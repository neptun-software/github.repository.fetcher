{
  "metadata": {
    "timestamp": 1736565302493,
    "page": 118,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "andreasfertig/cppinsights",
      "stars": 4161,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 2.9580078125,
          "content": "---\nLanguage:        Cpp\n# BasedOnStyle:  LLVM\nAccessModifierOffset: -4\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: true\nAlignConsecutiveDeclarations: true\nAlignEscapedNewlinesLeft: false\nAlignOperands:   true\nAlignTrailingComments: true\nAllowAllParametersOfDeclarationOnNextLine: false\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: true\nAllowShortFunctionsOnASingleLine: Inline\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: true\nBinPackArguments: false\nBinPackParameters: false\nBreakBeforeBraces: Custom\nBraceWrapping:   \n  AfterClass:     true\n  AfterControlStatement: false\n  AfterEnum:       true\n  AfterFunction:   true\n  AfterNamespace:  false\n  AfterObjCDeclaration: false\n  AfterStruct:     true\n  AfterUnion:      true\n  BeforeCatch:     false\n  BeforeElse:      false\n  IndentBraces:    false\nBreakBeforeBinaryOperators: None\nBreakBeforeInheritanceComma: false\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializersBeforeComma: true\nBreakStringLiterals: true\nColumnLimit:     120\nCommentPragmas:  '^ IWYU pragma:'\nConstructorInitializerAllOnOneLineOrOnePerLine: false\nConstructorInitializerIndentWidth: 0\nContinuationIndentWidth: 4\nCpp11BracedListStyle: true\nDerivePointerAlignment: false\nDisableFormat:   false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments : true\nForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]\n#IncludeCategories: \n#  - Regex:           '^\"(llvm|llvm-c|clang|clang-c)/'\n#    Priority:        2\n#  - Regex:           '^(<|\"(gtest|isl|json)/)'\n#   Priority:        3\n#   - Regex:           '.*'\n#    Priority:        1\nIncludeCategories: \n  - Regex:           '^<.*\\.h>'\n    Priority:        1\n  - Regex:           '^<.*'\n    Priority:        2\n  - Regex:           '.*'\n    Priority:        3\nIncludeIsMainRegex: '$'\nIndentCaseLabels: true\nIndentWidth:     4\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: true\nMacroBlockBegin: \"^[A-Z_]+_BEGIN$\"\nMacroBlockEnd: \"^[A-Z_]+_END$\"\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBlockIndentWidth: 2\nObjCSpaceAfterProperty: false\nObjCSpaceBeforeProtocolList: true\nPenaltyBreakBeforeFirstCallParameter: 19\nPenaltyBreakComment: 300\nPenaltyBreakFirstLessLess: 120\nPenaltyBreakString: 1000\nPenaltyExcessCharacter: 1000000\nPenaltyReturnTypeOnItsOwnLine: 60\nPointerAlignment: Left \nReflowComments:  true\nSortIncludes:    true\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: false\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeParens: Never\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 2\nSpacesInAngles:  false\nSpacesInContainerLiterals: true\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard:        Cpp11\nTabWidth:        4\nUseTab:          Never\n...\n"
        },
        {
          "name": ".clang-tidy",
          "type": "blob",
          "size": 1.767578125,
          "content": "Checks: '-*,clang-diagnostic-*,misc-*,-misc-unused-parameters,readability-identifier-naming,modernize-return-braced-init-list'\n#Checks: '-*,readability-identifier-naming,performance-*,modernize-use-*,misc-string-*,misc-use-after-move,misc-suspicious-*,misc-static-assert,misc-move-*,misc-macro-*,misc-dangling-handle,cppcoreguidelines-*,-cppcoreguidelines-pro-bounds-array-to-pointer-decay,-cppcoreguidelines-pro-type-reinterpret-cast'\nCheckOptions:\n  - { key: readability-identifier-naming.NamespaceCase,          value: lower_case }\n  - { key: readability-identifier-naming.ClassCase,              value: CamelCase  }\n  - { key: readability-identifier-naming.MemberCase,             value: CamelCase  }\n  - { key: readability-identifier-naming.MemberPrefix,           value: m          }\n  - { key: readability-identifier-naming.StructCase,             value: CamelCase  }\n  - { key: readability-identifier-naming.FunctionCase,           value: CamelCase  }\n  - { key: readability-identifier-naming.VariableCase,           value: camelBack  }\n  - { key: readability-identifier-naming.GlobalConstantCase,     value: UPPER_CASE }\n  - { key: readability-identifier-naming.EnumCase,               value: CamelCase  }\n  - { key: readability-identifier-naming.EnumPrefix,             value: 'E'        }\n  - { key: readability-identifier-naming.GlobalFunctionCase,     value: CamelCase  }\n  - { key: readability-identifier-naming.GlobalVariableCase,     value: CamelCase  }\n  - { key: readability-identifier-naming.GlobalVariablePrefix,   value: 'g'        }\n  - { key: readability-identifier-naming.ConstexprFunctionCase,  value: CamelCase  }\n  - { key: readability-identifier-naming.ConstexprMethodCase,    value: CamelCase  }\n  - { key: readability-identifier-naming.ConstexprVariableCase,  value: camelBack  }\n"
        },
        {
          "name": ".clang-tidy-ignore",
          "type": "blob",
          "size": 0.099609375,
          "content": "error: 'new' file not found\nerror: 'utility' file not found\nwarning: potentially unintended semicolon\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0087890625,
          "content": "build*/\r\n"
        },
        {
          "name": ".gitpod.yml",
          "type": "blob",
          "size": 0.373046875,
          "content": "# The Docker image to run your workspace in. Defaults to gitpod/workspace-full\nimage: andreasfertig/cppinsights-builder-gitpod:latest\nworkspaceLocation: \".\"\n\ntasks:\n    - init: \"mkdir /workspace/build && cd /workspace/build && cmake -G Ninja -DINSIGHTS_STATIC=Yes -DINSIGHTS_COVERAGE=No -DINSIGHTS_LLVM_CONFIG=/usr/bin/llvm-config /workspace/cppinsights && echo \\\"Run: ninja -j2\\\"\"\n"
        },
        {
          "name": "ASTHelpers.cpp",
          "type": "blob",
          "size": 26.439453125,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#include <algorithm>\n\n#include \"ASTHelpers.h\"\n#include \"CodeGenerator.h\"\n#include \"Insights.h\"\n#include \"InsightsHelpers.h\"\n#include \"InsightsStaticStrings.h\"\n#include \"InsightsStrCat.h\"\n//-----------------------------------------------------------------------------\n\nusing namespace std::literals;\n\nnamespace clang::insights::asthelpers {\nDeclStmt* _mkDeclStmt(std::span<Decl*> decls)\n{\n    const auto& ctx = GetGlobalAST();\n\n    auto dgRef = DeclGroupRef::Create(const_cast<ASTContext&>(ctx), decls.data(), decls.size());\n\n    return new(ctx) DeclStmt(dgRef, {}, {});\n}\n//-----------------------------------------------------------------------------\n\nBinaryOperator* Assign(const VarDecl* var, Expr* assignExpr)\n{\n    return Assign(mkDeclRefExpr(var), assignExpr);\n}\n//-----------------------------------------------------------------------------\n\nstatic BinaryOperator* mkBinaryOperator(Expr* lhs, Expr* rhs, BinaryOperator::Opcode opc, QualType resType)\n{\n    return BinaryOperator::Create(\n        GetGlobalAST(), lhs, rhs, opc, resType.getNonReferenceType(), VK_LValue, OK_Ordinary, {}, {});\n}\n//-----------------------------------------------------------------------------\n\nBinaryOperator* Assign(UnaryOperator* var, Expr* assignExpr)\n{\n    return mkBinaryOperator(var, assignExpr, BO_Assign, assignExpr->getType());\n}\n//-----------------------------------------------------------------------------\n\nBinaryOperator* Assign(MemberExpr* me, ValueDecl* field, Expr* assignExpr)\n{\n    return mkBinaryOperator(me, assignExpr, BO_Assign, field->getType());\n}\n//-----------------------------------------------------------------------------\n\nBinaryOperator* Assign(DeclRefExpr* declRef, ValueDecl* field, Expr* assignExpr)\n{\n    return Assign(AccessMember(declRef, field), field, assignExpr);\n}\n//-----------------------------------------------------------------------------\n\nBinaryOperator* Assign(DeclRefExpr* declRef, Expr* assignExpr)\n{\n    return mkBinaryOperator(declRef, assignExpr, BO_Assign, declRef->getType());\n}\n//-----------------------------------------------------------------------------\n\nBinaryOperator* Assign(Expr* var, Expr* assignExpr)\n{\n    return mkBinaryOperator(var, assignExpr, BO_Assign, assignExpr->getType());\n}\n//-----------------------------------------------------------------------------\n\nstatic UnaryOperator* mkUnaryOperator(const Expr* stmt, UnaryOperatorKind kind, QualType type)\n{\n    return UnaryOperator::Create(\n        GetGlobalAST(), const_cast<Expr*>(stmt), kind, type, VK_PRValue, OK_Ordinary, {}, false, {});\n}\n//-----------------------------------------------------------------------------\n\nUnaryOperator* Not(const Expr* stmt)\n{\n    return mkUnaryOperator(stmt, UO_LNot, stmt->getType());\n}\n//-----------------------------------------------------------------------------\n\nstatic UnaryOperator* mkReference(Expr* e, QualType t)\n{\n    return mkUnaryOperator(e, UO_AddrOf, t);\n}\n//-----------------------------------------------------------------------------\n\nUnaryOperator* Ref(const Expr* e)\n{\n    return mkReference(const_cast<Expr*>(e), e->getType());\n}\n//-----------------------------------------------------------------------------\n\nUnaryOperator* Ref(const ValueDecl* d)\n{\n    return Ref(mkDeclRefExpr(d));\n}\n//-----------------------------------------------------------------------------\n\nUnaryOperator* Dref(const Expr* stmt)\n{\n    return mkUnaryOperator(stmt, UO_Deref, stmt->getType());\n}\n//-----------------------------------------------------------------------------\n\nUnaryOperator* AddrOf(const Expr* stmt)\n{\n    return mkUnaryOperator(stmt, UO_AddrOf, stmt->getType());\n}\n//-----------------------------------------------------------------------------\n\nCallExpr* Call(const FunctionDecl* fd, ArrayRef<Expr*> params)\n{\n    return CallExpr::Create(GetGlobalAST(), mkDeclRefExpr(fd), params, fd->getType(), VK_LValue, {}, {});\n}\n//-----------------------------------------------------------------------------\n\nCallExpr* Call(MemberExpr* fd, ArrayRef<Expr*> params)\n{\n    return CallExpr::Create(GetGlobalAST(), fd, params, fd->getType(), VK_LValue, {}, {});\n}\n//-----------------------------------------------------------------------------\n\nCallExpr* Call(std::string_view name, ArrayRef<Expr*> args)\n{\n    params_vector params{};\n    params.reserve(args.size());\n\n    for(const auto& param : args) {\n        params.emplace_back(\"dummy\"sv, param->getType());\n    }\n\n    auto* freeFd = Function(name, VoidTy(), params);\n\n    return Call(freeFd, args);\n}\n//-----------------------------------------------------------------------------\n\nCXXTryStmt* Try(const Stmt* tryBody, CXXCatchStmt* catchAllBody)\n{\n    return CXXTryStmt::Create(\n        GetGlobalAST(), {}, const_cast<CompoundStmt*>(dyn_cast_or_null<CompoundStmt>(tryBody)), {catchAllBody});\n}\n//-----------------------------------------------------------------------------\n\nCXXCatchStmt* Catch(ArrayRef<Stmt*> body)\n{\n    CompoundStmt* compStmt = mkCompoundStmt(body);\n\n    return new(GetGlobalAST()) CXXCatchStmt({}, nullptr, compStmt);\n}\n//-----------------------------------------------------------------------------\n\nCXXCatchStmt* Catch(Stmt* body)\n{\n    return Catch(ArrayRef<Stmt*>{body});\n}\n//-----------------------------------------------------------------------------\n\nCXXThrowExpr* Throw(const Expr* expr)\n{\n    return new(GetGlobalAST()) CXXThrowExpr(const_cast<Expr*>(expr), VoidTy(), {}, false);\n}\n//-----------------------------------------------------------------------------\n\nUnaryExprOrTypeTraitExpr* Sizeof(QualType toType)\n{\n    const auto& ctx = GetGlobalAST();\n    return new(ctx) UnaryExprOrTypeTraitExpr(UETT_SizeOf, ctx.getTrivialTypeSourceInfo(toType), toType, {}, {});\n}\n//-----------------------------------------------------------------------------\n\nCXXStaticCastExpr* Cast(const Expr* toExpr, QualType toType)\n{\n    return StaticCast(toType, const_cast<Expr*>(toExpr), false);\n}\n//-----------------------------------------------------------------------------\n\nQualType Ptr(QualType srcType)\n{\n    return GetGlobalAST().getPointerType(srcType);\n}\n//-----------------------------------------------------------------------------\n\nCanQualType VoidTy()\n{\n    return GetGlobalAST().VoidTy;\n}\n//-----------------------------------------------------------------------------\n\nParenExpr* Paren(Expr* expr)\n{\n    return new(GetGlobalAST()) ParenExpr({}, {}, expr);\n}\n//-----------------------------------------------------------------------------\n\nQualType ContantArrayTy(QualType t, int size)\n{\n    return GetGlobalAST().getConstantArrayType(t,\n                                               llvm::APInt(32, size, false),\n                                               /*const Expr* SizeExpr*/ nullptr,\n                                               ArraySizeModifier::Normal,\n                                               0u);\n}\n//-----------------------------------------------------------------------------\n\nstatic QualType mkAnonVoidFunctionPointer()\n{\n    auto voidPtr = Ptr(VoidTy());\n\n    params_store params{{\"\"s, voidPtr}};\n\n    return Ptr(Function(\"\"sv, voidPtr, to_params_view(params))->getType());\n}\n//-----------------------------------------------------------------------------\n\nstatic FunctionDecl* CreateFunctionDecl(std::string_view funcName, params_vector params)\n{\n    return Function(funcName, VoidTy(), params);\n}\n//-----------------------------------------------------------------------------\n\nCXXStaticCastExpr* CastToVoidFunPtr(std::string_view name)\n{\n    return Cast(mkDeclRefExpr(CreateFunctionDecl(name, {})), mkAnonVoidFunctionPointer());\n}\n//-----------------------------------------------------------------------------\n\nCXXReinterpretCastExpr* ReinterpretCast(QualType toType, const Expr* toExpr, bool makePointer)\n{\n    auto& ctx = GetGlobalAST();\n\n    QualType sourceInfoToType = makePointer ? Ptr(toType) : toType;\n\n    return CXXReinterpretCastExpr::Create(ctx,\n                                          toType,\n                                          VK_LValue,\n                                          CK_BitCast,\n                                          const_cast<Expr*>(toExpr),\n                                          nullptr,\n                                          ctx.getTrivialTypeSourceInfo(sourceInfoToType),\n                                          {},\n                                          {},\n                                          {});\n}\n//-----------------------------------------------------------------------------\n\nCXXStaticCastExpr* StaticCast(QualType toType, const Expr* toExpr, bool makePointer)\n{\n    auto& ctx = GetGlobalAST();\n\n    QualType sourceInfoToType = makePointer ? Ptr(toType) : toType;\n\n    return CXXStaticCastExpr::Create(ctx,\n                                     toType,\n                                     VK_LValue,\n                                     CK_DerivedToBase,\n                                     const_cast<Expr*>(toExpr),\n                                     nullptr,\n                                     ctx.getTrivialTypeSourceInfo(sourceInfoToType),\n                                     {},\n                                     {},\n                                     {},\n                                     {});\n}\n//-----------------------------------------------------------------------------\n\nauto* mkLabelDecl(std::string_view name)\n{\n    auto& ctx = GetGlobalAST();\n\n    return LabelDecl::Create(const_cast<ASTContext&>(ctx), ctx.getTranslationUnitDecl(), {}, &ctx.Idents.get(name));\n}\n//-----------------------------------------------------------------------------\n\nLabelStmt* Label(std::string_view name)\n{\n    return new(GetGlobalAST()) LabelStmt({}, mkLabelDecl(name), nullptr);\n}\n//-----------------------------------------------------------------------------\n\nCompoundStmt* mkCompoundStmt(ArrayRef<Stmt*> bodyStmts, SourceLocation beginLoc, SourceLocation endLoc)\n{\n    return CompoundStmt::Create(GetGlobalAST(), bodyStmts, FPOptionsOverride{}, beginLoc, endLoc);\n}\n//-----------------------------------------------------------------------------\n\nIfStmt* If(const Expr* condition, ArrayRef<Stmt*> bodyStmts)\n{\n    return IfStmt::Create(GetGlobalAST(),\n                          {},\n                          IfStatementKind::Ordinary,\n                          nullptr,\n                          nullptr,\n                          const_cast<Expr*>(condition),\n                          {},\n                          {},\n                          mkCompoundStmt(bodyStmts),\n                          {},\n                          /*else*/ nullptr);\n}\n//-----------------------------------------------------------------------------\n\nIntegerLiteral* Int32(uint64_t value)\n{\n    auto&       ctx = GetGlobalAST();\n    llvm::APInt v{32, value, true};\n\n    return IntegerLiteral::Create(ctx, v, ctx.IntTy, {});\n}\n//-----------------------------------------------------------------------------\n\nMemberExpr* AccessMember(const Expr* expr, const ValueDecl* vd, bool isArrow)\n{\n    return MemberExpr::CreateImplicit(GetGlobalAST(),\n                                      const_cast<Expr*>(expr),\n                                      isArrow,\n                                      const_cast<ValueDecl*>(vd),\n                                      vd->getType().getNonReferenceType(),\n                                      VK_LValue,\n                                      OK_Ordinary);\n}\n//-----------------------------------------------------------------------------\n\nBinaryOperator* Equal(Expr* var, Expr* assignExpr)\n{\n    return mkBinaryOperator(var, assignExpr, BO_EQ, GetGlobalAST().BoolTy);\n}\n//-----------------------------------------------------------------------------\n\nBinaryOperator* Plus(Expr* var, Expr* assignExpr)\n{\n    return mkBinaryOperator(var, assignExpr, BO_Add, var->getType());\n}\n//-----------------------------------------------------------------------------\n\nGotoStmt* Goto(std::string_view labelName)\n{\n    return new(GetGlobalAST()) GotoStmt(mkLabelDecl(labelName), {}, {});\n}\n//-----------------------------------------------------------------------------\n\nParmVarDecl* Parameter(const FunctionDecl* fd, std::string_view name, QualType type)\n{\n    auto& ctx = GetGlobalAST();\n\n    return ParmVarDecl::Create(const_cast<ASTContext&>(ctx),\n                               const_cast<FunctionDecl*>(fd),\n                               {},\n                               {},\n                               &ctx.Idents.get(name),\n                               type,\n                               nullptr,\n                               SC_None,\n                               nullptr);\n}\n//-----------------------------------------------------------------------------\n\nstatic auto*\nFunctionBase(std::string_view name, QualType returnType, const params_vector& parameters, DeclContext* declCtx)\n{\n    auto&                    ctx = GetGlobalAST();\n    SmallVector<QualType, 8> argTypes{};\n\n    for(const auto& [_, type] : parameters) {\n        argTypes.push_back(type);\n    }\n\n    FunctionDecl* fdd = FunctionDecl::Create(\n        const_cast<ASTContext&>(ctx),\n        declCtx,\n        {},\n        {},\n        &ctx.Idents.get(name),\n        ctx.getFunctionType(returnType, ArrayRef<QualType>{argTypes}, FunctionProtoType::ExtProtoInfo{}),\n        nullptr,\n        SC_None,  // SC_Static,\n        false,\n        false,\n        false,\n        ConstexprSpecKind::Unspecified,\n        nullptr);\n    fdd->setImplicit(true);\n\n    SmallVector<ParmVarDecl*, 8> paramVarDecls{};\n\n    for(const auto& [name, type] : parameters) {\n        ParmVarDecl* param = Parameter(fdd, name, type);\n        param->setScopeInfo(0, 0);\n        paramVarDecls.push_back(param);\n    }\n\n    fdd->setParams(paramVarDecls);\n\n    return fdd;\n}\n\nFunctionDecl* Function(std::string_view name, QualType returnType, const params_vector& parameters)\n{\n    return FunctionBase(name, returnType, parameters, GetGlobalAST().getTranslationUnitDecl());\n}\n//-----------------------------------------------------------------------------\n\nauto* mkStdFunctionDecl(std::string_view name, QualType returnType, const params_vector& parameters)\n{\n    auto&          ctx   = GetGlobalAST();\n    NamespaceDecl* stdNs = NamespaceDecl::Create(const_cast<ASTContext&>(ctx),\n                                                 ctx.getTranslationUnitDecl(),\n                                                 false,\n                                                 {},\n                                                 {},\n                                                 &ctx.Idents.get(\"std\"),\n                                                 nullptr,\n                                                 false);\n\n    return FunctionBase(name, returnType, parameters, stdNs);\n}\n//-----------------------------------------------------------------------------\n\nDeclRefExpr* mkDeclRefExpr(const ValueDecl* vd)\n{\n    return DeclRefExpr::Create(GetGlobalAST(),\n                               NestedNameSpecifierLoc{},\n                               SourceLocation{},\n                               const_cast<ValueDecl*>(vd),\n                               false,\n                               SourceLocation{},\n                               vd->getType(),\n                               VK_LValue,\n                               nullptr,\n                               nullptr,\n                               NOUR_None);\n}\n//-----------------------------------------------------------------------------\n\nImplicitCastExpr* CastLToRValue(const VarDecl* vd)\n{\n    return ImplicitCastExpr::Create(\n        GetGlobalAST(), vd->getType(), CK_LValueToRValue, mkDeclRefExpr(vd), {}, VK_LValue, {});\n}\n//-----------------------------------------------------------------------------\n\nCXXMemberCallExpr* CallMemberFun(Expr* memExpr, QualType retType /*, const std::vector<Expr*>& params*/)\n{\n    return CXXMemberCallExpr::Create(GetGlobalAST(), memExpr, /*params*/ {}, retType, VK_LValue, {}, {});\n}\n//-----------------------------------------------------------------------------\n\nReturnStmt* Return(Expr* stmt)\n{\n    return ReturnStmt::Create(GetGlobalAST(), {}, stmt, nullptr);\n}\n//-----------------------------------------------------------------------------\n\nReturnStmt* Return(const ValueDecl* stmt)\n{\n    return Return(mkDeclRefExpr(stmt));\n}\n//-----------------------------------------------------------------------------\n\nSwitchStmt* Switch(Expr* stmt)\n{\n    return SwitchStmt::Create(GetGlobalAST(), nullptr, nullptr, stmt, {}, {});\n}\n//-----------------------------------------------------------------------------\n\nBreakStmt* Break()\n{\n    return new(GetGlobalAST()) BreakStmt(SourceLocation{});\n}\n//-----------------------------------------------------------------------------\n\nCaseStmt* Case(int value, Stmt* stmt)\n{\n    auto* caseStmt = CaseStmt::Create(GetGlobalAST(), Int32(value), nullptr, {}, {}, {});\n    caseStmt->setSubStmt(stmt);\n\n    return caseStmt;\n}\n//-----------------------------------------------------------------------------\n\nVarDecl* Variable(std::string_view name, QualType type, DeclContext* dc)\n{\n    auto& ctx = GetGlobalAST();\n\n    if(nullptr == dc) {\n        dc = GetGlobalAST().getTranslationUnitDecl();\n    }\n\n    return VarDecl::Create(const_cast<ASTContext&>(ctx), dc, {}, {}, &ctx.Idents.get(name), type, nullptr, SC_None);\n}\n//-----------------------------------------------------------------------------\n\nNullStmt* mkNullStmt()\n{\n    static auto* nstmt = new(GetGlobalAST()) NullStmt({}, false);\n    return nstmt;\n}\n//-----------------------------------------------------------------------------\n\nStmt* Comment(std::string_view comment)\n{\n    return new(GetGlobalAST()) CppInsightsCommentStmt{comment};\n}\n//-----------------------------------------------------------------------------\n\nCXXRecordDecl* Struct(std::string_view name)\n{\n    auto getRecord = [&] {\n        auto& ctx = GetGlobalAST();\n\n        return CXXRecordDecl::Create(ctx,\n#if IS_CLANG_NEWER_THAN(17)\n                                     TagTypeKind::Struct\n#else\n                                     TTK_Struct\n#endif\n                                     ,\n                                     ctx.getTranslationUnitDecl(),\n                                     {},\n                                     {},\n                                     &ctx.Idents.get(name),\n                                     nullptr,\n                                     false);\n    };\n\n    auto* rd = getRecord();\n    rd->startDefinition();\n\n    // A \"normal\" struct has itself attached as a Decl. To make everything work do the same thing here\n    auto* selfDecl = getRecord();\n    selfDecl->setAccess(AS_public);\n    rd->addDecl(selfDecl);\n\n    return rd;\n}\n//-----------------------------------------------------------------------------\n\nFieldDecl* mkFieldDecl(DeclContext* dc, std::string_view name, QualType type)\n{\n    auto& ctx = GetGlobalAST();\n    auto* fieldDecl =\n        FieldDecl::Create(ctx, dc, {}, {}, &ctx.Idents.get(name), type, nullptr, nullptr, false, ICIS_NoInit);\n    fieldDecl->setAccess(AS_public);\n\n    return fieldDecl;\n}\n//-----------------------------------------------------------------------------\n\nInitListExpr* InitList(ArrayRef<Expr*> initExprs, QualType t)\n{\n    auto* initList = new(GetGlobalAST()) InitListExpr(GetGlobalAST(), SourceLocation{}, initExprs, SourceLocation{});\n    initList->setType(t);\n\n    return initList;\n}\n//-----------------------------------------------------------------------------\n\nArraySubscriptExpr* ArraySubscript(const Expr* lhs, uint64_t index, QualType type)\n{\n    return new(GetGlobalAST()) ArraySubscriptExpr(\n        const_cast<Expr*>(lhs), Int32(index), type, ExprValueKind::VK_LValue, ExprObjectKind::OK_Ordinary, {});\n}\n//-----------------------------------------------------------------------------\n\nparams_vector to_params_view(params_store& params)\n{\n    params_vector ret{};\n    ret.reserve(params.size());\n\n    for(const auto& [name, type] : params) {\n        ret.emplace_back(name, type);\n    }\n\n    return ret;\n}\n//-----------------------------------------------------------------------------\n\nDeclRefExpr* mkVarDeclRefExpr(std::string_view name, QualType type)\n{\n    auto* internalThisVar = Variable(name, type);\n    auto* declRef         = mkDeclRefExpr(internalThisVar);\n\n    return declRef;\n}\n//-----------------------------------------------------------------------------\n\nstatic CallExpr* CallConstructor(QualType        ctorType,\n                                 DeclRefExpr*    lhsDeclRef,\n                                 Expr*           lhsMemberExpr,\n                                 ArrayRef<Expr*> callParams,\n                                 DoCast          doCast,\n                                 AsReference     asReference)\n{\n    if(nullptr == lhsMemberExpr) {\n        lhsMemberExpr = lhsDeclRef;\n    }\n\n    auto* callCtor =\n        CreateFunctionDecl(StrCat(\"Constructor_\"sv, GetName(ctorType)), {{kwInternalThis, lhsDeclRef->getType()}});\n\n    SmallVector<Expr*, 8> modCallParams{};\n\n    if(DoCast::Yes == doCast) {\n        modCallParams.push_back(StaticCast(lhsDeclRef->getType(), lhsDeclRef, false));\n\n    } else {\n        if(AsReference::Yes == asReference) {\n            modCallParams.push_back(Ref(lhsMemberExpr));\n        } else {\n            modCallParams.push_back(lhsMemberExpr);\n        }\n    }\n\n    modCallParams.append(callParams.begin(), callParams.end());\n\n    return Call(callCtor, modCallParams);\n}\n//-----------------------------------------------------------------------------\n\nCallExpr* CallConstructor(QualType         ctorType,\n                          QualType         lhsType,\n                          const FieldDecl* fieldDecl,\n                          ArrayRef<Expr*>  callParams,\n                          DoCast           doCast,\n                          AsReference      asReference)\n{\n    auto* lhsDeclRef = mkVarDeclRefExpr(kwInternalThis, lhsType);\n    Expr* lhsMemberExpr{};\n\n    if(DoCast::No == doCast) {\n        lhsMemberExpr = AccessMember(lhsDeclRef, fieldDecl);\n    }\n\n    return CallConstructor(ctorType, lhsDeclRef, lhsMemberExpr, callParams, doCast, asReference);\n}\n//-----------------------------------------------------------------------------\n\nCallExpr* CallConstructor(QualType        ctorType,\n                          const VarDecl*  varDecl,\n                          ArrayRef<Expr*> callParams,\n                          DoCast          doCast,\n                          AsReference     asReference)\n{\n    auto* lhsDeclRef = mkDeclRefExpr(varDecl);\n\n    return CallConstructor(ctorType, lhsDeclRef, nullptr, callParams, doCast, asReference);\n}\n//-----------------------------------------------------------------------------\n\nCXXBoolLiteralExpr* Bool(bool b)\n{\n    auto& ctx = GetGlobalAST();\n    return new(ctx) CXXBoolLiteralExpr(b, ctx.BoolTy, {});\n}\n//-----------------------------------------------------------------------------\n\nCallExpr* CallDestructor(const VarDecl* varDecl)\n{\n    auto* lhsDeclRef = mkDeclRefExpr(varDecl);\n\n    auto* callDtor = CreateFunctionDecl(StrCat(\"Destructor_\"sv, GetName(varDecl->getType())),\n                                        {{kwInternalThis, lhsDeclRef->getType()}});\n\n    return Call(callDtor, {Ref(lhsDeclRef)});\n}\n//-----------------------------------------------------------------------------\n\nQualType Typedef(std::string_view name, QualType underlayingType)\n{\n    auto& ctx  = GetGlobalAST();\n    auto* type = TypedefDecl::Create(const_cast<ASTContext&>(ctx),\n                                     ctx.getTranslationUnitDecl(),\n                                     {},\n                                     {},\n                                     &ctx.Idents.get(name),\n                                     ctx.getTrivialTypeSourceInfo(underlayingType));\n\n    return ctx.getTypeDeclType(type);\n}\n//-----------------------------------------------------------------------------\n\nQualType GetRecordDeclType(const CXXMethodDecl* md)\n{\n    return QualType(md->getParent()->getTypeForDecl(), 0);\n}\n//-----------------------------------------------------------------------------\n\nQualType GetRecordDeclType(const RecordDecl* rd)\n{\n    return QualType(rd->getTypeForDecl(), 0);\n}\n//-----------------------------------------------------------------------------\n\nCXXNewExpr* New(ArrayRef<Expr*> placementArgs, const Expr* expr, QualType t)\n{\n    auto& ctx = GetGlobalAST();\n\n    return CXXNewExpr::Create(ctx,\n                              false,\n                              nullptr,\n                              nullptr,\n                              true,\n                              false,\n                              placementArgs,\n                              SourceRange{},\n                              std::optional<Expr*>{},\n#if IS_CLANG_NEWER_THAN(17)\n                              CXXNewInitializationStyle::Parens\n#else\n                              CXXNewExpr::CallInit\n#endif\n                              ,\n                              const_cast<Expr*>(expr),\n                              Ptr(t),\n                              ctx.getTrivialTypeSourceInfo(t),\n                              SourceRange{},\n                              SourceRange{});\n}\n//-----------------------------------------------------------------------------\n\nBinaryOperator* Mul(Expr* lhs, Expr* rhs)\n{\n    return mkBinaryOperator(lhs, rhs, BinaryOperator::Opcode::BO_Mul, lhs->getType());\n}\n//-----------------------------------------------------------------------------\n\nBinaryOperator* And(VarDecl* lhs, Expr* rhs)\n{\n    return mkBinaryOperator(mkDeclRefExpr(lhs), rhs, BinaryOperator::Opcode::BO_And, lhs->getType());\n}\n//-----------------------------------------------------------------------------\n\nvoid StmtsContainer::AddBodyStmts(Stmt* body)\n{\n    if(auto* b = dyn_cast_or_null<CompoundStmt>(body)) {\n        auto children = b->children();\n        mStmts.append(children.begin(), children.end());\n    } else if(not isa<NullStmt>(body)) {\n        mStmts.push_back(body);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid ReplaceNode(Stmt* parent, Stmt* oldNode, Stmt* newNode)\n{\n    std::replace(parent->child_begin(), parent->child_end(), oldNode, newNode);\n}\n//-----------------------------------------------------------------------------\n\nSmallVector<Expr*, 5> ArgsToExprVector(const Expr* expr)\n{\n    if(const auto* ctorExpr = dyn_cast_or_null<CXXConstructExpr>(expr)) {\n        auto mutableCtorExpr = const_cast<CXXConstructExpr*>(ctorExpr);\n\n        return {mutableCtorExpr->arg_begin(), mutableCtorExpr->arg_end()};\n    }\n\n    return {};\n}\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights::asthelpers\n"
        },
        {
          "name": "ASTHelpers.h",
          "type": "blob",
          "size": 6.4970703125,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#ifndef INSIGHTS_AST_HELPERS_H\n#define INSIGHTS_AST_HELPERS_H\n//-----------------------------------------------------------------------------\n\n#include <array>\n#include <span>\n#include <string_view>\n#include <vector>\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\n#include \"InsightsStrongTypes.h\"\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights::asthelpers {\nvoid ReplaceNode(Stmt* parent, Stmt* oldNode, Stmt* newNode);\n\nusing params_vector = std::vector<std::pair<std::string_view, QualType>>;\nusing params_store  = std::vector<std::pair<std::string, QualType>>;\n\nparams_vector to_params_view(params_store& params);\n\nQualType GetRecordDeclType(const CXXMethodDecl* md);\nQualType GetRecordDeclType(const RecordDecl* rd);\n\nDeclRefExpr* mkVarDeclRefExpr(std::string_view name, QualType type);\n\nSTRONG_BOOL(DoCast);\nSTRONG_BOOL(AsReference);\n\nCallExpr* CallConstructor(QualType         ctorType,\n                          QualType         lhsType,\n                          const FieldDecl* fieldDecl,\n                          ArrayRef<Expr*>  callParams,\n                          DoCast           doCast      = DoCast::No,\n                          AsReference      asReference = AsReference::No);\n\nCallExpr* CallConstructor(QualType        ctorType,\n                          const VarDecl*  fieldDecl,\n                          ArrayRef<Expr*> callParams,\n                          DoCast          doCast      = DoCast::No,\n                          AsReference     asReference = AsReference::No);\n\nCXXBoolLiteralExpr* Bool(bool b);\nCallExpr*           CallDestructor(const VarDecl* fieldDecl);\nCXXNewExpr*         New(ArrayRef<Expr*> placementArgs, const Expr* expr, QualType t);\nBinaryOperator*     Mul(Expr* lhs, Expr* rhs);\nBinaryOperator*     And(VarDecl* lhs, Expr* rhs);\nQualType            Typedef(std::string_view name, QualType underlayingType);\n\nSmallVector<Expr*, 5> ArgsToExprVector(const Expr* expr);\n\n///! A helper type to have a container for ArrayRef\nstruct StmtsContainer\n{\n    SmallVector<Stmt*, 64> mStmts{};\n\n    StmtsContainer() = default;\n    StmtsContainer(std::initializer_list<const Stmt*> stmts)\n    {\n        for(const auto& stmt : stmts) {\n            Add(stmt);\n        }\n    }\n\n    void clear() { mStmts.clear(); }\n\n    void Add(const Stmt* stmt)\n    {\n        if(stmt) {\n            mStmts.push_back(const_cast<Stmt*>(stmt));\n        }\n    }\n\n    void AddBodyStmts(Stmt* body);\n\n    operator ArrayRef<Stmt*>() { return mStmts; }\n};\n//-----------------------------------------------------------------------------\n\ntemplate<typename... Dcls>\nDeclStmt* mkDeclStmt(Dcls... dcls)\n{\n    std::array<Decl*, sizeof...(dcls)> decls{dcls...};\n\n    DeclStmt* _mkDeclStmt(std::span<Decl*> decls);\n    return _mkDeclStmt(decls);\n}\n\nStmt*          Comment(std::string_view comment);\nVarDecl*       Variable(std::string_view name, QualType type, DeclContext* dc = nullptr);\nCXXRecordDecl* Struct(std::string_view name);\nReturnStmt*    Return(Expr* stmt = nullptr);\nReturnStmt*    Return(const ValueDecl* stmt);\n\nCompoundStmt* mkCompoundStmt(ArrayRef<Stmt*> bodyStmts, SourceLocation beginLoc = {}, SourceLocation endLoc = {});\nDeclRefExpr*  mkDeclRefExpr(const ValueDecl* vd);\nNullStmt*     mkNullStmt();\nFieldDecl*    mkFieldDecl(DeclContext* dc, std::string_view name, QualType type);\n\nParenExpr*                Paren(Expr*);\nQualType                  ContantArrayTy(QualType t, int size);\nInitListExpr*             InitList(ArrayRef<Expr*> initExprs, QualType t);\nArraySubscriptExpr*       ArraySubscript(const Expr* lhs, uint64_t index, QualType type);\nMemberExpr*               AccessMember(const Expr* expr, const ValueDecl* vd, bool isArrow = true);\nCXXMemberCallExpr*        CallMemberFun(Expr* memExpr, QualType retType);\nImplicitCastExpr*         CastLToRValue(const VarDecl* vd);\nFunctionDecl*             Function(std::string_view name, QualType returnType, const params_vector& parameters);\nParmVarDecl*              Parameter(const FunctionDecl* fd, std::string_view name, QualType type);\nBinaryOperator*           Assign(DeclRefExpr* declRef, ValueDecl* field, Expr* assignExpr);\nBinaryOperator*           Assign(MemberExpr* me, ValueDecl* field, Expr* assignExpr);\nBinaryOperator*           Assign(DeclRefExpr* declRef, Expr* assignExpr);\nBinaryOperator*           Assign(const VarDecl* var, Expr* assignExpr);\nBinaryOperator*           Assign(UnaryOperator* var, Expr* assignExpr);\nBinaryOperator*           Assign(Expr* var, Expr* assignExpr);\nBinaryOperator*           Equal(Expr* var, Expr* assignExpr);\nBinaryOperator*           Plus(Expr* var, Expr* assignExpr);\nCXXReinterpretCastExpr*   ReinterpretCast(QualType toType, const Expr* toExpr, bool makePointer = false);\nCXXStaticCastExpr*        StaticCast(QualType toType, const Expr* toExpr, bool makePointer = false);\nCXXStaticCastExpr*        CastToVoidFunPtr(std::string_view name);\nCXXStaticCastExpr*        Cast(const Expr* toExpr, QualType toType);\nIntegerLiteral*           Int32(uint64_t value);\nIfStmt*                   If(const Expr* condition, ArrayRef<Stmt*> bodyStmts);\nSwitchStmt*               Switch(Expr* stmt);\nCaseStmt*                 Case(int value, Stmt* stmt);\nBreakStmt*                Break();\nLabelStmt*                Label(std::string_view name);\nGotoStmt*                 Goto(std::string_view labelName);\nUnaryOperator*            Not(const Expr* stmt);\nUnaryOperator*            Ref(const Expr* e);\nUnaryOperator*            Ref(const ValueDecl* d);\nUnaryOperator*            Dref(const Expr* stmt);\nUnaryOperator*            AddrOf(const Expr* stmt);\nCallExpr*                 Call(const FunctionDecl* fd, ArrayRef<Expr*> params);\nCallExpr*                 Call(MemberExpr* fd, ArrayRef<Expr*> params);\nCallExpr*                 Call(std::string_view name, ArrayRef<Expr*> args);\nCXXTryStmt*               Try(const Stmt* tryBody, CXXCatchStmt* catchAllBody);\nCXXCatchStmt*             Catch(Stmt* body);\nCXXCatchStmt*             Catch(ArrayRef<Stmt*> body);\nCXXThrowExpr*             Throw(const Expr* expr = nullptr);\nUnaryExprOrTypeTraitExpr* Sizeof(QualType toType);\nQualType                  Ptr(QualType srcType);\nCanQualType               VoidTy();\n\n}  // namespace clang::insights::asthelpers\n\n#endif /* INSIGHTS_AST_HELPERS_H */\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 32.771484375,
          "content": "cmake_minimum_required(VERSION 3.20 FATAL_ERROR)\n\n# For better control enable MSVC_RUNTIME_LIBRARY target property\n# see https://cmake.org/cmake/help/latest/policy/CMP0091.html\nif(POLICY CMP0091)\n  cmake_policy(SET CMP0091 NEW)\nendif()\n\nset(CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_STANDARD 20)\n\ninclude(CMakePrintHelpers)\n\n# TODO: enable those options on Windows once tested\nif(NOT WIN32)\n    option(DEBUG                        \"Enable debug\"               Off)\n    option(INSIGHTS_STRIP               \"Strip insight after build\"  On )\n    option(INSIGHTS_TIDY                \"Run clang-tidy\"             Off)\n    option(INSIGHTS_IWYU                \"Run include-what-you-use\"   Off)\n    option(INSIGHTS_USE_LIBCPP          \"Enable code coverage\"       Off)\nelse()\n    set(DEBUG                         Off)\n    set(INSIGHTS_STRIP                Off)\n    set(INSIGHTS_TIDY                 Off)\n    set(INSIGHTS_IWYU                 Off)\n    set(INSIGHTS_USE_LIBCPP           Off)\nendif()\n\noption(INSIGHTS_USE_SYSTEM_INCLUDES \"Elevate to system includes\" On )\noption(INSIGHTS_COVERAGE            \"Enable code coverage\"       Off)\noption(INSIGHTS_STATIC              \"Use static linking\"         Off)\n\nset(INSIGHTS_LLVM_CONFIG \"llvm-config\" CACHE STRING \"LLVM config executable to use\")\n\nset(INSIGHTS_MIN_LLVM_MAJOR_VERSION 18)\nset(INSIGHTS_MIN_LLVM_VERSION ${INSIGHTS_MIN_LLVM_MAJOR_VERSION}.0)\n\nif(CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)\n  set(BUILD_INSIGHTS_OUTSIDE_LLVM On)\nelse()\n  # used when build inside the clang tool/extra folder\n  set(BUILD_INSIGHTS_OUTSIDE_LLVM Off)\n  include_directories(BEFORE\n    ${LLVM_SOURCE_DIR}/include\n    ${LLVM_EXTERNAL_CLANG_SOURCE_DIR}/include\n    ${LLVM_BINARY_DIR}/include\n    ${LLVM_BINARY_DIR}/tools/clang/include\n  )\n\nendif()\n\nif(INSIGHTS_COVERAGE OR DEBUG)\n    set(INSIGHTS_STRIP Off)\nendif()\n\nif (NOT BUILD_INSIGHTS_OUTSIDE_LLVM AND WIN32)\n  message(FATAL_ERROR \"Building inside LLVM on Windows was never tested\")\nendif ()\n\nif (BUILD_INSIGHTS_OUTSIDE_LLVM)\n    project(cpp-insights CXX)\nendif()\n\nif(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n    set(IS_GNU On)\nelse()\n    set(IS_GNU Off)\nendif()\n\nif(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"Clang\")\n    set(IS_CLANG On)\nelse()\n    set(IS_CLANG Off)\nendif()\n\nif(IS_GNU AND WIN32)\n    message(FATAL_ERROR \"GCC on Windows was never tested\")\nendif()\n\n# Clang On Windows mimics MSVC, but sometimes we need to know\n# if we really have CL.exe (not clang-cl.exe)\nif(NOT IS_CLANG AND MSVC)\n    set(IS_MSVC_CL 1)\nendif()\n\n# cmake_print_variables(\n#     CMAKE_CXX_COMPILER_ID\n#     BUILD_INSIGHTS_OUTSIDE_LLVM\n#     IS_CLANG\n#     IS_GNU\n#     IS_MSVC_CL\n#     MSVC)\n\nif (MSVC)\n  # For MSVC, CMake sets certain flags to defaults we want to override.\n  # This replacement code is taken from sample in the CMake Wiki at\n  # https://gitlab.kitware.com/cmake/community/wikis/FAQ#dynamic-replace.\n  foreach (flag_var\n         CMAKE_CXX_FLAGS CMAKE_CXX_FLAGS_DEBUG CMAKE_CXX_FLAGS_RELEASE\n         CMAKE_CXX_FLAGS_MINSIZEREL CMAKE_CXX_FLAGS_RELWITHDEBINFO)\n    string(REPLACE \"/MD\" \"\" ${flag_var} \"${${flag_var}}\")\n\n    string(REPLACE \"/EHsc\" \"\" ${flag_var} \"${${flag_var}}\")\n\n    string(REPLACE \"/GR\" \"\" ${flag_var} \"${${flag_var}}\")\n  endforeach()\nendif()\n\nif (BUILD_INSIGHTS_OUTSIDE_LLVM)\n    function(check_compiler COMPILER version)\n        if(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"${COMPILER}\")\n            if (CMAKE_CXX_COMPILER_VERSION VERSION_LESS ${version})\n                message(FATAL_ERROR \"${COMPILER} version must be at least ${version}!\")\n            endif()\n\n            set(HAVE_COMPILER On PARENT_SCOPE)\n        endif()\n    endfunction(check_compiler)\n\n    check_compiler(\"GNU\" 7.3)\n    check_compiler(\"Clang\" 6.0)\n    check_compiler(\"MSVC\" 19.25.0.0)\n\n    if(NOT HAVE_COMPILER)\n        message(WARNING \"You are using an unsupported compiler! Compilation has only been tested with Clang and GCC.\")\n    endif()\n\n\n    if(NOT DEFINED INSIGHTS_VERSION_MAJOR)\n      set(INSIGHTS_VERSION_MAJOR 0)\n    endif()\n    if(NOT DEFINED INSIGHTS_VERSION_MINOR)\n      set(INSIGHTS_VERSION_MINOR 1)\n    endif()\n    if(NOT DEFINED INSIGHTS_VERSION_PATCH)\n      set(INSIGHTS_VERSION_PATCH 0)\n    endif()\n    if(NOT DEFINED INSIGHTS_VERSION_SUFFIX)\n      set(INSIGHTS_VERSION_SUFFIX git)\n    endif()\n\n    if(NOT INSIGHTS_PACKAGE_VERSION)\n        set(INSIGHTS_PACKAGE_VERSION \"${INSIGHTS_VERSION_MAJOR}.${INSIGHTS_VERSION_MINOR}.${INSIGHTS_VERSION_PATCH}${INSIGHTS_VERSION_SUFFIX}\")\n    endif()\n\n\n    # Find LLVM Config binary for LLVM\n    # If you're on debian, go to http://llvm.org/apt/ and install the development\n    # release of LLVM (all packages).\n    # If you're on Windows, build LLVM from scratch,\n    # see Readme_Windows.md instructions.\n    find_program(LLVM_CONFIG_PATH \"${INSIGHTS_LLVM_CONFIG}\")\n    if(NOT LLVM_CONFIG_PATH)\n        message(FATAL_ERROR \"llvm-config not found -- ${LLVM_CONFIG_PATH}: ${INSIGHTS_LLVM_CONFIG}\")\n    endif()\n\n    if(INSIGHTS_STATIC)\n        if(APPLE)\n            message(STATUS \"Static linking may not be possible on OSX\")\n        else()\n            set(LIB_TYPE \"--link-static\")\n        endif()\n\n        if(WIN32)\n            add_definitions(/MT)\n        else()\n            set(CMAKE_EXE_LINKER_FLAGS  \"${CMAKE_EXE_LINKER_FLAGS} -static\")\n        endif()\n    endif()\n\n    # This function saves the output of the llvm-config command with the given\n    # switch to the variable named VARNAME.\n    #\n    # Example usage: llvm_config(LLVM_CXXFLAGS \"--cxxflags\")\n    function(llvm_config VARNAME switch)\n        set(CONFIG_COMMAND \"${LLVM_CONFIG_PATH}\" \"${switch}\")\n\n        execute_process(\n            COMMAND ${CONFIG_COMMAND} ${LIB_TYPE}\n            RESULT_VARIABLE HAD_ERROR\n            OUTPUT_VARIABLE CONFIG_OUTPUT\n        )\n\n        if (HAD_ERROR)\n            string(REPLACE \";\" \" \" CONFIG_COMMAND_STR \"${CONFIG_COMMAND}\")\n            message(STATUS \"${CONFIG_COMMAND_STR}\")\n            message(FATAL_ERROR \"llvm-config failed with status ${HAD_ERROR}\")\n        endif()\n\n        # replace linebreaks with semicolon\n        string(REGEX REPLACE\n            \"[ \\t]*[\\r\\n]+[ \\t]*\" \";\"\n            CONFIG_OUTPUT ${CONFIG_OUTPUT})\n\n        if(INSIGHTS_USE_SYSTEM_INCLUDES)\n            # make all includes system include to prevent the compiler to warn about issues in LLVM/Clang\n            if(NOT WIN32)\n                string(REGEX REPLACE \"-I\" \"-isystem\" CONFIG_OUTPUT \"${CONFIG_OUTPUT}\")\n            else()\n                if(IS_MSVC_CL)\n                    # See https://devblogs.microsoft.com/cppblog/broken-warnings-theory/\n                    string(REGEX REPLACE \"-I\" \"/external:I \" CONFIG_OUTPUT \"${CONFIG_OUTPUT}\")\n                endif()\n            endif()\n        endif()\n\n        # remove certain options clang doesn't like\n        if(IS_CLANG)\n            string(REGEX REPLACE \"-Wl,--no-keep-files-mapped\" \"\" CONFIG_OUTPUT \"${CONFIG_OUTPUT}\")\n            string(REGEX REPLACE \"-Wl,--no-map-whole-files\" \"\" CONFIG_OUTPUT \"${CONFIG_OUTPUT}\")\n            string(REGEX REPLACE \"-fuse-ld=gold\" \"\" CONFIG_OUTPUT \"${CONFIG_OUTPUT}\")\n        elseif(IS_GNU)\n            string(REGEX REPLACE \"-Wcovered-switch-default\" \"\" CONFIG_OUTPUT \"${CONFIG_OUTPUT}\")\n            string(REGEX REPLACE \"-Wstring-conversion\" \"\" CONFIG_OUTPUT \"${CONFIG_OUTPUT}\")\n            string(REGEX REPLACE \"-Werror=unguarded-availability-new\" \"\" CONFIG_OUTPUT \"${CONFIG_OUTPUT}\")\n            string(REGEX REPLACE \"-Wno-unknown-warning-option\" \"\" CONFIG_OUTPUT \"${CONFIG_OUTPUT}\")\n            string(REGEX REPLACE \"-Wno-unused-command-line-argument\" \"\" CONFIG_OUTPUT \"${CONFIG_OUTPUT}\")\n        endif()\n\n        # Since Clang 10 of ziglang C++14 is set\n        string(REGEX REPLACE \"-std[:=]+c\\\\+\\\\+[0-9][0-9]\" \"\" CONFIG_OUTPUT \"${CONFIG_OUTPUT}\")\n\n        # make result available outside\n        set(${VARNAME} ${CONFIG_OUTPUT} PARENT_SCOPE)\n\n        # Optionally output the configured value\n        message(STATUS \"llvm_config(${VARNAME})=>${CONFIG_OUTPUT}\")\n\n        # cleanup\n        unset(CONFIG_COMMAND)\n    endfunction(llvm_config)\n\n    llvm_config(LLVM_CXXFLAGS \"--cxxflags\")\n    llvm_config(LLVM_LDFLAGS \"--ldflags\")\n\n    llvm_config(LLVM_LIBS2 \"--libs\")\n    if(WIN32)\n        # libs list separated with \" \" (space).\n        # CMake does not understand list with spaces,\n        # but instead requires ; (semicolon).\n        # Use \".lib \" as string to replace instead of single \" \" (space)\n        # since LLVM/Clang libraries can be installed into folder\n        # with spaces (e.g., C:\\Program Files (x86)\\LLVM\\bin)\n        string(REPLACE \".lib \" \".lib;\" LLVM_LIBS \"${LLVM_LIBS2}\")\n    else()\n        set(LLVM_LIBS ${LLVM_LIBS2})\n    endif()\n\n    llvm_config(LLVM_LIBDIR \"--libdir\")\n    llvm_config(LLVM_INCLUDE_DIR \"--includedir\")\n\n    llvm_config(LLVM_SYSTEM_LIBS2 \"--system-libs\")\n    if(WIN32)\n        string(REPLACE \".lib \" \".lib;\" LLVM_SYSTEM_LIBS \"${LLVM_SYSTEM_LIBS2}\")\n        # For Win10 (?) some Win API things moved to Mincore.lib.\n        # (VerQueryValue, GetFileVersionInfoSize, GetFileVersionInfo)\n        # llvm-config does not contain it. Add manually.\n        set(LLVM_SYSTEM_LIBS \"${LLVM_SYSTEM_LIBS};Mincore.lib\")\n    elseif(APPLE)\n        string(REPLACE \".dylib\" \"\" LLVM_SYSTEM_LIBS \"${LLVM_SYSTEM_LIBS2}\")\n        string(REPLACE \"/usr/lib/lib\" \"-l\" LLVM_SYSTEM_LIBS \"${LLVM_SYSTEM_LIBS}\")\n        set(LLVM_SYSTEM_LIBS ${LLVM_SYSTEM_LIBS})\n    else()\n        set(LLVM_SYSTEM_LIBS ${LLVM_SYSTEM_LIBS2})\n    endif()\n\n    llvm_config(LLVM_PACKAGE_VERSION \"--version\")\n    string(REPLACE \"git\" \"\" LLVM_PACKAGE_VERSION_PLAIN \"${LLVM_PACKAGE_VERSION}\")\n    string(REPLACE \"rc\" \"\" LLVM_PACKAGE_VERSION_PLAIN \"${LLVM_PACKAGE_VERSION_PLAIN}\")\n\n    # With Clang 16 the location (path) of the include folder changed. Previously it was 15.0.0 now it is 16.\n    if(${LLVM_PACKAGE_VERSION_PLAIN} VERSION_GREATER_EQUAL \"15.0.0\")\n        string(REGEX REPLACE \"([0-9]+).[0-9]+.[0-9]+\" \"\\\\1\" LLVM_PACKAGE_VERSION_MAJOR_PLAIN \"${LLVM_PACKAGE_VERSION_PLAIN}\")\n    else()\n        set(LLVM_PACKAGE_VERSION_MAJOR_PLAIN \"${LLVM_PACKAGE_VERSION_PLAIN}\")\n    endif()\n\n    # always generate the compile commands\n    set(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n    if(WIN32)\n        # Make compile_commands.json work on Windows.\n        # Requires CMake > version 3.15 with fix of\n        # https://gitlab.kitware.com/cmake/cmake/issues/17482\n        set(CMAKE_C_USE_RESPONSE_FILE_FOR_INCLUDES OFF)\n        set(CMAKE_CXX_USE_RESPONSE_FILE_FOR_INCLUDES OFF)\n    endif()\n\n    add_definitions(${LLVM_CXXFLAGS})\n\n    if(NOT WIN32)\n        # To many warnings/errors from Clang's internals\n        add_definitions(-Wextra)\n        add_definitions(-Wold-style-cast)\n        if(NOT DEBUG)\n            add_definitions(-Werror)\n        endif ()\n    endif ()\n\n    if(IS_GNU AND NOT INSIGHTS_TIDY)\n        add_definitions(-Wsuggest-override)\n        #        add_definitions(-Wsuggest-final-types)\n        add_definitions(-Wuseless-cast)\n    elseif(IS_CLANG)\n        # -Wno-maybe-uninitialized is a g++ option which is (currently) unknown to clang\n        add_definitions(-Wno-unknown-warning-option)\n        #add_definitions(-Wnounused-command-line-argument)\n\n    endif()\n\n    if(DEBUG)\n        add_definitions(-D INSIGHTS_DEBUG)\n        add_definitions(-O0)\n        add_definitions(-g)\n    endif()\n\n    if(WIN32)\n        # Ignore deprecated std::iterator<> usage from Clang's sources\n        add_definitions(-D_SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING)\n    endif()\n\n    if(IS_MSVC_CL)\n        #add_definitions(/Wall)\n        #add_definitions(/WX)     # Warnings as errors\n        add_definitions(/wd4577) # 'noexcept' used with no exception handling mode specified; termination on exception is not guaranteed. Specify EHsc\n        add_definitions(/wd5045) # spectre mitigation introduced\n        add_definitions(/wd4514) # unreferenced inline function removed\n        add_definitions(/wd4710) # inline function _not_ inlined\n        add_definitions(/wd4711) # selected for automatic inline\n        add_definitions(/wd4820) # padding introduced\n        add_definitions(/wd4459) # hides global symbol disabled for now\n        add_definitions(/wd4626 /wd5027 /wd4623 /wd4625 /wd5026) # implicitly deleted operators\n        add_definitions(/wd4061) # enumerator 'clang::CK_BitCast' in switch of enum 'clang::CastKind' is not explicitly handled by a case label\n        #add_definitions(/err)\n\n        # To support /external:I:\n        # - enables \"system headers\" and\n        # - sets warning level 0 for them\n        add_definitions(/experimental:external /external:W0)\n\n        # Use sane and nice C++ for MSVC.\n        # This makes alternative tokens (not, and, ...) as actual keywords and\n        # enables more conformant C++ in general\n        add_definitions(/permissive-)\n\n        # Need to \"__cplusplus preprocessor macro to report an updated value for recent C++ language standards\n        # support\" ...\n        add_definitions(/Zc:__cplusplus)\n\n        # llvm-config says /EHs-c-.\n        # C++ exception handler used, but unwind semantics are not enabled\n        add_definitions(/wd4530)\n    endif()\n\n    include_directories(${LLVM_INCLUDE_DIR} .)\n    link_directories(${LLVM_LIBDIR})\n\n    if(INSIGHTS_COVERAGE)\n        message(STATUS \"Code coveraging enabled\")\n        if(IS_GNU)\n            set(COVERAGE_LINK_FLAGS    \"-lgcov\")\n        endif()\n\n        if(WIN32)\n            add_definitions(-fprofile-instr-generate)\n            set(COVERAGE_LINK_FLAGS \"${COVERAGE_LINK_FLAGS} ${LLVM_LIBDIR}/clang/${LLVM_PACKAGE_VERSION_PLAIN}/lib/windows/clang_rt.profile-x86_64.lib /FORCE:MULTIPLE\")\n    \telse()\n            add_definitions(-g)\n            add_definitions(-O0)\n#\t         add_definitions(-fprofile-arcs)\n            add_definitions(-ftest-coverage)\n            set(COVERAGE_LINK_FLAGS \"${COVERAGE_LINK_FLAGS} --coverage\")\n    \tendif()\n\n        if(IS_CLANG)\n            add_definitions(-fprofile-instr-generate -fcoverage-mapping)\n        else()\n            add_definitions(--coverage)\n        endif()\n\n        set( CMAKE_EXE_LINKER_FLAGS  \"${CMAKE_EXE_LINKER_FLAGS} ${COVERAGE_LINK_FLAGS}\")\n    endif()\n\n    # additional libs required when building insights outside llvm\n    set(ADDITIONAL_LIBS\n        ${LLVM_LDFLAGS}\n    )\n\n    if(${LLVM_PACKAGE_VERSION_PLAIN} VERSION_GREATER_EQUAL \"18.0.0\")\n        set(ADDITIONAL_LIBS\n            ${ADDITIONAL_LIBS}\n            clangAPINotes\n        )\n    endif()\n\n    set(ADDITIONAL_LIBS\n        ${ADDITIONAL_LIBS}\n        clangFrontend\n        clangDriver\n        clangSerialization\n        clangParse\n        clangSema\n        clangAnalysis\n        clangEdit\n        clangAST\n        clangLex\n        clangBasic\n        clangRewrite\n        clangSupport\n        ${LLVM_LIBS}\n        ${LLVM_SYSTEM_LIBS}\n    )\n\n    if(${LLVM_PACKAGE_VERSION_PLAIN} VERSION_GREATER_EQUAL \"18.0.0\")\n        set(ADDITIONAL_LIBS\n            ${ADDITIONAL_LIBS}\n            clangAPINotes\n        )\n    endif()\n\n\nelseif(NOT DEFINED LLVM_VERSION_MAJOR)  # used when build inside the clang tool/extra folder\n    message(FATAL_ERROR \"Neither in LLVM directory nor BUILD_INSIGHTS_OUTSIDE_LLVM is set\")\nelseif(NOT DEFINED LLVM_PACKAGE_VERSION)\n    # clang seems not to set this variable. Do it ourselves, IF it is not already defined\n    set(LLVM_PACKAGE_VERSION \"${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}\")\nendif()\n\n# minimum clang version\nif (${LLVM_PACKAGE_VERSION} VERSION_LESS ${INSIGHTS_MIN_LLVM_VERSION})\n    message(FATAL_ERROR \"LLVM version ${INSIGHTS_MIN_LLVM_VERSION} or higher required. Current version is: ${LLVM_PACKAGE_VERSION}.\")\nendif()\n\n# copied from: llvm/tools/clang/cmake/modules/AddClang.cmake\nmacro(add_clang_tool name)\n  add_executable( ${name} ${ARGN} )\nendmacro(add_clang_tool)\n\n\n\nif(WIN32)\n    # First for the generic no-config case (e.g. with mingw)\n    set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR} )\n    set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR} )\n    set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR} )\n    # Second, for multi-config builds (e.g. msvc)\n    foreach( OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES} )\n        string( TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG )\n        set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_BINARY_DIR} )\n        set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_BINARY_DIR} )\n        set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_BINARY_DIR} )\n    endforeach( OUTPUTCONFIG CMAKE_CONFIGURATION_TYPES )\nendif()\n\n\n# clang 8 and later or better ld warn, if the visibility is not the same as for the libs.\nset(CMAKE_CXX_VISIBILITY_PRESET hidden)\n\nif(EXISTS \"${CMAKE_CURRENT_SOURCE_DIR}/.git\")\n  execute_process(\n    COMMAND git log -1 --format=%H\n    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n    OUTPUT_VARIABLE GIT_COMMIT_HASH\n    OUTPUT_STRIP_TRAILING_WHITESPACE\n  )\n\n  execute_process(\n    COMMAND git config --get remote.origin.url\n    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n    OUTPUT_VARIABLE GIT_REPO_URL\n    OUTPUT_STRIP_TRAILING_WHITESPACE\n  )\n\nelse()\n  set(GIT_REPO_URL \"\")\n  set(GIT_COMMIT_HASH \"\")\nendif()\n\n\nmessage(STATUS \"Generating version.h\")\n\nconfigure_file(\n  ${CMAKE_CURRENT_SOURCE_DIR}/version.h.in\n  ${CMAKE_BINARY_DIR}/generated/version.h\n)\n\ninclude_directories(${CMAKE_BINARY_DIR}/generated)\n\n\n# http://www.mariobadr.com/using-clang-tidy-with-cmake-36.html\nfind_program(\n  CLANG_TIDY_EXE\n  NAMES \"clang-tidy\"\n  DOC \"Path to clang-tidy executable\"\n  )\nif(NOT CLANG_TIDY_EXE)\n  message(STATUS \"Could not find the program clang-tidy.\")\n\nelse()\n  message(STATUS \"Found clang-tidy: ${CLANG_TIDY_EXE}\")\n  set(DO_CLANG_TIDY \"${CLANG_TIDY_EXE}\" )\nendif()\n\n\nfind_program(IWYU_EXE NAMES include-what-you-use iwyu)\nif(IWYU_EXE)\n    message(STATUS \"Found include-what-you-use: ${IWYU_EXE}\")\n    set(DO_IWYU \"${IWYU_EXE}\" )\nelse()\n    message(STATUS \"Could not find the program include-what-you-use\")\nendif()\n\nif (NOT WIN32)\n    find_program(CCACHE_FOUND ccache)\n    if(CCACHE_FOUND)\n        message(STATUS \"Found ccache: ${CCACHE_FOUND}\")\n        set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)\n        set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)\n\n        if(IS_CLANG)\n            add_definitions(-Qunused-arguments)\n        endif()\n    endif()\nendif()\n\n\n# name the executable and all source files\nadd_clang_tool(insights\n    ASTHelpers.cpp\n    CodeGenerator.cpp\n    CfrontCodeGenerator.cpp\n    CoroutinesCodeGenerator.cpp\n    DPrint.cpp\n    Insights.cpp\n    InsightsHelpers.cpp\n    LifetimeTracker.cpp\n    OutputFormatHelper.cpp\n)\n\nif(IS_MSVC_CL)\n    # TODO figure out what llvm-config reports and use this configuration\n    set_property(TARGET insights PROPERTY MSVC_RUNTIME_LIBRARY \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\nendif()\n\nif(CLANG_LINK_CLANG_DYLIB)\n    if (NOT LLVM_LINK_LLVM_DYLIB)\n        message(FATAL_ERROR \"CLANG_LINK_CLANG_DYLIB and LLVM_LINK_LLVM_DYLIB must have the same value.\")\n    endif()\n    target_link_libraries(insights PRIVATE clang-cpp)\nelse()\n    # general include also provided by clang-build\n    target_link_libraries(insights\n        PRIVATE\n        ${ADDITIONAL_LIBS}\n        clangTooling\n        clangASTMatchers\n    )\nendif()\n\nif(LLVM_LINK_LLVM_DYLIB)\n    if (NOT CLANG_LINK_CLANG_DYLIB)\n        message(FATAL_ERROR \"CLANG_LINK_CLANG_DYLIB and LLVM_LINK_LLVM_DYLIB must have the same value.\")\n    endif()\n    target_link_libraries(insights PRIVATE LLVM)\nendif()\n\nif(CLANG_TIDY_EXE AND INSIGHTS_TIDY)\n  set(RUN_CLANG_TIDY On)\n  set_target_properties(insights PROPERTIES CXX_CLANG_TIDY \"${DO_CLANG_TIDY}\")\nelse()\n  set(RUN_CLANG_TIDY Off)\nendif()\n\nif(IWYU_EXE AND INSIGHTS_IWYU)\n    set(RUN_IWYU On)\n  set_target_properties(insights PROPERTIES CXX_INCLUDE_WHAT_YOU_USE \"${DO_IWYU}\")\nelse()\n  set(RUN_IWYU Off)\nendif()\n\n\ninstall( TARGETS insights RUNTIME DESTINATION bin )\n\nif (NOT WIN32)\n    # Not ready for Windows yet\n    #\n\n    # additional includes we need when building outside the llvm-folder\n    if (BUILD_INSIGHTS_OUTSIDE_LLVM)\n        if(INSIGHTS_STRIP)\n            if(APPLE)\n                # Apple's strip seems to dislike -s even as it is given at strip --help\n                set(STRIP_OPTION \"\")\n            else()\n                set(STRIP_OPTION \"-s\")\n            endif()\n\n            ADD_CUSTOM_COMMAND(\n                TARGET insights\n                POST_BUILD\n                COMMAND ${CMAKE_STRIP} ${STRIP_OPTION} insights\n                COMMENT \"Stripping ${TARGET}\"\n            )\n        endif()\n    endif()\n\n\n\n    # add a target to generate API documentation with Doxygen\n    find_package(Doxygen)\n    if(DOXYGEN_FOUND)\n        configure_file(${CMAKE_CURRENT_SOURCE_DIR}/docs/Doxyfile.in ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile @ONLY)\n        add_custom_target(doc\n            ${DOXYGEN_EXECUTABLE} ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile\n            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n            COMMENT \"Generating API documentation with Doxygen\" VERBATIM\n            COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/docs/postProcessDoxygen.py ${CMAKE_CURRENT_BINARY_DIR}/html\n        )\n\n        add_dependencies(doc gen-options)\n    endif()\nendif ()\n\n# XXX: hack to allow coverage build to run tests which fail\nset(TEST_FAILURE_IS_OK \"\")\nif(INSIGHTS_COVERAGE OR WIN32)\n    set(TEST_FAILURE_IS_OK \"--failure-is-ok\")\nendif()\n\nset(LLVM_PROF_DIR \"\")\nif(INSIGHTS_COVERAGE AND IS_CLANG)\n    set(LLVM_PROF_DIR \"--llvm-prof-dir=${CMAKE_CURRENT_BINARY_DIR}/llvmprof\")\nendif()\n\nset(TEST_USE_LIBCPP \"\")\nif(INSIGHTS_USE_LIBCPP)\n    set(TEST_USE_LIBCPP \"--use-libcpp\")\nendif()\n\n# Look for Python3, only relevant for target tests. As linux currently ships cmake 3.11.4 we need to workaround\nif(${CMAKE_VERSION} VERSION_LESS \"3.12.0\")\n    set(Python3_EXECUTABLE \"/usr/bin/python\")\n    set(Python3_FOUND \"Yes\")\nelse()\n    find_package(Python3 COMPONENTS Interpreter )\nendif()\n\nif (NOT Python3_FOUND)\n    message(WARNING \"Could not find the program Python3. Target tests disabled.\")\nelse()\n    message(STATUS \"Found Python3: ${Python3_EXECUTABLE}. Target tests enabled.\")\n\n    # add a target to generate run tests\n    add_custom_target(tests\n        COMMAND cmake -E rm -rf ${CMAKE_CURRENT_BINARY_DIR}/llvmprof/\n        COMMAND ${Python3_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/tests/runTest.py --insights\n        ${CMAKE_CURRENT_BINARY_DIR}/$<TARGET_FILE_NAME:insights> --cxx ${CMAKE_CXX_COMPILER} ${TEST_FAILURE_IS_OK} ${TEST_USE_LIBCPP} ${LLVM_PROF_DIR}\n        COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/tests/testSTDIN.sh ${CMAKE_CURRENT_BINARY_DIR}/$<TARGET_FILE_NAME:insights>\n        COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/tests/testInvalidOption.sh ${CMAKE_CURRENT_BINARY_DIR}/$<TARGET_FILE_NAME:insights>\n        DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/$<TARGET_FILE_NAME:insights> ${CMAKE_CURRENT_SOURCE_DIR}/tests/runTest.py\n        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/tests\n        COMMENT \"Running tests\" VERBATIM\n    )\nendif()\n\nif (NOT WIN32)\n    add_custom_target(update-tests\n        COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/tests/runTest.py --insights ${CMAKE_CURRENT_BINARY_DIR}/insights --cxx ${CMAKE_CXX_COMPILER} --update-tests ${TEST_FAILURE_IS_OK}\n        COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/tests/testSTDIN.sh ${CMAKE_CURRENT_BINARY_DIR}/insights\n        COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/tests/testInvalidOption.sh ${CMAKE_CURRENT_BINARY_DIR}/insights\n        DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/insights ${CMAKE_CURRENT_SOURCE_DIR}/tests/runTest.py\n        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/tests\n        COMMENT \"Running tests\" VERBATIM\n    )\n\n\n    # run tests in a docker container\n    add_custom_target(docker-tests\n        COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/scripts/docker-shell.sh ${CMAKE_CURRENT_BINARY_DIR}/docker_build compile \"-DINSIGHTS_STATIC=${INSIGHTS_STATIC} -DINSIGHTS_COVERAGE=${INSIGHTS_COVERAGE} -DDEBUG=${DEBUG} -DINSIGHTS_USE_LIBCPP=${INSIGHTS_USE_LIBCPP}\" tests\n        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/tests/runTest.py ${CMAKE_CURRENT_SOURCE_DIR}/scripts/docker-shell.sh\n        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/scripts\n        COMMENT \"Running tests in docker\" VERBATIM\n    )\n\n    # run code coverage in docker container\n    add_custom_target(docker-coverage\n        COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/scripts/docker-shell.sh ${CMAKE_CURRENT_BINARY_DIR}/docker_build compile \"-DINSIGHTS_STATIC=${INSIGHTS_STATIC} -DINSIGHTS_COVERAGE=Yes -DDEBUG=${DEBUG} -DINSIGHTS_USE_LIBCPP=${INSIGHTS_USE_LIBCPP}\" coverage-html\n        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/tests/runTest.py ${CMAKE_CURRENT_SOURCE_DIR}/scripts/docker-shell.sh\n        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/scripts\n        COMMENT \"Running tests in docker\" VERBATIM\n    )\n\n    # run tests in a docker container\n    add_custom_target(docker-build\n        COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/scripts/docker-shell.sh ${CMAKE_CURRENT_BINARY_DIR}/docker_build compile \"-DINSIGHTS_STATIC=${INSIGHTS_STATIC} -DINSIGHTS_COVERAGE=${INSIGHTS_COVERAGE} -DDEBUG=${DEBUG} -DINSIGHTS_TIDY=${INSIGHTS_TIDY} -DINSIGHTS_USE_LIBCPP=${INSIGHTS_USE_LIBCPP}\"\n        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/tests/runTest.py ${CMAKE_CURRENT_SOURCE_DIR}/scripts/docker-shell.sh\n        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/scripts\n        COMMENT \"Building insights in docker\" VERBATIM\n    )\n\n    # open a shell in the docker container\n    add_custom_target(docker-build-run\n        COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/scripts/docker-shell.sh ${CMAKE_CURRENT_BINARY_DIR}/docker_build shell\n        DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/scripts/docker-shell.sh\n        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/scripts\n        COMMENT \"Open shell in docker\" VERBATIM\n    )\n\n    if(CLANG_TIDY_EXE AND INSIGHTS_TIDY)\n        add_custom_command(TARGET insights\n            POST_BUILD\n            COMMAND /bin/bash ${CMAKE_CURRENT_SOURCE_DIR}/scripts/clang-tidy-check.sh ${CMAKE_CURRENT_BINARY_DIR}/output.txt ${CMAKE_CURRENT_SOURCE_DIR}/.clang-tidy-ignore\n            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n            COMMENT \"Analyzing clang-tidy output...\"\n        )\n    endif()\n\n    add_subdirectory(docs)\nendif()\n\n\n# code coverage\nif(INSIGHTS_COVERAGE)\n    if(WIN32)\n        find_program(GRCOV_BIN grcov REQUIRED)\n\n        if(NOT GRCOV_BIN)\n            message(FATAL_ERROR \"grcov not found\")\n        else()\n            message(STATUS \"Found grcov: ${GRCOV_BIN}. Target coverage enabled.\")\n\n            llvm_config(LLVM_BIN_DIR \"--bindir\")\n            get_filename_component(CLANG_ABS_DIR \"../\" ABSOLUTE BASE_DIR \"${LLVM_BIN_DIR}\")\n            message(STATUS \"${CLANG_ABS_DIR}\")\n\n            add_custom_target(coverage\n                COMMAND ${GRCOV_BIN} -s ${CMAKE_CURRENT_SOURCE_DIR} --llvm --ignore \"C:\\\\Program*\" --ignore \"${CLANG_ABS_DIR}/*\" --ignore-not-existing ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/insights.dir -t lcov -o ${CMAKE_CURRENT_BINARY_DIR}/filtered.info\n                DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/insights ${CMAKE_CURRENT_SOURCE_DIR}/tests/runTest.py\n                COMMENT \"Running code coverage analysis\" VERBATIM\n            )\n\n            add_custom_target(coverage-html\n                COMMAND ${GRCOV_BIN} -s ${CMAKE_CURRENT_SOURCE_DIR} --llvm --ignore \"${CMAKE_CURRENT_BINARY_DIR}/../current/*\" --ignore-not-existing ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/insights.dir -t html -o ${CMAKE_CURRENT_BINARY_DIR}/out\n                COMMENT \"Generating code coverage HTML\" VERBATIM\n            )\n        endif()\n    elseif(IS_GNU)\n        find_program(LCOV_BIN lcov)\n        find_program(GENHTML_BIN genhtml)\n        find_package_handle_standard_args(lcov\n            REQUIRED_VARS LCOV_BIN GENHTML_BIN\n        )\n\n        if (NOT LCOV_FOUND)\n            message(FATAL_ERROR \"Lcov not found\")\n        else()\n            message(STATUS \"Target coverage available\")\n            message(STATUS \"lcov                     : ${LCOV_BIN}\")\n\n            set(GCOV_TOOL \"\")\n            if(IS_GNU)\n                # Find the major version of the CXX compiler to use the corresponding gcov with it\n                string(REPLACE \".\" \";\" CXX_VERSION_LIST \"${CMAKE_CXX_COMPILER_VERSION}\")\n                list(GET CXX_VERSION_LIST 0 CXX_MAJOR_VERSION)\n                set(GCOV_TOOL --gcov-tool /usr/bin/gcov-${CXX_MAJOR_VERSION})\n            else()\n                #find_program(GCOV_BIN gcov PATHS /usr/local/bin NO_CMAKE_PATH NO_CMAKE_ENVIRONMENT_PATH NO_CMAKE_SYSTEM_PATH NO_DEFAULT_PATH)\n                #find_package_handle_standard_args(gcov REQUIRED_VARS GCOV_BIN)\n\n                #if (NOT GCOV_FOUND)\n                #    message(FATAL_ERROR \"gcov not found\")\n                #endif()\n\n                #                set(GCOV_TOOL \"--gcov-tool ${GCOV_BIN}\")\n                set(GCOV_TOOL --gcov-tool /usr/local/bin/gcov-10)\n            endif()\n\n            message(STATUS \"gcov_tool                : ${GCOV_TOOL}\")\n\n\n            add_custom_target(coverage\n                COMMAND lcov --directory ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/insights.dir ${GCOV_TOOL} --base-directory ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/insights.dir --capture --output-file ${CMAKE_CURRENT_BINARY_DIR}/coverage.info\n                COMMAND lcov --remove ${CMAKE_CURRENT_BINARY_DIR}/coverage.info \"/Applications/*\" \"/usr/*\" \"/Users/runner/work/cppinsights/cppinsights/current/*\" \"./current/*\" \"./build/*\" \"./cmake*/*\" \"${CMAKE_CURRENT_BINARY_DIR}\" \"./cppinsights/docs/*\" \"./cppinsights/tests/*\" -o ${CMAKE_CURRENT_BINARY_DIR}/filtered.info\n                DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/insights ${CMAKE_CURRENT_SOURCE_DIR}/tests/runTest.py\n                COMMENT \"Running code coverage analysis\" VERBATIM\n            )\n\n            add_custom_target(coverage-html\n                COMMAND genhtml ${CMAKE_CURRENT_BINARY_DIR}/filtered.info --demangle-cpp --output-directory ${CMAKE_CURRENT_BINARY_DIR}/out\n                COMMENT \"Generating code coverage HTML\" VERBATIM\n            )\n        endif()\n\n    else() # Clang\n        llvm_config(LLVM_BINDIR \"--bindir\")\n        find_program(LCOV_BIN llvm-cov PATHS ${LLVM_BINDIR})\n        find_program(PROFDATA_BIN llvm-profdata PATHS ${LLVM_BINDIR})\n        #        find_package_handle_standard_args(llvm-lcov\n        #            REQUIRED_VARS LCOV_BIN PROFDATA_BIN\n        #        )\n\n\n        #        if (NOT LCOV_FOUND)\n        #            message(FATAL_ERROR \"llvm-cov not found\")\n        #        elseif (NOT PROFDATA_FOUND)\n        #            message(FATAL_ERROR \"llvm-profdata not found\")\n        #        else()\n            message(STATUS \"Target coverage available\")\n            message(STATUS \"lcov                     : ${LCOV_BIN}\")\n            message(STATUS \"llvm-profdata            : ${PROFDATA_BIN}\")\n\n            # https://clang.llvm.org/docs/SourceBasedCodeCoverage.html\n            add_custom_target(coverage\n                COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/scripts/llvm-coverage.py --insights ${CMAKE_CURRENT_BINARY_DIR}/insights --llvm-prof-dir=${CMAKE_CURRENT_BINARY_DIR}/llvmprof/ --format=text  --output=${CMAKE_CURRENT_BINARY_DIR}/filtered.info --llvm-cov ${LCOV_BIN} --llvm-prof ${PROFDATA_BIN}\n                DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/insights ${CMAKE_CURRENT_SOURCE_DIR}/tests/runTest.py\n                COMMENT \"Running code coverage analysis\" VERBATIM\n            )\n\n            add_custom_target(coverage-html\n                COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/scripts/llvm-coverage.py --insights\n                ${CMAKE_CURRENT_BINARY_DIR}/insights --llvm-prof-dir=${CMAKE_CURRENT_BINARY_DIR}/llvmprof/ --format=lcov --output=${CMAKE_CURRENT_BINARY_DIR}/filtered.lcov --llvm-cov ${LCOV_BIN} --llvm-prof ${PROFDATA_BIN}\n                COMMAND genhtml ${CMAKE_CURRENT_BINARY_DIR}/filtered.lcov --demangle-cpp --output-directory ${CMAKE_CURRENT_BINARY_DIR}/out --keep-going\n                COMMENT \"Generating code coverage HTML\" VERBATIM\n            )\n\n        #        endif()\n    endif()\n\n    add_dependencies(coverage tests)\n    add_dependencies(coverage-html coverage)\n\nendif()\n\nmessage(STATUS \"\")\nmessage(STATUS \"[ Build summary ]\")\nmessage(STATUS \"BUILD_INSIGHTS_OUTSIDE_LLVM : ${BUILD_INSIGHTS_OUTSIDE_LLVM}\")\nmessage(STATUS \"CMAKE_GENERATOR       : ${CMAKE_GENERATOR}\")\nmessage(STATUS \"CMAKE_EXE_LINKER_FLAGS: ${CMAKE_EXE_LINKER_FLAGS}\")\nmessage(STATUS \"CMAKE_LINKER          : ${CMAKE_LINKER}\")\nmessage(STATUS \"CMAKE_OSX_ARCHITECTURES : ${CMAKE_OSX_ARCHITECTURES}\")\nmessage(STATUS \"Compiler ID           : ${CMAKE_CXX_COMPILER_ID}\")\nmessage(STATUS \"Compiler version      : ${CMAKE_CXX_COMPILER_VERSION}\")\nmessage(STATUS \"Compiler path         : ${CMAKE_CXX_COMPILER}\")\nmessage(STATUS \"llvm-config           : ${LLVM_CONFIG_PATH}\")\nmessage(STATUS \"Min LLVM major version: ${INSIGHTS_MIN_LLVM_MAJOR_VERSION}\")\nmessage(STATUS \"Install path          : ${CMAKE_INSTALL_PREFIX}\")\nmessage(STATUS \"Clang resource dir    : ${INSIGHTS_CLANG_RESOURCE_DIR}\")\nmessage(STATUS \"CMAKE_SOURCE_DIR      : ${CMAKE_SOURCE_DIR}\")\nmessage(STATUS \"CMAKE_BINARY_DIR      : ${CMAKE_BINARY_DIR}\")\nmessage(STATUS \"Git repo url          : ${GIT_REPO_URL}\")\nmessage(STATUS \"Git commit hash       : ${GIT_COMMIT_HASH}\")\nmessage(STATUS \"Debug                 : ${DEBUG}\")\nmessage(STATUS \"Code Coverage         : ${INSIGHTS_COVERAGE}\")\nmessage(STATUS \"Static linking        : ${INSIGHTS_STATIC}\")\nmessage(STATUS \"Strip executable      : ${INSIGHTS_STRIP}\")\nmessage(STATUS \"Elevate includes:     : ${INSIGHTS_USE_SYSTEM_INCLUDES}\")\nmessage(STATUS \"clang-tidy            : ${RUN_CLANG_TIDY}\")\nmessage(STATUS \"include-what-you-use  : ${RUN_IWYU}\")\nmessage(STATUS \"\")\n\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.2431640625,
          "content": "# Contributor Covenant Code of Conduct {#code_of_conduct}\n\nC++ Insights contributor covenant Code of Conduct.\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project lead at andy@cppinsights.io. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\n\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.9921875,
          "content": "# Contributing to C++ Insights {#contributing}\n\nThanks for considering contributing to **C++ Insights**.\n\n**C++ Insights** follows a [Code of Conduct](CODE_OF_CONDUCT.md) which aims to foster an open and welcoming environment.\n\n## In brief\n\nC++ Insights is a clang tooling project. Therefore it requires libclang to be installed. You can compile it either with\ng++ or clang++.\n\nThe current C++ language version used is C++17.\n\n\n## Contribute\n\nThere is a Travis CI running which compiles the code on Linux and macOS. Currently, it is limited to a out-of-source\nbuild. Windows is not supported yet. Please check the Travis CI status for each PR. The macOS build runs the unit tests.\nCode coverage runs on one of the Linux images.\n\n### Fixing an Issue\n\nCreate a test named: `Issue<ISSUE_NUMBER>.cpp` and a `Issue<ISSUE_NUMBER>.expect` with the transformed code after the fix.\n\nThe current style in the PR is:\n```\nFixed #<ISSUE_NUMBER>: <SHORT EXPLANATION>\n\n<DETAILD EXPLANATION>\n```\n\n### Contribute new functionality\n\n\n"
        },
        {
          "name": "CfrontCodeGenerator.cpp",
          "type": "blob",
          "size": 46.3623046875,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#include <clang/AST/VTableBuilder.h>\n\n#include <algorithm>\n#include <vector>\n\n#include \"CodeGenerator.h\"\n#include \"DPrint.h\"\n#include \"Insights.h\"\n#include \"InsightsHelpers.h\"\n#include \"InsightsOnce.h\"\n#include \"InsightsStrCat.h\"\n#include \"NumberIterator.h\"\n\n#include \"ASTHelpers.h\"\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n\nusing namespace asthelpers;\n//-----------------------------------------------------------------------------\n\n//! Store the `this` pointer offset from derived to base class.\nstatic llvm::DenseMap<std::pair<const CXXRecordDecl*, const CXXRecordDecl*>, int> mThisPointerOffset{};\n//-----------------------------------------------------------------------------\n\nstatic MemberExpr* AccessMember(std::string_view name, const ValueDecl* vd, QualType type)\n{\n    auto* rhsDeclRef    = mkVarDeclRefExpr(name, type);\n    auto* rhsMemberExpr = AccessMember(rhsDeclRef, vd);\n\n    return rhsMemberExpr;\n}\n//-----------------------------------------------------------------------------\n\nCfrontCodeGenerator::CfrontVtableData::CfrontVtableData()\n: vptpTypedef{Typedef(\"__vptp\"sv, Function(\"vptp\"sv, GetGlobalAST().IntTy, {})->getType())}\n, vtableRecorDecl{}\n{\n    vtableRecorDecl = Struct(\"__mptr\"sv);\n    auto AddField   = [&](FieldDecl* field) { vtableRecorDecl->addDecl(field); };\n\n    d = mkFieldDecl(vtableRecorDecl, \"d\"sv, GetGlobalAST().ShortTy);\n    AddField(d);\n    AddField(mkFieldDecl(vtableRecorDecl, \"i\"sv, GetGlobalAST().ShortTy));\n    f = mkFieldDecl(vtableRecorDecl, \"f\"sv, vptpTypedef);\n    AddField(f);\n\n    vtableRecorDecl->completeDefinition();\n\n    vtableRecordType = QualType{vtableRecorDecl->getTypeForDecl(), 0u};\n}\n//-----------------------------------------------------------------------------\n\nVarDecl* CfrontCodeGenerator::CfrontVtableData::VtblArrayVar(int size)\n{\n    return Variable(\"__vtbl_array\"sv, ContantArrayTy(Ptr(vtableRecordType), size));\n}\n//-----------------------------------------------------------------------------\n\nFieldDecl* CfrontCodeGenerator::CfrontVtableData::VtblPtrField(const CXXRecordDecl* parent)\n{\n    return mkFieldDecl(const_cast<CXXRecordDecl*>(parent), StrCat(\"__vptr\"sv, GetName(*parent)), Ptr(vtableRecordType));\n}\n//-----------------------------------------------------------------------------\n\nCfrontCodeGenerator::CfrontVtableData& CfrontCodeGenerator::VtableData()\n{\n    static CfrontVtableData data{};\n\n    return data;\n}\n//-----------------------------------------------------------------------------\n\nCodeGeneratorVariant::CodeGenerators::CodeGenerators(OutputFormatHelper&                      _outputFormatHelper,\n                                                     CodeGenerator::LambdaStackType&          lambdaStack,\n                                                     CodeGenerator::ProcessingPrimaryTemplate processingPrimaryTemplate)\n{\n    if(GetInsightsOptions().UseShow2C) {\n        new(&cfcg) CfrontCodeGenerator{\n            _outputFormatHelper, lambdaStack, CodeGenerator::LambdaInInitCapture::No, processingPrimaryTemplate};\n    } else {\n        new(&cg) CodeGenerator{\n            _outputFormatHelper, lambdaStack, CodeGenerator::LambdaInInitCapture::No, processingPrimaryTemplate};\n    }\n}\n//-----------------------------------------------------------------------------\n\nCodeGeneratorVariant::CodeGenerators::CodeGenerators(OutputFormatHelper&                _outputFormatHelper,\n                                                     CodeGenerator::LambdaInInitCapture lambdaInitCapture)\n{\n    if(GetInsightsOptions().UseShow2C) {\n        new(&cfcg) CfrontCodeGenerator{_outputFormatHelper, lambdaInitCapture};\n    } else {\n        new(&cg) CodeGenerator{_outputFormatHelper, lambdaInitCapture};\n    }\n}\n//-----------------------------------------------------------------------------\n\nCodeGeneratorVariant::CodeGenerators::~CodeGenerators()\n{\n    if(GetInsightsOptions().UseShow2C) {\n        cfcg.~CfrontCodeGenerator();\n    } else {\n        cg.~CodeGenerator();\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGeneratorVariant::Set()\n{\n    if(GetInsightsOptions().UseShow2C) {\n        cg = &cgs.cfcg;\n    } else {\n        cg = &cgs.cg;\n    }\n}\n//-----------------------------------------------------------------------------\n\nstatic bool IsCopyOrMoveCtor(const CXXConstructorDecl* ctor)\n{\n    return ctor and (ctor->isCopyConstructor() or ctor->isMoveConstructor());\n}\n//-----------------------------------------------------------------------------\n\nstatic bool IsCopyOrMoveAssign(const CXXMethodDecl* stmt)\n{\n    return stmt and (stmt->isCopyAssignmentOperator() or stmt->isMoveAssignmentOperator());\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string GetSpecialMemberName(const ValueDecl* vd, QualType type)\n{\n    if(const auto* md = dyn_cast_or_null<CXXMethodDecl>(vd)) {\n        // GetName below would return a[4] for example. To avoid the array part we go for the underlying type.\n        if(const auto* ar = dyn_cast_or_null<ArrayType>(type)) {\n            type = ar->getElementType();\n        }\n\n        auto rdName = GetName(type);\n\n        if(const auto* ctor = dyn_cast_or_null<CXXConstructorDecl>(md)) {\n            if(ctor->isCopyConstructor()) {\n                return StrCat(\"CopyConstructor_\"sv, rdName);\n            } else if(ctor->isMoveConstructor()) {\n                return StrCat(\"MoveConstructor_\"sv, rdName);\n            }\n\n            return StrCat(\"Constructor_\"sv, rdName);\n\n        } else if(isa<CXXDestructorDecl>(md)) {\n            return StrCat(\"Destructor_\"sv, rdName);\n        }\n    }\n\n    return GetName(*vd);\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetSpecialMemberName(const ValueDecl* vd)\n{\n    if(const auto* md = dyn_cast_or_null<CXXMethodDecl>(vd)) {\n        return GetSpecialMemberName(vd, GetRecordDeclType(md));\n    }\n\n    return {};\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertArg(const CXXThisExpr*)\n{\n    mOutputFormatHelper.Append(kwInternalThis);\n}\n//-----------------------------------------------------------------------------\n\nstatic bool HasCtor(QualType t)\n{\n    if(auto* cxxRecordDecl = t->getAsCXXRecordDecl(); cxxRecordDecl and not cxxRecordDecl->isTrivial()) {\n        return true;\n    }\n\n    return false;\n}\n//-----------------------------------------------------------------------------\n\nstatic bool HasDtor(QualType t)\n{\n    if(auto* cxxRecordDecl = t->getAsCXXRecordDecl(); cxxRecordDecl and not cxxRecordDecl->hasTrivialDestructor()) {\n        return true;\n    }\n\n    return false;\n}\n//-----------------------------------------------------------------------------\n\nstatic auto* CallVecDeleteOrDtor(Expr* objectParam, QualType allocatedType, std::string_view name, uint64_t size)\n{\n    auto dtorName = GetSpecialMemberName(allocatedType->getAsCXXRecordDecl()->getDestructor());\n\n    SmallVector<Expr*, 4> args{objectParam,\n                               Sizeof(allocatedType),\n                               Int32(size),  // XXX what is the correct value?\n                               CastToVoidFunPtr(dtorName)};\n\n    return Call(name, args);\n}\n//-----------------------------------------------------------------------------\n\nstatic auto* CallVecDelete(Expr* objectParam, QualType allocatedType)\n{\n    EnableGlobalInsert(GlobalInserts::FuncCxaVecDel);\n\n    return CallVecDeleteOrDtor(objectParam, allocatedType, \"__cxa_vec_delete\"sv, 0);\n}\n//-----------------------------------------------------------------------------\n\nstatic auto* CallVecDtor(Expr* objectParam, const ConstantArrayType* ar)\n{\n    EnableGlobalInsert(GlobalInserts::FuncCxaVecDtor);\n\n    return CallVecDeleteOrDtor(objectParam, ar->getElementType(), \"__cxa_vec_dtor\"sv, GetSize(ar));\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertArg(const CXXDeleteExpr* stmt)\n{\n    auto  destroyedType = stmt->getDestroyedType();\n    auto* arg           = const_cast<Expr*>(stmt->getArgument());\n\n    StmtsContainer bodyStmts{};\n\n    if(const auto hasDtor{HasDtor(destroyedType)}; stmt->isArrayForm() and hasDtor) {\n        bodyStmts.Add(CallVecDelete(arg, destroyedType));\n    } else if(hasDtor) {\n        bodyStmts.Add(Call(StrCat(\"Destructor_\"sv, GetName(destroyedType)), {arg}));\n    }\n\n    EnableGlobalInsert(GlobalInserts::FuncFree);\n\n    bodyStmts.Add(Call(\"free\"sv, {arg}));\n\n    InsertArg(If(arg, {bodyStmts}));\n    mInsertSemi = false;  // Since we tamper with a CompoundStmt we signal _not_ to insert the usual semi\n}\n//-----------------------------------------------------------------------------\n\nstatic auto* CallVecNewOrCtor(std::string_view ctorName,\n                              Expr*            objectParam,\n                              QualType         allocatedType,\n                              Expr*            arraySizeExpr,\n                              std::string_view funName)\n{\n    // According to \"Inside the C++ Object Model\" the dtor is required in case one of the array element ctors fails the\n    // already constructed one must be destroyed.\n    // See also: https://itanium-cxx-abi.github.io/cxx-abi/abi.html#array-ctor\n    auto dtorName = [&]() {\n        if(HasDtor(allocatedType)) {\n            return GetSpecialMemberName(allocatedType->getAsCXXRecordDecl()->getDestructor());\n        }\n\n        return std::string{kwNull};\n    }();\n\n    SmallVector<Expr*, 6> args{objectParam,\n                               Sizeof(allocatedType),\n                               arraySizeExpr,\n                               Int32(0),  // XXX what is the correct value?\n                               CastToVoidFunPtr(ctorName),\n                               CastToVoidFunPtr(dtorName)};\n\n    return Call(funName, args);\n}\n//-----------------------------------------------------------------------------\n\nstatic auto* CallVecNew(std::string_view ctorName, Expr* objectParam, QualType allocatedType, Expr* arraySizeExpr)\n{\n    EnableGlobalInsert(GlobalInserts::FuncCxaVecNew);\n\n    return CallVecNewOrCtor(ctorName, objectParam, allocatedType, arraySizeExpr, \"__cxa_vec_new\"sv);\n}\n//-----------------------------------------------------------------------------\n\nstatic auto*\nCallVecCtor(std::string_view ctorName, const VarDecl* objectParam, QualType allocatedType, Expr* arraySizeExpr)\n{\n    EnableGlobalInsert(GlobalInserts::FuncCxaVecCtor);\n\n    return CallVecNewOrCtor(ctorName, mkDeclRefExpr(objectParam), allocatedType, arraySizeExpr, \"__cxa_vec_ctor\"sv);\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertArg(const CXXNewExpr* cstmt)\n{\n    auto* stmt = const_cast<CXXNewExpr*>(cstmt);\n\n    auto allocatedType = stmt->getAllocatedType();\n    auto ctorName      = StrCat(\"Constructor_\"sv, GetName(allocatedType));\n\n    if(stmt->isArray()) {\n        EnableGlobalInsert(GlobalInserts::FuncMalloc);\n\n        auto* arraySizeExpr = stmt->getArraySize().value();\n        auto* callMalloc    = Call(\"malloc\"sv, {Mul(Sizeof(allocatedType), arraySizeExpr)});\n\n        Expr* assign{};\n\n        // According to \"Inside the C++ Object Model\" a trivial and literal type does use plain malloc as it does not\n        // require a ctor/dtor.\n        if(not HasCtor(allocatedType) and not HasDtor(allocatedType)) {\n            assign = Cast(callMalloc, Ptr(allocatedType));\n\n        } else {\n            if(allocatedType->getAsCXXRecordDecl()->ctors().empty()) {\n                EnableGlobalInsert(GlobalInserts::HeaderStddef);\n\n                ctorName = kwNull;\n            }\n\n            assign = Cast(CallVecNew(ctorName, callMalloc, allocatedType, arraySizeExpr), Ptr(allocatedType));\n        }\n\n        InsertArg(assign);\n\n        if(stmt->hasInitializer() and allocatedType->isBuiltinType()) {  // Ignore CXXConstructExpr\n            // The resulting code here is slightly different from the cfront code. For\n            //\n            // int* p = new int(2);\n            //\n            // C++ Insights generates:\n            //\n            // int* p = (int*)malloc(sizeof(int));\n            // if(p) { *p = 2; }\n            //\n            // However, due to Cs requirement to only declare variables and delay initialization the cfront code is\n            //\n            // int* p;\n            // if(p = (int*)malloc(sizeof(int))) { *p = 2; }\n            mOutputFormatHelper.AppendSemiNewLine();\n\n            if(auto* inits = dyn_cast_or_null<InitListExpr>(stmt->getInitializer())) {\n                auto* expr = [&]() -> const Expr* {\n                    if(auto* vd = dyn_cast_or_null<VarDecl>(mLastDecl)) {\n                        return mkDeclRefExpr(vd);\n                    }\n\n                    return mLastExpr;\n                }();\n\n                StmtsContainer bodyStmts{};\n\n                for(auto idx : NumberIterator(inits->getNumInits())) {\n                    bodyStmts.Add(Assign(ArraySubscript(expr, idx, allocatedType), inits->getInit(idx)));\n                }\n\n                InsertArg(If(expr, {bodyStmts}));\n\n                mInsertSemi = false;  // Since we tamper with a CompoundStmt we signal _not_ to insert the usual semi\n            }\n        }\n\n        return;\n    }\n\n    auto* mallocCall = [&]() -> Expr* {\n        if(stmt->getNumPlacementArgs()) {\n            return stmt->getPlacementArg(0);\n        }\n\n        EnableGlobalInsert(GlobalInserts::FuncMalloc);\n\n        return Call(\"malloc\"sv, {Sizeof(allocatedType)});\n    }();\n\n    mallocCall = Cast(mallocCall, Ptr(allocatedType));\n\n    if(allocatedType->isBuiltinType()) {\n        InsertArg(mallocCall);\n\n        if(stmt->hasInitializer()) {\n            // The resulting code here is slightly different from the cfront code. For\n            //\n            // int* p = new int(2);\n            //\n            // C++ Insights generates:\n            //\n            // int* p = (int*)malloc(sizeof(int));\n            // if(p) { *p = 2; }\n            //\n            // However, due to Cs requirement to only declare variables and delay initialization the cfront code is\n            //\n            // int* p;\n            // if(p = (int*)malloc(sizeof(int))) { *p = 2; }\n            mOutputFormatHelper.AppendSemiNewLine();\n\n            auto* varDeclRefExpr = mkDeclRefExpr(dyn_cast_or_null<VarDecl>(mLastDecl));\n\n            StmtsContainer bodyStmts{Assign(Dref(varDeclRefExpr), stmt->getInitializer())};\n\n            InsertArg(If(varDeclRefExpr, {bodyStmts}));\n\n            mInsertSemi = false;  // Since we tamper with a CompoundStmt we signal _not_ to insert the usual semi\n        }\n\n        return;\n    }\n\n    SmallVector<Expr*, 16> args{mallocCall};\n    if(auto* ncCtorExpr = const_cast<CXXConstructExpr*>(stmt->getConstructExpr())) {\n        args.append(ncCtorExpr->arg_begin(), ncCtorExpr->arg_end());\n    }\n\n    InsertArg(Call(ctorName, args));\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertArg(const CXXOperatorCallExpr* stmt)\n{\n    const auto* callee = stmt->getDirectCallee();\n\n    if(const auto* cxxCallee = dyn_cast_or_null<CXXMethodDecl>(callee); IsCopyOrMoveAssign(cxxCallee)) {\n        SmallVector<Expr*, 16> args{};\n\n        for(const auto& arg : stmt->arguments()) {\n            args.push_back(Ref(arg));\n        }\n\n        InsertArg(Call(callee, args));\n\n    } else {\n        InsertArg(dyn_cast_or_null<CallExpr>(stmt));\n    }\n}\n//-----------------------------------------------------------------------------\n\nstatic void InsertVtblPtr(const CXXMethodDecl* stmt, const CXXRecordDecl* cur, StmtsContainer& bodyStmts)\n{\n    if(cur->isPolymorphic() and (0 == cur->getNumBases())) {\n        auto* fieldDecl     = CfrontCodeGenerator::VtableData().VtblPtrField(cur);\n        auto* lhsMemberExpr = AccessMember(kwInternalThis, fieldDecl, Ptr(GetRecordDeclType(cur)));\n\n        // struct __mptr *__ptbl_vec__c___src_C_[]\n        auto* vtablAr = CfrontCodeGenerator::VtableData().VtblArrayVar(1);\n        auto* vtblArrayPos =\n            ArraySubscript(mkDeclRefExpr(vtablAr), GetGlobalVtablePos(stmt->getParent(), cur), fieldDecl->getType());\n\n        bodyStmts.AddBodyStmts(Assign(lhsMemberExpr, fieldDecl, vtblArrayPos));\n\n    } else if(cur->isPolymorphic() and (0 < cur->getNumBases()) and (cur != stmt->getParent())) {\n        for(const auto& base : cur->bases()) {\n            InsertVtblPtr(stmt, base.getType()->getAsCXXRecordDecl(), bodyStmts);\n        }\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertCXXMethodDecl(const CXXMethodDecl* stmt, SkipBody)\n{\n    // Skip if he method is unused like assignment operators by default.\n    RETURN_IF(not stmt->isUsed() and\n              (IsCopyOrMoveAssign(stmt) or (not stmt->hasBody() and not isa<CXXConstructorDecl>(stmt))));\n\n    OutputFormatHelper initOutputFormatHelper{};\n    initOutputFormatHelper.SetIndent(mOutputFormatHelper, OutputFormatHelper::SkipIndenting::Yes);\n\n    auto recordDeclType = GetRecordDeclType(stmt);\n    if(stmt->isConst()) {\n        recordDeclType.addConst();\n    }\n\n    auto           parentType = Ptr(recordDeclType);\n    auto*          body       = stmt->getBody();\n    StmtsContainer bodyStmts{};\n\n    auto retType = stmt->getReturnType();\n\n    auto processBaseClassesAndFields = [&](const CXXRecordDecl* parent) {\n        auto* thisOfParent = mkVarDeclRefExpr(kwInternalThis, parentType);\n\n        auto insertFields = [&](const RecordDecl* rd) {\n            for(auto* fieldDecl : rd->fields()) {\n                if(const auto* cxxRecordDecl = fieldDecl->getType()->getAsCXXRecordDecl()) {\n                    // We don't need any checks like isDefaultConstructible. We would not reach this\n                    // point in any other case.\n\n                    auto  lvalueRefType = GetGlobalAST().getLValueReferenceType(parentType);\n                    auto* lhsMemberExpr = AccessMember(kwInternalThis, fieldDecl, lvalueRefType);\n                    auto* rhsMemberExpr = AccessMember(\"__rhs\"sv, fieldDecl, lvalueRefType);\n\n                    // Add call to ctor\n                    bodyStmts.AddBodyStmts(Call(GetSpecialMemberName(stmt, GetRecordDeclType(cxxRecordDecl)),\n                                                {Ref(lhsMemberExpr), Ref(rhsMemberExpr)}));\n\n                } else {\n                    auto* rhsMemberExpr = AccessMember(\"__rhs\"sv, fieldDecl, parentType);\n\n                    bodyStmts.AddBodyStmts(Assign(thisOfParent, fieldDecl, rhsMemberExpr));\n                }\n            }\n        };\n\n        for(const auto& base : parent->bases()) {\n            const auto rd = base.getType()->getAsRecordDecl();\n\n            auto* lhsCast    = StaticCast(GetRecordDeclType(rd), thisOfParent, true);\n            auto* rhsDeclRef = mkVarDeclRefExpr(\"__rhs\"sv, parentType);\n            auto* rhsCast    = StaticCast(GetRecordDeclType(rd), rhsDeclRef, true);\n\n            auto* callAssignBase = Call(GetSpecialMemberName(stmt, GetRecordDeclType(rd)), {lhsCast, rhsCast});\n\n            bodyStmts.AddBodyStmts(callAssignBase);\n        }\n\n        // insert own fields\n        insertFields(parent);\n    };\n\n    // Skip ctor for trivial types\n    if(const auto* ctorDecl = dyn_cast_or_null<CXXConstructorDecl>(stmt)) {\n        const auto* parent = stmt->getParent();\n\n        if(not stmt->doesThisDeclarationHaveABody()) {\n            if(IsCopyOrMoveCtor(ctorDecl)) {\n                if(const bool showSpecialMemberFunc{stmt->isUserProvided() or stmt->isExplicitlyDefaulted()};\n                   not showSpecialMemberFunc) {\n                    return;\n                }\n\n                processBaseClassesAndFields(parent);\n            }\n        } else if(ctorDecl->isDefaultConstructor()) {\n            auto insertFields = [&](const RecordDecl* rd) {\n                for(auto* fieldDecl : rd->fields()) {\n                    if(auto* initializer = fieldDecl->getInClassInitializer();\n                       initializer and fieldDecl->hasInClassInitializer()) {\n                        const bool isConstructorExpr{isa<CXXConstructExpr>(initializer) or\n                                                     isa<ExprWithCleanups>(initializer)};\n\n                        if(not isConstructorExpr) {\n                            auto* lhsMemberExpr = AccessMember(kwInternalThis, fieldDecl, Ptr(GetRecordDeclType(rd)));\n\n                            bodyStmts.AddBodyStmts(Assign(lhsMemberExpr, fieldDecl, initializer));\n\n                        } else {\n                            bodyStmts.AddBodyStmts(CallConstructor(fieldDecl->getType(),\n                                                                   Ptr(GetRecordDeclType(rd)),\n                                                                   fieldDecl,\n                                                                   ArgsToExprVector(initializer),\n                                                                   DoCast::No,\n                                                                   AsReference::Yes));\n                        }\n\n                    } else if(const auto* cxxRecordDecl = fieldDecl->getType()->getAsCXXRecordDecl()) {\n                        // We don't need any checks like isDefaultConstructible. We would not reach this\n                        // point in any other cause.\n\n                        if(auto lhsType = fieldDecl->getType(); HasCtor(lhsType)) {\n                            bodyStmts.AddBodyStmts(CallConstructor(GetRecordDeclType(cxxRecordDecl),\n                                                                   Ptr(GetRecordDeclType(cxxRecordDecl)),\n                                                                   fieldDecl,\n                                                                   {},\n                                                                   DoCast::No,\n                                                                   AsReference::Yes));\n\n                        } else {\n                            bodyStmts.Add(\n                                Comment(StrCat(GetName(*fieldDecl), \" // trivial type, maybe uninitialized\"sv)));\n                            // Nothing to do here, we are looking at an uninitialized variable\n                        }\n                    }\n                }\n            };\n\n            for(const auto& base : parent->bases()) {\n                auto baseType = base.getType();\n\n                if(const auto* baseRd = baseType->getAsCXXRecordDecl();\n                   baseRd and baseRd->hasNonTrivialDefaultConstructor()) {\n                    bodyStmts.AddBodyStmts(CallConstructor(baseType, Ptr(baseType), nullptr, {}, DoCast::Yes));\n                }\n            }\n\n            // insert our vtable pointer\n            InsertVtblPtr(stmt, stmt->getParent(), bodyStmts);\n\n            // in case of multi inheritance insert additional vtable pointers\n            for(const auto& base : parent->bases()) {\n                InsertVtblPtr(stmt, base.getType()->getAsCXXRecordDecl(), bodyStmts);\n            }\n\n            // insert own fields\n            insertFields(parent);\n\n        } else {\n            // user ctor\n            for(const auto* init : ctorDecl->inits()) {\n                auto* member = init->getMember();\n\n                if(not isa<CXXConstructExpr>(init->getInit())) {\n                    if(not init->getAnyMember()) {\n                        continue;\n                    }\n\n                    auto* lhsMemberExpr = AccessMember(kwInternalThis, member, Ptr(GetRecordDeclType(parent)));\n\n                    bodyStmts.AddBodyStmts(Assign(lhsMemberExpr, member, init->getInit()));\n                    continue;\n\n                } else if(init->isBaseInitializer()) {\n                    bodyStmts.AddBodyStmts(init->getInit());\n                    continue;\n                }\n\n                auto ctorType = member->getType();\n\n                auto* lhsMemberExpr = AccessMember(kwInternalThis, member, ctorType);\n\n                auto callParams{ArgsToExprVector(init->getInit())};\n                callParams.insert(callParams.begin(), Ref(lhsMemberExpr));\n\n                bodyStmts.AddBodyStmts(\n                    Call(GetSpecialMemberName(stmt, GetRecordDeclType(ctorType->getAsRecordDecl())), callParams));\n            }\n        }\n\n        if(body) {\n            bodyStmts.AddBodyStmts(body);\n        }\n\n        bodyStmts.AddBodyStmts(Return(mkVarDeclRefExpr(kwInternalThis, Ptr(ctorDecl->getType()))));\n\n        body    = mkCompoundStmt({bodyStmts});\n        retType = parentType;\n\n        // copy and move assignment op\n    } else if(IsCopyOrMoveAssign(stmt)) {\n        if(not stmt->doesThisDeclarationHaveABody() or stmt->isDefaulted()) {\n\n            // we don't want the default generated body\n            bodyStmts.clear();\n\n            processBaseClassesAndFields(stmt->getParent());\n        } else if(body) {\n            bodyStmts.AddBodyStmts(body);\n        }\n\n        bodyStmts.AddBodyStmts(Return(mkVarDeclRefExpr(kwInternalThis, Ptr(stmt->getType()))));\n\n        body    = mkCompoundStmt({bodyStmts});\n        retType = parentType;\n\n    } else if(const auto* dtor = dyn_cast_or_null<CXXDestructorDecl>(stmt)) {\n        // Based on: https://www.dre.vanderbilt.edu/~schmidt/PDF/C++-translation.pdf\n\n        if(body) {\n            bodyStmts.AddBodyStmts(body);\n        }\n\n        if(not HasDtor(GetRecordDeclType(dtor->getParent()))) {\n            return;\n        }\n\n        for(const auto& base : llvm::reverse(dtor->getParent()->bases())) {\n            if(not dtor->isVirtual()) {\n                continue;\n            }\n\n            auto* lhsDeclRef = mkVarDeclRefExpr(kwInternalThis, Ptr(base.getType()));\n            auto* cast       = Cast(lhsDeclRef, lhsDeclRef->getType());\n\n            bodyStmts.Add(\n                Call(GetSpecialMemberName(stmt, GetRecordDeclType(base.getType()->getAsRecordDecl())), {cast}));\n\n            body = mkCompoundStmt({bodyStmts});\n        }\n    }\n\n    params_store params{};\n    params.reserve(stmt->getNumParams() + 1);\n\n    if(not IsStaticStorageClass(stmt) and not stmt->isStatic()) {\n        params.emplace_back(kwInternalThis, parentType);\n    }\n\n    for(const auto& param : stmt->parameters()) {\n        std::string name{GetName(*param)};\n        auto        type = param->getType();\n\n        // at least in case of a copy constructor modify the parameters\n        if((0 == name.length()) and\n           (IsCopyOrMoveCtor(dyn_cast_or_null<CXXConstructorDecl>(stmt)) or IsCopyOrMoveAssign(stmt))) {\n            name = \"__rhs\"sv;\n            type = Ptr(type.getNonReferenceType());\n        }\n\n        params.emplace_back(name, type);\n    }\n\n    auto* callSpecialMemberFn = Function(GetSpecialMemberName(stmt), retType, to_params_view(params));\n    callSpecialMemberFn->setInlineSpecified(stmt->isInlined());\n    callSpecialMemberFn->setStorageClass((stmt->isStatic() or IsStaticStorageClass(stmt)) ? SC_Static : SC_None);\n    callSpecialMemberFn->setBody(body);\n\n    InsertArg(callSpecialMemberFn);\n\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::FormatCast(const std::string_view,\n                                     const QualType& castDestType,\n                                     const Expr*     subExpr,\n                                     const CastKind& kind)\n{\n    // C does not have a rvalue notation and we already transformed the temporary into an object. Skip the cast to &&.\n    // Ignore CK_UncheckedDerivedToBase which would lead to (A)c where neither A nor c is a pointer.\n    if(not castDestType->isRValueReferenceType() and not(CastKind::CK_UncheckedDerivedToBase == kind)) {\n        mOutputFormatHelper.Append(\"(\", GetName(castDestType), \")\");\n\n        // ARM p 221:\n        // C* pc = new C;\n        // B* pb = pc -> pc = (B*) ((char*)pc+delta(B))\n        if(is{kind}.any_of(CastKind::CK_DerivedToBase, CastKind::CK_BaseToDerived)) {\n            // We have to switch in case of a base to derived cast\n            auto [key,\n                  sign] = [&]() -> std::pair<std::pair<const CXXRecordDecl*, const CXXRecordDecl*>, std::string_view> {\n                auto plainType = [](QualType t) {\n                    if(const auto* pt = dyn_cast_or_null<PointerType>(t.getTypePtrOrNull())) {\n                        return pt->getPointeeType()->getAsCXXRecordDecl();\n                    }\n\n                    return t->getAsCXXRecordDecl();\n                };\n\n                auto base    = plainType(castDestType);\n                auto derived = plainType(subExpr->getType());\n\n                if((CastKind::CK_BaseToDerived == kind)) {\n                    return {{base, derived}, \"-\"sv};\n                }\n\n                return {{derived, base}, \"+\"sv};\n            }();\n\n            if(auto off = mThisPointerOffset[key]) {\n                mOutputFormatHelper.Append(\"((char*)\"sv);\n                InsertArg(subExpr);\n                mOutputFormatHelper.Append(sign, off, \")\"sv);\n\n                return;\n            }\n        }\n    }\n\n    InsertArg(subExpr);\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertArg(const CXXNullPtrLiteralExpr*)\n{\n    EnableGlobalInsert(GlobalInserts::HeaderStddef);\n\n    mOutputFormatHelper.Append(kwNull);\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertArg(const StaticAssertDecl* stmt)\n{\n    EnableGlobalInsert(GlobalInserts::HeaderAssert);\n\n    mOutputFormatHelper.Append(\"_Static_assert\"sv);\n\n    WrapInParens([&] {\n        InsertArg(stmt->getAssertExpr());\n\n        if(stmt->getMessage()) {\n            mOutputFormatHelper.Append(\", \"sv);\n            InsertArg(stmt->getMessage());\n        }\n    });\n\n    mOutputFormatHelper.AppendSemiNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertArg(const TypedefDecl* stmt)\n{\n    mOutputFormatHelper.AppendSemiNewLine(kwTypedefSpace, GetName(stmt->getUnderlyingType()), \" \"sv, GetName(*stmt));\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nstatic void ProcessFields(CXXRecordDecl* recordDecl, const CXXRecordDecl* rd)\n{\n    RETURN_IF(not rd->hasDefinition())\n\n    auto AddField = [&](const FieldDecl* field) {\n        recordDecl->addDecl(mkFieldDecl(recordDecl, GetName(*field), field->getType()));\n    };\n\n    // Insert field from base classes\n    for(const auto& base : rd->bases()) {\n        // XXX: ignoring TemplateSpecializationType\n        if(const auto* rdBase = dyn_cast_or_null<CXXRecordDecl>(base.getType().getCanonicalType()->getAsRecordDecl())) {\n            ProcessFields(recordDecl, rdBase);\n        }\n    }\n\n    // insert vtable pointer if required\n    if(rd->isPolymorphic() and (rd->getNumBases() == 0)) {\n        recordDecl->addDecl(CfrontCodeGenerator::VtableData().VtblPtrField(rd));\n    }\n\n    // insert own fields\n    for(const auto* d : rd->fields()) {\n        AddField(d);\n    }\n\n    if(recordDecl->field_empty()) {\n        AddField(mkFieldDecl(recordDecl, \"__dummy\"sv, GetGlobalAST().CharTy));\n    }\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string GetFirstPolymorphicBaseName(const RecordDecl* decl, const RecordDecl* to)\n{\n    std::string ret{GetName(*decl)};\n\n    if(const auto* rdecl = dyn_cast_or_null<CXXRecordDecl>(decl); rdecl->getNumBases() > 1) {\n        for(const auto& base : rdecl->bases()) {\n            if(const auto* rd = base.getType()->getAsRecordDecl(); rd == to) {\n                ret += GetFirstPolymorphicBaseName(rd, to);\n                break;\n            }\n        }\n    }\n\n    return ret;\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertArg(const CXXRecordDecl* stmt)\n{\n    auto* recordDecl = Struct(GetName(*stmt));\n\n    if(stmt->hasDefinition() and stmt->isPolymorphic()) {\n        if(auto* itctx =\n               static_cast<ItaniumVTableContext*>(const_cast<ASTContext&>(GetGlobalAST()).getVTableContext())) {\n#if 0\n            // Get mangled RTTI name\n            auto*                     mc = const_cast<ASTContext&>(GetGlobalAST()).createMangleContext(nullptr);\n            SmallString<256>          rttiName{};\n            llvm::raw_svector_ostream out(rttiName);\n            mc->mangleCXXRTTI(QualType(stmt->getTypeForDecl(), 0), out);\n            DPrint(\"name: %s\\n\", rttiName.c_str());\n#endif\n\n            SmallVector<Expr*, 16>   mInitExprs{};\n            SmallVector<QualType, 5> baseList{};\n\n            if(stmt->getNumBases() == 0) {\n                baseList.push_back(GetRecordDeclType(stmt));\n            }\n\n            for(const auto& base : stmt->bases()) {\n                baseList.push_back(base.getType());\n            }\n\n            llvm::DenseMap<uint64_t, ThunkInfo> thunkMap{};\n            const VTableLayout&                 layout{itctx->getVTableLayout(stmt)};\n\n            for(const auto& [idx, thunk] : layout.vtable_thunks()) {\n                thunkMap[idx] = thunk;\n            }\n\n            unsigned clsIdx{};\n            unsigned funIdx{};\n            auto&    vtblData = VtableData();\n\n            auto pushVtable = [&] {\n                if(funIdx) {\n                    EnableGlobalInsert(GlobalInserts::FuncVtableStruct);\n\n                    //    struct __mptr __vtbl__A[] = {0, 0, 0, 0, 0, (__vptp)FunA, 0, 0, 0};\n                    auto* thisRd = baseList[clsIdx - 1]->getAsCXXRecordDecl();\n                    auto  vtableName{StrCat(\"__vtbl_\"sv, GetFirstPolymorphicBaseName(stmt, thisRd))};\n                    auto* vtabl = Variable(vtableName, ContantArrayTy(vtblData.vtableRecordType, funIdx));\n                    vtabl->setInit(InitList(mInitExprs, vtblData.vtableRecordType));\n\n                    PushVtableEntry(stmt, thisRd, vtabl);\n\n                    funIdx = 0;\n                }\n\n                mInitExprs.clear();\n            };\n\n            for(unsigned i = 0; const auto& vc : layout.vtable_components()) {\n                switch(vc.getKind()) {\n                    case VTableComponent::CK_OffsetToTop: {\n                        auto off = layout.getVTableOffset(clsIdx);\n                        if(auto rem = (off % 4)) {\n                            off += 4 - rem;  // sometimes the value is misaligned. Align to 4 bytes\n                        }\n\n                        mThisPointerOffset[{stmt, baseList[clsIdx]->getAsCXXRecordDecl()}] = off * 4;  // we need bytes\n\n                        if(clsIdx >= 1) {\n                            pushVtable();\n                        }\n                        ++clsIdx;\n                    } break;\n\n                    case VTableComponent::CK_RTTI:\n                        break;\n\n                        // Source: https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-components\n                        // The entries for virtual destructors are actually pairs of entries. The first destructor,\n                        // called the complete object destructor, performs the destruction without calling delete() on\n                        // the object. The second destructor, called the deleting destructor, calls delete() after\n                        // destroying the object.\n                    case VTableComponent::CK_CompleteDtorPointer:\n                        break;  // vc.getKind() == VTableComponent::CK_CompleteDtorPointer\n                    case VTableComponent::CK_DeletingDtorPointer:\n                    case VTableComponent::CK_FunctionPointer: {\n                        auto* thunkOffset = [&] {\n                            if(ThunkInfo thunk = thunkMap.lookup(i); not thunk.isEmpty() and not thunk.This.isEmpty()) {\n                                return Int32(thunk.This.NonVirtual);\n                            }\n\n                            return Int32(0);\n                        }();\n\n                        const auto* md = dyn_cast_or_null<FunctionDecl>(vc.getFunctionDecl());\n\n                        std::string name{};\n                        if(md->isPureVirtual()) {\n                            EnableGlobalInsert(GlobalInserts::HeaderStdlib);\n                            EnableGlobalInsert(GlobalInserts::FuncCxaPureVirtual);\n\n                            md = Function(\"__cxa_pure_virtual\"sv, VoidTy(), params_vector{{kwInternalThis, VoidTy()}});\n\n                            name = GetName(*md);\n                        } else {\n                            name = GetSpecialMemberName(md);\n                        }\n\n                        auto* reicast = ReinterpretCast(vtblData.vptpTypedef, mkVarDeclRefExpr(name, md->getType()));\n\n                        mInitExprs.push_back(InitList({thunkOffset, Int32(0), reicast}, vtblData.vtableRecordType));\n\n                        ++funIdx;\n                        break;\n                    }\n                    default: break;\n                }\n\n                ++i;\n            }\n\n            pushVtable();\n        }\n    }\n\n    if(stmt->hasDefinition()) {\n        ProcessFields(recordDecl, stmt);\n        recordDecl->completeDefinition();\n\n        mOutputFormatHelper.Append(kwTypedefSpace);\n    }\n\n    // use our freshly created recordDecl\n    CodeGenerator::InsertArg(recordDecl);\n\n#if 0\n    // TypedefDecl above is not called\n    auto& ctx = GetGlobalAST();\n    auto et = ctx.getElaboratedType(ElaboratedTypeKeyword::ETK_Struct, nullptr, GetRecordDeclType(recordDecl), nullptr);\n    auto* typedefDecl = Typedef(GetName(*stmt),et);\n    CodeGenerator::InsertArg(typedefDecl);\n#endif\n\n    // insert member functions except for the special member functions and classes defined inside this class\n    for(OnceTrue firstRecordDecl{}; const auto* d : stmt->decls()) {\n        if((isa<CXXRecordDecl>(d) and firstRecordDecl)          // skip the first record decl which are ourselves\n           or (stmt->isLambda() and isa<CXXDestructorDecl>(d))  // skip dtor for lambdas\n           or isa<FieldDecl>(d)                                 // skip fields\n           or isa<AccessSpecDecl>(d)                            // skip access specifiers\n        ) {\n            continue;\n        }\n\n        // According to \"Inside the C++ Object Model\" a trivial and literal type has no ctor/dtor.\n        if((stmt->isTrivial() and isa<CXXConstructorDecl>(d)) or\n           (stmt->hasTrivialDestructor() and isa<CXXDestructorDecl>(d))) {\n            continue;\n        }\n\n        InsertArg(d);\n    }\n}\n//-----------------------------------------------------------------------------\n\n///! Find the first polymorphic base class.\nstatic const CXXRecordDecl* GetFirstPolymorphicBase(const RecordDecl* decl)\n{\n    if(const auto* rdecl = dyn_cast_or_null<CXXRecordDecl>(decl); rdecl->getNumBases() >= 1) {\n        for(const auto& base : rdecl->bases()) {\n            const auto* rd = base.getType()->getAsRecordDecl();\n\n            if(const auto* cxxRd = dyn_cast_or_null<CXXRecordDecl>(rd); not cxxRd or not cxxRd->isPolymorphic()) {\n                continue;\n            } else if(const CXXRecordDecl* ret = GetFirstPolymorphicBase(rd)) {\n                return ret;\n            }\n\n            break;\n        }\n    }\n\n    return dyn_cast_or_null<CXXRecordDecl>(decl);\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertArg(const CXXMemberCallExpr* stmt)\n{\n    if(const auto* me = dyn_cast_or_null<MemberExpr>(stmt->getCallee())) {\n        auto*      obj = me->getBase();\n        const bool isPointer{obj->getType()->isPointerType()};\n\n        if(const bool isReference = IsReferenceType(dyn_cast_or_null<VarDecl>(obj->getReferencedDeclOfCallee()));\n           not isPointer and not isReference) {\n            obj = Ref(obj);\n        }\n\n        if(const auto* matExpr = dyn_cast_or_null<MaterializeTemporaryExpr>(me->getBase())) {\n            if(const auto* tmpExpr = dyn_cast_or_null<CXXBindTemporaryExpr>(matExpr->getSubExpr())) {\n                if(const auto* tmpObjExpr = dyn_cast_or_null<CXXTemporaryObjectExpr>(tmpExpr->getSubExpr())) {\n                    obj = const_cast<CXXTemporaryObjectExpr*>(tmpObjExpr);\n                }\n            }\n        }\n\n        auto* memDecl = me->getMemberDecl();\n\n        if(const auto* ar = dyn_cast_or_null<ConstantArrayType>(obj->getType())) {\n            if(const auto* dtor = dyn_cast_or_null<CXXDestructorDecl>(memDecl)) {\n                // ignore the reference\n                InsertArg(CallVecDtor(dyn_cast_or_null<UnaryOperator>(obj)->getSubExpr(), ar));\n                return;\n            }\n        }\n\n        SmallVector<Expr*, 16> params{obj};\n        auto*                  ncStmt = const_cast<CXXMemberCallExpr*>(stmt);\n        params.append(ncStmt->arg_begin(), ncStmt->arg_end());\n\n        if(auto* md = dyn_cast_or_null<CXXMethodDecl>(memDecl); md and md->isVirtual()) {\n            auto& vtblData    = VtableData();\n            auto* cls         = md->getParent();\n            auto  vRecordDecl = GetFirstPolymorphicBase(cls);\n            auto* vtblField   = VtableData().VtblPtrField(vRecordDecl);\n\n            // -- cast to function signature: void Fun(struct X*)\n\n            auto destType = not isPointer ? Ptr(obj->getType()) : obj->getType();\n            auto atype    = isPointer ? obj->getType()->getPointeeType() : obj->getType();\n            auto idx      = mVirtualFunctions[{md, {atype->getAsCXXRecordDecl(), vRecordDecl}}];\n\n            // a->__vptr[1];  #1\n            auto* accessVptr   = AccessMember(Paren(obj), vtblField, true);\n            auto* vtblArrayPos = ArraySubscript(accessVptr, idx, vtblField->getType());\n\n            auto* p             = Paren(vtblArrayPos);                 // ( #1 ) #2\n            auto* accessMemberF = AccessMember(p, vtblData.f, false);  // #2.f  #3\n\n            // (void (*)(struct X*) (#3)\n            params_vector ps{{kwInternalThis, destType}};\n            auto*         funcPtrFuncDecl = Function(\"__dummy\"sv, VoidTy(), ps);\n            auto*         reicast         = ReinterpretCast(funcPtrFuncDecl->getType(), accessMemberF, true);\n\n            auto* p4 = Paren(reicast);  // (#4)\n            auto  p5 = Dref(p4);        // *#5\n            auto* p6 = Paren(p5);       // (#5)  #6\n\n            // -- call with possible this pointer adjustment\n\n            auto* p7 = AccessMember(p, vtblData.d, false);                        // a->__vptr[1];  #7\n            auto* p8 = ReinterpretCast(GetGlobalAST().CharTy, Paren(obj), true);  // (#7) #8\n\n            auto* p9 = ReinterpretCast(destType, p8);\n\n            auto* p10 = Paren(p9);\n            auto* p11 = Plus(p10, p7);  // #7 + #8    #9\n            auto* p12 = Paren(p11);\n\n            // Use the modified object parameter\n            params[0] = p12;\n            InsertArg(CallExpr::Create(GetGlobalAST(), p6, params, p6->getType(), VK_LValue, {}, {}));\n\n        } else {\n            InsertArg(Call(GetSpecialMemberName(memDecl), params));\n        }\n\n    } else {\n        CodeGenerator::InsertArg(stmt);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertArg(const FunctionDecl* stmt)\n{\n    if(not stmt->isMain()) {\n        CodeGenerator::InsertArg(stmt);\n        return;\n    }\n\n    params_store           params{};\n    SmallVector<Expr*, 16> args{};\n\n    for(auto* param : stmt->parameters()) {\n        params.emplace_back(GetName(*param), param->getType());\n        args.push_back(mkDeclRefExpr(param));\n    }\n\n    auto mainName{\"main\"sv};\n    auto trampolinMainName{BuildInternalVarName(mainName)};\n\n    auto* intMain = Function(trampolinMainName, stmt->getReturnType(), to_params_view(params));\n    intMain->setBody(stmt->getBody());\n    intMain->setHasImplicitReturnZero(true);\n\n    InsertArg(intMain);\n    mOutputFormatHelper.AppendNewLine();\n\n    auto* mainRetVar = Variable(\"ret\"sv, stmt->getReturnType());\n    mainRetVar->setInit(Call(trampolinMainName, args));\n\n    auto* mainRetVarDeclStmt = mkDeclStmt(mainRetVar);\n\n    StmtsContainer bodyStmts{Call(cxaStart, {}), mainRetVarDeclStmt, Call(cxaAtExit, {}), Return(mainRetVar)};\n\n    auto* body    = mkCompoundStmt({bodyStmts});\n    auto* modMain = Function(mainName, stmt->getReturnType(), to_params_view(params));\n    modMain->setBody(body);\n\n    CodeGenerator::InsertArg(modMain);\n}\n//-----------------------------------------------------------------------------\n\nvoid CfrontCodeGenerator::InsertArg(const CXXConstructExpr* stmt)\n{\n    if(P0315Visitor dt{*this}; not dt.TraverseType(stmt->getType())) {\n        if(not mLambdaStack.empty()) {\n            for(const auto& e : mLambdaStack) {\n                RETURN_IF(LambdaCallerType::VarDecl == e.callerType());\n            }\n        }\n    }\n\n    auto  ctor     = stmt->getConstructor();\n    auto  ctorName = GetSpecialMemberName(ctor);\n    auto* vd       = dyn_cast_or_null<VarDecl>(mLastDecl);\n\n#if 0   \n   // XXX: An expression like C c[4]{4,5,6} with C having a ctor does show up wrong at the moment. \n    if(not ar) {\n        ar = dyn_cast_or_null<ConstantArrayType>(vd->getType());\n\n        if(ar) {\n            mLastStmt->dump();\n            openScope = true;\n            // mOutputFormatHelper.CloseScopeWithSemi();\n            mOutputFormatHelper.AppendSemiNewLine();\n        }\n    }\n#endif\n\n    auto InsertCallCtor = [&](Expr* varNameRef) {\n        SmallVector<Expr*, 16> args{Cast(varNameRef, Ptr(stmt->getType()))};\n\n        for(int i = 0; auto* arg : stmt->arguments()) {\n            if(IsCopyOrMoveCtor(ctor) or ctor->getParamDecl(i)->getType()->isReferenceType()) {\n                args.push_back(Ref(arg));\n\n            } else {\n                args.push_back(const_cast<Expr*>(arg));\n            }\n\n            ++i;\n        }\n\n        InsertArg(Call(ctorName, args));\n    };\n\n    // For an array we need to call __vec_new\n    if(const auto* ar = dyn_cast_or_null<ConstantArrayType>(stmt->getType())) {\n        if(not HasCtor(ar->getElementType())) {\n            mInsertSemi = false;\n            return;\n        }\n\n        InsertArg(CallVecCtor(ctorName, vd, ar->getElementType(), Int32(GetSize(ar))));\n\n    } else if(const auto* tmpObjectExpr = dyn_cast_or_null<CXXTemporaryObjectExpr>(stmt); vd and not tmpObjectExpr) {\n        if(not HasCtor(vd->getType())) {\n            mInsertSemi = false;\n        } else {\n            auto* varNameRef = Ref(mkDeclRefExpr(vd));\n\n            InsertCallCtor(varNameRef);\n        }\n\n    } else if(tmpObjectExpr) {\n        auto* varNameRef = Ref(mkVarDeclRefExpr(GetName(*tmpObjectExpr), stmt->getType()));\n\n        if(not HasCtor(stmt->getType())) {\n            InsertArg(varNameRef);\n            return;\n        }\n\n        InsertCallCtor(varNameRef);\n\n    } else {\n        InsertArg(CallConstructor(\n            stmt->getType(), Ptr(GetRecordDeclType(ctor)), nullptr, ArgsToExprVector(stmt), DoCast::Yes));\n    }\n}\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n"
        },
        {
          "name": "ClangCompat.h",
          "type": "blob",
          "size": 1.25390625,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#ifndef INSIGHTS_CLANG_COMPAT_H\n#define INSIGHTS_CLANG_COMPAT_H\n//-----------------------------------------------------------------------------\n\n#include <clang/Basic/Version.h>\n#include \"version.h\"\n//-----------------------------------------------------------------------------\n\n#define IS_CLANG_NEWER_THAN(major) (CLANG_VERSION_MAJOR > (major))\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n\ntemplate<unsigned int MAJOR>\nstruct IsClangNewerThan\n{\n    static_assert(INSIGHTS_MIN_LLVM_MAJOR_VERSION < MAJOR, \"Remove this function, all clang versions support it now\");\n    constexpr static inline bool value{CLANG_VERSION_MAJOR > MAJOR};\n};\n//-----------------------------------------------------------------------------\n\n// inline constexpr bool IsClangNewerThan8 = IsClangNewerThan<8>::value;\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n\n#endif /* INSIGHTS_CLANG_COMPAT_H */\n"
        },
        {
          "name": "CodeGenerator.cpp",
          "type": "blob",
          "size": 190.2919921875,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#include <algorithm>\n#include <optional>\n#include <vector>\n\n#include \"ASTHelpers.h\"\n#include \"ClangCompat.h\"\n#include \"CodeGenerator.h\"\n#include \"DPrint.h\"\n#include \"Insights.h\"\n#include \"InsightsHelpers.h\"\n#include \"InsightsOnce.h\"\n#include \"InsightsStrCat.h\"\n#include \"NumberIterator.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/Support/Path.h\"\n//-----------------------------------------------------------------------------\n\n/// \\brief Convenience macro to create a \\ref LambdaScopeHandler on the stack.\n#define LAMBDA_SCOPE_HELPER(type)                                                                                      \\\n    LambdaScopeHandler lambdaScopeHandler{mLambdaStack, mOutputFormatHelper, LambdaCallerType::type};\n//-----------------------------------------------------------------------------\n\n/// \\brief The lambda scope helper is only created if cond is true\n#define CONDITIONAL_LAMBDA_SCOPE_HELPER(type, cond)                                                                    \\\n    std::optional<LambdaScopeHandler> lambdaScopeHandler;                                                              \\\n    if(cond) {                                                                                                         \\\n        lambdaScopeHandler.emplace(mLambdaStack, mOutputFormatHelper, LambdaCallerType::type);                         \\\n    }\n//-----------------------------------------------------------------------------\n\nnamespace ranges = std::ranges;\n//-----------------------------------------------------------------------------\nnamespace clang::insights {\n\n#define BUILD_OPT_AND(name, param) std::function name = [](param t) -> MyOptional<param>\n#define BUILD_OPT_AND_O(name, param, ret) std::function name = [](param t) -> MyOptional<ret>\n\nBUILD_OPT_AND(IsPointer, QualType)\n{\n    if(t->isPointerType()) {\n        return t;\n    }\n\n    return {};\n};\n\nBUILD_OPT_AND(IsPOD, QualType)\n{\n    if(t.isPODType(GetGlobalAST())) {\n        return t;\n    }\n\n    return {};\n};\n\ntemplate<typename T>\nstd::function Isa = [](QualType t) -> MyOptional<QualType> {\n    if(isa<T>(t.getTypePtrOrNull())) {\n        return t;\n    }\n\n    return {};\n};\n\nBUILD_OPT_AND_O(CanonicalType, const InitListExpr&, QualType)\n{\n    return t.getType().getCanonicalType();\n};\n\nstatic std::string AccessToStringWithColon(const AccessSpecifier& access)\n{\n    std::string accessStr{getAccessSpelling(access)};\n    if(not accessStr.empty()) {\n        accessStr += \": \"sv;\n    }\n\n    return accessStr;\n}\n//-----------------------------------------------------------------------------\n\nusing namespace asthelpers;\n\nstatic std::string_view GetCastName(const CastKind castKind, bool constnessChange = false)\n{\n    if(is{castKind}.any_of(CastKind::CK_BitCast, CastKind::CK_IntegralToPointer, CastKind::CK_PointerToIntegral)) {\n        return kwReinterpretCast;\n    }\n\n    if((CastKind::CK_NoOp == castKind) and constnessChange) {\n        return \"const_cast\"sv;\n    }\n\n    return kwStaticCast;\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string_view GetTagDeclTypeName(const TagDecl& decl)\n{\n    if(decl.isClass()) {\n        return kwClassSpace;\n\n    } else if(decl.isUnion()) {\n        return kwUnionSpace;\n\n    } else {\n        return kwStructSpace;\n    }\n}\n//-----------------------------------------------------------------------------\n\nclass ArrayInitCodeGenerator final : public CodeGenerator\n{\n    const uint64_t mIndex;\n\npublic:\n    ArrayInitCodeGenerator(OutputFormatHelper& _outputFormatHelper, const uint64_t index)\n    : CodeGenerator{_outputFormatHelper}\n    , mIndex{index}\n    {\n    }\n\n    using CodeGenerator::InsertArg;\n    void InsertArg(const ArrayInitIndexExpr*) override { mOutputFormatHelper.Append(mIndex); }\n};\n//-----------------------------------------------------------------------------\n\n/// Handling specialties for decomposition declarations.\n///\n/// Decompositions declarations have no name. This class stores the made up name and returns it each time the anonymous\n/// declaration is asked for a name.\nclass StructuredBindingsCodeGenerator final : public CodeGenerator\n{\n    std::string mVarName;\n\npublic:\n    StructuredBindingsCodeGenerator(OutputFormatHelper& _outputFormatHelper, std::string&& varName)\n    : CodeGenerator{_outputFormatHelper}\n    , mVarName{std::move(varName)}\n    {\n    }\n\n    using CodeGenerator::InsertArg;\n    void InsertArg(const DeclRefExpr* stmt) override;\n    void InsertArg(const BindingDecl* stmt) override;\n\n    /// Inserts the bindings of a decompositions declaration.\n    void InsertDecompositionBindings(const DecompositionDecl& decompositionDeclStmt);\n\nprotected:\n    virtual bool ShowXValueCasts() const override { return true; }\n};\n//-----------------------------------------------------------------------------\n\n/// Handle using statements which pull functions ore members from a base class into the class.\nclass UsingCodeGenerator final : public CodeGenerator\n{\npublic:\n    UsingCodeGenerator(OutputFormatHelper& _outputFormatHelper)\n    : CodeGenerator{_outputFormatHelper}\n    {\n    }\n\n    using CodeGenerator::InsertArg;\n    void InsertArg(const CXXMethodDecl* stmt) override\n    {\n        mOutputFormatHelper.Append(kwCppCommentStartSpace);\n\n        InsertCXXMethodDecl(stmt, SkipBody::Yes);\n    }\n\n    void InsertArg(const FieldDecl* stmt) override\n    {\n        mOutputFormatHelper.Append(kwCppCommentStartSpace);\n        CodeGenerator::InsertArg(stmt);\n    }\n\n    // makes no sense to insert the class when applying it to using\n    void InsertArg(const CXXRecordDecl*) override {}\n\n    // makes no sense to insert the typedef when applying it to using\n    void InsertArg(const TypedefDecl*) override {}\n\nprotected:\n    bool InsertNamespace() const override { return true; }\n};\n//-----------------------------------------------------------------------------\n\n/// \\brief A special code generator for Lambda init captures which use \\c std::move\nclass LambdaInitCaptureCodeGenerator final : public CodeGenerator\n{\npublic:\n    explicit LambdaInitCaptureCodeGenerator(OutputFormatHelper& outputFormatHelper,\n                                            LambdaStackType&    lambdaStack,\n                                            std::string_view    varName)\n    : CodeGenerator{outputFormatHelper, lambdaStack, ProcessingPrimaryTemplate::No}\n    , mVarName{varName}\n    {\n    }\n\n    using CodeGenerator::InsertArg;\n\n    /// Replace every \\c VarDecl with the given variable name. This cover init captures which introduce a new name.\n    /// However, it means that _all_ VarDecl's will be changed.\n    /// TODO: Check if it is really good to replace all VarDecl's\n    void InsertArg(const DeclRefExpr* stmt) override\n    {\n        if(isa<VarDecl>(stmt->getDecl())) {\n            mOutputFormatHelper.Append(\"_\"sv, mVarName);\n\n        } else {\n\n            CodeGenerator::InsertArg(stmt);\n        }\n    }\n\nprivate:\n    std::string_view mVarName;  ///< The name of the variable that needs to be prefixed with _.\n};\n//-----------------------------------------------------------------------------\n\nclass LambdaNameOnlyCodeGenerator final : public CodeGenerator\n{\npublic:\n    using CodeGenerator::CodeGenerator;\n    using CodeGenerator::InsertArg;\n\n    void InsertArg(const LambdaExpr* stmt) override { mOutputFormatHelper.Append(GetLambdaName(*stmt), \"{}\"sv); }\n};\n//-----------------------------------------------------------------------------\n\nCodeGenerator::LambdaScopeHandler::LambdaScopeHandler(LambdaStackType&       stack,\n                                                      OutputFormatHelper&    outputFormatHelper,\n                                                      const LambdaCallerType lambdaCallerType)\n: mStack{stack}\n, mHelper{lambdaCallerType, GetBuffer(outputFormatHelper)}\n{\n    mStack.push(mHelper);\n}\n//-----------------------------------------------------------------------------\n\nCodeGenerator::LambdaScopeHandler::~LambdaScopeHandler()\n{\n    if(not mStack.empty()) {\n        mStack.pop()->finish();\n    }\n}\n//-----------------------------------------------------------------------------\n\nOutputFormatHelper& CodeGenerator::LambdaScopeHandler::GetBuffer(OutputFormatHelper& outputFormatHelper) const\n{\n    // Find the most outer element to place the lambda class definition. For example, if we have this:\n    // Test( [&]() {} );\n    // The lambda's class definition needs to be placed _before_ the CallExpr to Test.\n    for(auto& l : mStack) {\n        switch(l.callerType()) {\n            case LambdaCallerType::CallExpr: [[fallthrough]];\n            case LambdaCallerType::VarDecl: [[fallthrough]];\n            case LambdaCallerType::ReturnStmt: [[fallthrough]];\n            case LambdaCallerType::OperatorCallExpr: [[fallthrough]];\n            case LambdaCallerType::MemberCallExpr: [[fallthrough]];\n            case LambdaCallerType::BinaryOperator: [[fallthrough]];\n            case LambdaCallerType::CXXMethodDecl: return l.buffer();\n            default: break;\n        }\n    }\n\n    return outputFormatHelper;\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string_view ArrowOrDot(bool isArrow)\n{\n    return isArrow ? \"->\"sv : \".\"sv;\n}\n//-----------------------------------------------------------------------------\n\ntemplate<typename T>\nstatic T ValueOrDefault(bool b, T v)\n{\n    if(b) {\n        return v;\n    }\n\n    return {};\n}\n//-----------------------------------------------------------------------------\n\ntemplate<typename T>\nstatic T ValueOr(bool b, T val, T el)\n{\n    if(b) {\n        return val;\n    }\n\n    return el;\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXDependentScopeMemberExpr* stmt)\n{\n    if(not stmt->isImplicitAccess()) {\n        InsertArg(stmt->getBase());\n    } else {\n        InsertNamespace(stmt->getQualifier());\n    }\n\n    std::string_view op{ValueOrDefault(not stmt->isImplicitAccess(), ArrowOrDot(stmt->isArrow()))};\n\n    mOutputFormatHelper.Append(op, stmt->getMemberNameInfo().getAsString());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXForRangeStmt* rangeForStmt)\n{\n    auto&      langOpts{GetLangOpts(*rangeForStmt->getLoopVariable())};\n    const bool onlyCpp11{not langOpts.CPlusPlus17};\n\n    auto* rwStmt = const_cast<CXXForRangeStmt*>(rangeForStmt);\n\n    StmtsContainer outerScopeStmts{};\n\n    // C++20 init-statement\n    outerScopeStmts.Add(rangeForStmt->getInit());\n\n    // range statement\n    outerScopeStmts.Add(rangeForStmt->getRangeStmt());\n\n    if(not onlyCpp11) {\n        outerScopeStmts.Add(rangeForStmt->getBeginStmt());\n        outerScopeStmts.Add(rangeForStmt->getEndStmt());\n    }\n\n    // add the loop variable to the body\n    StmtsContainer bodyStmts{};\n    bodyStmts.Add(rangeForStmt->getLoopVarStmt());\n\n    // add the body itself, without the CompoundStmt\n    bodyStmts.AddBodyStmts(rwStmt->getBody());\n\n    const auto& ctx = rangeForStmt->getLoopVariable()->getASTContext();\n\n    // In case of a range-based for-loop inside an unevaluated template the begin and end statements are not present. In\n    // this case just add a nullptr.\n    auto* declStmt = [&]() -> DeclStmt* {\n        if(onlyCpp11) {\n            return mkDeclStmt(rwStmt->getBeginStmt() ? rwStmt->getBeginStmt()->getSingleDecl() : nullptr,\n                              rwStmt->getEndStmt() ? rwStmt->getEndStmt()->getSingleDecl() : nullptr);\n        }\n\n        return nullptr;\n    }();\n\n    auto* innerScope = mkCompoundStmt(bodyStmts, rangeForStmt->getBeginLoc(), rangeForStmt->getEndLoc());\n\n    auto* forStmt = new(ctx) ForStmt(ctx,\n                                     declStmt,\n                                     rwStmt->getCond(),\n                                     rwStmt->getLoopVariable(),\n                                     rwStmt->getInc(),\n                                     innerScope,\n                                     rangeForStmt->getBeginLoc(),\n                                     rangeForStmt->getEndLoc(),\n                                     rangeForStmt->getEndLoc());\n\n    outerScopeStmts.Add(forStmt);\n\n    auto* outerScope = mkCompoundStmt(outerScopeStmts, rangeForStmt->getBeginLoc(), rangeForStmt->getEndLoc());\n\n    InsertArg(outerScope);\n\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertQualifierAndName(const DeclarationName&     declName,\n                                           const NestedNameSpecifier* qualifier,\n                                           const bool                 hasTemplateKeyword)\n{\n    mOutputFormatHelper.Append(ScopeHandler::RemoveCurrentScope(GetNestedName(qualifier)),\n                               ValueOrDefault(hasTemplateKeyword, kwTemplateSpace),\n                               declName.getAsString());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertNamespace(const NestedNameSpecifier* stmt)\n{\n    mOutputFormatHelper.Append(ScopeHandler::RemoveCurrentScope(GetNestedName(stmt)));\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const UnresolvedLookupExpr* stmt)\n{\n    InsertQualifierAndNameWithTemplateArgs(stmt->getName(), stmt);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const DependentScopeDeclRefExpr* stmt)\n{\n    InsertQualifierAndNameWithTemplateArgs(stmt->getDeclName(), stmt);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const VarTemplateDecl* stmt)\n{\n    const auto* templatedDecl = stmt->getTemplatedDecl();\n\n    // Insert only the primary template here. The specializations are inserted via their instantiated\n    // VarTemplateSpecializationDecl which resolved to a VarDecl. It looks like whether the variable has an initializer\n    // or not can be used to distinguish between the primary template and one appearing in a templated class.\n    RETURN_IF(not templatedDecl->hasInit());\n\n    // VarTemplatedDecl's can have lambdas as initializers. Push a VarDecl on the stack, otherwise the lambda would\n    // appear in the middle of template<....> and the variable itself.\n    {\n        LAMBDA_SCOPE_HELPER(Decltype);  // Needed for P0315Checker\n        mLambdaStack.back().setInsertName(true);\n\n        InsertTemplateParameters(*stmt->getTemplateParameters());\n    }\n\n    LAMBDA_SCOPE_HELPER(VarDecl);\n\n    InsertArg(templatedDecl);\n\n    for(OnceTrue first{}; const auto* spec : stmt->specializations()) {\n        if(TSK_ExplicitSpecialization == spec->getSpecializationKind()) {\n            continue;\n        }\n\n        if(first) {\n            mOutputFormatHelper.AppendNewLine();\n        }\n\n        InsertArg(spec);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ConceptDecl* stmt)\n{\n    LAMBDA_SCOPE_HELPER(Decltype);\n\n    InsertTemplateParameters(*stmt->getTemplateParameters());\n    mOutputFormatHelper.Append(kwConceptSpace, stmt->getName(), hlpAssing);\n\n    InsertArg(stmt->getConstraintExpr());\n    mOutputFormatHelper.AppendSemiNewLine();\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ConditionalOperator* stmt)\n{\n    InsertArg(stmt->getCond());\n    mOutputFormatHelper.Append(\" ? \"sv);\n    InsertArg(stmt->getLHS());\n    mOutputFormatHelper.Append(\" : \"sv);\n    InsertArg(stmt->getRHS());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const DoStmt* stmt)\n{\n    mOutputFormatHelper.Append(kwDoSpace);\n\n    WrapInCompoundIfNeeded(stmt->getBody(), AddNewLineAfter::No);\n\n    mOutputFormatHelper.Append(kwWhile);\n    WrapInParens([&]() { InsertArg(stmt->getCond()); }, AddSpaceAtTheEnd::No);\n\n    mOutputFormatHelper.AppendSemiNewLine();\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CaseStmt* stmt)\n{\n    mOutputFormatHelper.Append(kwCaseSpace);\n    InsertArg(stmt->getLHS());\n\n    mOutputFormatHelper.Append(\": \"sv);\n    InsertArg(stmt->getSubStmt());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const BreakStmt* /*stmt*/)\n{\n    mOutputFormatHelper.Append(kwBreak);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const DefaultStmt* stmt)\n{\n    mOutputFormatHelper.Append(\"default: \"sv);\n    InsertArg(stmt->getSubStmt());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ContinueStmt* /*stmt*/)\n{\n    mOutputFormatHelper.Append(kwContinue);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const GotoStmt* stmt)\n{\n    mOutputFormatHelper.Append(kwGotoSpace);\n    InsertArg(stmt->getLabel());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const LabelStmt* stmt)\n{\n    mOutputFormatHelper.AppendNewLine(stmt->getName(), \":\"sv);\n\n    if(stmt->getSubStmt()) {\n        InsertArg(stmt->getSubStmt());\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const SwitchStmt* stmt)\n{\n    const bool hasInit{stmt->getInit() or stmt->getConditionVariable()};\n\n    if(hasInit) {\n        mOutputFormatHelper.OpenScope();\n\n        InsertIfOrSwitchInitVariables(stmt);\n    }\n\n    mOutputFormatHelper.Append(kwSwitch);\n\n    WrapInParens([&]() { InsertArg(stmt->getCond()); }, AddSpaceAtTheEnd::Yes);\n\n    InsertArg(stmt->getBody());\n\n    if(hasInit) {\n        mOutputFormatHelper.CloseScope();\n    }\n\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const WhileStmt* stmt)\n{\n    auto* rwStmt = const_cast<WhileStmt*>(stmt);\n    auto* conditionVar{rwStmt->getConditionVariable()};\n\n    {\n        // We need to handle the case that a lambda is used in the init-statement of the for-loop.\n        LAMBDA_SCOPE_HELPER(VarDecl);\n\n        if(conditionVar) {\n            mOutputFormatHelper.OpenScope();\n\n            InsertArg(conditionVar);\n        }\n\n        mOutputFormatHelper.Append(kwWhile);\n        WrapInParens([&]() { InsertArg(stmt->getCond()); }, AddSpaceAtTheEnd::Yes);\n    }\n\n    if(not conditionVar) {\n        WrapInCompoundIfNeeded(stmt->getBody(), AddNewLineAfter::Yes);\n    } else {\n        const auto&    ctx = GetGlobalAST();\n        StmtsContainer bodyStmts{};\n\n        bodyStmts.AddBodyStmts(rwStmt->getBody());\n        bodyStmts.AddBodyStmts(Assign(conditionVar, conditionVar->getInit()));\n\n        InsertArg(mkCompoundStmt(bodyStmts, stmt->getBeginLoc(), stmt->getEndLoc()));\n    }\n\n    if(conditionVar) {\n        mOutputFormatHelper.CloseScope();\n    }\n\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\n/// Get the name of a \\c FieldDecl in case this \\c FieldDecl is part of a lambda. The name has to be retrieved from the\n/// capture fields or can be \\c __this.\nstatic std::optional<std::string> GetFieldDeclNameForLambda(const FieldDecl&     fieldDecl,\n                                                            const CXXRecordDecl& cxxRecordDecl)\n{\n    if(cxxRecordDecl.isLambda()) {\n        llvm::DenseMap<const ValueDecl*, FieldDecl*> captures{};\n\n        FieldDecl* thisCapture{};\n\n        cxxRecordDecl.getCaptureFields(captures, thisCapture);\n\n        if(&fieldDecl == thisCapture) {\n            return std::string{kwInternalThis};\n        } else {\n            for(const auto& [key, value] : captures) {\n                if(&fieldDecl == value) {\n                    return GetName(*key);\n                }\n            }\n        }\n    }\n\n    return {};\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const SourceLocExpr* stmt)\n{\n    mOutputFormatHelper.Append(stmt->getBuiltinStr(), \"()\"sv);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const MemberExpr* stmt)\n{\n    const auto* base = stmt->getBase();\n    const bool  skipBase{[&] {\n        if(const auto* implicitCast = dyn_cast_or_null<ImplicitCastExpr>(base)) {\n            if(CastKind::CK_UncheckedDerivedToBase == implicitCast->getCastKind()) {\n                // if this calls a protected function we cannot cast it to the base, this would not compile\n                return isa<CXXThisExpr>(implicitCast->IgnoreImpCasts());\n            }\n        }\n\n        return false;\n    }()};\n\n    if(skipBase) {\n        mOutputFormatHelper.Append(kwCCommentStartSpace);\n    }\n\n    InsertArg(base);\n\n    const auto* meDecl = stmt->getMemberDecl();\n    bool        skipTemplateArgs{false};\n    const auto  name = [&]() -> std::string {\n        // Handle a special case where we have a lambda static invoke operator. In that case use the appropriate\n        // using retType as return type\n        if(const auto* m = dyn_cast_or_null<CXXMethodDecl>(meDecl)) {\n            if(const auto* rd = m->getParent(); rd and rd->isLambda() and isa<CXXConversionDecl>(m)) {\n                skipTemplateArgs = true;\n\n                return StrCat(kwOperatorSpace, GetLambdaName(*rd), \"::\"sv, BuildRetTypeName(*rd));\n            }\n        }\n\n        // This is at least the case for lambdas, where members are created by capturing a structured binding. See #181.\n        else if(const auto* fd = dyn_cast_or_null<FieldDecl>(meDecl)) {\n            if(const auto* cxxRecordDecl = dyn_cast_or_null<CXXRecordDecl>(fd->getParent())) {\n                if(const auto& fieldName = GetFieldDeclNameForLambda(*fd, *cxxRecordDecl)) {\n                    return fieldName.value();\n                }\n            }\n        }\n\n        // Special case. If this is a CXXConversionDecl it might be:\n        // a) a template so we need the template arguments from this type\n        // b) in a namespace and need want to preserve that one.\n        if(const auto* convDecl = dyn_cast_or_null<CXXConversionDecl>(meDecl)) {\n            return StrCat(kwOperatorSpace, GetName(convDecl->getConversionType()));\n        }\n\n        return stmt->getMemberNameInfo().getName().getAsString();\n    }();\n\n    mOutputFormatHelper.Append(ArrowOrDot(stmt->isArrow()));\n\n    if(skipBase) {\n        mOutputFormatHelper.Append(kwSpaceCCommentEndSpace);\n    }\n\n    mOutputFormatHelper.Append(name);\n\n    RETURN_IF(skipTemplateArgs);\n\n    if(const auto cxxMethod = dyn_cast_or_null<CXXMethodDecl>(meDecl)) {\n        if(const auto* tmplArgs = cxxMethod->getTemplateSpecializationArgs()) {\n            OutputFormatHelper ofm{};\n\n            ofm.Append('<');\n\n            bool haveArg{false};\n            for(OnceFalse needsComma{}; const auto& arg : tmplArgs->asArray()) {\n                if(arg.getKind() == TemplateArgument::Integral) {\n                    ofm.AppendComma(needsComma);\n\n                    ofm.Append(arg.getAsIntegral());\n                    haveArg = true;\n                } else {\n\n                    break;\n                }\n            }\n\n            if(haveArg) {\n                mOutputFormatHelper.Append(ofm, \">\"sv);\n\n            } else if(not isa<CXXConversionDecl>(meDecl)) {  // A special case from p0892 a templated conversion\n                                                             // operator does not carry the specialization args...\n                InsertTemplateArgs(*tmplArgs);\n            }\n        }\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const UnaryExprOrTypeTraitExpr* stmt)\n{\n    mOutputFormatHelper.Append(std::string_view{getTraitSpelling(stmt->getKind())});\n\n    if(not stmt->isArgumentType()) {\n        const auto* argExpr = stmt->getArgumentExpr();\n        const bool  needsParens{not isa<ParenExpr>(argExpr)};\n\n        WrapInParensIfNeeded(needsParens, [&] { InsertArg(argExpr); });\n\n    } else {\n        WrapInParens([&] { mOutputFormatHelper.Append(GetName(stmt->getTypeOfArgument())); });\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const IntegerLiteral* stmt)\n{\n    const auto& type     = stmt->getType();\n    const bool  isSigned = type->isSignedIntegerType();\n\n    mOutputFormatHelper.Append(llvm::toString(stmt->getValue(), 10, isSigned));\n\n    InsertSuffix(type);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const FloatingLiteral* stmt)\n{\n    // FIXME: not working correctly\n    mOutputFormatHelper.Append(EvaluateAsFloat(*stmt));\n    InsertSuffix(stmt->getType());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXTypeidExpr* stmt)\n{\n    mOutputFormatHelper.Append(kwTypeId);\n    WrapInParens([&]() {\n        if(stmt->isTypeOperand()) {\n            mOutputFormatHelper.Append(GetName(stmt->getTypeOperand(const_cast<ASTContext&>(GetGlobalAST()))));\n        } else {\n            InsertArg(stmt->getExprOperand());\n        }\n    });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const BinaryOperator* stmt)\n{\n    LAMBDA_SCOPE_HELPER(BinaryOperator);\n\n    BackupAndRestore _{mLastExpr, stmt->getLHS()};\n\n    const bool needLHSParens{isa<BinaryOperator>(stmt->getLHS()->IgnoreImpCasts())};\n    WrapInParensIfNeeded(needLHSParens, [&] { InsertArg(stmt->getLHS()); });\n\n    mOutputFormatHelper.Append(\" \"sv, stmt->getOpcodeStr(), \" \"sv);\n\n    const bool needRHSParens{isa<BinaryOperator>(stmt->getRHS()->IgnoreImpCasts())};\n    WrapInParensIfNeeded(needRHSParens, [&] { InsertArg(stmt->getRHS()); });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CompoundAssignOperator* stmt)\n{\n    LAMBDA_SCOPE_HELPER(BinaryOperator);\n\n    const bool needLHSParens{isa<BinaryOperator>(stmt->getLHS()->IgnoreImpCasts())};\n    WrapInParensIfNeeded(needLHSParens, [&] { InsertArg(stmt->getLHS()); });\n\n    mOutputFormatHelper.Append(hlpAssing);\n\n    // we may need a cast around this back to the src type\n    const bool needCast{stmt->getLHS()->getType() != stmt->getComputationLHSType()};\n    if(needCast) {\n        mOutputFormatHelper.Append(kwStaticCast, \"<\"sv, GetName(stmt->getLHS()->getType()), \">(\"sv);\n    }\n\n    WrapInParensIfNeeded(needLHSParens, [&] {\n        clang::ExprResult res = stmt->getLHS();\n\n        // This cast is not present in the AST. However, if the LHS type is smaller than RHS there is an implicit cast\n        // to RHS-type and the result is casted back to LHS-type: static_cast<LHSTy>( static_cast<RHSTy>(LHS) + RHS )\n        if(const auto resultingType = GetGlobalCI().getSema().PrepareScalarCast(res, stmt->getComputationLHSType());\n           resultingType != CK_NoOp) {\n            const QualType castDestType = stmt->getComputationLHSType();\n            FormatCast(kwStaticCast, castDestType, stmt->getLHS(), resultingType);\n        } else {\n            InsertArg(stmt->getLHS());\n        }\n    });\n\n    mOutputFormatHelper.Append(\n        \" \"sv, BinaryOperator::getOpcodeStr(BinaryOperator::getOpForCompoundAssignment(stmt->getOpcode())), \" \"sv);\n\n    const bool needRHSParens{isa<BinaryOperator>(stmt->getRHS()->IgnoreImpCasts())};\n    WrapInParensIfNeeded(needRHSParens, [&] { InsertArg(stmt->getRHS()); });\n\n    if(needCast) {\n        mOutputFormatHelper.Append(\")\"sv);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXRewrittenBinaryOperator* stmt)\n{\n    LAMBDA_SCOPE_HELPER(BinaryOperator);\n\n    InsertArg(stmt->getSemanticForm());\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string_view GetStorageClassAsString(const StorageClass& sc)\n{\n    if(SC_None != sc) {\n        return VarDecl::getStorageClassSpecifierString(sc);\n    }\n\n    return {};\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string GetStorageClassAsStringWithSpace(const StorageClass& sc)\n{\n    std::string ret{GetStorageClassAsString(sc)};\n\n    if(not ret.empty()) {\n        ret.append(\" \"sv);\n    }\n\n    return ret;\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string GetQualifiers(const VarDecl& vd)\n{\n    std::string qualifiers{};\n\n    if(vd.isInline() or vd.isInlineSpecified()) {\n        qualifiers += kwInlineSpace;\n    }\n\n    qualifiers += GetStorageClassAsStringWithSpace(vd.getStorageClass());\n\n    if(vd.isConstexpr()) {\n        qualifiers += kwConstExprSpace;\n    }\n\n    return qualifiers;\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string FormatVarTemplateSpecializationDecl(const Decl* decl, std::string&& defaultName)\n{\n    std::string name{std::move(defaultName)};\n\n    if(const auto* tvd = dyn_cast_or_null<VarTemplateSpecializationDecl>(decl)) {\n        OutputFormatHelper   outputFormatHelper{};\n        CodeGeneratorVariant codeGenerator{outputFormatHelper};\n\n        codeGenerator->InsertTemplateArgs(tvd->getTemplateArgs());\n\n        name += outputFormatHelper;\n    }\n\n    return name;\n}\n//-----------------------------------------------------------------------------\n\n/// \\brief Find a \\c DeclRefExpr belonging to a \\c DecompositionDecl\nclass BindingDeclFinder : public ConstStmtVisitor<BindingDeclFinder>\n{\n    bool mIsBinding{};\n\npublic:\n    BindingDeclFinder() = default;\n\n    void VisitDeclRefExpr(const DeclRefExpr* expr)\n    {\n        if(isa<DecompositionDecl>(expr->getDecl())) {\n            mIsBinding = true;\n        }\n    }\n\n    void VisitStmt(const Stmt* stmt)\n    {\n        for(const auto* child : stmt->children()) {\n            if(child) {\n                Visit(child);\n            }\n\n            RETURN_IF(mIsBinding);\n        }\n    }\n\n    bool Find(const Stmt* stmt)\n    {\n        if(stmt) {\n            VisitStmt(stmt);\n        }\n\n        return mIsBinding;\n    }\n};\n//-----------------------------------------------------------------------------\n\n/// \\brief Find a \\c DeclRefExpr belonging to a \\c DecompositionDecl\nclass TemporaryDeclFinder : public StmtVisitor<TemporaryDeclFinder>\n{\n    CodeGenerator&        codeGenerator;\n    bool                  mFound{};\n    bool                  mHaveTemporary{};\n    Stmt*                 mPrevStmt{};\n    std::string           mTempName{};\n    std::vector<VarDecl*> mDecls{};\n\npublic:\n    TemporaryDeclFinder(CodeGenerator& _codeGenerator, const Stmt* stmt, bool inspectReturn = false)\n    : codeGenerator{_codeGenerator}\n    , mPrevStmt{const_cast<Stmt*>(stmt)}\n    {\n        RETURN_IF(not GetInsightsOptions().ShowLifetime);\n\n        Visit(mPrevStmt);\n\n        for(auto d : mDecls) {\n            codeGenerator.InsertArg(d);\n        }\n\n        RETURN_IF(not GetInsightsOptions().UseShow2C or mFound or not inspectReturn);\n\n        if(auto* expr = dyn_cast_or_null<CXXConstructExpr>(stmt)) {\n            mTempName = GetTemporaryName(*expr);\n#if 0\n                auto* dummy = Function(\"dummy\"sv, VoidTy(), {});\n\n                auto* vd = Variable(mTempName, expr->getType(), dummy->getDeclContext());\n                dummy->getDeclContext()->addDecl(vd);\n                vd->setInit(const_cast<CXXConstructExpr*>(expr));\n                vd->setStorageClass(SC_None);\n#else\n            // XXX hack. Our normal VarDecl is at TU level. It then appears in cxa_start...\n            auto& ctx = GetGlobalAST();\n            auto* vd  = ImplicitParamDecl::Create(const_cast<ASTContext&>(ctx),\n                                                 ctx.getTranslationUnitDecl(),\n                                                  {},\n                                                 &ctx.Idents.get(mTempName),\n                                                 expr->getType(),\n#if IS_CLANG_NEWER_THAN(17)\n                                                 ImplicitParamKind::Other\n#else\n                                                 ImplicitParamDecl::Other\n#endif\n            );\n\n#endif\n\n            mFound = true;\n            codeGenerator.InsertArg(vd);\n\n        } else if(auto* expr = dyn_cast_or_null<InitListExpr>(stmt)) {\n            mTempName = GetTemporaryName(*expr);\n            auto* vd  = Variable(mTempName, expr->getType());\n            vd->setInit(const_cast<InitListExpr*>(expr));\n            mFound = true;\n            codeGenerator.InsertArg(vd);\n        }\n    }\n\n    ~TemporaryDeclFinder()\n    {\n        if(mHaveTemporary) {\n            codeGenerator.EndLifetimeScope();\n        }\n    }\n\n    bool Found() const { return mFound; }\n\n    std::string Name() const { return mTempName; }\n\n    void VisitCXXTemporaryObjectExpr(CXXTemporaryObjectExpr* expr)\n    {\n        mTempName = GetName(*expr);\n        mFound    = true;\n\n        auto* vd = Variable(mTempName, expr->getType());\n\n        // In the Cfront case the contents of the expression go after the generated constructor. In the lifetime\n        // _only_ case go with the variable.\n        if(not GetInsightsOptions().UseShow2C) {\n            // Since we insert the statement below we must clone this expression otherwise we look at a recursion.\n            auto* ctorConstructExpr = CXXConstructExpr::Create(GetGlobalAST(),\n                                                               expr->getType(),\n                                                               expr->getBeginLoc(),\n                                                               expr->getConstructor(),\n                                                               expr->isElidable(),\n                                                               {expr->getArgs(), expr->getNumArgs()},\n                                                               expr->hadMultipleCandidates(),\n                                                               expr->isListInitialization(),\n                                                               expr->isStdInitListInitialization(),\n                                                               expr->requiresZeroInitialization(),\n                                                               expr->getConstructionKind(),\n                                                               expr->getParenOrBraceRange());\n\n            vd->setInit(ctorConstructExpr);\n\n            auto* newValue = mkDeclRefExpr(vd);\n            ReplaceNode(mPrevStmt, expr, newValue);\n        }\n\n        mDecls.push_back(vd);\n    }\n\n#if 0\n    void VisitCXXBindTemporaryExpr(CXXBindTemporaryExpr* stmt)\n    {\n        auto& ctx = GetGlobalAST();\n\n        const auto name = MakeLineColumnName(ctx.getSourceManager(), stmt->getBeginLoc(), \"temp\"sv);\n        mFound          = true;\n\n        auto* vd = Variable(name, stmt->getType());\n        codeGenerator.InsertArg(vd);\n\n        StmtVisitor<TemporaryDeclFinder>::VisitCXXBindTemporaryExpr(stmt);\n    }\n#endif\n\n    void VisitMaterializeTemporaryExpr(MaterializeTemporaryExpr* stmt)\n    {\n        StmtVisitor<TemporaryDeclFinder>::VisitMaterializeTemporaryExpr(stmt);\n\n        RETURN_IF(mFound);\n\n        auto* vd = Variable(GetTemporaryName(*stmt), stmt->getType());\n        vd->setInit(stmt->getSubExpr());\n\n        auto* newValue = mkDeclRefExpr(vd);\n        ReplaceNode(mPrevStmt, stmt, newValue);\n\n        if(SD_FullExpression == stmt->getStorageDuration() and not mHaveTemporary) {\n            codeGenerator.StartLifetimeScope();\n            mHaveTemporary = true;\n        } else if(const auto* extending = stmt->getExtendingDecl()) {\n            codeGenerator.LifetimeAddExtended(vd, extending);\n        }\n\n        mDecls.push_back(vd);\n    }\n\n    void VisitStmt(Stmt* stmt)\n    {\n        auto* tmp = mPrevStmt;\n        mPrevStmt = stmt;\n\n        for(auto* child : stmt->children()) {\n            Visit(child);\n        }\n\n        mPrevStmt = tmp;\n    }\n\n    void Visit(Stmt* stmt)\n    {\n        if(stmt) {\n            StmtVisitor<TemporaryDeclFinder>::Visit(stmt);\n        }\n    }\n};\n//-----------------------------------------------------------------------------\n\n/*constinit*/ static SmallVector<std::pair<std::pair<const CXXRecordDecl*, const CXXRecordDecl*>, VarDecl*>, 10>\n                                            gVtables{};\n/*constinit*/ static SmallVector<Expr*, 10> globalVarCtors{};\n/*constinit*/ static SmallVector<Expr*, 10> globalVarDtors{};\n//-----------------------------------------------------------------------------\n\nint GetGlobalVtablePos(const CXXRecordDecl* record, const CXXRecordDecl* recordB)\n{\n    auto iter = std::ranges::find_if(\n        gVtables, [&](const auto& e) { return (e.first.first == record) and (e.first.second == recordB); });\n\n    if(iter == gVtables.end()) {\n        iter = std::ranges::find_if(gVtables, [&](const auto& e) { return e.first.first == record; });\n    }\n\n    return std::distance(gVtables.begin(), iter);\n}\n//-----------------------------------------------------------------------------\n\nvoid PushVtableEntry(const CXXRecordDecl* record, const CXXRecordDecl* recordB, VarDecl* decl)\n{\n    gVtables.push_back({{record, recordB}, decl});\n}\n//-----------------------------------------------------------------------------\n\nstatic void PushGlobalVariable(const Expr* callExpr)\n{\n    globalVarCtors.push_back(const_cast<Expr*>(callExpr));\n}\n//-----------------------------------------------------------------------------\n\nstatic void PushGlobalVariableDtor(const Expr* callExpr)\n{\n    globalVarDtors.push_back(const_cast<Expr*>(callExpr));\n}\n//-----------------------------------------------------------------------------\n\nstd::string EmitGlobalVariableCtors()\n{\n    StmtsContainer bodyStmts{};\n\n    for(auto& e : globalVarCtors) {\n        bodyStmts.AddBodyStmts(e);\n    }\n\n    auto* cxaStartFun = Function(cxaStart, VoidTy(), {});\n    cxaStartFun->setBody(mkCompoundStmt(bodyStmts));\n\n    OutputFormatHelper ofm{};\n    ofm.AppendNewLine();\n    ofm.AppendNewLine();\n    CodeGeneratorVariant cg{ofm};\n\n    if(gVtables.size()) {\n        SmallVector<Expr*, 16> mInitExprs{};\n\n        for(auto& e : gVtables) {\n            cg->InsertArg(e.second);\n            mInitExprs.push_back(mkDeclRefExpr(e.second));\n        }\n\n        ofm.AppendNewLine();\n\n        // struct __mptr *__ptbl_vec__c___src_C_[]\n        auto* vtable = CfrontCodeGenerator::VtableData().VtblArrayVar(mInitExprs.size());\n        vtable->setInit(InitList(mInitExprs, vtable->getType()));\n\n        cg->InsertArg(vtable);\n\n        ofm.AppendNewLine();\n    }\n\n    cg->InsertArg(cxaStartFun);\n\n    StmtsContainer bodyStmtsDtors{};\n\n    for(auto& e : globalVarDtors) {\n        bodyStmtsDtors.AddBodyStmts(e);\n    }\n\n    auto* cxaAtExitFun = Function(cxaAtExit, VoidTy(), {});\n    cxaAtExitFun->setBody(mkCompoundStmt(bodyStmtsDtors));\n\n    ofm.AppendNewLine();\n    cg->InsertArg(cxaAtExitFun);\n\n    return ofm.GetString();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::LifetimeAddExtended(const VarDecl* vd, const ValueDecl* extending)\n{\n    mLifeTimeTracker.AddExtended(vd, extending);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::StartLifetimeScope()\n{\n    mLifeTimeTracker.StartScope(false);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::EndLifetimeScope()\n{\n    mSkipSemi = mLifeTimeTracker.EndScope(mOutputFormatHelper, false) or mSkipSemi;\n}\n//-----------------------------------------------------------------------------\n\n// In a primary template we can see a ParenListExpr with a PackExpansionExpr. With the equal sign we need a type.\nstatic bool IsPrimaryTemplatePackExpansionExpr(const ParenListExpr* stmt)\n{\n    return stmt and stmt->getNumExprs() and isa_and_nonnull<PackExpansionExpr>(stmt->getExpr(0)) and\n           stmt->getType().isNull();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const LinkageSpecDecl* stmt)\n{\n    mOutputFormatHelper.Append(\"extern \\\"\",\n                               (\n#if IS_CLANG_NEWER_THAN(17)\n                                   LinkageSpecLanguageIDs::C\n#else\n                                   LinkageSpecDecl::lang_c\n#endif\n                                   == stmt->getLanguage())\n                                   ? \"C\"sv\n                                   : \"C++\"sv,\n                               \"\\\"\");\n    mOutputFormatHelper.OpenScope();\n\n    for(const auto* decl : stmt->decls()) {\n        InsertArg(decl);\n    }\n\n    mOutputFormatHelper.CloseScope();\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const VarDecl* stmt)\n{\n    if(auto* init = stmt->getInit();\n       GetInsightsOptions().UseShow2C and IsReferenceType(stmt) and\n       (not(isa<CallExpr>(init) or\n            (isa<ExprWithCleanups>(init) and\n             (isa<CallExpr>(dyn_cast_or_null<ExprWithCleanups>(init)->getSubExpr()) or\n              isa<MaterializeTemporaryExpr>(dyn_cast_or_null<ExprWithCleanups>(init)->getSubExpr())))))) {\n        return;\n    }\n\n    mLifeTimeTracker.Add(stmt);\n\n    // If this is part of a DecompositionDecl then ignore this VarDecl as we already have seen and inserted it. This\n    // happens in StructuredBindingsHandler3Test.cpp\n    if(BindingDeclFinder isBindingDecl{}; isBindingDecl.Find(stmt->getInit())) {\n        return;\n    }\n\n    LAMBDA_SCOPE_HELPER(VarDecl);\n    UpdateCurrentPos(mCurrentVarDeclPos);\n\n    TemporaryDeclFinder temporaryFinder{*this, stmt->getInit()};\n\n    if(InsertComma()) {\n        mOutputFormatHelper.Append(',');\n    }\n\n    // If we are looking at a static member variable of a class template which is defined out-of-line we need to\n    // protect the resulting instantiations.\n    const bool needsGuard = stmt->isOutOfLine() and isTemplateInstantiation(stmt->getTemplateSpecializationKind());\n\n    // We are looking at the primary definition of a out-of-line member variable of a class template. We need to add\n    // the template head.\n    if(stmt->isOutOfLine()) {\n        if(const auto* recordDecl = dyn_cast_or_null<CXXRecordDecl>(stmt->getDeclContext())) {\n            if(const auto* classTmpl = recordDecl->getDescribedClassTemplate()) {\n                InsertTemplateParameters(*classTmpl->getTemplateParameters());\n            }\n        }\n    }\n\n    if(isa<VarTemplateSpecializationDecl>(stmt)) {\n        InsertTemplateSpecializationHeader();\n    } else if(needsGuard) {\n        mOutputFormatHelper.InsertIfDefTemplateGuard();\n    }\n\n    InsertAttributes(stmt->attrs());\n    InsertConceptConstraint(stmt);\n\n    if(IsTrivialStaticClassVarDecl(*stmt)) {\n        HandleLocalStaticNonTrivialClass(stmt);\n\n    } else {\n        if(InsertVarDecl(stmt)) {\n            const auto desugaredType = GetType(GetDesugarType(stmt->getType()));\n\n            const bool isMemberPointer{isa<MemberPointerType>(desugaredType.getTypePtrOrNull())};\n            if(desugaredType->isFunctionPointerType() or isMemberPointer) {\n                const auto lineNo    = GetSM(*stmt).getSpellingLineNumber(stmt->getSourceRange().getBegin());\n                const auto ptrPrefix = isMemberPointer ? memberVariablePointerPrefix : functionPointerPrefix;\n                const auto funcPtrName{StrCat(ptrPrefix, lineNo)};\n\n                mOutputFormatHelper.AppendSemiNewLine(kwUsingSpace, funcPtrName, hlpAssing, GetName(desugaredType));\n                mOutputFormatHelper.Append(GetQualifiers(*stmt), funcPtrName, \" \"sv, GetName(*stmt));\n\n            } else {\n                mOutputFormatHelper.Append(GetQualifiers(*stmt));\n\n                const auto scope = [&] {\n                    if(const auto* ctx = stmt->getDeclContext(); stmt->getLexicalDeclContext() != ctx) {\n                        OutputFormatHelper scopeOfm{};\n                        scopeOfm.Append(GetDeclContext(ctx, WithTemplateParameters::Yes));\n\n                        return ScopeHandler::RemoveCurrentScope(scopeOfm.GetString());\n                    }\n\n                    return std::string{};\n                }();\n\n                const auto varName = FormatVarTemplateSpecializationDecl(stmt, StrCat(scope, GetName(*stmt)));\n\n                // TODO: to keep the special handling for lambdas, do this only for template specializations\n                mOutputFormatHelper.Append(GetTypeNameAsParameter(GetType(stmt->getType()), varName));\n            }\n        } else {\n            const std::string_view pointer = [&]() {\n                if(SkipSpaceAfterVarDecl()) {\n                    return \"\"sv;\n                }\n\n                if(stmt->getType()->isAnyPointerType()) {\n                    return \" *\"sv;\n                }\n                return \" \"sv;\n            }();\n\n            mOutputFormatHelper.Append(pointer, GetName(*stmt));\n        }\n\n        if(const auto* init = stmt->getInit()) {\n            if(const auto* ctorExpr = dyn_cast_or_null<CXXConstructExpr>(init);\n               GetInsightsOptions().UseShow2C and ctorExpr) {\n\n                // https://stackoverflow.com/questions/45471470/how-to-generate-code-for-initializing-global-variables-with-non-const-values-in\n                // https://llvm.org/docs/LangRef.html#the-llvm-global-ctors-global-variable\n                // https://stackoverflow.com/questions/72971935/why-does-clang-do-thread-safe-init-for-some-globals-but-not-others\n                // __cxx_global_var_init\n                // https://discourse.llvm.org/t/static-constructors-cxx-global-var-initn-vs-global-sub-i-xxx/39442\n                //                if(stmt->needsDestruction(stmt->getASTContext())) {\n                //\n                // at_exit\n                // https://clang.llvm.org/doxygen/CGDeclCXX_8cpp_source.html\n                // __cxa_atexit\n\n                //                if(not ctorExpr->getConstructor()->isTrivial()) {\n                if(stmt->hasGlobalStorage()) {\n                    // push to __cxx_global_var_init\n                    auto* callExpr = CallConstructor(\n                        stmt->getType(), stmt, ArgsToExprVector(ctorExpr), DoCast::No, AsReference::Yes);\n\n                    PushGlobalVariable(callExpr);\n\n                    PushGlobalVariableDtor(CallDestructor(stmt));\n\n                } else {\n                    mOutputFormatHelper.AppendSemiNewLine();\n                    InsertArg(init);\n                }\n                //                }\n\n            } else {\n                mProcessingVarDecl = false;\n                BackupAndRestore _{mProcessingVarDecl, true};\n\n                if(MyOptional<const InitListExpr*> initList{dyn_cast_or_null<InitListExpr>(init)};\n                   GetInsightsOptions().UseShow2C and\n                   initList.and_then(CanonicalType).and_then(Isa<RecordType>).and_not(IsPointer).and_then(IsPOD) and\n                   not isa<ArrayType>(stmt->getType())) {\n                    auto* callMemset = Call(\"memset\"sv, {Ref(stmt), Int32(0), Sizeof(stmt->getType())});\n\n                    EnableGlobalInsert(GlobalInserts::FuncMemset);\n\n                    if(stmt->hasGlobalStorage()) {\n                        PushGlobalVariable(callMemset);\n\n                    } else {\n                        mOutputFormatHelper.AppendSemiNewLine();\n                        InsertArg(callMemset);\n                    }\n\n                } else if(not(GetInsightsOptions().UseShow2C and\n                              initList.and_then(CanonicalType)\n                                  .and_then(Isa<RecordType>)\n                                  .and_not(IsPointer)\n                                  .and_not(IsPOD) and\n                              (0 == initList.value()->getNumInits()))) {\n\n                    // Skip the init statement in case we have a class type with a trivial default-constructor which\n                    // is used for this initialization.\n                    if(not(ctorExpr and ctorExpr->getConstructor()->isDefaultConstructor() and\n                           ctorExpr->getConstructor()->getParent()->hasTrivialDefaultConstructor())) {\n\n                        const bool isPrimaryTemplatePackExpansionExpr{\n                            IsPrimaryTemplatePackExpansionExpr(dyn_cast_or_null<ParenListExpr>(init))};\n\n                        if(not isa<CXXParenListInitExpr>(init) and not isPrimaryTemplatePackExpansionExpr) {\n                            mOutputFormatHelper.Append(hlpAssing);\n                        }\n\n                        WrapInParensIfNeeded(isPrimaryTemplatePackExpansionExpr, [&] {\n                            if(GetInsightsOptions().ShowLifetime and init->isXValue() and\n                               stmt->getType()->isRValueReferenceType()) {\n\n                                if(GetInsightsOptions().UseShow2C) {\n                                    mOutputFormatHelper.Append(\"&\");\n                                }\n\n                                InsertArg(StaticCast(stmt->getType(), init, false));\n\n                            } else {\n                                InsertArg(init);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        if(stmt->isNRVOVariable()) {\n            mOutputFormatHelper.Append(\" /* NRVO variable */\"sv);\n        }\n\n        if(InsertSemi()) {\n            mOutputFormatHelper.AppendSemiNewLine();\n        }\n\n        // Insert the bindings of a DecompositionDecl if this VarDecl is a DecompositionDecl.\n        if(const auto* decompDecl = dyn_cast_or_null<DecompositionDecl>(stmt)) {\n            StructuredBindingsCodeGenerator codeGenerator{mOutputFormatHelper, GetName(*stmt)};\n\n            codeGenerator.InsertDecompositionBindings(*decompDecl);\n        }\n    }\n\n    if(needsGuard) {\n        mOutputFormatHelper.InsertEndIfTemplateGuard();\n    }\n}\n//-----------------------------------------------------------------------------\n\nbool CodeGenerator::InsertLambdaStaticInvoker(const CXXMethodDecl* cxxMethodDecl)\n{\n    if(not(cxxMethodDecl and cxxMethodDecl->isLambdaStaticInvoker())) {\n        return false;\n    }\n\n    // A special case for a lambda with a static invoker. The standard says, that in such a case invoking the call\n    // operator gives the same result as invoking the function pointer (see [expr.prim.lambda.closure] p9). When it\n    // comes to block local statics having a body for both functions reveals a difference. This special code\n    // generates a forwarding call from the call operator to the static invoker. However, the compiler does better\n    // here. As this way we end up with copies of the parameters which is hard to avoid.\n\n    mOutputFormatHelper.AppendNewLine();\n    mOutputFormatHelper.OpenScope();\n\n    if(not cxxMethodDecl->getReturnType()->isVoidType()) {\n        mOutputFormatHelper.Append(kwReturn, \" \"sv);\n    }\n\n    mOutputFormatHelper.Append(GetName(*cxxMethodDecl->getParent()), \"{}.operator()\"sv);\n\n    if(cxxMethodDecl->isFunctionTemplateSpecialization()) {\n        InsertTemplateArgs(*dyn_cast_or_null<FunctionDecl>(cxxMethodDecl));\n    }\n\n    if(cxxMethodDecl->isTemplated()) {\n        if(cxxMethodDecl->getDescribedTemplate()) {\n            InsertTemplateParameters(*cxxMethodDecl->getDescribedTemplate()->getTemplateParameters(),\n                                     TemplateParamsOnly::Yes);\n        }\n        /*else if(decl.isFunctionTemplateSpecialization()) {\n            InsertTemplateSpecializationHeader();\n        }*/\n    }\n\n    WrapInParens([&] {\n        mOutputFormatHelper.AppendParameterList(cxxMethodDecl->parameters(),\n                                                OutputFormatHelper::NameOnly::Yes,\n                                                OutputFormatHelper::GenMissingParamName::Yes);\n    });\n\n    mOutputFormatHelper.AppendSemiNewLine();\n    mOutputFormatHelper.CloseScope(OutputFormatHelper::NoNewLineBefore::Yes);\n    mOutputFormatHelper.AppendNewLine();\n\n    return true;\n}\n//-----------------------------------------------------------------------------\n\n/// \\brief Inserts the instantiation point of a template.\n//\n// This reveals at which place the template is first used.\nvoid CodeGenerator::InsertInstantiationPoint(const SourceManager&  sm,\n                                             const SourceLocation& instLoc,\n                                             std::string_view      text)\n{\n    const auto  lineNo = sm.getSpellingLineNumber(instLoc);\n    const auto& fileId = sm.getFileID(instLoc);\n    if(const auto file = sm.getFileEntryRefForID(fileId)) {\n        const auto fileWithDirName = file->getName();\n        const auto fileName        = llvm::sys::path::filename(fileWithDirName);\n\n        if(text.empty()) {\n            text = \"First instantiated from: \"sv;\n        }\n\n        mOutputFormatHelper.AppendCommentNewLine(text, fileName, \":\"sv, lineNo);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertTemplateGuardBegin(const FunctionDecl* stmt)\n{\n    if(stmt->isTemplateInstantiation() and stmt->isFunctionTemplateSpecialization()) {\n        InsertInstantiationPoint(GetSM(*stmt), stmt->getPointOfInstantiation());\n        mOutputFormatHelper.InsertIfDefTemplateGuard();\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertTemplateGuardEnd(const FunctionDecl* stmt)\n{\n    if(stmt->isTemplateInstantiation() and stmt->isFunctionTemplateSpecialization()) {\n        mOutputFormatHelper.InsertEndIfTemplateGuard();\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CoroutineBodyStmt* stmt)\n{\n    InsertArg(stmt->getBody());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const DependentCoawaitExpr* stmt)\n{\n    mOutputFormatHelper.Append(kwCoAwaitSpace);\n\n    InsertArg(stmt->getOperand());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CoroutineSuspendExpr* stmt)\n{\n    //\tco_await or co_yield\n    if(isa<CoyieldExpr>(stmt)) {\n        mOutputFormatHelper.Append(kwCoYieldSpace);\n    } else {\n        mOutputFormatHelper.Append(kwCoAwaitSpace);\n    }\n\n    // peal of __promise.yield_value\n    if(const auto* matTemp = dyn_cast_or_null<MaterializeTemporaryExpr>(stmt->getCommonExpr())) {\n        const auto* temporary = matTemp->getSubExpr();\n\n        if(const auto* memExpr = dyn_cast_or_null<CXXMemberCallExpr>(temporary)) {\n            ForEachArg(memExpr->arguments(), [&](const auto& arg) { InsertArg(arg); });\n\n            // Seems to be the path for a co_await expr\n        } else {\n            InsertArg(temporary);\n        }\n    } else if(const auto* unaryexpr = dyn_cast_or_null<UnaryOperator>(stmt->getOperand())) {\n        if(const auto* callExpr = dyn_cast_or_null<CallExpr>(unaryexpr->getSubExpr())) {\n            InsertArg(callExpr->getArg(0));\n        }\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CoreturnStmt* stmt)\n{\n    mOutputFormatHelper.Append(kwCoReturnSpace);\n    InsertArg(stmt->getOperand());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertMethodBody(const FunctionDecl* stmt, const size_t posBeforeFunc)\n{\n    auto IsPrimaryTemplate = [&] {\n        // For now, don't transform the primary template of a coroutine\n        if(const auto* cxxMethod = dyn_cast_or_null<CXXMethodDecl>(stmt)) {\n            if(const auto* tmpl = cxxMethod->getParent()->getDescribedClassTemplate();\n               tmpl and not isa<ClassTemplateSpecializationDecl>(cxxMethod->getParent())) {\n                return true;\n            }\n        }\n\n        return (FunctionDecl::TK_FunctionTemplate == stmt->getTemplatedKind()) or\n               (ProcessingPrimaryTemplate::Yes == mProcessingPrimaryTemplate);\n    };\n\n    if(stmt->doesThisDeclarationHaveABody()) {\n        mOutputFormatHelper.AppendNewLine();\n\n        // If this function has a CoroutineBodyStmt as direct descend and coroutine transformation is enabled use\n        // the \\c CoroutinesCodeGenerator, otherwise insert the body as usual.\n        if(const auto* corBody = dyn_cast_or_null<CoroutineBodyStmt>(stmt->getBody());\n           (nullptr != corBody) and not IsPrimaryTemplate() and GetInsightsOptions().ShowCoroutineTransformation) {\n\n            CoroutinesCodeGenerator codeGenerator{mOutputFormatHelper, posBeforeFunc};\n            codeGenerator.InsertCoroutine(*stmt, corBody);\n        } else {\n            const auto exSpec = stmt->getExceptionSpecType();\n            const bool showNoexcept =\n                GetInsightsOptions().UseShowNoexcept and is{exSpec}.any_of(EST_BasicNoexcept, EST_NoexceptTrue);\n\n            // handle C++ [basic.start.main] §5: main can have no return statement\n            if(stmt->hasImplicitReturnZero()) {\n                mRequiresImplicitReturnZero = ranges::none_of(dyn_cast<CompoundStmt>(stmt->getBody())->body(),\n                                                              [](const Stmt* e) { return isa<ReturnStmt>(e); });\n            }\n\n            const auto* body = stmt->getBody();\n\n            if(showNoexcept) {\n                EnableGlobalInsert(GlobalInserts::HeaderException);\n\n                body = mkCompoundStmt(Try(body, Catch(Call(\"std::terminate\"sv, {}))));\n            }\n\n            if(GetInsightsOptions().ShowLifetime) {\n                for(const auto* param : stmt->parameters()) {\n                    auto       paramType = param->getType();\n                    const bool isPassByValue{not paramType->isPointerType() and not paramType->isReferenceType()};\n                    if(const auto* rd = paramType->getAsRecordDecl(); rd and isPassByValue) {\n                        mLifeTimeTracker.Add(param);\n                    }\n                }\n            }\n\n            InsertArg(body);\n        }\n\n        mOutputFormatHelper.AppendNewLine();\n    } else {\n        mOutputFormatHelper.AppendSemiNewLine();\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const FunctionDecl* stmt)\n{\n    {\n        LAMBDA_SCOPE_HELPER(Decltype);  // Needed for P0315Checker\n\n        // Special handling for C++20's P0315 (lambda in unevaluated context). See p0315_2Test.cpp\n        // We have to look for the lambda expression in the decltype.\n        P0315Visitor dt{*this};\n        dt.TraverseType(stmt->getReturnType());\n\n        // The arguments can contain a lambda as well\n        for(const auto& param : stmt->parameters()) {\n            P0315Visitor dt{*this};\n            dt.TraverseType(param->getType());\n        }\n    }\n\n    if(const auto* deductionGuide = dyn_cast_or_null<CXXDeductionGuideDecl>(stmt)) {\n        InsertArg(deductionGuide);\n    } else if(const auto* ctor = dyn_cast_or_null<CXXConstructorDecl>(stmt)) {\n        InsertArg(ctor);\n    } else {\n        // skip a case at least in lambdas with a templated conversion operator which is not used and has auto\n        // return type. This is hard to build with using.\n        RETURN_IF(isa<CXXConversionDecl>(stmt) and not stmt->hasBody());\n\n        const auto posBeforeFunc = mOutputFormatHelper.CurrentPos();\n\n        InsertTemplateGuardBegin(stmt);\n        InsertFunctionNameWithReturnType(*stmt);\n\n        if(not InsertLambdaStaticInvoker(dyn_cast_or_null<CXXMethodDecl>(stmt))) {\n            InsertMethodBody(stmt, posBeforeFunc);\n        }\n\n        InsertTemplateGuardEnd(stmt);\n    }\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string GetTypeConstraintAsString(const TypeConstraint* typeConstraint)\n{\n    if(typeConstraint) {\n        StringStream sstream{};\n        sstream.Print(*typeConstraint);\n\n        return sstream.str();\n    }\n\n    return {};\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string_view Ellipsis(bool b)\n{\n    return ValueOrDefault(b, kwElipsis);\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string_view EllipsisSpace(bool b)\n{\n    return ValueOrDefault(b, kwElipsisSpace);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertTemplateParameters(const TemplateParameterList& list,\n                                             const TemplateParamsOnly     templateParamsOnly)\n{\n    const bool full{TemplateParamsOnly::No == templateParamsOnly};\n\n    if(full) {\n        mOutputFormatHelper.Append(kwTemplate);\n    }\n\n    mOutputFormatHelper.Append(\"<\"sv);\n\n    for(OnceFalse needsComma{}; const auto* param : list) {\n        mOutputFormatHelper.AppendComma(needsComma);\n\n        const auto& typeName = GetName(*param);\n\n        if(const auto* tt = dyn_cast_or_null<TemplateTypeParmDecl>(param)) {\n            if(full) {\n                if(tt->wasDeclaredWithTypename()) {\n                    mOutputFormatHelper.Append(kwTypeNameSpace);\n                } else if(not tt->hasTypeConstraint()) {\n                    mOutputFormatHelper.Append(kwClassSpace);\n                }\n\n                mOutputFormatHelper.Append(EllipsisSpace(tt->isParameterPack()));\n            }\n\n            if(0 == typeName.size() or tt->isImplicit() /* fixes class container:auto*/) {\n                AppendTemplateTypeParamName(mOutputFormatHelper, tt, not full);\n\n            } else {\n                if(auto typeConstraint = GetTypeConstraintAsString(tt->getTypeConstraint());\n                   not typeConstraint.empty()) {\n                    mOutputFormatHelper.Append(std::move(typeConstraint), \" \"sv);\n                }\n\n                mOutputFormatHelper.Append(typeName);\n            }\n\n            mOutputFormatHelper.Append(EllipsisSpace(not full and tt->isParameterPack()));\n\n            if(tt->hasDefaultArgument() and not tt->defaultArgumentWasInherited()) {\n                const auto& defaultArg = tt->getDefaultArgument();\n\n                if(const auto decltypeType = dyn_cast_or_null<DecltypeType>(defaultArg\n                                                                                .\n#if IS_CLANG_NEWER_THAN(18)\n                                                                            getArgument()\n                                                                                .getAsType()\n#else\n                                                                            getTypePtrOrNull()\n#endif\n                                                                                )) {\n                    mOutputFormatHelper.Append(hlpAssing);\n\n                    InsertArg(decltypeType->getUnderlyingExpr());\n\n                } else {\n                    mOutputFormatHelper.Append(hlpAssing);\n                    InsertTemplateArg(defaultArg\n#if IS_CLANG_NEWER_THAN(18)\n                                          .getArgument()\n#endif\n                    );\n                }\n            }\n\n        } else if(const auto* nonTmplParam = dyn_cast_or_null<NonTypeTemplateParmDecl>(param)) {\n            if(full) {\n                if(const auto nttpType = nonTmplParam->getType();\n                   nttpType->isFunctionPointerType() or nttpType->isMemberFunctionPointerType()) {\n                    mOutputFormatHelper.Append(GetTypeNameAsParameter(nttpType, typeName));\n\n                } else {\n                    mOutputFormatHelper.Append(\n                        GetName(nttpType), \" \"sv, Ellipsis(nonTmplParam->isParameterPack()), typeName);\n                }\n\n                if(nonTmplParam->hasDefaultArgument()) {\n                    mOutputFormatHelper.Append(hlpAssing);\n#if IS_CLANG_NEWER_THAN(18)\n                    InsertTemplateArg(nonTmplParam->getDefaultArgument().getArgument());\n#else\n                    InsertArg(nonTmplParam->getDefaultArgument());\n#endif\n                }\n            } else {\n                mOutputFormatHelper.Append(typeName, EllipsisSpace(nonTmplParam->isParameterPack()));\n            }\n        } else if(const auto* tmplTmplParam = dyn_cast_or_null<TemplateTemplateParmDecl>(param)) {\n            auto pack{ValueOr(tmplTmplParam->isParameterPack(), kwElipsisSpace, \" \"sv)};\n\n            mOutputFormatHelper.Append(kwTemplateSpace, \"<typename> typename\"sv, pack, typeName);\n\n            if(tmplTmplParam->hasDefaultArgument()) {\n                mOutputFormatHelper.Append(hlpAssing);\n                InsertTemplateArg(tmplTmplParam->getDefaultArgument().getArgument());\n            }\n        }\n    }\n\n    mOutputFormatHelper.Append(\">\"sv);\n\n    if(full) {\n        mOutputFormatHelper.AppendNewLine();\n        InsertConceptConstraint(list);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ClassTemplateDecl* stmt)\n{\n    {\n        LAMBDA_SCOPE_HELPER(Decltype);  // Needed for P0315Checker\n        mLambdaStack.back().setInsertName(true);\n\n        InsertTemplateParameters(*stmt->getTemplateParameters());\n    }\n\n    InsertArg(stmt->getTemplatedDecl());\n\n    SmallVector<const ClassTemplateSpecializationDecl*, 10> specializations{};\n\n    // XXX C++23: replace with filter and ranges::to<>\n    for(const auto* spec : stmt->specializations()) {\n        // Explicit specializations and instantiations will appear later in the AST as dedicated node. Don't\n        // generate code for them now, otherwise they are there twice.\n        if(TSK_ImplicitInstantiation == spec->getSpecializationKind()) {\n            specializations.push_back(spec);\n        }\n    }\n\n    // Sort specializations by POI to make dependent specializations work.\n    ranges::sort(specializations,\n                 [](const ClassTemplateSpecializationDecl* a, const ClassTemplateSpecializationDecl* b) {\n                     return a->getPointOfInstantiation() < b->getPointOfInstantiation();\n                 });\n\n    for(const auto* spec : specializations) {\n        InsertArg(spec);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ParenListExpr* stmt)\n{\n    for(OnceFalse needsComma{}; const auto& expr : stmt->children()) {\n        mOutputFormatHelper.AppendComma(needsComma);\n\n        InsertArg(expr);\n    }\n}\n//-----------------------------------------------------------------------------\n\n/// Fill the values of a constant array.\n///\n/// This is either called by \\c InitListExpr (which may contain an offset, as the user already provided certain\n/// values) or by \\c GetValueOfValueInit.\nstd::string\nCodeGenerator::FillConstantArray(const ConstantArrayType* ct, const std::string& value, const uint64_t startAt)\n{\n    OutputFormatHelper ret{};\n\n    if(ct) {\n        const auto size{std::clamp(GetSize(ct), uint64_t{0}, MAX_FILL_VALUES_FOR_ARRAYS)};\n\n        OnceFalse needsComma{uint64_t{0} != startAt};\n        for_each(startAt, size, [&](auto) {\n            ret.AppendComma(needsComma);\n            ret.Append(value);\n        });\n    }\n\n    return ret.GetString();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const InitListExpr* stmt)\n{\n    // At least in case of a requires-clause containing T{} we don't want to get T{{}}.\n    RETURN_IF((NoEmptyInitList::Yes == mNoEmptyInitList) and (0 == stmt->getNumInits()));\n\n    WrapInCurliesIfNeeded(not GetInsightsOptions().UseShow2C or\n                              (GetInsightsOptions().UseShow2C and\n                               ((stmt->getNumInits() > 1) or stmt->getArrayFiller() or\n                                ((0 < stmt->getNumInits()) and isa<ImplicitValueInitExpr>(stmt->getInit(0))))),\n                          [&]() {\n                              mOutputFormatHelper.IncreaseIndent();\n\n                              ForEachArg(stmt->inits(), [&](const auto& init) { InsertArg(init); });\n\n                              if((0 == stmt->getNumInits()) and GetInsightsOptions().UseShow2C) {\n                                  if(stmt->getType().getCanonicalType()->isScalarType()) {\n                                      mOutputFormatHelper.Append(GetValueOfValueInit(stmt->getType()));\n                                      return;\n                                  } else {\n                                      // for a non scalar type that shoud become a memset?\n                                      // A a{}; -> A a; memset(&a, 0, sizef(a));\n                                      // mOutputFormatHelper.Append(\"memset(\"sv);\n                                  }\n                              }\n\n                              // If we have a filler, fill the rest of the array with the filler expr.\n                              if(const auto* filler = stmt->getArrayFiller()) {\n                                  OutputFormatHelper   ofm{};\n                                  CodeGeneratorVariant codeGenerator{ofm};\n                                  codeGenerator->InsertArg(filler);\n\n                                  const auto ret = FillConstantArray(\n                                      dyn_cast_or_null<ConstantArrayType>(stmt->getType().getTypePtrOrNull()),\n                                      ofm.GetString(),\n                                      stmt->getNumInits());\n\n                                  mOutputFormatHelper.Append(ret);\n                              }\n                          });\n\n    mOutputFormatHelper.DecreaseIndent();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXDefaultInitExpr* stmt)\n{\n    const auto* subExpr = stmt->getExpr();\n\n    InsertCurlysIfRequired(subExpr);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXDeleteExpr* stmt)\n{\n    mOutputFormatHelper.Append(kwDelete);\n\n    if(stmt->isArrayForm()) {\n        mOutputFormatHelper.Append(\"[]\"sv);\n    }\n\n    mOutputFormatHelper.Append(' ');\n\n    InsertArg(stmt->getArgument());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertConstructorExpr(const auto* stmt)\n{\n    {\n        CONDITIONAL_LAMBDA_SCOPE_HELPER(Decltype, not isa<DecltypeType>(stmt->getType()))\n\n        P0315Visitor dt{*this};\n        dt.TraverseType(stmt->getType());\n\n        if(not mLambdaStack.empty()) {\n            for(const auto& e : mLambdaStack) {\n                RETURN_IF((LambdaCallerType::MemberCallExpr == e.callerType()) and isa<DecltypeType>(stmt->getType()));\n            }\n        }\n    }\n\n    mOutputFormatHelper.Append(GetName(stmt->getType(), Unqualified::Yes));\n\n    const BraceKind braceKind = ValueOr(stmt->isListInitialization(), BraceKind::Curlys, BraceKind::Parens);\n\n    WrapInParensOrCurlys(braceKind, [&]() {\n        if(const auto& arguments = stmt->arguments(); not arguments.empty()) {\n            ForEachArg(stmt->arguments(), [&](const auto& arg) { InsertArg(arg); });\n        }\n    });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXConstructExpr* stmt)\n{\n    InsertConstructorExpr(stmt);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXUnresolvedConstructExpr* stmt)\n{\n    BackupAndRestore _{mNoEmptyInitList, NoEmptyInitList::Yes};\n\n    InsertConstructorExpr(stmt);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const UnresolvedMemberExpr* stmt)\n{\n    // InsertArg(stmt->getBase());\n    // const std::string op{};  // stmt->isArrow() ? \"->\" : \".\"};\n\n    // mOutputFormatHelper.Append(op, stmt->getMemberNameInfo().getAsString());\n    mOutputFormatHelper.Append(stmt->getMemberNameInfo().getAsString());\n\n    if(stmt->getNumTemplateArgs()) {\n        InsertTemplateArgs(*stmt);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const PackExpansionExpr* stmt)\n{\n    InsertArg(stmt->getPattern());\n    mOutputFormatHelper.Append(kwElipsisSpace);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXFoldExpr* stmt)\n{\n    auto operatorStr = BinaryOperator::getOpcodeStr(stmt->getOperator());\n\n    WrapInParens([&] {\n        // We have a binary NNN fold. If init is nullptr, then it is a unary NNN fold.\n        const auto* init = stmt->getInit();\n\n        if(stmt->isLeftFold()) {\n            if(init) {\n                InsertArg(init);\n                mOutputFormatHelper.Append(\" \"sv, operatorStr, \" \"sv);\n            }\n\n            mOutputFormatHelper.Append(kwElipsisSpace, operatorStr, \" \"sv);\n        }\n\n        InsertArg(stmt->getPattern());\n\n        if(stmt->isRightFold()) {\n            mOutputFormatHelper.Append(\" \"sv, operatorStr, \" \"sv, kwElipsis);\n\n            if(init) {\n                mOutputFormatHelper.Append(\" \"sv, operatorStr, \" \"sv);\n                InsertArg(init);\n            }\n        }\n    });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXInheritedCtorInitExpr* stmt)\n{\n    const auto& constructorDecl = *stmt->getConstructor();\n\n    mOutputFormatHelper.Append(GetName(GetDesugarType(stmt->getType()), Unqualified::Yes));\n    WrapInParens([&]() {\n        mOutputFormatHelper.AppendParameterList(constructorDecl.parameters(),\n                                                OutputFormatHelper::NameOnly::Yes,\n                                                OutputFormatHelper::GenMissingParamName::Yes);\n    });\n}\n//-----------------------------------------------------------------------------\n\nbool CodeGenerator::InsideDecltype() const\n{\n    return (not mLambdaStack.empty()) and (LambdaCallerType::Decltype == mLambdaStack.back().callerType());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXMemberCallExpr* stmt)\n{\n    CONDITIONAL_LAMBDA_SCOPE_HELPER(MemberCallExpr, not InsideDecltype())\n\n    InsertArg(stmt->getCallee());\n\n    WrapInParens([&]() { ForEachArg(stmt->arguments(), [&](const auto& arg) { InsertArg(arg); }); });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ParenExpr* stmt)\n{\n    WrapInParens([&]() { InsertArg(stmt->getSubExpr()); });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXParenListInitExpr* stmt)\n{\n    WrapInParens([&]() { ForEachArg(stmt->getInitExprs(), [&](const auto& init) { InsertArg(init); }); });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const UnaryOperator* stmt)\n{\n    StringRef  opCodeName = UnaryOperator::getOpcodeStr(stmt->getOpcode());\n    const bool insertBefore{not stmt->isPostfix()};\n\n    if(insertBefore) {\n        mOutputFormatHelper.Append(opCodeName);\n    }\n\n    InsertArg(stmt->getSubExpr());\n\n    if(not insertBefore) {\n        mOutputFormatHelper.Append(opCodeName);\n    }\n}\n//-------------\t----------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const StringLiteral* stmt)\n{\n    StringStream stream{};\n    stream.Print(*stmt);\n\n    mOutputFormatHelper.Append(stream.str());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ArrayInitIndexExpr* stmt)\n{\n    Error(stmt, \"ArrayInitIndexExpr should not be reached in CodeGenerator\");\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ArraySubscriptExpr* stmt)\n{\n    if((not GetInsightsOptions().UseAltArraySubscriptionSyntax) or stmt->getLHS()->isLValue()) {\n        InsertArg(stmt->getLHS());\n\n        mOutputFormatHelper.Append('[');\n        InsertArg(stmt->getRHS());\n        mOutputFormatHelper.Append(']');\n    } else {\n\n        mOutputFormatHelper.Append(\"(*(\"sv);\n        InsertArg(stmt->getLHS());\n        mOutputFormatHelper.Append(\" + \"sv);\n\n        InsertArg(stmt->getRHS());\n        mOutputFormatHelper.Append(\"))\"sv);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ArrayInitLoopExpr* stmt)\n{\n    WrapInCurlys([&]() {\n        const uint64_t size = stmt->getArraySize().getZExtValue();\n\n        ForEachArg(NumberIterator(size), [&](const auto& i) {\n            ArrayInitCodeGenerator codeGenerator{mOutputFormatHelper, i};\n            codeGenerator.InsertArg(stmt->getSubExpr());\n        });\n    });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const OpaqueValueExpr* stmt)\n{\n    InsertArg(stmt->getSourceExpr());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CallExpr* stmt)\n{\n    const bool insideDecltype{InsideDecltype()};\n\n    CONDITIONAL_LAMBDA_SCOPE_HELPER(CallExpr, not insideDecltype)\n    if(insideDecltype) {\n        mLambdaStack.back().setInsertName(true);\n    }\n\n    UpdateCurrentPos(mCurrentCallExprPos);\n\n    InsertArg(stmt->getCallee());\n\n    if(const auto* declRefExpr = dyn_cast_or_null<DeclRefExpr>(stmt->getCallee()->IgnoreImpCasts())) {\n        if(const auto* fd = dyn_cast_or_null<FunctionDecl>(declRefExpr->getDecl())) {\n            if((not declRefExpr->getNumTemplateArgs() and GetInsightsOptions().ShowAllCallExprTemplateParameters) or\n               isa<UserDefinedLiteral>(stmt)) {\n                InsertTemplateArgs(*fd);\n            }\n        }\n    }\n\n    WrapInParens([&]() {\n        auto*    funcDecl = dyn_cast_or_null<FunctionDecl>(stmt->getCalleeDecl());\n        unsigned parmIdx{};\n\n        ForEachArg(stmt->arguments(), [&](const auto* arg) {\n            ++parmIdx;\n\n            if(const auto* tmpExpr = dyn_cast_or_null<CXXBindTemporaryExpr>(arg)) {\n                if(const auto* tmp = dyn_cast_or_null<CXXTemporaryObjectExpr>(tmpExpr->getSubExpr())) {\n                    if(GetInsightsOptions().UseShow2C) {\n                        // De-reference the argument since we can only pass temporary objects to functions, not\n                        // pointers\n                        arg = Dref(arg);\n\n                    } else if(GetInsightsOptions().ShowLifetime) {\n                        mOutputFormatHelper.Append(GetName(*tmp));\n                        return;  // from lambda, which is like a continue\n                    }\n                }\n            }\n\n            if(GetInsightsOptions().UseShow2C and funcDecl and (funcDecl->getNumParams() >= parmIdx) and\n               IsReferenceType(funcDecl->getParamDecl(parmIdx - 1))) {\n                if(auto* unop = dyn_cast_or_null<UnaryOperator>(arg); not unop or (unop->getOpcode() != UO_AddrOf)) {\n                    arg = Ref(arg);\n                }\n            }\n\n            InsertArg(arg);\n        });\n    });\n\n    if(insideDecltype) {\n        mLambdaStack.back().setInsertName(false);\n    }\n\n    mCurrentCallExprPos.reset();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXNamedCastExpr* stmt)\n{\n    const QualType castDestType = stmt->getTypeAsWritten();\n    const Expr*    subExpr      = stmt->getSubExpr();\n\n    FormatCast(stmt->getCastName(), castDestType, subExpr, stmt->getCastKind());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ImplicitCastExpr* stmt)\n{\n    const Expr* subExpr  = stmt->getSubExpr();\n    const auto  castKind = stmt->getCastKind();\n    const bool  hideImplicitCasts{not GetInsightsOptions().ShowAllImplicitCasts};\n\n    auto isMatchingCast = [](const CastKind kind, const bool hideImplicitCasts, const bool showXValueCasts) {\n        switch(kind) {\n            case CastKind::CK_Dependent: [[fallthrough]];\n            case CastKind::CK_IntegralCast: [[fallthrough]];\n            case CastKind::CK_IntegralToBoolean: [[fallthrough]];\n            case CastKind::CK_IntegralToPointer: [[fallthrough]];\n            case CastKind::CK_PointerToIntegral: [[fallthrough]];\n            case CastKind::CK_BitCast: [[fallthrough]];\n            case CastKind::CK_UncheckedDerivedToBase: [[fallthrough]];\n            case CastKind::CK_ToUnion:\n                [[fallthrough]];\n                //            case CastKind::CK_UserDefinedConversion: [[fallthrough]];\n            case CastKind::CK_AtomicToNonAtomic: [[fallthrough]];\n            case CastKind::CK_DerivedToBase: [[fallthrough]];\n            case CastKind::CK_FloatingCast: [[fallthrough]];\n            case CastKind::CK_IntegralToFloating: [[fallthrough]];\n            case CastKind::CK_FloatingToIntegral: [[fallthrough]];\n            case CastKind::CK_NonAtomicToAtomic: return true;\n            default:\n                // Special case for structured bindings\n                if((showXValueCasts or not hideImplicitCasts) and (CastKind::CK_NoOp == kind)) {\n                    return true;\n                }\n\n                // Show this casts only if ShowAllImplicitCasts is turned on.\n                if(not hideImplicitCasts) {\n                    switch(kind) {\n                        case CastKind::CK_NullToPointer: [[fallthrough]];\n                        case CastKind::CK_NullToMemberPointer: [[fallthrough]];\n                        /* these are implicit conversions. We get them right, but they may end up in a compiler\n                         * internal type, which leads to compiler errors */\n                        case CastKind::CK_NoOp: [[fallthrough]];\n                        case CastKind::CK_ArrayToPointerDecay: return true;\n                        default: break;\n                    }\n                }\n\n                return false;\n        }\n    };\n\n    if(not isMatchingCast(castKind, hideImplicitCasts, stmt->isXValue() or ShowXValueCasts())) {\n        if(GetInsightsOptions().UseShow2C and (castKind == CastKind::CK_LValueToRValue) and\n           IsReferenceType(dyn_cast_or_null<DeclRefExpr>(subExpr))) {\n            mOutputFormatHelper.Append(\"*\"sv);\n        }\n\n        InsertArg(subExpr);\n\n    } else if(isa<IntegerLiteral>(subExpr) and hideImplicitCasts) {\n        InsertArg(stmt->IgnoreCasts());\n\n        // If this is part of an explicit cast, for example a CStyleCast or static_cast, ignore it, because it\n        // belongs to the cast written by the user.\n    } else if(stmt->isPartOfExplicitCast()) {\n        InsertArg(stmt->IgnoreCasts());\n\n    } else {\n        auto           castName{GetCastName(castKind)};\n        const QualType castDestType{[&] {\n            const auto type{stmt->getType()};\n\n            // In at least the case a structured bindings the compiler adds xvalue casts but the && is missing to\n            // make it valid C++.\n            if(VK_XValue == stmt->getValueKind()) {\n                return GetGlobalAST().getRValueReferenceType(type.getCanonicalType());\n            } else if(type->isDependentType()) {  // In case of a dependent type the canonical type doesn't know the\n                                                  // parameters name.\n                return type;\n            }\n\n            return type.getCanonicalType();\n        }()};\n\n        FormatCast(castName, castDestType, subExpr, castKind);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const DeclRefExpr* stmt)\n{\n    if(const auto* vd = dyn_cast_or_null<VarDecl>(stmt->getDecl());\n       GetInsightsOptions().UseShow2C and IsReferenceType(vd)) {\n        const auto* init = vd->getInit();\n\n        if(const auto* dref = dyn_cast_or_null<DeclRefExpr>(init)) {\n            mOutputFormatHelper.Append(GetName(*dref));\n            return;\n\n        } else if(const auto* inList = dyn_cast_or_null<InitListExpr>(init)) {\n            mOutputFormatHelper.Append(GetName(*dyn_cast_or_null<DeclRefExpr>(inList->getInit(0))));\n            return;\n        }\n    }\n\n    if(const auto* ctx = stmt->getDecl()->getDeclContext(); not ctx->isFunctionOrMethod() and\n                                                            not isa<NonTypeTemplateParmDecl>(stmt->getDecl()) and\n                                                            not GetInsightsOptions().UseShow2C) {\n        if(const auto* qualifier = stmt->getQualifier();\n           qualifier and (qualifier->getKind() == NestedNameSpecifier::SpecifierKind::Global)) {\n            // According to\n            // https://clang.llvm.org/doxygen/classclang_1_1NestedNameSpecifier.html#ac707a113605ed4283684b8c05664eb6f\n            // the global specifier is not stored.\n            mOutputFormatHelper.Append(\"::\"sv, GetPlainName(*stmt));\n\n        } else {\n            OutputFormatHelper   ofm{};\n            CodeGeneratorVariant codeGenerator{ofm};\n\n            codeGenerator->ParseDeclContext(ctx);\n\n            mOutputFormatHelper.Append(ScopeHandler::RemoveCurrentScope(ofm.GetString()), GetPlainName(*stmt));\n        }\n\n    } else {\n        mOutputFormatHelper.Append(GetName(*stmt));\n    }\n\n    if(const auto* varTmplSpecDecl = dyn_cast_or_null<VarTemplateSpecializationDecl>(stmt->getDecl())) {\n        InsertTemplateArgs(*varTmplSpecDecl);\n    } else {\n        InsertTemplateArgs(*stmt);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CompoundStmt* stmt)\n{\n    mOutputFormatHelper.OpenScope();\n    mLifeTimeTracker.StartScope(isa_and_nonnull<FunctionDecl>(mLastDecl));\n\n    // prevent nested CompoundStmt's to insert a return on each leave. Only insert it before closing the most outer\n    // one.\n    const bool requiresImplicitReturnZero{std::exchange(mRequiresImplicitReturnZero, false)};\n\n    HandleCompoundStmt(stmt);\n\n    if(requiresImplicitReturnZero) {\n        InsertArg(Return(Int32(0)));\n\n        if(not mSkipSemi) {\n            InsertArg(mkNullStmt());\n        }\n    }\n\n    mSkipSemi = mLifeTimeTracker.EndScope(mOutputFormatHelper, isa_and_nonnull<ReturnStmt>(mLastStmt));\n\n    mOutputFormatHelper.CloseScope(OutputFormatHelper::NoNewLineBefore::Yes);\n}\n//-----------------------------------------------------------------------------\n\ntemplate<typename... Args>\nstatic bool IsStmtRequiringSemi(const Stmt* stmt)\n{\n    return (... and not isa<Args>(stmt));\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::HandleCompoundStmt(const CompoundStmt* stmt)\n{\n    for(const auto* item : stmt->body()) {\n        InsertArg(item);\n\n        // Skip inserting a semicolon, if this is a LambdaExpr and out stack is empty. This addresses a special case\n        // #344.\n        const bool skipSemiForLambda{mLambdaStack.empty() and isa<LambdaExpr>(item)};\n\n        if(IsStmtRequiringSemi<IfStmt,\n                               NullStmt,\n                               ForStmt,\n                               DeclStmt,\n                               WhileStmt,\n                               DoStmt,\n                               CXXForRangeStmt,\n                               SwitchStmt,\n                               CXXTryStmt,\n                               CppInsightsCommentStmt>(item) and\n           InsertSemi() and not skipSemiForLambda and not mSkipSemi) {\n            mOutputFormatHelper.AppendSemiNewLine();\n        }\n\n        mSkipSemi = false;\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertIfOrSwitchInitVariables(same_as_any_of<const IfStmt, const SwitchStmt> auto* stmt)\n{\n    if(const auto* conditionVar = stmt->getConditionVariable()) {\n        InsertArg(conditionVar);\n    }\n\n    if(const auto* init = stmt->getInit()) {\n        InsertArg(init);\n\n        if(not isa<DeclStmt>(init)) {\n            mOutputFormatHelper.AppendSemiNewLine();\n        }\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const IfStmt* stmt)\n{\n    const bool hasInit{stmt->getInit() or stmt->getConditionVariable()};\n\n    if(hasInit) {\n        mOutputFormatHelper.OpenScope();\n\n        InsertIfOrSwitchInitVariables(stmt);\n    }\n\n    mOutputFormatHelper.Append(\"if\"sv, ValueOrDefault(stmt->isConstexpr(), kwSpaceConstExpr));\n\n    WrapInParensIfNeeded(\n        not stmt->isConsteval(),\n        [&]() {\n            mShowConstantExprValue = ShowConstantExprValue::Yes;\n\n            InsertArg(stmt->getCond());\n\n            mShowConstantExprValue = ShowConstantExprValue::No;\n        },\n        AddSpaceAtTheEnd::Yes);\n\n    mOutputFormatHelper.Append(ValueOrDefault(stmt->isNegatedConsteval(), \" !\"sv),\n                               ValueOrDefault(stmt->isConsteval(), kwSpaceConstEvalSpace));\n\n    WrapInCompoundIfNeeded(stmt->getThen(), AddNewLineAfter::No);\n\n    // else\n    if(const auto* elsePart = stmt->getElse()) {\n        mOutputFormatHelper.Append(\n            \"else \"sv,\n            ValueOrDefault(stmt->isConstexpr(), StrCat(kwCCommentStartSpace, kwConstExprSpace, kwCCommentEndSpace)));\n\n        WrapInCompoundIfNeeded(elsePart, AddNewLineAfter::No);\n    }\n\n    // Add newline after last closing curly (either from if or else if).\n    mOutputFormatHelper.AppendNewLine();\n\n    if(hasInit) {\n        mOutputFormatHelper.CloseScope();\n        mOutputFormatHelper.AppendNewLine();\n    }\n\n    // one blank line after statement\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nclass ContinueASTTransformer : public StmtVisitor<ContinueASTTransformer>\n{\n    Stmt*            mPrevStmt{};\n    std::string_view mContinueLabel{};\n\npublic:\n    bool found{};\n\n    ContinueASTTransformer(Stmt* stmt, std::string_view continueLabel)\n    : mPrevStmt{stmt}\n    , mContinueLabel{continueLabel}\n    {\n        Visit(stmt);\n    }\n\n    void Visit(Stmt* stmt)\n    {\n        if(stmt) {\n            StmtVisitor<ContinueASTTransformer>::Visit(stmt);\n        }\n    }\n\n    void VisitContinueStmt(ContinueStmt* stmt)\n    {\n        found = true;\n\n        ReplaceNode(mPrevStmt, stmt, Goto(mContinueLabel));\n    }\n\n    void VisitStmt(Stmt* stmt)\n    {\n        auto* tmp = mPrevStmt;\n        mPrevStmt = stmt;\n\n        for(auto* child : stmt->children()) {\n            Visit(child);\n        }\n\n        mPrevStmt = tmp;\n    }\n};\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ForStmt* stmt)\n{\n    // https://github.com/vtjnash/clang-ast-builder/blob/master/AstBuilder.cpp\n    // http://clang-developers.42468.n3.nabble.com/Adding-nodes-to-Clang-s-AST-td4054800.html\n    // https://stackoverflow.com/questions/30451485/how-to-clone-or-create-an-ast-stmt-node-of-clang/38899615\n\n    if(GetInsightsOptions().UseAltForSyntax) {\n        auto*          rwStmt = const_cast<ForStmt*>(stmt);\n        const auto&    ctx    = GetGlobalAST();\n        StmtsContainer bodyStmts{};\n\n        auto       continueLabel = MakeLineColumnName(ctx.getSourceManager(), stmt->getBeginLoc(), \"__continue_\"sv);\n        const bool insertLabel   = ContinueASTTransformer{rwStmt->getBody(), continueLabel}.found;\n\n        bodyStmts.AddBodyStmts(rwStmt->getBody());\n\n        // Build and insert the continue goto label\n        if(insertLabel) {\n            bodyStmts.Add(Label(continueLabel));\n        }\n\n        bodyStmts.Add(rwStmt->getInc());\n\n        auto* condition = [&]() -> Expr* {\n            if(rwStmt->getCond()) {\n                return rwStmt->getCond();\n            }\n\n            return Bool(true);\n        }();\n\n        auto* outerBody = mkCompoundStmt(bodyStmts, stmt->getBeginLoc(), stmt->getEndLoc());\n        auto* whileStmt = WhileStmt::Create(\n            ctx, nullptr, condition, outerBody, stmt->getBeginLoc(), stmt->getLParenLoc(), stmt->getRParenLoc());\n\n        StmtsContainer outerScopeStmts{};\n        outerScopeStmts.Add(rwStmt->getInit());\n        outerScopeStmts.Add(whileStmt);\n\n        auto* outerScopeBody = mkCompoundStmt(outerScopeStmts, stmt->getBeginLoc(), stmt->getEndLoc());\n\n        InsertArg(outerScopeBody);\n        mOutputFormatHelper.AppendNewLine();\n\n    } else {\n        {\n            // We need to handle the case that a lambda is used in the init-statement of the for-loop.\n            LAMBDA_SCOPE_HELPER(VarDecl);\n\n            mOutputFormatHelper.Append(\"for\"sv);\n\n            WrapInParens(\n                [&]() {\n                    if(const auto* init = stmt->getInit()) {\n                        MultiStmtDeclCodeGenerator codeGenerator{\n                            mOutputFormatHelper, mLambdaStack, InsertVarDecl(nullptr)};\n                        codeGenerator.InsertArg(init);\n\n                    } else {\n                        mOutputFormatHelper.Append(\"; \"sv);\n                    }\n\n                    InsertArg(stmt->getCond());\n                    mOutputFormatHelper.Append(\"; \"sv);\n\n                    InsertArg(stmt->getInc());\n                },\n                AddSpaceAtTheEnd::Yes);\n        }\n\n        WrapInCompoundIfNeeded(stmt->getBody(), AddNewLineAfter::Yes);\n    }\n\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nstatic bool IsConstQualifiedType(QualType type)\n{\n    if(not type.isNull()) {\n        if(auto* typePtr = type.getTypePtrOrNull()) {\n            if(auto pointee = typePtr->getPointeeType(); not pointee.isNull()) {\n                return pointee.isConstQualified();\n            }\n        }\n    }\n\n    return false;\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CStyleCastExpr* stmt)\n{\n    const auto     castKind     = stmt->getCastKind();\n    const QualType castDestType = stmt->getType().getCanonicalType();\n    const auto     castName     = GetCastName(\n        castKind, IsConstQualifiedType(castDestType) != IsConstQualifiedType(stmt->getSubExpr()->getType()));\n\n    FormatCast(castName, castDestType, stmt->getSubExpr(), castKind);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXNewExpr* stmt)\n{\n    const auto  noEmptyInitList = mNoEmptyInitList;\n    FinalAction _{[&] { mNoEmptyInitList = noEmptyInitList; }};\n    mNoEmptyInitList = GetInsightsOptions().UseShow2C ? NoEmptyInitList::Yes : NoEmptyInitList::No;\n\n    mOutputFormatHelper.Append(\"new \"sv);\n\n    if(stmt->getNumPlacementArgs()) {\n        /* we have a placement new */\n\n        WrapInParens([&]() {\n            ForEachArg(stmt->placement_arguments(), [&](const auto& placementArg) { InsertArg(placementArg); });\n        });\n    }\n\n    if(const auto* ctorExpr = stmt->getConstructExpr()) {\n        InsertArg(ctorExpr);\n\n    } else {\n        auto name = GetName(stmt->getAllocatedType());\n\n        // Special handling for arrays. They differ from one to more dimensions.\n        if(stmt->isArray()) {\n            OutputFormatHelper   ofm{};\n            CodeGeneratorVariant codeGenerator{ofm};\n\n            ofm.Append('[');\n            codeGenerator->InsertArg(stmt->getArraySize().value());\n            ofm.Append(']');\n\n            // In case of multi dimension the first dimension is the getArraySize() while the others are part of the\n            // type included in GetName(...).\n            if(Contains(name, \"[\"sv)) {\n                InsertBefore(name, \"[\"sv, ofm.GetString());\n            } else {\n                // here we have the single dimension case, the dimension is not part of GetName, so add it.\n                name.append(ofm);\n            }\n        }\n\n        mOutputFormatHelper.Append(name);\n\n        if(stmt->hasInitializer()) {\n            InsertCurlysIfRequired(stmt->getInitializer());\n        }\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const MaterializeTemporaryExpr* stmt)\n{\n    // At least in case of a ternary operator wrapped inside a MaterializeTemporaryExpr parens are necessary\n    const auto* temporary = stmt->getSubExpr();\n    WrapInParensIfNeeded(isa_and_nonnull<ConditionalOperator>(temporary), [&] { InsertArg(temporary); });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXOperatorCallExpr* stmt)\n{\n    LAMBDA_SCOPE_HELPER(OperatorCallExpr);\n\n    const auto* callee = dyn_cast_or_null<DeclRefExpr>(stmt->getCallee()->IgnoreImpCasts());\n    const bool  isCXXMethod{callee and isa<CXXMethodDecl>(callee->getDecl())};\n\n    if(2 == stmt->getNumArgs()) {\n        auto getArg = [&](unsigned idx) {\n            const auto* arg = stmt->getArg(idx);\n\n            // In show all casts mode don't filter this. It shows how the compiler adds const to arguments, if the\n            // argument is non-const but the parameter demands a const object\n            if(not GetInsightsOptions().ShowAllImplicitCasts) {\n                arg = arg->IgnoreImpCasts();\n            }\n\n            return dyn_cast_or_null<DeclRefExpr>(arg);\n        };\n\n        const auto* param1 = getArg(0);\n        const auto* param2 = getArg(1);\n\n        if(callee and param1 and param2) {\n            const std::string replace = [&]() {\n                // If the argument is a variable template, add the template arguments to the parameter name.\n                auto nameWithTmplArguments = [](const auto param) {\n                    return FormatVarTemplateSpecializationDecl(param->getDecl(), GetName(*param));\n                };\n\n                if(isa<CXXMethodDecl>(callee->getDecl())) {\n                    return StrCat(nameWithTmplArguments(param1),\n                                  \".\"sv,\n                                  GetName(*callee),\n                                  \"(\"sv,\n                                  nameWithTmplArguments(param2),\n                                  \")\"sv);\n                } else {\n                    return StrCat(GetName(*callee),\n                                  \"(\"sv,\n                                  nameWithTmplArguments(param1),\n                                  \", \"sv,\n                                  nameWithTmplArguments(param2),\n                                  \")\"sv);\n                }\n            }();\n\n            mOutputFormatHelper.Append(replace);\n\n            return;\n        }\n    }\n\n    auto        cb           = stmt->child_begin();\n    const auto* fallbackArg0 = stmt->getArg(0);\n\n    // arg0 := operator\n    // skip arg0\n    std::advance(cb, 1);\n\n    const auto* arg1 = *cb;\n\n    std::advance(cb, 1);\n\n    // operators in a namespace but outside a class so operator goes first\n    if(not isCXXMethod) {\n        // happens for UnresolvedLooupExpr\n        if(not callee) {\n            if(const auto* adl = dyn_cast_or_null<UnresolvedLookupExpr>(stmt->getCallee())) {\n                InsertArg(adl);\n            }\n        } else {\n            mOutputFormatHelper.Append(GetName(*callee));\n        }\n\n        mOutputFormatHelper.Append(\"(\"sv);\n    }\n\n    // insert the arguments\n    if(isa<DeclRefExpr>(fallbackArg0)) {\n        InsertArgWithParensIfNeeded(fallbackArg0);\n\n    } else {\n        InsertArgWithParensIfNeeded(arg1);\n    }\n\n    // if it is a class operator the operator follows now\n    if(isCXXMethod) {\n        const OverloadedOperatorKind opKind = stmt->getOperator();\n\n        const std::string_view operatorKw{ValueOr((OO_Coawait == opKind), kwOperatorSpace, kwOperator)};\n\n        mOutputFormatHelper.Append(\".\"sv, operatorKw, getOperatorSpelling(opKind), \"(\"sv);\n    }\n\n    // consume all remaining arguments\n    const auto childRange = llvm::make_range(cb, stmt->child_end());\n\n    // at least the call-operator can have more than 2 parameters\n    ForEachArg(childRange, [&](const auto& child) {\n        if(not isCXXMethod) {\n            // in global operators we need to separate the two parameters by comma\n            mOutputFormatHelper.Append(\", \"sv);\n        }\n\n        InsertArg(child);\n    });\n\n    mOutputFormatHelper.Append(')');\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const LambdaExpr* stmt)\n{\n    if(not mLambdaStack.empty()) {\n        const bool insertName{mLambdaStack.back().insertName()};\n\n        HandleLambdaExpr(stmt, mLambdaStack.back());\n\n        if(insertName) {\n            mOutputFormatHelper.Append(GetLambdaName(*stmt));\n        }\n\n    } else if(LambdaInInitCapture::Yes == mLambdaInitCapture) {\n        LAMBDA_SCOPE_HELPER(InitCapture);\n        HandleLambdaExpr(stmt, mLambdaStack.back());\n    } else {\n        LAMBDA_SCOPE_HELPER(LambdaExpr);\n        HandleLambdaExpr(stmt, mLambdaStack.back());\n    }\n\n    if(not mLambdaStack.empty()) {\n        mLambdaStack.back().insertInits(mOutputFormatHelper);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXThisExpr* stmt)\n{\n    DPrint(\"thisExpr: imlicit=%d %s\\n\", stmt->isImplicit(), GetName(GetDesugarType(stmt->getType())));\n\n    mOutputFormatHelper.Append(kwThis);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXBindTemporaryExpr* stmt)\n{\n    InsertArg(stmt->getSubExpr());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXFunctionalCastExpr* stmt)\n{\n    const bool isConstructor{isa<CXXConstructExpr>(stmt->getSubExpr())};\n    const bool isStdListInit{isa<CXXStdInitializerListExpr>(stmt->getSubExpr())};\n    const bool isListInitialization{stmt->getLParenLoc().isInvalid()};\n    const bool needsParens{not isConstructor and not isListInitialization and not isStdListInit};\n\n    // If a constructor follows we do not need to insert the type name. This would insert it twice.\n    if(not isConstructor and not isStdListInit) {\n        mOutputFormatHelper.Append(GetName(stmt->getTypeAsWritten()));\n    }\n\n    WrapInParensIfNeeded(needsParens, [&] { InsertArg(stmt->getSubExpr()); });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXBoolLiteralExpr* stmt)\n{\n    mOutputFormatHelper.Append(details::ConvertToBoolString(stmt->getValue()));\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const GNUNullExpr* /*stmt*/)\n{\n    mOutputFormatHelper.Append(kwNull);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CharacterLiteral* stmt)\n{\n    StringStream stream{};\n    stream.Print(*stmt);\n\n    auto str = std::move(stream.str());\n\n    if(str == \"'\\\\x00'\"sv) {\n        str = \"'\\\\0'\"sv;\n    } else if(str == \"'\\\\xff'\"sv) {\n        str = \"255\"sv;\n    }\n\n    mOutputFormatHelper.Append(str);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const PredefinedExpr* stmt)\n{\n    // Check if getFunctionName returns a valid StringLiteral. It does return a nullptr, if this PredefinedExpr is\n    // in a UnresolvedLookupExpr. In that case, print the identifier, e.g. __func__.\n    if(const auto* functionName = stmt->getFunctionName()) {\n        InsertArg(functionName);\n    } else {\n        const auto name = PredefinedExpr::getIdentKindName(stmt->getIdentKind());\n\n        mOutputFormatHelper.Append(name);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ExprWithCleanups* stmt)\n{\n    mLifeTimeTracker.StartScope(false);\n    TemporaryDeclFinder temporaryFinder{*this, not mProcessingVarDecl ? stmt->getSubExpr() : nullptr};\n\n    InsertArg(stmt->getSubExpr());\n\n    if(GetInsightsOptions().ShowLifetime and not mProcessingVarDecl) {\n        mOutputFormatHelper.AppendSemiNewLine();\n    }\n\n    mSkipSemi = mLifeTimeTracker.EndScope(mOutputFormatHelper, false);\n}\n//-----------------------------------------------------------------------------\n\nstd::string CodeGenerator::GetValueOfValueInit(const QualType& t)\n{\n    const QualType& type = t.getCanonicalType();\n\n    if(type->isScalarType()) {\n        switch(type->getScalarTypeKind()) {\n            case Type::STK_CPointer:\n            case Type::STK_BlockPointer:\n            case Type::STK_ObjCObjectPointer:\n            case Type::STK_MemberPointer: return std::string{kwNullptr};\n\n            case Type::STK_Bool: return std::string{kwFalse};\n\n            case Type::STK_Integral:\n            case Type::STK_Floating:\n                if(const auto* bt = type->getAs<BuiltinType>()) {\n                    switch(bt->getKind()) {\n                            // Type::STK_Integral\n                        case BuiltinType::Char_U:\n                        case BuiltinType::UChar:\n                        case BuiltinType::Char_S:\n                        case BuiltinType::SChar: return \"'\\\\0'\";\n                        case BuiltinType::WChar_U:\n                        case BuiltinType::WChar_S: return \"L'\\\\0'\";\n                        case BuiltinType::Char16: return \"u'\\\\0'\";\n                        case BuiltinType::Char32: return \"U'\\\\0'\";\n                        // Type::STK_Floating\n                        case BuiltinType::Half:\n                        case BuiltinType::Float: return \"0.0f\";\n                        case BuiltinType::Double: return \"0.0\";\n                        default: break;\n                    }\n                }\n\n                break;\n\n            case Type::STK_FloatingComplex:\n            case Type::STK_IntegralComplex:\n                if(const auto* complexType = type->getAs<ComplexType>()) {\n                    return GetValueOfValueInit(complexType->getElementType());\n                }\n\n                break;\n\n            case Type::STK_FixedPoint: Error(\"STK_FixedPoint is not implemented\"); break;\n        }\n\n    } else if(const auto* tt = dyn_cast_or_null<ConstantArrayType>(t.getTypePtrOrNull())) {\n        const auto&       elementType{tt->getElementType()};\n        const std::string elementTypeInitValue{GetValueOfValueInit(elementType)};\n\n        return FillConstantArray(tt, elementTypeInitValue, uint64_t{0});\n    }\n\n    return std::string{\"0\"sv};\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ImplicitValueInitExpr* stmt)\n{\n    mOutputFormatHelper.Append(GetValueOfValueInit(stmt->getType()));\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXScalarValueInitExpr* stmt)\n{\n    mOutputFormatHelper.Append(GetName(stmt->getType()), \"()\"sv);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXTryStmt* stmt)\n{\n    mOutputFormatHelper.AppendNewLine(kwTrySpace);\n\n    InsertArg(stmt->getTryBlock());\n\n    for(const auto& i : NumberIterator{stmt->getNumHandlers()}) {\n        InsertArg(stmt->getHandler(i));\n    }\n\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXCatchStmt* stmt)\n{\n    mOutputFormatHelper.Append(\" catch\"sv);\n\n    WrapInParens(\n        [&]() {\n            if(not stmt->getCaughtType().isNull()) {\n                mOutputFormatHelper.Append(\n                    GetTypeNameAsParameter(stmt->getCaughtType(), stmt->getExceptionDecl()->getName()));\n            } else {\n                mOutputFormatHelper.Append(kwElipsis);\n            }\n        },\n        AddSpaceAtTheEnd::Yes);\n\n    InsertArg(stmt->getHandlerBlock());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXThrowExpr* stmt)\n{\n    mOutputFormatHelper.Append(\"throw \"sv);\n\n    InsertArg(stmt->getSubExpr());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ConstantExpr* stmt)\n{\n    if((ShowConstantExprValue::Yes == mShowConstantExprValue) and stmt->hasAPValueResult()) {\n        if(const auto value = stmt->getAPValueResult(); value.isInt()) {\n            mOutputFormatHelper.Append(value.getInt());\n            return;\n        }\n    }\n\n    InsertArg(stmt->getSubExpr());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const TypeAliasDecl* stmt)\n{\n    const auto& underlyingType = stmt->getUnderlyingType();\n\n    LAMBDA_SCOPE_HELPER(Decltype);\n    P0315Visitor dt{*this};\n    dt.TraverseType(underlyingType);\n\n    mOutputFormatHelper.Append(kwUsingSpace, GetName(*stmt), hlpAssing);\n\n    if(auto* templateSpecializationType = underlyingType->getAs<TemplateSpecializationType>()) {\n#if IS_CLANG_NEWER_THAN(18)\n        const bool carriesNamespace{[&] {\n            if(const auto tn = templateSpecializationType->getTemplateName();\n               (TemplateName::QualifiedTemplate == tn.getKind()) or (TemplateName::DependentTemplate == tn.getKind())) {\n                const auto* qtn = tn.getAsQualifiedTemplateName();\n\n                return qtn->getQualifier() != nullptr;\n            }\n\n            return false;\n        }()};\n\n        if(const auto* elaboratedType = underlyingType->getAs<ElaboratedType>()) {\n            if(templateSpecializationType->isSugared() and not carriesNamespace) {\n                // do this only if the templateSpecializationType does not carry a nestedns\n                InsertNamespace(elaboratedType->getQualifier());\n            }\n        }\n#else\n        if(const auto* elaboratedType = underlyingType->getAs<ElaboratedType>()) {\n            InsertNamespace(elaboratedType->getQualifier());\n        }\n#endif\n\n        StringStream stream{};\n        stream.Print(*templateSpecializationType);\n\n        mOutputFormatHelper.Append(stream.str());\n\n        InsertTemplateArgs(*templateSpecializationType);\n    } else if(auto* dependentTemplateSpecializationType =\n                  underlyingType->getAs<DependentTemplateSpecializationType>()) {\n\n        mOutputFormatHelper.Append(GetElaboratedTypeKeyword(dependentTemplateSpecializationType->getKeyword()));\n\n        InsertNamespace(dependentTemplateSpecializationType->getQualifier());\n\n        mOutputFormatHelper.Append(kwTemplateSpace, dependentTemplateSpecializationType->getIdentifier()->getName());\n\n        InsertTemplateArgs(*dependentTemplateSpecializationType);\n\n    } else {\n        mOutputFormatHelper.Append(GetName(underlyingType));\n    }\n\n    mOutputFormatHelper.AppendSemiNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const TypedefDecl* stmt)\n{\n    /* function pointer typedefs are special. Ease up things using \"using\" */\n    //    outputFormatHelper.AppendNewLine(\"typedef \", GetName(stmt->getUnderlyingType()), \" \", GetName(*stmt),\n    //    \";\");\n    mOutputFormatHelper.AppendSemiNewLine(kwUsingSpace, GetName(*stmt), hlpAssing, GetName(stmt->getUnderlyingType()));\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertCXXMethodHeader(const CXXMethodDecl* stmt, OutputFormatHelper& initOutputFormatHelper)\n{\n    LAMBDA_SCOPE_HELPER(CXXMethodDecl);\n    CXXConstructorDecl* cxxInheritedCtorDecl{nullptr};\n\n    // Traverse the ctor inline init statements first to find a potential CXXInheritedCtorInitExpr. This carries the\n    // name and the type. The CXXMethodDecl above knows only the type.\n    if(const auto* ctor = dyn_cast_or_null<CXXConstructorDecl>(stmt)) {\n        CodeGeneratorVariant codeGenerator{initOutputFormatHelper, mLambdaStack, mProcessingPrimaryTemplate};\n        codeGenerator->mCurrentVarDeclPos         = mCurrentVarDeclPos;\n        codeGenerator->mCurrentFieldPos           = mCurrentFieldPos;\n        codeGenerator->mCurrentCallExprPos        = mCurrentCallExprPos;\n        codeGenerator->mOutputFormatHelperOutside = &mOutputFormatHelper;\n\n        for(OnceTrue first{}; const auto* init : ctor->inits()) {\n            initOutputFormatHelper.AppendNewLine();\n            if(first) {\n                initOutputFormatHelper.Append(\": \"sv);\n            } else {\n                initOutputFormatHelper.Append(\", \"sv);\n            }\n\n            // in case of delegating or base initializer there is no member.\n#if 0\n            if(const auto* member = init->getMember()) {\n                initOutputFormatHelper.Append(member->getName());\n                codeGenerator->InsertCurlysIfRequired(init->getInit());\n            } else {\n                const auto* inlineInit = init->getInit();\n                bool        useCurlies{false};\n\n                if(const auto* cxxInheritedCtorInitExpr = dyn_cast_or_null<CXXInheritedCtorInitExpr>(inlineInit)) {\n                    cxxInheritedCtorDecl = cxxInheritedCtorInitExpr->getConstructor();\n\n                    // Insert the base class name only, if it is not a CXXContructorExpr and not a\n                    // CXXDependentScopeMemberExpr which already carry the type.\n                } else if(init->isBaseInitializer() and not isa<CXXConstructExpr>(inlineInit)) {\n                    initOutputFormatHelper.Append(GetUnqualifiedScopelessName(init->getBaseClass()));\n                    useCurlies = true;\n                }\n\n                codeGenerator->WrapInCurliesIfNeeded(useCurlies, [&] { codeGenerator->InsertArg(inlineInit); });\n            }\n#else\n            const auto* inlineInit = init->getInit();\n\n            // in case of delegating or base initializer there is no member.\n            if(const auto* member = init->getMember()) {\n                initOutputFormatHelper.Append(member->getName());\n\n                if(isa<ParenListExpr>(inlineInit)) {\n                    codeGenerator->WrapInParens([&] { codeGenerator->InsertArg(inlineInit); });\n                } else {\n                    codeGenerator->InsertCurlysIfRequired(inlineInit);\n                }\n\n            } else if(const auto* cxxInheritedCtorInitExpr = dyn_cast_or_null<CXXInheritedCtorInitExpr>(inlineInit)) {\n                cxxInheritedCtorDecl = cxxInheritedCtorInitExpr->getConstructor();\n\n                codeGenerator->InsertArg(inlineInit);\n\n                // Insert the base class name only, if it is not a CXXContructorExpr and not a\n                // CXXDependentScopeMemberExpr which already carry the type.\n            } else if(init->isBaseInitializer() and not isa<CXXConstructExpr>(inlineInit)) {\n                initOutputFormatHelper.Append(GetUnqualifiedScopelessName(init->getBaseClass()));\n\n                const auto braceKind = isa<ParenListExpr>(inlineInit) ? BraceKind::Parens : BraceKind::Curlys;\n\n                codeGenerator->WrapInParensOrCurlys(braceKind, [&] { codeGenerator->InsertArg(inlineInit); });\n            } else {\n                codeGenerator->InsertArg(inlineInit);\n            }\n#endif\n        }\n    }\n\n    InsertTemplateGuardBegin(stmt);\n    InsertFunctionNameWithReturnType(*stmt, cxxInheritedCtorDecl);\n\n    if(stmt->isDeleted()) {\n        mOutputFormatHelper.AppendNewLine(kwSpaceEqualsDelete);\n\n    } else if(stmt->isDefaulted()) {\n        mOutputFormatHelper.AppendNewLine(kwSpaceEqualsDefault);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertCXXMethodDecl(const CXXMethodDecl* stmt, SkipBody skipBody)\n{\n    OutputFormatHelper initOutputFormatHelper{};\n    initOutputFormatHelper.SetIndent(mOutputFormatHelper, OutputFormatHelper::SkipIndenting::Yes);\n\n    const auto posBeforeFunc = mOutputFormatHelper.CurrentPos();\n\n    InsertCXXMethodHeader(stmt, initOutputFormatHelper);\n\n    if(not stmt->isUserProvided() or stmt->isExplicitlyDefaulted()) {\n        InsertTemplateGuardEnd(stmt);\n        return;\n    }\n\n    mOutputFormatHelper.Append(initOutputFormatHelper);\n\n    if(isa<CXXConversionDecl>(stmt)) {\n        if(stmt->getParent()->isLambda() and not stmt->doesThisDeclarationHaveABody()) {\n            mOutputFormatHelper.AppendNewLine();\n            WrapInCurlys([&]() {\n                mOutputFormatHelper.AppendNewLine();\n                mOutputFormatHelper.Append(\"  \"sv, kwReturn, \" \"sv);\n                if(const auto* invoker = stmt->getParent()->getLambdaStaticInvoker()) {\n                    mOutputFormatHelper.AppendSemiNewLine(invoker->getName());\n                } else {\n                    mOutputFormatHelper.AppendSemiNewLine(kwOperator, \"()\"sv);\n                }\n            });\n        }\n    }\n\n    if((SkipBody::No == skipBody) and stmt->doesThisDeclarationHaveABody() and not stmt->isLambdaStaticInvoker()) {\n        InsertMethodBody(stmt, posBeforeFunc);\n\n    } else if(not InsertLambdaStaticInvoker(stmt) or (SkipBody::Yes == skipBody)) {\n        mOutputFormatHelper.AppendSemiNewLine();\n    }\n\n    InsertTemplateGuardEnd(stmt);\n\n    if(SkipBody::No == skipBody) {\n        mOutputFormatHelper.AppendNewLine();\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXMethodDecl* stmt)\n{\n    // As per [special]/1: \"Programs shall not define implicitly-declared special member functions.\" hide special\n    // members which are not used and with that not fully evaluated. This also hopefully removes confusion about the\n    // noexcept, which is not evaluated, if the special member is not used.\n    RETURN_IF(not GetInsightsOptions().UseShow2C and not stmt->hasBody() and not stmt->isUserProvided() and\n              not stmt->isExplicitlyDefaulted() and not stmt->isDeleted());\n\n    InsertCXXMethodDecl(stmt, SkipBody::No);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const EnumDecl* stmt)\n{\n    mOutputFormatHelper.Append(kwEnumSpace);\n\n    if(stmt->isScoped()) {\n        if(stmt->isScopedUsingClassTag()) {\n            mOutputFormatHelper.Append(kwClassSpace);\n        } else {\n            mOutputFormatHelper.Append(kwStructSpace);\n        }\n    }\n\n    mOutputFormatHelper.Append(stmt->getName());\n\n    if(stmt->isFixed()) {\n        mOutputFormatHelper.Append(\" : \"sv, GetName(stmt->getIntegerType()));\n    }\n\n    mOutputFormatHelper.AppendNewLine();\n\n    WrapInCurlys(\n        [&]() {\n            mOutputFormatHelper.IncreaseIndent();\n            mOutputFormatHelper.AppendNewLine();\n            OnceFalse needsComma{};\n\n            ForEachArg(stmt->enumerators(), [&](const auto* value) {\n                if(needsComma) {\n                    mOutputFormatHelper.AppendNewLine();\n                }\n\n                InsertArg(value);\n            });\n\n            InsertArg(stmt->getBody());\n\n            mOutputFormatHelper.DecreaseIndent();\n            mOutputFormatHelper.AppendNewLine();\n        },\n        AddSpaceAtTheEnd::No);\n\n    mOutputFormatHelper.AppendSemiNewLine();\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const EnumConstantDecl* stmt)\n{\n    mOutputFormatHelper.Append(stmt->getName());\n\n    InsertAttributes(stmt);\n\n    if(const auto* initExpr = stmt->getInitExpr()) {\n        mOutputFormatHelper.Append(hlpAssing);\n\n        InsertArg(initExpr);\n    }\n}\n//-----------------------------------------------------------------------------\n\nstatic auto& GetRecordLayout(const RecordDecl* recordDecl)\n{\n    return GetGlobalAST().getASTRecordLayout(recordDecl);\n}\n//-----------------------------------------------------------------------------\n\n// XXX: replace with std::format once it is available in all std-libs\nauto GetSpaces(std::string::size_type offset)\n{\n    static const std::string_view spaces{\"                              \"sv};\n\n    if(offset >= spaces.size()) {\n        return \"\"sv;\n    } else {\n        return spaces.substr(0, spaces.size() - offset);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const FieldDecl* stmt)\n{\n    LAMBDA_SCOPE_HELPER(Decltype);\n    P0315Visitor dt{*this};\n\n    auto type = GetType(stmt->getType());\n    dt.TraverseType(type);\n\n    const auto initialSize{mOutputFormatHelper.size()};\n    InsertAttributes(stmt->attrs());\n\n    if(stmt->isMutable()) {\n        mOutputFormatHelper.Append(kwMutableSpace);\n    }\n\n    if(const auto* cxxRecordDecl = dyn_cast_or_null<CXXRecordDecl>(stmt->getParent())) {\n        std::string name{GetName(*stmt)};\n\n        if(const auto fieldName = GetFieldDeclNameForLambda(*stmt, *cxxRecordDecl)) {\n            name = std::move(fieldName.value());\n        }\n\n        mOutputFormatHelper.Append(GetTypeNameAsParameter(type, name));\n\n        if(const auto* constantExpr = dyn_cast_or_null<ConstantExpr>(stmt->getBitWidth())) {\n            mOutputFormatHelper.Append(':');\n            InsertArg(constantExpr);\n        }\n\n        // Keep the inline init for aggregates, as we do not see it somewhere else.\n        if(const auto* initializer = stmt->getInClassInitializer();\n           stmt->hasInClassInitializer() and initializer and cxxRecordDecl->isAggregate()) {\n            const bool isConstructorExpr{isa<CXXConstructExpr>(initializer) or isa<ExprWithCleanups>(initializer)};\n            if((ICIS_ListInit != stmt->getInClassInitStyle()) or isConstructorExpr) {\n                mOutputFormatHelper.Append(hlpAssing);\n            }\n\n            InsertArg(initializer);\n        }\n    }\n\n    mOutputFormatHelper.Append(';');\n\n    if(GetInsightsOptions().UseShowPadding) {\n        const auto* fieldClass   = stmt->getParent();\n        const auto& recordLayout = GetRecordLayout(fieldClass);\n        auto        effectiveFieldSize{GetGlobalAST().getTypeInfoInChars(type).Width.getQuantity()};\n        auto        getFieldOffsetInBytes = [&recordLayout](const FieldDecl* field) {\n            return recordLayout.getFieldOffset(field->getFieldIndex()) / 8;  // this is in bits\n        };\n        auto       fieldOffset = getFieldOffsetInBytes(stmt);\n        const auto offset      = mOutputFormatHelper.size() - initialSize;\n\n        mOutputFormatHelper.Append(GetSpaces(offset), \"  /* offset: \"sv, fieldOffset, \", size: \"sv, effectiveFieldSize);\n\n        // - get next field\n        // - if this fields offset + size is equal to the next fields offset we are good,\n        // - if not we insert padding bytes\n        // - in case there is no next field this is the last field, check this field's offset + size against the\n        // records\n        //   size. If unequal padding is needed\n\n        const auto expectedOffset = fieldOffset + effectiveFieldSize;\n        const auto nextOffset     = [&]() -> uint64_t {\n            // find previous field\n            if(const auto next = stmt->getFieldIndex() + 1; recordLayout.getFieldCount() > next) {\n                // We are in bounds, means we expect to get back a valid iterator\n                const auto* field = *std::next(fieldClass->fields().begin(), next);\n\n                return getFieldOffsetInBytes(field);\n            }\n\n            // no field found means we are the last field\n            return recordLayout.getSize().getQuantity();\n        }();\n\n        if(expectedOffset < nextOffset) {\n            const auto padding = nextOffset - expectedOffset;\n            mOutputFormatHelper.AppendNewLine();\n            std::string s = StrCat(\"char \"sv, BuildInternalVarName(\"padding\"sv), \"[\"sv, padding, \"];\"sv);\n            mOutputFormatHelper.Append(s, GetSpaces(s.length()), \"                size: \", padding);\n        }\n\n        mOutputFormatHelper.AppendNewLine(\" */\"sv);\n\n    } else {\n        mOutputFormatHelper.AppendNewLine();\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const AccessSpecDecl* stmt)\n{\n    mOutputFormatHelper.AppendNewLine();\n    mOutputFormatHelper.AppendNewLine(AccessToStringWithColon(stmt->getAccess()));\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const StaticAssertDecl* stmt)\n{\n    LAMBDA_SCOPE_HELPER(CallExpr);\n\n    if(not stmt->isFailed()) {\n        mOutputFormatHelper.Append(\"/* PASSED: \"sv);\n    } else {\n        mOutputFormatHelper.Append(\"/* FAILED: \"sv);\n    }\n\n    mOutputFormatHelper.Append(kwStaticAssert);\n\n    WrapInParens([&] {\n        BackupAndRestore _{GetInsightsOptionsRW().ShowLifetime, false};\n        InsertArg(stmt->getAssertExpr());\n\n        if(stmt->getMessage()) {\n            mOutputFormatHelper.Append(\", \"sv);\n            InsertArg(stmt->getMessage());\n        }\n    });\n\n    mOutputFormatHelper.AppendNewLine(\";\"sv, kwSpaceCCommentEnd);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const UsingDirectiveDecl* stmt)\n{\n    // We need this due to a wired case in UsingDeclTest.cpp\n    if(const auto& name = GetName(*stmt->getNominatedNamespace()); not name.empty()) {\n        mOutputFormatHelper.AppendSemiNewLine(kwUsingSpace, kwNamespaceSpace, name);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const NamespaceDecl* stmt)\n{\n    SCOPE_HELPER(stmt);\n\n    if(stmt->isInline()) {\n        mOutputFormatHelper.Append(kwInlineSpace);\n    }\n\n    mOutputFormatHelper.Append(kwNamespace);\n\n    if(not stmt->isAnonymousNamespace()) {\n        mOutputFormatHelper.Append(\" \"sv, stmt->getName());\n    }\n\n    InsertAttributes(stmt);\n\n    mOutputFormatHelper.AppendNewLine();\n\n    mOutputFormatHelper.OpenScope();\n\n    for(const auto* decl : stmt->decls()) {\n        InsertArg(decl);\n    }\n\n    mOutputFormatHelper.CloseScope();\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::ParseDeclContext(const DeclContext* ctx)\n{\n    mOutputFormatHelper.Append(GetDeclContext(ctx));\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const UsingDecl* stmt)\n{\n    OutputFormatHelper ofm{};\n    ofm.SetIndent(mOutputFormatHelper, OutputFormatHelper::SkipIndenting::Yes);\n\n    // Skip UsingDecl's which have ConstructorUsingShadowDecl attached. This means that we will create the\n    // associated constructors from the base class later. Having this \\c using still in the code prevents compiling\n    // the transformed code.\n    if(stmt->shadow_size()) {\n        for(const auto* shadow : stmt->shadows()) {\n            RETURN_IF(isa<ConstructorUsingShadowDecl>(shadow));\n\n            if(const auto* shadowUsing = dyn_cast_or_null<UsingShadowDecl>(shadow)) {\n                if(const auto* targetDecl = shadowUsing->getTargetDecl(); not isa<TypeAliasDecl>(targetDecl)) {\n                    UsingCodeGenerator codeGenerator{ofm};\n                    codeGenerator.InsertArg(targetDecl);\n                }\n            }\n        }\n    }\n\n    mOutputFormatHelper.Append(kwUsingSpace);\n\n    InsertQualifierAndName(stmt->getDeclName(), stmt->getQualifier(), false);\n\n    mOutputFormatHelper.AppendSemiNewLine();\n\n    // Insert what a using declaration pulled into this scope.\n    if(not ofm.empty()) {\n        mOutputFormatHelper.AppendNewLine(ofm);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const UnresolvedUsingValueDecl* stmt)\n{\n    mOutputFormatHelper.Append(kwUsingSpace);\n\n    InsertQualifierAndName(stmt->getDeclName(), stmt->getQualifier(), false);\n\n    mOutputFormatHelper.AppendSemiNewLine(Ellipsis(stmt->isPackExpansion()));\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const NamespaceAliasDecl* stmt)\n{\n    mOutputFormatHelper.AppendNewLine(\n        kwNamespaceSpace, stmt->getDeclName().getAsString(), hlpAssing, GetName(*stmt->getAliasedNamespace()), \";\");\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const FriendDecl* stmt)\n{\n    if(const auto* typeInfo = stmt->getFriendType()) {\n        mOutputFormatHelper.AppendSemiNewLine(kwFriendSpace, GetName(typeInfo->getType()));\n\n    } else if(const auto* fd = dyn_cast_or_null<FunctionDecl>(stmt->getFriendDecl())) {\n        InsertArg(fd);\n\n    } else if(const auto* fdt = dyn_cast_or_null<FunctionTemplateDecl>(stmt->getFriendDecl())) {\n        InsertArg(fdt);\n\n    } else {\n        std::string cls{};\n        if(const auto* ctd = dyn_cast_or_null<ClassTemplateDecl>(stmt->getFriendDecl())) {\n            InsertTemplateParameters(*ctd->getTemplateParameters());\n\n            cls = GetTagDeclTypeName(*ctd->getTemplatedDecl());\n        }\n\n        mOutputFormatHelper.AppendSemiNewLine(kwFriendSpace, cls, GetName(*stmt->getFriendDecl()));\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXNoexceptExpr* stmt)\n{\n    mOutputFormatHelper.Append(kwNoexcept);\n\n    WrapInParens([&] { mOutputFormatHelper.Append(details::ConvertToBoolString(stmt->getValue())); });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXDeductionGuideDecl* stmt)\n{\n    RETURN_IF(DeductionCandidate::Copy == stmt->getDeductionCandidateKind());\n\n    const bool isImplicit{stmt->isImplicit()};\n    const bool noSpecializations = [&] {\n        if(const auto* dt = stmt->getDescribedFunctionTemplate()) {\n            return dt->specializations().empty();\n        }\n\n        return false;\n    }();\n\n    // Block compiler generated deduction guides which are _overridden_ by user provided deduction guides.\n    RETURN_IF(not stmt->isUsed() and isImplicit and noSpecializations);\n\n    const bool isSpecialization{stmt->isFunctionTemplateSpecialization()};\n    const bool needsTemplateGuard{isImplicit or isSpecialization};\n\n    if(needsTemplateGuard) {\n        InsertTemplateGuardBegin(stmt);\n    }\n\n    const auto* deducedTemplate = stmt->getDeducedTemplate();\n\n    if(isSpecialization) {\n        InsertTemplateSpecializationHeader();\n    } else if(const auto* e = stmt->getDescribedFunctionTemplate()) {\n        InsertTemplateParameters(*e->getTemplateParameters());\n    }\n\n    mOutputFormatHelper.Append(GetName(*deducedTemplate));\n\n    if(stmt->getNumParams()) {\n        WrapInParens([&] { mOutputFormatHelper.AppendParameterList(stmt->parameters()); });\n    } else {\n        mOutputFormatHelper.Append(\"()\"sv);\n    }\n\n    mOutputFormatHelper.AppendSemiNewLine(hlpArrow, GetName(stmt->getReturnType()));\n\n    if(needsTemplateGuard) {\n        InsertTemplateGuardEnd(stmt);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertTemplate(const FunctionTemplateDecl* stmt, bool withSpec)\n{\n    LAMBDA_SCOPE_HELPER(TemplateHead);\n\n    mProcessingPrimaryTemplate = ProcessingPrimaryTemplate::Yes;\n\n    // InsertTemplateParameters(*stmt->getTemplateParameters());\n    InsertArg(stmt->getTemplatedDecl());\n\n    mProcessingPrimaryTemplate = ProcessingPrimaryTemplate::No;\n\n    RETURN_IF(not withSpec);\n\n    for(const auto* spec : stmt->specializations()) {\n        // For specializations we will see them later\n        if(spec->getPreviousDecl()) {\n            continue;\n        }\n\n        mOutputFormatHelper.AppendNewLine();\n        InsertArg(spec);\n        mOutputFormatHelper.AppendNewLine();\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const FunctionTemplateDecl* stmt)\n{\n    InsertTemplate(stmt, true);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const TypeAliasTemplateDecl* stmt)\n{\n    InsertTemplateParameters(*stmt->getTemplateParameters());\n\n    InsertArg(stmt->getTemplatedDecl());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const AttributedStmt* stmt)\n{\n    for(const auto& attr : stmt->getAttrs()) {\n        InsertAttribute(*attr);\n    }\n\n    InsertArg(stmt->getSubStmt());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertAttributes(const Decl* stmt)\n{\n    if(stmt->hasAttrs()) {\n        mOutputFormatHelper.Append(\" \"sv);\n\n        InsertAttributes(stmt->attrs());\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertAttributes(const Decl::attr_range& attrs)\n{\n    // attrs required for constinit\n    for(const auto& attr : attrs) {\n        InsertAttribute(*attr);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertAttribute(const Attr& attr)\n{\n    // skip this attribute. Clang seems to tag virtual methods with override\n    RETURN_IF(attr::Override == attr.getKind());\n\n    // skip this attribute. Clang seems to tag final methods or classes with final\n    RETURN_IF(attr::Final == attr.getKind());\n\n#if IS_CLANG_NEWER_THAN(17)\n    // skip this custom clang attribute\n    RETURN_IF(attr::NoInline == attr.getKind());\n#endif\n\n    // Clang's printPretty misses the parameter pack ellipsis. Hence treat this special case here.\n    if(const auto* alignedAttr = dyn_cast_or_null<AlignedAttr>(&attr)) {\n        auto insert = [&](const QualType type, const TemplateTypeParmType* tmplTypeParam) {\n            mOutputFormatHelper.Append(attr.getSpelling(),\n                                       \"(\"sv,\n                                       kwAlignof,\n                                       \"(\"sv,\n                                       GetName(type),\n                                       \")\"sv,\n                                       Ellipsis(tmplTypeParam->isParameterPack()),\n                                       \") \"sv);\n        };\n\n        if(alignedAttr->isAlignmentExpr()) {\n            if(const auto* unaryExpr = dyn_cast_or_null<UnaryExprOrTypeTraitExpr>(alignedAttr->getAlignmentExpr())) {\n                if(const auto* tmplTypeParam =\n                       dyn_cast_or_null<TemplateTypeParmType>(unaryExpr->getArgumentType().getTypePtrOrNull())) {\n                    insert(unaryExpr->getArgumentType(), tmplTypeParam);\n                    return;\n                }\n            }\n        } else if(const auto* tmplTypeParam =\n                      alignedAttr->getAlignmentType()->getType()->getAs<TemplateTypeParmType>()) {\n            insert(alignedAttr->getAlignmentType()->getType(), tmplTypeParam);\n            return;\n        }\n    }\n\n    StringStream   stream{};\n    PrintingPolicy pp{GetGlobalAST().getLangOpts()};\n    pp.adjustForCPlusPlus();\n\n    attr.printPretty(stream, pp);\n\n    // attributes start with a space, skip it as it is not required for the first attribute\n    std::string_view start{stream.str()};\n#if IS_CLANG_NEWER_THAN(18)\n#else\n    if(!start.empty()) {\n        start.remove_prefix(1);\n    }\n#endif\n\n    mOutputFormatHelper.Append(start, \" \"sv);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXRecordDecl* stmt)\n{\n    const size_t insertPosBeforeClass{mOutputFormatHelper.CurrentPos()};\n    const auto   indentAtInsertPosBeforeClass{mOutputFormatHelper.GetIndent()};\n\n    SCOPE_HELPER(stmt);\n\n    // Prevent a case like in #205 where the lambda appears twice.\n    RETURN_IF(stmt->isLambda() and (mLambdaStack.empty() or (nullptr == mLambdaExpr)));\n\n    const auto* classTemplatePartialSpecializationDecl = dyn_cast_or_null<ClassTemplatePartialSpecializationDecl>(stmt);\n    const auto* classTemplateSpecializationDecl        = dyn_cast_or_null<ClassTemplateSpecializationDecl>(stmt);\n\n    // we require the if-guard only if it is a compiler generated specialization. If it is a hand-written variant it\n    // should compile.\n    const bool isClassTemplateSpecialization{classTemplatePartialSpecializationDecl or classTemplateSpecializationDecl};\n    const bool tmplRequiresIfDef{[&] {\n        if(classTemplatePartialSpecializationDecl) {\n            return classTemplatePartialSpecializationDecl->isImplicit();\n\n        } else if(classTemplateSpecializationDecl) {\n            return not classTemplateSpecializationDecl->isExplicitInstantiationOrSpecialization();\n        }\n\n        return false;\n    }()};\n\n    FinalAction _{[&] {\n        if(tmplRequiresIfDef) {\n            mOutputFormatHelper.InsertEndIfTemplateGuard();\n        }\n    }};\n\n    if(isClassTemplateSpecialization) {\n        if(tmplRequiresIfDef) {\n            InsertInstantiationPoint(GetSM(*classTemplateSpecializationDecl),\n                                     classTemplateSpecializationDecl->getPointOfInstantiation());\n            mOutputFormatHelper.InsertIfDefTemplateGuard();\n        }\n\n        if(classTemplatePartialSpecializationDecl) {\n            InsertTemplateParameters(*classTemplatePartialSpecializationDecl->getTemplateParameters());\n        } else {\n            InsertTemplateSpecializationHeader();\n        }\n        // Render a out-of-line struct declared inside a class template\n    } else if(stmt->getLexicalDeclContext() != stmt->getDeclContext()) {\n        if(const auto* parent = dyn_cast_or_null<CXXRecordDecl>(stmt->getDeclContext())) {\n            if(const auto* outerClasTemplateDecl = parent->getDescribedClassTemplate()) {\n                InsertTemplateParameters(*outerClasTemplateDecl->getTemplateParameters());\n            }\n        }\n    }\n\n    mOutputFormatHelper.Append(GetTagDeclTypeName(*stmt));\n\n    InsertAttributes(stmt->attrs());\n\n    mOutputFormatHelper.Append(GetName(*stmt));\n\n    if(classTemplateSpecializationDecl) {\n        InsertTemplateArgs(*classTemplateSpecializationDecl);\n    }\n\n    if(stmt->hasAttr<FinalAttr>()) {\n        mOutputFormatHelper.Append(kwSpaceFinal);\n    }\n\n    // skip classes/struct's without a definition\n    if(not stmt->hasDefinition() or not stmt->isCompleteDefinition()) {\n        mOutputFormatHelper.AppendSemiNewLine();\n        return;\n    }\n\n    if(stmt->getNumBases()) {\n        mOutputFormatHelper.Append(\" : \"sv);\n\n        ForEachArg(stmt->bases(), [&](const auto& base) {\n            mOutputFormatHelper.Append(getAccessSpelling(base.getAccessSpecifier()),\n                                       \" \"sv,\n                                       ValueOrDefault(base.isVirtual(), kwVirtualSpace),\n                                       GetName(base.getType()),\n                                       Ellipsis(base.isPackExpansion()));\n        });\n    }\n\n    if(GetInsightsOptions().UseShowPadding) {\n        const auto& recordLayout = GetRecordLayout(stmt);\n        mOutputFormatHelper.AppendNewLine(\n            \"  /* size: \"sv, recordLayout.getSize(), \", align: \"sv, recordLayout.getAlignment(), \" */\"sv);\n\n    } else {\n        mOutputFormatHelper.AppendNewLine();\n    }\n\n    mOutputFormatHelper.OpenScope();\n\n    if(GetInsightsOptions().UseShowPadding) {\n        for(size_t offset{}; const auto& base : stmt->bases()) {\n            const auto& baseRecordLayout = GetRecordLayout(base.getType()->getAsRecordDecl());\n            const auto  baseVar          = StrCat(\"/* base (\"sv, GetName(base.getType()), \")\"sv);\n            const auto  size             = baseRecordLayout.getSize().getQuantity();\n\n            mOutputFormatHelper.AppendNewLine(\n                baseVar, GetSpaces(baseVar.size()), \"     offset: \"sv, offset, \", size: \"sv, size, \" */\"sv);\n\n            offset += size;\n        }\n    }\n\n    UpdateCurrentPos(mCurrentFieldPos);\n\n    OnceTrue        firstRecordDecl{};\n    OnceTrue        firstDecl{};\n    Decl::Kind      formerKind{};\n    AccessSpecifier lastAccess{stmt->isClass() ? AS_private : AS_public};\n    for(const auto* d : stmt->decls()) {\n        if(isa<CXXRecordDecl>(d) and firstRecordDecl) {\n            continue;\n        }\n\n        // Insert a newline when the decl kind changes. This for example, inserts a newline when after a FieldDecl\n        // we see a CXXMethodDecl.\n        if(not firstDecl and (d->getKind() != formerKind)) {\n            // mOutputFormatHelper.AppendNewLine();\n        }\n\n        if((stmt->isLambda() and isa<CXXDestructorDecl>(d)) and not d->isUsed()) {\n            continue;\n        }\n\n        // Insert the access modifier, as at least some of the compiler generated classes do not contain an access\n        // specifier which results in a default ctor being private if we do not insert the access modifier.\n        if(lastAccess != d->getAccess()) {\n            lastAccess = d->getAccess();\n\n            // skip inserting an access specifier of our own, if there is a real one coming.\n            if(not isa<AccessSpecDecl>(d)) {\n                mOutputFormatHelper.AppendNewLine(AccessToStringWithColon(lastAccess));\n            }\n        }\n\n        InsertArg(d);\n\n        formerKind = d->getKind();\n    }\n\n    if(stmt->isLambda()) {\n        const LambdaCallerType lambdaCallerType = mLambdaStack.back().callerType();\n        const bool             ctorRequired{stmt->capture_size() or stmt->lambdaIsDefaultConstructibleAndAssignable()};\n\n        if(ctorRequired) {\n            if(AS_public != lastAccess) {\n                mOutputFormatHelper.AppendNewLine();\n                // XXX avoid diff in tests. AccessToStringWithColon add \"public: \" before there was no space.\n                const auto       pub{AccessToStringWithColon(AS_public)};\n                std::string_view p{pub};\n                p.remove_suffix(1);\n                mOutputFormatHelper.AppendNewLine(p);\n            }\n\n            if(stmt->lambdaIsDefaultConstructibleAndAssignable()) {\n                mOutputFormatHelper.Append(kwCppCommentStartSpace);\n\n                if(stmt->hasConstexprDefaultConstructor()) {\n                    mOutputFormatHelper.Append(kwCommentStart, kwConstExprSpace, kwCCommentEndSpace);\n                }\n            }\n\n            mOutputFormatHelper.Append(GetName(*stmt), \"(\"sv);\n        }\n\n        SmallVector<std::string, 5> ctorInitializerList{};\n        std::string                 ctorArguments{'{'};\n        OnceTrue                    firstCtorArgument{};\n\n        auto addToInits =\n            [&](std::string_view name, const FieldDecl* fd, bool isThis, const Expr* expr, bool /*useBraces*/) {\n                if(firstCtorArgument) {\n                } else {\n                    mOutputFormatHelper.Append(\", \"sv);\n                    ctorArguments.append(\", \"sv);\n                }\n\n                bool byConstRef{false};\n                auto fieldName{isThis ? kwInternalThis : name};\n                auto fieldDeclType{fd->getType()};\n                bool isMoved{};\n\n                std::string fname = StrCat(\"_\"sv, name);\n\n                // Special handling for lambdas with init captures which contain a move. In such a case, copy the\n                // initial move statement and make the variable a &&.\n                if(const auto* cxxConstructExpr = dyn_cast_or_null<CXXConstructExpr>(expr);\n                   cxxConstructExpr and cxxConstructExpr->getConstructor()->isMoveConstructor()) {\n\n                    OutputFormatHelper             ofm{};\n                    LambdaInitCaptureCodeGenerator codeGenerator{ofm, mLambdaStack, name};\n\n                    if(cxxConstructExpr->getNumArgs()) {\n                        ForEachArg(cxxConstructExpr->arguments(),\n                                   [&](const auto& arg) { codeGenerator.InsertArg(arg); });\n                    }\n\n                    fieldDeclType = stmt->getASTContext().getRValueReferenceType(fieldDeclType);\n\n                    fname = ofm;\n\n                    // If it is not an object, check for other conditions why we take the variable by const &/&& in the\n                    // ctor\n                } else if(not fieldDeclType->isReferenceType() and not fieldDeclType->isAnyPointerType() and\n                          not fieldDeclType->isUndeducedAutoType()) {\n                    byConstRef                      = true;\n                    const auto* exprWithoutImpCasts = expr->IgnoreParenImpCasts();\n\n                    // treat a move of a primitive type\n                    if(exprWithoutImpCasts->isXValue()) {\n                        byConstRef = false;\n\n                        OutputFormatHelper             ofm{};\n                        LambdaInitCaptureCodeGenerator codeGenerator{ofm, mLambdaStack, name};\n                        codeGenerator.InsertArg(expr);\n\n                        fname = ofm;\n\n                    } else if(exprWithoutImpCasts\n                                  ->isPRValue()  // If we are looking at an rvalue (temporary) we need a const ref\n                              or exprWithoutImpCasts->getType().isConstQualified()  // If the captured variable is const\n                                                                                    // we can take it only by const ref\n\n                    ) {\n                        // this must go before adding the L or R-value reference, otherwise we get T& const instead of\n                        // const T&\n\n                        if(exprWithoutImpCasts->isPRValue() and isa<CXXBindTemporaryExpr>(exprWithoutImpCasts) and\n                           not exprWithoutImpCasts->getType().isConstQualified()) {\n                            fieldDeclType = stmt->getASTContext().getRValueReferenceType(fieldDeclType);\n                            EnableGlobalInsert(GlobalInserts::HeaderUtility);\n                            fname   = StrCat(\"std::move(\"sv, fname, \")\"sv);\n                            isMoved = true;\n\n                        } else {\n                            fieldDeclType.addConst();\n                        }\n                    }\n\n                    if(exprWithoutImpCasts->isXValue()) {\n                        fieldDeclType = stmt->getASTContext().getRValueReferenceType(fieldDeclType);\n\n                    } else if(not isMoved) {\n                        fieldDeclType = stmt->getASTContext().getLValueReferenceType(fieldDeclType);\n                    }\n                }\n\n                const std::string_view elips{\n                    Ellipsis(isa_and_nonnull<PackExpansionType>(fieldDeclType->getPointeeType().getTypePtrOrNull()))};\n\n                // To avoid seeing the templates stuff from std::move (typename...) the canonical type is used here.\n                fieldDeclType = fieldDeclType.getCanonicalType();\n\n                ctorInitializerList.push_back(StrCat(fieldName, \"{\"sv, fname, elips, \"}\"sv));\n\n                if(not isThis and expr) {\n                    LAMBDA_SCOPE_HELPER(Decltype);\n                    OutputFormatHelper ofmLambdaInCtor{};\n                    ofmLambdaInCtor.SetIndent(indentAtInsertPosBeforeClass);\n                    CodeGenerator cgLambdaInCtor{ofmLambdaInCtor, LambdaInInitCapture::Yes};\n\n                    if(P0315Visitor dt{cgLambdaInCtor}; dt.TraverseStmt(const_cast<Expr*>(expr))) {\n\n                        OutputFormatHelper   ofm{};\n                        CodeGeneratorVariant codeGenerator{ofm, mLambdaStack, mProcessingPrimaryTemplate};\n\n                        if(const auto* ctorExpr = dyn_cast_or_null<CXXConstructExpr>(expr);\n                           ctorExpr and byConstRef and (1 == ctorExpr->getNumArgs())) {\n                            codeGenerator->InsertArg(ctorExpr->getArg(0));\n\n                        } else {\n                            codeGenerator->InsertArg(expr);\n                        }\n\n                        //        if(isa<PackExpansionType>(stmt->getDecl()->getType().getTypePtrOrNull())) {\n                        //            mOutputFormatHelper.Append(kwElipsisSpace);\n                        //        }\n\n                        ctorArguments.append(ofm);\n\n                    } else {\n                        OutputFormatHelper          ofm{};\n                        LambdaNameOnlyCodeGenerator ccg{ofm};\n                        ccg.InsertArg(expr);\n\n                        ctorArguments.append(ofm.GetString());\n\n                        mOutputFormatHelper.InsertAt(insertPosBeforeClass, ofmLambdaInCtor);\n                    }\n                } else {\n                    if(isThis and not fieldDeclType->isPointerType()) {\n                        ctorArguments.append(\"*\"sv);\n                    }\n\n                    ctorArguments.append(name);\n                }\n\n                mOutputFormatHelper.Append(GetTypeNameAsParameter(fieldDeclType, StrCat(\"_\"sv, name)));\n            };\n\n        llvm::DenseMap<const ValueDecl*, FieldDecl*> captures{};\n        FieldDecl*                                   thisCapture{};\n\n        stmt->getCaptureFields(captures, thisCapture);\n\n        // Check if it captures this\n        if(thisCapture) {\n            const auto* captureInit = mLambdaExpr->capture_init_begin();\n\n            addToInits(kwThis, thisCapture, true, *captureInit, false);\n        }\n\n        // Find the corresponding capture in the DenseMap. The DenseMap seems to be change its order each time.\n        // Hence we use \\c captures() to keep the order stable. While using \\c Captures to generate the code as\n        // it carries the better type infos.\n        for(const auto& [c, cinit] : zip(mLambdaExpr->captures(), mLambdaExpr->capture_inits())) {\n            if(not c.capturesVariable()) {\n                continue;\n            }\n\n            const auto* capturedVar = c.getCapturedVar();\n            if(const auto* value = captures[capturedVar]) {\n                // Since C++20 lambdas can capture structured bindings\n                if(const auto* bindingDecl = dyn_cast_or_null<BindingDecl>(capturedVar)) {\n                    capturedVar = bindingDecl->getHoldingVar();\n                }\n\n                addToInits(GetName(*capturedVar),\n                           value,\n                           false,\n                           cinit,\n                           VarDecl::ListInit == dyn_cast_or_null<VarDecl>(capturedVar)->getInitStyle());\n            }\n        }\n\n        ctorArguments.append(\"}\"sv);\n\n        // generate the ctor only if it is required, i.e. we have captures. This is in fact a trick to get\n        // compiling code out of it. The compiler itself does not generate a constructor in many many cases.\n        if(ctorRequired) {\n            mOutputFormatHelper.Append(\")\"sv);\n\n            if(stmt->lambdaIsDefaultConstructibleAndAssignable()) {\n                mOutputFormatHelper.AppendNewLine(kwSpaceEqualsDefault);\n\n            } else {\n                mOutputFormatHelper.AppendNewLine();\n\n                for(OnceTrue firstCtorInitializer{}; const auto& initializer : ctorInitializerList) {\n                    if(firstCtorInitializer) {\n                        mOutputFormatHelper.Append(\": \"sv);\n                    } else {\n                        mOutputFormatHelper.Append(\", \"sv);\n                    }\n\n                    mOutputFormatHelper.AppendNewLine(initializer);\n                }\n\n                mOutputFormatHelper.AppendNewLine(\"{}\"sv);\n            }\n        }\n\n        // close the class scope\n        mOutputFormatHelper.CloseScope();\n\n        if(not is{lambdaCallerType}.any_of(LambdaCallerType::VarDecl,\n                                           LambdaCallerType::InitCapture,\n                                           LambdaCallerType::CallExpr,\n                                           LambdaCallerType::MemberCallExpr,\n                                           LambdaCallerType::TemplateHead,\n                                           LambdaCallerType::Decltype)) {\n            mOutputFormatHelper.Append(\" \"sv, GetLambdaName(*stmt), ctorArguments);\n        } else if(not is{lambdaCallerType}.any_of(LambdaCallerType::TemplateHead, LambdaCallerType::Decltype)) {\n            mLambdaStack.back().inits().append(ctorArguments);\n        }\n    } else {\n        mOutputFormatHelper.CloseScope(OutputFormatHelper::NoNewLineBefore::Yes);\n    }\n\n    if(GetInsightsOptions().UseShow2C) {\n        mOutputFormatHelper.Append(\" \"sv, GetName(*stmt));\n    }\n\n    mOutputFormatHelper.AppendSemiNewLine();\n    mOutputFormatHelper.AppendNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const DeclStmt* stmt)\n{\n    for(const auto* decl : stmt->decls()) {\n        InsertArg(decl);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const SubstNonTypeTemplateParmExpr* stmt)\n{\n    InsertArg(stmt->getReplacement());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const SizeOfPackExpr* stmt)\n{\n    if(stmt->isPartiallySubstituted()) {\n        mOutputFormatHelper.Append(stmt->getPartialArguments().size());\n    } else if(not stmt->isValueDependent()) {\n        mOutputFormatHelper.Append(stmt->getPackLength());\n    } else {\n        mOutputFormatHelper.Append(kwSizeof, kwElipsis, \"(\"sv, GetName(*stmt->getPack()), \")\"sv);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ReturnStmt* stmt)\n{\n    LAMBDA_SCOPE_HELPER(ReturnStmt);\n\n    UpdateCurrentPos(mCurrentReturnPos);\n\n    {  // dedicated scope to first clear everything found in the return statement. Then clear all others.\n        TemporaryDeclFinder temporaryFinder{*this, stmt->getRetValue(), true};\n\n        mOutputFormatHelper.Append(kwReturn);\n\n        if(const auto* retVal = stmt->getRetValue()) {\n            mOutputFormatHelper.Append(' ');\n\n            if(not temporaryFinder.Found()) {\n                if(const auto* nrvoVD = stmt->getNRVOCandidate()) {\n                    mOutputFormatHelper.Append(GetName(*nrvoVD));\n                } else {\n                    InsertArg(retVal);\n                }\n            } else {\n                mOutputFormatHelper.Append(temporaryFinder.Name());\n            }\n        }\n    }\n\n    mSkipSemi = mLifeTimeTracker.Return(mOutputFormatHelper);\n\n    // the InsertArg above changes the start\n    mLastStmt = stmt;\n\n    mCurrentReturnPos.reset();\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const NullStmt* /*stmt*/)\n{\n    mOutputFormatHelper.AppendSemiNewLine();\n    mSkipSemi = true;\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const StmtExpr* stmt)\n{\n    WrapInParens([&] { InsertArg(stmt->getSubStmt()); });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CppInsightsCommentStmt* stmt)\n{\n    mOutputFormatHelper.AppendCommentNewLine(stmt->Comment());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const ConceptSpecializationExpr* stmt)\n{\n    if(const auto* namedConcept = stmt->getNamedConcept()) {\n        mOutputFormatHelper.Append(GetName(*namedConcept));\n        InsertTemplateArgs(stmt->getTemplateArgsAsWritten()->arguments());\n\n#if 0\n        if(not stmt->isValueDependent()) {\n            mOutputFormatHelper.Append(kwCCommentStartSpace, stmt->isSatisfied(), kwSpaceCCommentEndSpace);\n        }\n#endif\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const RequiresExpr* stmt)\n{\n    mOutputFormatHelper.Append(kwRequires);\n\n    const auto localParameters = stmt->getLocalParameters();\n    WrapInParensIfNeeded(\n        not localParameters.empty(),\n        [&] { mOutputFormatHelper.AppendParameterList(localParameters); },\n        AddSpaceAtTheEnd::Yes);\n\n    mOutputFormatHelper.OpenScope();\n\n    const auto  noEmptyInitList = mNoEmptyInitList;\n    FinalAction _{[&] { mNoEmptyInitList = noEmptyInitList; }};\n    mNoEmptyInitList = NoEmptyInitList::Yes;\n\n    for(const auto& requirement : stmt->getRequirements()) {\n        if(const auto* typeRequirement = dyn_cast_or_null<concepts::TypeRequirement>(requirement)) {\n            if(typeRequirement->isSubstitutionFailure()) {\n                mOutputFormatHelper.Append(kwRequiresSpace, kwFalse);\n            } else {\n                mOutputFormatHelper.Append(GetName(typeRequirement->getType()->getType()));\n            }\n\n            // SimpleRequirement\n        } else if(const auto* exprRequirement = dyn_cast_or_null<concepts::ExprRequirement>(requirement)) {\n            if(exprRequirement->isExprSubstitutionFailure()) {\n                // The requirement failed. We need some way to express that. Using a nested\n                // requirement with false seems to be the simplest solution.\n                mOutputFormatHelper.Append(kwRequiresSpace, kwFalse);\n            } else {\n                WrapInCurliesIfNeeded(exprRequirement->isCompound(), [&] { InsertArg(exprRequirement->getExpr()); });\n\n                if(exprRequirement->hasNoexceptRequirement()) {\n                    mOutputFormatHelper.Append(kwSpaceNoexcept);\n                }\n\n                if(const auto& returnTypeRequirement = exprRequirement->getReturnTypeRequirement();\n                   not returnTypeRequirement.isEmpty()) {\n                    if(auto typeConstraint = GetTypeConstraintAsString(returnTypeRequirement.getTypeConstraint());\n                       not typeConstraint.empty()) {\n                        mOutputFormatHelper.Append(hlpArrow, std::move(typeConstraint));\n                    }\n                }\n            }\n        } else if(const auto* nestedRequirement = dyn_cast_or_null<concepts::NestedRequirement>(requirement)) {\n            mOutputFormatHelper.Append(kwRequiresSpace);\n\n            if(nestedRequirement->hasInvalidConstraint()) {\n                // The requirement failed. We need some way to express that. Using a nested\n                // requirement with false seems to be the simplest solution.\n                mOutputFormatHelper.Append(kwFalse);\n            } else {\n                InsertArg(nestedRequirement->getConstraintExpr());\n            }\n        }\n\n        mOutputFormatHelper.AppendSemiNewLine();\n    }\n\n    mOutputFormatHelper.CloseScope(OutputFormatHelper::NoNewLineBefore::Yes);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXDefaultArgExpr* stmt)\n{\n    InsertArg(stmt->getExpr());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXStdInitializerListExpr* stmt)\n{\n    // No qualifiers like const or volatile here. This appears in  function calls or operators as a parameter.\n    // CV's are not allowed there.\n    const auto typeName{GetName(stmt->getType(), Unqualified::Yes)};\n\n    if(GetInsightsOptions().UseShowInitializerList) {\n        RETURN_IF(not mCurrentVarDeclPos.has_value() and not mCurrentFieldPos.has_value() and\n                  not mCurrentReturnPos.has_value() and not mCurrentCallExprPos.has_value());\n\n        const auto* subExpr = stmt->getSubExpr();\n\n        if(const auto* dref = dyn_cast_or_null<DeclRefExpr>(subExpr); dref and GetInsightsOptions().ShowLifetime) {\n            const auto size = GetSize(dyn_cast_or_null<ConstantArrayType>(subExpr->getType()));\n\n            mOutputFormatHelper.Append(typeName, \"{\"sv, GetName(*dref), \", \"sv, size, \"}\"sv);\n            return;\n        }\n\n        std::string modifiers{};\n        size_t      variableInsertPos = mCurrentReturnPos.value_or(\n            mCurrentVarDeclPos.value_or(mCurrentCallExprPos.value_or(0)));  // order is important!\n\n        auto& ofmToInsert = [&]() -> decltype(auto) {\n            if(not mCurrentVarDeclPos.has_value() and not mCurrentReturnPos.has_value() and\n               not mCurrentCallExprPos.has_value()) {\n                variableInsertPos  = mCurrentFieldPos.value_or(0);\n                mCurrentVarDeclPos = variableInsertPos;\n                modifiers          = StrCat(kwStaticSpace, kwInlineSpace);\n                return (*mOutputFormatHelperOutside);\n            }\n\n            return (mOutputFormatHelper);\n        }();\n\n        OutputFormatHelper ofm{};\n        ofm.SetIndent(ofmToInsert, OutputFormatHelper::SkipIndenting::Yes);\n\n        const auto size = [&]() -> size_t {\n            if(const auto* mat = dyn_cast<MaterializeTemporaryExpr>(subExpr)) {\n                if(const auto* list = dyn_cast_or_null<InitListExpr>(mat->getSubExpr())) {\n                    return list->getNumInits();\n                }\n            }\n\n            return 0;\n        }();\n\n        auto internalListName =\n            MakeLineColumnName(GetGlobalAST().getSourceManager(), stmt->getBeginLoc(), BuildInternalVarName(\"list\"sv));\n\n        ofm.Append(modifiers, GetTypeNameAsParameter(subExpr->getType(), internalListName));\n        CodeGeneratorVariant codeGenerator{ofm};\n        codeGenerator->InsertArg(subExpr);\n        ofm.AppendSemiNewLine();\n\n        ofmToInsert.InsertAt(variableInsertPos, ofm);\n\n        mOutputFormatHelper.Append(typeName, \"{\"sv, internalListName, \", \"sv, size, \"}\"sv);\n\n        if(mCurrentReturnPos.has_value()) {\n            mCurrentReturnPos = mCurrentReturnPos.value() + ofm.size();\n        } else if(mCurrentVarDeclPos.has_value()) {\n            mCurrentVarDeclPos = mCurrentVarDeclPos.value() + ofm.size();\n        } else {\n            mCurrentCallExprPos = mCurrentCallExprPos.value() + ofm.size();\n        }\n\n    } else {\n        mOutputFormatHelper.Append(typeName);\n        InsertArg(stmt->getSubExpr());\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const CXXNullPtrLiteralExpr* /*stmt*/)\n{\n    mOutputFormatHelper.Append(kwNullptr);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const LabelDecl* stmt)\n{\n    mOutputFormatHelper.Append(stmt->getName());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const Decl* stmt)\n{\n    mLastDecl = stmt;\n\n#define SUPPORTED_DECL(type)                                                                                           \\\n    if(isa<type>(stmt)) {                                                                                              \\\n        InsertArg(static_cast<const type*>(stmt));                                                                     \\\n        return;                                                                                                        \\\n    }\n\n#define IGNORED_DECL SUPPORTED_DECL\n\n#include \"CodeGeneratorTypes.h\"\n\n    ToDo(stmt, mOutputFormatHelper);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const Stmt* stmt)\n{\n    if(not stmt) {\n        DPrint(\"Null stmt\\n\");\n        return;\n    }\n\n    mLastStmt = stmt;\n\n#define SUPPORTED_STMT(type)                                                                                           \\\n    if(isa<type>(stmt)) {                                                                                              \\\n        InsertArg(dyn_cast_or_null<type>(stmt));                                                                       \\\n        return;                                                                                                        \\\n    }\n\n#define IGNORED_STMT SUPPORTED_STMT\n\n#include \"CodeGeneratorTypes.h\"\n\n    ToDo(stmt, mOutputFormatHelper);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::FormatCast(const std::string_view castName,\n                               const QualType&        castDestType,\n                               const Expr*            subExpr,\n                               const CastKind&        castKind)\n{\n    const bool        isCastToBase{is{castKind}.any_of(CK_DerivedToBase, CK_UncheckedDerivedToBase) and\n                            castDestType->isRecordType()};\n    const std::string castDestTypeText{\n        StrCat(GetName(castDestType), ((isCastToBase and not castDestType->isAnyPointerType()) ? \"&\"sv : \"\"sv))};\n\n    mOutputFormatHelper.Append(castName, \"<\"sv, castDestTypeText, \">(\"sv);\n    InsertArg(subExpr);\n    mOutputFormatHelper.Append(')');\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArgWithParensIfNeeded(const Stmt* stmt)\n{\n    const bool needsParens = [&]() {\n        if(const auto* expr = dyn_cast_or_null<Expr>(stmt)) {\n            if(const auto* dest = dyn_cast_or_null<UnaryOperator>(expr->IgnoreImplicit())) {\n                return (dest->getOpcode() == clang::UO_Deref);\n            }\n        }\n\n        return false;\n    }();\n\n    WrapInParensIfNeeded(needsParens, [&] { InsertArg(stmt); });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertSuffix(const QualType& type)\n{\n    if(const auto* typePtr = type.getTypePtrOrNull(); typePtr and typePtr->isBuiltinType()) {\n        if(const auto* bt = dyn_cast_or_null<BuiltinType>(typePtr)) {\n            const auto kind = bt->getKind();\n\n            mOutputFormatHelper.Append(GetBuiltinTypeSuffix(kind));\n        }\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertTemplateArgs(const ClassTemplateSpecializationDecl& clsTemplateSpe)\n{\n#if IS_CLANG_NEWER_THAN(18)\n    if(const auto* ar = clsTemplateSpe.getTemplateArgsAsWritten()) {\n        InsertTemplateArgs(ar->arguments());\n    } else {\n        InsertTemplateArgs(clsTemplateSpe.getTemplateArgs());\n    }\n#else\n    if(const TypeSourceInfo* typeAsWritten = clsTemplateSpe.getTypeAsWritten()) {\n        const TemplateSpecializationType* tmplSpecType = cast<TemplateSpecializationType>(typeAsWritten->getType());\n        InsertTemplateArgs(*tmplSpecType);\n    } else {\n        InsertTemplateArgs(clsTemplateSpe.getTemplateArgs());\n    }\n#endif\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::HandleTemplateParameterPack(const ArrayRef<TemplateArgument>& args)\n{\n    ForEachArg(args, [&](const auto& arg) { InsertTemplateArg(arg); });\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertTemplateArg(const TemplateArgument& arg)\n{\n    switch(arg.getKind()) {\n        case TemplateArgument::Type: mOutputFormatHelper.Append(GetName(arg.getAsType())); break;\n        case TemplateArgument::Declaration:\n            // TODO: handle pointers\n            mOutputFormatHelper.Append(\"&\"sv, GetName(*arg.getAsDecl(), QualifiedName::Yes));\n            break;\n        case TemplateArgument::NullPtr: mOutputFormatHelper.Append(kwNullptr); break;\n        case TemplateArgument::Integral:\n\n            if(const auto& integral = arg.getAsIntegral(); arg.getIntegralType()->isCharType()) {\n                const char c{static_cast<char>(integral.getZExtValue())};\n                mOutputFormatHelper.Append(\"'\"sv, std::string{c}, \"'\"sv);\n            } else {\n                mOutputFormatHelper.Append(integral);\n            }\n\n            break;\n        case TemplateArgument::Expression: InsertArg(arg.getAsExpr()); break;\n        case TemplateArgument::Pack: HandleTemplateParameterPack(arg.pack_elements()); break;\n        case TemplateArgument::Template:\n            mOutputFormatHelper.Append(GetName(*arg.getAsTemplate().getAsTemplateDecl()));\n            break;\n        case TemplateArgument::TemplateExpansion:\n            mOutputFormatHelper.Append(GetName(*arg.getAsTemplateOrTemplatePattern().getAsTemplateDecl()));\n            break;\n        case TemplateArgument::Null: mOutputFormatHelper.Append(\"null\"sv); break;\n#if IS_CLANG_NEWER_THAN(17)\n        case TemplateArgument::StructuralValue: ToDo(arg, mOutputFormatHelper); break;\n#endif\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::HandleLocalStaticNonTrivialClass(const VarDecl* stmt)\n{\n    EnableGlobalInsert(GlobalInserts::HeaderNew);\n\n    const auto& ctx = GetGlobalAST();\n\n    auto&      langOpts{GetLangOpts(*stmt)};\n    const bool threadSafe{langOpts.ThreadsafeStatics and langOpts.CPlusPlus11 and\n                          (stmt->isLocalVarDecl() /*|| NonTemplateInline*/) and not stmt->getTLSKind()};\n\n    const std::string internalVarName{BuildInternalVarName(GetName(*stmt))};\n    const std::string compilerBoolVarName{StrCat(internalVarName, \"Guard\"sv)};\n\n    // insert compiler bool to track init state\n    auto* compilerGuardVar =\n        Variable(compilerBoolVarName, threadSafe ? Typedef(\"uint64_t\"sv, ctx.UnsignedLongTy) : ctx.BoolTy);\n    compilerGuardVar->setStorageClass(StorageClass::SC_Static);\n    InsertArg(compilerGuardVar);\n\n    // insert compiler memory place holder\n    auto* compilerStorageVar = Variable(internalVarName,\n                                        ctx.getConstantArrayType(ctx.CharTy,\n                                                                 llvm::APInt(ctx.getTypeSize(ctx.getSizeType()), 0),\n                                                                 Sizeof(stmt->getType()),\n#if IS_CLANG_NEWER_THAN(17)\n#else\n                                                                 ArrayType::\n#endif\n                                                                 ArraySizeModifier::Normal,\n                                                                 0));\n\n    compilerStorageVar->setStorageClass(StorageClass::SC_Static);\n\n    auto* alignedAttr =\n        AlignedAttr::CreateImplicit(const_cast<ASTContext&>(ctx),\n                                    true,\n                                    Sizeof(stmt->getType()),  // ctx.getTrivialTypeSourceInfo(stmt->getType()),\n                                    {},\n                                    AlignedAttr::Spelling::Keyword_alignas);\n\n    compilerStorageVar->addAttr(alignedAttr);\n\n    const std::string typeName{GetName(stmt->getType())};\n    mOutputFormatHelper.AppendSemiNewLine(\n        \"alignas(\"sv, typeName, \") static char \"sv, internalVarName, \"[sizeof(\"sv, typeName, \")]\"sv);\n\n    // insert compiler init if\n    mOutputFormatHelper.AppendNewLine();\n\n    // try to find out whether this ctor or the CallExpr can throw. If, then additional code needs to be generated\n    // for exception handling.\n    const bool canThrow{[&] {\n        const ValueDecl* decl = [&]() -> const ValueDecl* {\n            const auto* init = stmt->getInit()->IgnoreCasts();\n            if(const auto* ctorExpr = dyn_cast_or_null<CXXConstructExpr>(init)) {\n                return ctorExpr->getConstructor();\n            } else if(const auto* callExpr = dyn_cast_or_null<CallExpr>(init)) {\n                return callExpr->getDirectCallee();\n            }\n\n            return nullptr;\n        }();\n\n        if(decl) {\n            if(const auto* func = decl->getType()->castAs<FunctionProtoType>()) {\n                return not func->isNothrow();\n            }\n        }\n\n        return false;\n    }()};\n\n    // VarDecl of a static expression always have an initializer\n    auto* init = const_cast<Expr*>(stmt->getInit());\n\n    if(const bool isCallExpr{not isa<CXXConstructExpr>(init->IgnoreCasts())}; isCallExpr) {\n        // we have a function call\n        init = Call(\"std::move\"sv, {init});\n\n        // Tests show that the compiler does better than std::move\n        EnableGlobalInsert(GlobalInserts::HeaderUtility);\n    }\n\n    // the allocation and guard update:\n    // new (&__s)T();\n    //  __sGuard = true;\n    auto type = stmt->getType();\n    type.removeLocalConst();  // Issue369.cpp is a const static variable. Should the ctor use the const?\n    SmallVector<Stmt*, 4> allocAndFlagBodyStmts{New({Ref(compilerStorageVar)}, init, type),\n                                                Assign(compilerGuardVar, Bool(true))};\n    auto                  allocAndFlagBodyCompound = mkCompoundStmt(allocAndFlagBodyStmts);\n\n    StmtsContainer innerBodyStmts{};\n\n    // Need to insert a try catch, if the constructor/initializer can throw\n    if(canThrow) {\n        innerBodyStmts.AddBodyStmts(\n            Try(allocAndFlagBodyCompound, Catch({Call(\"__cxa_guard_abort\"sv, {Ref(compilerGuardVar)}), Throw()})));\n    } else {\n        innerBodyStmts.AddBodyStmts(allocAndFlagBodyCompound);\n    }\n\n    StmtsContainer bodyStmts{};\n\n    if(threadSafe) {\n        innerBodyStmts.AddBodyStmts(Call(\"__cxa_guard_release\"sv, {Ref(compilerGuardVar)}));\n        innerBodyStmts.Add(Comment(\n            StrCat(\"__cxa_atexit(\"sv, typeName, \"::~\"sv, typeName, \", &\"sv, internalVarName, \", &__dso_handle);\"sv)));\n\n        auto* aquireIf = If(Call(\"__cxa_guard_acquire\"sv, {Ref(compilerGuardVar)}), innerBodyStmts);\n        bodyStmts.AddBodyStmts(aquireIf);\n    } else {\n        bodyStmts.AddBodyStmts(allocAndFlagBodyCompound);\n    }\n\n    InsertArg(If(Equal(And(compilerGuardVar, Int32(0xff)), Int32(0)), bodyStmts));\n}\n//-----------------------------------------------------------------------------\n\nstd::string_view CodeGenerator::GetBuiltinTypeSuffix(const BuiltinType::Kind& kind)\n{\n#define CASE(K, retVal)                                                                                                \\\n    case BuiltinType::K: return retVal\n    switch(kind) {\n        CASE(UInt, \"U\"sv);\n        CASE(ULong, \"UL\"sv);\n        CASE(ULongLong, \"ULL\"sv);\n        CASE(UInt128, \"ULLL\"sv);\n        CASE(Long, \"L\"sv);\n        CASE(LongLong, \"LL\"sv);\n        CASE(Float, \"F\"sv);\n        CASE(LongDouble, \"L\"sv);\n        default: return {};\n    }\n#undef BTCASE\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::HandleLambdaExpr(const LambdaExpr* lambda, LambdaHelper& lambdaHelper)\n{\n    OutputFormatHelper& outputFormatHelper = lambdaHelper.buffer();\n\n    outputFormatHelper.AppendNewLine();\n    LambdaCodeGenerator codeGenerator{outputFormatHelper, mLambdaStack, mProcessingPrimaryTemplate};\n    codeGenerator.mCapturedThisAsCopy = ranges::any_of(\n        lambda->captures(), [](auto& c) { return (c.capturesThis() and (c.getCaptureKind() == LCK_StarThis)); });\n\n    codeGenerator.mLambdaExpr = lambda;\n    codeGenerator.InsertArg(lambda->getLambdaClass());\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertConceptConstraint(const llvm::SmallVectorImpl<const Expr*>& constraints,\n                                            const InsertInline                        insertInline)\n{\n    for(OnceTrue first{}; const auto* c : constraints) {\n        if(first and (InsertInline::Yes == insertInline)) {\n            mOutputFormatHelper.Append(' ');\n        }\n\n        mOutputFormatHelper.Append(kwRequiresSpace);\n        InsertArg(c);\n\n        if(InsertInline::No == insertInline) {\n            mOutputFormatHelper.AppendNewLine();\n        }\n    }\n}\n//-----------------------------------------------------------------------------\n\n// This inserts the requires clause after template<...>\nvoid CodeGenerator::InsertConceptConstraint(const TemplateParameterList& tmplDecl)\n{\n    if(const auto* reqClause = tmplDecl.getRequiresClause()) {\n        SmallVector<const Expr*, 1> constraints{reqClause};\n\n        InsertConceptConstraint(constraints, InsertInline::No);\n    }\n}\n//-----------------------------------------------------------------------------\n\n// This inserts the requires clause after the function header\nvoid CodeGenerator::InsertConceptConstraint(const FunctionDecl* tmplDecl)\n{\n    SmallVector<const Expr*, 5> constraints{};\n    tmplDecl->getAssociatedConstraints(constraints);\n\n    InsertConceptConstraint(constraints, InsertInline::Yes);\n}\n//-----------------------------------------------------------------------------\n\n// This inserts the requires clause after a variable type\nvoid CodeGenerator::InsertConceptConstraint(const VarDecl* varDecl)\n{\n    if(const auto* t = varDecl->getType()->getContainedAutoType()) {\n        if(t->getTypeConstraintConcept()) {\n#if 0\n            mOutputFormatHelper.Append(kwCommentStart, t->getTypeConstraintConcept()->getName(), kwCCommentEndSpace);\n#endif\n        }\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertFunctionNameWithReturnType(const FunctionDecl&       decl,\n                                                     const CXXConstructorDecl* cxxInheritedCtorDecl)\n{\n    bool        isLambda{false};\n    bool        isFirstCxxMethodDecl{true};\n    const auto* methodDecl{dyn_cast_or_null<CXXMethodDecl>(&decl)};\n    bool        isCXXMethodDecl{nullptr != methodDecl};\n    const bool  isClassTemplateSpec{isCXXMethodDecl and isa<ClassTemplateSpecializationDecl>(methodDecl->getParent())};\n    const bool  requiresComment{isCXXMethodDecl and not methodDecl->isUserProvided() and\n                               not methodDecl->isExplicitlyDefaulted()};\n    // [expr.prim.lambda.closure] p7 consteval/constexpr are obtained from the call operator\n    const bool          isLambdaStaticInvoker{isCXXMethodDecl and methodDecl->isLambdaStaticInvoker()};\n    const FunctionDecl& constExprDecl{not isLambdaStaticInvoker ? decl\n                                                                : *methodDecl->getParent()->getLambdaCallOperator()};\n    const auto          desugaredReturnType = GetType(GetDesugarReturnType(decl));\n\n    if(methodDecl) {\n        if(requiresComment) {\n            mOutputFormatHelper.Append(kwCppCommentStartSpace);\n        }\n\n        isLambda             = methodDecl->getParent()->isLambda();\n        isFirstCxxMethodDecl = (nullptr == methodDecl->getPreviousDecl());\n    }\n\n    // types of conversion decls can be invalid to type at this place. So introduce a using\n    if(isa<CXXConversionDecl>(decl) and TypeContainsSubType<PointerType, FunctionProtoType>(desugaredReturnType)) {\n        mOutputFormatHelper.AppendSemiNewLine(\n            kwUsingSpace, BuildRetTypeName(decl), hlpAssing, GetName(desugaredReturnType));\n    }\n\n    if(isCXXMethodDecl and decl.isOutOfLine()) {\n        if(const auto* parent = methodDecl->getParent()) {\n            if(const auto* outerClasTemplateDecl = parent->getDescribedClassTemplate()) {\n                InsertTemplateParameters(*outerClasTemplateDecl->getTemplateParameters());\n            }\n        }\n    }\n\n    if(decl.isTemplated()) {\n        if(decl.getDescribedTemplate()) {\n            InsertTemplateParameters(*decl.getDescribedTemplate()->getTemplateParameters());\n        }\n\n    } else if(decl.isFunctionTemplateSpecialization() or (isClassTemplateSpec and decl.isOutOfLine() and\n                                                          (decl.getLexicalDeclContext() != methodDecl->getParent()))) {\n        InsertTemplateSpecializationHeader();\n    }\n\n    InsertAttributes(decl.attrs());\n\n    if(not decl.isFunctionTemplateSpecialization() or (isCXXMethodDecl and isFirstCxxMethodDecl)) {\n        if(not decl.isOutOfLine() or (decl.getStorageClass() == SC_Extern)) {\n            mOutputFormatHelper.Append(GetStorageClassAsStringWithSpace(decl.getStorageClass()));\n        }\n\n        // [class.free]: Any allocation function for a class T is a static member (even if not explicitly declared\n        // static). (https://eel.is/c++draft/class.free#1)\n        // However, Clang does not add `static` to `getStorageClass` so this needs to be check independently.\n        if(isCXXMethodDecl and not decl.isOutOfLine()) {\n            // GetStorageClassAsStringWithSpace already carries static, if the method was marked so explicitly\n            if((not IsStaticStorageClass(methodDecl)) and (methodDecl->isStatic())) {\n                mOutputFormatHelper.Append(kwStaticSpace);\n            }\n        }\n    }\n\n    if(Decl::FOK_None != decl.getFriendObjectKind()) {\n        mOutputFormatHelper.Append(kwFriendSpace);\n    }\n\n    if(decl.isInlined()) {\n        mOutputFormatHelper.Append(kwInlineSpace);\n    }\n\n    if(methodDecl and isFirstCxxMethodDecl) {\n        if(methodDecl->isVirtual()) {\n            mOutputFormatHelper.Append(kwVirtualSpace);\n        }\n\n        const auto exspec = ExplicitSpecifier::getFromDecl(methodDecl);\n\n        if(const auto* expr = exspec.getExpr()) {\n            mOutputFormatHelper.Append(kwExplicit);\n\n            WrapInParens(\n                [&] {\n                    switch(exspec.getKind()) {\n                        case ExplicitSpecKind::Unresolved: InsertArg(expr); break;\n                        case ExplicitSpecKind::ResolvedFalse: mOutputFormatHelper.Append(kwFalse); break;\n                        case ExplicitSpecKind::ResolvedTrue: mOutputFormatHelper.Append(\"true\"sv); break;\n                    }\n                },\n                AddSpaceAtTheEnd::Yes);\n\n        } else if(exspec.isExplicit()) {\n            mOutputFormatHelper.Append(kwExplicitSpace);\n        }\n    }\n\n    if(constExprDecl.isConstexpr()) {\n        const bool skipConstexpr{isLambda and not isa<CXXConversionDecl>(constExprDecl)};\n        // Special treatment for a conversion operator in a captureless lambda. It appears that if the call operator\n        // is consteval the conversion operator must be as well, otherwise it cannot take the address of the invoke\n        // function.\n        const bool isConversionOpWithConstevalCallOp{[&]() {\n            if(methodDecl) {\n                if(const auto callOp = methodDecl->getParent()->getLambdaCallOperator()) {\n                    return callOp->isConsteval();\n                }\n            }\n\n            return false;\n        }()};\n\n        if(not isConversionOpWithConstevalCallOp and constExprDecl.isConstexprSpecified()) {\n            if(skipConstexpr) {\n                mOutputFormatHelper.Append(kwCommentStart);\n            }\n\n            mOutputFormatHelper.Append(kwConstExprSpace);\n\n            if(skipConstexpr) {\n                mOutputFormatHelper.Append(kwCCommentEndSpace);\n            }\n\n        } else if(isConversionOpWithConstevalCallOp or constExprDecl.isConsteval()) {\n            mOutputFormatHelper.Append(kwConstEvalSpace);\n        }\n    }\n\n    // temporary output to be able to handle a return value of array reference\n    OutputFormatHelper outputFormatHelper{};\n\n    if(methodDecl) {\n        if(not isFirstCxxMethodDecl or InsertNamespace() and decl.getQualifier()) {\n            CodeGeneratorVariant cg{outputFormatHelper};\n            cg->InsertNamespace(decl.getQualifier());\n\n            // This comes from a using Base::SomeFunc\n        } else if(not isFirstCxxMethodDecl or InsertNamespace() and not decl.getQualifier()) {\n            const auto* parent = methodDecl->getParent();\n            outputFormatHelper.Append(parent->getName(), \"::\"sv);\n        }\n    }\n\n    if(not isa<CXXConversionDecl>(decl)) {\n        if(isa<CXXConstructorDecl>(decl) or isa<CXXDestructorDecl>(decl)) {\n            if(methodDecl) {\n                if(isa<CXXDestructorDecl>(decl)) {\n                    outputFormatHelper.Append('~');\n                }\n\n                outputFormatHelper.Append(GetName(*methodDecl->getParent()));\n            }\n\n        } else {\n            outputFormatHelper.Append(GetName(decl));\n        }\n\n        if(isFirstCxxMethodDecl and decl.isFunctionTemplateSpecialization()) {\n            CodeGeneratorVariant codeGenerator{outputFormatHelper};\n            codeGenerator->InsertTemplateArgs(decl);\n        }\n\n        outputFormatHelper.Append('(');\n    }\n\n    // if a CXXInheritedCtorDecl was passed as a pointer us this to get the parameters from.\n    if(cxxInheritedCtorDecl) {\n        outputFormatHelper.AppendParameterList(cxxInheritedCtorDecl->parameters(),\n                                               OutputFormatHelper::NameOnly::No,\n                                               OutputFormatHelper::GenMissingParamName::Yes);\n    } else {\n        // The static invoker needs parameter names to forward parameters to the call operator even when the call\n        // operator doesn't care about them.\n        const OutputFormatHelper::GenMissingParamName genMissingParamName{\n            isLambdaStaticInvoker ? OutputFormatHelper::GenMissingParamName::Yes\n                                  : OutputFormatHelper::GenMissingParamName::No};\n\n        outputFormatHelper.AppendParameterList(\n            decl.parameters(), OutputFormatHelper::NameOnly::No, genMissingParamName);\n\n        if(GetInsightsOptions().UseShow2C and not decl.isVariadic() and decl.param_empty()) {\n            outputFormatHelper.Append(\"void\"sv);\n        }\n    }\n\n    if(decl.isVariadic()) {\n        outputFormatHelper.Append(\", ...\"sv);\n    }\n\n    outputFormatHelper.Append(')');\n\n    if(not isa<CXXConstructorDecl>(decl) and not isa<CXXDestructorDecl>(decl)) {\n        if(isa<CXXConversionDecl>(decl)) {\n            const std::string typeName{TypeContainsSubType<PointerType, FunctionProtoType>(desugaredReturnType)\n                                           ? BuildRetTypeName(decl)\n                                           : GetName(desugaredReturnType)};\n\n            mOutputFormatHelper.Append(kwOperatorSpace, typeName, \" (\"sv, outputFormatHelper.GetString());\n        } else {\n            mOutputFormatHelper.Append(GetTypeNameAsParameter(desugaredReturnType, outputFormatHelper.GetString()));\n        }\n    } else {\n        mOutputFormatHelper.Append(outputFormatHelper);\n    }\n\n    mOutputFormatHelper.Append(GetConst(decl));\n\n    if(methodDecl) {\n        if(methodDecl->isVolatile()) {\n            mOutputFormatHelper.Append(kwSpaceVolatile);\n        }\n\n        if(methodDecl->hasAttr<FinalAttr>()) {\n            mOutputFormatHelper.Append(kwSpaceFinal);\n        }\n    }\n\n    switch(decl.getType()->getAs<FunctionProtoType>()->getRefQualifier()) {\n        case RQ_None: break;\n        case RQ_LValue: mOutputFormatHelper.Append(\" &\"sv); break;\n        case RQ_RValue: mOutputFormatHelper.Append(\" &&\"sv); break;\n    }\n\n    mOutputFormatHelper.Append(GetNoExcept(decl));\n\n    // insert the trailing requires-clause, if any. In case, this is a template then we already inserted the\n    // template requires-clause during creation of the template head.\n    InsertConceptConstraint(&decl);\n\n#if IS_CLANG_NEWER_THAN(17)\n    if(decl.isPureVirtual()) {\n#else\n    if(decl.isPure()) {\n#endif\n        mOutputFormatHelper.Append(\" = 0\"sv);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertCurlysIfRequired(const Stmt* stmt)\n{\n    const bool requiresCurlys{not isa<InitListExpr>(stmt) and not isa<ParenExpr>(stmt) and\n                              not isa<CXXDefaultInitExpr>(stmt)};\n\n    if(requiresCurlys) {\n        mOutputFormatHelper.Append('{');\n    }\n\n    InsertArg(stmt);\n\n    if(requiresCurlys) {\n        mOutputFormatHelper.Append('}');\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::WrapInParensOrCurlys(const BraceKind        braceKind,\n                                         void_func_ref          lambda,\n                                         const AddSpaceAtTheEnd addSpaceAtTheEnd)\n{\n    if(BraceKind::Curlys == braceKind) {\n        mOutputFormatHelper.Append('{');\n    } else {\n        mOutputFormatHelper.Append('(');\n    }\n\n    lambda();\n\n    if(BraceKind::Curlys == braceKind) {\n        mOutputFormatHelper.Append('}');\n    } else {\n        mOutputFormatHelper.Append(')');\n    }\n\n    if(AddSpaceAtTheEnd::Yes == addSpaceAtTheEnd) {\n        mOutputFormatHelper.Append(' ');\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::WrapInCompoundIfNeeded(const Stmt* stmt, const AddNewLineAfter addNewLineAfter)\n{\n    const bool hasNoCompoundStmt = not(isa<CompoundStmt>(stmt) or isa<AttributedStmt>(stmt));\n\n    if(hasNoCompoundStmt) {\n        mOutputFormatHelper.OpenScope();\n    }\n\n    if(not isa<NullStmt>(stmt)) {\n        InsertArg(stmt);\n\n        const bool isAttrWithCompound{[&] {\n            auto* attrStmt = dyn_cast_or_null<AttributedStmt>(stmt);\n            return attrStmt and isa<CompoundStmt>(attrStmt->getSubStmt());\n        }()};\n\n        // Add semi-colon if necessary. A do{} while does already add one.\n        if(IsStmtRequiringSemi<IfStmt, CompoundStmt, NullStmt, WhileStmt, DoStmt>(stmt) and not isAttrWithCompound) {\n            mOutputFormatHelper.AppendSemiNewLine();\n        }\n    }\n\n    if(hasNoCompoundStmt) {\n        mOutputFormatHelper.CloseScope(OutputFormatHelper::NoNewLineBefore::Yes);\n    }\n\n    const bool addNewLine = (AddNewLineAfter::Yes == addNewLineAfter);\n    if(addNewLine or (hasNoCompoundStmt and addNewLine)) {\n        mOutputFormatHelper.AppendNewLine();\n    } else if(not addNewLine or (hasNoCompoundStmt and not addNewLine)) {\n        mOutputFormatHelper.Append(' ');\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::WrapInParens(void_func_ref lambda, const AddSpaceAtTheEnd addSpaceAtTheEnd)\n{\n    WrapInParensOrCurlys(BraceKind::Parens, lambda, addSpaceAtTheEnd);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::WrapInParensIfNeeded(bool                   needsParens,\n                                         void_func_ref          lambda,\n                                         const AddSpaceAtTheEnd addSpaceAtTheEnd)\n{\n    if(needsParens) {\n        WrapInParensOrCurlys(BraceKind::Parens, lambda, addSpaceAtTheEnd);\n    } else {\n        lambda();\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::WrapInCurliesIfNeeded(bool                   needsParens,\n                                          void_func_ref          lambda,\n                                          const AddSpaceAtTheEnd addSpaceAtTheEnd)\n{\n    if(needsParens) {\n        WrapInParensOrCurlys(BraceKind::Curlys, lambda, addSpaceAtTheEnd);\n    } else {\n        lambda();\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::WrapInCurlys(void_func_ref lambda, const AddSpaceAtTheEnd addSpaceAtTheEnd)\n{\n    WrapInParensOrCurlys(BraceKind::Curlys, lambda, addSpaceAtTheEnd);\n}\n//-----------------------------------------------------------------------------\n\nvoid CodeGenerator::InsertArg(const BindingDecl*)\n{\n    // We ignore this here in the global level. In some cases a BindingDecl appears _before_ the DecompositionDecl\n    // which leads to invalid code. See StructuredBindingsHandler3Test.cpp.\n}\n//-----------------------------------------------------------------------------\n\nvoid StructuredBindingsCodeGenerator::InsertArg(const BindingDecl* stmt)\n{\n    const auto* bindingStmt = stmt->getBinding();\n\n    // In a dependent context we have no binding and with that no type. Leave this as it is, we are looking at a\n    // primary template here.\n    RETURN_IF(not bindingStmt);\n\n    // Assume that we are looking at a builtin type. We have to construct the variable declaration information.\n    auto type = stmt->getType();\n\n    // If we have a holding var we are looking at a user defined type like tuple and those the defaults from above\n    // are wrong. This type contains the variable declaration so we insert this.\n    if(const auto* holdingVar = stmt->getHoldingVar()) {\n        // Initial paper: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0144r0.pdf\n\n        // The type of the binding depends on the initializer. In case the initializer is an lvalue we get a T&,\n        // otherwise a T&&. We typically look at an lvalue if the decomposition declaration was auto& [a,b]. Note\n        // the & here We have a rvalue in case the decomposition declaration was auto [a,b]. Note no reference. The\n        // standard std::get returns a lvalue reference in case e in get(e) is an lvalue, otherwise it returns an\n        // rvalue reference because then the call is get(std::move(e))\n        type = holdingVar->getType().getCanonicalType();\n\n        bindingStmt = holdingVar->getAnyInitializer();\n\n    } else if(not type->isLValueReferenceType()) {\n        type = stmt->getASTContext().getLValueReferenceType(type);\n    }\n\n    mOutputFormatHelper.Append(GetQualifiers(*dyn_cast_or_null<VarDecl>(stmt->getDecomposedDecl())),\n                               GetTypeNameAsParameter(type, GetName(*stmt)),\n                               hlpAssing);\n\n    InsertArg(bindingStmt);\n\n    mOutputFormatHelper.AppendSemiNewLine();\n}\n//-----------------------------------------------------------------------------\n\nvoid StructuredBindingsCodeGenerator::InsertDecompositionBindings(const DecompositionDecl& decompositionDeclStmt)\n{\n    for(const auto* bindingDecl : decompositionDeclStmt.bindings()) {\n        InsertArg(bindingDecl);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid StructuredBindingsCodeGenerator::InsertArg(const DeclRefExpr* stmt)\n{\n    const auto name = GetName(*stmt);\n\n    mOutputFormatHelper.Append(name);\n\n    if(name.empty()) {\n        mOutputFormatHelper.Append(mVarName);\n    } else {\n        InsertTemplateArgs(*stmt);\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid LambdaCodeGenerator::InsertArg(const CXXThisExpr* stmt)\n{\n    DPrint(\"thisExpr: imlicit=%d %s\\n\", stmt->isImplicit(), GetName(GetDesugarType(stmt->getType())));\n\n    if(mCapturedThisAsCopy) {\n        mOutputFormatHelper.Append(\"(&\"sv, kwInternalThis, \")\"sv);\n\n    } else {\n        mOutputFormatHelper.Append(kwInternalThis);\n    }\n}\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n"
        },
        {
          "name": "CodeGenerator.h",
          "type": "blob",
          "size": 27.05078125,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#ifndef INSIGHTS_CODE_GENERATOR_H\n#define INSIGHTS_CODE_GENERATOR_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/Rewrite/Core/Rewriter.h\"\n#include \"llvm/ADT/APInt.h\"\n\n#include <optional>\n\n#include \"ClangCompat.h\"\n#include \"InsightsStaticStrings.h\"\n#include \"InsightsStrongTypes.h\"\n#include \"InsightsUtility.h\"\n#include \"OutputFormatHelper.h\"\n#include \"StackList.h\"\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n\nvoid PushVtableEntry(const CXXRecordDecl*, const CXXRecordDecl*, VarDecl* decl);\nint  GetGlobalVtablePos(const CXXRecordDecl*, const CXXRecordDecl*);\n\nclass CppInsightsCommentStmt : public Stmt\n{\n    std::string mComment{};\n\npublic:\n    CppInsightsCommentStmt(std::string_view comment)\n    : Stmt{NoStmtClass}\n    , mComment{comment}\n    {\n    }\n\n    std::string_view Comment() const { return mComment; }\n\n    static bool classof(const Stmt* T) { return T->getStmtClass() == NoStmtClass; }\n\n    child_range children()\n    {\n        static child_iterator iter{};\n        return {iter, iter};\n    }\n    const_child_range children() const\n    {\n        static const_child_iterator iter{};\n        return {iter, iter};\n    }\n};\n\nstruct LifetimeEntry\n{\n    STRONG_BOOL(FuncStart);\n\n    const VarDecl* item{};\n    FuncStart      funcStart{FuncStart::No};\n    int            scope{};\n};\n\nclass LifetimeTracker\n{\n    inline static int scopeCounter{};\n\n    SmallVector<LifetimeEntry, 10> objects{};\n\n    void InsertDtorCall(const VarDecl* decl, OutputFormatHelper& ofm);\n\npublic:\n    void Add(const VarDecl* decl);\n    void AddExtended(const VarDecl* decl, const ValueDecl* extending);\n\n    LifetimeEntry& top() { return objects.back(); }\n\n    void removeTop();\n    void StartScope(bool funcStart);\n    bool Return(OutputFormatHelper& ofm);\n    bool EndScope(OutputFormatHelper& ofm, bool clear);\n};\n\n/// \\brief More or less the heart of C++ Insights.\n///\n/// This is the place where nearly all of the transformations happen. This class knows the needed types and how to\n/// generated code from them.\nclass CodeGenerator\n{\nprotected:\n    LifetimeTracker mLifeTimeTracker{};\n    const Stmt*     mLastStmt{};\n    const Expr*     mLastExpr{};  // special case for assignments to class member\n\npublic:\n    const Decl* mLastDecl{};\n\nprotected:\n    bool mProcessingVarDecl{};\n    friend class CodeGeneratorVariant;\n\n    OutputFormatHelper& mOutputFormatHelper;\n\n    enum class LambdaCallerType\n    {\n        VarDecl,\n        InitCapture,\n        CallExpr,\n        OperatorCallExpr,\n        MemberCallExpr,\n        LambdaExpr,\n        ReturnStmt,\n        BinaryOperator,\n        CXXMethodDecl,\n        TemplateHead,\n        Decltype,\n    };\n\n    class LambdaHelper : public StackListEntry<LambdaHelper>\n    {\n    public:\n        LambdaHelper(const LambdaCallerType lambdaCallerType, OutputFormatHelper& outputFormatHelper)\n        : mLambdaCallerType{lambdaCallerType}\n        , mCurrentVarDeclPos{outputFormatHelper.CurrentPos()}\n        , mOutputFormatHelper{outputFormatHelper}\n        {\n            mLambdaOutputFormatHelper.SetIndent(mOutputFormatHelper);\n        }\n\n        void finish()\n        {\n            if(not mLambdaOutputFormatHelper.empty()) {\n                mOutputFormatHelper.InsertAt(mCurrentVarDeclPos, mLambdaOutputFormatHelper);\n            }\n        }\n\n        OutputFormatHelper& buffer() { return mLambdaOutputFormatHelper; }\n\n        std::string& inits() { return mInits; }\n\n        void insertInits(OutputFormatHelper& outputFormatHelper)\n        {\n            if(not mInits.empty()) {\n                outputFormatHelper.Append(mInits);\n                mInits.clear();\n            }\n        }\n\n        LambdaCallerType callerType() const { return mLambdaCallerType; }\n        bool             insertName() const { return (LambdaCallerType::Decltype != mLambdaCallerType) or mForceName; }\n\n        void setInsertName(bool b) { mForceName = b; }\n\n    private:\n        const LambdaCallerType mLambdaCallerType;\n        const size_t           mCurrentVarDeclPos;\n        OutputFormatHelper&    mOutputFormatHelper;\n        OutputFormatHelper     mLambdaOutputFormatHelper{};\n        std::string            mInits{};\n        bool                   mForceName{};\n    };\n    //-----------------------------------------------------------------------------\n\n    using LambdaStackType = StackList<class LambdaHelper>;\n\n    STRONG_BOOL(LambdaInInitCapture);  ///! Signal whether we are processing a lambda created and assigned to an init\n                                       /// capture of another lambda.\n\n    STRONG_BOOL(\n        ProcessingPrimaryTemplate);  ///! We do not want to transform a primary template which contains a Coroutine.\n\n    constexpr CodeGenerator(OutputFormatHelper&       _outputFormatHelper,\n                            LambdaStackType&          lambdaStack,\n                            LambdaInInitCapture       lambdaInitCapture,\n                            ProcessingPrimaryTemplate processingPrimaryTemplate)\n    : mOutputFormatHelper{_outputFormatHelper}\n    , mLambdaStack{lambdaStack}\n    , mLambdaInitCapture{lambdaInitCapture}\n    , mProcessingPrimaryTemplate{processingPrimaryTemplate}\n    {\n    }\n\npublic:\n    explicit constexpr CodeGenerator(OutputFormatHelper& _outputFormatHelper)\n    : CodeGenerator{_outputFormatHelper, mLambdaStackThis, ProcessingPrimaryTemplate::No}\n    {\n    }\n\n    constexpr CodeGenerator(OutputFormatHelper& _outputFormatHelper, LambdaInInitCapture lambdaInitCapture)\n    : CodeGenerator{_outputFormatHelper, mLambdaStackThis, lambdaInitCapture, ProcessingPrimaryTemplate::No}\n    {\n    }\n\n    constexpr CodeGenerator(OutputFormatHelper&       _outputFormatHelper,\n                            LambdaStackType&          lambdaStack,\n                            ProcessingPrimaryTemplate processingPrimaryTemplate)\n    : CodeGenerator{_outputFormatHelper, lambdaStack, LambdaInInitCapture::No, processingPrimaryTemplate}\n    {\n    }\n\n    virtual ~CodeGenerator() = default;\n\n#define IGNORED_DECL(type)                                                                                             \\\n    virtual void InsertArg(const type*) {}\n#define IGNORED_STMT(type)                                                                                             \\\n    virtual void InsertArg(const type*) {}\n#define SUPPORTED_DECL(type) virtual void InsertArg(const type* stmt);\n#define SUPPORTED_STMT(type) virtual void InsertArg(const type* stmt);\n\n#include \"CodeGeneratorTypes.h\"\n\n    virtual void InsertArg(const Decl* stmt);\n    virtual void InsertArg(const Stmt* stmt);\n\n    template<typename T>\n    void InsertTemplateArgs(const T& t)\n    {\n        if constexpr(std::is_same_v<T, FunctionDecl>) {\n            if(const auto* tmplArgs = t.getTemplateSpecializationArgs()) {\n                InsertTemplateArgs(*tmplArgs);\n            }\n        } else if constexpr(std::is_same_v<T, VarTemplateSpecializationDecl>) {\n            InsertTemplateArgs(t.getTemplateArgs());\n\n        } else if constexpr(requires { t.template_arguments(); }) {\n            if constexpr(std::is_same_v<DeclRefExpr, T>) {\n                if(0 == t.getNumTemplateArgs()) {\n                    return;\n                }\n            }\n\n            InsertTemplateArgs(t.template_arguments());\n\n        } else if constexpr(requires { t.asArray(); }) {\n            InsertTemplateArgs(t.asArray());\n        }\n    }\n\n    void InsertTemplateArgs(const ClassTemplateSpecializationDecl& clsTemplateSpe);\n\n    /// \\brief Insert the code for a FunctionDecl.\n    ///\n    /// This inserts the code of a FunctionDecl (and everything which is derived from one). It takes care of\n    /// CXXMethodDecl's access modifier as well as things like constexpr, noexcept, static and more.\n    ///\n    /// @param decl The FunctionDecl to process.\n    /// @param skipAccess Show or hide access modifiers (public, private, protected). The default is to show them.\n    /// @param cxxInheritedCtorDecl If not null, the type and name of this decl is used for the parameters.\n    void InsertFunctionNameWithReturnType(const FunctionDecl&       decl,\n                                          const CXXConstructorDecl* cxxInheritedCtorDecl = nullptr);\n\n    template<typename T>\n    void InsertTemplateArgs(const ArrayRef<T>& array)\n    {\n        mOutputFormatHelper.Append('<');\n\n        ForEachArg(array, [&](const auto& arg) { InsertTemplateArg(arg); });\n\n        /* put as space between to closing brackets: >> -> > > */\n        if(mOutputFormatHelper.GetString().back() == '>') {\n            mOutputFormatHelper.Append(' ');\n        }\n\n        mOutputFormatHelper.Append('>');\n    }\n\n    void InsertAttributes(const Decl*);\n    void InsertAttributes(const Decl::attr_range&);\n    void InsertAttribute(const Attr&);\n\n    void InsertTemplateArg(const TemplateArgument& arg);\n\n    STRONG_BOOL(TemplateParamsOnly);  ///! Skip template, type constraints and class/typename.\n    void InsertTemplateParameters(const TemplateParameterList& list,\n                                  const TemplateParamsOnly     templateParamsOnly = TemplateParamsOnly::No);\n\n    void StartLifetimeScope();\n    void LifetimeAddExtended(const VarDecl*, const ValueDecl*);\n    void EndLifetimeScope();\n\nprotected:\n    virtual bool InsertVarDecl(const VarDecl*) { return true; }\n    virtual bool SkipSpaceAfterVarDecl() { return false; }\n    virtual bool InsertComma() { return false; }\n    virtual bool InsertSemi() { return true; }\n    virtual bool InsertNamespace() const { return false; }\n\n    /// \\brief Show casts to xvalues independent from the show all casts option.\n    ///\n    /// This helps showing xvalue casts in structured bindings.\n    virtual bool ShowXValueCasts() const { return false; }\n\n    void HandleTemplateParameterPack(const ArrayRef<TemplateArgument>& args);\n    void HandleCompoundStmt(const CompoundStmt* stmt);\n    /// \\brief Show what is behind a local static variable.\n    ///\n    /// [stmt.dcl] p4: Initialization of a block-scope variable with static storage duration is thread-safe since C++11.\n    /// Regardless of that, as long as it is a non-trivally construct and destructable class the compiler adds code to\n    /// track the initialization state. Reference:\n    /// - www.opensource.apple.com/source/libcppabi/libcppabi-14/src/cxa_guard.cxx\n    void HandleLocalStaticNonTrivialClass(const VarDecl* stmt);\n\n    virtual void FormatCast(const std::string_view castName,\n                            const QualType&        CastDestType,\n                            const Expr*            SubExpr,\n                            const CastKind&        castKind);\n\n    void ForEachArg(const auto& arguments, auto&& lambda) { mOutputFormatHelper.ForEachArg(arguments, lambda); }\n\n    void InsertArgWithParensIfNeeded(const Stmt* stmt);\n    void InsertSuffix(const QualType& type);\n\n    void InsertTemplateArg(const TemplateArgumentLoc& arg) { InsertTemplateArg(arg.getArgument()); }\n    bool InsertLambdaStaticInvoker(const CXXMethodDecl* cxxMethodDecl);\n\n    STRONG_BOOL(InsertInline);\n\n    void InsertConceptConstraint(const llvm::SmallVectorImpl<const Expr*>& constraints,\n                                 const InsertInline                        insertInline);\n    void InsertConceptConstraint(const FunctionDecl* tmplDecl);\n    void InsertConceptConstraint(const VarDecl* varDecl);\n    void InsertConceptConstraint(const TemplateParameterList& tmplDecl);\n\n    void InsertTemplate(const FunctionTemplateDecl*, bool withSpec);\n\n    void InsertQualifierAndNameWithTemplateArgs(const DeclarationName& declName, const auto* stmt)\n    {\n        InsertQualifierAndName(declName, stmt->getQualifier(), stmt->hasTemplateKeyword());\n\n        if(stmt->getNumTemplateArgs()) {\n            InsertTemplateArgs(*stmt);\n        } else if(stmt->hasExplicitTemplateArgs()) {\n            // we have empty templates arguments, but angle brackets provided by the user\n            mOutputFormatHelper.Append(\"<>\"sv);\n        }\n    }\n\n    void InsertQualifierAndName(const DeclarationName&     declName,\n                                const NestedNameSpecifier* qualifier,\n                                const bool                 hasTemplateKeyword);\n\n    /// For a special case, when a LambdaExpr occurs in a Constructor from an\n    /// in class initializer, there is a need for a more narrow scope for the \\c LAMBDA_SCOPE_HELPER.\n    void InsertCXXMethodHeader(const CXXMethodDecl* stmt, OutputFormatHelper& initOutputFormatHelper);\n\n    void InsertTemplateGuardBegin(const FunctionDecl* stmt);\n    void InsertTemplateGuardEnd(const FunctionDecl* stmt);\n\n    /// \\brief Insert \\c template<> to introduce a template specialization.\n    void InsertTemplateSpecializationHeader() { mOutputFormatHelper.AppendNewLine(\"template<>\"sv); }\n\n    void InsertNamespace(const NestedNameSpecifier* namespaceSpecifier);\n    void ParseDeclContext(const DeclContext* Ctx);\n\n    STRONG_BOOL(SkipBody);\n    virtual void InsertCXXMethodDecl(const CXXMethodDecl* stmt, SkipBody skipBody);\n    void         InsertMethodBody(const FunctionDecl* stmt, const size_t posBeforeFunc);\n\n    /// \\brief Generalized function to insert either a \\c CXXConstructExpr or \\c CXXUnresolvedConstructExpr\n    template<typename T>\n    void InsertConstructorExpr(const T* stmt);\n\n    /// \\brief Check whether or not this statement will add curlys or parentheses and add them only if required.\n    void InsertCurlysIfRequired(const Stmt* stmt);\n\n    void InsertIfOrSwitchInitVariables(same_as_any_of<const IfStmt, const SwitchStmt> auto* stmt);\n\n    void InsertInstantiationPoint(const SourceManager& sm, const SourceLocation& instLoc, std::string_view text = {});\n\n    STRONG_BOOL(AddNewLineAfter);\n\n    void WrapInCompoundIfNeeded(const Stmt* stmt, const AddNewLineAfter addNewLineAfter);\n\n    STRONG_BOOL(AddSpaceAtTheEnd);\n\n    enum class BraceKind\n    {\n        Parens,\n        Curlys\n    };\n\n    void WrapInParens(void_func_ref lambda, const AddSpaceAtTheEnd addSpaceAtTheEnd = AddSpaceAtTheEnd::No);\n\n    void WrapInParensIfNeeded(bool                   needsParens,\n                              void_func_ref          lambda,\n                              const AddSpaceAtTheEnd addSpaceAtTheEnd = AddSpaceAtTheEnd::No);\n\n    void WrapInCurliesIfNeeded(bool                   needsParens,\n                               void_func_ref          lambda,\n                               const AddSpaceAtTheEnd addSpaceAtTheEnd = AddSpaceAtTheEnd::No);\n\n    void WrapInCurlys(void_func_ref lambda, const AddSpaceAtTheEnd addSpaceAtTheEnd = AddSpaceAtTheEnd::No);\n\n    void WrapInParensOrCurlys(const BraceKind        curlys,\n                              void_func_ref          lambda,\n                              const AddSpaceAtTheEnd addSpaceAtTheEnd = AddSpaceAtTheEnd::No);\n\n    void UpdateCurrentPos(std::optional<size_t>& pos) { pos = mOutputFormatHelper.CurrentPos(); }\n\n    static std::string_view GetBuiltinTypeSuffix(const BuiltinType::Kind& kind);\n\n    class LambdaScopeHandler\n    {\n    public:\n        LambdaScopeHandler(LambdaStackType&       stack,\n                           OutputFormatHelper&    outputFormatHelper,\n                           const LambdaCallerType lambdaCallerType);\n\n        ~LambdaScopeHandler();\n\n    private:\n        LambdaStackType& mStack;\n        LambdaHelper     mHelper;\n\n        OutputFormatHelper& GetBuffer(OutputFormatHelper& outputFormatHelper) const;\n    };\n\n    void               HandleLambdaExpr(const LambdaExpr* stmt, LambdaHelper& lambdaHelper);\n    static std::string FillConstantArray(const ConstantArrayType* ct, const std::string& value, const uint64_t startAt);\n    static std::string GetValueOfValueInit(const QualType& t);\n\n    bool InsideDecltype() const;\n\n    LambdaStackType  mLambdaStackThis;\n    LambdaStackType& mLambdaStack;\n\n    STRONG_BOOL(SkipVarDecl);\n    STRONG_BOOL(UseCommaInsteadOfSemi);\n    STRONG_BOOL(NoEmptyInitList);\n    STRONG_BOOL(ShowConstantExprValue);\n    LambdaInInitCapture mLambdaInitCapture{LambdaInInitCapture::No};\n\n    ShowConstantExprValue mShowConstantExprValue{ShowConstantExprValue::No};\n    SkipVarDecl           mSkipVarDecl{SkipVarDecl::No};\n    UseCommaInsteadOfSemi mUseCommaInsteadOfSemi{UseCommaInsteadOfSemi::No};\n    NoEmptyInitList       mNoEmptyInitList{\n        NoEmptyInitList::No};  //!< At least in case if a requires-clause containing T{} we don't want to get T{{}}.\n    const LambdaExpr*     mLambdaExpr{};\n    static constexpr auto MAX_FILL_VALUES_FOR_ARRAYS{\n        uint64_t{100}};  //!< This is the upper limit of elements which will be shown for an array when filled by \\c\n                         //!< FillConstantArray.\n    std::optional<size_t> mCurrentVarDeclPos{};   //!< The position in mOutputFormatHelper where a potential\n                                                  //!< std::initializer_list expansion must be inserted.\n    std::optional<size_t> mCurrentCallExprPos{};  //!< The position in mOutputFormatHelper where a potential\n                                                  //!< std::initializer_list expansion must be inserted.\n    std::optional<size_t> mCurrentReturnPos{};    //!< The position in mOutputFormatHelper from a return where a\n                                                  //!< potential std::initializer_list expansion must be inserted.\n    std::optional<size_t> mCurrentFieldPos{};     //!< The position in mOutputFormatHelper in a class where where a\n                                                  //!< potential std::initializer_list expansion must be inserted.\n    OutputFormatHelper* mOutputFormatHelperOutside{\n        nullptr};                        //!< Helper output buffer for std::initializer_list expansion.\n    bool mRequiresImplicitReturnZero{};  //!< Track whether this is a function with an imlpicit return 0.\n    bool mSkipSemi{};\n    ProcessingPrimaryTemplate mProcessingPrimaryTemplate{};\n};\n//-----------------------------------------------------------------------------\n\nclass LambdaCodeGenerator final : public CodeGenerator\n{\npublic:\n    using CodeGenerator::CodeGenerator;\n\n    using CodeGenerator::InsertArg;\n    void InsertArg(const CXXThisExpr* stmt) override;\n\n    bool mCapturedThisAsCopy{};\n};\n//-----------------------------------------------------------------------------\n\n/*\n * \\brief Special case to generate the inits of e.g. a \\c ForStmt.\n *\n * This class is a specialization to handle cases where we can have multiple init statements to the same variable and\n * hence need only one time the \\c VarDecl. An example a for-loops:\n\\code\nfor(int x=2, y=3, z=4; i < x; ++i) {}\n\\endcode\n */\nclass MultiStmtDeclCodeGenerator final : public CodeGenerator\n{\npublic:\n    explicit MultiStmtDeclCodeGenerator(OutputFormatHelper& _outputFormatHelper,\n                                        LambdaStackType&    lambdaStack,\n                                        bool                insertVarDecl)\n    : CodeGenerator{_outputFormatHelper, lambdaStack, ProcessingPrimaryTemplate::No}\n    , mInsertVarDecl{insertVarDecl}\n    , mInsertComma{}\n    {\n    }\n\n    // Insert the semi after the last declaration. This implies that this class always requires its own scope.\n    ~MultiStmtDeclCodeGenerator() { mOutputFormatHelper.Append(\"; \"sv); }\n\n    using CodeGenerator::InsertArg;\n\nprotected:\n    OnceTrue  mInsertVarDecl{};  //! Insert the \\c VarDecl only once.\n    OnceFalse mInsertComma{};    //! Insert the comma after we have generated the first \\c VarDecl and we are about to\n                                 //! insert another one.\n\n    bool InsertVarDecl(const VarDecl*) override { return mInsertVarDecl; }\n    bool InsertComma() override { return mInsertComma; }\n    bool InsertSemi() override { return false; }\n};\n//-----------------------------------------------------------------------------\n\nstruct CoroutineASTData\n{\n    CXXRecordDecl*                  mFrameType{};\n    FieldDecl*                      mResumeFnField{};\n    FieldDecl*                      mDestroyFnField{};\n    FieldDecl*                      mPromiseField{};\n    FieldDecl*                      mSuspendIndexField{};\n    FieldDecl*                      mInitialAwaitResumeCalledField{};\n    MemberExpr*                     mInitialAwaitResumeCalledAccess{};\n    DeclRefExpr*                    mFrameAccessDeclRef{};\n    MemberExpr*                     mSuspendIndexAccess{};\n    bool                            mDoInsertInDtor{};\n    std::vector<const CXXThisExpr*> mThisExprs{};\n};\n\n///\n/// \\brief A special generator for coroutines. It is only activated, if \\c -show-coroutines-transformation is given as a\n/// command line option.\nclass CoroutinesCodeGenerator final : public CodeGenerator\n{\npublic:\n    explicit CoroutinesCodeGenerator(OutputFormatHelper& _outputFormatHelper, const size_t posBeforeFunc)\n    : CoroutinesCodeGenerator{_outputFormatHelper, posBeforeFunc, {}, {}, {}}\n    {\n    }\n\n    explicit CoroutinesCodeGenerator(OutputFormatHelper& _outputFormatHelper,\n                                     const size_t        posBeforeFunc,\n                                     std::string_view    fsmName,\n                                     size_t              suspendsCount,\n                                     CoroutineASTData    data)\n    : CodeGenerator{_outputFormatHelper}\n    , mPosBeforeFunc{posBeforeFunc}\n    , mSuspendsCount{suspendsCount}\n    , mFSMName{fsmName}\n    , mASTData{data}\n    {\n    }\n\n    ~CoroutinesCodeGenerator() override;\n\n    using CodeGenerator::InsertArg;\n\n    void InsertArg(const ImplicitCastExpr* stmt) override;\n    void InsertArg(const CallExpr* stmt) override;\n    void InsertArg(const CXXRecordDecl* stmt) override;\n    void InsertArg(const OpaqueValueExpr* stmt) override;\n\n    void InsertArg(const CoroutineBodyStmt* stmt) override;\n    void InsertArg(const CoroutineSuspendExpr* stmt) override;\n    void InsertArg(const CoreturnStmt* stmt) override;\n\n    void InsertCoroutine(const FunctionDecl& fd, const CoroutineBodyStmt* body);\n\n    std::string GetFrameName() const { return mFrameName; }\n\nprotected:\n    bool InsertVarDecl(const VarDecl* vd) override { return mInsertVarDecl or (vd and vd->isStaticLocal()); }\n    bool SkipSpaceAfterVarDecl() override { return not mInsertVarDecl; }\n\nprivate:\n    enum class eState\n    {\n        Invalid,\n        InitialSuspend,\n        Body,\n        FinalSuspend,\n    };\n\n    eState                            mState{};\n    const size_t                      mPosBeforeFunc;\n    size_t                            mPosBeforeSuspendExpr{};\n    size_t                            mSuspendsCount{};\n    size_t                            mSuspendsCounter{};\n    bool                              mInsertVarDecl{true};\n    bool                              mSupressCasts{};\n    bool                              mSupressRecordDecls{};\n    std::string                       mFrameName{};\n    std::string                       mFSMName{};\n    CoroutineASTData                  mASTData{};\n    llvm::DenseMap<const Stmt*, bool> mBinaryExprs{};\n    static inline llvm::DenseMap<const Expr*, std::string>\n        mOpaqueValues{};  ///! Keeps track of the current set of opaque value\n\n    QualType GetFrameType() const { return QualType(mASTData.mFrameType->getTypeForDecl(), 0); }\n    QualType GetFramePointerType() const;\n\n    std::string BuildResumeLabelName(int) const;\n    FieldDecl*  AddField(std::string_view name, QualType type);\n\n    void InsertArgWithNull(const Stmt* stmt);\n};\n//-----------------------------------------------------------------------------\n\n///\n/// \\brief A special generator for coroutines. It is only activated, if \\c -show-coroutines-transformation is given as a\n/// command line option.\nclass CfrontCodeGenerator final : public CodeGenerator\n{\n    ///! A mapping for the pair method decl - derived-to-base-class to index in the vtable.\n    static inline llvm::DenseMap<std::pair<const Decl*, std::pair<const CXXRecordDecl*, const CXXRecordDecl*>>, int>\n         mVirtualFunctions{};\n    bool mInsertSemi{true};  // We need to for int* p = new{5};\n\npublic:\n    using CodeGenerator::CodeGenerator;\n\n    using CodeGenerator::InsertArg;\n\n    void InsertArg(const CXXThisExpr*) override;\n    void InsertArg(const CXXDeleteExpr*) override;\n    void InsertArg(const CXXNewExpr*) override;\n    void InsertArg(const CXXOperatorCallExpr*) override;\n    void InsertArg(const CXXNullPtrLiteralExpr*) override;\n    void InsertArg(const StaticAssertDecl*) override;\n    void InsertArg(const CXXRecordDecl*) override;\n    void InsertArg(const CXXMemberCallExpr*) override;\n    void InsertArg(const CXXConstructExpr*) override;\n    void InsertArg(const FunctionDecl* stmt) override;\n    void InsertArg(const TypedefDecl* stmt) override;\n\n    void InsertCXXMethodDecl(const CXXMethodDecl*, CodeGenerator::SkipBody) override;\n\n    void FormatCast(const std::string_view, const QualType&, const Expr*, const CastKind&) override;\n\n    struct CfrontVtableData\n    {\n        CfrontVtableData();\n\n        // struct __mptr *__ptbl_vec__c___src_C_[]\n        VarDecl*   VtblArrayVar(int size);\n        FieldDecl* VtblPtrField(const CXXRecordDecl* parent);\n\n        QualType vptpTypedef;  // typedef int (*__vptp)();\n\n        /*\nstruct __mptr\n{\n    short  d;\n    short  i;\n    __vptp f;\n};\n*/\n        CXXRecordDecl* vtableRecorDecl;\n        QualType       vtableRecordType;\n        FieldDecl*     d;\n        FieldDecl*     f;\n    };\n\n    static CfrontVtableData& VtableData();\n\nprotected:\n    bool InsertSemi() override { return std::exchange(mInsertSemi, true); }\n};\n//-----------------------------------------------------------------------------\n\n///\n/// \\brief A special container which creates either a \\c CodeGenerator or a \\c CfrontCodeGenerator depending on the\n/// command line options.\nclass CodeGeneratorVariant\n{\n    union CodeGenerators\n    {\n        CodeGenerator       cg;\n        CfrontCodeGenerator cfcg;\n\n        CodeGenerators(OutputFormatHelper&                      _outputFormatHelper,\n                       CodeGenerator::LambdaStackType&          lambdaStack,\n                       CodeGenerator::ProcessingPrimaryTemplate processingPrimaryTemplate);\n        CodeGenerators(OutputFormatHelper& _outputFormatHelper, CodeGenerator::LambdaInInitCapture lambdaInitCapture);\n\n        ~CodeGenerators();\n    } cgs;\n\n    CodeGenerator*      cg;\n    OutputFormatHelper& ofm;\n\n    void Set();\n\npublic:\n    CodeGeneratorVariant(OutputFormatHelper& _outputFormatHelper)\n    : CodeGeneratorVariant{_outputFormatHelper, CodeGenerator::LambdaInInitCapture::No}\n    {\n    }\n\n    CodeGeneratorVariant(OutputFormatHelper&                      _outputFormatHelper,\n                         CodeGenerator::LambdaStackType&          lambdaStack,\n                         CodeGenerator::ProcessingPrimaryTemplate processingPrimaryTemplate)\n    : cgs{_outputFormatHelper, lambdaStack, processingPrimaryTemplate}\n    , ofm{_outputFormatHelper}\n    , cg{}\n    {\n        Set();\n    }\n\n    CodeGeneratorVariant(OutputFormatHelper& _outputFormatHelper, CodeGenerator::LambdaInInitCapture lambdaInitCapture)\n    : cgs{_outputFormatHelper, lambdaInitCapture}\n    , ofm{_outputFormatHelper}\n    , cg{}\n    {\n        Set();\n    }\n\n    CodeGenerator* operator->() { return cg; }\n};\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n\n#endif /* INSIGHTS_CODE_GENERATOR_H */\n"
        },
        {
          "name": "CodeGeneratorTypes.h",
          "type": "blob",
          "size": 4.013671875,
          "content": "#ifndef IGNORED_DECL\n#define IGNORED_DECL(type)\n#endif\n\n#ifndef IGNORED_STMT\n#define IGNORED_STMT(type)\n#endif\n\n#ifndef SUPPORTED_DECL\n#define SUPPORTED_DECL(type)\n#endif\n\n#ifndef SUPPORTED_STMT\n#define SUPPORTED_STMT(type)\n#endif\n\nIGNORED_STMT(OMPOrderedDirective)\nIGNORED_STMT(OMPParallelForDirective)\n\nIGNORED_DECL(UsingShadowDecl)\nIGNORED_DECL(UsingPackDecl)\nIGNORED_DECL(EmptyDecl)  // stray semicolon?\n\nSUPPORTED_DECL(BindingDecl)\nSUPPORTED_DECL(CXXDeductionGuideDecl)\nSUPPORTED_DECL(VarDecl)\nSUPPORTED_DECL(TypeAliasDecl)\nSUPPORTED_DECL(TypedefDecl)\nSUPPORTED_DECL(StaticAssertDecl)\nSUPPORTED_DECL(FieldDecl)\nSUPPORTED_DECL(AccessSpecDecl)\nSUPPORTED_DECL(CXXMethodDecl)\nSUPPORTED_DECL(UsingDecl)\nSUPPORTED_DECL(CXXRecordDecl)\nSUPPORTED_DECL(FunctionDecl)\nSUPPORTED_DECL(UsingDirectiveDecl)\nSUPPORTED_DECL(FriendDecl)\nSUPPORTED_DECL(EnumDecl)\nSUPPORTED_DECL(EnumConstantDecl)\nSUPPORTED_DECL(NamespaceAliasDecl)\nSUPPORTED_DECL(FunctionTemplateDecl)\nSUPPORTED_DECL(TypeAliasTemplateDecl)\nSUPPORTED_DECL(LabelDecl)\nSUPPORTED_DECL(ClassTemplateDecl)\nSUPPORTED_DECL(NamespaceDecl)\nSUPPORTED_DECL(VarTemplateDecl)\nSUPPORTED_DECL(ConceptDecl)\nSUPPORTED_DECL(UnresolvedUsingValueDecl)\nSUPPORTED_DECL(LinkageSpecDecl)\n\nSUPPORTED_STMT(CXXDeleteExpr)\nSUPPORTED_STMT(CXXDefaultInitExpr)\nSUPPORTED_STMT(MemberExpr)\nSUPPORTED_STMT(IntegerLiteral)\nSUPPORTED_STMT(StringLiteral)\nSUPPORTED_STMT(FloatingLiteral)\nSUPPORTED_STMT(CXXOperatorCallExpr)\nSUPPORTED_STMT(ParenExpr)\nSUPPORTED_STMT(UnaryOperator)\nSUPPORTED_STMT(LambdaExpr)\nSUPPORTED_STMT(CXXMemberCallExpr)\nSUPPORTED_STMT(CXXThisExpr)\nSUPPORTED_STMT(CXXConstructExpr)\nSUPPORTED_STMT(CXXInheritedCtorInitExpr)\nSUPPORTED_STMT(CompoundAssignOperator)\nSUPPORTED_STMT(BinaryOperator)\nSUPPORTED_STMT(CXXNamedCastExpr)\nSUPPORTED_STMT(CXXFunctionalCastExpr)\nSUPPORTED_STMT(ImplicitCastExpr)\nSUPPORTED_STMT(UnaryExprOrTypeTraitExpr)\nSUPPORTED_STMT(ConditionalOperator)\nSUPPORTED_STMT(MaterializeTemporaryExpr)\nSUPPORTED_STMT(CXXBindTemporaryExpr)\nSUPPORTED_STMT(DeclRefExpr)\nSUPPORTED_STMT(CallExpr)\nSUPPORTED_STMT(CXXBoolLiteralExpr)\nSUPPORTED_STMT(CXXTypeidExpr)\nSUPPORTED_STMT(GNUNullExpr)\nSUPPORTED_STMT(CharacterLiteral)\nSUPPORTED_STMT(ArraySubscriptExpr)\nSUPPORTED_STMT(PredefinedExpr)\nSUPPORTED_STMT(ExprWithCleanups)\nSUPPORTED_STMT(InitListExpr)\nSUPPORTED_STMT(DeclStmt)\nSUPPORTED_STMT(CompoundStmt)\nSUPPORTED_STMT(IfStmt)\nSUPPORTED_STMT(SubstNonTypeTemplateParmExpr)\nSUPPORTED_STMT(ReturnStmt)\nSUPPORTED_STMT(NullStmt)\nSUPPORTED_STMT(CXXDefaultArgExpr)\nSUPPORTED_STMT(CXXStdInitializerListExpr)\nSUPPORTED_STMT(CStyleCastExpr)\nSUPPORTED_STMT(ForStmt)\nSUPPORTED_STMT(CXXNewExpr)\nSUPPORTED_STMT(CXXNullPtrLiteralExpr)\nSUPPORTED_STMT(ArrayInitLoopExpr)\nSUPPORTED_STMT(OpaqueValueExpr)\nSUPPORTED_STMT(WhileStmt)\nSUPPORTED_STMT(SwitchStmt)\nSUPPORTED_STMT(CaseStmt)\nSUPPORTED_STMT(BreakStmt)\nSUPPORTED_STMT(DefaultStmt)\nSUPPORTED_STMT(ContinueStmt)\nSUPPORTED_STMT(GotoStmt)\nSUPPORTED_STMT(LabelStmt)\nSUPPORTED_STMT(CXXForRangeStmt)\nSUPPORTED_STMT(DoStmt)\nSUPPORTED_STMT(ArrayInitIndexExpr)\nSUPPORTED_STMT(UnresolvedLookupExpr)\nSUPPORTED_STMT(ImplicitValueInitExpr)\nSUPPORTED_STMT(CXXScalarValueInitExpr)\nSUPPORTED_STMT(CXXTryStmt)\nSUPPORTED_STMT(CXXCatchStmt)\nSUPPORTED_STMT(CXXThrowExpr)\nSUPPORTED_STMT(CXXDependentScopeMemberExpr)\nSUPPORTED_STMT(CXXNoexceptExpr)\nSUPPORTED_STMT(ParenListExpr)\nSUPPORTED_STMT(SizeOfPackExpr)\n// SUPPORTED_STMT(ParenListExpr)\nSUPPORTED_STMT(ConstantExpr)\nSUPPORTED_STMT(CXXUnresolvedConstructExpr)\nSUPPORTED_STMT(UnresolvedMemberExpr)\nSUPPORTED_STMT(PackExpansionExpr)\nSUPPORTED_STMT(CXXFoldExpr)\nSUPPORTED_STMT(CoroutineBodyStmt)\nSUPPORTED_STMT(CoroutineSuspendExpr)\nSUPPORTED_STMT(DependentCoawaitExpr)\nSUPPORTED_STMT(CoreturnStmt)\nSUPPORTED_STMT(DependentScopeDeclRefExpr)\nSUPPORTED_STMT(CXXRewrittenBinaryOperator)\nSUPPORTED_STMT(AttributedStmt)\nSUPPORTED_STMT(ConceptSpecializationExpr)\nSUPPORTED_STMT(RequiresExpr)\nSUPPORTED_STMT(StmtExpr)\nSUPPORTED_STMT(SourceLocExpr)\nSUPPORTED_STMT(CXXParenListInitExpr)\nSUPPORTED_STMT(CppInsightsCommentStmt)\n\n#undef IGNORED_DECL\n#undef IGNORED_STMT\n#undef SUPPORTED_DECL\n#undef SUPPORTED_STMT\n"
        },
        {
          "name": "Coroutines.md",
          "type": "blob",
          "size": 0.89453125,
          "content": "##Resources\n\nHere are a couple of resources I used during the development of the educational Coroutines transformation.\n\n- https://chromium.googlesource.com/external/github.com/llvm-mirror/clang/+/refs/heads/master/test/CodeGenCoroutines/coro-builtins.c\n- https://stackoverflow.com/questions/67923082/llvm-ir-for-coroutines-not-properly-lowered-by-opt\n- https://llvm.org/docs/Coroutines.html\n- https://gcc.gnu.org/legacy-ml/gcc-patches/2020-01/msg01096.html\n- https://devblogs.microsoft.com/oldnewthing/20210331-00/?p=105028\n- https://wiki.tum.de/download/attachments/93291100/Kolb%20report%20-%20Coroutines%20in%20C%2B%2B20.pdf?version=1&modificationDate=1532345204090&api=v2\n- https://llvm.org/devmtg/2016-11/Slides/Nishanov-LLVMCoroutines.pdf\n- https://www.youtube.com/watch?v=Ztr8QvMhqmQ\n- https://blog.panicsoftware.com/your-first-coroutine/\n- http://divine.fi.muni.cz/current/clang/lib/CodeGen/CGCoroutine.cpp\n"
        },
        {
          "name": "CoroutinesCodeGenerator.cpp",
          "type": "blob",
          "size": 37.15234375,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#include <iterator>\n#include <optional>\n#include <vector>\n#include \"ASTHelpers.h\"\n#include \"CodeGenerator.h\"\n#include \"DPrint.h\"\n#include \"Insights.h\"\n#include \"InsightsHelpers.h\"\n#include \"NumberIterator.h\"\n\n#include <algorithm>\n//-----------------------------------------------------------------------------\n\nnamespace ranges = std::ranges;\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n\nconstexpr std::string_view CORO_FRAME_NAME{\"__f\"sv};\nconst std::string          CORO_FRAME_ACCESS{StrCat(CORO_FRAME_NAME, \"->\"sv)};\nconst std::string          CORO_FRAME_ACCESS_THIS{StrCat(CORO_FRAME_ACCESS, kwInternalThis)};\nconst std::string          SUSPEND_INDEX_NAME{BuildInternalVarName(\"suspend_index\"sv)};\nconst std::string          INITIAL_AWAIT_SUSPEND_CALLED_NAME{BuildInternalVarName(\"initial_await_suspend_called\"sv)};\nconst std::string          RESUME_LABEL_PREFIX{BuildInternalVarName(\"resume\"sv)};\nconst std::string          FINAL_SUSPEND_NAME{BuildInternalVarName(\"final_suspend\"sv)};\n//-----------------------------------------------------------------------------\n\nusing namespace asthelpers;\n//-----------------------------------------------------------------------------\n\nQualType CoroutinesCodeGenerator::GetFramePointerType() const\n{\n    return Ptr(GetFrameType());\n}\n//-----------------------------------------------------------------------------\n\nCoroutinesCodeGenerator::~CoroutinesCodeGenerator()\n{\n    RETURN_IF(not(mASTData.mFrameType and mASTData.mDoInsertInDtor));\n\n    mASTData.mFrameType->completeDefinition();\n\n    OutputFormatHelper ofm{};\n\n    // Using the \"normal\" CodeGenerator here as this is only about inserting the made up coroutine-frame.\n    CodeGeneratorVariant codeGenerator{ofm};\n    codeGenerator->InsertArg(mASTData.mFrameType);\n\n    // Insert the made-up struct before the function declaration\n    mOutputFormatHelper.InsertAt(mPosBeforeFunc, ofm);\n}\n//-----------------------------------------------------------------------------\n\nstatic FieldDecl* AddField(CoroutineASTData& astData, std::string_view name, QualType type)\n{\n    if(nullptr == astData.mFrameType) {\n        return nullptr;\n    }\n\n    auto* fieldDecl = mkFieldDecl(astData.mFrameType, name, type);\n\n    astData.mFrameType->addDecl(fieldDecl);\n\n    return fieldDecl;\n}\n//-----------------------------------------------------------------------------\n\nFieldDecl* CoroutinesCodeGenerator::AddField(std::string_view name, QualType type)\n{\n    return ::clang::insights::AddField(mASTData, name, type);\n}\n//-----------------------------------------------------------------------------\n\nstatic auto* CreateCoroFunctionDecl(std::string funcName, QualType type)\n{\n    params_vector     params{{CORO_FRAME_NAME, type}};\n    const std::string coroFsmName{BuildInternalVarName(funcName)};\n\n    return Function(coroFsmName, VoidTy(), params);\n}\n//-----------------------------------------------------------------------------\n\nstatic void SetFunctionBody(FunctionDecl* fd, StmtsContainer& bodyStmts)\n{\n    fd->setBody(mkCompoundStmt(bodyStmts));\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string BuildSuspendVarName(const OpaqueValueExpr* stmt)\n{\n    return BuildInternalVarName(\n        MakeLineColumnName(GetGlobalAST().getSourceManager(), stmt->getSourceExpr()->getBeginLoc(), \"suspend_\"sv));\n}\n//-----------------------------------------------------------------------------\n\n/// \\brief Find a \\c SuspendsExpr's in a coroutine body statement for early transformation.\n///\n/// Traverse the whole CoroutineBodyStmt to find all appearing \\c VarDecl. These need to be rerouted to the\n/// coroutine frame and hence prefixed by something like __f->. For that reason we only look for \\c VarDecls\n/// directly appearing in the body, \\c CallExpr will be skipped.\nclass CoroutineASTTransformer : public StmtVisitor<CoroutineASTTransformer>\n{\n    StmtsContainer                        mBodyStmts{};\n    Stmt*                                 mPrevStmt{};  // used to insert the suspendexpr\n    CoroutineASTData&                     mASTData;\n    Stmt*                                 mStaged{};\n    bool                                  mSkip{};\n    size_t&                               mSuspendsCount;\n    llvm::DenseMap<VarDecl*, MemberExpr*> mVarNamePrefix{};\n\npublic:\n    CoroutineASTTransformer(CoroutineASTData&                     coroutineASTData,\n                            size_t&                               suspendsCounter,\n                            Stmt*                                 stmt,\n                            llvm::DenseMap<VarDecl*, MemberExpr*> varNamePrefix,\n                            Stmt*                                 prev = nullptr)\n    : mPrevStmt{prev}\n    , mASTData{coroutineASTData}\n    , mSuspendsCount{suspendsCounter}\n    , mVarNamePrefix{varNamePrefix}\n    {\n        if(nullptr == mPrevStmt) {\n            mPrevStmt = stmt;\n        }\n\n        Visit(stmt);\n    }\n\n    void Visit(Stmt* stmt)\n    {\n        if(stmt) {\n            StmtVisitor<CoroutineASTTransformer>::Visit(stmt);\n        }\n    }\n\n    void VisitCompoundStmt(CompoundStmt* stmt)\n    {\n        for(auto* child : stmt->body()) {\n            mStaged = child;\n            Visit(child);\n\n            if(not mSkip) {\n                mBodyStmts.Add(child);\n            }\n\n            mSkip = false;\n        }\n\n        auto* comp = mkCompoundStmt(mBodyStmts);\n\n        ReplaceNode(mPrevStmt, stmt, comp);\n\n        mBodyStmts.clear();\n    }\n\n    void VisitSwitchStmt(SwitchStmt* stmt)\n    {\n        Visit(stmt->getCond());\n\n        CoroutineASTTransformer{mASTData, mSuspendsCount, stmt->getBody(), mVarNamePrefix, stmt};\n    }\n\n    void VisitDoStmt(DoStmt* stmt)\n    {\n        Visit(stmt->getCond());\n\n        CoroutineASTTransformer{mASTData, mSuspendsCount, stmt->getBody(), mVarNamePrefix, stmt};\n    }\n\n    void VisitWhileStmt(WhileStmt* stmt)\n    {\n        Visit(stmt->getCond());\n\n        CoroutineASTTransformer{mASTData, mSuspendsCount, stmt->getBody(), mVarNamePrefix, stmt};\n    }\n\n    void VisitIfStmt(IfStmt* stmt)\n    {\n        Visit(stmt->getCond());\n\n        CoroutineASTTransformer{mASTData, mSuspendsCount, stmt->getThen(), mVarNamePrefix, stmt};\n\n        CoroutineASTTransformer{mASTData, mSuspendsCount, stmt->getElse(), mVarNamePrefix, stmt};\n    }\n\n    void VisitForStmt(ForStmt* stmt)\n    {\n        // technically because of the init the entire for loop should be put into a dedicated scope\n        Visit(stmt->getInit());\n\n        // Special case. A VarDecl in init will be added to the body of the function and the actual init is left\n        // untouched. Work some magic to put it in the right place.\n        if(mSkip) {\n            auto* oldInit = stmt->getInit();\n            auto* newInit = mBodyStmts.mStmts.back();\n            mBodyStmts.mStmts.pop_back();\n\n            ReplaceNode(stmt, oldInit, newInit);\n\n            mSkip = false;\n        }\n\n        Visit(stmt->getCond());\n\n        Visit(stmt->getInc());\n\n        CoroutineASTTransformer{mASTData, mSuspendsCount, stmt->getBody(), mVarNamePrefix, stmt};\n\n        mSkip = false;\n    }\n\n    void VisitCXXForRangeStmt(CXXForRangeStmt* stmt)\n    {\n        Visit(stmt->getRangeStmt());\n\n        // ignoring the loop variable should be fine.\n\n        CoroutineASTTransformer{mASTData, mSuspendsCount, stmt->getBody(), mVarNamePrefix, stmt};\n    }\n\n    void VisitDeclRefExpr(DeclRefExpr* stmt)\n    {\n        if(auto* vd = dyn_cast_or_null<VarDecl>(stmt->getDecl())) {\n            RETURN_IF(not vd->isLocalVarDeclOrParm() or vd->isStaticLocal() or not Contains(mVarNamePrefix, vd));\n\n            auto* memberExpr = mVarNamePrefix[vd];\n\n            ReplaceNode(mPrevStmt, stmt, memberExpr);\n        }\n    }\n\n    void VisitDeclStmt(DeclStmt* stmt)\n    {\n        for(auto* decl : stmt->decls()) {\n            if(auto* varDecl = dyn_cast_or_null<VarDecl>(decl)) {\n                if(varDecl->isStaticLocal()) {\n                    continue;\n                }\n\n                // add this point a placement-new would be appropriate for at least some cases.\n\n                auto* field  = AddField(mASTData, GetName(*varDecl), varDecl->getType());\n                auto* me     = AccessMember(mASTData.mFrameAccessDeclRef, field);\n                auto* assign = Assign(me, field, varDecl->getInit());\n\n                mVarNamePrefix.insert(std::make_pair(varDecl, me));\n\n                Visit(varDecl->getInit());\n\n                mSkip = true;\n                mBodyStmts.Add(assign);\n\n            } else if(const auto* recordDecl = dyn_cast_or_null<CXXRecordDecl>(decl)) {\n                mASTData.mFrameType->addDecl(const_cast<CXXRecordDecl*>(recordDecl));\n            }\n        }\n    }\n\n    void VisitCXXThisExpr(CXXThisExpr* stmt)\n    {\n        auto* fieldDecl              = mkFieldDecl(mASTData.mFrameType, kwInternalThis, stmt->getType());\n        auto* indirectThisMemberExpr = AccessMember(mASTData.mFrameAccessDeclRef, fieldDecl);\n\n        ReplaceNode(mPrevStmt, stmt, indirectThisMemberExpr);\n\n        if(0 == mASTData.mThisExprs.size()) {\n            mASTData.mThisExprs.push_back(stmt);\n        }\n    }\n\n    void VisitCallExpr(CallExpr* stmt)\n    {\n        auto* tmp = mPrevStmt;\n        mPrevStmt = stmt;\n\n        for(auto* arg : stmt->arguments()) {\n            Visit(arg);\n        }\n\n        mPrevStmt = tmp;\n    }\n\n    void VisitCXXMemberCallExpr(CXXMemberCallExpr* stmt)\n    {\n        auto* tmp = mPrevStmt;\n        mPrevStmt = stmt->getCallee();\n\n        Visit(stmt->getCallee());\n\n        mPrevStmt = tmp;\n\n        StmtVisitor<CoroutineASTTransformer>::VisitCXXMemberCallExpr(stmt);\n    }\n\n    void VisitCoreturnStmt(CoreturnStmt* stmt)\n    {\n        Visit(stmt->getOperand());\n        Visit(stmt->getPromiseCall());\n    }\n\n    void VisitCoyieldExpr(CoyieldExpr* stmt)\n    {\n        ++mSuspendsCount;\n\n        if(isa<ExprWithCleanups>(mStaged)) {\n            mBodyStmts.Add(stmt);\n            mSkip = true;\n        }\n\n        Visit(stmt->getOperand());\n    }\n\n    void VisitCoawaitExpr(CoawaitExpr* stmt)\n    {\n        ++mSuspendsCount;\n\n        if(const bool returnsVoid{stmt->getResumeExpr()->getType()->isVoidType()}; returnsVoid) {\n            Visit(stmt->getOperand());\n\n            // in the void return case there is nothing to do, because this expression (potentially) is not nested.\n            return;\n        }\n\n        mBodyStmts.Add(stmt);\n\n        // Note: Add the this pointer to the name isn't the best but s quick approach\n        const std::string name{StrCat(CORO_FRAME_ACCESS, BuildSuspendVarName(stmt->getOpaqueValue()), \"_res\"sv)};\n\n        auto* resultVar        = Variable(name, stmt->getType());\n        auto* resultVarDeclRef = mkDeclRefExpr(resultVar);\n\n        ReplaceNode(mPrevStmt, stmt, resultVarDeclRef);\n\n        Visit(stmt->getCommonExpr());\n        Visit(stmt->getOperand());\n        Visit(stmt->getSuspendExpr());\n        Visit(stmt->getReadyExpr());\n        Visit(stmt->getResumeExpr());\n    }\n\n    void VisitCoroutineBodyStmt(CoroutineBodyStmt* stmt)\n    {\n        auto* varDecl = stmt->getPromiseDecl();\n\n        mASTData.mPromiseField = AddField(mASTData, GetName(*varDecl), varDecl->getType());\n        auto* me               = AccessMember(mASTData.mFrameAccessDeclRef, mASTData.mPromiseField);\n\n        mVarNamePrefix.insert(std::make_pair(varDecl, me));\n\n        auto& ctx = GetGlobalAST();\n\n        // add the suspend index variable\n        mASTData.mSuspendIndexField  = AddField(mASTData, SUSPEND_INDEX_NAME, ctx.IntTy);\n        mASTData.mSuspendIndexAccess = AccessMember(mASTData.mFrameAccessDeclRef, mASTData.mSuspendIndexField);\n\n        // https://timsong-cpp.github.io/cppwp/n4861/dcl.fct.def.coroutine#5.3\n        mASTData.mInitialAwaitResumeCalledField = AddField(mASTData, INITIAL_AWAIT_SUSPEND_CALLED_NAME, ctx.BoolTy);\n        mASTData.mInitialAwaitResumeCalledAccess =\n            AccessMember(mASTData.mFrameAccessDeclRef, mASTData.mInitialAwaitResumeCalledField);\n\n        for(auto* param : stmt->getParamMoves()) {\n            if(auto* declStmt = dyn_cast_or_null<DeclStmt>(param)) {\n                if(auto* varDecl2 = dyn_cast_or_null<VarDecl>(declStmt->getSingleDecl())) {\n                    //  For the captured parameters we need to find the ParmVarDecl instead of the newly created VarDecl\n                    if(auto* declRef = FindDeclRef(varDecl2->getAnyInitializer())) {\n                        auto* varDecl = dyn_cast<ParmVarDecl>(declRef->getDecl());\n\n                        auto* field = AddField(mASTData, GetName(*varDecl), varDecl->getType());\n                        auto* me    = AccessMember(mASTData.mFrameAccessDeclRef, field);\n\n                        mVarNamePrefix.insert(std::make_pair(const_cast<ParmVarDecl*>(varDecl), me));\n                    }\n                }\n            }\n        }\n\n        Visit(stmt->getBody());\n\n        Visit(stmt->getReturnStmt());\n        Visit(stmt->getReturnValue());\n        Visit(stmt->getReturnValueInit());\n        Visit(stmt->getExceptionHandler());\n        Visit(stmt->getReturnStmtOnAllocFailure());\n        Visit(stmt->getFallthroughHandler());\n        Visit(stmt->getInitSuspendStmt());\n        Visit(stmt->getFinalSuspendStmt());\n    }\n\n    void VisitStmt(Stmt* stmt)\n    {\n        auto* tmp = mPrevStmt;\n        mPrevStmt = stmt;\n\n        for(auto* child : stmt->children()) {\n            Visit(child);\n        }\n\n        mPrevStmt = tmp;\n    }\n};\n//-----------------------------------------------------------------------------\n\nvoid CoroutinesCodeGenerator::InsertCoroutine(const FunctionDecl& fd, const CoroutineBodyStmt* stmt)\n{\n    mOutputFormatHelper.OpenScope();\n\n    auto& ctx = GetGlobalAST();\n\n    mFSMName = [&] {\n        OutputFormatHelper   ofm{};\n        CodeGeneratorVariant codeGenerator{ofm};\n\n        // Coroutines can be templates and then we end up with the same FSM name but different template parameters.\n        // XXX: This will fail with NTTP's like 3.14\n        if(const auto* args = fd.getTemplateSpecializationArgs()) {\n            ofm.Append('_');\n\n            for(OnceFalse needsUnderscore{}; const auto& arg : args->asArray()) {\n                if(needsUnderscore) {\n                    ofm.Append('_');\n                }\n\n                codeGenerator->InsertTemplateArg(arg);\n            }\n        }\n\n        auto& str = ofm.GetString();\n        ReplaceAll(str, \"<\"sv, \"\"sv);\n        ReplaceAll(str, \":\"sv, \"\"sv);\n        ReplaceAll(str, \">\"sv, \"\"sv);\n        ReplaceAll(str, \",\"sv, \"\"sv);\n        ReplaceAll(str, \" \"sv, \"\"sv);\n\n        if(fd.isOverloadedOperator()) {\n            return StrCat(MakeLineColumnName(ctx.getSourceManager(), stmt->getBeginLoc(), \"operator_\"sv), str);\n        } else {\n            return StrCat(GetName(fd), str);\n        }\n    }();\n\n    mFrameName = BuildInternalVarName(StrCat(mFSMName, \"Frame\"sv));\n\n    // Insert a made up struct which holds the \"captured\" parameters stored in the coroutine frame\n    mASTData.mFrameType          = Struct(mFrameName);\n    mASTData.mFrameAccessDeclRef = mkVarDeclRefExpr(CORO_FRAME_NAME, GetFrameType());\n\n    // The coroutine frame starts with two function pointers to the resume and destroy function. See:\n    // https://gcc.gnu.org/legacy-ml/gcc-patches/2020-01/msg01096.html:\n    // \"The ABI mandates that pointers into the coroutine frame point to an area\n    // begining with two function pointers (to the resume and destroy functions\n    // described below); these are immediately followed by the \"promise object\"\n    // described in the standard.\"\n    //\n    // and\n    // https://llvm.org/docs/Coroutines.html#id72 \"Coroutine Representation\"\n    auto* resumeFnFd        = Function(hlpResumeFn, VoidTy(), {{CORO_FRAME_NAME, GetFramePointerType()}});\n    auto  resumeFnType      = Ptr(resumeFnFd->getType());\n    mASTData.mResumeFnField = AddField(hlpResumeFn, resumeFnType);\n\n    auto* destroyFnFd        = Function(hlpDestroyFn, VoidTy(), {{CORO_FRAME_NAME, GetFramePointerType()}});\n    auto  destroyFnType      = Ptr(destroyFnFd->getType());\n    mASTData.mDestroyFnField = AddField(hlpDestroyFn, destroyFnType);\n\n    // Allocated the made up frame\n    mOutputFormatHelper.AppendCommentNewLine(\"Allocate the frame including the promise\"sv);\n    mOutputFormatHelper.AppendCommentNewLine(\"Note: The actual parameter new is __builtin_coro_size\"sv);\n\n    auto* coroFrameVar = Variable(CORO_FRAME_NAME, GetFramePointerType());\n    auto* reicast      = ReinterpretCast(GetFramePointerType(), stmt->getAllocate());\n\n    coroFrameVar->setInit(reicast);\n\n    InsertArg(coroFrameVar);\n\n    // P0057R8: [dcl.fct.def.coroutine] p8: get_return_object_on_allocation_failure indicates that new may return a\n    // nullptr. In this case return get_return_object_on_allocation_failure.\n    if(stmt->getReturnStmtOnAllocFailure()) {\n        auto* nptr = new(ctx) CXXNullPtrLiteralExpr({});\n\n        // Create an IfStmt.\n        StmtsContainer bodyStmts{stmt->getReturnStmtOnAllocFailure()};\n        auto*          ifStmt = If(Equal(nptr, mASTData.mFrameAccessDeclRef), bodyStmts);\n\n        mOutputFormatHelper.AppendNewLine();\n        InsertArg(ifStmt);\n    }\n\n    CoroutineASTTransformer{\n        mASTData, mSuspendsCounter, const_cast<CoroutineBodyStmt*>(stmt), llvm::DenseMap<VarDecl*, MemberExpr*>{}};\n\n    // set initial suspend count to zero.\n    auto* setSuspendIndexToZero = Assign(mASTData.mFrameAccessDeclRef, mASTData.mSuspendIndexField, Int32(0));\n    InsertArgWithNull(setSuspendIndexToZero);\n\n    // https://timsong-cpp.github.io/cppwp/n4861/dcl.fct.def.coroutine#5.3\n    auto* initializeInitialAwaitResume =\n        Assign(mASTData.mFrameAccessDeclRef, mASTData.mInitialAwaitResumeCalledField, Bool(false));\n    InsertArgWithNull(initializeInitialAwaitResume);\n\n    // Move the parameters first\n    for(auto* param : stmt->getParamMoves()) {\n        if(const auto* declStmt = dyn_cast_or_null<DeclStmt>(param)) {\n            if(const auto* varDecl = dyn_cast_or_null<VarDecl>(declStmt->getSingleDecl())) {\n                const auto varName = GetName(*varDecl);\n\n                mOutputFormatHelper.AppendNewLine(CORO_FRAME_ACCESS,\n                                                  varName,\n                                                  \" = \"sv,\n                                                  \"std::forward<\"sv,\n                                                  GetName(varDecl->getType()),\n                                                  \">(\"sv,\n                                                  varName,\n                                                  \");\"sv);\n            }\n        }\n    }\n\n    // According to https://eel.is/c++draft/dcl.fct.def.coroutine#5.7 the promise_type constructor can have\n    // parameters. If so, they must be equal to the coroutines function parameters.\n    // The code here performs a _simple_ lookup for a matching ctor without using Clang's overload resolution.\n    ArrayRef<ParmVarDecl*>        funParams = fd.parameters();\n    SmallVector<ParmVarDecl*, 16> funParamStorage{};\n    QualType                      cxxMethodType{};\n\n    if(const auto* cxxMethodDecl = dyn_cast_or_null<CXXMethodDecl>(&fd)) {\n        funParamStorage.reserve(funParams.size() + 1);\n\n        cxxMethodType = cxxMethodDecl->\n#if IS_CLANG_NEWER_THAN(17)\n                        getFunctionObjectParameterType()\n#else\n                        getThisObjectType()\n#endif\n            ;\n\n        // In case we have a member function the first parameter is a reference to this. The following code injects\n        // this parameter.\n        funParamStorage.push_back(Parameter(&fd, CORO_FRAME_ACCESS_THIS, cxxMethodType));\n\n        ranges::copy(funParams, std::back_inserter(funParamStorage));\n\n        funParams = funParamStorage;\n    }\n\n    auto getNonRefType = [&](auto* var) -> QualType {\n        if(const auto* et = var->getType().getNonReferenceType()->template getAs<ElaboratedType>()) {\n            return et->getNamedType();\n        } else {\n            return QualType(var->getType().getNonReferenceType().getTypePtrOrNull(), 0);\n        }\n    };\n\n    SmallVector<Expr*, 16> exprs{};\n\n    for(auto* promiseTypeRecordDecl = mASTData.mPromiseField->getType()->getAsCXXRecordDecl();\n        auto* ctor : promiseTypeRecordDecl->ctors()) {\n\n        if(not ranges::equal(\n               ctor->parameters(), funParams, [&](auto& a, auto& b) { return getNonRefType(a) == getNonRefType(b); })) {\n            continue;\n        }\n\n        // In case of a promise ctor which takes this as the first argument, that parameter needs to be deferences,\n        // as it can only be taken as a reference.\n        OnceTrue derefFirstParam{};\n\n        if(not ctor->param_empty() and\n           (getNonRefType(ctor->getParamDecl(0)) == QualType(cxxMethodType.getTypePtrOrNull(), 0))) {\n            if(0 == mASTData.mThisExprs.size()) {\n                mASTData.mThisExprs.push_back(\n#if IS_CLANG_NEWER_THAN(17)\n                    CXXThisExpr::Create(ctx, {}, Ptr(cxxMethodType), false)\n#else\n                    new(ctx) CXXThisExpr{{}, Ptr(cxxMethodType), false}\n#endif\n\n                );\n            }\n        } else {\n            (void)static_cast<bool>(derefFirstParam);  // set it to false\n        }\n\n        for(const auto& fparam : funParams) {\n            if(derefFirstParam) {\n                exprs.push_back(Dref(mkDeclRefExpr(fparam)));\n\n            } else {\n                exprs.push_back(AccessMember(mASTData.mFrameAccessDeclRef, fparam));\n            }\n        }\n\n        if(funParams.size()) {\n            // The <new> header needs to be included.\n            EnableGlobalInsert(GlobalInserts::HeaderNew);\n        }\n\n        break;  // We've found what we were looking for\n    }\n\n    if(mASTData.mThisExprs.size()) {\n        mOutputFormatHelper.AppendNewLine(CORO_FRAME_ACCESS_THIS, \" = this;\"sv);\n    }\n\n    // Now call the promise ctor, as it may access some of the parameters it comes at this point.\n    mOutputFormatHelper.AppendNewLine();\n    mOutputFormatHelper.AppendCommentNewLine(\"Construct the promise.\"sv);\n    auto* me = AccessMember(mASTData.mFrameAccessDeclRef, mASTData.mPromiseField);\n\n    auto* ctorArgs = new(ctx) InitListExpr{ctx, {}, exprs, {}};\n\n    CXXNewExpr* newFrame = New({AddrOf(me)}, ctorArgs, mASTData.mPromiseField->getType());\n\n    InsertArgWithNull(newFrame);\n\n    // Add parameters from the original function to the list\n\n    // P0057R8: [dcl.fct.def.coroutine] p5: before initial_suspend and at tops 1\n\n    // Make a call to the made up state machine function for the initial suspend\n    mOutputFormatHelper.AppendNewLine();\n\n    // [dcl.fct.def.coroutine]\n    mOutputFormatHelper.AppendCommentNewLine(\"Forward declare the resume and destroy function.\"sv);\n\n    auto* fsmFuncDecl = CreateCoroFunctionDecl(StrCat(mFSMName, \"Resume\"sv), GetFramePointerType());\n    InsertArg(fsmFuncDecl);\n    auto* deallocFuncDecl = CreateCoroFunctionDecl(StrCat(mFSMName, \"Destroy\"sv), GetFramePointerType());\n    InsertArg(deallocFuncDecl);\n\n    mOutputFormatHelper.AppendNewLine();\n\n    mOutputFormatHelper.AppendCommentNewLine(\"Assign the resume and destroy function pointers.\"sv);\n\n    auto* assignResumeFn = Assign(mASTData.mFrameAccessDeclRef, mASTData.mResumeFnField, Ref(fsmFuncDecl));\n    InsertArgWithNull(assignResumeFn);\n\n    auto* assignDestroyFn = Assign(mASTData.mFrameAccessDeclRef, mASTData.mDestroyFnField, Ref(deallocFuncDecl));\n    InsertArgWithNull(assignDestroyFn);\n    mOutputFormatHelper.AppendNewLine();\n\n    mOutputFormatHelper.AppendCommentNewLine(\n        R\"A(Call the made up function with the coroutine body for initial suspend.\n     This function will be called subsequently by coroutine_handle<>::resume()\n     which calls __builtin_coro_resume(__handle_))A\"sv);\n\n    auto* callCoroFSM = Call(fsmFuncDecl, {mASTData.mFrameAccessDeclRef});\n    InsertArgWithNull(callCoroFSM);\n\n    mOutputFormatHelper.AppendNewLine();\n    mOutputFormatHelper.AppendNewLine();\n\n    InsertArg(stmt->getReturnStmt());\n\n    mOutputFormatHelper.AppendSemiNewLine();\n\n    mOutputFormatHelper.CloseScope(OutputFormatHelper::NoNewLineBefore::Yes);\n    mOutputFormatHelper.AppendNewLine();\n    mOutputFormatHelper.AppendNewLine();\n\n    // add contents of the original function to the body of our made up function\n    StmtsContainer fsmFuncBodyStmts{stmt};\n\n    mOutputFormatHelper.AppendCommentNewLine(\"This function invoked by coroutine_handle<>::resume()\"sv);\n    SetFunctionBody(fsmFuncDecl, fsmFuncBodyStmts);\n    InsertArg(fsmFuncDecl);\n\n    mASTData.mDoInsertInDtor = true;  // As we have a coroutine insert the frame when this object goes out of scope.\n\n#if 0  // Preserve for later. Technically the destructor for the entire frame that's made up below takes care of\n       // everything.\n\n    // A destructor is only present, if they promise_type or one of its members is non-trivially destructible.\n    if(auto* dtor = mASTData.mPromiseField->getType()->getAsCXXRecordDecl()->getDestructor()) {\n        deallocFuncBodyStmts.Add(Comment(\"Deallocating the coroutine promise type\"sv));\n\n        auto* promiseAccess  = AccessMember(mASTData.mFrameAccessDeclRef, mASTData.mPromiseField);\n        auto* deallocPromise = AccessMember(promiseAccess, dtor, false);\n        auto* dtorCall       = CallMemberFun(deallocPromise, dtor->getType());\n        deallocFuncBodyStmts.Add(dtorCall);\n\n    } else {\n        deallocFuncBodyStmts.Add(\n            Comment(\"promise_type is trivially destructible, no dtor required.\"sv));\n    }\n#endif\n\n    // This code isn't really there but it is the easiest and cleanest way to visualize the destruction of all\n    // member in the frame. The deallocation function:\n    // https://devblogs.microsoft.com/oldnewthing/20210331-00/?p=105028\n    mOutputFormatHelper.AppendNewLine();\n    mOutputFormatHelper.AppendCommentNewLine(\"This function invoked by coroutine_handle<>::destroy()\"sv);\n\n    StmtsContainer deallocFuncBodyStmts{Comment(\"destroy all variables with dtors\"sv)};\n\n    auto* dtorFuncDecl =\n        Function(StrCat(\"~\"sv, GetName(*mASTData.mFrameType)), VoidTy(), {{CORO_FRAME_NAME, GetFramePointerType()}});\n    auto* deallocPromise = AccessMember(mASTData.mFrameAccessDeclRef, dtorFuncDecl);\n    auto* dtorCall       = CallMemberFun(deallocPromise, GetFrameType());\n    deallocFuncBodyStmts.Add(dtorCall);\n\n    deallocFuncBodyStmts.Add(Comment(\"Deallocating the coroutine frame\"sv));\n    deallocFuncBodyStmts.Add(\n        Comment(\"Note: The actual argument to delete is __builtin_coro_frame with the promise as parameter\"sv));\n\n    deallocFuncBodyStmts.Add(stmt->getDeallocate());\n\n    SetFunctionBody(deallocFuncDecl, deallocFuncBodyStmts);\n    InsertArg(deallocFuncDecl);\n}\n//-----------------------------------------------------------------------------\n\nvoid CoroutinesCodeGenerator::InsertArg(const CoroutineBodyStmt* stmt)\n{\n    // insert a made up switch for continuing a resume\n    SwitchStmt* sstmt = Switch(mASTData.mSuspendIndexAccess);\n\n    // insert 0 with break for consistency\n    auto*          initialSuspendCase = Case(0, Break());\n    StmtsContainer switchBodyStmts{initialSuspendCase};\n\n    for(const auto& i : NumberIterator{mSuspendsCounter}) {\n        switchBodyStmts.Add(Case(i + 1, Goto(BuildResumeLabelName(i + 1))));\n    }\n\n    auto* switchBody = mkCompoundStmt(switchBodyStmts);\n    sstmt->setBody(switchBody);\n\n    StmtsContainer funcBodyStmts{\n        Comment(\"Create a switch to get to the correct resume point\"sv), sstmt, stmt->getInitSuspendStmt()};\n\n    // insert the init suspend expr\n    mState = eState::InitialSuspend;\n\n    if(mASTData.mThisExprs.size()) {\n        AddField(kwInternalThis, mASTData.mThisExprs.at(0)->getType());\n    }\n\n    mInsertVarDecl      = false;\n    mSupressRecordDecls = true;\n\n    for(const auto* c : stmt->getBody()->children()) {\n        funcBodyStmts.Add(c);\n    }\n\n    if(const auto* coReturnVoid = dyn_cast_or_null<CoreturnStmt>(stmt->getFallthroughHandler())) {\n        coReturnVoid->dump();\n        funcBodyStmts.Add(coReturnVoid);\n    }\n\n    auto* gotoFinalSuspend = Goto(FINAL_SUSPEND_NAME);\n    funcBodyStmts.Add(gotoFinalSuspend);\n\n    auto* body = [&]() -> Stmt* {\n        auto* tryBody = mkCompoundStmt(funcBodyStmts);\n\n        // First open the try-catch block, as we get an error when jumping across such blocks with goto\n        if(const auto* exceptionHandler = stmt->getExceptionHandler()) {\n            // If we encounter an exceptionbefore inital_suspend's await_suspend was called we re-throw the\n            // exception.\n            auto* ifStmt = If(Not(mASTData.mInitialAwaitResumeCalledAccess), Throw());\n\n            StmtsContainer catchBodyStmts{ifStmt, exceptionHandler};\n\n            return Try(tryBody, Catch(catchBodyStmts));\n        }\n\n        return tryBody;\n    }();\n\n    InsertArg(body);\n\n    mOutputFormatHelper.AppendNewLine();\n\n    auto* finalSuspendLabel = Label(FINAL_SUSPEND_NAME);\n    InsertArg(finalSuspendLabel);\n    mState = eState::FinalSuspend;\n    InsertArg(stmt->getFinalSuspendStmt());\n\n    // disable prefixing names and types\n    mInsertVarDecl = true;\n}\n//-----------------------------------------------------------------------------\n\nvoid CoroutinesCodeGenerator::InsertArg(const CXXRecordDecl* stmt)\n{\n    if(not mSupressRecordDecls) {\n        CodeGenerator::InsertArg(stmt);\n    }\n}\n//-----------------------------------------------------------------------------\n\n// We seem to need this, to peal of some static_casts in a CoroutineSuspendExpr.\nvoid CoroutinesCodeGenerator::InsertArg(const ImplicitCastExpr* stmt)\n{\n    if(mSupressCasts) {\n        InsertArg(stmt->getSubExpr());\n    } else {\n        CodeGenerator::InsertArg(stmt);\n    }\n}\n//-----------------------------------------------------------------------------\n\n// A special hack to avoid having calls to __builtin_coro_xxx as some of them result in a crash\n// of the compiler and have assumption on the call order and function location.\nvoid CoroutinesCodeGenerator::InsertArg(const CallExpr* stmt)\n{\n    if(const auto* callee = dyn_cast_or_null<DeclRefExpr>(stmt->getCallee()->IgnoreCasts())) {\n        if(GetPlainName(*callee) == \"__builtin_coro_frame\"sv) {\n            CodeGenerator::InsertArg(StaticCast(VoidTy(), mASTData.mFrameAccessDeclRef, true));\n            return;\n\n        } else if(GetPlainName(*callee) == \"__builtin_coro_free\"sv) {\n            CodeGenerator::InsertArg(stmt->getArg(0));\n            return;\n\n        } else if(GetPlainName(*callee) == \"__builtin_coro_size\"sv) {\n            CodeGenerator::InsertArg(Sizeof(GetFrameType()));\n            return;\n        }\n    }\n\n    CodeGenerator::InsertArg(stmt);\n}\n//-----------------------------------------------------------------------------\n\nstatic std::optional<std::string> FindValue(llvm::DenseMap<const Expr*, std::string>& map, const Expr* key)\n{\n    if(const auto& s = map.find(key); s != map.end()) {\n        return s->second;\n    }\n\n    return {};\n}\n//-----------------------------------------------------------------------------\n\nvoid CoroutinesCodeGenerator::InsertArg(const OpaqueValueExpr* stmt)\n{\n    const auto* sourceExpr = stmt->getSourceExpr();\n\n    if(const auto& s = FindValue(mOpaqueValues, sourceExpr)) {\n        mOutputFormatHelper.Append(s.value());\n\n    } else {\n        // Needs to be internal because a user can create the same type and it gets put into the stack frame\n        std::string name{BuildSuspendVarName(stmt)};\n\n        // The initial_suspend and final_suspend expressions carry the same location info. If we hit such a case,\n        // make up another name.\n        // Below is a std::find_if. However, the same code looks unreadable with std::find_if\n        for(const auto lookupName{StrCat(CORO_FRAME_ACCESS, name)}; const auto& [k, v] : mOpaqueValues) {\n            if(v == lookupName) {\n                name += \"_1\"sv;\n                break;\n            }\n        }\n\n        const auto accessName{StrCat(CORO_FRAME_ACCESS, name)};\n        mOpaqueValues.insert(std::make_pair(sourceExpr, accessName));\n\n        OutputFormatHelper      ofm{};\n        CoroutinesCodeGenerator codeGenerator{ofm, mPosBeforeFunc, mFSMName, mSuspendsCount, mASTData};\n\n        auto*           promiseField = AddField(name, stmt->getType());\n        BinaryOperator* assignPromiseSuspend =\n            Assign(mASTData.mFrameAccessDeclRef, promiseField, stmt->getSourceExpr());\n\n        codeGenerator.InsertArg(assignPromiseSuspend);\n        ofm.AppendSemiNewLine();\n\n        ofm.SetIndent(mOutputFormatHelper);\n\n        mOutputFormatHelper.InsertAt(mPosBeforeSuspendExpr, ofm);\n        mOutputFormatHelper.Append(accessName);\n    }\n}\n//-----------------------------------------------------------------------------\n\nstd::string CoroutinesCodeGenerator::BuildResumeLabelName(int index) const\n{\n    return StrCat(RESUME_LABEL_PREFIX, \"_\"sv, mFSMName, \"_\"sv, index);\n}\n//-----------------------------------------------------------------------------\n\nvoid CoroutinesCodeGenerator::InsertArg(const CoroutineSuspendExpr* stmt)\n{\n    mOutputFormatHelper.AppendNewLine();\n    InsertInstantiationPoint(GetGlobalAST().getSourceManager(), stmt->getKeywordLoc(), [&] {\n        if(isa<CoawaitExpr>(stmt)) {\n            return kwCoAwaitSpace;\n        } else {\n            return kwCoYieldSpace;\n        }\n    }());\n\n    mPosBeforeSuspendExpr = mOutputFormatHelper.CurrentPos();\n\n    /// Represents an expression that might suspend coroutine execution;\n    /// either a co_await or co_yield expression.\n    ///\n    /// Evaluation of this expression first evaluates its 'ready' expression. If\n    /// that returns 'false':\n    ///  -- execution of the coroutine is suspended\n    ///  -- the 'suspend' expression is evaluated\n    ///     -- if the 'suspend' expression returns 'false', the coroutine is\n    ///        resumed\n    ///     -- otherwise, control passes back to the resumer.\n    /// If the coroutine is not suspended, or when it is resumed, the 'resume'\n    /// expression is evaluated, and its result is the result of the overall\n    /// expression.\n\n    // mOutputFormatHelper.AppendNewLine(\"// __builtin_coro_save() // frame->suspend_index = n\");\n\n    // For why, see the implementation of CoroutinesCodeGenerator::InsertArg(const ImplicitCastExpr* stmt)\n    mSupressCasts = true;\n\n    auto* il  = Int32(++mSuspendsCount);\n    auto* bop = Assign(mASTData.mSuspendIndexAccess, mASTData.mSuspendIndexField, il);\n\n    // Find out whether the return type is void or bool. In case of bool, we need to insert an if-statement, to\n    // suspend only, if the return value was true.\n    // Technically only void, bool, or std::coroutine_handle<Z> is allowed. [expr.await] p3.7\n    const bool returnsVoid{stmt->getSuspendExpr()->getType()->isVoidType()};\n\n    // XXX: check if getResumeExpr is marked noexcept. Otherwise we need additional expcetion handling?\n    // CGCoroutine.cpp:229\n\n    StmtsContainer bodyStmts{};\n    Expr*          initializeInitialAwaitResume = nullptr;\n\n    auto addInitialAwaitSuspendCalled = [&] {\n        bodyStmts.Add(bop);\n\n        if(eState::InitialSuspend == mState) {\n            mState = eState::Body;\n            // https://timsong-cpp.github.io/cppwp/n4861/dcl.fct.def.coroutine#5.3\n            initializeInitialAwaitResume =\n                Assign(mASTData.mFrameAccessDeclRef, mASTData.mInitialAwaitResumeCalledField, Bool(true));\n            bodyStmts.Add(initializeInitialAwaitResume);\n        }\n    };\n\n    if(returnsVoid) {\n        bodyStmts.Add(stmt->getSuspendExpr());\n        addInitialAwaitSuspendCalled();\n        bodyStmts.Add(Return());\n\n        InsertArg(If(Not(stmt->getReadyExpr()), bodyStmts));\n\n    } else {\n        addInitialAwaitSuspendCalled();\n        bodyStmts.Add(Return());\n\n        auto* ifSuspend = If(stmt->getSuspendExpr(), bodyStmts);\n\n        InsertArg(If(Not(stmt->getReadyExpr()), ifSuspend));\n    }\n\n    if(not returnsVoid and initializeInitialAwaitResume) {\n        // At this point we technically haven't called initial suspend\n        InsertArgWithNull(initializeInitialAwaitResume);\n        mOutputFormatHelper.AppendNewLine();\n    }\n\n    auto* suspendLabel = Label(BuildResumeLabelName(mSuspendsCount));\n    InsertArg(suspendLabel);\n\n    if(eState::FinalSuspend == mState) {\n        auto* memExpr     = AccessMember(mASTData.mFrameAccessDeclRef, mASTData.mDestroyFnField, true);\n        auto* callCoroFSM = Call(memExpr, {mASTData.mFrameAccessDeclRef});\n        InsertArg(callCoroFSM);\n        return;\n    }\n\n    const auto* resumeExpr = stmt->getResumeExpr();\n\n    if(not resumeExpr->getType()->isVoidType()) {\n        const auto* sourceExpr = stmt->getOpaqueValue()->getSourceExpr();\n\n        if(const auto& s = FindValue(mOpaqueValues, sourceExpr)) {\n            const auto fieldName{StrCat(std::string_view{s.value()}.substr(CORO_FRAME_ACCESS.size()), \"_res\"sv)};\n            mOutputFormatHelper.Append(CORO_FRAME_ACCESS, fieldName, hlpAssing);\n\n            AddField(fieldName, resumeExpr->getType());\n        }\n    }\n\n    InsertArg(resumeExpr);\n}\n//-----------------------------------------------------------------------------\n\nvoid CoroutinesCodeGenerator::InsertArg(const CoreturnStmt* stmt)\n{\n    InsertInstantiationPoint(GetGlobalAST().getSourceManager(), stmt->getKeywordLoc(), kwCoReturnSpace);\n\n    if(stmt->getPromiseCall()) {\n        InsertArg(stmt->getPromiseCall());\n\n        if(stmt->isImplicit()) {\n            mOutputFormatHelper.AppendComment(\"implicit\"sv);\n        }\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid CoroutinesCodeGenerator::InsertArgWithNull(const Stmt* stmt)\n{\n    InsertArg(stmt);\n    InsertArg(mkNullStmt());\n}\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n"
        },
        {
          "name": "DPrint.cpp",
          "type": "blob",
          "size": 2.35546875,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#include \"DPrint.h\"\n#include \"InsightsStaticStrings.h\"\n#include \"OutputFormatHelper.h\"\n\n#include \"clang/AST/AST.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"llvm/Support/Path.h\"\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n\nstatic void ToDo(std::string_view name, OutputFormatHelper& outputFormatHelper, std::source_location loc)\n{\n    const auto fileName = [&]() -> std::string_view {\n        if(llvm::sys::path::is_separator(loc.file_name()[0])) {\n            return llvm::sys::path::filename(loc.file_name());\n        }\n\n        return loc.file_name();\n    }();\n\n    outputFormatHelper.Append(\n        \"/* INSIGHTS-TODO: \"sv, fileName, \":\"sv, loc.line(), \" stmt: \"sv, name, kwSpaceCCommentEnd);\n}\n//-----------------------------------------------------------------------------\n\nvoid ToDo(const Stmt* stmt, OutputFormatHelper& outputFormatHelper, std::source_location loc)\n{\n    const std::string_view name = [&]() {\n        if(stmt and stmt->getStmtClassName()) {\n            Dump(stmt);\n\n            return stmt->getStmtClassName();\n        }\n\n        Error(\"arg urg: class name is empty\\n\");\n\n        return \"\";\n    }();\n\n    ToDo(name, outputFormatHelper, loc);\n}\n//-----------------------------------------------------------------------------\n\nvoid ToDo(const Decl* stmt, OutputFormatHelper& outputFormatHelper, std::source_location loc)\n{\n    const std::string_view name = [&]() {\n        if(stmt and stmt->getDeclKindName()) {\n            Dump(stmt);\n            return stmt->getDeclKindName();\n        }\n\n        Error(\"decl urg: class name is empty\\n\");\n\n        return \"\";\n    }();\n\n    ToDo(name, outputFormatHelper, loc);\n}\n//-----------------------------------------------------------------------------\n\nvoid ToDo(const class TemplateArgument& stmt, class OutputFormatHelper& outputFormatHelper, std::source_location loc)\n{\n    const std::string_view name{StrCat(\"tmplArgKind: \", stmt.getKind())};\n\n    ToDo(name, outputFormatHelper, loc);\n}\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n"
        },
        {
          "name": "DPrint.h",
          "type": "blob",
          "size": 4.240234375,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#ifndef INSIGHTS_DPRINT_H\n#define INSIGHTS_DPRINT_H\n\n#include <source_location>\n\n#include \"InsightsStrCat.h\"\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n\nnamespace details {\n\ninline const char* Normalize(const std::string& arg)\n{\n    static constexpr const char emptyString[]{\"\"};\n\n    if(arg.empty()) {\n        return emptyString;\n    }\n\n    return arg.c_str();\n}\n//-----------------------------------------------------------------------------\n\ninline uint64_t Normalize(const llvm::APInt& arg)\n{\n    return arg.getZExtValue();\n}\n//-----------------------------------------------------------------------------\n\ninline const char* Normalize(const llvm::APSInt& arg)\n{\n    return Normalize(ToString(arg));\n}\n//-----------------------------------------------------------------------------\n\ninline const char* Normalize(const StringRef& arg)\n{\n    return Normalize(arg.str());\n}\n//-----------------------------------------------------------------------------\n\ninline const auto& Normalize(const auto& arg)\n{\n    return arg;\n}\n//-----------------------------------------------------------------------------\n\ninline void FPrintf(const char* fmt, const auto&... args)\n{\n    if constexpr(0 < (sizeof...(args))) {\n        fprintf(stderr, fmt, Normalize(args)...);\n    } else {\n        fprintf(stderr, \"%s\", fmt);\n    }\n}\n//-----------------------------------------------------------------------------\n\n}  // namespace details\n\n/// \\brief Debug print which is disabled in release-mode.\n///\n/// It takes a variable number of parameters which are normalized if they are a \\ref std::string or a \\ref StringRef.\ninline void DPrint([[maybe_unused]] const char* fmt, [[maybe_unused]] const auto&... args)\n{\n#ifdef INSIGHTS_DEBUG\n    details::FPrintf(fmt, args...);\n#endif /* INSIGHTS_DEBUG */\n}\n//-----------------------------------------------------------------------------\n\n/// \\brief Log an error.\ninline void Error(const char* fmt, const auto&... args)\n{\n    details::FPrintf(fmt, args...);\n}\n//-----------------------------------------------------------------------------\n\ninline void Dump([[maybe_unused]] const auto* stmt)\n{\n#ifdef INSIGHTS_DEBUG\n    if(stmt) {\n        stmt->dump();\n    }\n#endif /* INSIGHTS_DEBUG */\n}\n//-----------------------------------------------------------------------------\n\n/// \\brief Log an error.\n///\n/// In debug-mode this dumps the \\ref Decl which caused the error and the error message.\ninline void Error(const Decl* stmt, const char* fmt, const auto&... args)\n{\n    if(stmt) {\n        Dump(stmt);\n    }\n\n    Error(fmt, args...);\n}\n//-----------------------------------------------------------------------------\n\n/// \\brief Log an error.\n///\n/// In debug-mode this dumps the \\ref Stmt which caused the error and the error message.\ninline void Error(const Stmt* stmt, const char* fmt, const auto&... args)\n{\n    if(stmt) {\n        Dump(stmt);\n    }\n\n    Error(fmt, args...);\n}\n//-----------------------------------------------------------------------------\n\n/// \\brief Helper function to generate TODO comments for an unsupported \\ref Stmt.\nvoid ToDo(const class Stmt*         stmt,\n          class OutputFormatHelper& outputFormatHelper,\n          std::source_location      loc = std::source_location::current());\n/// \\brief Helper function to generate TODO comments for an unsupported \\ref Decl.\nvoid ToDo(const class Decl*         stmt,\n          class OutputFormatHelper& outputFormatHelper,\n          std::source_location      loc = std::source_location::current());\n//-----------------------------------------------------------------------------\n/// \\brief Helper function to generate TODO comments for an unsupported \\ref TemplateArgument.\nvoid ToDo(const class TemplateArgument& stmt,\n          class OutputFormatHelper&     outputFormatHelper,\n          std::source_location          loc = std::source_location::current());\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n\n#endif /* INSIGHTS_DPRINT_H */\n"
        },
        {
          "name": "Insights.cpp",
          "type": "blob",
          "size": 17.5703125,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#include <array>\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Frontend/FrontendActions.h\"\n#include \"clang/Rewrite/Core/Rewriter.h\"\n#include \"clang/Tooling/CommonOptionsParser.h\"\n#include \"clang/Tooling/Tooling.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/Signals.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\n#include <vector>\n\n#include \"CodeGenerator.h\"\n#include \"DPrint.h\"\n#include \"Insights.h\"\n#include \"version.h\"\n//-----------------------------------------------------------------------------\n\nusing namespace clang;\nusing namespace clang::driver;\nusing namespace clang::tooling;\nusing namespace clang::insights;\n//-----------------------------------------------------------------------------\n\nstatic InsightsOptions gInsightsOptions{};\n//-----------------------------------------------------------------------------\n\nconst InsightsOptions& GetInsightsOptions()\n{\n    return gInsightsOptions;\n}\n//-----------------------------------------------------------------------------\n\nInsightsOptions& GetInsightsOptionsRW()\n{\n    return gInsightsOptions;\n}\n//-----------------------------------------------------------------------------\n\nstatic llvm::cl::OptionCategory gInsightCategory(\"Insights\"sv);\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\nstatic llvm::cl::OptionCategory gInsightEduCategory(\n    \"Insights-Educational\"sv,\n    \"This transformations are only for education purposes. The resulting code most likely does not compile.\"sv);\n//-----------------------------------------------------------------------------\n\nstatic llvm::cl::opt<bool> gStdinMode(\"stdin\",\n                                      llvm::cl::desc(\"Read the input from <stdin>.\"sv),\n                                      llvm::cl::init(false),\n                                      llvm::cl::cat(gInsightCategory));\n//-----------------------------------------------------------------------------\n\nstatic llvm::cl::opt<bool>\n    gUseLibCpp(\"use-libc++\", llvm::cl::desc(\"Use libc++.\"sv), llvm::cl::init(false), llvm::cl::cat(gInsightCategory));\n//-----------------------------------------------------------------------------\n\n#define INSIGHTS_OPT(option, name, deflt, description, category)                                                       \\\n    static llvm::cl::opt<bool, true> g##name(option,                                                                   \\\n                                             llvm::cl::desc(std::string_view{description}),                            \\\n                                             llvm::cl::NotHidden,                                                      \\\n                                             llvm::cl::location(gInsightsOptions.name),                                \\\n                                             llvm::cl::init(deflt),                                                    \\\n                                             llvm::cl::cat(category));\n//-----------------------------------------------------------------------------\n\n#include \"InsightsOptions.def\"\n//-----------------------------------------------------------------------------\n\nstatic const ASTContext* gAST{};\nconst ASTContext&        GetGlobalAST()\n{\n    return *gAST;\n}\n//-----------------------------------------------------------------------------\n\nstatic const CompilerInstance* gCI{};\nconst CompilerInstance&        GetGlobalCI()\n{\n    return *gCI;\n}\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\nstd::string EmitGlobalVariableCtors();\n\nusing GlobalInsertMap = std::pair<bool, std::string_view>;\n\nstatic constinit std::array<GlobalInsertMap, static_cast<size_t>(GlobalInserts::MAX)> gGlobalInserts{};\n\nvoid AddGLobalInsertMapEntry(GlobalInserts idx, std::string_view value)\n{\n    gGlobalInserts[static_cast<size_t>(idx)] = {false, value};\n}\n\nvoid EnableGlobalInsert(GlobalInserts idx)\n{\n    gGlobalInserts[static_cast<size_t>(idx)].first = true;\n}\n\n}  // namespace clang::insights\n\nusing IncludeData = std::pair<const SourceLocation, std::string>;\n\nclass FindIncludes : public PPCallbacks\n{\n    SourceManager&            mSm;\n    Preprocessor&             mPP;\n    std::vector<IncludeData>& mIncludes;\n\npublic:\n    FindIncludes(SourceManager& sm, Preprocessor& pp, std::vector<IncludeData>& incData)\n    : PPCallbacks{}\n    , mSm{sm}\n    , mPP{pp}\n    , mIncludes{incData}\n    {\n    }\n\n    void InclusionDirective(SourceLocation hashLoc,\n                            const Token& /*IncludeTok*/,\n                            StringRef fileName,\n                            bool      isAngled,\n                            CharSourceRange /*FilenameRange*/,\n                            OptionalFileEntryRef /*file*/,\n                            StringRef /*SearchPath*/,\n                            StringRef /*RelativePath*/,\n                            const Module* /*Imported*/,\n#if IS_CLANG_NEWER_THAN(18)\n                            bool /*ModuleImported*/,\n#endif\n                            SrcMgr::CharacteristicKind /*FileType*/) override\n    {\n        auto expansionLoc = mSm.getExpansionLoc(hashLoc);\n\n        if(expansionLoc.isInvalid() or mSm.isInSystemHeader(expansionLoc)) {\n            return;\n        }\n\n        // XXX: distinguish between include and import via the IncludeTok\n        if(isAngled) {\n            mIncludes.emplace_back(expansionLoc, StrCat(\"#include <\"sv, fileName, \">\\n\"sv));\n\n        } else {\n            mIncludes.emplace_back(expansionLoc, StrCat(\"#include \\\"\"sv, fileName, \"\\\"\\n\"sv));\n        }\n    }\n\n    void MacroDefined(const Token& macroNameTok, const MacroDirective* md) override\n    {\n        const auto loc = md->getLocation();\n        if(not mSm.isWrittenInMainFile(loc)) {\n            return;\n        }\n\n        auto name = mPP.getSpelling(macroNameTok);\n\n        if(not name.starts_with(\"INSIGHTS_\"sv)) {\n            return;\n        }\n\n        mIncludes.emplace_back(loc, StrCat(\"#define \"sv, name, \"\\n\"sv));\n    }\n};\n\nclass CppInsightASTConsumer final : public ASTConsumer\n{\n    Rewriter&                 mRewriter;\n    std::vector<IncludeData>& mIncludes;\n\npublic:\n    explicit CppInsightASTConsumer(Rewriter& rewriter, std::vector<IncludeData>& includes)\n    : ASTConsumer{}\n    , mRewriter{rewriter}\n    , mIncludes{includes}\n    {\n        if(GetInsightsOptions().UseShow2C) {\n            if(GetInsightsOptions().ShowCoroutineTransformation) {\n                gInsightsOptions.UseShow2C = false;\n            } else {\n                gInsightsOptions.ShowLifetime = true;\n            }\n        }\n\n        if(GetInsightsOptions().ShowLifetime) {\n            gInsightsOptions.UseShowInitializerList = true;\n        }\n    }\n\n    void HandleTranslationUnit(ASTContext& context) override\n    {\n        gAST     = &context;\n        auto& sm = context.getSourceManager();\n\n        auto isExpansionInSystemHeader = [&sm](const Decl* d) {\n            auto expansionLoc = sm.getExpansionLoc(d->getLocation());\n\n            return expansionLoc.isInvalid() or sm.isInSystemHeader(expansionLoc);\n        };\n\n        const auto& mainFileId = sm.getMainFileID();\n\n        mRewriter.ReplaceText({sm.getLocForStartOfFile(mainFileId), sm.getLocForEndOfFile(mainFileId)}, \"\");\n\n        OutputFormatHelper   outputFormatHelper{};\n        CodeGeneratorVariant codeGenerator{outputFormatHelper};\n\n        auto include = mIncludes.begin();\n\n        auto insertBlankLineIfRequired = [&](std::optional<SourceLocation>& lastLoc, SourceLocation nextLoc) {\n            if(lastLoc.has_value() and\n               (2 <= (sm.getSpellingLineNumber(nextLoc) - sm.getSpellingLineNumber(lastLoc.value())))) {\n                outputFormatHelper.AppendNewLine();\n            }\n\n            lastLoc = nextLoc;\n        };\n\n        for(std::optional<SourceLocation> lastLoc{}; const auto* d : context.getTranslationUnitDecl()->decls()) {\n            if(isExpansionInSystemHeader(d)) {\n                continue;\n            }\n\n            // includes before this decl\n            for(; (mIncludes.end() != include) and (include->first < d->getLocation()); include = std::next(include)) {\n                insertBlankLineIfRequired(lastLoc, include->first);\n                outputFormatHelper.Append(include->second);\n            }\n\n            // ignore includes inside this decl\n            include = std::find_if_not(include, mIncludes.end(), [&](auto& inc) {\n                return ((inc.first >= d->getLocation()) and (inc.first <= d->getEndLoc()));\n            });\n\n            if(isa<LinkageSpecDecl>(d) and d->isImplicit()) {\n                continue;\n\n                // Only handle explicit specializations here. Implicit ones are handled by the `VarTemplateDecl`\n                // itself.\n            } else if(const auto* vdspec = dyn_cast_or_null<VarTemplateSpecializationDecl>(d);\n                      vdspec and (TSK_ExplicitSpecialization != vdspec->getSpecializationKind())) {\n                continue;\n            }\n\n            insertBlankLineIfRequired(lastLoc, d->getLocation());\n\n            codeGenerator->InsertArg(d);\n        }\n\n        std::string insightsIncludes{};\n\n        if(GetInsightsOptions().ShowCoroutineTransformation) {\n            insightsIncludes.append(\n                R\"(/*************************************************************************************\n * NOTE: The coroutine transformation you've enabled is a hand coded transformation! *\n *       Most of it is _not_ present in the AST. What you see is an approximation.   *\n *************************************************************************************/\n)\"sv);\n        } else if(GetInsightsOptions().UseShow2C or GetInsightsOptions().ShowLifetime) {\n            insightsIncludes.append(\n                R\"(/*************************************************************************************\n * NOTE: This an educational hand-rolled transformation. Things can be incorrect or  *\n * buggy.                                                                            *\n *************************************************************************************/\n)\"sv);\n        }\n\n        // Check whether we had static local variables which we transformed. Then for the placement-new we need to\n        // include the header <new>.\n        std::string inserts{};\n        for(const auto& [active, value] : gGlobalInserts) {\n            if(not active) {\n                continue;\n            }\n\n            inserts.append(value);\n            inserts.append(\"\\n\"sv);\n        }\n\n        if(not inserts.empty()) {\n            insightsIncludes.append(inserts);\n            insightsIncludes.append(\"\\n\");\n        }\n\n        outputFormatHelper.InsertAt(0, insightsIncludes);\n\n        mRewriter.InsertText(sm.getLocForStartOfFile(mainFileId), outputFormatHelper.GetString());\n\n        if(GetInsightsOptions().UseShow2C) {\n            const auto& fileEntry = sm.getFileEntryForID(mainFileId);\n            auto        cxaStart  = EmitGlobalVariableCtors();\n            const auto  cxaLoc    = sm.translateFileLineCol(fileEntry, fileEntry->getSize(), 1);\n\n            mRewriter.InsertText(cxaLoc, cxaStart);\n        }\n    }\n};\n//-----------------------------------------------------------------------------\n\nclass CppInsightFrontendAction final : public ASTFrontendAction\n{\n    Rewriter                 mRewriter{};\n    std::vector<IncludeData> mIncludes{};\n\npublic:\n    CppInsightFrontendAction() = default;\n    void EndSourceFileAction() override\n    {\n        mRewriter.getEditBuffer(mRewriter.getSourceMgr().getMainFileID()).write(llvm::outs());\n    }\n\n    std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance& CI, StringRef /*file*/) override\n    {\n        gCI = &CI;\n\n        Preprocessor& pp = CI.getPreprocessor();\n        pp.addPPCallbacks(std::make_unique<FindIncludes>(CI.getSourceManager(), pp, mIncludes));\n\n        mRewriter.setSourceMgr(CI.getSourceManager(), CI.getLangOpts());\n        return std::make_unique<CppInsightASTConsumer>(mRewriter, mIncludes);\n    }\n};\n//-----------------------------------------------------------------------------\n\n#include \"clang/Basic/Version.h\"\n\nstatic void PrintVersion(raw_ostream& ostream)\n{\n    ostream << \"cpp-insights \" << INSIGHTS_VERSION << \" https://cppinsights.io (\" << GIT_REPO_URL << \" \"\n            << GIT_COMMIT_HASH << \")\"\n            << \"\\n\";\n\n#ifdef INSIGHTS_DEBUG\n    ostream << \"  Build with debug enabled\\n\";\n#endif\n    ostream << \"  LLVM  Revision: \" << clang::getLLVMRevision() << '\\n';\n    ostream << \"  Clang Revision: \" << clang::getClangFullCPPVersion() << '\\n';\n}\n//-----------------------------------------------------------------------------\n\nint main(int argc, const char** argv)\n{\n    // Headers go first\n    using enum GlobalInserts;\n    AddGLobalInsertMapEntry(HeaderNew,\n                            \"#include <new> // for thread-safe static's placement new\\n#include <stdint.h> // for \"\n                            \"uint64_t under Linux/GCC\"sv);\n    AddGLobalInsertMapEntry(HeaderException, \"#include <exception> // for noexcept transformation\"sv);\n    AddGLobalInsertMapEntry(HeaderUtility, \"#include <utility> // std::move\"sv);\n    AddGLobalInsertMapEntry(HeaderStddef, \"#include <stddef.h> // NULL and more\"sv);\n    AddGLobalInsertMapEntry(HeaderAssert, \"#include <assert.h> // _Static_assert\"sv);\n    AddGLobalInsertMapEntry(HeaderStdlib, \"#include <stdlib.h> // abort\"sv);\n\n    // Now all the forward declared functions\n    AddGLobalInsertMapEntry(FuncCxaStart, \"void __cxa_start(void);\"sv);\n    AddGLobalInsertMapEntry(FuncCxaAtExit, \"void __cxa_atexit(void);\"sv);\n    AddGLobalInsertMapEntry(FuncMalloc, \"void* malloc(unsigned int);\"sv);\n    AddGLobalInsertMapEntry(FuncFree, R\"(extern \"C\" void free(void*);)\"sv);\n    AddGLobalInsertMapEntry(FuncMemset, R\"(extern \"C\" void* memset(void*, int, unsigned int);)\"sv);\n    AddGLobalInsertMapEntry(FuncMemcpy, R\"(void* memcpy(void*, const void*, unsigned int);)\"sv);\n    AddGLobalInsertMapEntry(\n        FuncCxaVecNew,\n        R\"(extern \"C\" void* __cxa_vec_new(void*, unsigned int, unsigned int, unsigned int, void* (*)(void*), void* (*)(void*));)\"sv);\n    AddGLobalInsertMapEntry(\n        FuncCxaVecCtor,\n        R\"(extern \"C\" void* __cxa_vec_ctor(void*, unsigned int, unsigned int, unsigned int, void* (*)(void*), void* (*)(void*));)\"sv);\n    AddGLobalInsertMapEntry(\n        FuncCxaVecDel,\n        R\"(extern \"C\" void __cxa_vec_delete(void *, unsigned int, unsigned int, void* (*destructor)(void *) );)\"sv);\n    AddGLobalInsertMapEntry(\n        FuncCxaVecDtor,\n        R\"(extern \"C\" void __cxa_vec_dtor(void *, unsigned int, unsigned int, void* (*destructor)(void *) );)\"sv);\n    AddGLobalInsertMapEntry(FuncVtableStruct, R\"(typedef int (*__vptp)();\n\nstruct __mptr\n{\n    short  d;\n    short  i;\n    __vptp f;\n};\n\nextern struct __mptr* __vtbl_array[];\n)\"sv);\n    AddGLobalInsertMapEntry(FuncCxaPureVirtual, R\"(extern \"C\" void __cxa_pure_virtual() { abort(); })\");\n\n    llvm::sys::PrintStackTraceOnErrorSignal(argv[0]);\n    llvm::cl::SetVersionPrinter(&PrintVersion);\n\n    auto opExpected = CommonOptionsParser::create(argc, argv, gInsightCategory);\n\n    if(auto err = opExpected.takeError()) {\n        llvm::errs() << toString(std::move(err)) << \"\\n\";\n        return 1;\n    }\n\n    // In STDINMode, we override the file content with the <stdin> input.\n    // Since `tool.mapVirtualFile` takes `StringRef`, we define `Code` outside of\n    // the if-block so that `Code` is not released after the if-block.\n    std::unique_ptr<llvm::MemoryBuffer> inMemoryCode{};\n\n    CommonOptionsParser& op{opExpected.get()};\n    ClangTool            tool(op.getCompilations(), op.getSourcePathList());\n\n    if(gStdinMode) {\n        if(op.getSourcePathList().size() != 1) {\n            llvm::errs() << \"Expect exactly one file path in STDINMode.\\n\"sv;\n            return 1;\n        }\n\n        llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>> codeOrErr = llvm::MemoryBuffer::getSTDIN();\n\n        if(const std::error_code errorCode = codeOrErr.getError()) {\n            llvm::errs() << errorCode.message() << \"\\n\";\n            return 1;\n        }\n\n        inMemoryCode = std::move(codeOrErr.get());\n\n        if(inMemoryCode->getBufferSize() == 0) {\n            Error(\"empty file\\n\");\n            return 1;  // Skip empty files.\n        }\n\n        llvm::StringRef sourceFilePath = op.getSourcePathList().front();\n        tool.mapVirtualFile(sourceFilePath, inMemoryCode->getBuffer());\n    }\n\n    auto prependArgument = [&](auto arg) {\n        tool.appendArgumentsAdjuster(getInsertArgumentAdjuster(arg, ArgumentInsertPosition::BEGIN));\n    };\n\n    // Special handling to spare users to figure out what include paths to add.\n\n    // For some reason, Clang on Apple seems to require an additional hint for the C++ headers.\n#ifdef __APPLE__\n    gUseLibCpp = true;\n#endif /* __APPLE__ */\n\n    if(gUseLibCpp) {\n        prependArgument(INSIGHTS_LLVM_INCLUDE_DIR);\n        prependArgument(\"-stdlib=libc++\");\n        prependArgument(\"-fexperimental-library\");\n\n#ifdef __APPLE__\n        prependArgument(\"-nostdinc++\");  // macos Monterey\n#endif                                   /* __APPLE__ */\n    }\n\n    prependArgument(INSIGHTS_CLANG_RESOURCE_INCLUDE_DIR);\n    prependArgument(INSIGHTS_CLANG_RESOURCE_DIR);\n\n    if(GetInsightsOptions().UseShow2C) {\n        EnableGlobalInsert(FuncCxaStart);\n        EnableGlobalInsert(FuncCxaAtExit);\n    }\n\n    return tool.run(newFrontendActionFactory<CppInsightFrontendAction>().get());\n}\n//-----------------------------------------------------------------------------\n"
        },
        {
          "name": "Insights.h",
          "type": "blob",
          "size": 2.6298828125,
          "content": "///////////////////////////////////////////////////////////////////////////////\n//\n// C++ Insights, copyright (C) by Andreas Fertig\n// Distributed under an MIT license. See LICENSE for details\n//\n///////////////////////////////////////////////////////////////////////////////\n\n#ifndef INSIGHTS_H\n#define INSIGHTS_H\n//-----------------------------------------------------------------------------\n\nnamespace clang {\nclass ASTContext;\nclass CompilerInstance;\n}  // namespace clang\n//-----------------------------------------------------------------------------\n\n/// \\brief Global C++ Insights command line options.\nstruct InsightsOptions\n{\n#define INSIGHTS_OPT(opt, name, deflt, description, category) bool name;\n#include \"InsightsOptions.def\"\n};\n//-----------------------------------------------------------------------------\n\n/// \\brief Get the global C++ Insights options.\nextern const InsightsOptions& GetInsightsOptions();\nextern InsightsOptions&       GetInsightsOptionsRW();\n//-----------------------------------------------------------------------------\n\n/// \\brief Get access to the ASTContext\nextern const clang::ASTContext& GetGlobalAST();\n//-----------------------------------------------------------------------------\n\n/// \\brief Get access to the CompilerInstance\nextern const clang::CompilerInstance& GetGlobalCI();\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\nenum class GlobalInserts\n{               // Headers go first\n    HeaderNew,  //!< Track whether we have at least one local static variable in this TU. If so we need to insert the\n                //!< <new> header for the placement-new.\n    HeaderException,  //!< Track whether there was a noexcept transformation requireing the exception header.\n    HeaderUtility,    //!< Track whether there was a std::move inserted.\n    HeaderStddef,     //!< Track whether we need to insert <stddef.h> in Cfront mode\n    HeaderAssert,     //!< Track whether we need to insert <assert.h> in Cfront mode\n    HeaderStdlib,     //!< Track whether we need to insert <stdlib.h> in Cfront mode\n\n    // Now all the forward declared functions\n    FuncCxaStart,\n    FuncCxaAtExit,\n    FuncMalloc,\n    FuncFree,\n    FuncMemset,\n    FuncMemcpy,\n    FuncCxaVecNew,\n    FuncCxaVecCtor,\n    FuncCxaVecDel,\n    FuncCxaVecDtor,\n    FuncVtableStruct,\n    FuncCxaPureVirtual,\n\n    // The traditional enum element count\n    MAX\n};\n//-----------------------------------------------------------------------------\n\nvoid EnableGlobalInsert(GlobalInserts);\n//-----------------------------------------------------------------------------\n}  // namespace clang::insights\n\n#endif /* INSIGHTS_H */\n"
        },
        {
          "name": "InsightsHelpers.cpp",
          "type": "blob",
          "size": 57.0380859375,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#include \"InsightsHelpers.h\"\n#include \"ASTHelpers.h\"\n#include \"ClangCompat.h\"\n#include \"CodeGenerator.h\"\n#include \"DPrint.h\"\n#include \"Insights.h\"\n#include \"InsightsStaticStrings.h\"\n#include \"OutputFormatHelper.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Sema/Lookup.h\"\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n\nScopeHandler::ScopeHandler(const Decl* d)\n: mStack{mGlobalStack}\n, mHelper{mScope.length()}\n{\n    mStack.push(mHelper);\n\n    if(const auto* recordDecl = dyn_cast_or_null<CXXRecordDecl>(d)) {\n        mScope.append(GetName(*recordDecl));\n\n        if(const auto* classTmplSpec = dyn_cast_or_null<ClassTemplateSpecializationDecl>(recordDecl)) {\n            OutputFormatHelper ofm{};\n            CodeGenerator      codeGenerator{ofm};\n            codeGenerator.InsertTemplateArgs(*classTmplSpec);\n\n            mScope.append(ofm);\n        }\n\n    } else if(const auto* namespaceDecl = dyn_cast_or_null<NamespaceDecl>(d)) {\n        mScope.append(namespaceDecl->getName());\n    }\n\n    if(not mScope.empty()) {\n        mScope.append(\"::\");\n    }\n}\n//-----------------------------------------------------------------------------\n\nScopeHandler::~ScopeHandler()\n{\n    const auto length = mStack.pop()->mLength;\n    mScope.resize(length);\n}\n//-----------------------------------------------------------------------------\n\nstd::string ScopeHandler::RemoveCurrentScope(std::string name)\n{\n    if(mScope.length()) {\n        auto findAndReplace = [&name](const std::string& scope) {\n            if(const auto startPos = name.find(scope, 0); std::string::npos != startPos) {\n                if(const auto pos = startPos + scope.length();\n                   (pos > name.length()) or (name[pos] != '*')) {  // keep member points (See #374)\n                    name.replace(startPos, scope.length(), \"\"sv);\n                    return true;\n                }\n            }\n\n            return false;\n        };\n\n        // The default is that we can replace the entire scope. Suppose we are currently in N::X and having a symbol\n        // N::X::y then N::X:: is removed.\n        if(not findAndReplace(mScope)) {\n\n            // A special case where we need to remove the scope without the last item.\n            std::string tmp{mScope};\n            tmp.resize(mGlobalStack.back().mLength);\n\n            findAndReplace(tmp);\n        }\n    }\n\n    return name;\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string GetNamePlain(const NamedDecl& decl)\n{\n    if(const auto* fd = dyn_cast_or_null<FunctionDecl>(&decl); fd and GetInsightsOptions().UseShow2C) {\n        if(fd->isOverloadedOperator()) {\n            switch(fd->getOverloadedOperator()) {\n#define OVERLOADED_OPERATOR(Name, Spelling, Token, Unary, Binary, MemberOnly)                                          \\\n    case OO_##Name: return \"operator\" #Name;\n\n#include \"clang/Basic/OperatorKinds.def\"\n\n#undef OVERLOADED_OPERATOR\n                default: break;\n            }\n        }\n    }\n\n    return decl.getDeclName().getAsString();\n}\n\nstd::string GetPlainName(const DeclRefExpr& DRE)\n{\n    return ScopeHandler::RemoveCurrentScope(GetNamePlain(*DRE.getDecl()));\n}\n//-----------------------------------------------------------------------------\n\nSTRONG_BOOL(InsightsSuppressScope);\n//-----------------------------------------------------------------------------\n\nSTRONG_BOOL(InsightsCanonicalTypes);\n//-----------------------------------------------------------------------------\n\nstatic std::string GetUnqualifiedScopelessName(const Type* type, const InsightsSuppressScope supressScope);\n//-----------------------------------------------------------------------------\n\nstruct CppInsightsPrintingPolicy : PrintingPolicy\n{\n    unsigned              CppInsightsUnqualified : 1;  // NOLINT\n    InsightsSuppressScope CppInsightsSuppressScope;    // NOLINT\n\n    CppInsightsPrintingPolicy(const Unqualified            unqualified,\n                              const InsightsSuppressScope  supressScope,\n                              const InsightsCanonicalTypes insightsCanonicalTypes = InsightsCanonicalTypes::No)\n    : PrintingPolicy{LangOptions{}}\n    {\n        adjustForCPlusPlus();\n        SuppressUnwrittenScope = true;\n        Alignof                = true;\n        ConstantsAsWritten     = true;\n        AnonymousTagLocations  = false;  // does remove filename and line for from lambdas in parameters\n        PrintCanonicalTypes    = InsightsCanonicalTypes::Yes == insightsCanonicalTypes;\n\n        CppInsightsUnqualified   = (Unqualified::Yes == unqualified);\n        CppInsightsSuppressScope = supressScope;\n    }\n\n    CppInsightsPrintingPolicy()\n    : CppInsightsPrintingPolicy{Unqualified::No, InsightsSuppressScope::No}\n    {\n    }\n};\n//-----------------------------------------------------------------------------\n\nvoid ReplaceAll(std::string& str, std::string_view from, std::string_view to)\n{\n    size_t start_pos = 0;\n    while((start_pos = str.find(from, start_pos)) != std::string::npos) {\n        str.replace(start_pos, from.length(), to);\n        start_pos += to.length();  // Handles case where 'to' is a substring of 'from'\n    }\n}\n//-----------------------------------------------------------------------------\n\nnamespace details {\nstatic void\nBuildNamespace(std::string& fullNamespace, const NestedNameSpecifier* stmt, const IgnoreNamespace ignoreNamespace)\n{\n    RETURN_IF(not stmt);\n\n    if(const auto* prefix = stmt->getPrefix();\n       prefix and not((NestedNameSpecifier::TypeSpecWithTemplate == stmt->getKind()) and\n                      isa<DependentTemplateSpecializationType>(stmt->getAsType()))) {\n        BuildNamespace(fullNamespace, prefix, ignoreNamespace);\n    }\n\n    switch(stmt->getKind()) {\n        case NestedNameSpecifier::Identifier: fullNamespace.append(stmt->getAsIdentifier()->getName()); break;\n\n        case NestedNameSpecifier::Namespace:\n            RETURN_IF((IgnoreNamespace::Yes == ignoreNamespace) or (stmt->getAsNamespace()->isAnonymousNamespace()));\n\n            fullNamespace.append(stmt->getAsNamespace()->getName());\n            break;\n\n        case NestedNameSpecifier::NamespaceAlias: fullNamespace.append(stmt->getAsNamespaceAlias()->getName()); break;\n\n        case NestedNameSpecifier::TypeSpecWithTemplate:\n            if(auto* dependentSpecType = stmt->getAsType()->getAs<DependentTemplateSpecializationType>()) {\n                fullNamespace.append(GetElaboratedTypeKeyword(dependentSpecType->getKeyword()));\n            }\n\n            [[fallthrough]];\n\n        case NestedNameSpecifier::TypeSpec:\n            fullNamespace.append(GetUnqualifiedScopelessName(stmt->getAsType(), InsightsSuppressScope::Yes));\n            // The template parameters are already contained in the type we inserted above.\n            break;\n\n        default: break;\n    }\n\n    fullNamespace.append(\"::\"sv);\n}\n//-----------------------------------------------------------------------------\n}  // namespace details\n\nstd::string GetNestedName(const NestedNameSpecifier* nns, const IgnoreNamespace ignoreNamespace)\n{\n    std::string ret{};\n\n    if(nns) {\n        details::BuildNamespace(ret, nns, ignoreNamespace);\n    }\n\n    return ret;\n}\n//-----------------------------------------------------------------------------\n\nstatic const std::string GetAsCPPStyleString(const QualType& t, const CppInsightsPrintingPolicy& printingPolicy)\n{\n    return t.getAsString(printingPolicy);\n}\n//-----------------------------------------------------------------------------\n\nstd::string BuildInternalVarName(const std::string_view& varName)\n{\n    return StrCat(\"__\", varName);\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string\nBuildInternalVarName(const std::string_view& varName, const SourceLocation& loc, const SourceManager& sm)\n{\n    const auto lineNo = sm.getSpellingLineNumber(loc);\n\n    return StrCat(BuildInternalVarName(varName), lineNo);\n}\n//-----------------------------------------------------------------------------\n\nvoid InsertBefore(std::string& source, const std::string_view& find, const std::string_view& replace)\n{\n    const std::string::size_type i = source.find(find, 0);\n\n    if(std::string::npos != i) {\n        source.insert(i, replace);\n    }\n}\n//-----------------------------------------------------------------------------\n\nstatic void InsertAfter(std::string& source, const std::string_view& find, const std::string_view& replace)\n{\n    const std::string::size_type i = source.find(find, 0);\n\n    if(std::string::npos != i) {\n        source.insert(i + find.length(), replace);\n    }\n}\n//-----------------------------------------------------------------------------\n\nstd::string MakeLineColumnName(const SourceManager& sm, const SourceLocation& loc, const std::string_view& prefix)\n{\n    // In case of a macro expansion the expansion(line/column) number gives a unique value.\n    const auto lineNo   = loc.isMacroID() ? sm.getExpansionLineNumber(loc) : sm.getSpellingLineNumber(loc);\n    const auto columnNo = loc.isMacroID() ? sm.getExpansionColumnNumber(loc) : sm.getSpellingColumnNumber(loc);\n\n    return StrCat(prefix, lineNo, \"_\"sv, columnNo);\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string MakeLineColumnName(const Decl& decl, const std::string_view prefix)\n{\n    return MakeLineColumnName(GetSM(decl), decl.getBeginLoc(), prefix);\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetLambdaName(const CXXRecordDecl& lambda)\n{\n    static constexpr auto lambdaPrefix{\"__lambda_\"sv};\n    return MakeLineColumnName(lambda, lambdaPrefix);\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string GetAnonymStructOrUnionName(const CXXRecordDecl& cxxRecordDecl)\n{\n    static constexpr auto prefix{\"__anon_\"sv};\n    return MakeLineColumnName(cxxRecordDecl, prefix);\n}\n//-----------------------------------------------------------------------------\n\nstd::string BuildRetTypeName(const Decl& decl)\n{\n    static constexpr auto retTypePrefix{\"retType_\"sv};\n    return MakeLineColumnName(decl, retTypePrefix);\n}\n//-----------------------------------------------------------------------------\n\nconst QualType GetDesugarType(const QualType& QT)\n{\n    if(QT.getTypePtrOrNull()) {\n        if(const auto* autoType = QT->getAs<clang::AutoType>(); autoType and autoType->isSugared()) {\n            const auto dt = autoType->getDeducedType();\n\n            if(const auto* et = dt->getAs<ElaboratedType>()) {\n                return et->getNamedType();\n            } else {\n                return dt;\n            }\n\n        } else if(auto declType = QT->getAs<clang::DecltypeType>()) {\n            return declType->desugar();\n        }\n    }\n    return QT;\n}\n//-----------------------------------------------------------------------------\n\nconst std::string EvaluateAsFloat(const FloatingLiteral& expr)\n{\n    SmallString<16> str{};\n    expr.getValue().toString(str);\n\n    if(std::string::npos == str.find('.')) {\n        /* in case it is a number like 10.0 toString() seems to leave out the .0. However, as this distinguished\n         * between an integer and a floating point literal we need that dot. */\n        str.append(\".0\"sv);\n    }\n\n    return std::string{str.str()};\n}\n//-----------------------------------------------------------------------------\n\nstatic const VarDecl* GetVarDeclFromDeclRefExpr(const DeclRefExpr& declRefExpr)\n{\n    const auto* valueDecl = declRefExpr.getDecl();\n\n    return dyn_cast_or_null<VarDecl>(valueDecl);\n}\n//-----------------------------------------------------------------------------\n\n// own implementation due to lambdas\nstd::string GetDeclContext(const DeclContext* ctx, WithTemplateParameters withTemplateParameters)\n{\n    OutputFormatHelper                 mOutputFormatHelper{};\n    SmallVector<const DeclContext*, 8> contexts{};\n\n    while(ctx) {\n        if(isa<NamedDecl>(ctx)) {\n            contexts.push_back(ctx);\n        }\n        ctx = ctx->getParent();\n    }\n\n    for(const auto* declContext : llvm::reverse(contexts)) {\n        if(const auto* classTmplSpec = dyn_cast<ClassTemplateSpecializationDecl>(declContext)) {\n            mOutputFormatHelper.Append(classTmplSpec->getName());\n\n            CodeGenerator codeGenerator{mOutputFormatHelper};\n            codeGenerator.InsertTemplateArgs(*classTmplSpec);\n\n        } else if(const auto* nd = dyn_cast<NamespaceDecl>(declContext)) {\n            if(nd->isAnonymousNamespace() or nd->isInline()) {\n                continue;\n            }\n\n            mOutputFormatHelper.Append(nd->getName());\n\n        } else if(const auto* rd = dyn_cast<RecordDecl>(declContext)) {\n            if(not rd->getIdentifier()) {\n                continue;\n            }\n\n            mOutputFormatHelper.Append(rd->getName());\n\n            // A special case at least for out-of-line static member variables of a class template. They need to carry\n            // the template parameters of the class template.\n            if(WithTemplateParameters::Yes == withTemplateParameters /*declContext->isNamespace() or declContext->getLexicalParent()->isNamespace() or declContext->getLexicalParent()->isTranslationUnit()*/) {\n                if(const auto* cxxRecordDecl = dyn_cast_or_null<CXXRecordDecl>(rd)) {\n                    if(const auto* classTmpl = cxxRecordDecl->getDescribedClassTemplate()) {\n                        CodeGenerator codeGenerator{mOutputFormatHelper};\n                        codeGenerator.InsertTemplateParameters(*classTmpl->getTemplateParameters(),\n                                                               CodeGenerator::TemplateParamsOnly::Yes);\n                    }\n                }\n            }\n\n        } else if(dyn_cast<FunctionDecl>(declContext)) {\n            continue;\n\n        } else if(const auto* ed = dyn_cast<EnumDecl>(declContext)) {\n            if(not ed->isScoped()) {\n                continue;\n            }\n\n            mOutputFormatHelper.Append(ed->getName());\n\n        } else {\n            mOutputFormatHelper.Append(cast<NamedDecl>(declContext)->getName());\n        }\n\n        mOutputFormatHelper.Append(\"::\"sv);\n    }\n\n    return mOutputFormatHelper.GetString();\n}\n//-----------------------------------------------------------------------------\n\nnamespace details {\n\nSTRONG_BOOL(RemoveCurrentScope);  ///!< In some cases we need to keep the scope for a while, so don't remove the scope\n                                  /// we are in right now.\n//-----------------------------------------------------------------------------\n\nstatic std::string GetQualifiedName(const NamedDecl&         decl,\n                                    const RemoveCurrentScope removeCurrentScope = RemoveCurrentScope::Yes)\n{\n    std::string scope{GetDeclContext(decl.getDeclContext())};\n\n    scope += decl.getName();\n\n    if(RemoveCurrentScope::Yes == removeCurrentScope) {\n        return ScopeHandler::RemoveCurrentScope(scope);\n    }\n\n    return scope;\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string GetScope(const DeclContext*       declCtx,\n                            const RemoveCurrentScope removeCurrentScope = RemoveCurrentScope::Yes)\n{\n    std::string name{};\n\n    if(not declCtx->isTranslationUnit() and not declCtx->isFunctionOrMethod()) {\n        while(declCtx->isInlineNamespace()) {\n            declCtx = declCtx->getParent();\n        }\n\n        if(not declCtx->isTranslationUnit() and (declCtx->isNamespace() or declCtx->getParent()->isTranslationUnit())) {\n            if(const auto* namedDecl = dyn_cast_or_null<NamedDecl>(declCtx)) {\n                name = GetQualifiedName(*namedDecl, removeCurrentScope);\n                name.append(\"::\"sv);\n            }\n        }\n    }\n\n    return name;\n}\n//-----------------------------------------------------------------------------\n\n/// \\brief SimpleTypePrinter a partially substitution of Clang's TypePrinter.\n///\n/// With Clang 9 there seems to be a change in `lib/AST/TypePrinter.cpp` in `printTemplateTypeParmBefore`. It now\n/// inserts `auto` when it is a lambda auto parameter. Which is correct, but C++ Insights needs the\n/// template parameter name to make up compiling code. Hence, this `if` \"overrides\" the implementation of\n/// TypePrinter in that case.\n///\n/// It also drops some former code which handled `ClassTemplateSpecializationDecl` in a special way. Here the template\n/// parameters can be lambdas. Those they need a proper name.\nclass SimpleTypePrinter\n{\nprivate:\n    const QualType&                  mType;\n    const CppInsightsPrintingPolicy& mPrintingPolicy;\n    OutputFormatHelper               mData{};\n    std::string                      mDataAfter{};\n    bool                             mHasData{false};\n    bool                             mSkipSpace{false};\n    bool mScanningArrayDimension{};  //!< Only the outer most ConstantArrayType handles the array dimensions and size\n    std::string mScope{};            //!< A scope coming from an ElaboratedType which is used for a\n                                     //!< ClassTemplateSpecializationDecl if there is no other scope\n\n    bool HandleType(const TemplateTypeParmType* type)\n    {\n        const TemplateTypeParmDecl* decl = type->getDecl();\n\n        if((nullptr == type->getIdentifier()) or\n           (decl and decl->isImplicit()) /* this fixes auto operator()(type_parameter_0_0 container) const */) {\n\n            AppendTemplateTypeParamName(mData, decl, true, type);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    bool HandleType(const LValueReferenceType* type)\n    {\n        mDataAfter += \" &\"sv;\n\n        return HandleType(type->getPointeeType().getTypePtrOrNull());\n    }\n\n    bool HandleType(const RValueReferenceType* type)\n    {\n        mDataAfter += \" &&\"sv;\n\n        return HandleType(type->getPointeeType().getTypePtrOrNull());\n    }\n\n    bool HandleType(const PointerType* type)\n    {\n        mDataAfter += \" *\"sv;\n\n        return HandleType(type->getPointeeType().getTypePtrOrNull());\n    }\n\n    bool HandleType(const InjectedClassNameType* type) { return HandleType(type->getInjectedTST()); }\n\n    bool HandleType(const RecordType* type)\n    {\n        /// In case one of the template parameters is a lambda we need to insert the made up name.\n        if(const auto* tt = dyn_cast_or_null<ClassTemplateSpecializationDecl>(type->getDecl())) {\n            if(const auto* identifierName = mType.getBaseTypeIdentifier()) {\n                const auto& scope = GetScope(type->getDecl()->getDeclContext());\n\n                // If we don't have a scope with GetScope use a possible one from ElaboratedType\n                if((InsightsSuppressScope::Yes == mPrintingPolicy.CppInsightsSuppressScope) or scope.empty()) {\n                    mData.Append(mScope);\n                } else {\n                    mData.Append(scope);\n                }\n\n                mData.Append(identifierName->getName());\n                CodeGenerator codeGenerator{mData};\n                codeGenerator.InsertTemplateArgs(*tt);\n\n                return true;\n            }\n        } else if(const auto* cxxRecordDecl = type->getAsCXXRecordDecl()) {\n            // Special handling for dependent types. For example, ClassOperatorHandler7Test.cpp A<...* >::B.\n            if(type->isDependentType()) {\n                std::string context{GetDeclContext(type->getDecl()->getDeclContext())};\n\n                if(not context.empty()) {\n                    mData.Append(std::move(context));\n                    mData.Append(cxxRecordDecl->getName());\n\n                    return true;\n                }\n            }\n\n            if(cxxRecordDecl->isLambda()) {\n                mData.Append(GetLambdaName(*cxxRecordDecl));\n\n                return true;\n            }\n\n            // Handle anonymous struct or union.\n            if(IsAnonymousStructOrUnion(cxxRecordDecl)) {\n                mData.Append(GetAnonymStructOrUnionName(*cxxRecordDecl));\n\n                return true;\n            }\n\n            // we need a name here, as DecltypeType always says true\n            mData.Append(GetName(*cxxRecordDecl));\n        }\n\n        return false;\n    }\n\n    bool HandleType(const AutoType* type) { return HandleType(type->getDeducedType().getTypePtrOrNull()); }\n\n    bool HandleType(const SubstTemplateTypeParmType* type)\n    {\n        return HandleType(type->getReplacementType().getTypePtrOrNull());\n    }\n\n    bool HandleType(const ElaboratedType* type)\n    {\n        const IgnoreNamespace ignoreNamespace = (mPrintingPolicy.CppInsightsSuppressScope == InsightsSuppressScope::Yes)\n                                                    ? IgnoreNamespace::No\n                                                    : IgnoreNamespace::Yes;\n\n        mScope = GetNestedName(type->getQualifier(), ignoreNamespace);\n\n        const bool ret = HandleType(type->getNamedType().getTypePtrOrNull());\n\n        mScope.clear();\n\n        return ret;\n    }\n\n    bool HandleType(const DependentTemplateSpecializationType* type)\n    {\n        mData.Append(GetElaboratedTypeKeyword(type->getKeyword()),\n                     GetNestedName(type->getQualifier()),\n                     kwTemplateSpace,\n                     type->getIdentifier()->getName());\n\n        CodeGenerator codeGenerator{mData};\n        codeGenerator.InsertTemplateArgs(*type);\n\n        return true;\n    }\n\n    bool HandleType(const DeducedTemplateSpecializationType* type)\n    {\n        return HandleType(type->getDeducedType().getTypePtrOrNull());\n    }\n\n    bool HandleType(const TemplateSpecializationType* type)\n    {\n        if(type->getAsRecordDecl()) {\n            // Only if it was some sort of \"used\" `RecordType` we continue here.\n            if(HandleType(type->getAsRecordDecl()->getTypeForDecl())) {\n                HandleType(type->getPointeeType().getTypePtrOrNull());\n                return true;\n            }\n        }\n\n        /// This is a specialty discovered with #188_2. In some cases there is a `TemplateTypeParmDecl` which has no\n        /// identifier name. Then it will end up as `type-parameter-...`. At least in #188_2: _Head_base<_Idx,\n        /// type_parameter_0_1, true> the repetition of the template specialization arguments is not required.\n        /// `hasNoName` tries to detect this case and does then print the name of the template only.\n        const bool hasNoName{[&] {\n            for(const auto& arg : type->template_arguments()) {\n                StringStream sstream{};\n                sstream.Print(arg);\n\n                if(Contains(sstream.str(), \"type-parameter\"sv)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }()};\n\n        if(hasNoName) {\n            StringStream sstream{};\n            sstream.Print(*type);\n\n            mData.Append(sstream.str());\n\n            return true;\n        }\n\n        return false;\n    }\n\n    bool HandleType(const MemberPointerType* type)\n    {\n        HandleType(type->getPointeeType().getTypePtrOrNull());\n\n        mData.Append('(');\n\n        const bool ret = HandleType(type->getClass());\n\n        mData.Append(\"::*)\"sv);\n\n        HandleTypeAfter(type->getPointeeType().getTypePtrOrNull());\n\n        return ret;\n    }\n\n    bool HandleType(const FunctionProtoType* type) { return HandleType(type->getReturnType().getTypePtrOrNull()); }\n\n    void HandleTypeAfter(const FunctionProtoType* type)\n    {\n        mData.Append('(');\n\n        mSkipSpace = true;\n        for(OnceFalse needsComma{}; const auto& t : type->getParamTypes()) {\n            if(needsComma) {\n                mData.Append(\", \"sv);\n            }\n\n            HandleType(t.getTypePtrOrNull());\n        }\n\n        mSkipSpace = false;\n\n        mData.Append(')');\n\n        if(not type->getMethodQuals().empty()) {\n            mData.Append(\" \"sv, type->getMethodQuals().getAsString());\n        }\n\n        /// Currently, we are skipping `T->getRefQualifier()` and the exception specification, as well as the trailing\n        /// return type.\n    }\n\n    bool HandleType(const BuiltinType* type)\n    {\n        mData.Append(type->getName(mPrintingPolicy));\n\n        if(not mSkipSpace) {\n            mData.Append(' ');\n        }\n\n        return false;\n    }\n\n    bool HandleType(const TypedefType* type)\n    {\n        if(const auto* decl = type->getDecl()) {\n            /// Another filter place for type-parameter where it is contained in the FQN but leads to none compiling\n            /// code. Remove it to keep the code valid.\n            if(Contains(decl->getQualifiedNameAsString(), \"type-parameter\"sv)) {\n                auto* identifierInfo = decl->getIdentifier();\n                mData.Append(identifierInfo->getName());\n\n                return true;\n            }\n\n            return HandleType(decl->getUnderlyingType().getTypePtrOrNull());\n        }\n\n        return HandleType(type->getPointeeType().getTypePtrOrNull());\n    }\n\n    bool HandleType(const ConstantArrayType* type)\n    {\n        // Only the outer most ConstantArrayType generates the aary dimensions, block others.\n        bool scanningArrayDimension = false;\n        if(not mScanningArrayDimension) {\n            mScanningArrayDimension = true;\n            scanningArrayDimension  = true;\n        }\n\n        const bool ret = HandleType(type->getElementType().getTypePtrOrNull());\n\n        // Handle the array dimension after the type has been parsed.\n        if(scanningArrayDimension) {\n            do {\n                mData.Append(\"[\"sv, GetSize(type), \"]\"sv);\n            } while((type = dyn_cast_or_null<ConstantArrayType>(type->getElementType().getTypePtrOrNull())));\n\n            mScanningArrayDimension = false;\n        }\n\n        return ret;\n    }\n\n    bool HandleType(const PackExpansionType* type)\n    {\n        const bool ret = HandleType(type->getPattern().getTypePtrOrNull());\n\n        if(ret) {\n            mData.Append(kwElipsis);\n        }\n\n        return ret;\n    }\n\n    bool HandleType(const DecltypeType* type)\n    {\n        // A DecltypeType in a template definition is unevaluated and refers ti itself. This check ensures, that in such\n        // a situation no expansion is performed.\n        if(not isa_and_nonnull<DecltypeType>(type->desugar().getTypePtrOrNull())) {\n            const bool skipSpace{mSkipSpace};\n            mSkipSpace = true;\n\n            HandleType(type->desugar().getTypePtrOrNull());\n\n            mSkipSpace = skipSpace;\n\n            // if we hit a DecltypeType always use the expanded version to support things like a DecltypeType wrapped in\n            // an LValueReferenceType\n            return true;\n        }\n\n        if(not isa_and_nonnull<DeclRefExpr>(type->getUnderlyingExpr())) {\n            P0315Visitor visitor{mData};\n\n            return not visitor.TraverseStmt(type->getUnderlyingExpr());\n        }\n\n        return false;\n    }\n\n    bool HandleType(const Type* type)\n    {\n#define HANDLE_TYPE(t)                                                                                                 \\\n    if(isa<t>(type)) {                                                                                                 \\\n        return HandleType(dyn_cast_or_null<t>(type));                                                                  \\\n    }\n\n        if(nullptr == type) {\n            return false;\n        }\n\n        HANDLE_TYPE(FunctionProtoType);\n        HANDLE_TYPE(PointerType);\n        HANDLE_TYPE(LValueReferenceType);\n        HANDLE_TYPE(RValueReferenceType);\n        HANDLE_TYPE(TemplateTypeParmType);\n        HANDLE_TYPE(RecordType);\n        HANDLE_TYPE(AutoType);\n        HANDLE_TYPE(SubstTemplateTypeParmType);\n        HANDLE_TYPE(ElaboratedType);\n        HANDLE_TYPE(TemplateSpecializationType);\n        HANDLE_TYPE(DeducedTemplateSpecializationType);\n        HANDLE_TYPE(MemberPointerType);\n        HANDLE_TYPE(BuiltinType);\n        HANDLE_TYPE(TypedefType);\n        HANDLE_TYPE(ConstantArrayType);\n        HANDLE_TYPE(InjectedClassNameType);\n        HANDLE_TYPE(DependentTemplateSpecializationType);\n        HANDLE_TYPE(PackExpansionType);\n        HANDLE_TYPE(DecltypeType);\n\n#undef HANDLE_TYPE\n        return false;\n    }\n\n    void HandleTypeAfter(const Type* type)\n    {\n#define HANDLE_TYPE(t)                                                                                                 \\\n    if(isa<t>(type)) {                                                                                                 \\\n        HandleTypeAfter(dyn_cast_or_null<t>(type));                                                                    \\\n    }\n\n        if(nullptr != type) {\n            HANDLE_TYPE(FunctionProtoType);\n        }\n    }\n\n    void AddCVQualifiers(const Qualifiers& quals)\n    {\n        if((false == mPrintingPolicy.CppInsightsUnqualified) and not quals.empty()) {\n            mData.Append(quals.getAsString());\n\n            if(not mData.empty() and not mSkipSpace) {\n                mData.Append(' ');\n            }\n        }\n    }\n\npublic:\n    SimpleTypePrinter(const QualType& qt, const CppInsightsPrintingPolicy& printingPolicy)\n    : mType{qt}\n    , mPrintingPolicy{printingPolicy}\n    {\n    }\n\n    std::string& GetString() { return mData.GetString(); }\n\n    bool GetTypeString()\n    {\n        if(const SplitQualType splitted{mType.split()}; splitted.Quals.empty()) {\n            const auto& canonicalType = mType.getCanonicalType();\n\n            if(canonicalType->getPointeeType().getLocalFastQualifiers()) {\n                AddCVQualifiers(canonicalType->getPointeeType().getLocalQualifiers());\n            } else if(canonicalType.getLocalFastQualifiers()) {\n                AddCVQualifiers(canonicalType.getLocalQualifiers());\n            }\n        } else {\n            AddCVQualifiers(splitted.Quals);\n        }\n\n        const auto* typePtr = mType.getTypePtrOrNull();\n        mHasData            = HandleType(typePtr);\n        mData.Append(mDataAfter);\n\n        // Take care of 'char* const'\n        if(mType.getQualifiers().hasFastQualifiers()) {\n            const QualType fastQualifierType{typePtr, mType.getQualifiers().getFastQualifiers()};\n\n            mSkipSpace = true;\n            AddCVQualifiers(fastQualifierType.getCanonicalType()->getPointeeType().getLocalQualifiers());\n        }\n\n        return mHasData;\n    }\n};\n//-----------------------------------------------------------------------------\n\nstatic std::string GetName(QualType                    t,\n                           const Unqualified           unqualified  = Unqualified::No,\n                           const InsightsSuppressScope supressScope = InsightsSuppressScope::No)\n{\n    const CppInsightsPrintingPolicy printingPolicy{unqualified,\n                                                   supressScope,\n                                                   (isa<AutoType>(t.getTypePtrOrNull())) ? InsightsCanonicalTypes::Yes\n                                                                                         : InsightsCanonicalTypes::No};\n\n    QualType tt = t;\n\n    if(const auto* et = tt->getAs<ElaboratedType>()) {\n        if((nullptr == et->getQualifier()) and (nullptr == et->getOwnedTagDecl())) {\n            const auto quals = tt.getLocalFastQualifiers();\n            tt               = et->getNamedType();\n            tt.setLocalFastQualifiers(quals);\n        }\n    }\n\n    if(SimpleTypePrinter st{t, printingPolicy}; st.GetTypeString()) {\n        return ScopeHandler::RemoveCurrentScope(st.GetString());\n\n    } else if(true == printingPolicy.CppInsightsUnqualified) {\n        return ScopeHandler::RemoveCurrentScope(GetAsCPPStyleString(tt.getUnqualifiedType(), printingPolicy));\n    }\n\n    return ScopeHandler::RemoveCurrentScope(GetAsCPPStyleString(tt, printingPolicy));\n}\n}  // namespace details\n//-----------------------------------------------------------------------------\n\nstatic bool HasOverload(const FunctionDecl* fd)\n{\n    auto* ncfd = const_cast<FunctionDecl*>(fd);\n\n    Sema&        sema = GetGlobalCI().getSema();\n    LookupResult result{sema, ncfd->getDeclName(), {}, Sema::LookupOrdinaryName};\n\n    if(sema.LookupName(result, sema.getScopeForContext(ncfd->getDeclContext()))) {\n        return LookupResult::FoundOverloaded == result.getResultKind();\n    }\n\n    return false;\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetSpecialMemberName(const ValueDecl* vd);\n//-----------------------------------------------------------------------------\n\nstd::string GetCfrontOverloadedFunctionName(const FunctionDecl* fd)\n{\n    std::string name{};\n\n    if(fd and GetInsightsOptions().UseShow2C and HasOverload(fd) and not fd->isMain()) {\n        name = GetSpecialMemberName(fd);\n\n        if(not fd->param_empty()) {\n            name += \"_\";\n\n            for(const auto& param : fd->parameters()) {\n                QualType t         = param->getType();\n                QualType plainType = t.getNonReferenceType();\n                plainType.removeLocalConst();\n                plainType.removeLocalVolatile();\n\n                std::string ptr{};\n\n                while(plainType->isPointerType()) {\n                    ptr += \"p\";\n                    plainType = plainType->getPointeeType();\n\n                    auto quals  = plainType.getQualifiers();\n                    auto lquals = plainType.getLocalQualifiers();\n\n                    if(quals.hasConst() or lquals.hasConst()) {\n                        ptr += \"c\";\n                    }\n\n                    plainType.removeLocalConst();\n                }\n\n                if(t.isCanonical()) {\n                    t = t.getCanonicalType();\n                }\n\n                if(plainType->isBuiltinType() and plainType->hasUnsignedIntegerRepresentation()) {\n                    std::string tmp{GetName(plainType)};\n\n                    ReplaceAll(tmp, \"unsigned \", \"u\");\n\n                    name += tmp;\n                } else {\n                    name += GetName(plainType);\n                }\n\n                auto quals  = t.getQualifiers();\n                auto lquals = t.getLocalQualifiers();\n\n                if(t->isPointerType()) {\n                    name += ptr;\n                }\n\n                if(quals.hasConst() or lquals.hasConst()) {\n                    name += \"c\";\n                }\n\n                if(t->isLValueReferenceType()) {\n                    name += \"r\";\n                }\n\n                if(t->isRValueReferenceType()) {\n                    name += \"R\";\n                }\n            }\n        }\n    } else if(const auto* md = dyn_cast_or_null<CXXMethodDecl>(fd);\n              md and GetInsightsOptions().UseShow2C and md->isVirtual()) {\n        name = GetName(*md->getParent());\n    }\n\n    return name;\n}\n//-----------------------------------------------------------------------------\n\nSTRONG_BOOL(UseLexicalParent);\n//-----------------------------------------------------------------------------\n\nstatic bool NeedsNamespace(const Decl& decl, UseLexicalParent useLexicalParent)\n{\n    const auto* declCtx = decl.getDeclContext();\n    if(UseLexicalParent::Yes == useLexicalParent) {\n        declCtx = declCtx->getLexicalParent();\n    }\n\n    if(nullptr == declCtx) {\n        return false;\n    }\n\n    const bool isFriend{(decl.getFriendObjectKind() != Decl::FOK_None)};\n    const bool neitherTransparentNorFriend{not declCtx->isTransparentContext() and not isFriend};\n\n    if(UseLexicalParent::Yes == useLexicalParent) {\n        return (declCtx->isNamespace() and not declCtx->isInlineNamespace()) and neitherTransparentNorFriend;\n    }\n\n    return (declCtx->isNamespace() or declCtx->isInlineNamespace()) and neitherTransparentNorFriend;\n}\n//-----------------------------------------------------------------------------\n\nstatic const SubstTemplateTypeParmType* GetSubstTemplateTypeParmType(const Type* t)\n{\n    if(const auto* substTemplateTypeParmType = dyn_cast_or_null<SubstTemplateTypeParmType>(t)) {\n        return substTemplateTypeParmType;\n    } else if(const auto& pointeeType = t->getPointeeType(); not pointeeType.isNull()) {\n        return GetSubstTemplateTypeParmType(pointeeType.getTypePtrOrNull());\n    }\n\n    return nullptr;\n}\n//-----------------------------------------------------------------------------\n\nstatic const DeclRefExpr* FindVarDeclRef(const Stmt* stmt)\n{\n    if(const auto* dref = dyn_cast_or_null<DeclRefExpr>(stmt)) {\n        if(const auto* vd = dyn_cast_or_null<VarDecl>(dref->getDecl())) {\n            return dref;\n        }\n    }\n\n    if(stmt) {\n        for(const auto* child : stmt->children()) {\n            if(const auto* childRef = FindVarDeclRef(child)) {\n                return childRef;\n            }\n        }\n    }\n\n    return nullptr;\n}\n//-----------------------------------------------------------------------------\n\n/*\n * \\brief Get a usable name from a template parameter pack.\n *\n * A template parameter pack, args, as in:\n * \\code\ntemplate<typename F, typename ...Types>\nauto forward(F f, Types &&...args) {\n  f(args...);\n}\n\nforward(f,1, 2,3);\n * \\endcode\n *\n * gets expanded by clang as\n * \\code\nf(args, args, args);\n * \\endcode\n *\n * which would obviously not compile. For clang AST dump it is the right thing. For C++ Insights where the resulting\n * code should be compilable it is not. What this function does is, figure out whether it is a pack expansion and if so,\n * make the parameters unique, such that \\c args becomes \\c __args1 to \\c __args3.\n *\n * The expected type for \\c T currently is \\c ValueDecl or \\c VarDecl.\n */\nstatic std::string GetTemplateParameterPackArgumentName(std::string_view name, const Decl* decl)\n{\n    if(const auto* parmVarDecl = dyn_cast_or_null<ParmVarDecl>(decl)) {\n        if(const auto& originalType = parmVarDecl->getOriginalType(); not originalType.isNull()) {\n            if(const auto* substTemplateTypeParmType = GetSubstTemplateTypeParmType(originalType.getTypePtrOrNull());\n               substTemplateTypeParmType and substTemplateTypeParmType->getReplacedParameter()->isParameterPack()) {\n                return StrCat(BuildInternalVarName(name), parmVarDecl->getFunctionScopeIndex());\n\n            } else if(const auto* fd = parmVarDecl->getParentFunctionOrMethod()) {\n                // Get the primary template, if possible and check whether its parameters contain a parameter pack\n                if(const auto* primTmpl = dyn_cast_or_null<FunctionDecl>(fd)->getPrimaryTemplate();\n                   primTmpl and primTmpl->getTemplateParameters()->hasParameterPack()) {\n                    // if so, then search for the matching parameter name.\n                    for(const auto* pa : primTmpl->getTemplatedDecl()->parameters()) {\n                        // if one is found we suffix it with its function scope index\n                        if(pa->isParameterPack() and (parmVarDecl->getNameAsString() == pa->getNameAsString())) {\n                            return StrCat(BuildInternalVarName(name), parmVarDecl->getFunctionScopeIndex());\n                        }\n                    }\n                }\n            }\n        }\n    } else if(const auto* varDecl = dyn_cast_or_null<VarDecl>(decl)) {\n        // If it is an init-capture in C++2a p0780 brings \"Allow pack expansion in lambda init-capture\". We\n        // need to figure out, whether the initializer for this \\c VarDecl comes from a parameter pack. If\n        // so, then we use this ParmVarDecl to get the index.\n        if(varDecl->isInitCapture()) {\n            if(const auto* drefExpr = FindVarDeclRef(varDecl->getInit())) {\n                if(const auto* parmVarDecl = dyn_cast_or_null<ParmVarDecl>(drefExpr->getDecl())) {\n                    return GetTemplateParameterPackArgumentName(name, parmVarDecl);\n                }\n            }\n        }\n    }\n\n    return std::string{name};\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetName(const NamedDecl& nd, const QualifiedName qualifiedName)\n{\n    std::string name{};\n\n    if(NeedsNamespace(nd, UseLexicalParent::No) or (QualifiedName::Yes == qualifiedName)) {\n        if(const auto* cxxMedthodDecl = dyn_cast_or_null<CXXMethodDecl>(&nd)) {\n            if(cxxMedthodDecl->isLambdaStaticInvoker()) {\n                name = GetName(*cxxMedthodDecl->getParent());\n            }\n        }\n\n        name += details::GetScope(nd.getDeclContext(), details::RemoveCurrentScope::No);\n    }\n\n    name += GetNamePlain(nd);\n\n    name += GetCfrontOverloadedFunctionName(dyn_cast_or_null<FunctionDecl>(&nd));\n\n    return ScopeHandler::RemoveCurrentScope(GetTemplateParameterPackArgumentName(name, &nd));\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetName(const CXXRecordDecl& RD)\n{\n    if(RD.isLambda()) {\n        return GetLambdaName(RD);\n    }\n\n    // get the namespace as well\n    if(NeedsNamespace(RD, UseLexicalParent::Yes)) {\n        return details::GetQualifiedName(RD);\n    }\n\n    std::string ret{GetNestedName(RD.getQualifier())};\n\n    if(auto name = RD.getName(); not name.empty()) {\n        ret += name;\n\n    } else {\n        ret += GetAnonymStructOrUnionName(RD);\n    }\n\n    return ScopeHandler::RemoveCurrentScope(ret);\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetTemporaryName(const Expr& tmp)\n{\n    return BuildInternalVarName(MakeLineColumnName(GetGlobalAST().getSourceManager(), tmp.getEndLoc(), \"temporary\"sv));\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetName(const CXXTemporaryObjectExpr& tmp)\n{\n    return GetTemporaryName(tmp);\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetName(const QualType& t, const Unqualified unqualified)\n{\n    return details::GetName(t, unqualified);\n}\n//-----------------------------------------------------------------------------\n\nstatic std::string GetUnqualifiedScopelessName(const Type* type, const InsightsSuppressScope supressScope)\n{\n    return details::GetName(QualType(type, 0), Unqualified::Yes, supressScope);\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetUnqualifiedScopelessName(const Type* type)\n{\n    return GetUnqualifiedScopelessName(type, InsightsSuppressScope::No);\n}\n//-----------------------------------------------------------------------------\n\nQualType GetType(QualType t)\n{\n    if(GetInsightsOptions().UseShow2C and t->isReferenceType()) {\n        return GetGlobalAST().getPointerType(t.getNonReferenceType());\n    }\n\n    return t;\n}\n//-----------------------------------------------------------------------------\n\ntemplate<typename QT, typename SUB_T, typename SUB_T2 = void>\nstatic bool HasTypeWithSubType(const QualType& t)\n{\n    if(const auto* lref = dyn_cast_or_null<QT>(t.getTypePtrOrNull())) {\n        const auto  subType      = GetDesugarType(lref->getPointeeType());\n        const auto& ct           = subType.getCanonicalType();\n        const auto* plainSubType = ct.getTypePtrOrNull();\n\n        if(const auto* st = dyn_cast_or_null<SUB_T>(plainSubType)) {\n            if constexpr(std::is_same_v<void, SUB_T2>) {\n                return true;\n\n            } else {\n                const auto  subType      = GetDesugarType(st->getPointeeType());\n                const auto& ct           = subType.getCanonicalType();\n                const auto* plainSubType = ct.getTypePtrOrNull();\n\n                return isa<SUB_T2>(plainSubType);\n            }\n        }\n    }\n\n    return false;\n}\n//-----------------------------------------------------------------------------\n\ntemplate<typename QT, typename SUB_T>\nstatic bool HasTypePath(const QualType& t)\n{\n    if(const auto* lref = dyn_cast_or_null<QT>(t.getTypePtrOrNull())) {\n        const auto subType = GetDesugarType(lref->getPointeeType());\n\n        return isa<SUB_T>(subType);\n    }\n\n    return false;\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetTypeNameAsParameter(const QualType& t, std::string_view varName, const Unqualified unqualified)\n{\n    const bool isFunctionPointer =\n        HasTypeWithSubType<ReferenceType, FunctionProtoType>(t.getCanonicalType()) or\n        HasTypeWithSubType<ReferenceType, PointerType, FunctionProtoType>(t.getCanonicalType());\n    const bool isArrayRef = HasTypeWithSubType<ReferenceType, ArrayType>(t);\n    // Special case for Issue81, auto returns an array-ref and to catch auto deducing an array (Issue106)\n    const bool isAutoType             = (nullptr != dyn_cast_or_null<AutoType>(t.getTypePtrOrNull()));\n    const auto pointerToArrayBaseType = isAutoType ? t->getContainedAutoType()->getDeducedType() : t;\n    const bool isPointerToArray       = HasTypeWithSubType<PointerType, ArrayType>(pointerToArrayBaseType);\n    // Only treat this as an array if it is a top-level arry. Typdef's et all can hide the arrayness.\n    const bool isRawArrayType =\n        t->isArrayType() and not(isa<TypedefType>(t) or isa<ElaboratedType>(t) or isa<UsingType>(t));\n\n    std::string typeName = details::GetName(t, unqualified);\n\n    // Sometimes we get char const[2]. If we directly insert the typename we end up with char const__var[2] which is not\n    // a valid type name. Hence check for this condition and, if necessary, insert a space before __var.\n    auto getSpaceOrEmpty = [&](const std::string_view& needle) -> std::string_view {\n        if(not Contains(typeName, needle)) {\n            return \" \";\n        }\n\n        return {};\n    };\n\n    if(isRawArrayType and not t->isLValueReferenceType()) {\n        const auto space = getSpaceOrEmpty(\" [\"sv);\n        InsertBefore(typeName, \"[\"sv, StrCat(space, varName));\n\n    } else if(isArrayRef) {\n        const bool             isRValueRef{HasTypeWithSubType<RValueReferenceType, ArrayType>(t)};\n        const std::string_view contains{isRValueRef ? \"(&&\" : \"(&\"};\n\n        if(Contains(typeName, contains)) {\n            InsertAfter(typeName, contains, varName);\n        } else {\n            const std::string_view insertBefore{isRValueRef ? \"&&[\" : \"&[\"};\n\n            InsertBefore(typeName, insertBefore, \"(\"sv);\n\n            // check whether we are dealing with a function or an array\n            if(Contains(typeName, contains)) {\n                InsertAfter(typeName, contains, StrCat(varName, \")\"sv));\n            } else {\n                InsertAfter(typeName, typeName, StrCat(\" \"sv, varName));\n            }\n        }\n\n    } else if(isFunctionPointer) {\n        const bool isRValueRef{HasTypeWithSubType<RValueReferenceType, FunctionProtoType>(t)};\n        const auto contains{[&]() {\n            if(isRValueRef) {\n                return \"(&&\"sv;\n            }\n\n            else if(HasTypeWithSubType<LValueReferenceType, PointerType, FunctionProtoType>(t)) {\n                return \"(*&\"sv;\n            } else {\n                return \"(&\"sv;\n            }\n        }()};\n\n        if(Contains(typeName, contains)) {\n            InsertAfter(typeName, contains, varName);\n        } else {\n            typeName += StrCat(\" \"sv, varName);\n        }\n\n    } else if(isa<MemberPointerType>(t)) {\n        InsertAfter(typeName, \"::*\"sv, varName);\n\n    } else if(isPointerToArray) {\n        if(Contains(typeName, \"(*\"sv)) {\n            InsertAfter(typeName, \"(*\"sv, varName);\n        } else if(Contains(typeName, \"*\"sv)) {\n            InsertBefore(typeName, \"*\"sv, \"(\"sv);\n            InsertAfter(typeName, \"*\"sv, StrCat(varName, \")\"sv));\n        }\n    } else if(t->isFunctionPointerType()) {\n        if(Contains(typeName, \"(*\"sv)) {\n            InsertAfter(typeName, \"(*\"sv, varName);\n        } else {\n            typeName += StrCat(\" \"sv, varName);\n        }\n    } else if(HasTypePath<PointerType, ParenType>(t)) {\n        InsertAfter(typeName, \"(*\"sv, varName);\n\n    } else if(not isRawArrayType and not varName.empty()) {\n        typeName += StrCat(\" \"sv, varName);\n    }\n\n    return typeName;\n}\n//-----------------------------------------------------------------------------\n\nvoid AppendTemplateTypeParamName(OutputFormatHelper&         ofm,\n                                 const TemplateTypeParmDecl* decl,\n                                 const bool                  isParameter,\n                                 const TemplateTypeParmType* type)\n{\n    if(decl) {\n        if(const auto* typeConstraint = decl->getTypeConstraint(); typeConstraint and not isParameter) {\n            StringStream sstream{};\n            sstream.Print(*typeConstraint);\n\n            ofm.Append(sstream.str(), \" \"sv);\n        }\n    }\n\n    const auto depth = decl ? decl->getDepth() : type->getDepth();\n    const auto index = decl ? decl->getIndex() : type->getIndex();\n\n    ofm.Append(\"type_parameter_\"sv, depth, \"_\"sv, index);\n}\n//-----------------------------------------------------------------------------\n\nstatic bool IsTrivialStaticClassVarDecl(const DeclRefExpr& declRefExpr)\n{\n    if(const VarDecl* vd = GetVarDeclFromDeclRefExpr(declRefExpr)) {\n        return IsTrivialStaticClassVarDecl(*vd);\n    }\n\n    return false;\n}\n//-----------------------------------------------------------------------------\n\nAPValue* GetEvaluatedValue(const VarDecl& varDecl)\n{\n    if((nullptr != varDecl.ensureEvaluatedStmt()) and varDecl.ensureEvaluatedStmt()->Value.isValid() and\n       not varDecl.getInit()->isValueDependent()) {\n        return varDecl.evaluateValue();\n    }\n\n    return nullptr;\n}\n//-----------------------------------------------------------------------------\n\nbool IsEvaluatable(const VarDecl& varDecl)\n{\n    return (nullptr != GetEvaluatedValue(varDecl));\n}\n//-----------------------------------------------------------------------------\n\nbool IsTrivialStaticClassVarDecl(const VarDecl& varDecl)\n{\n    // Should the VarDecl be evaluatable at compile-time, there is no additional guard added by the compiler.\n    if(varDecl.isStaticLocal() and not IsEvaluatable(varDecl)) {\n        if(const auto* cxxRecordDecl = varDecl.getType()->getAsCXXRecordDecl()) {\n            if(cxxRecordDecl->hasNonTrivialDestructor() or cxxRecordDecl->hasNonTrivialDefaultConstructor()) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetName(const DeclRefExpr& declRefExpr)\n{\n    const auto* declRefDecl = declRefExpr.getDecl();\n    std::string name{};\n    const auto* declCtx = declRefDecl->getDeclContext();\n    const bool  needsNamespace{NeedsNamespace(*declRefDecl, UseLexicalParent::No)};\n\n    // get the namespace as well\n    if(needsNamespace) {\n        name = details::GetScope(declCtx);\n    } else if(declRefExpr.hasQualifier()) {\n        name = details::GetQualifiedName(*declRefDecl);\n    }\n\n    if(needsNamespace or not declRefExpr.hasQualifier()) {\n        std::string plainName{GetPlainName(declRefExpr)};\n\n        // try to handle the special case of a function local static with class type and non trivial destructor. In\n        // this case, as we teared that variable apart, we need to adjust the variable named and add a reinterpret\n        // cast\n        if(IsTrivialStaticClassVarDecl(declRefExpr)) {\n            if(const VarDecl* vd = GetVarDeclFromDeclRefExpr(declRefExpr)) {\n                if(const auto* cxxRecordDecl = vd->getType()->getAsCXXRecordDecl()) {\n                    plainName = StrCat(\"*\"sv,\n                                       kwReinterpretCast,\n                                       \"<\"sv,\n                                       GetName(vd->getType()),\n                                       \"*>(\"sv,\n                                       BuildInternalVarName(plainName),\n                                       \")\"sv);\n                }\n            }\n        }\n\n        name.append(plainName);\n    }\n\n    name += GetCfrontOverloadedFunctionName(dyn_cast_or_null<FunctionDecl>(declRefDecl));\n\n    return ScopeHandler::RemoveCurrentScope(GetTemplateParameterPackArgumentName(name, declRefDecl));\n}\n//-----------------------------------------------------------------------------\n\n/*\n * Go deep in a Stmt if necessary and look to all childs for a DeclRefExpr.\n */\nconst DeclRefExpr* FindDeclRef(const Stmt* stmt)\n{\n    if(const auto* dref = dyn_cast_or_null<DeclRefExpr>(stmt)) {\n        return dref;\n    } else if(const auto* arrayInitExpr = dyn_cast_or_null<ArrayInitLoopExpr>(stmt)) {\n        const auto* srcExpr = arrayInitExpr->getCommonExpr()->getSourceExpr();\n\n        if(const auto* arrayDeclRefExpr = dyn_cast_or_null<DeclRefExpr>(srcExpr)) {\n            return arrayDeclRefExpr;\n        }\n    } else if(const auto func = dyn_cast_or_null<CXXFunctionalCastExpr>(stmt)) {\n        //        TODO(stmt, \"\");\n    }\n\n    if(stmt) {\n        for(const auto* child : stmt->children()) {\n            if(const auto* childRef = FindDeclRef(child)) {\n                return childRef;\n            }\n        }\n    }\n\n    return nullptr;\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetName(const VarDecl& VD)\n{\n    // Handle a special case of DecompositionDecl. A DecompositionDecl does not have a name. Hence we make one up from\n    // the original name of the variable that is decomposed plus line number where the decomposition was written.\n    if(const auto* decompositionDeclStmt = dyn_cast_or_null<DecompositionDecl>(&VD)) {\n        const auto baseVarName{[&]() {\n            if(const auto* declName = FindDeclRef(decompositionDeclStmt->getInit())) {\n                std::string name = GetPlainName(*declName);\n\n                if(Contains(name, kwOperator)) {\n                    return std::string{kwOperator};\n                }\n\n                return name;\n            }\n\n            // We approached an unnamed decl. This happens for example like this: auto& [x, y] = Point{};\n            return std::string{};\n        }()};\n\n        return BuildInternalVarName(baseVarName, decompositionDeclStmt->getBeginLoc(), GetSM(*decompositionDeclStmt));\n    }\n\n    std::string name{VD.getNameAsString()};\n\n    return ScopeHandler::RemoveCurrentScope(GetTemplateParameterPackArgumentName(name, &VD));\n}\n//-----------------------------------------------------------------------------\n\nstatic std::optional<bool> EvaluateAsBoolenCondition(const Expr& expr, const Decl& decl)\n{\n    bool r{false};\n\n    if(expr.EvaluateAsBooleanCondition(r, decl.getASTContext())) {\n        return {r};\n    }\n\n    return std::nullopt;\n}\n//-----------------------------------------------------------------------------\n\nconst std::string GetNoExcept(const FunctionDecl& decl)\n{\n    const auto* func = decl.getType()->castAs<FunctionProtoType>();\n\n    if(func and func->hasNoexceptExceptionSpec() and not isUnresolvedExceptionSpec(func->getExceptionSpecType())) {\n        std::string ret{kwSpaceNoexcept};\n\n        if(const auto* expr = func->getNoexceptExpr()) {\n            ret += \"(\"sv;\n\n            if(const auto value = EvaluateAsBoolenCondition(*expr, decl); value) {\n                ret += details::ConvertToBoolString(*value);\n            } else {\n                OutputFormatHelper ofm{};\n                CodeGenerator      cg{ofm};\n                cg.InsertArg(expr);\n\n                ret += ofm.GetString();\n            }\n\n            ret += \")\"sv;\n        }\n\n        return ret;\n\n    } else if(func and isUnresolvedExceptionSpec(func->getExceptionSpecType())) {\n        // For special members the exception specification is unevaluated as long as the special member is unused.\n        return StrCat(\" \"sv, kwCommentStart, kwSpaceNoexcept, kwSpaceCCommentEnd);\n    }\n\n    return {};\n}\n//-----------------------------------------------------------------------------\n\nconst std::string_view GetConst(const FunctionDecl& decl)\n{\n    if(const auto* methodDecl = dyn_cast_or_null<CXXMethodDecl>(&decl)) {\n        if(methodDecl->isConst()) {\n            return kwSpaceConst;\n        }\n    }\n\n    return {};\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetElaboratedTypeKeyword(const ElaboratedTypeKeyword keyword)\n{\n    std::string ret{TypeWithKeyword::getKeywordName(keyword)};\n\n    if(not ret.empty()) {\n        ret += ' ';\n    }\n\n    return ret;\n}\n//-----------------------------------------------------------------------------\n\nuint64_t GetSize(const ConstantArrayType* arrayType)\n{\n    return arrayType->getSize().getZExtValue();\n}\n//-----------------------------------------------------------------------------\n\nvoid StringStream::Print(const TemplateArgument& arg)\n{\n    arg.print(CppInsightsPrintingPolicy{}, *this, false);\n}\n//-----------------------------------------------------------------------------\n\nvoid StringStream::Print(const TemplateSpecializationType& arg)\n{\n    arg.getTemplateName().print(*this, CppInsightsPrintingPolicy{}, TemplateName::Qualified::AsWritten);\n}\n//-----------------------------------------------------------------------------\n\nvoid StringStream::Print(const TypeConstraint& arg)\n{\n    arg.print(*this, CppInsightsPrintingPolicy{});\n}\n//-----------------------------------------------------------------------------\n\nvoid StringStream::Print(const StringLiteral& arg)\n{\n    arg.outputString(*this);\n}\n//-----------------------------------------------------------------------------\n\nvoid StringStream::Print(const CharacterLiteral& arg)\n{\n    CharacterLiteral::print(arg.getValue(), arg.getKind(), *this);\n}\n//-----------------------------------------------------------------------------\n\ntemplate<class... Ts>\nstruct overloaded : Ts...\n{\n    using Ts::operator()...;\n};\ntemplate<class... Ts>\noverloaded(Ts...) -> overloaded<Ts...>;\n\nbool P0315Visitor::VisitLambdaExpr(const LambdaExpr* expr)\n{\n    mLambdaExpr = expr;\n\n    std::visit(overloaded{\n                   [&](OutputFormatHelper& ofm) { ofm.Append(GetLambdaName(*expr)); },\n                   [&](CodeGenerator& cg) { cg.InsertArg(expr); },\n               },\n               mConsumer);\n\n    return false;\n}\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n"
        },
        {
          "name": "InsightsHelpers.h",
          "type": "blob",
          "size": 15.2255859375,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#ifndef INSIGHTS_HELPERS_H\n#define INSIGHTS_HELPERS_H\n//-----------------------------------------------------------------------------\n\n#include \"clang/AST/AST.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/Lex/Lexer.h\"\n\n#include <functional>\n#include <optional>\n#include <string>\n#include <variant>\n\n#include \"InsightsStrongTypes.h\"\n#include \"StackList.h\"\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n\nstd::string BuildInternalVarName(const std::string_view& varName);\n//-----------------------------------------------------------------------------\n\nstd::string MakeLineColumnName(const SourceManager& sm, const SourceLocation& loc, const std::string_view& prefix);\n//-----------------------------------------------------------------------------\n\ninline bool IsStaticStorageClass(const CXXMethodDecl* md)\n{\n    return SC_Static == md->getStorageClass();\n}\n//-----------------------------------------------------------------------------\n\ninline bool IsReferenceType(const ValueDecl* decl)\n{\n    return decl and decl->getType()->isReferenceType();\n}\n//-----------------------------------------------------------------------------\n\ninline bool IsReferenceType(const DeclRefExpr* decl)\n{\n    return decl and IsReferenceType(decl->getDecl());\n}\n//-----------------------------------------------------------------------------\n\nstd::string BuildRetTypeName(const Decl& decl);\n//-----------------------------------------------------------------------------\n\ninline bool Contains(const std::string_view source, const std::string_view search)\n{\n    return std::string::npos != source.find(search, 0);\n}\n//-----------------------------------------------------------------------------\n\ntemplate<typename K, typename V, typename U>\ninline bool Contains(const llvm::DenseMap<K, V>& map, const U& key)\n{\n    return map.find(key) != map.end();\n}\n//-----------------------------------------------------------------------------\n\nvoid ReplaceAll(std::string& str, std::string_view from, std::string_view to);\n//-----------------------------------------------------------------------------\n\nvoid InsertBefore(std::string& source, const std::string_view& find, const std::string_view& replace);\n//-----------------------------------------------------------------------------\n\ninline const SourceManager& GetSM(const Decl& decl)\n{\n    return decl.getASTContext().getSourceManager();\n}\n//-----------------------------------------------------------------------------\n\ninline const LangOptions& GetLangOpts(const Decl& decl)\n{\n    return decl.getASTContext().getLangOpts();\n}\n//-----------------------------------------------------------------------------\n\n/// \\brief Get the evaluated APValue from a `VarDecl`\n///\n/// Returns `nullptr` is the \\c VarDecl is not evaluatable.\nAPValue* GetEvaluatedValue(const VarDecl& varDecl);\n//-----------------------------------------------------------------------------\n\n/// \\brief Check whether a `VarDecl`s initialization can be done a compile-time.\n///\n/// This method checks, whether a \\c VarDecl is initialized by a constant expression.\nbool IsEvaluatable(const VarDecl& varDecl);\n//-----------------------------------------------------------------------------\n\nbool IsTrivialStaticClassVarDecl(const VarDecl& varDecl);\n//-----------------------------------------------------------------------------\n\n/*\n * Get the name of a DeclRefExpr without the namespace\n */\nstd::string GetPlainName(const DeclRefExpr& DRE);\n\nstd::string GetName(const DeclRefExpr& declRefExpr);\nstd::string GetName(const VarDecl& VD);\n//-----------------------------------------------------------------------------\n\nSTRONG_BOOL(QualifiedName);\nstd::string GetName(const NamedDecl& nd, const QualifiedName qualifiedName = QualifiedName::No);\n//-----------------------------------------------------------------------------\n\nstd::string GetNameAsFunctionPointer(const QualType& t);\n//-----------------------------------------------------------------------------\n\nstd::string GetLambdaName(const CXXRecordDecl& lambda);\n\ninline std::string GetLambdaName(const LambdaExpr& lambda)\n{\n    return GetLambdaName(*lambda.getLambdaClass());\n}\n//-----------------------------------------------------------------------------\n\nstd::string GetName(const CXXRecordDecl& RD);\n//-----------------------------------------------------------------------------\n\nstd::string GetName(const CXXTemporaryObjectExpr& tmp);\n//-----------------------------------------------------------------------------\n\nstd::string GetTemporaryName(const Expr& tmp);\n//-----------------------------------------------------------------------------\n\n/// \\brief In Cfront mode we transform references to pointers\nQualType GetType(QualType);\n//-----------------------------------------------------------------------------\n\n/// \\brief Check whether this is an anonymous struct or union.\n///\n/// There is a dedicated function `isAnonymousStructOrUnion` which at this point no longer returns true. Hence this\n/// method uses an empty record decl name as indication for an anonymous struct/union.\ninline bool IsAnonymousStructOrUnion(const CXXRecordDecl* cxxRecordDecl)\n{\n    if(cxxRecordDecl) {\n        return cxxRecordDecl->getName().empty();\n    }\n\n    return false;\n}\n//-----------------------------------------------------------------------------\n\nvoid AppendTemplateTypeParamName(class OutputFormatHelper&   ofm,\n                                 const TemplateTypeParmDecl* decl,\n                                 const bool                  isParameter,\n                                 const TemplateTypeParmType* type = nullptr);\n//-----------------------------------------------------------------------------\n\n/// \\brief Remove decltype from a QualType, if possible.\nconst QualType GetDesugarType(const QualType& QT);\n// -----------------------------------------------------------------------------\n\ninline QualType GetDesugarReturnType(const FunctionDecl& FD)\n{\n    return GetDesugarType(FD.getReturnType());\n}\n//-----------------------------------------------------------------------------\n\nSTRONG_BOOL(Unqualified);\n\nstd::string GetName(const QualType& t, const Unqualified unqualified = Unqualified::No);\n//-----------------------------------------------------------------------------\n\nstd::string GetUnqualifiedScopelessName(const Type* type);\n//-----------------------------------------------------------------------------\n\nstd::string\nGetTypeNameAsParameter(const QualType& t, std::string_view varName, const Unqualified unqualified = Unqualified::No);\n//-----------------------------------------------------------------------------\n\nSTRONG_BOOL(WithTemplateParameters);\nSTRONG_BOOL(IgnoreNamespace);\n\nstd::string GetNestedName(const NestedNameSpecifier* nns, const IgnoreNamespace ignoreNamespace = IgnoreNamespace::No);\nstd::string GetDeclContext(const DeclContext*     ctx,\n                           WithTemplateParameters withTemplateParameters = WithTemplateParameters::No);\n//-----------------------------------------------------------------------------\n\nconst std::string      EvaluateAsFloat(const FloatingLiteral& expr);\nconst std::string      GetNoExcept(const FunctionDecl& decl);\nconst std::string_view GetConst(const FunctionDecl& decl);\n//-----------------------------------------------------------------------------\n\nstd::string GetElaboratedTypeKeyword(const ElaboratedTypeKeyword keyword);\n//-----------------------------------------------------------------------------\n\nuint64_t GetSize(const ConstantArrayType*);\n//-----------------------------------------------------------------------------\n\ntemplate<typename QT, typename SUB_T>\nstatic bool TypeContainsSubType(const QualType& t)\n{\n    if(const auto* lref = dyn_cast_or_null<QT>(t.getTypePtrOrNull())) {\n        const auto  subType      = GetDesugarType(lref->getPointeeType());\n        const auto& ct           = subType.getCanonicalType();\n        const auto* plainSubType = ct.getTypePtrOrNull();\n\n        return isa<SUB_T>(plainSubType);\n    }\n\n    return false;\n}\n//-----------------------------------------------------------------------------\n\ntemplate<typename T, typename TFunc>\nvoid for_each(T start, T end, TFunc&& func)\n{\n    for(; start < end; ++start) {\n        func(start);\n    }\n}\n//-----------------------------------------------------------------------------\n\n/// \\brief Track the scope we are currently in to build a properly scoped variable.\n///\n/// The AST only knows about absolute scopes (namespace, struct, class), as once a declaration is parsed it is either in\n/// a scope or not. Each request to give me the namespace automatically leads to the entire scope the item is in. This\n/// makes it hard to have constructs like this: \\code struct One\n/// {\n///    static const int o{};\n///\n///    struct Two\n///    {\n///        static const int d = o;\n///    };\n///\n///    static const int a = Two::d;\n///};\n/// \\endcode\n///\n/// Here the initializer of \\c a is in the scope \\c One::Two::d. At this point the qualification \\c Two::d is enought.\n///\n/// \\c ScopeHelper tracks whether we are currently in a class or namespace and simply remove the path we already in from\n/// the scope.\nstruct ScopeHelper : public StackListEntry<ScopeHelper>\n{\n    ScopeHelper(const size_t len)\n    : mLength{len}\n    {\n    }\n\n    const size_t mLength;  //!< Length of the scope as it was _before_ this declaration was appended.\n};\n//-----------------------------------------------------------------------------\n\n/// \\brief The ScopeHandler tracks the current scope.\n///\n/// The \\c ScopeHandler tracks the current scope, knows about all the parts and is able to remove the current scope part\n/// from a name.\nclass ScopeHandler\n{\npublic:\n    ScopeHandler(const Decl* d);\n\n    ~ScopeHandler();\n\n    /// \\brief Remove the current scope from a string.\n    ///\n    /// The default is that the entire scope is replaced. Suppose we are\n    /// currently in N::X and having a symbol N::X::y then N::X:: is removed. However, there is a special case, where\n    /// the last item is skipped.\n    static std::string RemoveCurrentScope(std::string name);\n\nprivate:\n    using ScopeStackType = StackList<ScopeHelper>;\n\n    ScopeStackType& mStack;   //!< Access to the global \\c ScopeHelper stack.\n    ScopeHelper     mHelper;  //!< The \\c ScopeHelper this item refers to.\n\n    static inline ScopeStackType mGlobalStack;  //!< Global stack to keep track of the scope elements.\n    static inline std::string    mScope;        //!< The entire scope we are already in.\n};\n//-----------------------------------------------------------------------------\n\n/// \\brief Helper to create a \\c ScopeHandler on the stack which adds the current \\c Decl to it and removes it once the\n/// scope is left.\n#define SCOPE_HELPER(d)                                                                                                \\\n    ScopeHandler _scopeHandler                                                                                         \\\n    {                                                                                                                  \\\n        d                                                                                                              \\\n    }\n//-----------------------------------------------------------------------------\n\n/// \\brief Specialization for \\c ::llvm::raw_string_ostream with an internal \\c std::string buffer.\nclass StringStream : public ::llvm::raw_string_ostream\n{\nprivate:\n    std::string mData{};\n\npublic:\n    StringStream()\n    : ::llvm::raw_string_ostream{mData}\n    {\n    }\n\n    void Print(const TemplateArgument&);\n    void Print(const TemplateSpecializationType&);\n    void Print(const TypeConstraint&);\n    void Print(const StringLiteral&);\n    void Print(const CharacterLiteral&);\n};\n//-----------------------------------------------------------------------------\n\n/// \\brief A helper which invokes a lambda when the scope is destroyed.\ntemplate<typename T>\nclass FinalAction\n{\npublic:\n    explicit FinalAction(T&& action)\n    : mAction{std::forward<T>(action)}\n    {\n    }\n\n    ~FinalAction() { mAction(); }\n\nprivate:\n    T mAction;\n};\n//-----------------------------------------------------------------------------\n\n/// \\brief Handy helper to avoid longish comparisons.\n///\n/// The idea is taken from a talk from Björn Fahller at NDC TechTown 2019: Modern Techniques for Keeping Your Code DRY\n/// (https://youtu.be/YUWuNpxZa5k)\n/// \\code\n/// if( is{v}.any_of(A, B, C) ) { ... }\n/// \\endcode\ntemplate<typename T>\nstruct is\n{\n    T t;\n\n    constexpr bool any_of(const auto&... ts) const { return ((t == ts) or ...); }\n};\n//-----------------------------------------------------------------------------\n\ntemplate<typename T>\nis(T) -> is<T>;\n//-----------------------------------------------------------------------------\n\n/// Go deep in a Stmt if necessary and look to all childs for a DeclRefExpr.\nconst DeclRefExpr* FindDeclRef(const Stmt* stmt);\n//-----------------------------------------------------------------------------\n\n///! Find a LambdaExpr inside a Decltype\nclass P0315Visitor : public RecursiveASTVisitor<P0315Visitor>\n{\n    std::variant<std::reference_wrapper<class OutputFormatHelper>, std::reference_wrapper<class CodeGenerator>>\n                      mConsumer;\n    const LambdaExpr* mLambdaExpr{};\n\npublic:\n    P0315Visitor(class OutputFormatHelper& ofm)\n    : mConsumer{ofm}\n    {\n    }\n\n    P0315Visitor(class CodeGenerator& cg)\n    : mConsumer{cg}\n    {\n    }\n\n    bool VisitLambdaExpr(const LambdaExpr* expr);\n\n    const LambdaExpr* Get() const { return mLambdaExpr; }\n};\n//-----------------------------------------------------------------------------\n\ntemplate<typename T, typename U>\nstruct BackupAndRestore\n{\n    T& mValue;\n    T  mBackup{};\n\n    BackupAndRestore(T& value, U&& newVal)\n    : mValue(value)\n    , mBackup{mValue}\n    {\n        mValue = std::forward<U>(newVal);\n    }\n\n    ~BackupAndRestore() { mValue = mBackup; }\n};\n//-----------------------------------------------------------------------------\n\ntemplate<class T>\nclass MyOptional : public std::optional<T>\n{\n\npublic:\n    using std::optional<T>::optional;\n\n    template<class Return>\n    MyOptional<Return> and_then(std::function<MyOptional<Return>(T)> func)\n        requires(not std::is_pointer_v<T>)\n    {\n        if(not this->has_value()) {\n            return {};\n        }\n\n        return func(this->value());\n    }\n\n    template<class Return>\n    MyOptional<Return> and_then(std::function<MyOptional<Return>(std::remove_pointer_t<T>&)> func)\n        requires(std::is_pointer_v<T>)\n    {\n        if(not this->has_value()) {\n            return {};\n        }\n\n        if(this->value() == nullptr) {\n            return {};\n        } else {\n            return func(*this->value());\n        }\n    }\n\n    template<class Return>\n    MyOptional<Return> and_not(std::function<MyOptional<Return>(T)> func)\n    {\n        if(not this->has_value()) {\n            return {};\n        }\n\n        if(not func(this->value()).has_value()) {\n            return *this;\n        }\n\n        return {};\n    }\n};\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n\n#endif /* INSIGHTS_HELPERS_H */\n"
        },
        {
          "name": "InsightsOnce.h",
          "type": "blob",
          "size": 1.0634765625,
          "content": "#ifndef INSIGHTS_ONCE_H\n#define INSIGHTS_ONCE_H\n\nnamespace clang::insights {\n\n/// \\brief A helper object which returns a boolean value just once and toggles it after the first query.\n///\n/// This allows to simplify code like this:\n/// \\code\n/// bool first{true};\n/// for(... : ...) {\n///   if(first) {\n///      first = false;\n///      ...\n///   } else {\n///     ...\n///  }\n/// \\endcode\n///\n/// into this:\n/// \\code\n/// OnceTrue first{};\n/// for(... : ...) {\n///   if(first) {\n///      ...\n///   } else {\n///     ...\n///  }\n/// \\endcode\ntemplate<bool VALUE>\nclass Once\n{\npublic:\n    Once() = default;\n    Once(bool value)\n    : mValue{value}\n    {\n    }\n\n    operator bool()\n    {\n        if(VALUE == mValue) {\n            mValue = not VALUE;\n            return VALUE;\n        }\n\n        return not VALUE;\n    }\n\nprivate:\n    bool mValue{VALUE};\n};\n\n/// Returns true only once, following checks return false.\nusing OnceTrue = Once<true>;\n/// Returns false only once, following checks return true.\nusing OnceFalse = Once<false>;\n\n}  // namespace clang::insights\n#endif /* INSIGHTS_ONCE_H */\n"
        },
        {
          "name": "InsightsOptions.def",
          "type": "blob",
          "size": 1.8193359375,
          "content": "///////////////////////////////////////////////////////////////////////////////\n//\n// C++ Insights, copyright (C) by Andreas Fertig\n// Distributed under an MIT license. See LICENSE for details\n//\n///////////////////////////////////////////////////////////////////////////////\n\n/// \\brief C++ Insights options definition\n#ifndef INSIGHTS_OPT\n#define INSIGHTS_OPT(opt, name, deflt, description, category)\n#endif\n\nINSIGHTS_OPT(\"alt-syntax-for\",\n             UseAltForSyntax,\n             false,\n             \"Transform all for-loops into their equivalent while-loop.\",\n             gInsightCategory)\nINSIGHTS_OPT(\"alt-syntax-subscription\",\n             UseAltArraySubscriptionSyntax,\n             false,\n             \"Transform array subscriptions E1[E2] into (*(E1 + E2)).\", gInsightCategory)\nINSIGHTS_OPT(\"show-all-implicit-casts\", ShowAllImplicitCasts, false, \"Show all implicit casts which can be noisy.\", gInsightCategory)\nINSIGHTS_OPT(\"show-all-callexpr-template-parameters\", ShowAllCallExprTemplateParameters, false, \"Show all template parameters of a CallExpr.\", gInsightCategory)\nINSIGHTS_OPT(\"edu-show-initlist\", UseShowInitializerList, false, \"Transform a std::initializer list\", gInsightEduCategory)\nINSIGHTS_OPT(\"edu-show-noexcept\", UseShowNoexcept, false, \"Transform a noexcept function\", gInsightEduCategory)\nINSIGHTS_OPT(\"edu-show-padding\", UseShowPadding, false, \"Show the padding bytes in a struct/class\", gInsightEduCategory)\nINSIGHTS_OPT(\"edu-show-coroutine-transformation\",\n             ShowCoroutineTransformation,\n             false,\n             \"Show transformations of coroutines.\",\n             gInsightEduCategory)\nINSIGHTS_OPT(\"edu-show-cfront\", UseShow2C, false, \"Show transformation to C\", gInsightEduCategory)\nINSIGHTS_OPT(\"edu-show-lifetime\", ShowLifetime, false, \"Show lifetime of objects\", gInsightEduCategory)\n#undef INSIGHTS_OPT\n"
        },
        {
          "name": "InsightsStaticStrings.h",
          "type": "blob",
          "size": 8.9775390625,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#ifndef INSIGHTS_STATIC_STRINGS_H\n#define INSIGHTS_STATIC_STRINGS_H\n\n#include <string_view>\nusing namespace std::literals;\n//-----------------------------------------------------------------------------\n\n#define KW_CONST \"const\"\n#define KW_AUTO \"auto\"\n#define KW_CONSTEXPR \"constexpr\"\n#define KW_CONSTEVAL \"consteval\"\n#define KW_CONSTINIT \"constinit\"\n#define KW_VOLATILE \"volatile\"\n#define KW_STATIC \"static\"\n#define KW_EXTERN \"extern\"\n#define KW_NOEXCEPT \"noexcept\"\n#define KW_CLASS \"class\"\n#define KW_STRUCT \"struct\"\n#define KW_UNION \"union\"\n#define KW_VIRTUAL \"virtual\"\n#define KW_INLINE \"inline\"\n#define KW_REQUIRES \"requires\"\n#define KW_REINTERPRET_CAST \"reinterpret_cast\"\n#define KW_STATIC_CAST \"static_cast\"\n#define KW_PUBLIC \"public\"\n#define KW_PROTECTED \"protected\"\n#define KW_PRIVATE \"private\"\n#define KW_FINAL \"final\"\n#define KW_SIZEOF \"sizeof\"\n#define KW_ALIGNOF \"alignof\"\n#define KW_OPERATOR \"operator\"\n#define KW_USING \"using\"\n#define KW_FRIEND \"friend\"\n#define KW_EXPLICIT \"explicit\"\n#define KW_TEMPLATE \"template\"\n#define KW_NULLPTR \"nullptr\"\n#define KW_NULL \"NULL\"\n#define KW_ENUM \"enum\"\n#define KW_NAMESPACE \"namespace\"\n#define KW_CONCEPT \"concept\"\n#define KW_DELETE \"delete\"\n#define KW_WHILE \"while\"\n#define KW_BREAK \"break\"\n#define KW_DO \"do\"\n#define KW_CASE \"case\"\n#define KW_GOTO \"goto\"\n#define KW_CONTINUE \"continue\"\n#define KW_SWITCH \"switch\"\n#define KW_TYPEID \"typeid\"\n#define KW_MUTABLE \"mutable\"\n#define KW_RETURN \"return\"\n#define KW_STATIC_ASSERT \"static_assert\"\n#define KW_CO_RETURN \"co_return\"\n#define KW_CO_YIELD \"co_yield\"\n#define KW_CO_AWAIT \"co_await\"\n#define KW_TYPENAME \"typename\"\n#define KW_EQUALS_DEFAULT \"= default;\"\n#define KW_EQUALS_DELETE \"= delete;\"\n#define KW_INTERNAL_THIS \"__this\"\n#define KW_ELIPSIS \"...\"\n#define KW_FALSE \"false\"\n#define KW_TRY \"try\"\n#define KW_TYPEDEF \"typedef\"\n\n#define HLP_ASSIGN \" = \"\n#define HLP_ARROW \" -> \"\n//-----------------------------------------------------------------------------\n\n#define BUILD_KW(kw) \" \" kw \" \"\n\ninline constexpr std::string_view KW_OPERATOR_ALL{BUILD_KW(KW_OPERATOR)};\n\nconsteval std::string_view KwWithSpaceBefore(std::string_view kw)\n{\n    kw.remove_suffix(1);\n\n    return kw;\n}\n\nconsteval std::string_view KwWithSpaceAfter(std::string_view kw)\n{\n    kw.remove_prefix(1);\n\n    return kw;\n}\n\nconsteval std::string_view KwWithNoSpace(std::string_view kw)\n{\n    kw.remove_suffix(1);\n    kw.remove_prefix(1);\n\n    return kw;\n}\n\ninline constexpr std::string_view kwNoexcept{KW_NOEXCEPT};\ninline constexpr std::string_view kwRequires{KW_REQUIRES};\ninline constexpr std::string_view kwPublic{KW_PUBLIC};\ninline constexpr std::string_view kwProtected{KW_PROTECTED};\ninline constexpr std::string_view kwPrivate{KW_PRIVATE};\ninline constexpr std::string_view kwReinterpretCast{KW_REINTERPRET_CAST};\ninline constexpr std::string_view kwStaticCast{KW_STATIC_CAST};\ninline constexpr std::string_view kwSizeof{KW_SIZEOF};\ninline constexpr std::string_view kwAlignof{KW_ALIGNOF};\ninline constexpr std::string_view kwUnkown{\"unkown\"sv};\ninline constexpr std::string_view kwOperator{KwWithNoSpace(KW_OPERATOR_ALL)};\n// inline constexpr std::string_view kwOperator{KW_OPERATOR};\ninline constexpr std::string_view kwTemplate{KW_TEMPLATE};\ninline constexpr std::string_view kwCommentStart{\"/*\"sv};\ninline constexpr std::string_view kwNullptr{KW_NULLPTR};\ninline constexpr std::string_view kwNull{KW_NULL};\ninline constexpr std::string_view kwNamespace{KW_NAMESPACE};\ninline constexpr std::string_view kwDelete{KW_DELETE};\ninline constexpr std::string_view kwWhile{KW_WHILE};\ninline constexpr std::string_view kwBreak{KW_BREAK};\ninline constexpr std::string_view kwContinue{KW_CONTINUE};\ninline constexpr std::string_view kwSwitch{KW_SWITCH};\ninline constexpr std::string_view kwTypeId{KW_TYPEID};\ninline constexpr std::string_view kwReturn{KW_RETURN};\ninline constexpr std::string_view kwFalse{KW_FALSE};\ninline constexpr std::string_view kwElipsis{KW_ELIPSIS};\ninline constexpr std::string_view kwStaticAssert{KW_STATIC_ASSERT};\ninline constexpr std::string_view kwInternalThis{KW_INTERNAL_THIS};\ninline constexpr std::string_view kwThis{KwWithSpaceAfter(KwWithSpaceAfter(kwInternalThis))};\ninline constexpr std::string_view kwExplicit{KW_EXPLICIT};\n\ninline constexpr std::string_view hlpAssing{HLP_ASSIGN};\ninline constexpr std::string_view hlpArrow{HLP_ARROW};\ninline constexpr std::string_view hlpResumeFn{\"resume_fn\"sv};\ninline constexpr std::string_view hlpDestroyFn{\"destroy_fn\"sv};\n//-----------------------------------------------------------------------------\n\n#define BUILD_WITH_SPACE_AFTER(kw) kw \" \"\n#define BUILD_WITH_SPACE_BEFORE(kw) \" \" kw\n\ninline constexpr std::string_view kwConstExprSpace{BUILD_WITH_SPACE_AFTER(KW_CONSTEXPR)};\ninline constexpr std::string_view kwConstEvalSpace{BUILD_WITH_SPACE_AFTER(KW_CONSTEVAL)};\ninline constexpr std::string_view kwStaticSpace{BUILD_WITH_SPACE_AFTER(KW_STATIC)};\ninline constexpr std::string_view kwClassSpace{BUILD_WITH_SPACE_AFTER(KW_CLASS)};\ninline constexpr std::string_view kwStructSpace{BUILD_WITH_SPACE_AFTER(KW_STRUCT)};\ninline constexpr std::string_view kwEnumSpace{BUILD_WITH_SPACE_AFTER(KW_ENUM)};\ninline constexpr std::string_view kwUnionSpace{BUILD_WITH_SPACE_AFTER(KW_UNION)};\ninline constexpr std::string_view kwVirtualSpace{BUILD_WITH_SPACE_AFTER(KW_VIRTUAL)};\ninline constexpr std::string_view kwInlineSpace{BUILD_WITH_SPACE_AFTER(KW_INLINE)};\ninline constexpr std::string_view kwRequiresSpace{BUILD_WITH_SPACE_AFTER(KW_REQUIRES)};\ninline constexpr std::string_view kwOperatorSpace{KwWithSpaceAfter(KW_OPERATOR_ALL)};\ninline constexpr std::string_view kwCppCommentStartSpace{BUILD_WITH_SPACE_AFTER(\"//\")};\ninline constexpr std::string_view kwUsingSpace{BUILD_WITH_SPACE_AFTER(KW_USING)};\ninline constexpr std::string_view kwFriendSpace{BUILD_WITH_SPACE_AFTER(KW_FRIEND)};\ninline constexpr std::string_view kwExplicitSpace{BUILD_WITH_SPACE_AFTER(KW_EXPLICIT)};\ninline constexpr std::string_view kwTemplateSpace{BUILD_WITH_SPACE_AFTER(KW_TEMPLATE)};\ninline constexpr std::string_view kwNamespaceSpace{BUILD_WITH_SPACE_AFTER(KW_NAMESPACE)};\ninline constexpr std::string_view kwConceptSpace{BUILD_WITH_SPACE_AFTER(KW_CONCEPT)};\ninline constexpr std::string_view kwDoSpace{BUILD_WITH_SPACE_AFTER(KW_DO)};\ninline constexpr std::string_view kwCaseSpace{BUILD_WITH_SPACE_AFTER(KW_CASE)};\ninline constexpr std::string_view kwGotoSpace{BUILD_WITH_SPACE_AFTER(KW_GOTO)};\ninline constexpr std::string_view kwMutableSpace{BUILD_WITH_SPACE_AFTER(KW_MUTABLE)};\ninline constexpr std::string_view kwCoReturnSpace{BUILD_WITH_SPACE_AFTER(KW_CO_RETURN)};\ninline constexpr std::string_view kwCoYieldSpace{BUILD_WITH_SPACE_AFTER(KW_CO_YIELD)};\ninline constexpr std::string_view kwCoAwaitSpace{BUILD_WITH_SPACE_AFTER(KW_CO_AWAIT)};\ninline constexpr std::string_view kwTypeNameSpace{BUILD_WITH_SPACE_AFTER(KW_TYPENAME)};\ninline constexpr std::string_view kwCCommentStartSpace{BUILD_WITH_SPACE_AFTER(\"/*\")};\ninline constexpr std::string_view kwCCommentEndSpace{BUILD_WITH_SPACE_AFTER(\"*/\")};\ninline constexpr std::string_view kwElipsisSpace{BUILD_WITH_SPACE_AFTER(KW_ELIPSIS)};\ninline constexpr std::string_view kwTrySpace{BUILD_WITH_SPACE_AFTER(KW_TRY)};\ninline constexpr std::string_view kwReturnSpace{BUILD_WITH_SPACE_AFTER(KW_RETURN)};\ninline constexpr std::string_view kwTypedefSpace{BUILD_WITH_SPACE_AFTER(KW_TYPEDEF)};\n//-----------------------------------------------------------------------------\n\ninline constexpr std::string_view kwSpaceNoexcept{BUILD_WITH_SPACE_BEFORE(KW_NOEXCEPT)};\ninline constexpr std::string_view kwSpaceConst{BUILD_WITH_SPACE_BEFORE(KW_CONST)};\ninline constexpr std::string_view kwSpaceConstExpr{BUILD_WITH_SPACE_BEFORE(KW_CONSTEXPR)};\ninline constexpr std::string_view kwSpaceVolatile{BUILD_WITH_SPACE_BEFORE(KW_VOLATILE)};\ninline constexpr std::string_view kwSpaceFinal{BUILD_WITH_SPACE_BEFORE(KW_FINAL)};\ninline constexpr std::string_view kwSpaceEqualsDefault{BUILD_WITH_SPACE_BEFORE(KW_EQUALS_DEFAULT)};\ninline constexpr std::string_view kwSpaceEqualsDelete{BUILD_WITH_SPACE_BEFORE(KW_EQUALS_DELETE)};\ninline constexpr std::string_view kwSpaceCCommentEnd{BUILD_WITH_SPACE_BEFORE(\"*/\")};\n//-----------------------------------------------------------------------------\n\ninline constexpr std::string_view kwSpaceCCommentEndSpace{BUILD_WITH_SPACE_BEFORE(\"*/ \")};\ninline constexpr std::string_view kwSpaceConstEvalSpace{BUILD_WITH_SPACE_BEFORE(BUILD_WITH_SPACE_AFTER(KW_CONSTEVAL))};\n\ninline constexpr std::string_view memberVariablePointerPrefix{\"MemberVarPtr_\"};\ninline constexpr std::string_view functionPointerPrefix{\"FuncPtr_\"};\n//-----------------------------------------------------------------------------\n\ninline constexpr std::string_view cxaStart{\"__cxa_start\"};\ninline constexpr std::string_view cxaAtExit{\"__cxa_atexit\"};\n//-----------------------------------------------------------------------------\n\n#endif /* INSIGHTS_STATIC_STRINGS_H */\n"
        },
        {
          "name": "InsightsStrCat.h",
          "type": "blob",
          "size": 2.6865234375,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#ifndef INSIGHTS_STRCAT_H\n#define INSIGHTS_STRCAT_H\n\n#include \"clang/AST/AST.h\"\n#include \"llvm/ADT/StringExtras.h\"\n\n#include <string>\n#include <type_traits>\n#include <utility>\n\n#include \"ClangCompat.h\"\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n\nnamespace details {\n/// \\brief Convert a boolean value to a string representation of \"true\" or \"false\"\ninline std::string ConvertToBoolString(bool b)\n{\n    return b ? std::string{\"true\"} : std::string{\"false\"};\n}\n\n}  // namespace details\n\ninline std::string ToString(const llvm::APSInt& val)\n{\n    if(1 == val.getBitWidth()) {\n        return details::ConvertToBoolString(0 != val.getExtValue());\n    }\n\n    return llvm::toString(val, 10);\n}\n//-----------------------------------------------------------------------------\n\ninline uint64_t Normalize(const llvm::APInt& arg)\n{\n    return arg.getZExtValue();\n}\n//-----------------------------------------------------------------------------\n\ninline std::string Normalize(const llvm::APSInt& arg)\n{\n    return ToString(arg);\n}\n//-----------------------------------------------------------------------------\n\ninline std::string_view Normalize(const StringRef& arg)\n{\n    return arg;\n}\n//-----------------------------------------------------------------------------\n\nstatic inline std::string Normalize(const CharUnits& arg)\n{\n    return std::to_string(arg.getQuantity());\n}\n//-----------------------------------------------------------------------------\n\ntemplate<class T>\ninline decltype(auto) Normalize(const T& arg)\n{\n    // Handle bool's first, we like their string representation.\n    if constexpr(std::is_same_v<std::remove_cvref_t<T>, bool>) {\n        return details::ConvertToBoolString(arg);\n\n    } else if constexpr(std::is_integral_v<T>) {\n        return std::to_string(arg);\n\n    } else {\n        return (arg);\n    }\n}\n//-----------------------------------------------------------------------------\n\nnamespace details {\nvoid StrCat(std::string& ret, const auto&... args)\n{\n    (ret += ... += ::clang::insights::Normalize(args));\n}\n//-----------------------------------------------------------------------------\n}  // namespace details\n\ninline std::string StrCat(const auto&... args)\n{\n    std::string ret{};\n    details::StrCat(ret, args...);\n\n    return ret;\n}\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n\n#endif /* INSIGHTS_STRCAT_H */\n"
        },
        {
          "name": "InsightsStrongTypes.h",
          "type": "blob",
          "size": 1.2392578125,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#ifndef INSIGHTS_STRONG_TYPES\n#define INSIGHTS_STRONG_TYPES\n\n/// \\brief A more than simple typsafe \\c bool\n///\n/// This macro creates a class enum with two enumerators:\n/// - \\c No\n/// - \\c Yes\n///\n/// Usage:\n/// \\code\n/// STRONG_BOOL(AddNewLine);\n/// void Foo(AddNewLine);\n/// ...\n/// void Bar() {\n///   Foo(AddNewLine::Yes);\n/// }\n/// \\endcode\n#define STRONG_BOOL(typeName)                                                                                          \\\n    enum class typeName : bool                                                                                         \\\n    {                                                                                                                  \\\n        No  = false,                                                                                                   \\\n        Yes = true                                                                                                     \\\n    }\n\n#endif /* INSIGHTS_STRONG_TYPES */\n"
        },
        {
          "name": "InsightsUtility.h",
          "type": "blob",
          "size": 1.689453125,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#ifndef INSIGHTS_UTILITY_H\n#define INSIGHTS_UTILITY_H\n\n#include \"llvm/ADT/STLExtras.h\"\n\n#include <type_traits>\n#include <utility>\n//-----------------------------------------------------------------------------\n\n///! A helper inspired by https://github.com/Microsoft/wil/wiki/Error-handling-helpers\n#define RETURN_IF(cond)                                                                                                \\\n    if(cond) {                                                                                                         \\\n        return;                                                                                                        \\\n    }\n//-----------------------------------------------------------------------------\n\n#define RETURN_FALSE_IF(cond)                                                                                          \\\n    if(cond) {                                                                                                         \\\n        return false;                                                                                                  \\\n    }\n//-----------------------------------------------------------------------------\n\nusing void_func_ref = llvm::function_ref<void()>;\n//-----------------------------------------------------------------------------\n\ntemplate<typename T, typename... Ts>\nconcept same_as_any_of = (std::same_as<T, Ts> or ...);\n\n#endif /* INSIGHTS_UTILITY_H */\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0322265625,
          "content": "MIT License\n\nCopyright (c) 2018 \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "LifetimeTracker.cpp",
          "type": "blob",
          "size": 4.98828125,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#include <algorithm>\n\n#include \"ASTHelpers.h\"\n#include \"CodeGenerator.h\"\n#include \"DPrint.h\"\n#include \"Insights.h\"\n#include \"InsightsHelpers.h\"\n#include \"NumberIterator.h\"\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n\nusing namespace asthelpers;\n//-----------------------------------------------------------------------------\n\nvoid LifetimeTracker::StartScope(bool funcStart)\n{\n    RETURN_IF(not GetInsightsOptions().ShowLifetime)\n\n    ++scopeCounter;\n\n    objects.push_back(\n        {.funcStart = funcStart ? LifetimeEntry::FuncStart::Yes : LifetimeEntry::FuncStart::No, .scope = scopeCounter});\n}\n//-----------------------------------------------------------------------------\n\nvoid LifetimeTracker::AddExtended(const VarDecl* decl, const ValueDecl* extending)\n{\n    // Search for the extending VarlDecl which is already in `objects`. Insert this decl _after_\n    if(auto it = std::ranges::find_if(objects, [&](const auto& e) { return e.item == extending; });\n       it != objects.end()) {\n        const auto scope = (*it).scope;\n        objects.insert(std::next(it), {decl, LifetimeEntry::FuncStart::No, scope});\n    }\n}\n//-----------------------------------------------------------------------------\n\nvoid LifetimeTracker::Add(const VarDecl* decl)\n{\n    RETURN_IF(not GetInsightsOptions().ShowLifetime)\n\n    QualType type{decl->getType()};\n\n    RETURN_IF(type->isPointerType() or type->isRValueReferenceType());\n\n    // For life-time extended objects\n    // XXX contains in C++23\n    RETURN_IF(std::ranges::find_if(objects, [&](const auto& e) { return e.item == decl; }) != objects.end());\n\n    objects.push_back({decl, LifetimeEntry::FuncStart::No, scopeCounter});\n}\n//-----------------------------------------------------------------------------\n\nvoid LifetimeTracker::InsertDtorCall(const VarDecl* vd, OutputFormatHelper& ofm)\n{\n    QualType type{vd->getType()};\n\n    if(const auto* ar = dyn_cast_or_null<ConstantArrayType>(type)) {\n        type = ar->getElementType();\n    }\n\n    if(type->isLValueReferenceType()) {\n        type = type.getNonReferenceType();\n    }\n\n    if(const auto& ctx = GetGlobalAST(); QualType::DK_cxx_destructor != vd->needsDestruction(ctx)) {\n        CodeGeneratorVariant cg{ofm};\n        cg->InsertArg(Comment(StrCat(GetName(*vd), \" // lifetime ends here\")));\n\n        return;\n    }\n\n    auto*                dtorDecl = type->getAsCXXRecordDecl()->getDestructor();\n    auto*                ic       = CastLToRValue(vd);\n    CodeGeneratorVariant cg{ofm};\n\n    auto insertDtor = [&](Expr* member) {\n        auto* mem = AccessMember(member, dtorDecl, vd->getType()->isPointerType());\n        cg->InsertArg(CallMemberFun(mem, dtorDecl->getType()));\n        ofm.AppendSemiNewLine();\n    };\n\n    if(const auto* ar = dyn_cast_or_null<ConstantArrayType>(vd->getType()); ar and not GetInsightsOptions().UseShow2C) {\n        // not nice but call the destructor for each array element\n        for(const auto& i : NumberIterator{GetSize(ar)}) {\n            insertDtor(ArraySubscript(ic, i, type));\n        }\n\n        return;\n    }\n\n    insertDtor(ic);\n}\n//-----------------------------------------------------------------------------\n\nbool LifetimeTracker::Return(OutputFormatHelper& ofm)\n{\n    RETURN_FALSE_IF(not GetInsightsOptions().ShowLifetime or objects.empty())\n\n    bool ret{};\n\n    for(OnceTrue needsSemi{}; auto& e : llvm::reverse(objects)) {\n        if(LifetimeEntry::FuncStart::Yes == e.funcStart) {\n            break;\n        }\n\n        if(nullptr == e.item) {\n            continue;\n        }\n\n        if(needsSemi) {\n            CodeGeneratorVariant cg{ofm};\n            cg->InsertArg(mkNullStmt());\n        }\n\n        InsertDtorCall(e.item, ofm);\n        ret = true;\n    }\n\n    return ret;\n}\n//-----------------------------------------------------------------------------\n\nvoid LifetimeTracker::removeTop()\n{\n    objects.pop_back();\n\n    auto it = std::ranges::remove_if(objects, [&](const LifetimeEntry& e) { return (e.scope == scopeCounter); });\n    objects.erase(it.begin(), it.end());\n\n    --scopeCounter;\n}\n//-----------------------------------------------------------------------------\n\nbool LifetimeTracker::EndScope(OutputFormatHelper& ofm, bool coveredByReturn)\n{\n    RETURN_FALSE_IF(not GetInsightsOptions().ShowLifetime or objects.empty())\n\n    bool ret{};\n\n    if(not coveredByReturn) {\n        for(auto& e : llvm::reverse(objects)) {\n            if(e.scope != scopeCounter) {\n                break;\n            }\n\n            if(nullptr == e.item) {\n                break;\n            }\n\n            InsertDtorCall(e.item, ofm);\n            ret = true;\n        }\n    }\n\n    removeTop();\n\n    return ret;\n}\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n"
        },
        {
          "name": "NumberIterator.h",
          "type": "blob",
          "size": 0.6796875,
          "content": "#ifndef INSIGHTS_NUMBER_ITERATOR_H\n#define INSIGHTS_NUMBER_ITERATOR_H\n\ntemplate<typename T>\nclass NumberIterator\n{\n    const T mNum;\n    T       mCount{};\n\npublic:\n    NumberIterator(const T num)\n    : mNum{num}\n    {\n    }\n\n    const T& operator*() const { return mCount; }\n\n    NumberIterator& operator++()\n    {\n        ++mCount;\n\n        return *this;\n    }\n\n    struct sentinel\n    {\n    };\n\n    bool operator==(sentinel) const { return mCount >= mNum; }\n\n    const NumberIterator& begin() const { return *this; }\n    const sentinel        end() const { return {}; }\n};\n//-----------------------------------------------------------------------------\n\n#endif /* INSIGHTS_NUMBER_ITERATOR_H */\n"
        },
        {
          "name": "OutputFormatHelper.cpp",
          "type": "blob",
          "size": 3.0478515625,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#include <algorithm>\n\n#include \"CodeGenerator.h\"\n#include \"InsightsHelpers.h\"\n#include \"InsightsStaticStrings.h\"\n#include \"OutputFormatHelper.h\"\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n\nvoid OutputFormatHelper::Indent(unsigned count)\n{\n    mOutput.insert(mOutput.size(), count, ' ');\n}\n//-----------------------------------------------------------------------------\n\nvoid OutputFormatHelper::AppendParameterList(const ArrayRef<ParmVarDecl*> parameters,\n                                             const NameOnly               nameOnly,\n                                             const GenMissingParamName    genMissingParamName)\n{\n    int count{};\n\n    ForEachArg(parameters, [&](const auto& p) {\n        auto name{GetName(*p)};\n\n        // A special case for CXXInheritedCtor. A user can omit the parameters name, but wihtout a name the call to the\n        // base constructor may look like calling the default constructor. In such a case we create a name.\n        if((GenMissingParamName::Yes == genMissingParamName) && (0 == name.length())) {\n            name = BuildInternalVarName(StrCat(\"param\", count));\n            ++count;\n        }\n\n        // Get the attributes and insert them, if there are any\n        CodeGeneratorVariant codeGenerator{*this};\n        codeGenerator->InsertAttributes(p->attrs());\n\n        if(const auto type{GetType(p->getType())}; NameOnly::No == nameOnly) {\n\n            Append(GetTypeNameAsParameter(type, name));\n        } else {\n            Append(name);\n\n            if(isa<PackExpansionType>(type)) {\n                Append(kwElipsis);\n            }\n        }\n    });\n}\n//-----------------------------------------------------------------------------\n\nvoid OutputFormatHelper::CloseScope(const NoNewLineBefore newLineBefore)\n{\n    if(NoNewLineBefore::No == newLineBefore) {\n        NewLine();\n    }\n\n    RemoveIndent();\n\n    Append('}');\n\n    DecreaseIndent();\n}\n//-----------------------------------------------------------------------------\n\nvoid OutputFormatHelper::RemoveIndent()\n{\n    /* After a newline we are already indented by one level to much. Try to decrease it. */\n    if(0 != mDefaultIndent) {\n        // go the string backwards and find the first non-whitespace character\n        const auto res = std::find_if(\n            std::rbegin(mOutput), std::rbegin(mOutput) + SCOPE_INDENT, [](const char& c) { return ' ' != c; });\n\n        // check if the string did end with at least one whitespace\n        if(const auto& end = std::rbegin(mOutput); res != end) {\n            // remove the whitespaces at the end of the string\n            mOutput.resize(mOutput.size() - std::distance(end, res));\n        }\n    }\n}\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n"
        },
        {
          "name": "OutputFormatHelper.h",
          "type": "blob",
          "size": 7.44921875,
          "content": "/******************************************************************************\n *\n * C++ Insights, copyright (C) by Andreas Fertig\n * Distributed under an MIT license. See LICENSE for details\n *\n ****************************************************************************/\n\n#ifndef OUTPUT_FORMAT_HELPER_H\n#define OUTPUT_FORMAT_HELPER_H\n//-----------------------------------------------------------------------------\n\n#include <string_view>\n#include <utility>\nusing namespace std::literals;\n\n#include \"InsightsOnce.h\"\n#include \"InsightsStrCat.h\"\n#include \"InsightsStrongTypes.h\"\n//-----------------------------------------------------------------------------\n\nnamespace clang::insights {\n//-----------------------------------------------------------------------------\n\n/// \\brief The C++ Insights formatter.\n///\n/// Most of the code is handed to \\ref OutputFormatHelper for easy code formatting.\nclass OutputFormatHelper\n{\npublic:\n    OutputFormatHelper() = default;\n\n    explicit OutputFormatHelper(const unsigned indent)\n    : mDefaultIndent{indent}\n    {\n    }\n\n    operator std::string_view() const& { return {mOutput}; }\n\n    auto size() const { return mOutput.size(); }\n\n    /// \\brief Returns the current position in the output buffer.\n    size_t CurrentPos() const { return mOutput.length(); }\n\n    /// \\brief Insert a string before the position \\c atPos\n    void InsertAt(const size_t atPos, std::string_view data) { mOutput.insert(atPos, data); }\n\n    STRONG_BOOL(SkipIndenting);\n\n    auto GetIndent() const { return mDefaultIndent; }\n\n    /// \\brief Set the indent level of this class to \\c indent.\n    void SetIndent(const unsigned indent, const SkipIndenting skipIndenting = SkipIndenting::No)\n    {\n        mDefaultIndent = indent;\n\n        if(SkipIndenting::No == skipIndenting) {\n            Indent(mDefaultIndent);\n        }\n    }\n\n    /// \\brief Set the indent level of this class to that of \\c rhs.\n    void SetIndent(const OutputFormatHelper& rhs, const SkipIndenting skipIndenting = SkipIndenting::No)\n    {\n        if(&rhs != this) {\n            mDefaultIndent = rhs.mDefaultIndent;\n\n            if(SkipIndenting::No == skipIndenting) {\n                Indent(mDefaultIndent);\n            }\n        }\n    }\n\n    /// \\brief Check whether the buffer is empty.\n    ///\n    /// This also treats a string of just whitespaces as empty.\n    bool empty() const { return mOutput.empty() or (std::string::npos == mOutput.find_first_not_of(' ', 0)); }\n\n    /// \\brief Returns a reference to the underlying string buffer.\n    std::string& GetString() { return mOutput; }\n\n    /// \\brief Append a single character\n    ///\n    /// Append a single character to the buffer\n    void Append(const char c) { mOutput += c; }\n\n    void Append(const std::string_view& arg) { mOutput += arg; }\n\n    /// \\brief Append a variable number of data\n    ///\n    /// The \\c StrCat function which is used ensures, that a \\c StringRef or a char are converted appropriately.\n    void Append(const auto&... args) { details::StrCat(mOutput, args...); }\n\n    /// \\brief Same as \\ref Append but adds a newline after the last argument.\n    ///\n    /// Append a single character to the buffer\n    void AppendNewLine(const char c)\n    {\n        mOutput += c;\n        NewLine();\n    }\n\n    void AppendNewLine(const std::string_view& arg)\n    {\n        mOutput += arg;\n        NewLine();\n    }\n\n    /// \\brief Same as \\ref Append but adds a newline after the last argument.\n    void AppendNewLine(const auto&... args)\n    {\n        if constexpr(0 < sizeof...(args)) {\n            details::StrCat(mOutput, args...);\n        }\n\n        NewLine();\n    }\n\n    void AppendComment(const std::string_view& arg)\n    {\n        Append(\"/* \"sv);\n        Append(arg);\n        Append(\" */\"sv);\n    }\n\n    void AppendCommentNewLine(const std::string_view& arg)\n    {\n        AppendComment(arg);\n        NewLine();\n    }\n\n    void AppendCommentNewLine(const auto&... args)\n    {\n        if constexpr(0 < sizeof...(args)) {\n            AppendComment(StrCat(args...));\n        }\n\n        NewLine();\n    }\n\n    STRONG_BOOL(NameOnly);\n    STRONG_BOOL(GenMissingParamName);\n\n    /// \\brief Append a \\c ParamVarDecl array.\n    ///\n    /// The parameter name is always added as well.\n    void AppendParameterList(const ArrayRef<ParmVarDecl*> parameters,\n                             const NameOnly               nameOnly            = NameOnly::No,\n                             const GenMissingParamName    genMissingParamName = GenMissingParamName::No);\n\n    /// \\brief Increase the current indention by \\c SCOPE_INDENT\n    void IncreaseIndent() { mDefaultIndent += SCOPE_INDENT; }\n    /// \\brief Decrease the current indention by \\c SCOPE_INDENT\n    void DecreaseIndent()\n    {\n        if(mDefaultIndent >= SCOPE_INDENT) {\n            mDefaultIndent -= SCOPE_INDENT;\n        }\n    }\n\n    /// \\brief Open a scope by inserting a '{' followed by an indented newline.\n    void OpenScope()\n    {\n        Append('{');\n        IncreaseIndent();\n        NewLine();\n    }\n\n    STRONG_BOOL(NoNewLineBefore);\n    /// \\brief Close a scope by inserting a '}'\n    ///\n    /// With the parameter \\c newLineBefore a newline after the brace can be inserted.\n    void CloseScope(const NoNewLineBefore newLineBefore = NoNewLineBefore::No);\n\n    /// \\brief Similiar to \\ref CloseScope only this time a ';' is inserted after the brace.\n    void CloseScopeWithSemi(const NoNewLineBefore newLineBefore = NoNewLineBefore::No)\n    {\n        CloseScope(newLineBefore);\n        Append(';');\n    }\n\n    /// \\brief Append a comma if needed.\n    void AppendComma(OnceFalse& needsComma)\n    {\n        if(needsComma) {\n            Append(\", \"sv);\n        }\n    }\n\n    /// \\brief Append a semicolon and a newline.\n    void AppendSemiNewLine() { AppendNewLine(';'); }\n\n    /// \\brief Append a semicolon and a newline.\n    template<typename... Args>\n    void AppendSemiNewLine(const Args&... args)\n    {\n        if constexpr(0 < sizeof...(args)) {\n            details::StrCat(mOutput, args...);\n        }\n\n        AppendNewLine(';');\n    }\n\n    void AppendSemiNewLine(const std::string_view& arg)\n    {\n        mOutput += arg;\n        AppendNewLine(';');\n    }\n\n    /// \\brief Append a argument list to the buffer.\n    ///\n    /// This function takes care of the delimiting ',' between the parameters. The lambda \\c lambda is called to each\n    /// argument after the comma was inserted.\n    /// Usage:\n    /// \\code\n    /// ForEachArg(parameters, [&](const auto& p) {\n    /// \t\t// do something with p\n    /// });\n    /// \\endcode\n    inline void ForEachArg(const auto& arguments, /*XXX: invocable*/ auto&& lambda)\n    {\n        for(OnceFalse needsComma{}; const auto& arg : arguments) {\n            if constexpr(std::is_same_v<const TemplateArgument&, decltype(arg)>) {\n                if((TemplateArgument::Pack == arg.getKind()) and (0 == arg.pack_size())) {\n                    break;\n                }\n            }\n\n            AppendComma(needsComma);\n\n            lambda(arg);\n        }\n    }\n\n    void InsertIfDefTemplateGuard() { AppendNewLine(\"#ifdef INSIGHTS_USE_TEMPLATE\"sv); }\n    void InsertEndIfTemplateGuard() { AppendNewLine(\"#endif\"sv); }\n\nprivate:\n    static constexpr unsigned SCOPE_INDENT{2};\n    unsigned                  mDefaultIndent{};\n    std::string               mOutput{};\n\n    void Indent(unsigned count);\n    void NewLine()\n    {\n        mOutput += '\\n';\n        Indent(mDefaultIndent);\n    }\n\n    void RemoveIndent();\n};\n//-----------------------------------------------------------------------------\n\n}  // namespace clang::insights\n#endif /* OUTPUT_FORMAT_HELPER_H */\n"
        },
        {
          "name": "Readme.md",
          "type": "blob",
          "size": 11.2099609375,
          "content": "![cpp insights logo](artwork/logo_cppinsights.png)\n# C++ Insights - See your source code with the eyes of a compiler.\n\n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](https://opensource.org/licenses/MIT) [![download](https://img.shields.io/badge/latest-download-blue.svg)](https://github.com/andreasfertig/cppinsights/releases) [![Build Status](https://github.com/andreasfertig/cppinsights/workflows/ci/badge.svg)](https://github.com/andreasfertig/cppinsights/actions/)\n[![codecov](https://codecov.io/gh/andreasfertig/cppinsights/branch/main/graph/badge.svg)](https://codecov.io/gh/andreasfertig/cppinsights)\n[![Try online](https://img.shields.io/badge/try-online-blue.svg)](https://cppinsights.io)\n[![Documentation](https://img.shields.io/badge/view-documentation-blue)](https://docs.cppinsights.io)\n[![patreon](https://img.shields.io/badge/patreon-support-orange.svg)](https://www.patreon.com/cppinsights)\n\n[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io#https://github.com/andreasfertig/cppinsights)\n\n## Contents\n\n- [What](#what)\n- [Why](#why)\n- [Building](#building)\n- [Usage](#usage)\n- [Get Involved](#get-involved)\n- [Support](#support)\n\n\n## What\n\n[C++ Insights](https://cppinsights.io) is a [Clang](https://clang.llvm.org)-based tool that does a source-to-source\ntransformation. The goal of C++ Insights is to make things visible that normally and intentionally happen behind the scenes.\nIt's about the magic the compiler does for us to make things work.\n\nTake this piece of code, for example:\n\n```.cpp\nclass Base {\n};\n\nclass Derived : public Base {\n};\n\nint main() {\n  Derived d;\n\n  Derived d2 = d;\n\n  d2 = d;\n\n  Base& b = d;\n}\n```\n\nNothing special, and of course, it compiles. This is the compiler's view on it:\n\n```.cpp\nclass Base\n{\n  public:\n  // inline constexpr Base() noexcept = default;\n  // inline constexpr Base(const Base &) noexcept = default;\n  // inline constexpr Base & operator=(const Base &) noexcept = default;\n};\n\n\n\nclass Derived : public Base\n{\n  public:\n  // inline constexpr Derived() noexcept = default;\n  // inline constexpr Derived(const Derived &) noexcept = default;\n  // inline constexpr Derived & operator=(const Derived &) noexcept = default;\n};\n\n\n\nint main()\n{\n  Derived d;\n  Derived d2 = Derived(d);\n  d2.operator=(d);\n  Base & b = static_cast<Base&>(d);\n  return 0;\n}\n```\n\nYou can see all the compiler-provided special member functions and the upcast from `Derived` to `Base`.\n\n## Why\n\n[C++ Insights](https://cppinsights.io) is a [Clang](https://clang.llvm.org)-based tool that does a source-to-source transformation.\nThe goal of C++ Insights is to make things visible that normally and intentionally happen behind the scenes. It's about the magic the compiler does\nfor us to make things work. Or looking through the classes of a compiler.\n\nIn 2017, I started looking into some new things we got with C++11, C++14, and C++17. Amazing things like lambdas, range-based for-loops,\nand structured bindings. I put it together in a talk. You can find the [slides](https://andreasfertig.com/talks/dl/afertig-ndcolo-2017-fast-and-small.pdf)\nand a [video](https://youtu.be/Bt7KzFxcbgc) online.\n\nHowever, all that research and some of my training and teaching got me to start thinking about how it would be if we could see with the eyes\nof the compiler. Sure, there is an AST dump, at least for Clang. We can see what code the compiler generates from a C++ source snippet with\ntools like Compiler Explorer. However, what we see is assembler. Neither the AST nor the Compiler Explorer output is in the language I write\ncode. Hence, I'm not very familiar with this output. Plus, when teaching students C++, showing an AST and explaining that it is all there was\nnot quite satisfying for me.\n\nI started to write a Clang-based tool that can transform a range-based for-loop into the compiler-internal version. Then, I did the same\nfor structured bindings and lambdas. In the end, I did much more than initially planned. It shows where operators are\ninvoked and places in which the compiler does some casting. C++ Insights can deduce the type behind `auto` or `decltype`. The goal\nis to produce compilable code. However, this is not possible in all places.\n\nYou can see, for example, the transformation of a [lambda](https://cppinsights.io/s/e4e19791), [range-based for-loop](https://cppinsights.io/s/0cddd172), or [auto](https://cppinsights.io/s/6c61d601). Of course, you can transform any other C++ snippet.\n\nSee yourself. C++ Insights is available online: [cppinsights.io](https://cppinsights.io).\n\nStill, there is work to do.\n\nI do not claim to get all the things right. I'm also working on supporting features from new standards, like C++20, at the moment.\nPlease remember that C++ Insights is based on Clang and its understanding of the AST.\n\n\nI did a couple of talks about C++ Insights since I released C++ Insights. For example, at C++ now. Here are the [slides](https://andreasfertig.com/talks/dl/afertig-2021-cppnow-cpp-insights.pdf) and the [video](https://youtu.be/p-8wndrTaTs).\n\n\n## Building\n\nC++ Insights can be built inside or outside the Clang source tree.\n\n### Building on Windows\n\nSee [Readme_Windows.md](Readme_Windows.md)\n\n### Building on Arch Linux\n\nTo build with `extra/clang` use the following extra flags: `-DINSIGHTS_USE_SYSTEM_INCLUDES=off -DCLANG_LINK_CLANG_DYLIB=on -DLLVM_LINK_LLVM_DYLIB=on`\n\nSee https://github.com/andreasfertig/cppinsights/issues/186 for an explanation of why `INSIGHTS_USE_SYSTEM_INCLUDES` needs to be turned off.\n\n`extra/clang` and `extra/llvm` provide `/usr/lib/{libclangAST.so,libLLVM*.a,libLLVM.so}`. `libclangAST.so` needs `libLLVM.so` and there would be a conflict if `libLLVM*.a` (instead of `libLLVM.so`) are linked. See https://bugs.archlinux.org/task/60512\n\n\n### Building outside Clang\n\nYou need to have a Clang installation in the search path.\n\n```\ngit clone https://github.com/andreasfertig/cppinsights.git\nmkdir build && cd build\ncmake -G\"Ninja\" ../cppinsights\nninja\n```\nThe resulting binary (insights) can be found in the `build` folder.\n\n### Building inside Clang\n\nThe easiest way to build C++ Insights inside the Clang source tree is using the `LLVM_EXTERNAL_PROJECTS` option.\n\n```\ngit clone https://github.com/llvm/llvm-project.git\ngit clone https://github.com/andreasfertig/cppinsights.git\n\nmkdir build\ncd build\ncmake -G Ninja -D=CMAKE_BUILD_TYPE=Release -DLLVM_EXTERNAL_PROJECTS=cppinsights -DLLVM_EXTERNAL_CPPINSIGHTS_SOURCE_DIR=<PATH/TO/cppinsights>  [INSIGHTS CMAKE OPTIONS] ../llvm-project/llvm\n\nninja\n```\n\n\n\n### cmake options\n\nThere are a couple of options that can be enabled with [cmake](https://cmake.org):\n\n| Option              | Description                | Default |\n|---------------------|:---------------------------| --------|\n| INSIGHTS_STRIP      | Strip insight after build  | ON      |\n| INSIGHTS_STATIC     | Use static linking         | OFF     |\n| INSIGHTS_COVERAGE   | Enable code coverage       | OFF     |\n| INSIGHTS_USE_LIBCPP | Use libc++ for tests       | OFF     |\n| DEBUG               | Enable debug               | OFF     |\n\n### Building for ARM on macOS\n\nIt seems best to supply the architecture during configuration:\n\n```\ncmake -DCMAKE_OSX_ARCHITECTURES=arm64 ../cppinsights\n```\n\n\n### Use it with [Cevelop](https://www.cevelop.com)\n\n```\ngit clone https://github.com/andreasfertig/cppinsights.git\nmkdir build_eclipse\ncd build_eclipse\ncmake -G\"Eclipse CDT4 - Unix Makefiles\" ../cppinsights/\n```\n\nThen, in [Cevelop](https://www.cevelop.com) Import -> General -> Existing Project into Workspace. Select `build_eclipse`. Enjoy editing with\n[Cevelop](https://www.cevelop.com).\n\n## Usage\n\nUsing C++ Insights is fairly simple:\n\n```\ninsights <YOUR_CPP_FILE> -- -std=c++17\n```\n\nThings get complicated when it comes to the system-include paths. These paths are hard-coded in the binary, which seems\nto come from the compiler C++ Insights was built with. To help with that, check out [scripts/getinclude.py](scripts/getinclude.py). The script tries to\ncollect the system-include paths from the compiler. Without an option, `getinclude.py` uses `g++`. You can also pass another compiler\nas a first argument.\n\nHere is an example:\n\n```\n./scripts/getinclude.py\n-isystem/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1 -isystem/usr/local/include -isystem/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/7.3.0/include -isystem/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include -isystem/usr/include\n```\n\nThe script can be used together with C++ Insights:\n\n```\ninsights <YOUR_CPP_FILE> -- -std=c++17 `./scripts/getinclude.py`\n```\n\n\n### Custom GCC installation\n\nIn case you have a custom build of the GCC compiler, for example, gcc-11.2.0, and _NOT_ installed in the compiler in the default system path, then after building, Clang fails to find the correct `libstdc++` path (GCC's STL). If you run into this situation, you can use \"`--gcc-toolchain=/path/GCC-1x.x.x/installed/path`\" to tell Clang/C++ Insights the location of the STL:\n\n```\n./cppinsights Insights.cpp -- --gcc-toolchain=${GCC_11_2_0_INSTALL_PATH} -std=c++20\n```\n\nHere \"`${GCC_11_2_0_INSTALL_PATH}`\" is the installation directory of your customized-built GCC. The option for Clang is described [here](https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-gcc-toolchain).\n\n\n### Ready to use Docker container\n\nThere is also another GitHub project that sets up a docker container with the latest C++ Insights version in it: [C++\nInsights - Docker](https://github.com/andreasfertig/cppinsights-docker)\n\n\n## Plugins / Extensions / Packages\n\n### C++ Insights @ Vim\n\nA plugin for Vim is available at\n[here](https://github.com/Freed-Wu/cppinsights.vim).\n\n### C++ Insights @ Neovim\n\nA plugin for Neovim is available at\n[here](https://github.com/Freed-Wu/cppinsights.nvim).\n\n### C++ Insights @ VSCode\n\nAn extension for Visual Studio Code is available at the VS Code marketplace: [C++\nInsights - VSCode Extension](https://marketplace.visualstudio.com/items?itemName=devtbi.vscode-cppinsights).\n\n\n### C++ Insights @ brew\n\nAt least for macOS, you can install C++ Insights via Homebrew thanks to [this formular](https://formulae.brew.sh/formula/cppinsights):\n\n```\nbrew install cppinsights\n```\n\n\n## Compatibility\n\nI aim for the repository to compile with the latest version of Clang and at least the one before. The website tries to\nstay close to the latest release of Clang. However, due to certain issues (building Clang for Windows), the website's\nversion is often delayed by a few months.\n\n\n## C++ Insights @ YouTube\n\nI created a [YouTube](https://youtube.com/@andreas_fertig) channel where I release a new video each month. In\nthese videos, I use C++ Insights to show and explain certain C++ constructs, and sometimes I explain C++ Insights as well.\n\n\n## ToDo's\n\nSee [TODO](TODO.md).\n\n\n## Get Involved\n+ Report bugs/issues by submitting a [GitHub issue](https://github.com/andreasfertig/cppinsights/issues).\n+ Submit contributions using [pull requests](https://github.com/andreasfertig/cppinsights/pulls). See [Contributing](CONTRIBUTING.md)\n\n## Support\n\nIf you like to support the project, consider [submitting](CONTRIBUTING.md) a patch. Another alternative is to become a [GitHub Sponsor](https://github.com/sponsors/andreasfertig) or a [Patreon](https://www.patreon.com/cppinsights) supporter.\n\n\n"
        },
        {
          "name": "Readme_Windows.md",
          "type": "blob",
          "size": 2.3974609375,
          "content": "## Building on Windows {#building_on_windows}\r\n\r\n### Tested with (supported compilers)\r\n\r\n|         Name       | Version | Actual compiler |    Version    |        CMake command                      |\r\n|--------------------|---------|-----------------|---------------|-------------------------------------------|\r\n| Visual Studio 2019 | 16.1.3  |     cl.exe      | 19.21.27702.2 | -G \"Visual Studio 16 2019\" -A x64         |\r\n| Clang (VS 2019)    | 16.1.3  |   clang-cl.exe  | 8.0.0         | -G \"Visual Studio 16 2019\" -A x64 -T LLVM |\r\n\r\nNote: supports only building **outside** LLVM.\r\nThere is no support for x86 since there is no LLVM/Clang libraries for x86.\r\n\r\nFor Clang with VS:\r\n\r\n + go to [LLVM Download Page](http://releases.llvm.org/download.html);\r\n + install \"Windows (64-bit)\" from \"Pre-Built Binaries\" section;\r\n\r\nInstaller will automatically add LLVM toolset to all Visual Studio instances you have.\r\n\r\n### Build & install Clang from sources\r\n\r\nNeeded to have Clang libraries and `llvm-config.exe` to setup CMake.\r\n\r\nInstalls Clang/LLVM libraries to (for example) `C:\\Programs\\LLVM_local2`.\r\n\r\nNote:\r\n\r\n * it's important to have install path with no spaces\r\n * better to have something different from %Program Files%\r\n   since otherwise Administrator rights are needed to install files\r\n\r\n```\r\ngit clone https://github.com/llvm/llvm-project.git\r\ncd llvm-project\r\nmkdir build\r\ncd build\r\ncmake -DLLVM_ENABLE_PROJECTS=clang ^\r\n      -DCMAKE_INSTALL_PREFIX=C:\\Programs\\LLVM_local2 ^\r\n      -G \"Visual Studio 15 2017\" ^\r\n      -A x64 ^\r\n      -Thost=x64 ^\r\n      ..\\llvm\r\ncmake --build . --config Release --target install\r\n```\r\n\r\nYou can also open build/LLVM.sln solution in Visual Studio and build everything\r\nfrom there instead of using `cmake --build ...` command.\r\n\r\n### Build insights\r\n\r\nAssume:\r\n\r\n * cppinsights sources are in `C:\\dev\\cppinsights` and\r\n * LLVM/Clang built and installed into `C:\\Programs\\LLVM_local2` (see step above)\r\n \r\n\r\n```\r\ncd C:\\dev\\cppinsights\\\r\nmkdir build\r\ncd build\r\nset path=%path%;C:\\Programs\\LLVM_local2\\bin\r\ncmake -G \"Visual Studio 16 2019\" -A x64 -T LLVM_v142 ..\r\ncmake --build . --config Release --target insights\r\n```\r\n\r\nInstead of \"Visual Studio 16 2019\" generator with Clang,\r\nyou can choose whatever works for you.\r\nSee \"Tested with (supported compilers)\", *CMake command* column above.\r\n\r\nAlso, instead of building from command line, you can\r\nopen `build/cpp-insights.sln` and have fun with VS.\r\n\r\n\r\n"
        },
        {
          "name": "StackList.h",
          "type": "blob",
          "size": 2.53515625,
          "content": "#ifndef INSIGHTS_STACK_LIST_H\n#define INSIGHTS_STACK_LIST_H\n\n/// \\brief Base class for \\ref StackList.\n///\ntemplate<typename T>\nstruct StackListEntry\n{\n    StackListEntry* next{nullptr};\n    StackListEntry* prev{nullptr};\n};\n\n/// \\brief StackList is a container for a list which elements exist only on the stack.\n///\n/// The purpose is to keep allocation with new and delete away as long as stack seems to be\n/// available. The class is range based for loop ready.\n/// To use it a class needs to derive from \\ref StackListEntry.\n///\n/// Example:\n/// \\code\n//  class Foo : public StackListEntry<Foo> {...};\n/// \\endcode\ntemplate<typename T>\nclass StackList\n{\npublic:\n    using TStackListEntry = StackListEntry<T>;\n\n    StackList() = default;\n\n    void push(TStackListEntry& entry) noexcept\n    {\n        entry.next = nullptr;\n\n        if(!mFirst) {\n            mFirst       = &entry;\n            mFirst->prev = nullptr;\n\n        } else {\n            mLast->next = &entry;\n            entry.prev  = mLast;\n        }\n\n        mLast = &entry;\n    }\n\n    T* pop() noexcept\n    {\n        TStackListEntry* last = mLast;\n\n        if(mLast) {\n            mLast = mLast->prev;\n\n            if(mLast) {\n                mLast->next = nullptr;\n\n                last->next = nullptr;\n                last->prev = nullptr;\n            } else {\n                mFirst = nullptr;\n            }\n        }\n\n        return static_cast<T*>(last);\n    }\n\n    T& back() noexcept { return *static_cast<T*>(mLast); }\n\n    constexpr bool empty() const noexcept { return (nullptr == mLast); }\n\n    class StackListIterator\n    {\n    public:\n        StackListIterator(StackList& list)\n        : mCurrent{list.mFirst}\n        , mLast{list.mLast}\n        {\n        }\n\n        constexpr StackListIterator& begin() noexcept { return *this; }\n        constexpr StackListIterator& end() noexcept { return *this; }\n\n        constexpr T& operator*() noexcept { return *static_cast<T*>(mCurrent); }\n\n        constexpr StackListIterator& operator++() noexcept\n        {\n            if(mCurrent) {\n                mCurrent = mCurrent->next;\n            }\n\n            return *this;\n        }\n\n        constexpr bool operator!=(const TStackListEntry*) const noexcept { return (nullptr != mCurrent); }\n\n    private:\n        TStackListEntry* mCurrent;\n        TStackListEntry* mLast;\n    };\n\n    constexpr StackListIterator begin() noexcept { return StackListIterator{*this}; }\n    constexpr TStackListEntry*  end() noexcept { return mLast; }\n\nprivate:\n    TStackListEntry* mFirst{nullptr};\n    TStackListEntry* mLast{nullptr};\n};\n\n#endif\n"
        },
        {
          "name": "TODO.md",
          "type": "blob",
          "size": 0.87890625,
          "content": "# C++ Insights ToDo {#todo}\n\nThis is a list of things I plan to do. If you like to jump in that's great. Please have a look at the [Code of Conduct](CODE_OF_CONDUCT.md) and [Contributing](CONTRIBUTING.md) before starting.\n\n\n- [X] Add TODO.md\n- [X] Add CODE_OF_CONDUCT.md\n- [X] Add CONTRIBUTING.md\n- [X] Add Windows support\n- [X] macOS homebrew package\n- [ ] Linux debian package\n- [ ] Improve tests on other platforms than macOS\n- [ ] Temporary execute tests and check only for signals on other platforms than macOS\n- [X] Publish doxygen output -> see [https://docs.cppinsights.io](https://docs.cppinsights.io)\n- [X]  Switch between libc++ and libstdc++ headers?\n- [X] Add more headers like boost\n- [ ] Catch insights crashes and provide easy issue reporting including error output.\n- [X] Short links (public database?)\n- [X] Provide easy local installation (via docker)\n- [ ] Use libc++ on Windows\n\n"
        },
        {
          "name": "artwork",
          "type": "tree",
          "content": null
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.154296875,
          "content": "fixes:\n  - \"cppinsights/::\"\n  - \"/home/runner/work/cppinsights/cppinsights/::\"\n  - \"/Users/runner/work/cppinsights/cppinsights/::\"\n  - \"github/workspace/::\"\n\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.h.in",
          "type": "blob",
          "size": 0.787109375,
          "content": "#ifndef INSIGHTS_VERSION_H\n#define INSIGHTS_VERSION_H\n\n#define INSIGHTS_VERSION \"18.1\"\n#define GIT_REPO_URL \"@GIT_REPO_URL@\"\n#define GIT_COMMIT_HASH \"@GIT_COMMIT_HASH@\"\n\n#define INSIGHTS_MIN_LLVM_MAJOR_VERSION @INSIGHTS_MIN_LLVM_MAJOR_VERSION@\n\n\n#include <clang/Basic/Version.h>\n\n// Build Clang's resource dir and include dir by hand. This is necessary, as we do not always have Clang installed. \n// See: https://github.com/MaskRay/ccls/wiki/Install#clang-resource-directory\n#define INSIGHTS_CLANG_RESOURCE_DIR R\"(-resource-dir=@LLVM_LIBDIR@/clang/@LLVM_PACKAGE_VERSION_MAJOR_PLAIN@)\"\n#define INSIGHTS_CLANG_RESOURCE_INCLUDE_DIR R\"(-I @LLVM_LIBDIR@/clang/@LLVM_PACKAGE_VERSION_MAJOR_PLAIN@/include)\"\n#define INSIGHTS_LLVM_INCLUDE_DIR R\"(-isystem@LLVM_INCLUDE_DIR@/c++/v1)\"\n\n#endif /* INSIGHTS_VERSION_H */\n"
        }
      ]
    }
  ]
}