{
  "metadata": {
    "timestamp": 1736565734074,
    "page": 649,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "orlp/pdqsort",
      "stars": 2385,
      "defaultBranch": "master",
      "files": [
        {
          "name": "bench",
          "type": "tree",
          "content": null
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 0.853515625,
          "content": "Copyright (c) 2021 Orson Peters <orsonpeters@gmail.com>\n\nThis software is provided 'as-is', without any express or implied warranty. In no event will the\nauthors be held liable for any damages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose, including commercial\napplications, and to alter it and redistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must not claim that you wrote the\n   original software. If you use this software in a product, an acknowledgment in the product\n   documentation would be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and must not be misrepresented as\n   being the original software.\n\n3. This notice may not be removed or altered from any source distribution.\n"
        },
        {
          "name": "pdqsort.h",
          "type": "blob",
          "size": 22.115234375,
          "content": "/*\n    pdqsort.h - Pattern-defeating quicksort.\n\n    Copyright (c) 2021 Orson Peters\n\n    This software is provided 'as-is', without any express or implied warranty. In no event will the\n    authors be held liable for any damages arising from the use of this software.\n\n    Permission is granted to anyone to use this software for any purpose, including commercial\n    applications, and to alter it and redistribute it freely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not claim that you wrote the\n       original software. If you use this software in a product, an acknowledgment in the product\n       documentation would be appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be misrepresented as\n       being the original software.\n\n    3. This notice may not be removed or altered from any source distribution.\n*/\n\n\n#ifndef PDQSORT_H\n#define PDQSORT_H\n\n#include <algorithm>\n#include <cstddef>\n#include <functional>\n#include <utility>\n#include <iterator>\n\n#if __cplusplus >= 201103L\n    #include <cstdint>\n    #include <type_traits>\n    #define PDQSORT_PREFER_MOVE(x) std::move(x)\n#else\n    #define PDQSORT_PREFER_MOVE(x) (x)\n#endif\n\n\nnamespace pdqsort_detail {\n    enum {\n        // Partitions below this size are sorted using insertion sort.\n        insertion_sort_threshold = 24,\n\n        // Partitions above this size use Tukey's ninther to select the pivot.\n        ninther_threshold = 128,\n\n        // When we detect an already sorted partition, attempt an insertion sort that allows this\n        // amount of element moves before giving up.\n        partial_insertion_sort_limit = 8,\n\n        // Must be multiple of 8 due to loop unrolling, and < 256 to fit in unsigned char.\n        block_size = 64,\n\n        // Cacheline size, assumes power of two.\n        cacheline_size = 64\n\n    };\n\n#if __cplusplus >= 201103L\n    template<class T> struct is_default_compare : std::false_type { };\n    template<class T> struct is_default_compare<std::less<T>> : std::true_type { };\n    template<class T> struct is_default_compare<std::greater<T>> : std::true_type { };\n#endif\n\n    // Returns floor(log2(n)), assumes n > 0.\n    template<class T>\n    inline int log2(T n) {\n        int log = 0;\n        while (n >>= 1) ++log;\n        return log;\n    }\n\n    // Sorts [begin, end) using insertion sort with the given comparison function.\n    template<class Iter, class Compare>\n    inline void insertion_sort(Iter begin, Iter end, Compare comp) {\n        typedef typename std::iterator_traits<Iter>::value_type T;\n        if (begin == end) return;\n\n        for (Iter cur = begin + 1; cur != end; ++cur) {\n            Iter sift = cur;\n            Iter sift_1 = cur - 1;\n\n            // Compare first so we can avoid 2 moves for an element already positioned correctly.\n            if (comp(*sift, *sift_1)) {\n                T tmp = PDQSORT_PREFER_MOVE(*sift);\n\n                do { *sift-- = PDQSORT_PREFER_MOVE(*sift_1); }\n                while (sift != begin && comp(tmp, *--sift_1));\n\n                *sift = PDQSORT_PREFER_MOVE(tmp);\n            }\n        }\n    }\n\n    // Sorts [begin, end) using insertion sort with the given comparison function. Assumes\n    // *(begin - 1) is an element smaller than or equal to any element in [begin, end).\n    template<class Iter, class Compare>\n    inline void unguarded_insertion_sort(Iter begin, Iter end, Compare comp) {\n        typedef typename std::iterator_traits<Iter>::value_type T;\n        if (begin == end) return;\n\n        for (Iter cur = begin + 1; cur != end; ++cur) {\n            Iter sift = cur;\n            Iter sift_1 = cur - 1;\n\n            // Compare first so we can avoid 2 moves for an element already positioned correctly.\n            if (comp(*sift, *sift_1)) {\n                T tmp = PDQSORT_PREFER_MOVE(*sift);\n\n                do { *sift-- = PDQSORT_PREFER_MOVE(*sift_1); }\n                while (comp(tmp, *--sift_1));\n\n                *sift = PDQSORT_PREFER_MOVE(tmp);\n            }\n        }\n    }\n\n    // Attempts to use insertion sort on [begin, end). Will return false if more than\n    // partial_insertion_sort_limit elements were moved, and abort sorting. Otherwise it will\n    // successfully sort and return true.\n    template<class Iter, class Compare>\n    inline bool partial_insertion_sort(Iter begin, Iter end, Compare comp) {\n        typedef typename std::iterator_traits<Iter>::value_type T;\n        if (begin == end) return true;\n        \n        std::size_t limit = 0;\n        for (Iter cur = begin + 1; cur != end; ++cur) {\n            Iter sift = cur;\n            Iter sift_1 = cur - 1;\n\n            // Compare first so we can avoid 2 moves for an element already positioned correctly.\n            if (comp(*sift, *sift_1)) {\n                T tmp = PDQSORT_PREFER_MOVE(*sift);\n\n                do { *sift-- = PDQSORT_PREFER_MOVE(*sift_1); }\n                while (sift != begin && comp(tmp, *--sift_1));\n\n                *sift = PDQSORT_PREFER_MOVE(tmp);\n                limit += cur - sift;\n            }\n            \n            if (limit > partial_insertion_sort_limit) return false;\n        }\n\n        return true;\n    }\n\n    template<class Iter, class Compare>\n    inline void sort2(Iter a, Iter b, Compare comp) {\n        if (comp(*b, *a)) std::iter_swap(a, b);\n    }\n\n    // Sorts the elements *a, *b and *c using comparison function comp.\n    template<class Iter, class Compare>\n    inline void sort3(Iter a, Iter b, Iter c, Compare comp) {\n        sort2(a, b, comp);\n        sort2(b, c, comp);\n        sort2(a, b, comp);\n    }\n\n    template<class T>\n    inline T* align_cacheline(T* p) {\n#if defined(UINTPTR_MAX) && __cplusplus >= 201103L\n        std::uintptr_t ip = reinterpret_cast<std::uintptr_t>(p);\n#else\n        std::size_t ip = reinterpret_cast<std::size_t>(p);\n#endif\n        ip = (ip + cacheline_size - 1) & -cacheline_size;\n        return reinterpret_cast<T*>(ip);\n    }\n\n    template<class Iter>\n    inline void swap_offsets(Iter first, Iter last,\n                             unsigned char* offsets_l, unsigned char* offsets_r,\n                             size_t num, bool use_swaps) {\n        typedef typename std::iterator_traits<Iter>::value_type T;\n        if (use_swaps) {\n            // This case is needed for the descending distribution, where we need\n            // to have proper swapping for pdqsort to remain O(n).\n            for (size_t i = 0; i < num; ++i) {\n                std::iter_swap(first + offsets_l[i], last - offsets_r[i]);\n            }\n        } else if (num > 0) {\n            Iter l = first + offsets_l[0]; Iter r = last - offsets_r[0];\n            T tmp(PDQSORT_PREFER_MOVE(*l)); *l = PDQSORT_PREFER_MOVE(*r);\n            for (size_t i = 1; i < num; ++i) {\n                l = first + offsets_l[i]; *r = PDQSORT_PREFER_MOVE(*l);\n                r = last - offsets_r[i]; *l = PDQSORT_PREFER_MOVE(*r);\n            }\n            *r = PDQSORT_PREFER_MOVE(tmp);\n        }\n    }\n\n    // Partitions [begin, end) around pivot *begin using comparison function comp. Elements equal\n    // to the pivot are put in the right-hand partition. Returns the position of the pivot after\n    // partitioning and whether the passed sequence already was correctly partitioned. Assumes the\n    // pivot is a median of at least 3 elements and that [begin, end) is at least\n    // insertion_sort_threshold long. Uses branchless partitioning.\n    template<class Iter, class Compare>\n    inline std::pair<Iter, bool> partition_right_branchless(Iter begin, Iter end, Compare comp) {\n        typedef typename std::iterator_traits<Iter>::value_type T;\n\n        // Move pivot into local for speed.\n        T pivot(PDQSORT_PREFER_MOVE(*begin));\n        Iter first = begin;\n        Iter last = end;\n\n        // Find the first element greater than or equal than the pivot (the median of 3 guarantees\n        // this exists).\n        while (comp(*++first, pivot));\n\n        // Find the first element strictly smaller than the pivot. We have to guard this search if\n        // there was no element before *first.\n        if (first - 1 == begin) while (first < last && !comp(*--last, pivot));\n        else                    while (                !comp(*--last, pivot));\n\n        // If the first pair of elements that should be swapped to partition are the same element,\n        // the passed in sequence already was correctly partitioned.\n        bool already_partitioned = first >= last;\n        if (!already_partitioned) {\n            std::iter_swap(first, last);\n            ++first;\n\n            // The following branchless partitioning is derived from \"BlockQuicksort: How Branch\n            // Mispredictions donâ€™t affect Quicksort\" by Stefan Edelkamp and Armin Weiss, but\n            // heavily micro-optimized.\n            unsigned char offsets_l_storage[block_size + cacheline_size];\n            unsigned char offsets_r_storage[block_size + cacheline_size];\n            unsigned char* offsets_l = align_cacheline(offsets_l_storage);\n            unsigned char* offsets_r = align_cacheline(offsets_r_storage);\n\n            Iter offsets_l_base = first;\n            Iter offsets_r_base = last;\n            size_t num_l, num_r, start_l, start_r;\n            num_l = num_r = start_l = start_r = 0;\n            \n            while (first < last) {\n                // Fill up offset blocks with elements that are on the wrong side.\n                // First we determine how much elements are considered for each offset block.\n                size_t num_unknown = last - first;\n                size_t left_split = num_l == 0 ? (num_r == 0 ? num_unknown / 2 : num_unknown) : 0;\n                size_t right_split = num_r == 0 ? (num_unknown - left_split) : 0;\n\n                // Fill the offset blocks.\n                if (left_split >= block_size) {\n                    for (size_t i = 0; i < block_size;) {\n                        offsets_l[num_l] = i++; num_l += !comp(*first, pivot); ++first;\n                        offsets_l[num_l] = i++; num_l += !comp(*first, pivot); ++first;\n                        offsets_l[num_l] = i++; num_l += !comp(*first, pivot); ++first;\n                        offsets_l[num_l] = i++; num_l += !comp(*first, pivot); ++first;\n                        offsets_l[num_l] = i++; num_l += !comp(*first, pivot); ++first;\n                        offsets_l[num_l] = i++; num_l += !comp(*first, pivot); ++first;\n                        offsets_l[num_l] = i++; num_l += !comp(*first, pivot); ++first;\n                        offsets_l[num_l] = i++; num_l += !comp(*first, pivot); ++first;\n                    }\n                } else {\n                    for (size_t i = 0; i < left_split;) {\n                        offsets_l[num_l] = i++; num_l += !comp(*first, pivot); ++first;\n                    }\n                }\n\n                if (right_split >= block_size) {\n                    for (size_t i = 0; i < block_size;) {\n                        offsets_r[num_r] = ++i; num_r += comp(*--last, pivot);\n                        offsets_r[num_r] = ++i; num_r += comp(*--last, pivot);\n                        offsets_r[num_r] = ++i; num_r += comp(*--last, pivot);\n                        offsets_r[num_r] = ++i; num_r += comp(*--last, pivot);\n                        offsets_r[num_r] = ++i; num_r += comp(*--last, pivot);\n                        offsets_r[num_r] = ++i; num_r += comp(*--last, pivot);\n                        offsets_r[num_r] = ++i; num_r += comp(*--last, pivot);\n                        offsets_r[num_r] = ++i; num_r += comp(*--last, pivot);\n                    }\n                } else {\n                    for (size_t i = 0; i < right_split;) {\n                        offsets_r[num_r] = ++i; num_r += comp(*--last, pivot);\n                    }\n                }\n\n                // Swap elements and update block sizes and first/last boundaries.\n                size_t num = std::min(num_l, num_r);\n                swap_offsets(offsets_l_base, offsets_r_base,\n                             offsets_l + start_l, offsets_r + start_r,\n                             num, num_l == num_r);\n                num_l -= num; num_r -= num;\n                start_l += num; start_r += num;\n\n                if (num_l == 0) {\n                    start_l = 0;\n                    offsets_l_base = first;\n                }\n                \n                if (num_r == 0) {\n                    start_r = 0;\n                    offsets_r_base = last;\n                }\n            }\n\n            // We have now fully identified [first, last)'s proper position. Swap the last elements.\n            if (num_l) {\n                offsets_l += start_l;\n                while (num_l--) std::iter_swap(offsets_l_base + offsets_l[num_l], --last);\n                first = last;\n            }\n            if (num_r) {\n                offsets_r += start_r;\n                while (num_r--) std::iter_swap(offsets_r_base - offsets_r[num_r], first), ++first;\n                last = first;\n            }\n        }\n\n        // Put the pivot in the right place.\n        Iter pivot_pos = first - 1;\n        *begin = PDQSORT_PREFER_MOVE(*pivot_pos);\n        *pivot_pos = PDQSORT_PREFER_MOVE(pivot);\n\n        return std::make_pair(pivot_pos, already_partitioned);\n    }\n\n\n\n    // Partitions [begin, end) around pivot *begin using comparison function comp. Elements equal\n    // to the pivot are put in the right-hand partition. Returns the position of the pivot after\n    // partitioning and whether the passed sequence already was correctly partitioned. Assumes the\n    // pivot is a median of at least 3 elements and that [begin, end) is at least\n    // insertion_sort_threshold long.\n    template<class Iter, class Compare>\n    inline std::pair<Iter, bool> partition_right(Iter begin, Iter end, Compare comp) {\n        typedef typename std::iterator_traits<Iter>::value_type T;\n        \n        // Move pivot into local for speed.\n        T pivot(PDQSORT_PREFER_MOVE(*begin));\n\n        Iter first = begin;\n        Iter last = end;\n\n        // Find the first element greater than or equal than the pivot (the median of 3 guarantees\n        // this exists).\n        while (comp(*++first, pivot));\n\n        // Find the first element strictly smaller than the pivot. We have to guard this search if\n        // there was no element before *first.\n        if (first - 1 == begin) while (first < last && !comp(*--last, pivot));\n        else                    while (                !comp(*--last, pivot));\n\n        // If the first pair of elements that should be swapped to partition are the same element,\n        // the passed in sequence already was correctly partitioned.\n        bool already_partitioned = first >= last;\n        \n        // Keep swapping pairs of elements that are on the wrong side of the pivot. Previously\n        // swapped pairs guard the searches, which is why the first iteration is special-cased\n        // above.\n        while (first < last) {\n            std::iter_swap(first, last);\n            while (comp(*++first, pivot));\n            while (!comp(*--last, pivot));\n        }\n\n        // Put the pivot in the right place.\n        Iter pivot_pos = first - 1;\n        *begin = PDQSORT_PREFER_MOVE(*pivot_pos);\n        *pivot_pos = PDQSORT_PREFER_MOVE(pivot);\n\n        return std::make_pair(pivot_pos, already_partitioned);\n    }\n\n    // Similar function to the one above, except elements equal to the pivot are put to the left of\n    // the pivot and it doesn't check or return if the passed sequence already was partitioned.\n    // Since this is rarely used (the many equal case), and in that case pdqsort already has O(n)\n    // performance, no block quicksort is applied here for simplicity.\n    template<class Iter, class Compare>\n    inline Iter partition_left(Iter begin, Iter end, Compare comp) {\n        typedef typename std::iterator_traits<Iter>::value_type T;\n\n        T pivot(PDQSORT_PREFER_MOVE(*begin));\n        Iter first = begin;\n        Iter last = end;\n        \n        while (comp(pivot, *--last));\n\n        if (last + 1 == end) while (first < last && !comp(pivot, *++first));\n        else                 while (                !comp(pivot, *++first));\n\n        while (first < last) {\n            std::iter_swap(first, last);\n            while (comp(pivot, *--last));\n            while (!comp(pivot, *++first));\n        }\n\n        Iter pivot_pos = last;\n        *begin = PDQSORT_PREFER_MOVE(*pivot_pos);\n        *pivot_pos = PDQSORT_PREFER_MOVE(pivot);\n\n        return pivot_pos;\n    }\n\n\n    template<class Iter, class Compare, bool Branchless>\n    inline void pdqsort_loop(Iter begin, Iter end, Compare comp, int bad_allowed, bool leftmost = true) {\n        typedef typename std::iterator_traits<Iter>::difference_type diff_t;\n\n        // Use a while loop for tail recursion elimination.\n        while (true) {\n            diff_t size = end - begin;\n\n            // Insertion sort is faster for small arrays.\n            if (size < insertion_sort_threshold) {\n                if (leftmost) insertion_sort(begin, end, comp);\n                else unguarded_insertion_sort(begin, end, comp);\n                return;\n            }\n\n            // Choose pivot as median of 3 or pseudomedian of 9.\n            diff_t s2 = size / 2;\n            if (size > ninther_threshold) {\n                sort3(begin, begin + s2, end - 1, comp);\n                sort3(begin + 1, begin + (s2 - 1), end - 2, comp);\n                sort3(begin + 2, begin + (s2 + 1), end - 3, comp);\n                sort3(begin + (s2 - 1), begin + s2, begin + (s2 + 1), comp);\n                std::iter_swap(begin, begin + s2);\n            } else sort3(begin + s2, begin, end - 1, comp);\n\n            // If *(begin - 1) is the end of the right partition of a previous partition operation\n            // there is no element in [begin, end) that is smaller than *(begin - 1). Then if our\n            // pivot compares equal to *(begin - 1) we change strategy, putting equal elements in\n            // the left partition, greater elements in the right partition. We do not have to\n            // recurse on the left partition, since it's sorted (all equal).\n            if (!leftmost && !comp(*(begin - 1), *begin)) {\n                begin = partition_left(begin, end, comp) + 1;\n                continue;\n            }\n\n            // Partition and get results.\n            std::pair<Iter, bool> part_result =\n                Branchless ? partition_right_branchless(begin, end, comp)\n                           : partition_right(begin, end, comp);\n            Iter pivot_pos = part_result.first;\n            bool already_partitioned = part_result.second;\n\n            // Check for a highly unbalanced partition.\n            diff_t l_size = pivot_pos - begin;\n            diff_t r_size = end - (pivot_pos + 1);\n            bool highly_unbalanced = l_size < size / 8 || r_size < size / 8;\n\n            // If we got a highly unbalanced partition we shuffle elements to break many patterns.\n            if (highly_unbalanced) {\n                // If we had too many bad partitions, switch to heapsort to guarantee O(n log n).\n                if (--bad_allowed == 0) {\n                    std::make_heap(begin, end, comp);\n                    std::sort_heap(begin, end, comp);\n                    return;\n                }\n\n                if (l_size >= insertion_sort_threshold) {\n                    std::iter_swap(begin,             begin + l_size / 4);\n                    std::iter_swap(pivot_pos - 1, pivot_pos - l_size / 4);\n\n                    if (l_size > ninther_threshold) {\n                        std::iter_swap(begin + 1,         begin + (l_size / 4 + 1));\n                        std::iter_swap(begin + 2,         begin + (l_size / 4 + 2));\n                        std::iter_swap(pivot_pos - 2, pivot_pos - (l_size / 4 + 1));\n                        std::iter_swap(pivot_pos - 3, pivot_pos - (l_size / 4 + 2));\n                    }\n                }\n                \n                if (r_size >= insertion_sort_threshold) {\n                    std::iter_swap(pivot_pos + 1, pivot_pos + (1 + r_size / 4));\n                    std::iter_swap(end - 1,                   end - r_size / 4);\n                    \n                    if (r_size > ninther_threshold) {\n                        std::iter_swap(pivot_pos + 2, pivot_pos + (2 + r_size / 4));\n                        std::iter_swap(pivot_pos + 3, pivot_pos + (3 + r_size / 4));\n                        std::iter_swap(end - 2,             end - (1 + r_size / 4));\n                        std::iter_swap(end - 3,             end - (2 + r_size / 4));\n                    }\n                }\n            } else {\n                // If we were decently balanced and we tried to sort an already partitioned\n                // sequence try to use insertion sort.\n                if (already_partitioned && partial_insertion_sort(begin, pivot_pos, comp)\n                                        && partial_insertion_sort(pivot_pos + 1, end, comp)) return;\n            }\n                \n            // Sort the left partition first using recursion and do tail recursion elimination for\n            // the right-hand partition.\n            pdqsort_loop<Iter, Compare, Branchless>(begin, pivot_pos, comp, bad_allowed, leftmost);\n            begin = pivot_pos + 1;\n            leftmost = false;\n        }\n    }\n}\n\n\ntemplate<class Iter, class Compare>\ninline void pdqsort(Iter begin, Iter end, Compare comp) {\n    if (begin == end) return;\n\n#if __cplusplus >= 201103L\n    pdqsort_detail::pdqsort_loop<Iter, Compare,\n        pdqsort_detail::is_default_compare<typename std::decay<Compare>::type>::value &&\n        std::is_arithmetic<typename std::iterator_traits<Iter>::value_type>::value>(\n        begin, end, comp, pdqsort_detail::log2(end - begin));\n#else\n    pdqsort_detail::pdqsort_loop<Iter, Compare, false>(\n        begin, end, comp, pdqsort_detail::log2(end - begin));\n#endif\n}\n\ntemplate<class Iter>\ninline void pdqsort(Iter begin, Iter end) {\n    typedef typename std::iterator_traits<Iter>::value_type T;\n    pdqsort(begin, end, std::less<T>());\n}\n\ntemplate<class Iter, class Compare>\ninline void pdqsort_branchless(Iter begin, Iter end, Compare comp) {\n    if (begin == end) return;\n    pdqsort_detail::pdqsort_loop<Iter, Compare, true>(\n        begin, end, comp, pdqsort_detail::log2(end - begin));\n}\n\ntemplate<class Iter>\ninline void pdqsort_branchless(Iter begin, Iter end) {\n    typedef typename std::iterator_traits<Iter>::value_type T;\n    pdqsort_branchless(begin, end, std::less<T>());\n}\n\n\n#undef PDQSORT_PREFER_MOVE\n\n#endif\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 6.15234375,
          "content": "pdqsort\n-------\n\nPattern-defeating quicksort (pdqsort) is a novel sorting algorithm that combines the fast average\ncase of randomized quicksort with the fast worst case of heapsort, while achieving linear time on\ninputs with certain patterns. pdqsort is an extension and improvement of David Mussers introsort.\nAll code is available for free under the zlib license.\n\n    Best        Average     Worst       Memory      Stable      Deterministic\n    n           n log n     n log n     log n       No          Yes\n\n### Usage\n\n`pdqsort` is a drop-in replacement for [`std::sort`](http://en.cppreference.com/w/cpp/algorithm/sort).\nJust replace a call to `std::sort` with `pdqsort` to start using pattern-defeating quicksort. If your\ncomparison function is branchless, you can call `pdqsort_branchless` for a potential big speedup. If\nyou are using C++11, the type you're sorting is arithmetic and your comparison function is not given\nor is `std::less`/`std::greater`, `pdqsort` automatically delegates to `pdqsort_branchless`.\n\n### Benchmark\n\nA comparison of pdqsort and GCC's `std::sort` and `std::stable_sort` with various input\ndistributions:\n\n![Performance graph](http://i.imgur.com/1RnIGBO.png)\n\nCompiled with `-std=c++11 -O2 -m64 -march=native`.\n\n\n### Visualization\n\nA visualization of pattern-defeating quicksort sorting a ~200 element array with some duplicates.\nGenerated using Timo Bingmann's [The Sound of Sorting](http://panthema.net/2013/sound-of-sorting/)\nprogram, a tool that has been invaluable during the development of pdqsort. For the purposes of\nthis visualization the cutoff point for insertion sort was lowered to 8 elements.\n\n![Visualization](http://i.imgur.com/QzFG09F.gif)\n\n\n### The best case\n\npdqsort is designed to run in linear time for a couple of best-case patterns. Linear time is\nachieved for inputs that are in strictly ascending or descending order, only contain equal elements,\nor are strictly in ascending order followed by one out-of-place element. There are two separate\nmechanisms at play to achieve this.\n\nFor equal elements a smart partitioning scheme is used that always puts equal elements in the\npartition containing elements greater than the pivot. When a new pivot is chosen it's compared to\nthe greatest element in the partition before it. If they compare equal we can derive that there are\nno elements smaller than the chosen pivot. When this happens we switch strategy for this partition,\nand filter out all elements equal to the pivot.\n\nTo get linear time for the other patterns we check after every partition if any swaps were made. If\nno swaps were made and the partition was decently balanced we will optimistically attempt to use\ninsertion sort. This insertion sort aborts if more than a constant amount of moves are required to\nsort.\n\n\n### The average case\n\nOn average case data where no patterns are detected pdqsort is effectively a quicksort that uses\nmedian-of-3 pivot selection, switching to insertion sort if the number of elements to be\n(recursively) sorted is small. The overhead associated with detecting the patterns for the best case\nis so small it lies within the error of measurement.\n\npdqsort gets a great speedup over the traditional way of implementing quicksort when sorting large\narrays (1000+ elements). This is due to a new technique described in \"BlockQuicksort: How Branch\nMispredictions don't affect Quicksort\" by Stefan Edelkamp and Armin Weiss. In short, we bypass the\nbranch predictor by using small buffers (entirely in L1 cache) of the indices of elements that need\nto be swapped. We fill these buffers in a branch-free way that's quite elegant (in pseudocode):\n\n```cpp\nbuffer_num = 0; buffer_max_size = 64;\nfor (int i = 0; i < buffer_max_size; ++i) {\n    // With branch:\n    if (elements[i] < pivot) { buffer[buffer_num] = i; buffer_num++; }\n    // Without:\n    buffer[buffer_num] = i; buffer_num += (elements[i] < pivot);\n}\n```\n\nThis is only a speedup if the comparison function itself is branchless, however. By default pdqsort\nwill detect this if you're using C++11 or higher, the type you're sorting is arithmetic (e.g.\n`int`), and you're using either `std::less` or `std::greater`. You can explicitly request branchless\npartitioning by calling `pdqsort_branchless` instead of `pdqsort`.\n\n\n### The worst case\n\nQuicksort naturally performs bad on inputs that form patterns, due to it being a partition-based\nsort. Choosing a bad pivot will result in many comparisons that give little to no progress in the\nsorting process. If the pattern does not get broken up, this can happen many times in a row. Worse,\nreal world data is filled with these patterns.\n\nTraditionally the solution to this is to randomize the pivot selection of quicksort. While this\ntechnically still allows for a quadratic worst case, the chances of it happening are astronomically\nsmall. Later, in introsort, pivot selection is kept deterministic, instead switching to the\nguaranteed O(n log n) heapsort if the recursion depth becomes too big. In pdqsort we adopt a hybrid\napproach, (deterministically) shuffling some elements to break up patterns when we encounter a \"bad\"\npartition. If we encounter too many \"bad\" partitions we switch to heapsort.\n\n\n### Bad partitions\n\nA bad partition occurs when the position of the pivot after partitioning is under 12.5% (1/8th)\npercentile or over 87,5% percentile - the partition is highly unbalanced. When this happens we will\nshuffle four elements at fixed locations for both partitions. This effectively breaks up many\npatterns. If we encounter more than log(n) bad partitions we will switch to heapsort.\n\nThe 1/8th percentile is not chosen arbitrarily. An upper bound of quicksorts worst case runtime can\nbe approximated within a constant factor by the following recurrence:\n\n    T(n, p) = n + T(p(n-1), p) + T((1-p)(n-1), p)\n\nWhere n is the number of elements, and p is the percentile of the pivot after partitioning.\n`T(n, 1/2)` is the best case for quicksort. On modern systems heapsort is profiled to be\napproximately 1.8 to 2 times as slow as quicksort. Choosing p such that `T(n, 1/2) / T(n, p) ~= 1.9`\nas n gets big will ensure that we will only switch to heapsort if it would speed up the sorting.\np = 1/8 is a reasonably close value and is cheap to compute on every platform using a bitshift.\n"
        }
      ]
    }
  ]
}