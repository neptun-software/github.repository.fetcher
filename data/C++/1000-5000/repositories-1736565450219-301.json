{
  "metadata": {
    "timestamp": 1736565450219,
    "page": 301,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nodejs/nan",
      "stars": 3293,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".dntrc",
          "type": "blob",
          "size": 0.72265625,
          "content": "## DNT config file\n## see https://github.com/rvagg/dnt\n\nNODE_VERSIONS=\"\\\n  master   \\\n  v0.11.13 \\\n  v0.10.30 \\\n  v0.10.29 \\\n  v0.10.28 \\\n  v0.10.26 \\\n  v0.10.25 \\\n  v0.10.24 \\\n  v0.10.23 \\\n  v0.10.22 \\\n  v0.10.21 \\\n  v0.10.20 \\\n  v0.10.19 \\\n  v0.8.28  \\\n  v0.8.27  \\\n  v0.8.26  \\\n  v0.8.24  \\\n\"\nOUTPUT_PREFIX=\"nan-\"\nTEST_CMD=\"                                                                        \\\n  cd /dnt/ &&                                                                     \\\n  npm install &&                                                                  \\\n  node_modules/.bin/node-gyp --nodedir /usr/src/node/ rebuild --directory test && \\\n  node_modules/.bin/tap --gc test/js/*-test.js                                    \\\n\"\n\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01953125,
          "content": "build/\nnode_modules/"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.1005859375,
          "content": "test/\nexamples/\n.dntrc\n.travis.yml\n.npmignore\nappveyor.yml\nMakefile\ncpplint.py\nnan-*.tgz\ndoc/.build.sh\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 2.056640625,
          "content": "os:\n  - linux\n  - osx\nlanguage: cpp\naddons:\n  apt:\n    sources:\n    - ubuntu-toolchain-r-test\n    packages:\n    - bc\n    - g++-4.8\nenv:\n  matrix:\n  - TRAVIS_NODE_VERSION=\"0.10\"\n  - TRAVIS_NODE_VERSION=\"0.12\"\n  - TRAVIS_NODE_VERSION=\"4\"\n  - TRAVIS_NODE_VERSION=\"5\"\n  - TRAVIS_NODE_VERSION=\"6\"\n  - TRAVIS_NODE_VERSION=\"7\"\n  - TRAVIS_NODE_VERSION=\"8\"\n  - TRAVIS_NODE_VERSION=\"9\"\n  - TRAVIS_NODE_VERSION=\"10\"\n  - TRAVIS_NODE_VERSION=\"11\"\n  - TRAVIS_NODE_VERSION=\"12\"\n  - TRAVIS_NODE_VERSION=\"13\"\n  - TRAVIS_NODE_VERSION=\"14\"\n  - TRAVIS_NODE_VERSION=\"15\"\n  - TRAVIS_NODE_VERSION=\"16\"\n  - TRAVIS_NODE_VERSION=\"17\"\n  - TRAVIS_NODE_VERSION=\"18\"\n  - TRAVIS_NODE_VERSION=\"19\"\n  - TRAVIS_NODE_VERSION=\"20\"\n  - TRAVIS_NODE_VERSION=\"lts/*\" ELECTRON_VERSION=\"2.0.18\"\n  - TRAVIS_NODE_VERSION=\"lts/*\" ELECTRON_VERSION=\"3.1.13\"\n  - TRAVIS_NODE_VERSION=\"lts/*\" ELECTRON_VERSION=\"4.2.12\"\n  - TRAVIS_NODE_VERSION=\"lts/*\" ELECTRON_VERSION=\"5.0.13\"\n  - TRAVIS_NODE_VERSION=\"lts/*\" ELECTRON_VERSION=\"6.1.10\"\n  - TRAVIS_NODE_VERSION=\"lts/*\" ELECTRON_VERSION=\"7.2.3\"\n  - TRAVIS_NODE_VERSION=\"lts/*\" ELECTRON_VERSION=\"8.2.3\"\nmatrix:\n  exclude:\n    - os: osx\n      env: TRAVIS_NODE_VERSION=\"0.12\"\ninstall:\n  - rm -rf ~/.nvm && git clone https://github.com/creationix/nvm.git ~/.nvm && (cd ~/.nvm && git checkout `git describe --abbrev=0 --tags`) && source ~/.nvm/nvm.sh && nvm install $TRAVIS_NODE_VERSION\n  - if [[ $TRAVIS_OS_NAME == \"linux\" ]]; then export CXX=g++-4.8; fi\n  - $CXX --version\n  - if [[ $TRAVIS_NODE_VERSION == \"0.8\" ]]; then npm config set strict-ssl false; fi\n  - if [[ -z \"$ELECTRON_VERSION\" && $(echo \"$TRAVIS_NODE_VERSION < 4\" | bc -l)  == \"1\" ]]; then npm install npm@2 && mv node_modules npm && npm/.bin/npm --version && npm/.bin/npm install; else npm --version && npm install; fi\n  - if [[ -z \"$ELECTRON_VERSION\" ]]; then node_modules/.bin/node-gyp rebuild --directory test; else node_modules/.bin/node-gyp rebuild --target=v$ELECTRON_VERSION --dist-url=https://atom.io/download/electron --directory test; fi\nscript:\n  - if [[ -z \"$ELECTRON_VERSION\" ]]; then node_modules/.bin/tap --gc test/js/*-test.js; fi\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 21.955078125,
          "content": "# NAN ChangeLog\n\n**Version 2.22.0: current Node 22.9.0, Node 0.12: 0.12.18, Node 0.10: 0.10.48, iojs: 3.3.1**\n\n### 2.22.0 Oct 11 2024\n\n  - Feature: replace SetAccessor -> SetNativeDataProperty (#977) 6bd62c9a0004339d5d1e18a945c84929d0f6b808\n\n### 2.21.0 Oct 10 2024\n\n  - Feature: Support for node version 20.17.0 (#976) a7df36eda8a7fe8581c00a18590f5e4faafca7ae\n\n### 2.20.0 Jun 12 2024\n\n  - Feature: fix removal of v8::CopyablePersistent (#970) 5805ca5c4c2eef9a65316b68741e29f4825c511f\n\n### 2.19.0 Mar 6 2024\n\n  - Feature: Fix builds for Electron 29 (#966) 1b630ddb3412cde35b64513662b440f9fd71e1ff\n\n### 2.18.0 Sep 12 2023\n\n  - Feature: Cast v8::Object::GetInternalField() return value to v8::Value (#956) bdfee1788239f735b67fe6b46b1439da755e9b62\n\n### 2.17.0 Oct 10 2022\n\n  - Feature: overload deprecated AccessorSignatures (#943) 7f9ceb80fbc45c9ba1a10e6591ccbef9e8dee6b4\n\n### 2.16.0 May 25 2022\n\n  - Feature: Add support for Node 18 (#937) 16fa32231e2ccd89d2804b3f765319128b20c4ac\n\n### 2.15.0 Aug 4 2021\n\n  - Feature: add ScriptOrigin (#918) d09debf9eeedcb7ca4073e84ffe5fbb455ecb709\n\n### 2.14.2 Oct 13 2020\n\n  - Bugfix: fix gcc 8 function cast warning (#899) 35f0fab205574b2cbda04e6347c8b2db755e124f\n\n### 2.14.1 Apr 21 2020\n\n  - Bugfix: use GetBackingStore() instead of GetContents() (#888) 2c023bd447661a61071da318b0ff4003c3858d39\n\n### 2.14.0 May 16 2019\n\n  - Feature: Add missing methods to Nan::Maybe<T> (#852) 4e962489fb84a184035b9fa74f245f650249aca6\n\n### 2.13.2 Mar 24 2019\n\n  - Bugfix: remove usage of deprecated `IsNearDeath` (#842) fbaf42252af279c3d867c6b193571f9711c39847\n\n### 2.13.1 Mar 14 2019\n\n  - Bugfix: check V8 version directly instead of inferring from NMV (#840) 12f9df9f393285de8fb4a8cd01478dc4fe3b089d\n\n### 2.13.0 Mar 13 2019\n\n  - Feature: add support for node master (#831) 113c0282072e7ff4f9dfc98b432fd894b798c2c\n\n### 2.12.1 Dec 18 2018\n\n  - Bugfix: Fix build breakage with Node.js 10.0.0-10.9.0. (#833) 625e90e8fef8d39ffa7247250a76a100b2487474\n\n### 2.12.0 Dec 16 2018\n\n  - Bugfix: Add scope.Escape() to Call() (#817) 2e5ed4fc3a8ac80a6ef1f2a55099ab3ac8800dc6\n  - Bugfix: Fix Node.js v10.12.0 deprecation warnings. 509859cc23b1770376b56550a027840a2ce0f73d\n  - Feature: Allow SetWeak() for non-object persistent handles. (#824) e6ef6a48e7e671fe3e4b7dddaa8912a3f8262ecd\n\n### 2.11.1 Sep 29 2018\n\n  - Fix: adapt to V8 7.0 24a22c3b25eeeec2016c6ec239bdd6169e985447\n\n### 2.11.0 Aug 25 2018\n\n  - Removal: remove `FunctionCallbackInfo::Callee` for nodejs `>= 10` 1a56c0a6efd4fac944cb46c30912a8e023bda7d4\n  - Bugfix: Fix `AsyncProgressWorkerBase::WorkProgress` sends invalid data b0c764d1dab11e9f8b37ffb81e2560a4498aad5e\n  - Feature: Introduce `GetCurrentEventLoop` b4911b0bb1f6d47d860e10ec014d941c51efac5e\n  - Feature: Add `NAN_MODULE_WORKER_ENABLED` macro as a replacement for `NAN_MODULE` b058fb047d18a58250e66ae831444441c1f2ac7a\n\n### 2.10.0 Mar 16 2018\n\n  - Deprecation: Deprecate `MakeCallback` 5e92b19a59e194241d6a658bd6ff7bfbda372950\n  - Feature: add `Nan::Call` overload 4482e1242fe124d166fc1a5b2be3c1cc849fe452\n  - Feature: add more `Nan::Call` overloads 8584e63e6d04c7d2eb8c4a664e4ef57d70bf672b\n  - Feature: Fix deprecation warnings for Node 10 1caf258243b0602ed56922bde74f1c91b0cbcb6a\n\n### 2.9.2 Feb 22 2018\n\n  - Bugfix: Bandaid for async hooks 212bd2f849be14ef1b02fc85010b053daa24252b\n\n### 2.9.1 Feb 22 2018\n\n  - Bugfix: Avoid deprecation warnings in deprecated `Nan::Callback::operator()` 372b14d91289df4604b0f81780709708c45a9aa4\n  - Bugfix: Avoid deprecation warnings in `Nan::JSON` 3bc294bce0b7d0a3ee4559926303e5ed4866fda2\n\n### 2.9.0 Feb 22 2018\n\n  - Deprecation: Deprecate legacy `Callback::Call` 6dd5fa690af61ca3523004b433304c581b3ea309\n  - Feature: introduce `AsyncResource` class 90c0a179c0d8cb5fd26f1a7d2b1d6231eb402d48o\n  - Feature: Add context aware `Nan::Callback::Call` functions 7169e09fb088418b6e388222e88b4c13f07ebaee\n  - Feature: Make `AsyncWorker` context aware 066ba21a6fb9e2b5230c9ed3a6fc51f1211736a4\n  - Feature: add `Callback` overload to `Nan::Call` 5328daf66e202658c1dc0d916c3aaba99b3cc606\n  - Bugfix: fix warning: suggest parentheses around `&&` within `||` b2bb63d68b8ae623a526b542764e1ac82319cb2c\n  - Bugfix: Fix compilation on io.js 3 d06114dba0a522fb436f0c5f47b994210968cd7b\n\n### 2.8.0 Nov 15 2017\n\n  - Deprecation: Deprecate `Nan::ForceSet` in favor of `Nan::DefineOwnProperty()` 95cbb976d6fbbba88ba0f86dd188223a8591b4e7\n  - Feature: Add `Nan::AsyncProgressQueueWorker` a976636ecc2ef617d1b061ce4a6edf39923691cb\n  - Feature: Add `Nan::DefineOwnProperty()` 95cbb976d6fbbba88ba0f86dd188223a8591b4e7\n  - Bugfix: Fix compiling on io.js 1 & 2 82705a64503ce60c62e98df5bd02972bba090900\n  - Bugfix: Use DefineOwnProperty instead of ForceSet 95cbb976d6fbbba88ba0f86dd188223a8591b4e7\n\n### 2.7.0 Aug 30 2017\n\n  - Feature: Add `Nan::To<v8::Function>()` overload. b93280670c9f6da42ed4cf6cbf085ffdd87bd65b\n  - Bugfix: Fix ternary in `Nan::MaybeLocal<T>::FromMaybe<S>()`. 79a26f7d362e756a9524e672a82c3d603b542867\n\n### 2.6.2 Apr 12 2017\n\n  - Bugfix: Fix v8::JSON::Parse() deprecation warning. 87f6a3c65815fa062296a994cc863e2fa124867d\n\n### 2.6.1 Apr 6 2017\n\n  - Bugfix: nan_json.h: fix build breakage in Node 6 ac8d47dc3c10bfbf3f15a6b951633120c0ee6d51\n\n### 2.6.0 Apr 6 2017\n\n  - Feature: nan: add support for JSON::Parse & Stringify b533226c629cce70e1932a873bb6f849044a56c5\n\n### 2.5.1 Jan 23 2017\n\n  - Bugfix: Fix disappearing handle for private value 6a80995694f162ef63dbc9948fbefd45d4485aa0\n  - Bugfix: Add missing scopes a93b8bae6bc7d32a170db6e89228b7f60ee57112\n  - Bugfix: Use string::data instead of string::front in NewOneByteString d5f920371e67e1f3b268295daee6e83af86b6e50\n\n### 2.5.0 Dec 21 2016\n\n  - Feature: Support Private accessors a86255cb357e8ad8ccbf1f6a4a901c921e39a178\n  - Bugfix: Abort in delete operators that shouldn't be called 0fe38215ff8581703967dfd26c12793feb960018\n\n### 2.4.0 Jul 10 2016\n\n  - Feature: Rewrite Callback to add Callback::Reset c4cf44d61f8275cd5f7b0c911d7a806d4004f649\n  - Feature: AsyncProgressWorker: add template types for .send 1242c9a11a7ed481c8f08ec06316385cacc513d0\n  - Bugfix: Add constness to old Persistent comparison operators bd43cb9982c7639605d60fd073efe8cae165d9b2\n\n### 2.3.5 May 31 2016\n\n  - Bugfix: Replace NAN_INLINE with 'inline' keyword. 71819d8725f822990f439479c9aba3b240804909\n\n### 2.3.4 May 31 2016\n\n  - Bugfix: Remove V8 deprecation warnings 0592fb0a47f3a1c7763087ebea8e1138829f24f9\n  - Bugfix: Fix new versions not to use WeakCallbackInfo::IsFirstPass 615c19d9e03d4be2049c10db0151edbc3b229246\n  - Bugfix: Make ObjectWrap::handle() const d19af99595587fe7a26bd850af6595c2a7145afc\n  - Bugfix: Fix compilation errors related to 0592fb0a47f3a1c7763087ebea8e1138829f24f9 e9191c525b94f652718325e28610a1adcf90fed8\n\n### 2.3.3 May 4 2016\n\n  - Bugfix: Refactor SetMethod() to deal with v8::Templates (#566) b9083cf6d5de6ebe6bcb49c7502fbb7c0d9ddda8\n\n### 2.3.2 Apr 27 2016\n\n  - Bugfix: Fix compilation on outdated versions due to Handle removal f8b7c875d04d425a41dfd4f3f8345bc3a11e6c52\n\n### 2.3.1 Apr 27 2016\n\n  - Bugfix: Don't use deprecated v8::Template::Set() in SetMethod a90951e9ea70fa1b3836af4b925322919159100e\n\n### 2.3.0 Apr 27 2016\n\n  - Feature: added Signal() for invoking async callbacks without sending data from AsyncProgressWorker d8adba45f20e077d00561b20199133620c990b38\n  - Bugfix: Don't use deprecated v8::Template::Set() 00dacf0a4b86027415867fa7f1059acc499dcece\n\n### 2.2.1 Mar 29 2016\n\n  - Bugfix: Use NewFromUnsigned in ReturnValue<T>::Set(uint32_t i) for pre_12 3a18f9bdce29826e0e4c217854bc476918241a58\n  - Performance: Remove unneeeded nullptr checks b715ef44887931c94f0d1605b3b1a4156eebece9\n\n### 2.2.0 Jan 9 2016\n\n  - Feature: Add Function::Call wrapper 4c157474dacf284d125c324177b45aa5dabc08c6\n  - Feature: Rename GC*logueCallback to GCCallback for > 4.0 3603435109f981606d300eb88004ca101283acec\n  - Bugfix: Fix Global::Pass for old versions 367e82a60fbaa52716232cc89db1cc3f685d77d9\n  - Bugfix: Remove weird MaybeLocal wrapping of what already is a MaybeLocal 23b4590db10c2ba66aee2338aebe9751c4cb190b\n\n### 2.1.0 Oct 8 2015\n\n  - Deprecation: Deprecate NanErrnoException in favor of ErrnoException 0af1ca4cf8b3f0f65ed31bc63a663ab3319da55c\n  - Feature: added helper class for accessing contents of typedarrays 17b51294c801e534479d5463697a73462d0ca555\n  - Feature: [Maybe types] Add MakeMaybe(...) 48d7b53d9702b0c7a060e69ea10fea8fb48d814d\n  - Feature: new: allow utf16 string with length 66ac6e65c8ab9394ef588adfc59131b3b9d8347b\n  - Feature: Introduce SetCallHandler and SetCallAsFunctionHandler 7764a9a115d60ba10dc24d86feb0fbc9b4f75537\n  - Bugfix: Enable creating Locals from Globals under Node 0.10. 9bf9b8b190821af889790fdc18ace57257e4f9ff\n  - Bugfix: Fix issue #462 where PropertyCallbackInfo data is not stored safely. 55f50adedd543098526c7b9f4fffd607d3f9861f\n\n### 2.0.9 Sep 8 2015\n\n  - Bugfix: EscapableHandleScope in Nan::NewBuffer for Node 0.8 and 0.10 b1654d7\n\n### 2.0.8 Aug 28 2015\n\n  - Work around duplicate linking bug in clang 11902da\n\n### 2.0.7 Aug 26 2015\n\n  - Build: Repackage\n\n### 2.0.6 Aug 26 2015\n\n  - Bugfix: Properly handle null callback in FunctionTemplate factory 6e99cb1\n  - Bugfix: Remove unused static std::map instances 525bddc\n  - Bugfix: Make better use of maybe versions of APIs bfba85b\n  - Bugfix: Fix shadowing issues with handle in ObjectWrap 0a9072d\n\n### 2.0.5 Aug 10 2015\n\n  - Bugfix: Reimplement weak callback in ObjectWrap 98d38c1\n  - Bugfix: Make sure callback classes are not assignable, copyable or movable 81f9b1d\n\n### 2.0.4 Aug 6 2015\n\n  - Build: Repackage\n\n### 2.0.3 Aug 6 2015\n\n  - Bugfix: Don't use clang++ / g++ syntax extension. 231450e\n\n### 2.0.2 Aug 6 2015\n\n  - Build: Repackage\n\n### 2.0.1 Aug 6 2015\n\n  - Bugfix: Add workaround for missing REPLACE_INVALID_UTF8 60d6687\n  - Bugfix: Reimplement ObjectWrap from scratch to prevent memory leaks 6484601\n  - Bugfix: Fix Persistent leak in FunctionCallbackInfo and PropertyCallbackInfo 641ef5f\n  - Bugfix: Add missing overload for Nan::NewInstance that takes argc/argv 29450ed\n\n### 2.0.0 Jul 31 2015\n\n  - Change: Renamed identifiers with leading underscores\tb5932b4\n  - Change: Replaced NanObjectWrapHandle with class NanObjectWrap\t464f1e1\n  - Change: Replace NanScope and NanEscpableScope macros with classes\t47751c4\n  - Change: Rename NanNewBufferHandle to NanNewBuffer\t6745f99\n  - Change: Rename NanBufferUse to NanNewBuffer\t3e8b0a5\n  - Change: Rename NanNewBuffer to NanCopyBuffer\td6af78d\n  - Change: Remove Nan prefix from all names\t72d1f67\n  - Change: Update Buffer API for new upstream changes\td5d3291\n  - Change: Rename Scope and EscapableScope to HandleScope and EscapableHandleScope\t21a7a6a\n  - Change: Get rid of Handles\t e6c0daf\n  - Feature: Support io.js 3 with V8 4.4\n  - Feature: Introduce NanPersistent\t7fed696\n  - Feature: Introduce NanGlobal\t4408da1\n  - Feature: Added NanTryCatch\t10f1ca4\n  - Feature: Update for V8 v4.3\t4b6404a\n  - Feature: Introduce NanNewOneByteString\tc543d32\n  - Feature: Introduce namespace Nan\t67ed1b1\n  - Removal: Remove NanLocker and NanUnlocker\tdd6e401\n  - Removal: Remove string converters, except NanUtf8String, which now follows the node implementation b5d00a9\n  - Removal: Remove NanReturn* macros\td90a25c\n  - Removal: Remove HasInstance\te8f84fe\n\n\n### 1.9.0 Jul 31 2015\n\n  - Feature: Added `NanFatalException` 81d4a2c\n  - Feature: Added more error types 4265f06\n  - Feature: Added dereference and function call operators to NanCallback c4b2ed0\n  - Feature: Added indexed GetFromPersistent and SaveToPersistent edd510c\n  - Feature: Added more overloads of SaveToPersistent and GetFromPersistent 8b1cef6\n  - Feature: Added NanErrnoException dd87d9e\n  - Correctness: Prevent assign, copy, and move for classes that do not support it 1f55c59, 4b808cb, c96d9b2, fba4a29, 3357130\n  - Deprecation: Deprecate `NanGetPointerSafe` and `NanSetPointerSafe` 81d4a2c\n  - Deprecation: Deprecate `NanBooleanOptionValue` and `NanUInt32OptionValue` 0ad254b\n\n### 1.8.4 Apr 26 2015\n\n  - Build: Repackage\n\n### 1.8.3 Apr 26 2015\n\n  - Bugfix: Include missing header 1af8648\n\n### 1.8.2 Apr 23 2015\n\n  - Build: Repackage\n\n### 1.8.1 Apr 23 2015\n\n  - Bugfix: NanObjectWrapHandle should take a pointer 155f1d3\n\n### 1.8.0 Apr 23 2015\n\n  - Feature: Allow primitives with NanReturnValue 2e4475e\n  - Feature: Added comparison operators to NanCallback 55b075e\n  - Feature: Backport thread local storage 15bb7fa\n  - Removal: Remove support for signatures with arguments 8a2069d\n  - Correcteness: Replaced NanObjectWrapHandle macro with function 0bc6d59\n\n### 1.7.0 Feb 28 2015\n\n  - Feature: Made NanCallback::Call accept optional target 8d54da7\n  - Feature: Support atom-shell 0.21 0b7f1bb\n\n### 1.6.2 Feb 6 2015\n\n  - Bugfix: NanEncode: fix argument type for node::Encode on io.js 2be8639\n\n### 1.6.1 Jan 23 2015\n\n  - Build: version bump\n\n### 1.5.3 Jan 23 2015\n\n  - Build: repackage\n\n### 1.6.0 Jan 23 2015\n\n - Deprecated `NanNewContextHandle` in favor of `NanNew<Context>` 49259af\n - Support utility functions moved in newer v8 versions (Node 0.11.15, io.js 1.0) a0aa179\n - Added `NanEncode`, `NanDecodeBytes` and `NanDecodeWrite` 75e6fb9\n\n### 1.5.2 Jan 23 2015\n\n  - Bugfix: Fix non-inline definition build error with clang++ 21d96a1, 60fadd4\n  - Bugfix: Readded missing String constructors 18d828f\n  - Bugfix: Add overload handling NanNew<FunctionTemplate>(..) 5ef813b\n  - Bugfix: Fix uv_work_cb versioning 997e4ae\n  - Bugfix: Add function factory and test 4eca89c\n  - Bugfix: Add object template factory and test cdcb951\n  - Correctness: Lifted an io.js related typedef c9490be\n  - Correctness: Make explicit downcasts of String lengths 00074e6\n  - Windows: Limit the scope of disabled warning C4530 83d7deb\n\n### 1.5.1 Jan 15 2015\n\n  - Build: version bump\n\n### 1.4.3 Jan 15 2015\n\n  - Build: version bump\n\n### 1.4.2 Jan 15 2015\n\n  - Feature: Support io.js 0dbc5e8\n\n### 1.5.0 Jan 14 2015\n\n - Feature: Support io.js b003843\n - Correctness: Improved NanNew internals 9cd4f6a\n - Feature: Implement progress to NanAsyncWorker 8d6a160\n\n### 1.4.1 Nov 8 2014\n\n - Bugfix: Handle DEBUG definition correctly\n - Bugfix: Accept int as Boolean\n\n### 1.4.0 Nov 1 2014\n\n - Feature: Added NAN_GC_CALLBACK 6a5c245\n - Performance: Removed unnecessary local handle creation 18a7243, 41fe2f8\n - Correctness: Added constness to references in NanHasInstance 02c61cd\n - Warnings: Fixed spurious warnings from -Wundef and -Wshadow, 541b122, 99d8cb6\n - Windoze: Shut Visual Studio up when compiling 8d558c1\n - License: Switch to plain MIT from custom hacked MIT license 11de983\n - Build: Added test target to Makefile e232e46\n - Performance: Removed superfluous scope in NanAsyncWorker f4b7821\n - Sugar/Feature: Added NanReturnThis() and NanReturnHolder() shorthands 237a5ff, d697208\n - Feature: Added suitable overload of NanNew for v8::Integer::NewFromUnsigned b27b450\n\n### 1.3.0 Aug 2 2014\n\n - Added NanNew<v8::String, std::string>(std::string)\n - Added NanNew<v8::String, std::string&>(std::string&)\n - Added NanAsciiString helper class\n - Added NanUtf8String helper class\n - Added NanUcs2String helper class\n - Deprecated NanRawString()\n - Deprecated NanCString()\n - Added NanGetIsolateData(v8::Isolate *isolate)\n - Added NanMakeCallback(v8::Handle<v8::Object> target, v8::Handle<v8::Function> func, int argc, v8::Handle<v8::Value>* argv)\n - Added NanMakeCallback(v8::Handle<v8::Object> target, v8::Handle<v8::String> symbol, int argc, v8::Handle<v8::Value>* argv)\n - Added NanMakeCallback(v8::Handle<v8::Object> target, const char* method, int argc, v8::Handle<v8::Value>* argv)\n - Added NanSetTemplate(v8::Handle<v8::Template> templ, v8::Handle<v8::String> name , v8::Handle<v8::Data> value, v8::PropertyAttribute attributes)\n - Added NanSetPrototypeTemplate(v8::Local<v8::FunctionTemplate> templ, v8::Handle<v8::String> name, v8::Handle<v8::Data> value, v8::PropertyAttribute attributes)\n - Added NanSetInstanceTemplate(v8::Local<v8::FunctionTemplate> templ, const char *name, v8::Handle<v8::Data> value)\n - Added NanSetInstanceTemplate(v8::Local<v8::FunctionTemplate> templ, v8::Handle<v8::String> name, v8::Handle<v8::Data> value, v8::PropertyAttribute attributes)\n\n### 1.2.0 Jun 5 2014\n\n - Add NanSetPrototypeTemplate\n - Changed NAN_WEAK_CALLBACK internals, switched _NanWeakCallbackData to class,\n     introduced _NanWeakCallbackDispatcher\n - Removed -Wno-unused-local-typedefs from test builds\n - Made test builds Windows compatible ('Sleep()')\n\n### 1.1.2 May 28 2014\n\n - Release to fix more stuff-ups in 1.1.1\n\n### 1.1.1 May 28 2014\n\n - Release to fix version mismatch in nan.h and lack of changelog entry for 1.1.0\n\n### 1.1.0 May 25 2014\n\n - Remove nan_isolate, use v8::Isolate::GetCurrent() internally instead\n - Additional explicit overloads for NanNew(): (char*,int), (uint8_t*[,int]),\n     (uint16_t*[,int), double, int, unsigned int, bool, v8::String::ExternalStringResource*,\n     v8::String::ExternalAsciiStringResource*\n - Deprecate NanSymbol()\n - Added SetErrorMessage() and ErrorMessage() to NanAsyncWorker\n\n### 1.0.0 May 4 2014\n\n - Heavy API changes for V8 3.25 / Node 0.11.13\n - Use cpplint.py\n - Removed NanInitPersistent\n - Removed NanPersistentToLocal\n - Removed NanFromV8String\n - Removed NanMakeWeak\n - Removed NanNewLocal\n - Removed NAN_WEAK_CALLBACK_OBJECT\n - Removed NAN_WEAK_CALLBACK_DATA\n - Introduce NanNew, replaces NanNewLocal, NanPersistentToLocal, adds many overloaded typed versions\n - Introduce NanUndefined, NanNull, NanTrue and NanFalse\n - Introduce NanEscapableScope and NanEscapeScope\n - Introduce NanMakeWeakPersistent (requires a special callback to work on both old and new node)\n - Introduce NanMakeCallback for node::MakeCallback\n - Introduce NanSetTemplate\n - Introduce NanGetCurrentContext\n - Introduce NanCompileScript and NanRunScript\n - Introduce NanAdjustExternalMemory\n - Introduce NanAddGCEpilogueCallback, NanAddGCPrologueCallback, NanRemoveGCEpilogueCallback, NanRemoveGCPrologueCallback\n - Introduce NanGetHeapStatistics\n - Rename NanAsyncWorker#SavePersistent() to SaveToPersistent()\n\n### 0.8.0 Jan 9 2014\n\n - NanDispose -> NanDisposePersistent, deprecate NanDispose\n - Extract _NAN_*_RETURN_TYPE, pull up NAN_*()\n\n### 0.7.1 Jan 9 2014\n\n - Fixes to work against debug builds of Node\n - Safer NanPersistentToLocal (avoid reinterpret_cast)\n - Speed up common NanRawString case by only extracting flattened string when necessary\n\n### 0.7.0 Dec 17 2013\n\n - New no-arg form of NanCallback() constructor.\n - NanCallback#Call takes Handle rather than Local\n - Removed deprecated NanCallback#Run method, use NanCallback#Call instead\n - Split off _NAN_*_ARGS_TYPE from _NAN_*_ARGS\n - Restore (unofficial) Node 0.6 compatibility at NanCallback#Call()\n - Introduce NanRawString() for char* (or appropriate void*) from v8::String\n     (replacement for NanFromV8String)\n - Introduce NanCString() for null-terminated char* from v8::String\n\n### 0.6.0 Nov 21 2013\n\n - Introduce NanNewLocal<T>(v8::Handle<T> value) for use in place of\n     v8::Local<T>::New(...) since v8 started requiring isolate in Node 0.11.9\n\n### 0.5.2 Nov 16 2013\n\n - Convert SavePersistent and GetFromPersistent in NanAsyncWorker from protected and public\n\n### 0.5.1 Nov 12 2013\n\n - Use node::MakeCallback() instead of direct v8::Function::Call()\n\n### 0.5.0 Nov 11 2013\n\n - Added @TooTallNate as collaborator\n - New, much simpler, \"include_dirs\" for binding.gyp\n - Added full range of NAN_INDEX_* macros to match NAN_PROPERTY_* macros\n\n### 0.4.4 Nov 2 2013\n\n - Isolate argument from v8::Persistent::MakeWeak removed for 0.11.8+\n\n### 0.4.3 Nov 2 2013\n\n - Include node_object_wrap.h, removed from node.h for Node 0.11.8.\n\n### 0.4.2 Nov 2 2013\n\n - Handle deprecation of v8::Persistent::Dispose(v8::Isolate* isolate)) for\n     Node 0.11.8 release.\n\n### 0.4.1 Sep 16 2013\n\n - Added explicit `#include <uv.h>` as it was removed from node.h for v0.11.8\n\n### 0.4.0 Sep 2 2013\n\n - Added NAN_INLINE and NAN_DEPRECATED and made use of them\n - Added NanError, NanTypeError and NanRangeError\n - Cleaned up code\n\n### 0.3.2 Aug 30 2013\n\n - Fix missing scope declaration in GetFromPersistent() and SaveToPersistent\n     in NanAsyncWorker\n\n### 0.3.1 Aug 20 2013\n\n - fix \"not all control paths return a value\" compile warning on some platforms\n\n### 0.3.0 Aug 19 2013\n\n - Made NAN work with NPM\n - Lots of fixes to NanFromV8String, pulling in features from new Node core\n - Changed node::encoding to Nan::Encoding in NanFromV8String to unify the API\n - Added optional error number argument for NanThrowError()\n - Added NanInitPersistent()\n - Added NanReturnNull() and NanReturnEmptyString()\n - Added NanLocker and NanUnlocker\n - Added missing scopes\n - Made sure to clear disposed Persistent handles\n - Changed NanAsyncWorker to allocate error messages on the heap\n - Changed NanThrowError(Local<Value>) to NanThrowError(Handle<Value>)\n - Fixed leak in NanAsyncWorker when errmsg is used\n\n### 0.2.2 Aug 5 2013\n\n - Fixed usage of undefined variable with node::BASE64 in NanFromV8String()\n\n### 0.2.1 Aug 5 2013\n\n - Fixed 0.8 breakage, node::BUFFER encoding type not available in 0.8 for\n     NanFromV8String()\n\n### 0.2.0 Aug 5 2013\n\n - Added NAN_PROPERTY_GETTER, NAN_PROPERTY_SETTER, NAN_PROPERTY_ENUMERATOR,\n     NAN_PROPERTY_DELETER, NAN_PROPERTY_QUERY\n - Extracted _NAN_METHOD_ARGS, _NAN_GETTER_ARGS, _NAN_SETTER_ARGS,\n     _NAN_PROPERTY_GETTER_ARGS, _NAN_PROPERTY_SETTER_ARGS,\n     _NAN_PROPERTY_ENUMERATOR_ARGS, _NAN_PROPERTY_DELETER_ARGS,\n     _NAN_PROPERTY_QUERY_ARGS\n - Added NanGetInternalFieldPointer, NanSetInternalFieldPointer\n - Added NAN_WEAK_CALLBACK, NAN_WEAK_CALLBACK_OBJECT,\n     NAN_WEAK_CALLBACK_DATA, NanMakeWeak\n - Renamed THROW_ERROR to _NAN_THROW_ERROR\n - Added NanNewBufferHandle(char*, size_t, node::smalloc::FreeCallback, void*)\n - Added NanBufferUse(char*, uint32_t)\n - Added NanNewContextHandle(v8::ExtensionConfiguration*,\n       v8::Handle<v8::ObjectTemplate>, v8::Handle<v8::Value>)\n - Fixed broken NanCallback#GetFunction()\n - Added optional encoding and size arguments to NanFromV8String()\n - Added NanGetPointerSafe() and NanSetPointerSafe()\n - Added initial test suite (to be expanded)\n - Allow NanUInt32OptionValue to convert any Number object\n\n### 0.1.0 Jul 21 2013\n\n - Added `NAN_GETTER`, `NAN_SETTER`\n - Added `NanThrowError` with single Local<Value> argument\n - Added `NanNewBufferHandle` with single uint32_t argument\n - Added `NanHasInstance(Persistent<FunctionTemplate>&, Handle<Value>)`\n - Added `Local<Function> NanCallback#GetFunction()`\n - Added `NanCallback#Call(int, Local<Value>[])`\n - Deprecated `NanCallback#Run(int, Local<Value>[])` in favour of Call\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 4.1396484375,
          "content": "cmake_minimum_required(VERSION 3.5)\nproject(nan)\n\nset(CMAKE_CXX_STANDARD 11)\n\nset(CPPLINT \"${CMAKE_CURRENT_SOURCE_DIR}/cpplint.py\")\nset(MODULES symbols strings)\nset(SOURCES \"\")\nset(ADDONS \"\")\n\nforeach(MODULE ${MODULES})\n    list(APPEND SOURCES \"test/cpp/${MODULE}.cpp\")\n    list(APPEND ADDONS \"test/build/${CMAKE_BUILD_TYPE}/${MODULE}.node\")\nendforeach()\n\nset(LINT_SOURCES examples/async_pi_estimate/addon.cc\n\texamples/async_pi_estimate/async.cc \n\texamples/async_pi_estimate/async.h \n\texamples/async_pi_estimate/pi_est.cc \n\texamples/async_pi_estimate/pi_est.h \n\texamples/async_pi_estimate/sync.cc \n\texamples/async_pi_estimate/sync.h \n\tnan.h \n\tnan_callbacks.h \n\tnan_callbacks_12_inl.h \n\tnan_callbacks_pre_12_inl.h \n\tnan_converters.h \n\tnan_converters_43_inl.h \n\tnan_converters_pre_43_inl.h \n\tnan_define_own_property_helper.h \n\tnan_implementation_12_inl.h \n\tnan_implementation_pre_12_inl.h \n\tnan_json.h \n\tnan_maybe_43_inl.h \n\tnan_maybe_pre_43_inl.h \n\tnan_new.h \n\tnan_object_wrap.h \n\tnan_persistent_12_inl.h \n\tnan_persistent_pre_12_inl.h \n\tnan_private.h \n\tnan_scriptorigin.h \n\tnan_string_bytes.h \n\tnan_weak.h \n\ttest/cpp/accessors.cpp \n\ttest/cpp/accessors2.cpp \n\ttest/cpp/asyncresource.cpp \n\ttest/cpp/asyncworker.cpp \n\ttest/cpp/asyncprogressworker.cpp \n\ttest/cpp/asyncprogressworkerstream.cpp \n\ttest/cpp/asyncprogressworkersignal.cpp \n\ttest/cpp/asyncprogressqueueworker.cpp \n\ttest/cpp/asyncprogressqueueworkerstream.cpp \n\ttest/cpp/asyncworkererror.cpp \n\ttest/cpp/buffer.cpp \n\ttest/cpp/bufferworkerpersistent.cpp \n\ttest/cpp/error.cpp \n\ttest/cpp/gc.cpp \n\ttest/cpp/indexedinterceptors.cpp \n\ttest/cpp/callbackcontext.cpp \n\ttest/cpp/converters.cpp \n\ttest/cpp/isolatedata.cpp \n\ttest/cpp/json-parse.cpp \n\ttest/cpp/json-stringify.cpp \n\ttest/cpp/makecallback.cpp \n\ttest/cpp/maybe.cpp \n\ttest/cpp/morenews.cpp \n\ttest/cpp/multifile1.cpp \n\ttest/cpp/multifile2.cpp \n\ttest/cpp/multifile2.h \n\ttest/cpp/namedinterceptors.cpp \n\ttest/cpp/nancallback.cpp \n\ttest/cpp/nannew.cpp \n\ttest/cpp/news.cpp \n\ttest/cpp/objectwraphandle.cpp \n\ttest/cpp/persistent.cpp \n\ttest/cpp/private.cpp \n\ttest/cpp/returnemptystring.cpp \n\ttest/cpp/returnnull.cpp \n\ttest/cpp/returnundefined.cpp \n\ttest/cpp/returnvalue.cpp \n\ttest/cpp/setcallhandler.cpp \n\ttest/cpp/settemplate.cpp \n\ttest/cpp/sleep.h \n\ttest/cpp/strings.cpp \n\ttest/cpp/symbols.cpp \n\ttest/cpp/threadlocal.cpp \n\ttest/cpp/trycatch.cpp \n\ttest/cpp/typedarrays.cpp \n\ttest/cpp/weak.cpp \n\ttest/cpp/weak2.cpp\n    test/cpp/wrappedobjectfactory.cpp\n    node_modules/node-gyp/gyp/data/win/large-pdb-shim.cc)\n        \nset(FILTER \"-build/include_subdir,-whitespace/parens\")\n\nfind_package(Python COMPONENTS Interpreter Development REQUIRED)\n\nexecute_process(\n        COMMAND npm install\n        OUTPUT_FILE node_modules\n        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n)\n\nadd_custom_target(lint\n    COMMAND ${Python_EXECUTABLE} ${CPPLINT} --filter=${FILTER} ${LINT_SOURCES}\n    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n)\n\nadd_custom_target(test\n    DEPENDS ${ADDONS}\n    COMMAND npm test\n)\n\nadd_custom_target(forcetest\n    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/test\n    COMMAND ../node_modules/.bin/node-gyp rebuild\n    COMMAND npm test\n)\n\nadd_custom_target(docs\n    DEPENDS README.md doc/.build.sh doc/asyncworker.md doc/buffers.md doc/callback.md\n            doc/converters.md doc/errors.md doc/maybe_types.md doc/methods.md doc/new.md\n            doc/node_misc.md doc/persistent.md doc/scopes.md doc/script.md doc/string_bytes.md\n            doc/v8_internals.md doc/json.md doc/v8_misc.md\n    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n    COMMAND doc/.build.sh\n)\n\nadd_custom_command(OUTPUT ${ADDONS}\n    DEPENDS ${SOURCES} nan.h nan_new.h nan_implementation_pre_12_inl.h nan_implementation_12_inl.h\n            nan_callbacks.h nan_callbacks_12_inl.h nan_callbacks_pre_12_inl.h nan_converters.h\n            nan_converters_43_inl.h nan_converters_pre_43_inl.h nan_define_own_property_helper.h\n            nan_json.h nan_maybe_43_inl.h nan_maybe_pre_43_inl.h nan_persistent_12_inl.h\n            nan_persistent_pre_12_inl.h nan_private.h nan_weak.h nan_scriptorigin.h nan_string_bytes.h\n            test/binding.gyp\n    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/test\n    COMMAND ../node_modules/.bin/node-gyp rebuild\n)"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.1171875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2018 [NAN contributors](<https://github.com/nodejs/nan#wg-members--collaborators>)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.48046875,
          "content": "TOPLEVEL ?= $(dir $(lastword $(MAKEFILE_LIST)))\nCPPLINT ?= $(TOPLEVEL)/cpplint.py\nPYTHON ?= python\nBUILDTYPE ?= Release\nMODULES = symbols strings\nSOURCES = $(MODULES:%=test/cpp/%.cpp)\nADDONS = $(MODULES:%=test/build/$(BUILDTYPE)/%.node)\n\nLINT_SOURCES = \\\n\texamples/async_pi_estimate/addon.cc \\\n\texamples/async_pi_estimate/async.cc \\\n\texamples/async_pi_estimate/async.h \\\n\texamples/async_pi_estimate/pi_est.cc \\\n\texamples/async_pi_estimate/pi_est.h \\\n\texamples/async_pi_estimate/sync.cc \\\n\texamples/async_pi_estimate/sync.h \\\n\tnan.h \\\n\tnan_callbacks.h \\\n\tnan_callbacks_12_inl.h \\\n\tnan_callbacks_pre_12_inl.h \\\n\tnan_converters.h \\\n\tnan_converters_43_inl.h \\\n\tnan_converters_pre_43_inl.h \\\n\tnan_define_own_property_helper.h \\\n\tnan_implementation_12_inl.h \\\n\tnan_implementation_pre_12_inl.h \\\n\tnan_json.h \\\n\tnan_maybe_43_inl.h \\\n\tnan_maybe_pre_43_inl.h \\\n\tnan_new.h \\\n\tnan_object_wrap.h \\\n\tnan_persistent_12_inl.h \\\n\tnan_persistent_pre_12_inl.h \\\n\tnan_private.h \\\n\tnan_scriptorigin.h \\\n\tnan_string_bytes.h \\\n\tnan_weak.h \\\n\ttest/cpp/accessors.cpp \\\n\ttest/cpp/accessors2.cpp \\\n\ttest/cpp/asyncresource.cpp \\\n\ttest/cpp/asyncworker.cpp \\\n\ttest/cpp/asyncprogressworker.cpp \\\n\ttest/cpp/asyncprogressworkerstream.cpp \\\n\ttest/cpp/asyncprogressworkersignal.cpp \\\n\ttest/cpp/asyncprogressqueueworker.cpp \\\n\ttest/cpp/asyncprogressqueueworkerstream.cpp \\\n\ttest/cpp/asyncworkererror.cpp \\\n\ttest/cpp/buffer.cpp \\\n\ttest/cpp/bufferworkerpersistent.cpp \\\n\ttest/cpp/error.cpp \\\n\ttest/cpp/gc.cpp \\\n\ttest/cpp/indexedinterceptors.cpp \\\n\ttest/cpp/callbackcontext.cpp \\\n\ttest/cpp/converters.cpp \\\n\ttest/cpp/isolatedata.cpp \\\n\ttest/cpp/json-parse.cpp \\\n\ttest/cpp/json-stringify.cpp \\\n\ttest/cpp/makecallback.cpp \\\n\ttest/cpp/maybe.cpp \\\n\ttest/cpp/morenews.cpp \\\n\ttest/cpp/multifile1.cpp \\\n\ttest/cpp/multifile2.cpp \\\n\ttest/cpp/multifile2.h \\\n\ttest/cpp/namedinterceptors.cpp \\\n\ttest/cpp/nancallback.cpp \\\n\ttest/cpp/nannew.cpp \\\n\ttest/cpp/news.cpp \\\n\ttest/cpp/objectwraphandle.cpp \\\n\ttest/cpp/persistent.cpp \\\n\ttest/cpp/private.cpp \\\n\ttest/cpp/returnemptystring.cpp \\\n\ttest/cpp/returnnull.cpp \\\n\ttest/cpp/returnundefined.cpp \\\n\ttest/cpp/returnvalue.cpp \\\n\ttest/cpp/setcallhandler.cpp \\\n\ttest/cpp/settemplate.cpp \\\n\ttest/cpp/sleep.h \\\n\ttest/cpp/strings.cpp \\\n\ttest/cpp/symbols.cpp \\\n\ttest/cpp/threadlocal.cpp \\\n\ttest/cpp/trycatch.cpp \\\n\ttest/cpp/typedarrays.cpp \\\n\ttest/cpp/weak.cpp \\\n\ttest/cpp/weak2.cpp \\\n\ttest/cpp/wrappedobjectfactory.cpp \\\n\tnode_modules/node-gyp/gyp/data/win/large-pdb-shim.cc\n\nFILTER = -build/include_subdir,-whitespace/parens\n\n.PHONY: lint\n\nlint:\n\tcd $(TOPLEVEL) && $(PYTHON) $(CPPLINT) --filter=$(FILTER) $(LINT_SOURCES)\n\ntest: $(ADDONS)\n\tnpm test\n\nforcetest:\n\tcd test && ../node_modules/.bin/node-gyp rebuild && cd ..\n\tnpm test\n\ndocs: README.md doc/.build.sh doc/asyncworker.md doc/buffers.md doc/callback.md \\\n\t\tdoc/converters.md doc/errors.md doc/maybe_types.md doc/methods.md doc/new.md \\\n\t\tdoc/node_misc.md doc/persistent.md doc/scopes.md doc/script.md doc/string_bytes.md \\\n\t\tdoc/v8_internals.md doc/json.md doc/v8_misc.md\n\tdoc/.build.sh\n\n\n$(ADDONS): nan.h nan_new.h nan_implementation_pre_12_inl.h nan_implementation_12_inl.h \\\n\t\tnan_callbacks.h nan_callbacks_12_inl.h nan_callbacks_pre_12_inl.h \\\n\t\tnan_converters.h nan_converters_43_inl.h nan_converters_pre_43_inl.h \\\n\t\tnan_define_own_property_helper.h \\\n\t\tnan_json.h nan_maybe_43_inl.h nan_maybe_pre_43_inl.h \\\n\t\tnan_persistent_12_inl.h nan_persistent_pre_12_inl.h nan_private.h \\\n\t\tnan_weak.h nan_scriptorigin.h nan_string_bytes.h \\\n\t\ttest/binding.gyp $(SOURCES)\n\tcd test/ && ../node_modules/.bin/node-gyp rebuild\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 27.9658203125,
          "content": "Native Abstractions for Node.js\n===============================\n\n**A header file filled with macro and utility goodness for making add-on development for Node.js easier across versions 0.8, 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22 and 23.**\n\n***Current version: 2.22.0***\n\n*(See [CHANGELOG.md](https://github.com/nodejs/nan/blob/master/CHANGELOG.md) for complete ChangeLog)*\n\n[![NPM](https://nodei.co/npm/nan.png?downloads=true&downloadRank=true)](https://nodei.co/npm/nan/) [![NPM](https://nodei.co/npm-dl/nan.png?months=6&height=3)](https://nodei.co/npm/nan/)\n\n[![Build Status](https://api.travis-ci.com/nodejs/nan.svg?branch=master)](https://travis-ci.com/nodejs/nan)\n[![Build status](https://ci.appveyor.com/api/projects/status/kh73pbm9dsju7fgh)](https://ci.appveyor.com/project/RodVagg/nan)\n\nThanks to the crazy changes in V8 (and some in Node core), keeping native addons compiling happily across versions, particularly 0.10 to 0.12 to 4.0, is a minor nightmare. The goal of this project is to store all logic necessary to develop native Node.js addons without having to inspect `NODE_MODULE_VERSION` and get yourself into a macro-tangle.\n\nThis project also contains some helper utilities that make addon development a bit more pleasant.\n\n * **[News & Updates](#news)**\n * **[Usage](#usage)**\n * **[Example](#example)**\n * **[API](#api)**\n * **[Tests](#tests)**\n * **[Known issues](#issues)**\n * **[Governance & Contributing](#governance)**\n\n<a name=\"news\"></a>\n\n## News & Updates\n\n<a name=\"usage\"></a>\n\n## Usage\n\nSimply add **NAN** as a dependency in the *package.json* of your Node addon:\n\n``` bash\n$ npm install --save nan\n```\n\nPull in the path to **NAN** in your *binding.gyp* so that you can use `#include <nan.h>` in your *.cpp* files:\n\n``` python\n\"include_dirs\" : [\n    \"<!(node -e \\\"require('nan')\\\")\"\n]\n```\n\nThis works like a `-I<path-to-NAN>` when compiling your addon.\n\n<a name=\"example\"></a>\n\n## Example\n\nJust getting started with Nan? Take a look at the **[Node Add-on Examples](https://github.com/nodejs/node-addon-examples)**.\n\nRefer to a [quick-start **Nan** Boilerplate](https://github.com/fcanas/node-native-boilerplate) for a ready-to-go project that utilizes basic Nan functionality.\n\nFor a simpler example, see the **[async pi estimation example](https://github.com/nodejs/nan/tree/master/examples/async_pi_estimate)** in the examples directory for full code and an explanation of what this Monte Carlo Pi estimation example does. Below are just some parts of the full example that illustrate the use of **NAN**.\n\nYet another example is **[nan-example-eol](https://github.com/CodeCharmLtd/nan-example-eol)**. It shows newline detection implemented as a native addon.\n\nAlso take a look at our comprehensive **[C++ test suite](https://github.com/nodejs/nan/tree/master/test/cpp)** which has a plethora of code snippets for your pasting pleasure.\n\n<a name=\"api\"></a>\n\n## API\n\nAdditional to the NAN documentation below, please consult:\n\n* [The V8 Getting Started * Guide](https://v8.dev/docs/embed)\n* [V8 API Documentation](https://v8docs.nodesource.com/)\n* [Node Add-on Documentation](https://nodejs.org/api/addons.html)\n\n<!-- START API -->\n\n### JavaScript-accessible methods\n\nA _template_ is a blueprint for JavaScript functions and objects in a context. You can use a template to wrap C++ functions and data structures within JavaScript objects so that they can be manipulated from JavaScript. See the V8 Embedders Guide section on [Templates](https://github.com/v8/v8/wiki/Embedder%27s-Guide#templates) for further information.\n\nIn order to expose functionality to JavaScript via a template, you must provide it to V8 in a form that it understands. Across the versions of V8 supported by NAN, JavaScript-accessible method signatures vary widely, NAN fully abstracts method declaration and provides you with an interface that is similar to the most recent V8 API but is backward-compatible with older versions that still use the now-deceased `v8::Argument` type.\n\n* **Method argument types**\n - <a href=\"doc/methods.md#api_nan_function_callback_info\"><b><code>Nan::FunctionCallbackInfo</code></b></a>\n - <a href=\"doc/methods.md#api_nan_property_callback_info\"><b><code>Nan::PropertyCallbackInfo</code></b></a>\n - <a href=\"doc/methods.md#api_nan_return_value\"><b><code>Nan::ReturnValue</code></b></a>\n* **Method declarations**\n - <a href=\"doc/methods.md#api_nan_method\"><b>Method declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_getter\"><b>Getter declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_setter\"><b>Setter declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_property_getter\"><b>Property getter declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_property_setter\"><b>Property setter declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_property_enumerator\"><b>Property enumerator declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_property_deleter\"><b>Property deleter declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_property_query\"><b>Property query declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_index_getter\"><b>Index getter declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_index_setter\"><b>Index setter declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_index_enumerator\"><b>Index enumerator declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_index_deleter\"><b>Index deleter declaration</b></a>\n - <a href=\"doc/methods.md#api_nan_index_query\"><b>Index query declaration</b></a>\n* Method and template helpers\n - <a href=\"doc/methods.md#api_nan_set_method\"><b><code>Nan::SetMethod()</code></b></a>\n - <a href=\"doc/methods.md#api_nan_set_prototype_method\"><b><code>Nan::SetPrototypeMethod()</code></b></a>\n - <a href=\"doc/methods.md#api_nan_set_accessor\"><b><code>Nan::SetAccessor()</code></b></a>\n - <a href=\"doc/methods.md#api_nan_set_named_property_handler\"><b><code>Nan::SetNamedPropertyHandler()</code></b></a>\n - <a href=\"doc/methods.md#api_nan_set_indexed_property_handler\"><b><code>Nan::SetIndexedPropertyHandler()</code></b></a>\n - <a href=\"doc/methods.md#api_nan_set_template\"><b><code>Nan::SetTemplate()</code></b></a>\n - <a href=\"doc/methods.md#api_nan_set_prototype_template\"><b><code>Nan::SetPrototypeTemplate()</code></b></a>\n - <a href=\"doc/methods.md#api_nan_set_instance_template\"><b><code>Nan::SetInstanceTemplate()</code></b></a>\n - <a href=\"doc/methods.md#api_nan_set_call_handler\"><b><code>Nan::SetCallHandler()</code></b></a>\n - <a href=\"doc/methods.md#api_nan_set_call_as_function_handler\"><b><code>Nan::SetCallAsFunctionHandler()</code></b></a>\n\n### Scopes\n\nA _local handle_ is a pointer to an object. All V8 objects are accessed using handles, they are necessary because of the way the V8 garbage collector works.\n\nA handle scope can be thought of as a container for any number of handles. When you've finished with your handles, instead of deleting each one individually you can simply delete their scope.\n\nThe creation of `HandleScope` objects is different across the supported versions of V8. Therefore, NAN provides its own implementations that can be used safely across these.\n\n - <a href=\"doc/scopes.md#api_nan_handle_scope\"><b><code>Nan::HandleScope</code></b></a>\n - <a href=\"doc/scopes.md#api_nan_escapable_handle_scope\"><b><code>Nan::EscapableHandleScope</code></b></a>\n\nAlso see the V8 Embedders Guide section on [Handles and Garbage Collection](https://github.com/v8/v8/wiki/Embedder%27s%20Guide#handles-and-garbage-collection).\n\n### Persistent references\n\nAn object reference that is independent of any `HandleScope` is a _persistent_ reference. Where a `Local` handle only lives as long as the `HandleScope` in which it was allocated, a `Persistent` handle remains valid until it is explicitly disposed.\n\nDue to the evolution of the V8 API, it is necessary for NAN to provide a wrapper implementation of the `Persistent` classes to supply compatibility across the V8 versions supported.\n\n - <a href=\"doc/persistent.md#api_nan_persistent_base\"><b><code>Nan::PersistentBase & v8::PersistentBase</code></b></a>\n - <a href=\"doc/persistent.md#api_nan_non_copyable_persistent_traits\"><b><code>Nan::NonCopyablePersistentTraits & v8::NonCopyablePersistentTraits</code></b></a>\n - <a href=\"doc/persistent.md#api_nan_copyable_persistent_traits\"><b><code>Nan::CopyablePersistentTraits & v8::CopyablePersistentTraits</code></b></a>\n - <a href=\"doc/persistent.md#api_nan_persistent\"><b><code>Nan::Persistent</code></b></a>\n - <a href=\"doc/persistent.md#api_nan_global\"><b><code>Nan::Global</code></b></a>\n - <a href=\"doc/persistent.md#api_nan_weak_callback_info\"><b><code>Nan::WeakCallbackInfo</code></b></a>\n - <a href=\"doc/persistent.md#api_nan_weak_callback_type\"><b><code>Nan::WeakCallbackType</code></b></a>\n\nAlso see the V8 Embedders Guide section on [Handles and Garbage Collection](https://v8.dev/docs/embed#handles-and-garbage-collection).\n\n### New\n\nNAN provides a `Nan::New()` helper for the creation of new JavaScript objects in a way that's compatible across the supported versions of V8.\n\n - <a href=\"doc/new.md#api_nan_new\"><b><code>Nan::New()</code></b></a>\n - <a href=\"doc/new.md#api_nan_undefined\"><b><code>Nan::Undefined()</code></b></a>\n - <a href=\"doc/new.md#api_nan_null\"><b><code>Nan::Null()</code></b></a>\n - <a href=\"doc/new.md#api_nan_true\"><b><code>Nan::True()</code></b></a>\n - <a href=\"doc/new.md#api_nan_false\"><b><code>Nan::False()</code></b></a>\n - <a href=\"doc/new.md#api_nan_empty_string\"><b><code>Nan::EmptyString()</code></b></a>\n\n\n### Converters\n\nNAN contains functions that convert `v8::Value`s to other `v8::Value` types and native types. Since type conversion is not guaranteed to succeed, they return `Nan::Maybe` types. These converters can be used in place of `value->ToX()` and `value->XValue()` (where `X` is one of the types, e.g. `Boolean`) in a way that provides a consistent interface across V8 versions. Newer versions of V8 use the new `v8::Maybe` and `v8::MaybeLocal` types for these conversions, older versions don't have this functionality so it is provided by NAN.\n\n - <a href=\"doc/converters.md#api_nan_to\"><b><code>Nan::To()</code></b></a>\n\n### Maybe Types\n\nThe `Nan::MaybeLocal` and `Nan::Maybe` types are monads that encapsulate `v8::Local` handles that _may be empty_.\n\n* **Maybe Types**\n  - <a href=\"doc/maybe_types.md#api_nan_maybe_local\"><b><code>Nan::MaybeLocal</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_maybe\"><b><code>Nan::Maybe</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_nothing\"><b><code>Nan::Nothing</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_just\"><b><code>Nan::Just</code></b></a>\n* **Maybe Helpers**\n  - <a href=\"doc/maybe_types.md#api_nan_call\"><b><code>Nan::Call()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_to_detail_string\"><b><code>Nan::ToDetailString()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_to_array_index\"><b><code>Nan::ToArrayIndex()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_equals\"><b><code>Nan::Equals()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_new_instance\"><b><code>Nan::NewInstance()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get_function\"><b><code>Nan::GetFunction()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_set\"><b><code>Nan::Set()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_define_own_property\"><b><code>Nan::DefineOwnProperty()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_force_set\"><del><b><code>Nan::ForceSet()</code></b></del></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get\"><b><code>Nan::Get()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get_property_attribute\"><b><code>Nan::GetPropertyAttributes()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_has\"><b><code>Nan::Has()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_delete\"><b><code>Nan::Delete()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get_property_names\"><b><code>Nan::GetPropertyNames()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get_own_property_names\"><b><code>Nan::GetOwnPropertyNames()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_set_prototype\"><b><code>Nan::SetPrototype()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_object_proto_to_string\"><b><code>Nan::ObjectProtoToString()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_has_own_property\"><b><code>Nan::HasOwnProperty()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_has_real_named_property\"><b><code>Nan::HasRealNamedProperty()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_has_real_indexed_property\"><b><code>Nan::HasRealIndexedProperty()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_has_real_named_callback_property\"><b><code>Nan::HasRealNamedCallbackProperty()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get_real_named_property_in_prototype_chain\"><b><code>Nan::GetRealNamedPropertyInPrototypeChain()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get_real_named_property\"><b><code>Nan::GetRealNamedProperty()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_call_as_function\"><b><code>Nan::CallAsFunction()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_call_as_constructor\"><b><code>Nan::CallAsConstructor()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get_source_line\"><b><code>Nan::GetSourceLine()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get_line_number\"><b><code>Nan::GetLineNumber()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get_start_column\"><b><code>Nan::GetStartColumn()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get_end_column\"><b><code>Nan::GetEndColumn()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_clone_element_at\"><b><code>Nan::CloneElementAt()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_has_private\"><b><code>Nan::HasPrivate()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_get_private\"><b><code>Nan::GetPrivate()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_set_private\"><b><code>Nan::SetPrivate()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_delete_private\"><b><code>Nan::DeletePrivate()</code></b></a>\n  - <a href=\"doc/maybe_types.md#api_nan_make_maybe\"><b><code>Nan::MakeMaybe()</code></b></a>\n\n### Script\n\nNAN provides `v8::Script` helpers as the API has changed over the supported versions of V8.\n\n - <a href=\"doc/script.md#api_nan_compile_script\"><b><code>Nan::CompileScript()</code></b></a>\n - <a href=\"doc/script.md#api_nan_run_script\"><b><code>Nan::RunScript()</code></b></a>\n - <a href=\"doc/script.md#api_nan_script_origin\"><b><code>Nan::ScriptOrigin</code></b></a>\n\n\n### JSON\n\nThe _JSON_ object provides the C++ versions of the methods offered by the `JSON` object in javascript. V8 exposes these methods via the `v8::JSON` object.\n\n - <a href=\"doc/json.md#api_nan_json_parse\"><b><code>Nan::JSON.Parse</code></b></a>\n - <a href=\"doc/json.md#api_nan_json_stringify\"><b><code>Nan::JSON.Stringify</code></b></a>\n\nRefer to the V8 JSON object in the [V8 documentation](https://v8docs.nodesource.com/node-8.16/da/d6f/classv8_1_1_j_s_o_n.html) for more information about these methods and their arguments.\n\n### Errors\n\nNAN includes helpers for creating, throwing and catching Errors as much of this functionality varies across the supported versions of V8 and must be abstracted.\n\nNote that an Error object is simply a specialized form of `v8::Value`.\n\nAlso consult the V8 Embedders Guide section on [Exceptions](https://v8.dev/docs/embed#exceptions) for more information.\n\n - <a href=\"doc/errors.md#api_nan_error\"><b><code>Nan::Error()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_range_error\"><b><code>Nan::RangeError()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_reference_error\"><b><code>Nan::ReferenceError()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_syntax_error\"><b><code>Nan::SyntaxError()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_type_error\"><b><code>Nan::TypeError()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_throw_error\"><b><code>Nan::ThrowError()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_throw_range_error\"><b><code>Nan::ThrowRangeError()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_throw_reference_error\"><b><code>Nan::ThrowReferenceError()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_throw_syntax_error\"><b><code>Nan::ThrowSyntaxError()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_throw_type_error\"><b><code>Nan::ThrowTypeError()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_fatal_exception\"><b><code>Nan::FatalException()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_errno_exception\"><b><code>Nan::ErrnoException()</code></b></a>\n - <a href=\"doc/errors.md#api_nan_try_catch\"><b><code>Nan::TryCatch</code></b></a>\n\n\n### Buffers\n\nNAN's `node::Buffer` helpers exist as the API has changed across supported Node versions. Use these methods to ensure compatibility.\n\n - <a href=\"doc/buffers.md#api_nan_new_buffer\"><b><code>Nan::NewBuffer()</code></b></a>\n - <a href=\"doc/buffers.md#api_nan_copy_buffer\"><b><code>Nan::CopyBuffer()</code></b></a>\n - <a href=\"doc/buffers.md#api_nan_free_callback\"><b><code>Nan::FreeCallback()</code></b></a>\n\n### Nan::Callback\n\n`Nan::Callback` makes it easier to use `v8::Function` handles as callbacks. A class that wraps a `v8::Function` handle, protecting it from garbage collection and making it particularly useful for storage and use across asynchronous execution.\n\n - <a href=\"doc/callback.md#api_nan_callback\"><b><code>Nan::Callback</code></b></a>\n\n### Asynchronous work helpers\n\n`Nan::AsyncWorker`, `Nan::AsyncProgressWorker` and `Nan::AsyncProgressQueueWorker` are helper classes that make working with asynchronous code easier.\n\n - <a href=\"doc/asyncworker.md#api_nan_async_worker\"><b><code>Nan::AsyncWorker</code></b></a>\n - <a href=\"doc/asyncworker.md#api_nan_async_progress_worker\"><b><code>Nan::AsyncProgressWorkerBase &amp; Nan::AsyncProgressWorker</code></b></a>\n - <a href=\"doc/asyncworker.md#api_nan_async_progress_queue_worker\"><b><code>Nan::AsyncProgressQueueWorker</code></b></a>\n - <a href=\"doc/asyncworker.md#api_nan_async_queue_worker\"><b><code>Nan::AsyncQueueWorker</code></b></a>\n\n### Strings & Bytes\n\nMiscellaneous string & byte encoding and decoding functionality provided for compatibility across supported versions of V8 and Node. Implemented by NAN to ensure that all encoding types are supported, even for older versions of Node where they are missing.\n\n - <a href=\"doc/string_bytes.md#api_nan_encoding\"><b><code>Nan::Encoding</code></b></a>\n - <a href=\"doc/string_bytes.md#api_nan_encode\"><b><code>Nan::Encode()</code></b></a>\n - <a href=\"doc/string_bytes.md#api_nan_decode_bytes\"><b><code>Nan::DecodeBytes()</code></b></a>\n - <a href=\"doc/string_bytes.md#api_nan_decode_write\"><b><code>Nan::DecodeWrite()</code></b></a>\n\n\n### Object Wrappers\n\nThe `ObjectWrap` class can be used to make wrapped C++ objects and a factory of wrapped objects.\n\n - <a href=\"doc/object_wrappers.md#api_nan_object_wrap\"><b><code>Nan::ObjectWrap</code></b></a>\n\n\n### V8 internals\n\nThe hooks to access V8 internals—including GC and statistics—are different across the supported versions of V8, therefore NAN provides its own hooks that call the appropriate V8 methods.\n\n - <a href=\"doc/v8_internals.md#api_nan_gc_callback\"><b><code>NAN_GC_CALLBACK()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_add_gc_epilogue_callback\"><b><code>Nan::AddGCEpilogueCallback()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_remove_gc_epilogue_callback\"><b><code>Nan::RemoveGCEpilogueCallback()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_add_gc_prologue_callback\"><b><code>Nan::AddGCPrologueCallback()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_remove_gc_prologue_callback\"><b><code>Nan::RemoveGCPrologueCallback()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_get_heap_statistics\"><b><code>Nan::GetHeapStatistics()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_set_counter_function\"><b><code>Nan::SetCounterFunction()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_set_create_histogram_function\"><b><code>Nan::SetCreateHistogramFunction()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_set_add_histogram_sample_function\"><b><code>Nan::SetAddHistogramSampleFunction()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_idle_notification\"><del><b><code>Nan::IdleNotification()</code></b></del></a>\n - <a href=\"doc/v8_internals.md#api_nan_low_memory_notification\"><b><code>Nan::LowMemoryNotification()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_context_disposed_notification\"><b><code>Nan::ContextDisposedNotification()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_get_internal_field_pointer\"><b><code>Nan::GetInternalFieldPointer()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_set_internal_field_pointer\"><b><code>Nan::SetInternalFieldPointer()</code></b></a>\n - <a href=\"doc/v8_internals.md#api_nan_adjust_external_memory\"><b><code>Nan::AdjustExternalMemory()</code></b></a>\n\n\n### Miscellaneous V8 Helpers\n\n - <a href=\"doc/v8_misc.md#api_nan_utf8_string\"><b><code>Nan::Utf8String</code></b></a>\n - <a href=\"doc/v8_misc.md#api_nan_get_current_context\"><b><code>Nan::GetCurrentContext()</code></b></a>\n - <a href=\"doc/v8_misc.md#api_nan_set_isolate_data\"><b><code>Nan::SetIsolateData()</code></b></a>\n - <a href=\"doc/v8_misc.md#api_nan_get_isolate_data\"><b><code>Nan::GetIsolateData()</code></b></a>\n - <a href=\"doc/v8_misc.md#api_nan_typedarray_contents\"><b><code>Nan::TypedArrayContents</code></b></a>\n\n\n### Miscellaneous Node Helpers\n\n - <a href=\"doc/node_misc.md#api_nan_asyncresource\"><b><code>Nan::AsyncResource</code></b></a>\n - <a href=\"doc/node_misc.md#api_nan_make_callback\"><b><code>Nan::MakeCallback()</code></b></a>\n - <a href=\"doc/node_misc.md#api_nan_module_init\"><b><code>NAN_MODULE_INIT()</code></b></a>\n - <a href=\"doc/node_misc.md#api_nan_export\"><b><code>Nan::Export()</code></b></a>\n\n<!-- END API -->\n\n\n<a name=\"tests\"></a>\n\n### Tests\n\nTo run the NAN tests do:\n\n``` sh\nnpm install\nnpm run-script rebuild-tests\nnpm test\n```\n\nOr just:\n\n``` sh\nnpm install\nmake test\n```\n\n<a name=\"issues\"></a>\n\n## Known issues\n\n### Compiling against Node.js 0.12 on OSX\n\nWith new enough compilers available on OSX, the versions of V8 headers corresponding to Node.js 0.12\ndo not compile anymore. The error looks something like:\n\n```\n❯   CXX(target) Release/obj.target/accessors/cpp/accessors.o\nIn file included from ../cpp/accessors.cpp:9:\nIn file included from ../../nan.h:51:\nIn file included from /Users/ofrobots/.node-gyp/0.12.18/include/node/node.h:61:\n/Users/ofrobots/.node-gyp/0.12.18/include/node/v8.h:5800:54: error: 'CreateHandle' is a protected member of 'v8::HandleScope'\n  return Handle<T>(reinterpret_cast<T*>(HandleScope::CreateHandle(\n                                        ~~~~~~~~~~~~~^~~~~~~~~~~~\n```\n\nThis can be worked around by patching your local versions of v8.h corresponding to Node 0.12 to make\n`v8::Handle` a friend of `v8::HandleScope`. Since neither Node.js not V8 support this release line anymore\nthis patch cannot be released by either project in an official release.\n\nFor this reason, we do not test against Node.js 0.12 on OSX in this project's CI. If you need to support\nthat configuration, you will need to either get an older compiler, or apply a source patch to the version\nof V8 headers as a workaround.\n\n<a name=\"governance\"></a>\n\n## Governance & Contributing\n\nNAN is governed by the [Node.js Addon API Working Group](https://github.com/nodejs/CTC/blob/master/WORKING_GROUPS.md#addon-api)\n\n### Addon API Working Group (WG)\n\nThe NAN project is jointly governed by a Working Group which is responsible for high-level guidance of the project.\n\nMembers of the WG are also known as Collaborators, there is no distinction between the two, unlike other Node.js projects.\n\nThe WG has final authority over this project including:\n\n* Technical direction\n* Project governance and process (including this policy)\n* Contribution policy\n* GitHub repository hosting\n* Maintaining the list of additional Collaborators\n\nFor the current list of WG members, see the project [README.md](./README.md#collaborators).\n\nIndividuals making significant and valuable contributions are made members of the WG and given commit-access to the project. These individuals are identified by the WG and their addition to the WG is discussed via GitHub and requires unanimous consensus amongst those WG members participating in the discussion with a quorum of 50% of WG members required for acceptance of the vote.\n\n_Note:_ If you make a significant contribution and are not considered for commit-access log an issue or contact a WG member directly.\n\nFor the current list of WG members / Collaborators, see the project [README.md](./README.md#collaborators).\n\n### Consensus Seeking Process\n\nThe WG follows a [Consensus Seeking](https://en.wikipedia.org/wiki/Consensus-seeking_decision-making) decision making model.\n\nModifications of the contents of the NAN repository are made on a collaborative basis. Anybody with a GitHub account may propose a modification via pull request and it will be considered by the WG. All pull requests must be reviewed and accepted by a WG member with sufficient expertise who is able to take full responsibility for the change. In the case of pull requests proposed by an existing WG member, an additional WG member is required for sign-off. Consensus should be sought if additional WG members participate and there is disagreement around a particular modification.\n\nIf a change proposal cannot reach a consensus, a WG member can call for a vote amongst the members of the WG. Simple majority wins.\n\n<a id=\"developers-certificate-of-origin\"></a>\n\n## Developer's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n* (a) The contribution was created in whole or in part by me and I\n  have the right to submit it under the open source license\n  indicated in the file; or\n\n* (b) The contribution is based upon previous work that, to the best\n  of my knowledge, is covered under an appropriate open source\n  license and I have the right under that license to submit that\n  work with modifications, whether created in whole or in part\n  by me, under the same open source license (unless I am\n  permitted to submit under a different license), as indicated\n  in the file; or\n\n* (c) The contribution was provided directly to me by some other\n  person who certified (a), (b) or (c) and I have not modified\n  it.\n\n* (d) I understand and agree that this project and the contribution\n  are public and that a record of the contribution (including all\n  personal information I submit with it, including my sign-off) is\n  maintained indefinitely and may be redistributed consistent with\n  this project or the open source license(s) involved.\n\n<a name=\"collaborators\"></a>\n\n### WG Members / Collaborators\n\n<table><tbody>\n<tr><th align=\"left\">Rod Vagg</th><td><a href=\"https://github.com/rvagg\">GitHub/rvagg</a></td><td><a href=\"http://twitter.com/rvagg\">Twitter/@rvagg</a></td></tr>\n<tr><th align=\"left\">Benjamin Byholm</th><td><a href=\"https://github.com/kkoopa/\">GitHub/kkoopa</a></td><td>-</td></tr>\n<tr><th align=\"left\">Trevor Norris</th><td><a href=\"https://github.com/trevnorris\">GitHub/trevnorris</a></td><td><a href=\"http://twitter.com/trevnorris\">Twitter/@trevnorris</a></td></tr>\n<tr><th align=\"left\">Nathan Rajlich</th><td><a href=\"https://github.com/TooTallNate\">GitHub/TooTallNate</a></td><td><a href=\"http://twitter.com/TooTallNate\">Twitter/@TooTallNate</a></td></tr>\n<tr><th align=\"left\">Brett Lawson</th><td><a href=\"https://github.com/brett19\">GitHub/brett19</a></td><td><a href=\"http://twitter.com/brett19x\">Twitter/@brett19x</a></td></tr>\n<tr><th align=\"left\">Ben Noordhuis</th><td><a href=\"https://github.com/bnoordhuis\">GitHub/bnoordhuis</a></td><td><a href=\"http://twitter.com/bnoordhuis\">Twitter/@bnoordhuis</a></td></tr>\n<tr><th align=\"left\">David Siegel</th><td><a href=\"https://github.com/agnat\">GitHub/agnat</a></td><td><a href=\"http://twitter.com/agnat\">Twitter/@agnat</a></td></tr>\n<tr><th align=\"left\">Michael Ira Krufky</th><td><a href=\"https://github.com/mkrufky\">GitHub/mkrufky</a></td><td><a href=\"http://twitter.com/mkrufky\">Twitter/@mkrufky</a></td></tr>\n</tbody></table>\n\n## Licence &amp; copyright\n\nCopyright (c) 2018 NAN WG Members / Collaborators (listed above).\n\nNative Abstractions for Node.js is licensed under an MIT license. All rights not explicitly granted in the MIT license are reserved. See the included LICENSE file for more details.\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 1.8076171875,
          "content": "# http://www.appveyor.com/docs/appveyor-yml\n\nimage:\n  - Visual Studio 2017\n\n# Test against these versions of Io.js and Node.js.\nenvironment:\n  matrix:\n  # node.js\n    - nodejs_version: \"0.10\"\n    - nodejs_version: \"0.12\"\n    - nodejs_version: \"4\"\n    - nodejs_version: \"5\"\n    - nodejs_version: \"6\"\n    - nodejs_version: \"7\"\n    - nodejs_version: \"8\"\n    - nodejs_version: \"9\"\n    - nodejs_version: \"10\"\n    - nodejs_version: \"11\"\n    - nodejs_version: \"12\"\n    - nodejs_version: \"13\"\n    - nodejs_version: \"14\"\n    - nodejs_version: \"15\"\n    - nodejs_version: \"16\"\n    - nodejs_version: \"17\"\n    - nodejs_version: \"18\"\n    - nodejs_version: \"19\"\n    - nodejs_version: \"20\"\n    - nodejs_version: \"21\"\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      nodejs_version: \"22\"\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n      nodejs_version: \"23\"\n\n# Install scripts. (runs after repo cloning)\ninstall:\n  # Get the latest stable version of Node 0.STABLE.latest\n  - ps: Update-NodeJsInstallation (Get-NodeJsLatestBuild $env:nodejs_version) x64\n  - IF %nodejs_version% LSS 4 npm -g install npm@2\n  - IF %nodejs_version% EQU 5 npm -g install npm@3\n  - set PATH=%APPDATA%\\npm;%PATH%\n  # Typical npm stuff.\n  - npm install\n  - IF %nodejs_version% GEQ 22 set NODE_GYP_FORCE_PYTHON=C:\\Python38-x64\\python.exe\n  - IF %nodejs_version% LSS 8 (npm run rebuild-tests-2015) ELSE (npm run rebuild-tests)\n\n# Post-install test scripts.\ntest_script:\n  # Output useful info for debugging.\n  - node --version\n  - npm --version\n  # run tests\n  - IF %nodejs_version% LSS 1 (npm test) ELSE (IF %nodejs_version% LSS 4 (iojs node_modules\\tap\\bin\\tap.js --gc test/js/*-test.js) ELSE (node node_modules\\tap\\bin\\tap.js --gc test/js/*-test.js))\n\n# Don't actually build.\nbuild: off\n\n# Set build version format here instead of in the admin panel.\nversion: \"{build}\"\n"
        },
        {
          "name": "cpplint.py",
          "type": "blob",
          "size": 248.4453125,
          "content": "#!/usr/bin/env python\n#\n# Copyright (c) 2009 Google Inc. All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n#    * Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n#    * Redistributions in binary form must reproduce the above\n# copyright notice, this list of conditions and the following disclaimer\n# in the documentation and/or other materials provided with the\n# distribution.\n#    * Neither the name of Google Inc. nor the names of its\n# contributors may be used to endorse or promote products derived from\n# this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\"\"\"Does google-lint on c++ files.\n\nThe goal of this script is to identify places in the code that *may*\nbe in non-compliance with google style.  It does not attempt to fix\nup these problems -- the point is to educate.  It does also not\nattempt to find all problems, or to ensure that everything it does\nfind is legitimately a problem.\n\nIn particular, we can get very confused by /* and // inside strings!\nWe do a small hack, which is to ignore //'s with \"'s after them on the\nsame line, but it is far from perfect (in either direction).\n\"\"\"\n\nimport codecs\nimport copy\nimport getopt\nimport glob\nimport itertools\nimport math  # for log\nimport os\nimport re\nimport sre_compile\nimport string\nimport sys\nimport sysconfig\nimport unicodedata\nimport xml.etree.ElementTree\n\n# if empty, use defaults\n_valid_extensions = set([])\n\n__VERSION__ = '1.4.4'\n\ntry:\n  xrange          # Python 2\nexcept NameError:\n  #  -- pylint: disable=redefined-builtin\n  xrange = range  # Python 3\n\n\n_USAGE = \"\"\"\nSyntax: cpplint.py [--verbose=#] [--output=emacs|eclipse|vs7|junit]\n                   [--filter=-x,+y,...]\n                   [--counting=total|toplevel|detailed] [--root=subdir]\n                   [--repository=path]\n                   [--linelength=digits] [--headers=x,y,...]\n                   [--recursive]\n                   [--exclude=path]\n                   [--extensions=hpp,cpp,...]\n                   [--quiet]\n                   [--version]\n        <file> [file] ...\n\n  Style checker for C/C++ source files.\n  This is a fork of the Google style checker with minor extensions.\n\n  The style guidelines this tries to follow are those in\n    https://google.github.io/styleguide/cppguide.html\n\n  Every problem is given a confidence score from 1-5, with 5 meaning we are\n  certain of the problem, and 1 meaning it could be a legitimate construct.\n  This will miss some errors, and is not a substitute for a code review.\n\n  To suppress false-positive errors of a certain category, add a\n  'NOLINT(category)' comment to the line.  NOLINT or NOLINT(*)\n  suppresses errors of all categories on that line.\n\n  The files passed in will be linted; at least one file must be provided.\n  Default linted extensions are %s.\n  Other file types will be ignored.\n  Change the extensions with the --extensions flag.\n\n  Flags:\n\n    output=emacs|eclipse|vs7|junit\n      By default, the output is formatted to ease emacs parsing.  Visual Studio\n      compatible output (vs7) may also be used.  Further support exists for\n      eclipse (eclipse), and JUnit (junit). XML parsers such as those used\n      in Jenkins and Bamboo may also be used.  Other formats are unsupported.\n\n    verbose=#\n      Specify a number 0-5 to restrict errors to certain verbosity levels.\n      Errors with lower verbosity levels have lower confidence and are more\n      likely to be false positives.\n\n    quiet\n      Don't print anything if no errors are found.\n\n    filter=-x,+y,...\n      Specify a comma-separated list of category-filters to apply: only\n      error messages whose category names pass the filters will be printed.\n      (Category names are printed with the message and look like\n      \"[whitespace/indent]\".)  Filters are evaluated left to right.\n      \"-FOO\" and \"FOO\" means \"do not print categories that start with FOO\".\n      \"+FOO\" means \"do print categories that start with FOO\".\n\n      Examples: --filter=-whitespace,+whitespace/braces\n                --filter=whitespace,runtime/printf,+runtime/printf_format\n                --filter=-,+build/include_what_you_use\n\n      To see a list of all the categories used in cpplint, pass no arg:\n         --filter=\n\n    counting=total|toplevel|detailed\n      The total number of errors found is always printed. If\n      'toplevel' is provided, then the count of errors in each of\n      the top-level categories like 'build' and 'whitespace' will\n      also be printed. If 'detailed' is provided, then a count\n      is provided for each category like 'build/class'.\n\n    repository=path\n      The top level directory of the repository, used to derive the header\n      guard CPP variable. By default, this is determined by searching for a\n      path that contains .git, .hg, or .svn. When this flag is specified, the\n      given path is used instead. This option allows the header guard CPP\n      variable to remain consistent even if members of a team have different\n      repository root directories (such as when checking out a subdirectory\n      with SVN). In addition, users of non-mainstream version control systems\n      can use this flag to ensure readable header guard CPP variables.\n\n      Examples:\n        Assuming that Alice checks out ProjectName and Bob checks out\n        ProjectName/trunk and trunk contains src/chrome/ui/browser.h, then\n        with no --repository flag, the header guard CPP variable will be:\n\n        Alice => TRUNK_SRC_CHROME_BROWSER_UI_BROWSER_H_\n        Bob   => SRC_CHROME_BROWSER_UI_BROWSER_H_\n\n        If Alice uses the --repository=trunk flag and Bob omits the flag or\n        uses --repository=. then the header guard CPP variable will be:\n\n        Alice => SRC_CHROME_BROWSER_UI_BROWSER_H_\n        Bob   => SRC_CHROME_BROWSER_UI_BROWSER_H_\n\n    root=subdir\n      The root directory used for deriving header guard CPP variable.\n      This directory is relative to the top level directory of the repository\n      which by default is determined by searching for a directory that contains\n      .git, .hg, or .svn but can also be controlled with the --repository flag.\n      If the specified directory does not exist, this flag is ignored.\n\n      Examples:\n        Assuming that src is the top level directory of the repository (and\n        cwd=top/src), the header guard CPP variables for\n        src/chrome/browser/ui/browser.h are:\n\n        No flag => CHROME_BROWSER_UI_BROWSER_H_\n        --root=chrome => BROWSER_UI_BROWSER_H_\n        --root=chrome/browser => UI_BROWSER_H_\n        --root=.. => SRC_CHROME_BROWSER_UI_BROWSER_H_\n\n    linelength=digits\n      This is the allowed line length for the project. The default value is\n      80 characters.\n\n      Examples:\n        --linelength=120\n\n    recursive\n      Search for files to lint recursively. Each directory given in the list\n      of files to be linted is replaced by all files that descend from that\n      directory. Files with extensions not in the valid extensions list are\n      excluded.\n\n    exclude=path\n      Exclude the given path from the list of files to be linted. Relative\n      paths are evaluated relative to the current directory and shell globbing\n      is performed. This flag can be provided multiple times to exclude\n      multiple files.\n\n      Examples:\n        --exclude=one.cc\n        --exclude=src/*.cc\n        --exclude=src/*.cc --exclude=test/*.cc\n\n    extensions=extension,extension,...\n      The allowed file extensions that cpplint will check\n\n      Examples:\n        --extensions=%s\n\n    headers=x,y,...\n      The header extensions that cpplint will treat as .h in checks. Values are\n      automatically added to --extensions list.\n     (by default, only files with extensions %s will be assumed to be headers)\n\n      Examples:\n        --headers=%s\n        --headers=hpp,hxx\n        --headers=hpp\n\n    cpplint.py supports per-directory configurations specified in CPPLINT.cfg\n    files. CPPLINT.cfg file can contain a number of key=value pairs.\n    Currently the following options are supported:\n\n      set noparent\n      filter=+filter1,-filter2,...\n      exclude_files=regex\n      linelength=80\n      root=subdir\n      headers=x,y,...\n\n    \"set noparent\" option prevents cpplint from traversing directory tree\n    upwards looking for more .cfg files in parent directories. This option\n    is usually placed in the top-level project directory.\n\n    The \"filter\" option is similar in function to --filter flag. It specifies\n    message filters in addition to the |_DEFAULT_FILTERS| and those specified\n    through --filter command-line flag.\n\n    \"exclude_files\" allows to specify a regular expression to be matched against\n    a file name. If the expression matches, the file is skipped and not run\n    through the linter.\n\n    \"linelength\" allows to specify the allowed line length for the project.\n\n    The \"root\" option is similar in function to the --root flag (see example\n    above). Paths are relative to the directory of the CPPLINT.cfg.\n\n    The \"headers\" option is similar in function to the --headers flag\n    (see example above).\n\n    CPPLINT.cfg has an effect on files in the same directory and all\n    sub-directories, unless overridden by a nested configuration file.\n\n      Example file:\n        filter=-build/include_order,+build/include_alpha\n        exclude_files=.*\\\\.cc\n\n    The above example disables build/include_order warning and enables\n    build/include_alpha as well as excludes all .cc from being\n    processed by linter, in the current directory (where the .cfg\n    file is located) and all sub-directories.\n\"\"\"\n\n# We categorize each error message we print.  Here are the categories.\n# We want an explicit list so we can list them all in cpplint --filter=.\n# If you add a new error message with a new category, add it to the list\n# here!  cpplint_unittest.py should tell you if you forget to do this.\n_ERROR_CATEGORIES = [\n    'build/class',\n    'build/c++11',\n    'build/c++14',\n    'build/c++tr1',\n    'build/deprecated',\n    'build/endif_comment',\n    'build/explicit_make_pair',\n    'build/forward_decl',\n    'build/header_guard',\n    'build/include',\n    'build/include_subdir',\n    'build/include_alpha',\n    'build/include_order',\n    'build/include_what_you_use',\n    'build/namespaces_literals',\n    'build/namespaces',\n    'build/printf_format',\n    'build/storage_class',\n    'legal/copyright',\n    'readability/alt_tokens',\n    'readability/braces',\n    'readability/casting',\n    'readability/check',\n    'readability/constructors',\n    'readability/fn_size',\n    'readability/inheritance',\n    'readability/multiline_comment',\n    'readability/multiline_string',\n    'readability/namespace',\n    'readability/nolint',\n    'readability/nul',\n    'readability/strings',\n    'readability/todo',\n    'readability/utf8',\n    'runtime/arrays',\n    'runtime/casting',\n    'runtime/explicit',\n    'runtime/int',\n    'runtime/init',\n    'runtime/invalid_increment',\n    'runtime/member_string_references',\n    'runtime/memset',\n    'runtime/indentation_namespace',\n    'runtime/operator',\n    'runtime/printf',\n    'runtime/printf_format',\n    'runtime/references',\n    'runtime/string',\n    'runtime/threadsafe_fn',\n    'runtime/vlog',\n    'whitespace/blank_line',\n    'whitespace/braces',\n    'whitespace/comma',\n    'whitespace/comments',\n    'whitespace/empty_conditional_body',\n    'whitespace/empty_if_body',\n    'whitespace/empty_loop_body',\n    'whitespace/end_of_line',\n    'whitespace/ending_newline',\n    'whitespace/forcolon',\n    'whitespace/indent',\n    'whitespace/line_length',\n    'whitespace/newline',\n    'whitespace/operators',\n    'whitespace/parens',\n    'whitespace/semicolon',\n    'whitespace/tab',\n    'whitespace/todo',\n    ]\n\n# These error categories are no longer enforced by cpplint, but for backwards-\n# compatibility they may still appear in NOLINT comments.\n_LEGACY_ERROR_CATEGORIES = [\n    'readability/streams',\n    'readability/function',\n    ]\n\n# The default state of the category filter. This is overridden by the --filter=\n# flag. By default all errors are on, so only add here categories that should be\n# off by default (i.e., categories that must be enabled by the --filter= flags).\n# All entries here should start with a '-' or '+', as in the --filter= flag.\n_DEFAULT_FILTERS = ['-build/include_alpha']\n\n# The default list of categories suppressed for C (not C++) files.\n_DEFAULT_C_SUPPRESSED_CATEGORIES = [\n    'readability/casting',\n    ]\n\n# The default list of categories suppressed for Linux Kernel files.\n_DEFAULT_KERNEL_SUPPRESSED_CATEGORIES = [\n    'whitespace/tab',\n    ]\n\n# We used to check for high-bit characters, but after much discussion we\n# decided those were OK, as long as they were in UTF-8 and didn't represent\n# hard-coded international strings, which belong in a separate i18n file.\n\n# C++ headers\n_CPP_HEADERS = frozenset([\n    # Legacy\n    'algobase.h',\n    'algo.h',\n    'alloc.h',\n    'builtinbuf.h',\n    'bvector.h',\n    'complex.h',\n    'defalloc.h',\n    'deque.h',\n    'editbuf.h',\n    'fstream.h',\n    'function.h',\n    'hash_map',\n    'hash_map.h',\n    'hash_set',\n    'hash_set.h',\n    'hashtable.h',\n    'heap.h',\n    'indstream.h',\n    'iomanip.h',\n    'iostream.h',\n    'istream.h',\n    'iterator.h',\n    'list.h',\n    'map.h',\n    'multimap.h',\n    'multiset.h',\n    'ostream.h',\n    'pair.h',\n    'parsestream.h',\n    'pfstream.h',\n    'procbuf.h',\n    'pthread_alloc',\n    'pthread_alloc.h',\n    'rope',\n    'rope.h',\n    'ropeimpl.h',\n    'set.h',\n    'slist',\n    'slist.h',\n    'stack.h',\n    'stdiostream.h',\n    'stl_alloc.h',\n    'stl_relops.h',\n    'streambuf.h',\n    'stream.h',\n    'strfile.h',\n    'strstream.h',\n    'tempbuf.h',\n    'tree.h',\n    'type_traits.h',\n    'vector.h',\n    # 17.6.1.2 C++ library headers\n    'algorithm',\n    'array',\n    'atomic',\n    'bitset',\n    'chrono',\n    'codecvt',\n    'complex',\n    'condition_variable',\n    'deque',\n    'exception',\n    'forward_list',\n    'fstream',\n    'functional',\n    'future',\n    'initializer_list',\n    'iomanip',\n    'ios',\n    'iosfwd',\n    'iostream',\n    'istream',\n    'iterator',\n    'limits',\n    'list',\n    'locale',\n    'map',\n    'memory',\n    'mutex',\n    'new',\n    'numeric',\n    'ostream',\n    'queue',\n    'random',\n    'ratio',\n    'regex',\n    'scoped_allocator',\n    'set',\n    'sstream',\n    'stack',\n    'stdexcept',\n    'streambuf',\n    'string',\n    'strstream',\n    'system_error',\n    'thread',\n    'tuple',\n    'typeindex',\n    'typeinfo',\n    'type_traits',\n    'unordered_map',\n    'unordered_set',\n    'utility',\n    'valarray',\n    'vector',\n    # 17.6.1.2 C++14 headers\n    'shared_mutex',\n    # 17.6.1.2 C++17 headers\n    'any',\n    'charconv',\n    'codecvt',\n    'execution',\n    'filesystem',\n    'memory_resource',\n    'optional',\n    'string_view',\n    'variant',\n    # 17.6.1.2 C++ headers for C library facilities\n    'cassert',\n    'ccomplex',\n    'cctype',\n    'cerrno',\n    'cfenv',\n    'cfloat',\n    'cinttypes',\n    'ciso646',\n    'climits',\n    'clocale',\n    'cmath',\n    'csetjmp',\n    'csignal',\n    'cstdalign',\n    'cstdarg',\n    'cstdbool',\n    'cstddef',\n    'cstdint',\n    'cstdio',\n    'cstdlib',\n    'cstring',\n    'ctgmath',\n    'ctime',\n    'cuchar',\n    'cwchar',\n    'cwctype',\n    ])\n\n# Type names\n_TYPES = re.compile(\n    r'^(?:'\n    # [dcl.type.simple]\n    r'(char(16_t|32_t)?)|wchar_t|'\n    r'bool|short|int|long|signed|unsigned|float|double|'\n    # [support.types]\n    r'(ptrdiff_t|size_t|max_align_t|nullptr_t)|'\n    # [cstdint.syn]\n    r'(u?int(_fast|_least)?(8|16|32|64)_t)|'\n    r'(u?int(max|ptr)_t)|'\n    r')$')\n\n\n# These headers are excluded from [build/include] and [build/include_order]\n# checks:\n# - Anything not following google file name conventions (containing an\n#   uppercase character, such as Python.h or nsStringAPI.h, for example).\n# - Lua headers.\n_THIRD_PARTY_HEADERS_PATTERN = re.compile(\n    r'^(?:[^/]*[A-Z][^/]*\\.h|lua\\.h|lauxlib\\.h|lualib\\.h)$')\n\n# Pattern for matching FileInfo.BaseName() against test file name\n_test_suffixes = ['_test', '_regtest', '_unittest']\n_TEST_FILE_SUFFIX = '(' + '|'.join(_test_suffixes) + r')$'\n\n# Pattern that matches only complete whitespace, possibly across multiple lines.\n_EMPTY_CONDITIONAL_BODY_PATTERN = re.compile(r'^\\s*$', re.DOTALL)\n\n# Assertion macros.  These are defined in base/logging.h and\n# testing/base/public/gunit.h.\n_CHECK_MACROS = [\n    'DCHECK', 'CHECK',\n    'EXPECT_TRUE', 'ASSERT_TRUE',\n    'EXPECT_FALSE', 'ASSERT_FALSE',\n    ]\n\n# Replacement macros for CHECK/DCHECK/EXPECT_TRUE/EXPECT_FALSE\n_CHECK_REPLACEMENT = dict([(macro_var, {}) for macro_var in _CHECK_MACROS])\n\nfor op, replacement in [('==', 'EQ'), ('!=', 'NE'),\n                        ('>=', 'GE'), ('>', 'GT'),\n                        ('<=', 'LE'), ('<', 'LT')]:\n  _CHECK_REPLACEMENT['DCHECK'][op] = 'DCHECK_%s' % replacement\n  _CHECK_REPLACEMENT['CHECK'][op] = 'CHECK_%s' % replacement\n  _CHECK_REPLACEMENT['EXPECT_TRUE'][op] = 'EXPECT_%s' % replacement\n  _CHECK_REPLACEMENT['ASSERT_TRUE'][op] = 'ASSERT_%s' % replacement\n\nfor op, inv_replacement in [('==', 'NE'), ('!=', 'EQ'),\n                            ('>=', 'LT'), ('>', 'LE'),\n                            ('<=', 'GT'), ('<', 'GE')]:\n  _CHECK_REPLACEMENT['EXPECT_FALSE'][op] = 'EXPECT_%s' % inv_replacement\n  _CHECK_REPLACEMENT['ASSERT_FALSE'][op] = 'ASSERT_%s' % inv_replacement\n\n# Alternative tokens and their replacements.  For full list, see section 2.5\n# Alternative tokens [lex.digraph] in the C++ standard.\n#\n# Digraphs (such as '%:') are not included here since it's a mess to\n# match those on a word boundary.\n_ALT_TOKEN_REPLACEMENT = {\n    'and': '&&',\n    'bitor': '|',\n    'or': '||',\n    'xor': '^',\n    'compl': '~',\n    'bitand': '&',\n    'and_eq': '&=',\n    'or_eq': '|=',\n    'xor_eq': '^=',\n    'not': '!',\n    'not_eq': '!='\n    }\n\n# Compile regular expression that matches all the above keywords.  The \"[ =()]\"\n# bit is meant to avoid matching these keywords outside of boolean expressions.\n#\n# False positives include C-style multi-line comments and multi-line strings\n# but those have always been troublesome for cpplint.\n_ALT_TOKEN_REPLACEMENT_PATTERN = re.compile(\n    r'[ =()](' + ('|'.join(_ALT_TOKEN_REPLACEMENT.keys())) + r')(?=[ (]|$)')\n\n\n# These constants define types of headers for use with\n# _IncludeState.CheckNextIncludeOrder().\n_C_SYS_HEADER = 1\n_CPP_SYS_HEADER = 2\n_LIKELY_MY_HEADER = 3\n_POSSIBLE_MY_HEADER = 4\n_OTHER_HEADER = 5\n\n# These constants define the current inline assembly state\n_NO_ASM = 0       # Outside of inline assembly block\n_INSIDE_ASM = 1   # Inside inline assembly block\n_END_ASM = 2      # Last line of inline assembly block\n_BLOCK_ASM = 3    # The whole block is an inline assembly block\n\n# Match start of assembly blocks\n_MATCH_ASM = re.compile(r'^\\s*(?:asm|_asm|__asm|__asm__)'\n                        r'(?:\\s+(volatile|__volatile__))?'\n                        r'\\s*[{(]')\n\n# Match strings that indicate we're working on a C (not C++) file.\n_SEARCH_C_FILE = re.compile(r'\\b(?:LINT_C_FILE|'\n                            r'vim?:\\s*.*(\\s*|:)filetype=c(\\s*|:|$))')\n\n# Match string that indicates we're working on a Linux Kernel file.\n_SEARCH_KERNEL_FILE = re.compile(r'\\b(?:LINT_KERNEL_FILE)')\n\n_regexp_compile_cache = {}\n\n# {str, set(int)}: a map from error categories to sets of linenumbers\n# on which those errors are expected and should be suppressed.\n_error_suppressions = {}\n\n# The root directory used for deriving header guard CPP variable.\n# This is set by --root flag.\n_root = None\n_root_debug = False\n\n# The top level repository directory. If set, _root is calculated relative to\n# this directory instead of the directory containing version control artifacts.\n# This is set by the --repository flag.\n_repository = None\n\n# Files to exclude from linting. This is set by the --exclude flag.\n_excludes = None\n\n# Whether to supress PrintInfo messages\n_quiet = False\n\n# The allowed line length of files.\n# This is set by --linelength flag.\n_line_length = 80\n\ntry:\n  unicode\nexcept NameError:\n  #  -- pylint: disable=redefined-builtin\n  basestring = unicode = str\n\ntry:\n  long\nexcept NameError:\n  #  -- pylint: disable=redefined-builtin\n  long = int\n\nif sys.version_info < (3,):\n  #  -- pylint: disable=no-member\n  # BINARY_TYPE = str\n  itervalues = dict.itervalues\n  iteritems = dict.iteritems\nelse:\n  # BINARY_TYPE = bytes\n  itervalues = dict.values\n  iteritems = dict.items\n\ndef unicode_escape_decode(x):\n  if sys.version_info < (3,):\n    return codecs.unicode_escape_decode(x)[0]\n  else:\n    return x\n\n# Treat all headers starting with 'h' equally: .h, .hpp, .hxx etc.\n# This is set by --headers flag.\n_hpp_headers = set([])\n\n# {str, bool}: a map from error categories to booleans which indicate if the\n# category should be suppressed for every line.\n_global_error_suppressions = {}\n\ndef ProcessHppHeadersOption(val):\n  global _hpp_headers\n  try:\n    _hpp_headers = {ext.strip() for ext in val.split(',')}\n  except ValueError:\n    PrintUsage('Header extensions must be comma separated list.')\n\ndef IsHeaderExtension(file_extension):\n  return file_extension in GetHeaderExtensions()\n\ndef GetHeaderExtensions():\n  if _hpp_headers:\n    return _hpp_headers\n  if _valid_extensions:\n    return {h for h in _valid_extensions if 'h' in h}\n  return set(['h', 'hh', 'hpp', 'hxx', 'h++', 'cuh'])\n\n# The allowed extensions for file names\n# This is set by --extensions flag\ndef GetAllExtensions():\n  return GetHeaderExtensions().union(_valid_extensions or set(\n    ['c', 'cc', 'cpp', 'cxx', 'c++', 'cu']))\n\ndef ProcessExtensionsOption(val):\n  global _valid_extensions\n  try:\n    extensions = [ext.strip() for ext in val.split(',')]\n    _valid_extensions = set(extensions)\n  except ValueError:\n    PrintUsage('Extensions should be a comma-separated list of values;'\n               'for example: extensions=hpp,cpp\\n'\n               'This could not be parsed: \"%s\"' % (val,))\n\ndef GetNonHeaderExtensions():\n  return GetAllExtensions().difference(GetHeaderExtensions())\n\ndef ParseNolintSuppressions(filename, raw_line, linenum, error):\n  \"\"\"Updates the global list of line error-suppressions.\n\n  Parses any NOLINT comments on the current line, updating the global\n  error_suppressions store.  Reports an error if the NOLINT comment\n  was malformed.\n\n  Args:\n    filename: str, the name of the input file.\n    raw_line: str, the line of input text, with comments.\n    linenum: int, the number of the current line.\n    error: function, an error handler.\n  \"\"\"\n  matched = Search(r'\\bNOLINT(NEXTLINE)?\\b(\\([^)]+\\))?', raw_line)\n  if matched:\n    if matched.group(1):\n      suppressed_line = linenum + 1\n    else:\n      suppressed_line = linenum\n    category = matched.group(2)\n    if category in (None, '(*)'):  # => \"suppress all\"\n      _error_suppressions.setdefault(None, set()).add(suppressed_line)\n    else:\n      if category.startswith('(') and category.endswith(')'):\n        category = category[1:-1]\n        if category in _ERROR_CATEGORIES:\n          _error_suppressions.setdefault(category, set()).add(suppressed_line)\n        elif category not in _LEGACY_ERROR_CATEGORIES:\n          error(filename, linenum, 'readability/nolint', 5,\n                'Unknown NOLINT error category: %s' % category)\n\n\ndef ProcessGlobalSuppresions(lines):\n  \"\"\"Updates the list of global error suppressions.\n\n  Parses any lint directives in the file that have global effect.\n\n  Args:\n    lines: An array of strings, each representing a line of the file, with the\n           last element being empty if the file is terminated with a newline.\n  \"\"\"\n  for line in lines:\n    if _SEARCH_C_FILE.search(line):\n      for category in _DEFAULT_C_SUPPRESSED_CATEGORIES:\n        _global_error_suppressions[category] = True\n    if _SEARCH_KERNEL_FILE.search(line):\n      for category in _DEFAULT_KERNEL_SUPPRESSED_CATEGORIES:\n        _global_error_suppressions[category] = True\n\n\ndef ResetNolintSuppressions():\n  \"\"\"Resets the set of NOLINT suppressions to empty.\"\"\"\n  _error_suppressions.clear()\n  _global_error_suppressions.clear()\n\n\ndef IsErrorSuppressedByNolint(category, linenum):\n  \"\"\"Returns true if the specified error category is suppressed on this line.\n\n  Consults the global error_suppressions map populated by\n  ParseNolintSuppressions/ProcessGlobalSuppresions/ResetNolintSuppressions.\n\n  Args:\n    category: str, the category of the error.\n    linenum: int, the current line number.\n  Returns:\n    bool, True iff the error should be suppressed due to a NOLINT comment or\n    global suppression.\n  \"\"\"\n  return (_global_error_suppressions.get(category, False) or\n          linenum in _error_suppressions.get(category, set()) or\n          linenum in _error_suppressions.get(None, set()))\n\n\ndef Match(pattern, s):\n  \"\"\"Matches the string with the pattern, caching the compiled regexp.\"\"\"\n  # The regexp compilation caching is inlined in both Match and Search for\n  # performance reasons; factoring it out into a separate function turns out\n  # to be noticeably expensive.\n  if pattern not in _regexp_compile_cache:\n    _regexp_compile_cache[pattern] = sre_compile.compile(pattern)\n  return _regexp_compile_cache[pattern].match(s)\n\n\ndef ReplaceAll(pattern, rep, s):\n  \"\"\"Replaces instances of pattern in a string with a replacement.\n\n  The compiled regex is kept in a cache shared by Match and Search.\n\n  Args:\n    pattern: regex pattern\n    rep: replacement text\n    s: search string\n\n  Returns:\n    string with replacements made (or original string if no replacements)\n  \"\"\"\n  if pattern not in _regexp_compile_cache:\n    _regexp_compile_cache[pattern] = sre_compile.compile(pattern)\n  return _regexp_compile_cache[pattern].sub(rep, s)\n\n\ndef Search(pattern, s):\n  \"\"\"Searches the string for the pattern, caching the compiled regexp.\"\"\"\n  if pattern not in _regexp_compile_cache:\n    _regexp_compile_cache[pattern] = sre_compile.compile(pattern)\n  return _regexp_compile_cache[pattern].search(s)\n\n\ndef _IsSourceExtension(s):\n  \"\"\"File extension (excluding dot) matches a source file extension.\"\"\"\n  return s in GetNonHeaderExtensions()\n\n\nclass _IncludeState(object):\n  \"\"\"Tracks line numbers for includes, and the order in which includes appear.\n\n  include_list contains list of lists of (header, line number) pairs.\n  It's a lists of lists rather than just one flat list to make it\n  easier to update across preprocessor boundaries.\n\n  Call CheckNextIncludeOrder() once for each header in the file, passing\n  in the type constants defined above. Calls in an illegal order will\n  raise an _IncludeError with an appropriate error message.\n\n  \"\"\"\n  # self._section will move monotonically through this set. If it ever\n  # needs to move backwards, CheckNextIncludeOrder will raise an error.\n  _INITIAL_SECTION = 0\n  _MY_H_SECTION = 1\n  _C_SECTION = 2\n  _CPP_SECTION = 3\n  _OTHER_H_SECTION = 4\n\n  _TYPE_NAMES = {\n      _C_SYS_HEADER: 'C system header',\n      _CPP_SYS_HEADER: 'C++ system header',\n      _LIKELY_MY_HEADER: 'header this file implements',\n      _POSSIBLE_MY_HEADER: 'header this file may implement',\n      _OTHER_HEADER: 'other header',\n      }\n  _SECTION_NAMES = {\n      _INITIAL_SECTION: \"... nothing. (This can't be an error.)\",\n      _MY_H_SECTION: 'a header this file implements',\n      _C_SECTION: 'C system header',\n      _CPP_SECTION: 'C++ system header',\n      _OTHER_H_SECTION: 'other header',\n      }\n\n  def __init__(self):\n    self.include_list = [[]]\n    self._section = None\n    self._last_header = None\n    self.ResetSection('')\n\n  def FindHeader(self, header):\n    \"\"\"Check if a header has already been included.\n\n    Args:\n      header: header to check.\n    Returns:\n      Line number of previous occurrence, or -1 if the header has not\n      been seen before.\n    \"\"\"\n    for section_list in self.include_list:\n      for f in section_list:\n        if f[0] == header:\n          return f[1]\n    return -1\n\n  def ResetSection(self, directive):\n    \"\"\"Reset section checking for preprocessor directive.\n\n    Args:\n      directive: preprocessor directive (e.g. \"if\", \"else\").\n    \"\"\"\n    # The name of the current section.\n    self._section = self._INITIAL_SECTION\n    # The path of last found header.\n    self._last_header = ''\n\n    # Update list of includes.  Note that we never pop from the\n    # include list.\n    if directive in ('if', 'ifdef', 'ifndef'):\n      self.include_list.append([])\n    elif directive in ('else', 'elif'):\n      self.include_list[-1] = []\n\n  def SetLastHeader(self, header_path):\n    self._last_header = header_path\n\n  def CanonicalizeAlphabeticalOrder(self, header_path):\n    \"\"\"Returns a path canonicalized for alphabetical comparison.\n\n    - replaces \"-\" with \"_\" so they both cmp the same.\n    - removes '-inl' since we don't require them to be after the main header.\n    - lowercase everything, just in case.\n\n    Args:\n      header_path: Path to be canonicalized.\n\n    Returns:\n      Canonicalized path.\n    \"\"\"\n    return header_path.replace('-inl.h', '.h').replace('-', '_').lower()\n\n  def IsInAlphabeticalOrder(self, clean_lines, linenum, header_path):\n    \"\"\"Check if a header is in alphabetical order with the previous header.\n\n    Args:\n      clean_lines: A CleansedLines instance containing the file.\n      linenum: The number of the line to check.\n      header_path: Canonicalized header to be checked.\n\n    Returns:\n      Returns true if the header is in alphabetical order.\n    \"\"\"\n    # If previous section is different from current section, _last_header will\n    # be reset to empty string, so it's always less than current header.\n    #\n    # If previous line was a blank line, assume that the headers are\n    # intentionally sorted the way they are.\n    if (self._last_header > header_path and\n        Match(r'^\\s*#\\s*include\\b', clean_lines.elided[linenum - 1])):\n      return False\n    return True\n\n  def CheckNextIncludeOrder(self, header_type):\n    \"\"\"Returns a non-empty error message if the next header is out of order.\n\n    This function also updates the internal state to be ready to check\n    the next include.\n\n    Args:\n      header_type: One of the _XXX_HEADER constants defined above.\n\n    Returns:\n      The empty string if the header is in the right order, or an\n      error message describing what's wrong.\n\n    \"\"\"\n    error_message = ('Found %s after %s' %\n                     (self._TYPE_NAMES[header_type],\n                      self._SECTION_NAMES[self._section]))\n\n    last_section = self._section\n\n    if header_type == _C_SYS_HEADER:\n      if self._section <= self._C_SECTION:\n        self._section = self._C_SECTION\n      else:\n        self._last_header = ''\n        return error_message\n    elif header_type == _CPP_SYS_HEADER:\n      if self._section <= self._CPP_SECTION:\n        self._section = self._CPP_SECTION\n      else:\n        self._last_header = ''\n        return error_message\n    elif header_type == _LIKELY_MY_HEADER:\n      if self._section <= self._MY_H_SECTION:\n        self._section = self._MY_H_SECTION\n      else:\n        self._section = self._OTHER_H_SECTION\n    elif header_type == _POSSIBLE_MY_HEADER:\n      if self._section <= self._MY_H_SECTION:\n        self._section = self._MY_H_SECTION\n      else:\n        # This will always be the fallback because we're not sure\n        # enough that the header is associated with this file.\n        self._section = self._OTHER_H_SECTION\n    else:\n      assert header_type == _OTHER_HEADER\n      self._section = self._OTHER_H_SECTION\n\n    if last_section != self._section:\n      self._last_header = ''\n\n    return ''\n\n\nclass _CppLintState(object):\n  \"\"\"Maintains module-wide state..\"\"\"\n\n  def __init__(self):\n    self.verbose_level = 1  # global setting.\n    self.error_count = 0    # global count of reported errors\n    # filters to apply when emitting error messages\n    self.filters = _DEFAULT_FILTERS[:]\n    # backup of filter list. Used to restore the state after each file.\n    self._filters_backup = self.filters[:]\n    self.counting = 'total'  # In what way are we counting errors?\n    self.errors_by_category = {}  # string to int dict storing error counts\n    self.quiet = False  # Suppress non-error messagess?\n\n    # output format:\n    # \"emacs\" - format that emacs can parse (default)\n    # \"eclipse\" - format that eclipse can parse\n    # \"vs7\" - format that Microsoft Visual Studio 7 can parse\n    # \"junit\" - format that Jenkins, Bamboo, etc can parse\n    self.output_format = 'emacs'\n\n    # For JUnit output, save errors and failures until the end so that they\n    # can be written into the XML\n    self._junit_errors = []\n    self._junit_failures = []\n\n  def SetOutputFormat(self, output_format):\n    \"\"\"Sets the output format for errors.\"\"\"\n    self.output_format = output_format\n\n  def SetQuiet(self, quiet):\n    \"\"\"Sets the module's quiet settings, and returns the previous setting.\"\"\"\n    last_quiet = self.quiet\n    self.quiet = quiet\n    return last_quiet\n\n  def SetVerboseLevel(self, level):\n    \"\"\"Sets the module's verbosity, and returns the previous setting.\"\"\"\n    last_verbose_level = self.verbose_level\n    self.verbose_level = level\n    return last_verbose_level\n\n  def SetCountingStyle(self, counting_style):\n    \"\"\"Sets the module's counting options.\"\"\"\n    self.counting = counting_style\n\n  def SetFilters(self, filters):\n    \"\"\"Sets the error-message filters.\n\n    These filters are applied when deciding whether to emit a given\n    error message.\n\n    Args:\n      filters: A string of comma-separated filters (eg \"+whitespace/indent\").\n               Each filter should start with + or -; else we die.\n\n    Raises:\n      ValueError: The comma-separated filters did not all start with '+' or '-'.\n                  E.g. \"-,+whitespace,-whitespace/indent,whitespace/badfilter\"\n    \"\"\"\n    # Default filters always have less priority than the flag ones.\n    self.filters = _DEFAULT_FILTERS[:]\n    self.AddFilters(filters)\n\n  def AddFilters(self, filters):\n    \"\"\" Adds more filters to the existing list of error-message filters. \"\"\"\n    for filt in filters.split(','):\n      clean_filt = filt.strip()\n      if clean_filt:\n        self.filters.append(clean_filt)\n    for filt in self.filters:\n      if not (filt.startswith('+') or filt.startswith('-')):\n        raise ValueError('Every filter in --filters must start with + or -'\n                         ' (%s does not)' % filt)\n\n  def BackupFilters(self):\n    \"\"\" Saves the current filter list to backup storage.\"\"\"\n    self._filters_backup = self.filters[:]\n\n  def RestoreFilters(self):\n    \"\"\" Restores filters previously backed up.\"\"\"\n    self.filters = self._filters_backup[:]\n\n  def ResetErrorCounts(self):\n    \"\"\"Sets the module's error statistic back to zero.\"\"\"\n    self.error_count = 0\n    self.errors_by_category = {}\n\n  def IncrementErrorCount(self, category):\n    \"\"\"Bumps the module's error statistic.\"\"\"\n    self.error_count += 1\n    if self.counting in ('toplevel', 'detailed'):\n      if self.counting != 'detailed':\n        category = category.split('/')[0]\n      if category not in self.errors_by_category:\n        self.errors_by_category[category] = 0\n      self.errors_by_category[category] += 1\n\n  def PrintErrorCounts(self):\n    \"\"\"Print a summary of errors by category, and the total.\"\"\"\n    for category, count in sorted(iteritems(self.errors_by_category)):\n      self.PrintInfo('Category \\'%s\\' errors found: %d\\n' %\n                       (category, count))\n    if self.error_count > 0:\n      self.PrintInfo('Total errors found: %d\\n' % self.error_count)\n\n  def PrintInfo(self, message):\n    if not _quiet and self.output_format != 'junit':\n      sys.stdout.write(message)\n\n  def PrintError(self, message):\n    if self.output_format == 'junit':\n      self._junit_errors.append(message)\n    else:\n      sys.stderr.write(message)\n\n  def AddJUnitFailure(self, filename, linenum, message, category, confidence):\n    self._junit_failures.append((filename, linenum, message, category,\n        confidence))\n\n  def FormatJUnitXML(self):\n    num_errors = len(self._junit_errors)\n    num_failures = len(self._junit_failures)\n\n    testsuite = xml.etree.ElementTree.Element('testsuite')\n    testsuite.attrib['errors'] = str(num_errors)\n    testsuite.attrib['failures'] = str(num_failures)\n    testsuite.attrib['name'] = 'cpplint'\n\n    if num_errors == 0 and num_failures == 0:\n      testsuite.attrib['tests'] = str(1)\n      xml.etree.ElementTree.SubElement(testsuite, 'testcase', name='passed')\n\n    else:\n      testsuite.attrib['tests'] = str(num_errors + num_failures)\n      if num_errors > 0:\n        testcase = xml.etree.ElementTree.SubElement(testsuite, 'testcase')\n        testcase.attrib['name'] = 'errors'\n        error = xml.etree.ElementTree.SubElement(testcase, 'error')\n        error.text = '\\n'.join(self._junit_errors)\n      if num_failures > 0:\n        # Group failures by file\n        failed_file_order = []\n        failures_by_file = {}\n        for failure in self._junit_failures:\n          failed_file = failure[0]\n          if failed_file not in failed_file_order:\n            failed_file_order.append(failed_file)\n            failures_by_file[failed_file] = []\n          failures_by_file[failed_file].append(failure)\n        # Create a testcase for each file\n        for failed_file in failed_file_order:\n          failures = failures_by_file[failed_file]\n          testcase = xml.etree.ElementTree.SubElement(testsuite, 'testcase')\n          testcase.attrib['name'] = failed_file\n          failure = xml.etree.ElementTree.SubElement(testcase, 'failure')\n          template = '{0}: {1} [{2}] [{3}]'\n          texts = [template.format(f[1], f[2], f[3], f[4]) for f in failures]\n          failure.text = '\\n'.join(texts)\n\n    xml_decl = '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'\n    return xml_decl + xml.etree.ElementTree.tostring(testsuite, 'utf-8').decode('utf-8')\n\n\n_cpplint_state = _CppLintState()\n\n\ndef _OutputFormat():\n  \"\"\"Gets the module's output format.\"\"\"\n  return _cpplint_state.output_format\n\n\ndef _SetOutputFormat(output_format):\n  \"\"\"Sets the module's output format.\"\"\"\n  _cpplint_state.SetOutputFormat(output_format)\n\ndef _Quiet():\n  \"\"\"Return's the module's quiet setting.\"\"\"\n  return _cpplint_state.quiet\n\ndef _SetQuiet(quiet):\n  \"\"\"Set the module's quiet status, and return previous setting.\"\"\"\n  return _cpplint_state.SetQuiet(quiet)\n\n\ndef _VerboseLevel():\n  \"\"\"Returns the module's verbosity setting.\"\"\"\n  return _cpplint_state.verbose_level\n\n\ndef _SetVerboseLevel(level):\n  \"\"\"Sets the module's verbosity, and returns the previous setting.\"\"\"\n  return _cpplint_state.SetVerboseLevel(level)\n\n\ndef _SetCountingStyle(level):\n  \"\"\"Sets the module's counting options.\"\"\"\n  _cpplint_state.SetCountingStyle(level)\n\n\ndef _Filters():\n  \"\"\"Returns the module's list of output filters, as a list.\"\"\"\n  return _cpplint_state.filters\n\n\ndef _SetFilters(filters):\n  \"\"\"Sets the module's error-message filters.\n\n  These filters are applied when deciding whether to emit a given\n  error message.\n\n  Args:\n    filters: A string of comma-separated filters (eg \"whitespace/indent\").\n             Each filter should start with + or -; else we die.\n  \"\"\"\n  _cpplint_state.SetFilters(filters)\n\ndef _AddFilters(filters):\n  \"\"\"Adds more filter overrides.\n\n  Unlike _SetFilters, this function does not reset the current list of filters\n  available.\n\n  Args:\n    filters: A string of comma-separated filters (eg \"whitespace/indent\").\n             Each filter should start with + or -; else we die.\n  \"\"\"\n  _cpplint_state.AddFilters(filters)\n\ndef _BackupFilters():\n  \"\"\" Saves the current filter list to backup storage.\"\"\"\n  _cpplint_state.BackupFilters()\n\ndef _RestoreFilters():\n  \"\"\" Restores filters previously backed up.\"\"\"\n  _cpplint_state.RestoreFilters()\n\nclass _FunctionState(object):\n  \"\"\"Tracks current function name and the number of lines in its body.\"\"\"\n\n  _NORMAL_TRIGGER = 250  # for --v=0, 500 for --v=1, etc.\n  _TEST_TRIGGER = 400    # about 50% more than _NORMAL_TRIGGER.\n\n  def __init__(self):\n    self.in_a_function = False\n    self.lines_in_function = 0\n    self.current_function = ''\n\n  def Begin(self, function_name):\n    \"\"\"Start analyzing function body.\n\n    Args:\n      function_name: The name of the function being tracked.\n    \"\"\"\n    self.in_a_function = True\n    self.lines_in_function = 0\n    self.current_function = function_name\n\n  def Count(self):\n    \"\"\"Count line in current function body.\"\"\"\n    if self.in_a_function:\n      self.lines_in_function += 1\n\n  def Check(self, error, filename, linenum):\n    \"\"\"Report if too many lines in function body.\n\n    Args:\n      error: The function to call with any errors found.\n      filename: The name of the current file.\n      linenum: The number of the line to check.\n    \"\"\"\n    if not self.in_a_function:\n      return\n\n    if Match(r'T(EST|est)', self.current_function):\n      base_trigger = self._TEST_TRIGGER\n    else:\n      base_trigger = self._NORMAL_TRIGGER\n    trigger = base_trigger * 2**_VerboseLevel()\n\n    if self.lines_in_function > trigger:\n      error_level = int(math.log(self.lines_in_function / base_trigger, 2))\n      # 50 => 0, 100 => 1, 200 => 2, 400 => 3, 800 => 4, 1600 => 5, ...\n      if error_level > 5:\n        error_level = 5\n      error(filename, linenum, 'readability/fn_size', error_level,\n            'Small and focused functions are preferred:'\n            ' %s has %d non-comment lines'\n            ' (error triggered by exceeding %d lines).'  % (\n                self.current_function, self.lines_in_function, trigger))\n\n  def End(self):\n    \"\"\"Stop analyzing function body.\"\"\"\n    self.in_a_function = False\n\n\nclass _IncludeError(Exception):\n  \"\"\"Indicates a problem with the include order in a file.\"\"\"\n  pass\n\n\nclass FileInfo(object):\n  \"\"\"Provides utility functions for filenames.\n\n  FileInfo provides easy access to the components of a file's path\n  relative to the project root.\n  \"\"\"\n\n  def __init__(self, filename):\n    self._filename = filename\n\n  def FullName(self):\n    \"\"\"Make Windows paths like Unix.\"\"\"\n    return os.path.abspath(self._filename).replace('\\\\', '/')\n\n  def RepositoryName(self):\n    r\"\"\"FullName after removing the local path to the repository.\n\n    If we have a real absolute path name here we can try to do something smart:\n    detecting the root of the checkout and truncating /path/to/checkout from\n    the name so that we get header guards that don't include things like\n    \"C:\\\\Documents and Settings\\\\...\" or \"/home/username/...\" in them and thus\n    people on different computers who have checked the source out to different\n    locations won't see bogus errors.\n    \"\"\"\n    fullname = self.FullName()\n\n    if os.path.exists(fullname):\n      project_dir = os.path.dirname(fullname)\n\n      # If the user specified a repository path, it exists, and the file is\n      # contained in it, use the specified repository path\n      if _repository:\n        repo = FileInfo(_repository).FullName()\n        root_dir = project_dir\n        while os.path.exists(root_dir):\n          # allow case insensitive compare on Windows\n          if os.path.normcase(root_dir) == os.path.normcase(repo):\n            return os.path.relpath(fullname, root_dir).replace('\\\\', '/')\n          one_up_dir = os.path.dirname(root_dir)\n          if one_up_dir == root_dir:\n            break\n          root_dir = one_up_dir\n\n      if os.path.exists(os.path.join(project_dir, \".svn\")):\n        # If there's a .svn file in the current directory, we recursively look\n        # up the directory tree for the top of the SVN checkout\n        root_dir = project_dir\n        one_up_dir = os.path.dirname(root_dir)\n        while os.path.exists(os.path.join(one_up_dir, \".svn\")):\n          root_dir = os.path.dirname(root_dir)\n          one_up_dir = os.path.dirname(one_up_dir)\n\n        prefix = os.path.commonprefix([root_dir, project_dir])\n        return fullname[len(prefix) + 1:]\n\n      # Not SVN <= 1.6? Try to find a git, hg, or svn top level directory by\n      # searching up from the current path.\n      root_dir = current_dir = os.path.dirname(fullname)\n      while current_dir != os.path.dirname(current_dir):\n        if (os.path.exists(os.path.join(current_dir, \".git\")) or\n            os.path.exists(os.path.join(current_dir, \".hg\")) or\n            os.path.exists(os.path.join(current_dir, \".svn\"))):\n          root_dir = current_dir\n        current_dir = os.path.dirname(current_dir)\n\n      if (os.path.exists(os.path.join(root_dir, \".git\")) or\n          os.path.exists(os.path.join(root_dir, \".hg\")) or\n          os.path.exists(os.path.join(root_dir, \".svn\"))):\n        prefix = os.path.commonprefix([root_dir, project_dir])\n        return fullname[len(prefix) + 1:]\n\n    # Don't know what to do; header guard warnings may be wrong...\n    return fullname\n\n  def Split(self):\n    \"\"\"Splits the file into the directory, basename, and extension.\n\n    For 'chrome/browser/browser.cc', Split() would\n    return ('chrome/browser', 'browser', '.cc')\n\n    Returns:\n      A tuple of (directory, basename, extension).\n    \"\"\"\n\n    googlename = self.RepositoryName()\n    project, rest = os.path.split(googlename)\n    return (project,) + os.path.splitext(rest)\n\n  def BaseName(self):\n    \"\"\"File base name - text after the final slash, before the final period.\"\"\"\n    return self.Split()[1]\n\n  def Extension(self):\n    \"\"\"File extension - text following the final period, includes that period.\"\"\"\n    return self.Split()[2]\n\n  def NoExtension(self):\n    \"\"\"File has no source file extension.\"\"\"\n    return '/'.join(self.Split()[0:2])\n\n  def IsSource(self):\n    \"\"\"File has a source file extension.\"\"\"\n    return _IsSourceExtension(self.Extension()[1:])\n\n\ndef _ShouldPrintError(category, confidence, linenum):\n  \"\"\"If confidence >= verbose, category passes filter and is not suppressed.\"\"\"\n\n  # There are three ways we might decide not to print an error message:\n  # a \"NOLINT(category)\" comment appears in the source,\n  # the verbosity level isn't high enough, or the filters filter it out.\n  if IsErrorSuppressedByNolint(category, linenum):\n    return False\n\n  if confidence < _cpplint_state.verbose_level:\n    return False\n\n  is_filtered = False\n  for one_filter in _Filters():\n    if one_filter.startswith('-'):\n      if category.startswith(one_filter[1:]):\n        is_filtered = True\n    elif one_filter.startswith('+'):\n      if category.startswith(one_filter[1:]):\n        is_filtered = False\n    else:\n      assert False  # should have been checked for in SetFilter.\n  if is_filtered:\n    return False\n\n  return True\n\n\ndef Error(filename, linenum, category, confidence, message):\n  \"\"\"Logs the fact we've found a lint error.\n\n  We log where the error was found, and also our confidence in the error,\n  that is, how certain we are this is a legitimate style regression, and\n  not a misidentification or a use that's sometimes justified.\n\n  False positives can be suppressed by the use of\n  \"cpplint(category)\"  comments on the offending line.  These are\n  parsed into _error_suppressions.\n\n  Args:\n    filename: The name of the file containing the error.\n    linenum: The number of the line containing the error.\n    category: A string used to describe the \"category\" this bug\n      falls under: \"whitespace\", say, or \"runtime\".  Categories\n      may have a hierarchy separated by slashes: \"whitespace/indent\".\n    confidence: A number from 1-5 representing a confidence score for\n      the error, with 5 meaning that we are certain of the problem,\n      and 1 meaning that it could be a legitimate construct.\n    message: The error message.\n  \"\"\"\n  if _ShouldPrintError(category, confidence, linenum):\n    _cpplint_state.IncrementErrorCount(category)\n    if _cpplint_state.output_format == 'vs7':\n      _cpplint_state.PrintError('%s(%s): error cpplint: [%s] %s [%d]\\n' % (\n          filename, linenum, category, message, confidence))\n    elif _cpplint_state.output_format == 'eclipse':\n      sys.stderr.write('%s:%s: warning: %s  [%s] [%d]\\n' % (\n          filename, linenum, message, category, confidence))\n    elif _cpplint_state.output_format == 'junit':\n      _cpplint_state.AddJUnitFailure(filename, linenum, message, category,\n          confidence)\n    else:\n      final_message = '%s:%s:  %s  [%s] [%d]\\n' % (\n          filename, linenum, message, category, confidence)\n      sys.stderr.write(final_message)\n\n# Matches standard C++ escape sequences per 2.13.2.3 of the C++ standard.\n_RE_PATTERN_CLEANSE_LINE_ESCAPES = re.compile(\n    r'\\\\([abfnrtv?\"\\\\\\']|\\d+|x[0-9a-fA-F]+)')\n# Match a single C style comment on the same line.\n_RE_PATTERN_C_COMMENTS = r'/\\*(?:[^*]|\\*(?!/))*\\*/'\n# Matches multi-line C style comments.\n# This RE is a little bit more complicated than one might expect, because we\n# have to take care of space removals tools so we can handle comments inside\n# statements better.\n# The current rule is: We only clear spaces from both sides when we're at the\n# end of the line. Otherwise, we try to remove spaces from the right side,\n# if this doesn't work we try on left side but only if there's a non-character\n# on the right.\n_RE_PATTERN_CLEANSE_LINE_C_COMMENTS = re.compile(\n    r'(\\s*' + _RE_PATTERN_C_COMMENTS + r'\\s*$|' +\n    _RE_PATTERN_C_COMMENTS + r'\\s+|' +\n    r'\\s+' + _RE_PATTERN_C_COMMENTS + r'(?=\\W)|' +\n    _RE_PATTERN_C_COMMENTS + r')')\n\n\ndef IsCppString(line):\n  \"\"\"Does line terminate so, that the next symbol is in string constant.\n\n  This function does not consider single-line nor multi-line comments.\n\n  Args:\n    line: is a partial line of code starting from the 0..n.\n\n  Returns:\n    True, if next character appended to 'line' is inside a\n    string constant.\n  \"\"\"\n\n  line = line.replace(r'\\\\', 'XX')  # after this, \\\\\" does not match to \\\"\n  return ((line.count('\"') - line.count(r'\\\"') - line.count(\"'\\\"'\")) & 1) == 1\n\n\ndef CleanseRawStrings(raw_lines):\n  \"\"\"Removes C++11 raw strings from lines.\n\n    Before:\n      static const char kData[] = R\"(\n          multi-line string\n          )\";\n\n    After:\n      static const char kData[] = \"\"\n          (replaced by blank line)\n          \"\";\n\n  Args:\n    raw_lines: list of raw lines.\n\n  Returns:\n    list of lines with C++11 raw strings replaced by empty strings.\n  \"\"\"\n\n  delimiter = None\n  lines_without_raw_strings = []\n  for line in raw_lines:\n    if delimiter:\n      # Inside a raw string, look for the end\n      end = line.find(delimiter)\n      if end >= 0:\n        # Found the end of the string, match leading space for this\n        # line and resume copying the original lines, and also insert\n        # a \"\" on the last line.\n        leading_space = Match(r'^(\\s*)\\S', line)\n        line = leading_space.group(1) + '\"\"' + line[end + len(delimiter):]\n        delimiter = None\n      else:\n        # Haven't found the end yet, append a blank line.\n        line = '\"\"'\n\n    # Look for beginning of a raw string, and replace them with\n    # empty strings.  This is done in a loop to handle multiple raw\n    # strings on the same line.\n    while delimiter is None:\n      # Look for beginning of a raw string.\n      # See 2.14.15 [lex.string] for syntax.\n      #\n      # Once we have matched a raw string, we check the prefix of the\n      # line to make sure that the line is not part of a single line\n      # comment.  It's done this way because we remove raw strings\n      # before removing comments as opposed to removing comments\n      # before removing raw strings.  This is because there are some\n      # cpplint checks that requires the comments to be preserved, but\n      # we don't want to check comments that are inside raw strings.\n      matched = Match(r'^(.*?)\\b(?:R|u8R|uR|UR|LR)\"([^\\s\\\\()]*)\\((.*)$', line)\n      if (matched and\n          not Match(r'^([^\\'\"]|\\'(\\\\.|[^\\'])*\\'|\"(\\\\.|[^\"])*\")*//',\n                    matched.group(1))):\n        delimiter = ')' + matched.group(2) + '\"'\n\n        end = matched.group(3).find(delimiter)\n        if end >= 0:\n          # Raw string ended on same line\n          line = (matched.group(1) + '\"\"' +\n                  matched.group(3)[end + len(delimiter):])\n          delimiter = None\n        else:\n          # Start of a multi-line raw string\n          line = matched.group(1) + '\"\"'\n      else:\n        break\n\n    lines_without_raw_strings.append(line)\n\n  # TODO(unknown): if delimiter is not None here, we might want to\n  # emit a warning for unterminated string.\n  return lines_without_raw_strings\n\n\ndef FindNextMultiLineCommentStart(lines, lineix):\n  \"\"\"Find the beginning marker for a multiline comment.\"\"\"\n  while lineix < len(lines):\n    if lines[lineix].strip().startswith('/*'):\n      # Only return this marker if the comment goes beyond this line\n      if lines[lineix].strip().find('*/', 2) < 0:\n        return lineix\n    lineix += 1\n  return len(lines)\n\n\ndef FindNextMultiLineCommentEnd(lines, lineix):\n  \"\"\"We are inside a comment, find the end marker.\"\"\"\n  while lineix < len(lines):\n    if lines[lineix].strip().endswith('*/'):\n      return lineix\n    lineix += 1\n  return len(lines)\n\n\ndef RemoveMultiLineCommentsFromRange(lines, begin, end):\n  \"\"\"Clears a range of lines for multi-line comments.\"\"\"\n  # Having // dummy comments makes the lines non-empty, so we will not get\n  # unnecessary blank line warnings later in the code.\n  for i in range(begin, end):\n    lines[i] = '/**/'\n\n\ndef RemoveMultiLineComments(filename, lines, error):\n  \"\"\"Removes multiline (c-style) comments from lines.\"\"\"\n  lineix = 0\n  while lineix < len(lines):\n    lineix_begin = FindNextMultiLineCommentStart(lines, lineix)\n    if lineix_begin >= len(lines):\n      return\n    lineix_end = FindNextMultiLineCommentEnd(lines, lineix_begin)\n    if lineix_end >= len(lines):\n      error(filename, lineix_begin + 1, 'readability/multiline_comment', 5,\n            'Could not find end of multi-line comment')\n      return\n    RemoveMultiLineCommentsFromRange(lines, lineix_begin, lineix_end + 1)\n    lineix = lineix_end + 1\n\n\ndef CleanseComments(line):\n  \"\"\"Removes //-comments and single-line C-style /* */ comments.\n\n  Args:\n    line: A line of C++ source.\n\n  Returns:\n    The line with single-line comments removed.\n  \"\"\"\n  commentpos = line.find('//')\n  if commentpos != -1 and not IsCppString(line[:commentpos]):\n    line = line[:commentpos].rstrip()\n  # get rid of /* ... */\n  return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS.sub('', line)\n\n\nclass CleansedLines(object):\n  \"\"\"Holds 4 copies of all lines with different preprocessing applied to them.\n\n  1) elided member contains lines without strings and comments.\n  2) lines member contains lines without comments.\n  3) raw_lines member contains all the lines without processing.\n  4) lines_without_raw_strings member is same as raw_lines, but with C++11 raw\n     strings removed.\n  All these members are of <type 'list'>, and of the same length.\n  \"\"\"\n\n  def __init__(self, lines):\n    self.elided = []\n    self.lines = []\n    self.raw_lines = lines\n    self.num_lines = len(lines)\n    self.lines_without_raw_strings = CleanseRawStrings(lines)\n    for linenum in range(len(self.lines_without_raw_strings)):\n      self.lines.append(CleanseComments(\n          self.lines_without_raw_strings[linenum]))\n      elided = self._CollapseStrings(self.lines_without_raw_strings[linenum])\n      self.elided.append(CleanseComments(elided))\n\n  def NumLines(self):\n    \"\"\"Returns the number of lines represented.\"\"\"\n    return self.num_lines\n\n  @staticmethod\n  def _CollapseStrings(elided):\n    \"\"\"Collapses strings and chars on a line to simple \"\" or '' blocks.\n\n    We nix strings first so we're not fooled by text like '\"http://\"'\n\n    Args:\n      elided: The line being processed.\n\n    Returns:\n      The line with collapsed strings.\n    \"\"\"\n    if _RE_PATTERN_INCLUDE.match(elided):\n      return elided\n\n    # Remove escaped characters first to make quote/single quote collapsing\n    # basic.  Things that look like escaped characters shouldn't occur\n    # outside of strings and chars.\n    elided = _RE_PATTERN_CLEANSE_LINE_ESCAPES.sub('', elided)\n\n    # Replace quoted strings and digit separators.  Both single quotes\n    # and double quotes are processed in the same loop, otherwise\n    # nested quotes wouldn't work.\n    collapsed = ''\n    while True:\n      # Find the first quote character\n      match = Match(r'^([^\\'\"]*)([\\'\"])(.*)$', elided)\n      if not match:\n        collapsed += elided\n        break\n      head, quote, tail = match.groups()\n\n      if quote == '\"':\n        # Collapse double quoted strings\n        second_quote = tail.find('\"')\n        if second_quote >= 0:\n          collapsed += head + '\"\"'\n          elided = tail[second_quote + 1:]\n        else:\n          # Unmatched double quote, don't bother processing the rest\n          # of the line since this is probably a multiline string.\n          collapsed += elided\n          break\n      else:\n        # Found single quote, check nearby text to eliminate digit separators.\n        #\n        # There is no special handling for floating point here, because\n        # the integer/fractional/exponent parts would all be parsed\n        # correctly as long as there are digits on both sides of the\n        # separator.  So we are fine as long as we don't see something\n        # like \"0.'3\" (gcc 4.9.0 will not allow this literal).\n        if Search(r'\\b(?:0[bBxX]?|[1-9])[0-9a-fA-F]*$', head):\n          match_literal = Match(r'^((?:\\'?[0-9a-zA-Z_])*)(.*)$', \"'\" + tail)\n          collapsed += head + match_literal.group(1).replace(\"'\", '')\n          elided = match_literal.group(2)\n        else:\n          second_quote = tail.find('\\'')\n          if second_quote >= 0:\n            collapsed += head + \"''\"\n            elided = tail[second_quote + 1:]\n          else:\n            # Unmatched single quote\n            collapsed += elided\n            break\n\n    return collapsed\n\n\ndef FindEndOfExpressionInLine(line, startpos, stack):\n  \"\"\"Find the position just after the end of current parenthesized expression.\n\n  Args:\n    line: a CleansedLines line.\n    startpos: start searching at this position.\n    stack: nesting stack at startpos.\n\n  Returns:\n    On finding matching end: (index just after matching end, None)\n    On finding an unclosed expression: (-1, None)\n    Otherwise: (-1, new stack at end of this line)\n  \"\"\"\n  for i in xrange(startpos, len(line)):\n    char = line[i]\n    if char in '([{':\n      # Found start of parenthesized expression, push to expression stack\n      stack.append(char)\n    elif char == '<':\n      # Found potential start of template argument list\n      if i > 0 and line[i - 1] == '<':\n        # Left shift operator\n        if stack and stack[-1] == '<':\n          stack.pop()\n          if not stack:\n            return (-1, None)\n      elif i > 0 and Search(r'\\boperator\\s*$', line[0:i]):\n        # operator<, don't add to stack\n        continue\n      else:\n        # Tentative start of template argument list\n        stack.append('<')\n    elif char in ')]}':\n      # Found end of parenthesized expression.\n      #\n      # If we are currently expecting a matching '>', the pending '<'\n      # must have been an operator.  Remove them from expression stack.\n      while stack and stack[-1] == '<':\n        stack.pop()\n      if not stack:\n        return (-1, None)\n      if ((stack[-1] == '(' and char == ')') or\n          (stack[-1] == '[' and char == ']') or\n          (stack[-1] == '{' and char == '}')):\n        stack.pop()\n        if not stack:\n          return (i + 1, None)\n      else:\n        # Mismatched parentheses\n        return (-1, None)\n    elif char == '>':\n      # Found potential end of template argument list.\n\n      # Ignore \"->\" and operator functions\n      if (i > 0 and\n          (line[i - 1] == '-' or Search(r'\\boperator\\s*$', line[0:i - 1]))):\n        continue\n\n      # Pop the stack if there is a matching '<'.  Otherwise, ignore\n      # this '>' since it must be an operator.\n      if stack:\n        if stack[-1] == '<':\n          stack.pop()\n          if not stack:\n            return (i + 1, None)\n    elif char == ';':\n      # Found something that look like end of statements.  If we are currently\n      # expecting a '>', the matching '<' must have been an operator, since\n      # template argument list should not contain statements.\n      while stack and stack[-1] == '<':\n        stack.pop()\n      if not stack:\n        return (-1, None)\n\n  # Did not find end of expression or unbalanced parentheses on this line\n  return (-1, stack)\n\n\ndef CloseExpression(clean_lines, linenum, pos):\n  \"\"\"If input points to ( or { or [ or <, finds the position that closes it.\n\n  If lines[linenum][pos] points to a '(' or '{' or '[' or '<', finds the\n  linenum/pos that correspond to the closing of the expression.\n\n  TODO(unknown): cpplint spends a fair bit of time matching parentheses.\n  Ideally we would want to index all opening and closing parentheses once\n  and have CloseExpression be just a simple lookup, but due to preprocessor\n  tricks, this is not so easy.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    pos: A position on the line.\n\n  Returns:\n    A tuple (line, linenum, pos) pointer *past* the closing brace, or\n    (line, len(lines), -1) if we never find a close.  Note we ignore\n    strings and comments when matching; and the line we return is the\n    'cleansed' line at linenum.\n  \"\"\"\n\n  line = clean_lines.elided[linenum]\n  if (line[pos] not in '({[<') or Match(r'<[<=]', line[pos:]):\n    return (line, clean_lines.NumLines(), -1)\n\n  # Check first line\n  (end_pos, stack) = FindEndOfExpressionInLine(line, pos, [])\n  if end_pos > -1:\n    return (line, linenum, end_pos)\n\n  # Continue scanning forward\n  while stack and linenum < clean_lines.NumLines() - 1:\n    linenum += 1\n    line = clean_lines.elided[linenum]\n    (end_pos, stack) = FindEndOfExpressionInLine(line, 0, stack)\n    if end_pos > -1:\n      return (line, linenum, end_pos)\n\n  # Did not find end of expression before end of file, give up\n  return (line, clean_lines.NumLines(), -1)\n\n\ndef FindStartOfExpressionInLine(line, endpos, stack):\n  \"\"\"Find position at the matching start of current expression.\n\n  This is almost the reverse of FindEndOfExpressionInLine, but note\n  that the input position and returned position differs by 1.\n\n  Args:\n    line: a CleansedLines line.\n    endpos: start searching at this position.\n    stack: nesting stack at endpos.\n\n  Returns:\n    On finding matching start: (index at matching start, None)\n    On finding an unclosed expression: (-1, None)\n    Otherwise: (-1, new stack at beginning of this line)\n  \"\"\"\n  i = endpos\n  while i >= 0:\n    char = line[i]\n    if char in ')]}':\n      # Found end of expression, push to expression stack\n      stack.append(char)\n    elif char == '>':\n      # Found potential end of template argument list.\n      #\n      # Ignore it if it's a \"->\" or \">=\" or \"operator>\"\n      if (i > 0 and\n          (line[i - 1] == '-' or\n           Match(r'\\s>=\\s', line[i - 1:]) or\n           Search(r'\\boperator\\s*$', line[0:i]))):\n        i -= 1\n      else:\n        stack.append('>')\n    elif char == '<':\n      # Found potential start of template argument list\n      if i > 0 and line[i - 1] == '<':\n        # Left shift operator\n        i -= 1\n      else:\n        # If there is a matching '>', we can pop the expression stack.\n        # Otherwise, ignore this '<' since it must be an operator.\n        if stack and stack[-1] == '>':\n          stack.pop()\n          if not stack:\n            return (i, None)\n    elif char in '([{':\n      # Found start of expression.\n      #\n      # If there are any unmatched '>' on the stack, they must be\n      # operators.  Remove those.\n      while stack and stack[-1] == '>':\n        stack.pop()\n      if not stack:\n        return (-1, None)\n      if ((char == '(' and stack[-1] == ')') or\n          (char == '[' and stack[-1] == ']') or\n          (char == '{' and stack[-1] == '}')):\n        stack.pop()\n        if not stack:\n          return (i, None)\n      else:\n        # Mismatched parentheses\n        return (-1, None)\n    elif char == ';':\n      # Found something that look like end of statements.  If we are currently\n      # expecting a '<', the matching '>' must have been an operator, since\n      # template argument list should not contain statements.\n      while stack and stack[-1] == '>':\n        stack.pop()\n      if not stack:\n        return (-1, None)\n\n    i -= 1\n\n  return (-1, stack)\n\n\ndef ReverseCloseExpression(clean_lines, linenum, pos):\n  \"\"\"If input points to ) or } or ] or >, finds the position that opens it.\n\n  If lines[linenum][pos] points to a ')' or '}' or ']' or '>', finds the\n  linenum/pos that correspond to the opening of the expression.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    pos: A position on the line.\n\n  Returns:\n    A tuple (line, linenum, pos) pointer *at* the opening brace, or\n    (line, 0, -1) if we never find the matching opening brace.  Note\n    we ignore strings and comments when matching; and the line we\n    return is the 'cleansed' line at linenum.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n  if line[pos] not in ')}]>':\n    return (line, 0, -1)\n\n  # Check last line\n  (start_pos, stack) = FindStartOfExpressionInLine(line, pos, [])\n  if start_pos > -1:\n    return (line, linenum, start_pos)\n\n  # Continue scanning backward\n  while stack and linenum > 0:\n    linenum -= 1\n    line = clean_lines.elided[linenum]\n    (start_pos, stack) = FindStartOfExpressionInLine(line, len(line) - 1, stack)\n    if start_pos > -1:\n      return (line, linenum, start_pos)\n\n  # Did not find start of expression before beginning of file, give up\n  return (line, 0, -1)\n\n\ndef CheckForCopyright(filename, lines, error):\n  \"\"\"Logs an error if no Copyright message appears at the top of the file.\"\"\"\n\n  # We'll say it should occur by line 10. Don't forget there's a\n  # dummy line at the front.\n  for line in xrange(1, min(len(lines), 11)):\n    if re.search(r'Copyright', lines[line], re.I): break\n  else:                       # means no copyright line was found\n    error(filename, 0, 'legal/copyright', 5,\n          'No copyright message found.  '\n          'You should have a line: \"Copyright [year] <Copyright Owner>\"')\n\n\ndef GetIndentLevel(line):\n  \"\"\"Return the number of leading spaces in line.\n\n  Args:\n    line: A string to check.\n\n  Returns:\n    An integer count of leading spaces, possibly zero.\n  \"\"\"\n  indent = Match(r'^( *)\\S', line)\n  if indent:\n    return len(indent.group(1))\n  else:\n    return 0\n\ndef PathSplitToList(path):\n  \"\"\"Returns the path split into a list by the separator.\n\n  Args:\n    path: An absolute or relative path (e.g. '/a/b/c/' or '../a')\n\n  Returns:\n    A list of path components (e.g. ['a', 'b', 'c]).\n  \"\"\"\n  lst = []\n  while True:\n    (head, tail) = os.path.split(path)\n    if head == path:  # absolute paths end\n      lst.append(head)\n      break\n    if tail == path:  # relative paths end\n      lst.append(tail)\n      break\n\n    path = head\n    lst.append(tail)\n\n  lst.reverse()\n  return lst\n\ndef GetHeaderGuardCPPVariable(filename):\n  \"\"\"Returns the CPP variable that should be used as a header guard.\n\n  Args:\n    filename: The name of a C++ header file.\n\n  Returns:\n    The CPP variable that should be used as a header guard in the\n    named file.\n\n  \"\"\"\n\n  # Restores original filename in case that cpplint is invoked from Emacs's\n  # flymake.\n  filename = re.sub(r'_flymake\\.h$', '.h', filename)\n  filename = re.sub(r'/\\.flymake/([^/]*)$', r'/\\1', filename)\n  # Replace 'c++' with 'cpp'.\n  filename = filename.replace('C++', 'cpp').replace('c++', 'cpp')\n\n  fileinfo = FileInfo(filename)\n  file_path_from_root = fileinfo.RepositoryName()\n\n  def FixupPathFromRoot():\n    if _root_debug:\n      sys.stderr.write(\"\\n_root fixup, _root = '%s', repository name = '%s'\\n\"\n          % (_root, fileinfo.RepositoryName()))\n\n    # Process the file path with the --root flag if it was set.\n    if not _root:\n      if _root_debug:\n        sys.stderr.write(\"_root unspecified\\n\")\n      return file_path_from_root\n\n    def StripListPrefix(lst, prefix):\n      # f(['x', 'y'], ['w, z']) -> None  (not a valid prefix)\n      if lst[:len(prefix)] != prefix:\n        return None\n      # f(['a, 'b', 'c', 'd'], ['a', 'b']) -> ['c', 'd']\n      return lst[(len(prefix)):]\n\n    # root behavior:\n    #   --root=subdir , lstrips subdir from the header guard\n    maybe_path = StripListPrefix(PathSplitToList(file_path_from_root),\n                                 PathSplitToList(_root))\n\n    if _root_debug:\n      sys.stderr.write((\"_root lstrip (maybe_path=%s, file_path_from_root=%s,\" +\n          \" _root=%s)\\n\") % (maybe_path, file_path_from_root, _root))\n\n    if maybe_path:\n      return os.path.join(*maybe_path)\n\n    #   --root=.. , will prepend the outer directory to the header guard\n    full_path = fileinfo.FullName()\n    root_abspath = os.path.abspath(_root)\n\n    maybe_path = StripListPrefix(PathSplitToList(full_path),\n                                 PathSplitToList(root_abspath))\n\n    if _root_debug:\n      sys.stderr.write((\"_root prepend (maybe_path=%s, full_path=%s, \" +\n          \"root_abspath=%s)\\n\") % (maybe_path, full_path, root_abspath))\n\n    if maybe_path:\n      return os.path.join(*maybe_path)\n\n    if _root_debug:\n      sys.stderr.write(\"_root ignore, returning %s\\n\" % (file_path_from_root))\n\n    #   --root=FAKE_DIR is ignored\n    return file_path_from_root\n\n  file_path_from_root = FixupPathFromRoot()\n  return re.sub(r'[^a-zA-Z0-9]', '_', file_path_from_root).upper() + '_'\n\n\ndef CheckForHeaderGuard(filename, clean_lines, error):\n  \"\"\"Checks that the file contains a header guard.\n\n  Logs an error if no #ifndef header guard is present.  For other\n  headers, checks that the full pathname is used.\n\n  Args:\n    filename: The name of the C++ header file.\n    clean_lines: A CleansedLines instance containing the file.\n    error: The function to call with any errors found.\n  \"\"\"\n\n  # Don't check for header guards if there are error suppression\n  # comments somewhere in this file.\n  #\n  # Because this is silencing a warning for a nonexistent line, we\n  # only support the very specific NOLINT(build/header_guard) syntax,\n  # and not the general NOLINT or NOLINT(*) syntax.\n  raw_lines = clean_lines.lines_without_raw_strings\n  for i in raw_lines:\n    if Search(r'//\\s*NOLINT\\(build/header_guard\\)', i):\n      return\n\n  # Allow pragma once instead of header guards\n  for i in raw_lines:\n    if Search(r'^\\s*#pragma\\s+once', i):\n      return\n\n  cppvar = GetHeaderGuardCPPVariable(filename)\n\n  ifndef = ''\n  ifndef_linenum = 0\n  define = ''\n  endif = ''\n  endif_linenum = 0\n  for linenum, line in enumerate(raw_lines):\n    linesplit = line.split()\n    if len(linesplit) >= 2:\n      # find the first occurrence of #ifndef and #define, save arg\n      if not ifndef and linesplit[0] == '#ifndef':\n        # set ifndef to the header guard presented on the #ifndef line.\n        ifndef = linesplit[1]\n        ifndef_linenum = linenum\n      if not define and linesplit[0] == '#define':\n        define = linesplit[1]\n    # find the last occurrence of #endif, save entire line\n    if line.startswith('#endif'):\n      endif = line\n      endif_linenum = linenum\n\n  if not ifndef or not define or ifndef != define:\n    error(filename, 0, 'build/header_guard', 5,\n          'No #ifndef header guard found, suggested CPP variable is: %s' %\n          cppvar)\n    return\n\n  # The guard should be PATH_FILE_H_, but we also allow PATH_FILE_H__\n  # for backward compatibility.\n  if ifndef != cppvar:\n    error_level = 0\n    if ifndef != cppvar + '_':\n      error_level = 5\n\n    ParseNolintSuppressions(filename, raw_lines[ifndef_linenum], ifndef_linenum,\n                            error)\n    error(filename, ifndef_linenum, 'build/header_guard', error_level,\n          '#ifndef header guard has wrong style, please use: %s' % cppvar)\n\n  # Check for \"//\" comments on endif line.\n  ParseNolintSuppressions(filename, raw_lines[endif_linenum], endif_linenum,\n                          error)\n  match = Match(r'#endif\\s*//\\s*' + cppvar + r'(_)?\\b', endif)\n  if match:\n    if match.group(1) == '_':\n      # Issue low severity warning for deprecated double trailing underscore\n      error(filename, endif_linenum, 'build/header_guard', 0,\n            '#endif line should be \"#endif  // %s\"' % cppvar)\n    return\n\n  # Didn't find the corresponding \"//\" comment.  If this file does not\n  # contain any \"//\" comments at all, it could be that the compiler\n  # only wants \"/**/\" comments, look for those instead.\n  no_single_line_comments = True\n  for i in xrange(1, len(raw_lines) - 1):\n    line = raw_lines[i]\n    if Match(r'^(?:(?:\\'(?:\\.|[^\\'])*\\')|(?:\"(?:\\.|[^\"])*\")|[^\\'\"])*//', line):\n      no_single_line_comments = False\n      break\n\n  if no_single_line_comments:\n    match = Match(r'#endif\\s*/\\*\\s*' + cppvar + r'(_)?\\s*\\*/', endif)\n    if match:\n      if match.group(1) == '_':\n        # Low severity warning for double trailing underscore\n        error(filename, endif_linenum, 'build/header_guard', 0,\n              '#endif line should be \"#endif  /* %s */\"' % cppvar)\n      return\n\n  # Didn't find anything\n  error(filename, endif_linenum, 'build/header_guard', 5,\n        '#endif line should be \"#endif  // %s\"' % cppvar)\n\n\ndef CheckHeaderFileIncluded(filename, include_state, error):\n  \"\"\"Logs an error if a source file does not include its header.\"\"\"\n\n  # Do not check test files\n  fileinfo = FileInfo(filename)\n  if Search(_TEST_FILE_SUFFIX, fileinfo.BaseName()):\n    return\n\n  for ext in GetHeaderExtensions():\n    basefilename = filename[0:len(filename) - len(fileinfo.Extension())]\n    headerfile = basefilename + '.' + ext\n    if not os.path.exists(headerfile):\n      continue\n    headername = FileInfo(headerfile).RepositoryName()\n    first_include = None\n    for section_list in include_state.include_list:\n      for f in section_list:\n        if headername in f[0] or f[0] in headername:\n          return\n        if not first_include:\n          first_include = f[1]\n\n    error(filename, first_include, 'build/include', 5,\n          '%s should include its header file %s' % (fileinfo.RepositoryName(),\n                                                    headername))\n\n\ndef CheckForBadCharacters(filename, lines, error):\n  \"\"\"Logs an error for each line containing bad characters.\n\n  Two kinds of bad characters:\n\n  1. Unicode replacement characters: These indicate that either the file\n  contained invalid UTF-8 (likely) or Unicode replacement characters (which\n  it shouldn't).  Note that it's possible for this to throw off line\n  numbering if the invalid UTF-8 occurred adjacent to a newline.\n\n  2. NUL bytes.  These are problematic for some tools.\n\n  Args:\n    filename: The name of the current file.\n    lines: An array of strings, each representing a line of the file.\n    error: The function to call with any errors found.\n  \"\"\"\n  for linenum, line in enumerate(lines):\n    if unicode_escape_decode('\\ufffd') in line:\n      error(filename, linenum, 'readability/utf8', 5,\n            'Line contains invalid UTF-8 (or Unicode replacement character).')\n    if '\\0' in line:\n      error(filename, linenum, 'readability/nul', 5, 'Line contains NUL byte.')\n\n\ndef CheckForNewlineAtEOF(filename, lines, error):\n  \"\"\"Logs an error if there is no newline char at the end of the file.\n\n  Args:\n    filename: The name of the current file.\n    lines: An array of strings, each representing a line of the file.\n    error: The function to call with any errors found.\n  \"\"\"\n\n  # The array lines() was created by adding two newlines to the\n  # original file (go figure), then splitting on \\n.\n  # To verify that the file ends in \\n, we just have to make sure the\n  # last-but-two element of lines() exists and is empty.\n  if len(lines) < 3 or lines[-2]:\n    error(filename, len(lines) - 2, 'whitespace/ending_newline', 5,\n          'Could not find a newline character at the end of the file.')\n\n\ndef CheckForMultilineCommentsAndStrings(filename, clean_lines, linenum, error):\n  \"\"\"Logs an error if we see /* ... */ or \"...\" that extend past one line.\n\n  /* ... */ comments are legit inside macros, for one line.\n  Otherwise, we prefer // comments, so it's ok to warn about the\n  other.  Likewise, it's ok for strings to extend across multiple\n  lines, as long as a line continuation character (backslash)\n  terminates each line. Although not currently prohibited by the C++\n  style guide, it's ugly and unnecessary. We don't do well with either\n  in this lint program, so we warn about both.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n\n  # Remove all \\\\ (escaped backslashes) from the line. They are OK, and the\n  # second (escaped) slash may trigger later \\\" detection erroneously.\n  line = line.replace('\\\\\\\\', '')\n\n  if line.count('/*') > line.count('*/'):\n    error(filename, linenum, 'readability/multiline_comment', 5,\n          'Complex multi-line /*...*/-style comment found. '\n          'Lint may give bogus warnings.  '\n          'Consider replacing these with //-style comments, '\n          'with #if 0...#endif, '\n          'or with more clearly structured multi-line comments.')\n\n  if (line.count('\"') - line.count('\\\\\"')) % 2:\n    error(filename, linenum, 'readability/multiline_string', 5,\n          'Multi-line string (\"...\") found.  This lint script doesn\\'t '\n          'do well with such strings, and may give bogus warnings.  '\n          'Use C++11 raw strings or concatenation instead.')\n\n\n# (non-threadsafe name, thread-safe alternative, validation pattern)\n#\n# The validation pattern is used to eliminate false positives such as:\n#  _rand();               // false positive due to substring match.\n#  ->rand();              // some member function rand().\n#  ACMRandom rand(seed);  // some variable named rand.\n#  ISAACRandom rand();    // another variable named rand.\n#\n# Basically we require the return value of these functions to be used\n# in some expression context on the same line by matching on some\n# operator before the function name.  This eliminates constructors and\n# member function calls.\n_UNSAFE_FUNC_PREFIX = r'(?:[-+*/=%^&|(<]\\s*|>\\s+)'\n_THREADING_LIST = (\n    ('asctime(', 'asctime_r(', _UNSAFE_FUNC_PREFIX + r'asctime\\([^)]+\\)'),\n    ('ctime(', 'ctime_r(', _UNSAFE_FUNC_PREFIX + r'ctime\\([^)]+\\)'),\n    ('getgrgid(', 'getgrgid_r(', _UNSAFE_FUNC_PREFIX + r'getgrgid\\([^)]+\\)'),\n    ('getgrnam(', 'getgrnam_r(', _UNSAFE_FUNC_PREFIX + r'getgrnam\\([^)]+\\)'),\n    ('getlogin(', 'getlogin_r(', _UNSAFE_FUNC_PREFIX + r'getlogin\\(\\)'),\n    ('getpwnam(', 'getpwnam_r(', _UNSAFE_FUNC_PREFIX + r'getpwnam\\([^)]+\\)'),\n    ('getpwuid(', 'getpwuid_r(', _UNSAFE_FUNC_PREFIX + r'getpwuid\\([^)]+\\)'),\n    ('gmtime(', 'gmtime_r(', _UNSAFE_FUNC_PREFIX + r'gmtime\\([^)]+\\)'),\n    ('localtime(', 'localtime_r(', _UNSAFE_FUNC_PREFIX + r'localtime\\([^)]+\\)'),\n    ('rand(', 'rand_r(', _UNSAFE_FUNC_PREFIX + r'rand\\(\\)'),\n    ('strtok(', 'strtok_r(',\n     _UNSAFE_FUNC_PREFIX + r'strtok\\([^)]+\\)'),\n    ('ttyname(', 'ttyname_r(', _UNSAFE_FUNC_PREFIX + r'ttyname\\([^)]+\\)'),\n    )\n\n\ndef CheckPosixThreading(filename, clean_lines, linenum, error):\n  \"\"\"Checks for calls to thread-unsafe functions.\n\n  Much code has been originally written without consideration of\n  multi-threading. Also, engineers are relying on their old experience;\n  they have learned posix before threading extensions were added. These\n  tests guide the engineers to use thread-safe functions (when using\n  posix directly).\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n  for single_thread_func, multithread_safe_func, pattern in _THREADING_LIST:\n    # Additional pattern matching check to confirm that this is the\n    # function we are looking for\n    if Search(pattern, line):\n      error(filename, linenum, 'runtime/threadsafe_fn', 2,\n            'Consider using ' + multithread_safe_func +\n            '...) instead of ' + single_thread_func +\n            '...) for improved thread safety.')\n\n\ndef CheckVlogArguments(filename, clean_lines, linenum, error):\n  \"\"\"Checks that VLOG() is only used for defining a logging level.\n\n  For example, VLOG(2) is correct. VLOG(INFO), VLOG(WARNING), VLOG(ERROR), and\n  VLOG(FATAL) are not.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n  if Search(r'\\bVLOG\\((INFO|ERROR|WARNING|DFATAL|FATAL)\\)', line):\n    error(filename, linenum, 'runtime/vlog', 5,\n          'VLOG() should be used with numeric verbosity level.  '\n          'Use LOG() if you want symbolic severity levels.')\n\n# Matches invalid increment: *count++, which moves pointer instead of\n# incrementing a value.\n_RE_PATTERN_INVALID_INCREMENT = re.compile(\n    r'^\\s*\\*\\w+(\\+\\+|--);')\n\n\ndef CheckInvalidIncrement(filename, clean_lines, linenum, error):\n  \"\"\"Checks for invalid increment *count++.\n\n  For example following function:\n  void increment_counter(int* count) {\n    *count++;\n  }\n  is invalid, because it effectively does count++, moving pointer, and should\n  be replaced with ++*count, (*count)++ or *count += 1.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n  if _RE_PATTERN_INVALID_INCREMENT.match(line):\n    error(filename, linenum, 'runtime/invalid_increment', 5,\n          'Changing pointer instead of value (or unused value of operator*).')\n\n\ndef IsMacroDefinition(clean_lines, linenum):\n  if Search(r'^#define', clean_lines[linenum]):\n    return True\n\n  if linenum > 0 and Search(r'\\\\$', clean_lines[linenum - 1]):\n    return True\n\n  return False\n\n\ndef IsForwardClassDeclaration(clean_lines, linenum):\n  return Match(r'^\\s*(\\btemplate\\b)*.*class\\s+\\w+;\\s*$', clean_lines[linenum])\n\n\nclass _BlockInfo(object):\n  \"\"\"Stores information about a generic block of code.\"\"\"\n\n  def __init__(self, linenum, seen_open_brace):\n    self.starting_linenum = linenum\n    self.seen_open_brace = seen_open_brace\n    self.open_parentheses = 0\n    self.inline_asm = _NO_ASM\n    self.check_namespace_indentation = False\n\n  def CheckBegin(self, filename, clean_lines, linenum, error):\n    \"\"\"Run checks that applies to text up to the opening brace.\n\n    This is mostly for checking the text after the class identifier\n    and the \"{\", usually where the base class is specified.  For other\n    blocks, there isn't much to check, so we always pass.\n\n    Args:\n      filename: The name of the current file.\n      clean_lines: A CleansedLines instance containing the file.\n      linenum: The number of the line to check.\n      error: The function to call with any errors found.\n    \"\"\"\n    pass\n\n  def CheckEnd(self, filename, clean_lines, linenum, error):\n    \"\"\"Run checks that applies to text after the closing brace.\n\n    This is mostly used for checking end of namespace comments.\n\n    Args:\n      filename: The name of the current file.\n      clean_lines: A CleansedLines instance containing the file.\n      linenum: The number of the line to check.\n      error: The function to call with any errors found.\n    \"\"\"\n    pass\n\n  def IsBlockInfo(self):\n    \"\"\"Returns true if this block is a _BlockInfo.\n\n    This is convenient for verifying that an object is an instance of\n    a _BlockInfo, but not an instance of any of the derived classes.\n\n    Returns:\n      True for this class, False for derived classes.\n    \"\"\"\n    return self.__class__ == _BlockInfo\n\n\nclass _ExternCInfo(_BlockInfo):\n  \"\"\"Stores information about an 'extern \"C\"' block.\"\"\"\n\n  def __init__(self, linenum):\n    _BlockInfo.__init__(self, linenum, True)\n\n\nclass _ClassInfo(_BlockInfo):\n  \"\"\"Stores information about a class.\"\"\"\n\n  def __init__(self, name, class_or_struct, clean_lines, linenum):\n    _BlockInfo.__init__(self, linenum, False)\n    self.name = name\n    self.is_derived = False\n    self.check_namespace_indentation = True\n    if class_or_struct == 'struct':\n      self.access = 'public'\n      self.is_struct = True\n    else:\n      self.access = 'private'\n      self.is_struct = False\n\n    # Remember initial indentation level for this class.  Using raw_lines here\n    # instead of elided to account for leading comments.\n    self.class_indent = GetIndentLevel(clean_lines.raw_lines[linenum])\n\n    # Try to find the end of the class.  This will be confused by things like:\n    #   class A {\n    #   } *x = { ...\n    #\n    # But it's still good enough for CheckSectionSpacing.\n    self.last_line = 0\n    depth = 0\n    for i in range(linenum, clean_lines.NumLines()):\n      line = clean_lines.elided[i]\n      depth += line.count('{') - line.count('}')\n      if not depth:\n        self.last_line = i\n        break\n\n  def CheckBegin(self, filename, clean_lines, linenum, error):\n    # Look for a bare ':'\n    if Search('(^|[^:]):($|[^:])', clean_lines.elided[linenum]):\n      self.is_derived = True\n\n  def CheckEnd(self, filename, clean_lines, linenum, error):\n    # If there is a DISALLOW macro, it should appear near the end of\n    # the class.\n    seen_last_thing_in_class = False\n    for i in xrange(linenum - 1, self.starting_linenum, -1):\n      match = Search(\n          r'\\b(DISALLOW_COPY_AND_ASSIGN|DISALLOW_IMPLICIT_CONSTRUCTORS)\\(' +\n          self.name + r'\\)',\n          clean_lines.elided[i])\n      if match:\n        if seen_last_thing_in_class:\n          error(filename, i, 'readability/constructors', 3,\n                match.group(1) + ' should be the last thing in the class')\n        break\n\n      if not Match(r'^\\s*$', clean_lines.elided[i]):\n        seen_last_thing_in_class = True\n\n    # Check that closing brace is aligned with beginning of the class.\n    # Only do this if the closing brace is indented by only whitespaces.\n    # This means we will not check single-line class definitions.\n    indent = Match(r'^( *)\\}', clean_lines.elided[linenum])\n    if indent and len(indent.group(1)) != self.class_indent:\n      if self.is_struct:\n        parent = 'struct ' + self.name\n      else:\n        parent = 'class ' + self.name\n      error(filename, linenum, 'whitespace/indent', 3,\n            'Closing brace should be aligned with beginning of %s' % parent)\n\n\nclass _NamespaceInfo(_BlockInfo):\n  \"\"\"Stores information about a namespace.\"\"\"\n\n  def __init__(self, name, linenum):\n    _BlockInfo.__init__(self, linenum, False)\n    self.name = name or ''\n    self.check_namespace_indentation = True\n\n  def CheckEnd(self, filename, clean_lines, linenum, error):\n    \"\"\"Check end of namespace comments.\"\"\"\n    line = clean_lines.raw_lines[linenum]\n\n    # Check how many lines is enclosed in this namespace.  Don't issue\n    # warning for missing namespace comments if there aren't enough\n    # lines.  However, do apply checks if there is already an end of\n    # namespace comment and it's incorrect.\n    #\n    # TODO(unknown): We always want to check end of namespace comments\n    # if a namespace is large, but sometimes we also want to apply the\n    # check if a short namespace contained nontrivial things (something\n    # other than forward declarations).  There is currently no logic on\n    # deciding what these nontrivial things are, so this check is\n    # triggered by namespace size only, which works most of the time.\n    if (linenum - self.starting_linenum < 10\n        and not Match(r'^\\s*};*\\s*(//|/\\*).*\\bnamespace\\b', line)):\n      return\n\n    # Look for matching comment at end of namespace.\n    #\n    # Note that we accept C style \"/* */\" comments for terminating\n    # namespaces, so that code that terminate namespaces inside\n    # preprocessor macros can be cpplint clean.\n    #\n    # We also accept stuff like \"// end of namespace <name>.\" with the\n    # period at the end.\n    #\n    # Besides these, we don't accept anything else, otherwise we might\n    # get false negatives when existing comment is a substring of the\n    # expected namespace.\n    if self.name:\n      # Named namespace\n      if not Match((r'^\\s*};*\\s*(//|/\\*).*\\bnamespace\\s+' +\n                    re.escape(self.name) + r'[\\*/\\.\\\\\\s]*$'),\n                   line):\n        error(filename, linenum, 'readability/namespace', 5,\n              'Namespace should be terminated with \"// namespace %s\"' %\n              self.name)\n    else:\n      # Anonymous namespace\n      if not Match(r'^\\s*};*\\s*(//|/\\*).*\\bnamespace[\\*/\\.\\\\\\s]*$', line):\n        # If \"// namespace anonymous\" or \"// anonymous namespace (more text)\",\n        # mention \"// anonymous namespace\" as an acceptable form\n        if Match(r'^\\s*}.*\\b(namespace anonymous|anonymous namespace)\\b', line):\n          error(filename, linenum, 'readability/namespace', 5,\n                'Anonymous namespace should be terminated with \"// namespace\"'\n                ' or \"// anonymous namespace\"')\n        else:\n          error(filename, linenum, 'readability/namespace', 5,\n                'Anonymous namespace should be terminated with \"// namespace\"')\n\n\nclass _PreprocessorInfo(object):\n  \"\"\"Stores checkpoints of nesting stacks when #if/#else is seen.\"\"\"\n\n  def __init__(self, stack_before_if):\n    # The entire nesting stack before #if\n    self.stack_before_if = stack_before_if\n\n    # The entire nesting stack up to #else\n    self.stack_before_else = []\n\n    # Whether we have already seen #else or #elif\n    self.seen_else = False\n\n\nclass NestingState(object):\n  \"\"\"Holds states related to parsing braces.\"\"\"\n\n  def __init__(self):\n    # Stack for tracking all braces.  An object is pushed whenever we\n    # see a \"{\", and popped when we see a \"}\".  Only 3 types of\n    # objects are possible:\n    # - _ClassInfo: a class or struct.\n    # - _NamespaceInfo: a namespace.\n    # - _BlockInfo: some other type of block.\n    self.stack = []\n\n    # Top of the previous stack before each Update().\n    #\n    # Because the nesting_stack is updated at the end of each line, we\n    # had to do some convoluted checks to find out what is the current\n    # scope at the beginning of the line.  This check is simplified by\n    # saving the previous top of nesting stack.\n    #\n    # We could save the full stack, but we only need the top.  Copying\n    # the full nesting stack would slow down cpplint by ~10%.\n    self.previous_stack_top = []\n\n    # Stack of _PreprocessorInfo objects.\n    self.pp_stack = []\n\n  def SeenOpenBrace(self):\n    \"\"\"Check if we have seen the opening brace for the innermost block.\n\n    Returns:\n      True if we have seen the opening brace, False if the innermost\n      block is still expecting an opening brace.\n    \"\"\"\n    return (not self.stack) or self.stack[-1].seen_open_brace\n\n  def InNamespaceBody(self):\n    \"\"\"Check if we are currently one level inside a namespace body.\n\n    Returns:\n      True if top of the stack is a namespace block, False otherwise.\n    \"\"\"\n    return self.stack and isinstance(self.stack[-1], _NamespaceInfo)\n\n  def InExternC(self):\n    \"\"\"Check if we are currently one level inside an 'extern \"C\"' block.\n\n    Returns:\n      True if top of the stack is an extern block, False otherwise.\n    \"\"\"\n    return self.stack and isinstance(self.stack[-1], _ExternCInfo)\n\n  def InClassDeclaration(self):\n    \"\"\"Check if we are currently one level inside a class or struct declaration.\n\n    Returns:\n      True if top of the stack is a class/struct, False otherwise.\n    \"\"\"\n    return self.stack and isinstance(self.stack[-1], _ClassInfo)\n\n  def InAsmBlock(self):\n    \"\"\"Check if we are currently one level inside an inline ASM block.\n\n    Returns:\n      True if the top of the stack is a block containing inline ASM.\n    \"\"\"\n    return self.stack and self.stack[-1].inline_asm != _NO_ASM\n\n  def InTemplateArgumentList(self, clean_lines, linenum, pos):\n    \"\"\"Check if current position is inside template argument list.\n\n    Args:\n      clean_lines: A CleansedLines instance containing the file.\n      linenum: The number of the line to check.\n      pos: position just after the suspected template argument.\n    Returns:\n      True if (linenum, pos) is inside template arguments.\n    \"\"\"\n    while linenum < clean_lines.NumLines():\n      # Find the earliest character that might indicate a template argument\n      line = clean_lines.elided[linenum]\n      match = Match(r'^[^{};=\\[\\]\\.<>]*(.)', line[pos:])\n      if not match:\n        linenum += 1\n        pos = 0\n        continue\n      token = match.group(1)\n      pos += len(match.group(0))\n\n      # These things do not look like template argument list:\n      #   class Suspect {\n      #   class Suspect x; }\n      if token in ('{', '}', ';'): return False\n\n      # These things look like template argument list:\n      #   template <class Suspect>\n      #   template <class Suspect = default_value>\n      #   template <class Suspect[]>\n      #   template <class Suspect...>\n      if token in ('>', '=', '[', ']', '.'): return True\n\n      # Check if token is an unmatched '<'.\n      # If not, move on to the next character.\n      if token != '<':\n        pos += 1\n        if pos >= len(line):\n          linenum += 1\n          pos = 0\n        continue\n\n      # We can't be sure if we just find a single '<', and need to\n      # find the matching '>'.\n      (_, end_line, end_pos) = CloseExpression(clean_lines, linenum, pos - 1)\n      if end_pos < 0:\n        # Not sure if template argument list or syntax error in file\n        return False\n      linenum = end_line\n      pos = end_pos\n    return False\n\n  def UpdatePreprocessor(self, line):\n    \"\"\"Update preprocessor stack.\n\n    We need to handle preprocessors due to classes like this:\n      #ifdef SWIG\n      struct ResultDetailsPageElementExtensionPoint {\n      #else\n      struct ResultDetailsPageElementExtensionPoint : public Extension {\n      #endif\n\n    We make the following assumptions (good enough for most files):\n    - Preprocessor condition evaluates to true from #if up to first\n      #else/#elif/#endif.\n\n    - Preprocessor condition evaluates to false from #else/#elif up\n      to #endif.  We still perform lint checks on these lines, but\n      these do not affect nesting stack.\n\n    Args:\n      line: current line to check.\n    \"\"\"\n    if Match(r'^\\s*#\\s*(if|ifdef|ifndef)\\b', line):\n      # Beginning of #if block, save the nesting stack here.  The saved\n      # stack will allow us to restore the parsing state in the #else case.\n      self.pp_stack.append(_PreprocessorInfo(copy.deepcopy(self.stack)))\n    elif Match(r'^\\s*#\\s*(else|elif)\\b', line):\n      # Beginning of #else block\n      if self.pp_stack:\n        if not self.pp_stack[-1].seen_else:\n          # This is the first #else or #elif block.  Remember the\n          # whole nesting stack up to this point.  This is what we\n          # keep after the #endif.\n          self.pp_stack[-1].seen_else = True\n          self.pp_stack[-1].stack_before_else = copy.deepcopy(self.stack)\n\n        # Restore the stack to how it was before the #if\n        self.stack = copy.deepcopy(self.pp_stack[-1].stack_before_if)\n      else:\n        # TODO(unknown): unexpected #else, issue warning?\n        pass\n    elif Match(r'^\\s*#\\s*endif\\b', line):\n      # End of #if or #else blocks.\n      if self.pp_stack:\n        # If we saw an #else, we will need to restore the nesting\n        # stack to its former state before the #else, otherwise we\n        # will just continue from where we left off.\n        if self.pp_stack[-1].seen_else:\n          # Here we can just use a shallow copy since we are the last\n          # reference to it.\n          self.stack = self.pp_stack[-1].stack_before_else\n        # Drop the corresponding #if\n        self.pp_stack.pop()\n      else:\n        # TODO(unknown): unexpected #endif, issue warning?\n        pass\n\n  # TODO(unknown): Update() is too long, but we will refactor later.\n  def Update(self, filename, clean_lines, linenum, error):\n    \"\"\"Update nesting state with current line.\n\n    Args:\n      filename: The name of the current file.\n      clean_lines: A CleansedLines instance containing the file.\n      linenum: The number of the line to check.\n      error: The function to call with any errors found.\n    \"\"\"\n    line = clean_lines.elided[linenum]\n\n    # Remember top of the previous nesting stack.\n    #\n    # The stack is always pushed/popped and not modified in place, so\n    # we can just do a shallow copy instead of copy.deepcopy.  Using\n    # deepcopy would slow down cpplint by ~28%.\n    if self.stack:\n      self.previous_stack_top = self.stack[-1]\n    else:\n      self.previous_stack_top = None\n\n    # Update pp_stack\n    self.UpdatePreprocessor(line)\n\n    # Count parentheses.  This is to avoid adding struct arguments to\n    # the nesting stack.\n    if self.stack:\n      inner_block = self.stack[-1]\n      depth_change = line.count('(') - line.count(')')\n      inner_block.open_parentheses += depth_change\n\n      # Also check if we are starting or ending an inline assembly block.\n      if inner_block.inline_asm in (_NO_ASM, _END_ASM):\n        if (depth_change != 0 and\n            inner_block.open_parentheses == 1 and\n            _MATCH_ASM.match(line)):\n          # Enter assembly block\n          inner_block.inline_asm = _INSIDE_ASM\n        else:\n          # Not entering assembly block.  If previous line was _END_ASM,\n          # we will now shift to _NO_ASM state.\n          inner_block.inline_asm = _NO_ASM\n      elif (inner_block.inline_asm == _INSIDE_ASM and\n            inner_block.open_parentheses == 0):\n        # Exit assembly block\n        inner_block.inline_asm = _END_ASM\n\n    # Consume namespace declaration at the beginning of the line.  Do\n    # this in a loop so that we catch same line declarations like this:\n    #   namespace proto2 { namespace bridge { class MessageSet; } }\n    while True:\n      # Match start of namespace.  The \"\\b\\s*\" below catches namespace\n      # declarations even if it weren't followed by a whitespace, this\n      # is so that we don't confuse our namespace checker.  The\n      # missing spaces will be flagged by CheckSpacing.\n      namespace_decl_match = Match(r'^\\s*namespace\\b\\s*([:\\w]+)?(.*)$', line)\n      if not namespace_decl_match:\n        break\n\n      new_namespace = _NamespaceInfo(namespace_decl_match.group(1), linenum)\n      self.stack.append(new_namespace)\n\n      line = namespace_decl_match.group(2)\n      if line.find('{') != -1:\n        new_namespace.seen_open_brace = True\n        line = line[line.find('{') + 1:]\n\n    # Look for a class declaration in whatever is left of the line\n    # after parsing namespaces.  The regexp accounts for decorated classes\n    # such as in:\n    #   class LOCKABLE API Object {\n    #   };\n    class_decl_match = Match(\n        r'^(\\s*(?:template\\s*<[\\w\\s<>,:=]*>\\s*)?'\n        r'(class|struct)\\s+(?:[A-Z_]+\\s+)*(\\w+(?:::\\w+)*))'\n        r'(.*)$', line)\n    if (class_decl_match and\n        (not self.stack or self.stack[-1].open_parentheses == 0)):\n      # We do not want to accept classes that are actually template arguments:\n      #   template <class Ignore1,\n      #             class Ignore2 = Default<Args>,\n      #             template <Args> class Ignore3>\n      #   void Function() {};\n      #\n      # To avoid template argument cases, we scan forward and look for\n      # an unmatched '>'.  If we see one, assume we are inside a\n      # template argument list.\n      end_declaration = len(class_decl_match.group(1))\n      if not self.InTemplateArgumentList(clean_lines, linenum, end_declaration):\n        self.stack.append(_ClassInfo(\n            class_decl_match.group(3), class_decl_match.group(2),\n            clean_lines, linenum))\n        line = class_decl_match.group(4)\n\n    # If we have not yet seen the opening brace for the innermost block,\n    # run checks here.\n    if not self.SeenOpenBrace():\n      self.stack[-1].CheckBegin(filename, clean_lines, linenum, error)\n\n    # Update access control if we are inside a class/struct\n    if self.stack and isinstance(self.stack[-1], _ClassInfo):\n      classinfo = self.stack[-1]\n      access_match = Match(\n          r'^(.*)\\b(public|private|protected|signals)(\\s+(?:slots\\s*)?)?'\n          r':(?:[^:]|$)',\n          line)\n      if access_match:\n        classinfo.access = access_match.group(2)\n\n        # Check that access keywords are indented +1 space.  Skip this\n        # check if the keywords are not preceded by whitespaces.\n        indent = access_match.group(1)\n        if (len(indent) != classinfo.class_indent + 1 and\n            Match(r'^\\s*$', indent)):\n          if classinfo.is_struct:\n            parent = 'struct ' + classinfo.name\n          else:\n            parent = 'class ' + classinfo.name\n          slots = ''\n          if access_match.group(3):\n            slots = access_match.group(3)\n          error(filename, linenum, 'whitespace/indent', 3,\n                '%s%s: should be indented +1 space inside %s' % (\n                    access_match.group(2), slots, parent))\n\n    # Consume braces or semicolons from what's left of the line\n    while True:\n      # Match first brace, semicolon, or closed parenthesis.\n      matched = Match(r'^[^{;)}]*([{;)}])(.*)$', line)\n      if not matched:\n        break\n\n      token = matched.group(1)\n      if token == '{':\n        # If namespace or class hasn't seen a opening brace yet, mark\n        # namespace/class head as complete.  Push a new block onto the\n        # stack otherwise.\n        if not self.SeenOpenBrace():\n          self.stack[-1].seen_open_brace = True\n        elif Match(r'^extern\\s*\"[^\"]*\"\\s*\\{', line):\n          self.stack.append(_ExternCInfo(linenum))\n        else:\n          self.stack.append(_BlockInfo(linenum, True))\n          if _MATCH_ASM.match(line):\n            self.stack[-1].inline_asm = _BLOCK_ASM\n\n      elif token == ';' or token == ')':\n        # If we haven't seen an opening brace yet, but we already saw\n        # a semicolon, this is probably a forward declaration.  Pop\n        # the stack for these.\n        #\n        # Similarly, if we haven't seen an opening brace yet, but we\n        # already saw a closing parenthesis, then these are probably\n        # function arguments with extra \"class\" or \"struct\" keywords.\n        # Also pop these stack for these.\n        if not self.SeenOpenBrace():\n          self.stack.pop()\n      else:  # token == '}'\n        # Perform end of block checks and pop the stack.\n        if self.stack:\n          self.stack[-1].CheckEnd(filename, clean_lines, linenum, error)\n          self.stack.pop()\n      line = matched.group(2)\n\n  def InnermostClass(self):\n    \"\"\"Get class info on the top of the stack.\n\n    Returns:\n      A _ClassInfo object if we are inside a class, or None otherwise.\n    \"\"\"\n    for i in range(len(self.stack), 0, -1):\n      classinfo = self.stack[i - 1]\n      if isinstance(classinfo, _ClassInfo):\n        return classinfo\n    return None\n\n  def CheckCompletedBlocks(self, filename, error):\n    \"\"\"Checks that all classes and namespaces have been completely parsed.\n\n    Call this when all lines in a file have been processed.\n    Args:\n      filename: The name of the current file.\n      error: The function to call with any errors found.\n    \"\"\"\n    # Note: This test can result in false positives if #ifdef constructs\n    # get in the way of brace matching. See the testBuildClass test in\n    # cpplint_unittest.py for an example of this.\n    for obj in self.stack:\n      if isinstance(obj, _ClassInfo):\n        error(filename, obj.starting_linenum, 'build/class', 5,\n              'Failed to find complete declaration of class %s' %\n              obj.name)\n      elif isinstance(obj, _NamespaceInfo):\n        error(filename, obj.starting_linenum, 'build/namespaces', 5,\n              'Failed to find complete declaration of namespace %s' %\n              obj.name)\n\n\ndef CheckForNonStandardConstructs(filename, clean_lines, linenum,\n                                  nesting_state, error):\n  r\"\"\"Logs an error if we see certain non-ANSI constructs ignored by gcc-2.\n\n  Complain about several constructs which gcc-2 accepts, but which are\n  not standard C++.  Warning about these in lint is one way to ease the\n  transition to new compilers.\n  - put storage class first (e.g. \"static const\" instead of \"const static\").\n  - \"%lld\" instead of %qd\" in printf-type functions.\n  - \"%1$d\" is non-standard in printf-type functions.\n  - \"\\%\" is an undefined character escape sequence.\n  - text after #endif is not allowed.\n  - invalid inner-style forward declaration.\n  - >? and <? operators, and their >?= and <?= cousins.\n\n  Additionally, check for constructor/destructor style violations and reference\n  members, as it is very convenient to do so while checking for\n  gcc-2 compliance.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    nesting_state: A NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: A callable to which errors are reported, which takes 4 arguments:\n           filename, line number, error level, and message\n  \"\"\"\n\n  # Remove comments from the line, but leave in strings for now.\n  line = clean_lines.lines[linenum]\n\n  if Search(r'printf\\s*\\(.*\".*%[-+ ]?\\d*q', line):\n    error(filename, linenum, 'runtime/printf_format', 3,\n          '%q in format strings is deprecated.  Use %ll instead.')\n\n  if Search(r'printf\\s*\\(.*\".*%\\d+\\$', line):\n    error(filename, linenum, 'runtime/printf_format', 2,\n          '%N$ formats are unconventional.  Try rewriting to avoid them.')\n\n  # Remove escaped backslashes before looking for undefined escapes.\n  line = line.replace('\\\\\\\\', '')\n\n  if Search(r'(\"|\\').*\\\\(%|\\[|\\(|{)', line):\n    error(filename, linenum, 'build/printf_format', 3,\n          '%, [, (, and { are undefined character escapes.  Unescape them.')\n\n  # For the rest, work with both comments and strings removed.\n  line = clean_lines.elided[linenum]\n\n  if Search(r'\\b(const|volatile|void|char|short|int|long'\n            r'|float|double|signed|unsigned'\n            r'|schar|u?int8|u?int16|u?int32|u?int64)'\n            r'\\s+(register|static|extern|typedef)\\b',\n            line):\n    error(filename, linenum, 'build/storage_class', 5,\n          'Storage-class specifier (static, extern, typedef, etc) should be '\n          'at the beginning of the declaration.')\n\n  if Match(r'\\s*#\\s*endif\\s*[^/\\s]+', line):\n    error(filename, linenum, 'build/endif_comment', 5,\n          'Uncommented text after #endif is non-standard.  Use a comment.')\n\n  if Match(r'\\s*class\\s+(\\w+\\s*::\\s*)+\\w+\\s*;', line):\n    error(filename, linenum, 'build/forward_decl', 5,\n          'Inner-style forward declarations are invalid.  Remove this line.')\n\n  if Search(r'(\\w+|[+-]?\\d+(\\.\\d*)?)\\s*(<|>)\\?=?\\s*(\\w+|[+-]?\\d+)(\\.\\d*)?',\n            line):\n    error(filename, linenum, 'build/deprecated', 3,\n          '>? and <? (max and min) operators are non-standard and deprecated.')\n\n  if Search(r'^\\s*const\\s*string\\s*&\\s*\\w+\\s*;', line):\n    # TODO(unknown): Could it be expanded safely to arbitrary references,\n    # without triggering too many false positives? The first\n    # attempt triggered 5 warnings for mostly benign code in the regtest, hence\n    # the restriction.\n    # Here's the original regexp, for the reference:\n    # type_name = r'\\w+((\\s*::\\s*\\w+)|(\\s*<\\s*\\w+?\\s*>))?'\n    # r'\\s*const\\s*' + type_name + '\\s*&\\s*\\w+\\s*;'\n    error(filename, linenum, 'runtime/member_string_references', 2,\n          'const string& members are dangerous. It is much better to use '\n          'alternatives, such as pointers or simple constants.')\n\n  # Everything else in this function operates on class declarations.\n  # Return early if the top of the nesting stack is not a class, or if\n  # the class head is not completed yet.\n  classinfo = nesting_state.InnermostClass()\n  if not classinfo or not classinfo.seen_open_brace:\n    return\n\n  # The class may have been declared with namespace or classname qualifiers.\n  # The constructor and destructor will not have those qualifiers.\n  base_classname = classinfo.name.split('::')[-1]\n\n  # Look for single-argument constructors that aren't marked explicit.\n  # Technically a valid construct, but against style.\n  explicit_constructor_match = Match(\n      r'\\s+(?:(?:inline|constexpr)\\s+)*(explicit\\s+)?'\n      r'(?:(?:inline|constexpr)\\s+)*%s\\s*'\n      r'\\(((?:[^()]|\\([^()]*\\))*)\\)'\n      % re.escape(base_classname),\n      line)\n\n  if explicit_constructor_match:\n    is_marked_explicit = explicit_constructor_match.group(1)\n\n    if not explicit_constructor_match.group(2):\n      constructor_args = []\n    else:\n      constructor_args = explicit_constructor_match.group(2).split(',')\n\n    # collapse arguments so that commas in template parameter lists and function\n    # argument parameter lists don't split arguments in two\n    i = 0\n    while i < len(constructor_args):\n      constructor_arg = constructor_args[i]\n      while (constructor_arg.count('<') > constructor_arg.count('>') or\n             constructor_arg.count('(') > constructor_arg.count(')')):\n        constructor_arg += ',' + constructor_args[i + 1]\n        del constructor_args[i + 1]\n      constructor_args[i] = constructor_arg\n      i += 1\n\n    variadic_args = [arg for arg in constructor_args if '&&...' in arg]\n    defaulted_args = [arg for arg in constructor_args if '=' in arg]\n    noarg_constructor = (not constructor_args or  # empty arg list\n                         # 'void' arg specifier\n                         (len(constructor_args) == 1 and\n                          constructor_args[0].strip() == 'void'))\n    onearg_constructor = ((len(constructor_args) == 1 and  # exactly one arg\n                           not noarg_constructor) or\n                          # all but at most one arg defaulted\n                          (len(constructor_args) >= 1 and\n                           not noarg_constructor and\n                           len(defaulted_args) >= len(constructor_args) - 1) or\n                          # variadic arguments with zero or one argument\n                          (len(constructor_args) <= 2 and\n                           len(variadic_args) >= 1))\n    initializer_list_constructor = bool(\n        onearg_constructor and\n        Search(r'\\bstd\\s*::\\s*initializer_list\\b', constructor_args[0]))\n    copy_constructor = bool(\n        onearg_constructor and\n        Match(r'((const\\s+(volatile\\s+)?)?|(volatile\\s+(const\\s+)?))?'\n              r'%s(\\s*<[^>]*>)?(\\s+const)?\\s*(?:<\\w+>\\s*)?&'\n              % re.escape(base_classname), constructor_args[0].strip()))\n\n    if (not is_marked_explicit and\n        onearg_constructor and\n        not initializer_list_constructor and\n        not copy_constructor):\n      if defaulted_args or variadic_args:\n        error(filename, linenum, 'runtime/explicit', 5,\n              'Constructors callable with one argument '\n              'should be marked explicit.')\n      else:\n        error(filename, linenum, 'runtime/explicit', 5,\n              'Single-parameter constructors should be marked explicit.')\n    elif is_marked_explicit and not onearg_constructor:\n      if noarg_constructor:\n        error(filename, linenum, 'runtime/explicit', 5,\n              'Zero-parameter constructors should not be marked explicit.')\n\n\ndef CheckSpacingForFunctionCall(filename, clean_lines, linenum, error):\n  \"\"\"Checks for the correctness of various spacing around function calls.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n\n  # Since function calls often occur inside if/for/while/switch\n  # expressions - which have their own, more liberal conventions - we\n  # first see if we should be looking inside such an expression for a\n  # function call, to which we can apply more strict standards.\n  fncall = line    # if there's no control flow construct, look at whole line\n  for pattern in (r'\\bif\\s*\\((.*)\\)\\s*{',\n                  r'\\bfor\\s*\\((.*)\\)\\s*{',\n                  r'\\bwhile\\s*\\((.*)\\)\\s*[{;]',\n                  r'\\bswitch\\s*\\((.*)\\)\\s*{'):\n    match = Search(pattern, line)\n    if match:\n      fncall = match.group(1)    # look inside the parens for function calls\n      break\n\n  # Except in if/for/while/switch, there should never be space\n  # immediately inside parens (eg \"f( 3, 4 )\").  We make an exception\n  # for nested parens ( (a+b) + c ).  Likewise, there should never be\n  # a space before a ( when it's a function argument.  I assume it's a\n  # function argument when the char before the whitespace is legal in\n  # a function name (alnum + _) and we're not starting a macro. Also ignore\n  # pointers and references to arrays and functions coz they're too tricky:\n  # we use a very simple way to recognize these:\n  # \" (something)(maybe-something)\" or\n  # \" (something)(maybe-something,\" or\n  # \" (something)[something]\"\n  # Note that we assume the contents of [] to be short enough that\n  # they'll never need to wrap.\n  if (  # Ignore control structures.\n      not Search(r'\\b(if|for|while|switch|return|new|delete|catch|sizeof)\\b',\n                 fncall) and\n      # Ignore pointers/references to functions.\n      not Search(r' \\([^)]+\\)\\([^)]*(\\)|,$)', fncall) and\n      # Ignore pointers/references to arrays.\n      not Search(r' \\([^)]+\\)\\[[^\\]]+\\]', fncall)):\n    if Search(r'\\w\\s*\\(\\s(?!\\s*\\\\$)', fncall):      # a ( used for a fn call\n      error(filename, linenum, 'whitespace/parens', 4,\n            'Extra space after ( in function call')\n    elif Search(r'\\(\\s+(?!(\\s*\\\\)|\\()', fncall):\n      error(filename, linenum, 'whitespace/parens', 2,\n            'Extra space after (')\n    if (Search(r'\\w\\s+\\(', fncall) and\n        not Search(r'_{0,2}asm_{0,2}\\s+_{0,2}volatile_{0,2}\\s+\\(', fncall) and\n        not Search(r'#\\s*define|typedef|using\\s+\\w+\\s*=', fncall) and\n        not Search(r'\\w\\s+\\((\\w+::)*\\*\\w+\\)\\(', fncall) and\n        not Search(r'\\bcase\\s+\\(', fncall)):\n      # TODO(unknown): Space after an operator function seem to be a common\n      # error, silence those for now by restricting them to highest verbosity.\n      if Search(r'\\boperator_*\\b', line):\n        error(filename, linenum, 'whitespace/parens', 0,\n              'Extra space before ( in function call')\n      else:\n        error(filename, linenum, 'whitespace/parens', 4,\n              'Extra space before ( in function call')\n    # If the ) is followed only by a newline or a { + newline, assume it's\n    # part of a control statement (if/while/etc), and don't complain\n    if Search(r'[^)]\\s+\\)\\s*[^{\\s]', fncall):\n      # If the closing parenthesis is preceded by only whitespaces,\n      # try to give a more descriptive error message.\n      if Search(r'^\\s+\\)', fncall):\n        error(filename, linenum, 'whitespace/parens', 2,\n              'Closing ) should be moved to the previous line')\n      else:\n        error(filename, linenum, 'whitespace/parens', 2,\n              'Extra space before )')\n\n\ndef IsBlankLine(line):\n  \"\"\"Returns true if the given line is blank.\n\n  We consider a line to be blank if the line is empty or consists of\n  only white spaces.\n\n  Args:\n    line: A line of a string.\n\n  Returns:\n    True, if the given line is blank.\n  \"\"\"\n  return not line or line.isspace()\n\n\ndef CheckForNamespaceIndentation(filename, nesting_state, clean_lines, line,\n                                 error):\n  is_namespace_indent_item = (\n      len(nesting_state.stack) > 1 and\n      nesting_state.stack[-1].check_namespace_indentation and\n      isinstance(nesting_state.previous_stack_top, _NamespaceInfo) and\n      nesting_state.previous_stack_top == nesting_state.stack[-2])\n\n  if ShouldCheckNamespaceIndentation(nesting_state, is_namespace_indent_item,\n                                     clean_lines.elided, line):\n    CheckItemIndentationInNamespace(filename, clean_lines.elided,\n                                    line, error)\n\n\ndef CheckForFunctionLengths(filename, clean_lines, linenum,\n                            function_state, error):\n  \"\"\"Reports for long function bodies.\n\n  For an overview why this is done, see:\n  https://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Write_Short_Functions\n\n  Uses a simplistic algorithm assuming other style guidelines\n  (especially spacing) are followed.\n  Only checks unindented functions, so class members are unchecked.\n  Trivial bodies are unchecked, so constructors with huge initializer lists\n  may be missed.\n  Blank/comment lines are not counted so as to avoid encouraging the removal\n  of vertical space and comments just to get through a lint check.\n  NOLINT *on the last line of a function* disables this check.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    function_state: Current function name and lines in body so far.\n    error: The function to call with any errors found.\n  \"\"\"\n  lines = clean_lines.lines\n  line = lines[linenum]\n  joined_line = ''\n\n  starting_func = False\n  regexp = r'(\\w(\\w|::|\\*|\\&|\\s)*)\\('  # decls * & space::name( ...\n  match_result = Match(regexp, line)\n  if match_result:\n    # If the name is all caps and underscores, figure it's a macro and\n    # ignore it, unless it's TEST or TEST_F.\n    function_name = match_result.group(1).split()[-1]\n    if function_name == 'TEST' or function_name == 'TEST_F' or (\n        not Match(r'[A-Z_]+$', function_name)):\n      starting_func = True\n\n  if starting_func:\n    body_found = False\n    for start_linenum in xrange(linenum, clean_lines.NumLines()):\n      start_line = lines[start_linenum]\n      joined_line += ' ' + start_line.lstrip()\n      if Search(r'(;|})', start_line):  # Declarations and trivial functions\n        body_found = True\n        break                              # ... ignore\n      if Search(r'{', start_line):\n        body_found = True\n        function = Search(r'((\\w|:)*)\\(', line).group(1)\n        if Match(r'TEST', function):    # Handle TEST... macros\n          parameter_regexp = Search(r'(\\(.*\\))', joined_line)\n          if parameter_regexp:             # Ignore bad syntax\n            function += parameter_regexp.group(1)\n        else:\n          function += '()'\n        function_state.Begin(function)\n        break\n    if not body_found:\n      # No body for the function (or evidence of a non-function) was found.\n      error(filename, linenum, 'readability/fn_size', 5,\n            'Lint failed to find start of function body.')\n  elif Match(r'^\\}\\s*$', line):  # function end\n    function_state.Check(error, filename, linenum)\n    function_state.End()\n  elif not Match(r'^\\s*$', line):\n    function_state.Count()  # Count non-blank/non-comment lines.\n\n\n_RE_PATTERN_TODO = re.compile(r'^//(\\s*)TODO(\\(.+?\\))?:?(\\s|$)?')\n\n\ndef CheckComment(line, filename, linenum, next_line_start, error):\n  \"\"\"Checks for common mistakes in comments.\n\n  Args:\n    line: The line in question.\n    filename: The name of the current file.\n    linenum: The number of the line to check.\n    next_line_start: The first non-whitespace column of the next line.\n    error: The function to call with any errors found.\n  \"\"\"\n  commentpos = line.find('//')\n  if commentpos != -1:\n    # Check if the // may be in quotes.  If so, ignore it\n    if re.sub(r'\\\\.', '', line[0:commentpos]).count('\"') % 2 == 0:\n      # Allow one space for new scopes, two spaces otherwise:\n      if (not (Match(r'^.*{ *//', line) and next_line_start == commentpos) and\n          ((commentpos >= 1 and\n            line[commentpos-1] not in string.whitespace) or\n           (commentpos >= 2 and\n            line[commentpos-2] not in string.whitespace))):\n        error(filename, linenum, 'whitespace/comments', 2,\n              'At least two spaces is best between code and comments')\n\n      # Checks for common mistakes in TODO comments.\n      comment = line[commentpos:]\n      match = _RE_PATTERN_TODO.match(comment)\n      if match:\n        # One whitespace is correct; zero whitespace is handled elsewhere.\n        leading_whitespace = match.group(1)\n        if len(leading_whitespace) > 1:\n          error(filename, linenum, 'whitespace/todo', 2,\n                'Too many spaces before TODO')\n\n        username = match.group(2)\n        if not username:\n          error(filename, linenum, 'readability/todo', 2,\n                'Missing username in TODO; it should look like '\n                '\"// TODO(my_username): Stuff.\"')\n\n        middle_whitespace = match.group(3)\n        # Comparisons made explicit for correctness -- pylint: disable=g-explicit-bool-comparison\n        if middle_whitespace != ' ' and middle_whitespace != '':\n          error(filename, linenum, 'whitespace/todo', 2,\n                'TODO(my_username) should be followed by a space')\n\n      # If the comment contains an alphanumeric character, there\n      # should be a space somewhere between it and the // unless\n      # it's a /// or //! Doxygen comment.\n      if (Match(r'//[^ ]*\\w', comment) and\n          not Match(r'(///|//\\!)(\\s+|$)', comment)):\n        error(filename, linenum, 'whitespace/comments', 4,\n              'Should have a space between // and comment')\n\n\ndef CheckSpacing(filename, clean_lines, linenum, nesting_state, error):\n  \"\"\"Checks for the correctness of various spacing issues in the code.\n\n  Things we check for: spaces around operators, spaces after\n  if/for/while/switch, no spaces around parens in function calls, two\n  spaces between code and comment, don't start a block with a blank\n  line, don't end a function with a blank line, don't add a blank line\n  after public/protected/private, don't have too many blank lines in a row.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    nesting_state: A NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: The function to call with any errors found.\n  \"\"\"\n\n  # Don't use \"elided\" lines here, otherwise we can't check commented lines.\n  # Don't want to use \"raw\" either, because we don't want to check inside C++11\n  # raw strings,\n  raw = clean_lines.lines_without_raw_strings\n  line = raw[linenum]\n\n  # Before nixing comments, check if the line is blank for no good\n  # reason.  This includes the first line after a block is opened, and\n  # blank lines at the end of a function (ie, right before a line like '}'\n  #\n  # Skip all the blank line checks if we are immediately inside a\n  # namespace body.  In other words, don't issue blank line warnings\n  # for this block:\n  #   namespace {\n  #\n  #   }\n  #\n  # A warning about missing end of namespace comments will be issued instead.\n  #\n  # Also skip blank line checks for 'extern \"C\"' blocks, which are formatted\n  # like namespaces.\n  if (IsBlankLine(line) and\n      not nesting_state.InNamespaceBody() and\n      not nesting_state.InExternC()):\n    elided = clean_lines.elided\n    prev_line = elided[linenum - 1]\n    prevbrace = prev_line.rfind('{')\n    # TODO(unknown): Don't complain if line before blank line, and line after,\n    #                both start with alnums and are indented the same amount.\n    #                This ignores whitespace at the start of a namespace block\n    #                because those are not usually indented.\n    if prevbrace != -1 and prev_line[prevbrace:].find('}') == -1:\n      # OK, we have a blank line at the start of a code block.  Before we\n      # complain, we check if it is an exception to the rule: The previous\n      # non-empty line has the parameters of a function header that are indented\n      # 4 spaces (because they did not fit in a 80 column line when placed on\n      # the same line as the function name).  We also check for the case where\n      # the previous line is indented 6 spaces, which may happen when the\n      # initializers of a constructor do not fit into a 80 column line.\n      exception = False\n      if Match(r' {6}\\w', prev_line):  # Initializer list?\n        # We are looking for the opening column of initializer list, which\n        # should be indented 4 spaces to cause 6 space indentation afterwards.\n        search_position = linenum-2\n        while (search_position >= 0\n               and Match(r' {6}\\w', elided[search_position])):\n          search_position -= 1\n        exception = (search_position >= 0\n                     and elided[search_position][:5] == '    :')\n      else:\n        # Search for the function arguments or an initializer list.  We use a\n        # simple heuristic here: If the line is indented 4 spaces; and we have a\n        # closing paren, without the opening paren, followed by an opening brace\n        # or colon (for initializer lists) we assume that it is the last line of\n        # a function header.  If we have a colon indented 4 spaces, it is an\n        # initializer list.\n        exception = (Match(r' {4}\\w[^\\(]*\\)\\s*(const\\s*)?(\\{\\s*$|:)',\n                           prev_line)\n                     or Match(r' {4}:', prev_line))\n\n      if not exception:\n        error(filename, linenum, 'whitespace/blank_line', 2,\n              'Redundant blank line at the start of a code block '\n              'should be deleted.')\n    # Ignore blank lines at the end of a block in a long if-else\n    # chain, like this:\n    #   if (condition1) {\n    #     // Something followed by a blank line\n    #\n    #   } else if (condition2) {\n    #     // Something else\n    #   }\n    if linenum + 1 < clean_lines.NumLines():\n      next_line = raw[linenum + 1]\n      if (next_line\n          and Match(r'\\s*}', next_line)\n          and next_line.find('} else ') == -1):\n        error(filename, linenum, 'whitespace/blank_line', 3,\n              'Redundant blank line at the end of a code block '\n              'should be deleted.')\n\n    matched = Match(r'\\s*(public|protected|private):', prev_line)\n    if matched:\n      error(filename, linenum, 'whitespace/blank_line', 3,\n            'Do not leave a blank line after \"%s:\"' % matched.group(1))\n\n  # Next, check comments\n  next_line_start = 0\n  if linenum + 1 < clean_lines.NumLines():\n    next_line = raw[linenum + 1]\n    next_line_start = len(next_line) - len(next_line.lstrip())\n  CheckComment(line, filename, linenum, next_line_start, error)\n\n  # get rid of comments and strings\n  line = clean_lines.elided[linenum]\n\n  # You shouldn't have spaces before your brackets, except maybe after\n  # 'delete []', 'return []() {};', or 'auto [abc, ...] = ...;'.\n  if Search(r'\\w\\s+\\[', line) and not Search(r'(?:auto&?|delete|return)\\s+\\[', line):\n    error(filename, linenum, 'whitespace/braces', 5,\n          'Extra space before [')\n\n  # In range-based for, we wanted spaces before and after the colon, but\n  # not around \"::\" tokens that might appear.\n  if (Search(r'for *\\(.*[^:]:[^: ]', line) or\n      Search(r'for *\\(.*[^: ]:[^:]', line)):\n    error(filename, linenum, 'whitespace/forcolon', 2,\n          'Missing space around colon in range-based for loop')\n\n\ndef CheckOperatorSpacing(filename, clean_lines, linenum, error):\n  \"\"\"Checks for horizontal spacing around operators.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n\n  # Don't try to do spacing checks for operator methods.  Do this by\n  # replacing the troublesome characters with something else,\n  # preserving column position for all other characters.\n  #\n  # The replacement is done repeatedly to avoid false positives from\n  # operators that call operators.\n  while True:\n    match = Match(r'^(.*\\boperator\\b)(\\S+)(\\s*\\(.*)$', line)\n    if match:\n      line = match.group(1) + ('_' * len(match.group(2))) + match.group(3)\n    else:\n      break\n\n  # We allow no-spaces around = within an if: \"if ( (a=Foo()) == 0 )\".\n  # Otherwise not.  Note we only check for non-spaces on *both* sides;\n  # sometimes people put non-spaces on one side when aligning ='s among\n  # many lines (not that this is behavior that I approve of...)\n  if ((Search(r'[\\w.]=', line) or\n       Search(r'=[\\w.]', line))\n      and not Search(r'\\b(if|while|for) ', line)\n      # Operators taken from [lex.operators] in C++11 standard.\n      and not Search(r'(>=|<=|==|!=|&=|\\^=|\\|=|\\+=|\\*=|\\/=|\\%=)', line)\n      and not Search(r'operator=', line)):\n    error(filename, linenum, 'whitespace/operators', 4,\n          'Missing spaces around =')\n\n  # It's ok not to have spaces around binary operators like + - * /, but if\n  # there's too little whitespace, we get concerned.  It's hard to tell,\n  # though, so we punt on this one for now.  TODO.\n\n  # You should always have whitespace around binary operators.\n  #\n  # Check <= and >= first to avoid false positives with < and >, then\n  # check non-include lines for spacing around < and >.\n  #\n  # If the operator is followed by a comma, assume it's be used in a\n  # macro context and don't do any checks.  This avoids false\n  # positives.\n  #\n  # Note that && is not included here.  This is because there are too\n  # many false positives due to RValue references.\n  match = Search(r'[^<>=!\\s](==|!=|<=|>=|\\|\\|)[^<>=!\\s,;\\)]', line)\n  if match:\n    error(filename, linenum, 'whitespace/operators', 3,\n          'Missing spaces around %s' % match.group(1))\n  elif not Match(r'#.*include', line):\n    # Look for < that is not surrounded by spaces.  This is only\n    # triggered if both sides are missing spaces, even though\n    # technically should should flag if at least one side is missing a\n    # space.  This is done to avoid some false positives with shifts.\n    match = Match(r'^(.*[^\\s<])<[^\\s=<,]', line)\n    if match:\n      (_, _, end_pos) = CloseExpression(\n          clean_lines, linenum, len(match.group(1)))\n      if end_pos <= -1:\n        error(filename, linenum, 'whitespace/operators', 3,\n              'Missing spaces around <')\n\n    # Look for > that is not surrounded by spaces.  Similar to the\n    # above, we only trigger if both sides are missing spaces to avoid\n    # false positives with shifts.\n    match = Match(r'^(.*[^-\\s>])>[^\\s=>,]', line)\n    if match:\n      (_, _, start_pos) = ReverseCloseExpression(\n          clean_lines, linenum, len(match.group(1)))\n      if start_pos <= -1:\n        error(filename, linenum, 'whitespace/operators', 3,\n              'Missing spaces around >')\n\n  # We allow no-spaces around << when used like this: 10<<20, but\n  # not otherwise (particularly, not when used as streams)\n  #\n  # We also allow operators following an opening parenthesis, since\n  # those tend to be macros that deal with operators.\n  match = Search(r'(operator|[^\\s(<])(?:L|UL|LL|ULL|l|ul|ll|ull)?<<([^\\s,=<])', line)\n  if (match and not (match.group(1).isdigit() and match.group(2).isdigit()) and\n      not (match.group(1) == 'operator' and match.group(2) == ';')):\n    error(filename, linenum, 'whitespace/operators', 3,\n          'Missing spaces around <<')\n\n  # We allow no-spaces around >> for almost anything.  This is because\n  # C++11 allows \">>\" to close nested templates, which accounts for\n  # most cases when \">>\" is not followed by a space.\n  #\n  # We still warn on \">>\" followed by alpha character, because that is\n  # likely due to \">>\" being used for right shifts, e.g.:\n  #   value >> alpha\n  #\n  # When \">>\" is used to close templates, the alphanumeric letter that\n  # follows would be part of an identifier, and there should still be\n  # a space separating the template type and the identifier.\n  #   type<type<type>> alpha\n  match = Search(r'>>[a-zA-Z_]', line)\n  if match:\n    error(filename, linenum, 'whitespace/operators', 3,\n          'Missing spaces around >>')\n\n  # There shouldn't be space around unary operators\n  match = Search(r'(!\\s|~\\s|[\\s]--[\\s;]|[\\s]\\+\\+[\\s;])', line)\n  if match:\n    error(filename, linenum, 'whitespace/operators', 4,\n          'Extra space for operator %s' % match.group(1))\n\n\ndef CheckParenthesisSpacing(filename, clean_lines, linenum, error):\n  \"\"\"Checks for horizontal spacing around parentheses.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n\n  # No spaces after an if, while, switch, or for\n  match = Search(r' (if\\(|for\\(|while\\(|switch\\()', line)\n  if match:\n    error(filename, linenum, 'whitespace/parens', 5,\n          'Missing space before ( in %s' % match.group(1))\n\n  # For if/for/while/switch, the left and right parens should be\n  # consistent about how many spaces are inside the parens, and\n  # there should either be zero or one spaces inside the parens.\n  # We don't want: \"if ( foo)\" or \"if ( foo   )\".\n  # Exception: \"for ( ; foo; bar)\" and \"for (foo; bar; )\" are allowed.\n  match = Search(r'\\b(if|for|while|switch)\\s*'\n                 r'\\(([ ]*)(.).*[^ ]+([ ]*)\\)\\s*{\\s*$',\n                 line)\n  if match:\n    if len(match.group(2)) != len(match.group(4)):\n      if not (match.group(3) == ';' and\n              len(match.group(2)) == 1 + len(match.group(4)) or\n              not match.group(2) and Search(r'\\bfor\\s*\\(.*; \\)', line)):\n        error(filename, linenum, 'whitespace/parens', 5,\n              'Mismatching spaces inside () in %s' % match.group(1))\n    if len(match.group(2)) not in [0, 1]:\n      error(filename, linenum, 'whitespace/parens', 5,\n            'Should have zero or one spaces inside ( and ) in %s' %\n            match.group(1))\n\n\ndef CheckCommaSpacing(filename, clean_lines, linenum, error):\n  \"\"\"Checks for horizontal spacing near commas and semicolons.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  raw = clean_lines.lines_without_raw_strings\n  line = clean_lines.elided[linenum]\n\n  # You should always have a space after a comma (either as fn arg or operator)\n  #\n  # This does not apply when the non-space character following the\n  # comma is another comma, since the only time when that happens is\n  # for empty macro arguments.\n  #\n  # We run this check in two passes: first pass on elided lines to\n  # verify that lines contain missing whitespaces, second pass on raw\n  # lines to confirm that those missing whitespaces are not due to\n  # elided comments.\n  if (Search(r',[^,\\s]', ReplaceAll(r'\\boperator\\s*,\\s*\\(', 'F(', line)) and\n      Search(r',[^,\\s]', raw[linenum])):\n    error(filename, linenum, 'whitespace/comma', 3,\n          'Missing space after ,')\n\n  # You should always have a space after a semicolon\n  # except for few corner cases\n  # TODO(unknown): clarify if 'if (1) { return 1;}' is requires one more\n  # space after ;\n  if Search(r';[^\\s};\\\\)/]', line):\n    error(filename, linenum, 'whitespace/semicolon', 3,\n          'Missing space after ;')\n\n\ndef _IsType(clean_lines, nesting_state, expr):\n  \"\"\"Check if expression looks like a type name, returns true if so.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    nesting_state: A NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    expr: The expression to check.\n  Returns:\n    True, if token looks like a type.\n  \"\"\"\n  # Keep only the last token in the expression\n  last_word = Match(r'^.*(\\b\\S+)$', expr)\n  if last_word:\n    token = last_word.group(1)\n  else:\n    token = expr\n\n  # Match native types and stdint types\n  if _TYPES.match(token):\n    return True\n\n  # Try a bit harder to match templated types.  Walk up the nesting\n  # stack until we find something that resembles a typename\n  # declaration for what we are looking for.\n  typename_pattern = (r'\\b(?:typename|class|struct)\\s+' + re.escape(token) +\n                      r'\\b')\n  block_index = len(nesting_state.stack) - 1\n  while block_index >= 0:\n    if isinstance(nesting_state.stack[block_index], _NamespaceInfo):\n      return False\n\n    # Found where the opening brace is.  We want to scan from this\n    # line up to the beginning of the function, minus a few lines.\n    #   template <typename Type1,  // stop scanning here\n    #             ...>\n    #   class C\n    #     : public ... {  // start scanning here\n    last_line = nesting_state.stack[block_index].starting_linenum\n\n    next_block_start = 0\n    if block_index > 0:\n      next_block_start = nesting_state.stack[block_index - 1].starting_linenum\n    first_line = last_line\n    while first_line >= next_block_start:\n      if clean_lines.elided[first_line].find('template') >= 0:\n        break\n      first_line -= 1\n    if first_line < next_block_start:\n      # Didn't find any \"template\" keyword before reaching the next block,\n      # there are probably no template things to check for this block\n      block_index -= 1\n      continue\n\n    # Look for typename in the specified range\n    for i in xrange(first_line, last_line + 1, 1):\n      if Search(typename_pattern, clean_lines.elided[i]):\n        return True\n    block_index -= 1\n\n  return False\n\n\ndef CheckBracesSpacing(filename, clean_lines, linenum, nesting_state, error):\n  \"\"\"Checks for horizontal spacing near commas.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    nesting_state: A NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n\n  # Except after an opening paren, or after another opening brace (in case of\n  # an initializer list, for instance), you should have spaces before your\n  # braces when they are delimiting blocks, classes, namespaces etc.\n  # And since you should never have braces at the beginning of a line,\n  # this is an easy test.  Except that braces used for initialization don't\n  # follow the same rule; we often don't want spaces before those.\n  match = Match(r'^(.*[^ ({>]){', line)\n\n  if match:\n    # Try a bit harder to check for brace initialization.  This\n    # happens in one of the following forms:\n    #   Constructor() : initializer_list_{} { ... }\n    #   Constructor{}.MemberFunction()\n    #   Type variable{};\n    #   FunctionCall(type{}, ...);\n    #   LastArgument(..., type{});\n    #   LOG(INFO) << type{} << \" ...\";\n    #   map_of_type[{...}] = ...;\n    #   ternary = expr ? new type{} : nullptr;\n    #   OuterTemplate<InnerTemplateConstructor<Type>{}>\n    #\n    # We check for the character following the closing brace, and\n    # silence the warning if it's one of those listed above, i.e.\n    # \"{.;,)<>]:\".\n    #\n    # To account for nested initializer list, we allow any number of\n    # closing braces up to \"{;,)<\".  We can't simply silence the\n    # warning on first sight of closing brace, because that would\n    # cause false negatives for things that are not initializer lists.\n    #   Silence this:         But not this:\n    #     Outer{                if (...) {\n    #       Inner{...}            if (...){  // Missing space before {\n    #     };                    }\n    #\n    # There is a false negative with this approach if people inserted\n    # spurious semicolons, e.g. \"if (cond){};\", but we will catch the\n    # spurious semicolon with a separate check.\n    leading_text = match.group(1)\n    (endline, endlinenum, endpos) = CloseExpression(\n        clean_lines, linenum, len(match.group(1)))\n    trailing_text = ''\n    if endpos > -1:\n      trailing_text = endline[endpos:]\n    for offset in xrange(endlinenum + 1,\n                         min(endlinenum + 3, clean_lines.NumLines() - 1)):\n      trailing_text += clean_lines.elided[offset]\n    # We also suppress warnings for `uint64_t{expression}` etc., as the style\n    # guide recommends brace initialization for integral types to avoid\n    # overflow/truncation.\n    if (not Match(r'^[\\s}]*[{.;,)<>\\]:]', trailing_text)\n        and not _IsType(clean_lines, nesting_state, leading_text)):\n      error(filename, linenum, 'whitespace/braces', 5,\n            'Missing space before {')\n\n  # Make sure '} else {' has spaces.\n  if Search(r'}else', line):\n    error(filename, linenum, 'whitespace/braces', 5,\n          'Missing space before else')\n\n  # You shouldn't have a space before a semicolon at the end of the line.\n  # There's a special case for \"for\" since the style guide allows space before\n  # the semicolon there.\n  if Search(r':\\s*;\\s*$', line):\n    error(filename, linenum, 'whitespace/semicolon', 5,\n          'Semicolon defining empty statement. Use {} instead.')\n  elif Search(r'^\\s*;\\s*$', line):\n    error(filename, linenum, 'whitespace/semicolon', 5,\n          'Line contains only semicolon. If this should be an empty statement, '\n          'use {} instead.')\n  elif (Search(r'\\s+;\\s*$', line) and\n        not Search(r'\\bfor\\b', line)):\n    error(filename, linenum, 'whitespace/semicolon', 5,\n          'Extra space before last semicolon. If this should be an empty '\n          'statement, use {} instead.')\n\n\ndef IsDecltype(clean_lines, linenum, column):\n  \"\"\"Check if the token ending on (linenum, column) is decltype().\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: the number of the line to check.\n    column: end column of the token to check.\n  Returns:\n    True if this token is decltype() expression, False otherwise.\n  \"\"\"\n  (text, _, start_col) = ReverseCloseExpression(clean_lines, linenum, column)\n  if start_col < 0:\n    return False\n  if Search(r'\\bdecltype\\s*$', text[0:start_col]):\n    return True\n  return False\n\ndef CheckSectionSpacing(filename, clean_lines, class_info, linenum, error):\n  \"\"\"Checks for additional blank line issues related to sections.\n\n  Currently the only thing checked here is blank line before protected/private.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    class_info: A _ClassInfo objects.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  # Skip checks if the class is small, where small means 25 lines or less.\n  # 25 lines seems like a good cutoff since that's the usual height of\n  # terminals, and any class that can't fit in one screen can't really\n  # be considered \"small\".\n  #\n  # Also skip checks if we are on the first line.  This accounts for\n  # classes that look like\n  #   class Foo { public: ... };\n  #\n  # If we didn't find the end of the class, last_line would be zero,\n  # and the check will be skipped by the first condition.\n  if (class_info.last_line - class_info.starting_linenum <= 24 or\n      linenum <= class_info.starting_linenum):\n    return\n\n  matched = Match(r'\\s*(public|protected|private):', clean_lines.lines[linenum])\n  if matched:\n    # Issue warning if the line before public/protected/private was\n    # not a blank line, but don't do this if the previous line contains\n    # \"class\" or \"struct\".  This can happen two ways:\n    #  - We are at the beginning of the class.\n    #  - We are forward-declaring an inner class that is semantically\n    #    private, but needed to be public for implementation reasons.\n    # Also ignores cases where the previous line ends with a backslash as can be\n    # common when defining classes in C macros.\n    prev_line = clean_lines.lines[linenum - 1]\n    if (not IsBlankLine(prev_line) and\n        not Search(r'\\b(class|struct)\\b', prev_line) and\n        not Search(r'\\\\$', prev_line)):\n      # Try a bit harder to find the beginning of the class.  This is to\n      # account for multi-line base-specifier lists, e.g.:\n      #   class Derived\n      #       : public Base {\n      end_class_head = class_info.starting_linenum\n      for i in range(class_info.starting_linenum, linenum):\n        if Search(r'\\{\\s*$', clean_lines.lines[i]):\n          end_class_head = i\n          break\n      if end_class_head < linenum - 1:\n        error(filename, linenum, 'whitespace/blank_line', 3,\n              '\"%s:\" should be preceded by a blank line' % matched.group(1))\n\n\ndef GetPreviousNonBlankLine(clean_lines, linenum):\n  \"\"\"Return the most recent non-blank line and its line number.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file contents.\n    linenum: The number of the line to check.\n\n  Returns:\n    A tuple with two elements.  The first element is the contents of the last\n    non-blank line before the current line, or the empty string if this is the\n    first non-blank line.  The second is the line number of that line, or -1\n    if this is the first non-blank line.\n  \"\"\"\n\n  prevlinenum = linenum - 1\n  while prevlinenum >= 0:\n    prevline = clean_lines.elided[prevlinenum]\n    if not IsBlankLine(prevline):     # if not a blank line...\n      return (prevline, prevlinenum)\n    prevlinenum -= 1\n  return ('', -1)\n\n\ndef CheckBraces(filename, clean_lines, linenum, error):\n  \"\"\"Looks for misplaced braces (e.g. at the end of line).\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n\n  line = clean_lines.elided[linenum]        # get rid of comments and strings\n\n  if Match(r'\\s*{\\s*$', line):\n    # We allow an open brace to start a line in the case where someone is using\n    # braces in a block to explicitly create a new scope, which is commonly used\n    # to control the lifetime of stack-allocated variables.  Braces are also\n    # used for brace initializers inside function calls.  We don't detect this\n    # perfectly: we just don't complain if the last non-whitespace character on\n    # the previous non-blank line is ',', ';', ':', '(', '{', or '}', or if the\n    # previous line starts a preprocessor block. We also allow a brace on the\n    # following line if it is part of an array initialization and would not fit\n    # within the 80 character limit of the preceding line.\n    prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0]\n    if (not Search(r'[,;:}{(]\\s*$', prevline) and\n        not Match(r'\\s*#', prevline) and\n        not (GetLineWidth(prevline) > _line_length - 2 and '[]' in prevline)):\n      error(filename, linenum, 'whitespace/braces', 4,\n            '{ should almost always be at the end of the previous line')\n\n  # An else clause should be on the same line as the preceding closing brace.\n  if Match(r'\\s*else\\b\\s*(?:if\\b|\\{|$)', line):\n    prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0]\n    if Match(r'\\s*}\\s*$', prevline):\n      error(filename, linenum, 'whitespace/newline', 4,\n            'An else should appear on the same line as the preceding }')\n\n  # If braces come on one side of an else, they should be on both.\n  # However, we have to worry about \"else if\" that spans multiple lines!\n  if Search(r'else if\\s*\\(', line):       # could be multi-line if\n    brace_on_left = bool(Search(r'}\\s*else if\\s*\\(', line))\n    # find the ( after the if\n    pos = line.find('else if')\n    pos = line.find('(', pos)\n    if pos > 0:\n      (endline, _, endpos) = CloseExpression(clean_lines, linenum, pos)\n      brace_on_right = endline[endpos:].find('{') != -1\n      if brace_on_left != brace_on_right:    # must be brace after if\n        error(filename, linenum, 'readability/braces', 5,\n              'If an else has a brace on one side, it should have it on both')\n  elif Search(r'}\\s*else[^{]*$', line) or Match(r'[^}]*else\\s*{', line):\n    error(filename, linenum, 'readability/braces', 5,\n          'If an else has a brace on one side, it should have it on both')\n\n  # Likewise, an else should never have the else clause on the same line\n  if Search(r'\\belse [^\\s{]', line) and not Search(r'\\belse if\\b', line):\n    error(filename, linenum, 'whitespace/newline', 4,\n          'Else clause should never be on same line as else (use 2 lines)')\n\n  # In the same way, a do/while should never be on one line\n  if Match(r'\\s*do [^\\s{]', line):\n    error(filename, linenum, 'whitespace/newline', 4,\n          'do/while clauses should not be on a single line')\n\n  # Check single-line if/else bodies. The style guide says 'curly braces are not\n  # required for single-line statements'. We additionally allow multi-line,\n  # single statements, but we reject anything with more than one semicolon in\n  # it. This means that the first semicolon after the if should be at the end of\n  # its line, and the line after that should have an indent level equal to or\n  # lower than the if. We also check for ambiguous if/else nesting without\n  # braces.\n  if_else_match = Search(r'\\b(if\\s*\\(|else\\b)', line)\n  if if_else_match and not Match(r'\\s*#', line):\n    if_indent = GetIndentLevel(line)\n    endline, endlinenum, endpos = line, linenum, if_else_match.end()\n    if_match = Search(r'\\bif\\s*\\(', line)\n    if if_match:\n      # This could be a multiline if condition, so find the end first.\n      pos = if_match.end() - 1\n      (endline, endlinenum, endpos) = CloseExpression(clean_lines, linenum, pos)\n    # Check for an opening brace, either directly after the if or on the next\n    # line. If found, this isn't a single-statement conditional.\n    if (not Match(r'\\s*{', endline[endpos:])\n        and not (Match(r'\\s*$', endline[endpos:])\n                 and endlinenum < (len(clean_lines.elided) - 1)\n                 and Match(r'\\s*{', clean_lines.elided[endlinenum + 1]))):\n      while (endlinenum < len(clean_lines.elided)\n             and ';' not in clean_lines.elided[endlinenum][endpos:]):\n        endlinenum += 1\n        endpos = 0\n      if endlinenum < len(clean_lines.elided):\n        endline = clean_lines.elided[endlinenum]\n        # We allow a mix of whitespace and closing braces (e.g. for one-liner\n        # methods) and a single \\ after the semicolon (for macros)\n        endpos = endline.find(';')\n        if not Match(r';[\\s}]*(\\\\?)$', endline[endpos:]):\n          # Semicolon isn't the last character, there's something trailing.\n          # Output a warning if the semicolon is not contained inside\n          # a lambda expression.\n          if not Match(r'^[^{};]*\\[[^\\[\\]]*\\][^{}]*\\{[^{}]*\\}\\s*\\)*[;,]\\s*$',\n                       endline):\n            error(filename, linenum, 'readability/braces', 4,\n                  'If/else bodies with multiple statements require braces')\n        elif endlinenum < len(clean_lines.elided) - 1:\n          # Make sure the next line is dedented\n          next_line = clean_lines.elided[endlinenum + 1]\n          next_indent = GetIndentLevel(next_line)\n          # With ambiguous nested if statements, this will error out on the\n          # if that *doesn't* match the else, regardless of whether it's the\n          # inner one or outer one.\n          if (if_match and Match(r'\\s*else\\b', next_line)\n              and next_indent != if_indent):\n            error(filename, linenum, 'readability/braces', 4,\n                  'Else clause should be indented at the same level as if. '\n                  'Ambiguous nested if/else chains require braces.')\n          elif next_indent > if_indent:\n            error(filename, linenum, 'readability/braces', 4,\n                  'If/else bodies with multiple statements require braces')\n\n\ndef CheckTrailingSemicolon(filename, clean_lines, linenum, error):\n  \"\"\"Looks for redundant trailing semicolon.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n\n  line = clean_lines.elided[linenum]\n\n  # Block bodies should not be followed by a semicolon.  Due to C++11\n  # brace initialization, there are more places where semicolons are\n  # required than not, so we use a whitelist approach to check these\n  # rather than a blacklist.  These are the places where \"};\" should\n  # be replaced by just \"}\":\n  # 1. Some flavor of block following closing parenthesis:\n  #    for (;;) {};\n  #    while (...) {};\n  #    switch (...) {};\n  #    Function(...) {};\n  #    if (...) {};\n  #    if (...) else if (...) {};\n  #\n  # 2. else block:\n  #    if (...) else {};\n  #\n  # 3. const member function:\n  #    Function(...) const {};\n  #\n  # 4. Block following some statement:\n  #    x = 42;\n  #    {};\n  #\n  # 5. Block at the beginning of a function:\n  #    Function(...) {\n  #      {};\n  #    }\n  #\n  #    Note that naively checking for the preceding \"{\" will also match\n  #    braces inside multi-dimensional arrays, but this is fine since\n  #    that expression will not contain semicolons.\n  #\n  # 6. Block following another block:\n  #    while (true) {}\n  #    {};\n  #\n  # 7. End of namespaces:\n  #    namespace {};\n  #\n  #    These semicolons seems far more common than other kinds of\n  #    redundant semicolons, possibly due to people converting classes\n  #    to namespaces.  For now we do not warn for this case.\n  #\n  # Try matching case 1 first.\n  match = Match(r'^(.*\\)\\s*)\\{', line)\n  if match:\n    # Matched closing parenthesis (case 1).  Check the token before the\n    # matching opening parenthesis, and don't warn if it looks like a\n    # macro.  This avoids these false positives:\n    #  - macro that defines a base class\n    #  - multi-line macro that defines a base class\n    #  - macro that defines the whole class-head\n    #\n    # But we still issue warnings for macros that we know are safe to\n    # warn, specifically:\n    #  - TEST, TEST_F, TEST_P, MATCHER, MATCHER_P\n    #  - TYPED_TEST\n    #  - INTERFACE_DEF\n    #  - EXCLUSIVE_LOCKS_REQUIRED, SHARED_LOCKS_REQUIRED, LOCKS_EXCLUDED:\n    #\n    # We implement a whitelist of safe macros instead of a blacklist of\n    # unsafe macros, even though the latter appears less frequently in\n    # google code and would have been easier to implement.  This is because\n    # the downside for getting the whitelist wrong means some extra\n    # semicolons, while the downside for getting the blacklist wrong\n    # would result in compile errors.\n    #\n    # In addition to macros, we also don't want to warn on\n    #  - Compound literals\n    #  - Lambdas\n    #  - alignas specifier with anonymous structs\n    #  - decltype\n    closing_brace_pos = match.group(1).rfind(')')\n    opening_parenthesis = ReverseCloseExpression(\n        clean_lines, linenum, closing_brace_pos)\n    if opening_parenthesis[2] > -1:\n      line_prefix = opening_parenthesis[0][0:opening_parenthesis[2]]\n      macro = Search(r'\\b([A-Z_][A-Z0-9_]*)\\s*$', line_prefix)\n      func = Match(r'^(.*\\])\\s*$', line_prefix)\n      if ((macro and\n           macro.group(1) not in (\n               'TEST', 'TEST_F', 'MATCHER', 'MATCHER_P', 'TYPED_TEST',\n               'EXCLUSIVE_LOCKS_REQUIRED', 'SHARED_LOCKS_REQUIRED',\n               'LOCKS_EXCLUDED', 'INTERFACE_DEF')) or\n          (func and not Search(r'\\boperator\\s*\\[\\s*\\]', func.group(1))) or\n          Search(r'\\b(?:struct|union)\\s+alignas\\s*$', line_prefix) or\n          Search(r'\\bdecltype$', line_prefix) or\n          Search(r'\\s+=\\s*$', line_prefix)):\n        match = None\n    if (match and\n        opening_parenthesis[1] > 1 and\n        Search(r'\\]\\s*$', clean_lines.elided[opening_parenthesis[1] - 1])):\n      # Multi-line lambda-expression\n      match = None\n\n  else:\n    # Try matching cases 2-3.\n    match = Match(r'^(.*(?:else|\\)\\s*const)\\s*)\\{', line)\n    if not match:\n      # Try matching cases 4-6.  These are always matched on separate lines.\n      #\n      # Note that we can't simply concatenate the previous line to the\n      # current line and do a single match, otherwise we may output\n      # duplicate warnings for the blank line case:\n      #   if (cond) {\n      #     // blank line\n      #   }\n      prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0]\n      if prevline and Search(r'[;{}]\\s*$', prevline):\n        match = Match(r'^(\\s*)\\{', line)\n\n  # Check matching closing brace\n  if match:\n    (endline, endlinenum, endpos) = CloseExpression(\n        clean_lines, linenum, len(match.group(1)))\n    if endpos > -1 and Match(r'^\\s*;', endline[endpos:]):\n      # Current {} pair is eligible for semicolon check, and we have found\n      # the redundant semicolon, output warning here.\n      #\n      # Note: because we are scanning forward for opening braces, and\n      # outputting warnings for the matching closing brace, if there are\n      # nested blocks with trailing semicolons, we will get the error\n      # messages in reversed order.\n\n      # We need to check the line forward for NOLINT\n      raw_lines = clean_lines.raw_lines\n      ParseNolintSuppressions(filename, raw_lines[endlinenum-1], endlinenum-1,\n                              error)\n      ParseNolintSuppressions(filename, raw_lines[endlinenum], endlinenum,\n                              error)\n\n      error(filename, endlinenum, 'readability/braces', 4,\n            \"You don't need a ; after a }\")\n\n\ndef CheckEmptyBlockBody(filename, clean_lines, linenum, error):\n  \"\"\"Look for empty loop/conditional body with only a single semicolon.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n\n  # Search for loop keywords at the beginning of the line.  Because only\n  # whitespaces are allowed before the keywords, this will also ignore most\n  # do-while-loops, since those lines should start with closing brace.\n  #\n  # We also check \"if\" blocks here, since an empty conditional block\n  # is likely an error.\n  line = clean_lines.elided[linenum]\n  matched = Match(r'\\s*(for|while|if)\\s*\\(', line)\n  if matched:\n    # Find the end of the conditional expression.\n    (end_line, end_linenum, end_pos) = CloseExpression(\n        clean_lines, linenum, line.find('('))\n\n    # Output warning if what follows the condition expression is a semicolon.\n    # No warning for all other cases, including whitespace or newline, since we\n    # have a separate check for semicolons preceded by whitespace.\n    if end_pos >= 0 and Match(r';', end_line[end_pos:]):\n      if matched.group(1) == 'if':\n        error(filename, end_linenum, 'whitespace/empty_conditional_body', 5,\n              'Empty conditional bodies should use {}')\n      else:\n        error(filename, end_linenum, 'whitespace/empty_loop_body', 5,\n              'Empty loop bodies should use {} or continue')\n\n    # Check for if statements that have completely empty bodies (no comments)\n    # and no else clauses.\n    if end_pos >= 0 and matched.group(1) == 'if':\n      # Find the position of the opening { for the if statement.\n      # Return without logging an error if it has no brackets.\n      opening_linenum = end_linenum\n      opening_line_fragment = end_line[end_pos:]\n      # Loop until EOF or find anything that's not whitespace or opening {.\n      while not Search(r'^\\s*\\{', opening_line_fragment):\n        if Search(r'^(?!\\s*$)', opening_line_fragment):\n          # Conditional has no brackets.\n          return\n        opening_linenum += 1\n        if opening_linenum == len(clean_lines.elided):\n          # Couldn't find conditional's opening { or any code before EOF.\n          return\n        opening_line_fragment = clean_lines.elided[opening_linenum]\n      # Set opening_line (opening_line_fragment may not be entire opening line).\n      opening_line = clean_lines.elided[opening_linenum]\n\n      # Find the position of the closing }.\n      opening_pos = opening_line_fragment.find('{')\n      if opening_linenum == end_linenum:\n        # We need to make opening_pos relative to the start of the entire line.\n        opening_pos += end_pos\n      (closing_line, closing_linenum, closing_pos) = CloseExpression(\n          clean_lines, opening_linenum, opening_pos)\n      if closing_pos < 0:\n        return\n\n      # Now construct the body of the conditional. This consists of the portion\n      # of the opening line after the {, all lines until the closing line,\n      # and the portion of the closing line before the }.\n      if (clean_lines.raw_lines[opening_linenum] !=\n          CleanseComments(clean_lines.raw_lines[opening_linenum])):\n        # Opening line ends with a comment, so conditional isn't empty.\n        return\n      if closing_linenum > opening_linenum:\n        # Opening line after the {. Ignore comments here since we checked above.\n        bodylist = list(opening_line[opening_pos+1:])\n        # All lines until closing line, excluding closing line, with comments.\n        bodylist.extend(clean_lines.raw_lines[opening_linenum+1:closing_linenum])\n        # Closing line before the }. Won't (and can't) have comments.\n        bodylist.append(clean_lines.elided[closing_linenum][:closing_pos-1])\n        body = '\\n'.join(bodylist)\n      else:\n        # If statement has brackets and fits on a single line.\n        body = opening_line[opening_pos+1:closing_pos-1]\n\n      # Check if the body is empty\n      if not _EMPTY_CONDITIONAL_BODY_PATTERN.search(body):\n        return\n      # The body is empty. Now make sure there's not an else clause.\n      current_linenum = closing_linenum\n      current_line_fragment = closing_line[closing_pos:]\n      # Loop until EOF or find anything that's not whitespace or else clause.\n      while Search(r'^\\s*$|^(?=\\s*else)', current_line_fragment):\n        if Search(r'^(?=\\s*else)', current_line_fragment):\n          # Found an else clause, so don't log an error.\n          return\n        current_linenum += 1\n        if current_linenum == len(clean_lines.elided):\n          break\n        current_line_fragment = clean_lines.elided[current_linenum]\n\n      # The body is empty and there's no else clause until EOF or other code.\n      error(filename, end_linenum, 'whitespace/empty_if_body', 4,\n            ('If statement had no body and no else clause'))\n\n\ndef FindCheckMacro(line):\n  \"\"\"Find a replaceable CHECK-like macro.\n\n  Args:\n    line: line to search on.\n  Returns:\n    (macro name, start position), or (None, -1) if no replaceable\n    macro is found.\n  \"\"\"\n  for macro in _CHECK_MACROS:\n    i = line.find(macro)\n    if i >= 0:\n      # Find opening parenthesis.  Do a regular expression match here\n      # to make sure that we are matching the expected CHECK macro, as\n      # opposed to some other macro that happens to contain the CHECK\n      # substring.\n      matched = Match(r'^(.*\\b' + macro + r'\\s*)\\(', line)\n      if not matched:\n        continue\n      return (macro, len(matched.group(1)))\n  return (None, -1)\n\n\ndef CheckCheck(filename, clean_lines, linenum, error):\n  \"\"\"Checks the use of CHECK and EXPECT macros.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n\n  # Decide the set of replacement macros that should be suggested\n  lines = clean_lines.elided\n  (check_macro, start_pos) = FindCheckMacro(lines[linenum])\n  if not check_macro:\n    return\n\n  # Find end of the boolean expression by matching parentheses\n  (last_line, end_line, end_pos) = CloseExpression(\n      clean_lines, linenum, start_pos)\n  if end_pos < 0:\n    return\n\n  # If the check macro is followed by something other than a\n  # semicolon, assume users will log their own custom error messages\n  # and don't suggest any replacements.\n  if not Match(r'\\s*;', last_line[end_pos:]):\n    return\n\n  if linenum == end_line:\n    expression = lines[linenum][start_pos + 1:end_pos - 1]\n  else:\n    expression = lines[linenum][start_pos + 1:]\n    for i in xrange(linenum + 1, end_line):\n      expression += lines[i]\n    expression += last_line[0:end_pos - 1]\n\n  # Parse expression so that we can take parentheses into account.\n  # This avoids false positives for inputs like \"CHECK((a < 4) == b)\",\n  # which is not replaceable by CHECK_LE.\n  lhs = ''\n  rhs = ''\n  operator = None\n  while expression:\n    matched = Match(r'^\\s*(<<|<<=|>>|>>=|->\\*|->|&&|\\|\\||'\n                    r'==|!=|>=|>|<=|<|\\()(.*)$', expression)\n    if matched:\n      token = matched.group(1)\n      if token == '(':\n        # Parenthesized operand\n        expression = matched.group(2)\n        (end, _) = FindEndOfExpressionInLine(expression, 0, ['('])\n        if end < 0:\n          return  # Unmatched parenthesis\n        lhs += '(' + expression[0:end]\n        expression = expression[end:]\n      elif token in ('&&', '||'):\n        # Logical and/or operators.  This means the expression\n        # contains more than one term, for example:\n        #   CHECK(42 < a && a < b);\n        #\n        # These are not replaceable with CHECK_LE, so bail out early.\n        return\n      elif token in ('<<', '<<=', '>>', '>>=', '->*', '->'):\n        # Non-relational operator\n        lhs += token\n        expression = matched.group(2)\n      else:\n        # Relational operator\n        operator = token\n        rhs = matched.group(2)\n        break\n    else:\n      # Unparenthesized operand.  Instead of appending to lhs one character\n      # at a time, we do another regular expression match to consume several\n      # characters at once if possible.  Trivial benchmark shows that this\n      # is more efficient when the operands are longer than a single\n      # character, which is generally the case.\n      matched = Match(r'^([^-=!<>()&|]+)(.*)$', expression)\n      if not matched:\n        matched = Match(r'^(\\s*\\S)(.*)$', expression)\n        if not matched:\n          break\n      lhs += matched.group(1)\n      expression = matched.group(2)\n\n  # Only apply checks if we got all parts of the boolean expression\n  if not (lhs and operator and rhs):\n    return\n\n  # Check that rhs do not contain logical operators.  We already know\n  # that lhs is fine since the loop above parses out && and ||.\n  if rhs.find('&&') > -1 or rhs.find('||') > -1:\n    return\n\n  # At least one of the operands must be a constant literal.  This is\n  # to avoid suggesting replacements for unprintable things like\n  # CHECK(variable != iterator)\n  #\n  # The following pattern matches decimal, hex integers, strings, and\n  # characters (in that order).\n  lhs = lhs.strip()\n  rhs = rhs.strip()\n  match_constant = r'^([-+]?(\\d+|0[xX][0-9a-fA-F]+)[lLuU]{0,3}|\".*\"|\\'.*\\')$'\n  if Match(match_constant, lhs) or Match(match_constant, rhs):\n    # Note: since we know both lhs and rhs, we can provide a more\n    # descriptive error message like:\n    #   Consider using CHECK_EQ(x, 42) instead of CHECK(x == 42)\n    # Instead of:\n    #   Consider using CHECK_EQ instead of CHECK(a == b)\n    #\n    # We are still keeping the less descriptive message because if lhs\n    # or rhs gets long, the error message might become unreadable.\n    error(filename, linenum, 'readability/check', 2,\n          'Consider using %s instead of %s(a %s b)' % (\n              _CHECK_REPLACEMENT[check_macro][operator],\n              check_macro, operator))\n\n\ndef CheckAltTokens(filename, clean_lines, linenum, error):\n  \"\"\"Check alternative keywords being used in boolean expressions.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n\n  # Avoid preprocessor lines\n  if Match(r'^\\s*#', line):\n    return\n\n  # Last ditch effort to avoid multi-line comments.  This will not help\n  # if the comment started before the current line or ended after the\n  # current line, but it catches most of the false positives.  At least,\n  # it provides a way to workaround this warning for people who use\n  # multi-line comments in preprocessor macros.\n  #\n  # TODO(unknown): remove this once cpplint has better support for\n  # multi-line comments.\n  if line.find('/*') >= 0 or line.find('*/') >= 0:\n    return\n\n  for match in _ALT_TOKEN_REPLACEMENT_PATTERN.finditer(line):\n    error(filename, linenum, 'readability/alt_tokens', 2,\n          'Use operator %s instead of %s' % (\n              _ALT_TOKEN_REPLACEMENT[match.group(1)], match.group(1)))\n\n\ndef GetLineWidth(line):\n  \"\"\"Determines the width of the line in column positions.\n\n  Args:\n    line: A string, which may be a Unicode string.\n\n  Returns:\n    The width of the line in column positions, accounting for Unicode\n    combining characters and wide characters.\n  \"\"\"\n  if isinstance(line, unicode):\n    width = 0\n    for uc in unicodedata.normalize('NFC', line):\n      if unicodedata.east_asian_width(uc) in ('W', 'F'):\n        width += 2\n      elif not unicodedata.combining(uc):\n        # Issue 337\n        # https://mail.python.org/pipermail/python-list/2012-August/628809.html\n        if (sys.version_info.major, sys.version_info.minor) <= (3, 2):\n          # https://github.com/python/cpython/blob/2.7/Include/unicodeobject.h#L81\n          is_wide_build = sysconfig.get_config_var(\"Py_UNICODE_SIZE\") >= 4\n          # https://github.com/python/cpython/blob/2.7/Objects/unicodeobject.c#L564\n          is_low_surrogate = 0xDC00 <= ord(uc) <= 0xDFFF\n          if not is_wide_build and is_low_surrogate:\n            width -= 1\n\n        width += 1\n    return width\n  else:\n    return len(line)\n\n\ndef CheckStyle(filename, clean_lines, linenum, file_extension, nesting_state,\n               error):\n  \"\"\"Checks rules from the 'C++ style rules' section of cppguide.html.\n\n  Most of these rules are hard to test (naming, comment style), but we\n  do what we can.  In particular we check for 2-space indents, line lengths,\n  tab usage, spaces inside code, etc.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    file_extension: The extension (without the dot) of the filename.\n    nesting_state: A NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: The function to call with any errors found.\n  \"\"\"\n\n  # Don't use \"elided\" lines here, otherwise we can't check commented lines.\n  # Don't want to use \"raw\" either, because we don't want to check inside C++11\n  # raw strings,\n  raw_lines = clean_lines.lines_without_raw_strings\n  line = raw_lines[linenum]\n  prev = raw_lines[linenum - 1] if linenum > 0 else ''\n\n  if line.find('\\t') != -1:\n    error(filename, linenum, 'whitespace/tab', 1,\n          'Tab found; better to use spaces')\n\n  # One or three blank spaces at the beginning of the line is weird; it's\n  # hard to reconcile that with 2-space indents.\n  # NOTE: here are the conditions rob pike used for his tests.  Mine aren't\n  # as sophisticated, but it may be worth becoming so:  RLENGTH==initial_spaces\n  # if(RLENGTH > 20) complain = 0;\n  # if(match($0, \" +(error|private|public|protected):\")) complain = 0;\n  # if(match(prev, \"&& *$\")) complain = 0;\n  # if(match(prev, \"\\\\|\\\\| *$\")) complain = 0;\n  # if(match(prev, \"[\\\",=><] *$\")) complain = 0;\n  # if(match($0, \" <<\")) complain = 0;\n  # if(match(prev, \" +for \\\\(\")) complain = 0;\n  # if(prevodd && match(prevprev, \" +for \\\\(\")) complain = 0;\n  scope_or_label_pattern = r'\\s*\\w+\\s*:\\s*\\\\?$'\n  classinfo = nesting_state.InnermostClass()\n  initial_spaces = 0\n  cleansed_line = clean_lines.elided[linenum]\n  while initial_spaces < len(line) and line[initial_spaces] == ' ':\n    initial_spaces += 1\n  # There are certain situations we allow one space, notably for\n  # section labels, and also lines containing multi-line raw strings.\n  # We also don't check for lines that look like continuation lines\n  # (of lines ending in double quotes, commas, equals, or angle brackets)\n  # because the rules for how to indent those are non-trivial.\n  if (not Search(r'[\",=><] *$', prev) and\n      (initial_spaces == 1 or initial_spaces == 3) and\n      not Match(scope_or_label_pattern, cleansed_line) and\n      not (clean_lines.raw_lines[linenum] != line and\n           Match(r'^\\s*\"\"', line))):\n    error(filename, linenum, 'whitespace/indent', 3,\n          'Weird number of spaces at line-start.  '\n          'Are you using a 2-space indent?')\n\n  if line and line[-1].isspace():\n    error(filename, linenum, 'whitespace/end_of_line', 4,\n          'Line ends in whitespace.  Consider deleting these extra spaces.')\n\n  # Check if the line is a header guard.\n  is_header_guard = False\n  if IsHeaderExtension(file_extension):\n    cppvar = GetHeaderGuardCPPVariable(filename)\n    if (line.startswith('#ifndef %s' % cppvar) or\n        line.startswith('#define %s' % cppvar) or\n        line.startswith('#endif  // %s' % cppvar)):\n      is_header_guard = True\n  # #include lines and header guards can be long, since there's no clean way to\n  # split them.\n  #\n  # URLs can be long too.  It's possible to split these, but it makes them\n  # harder to cut&paste.\n  #\n  # The \"$Id:...$\" comment may also get very long without it being the\n  # developers fault.\n  #\n  # Doxygen documentation copying can get pretty long when using an overloaded\n  # function declaration\n  if (not line.startswith('#include') and not is_header_guard and\n      not Match(r'^\\s*//.*http(s?)://\\S*$', line) and\n      not Match(r'^\\s*//\\s*[^\\s]*$', line) and\n      not Match(r'^// \\$Id:.*#[0-9]+ \\$$', line) and\n      not Match(r'^\\s*/// [@\\\\](copydoc|copydetails|copybrief) .*$', line)):\n    line_width = GetLineWidth(line)\n    if line_width > _line_length:\n      error(filename, linenum, 'whitespace/line_length', 2,\n            'Lines should be <= %i characters long' % _line_length)\n\n  if (cleansed_line.count(';') > 1 and\n      # allow simple single line lambdas\n      not Match(r'^[^{};]*\\[[^\\[\\]]*\\][^{}]*\\{[^{}\\n\\r]*\\}',\n                line) and\n      # for loops are allowed two ;'s (and may run over two lines).\n      cleansed_line.find('for') == -1 and\n      (GetPreviousNonBlankLine(clean_lines, linenum)[0].find('for') == -1 or\n       GetPreviousNonBlankLine(clean_lines, linenum)[0].find(';') != -1) and\n      # It's ok to have many commands in a switch case that fits in 1 line\n      not ((cleansed_line.find('case ') != -1 or\n            cleansed_line.find('default:') != -1) and\n           cleansed_line.find('break;') != -1)):\n    error(filename, linenum, 'whitespace/newline', 0,\n          'More than one command on the same line')\n\n  # Some more style checks\n  CheckBraces(filename, clean_lines, linenum, error)\n  CheckTrailingSemicolon(filename, clean_lines, linenum, error)\n  CheckEmptyBlockBody(filename, clean_lines, linenum, error)\n  CheckSpacing(filename, clean_lines, linenum, nesting_state, error)\n  CheckOperatorSpacing(filename, clean_lines, linenum, error)\n  CheckParenthesisSpacing(filename, clean_lines, linenum, error)\n  CheckCommaSpacing(filename, clean_lines, linenum, error)\n  CheckBracesSpacing(filename, clean_lines, linenum, nesting_state, error)\n  CheckSpacingForFunctionCall(filename, clean_lines, linenum, error)\n  CheckCheck(filename, clean_lines, linenum, error)\n  CheckAltTokens(filename, clean_lines, linenum, error)\n  classinfo = nesting_state.InnermostClass()\n  if classinfo:\n    CheckSectionSpacing(filename, clean_lines, classinfo, linenum, error)\n\n\n_RE_PATTERN_INCLUDE = re.compile(r'^\\s*#\\s*include\\s*([<\"])([^>\"]*)[>\"].*$')\n# Matches the first component of a filename delimited by -s and _s. That is:\n#  _RE_FIRST_COMPONENT.match('foo').group(0) == 'foo'\n#  _RE_FIRST_COMPONENT.match('foo.cc').group(0) == 'foo'\n#  _RE_FIRST_COMPONENT.match('foo-bar_baz.cc').group(0) == 'foo'\n#  _RE_FIRST_COMPONENT.match('foo_bar-baz.cc').group(0) == 'foo'\n_RE_FIRST_COMPONENT = re.compile(r'^[^-_.]+')\n\n\ndef _DropCommonSuffixes(filename):\n  \"\"\"Drops common suffixes like _test.cc or -inl.h from filename.\n\n  For example:\n    >>> _DropCommonSuffixes('foo/foo-inl.h')\n    'foo/foo'\n    >>> _DropCommonSuffixes('foo/bar/foo.cc')\n    'foo/bar/foo'\n    >>> _DropCommonSuffixes('foo/foo_internal.h')\n    'foo/foo'\n    >>> _DropCommonSuffixes('foo/foo_unusualinternal.h')\n    'foo/foo_unusualinternal'\n\n  Args:\n    filename: The input filename.\n\n  Returns:\n    The filename with the common suffix removed.\n  \"\"\"\n  for suffix in itertools.chain(\n      ('%s.%s' % (test_suffix.lstrip('_'), ext)\n       for test_suffix, ext in itertools.product(_test_suffixes, GetNonHeaderExtensions())),\n      ('%s.%s' % (suffix, ext)\n       for suffix, ext in itertools.product(['inl', 'imp', 'internal'], GetHeaderExtensions()))):\n    if (filename.endswith(suffix) and len(filename) > len(suffix) and\n        filename[-len(suffix) - 1] in ('-', '_')):\n      return filename[:-len(suffix) - 1]\n  return os.path.splitext(filename)[0]\n\n\ndef _ClassifyInclude(fileinfo, include, is_system):\n  \"\"\"Figures out what kind of header 'include' is.\n\n  Args:\n    fileinfo: The current file cpplint is running over. A FileInfo instance.\n    include: The path to a #included file.\n    is_system: True if the #include used <> rather than \"\".\n\n  Returns:\n    One of the _XXX_HEADER constants.\n\n  For example:\n    >>> _ClassifyInclude(FileInfo('foo/foo.cc'), 'stdio.h', True)\n    _C_SYS_HEADER\n    >>> _ClassifyInclude(FileInfo('foo/foo.cc'), 'string', True)\n    _CPP_SYS_HEADER\n    >>> _ClassifyInclude(FileInfo('foo/foo.cc'), 'foo/foo.h', False)\n    _LIKELY_MY_HEADER\n    >>> _ClassifyInclude(FileInfo('foo/foo_unknown_extension.cc'),\n    ...                  'bar/foo_other_ext.h', False)\n    _POSSIBLE_MY_HEADER\n    >>> _ClassifyInclude(FileInfo('foo/foo.cc'), 'foo/bar.h', False)\n    _OTHER_HEADER\n  \"\"\"\n  # This is a list of all standard c++ header files, except\n  # those already checked for above.\n  is_cpp_h = include in _CPP_HEADERS\n\n  # Headers with C++ extensions shouldn't be considered C system headers\n  if is_system and os.path.splitext(include)[1] in ['.hpp', '.hxx', '.h++']:\n    is_system = False\n\n  if is_system:\n    if is_cpp_h:\n      return _CPP_SYS_HEADER\n    else:\n      return _C_SYS_HEADER\n\n  # If the target file and the include we're checking share a\n  # basename when we drop common extensions, and the include\n  # lives in . , then it's likely to be owned by the target file.\n  target_dir, target_base = (\n      os.path.split(_DropCommonSuffixes(fileinfo.RepositoryName())))\n  include_dir, include_base = os.path.split(_DropCommonSuffixes(include))\n  target_dir_pub = os.path.normpath(target_dir + '/../public')\n  target_dir_pub = target_dir_pub.replace('\\\\', '/')\n  if target_base == include_base and (\n      include_dir == target_dir or\n      include_dir == target_dir_pub):\n    return _LIKELY_MY_HEADER\n\n  # If the target and include share some initial basename\n  # component, it's possible the target is implementing the\n  # include, so it's allowed to be first, but we'll never\n  # complain if it's not there.\n  target_first_component = _RE_FIRST_COMPONENT.match(target_base)\n  include_first_component = _RE_FIRST_COMPONENT.match(include_base)\n  if (target_first_component and include_first_component and\n      target_first_component.group(0) ==\n      include_first_component.group(0)):\n    return _POSSIBLE_MY_HEADER\n\n  return _OTHER_HEADER\n\n\n\ndef CheckIncludeLine(filename, clean_lines, linenum, include_state, error):\n  \"\"\"Check rules that are applicable to #include lines.\n\n  Strings on #include lines are NOT removed from elided line, to make\n  certain tasks easier. However, to prevent false positives, checks\n  applicable to #include lines in CheckLanguage must be put here.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    include_state: An _IncludeState instance in which the headers are inserted.\n    error: The function to call with any errors found.\n  \"\"\"\n  fileinfo = FileInfo(filename)\n  line = clean_lines.lines[linenum]\n\n  # \"include\" should use the new style \"foo/bar.h\" instead of just \"bar.h\"\n  # Only do this check if the included header follows google naming\n  # conventions.  If not, assume that it's a 3rd party API that\n  # requires special include conventions.\n  #\n  # We also make an exception for Lua headers, which follow google\n  # naming convention but not the include convention.\n  match = Match(r'#include\\s*\"([^/]+\\.h)\"', line)\n  if match and not _THIRD_PARTY_HEADERS_PATTERN.match(match.group(1)):\n    error(filename, linenum, 'build/include_subdir', 4,\n          'Include the directory when naming .h files')\n\n  # we shouldn't include a file more than once. actually, there are a\n  # handful of instances where doing so is okay, but in general it's\n  # not.\n  match = _RE_PATTERN_INCLUDE.search(line)\n  if match:\n    include = match.group(2)\n    is_system = (match.group(1) == '<')\n    duplicate_line = include_state.FindHeader(include)\n    if duplicate_line >= 0:\n      error(filename, linenum, 'build/include', 4,\n            '\"%s\" already included at %s:%s' %\n            (include, filename, duplicate_line))\n      return\n\n    for extension in GetNonHeaderExtensions():\n      if (include.endswith('.' + extension) and\n          os.path.dirname(fileinfo.RepositoryName()) != os.path.dirname(include)):\n        error(filename, linenum, 'build/include', 4,\n              'Do not include .' + extension + ' files from other packages')\n        return\n\n    # We DO want to include a 3rd party looking header if it matches the\n    # filename. Otherwise we get an erroneous error \"...should include its\n    # header\" error later.\n    third_src_header = False\n    for ext in GetHeaderExtensions():\n      basefilename = filename[0:len(filename) - len(fileinfo.Extension())]\n      headerfile = basefilename + '.' + ext\n      headername = FileInfo(headerfile).RepositoryName()\n      if headername in include or include in headername:\n        third_src_header = True\n        break\n\n    if third_src_header or not _THIRD_PARTY_HEADERS_PATTERN.match(include):\n      include_state.include_list[-1].append((include, linenum))\n\n      # We want to ensure that headers appear in the right order:\n      # 1) for foo.cc, foo.h  (preferred location)\n      # 2) c system files\n      # 3) cpp system files\n      # 4) for foo.cc, foo.h  (deprecated location)\n      # 5) other google headers\n      #\n      # We classify each include statement as one of those 5 types\n      # using a number of techniques. The include_state object keeps\n      # track of the highest type seen, and complains if we see a\n      # lower type after that.\n      error_message = include_state.CheckNextIncludeOrder(\n          _ClassifyInclude(fileinfo, include, is_system))\n      if error_message:\n        error(filename, linenum, 'build/include_order', 4,\n              '%s. Should be: %s.h, c system, c++ system, other.' %\n              (error_message, fileinfo.BaseName()))\n      canonical_include = include_state.CanonicalizeAlphabeticalOrder(include)\n      if not include_state.IsInAlphabeticalOrder(\n          clean_lines, linenum, canonical_include):\n        error(filename, linenum, 'build/include_alpha', 4,\n              'Include \"%s\" not in alphabetical order' % include)\n      include_state.SetLastHeader(canonical_include)\n\n\n\ndef _GetTextInside(text, start_pattern):\n  r\"\"\"Retrieves all the text between matching open and close parentheses.\n\n  Given a string of lines and a regular expression string, retrieve all the text\n  following the expression and between opening punctuation symbols like\n  (, [, or {, and the matching close-punctuation symbol. This properly nested\n  occurrences of the punctuations, so for the text like\n    printf(a(), b(c()));\n  a call to _GetTextInside(text, r'printf\\(') will return 'a(), b(c())'.\n  start_pattern must match string having an open punctuation symbol at the end.\n\n  Args:\n    text: The lines to extract text. Its comments and strings must be elided.\n           It can be single line and can span multiple lines.\n    start_pattern: The regexp string indicating where to start extracting\n                   the text.\n  Returns:\n    The extracted text.\n    None if either the opening string or ending punctuation could not be found.\n  \"\"\"\n  # TODO(unknown): Audit cpplint.py to see what places could be profitably\n  # rewritten to use _GetTextInside (and use inferior regexp matching today).\n\n  # Give opening punctuations to get the matching close-punctuations.\n  matching_punctuation = {'(': ')', '{': '}', '[': ']'}\n  closing_punctuation = set(itervalues(matching_punctuation))\n\n  # Find the position to start extracting text.\n  match = re.search(start_pattern, text, re.M)\n  if not match:  # start_pattern not found in text.\n    return None\n  start_position = match.end(0)\n\n  assert start_position > 0, (\n      'start_pattern must ends with an opening punctuation.')\n  assert text[start_position - 1] in matching_punctuation, (\n      'start_pattern must ends with an opening punctuation.')\n  # Stack of closing punctuations we expect to have in text after position.\n  punctuation_stack = [matching_punctuation[text[start_position - 1]]]\n  position = start_position\n  while punctuation_stack and position < len(text):\n    if text[position] == punctuation_stack[-1]:\n      punctuation_stack.pop()\n    elif text[position] in closing_punctuation:\n      # A closing punctuation without matching opening punctuations.\n      return None\n    elif text[position] in matching_punctuation:\n      punctuation_stack.append(matching_punctuation[text[position]])\n    position += 1\n  if punctuation_stack:\n    # Opening punctuations left without matching close-punctuations.\n    return None\n  # punctuations match.\n  return text[start_position:position - 1]\n\n\n# Patterns for matching call-by-reference parameters.\n#\n# Supports nested templates up to 2 levels deep using this messy pattern:\n#   < (?: < (?: < [^<>]*\n#               >\n#           |   [^<>] )*\n#         >\n#     |   [^<>] )*\n#   >\n_RE_PATTERN_IDENT = r'[_a-zA-Z]\\w*'  # =~ [[:alpha:]][[:alnum:]]*\n_RE_PATTERN_TYPE = (\n    r'(?:const\\s+)?(?:typename\\s+|class\\s+|struct\\s+|union\\s+|enum\\s+)?'\n    r'(?:\\w|'\n    r'\\s*<(?:<(?:<[^<>]*>|[^<>])*>|[^<>])*>|'\n    r'::)+')\n# A call-by-reference parameter ends with '& identifier'.\n_RE_PATTERN_REF_PARAM = re.compile(\n    r'(' + _RE_PATTERN_TYPE + r'(?:\\s*(?:\\bconst\\b|[*]))*\\s*'\n    r'&\\s*' + _RE_PATTERN_IDENT + r')\\s*(?:=[^,()]+)?[,)]')\n# A call-by-const-reference parameter either ends with 'const& identifier'\n# or looks like 'const type& identifier' when 'type' is atomic.\n_RE_PATTERN_CONST_REF_PARAM = (\n    r'(?:.*\\s*\\bconst\\s*&\\s*' + _RE_PATTERN_IDENT +\n    r'|const\\s+' + _RE_PATTERN_TYPE + r'\\s*&\\s*' + _RE_PATTERN_IDENT + r')')\n# Stream types.\n_RE_PATTERN_REF_STREAM_PARAM = (\n    r'(?:.*stream\\s*&\\s*' + _RE_PATTERN_IDENT + r')')\n\n\ndef CheckLanguage(filename, clean_lines, linenum, file_extension,\n                  include_state, nesting_state, error):\n  \"\"\"Checks rules from the 'C++ language rules' section of cppguide.html.\n\n  Some of these rules are hard to test (function overloading, using\n  uint32 inappropriately), but we do the best we can.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    file_extension: The extension (without the dot) of the filename.\n    include_state: An _IncludeState instance in which the headers are inserted.\n    nesting_state: A NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: The function to call with any errors found.\n  \"\"\"\n  # If the line is empty or consists of entirely a comment, no need to\n  # check it.\n  line = clean_lines.elided[linenum]\n  if not line:\n    return\n\n  match = _RE_PATTERN_INCLUDE.search(line)\n  if match:\n    CheckIncludeLine(filename, clean_lines, linenum, include_state, error)\n    return\n\n  # Reset include state across preprocessor directives.  This is meant\n  # to silence warnings for conditional includes.\n  match = Match(r'^\\s*#\\s*(if|ifdef|ifndef|elif|else|endif)\\b', line)\n  if match:\n    include_state.ResetSection(match.group(1))\n\n\n  # Perform other checks now that we are sure that this is not an include line\n  CheckCasts(filename, clean_lines, linenum, error)\n  CheckGlobalStatic(filename, clean_lines, linenum, error)\n  CheckPrintf(filename, clean_lines, linenum, error)\n\n  if IsHeaderExtension(file_extension):\n    # TODO(unknown): check that 1-arg constructors are explicit.\n    #                How to tell it's a constructor?\n    #                (handled in CheckForNonStandardConstructs for now)\n    # TODO(unknown): check that classes declare or disable copy/assign\n    #                (level 1 error)\n    pass\n\n  # Check if people are using the verboten C basic types.  The only exception\n  # we regularly allow is \"unsigned short port\" for port.\n  if Search(r'\\bshort port\\b', line):\n    if not Search(r'\\bunsigned short port\\b', line):\n      error(filename, linenum, 'runtime/int', 4,\n            'Use \"unsigned short\" for ports, not \"short\"')\n  else:\n    match = Search(r'\\b(short|long(?! +double)|long long)\\b', line)\n    if match:\n      error(filename, linenum, 'runtime/int', 4,\n            'Use int16/int64/etc, rather than the C type %s' % match.group(1))\n\n  # Check if some verboten operator overloading is going on\n  # TODO(unknown): catch out-of-line unary operator&:\n  #   class X {};\n  #   int operator&(const X& x) { return 42; }  // unary operator&\n  # The trick is it's hard to tell apart from binary operator&:\n  #   class Y { int operator&(const Y& x) { return 23; } }; // binary operator&\n  if Search(r'\\boperator\\s*&\\s*\\(\\s*\\)', line):\n    error(filename, linenum, 'runtime/operator', 4,\n          'Unary operator& is dangerous.  Do not use it.')\n\n  # Check for suspicious usage of \"if\" like\n  # } if (a == b) {\n  if Search(r'\\}\\s*if\\s*\\(', line):\n    error(filename, linenum, 'readability/braces', 4,\n          'Did you mean \"else if\"? If not, start a new line for \"if\".')\n\n  # Check for potential format string bugs like printf(foo).\n  # We constrain the pattern not to pick things like DocidForPrintf(foo).\n  # Not perfect but it can catch printf(foo.c_str()) and printf(foo->c_str())\n  # TODO(unknown): Catch the following case. Need to change the calling\n  # convention of the whole function to process multiple line to handle it.\n  #   printf(\n  #       boy_this_is_a_really_long_variable_that_cannot_fit_on_the_prev_line);\n  printf_args = _GetTextInside(line, r'(?i)\\b(string)?printf\\s*\\(')\n  if printf_args:\n    match = Match(r'([\\w.\\->()]+)$', printf_args)\n    if match and match.group(1) != '__VA_ARGS__':\n      function_name = re.search(r'\\b((?:string)?printf)\\s*\\(',\n                                line, re.I).group(1)\n      error(filename, linenum, 'runtime/printf', 4,\n            'Potential format string bug. Do %s(\"%%s\", %s) instead.'\n            % (function_name, match.group(1)))\n\n  # Check for potential memset bugs like memset(buf, sizeof(buf), 0).\n  match = Search(r'memset\\s*\\(([^,]*),\\s*([^,]*),\\s*0\\s*\\)', line)\n  if match and not Match(r\"^''|-?[0-9]+|0x[0-9A-Fa-f]$\", match.group(2)):\n    error(filename, linenum, 'runtime/memset', 4,\n          'Did you mean \"memset(%s, 0, %s)\"?'\n          % (match.group(1), match.group(2)))\n\n  if Search(r'\\busing namespace\\b', line):\n    if Search(r'\\bliterals\\b', line):\n      error(filename, linenum, 'build/namespaces_literals', 5,\n            'Do not use namespace using-directives.  '\n            'Use using-declarations instead.')\n    else:\n      error(filename, linenum, 'build/namespaces', 5,\n            'Do not use namespace using-directives.  '\n            'Use using-declarations instead.')\n\n  # Detect variable-length arrays.\n  match = Match(r'\\s*(.+::)?(\\w+) [a-z]\\w*\\[(.+)];', line)\n  if (match and match.group(2) != 'return' and match.group(2) != 'delete' and\n      match.group(3).find(']') == -1):\n    # Split the size using space and arithmetic operators as delimiters.\n    # If any of the resulting tokens are not compile time constants then\n    # report the error.\n    tokens = re.split(r'\\s|\\+|\\-|\\*|\\/|<<|>>]', match.group(3))\n    is_const = True\n    skip_next = False\n    for tok in tokens:\n      if skip_next:\n        skip_next = False\n        continue\n\n      if Search(r'sizeof\\(.+\\)', tok): continue\n      if Search(r'arraysize\\(\\w+\\)', tok): continue\n\n      tok = tok.lstrip('(')\n      tok = tok.rstrip(')')\n      if not tok: continue\n      if Match(r'\\d+', tok): continue\n      if Match(r'0[xX][0-9a-fA-F]+', tok): continue\n      if Match(r'k[A-Z0-9]\\w*', tok): continue\n      if Match(r'(.+::)?k[A-Z0-9]\\w*', tok): continue\n      if Match(r'(.+::)?[A-Z][A-Z0-9_]*', tok): continue\n      # A catch all for tricky sizeof cases, including 'sizeof expression',\n      # 'sizeof(*type)', 'sizeof(const type)', 'sizeof(struct StructName)'\n      # requires skipping the next token because we split on ' ' and '*'.\n      if tok.startswith('sizeof'):\n        skip_next = True\n        continue\n      is_const = False\n      break\n    if not is_const:\n      error(filename, linenum, 'runtime/arrays', 1,\n            'Do not use variable-length arrays.  Use an appropriately named '\n            \"('k' followed by CamelCase) compile-time constant for the size.\")\n\n  # Check for use of unnamed namespaces in header files.  Registration\n  # macros are typically OK, so we allow use of \"namespace {\" on lines\n  # that end with backslashes.\n  if (IsHeaderExtension(file_extension)\n      and Search(r'\\bnamespace\\s*{', line)\n      and line[-1] != '\\\\'):\n    error(filename, linenum, 'build/namespaces', 4,\n          'Do not use unnamed namespaces in header files.  See '\n          'https://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Namespaces'\n          ' for more information.')\n\n\ndef CheckGlobalStatic(filename, clean_lines, linenum, error):\n  \"\"\"Check for unsafe global or static objects.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n\n  # Match two lines at a time to support multiline declarations\n  if linenum + 1 < clean_lines.NumLines() and not Search(r'[;({]', line):\n    line += clean_lines.elided[linenum + 1].strip()\n\n  # Check for people declaring static/global STL strings at the top level.\n  # This is dangerous because the C++ language does not guarantee that\n  # globals with constructors are initialized before the first access, and\n  # also because globals can be destroyed when some threads are still running.\n  # TODO(unknown): Generalize this to also find static unique_ptr instances.\n  # TODO(unknown): File bugs for clang-tidy to find these.\n  match = Match(\n      r'((?:|static +)(?:|const +))(?::*std::)?string( +const)? +'\n      r'([a-zA-Z0-9_:]+)\\b(.*)',\n      line)\n\n  # Remove false positives:\n  # - String pointers (as opposed to values).\n  #    string *pointer\n  #    const string *pointer\n  #    string const *pointer\n  #    string *const pointer\n  #\n  # - Functions and template specializations.\n  #    string Function<Type>(...\n  #    string Class<Type>::Method(...\n  #\n  # - Operators.  These are matched separately because operator names\n  #   cross non-word boundaries, and trying to match both operators\n  #   and functions at the same time would decrease accuracy of\n  #   matching identifiers.\n  #    string Class::operator*()\n  if (match and\n      not Search(r'\\bstring\\b(\\s+const)?\\s*[\\*\\&]\\s*(const\\s+)?\\w', line) and\n      not Search(r'\\boperator\\W', line) and\n      not Match(r'\\s*(<.*>)?(::[a-zA-Z0-9_]+)*\\s*\\(([^\"]|$)', match.group(4))):\n    if Search(r'\\bconst\\b', line):\n      error(filename, linenum, 'runtime/string', 4,\n            'For a static/global string constant, use a C style string '\n            'instead: \"%schar%s %s[]\".' %\n            (match.group(1), match.group(2) or '', match.group(3)))\n    else:\n      error(filename, linenum, 'runtime/string', 4,\n            'Static/global string variables are not permitted.')\n\n  if (Search(r'\\b([A-Za-z0-9_]*_)\\(\\1\\)', line) or\n      Search(r'\\b([A-Za-z0-9_]*_)\\(CHECK_NOTNULL\\(\\1\\)\\)', line)):\n    error(filename, linenum, 'runtime/init', 4,\n          'You seem to be initializing a member variable with itself.')\n\n\ndef CheckPrintf(filename, clean_lines, linenum, error):\n  \"\"\"Check for printf related issues.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n\n  # When snprintf is used, the second argument shouldn't be a literal.\n  match = Search(r'snprintf\\s*\\(([^,]*),\\s*([0-9]*)\\s*,', line)\n  if match and match.group(2) != '0':\n    # If 2nd arg is zero, snprintf is used to calculate size.\n    error(filename, linenum, 'runtime/printf', 3,\n          'If you can, use sizeof(%s) instead of %s as the 2nd arg '\n          'to snprintf.' % (match.group(1), match.group(2)))\n\n  # Check if some verboten C functions are being used.\n  if Search(r'\\bsprintf\\s*\\(', line):\n    error(filename, linenum, 'runtime/printf', 5,\n          'Never use sprintf. Use snprintf instead.')\n  match = Search(r'\\b(strcpy|strcat)\\s*\\(', line)\n  if match:\n    error(filename, linenum, 'runtime/printf', 4,\n          'Almost always, snprintf is better than %s' % match.group(1))\n\n\ndef IsDerivedFunction(clean_lines, linenum):\n  \"\"\"Check if current line contains an inherited function.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n  Returns:\n    True if current line contains a function with \"override\"\n    virt-specifier.\n  \"\"\"\n  # Scan back a few lines for start of current function\n  for i in xrange(linenum, max(-1, linenum - 10), -1):\n    match = Match(r'^([^()]*\\w+)\\(', clean_lines.elided[i])\n    if match:\n      # Look for \"override\" after the matching closing parenthesis\n      line, _, closing_paren = CloseExpression(\n          clean_lines, i, len(match.group(1)))\n      return (closing_paren >= 0 and\n              Search(r'\\boverride\\b', line[closing_paren:]))\n  return False\n\n\ndef IsOutOfLineMethodDefinition(clean_lines, linenum):\n  \"\"\"Check if current line contains an out-of-line method definition.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n  Returns:\n    True if current line contains an out-of-line method definition.\n  \"\"\"\n  # Scan back a few lines for start of current function\n  for i in xrange(linenum, max(-1, linenum - 10), -1):\n    if Match(r'^([^()]*\\w+)\\(', clean_lines.elided[i]):\n      return Match(r'^[^()]*\\w+::\\w+\\(', clean_lines.elided[i]) is not None\n  return False\n\n\ndef IsInitializerList(clean_lines, linenum):\n  \"\"\"Check if current line is inside constructor initializer list.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n  Returns:\n    True if current line appears to be inside constructor initializer\n    list, False otherwise.\n  \"\"\"\n  for i in xrange(linenum, 1, -1):\n    line = clean_lines.elided[i]\n    if i == linenum:\n      remove_function_body = Match(r'^(.*)\\{\\s*$', line)\n      if remove_function_body:\n        line = remove_function_body.group(1)\n\n    if Search(r'\\s:\\s*\\w+[({]', line):\n      # A lone colon tend to indicate the start of a constructor\n      # initializer list.  It could also be a ternary operator, which\n      # also tend to appear in constructor initializer lists as\n      # opposed to parameter lists.\n      return True\n    if Search(r'\\}\\s*,\\s*$', line):\n      # A closing brace followed by a comma is probably the end of a\n      # brace-initialized member in constructor initializer list.\n      return True\n    if Search(r'[{};]\\s*$', line):\n      # Found one of the following:\n      # - A closing brace or semicolon, probably the end of the previous\n      #   function.\n      # - An opening brace, probably the start of current class or namespace.\n      #\n      # Current line is probably not inside an initializer list since\n      # we saw one of those things without seeing the starting colon.\n      return False\n\n  # Got to the beginning of the file without seeing the start of\n  # constructor initializer list.\n  return False\n\n\ndef CheckForNonConstReference(filename, clean_lines, linenum,\n                              nesting_state, error):\n  \"\"\"Check for non-const references.\n\n  Separate from CheckLanguage since it scans backwards from current\n  line, instead of scanning forward.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    nesting_state: A NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: The function to call with any errors found.\n  \"\"\"\n  # Do nothing if there is no '&' on current line.\n  line = clean_lines.elided[linenum]\n  if '&' not in line:\n    return\n\n  # If a function is inherited, current function doesn't have much of\n  # a choice, so any non-const references should not be blamed on\n  # derived function.\n  if IsDerivedFunction(clean_lines, linenum):\n    return\n\n  # Don't warn on out-of-line method definitions, as we would warn on the\n  # in-line declaration, if it isn't marked with 'override'.\n  if IsOutOfLineMethodDefinition(clean_lines, linenum):\n    return\n\n  # Long type names may be broken across multiple lines, usually in one\n  # of these forms:\n  #   LongType\n  #       ::LongTypeContinued &identifier\n  #   LongType::\n  #       LongTypeContinued &identifier\n  #   LongType<\n  #       ...>::LongTypeContinued &identifier\n  #\n  # If we detected a type split across two lines, join the previous\n  # line to current line so that we can match const references\n  # accordingly.\n  #\n  # Note that this only scans back one line, since scanning back\n  # arbitrary number of lines would be expensive.  If you have a type\n  # that spans more than 2 lines, please use a typedef.\n  if linenum > 1:\n    previous = None\n    if Match(r'\\s*::(?:[\\w<>]|::)+\\s*&\\s*\\S', line):\n      # previous_line\\n + ::current_line\n      previous = Search(r'\\b((?:const\\s*)?(?:[\\w<>]|::)+[\\w<>])\\s*$',\n                        clean_lines.elided[linenum - 1])\n    elif Match(r'\\s*[a-zA-Z_]([\\w<>]|::)+\\s*&\\s*\\S', line):\n      # previous_line::\\n + current_line\n      previous = Search(r'\\b((?:const\\s*)?(?:[\\w<>]|::)+::)\\s*$',\n                        clean_lines.elided[linenum - 1])\n    if previous:\n      line = previous.group(1) + line.lstrip()\n    else:\n      # Check for templated parameter that is split across multiple lines\n      endpos = line.rfind('>')\n      if endpos > -1:\n        (_, startline, startpos) = ReverseCloseExpression(\n            clean_lines, linenum, endpos)\n        if startpos > -1 and startline < linenum:\n          # Found the matching < on an earlier line, collect all\n          # pieces up to current line.\n          line = ''\n          for i in xrange(startline, linenum + 1):\n            line += clean_lines.elided[i].strip()\n\n  # Check for non-const references in function parameters.  A single '&' may\n  # found in the following places:\n  #   inside expression: binary & for bitwise AND\n  #   inside expression: unary & for taking the address of something\n  #   inside declarators: reference parameter\n  # We will exclude the first two cases by checking that we are not inside a\n  # function body, including one that was just introduced by a trailing '{'.\n  # TODO(unknown): Doesn't account for 'catch(Exception& e)' [rare].\n  if (nesting_state.previous_stack_top and\n      not (isinstance(nesting_state.previous_stack_top, _ClassInfo) or\n           isinstance(nesting_state.previous_stack_top, _NamespaceInfo))):\n    # Not at toplevel, not within a class, and not within a namespace\n    return\n\n  # Avoid initializer lists.  We only need to scan back from the\n  # current line for something that starts with ':'.\n  #\n  # We don't need to check the current line, since the '&' would\n  # appear inside the second set of parentheses on the current line as\n  # opposed to the first set.\n  if linenum > 0:\n    for i in xrange(linenum - 1, max(0, linenum - 10), -1):\n      previous_line = clean_lines.elided[i]\n      if not Search(r'[),]\\s*$', previous_line):\n        break\n      if Match(r'^\\s*:\\s+\\S', previous_line):\n        return\n\n  # Avoid preprocessors\n  if Search(r'\\\\\\s*$', line):\n    return\n\n  # Avoid constructor initializer lists\n  if IsInitializerList(clean_lines, linenum):\n    return\n\n  # We allow non-const references in a few standard places, like functions\n  # called \"swap()\" or iostream operators like \"<<\" or \">>\".  Do not check\n  # those function parameters.\n  #\n  # We also accept & in static_assert, which looks like a function but\n  # it's actually a declaration expression.\n  whitelisted_functions = (r'(?:[sS]wap(?:<\\w:+>)?|'\n                           r'operator\\s*[<>][<>]|'\n                           r'static_assert|COMPILE_ASSERT'\n                           r')\\s*\\(')\n  if Search(whitelisted_functions, line):\n    return\n  elif not Search(r'\\S+\\([^)]*$', line):\n    # Don't see a whitelisted function on this line.  Actually we\n    # didn't see any function name on this line, so this is likely a\n    # multi-line parameter list.  Try a bit harder to catch this case.\n    for i in xrange(2):\n      if (linenum > i and\n          Search(whitelisted_functions, clean_lines.elided[linenum - i - 1])):\n        return\n\n  decls = ReplaceAll(r'{[^}]*}', ' ', line)  # exclude function body\n  for parameter in re.findall(_RE_PATTERN_REF_PARAM, decls):\n    if (not Match(_RE_PATTERN_CONST_REF_PARAM, parameter) and\n        not Match(_RE_PATTERN_REF_STREAM_PARAM, parameter)):\n      error(filename, linenum, 'runtime/references', 2,\n            'Is this a non-const reference? '\n            'If so, make const or use a pointer: ' +\n            ReplaceAll(' *<', '<', parameter))\n\n\ndef CheckCasts(filename, clean_lines, linenum, error):\n  \"\"\"Various cast related checks.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n\n  # Check to see if they're using an conversion function cast.\n  # I just try to capture the most common basic types, though there are more.\n  # Parameterless conversion functions, such as bool(), are allowed as they are\n  # probably a member operator declaration or default constructor.\n  match = Search(\n      r'(\\bnew\\s+(?:const\\s+)?|\\S<\\s*(?:const\\s+)?)?\\b'\n      r'(int|float|double|bool|char|int32|uint32|int64|uint64)'\n      r'(\\([^)].*)', line)\n  expecting_function = ExpectingFunctionArgs(clean_lines, linenum)\n  if match and not expecting_function:\n    matched_type = match.group(2)\n\n    # matched_new_or_template is used to silence two false positives:\n    # - New operators\n    # - Template arguments with function types\n    #\n    # For template arguments, we match on types immediately following\n    # an opening bracket without any spaces.  This is a fast way to\n    # silence the common case where the function type is the first\n    # template argument.  False negative with less-than comparison is\n    # avoided because those operators are usually followed by a space.\n    #\n    #   function<double(double)>   // bracket + no space = false positive\n    #   value < double(42)         // bracket + space = true positive\n    matched_new_or_template = match.group(1)\n\n    # Avoid arrays by looking for brackets that come after the closing\n    # parenthesis.\n    if Match(r'\\([^()]+\\)\\s*\\[', match.group(3)):\n      return\n\n    # Other things to ignore:\n    # - Function pointers\n    # - Casts to pointer types\n    # - Placement new\n    # - Alias declarations\n    matched_funcptr = match.group(3)\n    if (matched_new_or_template is None and\n        not (matched_funcptr and\n             (Match(r'\\((?:[^() ]+::\\s*\\*\\s*)?[^() ]+\\)\\s*\\(',\n                    matched_funcptr) or\n              matched_funcptr.startswith('(*)'))) and\n        not Match(r'\\s*using\\s+\\S+\\s*=\\s*' + matched_type, line) and\n        not Search(r'new\\(\\S+\\)\\s*' + matched_type, line)):\n      error(filename, linenum, 'readability/casting', 4,\n            'Using deprecated casting style.  '\n            'Use static_cast<%s>(...) instead' %\n            matched_type)\n\n  if not expecting_function:\n    CheckCStyleCast(filename, clean_lines, linenum, 'static_cast',\n                    r'\\((int|float|double|bool|char|u?int(16|32|64))\\)', error)\n\n  # This doesn't catch all cases. Consider (const char * const)\"hello\".\n  #\n  # (char *) \"foo\" should always be a const_cast (reinterpret_cast won't\n  # compile).\n  if CheckCStyleCast(filename, clean_lines, linenum, 'const_cast',\n                     r'\\((char\\s?\\*+\\s?)\\)\\s*\"', error):\n    pass\n  else:\n    # Check pointer casts for other than string constants\n    CheckCStyleCast(filename, clean_lines, linenum, 'reinterpret_cast',\n                    r'\\((\\w+\\s?\\*+\\s?)\\)', error)\n\n  # In addition, we look for people taking the address of a cast.  This\n  # is dangerous -- casts can assign to temporaries, so the pointer doesn't\n  # point where you think.\n  #\n  # Some non-identifier character is required before the '&' for the\n  # expression to be recognized as a cast.  These are casts:\n  #   expression = &static_cast<int*>(temporary());\n  #   function(&(int*)(temporary()));\n  #\n  # This is not a cast:\n  #   reference_type&(int* function_param);\n  match = Search(\n      r'(?:[^\\w]&\\(([^)*][^)]*)\\)[\\w(])|'\n      r'(?:[^\\w]&(static|dynamic|down|reinterpret)_cast\\b)', line)\n  if match:\n    # Try a better error message when the & is bound to something\n    # dereferenced by the casted pointer, as opposed to the casted\n    # pointer itself.\n    parenthesis_error = False\n    match = Match(r'^(.*&(?:static|dynamic|down|reinterpret)_cast\\b)<', line)\n    if match:\n      _, y1, x1 = CloseExpression(clean_lines, linenum, len(match.group(1)))\n      if x1 >= 0 and clean_lines.elided[y1][x1] == '(':\n        _, y2, x2 = CloseExpression(clean_lines, y1, x1)\n        if x2 >= 0:\n          extended_line = clean_lines.elided[y2][x2:]\n          if y2 < clean_lines.NumLines() - 1:\n            extended_line += clean_lines.elided[y2 + 1]\n          if Match(r'\\s*(?:->|\\[)', extended_line):\n            parenthesis_error = True\n\n    if parenthesis_error:\n      error(filename, linenum, 'readability/casting', 4,\n            ('Are you taking an address of something dereferenced '\n             'from a cast?  Wrapping the dereferenced expression in '\n             'parentheses will make the binding more obvious'))\n    else:\n      error(filename, linenum, 'runtime/casting', 4,\n            ('Are you taking an address of a cast?  '\n             'This is dangerous: could be a temp var.  '\n             'Take the address before doing the cast, rather than after'))\n\n\ndef CheckCStyleCast(filename, clean_lines, linenum, cast_type, pattern, error):\n  \"\"\"Checks for a C-style cast by looking for the pattern.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    cast_type: The string for the C++ cast to recommend.  This is either\n      reinterpret_cast, static_cast, or const_cast, depending.\n    pattern: The regular expression used to find C-style casts.\n    error: The function to call with any errors found.\n\n  Returns:\n    True if an error was emitted.\n    False otherwise.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n  match = Search(pattern, line)\n  if not match:\n    return False\n\n  # Exclude lines with keywords that tend to look like casts\n  context = line[0:match.start(1) - 1]\n  if Match(r'.*\\b(?:sizeof|alignof|alignas|[_A-Z][_A-Z0-9]*)\\s*$', context):\n    return False\n\n  # Try expanding current context to see if we one level of\n  # parentheses inside a macro.\n  if linenum > 0:\n    for i in xrange(linenum - 1, max(0, linenum - 5), -1):\n      context = clean_lines.elided[i] + context\n  if Match(r'.*\\b[_A-Z][_A-Z0-9]*\\s*\\((?:\\([^()]*\\)|[^()])*$', context):\n    return False\n\n  # operator++(int) and operator--(int)\n  if context.endswith(' operator++') or context.endswith(' operator--'):\n    return False\n\n  # A single unnamed argument for a function tends to look like old style cast.\n  # If we see those, don't issue warnings for deprecated casts.\n  remainder = line[match.end(0):]\n  if Match(r'^\\s*(?:;|const\\b|throw\\b|final\\b|override\\b|[=>{),]|->)',\n           remainder):\n    return False\n\n  # At this point, all that should be left is actual casts.\n  error(filename, linenum, 'readability/casting', 4,\n        'Using C-style cast.  Use %s<%s>(...) instead' %\n        (cast_type, match.group(1)))\n\n  return True\n\n\ndef ExpectingFunctionArgs(clean_lines, linenum):\n  \"\"\"Checks whether where function type arguments are expected.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n\n  Returns:\n    True if the line at 'linenum' is inside something that expects arguments\n    of function types.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n  return (Match(r'^\\s*MOCK_(CONST_)?METHOD\\d+(_T)?\\(', line) or\n          (linenum >= 2 and\n           (Match(r'^\\s*MOCK_(?:CONST_)?METHOD\\d+(?:_T)?\\((?:\\S+,)?\\s*$',\n                  clean_lines.elided[linenum - 1]) or\n            Match(r'^\\s*MOCK_(?:CONST_)?METHOD\\d+(?:_T)?\\(\\s*$',\n                  clean_lines.elided[linenum - 2]) or\n            Search(r'\\bstd::m?function\\s*\\<\\s*$',\n                   clean_lines.elided[linenum - 1]))))\n\n\n_HEADERS_CONTAINING_TEMPLATES = (\n    ('<deque>', ('deque',)),\n    ('<functional>', ('unary_function', 'binary_function',\n                      'plus', 'minus', 'multiplies', 'divides', 'modulus',\n                      'negate',\n                      'equal_to', 'not_equal_to', 'greater', 'less',\n                      'greater_equal', 'less_equal',\n                      'logical_and', 'logical_or', 'logical_not',\n                      'unary_negate', 'not1', 'binary_negate', 'not2',\n                      'bind1st', 'bind2nd',\n                      'pointer_to_unary_function',\n                      'pointer_to_binary_function',\n                      'ptr_fun',\n                      'mem_fun_t', 'mem_fun', 'mem_fun1_t', 'mem_fun1_ref_t',\n                      'mem_fun_ref_t',\n                      'const_mem_fun_t', 'const_mem_fun1_t',\n                      'const_mem_fun_ref_t', 'const_mem_fun1_ref_t',\n                      'mem_fun_ref',\n                     )),\n    ('<limits>', ('numeric_limits',)),\n    ('<list>', ('list',)),\n    ('<map>', ('multimap',)),\n    ('<memory>', ('allocator', 'make_shared', 'make_unique', 'shared_ptr',\n                  'unique_ptr', 'weak_ptr')),\n    ('<queue>', ('queue', 'priority_queue',)),\n    ('<set>', ('multiset',)),\n    ('<stack>', ('stack',)),\n    ('<string>', ('char_traits', 'basic_string',)),\n    ('<tuple>', ('tuple',)),\n    ('<unordered_map>', ('unordered_map', 'unordered_multimap')),\n    ('<unordered_set>', ('unordered_set', 'unordered_multiset')),\n    ('<utility>', ('pair',)),\n    ('<vector>', ('vector',)),\n\n    # gcc extensions.\n    # Note: std::hash is their hash, ::hash is our hash\n    ('<hash_map>', ('hash_map', 'hash_multimap',)),\n    ('<hash_set>', ('hash_set', 'hash_multiset',)),\n    ('<slist>', ('slist',)),\n    )\n\n_HEADERS_MAYBE_TEMPLATES = (\n    ('<algorithm>', ('copy', 'max', 'min', 'min_element', 'sort',\n                     'transform',\n                    )),\n    ('<utility>', ('forward', 'make_pair', 'move', 'swap')),\n    )\n\n_RE_PATTERN_STRING = re.compile(r'\\bstring\\b')\n\n_re_pattern_headers_maybe_templates = []\nfor _header, _templates in _HEADERS_MAYBE_TEMPLATES:\n  for _template in _templates:\n    # Match max<type>(..., ...), max(..., ...), but not foo->max, foo.max or\n    # 'type::max()'.\n    _re_pattern_headers_maybe_templates.append(\n        (re.compile(r'[^>.]\\b' + _template + r'(<.*?>)?\\([^\\)]'),\n            _template,\n            _header))\n# Match set<type>, but not foo->set<type>, foo.set<type>\n_re_pattern_headers_maybe_templates.append(\n    (re.compile(r'[^>.]\\bset\\s*\\<'),\n        'set<>',\n        '<set>'))\n# Match 'map<type> var' and 'std::map<type>(...)', but not 'map<type>(...)''\n_re_pattern_headers_maybe_templates.append(\n    (re.compile(r'(std\\b::\\bmap\\s*\\<)|(^(std\\b::\\b)map\\b\\(\\s*\\<)'),\n        'map<>',\n        '<map>'))\n\n# Other scripts may reach in and modify this pattern.\n_re_pattern_templates = []\nfor _header, _templates in _HEADERS_CONTAINING_TEMPLATES:\n  for _template in _templates:\n    _re_pattern_templates.append(\n        (re.compile(r'(\\<|\\b)' + _template + r'\\s*\\<'),\n         _template + '<>',\n         _header))\n\n\ndef FilesBelongToSameModule(filename_cc, filename_h):\n  \"\"\"Check if these two filenames belong to the same module.\n\n  The concept of a 'module' here is a as follows:\n  foo.h, foo-inl.h, foo.cc, foo_test.cc and foo_unittest.cc belong to the\n  same 'module' if they are in the same directory.\n  some/path/public/xyzzy and some/path/internal/xyzzy are also considered\n  to belong to the same module here.\n\n  If the filename_cc contains a longer path than the filename_h, for example,\n  '/absolute/path/to/base/sysinfo.cc', and this file would include\n  'base/sysinfo.h', this function also produces the prefix needed to open the\n  header. This is used by the caller of this function to more robustly open the\n  header file. We don't have access to the real include paths in this context,\n  so we need this guesswork here.\n\n  Known bugs: tools/base/bar.cc and base/bar.h belong to the same module\n  according to this implementation. Because of this, this function gives\n  some false positives. This should be sufficiently rare in practice.\n\n  Args:\n    filename_cc: is the path for the source (e.g. .cc) file\n    filename_h: is the path for the header path\n\n  Returns:\n    Tuple with a bool and a string:\n    bool: True if filename_cc and filename_h belong to the same module.\n    string: the additional prefix needed to open the header file.\n  \"\"\"\n  fileinfo_cc = FileInfo(filename_cc)\n  if not fileinfo_cc.Extension().lstrip('.') in GetNonHeaderExtensions():\n    return (False, '')\n\n  fileinfo_h = FileInfo(filename_h)\n  if not IsHeaderExtension(fileinfo_h.Extension().lstrip('.')):\n    return (False, '')\n\n  filename_cc = filename_cc[:-(len(fileinfo_cc.Extension()))]\n  matched_test_suffix = Search(_TEST_FILE_SUFFIX, fileinfo_cc.BaseName())\n  if matched_test_suffix:\n    filename_cc = filename_cc[:-len(matched_test_suffix.group(1))]\n\n  filename_cc = filename_cc.replace('/public/', '/')\n  filename_cc = filename_cc.replace('/internal/', '/')\n\n  filename_h = filename_h[:-(len(fileinfo_h.Extension()))]\n  if filename_h.endswith('-inl'):\n    filename_h = filename_h[:-len('-inl')]\n  filename_h = filename_h.replace('/public/', '/')\n  filename_h = filename_h.replace('/internal/', '/')\n\n  files_belong_to_same_module = filename_cc.endswith(filename_h)\n  common_path = ''\n  if files_belong_to_same_module:\n    common_path = filename_cc[:-len(filename_h)]\n  return files_belong_to_same_module, common_path\n\n\ndef UpdateIncludeState(filename, include_dict, io=codecs):\n  \"\"\"Fill up the include_dict with new includes found from the file.\n\n  Args:\n    filename: the name of the header to read.\n    include_dict: a dictionary in which the headers are inserted.\n    io: The io factory to use to read the file. Provided for testability.\n\n  Returns:\n    True if a header was successfully added. False otherwise.\n  \"\"\"\n  headerfile = None\n  try:\n    headerfile = io.open(filename, 'r', 'utf8', 'replace')\n  except IOError:\n    return False\n  linenum = 0\n  for line in headerfile:\n    linenum += 1\n    clean_line = CleanseComments(line)\n    match = _RE_PATTERN_INCLUDE.search(clean_line)\n    if match:\n      include = match.group(2)\n      include_dict.setdefault(include, linenum)\n  return True\n\n\ndef CheckForIncludeWhatYouUse(filename, clean_lines, include_state, error,\n                              io=codecs):\n  \"\"\"Reports for missing stl includes.\n\n  This function will output warnings to make sure you are including the headers\n  necessary for the stl containers and functions that you use. We only give one\n  reason to include a header. For example, if you use both equal_to<> and\n  less<> in a .h file, only one (the latter in the file) of these will be\n  reported as a reason to include the <functional>.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    include_state: An _IncludeState instance.\n    error: The function to call with any errors found.\n    io: The IO factory to use to read the header file. Provided for unittest\n        injection.\n  \"\"\"\n  required = {}  # A map of header name to linenumber and the template entity.\n                 # Example of required: { '<functional>': (1219, 'less<>') }\n\n  for linenum in xrange(clean_lines.NumLines()):\n    line = clean_lines.elided[linenum]\n    if not line or line[0] == '#':\n      continue\n\n    # String is special -- it is a non-templatized type in STL.\n    matched = _RE_PATTERN_STRING.search(line)\n    if matched:\n      # Don't warn about strings in non-STL namespaces:\n      # (We check only the first match per line; good enough.)\n      prefix = line[:matched.start()]\n      if prefix.endswith('std::') or not prefix.endswith('::'):\n        required['<string>'] = (linenum, 'string')\n\n    for pattern, template, header in _re_pattern_headers_maybe_templates:\n      if pattern.search(line):\n        required[header] = (linenum, template)\n\n    # The following function is just a speed up, no semantics are changed.\n    if not '<' in line:  # Reduces the cpu time usage by skipping lines.\n      continue\n\n    for pattern, template, header in _re_pattern_templates:\n      matched = pattern.search(line)\n      if matched:\n        # Don't warn about IWYU in non-STL namespaces:\n        # (We check only the first match per line; good enough.)\n        prefix = line[:matched.start()]\n        if prefix.endswith('std::') or not prefix.endswith('::'):\n          required[header] = (linenum, template)\n\n  # The policy is that if you #include something in foo.h you don't need to\n  # include it again in foo.cc. Here, we will look at possible includes.\n  # Let's flatten the include_state include_list and copy it into a dictionary.\n  include_dict = dict([item for sublist in include_state.include_list\n                       for item in sublist])\n\n  # Did we find the header for this file (if any) and successfully load it?\n  header_found = False\n\n  # Use the absolute path so that matching works properly.\n  abs_filename = FileInfo(filename).FullName()\n\n  # For Emacs's flymake.\n  # If cpplint is invoked from Emacs's flymake, a temporary file is generated\n  # by flymake and that file name might end with '_flymake.cc'. In that case,\n  # restore original file name here so that the corresponding header file can be\n  # found.\n  # e.g. If the file name is 'foo_flymake.cc', we should search for 'foo.h'\n  # instead of 'foo_flymake.h'\n  abs_filename = re.sub(r'_flymake\\.cc$', '.cc', abs_filename)\n\n  # include_dict is modified during iteration, so we iterate over a copy of\n  # the keys.\n  header_keys = list(include_dict.keys())\n  for header in header_keys:\n    (same_module, common_path) = FilesBelongToSameModule(abs_filename, header)\n    fullpath = common_path + header\n    if same_module and UpdateIncludeState(fullpath, include_dict, io):\n      header_found = True\n\n  # If we can't find the header file for a .cc, assume it's because we don't\n  # know where to look. In that case we'll give up as we're not sure they\n  # didn't include it in the .h file.\n  # TODO(unknown): Do a better job of finding .h files so we are confident that\n  # not having the .h file means there isn't one.\n  if not header_found:\n    for extension in GetNonHeaderExtensions():\n      if filename.endswith('.' + extension):\n        return\n\n  # All the lines have been processed, report the errors found.\n  for required_header_unstripped in sorted(required, key=required.__getitem__):\n    template = required[required_header_unstripped][1]\n    if required_header_unstripped.strip('<>\"') not in include_dict:\n      error(filename, required[required_header_unstripped][0],\n            'build/include_what_you_use', 4,\n            'Add #include ' + required_header_unstripped + ' for ' + template)\n\n\n_RE_PATTERN_EXPLICIT_MAKEPAIR = re.compile(r'\\bmake_pair\\s*<')\n\n\ndef CheckMakePairUsesDeduction(filename, clean_lines, linenum, error):\n  \"\"\"Check that make_pair's template arguments are deduced.\n\n  G++ 4.6 in C++11 mode fails badly if make_pair's template arguments are\n  specified explicitly, and such use isn't intended in any case.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n  match = _RE_PATTERN_EXPLICIT_MAKEPAIR.search(line)\n  if match:\n    error(filename, linenum, 'build/explicit_make_pair',\n          4,  # 4 = high confidence\n          'For C++11-compatibility, omit template arguments from make_pair'\n          ' OR use pair directly OR if appropriate, construct a pair directly')\n\n\ndef CheckRedundantVirtual(filename, clean_lines, linenum, error):\n  \"\"\"Check if line contains a redundant \"virtual\" function-specifier.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  # Look for \"virtual\" on current line.\n  line = clean_lines.elided[linenum]\n  virtual = Match(r'^(.*)(\\bvirtual\\b)(.*)$', line)\n  if not virtual: return\n\n  # Ignore \"virtual\" keywords that are near access-specifiers.  These\n  # are only used in class base-specifier and do not apply to member\n  # functions.\n  if (Search(r'\\b(public|protected|private)\\s+$', virtual.group(1)) or\n      Match(r'^\\s+(public|protected|private)\\b', virtual.group(3))):\n    return\n\n  # Ignore the \"virtual\" keyword from virtual base classes.  Usually\n  # there is a column on the same line in these cases (virtual base\n  # classes are rare in google3 because multiple inheritance is rare).\n  if Match(r'^.*[^:]:[^:].*$', line): return\n\n  # Look for the next opening parenthesis.  This is the start of the\n  # parameter list (possibly on the next line shortly after virtual).\n  # TODO(unknown): doesn't work if there are virtual functions with\n  # decltype() or other things that use parentheses, but csearch suggests\n  # that this is rare.\n  end_col = -1\n  end_line = -1\n  start_col = len(virtual.group(2))\n  for start_line in xrange(linenum, min(linenum + 3, clean_lines.NumLines())):\n    line = clean_lines.elided[start_line][start_col:]\n    parameter_list = Match(r'^([^(]*)\\(', line)\n    if parameter_list:\n      # Match parentheses to find the end of the parameter list\n      (_, end_line, end_col) = CloseExpression(\n          clean_lines, start_line, start_col + len(parameter_list.group(1)))\n      break\n    start_col = 0\n\n  if end_col < 0:\n    return  # Couldn't find end of parameter list, give up\n\n  # Look for \"override\" or \"final\" after the parameter list\n  # (possibly on the next few lines).\n  for i in xrange(end_line, min(end_line + 3, clean_lines.NumLines())):\n    line = clean_lines.elided[i][end_col:]\n    match = Search(r'\\b(override|final)\\b', line)\n    if match:\n      error(filename, linenum, 'readability/inheritance', 4,\n            ('\"virtual\" is redundant since function is '\n             'already declared as \"%s\"' % match.group(1)))\n\n    # Set end_col to check whole lines after we are done with the\n    # first line.\n    end_col = 0\n    if Search(r'[^\\w]\\s*$', line):\n      break\n\n\ndef CheckRedundantOverrideOrFinal(filename, clean_lines, linenum, error):\n  \"\"\"Check if line contains a redundant \"override\" or \"final\" virt-specifier.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  # Look for closing parenthesis nearby.  We need one to confirm where\n  # the declarator ends and where the virt-specifier starts to avoid\n  # false positives.\n  line = clean_lines.elided[linenum]\n  declarator_end = line.rfind(')')\n  if declarator_end >= 0:\n    fragment = line[declarator_end:]\n  else:\n    if linenum > 1 and clean_lines.elided[linenum - 1].rfind(')') >= 0:\n      fragment = line\n    else:\n      return\n\n  # Check that at most one of \"override\" or \"final\" is present, not both\n  if Search(r'\\boverride\\b', fragment) and Search(r'\\bfinal\\b', fragment):\n    error(filename, linenum, 'readability/inheritance', 4,\n          ('\"override\" is redundant since function is '\n           'already declared as \"final\"'))\n\n\n\n\n# Returns true if we are at a new block, and it is directly\n# inside of a namespace.\ndef IsBlockInNameSpace(nesting_state, is_forward_declaration):\n  \"\"\"Checks that the new block is directly in a namespace.\n\n  Args:\n    nesting_state: The _NestingState object that contains info about our state.\n    is_forward_declaration: If the class is a forward declared class.\n  Returns:\n    Whether or not the new block is directly in a namespace.\n  \"\"\"\n  if is_forward_declaration:\n    return len(nesting_state.stack) >= 1 and (\n      isinstance(nesting_state.stack[-1], _NamespaceInfo))\n\n\n  return (len(nesting_state.stack) > 1 and\n          nesting_state.stack[-1].check_namespace_indentation and\n          isinstance(nesting_state.stack[-2], _NamespaceInfo))\n\n\ndef ShouldCheckNamespaceIndentation(nesting_state, is_namespace_indent_item,\n                                    raw_lines_no_comments, linenum):\n  \"\"\"This method determines if we should apply our namespace indentation check.\n\n  Args:\n    nesting_state: The current nesting state.\n    is_namespace_indent_item: If we just put a new class on the stack, True.\n      If the top of the stack is not a class, or we did not recently\n      add the class, False.\n    raw_lines_no_comments: The lines without the comments.\n    linenum: The current line number we are processing.\n\n  Returns:\n    True if we should apply our namespace indentation check. Currently, it\n    only works for classes and namespaces inside of a namespace.\n  \"\"\"\n\n  is_forward_declaration = IsForwardClassDeclaration(raw_lines_no_comments,\n                                                     linenum)\n\n  if not (is_namespace_indent_item or is_forward_declaration):\n    return False\n\n  # If we are in a macro, we do not want to check the namespace indentation.\n  if IsMacroDefinition(raw_lines_no_comments, linenum):\n    return False\n\n  return IsBlockInNameSpace(nesting_state, is_forward_declaration)\n\n\n# Call this method if the line is directly inside of a namespace.\n# If the line above is blank (excluding comments) or the start of\n# an inner namespace, it cannot be indented.\ndef CheckItemIndentationInNamespace(filename, raw_lines_no_comments, linenum,\n                                    error):\n  line = raw_lines_no_comments[linenum]\n  if Match(r'^\\s+', line):\n    error(filename, linenum, 'runtime/indentation_namespace', 4,\n          'Do not indent within a namespace')\n\n\ndef ProcessLine(filename, file_extension, clean_lines, line,\n                include_state, function_state, nesting_state, error,\n                extra_check_functions=None):\n  \"\"\"Processes a single line in the file.\n\n  Args:\n    filename: Filename of the file that is being processed.\n    file_extension: The extension (dot not included) of the file.\n    clean_lines: An array of strings, each representing a line of the file,\n                 with comments stripped.\n    line: Number of line being processed.\n    include_state: An _IncludeState instance in which the headers are inserted.\n    function_state: A _FunctionState instance which counts function lines, etc.\n    nesting_state: A NestingState instance which maintains information about\n                   the current stack of nested blocks being parsed.\n    error: A callable to which errors are reported, which takes 4 arguments:\n           filename, line number, error level, and message\n    extra_check_functions: An array of additional check functions that will be\n                           run on each source line. Each function takes 4\n                           arguments: filename, clean_lines, line, error\n  \"\"\"\n  raw_lines = clean_lines.raw_lines\n  ParseNolintSuppressions(filename, raw_lines[line], line, error)\n  nesting_state.Update(filename, clean_lines, line, error)\n  CheckForNamespaceIndentation(filename, nesting_state, clean_lines, line,\n                               error)\n  if nesting_state.InAsmBlock(): return\n  CheckForFunctionLengths(filename, clean_lines, line, function_state, error)\n  CheckForMultilineCommentsAndStrings(filename, clean_lines, line, error)\n  CheckStyle(filename, clean_lines, line, file_extension, nesting_state, error)\n  CheckLanguage(filename, clean_lines, line, file_extension, include_state,\n                nesting_state, error)\n  CheckForNonConstReference(filename, clean_lines, line, nesting_state, error)\n  CheckForNonStandardConstructs(filename, clean_lines, line,\n                                nesting_state, error)\n  CheckVlogArguments(filename, clean_lines, line, error)\n  CheckPosixThreading(filename, clean_lines, line, error)\n  CheckInvalidIncrement(filename, clean_lines, line, error)\n  CheckMakePairUsesDeduction(filename, clean_lines, line, error)\n  CheckRedundantVirtual(filename, clean_lines, line, error)\n  CheckRedundantOverrideOrFinal(filename, clean_lines, line, error)\n  if extra_check_functions:\n    for check_fn in extra_check_functions:\n      check_fn(filename, clean_lines, line, error)\n\ndef FlagCxx11Features(filename, clean_lines, linenum, error):\n  \"\"\"Flag those c++11 features that we only allow in certain places.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n\n  include = Match(r'\\s*#\\s*include\\s+[<\"]([^<\"]+)[\">]', line)\n\n  # Flag unapproved C++ TR1 headers.\n  if include and include.group(1).startswith('tr1/'):\n    error(filename, linenum, 'build/c++tr1', 5,\n          ('C++ TR1 headers such as <%s> are unapproved.') % include.group(1))\n\n  # Flag unapproved C++11 headers.\n  if include and include.group(1) in ('cfenv',\n                                      'condition_variable',\n                                      'fenv.h',\n                                      'future',\n                                      'mutex',\n                                      'thread',\n                                      'chrono',\n                                      'ratio',\n                                      'regex',\n                                      'system_error',\n                                     ):\n    error(filename, linenum, 'build/c++11', 5,\n          ('<%s> is an unapproved C++11 header.') % include.group(1))\n\n  # The only place where we need to worry about C++11 keywords and library\n  # features in preprocessor directives is in macro definitions.\n  if Match(r'\\s*#', line) and not Match(r'\\s*#\\s*define\\b', line): return\n\n  # These are classes and free functions.  The classes are always\n  # mentioned as std::*, but we only catch the free functions if\n  # they're not found by ADL.  They're alphabetical by header.\n  for top_name in (\n      # type_traits\n      'alignment_of',\n      'aligned_union',\n      ):\n    if Search(r'\\bstd::%s\\b' % top_name, line):\n      error(filename, linenum, 'build/c++11', 5,\n            ('std::%s is an unapproved C++11 class or function.  Send c-style '\n             'an example of where it would make your code more readable, and '\n             'they may let you use it.') % top_name)\n\n\ndef FlagCxx14Features(filename, clean_lines, linenum, error):\n  \"\"\"Flag those C++14 features that we restrict.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"\n  line = clean_lines.elided[linenum]\n\n  include = Match(r'\\s*#\\s*include\\s+[<\"]([^<\"]+)[\">]', line)\n\n  # Flag unapproved C++14 headers.\n  if include and include.group(1) in ('scoped_allocator', 'shared_mutex'):\n    error(filename, linenum, 'build/c++14', 5,\n          ('<%s> is an unapproved C++14 header.') % include.group(1))\n\n\ndef ProcessFileData(filename, file_extension, lines, error,\n                    extra_check_functions=None):\n  \"\"\"Performs lint checks and reports any errors to the given error function.\n\n  Args:\n    filename: Filename of the file that is being processed.\n    file_extension: The extension (dot not included) of the file.\n    lines: An array of strings, each representing a line of the file, with the\n           last element being empty if the file is terminated with a newline.\n    error: A callable to which errors are reported, which takes 4 arguments:\n           filename, line number, error level, and message\n    extra_check_functions: An array of additional check functions that will be\n                           run on each source line. Each function takes 4\n                           arguments: filename, clean_lines, line, error\n  \"\"\"\n  lines = (['// marker so line numbers and indices both start at 1'] + lines +\n           ['// marker so line numbers end in a known way'])\n\n  include_state = _IncludeState()\n  function_state = _FunctionState()\n  nesting_state = NestingState()\n\n  ResetNolintSuppressions()\n\n  CheckForCopyright(filename, lines, error)\n  ProcessGlobalSuppresions(lines)\n  RemoveMultiLineComments(filename, lines, error)\n  clean_lines = CleansedLines(lines)\n\n  if IsHeaderExtension(file_extension):\n    CheckForHeaderGuard(filename, clean_lines, error)\n\n  for line in xrange(clean_lines.NumLines()):\n    ProcessLine(filename, file_extension, clean_lines, line,\n                include_state, function_state, nesting_state, error,\n                extra_check_functions)\n    FlagCxx11Features(filename, clean_lines, line, error)\n  nesting_state.CheckCompletedBlocks(filename, error)\n\n  CheckForIncludeWhatYouUse(filename, clean_lines, include_state, error)\n\n  # Check that the .cc file has included its header if it exists.\n  if _IsSourceExtension(file_extension):\n    CheckHeaderFileIncluded(filename, include_state, error)\n\n  # We check here rather than inside ProcessLine so that we see raw\n  # lines rather than \"cleaned\" lines.\n  CheckForBadCharacters(filename, lines, error)\n\n  CheckForNewlineAtEOF(filename, lines, error)\n\ndef ProcessConfigOverrides(filename):\n  \"\"\" Loads the configuration files and processes the config overrides.\n\n  Args:\n    filename: The name of the file being processed by the linter.\n\n  Returns:\n    False if the current |filename| should not be processed further.\n  \"\"\"\n\n  abs_filename = os.path.abspath(filename)\n  cfg_filters = []\n  keep_looking = True\n  while keep_looking:\n    abs_path, base_name = os.path.split(abs_filename)\n    if not base_name:\n      break  # Reached the root directory.\n\n    cfg_file = os.path.join(abs_path, \"CPPLINT.cfg\")\n    abs_filename = abs_path\n    if not os.path.isfile(cfg_file):\n      continue\n\n    try:\n      with open(cfg_file) as file_handle:\n        for line in file_handle:\n          line, _, _ = line.partition('#')  # Remove comments.\n          if not line.strip():\n            continue\n\n          name, _, val = line.partition('=')\n          name = name.strip()\n          val = val.strip()\n          if name == 'set noparent':\n            keep_looking = False\n          elif name == 'filter':\n            cfg_filters.append(val)\n          elif name == 'exclude_files':\n            # When matching exclude_files pattern, use the base_name of\n            # the current file name or the directory name we are processing.\n            # For example, if we are checking for lint errors in /foo/bar/baz.cc\n            # and we found the .cfg file at /foo/CPPLINT.cfg, then the config\n            # file's \"exclude_files\" filter is meant to be checked against \"bar\"\n            # and not \"baz\" nor \"bar/baz.cc\".\n            if base_name:\n              pattern = re.compile(val)\n              if pattern.match(base_name):\n                if _cpplint_state.quiet:\n                  # Suppress \"Ignoring file\" warning when using --quiet.\n                  return False\n                _cpplint_state.PrintInfo('Ignoring \"%s\": file excluded by \"%s\". '\n                                 'File path component \"%s\" matches '\n                                 'pattern \"%s\"\\n' %\n                                 (filename, cfg_file, base_name, val))\n                return False\n          elif name == 'linelength':\n            global _line_length\n            try:\n              _line_length = int(val)\n            except ValueError:\n              _cpplint_state.PrintError('Line length must be numeric.')\n          elif name == 'extensions':\n            ProcessExtensionsOption(val)\n          elif name == 'root':\n            global _root\n            # root directories are specified relative to CPPLINT.cfg dir.\n            _root = os.path.join(os.path.dirname(cfg_file), val)\n          elif name == 'headers':\n            ProcessHppHeadersOption(val)\n          else:\n            _cpplint_state.PrintError(\n                'Invalid configuration option (%s) in file %s\\n' %\n                (name, cfg_file))\n\n    except IOError:\n      _cpplint_state.PrintError(\n          \"Skipping config file '%s': Can't open for reading\\n\" % cfg_file)\n      keep_looking = False\n\n  # Apply all the accumulated filters in reverse order (top-level directory\n  # config options having the least priority).\n  for cfg_filter in reversed(cfg_filters):\n    _AddFilters(cfg_filter)\n\n  return True\n\n\ndef ProcessFile(filename, vlevel, extra_check_functions=None):\n  \"\"\"Does google-lint on a single file.\n\n  Args:\n    filename: The name of the file to parse.\n\n    vlevel: The level of errors to report.  Every error of confidence\n    >= verbose_level will be reported.  0 is a good default.\n\n    extra_check_functions: An array of additional check functions that will be\n                           run on each source line. Each function takes 4\n                           arguments: filename, clean_lines, line, error\n  \"\"\"\n\n  _SetVerboseLevel(vlevel)\n  _BackupFilters()\n  old_errors = _cpplint_state.error_count\n\n  if not ProcessConfigOverrides(filename):\n    _RestoreFilters()\n    return\n\n  lf_lines = []\n  crlf_lines = []\n  try:\n    # Support the UNIX convention of using \"-\" for stdin.  Note that\n    # we are not opening the file with universal newline support\n    # (which codecs doesn't support anyway), so the resulting lines do\n    # contain trailing '\\r' characters if we are reading a file that\n    # has CRLF endings.\n    # If after the split a trailing '\\r' is present, it is removed\n    # below.\n    if filename == '-':\n      lines = codecs.StreamReaderWriter(sys.stdin,\n                                        codecs.getreader('utf8'),\n                                        codecs.getwriter('utf8'),\n                                        'replace').read().split('\\n')\n    else:\n      lines = codecs.open(filename, 'r', 'utf8', 'replace').read().split('\\n')\n\n    # Remove trailing '\\r'.\n    # The -1 accounts for the extra trailing blank line we get from split()\n    for linenum in range(len(lines) - 1):\n      if lines[linenum].endswith('\\r'):\n        lines[linenum] = lines[linenum].rstrip('\\r')\n        crlf_lines.append(linenum + 1)\n      else:\n        lf_lines.append(linenum + 1)\n\n  except IOError:\n    _cpplint_state.PrintError(\n        \"Skipping input '%s': Can't open for reading\\n\" % filename)\n    _RestoreFilters()\n    return\n\n  # Note, if no dot is found, this will give the entire filename as the ext.\n  file_extension = filename[filename.rfind('.') + 1:]\n\n  # When reading from stdin, the extension is unknown, so no cpplint tests\n  # should rely on the extension.\n  if filename != '-' and file_extension not in GetAllExtensions():\n    _cpplint_state.PrintError('Ignoring %s; not a valid file name '\n                     '(%s)\\n' % (filename, ', '.join(GetAllExtensions())))\n  else:\n    ProcessFileData(filename, file_extension, lines, Error,\n                    extra_check_functions)\n\n    # If end-of-line sequences are a mix of LF and CR-LF, issue\n    # warnings on the lines with CR.\n    #\n    # Don't issue any warnings if all lines are uniformly LF or CR-LF,\n    # since critique can handle these just fine, and the style guide\n    # doesn't dictate a particular end of line sequence.\n    #\n    # We can't depend on os.linesep to determine what the desired\n    # end-of-line sequence should be, since that will return the\n    # server-side end-of-line sequence.\n    if lf_lines and crlf_lines:\n      # Warn on every line with CR.  An alternative approach might be to\n      # check whether the file is mostly CRLF or just LF, and warn on the\n      # minority, we bias toward LF here since most tools prefer LF.\n      for linenum in crlf_lines:\n        Error(filename, linenum, 'whitespace/newline', 1,\n              'Unexpected \\\\r (^M) found; better to use only \\\\n')\n\n  # Suppress printing anything if --quiet was passed unless the error\n  # count has increased after processing this file.\n  if not _cpplint_state.quiet or old_errors != _cpplint_state.error_count:\n    _cpplint_state.PrintInfo('Done processing %s\\n' % filename)\n  _RestoreFilters()\n\n\ndef PrintUsage(message):\n  \"\"\"Prints a brief usage string and exits, optionally with an error message.\n\n  Args:\n    message: The optional error message.\n  \"\"\"\n  sys.stderr.write(_USAGE  % (list(GetAllExtensions()),\n       ','.join(list(GetAllExtensions())),\n       GetHeaderExtensions(),\n       ','.join(GetHeaderExtensions())))\n\n  if message:\n    sys.exit('\\nFATAL ERROR: ' + message)\n  else:\n    sys.exit(0)\n\ndef PrintVersion():\n  sys.stdout.write('Cpplint fork (https://github.com/cpplint/cpplint)\\n')\n  sys.stdout.write('cpplint ' + __VERSION__ + '\\n')\n  sys.stdout.write('Python ' + sys.version + '\\n')\n  sys.exit(0)\n\ndef PrintCategories():\n  \"\"\"Prints a list of all the error-categories used by error messages.\n\n  These are the categories used to filter messages via --filter.\n  \"\"\"\n  sys.stderr.write(''.join('  %s\\n' % cat for cat in _ERROR_CATEGORIES))\n  sys.exit(0)\n\n\ndef ParseArguments(args):\n  \"\"\"Parses the command line arguments.\n\n  This may set the output format and verbosity level as side-effects.\n\n  Args:\n    args: The command line arguments:\n\n  Returns:\n    The list of filenames to lint.\n  \"\"\"\n  try:\n    (opts, filenames) = getopt.getopt(args, '', ['help', 'output=', 'verbose=',\n                                                 'v=',\n                                                 'version',\n                                                 'counting=',\n                                                 'filter=',\n                                                 'root=',\n                                                 'repository=',\n                                                 'linelength=',\n                                                 'extensions=',\n                                                 'exclude=',\n                                                 'recursive',\n                                                 'headers=',\n                                                 'quiet'])\n  except getopt.GetoptError:\n    PrintUsage('Invalid arguments.')\n\n  verbosity = _VerboseLevel()\n  output_format = _OutputFormat()\n  filters = ''\n  quiet = _Quiet()\n  counting_style = ''\n  recursive = False\n\n  for (opt, val) in opts:\n    if opt == '--help':\n      PrintUsage(None)\n    if opt == '--version':\n      PrintVersion()\n    elif opt == '--output':\n      if val not in ('emacs', 'vs7', 'eclipse', 'junit'):\n        PrintUsage('The only allowed output formats are emacs, vs7, eclipse '\n                   'and junit.')\n      output_format = val\n    elif opt == '--quiet':\n      quiet = True\n    elif opt == '--verbose' or opt == '--v':\n      verbosity = int(val)\n    elif opt == '--filter':\n      filters = val\n      if not filters:\n        PrintCategories()\n    elif opt == '--counting':\n      if val not in ('total', 'toplevel', 'detailed'):\n        PrintUsage('Valid counting options are total, toplevel, and detailed')\n      counting_style = val\n    elif opt == '--root':\n      global _root\n      _root = val\n    elif opt == '--repository':\n      global _repository\n      _repository = val\n    elif opt == '--linelength':\n      global _line_length\n      try:\n        _line_length = int(val)\n      except ValueError:\n        PrintUsage('Line length must be digits.')\n    elif opt == '--exclude':\n      global _excludes\n      if not _excludes:\n        _excludes = set()\n      _excludes.update(glob.glob(val))\n    elif opt == '--extensions':\n      ProcessExtensionsOption(val)\n    elif opt == '--headers':\n      ProcessHppHeadersOption(val)\n    elif opt == '--recursive':\n      recursive = True\n\n  if not filenames:\n    PrintUsage('No files were specified.')\n\n  if recursive:\n    filenames = _ExpandDirectories(filenames)\n\n  if _excludes:\n    filenames = _FilterExcludedFiles(filenames)\n\n  _SetOutputFormat(output_format)\n  _SetQuiet(quiet)\n  _SetVerboseLevel(verbosity)\n  _SetFilters(filters)\n  _SetCountingStyle(counting_style)\n\n  return filenames\n\ndef _ExpandDirectories(filenames):\n  \"\"\"Searches a list of filenames and replaces directories in the list with\n  all files descending from those directories. Files with extensions not in\n  the valid extensions list are excluded.\n\n  Args:\n    filenames: A list of files or directories\n\n  Returns:\n    A list of all files that are members of filenames or descended from a\n    directory in filenames\n  \"\"\"\n  expanded = set()\n  for filename in filenames:\n    if not os.path.isdir(filename):\n      expanded.add(filename)\n      continue\n\n    for root, _, files in os.walk(filename):\n      for loopfile in files:\n        fullname = os.path.join(root, loopfile)\n        if fullname.startswith('.' + os.path.sep):\n          fullname = fullname[len('.' + os.path.sep):]\n        expanded.add(fullname)\n\n  filtered = []\n  for filename in expanded:\n    if os.path.splitext(filename)[1][1:] in GetAllExtensions():\n      filtered.append(filename)\n  return filtered\n\ndef _FilterExcludedFiles(fnames):\n  \"\"\"Filters out files listed in the --exclude command line switch. File paths\n  in the switch are evaluated relative to the current working directory\n  \"\"\"\n  exclude_paths = [os.path.abspath(f) for f in _excludes]\n  # because globbing does not work recursively, exclude all subpath of all excluded entries\n  return [f for f in fnames\n          if not any(e for e in exclude_paths\n                  if _IsParentOrSame(e, os.path.abspath(f)))]\n\ndef _IsParentOrSame(parent, child):\n  \"\"\"Return true if child is subdirectory of parent.\n  Assumes both paths are absolute and don't contain symlinks.\n  \"\"\"\n  parent = os.path.normpath(parent)\n  child = os.path.normpath(child)\n  if parent == child:\n    return True\n\n  prefix = os.path.commonprefix([parent, child])\n  if prefix != parent:\n    return False\n  # Note: os.path.commonprefix operates on character basis, so\n  # take extra care of situations like '/foo/ba' and '/foo/bar/baz'\n  child_suffix = child[len(prefix):]\n  child_suffix = child_suffix.lstrip(os.sep)\n  return child == os.path.join(prefix, child_suffix)\n\ndef main():\n  filenames = ParseArguments(sys.argv[1:])\n  backup_err = sys.stderr\n  try:\n    # Change stderr to write with replacement characters so we don't die\n    # if we try to print something containing non-ASCII characters.\n    sys.stderr = codecs.StreamReader(sys.stderr, 'replace')\n\n    _cpplint_state.ResetErrorCounts()\n    for filename in filenames:\n      ProcessFile(filename, _cpplint_state.verbose_level)\n    # If --quiet is passed, suppress printing error count unless there are errors.\n    if not _cpplint_state.quiet or _cpplint_state.error_count > 0:\n      _cpplint_state.PrintErrorCounts()\n\n    if _cpplint_state.output_format == 'junit':\n      sys.stderr.write(_cpplint_state.FormatJUnitXML())\n\n  finally:\n    sys.stderr = backup_err\n\n  sys.exit(_cpplint_state.error_count > 0)\n\n\nif __name__ == '__main__':\n  main()\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "include_dirs.js",
          "type": "blob",
          "size": 0.0537109375,
          "content": "console.log(require('path').relative('.', __dirname));\n"
        },
        {
          "name": "nan.h",
          "type": "blob",
          "size": 91.4482421875,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors:\n *   - Rod Vagg <https://github.com/rvagg>\n *   - Benjamin Byholm <https://github.com/kkoopa>\n *   - Trevor Norris <https://github.com/trevnorris>\n *   - Nathan Rajlich <https://github.com/TooTallNate>\n *   - Brett Lawson <https://github.com/brett19>\n *   - Ben Noordhuis <https://github.com/bnoordhuis>\n *   - David Siegel <https://github.com/agnat>\n *   - Michael Ira Krufky <https://github.com/mkrufky>\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n *\n * Version 2.22.0: current Node 22.9.0, Node 0.12: 0.12.18, Node 0.10: 0.10.48, iojs: 3.3.1\n *\n * See https://github.com/nodejs/nan for the latest update to this file\n **********************************************************************************/\n\n#ifndef NAN_H_\n#define NAN_H_\n\n#include <node_version.h>\n\n#define NODE_0_10_MODULE_VERSION 11\n#define NODE_0_12_MODULE_VERSION 14\n#define ATOM_0_21_MODULE_VERSION 41\n#define IOJS_1_0_MODULE_VERSION  42\n#define IOJS_1_1_MODULE_VERSION  43\n#define IOJS_2_0_MODULE_VERSION  44\n#define IOJS_3_0_MODULE_VERSION  45\n#define NODE_4_0_MODULE_VERSION  46\n#define NODE_5_0_MODULE_VERSION  47\n#define NODE_6_0_MODULE_VERSION  48\n#define NODE_7_0_MODULE_VERSION  51\n#define NODE_8_0_MODULE_VERSION  57\n#define NODE_9_0_MODULE_VERSION  59\n#define NODE_10_0_MODULE_VERSION 64\n#define NODE_11_0_MODULE_VERSION 67\n#define NODE_12_0_MODULE_VERSION 72\n#define NODE_13_0_MODULE_VERSION 79\n#define NODE_14_0_MODULE_VERSION 83\n#define NODE_15_0_MODULE_VERSION 88\n#define NODE_16_0_MODULE_VERSION 93\n#define NODE_17_0_MODULE_VERSION 102\n#define NODE_18_0_MODULE_VERSION 108\n#define NODE_19_0_MODULE_VERSION 111\n#define NODE_20_0_MODULE_VERSION 115\n\n#ifdef _MSC_VER\n# define NAN_HAS_CPLUSPLUS_11 (_MSC_VER >= 1800)\n#else\n# define NAN_HAS_CPLUSPLUS_11 (__cplusplus >= 201103L)\n#endif\n\n#if NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION && !NAN_HAS_CPLUSPLUS_11\n# error This version of node/NAN/v8 requires a C++11 compiler\n#endif\n\n#include <uv.h>\n#include <node.h>\n#include <node_buffer.h>\n#include <node_object_wrap.h>\n#include <algorithm>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <utility>\n#if defined(_MSC_VER)\n# pragma warning( push )\n# pragma warning( disable : 4530 )\n# include <queue>\n# include <string>\n# include <vector>\n# pragma warning( pop )\n#else\n# include <queue>\n# include <string>\n# include <vector>\n#endif\n\n// uv helpers\n#ifdef UV_VERSION_MAJOR\n# ifndef UV_VERSION_PATCH\n#  define UV_VERSION_PATCH 0\n# endif\n# define NAUV_UVVERSION ((UV_VERSION_MAJOR << 16) | \\\n                         (UV_VERSION_MINOR <<  8) | \\\n                         (UV_VERSION_PATCH))\n#else\n# define NAUV_UVVERSION 0x000b00\n#endif\n\n#if NAUV_UVVERSION < 0x000b0b\n# ifdef WIN32\n#  include <windows.h>\n# else\n#  include <pthread.h>\n# endif\n#endif\n\nnamespace Nan {\n\n#define NAN_CONCAT(a, b) NAN_CONCAT_HELPER(a, b)\n#define NAN_CONCAT_HELPER(a, b) a##b\n\n#define NAN_INLINE inline  // TODO(bnoordhuis) Remove in v3.0.0.\n\n#if defined(__GNUC__) && \\\n    !(defined(V8_DISABLE_DEPRECATIONS) && V8_DISABLE_DEPRECATIONS)\n# define NAN_DEPRECATED __attribute__((deprecated))\n#elif defined(_MSC_VER) && \\\n    !(defined(V8_DISABLE_DEPRECATIONS) && V8_DISABLE_DEPRECATIONS)\n# define NAN_DEPRECATED __declspec(deprecated)\n#else\n# define NAN_DEPRECATED\n#endif\n\n#if NAN_HAS_CPLUSPLUS_11\n# define NAN_DISALLOW_ASSIGN(CLASS) void operator=(const CLASS&) = delete;\n# define NAN_DISALLOW_COPY(CLASS) CLASS(const CLASS&) = delete;\n# define NAN_DISALLOW_MOVE(CLASS)                                              \\\n    CLASS(CLASS&&) = delete;  /* NOLINT(build/c++11) */                        \\\n    void operator=(CLASS&&) = delete;\n#else\n# define NAN_DISALLOW_ASSIGN(CLASS) void operator=(const CLASS&);\n# define NAN_DISALLOW_COPY(CLASS) CLASS(const CLASS&);\n# define NAN_DISALLOW_MOVE(CLASS)\n#endif\n\n#define NAN_DISALLOW_ASSIGN_COPY(CLASS)                                        \\\n    NAN_DISALLOW_ASSIGN(CLASS)                                                 \\\n    NAN_DISALLOW_COPY(CLASS)\n\n#define NAN_DISALLOW_ASSIGN_MOVE(CLASS)                                        \\\n    NAN_DISALLOW_ASSIGN(CLASS)                                                 \\\n    NAN_DISALLOW_MOVE(CLASS)\n\n#define NAN_DISALLOW_COPY_MOVE(CLASS)                                          \\\n    NAN_DISALLOW_COPY(CLASS)                                                   \\\n    NAN_DISALLOW_MOVE(CLASS)\n\n#define NAN_DISALLOW_ASSIGN_COPY_MOVE(CLASS)                                   \\\n    NAN_DISALLOW_ASSIGN(CLASS)                                                 \\\n    NAN_DISALLOW_COPY(CLASS)                                                   \\\n    NAN_DISALLOW_MOVE(CLASS)\n\n#define TYPE_CHECK(T, S)                                                       \\\n    while (false) {                                                            \\\n      *(static_cast<T *volatile *>(0)) = static_cast<S*>(0);                   \\\n    }\n\n//=== RegistrationFunction =====================================================\n\n#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n  typedef v8::Handle<v8::Object> ADDON_REGISTER_FUNCTION_ARGS_TYPE;\n#else\n  typedef v8::Local<v8::Object> ADDON_REGISTER_FUNCTION_ARGS_TYPE;\n#endif\n\n#define NAN_MODULE_INIT(name)                                                  \\\n    void name(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target)\n\n#if NODE_MAJOR_VERSION >= 10 || \\\n    NODE_MAJOR_VERSION == 9 && NODE_MINOR_VERSION >= 3\n#define NAN_MODULE_WORKER_ENABLED(module_name, registration)                   \\\n    extern \"C\" NODE_MODULE_EXPORT void                                         \\\n      NAN_CONCAT(node_register_module_v, NODE_MODULE_VERSION)(                 \\\n        v8::Local<v8::Object> exports, v8::Local<v8::Value> module,            \\\n        v8::Local<v8::Context> context)                                        \\\n    {                                                                          \\\n        registration(exports);                                                 \\\n    }\n#else\n#define NAN_MODULE_WORKER_ENABLED(module_name, registration)                   \\\n    NODE_MODULE(module_name, registration)\n#endif\n\n//=== CallbackInfo =============================================================\n\n#include \"nan_callbacks.h\"  // NOLINT(build/include)\n\n//==============================================================================\n\n#if (NODE_MODULE_VERSION < NODE_0_12_MODULE_VERSION)\ntypedef v8::Script             UnboundScript;\ntypedef v8::Script             BoundScript;\n#else\ntypedef v8::UnboundScript      UnboundScript;\ntypedef v8::Script             BoundScript;\n#endif\n\n#if (NODE_MODULE_VERSION < ATOM_0_21_MODULE_VERSION)\ntypedef v8::String::ExternalAsciiStringResource\n    ExternalOneByteStringResource;\n#else\ntypedef v8::String::ExternalOneByteStringResource\n    ExternalOneByteStringResource;\n#endif\n\n#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)\ntemplate<typename T>\nclass NonCopyablePersistentTraits :\n    public v8::NonCopyablePersistentTraits<T> {};\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 10 ||                     \\\n  (V8_MAJOR_VERSION == 10 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 5))\ntemplate<typename T> struct CopyablePersistentTraits {\n  typedef v8::Persistent<T, CopyablePersistentTraits<T> > CopyablePersistent;\n  static const bool kResetInDestructor = true;\n  template <typename S, typename M>\n  static NAN_INLINE void Copy(const v8::Persistent<S, M> &source,\n      CopyablePersistent *dest) {\n  }\n};\n#else\ntemplate<typename T>\nclass CopyablePersistentTraits :\n    public v8::CopyablePersistentTraits<T> {};\n#endif\n\ntemplate<typename T>\nclass PersistentBase :\n    public v8::PersistentBase<T> {};\n\ntemplate<typename T, typename M = v8::NonCopyablePersistentTraits<T> >\nclass Persistent;\n#else\ntemplate<typename T> class NonCopyablePersistentTraits;\ntemplate<typename T> class PersistentBase;\ntemplate<typename T, typename P> class WeakCallbackData;\ntemplate<typename T, typename M = NonCopyablePersistentTraits<T> >\nclass Persistent;\n#endif  // NODE_MODULE_VERSION\n\ntemplate<typename T>\nclass Maybe {\n public:\n  inline bool IsNothing() const { return !has_value_; }\n  inline bool IsJust() const { return has_value_; }\n\n  inline T ToChecked() const { return FromJust(); }\n  inline void Check() const { FromJust(); }\n\n  inline bool To(T* out) const {\n    if (IsJust()) *out = value_;\n    return IsJust();\n  }\n\n  inline T FromJust() const {\n#if defined(V8_ENABLE_CHECKS)\n    assert(IsJust() && \"FromJust is Nothing\");\n#endif  // V8_ENABLE_CHECKS\n    return value_;\n  }\n\n  inline T FromMaybe(const T& default_value) const {\n    return has_value_ ? value_ : default_value;\n  }\n\n  inline bool operator==(const Maybe &other) const {\n    return (IsJust() == other.IsJust()) &&\n        (!IsJust() || FromJust() == other.FromJust());\n  }\n\n  inline bool operator!=(const Maybe &other) const {\n    return !operator==(other);\n  }\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n  // Allow implicit conversions from v8::Maybe<T> to Nan::Maybe<T>.\n  Maybe(const v8::Maybe<T>& that)  // NOLINT(runtime/explicit)\n    : has_value_(that.IsJust())\n    , value_(that.FromMaybe(T())) {}\n#endif\n\n private:\n  Maybe() : has_value_(false) {}\n  explicit Maybe(const T& t) : has_value_(true), value_(t) {}\n  bool has_value_;\n  T value_;\n\n  template<typename U>\n  friend Maybe<U> Nothing();\n  template<typename U>\n  friend Maybe<U> Just(const U& u);\n};\n\ntemplate<typename T>\ninline Maybe<T> Nothing() {\n  return Maybe<T>();\n}\n\ntemplate<typename T>\ninline Maybe<T> Just(const T& t) {\n  return Maybe<T>(t);\n}\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n# include \"nan_maybe_43_inl.h\"  // NOLINT(build/include)\n#else\n# include \"nan_maybe_pre_43_inl.h\"  // NOLINT(build/include)\n#endif\n\n#include \"nan_converters.h\"  // NOLINT(build/include)\n#include \"nan_new.h\"  // NOLINT(build/include)\n\n#if NAUV_UVVERSION < 0x000b17\n#define NAUV_WORK_CB(func) \\\n    void func(uv_async_t *async, int)\n#else\n#define NAUV_WORK_CB(func) \\\n    void func(uv_async_t *async)\n#endif\n\n#if NAUV_UVVERSION >= 0x000b0b\n\ntypedef uv_key_t nauv_key_t;\n\ninline int nauv_key_create(nauv_key_t *key) {\n  return uv_key_create(key);\n}\n\ninline void nauv_key_delete(nauv_key_t *key) {\n  uv_key_delete(key);\n}\n\ninline void* nauv_key_get(nauv_key_t *key) {\n  return uv_key_get(key);\n}\n\ninline void nauv_key_set(nauv_key_t *key, void *value) {\n  uv_key_set(key, value);\n}\n\n#else\n\n/* Implement thread local storage for older versions of libuv.\n * This is essentially a backport of libuv commit 5d2434bf\n * written by Ben Noordhuis, adjusted for names and inline.\n */\n\n#ifndef WIN32\n\ntypedef pthread_key_t nauv_key_t;\n\ninline int nauv_key_create(nauv_key_t* key) {\n  return -pthread_key_create(key, NULL);\n}\n\ninline void nauv_key_delete(nauv_key_t* key) {\n  if (pthread_key_delete(*key))\n    abort();\n}\n\ninline void* nauv_key_get(nauv_key_t* key) {\n  return pthread_getspecific(*key);\n}\n\ninline void nauv_key_set(nauv_key_t* key, void* value) {\n  if (pthread_setspecific(*key, value))\n    abort();\n}\n\n#else\n\ntypedef struct {\n  DWORD tls_index;\n} nauv_key_t;\n\ninline int nauv_key_create(nauv_key_t* key) {\n  key->tls_index = TlsAlloc();\n  if (key->tls_index == TLS_OUT_OF_INDEXES)\n    return UV_ENOMEM;\n  return 0;\n}\n\ninline void nauv_key_delete(nauv_key_t* key) {\n  if (TlsFree(key->tls_index) == FALSE)\n    abort();\n  key->tls_index = TLS_OUT_OF_INDEXES;\n}\n\ninline void* nauv_key_get(nauv_key_t* key) {\n  void* value = TlsGetValue(key->tls_index);\n  if (value == NULL)\n    if (GetLastError() != ERROR_SUCCESS)\n      abort();\n  return value;\n}\n\ninline void nauv_key_set(nauv_key_t* key, void* value) {\n  if (TlsSetValue(key->tls_index, value) == FALSE)\n    abort();\n}\n\n#endif\n#endif\n\n#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\ntemplate<typename T>\nv8::Local<T> New(v8::Handle<T>);\n#endif\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n  typedef v8::WeakCallbackType WeakCallbackType;\n#else\nstruct WeakCallbackType {\n  enum E {kParameter, kInternalFields};\n  E type;\n  WeakCallbackType(E other) : type(other) {}  // NOLINT(runtime/explicit)\n  inline bool operator==(E other) { return other == this->type; }\n  inline bool operator!=(E other) { return !operator==(other); }\n};\n#endif\n\ntemplate<typename P> class WeakCallbackInfo;\n\n#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n# include \"nan_persistent_12_inl.h\"  // NOLINT(build/include)\n#else\n# include \"nan_persistent_pre_12_inl.h\"  // NOLINT(build/include)\n#endif\n\nnamespace imp {\n  static const size_t kMaxLength = 0x3fffffff;\n  // v8::String::REPLACE_INVALID_UTF8 was introduced\n  // in node.js v0.10.29 and v0.8.27.\n#if NODE_MAJOR_VERSION > 0 || \\\n    NODE_MINOR_VERSION > 10 || \\\n    NODE_MINOR_VERSION == 10 && NODE_PATCH_VERSION >= 29 || \\\n    NODE_MINOR_VERSION == 8 && NODE_PATCH_VERSION >= 27\n  static const unsigned kReplaceInvalidUtf8 = v8::String::REPLACE_INVALID_UTF8;\n#else\n  static const unsigned kReplaceInvalidUtf8 = 0;\n#endif\n}  // end of namespace imp\n\n//=== HandleScope ==============================================================\n\nclass HandleScope {\n  v8::HandleScope scope;\n\n public:\n#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n  inline HandleScope() : scope(v8::Isolate::GetCurrent()) {}\n  inline static int NumberOfHandles() {\n    return v8::HandleScope::NumberOfHandles(v8::Isolate::GetCurrent());\n  }\n#else\n  inline HandleScope() : scope() {}\n  inline static int NumberOfHandles() {\n    return v8::HandleScope::NumberOfHandles();\n  }\n#endif\n\n private:\n  // Make it hard to create heap-allocated or illegal handle scopes by\n  // disallowing certain operations.\n  HandleScope(const HandleScope &);\n  void operator=(const HandleScope &);\n  void *operator new(size_t size);\n  void operator delete(void *, size_t) {\n    abort();\n  }\n};\n\nclass EscapableHandleScope {\n public:\n#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n  inline EscapableHandleScope() : scope(v8::Isolate::GetCurrent()) {}\n\n  inline static int NumberOfHandles() {\n    return v8::EscapableHandleScope::NumberOfHandles(v8::Isolate::GetCurrent());\n  }\n\n  template<typename T>\n  inline v8::Local<T> Escape(v8::Local<T> value) {\n    return scope.Escape(value);\n  }\n\n private:\n  v8::EscapableHandleScope scope;\n#else\n  inline EscapableHandleScope() : scope() {}\n\n  inline static int NumberOfHandles() {\n    return v8::HandleScope::NumberOfHandles();\n  }\n\n  template<typename T>\n  inline v8::Local<T> Escape(v8::Local<T> value) {\n    return scope.Close(value);\n  }\n\n private:\n  v8::HandleScope scope;\n#endif\n\n private:\n  // Make it hard to create heap-allocated or illegal handle scopes by\n  // disallowing certain operations.\n  EscapableHandleScope(const EscapableHandleScope &);\n  void operator=(const EscapableHandleScope &);\n  void *operator new(size_t size);\n  void operator delete(void *, size_t) {\n    abort();\n  }\n};\n\n//=== TryCatch =================================================================\n\nclass TryCatch {\n  v8::TryCatch try_catch_;\n  friend void FatalException(const TryCatch&);\n\n public:\n#if NODE_MODULE_VERSION > NODE_0_12_MODULE_VERSION\n  TryCatch() : try_catch_(v8::Isolate::GetCurrent()) {}\n#endif\n\n  inline bool HasCaught() const { return try_catch_.HasCaught(); }\n\n  inline bool CanContinue() const { return try_catch_.CanContinue(); }\n\n  inline v8::Local<v8::Value> ReThrow() {\n#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n    return New(try_catch_.ReThrow());\n#else\n    return try_catch_.ReThrow();\n#endif\n  }\n\n  inline v8::Local<v8::Value> Exception() const {\n    return try_catch_.Exception();\n  }\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n  inline v8::MaybeLocal<v8::Value> StackTrace() const {\n    v8::Isolate *isolate = v8::Isolate::GetCurrent();\n    v8::EscapableHandleScope scope(isolate);\n    return scope.Escape(try_catch_.StackTrace(isolate->GetCurrentContext())\n                            .FromMaybe(v8::Local<v8::Value>()));\n  }\n#else\n  inline MaybeLocal<v8::Value> StackTrace() const {\n    return try_catch_.StackTrace();\n  }\n#endif\n\n  inline v8::Local<v8::Message> Message() const {\n    return try_catch_.Message();\n  }\n\n  inline void Reset() { try_catch_.Reset(); }\n\n  inline void SetVerbose(bool value) { try_catch_.SetVerbose(value); }\n\n  inline void SetCaptureMessage(bool value) {\n    try_catch_.SetCaptureMessage(value);\n  }\n};\n\nv8::Local<v8::Value> MakeCallback(v8::Local<v8::Object> target,\n                                  v8::Local<v8::Function> func,\n                                  int argc,\n                                  v8::Local<v8::Value>* argv);\nv8::Local<v8::Value> MakeCallback(v8::Local<v8::Object> target,\n                                  v8::Local<v8::String> symbol,\n                                  int argc,\n                                  v8::Local<v8::Value>* argv);\nv8::Local<v8::Value> MakeCallback(v8::Local<v8::Object> target,\n                                  const char* method,\n                                  int argc,\n                                  v8::Local<v8::Value>* argv);\n\n// === AsyncResource ===========================================================\n\nclass AsyncResource {\n public:\n  AsyncResource(\n      v8::Local<v8::String> name\n    , v8::Local<v8::Object> resource = New<v8::Object>()) {\n#if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n\n    if (resource.IsEmpty()) {\n      resource = New<v8::Object>();\n    }\n\n    context = node::EmitAsyncInit(isolate, resource, name);\n#endif\n  }\n\n  AsyncResource(\n      const char* name\n    , v8::Local<v8::Object> resource = New<v8::Object>()) {\n#if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n\n    if (resource.IsEmpty()) {\n      resource = New<v8::Object>();\n    }\n\n    v8::Local<v8::String> name_string =\n        New<v8::String>(name).ToLocalChecked();\n    context = node::EmitAsyncInit(isolate, resource, name_string);\n#endif\n  }\n\n  ~AsyncResource() {\n#if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n    node::EmitAsyncDestroy(isolate, context);\n#endif\n  }\n\n  inline MaybeLocal<v8::Value> runInAsyncScope(\n      v8::Local<v8::Object> target\n    , v8::Local<v8::Function> func\n    , int argc\n    , v8::Local<v8::Value>* argv) {\n#if NODE_MODULE_VERSION < NODE_9_0_MODULE_VERSION\n    return MakeCallback(target, func, argc, argv);\n#else\n    return node::MakeCallback(\n        v8::Isolate::GetCurrent(), target, func, argc, argv, context);\n#endif\n  }\n\n  inline MaybeLocal<v8::Value> runInAsyncScope(\n      v8::Local<v8::Object> target\n    , v8::Local<v8::String> symbol\n    , int argc\n    , v8::Local<v8::Value>* argv) {\n#if NODE_MODULE_VERSION < NODE_9_0_MODULE_VERSION\n    return MakeCallback(target, symbol, argc, argv);\n#else\n    return node::MakeCallback(\n        v8::Isolate::GetCurrent(), target, symbol, argc, argv, context);\n#endif\n  }\n\n  inline MaybeLocal<v8::Value> runInAsyncScope(\n      v8::Local<v8::Object> target\n    , const char* method\n    , int argc\n    , v8::Local<v8::Value>* argv) {\n#if NODE_MODULE_VERSION < NODE_9_0_MODULE_VERSION\n    return MakeCallback(target, method, argc, argv);\n#else\n    return node::MakeCallback(\n        v8::Isolate::GetCurrent(), target, method, argc, argv, context);\n#endif\n  }\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(AsyncResource)\n#if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n  node::async_context context;\n#endif\n};\n\ninline uv_loop_t* GetCurrentEventLoop() {\n#if NODE_MAJOR_VERSION >= 10 || \\\n  NODE_MAJOR_VERSION == 9 && NODE_MINOR_VERSION >= 3 || \\\n  NODE_MAJOR_VERSION == 8 && NODE_MINOR_VERSION >= 10\n    return node::GetCurrentEventLoop(v8::Isolate::GetCurrent());\n#else\n    return uv_default_loop();\n#endif\n}\n\n//============ =================================================================\n\n/* node 0.12  */\n#if NODE_MODULE_VERSION >= NODE_0_12_MODULE_VERSION\n  inline\n  void SetCounterFunction(v8::CounterLookupCallback cb) {\n    v8::Isolate::GetCurrent()->SetCounterFunction(cb);\n  }\n\n  inline\n  void SetCreateHistogramFunction(v8::CreateHistogramCallback cb) {\n    v8::Isolate::GetCurrent()->SetCreateHistogramFunction(cb);\n  }\n\n  inline\n  void SetAddHistogramSampleFunction(v8::AddHistogramSampleCallback cb) {\n    v8::Isolate::GetCurrent()->SetAddHistogramSampleFunction(cb);\n  }\n\n#if defined(V8_MAJOR_VERSION) &&                                               \\\n      (V8_MAJOR_VERSION > 12 ||                                                \\\n       (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) &&                 \\\n        V8_MINOR_VERSION >= 7))\n  NAN_DEPRECATED inline bool IdleNotification(int) {\n    return true;\n  }\n# elif defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                   \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n  NAN_DEPRECATED inline bool IdleNotification(int idle_time_in_ms) {\n    return v8::Isolate::GetCurrent()->IdleNotificationDeadline(\n        idle_time_in_ms * 0.001);\n  }\n# else\n  NAN_DEPRECATED inline bool IdleNotification(int idle_time_in_ms) {\n    return v8::Isolate::GetCurrent()->IdleNotification(idle_time_in_ms);\n  }\n#endif\n\n  inline void LowMemoryNotification() {\n    v8::Isolate::GetCurrent()->LowMemoryNotification();\n  }\n\n  inline void ContextDisposedNotification() {\n    v8::Isolate::GetCurrent()->ContextDisposedNotification();\n  }\n#else\n  inline\n  void SetCounterFunction(v8::CounterLookupCallback cb) {\n    v8::V8::SetCounterFunction(cb);\n  }\n\n  inline\n  void SetCreateHistogramFunction(v8::CreateHistogramCallback cb) {\n    v8::V8::SetCreateHistogramFunction(cb);\n  }\n\n  inline\n  void SetAddHistogramSampleFunction(v8::AddHistogramSampleCallback cb) {\n    v8::V8::SetAddHistogramSampleFunction(cb);\n  }\n\n  inline bool IdleNotification(int idle_time_in_ms) {\n    return v8::V8::IdleNotification(idle_time_in_ms);\n  }\n\n  inline void LowMemoryNotification() {\n    v8::V8::LowMemoryNotification();\n  }\n\n  inline void ContextDisposedNotification() {\n    v8::V8::ContextDisposedNotification();\n  }\n#endif\n\n#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)  // Node 0.12\n  inline v8::Local<v8::Primitive> Undefined() {\n# if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n    EscapableHandleScope scope;\n    return scope.Escape(New(v8::Undefined(v8::Isolate::GetCurrent())));\n# else\n    return v8::Undefined(v8::Isolate::GetCurrent());\n# endif\n  }\n\n  inline v8::Local<v8::Primitive> Null() {\n# if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n    EscapableHandleScope scope;\n    return scope.Escape(New(v8::Null(v8::Isolate::GetCurrent())));\n# else\n    return v8::Null(v8::Isolate::GetCurrent());\n# endif\n  }\n\n  inline v8::Local<v8::Boolean> True() {\n# if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n    EscapableHandleScope scope;\n    return scope.Escape(New(v8::True(v8::Isolate::GetCurrent())));\n# else\n    return v8::True(v8::Isolate::GetCurrent());\n# endif\n  }\n\n  inline v8::Local<v8::Boolean> False() {\n# if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n    EscapableHandleScope scope;\n    return scope.Escape(New(v8::False(v8::Isolate::GetCurrent())));\n# else\n    return v8::False(v8::Isolate::GetCurrent());\n# endif\n  }\n\n  inline v8::Local<v8::String> EmptyString() {\n    return v8::String::Empty(v8::Isolate::GetCurrent());\n  }\n\n  inline int AdjustExternalMemory(int bc) {\n    return static_cast<int>(\n        v8::Isolate::GetCurrent()->AdjustAmountOfExternalAllocatedMemory(bc));\n  }\n\n  inline void SetTemplate(\n      v8::Local<v8::Template> templ\n    , const char *name\n    , v8::Local<v8::Data> value) {\n    templ->Set(v8::Isolate::GetCurrent(), name, value);\n  }\n\n  inline void SetTemplate(\n      v8::Local<v8::Template> templ\n    , v8::Local<v8::String> name\n    , v8::Local<v8::Data> value\n    , v8::PropertyAttribute attributes) {\n    templ->Set(name, value, attributes);\n  }\n\n  inline v8::Local<v8::Context> GetCurrentContext() {\n    return v8::Isolate::GetCurrent()->GetCurrentContext();\n  }\n\n  inline void* GetInternalFieldPointer(\n      v8::Local<v8::Object> object\n    , int index) {\n    return object->GetAlignedPointerFromInternalField(index);\n  }\n\n  inline void SetInternalFieldPointer(\n      v8::Local<v8::Object> object\n    , int index\n    , void* value) {\n    object->SetAlignedPointerInInternalField(index, value);\n  }\n\n# define NAN_GC_CALLBACK(name)                                                 \\\n    void name(v8::Isolate *isolate, v8::GCType type, v8::GCCallbackFlags flags)\n\n#if NODE_MODULE_VERSION <= NODE_4_0_MODULE_VERSION\n  typedef v8::Isolate::GCEpilogueCallback GCEpilogueCallback;\n  typedef v8::Isolate::GCPrologueCallback GCPrologueCallback;\n#else\n  typedef v8::Isolate::GCCallback GCEpilogueCallback;\n  typedef v8::Isolate::GCCallback GCPrologueCallback;\n#endif\n\n  inline void AddGCEpilogueCallback(\n      GCEpilogueCallback callback\n    , v8::GCType gc_type_filter = v8::kGCTypeAll) {\n    v8::Isolate::GetCurrent()->AddGCEpilogueCallback(callback, gc_type_filter);\n  }\n\n  inline void RemoveGCEpilogueCallback(\n      GCEpilogueCallback callback) {\n    v8::Isolate::GetCurrent()->RemoveGCEpilogueCallback(callback);\n  }\n\n  inline void AddGCPrologueCallback(\n      GCPrologueCallback callback\n    , v8::GCType gc_type_filter = v8::kGCTypeAll) {\n    v8::Isolate::GetCurrent()->AddGCPrologueCallback(callback, gc_type_filter);\n  }\n\n  inline void RemoveGCPrologueCallback(\n      GCPrologueCallback callback) {\n    v8::Isolate::GetCurrent()->RemoveGCPrologueCallback(callback);\n  }\n\n  inline void GetHeapStatistics(\n      v8::HeapStatistics *heap_statistics) {\n    v8::Isolate::GetCurrent()->GetHeapStatistics(heap_statistics);\n  }\n\n# define X(NAME)                                                               \\\n    inline v8::Local<v8::Value> NAME(const char *msg) {                        \\\n      EscapableHandleScope scope;                                              \\\n      return scope.Escape(v8::Exception::NAME(New(msg).ToLocalChecked()));     \\\n    }                                                                          \\\n                                                                               \\\n    inline                                                                     \\\n    v8::Local<v8::Value> NAME(v8::Local<v8::String> msg) {                     \\\n      return v8::Exception::NAME(msg);                                         \\\n    }                                                                          \\\n                                                                               \\\n    inline void Throw ## NAME(const char *msg) {                               \\\n      HandleScope scope;                                                       \\\n      v8::Isolate::GetCurrent()->ThrowException(                               \\\n          v8::Exception::NAME(New(msg).ToLocalChecked()));                     \\\n    }                                                                          \\\n                                                                               \\\n    inline void Throw ## NAME(v8::Local<v8::String> msg) {                     \\\n      HandleScope scope;                                                       \\\n      v8::Isolate::GetCurrent()->ThrowException(                               \\\n          v8::Exception::NAME(msg));                                           \\\n    }\n\n  X(Error)\n  X(RangeError)\n  X(ReferenceError)\n  X(SyntaxError)\n  X(TypeError)\n\n# undef X\n\n  inline void ThrowError(v8::Local<v8::Value> error) {\n    v8::Isolate::GetCurrent()->ThrowException(error);\n  }\n\n  inline MaybeLocal<v8::Object> NewBuffer(\n      char *data\n    , size_t length\n#if NODE_MODULE_VERSION > IOJS_2_0_MODULE_VERSION\n    , node::Buffer::FreeCallback callback\n#else\n    , node::smalloc::FreeCallback callback\n#endif\n    , void *hint\n  ) {\n    // arbitrary buffer lengths requires\n    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION\n    assert(length <= imp::kMaxLength && \"too large buffer\");\n#if NODE_MODULE_VERSION > IOJS_2_0_MODULE_VERSION\n    return node::Buffer::New(\n        v8::Isolate::GetCurrent(), data, length, callback, hint);\n#else\n    return node::Buffer::New(v8::Isolate::GetCurrent(), data, length, callback,\n                             hint);\n#endif\n  }\n\n  inline MaybeLocal<v8::Object> CopyBuffer(\n      const char *data\n    , uint32_t size\n  ) {\n    // arbitrary buffer lengths requires\n    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION\n    assert(size <= imp::kMaxLength && \"too large buffer\");\n#if NODE_MODULE_VERSION > IOJS_2_0_MODULE_VERSION\n    return node::Buffer::Copy(\n        v8::Isolate::GetCurrent(), data, size);\n#else\n    return node::Buffer::New(v8::Isolate::GetCurrent(), data, size);\n#endif\n  }\n\n  inline MaybeLocal<v8::Object> NewBuffer(uint32_t size) {\n    // arbitrary buffer lengths requires\n    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION\n    assert(size <= imp::kMaxLength && \"too large buffer\");\n#if NODE_MODULE_VERSION > IOJS_2_0_MODULE_VERSION\n    return node::Buffer::New(\n        v8::Isolate::GetCurrent(), size);\n#else\n    return node::Buffer::New(v8::Isolate::GetCurrent(), size);\n#endif\n  }\n\n  inline MaybeLocal<v8::Object> NewBuffer(\n      char* data\n    , uint32_t size\n  ) {\n    // arbitrary buffer lengths requires\n    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION\n    assert(size <= imp::kMaxLength && \"too large buffer\");\n#if NODE_MODULE_VERSION > IOJS_2_0_MODULE_VERSION\n    return node::Buffer::New(v8::Isolate::GetCurrent(), data, size);\n#else\n    return node::Buffer::Use(v8::Isolate::GetCurrent(), data, size);\n#endif\n  }\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n  inline MaybeLocal<v8::String>\n  NewOneByteString(const uint8_t * value, int length = -1) {\n    return v8::String::NewFromOneByte(v8::Isolate::GetCurrent(), value,\n          v8::NewStringType::kNormal, length);\n  }\n\n  inline MaybeLocal<BoundScript> CompileScript(\n      v8::Local<v8::String> s\n    , const v8::ScriptOrigin& origin\n  ) {\n    v8::Isolate *isolate = v8::Isolate::GetCurrent();\n    v8::EscapableHandleScope scope(isolate);\n    v8::ScriptCompiler::Source source(s, origin);\n    return scope.Escape(\n        v8::ScriptCompiler::Compile(isolate->GetCurrentContext(), &source)\n            .FromMaybe(v8::Local<BoundScript>()));\n  }\n\n  inline MaybeLocal<BoundScript> CompileScript(\n      v8::Local<v8::String> s\n  ) {\n    v8::Isolate *isolate = v8::Isolate::GetCurrent();\n    v8::EscapableHandleScope scope(isolate);\n    v8::ScriptCompiler::Source source(s);\n    return scope.Escape(\n        v8::ScriptCompiler::Compile(isolate->GetCurrentContext(), &source)\n            .FromMaybe(v8::Local<BoundScript>()));\n  }\n\n  inline MaybeLocal<v8::Value> RunScript(\n      v8::Local<UnboundScript> script\n  ) {\n    v8::Isolate *isolate = v8::Isolate::GetCurrent();\n    v8::EscapableHandleScope scope(isolate);\n    return scope.Escape(script->BindToCurrentContext()\n                            ->Run(isolate->GetCurrentContext())\n                            .FromMaybe(v8::Local<v8::Value>()));\n  }\n\n  inline MaybeLocal<v8::Value> RunScript(\n      v8::Local<BoundScript> script\n  ) {\n    v8::Isolate *isolate = v8::Isolate::GetCurrent();\n    v8::EscapableHandleScope scope(isolate);\n    return scope.Escape(script->Run(isolate->GetCurrentContext())\n                            .FromMaybe(v8::Local<v8::Value>()));\n  }\n#else\n  inline MaybeLocal<v8::String>\n  NewOneByteString(const uint8_t * value, int length = -1) {\n    return v8::String::NewFromOneByte(v8::Isolate::GetCurrent(), value,\n                                      v8::String::kNormalString, length);\n  }\n\n  inline MaybeLocal<BoundScript> CompileScript(\n      v8::Local<v8::String> s\n    , const v8::ScriptOrigin& origin\n  ) {\n    v8::ScriptCompiler::Source source(s, origin);\n    return v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &source);\n  }\n\n  inline MaybeLocal<BoundScript> CompileScript(\n      v8::Local<v8::String> s\n  ) {\n    v8::ScriptCompiler::Source source(s);\n    return v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &source);\n  }\n\n  inline MaybeLocal<v8::Value> RunScript(\n      v8::Local<UnboundScript> script\n  ) {\n    EscapableHandleScope scope;\n    return scope.Escape(script->BindToCurrentContext()->Run());\n  }\n\n  inline MaybeLocal<v8::Value> RunScript(\n      v8::Local<BoundScript> script\n  ) {\n    return script->Run();\n  }\n#endif\n\n  NAN_DEPRECATED inline v8::Local<v8::Value> MakeCallback(\n      v8::Local<v8::Object> target\n    , v8::Local<v8::Function> func\n    , int argc\n    , v8::Local<v8::Value>* argv) {\n#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n    EscapableHandleScope scope;\n    return scope.Escape(New(node::MakeCallback(\n        v8::Isolate::GetCurrent(), target, func, argc, argv)));\n#else\n# if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    AsyncResource res(\"nan:makeCallback\");\n    return res.runInAsyncScope(target, func, argc, argv)\n        .FromMaybe(v8::Local<v8::Value>());\n# else\n    return node::MakeCallback(\n        v8::Isolate::GetCurrent(), target, func, argc, argv);\n# endif  // NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n#endif  // NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n  }\n\n  NAN_DEPRECATED inline v8::Local<v8::Value> MakeCallback(\n      v8::Local<v8::Object> target\n    , v8::Local<v8::String> symbol\n    , int argc\n    , v8::Local<v8::Value>* argv) {\n#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n    EscapableHandleScope scope;\n    return scope.Escape(New(node::MakeCallback(\n        v8::Isolate::GetCurrent(), target, symbol, argc, argv)));\n#else\n# if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    AsyncResource res(\"nan:makeCallback\");\n    return res.runInAsyncScope(target, symbol, argc, argv)\n        .FromMaybe(v8::Local<v8::Value>());\n# else\n    return node::MakeCallback(\n        v8::Isolate::GetCurrent(), target, symbol, argc, argv);\n# endif  // NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n#endif  // NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n  }\n\n  NAN_DEPRECATED inline v8::Local<v8::Value> MakeCallback(\n      v8::Local<v8::Object> target\n    , const char* method\n    , int argc\n    , v8::Local<v8::Value>* argv) {\n#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n    EscapableHandleScope scope;\n    return scope.Escape(New(node::MakeCallback(\n        v8::Isolate::GetCurrent(), target, method, argc, argv)));\n#else\n# if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    AsyncResource res(\"nan:makeCallback\");\n    return res.runInAsyncScope(target, method, argc, argv)\n        .FromMaybe(v8::Local<v8::Value>());\n# else\n    return node::MakeCallback(\n        v8::Isolate::GetCurrent(), target, method, argc, argv);\n# endif  // NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n#endif  // NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n  }\n\n  inline void FatalException(const TryCatch& try_catch) {\n    node::FatalException(v8::Isolate::GetCurrent(), try_catch.try_catch_);\n  }\n\n  inline v8::Local<v8::Value> ErrnoException(\n          int errorno\n       ,  const char* syscall = NULL\n       ,  const char* message = NULL\n       ,  const char* path = NULL) {\n    return node::ErrnoException(v8::Isolate::GetCurrent(), errorno, syscall,\n            message, path);\n  }\n\n  NAN_DEPRECATED inline v8::Local<v8::Value> NanErrnoException(\n          int errorno\n       ,  const char* syscall = NULL\n       ,  const char* message = NULL\n       ,  const char* path = NULL) {\n    return ErrnoException(errorno, syscall, message, path);\n  }\n\n  template<typename T>\n  inline void SetIsolateData(\n      v8::Isolate *isolate\n    , T *data\n  ) {\n      isolate->SetData(0, data);\n  }\n\n  template<typename T>\n  inline T *GetIsolateData(\n      v8::Isolate *isolate\n  ) {\n      return static_cast<T*>(isolate->GetData(0));\n  }\n\nclass Utf8String {\n public:\n  inline explicit Utf8String(v8::Local<v8::Value> from) :\n      length_(0), str_(str_st_) {\n    HandleScope scope;\n    if (!from.IsEmpty()) {\n#if NODE_MAJOR_VERSION >= 10\n      v8::Local<v8::Context> context = GetCurrentContext();\n      v8::Local<v8::String> string =\n          from->ToString(context).FromMaybe(v8::Local<v8::String>());\n#else\n      v8::Local<v8::String> string = from->ToString();\n#endif\n      if (!string.IsEmpty()) {\n        size_t len = 3 * string->Length() + 1;\n        assert(len <= INT_MAX);\n        if (len > sizeof (str_st_)) {\n          str_ = static_cast<char*>(malloc(len));\n          assert(str_ != 0);\n        }\n        const int flags =\n            v8::String::NO_NULL_TERMINATION | imp::kReplaceInvalidUtf8;\n#if NODE_MAJOR_VERSION >= 11\n        length_ = string->WriteUtf8(v8::Isolate::GetCurrent(), str_,\n                                    static_cast<int>(len), 0, flags);\n#else\n        // See https://github.com/nodejs/nan/issues/832.\n        // Disable the warning as there is no way around it.\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4996)\n#endif\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n        length_ = string->WriteUtf8(str_, static_cast<int>(len), 0, flags);\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n#endif  // NODE_MAJOR_VERSION < 11\n        str_[length_] = '\\0';\n      }\n    }\n  }\n\n  inline int length() const {\n    return length_;\n  }\n\n  inline char* operator*() { return str_; }\n  inline const char* operator*() const { return str_; }\n\n  inline ~Utf8String() {\n    if (str_ != str_st_) {\n      free(str_);\n    }\n  }\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(Utf8String)\n\n  int length_;\n  char *str_;\n  char str_st_[1024];\n};\n\n#else  // Node 0.8 and 0.10\n  inline v8::Local<v8::Primitive> Undefined() {\n    EscapableHandleScope scope;\n    return scope.Escape(New(v8::Undefined()));\n  }\n\n  inline v8::Local<v8::Primitive> Null() {\n    EscapableHandleScope scope;\n    return scope.Escape(New(v8::Null()));\n  }\n\n  inline v8::Local<v8::Boolean> True() {\n    EscapableHandleScope scope;\n    return scope.Escape(New(v8::True()));\n  }\n\n  inline v8::Local<v8::Boolean> False() {\n    EscapableHandleScope scope;\n    return scope.Escape(New(v8::False()));\n  }\n\n  inline v8::Local<v8::String> EmptyString() {\n    return v8::String::Empty();\n  }\n\n  inline int AdjustExternalMemory(int bc) {\n    return static_cast<int>(v8::V8::AdjustAmountOfExternalAllocatedMemory(bc));\n  }\n\n  inline void SetTemplate(\n      v8::Local<v8::Template> templ\n    , const char *name\n    , v8::Local<v8::Data> value) {\n    templ->Set(name, value);\n  }\n\n  inline void SetTemplate(\n      v8::Local<v8::Template> templ\n    , v8::Local<v8::String> name\n    , v8::Local<v8::Data> value\n    , v8::PropertyAttribute attributes) {\n    templ->Set(name, value, attributes);\n  }\n\n  inline v8::Local<v8::Context> GetCurrentContext() {\n    return v8::Context::GetCurrent();\n  }\n\n  inline void* GetInternalFieldPointer(\n      v8::Local<v8::Object> object\n    , int index) {\n    return object->GetPointerFromInternalField(index);\n  }\n\n  inline void SetInternalFieldPointer(\n      v8::Local<v8::Object> object\n    , int index\n    , void* value) {\n    object->SetPointerInInternalField(index, value);\n  }\n\n# define NAN_GC_CALLBACK(name)                                                 \\\n    void name(v8::GCType type, v8::GCCallbackFlags flags)\n\n  inline void AddGCEpilogueCallback(\n    v8::GCEpilogueCallback callback\n  , v8::GCType gc_type_filter = v8::kGCTypeAll) {\n    v8::V8::AddGCEpilogueCallback(callback, gc_type_filter);\n  }\n  inline void RemoveGCEpilogueCallback(\n    v8::GCEpilogueCallback callback) {\n    v8::V8::RemoveGCEpilogueCallback(callback);\n  }\n  inline void AddGCPrologueCallback(\n    v8::GCPrologueCallback callback\n  , v8::GCType gc_type_filter = v8::kGCTypeAll) {\n    v8::V8::AddGCPrologueCallback(callback, gc_type_filter);\n  }\n  inline void RemoveGCPrologueCallback(\n    v8::GCPrologueCallback callback) {\n    v8::V8::RemoveGCPrologueCallback(callback);\n  }\n  inline void GetHeapStatistics(\n    v8::HeapStatistics *heap_statistics) {\n    v8::V8::GetHeapStatistics(heap_statistics);\n  }\n\n# define X(NAME)                                                               \\\n    inline v8::Local<v8::Value> NAME(const char *msg) {                        \\\n      EscapableHandleScope scope;                                              \\\n      return scope.Escape(v8::Exception::NAME(New(msg).ToLocalChecked()));     \\\n    }                                                                          \\\n                                                                               \\\n    inline                                                                     \\\n    v8::Local<v8::Value> NAME(v8::Local<v8::String> msg) {                     \\\n      return v8::Exception::NAME(msg);                                         \\\n    }                                                                          \\\n                                                                               \\\n    inline void Throw ## NAME(const char *msg) {                               \\\n      HandleScope scope;                                                       \\\n      v8::ThrowException(v8::Exception::NAME(New(msg).ToLocalChecked()));      \\\n    }                                                                          \\\n                                                                               \\\n    inline                                                                     \\\n    void Throw ## NAME(v8::Local<v8::String> errmsg) {                         \\\n      HandleScope scope;                                                       \\\n      v8::ThrowException(v8::Exception::NAME(errmsg));                         \\\n    }\n\n  X(Error)\n  X(RangeError)\n  X(ReferenceError)\n  X(SyntaxError)\n  X(TypeError)\n\n# undef X\n\n  inline void ThrowError(v8::Local<v8::Value> error) {\n    v8::ThrowException(error);\n  }\n\n  inline MaybeLocal<v8::Object> NewBuffer(\n      char *data\n    , size_t length\n    , node::Buffer::free_callback callback\n    , void *hint\n  ) {\n    EscapableHandleScope scope;\n    // arbitrary buffer lengths requires\n    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION\n    assert(length <= imp::kMaxLength && \"too large buffer\");\n    return scope.Escape(\n        New(node::Buffer::New(data, length, callback, hint)->handle_));\n  }\n\n  inline MaybeLocal<v8::Object> CopyBuffer(\n      const char *data\n    , uint32_t size\n  ) {\n    EscapableHandleScope scope;\n    // arbitrary buffer lengths requires\n    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION\n    assert(size <= imp::kMaxLength && \"too large buffer\");\n#if NODE_MODULE_VERSION >= NODE_0_10_MODULE_VERSION\n    return scope.Escape(New(node::Buffer::New(data, size)->handle_));\n#else\n    return scope.Escape(\n        New(node::Buffer::New(const_cast<char *>(data), size)->handle_));\n#endif\n  }\n\n  inline MaybeLocal<v8::Object> NewBuffer(uint32_t size) {\n    // arbitrary buffer lengths requires\n    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION\n    EscapableHandleScope scope;\n    assert(size <= imp::kMaxLength && \"too large buffer\");\n    return scope.Escape(New(node::Buffer::New(size)->handle_));\n  }\n\n  inline void FreeData(char *data, void *hint) {\n    (void) hint;  // unused\n    delete[] data;\n  }\n\n  inline MaybeLocal<v8::Object> NewBuffer(\n      char* data\n    , uint32_t size\n  ) {\n    EscapableHandleScope scope;\n    // arbitrary buffer lengths requires\n    // NODE_MODULE_VERSION >= IOJS_3_0_MODULE_VERSION\n    assert(size <= imp::kMaxLength && \"too large buffer\");\n    return scope.Escape(\n        New(node::Buffer::New(data, size, FreeData, NULL)->handle_));\n  }\n\nnamespace imp {\ninline void\nwidenString(std::vector<uint16_t> *ws, const uint8_t *s, int l) {\n  size_t len = static_cast<size_t>(l);\n  if (l < 0) {\n    len = strlen(reinterpret_cast<const char*>(s));\n  }\n  assert(len <= INT_MAX && \"string too long\");\n  ws->resize(len);\n  std::copy(s, s + len, ws->begin());  // NOLINT(build/include_what_you_use)\n}\n}  // end of namespace imp\n\n  inline MaybeLocal<v8::String>\n  NewOneByteString(const uint8_t * value, int length = -1) {\n    std::vector<uint16_t> wideString;  // NOLINT(build/include_what_you_use)\n    imp::widenString(&wideString, value, length);\n    return v8::String::New(wideString.data(),\n                           static_cast<int>(wideString.size()));\n  }\n\n  inline MaybeLocal<BoundScript> CompileScript(\n      v8::Local<v8::String> s\n    , const v8::ScriptOrigin& origin\n  ) {\n    return v8::Script::Compile(s, const_cast<v8::ScriptOrigin *>(&origin));\n  }\n\n  inline MaybeLocal<BoundScript> CompileScript(\n    v8::Local<v8::String> s\n  ) {\n    return v8::Script::Compile(s);\n  }\n\n  inline\n  MaybeLocal<v8::Value> RunScript(v8::Local<v8::Script> script) {\n    return script->Run();\n  }\n\n  inline v8::Local<v8::Value> MakeCallback(\n      v8::Local<v8::Object> target\n    , v8::Local<v8::Function> func\n    , int argc\n    , v8::Local<v8::Value>* argv) {\n    v8::HandleScope scope;\n    return scope.Close(New(node::MakeCallback(target, func, argc, argv)));\n  }\n\n  inline v8::Local<v8::Value> MakeCallback(\n      v8::Local<v8::Object> target\n    , v8::Local<v8::String> symbol\n    , int argc\n    , v8::Local<v8::Value>* argv) {\n    v8::HandleScope scope;\n    return scope.Close(New(node::MakeCallback(target, symbol, argc, argv)));\n  }\n\n  inline v8::Local<v8::Value> MakeCallback(\n      v8::Local<v8::Object> target\n    , const char* method\n    , int argc\n    , v8::Local<v8::Value>* argv) {\n    v8::HandleScope scope;\n    return scope.Close(New(node::MakeCallback(target, method, argc, argv)));\n  }\n\n  inline void FatalException(const TryCatch& try_catch) {\n    node::FatalException(const_cast<v8::TryCatch &>(try_catch.try_catch_));\n  }\n\n  inline v8::Local<v8::Value> ErrnoException(\n          int errorno\n       ,  const char* syscall = NULL\n       ,  const char* message = NULL\n       ,  const char* path = NULL) {\n    return node::ErrnoException(errorno, syscall, message, path);\n  }\n\n  NAN_DEPRECATED inline v8::Local<v8::Value> NanErrnoException(\n          int errorno\n       ,  const char* syscall = NULL\n       ,  const char* message = NULL\n       ,  const char* path = NULL) {\n    return ErrnoException(errorno, syscall, message, path);\n  }\n\n\n  template<typename T>\n  inline void SetIsolateData(\n      v8::Isolate *isolate\n    , T *data\n  ) {\n      isolate->SetData(data);\n  }\n\n  template<typename T>\n  inline T *GetIsolateData(\n      v8::Isolate *isolate\n  ) {\n      return static_cast<T*>(isolate->GetData());\n  }\n\nclass Utf8String {\n public:\n  inline explicit Utf8String(v8::Local<v8::Value> from) :\n      length_(0), str_(str_st_) {\n    v8::HandleScope scope;\n    if (!from.IsEmpty()) {\n      v8::Local<v8::String> string = from->ToString();\n      if (!string.IsEmpty()) {\n        size_t len = 3 * string->Length() + 1;\n        assert(len <= INT_MAX);\n        if (len > sizeof (str_st_)) {\n          str_ = static_cast<char*>(malloc(len));\n          assert(str_ != 0);\n        }\n        const int flags =\n            v8::String::NO_NULL_TERMINATION | imp::kReplaceInvalidUtf8;\n        length_ = string->WriteUtf8(str_, static_cast<int>(len), 0, flags);\n        str_[length_] = '\\0';\n      }\n    }\n  }\n\n  inline int length() const {\n    return length_;\n  }\n\n  inline char* operator*() { return str_; }\n  inline const char* operator*() const { return str_; }\n\n  inline ~Utf8String() {\n    if (str_ != str_st_) {\n      free(str_);\n    }\n  }\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(Utf8String)\n\n  int length_;\n  char *str_;\n  char str_st_[1024];\n};\n\n#endif  // NODE_MODULE_VERSION\n\ntypedef void (*FreeCallback)(char *data, void *hint);\n\ntypedef const FunctionCallbackInfo<v8::Value>& NAN_METHOD_ARGS_TYPE;\ntypedef void NAN_METHOD_RETURN_TYPE;\n\ntypedef const PropertyCallbackInfo<v8::Value>& NAN_GETTER_ARGS_TYPE;\ntypedef void NAN_GETTER_RETURN_TYPE;\n\ntypedef const PropertyCallbackInfo<void>& NAN_SETTER_ARGS_TYPE;\ntypedef void NAN_SETTER_RETURN_TYPE;\n\ntypedef const PropertyCallbackInfo<v8::Value>&\n    NAN_PROPERTY_GETTER_ARGS_TYPE;\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\ntypedef v8::Intercepted NAN_PROPERTY_GETTER_RETURN_TYPE;\n#else\ntypedef void NAN_PROPERTY_GETTER_RETURN_TYPE;\n#endif\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\ntypedef const PropertyCallbackInfo<void>&\n    NAN_PROPERTY_SETTER_ARGS_TYPE;\ntypedef v8::Intercepted NAN_PROPERTY_SETTER_RETURN_TYPE;\n#else\ntypedef const PropertyCallbackInfo<v8::Value>&\n    NAN_PROPERTY_SETTER_ARGS_TYPE;\ntypedef void NAN_PROPERTY_SETTER_RETURN_TYPE;\n#endif\n\ntypedef const PropertyCallbackInfo<v8::Array>&\n    NAN_PROPERTY_ENUMERATOR_ARGS_TYPE;\ntypedef void NAN_PROPERTY_ENUMERATOR_RETURN_TYPE;\n\ntypedef const PropertyCallbackInfo<v8::Boolean>&\n    NAN_PROPERTY_DELETER_ARGS_TYPE;\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\ntypedef v8::Intercepted NAN_PROPERTY_DELETER_RETURN_TYPE;\n#else\ntypedef void NAN_PROPERTY_DELETER_RETURN_TYPE;\n#endif\n\n\ntypedef const PropertyCallbackInfo<v8::Integer>&\n    NAN_PROPERTY_QUERY_ARGS_TYPE;\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\ntypedef v8::Intercepted NAN_PROPERTY_QUERY_RETURN_TYPE;\n#else\ntypedef void NAN_PROPERTY_QUERY_RETURN_TYPE;\n#endif\n\ntypedef const PropertyCallbackInfo<v8::Value>& NAN_INDEX_GETTER_ARGS_TYPE;\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\ntypedef v8::Intercepted NAN_INDEX_GETTER_RETURN_TYPE;\n#else\ntypedef void NAN_INDEX_GETTER_RETURN_TYPE;\n#endif\n\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\ntypedef const PropertyCallbackInfo<void>& NAN_INDEX_SETTER_ARGS_TYPE;\ntypedef v8::Intercepted NAN_INDEX_SETTER_RETURN_TYPE;\n#else\ntypedef const PropertyCallbackInfo<v8::Value>& NAN_INDEX_SETTER_ARGS_TYPE;\ntypedef void NAN_INDEX_SETTER_RETURN_TYPE;\n#endif\n\ntypedef const PropertyCallbackInfo<v8::Array>&\n    NAN_INDEX_ENUMERATOR_ARGS_TYPE;\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\ntypedef v8::Intercepted NAN_INDEX_ENUMERATOR_RETURN_TYPE;\n#else\ntypedef void NAN_INDEX_ENUMERATOR_RETURN_TYPE;\n#endif\n\ntypedef const PropertyCallbackInfo<v8::Boolean>&\n    NAN_INDEX_DELETER_ARGS_TYPE;\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\ntypedef v8::Intercepted NAN_INDEX_DELETER_RETURN_TYPE;\n#else\ntypedef void NAN_INDEX_DELETER_RETURN_TYPE;\n#endif\n\ntypedef const PropertyCallbackInfo<v8::Integer>&\n    NAN_INDEX_QUERY_ARGS_TYPE;\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\ntypedef v8::Intercepted NAN_INDEX_QUERY_RETURN_TYPE;\n#else\ntypedef void NAN_INDEX_QUERY_RETURN_TYPE;\n#endif\n\n#define NAN_METHOD(name)                                                       \\\n    Nan::NAN_METHOD_RETURN_TYPE name(Nan::NAN_METHOD_ARGS_TYPE info)\n#define NAN_GETTER(name)                                                       \\\n    Nan::NAN_GETTER_RETURN_TYPE name(                                          \\\n        v8::Local<v8::String> property                                         \\\n      , Nan::NAN_GETTER_ARGS_TYPE info)\n#define NAN_SETTER(name)                                                       \\\n    Nan::NAN_SETTER_RETURN_TYPE name(                                          \\\n        v8::Local<v8::String> property                                         \\\n      , v8::Local<v8::Value> value                                             \\\n      , Nan::NAN_SETTER_ARGS_TYPE info)\n#define NAN_PROPERTY_GETTER(name)                                              \\\n    Nan::NAN_PROPERTY_GETTER_RETURN_TYPE name(                                 \\\n        v8::Local<v8::String> property                                         \\\n      , Nan::NAN_PROPERTY_GETTER_ARGS_TYPE info)\n#define NAN_PROPERTY_SETTER(name)                                              \\\n    Nan::NAN_PROPERTY_SETTER_RETURN_TYPE name(                                 \\\n        v8::Local<v8::String> property                                         \\\n      , v8::Local<v8::Value> value                                             \\\n      , Nan::NAN_PROPERTY_SETTER_ARGS_TYPE info)\n#define NAN_PROPERTY_ENUMERATOR(name)                                          \\\n    Nan::NAN_PROPERTY_ENUMERATOR_RETURN_TYPE name(                             \\\n        Nan::NAN_PROPERTY_ENUMERATOR_ARGS_TYPE info)\n#define NAN_PROPERTY_DELETER(name)                                             \\\n    Nan::NAN_PROPERTY_DELETER_RETURN_TYPE name(                                \\\n        v8::Local<v8::String> property                                         \\\n      , Nan::NAN_PROPERTY_DELETER_ARGS_TYPE info)\n#define NAN_PROPERTY_QUERY(name)                                               \\\n    Nan::NAN_PROPERTY_QUERY_RETURN_TYPE name(                                  \\\n        v8::Local<v8::String> property                                         \\\n      , Nan::NAN_PROPERTY_QUERY_ARGS_TYPE info)\n# define NAN_INDEX_GETTER(name)                                                \\\n    Nan::NAN_INDEX_GETTER_RETURN_TYPE name(                                    \\\n        uint32_t index                                                         \\\n      , Nan::NAN_INDEX_GETTER_ARGS_TYPE info)\n#define NAN_INDEX_SETTER(name)                                                 \\\n    Nan::NAN_INDEX_SETTER_RETURN_TYPE name(                                    \\\n        uint32_t index                                                         \\\n      , v8::Local<v8::Value> value                                             \\\n      , Nan::NAN_INDEX_SETTER_ARGS_TYPE info)\n#define NAN_INDEX_ENUMERATOR(name)                                             \\\n    Nan::NAN_INDEX_ENUMERATOR_RETURN_TYPE                                      \\\n    name(Nan::NAN_INDEX_ENUMERATOR_ARGS_TYPE info)\n#define NAN_INDEX_DELETER(name)                                                \\\n    Nan::NAN_INDEX_DELETER_RETURN_TYPE name(                                   \\\n        uint32_t index                                                         \\\n      , Nan::NAN_INDEX_DELETER_ARGS_TYPE info)\n#define NAN_INDEX_QUERY(name)                                                  \\\n    Nan::NAN_INDEX_QUERY_RETURN_TYPE name(                                     \\\n        uint32_t index                                                         \\\n      , Nan::NAN_INDEX_QUERY_ARGS_TYPE info)\n\nclass Callback {\n public:\n  Callback() {}\n\n  explicit Callback(const v8::Local<v8::Function> &fn) : handle_(fn) {}\n\n  ~Callback() {\n    handle_.Reset();\n  }\n\n  bool operator==(const Callback &other) const {\n    return handle_ == other.handle_;\n  }\n\n  bool operator!=(const Callback &other) const {\n    return !operator==(other);\n  }\n\n  inline\n  v8::Local<v8::Function> operator*() const { return GetFunction(); }\n\n  NAN_DEPRECATED inline v8::Local<v8::Value> operator()(\n      v8::Local<v8::Object> target\n    , int argc = 0\n    , v8::Local<v8::Value> argv[] = 0) const {\n#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n    v8::Isolate *isolate = v8::Isolate::GetCurrent();\n# if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    AsyncResource async(\"nan:Callback:operator()\");\n    return Call_(isolate, target, argc, argv, &async)\n        .FromMaybe(v8::Local<v8::Value>());\n# else\n    return Call_(isolate, target, argc, argv);\n# endif  // NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n#else\n    return Call_(target, argc, argv);\n#endif  //  NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n  }\n\n  NAN_DEPRECATED inline v8::Local<v8::Value> operator()(\n      int argc = 0\n    , v8::Local<v8::Value> argv[] = 0) const {\n#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n    v8::Isolate *isolate = v8::Isolate::GetCurrent();\n    v8::EscapableHandleScope scope(isolate);\n# if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    AsyncResource async(\"nan:Callback:operator()\");\n    return scope.Escape(Call_(isolate, isolate->GetCurrentContext()->Global(),\n                              argc, argv, &async)\n                            .FromMaybe(v8::Local<v8::Value>()));\n# else\n    return scope.Escape(\n        Call_(isolate, isolate->GetCurrentContext()->Global(), argc, argv));\n# endif  // NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n#else\n    v8::HandleScope scope;\n    return scope.Close(Call_(v8::Context::GetCurrent()->Global(), argc, argv));\n#endif  //  NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n  }\n\n  inline MaybeLocal<v8::Value> operator()(\n      AsyncResource* resource\n    , int argc = 0\n    , v8::Local<v8::Value> argv[] = 0) const {\n    return this->Call(argc, argv, resource);\n  }\n\n  inline MaybeLocal<v8::Value> operator()(\n      AsyncResource* resource\n    , v8::Local<v8::Object> target\n    , int argc = 0\n    , v8::Local<v8::Value> argv[] = 0) const {\n    return this->Call(target, argc, argv, resource);\n  }\n\n  // TODO(kkoopa): remove\n  inline void SetFunction(const v8::Local<v8::Function> &fn) {\n    Reset(fn);\n  }\n\n  inline void Reset(const v8::Local<v8::Function> &fn) {\n    handle_.Reset(fn);\n  }\n\n  inline void Reset() {\n    handle_.Reset();\n  }\n\n  inline v8::Local<v8::Function> GetFunction() const {\n    return New(handle_);\n  }\n\n  inline bool IsEmpty() const {\n    return handle_.IsEmpty();\n  }\n\n  // Deprecated: For async callbacks Use the versions that accept an\n  // AsyncResource. If this callback does not correspond to an async resource,\n  // that is, it is a synchronous function call on a non-empty JS stack, you\n  // should Nan::Call instead.\n  NAN_DEPRECATED inline v8::Local<v8::Value>\n  Call(v8::Local<v8::Object> target\n     , int argc\n     , v8::Local<v8::Value> argv[]) const {\n#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n    v8::Isolate *isolate = v8::Isolate::GetCurrent();\n# if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    AsyncResource async(\"nan:Callback:Call\");\n    return Call_(isolate, target, argc, argv, &async)\n        .FromMaybe(v8::Local<v8::Value>());\n# else\n    return Call_(isolate, target, argc, argv);\n# endif  // NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n#else\n    return Call_(target, argc, argv);\n#endif\n  }\n\n  // Deprecated: For async callbacks Use the versions that accept an\n  // AsyncResource. If this callback does not correspond to an async resource,\n  // that is, it is a synchronous function call on a non-empty JS stack, you\n  // should Nan::Call instead.\n  NAN_DEPRECATED inline v8::Local<v8::Value>\n  Call(int argc, v8::Local<v8::Value> argv[]) const {\n#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n    v8::Isolate *isolate = v8::Isolate::GetCurrent();\n    v8::EscapableHandleScope scope(isolate);\n# if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    AsyncResource async(\"nan:Callback:Call\");\n    return scope.Escape(Call_(isolate, isolate->GetCurrentContext()->Global(),\n                              argc, argv, &async)\n                            .FromMaybe(v8::Local<v8::Value>()));\n# else\n    return scope.Escape(\n        Call_(isolate, isolate->GetCurrentContext()->Global(), argc, argv));\n# endif  // NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n#else\n    v8::HandleScope scope;\n    return scope.Close(Call_(v8::Context::GetCurrent()->Global(), argc, argv));\n#endif\n  }\n\n  inline MaybeLocal<v8::Value>\n  Call(v8::Local<v8::Object> target\n     , int argc\n     , v8::Local<v8::Value> argv[]\n     , AsyncResource* resource) const {\n#if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n    return Call_(isolate, target, argc, argv, resource);\n#elif NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n    v8::Isolate *isolate = v8::Isolate::GetCurrent();\n    return Call_(isolate, target, argc, argv);\n#else\n    return Call_(target, argc, argv);\n#endif\n  }\n\n  inline MaybeLocal<v8::Value>\n  Call(int argc, v8::Local<v8::Value> argv[], AsyncResource* resource) const {\n#if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n    return Call(isolate->GetCurrentContext()->Global(), argc, argv, resource);\n#elif NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n    v8::Isolate *isolate = v8::Isolate::GetCurrent();\n    v8::EscapableHandleScope scope(isolate);\n    return scope.Escape(\n        Call_(isolate, isolate->GetCurrentContext()->Global(), argc, argv));\n#else\n    v8::HandleScope scope;\n    return scope.Close(Call_(v8::Context::GetCurrent()->Global(), argc, argv));\n#endif\n  }\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(Callback)\n  Persistent<v8::Function> handle_;\n\n#if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n  MaybeLocal<v8::Value> Call_(v8::Isolate *isolate\n                            , v8::Local<v8::Object> target\n                            , int argc\n                            , v8::Local<v8::Value> argv[]\n                            , AsyncResource* resource) const {\n    EscapableHandleScope scope;\n    v8::Local<v8::Function> func = New(handle_);\n    auto maybe = resource->runInAsyncScope(target, func, argc, argv);\n    v8::Local<v8::Value> local;\n    if (!maybe.ToLocal(&local)) return MaybeLocal<v8::Value>();\n    return scope.Escape(local);\n  }\n#elif NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n  v8::Local<v8::Value> Call_(v8::Isolate *isolate\n                           , v8::Local<v8::Object> target\n                           , int argc\n                           , v8::Local<v8::Value> argv[]) const {\n    EscapableHandleScope scope;\n\n    v8::Local<v8::Function> callback = New(handle_);\n# if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\n    return scope.Escape(New(node::MakeCallback(\n        isolate\n      , target\n      , callback\n      , argc\n      , argv\n    )));\n# else\n    return scope.Escape(node::MakeCallback(\n        isolate\n      , target\n      , callback\n      , argc\n      , argv\n    ));\n# endif\n  }\n#else\n  v8::Local<v8::Value> Call_(v8::Local<v8::Object> target\n                           , int argc\n                           , v8::Local<v8::Value> argv[]) const {\n    EscapableHandleScope scope;\n\n    v8::Local<v8::Function> callback = New(handle_);\n    return scope.Escape(New(node::MakeCallback(\n        target\n      , callback\n      , argc\n      , argv\n    )));\n  }\n#endif\n};\n\ninline MaybeLocal<v8::Value> Call(\n    const Nan::Callback& callback\n  , v8::Local<v8::Object> recv\n  , int argc\n  , v8::Local<v8::Value> argv[]) {\n  return Call(*callback, recv, argc, argv);\n}\n\ninline MaybeLocal<v8::Value> Call(\n    const Nan::Callback& callback\n  , int argc\n  , v8::Local<v8::Value> argv[]) {\n#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(\n      Call(*callback, isolate->GetCurrentContext()->Global(), argc, argv)\n          .FromMaybe(v8::Local<v8::Value>()));\n#else\n  EscapableHandleScope scope;\n  return scope.Escape(\n      Call(*callback, v8::Context::GetCurrent()->Global(), argc, argv)\n          .FromMaybe(v8::Local<v8::Value>()));\n#endif\n}\n\ninline MaybeLocal<v8::Value> Call(\n    v8::Local<v8::String> symbol\n  , v8::Local<v8::Object> recv\n  , int argc\n  , v8::Local<v8::Value> argv[]) {\n  EscapableHandleScope scope;\n  v8::Local<v8::Value> fn_v =\n      Get(recv, symbol).FromMaybe(v8::Local<v8::Value>());\n  if (fn_v.IsEmpty() || !fn_v->IsFunction()) return v8::Local<v8::Value>();\n  v8::Local<v8::Function> fn = fn_v.As<v8::Function>();\n  return scope.Escape(\n      Call(fn, recv, argc, argv).FromMaybe(v8::Local<v8::Value>()));\n}\n\ninline MaybeLocal<v8::Value> Call(\n    const char* method\n  , v8::Local<v8::Object> recv\n  , int argc\n  , v8::Local<v8::Value> argv[]) {\n  EscapableHandleScope scope;\n  v8::Local<v8::String> method_string =\n      New<v8::String>(method).ToLocalChecked();\n  return scope.Escape(\n      Call(method_string, recv, argc, argv).FromMaybe(v8::Local<v8::Value>()));\n}\n\n/* abstract */ class AsyncWorker {\n public:\n  explicit AsyncWorker(Callback *callback_,\n                       const char* resource_name = \"nan:AsyncWorker\")\n      : callback(callback_), errmsg_(NULL) {\n    request.data = this;\n\n    HandleScope scope;\n    v8::Local<v8::Object> obj = New<v8::Object>();\n    persistentHandle.Reset(obj);\n    async_resource = new AsyncResource(resource_name, obj);\n  }\n\n  virtual ~AsyncWorker() {\n    HandleScope scope;\n\n    if (!persistentHandle.IsEmpty())\n      persistentHandle.Reset();\n    delete callback;\n    delete[] errmsg_;\n    delete async_resource;\n  }\n\n  virtual void WorkComplete() {\n    HandleScope scope;\n\n    if (errmsg_ == NULL)\n      HandleOKCallback();\n    else\n      HandleErrorCallback();\n    delete callback;\n    callback = NULL;\n  }\n\n  inline void SaveToPersistent(\n      const char *key, const v8::Local<v8::Value> &value) {\n    HandleScope scope;\n    Set(New(persistentHandle), New(key).ToLocalChecked(), value).FromJust();\n  }\n\n  inline void SaveToPersistent(\n      const v8::Local<v8::String> &key, const v8::Local<v8::Value> &value) {\n    HandleScope scope;\n    Set(New(persistentHandle), key, value).FromJust();\n  }\n\n  inline void SaveToPersistent(\n      uint32_t index, const v8::Local<v8::Value> &value) {\n    HandleScope scope;\n    Set(New(persistentHandle), index, value).FromJust();\n  }\n\n  inline v8::Local<v8::Value> GetFromPersistent(const char *key) const {\n    EscapableHandleScope scope;\n    return scope.Escape(\n        Get(New(persistentHandle), New(key).ToLocalChecked())\n        .FromMaybe(v8::Local<v8::Value>()));\n  }\n\n  inline v8::Local<v8::Value>\n  GetFromPersistent(const v8::Local<v8::String> &key) const {\n    EscapableHandleScope scope;\n    return scope.Escape(\n        Get(New(persistentHandle), key)\n        .FromMaybe(v8::Local<v8::Value>()));\n  }\n\n  inline v8::Local<v8::Value> GetFromPersistent(uint32_t index) const {\n    EscapableHandleScope scope;\n    return scope.Escape(\n        Get(New(persistentHandle), index)\n        .FromMaybe(v8::Local<v8::Value>()));\n  }\n\n  virtual void Execute() = 0;\n\n  uv_work_t request;\n\n  virtual void Destroy() {\n      delete this;\n  }\n\n protected:\n  Persistent<v8::Object> persistentHandle;\n  Callback *callback;\n  AsyncResource *async_resource;\n\n  virtual void HandleOKCallback() {\n    HandleScope scope;\n\n    callback->Call(0, NULL, async_resource);\n  }\n\n  virtual void HandleErrorCallback() {\n    HandleScope scope;\n\n    v8::Local<v8::Value> argv[] = {\n      v8::Exception::Error(New<v8::String>(ErrorMessage()).ToLocalChecked())\n    };\n    callback->Call(1, argv, async_resource);\n  }\n\n  void SetErrorMessage(const char *msg) {\n    delete[] errmsg_;\n\n    size_t size = strlen(msg) + 1;\n    errmsg_ = new char[size];\n    memcpy(errmsg_, msg, size);\n  }\n\n  const char* ErrorMessage() const {\n    return errmsg_;\n  }\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(AsyncWorker)\n  char *errmsg_;\n};\n\n/* abstract */ class AsyncBareProgressWorkerBase : public AsyncWorker {\n public:\n  explicit AsyncBareProgressWorkerBase(\n      Callback *callback_,\n      const char* resource_name = \"nan:AsyncBareProgressWorkerBase\")\n      : AsyncWorker(callback_, resource_name) {\n    uv_async_init(\n        GetCurrentEventLoop()\n      , &async\n      , AsyncProgress_\n    );\n    async.data = this;\n  }\n\n  virtual ~AsyncBareProgressWorkerBase() {\n  }\n\n  virtual void WorkProgress() = 0;\n\n  virtual void Destroy() {\n      uv_close(reinterpret_cast<uv_handle_t*>(&async), AsyncClose_);\n  }\n\n private:\n  inline static NAUV_WORK_CB(AsyncProgress_) {\n    AsyncBareProgressWorkerBase *worker =\n            static_cast<AsyncBareProgressWorkerBase*>(async->data);\n    worker->WorkProgress();\n  }\n\n  inline static void AsyncClose_(uv_handle_t* handle) {\n    AsyncBareProgressWorkerBase *worker =\n            static_cast<AsyncBareProgressWorkerBase*>(handle->data);\n    delete worker;\n  }\n\n protected:\n  uv_async_t async;\n};\n\ntemplate<class T>\n/* abstract */\nclass AsyncBareProgressWorker : public AsyncBareProgressWorkerBase {\n public:\n  explicit AsyncBareProgressWorker(\n      Callback *callback_,\n      const char* resource_name = \"nan:AsyncBareProgressWorker\")\n      : AsyncBareProgressWorkerBase(callback_, resource_name) {\n    uv_mutex_init(&async_lock);\n  }\n\n  virtual ~AsyncBareProgressWorker() {\n    uv_mutex_destroy(&async_lock);\n  }\n\n  class ExecutionProgress {\n    friend class AsyncBareProgressWorker;\n   public:\n    void Signal() const {\n      uv_mutex_lock(&that_->async_lock);\n      uv_async_send(&that_->async);\n      uv_mutex_unlock(&that_->async_lock);\n    }\n\n    void Send(const T* data, size_t count) const {\n      that_->SendProgress_(data, count);\n    }\n\n   private:\n    explicit ExecutionProgress(AsyncBareProgressWorker *that) : that_(that) {}\n    NAN_DISALLOW_ASSIGN_COPY_MOVE(ExecutionProgress)\n    AsyncBareProgressWorker* const that_;\n  };\n\n  virtual void Execute(const ExecutionProgress& progress) = 0;\n  virtual void HandleProgressCallback(const T *data, size_t size) = 0;\n\n protected:\n  uv_mutex_t async_lock;\n\n private:\n  void Execute() /*final override*/ {\n    ExecutionProgress progress(this);\n    Execute(progress);\n  }\n\n  virtual void SendProgress_(const T *data, size_t count) = 0;\n};\n\ntemplate<class T>\n/* abstract */\nclass AsyncProgressWorkerBase : public AsyncBareProgressWorker<T> {\n public:\n  explicit AsyncProgressWorkerBase(\n      Callback *callback_,\n      const char* resource_name = \"nan:AsyncProgressWorkerBase\")\n      : AsyncBareProgressWorker<T>(callback_, resource_name), asyncdata_(NULL),\n        asyncsize_(0) {\n  }\n\n  virtual ~AsyncProgressWorkerBase() {\n    delete[] asyncdata_;\n  }\n\n  void WorkProgress() {\n    uv_mutex_lock(&this->async_lock);\n    T *data = asyncdata_;\n    size_t size = asyncsize_;\n    asyncdata_ = NULL;\n    asyncsize_ = 0;\n    uv_mutex_unlock(&this->async_lock);\n\n    // Don't send progress events after we've already completed.\n    if (this->callback) {\n        this->HandleProgressCallback(data, size);\n    }\n    delete[] data;\n  }\n\n private:\n  void SendProgress_(const T *data, size_t count) {\n    T *new_data = new T[count];\n    std::copy(data, data + count, new_data);\n\n    uv_mutex_lock(&this->async_lock);\n    T *old_data = asyncdata_;\n    asyncdata_ = new_data;\n    asyncsize_ = count;\n    uv_async_send(&this->async);\n    uv_mutex_unlock(&this->async_lock);\n\n    delete[] old_data;\n  }\n\n  T *asyncdata_;\n  size_t asyncsize_;\n};\n\n// This ensures compatibility to the previous un-templated AsyncProgressWorker\n// class definition.\ntypedef AsyncProgressWorkerBase<char> AsyncProgressWorker;\n\ntemplate<class T>\n/* abstract */\nclass AsyncBareProgressQueueWorker : public AsyncBareProgressWorkerBase {\n public:\n  explicit AsyncBareProgressQueueWorker(\n      Callback *callback_,\n      const char* resource_name = \"nan:AsyncBareProgressQueueWorker\")\n      : AsyncBareProgressWorkerBase(callback_, resource_name) {\n  }\n\n  virtual ~AsyncBareProgressQueueWorker() {\n  }\n\n  class ExecutionProgress {\n    friend class AsyncBareProgressQueueWorker;\n   public:\n    void Send(const T* data, size_t count) const {\n      that_->SendProgress_(data, count);\n    }\n\n   private:\n    explicit ExecutionProgress(AsyncBareProgressQueueWorker *that)\n        : that_(that) {}\n    NAN_DISALLOW_ASSIGN_COPY_MOVE(ExecutionProgress)\n    AsyncBareProgressQueueWorker* const that_;\n  };\n\n  virtual void Execute(const ExecutionProgress& progress) = 0;\n  virtual void HandleProgressCallback(const T *data, size_t size) = 0;\n\n private:\n  void Execute() /*final override*/ {\n    ExecutionProgress progress(this);\n    Execute(progress);\n  }\n\n  virtual void SendProgress_(const T *data, size_t count) = 0;\n};\n\ntemplate<class T>\n/* abstract */\nclass AsyncProgressQueueWorker : public AsyncBareProgressQueueWorker<T> {\n public:\n  explicit AsyncProgressQueueWorker(\n      Callback *callback_,\n      const char* resource_name = \"nan:AsyncProgressQueueWorker\")\n      : AsyncBareProgressQueueWorker<T>(callback_) {\n    uv_mutex_init(&async_lock);\n  }\n\n  virtual ~AsyncProgressQueueWorker() {\n    uv_mutex_lock(&async_lock);\n\n    while (!asyncdata_.empty()) {\n      std::pair<T*, size_t> &datapair = asyncdata_.front();\n      T *data = datapair.first;\n\n      asyncdata_.pop();\n\n      delete[] data;\n    }\n\n    uv_mutex_unlock(&async_lock);\n    uv_mutex_destroy(&async_lock);\n  }\n\n  void WorkComplete() {\n    WorkProgress();\n    AsyncWorker::WorkComplete();\n  }\n\n  void WorkProgress() {\n    uv_mutex_lock(&async_lock);\n\n    while (!asyncdata_.empty()) {\n      std::pair<T*, size_t> &datapair = asyncdata_.front();\n\n      T *data = datapair.first;\n      size_t size = datapair.second;\n\n      asyncdata_.pop();\n      uv_mutex_unlock(&async_lock);\n\n      // Don't send progress events after we've already completed.\n      if (this->callback) {\n          this->HandleProgressCallback(data, size);\n      }\n\n      delete[] data;\n\n      uv_mutex_lock(&async_lock);\n    }\n\n    uv_mutex_unlock(&async_lock);\n  }\n\n private:\n  void SendProgress_(const T *data, size_t count) {\n    T *new_data = new T[count];\n    std::copy(data, data + count, new_data);\n\n    uv_mutex_lock(&async_lock);\n    asyncdata_.push(std::pair<T*, size_t>(new_data, count));\n    uv_mutex_unlock(&async_lock);\n\n    uv_async_send(&this->async);\n  }\n\n  uv_mutex_t async_lock;\n  std::queue<std::pair<T*, size_t> > asyncdata_;\n};\n\ninline void AsyncExecute (uv_work_t* req) {\n  AsyncWorker *worker = static_cast<AsyncWorker*>(req->data);\n  worker->Execute();\n}\n\n/* uv_after_work_cb has 1 argument before node-v0.9.4 and\n * 2 arguments since node-v0.9.4\n * https://github.com/libuv/libuv/commit/92fb84b751e18f032c02609467f44bfe927b80c5\n */\ninline void AsyncExecuteComplete(uv_work_t *req) {\n  AsyncWorker* worker = static_cast<AsyncWorker*>(req->data);\n  worker->WorkComplete();\n  worker->Destroy();\n}\ninline void AsyncExecuteComplete (uv_work_t* req, int status) {\n  AsyncExecuteComplete(req);\n}\n\ninline void AsyncQueueWorker (AsyncWorker* worker) {\n  uv_queue_work(\n      GetCurrentEventLoop()\n    , &worker->request\n    , AsyncExecute\n    , AsyncExecuteComplete\n  );\n}\n\nnamespace imp {\n\ninline\nExternalOneByteStringResource const*\nGetExternalResource(v8::Local<v8::String> str) {\n#if NODE_MODULE_VERSION < ATOM_0_21_MODULE_VERSION\n    return str->GetExternalAsciiStringResource();\n#else\n    return str->GetExternalOneByteStringResource();\n#endif\n}\n\ninline\nbool\nIsExternal(v8::Local<v8::String> str) {\n#if NODE_MODULE_VERSION < ATOM_0_21_MODULE_VERSION\n    return str->IsExternalAscii();\n#else\n    return str->IsExternalOneByte();\n#endif\n}\n\n}  // end of namespace imp\n\nenum Encoding {ASCII, UTF8, BASE64, UCS2, BINARY, HEX, BUFFER};\n\n#if NODE_MODULE_VERSION < NODE_0_10_MODULE_VERSION\n# include \"nan_string_bytes.h\"  // NOLINT(build/include)\n#endif\n\ninline v8::Local<v8::Value> Encode(\n    const void *buf, size_t len, enum Encoding encoding = BINARY) {\n#if (NODE_MODULE_VERSION >= ATOM_0_21_MODULE_VERSION)\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  node::encoding node_enc = static_cast<node::encoding>(encoding);\n\n  if (encoding == UCS2) {\n    return node::Encode(\n        isolate\n      , reinterpret_cast<const uint16_t *>(buf)\n      , len / 2);\n  } else {\n    return node::Encode(\n        isolate\n      , reinterpret_cast<const char *>(buf)\n      , len\n      , node_enc);\n  }\n#elif (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)\n  return node::Encode(\n      v8::Isolate::GetCurrent()\n    , buf, len\n    , static_cast<node::encoding>(encoding));\n#else\n# if NODE_MODULE_VERSION >= NODE_0_10_MODULE_VERSION\n  return node::Encode(buf, len, static_cast<node::encoding>(encoding));\n# else\n  return imp::Encode(reinterpret_cast<const char*>(buf), len, encoding);\n# endif\n#endif\n}\n\ninline ssize_t DecodeBytes(\n    v8::Local<v8::Value> val, enum Encoding encoding = BINARY) {\n#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)\n  return node::DecodeBytes(\n      v8::Isolate::GetCurrent()\n    , val\n    , static_cast<node::encoding>(encoding));\n#else\n# if (NODE_MODULE_VERSION < NODE_0_10_MODULE_VERSION)\n  if (encoding == BUFFER) {\n    return node::DecodeBytes(val, node::BINARY);\n  }\n# endif\n  return node::DecodeBytes(val, static_cast<node::encoding>(encoding));\n#endif\n}\n\ninline ssize_t DecodeWrite(\n    char *buf\n  , size_t len\n  , v8::Local<v8::Value> val\n  , enum Encoding encoding = BINARY) {\n#if (NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION)\n  return node::DecodeWrite(\n      v8::Isolate::GetCurrent()\n    , buf\n    , len\n    , val\n    , static_cast<node::encoding>(encoding));\n#else\n# if (NODE_MODULE_VERSION < NODE_0_10_MODULE_VERSION)\n  if (encoding == BUFFER) {\n    return node::DecodeWrite(buf, len, val, node::BINARY);\n  }\n# endif\n  return node::DecodeWrite(\n      buf\n    , len\n    , val\n    , static_cast<node::encoding>(encoding));\n#endif\n}\n\ninline void SetPrototypeTemplate(\n    v8::Local<v8::FunctionTemplate> templ\n  , const char *name\n  , v8::Local<v8::Data> value\n) {\n  HandleScope scope;\n  SetTemplate(templ->PrototypeTemplate(), name, value);\n}\n\ninline void SetPrototypeTemplate(\n    v8::Local<v8::FunctionTemplate> templ\n  , v8::Local<v8::String> name\n  , v8::Local<v8::Data> value\n  , v8::PropertyAttribute attributes\n) {\n  HandleScope scope;\n  SetTemplate(templ->PrototypeTemplate(), name, value, attributes);\n}\n\ninline void SetInstanceTemplate(\n    v8::Local<v8::FunctionTemplate> templ\n  , const char *name\n  , v8::Local<v8::Data> value\n) {\n  HandleScope scope;\n  SetTemplate(templ->InstanceTemplate(), name, value);\n}\n\ninline void SetInstanceTemplate(\n    v8::Local<v8::FunctionTemplate> templ\n  , v8::Local<v8::String> name\n  , v8::Local<v8::Data> value\n  , v8::PropertyAttribute attributes\n) {\n  HandleScope scope;\n  SetTemplate(templ->InstanceTemplate(), name, value, attributes);\n}\n\nnamespace imp {\n\n// Note(@agnat): Helper to distinguish different receiver types. The first\n// version deals with receivers derived from v8::Template. The second version\n// handles everything else. The final argument only serves as discriminator and\n// is unused.\ntemplate <typename T>\ninline\nvoid\nSetMethodAux(T recv,\n             v8::Local<v8::String> name,\n             v8::Local<v8::FunctionTemplate> tpl,\n             v8::Template *) {\n  recv->Set(name, tpl);\n}\n\ntemplate <typename T>\ninline\nvoid\nSetMethodAux(T recv,\n             v8::Local<v8::String> name,\n             v8::Local<v8::FunctionTemplate> tpl,\n             ...) {\n  Set(recv, name, GetFunction(tpl).ToLocalChecked());\n}\n\n}  // end of namespace imp\n\ntemplate <typename T, template <typename> class HandleType>\ninline void SetMethod(\n    HandleType<T> recv\n  , const char *name\n  , FunctionCallback callback\n  , v8::Local<v8::Value> data = v8::Local<v8::Value>()) {\n  HandleScope scope;\n  v8::Local<v8::FunctionTemplate> t = New<v8::FunctionTemplate>(callback, data);\n  v8::Local<v8::String> fn_name = New(name).ToLocalChecked();\n  t->SetClassName(fn_name);\n  // Note(@agnat): Pass an empty T* as discriminator. See note on\n  // SetMethodAux(...) above\n  imp::SetMethodAux(recv, fn_name, t, static_cast<T*>(0));\n}\n\ninline void SetPrototypeMethod(\n    v8::Local<v8::FunctionTemplate> recv\n  , const char* name\n  , FunctionCallback callback\n  , v8::Local<v8::Value> data = v8::Local<v8::Value>()) {\n  HandleScope scope;\n  v8::Local<v8::FunctionTemplate> t = New<v8::FunctionTemplate>(\n      callback\n    , data\n    , New<v8::Signature>(recv));\n  v8::Local<v8::String> fn_name = New(name).ToLocalChecked();\n  recv->PrototypeTemplate()->Set(fn_name, t);\n  t->SetClassName(fn_name);\n}\n\n//=== Accessors and Such =======================================================\n\nNAN_DEPRECATED inline void SetAccessor(\n    v8::Local<v8::ObjectTemplate> tpl\n  , v8::Local<v8::String> name\n  , GetterCallback getter\n  , SetterCallback setter\n  , v8::Local<v8::Value> data\n  , v8::AccessControl settings\n  , v8::PropertyAttribute attribute\n  , imp::Sig signature) {\n  HandleScope scope;\n\n  imp::NativeGetter getter_ =\n      imp::GetterCallbackWrapper;\n  imp::NativeSetter setter_ =\n      setter ? imp::SetterCallbackWrapper : 0;\n\n  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();\n  otpl->SetInternalFieldCount(imp::kAccessorFieldCount);\n  v8::Local<v8::Object> obj = NewInstance(otpl).ToLocalChecked();\n\n  obj->SetInternalField(\n      imp::kGetterIndex\n    , New<v8::External>(reinterpret_cast<void *>(getter)));\n\n  if (setter != 0) {\n    obj->SetInternalField(\n        imp::kSetterIndex\n      , New<v8::External>(reinterpret_cast<void *>(setter)));\n  }\n\n  if (!data.IsEmpty()) {\n    obj->SetInternalField(imp::kDataIndex, data);\n  }\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 || (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 5))\n  tpl->SetNativeDataProperty(\n#else\n  tpl->SetAccessor(\n#endif\n      name\n    , getter_\n    , setter_\n    , obj\n#if !defined(V8_MAJOR_VERSION) || V8_MAJOR_VERSION < 12\n    , settings\n#endif\n    , attribute\n#if (NODE_MODULE_VERSION < NODE_16_0_MODULE_VERSION)\n    , signature\n#endif\n  );\n}\n\ninline void SetAccessor(\n    v8::Local<v8::ObjectTemplate> tpl\n  , v8::Local<v8::String> name\n  , GetterCallback getter\n  , SetterCallback setter = 0\n  , v8::Local<v8::Value> data = v8::Local<v8::Value>()\n  , v8::AccessControl settings = v8::DEFAULT\n  , v8::PropertyAttribute attribute = v8::None) {\n  HandleScope scope;\n\n  imp::NativeGetter getter_ =\n      imp::GetterCallbackWrapper;\n  imp::NativeSetter setter_ =\n      setter ? imp::SetterCallbackWrapper : 0;\n\n  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();\n  otpl->SetInternalFieldCount(imp::kAccessorFieldCount);\n  v8::Local<v8::Object> obj = NewInstance(otpl).ToLocalChecked();\n\n  obj->SetInternalField(\n      imp::kGetterIndex\n    , New<v8::External>(reinterpret_cast<void *>(getter)));\n\n  if (setter != 0) {\n    obj->SetInternalField(\n        imp::kSetterIndex\n      , New<v8::External>(reinterpret_cast<void *>(setter)));\n  }\n\n  if (!data.IsEmpty()) {\n    obj->SetInternalField(imp::kDataIndex, data);\n  }\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 || (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 5))\n  tpl->SetNativeDataProperty(\n#else\n  tpl->SetAccessor(\n#endif\n      name\n    , getter_\n    , setter_\n    , obj\n#if !defined(V8_MAJOR_VERSION) || V8_MAJOR_VERSION < 12\n    , settings\n#endif\n    , attribute\n  );\n}\n\ninline bool SetAccessor(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::String> name\n  , GetterCallback getter\n  , SetterCallback setter = 0\n  , v8::Local<v8::Value> data = v8::Local<v8::Value>()\n  , v8::AccessControl settings = v8::DEFAULT\n  , v8::PropertyAttribute attribute = v8::None) {\n  HandleScope scope;\n\n  imp::NativeGetter getter_ =\n      imp::GetterCallbackWrapper;\n  imp::NativeSetter setter_ =\n      setter ? imp::SetterCallbackWrapper : 0;\n\n  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();\n  otpl->SetInternalFieldCount(imp::kAccessorFieldCount);\n  v8::Local<v8::Object> dataobj = NewInstance(otpl).ToLocalChecked();\n\n  dataobj->SetInternalField(\n      imp::kGetterIndex\n    , New<v8::External>(reinterpret_cast<void *>(getter)));\n\n  if (!data.IsEmpty()) {\n    dataobj->SetInternalField(imp::kDataIndex, data);\n  }\n\n  if (setter) {\n    dataobj->SetInternalField(\n        imp::kSetterIndex\n      , New<v8::External>(reinterpret_cast<void *>(setter)));\n  }\n\n#if (NODE_MODULE_VERSION >= NODE_6_0_MODULE_VERSION)\n#if defined(V8_MAJOR_VERSION) &&                                               \\\n    (V8_MAJOR_VERSION > 12 ||                                                  \\\n     (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) &&                   \\\n      V8_MINOR_VERSION >= 5))\n  return obj->SetNativeDataProperty(\n      GetCurrentContext()\n    , name\n    , getter_\n    , setter_\n    , dataobj\n    , attribute).FromMaybe(false);\n#else\n  return obj->SetAccessor(\n      GetCurrentContext()\n    , name\n    , getter_\n    , setter_\n    , dataobj\n    , settings\n    , attribute).FromMaybe(false);\n#endif\n#else\n  return obj->SetAccessor(\n      name\n    , getter_\n    , setter_\n    , dataobj\n    , settings\n    , attribute);\n#endif\n}\n\ninline void SetNamedPropertyHandler(\n    v8::Local<v8::ObjectTemplate> tpl\n  , PropertyGetterCallback getter\n  , PropertySetterCallback setter = 0\n  , PropertyQueryCallback query = 0\n  , PropertyDeleterCallback deleter = 0\n  , PropertyEnumeratorCallback enumerator = 0\n  , v8::Local<v8::Value> data = v8::Local<v8::Value>()) {\n  HandleScope scope;\n\n  imp::NativePropertyGetter getter_ =\n      imp::PropertyGetterCallbackWrapper;\n  imp::NativePropertySetter setter_ =\n      setter ? imp::PropertySetterCallbackWrapper : 0;\n  imp::NativePropertyQuery query_ =\n      query ? imp::PropertyQueryCallbackWrapper : 0;\n  imp::NativePropertyDeleter *deleter_ =\n      deleter ? imp::PropertyDeleterCallbackWrapper : 0;\n  imp::NativePropertyEnumerator enumerator_ =\n      enumerator ? imp::PropertyEnumeratorCallbackWrapper : 0;\n\n  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();\n  otpl->SetInternalFieldCount(imp::kPropertyFieldCount);\n  v8::Local<v8::Object> obj = NewInstance(otpl).ToLocalChecked();\n  obj->SetInternalField(\n      imp::kPropertyGetterIndex\n    , New<v8::External>(reinterpret_cast<void *>(getter)));\n\n  if (setter) {\n    obj->SetInternalField(\n        imp::kPropertySetterIndex\n      , New<v8::External>(reinterpret_cast<void *>(setter)));\n  }\n\n  if (query) {\n    obj->SetInternalField(\n        imp::kPropertyQueryIndex\n      , New<v8::External>(reinterpret_cast<void *>(query)));\n  }\n\n  if (deleter) {\n    obj->SetInternalField(\n        imp::kPropertyDeleterIndex\n      , New<v8::External>(reinterpret_cast<void *>(deleter)));\n  }\n\n  if (enumerator) {\n    obj->SetInternalField(\n        imp::kPropertyEnumeratorIndex\n      , New<v8::External>(reinterpret_cast<void *>(enumerator)));\n  }\n\n  if (!data.IsEmpty()) {\n    obj->SetInternalField(imp::kDataIndex, data);\n  }\n\n#if NODE_MODULE_VERSION > NODE_0_12_MODULE_VERSION\n  tpl->SetHandler(v8::NamedPropertyHandlerConfiguration(\n      getter_, setter_, query_, deleter_, enumerator_, obj));\n#else\n  tpl->SetNamedPropertyHandler(\n      getter_\n    , setter_\n    , query_\n    , deleter_\n    , enumerator_\n    , obj);\n#endif\n}\n\ninline void SetIndexedPropertyHandler(\n    v8::Local<v8::ObjectTemplate> tpl\n  , IndexGetterCallback getter\n  , IndexSetterCallback setter = 0\n  , IndexQueryCallback query = 0\n  , IndexDeleterCallback deleter = 0\n  , IndexEnumeratorCallback enumerator = 0\n  , v8::Local<v8::Value> data = v8::Local<v8::Value>()) {\n  HandleScope scope;\n\n  imp::NativeIndexGetter getter_ =\n      imp::IndexGetterCallbackWrapper;\n  imp::NativeIndexSetter setter_ =\n      setter ? imp::IndexSetterCallbackWrapper : 0;\n  imp::NativeIndexQuery query_ =\n      query ? imp::IndexQueryCallbackWrapper : 0;\n  imp::NativeIndexDeleter deleter_ =\n      deleter ? imp::IndexDeleterCallbackWrapper : 0;\n  imp::NativeIndexEnumerator enumerator_ =\n      enumerator ? imp::IndexEnumeratorCallbackWrapper : 0;\n\n  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();\n  otpl->SetInternalFieldCount(imp::kIndexPropertyFieldCount);\n  v8::Local<v8::Object> obj = NewInstance(otpl).ToLocalChecked();\n  obj->SetInternalField(\n      imp::kIndexPropertyGetterIndex\n    , New<v8::External>(reinterpret_cast<void *>(getter)));\n\n  if (setter) {\n    obj->SetInternalField(\n        imp::kIndexPropertySetterIndex\n      , New<v8::External>(reinterpret_cast<void *>(setter)));\n  }\n\n  if (query) {\n    obj->SetInternalField(\n        imp::kIndexPropertyQueryIndex\n      , New<v8::External>(reinterpret_cast<void *>(query)));\n  }\n\n  if (deleter) {\n    obj->SetInternalField(\n        imp::kIndexPropertyDeleterIndex\n      , New<v8::External>(reinterpret_cast<void *>(deleter)));\n  }\n\n  if (enumerator) {\n    obj->SetInternalField(\n        imp::kIndexPropertyEnumeratorIndex\n      , New<v8::External>(reinterpret_cast<void *>(enumerator)));\n  }\n\n  if (!data.IsEmpty()) {\n    obj->SetInternalField(imp::kDataIndex, data);\n  }\n\n#if NODE_MODULE_VERSION > NODE_0_12_MODULE_VERSION\n  tpl->SetHandler(v8::IndexedPropertyHandlerConfiguration(\n      getter_, setter_, query_, deleter_, enumerator_, obj));\n#else\n  tpl->SetIndexedPropertyHandler(\n      getter_\n    , setter_\n    , query_\n    , deleter_\n    , enumerator_\n    , obj);\n#endif\n}\n\ninline void SetCallHandler(\n    v8::Local<v8::FunctionTemplate> tpl\n  , FunctionCallback callback\n  , v8::Local<v8::Value> data = v8::Local<v8::Value>()) {\n  HandleScope scope;\n\n  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();\n  otpl->SetInternalFieldCount(imp::kFunctionFieldCount);\n  v8::Local<v8::Object> obj = NewInstance(otpl).ToLocalChecked();\n\n  obj->SetInternalField(\n      imp::kFunctionIndex\n    , New<v8::External>(reinterpret_cast<void *>(callback)));\n\n  if (!data.IsEmpty()) {\n    obj->SetInternalField(imp::kDataIndex, data);\n  }\n\n  tpl->SetCallHandler(imp::FunctionCallbackWrapper, obj);\n}\n\n\ninline void SetCallAsFunctionHandler(\n    v8::Local<v8::ObjectTemplate> tpl,\n    FunctionCallback callback,\n    v8::Local<v8::Value> data = v8::Local<v8::Value>()) {\n  HandleScope scope;\n\n  v8::Local<v8::ObjectTemplate> otpl = New<v8::ObjectTemplate>();\n  otpl->SetInternalFieldCount(imp::kFunctionFieldCount);\n  v8::Local<v8::Object> obj = NewInstance(otpl).ToLocalChecked();\n\n  obj->SetInternalField(\n      imp::kFunctionIndex\n    , New<v8::External>(reinterpret_cast<void *>(callback)));\n\n  if (!data.IsEmpty()) {\n    obj->SetInternalField(imp::kDataIndex, data);\n  }\n\n  tpl->SetCallAsFunctionHandler(imp::FunctionCallbackWrapper, obj);\n}\n\n//=== Weak Persistent Handling =================================================\n\n#include \"nan_weak.h\"  // NOLINT(build/include)\n\n//=== ObjectWrap ===============================================================\n\n#include \"nan_object_wrap.h\"  // NOLINT(build/include)\n\n//=== HiddenValue/Private ======================================================\n\n#include \"nan_private.h\"  // NOLINT(build/include)\n\n//=== Export ==================================================================\n\ninline\nvoid\nExport(ADDON_REGISTER_FUNCTION_ARGS_TYPE target, const char *name,\n    FunctionCallback f) {\n  HandleScope scope;\n\n  Set(target, New<v8::String>(name).ToLocalChecked(),\n      GetFunction(New<v8::FunctionTemplate>(f)).ToLocalChecked());\n}\n\n//=== Tap Reverse Binding =====================================================\n\nstruct Tap {\n  explicit Tap(v8::Local<v8::Value> t) : t_() {\n    HandleScope scope;\n\n    t_.Reset(To<v8::Object>(t).ToLocalChecked());\n  }\n\n  ~Tap() { t_.Reset(); }  // not sure if necessary\n\n  inline void plan(int i) {\n    HandleScope scope;\n    v8::Local<v8::Value> arg = New(i);\n    Call(\"plan\", New(t_), 1, &arg);\n  }\n\n  inline void ok(bool isOk, const char *msg = NULL) {\n    HandleScope scope;\n    v8::Local<v8::Value> args[2];\n    args[0] = New(isOk);\n    if (msg) args[1] = New(msg).ToLocalChecked();\n    Call(\"ok\", New(t_), msg ? 2 : 1, args);\n  }\n\n  inline void pass(const char * msg = NULL) {\n    HandleScope scope;\n    v8::Local<v8::Value> hmsg;\n    if (msg) hmsg = New(msg).ToLocalChecked();\n    Call(\"pass\", New(t_), msg ? 1 : 0, &hmsg);\n  }\n\n  inline void end() {\n    HandleScope scope;\n    Call(\"end\", New(t_), 0, NULL);\n  }\n\n private:\n  Persistent<v8::Object> t_;\n};\n\n#define NAN_STRINGIZE2(x) #x\n#define NAN_STRINGIZE(x) NAN_STRINGIZE2(x)\n#define NAN_TEST_EXPRESSION(expression) \\\n  ( expression ), __FILE__ \":\" NAN_STRINGIZE(__LINE__) \": \" #expression\n\n#define NAN_EXPORT(target, function) Export(target, #function, function)\n\n#undef TYPE_CHECK\n\n//=== Generic Maybefication ===================================================\n\nnamespace imp {\n\ntemplate <typename T> struct Maybefier;\n\ntemplate <typename T> struct Maybefier<v8::Local<T> > {\n  inline static MaybeLocal<T> convert(v8::Local<T> v) {\n    return v;\n  }\n};\n\ntemplate <typename T> struct Maybefier<MaybeLocal<T> > {\n  inline static MaybeLocal<T> convert(MaybeLocal<T> v) {\n    return v;\n  }\n};\n\n}  // end of namespace imp\n\ntemplate <typename T, template <typename> class MaybeMaybe>\ninline MaybeLocal<T>\nMakeMaybe(MaybeMaybe<T> v) {\n  return imp::Maybefier<MaybeMaybe<T> >::convert(v);\n}\n\n//=== TypedArrayContents =======================================================\n\n#include \"nan_typedarray_contents.h\"  // NOLINT(build/include)\n\n//=== JSON =====================================================================\n\n#include \"nan_json.h\"  // NOLINT(build/include)\n\n//=== ScriptOrigin =============================================================\n\n#include \"nan_scriptorigin.h\"  // NOLINT(build/include)\n\n}  // end of namespace Nan\n\n#endif  // NAN_H_\n"
        },
        {
          "name": "nan_callbacks.h",
          "type": "blob",
          "size": 4.48828125,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_CALLBACKS_H_\n#define NAN_CALLBACKS_H_\n\ntemplate<typename T> class FunctionCallbackInfo;\ntemplate<typename T> class PropertyCallbackInfo;\ntemplate<typename T> class Global;\n\ntypedef void(*FunctionCallback)(const FunctionCallbackInfo<v8::Value>&);\ntypedef void(*GetterCallback)\n    (v8::Local<v8::String>, const PropertyCallbackInfo<v8::Value>&);\ntypedef void(*SetterCallback)(\n    v8::Local<v8::String>,\n    v8::Local<v8::Value>,\n    const PropertyCallbackInfo<void>&);\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\ntypedef v8::Intercepted(*PropertyGetterCallback)(\n    v8::Local<v8::String>,\n    const PropertyCallbackInfo<v8::Value>&);\ntypedef v8::Intercepted(*PropertySetterCallback)(\n    v8::Local<v8::String>,\n    v8::Local<v8::Value>,\n    const PropertyCallbackInfo<void>&);\n#else\ntypedef void(*PropertyGetterCallback)(\n    v8::Local<v8::String>,\n    const PropertyCallbackInfo<v8::Value>&);\ntypedef void(*PropertySetterCallback)(\n    v8::Local<v8::String>,\n    v8::Local<v8::Value>,\n    const PropertyCallbackInfo<v8::Value>&);\n#endif\ntypedef void(*PropertyEnumeratorCallback)\n    (const PropertyCallbackInfo<v8::Array>&);\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\ntypedef v8::Intercepted(*PropertyDeleterCallback)(\n    v8::Local<v8::String>,\n    const PropertyCallbackInfo<v8::Boolean>&);\ntypedef v8::Intercepted(*PropertyQueryCallback)(\n    v8::Local<v8::String>,\n    const PropertyCallbackInfo<v8::Integer>&);\ntypedef v8::Intercepted(*IndexGetterCallback)(\n    uint32_t,\n    const PropertyCallbackInfo<v8::Value>&);\ntypedef v8::Intercepted(*IndexSetterCallback)(\n    uint32_t,\n    v8::Local<v8::Value>,\n    const PropertyCallbackInfo<void>&);\ntypedef v8::Intercepted(*IndexEnumeratorCallback)\n    (const PropertyCallbackInfo<v8::Array>&);\ntypedef v8::Intercepted(*IndexDeleterCallback)(\n    uint32_t,\n    const PropertyCallbackInfo<v8::Boolean>&);\ntypedef v8::Intercepted(*IndexQueryCallback)(\n    uint32_t,\n    const PropertyCallbackInfo<v8::Integer>&);\n#else\ntypedef void(*PropertyDeleterCallback)(\n    v8::Local<v8::String>,\n    const PropertyCallbackInfo<v8::Boolean>&);\ntypedef void(*PropertyQueryCallback)(\n    v8::Local<v8::String>,\n    const PropertyCallbackInfo<v8::Integer>&);\ntypedef void(*IndexGetterCallback)(\n    uint32_t,\n    const PropertyCallbackInfo<v8::Value>&);\ntypedef void(*IndexSetterCallback)(\n    uint32_t,\n    v8::Local<v8::Value>,\n    const PropertyCallbackInfo<v8::Value>&);\ntypedef void(*IndexEnumeratorCallback)\n    (const PropertyCallbackInfo<v8::Array>&);\ntypedef void(*IndexDeleterCallback)(\n    uint32_t,\n    const PropertyCallbackInfo<v8::Boolean>&);\ntypedef void(*IndexQueryCallback)(\n    uint32_t,\n    const PropertyCallbackInfo<v8::Integer>&);\n#endif\nnamespace imp {\n#if (NODE_MODULE_VERSION < NODE_16_0_MODULE_VERSION)\ntypedef v8::Local<v8::AccessorSignature> Sig;\n#else\ntypedef v8::Local<v8::Data> Sig;\n#endif\n\nstatic const int kDataIndex =                    0;\n\nstatic const int kFunctionIndex =                1;\nstatic const int kFunctionFieldCount =           2;\n\nstatic const int kGetterIndex =                  1;\nstatic const int kSetterIndex =                  2;\nstatic const int kAccessorFieldCount =           3;\n\nstatic const int kPropertyGetterIndex =          1;\nstatic const int kPropertySetterIndex =          2;\nstatic const int kPropertyEnumeratorIndex =      3;\nstatic const int kPropertyDeleterIndex =         4;\nstatic const int kPropertyQueryIndex =           5;\nstatic const int kPropertyFieldCount =           6;\n\nstatic const int kIndexPropertyGetterIndex =     1;\nstatic const int kIndexPropertySetterIndex =     2;\nstatic const int kIndexPropertyEnumeratorIndex = 3;\nstatic const int kIndexPropertyDeleterIndex =    4;\nstatic const int kIndexPropertyQueryIndex =      5;\nstatic const int kIndexPropertyFieldCount =      6;\n\n}  // end of namespace imp\n\n#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n# include \"nan_callbacks_12_inl.h\"  // NOLINT(build/include)\n#else\n# include \"nan_callbacks_pre_12_inl.h\"  // NOLINT(build/include)\n#endif\n\n#endif  // NAN_CALLBACKS_H_\n"
        },
        {
          "name": "nan_callbacks_12_inl.h",
          "type": "blob",
          "size": 23.9833984375,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_CALLBACKS_12_INL_H_\n#define NAN_CALLBACKS_12_INL_H_\n\ntemplate<typename T>\nclass ReturnValue {\n  v8::ReturnValue<T> value_;\n\n public:\n  template <class S>\n  explicit inline ReturnValue(const v8::ReturnValue<S> &value) :\n      value_(value) {}\n  template <class S>\n  explicit inline ReturnValue(const ReturnValue<S>& that)\n      : value_(that.value_) {\n    TYPE_CHECK(T, S);\n  }\n\n  // Handle setters\n  template <typename S> inline void Set(const v8::Local<S> &handle) {\n    TYPE_CHECK(T, S);\n    value_.Set(handle);\n  }\n\n  template <typename S> inline void Set(const Global<S> &handle) {\n    TYPE_CHECK(T, S);\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) &&                       \\\n  (V8_MINOR_VERSION > 5 || (V8_MINOR_VERSION == 5 &&                           \\\n  defined(V8_BUILD_NUMBER) && V8_BUILD_NUMBER >= 8))))\n    value_.Set(handle);\n#else\n    value_.Set(*reinterpret_cast<const v8::Persistent<S>*>(&handle));\n    const_cast<Global<S> &>(handle).Reset();\n#endif\n  }\n\n  // Fast primitive setters\n  inline void Set(bool value) {\n    TYPE_CHECK(T, v8::Boolean);\n    value_.Set(value);\n  }\n\n  inline void Set(double i) {\n    TYPE_CHECK(T, v8::Number);\n    value_.Set(i);\n  }\n\n  inline void Set(int32_t i) {\n    TYPE_CHECK(T, v8::Integer);\n    value_.Set(i);\n  }\n\n  inline void Set(uint32_t i) {\n    TYPE_CHECK(T, v8::Integer);\n    value_.Set(i);\n  }\n\n  // Fast JS primitive setters\n  inline void SetNull() {\n    TYPE_CHECK(T, v8::Primitive);\n    value_.SetNull();\n  }\n\n  inline void SetUndefined() {\n    TYPE_CHECK(T, v8::Primitive);\n    value_.SetUndefined();\n  }\n\n  inline void SetEmptyString() {\n    TYPE_CHECK(T, v8::String);\n    value_.SetEmptyString();\n  }\n\n  // Convenience getter for isolate\n  inline v8::Isolate *GetIsolate() const {\n    return value_.GetIsolate();\n  }\n\n  // Pointer setter: Uncompilable to prevent inadvertent misuse.\n  template<typename S>\n  inline void Set(S *whatever) { TYPE_CHECK(S*, v8::Primitive); }\n};\n\ntemplate<typename T>\nclass FunctionCallbackInfo {\n  const v8::FunctionCallbackInfo<T> &info_;\n  const v8::Local<v8::Value> data_;\n\n public:\n  explicit inline FunctionCallbackInfo(\n      const v8::FunctionCallbackInfo<T> &info\n    , v8::Local<v8::Value> data) :\n          info_(info)\n        , data_(data) {}\n\n  inline ReturnValue<T> GetReturnValue() const {\n    return ReturnValue<T>(info_.GetReturnValue());\n  }\n\n#if NODE_MAJOR_VERSION < 10\n  inline v8::Local<v8::Function> Callee() const { return info_.Callee(); }\n#endif\n  inline v8::Local<v8::Value> Data() const { return data_; }\n  inline v8::Local<v8::Object> Holder() const { return info_.Holder(); }\n  inline bool IsConstructCall() const { return info_.IsConstructCall(); }\n  inline int Length() const { return info_.Length(); }\n  inline v8::Local<v8::Value> operator[](int i) const { return info_[i]; }\n  inline v8::Local<v8::Object> This() const { return info_.This(); }\n  inline v8::Isolate *GetIsolate() const { return info_.GetIsolate(); }\n\n\n protected:\n  static const int kHolderIndex = 0;\n  static const int kIsolateIndex = 1;\n  static const int kReturnValueDefaultValueIndex = 2;\n  static const int kReturnValueIndex = 3;\n  static const int kDataIndex = 4;\n  static const int kCalleeIndex = 5;\n  static const int kContextSaveIndex = 6;\n  static const int kArgsLength = 7;\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(FunctionCallbackInfo)\n};\n\ntemplate<typename T>\nclass PropertyCallbackInfo {\n  const v8::PropertyCallbackInfo<T> &info_;\n  const v8::Local<v8::Value> data_;\n\n public:\n  explicit inline PropertyCallbackInfo(\n      const v8::PropertyCallbackInfo<T> &info\n    , const v8::Local<v8::Value> data) :\n          info_(info)\n        , data_(data) {}\n\n  inline v8::Isolate* GetIsolate() const { return info_.GetIsolate(); }\n  inline v8::Local<v8::Value> Data() const { return data_; }\n  inline v8::Local<v8::Object> This() const { return info_.This(); }\n  inline v8::Local<v8::Object> Holder() const { return info_.Holder(); }\n  inline ReturnValue<T> GetReturnValue() const {\n    return ReturnValue<T>(info_.GetReturnValue());\n  }\n\n protected:\n  static const int kHolderIndex = 0;\n  static const int kIsolateIndex = 1;\n  static const int kReturnValueDefaultValueIndex = 2;\n  static const int kReturnValueIndex = 3;\n  static const int kDataIndex = 4;\n  static const int kThisIndex = 5;\n  static const int kArgsLength = 6;\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(PropertyCallbackInfo)\n};\n\nnamespace imp {\nstatic\nvoid FunctionCallbackWrapper(const v8::FunctionCallbackInfo<v8::Value> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  FunctionCallback callback = reinterpret_cast<FunctionCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kFunctionIndex)\n          .As<v8::Value>().As<v8::External>()->Value()));\n  FunctionCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  callback(cbinfo);\n}\n\ntypedef void (*NativeFunction)(const v8::FunctionCallbackInfo<v8::Value> &);\n\n#if NODE_MODULE_VERSION > NODE_0_12_MODULE_VERSION\nstatic\nvoid GetterCallbackWrapper(\n    v8::Local<v8::Name> property\n  , const v8::PropertyCallbackInfo<v8::Value> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  GetterCallback callback = reinterpret_cast<GetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kGetterIndex)\n          .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property.As<v8::String>(), cbinfo);\n}\n\ntypedef void (*NativeGetter)\n    (v8::Local<v8::Name>, const v8::PropertyCallbackInfo<v8::Value> &);\n\nstatic\nvoid SetterCallbackWrapper(\n    v8::Local<v8::Name> property\n  , v8::Local<v8::Value> value\n  , const v8::PropertyCallbackInfo<void> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<void>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  SetterCallback callback = reinterpret_cast<SetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kSetterIndex)\n          .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property.As<v8::String>(), value, cbinfo);\n}\n\ntypedef void (*NativeSetter)(\n    v8::Local<v8::Name>\n  , v8::Local<v8::Value>\n  , const v8::PropertyCallbackInfo<void> &);\n#else\nstatic\nvoid GetterCallbackWrapper(\n    v8::Local<v8::String> property\n  , const v8::PropertyCallbackInfo<v8::Value> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  GetterCallback callback = reinterpret_cast<GetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kGetterIndex)\n          .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property, cbinfo);\n}\n\ntypedef void (*NativeGetter)\n    (v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value> &);\n\nstatic\nvoid SetterCallbackWrapper(\n    v8::Local<v8::String> property\n  , v8::Local<v8::Value> value\n  , const v8::PropertyCallbackInfo<void> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<void>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  SetterCallback callback = reinterpret_cast<SetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kSetterIndex)\n          .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property, value, cbinfo);\n}\n\ntypedef void (*NativeSetter)(\n    v8::Local<v8::String>\n  , v8::Local<v8::Value>\n  , const v8::PropertyCallbackInfo<void> &);\n#endif\n\n#if NODE_MODULE_VERSION > NODE_0_12_MODULE_VERSION\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\nstatic\nv8::Intercepted PropertyGetterCallbackWrapper(\n    v8::Local<v8::Name> property\n  , const v8::PropertyCallbackInfo<v8::Value> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertyGetterCallback callback = reinterpret_cast<PropertyGetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyGetterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  return callback(property.As<v8::String>(), cbinfo);\n}\n\ntypedef v8::Intercepted (*NativePropertyGetter)\n    (v8::Local<v8::Name>, const v8::PropertyCallbackInfo<v8::Value> &);\n\nstatic\nv8::Intercepted PropertySetterCallbackWrapper(\n    v8::Local<v8::Name> property\n  , v8::Local<v8::Value> value\n  , const v8::PropertyCallbackInfo<void> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<void>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertySetterCallback callback = reinterpret_cast<PropertySetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertySetterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  return callback(property.As<v8::String>(), value, cbinfo);\n}\n\ntypedef v8::Intercepted (*NativePropertySetter)(\n    v8::Local<v8::Name>\n  , v8::Local<v8::Value>\n  , const v8::PropertyCallbackInfo<void> &);\n\n#else\nstatic\nvoid PropertyGetterCallbackWrapper(\n    v8::Local<v8::Name> property\n  , const v8::PropertyCallbackInfo<v8::Value> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertyGetterCallback callback = reinterpret_cast<PropertyGetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyGetterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property.As<v8::String>(), cbinfo);\n}\n\ntypedef void (*NativePropertyGetter)\n    (v8::Local<v8::Name>, const v8::PropertyCallbackInfo<v8::Value> &);\n\nstatic\nvoid PropertySetterCallbackWrapper(\n    v8::Local<v8::Name> property\n  , v8::Local<v8::Value> value\n  , const v8::PropertyCallbackInfo<v8::Value> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertySetterCallback callback = reinterpret_cast<PropertySetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertySetterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property.As<v8::String>(), value, cbinfo);\n}\n\ntypedef void (*NativePropertySetter)(\n    v8::Local<v8::Name>\n  , v8::Local<v8::Value>\n  , const v8::PropertyCallbackInfo<v8::Value> &);\n#endif\n\nstatic\nvoid PropertyEnumeratorCallbackWrapper(\n    const v8::PropertyCallbackInfo<v8::Array> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Array>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertyEnumeratorCallback callback =\n      reinterpret_cast<PropertyEnumeratorCallback>(reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyEnumeratorIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(cbinfo);\n}\n\ntypedef void (*NativePropertyEnumerator)\n    (const v8::PropertyCallbackInfo<v8::Array> &);\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\nstatic\nv8::Intercepted PropertyDeleterCallbackWrapper(\n    v8::Local<v8::Name> property\n  , const v8::PropertyCallbackInfo<v8::Boolean> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Boolean>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertyDeleterCallback callback = reinterpret_cast<PropertyDeleterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyDeleterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  return callback(property.As<v8::String>(), cbinfo);\n}\n\ntypedef v8::Intercepted (NativePropertyDeleter)\n    (v8::Local<v8::Name>, const v8::PropertyCallbackInfo<v8::Boolean> &);\n\n\nstatic\nv8::Intercepted PropertyQueryCallbackWrapper(\n    v8::Local<v8::Name> property\n  , const v8::PropertyCallbackInfo<v8::Integer> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Integer>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertyQueryCallback callback = reinterpret_cast<PropertyQueryCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyQueryIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  return callback(property.As<v8::String>(), cbinfo);\n}\n\ntypedef v8::Intercepted (*NativePropertyQuery)\n    (v8::Local<v8::Name>, const v8::PropertyCallbackInfo<v8::Integer> &);\n#else\nstatic\nvoid PropertyDeleterCallbackWrapper(\n    v8::Local<v8::Name> property\n  , const v8::PropertyCallbackInfo<v8::Boolean> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Boolean>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertyDeleterCallback callback = reinterpret_cast<PropertyDeleterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyDeleterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property.As<v8::String>(), cbinfo);\n}\n\ntypedef void (NativePropertyDeleter)\n    (v8::Local<v8::Name>, const v8::PropertyCallbackInfo<v8::Boolean> &);\n\nstatic\nvoid PropertyQueryCallbackWrapper(\n    v8::Local<v8::Name> property\n  , const v8::PropertyCallbackInfo<v8::Integer> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Integer>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertyQueryCallback callback = reinterpret_cast<PropertyQueryCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyQueryIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property.As<v8::String>(), cbinfo);\n}\n\ntypedef void (*NativePropertyQuery)\n    (v8::Local<v8::Name>, const v8::PropertyCallbackInfo<v8::Integer> &);\n#endif\n#else\nstatic\nvoid PropertyGetterCallbackWrapper(\n    v8::Local<v8::String> property\n  , const v8::PropertyCallbackInfo<v8::Value> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertyGetterCallback callback = reinterpret_cast<PropertyGetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyGetterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property, cbinfo);\n}\n\ntypedef void (*NativePropertyGetter)\n    (v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value> &);\n\nstatic\nvoid PropertySetterCallbackWrapper(\n    v8::Local<v8::String> property\n  , v8::Local<v8::Value> value\n  , const v8::PropertyCallbackInfo<v8::Value> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertySetterCallback callback = reinterpret_cast<PropertySetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertySetterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property, value, cbinfo);\n}\n\ntypedef void (*NativePropertySetter)(\n    v8::Local<v8::String>\n  , v8::Local<v8::Value>\n  , const v8::PropertyCallbackInfo<v8::Value> &);\n\nstatic\nvoid PropertyEnumeratorCallbackWrapper(\n    const v8::PropertyCallbackInfo<v8::Array> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Array>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertyEnumeratorCallback callback =\n      reinterpret_cast<PropertyEnumeratorCallback>(reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyEnumeratorIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(cbinfo);\n}\n\ntypedef void (*NativePropertyEnumerator)\n    (const v8::PropertyCallbackInfo<v8::Array> &);\n\nstatic\nvoid PropertyDeleterCallbackWrapper(\n    v8::Local<v8::String> property\n  , const v8::PropertyCallbackInfo<v8::Boolean> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Boolean>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertyDeleterCallback callback = reinterpret_cast<PropertyDeleterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyDeleterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property, cbinfo);\n}\n\ntypedef void (NativePropertyDeleter)\n    (v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Boolean> &);\n\nstatic\nvoid PropertyQueryCallbackWrapper(\n    v8::Local<v8::String> property\n  , const v8::PropertyCallbackInfo<v8::Integer> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Integer>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  PropertyQueryCallback callback = reinterpret_cast<PropertyQueryCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyQueryIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(property, cbinfo);\n}\n\ntypedef void (*NativePropertyQuery)\n    (v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Integer> &);\n#endif\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\nstatic\nv8::Intercepted IndexGetterCallbackWrapper(\n    uint32_t index, const v8::PropertyCallbackInfo<v8::Value> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  IndexGetterCallback callback = reinterpret_cast<IndexGetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertyGetterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  return callback(index, cbinfo);\n}\n\ntypedef v8::Intercepted (*NativeIndexGetter)\n    (uint32_t, const v8::PropertyCallbackInfo<v8::Value> &);\n\nstatic\nv8::Intercepted IndexSetterCallbackWrapper(\n    uint32_t index\n  , v8::Local<v8::Value> value\n  , const v8::PropertyCallbackInfo<void> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<void>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  IndexSetterCallback callback = reinterpret_cast<IndexSetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertySetterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  return callback(index, value, cbinfo);\n}\n\ntypedef v8::Intercepted (*NativeIndexSetter)(\n    uint32_t\n  , v8::Local<v8::Value>\n  , const v8::PropertyCallbackInfo<void> &);\n\n#else\nstatic\nvoid IndexGetterCallbackWrapper(\n    uint32_t index, const v8::PropertyCallbackInfo<v8::Value> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  IndexGetterCallback callback = reinterpret_cast<IndexGetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertyGetterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(index, cbinfo);\n}\n\ntypedef void (*NativeIndexGetter)\n    (uint32_t, const v8::PropertyCallbackInfo<v8::Value> &);\nstatic\nvoid IndexSetterCallbackWrapper(\n    uint32_t index\n  , v8::Local<v8::Value> value\n  , const v8::PropertyCallbackInfo<v8::Value> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  IndexSetterCallback callback = reinterpret_cast<IndexSetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertySetterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(index, value, cbinfo);\n}\n\ntypedef void (*NativeIndexSetter)(\n    uint32_t\n  , v8::Local<v8::Value>\n  , const v8::PropertyCallbackInfo<v8::Value> &);\n\n#endif\n\nstatic\nvoid IndexEnumeratorCallbackWrapper(\n    const v8::PropertyCallbackInfo<v8::Array> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Array>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  IndexEnumeratorCallback callback = reinterpret_cast<IndexEnumeratorCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(\n              kIndexPropertyEnumeratorIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(cbinfo);\n}\n\ntypedef void (*NativeIndexEnumerator)\n    (const v8::PropertyCallbackInfo<v8::Array> &);\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 12 ||                     \\\n  (V8_MAJOR_VERSION == 12 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 4))\nstatic\nv8::Intercepted IndexDeleterCallbackWrapper(\n    uint32_t index, const v8::PropertyCallbackInfo<v8::Boolean> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Boolean>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  IndexDeleterCallback callback = reinterpret_cast<IndexDeleterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertyDeleterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  return callback(index, cbinfo);\n}\n\ntypedef v8::Intercepted (*NativeIndexDeleter)\n    (uint32_t, const v8::PropertyCallbackInfo<v8::Boolean> &);\n\nstatic\nv8::Intercepted IndexQueryCallbackWrapper(\n    uint32_t index, const v8::PropertyCallbackInfo<v8::Integer> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Integer>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  IndexQueryCallback callback = reinterpret_cast<IndexQueryCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertyQueryIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  return callback(index, cbinfo);\n}\n\ntypedef v8::Intercepted (*NativeIndexQuery)\n    (uint32_t, const v8::PropertyCallbackInfo<v8::Integer> &);\n#else\nstatic\nvoid IndexDeleterCallbackWrapper(\n    uint32_t index, const v8::PropertyCallbackInfo<v8::Boolean> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Boolean>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  IndexDeleterCallback callback = reinterpret_cast<IndexDeleterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertyDeleterIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(index, cbinfo);\n}\n\ntypedef void (*NativeIndexDeleter)\n    (uint32_t, const v8::PropertyCallbackInfo<v8::Boolean> &);\n\nstatic\nvoid IndexQueryCallbackWrapper(\n    uint32_t index, const v8::PropertyCallbackInfo<v8::Integer> &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Integer>\n      cbinfo(info, obj->GetInternalField(kDataIndex).As<v8::Value>());\n  IndexQueryCallback callback = reinterpret_cast<IndexQueryCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertyQueryIndex)\n              .As<v8::Value>().As<v8::External>()->Value()));\n  callback(index, cbinfo);\n}\n\ntypedef void (*NativeIndexQuery)\n    (uint32_t, const v8::PropertyCallbackInfo<v8::Integer> &);\n\n#endif\n}  // end of namespace imp\n\n#endif  // NAN_CALLBACKS_12_INL_H_\n"
        },
        {
          "name": "nan_callbacks_pre_12_inl.h",
          "type": "blob",
          "size": 16.6845703125,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_CALLBACKS_PRE_12_INL_H_\n#define NAN_CALLBACKS_PRE_12_INL_H_\n\nnamespace imp {\ntemplate<typename T> class ReturnValueImp;\n}  // end of namespace imp\n\ntemplate<typename T>\nclass ReturnValue {\n  v8::Isolate *isolate_;\n  v8::Persistent<T> *value_;\n  friend class imp::ReturnValueImp<T>;\n\n public:\n  template <class S>\n  explicit inline ReturnValue(v8::Isolate *isolate, v8::Persistent<S> *p) :\n      isolate_(isolate), value_(p) {}\n  template <class S>\n  explicit inline ReturnValue(const ReturnValue<S>& that)\n      : isolate_(that.isolate_), value_(that.value_) {\n    TYPE_CHECK(T, S);\n  }\n\n  // Handle setters\n  template <typename S> inline void Set(const v8::Local<S> &handle) {\n    TYPE_CHECK(T, S);\n    value_->Dispose();\n    *value_ = v8::Persistent<T>::New(handle);\n  }\n\n  template <typename S> inline void Set(const Global<S> &handle) {\n    TYPE_CHECK(T, S);\n    value_->Dispose();\n    *value_ = v8::Persistent<T>::New(handle.persistent);\n    const_cast<Global<S> &>(handle).Reset();\n  }\n\n  // Fast primitive setters\n  inline void Set(bool value) {\n    v8::HandleScope scope;\n\n    TYPE_CHECK(T, v8::Boolean);\n    value_->Dispose();\n    *value_ = v8::Persistent<T>::New(v8::Boolean::New(value));\n  }\n\n  inline void Set(double i) {\n    v8::HandleScope scope;\n\n    TYPE_CHECK(T, v8::Number);\n    value_->Dispose();\n    *value_ = v8::Persistent<T>::New(v8::Number::New(i));\n  }\n\n  inline void Set(int32_t i) {\n    v8::HandleScope scope;\n\n    TYPE_CHECK(T, v8::Integer);\n    value_->Dispose();\n    *value_ = v8::Persistent<T>::New(v8::Int32::New(i));\n  }\n\n  inline void Set(uint32_t i) {\n    v8::HandleScope scope;\n\n    TYPE_CHECK(T, v8::Integer);\n    value_->Dispose();\n    *value_ = v8::Persistent<T>::New(v8::Uint32::NewFromUnsigned(i));\n  }\n\n  // Fast JS primitive setters\n  inline void SetNull() {\n    v8::HandleScope scope;\n\n    TYPE_CHECK(T, v8::Primitive);\n    value_->Dispose();\n    *value_ = v8::Persistent<T>::New(v8::Null());\n  }\n\n  inline void SetUndefined() {\n    v8::HandleScope scope;\n\n    TYPE_CHECK(T, v8::Primitive);\n    value_->Dispose();\n    *value_ = v8::Persistent<T>::New(v8::Undefined());\n  }\n\n  inline void SetEmptyString() {\n    v8::HandleScope scope;\n\n    TYPE_CHECK(T, v8::String);\n    value_->Dispose();\n    *value_ = v8::Persistent<T>::New(v8::String::Empty());\n  }\n\n  // Convenience getter for isolate\n  inline v8::Isolate *GetIsolate() const {\n    return isolate_;\n  }\n\n  // Pointer setter: Uncompilable to prevent inadvertent misuse.\n  template<typename S>\n  inline void Set(S *whatever) { TYPE_CHECK(S*, v8::Primitive); }\n};\n\ntemplate<typename T>\nclass FunctionCallbackInfo {\n  const v8::Arguments &args_;\n  v8::Local<v8::Value> data_;\n  ReturnValue<T> return_value_;\n  v8::Persistent<T> retval_;\n\n public:\n  explicit inline FunctionCallbackInfo(\n      const v8::Arguments &args\n    , v8::Local<v8::Value> data) :\n          args_(args)\n        , data_(data)\n        , return_value_(args.GetIsolate(), &retval_)\n        , retval_(v8::Persistent<T>::New(v8::Undefined())) {}\n\n  inline ~FunctionCallbackInfo() {\n    retval_.Dispose();\n    retval_.Clear();\n  }\n\n  inline ReturnValue<T> GetReturnValue() const {\n    return ReturnValue<T>(return_value_);\n  }\n\n  inline v8::Local<v8::Function> Callee() const { return args_.Callee(); }\n  inline v8::Local<v8::Value> Data() const { return data_; }\n  inline v8::Local<v8::Object> Holder() const { return args_.Holder(); }\n  inline bool IsConstructCall() const { return args_.IsConstructCall(); }\n  inline int Length() const { return args_.Length(); }\n  inline v8::Local<v8::Value> operator[](int i) const { return args_[i]; }\n  inline v8::Local<v8::Object> This() const { return args_.This(); }\n  inline v8::Isolate *GetIsolate() const { return args_.GetIsolate(); }\n\n\n protected:\n  static const int kHolderIndex = 0;\n  static const int kIsolateIndex = 1;\n  static const int kReturnValueDefaultValueIndex = 2;\n  static const int kReturnValueIndex = 3;\n  static const int kDataIndex = 4;\n  static const int kCalleeIndex = 5;\n  static const int kContextSaveIndex = 6;\n  static const int kArgsLength = 7;\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(FunctionCallbackInfo)\n};\n\ntemplate<typename T>\nclass PropertyCallbackInfoBase {\n  const v8::AccessorInfo &info_;\n  const v8::Local<v8::Value> data_;\n\n public:\n  explicit inline PropertyCallbackInfoBase(\n      const v8::AccessorInfo &info\n    , const v8::Local<v8::Value> data) :\n          info_(info)\n        , data_(data) {}\n\n  inline v8::Isolate* GetIsolate() const { return info_.GetIsolate(); }\n  inline v8::Local<v8::Value> Data() const { return data_; }\n  inline v8::Local<v8::Object> This() const { return info_.This(); }\n  inline v8::Local<v8::Object> Holder() const { return info_.Holder(); }\n\n protected:\n  static const int kHolderIndex = 0;\n  static const int kIsolateIndex = 1;\n  static const int kReturnValueDefaultValueIndex = 2;\n  static const int kReturnValueIndex = 3;\n  static const int kDataIndex = 4;\n  static const int kThisIndex = 5;\n  static const int kArgsLength = 6;\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(PropertyCallbackInfoBase)\n};\n\ntemplate<typename T>\nclass PropertyCallbackInfo : public PropertyCallbackInfoBase<T> {\n  ReturnValue<T> return_value_;\n  v8::Persistent<T> retval_;\n\n public:\n  explicit inline PropertyCallbackInfo(\n      const v8::AccessorInfo &info\n    , const v8::Local<v8::Value> data) :\n          PropertyCallbackInfoBase<T>(info, data)\n        , return_value_(info.GetIsolate(), &retval_)\n        , retval_(v8::Persistent<T>::New(v8::Undefined())) {}\n\n  inline ~PropertyCallbackInfo() {\n    retval_.Dispose();\n    retval_.Clear();\n  }\n\n  inline ReturnValue<T> GetReturnValue() const { return return_value_; }\n};\n\ntemplate<>\nclass PropertyCallbackInfo<v8::Array> :\n    public PropertyCallbackInfoBase<v8::Array> {\n  ReturnValue<v8::Array> return_value_;\n  v8::Persistent<v8::Array> retval_;\n\n public:\n  explicit inline PropertyCallbackInfo(\n      const v8::AccessorInfo &info\n    , const v8::Local<v8::Value> data) :\n          PropertyCallbackInfoBase<v8::Array>(info, data)\n        , return_value_(info.GetIsolate(), &retval_)\n        , retval_(v8::Persistent<v8::Array>::New(v8::Local<v8::Array>())) {}\n\n  inline ~PropertyCallbackInfo() {\n    retval_.Dispose();\n    retval_.Clear();\n  }\n\n  inline ReturnValue<v8::Array> GetReturnValue() const {\n    return return_value_;\n  }\n};\n\ntemplate<>\nclass PropertyCallbackInfo<v8::Boolean> :\n    public PropertyCallbackInfoBase<v8::Boolean> {\n  ReturnValue<v8::Boolean> return_value_;\n  v8::Persistent<v8::Boolean> retval_;\n\n public:\n  explicit inline PropertyCallbackInfo(\n      const v8::AccessorInfo &info\n    , const v8::Local<v8::Value> data) :\n          PropertyCallbackInfoBase<v8::Boolean>(info, data)\n        , return_value_(info.GetIsolate(), &retval_)\n        , retval_(v8::Persistent<v8::Boolean>::New(v8::Local<v8::Boolean>())) {}\n\n  inline ~PropertyCallbackInfo() {\n    retval_.Dispose();\n    retval_.Clear();\n  }\n\n  inline ReturnValue<v8::Boolean> GetReturnValue() const {\n    return return_value_;\n  }\n};\n\ntemplate<>\nclass PropertyCallbackInfo<v8::Integer> :\n    public PropertyCallbackInfoBase<v8::Integer> {\n  ReturnValue<v8::Integer> return_value_;\n  v8::Persistent<v8::Integer> retval_;\n\n public:\n  explicit inline PropertyCallbackInfo(\n      const v8::AccessorInfo &info\n    , const v8::Local<v8::Value> data) :\n          PropertyCallbackInfoBase<v8::Integer>(info, data)\n        , return_value_(info.GetIsolate(), &retval_)\n        , retval_(v8::Persistent<v8::Integer>::New(v8::Local<v8::Integer>())) {}\n\n  inline ~PropertyCallbackInfo() {\n    retval_.Dispose();\n    retval_.Clear();\n  }\n\n  inline ReturnValue<v8::Integer> GetReturnValue() const {\n    return return_value_;\n  }\n};\n\nnamespace imp {\ntemplate<typename T>\nclass ReturnValueImp : public ReturnValue<T> {\n public:\n  explicit ReturnValueImp(ReturnValue<T> that) :\n      ReturnValue<T>(that) {}\n  inline v8::Handle<T> Value() {\n      return *ReturnValue<T>::value_;\n  }\n};\n\nstatic\nv8::Handle<v8::Value> FunctionCallbackWrapper(const v8::Arguments &args) {\n  v8::Local<v8::Object> obj = args.Data().As<v8::Object>();\n  FunctionCallback callback = reinterpret_cast<FunctionCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kFunctionIndex).As<v8::External>()->Value()));\n  FunctionCallbackInfo<v8::Value>\n      cbinfo(args, obj->GetInternalField(kDataIndex));\n  callback(cbinfo);\n  return ReturnValueImp<v8::Value>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Value> (*NativeFunction)(const v8::Arguments &);\n\nstatic\nv8::Handle<v8::Value> GetterCallbackWrapper(\n    v8::Local<v8::String> property, const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  GetterCallback callback = reinterpret_cast<GetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kGetterIndex).As<v8::External>()->Value()));\n  callback(property, cbinfo);\n  return ReturnValueImp<v8::Value>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Value> (*NativeGetter)\n    (v8::Local<v8::String>, const v8::AccessorInfo &);\n\nstatic\nvoid SetterCallbackWrapper(\n    v8::Local<v8::String> property\n  , v8::Local<v8::Value> value\n  , const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<void>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  SetterCallback callback = reinterpret_cast<SetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kSetterIndex).As<v8::External>()->Value()));\n  callback(property, value, cbinfo);\n}\n\ntypedef void (*NativeSetter)\n    (v8::Local<v8::String>, v8::Local<v8::Value>, const v8::AccessorInfo &);\n\nstatic\nv8::Handle<v8::Value> PropertyGetterCallbackWrapper(\n    v8::Local<v8::String> property, const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  PropertyGetterCallback callback = reinterpret_cast<PropertyGetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyGetterIndex)\n              .As<v8::External>()->Value()));\n  callback(property, cbinfo);\n  return ReturnValueImp<v8::Value>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Value> (*NativePropertyGetter)\n    (v8::Local<v8::String>, const v8::AccessorInfo &);\n\nstatic\nv8::Handle<v8::Value> PropertySetterCallbackWrapper(\n    v8::Local<v8::String> property\n  , v8::Local<v8::Value> value\n  , const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  PropertySetterCallback callback = reinterpret_cast<PropertySetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertySetterIndex)\n              .As<v8::External>()->Value()));\n  callback(property, value, cbinfo);\n  return ReturnValueImp<v8::Value>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Value> (*NativePropertySetter)\n    (v8::Local<v8::String>, v8::Local<v8::Value>, const v8::AccessorInfo &);\n\nstatic\nv8::Handle<v8::Array> PropertyEnumeratorCallbackWrapper(\n    const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Array>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  PropertyEnumeratorCallback callback =\n      reinterpret_cast<PropertyEnumeratorCallback>(reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyEnumeratorIndex)\n              .As<v8::External>()->Value()));\n  callback(cbinfo);\n  return ReturnValueImp<v8::Array>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Array> (*NativePropertyEnumerator)\n    (const v8::AccessorInfo &);\n\nstatic\nv8::Handle<v8::Boolean> PropertyDeleterCallbackWrapper(\n    v8::Local<v8::String> property\n  , const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Boolean>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  PropertyDeleterCallback callback = reinterpret_cast<PropertyDeleterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyDeleterIndex)\n              .As<v8::External>()->Value()));\n  callback(property, cbinfo);\n  return ReturnValueImp<v8::Boolean>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Boolean> (NativePropertyDeleter)\n    (v8::Local<v8::String>, const v8::AccessorInfo &);\n\nstatic\nv8::Handle<v8::Integer> PropertyQueryCallbackWrapper(\n    v8::Local<v8::String> property, const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Integer>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  PropertyQueryCallback callback = reinterpret_cast<PropertyQueryCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kPropertyQueryIndex)\n              .As<v8::External>()->Value()));\n  callback(property, cbinfo);\n  return ReturnValueImp<v8::Integer>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Integer> (*NativePropertyQuery)\n    (v8::Local<v8::String>, const v8::AccessorInfo &);\n\nstatic\nv8::Handle<v8::Value> IndexGetterCallbackWrapper(\n    uint32_t index, const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  IndexGetterCallback callback = reinterpret_cast<IndexGetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertyGetterIndex)\n              .As<v8::External>()->Value()));\n  callback(index, cbinfo);\n  return ReturnValueImp<v8::Value>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Value> (*NativeIndexGetter)\n    (uint32_t, const v8::AccessorInfo &);\n\nstatic\nv8::Handle<v8::Value> IndexSetterCallbackWrapper(\n    uint32_t index\n  , v8::Local<v8::Value> value\n  , const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Value>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  IndexSetterCallback callback = reinterpret_cast<IndexSetterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertySetterIndex)\n              .As<v8::External>()->Value()));\n  callback(index, value, cbinfo);\n  return ReturnValueImp<v8::Value>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Value> (*NativeIndexSetter)\n    (uint32_t, v8::Local<v8::Value>, const v8::AccessorInfo &);\n\nstatic\nv8::Handle<v8::Array> IndexEnumeratorCallbackWrapper(\n    const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Array>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  IndexEnumeratorCallback callback = reinterpret_cast<IndexEnumeratorCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertyEnumeratorIndex)\n              .As<v8::External>()->Value()));\n  callback(cbinfo);\n  return ReturnValueImp<v8::Array>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Array> (*NativeIndexEnumerator)\n    (const v8::AccessorInfo &);\n\nstatic\nv8::Handle<v8::Boolean> IndexDeleterCallbackWrapper(\n    uint32_t index, const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Boolean>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  IndexDeleterCallback callback = reinterpret_cast<IndexDeleterCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertyDeleterIndex)\n              .As<v8::External>()->Value()));\n  callback(index, cbinfo);\n  return ReturnValueImp<v8::Boolean>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Boolean> (*NativeIndexDeleter)\n    (uint32_t, const v8::AccessorInfo &);\n\nstatic\nv8::Handle<v8::Integer> IndexQueryCallbackWrapper(\n    uint32_t index, const v8::AccessorInfo &info) {\n  v8::Local<v8::Object> obj = info.Data().As<v8::Object>();\n  PropertyCallbackInfo<v8::Integer>\n      cbinfo(info, obj->GetInternalField(kDataIndex));\n  IndexQueryCallback callback = reinterpret_cast<IndexQueryCallback>(\n      reinterpret_cast<intptr_t>(\n          obj->GetInternalField(kIndexPropertyQueryIndex)\n              .As<v8::External>()->Value()));\n  callback(index, cbinfo);\n  return ReturnValueImp<v8::Integer>(cbinfo.GetReturnValue()).Value();\n}\n\ntypedef v8::Handle<v8::Integer> (*NativeIndexQuery)\n    (uint32_t, const v8::AccessorInfo &);\n}  // end of namespace imp\n\n#endif  // NAN_CALLBACKS_PRE_12_INL_H_\n"
        },
        {
          "name": "nan_converters.h",
          "type": "blob",
          "size": 2.0595703125,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_CONVERTERS_H_\n#define NAN_CONVERTERS_H_\n\nnamespace imp {\ntemplate<typename T> struct ToFactoryBase {\n  typedef MaybeLocal<T> return_t;\n};\ntemplate<typename T> struct ValueFactoryBase { typedef Maybe<T> return_t; };\n\ntemplate<typename T> struct ToFactory;\n\ntemplate<>\nstruct ToFactory<v8::Function> : ToFactoryBase<v8::Function> {\n  static inline return_t convert(v8::Local<v8::Value> val) {\n    if (val.IsEmpty() || !val->IsFunction()) return MaybeLocal<v8::Function>();\n    return MaybeLocal<v8::Function>(val.As<v8::Function>());\n  }\n};\n\n#define X(TYPE)                                                                \\\n    template<>                                                                 \\\n    struct ToFactory<v8::TYPE> : ToFactoryBase<v8::TYPE> {                     \\\n      static inline return_t convert(v8::Local<v8::Value> val);                \\\n    };\n\nX(Boolean)\nX(Number)\nX(String)\nX(Object)\nX(Integer)\nX(Uint32)\nX(Int32)\n\n#undef X\n\n#define X(TYPE)                                                                \\\n    template<>                                                                 \\\n    struct ToFactory<TYPE> : ValueFactoryBase<TYPE> {                          \\\n      static inline return_t convert(v8::Local<v8::Value> val);                \\\n    };\n\nX(bool)\nX(double)\nX(int64_t)\nX(uint32_t)\nX(int32_t)\n\n#undef X\n}  // end of namespace imp\n\ntemplate<typename T>\ninline\ntypename imp::ToFactory<T>::return_t To(v8::Local<v8::Value> val) {\n  return imp::ToFactory<T>::convert(val);\n}\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n# include \"nan_converters_43_inl.h\"\n#else\n# include \"nan_converters_pre_43_inl.h\"\n#endif\n\n#endif  // NAN_CONVERTERS_H_\n"
        },
        {
          "name": "nan_converters_43_inl.h",
          "type": "blob",
          "size": 2.68359375,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_CONVERTERS_43_INL_H_\n#define NAN_CONVERTERS_43_INL_H_\n\n#define X(TYPE)                                                                \\\nimp::ToFactory<v8::TYPE>::return_t                                             \\\nimp::ToFactory<v8::TYPE>::convert(v8::Local<v8::Value> val) {                  \\\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();                            \\\n  v8::EscapableHandleScope scope(isolate);                                     \\\n  return scope.Escape(                                                         \\\n      val->To ## TYPE(isolate->GetCurrentContext())                            \\\n          .FromMaybe(v8::Local<v8::TYPE>()));                                  \\\n}\n\nX(Number)\nX(String)\nX(Object)\nX(Integer)\nX(Uint32)\nX(Int32)\n// V8 <= 7.0\n#if V8_MAJOR_VERSION < 7 || (V8_MAJOR_VERSION == 7 && V8_MINOR_VERSION == 0)\nX(Boolean)\n#else\nimp::ToFactory<v8::Boolean>::return_t                                          \\\nimp::ToFactory<v8::Boolean>::convert(v8::Local<v8::Value> val) {               \\\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();                            \\\n  v8::EscapableHandleScope scope(isolate);                                     \\\n  return scope.Escape(val->ToBoolean(isolate));                                \\\n}\n#endif\n\n#undef X\n\n#define X(TYPE, NAME)                                                          \\\nimp::ToFactory<TYPE>::return_t                                                 \\\nimp::ToFactory<TYPE>::convert(v8::Local<v8::Value> val) {                      \\\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();                            \\\n  v8::HandleScope scope(isolate);                                              \\\n  return val->NAME ## Value(isolate->GetCurrentContext());                     \\\n}\n\nX(double, Number)\nX(int64_t, Integer)\nX(uint32_t, Uint32)\nX(int32_t, Int32)\n// V8 <= 7.0\n#if V8_MAJOR_VERSION < 7 || (V8_MAJOR_VERSION == 7 && V8_MINOR_VERSION == 0)\nX(bool, Boolean)\n#else\nimp::ToFactory<bool>::return_t                                                 \\\nimp::ToFactory<bool>::convert(v8::Local<v8::Value> val) {                      \\\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();                            \\\n  v8::HandleScope scope(isolate);                                              \\\n  return Just<bool>(val->BooleanValue(isolate));                               \\\n}\n#endif\n\n#undef X\n\n#endif  // NAN_CONVERTERS_43_INL_H_\n"
        },
        {
          "name": "nan_converters_pre_43_inl.h",
          "type": "blob",
          "size": 1.224609375,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_CONVERTERS_PRE_43_INL_H_\n#define NAN_CONVERTERS_PRE_43_INL_H_\n\n#define X(TYPE)                                                                \\\nimp::ToFactory<v8::TYPE>::return_t                                             \\\nimp::ToFactory<v8::TYPE>::convert(v8::Local<v8::Value> val) {                  \\\n  return val->To ## TYPE();                                                    \\\n}\n\nX(Boolean)\nX(Number)\nX(String)\nX(Object)\nX(Integer)\nX(Uint32)\nX(Int32)\n\n#undef X\n\n#define X(TYPE, NAME)                                                          \\\nimp::ToFactory<TYPE>::return_t                                                 \\\nimp::ToFactory<TYPE>::convert(v8::Local<v8::Value> val) {                      \\\n  return Just(val->NAME ## Value());                                           \\\n}\n\nX(bool, Boolean)\nX(double, Number)\nX(int64_t, Integer)\nX(uint32_t, Uint32)\nX(int32_t, Int32)\n\n#undef X\n\n#endif  // NAN_CONVERTERS_PRE_43_INL_H_\n"
        },
        {
          "name": "nan_define_own_property_helper.h",
          "type": "blob",
          "size": 1.0029296875,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_DEFINE_OWN_PROPERTY_HELPER_H_\n#define NAN_DEFINE_OWN_PROPERTY_HELPER_H_\n\nnamespace imp {\n\ninline Maybe<bool> DefineOwnPropertyHelper(\n    v8::PropertyAttribute current\n  , v8::Handle<v8::Object> obj\n  , v8::Handle<v8::String> key\n  , v8::Handle<v8::Value> value\n  , v8::PropertyAttribute attribs = v8::None) {\n  return !(current & v8::DontDelete) ||                     // configurable OR\n                  (!(current & v8::ReadOnly) &&             // writable AND\n                   !((attribs ^ current) & ~v8::ReadOnly))  // same excluding RO\n             ? Just<bool>(obj->ForceSet(key, value, attribs))\n             : Nothing<bool>();\n}\n\n}  // end of namespace imp\n\n#endif  // NAN_DEFINE_OWN_PROPERTY_HELPER_H_\n"
        },
        {
          "name": "nan_implementation_12_inl.h",
          "type": "blob",
          "size": 14.701171875,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_IMPLEMENTATION_12_INL_H_\n#define NAN_IMPLEMENTATION_12_INL_H_\n//==============================================================================\n// node v0.11 implementation\n//==============================================================================\n\nnamespace imp {\n\n//=== Array ====================================================================\n\nFactory<v8::Array>::return_t\nFactory<v8::Array>::New() {\n  return v8::Array::New(v8::Isolate::GetCurrent());\n}\n\nFactory<v8::Array>::return_t\nFactory<v8::Array>::New(int length) {\n  return v8::Array::New(v8::Isolate::GetCurrent(), length);\n}\n\n//=== Boolean ==================================================================\n\nFactory<v8::Boolean>::return_t\nFactory<v8::Boolean>::New(bool value) {\n  return v8::Boolean::New(v8::Isolate::GetCurrent(), value);\n}\n\n//=== Boolean Object ===========================================================\n\nFactory<v8::BooleanObject>::return_t\nFactory<v8::BooleanObject>::New(bool value) {\n#if (NODE_MODULE_VERSION >= NODE_6_0_MODULE_VERSION)\n  return v8::BooleanObject::New(\n    v8::Isolate::GetCurrent(), value).As<v8::BooleanObject>();\n#else\n  return v8::BooleanObject::New(value).As<v8::BooleanObject>();\n#endif\n}\n\n//=== Context ==================================================================\n\nFactory<v8::Context>::return_t\nFactory<v8::Context>::New( v8::ExtensionConfiguration* extensions\n                         , v8::Local<v8::ObjectTemplate> tmpl\n                         , v8::Local<v8::Value> obj) {\n  return v8::Context::New(v8::Isolate::GetCurrent(), extensions, tmpl, obj);\n}\n\n//=== Date =====================================================================\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\nFactory<v8::Date>::return_t\nFactory<v8::Date>::New(double value) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(v8::Date::New(isolate->GetCurrentContext(), value)\n      .FromMaybe(v8::Local<v8::Value>()).As<v8::Date>());\n}\n#else\nFactory<v8::Date>::return_t\nFactory<v8::Date>::New(double value) {\n  return v8::Date::New(v8::Isolate::GetCurrent(), value).As<v8::Date>();\n}\n#endif\n\n//=== External =================================================================\n\nFactory<v8::External>::return_t\nFactory<v8::External>::New(void * value) {\n  return v8::External::New(v8::Isolate::GetCurrent(), value);\n}\n\n//=== Function =================================================================\n\nFactory<v8::Function>::return_t\nFactory<v8::Function>::New( FunctionCallback callback\n                          , v8::Local<v8::Value> data) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  v8::Local<v8::ObjectTemplate> tpl = v8::ObjectTemplate::New(isolate);\n  tpl->SetInternalFieldCount(imp::kFunctionFieldCount);\n  v8::Local<v8::Object> obj = NewInstance(tpl).ToLocalChecked();\n\n  obj->SetInternalField(\n      imp::kFunctionIndex\n    , v8::External::New(isolate, reinterpret_cast<void *>(callback)));\n\n  v8::Local<v8::Value> val = v8::Local<v8::Value>::New(isolate, data);\n\n  if (!val.IsEmpty()) {\n    obj->SetInternalField(imp::kDataIndex, val);\n  }\n\n#if NODE_MAJOR_VERSION >= 10\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n  v8::Local<v8::Function> function =\n      v8::Function::New(context, imp::FunctionCallbackWrapper, obj)\n      .ToLocalChecked();\n#else\n  v8::Local<v8::Function> function =\n      v8::Function::New(isolate, imp::FunctionCallbackWrapper, obj);\n#endif\n\n  return scope.Escape(function);\n}\n\n//=== Function Template ========================================================\n\nFactory<v8::FunctionTemplate>::return_t\nFactory<v8::FunctionTemplate>::New( FunctionCallback callback\n                                  , v8::Local<v8::Value> data\n                                  , v8::Local<v8::Signature> signature) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  if (callback) {\n    v8::EscapableHandleScope scope(isolate);\n    v8::Local<v8::ObjectTemplate> tpl = v8::ObjectTemplate::New(isolate);\n    tpl->SetInternalFieldCount(imp::kFunctionFieldCount);\n    v8::Local<v8::Object> obj = NewInstance(tpl).ToLocalChecked();\n\n    obj->SetInternalField(\n        imp::kFunctionIndex\n      , v8::External::New(isolate, reinterpret_cast<void *>(callback)));\n    v8::Local<v8::Value> val = v8::Local<v8::Value>::New(isolate, data);\n\n    if (!val.IsEmpty()) {\n      obj->SetInternalField(imp::kDataIndex, val);\n    }\n\n    return scope.Escape(v8::FunctionTemplate::New( isolate\n                                    , imp::FunctionCallbackWrapper\n                                    , obj\n                                    , signature));\n  } else {\n    return v8::FunctionTemplate::New(isolate, 0, data, signature);\n  }\n}\n\n//=== Number ===================================================================\n\nFactory<v8::Number>::return_t\nFactory<v8::Number>::New(double value) {\n  return v8::Number::New(v8::Isolate::GetCurrent(), value);\n}\n\n//=== Number Object ============================================================\n\nFactory<v8::NumberObject>::return_t\nFactory<v8::NumberObject>::New(double value) {\n  return v8::NumberObject::New( v8::Isolate::GetCurrent()\n                              , value).As<v8::NumberObject>();\n}\n\n//=== Integer, Int32 and Uint32 ================================================\n\ntemplate <typename T>\ntypename IntegerFactory<T>::return_t\nIntegerFactory<T>::New(int32_t value) {\n  return To<T>(T::New(v8::Isolate::GetCurrent(), value));\n}\n\ntemplate <typename T>\ntypename IntegerFactory<T>::return_t\nIntegerFactory<T>::New(uint32_t value) {\n  return To<T>(T::NewFromUnsigned(v8::Isolate::GetCurrent(), value));\n}\n\nFactory<v8::Uint32>::return_t\nFactory<v8::Uint32>::New(int32_t value) {\n  return To<v8::Uint32>(\n      v8::Uint32::NewFromUnsigned(v8::Isolate::GetCurrent(), value));\n}\n\nFactory<v8::Uint32>::return_t\nFactory<v8::Uint32>::New(uint32_t value) {\n  return To<v8::Uint32>(\n      v8::Uint32::NewFromUnsigned(v8::Isolate::GetCurrent(), value));\n}\n\n//=== Object ===================================================================\n\nFactory<v8::Object>::return_t\nFactory<v8::Object>::New() {\n  return v8::Object::New(v8::Isolate::GetCurrent());\n}\n\n//=== Object Template ==========================================================\n\nFactory<v8::ObjectTemplate>::return_t\nFactory<v8::ObjectTemplate>::New() {\n  return v8::ObjectTemplate::New(v8::Isolate::GetCurrent());\n}\n\n//=== RegExp ===================================================================\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\nFactory<v8::RegExp>::return_t\nFactory<v8::RegExp>::New(\n    v8::Local<v8::String> pattern\n  , v8::RegExp::Flags flags) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(\n      v8::RegExp::New(isolate->GetCurrentContext(), pattern, flags)\n          .FromMaybe(v8::Local<v8::RegExp>()));\n}\n#else\nFactory<v8::RegExp>::return_t\nFactory<v8::RegExp>::New(\n    v8::Local<v8::String> pattern\n  , v8::RegExp::Flags flags) {\n  return v8::RegExp::New(pattern, flags);\n}\n#endif\n\n//=== Script ===================================================================\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\nFactory<v8::Script>::return_t\nFactory<v8::Script>::New( v8::Local<v8::String> source) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  v8::ScriptCompiler::Source src(source);\n  return scope.Escape(\n      v8::ScriptCompiler::Compile(isolate->GetCurrentContext(), &src)\n          .FromMaybe(v8::Local<v8::Script>()));\n}\n\nFactory<v8::Script>::return_t\nFactory<v8::Script>::New( v8::Local<v8::String> source\n                        , v8::ScriptOrigin const& origin) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  v8::ScriptCompiler::Source src(source, origin);\n  return scope.Escape(\n      v8::ScriptCompiler::Compile(isolate->GetCurrentContext(), &src)\n          .FromMaybe(v8::Local<v8::Script>()));\n}\n#else\nFactory<v8::Script>::return_t\nFactory<v8::Script>::New( v8::Local<v8::String> source) {\n  v8::ScriptCompiler::Source src(source);\n  return v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &src);\n}\n\nFactory<v8::Script>::return_t\nFactory<v8::Script>::New( v8::Local<v8::String> source\n                        , v8::ScriptOrigin const& origin) {\n  v8::ScriptCompiler::Source src(source, origin);\n  return v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &src);\n}\n#endif\n\n//=== Signature ================================================================\n\nFactory<v8::Signature>::return_t\nFactory<v8::Signature>::New(Factory<v8::Signature>::FTH receiver) {\n  return v8::Signature::New(v8::Isolate::GetCurrent(), receiver);\n}\n\n//=== String ===================================================================\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New() {\n  return v8::String::Empty(v8::Isolate::GetCurrent());\n}\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\nFactory<v8::String>::return_t\nFactory<v8::String>::New(const char * value, int length) {\n  return v8::String::NewFromUtf8(\n      v8::Isolate::GetCurrent(), value, v8::NewStringType::kNormal, length);\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(std::string const& value) {\n  assert(value.size() <= INT_MAX && \"string too long\");\n  return v8::String::NewFromUtf8(v8::Isolate::GetCurrent(),\n      value.data(), v8::NewStringType::kNormal, static_cast<int>(value.size()));\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(const uint16_t * value, int length) {\n  return v8::String::NewFromTwoByte(v8::Isolate::GetCurrent(), value,\n        v8::NewStringType::kNormal, length);\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(v8::String::ExternalStringResource * value) {\n  return v8::String::NewExternalTwoByte(v8::Isolate::GetCurrent(), value);\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(ExternalOneByteStringResource * value) {\n  return v8::String::NewExternalOneByte(v8::Isolate::GetCurrent(), value);\n}\n#else\nFactory<v8::String>::return_t\nFactory<v8::String>::New(const char * value, int length) {\n  return v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), value,\n                                 v8::String::kNormalString, length);\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(\n    std::string const& value) /* NOLINT(build/include_what_you_use) */ {\n  assert(value.size() <= INT_MAX && \"string too long\");\n  return v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), value.data(),\n                                 v8::String::kNormalString,\n                                 static_cast<int>(value.size()));\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(const uint16_t * value, int length) {\n  return v8::String::NewFromTwoByte(v8::Isolate::GetCurrent(), value,\n                                    v8::String::kNormalString, length);\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(v8::String::ExternalStringResource * value) {\n  return v8::String::NewExternal(v8::Isolate::GetCurrent(), value);\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(ExternalOneByteStringResource * value) {\n  return v8::String::NewExternal(v8::Isolate::GetCurrent(), value);\n}\n#endif\n\n//=== String Object ============================================================\n\n// See https://github.com/nodejs/nan/pull/811#discussion_r224594980.\n// Disable the warning as there is no way around it.\n// TODO(bnoordhuis) Use isolate-based version in Node.js v12.\nFactory<v8::StringObject>::return_t\nFactory<v8::StringObject>::New(v8::Local<v8::String> value) {\n// V8 > 7.0\n#if V8_MAJOR_VERSION > 7 || (V8_MAJOR_VERSION == 7 && V8_MINOR_VERSION > 0)\n  return v8::StringObject::New(v8::Isolate::GetCurrent(), value)\n      .As<v8::StringObject>();\n#else\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable : 4996)\n#endif\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n  return v8::StringObject::New(value).As<v8::StringObject>();\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n#endif\n}\n\n//=== Unbound Script ===========================================================\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\nFactory<v8::UnboundScript>::return_t\nFactory<v8::UnboundScript>::New(v8::Local<v8::String> source) {\n  v8::ScriptCompiler::Source src(source);\n  return v8::ScriptCompiler::CompileUnboundScript(\n      v8::Isolate::GetCurrent(), &src);\n}\n\nFactory<v8::UnboundScript>::return_t\nFactory<v8::UnboundScript>::New( v8::Local<v8::String> source\n                               , v8::ScriptOrigin const& origin) {\n  v8::ScriptCompiler::Source src(source, origin);\n  return v8::ScriptCompiler::CompileUnboundScript(\n      v8::Isolate::GetCurrent(), &src);\n}\n#else\nFactory<v8::UnboundScript>::return_t\nFactory<v8::UnboundScript>::New(v8::Local<v8::String> source) {\n  v8::ScriptCompiler::Source src(source);\n  return v8::ScriptCompiler::CompileUnbound(v8::Isolate::GetCurrent(), &src);\n}\n\nFactory<v8::UnboundScript>::return_t\nFactory<v8::UnboundScript>::New( v8::Local<v8::String> source\n                               , v8::ScriptOrigin const& origin) {\n  v8::ScriptCompiler::Source src(source, origin);\n  return v8::ScriptCompiler::CompileUnbound(v8::Isolate::GetCurrent(), &src);\n}\n#endif\n\n}  // end of namespace imp\n\n//=== Presistents and Handles ==================================================\n\n#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\ntemplate <typename T>\ninline v8::Local<T> New(v8::Handle<T> h) {\n  return v8::Local<T>::New(v8::Isolate::GetCurrent(), h);\n}\n#endif\n\ntemplate <typename T, typename M>\ninline v8::Local<T> New(v8::Persistent<T, M> const& p) {\n  return v8::Local<T>::New(v8::Isolate::GetCurrent(), p);\n}\n\ntemplate <typename T, typename M>\ninline v8::Local<T> New(Persistent<T, M> const& p) {\n  return v8::Local<T>::New(v8::Isolate::GetCurrent(), p);\n}\n\ntemplate <typename T>\ninline v8::Local<T> New(Global<T> const& p) {\n  return v8::Local<T>::New(v8::Isolate::GetCurrent(), p);\n}\n\n#endif  // NAN_IMPLEMENTATION_12_INL_H_\n"
        },
        {
          "name": "nan_implementation_pre_12_inl.h",
          "type": "blob",
          "size": 7.7568359375,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_IMPLEMENTATION_PRE_12_INL_H_\n#define NAN_IMPLEMENTATION_PRE_12_INL_H_\n\n//==============================================================================\n// node v0.10 implementation\n//==============================================================================\n\nnamespace imp {\n\n//=== Array ====================================================================\n\nFactory<v8::Array>::return_t\nFactory<v8::Array>::New() {\n  return v8::Array::New();\n}\n\nFactory<v8::Array>::return_t\nFactory<v8::Array>::New(int length) {\n  return v8::Array::New(length);\n}\n\n//=== Boolean ==================================================================\n\nFactory<v8::Boolean>::return_t\nFactory<v8::Boolean>::New(bool value) {\n  return v8::Boolean::New(value)->ToBoolean();\n}\n\n//=== Boolean Object ===========================================================\n\nFactory<v8::BooleanObject>::return_t\nFactory<v8::BooleanObject>::New(bool value) {\n  return v8::BooleanObject::New(value).As<v8::BooleanObject>();\n}\n\n//=== Context ==================================================================\n\nFactory<v8::Context>::return_t\nFactory<v8::Context>::New( v8::ExtensionConfiguration* extensions\n                         , v8::Local<v8::ObjectTemplate> tmpl\n                         , v8::Local<v8::Value> obj) {\n  v8::Persistent<v8::Context> ctx = v8::Context::New(extensions, tmpl, obj);\n  v8::Local<v8::Context> lctx = v8::Local<v8::Context>::New(ctx);\n  ctx.Dispose();\n  return lctx;\n}\n\n//=== Date =====================================================================\n\nFactory<v8::Date>::return_t\nFactory<v8::Date>::New(double value) {\n  return v8::Date::New(value).As<v8::Date>();\n}\n\n//=== External =================================================================\n\nFactory<v8::External>::return_t\nFactory<v8::External>::New(void * value) {\n  return v8::External::New(value);\n}\n\n//=== Function =================================================================\n\nFactory<v8::Function>::return_t\nFactory<v8::Function>::New( FunctionCallback callback\n                          , v8::Local<v8::Value> data) {\n  v8::HandleScope scope;\n\n  return scope.Close(Factory<v8::FunctionTemplate>::New(\n                         callback, data, v8::Local<v8::Signature>())\n                         ->GetFunction());\n}\n\n\n//=== FunctionTemplate =========================================================\n\nFactory<v8::FunctionTemplate>::return_t\nFactory<v8::FunctionTemplate>::New( FunctionCallback callback\n                                  , v8::Local<v8::Value> data\n                                  , v8::Local<v8::Signature> signature) {\n  if (callback) {\n    v8::HandleScope scope;\n\n    v8::Local<v8::ObjectTemplate> tpl = v8::ObjectTemplate::New();\n    tpl->SetInternalFieldCount(imp::kFunctionFieldCount);\n    v8::Local<v8::Object> obj = tpl->NewInstance();\n\n    obj->SetInternalField(\n        imp::kFunctionIndex\n      , v8::External::New(reinterpret_cast<void *>(callback)));\n\n    v8::Local<v8::Value> val = v8::Local<v8::Value>::New(data);\n\n    if (!val.IsEmpty()) {\n      obj->SetInternalField(imp::kDataIndex, val);\n    }\n\n    // Note(agnat): Emulate length argument here. Unfortunately, I couldn't find\n    // a way. Have at it though...\n    return scope.Close(\n        v8::FunctionTemplate::New(imp::FunctionCallbackWrapper\n                                 , obj\n                                 , signature));\n  } else {\n    return v8::FunctionTemplate::New(0, data, signature);\n  }\n}\n\n//=== Number ===================================================================\n\nFactory<v8::Number>::return_t\nFactory<v8::Number>::New(double value) {\n  return v8::Number::New(value);\n}\n\n//=== Number Object ============================================================\n\nFactory<v8::NumberObject>::return_t\nFactory<v8::NumberObject>::New(double value) {\n  return v8::NumberObject::New(value).As<v8::NumberObject>();\n}\n\n//=== Integer, Int32 and Uint32 ================================================\n\ntemplate <typename T>\ntypename IntegerFactory<T>::return_t\nIntegerFactory<T>::New(int32_t value) {\n  return To<T>(T::New(value));\n}\n\ntemplate <typename T>\ntypename IntegerFactory<T>::return_t\nIntegerFactory<T>::New(uint32_t value) {\n  return To<T>(T::NewFromUnsigned(value));\n}\n\nFactory<v8::Uint32>::return_t\nFactory<v8::Uint32>::New(int32_t value) {\n  return To<v8::Uint32>(v8::Uint32::NewFromUnsigned(value));\n}\n\nFactory<v8::Uint32>::return_t\nFactory<v8::Uint32>::New(uint32_t value) {\n  return To<v8::Uint32>(v8::Uint32::NewFromUnsigned(value));\n}\n\n\n//=== Object ===================================================================\n\nFactory<v8::Object>::return_t\nFactory<v8::Object>::New() {\n  return v8::Object::New();\n}\n\n//=== Object Template ==========================================================\n\nFactory<v8::ObjectTemplate>::return_t\nFactory<v8::ObjectTemplate>::New() {\n  return v8::ObjectTemplate::New();\n}\n\n//=== RegExp ===================================================================\n\nFactory<v8::RegExp>::return_t\nFactory<v8::RegExp>::New(\n    v8::Local<v8::String> pattern\n  , v8::RegExp::Flags flags) {\n  return v8::RegExp::New(pattern, flags);\n}\n\n//=== Script ===================================================================\n\nFactory<v8::Script>::return_t\nFactory<v8::Script>::New( v8::Local<v8::String> source) {\n  return v8::Script::New(source);\n}\nFactory<v8::Script>::return_t\nFactory<v8::Script>::New( v8::Local<v8::String> source\n                        , v8::ScriptOrigin const& origin) {\n  return v8::Script::New(source, const_cast<v8::ScriptOrigin*>(&origin));\n}\n\n//=== Signature ================================================================\n\nFactory<v8::Signature>::return_t\nFactory<v8::Signature>::New(Factory<v8::Signature>::FTH receiver) {\n  return v8::Signature::New(receiver);\n}\n\n//=== String ===================================================================\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New() {\n  return v8::String::Empty();\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(const char * value, int length) {\n  return v8::String::New(value, length);\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(\n    std::string const& value) /* NOLINT(build/include_what_you_use) */ {\n  assert(value.size() <= INT_MAX && \"string too long\");\n  return v8::String::New(value.data(), static_cast<int>(value.size()));\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(const uint16_t * value, int length) {\n  return v8::String::New(value, length);\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(v8::String::ExternalStringResource * value) {\n  return v8::String::NewExternal(value);\n}\n\nFactory<v8::String>::return_t\nFactory<v8::String>::New(v8::String::ExternalAsciiStringResource * value) {\n  return v8::String::NewExternal(value);\n}\n\n//=== String Object ============================================================\n\nFactory<v8::StringObject>::return_t\nFactory<v8::StringObject>::New(v8::Local<v8::String> value) {\n  return v8::StringObject::New(value).As<v8::StringObject>();\n}\n\n}  // end of namespace imp\n\n//=== Presistents and Handles ==================================================\n\ntemplate <typename T>\ninline v8::Local<T> New(v8::Handle<T> h) {\n  return v8::Local<T>::New(h);\n}\n\ntemplate <typename T>\ninline v8::Local<T> New(v8::Persistent<T> const& p) {\n  return v8::Local<T>::New(p);\n}\n\ntemplate <typename T, typename M>\ninline v8::Local<T> New(Persistent<T, M> const& p) {\n  return v8::Local<T>::New(p.persistent);\n}\n\ntemplate <typename T>\ninline v8::Local<T> New(Global<T> const& p) {\n  return v8::Local<T>::New(p.persistent);\n}\n\n#endif  // NAN_IMPLEMENTATION_PRE_12_INL_H_\n"
        },
        {
          "name": "nan_json.h",
          "type": "blob",
          "size": 5.63671875,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_JSON_H_\n#define NAN_JSON_H_\n\n#if NODE_MODULE_VERSION < NODE_0_12_MODULE_VERSION\n#define NAN_JSON_H_NEED_PARSE 1\n#else\n#define NAN_JSON_H_NEED_PARSE 0\n#endif  // NODE_MODULE_VERSION < NODE_0_12_MODULE_VERSION\n\n#if NODE_MODULE_VERSION >= NODE_7_0_MODULE_VERSION\n#define NAN_JSON_H_NEED_STRINGIFY 0\n#else\n#define NAN_JSON_H_NEED_STRINGIFY 1\n#endif  // NODE_MODULE_VERSION >= NODE_7_0_MODULE_VERSION\n\nclass JSON {\n public:\n  JSON() {\n#if NAN_JSON_H_NEED_PARSE + NAN_JSON_H_NEED_STRINGIFY\n    Nan::HandleScope scope;\n\n    Nan::MaybeLocal<v8::Value> maybe_global_json = Nan::Get(\n      Nan::GetCurrentContext()->Global(),\n      Nan::New(\"JSON\").ToLocalChecked()\n    );\n\n    assert(!maybe_global_json.IsEmpty() && \"global JSON is empty\");\n    v8::Local<v8::Value> val_global_json = maybe_global_json.ToLocalChecked();\n\n    assert(val_global_json->IsObject() && \"global JSON is not an object\");\n    Nan::MaybeLocal<v8::Object> maybe_obj_global_json =\n      Nan::To<v8::Object>(val_global_json);\n\n    assert(!maybe_obj_global_json.IsEmpty() && \"global JSON object is empty\");\n    v8::Local<v8::Object> global_json = maybe_obj_global_json.ToLocalChecked();\n\n#if NAN_JSON_H_NEED_PARSE\n    Nan::MaybeLocal<v8::Value> maybe_parse_method = Nan::Get(\n      global_json, Nan::New(\"parse\").ToLocalChecked()\n    );\n\n    assert(!maybe_parse_method.IsEmpty() && \"JSON.parse is empty\");\n    v8::Local<v8::Value> parse_method = maybe_parse_method.ToLocalChecked();\n\n    assert(parse_method->IsFunction() && \"JSON.parse is not a function\");\n    parse_cb_.Reset(parse_method.As<v8::Function>());\n#endif  // NAN_JSON_H_NEED_PARSE\n\n#if NAN_JSON_H_NEED_STRINGIFY\n    Nan::MaybeLocal<v8::Value> maybe_stringify_method = Nan::Get(\n      global_json, Nan::New(\"stringify\").ToLocalChecked()\n    );\n\n    assert(!maybe_stringify_method.IsEmpty() && \"JSON.stringify is empty\");\n    v8::Local<v8::Value> stringify_method =\n      maybe_stringify_method.ToLocalChecked();\n\n    assert(\n      stringify_method->IsFunction() && \"JSON.stringify is not a function\"\n    );\n    stringify_cb_.Reset(stringify_method.As<v8::Function>());\n#endif  // NAN_JSON_H_NEED_STRINGIFY\n#endif  // NAN_JSON_H_NEED_PARSE + NAN_JSON_H_NEED_STRINGIFY\n  }\n\n  inline\n  Nan::MaybeLocal<v8::Value> Parse(v8::Local<v8::String> json_string) {\n    Nan::EscapableHandleScope scope;\n#if NAN_JSON_H_NEED_PARSE\n    return scope.Escape(parse(json_string));\n#else\n    Nan::MaybeLocal<v8::Value> result;\n#if NODE_MODULE_VERSION >= NODE_0_12_MODULE_VERSION && \\\n    NODE_MODULE_VERSION <= IOJS_2_0_MODULE_VERSION\n    result = v8::JSON::Parse(json_string);\n#else\n#if NODE_MODULE_VERSION > NODE_6_0_MODULE_VERSION\n    v8::Local<v8::Context> context_or_isolate = Nan::GetCurrentContext();\n#else\n    v8::Isolate* context_or_isolate = v8::Isolate::GetCurrent();\n#endif  // NODE_MODULE_VERSION > NODE_6_0_MODULE_VERSION\n    result = v8::JSON::Parse(context_or_isolate, json_string);\n#endif  // NODE_MODULE_VERSION >= NODE_0_12_MODULE_VERSION &&\n        // NODE_MODULE_VERSION <= IOJS_2_0_MODULE_VERSION\n    if (result.IsEmpty()) return v8::Local<v8::Value>();\n    return scope.Escape(result.ToLocalChecked());\n#endif  // NAN_JSON_H_NEED_PARSE\n  }\n\n  inline\n  Nan::MaybeLocal<v8::String> Stringify(v8::Local<v8::Object> json_object) {\n    Nan::EscapableHandleScope scope;\n    Nan::MaybeLocal<v8::String> result =\n#if NAN_JSON_H_NEED_STRINGIFY\n      Nan::To<v8::String>(stringify(json_object));\n#else\n      v8::JSON::Stringify(Nan::GetCurrentContext(), json_object);\n#endif  // NAN_JSON_H_NEED_STRINGIFY\n    if (result.IsEmpty()) return v8::Local<v8::String>();\n    return scope.Escape(result.ToLocalChecked());\n  }\n\n  inline\n  Nan::MaybeLocal<v8::String> Stringify(v8::Local<v8::Object> json_object,\n    v8::Local<v8::String> gap) {\n    Nan::EscapableHandleScope scope;\n    Nan::MaybeLocal<v8::String> result =\n#if NAN_JSON_H_NEED_STRINGIFY\n      Nan::To<v8::String>(stringify(json_object, gap));\n#else\n      v8::JSON::Stringify(Nan::GetCurrentContext(), json_object, gap);\n#endif  // NAN_JSON_H_NEED_STRINGIFY\n    if (result.IsEmpty()) return v8::Local<v8::String>();\n    return scope.Escape(result.ToLocalChecked());\n  }\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(JSON)\n#if NAN_JSON_H_NEED_PARSE\n  Nan::Callback parse_cb_;\n#endif  // NAN_JSON_H_NEED_PARSE\n#if NAN_JSON_H_NEED_STRINGIFY\n  Nan::Callback stringify_cb_;\n#endif  // NAN_JSON_H_NEED_STRINGIFY\n\n#if NAN_JSON_H_NEED_PARSE\n  inline v8::Local<v8::Value> parse(v8::Local<v8::Value> arg) {\n    assert(!parse_cb_.IsEmpty() && \"parse_cb_ is empty\");\n    AsyncResource resource(\"nan:JSON.parse\");\n    return parse_cb_.Call(1, &arg, &resource).FromMaybe(v8::Local<v8::Value>());\n  }\n#endif  // NAN_JSON_H_NEED_PARSE\n\n#if NAN_JSON_H_NEED_STRINGIFY\n  inline v8::Local<v8::Value> stringify(v8::Local<v8::Value> arg) {\n    assert(!stringify_cb_.IsEmpty() && \"stringify_cb_ is empty\");\n    AsyncResource resource(\"nan:JSON.stringify\");\n    return stringify_cb_.Call(1, &arg, &resource)\n        .FromMaybe(v8::Local<v8::Value>());\n  }\n\n  inline v8::Local<v8::Value> stringify(v8::Local<v8::Value> arg,\n    v8::Local<v8::String> gap) {\n    assert(!stringify_cb_.IsEmpty() && \"stringify_cb_ is empty\");\n\n    v8::Local<v8::Value> argv[] = {\n      arg,\n      Nan::Null(),\n      gap\n    };\n    AsyncResource resource(\"nan:JSON.stringify\");\n    return stringify_cb_.Call(3, argv, &resource)\n        .FromMaybe(v8::Local<v8::Value>());\n  }\n#endif  // NAN_JSON_H_NEED_STRINGIFY\n};\n\n#endif  // NAN_JSON_H_\n"
        },
        {
          "name": "nan_maybe_43_inl.h",
          "type": "blob",
          "size": 12.0849609375,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_MAYBE_43_INL_H_\n#define NAN_MAYBE_43_INL_H_\n\ntemplate<typename T>\nusing MaybeLocal = v8::MaybeLocal<T>;\n\ninline\nMaybeLocal<v8::String> ToDetailString(v8::Local<v8::Value> val) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(val->ToDetailString(isolate->GetCurrentContext())\n                          .FromMaybe(v8::Local<v8::String>()));\n}\n\ninline\nMaybeLocal<v8::Uint32> ToArrayIndex(v8::Local<v8::Value> val) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(val->ToArrayIndex(isolate->GetCurrentContext())\n                          .FromMaybe(v8::Local<v8::Uint32>()));\n}\n\ninline\nMaybe<bool> Equals(v8::Local<v8::Value> a, v8::Local<v8::Value>(b)) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return a->Equals(isolate->GetCurrentContext(), b);\n}\n\ninline\nMaybeLocal<v8::Object> NewInstance(v8::Local<v8::Function> h) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(h->NewInstance(isolate->GetCurrentContext())\n                          .FromMaybe(v8::Local<v8::Object>()));\n}\n\ninline\nMaybeLocal<v8::Object> NewInstance(\n      v8::Local<v8::Function> h\n    , int argc\n    , v8::Local<v8::Value> argv[]) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(h->NewInstance(isolate->GetCurrentContext(), argc, argv)\n                          .FromMaybe(v8::Local<v8::Object>()));\n}\n\ninline\nMaybeLocal<v8::Object> NewInstance(v8::Local<v8::ObjectTemplate> h) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(h->NewInstance(isolate->GetCurrentContext())\n                          .FromMaybe(v8::Local<v8::Object>()));\n}\n\n\ninline MaybeLocal<v8::Function> GetFunction(\n    v8::Local<v8::FunctionTemplate> t) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(t->GetFunction(isolate->GetCurrentContext())\n                          .FromMaybe(v8::Local<v8::Function>()));\n}\n\ninline Maybe<bool> Set(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::Value> key\n  , v8::Local<v8::Value> value) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->Set(isolate->GetCurrentContext(), key, value);\n}\n\ninline Maybe<bool> Set(\n    v8::Local<v8::Object> obj\n  , uint32_t index\n  , v8::Local<v8::Value> value) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->Set(isolate->GetCurrentContext(), index, value);\n}\n\n#if NODE_MODULE_VERSION < NODE_4_0_MODULE_VERSION\n#include \"nan_define_own_property_helper.h\"  // NOLINT(build/include)\n#endif\n\ninline Maybe<bool> DefineOwnProperty(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::String> key\n  , v8::Local<v8::Value> value\n  , v8::PropertyAttribute attribs = v8::None) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n#if NODE_MODULE_VERSION >= NODE_4_0_MODULE_VERSION\n  return obj->DefineOwnProperty(isolate->GetCurrentContext(), key, value,\n                                attribs);\n#else\n  Maybe<v8::PropertyAttribute> maybeCurrent =\n      obj->GetPropertyAttributes(isolate->GetCurrentContext(), key);\n  if (maybeCurrent.IsNothing()) {\n    return Nothing<bool>();\n  }\n  v8::PropertyAttribute current = maybeCurrent.FromJust();\n  return imp::DefineOwnPropertyHelper(current, obj, key, value, attribs);\n#endif\n}\n\nNAN_DEPRECATED inline Maybe<bool> ForceSet(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::Value> key\n  , v8::Local<v8::Value> value\n  , v8::PropertyAttribute attribs = v8::None) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n#if NODE_MODULE_VERSION >= NODE_9_0_MODULE_VERSION\n  return key->IsName()\n             ? obj->DefineOwnProperty(isolate->GetCurrentContext(),\n                                      key.As<v8::Name>(), value, attribs)\n             : Nothing<bool>();\n#else\n  return obj->ForceSet(isolate->GetCurrentContext(), key, value, attribs);\n#endif\n}\n\ninline MaybeLocal<v8::Value> Get(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::Value> key) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(obj->Get(isolate->GetCurrentContext(), key)\n                          .FromMaybe(v8::Local<v8::Value>()));\n}\n\ninline\nMaybeLocal<v8::Value> Get(v8::Local<v8::Object> obj, uint32_t index) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(obj->Get(isolate->GetCurrentContext(), index)\n                          .FromMaybe(v8::Local<v8::Value>()));\n}\n\ninline v8::PropertyAttribute GetPropertyAttributes(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::Value> key) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->GetPropertyAttributes(isolate->GetCurrentContext(), key)\n      .FromJust();\n}\n\ninline Maybe<bool> Has(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::String> key) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->Has(isolate->GetCurrentContext(), key);\n}\n\ninline Maybe<bool> Has(v8::Local<v8::Object> obj, uint32_t index) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->Has(isolate->GetCurrentContext(), index);\n}\n\ninline Maybe<bool> Delete(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::String> key) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->Delete(isolate->GetCurrentContext(), key);\n}\n\ninline\nMaybe<bool> Delete(v8::Local<v8::Object> obj, uint32_t index) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->Delete(isolate->GetCurrentContext(), index);\n}\n\ninline\nMaybeLocal<v8::Array> GetPropertyNames(v8::Local<v8::Object> obj) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(obj->GetPropertyNames(isolate->GetCurrentContext())\n                          .FromMaybe(v8::Local<v8::Array>()));\n}\n\ninline\nMaybeLocal<v8::Array> GetOwnPropertyNames(v8::Local<v8::Object> obj) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(obj->GetOwnPropertyNames(isolate->GetCurrentContext())\n                          .FromMaybe(v8::Local<v8::Array>()));\n}\n\ninline Maybe<bool> SetPrototype(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::Value> prototype) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->SetPrototype(isolate->GetCurrentContext(), prototype);\n}\n\ninline MaybeLocal<v8::String> ObjectProtoToString(\n    v8::Local<v8::Object> obj) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(obj->ObjectProtoToString(isolate->GetCurrentContext())\n                          .FromMaybe(v8::Local<v8::String>()));\n}\n\ninline Maybe<bool> HasOwnProperty(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::String> key) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->HasOwnProperty(isolate->GetCurrentContext(), key);\n}\n\ninline Maybe<bool> HasRealNamedProperty(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::String> key) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->HasRealNamedProperty(isolate->GetCurrentContext(), key);\n}\n\ninline Maybe<bool> HasRealIndexedProperty(\n    v8::Local<v8::Object> obj\n  , uint32_t index) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->HasRealIndexedProperty(isolate->GetCurrentContext(), index);\n}\n\ninline Maybe<bool> HasRealNamedCallbackProperty(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::String> key) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return obj->HasRealNamedCallbackProperty(isolate->GetCurrentContext(), key);\n}\n\ninline MaybeLocal<v8::Value> GetRealNamedPropertyInPrototypeChain(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::String> key) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(obj->GetRealNamedPropertyInPrototypeChain(\n                             isolate->GetCurrentContext(), key)\n                          .FromMaybe(v8::Local<v8::Value>()));\n}\n\ninline MaybeLocal<v8::Value> GetRealNamedProperty(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::String> key) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(\n      obj->GetRealNamedProperty(isolate->GetCurrentContext(), key)\n          .FromMaybe(v8::Local<v8::Value>()));\n}\n\ninline MaybeLocal<v8::Value> CallAsFunction(\n    v8::Local<v8::Object> obj\n  , v8::Local<v8::Object> recv\n  , int argc\n  , v8::Local<v8::Value> argv[]) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(\n      obj->CallAsFunction(isolate->GetCurrentContext(), recv, argc, argv)\n          .FromMaybe(v8::Local<v8::Value>()));\n}\n\ninline MaybeLocal<v8::Value> CallAsConstructor(\n    v8::Local<v8::Object> obj\n  , int argc, v8::Local<v8::Value> argv[]) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(\n      obj->CallAsConstructor(isolate->GetCurrentContext(), argc, argv)\n          .FromMaybe(v8::Local<v8::Value>()));\n}\n\ninline\nMaybeLocal<v8::String> GetSourceLine(v8::Local<v8::Message> msg) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(msg->GetSourceLine(isolate->GetCurrentContext())\n                          .FromMaybe(v8::Local<v8::String>()));\n}\n\ninline Maybe<int> GetLineNumber(v8::Local<v8::Message> msg) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return msg->GetLineNumber(isolate->GetCurrentContext());\n}\n\ninline Maybe<int> GetStartColumn(v8::Local<v8::Message> msg) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return msg->GetStartColumn(isolate->GetCurrentContext());\n}\n\ninline Maybe<int> GetEndColumn(v8::Local<v8::Message> msg) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  return msg->GetEndColumn(isolate->GetCurrentContext());\n}\n\ninline MaybeLocal<v8::Object> CloneElementAt(\n    v8::Local<v8::Array> array\n  , uint32_t index) {\n#if (NODE_MODULE_VERSION >= NODE_6_0_MODULE_VERSION)\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n  v8::Local<v8::Value> elem;\n  v8::Local<v8::Object> obj;\n  if (!array->Get(context, index).ToLocal(&elem)) {\n    return scope.Escape(obj);\n  }\n  if (!elem->ToObject(context).ToLocal(&obj)) {\n    return scope.Escape(v8::Local<v8::Object>());\n  }\n  return scope.Escape(obj->Clone());\n#else\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(array->CloneElementAt(isolate->GetCurrentContext(), index)\n                          .FromMaybe(v8::Local<v8::Object>()));\n#endif\n}\n\ninline MaybeLocal<v8::Value> Call(\n    v8::Local<v8::Function> fun\n  , v8::Local<v8::Object> recv\n  , int argc\n  , v8::Local<v8::Value> argv[]) {\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  return scope.Escape(fun->Call(isolate->GetCurrentContext(), recv, argc, argv)\n                          .FromMaybe(v8::Local<v8::Value>()));\n}\n\n#endif  // NAN_MAYBE_43_INL_H_\n"
        },
        {
          "name": "nan_maybe_pre_43_inl.h",
          "type": "blob",
          "size": 6.9931640625,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_MAYBE_PRE_43_INL_H_\n#define NAN_MAYBE_PRE_43_INL_H_\n\ntemplate<typename T>\nclass MaybeLocal {\n public:\n  inline MaybeLocal() : val_(v8::Local<T>()) {}\n\n  template<typename S>\n# if NODE_MODULE_VERSION >= NODE_0_12_MODULE_VERSION\n  inline\n  MaybeLocal(v8::Local<S> that) : val_(that) {}  // NOLINT(runtime/explicit)\n# else\n  inline\n  MaybeLocal(v8::Local<S> that) :  // NOLINT(runtime/explicit)\n      val_(*reinterpret_cast<v8::Local<T>*>(&that)) {}\n# endif\n\n  inline bool IsEmpty() const { return val_.IsEmpty(); }\n\n  template<typename S>\n  inline bool ToLocal(v8::Local<S> *out) const {\n    *out = val_;\n    return !IsEmpty();\n  }\n\n  inline v8::Local<T> ToLocalChecked() const {\n#if defined(V8_ENABLE_CHECKS)\n    assert(!IsEmpty() && \"ToLocalChecked is Empty\");\n#endif  // V8_ENABLE_CHECKS\n    return val_;\n  }\n\n  template<typename S>\n  inline v8::Local<S> FromMaybe(v8::Local<S> default_value) const {\n    return IsEmpty() ? default_value : v8::Local<S>(val_);\n  }\n\n private:\n  v8::Local<T> val_;\n};\n\ninline\nMaybeLocal<v8::String> ToDetailString(v8::Handle<v8::Value> val) {\n  return MaybeLocal<v8::String>(val->ToDetailString());\n}\n\ninline\nMaybeLocal<v8::Uint32> ToArrayIndex(v8::Handle<v8::Value> val) {\n  return MaybeLocal<v8::Uint32>(val->ToArrayIndex());\n}\n\ninline\nMaybe<bool> Equals(v8::Handle<v8::Value> a, v8::Handle<v8::Value>(b)) {\n  return Just<bool>(a->Equals(b));\n}\n\ninline\nMaybeLocal<v8::Object> NewInstance(v8::Handle<v8::Function> h) {\n  return MaybeLocal<v8::Object>(h->NewInstance());\n}\n\ninline\nMaybeLocal<v8::Object> NewInstance(\n      v8::Local<v8::Function> h\n    , int argc\n    , v8::Local<v8::Value> argv[]) {\n  return MaybeLocal<v8::Object>(h->NewInstance(argc, argv));\n}\n\ninline\nMaybeLocal<v8::Object> NewInstance(v8::Handle<v8::ObjectTemplate> h) {\n  return MaybeLocal<v8::Object>(h->NewInstance());\n}\n\ninline\nMaybeLocal<v8::Function> GetFunction(v8::Handle<v8::FunctionTemplate> t) {\n  return MaybeLocal<v8::Function>(t->GetFunction());\n}\n\ninline Maybe<bool> Set(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::Value> key\n  , v8::Handle<v8::Value> value) {\n  return Just<bool>(obj->Set(key, value));\n}\n\ninline Maybe<bool> Set(\n    v8::Handle<v8::Object> obj\n  , uint32_t index\n  , v8::Handle<v8::Value> value) {\n  return Just<bool>(obj->Set(index, value));\n}\n\n#include \"nan_define_own_property_helper.h\"  // NOLINT(build/include)\n\ninline Maybe<bool> DefineOwnProperty(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::String> key\n  , v8::Handle<v8::Value> value\n  , v8::PropertyAttribute attribs = v8::None) {\n  v8::PropertyAttribute current = obj->GetPropertyAttributes(key);\n  return imp::DefineOwnPropertyHelper(current, obj, key, value, attribs);\n}\n\nNAN_DEPRECATED inline Maybe<bool> ForceSet(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::Value> key\n  , v8::Handle<v8::Value> value\n  , v8::PropertyAttribute attribs = v8::None) {\n  return Just<bool>(obj->ForceSet(key, value, attribs));\n}\n\ninline MaybeLocal<v8::Value> Get(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::Value> key) {\n  return MaybeLocal<v8::Value>(obj->Get(key));\n}\n\ninline MaybeLocal<v8::Value> Get(\n    v8::Handle<v8::Object> obj\n  , uint32_t index) {\n  return MaybeLocal<v8::Value>(obj->Get(index));\n}\n\ninline Maybe<v8::PropertyAttribute> GetPropertyAttributes(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::Value> key) {\n  return Just<v8::PropertyAttribute>(obj->GetPropertyAttributes(key));\n}\n\ninline Maybe<bool> Has(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::String> key) {\n  return Just<bool>(obj->Has(key));\n}\n\ninline Maybe<bool> Has(\n    v8::Handle<v8::Object> obj\n  , uint32_t index) {\n  return Just<bool>(obj->Has(index));\n}\n\ninline Maybe<bool> Delete(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::String> key) {\n  return Just<bool>(obj->Delete(key));\n}\n\ninline Maybe<bool> Delete(\n    v8::Handle<v8::Object> obj\n  , uint32_t index) {\n  return Just<bool>(obj->Delete(index));\n}\n\ninline\nMaybeLocal<v8::Array> GetPropertyNames(v8::Handle<v8::Object> obj) {\n  return MaybeLocal<v8::Array>(obj->GetPropertyNames());\n}\n\ninline\nMaybeLocal<v8::Array> GetOwnPropertyNames(v8::Handle<v8::Object> obj) {\n  return MaybeLocal<v8::Array>(obj->GetOwnPropertyNames());\n}\n\ninline Maybe<bool> SetPrototype(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::Value> prototype) {\n  return Just<bool>(obj->SetPrototype(prototype));\n}\n\ninline MaybeLocal<v8::String> ObjectProtoToString(\n    v8::Handle<v8::Object> obj) {\n  return MaybeLocal<v8::String>(obj->ObjectProtoToString());\n}\n\ninline Maybe<bool> HasOwnProperty(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::String> key) {\n  return Just<bool>(obj->HasOwnProperty(key));\n}\n\ninline Maybe<bool> HasRealNamedProperty(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::String> key) {\n  return Just<bool>(obj->HasRealNamedProperty(key));\n}\n\ninline Maybe<bool> HasRealIndexedProperty(\n    v8::Handle<v8::Object> obj\n  , uint32_t index) {\n  return Just<bool>(obj->HasRealIndexedProperty(index));\n}\n\ninline Maybe<bool> HasRealNamedCallbackProperty(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::String> key) {\n  return Just<bool>(obj->HasRealNamedCallbackProperty(key));\n}\n\ninline MaybeLocal<v8::Value> GetRealNamedPropertyInPrototypeChain(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::String> key) {\n  return MaybeLocal<v8::Value>(\n      obj->GetRealNamedPropertyInPrototypeChain(key));\n}\n\ninline MaybeLocal<v8::Value> GetRealNamedProperty(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::String> key) {\n  return MaybeLocal<v8::Value>(obj->GetRealNamedProperty(key));\n}\n\ninline MaybeLocal<v8::Value> CallAsFunction(\n    v8::Handle<v8::Object> obj\n  , v8::Handle<v8::Object> recv\n  , int argc\n  , v8::Handle<v8::Value> argv[]) {\n  return MaybeLocal<v8::Value>(obj->CallAsFunction(recv, argc, argv));\n}\n\ninline MaybeLocal<v8::Value> CallAsConstructor(\n    v8::Handle<v8::Object> obj\n  , int argc\n  , v8::Local<v8::Value> argv[]) {\n  return MaybeLocal<v8::Value>(obj->CallAsConstructor(argc, argv));\n}\n\ninline\nMaybeLocal<v8::String> GetSourceLine(v8::Handle<v8::Message> msg) {\n  return MaybeLocal<v8::String>(msg->GetSourceLine());\n}\n\ninline Maybe<int> GetLineNumber(v8::Handle<v8::Message> msg) {\n  return Just<int>(msg->GetLineNumber());\n}\n\ninline Maybe<int> GetStartColumn(v8::Handle<v8::Message> msg) {\n  return Just<int>(msg->GetStartColumn());\n}\n\ninline Maybe<int> GetEndColumn(v8::Handle<v8::Message> msg) {\n  return Just<int>(msg->GetEndColumn());\n}\n\ninline MaybeLocal<v8::Object> CloneElementAt(\n    v8::Handle<v8::Array> array\n  , uint32_t index) {\n  return MaybeLocal<v8::Object>(array->CloneElementAt(index));\n}\n\ninline MaybeLocal<v8::Value> Call(\n    v8::Local<v8::Function> fun\n  , v8::Local<v8::Object> recv\n  , int argc\n  , v8::Local<v8::Value> argv[]) {\n  return MaybeLocal<v8::Value>(fun->Call(recv, argc, argv));\n}\n\n#endif  // NAN_MAYBE_PRE_43_INL_H_\n"
        },
        {
          "name": "nan_new.h",
          "type": "blob",
          "size": 8.580078125,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_NEW_H_\n#define NAN_NEW_H_\n\nnamespace imp {  // scnr\n\n// TODO(agnat): Generalize\ntemplate <typename T> v8::Local<T> To(v8::Local<v8::Integer> i);\n\ntemplate <>\ninline\nv8::Local<v8::Integer>\nTo<v8::Integer>(v8::Local<v8::Integer> i) {\n  return Nan::To<v8::Integer>(i).ToLocalChecked();\n}\n\ntemplate <>\ninline\nv8::Local<v8::Int32>\nTo<v8::Int32>(v8::Local<v8::Integer> i) {\n  return Nan::To<v8::Int32>(i).ToLocalChecked();\n}\n\ntemplate <>\ninline\nv8::Local<v8::Uint32>\nTo<v8::Uint32>(v8::Local<v8::Integer> i) {\n  return Nan::To<v8::Uint32>(i).ToLocalChecked();\n}\n\ntemplate <typename T> struct FactoryBase {\n  typedef v8::Local<T> return_t;\n};\n\ntemplate <typename T> struct MaybeFactoryBase {\n  typedef MaybeLocal<T> return_t;\n};\n\ntemplate <typename T> struct Factory;\n\ntemplate <>\nstruct Factory<v8::Array> : FactoryBase<v8::Array> {\n  static inline return_t New();\n  static inline return_t New(int length);\n};\n\ntemplate <>\nstruct Factory<v8::Boolean> : FactoryBase<v8::Boolean> {\n  static inline return_t New(bool value);\n};\n\ntemplate <>\nstruct Factory<v8::BooleanObject> : FactoryBase<v8::BooleanObject> {\n  static inline return_t New(bool value);\n};\n\ntemplate <>\nstruct Factory<v8::Context> : FactoryBase<v8::Context> {\n  static inline\n  return_t\n  New( v8::ExtensionConfiguration* extensions = NULL\n     , v8::Local<v8::ObjectTemplate> tmpl = v8::Local<v8::ObjectTemplate>()\n     , v8::Local<v8::Value> obj = v8::Local<v8::Value>());\n};\n\ntemplate <>\nstruct Factory<v8::Date> : MaybeFactoryBase<v8::Date> {\n  static inline return_t New(double value);\n};\n\ntemplate <>\nstruct Factory<v8::External> : FactoryBase<v8::External> {\n  static inline return_t New(void *value);\n};\n\ntemplate <>\nstruct Factory<v8::Function> : FactoryBase<v8::Function> {\n  static inline\n  return_t\n  New( FunctionCallback callback\n     , v8::Local<v8::Value> data = v8::Local<v8::Value>());\n};\n\ntemplate <>\nstruct Factory<v8::FunctionTemplate> : FactoryBase<v8::FunctionTemplate> {\n  static inline\n  return_t\n  New( FunctionCallback callback = NULL\n     , v8::Local<v8::Value> data = v8::Local<v8::Value>()\n     , v8::Local<v8::Signature> signature = v8::Local<v8::Signature>());\n};\n\ntemplate <>\nstruct Factory<v8::Number> : FactoryBase<v8::Number> {\n  static inline return_t New(double value);\n};\n\ntemplate <>\nstruct Factory<v8::NumberObject> : FactoryBase<v8::NumberObject> {\n  static inline return_t New(double value);\n};\n\ntemplate <typename T>\nstruct IntegerFactory : FactoryBase<T> {\n  typedef typename FactoryBase<T>::return_t return_t;\n  static inline return_t New(int32_t value);\n  static inline return_t New(uint32_t value);\n};\n\ntemplate <>\nstruct Factory<v8::Integer> : IntegerFactory<v8::Integer> {};\n\ntemplate <>\nstruct Factory<v8::Int32> : IntegerFactory<v8::Int32> {};\n\ntemplate <>\nstruct Factory<v8::Uint32> : FactoryBase<v8::Uint32> {\n  static inline return_t New(int32_t value);\n  static inline return_t New(uint32_t value);\n};\n\ntemplate <>\nstruct Factory<v8::Object> : FactoryBase<v8::Object> {\n  static inline return_t New();\n};\n\ntemplate <>\nstruct Factory<v8::ObjectTemplate> : FactoryBase<v8::ObjectTemplate> {\n  static inline return_t New();\n};\n\ntemplate <>\nstruct Factory<v8::RegExp> : MaybeFactoryBase<v8::RegExp> {\n  static inline return_t New(\n      v8::Local<v8::String> pattern, v8::RegExp::Flags flags);\n};\n\ntemplate <>\nstruct Factory<v8::Script> : MaybeFactoryBase<v8::Script> {\n  static inline return_t New( v8::Local<v8::String> source);\n  static inline return_t New( v8::Local<v8::String> source\n                            , v8::ScriptOrigin const& origin);\n};\n\ntemplate <>\nstruct Factory<v8::Signature> : FactoryBase<v8::Signature> {\n  typedef v8::Local<v8::FunctionTemplate> FTH;\n  static inline return_t New(FTH receiver = FTH());\n};\n\ntemplate <>\nstruct Factory<v8::String> : MaybeFactoryBase<v8::String> {\n  static inline return_t New();\n  static inline return_t New(const char *value, int length = -1);\n  static inline return_t New(const uint16_t *value, int length = -1);\n  static inline return_t New(std::string const& value);\n\n  static inline return_t New(v8::String::ExternalStringResource * value);\n  static inline return_t New(ExternalOneByteStringResource * value);\n};\n\ntemplate <>\nstruct Factory<v8::StringObject> : FactoryBase<v8::StringObject> {\n  static inline return_t New(v8::Local<v8::String> value);\n};\n\n}  // end of namespace imp\n\n#if (NODE_MODULE_VERSION >= 12)\n\nnamespace imp {\n\ntemplate <>\nstruct Factory<v8::UnboundScript> : MaybeFactoryBase<v8::UnboundScript> {\n  static inline return_t New( v8::Local<v8::String> source);\n  static inline return_t New( v8::Local<v8::String> source\n                            , v8::ScriptOrigin const& origin);\n};\n\n}  // end of namespace imp\n\n# include \"nan_implementation_12_inl.h\"\n\n#else  // NODE_MODULE_VERSION >= 12\n\n# include \"nan_implementation_pre_12_inl.h\"\n\n#endif\n\n//=== API ======================================================================\n\ntemplate <typename T>\ntypename imp::Factory<T>::return_t\nNew() {\n  return imp::Factory<T>::New();\n}\n\ntemplate <typename T, typename A0>\ntypename imp::Factory<T>::return_t\nNew(A0 arg0) {\n  return imp::Factory<T>::New(arg0);\n}\n\ntemplate <typename T, typename A0, typename A1>\ntypename imp::Factory<T>::return_t\nNew(A0 arg0, A1 arg1) {\n  return imp::Factory<T>::New(arg0, arg1);\n}\n\ntemplate <typename T, typename A0, typename A1, typename A2>\ntypename imp::Factory<T>::return_t\nNew(A0 arg0, A1 arg1, A2 arg2) {\n  return imp::Factory<T>::New(arg0, arg1, arg2);\n}\n\ntemplate <typename T, typename A0, typename A1, typename A2, typename A3>\ntypename imp::Factory<T>::return_t\nNew(A0 arg0, A1 arg1, A2 arg2, A3 arg3) {\n  return imp::Factory<T>::New(arg0, arg1, arg2, arg3);\n}\n\n// Note(agnat): When passing overloaded function pointers to template functions\n// as generic arguments the compiler needs help in picking the right overload.\n// These two functions handle New<Function> and New<FunctionTemplate> with\n// all argument variations.\n\n// v8::Function and v8::FunctionTemplate with one or two arguments\ntemplate <typename T>\ntypename imp::Factory<T>::return_t\nNew( FunctionCallback callback\n      , v8::Local<v8::Value> data = v8::Local<v8::Value>()) {\n    return imp::Factory<T>::New(callback, data);\n}\n\n// v8::Function and v8::FunctionTemplate with three arguments\ntemplate <typename T, typename A2>\ntypename imp::Factory<T>::return_t\nNew( FunctionCallback callback\n      , v8::Local<v8::Value> data = v8::Local<v8::Value>()\n      , A2 a2 = A2()) {\n    return imp::Factory<T>::New(callback, data, a2);\n}\n\n// Convenience\n\n#if NODE_MODULE_VERSION < IOJS_3_0_MODULE_VERSION\ntemplate <typename T> inline v8::Local<T> New(v8::Handle<T> h);\n#endif\n\n#if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\ntemplate <typename T, typename M>\n    inline v8::Local<T> New(v8::Persistent<T, M> const& p);\n#else\ntemplate <typename T> inline v8::Local<T> New(v8::Persistent<T> const& p);\n#endif\ntemplate <typename T, typename M>\ninline v8::Local<T> New(Persistent<T, M> const& p);\ntemplate <typename T>\ninline v8::Local<T> New(Global<T> const& p);\n\ninline\nimp::Factory<v8::Boolean>::return_t\nNew(bool value) {\n  return New<v8::Boolean>(value);\n}\n\ninline\nimp::Factory<v8::Int32>::return_t\nNew(int32_t value) {\n  return New<v8::Int32>(value);\n}\n\ninline\nimp::Factory<v8::Uint32>::return_t\nNew(uint32_t value) {\n  return New<v8::Uint32>(value);\n}\n\ninline\nimp::Factory<v8::Number>::return_t\nNew(double value) {\n  return New<v8::Number>(value);\n}\n\ninline\nimp::Factory<v8::String>::return_t\nNew(std::string const& value) {  // NOLINT(build/include_what_you_use)\n  return New<v8::String>(value);\n}\n\ninline\nimp::Factory<v8::String>::return_t\nNew(const char * value, int length) {\n  return New<v8::String>(value, length);\n}\n\ninline\nimp::Factory<v8::String>::return_t\nNew(const uint16_t * value, int length) {\n  return New<v8::String>(value, length);\n}\n\ninline\nimp::Factory<v8::String>::return_t\nNew(const char * value) {\n  return New<v8::String>(value);\n}\n\ninline\nimp::Factory<v8::String>::return_t\nNew(const uint16_t * value) {\n  return New<v8::String>(value);\n}\n\ninline\nimp::Factory<v8::String>::return_t\nNew(v8::String::ExternalStringResource * value) {\n  return New<v8::String>(value);\n}\n\ninline\nimp::Factory<v8::String>::return_t\nNew(ExternalOneByteStringResource * value) {\n  return New<v8::String>(value);\n}\n\ninline\nimp::Factory<v8::RegExp>::return_t\nNew(v8::Local<v8::String> pattern, v8::RegExp::Flags flags) {\n  return New<v8::RegExp>(pattern, flags);\n}\n\n#endif  // NAN_NEW_H_\n"
        },
        {
          "name": "nan_object_wrap.h",
          "type": "blob",
          "size": 4.03125,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_OBJECT_WRAP_H_\n#define NAN_OBJECT_WRAP_H_\n\nclass ObjectWrap {\n public:\n  ObjectWrap() {\n    refs_ = 0;\n  }\n\n\n  virtual ~ObjectWrap() {\n    if (persistent().IsEmpty()) {\n      return;\n    }\n\n    persistent().ClearWeak();\n    persistent().Reset();\n  }\n\n\n  template <class T>\n  static inline T* Unwrap(v8::Local<v8::Object> object) {\n    assert(!object.IsEmpty());\n    assert(object->InternalFieldCount() > 0);\n    // Cast to ObjectWrap before casting to T.  A direct cast from void\n    // to T won't work right when T has more than one base class.\n    void* ptr = GetInternalFieldPointer(object, 0);\n    ObjectWrap* wrap = static_cast<ObjectWrap*>(ptr);\n    return static_cast<T*>(wrap);\n  }\n\n\n  inline v8::Local<v8::Object> handle() const {\n    return New(handle_);\n  }\n\n\n  inline Persistent<v8::Object>& persistent() {\n    return handle_;\n  }\n\n\n protected:\n  inline void Wrap(v8::Local<v8::Object> object) {\n    assert(persistent().IsEmpty());\n    assert(object->InternalFieldCount() > 0);\n    SetInternalFieldPointer(object, 0, this);\n    persistent().Reset(object);\n    MakeWeak();\n  }\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n\n  inline void MakeWeak() {\n    persistent().v8::PersistentBase<v8::Object>::SetWeak(\n        this, WeakCallback, v8::WeakCallbackType::kParameter);\n#if NODE_MAJOR_VERSION < 10\n    // FIXME(bnoordhuis) Probably superfluous in older Node.js versions too.\n    persistent().MarkIndependent();\n#endif\n  }\n\n#elif NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n\n  inline void MakeWeak() {\n    persistent().v8::PersistentBase<v8::Object>::SetWeak(this, WeakCallback);\n    persistent().MarkIndependent();\n  }\n\n#else\n\n  inline void MakeWeak() {\n    persistent().persistent.MakeWeak(this, WeakCallback);\n    persistent().MarkIndependent();\n  }\n\n#endif\n\n  /* Ref() marks the object as being attached to an event loop.\n   * Refed objects will not be garbage collected, even if\n   * all references are lost.\n   */\n  virtual void Ref() {\n    assert(!persistent().IsEmpty());\n    persistent().ClearWeak();\n    refs_++;\n  }\n\n  /* Unref() marks an object as detached from the event loop.  This is its\n   * default state.  When an object with a \"weak\" reference changes from\n   * attached to detached state it will be freed. Be careful not to access\n   * the object after making this call as it might be gone!\n   * (A \"weak reference\" means an object that only has a\n   * persistent handle.)\n   *\n   * DO NOT CALL THIS FROM DESTRUCTOR\n   */\n  virtual void Unref() {\n    assert(!persistent().IsEmpty());\n    assert(!persistent().IsWeak());\n    assert(refs_ > 0);\n    if (--refs_ == 0)\n      MakeWeak();\n  }\n\n  int refs_;  // ro\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(ObjectWrap)\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n\n  static void\n  WeakCallback(v8::WeakCallbackInfo<ObjectWrap> const& info) {\n    ObjectWrap* wrap = info.GetParameter();\n    assert(wrap->refs_ == 0);\n    wrap->handle_.Reset();\n    delete wrap;\n  }\n\n#elif NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n\n  static void\n  WeakCallback(v8::WeakCallbackData<v8::Object, ObjectWrap> const& data) {\n    ObjectWrap* wrap = data.GetParameter();\n    assert(wrap->refs_ == 0);\n    assert(wrap->handle_.IsNearDeath());\n    wrap->handle_.Reset();\n    delete wrap;\n  }\n\n#else\n\n  static void WeakCallback(v8::Persistent<v8::Value> value, void *data) {\n    ObjectWrap *wrap = static_cast<ObjectWrap*>(data);\n    assert(wrap->refs_ == 0);\n    assert(wrap->handle_.IsNearDeath());\n    wrap->handle_.Reset();\n    delete wrap;\n  }\n\n#endif\n  Persistent<v8::Object> handle_;\n};\n\n\n#endif  // NAN_OBJECT_WRAP_H_\n"
        },
        {
          "name": "nan_persistent_12_inl.h",
          "type": "blob",
          "size": 3.7822265625,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_PERSISTENT_12_INL_H_\n#define NAN_PERSISTENT_12_INL_H_\n\ntemplate<typename T, typename M> class Persistent :\n    public v8::Persistent<T, M> {\n public:\n  inline Persistent() : v8::Persistent<T, M>() {}\n\n  template<typename S> inline Persistent(v8::Local<S> that) :\n      v8::Persistent<T, M>(v8::Isolate::GetCurrent(), that) {}\n\n  template<typename S, typename M2>\n  inline\n  Persistent(const v8::Persistent<S, M2> &that) :  // NOLINT(runtime/explicit)\n      v8::Persistent<T, M2>(v8::Isolate::GetCurrent(), that) {}\n\n  inline void Reset() { v8::PersistentBase<T>::Reset(); }\n\n  template <typename S>\n  inline void Reset(const v8::Local<S> &other) {\n    v8::PersistentBase<T>::Reset(v8::Isolate::GetCurrent(), other);\n  }\n\n  template <typename S>\n  inline void Reset(const v8::PersistentBase<S> &other) {\n    v8::PersistentBase<T>::Reset(v8::Isolate::GetCurrent(), other);\n  }\n\n  template<typename P>\n  inline void SetWeak(\n    P *parameter\n    , typename WeakCallbackInfo<P>::Callback callback\n    , WeakCallbackType type);\n\n private:\n  inline T *operator*() const { return *PersistentBase<T>::persistent; }\n\n  template<typename S, typename M2>\n  inline void Copy(const Persistent<S, M2> &that) {\n    TYPE_CHECK(T, S);\n\n    this->Reset();\n\n    if (!that.IsEmpty()) {\n      this->Reset(that);\n      M::Copy(that, this);\n    }\n  }\n};\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\ntemplate<typename T>\nclass Global : public v8::Global<T> {\n public:\n  inline Global() : v8::Global<T>() {}\n\n  template<typename S> inline Global(v8::Local<S> that) :\n    v8::Global<T>(v8::Isolate::GetCurrent(), that) {}\n\n  template<typename S>\n  inline\n  Global(const v8::PersistentBase<S> &that) :  // NOLINT(runtime/explicit)\n      v8::Global<S>(v8::Isolate::GetCurrent(), that) {}\n\n  inline void Reset() { v8::PersistentBase<T>::Reset(); }\n\n  template <typename S>\n  inline void Reset(const v8::Local<S> &other) {\n    v8::PersistentBase<T>::Reset(v8::Isolate::GetCurrent(), other);\n  }\n\n  template <typename S>\n  inline void Reset(const v8::PersistentBase<S> &other) {\n    v8::PersistentBase<T>::Reset(v8::Isolate::GetCurrent(), other);\n  }\n\n  template<typename P>\n  inline void SetWeak(\n    P *parameter\n    , typename WeakCallbackInfo<P>::Callback callback\n    , WeakCallbackType type) {\n    reinterpret_cast<Persistent<T>*>(this)->SetWeak(\n        parameter, callback, type);\n  }\n};\n#else\ntemplate<typename T>\nclass Global : public v8::UniquePersistent<T> {\n public:\n  inline Global() : v8::UniquePersistent<T>() {}\n\n  template<typename S> inline Global(v8::Local<S> that) :\n    v8::UniquePersistent<T>(v8::Isolate::GetCurrent(), that) {}\n\n  template<typename S>\n  inline\n  Global(const v8::PersistentBase<S> &that) :  // NOLINT(runtime/explicit)\n      v8::UniquePersistent<S>(v8::Isolate::GetCurrent(), that) {}\n\n  inline void Reset() { v8::PersistentBase<T>::Reset(); }\n\n  template <typename S>\n  inline void Reset(const v8::Local<S> &other) {\n    v8::PersistentBase<T>::Reset(v8::Isolate::GetCurrent(), other);\n  }\n\n  template <typename S>\n  inline void Reset(const v8::PersistentBase<S> &other) {\n    v8::PersistentBase<T>::Reset(v8::Isolate::GetCurrent(), other);\n  }\n\n  template<typename P>\n  inline void SetWeak(\n    P *parameter\n    , typename WeakCallbackInfo<P>::Callback callback\n    , WeakCallbackType type) {\n    reinterpret_cast<Persistent<T>*>(this)->SetWeak(\n        parameter, callback, type);\n  }\n};\n#endif\n\n#endif  // NAN_PERSISTENT_12_INL_H_\n"
        },
        {
          "name": "nan_persistent_pre_12_inl.h",
          "type": "blob",
          "size": 6.0126953125,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_PERSISTENT_PRE_12_INL_H_\n#define NAN_PERSISTENT_PRE_12_INL_H_\n\ntemplate<typename T>\nclass PersistentBase {\n  v8::Persistent<T> persistent;\n  template<typename U>\n  friend v8::Local<U> New(const PersistentBase<U> &p);\n  template<typename U, typename M>\n  friend v8::Local<U> New(const Persistent<U, M> &p);\n  template<typename U>\n  friend v8::Local<U> New(const Global<U> &p);\n  template<typename S> friend class ReturnValue;\n\n public:\n  inline PersistentBase() :\n      persistent() {}\n\n  inline void Reset() {\n    persistent.Dispose();\n    persistent.Clear();\n  }\n\n  template<typename S>\n  inline void Reset(const v8::Local<S> &other) {\n    TYPE_CHECK(T, S);\n\n    if (!persistent.IsEmpty()) {\n      persistent.Dispose();\n    }\n\n    if (other.IsEmpty()) {\n      persistent.Clear();\n    } else {\n      persistent = v8::Persistent<T>::New(other);\n    }\n  }\n\n  template<typename S>\n  inline void Reset(const PersistentBase<S> &other) {\n    TYPE_CHECK(T, S);\n\n    if (!persistent.IsEmpty()) {\n      persistent.Dispose();\n    }\n\n    if (other.IsEmpty()) {\n      persistent.Clear();\n    } else {\n      persistent = v8::Persistent<T>::New(other.persistent);\n    }\n  }\n\n  inline bool IsEmpty() const { return persistent.IsEmpty(); }\n\n  inline void Empty() { persistent.Clear(); }\n\n  template<typename S>\n  inline bool operator==(const PersistentBase<S> &that) const {\n    return this->persistent == that.persistent;\n  }\n\n  template<typename S>\n  inline bool operator==(const v8::Local<S> &that) const {\n    return this->persistent == that;\n  }\n\n  template<typename S>\n  inline bool operator!=(const PersistentBase<S> &that) const {\n    return !operator==(that);\n  }\n\n  template<typename S>\n  inline bool operator!=(const v8::Local<S> &that) const {\n    return !operator==(that);\n  }\n\n  template<typename P>\n  inline void SetWeak(\n    P *parameter\n    , typename WeakCallbackInfo<P>::Callback callback\n    , WeakCallbackType type);\n\n  inline void ClearWeak() { persistent.ClearWeak(); }\n\n  inline void MarkIndependent() { persistent.MarkIndependent(); }\n\n  inline bool IsIndependent() const { return persistent.IsIndependent(); }\n\n  inline bool IsNearDeath() const { return persistent.IsNearDeath(); }\n\n  inline bool IsWeak() const { return persistent.IsWeak(); }\n\n private:\n  inline explicit PersistentBase(v8::Persistent<T> that) :\n      persistent(that) { }\n  inline explicit PersistentBase(T *val) : persistent(val) {}\n  template<typename S, typename M> friend class Persistent;\n  template<typename S> friend class Global;\n  friend class ObjectWrap;\n};\n\ntemplate<typename T>\nclass NonCopyablePersistentTraits {\n public:\n  typedef Persistent<T, NonCopyablePersistentTraits<T> >\n      NonCopyablePersistent;\n  static const bool kResetInDestructor = false;\n  template<typename S, typename M>\n  inline static void Copy(const Persistent<S, M> &source,\n                             NonCopyablePersistent *dest) {\n    Uncompilable<v8::Object>();\n  }\n\n  template<typename O> inline static void Uncompilable() {\n    TYPE_CHECK(O, v8::Primitive);\n  }\n};\n\ntemplate<typename T>\nstruct CopyablePersistentTraits {\n  typedef Persistent<T, CopyablePersistentTraits<T> > CopyablePersistent;\n  static const bool kResetInDestructor = true;\n  template<typename S, typename M>\n  static inline void Copy(const Persistent<S, M> &source,\n                             CopyablePersistent *dest) {}\n};\n\ntemplate<typename T, typename M> class Persistent :\n    public PersistentBase<T> {\n public:\n  inline Persistent() {}\n\n  template<typename S> inline Persistent(v8::Handle<S> that)\n      : PersistentBase<T>(v8::Persistent<T>::New(that)) {\n    TYPE_CHECK(T, S);\n  }\n\n  inline Persistent(const Persistent &that) : PersistentBase<T>() {\n    Copy(that);\n  }\n\n  template<typename S, typename M2>\n  inline Persistent(const Persistent<S, M2> &that) :\n      PersistentBase<T>() {\n    Copy(that);\n  }\n\n  inline Persistent &operator=(const Persistent &that) {\n    Copy(that);\n    return *this;\n  }\n\n  template <class S, class M2>\n  inline Persistent &operator=(const Persistent<S, M2> &that) {\n    Copy(that);\n    return *this;\n  }\n\n  inline ~Persistent() {\n    if (M::kResetInDestructor) this->Reset();\n  }\n\n private:\n  inline T *operator*() const { return *PersistentBase<T>::persistent; }\n\n  template<typename S, typename M2>\n  inline void Copy(const Persistent<S, M2> &that) {\n    TYPE_CHECK(T, S);\n\n    this->Reset();\n\n    if (!that.IsEmpty()) {\n      this->persistent = v8::Persistent<T>::New(that.persistent);\n      M::Copy(that, this);\n    }\n  }\n};\n\ntemplate<typename T>\nclass Global : public PersistentBase<T> {\n  struct RValue {\n    inline explicit RValue(Global* obj) : object(obj) {}\n    Global* object;\n  };\n\n public:\n  inline Global() : PersistentBase<T>(0) { }\n\n  template <typename S>\n  inline Global(v8::Local<S> that)  // NOLINT(runtime/explicit)\n      : PersistentBase<T>(v8::Persistent<T>::New(that)) {\n    TYPE_CHECK(T, S);\n  }\n\n  template <typename S>\n  inline Global(const PersistentBase<S> &that)  // NOLINT(runtime/explicit)\n    : PersistentBase<T>(that) {\n    TYPE_CHECK(T, S);\n  }\n  /**\n   * Move constructor.\n   */\n  inline Global(RValue rvalue)  // NOLINT(runtime/explicit)\n    : PersistentBase<T>(rvalue.object->persistent) {\n    rvalue.object->Reset();\n  }\n  inline ~Global() { this->Reset(); }\n  /**\n   * Move via assignment.\n   */\n  template<typename S>\n  inline Global &operator=(Global<S> rhs) {\n    TYPE_CHECK(T, S);\n    this->Reset(rhs.persistent);\n    rhs.Reset();\n    return *this;\n  }\n  /**\n   * Cast operator for moves.\n   */\n  inline operator RValue() { return RValue(this); }\n  /**\n   * Pass allows returning uniques from functions, etc.\n   */\n  Global Pass() { return Global(RValue(this)); }\n\n private:\n  Global(Global &);\n  void operator=(Global &);\n  template<typename S> friend class ReturnValue;\n};\n\n#endif  // NAN_PERSISTENT_PRE_12_INL_H_\n"
        },
        {
          "name": "nan_private.h",
          "type": "blob",
          "size": 2.4189453125,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_PRIVATE_H_\n#define NAN_PRIVATE_H_\n\ninline Maybe<bool>\nHasPrivate(v8::Local<v8::Object> object, v8::Local<v8::String> key) {\n  HandleScope scope;\n#if NODE_MODULE_VERSION >= NODE_6_0_MODULE_VERSION\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n  v8::Local<v8::Private> private_key = v8::Private::ForApi(isolate, key);\n  return object->HasPrivate(context, private_key);\n#else\n  return Just(!object->GetHiddenValue(key).IsEmpty());\n#endif\n}\n\ninline MaybeLocal<v8::Value>\nGetPrivate(v8::Local<v8::Object> object, v8::Local<v8::String> key) {\n#if NODE_MODULE_VERSION >= NODE_6_0_MODULE_VERSION\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope scope(isolate);\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n  v8::Local<v8::Private> private_key = v8::Private::ForApi(isolate, key);\n  v8::MaybeLocal<v8::Value> v = object->GetPrivate(context, private_key);\n  return scope.Escape(v.ToLocalChecked());\n#else\n  EscapableHandleScope scope;\n  v8::Local<v8::Value> v = object->GetHiddenValue(key);\n  if (v.IsEmpty()) {\n    v = Undefined();\n  }\n  return scope.Escape(v);\n#endif\n}\n\ninline Maybe<bool> SetPrivate(\n    v8::Local<v8::Object> object,\n    v8::Local<v8::String> key,\n    v8::Local<v8::Value> value) {\n#if NODE_MODULE_VERSION >= NODE_6_0_MODULE_VERSION\n  HandleScope scope;\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n  v8::Local<v8::Private> private_key = v8::Private::ForApi(isolate, key);\n  return object->SetPrivate(context, private_key, value);\n#else\n  return Just(object->SetHiddenValue(key, value));\n#endif\n}\n\ninline Maybe<bool> DeletePrivate(\n    v8::Local<v8::Object> object,\n    v8::Local<v8::String> key) {\n#if NODE_MODULE_VERSION >= NODE_6_0_MODULE_VERSION\n  HandleScope scope;\n  v8::Isolate *isolate = v8::Isolate::GetCurrent();\n  v8::Local<v8::Private> private_key = v8::Private::ForApi(isolate, key);\n  return object->DeletePrivate(isolate->GetCurrentContext(), private_key);\n#else\n  return Just(object->DeleteHiddenValue(key));\n#endif\n}\n\n#endif  // NAN_PRIVATE_H_\n\n"
        },
        {
          "name": "nan_scriptorigin.h",
          "type": "blob",
          "size": 3.5986328125,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2021 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_SCRIPTORIGIN_H_\n#define NAN_SCRIPTORIGIN_H_\n\nclass ScriptOrigin : public v8::ScriptOrigin {\n public:\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 11 \\\n    && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION > 7)\n  explicit ScriptOrigin(v8::Local<v8::Value> name) :\n      v8::ScriptOrigin(name) {}\n\n  ScriptOrigin(v8::Local<v8::Value> name\n             , v8::Local<v8::Integer> line) :\n      v8::ScriptOrigin(name\n                   , To<int32_t>(line).FromMaybe(0)) {}\n\n  ScriptOrigin(v8::Local<v8::Value> name\n             , v8::Local<v8::Integer> line\n             , v8::Local<v8::Integer> column) :\n      v8::ScriptOrigin(name\n                   , To<int32_t>(line).FromMaybe(0)\n                   , To<int32_t>(column).FromMaybe(0)) {}\n#elif defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 9 ||                      \\\n  (V8_MAJOR_VERSION == 9 && (defined(V8_MINOR_VERSION) && (V8_MINOR_VERSION > 0\\\n      || (V8_MINOR_VERSION == 0 && defined(V8_BUILD_NUMBER)                    \\\n          && V8_BUILD_NUMBER >= 1)))))\n  explicit ScriptOrigin(v8::Local<v8::Value> name) :\n      v8::ScriptOrigin(v8::Isolate::GetCurrent(), name) {}\n\n  ScriptOrigin(v8::Local<v8::Value> name\n             , v8::Local<v8::Integer> line) :\n      v8::ScriptOrigin(v8::Isolate::GetCurrent()\n                   , name\n                   , To<int32_t>(line).FromMaybe(0)) {}\n\n  ScriptOrigin(v8::Local<v8::Value> name\n             , v8::Local<v8::Integer> line\n             , v8::Local<v8::Integer> column) :\n      v8::ScriptOrigin(v8::Isolate::GetCurrent()\n                   , name\n                   , To<int32_t>(line).FromMaybe(0)\n                   , To<int32_t>(column).FromMaybe(0)) {}\n#elif defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 8 ||                    \\\n  (V8_MAJOR_VERSION == 8 && (defined(V8_MINOR_VERSION) && (V8_MINOR_VERSION > 9\\\n      || (V8_MINOR_VERSION == 9 && defined(V8_BUILD_NUMBER)                    \\\n          && V8_BUILD_NUMBER >= 45)))))\n  explicit ScriptOrigin(v8::Local<v8::Value> name) : v8::ScriptOrigin(name) {}\n\n  ScriptOrigin(v8::Local<v8::Value> name\n             , v8::Local<v8::Integer> line) :\n      v8::ScriptOrigin(name, To<int32_t>(line).FromMaybe(0)) {}\n\n  ScriptOrigin(v8::Local<v8::Value> name\n             , v8::Local<v8::Integer> line\n             , v8::Local<v8::Integer> column) :\n      v8::ScriptOrigin(name\n                   , To<int32_t>(line).FromMaybe(0)\n                   , To<int32_t>(column).FromMaybe(0)) {}\n#else\n  explicit ScriptOrigin(v8::Local<v8::Value> name) : v8::ScriptOrigin(name) {}\n\n  ScriptOrigin(v8::Local<v8::Value> name\n             , v8::Local<v8::Integer> line) : v8::ScriptOrigin(name, line) {}\n\n  ScriptOrigin(v8::Local<v8::Value> name\n             , v8::Local<v8::Integer> line\n             , v8::Local<v8::Integer> column) :\n      v8::ScriptOrigin(name, line, column) {}\n#endif\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 8 ||                      \\\n  (V8_MAJOR_VERSION == 8 && (defined(V8_MINOR_VERSION) && (V8_MINOR_VERSION > 9\\\n      || (V8_MINOR_VERSION == 9 && defined(V8_BUILD_NUMBER)                    \\\n          && V8_BUILD_NUMBER >= 45)))))\n    v8::Local<v8::Integer> ResourceLineOffset() const {\n      return New(LineOffset());\n    }\n\n    v8::Local<v8::Integer> ResourceColumnOffset() const {\n      return New(ColumnOffset());\n    }\n#endif\n};\n\n#endif  // NAN_SCRIPTORIGIN_H_\n"
        },
        {
          "name": "nan_string_bytes.h",
          "type": "blob",
          "size": 7.912109375,
          "content": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#ifndef NAN_STRING_BYTES_H_\n#define NAN_STRING_BYTES_H_\n\n// Decodes a v8::Local<v8::String> or Buffer to a raw char*\n\nnamespace imp {\n\nusing v8::Local;\nusing v8::Object;\nusing v8::String;\nusing v8::Value;\n\n\n//// Base 64 ////\n\n#define base64_encoded_size(size) ((size + 2 - ((size + 2) % 3)) / 3 * 4)\n\n\n\n//// HEX ////\n\nstatic bool contains_non_ascii_slow(const char* buf, size_t len) {\n  for (size_t i = 0; i < len; ++i) {\n    if (buf[i] & 0x80) return true;\n  }\n  return false;\n}\n\n\nstatic bool contains_non_ascii(const char* src, size_t len) {\n  if (len < 16) {\n    return contains_non_ascii_slow(src, len);\n  }\n\n  const unsigned bytes_per_word = sizeof(void*);\n  const unsigned align_mask = bytes_per_word - 1;\n  const unsigned unaligned = reinterpret_cast<uintptr_t>(src) & align_mask;\n\n  if (unaligned > 0) {\n    const unsigned n = bytes_per_word - unaligned;\n    if (contains_non_ascii_slow(src, n)) return true;\n    src += n;\n    len -= n;\n  }\n\n\n#if defined(__x86_64__) || defined(_WIN64)\n  const uintptr_t mask = 0x8080808080808080ll;\n#else\n  const uintptr_t mask = 0x80808080l;\n#endif\n\n  const uintptr_t* srcw = reinterpret_cast<const uintptr_t*>(src);\n\n  for (size_t i = 0, n = len / bytes_per_word; i < n; ++i) {\n    if (srcw[i] & mask) return true;\n  }\n\n  const unsigned remainder = len & align_mask;\n  if (remainder > 0) {\n    const size_t offset = len - remainder;\n    if (contains_non_ascii_slow(src + offset, remainder)) return true;\n  }\n\n  return false;\n}\n\n\nstatic void force_ascii_slow(const char* src, char* dst, size_t len) {\n  for (size_t i = 0; i < len; ++i) {\n    dst[i] = src[i] & 0x7f;\n  }\n}\n\n\nstatic void force_ascii(const char* src, char* dst, size_t len) {\n  if (len < 16) {\n    force_ascii_slow(src, dst, len);\n    return;\n  }\n\n  const unsigned bytes_per_word = sizeof(void*);\n  const unsigned align_mask = bytes_per_word - 1;\n  const unsigned src_unalign = reinterpret_cast<uintptr_t>(src) & align_mask;\n  const unsigned dst_unalign = reinterpret_cast<uintptr_t>(dst) & align_mask;\n\n  if (src_unalign > 0) {\n    if (src_unalign == dst_unalign) {\n      const unsigned unalign = bytes_per_word - src_unalign;\n      force_ascii_slow(src, dst, unalign);\n      src += unalign;\n      dst += unalign;\n      len -= src_unalign;\n    } else {\n      force_ascii_slow(src, dst, len);\n      return;\n    }\n  }\n\n#if defined(__x86_64__) || defined(_WIN64)\n  const uintptr_t mask = ~0x8080808080808080ll;\n#else\n  const uintptr_t mask = ~0x80808080l;\n#endif\n\n  const uintptr_t* srcw = reinterpret_cast<const uintptr_t*>(src);\n  uintptr_t* dstw = reinterpret_cast<uintptr_t*>(dst);\n\n  for (size_t i = 0, n = len / bytes_per_word; i < n; ++i) {\n    dstw[i] = srcw[i] & mask;\n  }\n\n  const unsigned remainder = len & align_mask;\n  if (remainder > 0) {\n    const size_t offset = len - remainder;\n    force_ascii_slow(src + offset, dst + offset, remainder);\n  }\n}\n\n\nstatic size_t base64_encode(const char* src,\n                            size_t slen,\n                            char* dst,\n                            size_t dlen) {\n  // We know how much we'll write, just make sure that there's space.\n  assert(dlen >= base64_encoded_size(slen) &&\n      \"not enough space provided for base64 encode\");\n\n  dlen = base64_encoded_size(slen);\n\n  unsigned a;\n  unsigned b;\n  unsigned c;\n  unsigned i;\n  unsigned k;\n  unsigned n;\n\n  static const char table[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                              \"abcdefghijklmnopqrstuvwxyz\"\n                              \"0123456789+/\";\n\n  i = 0;\n  k = 0;\n  n = slen / 3 * 3;\n\n  while (i < n) {\n    a = src[i + 0] & 0xff;\n    b = src[i + 1] & 0xff;\n    c = src[i + 2] & 0xff;\n\n    dst[k + 0] = table[a >> 2];\n    dst[k + 1] = table[((a & 3) << 4) | (b >> 4)];\n    dst[k + 2] = table[((b & 0x0f) << 2) | (c >> 6)];\n    dst[k + 3] = table[c & 0x3f];\n\n    i += 3;\n    k += 4;\n  }\n\n  if (n != slen) {\n    switch (slen - n) {\n      case 1:\n        a = src[i + 0] & 0xff;\n        dst[k + 0] = table[a >> 2];\n        dst[k + 1] = table[(a & 3) << 4];\n        dst[k + 2] = '=';\n        dst[k + 3] = '=';\n        break;\n\n      case 2:\n        a = src[i + 0] & 0xff;\n        b = src[i + 1] & 0xff;\n        dst[k + 0] = table[a >> 2];\n        dst[k + 1] = table[((a & 3) << 4) | (b >> 4)];\n        dst[k + 2] = table[(b & 0x0f) << 2];\n        dst[k + 3] = '=';\n        break;\n    }\n  }\n\n  return dlen;\n}\n\n\nstatic size_t hex_encode(const char* src, size_t slen, char* dst, size_t dlen) {\n  // We know how much we'll write, just make sure that there's space.\n  assert(dlen >= slen * 2 &&\n      \"not enough space provided for hex encode\");\n\n  dlen = slen * 2;\n  for (uint32_t i = 0, k = 0; k < dlen; i += 1, k += 2) {\n    static const char hex[] = \"0123456789abcdef\";\n    uint8_t val = static_cast<uint8_t>(src[i]);\n    dst[k + 0] = hex[val >> 4];\n    dst[k + 1] = hex[val & 15];\n  }\n\n  return dlen;\n}\n\n\n\nstatic Local<Value> Encode(const char* buf,\n                           size_t buflen,\n                           enum Encoding encoding) {\n  assert(buflen <= node::Buffer::kMaxLength);\n  if (!buflen && encoding != BUFFER)\n    return New(\"\").ToLocalChecked();\n\n  Local<String> val;\n  switch (encoding) {\n    case BUFFER:\n      return CopyBuffer(buf, buflen).ToLocalChecked();\n\n    case ASCII:\n      if (contains_non_ascii(buf, buflen)) {\n        char* out = new char[buflen];\n        force_ascii(buf, out, buflen);\n        val = New<String>(out, buflen).ToLocalChecked();\n        delete[] out;\n      } else {\n        val = New<String>(buf, buflen).ToLocalChecked();\n      }\n      break;\n\n    case UTF8:\n      val = New<String>(buf, buflen).ToLocalChecked();\n      break;\n\n    case BINARY: {\n      // TODO(isaacs) use ExternalTwoByteString?\n      const unsigned char *cbuf = reinterpret_cast<const unsigned char*>(buf);\n      uint16_t * twobytebuf = new uint16_t[buflen];\n      for (size_t i = 0; i < buflen; i++) {\n        // XXX is the following line platform independent?\n        twobytebuf[i] = cbuf[i];\n      }\n      val = New<String>(twobytebuf, buflen).ToLocalChecked();\n      delete[] twobytebuf;\n      break;\n    }\n\n    case BASE64: {\n      size_t dlen = base64_encoded_size(buflen);\n      char* dst = new char[dlen];\n\n      size_t written = base64_encode(buf, buflen, dst, dlen);\n      assert(written == dlen);\n\n      val = New<String>(dst, dlen).ToLocalChecked();\n      delete[] dst;\n      break;\n    }\n\n    case UCS2: {\n      const uint16_t* data = reinterpret_cast<const uint16_t*>(buf);\n      val = New<String>(data, buflen / 2).ToLocalChecked();\n      break;\n    }\n\n    case HEX: {\n      size_t dlen = buflen * 2;\n      char* dst = new char[dlen];\n      size_t written = hex_encode(buf, buflen, dst, dlen);\n      assert(written == dlen);\n\n      val = New<String>(dst, dlen).ToLocalChecked();\n      delete[] dst;\n      break;\n    }\n\n    default:\n      assert(0 && \"unknown encoding\");\n      break;\n  }\n\n  return val;\n}\n\n#undef base64_encoded_size\n\n}  // end of namespace imp\n\n#endif  // NAN_STRING_BYTES_H_\n"
        },
        {
          "name": "nan_typedarray_contents.h",
          "type": "blob",
          "size": 3.0166015625,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_TYPEDARRAY_CONTENTS_H_\n#define NAN_TYPEDARRAY_CONTENTS_H_\n\ntemplate<typename T>\nclass TypedArrayContents {\n public:\n  inline explicit TypedArrayContents(v8::Local<v8::Value> from) :\n      length_(0), data_(NULL) {\n    HandleScope scope;\n\n    size_t length = 0;\n    void*  data = NULL;\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n\n    if (from->IsArrayBufferView()) {\n      v8::Local<v8::ArrayBufferView> array =\n        v8::Local<v8::ArrayBufferView>::Cast(from);\n\n      const size_t    byte_length = array->ByteLength();\n      const ptrdiff_t byte_offset = array->ByteOffset();\n      v8::Local<v8::ArrayBuffer> buffer = array->Buffer();\n\n      length = byte_length / sizeof(T);\n// Actually it's 7.9 here but this would lead to ABI issues with Node.js 13\n// using 7.8 till 13.2.0.\n#if (V8_MAJOR_VERSION >= 8)\n      data = static_cast<char*>(buffer->GetBackingStore()->Data()) + byte_offset;\n#else\n      data = static_cast<char*>(buffer->GetContents().Data()) + byte_offset;\n#endif\n    }\n\n#else\n\n    if (from->IsObject() && !from->IsNull()) {\n      v8::Local<v8::Object> array = v8::Local<v8::Object>::Cast(from);\n\n      MaybeLocal<v8::Value> buffer = Get(array,\n        New<v8::String>(\"buffer\").ToLocalChecked());\n      MaybeLocal<v8::Value> byte_length = Get(array,\n        New<v8::String>(\"byteLength\").ToLocalChecked());\n      MaybeLocal<v8::Value> byte_offset = Get(array,\n        New<v8::String>(\"byteOffset\").ToLocalChecked());\n\n      if (!buffer.IsEmpty() &&\n          !byte_length.IsEmpty() && byte_length.ToLocalChecked()->IsUint32() &&\n          !byte_offset.IsEmpty() && byte_offset.ToLocalChecked()->IsUint32()) {\n        data = array->GetIndexedPropertiesExternalArrayData();\n        if(data) {\n          length = byte_length.ToLocalChecked()->Uint32Value() / sizeof(T);\n        }\n      }\n    }\n\n#endif\n\n#if defined(_MSC_VER) && _MSC_VER >= 1900 || __cplusplus >= 201103L\n    assert(reinterpret_cast<uintptr_t>(data) % alignof (T) == 0);\n#elif defined(_MSC_VER) && _MSC_VER >= 1600 || defined(__GNUC__)\n    assert(reinterpret_cast<uintptr_t>(data) % __alignof(T) == 0);\n#else\n    assert(reinterpret_cast<uintptr_t>(data) % sizeof (T) == 0);\n#endif\n\n    length_ = length;\n    data_   = static_cast<T*>(data);\n  }\n\n  inline size_t length() const      { return length_; }\n  inline T* operator*()             { return data_;   }\n  inline const T* operator*() const { return data_;   }\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(TypedArrayContents)\n\n  //Disable heap allocation\n  void *operator new(size_t size);\n  void operator delete(void *, size_t) {\n    abort();\n  }\n\n  size_t  length_;\n  T*      data_;\n};\n\n#endif  // NAN_TYPEDARRAY_CONTENTS_H_\n"
        },
        {
          "name": "nan_weak.h",
          "type": "blob",
          "size": 14.994140625,
          "content": "/*********************************************************************\n * NAN - Native Abstractions for Node.js\n *\n * Copyright (c) 2018 NAN contributors\n *\n * MIT License <https://github.com/nodejs/nan/blob/master/LICENSE.md>\n ********************************************************************/\n\n#ifndef NAN_WEAK_H_\n#define NAN_WEAK_H_\n\nstatic const int kInternalFieldsInWeakCallback = 2;\nstatic const int kNoInternalFieldIndex = -1;\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n# define NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_ \\\n    v8::WeakCallbackInfo<WeakCallbackInfo<T> > const&\n# define NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_ \\\n    NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_\n# define NAN_WEAK_PARAMETER_CALLBACK_SIG_ NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_\n# define NAN_WEAK_TWOFIELD_CALLBACK_SIG_ NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_\n#elif NODE_MODULE_VERSION > IOJS_1_1_MODULE_VERSION\n# define NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_ \\\n    v8::PhantomCallbackData<WeakCallbackInfo<T> > const&\n# define NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_ \\\n    NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_\n# define NAN_WEAK_PARAMETER_CALLBACK_SIG_ NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_\n# define NAN_WEAK_TWOFIELD_CALLBACK_SIG_ NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_\n#elif NODE_MODULE_VERSION > NODE_0_12_MODULE_VERSION\n# define NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_ \\\n    v8::PhantomCallbackData<WeakCallbackInfo<T> > const&\n# define NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_ \\\n    v8::InternalFieldsCallbackData<WeakCallbackInfo<T>, void> const&\n# define NAN_WEAK_PARAMETER_CALLBACK_SIG_ NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_\n# define NAN_WEAK_TWOFIELD_CALLBACK_SIG_ NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_\n#elif NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n# define NAN_WEAK_CALLBACK_DATA_TYPE_ \\\n    v8::WeakCallbackData<S, WeakCallbackInfo<T> > const&\n# define NAN_WEAK_CALLBACK_SIG_ NAN_WEAK_CALLBACK_DATA_TYPE_\n#else\n# define NAN_WEAK_CALLBACK_DATA_TYPE_ void *\n# define NAN_WEAK_CALLBACK_SIG_ \\\n    v8::Persistent<v8::Value>, NAN_WEAK_CALLBACK_DATA_TYPE_\n#endif\n\ntemplate<typename T>\nclass WeakCallbackInfo {\n public:\n  typedef void (*Callback)(const WeakCallbackInfo<T>& data);\n  WeakCallbackInfo(\n      Persistent<v8::Value> *persistent\n    , Callback callback\n    , void *parameter\n    , void *field1 = 0\n    , void *field2 = 0) :\n        callback_(callback), isolate_(0), parameter_(parameter) {\n    std::memcpy(&persistent_, persistent, sizeof (v8::Persistent<v8::Value>));\n    internal_fields_[0] = field1;\n    internal_fields_[1] = field2;\n  }\n  inline v8::Isolate *GetIsolate() const { return isolate_; }\n  inline T *GetParameter() const { return static_cast<T*>(parameter_); }\n  inline void *GetInternalField(int index) const {\n    assert((index == 0 || index == 1) && \"internal field index out of bounds\");\n    if (index == 0) {\n      return internal_fields_[0];\n    } else {\n      return internal_fields_[1];\n    }\n  }\n\n private:\n  NAN_DISALLOW_ASSIGN_COPY_MOVE(WeakCallbackInfo)\n  Callback callback_;\n  v8::Isolate *isolate_;\n  void *parameter_;\n  void *internal_fields_[kInternalFieldsInWeakCallback];\n  v8::Persistent<v8::Value> persistent_;\n  template<typename S, typename M> friend class Persistent;\n  template<typename S> friend class PersistentBase;\n#if NODE_MODULE_VERSION <= NODE_0_12_MODULE_VERSION\n# if NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n  template<typename S>\n  static void invoke(NAN_WEAK_CALLBACK_SIG_ data);\n  template<typename S>\n  static WeakCallbackInfo *unwrap(NAN_WEAK_CALLBACK_DATA_TYPE_ data);\n# else\n  static void invoke(NAN_WEAK_CALLBACK_SIG_ data);\n  static WeakCallbackInfo *unwrap(NAN_WEAK_CALLBACK_DATA_TYPE_ data);\n# endif\n#else\n# if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                     \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n  template<bool isFirstPass>\n  static void invokeparameter(NAN_WEAK_PARAMETER_CALLBACK_SIG_ data);\n  template<bool isFirstPass>\n  static void invoketwofield(NAN_WEAK_TWOFIELD_CALLBACK_SIG_ data);\n# else\n  static void invokeparameter(NAN_WEAK_PARAMETER_CALLBACK_SIG_ data);\n  static void invoketwofield(NAN_WEAK_TWOFIELD_CALLBACK_SIG_ data);\n# endif\n  static WeakCallbackInfo *unwrapparameter(\n      NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_ data);\n  static WeakCallbackInfo *unwraptwofield(\n      NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_ data);\n#endif\n};\n\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\n\ntemplate<typename T>\ntemplate<bool isFirstPass>\nvoid\nWeakCallbackInfo<T>::invokeparameter(NAN_WEAK_PARAMETER_CALLBACK_SIG_ data) {\n  WeakCallbackInfo<T> *cbinfo = unwrapparameter(data);\n  if (isFirstPass) {\n    cbinfo->persistent_.Reset();\n    data.SetSecondPassCallback(invokeparameter<false>);\n  } else {\n    cbinfo->callback_(*cbinfo);\n    delete cbinfo;\n  }\n}\n\ntemplate<typename T>\ntemplate<bool isFirstPass>\nvoid\nWeakCallbackInfo<T>::invoketwofield(NAN_WEAK_TWOFIELD_CALLBACK_SIG_ data) {\n  WeakCallbackInfo<T> *cbinfo = unwraptwofield(data);\n  if (isFirstPass) {\n    cbinfo->persistent_.Reset();\n    data.SetSecondPassCallback(invoketwofield<false>);\n  } else {\n    cbinfo->callback_(*cbinfo);\n    delete cbinfo;\n  }\n}\n\ntemplate<typename T>\nWeakCallbackInfo<T> *WeakCallbackInfo<T>::unwrapparameter(\n    NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_ data) {\n  WeakCallbackInfo<T> *cbinfo =\n      static_cast<WeakCallbackInfo<T>*>(data.GetParameter());\n  cbinfo->isolate_ = data.GetIsolate();\n  return cbinfo;\n}\n\ntemplate<typename T>\nWeakCallbackInfo<T> *WeakCallbackInfo<T>::unwraptwofield(\n    NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_ data) {\n  WeakCallbackInfo<T> *cbinfo =\n      static_cast<WeakCallbackInfo<T>*>(data.GetInternalField(0));\n  cbinfo->isolate_ = data.GetIsolate();\n  return cbinfo;\n}\n\n#undef NAN_WEAK_PARAMETER_CALLBACK_SIG_\n#undef NAN_WEAK_TWOFIELD_CALLBACK_SIG_\n#undef NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_\n#undef NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_\n# elif NODE_MODULE_VERSION > NODE_0_12_MODULE_VERSION\n\ntemplate<typename T>\nvoid\nWeakCallbackInfo<T>::invokeparameter(NAN_WEAK_PARAMETER_CALLBACK_SIG_ data) {\n  WeakCallbackInfo<T> *cbinfo = unwrapparameter(data);\n  cbinfo->persistent_.Reset();\n  cbinfo->callback_(*cbinfo);\n  delete cbinfo;\n}\n\ntemplate<typename T>\nvoid\nWeakCallbackInfo<T>::invoketwofield(NAN_WEAK_TWOFIELD_CALLBACK_SIG_ data) {\n  WeakCallbackInfo<T> *cbinfo = unwraptwofield(data);\n  cbinfo->persistent_.Reset();\n  cbinfo->callback_(*cbinfo);\n  delete cbinfo;\n}\n\ntemplate<typename T>\nWeakCallbackInfo<T> *WeakCallbackInfo<T>::unwrapparameter(\n    NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_ data) {\n  WeakCallbackInfo<T> *cbinfo =\n       static_cast<WeakCallbackInfo<T>*>(data.GetParameter());\n  cbinfo->isolate_ = data.GetIsolate();\n  return cbinfo;\n}\n\ntemplate<typename T>\nWeakCallbackInfo<T> *WeakCallbackInfo<T>::unwraptwofield(\n    NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_ data) {\n  WeakCallbackInfo<T> *cbinfo =\n       static_cast<WeakCallbackInfo<T>*>(data.GetInternalField1());\n  cbinfo->isolate_ = data.GetIsolate();\n  return cbinfo;\n}\n\n#undef NAN_WEAK_PARAMETER_CALLBACK_SIG_\n#undef NAN_WEAK_TWOFIELD_CALLBACK_SIG_\n#undef NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_\n#undef NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_\n#elif NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\n\ntemplate<typename T>\ntemplate<typename S>\nvoid WeakCallbackInfo<T>::invoke(NAN_WEAK_CALLBACK_SIG_ data) {\n  WeakCallbackInfo<T> *cbinfo = unwrap(data);\n  cbinfo->persistent_.Reset();\n  cbinfo->callback_(*cbinfo);\n  delete cbinfo;\n}\n\ntemplate<typename T>\ntemplate<typename S>\nWeakCallbackInfo<T> *WeakCallbackInfo<T>::unwrap(\n    NAN_WEAK_CALLBACK_DATA_TYPE_ data) {\n  void *parameter = data.GetParameter();\n  WeakCallbackInfo<T> *cbinfo =\n      static_cast<WeakCallbackInfo<T>*>(parameter);\n  cbinfo->isolate_ = data.GetIsolate();\n  return cbinfo;\n}\n\n#undef NAN_WEAK_CALLBACK_SIG_\n#undef NAN_WEAK_CALLBACK_DATA_TYPE_\n#else\n\ntemplate<typename T>\nvoid WeakCallbackInfo<T>::invoke(NAN_WEAK_CALLBACK_SIG_ data) {\n  WeakCallbackInfo<T> *cbinfo = unwrap(data);\n  cbinfo->persistent_.Dispose();\n  cbinfo->persistent_.Clear();\n  cbinfo->callback_(*cbinfo);\n  delete cbinfo;\n}\n\ntemplate<typename T>\nWeakCallbackInfo<T> *WeakCallbackInfo<T>::unwrap(\n    NAN_WEAK_CALLBACK_DATA_TYPE_ data) {\n  WeakCallbackInfo<T> *cbinfo =\n      static_cast<WeakCallbackInfo<T>*>(data);\n  cbinfo->isolate_ = v8::Isolate::GetCurrent();\n  return cbinfo;\n}\n\n#undef NAN_WEAK_CALLBACK_SIG_\n#undef NAN_WEAK_CALLBACK_DATA_TYPE_\n#endif\n\n#if defined(V8_MAJOR_VERSION) && (V8_MAJOR_VERSION > 4 ||                      \\\n  (V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3))\ntemplate<typename T, typename M>\ntemplate<typename P>\ninline void Persistent<T, M>::SetWeak(\n    P *parameter\n  , typename WeakCallbackInfo<P>::Callback callback\n  , WeakCallbackType type) {\n  WeakCallbackInfo<P> *wcbd;\n  if (type == WeakCallbackType::kParameter) {\n    wcbd = new WeakCallbackInfo<P>(\n        reinterpret_cast<Persistent<v8::Value>*>(this)\n      , callback\n      , parameter);\n    v8::PersistentBase<T>::SetWeak(\n        wcbd\n      , WeakCallbackInfo<P>::template invokeparameter<true>\n      , type);\n  } else {\n    v8::Local<v8::Value>* self_v(reinterpret_cast<v8::Local<v8::Value>*>(this));\n    assert((*self_v)->IsObject());\n    v8::Local<v8::Object> self((*self_v).As<v8::Object>());\n    int count = self->InternalFieldCount();\n    void *internal_fields[kInternalFieldsInWeakCallback] = {0, 0};\n    for (int i = 0; i < count && i < kInternalFieldsInWeakCallback; i++) {\n      internal_fields[i] = self->GetAlignedPointerFromInternalField(i);\n    }\n    wcbd = new WeakCallbackInfo<P>(\n        reinterpret_cast<Persistent<v8::Value>*>(this)\n      , callback\n      , 0\n      , internal_fields[0]\n      , internal_fields[1]);\n    self->SetAlignedPointerInInternalField(0, wcbd);\n    v8::PersistentBase<T>::SetWeak(\n        static_cast<WeakCallbackInfo<P>*>(0)\n      , WeakCallbackInfo<P>::template invoketwofield<true>\n      , type);\n  }\n}\n#elif NODE_MODULE_VERSION > IOJS_1_1_MODULE_VERSION\ntemplate<typename T, typename M>\ntemplate<typename P>\ninline void Persistent<T, M>::SetWeak(\n    P *parameter\n  , typename WeakCallbackInfo<P>::Callback callback\n  , WeakCallbackType type) {\n  WeakCallbackInfo<P> *wcbd;\n  if (type == WeakCallbackType::kParameter) {\n    wcbd = new WeakCallbackInfo<P>(\n        reinterpret_cast<Persistent<v8::Value>*>(this)\n      , callback\n      , parameter);\n    v8::PersistentBase<T>::SetPhantom(\n        wcbd\n      , WeakCallbackInfo<P>::invokeparameter);\n  } else {\n    v8::Local<v8::Value>* self_v(reinterpret_cast<v8::Local<v8::Value>*>(this));\n    assert((*self_v)->IsObject());\n    v8::Local<v8::Object> self((*self_v).As<v8::Object>());\n    int count = self->InternalFieldCount();\n    void *internal_fields[kInternalFieldsInWeakCallback] = {0, 0};\n    for (int i = 0; i < count && i < kInternalFieldsInWeakCallback; i++) {\n      internal_fields[i] = self->GetAlignedPointerFromInternalField(i);\n    }\n    wcbd = new WeakCallbackInfo<P>(\n        reinterpret_cast<Persistent<v8::Value>*>(this)\n      , callback\n      , 0\n      , internal_fields[0]\n      , internal_fields[1]);\n    self->SetAlignedPointerInInternalField(0, wcbd);\n    v8::PersistentBase<T>::SetPhantom(\n        static_cast<WeakCallbackInfo<P>*>(0)\n      , WeakCallbackInfo<P>::invoketwofield\n      , 0\n      , count > 1 ? 1 : kNoInternalFieldIndex);\n  }\n}\n#elif NODE_MODULE_VERSION > NODE_0_12_MODULE_VERSION\ntemplate<typename T, typename M>\ntemplate<typename P>\ninline void Persistent<T, M>::SetWeak(\n    P *parameter\n  , typename WeakCallbackInfo<P>::Callback callback\n  , WeakCallbackType type) {\n  WeakCallbackInfo<P> *wcbd;\n  if (type == WeakCallbackType::kParameter) {\n    wcbd = new WeakCallbackInfo<P>(\n        reinterpret_cast<Persistent<v8::Value>*>(this)\n      , callback\n      , parameter);\n    v8::PersistentBase<T>::SetPhantom(\n        wcbd\n      , WeakCallbackInfo<P>::invokeparameter);\n  } else {\n    v8::Local<v8::Value>* self_v(reinterpret_cast<v8::Local<v8::Value>*>(this));\n    assert((*self_v)->IsObject());\n    v8::Local<v8::Object> self((*self_v).As<v8::Object>());\n    int count = self->InternalFieldCount();\n    void *internal_fields[kInternalFieldsInWeakCallback] = {0, 0};\n    for (int i = 0; i < count && i < kInternalFieldsInWeakCallback; i++) {\n      internal_fields[i] = self->GetAlignedPointerFromInternalField(i);\n    }\n    wcbd = new WeakCallbackInfo<P>(\n        reinterpret_cast<Persistent<v8::Value>*>(this)\n      , callback\n      , 0\n      , internal_fields[0]\n      , internal_fields[1]);\n    self->SetAlignedPointerInInternalField(0, wcbd);\n    v8::PersistentBase<T>::SetPhantom(\n        WeakCallbackInfo<P>::invoketwofield\n      , 0\n      , count > 1 ? 1 : kNoInternalFieldIndex);\n  }\n}\n#elif NODE_MODULE_VERSION > NODE_0_10_MODULE_VERSION\ntemplate<typename T, typename M>\ntemplate<typename P>\ninline void Persistent<T, M>::SetWeak(\n    P *parameter\n  , typename WeakCallbackInfo<P>::Callback callback\n  , WeakCallbackType type) {\n  WeakCallbackInfo<P> *wcbd;\n  if (type == WeakCallbackType::kParameter) {\n    wcbd = new WeakCallbackInfo<P>(\n        reinterpret_cast<Persistent<v8::Value>*>(this)\n      , callback\n      , parameter);\n    v8::PersistentBase<T>::SetWeak(wcbd, WeakCallbackInfo<P>::invoke);\n  } else {\n    v8::Local<v8::Value>* self_v(reinterpret_cast<v8::Local<v8::Value>*>(this));\n    assert((*self_v)->IsObject());\n    v8::Local<v8::Object> self((*self_v).As<v8::Object>());\n    int count = self->InternalFieldCount();\n    void *internal_fields[kInternalFieldsInWeakCallback] = {0, 0};\n    for (int i = 0; i < count && i < kInternalFieldsInWeakCallback; i++) {\n      internal_fields[i] = self->GetAlignedPointerFromInternalField(i);\n    }\n    wcbd = new WeakCallbackInfo<P>(\n        reinterpret_cast<Persistent<v8::Value>*>(this)\n      , callback\n      , 0\n      , internal_fields[0]\n      , internal_fields[1]);\n    v8::PersistentBase<T>::SetWeak(wcbd, WeakCallbackInfo<P>::invoke);\n  }\n}\n#else\ntemplate<typename T>\ntemplate<typename P>\ninline void PersistentBase<T>::SetWeak(\n    P *parameter\n  , typename WeakCallbackInfo<P>::Callback callback\n  , WeakCallbackType type) {\n  WeakCallbackInfo<P> *wcbd;\n  if (type == WeakCallbackType::kParameter) {\n    wcbd = new WeakCallbackInfo<P>(\n        reinterpret_cast<Persistent<v8::Value>*>(this)\n      , callback\n      , parameter);\n    persistent.MakeWeak(wcbd, WeakCallbackInfo<P>::invoke);\n  } else {\n    v8::Local<v8::Value>* self_v(reinterpret_cast<v8::Local<v8::Value>*>(this));\n    assert((*self_v)->IsObject());\n    v8::Local<v8::Object> self((*self_v).As<v8::Object>());\n    int count = self->InternalFieldCount();\n    void *internal_fields[kInternalFieldsInWeakCallback] = {0, 0};\n    for (int i = 0; i < count && i < kInternalFieldsInWeakCallback; i++) {\n      internal_fields[i] = self->GetPointerFromInternalField(i);\n    }\n    wcbd = new WeakCallbackInfo<P>(\n        reinterpret_cast<Persistent<v8::Value>*>(this)\n      , callback\n      , 0\n      , internal_fields[0]\n      , internal_fields[1]);\n    persistent.MakeWeak(wcbd, WeakCallbackInfo<P>::invoke);\n  }\n}\n#endif\n\n#endif  // NAN_WEAK_H_\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.4033203125,
          "content": "{\n  \"name\": \"nan\",\n  \"version\": \"2.22.0\",\n  \"description\": \"Native Abstractions for Node.js: C++ header for Node 0.8 -> 23 compatibility\",\n  \"main\": \"include_dirs.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/nodejs/nan.git\"\n  },\n  \"scripts\": {\n    \"test\": \"tap --gc --stderr test/js/*-test.js\",\n    \"test:worker\": \"node --experimental-worker test/tap-as-worker.js --gc --stderr test/js/*-test.js\",\n    \"rebuild-tests-2015\": \"node-gyp rebuild --msvs_version=2015 --directory test\",\n    \"rebuild-tests\": \"node-gyp rebuild --directory test\",\n    \"docs\": \"doc/.build.sh\"\n  },\n  \"contributors\": [\n    \"Rod Vagg <r@va.gg> (https://github.com/rvagg)\",\n    \"Benjamin Byholm <bbyholm@abo.fi> (https://github.com/kkoopa/)\",\n    \"Trevor Norris <trev.norris@gmail.com> (https://github.com/trevnorris)\",\n    \"Nathan Rajlich <nathan@tootallnate.net> (https://github.com/TooTallNate)\",\n    \"Brett Lawson <brett19@gmail.com> (https://github.com/brett19)\",\n    \"Ben Noordhuis <info@bnoordhuis.nl> (https://github.com/bnoordhuis)\",\n    \"David Siegel <david@artcom.de> (https://github.com/agnat)\",\n    \"Michael Ira Krufky <mkrufky@gmail.com> (https://github.com/mkrufky)\"\n  ],\n  \"devDependencies\": {\n    \"bindings\": \"~1.2.1\",\n    \"commander\": \"^2.8.1\",\n    \"glob\": \"^5.0.14\",\n    \"request\": \"=2.81.0\",\n    \"node-gyp\": \"~8.4.1\",\n    \"readable-stream\": \"^2.1.4\",\n    \"tap\": \"~0.7.1\",\n    \"xtend\": \"~4.0.0\"\n  },\n  \"license\": \"MIT\"\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}