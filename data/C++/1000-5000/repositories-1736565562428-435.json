{
  "metadata": {
    "timestamp": 1736565562428,
    "page": 435,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "facebook/wdt",
      "stars": 2883,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.2099609375,
          "content": "---\nBasedOnStyle: Google\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: false\n#IndentWidth: 4\nUseTab: Never\nStandard: Cpp11\n#SortIncludes: false\n...\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.1640625,
          "content": "sudo: false\n\nlanguage: cpp\n\nos:\n  - linux\n  - osx\n\n# Need >= xcode9 to build folly\nosx_image: xcode9.4\n\n# Need >= gcc 5 to build folly\ndist: xenial\n\ncompiler:\n  - clang\n  - gcc\n\naddons:\n  apt:\n    sources:\n      - boost-latest\n    packages:\n      - libboost-system-dev\n      - libboost-filesystem-dev\n      - libssl-dev\n\nscript:\n  # Debug\n  - date ; uname -a ; pwd ; ls -l ..; echo $HOSTNAME\n  # Build\n  - mkdir ../build && cd ../build\n  - echo $PATH; echo $LD_LIBRARY_PATH\n  - which $CXX\n  - cmake ../wdt -DBUILD_TESTING=1\n  #- make -j 4 VERBOSE=1\n  - make -j 4\n  #- WDT_TEST_SYMLINKS=0 CTEST_OUTPUT_ON_FAILURE=1 make test\n  - CTEST_OUTPUT_ON_FAILURE=1 make test\n  # to see the full output/debug:\n  #- ../wdt_e2e_simple_test.sh\n\nbefore_install:\n  - echo \"Travis os name $TRAVIS_OS_NAME\"\n  # will change PATH so we find cmake,...\n  - source ./build/travis_${TRAVIS_OS_NAME}.sh\n\nnotifications:\n  webhooks:\n    urls:\n      - https://webhooks.gitter.im/e/573ed195be620cb76847\n    on_success: change  # options: [always|never|change] default: always\n    on_failure: always  # options: [always|never|change] default: always\n    on_start: never     # options: [always|never|change] default: always\n"
        },
        {
          "name": "AbortChecker.h",
          "type": "blob",
          "size": 0.830078125,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n#include <atomic>\n\nnamespace facebook {\nnamespace wdt {\n\n/// Interface for external abort checks (pull mode)\nclass IAbortChecker {\n public:\n  virtual bool shouldAbort() const = 0;\n  virtual ~IAbortChecker() {\n  }\n};\n\n/// A sample abort checker using std::atomic for abort\nclass WdtAbortChecker : public IAbortChecker {\n public:\n  explicit WdtAbortChecker(const std::atomic<bool> &abortTrigger)\n      : abortTriggerPtr_(&abortTrigger) {\n  }\n  bool shouldAbort() const override {\n    return abortTriggerPtr_->load();\n  }\n\n private:\n  std::atomic<bool> const *abortTriggerPtr_;\n};\n\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "ByteSource.h",
          "type": "blob",
          "size": 3.5966796875,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n#include <wdt/Protocol.h>\n#include <wdt/util/CommonImpl.h>\n\n#include <string>\n\nnamespace facebook {\nnamespace wdt {\n\n/// struct representing file level data shared between blocks\nstruct SourceMetaData {\n  SourceMetaData() {\n  }\n\n  /// Delete copy constructor and assignment operator\n  SourceMetaData(const SourceMetaData &that) = delete;\n  SourceMetaData &operator=(const SourceMetaData &that) = delete;\n\n  /// full filepath\n  std::string fullPath;\n  /// relative pathname\n  std::string relPath;\n  /**\n   * Sequence number associated with the file. Sequence number\n   * represents the order in which files were first added to the queue.\n   * This is a file level identifier. It is same for blocks belonging\n   * to the same file. This is efficient while using in sets. Instead\n   * of using full path of the file, we can use this to identify the\n   * file. First valid sequence id is 1\n   */\n  int64_t seqId{0};\n  /// size of the entire source\n  int64_t size{0};\n  /// file allocation status in the receiver side\n  FileAllocationStatus allocationStatus{NOT_EXISTS};\n  /// if there is a size mismatch, this is the previous sequence id\n  int64_t prevSeqId{0};\n  /// If true, files are read using O_DIRECT or F_NOCACHE\n  bool directReads{false};\n  /// File descriptor. If this is not -1, then wdt uses this to read\n  int fd{-1};\n  /// If true, fd was opened by wdt and must be closed after transfer finish\n  bool needToClose{false};\n};\n\nclass ByteSource {\n public:\n  virtual ~ByteSource() {\n  }\n\n  /// @return identifier for the source\n  virtual const std::string &getIdentifier() const = 0;\n\n  /// @return number of bytes in this source\n  virtual int64_t getSize() const = 0;\n\n  /// @return offset from which to start reading\n  virtual int64_t getOffset() const = 0;\n\n  /// @return metadata for the source\n  virtual const SourceMetaData &getMetaData() const = 0;\n\n  /// @return true iff all data read successfully\n  virtual bool finished() const = 0;\n\n  /// @return true iff there was an error reading\n  virtual bool hasError() const = 0;\n\n  /**\n   * Read chunk of data from the source and return a pointer to data and its\n   * size. Memory is owned by the source. Subsequent calls to read() might\n   * delete the previously read data so make sure to consume all data between\n   * calls to read().\n   *\n   * @param size      will be set to number of bytes read (the source will\n   *                  decide how much data to read at once)\n   *\n   * @return          pointer to the data read; in case of failure or EOF,\n   *                  nullptr will be returned and size will be set to 0;\n   *                  use finished() and hasError() members to distinguish\n   *                  the two cases\n   */\n  virtual char *read(int64_t &size) = 0;\n\n  /// Advances ByteSource offset by numBytes\n  virtual void advanceOffset(int64_t numBytes) = 0;\n\n  /**\n   * open the source for reading\n   *\n   * @param threadCtx    context of the calling thread\n   *\n   * @return      error code\n   */\n  virtual ErrorCode open(ThreadCtx *threadCtx) = 0;\n\n  /// close the source for reading\n  virtual void close() = 0;\n\n  /**\n   * @return transfer stats for the source. If the stats is moved by the\n   *         caller, then this function can not be called again\n   */\n  virtual TransferStats &getTransferStats() = 0;\n\n  /// @param stats    Stats to be added\n  virtual void addTransferStats(const TransferStats &stats) = 0;\n};\n\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 15.748046875,
          "content": "# CMake build file - use CMake 3.2 or later to build WDT and its dependencies.\n#\n# mkdir build; cd build; cmake .. -DBUILD_TESTING=on; make -j\n# omit -DBUILD_TESTING=on if you don't want the extra dependencies for\n# testing (but testing is good !)\n# (at fb:\n# cd local; mkdir wdt_build; cd wdt_build\n# cmake31 ~/fbcode/wdt -DFOLLY_SOURCE_DIR=$HOME/fbcode -DBUILD_TESTING=on\n# make -j\n# )\n#\n#  Copyright (c) 2014-present, Facebook, Inc.\n#  All rights reserved.\n#\n#  This source code is licensed under the BSD-style license found in the\n#  LICENSE file in the root directory of this source tree.\n#\n\ncmake_minimum_required(VERSION 3.2)\n\n# There is no C per se in WDT but if you use CXX only here many checks fail\n# Version is Major.Minor.YYMMDDX for up to 10 releases per day (X from 0 to 9)\n# Minor currently is also the protocol version - has to match with Protocol.cpp\nproject(\"WDT\" LANGUAGES C CXX VERSION 1.32.1910230)\n\n# WDT uses C++17 features per fdbc5432230290f86ff8ad89ab52d5b7fef232b4\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED on)\n\n# somehow 'option' for this doesn't seeem to work/I don't know how to make it\nset(BUILD_SHARED_LIBS on CACHE BOOL \"build shared libs\")\n\n# CMake default behavior should be to set rpath when needed (non system install)\n# it's not so let's set this for now:\nset(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)\nset(CMAKE_INSTALL_RPATH \"${CMAKE_INSTALL_PREFIX}/lib\")\n\nset(WDT_USE_SYSTEM_FOLLY Off CACHE BOOL \"Use folly library from system (default off)\")\n\n# Optimized by default\n# TODO: This doesn't seem to work / sets default to \"\" instead of Release...\n# set(CMAKE_BUILD_TYPE Release CACHE String \"build type\")\n# So hardcoding for now:\n#set(CMAKE_BUILD_TYPE Debug)\nset(CMAKE_BUILD_TYPE Release)\nset(CMAKE_CXX_FLAGS \"-msse4.2 -mpclmul\")\n#set(CMAKE_CXX_FLAGS \"-msse4.2 -mpclmul -Wextra -Wsign-compare -Wunused-variable\")\n#set(CMAKE_CXX_FLAGS \"-msse4.2 -mpclmul -Wextra -Wsign-compare -Wunused-variable -Wconversion -Wsign-conversion\")\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY \"_bin/wdt\")\n\nif (NOT WDT_USE_SYSTEM_FOLLY)\n  # Check that we have the Folly source tree\n  set(FOLLY_SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../folly\" CACHE PATH\n      \"Folly source tree (folly/Conv.h should be reachable from there\")\n  # Check for folly - TODO: this doesn't work well for relative paths\n  # (because of relative to build dir vs relative to source tree for -I)\n  if(NOT EXISTS \"${FOLLY_SOURCE_DIR}/folly/Conv.h\")\n    MESSAGE(FATAL_ERROR \"${FOLLY_SOURCE_DIR}/folly/Conv.h not found\n  Fix using:\n  (in a sister directory of the wdt source tree - same level:)\n  git clone https://github.com/facebook/folly.git\n  or change FOLLY_SOURCE_DIR (use ccmake or -DFOLLY_SOURCE_DIR=...)\n  or change WDT_USE_SYSTEM_FOLLY (use ccmake or -DWDT_USE_SYSTEM_FOLLY=...)\n  \")\n  endif()\n\n\n  # The part of folly that isn't pure .h and we use:\n  set (FOLLY_CPP_SRC\n  \"${FOLLY_SOURCE_DIR}/folly/Conv.cpp\"\n  \"${FOLLY_SOURCE_DIR}/folly/Demangle.cpp\"\n  \"${FOLLY_SOURCE_DIR}/folly/lang/CString.cpp\"\n  \"${FOLLY_SOURCE_DIR}/folly/lang/ToAscii.cpp\"\n  \"${FOLLY_SOURCE_DIR}/folly/hash/Checksum.cpp\"\n  \"${FOLLY_SOURCE_DIR}/folly/hash/detail/ChecksumDetail.cpp\"\n  \"${FOLLY_SOURCE_DIR}/folly/hash/detail/Crc32cDetail.cpp\"\n  \"${FOLLY_SOURCE_DIR}/folly/hash/detail/Crc32CombineDetail.cpp\"\n  \"${FOLLY_SOURCE_DIR}/folly/ScopeGuard.cpp\"\n  \"${FOLLY_SOURCE_DIR}/folly/detail/SplitStringSimd.cpp\"\n  )\nendif()\n\n# WDT's library proper - comes from: ls -1 *.cpp | grep -iv test\nadd_library(wdt_min\nutil/WdtSocket.cpp\nutil/ClientSocket.cpp\nutil/EncryptionUtils.cpp\nutil/DirectorySourceQueue.cpp\nErrorCodes.cpp\nutil/FileByteSource.cpp\nutil/FileCreator.cpp\nProtocol.cpp\nWdtThread.cpp\nutil/ThreadsController.cpp\nReceiverThread.cpp\nReceiver.cpp\nWdtTransferRequest.cpp\nReporting.cpp\nutil/ThreadTransferHistory.cpp\nSenderThread.cpp\nSender.cpp\nutil/ServerSocket.cpp\nThrottler.cpp\nWdtOptions.cpp\nutil/FileWriter.cpp\nutil/TransferLogManager.cpp\nutil/SerializationUtil.cpp\nutil/Stats.cpp\nWdtBase.cpp\nWdtResourceController.cpp\nutil/CommonImpl.cpp\n)\n# Source files that depend on gflags and provide flags -> options init\nset (WDT_FLAGS_RELATED_SRC\nutil/WdtFlags.cpp\nWdt.cpp\n)\nadd_library(wdt ${WDT_FLAGS_RELATED_SRC})\n\nset_property(TARGET wdt PROPERTY VERSION ${PROJECT_VERSION})\nset_property(TARGET wdt_min PROPERTY VERSION ${PROJECT_VERSION})\ntarget_link_libraries(wdt wdt_min)\n\n\n\n# Folly uses boost system and filesystem\n#set(Boost_USE_STATIC_LIBS on)\nfind_package(Boost COMPONENTS system filesystem REQUIRED)\ninclude_directories(${Boost_INCLUDE_DIRS})\n\n# We use std:: threads\nfind_package(Threads) # this will set ${CMAKE_THREAD_LIBS_INIT} (ie pthreads)\n\n\n# double-conversion\nfind_path(DOUBLECONV_INCLUDE_DIR double-conversion/double-conversion.h)\nfind_library(DOUBLECONV_LIBRARY double-conversion)\n# Glog\nfind_path(GLOG_INCLUDE_DIR glog/logging.h)\nfind_library(GLOG_LIBRARY glog)\n# Gflags\nfind_path(GFLAGS_INCLUDE_DIR gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY gflags)\n# GFLAGS_NAMESPACE is defined in most releases but not in all\ninclude(CheckCXXSymbolExists)\nlist(APPEND CMAKE_REQUIRED_INCLUDES \"${GFLAGS_INCLUDE_DIR}/\")\nlist(APPEND CMAKE_REQUIRED_LIBRARIES \"${GFLAGS_LIBRARY}\")\ncheck_cxx_symbol_exists(GFLAGS_NAMESPACE \"gflags/gflags.h\" CMAKE_GFLAGS_NAMESPACE)\nif (NOT CMAKE_GFLAGS_NAMESPACE)\n  check_cxx_symbol_exists(gflags::GetArgv \"gflags/gflags.h\" CMAKE_GFLAGS_GFLAGS_GETARGV)\n  if (CMAKE_GFLAGS_GFLAGS_GETARGV)\n    add_definitions(\"-DGFLAGS_NAMESPACE=gflags\")\n  else()\n    check_cxx_symbol_exists(google::GetArgv \"gflags/gflags.h\" CMAKE_GFLAGS_GOOGLE_GETARGV)\n    if (CMAKE_GFLAGS_GOOGLE_GETARGV)\n      add_definitions(\"-DGFLAGS_NAMESPACE=google\")\n    endif()\n  endif()\nendif()\nlist(REMOVE_ITEM CMAKE_REQUIRED_INCLUDES \"${GFLAGS_INCLUDE_DIR}/\")\nlist(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES \"${GFLAGS_LIBRARY}\")\n# OpenSSL's crypto lib\nfind_package(OpenSSL REQUIRED)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n# System Folly\nif (WDT_USE_SYSTEM_FOLLY)\n  find_path(FOLLY_INCLUDE_DIR folly/Conv.h)\n  find_library(FOLLY_LIBRARY folly)\nelse()\n  set(FOLLY_LIBRARY folly4wdt)\n  set(FOLLY_INCLUDE_DIR \"${FOLLY_SOURCE_DIR}\")\nendif()\n\n# You can also add jemalloc to the list if you have it/want it\ntarget_link_libraries(wdt_min\n  ${FOLLY_LIBRARY}\n  ${GLOG_LIBRARY}\n  ${GFLAGS_LIBRARY}\n  ${Boost_LIBRARIES}\n  ${DOUBLECONV_LIBRARY}\n  ${OPENSSL_CRYPTO_LIBRARY}\n  ${CMAKE_THREAD_LIBS_INIT} # Must be last to avoid link errors\n)\n\n# What we need to build the part of folly we use:\n\ninclude(CheckIncludeFileCXX)\ninclude(CheckFunctionExists)\ninclude(CheckLibraryExists)\ninclude(CheckCXXSourceCompiles)\n# For WDT itself:\ncheck_function_exists(posix_fallocate HAS_POSIX_FALLOCATE)\ncheck_function_exists(sync_file_range HAS_SYNC_FILE_RANGE)\ncheck_function_exists(posix_memalign HAS_POSIX_MEMALIGN)\ncheck_function_exists(posix_fadvise HAS_POSIX_FADVISE)\n# C based check (which fail with the c++ setting thereafter...)\ncheck_function_exists(clock_gettime FOLLY_HAVE_CLOCK_GETTIME)\n# was: check_library_exists(rt clock_gettime \"\" FOLLY_HAVE_CLOCK_GETTIME)\nset(SAVE_CMRL ${CMAKE_REQUIRED_LIBRARIES}) #globals are evil/ugly\nset(CMAKE_REQUIRED_LIBRARIES ${CMAKE_THREAD_LIBS_INIT})\ncheck_function_exists(pthread_atfork FOLLY_HAVE_PTHREAD_ATFORK)\nset(CMAKE_REQUIRED_LIBRARIES ${SAVE_CMRL}) #globals are evil/ugly\n# Needed until Cmake issue #15361 is addressed\n# All the check_function_exists should be before this line\n# or else they will not work'\n\nset(CMAKE_REQUIRED_DEFINITIONS ${CMAKE_CXX11_STANDARD_COMPILE_OPTION})\ncheck_include_file_cxx(linux/sockios.h WDT_HAS_SOCKIOS_H)\n#check_function_exists(clock_gettime FOLLY_HAVE_CLOCK_GETTIME)\ncheck_cxx_source_compiles(\n\"extern \\\"C\\\" void cmkcheckweak() __attribute__((weak));\nint main(int argc, char** argv) {\n  return (cmkcheckweak) ? 1 : 0 ;\n}\" FOLLY_HAVE_WEAK_SYMBOLS)\n# Now record all this :\n# Folly's:\nconfigure_file(build/folly-config.h.in folly/folly-config.h)\n# Wdt's config/version\nconfigure_file(WdtConfig.h.in wdt/WdtConfig.h)\n\nif (NOT WDT_USE_SYSTEM_FOLLY)\n  # Malloc stuff  tied to not supporting weaksympbols\n  if (NOT FOLLY_HAVE_WEAK_SYMBOLS)\n    list(APPEND FOLLY_CPP_SRC \"${FOLLY_SOURCE_DIR}/folly/memory/detail/MallocImpl.cpp\")\n    message(STATUS \"no weak symbols, adding MallocImpl to folly src\")\n  endif()\n\n  add_library(folly4wdt ${FOLLY_CPP_SRC})\n  target_link_libraries(folly4wdt ${GLOG_LIBRARY} ${DOUBLECONV_LIBRARY})\nendif()\n\n# Order is important - inside fb we want the above\n# folly-config.h to be picked up instead of the fbcode one\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\ninclude_directories(${FOLLY_INCLUDE_DIR})\ninclude_directories(${DOUBLECONV_INCLUDE_DIR})\ninclude_directories(${GLOG_INCLUDE_DIR})\ninclude_directories(${GFLAGS_INCLUDE_DIR})\ninclude_directories(${CMAKE_CURRENT_SOURCE_DIR}/..)\n\nadd_executable(wdtbin wdtCmdLine.cpp ${WDT_FLAGS_RELATED_SRC})\nset_target_properties(wdtbin PROPERTIES COMPILE_DEFINITIONS \"STANDALONE_APP\")\n\ntarget_link_libraries(wdtbin wdt_min)\n\n### Install rules\nset_target_properties(wdtbin PROPERTIES RUNTIME_OUTPUT_NAME \"wdt\")\ninstall(TARGETS wdtbin wdt wdt_min\n  RUNTIME DESTINATION bin\n  LIBRARY DESTINATION lib\n  ARCHIVE DESTINATION lib\n  )\n\nif (NOT WDT_USE_SYSTEM_FOLLY)\n  install(TARGETS folly4wdt\n    RUNTIME DESTINATION bin\n    LIBRARY DESTINATION lib\n    ARCHIVE DESTINATION lib\n    )\nendif()\n\n### Install header files\n\n# Find the . files in the root directory\n\nfile(GLOB headers \"*.h\")\nforeach(header ${headers})\n  install(FILES ${header} DESTINATION include/wdt)\nendforeach()\n\n# Install the .h files in the util with directory structure maintained\n\ninstall(DIRECTORY \"${PROJECT_SOURCE_DIR}/util\" DESTINATION include/wdt\n        FILES_MATCHING PATTERN \"*.h\")\n\n# wcp script\ninstall(PROGRAMS test/wcp.sh DESTINATION bin RENAME wcp)\n\n\n### Everything below is about testing (and not required to create wdt/wdt)\n\nif (BUILD_TESTING)\n\n  enable_testing()\n  find_package(GTest CONFIG REQUIRED)\n  if(NOT GTest_FOUND)\n    include(ExternalProject)\n\n    # GTest\n    #  from https://github.com/google/googletest/tree/master/googletest\n    configure_file(CMakeLists.txt.in googletest-download/CMakeLists.txt)\n    execute_process(COMMAND ${CMAKE_COMMAND} -G \"${CMAKE_GENERATOR}\" .\n      RESULT_VARIABLE result\n      WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download )\n    if(result)\n      message(FATAL_ERROR \"CMake step for googletest failed: ${result}\")\n    endif()\n    execute_process(COMMAND ${CMAKE_COMMAND} --build .\n      RESULT_VARIABLE result\n      WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/googletest-download )\n    if(result)\n      message(FATAL_ERROR \"Build step for googletest failed: ${result}\")\n    endif()\n\n    # Prevent overriding the parent project's compiler/linker\n    # settings on Windows\n    set(gtest_force_shared_crt ON CACHE BOOL \"\" FORCE)\n\n    # Add googletest directly to our build. This defines\n    # the gtest and gtest_main targets.\n    add_subdirectory(${CMAKE_CURRENT_BINARY_DIR}/googletest-src\n                     ${CMAKE_CURRENT_BINARY_DIR}/googletest-build\n                     EXCLUDE_FROM_ALL)\n  endif()\n\n  # Extra code that we use in tests\n  add_library(wdt4tests_min\n    test/TestCommon.cpp\n  )\n  target_link_libraries(wdt4tests_min\n    gtest\n    wdt_min\n  )\n\n  add_library(wdt4tests\n    ${WDT_FLAGS_RELATED_SRC}\n  )\n  target_link_libraries(wdt4tests wdt4tests_min)\n\n  # TODO: make a macro/function to add tests in 1 line instead of 3\n\n\n  # WDT testing/benchmarking code\n  add_library(wdtbenchlib\n    bench/Bigram.cpp\n  )\n\n  target_link_libraries(wdtbenchlib\n    ${GLOG_LIBRARY}\n    ${GFLAGS_LIBRARY}\n  )\n\n  add_library(wdtbenchtestslib\n    bench/WdtGenTestUtils.cpp\n  )\n  target_link_libraries(wdtbenchtestslib\n    gtest\n    wdtbenchlib\n    ${CMAKE_THREAD_LIBS_INIT} # Must be last to avoid link errors\n  )\n\n  add_executable(wdt_gen_files bench/wdtGenFiles.cpp)\n  target_link_libraries(wdt_gen_files wdtbenchlib\n    ${CMAKE_THREAD_LIBS_INIT} # Must be last to avoid link errors\n  )\n  set_target_properties(wdt_gen_files PROPERTIES\n    RUNTIME_OUTPUT_DIRECTORY \"_bin/wdt/bench/\")\n\n  add_executable(wdt_gen_stats bench/wdtStats.cpp)\n  target_link_libraries(wdt_gen_stats wdtbenchlib)\n\n  add_executable(wdt_gen_test bench/wdtGenTest.cpp)\n  target_link_libraries(wdt_gen_test wdtbenchtestslib)\n  add_test(NAME AllTestsInGenTest COMMAND wdt_gen_test)\n\n  # Regular tests\n\n  add_executable(protocol_test test/ProtocolTest.cpp)\n  target_link_libraries(protocol_test wdt4tests)\n  add_test(NAME AllTestsInProtocolTest COMMAND protocol_test)\n\n  add_executable(test_encdeci64_func test/test_encdeci64_func.cpp)\n  target_link_libraries(test_encdeci64_func wdt4tests)\n  add_test(NAME test_encdeci64_func COMMAND test_encdeci64_func)\n\n  add_executable(test_stats test/Stats_test.cpp)\n  target_link_libraries(test_stats wdt4tests)\n  add_test(NAME test_stats COMMAND test_stats)\n\n  add_executable(histogram test/Histogram.cpp)\n  target_link_libraries(histogram wdt_min)\n\n  add_executable(resource_controller_test  test/WdtResourceControllerTest.cpp)\n  target_link_libraries(resource_controller_test wdt4tests)\n  add_test(NAME ResourceControllerTests COMMAND resource_controller_test)\n\n  add_executable(wdt_url_test  test/WdtUrlTest.cpp)\n  target_link_libraries(wdt_url_test wdt4tests)\n  add_test(NAME WdtUrlTests COMMAND wdt_url_test)\n\n  add_executable(wdt_misc_tests  test/WdtMiscTests.cpp)\n  target_link_libraries(wdt_misc_tests wdt4tests)\n  add_test(NAME WdtMiscTests COMMAND wdt_misc_tests)\n\n  add_executable(wdt_fd_test  test/FdTest.cpp)\n  target_link_libraries(wdt_fd_test wdt4tests)\n  add_test(NAME WdtFdTests COMMAND wdt_fd_test)\n\n  add_executable(encryption_test  test/EncryptionTest.cpp)\n  target_link_libraries(encryption_test wdt4tests)\n  add_test(NAME EncryptionTests COMMAND encryption_test)\n\n  add_executable(file_reader_test  test/FileReaderTest.cpp)\n  target_link_libraries(file_reader_test wdt4tests)\n  add_test(NAME FileReaderTests COMMAND file_reader_test)\n\n  add_executable(option_type_test_long_flags test/OptionTypeTest.cpp)\n  target_link_libraries(option_type_test_long_flags wdt4tests)\n\n  add_executable(option_type_test_short_flags test/OptionTypeTest.cpp\n                                              ${WDT_FLAGS_RELATED_SRC}\n                                              )\n  set_target_properties(option_type_test_short_flags PROPERTIES\n    COMPILE_DEFINITIONS \"STANDALONE_APP\"\n    RUNTIME_OUTPUT_DIRECTORY \"_bin/wdt/short_flags/\")\n\n  target_link_libraries(option_type_test_short_flags wdt4tests_min)\n\n  add_test(NAME WdtRandGenTest COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_rand_gen_test.sh\")\n\n  add_test(NAME WdtBasicE2E COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_e2e_simple_test.sh\")\n\n# Doesn't work on a mac:\n#  add_test(NAME WdtStdinManifestAndUrl COMMAND\n#    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_stdin_test.sh\")\n\n  add_test(NAME WdtLockFailFast COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_lock_failfast.sh\")\n\n  add_test(NAME WdtBasicE2Exfs COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_e2e_xfs_test.sh\")\n\n  add_test(NAME WdtOptionsTypeTests COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_option_type_test.sh\")\n\n  add_test(NAME hostname_override_test COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/hostname_override_test.py\")\n\n  add_test(NAME WdtPortBlockTest COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_port_block_test.py\")\n\n  add_test(NAME WdtProtocolNegotiationTest COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_protocol_negotiation_test.py\")\n\n  add_test(NAME WdtSimpleOdirectTest COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_e2e_simple_test.sh\" -o true)\n\n  add_test(NAME WdtFileListTest COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_file_list_test.py\")\n\n  add_test(NAME WdtOverwriteTest COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_overwrite_test.py\")\n\n  add_test(NAME WdtBadServerTest COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_bad_server_test.py\")\n\n  add_test(NAME ReceiverThrottlerRefCountTest COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/receiver_throttler_ref_count_test.sh\")\n\n  add_test(NAME WdtLongRunningTest COMMAND\n    \"${CMAKE_CURRENT_SOURCE_DIR}/test/wdt_long_running_test.py\")\n\nendif(BUILD_TESTING)\n"
        },
        {
          "name": "CMakeLists.txt.in",
          "type": "blob",
          "size": 0.43359375,
          "content": "cmake_minimum_required(VERSION 2.8.2)\n\nproject(googletest-download NONE)\n\ninclude(ExternalProject)\nExternalProject_Add(googletest\n  GIT_REPOSITORY    https://github.com/google/googletest.git\n  GIT_TAG           master\n  SOURCE_DIR        \"${CMAKE_CURRENT_BINARY_DIR}/googletest-src\"\n  BINARY_DIR        \"${CMAKE_CURRENT_BINARY_DIR}/googletest-build\"\n  CONFIGURE_COMMAND \"\"\n  BUILD_COMMAND     \"\"\n  INSTALL_COMMAND   \"\"\n  TEST_COMMAND      \"\"\n)\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.27734375,
          "content": "# Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to make participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies within all project spaces, and it also applies when\nan individual is representing the project or its community in public spaces.\nExamples of representing a project or community include using an official\nproject e-mail address, posting via an official social media account, or acting\nas an appointed representative at an online or offline event. Representation of\na project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at <opensource-conduct@fb.com>. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.25390625,
          "content": "# Contributing to WDT\nWe want to make contributing to this project as easy and transparent as\npossible.\n\n## Our Development Process\n\nSee also README.md\n\n## Pull Requests\nWe actively welcome your pull requests.\n1. Fork the repo and create your branch from `master`.\n2. If you've added code that should be tested, add tests\n3. If you've changed APIs, update the documentation.\n4. Ensure the test suite passes.\n5. Make sure your code lints.\n6. If you haven't already, complete the Contributor License Agreement (\"CLA\").\n\n## Contributor License Agreement (\"CLA\")\nIn order to accept your pull request, we need you to submit a CLA. You only need\nto do this once to work on any of Facebook's open source projects.\n\nComplete your CLA here: <https://code.facebook.com/cla>\n\n## Issues\nWe use GitHub issues to track public bugs. Please ensure your description is\nclear and has sufficient instructions to be able to reproduce the issue.\n\nFacebook has a [bounty program](https://www.facebook.com/whitehat/) for the safe\ndisclosure of security bugs. In those cases, please go through the process\noutlined on that page and do not file a public issue.\n\n## Coding Style\n* run clangformat.sh\n\n## License\nBy contributing to WDT, you agree that your contributions will be licensed\nunder its BSD license.\n"
        },
        {
          "name": "ErrorCodes.cpp",
          "type": "blob",
          "size": 1.1572265625,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <folly/Conv.h>\n#include <string.h>\n#include <wdt/ErrorCodes.h>\n\nDEFINE_int32(wdt_double_precision, 2, \"Precision while printing double\");\nDEFINE_bool(wdt_logging_enabled, true, \"To enable/disable WDT logging.\");\n\nnamespace facebook {\nnamespace wdt {\nstd::string errorCodeToStr(ErrorCode code) {\n  int numErrorCodes = sizeof(kErrorToStr) / sizeof(kErrorToStr[0]);\n  if (code < numErrorCodes) {\n    return kErrorToStr[code];\n  }\n  return folly::to<std::string>(code);\n}\n\nErrorCode getMoreInterestingError(ErrorCode err1, ErrorCode err2) {\n  return std::max(err1, err2);\n}\n\nstd::string strerrorStr(int errnum) {\n  std::string result;\n  char buf[1024], *res = buf;\n  buf[0] = 0;\n#if defined(__APPLE__) || \\\n    ((_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && !_GNU_SOURCE)\n  strerror_r(errnum, buf, sizeof(buf));\n#else\n  res = strerror_r(errnum, buf, sizeof(buf));\n#endif\n  result.assign(res);\n  return result;\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "ErrorCodes.h",
          "type": "blob",
          "size": 5.2802734375,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n#include <gflags/gflags.h>\n#include <glog/logging.h>\n#include <wdt/WdtConfig.h>\n\n#include <iomanip>\n#include <string>\n\n#define WDT_DOUBLE_FORMATTING \\\n  std::fixed << std::setprecision(FLAGS_wdt_double_precision)\n\n#define WDT_LOGGING_ENABLED FLAGS_wdt_logging_enabled\n\nDECLARE_int32(wdt_double_precision);\nDECLARE_bool(wdt_logging_enabled);\n\nnamespace facebook {\nnamespace wdt {\n\n// Call regular google log but prefix with wdt for easier extraction later\n#define WDT_LOG_PREFIX \"wdt>\\t\"\n#define WLOG(X) \\\n  LOG_IF(X, WDT_LOGGING_ENABLED) << WDT_LOG_PREFIX << WDT_DOUBLE_FORMATTING\n#define WVLOG(X) \\\n  VLOG_IF(X, WDT_LOGGING_ENABLED) << WDT_LOG_PREFIX << WDT_DOUBLE_FORMATTING\n#define WPLOG(X) \\\n  PLOG_IF(X, WDT_LOGGING_ENABLED) << WDT_LOG_PREFIX << WDT_DOUBLE_FORMATTING\n#define WLOG_IF(X, Y)                   \\\n  LOG_IF(X, WDT_LOGGING_ENABLED && (Y)) \\\n      << WDT_LOG_PREFIX << WDT_DOUBLE_FORMATTING\n#define WVLOG_IF(X, Y)                   \\\n  VLOG_IF(X, WDT_LOGGING_ENABLED && (Y)) \\\n      << WDT_LOG_PREFIX << WDT_DOUBLE_FORMATTING\n#define WTLOG(X) WLOG(X) << *this << \" \"\n#define WTVLOG(X) WVLOG(X) << *this << \" \"\n#define WTPLOG(X) WPLOG(X) << *this << \" \"\n\n// For now just does regular check, for some library embedding may consider\n// skipping or being DCHECK\n#define WDT_CHECK CHECK\n#define WDT_CHECK_EQ CHECK_EQ\n#define WDT_CHECK_NE CHECK_NE\n#define WDT_CHECK_LE CHECK_LE\n#define WDT_CHECK_LT CHECK_LT\n#define WDT_CHECK_GE CHECK_GE\n#define WDT_CHECK_GT CHECK_GT\n// Note : All the new errors should be defined at the end - but see also\n// getMoreInterestingError implementation for error priorities for reporting\n#define ERRORS                                                                 \\\n  X(OK)                      /** No error  */                                  \\\n  X(ERROR)                   /** Generic error  */                             \\\n  X(ABORT)                   /** Abort */                                      \\\n  X(CONN_ERROR)              /** Connection Error */                           \\\n  X(CONN_ERROR_RETRYABLE)    /** Retryable connection error  */                \\\n  X(SOCKET_READ_ERROR)       /** Socket read error  */                         \\\n  X(SOCKET_WRITE_ERROR)      /** Socket write error  */                        \\\n  X(BYTE_SOURCE_READ_ERROR)  /** Byte source(file) read error  */              \\\n  X(FILE_WRITE_ERROR)        /** file write error  */                          \\\n  X(MEMORY_ALLOCATION_ERROR) /** Memory allocation failure  */                 \\\n  X(PROTOCOL_ERROR)          /** WDT protocol error  */                        \\\n  X(VERSION_MISMATCH)        /** Sender and Receiver version mismatch */       \\\n  X(ID_MISMATCH)             /** Sender and Receiver id mismatch*/             \\\n  X(CHECKSUM_MISMATCH)       /** Checksums do not match */                     \\\n  X(RESOURCE_NOT_FOUND)      /** Not found in the resource controller */       \\\n  X(ABORTED_BY_APPLICATION)  /** Transfer was aborted by application */        \\\n  X(VERSION_INCOMPATIBLE)    /** Sender/receiver version incompatible */       \\\n  X(NOT_FOUND)               /** Not found in the resource controller */       \\\n  X(QUOTA_EXCEEDED)          /** Quota exceeded in resource controller */      \\\n  X(FEWER_PORTS)             /** Couldn't listen on all the ports */           \\\n  X(URI_PARSE_ERROR)         /** Wdt uri passed couldn't be parsed */          \\\n  X(INCONSISTENT_DIRECTORY)  /** Destination directory is not consistent with  \\\n                                transfer log */                                \\\n  X(INVALID_LOG)             /** Transfer log invalid */                       \\\n  X(INVALID_CHECKPOINT)      /** Received checkpoint is invalid */             \\\n  X(NO_PROGRESS)             /** Transfer has not progressed */                \\\n  X(TRANSFER_LOG_ACQUIRE_ERROR) /** Failed to acquire lock for transfer log */ \\\n  X(WDT_TIMEOUT)                /** Socket operation timed out  */             \\\n  X(UNEXPECTED_CMD_ERROR)       /** Unexpected cmd received */                 \\\n  X(ENCRYPTION_ERROR)           /** Error related to encryption */             \\\n  X(ALREADY_EXISTS)             /** Create attempt for existing id */          \\\n  X(GLOBAL_CHECKPOINT_ABORT)    /** Abort due to global checkpoint */          \\\n  X(INVALID_REQUEST)        /** Request for creation of wdt object invalid */  \\\n  X(SENDER_START_TIMED_OUT) /** Sender start timed out */                      \\\n  X(AUTH_ERROR)             /** Authentication Error */\n\nenum ErrorCode {\n#define X(A) A,\n  ERRORS\n#undef X\n};\n\nstd::string const kErrorToStr[] = {\n#define X(A) #A,\n    ERRORS\n#undef X\n};\n\n/**\n * returns string description of an error code\n *\n * @param code  error-code\n * @return      string representation\n */\nstd::string errorCodeToStr(ErrorCode code);\n\n/**\n * returns more interesting of two errors\n */\nErrorCode getMoreInterestingError(ErrorCode err1, ErrorCode err2);\n\n/**\n * Thread safe version of strerror(), easier than strerror_r\n * (similar to folly::errnoStr() but without pulling in all the dependencies)\n */\nstd::string strerrorStr(int errnum);\n}  // namespace wdt\n}  // namespace facebook\n#undef ERRORS\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.48828125,
          "content": "BSD License\n\nFor WDT software\n\nCopyright (c) 2014-present, Facebook, Inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n * Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n * Neither the name Facebook nor the names of its contributors may be used to\n   endorse or promote products derived from this software without specific\n   prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Protocol.cpp",
          "type": "blob",
          "size": 19.421875,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <wdt/ErrorCodes.h>\n#include <wdt/Protocol.h>\n#include <wdt/WdtOptions.h>\n#include <wdt/util/SerializationUtil.h>\n\nnamespace facebook {\nnamespace wdt {\n\nusing folly::ByteRange;\nusing std::string;\n\nconst int Protocol::protocol_version = WDT_PROTOCOL_VERSION;\n\nconst int Protocol::RECEIVER_PROGRESS_REPORT_VERSION = 11;\nconst int Protocol::CHECKSUM_VERSION = 12;\nconst int Protocol::DOWNLOAD_RESUMPTION_VERSION = 13;\n\nconst int Protocol::SETTINGS_FLAG_VERSION = 12;\nconst int Protocol::HEADER_FLAG_AND_PREV_SEQ_ID_VERSION = 13;\nconst int Protocol::CHECKPOINT_OFFSET_VERSION = 16;\nconst int Protocol::CHECKPOINT_SEQ_ID_VERSION = 21;\nconst int Protocol::ENCRYPTION_V1_VERSION = 23;\nconst int Protocol::INCREMENTAL_TAG_VERIFICATION_VERSION = 25;\nconst int Protocol::DELETE_CMD_VERSION = 26;\nconst int Protocol::VARINT_CHANGE = 27;\nconst int Protocol::HEART_BEAT_VERSION = 29;\nconst int Protocol::PERIODIC_ENCRYPTION_IV_CHANGE_VERSION = 30;\n\n/* All methods of Protocol class are static (functions) */\n\nconst string Protocol::getFullVersion() {\n  string fullVersion(WDT_VERSION_STR);\n  fullVersion.append(\" p \");\n  fullVersion.append(std::to_string(protocol_version));\n  return fullVersion;\n}\n\nint Protocol::negotiateProtocol(int requestedProtocolVersion,\n                                int curProtocolVersion) {\n  if (requestedProtocolVersion < 10) {\n    WLOG(WARNING) << \"Can not handle protocol \" << requestedProtocolVersion;\n    return 0;\n  }\n  return std::min<int>(curProtocolVersion, requestedProtocolVersion);\n}\n\nstd::ostream &operator<<(std::ostream &os, const Checkpoint &checkpoint) {\n  os << \"checkpoint-port: \" << checkpoint.port\n     << \" num-blocks: \" << checkpoint.numBlocks\n     << \" seq-id: \" << checkpoint.lastBlockSeqId\n     << \" block-offset: \" << checkpoint.lastBlockOffset\n     << \" received-bytes: \" << checkpoint.lastBlockReceivedBytes;\n  return os;\n}\n\nint64_t FileChunksInfo::getTotalChunkSize() const {\n  int64_t totalChunkSize = 0;\n  for (const auto &chunk : chunks_) {\n    totalChunkSize += chunk.size();\n  }\n  return totalChunkSize;\n}\n\nvoid FileChunksInfo::addChunk(const Interval &chunk) {\n  chunks_.emplace_back(chunk);\n}\n\nvoid FileChunksInfo::mergeChunks() {\n  if (chunks_.empty()) {\n    return;\n  }\n  std::sort(chunks_.begin(), chunks_.end());\n  std::vector<Interval> mergedChunks;\n  Interval curChunk = chunks_[0];\n  const size_t numChunks = chunks_.size();\n  for (size_t i = 1; i < numChunks; i++) {\n    if (chunks_[i].start_ > curChunk.end_) {\n      mergedChunks.emplace_back(curChunk);\n      curChunk = chunks_[i];\n    } else {\n      curChunk.end_ = std::max(curChunk.end_, chunks_[i].end_);\n    }\n  }\n  mergedChunks.emplace_back(curChunk);\n  chunks_ = mergedChunks;\n}\n\nstd::vector<Interval> FileChunksInfo::getRemainingChunks(int64_t curFileSize) {\n  std::vector<Interval> remainingChunks;\n  int64_t curStart = 0;\n  for (const auto &chunk : chunks_) {\n    if (chunk.start_ > curStart) {\n      remainingChunks.emplace_back(curStart, chunk.start_);\n    }\n    curStart = chunk.end_;\n  }\n  if (curStart < curFileSize) {\n    remainingChunks.emplace_back(curStart, curFileSize);\n  }\n  return remainingChunks;\n}\n\nstd::ostream &operator<<(std::ostream &os,\n                         FileChunksInfo const &fileChunksInfo) {\n  os << \"name \" << fileChunksInfo.getFileName() << \" seqId \"\n     << fileChunksInfo.getSeqId() << \" file-size \"\n     << fileChunksInfo.getFileSize() << \" number of chunks \"\n     << fileChunksInfo.getChunks().size();\n  for (const auto &chunk : fileChunksInfo.getChunks()) {\n    os << \" (\" << chunk.start_ << \", \" << chunk.end_ << \") \";\n  }\n  return os;\n}\n\nint Protocol::getMaxLocalCheckpointLength(int protocolVersion) {\n  // add 10 for the size of the vector(local checkpoint is a vector of\n  // checkpoints with size 1). Even though, it only takes 1 byte to encode this,\n  // previous version of code assumes this to be 10. So, keeping this as 10\n  int length = 10;\n  // port & number of blocks\n  length += 2 * 10;\n  if (protocolVersion >= CHECKPOINT_OFFSET_VERSION) {\n    // number of bytes in the last block\n    length += 10;\n  }\n  if (protocolVersion >= CHECKPOINT_SEQ_ID_VERSION) {\n    // seq-id and block offset\n    length += 2 * 10;\n  }\n  return length;\n}\n\nbool Protocol::encodeHeader(int senderProtocolVersion, char *dest, int64_t &off,\n                            const int64_t max,\n                            const BlockDetails &blockDetails) {\n  WDT_CHECK_GE(max, 0);\n  const size_t umax = static_cast<size_t>(max);  // we made sure it's not < 0\n  bool ok = encodeString(dest, max, off, blockDetails.fileName) &&\n            encodeVarI64C(dest, umax, off, blockDetails.seqId) &&\n            encodeVarI64C(dest, umax, off, blockDetails.dataSize) &&\n            encodeVarI64C(dest, umax, off, blockDetails.offset) &&\n            encodeVarI64C(dest, umax, off, blockDetails.fileSize);\n  if (ok && senderProtocolVersion >= HEADER_FLAG_AND_PREV_SEQ_ID_VERSION) {\n    uint8_t flags = blockDetails.allocationStatus;\n    if (off >= max) {\n      ok = false;\n    } else {\n      dest[off++] = static_cast<char>(flags);\n      if (flags == EXISTS_TOO_SMALL || flags == EXISTS_TOO_LARGE) {\n        // prev seq-id is only used in case the size is less on the sender side\n        ok = encodeVarI64C(dest, umax, off, blockDetails.prevSeqId);\n      }\n    }\n  }\n  if (!ok) {\n    WLOG(ERROR) << \"Failed to encode header, ran out of space, \" << off << \" \"\n                << max;\n  }\n  return ok;\n}\n\nbool Protocol::decodeHeader(int receiverProtocolVersion, char *src,\n                            int64_t &off, const int64_t max,\n                            BlockDetails &blockDetails) {\n  ByteRange br = makeByteRange(src, max, off);  // will check for off>0 max>0\n  const ByteRange obr = br;\n\n  bool ok = decodeString(br, blockDetails.fileName) &&\n            decodeInt64C(br, blockDetails.seqId) &&\n            decodeInt64C(br, blockDetails.dataSize) &&\n            decodeInt64C(br, blockDetails.offset) &&\n            decodeInt64C(br, blockDetails.fileSize);\n  if (ok && receiverProtocolVersion >= HEADER_FLAG_AND_PREV_SEQ_ID_VERSION) {\n    if (br.empty()) {\n      WLOG(ERROR) << \"Invalid (too short) input len \" << max << \" at offset \"\n                  << (max - obr.size());\n      return false;\n    }\n    uint8_t flags = br.front();\n    // first 3 bits are used to represent allocation status\n    blockDetails.allocationStatus = (FileAllocationStatus)(flags & 7);\n    br.pop_front();\n    if (blockDetails.allocationStatus == EXISTS_TOO_SMALL ||\n        blockDetails.allocationStatus == EXISTS_TOO_LARGE) {\n      ok = decodeInt64C(br, blockDetails.prevSeqId);\n    }\n  }\n  off += offset(br, obr);\n  return ok;\n}\n\nbool Protocol::encodeCheckpoints(int protocolVersion, char *dest, int64_t &off,\n                                 int64_t max,\n                                 const std::vector<Checkpoint> &checkpoints) {\n  WDT_CHECK_GE(max, 0);\n  const size_t umax = static_cast<size_t>(max);\n  bool ok = encodeVarU64(dest, umax, off, checkpoints.size());\n  for (const auto &checkpoint : checkpoints) {\n    if (!ok) {\n      break;\n    }\n    ok = encodeVarI64C(dest, umax, off, checkpoint.port) &&\n         encodeVarI64C(dest, umax, off, checkpoint.numBlocks);\n    if (ok && protocolVersion >= CHECKPOINT_OFFSET_VERSION) {\n      ok = encodeVarI64C(dest, umax, off, checkpoint.lastBlockReceivedBytes);\n    }\n    if (ok && protocolVersion >= CHECKPOINT_SEQ_ID_VERSION) {\n      ok = encodeVarI64C(dest, umax, off, checkpoint.lastBlockSeqId) &&\n           encodeVarI64C(dest, umax, off, checkpoint.lastBlockOffset);\n    }\n  }\n  if (!ok) {\n    WLOG(ERROR) << \"encodeCheckpoints \" << off << \" \" << max;\n  }\n  return ok;\n}\n\nbool Protocol::decodeCheckpoints(int protocolVersion, char *src, int64_t &off,\n                                 int64_t max,\n                                 std::vector<Checkpoint> &checkpoints) {\n  ByteRange br = makeByteRange(src, max, off);  // will check for off>0 max>0\n  const ByteRange obr = br;\n  uint64_t len;\n  bool ok = decodeUInt64(br, len);\n  for (uint64_t i = 0; ok && i < len; i++) {\n    Checkpoint checkpoint;\n    ok = decodeInt32C(br, checkpoint.port) &&\n         decodeInt64C(br, checkpoint.numBlocks);\n    if (ok && protocolVersion >= CHECKPOINT_OFFSET_VERSION) {\n      ok = decodeInt64C(br, checkpoint.lastBlockReceivedBytes);\n    }\n    if (ok && protocolVersion >= CHECKPOINT_SEQ_ID_VERSION) {\n      // Deal with -1 encoded by pre 1.27 version\n      uint64_t uv = 0;\n      ok = decodeUInt64(br, uv);\n      checkpoint.lastBlockSeqId = static_cast<int64_t>(uv);\n      if (ok && protocolVersion < VARINT_CHANGE) {\n        // pre 1.27 encodes -1 for invalid and use 9 0xff bytes and 1 0x01 byte\n        // 1.27+ decodes the 9 0xff as max uint64_t (all FFs) so we check and\n        // consume the leftover 0x01\n        if (uv == 0xffffffffffffffff && !br.empty()) {\n          if (br.front() != 0x01) {\n            WLOG(ERROR) << \"Unexpected decoding of pre1.27 -1 : \" << br.front();\n            ok = false;\n          }\n          br.advance(1);  // 1.26 used 10 bytes\n          WLOG(INFO) << \"Fixed v\" << protocolVersion << \" chkpt to -1 seqid\";\n          checkpoint.lastBlockSeqId = -1;\n        }\n      }\n      ok = ok && decodeInt64C(br, checkpoint.lastBlockOffset);\n      checkpoint.hasSeqId = true;\n    }\n    if (ok) {\n      checkpoints.emplace_back(checkpoint);\n    }\n  }\n  off += offset(br, obr);\n  return ok;\n}\n\nbool Protocol::encodeDone(int protocolVersion, char *dest, int64_t &off,\n                          int64_t max, int64_t numBlocks, int64_t bytesSent) {\n  bool ok = encodeVarI64C(dest, max, off, numBlocks);\n  if (ok && protocolVersion >= CHECKPOINT_OFFSET_VERSION) {\n    ok = encodeVarI64C(dest, max, off, bytesSent);\n  }\n  return ok;\n}\n\nbool Protocol::decodeDone(int protocolVersion, char *src, int64_t &off,\n                          int64_t max, int64_t &numBlocks, int64_t &bytesSent) {\n  ByteRange br = makeByteRange(src, max, off);  // will check for off>0 max>0\n  const ByteRange obr = br;\n  bool ok = decodeInt64C(br, numBlocks);\n  if (ok && protocolVersion >= CHECKPOINT_OFFSET_VERSION) {\n    ok = decodeInt64C(br, bytesSent);\n  }\n  off += offset(br, obr);\n  return ok;\n}\n\nbool Protocol::encodeSize(char *dest, int64_t &off, int64_t max,\n                          int64_t totalNumBytes) {\n  return encodeVarI64C(dest, max, off, totalNumBytes);\n}\n\nbool Protocol::decodeSize(char *src, int64_t &off, int64_t max,\n                          int64_t &totalNumBytes) {\n  ByteRange br = makeByteRange(src, max, off);  // will check for off>0 max>0\n  const ByteRange obr = br;\n  bool ok = decodeInt64C(br, totalNumBytes);\n  off += offset(br, obr);\n  return ok;\n}\n\nbool Protocol::encodeAbort(char *dest, int64_t &off, const int64_t max,\n                           int32_t protocolVersion, ErrorCode errCode,\n                           int64_t checkpoint) {\n  if (off + kAbortLength > max) {\n    WLOG(ERROR) << \"Trying to encode abort in too small of a buffer sz \" << max\n                << \" off \" << off;\n    return false;\n  }\n  bool ok = encodeInt32FixedLength(dest, max, off, protocolVersion);\n  if (!ok) {\n    return false;\n  }\n  dest[off++] = errCode;\n  return encodeInt64FixedLength(dest, max, off, checkpoint);\n}\n\nbool Protocol::decodeAbort(char *src, int64_t &off, int64_t max,\n                           int32_t &protocolVersion, ErrorCode &errCode,\n                           int64_t &checkpoint) {\n  if (off + kAbortLength > max) {\n    WLOG(ERROR) << \"Trying to decode abort, not enough to read sz \" << max\n                << \" at off \" << off;\n    return false;\n  }\n  ByteRange br = makeByteRange(src, max, off);  // will check for off>0 max>0\n  const ByteRange obr = br;\n  bool ok = decodeInt32FixedLength(br, protocolVersion);\n  if (!ok) {\n    return false;\n  }\n  errCode = (ErrorCode)br.front();\n  br.pop_front();\n  ok = decodeInt64FixedLength(br, checkpoint);\n  off += offset(br, obr);\n  return ok;\n}\n\nbool Protocol::encodeChunksCmd(char *dest, int64_t &off, int64_t max,\n                               int64_t bufSize, int64_t numFiles) {\n  return encodeInt64FixedLength(dest, max, off, bufSize) &&\n         encodeInt64FixedLength(dest, max, off, numFiles);\n}\n\nbool Protocol::decodeChunksCmd(char *src, int64_t &off, int64_t max,\n                               int64_t &bufSize, int64_t &numFiles) {\n  ByteRange br = makeByteRange(src, max, off);  // will check for off>0 max>0\n  const ByteRange obr = br;\n  bool ok = decodeInt64FixedLength(br, bufSize) &&\n            decodeInt64FixedLength(br, numFiles);\n  off += offset(br, obr);\n  return ok;\n}\n\nbool Protocol::encodeChunkInfo(char *dest, int64_t &off, int64_t max,\n                               const Interval &chunk) {\n  return encodeVarI64C(dest, max, off, chunk.start_) &&\n         encodeVarI64C(dest, max, off, chunk.end_);\n}\n\nbool Protocol::decodeChunkInfo(ByteRange &br, Interval &chunk) {\n  return decodeInt64C(br, chunk.start_) && decodeInt64C(br, chunk.end_);\n}\n\nbool Protocol::encodeFileChunksInfo(char *dest, int64_t &off, int64_t max,\n                                    const FileChunksInfo &fileChunksInfo) {\n  bool ok = encodeVarI64C(dest, max, off, fileChunksInfo.getSeqId()) &&\n            encodeString(dest, max, off, fileChunksInfo.getFileName()) &&\n            encodeVarI64C(dest, max, off, fileChunksInfo.getFileSize()) &&\n            encodeVarI64C(dest, max, off, fileChunksInfo.getChunks().size());\n  if (!ok) {\n    return false;\n  }\n  for (const auto &chunk : fileChunksInfo.getChunks()) {\n    if (!encodeChunkInfo(dest, off, max, chunk)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool Protocol::decodeFileChunksInfo(ByteRange &br,\n                                    FileChunksInfo &fileChunksInfo) {\n  int64_t seqId, fileSize, numChunks;\n  string fileName;\n  bool ok = decodeInt64C(br, seqId) && decodeString(br, fileName) &&\n            decodeInt64C(br, fileSize) && decodeInt64C(br, numChunks);\n  if (!ok) {\n    return false;\n  }\n  fileChunksInfo.setSeqId(seqId);\n  fileChunksInfo.setFileName(fileName);\n  fileChunksInfo.setFileSize(fileSize);\n  if (numChunks < 0) {\n    WLOG(ERROR) << \"Negative number of chunks decoded \" << numChunks;\n    return false;\n  }\n  for (int64_t i = 0; i < numChunks; i++) {\n    Interval chunk;\n    if (!decodeChunkInfo(br, chunk)) {\n      return false;\n    }\n    fileChunksInfo.addChunk(chunk);\n  }\n  return true;\n}\n\nint64_t Protocol::maxEncodeLen(const FileChunksInfo &fileChunkInfo) {\n  return 10 + 2 + fileChunkInfo.getFileName().size() + 10 + 10 +\n         fileChunkInfo.getChunks().size() * kMaxChunkEncodeLen;\n}\n\nint64_t Protocol::encodeFileChunksInfoList(\n    char *dest, int64_t &off, int64_t bufSize, int64_t startIndex,\n    const std::vector<FileChunksInfo> &fileChunksInfoList) {\n  int64_t oldOffset = off;\n  int64_t numEncoded = 0;\n  const int64_t numFileChunks = fileChunksInfoList.size();\n  for (int64_t i = startIndex; i < numFileChunks; i++) {\n    const FileChunksInfo &fileChunksInfo = fileChunksInfoList[i];\n    int64_t maxLength = maxEncodeLen(fileChunksInfo);\n    if (maxLength + oldOffset > bufSize) {\n      WLOG(WARNING) << \"Chunk info for \" << fileChunksInfo.getFileName()\n                    << \" can not be encoded in a buffer of size \" << bufSize\n                    << \", Ignoring.\";\n      continue;\n    }\n    if (maxLength + off >= bufSize) {\n      break;\n    }\n    encodeFileChunksInfo(dest, off, bufSize, fileChunksInfo);\n    numEncoded++;\n  }\n  return numEncoded;\n}\n\nbool Protocol::decodeFileChunksInfoList(\n    char *src, int64_t &off, int64_t dataSize,\n    std::vector<FileChunksInfo> &fileChunksInfoList) {\n  ByteRange br = makeByteRange(src, dataSize, off);\n  const ByteRange obr = br;\n  while (!br.empty()) {\n    FileChunksInfo fileChunkInfo;\n    if (!decodeFileChunksInfo(br, fileChunkInfo)) {\n      return false;\n    }\n    fileChunksInfoList.emplace_back(std::move(fileChunkInfo));\n  }\n  off += offset(br, obr);\n  return true;\n}\n\nbool Protocol::encodeSettings(int senderProtocolVersion, char *dest,\n                              int64_t &off, int64_t max,\n                              const Settings &settings) {\n  bool ok = encodeVarI64C(dest, max, off, senderProtocolVersion) &&\n            encodeVarI64C(dest, max, off, settings.readTimeoutMillis) &&\n            encodeVarI64C(dest, max, off, settings.writeTimeoutMillis) &&\n            encodeString(dest, max, off, settings.transferId);\n  if (ok && senderProtocolVersion >= SETTINGS_FLAG_VERSION) {\n    uint8_t flags = 0;\n    if (settings.enableChecksum) {\n      flags |= 1;\n    }\n    if (settings.sendFileChunks) {\n      flags |= (1 << 1);\n    }\n    if (settings.blockModeDisabled) {\n      flags |= (1 << 2);\n    }\n    if (settings.enableHeartBeat) {\n      flags |= (1 << 3);\n    }\n    if (off >= max) {\n      return false;\n    }\n    dest[off++] = flags;\n  }\n  return ok;\n}\n\nbool Protocol::decodeVersion(char *src, int64_t &off, int64_t max,\n                             int &senderProtocolVersion) {\n  ByteRange br = makeByteRange(src, max, off);\n  const ByteRange obr = br;\n  bool ok = decodeInt32C(br, senderProtocolVersion);\n  off += offset(br, obr);\n  return ok;\n}\n\nbool Protocol::decodeSettings(int protocolVersion, char *src, int64_t &off,\n                              int64_t max, Settings &settings) {\n  settings.enableChecksum = settings.sendFileChunks = false;\n  if (off < 0) {\n    WLOG(ERROR) << \"Invalid negative start offset for decodeSettings \" << off;\n    return false;\n  }\n  if (off >= max) {\n    WLOG(ERROR) << \"Invalid start offset at the end for decodeSettings \" << off;\n    return false;\n  }\n  ByteRange br = makeByteRange(src, max, off);\n  const ByteRange obr = br;\n  bool ok = decodeInt32C(br, settings.readTimeoutMillis) &&\n            decodeInt32C(br, settings.writeTimeoutMillis) &&\n            decodeString(br, settings.transferId);\n  if (ok && protocolVersion >= SETTINGS_FLAG_VERSION) {\n    if (br.empty()) {\n      return false;\n    }\n    uint8_t flags = br.front();\n    settings.enableChecksum = flags & 1;\n    settings.sendFileChunks = flags & (1 << 1);\n    settings.blockModeDisabled = flags & (1 << 2);\n    settings.enableHeartBeat = flags & (1 << 3);\n    br.pop_front();\n  }\n  off += offset(br, obr);\n  return ok;\n}\n\n/* static */\nbool Protocol::encodeEncryptionSettings(char *dest, int64_t &off, int64_t max,\n                                        const EncryptionType encryptionType,\n                                        const string &iv,\n                                        const int32_t tagInterval) {\n  return encodeVarI64C(dest, max, off, encryptionType) &&\n         encodeString(dest, max, off, iv) &&\n         encodeInt32FixedLength(dest, max, off, tagInterval);\n}\n\n/* static */\nbool Protocol::decodeEncryptionSettings(char *src, int64_t &off, int64_t max,\n                                        EncryptionType &encryptionType,\n                                        string &iv, int32_t &tagInterval) {\n  ByteRange br = makeByteRange(src, max, off);\n  const ByteRange obr = br;\n  int64_t v;\n  bool ok = decodeInt64C(br, v) && decodeString(br, iv) &&\n            decodeInt32FixedLength(br, tagInterval);\n  if (ok) {\n    encryptionType = static_cast<EncryptionType>(v);\n  }\n  off += offset(br, obr);\n  return ok;\n}\n\nbool Protocol::encodeFooter(char *dest, int64_t &off, int64_t max,\n                            int32_t checksum) {\n  return encodeVarI64(dest, max, off, checksum);\n}\n\nbool Protocol::decodeFooter(char *src, int64_t &off, int64_t max,\n                            int32_t &checksum) {\n  ByteRange br = makeByteRange(src, max, off);\n  const ByteRange obr = br;\n  bool ok = decodeInt32(br, checksum);\n  off += offset(br, obr);\n  return ok;\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "Protocol.h",
          "type": "blob",
          "size": 19.4716796875,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n#include <folly/Range.h>\n#include <limits.h>\n#include <stddef.h>\n#include <wdt/ErrorCodes.h>\n#include <wdt/util/EncryptionUtils.h>\n\n#include <string>\n#include <vector>\n\nnamespace facebook {\nnamespace wdt {\n\n// Note: we use int64_t internally for most things - it helps for arithmetic\n// and not getting accidental overflow when substracting, it helps comparaison\n// and also idendtifying errors as negative values.\n// BUT we made a mistake in early version of wdt where we used an encoding that\n// doesn't efficiently represent negative values - so in term of serializing\n// ints on the wire we expect all numbers to actually be positive (which is\n// more efficient when only positive numbers are indeed encoded)\n// For future fields where small negative value occurs, do use the I64 functions\n// without the trailing C for compatibility or use U64 when you know for sure\n// the data encoded is >= 0 (in util/SerializationUtil.h)\n\n/// Checkpoint consists of port number, number of successfully transferred\n/// blocks and number of bytes received for the last block\nstruct Checkpoint {\n  int32_t port{0};\n  /// number of complete blocks received\n  int64_t numBlocks{0};\n  /// Next three fields are only set if a block is received partially\n  /// seq-id of the partially received block (and we don't use encryption\n  /// which doesn't allow using partial blocks as they can't be authenticated)\n  int64_t lastBlockSeqId{0};  // was -1 in 1.26\n  /// block offset of the partially received block\n  int64_t lastBlockOffset{0};\n  /// number of bytes received for the partially received block\n  int64_t lastBlockReceivedBytes{0};\n  bool hasSeqId{false};\n  Checkpoint() {\n  }\n\n  explicit Checkpoint(int32_t port) {\n    this->port = port;\n  }\n\n  bool hasPartialBlockInfo() const {\n    return (hasSeqId && lastBlockSeqId >= 0 && lastBlockReceivedBytes > 0);\n  }\n\n  void resetLastBlockDetails() {\n    lastBlockReceivedBytes = 0;\n    lastBlockSeqId = 0;  // was -1 in 1.26\n    lastBlockOffset = 0;\n  }\n\n  void setLastBlockDetails(int64_t seqId, int64_t offset,\n                           int64_t receivedBytes) {\n    this->lastBlockSeqId = seqId;\n    this->lastBlockOffset = offset;\n    this->lastBlockReceivedBytes = receivedBytes;\n  }\n\n  void incrNumBlocks() {\n    numBlocks++;\n  }\n};\n\nstd::ostream &operator<<(std::ostream &os, const Checkpoint &checkpoint);\n\n/// structure representing a single chunk of a file\nstruct Interval {\n  /// start offset\n  int64_t start_{0};\n  /// end offset\n  int64_t end_{0};\n\n  Interval() {\n  }\n\n  Interval(int64_t start, int64_t end) : start_(start), end_(end) {\n    WDT_CHECK(end_ >= start_);\n  }\n\n  /// @return   size of the chunk\n  int64_t size() const {\n    return end_ - start_;\n  }\n\n  bool operator<(const Interval &chunk) const {\n    return this->start_ < chunk.start_;\n  }\n\n  bool operator==(const Interval &chunk) const {\n    return this->start_ == chunk.start_ && this->end_ == chunk.end_;\n  }\n};\n\n/// class representing chunks in a file\nclass FileChunksInfo {\n public:\n  /// making the object noncopyable\n  FileChunksInfo(const FileChunksInfo &) = delete;\n  FileChunksInfo &operator=(const FileChunksInfo &) = delete;\n  FileChunksInfo(FileChunksInfo &&) = default;\n  FileChunksInfo &operator=(FileChunksInfo &&) = default;\n\n  FileChunksInfo() {\n  }\n\n  /**\n   * @param seqId     seq-id of the file\n   * @param fileName  file-name\n   * @param fileSize  file-size\n   */\n  FileChunksInfo(int64_t seqId, std::string &fileName, int64_t fileSize)\n      : seqId_(seqId), fileName_(fileName), fileSize_(fileSize) {\n  }\n\n  /// @return   file-name\n  const std::string &getFileName() const {\n    return fileName_;\n  }\n\n  /// @param fileName   file-name to be set\n  void setFileName(const std::string &fileName) {\n    fileName_ = fileName;\n  }\n\n  /// @return   seq-id of the file\n  int64_t getSeqId() const {\n    return seqId_;\n  }\n\n  /// @param seqId      seq-id to be set\n  void setSeqId(int64_t seqId) {\n    seqId_ = seqId;\n  }\n\n  /// @return         file-size\n  int64_t getFileSize() const {\n    return fileSize_;\n  }\n\n  /// @param fileSize   file-size to be set\n  void setFileSize(int64_t fileSize) {\n    fileSize_ = fileSize;\n  }\n\n  /// @return         chunks of the file\n  const std::vector<Interval> &getChunks() const {\n    return chunks_;\n  }\n\n  /// @param chunk    chunk to be added\n  void addChunk(const Interval &chunk);\n\n  /// merges all the chunks\n  void mergeChunks();\n\n  int64_t getTotalChunkSize() const;\n\n  /// @return   list of chunks which are not part of the chunks-list\n  std::vector<Interval> getRemainingChunks(int64_t curFileSize);\n\n  bool operator==(const FileChunksInfo &fileChunksInfo) const {\n    return this->seqId_ == fileChunksInfo.seqId_ &&\n           this->fileName_ == fileChunksInfo.fileName_ &&\n           this->chunks_ == fileChunksInfo.chunks_ &&\n           this->fileSize_ == fileChunksInfo.fileSize_;\n  }\n\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const FileChunksInfo &fileChunksInfo);\n\n private:\n  /// seq-id of the file\n  int64_t seqId_{0};\n  /// name of the file\n  std::string fileName_;\n  /// size of the file\n  int64_t fileSize_{0};\n  /// list of chunk info\n  std::vector<Interval> chunks_;\n};\n\n/// enum representing file allocation status at the receiver side\nenum FileAllocationStatus {\n  NOT_EXISTS,           // file does not exist\n  EXISTS_CORRECT_SIZE,  // file exists with correct size\n  EXISTS_TOO_LARGE,     // file exists, but too large\n  EXISTS_TOO_SMALL,     // file exists, but too small\n  TO_BE_DELETED,        // file not needed, should be deleted\n};\n\n/// structure representing details of a block\nstruct BlockDetails {\n  /// name of the file\n  std::string fileName;\n  /// sequence-id of the file\n  int64_t seqId{0};\n  /// size of the file\n  int64_t fileSize{0};\n  /// offset of the block from the start of the file\n  int64_t offset{0};\n  /// size of the block\n  int64_t dataSize{0};\n  /// receiver side file allocation status\n  FileAllocationStatus allocationStatus{NOT_EXISTS};\n  /// seq-id of previous transfer, only valid if there is a size mismatch\n  int64_t prevSeqId{0};\n};\n\n/// structure representing settings cmd\nstruct Settings {\n  /// sender side read timeout\n  int readTimeoutMillis{0};\n  /// sender side write timeout\n  int writeTimeoutMillis{0};\n  /// transfer-id\n  std::string transferId{0};\n  /// whether checksum in enabled or not\n  bool enableChecksum{0};\n  /// whether sender wants to read previously transferred chunks or not\n  bool sendFileChunks{0};\n  /// whether block mode is disabled\n  bool blockModeDisabled{false};\n  /// whether heart-beat is enabled\n  bool enableHeartBeat{false};\n};\n\nclass Protocol {\n public:\n  /// current protocol version\n  static const int protocol_version;\n\n  // list of feature versions\n  /// version from which receiver side progress reporting is supported\n  static const int RECEIVER_PROGRESS_REPORT_VERSION;\n  /// version from which checksum is supported\n  static const int CHECKSUM_VERSION;\n  /// version from which download resumption is supported\n  static const int DOWNLOAD_RESUMPTION_VERSION;\n\n  // list of encoding/decoding versions\n  /// version from which flags are sent with settings cmd\n  static const int SETTINGS_FLAG_VERSION;\n  /// version from which flags and prevSeqId are sent with header cmd\n  static const int HEADER_FLAG_AND_PREV_SEQ_ID_VERSION;\n  /// version from which checkpoint started including file offset\n  static const int CHECKPOINT_OFFSET_VERSION;\n  /// version from which checkpoint started including seq-id\n  static const int CHECKPOINT_SEQ_ID_VERSION;\n  /// version from which wdt supports encryption\n  static const int ENCRYPTION_V1_VERSION;\n  /// version from which GCM tags were verified incrementally\n  static const int INCREMENTAL_TAG_VERIFICATION_VERSION;\n  /// version from which file deletion was supported for resumption\n  static const int DELETE_CMD_VERSION;\n  /// version from which we switched varint to better one\n  static const int VARINT_CHANGE;\n  /// version from which heart-beat was introduced\n  static const int HEART_BEAT_VERSION;\n  /// version from which wdt started to change encryption iv periodically\n  static const int PERIODIC_ENCRYPTION_IV_CHANGE_VERSION;\n\n  /// Both version, magic number and command byte\n  enum CMD_MAGIC {\n    DONE_CMD = 0x44,      // D)one\n    FILE_CMD = 0x4C,      // L)oad\n    WAIT_CMD = 0x57,      // W)ait\n    ERR_CMD = 0x45,       // E)rr\n    SETTINGS_CMD = 0x53,  // S)ettings\n    ABORT_CMD = 0x41,     // A)bort\n    CHUNKS_CMD = 0x43,    // C)hunk\n    ACK_CMD = 0x61,       // a)ck\n    SIZE_CMD = 0x5A,      // Si(Z)e\n    FOOTER_CMD = 0x46,    // F)ooter\n    LOCAL_CHECKPOINT_CMD =\n        0x01,  // Local checkpoint cmd. This is a hack to ensure backward\n               // compatibility. Since, the format of checkpoints is\n               // <num_checkpoints><checkpoint1><checkpoint2>..., and since the\n               // number of checkpoints for local checkpoint is 1, we can treat\n               // 0x01 to be a separate cmd\n    ENCRYPTION_CMD = 0x65,  // (e)ncryption\n    HEART_BEAT_CMD = 0x48,  // (H)eart-beat\n  };\n\n  // TODO: move the rest of those definitions closer to where they need to be\n  // correct, ie in cpp like kAbortLength and kChunksCmdLen\n\n  /// Max size of sender or receiver id\n  static constexpr int64_t kMaxTransferIdLength = 1024;\n  /// 1 byte for cmd, 2 bytes for file-name length, Max size of filename, 4\n  /// variants(seq-id, data-size, offset, file-size), 1 byte for flag, 10 bytes\n  /// prev seq-id\n  static constexpr int64_t kMaxHeader = 1 + 2 + PATH_MAX + 4 * 10 + 1 + 10;\n  /// min number of bytes that must be send to unblock receiver\n  static constexpr int64_t kMinBufLength = 256;\n  /// max size of done command encoding(1 byte for cmd, 1 for status, 10 for\n  /// number of blocks, 10 for number of bytes sent)\n  static constexpr int64_t kMaxDone = 2 + 2 * 10;\n  /// max length of the size cmd encoding\n  static constexpr int64_t kMaxSize = 1 + 10;\n  /// max size of settings command encoding\n  static constexpr int64_t kMaxSettings = 1 + 3 * 10 + kMaxTransferIdLength + 1;\n  /// max length of the footer cmd encoding, 10 byte for checksum\n  static constexpr int64_t kMaxFooter = 1 + 10;\n  /// max size of chunks cmd(4 bytes for buffer size and 4 bytes for number of\n  /// files)\n  static constexpr int64_t kChunksCmdLen = 2 * sizeof(int64_t);\n  /// max size of chunkInfo encoding length\n  static constexpr int64_t kMaxChunkEncodeLen = 20;\n  /// abort cmd length(4 bytes for protocol, 1 byte for error-code and 8 bytes\n  /// for checkpoint)\n  static constexpr int64_t kAbortLength = sizeof(int32_t) + 1 + sizeof(int64_t);\n  /// max size of version encoding\n  static constexpr int64_t kMaxVersion = 10;\n  /// max size of encryption cmd(1 byte for cmd, 1 byte for\n  /// encryption type, rest for initialization vector and tag interval)\n  static constexpr int64_t kEncryptionCmdLen =\n      1 + 1 + 1 + kAESBlockSize + sizeof(int32_t);\n\n  static_assert(kMinBufLength <= kMaxHeader && kMaxSettings <= kMaxHeader,\n                \"Minimum buffer size is kMaxHeader. Header and Settings cmd \"\n                \"must fit within the buffer\");\n  /**\n   * Return the library version, including protocol.\n   * For debugging/identification purpose.\n   */\n  static const std::string getFullVersion();\n\n  /**\n   * Decides whether the current running wdt version can support the request\n   * protocol version or not\n   *\n   * @param requestedProtocolVersion    protocol version requested\n   * @param curProtocolVersion          current protocol version\n   *\n   * @return    If current wdt supports the requested version or some lower\n   *            version, that version is returned. If it can not support the\n   *            requested version, 0 is returned\n   */\n  static int negotiateProtocol(int requestedProtocolVersion,\n                               int curProtocolVersion = protocol_version);\n\n  /// @return     max local checkpoint length for a specific version\n  static int getMaxLocalCheckpointLength(int protocolVersion);\n\n  /// encodes blockDetails into dest+off\n  /// moves the off into dest pointer, not going past max\n  /// @return false if there isn't enough room to encode\n  static bool encodeHeader(int senderProtocolVersion, char *dest, int64_t &off,\n                           int64_t max, const BlockDetails &blockDetails);\n\n  /// decodes from src+off and consumes/moves off but not past max\n  /// sets BlockDetails\n  /// @return false if there isn't enough data in src+off to src+max\n  static bool decodeHeader(int receiverProtocolVersion, char *src, int64_t &off,\n                           int64_t max, BlockDetails &blockDetails);\n\n  /// encodes checkpoints into dest+off\n  /// moves the off into dest pointer, not going past max\n  /// @return false if there isn't enough room to encode\n  static bool encodeCheckpoints(int protocolVersion, char *dest, int64_t &off,\n                                int64_t max,\n                                const std::vector<Checkpoint> &checkpoints);\n\n  /// decodes from src+off and consumes/moves off but not past max\n  /// sets checkpoints\n  /// @return false if there isn't enough data in src+off to src+max\n  static bool decodeCheckpoints(int protocolVersion, char *src, int64_t &off,\n                                int64_t max,\n                                std::vector<Checkpoint> &checkpoints);\n\n  /// encodes numBlocks, totalBytes into dest+off\n  /// moves the off into dest pointer, not going past max\n  /// @return false if there isn't enough room to encode\n  static bool encodeDone(int protocolVersion, char *dest, int64_t &off,\n                         int64_t max, int64_t numBlocks, int64_t totalBytes);\n\n  /// decodes from src+off and consumes/moves off but not past max\n  /// sets numBlocks, totalBytes\n  /// @return false if there isn't enough data in src+off to src+max\n  static bool decodeDone(int protocolVersion, char *src, int64_t &off,\n                         int64_t max, int64_t &numBlocks, int64_t &totalBytes);\n\n  /// encodes settings into dest+off\n  /// moves the off into dest pointer, not going past max\n  /// @return false if there isn't enough room to encode\n  static bool encodeSettings(int senderProtocolVersion, char *dest,\n                             int64_t &off, int64_t max,\n                             const Settings &settings);\n\n  /// decodes from src+off and consumes/moves off but not past max\n  /// sets senderProtocolVersion\n  /// @return false if there isn't enough data in src+off to src+max\n  static bool decodeVersion(char *src, int64_t &off, int64_t max,\n                            int &senderProtocolVersion);\n\n  /// decodes from src+off and consumes/moves off but not past max\n  /// sets settings\n  /// @return false if there isn't enough data in src+off to src+max\n  static bool decodeSettings(int protocolVersion, char *src, int64_t &off,\n                             int64_t max, Settings &settings);\n\n  /// encodes encryption info into dest+off\n  /// moves the off into dest pointer, not going past max\n  /// @return false if there isn't enough room to encode\n  static bool encodeEncryptionSettings(char *dest, int64_t &off, int64_t max,\n                                       const EncryptionType encryptionType,\n                                       const std::string &iv,\n                                       int32_t tagInterval);\n\n  /// decodes from src+off and consumes/moves off but not past max\n  /// sets encryption type, initializaion vector and tag interval\n  /// @return false if there isn't enough data in src+off to src+max\n  static bool decodeEncryptionSettings(char *src, int64_t &off, int64_t max,\n                                       EncryptionType &encryptionType,\n                                       std::string &iv, int32_t &tagInterval);\n\n  /// encodes totalNumBytes into dest+off\n  /// moves the off into dest pointer, not going past max\n  /// @return false if there isn't enough room to encode\n  static bool encodeSize(char *dest, int64_t &off, int64_t max,\n                         int64_t totalNumBytes);\n\n  /// decodes from src+off and consumes/moves off but not past max\n  /// sets totalNumBytes\n  /// @return false if there isn't enough data in src+off to src+max\n  static bool decodeSize(char *src, int64_t &off, int64_t max,\n                         int64_t &totalNumBytes);\n\n  /// encodes checksum or tag into dest+off\n  /// moves the off into dest pointer, not going past max\n  /// @return false if there isn't enough room to encode\n  static bool encodeFooter(char *dest, int64_t &off, int64_t max,\n                           int32_t checksum);\n\n  /// decodes from src+off and consumes/moves off but not past max\n  /// sets checksum or tag\n  /// @return false if there isn't enough data in src+off to src+max\n  static bool decodeFooter(char *src, int64_t &off, int64_t max,\n                           int32_t &checksum);\n\n  /// encodes protocolVersion, errCode and checkpoint into dest+off\n  /// moves the off into dest pointer\n  static bool encodeAbort(char *dest, int64_t &off, int64_t max,\n                          int32_t protocolVersion, ErrorCode errCode,\n                          int64_t checkpoint);\n\n  /// decodes from src+off and consumes/moves off\n  /// sets protocolversion, errcode, checkpoint\n  static bool decodeAbort(char *src, int64_t &off, int64_t max,\n                          int32_t &protocolVersion, ErrorCode &errCode,\n                          int64_t &checkpoint);\n\n  /// encodes bufSize and numFiles into dest+off\n  /// moves the off into dest pointer\n  static bool encodeChunksCmd(char *dest, int64_t &off, int64_t max,\n                              int64_t bufSize, int64_t numFiles);\n\n  /// decodes from src+off and consumes/moves off\n  /// sets bufSize and numFiles\n  static bool decodeChunksCmd(char *src, int64_t &off, int64_t max,\n                              int64_t &bufSize, int64_t &numFiles);\n\n  /// encodes chunk into dest+off\n  /// moves the off into dest pointer\n  static bool encodeChunkInfo(char *dest, int64_t &off, int64_t max,\n                              const Interval &chunk);\n\n  /// decodes from src+off and consumes/moves off\n  /// sets chunk\n  /// @return false if there isn't enough data in src+off to src+max\n  static bool decodeChunkInfo(folly::ByteRange &br, Interval &chunk);\n\n  /// encodes fileChunksInfo into dest+off\n  /// moves the off into dest pointer\n  static bool encodeFileChunksInfo(char *dest, int64_t &off, int64_t max,\n                                   const FileChunksInfo &fileChunksInfo);\n\n  /// decodes from src+off and consumes/moves off\n  /// sets fileChunksInfo\n  /// @return false if there isn't enough data in src+off to src+max\n  static bool decodeFileChunksInfo(folly::ByteRange &br,\n                                   FileChunksInfo &fileChunksInfo);\n\n  /**\n   * returns maximum number of bytes to encode a given FileChunksInfo\n   *\n   * @param fileChunkInfo    FileChunksInfo to encode\n   *\n   * @return                 max number of bytes to encode\n   */\n  static int64_t maxEncodeLen(const FileChunksInfo &fileChunkInfo);\n\n  /// encodes fileChunksInfo into dest+off\n  /// moves the off into dest pointer\n  /// returns number of fileChunks encoded\n  static int64_t encodeFileChunksInfoList(\n      char *dest, int64_t &off, int64_t bufSize, int64_t startIndex,\n      const std::vector<FileChunksInfo> &fileChunksInfoList);\n\n  /// decodes from src+off and consumes/moves off\n  /// sets fileChunksInfoList\n  /// @return false if there isn't enough data in src+off to src+max\n  static bool decodeFileChunksInfoList(\n      char *src, int64_t &off, int64_t dataSize,\n      std::vector<FileChunksInfo> &fileChunksInfoList);\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.521484375,
          "content": "![](build/wdt_logo.png)\n`WDT` Warp speed Data Transfer\n------------------------------\n\n[![Join the chat at https://gitter.im/facebook/wdt](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/facebook/wdt?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n[![Build Status](https://travis-ci.org/facebook/wdt.svg?branch=master)](https://travis-ci.org/facebook/wdt)\n\n## Design philosophy/Overview\n\nGoal:\nLowest possible total transfer time -  to be only hardware limited\n(disc or network bandwidth not latency) and as efficient as possible\n(low CPU/memory/resources utilization)\n\nWe keep dependencies minimal in order to maximize portability\nand ensure a small binary size. As a bonus, this also minimizes compile time.\n\nWe aren't using exceptions for performance reasons and because using exceptions\nwould make it harder to reason about the control flow of the library.\nWe also believe the WDT library is easier to integrate as a result.\nOur philosophy is to write moderately structured and encapsulated C code\nas opposed to using every feature of C++.\n\nWe try to minimize the number of system calls, which is one of the reasons\nwe are using blocking thread IOs. We can maximize system throughput because\nat any given point some threads are reading while others are writing, and data\nis buffered on both paths - keeping each subsystem busy while minimizing\nkernel to userspace switches.\n\n## Terminology\nWDT uses \"Mbytes\" everywhere in its output as 1024*1024 bytes = 1048576 bytes\n(technically this should be the new mebibyte (MiB) standard but it felt\nMbytes is be more in line with what other tools are using, clearer, easier\nto read and matching what a traditional \"megabyte\" used to mean in historical\nmemory units where the address lines are binary and thus power of two and not\nof ten)\n\n## Example\n\nWhile WDT is primarily a library, we also have a small command line tool\nwhich we use for tests and which is useful by itself. Here is a quick example:\n\n```\nReceiver side: (starts the server indicating destination directory)\n\n[ldemailly@devbig074]$ wdt -directory /data/users/ldemailly/transfer1\n\nSender side: (discover and sends all files in a directory tree to destination)\n\n[root@dev443]$ wdt -directory /usr/bin -destination devbig074.prn2\n\n[=================================================] 100% 588.8 Mbytes/s\nI0720 21:48:08.446014 3245296 Sender.cpp:314] Total sender time = 2.68699\nseconds (0.00640992 dirTime). Transfer summary : Transfer status = OK. Number\nof files transferred = 1887. Data Mbytes = 1582.08. Header Kbytes = 62.083\n(0.00383215% overhead). Total bytes = 1658999858. Wasted bytes due to\nfailure = 0 (0% overhead). Total sender throughput = 588.816 Mbytes/sec\n(590.224 Mbytes/sec pure transf rate)\n```\n\nNote that in this simple example with lots of small files (/usr/bin from\na linux distribution), but not much data (~1.5Gbyte), the maximum\nspeed isn't as good as it would with more data (as there is still a TCP ramp\nup time even though it's faster because of parallelization) like when we use\nit in our production use cases.\n\n## Performance/Results\n\nIn an internal use at Facebook to transfer RocksDB snapshot between hosts\nwe are able to transfer data at a throttled 600 Mbytes/sec even across\nlong distance, high latency links (e.g. Sweden to Oregon). That's 3x the speed\nof the previous highly optimized HTTP-based solution and with less strain on the\nsystem. When not throttling, we are able to easily saturate a 40 Gbit/s NIC and\nget near theoretical link speed (above 4 Gbytes/sec).\n\nWe have so far optimized WDT for servers with fast IOs - in particular flash\ncard or in-memory read/writes. If you use disks throughput won't be as good,\nbut we do plan on optimizing for disks as well in the future.\n\n## Dependencies\n\nCMake for building WDT - See [build/BUILD.md](build/BUILD.md)\n\ngflags (google flags library) but only for the command line,  the library\ndoesn't depend on that\n\ngtest (google testing) but only for tests\n\nglog (google logging library) - use W*LOG macros so everything logged by WDT\nis always prefixed by \"wdt>\" which helps when embedded in another service\n\nParts of Facebook's Folly open source library (as set in the CMakefile)\nMostly conv, threadlocal and checksum support.\n\nFor encryption, the crypto lib part of openssl-1.x\n\nYou can build and embed wdt as a library with as little as a C++11 compiler\nand glog - and you could macro away glog or replace it by printing to stderr if\nneeded.\n\n## Code layout\n\n### Directories\n\n* top level\nMain WDT classes and Wdt command line source, CMakeLists.txt\n\n* util/\nUtilities used for implementing the main objects\n\n* test/\nTests files and scripts\n\n* build/\nBuild related scripts and files and utils\n\n\n* fbonly/\nStuff specific to facebook/ (not in open source version)\n\n* bench/\nBenchmark generation tools\n\n\n### Main files\n\n* CMakeLists.txt, .travis.yml, build/BUILD.md,travis_linux.sh,travis_osx.sh\nBuild definition file - use CMake to generate a Makefile or a project file for\nyour favorite IDE - details in [build/BUILD.md](build/BUILD.md)\n\n* wdtCmdline.cpp\n\nMain program which allows to have a server or client process to exercise\nthe library (for end 2 end test as well as a standalone utility)\n\n* wcp.sh\n\nA script to use wdt like scp for single big files - pending splitting support\ninside wdt proper the script does the splitting for you. install as \"wcp\".\n\n* WdtOptions.{h|cpp}\n\nTo specify the behavior of wdt. If wdt is used as a library, then the\ncaller get the mutable object of options and set different options accordingly.\nWhen wdt is run in a standalone mode, behavior is changed through gflags in\nwdtCmdLine.cpp\n\n* WdtThread.{h|cpp}\nCommon functionality and settings between SenderThread and ReceiverThread.\nBoth of these kind of threads inherit from this base class.\n\n* WdtBase.{h|cpp}\n\nCommon functionality and settings between Sender and Receiver\n\n* WdtResourceController.{h|cpp}\n\nOptional factory for Sender/Receiver with limit on number being created.\n\n### Producing/Sending\n\n* ByteSource.h\n\nInterface for a data element to be sent/transferred\n\n* FileByteSource.{h|cpp}\n\nImplementation/concrete subclass of ByteSource for a file identified as a\nrelative path from a root dir. The identifier (path) sent remotely is\nthe relative path\n\n* SourceQueue.h\n\nInterface for producing next ByteSource to be sent\n\n* DirectorySourceQueue.{h|cpp}\n\nConcrete implementation of SourceQueue producing all the files in a given\ndirectory, sorted by decreasing size (as they are discovered, you can start\npulling from the queue even before all the files are found, it will return\nthe current largest file)\n\n* ThreadTransferHistory.{h|cpp}\n\nEvery thread maintains a transfer history so that when a connection breaks\nit can talk to the receiver to find out up to where in the history has been\nsent. This class encapsulates all the logic for that bookkeeping\n\n* SenderThread.{h|cpp}\n\nImplements the functionality of one sender thread, which binds to a certain port\nand sends files over.\n\n* Sender.{h|cpp}\n\nSpawns multiple SenderThread threads and sends the data across to receiver\n\n### Consuming / Receiving\n\n* FileCreator.{h|cpp}\n\nCreates file and directories necessary for said file (mkdir -p like)\n\n* ReceiverThread.{h|cpp}\n\nImplements the functionality of the receiver threads, responsible for listening on\na port and receiving files over the network.\n\n* Receiver.{h|cpp}\n\nParent receiver class that spawns multiple ReceiverThread threads and receives\ndata from a remote host\n\n### Low level building blocks\n\n* ServerSocket.{h|.cpp}\n\nEncapsulate a server socket listening on a port and giving a file descriptor\nto be used to communicate with the client\n\n* ClientSocket.{h|cpp}\n\nClient socket wrapper - connection to a server port -> fd\n\n* Protocol.{h|cpp}\n\nDecodes/Encodes meta information needed to interpret the data stream:\nthe id (file path) and size (byte length of the data)\n\n* SocketUtils.{h|cpp}\n\nCommon socket related utilities (both client/server, sender/receiver side use)\n\n* Throttler.{h|cpp}\n\nThrottling code\n\n* ErrorCodes.h\n\nHeader file for error codes\n\n* Reporting.{h|cpp}\n\nClass representing transfer stats and reports\n\n## Future development/extensibility\n\nThe current implementation works well and has high efficiency.\nIt is also extensible by implementing different byte sources both in and\nout. But inserting processing units isn't as easy.\n\nFor that we plan on restructuring the code to use a Zero copy stream/buffer\npipeline: To maintain efficiency, the best overall total transfer time and\ntime to first byte we can see WDT's internal architecture as chainable units\n\n[Disk/flash/Storage IO] -> [Compression] -> [Protocol handling]\n-> [Encryption] -> [Network IO]\n\nAnd the reverse chain on the receiving/writing end\nThe trick is the data is variable length input and some units can change length\nand we need to process things by blocks\nConstraints/Design:\n- No locking / contention when possible\n- (Hard) Limits on memory used\n- Minimal number of copies/moving memory around\n- Still works the same for simple\n   read file fd -> control -> write socked fd current basic implementation\n\nPossible Solution(?) API:\n- Double linked list of Units\n- read/pull from left (pull() ?)\n- push to the right (push() ?)\n- end of stream from left\n- propagate last bytes to right\n\nCan still be fully synchronous / blocking, works thanks to eof handling\n(synchronous gives us lock free/single thread - internally a unit is\nfree to use parallelization like the compression stage is likely to want/need)\n\nAnother thing we touched on is processing chunks out of order - by changing\nheader to be ( fileid, offset, size ) instead of ( filename, size )\nand assuming everything is following in 1 continuous block (will also help\nthe use case of small number of large files/chunks) : mmap'in\nthe target/destination file\nThe issue then is who creates it in what order - similar to the directory\ncreation problem - we could use a meta info channel to avoid locking/contention\nbut that requires synchronization\n\nWe want things to work with even up to 1 second latency without incurring\na 1 second delay before we send the first payload byte\n\n\n## Submitting diffs/making changes\n\nSee CONTRIBUTING.md\n\nPlease run the tests\n```\nCTEST_OUTPUT_ON_FAILURE=1 make test\n```\nAnd ideally also the manual tests (integration/porting upcoming)\n\nwdt_e2e_test.sh\nwdt_download_resumption_test.sh\nwdt_network_test.sh\nwdt_max_send_test.sh\n\n(facebook only:)\nMake sure to do the following, before \"arc diff\":\n```\n (cd wdt ; ./build/clangformat.sh )\n # if you changed the minor version of the protocol (in CMakeLists.txt)\n # run (cd wdt ; ./build/version_update.tcl ) to sync with fbcode's WdtConfig.h\n\n fbconfig  --clang --sanitize=address -r  wdt\n\n fbmake runtests --run-disabled --extended-tests\n # Optionally: opt build\n fbmake runtests_opt\n fbmake opt\n # Sender max speed test\n wdt/test/wdt_max_send_test.sh\n # Check buck build\n buck build wdt/...\n # Debug a specific test with full output even on success:\n buck test wdt:xxx -- --run-disabled --extended-tests --print-passing-details\\\n   --print-long-results\n```\n\nand check the output of the last step to make sure one of the 3 runs is\nstill above 20,000 Mbytes/sec (you may need to make sure you\n/dev/shm is mostly empty to get the best memory throughput, as well\nas not having a ton of random processes running during the test)\n\nAlso :\n\n* Update this file\n* Make sure your diff has a task\n* Put (relevant) log output of sender/receiver in the diff test plan or comment\n* Depending on the changes\n  * Perf: wdt/wdt_e2e_test.sh has a mix of ~ > 700 files, > 8 Gbytes/sec\n  * do run remote network tests (wdt/wdt_remote_test.sh)\n  * do run profiler and check profile results (wdt/fbonly/wdt_prof.sh)\n    80k small files at > 1.6 Gbyte/sec\n"
        },
        {
          "name": "Receiver.cpp",
          "type": "blob",
          "size": 19.0908203125,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <fcntl.h>\n#include <folly/Conv.h>\n#include <folly/lang/Bits.h>\n#include <gflags/gflags.h>\n#include <glog/logging.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <wdt/Receiver.h>\n#include <wdt/util/EncryptionUtils.h>\n#include <wdt/util/ServerSocket.h>\n\n#include <thread>\n\nnamespace facebook {\nnamespace wdt {\n\nvoid Receiver::addCheckpoint(Checkpoint checkpoint) {\n  WLOG(INFO) << \"Adding global checkpoint \" << checkpoint.port << \" \"\n             << checkpoint.numBlocks << \" \"\n             << checkpoint.lastBlockReceivedBytes;\n  checkpoints_.emplace_back(checkpoint);\n}\n\nstd::vector<Checkpoint> Receiver::getNewCheckpoints(int startIndex) {\n  std::vector<Checkpoint> checkpoints;\n  const int64_t numCheckpoints = checkpoints_.size();\n  for (int64_t i = startIndex; i < numCheckpoints; i++) {\n    checkpoints.emplace_back(checkpoints_[i]);\n  }\n  return checkpoints;\n}\n\nReceiver::Receiver(const WdtTransferRequest &transferRequest) {\n  WLOG(INFO) << \"WDT Receiver \" << Protocol::getFullVersion();\n  transferRequest_ = transferRequest;\n}\n\nReceiver::Receiver(int port, int numSockets, const std::string &destDir)\n    : Receiver(WdtTransferRequest(port, numSockets, destDir)) {\n}\n\nvoid Receiver::setSocketCreator(Receiver::ISocketCreator *socketCreator) {\n  socketCreator_ = socketCreator;\n}\n\nvoid Receiver::traverseDestinationDir(\n    std::vector<FileChunksInfo> &fileChunksInfo) {\n  DirectorySourceQueue dirQueue(options_, getDirectory(),\n                                &abortCheckerCallback_);\n  dirQueue.buildQueueSynchronously();\n  auto &discoveredFilesInfo = dirQueue.getDiscoveredFilesMetaData();\n  for (auto &fileInfo : discoveredFilesInfo) {\n    if (fileInfo->relPath == kWdtLogName ||\n        fileInfo->relPath == kWdtBuggyLogName) {\n      // do not include wdt log files\n      WVLOG(1) << \"Removing \" << fileInfo->relPath\n               << \" from the list of existing files\";\n      continue;\n    }\n    FileChunksInfo chunkInfo(fileInfo->seqId, fileInfo->relPath,\n                             fileInfo->size);\n    chunkInfo.addChunk(Interval(0, fileInfo->size));\n    fileChunksInfo.emplace_back(std::move(chunkInfo));\n  }\n  return;\n}\n\nvoid Receiver::startNewGlobalSession(const std::string &peerIp) {\n  if (throttler_) {\n    // If throttler is configured/set then register this session\n    // in the throttler. This is guranteed to work in either of the\n    // modes long running or not. We will de register from the throttler\n    // when the current session ends\n    throttler_->startTransfer();\n  }\n  startTime_.store(Clock::now());\n  if (options_.enable_download_resumption) {\n    transferLogManager_->startThread();\n    bool verifySuccessful = transferLogManager_->verifySenderIp(peerIp);\n    if (!verifySuccessful) {\n      fileChunksInfo_.clear();\n    }\n  }\n  hasNewTransferStarted_.store(true);\n  WLOG(INFO) << \"Starting new transfer,  peerIp \" << peerIp << \" , transfer id \"\n             << getTransferId();\n}\n\nbool Receiver::hasNewTransferStarted() const {\n  return hasNewTransferStarted_.load();\n}\n\nvoid Receiver::endCurGlobalSession() {\n  setTransferStatus(TransferStatus::FINISHED);\n  if (!hasNewTransferStarted_) {\n    WLOG(WARNING) << \"WDT transfer did not start, no need to end session\";\n    return;\n  }\n  WLOG(INFO) << \"Ending the transfer \" << getTransferId();\n  if (throttler_) {\n    throttler_->endTransfer();\n  }\n  checkpoints_.clear();\n  if (fileCreator_) {\n    fileCreator_->clearAllocationMap();\n  }\n  // TODO might consider moving closing the transfer log here\n  hasNewTransferStarted_.store(false);\n}\n\nconst WdtTransferRequest &Receiver::init() {\n  if (validateTransferRequest() != OK) {\n    WLOG(ERROR) << \"Couldn't validate the transfer request \"\n                << transferRequest_.getLogSafeString();\n    return transferRequest_;\n  }\n  transferLogManager_ =\n      std::make_unique<TransferLogManager>(options_, getDirectory());\n  checkAndUpdateBufferSize();\n  backlog_ = options_.backlog;\n  if (getTransferId().empty()) {\n    setTransferId(WdtBase::generateTransferId());\n  }\n  negotiateProtocol();\n  auto numThreads = transferRequest_.ports.size();\n  // This creates the destination directory (which is needed for transferLogMgr)\n  fileCreator_.reset(new FileCreator(\n      getDirectory(), numThreads, *transferLogManager_, options_.skip_writes));\n\n  transferRequest_.downloadResumptionEnabled =\n      options_.enable_download_resumption;\n\n  // Make sure we can get the lock on the transfer log manager early\n  // so if we can't we don't generate a valid but useless url and end up\n  // starting a sender doomed to fail\n  if (options_.enable_download_resumption) {\n    WDT_CHECK(!options_.skip_writes)\n        << \"Can not skip transfers with download resumption turned on\";\n    if (options_.resume_using_dir_tree) {\n      WDT_CHECK(!options_.shouldPreallocateFiles())\n          << \"Can not resume using directory tree if preallocation is enabled\";\n    }\n    ErrorCode errCode = transferLogManager_->openLog();\n    if (errCode != OK) {\n      WLOG(ERROR) << \"Failed to open transfer log \" << errorCodeToStr(errCode);\n      transferRequest_.errorCode = errCode;\n      return transferRequest_;\n    }\n    ErrorCode code = transferLogManager_->parseAndMatch(\n        recoveryId_, getTransferConfig(), fileChunksInfo_);\n    if (code == OK && options_.resume_using_dir_tree) {\n      WDT_CHECK(fileChunksInfo_.empty());\n      traverseDestinationDir(fileChunksInfo_);\n    }\n  }\n\n  EncryptionType encryptionType = parseEncryptionType(options_.encryption_type);\n  // is encryption enabled?\n  bool encrypt = (encryptionType != ENC_NONE &&\n                  getProtocolVersion() >= Protocol::ENCRYPTION_V1_VERSION);\n  if (encrypt) {\n    WLOG(INFO) << encryptionTypeToStr(encryptionType)\n               << \" encryption is enabled for this transfer \";\n    if (!transferRequest_.encryptionData.isSet()) {\n      WLOG(INFO) << \"Receiver generating encryption key for type \"\n                 << encryptionTypeToStr(encryptionType);\n      transferRequest_.encryptionData =\n          EncryptionParams::generateEncryptionParams(encryptionType);\n    }\n    if (!transferRequest_.encryptionData.isSet()) {\n      WLOG(ERROR) << \"Unable to generate encryption key for type \"\n                  << encryptionTypeToStr(encryptionType);\n      transferRequest_.errorCode = ENCRYPTION_ERROR;\n      return transferRequest_;\n    }\n  } else {\n    if (encryptionType != ENC_NONE) {\n      WLOG(WARNING) << \"Encryption is enabled, but protocol version is \"\n                    << getProtocolVersion()\n                    << \", minimum version required for encryption is \"\n                    << Protocol::ENCRYPTION_V1_VERSION;\n    }\n    transferRequest_.encryptionData.erase();\n  }\n  transferRequest_.ivChangeInterval = options_.iv_change_interval_mb * kMbToB;\n  if (options_.max_accept_retries <= 0) {\n    WLOG(INFO) << \"Max accept retries \" << options_.max_accept_retries\n               << \", will accept forever\";\n    setAcceptMode(ACCEPT_FOREVER);\n  }\n  threadsController_ = new ThreadsController(numThreads);\n  threadsController_->setNumFunnels(ReceiverThread::NUM_FUNNELS);\n  threadsController_->setNumBarriers(ReceiverThread::NUM_BARRIERS);\n  threadsController_->setNumConditions(ReceiverThread::NUM_CONDITIONS);\n  // TODO: take transferRequest directly !\n  receiverThreads_ = threadsController_->makeThreads<Receiver, ReceiverThread>(\n      this, transferRequest_.ports.size(), transferRequest_.ports);\n  size_t numSuccessfulInitThreads = 0;\n  for (auto &receiverThread : receiverThreads_) {\n    ErrorCode code = receiverThread->init();\n    if (code == OK) {\n      ++numSuccessfulInitThreads;\n    }\n  }\n  WLOG(INFO) << \"Registered \" << numSuccessfulInitThreads\n             << \" successful sockets\";\n  ErrorCode code = OK;\n  const size_t targetSize = transferRequest_.ports.size();\n  // TODO: replace with getNumPorts/thread\n  if (numSuccessfulInitThreads != targetSize) {\n    code = FEWER_PORTS;\n    if (numSuccessfulInitThreads == 0) {\n      code = ERROR;\n    }\n  }\n\n  transferRequest_.ports.clear();\n  for (const auto &receiverThread : receiverThreads_) {\n    transferRequest_.ports.push_back(receiverThread->getPort());\n  }\n\n  if (transferRequest_.hostName.empty()) {\n    char hostName[1024];\n    int ret = gethostname(hostName, sizeof(hostName));\n    if (ret == 0) {\n      transferRequest_.hostName.assign(hostName);\n    } else {\n      WPLOG(ERROR) << \"Couldn't find the local host name\";\n      code = ERROR;\n    }\n  }\n  transferRequest_.errorCode = code;\n  return transferRequest_;\n}\n\nTransferLogManager &Receiver::getTransferLogManager() {\n  return *transferLogManager_;\n}\n\nstd::unique_ptr<FileCreator> &Receiver::getFileCreator() {\n  return fileCreator_;\n}\n\nvoid Receiver::setRecoveryId(const std::string &recoveryId) {\n  recoveryId_ = recoveryId;\n  WLOG(INFO) << \"recovery id \" << recoveryId_;\n}\n\nvoid Receiver::setAcceptMode(const AcceptMode acceptMode) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  acceptMode_ = acceptMode;\n}\n\nReceiver::AcceptMode Receiver::getAcceptMode() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  return acceptMode_;\n}\n\nReceiver::~Receiver() {\n  TransferStatus status = getTransferStatus();\n  if (status == TransferStatus::ONGOING) {\n    WLOG(WARNING) << \"There is an ongoing transfer and the destructor\"\n                  << \" is being called. Trying to finish the transfer\";\n    abort(ABORTED_BY_APPLICATION);\n  }\n  finish();\n}\n\nconst std::vector<FileChunksInfo> &Receiver::getFileChunksInfo() const {\n  return fileChunksInfo_;\n}\n\nint64_t Receiver::getTransferConfig() const {\n  int64_t config = 0;\n  if (options_.shouldPreallocateFiles()) {\n    config = 1;\n  }\n  if (options_.resume_using_dir_tree) {\n    config |= (1 << 1);\n  }\n  return config;\n}\n\nstd::unique_ptr<TransferReport> Receiver::finish() {\n  std::unique_lock<std::mutex> instanceLock(instanceManagementMutex_);\n  TransferStatus status = getTransferStatus();\n  if (status == TransferStatus::NOT_STARTED) {\n    WLOG(WARNING) << \"Even though transfer has not started, finish is called\";\n    // getTransferReport will set the error code to ERROR\n    return getTransferReport();\n  }\n  if (status == TransferStatus::THREADS_JOINED) {\n    WLOG(WARNING) << \"Threads have already been joined. Returning the \"\n                  << \"transfer report\";\n    return getTransferReport();\n  }\n  if (!isJoinable_) {\n    // TODO: don't complain about this when coming from runForever()\n    WLOG(WARNING) << \"The receiver is not joinable. The threads will never\"\n                  << \" finish and this method will never return\";\n  }\n  for (auto &receiverThread : receiverThreads_) {\n    receiverThread->finish();\n  }\n\n  setTransferStatus(TransferStatus::THREADS_JOINED);\n\n  if (isJoinable_) {\n    // Make sure to join the progress thread.\n    progressTrackerThread_.join();\n  }\n  std::unique_ptr<TransferReport> report = getTransferReport();\n  auto &summary = report->getSummary();\n  bool transferSuccess = (report->getSummary().getErrorCode() == OK);\n  fixAndCloseTransferLog(transferSuccess);\n  auto totalSenderBytes = summary.getTotalSenderBytes();\n  if (progressReporter_ && totalSenderBytes >= 0) {\n    report->setTotalFileSize(totalSenderBytes);\n    report->setTotalTime(durationSeconds(Clock::now() - startTime_.load()));\n    progressReporter_->end(report);\n  }\n  logPerfStats();\n\n  WLOG(WARNING) << \"WDT receiver's transfer has been finished\";\n  WLOG(INFO) << *report;\n  return report;\n}\n\nstd::unique_ptr<TransferReport> Receiver::getTransferReport() {\n  TransferStats globalStats;\n  for (const auto &receiverThread : receiverThreads_) {\n    globalStats += receiverThread->getTransferStats();\n  }\n  std::unique_ptr<TransferReport> transferReport =\n      std::make_unique<TransferReport>(std::move(globalStats));\n  TransferStatus status = getTransferStatus();\n  ErrorCode errCode = transferReport->getSummary().getErrorCode();\n  if (status == TransferStatus::NOT_STARTED && errCode == OK) {\n    WLOG(INFO) << \"Transfer not started, setting the error code to ERROR\";\n    transferReport->setErrorCode(ERROR);\n  }\n  WVLOG(1) << \"Summary code \" << errCode;\n  return transferReport;\n}\n\nErrorCode Receiver::transferAsync() {\n  isJoinable_ = true;\n  int progressReportIntervalMillis = options_.progress_report_interval_millis;\n  if (!progressReporter_ && progressReportIntervalMillis > 0) {\n    // if progress reporter has not been set, use the default one\n    progressReporter_ = std::make_unique<ProgressReporter>(transferRequest_);\n  }\n  return start();\n}\n\nErrorCode Receiver::runForever() {\n  WDT_CHECK(!options_.enable_download_resumption)\n      << \"Transfer resumption not supported in long running mode\";\n\n  // Enforce the full reporting to be false in the daemon mode.\n  // These statistics are expensive, and useless as they will never\n  // be received/reviewed in a forever running process.\n  ErrorCode errCode = start();\n  if (errCode != OK) {\n    return errCode;\n  }\n  finish();\n  // This method should never finish\n  return ERROR;\n}\n\nvoid Receiver::progressTracker() {\n  // Progress tracker will check for progress after the time specified\n  // in milliseconds.\n  int progressReportIntervalMillis = options_.progress_report_interval_millis;\n  int throughputUpdateIntervalMillis =\n      options_.throughput_update_interval_millis;\n  if (progressReportIntervalMillis <= 0 || throughputUpdateIntervalMillis < 0 ||\n      !isJoinable_) {\n    return;\n  }\n  int throughputUpdateInterval =\n      throughputUpdateIntervalMillis / progressReportIntervalMillis;\n\n  int64_t lastEffectiveBytes = 0;\n  std::chrono::time_point<Clock> lastUpdateTime = Clock::now();\n  int intervalsSinceLastUpdate = 0;\n  double currentThroughput = 0;\n  WLOG(INFO) << \"Progress reporter updating every \"\n             << progressReportIntervalMillis << \" ms\";\n  auto waitingTime = std::chrono::milliseconds(progressReportIntervalMillis);\n  int64_t totalSenderBytes = -1;\n  while (true) {\n    {\n      std::unique_lock<std::mutex> lock(mutex_);\n      conditionFinished_.wait_for(lock, waitingTime);\n      if (transferStatus_ == TransferStatus::THREADS_JOINED) {\n        break;\n      }\n    }\n    double totalTime = durationSeconds(Clock::now() - startTime_.load());\n    TransferStats globalStats;\n    for (const auto &receiverThread : receiverThreads_) {\n      globalStats += receiverThread->getTransferStats();\n    }\n    totalSenderBytes = globalStats.getTotalSenderBytes();\n    // Note: totalSenderBytes may not be valid yet if sender has not\n    // completed file discovery.  But that's ok, report whatever progress\n    // we can.\n    auto transferReport = std::make_unique<TransferReport>(\n        std::move(globalStats), totalTime, totalSenderBytes, 0, true);\n    intervalsSinceLastUpdate++;\n    if (intervalsSinceLastUpdate >= throughputUpdateInterval) {\n      auto curTime = Clock::now();\n      int64_t curEffectiveBytes =\n          transferReport->getSummary().getEffectiveDataBytes();\n      double time = durationSeconds(curTime - lastUpdateTime);\n      currentThroughput = (curEffectiveBytes - lastEffectiveBytes) / time;\n      lastEffectiveBytes = curEffectiveBytes;\n      lastUpdateTime = curTime;\n      intervalsSinceLastUpdate = 0;\n    }\n    transferReport->setCurrentThroughput(currentThroughput);\n\n    progressReporter_->progress(transferReport);\n    if (reportPerfSignal_.notified()) {\n      logPerfStats();\n    }\n  }\n}\n\nvoid Receiver::logPerfStats() const {\n  if (!options_.enable_perf_stat_collection) {\n    return;\n  }\n\n  PerfStatReport globalPerfReport(options_);\n  for (auto &receiverThread : receiverThreads_) {\n    globalPerfReport += receiverThread->getPerfReport();\n  }\n  WLOG(INFO) << globalPerfReport;\n}\n\nErrorCode Receiver::start() {\n  WDT_CHECK_EQ(getTransferStatus(), TransferStatus::NOT_STARTED)\n      << \"There is already a transfer running on this instance of receiver\";\n  startTime_ = Clock::now();\n  WLOG(INFO) << \"Starting (receiving) server on ports [ \"\n             << transferRequest_.ports << \"] Target dir : \" << getDirectory();\n  // TODO do the init stuff here\n  if (!throttler_) {\n    configureThrottler();\n  } else {\n    WLOG(INFO) << \"Throttler set externally. Throttler : \" << *throttler_;\n  }\n  setTransferStatus(TransferStatus::ONGOING);\n  while (true) {\n    for (auto &receiverThread : receiverThreads_) {\n      receiverThread->startThread();\n    }\n    if (isJoinable_) {\n      break;\n    }\n    // If it is long running mode, finish the threads\n    // processing the current transfer and re spawn them again\n    // with the same sockets\n    for (auto &receiverThread : receiverThreads_) {\n      receiverThread->finish();\n      receiverThread->reset();\n    }\n    threadsController_->reset();\n    // reset transfer status\n    setTransferStatus(TransferStatus::NOT_STARTED);\n    continue;\n  }\n  if (isJoinable_) {\n    if (progressReporter_) {\n      progressReporter_->start();\n    }\n    std::thread trackerThread(&Receiver::progressTracker, this);\n    progressTrackerThread_ = std::move(trackerThread);\n  }\n  return OK;\n}\n\nvoid Receiver::addTransferLogHeader(bool isBlockMode, bool isSenderResuming) {\n  if (!options_.enable_download_resumption) {\n    return;\n  }\n  bool invalidationEntryNeeded = false;\n  if (!isSenderResuming) {\n    WLOG(INFO) << \"Sender is not in resumption mode. Invalidating directory.\";\n    invalidationEntryNeeded = true;\n  } else if (options_.resume_using_dir_tree && isBlockMode) {\n    WLOG(INFO) << \"Sender is running in block mode, but receiver is running in \"\n                  \"size based resumption mode. Invalidating directory.\";\n    invalidationEntryNeeded = true;\n  }\n  if (invalidationEntryNeeded) {\n    transferLogManager_->invalidateDirectory();\n  }\n  bool isInconsistentDirectory =\n      (transferLogManager_->getResumptionStatus() == INCONSISTENT_DIRECTORY);\n  bool shouldWriteHeader =\n      (!options_.resume_using_dir_tree || !isInconsistentDirectory);\n  if (shouldWriteHeader) {\n    transferLogManager_->writeLogHeader();\n  }\n}\n\nvoid Receiver::fixAndCloseTransferLog(bool transferSuccess) {\n  if (!options_.enable_download_resumption) {\n    return;\n  }\n\n  bool isInconsistentDirectory =\n      (transferLogManager_->getResumptionStatus() == INCONSISTENT_DIRECTORY);\n  bool isInvalidLog =\n      (transferLogManager_->getResumptionStatus() == INVALID_LOG);\n  if (transferSuccess && isInconsistentDirectory) {\n    // write log header to validate directory in case of success\n    WDT_CHECK(options_.resume_using_dir_tree);\n    transferLogManager_->writeLogHeader();\n  }\n\n  if (options_.enable_transfer_log_compaction && transferSuccess &&\n      !isInvalidLog && options_.keep_transfer_log &&\n      !options_.resume_using_dir_tree) {\n    transferLogManager_->compactLog();\n  } else {\n    WLOG(INFO) << \"Skip compacting transfer log\";\n    WVLOG(1) << \"options_.enable_transfer_log_compaction=\"\n             << options_.enable_transfer_log_compaction\n             << \" isInvalidLog=\" << isInvalidLog\n             << \" options_.keep_transfer_log=\" << options_.keep_transfer_log\n             << \" options_.resume_using_dir_tree=\"\n             << options_.resume_using_dir_tree;\n  }\n\n  transferLogManager_->closeLog();\n\n  if (!transferSuccess) {\n    return;\n  }\n\n  if (isInvalidLog) {\n    transferLogManager_->renameBuggyLog();\n  }\n\n  if (!options_.keep_transfer_log) {\n    transferLogManager_->unlink();\n  }\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "Receiver.h",
          "type": "blob",
          "size": 6.875,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n#include <wdt/ReceiverThread.h>\n#include <wdt/WdtBase.h>\n#include <wdt/util/FileCreator.h>\n#include <wdt/util/IServerSocket.h>\n#include <wdt/util/TransferLogManager.h>\n\n#include <chrono>\n#include <memory>\n#include <string>\n#include <thread>\n\nnamespace facebook {\nnamespace wdt {\n/**\n * Receiver is the receiving side of the transfer. Receiver listens on ports\n * accepts connections, receives the files and writes to the destination\n * directory. Receiver has two modes of operation : You can spawn a receiver\n * for one transfer or alternatively it can also be used in a long running\n * mode where it accepts subsequent transfers and runs in an infinite loop.\n */\nclass Receiver : public WdtBase {\n public:\n  /// Constructor using wdt transfer request (@see in WdtBase.h)\n  explicit Receiver(const WdtTransferRequest &transferRequest);\n\n  /**\n   * Constructor with start port, number of ports and directory to write to.\n   * If the start port is specified as zero, it auto configures the ports\n   */\n  Receiver(int port, int numSockets, const std::string &destDir);\n\n  /// Setup before starting (@see WdtBase.h)\n  const WdtTransferRequest &init() override;\n\n  /**\n   * Joins on the threads spawned by start. This method\n   * is called by default when the wdt receiver is expected\n   * to run as forever running process. However this has to\n   * be explicitly called when the caller expects to conclude\n   * a transfer.\n   */\n  std::unique_ptr<TransferReport> finish() override;\n\n  /**\n   * Call this method instead of transferAsync() when you don't\n   * want the wdt receiver to stop after one transfer.\n   */\n  ErrorCode runForever();\n\n  /**\n   * Starts the threads, and returns. Caller should call finish() after\n   * calling this method to get the statistics of the transfer.\n   */\n  ErrorCode transferAsync() override;\n\n  /// @param recoveryId   unique-id used to verify transfer log\n  void setRecoveryId(const std::string &recoveryId);\n\n  /// Returns true if at least one thread has accepted connection\n  bool hasNewTransferStarted() const;\n\n  // Different accept modes for the Receiver\n  enum AcceptMode {\n    ACCEPT_WITH_RETRIES,  // Receiver gives up after max_accept_retries\n    ACCEPT_FOREVER,       // Receiver never gives up\n    STOP_ACCEPTING,       // Receiver stops accepting\n  };\n\n  /// @param acceptMode   acceptMode to use\n  void setAcceptMode(AcceptMode acceptMode);\n\n  /// Interface to make socket\n  class ISocketCreator {\n   public:\n    virtual std::unique_ptr<IServerSocket> makeServerSocket(\n        ThreadCtx &threadCtx, int port, int backlog,\n        const EncryptionParams &encryptionParams, int64_t ivChangeInterval,\n        Func &&tagVerificationSuccessCallback, bool tls) = 0;\n\n    virtual ~ISocketCreator() = default;\n  };\n\n  /**\n   * Sets socket creator\n   *\n   * @param socketCreator   socket-creator to be used\n   */\n  void setSocketCreator(ISocketCreator *socketCreator);\n\n  /**\n   * Destructor for the receiver. The destructor automatically cancels\n   * any incomplete transfers that are going on. 'Incomplete transfer' is a\n   * transfer where there is no receiver thread that has received\n   * confirmation from wdt sender that the transfer is 'DONE'. Destructor also\n   * internally calls finish() for every transfer if finish() wasn't called\n   */\n  ~Receiver() override;\n\n protected:\n  friend class ReceiverThread;\n\n  /**\n   * Traverses root directory and returns discovered file information\n   *\n   * @param fileChunksInfo     discovered file info\n   */\n  void traverseDestinationDir(std::vector<FileChunksInfo> &fileChunksInfo);\n\n  /// Get the transferred file chunks info\n  const std::vector<FileChunksInfo> &getFileChunksInfo() const;\n\n  /// Get file creator, used by receiver threads\n  std::unique_ptr<FileCreator> &getFileCreator();\n\n  /// Socket creator used to optionally create different kind of server socket\n  ISocketCreator *socketCreator_{nullptr};\n\n  /// Get the ref to transfer log manager\n  TransferLogManager &getTransferLogManager();\n\n  /// Responsible for basic setup and starting threads\n  ErrorCode start();\n\n  /**\n   * Periodically calculates current transfer report and send it to progress\n   * reporter. This only works in the single transfer mode.\n   */\n  void progressTracker();\n\n  /**\n   * Adds a checkpoint to the global checkpoint list\n   * @param checkpoint    checkpoint to be added\n   */\n  void addCheckpoint(Checkpoint checkpoint);\n\n  /**\n   * @param startIndex    number of checkpoints already transferred by the\n   *                      calling thread\n   * @return              list of new checkpoints\n   */\n  std::vector<Checkpoint> getNewCheckpoints(int startIndex);\n\n  /// Does the steps needed before a new transfer is started\n  void startNewGlobalSession(const std::string &peerIp);\n\n  /// Has steps to do when the current transfer is ended\n  void endCurGlobalSession();\n\n  /// adds log header and also a directory invalidation entry if needed\n  void addTransferLogHeader(bool isBlockMode, bool isSenderResuming);\n\n  /// fix, compact (if enabled) and close transfer log\n  void fixAndCloseTransferLog(bool transferSuccess);\n\n  /**\n   * Get transfer report, meant to be called after threads have been finished\n   * This method is not thread safe\n   */\n  std::unique_ptr<TransferReport> getTransferReport();\n\n  void logPerfStats() const override;\n\n  /// @return     transfer config encoded as int\n  int64_t getTransferConfig() const;\n\n  AcceptMode getAcceptMode();\n\n  /// The thread that is responsible for calling running the progress tracker\n  std::thread progressTrackerThread_;\n\n  /// Flag based on which threads finish processing on receiving a done\n  bool isJoinable_{false};\n\n  /// Responsible for writing files on the disk\n  std::unique_ptr<FileCreator> fileCreator_{nullptr};\n\n  /**\n   * Unique-id used to verify transfer log. This value must be same for\n   * transfers across resumption\n   */\n  std::string recoveryId_;\n\n  /**\n   * The instance of the receiver threads are stored in this vector.\n   * This will not be destroyed until this object is destroyed, hence\n   * it has to be made sure that these threads are joined at least before\n   * the destruction of this object.\n   */\n  std::vector<std::unique_ptr<WdtThread>> receiverThreads_;\n\n  /// Transfer log manager\n  std::unique_ptr<TransferLogManager> transferLogManager_;\n\n  /// Global list of checkpoints\n  std::vector<Checkpoint> checkpoints_;\n\n  /// Start time of the session\n  std::atomic<std::chrono::time_point<Clock>> startTime_;\n\n  /// already transferred file chunks\n  std::vector<FileChunksInfo> fileChunksInfo_;\n\n  /// Marks when a new transfer has started\n  std::atomic<bool> hasNewTransferStarted_{false};\n\n  /// Backlog used by the sockets\n  int backlog_;\n\n  AcceptMode acceptMode_{ACCEPT_WITH_RETRIES};\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "ReceiverThread.cpp",
          "type": "blob",
          "size": 37.6083984375,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <folly/Conv.h>\n#include <folly/Memory.h>\n#include <folly/ScopeGuard.h>\n#include <folly/String.h>\n#include <folly/hash/Checksum.h>\n#include <folly/lang/Bits.h>\n#include <wdt/ReceiverThread.h>\n#include <wdt/util/FileWriter.h>\n\nnamespace facebook {\nnamespace wdt {\n\nconst static int kTimeoutBufferMillis = 1000;\nconst static int kWaitTimeoutFactor = 5;\n\nstd::ostream &operator<<(std::ostream &os,\n                         const ReceiverThread &receiverThread) {\n  os << \"Thread[\" << receiverThread.threadIndex_\n     << \", port: \" << receiverThread.socket_->getPort() << \"] \";\n  return os;\n}\n\nint64_t readAtLeast(IServerSocket &s, char *buf, int64_t max, int64_t atLeast,\n                    int64_t len) {\n  WVLOG(4) << \"readAtLeast len \" << len << \" max \" << max << \" atLeast \"\n           << atLeast << \" from \" << s.getFd();\n  WDT_CHECK_GE(len, 0);\n  WDT_CHECK_GT(atLeast, 0);\n  WDT_CHECK_LE(atLeast, max);\n  int count = 0;\n  while (len < atLeast) {\n    // because we want to process data as soon as it arrives, tryFull option for\n    // read is false\n    int64_t n = s.read(buf + len, max - len, false);\n    if (n < 0) {\n      WPLOG(ERROR) << \"Read error on \" << s.getPort() << \" after \" << count;\n      if (len) {\n        return len;\n      } else {\n        return n;\n      }\n    }\n    if (n == 0) {\n      WVLOG(2) << \"Eof on \" << s.getPort() << \" after \" << count << \" reads \"\n               << \"got \" << len;\n      return len;\n    }\n    len += n;\n    count++;\n  }\n  WVLOG(3) << \"Took \" << count << \" reads to get \" << len\n           << \" from fd : \" << s.getFd();\n  return len;\n}\n\nint64_t readAtMost(IServerSocket &s, char *buf, int64_t max, int64_t atMost) {\n  const int64_t target = atMost < max ? atMost : max;\n  WVLOG(3) << \"readAtMost target \" << target;\n  // because we want to process data as soon as it arrives, tryFull option for\n  // read is false\n  int64_t n = s.read(buf, target, false);\n  if (n < 0) {\n    WPLOG(ERROR) << \"Read error on \" << s.getPort() << \" target \" << target;\n    return n;\n  }\n  if (n == 0) {\n    WLOG(WARNING) << \"Eof on \" << s.getFd();\n    return n;\n  }\n  WVLOG(3) << \"readAtMost \" << n << \" / \" << atMost << \" from \" << s.getFd();\n  return n;\n}\n\nconst ReceiverThread::StateFunction ReceiverThread::stateMap_[] = {\n    &ReceiverThread::listen,\n    &ReceiverThread::acceptFirstConnection,\n    &ReceiverThread::acceptWithTimeout,\n    &ReceiverThread::sendLocalCheckpoint,\n    &ReceiverThread::readNextCmd,\n    &ReceiverThread::processFileCmd,\n    &ReceiverThread::processSettingsCmd,\n    &ReceiverThread::processDoneCmd,\n    &ReceiverThread::processSizeCmd,\n    &ReceiverThread::sendFileChunks,\n    &ReceiverThread::sendGlobalCheckpoint,\n    &ReceiverThread::sendDoneCmd,\n    &ReceiverThread::sendAbortCmd,\n    &ReceiverThread::waitForFinishOrNewCheckpoint,\n    &ReceiverThread::finishWithError};\n\nReceiverThread::ReceiverThread(Receiver *wdtParent, int threadIndex,\n                               int32_t port, ThreadsController *controller)\n    : WdtThread(wdtParent->options_, threadIndex, port,\n                wdtParent->getProtocolVersion(), controller),\n      wdtParent_(wdtParent) {\n  controller_->registerThread(threadIndex_);\n  threadCtx_->setAbortChecker(&wdtParent_->abortCheckerCallback_);\n}\n\n/**LISTEN STATE***/\nReceiverState ReceiverThread::listen() {\n  WTVLOG(1) << \"entered LISTEN state\";\n  const bool doActualWrites = !options_.skip_writes;\n  int32_t port = socket_->getPort();\n  WVLOG(1) << \"Server Thread for port \" << port << \" with backlog \"\n           << socket_->getBackLog() << \" on \" << wdtParent_->getDirectory()\n           << \" writes = \" << doActualWrites;\n\n  for (int retry = 1; retry < options_.max_retries; ++retry) {\n    ErrorCode code = socket_->listen();\n    if (code == OK) {\n      break;\n    } else if (code == CONN_ERROR) {\n      threadStats_.setLocalErrorCode(code);\n      return FINISH_WITH_ERROR;\n    }\n    WTLOG(INFO) << \"Sleeping after failed attempt \" << retry;\n    /* sleep override */\n    usleep(options_.sleep_millis * 1000);\n  }\n  // one more/last try (stays true if it worked above)\n  if (socket_->listen() != OK) {\n    WTLOG(ERROR) << \"Unable to listen/bind despite retries\";\n    threadStats_.setLocalErrorCode(CONN_ERROR);\n    return FINISH_WITH_ERROR;\n  }\n  return ACCEPT_FIRST_CONNECTION;\n}\n\n/***ACCEPT_FIRST_CONNECTION***/\nReceiverState ReceiverThread::acceptFirstConnection() {\n  WTVLOG(1) << \"entered ACCEPT_FIRST_CONNECTION state\";\n\n  reset();\n  socket_->closeNoCheck();\n  auto timeout = options_.accept_timeout_millis;\n  int acceptAttempts = 0;\n  while (true) {\n    // Move to timeout state if some other thread was successful\n    // in getting a connection\n    if (wdtParent_->hasNewTransferStarted()) {\n      return ACCEPT_WITH_TIMEOUT;\n    }\n    switch (wdtParent_->getAcceptMode()) {\n      case Receiver::AcceptMode::ACCEPT_WITH_RETRIES: {\n        if (acceptAttempts >= options_.max_accept_retries) {\n          WTLOG(ERROR) << \"Unable to accept after \" << acceptAttempts\n                       << \" attempts\";\n          threadStats_.setLocalErrorCode(CONN_ERROR);\n          return FINISH_WITH_ERROR;\n        }\n        break;\n      }\n      case Receiver::AcceptMode::ACCEPT_FOREVER: {\n        WTVLOG(2) << \"Receiver is configured to accept for-ever\";\n        break;\n      }\n      case Receiver::AcceptMode::STOP_ACCEPTING: {\n        WTLOG(ERROR) << \"Receiver is asked to stop accepting, attempts : \"\n                     << acceptAttempts;\n        threadStats_.setLocalErrorCode(CONN_ERROR);\n        return FINISH_WITH_ERROR;\n      }\n    }\n    if (wdtParent_->getCurAbortCode() != OK) {\n      WTLOG(ERROR) << \"Thread marked to abort while trying to accept \"\n                   << \"first connection. Num attempts \" << acceptAttempts;\n      threadStats_.setLocalErrorCode(ABORT);\n      return FINISH_WITH_ERROR;\n    }\n    ErrorCode code =\n        socket_->acceptNextConnection(timeout, curConnectionVerified_);\n    if (code == OK) {\n      break;\n    }\n    ++acceptAttempts;\n  }\n  // Make the parent start new global session. This is executed\n  // only by the first thread that calls this function\n  controller_->executeAtStart(\n      [&]() { wdtParent_->startNewGlobalSession(socket_->getPeerIp()); });\n  return READ_NEXT_CMD;\n}\n\n/***ACCEPT_WITH_TIMEOUT STATE***/\nReceiverState ReceiverThread::acceptWithTimeout() {\n  WTLOG(INFO) << \"entered ACCEPT_WITH_TIMEOUT state\";\n\n  // check socket status\n  ErrorCode socketErrCode = socket_->getNonRetryableErrCode();\n  if (socketErrCode != OK) {\n    WTLOG(ERROR) << \"Socket has non-retryable error \"\n                 << errorCodeToStr(socketErrCode);\n    threadStats_.setLocalErrorCode(socketErrCode);\n    return END;\n  }\n  socket_->closeNoCheck();\n  blocksWaitingVerification_.clear();\n\n  auto timeout = options_.accept_window_millis;\n  if (senderReadTimeout_ > 0) {\n    // transfer is in progress and we have already got sender settings\n    timeout = std::max(senderReadTimeout_, senderWriteTimeout_) +\n              kTimeoutBufferMillis;\n  }\n  ErrorCode code =\n      socket_->acceptNextConnection(timeout, curConnectionVerified_);\n  curConnectionVerified_ = false;\n  if (code != OK) {\n    WTLOG(ERROR) << \"accept() failed with error \" << errorCodeToStr(code)\n                 << \" timeout \" << timeout;\n    threadStats_.setLocalErrorCode(code);\n    return FINISH_WITH_ERROR;\n  }\n\n  numRead_ = off_ = 0;\n  pendingCheckpointIndex_ = checkpointIndex_;\n  ReceiverState nextState = READ_NEXT_CMD;\n  if (threadStats_.getLocalErrorCode() != OK) {\n    nextState = SEND_LOCAL_CHECKPOINT;\n  }\n  // reset thread status\n  threadStats_.setLocalErrorCode(OK);\n  return nextState;\n}\n\n/***SEND_LOCAL_CHECKPOINT STATE***/\nReceiverState ReceiverThread::sendLocalCheckpoint() {\n  WTLOG(INFO) << \"entered SEND_LOCAL_CHECKPOINT state \" << checkpoint_;\n  std::vector<Checkpoint> checkpoints;\n  checkpoints.emplace_back(checkpoint_);\n\n  int64_t off = 0;\n  const int checkpointLen =\n      Protocol::getMaxLocalCheckpointLength(threadProtocolVersion_);\n  Protocol::encodeCheckpoints(threadProtocolVersion_, buf_, off, checkpointLen,\n                              checkpoints);\n  int written = socket_->write(buf_, checkpointLen);\n  if (written != checkpointLen) {\n    WTLOG(ERROR) << \"unable to write local checkpoint. write mismatch \"\n                 << checkpointLen << \" \" << written;\n    threadStats_.setLocalErrorCode(SOCKET_WRITE_ERROR);\n    return ACCEPT_WITH_TIMEOUT;\n  }\n  threadStats_.addHeaderBytes(checkpointLen);\n  return READ_NEXT_CMD;\n}\n\n/***READ_NEXT_CMD***/\nReceiverState ReceiverThread::readNextCmd() {\n  WTVLOG(1) << \"entered READ_NEXT_CMD state\";\n  oldOffset_ = off_;\n  // TODO: we shouldn't have off_ here and buffer/size inside buffer.\n  numRead_ = readAtLeast(*socket_, buf_ + off_, bufSize_ - off_,\n                         Protocol::kMinBufLength, numRead_);\n  if (numRead_ < Protocol::kMinBufLength) {\n    WTLOG(ERROR) << \"socket read failure \" << Protocol::kMinBufLength << \" \"\n                 << numRead_;\n    threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n    return ACCEPT_WITH_TIMEOUT;\n  }\n  Protocol::CMD_MAGIC cmd = (Protocol::CMD_MAGIC)buf_[off_++];\n  if (cmd == Protocol::DONE_CMD) {\n    return PROCESS_DONE_CMD;\n  }\n  if (cmd == Protocol::FILE_CMD) {\n    return PROCESS_FILE_CMD;\n  }\n  if (cmd == Protocol::SETTINGS_CMD) {\n    return PROCESS_SETTINGS_CMD;\n  }\n  if (cmd == Protocol::SIZE_CMD) {\n    return PROCESS_SIZE_CMD;\n  }\n  WTLOG(ERROR) << \"received an unknown cmd \" << cmd;\n  threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n  return FINISH_WITH_ERROR;\n}\n\n/***PROCESS_SETTINGS_CMD***/\nReceiverState ReceiverThread::processSettingsCmd() {\n  WTVLOG(1) << \"entered PROCESS_SETTINGS_CMD state\";\n  Settings settings;\n  int senderProtocolVersion;\n\n  bool success = Protocol::decodeVersion(\n      buf_, off_, oldOffset_ + Protocol::kMaxVersion, senderProtocolVersion);\n  if (!success) {\n    WTLOG(ERROR) << \"Unable to decode version \" << threadIndex_;\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return FINISH_WITH_ERROR;\n  }\n  if (senderProtocolVersion != threadProtocolVersion_) {\n    WTLOG(WARNING) << \"Receiver and sender protocol version mismatch \"\n                   << senderProtocolVersion << \" \" << threadProtocolVersion_;\n    int negotiatedProtocol = Protocol::negotiateProtocol(\n        senderProtocolVersion, threadProtocolVersion_);\n    if (negotiatedProtocol == 0) {\n      WTLOG(WARNING) << \"Can not support sender with version \"\n                     << senderProtocolVersion << \", aborting!\";\n      threadStats_.setLocalErrorCode(VERSION_INCOMPATIBLE);\n      return SEND_ABORT_CMD;\n    } else {\n      WLOG_IF(INFO, threadProtocolVersion_ != negotiatedProtocol)\n          << *this << \"Changing receiver protocol version to \"\n          << negotiatedProtocol;\n      threadProtocolVersion_ = negotiatedProtocol;\n      if (negotiatedProtocol != senderProtocolVersion) {\n        threadStats_.setLocalErrorCode(VERSION_MISMATCH);\n        return SEND_ABORT_CMD;\n      }\n    }\n  }\n\n  if (threadProtocolVersion_ <\n      Protocol::PERIODIC_ENCRYPTION_IV_CHANGE_VERSION) {\n    socket_->disableIvChange();\n  }\n\n  success = Protocol::decodeSettings(\n      threadProtocolVersion_, buf_, off_,\n      oldOffset_ + Protocol::kMaxVersion + Protocol::kMaxSettings, settings);\n  if (!success) {\n    WTLOG(ERROR) << \"Unable to decode settings cmd \";\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return FINISH_WITH_ERROR;\n  }\n  auto senderId = settings.transferId;\n  auto transferId = wdtParent_->getTransferId();\n  if (transferId != senderId) {\n    WTLOG(ERROR) << \"Receiver and sender id mismatch \" << senderId << \" \"\n                 << transferId;\n    threadStats_.setLocalErrorCode(ID_MISMATCH);\n    return SEND_ABORT_CMD;\n  }\n  senderReadTimeout_ = settings.readTimeoutMillis;\n  senderWriteTimeout_ = settings.writeTimeoutMillis;\n  isBlockMode_ = !settings.blockModeDisabled;\n  enableHeartBeat_ = settings.enableHeartBeat;\n  if (!enableHeartBeat_) {\n    WTLOG(INFO) << \"Disabling heart-beat as sender does not support it\";\n  }\n  curConnectionVerified_ = true;\n\n  // determine footer type\n  if (settings.enableChecksum) {\n    footerType_ = CHECKSUM_FOOTER;\n  } else {\n    footerType_ = NO_FOOTER;\n  }\n\n  if (settings.sendFileChunks) {\n    // We only move to SEND_FILE_CHUNKS state, if download resumption is enabled\n    // in the sender side\n    numRead_ = off_ = 0;\n    return SEND_FILE_CHUNKS;\n  }\n  auto msgLen = off_ - oldOffset_;\n  numRead_ -= msgLen;\n  return READ_NEXT_CMD;\n}\n\nvoid ReceiverThread::sendHeartBeat() {\n  if (!enableHeartBeat_) {\n    return;\n  }\n  const auto now = Clock::now();\n  const int timeSinceLastHeartBeatMs = durationMillis(now - lastHeartBeatTime_);\n  const int heartBeatIntervalMs = (senderReadTimeout_ / kWaitTimeoutFactor);\n  if (timeSinceLastHeartBeatMs <= heartBeatIntervalMs) {\n    return;\n  }\n  lastHeartBeatTime_ = now;\n  // time to send a heart beat\n  char buf = Protocol::HEART_BEAT_CMD;\n  const int written = socket_->write(&buf, 1);\n  if (written != 1) {\n    WTLOG(WARNING) << \"Failed to send heart-beat \" << written;\n  }\n}\n\n/***PROCESS_FILE_CMD***/\nReceiverState ReceiverThread::processFileCmd() {\n  WTVLOG(1) << \"entered PROCESS_FILE_CMD state\";\n  // following block needs to be executed for the first file cmd. There is no\n  // harm in executing it more than once. number of blocks equal to 0 is a good\n  // approximation for first file cmd. Did not want to introduce another boolean\n  if (options_.enable_download_resumption && threadStats_.getNumBlocks() == 0) {\n    auto sendChunksFunnel = controller_->getFunnel(SEND_FILE_CHUNKS_FUNNEL);\n    auto state = sendChunksFunnel->getStatus();\n    if (state == FUNNEL_START) {\n      // sender is not in resumption mode\n      wdtParent_->addTransferLogHeader(isBlockMode_,\n                                       /* sender not resuming */ false);\n      sendChunksFunnel->notifySuccess();\n    }\n  }\n  checkpoint_.resetLastBlockDetails();\n  BlockDetails blockDetails;\n  auto guard = folly::makeGuard([&] {\n    if (threadStats_.getLocalErrorCode() != OK) {\n      threadStats_.incrFailedAttempts();\n    }\n  });\n\n  ErrorCode transferStatus = (ErrorCode)buf_[off_++];\n  if (transferStatus != OK) {\n    // TODO: use this status information to implement fail fast mode\n    WTVLOG(1) << \"sender entered into error state \"\n              << errorCodeToStr(transferStatus);\n  }\n  int16_t headerLen = folly::loadUnaligned<int16_t>(buf_ + off_);\n  headerLen = folly::Endian::little(headerLen);\n  if (headerLen <= 0) {\n    WTLOG(ERROR) << \"Header length must be positive \" << headerLen;\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return FINISH_WITH_ERROR;\n  }\n\n  WVLOG(2) << \"Processing FILE_CMD, header len \" << headerLen;\n\n  sendHeartBeat();\n\n  if (headerLen > numRead_) {\n    int64_t end = oldOffset_ + numRead_;\n    numRead_ =\n        readAtLeast(*socket_, buf_ + end, bufSize_ - end, headerLen, numRead_);\n  }\n  if (numRead_ < headerLen) {\n    WTLOG(ERROR) << \"Unable to read full header \" << headerLen << \" \"\n                 << numRead_;\n    threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n    return ACCEPT_WITH_TIMEOUT;\n  }\n  off_ += sizeof(int16_t);\n  bool success = Protocol::decodeHeader(threadProtocolVersion_, buf_, off_,\n                                        numRead_ + oldOffset_, blockDetails);\n  int64_t headerBytes = off_ - oldOffset_;\n  // transferred header length must match decoded header length\n  if (headerLen != headerBytes) {\n    WTLOG(ERROR) << \"Decoded header length: \" << headerBytes\n                 << \", transferred header length: \" << headerBytes\n                 << \", they should be equal.\";\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return FINISH_WITH_ERROR;\n  }\n\n  threadStats_.addHeaderBytes(headerBytes);\n  threadStats_.addEffectiveBytes(headerBytes, 0);\n  if (!success) {\n    WTLOG(ERROR) << \"Error decoding at\" << \" ooff:\" << oldOffset_\n                 << \" off_: \" << off_ << \" numRead_: \" << numRead_;\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return FINISH_WITH_ERROR;\n  }\n  if (blockDetails.allocationStatus == TO_BE_DELETED &&\n      (blockDetails.fileSize != 0 || blockDetails.dataSize != 0)) {\n    WTLOG(ERROR) << \"Invalid file header, file to be deleted, but \"\n                    \"file-size/block-size not zero \"\n                 << blockDetails.fileName << \" file-size \"\n                 << blockDetails.fileSize << \" block-size \"\n                 << blockDetails.dataSize;\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return FINISH_WITH_ERROR;\n  }\n\n  // received a well formed file cmd, apply the pending checkpoint update\n  checkpointIndex_ = pendingCheckpointIndex_;\n  WTVLOG(1) << \"Read id:\" << blockDetails.fileName\n            << \" size:\" << blockDetails.dataSize << \" ooff:\" << oldOffset_\n            << \" off_: \" << off_ << \" numRead_: \" << numRead_;\n  auto &fileCreator = wdtParent_->getFileCreator();\n  FileWriter writer(*threadCtx_, &blockDetails, fileCreator.get());\n  const auto encryptionType = socket_->getEncryptionType();\n  auto writtenGuard = folly::makeGuard([&] {\n    if (!encryptionTypeToTagLen(encryptionType) && footerType_ == NO_FOOTER) {\n      // if encryption doesn't have tag verification and checksum verification\n      // is disabled, we can consider bytes received before connection break as\n      // valid\n      checkpoint_.setLastBlockDetails(blockDetails.seqId, blockDetails.offset,\n                                      writer.getTotalWritten());\n      threadStats_.addEffectiveBytes(headerBytes, writer.getTotalWritten());\n    }\n  });\n\n  sendHeartBeat();\n\n  // writer.open() deletes files if status == TO_BE_DELETED\n  // therefore if !(!delete_extra_files && status == TO_BE_DELETED)\n  // we should skip writer.open() call altogether\n  if (options_.delete_extra_files ||\n      blockDetails.allocationStatus != TO_BE_DELETED) {\n    if (writer.open() != OK) {\n      threadStats_.setLocalErrorCode(FILE_WRITE_ERROR);\n      return SEND_ABORT_CMD;\n    }\n  }\n\n  int32_t checksum = 0;\n  int64_t remainingData = numRead_ + oldOffset_ - off_;\n  int64_t toWrite = remainingData;\n  WDT_CHECK(remainingData >= 0);\n  if (remainingData >= blockDetails.dataSize) {\n    toWrite = blockDetails.dataSize;\n  }\n  threadStats_.addDataBytes(toWrite);\n  if (footerType_ == CHECKSUM_FOOTER) {\n    checksum = folly::crc32c((const uint8_t *)(buf_ + off_), toWrite, checksum);\n  }\n  auto throttler = wdtParent_->getThrottler();\n  if (throttler) {\n    // We might be reading more than we require for this file but\n    // throttling should make sense for any additional bytes received\n    // on the network\n    throttler->limit(*threadCtx_, toWrite + headerBytes);\n  }\n\n  sendHeartBeat();\n\n  ErrorCode code = ERROR;\n  if (toWrite > 0) {\n    code = writer.write(buf_ + off_, toWrite);\n    if (code != OK) {\n      threadStats_.setLocalErrorCode(code);\n      return SEND_ABORT_CMD;\n    }\n  }\n  off_ += toWrite;\n  remainingData -= toWrite;\n  // also means no leftOver so it's ok we use buf_ from start\n  while (writer.getTotalWritten() < blockDetails.dataSize) {\n    if (wdtParent_->getCurAbortCode() != OK) {\n      WTLOG(ERROR) << \"Thread marked for abort while processing \"\n                   << blockDetails.fileName << \" \" << blockDetails.seqId\n                   << \" port : \" << socket_->getPort();\n      threadStats_.setLocalErrorCode(ABORT);\n      return FINISH_WITH_ERROR;\n    }\n\n    sendHeartBeat();\n\n    int64_t nres = readAtMost(*socket_, buf_, bufSize_,\n                              blockDetails.dataSize - writer.getTotalWritten());\n    if (nres <= 0) {\n      break;\n    }\n    if (throttler) {\n      // We only know how much we have read after we are done calling\n      // readAtMost. Call throttler with the bytes read off_ the wire.\n      throttler->limit(*threadCtx_, nres);\n    }\n    threadStats_.addDataBytes(nres);\n    if (footerType_ == CHECKSUM_FOOTER) {\n      checksum = folly::crc32c((const uint8_t *)buf_, nres, checksum);\n    }\n\n    sendHeartBeat();\n\n    code = writer.write(buf_, nres);\n    if (code != OK) {\n      WTLOG(ERROR) << \"failed to write to \" << blockDetails.fileName;\n      threadStats_.setLocalErrorCode(code);\n      return SEND_ABORT_CMD;\n    }\n  }\n\n  // Sync the writer to disk and close it. We need to check for error code each\n  // time, otherwise we would move forward with corrupted files.\n  const ErrorCode syncCode = writer.sync();\n  if (syncCode != OK) {\n    WTLOG(ERROR) << \"could not sync \" << blockDetails.fileName << \" to disk\";\n    threadStats_.setLocalErrorCode(syncCode);\n    return SEND_ABORT_CMD;\n  }\n  const ErrorCode closeCode = writer.close();\n  if (closeCode != OK) {\n    WTLOG(ERROR) << \"could not close \" << blockDetails.fileName;\n    threadStats_.setLocalErrorCode(closeCode);\n    return SEND_ABORT_CMD;\n  }\n\n  if (writer.getTotalWritten() != blockDetails.dataSize) {\n    // This can only happen if there are transmission errors\n    // Write errors to disk are already taken care of above\n    WTLOG(ERROR) << \"could not read entire content for \"\n                 << blockDetails.fileName << \" port \" << socket_->getPort();\n    threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n    return ACCEPT_WITH_TIMEOUT;\n  }\n  writtenGuard.dismiss();\n  WVLOG(2) << \"completed \" << blockDetails.fileName << \" off: \" << off_\n           << \" numRead: \" << numRead_;\n  // Transfer of the file is complete here, mark the bytes effective\n  WDT_CHECK(remainingData >= 0) << \"Negative remainingData \" << remainingData;\n  if (remainingData > 0) {\n    // if we need to read more anyway, let's move the data\n    numRead_ = remainingData;\n    if ((remainingData < Protocol::kMaxHeader) && (off_ > (bufSize_ / 2))) {\n      // rare so inefficient is ok\n      WVLOG(3) << \"copying extra \" << remainingData << \" leftover bytes @ \"\n               << off_;\n      memmove(/* dst      */ buf_,\n              /* from     */ buf_ + off_,\n              /* how much */ remainingData);\n      off_ = 0;\n    } else {\n      // otherwise just continue from the offset\n      WVLOG(3) << \"Using remaining extra \" << remainingData\n               << \" leftover bytes starting @ \" << off_;\n    }\n  } else {\n    numRead_ = off_ = 0;\n  }\n  if (footerType_ == CHECKSUM_FOOTER) {\n    sendHeartBeat();\n    // have to read footer cmd\n    oldOffset_ = off_;\n    numRead_ = readAtLeast(*socket_, buf_ + off_, bufSize_ - off_,\n                           Protocol::kMinBufLength, numRead_);\n    if (numRead_ < Protocol::kMinBufLength) {\n      WTLOG(ERROR) << \"socket read failure \" << Protocol::kMinBufLength << \" \"\n                   << numRead_;\n      threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n      return ACCEPT_WITH_TIMEOUT;\n    }\n    Protocol::CMD_MAGIC cmd = (Protocol::CMD_MAGIC)buf_[off_++];\n    if (cmd != Protocol::FOOTER_CMD) {\n      WTLOG(ERROR) << \"Expecting footer cmd, but received \" << cmd;\n      threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n      return FINISH_WITH_ERROR;\n    }\n    int32_t receivedChecksum;\n    bool ok = Protocol::decodeFooter(\n        buf_, off_, oldOffset_ + Protocol::kMaxFooter, receivedChecksum);\n    if (!ok) {\n      WTLOG(ERROR) << \"Unable to decode footer cmd\";\n      threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n      return FINISH_WITH_ERROR;\n    }\n    if (checksum != receivedChecksum) {\n      WTLOG(ERROR) << \"Checksum mismatch \" << checksum << \" \"\n                   << receivedChecksum << \" port \" << socket_->getPort()\n                   << \" file \" << blockDetails.fileName;\n      threadStats_.setLocalErrorCode(CHECKSUM_MISMATCH);\n      return ACCEPT_WITH_TIMEOUT;\n    }\n    markBlockVerified(blockDetails);\n    int64_t msgLen = off_ - oldOffset_;\n    numRead_ -= msgLen;\n  } else {\n    WDT_CHECK(footerType_ == NO_FOOTER);\n    if (encryptionTypeToTagLen(encryptionType)) {\n      blocksWaitingVerification_.emplace_back(blockDetails);\n    } else {\n      markBlockVerified(blockDetails);\n    }\n  }\n  return READ_NEXT_CMD;\n}\n\nvoid ReceiverThread::markBlockVerified(const BlockDetails &blockDetails) {\n  threadStats_.addEffectiveBytes(0, blockDetails.dataSize);\n  threadStats_.incrNumBlocks();\n  checkpoint_.incrNumBlocks();\n  if (!options_.isLogBasedResumption()) {\n    return;\n  }\n  TransferLogManager &transferLogManager = wdtParent_->getTransferLogManager();\n  if (blockDetails.allocationStatus == TO_BE_DELETED) {\n    transferLogManager.addFileInvalidationEntry(blockDetails.seqId);\n    return;\n  }\n  transferLogManager.addBlockWriteEntry(blockDetails.seqId, blockDetails.offset,\n                                        blockDetails.dataSize);\n}\n\nvoid ReceiverThread::markReceivedBlocksVerified() {\n  for (const BlockDetails &blockDetails : blocksWaitingVerification_) {\n    markBlockVerified(blockDetails);\n  }\n  blocksWaitingVerification_.clear();\n}\n\nReceiverState ReceiverThread::processDoneCmd() {\n  WTVLOG(1) << \"entered PROCESS_DONE_CMD state\";\n  if (numRead_ != Protocol::kMinBufLength) {\n    WTLOG(ERROR) << \"Unexpected state for done command\" << \" off_: \" << off_\n                 << \" numRead_: \" << numRead_;\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return FINISH_WITH_ERROR;\n  }\n\n  ErrorCode senderStatus = (ErrorCode)buf_[off_++];\n  int64_t numBlocksSend = -1;\n  int64_t totalSenderBytes = -1;\n  bool success = Protocol::decodeDone(threadProtocolVersion_, buf_, off_,\n                                      oldOffset_ + Protocol::kMaxDone,\n                                      numBlocksSend, totalSenderBytes);\n  if (!success) {\n    WTLOG(ERROR) << \"Unable to decode done cmd\";\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return FINISH_WITH_ERROR;\n  }\n  threadStats_.setNumBlocksSend(numBlocksSend);\n  threadStats_.setTotalSenderBytes(totalSenderBytes);\n  threadStats_.setRemoteErrorCode(senderStatus);\n\n  // received a valid command, applying pending checkpoint write update\n  checkpointIndex_ = pendingCheckpointIndex_;\n  return WAIT_FOR_FINISH_OR_NEW_CHECKPOINT;\n}\n\nReceiverState ReceiverThread::processSizeCmd() {\n  WTVLOG(1) << \"entered PROCESS_SIZE_CMD state\";\n  int64_t totalSenderBytes;\n  bool success = Protocol::decodeSize(\n      buf_, off_, oldOffset_ + Protocol::kMaxSize, totalSenderBytes);\n  if (!success) {\n    WTLOG(ERROR) << \"Unable to decode size cmd\";\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return FINISH_WITH_ERROR;\n  }\n  WVLOG(1) << \"Number of bytes to receive \" << totalSenderBytes;\n  threadStats_.setTotalSenderBytes(totalSenderBytes);\n  auto msgLen = off_ - oldOffset_;\n  numRead_ -= msgLen;\n  return READ_NEXT_CMD;\n}\n\nReceiverState ReceiverThread::sendFileChunks() {\n  WTLOG(INFO) << \"entered SEND_FILE_CHUNKS state\";\n  WDT_CHECK(senderReadTimeout_ > 0);  // must have received settings\n  int waitingTimeMillis = senderReadTimeout_ / kWaitTimeoutFactor;\n  auto execFunnel = controller_->getFunnel(SEND_FILE_CHUNKS_FUNNEL);\n  while (true) {\n    auto status = execFunnel->getStatus();\n    switch (status) {\n      case FUNNEL_END: {\n        buf_[0] = Protocol::ACK_CMD;\n        int toWrite = 1;\n        int written = socket_->write(buf_, toWrite);\n        if (written != toWrite) {\n          WTLOG(ERROR) << \"socket write error \" << toWrite << \" \" << written;\n          threadStats_.setLocalErrorCode(SOCKET_WRITE_ERROR);\n          return ACCEPT_WITH_TIMEOUT;\n        }\n        threadStats_.addHeaderBytes(toWrite);\n        return READ_NEXT_CMD;\n      }\n      case FUNNEL_PROGRESS: {\n        buf_[0] = Protocol::WAIT_CMD;\n        int toWrite = 1;\n        int written = socket_->write(buf_, toWrite);\n        if (written != toWrite) {\n          WTLOG(ERROR) << \"socket write error \" << toWrite << \" \" << written;\n          threadStats_.setLocalErrorCode(SOCKET_WRITE_ERROR);\n          return ACCEPT_WITH_TIMEOUT;\n        }\n        threadStats_.addHeaderBytes(toWrite);\n        execFunnel->wait(waitingTimeMillis, *threadCtx_);\n        break;\n      }\n      case FUNNEL_START: {\n        int64_t off = 0;\n        buf_[off++] = Protocol::CHUNKS_CMD;\n        const auto &fileChunksInfo = wdtParent_->getFileChunksInfo();\n        const int64_t numParsedChunksInfo = fileChunksInfo.size();\n        Protocol::encodeChunksCmd(buf_, off, /* size of buf_ */ bufSize_,\n                                  /* param to send */ bufSize_,\n                                  numParsedChunksInfo);\n        int written = socket_->write(buf_, off);\n        if (written > 0) {\n          threadStats_.addHeaderBytes(written);\n        }\n        if (written != off) {\n          WTLOG(ERROR) << \"socket write err \" << off << \" \" << written;\n          threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n          execFunnel->notifyFail();\n          return ACCEPT_WITH_TIMEOUT;\n        }\n        int64_t numEntriesWritten = 0;\n        // we try to encode as many chunks as possible in the buffer. If a\n        // single\n        // chunk can not fit in the buffer, it is ignored. Format of encoding :\n        // <data-size><chunk1><chunk2>...\n        while (numEntriesWritten < numParsedChunksInfo) {\n          off = sizeof(int32_t);\n          int64_t numEntriesEncoded = Protocol::encodeFileChunksInfoList(\n              buf_, off, bufSize_, numEntriesWritten, fileChunksInfo);\n          int32_t dataSize = folly::Endian::little(off - sizeof(int32_t));\n          folly::storeUnaligned<int32_t>(buf_, dataSize);\n          written = socket_->write(buf_, off);\n          if (written > 0) {\n            threadStats_.addHeaderBytes(written);\n          }\n          if (written != off) {\n            break;\n          }\n          numEntriesWritten += numEntriesEncoded;\n        }\n        if (numEntriesWritten != numParsedChunksInfo) {\n          WTLOG(ERROR) << \"Could not write all the file chunks \"\n                       << numParsedChunksInfo << \" \" << numEntriesWritten;\n          threadStats_.setLocalErrorCode(SOCKET_WRITE_ERROR);\n          execFunnel->notifyFail();\n          return ACCEPT_WITH_TIMEOUT;\n        }\n        // try to read ack\n        int64_t toRead = 1;\n        int64_t numRead = socket_->read(buf_, toRead);\n        if (numRead != toRead) {\n          WTLOG(ERROR) << \"Socket read error \" << toRead << \" \" << numRead;\n          threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n          execFunnel->notifyFail();\n          return ACCEPT_WITH_TIMEOUT;\n        }\n        wdtParent_->addTransferLogHeader(isBlockMode_,\n                                         /* sender resuming */ true);\n        execFunnel->notifySuccess();\n        return READ_NEXT_CMD;\n      }\n    }\n  }\n}\n\nReceiverState ReceiverThread::sendGlobalCheckpoint() {\n  WTLOG(INFO) << \"entered SEND_GLOBAL_CHECKPOINTS state\";\n  buf_[0] = Protocol::ERR_CMD;\n  off_ = 1;\n  // leave space for length\n  off_ += sizeof(int16_t);\n  auto oldOffset = off_;\n  Protocol::encodeCheckpoints(threadProtocolVersion_, buf_, off_, bufSize_,\n                              newCheckpoints_);\n  int16_t length = off_ - oldOffset;\n  folly::storeUnaligned<int16_t>(buf_ + 1, folly::Endian::little(length));\n\n  int written = socket_->write(buf_, off_);\n  if (written != off_) {\n    WTLOG(ERROR) << \"unable to write error checkpoints\";\n    threadStats_.setLocalErrorCode(SOCKET_WRITE_ERROR);\n    return ACCEPT_WITH_TIMEOUT;\n  } else {\n    threadStats_.addHeaderBytes(off_);\n    pendingCheckpointIndex_ = checkpointIndex_ + newCheckpoints_.size();\n    numRead_ = off_ = 0;\n    return READ_NEXT_CMD;\n  }\n}\n\nReceiverState ReceiverThread::sendAbortCmd() {\n  WTLOG(INFO) << \"entered SEND_ABORT_CMD state\";\n  int64_t offset = 0;\n  buf_[offset++] = Protocol::ABORT_CMD;\n  Protocol::encodeAbort(buf_, offset, bufSize_, threadProtocolVersion_,\n                        threadStats_.getLocalErrorCode(),\n                        threadStats_.getNumFiles());\n  socket_->write(buf_, offset);\n  // No need to check if we were successful in sending ABORT\n  // This thread will simply disconnect and sender thread on the\n  // other side will timeout\n  socket_->closeConnection();\n  threadStats_.addHeaderBytes(offset);\n  if (threadStats_.getLocalErrorCode() == VERSION_MISMATCH) {\n    // Receiver should try again expecting sender to have changed its version\n    return ACCEPT_WITH_TIMEOUT;\n  }\n  return FINISH_WITH_ERROR;\n}\n\nReceiverState ReceiverThread::sendDoneCmd() {\n  WTVLOG(1) << \"entered SEND_DONE_CMD state\";\n  buf_[0] = Protocol::DONE_CMD;\n  if (socket_->write(buf_, 1) != 1) {\n    WTPLOG(ERROR) << \"unable to send DONE \" << threadIndex_;\n    threadStats_.setLocalErrorCode(SOCKET_WRITE_ERROR);\n    return ACCEPT_WITH_TIMEOUT;\n  }\n\n  threadStats_.addHeaderBytes(1);\n\n  auto read = socket_->read(buf_, 1);\n  if (read != 1 || buf_[0] != Protocol::DONE_CMD) {\n    WTLOG(ERROR) << \"did not receive ack for DONE\";\n    threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n    return ACCEPT_WITH_TIMEOUT;\n  }\n  ErrorCode code = socket_->expectEndOfStream();\n  if (code != OK) {\n    WTLOG(ERROR) << \"error while processing logical end of stream \"\n                 << errorCodeToStr(code);\n    threadStats_.setLocalErrorCode(code);\n    return ACCEPT_WITH_TIMEOUT;\n  }\n  markReceivedBlocksVerified();\n  threadStats_.setLocalErrorCode(socket_->closeConnection());\n  WTLOG(INFO) << \"got ack for DONE and logical eof. Transfer finished\";\n  return END;\n}\n\nReceiverState ReceiverThread::finishWithError() {\n  WTLOG(INFO) << \"entered FINISH_WITH_ERROR state\";\n  // should only be in this state if there is some error\n  WDT_CHECK(threadStats_.getLocalErrorCode() != OK);\n\n  // close the socket, so that sender receives an error during connect\n  // When we are doing a single session, close the listening socket as soon\n  // as we are done\n  if (wdtParent_->isJoinable_) {\n    socket_->closeAllNoCheck();\n  } else {\n    socket_->closeNoCheck();\n  }\n  auto cv = controller_->getCondition(WAIT_FOR_FINISH_OR_CHECKPOINT_CV);\n  auto guard = cv->acquire();\n  wdtParent_->addCheckpoint(checkpoint_);\n  controller_->markState(threadIndex_, FINISHED);\n  guard.notifyOne();\n  return END;\n}\n\nReceiverState ReceiverThread::checkForFinishOrNewCheckpoints() {\n  auto checkpoints = wdtParent_->getNewCheckpoints(checkpointIndex_);\n  if (!checkpoints.empty()) {\n    newCheckpoints_ = std::move(checkpoints);\n    controller_->markState(threadIndex_, RUNNING);\n    return SEND_GLOBAL_CHECKPOINTS;\n  }\n  bool existActiveThreads = controller_->hasThreads(threadIndex_, RUNNING);\n  if (!existActiveThreads) {\n    controller_->markState(threadIndex_, FINISHED);\n    return SEND_DONE_CMD;\n  }\n  return WAIT_FOR_FINISH_OR_NEW_CHECKPOINT;\n}\n\nReceiverState ReceiverThread::waitForFinishOrNewCheckpoint() {\n  WTLOG(INFO) << \"entered WAIT_FOR_FINISH_OR_NEW_CHECKPOINT state\";\n  // should only be called if the are no errors\n  WDT_CHECK(threadStats_.getLocalErrorCode() == OK);\n  auto cv = controller_->getCondition(WAIT_FOR_FINISH_OR_CHECKPOINT_CV);\n  int timeoutMillis = senderReadTimeout_ / kWaitTimeoutFactor;\n  controller_->markState(threadIndex_, WAITING);\n  while (true) {\n    WDT_CHECK(senderReadTimeout_ > 0);  // must have received settings\n    {\n      auto guard = cv->acquire();\n      auto state = checkForFinishOrNewCheckpoints();\n      if (state != WAIT_FOR_FINISH_OR_NEW_CHECKPOINT) {\n        guard.notifyOne();\n        return state;\n      }\n      {\n        PerfStatCollector statCollector(*threadCtx_,\n                                        PerfStatReport::RECEIVER_WAIT_SLEEP);\n        guard.wait(timeoutMillis, *threadCtx_);\n      }\n      state = checkForFinishOrNewCheckpoints();\n      if (state != WAIT_FOR_FINISH_OR_NEW_CHECKPOINT) {\n        guard.notifyOne();\n        return state;\n      }\n    }\n    // send WAIT cmd to keep sender thread alive\n    buf_[0] = Protocol::WAIT_CMD;\n    if (socket_->write(buf_, 1) != 1) {\n      WTPLOG(ERROR) << \"unable to write WAIT\";\n      threadStats_.setLocalErrorCode(SOCKET_WRITE_ERROR);\n      controller_->markState(threadIndex_, RUNNING);\n      return ACCEPT_WITH_TIMEOUT;\n    }\n    threadStats_.addHeaderBytes(1);\n  }\n}\n\nvoid ReceiverThread::start() {\n  if (buf_ == nullptr) {\n    WTLOG(ERROR) << \"Unable to allocate buffer\";\n    threadStats_.setLocalErrorCode(MEMORY_ALLOCATION_ERROR);\n    return;\n  }\n  ReceiverState state = LISTEN;\n  while (true) {\n    ErrorCode abortCode = wdtParent_->getCurAbortCode();\n    if (abortCode != OK) {\n      WTLOG(ERROR) << \"Transfer aborted \" << socket_->getPort() << \" \"\n                   << errorCodeToStr(abortCode);\n      threadStats_.setLocalErrorCode(ABORT);\n      break;\n    }\n    if (state == END) {\n      break;\n    }\n    state = (this->*stateMap_[state])();\n  }\n  controller_->deRegisterThread(threadIndex_);\n  controller_->executeAtEnd([&]() { wdtParent_->endCurGlobalSession(); });\n  WDT_CHECK(socket_.get());\n  threadStats_.setEncryptionType(socket_->getEncryptionType());\n  WTLOG(INFO) << threadStats_;\n}\n\nint32_t ReceiverThread::getPort() const {\n  return socket_->getPort();\n}\n\nErrorCode ReceiverThread::init() {\n  const EncryptionParams &encryptionData =\n      wdtParent_->transferRequest_.encryptionData;\n  Func tagVerificationSuccessCallback = [this] {\n    this->markReceivedBlocksVerified();\n  };\n  if (wdtParent_->socketCreator_) {\n    socket_ = wdtParent_->socketCreator_->makeServerSocket(\n        *threadCtx_, port_, wdtParent_->backlog_, encryptionData,\n        wdtParent_->transferRequest_.ivChangeInterval,\n        std::move(tagVerificationSuccessCallback),\n        wdtParent_->transferRequest_.tls);\n  } else {\n    socket_ = std::make_unique<ServerSocket>(\n        *threadCtx_, port_, wdtParent_->backlog_, encryptionData,\n        wdtParent_->transferRequest_.ivChangeInterval,\n        std::move(tagVerificationSuccessCallback));\n  }\n\n  if (!socket_) {\n    return ERROR;\n  }\n\n  int max_retries = options_.max_retries;\n  for (int retries = 0; retries < max_retries; retries++) {\n    if (socket_->listen() == OK) {\n      break;\n    }\n  }\n  if (socket_->listen() != OK) {\n    WTLOG(ERROR) << \"Couldn't listen on port \" << socket_->getPort();\n    return ERROR;\n  }\n  checkpoint_.port = socket_->getPort();\n  WTLOG(INFO) << \"Listening on port \" << socket_->getPort();\n  return OK;\n}\n\nvoid ReceiverThread::reset() {\n  numRead_ = off_ = 0;\n  checkpointIndex_ = pendingCheckpointIndex_ = 0;\n  senderReadTimeout_ = senderWriteTimeout_ = -1;\n  curConnectionVerified_ = false;\n  threadStats_.reset();\n  checkpoints_.clear();\n  newCheckpoints_.clear();\n  checkpoint_ = Checkpoint(socket_->getPort());\n}\n\nReceiverThread::~ReceiverThread() {\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "ReceiverThread.h",
          "type": "blob",
          "size": 12.248046875,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n#include <wdt/Receiver.h>\n#include <wdt/WdtBase.h>\n#include <wdt/WdtThread.h>\n#include <wdt/util/ServerSocket.h>\n\nnamespace facebook {\nnamespace wdt {\n\nclass Receiver;\n/**\n * Wdt receiver has logic to maintain the consistency of the\n * transfers through connection errors. All threads are run by the logic\n * defined as a state machine. These are the all the states in that\n * state machine\n */\nenum ReceiverState {\n  LISTEN,\n  ACCEPT_FIRST_CONNECTION,\n  ACCEPT_WITH_TIMEOUT,\n  SEND_LOCAL_CHECKPOINT,\n  READ_NEXT_CMD,\n  PROCESS_FILE_CMD,\n  PROCESS_SETTINGS_CMD,\n  PROCESS_DONE_CMD,\n  PROCESS_SIZE_CMD,\n  SEND_FILE_CHUNKS,\n  SEND_GLOBAL_CHECKPOINTS,\n  SEND_DONE_CMD,\n  SEND_ABORT_CMD,\n  WAIT_FOR_FINISH_OR_NEW_CHECKPOINT,\n  FINISH_WITH_ERROR,\n  END\n};\n\n/**\n * This class represents a receiver thread. It contains\n * all the logic for a thread to bind on a port and\n * receive data from the wdt sender. All the receiver threads\n * share modules like threads controller, throttler etc\n */\nclass ReceiverThread : public WdtThread {\n public:\n  /// Identifiers for the funnels that this thread will use\n  enum RECEIVER_FUNNELS { SEND_FILE_CHUNKS_FUNNEL, NUM_FUNNELS };\n\n  /// Identifiers for the condition variable wrappers used in the thread\n  enum RECEIVER_CONDITIONS { WAIT_FOR_FINISH_OR_CHECKPOINT_CV, NUM_CONDITIONS };\n\n  /// Identifiers for the barriers used in the thread\n  enum RECEIVER_BARRIERS { NUM_BARRIERS };\n  /**\n   * Constructor for receiver thread.\n   * @param wdtParent       Pointer back to the parent receiver for meta\n   *                        information\n   * @param threadIndex     Every thread is identified by unique index\n   * @param port            Port this thread will listen on\n   * @param controller      Thread controller for all the instances of the\n   *                        receiver threads. All the receiver thread objects\n   *                        need to share the same instance of the controller\n   */\n  ReceiverThread(Receiver *wdtParent, int threadIndex, int port,\n                 ThreadsController *controller);\n\n  /// Initializes the receiver thread before starting\n  ErrorCode init() override;\n\n  /**\n   * In long running mode, we need to reset thread variables after each\n   * session. Before starting each session, reset() has to called to do that.\n   */\n  void reset() override;\n\n  /// Destructor of Receiver thread\n  ~ReceiverThread() override;\n\n  /// Get the port this receiver thread is listening on\n  int32_t getPort() const override;\n\n private:\n  /// Overloaded operator for printing thread info\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const ReceiverThread &receiverThread);\n  typedef ReceiverState (ReceiverThread::*StateFunction)();\n\n  /// Parent shared among all the threads for meta information\n  Receiver *wdtParent_;\n\n  /**\n   * Tries to listen/bind to port. If this fails, thread is considered failed.\n   * Previous states : n/a (start state)\n   * Next states : ACCEPT_FIRST_CONNECTION(success),\n   *               FINISH_WITH_ERROR(failure)\n   */\n  ReceiverState listen();\n\n  /**\n   * Tries to accept first connection of a new session. Periodically checks\n   * whether a new session has started or not. If a new session has started then\n   * goes to ACCEPT_WITH_TIMEOUT state. Also does session initialization. In\n   * joinable mode, tries to accept for a limited number of user specified\n   * retries.\n   * Previous states : LISTEN,\n   *                   END(if in long running mode)\n   * Next states : ACCEPT_WITH_TIMEOUT(if a new transfer has started and this\n   *               thread has not received a connection),\n   *               FINISH_WITH_ERROR(if did not receive a\n   *               connection in specified number of retries),\n   *               READ_NEXT_CMD(if a connection was received)\n   */\n  ReceiverState acceptFirstConnection();\n\n  /**\n   * Tries to accept a connection with timeout. There are 2 kinds of timeout. At\n   * the beginning of the session, it uses accept window as the timeout. Later\n   * when sender settings are known it uses max(readTimeOut, writeTimeout)) +\n   * buffer(500) as the timeout.\n   * Previous states : Almost all states(for any network errors during transfer,\n   *                   we transition to this state),\n   * Next states : READ_NEXT_CMD(if there are no previous errors and accept\n   *               was successful),\n   *               SEND_LOCAL_CHECKPOINT(if there were previous errors and\n   *               accept was successful),\n   *               FINISH_WITH_ERROR(if accept failed and\n   *               transfer previously failed during SEND_DONE_CMD state. Thus\n   *               case needs special handling to ensure that we do not mess up\n   *               session variables),\n   *               END(if accept fails otherwise)\n   */\n  ReceiverState acceptWithTimeout();\n  /**\n   * Sends local checkpoint to the sender. In case of previous error during\n   * SEND_LOCAL_CHECKPOINT state, we send -1 as the checkpoint.\n   * Previous states : ACCEPT_WITH_TIMEOUT\n   * Next states : ACCEPT_WITH_TIMEOUT(if sending fails),\n   *               SEND_DONE_CMD(if send is successful and we have previous\n   *               SEND_DONE_CMD error),\n   *               READ_NEXT_CMD(if send is successful otherwise)\n   */\n  ReceiverState sendLocalCheckpoint();\n  /**\n   * Reads next cmd and transitions to the state accordingly.\n   * Previous states : SEND_LOCAL_CHECKPOINT,\n   *                   ACCEPT_FIRST_CONNECTION,\n   *                   ACCEPT_WITH_TIMEOUT,\n   *                   PROCESS_SETTINGS_CMD,\n   *                   PROCESS_FILE_CMD,\n   *                   SEND_GLOBAL_CHECKPOINTS,\n   * Next states : PROCESS_FILE_CMD,\n   *               PROCESS_DONE_CMD,\n   *               PROCESS_SETTINGS_CMD,\n   *               PROCESS_SIZE_CMD,\n   *               ACCEPT_WITH_TIMEOUT(in case of read failure),\n   *               FINISH_WITH_ERROR(in case of protocol errors)\n   */\n  ReceiverState readNextCmd();\n  /**\n   * Processes file cmd. Logic of how we write the file to the destination\n   * directory is defined here.\n   * Previous states : READ_NEXT_CMD\n   * Next states : READ_NEXT_CMD(success),\n   *               FINISH_WITH_ERROR(protocol error),\n   *               ACCEPT_WITH_TIMEOUT(socket read failure)\n   */\n  ReceiverState processFileCmd();\n  /**\n   * Processes settings cmd. Settings has a connection settings,\n   * protocol version, transfer id, etc. For more info check Protocol.h\n   * Previous states : READ_NEXT_CMD,\n   * Next states : READ_NEXT_CMD(success),\n   *               FINISH_WITH_ERROR(protocol error),\n   *               ACCEPT_WITH_TIMEOUT(socket read failure),\n   *               SEND_FILE_CHUNKS(If the sender wants to resume transfer)\n   */\n  ReceiverState processSettingsCmd();\n  /**\n   * Processes done cmd. Also checks to see if there are any new global\n   * checkpoints or not\n   * Previous states : READ_NEXT_CMD,\n   * Next states : FINISH_WITH_ERROR(protocol error),\n   *               WAIT_FOR_FINISH_OR_NEW_CHECKPOINT(success),\n   *               SEND_GLOBAL_CHECKPOINTS(if there are global errors)\n   */\n  ReceiverState processDoneCmd();\n  /**\n   * Processes size cmd. Sets the value of totalSenderBytes_\n   * Previous states : READ_NEXT_CMD,\n   * Next states : READ_NEXT_CMD(success),\n   *               FINISH_WITH_ERROR(protocol error)\n   */\n  ReceiverState processSizeCmd();\n  /**\n   * Sends file chunks that were received successfully in any previous transfer,\n   * this is the first step in download resumption.\n   * Checks to see if they have already been transferred or not.\n   * If yes, send ACK. If some other thread is sending it, sends wait cmd\n   * and checks again later. Otherwise, breaks the entire data into bufferSIze_\n   * chunks and sends it.\n   * Previous states: PROCESS_SETTINGS_CMD,\n   * Next states : ACCEPT_WITH_TIMEOUT(network error),\n   *               READ_NEXT_CMD(success)\n   */\n  ReceiverState sendFileChunks();\n  /**\n   * Sends global checkpoints to sender\n   * Previous states : PROCESS_DONE_CMD,\n   *                   FINISH_WITH_ERROR\n   * Next states : READ_NEXT_CMD(success),\n   *               ACCEPT_WITH_TIMEOUT(socket write failure)\n   */\n  ReceiverState sendGlobalCheckpoint();\n  /**\n   * Sends DONE to sender, also tries to read back ack. If anything fails during\n   * this state, doneSendFailure_ thread variable is set. This flag makes the\n   * state machine behave differently, effectively bypassing all session related\n   * things.\n   * Previous states : SEND_LOCAL_CHECKPOINT,\n   *                   FINISH_WITH_ERROR\n   * Next states : END(success),\n   *               ACCEPT_WITH_TIMEOUT(failure)\n   */\n  ReceiverState sendDoneCmd();\n\n  /**\n   * Sends ABORT cmd back to the sender\n   * Previous states : PROCESS_FILE_CMD\n   * Next states : FINISH_WITH_ERROR\n   */\n  ReceiverState sendAbortCmd();\n\n  /**\n   * Internal implementation of waitForFinishOrNewCheckpoint\n   * Returns :\n   *  SEND_GLOBAL_CHECKPOINTS if there are checkpoints\n   *  SEND_DONE_CMD if there are no checkpoints and\n   *  there are no active threads\n   *  WAIT_FOR_FINISH_OR_NEW_CHECKPOINT in all other cases\n   */\n  ReceiverState checkForFinishOrNewCheckpoints();\n\n  /**\n   * Waits for transfer to finish or new checkpoints. This state first\n   * increments waitingThreadCount_. Then, it\n   * waits till all the threads have finished. It sends periodic WAIT signal to\n   * prevent sender from timing out. If a new checkpoint is found, we move to\n   * SEND_GLOBAL_CHECKPOINTS state.\n   * Previous states : PROCESS_DONE_CMD\n   * Next states : SEND_DONE_CMD(all threads finished),\n   *               SEND_GLOBAL_CHECKPOINTS(if new checkpoints are found),\n   *               ACCEPT_WITH_TIMEOUT(if socket write fails)\n   */\n  ReceiverState waitForFinishOrNewCheckpoint();\n\n  /**\n   * Waits for transfer to finish. Only called when there is an error for the\n   * thread. It adds a checkpoint to the global list of checkpoints if a\n   * connection was received. It increments waitingWithErrorThreadCount_ and\n   * waits till the session ends.\n   * Previous states : Almost all states\n   * Next states : END\n   */\n  ReceiverState finishWithError();\n\n  /// marks a block a verified\n  void markBlockVerified(const BlockDetails &blockDetails);\n\n  /// verifies received blocks which are not already verified\n  void markReceivedBlocksVerified();\n\n  /// checks whether heart-beat is enabled, and whether it is time to send\n  /// another heart-beat, and if yes, sends a heart-beat\n  void sendHeartBeat();\n\n  /// Mapping from receiver states to state functions\n  static const StateFunction stateMap_[];\n\n  /// Main entry point for the thread, starts the state machine\n  void start() override;\n\n  /**\n   * Server socket object that provides functionality such as listen()\n   * accept, read, write on the socket\n   */\n  std::unique_ptr<IServerSocket> socket_{nullptr};\n\n  /// Marks the number of bytes already read in the buffer\n  int64_t numRead_{0};\n\n  /// Following two are markers to mark how much data has been read/parsed\n  int64_t off_{0};\n  int64_t oldOffset_{0};\n\n  /// Number of checkpoints already transferred\n  int checkpointIndex_{0};\n\n  /// Checkpoints saved for this thread\n  std::vector<Checkpoint> checkpoints_;\n\n  /**\n   * Pending value of checkpoint count. since write call success does not\n   * gurantee actual transfer, we do not apply checkpoint count update after\n   * the write. Only after receiving next cmd from sender, we apply the\n   * update\n   */\n  int pendingCheckpointIndex_{0};\n\n  /// read timeout for sender\n  int64_t senderReadTimeout_{-1};\n\n  /// write timeout for sender\n  int64_t senderWriteTimeout_{-1};\n\n  /// whether the transfer is in block mode or not\n  bool isBlockMode_{true};\n\n  /// Checkpoint local to the thread, updated regularly\n  Checkpoint checkpoint_;\n\n  /// whether settings have been received and verified for the current\n  /// connection. This is used to determine round robin order for polling in\n  /// the server socket\n  bool curConnectionVerified_{false};\n\n  /// Checkpoints that have not been sent back to the sender\n  std::vector<Checkpoint> newCheckpoints_;\n\n  /// list of received blocks which have not yet been verified\n  std::vector<BlockDetails> blocksWaitingVerification_;\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "Reporting.cpp",
          "type": "blob",
          "size": 19.1650390625,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <folly/String.h>\n#include <wdt/Protocol.h>\n#include <wdt/Reporting.h>\n#include <wdt/WdtOptions.h>\n\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n#include <set>\n\nnamespace facebook {\nnamespace wdt {\n\nconst static int64_t kMaxEntriesToPrint = 10;\n\nTransferStats& TransferStats::operator+=(const TransferStats& stats) {\n  std::unique_lock writeLock(getUniqueLock());\n  std::shared_lock readLock(stats.getSharedLock());\n  headerBytes_ += stats.headerBytes_;\n  dataBytes_ += stats.dataBytes_;\n  effectiveHeaderBytes_ += stats.effectiveHeaderBytes_;\n  effectiveDataBytes_ += stats.effectiveDataBytes_;\n  numFiles_ += stats.numFiles_;\n  numBlocks_ += stats.numBlocks_;\n  failedAttempts_ += stats.failedAttempts_;\n  if (numBlocksSend_ == -1) {\n    numBlocksSend_ = stats.numBlocksSend_;\n  } else if (stats.numBlocksSend_ != -1 &&\n             numBlocksSend_ != stats.numBlocksSend_) {\n    WLOG_IF(ERROR, localErrCode_ == OK)\n        << \"Mismatch in the numBlocksSend \" << numBlocksSend_ << \" \"\n        << stats.numBlocksSend_;\n    localErrCode_ = ERROR;\n  }\n  if (totalSenderBytes_ == -1) {\n    totalSenderBytes_ = stats.totalSenderBytes_;\n  } else if (stats.totalSenderBytes_ != -1 &&\n             totalSenderBytes_ != stats.totalSenderBytes_) {\n    WLOG_IF(ERROR, localErrCode_ == OK)\n        << \"Mismatch in the total sender bytes \" << totalSenderBytes_ << \" \"\n        << stats.totalSenderBytes_;\n    localErrCode_ = ERROR;\n  }\n  localErrCode_ = getMoreInterestingError(localErrCode_, stats.localErrCode_);\n  WVLOG(2) << \"Local ErrorCode now \" << localErrCode_ << \" from \"\n           << stats.localErrCode_;\n  remoteErrCode_ =\n      getMoreInterestingError(remoteErrCode_, stats.remoteErrCode_);\n  if (stats.localErrCode_ == OK && stats.remoteErrCode_ == OK) {\n    // encryption type valid only if error code is OK\n    // TODO: verify whether all successful threads have same encryption types\n    encryptionType_ = stats.encryptionType_;\n    tls_ = stats.getTls();\n  }\n  return *this;\n}\n\nstd::ostream& operator<<(std::ostream& os, const TransferStats& stats) {\n  std::shared_lock lock(stats.getSharedLock());\n  double headerOverhead = 100;\n  double failureOverhead = 100;\n\n  if (stats.effectiveDataBytes_ > 0) {\n    headerOverhead = 100.0 * stats.headerBytes_ / stats.effectiveDataBytes_;\n    failureOverhead = 100.0 * (stats.dataBytes_ - stats.effectiveDataBytes_) /\n                      stats.effectiveDataBytes_;\n  }\n\n  if (stats.localErrCode_ == OK && stats.remoteErrCode_ == OK) {\n    os << \"Transfer status = OK.\";\n  } else if (stats.localErrCode_ == stats.remoteErrCode_) {\n    os << \"Transfer status = \" << errorCodeToStr(stats.localErrCode_) << \".\";\n  } else {\n    os << \"Transfer status (local) = \" << errorCodeToStr(stats.localErrCode_)\n       << \", (remote) = \" << errorCodeToStr(stats.remoteErrCode_) << \".\";\n  }\n\n  if (stats.numFiles_ > 0) {\n    os << \" Number of files transferred = \" << stats.numFiles_ << \".\";\n  } else {\n    os << \" Number of blocks transferred = \" << stats.numBlocks_ << \".\";\n  }\n  os << \" Data Mbytes = \" << stats.effectiveDataBytes_ / kMbToB\n     << \". Header Kbytes = \" << stats.headerBytes_ / 1024. << \" (\"\n     << headerOverhead << \"% overhead)\"\n     << \". Total bytes = \" << (stats.dataBytes_ + stats.headerBytes_)\n     << \". Wasted bytes due to failure = \"\n     << (stats.dataBytes_ - stats.effectiveDataBytes_) << \" (\"\n     << failureOverhead << \"% overhead)\"\n     << \". Encryption type = \" << encryptionTypeToStr(stats.encryptionType_)\n     << \".\";\n  return os;\n}\n\nTransferReport::TransferReport(\n    std::vector<TransferStats>& transferredSourceStats,\n    std::vector<TransferStats>& failedSourceStats,\n    std::vector<TransferStats>& threadStats,\n    std::vector<std::string>& failedDirectories, double totalTime,\n    int64_t totalFileSize, int64_t numDiscoveredFiles,\n    int64_t previouslySentBytes, bool fileDiscoveryFinished)\n    : transferredSourceStats_(std::move(transferredSourceStats)),\n      failedSourceStats_(std::move(failedSourceStats)),\n      threadStats_(std::move(threadStats)),\n      failedDirectories_(std::move(failedDirectories)),\n      totalTime_(totalTime),\n      totalFileSize_(totalFileSize),\n      numDiscoveredFiles_(numDiscoveredFiles),\n      previouslySentBytes_(previouslySentBytes),\n      fileDiscoveryFinished_(fileDiscoveryFinished) {\n  for (const auto& stats : threadStats_) {\n    summary_ += stats;\n  }\n  ErrorCode summaryErrorCode = summary_.getErrorCode();\n  bool atLeastOneOk = false;\n  for (auto& stats : threadStats_) {\n    if (stats.getErrorCode() == OK) {\n      atLeastOneOk = true;\n      break;\n    }\n  }\n  WLOG(INFO) << \"Error code summary \" << errorCodeToStr(summaryErrorCode);\n  // none of the files or directories failed\n  bool possiblyOk = true;\n  if (!failedDirectories_.empty()) {\n    possiblyOk = false;\n    summaryErrorCode =\n        getMoreInterestingError(summaryErrorCode, BYTE_SOURCE_READ_ERROR);\n  }\n  for (const auto& sourceStat : failedSourceStats_) {\n    possiblyOk = false;\n    summaryErrorCode =\n        getMoreInterestingError(summaryErrorCode, sourceStat.getErrorCode());\n  }\n  // Check that all bytes have been sent.\n  if (summary_.getEffectiveDataBytes() != totalFileSize_) {\n    // sender did not send all the bytes\n    WLOG(INFO) << \"Could not send all the bytes \" << totalFileSize_ << \" \"\n               << summary_.getEffectiveDataBytes();\n    if (summaryErrorCode == OK) {\n      WLOG(ERROR) << \"BUG: All threads OK yet sized based error detected\";\n      summaryErrorCode = ERROR;\n    }\n  } else {\n    // See if the error is recoverable.\n    if (summaryErrorCode != OK && possiblyOk && atLeastOneOk) {\n      WLOG(WARNING) << \"WDT successfully recovered from error \"\n                    << errorCodeToStr(summaryErrorCode);\n      summaryErrorCode = OK;\n    }\n  }\n  setErrorCode(summaryErrorCode);\n\n  std::set<std::string> failedFilesSet;\n  for (auto& stats : failedSourceStats_) {\n    failedFilesSet.insert(stats.getId());\n  }\n  int64_t numTransferredFiles = numDiscoveredFiles - failedFilesSet.size();\n  summary_.setNumFiles(numTransferredFiles);\n}\n\nTransferReport::TransferReport(TransferStats&& globalStats, double totalTime,\n                               int64_t totalFileSize,\n                               int64_t numDiscoveredFiles,\n                               bool fileDiscoveryFinished)\n    : summary_(std::move(globalStats)),\n      totalTime_(totalTime),\n      totalFileSize_(totalFileSize),\n      numDiscoveredFiles_(numDiscoveredFiles),\n      fileDiscoveryFinished_(fileDiscoveryFinished) {\n}\n\nTransferReport::TransferReport(const std::vector<TransferStats>& threadStats,\n                               double totalTime, int64_t totalFileSize,\n                               int64_t numDiscoveredFiles,\n                               bool fileDiscoveryFinished)\n    : totalTime_(totalTime),\n      totalFileSize_(totalFileSize),\n      numDiscoveredFiles_(numDiscoveredFiles),\n      fileDiscoveryFinished_(fileDiscoveryFinished) {\n  for (const auto& stats : threadStats) {\n    summary_ += stats;\n  }\n}\n\nTransferReport::TransferReport(TransferStats&& globalStats)\n    : summary_(std::move(globalStats)) {\n  const int64_t numBlocksSend = summary_.getNumBlocksSend();\n  const int64_t numBlocksReceived = summary_.getNumBlocks();\n  const int64_t numBytesSend = summary_.getTotalSenderBytes();\n  const int64_t numBytesReceived = summary_.getEffectiveDataBytes();\n  ErrorCode summaryErrorCode = summary_.getLocalErrorCode();\n  WVLOG(1) << \"Summary Error Code \" << summaryErrorCode;\n  // TODO this is messy and error (ah!) prone\n  if (numBlocksSend == -1 || numBlocksSend != numBlocksReceived) {\n    WLOG(ERROR) << \"Did not receive all the blocks sent by the sender \"\n                << numBlocksSend << \" \" << numBlocksReceived;\n    summaryErrorCode = getMoreInterestingError(summaryErrorCode, ERROR);\n  } else if (numBytesSend != -1 && numBytesSend != numBytesReceived) {\n    // did not receive all the bytes\n    WLOG(ERROR) << \"Number of bytes sent and received do not match \"\n                << numBytesSend << \" \" << numBytesReceived;\n    summaryErrorCode = getMoreInterestingError(summaryErrorCode, ERROR);\n  } else {\n    // We got all the bytes... but if we have an encryption error we should\n    // make it stick (unlike the connection error on a single port...)\n    if (summaryErrorCode != OK && summaryErrorCode != ENCRYPTION_ERROR) {\n      WLOG(WARNING) << \"All bytes received, turning \"\n                    << errorCodeToStr(summaryErrorCode) << \" into local OK\";\n      summaryErrorCode = OK;\n    }\n  }\n  // only the local error code is set here. Any remote error means transfer\n  // failure. Since, getErrorCode checks both local and remote codes, it will\n  // return the correct one\n  summary_.setLocalErrorCode(summaryErrorCode);\n}\n\nstd::ostream& operator<<(std::ostream& os, const TransferReport& report) {\n  os << report.getSummary();\n  os << \" Previously sent bytes : \" << report.getPreviouslySentBytes() << \".\";\n  if (!report.failedSourceStats_.empty()) {\n    if (report.summary_.getNumFiles() == 0) {\n      os << \" All files failed.\";\n    } else {\n      os << \"\\n\" << WDT_LOG_PREFIX << \"Failed files :\\n\" << WDT_LOG_PREFIX;\n      std::set<std::string> failedFilesSet;\n      for (auto& stats : report.getFailedSourceStats()) {\n        failedFilesSet.insert(stats.getId());\n      }\n      int64_t numFailedFiles = failedFilesSet.size();\n      int64_t numOfFilesToPrint =\n          std::min<int64_t>(kMaxEntriesToPrint, numFailedFiles);\n\n      int64_t displayCount = 0;\n      for (auto& fileName : failedFilesSet) {\n        if (displayCount >= numOfFilesToPrint) {\n          break;\n        }\n        os << fileName << \"\\n\" << WDT_LOG_PREFIX;\n        displayCount++;\n      }\n\n      if (numOfFilesToPrint < numFailedFiles) {\n        os << \"more...(\" << numFailedFiles - numOfFilesToPrint << \" files)\";\n      }\n    }\n  }\n  if (!report.failedDirectories_.empty()) {\n    os << \"\\n\" << WDT_LOG_PREFIX << \"Failed directories :\\n\" << WDT_LOG_PREFIX;\n    int64_t numFailedDirectories = report.failedDirectories_.size();\n    int64_t numOfDirToPrint =\n        std::min<int64_t>(kMaxEntriesToPrint, numFailedDirectories);\n    for (int64_t i = 0; i < numOfDirToPrint; i++) {\n      os << report.failedDirectories_[i] << \"\\n\" << WDT_LOG_PREFIX;\n    }\n    if (numOfDirToPrint < numFailedDirectories) {\n      os << \"more...(\" << numFailedDirectories - numOfDirToPrint\n         << \" directories)\";\n    }\n  }\n  return os;\n}\n\nvoid ProgressReporter::progress(const std::unique_ptr<TransferReport>& report) {\n  const TransferStats& stats = report->getSummary();\n  int64_t totalDiscoveredSize = report->getTotalFileSize();\n  int progress = 0;\n  if (totalDiscoveredSize > 0) {\n    progress = stats.getEffectiveDataBytes() * 100 / totalDiscoveredSize;\n  }\n  if (isTty_) {\n    displayProgress(progress, report->getThroughputMBps(),\n                    report->getCurrentThroughputMBps(),\n                    report->getNumDiscoveredFiles(),\n                    report->fileDiscoveryFinished());\n  } else {\n    logProgress(stats.getEffectiveDataBytes(), progress,\n                report->getThroughputMBps(), report->getCurrentThroughputMBps(),\n                report->getNumDiscoveredFiles(),\n                report->fileDiscoveryFinished());\n  }\n}\n\nvoid ProgressReporter::end(const std::unique_ptr<TransferReport>& report) {\n  progress(report);\n  if (isTty_) {\n    std::cout << '\\n';\n    std::cout.flush();\n  }\n}\n\nvoid ProgressReporter::displayProgress(int progress, double averageThroughput,\n                                       double currentThroughput,\n                                       int64_t numDiscoveredFiles,\n                                       bool fileDiscoveryFinished) {\n  std::cout << '\\r';\n  int progressWidth = 50;\n  if (!fileDiscoveryFinished) {\n    std::cout << numDiscoveredFiles << \"...\";\n\n    // Progress bar is shorter while file discovery is ongoing\n    int digits = (numDiscoveredFiles > 0)\n                     ? ((int)log10((double)numDiscoveredFiles) + 1)\n                     : 1;\n    progressWidth -= (3 + digits);\n  }\n\n  int scaledProgress = (progress * progressWidth) / 100;\n  std::cout << '[';\n  for (int i = 0; i < scaledProgress - 1; i++) {\n    std::cout << '=';\n  }\n  if (scaledProgress != 0 && scaledProgress != progressWidth) {\n    std::cout << '>';\n  }\n  for (int i = 0; i < progressWidth - scaledProgress - 1; i++) {\n    std::cout << ' ';\n  }\n  std::cout << \"] \" << std::setw(2) << progress << \"% \" << std::setprecision(1)\n            << std::fixed << averageThroughput;\n  if (progress < 100) {\n    std::cout << \" \" << currentThroughput << \" Mbytes/s  \";\n  } else {\n    std::cout << \" Mbytes/s          \";\n  }\n  std::cout.flush();\n}\n\nvoid ProgressReporter::logProgress(int64_t effectiveDataBytes, int progress,\n                                   double averageThroughput,\n                                   double currentThroughput,\n                                   int64_t numDiscoveredFiles,\n                                   bool fileDiscoveryFinished) {\n  WLOG(INFO) << \"wdt transfer progress \" << (effectiveDataBytes / kMbToB)\n             << \" Mbytes, completed \" << progress << \"%, Average throughput \"\n             << averageThroughput << \" Mbytes/s, Recent throughput \"\n             << currentThroughput << \" Mbytes/s \" << numDiscoveredFiles\n             << \" Files discovered \"\n             << (fileDiscoveryFinished ? \"(complete)\" : \"(incomplete)\")\n             << \"; @logview-trait(ignore_task;1)\";\n}\n\nconst std::string PerfStatReport::statTypeDescription_[] = {\n    \"Socket Read\",\n    \"Socket Write\",\n    \"File Open\",\n    \"File Close\",\n    \"File Read\",\n    \"File Write\",\n    \"Sync File Range\",\n    \"fsync\",\n    \"File Seek\",\n    \"Throttler Sleep\",\n    \"Receiver Wait Sleep\",\n    \"Directory creation\",\n    \"Ioctl\",\n    \"Unlink\",\n    \"Fadvise\"};\n\nPerfStatReport::PerfStatReport(const WdtOptions& options) {\n  static_assert(\n      sizeof(statTypeDescription_) / sizeof(statTypeDescription_[0]) ==\n          PerfStatReport::END,\n      \"Mismatch between number of stat types and number of descriptions\");\n  networkTimeoutMillis_ =\n      std::min<int>(options.read_timeout_millis, options.write_timeout_millis);\n}\n\n/**\n *  Semi log bucket definitions covering 5 order of magnitude (more\n *  could be added) with high resolution in small numbers and relatively\n *  small number of total buckets\n *  For efficiency a look up table is created so the last value shouldn't\n *  be too large (or will incur large memory overhead)\n *  value between   [ bucket(i-1), bucket(i) [ go in slot i\n *  plus every value > bucket(last) in last bucket\n */\nconst int32_t PerfStatReport::kHistogramBuckets[] = {\n    1,     2,     3,     4,     5,     6,\n    7,     8,     9,     10,    11,          // by 1\n    12,    14,    16,    18,    20,          // by 2\n    25,    30,    35,    40,    45,    50,   // by 5\n    60,    70,    80,    90,    100,         // by 10\n    120,   140,   160,   180,   200,         // line2 *10\n    250,   300,   350,   400,   450,   500,  // line3 *10\n    600,   700,   800,   900,   1000,        // line4 *10\n    2000,  3000,  4000,  5000,  7500,  10000,\n    20000, 30000, 40000, 50000, 75000, 100000};\n\nvoid PerfStatReport::addPerfStat(StatType statType, int64_t timeInMicros) {\n  std::unique_lock writeLock(mutex_);\n\n  int64_t timeInMillis = timeInMicros / kMicroToMilli;\n  if (timeInMicros >= networkTimeoutMillis_ * 750) {\n    WLOG(WARNING) << statTypeDescription_[statType] << \" system call took \"\n                  << timeInMillis << \" ms\";\n  }\n  perfStats_[statType][timeInMillis]++;\n  maxValueMicros_[statType] =\n      std::max<int64_t>(maxValueMicros_[statType], timeInMicros);\n  minValueMicros_[statType] =\n      std::min<int64_t>(minValueMicros_[statType], timeInMicros);\n  count_[statType]++;\n  sumMicros_[statType] += timeInMicros;\n}\n\nPerfStatReport& PerfStatReport::operator+=(const PerfStatReport& statReport) {\n  std::unique_lock writeLock(mutex_);\n  std::shared_lock readLock(statReport.mutex_);\n\n  for (int i = 0; i < kNumTypes_; i++) {\n    for (const auto& pair : statReport.perfStats_[i]) {\n      int64_t key = pair.first;\n      int64_t value = pair.second;\n      perfStats_[i][key] += value;\n    }\n    maxValueMicros_[i] =\n        std::max<int64_t>(maxValueMicros_[i], statReport.maxValueMicros_[i]);\n    minValueMicros_[i] =\n        std::min<int64_t>(minValueMicros_[i], statReport.minValueMicros_[i]);\n    count_[i] += statReport.count_[i];\n    sumMicros_[i] += statReport.sumMicros_[i];\n  }\n  return *this;\n}\n\nstd::ostream& operator<<(std::ostream& os, const PerfStatReport& statReport) {\n  std::shared_lock readLock(statReport.mutex_);\n\n  os << \"***** PERF STATS *****\\n\" << WDT_LOG_PREFIX;\n  for (int i = 0; i < PerfStatReport::kNumTypes_; i++) {\n    if (statReport.count_[i] == 0) {\n      continue;\n    }\n    double max = statReport.maxValueMicros_[i] / kMicroToMilli;\n    double min = statReport.minValueMicros_[i] / kMicroToMilli;\n    double sum = (statReport.sumMicros_[i] / kMicroToMilli);\n    double avg = (((double)statReport.sumMicros_[i]) / statReport.count_[i] /\n                  kMicroToMilli);\n\n    os << std::fixed << std::setprecision(2);\n    os << statReport.statTypeDescription_[i] << \" : \";\n    os << \"Ncalls \" << statReport.count_[i] << \" Stats in ms : sum \" << sum\n       << \" Min \" << min << \" Max \" << max << \" Avg \" << avg << \" \";\n\n    // One extra bucket for values extending beyond last bucket\n    int numBuckets = 1 + sizeof(PerfStatReport::kHistogramBuckets) /\n                             sizeof(PerfStatReport::kHistogramBuckets[0]);\n    std::vector<int64_t> buckets(numBuckets);\n\n    auto& perfStatMap = statReport.perfStats_[i];\n    std::vector<int64_t> timesInMillis;\n    for (const auto& pair : perfStatMap) {\n      timesInMillis.emplace_back(pair.first);\n    }\n    std::sort(timesInMillis.begin(), timesInMillis.end());\n    int currentBucketIndex = 0;\n\n    int64_t runningCount = 0;\n    int64_t p50Count = statReport.count_[i] * 0.50;\n    int64_t p95Count = statReport.count_[i] * 0.95;\n    int64_t p99Count = statReport.count_[i] * 0.99;\n\n    for (auto time : timesInMillis) {\n      WDT_CHECK(time >= 0) << time;\n      int64_t count = perfStatMap.find(time)->second;\n\n      if (p50Count > runningCount && p50Count <= runningCount + count) {\n        os << \"p50 \" << time << \" \";\n      }\n      if (p95Count > runningCount && p95Count <= runningCount + count) {\n        os << \"p95 \" << time << \" \";\n      }\n      if (p99Count > runningCount && p99Count <= runningCount + count) {\n        os << \"p99 \" << time;\n      }\n      runningCount += count;\n\n      while (currentBucketIndex < numBuckets - 1 &&\n             time >= PerfStatReport::kHistogramBuckets[currentBucketIndex]) {\n        currentBucketIndex++;\n      }\n      buckets[currentBucketIndex] += count;\n    }\n    os << '\\n' << WDT_LOG_PREFIX;\n    for (int j = 0; j < numBuckets; j++) {\n      if (buckets[j] == 0) {\n        continue;\n      }\n      int64_t bucketStart =\n          (j == 0 ? 0 : PerfStatReport::kHistogramBuckets[j - 1]);\n      int64_t bucketEnd =\n          (j < numBuckets - 1 ? PerfStatReport::kHistogramBuckets[j]\n                              : std::numeric_limits<int64_t>::max());\n      os << \"[\" << bucketStart << \", \" << bucketEnd << \") --> \" << buckets[j]\n         << '\\n'\n         << WDT_LOG_PREFIX;\n    }\n  }\n  return os;\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "Reporting.h",
          "type": "blob",
          "size": 17.8291015625,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n#include <folly/synchronization/RWSpinLock.h>\n#include <wdt/AbortChecker.h>\n#include <wdt/ErrorCodes.h>\n#include <wdt/WdtOptions.h>\n#include <wdt/WdtTransferRequest.h>\n#include <wdt/util/EncryptionUtils.h>\n\n#include <algorithm>\n#include <chrono>\n#include <iterator>\n#include <limits>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nnamespace facebook {\nnamespace wdt {\n\nconst double kMbToB = 1024 * 1024;\nconst double kMicroToMilli = 1000;\nconst double kMicroToSec = 1000 * 1000;\nconst double kMilliToSec = 1000;\n\ntypedef std::chrono::high_resolution_clock Clock;\n\ntemplate <typename T>\nint64_t durationMicros(T d) {\n  return std::chrono::duration_cast<std::chrono::microseconds>(d).count();\n}\n\ntemplate <typename T>\nint durationMillis(T d) {\n  return std::chrono::duration_cast<std::chrono::milliseconds>(d).count();\n}\n\ntemplate <typename T>\ndouble durationSeconds(T d) {\n  return std::chrono::duration_cast<std::chrono::duration<double>>(d).count();\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &v) {\n  std::copy(v.begin(), v.end(), std::ostream_iterator<T>(os, \" \"));\n  return os;\n}\n\n// TODO rename to ThreadResult\n/// class representing statistics related to file transfer\nclass TransferStats {\n private:\n  /// number of header bytes transferred\n  int64_t headerBytes_ = 0;\n  /// number of data bytes transferred\n  int64_t dataBytes_ = 0;\n\n  /// number of header bytes transferred as part of successful file transfer\n  int64_t effectiveHeaderBytes_ = 0;\n  /// number of data bytes transferred as part of successful file transfer\n  int64_t effectiveDataBytes_ = 0;\n\n  /// number of files successfully transferred\n  int64_t numFiles_ = 0;\n\n  /// number of blocks successfully transferred\n  int64_t numBlocks_ = 0;\n\n  /// number of failed transfers\n  int64_t failedAttempts_ = 0;\n\n  /// Total number of blocks sent by sender\n  int64_t numBlocksSend_{-1};\n\n  /// Total number of bytes sent by sender\n  int64_t totalSenderBytes_{-1};\n\n  /// status of the transfer\n  ErrorCode localErrCode_ = OK;\n\n  /// status of the remote\n  ErrorCode remoteErrCode_ = OK;\n\n  /// id of the owner object\n  std::string id_;\n\n  /// encryption type used\n  EncryptionType encryptionType_{ENC_NONE};\n\n  /// is tls enabled?\n  bool tls_{false};\n\n  /// mutex to support synchronized access\n  std::unique_ptr<folly::RWSpinLock> mutex_{nullptr};\n\n  std::unique_lock<folly::RWSpinLock> getUniqueLock() {\n    using lock = std::unique_lock<folly::RWSpinLock>;\n    return mutex_ ? lock{*mutex_} : lock{};\n  }\n\n  std::shared_lock<folly::RWSpinLock> getSharedLock() const {\n    using lock = std::shared_lock<folly::RWSpinLock>;\n    return mutex_ ? lock{*mutex_} : lock{};\n  }\n\n public:\n  // making the object noncopyable\n  TransferStats(const TransferStats &stats) = delete;\n  TransferStats &operator=(const TransferStats &stats) = delete;\n  TransferStats(TransferStats &&stats) = default;\n  TransferStats &operator=(TransferStats &&stats) = default;\n\n  explicit TransferStats(bool isLocked = false) {\n    if (isLocked) {\n      mutex_ = std::make_unique<folly::RWSpinLock>();\n    }\n  }\n\n  explicit TransferStats(const std::string &id, bool isLocked = false)\n      : TransferStats(isLocked) {\n    id_ = id;\n  }\n\n  void reset() {\n    std::unique_lock lock(getUniqueLock());\n    headerBytes_ = dataBytes_ = 0;\n    effectiveHeaderBytes_ = effectiveDataBytes_ = 0;\n    numFiles_ = numBlocks_ = 0;\n    failedAttempts_ = 0;\n    localErrCode_ = remoteErrCode_ = OK;\n  }\n\n  /// @return the number of blocks sent by sender\n  int64_t getNumBlocksSend() const {\n    std::shared_lock lock(getSharedLock());\n    return numBlocksSend_;\n  }\n\n  /// @return the total sender bytes\n  int64_t getTotalSenderBytes() const {\n    std::shared_lock lock(getSharedLock());\n    return totalSenderBytes_;\n  }\n\n  /// @return number of header bytes transferred\n  int64_t getHeaderBytes() const {\n    std::shared_lock lock(getSharedLock());\n    return headerBytes_;\n  }\n\n  /// @return number of data bytes transferred\n  int64_t getDataBytes() const {\n    std::shared_lock lock(getSharedLock());\n    return dataBytes_;\n  }\n\n  /**\n   * @param needLocking     specifies whether we need to lock or not. this is\n   *                        for performance improvement. in sender, we do not\n   *                        need locking for this call, even though the other\n   *                        calls have to be locked\n   *\n   * @return                number of total bytes transferred\n   */\n  int64_t getTotalBytes(bool needLocking = true) const {\n    if (needLocking) {\n      std::shared_lock lock(getSharedLock());\n      return headerBytes_ + dataBytes_;\n    }\n    return headerBytes_ + dataBytes_;\n  }\n\n  /**\n   * @return    number of header bytes transferred as part of successful file\n   *            transfer\n   */\n  int64_t getEffectiveHeaderBytes() const {\n    std::shared_lock lock(getSharedLock());\n    return effectiveHeaderBytes_;\n  }\n\n  /**\n   * @return    number of data bytes transferred as part of successful file\n   *            transfer\n   */\n  int64_t getEffectiveDataBytes() const {\n    std::shared_lock lock(getSharedLock());\n    return effectiveDataBytes_;\n  }\n\n  /**\n   * @return    number of total bytes transferred as part of successful file\n   *            transfer\n   */\n  int64_t getEffectiveTotalBytes() const {\n    std::shared_lock lock(getSharedLock());\n    return effectiveHeaderBytes_ + effectiveDataBytes_;\n  }\n\n  /// @return number of files successfully transferred\n  int64_t getNumFiles() const {\n    std::shared_lock lock(getSharedLock());\n    return numFiles_;\n  }\n\n  /// @return number of blocks successfully transferred\n  int64_t getNumBlocks() const {\n    std::shared_lock lock(getSharedLock());\n    return numBlocks_;\n  }\n\n  /// @return number of failed transfers\n  int64_t getFailedAttempts() const {\n    std::shared_lock lock(getSharedLock());\n    return failedAttempts_;\n  }\n\n  /// @return error code based on combinator of local and remote error\n  ErrorCode getErrorCode() const {\n    std::shared_lock lock(getSharedLock());\n    return getMoreInterestingError(localErrCode_, remoteErrCode_);\n  }\n\n  /// @return status of the transfer on this side\n  ErrorCode getLocalErrorCode() const {\n    std::shared_lock lock(getSharedLock());\n    return localErrCode_;\n  }\n\n  /// @return status of the transfer on the remote end\n  ErrorCode getRemoteErrorCode() const {\n    std::shared_lock lock(getSharedLock());\n    return remoteErrCode_;\n  }\n\n  const std::string &getId() const {\n    std::shared_lock lock(getSharedLock());\n    return id_;\n  }\n\n  /// @param number of additional data bytes transferred\n  void addDataBytes(int64_t count) {\n    std::unique_lock lock(getUniqueLock());\n    dataBytes_ += count;\n  }\n\n  /// @param number of additional header bytes transferred\n  void addHeaderBytes(int64_t count) {\n    std::unique_lock lock(getUniqueLock());\n    headerBytes_ += count;\n  }\n\n  /// @param set num blocks send\n  void setNumBlocksSend(int64_t numBlocksSend) {\n    std::unique_lock lock(getUniqueLock());\n    numBlocksSend_ = numBlocksSend;\n  }\n\n  /// @param set total sender bytes\n  void setTotalSenderBytes(int64_t totalSenderBytes) {\n    std::unique_lock lock(getUniqueLock());\n    totalSenderBytes_ = totalSenderBytes;\n  }\n\n  /// one more file transfer failed\n  void incrFailedAttempts() {\n    std::unique_lock lock(getUniqueLock());\n    failedAttempts_++;\n  }\n\n  /// @param status of the transfer\n  void setLocalErrorCode(ErrorCode errCode) {\n    std::unique_lock lock(getUniqueLock());\n    localErrCode_ = errCode;\n  }\n\n  /// @param status of the transfer on the remote end\n  void setRemoteErrorCode(ErrorCode remoteErrCode) {\n    std::unique_lock lock(getUniqueLock());\n    remoteErrCode_ = remoteErrCode;\n  }\n\n  /// @param id of the corresponding entity\n  void setId(const std::string &id) {\n    std::unique_lock lock(getUniqueLock());\n    id_ = id;\n  }\n\n  /// @param numFiles number of files successfully send\n  void setNumFiles(int64_t numFiles) {\n    std::unique_lock lock(getUniqueLock());\n    numFiles_ = numFiles;\n  }\n\n  /// one more block successfully transferred\n  void incrNumBlocks() {\n    std::unique_lock lock(getUniqueLock());\n    numBlocks_++;\n  }\n\n  void decrNumBlocks() {\n    std::unique_lock lock(getUniqueLock());\n    numBlocks_--;\n  }\n\n  /**\n   * @param headerBytes header bytes transfered part of a successful file\n   *                    transfer\n   * @param dataBytes   data bytes transferred part of a successful file\n   *                    transfer\n   */\n  void addEffectiveBytes(int64_t headerBytes, int64_t dataBytes) {\n    std::unique_lock lock(getUniqueLock());\n    effectiveHeaderBytes_ += headerBytes;\n    effectiveDataBytes_ += dataBytes;\n  }\n\n  void subtractEffectiveBytes(int64_t headerBytes, int64_t dataBytes) {\n    std::unique_lock lock(getUniqueLock());\n    effectiveHeaderBytes_ -= headerBytes;\n    effectiveDataBytes_ -= dataBytes;\n  }\n\n  void setEncryptionType(EncryptionType encryptionType) {\n    std::unique_lock lock(getUniqueLock());\n    encryptionType_ = encryptionType;\n  }\n\n  EncryptionType getEncryptionType() const {\n    std::shared_lock lock(getSharedLock());\n    return encryptionType_;\n  }\n\n  void setTls(bool tls) {\n    std::unique_lock lock(getUniqueLock());\n    tls_ = tls;\n  }\n\n  bool getTls() const {\n    std::shared_lock lock(getSharedLock());\n    return tls_;\n  }\n\n  TransferStats &operator+=(const TransferStats &stats);\n\n  friend std::ostream &operator<<(std::ostream &os, const TransferStats &stats);\n};\n\n/**\n * Class representing entire client transfer report.\n * Unit are mebibyte (MiB), ie 1048576 bytes which we call \"Mbytes\"\n * for familiarity\n */\nclass TransferReport {\n public:\n  // TODO: too many constructor parameters, needs to clean-up\n  /**\n   * This constructor moves all the stat objects to member variables. This is\n   * only called at the end of transfer by the sender\n   */\n  TransferReport(std::vector<TransferStats> &transferredSourceStats,\n                 std::vector<TransferStats> &failedSourceStats,\n                 std::vector<TransferStats> &threadStats,\n                 std::vector<std::string> &failedDirectories, double totalTime,\n                 int64_t totalFileSize, int64_t numDiscoveredFiles,\n                 int64_t previouslySentBytes, bool fileDiscoveryFinished);\n\n  /**\n   * This function does not move the thread stats passed to it. This is called\n   * by the progress reporter thread.\n   */\n  TransferReport(const std::vector<TransferStats> &threadStats,\n                 double totalTime, int64_t totalFileSize,\n                 int64_t numDiscoveredFiles, bool fileDiscoveryFinished);\n\n  TransferReport(TransferStats &&stats, double totalTime, int64_t totalFileSize,\n                 int64_t numDiscoveredFiles, bool fileDiscoveryFinished);\n  /// constructor used by receiver, does move the stats\n  explicit TransferReport(TransferStats &&globalStats);\n  /// @return   summary of the report\n  const TransferStats &getSummary() const {\n    return summary_;\n  }\n  /// @return   transfer throughput in Mbytes/sec\n  double getThroughputMBps() const {\n    return summary_.getEffectiveTotalBytes() / totalTime_ / kMbToB;\n  }\n  /// @return total time taken in transfer\n  double getTotalTime() const {\n    return totalTime_;\n  }\n  /// @return   stats for successfully transferred sources\n  const std::vector<TransferStats> &getTransferredSourceStats() const {\n    return transferredSourceStats_;\n  }\n  /// @return   stats for failed sources\n  const std::vector<TransferStats> &getFailedSourceStats() const {\n    return failedSourceStats_;\n  }\n  /// @return   stats for threads\n  const std::vector<TransferStats> &getThreadStats() const {\n    return threadStats_;\n  }\n  const std::vector<std::string> &getFailedDirectories() const {\n    return failedDirectories_;\n  }\n  int64_t getTotalFileSize() const {\n    return totalFileSize_;\n  }\n  /// @return   recent throughput in Mbytes/sec\n  double getCurrentThroughputMBps() const {\n    return currentThroughput_ / kMbToB;\n  }\n  /// @param stats  stats to added\n  void addTransferStats(const TransferStats &stats) {\n    summary_ += stats;\n  }\n  /// @param currentThroughput  current throughput\n  void setCurrentThroughput(double currentThroughput) {\n    currentThroughput_ = currentThroughput;\n  }\n  void setTotalTime(double totalTime) {\n    totalTime_ = totalTime;\n  }\n  void setTotalFileSize(int64_t totalFileSize) {\n    totalFileSize_ = totalFileSize;\n  }\n  void setErrorCode(const ErrorCode errCode) {\n    summary_.setLocalErrorCode(errCode);\n    summary_.setRemoteErrorCode(errCode);\n  }\n  int64_t getNumDiscoveredFiles() const {\n    return numDiscoveredFiles_;\n  }\n  bool fileDiscoveryFinished() const {\n    return fileDiscoveryFinished_;\n  }\n  int64_t getPreviouslySentBytes() const {\n    return previouslySentBytes_;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const TransferReport &report);\n\n private:\n  TransferStats summary_;\n  /// stats for successfully transferred sources\n  std::vector<TransferStats> transferredSourceStats_;\n  /// stats for failed sources\n  std::vector<TransferStats> failedSourceStats_;\n  /// stats for client threads\n  std::vector<TransferStats> threadStats_;\n  /// directories which could not be opened\n  std::vector<std::string> failedDirectories_;\n  /// total transfer time\n  double totalTime_{0};\n  /// sum of all the file sizes\n  int64_t totalFileSize_{0};\n  /// recent throughput in bytes/sec\n  double currentThroughput_{0};\n  /// Count of all files discovered so far\n  int64_t numDiscoveredFiles_{0};\n  /// Number of bytes sent in previous transfers\n  int64_t previouslySentBytes_{0};\n  /// Is file discovery finished?\n  bool fileDiscoveryFinished_{false};\n};\n\n/**\n * This class represents interface and default implementation of progress\n * reporting\n */\nclass ProgressReporter {\n public:\n  explicit ProgressReporter(const WdtTransferRequest &transferRequest)\n      : transferRequest_(transferRequest) {\n    isTty_ = isatty(STDOUT_FILENO);\n  }\n\n  /// this method is called before the transfer starts\n  virtual void start() {\n  }\n\n  /**\n   * This method gets called repeatedly with interval defined by\n   * progress_report_interval. If stdout is a terminal, then it displays\n   * transfer progress in stdout. Example output [===>    ] 30% 5.00 Mbytes/sec.\n   * Else, it prints progress details in stdout.\n   *\n   * @param report                current transfer report\n   */\n  virtual void progress(const std::unique_ptr<TransferReport> &report);\n\n  /**\n   * This method gets called after the transfer ends\n   *\n   * @param report                final transfer report\n   */\n  virtual void end(const std::unique_ptr<TransferReport> &report);\n\n  virtual ~ProgressReporter() {\n  }\n\n protected:\n  /// Reference to the wdt transfer request for the wdt base\n  /// object using the progress reporter\n  const WdtTransferRequest &transferRequest_;\n\n private:\n  /**\n   * Displays progress of the transfer in stdout\n   *\n   * @param progress              progress percentage\n   * @param throughput            average throughput\n   * @param currentThroughput     recent throughput\n   * @param numDiscoveredFiles    number of files discovered so far\n   * @param fileDiscoveryFinished true once file discovery has compeleted\n   */\n  void displayProgress(int progress, double averageThroughput,\n                       double currentThroughput, int64_t numDiscoveredFiles,\n                       bool fileDiscoveryFinished);\n\n  /**\n   * logs progress details\n   *\n   * @param effectiveDataBytes    number of bytes sent\n   * @param progress              progress percentage\n   * @param throughput            average throughput\n   * @param currentThroughput     recent throughput\n   * @param numDiscoveredFiles    number of files discovered so far\n   * @param fileDiscoveryFinished true once file discovery has compeleted\n   */\n  void logProgress(int64_t effectiveDataBytes, int progress,\n                   double averageThroughput, double currentThroughput,\n                   int64_t numDiscoveredFiles, bool fileDiscoveryFinished);\n\n  /// whether stdout is redirected to a terminal or not\n  bool isTty_;\n};\n\n/// class representing perf stat collection\nclass PerfStatReport {\n public:\n  enum StatType {\n    SOCKET_READ,\n    SOCKET_WRITE,\n    FILE_OPEN,\n    FILE_CLOSE,\n    FILE_READ,\n    FILE_WRITE,\n    SYNC_FILE_RANGE,\n    FSYNC_STATS,  // just 'FSYNC' is defined on Windows/conflicts\n    FILE_SEEK,\n    THROTTLER_SLEEP,\n    RECEIVER_WAIT_SLEEP,  // receiver sleep duration between sending wait cmd to\n                          // sender. A high sum for this suggests threads\n                          // were not properly load balanced\n    DIRECTORY_CREATE,\n    IOCTL,\n    UNLINK,\n    FADVISE,\n    END\n  };\n\n  explicit PerfStatReport(const WdtOptions &options);\n\n  /**\n   * @param statType      stat-type\n   * @param timeInMicros  time taken by the operation in microseconds\n   */\n  void addPerfStat(StatType statType, int64_t timeInMicros);\n\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const PerfStatReport &statReport);\n  PerfStatReport &operator+=(const PerfStatReport &statReport);\n\n private:\n  const static int kNumTypes_ = PerfStatReport::END;\n  const static std::string statTypeDescription_[];\n  const static int32_t kHistogramBuckets[];\n  /// mapping from time to number of entries\n  std::unordered_map<int64_t, int64_t> perfStats_[kNumTypes_];\n  /// max time for different stat types\n  int64_t maxValueMicros_[kNumTypes_] = {0};\n  /// min time for different stat types\n  int64_t minValueMicros_[kNumTypes_] = {std::numeric_limits<int64_t>::max()};\n  /// number of records for different stat types\n  int64_t count_[kNumTypes_] = {0};\n  /// sum of all records for different stat types\n  int64_t sumMicros_[kNumTypes_] = {0};\n  /// network timeout in milliseconds\n  int networkTimeoutMillis_;\n  /// mutex to support synchronized access\n  mutable folly::RWSpinLock mutex_;\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "Sender.cpp",
          "type": "blob",
          "size": 16.337890625,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <folly/Conv.h>\n#include <folly/Memory.h>\n#include <folly/ScopeGuard.h>\n#include <folly/String.h>\n#include <folly/hash/Checksum.h>\n#include <folly/lang/Bits.h>\n#include <wdt/Sender.h>\n#include <wdt/SenderThread.h>\n#include <wdt/Throttler.h>\n#include <wdt/util/ClientSocket.h>\n\nnamespace facebook {\nnamespace wdt {\n\nvoid Sender::endCurTransfer() {\n  endTime_ = Clock::now();\n  WLOG(INFO) << \"Last thread finished \"\n             << durationSeconds(endTime_ - startTime_) << \" for transfer id \"\n             << getTransferId();\n  setTransferStatus(TransferStatus::FINISHED);\n  if (throttler_) {\n    throttler_->endTransfer();\n  }\n}\n\nvoid Sender::startNewTransfer() {\n  if (throttler_) {\n    throttler_->startTransfer();\n  }\n  WLOG(INFO) << \"Starting a new transfer \" << getTransferId() << \" to \"\n             << transferRequest_.hostName;\n}\n\nSender::Sender(const WdtTransferRequest &transferRequest)\n    : queueAbortChecker_(this) {\n  WLOG(INFO) << \"WDT Sender \" << Protocol::getFullVersion();\n  transferRequest_ = transferRequest;\n\n  if (getTransferId().empty()) {\n    WLOG(WARNING) << \"Sender without transferId... will likely fail to connect\";\n  }\n}\n\nErrorCode Sender::validateTransferRequest() {\n  ErrorCode code = WdtBase::validateTransferRequest();\n  // If the request is still valid check for other\n  // sender specific validations\n  if (code == OK && transferRequest_.hostName.empty()) {\n    WLOG(ERROR) << \"Transfer request validation failed for wdt sender \"\n                << transferRequest_.getLogSafeString();\n    code = INVALID_REQUEST;\n  }\n  transferRequest_.errorCode = code;\n  return code;\n}\n\nconst WdtTransferRequest &Sender::init() {\n  WVLOG(1) << \"Sender Init() with encryption set = \"\n           << transferRequest_.encryptionData.isSet();\n  negotiateProtocol();\n  if (validateTransferRequest() != OK) {\n    WLOG(ERROR) << \"Couldn't validate the transfer request \"\n                << transferRequest_.getLogSafeString();\n    return transferRequest_;\n  }\n  // TODO Figure out what to do with file info\n  // transferRequest.fileInfo = dirQueue_->getFileInfo();\n  transferRequest_.errorCode = OK;\n\n  bool encrypt = transferRequest_.encryptionData.isSet();\n  WLOG_IF(INFO, encrypt) << \"Encryption is enabled for this transfer\";\n  return transferRequest_;\n}\n\nSender::~Sender() {\n  TransferStatus status = getTransferStatus();\n  if (status == TransferStatus::ONGOING) {\n    WLOG(WARNING) << \"Sender being deleted. Forcefully aborting the transfer\";\n    abort(ABORTED_BY_APPLICATION);\n  }\n  finish();\n}\n\nProtoNegotiationStatus Sender::getNegotiationStatus() {\n  return protoNegotiationStatus_;\n}\n\nstd::vector<int> Sender::getNegotiatedProtocols() const {\n  std::vector<int> ret;\n  for (const auto &senderThread : senderThreads_) {\n    ret.push_back(senderThread->getNegotiatedProtocol());\n  }\n  return ret;\n}\n\nvoid Sender::setProtoNegotiationStatus(ProtoNegotiationStatus status) {\n  protoNegotiationStatus_ = status;\n}\n\nbool Sender::isSendFileChunks() const {\n  return (downloadResumptionEnabled_ &&\n          getProtocolVersion() >= Protocol::DOWNLOAD_RESUMPTION_VERSION);\n}\n\nbool Sender::isFileChunksReceived() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  return fileChunksReceived_;\n}\n\nvoid Sender::setFileChunksInfo(\n    std::vector<FileChunksInfo> &fileChunksInfoList) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (fileChunksReceived_) {\n    WLOG(WARNING) << \"File chunks list received multiple times\";\n    return;\n  }\n  dirQueue_->setPreviouslyReceivedChunks(fileChunksInfoList);\n  fileChunksReceived_ = true;\n}\n\nconst std::string &Sender::getDestination() const {\n  return transferRequest_.hostName;\n}\n\nstd::unique_ptr<TransferReport> Sender::getTransferReport() {\n  int64_t totalFileSize = 0;\n  int64_t fileCount = 0;\n  bool fileDiscoveryFinished = false;\n  if (dirQueue_ != nullptr) {\n    totalFileSize = dirQueue_->getTotalSize();\n    fileCount = dirQueue_->getCount();\n    fileDiscoveryFinished = dirQueue_->fileDiscoveryFinished();\n  }\n  double totalTime = durationSeconds(Clock::now() - startTime_);\n  auto globalStats = getGlobalTransferStats();\n  std::unique_ptr<TransferReport> transferReport =\n      std::make_unique<TransferReport>(std::move(globalStats), totalTime,\n                                       totalFileSize, fileCount,\n                                       fileDiscoveryFinished);\n  TransferStatus status = getTransferStatus();\n  ErrorCode errCode = transferReport->getSummary().getErrorCode();\n  if (status == TransferStatus::NOT_STARTED && errCode == OK) {\n    WLOG(INFO) << \"Transfer not started, setting the error code to ERROR\";\n    transferReport->setErrorCode(ERROR);\n  }\n  return transferReport;\n}\n\nClock::time_point Sender::getEndTime() {\n  return endTime_;\n}\n\nTransferStats Sender::getGlobalTransferStats() const {\n  TransferStats globalStats;\n  for (const auto &thread : senderThreads_) {\n    globalStats += thread->getTransferStats();\n  }\n  return globalStats;\n}\n\nstd::unique_ptr<TransferReport> Sender::finish() {\n  std::unique_lock<std::mutex> instanceLock(instanceManagementMutex_);\n  WVLOG(1) << \"Sender::finish()\";\n  TransferStatus status = getTransferStatus();\n  if (status == TransferStatus::NOT_STARTED) {\n    WLOG(WARNING) << \"Even though transfer has not started, finish is called\";\n    // getTransferReport will set the error code to ERROR\n    return getTransferReport();\n  }\n  if (status == TransferStatus::THREADS_JOINED) {\n    WVLOG(1) << \"Threads have already been joined. Returning the\"\n             << \" existing transfer report\";\n    return getTransferReport();\n  }\n  const bool twoPhases = options_.two_phases;\n  bool progressReportEnabled =\n      progressReporter_ && progressReportIntervalMillis_ > 0;\n  for (auto &senderThread : senderThreads_) {\n    senderThread->finish();\n  }\n  if (!twoPhases) {\n    dirThread_.join();\n  }\n  WDT_CHECK(numActiveThreads_ == 0);\n  setTransferStatus(TransferStatus::THREADS_JOINED);\n  if (progressReportEnabled) {\n    progressReporterThread_.join();\n  }\n  std::vector<TransferStats> threadStats;\n  for (auto &senderThread : senderThreads_) {\n    threadStats.push_back(senderThread->moveStats());\n  }\n\n  bool allSourcesAcked = false;\n  for (auto &senderThread : senderThreads_) {\n    auto &stats = senderThread->getTransferStats();\n    if (stats.getErrorCode() == OK) {\n      // at least one thread finished correctly\n      // that means all transferred sources are acked\n      allSourcesAcked = true;\n      break;\n    }\n  }\n\n  std::vector<TransferStats> transferredSourceStats;\n  for (auto port : transferRequest_.ports) {\n    auto &transferHistory =\n        transferHistoryController_->getTransferHistory(port);\n    if (allSourcesAcked) {\n      transferHistory.markAllAcknowledged();\n    } else {\n      transferHistory.returnUnackedSourcesToQueue();\n    }\n    if (options_.full_reporting) {\n      std::vector<TransferStats> stats = transferHistory.popAckedSourceStats();\n      transferredSourceStats.insert(transferredSourceStats.end(),\n                                    std::make_move_iterator(stats.begin()),\n                                    std::make_move_iterator(stats.end()));\n    }\n  }\n  if (options_.full_reporting) {\n    validateTransferStats(transferredSourceStats,\n                          dirQueue_->getFailedSourceStats());\n  }\n  int64_t totalFileSize = dirQueue_->getTotalSize();\n  double totalTime = durationSeconds(endTime_ - startTime_);\n  std::unique_ptr<TransferReport> transferReport =\n      std::make_unique<TransferReport>(\n          transferredSourceStats, dirQueue_->getFailedSourceStats(),\n          threadStats, dirQueue_->getFailedDirectories(), totalTime,\n          totalFileSize, dirQueue_->getCount(),\n          dirQueue_->getPreviouslySentBytes(),\n          dirQueue_->fileDiscoveryFinished());\n\n  if (progressReportEnabled) {\n    progressReporter_->end(transferReport);\n  }\n  logPerfStats();\n\n  double directoryTime;\n  directoryTime = dirQueue_->getDirectoryTime();\n  WLOG(INFO) << \"Total sender time = \" << totalTime << \" seconds (\"\n             << directoryTime << \" dirTime)\"\n             << \". Transfer summary : \" << *transferReport << \"\\n\"\n             << WDT_LOG_PREFIX << \"Total sender throughput = \"\n             << transferReport->getThroughputMBps() << \" Mbytes/sec (\"\n             << transferReport->getSummary().getEffectiveTotalBytes() /\n                    (totalTime - directoryTime) / kMbToB\n             << \" Mbytes/sec pure transfer rate)\";\n  return transferReport;\n}\n\nErrorCode Sender::transferAsync() {\n  return start();\n}\n\nstd::unique_ptr<TransferReport> Sender::transfer() {\n  start();\n  return finish();\n}\n\nfolly::Optional<std::vector<WdtFileInfo>>\nSender::getFilesFromFileInfoGenerator() {\n  auto runningThreads = [this]() {\n    return threadsController_->numRunningThreads();\n  };\n  dirQueue_->waitForPreviousTransfer(\n      std::chrono::milliseconds(options_.progress_report_interval_millis),\n      runningThreads);\n\n  const auto status = getTransferStatus();\n  if (status != TransferStatus::ONGOING) {\n    WLOG(INFO) << \"Terminating transafer since status isn't ONGOING. \"\n               << \"Status: \" << status;\n    return folly::none;\n  }\n  return transferRequest_.fileInfoGenerator();\n}\n\nErrorCode Sender::start() {\n  {\n    std::lock_guard<std::mutex> lock(mutex_);\n    if (transferStatus_ != TransferStatus::NOT_STARTED) {\n      WLOG(ERROR) << \"duplicate start() call detected \" << transferStatus_;\n      return ALREADY_EXISTS;\n    }\n    transferStatus_ = TransferStatus::ONGOING;\n  }\n\n  // set up directory queue\n  dirQueue_.reset(new DirectorySourceQueue(options_, transferRequest_.directory,\n                                           &queueAbortChecker_));\n  WVLOG(3) << \"Configuring the  directory queue\";\n  dirQueue_->setIncludePattern(options_.include_regex);\n  dirQueue_->setExcludePattern(options_.exclude_regex);\n  dirQueue_->setPruneDirPattern(options_.prune_dir_regex);\n  dirQueue_->setFollowSymlinks(options_.follow_symlinks);\n  dirQueue_->setBlockSizeMbytes(options_.block_size_mbytes);\n  dirQueue_->setNumClientThreads(transferRequest_.ports.size());\n  dirQueue_->setOpenFilesDuringDiscovery(options_.open_files_during_discovery);\n  dirQueue_->setDirectReads(options_.odirect_reads);\n  if (!transferRequest_.fileInfo.empty() ||\n      transferRequest_.fileInfoGenerator ||\n      transferRequest_.disableDirectoryTraversal) {\n    dirQueue_->setFileInfo(transferRequest_.fileInfo);\n    if (transferRequest_.fileInfoGenerator) {\n      dirQueue_->setFileInfoGenerator(\n          [this]() { return getFilesFromFileInfoGenerator(); });\n    }\n  }\n  transferHistoryController_ =\n      std::make_unique<TransferHistoryController>(*dirQueue_);\n\n  checkAndUpdateBufferSize();\n  const bool twoPhases = options_.two_phases;\n  WLOG(INFO) << \"Client (sending) to \" << getDestination() << \", Using ports [ \"\n             << transferRequest_.ports << \"]\";\n  startTime_ = Clock::now();\n  progressReportIntervalMillis_ = options_.progress_report_interval_millis;\n  downloadResumptionEnabled_ = (transferRequest_.downloadResumptionEnabled ||\n                                options_.enable_download_resumption);\n  bool deleteExtraFiles = (transferRequest_.downloadResumptionEnabled ||\n                           options_.delete_extra_files);\n  if (!progressReporter_) {\n    WVLOG(1) << \"No progress reporter provided, making a default one\";\n    progressReporter_ = std::make_unique<ProgressReporter>(transferRequest_);\n  }\n  bool progressReportEnabled =\n      progressReporter_ && progressReportIntervalMillis_ > 0;\n  if (throttler_) {\n    WLOG(INFO) << \"Skipping throttler setup. External throttler set.\"\n               << \"Throttler details : \" << *throttler_;\n  } else {\n    configureThrottler();\n  }\n  threadsController_ = new ThreadsController(transferRequest_.ports.size());\n  threadsController_->setNumBarriers(SenderThread::NUM_BARRIERS);\n  threadsController_->setNumFunnels(SenderThread::NUM_FUNNELS);\n  threadsController_->setNumConditions(SenderThread::NUM_CONDITIONS);\n  // TODO: fix this ! use transferRequest! (and dup from Receiver)\n  senderThreads_ = threadsController_->makeThreads<Sender, SenderThread>(\n      this, transferRequest_.ports.size(), transferRequest_.ports);\n  if (downloadResumptionEnabled_ && deleteExtraFiles) {\n    if (getProtocolVersion() >= Protocol::DELETE_CMD_VERSION) {\n      dirQueue_->enableFileDeletion();\n    } else {\n      WLOG(WARNING) << \"Turning off extra file deletion on the receiver side \"\n                       \"because of protocol version \"\n                    << getProtocolVersion();\n    }\n  }\n  dirThread_ = dirQueue_->buildQueueAsynchronously();\n  if (twoPhases) {\n    dirThread_.join();\n  }\n  for (auto &senderThread : senderThreads_) {\n    senderThread->startThread();\n  }\n  if (progressReportEnabled) {\n    progressReporter_->start();\n    std::thread reporterThread(&Sender::reportProgress, this);\n    progressReporterThread_ = std::move(reporterThread);\n  }\n  return OK;\n}\n\nvoid Sender::validateTransferStats(\n    const std::vector<TransferStats> &transferredSourceStats,\n    const std::vector<TransferStats> &failedSourceStats) {\n  int64_t sourceFailedAttempts = 0;\n  int64_t sourceDataBytes = 0;\n  int64_t sourceEffectiveDataBytes = 0;\n  int64_t sourceNumBlocks = 0;\n\n  int64_t threadFailedAttempts = 0;\n  int64_t threadDataBytes = 0;\n  int64_t threadEffectiveDataBytes = 0;\n  int64_t threadNumBlocks = 0;\n\n  for (const auto &stat : transferredSourceStats) {\n    sourceFailedAttempts += stat.getFailedAttempts();\n    sourceDataBytes += stat.getDataBytes();\n    sourceEffectiveDataBytes += stat.getEffectiveDataBytes();\n    sourceNumBlocks += stat.getNumBlocks();\n  }\n  for (const auto &stat : failedSourceStats) {\n    sourceFailedAttempts += stat.getFailedAttempts();\n    sourceDataBytes += stat.getDataBytes();\n    sourceEffectiveDataBytes += stat.getEffectiveDataBytes();\n    sourceNumBlocks += stat.getNumBlocks();\n  }\n  for (const auto &senderThread : senderThreads_) {\n    const auto &stat = senderThread->getTransferStats();\n    threadFailedAttempts += stat.getFailedAttempts();\n    threadDataBytes += stat.getDataBytes();\n    threadEffectiveDataBytes += stat.getEffectiveDataBytes();\n    threadNumBlocks += stat.getNumBlocks();\n  }\n\n  WDT_CHECK(sourceFailedAttempts == threadFailedAttempts);\n  WDT_CHECK(sourceDataBytes == threadDataBytes);\n  WDT_CHECK(sourceEffectiveDataBytes == threadEffectiveDataBytes);\n  WDT_CHECK(sourceNumBlocks == threadNumBlocks);\n}\n\nvoid Sender::setSocketCreator(Sender::ISocketCreator *socketCreator) {\n  socketCreator_ = socketCreator;\n}\n\nvoid Sender::reportProgress() {\n  WDT_CHECK(progressReportIntervalMillis_ > 0);\n  int throughputUpdateIntervalMillis =\n      options_.throughput_update_interval_millis;\n  WDT_CHECK(throughputUpdateIntervalMillis >= 0);\n  int throughputUpdateInterval =\n      throughputUpdateIntervalMillis / progressReportIntervalMillis_;\n\n  int64_t lastEffectiveBytes = 0;\n  std::chrono::time_point<Clock> lastUpdateTime = Clock::now();\n  int intervalsSinceLastUpdate = 0;\n  double currentThroughput = 0;\n\n  auto waitingTime = std::chrono::milliseconds(progressReportIntervalMillis_);\n  WLOG(INFO) << \"Progress reporter tracking every \"\n             << progressReportIntervalMillis_ << \" ms\";\n  while (true) {\n    {\n      std::unique_lock<std::mutex> lock(mutex_);\n      conditionFinished_.wait_for(lock, waitingTime);\n      if (transferStatus_ == TransferStatus::THREADS_JOINED) {\n        break;\n      }\n    }\n\n    std::unique_ptr<TransferReport> transferReport = getTransferReport();\n    intervalsSinceLastUpdate++;\n    if (intervalsSinceLastUpdate >= throughputUpdateInterval) {\n      auto curTime = Clock::now();\n      int64_t curEffectiveBytes =\n          transferReport->getSummary().getEffectiveDataBytes();\n      double time = durationSeconds(curTime - lastUpdateTime);\n      currentThroughput = (curEffectiveBytes - lastEffectiveBytes) / time;\n      lastEffectiveBytes = curEffectiveBytes;\n      lastUpdateTime = curTime;\n      intervalsSinceLastUpdate = 0;\n    }\n    transferReport->setCurrentThroughput(currentThroughput);\n\n    progressReporter_->progress(transferReport);\n    if (reportPerfSignal_.notified()) {\n      logPerfStats();\n    }\n  }\n}\n\nvoid Sender::logPerfStats() const {\n  if (!options_.enable_perf_stat_collection) {\n    return;\n  }\n\n  PerfStatReport report(options_);\n  for (auto &senderThread : senderThreads_) {\n    report += senderThread->getPerfReport();\n  }\n  report += dirQueue_->getPerfReport();\n  WLOG(INFO) << report;\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "Sender.h",
          "type": "blob",
          "size": 7.4130859375,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n#include <wdt/WdtBase.h>\n#include <wdt/util/ClientSocket.h>\n\n#include <chrono>\n#include <iostream>\n#include <memory>\n\nnamespace facebook {\nnamespace wdt {\n\nclass SenderThread;\nclass TransferHistoryController;\n\nenum ProtoNegotiationStatus {\n  V_MISMATCH_WAIT,      // waiting for version mismatch to be processed\n  V_MISMATCH_RESOLVED,  // version mismatch processed and was successful\n  V_MISMATCH_FAILED,    // version mismatch processed and it failed\n};\n\n/**\n * The sender for the transfer. One instance of sender should only be\n * responsible for one transfer. For a second transfer you should make\n * another instance of the sender.\n * The object will not be destroyed till the transfer finishes. This\n * class is not thread safe.\n */\nclass Sender : public WdtBase {\n public:\n  /// Creates a counter part sender for the receiver according to the details\n  explicit Sender(const WdtTransferRequest &transferRequest);\n\n  /// Setup before start (@see WdtBase.h)\n  const WdtTransferRequest &init() override;\n\n  /**\n   * If the transfer has not finished, then it is aborted. finish() is called to\n   * wait for threads to end.\n   */\n  ~Sender() override;\n\n  /**\n   * Joins on the threads spawned by start. This has to\n   * be explicitly called when the caller expects to conclude\n   * a transfer. This method can be called multiple times and is thread-safe.\n   *\n   * @return    transfer report\n   */\n  std::unique_ptr<TransferReport> finish() override;\n\n  /**\n   * API to initiate a transfer and return back to the context\n   * from where it was called. Caller would have to call finish\n   * to get the stats for the transfer\n   */\n  ErrorCode transferAsync() override;\n\n  /**\n   * A blocking call which will initiate a transfer based on\n   * the configuration and return back the stats for the transfer\n   *\n   * @return    transfer report\n   */\n  std::unique_ptr<TransferReport> transfer();\n\n  /// End time of the transfer\n  Clock::time_point getEndTime();\n\n  /// Get the destination sender is sending to\n  /// @return     destination host-name\n  const std::string &getDestination() const;\n\n  /// @return    minimal transfer report using transfer stats of the thread\n  std::unique_ptr<TransferReport> getTransferReport();\n\n  /// Interface to make socket\n  class ISocketCreator {\n   public:\n    virtual std::unique_ptr<IClientSocket> makeClientSocket(\n        ThreadCtx &threadCtx, const std::string &dest, const int port,\n        const EncryptionParams &encryptionParams, int64_t ivChangeInterval,\n        bool tls) = 0;\n\n    virtual ~ISocketCreator() = default;\n  };\n\n  /**\n   * Sets socket creator\n   *\n   * @param socketCreator   socket-creator to be used\n   */\n  void setSocketCreator(ISocketCreator *socketCreator);\n\n private:\n  friend class SenderThread;\n  friend class QueueAbortChecker;\n  friend class SenderTests;\n\n  /// Validate the transfer request\n  ErrorCode validateTransferRequest() override;\n\n  /// Get the sum of all the thread transfer stats\n  TransferStats getGlobalTransferStats() const;\n\n  /// Returns true if file chunks need to be read\n  bool isSendFileChunks() const;\n\n  /// Returns true if file chunks been received by a thread\n  bool isFileChunksReceived();\n\n  /// Sender thread calls this method to set the file chunks info received\n  /// from the receiver\n  void setFileChunksInfo(std::vector<FileChunksInfo> &fileChunksInfoList);\n\n  /// Abort checker passed to DirectoryQueue. If all the network threads finish,\n  /// directory discovery thread is also aborted\n  class QueueAbortChecker : public IAbortChecker {\n   public:\n    explicit QueueAbortChecker(Sender *sender) : sender_(sender) {\n    }\n\n    bool shouldAbort() const override {\n      return (sender_->getTransferStatus() == TransferStatus::FINISHED);\n    }\n\n   private:\n    Sender *sender_;\n  };\n\n  /// Abort checker shared with the directory queue\n  QueueAbortChecker queueAbortChecker_;\n\n  /**\n   * Internal API that triggers the directory thread, sets up the sender\n   * threads and starts the transfer. Returns after the sender threads\n   * have been spawned\n   */\n  ErrorCode start();\n\n  /**\n   * @param transferredSourceStats      Stats for the successfully transmitted\n   *                                    sources\n   * @param failedSourceStats           Stats for the failed sources\n   */\n  void validateTransferStats(\n      const std::vector<TransferStats> &transferredSourceStats,\n      const std::vector<TransferStats> &failedSourceStats);\n\n  /**\n   * Responsible for doing a periodic check.\n   * 1. Takes a lock on the thread stats to make a summary\n   * 2. Sends the progress report with the summary to the progress reporter\n   *    which can be provided by the user\n   */\n  void reportProgress();\n\n  void logPerfStats() const override;\n\n  /// Get the files from fileInfoGenerator if it's configured in transferRequest\n  /// Note: This call may block on DirectorySourceQueue::waitForPreviousTransfer\n  ///\n  /// @return     list of files or folly::none indicating no more files\n  folly::Optional<std::vector<WdtFileInfo>> getFilesFromFileInfoGenerator();\n\n  /// Pointer to DirectorySourceQueue which reads the srcDir and the files\n  std::unique_ptr<DirectorySourceQueue> dirQueue_;\n  /// Number of active threads, decremented every time a thread is finished\n  int32_t numActiveThreads_{0};\n  /// The interval at which the progress reporter should check for progress\n  int progressReportIntervalMillis_{0};\n  /// Socket creator used to optionally create different kinds of client socket\n  ISocketCreator *socketCreator_{nullptr};\n  /// Whether download resumption is enabled or not\n  bool downloadResumptionEnabled_{false};\n  /// Flags representing whether file chunks have been received or not\n  bool fileChunksReceived_{false};\n  /// Thread that is running the discovery of files using the dirQueue_\n  std::thread dirThread_;\n  /// Threads which are responsible for transfer of the sources\n  std::vector<std::unique_ptr<WdtThread>> senderThreads_;\n  /// Thread responsible for doing the progress checks. Uses reportProgress()\n  std::thread progressReporterThread_;\n\n  /// Returns the protocol negotiation status of the parent sender\n  ProtoNegotiationStatus getNegotiationStatus();\n\n  /// Set the protocol negotiation status, called by sender thread\n  void setProtoNegotiationStatus(ProtoNegotiationStatus status);\n\n  /// Things to do before ending the current transfer\n  void endCurTransfer();\n\n  /// Initializing the new transfer\n  void startNewTransfer();\n\n  /// Returns vector of negotiated protocols set by sender threads\n  std::vector<int> getNegotiatedProtocols() const;\n\n  /// Protocol negotiation status, used to co-ordinate processing of version\n  /// mismatch. Threads aborted due to version mismatch waits for all threads to\n  /// abort and reach PROCESS_VERSION_MISMATCH state. Last thread processes\n  /// version mismatch and changes this status variable. Other threads check\n  /// this variable to decide when to proceed.\n  ProtoNegotiationStatus protoNegotiationStatus_{V_MISMATCH_WAIT};\n  /// Time at which the transfer was started\n  std::chrono::time_point<Clock> startTime_;\n  /// Time at which the transfer finished\n  std::chrono::time_point<Clock> endTime_;\n\n  /// Transfer history controller for the sender threads\n  std::unique_ptr<TransferHistoryController> transferHistoryController_;\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "SenderThread.cpp",
          "type": "blob",
          "size": 36.7783203125,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <folly/Conv.h>\n#include <folly/Memory.h>\n#include <folly/String.h>\n#include <folly/hash/Checksum.h>\n#include <folly/lang/Bits.h>\n#include <sys/stat.h>\n#include <wdt/Sender.h>\n#include <wdt/SenderThread.h>\n\nnamespace facebook {\nnamespace wdt {\n\nstd::ostream &operator<<(std::ostream &os, const SenderThread &senderThread) {\n  os << \"Thread[\" << senderThread.threadIndex_\n     << \", port: \" << senderThread.port_ << \"] \";\n  return os;\n}\n\nconst SenderThread::StateFunction SenderThread::stateMap_[] = {\n    &SenderThread::connect,         &SenderThread::readLocalCheckPoint,\n    &SenderThread::sendSettings,    &SenderThread::sendBlocks,\n    &SenderThread::sendDoneCmd,     &SenderThread::sendSizeCmd,\n    &SenderThread::checkForAbort,   &SenderThread::readFileChunks,\n    &SenderThread::readReceiverCmd, &SenderThread::processDoneCmd,\n    &SenderThread::processWaitCmd,  &SenderThread::processErrCmd,\n    &SenderThread::processAbortCmd, &SenderThread::processVersionMismatch};\n\nstd::unique_ptr<IClientSocket> SenderThread::connectToReceiver(\n    const int port, IAbortChecker const * /*abortChecker*/,\n    ErrorCode &errCode) {\n  auto startTime = Clock::now();\n  int connectAttempts = 0;\n  std::unique_ptr<IClientSocket> socket;\n  const EncryptionParams &encryptionData =\n      wdtParent_->transferRequest_.encryptionData;\n  int64_t ivChangeInterval = wdtParent_->transferRequest_.ivChangeInterval;\n  if (threadProtocolVersion_ <\n      Protocol::PERIODIC_ENCRYPTION_IV_CHANGE_VERSION) {\n    WTLOG(WARNING) << \"Disabling periodic iv change for sender with version \"\n                   << threadProtocolVersion_;\n    ivChangeInterval = 0;\n  }\n\n  if (wdtParent_->socketCreator_) {\n    VLOG(3) << \"Creating sender socket\";\n    socket = wdtParent_->socketCreator_->makeClientSocket(\n        *threadCtx_, wdtParent_->getDestination(), port, encryptionData,\n        ivChangeInterval, wdtParent_->transferRequest_.tls);\n  } else {\n    // socket creator not set, creating ClientSocket\n    VLOG(3) << \"Creating sender socket\";\n    socket = std::make_unique<ClientSocket>(*threadCtx_,\n                                            wdtParent_->getDestination(), port,\n                                            encryptionData, ivChangeInterval);\n  }\n\n  if (!socket) {\n    errCode = ERROR;\n    return nullptr;\n  }\n\n  double retryInterval = options_.sleep_millis;\n  int maxRetries = options_.max_retries;\n  if (maxRetries < 1) {\n    WTLOG(ERROR) << \"Invalid max_retries \" << maxRetries << \" using 1 instead\";\n    maxRetries = 1;\n  }\n  for (int i = 1; i <= maxRetries; ++i) {\n    ++connectAttempts;\n    errCode = socket->connect();\n    if (errCode == OK) {\n      break;\n    } else if (errCode == CONN_ERROR) {\n      return nullptr;\n    }\n    if (getThreadAbortCode() != OK) {\n      errCode = ABORT;\n      return nullptr;\n    }\n    if (i != maxRetries) {\n      // sleep between attempts but not after the last\n      WTVLOG(1) << \"Sleeping after failed attempt \" << i;\n      /* sleep override */ usleep(retryInterval * 1000);\n    }\n  }\n  double elapsedSecsConn = durationSeconds(Clock::now() - startTime);\n  if (errCode != OK) {\n    WTLOG(ERROR) << \"Unable to connect to \" << wdtParent_->getDestination()\n                 << \" \" << port << \" despite \" << connectAttempts\n                 << \" retries in \" << elapsedSecsConn << \" seconds.\";\n    errCode = CONN_ERROR;\n    return nullptr;\n  }\n\n  (connectAttempts > 1) ? WTLOG(WARNING)\n                        : WTLOG(INFO) << \"Connection took \" << connectAttempts\n                                      << \" attempt(s) and \" << elapsedSecsConn\n                                      << \" seconds. port \" << port;\n  return socket;\n}\n\nSenderState SenderThread::connect() {\n  WTVLOG(1) << \"entered CONNECT state\";\n  if (socket_) {\n    ErrorCode socketErrCode = socket_->getNonRetryableErrCode();\n    if (socketErrCode != OK) {\n      WTLOG(ERROR) << \"Socket has non-retryable error \"\n                   << errorCodeToStr(socketErrCode);\n      threadStats_.setLocalErrorCode(socketErrCode);\n      return END;\n    }\n    socket_->closeNoCheck();\n  }\n  if (numReconnectWithoutProgress_ >= options_.max_transfer_retries) {\n    WTLOG(ERROR) << \"Sender thread reconnected \" << numReconnectWithoutProgress_\n                 << \" times without making any progress, giving up. port: \"\n                 << socket_->getPort();\n    threadStats_.setLocalErrorCode(NO_PROGRESS);\n    return END;\n  }\n  ErrorCode code;\n  // TODO cleanup more but for now avoid having 2 socket object live per port\n  socket_ = nullptr;\n  socket_ = connectToReceiver(port_, threadCtx_->getAbortChecker(), code);\n  if (code == ABORT) {\n    threadStats_.setLocalErrorCode(ABORT);\n    if (getThreadAbortCode() == VERSION_MISMATCH) {\n      return PROCESS_VERSION_MISMATCH;\n    }\n    return END;\n  }\n  if (code != OK) {\n    threadStats_.setLocalErrorCode(code);\n    return END;\n  }\n  auto nextState = SEND_SETTINGS;\n  if (threadStats_.getLocalErrorCode() != OK) {\n    nextState = READ_LOCAL_CHECKPOINT;\n  }\n  // resetting the status of thread\n  reset();\n  return nextState;\n}\n\nSenderState SenderThread::readLocalCheckPoint() {\n  WTLOG(INFO) << \"entered READ_LOCAL_CHECKPOINT state\";\n  ThreadTransferHistory &transferHistory = getTransferHistory();\n  std::vector<Checkpoint> checkpoints;\n  int64_t decodeOffset = 0;\n  int checkpointLen =\n      Protocol::getMaxLocalCheckpointLength(threadProtocolVersion_);\n  int64_t numRead = socket_->read(buf_, checkpointLen);\n  if (numRead != checkpointLen) {\n    WTLOG(ERROR) << \"read mismatch during reading local checkpoint \"\n                 << checkpointLen << \" \" << numRead << \" port \" << port_;\n    threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n    numReconnectWithoutProgress_++;\n    return CONNECT;\n  }\n  bool isValidCheckpoint = true;\n  if (!Protocol::decodeCheckpoints(threadProtocolVersion_, buf_, decodeOffset,\n                                   checkpointLen, checkpoints)) {\n    WTLOG(ERROR) << \"checkpoint decode failure \"\n                 << folly::humanify(std::string(buf_, numRead));\n    isValidCheckpoint = false;\n  } else if (checkpoints.size() != 1) {\n    WTLOG(ERROR) << \"Illegal local checkpoint, unexpected num checkpoints \"\n                 << checkpoints.size() << \" \"\n                 << folly::humanify(std::string(buf_, numRead));\n    isValidCheckpoint = false;\n  } else if (checkpoints[0].port != port_) {\n    WTLOG(ERROR) << \"illegal checkpoint, checkpoint \" << checkpoints[0]\n                 << \" doesn't match the port \" << port_;\n    isValidCheckpoint = false;\n  }\n  if (!isValidCheckpoint) {\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return END;\n  }\n  const Checkpoint &checkpoint = checkpoints[0];\n  auto numBlocks = checkpoint.numBlocks;\n  WTVLOG(1) << \"received local checkpoint \" << checkpoint;\n\n  if (numBlocks == -1) {\n    // Receiver failed while sending DONE cmd\n    return READ_RECEIVER_CMD;\n  }\n\n  ErrorCode errCode = transferHistory.setLocalCheckpoint(checkpoint);\n  if (errCode == INVALID_CHECKPOINT) {\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return END;\n  }\n  if (errCode == NO_PROGRESS) {\n    ++numReconnectWithoutProgress_;\n  } else {\n    numReconnectWithoutProgress_ = 0;\n  }\n  return SEND_SETTINGS;\n}\n\nSenderState SenderThread::sendSettings() {\n  WTVLOG(1) << \"entered SEND_SETTINGS state\";\n  int64_t readTimeoutMillis = options_.read_timeout_millis;\n  int64_t writeTimeoutMillis = options_.write_timeout_millis;\n  int64_t off = 0;\n  buf_[off++] = Protocol::SETTINGS_CMD;\n  bool sendFileChunks = wdtParent_->isSendFileChunks();\n  enableHeartBeat_ = false;\n  if (options_.enable_heart_beat) {\n    if (threadProtocolVersion_ < Protocol::HEART_BEAT_VERSION) {\n      WTLOG(INFO) << \"Disabling heart beat because of the receiver version is \"\n                  << threadProtocolVersion_;\n    } else {\n      enableHeartBeat_ = true;\n    }\n  }\n  enableHeartBeat_ = (threadProtocolVersion_ >= Protocol::HEART_BEAT_VERSION &&\n                      options_.enable_heart_beat);\n  Settings settings;\n  settings.readTimeoutMillis = readTimeoutMillis;\n  settings.writeTimeoutMillis = writeTimeoutMillis;\n  settings.transferId = wdtParent_->getTransferId();\n  settings.enableChecksum = (footerType_ == CHECKSUM_FOOTER);\n  settings.sendFileChunks = sendFileChunks;\n  settings.blockModeDisabled = (options_.block_size_mbytes <= 0);\n  settings.enableHeartBeat = enableHeartBeat_;\n  Protocol::encodeSettings(threadProtocolVersion_, buf_, off,\n                           Protocol::kMaxSettings, settings);\n  int64_t toWrite = sendFileChunks ? Protocol::kMinBufLength : off;\n  int64_t written = socket_->write(buf_, toWrite);\n  if (written != toWrite) {\n    WTLOG(ERROR) << \"Socket write failure \" << written << \" \" << toWrite;\n    threadStats_.setLocalErrorCode(SOCKET_WRITE_ERROR);\n    return CONNECT;\n  }\n  threadStats_.addHeaderBytes(toWrite);\n  return (sendFileChunks ? READ_FILE_CHUNKS : SEND_BLOCKS);\n}\n\nconst int kHeartBeatReadTimeFactor = 10;\n\nErrorCode SenderThread::readHeartBeats() {\n  if (!enableHeartBeat_) {\n    return OK;\n  }\n  const auto now = Clock::now();\n  const int timeSinceLastHeartBeatMs = durationMillis(now - lastHeartBeatTime_);\n  const int heartBeatIntervalMs =\n      (options_.read_timeout_millis * kHeartBeatReadTimeFactor);\n  if (timeSinceLastHeartBeatMs <= heartBeatIntervalMs) {\n    return OK;\n  }\n  lastHeartBeatTime_ = now;\n  // time to read heart-beats\n  const int numRead = socket_->read(buf_, bufSize_,\n                                    /* don't try to read all the data */ false);\n  if (numRead <= 0) {\n    WTLOG(ERROR) << \"Failed to read heart-beat \" << numRead;\n    return SOCKET_READ_ERROR;\n  }\n  for (int i = 0; i < numRead; i++) {\n    const char receivedCmd = buf_[i];\n    if (receivedCmd != Protocol::HEART_BEAT_CMD) {\n      WTLOG(ERROR) << \"Received \" << receivedCmd\n                   << \" instead of heart-beat cmd\";\n      return PROTOCOL_ERROR;\n    }\n  }\n  if (!isTty_) {\n    WTLOG(INFO) << \"Received \" << numRead << \" heart-beats\";\n  }\n  return OK;\n}\n\nSenderState SenderThread::sendBlocks() {\n  WTVLOG(1) << \"entered SEND_BLOCKS state\";\n  ThreadTransferHistory &transferHistory = getTransferHistory();\n  if (threadProtocolVersion_ >= Protocol::RECEIVER_PROGRESS_REPORT_VERSION &&\n      !totalSizeSent_ && dirQueue_->fileDiscoveryFinished()) {\n    return SEND_SIZE_CMD;\n  }\n  ErrorCode transferStatus;\n  std::unique_ptr<ByteSource> source =\n      dirQueue_->getNextSource(threadCtx_.get(), transferStatus);\n  if (!source) {\n    // try to read any buffered heart-beats\n    readHeartBeats();\n\n    return SEND_DONE_CMD;\n  }\n  WDT_CHECK(!source->hasError());\n  TransferStats transferStats = sendOneByteSource(source, transferStatus);\n  threadStats_ += transferStats;\n  source->addTransferStats(transferStats);\n  source->close();\n  if (!transferHistory.addSource(source)) {\n    // global checkpoint received for this thread. no point in\n    // continuing\n    WTLOG(ERROR) << \"global checkpoint received. Stopping\";\n    threadStats_.setLocalErrorCode(CONN_ERROR);\n    return END;\n  }\n  if (transferStats.getLocalErrorCode() != OK) {\n    return CHECK_FOR_ABORT;\n  }\n  return SEND_BLOCKS;\n}\n\nTransferStats SenderThread::sendOneByteSource(\n    const std::unique_ptr<ByteSource> &source, ErrorCode transferStatus) {\n  TransferStats stats;\n  char headerBuf[Protocol::kMaxHeader];\n  int64_t off = 0;\n  headerBuf[off++] = Protocol::FILE_CMD;\n  headerBuf[off++] = transferStatus;\n  char *headerLenPtr = headerBuf + off;\n  off += sizeof(int16_t);\n  const int64_t expectedSize = source->getSize();\n  int64_t actualSize = 0;\n  const SourceMetaData &metadata = source->getMetaData();\n  BlockDetails blockDetails;\n  blockDetails.fileName = metadata.relPath;\n  blockDetails.seqId = metadata.seqId;\n  blockDetails.fileSize = metadata.size;\n  blockDetails.offset = source->getOffset();\n  blockDetails.dataSize = expectedSize;\n  blockDetails.allocationStatus = metadata.allocationStatus;\n  blockDetails.prevSeqId = metadata.prevSeqId;\n  Protocol::encodeHeader(wdtParent_->getProtocolVersion(), headerBuf, off,\n                         Protocol::kMaxHeader, blockDetails);\n  int16_t littleEndianOff = folly::Endian::little((int16_t)off);\n  folly::storeUnaligned<int16_t>(headerLenPtr, littleEndianOff);\n  int64_t written = socket_->write(headerBuf, off);\n  if (written != off) {\n    WTPLOG(ERROR) << \"Write error/mismatch \" << written << \" \" << off\n                  << \". fd = \" << socket_->getFd()\n                  << \". file = \" << metadata.relPath\n                  << \". port = \" << socket_->getPort();\n    stats.setLocalErrorCode(SOCKET_WRITE_ERROR);\n    stats.incrFailedAttempts();\n    return stats;\n  }\n\n  stats.addHeaderBytes(written);\n  int64_t byteSourceHeaderBytes = written;\n  int64_t throttlerInstanceBytes = byteSourceHeaderBytes;\n  int64_t totalThrottlerBytes = 0;\n  WTVLOG(3) << \"Sent \" << written << \" on \" << socket_->getFd() << \" : \"\n            << folly::humanify(std::string(headerBuf, off));\n  int32_t checksum = 0;\n  while (!source->finished()) {\n    // TODO: handle protocol errors from readHeartBeats\n    readHeartBeats();\n\n    int64_t size;\n    char *buffer = source->read(size);\n    if (source->hasError()) {\n      WTLOG(ERROR) << \"Failed reading file \" << source->getIdentifier()\n                   << \" for fd \" << socket_->getFd();\n      break;\n    }\n    WDT_CHECK(buffer && size > 0);\n    if (footerType_ == CHECKSUM_FOOTER) {\n      checksum = folly::crc32c((const uint8_t *)buffer, size, checksum);\n    }\n    if (wdtParent_->getThrottler()) {\n      /**\n       * If throttling is enabled we call limit(deltaBytes) which\n       * used both the methods of throttling peak and average.\n       * Always call it with bytes being written to the wire, throttler\n       * will do the rest.\n       * The first time throttle is called with the header bytes\n       * included. In the next iterations throttler is only called\n       * with the bytes being written.\n       */\n      throttlerInstanceBytes += size;\n      wdtParent_->getThrottler()->limit(*threadCtx_, throttlerInstanceBytes);\n      totalThrottlerBytes += throttlerInstanceBytes;\n      throttlerInstanceBytes = 0;\n    }\n    written = socket_->write(buffer, size, /* retry writes */ true);\n    if (getThreadAbortCode() != OK) {\n      WTLOG(ERROR) << \"Transfer aborted during block transfer \"\n                   << socket_->getPort() << \" \" << source->getIdentifier();\n      stats.setLocalErrorCode(ABORT);\n      stats.incrFailedAttempts();\n      return stats;\n    }\n    if (written != size) {\n      WTLOG(ERROR) << \"Write error \" << written << \" (\" << size << \")\"\n                   << \". fd = \" << socket_->getFd()\n                   << \". file = \" << metadata.relPath\n                   << \". port = \" << socket_->getPort();\n      stats.setLocalErrorCode(SOCKET_WRITE_ERROR);\n      stats.incrFailedAttempts();\n      return stats;\n    }\n    stats.addDataBytes(written);\n    actualSize += written;\n  }\n  if (actualSize != expectedSize) {\n    // Can only happen if sender thread can not read complete source byte\n    // stream\n    WTLOG(ERROR) << \"UGH \" << source->getIdentifier() << \" \" << expectedSize\n                 << \" \" << actualSize;\n    struct stat fileStat;\n    if (stat(metadata.fullPath.c_str(), &fileStat) != 0) {\n      WTPLOG(ERROR) << \"stat failed on path \" << metadata.fullPath;\n    } else {\n      WTLOG(WARNING) << \"file \" << source->getIdentifier() << \" previous size \"\n                     << metadata.size << \" current size \" << fileStat.st_size;\n    }\n    stats.setLocalErrorCode(BYTE_SOURCE_READ_ERROR);\n    stats.incrFailedAttempts();\n    return stats;\n  }\n  if (wdtParent_->getThrottler() && actualSize > 0) {\n    WDT_CHECK(totalThrottlerBytes == actualSize + byteSourceHeaderBytes)\n        << totalThrottlerBytes << \" \" << (actualSize + totalThrottlerBytes);\n  }\n  if (footerType_ != NO_FOOTER) {\n    off = 0;\n    headerBuf[off++] = Protocol::FOOTER_CMD;\n    Protocol::encodeFooter(headerBuf, off, Protocol::kMaxFooter, checksum);\n    int toWrite = off;\n    written = socket_->write(headerBuf, toWrite);\n    if (written != toWrite) {\n      WTLOG(ERROR) << \"Write mismatch \" << written << \" \" << toWrite;\n      stats.setLocalErrorCode(SOCKET_WRITE_ERROR);\n      stats.incrFailedAttempts();\n      return stats;\n    }\n    stats.addHeaderBytes(toWrite);\n  }\n  stats.setLocalErrorCode(OK);\n  stats.incrNumBlocks();\n  stats.addEffectiveBytes(stats.getHeaderBytes(), stats.getDataBytes());\n  return stats;\n}\n\nSenderState SenderThread::sendSizeCmd() {\n  WTVLOG(1) << \"entered SEND_SIZE_CMD state\";\n  int64_t off = 0;\n  buf_[off++] = Protocol::SIZE_CMD;\n\n  Protocol::encodeSize(buf_, off, Protocol::kMaxSize,\n                       dirQueue_->getTotalSize());\n  int64_t written = socket_->write(buf_, off);\n  if (written != off) {\n    WTLOG(ERROR) << \"Socket write error \" << off << \" \" << written;\n    threadStats_.setLocalErrorCode(SOCKET_WRITE_ERROR);\n    return CHECK_FOR_ABORT;\n  }\n  threadStats_.addHeaderBytes(off);\n  totalSizeSent_ = true;\n  return SEND_BLOCKS;\n}\n\nSenderState SenderThread::sendDoneCmd() {\n  WTVLOG(1) << \"entered SEND_DONE_CMD state\";\n\n  int64_t off = 0;\n  buf_[off++] = Protocol::DONE_CMD;\n  auto pair = dirQueue_->getNumBlocksAndStatus();\n  int64_t numBlocksDiscovered = pair.first;\n  ErrorCode transferStatus = pair.second;\n  buf_[off++] = transferStatus;\n  Protocol::encodeDone(threadProtocolVersion_, buf_, off, Protocol::kMaxDone,\n                       numBlocksDiscovered, dirQueue_->getTotalSize());\n  int toWrite = Protocol::kMinBufLength;\n  int64_t written = socket_->write(buf_, toWrite);\n  if (written != toWrite) {\n    WTLOG(ERROR) << \"Socket write failure \" << written << \" \" << toWrite;\n    threadStats_.setLocalErrorCode(SOCKET_WRITE_ERROR);\n    return CHECK_FOR_ABORT;\n  }\n  threadStats_.addHeaderBytes(toWrite);\n  WTVLOG(1) << \"Wrote done cmd on \" << socket_->getFd()\n            << \" waiting for reply...\";\n  return READ_RECEIVER_CMD;\n}\n\nSenderState SenderThread::checkForAbort() {\n  WTLOG(INFO) << \"entered CHECK_FOR_ABORT state\";\n  auto numRead = socket_->read(buf_, 1);\n  if (numRead != 1) {\n    WTVLOG(1) << \"No abort cmd found\";\n    return CONNECT;\n  }\n  Protocol::CMD_MAGIC cmd = (Protocol::CMD_MAGIC)buf_[0];\n  if (cmd != Protocol::ABORT_CMD) {\n    WTVLOG(1) << \"Unexpected result found while reading for abort \" << buf_[0];\n    return CONNECT;\n  }\n  threadStats_.addHeaderBytes(1);\n  return PROCESS_ABORT_CMD;\n}\n\nSenderState SenderThread::readFileChunks() {\n  WTLOG(INFO) << \"entered READ_FILE_CHUNKS state \";\n  int64_t numRead = socket_->read(buf_, 1);\n  if (numRead != 1) {\n    WTLOG(ERROR) << \"Socket read error 1 \" << numRead;\n    threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n    return CHECK_FOR_ABORT;\n  }\n  threadStats_.addHeaderBytes(numRead);\n  Protocol::CMD_MAGIC cmd = (Protocol::CMD_MAGIC)buf_[0];\n  if (cmd == Protocol::ABORT_CMD) {\n    return PROCESS_ABORT_CMD;\n  }\n  if (cmd == Protocol::WAIT_CMD) {\n    return READ_FILE_CHUNKS;\n  }\n  if (cmd == Protocol::ACK_CMD) {\n    if (!wdtParent_->isFileChunksReceived()) {\n      WTLOG(ERROR) << \"Sender has not yet received file chunks, but receiver \"\n                   << \"thinks it has already sent it\";\n      threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n      return END;\n    }\n    return SEND_BLOCKS;\n  }\n  if (cmd == Protocol::LOCAL_CHECKPOINT_CMD) {\n    ErrorCode errCode = readAndVerifySpuriousCheckpoint();\n    if (errCode == SOCKET_READ_ERROR) {\n      return CONNECT;\n    }\n    if (errCode == PROTOCOL_ERROR) {\n      return END;\n    }\n    WDT_CHECK_EQ(OK, errCode);\n    return READ_FILE_CHUNKS;\n  }\n  if (cmd != Protocol::CHUNKS_CMD) {\n    WTLOG(ERROR) << \"Unexpected cmd \" << cmd;\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return END;\n  }\n  int64_t toRead = Protocol::kChunksCmdLen;\n  numRead = socket_->read(buf_, toRead);\n  if (numRead != toRead) {\n    WTLOG(ERROR) << \"Socket read error \" << toRead << \" \" << numRead;\n    threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n    return CHECK_FOR_ABORT;\n  }\n  threadStats_.addHeaderBytes(numRead);\n  int64_t off = 0;\n  int64_t bufSize, numFiles;\n  Protocol::decodeChunksCmd(buf_, off, bufSize_, bufSize, numFiles);\n  WTLOG(INFO) << \"File chunk list has \" << numFiles\n              << \" entries and is broken in buffers of length \" << bufSize;\n  if (bufSize < 0 || numFiles < 0) {\n    WLOG(ERROR) << \"Decoded bogus size for file chunks list bufSize = \"\n                << bufSize << \" num files \" << numFiles;\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return END;\n  }\n  std::unique_ptr<char[]> chunkBuffer(new char[bufSize]);\n  std::vector<FileChunksInfo> fileChunksInfoList;\n  while (true) {\n    int64_t numFileChunks = fileChunksInfoList.size();\n    if (numFileChunks > numFiles) {\n      // We should never be able to read more file chunks than mentioned in the\n      // chunks cmd. Chunks cmd has buffer size used to transfer chunks and also\n      // number of chunks. This chunks are read and parsed and added to\n      // fileChunksInfoList. Number of chunks we decode should match with the\n      // number mentioned in the Chunks cmd.\n      WTLOG(ERROR) << \"Number of file chunks received is more than the number \"\n                      \"mentioned in CHUNKS_CMD \"\n                   << numFileChunks << \" \" << numFiles;\n      threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n      return END;\n    }\n    if (numFileChunks == numFiles) {\n      break;\n    }\n    toRead = sizeof(int32_t);\n    numRead = socket_->read(buf_, toRead);\n    if (numRead != toRead) {\n      WTLOG(ERROR) << \"Socket read error \" << toRead << \" \" << numRead;\n      threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n      return CHECK_FOR_ABORT;\n    }\n    toRead = folly::loadUnaligned<int32_t>(buf_);\n    toRead = folly::Endian::little(toRead);\n    numRead = socket_->read(chunkBuffer.get(), toRead);\n    if (numRead != toRead) {\n      WTLOG(ERROR) << \"Socket read error \" << toRead << \" \" << numRead;\n      threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n      return CHECK_FOR_ABORT;\n    }\n    threadStats_.addHeaderBytes(numRead);\n    off = 0;\n    // decode function below adds decoded file chunks to fileChunksInfoList\n    bool success = Protocol::decodeFileChunksInfoList(\n        chunkBuffer.get(), off, toRead, fileChunksInfoList);\n    if (!success) {\n      WTLOG(ERROR) << \"Unable to decode file chunks list\";\n      threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n      return END;\n    }\n  }\n  wdtParent_->setFileChunksInfo(fileChunksInfoList);\n  // send ack for file chunks list\n  buf_[0] = Protocol::ACK_CMD;\n  int64_t toWrite = 1;\n  int64_t written = socket_->write(buf_, toWrite);\n  if (toWrite != written) {\n    WTLOG(ERROR) << \"Socket write error \" << toWrite << \" \" << written;\n    threadStats_.setLocalErrorCode(SOCKET_WRITE_ERROR);\n    return CHECK_FOR_ABORT;\n  }\n  threadStats_.addHeaderBytes(written);\n  return SEND_BLOCKS;\n}\n\nErrorCode SenderThread::readNextReceiverCmd() {\n  int numUnackedBytes = socket_->getUnackedBytes();\n  int timeToClearSendBuffer = 0;\n  Clock::time_point startTime = Clock::now();\n  while (true) {\n    int numRead = socket_->read(buf_, 1);\n    if (numRead == 1) {\n      return OK;\n    }\n    if (getThreadAbortCode() != OK) {\n      return ABORT;\n    }\n    if (numRead == 0) {\n      WTPLOG(ERROR) << \"Got unexpected EOF, reconnecting\";\n      return SOCKET_READ_ERROR;\n    }\n    WDT_CHECK_LT(numRead, 0);\n    ErrorCode errCode = socket_->getReadErrCode();\n    WTLOG(ERROR) << \"Failed to read receiver cmd \" << numRead << \" \"\n                 << errorCodeToStr(errCode);\n    if (errCode != WDT_TIMEOUT) {\n      // not timed out\n      return SOCKET_READ_ERROR;\n    }\n    int curUnackedBytes = socket_->getUnackedBytes();\n    if (numUnackedBytes < 0 || curUnackedBytes < 0) {\n      WTLOG(ERROR) << \"Failed to read number of unacked bytes, reconnecting\";\n      return SOCKET_READ_ERROR;\n    }\n    WDT_CHECK_GE(numUnackedBytes, curUnackedBytes);\n    if (curUnackedBytes == 0) {\n      timeToClearSendBuffer = durationMillis(Clock::now() - startTime);\n      break;\n    }\n    if (curUnackedBytes == numUnackedBytes) {\n      WTLOG(ERROR) << \"Number of unacked bytes did not change, reconnecting \"\n                   << curUnackedBytes;\n      return SOCKET_READ_ERROR;\n    }\n    WTLOG(INFO) << \"Read receiver command failed, but number of unacked \"\n                   \"bytes decreased, retrying socket read \"\n                << numUnackedBytes << \" \" << curUnackedBytes;\n    numUnackedBytes = curUnackedBytes;\n  }\n  // we are assuming that sender and receiver tcp buffer sizes are same. So, we\n  // expect another timeToClearSendBuffer milliseconds for receiver to clear its\n  // buffer\n  int readTimeout = timeToClearSendBuffer + options_.drain_extra_ms;\n  WTLOG(INFO) << \"Send buffer cleared in \" << timeToClearSendBuffer\n              << \"ms, waiting for \" << readTimeout\n              << \"ms for receiver buffer to clear\";\n  // readWithTimeout internally checks for abort periodically\n  int numRead = socket_->readWithTimeout(buf_, 1, readTimeout);\n  if (numRead != 1) {\n    WTLOG(ERROR) << \"Failed to read receiver cmd \" << numRead;\n    return SOCKET_READ_ERROR;\n  }\n  return OK;\n}\n\nSenderState SenderThread::readReceiverCmd() {\n  WTVLOG(1) << \"entered READ_RECEIVER_CMD state\";\n\n  ErrorCode errCode = readNextReceiverCmd();\n  if (errCode != OK) {\n    threadStats_.setLocalErrorCode(errCode);\n    return CONNECT;\n  }\n  Protocol::CMD_MAGIC cmd = (Protocol::CMD_MAGIC)buf_[0];\n  if (cmd == Protocol::ERR_CMD) {\n    return PROCESS_ERR_CMD;\n  }\n  if (cmd == Protocol::WAIT_CMD) {\n    return PROCESS_WAIT_CMD;\n  }\n  if (cmd == Protocol::DONE_CMD) {\n    return PROCESS_DONE_CMD;\n  }\n  if (cmd == Protocol::ABORT_CMD) {\n    return PROCESS_ABORT_CMD;\n  }\n  if (cmd == Protocol::LOCAL_CHECKPOINT_CMD) {\n    errCode = readAndVerifySpuriousCheckpoint();\n    if (errCode == SOCKET_READ_ERROR) {\n      return CONNECT;\n    }\n    if (errCode == PROTOCOL_ERROR) {\n      return END;\n    }\n    WDT_CHECK_EQ(OK, errCode);\n    return READ_RECEIVER_CMD;\n  }\n  if (cmd == Protocol::HEART_BEAT_CMD) {\n    return READ_RECEIVER_CMD;\n  }\n  WTLOG(ERROR) << \"Read unexpected receiver cmd \" << cmd << \" port \" << port_;\n  threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n  return END;\n}\n\nErrorCode SenderThread::readAndVerifySpuriousCheckpoint() {\n  int checkpointLen =\n      Protocol::getMaxLocalCheckpointLength(threadProtocolVersion_);\n  int64_t toRead = checkpointLen - 1;\n  int numRead = socket_->read(buf_ + 1, toRead);\n  if (numRead != toRead) {\n    WTLOG(ERROR) << \"Could not read possible local checkpoint \" << toRead << \" \"\n                 << numRead << \" \" << port_;\n    threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n    return SOCKET_READ_ERROR;\n  }\n  int64_t offset = 0;\n  std::vector<Checkpoint> checkpoints;\n  if (Protocol::decodeCheckpoints(threadProtocolVersion_, buf_, offset,\n                                  checkpointLen, checkpoints)) {\n    if (checkpoints.size() == 1 && checkpoints[0].port == port_ &&\n        checkpoints[0].numBlocks == 0 &&\n        checkpoints[0].lastBlockReceivedBytes == 0) {\n      // In a spurious local checkpoint, number of blocks and offset must both\n      // be zero\n      // Ignore the checkpoint\n      WTLOG(WARNING)\n          << \"Received valid but unexpected local checkpoint, ignoring \"\n          << port_ << \" checkpoint \" << checkpoints[0];\n      return OK;\n    }\n  }\n  WTLOG(ERROR) << \"Failed to verify spurious local checkpoint, port \" << port_\n               << \" numRead \" << numRead << \" chkptsz \" << checkpoints.size()\n               << \" chkplen \" << checkpointLen;\n  threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n  return PROTOCOL_ERROR;\n}\n\nSenderState SenderThread::processDoneCmd() {\n  WTVLOG(1) << \"entered PROCESS_DONE_CMD state\";\n  // DONE cmd implies that all the blocks sent till now is acked\n  ThreadTransferHistory &transferHistory = getTransferHistory();\n  transferHistory.markAllAcknowledged();\n\n  // send ack for DONE\n  buf_[0] = Protocol::DONE_CMD;\n  socket_->write(buf_, 1);\n\n  socket_->shutdownWrites();\n  ErrorCode retCode = socket_->expectEndOfStream();\n  if (retCode != OK) {\n    WTLOG(WARNING) << \"Logical EOF not found when expected \"\n                   << errorCodeToStr(retCode);\n    threadStats_.setLocalErrorCode(retCode);\n    return CONNECT;\n  }\n  WTVLOG(1) << \"done with transfer, port \" << port_;\n  return END;\n}\n\nSenderState SenderThread::processWaitCmd() {\n  WTLOG(INFO) << \"entered PROCESS_WAIT_CMD state \";\n  // similar to DONE, WAIT also verifies all the blocks\n  ThreadTransferHistory &transferHistory = getTransferHistory();\n  transferHistory.markAllAcknowledged();\n  WTVLOG(1) << \"received WAIT_CMD, port \" << port_;\n  return READ_RECEIVER_CMD;\n}\n\nSenderState SenderThread::processErrCmd() {\n  WTLOG(INFO) << \"entered PROCESS_ERR_CMD state\";\n  // similar to DONE, global checkpoint cmd also verifies all the blocks\n  ThreadTransferHistory &transferHistory = getTransferHistory();\n  transferHistory.markAllAcknowledged();\n  int64_t toRead = sizeof(int16_t);\n  int64_t numRead = socket_->read(buf_, toRead);\n  if (numRead != toRead) {\n    WTLOG(ERROR) << \"read unexpected \" << toRead << \" \" << numRead;\n    threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n    return CONNECT;\n  }\n\n  int16_t checkpointsLen = folly::loadUnaligned<int16_t>(buf_);\n  checkpointsLen = folly::Endian::little(checkpointsLen);\n  char checkpointBuf[checkpointsLen];\n  numRead = socket_->read(checkpointBuf, checkpointsLen);\n  if (numRead != checkpointsLen) {\n    WTLOG(ERROR) << \"read unexpected \" << checkpointsLen << \" \" << numRead;\n    threadStats_.setLocalErrorCode(SOCKET_READ_ERROR);\n    return CONNECT;\n  }\n\n  std::vector<Checkpoint> checkpoints;\n  int64_t decodeOffset = 0;\n  if (!Protocol::decodeCheckpoints(threadProtocolVersion_, checkpointBuf,\n                                   decodeOffset, checkpointsLen, checkpoints)) {\n    WTLOG(ERROR) << \"checkpoint decode failure \"\n                 << folly::humanify(std::string(checkpointBuf, checkpointsLen));\n    threadStats_.setLocalErrorCode(PROTOCOL_ERROR);\n    return END;\n  }\n  for (auto &checkpoint : checkpoints) {\n    WTLOG(INFO) << \"Received global checkpoint \" << checkpoint;\n    transferHistoryController_->handleGlobalCheckpoint(checkpoint);\n  }\n  return SEND_BLOCKS;\n}\n\nSenderState SenderThread::processAbortCmd() {\n  WTLOG(INFO) << \"entered PROCESS_ABORT_CMD state \";\n  ThreadTransferHistory &transferHistory = getTransferHistory();\n  threadStats_.setLocalErrorCode(ABORT);\n  int toRead = Protocol::kAbortLength;\n  auto numRead = socket_->read(buf_, toRead);\n  if (numRead != toRead) {\n    // can not read checkpoint, but still must exit because of ABORT\n    WTLOG(ERROR) << \"Error while trying to read ABORT cmd \" << numRead << \" \"\n                 << toRead;\n    return END;\n  }\n  int64_t offset = 0;\n  int32_t negotiatedProtocol;\n  ErrorCode remoteError;\n  int64_t checkpoint;\n  Protocol::decodeAbort(buf_, offset, bufSize_, negotiatedProtocol, remoteError,\n                        checkpoint);\n  threadStats_.setRemoteErrorCode(remoteError);\n  std::string failedFileName = transferHistory.getSourceId(checkpoint);\n  WTLOG(WARNING) << \"Received abort on \" << \" remote protocol version \"\n                 << negotiatedProtocol << \" remote error code \"\n                 << errorCodeToStr(remoteError) << \" file \" << failedFileName\n                 << \" checkpoint \" << checkpoint;\n  wdtParent_->abort(remoteError);\n  if (remoteError == VERSION_MISMATCH) {\n    if (Protocol::negotiateProtocol(\n            negotiatedProtocol, threadProtocolVersion_) == negotiatedProtocol) {\n      // sender can support this negotiated version\n      negotiatedProtocol_ = negotiatedProtocol;\n      return PROCESS_VERSION_MISMATCH;\n    } else {\n      WTLOG(ERROR) << \"Sender can not support receiver version \"\n                   << negotiatedProtocol;\n      threadStats_.setRemoteErrorCode(VERSION_INCOMPATIBLE);\n    }\n  }\n  return END;\n}\n\nSenderState SenderThread::processVersionMismatch() {\n  WTLOG(INFO) << \"entered PROCESS_VERSION_MISMATCH state \";\n  WDT_CHECK(threadStats_.getLocalErrorCode() == ABORT);\n  auto negotiationStatus = wdtParent_->getNegotiationStatus();\n  WDT_CHECK_NE(negotiationStatus, V_MISMATCH_FAILED)\n      << \"Thread should have ended in case of version mismatch\";\n  if (negotiationStatus == V_MISMATCH_RESOLVED) {\n    WTLOG(WARNING) << \"Protocol version already negotiated, but \"\n                      \"transfer still aborted due to version mismatch\";\n    return END;\n  }\n  WDT_CHECK_EQ(negotiationStatus, V_MISMATCH_WAIT);\n  // Need a barrier here to make sure all the negotiated protocol versions\n  // have been collected\n  auto barrier = controller_->getBarrier(VERSION_MISMATCH_BARRIER);\n  barrier->execute();\n  WTVLOG(1) << \"cleared the protocol version barrier\";\n  auto execFunnel = controller_->getFunnel(VERSION_MISMATCH_FUNNEL);\n  while (true) {\n    auto status = execFunnel->getStatus();\n    switch (status) {\n      case FUNNEL_START: {\n        WTLOG(INFO) << \"started the funnel for version mismatch\";\n        wdtParent_->setProtoNegotiationStatus(V_MISMATCH_FAILED);\n        if (transferHistoryController_->handleVersionMismatch() != OK) {\n          execFunnel->notifySuccess();\n          return END;\n        }\n        int negotiatedProtocol = 0;\n        for (int threadProtocolVersion : wdtParent_->getNegotiatedProtocols()) {\n          if (threadProtocolVersion > 0) {\n            if (negotiatedProtocol > 0 &&\n                negotiatedProtocol != threadProtocolVersion) {\n              WTLOG(ERROR)\n                  << \"Different threads negotiated different protocols \"\n                  << negotiatedProtocol << \" \" << threadProtocolVersion;\n              execFunnel->notifySuccess();\n              return END;\n            }\n            negotiatedProtocol = threadProtocolVersion;\n          }\n        }\n        WDT_CHECK_GT(negotiatedProtocol, 0);\n        WLOG_IF(INFO, negotiatedProtocol != threadProtocolVersion_)\n            << *this << \" Changing protocol version to \" << negotiatedProtocol\n            << \", previous version \" << threadProtocolVersion_;\n        wdtParent_->setProtocolVersion(negotiatedProtocol);\n        threadProtocolVersion_ = wdtParent_->getProtocolVersion();\n        setFooterType();\n        threadStats_.setRemoteErrorCode(OK);\n        wdtParent_->setProtoNegotiationStatus(V_MISMATCH_RESOLVED);\n        wdtParent_->clearAbort();\n        execFunnel->notifySuccess();\n        return CONNECT;\n      }\n      case FUNNEL_PROGRESS: {\n        execFunnel->wait();\n        break;\n      }\n      case FUNNEL_END: {\n        negotiationStatus = wdtParent_->getNegotiationStatus();\n        WDT_CHECK_NE(negotiationStatus, V_MISMATCH_WAIT);\n        if (negotiationStatus == V_MISMATCH_FAILED) {\n          return END;\n        }\n        if (negotiationStatus == V_MISMATCH_RESOLVED) {\n          threadProtocolVersion_ = wdtParent_->getProtocolVersion();\n          threadStats_.setRemoteErrorCode(OK);\n          return CONNECT;\n        }\n      }\n    }\n  }\n}\n\nvoid SenderThread::setFooterType() {\n  const int protocolVersion = wdtParent_->getProtocolVersion();\n  if (protocolVersion >= Protocol::CHECKSUM_VERSION &&\n      options_.enable_checksum) {\n    footerType_ = CHECKSUM_FOOTER;\n  } else {\n    footerType_ = NO_FOOTER;\n  }\n}\n\nvoid SenderThread::start() {\n  Clock::time_point startTime = Clock::now();\n\n  if (buf_ == nullptr) {\n    WTLOG(ERROR) << \"Unable to allocate buffer\";\n    threadStats_.setLocalErrorCode(MEMORY_ALLOCATION_ERROR);\n    return;\n  }\n\n  setFooterType();\n\n  controller_->executeAtStart([&]() { wdtParent_->startNewTransfer(); });\n  SenderState state = CONNECT;\n\n  while (state != END) {\n    ErrorCode abortCode = getThreadAbortCode();\n    if (abortCode != OK) {\n      WTLOG(ERROR) << \"Transfer aborted \" << errorCodeToStr(abortCode);\n      threadStats_.setLocalErrorCode(ABORT);\n      if (abortCode == VERSION_MISMATCH) {\n        state = PROCESS_VERSION_MISMATCH;\n      } else {\n        break;\n      }\n    }\n    state = (this->*stateMap_[state])();\n  }\n\n  threadStats_.setTls(wdtParent_->transferRequest_.tls);\n  EncryptionType encryptionType =\n      (socket_ ? socket_->getEncryptionType() : ENC_NONE);\n  threadStats_.setEncryptionType(encryptionType);\n  double totalTime = durationSeconds(Clock::now() - startTime);\n  WTLOG(INFO) << \"Port \" << port_ << \" done. \" << threadStats_\n              << \" Total throughput = \"\n              << threadStats_.getEffectiveTotalBytes() / totalTime / kMbToB\n              << \" Mbytes/sec\";\n\n  ThreadTransferHistory &transferHistory = getTransferHistory();\n  transferHistory.markNotInUse();\n  controller_->deRegisterThread(threadIndex_);\n  controller_->executeAtEnd([&]() { wdtParent_->endCurTransfer(); });\n  // Important to delete the socket before the thread dies for sub class\n  // of clientsocket which have thread local data\n  socket_ = nullptr;\n\n  return;\n}\n\nint SenderThread::getPort() const {\n  return port_;\n}\n\nint SenderThread::getNegotiatedProtocol() const {\n  return negotiatedProtocol_;\n}\n\nErrorCode SenderThread::init() {\n  return OK;\n}\n\nvoid SenderThread::reset() {\n  totalSizeSent_ = false;\n  threadStats_.setLocalErrorCode(OK);\n}\n\nErrorCode SenderThread::getThreadAbortCode() {\n  ErrorCode globalAbortCode = wdtParent_->getCurAbortCode();\n  if (globalAbortCode != OK) {\n    return globalAbortCode;\n  }\n  if (getTransferHistory().isGlobalCheckpointReceived()) {\n    return GLOBAL_CHECKPOINT_ABORT;\n  }\n  return OK;\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "SenderThread.h",
          "type": "blob",
          "size": 10.0771484375,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n#include <folly/Conv.h>\n#include <wdt/Sender.h>\n#include <wdt/WdtThread.h>\n#include <wdt/util/IClientSocket.h>\n#include <wdt/util/ThreadTransferHistory.h>\n\n#include <thread>\n\nnamespace facebook {\nnamespace wdt {\n\nclass DirectorySourceQueue;\n\n/// state machine states\nenum SenderState {\n  CONNECT,\n  READ_LOCAL_CHECKPOINT,\n  SEND_SETTINGS,\n  SEND_BLOCKS,\n  SEND_DONE_CMD,\n  SEND_SIZE_CMD,\n  CHECK_FOR_ABORT,\n  READ_FILE_CHUNKS,\n  READ_RECEIVER_CMD,\n  PROCESS_DONE_CMD,\n  PROCESS_WAIT_CMD,\n  PROCESS_ERR_CMD,\n  PROCESS_ABORT_CMD,\n  PROCESS_VERSION_MISMATCH,\n  END\n};\n\n/**\n * This class represents one sender thread. It contains all the\n * functionalities that a thread would need to send data over\n * a connection to the receiver.\n * All the sender threads share bunch of modules like directory queue,\n * throttler, threads controller etc\n */\nclass SenderThread : public WdtThread {\n public:\n  /// Identifers for the barriers used in the thread\n  enum SENDER_BARRIERS { VERSION_MISMATCH_BARRIER, NUM_BARRIERS };\n\n  /// Identifiers for the funnels used in the thread\n  enum SENDER_FUNNELS { VERSION_MISMATCH_FUNNEL, NUM_FUNNELS };\n\n  /// Identifier for the condition wrappers used in the thread\n  enum SENDER_CONDITIONS { NUM_CONDITIONS };\n\n  /// abort checker passed to client sockets. This checks both global sender\n  /// abort and whether global checkpoint has been received or not\n  class SocketAbortChecker : public IAbortChecker {\n   public:\n    explicit SocketAbortChecker(SenderThread *threadPtr)\n        : threadPtr_(threadPtr) {\n    }\n\n    bool shouldAbort() const override {\n      return (threadPtr_->getThreadAbortCode() != OK);\n    }\n\n   private:\n    SenderThread *threadPtr_{nullptr};\n  };\n\n  /// Constructor for the sender thread\n  SenderThread(Sender *sender, int threadIndex, int32_t port,\n               ThreadsController *threadsController)\n      : WdtThread(sender->options_, threadIndex, port,\n                  sender->getProtocolVersion(), threadsController),\n        wdtParent_(sender),\n        dirQueue_(sender->dirQueue_.get()),\n        transferHistoryController_(sender->transferHistoryController_.get()) {\n    controller_->registerThread(threadIndex_);\n    transferHistoryController_->addThreadHistory(port_, threadStats_);\n    threadAbortChecker_ = std::make_unique<SocketAbortChecker>(this);\n    threadCtx_->setAbortChecker(threadAbortChecker_.get());\n    threadStats_.setId(folly::to<std::string>(threadIndex_));\n    isTty_ = isatty(STDERR_FILENO);\n  }\n\n  typedef SenderState (SenderThread::*StateFunction)();\n\n  /// Returns the neogtiated protocol\n  int getNegotiatedProtocol() const override;\n\n  /// Steps to do ebfore calling start\n  ErrorCode init() override;\n\n  /// Reset the sender thread\n  void reset() override;\n\n  /// Get the port sender thread is connecting to\n  int getPort() const override;\n\n  /// returns current abort code. checks for both global abort and abort due to\n  /// receive of global checkpoint\n  ErrorCode getThreadAbortCode();\n\n  /// Destructor of the sender thread\n  ~SenderThread() override {\n  }\n\n private:\n  /// Overloaded operator for printing thread info\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const SenderThread &senderThread);\n\n  /// Parent shared among all the threads for meta information\n  Sender *wdtParent_;\n\n  /// sets the correct footer type depending on the checksum and encryption type\n  void setFooterType();\n\n  /// The main entry point of the thread\n  void start() override;\n\n  /// Get the local transfer history\n  ThreadTransferHistory &getTransferHistory() {\n    return transferHistoryController_->getTransferHistory(port_);\n  }\n\n  /**\n   * tries to connect to the receiver\n   * Previous states : Almost all states(in case of network errors, all states\n   *                   move to this state)\n   * Next states : SEND_SETTINGS(if there is no previous error)\n   *               READ_LOCAL_CHECKPOINT(if there is previous error)\n   *               END(failed)\n   */\n  SenderState connect();\n  /**\n   * tries to read local checkpoint and return unacked sources to queue. If the\n   * checkpoint value is -1, then we know previous attempt to send DONE had\n   * failed. So, we move to READ_RECEIVER_CMD state.\n   * Previous states : CONNECT\n   * Next states : CONNECT(read failure),\n   *               END(protocol error or global checkpoint found),\n   *               READ_RECEIVER_CMD(if checkpoint is -1),\n   *               SEND_SETTINGS(success)\n   */\n  SenderState readLocalCheckPoint();\n  /**\n   * sends sender settings to the receiver\n   * Previous states : READ_LOCAL_CHECKPOINT,\n   *                   CONNECT\n   * Next states : SEND_BLOCKS(success),\n   *               CONNECT(failure)\n   */\n  SenderState sendSettings();\n  /**\n   * sends blocks to receiver till the queue is not empty. After transferring a\n   * block, we add it to the history. While adding to history, if it is found\n   * that global checkpoint has been received for this thread, we move to END\n   * state.\n   * Previous states : SEND_SETTINGS,\n   *                   PROCESS_ERR_CMD\n   * Next states : SEND_BLOCKS(success),\n   *               END(global checkpoint received),\n   *               CHECK_FOR_ABORT(socket write failure),\n   *               SEND_DONE_CMD(no more blocks left to transfer)\n   */\n  SenderState sendBlocks();\n  /**\n   * sends DONE cmd to the receiver\n   * Previous states : SEND_BLOCKS\n   * Next states : CONNECT(failure),\n   *               READ_RECEIVER_CMD(success)\n   */\n  SenderState sendDoneCmd();\n  /**\n   * sends size cmd to the receiver\n   * Previous states : SEND_BLOCKS\n   * Next states : CHECK_FOR_ABORT(failure),\n   *               SEND_BLOCKS(success)\n   */\n  SenderState sendSizeCmd();\n  /**\n   * checks to see if the receiver has sent ABORT or not\n   * Previous states : SEND_BLOCKS,\n   *                   SEND_DONE_CMD\n   * Next states : CONNECT(no ABORT cmd),\n   *               END(protocol error),\n   *               PROCESS_ABORT_CMD(read ABORT cmd)\n   */\n  SenderState checkForAbort();\n  /**\n   * reads previously transferred file chunks list. If it receives an ACK cmd,\n   * then it moves on. If wait cmd is received, it waits. Otherwise reads the\n   * file chunks and when done starts directory queue thread.\n   * Previous states : SEND_SETTINGS,\n   * Next states: READ_FILE_CHUNKS(if wait cmd is received),\n   *              CHECK_FOR_ABORT(network error),\n   *              END(protocol error),\n   *              SEND_BLOCKS(success)\n   *\n   */\n  SenderState readFileChunks();\n  /**\n   * reads receiver cmd\n   * Previous states : SEND_DONE_CMD\n   * Next states : PROCESS_DONE_CMD,\n   *               PROCESS_WAIT_CMD,\n   *               PROCESS_ERR_CMD,\n   *               END(protocol error),\n   *               CONNECT(failure)\n   */\n  SenderState readReceiverCmd();\n  /**\n   * handles DONE cmd\n   * Previous states : READ_RECEIVER_CMD\n   * Next states : END\n   */\n  SenderState processDoneCmd();\n  /**\n   * handles WAIT cmd\n   * Previous states : READ_RECEIVER_CMD\n   * Next states : READ_RECEIVER_CMD\n   */\n  SenderState processWaitCmd();\n  /**\n   * reads list of global checkpoints and returns unacked sources to queue.\n   * Previous states : READ_RECEIVER_CMD\n   * Next states : CONNECT(socket read failure)\n   *               END(checkpoint list decode failure),\n   *               SEND_BLOCKS(success)\n   */\n  SenderState processErrCmd();\n  /**\n   * processes ABORT cmd\n   * Previous states : CHECK_FOR_ABORT,\n   *                   READ_RECEIVER_CMD\n   * Next states : END\n   */\n  SenderState processAbortCmd();\n\n  /**\n   * waits for all active threads to be aborted, checks to see if the abort was\n   * due to version mismatch. Also performs various sanity checks.\n   * Previous states : Almost all threads, abort flags is checked between every\n   *                   state transition\n   * Next states : CONNECT(Abort was due to version kismatch),\n   *               END(if abort was not due to version mismatch or some sanity\n   *               check failed)\n   */\n  SenderState processVersionMismatch();\n\n  /**\n   * Reads next receiver cmd. If the read times out, checks to see if the tcp\n   * unacked bytes have decreased or not\n   *\n   * @return      status of the read\n   */\n  ErrorCode readNextReceiverCmd();\n\n  /**\n   * Reads and verifies spurious extra checkpoint. Receiver can insert extra\n   * checkpoint in case some bad client connected to it.\n   *\n   * @return      status of read/verification\n   */\n  ErrorCode readAndVerifySpuriousCheckpoint();\n\n  /// General utility used by sender threads to connect to receiver\n  std::unique_ptr<IClientSocket> connectToReceiver(\n      int port, IAbortChecker const *abortChecker, ErrorCode &errCode);\n\n  /// Method responsible for sending one source to the destination\n  TransferStats sendOneByteSource(const std::unique_ptr<ByteSource> &source,\n                                  ErrorCode transferStatus);\n\n  /// checks to see if heart-beat is enabled, and if it is time to read\n  /// heart-beats, and if yes, reads heart-beats\n  ErrorCode readHeartBeats();\n\n  /// mapping from sender states to state functions\n  static const StateFunction stateMap_[];\n\n  /// whether stderr is tty\n  bool isTty_{false};\n\n  /// Negotiated protocol of the sender thread\n  int negotiatedProtocol_{-1};\n\n  /// Pointer to client socket to maintain connection to the receiver\n  /// Note: this must be deleted while still on the same thread it was created\n  /// (for fbonly / btm / thrift / eventbase reasons)\n  std::unique_ptr<IClientSocket> socket_;\n\n  /// whether total file size has been sent to the receiver\n  bool totalSizeSent_{false};\n\n  /// number of consecutive reconnects without any progress\n  int numReconnectWithoutProgress_{0};\n\n  /// Point to the directory queue of parent sender\n  DirectorySourceQueue *dirQueue_;\n\n  /// abort checker to use for this thread\n  std::unique_ptr<IAbortChecker> threadAbortChecker_{nullptr};\n\n  /// Thread history controller shared across all threads\n  TransferHistoryController *transferHistoryController_;\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "SourceQueue.h",
          "type": "blob",
          "size": 1.7099609375,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n#include <wdt/ByteSource.h>\n\n#include <memory>\n\nnamespace facebook {\nnamespace wdt {\n\n/**\n * Interface for consuming data from multiple ByteSource's.\n * Call getNextSource() repeatedly to get new sources to consume data\n * from, until finished() returns true.\n *\n * This class is thread-safe, i.e. multiple threads can consume sources\n * in parallel and terminate once finished() returns true. Each source\n * is guaranteed to be consumed exactly once.\n */\nclass SourceQueue {\n public:\n  virtual ~SourceQueue() {\n  }\n\n  /// @return true iff no more sources to read from\n  virtual bool finished() const = 0;\n\n  /**\n   * Get the next source to consume. Ownership transfers to the caller.\n   * The method will block until it's able to get the next available source\n   * or be sure consumption of all sources has finished.\n   *\n   * @param threadCtx context of the caller thread\n   * @param status    this variable is set to true, if the transfer has already\n   *\n   * @return          New ByteSource to consume or nullptr if there are\n   *                  no more sources to read from (equivalent to finished()).\n   */\n  virtual std::unique_ptr<ByteSource> getNextSource(ThreadCtx *threadCtx,\n                                                    ErrorCode &status) = 0;\n\n  /// @return         total number of files processed/enqueued\n  virtual int64_t getCount() const = 0;\n\n  /// @return         total size of files processed/enqueued\n  virtual int64_t getTotalSize() const = 0;\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "Throttler.cpp",
          "type": "blob",
          "size": 9.701171875,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <wdt/ErrorCodes.h>\n#include <wdt/Throttler.h>\n#include <wdt/WdtOptions.h>\n\nnamespace facebook {\nnamespace wdt {\n\n// Constants for different calculations\nconst int64_t kMillisecsPerSec = 1000;\nconst double kPeakMultiplier = 1.2;\nconst int kBucketMultiplier = 2;\nconst double kTimeMultiplier = 0.25;\n\nstd::shared_ptr<Throttler> Throttler::makeThrottler(\n    const ThrottlerOptions& options) {\n  return std::make_shared<Throttler>(options);\n}\n\nvoid Throttler::configureOptions(double& avgRatePerSec, double& peakRatePerSec,\n                                 double& bucketLimit) {\n  if (peakRatePerSec < avgRatePerSec && peakRatePerSec >= 0) {\n    WLOG(WARNING) << \"Per thread peak rate should be greater \"\n                  << \"than per thread average rate. \"\n                  << \"Making peak rate 1.2 times the average rate\";\n    peakRatePerSec = kPeakMultiplier * (double)avgRatePerSec;\n  }\n  if (bucketLimit <= 0 && peakRatePerSec > 0) {\n    bucketLimit = kTimeMultiplier * kBucketMultiplier * peakRatePerSec;\n    WLOG(INFO) << \"Burst limit not specified but peak \"\n               << \"rate is configured. Auto configuring to \" << bucketLimit;\n  }\n}\n\nThrottler::Throttler(const ThrottlerOptions& options)\n    : avgRatePerSec_(options.avg_rate_per_sec) {\n  bucketRatePerSec_ = options.max_rate_per_sec;\n  tokenBucketLimit_ = kTimeMultiplier * kBucketMultiplier * bucketRatePerSec_;\n  /* We keep the number of tokens generated as zero initially\n   * It could be argued that we keep this filled when we created the\n   * bucket. However the startTime is passed in this case and the hope is\n   * that we will have enough number of tokens by the time we send the data\n   */\n  tokenBucket_ = 0;\n  if (options.throttler_bucket_limit > 0) {\n    tokenBucketLimit_ = options.throttler_bucket_limit;\n  }\n  if (avgRatePerSec_ > 0) {\n    WLOG(INFO) << \"Average rate \" << avgRatePerSec_;\n  } else {\n    WLOG(INFO) << \"No average rate specified\";\n  }\n  if (bucketRatePerSec_ > 0) {\n    WLOG(INFO) << \"Peak rate \" << bucketRatePerSec_ << \".  Bucket limit \"\n               << tokenBucketLimit_;\n  } else {\n    WLOG(INFO) << \"No peak rate specified\";\n  }\n  WDT_CHECK_GT(options.single_request_limit, 0);\n  singleRequestLimit_ = options.single_request_limit;\n  throttlerLogTimeMillis_ = options.throttler_log_time_millis;\n}\n\nvoid Throttler::setThrottlerRates(double& avgRatePerSec,\n                                  double& bucketRatePerSec,\n                                  double& tokenBucketLimit) {\n  // configureOptions will change the rates in case they don't make\n  // sense\n  configureOptions(avgRatePerSec, bucketRatePerSec, tokenBucketLimit);\n  std::unique_lock lock(throttlerMutex_);\n\n  resetState();\n\n  WLOG(INFO) << \"Updating the rates avgRatePerSec : \" << avgRatePerSec\n             << \" bucketRatePerSec : \" << bucketRatePerSec\n             << \" tokenBucketLimit : \" << tokenBucketLimit;\n  avgRatePerSec_ = avgRatePerSec;\n  bucketRatePerSec_ = bucketRatePerSec;\n  tokenBucketLimit_ = tokenBucketLimit;\n}\n\nvoid Throttler::setThrottlerRates(const ThrottlerOptions& options) {\n  double avgRatePerSec = options.avg_rate_per_sec;\n  double peakRatePerSec = options.max_rate_per_sec;\n  double bucketLimit = options.throttler_bucket_limit;\n  setThrottlerRates(avgRatePerSec, peakRatePerSec, bucketLimit);\n}\n\nvoid Throttler::limit(ThreadCtx& threadCtx, int64_t deltaProgress) {\n  limitInternal(&threadCtx, deltaProgress);\n}\n\nvoid Throttler::limit(int64_t deltaProgress) {\n  limitInternal(nullptr, deltaProgress);\n}\n\nvoid Throttler::limitInternal(ThreadCtx* threadCtx, int64_t deltaProgress) {\n  const int kLogInterval = 100;\n  int64_t numThrottled = 0;\n  int64_t count = 0;\n  while (numThrottled < deltaProgress) {\n    const int64_t toThrottle =\n        std::min(singleRequestLimit_, deltaProgress - numThrottled);\n    limitSingleRequest(threadCtx, toThrottle);\n    numThrottled += toThrottle;\n    count++;\n    if (count % kLogInterval == 0) {\n      WLOG(INFO) << \"Throttling large amount data, to-throttle: \"\n                 << deltaProgress << \", num-throttled: \" << numThrottled;\n    }\n  }\n}\n\nvoid Throttler::limitSingleRequest(ThreadCtx* threadCtx,\n                                   int64_t deltaProgress) {\n  WDT_CHECK_LE(deltaProgress, singleRequestLimit_);\n  std::chrono::time_point<Clock> now = Clock::now();\n  double sleepTimeSeconds = calculateSleep(deltaProgress, now);\n  if (throttlerLogTimeMillis_ > 0) {\n    printPeriodicLogs(now, deltaProgress);\n  }\n  if (sleepTimeSeconds <= 0) {\n    return;\n  }\n  if (threadCtx == nullptr) {\n    sleep(sleepTimeSeconds);\n    return;\n  }\n  PerfStatCollector statCollector(*threadCtx, PerfStatReport::THROTTLER_SLEEP);\n  sleep(sleepTimeSeconds);\n}\n\nvoid Throttler::sleep(double sleepTimeSecs) const {\n  /* sleep override */\n  std::this_thread::sleep_for(std::chrono::duration<double>(sleepTimeSecs));\n}\n\ndouble Throttler::calculateSleep(double deltaProgress,\n                                 const Clock::time_point& now) {\n  std::unique_lock lock(throttlerMutex_);\n  if (refCount_ <= 0) {\n    WLOG(ERROR) << \"Using the throttler without registering the transfer\";\n    return -1;\n  }\n  progress_ += deltaProgress;\n  double avgThrottlerSleep = averageThrottler(now);\n  const bool willSleep = (avgThrottlerSleep > 0);\n  if (willSleep) {\n    return avgThrottlerSleep;\n  }\n  // we still hold the lock if peak throttler can come into effect\n  if ((bucketRatePerSec_ > 0) && (tokenBucketLimit_ > 0)) {\n    std::chrono::duration<double> elapsedDuration = now - lastFillTime_;\n    lastFillTime_ = now;\n    double elapsedSeconds = elapsedDuration.count();\n    tokenBucket_ += elapsedSeconds * bucketRatePerSec_;\n    if (tokenBucket_ > tokenBucketLimit_) {\n      tokenBucket_ = tokenBucketLimit_;\n    }\n    tokenBucket_ -= deltaProgress;\n    if (tokenBucket_ < 0) {\n      /*\n       * If we have negative number of tokens lets sleep\n       * This way we will have positive number of tokens next time\n       */\n      double peakThrottlerSleep = -1.0 * tokenBucket_ / bucketRatePerSec_;\n      WVLOG(2) << \"Peak throttler wants to sleep \" << peakThrottlerSleep\n               << \" seconds\";\n      return peakThrottlerSleep;\n    }\n  }\n  return -1;\n}\n\nvoid Throttler::printPeriodicLogs(const Clock::time_point& now,\n                                  double deltaProgress) {\n  /*\n   * This is the part where throttler prints out the progress\n   * made periodically.\n   */\n  std::chrono::duration<double> elapsedLogDuration;\n  std::unique_lock lock(throttlerMutex_);\n  instantProgress_ += deltaProgress;\n  elapsedLogDuration = now - lastLogTime_;\n  double elapsedLogSeconds = elapsedLogDuration.count();\n  if (elapsedLogSeconds * kMillisecsPerSec >= throttlerLogTimeMillis_) {\n    double instantRatePerSec = 0;\n    instantRatePerSec = instantProgress_ / elapsedLogSeconds;\n    instantProgress_ = 0;\n    lastLogTime_ = now;\n    std::chrono::duration<double> elapsedAvgDuration = now - startTime_;\n    double elapsedAvgSeconds = elapsedAvgDuration.count();\n    double avgRatePerSec = progress_ / elapsedAvgSeconds;\n    WLOG(INFO) << \"Throttler:Transfer_Rates::\" << \" \" << elapsedAvgSeconds\n               << \" \" << avgRatePerSec << \" \" << instantRatePerSec << \" \"\n               << deltaProgress;\n  }\n}\n\ndouble Throttler::averageThrottler(const Clock::time_point& now) {\n  std::chrono::duration<double> elapsedDuration = now - startTime_;\n  double elapsedSeconds = elapsedDuration.count();\n  if (avgRatePerSec_ <= 0) {\n    WVLOG(2) << \"There is no avg rate limit\";\n    return -1;\n  }\n  const double allowedProgress = avgRatePerSec_ * elapsedSeconds;\n  if (progress_ > allowedProgress) {\n    double idealTime = progress_ / avgRatePerSec_;\n    const double sleepTimeSeconds = idealTime - elapsedSeconds;\n    WVLOG(1) << \"Throttler : Elapsed \" << elapsedSeconds\n             << \" seconds. Made progress \" << progress_ << \" in \"\n             << elapsedSeconds\n             << \" seconds, maximum allowed progress for this duration is \"\n             << allowedProgress << \". Mean Rate allowed is \" << avgRatePerSec_\n             << \" . Sleeping for \" << sleepTimeSeconds << \" seconds\";\n    return sleepTimeSeconds;\n  }\n  return -1;\n}\n\nvoid Throttler::startTransfer() {\n  std::unique_lock lock(throttlerMutex_);\n  if (refCount_ == 0) {\n    resetState();\n  }\n  refCount_++;\n}\n\nvoid Throttler::resetState() {\n  startTime_ = Clock::now();\n  lastFillTime_ = startTime_;\n  lastLogTime_ = startTime_;\n  instantProgress_ = 0;\n  progress_ = 0;\n  tokenBucket_ = 0;\n}\n\nvoid Throttler::endTransfer() {\n  std::unique_lock lock(throttlerMutex_);\n  WDT_CHECK(refCount_ > 0);\n  refCount_--;\n}\n\ndouble Throttler::getProgress() {\n  std::unique_lock lock(throttlerMutex_);\n  return progress_;\n}\n\ndouble Throttler::getAvgRatePerSec() {\n  std::unique_lock lock(throttlerMutex_);\n  return avgRatePerSec_;\n}\n\ndouble Throttler::getPeakRatePerSec() {\n  std::unique_lock lock(throttlerMutex_);\n  return bucketRatePerSec_;\n}\n\ndouble Throttler::getBucketLimit() {\n  std::unique_lock lock(throttlerMutex_);\n  return tokenBucketLimit_;\n}\n\nint64_t Throttler::getThrottlerLogTimeMillis() {\n  std::unique_lock lock(throttlerMutex_);\n  return throttlerLogTimeMillis_;\n}\n\nvoid Throttler::setThrottlerLogTimeMillis(int64_t throttlerLogTimeMillis) {\n  std::unique_lock lock(throttlerMutex_);\n  throttlerLogTimeMillis_ = throttlerLogTimeMillis;\n}\n\nstd::ostream& operator<<(std::ostream& stream, const Throttler& throttler) {\n  stream << \"avgRate: \" << throttler.avgRatePerSec_\n         << \", peakRate: \" << throttler.bucketRatePerSec_\n         << \", bucketLimit: \" << throttler.tokenBucketLimit_\n         << \", throttlerLogTimeMillis: \" << throttler.throttlerLogTimeMillis_;\n  return stream;\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "Throttler.h",
          "type": "blob",
          "size": 6.8671875,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n#include <folly/SpinLock.h>\n#include <glog/logging.h>\n#include <wdt/util/CommonImpl.h>\n\n#include <thread>\nnamespace facebook {\nnamespace wdt {\n\nstruct ThrottlerOptions {\n  /**\n   * Rate at which we would like to throttle,\n   * specifying this as < 0 makes it unlimited\n   */\n  double avg_rate_per_sec{-1};\n  /**\n   * Rate at which tokens will be generated in TB algorithm.\n   * When we lag behind, this will allow us to go faster,\n   * specify as < 0 to make it unlimited. Specify as 0\n   * for auto configuring.\n   * auto conf as (kPeakMultiplier * avgRatePerSec_)\n   * Find details in Throttler.cpp\n   */\n  double max_rate_per_sec{0};\n  /**\n   * Maximum bucket size of TB algorithm.\n   * This together with maxRatePerSec_ will\n   * make for maximum burst rate. If specified as 0 it is\n   * auto configured in Throttler.cpp\n   */\n  double throttler_bucket_limit{0};\n  /**\n   * Throttler logs statistics like average and max rate.\n   * This option specifies on how frequently should those\n   * be logged\n   */\n  int64_t throttler_log_time_millis{0};\n  /**\n   * Limit for single request. If the requested size is greater than this, the\n   * request is broken in chunks of this size and processed sequentially.\n   * This ensures that a thread asking for large amount of resource does not\n   * starve other threads asking for small amount of resource.\n   */\n  int64_t single_request_limit{1};\n};\n\n/**\n * Attempts to limit the rate in two ways.\n * 1. Limit average rate by calling averageThrottler()\n * 2. Limit the peak rate by calling limitByTokenBucket\n * Generally average throttler would be maintaining the rate to avgRate_\n * although at times the actual rate might fall behind and in those\n * circumstances the rate at which you will catch up is limited\n * with respect to the peak rate and the bucket limit using the\n * token bucket algorithm.\n * Token Bucket algorithm can be found on\n * http://en.wikipedia.org/wiki/Token_bucket\n */\nclass Throttler {\n public:\n  /// Utility method that makes throttler using options.\n  static std::shared_ptr<Throttler> makeThrottler(\n      const ThrottlerOptions& options);\n\n  explicit Throttler(const ThrottlerOptions& options);\n\n  /**\n   * Calls calculateSleep which is a thread safe method. Finds out the\n   * time thread has to sleep and makes it sleep.\n   * Also calls the throttler logger to log the stats\n   */\n  virtual void limit(ThreadCtx& threadCtx, int64_t deltaProgress);\n\n  /**\n   * Same as the other limit, but without reporting for sleep duration\n   */\n  virtual void limit(int64_t deltaProgress);\n\n  /**\n   * This is thread safe implementation of token bucket\n   * algorithm. Bucket is filled at the rate of bucketRatePerSec_\n   * till the limit of tokenBucketLimit_\n   * There is no sleep, we just calculate how much to sleep.\n   * This method also calls the averageThrottler inside\n   * @param deltaProgress         Progress since the last limit call\n   */\n  virtual double calculateSleep(double totalProgress,\n                                const Clock::time_point& now);\n\n  /// Provides anyone using this throttler instance to update the throttler\n  /// rates. The rates might be configured to different values than what\n  /// were passed.\n  virtual void setThrottlerRates(double& avgRatePerSec,\n                                 double& bucketRatePerSec,\n                                 double& tokenBucketLimit);\n\n  /// Utility method that set throttler rate using options\n  void setThrottlerRates(const ThrottlerOptions& options);\n\n  virtual ~Throttler() {\n  }\n\n  /// Anyone who is using the throttler should call this method to maintain\n  /// the refCount_ and startTime_ correctly\n  void startTransfer();\n\n  /// Method to de-register the transfer and decrement the refCount_\n  void endTransfer();\n\n  /// Get the average rate per sec\n  double getAvgRatePerSec();\n\n  /// Get the bucket rate per sec\n  double getPeakRatePerSec();\n\n  /// Get the bucket limit\n  double getBucketLimit();\n\n  /// Get the throttler logging time period in millis\n  int64_t getThrottlerLogTimeMillis();\n\n  /// Set the throttler logging time in millis\n  void setThrottlerLogTimeMillis(int64_t throttlerLogTimeMillis);\n\n  /// Get tokens processed till now\n  double getProgress();\n\n  friend std::ostream& operator<<(std::ostream& stream,\n                                  const Throttler& throttler);\n\n private:\n  /**\n   * Sometimes the options passed to throttler might not make sense so this\n   * method tries to auto configure them\n   */\n  static void configureOptions(double& avgRatePerSec, double& peakRatePerSec,\n                               double& bucketLimit);\n\n  /**\n   * This method is invoked repeatedly with the amount of progress made\n   * (e.g. number of tokens processed) till now. If the total progress\n   * till now is over the allowed average progress then it returns the\n   * time to sleep for the calling thread\n   * @param now                       Pass in the current time stamp\n   */\n  double averageThrottler(const Clock::time_point& now);\n\n  void limitInternal(ThreadCtx* threadCtx, int64_t deltaProgress);\n\n  void limitSingleRequest(ThreadCtx* threadCtx, int64_t deltaProgress);\n\n  void sleep(double sleepTimeSecs) const;\n\n  void resetState();\n\n  /**\n   * This method periodically prints logs.\n   * The period is defined by FLAGS_peak_log_time_ms\n   * @param deltaProgress      Progress since last call to limit()\n   * @param now                The time point caller has\n   * @param sleepTimeSeconds   Duration of sleep caused by limit()\n   */\n  void printPeriodicLogs(const Clock::time_point& now, double deltaProgress);\n  /// Records the time the throttler was started\n  Clock::time_point startTime_;\n\n  /**\n   * Throttler logs the average and instantaneous progress\n   * periodically (check FLAGS_peak_log_time_ms). lastLogTime_ is\n   * the last time this log was written\n   */\n  Clock::time_point lastLogTime_;\n  /// Instant progress in the time stats were logged last time\n  double instantProgress_{0};\n  // Records the total progress in tokens till now\n  double progress_{0};\n  /// Last time the token bucket was filled\n  std::chrono::time_point<std::chrono::high_resolution_clock> lastFillTime_;\n\n protected:\n  /// Number of tokens in the bucket\n  int64_t tokenBucket_;\n  /// Controls the access across threads\n  folly::SpinLock throttlerMutex_;\n  /// Number of users of this throttler\n  int64_t refCount_{0};\n  /// The average rate expected\n  double avgRatePerSec_;\n  /// Limit on the max number of tokens\n  double tokenBucketLimit_;\n  /// Rate at which bucket is filled\n  double bucketRatePerSec_;\n  /// Max number of tokens that can be requested in a single call\n  int64_t singleRequestLimit_;\n  /// Interval between every print of throttler logs\n  int64_t throttlerLogTimeMillis_;\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "Wdt.cpp",
          "type": "blob",
          "size": 7.94921875,
          "content": "#include <wdt/Wdt.h>\n#include <wdt/util/WdtFlags.h>\n\nnamespace facebook {\nnamespace wdt {\n\n// this must be called first and exactly once:\nWdt &Wdt::initializeWdt(const std::string &appName) {\n  static bool doGlobalFlagsInit = true;\n  if (doGlobalFlagsInit) {\n    WdtFlags::initializeFromFlags(WdtOptions::getMutable());\n    doGlobalFlagsInit = false;\n  }\n  Wdt &res = getWdtInternal(appName, []() -> Wdt * { return new Wdt(); });\n  res.initializeWdtInternal(appName);\n  // At fb we do this for services - that's floody for cmd line though\n  // res.printWdtOptions(WLOG(INFO));\n  return res;\n}\n\nErrorCode Wdt::initializeWdtInternal(const std::string &appName) {\n  WLOG(INFO) << \"One time initialization of WDT for \" << appName;\n  if (initDone_) {\n    WLOG(ERROR) << \"Called initializeWdt() more than once\";\n    return ERROR;\n  }\n  appName_ = appName;\n  initDone_ = true;\n  resourceController_->getWdtThrottler()->setThrottlerRates(\n      options_.getThrottlerOptions());\n  return OK;\n}\n\n// this can be called many times after initializeWdt()\nWdt &Wdt::getWdt(const std::string &appName) {\n  Wdt &res = getWdtInternal(appName, nullptr);\n  if (!res.initDone_) {\n    WLOG(ERROR) << \"Called getWdt() before/without initializeWdt()\";\n    WDT_CHECK(false) << \"Must call initializeWdt() once before getWdt()\";\n  }\n  return res;\n}\n\nErrorCode Wdt::printWdtOptions(std::ostream &out) {\n  WdtFlags::printOptions(out, options_);\n  return OK;\n}\n\nWdt::Wdt() {\n  WdtFlags::initializeFromFlags(options_);\n  resourceController_ = std::make_unique<WdtResourceController>(options_);\n}\n\nWdt::Wdt(std::shared_ptr<Throttler> throttler) {\n  WdtFlags::initializeFromFlags(options_);\n  resourceController_ =\n      std::make_unique<WdtResourceController>(options_, throttler);\n}\n\nstd::string Wdt::getSenderIdentifier(const WdtTransferRequest &req) {\n  if (req.destIdentifier.empty()) {\n    return req.hostName;\n  }\n  return req.destIdentifier;\n}\n\nErrorCode Wdt::createWdtSender(const WdtTransferRequest &req,\n                               std::shared_ptr<IAbortChecker> abortChecker,\n                               bool terminateExistingOne,\n                               SenderPtr &senderPtr) {\n  if (req.errorCode != OK) {\n    WLOG(ERROR) << \"Transfer request error \" << errorCodeToStr(req.errorCode);\n    return req.errorCode;\n  }\n  // Protocol issues will/should be flagged as error when we call createSender\n\n  // try to create sender\n  const std::string &wdtNamespace = req.wdtNamespace;\n  const std::string secondKey = getSenderIdentifier(req);\n  ErrorCode errCode = resourceController_->createSender(wdtNamespace, secondKey,\n                                                        req, senderPtr);\n  if (errCode == ALREADY_EXISTS && terminateExistingOne) {\n    WLOG(WARNING) << \"Found pre-existing sender for \" << wdtNamespace << \" \"\n                  << secondKey << \" aborting it and making a new one\";\n    if (senderPtr->getTransferRequest().transferId == req.transferId) {\n      WLOG(WARNING) << \"No need to recreate same sender with key: \" << secondKey\n                    << \" TransferRequest: \" << req;\n      return ALREADY_EXISTS;\n    }\n    senderPtr->abort(ABORTED_BY_APPLICATION);\n    // This may log an error too\n    resourceController_->releaseSender(wdtNamespace, secondKey);\n    // Try#2\n    errCode = resourceController_->createSender(wdtNamespace, secondKey, req,\n                                                senderPtr);\n  }\n  if (errCode != OK) {\n    WLOG(ERROR) << \"Failed to create sender \" << errorCodeToStr(errCode) << \" \"\n                << wdtNamespace << \" \" << secondKey;\n    return errCode;\n  }\n  wdtSetAbortSocketCreatorAndReporter(\n      senderPtr.get(), senderPtr->getTransferRequest(), abortChecker);\n  return OK;\n}\n\nErrorCode Wdt::releaseWdtSender(const WdtTransferRequest &wdtRequest) {\n  return resourceController_->releaseSender(wdtRequest.wdtNamespace,\n                                            getSenderIdentifier(wdtRequest));\n}\n\nErrorCode Wdt::wdtSend(const WdtTransferRequest &req,\n                       std::shared_ptr<IAbortChecker> abortChecker,\n                       bool terminateExistingOne) {\n  SenderPtr sender;\n  ErrorCode errCode =\n      createWdtSender(req, abortChecker, terminateExistingOne, sender);\n  if (errCode != OK) {\n    return errCode;\n  }\n  const std::string &wdtNamespace = req.wdtNamespace;\n  auto validatedReq = sender->init();\n  if (validatedReq.errorCode != OK) {\n    WLOG(ERROR) << \"Couldn't init sender with request for \" << wdtNamespace;\n    return validatedReq.errorCode;\n  }\n  auto transferReport = sender->transfer();\n  errCode = transferReport->getSummary().getErrorCode();\n  releaseWdtSender(req);\n  WLOG(INFO) << \"wdtSend for \" << wdtNamespace << \" \" << req.hostName\n             << \" ended with \" << errorCodeToStr(errCode);\n  return errCode;\n}\n\nErrorCode Wdt::wdtReceiveStart(const std::string &wdtNamespace,\n                               WdtTransferRequest &req,\n                               const std::string &identifier,\n                               std::shared_ptr<IAbortChecker> abortChecker) {\n  if (req.errorCode != OK) {\n    WLOG(ERROR) << \"Transfer request namespace:\" << wdtNamespace\n                << \" identifier:\" << identifier\n                << \" error:\" << errorCodeToStr(req.errorCode);\n    return req.errorCode;\n  }\n\n  ReceiverPtr receiver;\n  ErrorCode errCode = resourceController_->createReceiver(\n      wdtNamespace, identifier, req, receiver);\n  if (errCode != OK) {\n    WLOG(ERROR) << \"Failed to create receiver \" << errorCodeToStr(errCode)\n                << \" \" << wdtNamespace << \" \" << identifier;\n    req.errorCode = errCode;\n    return errCode;\n  }\n\n  wdtSetAbortSocketCreatorAndReporter(receiver.get(), req, abortChecker);\n\n  req = receiver->init();\n  if (req.errorCode != OK) {\n    WLOG(ERROR) << \"Couldn't init receiver with request for \" << wdtNamespace\n                << \" \" << identifier;\n    return req.errorCode;\n  }\n  errCode = receiver->transferAsync();\n  WLOG(INFO) << \"wdtReceiveStart for \" << wdtNamespace << \" \" << identifier\n             << \" : \" << errorCodeToStr(errCode);\n  req.errorCode = errCode;\n  return errCode;\n}\n\nErrorCode Wdt::wdtReceiveFinish(const std::string &wdtNamespace,\n                                const std::string &identifier) {\n  ReceiverPtr receiver =\n      resourceController_->getReceiver(wdtNamespace, identifier);\n  if (receiver == nullptr) {\n    WLOG(ERROR) << \"Failed to get receiver \" << errorCodeToStr(NOT_FOUND) << \" \"\n                << wdtNamespace << \" \" << identifier;\n    return NOT_FOUND;\n  }\n  auto report = receiver->finish();\n  ErrorCode errCode = report->getSummary().getErrorCode();\n  WLOG(INFO) << \"wdtReceiveFinish for \" << wdtNamespace << \" \" << identifier\n             << \" ended with \" << errorCodeToStr(errCode);\n  resourceController_->releaseReceiver(wdtNamespace, identifier);\n  return errCode;\n}\n\nErrorCode Wdt::wdtSetAbortSocketCreatorAndReporter(\n    WdtBase *target, const WdtTransferRequest &,\n    std::shared_ptr<IAbortChecker> abortChecker) {\n  if (abortChecker.get() != nullptr) {\n    target->setAbortChecker(abortChecker);\n  }\n  return OK;\n}\n\nWdtOptions &Wdt::getWdtOptions() {\n  return options_;\n}\n\nstatic std::unordered_map<std::string, std::unique_ptr<Wdt>> s_wdtMap;\nstatic std::mutex s_mutex;\n\n// private version\nWdt &Wdt::getWdtInternal(const std::string &appName,\n                         std::function<Wdt *()> factory) {\n  std::lock_guard<std::mutex> lock(s_mutex);\n  auto it = s_wdtMap.find(appName);\n  if (it != s_wdtMap.end()) {\n    return *(it->second);\n  }\n  WDT_CHECK(factory) << \"Must call initializeWdt() once before getWdt() \"\n                     << appName;\n  Wdt *wdtPtr = factory();\n  std::unique_ptr<Wdt> wdt(wdtPtr);\n  s_wdtMap.emplace(appName, std::move(wdt));\n  return *wdtPtr;\n}\n\nvoid Wdt::releaseWdt(const std::string &appName) {\n  LOG(INFO) << \"Releasing WDT for \" << appName;\n  std::lock_guard<std::mutex> lock(s_mutex);\n  auto it = s_wdtMap.find(appName);\n  if (it == s_wdtMap.end()) {\n    LOG(ERROR) << appName << \" not found in releaseWdt\";\n    return;\n  }\n  s_wdtMap.erase(it);\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "Wdt.h",
          "type": "blob",
          "size": 4.9599609375,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n#include <wdt/Receiver.h>\n#include <wdt/Sender.h>\n// For Options\n#include <wdt/WdtOptions.h>\n// For ErrorCode\n#include <wdt/ErrorCodes.h>\n// For IAbortChecker and WdtTransferRequest - TODO: split out ?\n#include <wdt/WdtBase.h>\n#include <wdt/WdtResourceController.h>\n#include <wdt/util/EncryptionUtils.h>\n\n#include <ostream>\n\nnamespace facebook {\nnamespace wdt {\n\n// Note: we use Wdt in the method names even if redundant with the class name\n// so we can search callers easily\n\n/**\n * This class is the main API and entry point for using WDT (Warp speed Data\n * Transfers).\n *\n * Example of use:\n * // During the single threaded part of your service's initialization\n * Wdt &wdt = Wdt::initializeWdt(\"app-name\");\n * // Optionally: change the WdtOptions as you need, for instance:\n * wdt.getWdtOptions().overwrite = true;\n * // Will use the (possibly changed above) settings, to configure wdt,\n * // for instance throttler options\n * // Sender for already setup receiver: (abortChecker is optional)\n * wdtSend(transferRequest, myAbortChecker);\n */\nclass Wdt {\n public:\n  /**\n   * Initialize the Wdt library and parse options from gflags.\n   * Also initialize crypto library if needed/not already initialized.\n   * @param:\n   *   applicationName is used at fb for scuba reporting to differentiate apps\n   */\n  static Wdt &initializeWdt(const std::string &appName);\n  /**\n   * Mutable reference to WdtOptions\n   */\n  WdtOptions &getWdtOptions();\n  /**\n   * Return Wdt lib handle which has been previously initialized by calling\n   * @see initializeWdt()\n   * This is only needed if the caller code doesn't want to pass the Wdt\n   * instance around.\n   */\n  static Wdt &getWdt(const std::string &appName);\n  /**\n   * TLS is unsupported for now\n   */\n  virtual bool isTlsEnabled() {\n    return false;\n  }\n\n  /// High level APIs:\n\n  /**\n   * Send data for the shard identified by shardId to an already running/setup\n   * receiver whose connection url was used to make a WdtTransferRequest.\n   * Optionally passes an abort checker.\n   */\n  virtual ErrorCode wdtSend(\n      const WdtTransferRequest &wdtRequest,\n      std::shared_ptr<IAbortChecker> abortChecker = nullptr,\n      bool terminateExistingOne = false);\n\n  virtual ErrorCode createWdtSender(const WdtTransferRequest &wdtRequest,\n                                    std::shared_ptr<IAbortChecker> abortChecker,\n                                    bool terminateExistingOne,\n                                    SenderPtr &senderPtr);\n\n  virtual ErrorCode releaseWdtSender(const WdtTransferRequest &wdtRequest);\n\n  /**\n   * Receive data. It creates a receiver on specified namespace/identifier and\n   * initialize it.\n   */\n  virtual ErrorCode wdtReceiveStart(\n      const std::string &wdtNamespace, WdtTransferRequest &wdtRequest,\n      const std::string &identifier = \"default\",\n      std::shared_ptr<IAbortChecker> abortChecker = nullptr);\n\n  /**\n   * Finish receiving data. It finishes the receiver on specified\n   * namespace/identifier.\n   */\n  virtual ErrorCode wdtReceiveFinish(const std::string &wdtNamespace,\n                                     const std::string &identifier = \"default\");\n\n  virtual ErrorCode printWdtOptions(std::ostream &out);\n\n  WdtResourceController *getWdtResourceController() {\n    return resourceController_.get();\n  }\n\n  /// destroys WDT object for an app\n  static void releaseWdt(const std::string &appName);\n\n  /// @return  sender identifier for a transfer request\n  static std::string getSenderIdentifier(const WdtTransferRequest &req);\n\n  virtual void wdtSetReceiverSocketCreator(Receiver & /* unused */) {\n  }\n\n  /// Virtual Destructor (for class hierarchy)\n  virtual ~Wdt() {\n  }\n\n protected:\n  /// Set to true when each instance is initialized\n  bool initDone_{false};\n\n  /// App name which is used in scuba reporting\n  std::string appName_;\n\n  WdtOptions options_;\n\n  /// responsible for initializing openssl\n  WdtCryptoIntializer cryptoInitializer_;\n\n  // TODO: share resource controller across apps\n  /// wdt resource controller\n  std::unique_ptr<WdtResourceController> resourceController_;\n\n  // Internal initialization so sub classes can share the code\n  virtual ErrorCode initializeWdtInternal(const std::string &appName);\n\n  // Optionally set socket creator and progress reporter (used for fb)\n  virtual ErrorCode wdtSetAbortSocketCreatorAndReporter(\n      WdtBase *target, const WdtTransferRequest &req,\n      std::shared_ptr<IAbortChecker> abortChecker);\n\n  // Internal wdt object creator/holder\n  static Wdt &getWdtInternal(const std::string &appName,\n                             std::function<Wdt *()> factory);\n\n  /// Private constructor\n  explicit Wdt();\n  explicit Wdt(std::shared_ptr<Throttler> throttler);\n\n  /// Not copyable\n  Wdt(const Wdt &) = delete;\n  Wdt &operator=(const Wdt &) = delete;\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "WdtBase.cpp",
          "type": "blob",
          "size": 5.7763671875,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <wdt/WdtBase.h>\n#include <wdt/WdtTransferRequest.h>\n\n#include <random>\nusing namespace std;\n\nnamespace facebook {\nnamespace wdt {\n\n// TODO: force callers to pass options in\nWdtBase::WdtBase() : abortCheckerCallback_(this) {\n  options_.copyInto(WdtOptions::get());\n}\n\nvoid WdtBase::setWdtOptions(const WdtOptions& src) {\n  options_.copyInto(src);\n}\n\nWdtBase::~WdtBase() {\n  abortChecker_ = nullptr;\n  delete threadsController_;\n}\n\nvoid WdtBase::abort(const ErrorCode abortCode) {\n  std::unique_lock guard(abortCodeLock_);\n  if (abortCode == VERSION_MISMATCH && abortCode_ != OK) {\n    // VERSION_MISMATCH is the lowest priority abort code. If the abort code is\n    // anything other than OK, we should not override it\n    return;\n  }\n  WLOG(WARNING) << \"Setting the abort code \" << abortCode;\n  abortCode_ = abortCode;\n}\n\nvoid WdtBase::clearAbort() {\n  std::unique_lock guard(abortCodeLock_);\n  if (abortCode_ != VERSION_MISMATCH) {\n    // We do no clear abort code unless it is VERSION_MISMATCH\n    return;\n  }\n  WLOG(WARNING) << \"Clearing the abort code\";\n  abortCode_ = OK;\n}\n\nvoid WdtBase::setAbortChecker(const std::shared_ptr<IAbortChecker>& checker) {\n  abortChecker_ = checker;\n}\n\nErrorCode WdtBase::getCurAbortCode() const {\n  // external check, if any:\n  if (abortChecker_ && abortChecker_->shouldAbort()) {\n    return ABORTED_BY_APPLICATION;\n  }\n  std::shared_lock guard(abortCodeLock_);\n  // internal check:\n  return abortCode_;\n}\n\nvoid WdtBase::setProgressReporter(\n    std::unique_ptr<ProgressReporter>& progressReporter) {\n  progressReporter_ = std::move(progressReporter);\n}\n\nvoid WdtBase::setThrottler(std::shared_ptr<Throttler> throttler) {\n  WVLOG(2) << \"Setting an external throttler\";\n  throttler_ = throttler;\n}\n\nstd::shared_ptr<Throttler> WdtBase::getThrottler() const {\n  return throttler_;\n}\n\nvoid WdtBase::setTransferId(const std::string& transferId) {\n  transferRequest_.transferId = transferId;\n  WLOG(INFO) << \"Setting transfer id \" << transferId;\n}\n\nvoid WdtBase::negotiateProtocol() {\n  int protocol = transferRequest_.protocolVersion;\n  WDT_CHECK(protocol > 0) << \"Protocol version can't be <= 0 \" << protocol;\n  int negotiatedPv = Protocol::negotiateProtocol(protocol);\n  if (negotiatedPv != protocol) {\n    WLOG(WARNING) << \"Negotiated protocol version \" << protocol << \" -> \"\n                  << negotiatedPv;\n  }\n  transferRequest_.protocolVersion = negotiatedPv;\n  WLOG(INFO) << \"using wdt protocol version \"\n             << transferRequest_.protocolVersion;\n}\n\nint WdtBase::getProtocolVersion() const {\n  return transferRequest_.protocolVersion;\n}\n\nvoid WdtBase::setProtocolVersion(int protocolVersion) {\n  transferRequest_.protocolVersion = protocolVersion;\n}\n\nstd::string WdtBase::getTransferId() {\n  return transferRequest_.transferId;\n}\n\nconst std::string& WdtBase::getDirectory() const {\n  return transferRequest_.directory;\n}\n\nWdtTransferRequest& WdtBase::getTransferRequest() {\n  return transferRequest_;\n}\n\nvoid WdtBase::checkAndUpdateBufferSize() {\n  int64_t bufSize = options_.buffer_size;\n  if (bufSize < Protocol::kMaxHeader) {\n    bufSize = Protocol::kMaxHeader;\n    WLOG(WARNING) << \"Specified buffer size \" << options_.buffer_size\n                  << \" less than \" << Protocol::kMaxHeader << \", using \"\n                  << bufSize;\n  }\n  if (bufSize % kDiskBlockSize != 0) {\n    int64_t alignedBufSize =\n        ((bufSize + kDiskBlockSize - 1) / kDiskBlockSize) * kDiskBlockSize;\n    WLOG(WARNING) << \"Buffer size \" << bufSize\n                  << \" not divisible by disk block size \" << kDiskBlockSize\n                  << \", changing it to \" << alignedBufSize;\n    bufSize = alignedBufSize;\n  }\n  options_.buffer_size = bufSize;\n}\n\nWdtBase::TransferStatus WdtBase::getTransferStatus() {\n  std::lock_guard<std::mutex> lock(mutex_);\n  return transferStatus_;\n}\n\nErrorCode WdtBase::validateTransferRequest() {\n  ErrorCode code = transferRequest_.errorCode;\n  if (code != OK) {\n    WLOG(ERROR) << \"WDT object initiated with erroneous transfer request \"\n                << transferRequest_.getLogSafeString();\n    return code;\n  }\n  if (transferRequest_.directory.empty() ||\n      (transferRequest_.protocolVersion < 0) ||\n      transferRequest_.ports.empty()) {\n    WLOG(ERROR) << \"Transfer request validation failed for wdt object \"\n                << transferRequest_.getLogSafeString();\n    code = INVALID_REQUEST;\n    transferRequest_.errorCode = code;\n  }\n  return code;\n}\n\nvoid WdtBase::setTransferStatus(TransferStatus transferStatus) {\n  std::lock_guard<std::mutex> lock(mutex_);\n  transferStatus_ = transferStatus;\n  if (transferStatus_ == TransferStatus::THREADS_JOINED) {\n    conditionFinished_.notify_one();\n  }\n}\n\nbool WdtBase::isStale() {\n  TransferStatus status = getTransferStatus();\n  return (status == TransferStatus::FINISHED ||\n          status == TransferStatus::THREADS_JOINED);\n}\n\nbool WdtBase::hasStarted() {\n  TransferStatus status = getTransferStatus();\n  return (status != TransferStatus::NOT_STARTED);\n}\n\nvoid WdtBase::configureThrottler() {\n  WDT_CHECK(!throttler_);\n  WVLOG(1) << \"Configuring throttler options\";\n  throttler_ = std::make_shared<Throttler>(options_.getThrottlerOptions());\n  if (throttler_) {\n    WLOG(INFO) << \"Enabling throttling \" << *throttler_;\n  } else {\n    WLOG(INFO) << \"Throttling not enabled\";\n  }\n}\n\nstring WdtBase::generateTransferId() {\n  static std::default_random_engine randomEngine{std::random_device()()};\n  static std::mutex mutex;\n  string transferId;\n  {\n    std::lock_guard<std::mutex> lock(mutex);\n    transferId = to_string(randomEngine());\n  }\n  WVLOG(1) << \"Generated a transfer id \" << transferId;\n  return transferId;\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "WdtBase.h",
          "type": "blob",
          "size": 6.767578125,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n#include <folly/synchronization/RWSpinLock.h>\n#include <wdt/AbortChecker.h>\n#include <wdt/ErrorCodes.h>\n#include <wdt/Protocol.h>\n#include <wdt/Reporting.h>\n#include <wdt/Throttler.h>\n#include <wdt/WdtOptions.h>\n#include <wdt/WdtThread.h>\n#include <wdt/util/DirectorySourceQueue.h>\n#include <wdt/util/EncryptionUtils.h>\n#include <wdt/util/ThreadsController.h>\n\n#include <memory>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nnamespace facebook {\nnamespace wdt {\n\n/**\n * Shared code/functionality between Receiver and Sender\n * TODO: check if more of Receiver/Sender should move here\n */\nclass WdtBase {\n public:\n  /// Constructor\n  WdtBase();\n\n  /**\n   * Does the setup before start, returns the transfer request\n   * that corresponds to the information relating to the sender\n   * The transfer request has error code set should there be an error\n   */\n  virtual const WdtTransferRequest& init() = 0;\n\n  /// Sets other options than global/singleton ones - call this before init()\n  void setWdtOptions(const WdtOptions& src);\n\n  /// Destructor\n  virtual ~WdtBase();\n\n  /// Transfer can be marked to abort and threads will eventually\n  /// get aborted after this method has been called based on\n  /// whether they are doing read/write on the socket and the timeout for the\n  /// socket. Push mode for abort.\n  void abort(ErrorCode abortCode);\n\n  /// clears abort flag\n  void clearAbort();\n\n  /**\n   * Returns a reference to the copy of WdtOptions held by this object.\n   * Changes should only be made before init() is called, not after.\n   */\n  WdtOptions& getWdtOptions() {\n    return options_;\n  }\n\n  /**\n   * sets an extra external call back to check for abort\n   * can be for instance extending IAbortChecker with\n   * bool checkAbort() {return atomicBool->load();}\n   * see wdtCmdLine.cpp for an example.\n   */\n  void setAbortChecker(const std::shared_ptr<IAbortChecker>& checker);\n\n  /// threads can call this method to find out\n  /// whether transfer has been marked from abort\n  ErrorCode getCurAbortCode() const;\n\n  /// Wdt objects can report progress. Setter for progress reporter\n  /// defined in Reporting.h\n  void setProgressReporter(std::unique_ptr<ProgressReporter>& progressReporter);\n\n  /// Set throttler externally. Should be set before any transfer calls\n  void setThrottler(std::shared_ptr<Throttler> throttler);\n\n  /// Sets the transferId for this transfer\n  void setTransferId(const std::string& transferId);\n\n  ///  Get the protocol version of the transfer\n  int getProtocolVersion() const;\n\n  /// Sets protocol version to use\n  void setProtocolVersion(int protocolVersion);\n\n  /// Get the transfer id of the object\n  std::string getTransferId();\n\n  /// Get the transfer request\n  WdtTransferRequest& getTransferRequest();\n\n  /// Finishes the wdt object and returns a report\n  virtual std::unique_ptr<TransferReport> finish() = 0;\n\n  /// Method to transfer the data. Doesn't block and\n  /// returns with the status\n  virtual ErrorCode transferAsync() = 0;\n\n  /// Basic setup for throttler using options\n  void configureThrottler();\n\n  /// Utility to generate a random transfer id\n  static std::string generateTransferId();\n\n  /// Get the throttler\n  std::shared_ptr<Throttler> getThrottler() const;\n\n  /// @return   Root directory\n  const std::string& getDirectory() const;\n\n  /// @param      whether the object is stale. If all the transferring threads\n  ///             have finished, the object will marked as stale\n  bool isStale();\n\n  /// @return       Whether the transfer has started\n  bool hasStarted();\n\n  /// abort checker class passed to socket functions\n  class AbortChecker : public IAbortChecker {\n   public:\n    explicit AbortChecker(WdtBase* wdtBase) : wdtBase_(wdtBase) {\n    }\n\n    bool shouldAbort() const override {\n      return wdtBase_->getCurAbortCode() != OK;\n    }\n\n   private:\n    WdtBase* wdtBase_;\n  };\n\n protected:\n  enum class TransferStatus {\n    NOT_STARTED,     // threads not started\n    ONGOING,         // transfer is ongoing\n    FINISHED,        // last running thread finished\n    THREADS_JOINED,  // threads joined\n  };\n  friend std::ostream& operator<<(std::ostream& os,\n                                  const WdtBase::TransferStatus& status);\n\n  /// Validate the transfer request\n  virtual ErrorCode validateTransferRequest();\n\n  /// @return current transfer status\n  TransferStatus getTransferStatus();\n\n  /// corrects buffer size if necessary\n  void checkAndUpdateBufferSize();\n\n  /// @param transferStatus   current transfer status\n  void setTransferStatus(TransferStatus transferStatus);\n\n  /// Sets the protocol version for the transfer\n  void negotiateProtocol();\n\n  /// Dumps performance statistics if enable_perf_stat_collection is true.\n  virtual void logPerfStats() const = 0;\n\n  /// Input/output transfer request\n  WdtTransferRequest transferRequest_;\n\n  /// Global throttler across all threads\n  std::shared_ptr<Throttler> throttler_;\n\n  /// Holds the instance of the progress reporter default or customized\n  std::unique_ptr<ProgressReporter> progressReporter_;\n\n  /// abort checker passed to socket functions\n  AbortChecker abortCheckerCallback_;\n\n  /// current transfer status\n  TransferStatus transferStatus_{TransferStatus::NOT_STARTED};\n\n  /// Mutex which is shared between the parent thread, transferring threads and\n  /// progress reporter thread\n  std::mutex mutex_;\n\n  /// Mutex for the management of this instance, specifically to keep the\n  /// instance sane for multi threaded public API calls\n  std::mutex instanceManagementMutex_;\n\n  /// This condition is notified when the transfer is finished\n  std::condition_variable conditionFinished_;\n\n  /// Controller for wdt threads shared between base and threads\n  ThreadsController* threadsController_{nullptr};\n\n  /// Dump perf stats if notified\n  ReportPerfSignalSubscriber reportPerfSignal_;\n\n  /// Options/config used by this object\n  WdtOptions options_;\n\n private:\n  mutable folly::RWSpinLock abortCodeLock_;\n  /// Internal and default abort code\n  ErrorCode abortCode_{OK};\n  /// Additional external source of check for abort requested\n  std::shared_ptr<IAbortChecker> abortChecker_{nullptr};\n};\n\ninline std::ostream& operator<<(std::ostream& os,\n                                const WdtBase::TransferStatus& status) {\n  switch (status) {\n    case WdtBase::TransferStatus::NOT_STARTED:\n      os << \"NOT_STARTED\";\n      break;\n    case WdtBase::TransferStatus::ONGOING:\n      os << \"ONGOING\";\n      break;\n    case WdtBase::TransferStatus::FINISHED:\n      os << \"FINISHED\";\n      break;\n    case WdtBase::TransferStatus::THREADS_JOINED:\n      os << \"THREADS_JOINED\";\n      break;\n  }\n  return os;\n}\n\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "WdtConfig.h.in",
          "type": "blob",
          "size": 0.8388671875,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// Source is WdtConfig.h auto generated by CMake from .in file\n#pragma once\n\n#include <fcntl.h>\n\n#define WDT_VERSION_MAJOR @WDT_VERSION_MAJOR@\n#define WDT_VERSION_MINOR @WDT_VERSION_MINOR@\n#define WDT_VERSION_BUILD @WDT_VERSION_PATCH@\n#define WDT_VERSION_STR \"@WDT_VERSION@\"\n// Tie minor and proto version for now\n#define WDT_PROTOCOL_VERSION WDT_VERSION_MINOR\n\n#cmakedefine HAS_POSIX_FALLOCATE 1\n#cmakedefine HAS_SYNC_FILE_RANGE 1\n#cmakedefine HAS_POSIX_MEMALIGN 1\n#cmakedefine HAS_POSIX_FADVISE 1\n\n#if (defined(HAS_POSIX_MEMALIGN) && defined(O_DIRECT)) || defined(F_NOCACHE)\n#define WDT_SUPPORTS_ODIRECT 1\n#endif\n#cmakedefine WDT_HAS_SOCKIOS_H\n"
        },
        {
          "name": "WdtOptions.cpp",
          "type": "blob",
          "size": 3.357421875,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <glog/logging.h>\n#include <wdt/Throttler.h>\n#include <wdt/WdtOptions.h>\n\nnamespace facebook {\nnamespace wdt {\n\n/**\n * Macro to change the default of some flags based on some other flag\n * Example of usage:\n *  if (enable_download_resumption) {\n *    CHANGE_IF_NOT_SPECIFIED(overwrite, userSpecifiedOptions, true,\n *                            \"(download resumption)\")\n *  }\n */\n#define CHANGE_IF_NOT_SPECIFIED(option, specifiedOptions, value, msg)         \\\n  if (specifiedOptions.find(#option) == specifiedOptions.end()) {             \\\n    WLOG(INFO) << \"Setting \" << #option << \" to \" << value << \" \" << msg;     \\\n    option = value;                                                           \\\n  } else {                                                                    \\\n    WLOG(INFO) << \"Not overwriting user specified \" << #option << \" \" << msg; \\\n  }\n\nconst char* WdtOptions::FLASH_OPTION_TYPE = \"flash\";\nconst char* WdtOptions::DISK_OPTION_TYPE = \"disk\";\n\nvoid WdtOptions::modifyOptions(\n    const std::string& optionType,\n    const std::set<std::string>& userSpecifiedOptions) {\n  if (optionType == DISK_OPTION_TYPE) {\n    std::string msg(\"(disk option type)\");\n    CHANGE_IF_NOT_SPECIFIED(num_ports, userSpecifiedOptions, 3, msg)\n    CHANGE_IF_NOT_SPECIFIED(block_size_mbytes, userSpecifiedOptions, -1, msg)\n    CHANGE_IF_NOT_SPECIFIED(disable_preallocation, userSpecifiedOptions, true,\n                            msg)\n    CHANGE_IF_NOT_SPECIFIED(resume_using_dir_tree, userSpecifiedOptions, true,\n                            msg)\n    return;\n  }\n  if (optionType != FLASH_OPTION_TYPE) {\n    WLOG(WARNING) << \"Invalid option type \" << optionType\n                  << \". Valid types are \" << FLASH_OPTION_TYPE << \", \"\n                  << DISK_OPTION_TYPE;\n  }\n  // options are initialized for flash. So, no need to change anything\n  if (userSpecifiedOptions.find(\"start_port\") != userSpecifiedOptions.end() &&\n      !static_ports) {\n    WLOG(INFO) << \"start_port is specified, setting static_ports true\";\n    static_ports = true;\n  }\n}\n\nbool WdtOptions::shouldPreallocateFiles() const {\n#ifdef HAS_POSIX_FALLOCATE\n  return !disable_preallocation;\n#else\n  return false;\n#endif\n}\n\nbool WdtOptions::isLogBasedResumption() const {\n  return enable_download_resumption && !resume_using_dir_tree;\n}\n\nbool WdtOptions::isDirectoryTreeBasedResumption() const {\n  return enable_download_resumption && resume_using_dir_tree;\n}\n\nThrottlerOptions WdtOptions::getThrottlerOptions() const {\n  ThrottlerOptions throttlerOptions;\n  throttlerOptions.avg_rate_per_sec = avg_mbytes_per_sec * kMbToB;\n  throttlerOptions.max_rate_per_sec = max_mbytes_per_sec * kMbToB;\n  throttlerOptions.throttler_bucket_limit = throttler_bucket_limit * kMbToB;\n  throttlerOptions.throttler_log_time_millis = throttler_log_time_millis;\n  // Expected request size equal to buffer size\n  throttlerOptions.single_request_limit = buffer_size;\n  return throttlerOptions;\n}\n\n/* static */\nconst WdtOptions& WdtOptions::get() {\n  return getMutable();\n}\n\nWdtOptions& WdtOptions::getMutable() {\n  static WdtOptions opt;\n  return opt;\n}\n\nvoid WdtOptions::copyInto(const WdtOptions& src) {\n  *this = src;\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "WdtOptions.h",
          "type": "blob",
          "size": 11.884765625,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n#include <unistd.h>\n#include <wdt/WdtConfig.h>\n#include <wdt/util/EncryptionUtils.h>\n\n#include <cstdint>\n#include <set>\n#include <string>\n\nnamespace facebook {\nnamespace wdt {\nstruct ThrottlerOptions;\n\n/**\n * A singleton class managing different options for WDT.\n * There will only be one instance of this class created\n * per creation of sender or receiver or both.\n * We can now support more than 1 instance of those per process\n * and attach a different one to sets of Sender/Receivers.\n */\nclass WdtOptions {\n public:\n  // WDT option types\n  static const char* FLASH_OPTION_TYPE;\n  static const char* DISK_OPTION_TYPE;\n\n  /**\n   * A static method that can be called to create\n   * the singleton copy of WdtOptions through the lifetime\n   * of wdt run.\n   * This is to be avoided, instead use the WdtOptions instance\n   * off each object.\n   * @deprecated\n   */\n  static const WdtOptions& get();\n  /**\n   * Method to get mutable copy of the singleton.\n   * This is to be avoided, instead use the WdtOptions instance\n   * off each object.\n   * @deprecated\n   */\n  static WdtOptions& getMutable();\n\n  /**\n   * Modifies options based on the type specified\n   *\n   * @param optionType           option type\n   * @param userSpecifiedOptions options specified by user, this options are not\n   *                             changed\n   */\n  void modifyOptions(const std::string& optionType,\n                     const std::set<std::string>& userSpecifiedOptions);\n\n  /**\n   * Use ipv6 while establishing connection.\n   * When both ipv6 and ipv4 are false we will try both\n   * if the host name has both.\n   */\n  bool ipv6{false};\n  /**\n   * Use ipv4, this takes precedence over ipv6\n   */\n  bool ipv4{false};\n\n  /**\n   * DSCP flag, see https://en.wikipedia.org/wiki/Differentiated_services.\n   */\n  int dscp{0};\n\n  /**\n   * Run wdt in a mode where the receiver doesn't\n   * write anything to the disk\n   */\n  bool skip_writes{false};\n  /**\n   * Continue the operation even if there are\n   * socket errors\n   */\n  bool ignore_open_errors{false};\n  /**\n   * Run the sender in two phases. First phase is\n   * discovery phase and the second one is sending\n   * the files over wire.\n   */\n  bool two_phases{false};\n  /**\n   * This option specifies whether wdt should\n   * discover symlinks and transfer those files\n   */\n  bool follow_symlinks{false};\n\n  /**\n   * Starting start_port for wdt. Number of ports allocated\n   * are contiguous sequence starting of numSockets\n   * starting from this start_port\n   */\n  int32_t start_port{22356};  // W (D) T = 0x5754\n  int32_t num_ports{8};\n  /**\n   * If true, will use start_port otherwise will use 0 / dynamic ports\n   */\n  bool static_ports{false};\n  /**\n   * Maximum buffer size for the write on the sender\n   * as well as while reading on receiver.\n   */\n  int32_t buffer_size{256 * 1024};\n  /**\n   * Maximum number of retries for the sender in case of\n   * failures before exiting\n   */\n  int32_t max_retries{20};\n  /**\n   * Time in ms to sleep before retrying after each connection\n   * failure\n   */\n  int32_t sleep_millis{50};\n\n  /**\n   * Specify the backlog to start the server socket with. Look\n   * into ServerSocket.h\n   */\n  int32_t backlog{1};\n\n  /**\n   * Rate at which we would like data to be transferred,\n   * specifying this as < 0 makes it unlimited\n   */\n  double avg_mbytes_per_sec{-1};\n  /**\n   * Rate at which tokens will be generated in TB algorithm.\n   * When we lag behind, this will allow us to go faster,\n   * specify as < 0 to make it unlimited. Specify as 0\n   * for auto configuring.\n   * auto conf as (kPeakMultiplier * avgMbytesPerSec_)\n   * Find details in Sender.cpp\n   */\n  double max_mbytes_per_sec{0};\n  /**\n   * Maximum bucket size of TB algorithm in mbytes\n   * This together with maxBytesPerSec_ will\n   * make for maximum burst rate. If specified as 0 it is\n   * auto configured in Sender.cpp\n   */\n  double throttler_bucket_limit{0};\n  /**\n   * Throttler logs statistics like average and max rate.\n   * This option specifies on how frequently should those\n   * be logged\n   */\n  int64_t throttler_log_time_millis{0};\n  /**\n   * Regex for the files to be included in discovery\n   */\n  std::string include_regex{\"\"};\n  /**\n   * Regex for the files to be excluded from the discovery\n   */\n  std::string exclude_regex{\"\"};\n  /**\n   * Regex for the directories that shouldn't be explored\n   */\n  std::string prune_dir_regex{\"\"};\n\n  /**\n   * Maximum number of times sender thread reconnects without making any\n   * progress\n   */\n  int max_transfer_retries{3};\n\n  /**\n   * True if full reporting is enabled. False otherwise\n   */\n  bool full_reporting{false};\n\n  /**\n   * IntervalMillis(in milliseconds) between progress reports\n   */\n  int progress_report_interval_millis{\n      isatty(STDOUT_FILENO) ? 20 : 200};  // default value is much higher for\n                                          // logging case, this is done to avoid\n                                          // flooding the log with progress\n                                          // information\n\n  /**\n   * block size, it is used to break bigger files into smaller chunks\n   * block_size of <= 0 disables block transfer\n   */\n  double block_size_mbytes{16};\n\n  /**\n   * timeout in accept call at the server\n   */\n  int32_t accept_timeout_millis{100};\n\n  /**\n   * maximum number of retries for accept call in joinable mode. we try to\n   * accept with timeout of accept_timeout_millis. first connection from sender\n   * must come before max_accept_retries.\n   */\n  int32_t max_accept_retries{500};\n\n  /**\n   * accept window size in millis. For a session, after the first connection is\n   * received, other connections must be received before this duration.\n   */\n  int32_t accept_window_millis{2000};\n\n  /**\n   * timeout for socket read\n   */\n  int read_timeout_millis{5000};\n\n  /**\n   * timeout for socket write\n   */\n  int write_timeout_millis{5000};\n\n  /**\n   * timeout for socket connect\n   */\n  int32_t connect_timeout_millis{1000};\n\n  /**\n   * interval in ms between abort checks\n   */\n  int abort_check_interval_millis{200};\n\n  /**\n   * Disk sync interval in mb. A negative value disables syncing\n   */\n  double disk_sync_interval_mb{0.5};\n\n  /**\n   * If true, each file is fsync'ed after its last block is\n   * received.\n   * Note that this can cause some performance hit on some filesystems, however\n   * if you disable it there no correctness guarantee will be provided.\n   */\n  bool fsync{true};\n\n  /**\n   * Intervals in millis after which progress reporter updates current\n   * throughput\n   */\n  int throughput_update_interval_millis{500};\n\n  /**\n   * Flag for turning on/off checksum. Redundant gcm in ENC_AES128_GCM.\n   */\n  bool enable_checksum{false};\n\n  /**\n   * If true, perf stats are collected and reported at the end of transfer\n   */\n  bool enable_perf_stat_collection{false};\n\n  /**\n   * Interval in milliseconds after which transfer log is written to disk\n   */\n  int transfer_log_write_interval_ms{100};\n\n  /**\n   * If true, compact transfer log if transfer finishes successfully\n   */\n  bool enable_transfer_log_compaction{false};\n\n  /**\n   * If true, download resumption is enabled\n   */\n  bool enable_download_resumption{false};\n\n  /**\n   * At transfer end, do not delete transfer log\n   */\n  bool keep_transfer_log{true};\n\n  /**\n   * If true, WDT does not verify sender ip during resumption\n   */\n  bool disable_sender_verification_during_resumption{false};\n\n  /**\n   * Max number of senders allowed globally\n   */\n  int global_sender_limit{0};\n\n  /**\n   * Max number of receivers allowed globally\n   */\n  int global_receiver_limit{0};\n\n  /**\n   * Max number of senders allowed per namespace\n   */\n  int namespace_sender_limit{0};\n\n  /**\n   * Max number of receivers allowed per namespace\n   */\n  int namespace_receiver_limit{1};\n\n  /**\n   * Read files in O_DIRECT\n   */\n  bool odirect_reads{false};\n\n  /**\n   * If true, files are not pre-allocated using posix_fallocate.\n   * This flag should not be used directly by wdt code. It should be accessed\n   * through shouldPreallocateFiles method.\n   */\n  bool disable_preallocation{false};\n\n  /**\n   * If true, destination directory tree is trusted during resumption. So, only\n   * the remaining portion of the files are transferred. This is only supported\n   * if preallocation and block mode is disabled.\n   */\n  bool resume_using_dir_tree{false};\n\n  /**\n   * If > 0 will open up to that number of files during discovery\n   * if 0 will not open any file during discovery\n   * if < 0 will try to open all the files during discovery (which may fail\n   * with too many open files errors)\n   */\n  int open_files_during_discovery{0};\n\n  /**\n   * If true, wdt can overwrite existing files\n   */\n  bool overwrite{false};\n\n  /**\n   * Extra time buffer to account for network when sender waits for receiver to\n   * finish processing buffered data\n   */\n  int drain_extra_ms{500};\n\n  /**\n   * Encryption type to use\n   */\n  std::string encryption_type{encryptionTypeToStr(ENC_AES128_GCM)};\n\n  /**\n   * Encryption tag verification interval in bytes. A value of zero disables\n   * incremental tag verification. In that case, tag only gets verified at the\n   * end.\n   */\n  int encryption_tag_interval_bytes{4 * 1024 * 1024};\n\n  /**\n   * send buffer size for Sender. If < = 0, buffer size is not set\n   */\n  int send_buffer_size{0};\n\n  /**\n   * receive buffer size for Receiver. If < = 0, buffer size is not set\n   */\n  int receive_buffer_size{0};\n\n  /**\n   * If true, extra files on the receiver side is deleted during resumption\n   */\n  bool delete_extra_files{false};\n\n  /**\n   * If true, fadvise is skipped after block write\n   */\n  bool skip_fadvise{false};\n\n  /**\n   * If true, periodic heart-beats from receiver to sender is enabled.\n   * The heart-beat interval is determined by the socket read timeout of the\n   * sender.\n   * WDT senders streams data and only waits for a receiver response after\n   * all the blocks are sent. Because of the high socket buffer sizes, it might\n   * take a long time for receiver to process all the bytes sent. So, for slower\n   * threads, there is significant difference between the time receiver\n   * processes all the bytes and the time sender finishes sending all the bytes.\n   * So, the sender might time out while waiting for the response from receiver.\n   * This happens a lot more for disks because of the lower io throughput.\n   * To solve this, receiver sends heart-beats to signal that it is sill\n   * processing data, and sender waits will it is still getting heart-beats.\n   */\n  bool enable_heart_beat{true};\n\n  /**\n   * Number of MBytes after which encryption iv is changed. A value of 0\n   * disables iv change.\n   */\n  int iv_change_interval_mb{32 * 1024};\n\n  /**\n   * Set O_CLOEXEC flag when open files.\n   */\n  bool close_on_exec{false};\n\n  /**\n   * @return    whether files should be pre-allocated or not\n   */\n  bool shouldPreallocateFiles() const;\n\n  /**\n   * @return    whether transfer log based resumption is enabled\n   */\n  bool isLogBasedResumption() const;\n\n  /**\n   * @return    whether directory tree based resumption is enabled\n   */\n  bool isDirectoryTreeBasedResumption() const;\n\n  /**\n   * @return    throttler options\n   */\n  ThrottlerOptions getThrottlerOptions() const;\n\n  // NOTE: any option added here should also be added to util/WdtFlags.cpp.inc\n\n  /**\n   * Initialize the fields of this object from another src one. ie makes 1 copy\n   * explicitly.\n   */\n  void copyInto(const WdtOptions& src);\n  /**\n   * This used to be a singleton (which as always is a pretty bad idea)\n   * so copy constructor and assignment operator were deleted\n   * We still want to avoid accidental copying around of a fairly\n   * big object thus the copyInto pattern above\n   */\n  WdtOptions(const WdtOptions&) = delete;\n  WdtOptions() {\n  }\n  ~WdtOptions() {\n  }\n\n private:\n  WdtOptions& operator=(const WdtOptions&) = default;\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "WdtResourceController.cpp",
          "type": "blob",
          "size": 22.2822265625,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <wdt/WdtResourceController.h>\n\nusing namespace std;\nconst int64_t kDelTimeToSleepMillis = 100;\n\nnamespace facebook {\nnamespace wdt {\n\nconst char *const WdtResourceController::kGlobalNamespace(\"Global\");\n\nvoid WdtControllerBase::updateMaxReceiversLimit(int64_t maxNumReceivers) {\n  GuardLock lock(controllerMutex_);\n  maxNumReceivers_ = maxNumReceivers;\n  WLOG(INFO) << \"Updated max number of receivers for \" << controllerName_\n             << \" to \" << maxNumReceivers_;\n}\n\nvoid WdtControllerBase::updateMaxSendersLimit(int64_t maxNumSenders) {\n  GuardLock lock(controllerMutex_);\n  maxNumSenders_ = maxNumSenders;\n  WLOG(INFO) << \"Updated max number of senders for \" << controllerName_\n             << \" to \" << maxNumSenders_;\n}\n\nWdtControllerBase::WdtControllerBase(const string &controllerName) {\n  controllerName_ = controllerName;\n}\n\nWdtNamespaceController::WdtNamespaceController(\n    const string &wdtNamespace, const WdtResourceController *const parent)\n    : WdtControllerBase(wdtNamespace), parent_(parent) {\n  auto &options = parent_->getOptions();\n  updateMaxSendersLimit(options.namespace_sender_limit);\n  updateMaxReceiversLimit(options.namespace_receiver_limit);\n}\n\nbool WdtNamespaceController::hasReceiverQuota() const {\n  GuardLock lock(controllerMutex_);\n  if (numReceivers_ >= maxNumReceivers_ && maxNumReceivers_ > 0) {\n    WLOG(WARNING) << \"Exceeded number of receivers for \" << controllerName_\n                  << \" Max number of receivers \" << maxNumReceivers_;\n    return false;\n  }\n  return true;\n}\n\nErrorCode WdtNamespaceController::createReceiver(\n    const WdtTransferRequest &request, const string &identifier,\n    ReceiverPtr &receiver) {\n  receiver = nullptr;\n  {\n    GuardLock lock(controllerMutex_);\n    // Check for already existing\n    auto it = receiversMap_.find(identifier);\n    if (it != receiversMap_.end()) {\n      WLOG(ERROR) << \"Receiver already created for transfer \" << identifier;\n      // Return it so the old one can potentially be aborted\n      receiver = it->second;\n      return ALREADY_EXISTS;\n    }\n    // Check for quotas\n    if (!hasReceiverQuota()) {\n      return QUOTA_EXCEEDED;\n    }\n    receiver = make_shared<Receiver>(request);\n    receiver->setThrottler(parent_->getWdtThrottler());\n    receiver->setWdtOptions(parent_->getOptions());\n    receiversMap_[identifier] = receiver;\n    ++numReceivers_;\n  }\n  return OK;\n}\n\nbool WdtNamespaceController::hasSenderQuota() const {\n  GuardLock lock(controllerMutex_);\n  if (numSenders_ >= maxNumSenders_ && maxNumSenders_ > 0) {\n    WLOG(WARNING) << \"Exceeded number of senders for \" << controllerName_\n                  << \" Max number of senders \" << maxNumSenders_;\n    return false;\n  }\n  return true;\n}\n\nErrorCode WdtNamespaceController::createSender(\n    const WdtTransferRequest &request, const string &identifier,\n    SenderPtr &sender) {\n  sender = nullptr;\n  {\n    GuardLock lock(controllerMutex_);\n    // Check for already existing\n    auto it = sendersMap_.find(identifier);\n    if (it != sendersMap_.end()) {\n      WLOG(ERROR) << \"Sender already created for transfer \" << identifier;\n      // Return it so the old one can potentially be aborted\n      sender = it->second;\n      return ALREADY_EXISTS;\n    }\n    /// Check for quotas\n    if (!hasSenderQuota()) {\n      return QUOTA_EXCEEDED;\n    }\n    sender = make_shared<Sender>(request);\n    sender->setThrottler(parent_->getWdtThrottler());\n    sender->setWdtOptions(parent_->getOptions());\n    sendersMap_[identifier] = sender;\n    ++numSenders_;\n  }\n  return OK;\n}\n\nErrorCode WdtNamespaceController::releaseReceiver(\n    const std::string &identifier) {\n  ReceiverPtr receiver = nullptr;\n  {\n    GuardLock lock(controllerMutex_);\n    auto it = receiversMap_.find(identifier);\n    if (it == receiversMap_.end()) {\n      WLOG(ERROR) << \"Couldn't find receiver to release with id \" << identifier\n                  << \" for \" << controllerName_;\n      return NOT_FOUND;\n    }\n    receiver = std::move(it->second);\n    receiversMap_.erase(it);\n    --numReceivers_;\n  }\n  // receiver will be deleted and logs printed by the destructor\n  // if no other thread has the shared pointer, that is...\n  WLOG(INFO) << \"Released the receiver with id \" << receiver->getTransferId();\n  return OK;\n}\n\nErrorCode WdtNamespaceController::releaseSender(const std::string &identifier) {\n  SenderPtr sender = nullptr;\n  {\n    GuardLock lock(controllerMutex_);\n    auto it = sendersMap_.find(identifier);\n    if (it == sendersMap_.end()) {\n      WLOG(ERROR) << \"Couldn't find sender to release with id \" << identifier\n                  << \" for \" << controllerName_;\n      return NOT_FOUND;\n    }\n    sender = std::move(it->second);\n    sendersMap_.erase(it);\n    --numSenders_;\n  }\n  WLOG(INFO) << \"Released the sender with id \" << sender->getTransferId();\n  return OK;\n}\n\nint64_t WdtNamespaceController::releaseAllSenders() {\n  vector<SenderPtr> senders;\n  {\n    GuardLock lock(controllerMutex_);\n    for (auto &senderPair : sendersMap_) {\n      senders.push_back(std::move(senderPair.second));\n    }\n    sendersMap_.clear();\n    numSenders_ = 0;\n  }\n  int numSenders = senders.size();\n  WVLOG(1) << \"Number of senders released \" << numSenders;\n  return numSenders;\n}\n\nvector<string> WdtNamespaceController::releaseStaleSenders() {\n  vector<SenderPtr> senders;\n  vector<string> erasedIds;\n  {\n    GuardLock lock(controllerMutex_);\n    for (auto it = sendersMap_.begin(); it != sendersMap_.end();) {\n      auto sender = it->second;\n      string identifier = it->first;\n      if (sender->isStale()) {\n        it = sendersMap_.erase(it);\n        erasedIds.push_back(identifier);\n        senders.push_back(std::move(sender));\n        --numSenders_;\n        continue;\n      }\n      it++;\n    }\n  }\n  WLOG(INFO) << \"Cleared \" << senders.size() << \" stale senders\";\n  return erasedIds;\n}\n\nint64_t WdtNamespaceController::releaseAllReceivers() {\n  vector<ReceiverPtr> receivers;\n  {\n    GuardLock lock(controllerMutex_);\n    for (auto &receiverPair : receiversMap_) {\n      receivers.push_back(std::move(receiverPair.second));\n    }\n    receiversMap_.clear();\n    numReceivers_ = 0;\n  }\n  int numReceivers = receivers.size();\n  WVLOG(1) << \"Number of receivers released \" << numReceivers;\n  return numReceivers;\n}\n\nvector<string> WdtNamespaceController::releaseStaleReceivers() {\n  vector<ReceiverPtr> receivers;\n  vector<string> erasedIds;\n  {\n    GuardLock lock(controllerMutex_);\n    for (auto it = receiversMap_.begin(); it != receiversMap_.end();) {\n      auto receiver = it->second;\n      string identifier = it->first;\n      if (receiver->isStale()) {\n        it = receiversMap_.erase(it);\n        erasedIds.push_back(identifier);\n        receivers.push_back(std::move(receiver));\n        --numReceivers_;\n        continue;\n      }\n      it++;\n    }\n  }\n  WLOG(INFO) << \"Cleared \" << receivers.size() << \"stale receivers\";\n  return erasedIds;\n}\n\nSenderPtr WdtNamespaceController::getSender(const string &identifier) const {\n  GuardLock lock(controllerMutex_);\n  auto it = sendersMap_.find(identifier);\n  if (it == sendersMap_.end()) {\n    WLOG(ERROR) << \"Couldn't find sender transfer-id \" << identifier << \" for \"\n                << controllerName_;\n    return nullptr;\n  }\n  return it->second;\n}\n\nReceiverPtr WdtNamespaceController::getReceiver(\n    const string &identifier) const {\n  GuardLock lock(controllerMutex_);\n  auto it = receiversMap_.find(identifier);\n  if (it == receiversMap_.end()) {\n    WLOG(ERROR) << \"Couldn't find receiver transfer-id \" << identifier\n                << \" for \" << controllerName_;\n    return nullptr;\n  }\n  return it->second;\n}\n\nvector<SenderPtr> WdtNamespaceController::getSenders() const {\n  vector<SenderPtr> senders;\n  GuardLock lock(controllerMutex_);\n  for (const auto &senderPair : sendersMap_) {\n    senders.push_back(senderPair.second);\n  }\n  return senders;\n}\n\nvector<ReceiverPtr> WdtNamespaceController::getReceivers() const {\n  vector<ReceiverPtr> receivers;\n  GuardLock lock(controllerMutex_);\n  for (const auto &receiverPair : receiversMap_) {\n    receivers.push_back(receiverPair.second);\n  }\n  return receivers;\n}\n\nvector<string> WdtNamespaceController::getSendersIds() const {\n  vector<string> senderIds;\n  GuardLock lock(controllerMutex_);\n  for (const auto &senderPair : sendersMap_) {\n    senderIds.push_back(senderPair.first);\n  }\n  return senderIds;\n}\n\nWdtNamespaceController::~WdtNamespaceController() {\n  // release is done by parent shutdown\n}\n\nWdtResourceController::WdtResourceController(\n    const WdtOptions &options, std::shared_ptr<Throttler> throttler)\n    : WdtControllerBase(\"_root controller_\"), options_(options) {\n  updateMaxSendersLimit(options.global_sender_limit);\n  updateMaxReceiversLimit(options.global_receiver_limit);\n  throttler_ = throttler;\n}\n\nWdtResourceController::WdtResourceController(const WdtOptions &options)\n    : WdtResourceController(\n          options, std::make_shared<Throttler>(options.getThrottlerOptions())) {\n}\n\nWdtResourceController::WdtResourceController()\n    : WdtResourceController(WdtOptions::get()) {\n}\n\nWdtResourceController *WdtResourceController::get() {\n  static WdtResourceController wdtController(WdtOptions::get());\n  return &wdtController;\n}\n\nvoid WdtResourceController::shutdown() {\n  WLOG(INFO) << \"Shutting down the controller (\" << numSenders_ << \" senders \"\n             << numReceivers_ << \" receivers)\";\n  GuardLock lock(controllerMutex_);\n  for (auto &namespaceController : namespaceMap_) {\n    NamespaceControllerPtr controller = namespaceController.second;\n    numSenders_ -= controller->releaseAllSenders();\n    numReceivers_ -= controller->releaseAllReceivers();\n    WVLOG(1) << \"Cleared out controller for \" << namespaceController.first;\n  }\n  namespaceMap_.clear();\n  WDT_CHECK_EQ(numReceivers_, 0);\n  WDT_CHECK_EQ(numSenders_, 0);\n  WVLOG(1) << \"Shutdown the wdt resource controller\";\n}\n\nWdtResourceController::~WdtResourceController() {\n  shutdown();\n}\n\nErrorCode WdtResourceController::getCounts(int32_t &numNamespaces,\n                                           int32_t &numSenders,\n                                           int32_t &numReceivers) {\n  GuardLock lock(controllerMutex_);\n  numSenders = numSenders_;\n  numReceivers = numReceivers_;\n  numNamespaces = namespaceMap_.size();\n  return OK;\n}\n\nbool WdtResourceController::hasSenderQuota(\n    const std::string &wdtNamespace) const {\n  const auto &controller = getNamespaceController(wdtNamespace);\n  return hasSenderQuotaInternal(controller);\n}\n\nbool WdtResourceController::hasSenderQuotaInternal(\n    const std::shared_ptr<WdtNamespaceController> &controller) const {\n  GuardLock lock(controllerMutex_);\n  if ((numSenders_ >= maxNumSenders_) && (maxNumSenders_ > 0)) {\n    WLOG(WARNING) << \"Exceeded quota on max senders. \" << \"Max num senders \"\n                  << maxNumSenders_ << \" and we have \" << numSenders_\n                  << \" existing senders\";\n    return false;\n  }\n  if (controller && !controller->hasSenderQuota()) {\n    return false;\n  }\n  return true;\n}\n\nErrorCode WdtResourceController::createSender(\n    const std::string &wdtNamespace, const std::string &identifier,\n    const WdtTransferRequest &wdtOperationRequest, SenderPtr &sender) {\n  NamespaceControllerPtr controller = nullptr;\n  sender = nullptr;\n  {\n    GuardLock lock(controllerMutex_);\n    controller = getNamespaceController(wdtNamespace);\n    if (!controller) {\n      if (strictRegistration_) {\n        WLOG(WARNING) << \"Couldn't find controller for \" << wdtNamespace;\n        return NOT_FOUND;\n      } else {\n        WLOG(INFO) << \"First time \"\n                   << (wdtNamespace.empty() ? \"(default)\" : wdtNamespace)\n                   << \" is seen, creating.\";\n        controller = createNamespaceController(wdtNamespace);\n      }\n    }\n    if (!hasSenderQuotaInternal(controller)) {\n      WLOG(ERROR) << \"No quota for more sender.\";\n      return QUOTA_EXCEEDED;\n    }\n    ++numSenders_;\n  }\n  // TODO: not thread safe reading from options_\n  throttler_->setThrottlerRates(options_.getThrottlerOptions());\n  ErrorCode code =\n      controller->createSender(wdtOperationRequest, identifier, sender);\n  if (code != OK) {\n    GuardLock lock(controllerMutex_);\n    --numSenders_;\n    WLOG(ERROR) << \"Failed in creating sender for \" << wdtNamespace << \" \"\n                << errorCodeToStr(code);\n  } else {\n    WLOG(INFO) << \"Successfully added a sender for \" << wdtNamespace\n               << \" identifier \" << identifier;\n  }\n  return code;\n}\n\nbool WdtResourceController::hasReceiverQuota(\n    const std::string &wdtNamespace) const {\n  const auto &controller = getNamespaceController(wdtNamespace);\n  return hasReceiverQuotaInternal(controller);\n}\n\nbool WdtResourceController::hasReceiverQuotaInternal(\n    const std::shared_ptr<WdtNamespaceController> &controller) const {\n  GuardLock lock(controllerMutex_);\n  if ((numReceivers_ >= maxNumReceivers_) && (maxNumReceivers_ > 0)) {\n    WLOG(WARNING) << \"Exceeded quota on max receivers. \" << \"Max num receivers \"\n                  << maxNumReceivers_ << \" and we have \" << numReceivers_\n                  << \" existing receivers\";\n    return false;\n  }\n  if (controller && !controller->hasReceiverQuota()) {\n    return false;\n  }\n  return true;\n}\n\nErrorCode WdtResourceController::createReceiver(\n    const std::string &wdtNamespace, const string &identifier,\n    const WdtTransferRequest &wdtOperationRequest, ReceiverPtr &receiver) {\n  NamespaceControllerPtr controller = nullptr;\n  receiver = nullptr;\n  {\n    GuardLock lock(controllerMutex_);\n    controller = getNamespaceController(wdtNamespace);\n    if (!controller) {\n      if (strictRegistration_) {\n        WLOG(WARNING) << \"Couldn't find controller for \" << wdtNamespace;\n        return NOT_FOUND;\n      } else {\n        WLOG(INFO) << \"First time \" << wdtNamespace << \" is seen, creating.\";\n        controller = createNamespaceController(wdtNamespace);\n      }\n    }\n    if (!hasReceiverQuotaInternal(controller)) {\n      WLOG(ERROR) << \"No quota for more receiver.\";\n      return QUOTA_EXCEEDED;\n    }\n    ++numReceivers_;\n  }\n  // TODO: not thread safe reading from options_\n  throttler_->setThrottlerRates(options_.getThrottlerOptions());\n  ErrorCode code =\n      controller->createReceiver(wdtOperationRequest, identifier, receiver);\n  if (code != OK) {\n    GuardLock lock(controllerMutex_);\n    --numReceivers_;\n    WLOG(ERROR) << \"Failed in creating receiver for \" << wdtNamespace << \" \"\n                << errorCodeToStr(code);\n  } else {\n    WLOG(INFO) << \"Successfully added a receiver for \" << wdtNamespace\n               << \" identifier \" << identifier;\n  }\n  return code;\n}\n\nErrorCode WdtResourceController::releaseSender(const std::string &wdtNamespace,\n                                               const std::string &identifier) {\n  NamespaceControllerPtr controller = nullptr;\n  {\n    controller = getNamespaceController(wdtNamespace);\n    if (!controller) {\n      WLOG(WARNING) << \"Couldn't find controller for \" << wdtNamespace;\n      return ERROR;\n    }\n  }\n  if (controller->releaseSender(identifier) == OK) {\n    GuardLock lock(controllerMutex_);\n    --numSenders_;\n    return OK;\n  }\n  WLOG(ERROR) << \"Couldn't release sender \" << identifier << \" for \"\n              << wdtNamespace;\n  return ERROR;\n}\n\nErrorCode WdtResourceController::releaseAllSenders(\n    const std::string &wdtNamespace) {\n  NamespaceControllerPtr controller = nullptr;\n  {\n    controller = getNamespaceController(wdtNamespace);\n    if (!controller) {\n      WLOG(WARNING) << \"Couldn't find controller for \" << wdtNamespace;\n      return ERROR;\n    }\n  }\n  int64_t numSenders = controller->releaseAllSenders();\n  if (numSenders > 0) {\n    GuardLock lock(controllerMutex_);\n    numSenders_ -= numSenders;\n  }\n  return OK;\n}\n\nErrorCode WdtResourceController::releaseReceiver(\n    const std::string &wdtNamespace, const std::string &identifier) {\n  NamespaceControllerPtr controller = nullptr;\n  {\n    controller = getNamespaceController(wdtNamespace);\n    if (!controller) {\n      WLOG(WARNING) << \"Couldn't find controller for \" << wdtNamespace;\n      return ERROR;\n    }\n  }\n  if (controller->releaseReceiver(identifier) == OK) {\n    GuardLock lock(controllerMutex_);\n    --numReceivers_;\n    return OK;\n  }\n  WLOG(ERROR) << \"Couldn't release receiver \" << identifier << \" for \"\n              << wdtNamespace;\n\n  return ERROR;\n}\n\nErrorCode WdtResourceController::releaseAllReceivers(\n    const std::string &wdtNamespace) {\n  NamespaceControllerPtr controller = nullptr;\n  {\n    controller = getNamespaceController(wdtNamespace);\n    if (!controller) {\n      WLOG(WARNING) << \"Couldn't find controller for \" << wdtNamespace;\n      return ERROR;\n    }\n  }\n  int64_t numReceivers = controller->releaseAllReceivers();\n  if (numReceivers > 0) {\n    GuardLock lock(controllerMutex_);\n    numReceivers_ -= numReceivers;\n  }\n  return OK;\n}\n\nSenderPtr WdtResourceController::getSender(const string &wdtNamespace,\n                                           const string &identifier) const {\n  NamespaceControllerPtr controller = nullptr;\n  controller = getNamespaceController(wdtNamespace);\n  if (!controller) {\n    WLOG(ERROR) << \"Couldn't find the controller for \" << wdtNamespace;\n    return nullptr;\n  }\n  return controller->getSender(identifier);\n}\n\nvector<SenderPtr> WdtResourceController::getAllSenders(\n    const string &wdtNamespace) const {\n  NamespaceControllerPtr controller = nullptr;\n  controller = getNamespaceController(wdtNamespace);\n  if (!controller) {\n    WLOG(ERROR) << \"Couldn't find the controller for \" << wdtNamespace;\n    return vector<SenderPtr>();\n  }\n  return controller->getSenders();\n}\n\nErrorCode WdtResourceController::releaseStaleSenders(\n    const string &wdtNamespace, vector<string> &erasedIds) {\n  NamespaceControllerPtr controller = nullptr;\n  controller = getNamespaceController(wdtNamespace);\n  if (!controller) {\n    WLOG(ERROR) << \"Couldn't find the controller for \" << wdtNamespace;\n    return NOT_FOUND;\n  }\n  erasedIds = controller->releaseStaleSenders();\n  if (erasedIds.size() > 0) {\n    GuardLock lock(controllerMutex_);\n    numSenders_ -= erasedIds.size();\n  }\n  return OK;\n}\n\nReceiverPtr WdtResourceController::getReceiver(const string &wdtNamespace,\n                                               const string &identifier) const {\n  NamespaceControllerPtr controller = nullptr;\n  controller = getNamespaceController(wdtNamespace);\n  if (!controller) {\n    WLOG(ERROR) << \"Couldn't find the controller for \" << wdtNamespace;\n    return nullptr;\n  }\n  return controller->getReceiver(identifier);\n}\n\nvector<ReceiverPtr> WdtResourceController::getAllReceivers(\n    const string &wdtNamespace) const {\n  NamespaceControllerPtr controller = nullptr;\n  controller = getNamespaceController(wdtNamespace);\n  if (!controller) {\n    WLOG(ERROR) << \"Couldn't find the controller for \" << wdtNamespace;\n    return vector<ReceiverPtr>();\n  }\n  return controller->getReceivers();\n}\n\nstd::vector<std::string> WdtResourceController::getAllSendersIds(\n    const string &wdtNamespace) const {\n  vector<string> senderIds;\n  NamespaceControllerPtr controller = nullptr;\n  controller = getNamespaceController(wdtNamespace);\n  if (!controller) {\n    WLOG(ERROR) << \"Couldn't find the controller for \" << wdtNamespace;\n    return senderIds;\n  }\n  return controller->getSendersIds();\n}\n\nErrorCode WdtResourceController::releaseStaleReceivers(\n    const string &wdtNamespace, vector<string> &erasedIds) {\n  NamespaceControllerPtr controller = nullptr;\n  controller = getNamespaceController(wdtNamespace);\n  if (!controller) {\n    WLOG(ERROR) << \"Couldn't find the controller for \" << wdtNamespace;\n    return NOT_FOUND;\n  }\n  erasedIds = controller->releaseStaleReceivers();\n  if (erasedIds.size() > 0) {\n    GuardLock lock(controllerMutex_);\n    numReceivers_ -= erasedIds.size();\n  }\n  return OK;\n}\n\nWdtResourceController::NamespaceControllerPtr\nWdtResourceController::createNamespaceController(\n    const std::string &wdtNamespace) {\n  auto namespaceController =\n      make_shared<WdtNamespaceController>(wdtNamespace, this);\n  namespaceMap_[wdtNamespace] = namespaceController;\n  return namespaceController;\n}\n\nErrorCode WdtResourceController::registerWdtNamespace(\n    const std::string &wdtNamespace) {\n  GuardLock lock(controllerMutex_);\n  if (getNamespaceController(wdtNamespace)) {\n    WLOG(INFO) << \"Found existing controller for \" << wdtNamespace;\n    return OK;\n  }\n  createNamespaceController(wdtNamespace);\n  return OK;\n}\n\nErrorCode WdtResourceController::deRegisterWdtNamespace(\n    const std::string &wdtNamespace) {\n  NamespaceControllerPtr controller;\n  {\n    GuardLock lock(controllerMutex_);\n    auto it = namespaceMap_.find(wdtNamespace);\n    if (it != namespaceMap_.end()) {\n      controller = std::move(it->second);\n    } else {\n      WLOG(ERROR) << \"Couldn't find the namespace \" << wdtNamespace;\n      return ERROR;\n    }\n    namespaceMap_.erase(it);\n  }\n  int numSenders = controller->releaseAllSenders();\n  int numReceivers = controller->releaseAllReceivers();\n\n  {\n    GuardLock lock(controllerMutex_);\n    numSenders_ -= numSenders;\n    numReceivers_ -= numReceivers;\n  }\n\n  while (controller.use_count() > 1) {\n    /* sleep override */\n    usleep(kDelTimeToSleepMillis * 1000);\n    WLOG(INFO) << \"Trying to delete the namespace \" << wdtNamespace;\n  }\n  WLOG(INFO) << \"Deleted the namespace \" << wdtNamespace;\n  return OK;\n}\n\nvoid WdtResourceController::updateMaxReceiversLimit(\n    const std::string &wdtNamespace, int64_t maxNumReceivers) {\n  auto controller = getNamespaceController(wdtNamespace);\n  if (controller) {\n    controller->updateMaxReceiversLimit(maxNumReceivers);\n  }\n}\n\nvoid WdtResourceController::updateMaxSendersLimit(\n    const std::string &wdtNamespace, int64_t maxNumSenders) {\n  auto controller = getNamespaceController(wdtNamespace);\n  if (controller) {\n    controller->updateMaxSendersLimit(maxNumSenders);\n  }\n}\n\nstd::shared_ptr<Throttler> WdtResourceController::getWdtThrottler() const {\n  return throttler_;\n}\n\nconst WdtOptions &WdtResourceController::getOptions() const {\n  return options_;\n}\n\n// TODO: consider putting strict/not strict handling logic here...\nshared_ptr<WdtNamespaceController>\nWdtResourceController::getNamespaceController(\n    const string &wdtNamespace) const {\n  GuardLock lock(controllerMutex_);\n  auto it = namespaceMap_.find(wdtNamespace);\n  if (it != namespaceMap_.end()) {\n    return it->second;\n  }\n  return nullptr;\n}\n\nvoid WdtResourceController::requireRegistration(bool strict) {\n  strictRegistration_ = strict;\n}\n\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "WdtResourceController.h",
          "type": "blob",
          "size": 9.76171875,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n#include <wdt/ErrorCodes.h>\n#include <wdt/Receiver.h>\n#include <wdt/Sender.h>\n\n#include <unordered_map>\n#include <vector>\n\nnamespace facebook {\nnamespace wdt {\n\ntypedef std::shared_ptr<Receiver> ReceiverPtr;\ntypedef std::shared_ptr<Sender> SenderPtr;\n\n/**\n * Base class for both wdt global and namespace controller\n */\nclass WdtControllerBase {\n public:\n  /// Constructor with a name for the controller\n  explicit WdtControllerBase(const std::string &controllerName);\n\n  /// Destructor\n  virtual ~WdtControllerBase() {\n  }\n\n  /// Update max receivers limit\n  virtual void updateMaxReceiversLimit(int64_t maxNumReceivers);\n\n  /// Update max senders limit\n  virtual void updateMaxSendersLimit(int64_t maxNumSenders);\n\n protected:\n  using GuardLock = std::unique_lock<std::recursive_mutex>;\n  /// Number of active receivers\n  int64_t numReceivers_{0};\n\n  /// Number of active senders\n  int64_t numSenders_{0};\n\n  /// Maximum number of senders allowed for this namespace\n  int64_t maxNumSenders_{0};\n\n  /// Maximum number of receivers allowed for this namespace\n  int64_t maxNumReceivers_{0};\n\n  /// Mutex that protects all the private members of this class\n  mutable std::recursive_mutex controllerMutex_;\n\n  /// Name of the resource controller\n  std::string controllerName_;\n};\n\nclass WdtResourceController;\n\n/**\n * Controller defined per namespace if the user wants to divide\n * things between different namespaces (ex db shards)\n */\nclass WdtNamespaceController : public WdtControllerBase {\n public:\n  /// Constructor with a name for namespace\n  WdtNamespaceController(const std::string &wdtNamespace,\n                         const WdtResourceController *const parent);\n\n  /// Is free to create sender.\n  bool hasSenderQuota() const;\n\n  /// Add a receiver for this namespace with identifier\n  ErrorCode createReceiver(const WdtTransferRequest &request,\n                           const std::string &identifier,\n                           ReceiverPtr &receiver);\n\n  /// Is free to create receiver.\n  bool hasReceiverQuota() const;\n\n  /// Add a sender for this namespace with identifier\n  ErrorCode createSender(const WdtTransferRequest &request,\n                         const std::string &identifier, SenderPtr &sender);\n\n  /// Delete a receiver from this namespace\n  ErrorCode releaseReceiver(const std::string &identifier);\n\n  /// Delete a sender from this namespace\n  ErrorCode releaseSender(const std::string &identifier);\n\n  /// Releases all senders in this namespace\n  int64_t releaseAllSenders();\n\n  /// Releases all receivers in this namespace\n  int64_t releaseAllReceivers();\n\n  /**\n   * Get the sender you created by the createSender API\n   * using the same identifier you mentioned before\n   */\n  SenderPtr getSender(const std::string &identifier) const;\n\n  /**\n   * Get the receiver you created by the createReceiver API\n   * using the same identifier you mentioned before\n   */\n  ReceiverPtr getReceiver(const std::string &identifier) const;\n\n  /// Get all senders\n  std::vector<SenderPtr> getSenders() const;\n\n  /// Get all receivers\n  std::vector<ReceiverPtr> getReceivers() const;\n\n  // Get all senders ids\n  std::vector<std::string> getSendersIds() const;\n\n  /// Clear the senders that are not active anymore\n  std::vector<std::string> releaseStaleSenders();\n\n  /// Clear the receivers that are not active anymore\n  std::vector<std::string> releaseStaleReceivers();\n\n  /// Destructor, clears the senders and receivers\n  ~WdtNamespaceController() override;\n\n private:\n  /// Map of receivers associated with identifier\n  std::unordered_map<std::string, ReceiverPtr> receiversMap_;\n\n  /// Map of senders associated with identifier\n  std::unordered_map<std::string, SenderPtr> sendersMap_;\n\n  /// Throttler for this namespace\n  const WdtResourceController *const parent_;\n};\n\n/**\n * A generic resource controller for wdt objects\n * User can set the maximum limit for receiver/sender\n * and organize them in different namespace\n */\nclass WdtResourceController : public WdtControllerBase {\n public:\n  /// resource controller should take the option as reference so that it can be\n  /// changed later from the parent object\n  WdtResourceController(const WdtOptions &options,\n                        std::shared_ptr<Throttler> throttler);\n  explicit WdtResourceController(const WdtOptions &options);\n  WdtResourceController();\n\n  /// Is free to create sender specified by namespace.\n  bool hasSenderQuota(const std::string &wdtNamespace) const;\n\n  /**\n   * Add a sender specified by namespace and a identifier.\n   * You can get this sender back by using the same identifier\n   */\n  ErrorCode createSender(const std::string &wdtNamespace,\n                         const std::string &identifier,\n                         const WdtTransferRequest &request, SenderPtr &sender);\n\n  /// Is free to create receiver specified by namespace.\n  bool hasReceiverQuota(const std::string &wdtNamespace) const;\n\n  /// Add a receiver specified with namespace and identifier\n  ErrorCode createReceiver(const std::string &wdtNamespace,\n                           const std::string &identifier,\n                           const WdtTransferRequest &request,\n                           ReceiverPtr &receiver);\n\n  /// Release a sender specified with namespace and identifier\n  ErrorCode releaseSender(const std::string &wdtNamespace,\n                          const std::string &identifier);\n\n  /// Release a receiver specified with namespace and identifier\n  ErrorCode releaseReceiver(const std::string &wdtNamespace,\n                            const std::string &identifier);\n\n  /// Register a wdt namespace (if strict mode)\n  ErrorCode registerWdtNamespace(const std::string &wdtNamespace);\n\n  /// De register a wdt namespace\n  ErrorCode deRegisterWdtNamespace(const std::string &wdtNamespace);\n\n  /// Use the base class methods for global limits\n  using WdtControllerBase::updateMaxReceiversLimit;\n  using WdtControllerBase::updateMaxSendersLimit;\n\n  /// Update max receivers limit of namespace\n  void updateMaxReceiversLimit(const std::string &wdtNamespace,\n                               int64_t maxNumReceivers);\n\n  /// Update max senders limit of namespace\n  void updateMaxSendersLimit(const std::string &wdtNamespace,\n                             int64_t maxNumSenders);\n\n  /// Release all senders in the specified namespace\n  ErrorCode releaseAllSenders(const std::string &wdtNamespace);\n\n  /// Releases all receivers in specified namespace\n  ErrorCode releaseAllReceivers(const std::string &wdtNamespace);\n\n  /// Get a particular sender from a wdt namespace\n  SenderPtr getSender(const std::string &wdtNamespace,\n                      const std::string &identifier) const;\n\n  /// Get a particular receiver from a wdt namespace\n  ReceiverPtr getReceiver(const std::string &wdtNamespace,\n                          const std::string &identifier) const;\n\n  /// Get all senders in a namespace\n  std::vector<SenderPtr> getAllSenders(const std::string &wdtNamespace) const;\n\n  /// Get all senders ids in a namespace\n  std::vector<std::string> getAllSendersIds(\n      const std::string &wdtNamespace) const;\n\n  /// Get all receivers in a namespace\n  std::vector<ReceiverPtr> getAllReceivers(\n      const std::string &wdtNamespace) const;\n\n  /// Clear the senders that are no longer active.\n  ErrorCode releaseStaleSenders(const std::string &wdtNamespace,\n                                std::vector<std::string> &erasedIds);\n\n  /// Clear the receivers that are no longer active\n  ErrorCode releaseStaleReceivers(const std::string &wdtNamespace,\n                                  std::vector<std::string> &erasedIds);\n\n  /**\n   * Call with true to require registerWdtNameSpace() to be called\n   * before requesting sender/receiver for that namespace.\n   */\n  void requireRegistration(bool isStrict);\n\n  /// Cleanly shuts down the controller\n  void shutdown();\n\n  /// @return     Singleton instance of the controller\n  static WdtResourceController *get();\n\n  /// Destructor for the global resource controller\n  ~WdtResourceController() override;\n\n  /// Default global namespace\n  static const char *const kGlobalNamespace;\n\n  /// Return current counts\n  ErrorCode getCounts(int32_t &numNamespaces, int32_t &numSenders,\n                      int32_t &numReceivers);\n\n  /**\n   * getter for throttler.\n   * setThrottlerRates to this throttler may not take effect. Instead, update\n   * WdtOptions accordingly.\n   * Applications have to register transfers with the throttler, and at the end\n   * de-register it. For example-\n   * throttler->startTransfer();\n   * ...\n   * throttler->limit(numBytes);\n   * ...\n   * throttler->endTransfer();\n   */\n  std::shared_ptr<Throttler> getWdtThrottler() const;\n\n  const WdtOptions &getOptions() const;\n\n protected:\n  typedef std::shared_ptr<WdtNamespaceController> NamespaceControllerPtr;\n  /// Get the namespace controller\n  NamespaceControllerPtr getNamespaceController(\n      const std::string &wdtNamespace) const;\n\n private:\n  NamespaceControllerPtr createNamespaceController(const std::string &name);\n  /// Map containing the resource controller per namespace\n  std::unordered_map<std::string, NamespaceControllerPtr> namespaceMap_;\n  /// Whether namespace need to be created explictly\n  bool strictRegistration_{false};\n  /// Throttler for all the namespaces\n  std::shared_ptr<Throttler> throttler_{nullptr};\n  const WdtOptions &options_;\n  /// Internal method for checking hasSenderQuota & hasReceiverQuota\n  bool hasSenderQuotaInternal(const std::shared_ptr<WdtNamespaceController>\n                                  &controller = nullptr) const;\n  bool hasReceiverQuotaInternal(const std::shared_ptr<WdtNamespaceController>\n                                    &controller = nullptr) const;\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "WdtThread.cpp",
          "type": "blob",
          "size": 1.3974609375,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <wdt/WdtThread.h>\n\nusing namespace std;\n\nnamespace facebook {\nnamespace wdt {\n\nTransferStats WdtThread::moveStats() {\n  return std::move(threadStats_);\n}\n\nconst PerfStatReport &WdtThread::getPerfReport() const {\n  return threadCtx_->getPerfReport();\n}\n\nconst TransferStats &WdtThread::getTransferStats() const {\n  return threadStats_;\n}\n\nvoid WdtThread::startThread() {\n  if (threadPtr_) {\n    WDT_CHECK(false) << \"There is a already a thread running \" << threadIndex_\n                     << \" \" << getPort();\n  }\n  auto state = controller_->getState(threadIndex_);\n  // Check the state should be running here\n  WDT_CHECK_EQ(state, RUNNING);\n  threadPtr_.reset(new std::thread(&WdtThread::start, this));\n}\n\nErrorCode WdtThread::finish() {\n  if (!threadPtr_) {\n    WLOG(ERROR) << \"Finish called on an instance while no thread has been \"\n                << \" created to do any work\";\n    return ERROR;\n  }\n  threadPtr_->join();\n  threadPtr_.reset();\n  return OK;\n}\n\nWdtThread::~WdtThread() {\n  if (threadPtr_) {\n    WLOG(INFO) << threadIndex_\n               << \" has an alive thread while the instance is being \"\n               << \"destructed\";\n    finish();\n  }\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "WdtThread.h",
          "type": "blob",
          "size": 3.115234375,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n#include <folly/lang/Bits.h>\n#include <wdt/ErrorCodes.h>\n#include <wdt/Protocol.h>\n#include <wdt/util/CommonImpl.h>\n#include <wdt/util/ThreadsController.h>\n#include <wdt/util/WdtSocket.h>\n\n#include <memory>\n#include <thread>\n\nnamespace facebook {\nnamespace wdt {\n\nclass ThreadsController;\n\n/// Common functionality and settings between SenderThread and ReceiverThread\nclass WdtThread {\n public:\n  /// Constructor for wdt thread\n  WdtThread(const WdtOptions &options, int threadIndex, int port,\n            int protocolVersion, ThreadsController *controller)\n      : options_(options),\n        port_(port),\n        threadProtocolVersion_(protocolVersion) {\n    controller_ = controller;\n    threadCtx_ = std::make_unique<ThreadCtx>(\n        options, /* allocate buffer */ true, threadIndex);\n    const Buffer *buffer = threadCtx_->getBuffer();\n    WDT_CHECK(buffer);\n    buf_ = buffer->getData();\n    bufSize_ = buffer->getSize();\n    threadIndex_ = threadCtx_->getThreadIndex();\n    lastHeartBeatTime_ = Clock::now();\n  }\n  /// Starts a thread which runs the wdt functionality\n  void startThread();\n\n  /// Get the perf stats of the transfer for this thread\n  const PerfStatReport &getPerfReport() const;\n\n  /// Initializes the wdt thread before starting\n  virtual ErrorCode init() = 0;\n\n  /// Conclude the thread transfer\n  virtual ErrorCode finish();\n\n  /// Moves the local stats into a new instance\n  TransferStats moveStats();\n\n  /// Get the transfer stats recorded by this thread\n  const TransferStats &getTransferStats() const;\n\n  /// Reset the wdt thread\n  virtual void reset() = 0;\n\n  /// Get the port this thread is running on\n  virtual int getPort() const = 0;\n\n  // TODO remove this function\n  virtual int getNegotiatedProtocol() const {\n    return threadProtocolVersion_;\n  }\n\n  virtual ~WdtThread();\n\n protected:\n  /// The main entry point of the thread\n  virtual void start() = 0;\n\n  std::unique_ptr<ThreadCtx> threadCtx_{nullptr};\n\n  /// buffer pointer. this points to the buffer in threadCtx_\n  char *buf_{nullptr};\n\n  /// buffer size. this is the size of buffer in threadCtx_\n  int64_t bufSize_{0};\n\n  /// reference to parent options\n  const WdtOptions &options_;\n\n  /// Index of this thread with respect to other threads\n  int threadIndex_;\n\n  /// port number for this thread\n  const int port_;\n\n  /// Copy of the protocol version that might be changed\n  int threadProtocolVersion_;\n\n  /// whether heart-beat is enabled\n  bool enableHeartBeat_{false};\n\n  Clock::time_point lastHeartBeatTime_;\n\n  /// possible footer types\n  enum FooterType {\n    NO_FOOTER,\n    CHECKSUM_FOOTER,\n  };\n\n  FooterType footerType_{NO_FOOTER};\n\n  /// Transfer stats for this thread\n  TransferStats threadStats_{true};\n\n  /// Thread controller for all the sender threads\n  ThreadsController *controller_{nullptr};\n\n  /// Pointer to the std::thread executing the transfer\n  std::unique_ptr<std::thread> threadPtr_{nullptr};\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "WdtTransferRequest.cpp",
          "type": "blob",
          "size": 15.431640625,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <folly/Conv.h>\n#include <folly/Range.h>\n#include <wdt/WdtTransferRequest.h>\n\n#include <ctime>\n\nusing namespace std;\nusing folly::StringPiece;\n\nnamespace facebook {\nnamespace wdt {\n\nWdtUri::WdtUri(const string& url) {\n  errorCode_ = process(url);\n}\n\nvoid WdtUri::setHostName(const string& hostName) {\n  hostName_ = hostName;\n}\n\nvoid WdtUri::setPort(int32_t port) {\n  port_ = port;\n}\n\nvoid WdtUri::setQueryParam(const string& key, const string& value) {\n  queryParams_[key] = value;\n}\n\nErrorCode WdtUri::getErrorCode() const {\n  return errorCode_;\n}\n\n/* static */\nchar WdtUri::toHex(unsigned char v) {\n  WDT_CHECK_LT(v, 16);\n  if (v <= 9) {\n    return '0' + v;\n  }\n  return 'a' + v - 10;\n}\n/* static */\nint WdtUri::fromHex(char c) {\n  if (c < '0' || (c > '9' && (c < 'a' || c > 'f'))) {\n    return -1;  // invalid not 0-9a-f hex char\n  }\n  if (c <= '9') {\n    return c - '0';\n  }\n  return c - 'a' + 10;\n}\n\n/* static */\nstring WdtUri::escape(const string& binaryStr) {\n  string res;\n  res.reserve(binaryStr.length());  // most time nothing to escape\n  for (unsigned char c : binaryStr) {\n    // Allow 0-9 A-Z a-z (alphanum) and , : . _ + - (note that : is arguable)\n    // (and we could use an array lookup instead of a bunch of ||s)\n    if (c == ',' || c == ':' || c == '.' || c == '_' || c == '+' || c == '-' ||\n        (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||\n        (c >= '0' && c <= '9')) {\n      res.push_back(c);\n    } else {\n      res.push_back('%');\n      res.push_back(toHex(c >> 4));\n      res.push_back(toHex(c & 0xf));\n    }\n  }\n  return res;\n}\n\n/* static */\nbool WdtUri::unescape(string& res, StringPiece escapedValue) {\n  res.reserve(res.length() + escapedValue.size());\n  for (size_t i = 0; i < escapedValue.size(); ++i) {\n    char c = escapedValue[i];\n    if (c != '%') {\n      res.push_back(c);\n      continue;\n    }\n    i += 2;\n    // Make sure there room for both hex\n    if (i >= escapedValue.size()) {\n      WLOG(ERROR) << \"Can't decode \\\"\" << escapedValue\n                  << \"\\\" end with unfinished % sequence\";\n      return false;\n    }\n    const int msb = fromHex(escapedValue[i - 1]);\n    const int lsb = fromHex(escapedValue[i]);\n    if (msb < 0 || lsb < 0) {\n      WLOG(ERROR) << \"Can't decode \\\"\" << escapedValue\n                  << \"\\\" % sequence with non 0-9a-f characters\";\n      return false;\n    }\n    res.push_back(msb << 4 | lsb);\n  }\n  return true;\n}\n\nstring WdtUri::generateUrl() const {\n  string url = WDT_URL_PREFIX;\n  if (hostName_.find(':') != string::npos) {\n    // Enclosing ipv6 address by [] so that it can be escaped\n    folly::toAppend('[', hostName_, ']', &url);\n  } else {\n    folly::toAppend(hostName_, &url);\n  }\n  if (port_ > 0) {\n    // Must have positive port value\n    folly::toAppend(\":\", port_, &url);\n  }\n  char prefix = '?';\n  for (const auto& pair : queryParams_) {\n    if (!pair.second.empty()) {\n      string value = WdtUri::escape(pair.second);\n      folly::toAppend(prefix, pair.first, \"=\", value, &url);\n      prefix = '&';\n    }\n  }\n  return url;\n}\n\nErrorCode WdtUri::process(const string& url) {\n  if (url.size() < WDT_URL_PREFIX.size()) {\n    WLOG(ERROR) << \"Url doesn't specify wdt protocol\";\n    return URI_PARSE_ERROR;\n  }\n  StringPiece urlPiece(url, 0, WDT_URL_PREFIX.size());\n  StringPiece wdtPrefix(WDT_URL_PREFIX);\n  if (urlPiece != wdtPrefix) {\n    WLOG(ERROR) << \"Url does not specify wdt protocol \" << url;\n    return URI_PARSE_ERROR;\n  }\n  urlPiece = StringPiece(url, WDT_URL_PREFIX.size());\n  if (urlPiece.empty()) {\n    WLOG(ERROR) << \"Empty host name \" << url;\n    return URI_PARSE_ERROR;\n  }\n  ErrorCode status = OK;\n  // Parse hostname\n  if (urlPiece[0] == '[') {\n    urlPiece.advance(1);\n    size_t hostNameEnd = urlPiece.find(']');\n    if (hostNameEnd == string::npos) {\n      WLOG(ERROR) << \"Didn't find ] for ipv6 address \" << url;\n      return URI_PARSE_ERROR;\n    }\n    hostName_.assign(urlPiece.data(), 0, hostNameEnd);\n    urlPiece.advance(hostNameEnd + 1);\n  } else {\n    size_t urlIndex = 0;\n    for (; urlIndex < urlPiece.size(); ++urlIndex) {\n      if (urlPiece[urlIndex] == ':') {\n        break;\n      }\n      if (urlPiece[urlIndex] == '?') {\n        break;\n      }\n    }\n    hostName_.assign(urlPiece.data(), 0, urlIndex);\n    urlPiece.advance(urlIndex);\n  }\n\n  if (hostName_.empty()) {\n    status = URI_PARSE_ERROR;\n    WLOG(ERROR) << \"Empty hostname \" << url;\n  }\n\n  if (urlPiece.empty()) {\n    return status;\n  }\n  // TODO: allow for '/' like wdt://[::1]:1234/?num_ports=3\n  // parse port number\n  if (urlPiece[0] == ':') {\n    urlPiece.advance(1);\n    size_t paramsIndex = urlPiece.find('?');\n    if (paramsIndex == string::npos) {\n      paramsIndex = urlPiece.size();\n    }\n    try {\n      string portStr;\n      portStr.assign(urlPiece.data(), 0, paramsIndex);\n      port_ = folly::to<int32_t>(portStr);\n    } catch (std::exception&) {\n      WLOG(ERROR) << \"Invalid port, can't be parsed \" << url;\n      status = URI_PARSE_ERROR;\n    }\n    urlPiece.advance(paramsIndex);\n  }\n\n  if (urlPiece.empty()) {\n    return status;\n  }\n\n  if (urlPiece[0] != '?') {\n    WLOG(ERROR) << \"Unexpected delimiter for params \" << urlPiece[0];\n    return URI_PARSE_ERROR;\n  }\n  urlPiece.advance(1);\n  // parse params\n  while (!urlPiece.empty()) {\n    StringPiece keyValuePair = urlPiece.split_step('&');\n    if (keyValuePair.empty()) {\n      // Last key value pair\n      keyValuePair = urlPiece;\n      urlPiece.advance(urlPiece.size());\n    }\n    StringPiece key = keyValuePair.split_step('=');\n    StringPiece value = keyValuePair;\n    if (key.empty()) {\n      // Value can be empty but key can't be empty\n      WLOG(ERROR) << \"Errors parsing params, url = \" << url;\n      status = URI_PARSE_ERROR;\n      break;\n    }\n    string unescapedValue;\n    if (!unescape(unescapedValue, value)) {\n      status = URI_PARSE_ERROR;\n    }\n    queryParams_[key.toString()] = unescapedValue;\n  }\n  return status;\n}\n\nstring WdtUri::getHostName() const {\n  return hostName_;\n}\n\nint32_t WdtUri::getPort() const {\n  return port_;\n}\n\nstring WdtUri::getQueryParam(const string& key) const {\n  auto it = queryParams_.find(key);\n  if (it == queryParams_.end()) {\n    WVLOG(1) << \"Couldn't find query param \" << key;\n    return \"\";\n  }\n  return it->second;\n}\n\nconst map<string, string>& WdtUri::getQueryParams() const {\n  return queryParams_;\n}\n\nvoid WdtUri::clear() {\n  hostName_.clear();\n  port_ = -1;\n  queryParams_.clear();\n}\n\nWdtUri& WdtUri::operator=(const string& url) {\n  clear();\n  errorCode_ = process(url);\n  return *this;\n}\n\n/* static */\nstd::vector<int32_t> WdtTransferRequest::genPortsVector(int32_t startPort,\n                                                        int32_t numPorts) {\n  std::vector<int32_t> ports;\n  for (int32_t i = 0; i < numPorts; i++) {\n    ports.push_back(startPort + i);\n  }\n  return ports;\n}\n\nconst string WdtTransferRequest::TRANSFER_ID_PARAM{\"id\"};\n/** RECeiver's Protocol Version */\nconst string WdtTransferRequest::RECEIVER_PROTOCOL_VERSION_PARAM{\"recpv\"};\nconst string WdtTransferRequest::DIRECTORY_PARAM{\"dir\"};\nconst string WdtTransferRequest::PORTS_PARAM{\"ports\"};\nconst string WdtTransferRequest::START_PORT_PARAM{\"start_port\"};\nconst string WdtTransferRequest::NUM_PORTS_PARAM{\"num_ports\"};\nconst string WdtTransferRequest::ENCRYPTION_PARAM{\"Enc\"};\nconst string WdtTransferRequest::TLS_PARAM{\"tls\"};\nconst string WdtTransferRequest::NAMESPACE_PARAM{\"ns\"};\nconst string WdtTransferRequest::DEST_IDENTIFIER_PARAM{\"dstid\"};\nconst string WdtTransferRequest::DOWNLOAD_RESUMPTION_PARAM{\"dr\"};\nconst string WdtTransferRequest::IV_CHANGE_INTERVAL_PARAM{\"iv_change_int\"};\n\nWdtTransferRequest::WdtTransferRequest(int startPort, int numPorts,\n                                       const string& directory) {\n  this->directory = directory;\n  int portNum = startPort;\n  for (int i = 0; i < numPorts; i++) {\n    ports.push_back(portNum);\n    if (startPort) {\n      ++portNum;\n    }\n  }\n}\n\nWdtTransferRequest::WdtTransferRequest(const string& uriString) {\n  WdtUri wdtUri(uriString);\n  errorCode = wdtUri.getErrorCode();\n  hostName = wdtUri.getHostName();\n  transferId = wdtUri.getQueryParam(TRANSFER_ID_PARAM);\n  wdtNamespace = wdtUri.getQueryParam(NAMESPACE_PARAM);\n  destIdentifier = wdtUri.getQueryParam(DEST_IDENTIFIER_PARAM);\n  directory = wdtUri.getQueryParam(DIRECTORY_PARAM);\n  string encStr = wdtUri.getQueryParam(ENCRYPTION_PARAM);\n  if (!encStr.empty()) {\n    ErrorCode code = EncryptionParams::unserialize(encStr, encryptionData);\n    if (code != OK) {\n      WLOG(ERROR) << \"Unable to parse encryption data from \\\"\" << encStr\n                  << \"\\\" \" << errorCodeToStr(code);\n      errorCode = getMoreInterestingError(code, errorCode);\n    }\n  }\n\n  string tlsEnabled = wdtUri.getQueryParam(TLS_PARAM);\n  try {\n    if (!tlsEnabled.empty()) {\n      tls = folly::to<bool>(tlsEnabled);\n    }\n  } catch (std::exception& e) {\n    WLOG(ERROR) << \"Error parsing tls \" << tlsEnabled << \" \" << e.what();\n    errorCode = URI_PARSE_ERROR;\n  }\n\n  string downloadResume = wdtUri.getQueryParam(DOWNLOAD_RESUMPTION_PARAM);\n  try {\n    if (!downloadResume.empty()) {\n      downloadResumptionEnabled = folly::to<bool>(downloadResume);\n    }\n  } catch (std::exception& e) {\n    WLOG(ERROR) << \"Error parsing download resume \" << downloadResume << \" \"\n                << e.what();\n    errorCode = URI_PARSE_ERROR;\n  }\n\n  const string recpv = wdtUri.getQueryParam(RECEIVER_PROTOCOL_VERSION_PARAM);\n  if (recpv.empty()) {\n    WLOG(WARNING) << RECEIVER_PROTOCOL_VERSION_PARAM << \" not specified in URI\";\n  } else {\n    try {\n      protocolVersion = folly::to<int64_t>(recpv);\n    } catch (std::exception& e) {\n      WLOG(ERROR) << \"Error parsing protocol version \"\n                  << wdtUri.getQueryParam(RECEIVER_PROTOCOL_VERSION_PARAM)\n                  << \" \" << e.what();\n      errorCode = URI_PARSE_ERROR;\n    }\n  }\n\n  const string ivChangeIntervalStr =\n      wdtUri.getQueryParam(IV_CHANGE_INTERVAL_PARAM);\n  if (ivChangeIntervalStr.empty()) {\n    WLOG(WARNING) << IV_CHANGE_INTERVAL_PARAM << \" not specified in URI\";\n  } else {\n    try {\n      ivChangeInterval = folly::to<int64_t>(ivChangeIntervalStr);\n    } catch (std::exception& e) {\n      WLOG(ERROR) << \"Error parsing iv change interval \" << ivChangeIntervalStr\n                  << \" \" << e.what();\n      errorCode = URI_PARSE_ERROR;\n    }\n  }\n\n  string portsStr(wdtUri.getQueryParam(PORTS_PARAM));\n  StringPiece portsList(portsStr);  // pointers into portsStr\n  do {\n    StringPiece portNum = portsList.split_step(',');\n    int port;\n    if (!portNum.empty()) {\n      try {\n        port = folly::to<int32_t>(portNum);\n        ports.push_back(port);\n      } catch (std::exception&) {\n        WLOG(ERROR) << \"Couldn't convert \" << portNum\n                    << \" to valid port number\";\n        errorCode = URI_PARSE_ERROR;\n      }\n    }\n  } while (!portsList.empty());\n  if (!ports.empty()) {\n    // Done with ports - rest of the function is alternative way to set ports\n    return;\n  }\n  // Figure out ports using other params only if there was no port list\n  string startPortStr = wdtUri.getQueryParam(START_PORT_PARAM);\n  string numPortsStr = wdtUri.getQueryParam(NUM_PORTS_PARAM);\n  int32_t startPort = wdtUri.getPort();\n  if (startPort <= 0) {\n    if (startPortStr.empty()) {\n      WLOG(ERROR) << \"URI should have port or \" << START_PORT_PARAM;\n      errorCode = INVALID_REQUEST;\n    } else {\n      try {\n        startPort = folly::to<int32_t>(startPortStr);\n      } catch (std::exception&) {\n        WLOG(ERROR) << \"Couldn't convert start port \" << startPortStr;\n        errorCode = URI_PARSE_ERROR;\n      }\n    }\n  }\n  int32_t numPorts = 0;\n  if (numPortsStr.empty()) {\n    WLOG(ERROR) << \"URI should have \" << NUM_PORTS_PARAM;\n    errorCode = INVALID_REQUEST;\n  } else {\n    try {\n      numPorts = folly::to<int32_t>(numPortsStr);\n    } catch (std::exception&) {\n      WLOG(ERROR) << \"Couldn't convert num ports \" << numPortsStr;\n      errorCode = URI_PARSE_ERROR;\n    }\n  }\n  if (errorCode == OK) {\n    ports = WdtTransferRequest::genPortsVector(startPort, numPorts);\n  }\n  // beware of the return above, add future params processing above the return\n}\n\nstring WdtTransferRequest::genWdtUrlWithSecret() const {\n  return generateUrlInternal(false, false);\n}\n\nstring WdtTransferRequest::getLogSafeString() const {\n  return generateUrlInternal(true, true);\n}\n\nstring WdtTransferRequest::generateUrlInternal(bool genFull,\n                                               bool forLogging) const {\n  if (errorCode != OK) {\n    const string msg = errorCodeToStr(errorCode);\n    WLOG(ERROR) << \"Transfer request has \" << msg;\n    return msg;\n  }\n  WdtUri wdtUri;\n  wdtUri.setHostName(hostName);\n  wdtUri.setQueryParam(TRANSFER_ID_PARAM, transferId);\n  wdtUri.setQueryParam(NAMESPACE_PARAM, wdtNamespace);\n  wdtUri.setQueryParam(DEST_IDENTIFIER_PARAM, destIdentifier);\n  wdtUri.setQueryParam(RECEIVER_PROTOCOL_VERSION_PARAM,\n                       folly::to<string>(protocolVersion));\n  wdtUri.setQueryParam(IV_CHANGE_INTERVAL_PARAM,\n                       folly::to<string>(ivChangeInterval));\n  if (downloadResumptionEnabled) {\n    wdtUri.setQueryParam(DOWNLOAD_RESUMPTION_PARAM,\n                         folly::to<string>(downloadResumptionEnabled));\n  }\n  serializePorts(wdtUri);\n  if (genFull) {\n    wdtUri.setQueryParam(DIRECTORY_PARAM, directory);\n  }\n  if (encryptionData.isSet()) {\n    WVLOG(1) << \"Encryption data is set \" << encryptionData.getLogSafeString();\n    wdtUri.setQueryParam(ENCRYPTION_PARAM,\n                         forLogging ? encryptionData.getLogSafeString()\n                                    : encryptionData.getUrlSafeString());\n  }\n  wdtUri.setQueryParam(TLS_PARAM, folly::to<string>(tls));\n  return wdtUri.generateUrl();\n}\n\nvoid WdtTransferRequest::serializePorts(WdtUri& wdtUri) const {\n  // Serialize to a port list if the ports are not\n  // contigous sequence else wdt://hostname:port\n  if (ports.size() == 0) {\n    return;\n  }\n  int32_t prevPort = ports[0];\n  bool hasHoles = false;\n  for (size_t i = 1; i < ports.size(); i++) {\n    if (ports[i] != prevPort + 1) {\n      hasHoles = true;\n      break;\n    }\n    prevPort = ports[i];\n  }\n  if (hasHoles) {\n    wdtUri.setQueryParam(PORTS_PARAM, getSerializedPortsList());\n  } else {\n    wdtUri.setPort(ports[0]);\n    wdtUri.setQueryParam(NUM_PORTS_PARAM, folly::to<string>(ports.size()));\n  }\n}\n\nstring WdtTransferRequest::getSerializedPortsList() const {\n  string portsList = \"\";\n  for (size_t i = 0; i < ports.size(); i++) {\n    if (i != 0) {\n      folly::toAppend(\",\", &portsList);\n    }\n    auto port = ports[i];\n    folly::toAppend(port, &portsList);\n  }\n  return portsList;\n}\n\nbool WdtTransferRequest::operator==(const WdtTransferRequest& that) const {\n  bool result = (transferId == that.transferId) &&\n                (protocolVersion == that.protocolVersion) &&\n                (directory == that.directory) && (hostName == that.hostName) &&\n                (ports == that.ports) &&\n                (encryptionData == that.encryptionData) &&\n                (destIdentifier == that.destIdentifier) &&\n                (wdtNamespace == that.wdtNamespace);\n  // No need to check the file info, simply checking whether two objects\n  // are same with respect to the wdt settings\n  return result;\n}\n\nstd::ostream& operator<<(std::ostream& os, const WdtTransferRequest& req) {\n  // getLogSafeString() returns a url string containing all fields. So should be\n  // enough for logging purpose.\n  os << \"WdtTransferRequest represented by url: \" << req.getLogSafeString();\n  return os;\n}\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "WdtTransferRequest.h",
          "type": "blob",
          "size": 8.6787109375,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n#include <folly/Optional.h>\n#include <wdt/ErrorCodes.h>\n#include <wdt/Protocol.h>\n#include <wdt/WdtOptions.h>\n\n#include <functional>\n#include <map>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace facebook {\nnamespace wdt {\n/**\n * Users of wdt apis can provide a list of info\n * for files. A info represents a file name with\n * information such as size, and flags\n * to read the file with\n */\nstruct WdtFileInfo {\n  /**\n   * Name of the file to be read, generally as relative path\n   */\n  std::string fileName;\n  /// Size of the file to be read, default is -1\n  int64_t fileSize;\n  /// File descriptor. If this is not -1, then wdt uses this to read\n  int fd{-1};\n  /// Whether read should be done using o_direct. If fd is set, this flag will\n  /// be set automatically to match the fd open mode\n  bool directReads{false};\n  /// Constructor for file info with name, size and odirect request\n  WdtFileInfo(const std::string& name, int64_t size, bool directReads);\n  /**\n   * Constructor with name, size and fd\n   * If this constructor is used, then whether to do direct reads is decided\n   * by fd flags.\n   * Attempt to disambiguate the 2 constructors by having the fd first\n   * and string last in this one.\n   */\n  WdtFileInfo(int fd, int64_t size, const std::string& name);\n  /// Verify that we can align for reading in O_DIRECT and\n  /// the flags make sense\n  void verifyAndFixFlags();\n};\n\n/**\n * Basic Uri class to parse and get information from wdt url\n * This class can be used in two ways :\n * 1. Construct the class with a url and get fields like\n *    hostname, and different get parameters\n * 2. Construct an empty object and set the fields, and\n *    generate a url\n *\n * Example of a url :\n * wdt://localhost?dir=/tmp/wdt&ports=22356,22357\n */\nclass WdtUri {\n public:\n  /// Empty Uri object\n  WdtUri() = default;\n\n  /// Construct the uri object using a string url\n  explicit WdtUri(const std::string& url);\n\n  /// Get the host name of the url\n  std::string getHostName() const;\n\n  /// Get the port number\n  int32_t getPort() const;\n\n  /// Get the query param by key\n  std::string getQueryParam(const std::string& key) const;\n\n  /// Get all the query params\n  const std::map<std::string, std::string>& getQueryParams() const;\n\n  /// Sets hostname to generate a url\n  void setHostName(const std::string& hostName);\n\n  /// Set the port for the uri\n  void setPort(int32_t port);\n\n  /// Sets a query param in the query params map\n  void setQueryParam(const std::string& key, const std::string& value);\n\n  /// Generate url by serializing the members of this struct\n  std::string generateUrl() const;\n\n  /// Url escape a value (which can be binary)\n  static std::string escape(const std::string& binaryStr);\n  /// Url unescape a value (escaped by escape()) - returns true if successful,\n  /// false if there is a malformed % sequence in the string\n  static bool unescape(std::string& result, folly::StringPiece escapedValue);\n  /// 0-16 -> '0'-'f'\n  static char toHex(unsigned char v);\n  /// '0'-'f' -> 0-16\n  static int fromHex(char c);\n\n  /// Assignment operator to convert string to wdt uri object\n  WdtUri& operator=(const std::string& url);\n\n  /// Clears the field of the uri\n  void clear();\n\n  /// Get the error code if any during parsing\n  ErrorCode getErrorCode() const;\n\n private:\n  /**\n   * Returns whether the url could be processed successfully. Populates\n   * the values on a best effort basis.\n   */\n  ErrorCode process(const std::string& url);\n\n  // TODO: use a vector instead, we don't really need to search...\n  /**\n   * Map of get parameters of the url. Key and value\n   * of the map are the name and value of get parameter respectively\n   */\n  std::map<std::string, std::string> queryParams_;\n\n  /// Prefix of the wdt url\n  const std::string WDT_URL_PREFIX{\"wdt://\"};\n\n  /// Hostname/ip address in the uri\n  std::string hostName_{\"\"};\n\n  /// Port of the uri\n  int32_t port_{-1};\n\n  /// Error code that reflects that status of parsing url\n  ErrorCode errorCode_{OK};\n};\n\n/**\n * Basic request for creating wdt objects\n * This request can be used for creating receivers and the\n * counter part sender or vice versa\n */\nstruct WdtTransferRequest {\n  /**\n   * Transfer Id for the transfer. It has to be same\n   * on both sender and receiver\n   */\n  std::string transferId;\n\n  /// Encryption protocol:sessionKey / secret (not printed), empty = clear text\n  EncryptionParams encryptionData;\n\n  /// Protocol version on sender and receiver\n  int64_t protocolVersion{Protocol::protocol_version};\n\n  /// Ports on which receiver is listening / sender is sending to\n  std::vector<int32_t> ports;\n\n  /// Address on which receiver binded the ports / sender is sending data to\n  std::string hostName;\n\n  /// Unique identifier for destination. This is useful to distinguish multiple\n  /// destinations in the same host\n  std::string destIdentifier;\n\n  /// Namespace for the transfer\n  std::string wdtNamespace;\n\n  /// Directory to write the data to / read the data from\n  std::string directory;\n\n  /// Only used for the sender and when not using directory discovery\n  std::vector<WdtFileInfo> fileInfo;\n\n  /// Only used for the sender and when not using directory discovery.\n  /// Sender repeatedly invokes this function to get list of files to\n  /// send and stops when the function return folly::none. File transfer\n  /// is done in batches. After intiating the transfer for a initial list of\n  /// files (either via fileInfo or a call to fileInfoGenerator), we wait\n  /// until transfer is complete before we read the next batch, if any, by\n  /// invoking fileInfoGenerator again.\n  using FileInfoGenerator =\n      std::function<folly::Optional<std::vector<WdtFileInfo>>()>;\n  FileInfoGenerator fileInfoGenerator{};\n\n  /// Use fileInfo even if empty (don't use the directory exploring)\n  bool disableDirectoryTraversal{false};\n\n  // download resumption is enabled on the receiver side\n  // and is requested from the sender\n  bool downloadResumptionEnabled{false};\n\n  /// TLS is enabled on the receiver side\n  bool tls{false};\n\n  /// Number of GBytes after iv is changed\n  int64_t ivChangeInterval{0};\n\n  /// Any error associated with this transfer request upon processing\n  ErrorCode errorCode{OK};\n\n  /// Empty constructor\n  WdtTransferRequest() {\n  }\n\n  /**\n   * Constructor with start port and num ports. Fills the vector with\n   * ports from [startPort, startPort + numPorts)\n   */\n  WdtTransferRequest(int startPort, int numPorts, const std::string& directory);\n\n  /// Constructor to construct the request object from a url string\n  explicit WdtTransferRequest(const std::string& uriString);\n\n  /// @return    generates wdt connection url and has encryption secret.\n  ///            Returned secret should not be logged\n  std::string genWdtUrlWithSecret() const;\n\n  /// @return    returns a string describing this request. This string can be\n  ///            logged\n  std::string getLogSafeString() const;\n\n  /// Serialize the ports into uri\n  void serializePorts(WdtUri& wdtUri) const;\n\n  /// Get stringified port list\n  std::string getSerializedPortsList() const;\n\n  /// Operator for finding if two request objects are equal\n  bool operator==(const WdtTransferRequest& that) const;\n\n  /// Overloaded operator for printing request info\n  friend std::ostream& operator<<(std::ostream& os,\n                                  const WdtTransferRequest& req);\n\n  const static int LEGACY_PROTCOL_VERSION;\n\n  /// Names of the get parameters for different fields\n  const static std::string TRANSFER_ID_PARAM;\n  /** Constant for for the protocol version get parameter in uri */\n  const static std::string RECEIVER_PROTOCOL_VERSION_PARAM;\n  const static std::string DIRECTORY_PARAM;\n  const static std::string PORTS_PARAM;\n  const static std::string START_PORT_PARAM;\n  const static std::string NUM_PORTS_PARAM;\n  /// Encryption parameters (proto:key for now, certificate,... potentially)\n  const static std::string ENCRYPTION_PARAM;\n  const static std::string TLS_PARAM;\n  const static std::string NAMESPACE_PARAM;\n  const static std::string DEST_IDENTIFIER_PARAM;\n  const static std::string DOWNLOAD_RESUMPTION_PARAM;\n  const static std::string IV_CHANGE_INTERVAL_PARAM;\n\n  /// Get ports vector from startPort and numPorts\n  static std::vector<int32_t> genPortsVector(int32_t startPort,\n                                             int32_t numPorts);\n\n private:\n  /**\n   * Serialize this structure into a url string containing all fields\n   * Will only put the real encoded secret if forLogging is set to false\n   */\n  std::string generateUrlInternal(bool genFull, bool forLogging) const;\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "Writer.h",
          "type": "blob",
          "size": 0.9697265625,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#pragma once\n\n#include <wdt/ErrorCodes.h>\n\nnamespace facebook {\nnamespace wdt {\n/**\n * Interface to write received data\n */\nclass Writer {\n public:\n  virtual ~Writer() {\n  }\n\n  /**\n   * open the source for reading\n   *\n   * @return status of the open\n   */\n  virtual ErrorCode open() = 0;\n\n  /**\n   * writes size number bytes from buffer\n   *\n   * @param buf   buffer to write from\n   * @param size  number of bytes to write\n   *\n   * @return      status of the write\n   */\n  virtual ErrorCode write(char *buf, int64_t size) = 0;\n\n  /// @return   total number of bytes written\n  virtual int64_t getTotalWritten() = 0;\n\n  /// sync data to disk\n  virtual ErrorCode sync() = 0;\n\n  /// close the writer\n  virtual ErrorCode close() = 0;\n};\n}  // namespace wdt\n}  // namespace facebook\n"
        },
        {
          "name": "bench",
          "type": "tree",
          "content": null
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        },
        {
          "name": "wdtCmdLine.cpp",
          "type": "blob",
          "size": 13.1943359375,
          "content": "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n */\n#include <folly/String.h>\n#include <gflags/gflags.h>\n#include <glog/logging.h>\n#include <signal.h>\n#include <wdt/Receiver.h>\n#include <wdt/Wdt.h>\n#include <wdt/WdtResourceController.h>\n\n#include <chrono>\n#include <fstream>\n#include <future>\n#include <iostream>\n#include <thread>\n\n// Used in fbonly to add socket creator setup\n#ifndef ADDITIONAL_SENDER_SETUP\n#define ADDITIONAL_SENDER_SETUP\n#endif\n\n// This can be the fbonly (FbWdt) version (extended initialization, and options)\n#ifndef WDTCLASS\n#define WDTCLASS Wdt\n#endif\n\n// Flags not already in WdtOptions.h/WdtFlags.cpp.inc\nDEFINE_bool(fork, false,\n            \"If true, forks the receiver, if false, no forking/stay in fg\");\n\nDEFINE_bool(run_as_daemon, false,\n            \"If true, run the receiver as never ending process\");\n\nDEFINE_string(directory, \".\", \"Source/Destination directory\");\nDEFINE_string(manifest, \"\",\n              \"If specified, then we will read a list of files and optional \"\n              \"sizes from this file, use - for stdin\");\nDEFINE_string(\n    destination, \"\",\n    \"empty is server (destination) mode, non empty is destination host\");\n\nDEFINE_string(hostname, \"\", \"override hostname in transfe request\");\n\nDEFINE_bool(parse_transfer_log, false,\n            \"If true, transfer log is parsed and fixed\");\n\nDEFINE_string(transfer_id, \"\",\n              \"Transfer id. Receiver will generate one to be used (via URL) on\"\n              \" the sender if not set explicitly\");\nDEFINE_int32(protocol_version, 0,\n             \"facebook::wdt::Protocol version to use, this is used to simulate \"\n             \"protocol negotiation\");\n\nDEFINE_string(connection_url, \"\",\n              \"Provide the connection string to connect to receiver\"\n              \" (incl. transfer_id and other parameters).\"\n              \" Deprecated: use - arg instead for safe encryption key\"\n              \" transmission\");\n\nDECLARE_bool(logtostderr);  // default of standard glog is off - let's set it on\n\nDEFINE_int32(abort_after_seconds, 0,\n             \"Abort transfer after given seconds. 0 means don't abort.\");\n\nDEFINE_string(recovery_id, \"\", \"Recovery-id to use for download resumption\");\n\nDEFINE_bool(treat_fewer_port_as_error, false,\n            \"If the receiver is unable to bind to all the ports, treat that as \"\n            \"an error.\");\nDEFINE_bool(print_options, false,\n            \"If true, wdt prints the option values and exits. Option values \"\n            \"printed take into account option type and other command line \"\n            \"flags specified.\");\nDEFINE_bool(exit_on_bad_flags, true,\n            \"If true, wdt exits on bad/unknown flag. Otherwise, an unknown \"\n            \"flags are ignored\");\nDEFINE_string(test_only_encryption_secret, \"\",\n              \"Test only encryption secret, to test url encoding/decoding\");\n\nDEFINE_string(app_name, \"wdt\", \"Identifier used for reporting (scuba, at fb)\");\n\nDEFINE_string(namespace, \"\", \"WDT namespace (e.g shard)\");\n\nDEFINE_string(dest_id, \"\",\n              \"Unique destination identifier (will default to hostname)\");\n\nDECLARE_bool(help);\n\n// TODO: move this to some util and/or delete\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::set<T> &v) {\n  std::copy(v.begin(), v.end(), std::ostream_iterator<T>(os, \" \"));\n  return os;\n}\n\nstd::mutex abortMutex;\nstd::condition_variable abortCondVar;\nbool isAbortCancelled = false;\nstd::shared_ptr<facebook::wdt::WdtAbortChecker> setupAbortChecker() {\n  int abortSeconds = FLAGS_abort_after_seconds;\n  if (abortSeconds <= 0) {\n    return nullptr;\n  }\n  WLOG(INFO) << \"Setting up abort \" << abortSeconds << \" seconds.\";\n  static std::atomic<bool> abortTrigger{false};\n  auto res = std::make_shared<facebook::wdt::WdtAbortChecker>(abortTrigger);\n  auto lambda = [=] {\n    WLOG(INFO) << \"Will abort in \" << abortSeconds << \" seconds.\";\n    std::unique_lock<std::mutex> lk(abortMutex);\n    bool isNotAbort =\n        abortCondVar.wait_for(lk, std::chrono::seconds(abortSeconds),\n                              [&]() -> bool { return isAbortCancelled; });\n    if (isNotAbort) {\n      WLOG(INFO) << \"Already finished normally, no abort.\";\n    } else {\n      WLOG(INFO) << \"Requesting abort.\";\n      abortTrigger.store(true);\n    }\n  };\n  // Run this in a separate thread concurrently with sender/receiver\n  static auto f = std::async(std::launch::async, lambda);\n  return res;\n}\n\nvoid setAbortChecker(facebook::wdt::WdtBase &senderOrReceiver) {\n  senderOrReceiver.setAbortChecker(setupAbortChecker());\n}\n\nvoid cancelAbort() {\n  {\n    std::unique_lock<std::mutex> lk(abortMutex);\n    isAbortCancelled = true;\n    abortCondVar.notify_one();\n  }\n  std::this_thread::yield();\n}\n\nvoid readManifest(std::istream &fin, facebook::wdt::WdtTransferRequest &req,\n                  bool dfltDirect) {\n  std::string line;\n  while (std::getline(fin, line)) {\n    std::vector<std::string> fields;\n    folly::split('\\t', line, fields, true);\n    if (fields.empty() || fields.size() > 3) {\n      WLOG(FATAL) << \"Invalid input manifest: \" << line;\n    }\n    int64_t filesize = fields.size() > 1 ? folly::to<int64_t>(fields[1]) : -1;\n    bool odirect = fields.size() > 2 ? folly::to<bool>(fields[2]) : dfltDirect;\n    req.fileInfo.emplace_back(fields[0], filesize, odirect);\n  }\n  req.disableDirectoryTraversal = true;\n}\n\nnamespace GFLAGS_NAMESPACE {\nextern GFLAGS_DLL_DECL void (*gflags_exitfunc)(int);\n}\n\nbool badGflagFound = false;\n\nstatic std::string usage;\nvoid printUsage() {\n  std::cerr << usage << std::endl;\n}\n\nvoid sigUSR1Handler(int) {\n  facebook::wdt::ReportPerfSignalSubscriber::notify();\n}\n\nint main(int argc, char *argv[]) {\n#ifdef WDTFBINIT\n  WDTFBINIT\n#endif\n\n  FLAGS_logtostderr = true;\n  // Ugliness in gflags' api; to be able to use program name\n  GFLAGS_NAMESPACE::SetArgv(argc, const_cast<const char **>(argv));\n  GFLAGS_NAMESPACE::SetVersionString(facebook::wdt::Protocol::getFullVersion());\n  usage.assign(\"WDT Warp-speed Data Transfer. v \");\n  usage.append(GFLAGS_NAMESPACE::VersionString());\n  usage.append(\". Sample usage:\\nTo transfer from srchost to desthost:\\n\\t\");\n  usage.append(\"ssh dsthost \");\n  usage.append(GFLAGS_NAMESPACE::ProgramInvocationShortName());\n  usage.append(\" -directory destdir | ssh srchost \");\n  usage.append(GFLAGS_NAMESPACE::ProgramInvocationShortName());\n  usage.append(\" -directory srcdir -\");\n  usage.append(\n      \"\\nPassing - as the argument to wdt means start the sender and\"\n      \" read the\");\n  usage.append(\n      \"\\nconnection URL produced by the receiver, including encryption\"\n      \" key, from stdin.\");\n  usage.append(\"\\nUse --help to see all the options.\");\n  GFLAGS_NAMESPACE::SetUsageMessage(usage);\n  GFLAGS_NAMESPACE::gflags_exitfunc = [](int code) {\n    if (code == 0 || FLAGS_help) {\n      // By default gflags exit 1 with --help and 0 for --version (good)\n      // let's also exit(0) for --help to be like most gnu command line\n      exit(0);\n    }\n    // error cases:\n    if (FLAGS_exit_on_bad_flags) {\n      printUsage();\n      exit(code);\n    }\n    badGflagFound = true;\n  };\n  GFLAGS_NAMESPACE::ParseCommandLineFlags(&argc, &argv, true);\n  google::InitGoogleLogging(argv[0]);\n  if (badGflagFound) {\n    // will only work for receivers\n    WLOG(ERROR) << \"Continuing despite bad flags\";\n  } else {\n    // Only non -flag argument allowed so far is \"-\" meaning\n    // Read url from stdin and start a sender\n    if (argc > 2 || (argc == 2 && (argv[1][0] != '-' || argv[1][1] != '\\0'))) {\n      printUsage();\n      std::cerr << \"Error: argument should be - (to read url from stdin) \"\n                << \"or no arguments\" << std::endl;\n      exit(1);\n    }\n  }\n  signal(SIGPIPE, SIG_IGN);\n  signal(SIGUSR1, sigUSR1Handler);\n\n  std::string connectUrl;\n  if (!badGflagFound && argc == 2) {\n    std::getline(std::cin, connectUrl);\n    if (connectUrl.empty()) {\n      WLOG(ERROR)\n          << \"Sender unable to read connection url from stdin - exiting\";\n      return facebook::wdt::URI_PARSE_ERROR;\n    }\n  } else {\n    connectUrl = FLAGS_connection_url;\n  }\n\n  // Might be a sub class (fbonly wdtCmdLine.cpp)\n  facebook::wdt::Wdt &wdt =\n      facebook::wdt::WDTCLASS::initializeWdt(FLAGS_app_name);\n  if (FLAGS_print_options) {\n    wdt.printWdtOptions(std::cout);\n    return 0;\n  }\n  facebook::wdt::WdtOptions &options = wdt.getWdtOptions();\n\n  facebook::wdt::ErrorCode retCode = facebook::wdt::OK;\n\n  // Odd ball case of log parsing\n  if (FLAGS_parse_transfer_log) {\n    // Log parsing mode\n    options.enable_download_resumption = true;\n    facebook::wdt::TransferLogManager transferLogManager(options,\n                                                         FLAGS_directory);\n    transferLogManager.openLog();\n    bool success = transferLogManager.parseAndPrint();\n    WLOG_IF(ERROR, !success) << \"Transfer log parsing failed\";\n    transferLogManager.closeLog();\n    return success ? facebook::wdt::OK : facebook::wdt::ERROR;\n  }\n\n  // General case : Sender or Receiver\n  std::unique_ptr<facebook::wdt::WdtTransferRequest> reqPtr;\n  if (connectUrl.empty()) {\n    reqPtr = std::make_unique<facebook::wdt::WdtTransferRequest>(\n        options.start_port, options.num_ports, FLAGS_directory);\n    reqPtr->hostName = FLAGS_destination;\n    reqPtr->transferId = FLAGS_transfer_id;\n    if (!FLAGS_test_only_encryption_secret.empty()) {\n      reqPtr->encryptionData = facebook::wdt::EncryptionParams(\n          facebook::wdt::parseEncryptionType(options.encryption_type),\n          FLAGS_test_only_encryption_secret);\n    }\n    reqPtr->ivChangeInterval =\n        options.iv_change_interval_mb * facebook::wdt::kMbToB;\n    reqPtr->tls = wdt.isTlsEnabled();\n  } else {\n    reqPtr = std::make_unique<facebook::wdt::WdtTransferRequest>(connectUrl);\n    if (reqPtr->errorCode != facebook::wdt::OK) {\n      WLOG(ERROR) << \"Invalid url \\\"\" << connectUrl\n                  << \"\\\" : \" << errorCodeToStr(reqPtr->errorCode);\n      return facebook::wdt::ERROR;\n    }\n    reqPtr->directory = FLAGS_directory;\n    WLOG(INFO) << \"Parsed url as \" << reqPtr->getLogSafeString();\n  }\n  facebook::wdt::WdtTransferRequest &req = *reqPtr;\n  req.wdtNamespace = FLAGS_namespace;\n  if (!FLAGS_dest_id.empty()) {\n    req.destIdentifier = FLAGS_dest_id;\n  }\n  if (FLAGS_protocol_version > 0) {\n    req.protocolVersion = FLAGS_protocol_version;\n  }\n  if (!FLAGS_hostname.empty()) {\n    reqPtr->hostName = FLAGS_hostname;\n  }\n  if (FLAGS_destination.empty() && connectUrl.empty()) {\n    facebook::wdt::Receiver receiver(req);\n    facebook::wdt::WdtOptions &recOptions = receiver.getWdtOptions();\n    if (FLAGS_run_as_daemon) {\n      // Backward compatible with static ports, you can still get dynamic\n      // daemon ports using -start_port 0 like before\n      recOptions.static_ports = true;\n    }\n    if (!FLAGS_recovery_id.empty()) {\n      // TODO: add a test for this\n      recOptions.enable_download_resumption = true;\n      receiver.setRecoveryId(FLAGS_recovery_id);\n    }\n    wdt.wdtSetReceiverSocketCreator(receiver);\n    facebook::wdt::WdtTransferRequest augmentedReq = receiver.init();\n    retCode = augmentedReq.errorCode;\n    if (retCode == facebook::wdt::FEWER_PORTS) {\n      if (FLAGS_treat_fewer_port_as_error) {\n        WLOG(ERROR) << \"Receiver could not bind to all the ports\";\n        return facebook::wdt::FEWER_PORTS;\n      }\n      retCode = facebook::wdt::OK;\n    } else if (augmentedReq.errorCode != facebook::wdt::OK) {\n      WLOG(ERROR) << \"Error setting up receiver \" << errorCodeToStr(retCode);\n      return retCode;\n    }\n    // In the log:\n    WLOG(INFO) << \"Starting receiver with connection url \"\n               << augmentedReq.getLogSafeString();  // The url without secret\n    // on stdout: the one with secret:\n    std::cout << augmentedReq.genWdtUrlWithSecret() << std::endl;\n    std::cout.flush();\n    if (FLAGS_fork) {\n      pid_t cpid = fork();\n      if (cpid == -1) {\n        perror(\"Failed to fork()\");\n        exit(1);\n      }\n      if (cpid > 0) {\n        WLOG(INFO) << \"Detaching receiver\";\n        exit(0);\n      }\n      close(0);\n      close(1);\n    }\n    setAbortChecker(receiver);\n    if (!FLAGS_run_as_daemon) {\n      retCode = receiver.transferAsync();\n      if (retCode == facebook::wdt::OK) {\n        std::unique_ptr<facebook::wdt::TransferReport> report =\n            receiver.finish();\n        retCode = report->getSummary().getErrorCode();\n      }\n    } else {\n      retCode = receiver.runForever();\n      // not reached\n    }\n  } else {\n    // Sender mode\n    if (!FLAGS_manifest.empty()) {\n      // Each line should have the filename and optionally\n      // the filesize separated by a single space\n      if (FLAGS_manifest == \"-\") {\n        readManifest(std::cin, req, options.odirect_reads);\n      } else {\n        std::ifstream fin(FLAGS_manifest);\n        readManifest(fin, req, options.odirect_reads);\n        fin.close();\n      }\n      WLOG(INFO) << \"Using files lists, number of files \"\n                 << req.fileInfo.size();\n    }\n    WLOG(INFO) << \"Making Sender with encryption set = \"\n               << req.encryptionData.isSet();\n\n    retCode = wdt.wdtSend(req, setupAbortChecker());\n  }\n  cancelAbort();\n  if (retCode == facebook::wdt::OK) {\n    WLOG(INFO) << \"Returning with OK exit code\";\n  } else {\n    WLOG(ERROR) << \"Returning with code \" << retCode << \" \"\n                << errorCodeToStr(retCode);\n  }\n  return retCode;\n}\n"
        }
      ]
    }
  ]
}