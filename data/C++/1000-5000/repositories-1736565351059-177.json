{
  "metadata": {
    "timestamp": 1736565351059,
    "page": 177,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "thedmd/imgui-node-editor",
      "stars": 3810,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0810546875,
          "content": ".vs\n.vscode\n.build*\n.DS_Store\nbin\n[Bb]uild\n*.VC.db\n*.VC.opendb\n*.user\n*.ini\n*.json\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2019 Michał Cichoń\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "crude_json.cpp",
          "type": "blob",
          "size": 20.58984375,
          "content": "// Crude implementation of JSON value object and parser.\n//\n// VERSION 0.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n# include \"crude_json.h\"\n# include <iomanip>\n# include <limits>\n# include <cstdlib>\n# include <clocale>\n# include <cmath>\n# include <cstring>\n# if CRUDE_JSON_IO\n#     include <stdio.h>\n#     include <memory>\n# endif\n\nnamespace crude_json {\n\nvalue::value(value&& other)\n    : m_Type(other.m_Type)\n{\n    switch (m_Type)\n    {\n        case type_t::object:    construct(m_Storage, std::move( *object_ptr(other.m_Storage))); break;\n        case type_t::array:     construct(m_Storage, std::move(  *array_ptr(other.m_Storage))); break;\n        case type_t::string:    construct(m_Storage, std::move( *string_ptr(other.m_Storage))); break;\n        case type_t::boolean:   construct(m_Storage, std::move(*boolean_ptr(other.m_Storage))); break;\n        case type_t::number:    construct(m_Storage, std::move( *number_ptr(other.m_Storage))); break;\n        default: break;\n    }\n    destruct(other.m_Storage, other.m_Type);\n    other.m_Type = type_t::null;\n}\n\nvalue::value(const value& other)\n    : m_Type(other.m_Type)\n{\n    switch (m_Type)\n    {\n        case type_t::object:    construct(m_Storage,  *object_ptr(other.m_Storage)); break;\n        case type_t::array:     construct(m_Storage,   *array_ptr(other.m_Storage)); break;\n        case type_t::string:    construct(m_Storage,  *string_ptr(other.m_Storage)); break;\n        case type_t::boolean:   construct(m_Storage, *boolean_ptr(other.m_Storage)); break;\n        case type_t::number:    construct(m_Storage,  *number_ptr(other.m_Storage)); break;\n        default: break;\n    }\n}\n\nvalue& value::operator[](size_t index)\n{\n    if (is_null())\n        m_Type = construct(m_Storage, type_t::array);\n\n    if (is_array())\n    {\n        auto& v = *array_ptr(m_Storage);\n        if (index >= v.size())\n            v.insert(v.end(), index - v.size() + 1, value());\n\n        return v[index];\n    }\n\n    CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n    std::terminate();\n}\n\nconst value& value::operator[](size_t index) const\n{\n    if (is_array())\n        return (*array_ptr(m_Storage))[index];\n\n    CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n    std::terminate();\n}\n\nvalue& value::operator[](const string& key)\n{\n    if (is_null())\n        m_Type = construct(m_Storage, type_t::object);\n\n    if (is_object())\n        return (*object_ptr(m_Storage))[key];\n\n    CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n    std::terminate();\n}\n\nconst value& value::operator[](const string& key) const\n{\n    if (is_object())\n    {\n        auto& o = *object_ptr(m_Storage);\n        auto it = o.find(key);\n        CRUDE_ASSERT(it != o.end());\n        return it->second;\n    }\n\n    CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n    std::terminate();\n}\n\nbool value::contains(const string& key) const\n{\n    if (is_object())\n    {\n        auto& o = *object_ptr(m_Storage);\n        auto it = o.find(key);\n        return it != o.end();\n    }\n\n    return false;\n}\n\nvoid value::push_back(const value& value)\n{\n    if (is_null())\n        m_Type = construct(m_Storage, type_t::array);\n\n    if (is_array())\n    {\n        auto& v = *array_ptr(m_Storage);\n        v.push_back(value);\n    }\n    else\n    {\n        CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n        std::terminate();\n    }\n}\n\nvoid value::push_back(value&& value)\n{\n    if (is_null())\n        m_Type = construct(m_Storage, type_t::array);\n\n    if (is_array())\n    {\n        auto& v = *array_ptr(m_Storage);\n        v.push_back(std::move(value));\n    }\n    else\n    {\n        CRUDE_ASSERT(false && \"operator[] on unsupported type\");\n        std::terminate();\n    }\n}\n\nsize_t value::erase(const string& key)\n{\n    if (!is_object())\n        return 0;\n\n    auto& o = *object_ptr(m_Storage);\n    auto it = o.find(key);\n\n    if (it == o.end())\n        return 0;\n\n    o.erase(it);\n\n    return 1;\n}\n\nvoid value::swap(value& other)\n{\n    using std::swap;\n\n    if (m_Type == other.m_Type)\n    {\n        switch (m_Type)\n        {\n            case type_t::object:    swap(*object_ptr(m_Storage),  *object_ptr(other.m_Storage));  break;\n            case type_t::array:     swap(*array_ptr(m_Storage),   *array_ptr(other.m_Storage));   break;\n            case type_t::string:    swap(*string_ptr(m_Storage),  *string_ptr(other.m_Storage));  break;\n            case type_t::boolean:   swap(*boolean_ptr(m_Storage), *boolean_ptr(other.m_Storage)); break;\n            case type_t::number:    swap(*number_ptr(m_Storage),  *number_ptr(other.m_Storage));  break;\n            default: break;\n        }\n    }\n    else\n    {\n        value tmp(std::move(other));\n        other.~value();\n        new (&other) value(std::move(*this));\n        this->~value();\n        new (this) value(std::move(tmp));\n    }\n}\n\nstring value::dump(const int indent, const char indent_char) const\n{\n    dump_context_t context(indent, indent_char);\n\n    context.out.precision(std::numeric_limits<double>::max_digits10 + 1);\n    context.out << std::defaultfloat;\n\n    dump(context, 0);\n    return context.out.str();\n}\n\nvoid value::dump_context_t::write_indent(int level)\n{\n    if (indent <= 0 || level == 0)\n        return;\n\n    out.fill(indent_char);\n    out.width(indent * level);\n    out << indent_char;\n    out.width(0);\n}\n\nvoid value::dump_context_t::write_separator()\n{\n    if (indent < 0)\n        return;\n\n    out.put(' ');\n}\n\nvoid value::dump_context_t::write_newline()\n{\n    if (indent < 0)\n        return;\n\n    out.put('\\n');\n}\n\nvoid value::dump(dump_context_t& context, int level) const\n{\n    context.write_indent(level);\n\n    switch (m_Type)\n    {\n        case type_t::null:\n            context.out << \"null\";\n            break;\n\n        case type_t::object:\n            context.out << '{';\n            {\n                context.write_newline();\n                bool first = true;\n                for (auto& entry : *object_ptr(m_Storage))\n                {\n                    if (!first) { context.out << ','; context.write_newline(); } else first = false;\n                    context.write_indent(level + 1);\n                    context.out << '\\\"' << entry.first << \"\\\":\";\n                    if (!entry.second.is_structured())\n                    {\n                        context.write_separator();\n                        entry.second.dump(context, 0);\n                    }\n                    else\n                    {\n                        context.write_newline();\n                        entry.second.dump(context, level + 1);\n                    }\n                }\n                if (!first)\n                    context.write_newline();\n            }\n            context.write_indent(level);\n            context.out << '}';\n            break;\n\n        case type_t::array:\n            context.out << '[';\n            {\n                context.write_newline();\n                bool first = true;\n                for (auto& entry : *array_ptr(m_Storage))\n                {\n                    if (!first) { context.out << ','; context.write_newline(); } else first = false;\n                    if (!entry.is_structured())\n                    {\n                        context.write_indent(level + 1);\n                        entry.dump(context, 0);\n                    }\n                    else\n                    {\n                        entry.dump(context, level + 1);\n                    }\n                }\n                if (!first)\n                    context.write_newline();\n            }\n            context.write_indent(level);\n            context.out << ']';\n            break;\n\n        case type_t::string:\n            context.out << '\\\"';\n\n            if (string_ptr(m_Storage)->find_first_of(\"\\\"\\\\/\\b\\f\\n\\r\") != string::npos || string_ptr(m_Storage)->find('\\0') != string::npos)\n            {\n                for (auto c : *string_ptr(m_Storage))\n                {\n                         if (c == '\\\"')  context.out << \"\\\\\\\"\";\n                    else if (c == '\\\\')  context.out << \"\\\\\\\\\";\n                    else if (c == '/')   context.out << \"\\\\/\";\n                    else if (c == '\\b')  context.out << \"\\\\b\";\n                    else if (c == '\\f')  context.out << \"\\\\f\";\n                    else if (c == '\\n')  context.out << \"\\\\n\";\n                    else if (c == '\\r')  context.out << \"\\\\r\";\n                    else if (c == '\\t')  context.out << \"\\\\t\";\n                    else if (c == 0)     context.out << \"\\\\u0000\";\n                    else                 context.out << c;\n                }\n            }\n            else\n                context.out << *string_ptr(m_Storage);\n            context.out << '\\\"';\n            break;\n\n\n        case type_t::boolean:\n            if (*boolean_ptr(m_Storage))\n                context.out << \"true\";\n            else\n                context.out << \"false\";\n            break;\n\n        case type_t::number:\n            context.out << *number_ptr(m_Storage);\n            break;\n\n        default:\n            break;\n    }\n}\n\nstruct value::parser\n{\n    parser(const char* begin, const char* end)\n        : m_Cursor(begin)\n        , m_End(end)\n    {\n    }\n\n    value parse()\n    {\n        value v;\n\n        // Switch to C locale to make strtod and strtol work as expected\n        auto previous_locale = std::setlocale(LC_NUMERIC, \"C\");\n\n        // Accept single value only when end of the stream is reached.\n        if (!accept_element(v) || !eof())\n            v = value(type_t::discarded);\n\n        if (previous_locale && strcmp(previous_locale, \"C\") != 0)\n            std::setlocale(LC_NUMERIC, previous_locale);\n\n        return v;\n    }\n\nprivate:\n    struct cursor_state\n    {\n        cursor_state(parser* p)\n            : m_Owner(p)\n            , m_LastCursor(p->m_Cursor)\n        {\n        }\n\n        void reset()\n        {\n            m_Owner->m_Cursor = m_LastCursor;\n        }\n\n        bool operator()(bool accept)\n        {\n            if (!accept)\n                reset();\n            else\n                m_LastCursor = m_Owner->m_Cursor;\n            return accept;\n        }\n\n    private:\n        parser*     m_Owner;\n        const char* m_LastCursor;\n    };\n\n    cursor_state state()\n    {\n        return cursor_state(this);\n    }\n\n    bool accept_value(value& result)\n    {\n        return accept_object(result)\n            || accept_array(result)\n            || accept_string(result)\n            || accept_number(result)\n            || accept_boolean(result)\n            || accept_null(result);\n    }\n\n    bool accept_object(value& result)\n    {\n        auto s = state();\n\n        object o;\n        if (s(accept('{') && accept_ws() && accept('}')))\n        {\n            result = o;\n            return true;\n        }\n        else if (s(accept('{') && accept_members(o) && accept('}')))\n        {\n            result = std::move(o);\n            return true;\n        }\n\n        return false;\n    }\n\n    bool accept_members(object& o)\n    {\n        if (!accept_member(o))\n            return false;\n\n        while (true)\n        {\n            auto s = state();\n            if (!s(accept(',') && accept_member(o)))\n                break;\n        }\n\n        return true;\n    }\n\n    bool accept_member(object& o)\n    {\n        auto s = state();\n\n        value key;\n        value v;\n        if (s(accept_ws() && accept_string(key) && accept_ws() && accept(':') && accept_element(v)))\n        {\n            o.emplace(std::move(key.get<string>()), std::move(v));\n            return true;\n        }\n\n        return false;\n    }\n\n    bool accept_array(value& result)\n    {\n        auto s = state();\n\n        if (s(accept('[') && accept_ws() && accept(']')))\n        {\n            result = array();\n            return true;\n        }\n\n        array a;\n        if (s(accept('[') && accept_elements(a) && accept(']')))\n        {\n            result = std::move(a);\n            return true;\n        }\n\n        return false;\n    }\n\n    bool accept_elements(array& a)\n    {\n        value v;\n        if (!accept_element(v))\n            return false;\n\n        a.emplace_back(std::move(v));\n        while (true)\n        {\n            auto s = state();\n            v = nullptr;\n            if (!s(accept(',') && accept_element(v)))\n                break;\n            a.emplace_back(std::move(v));\n        }\n\n        return true;\n    }\n\n    bool accept_element(value& result)\n    {\n        auto s = state();\n        return s(accept_ws() && accept_value(result) && accept_ws());\n    }\n\n    bool accept_string(value& result)\n    {\n        auto s = state();\n\n        string v;\n        if (s(accept('\\\"') && accept_characters(v) && accept('\\\"')))\n        {\n            result = std::move(v);\n            return true;\n        }\n        else\n            return false;\n    }\n\n    bool accept_characters(string& result)\n    {\n        int c;\n        while (accept_character(c))\n        {\n            CRUDE_ASSERT(c < 128); // #todo: convert characters > 127 to UTF-8\n            result.push_back(static_cast<char>(c));\n        }\n\n        return true;\n    }\n\n    bool accept_character(int& c)\n    {\n        auto s = state();\n\n        if (accept('\\\\'))\n        {\n            return accept_escape(c);\n        }\n        else if (expect('\\\"'))\n            return false;\n\n        // #todo: Handle UTF-8 sequences.\n        return s((c = peek()) >= 0) && advance();\n    }\n\n    bool accept_escape(int& c)\n    {\n        if (accept('\\\"')) { c = '\\\"'; return true; }\n        if (accept('\\\\')) { c = '\\\\'; return true; }\n        if (accept('/'))  { c = '/';  return true; }\n        if (accept('b'))  { c = '\\b'; return true; }\n        if (accept('f'))  { c = '\\f'; return true; }\n        if (accept('n'))  { c = '\\n'; return true; }\n        if (accept('r'))  { c = '\\r'; return true; }\n        if (accept('t'))  { c = '\\t'; return true; }\n\n        auto s = state();\n\n        string hex;\n        hex.reserve(4);\n        if (s(accept('u') && accept_hex(hex) && accept_hex(hex) && accept_hex(hex) && accept_hex(hex)))\n        {\n            char* end = nullptr;\n            auto v = std::strtol(hex.c_str(), &end, 16);\n            if (end != hex.c_str() + hex.size())\n                return false;\n\n            c = static_cast<int>(v);\n            return true;\n        }\n\n        return false;\n    }\n\n    bool accept_hex(string& result)\n    {\n        if (accept_digit(result))\n            return true;\n\n        auto c = peek();\n        if ((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n        {\n            advance();\n            result.push_back(static_cast<char>(c));\n            return true;\n        }\n\n        return false;\n    }\n\n    bool accept_number(value& result)\n    {\n        auto s = state();\n\n        string n;\n        if (s(accept_int(n) && accept_frac(n) && accept_exp(n)))\n        {\n            char* end = nullptr;\n            auto v = std::strtod(n.c_str(), &end);\n            if (end != n.c_str() + n.size())\n                return false;\n\n            if (v != 0 && !std::isnormal(v))\n                return false;\n\n            result = v;\n            return true;\n        }\n\n        return false;\n    }\n\n    bool accept_int(string& result)\n    {\n        auto s = state();\n\n        string part;\n        if (s(accept_onenine(part) && accept_digits(part)))\n        {\n            result += std::move(part);\n            return true;\n        }\n\n        part.resize(0);\n        if (accept_digit(part))\n        {\n            result += std::move(part);\n            return true;\n        }\n\n        part.resize(0);\n        if (s(accept('-') && accept_onenine(part) && accept_digits(part)))\n        {\n            result += '-';\n            result += std::move(part);\n            return true;\n        }\n\n        part.resize(0);\n        if (s(accept('-') && accept_digit(part)))\n        {\n            result += '-';\n            result += std::move(part);\n            return true;\n        }\n\n        return false;\n    }\n\n    bool accept_digits(string& result)\n    {\n        string part;\n        if (!accept_digit(part))\n            return false;\n\n        while (accept_digit(part))\n            ;\n\n        result += std::move(part);\n\n        return true;\n    }\n\n    bool accept_digit(string& result)\n    {\n        if (accept('0'))\n        {\n            result.push_back('0');\n            return true;\n        }\n        else if (accept_onenine(result))\n            return true;\n\n        return false;\n    }\n\n    bool accept_onenine(string& result)\n    {\n        auto c = peek();\n        if (c >= '1' && c <= '9')\n        {\n            result.push_back(static_cast<char>(c));\n            return advance();\n        }\n\n        return false;\n    }\n\n    bool accept_frac(string& result)\n    {\n        auto s = state();\n\n        string part;\n        if (s(accept('.') && accept_digits(part)))\n        {\n            result += '.';\n            result += std::move(part);\n        }\n\n        return true;\n    }\n\n    bool accept_exp(string& result)\n    {\n        auto s = state();\n\n        string part;\n        if (s(accept('e') && accept_sign(part) && accept_digits(part)))\n        {\n            result += 'e';\n            result += std::move(part);\n            return true;\n        }\n        part.resize(0);\n        if (s(accept('E') && accept_sign(part) && accept_digits(part)))\n        {\n            result += 'E';\n            result += std::move(part);\n        }\n\n        return true;\n    }\n\n    bool accept_sign(string& result)\n    {\n        if (accept('+'))\n            result.push_back('+');\n        else if (accept('-'))\n            result.push_back('-');\n\n        return true;\n    }\n\n    bool accept_ws()\n    {\n        while (expect('\\x09') || expect('\\x0A') || expect('\\x0D') || expect('\\x20'))\n            advance();\n        return true;\n    }\n\n    bool accept_boolean(value& result)\n    {\n        if (accept(\"true\"))\n        {\n            result = true;\n            return true;\n        }\n        else if (accept(\"false\"))\n        {\n            result = false;\n            return true;\n        }\n\n        return false;\n    }\n\n    bool accept_null(value& result)\n    {\n        if (accept(\"null\"))\n        {\n            result = nullptr;\n            return true;\n        }\n\n        return false;\n    }\n\n    bool accept(char c)\n    {\n        if (expect(c))\n            return advance();\n        else\n            return false;\n    }\n\n    bool accept(const char* str)\n    {\n        auto last = m_Cursor;\n\n        while (*str)\n        {\n            if (eof() || *str != *m_Cursor)\n            {\n                m_Cursor = last;\n                return false;\n            }\n\n            advance();\n            ++str;\n        }\n\n        return true;\n    }\n\n    int peek() const\n    {\n        if (!eof())\n            return *m_Cursor;\n        else\n            return -1;\n    }\n\n    bool expect(char c)\n    {\n        return peek() == c;\n    }\n\n    bool advance(int count = 1)\n    {\n        if (m_Cursor + count > m_End)\n        {\n            m_Cursor = m_End;\n            return false;\n        }\n\n        m_Cursor += count;\n\n        return true;\n    }\n\n    bool eof() const\n    {\n        return m_Cursor == m_End;\n    }\n\n    const char* m_Cursor;\n    const char* m_End;\n};\n\nvalue value::parse(const string& data)\n{\n    auto p = parser(data.c_str(), data.c_str() + data.size());\n\n    auto v = p.parse();\n\n    return v;\n}\n\n# if CRUDE_JSON_IO\nstd::pair<value, bool> value::load(const string& path)\n{\n    // Modern C++, so beautiful...\n    std::unique_ptr<FILE, void(*)(FILE*)> file{nullptr, [](FILE* file) { if (file) fclose(file); }};\n# if defined(_MSC_VER) || (defined(__STDC_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__)\n    FILE* handle = nullptr;\n    if (fopen_s(&handle, path.c_str(), \"rb\") != 0)\n        return {value{}, false};\n    file.reset(handle);\n# else\n    file.reset(fopen(path.c_str(), \"rb\"));\n# endif\n\n    if (!file)\n        return {value{}, false};\n\n    fseek(file.get(), 0, SEEK_END);\n    auto size = static_cast<size_t>(ftell(file.get()));\n    fseek(file.get(), 0, SEEK_SET);\n\n    string data;\n    data.resize(size);\n    if (fread(const_cast<char*>(data.data()), size, 1, file.get()) != 1)\n        return {value{}, false};\n\n    return {parse(data), true};\n}\n\nbool value::save(const string& path, const int indent, const char indent_char) const\n{\n    // Modern C++, so beautiful...\n    std::unique_ptr<FILE, void(*)(FILE*)> file{nullptr, [](FILE* file) { if (file) fclose(file); }};\n# if defined(_MSC_VER) || (defined(__STDC_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__)\n    FILE* handle = nullptr;\n    if (fopen_s(&handle, path.c_str(), \"wb\") != 0)\n        return false;\n    file.reset(handle);\n# else\n    file.reset(fopen(path.c_str(), \"wb\"));\n# endif\n\n    if (!file)\n        return false;\n\n    auto data = dump(indent, indent_char);\n\n    if (fwrite(data.data(), data.size(), 1, file.get()) != 1)\n        return false;\n\n    return true;\n}\n\n# endif\n\n} // namespace crude_json\n"
        },
        {
          "name": "crude_json.h",
          "type": "blob",
          "size": 12.6201171875,
          "content": "﻿// Crude implementation of JSON value object and parser.\n//\n// VERSION 0.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n# ifndef __CRUDE_JSON_H__\n# define __CRUDE_JSON_H__\n# pragma once\n\n# include <type_traits>\n# include <string>\n# include <vector>\n# include <map>\n# include <cstddef>\n# include <algorithm>\n# include <sstream>\n\n# ifndef CRUDE_ASSERT\n#     include <cassert>\n#     define CRUDE_ASSERT(expr) assert(expr)\n# endif\n\n# ifndef CRUDE_JSON_IO\n#     define CRUDE_JSON_IO 1\n# endif\n\nnamespace crude_json {\n\nstruct value;\n\nusing string  = std::string;\nusing object  = std::map<string, value>;\nusing array   = std::vector<value>;\nusing number  = double;\nusing boolean = bool;\nusing null    = std::nullptr_t;\n\nenum class type_t\n{\n    null,\n    object,\n    array,\n    string,\n    boolean,\n    number,\n    discarded\n};\n\nstruct value\n{\n    value(type_t type = type_t::null): m_Type(construct(m_Storage, type)) {}\n    value(value&& other);\n    value(const value& other);\n\n    value(      null)      : m_Type(construct(m_Storage,      null()))  {}\n    value(      object&& v): m_Type(construct(m_Storage, std::move(v))) {}\n    value(const object&  v): m_Type(construct(m_Storage,           v))  {}\n    value(      array&&  v): m_Type(construct(m_Storage, std::move(v))) {}\n    value(const array&   v): m_Type(construct(m_Storage,           v))  {}\n    value(      string&& v): m_Type(construct(m_Storage, std::move(v))) {}\n    value(const string&  v): m_Type(construct(m_Storage,           v))  {}\n    value(const char*    v): m_Type(construct(m_Storage,           v))  {}\n    value(      boolean  v): m_Type(construct(m_Storage,           v))  {}\n    value(      number   v): m_Type(construct(m_Storage,           v))  {}\n    ~value() { destruct(m_Storage, m_Type); }\n\n    value& operator=(value&& other)      { if (this != &other) { value(std::move(other)).swap(*this); } return *this; }\n    value& operator=(const value& other) { if (this != &other) { value(          other).swap(*this);  } return *this; }\n\n    value& operator=(      null)       { auto other = value(           );  swap(other); return *this; }\n    value& operator=(      object&& v) { auto other = value(std::move(v)); swap(other); return *this; }\n    value& operator=(const object&  v) { auto other = value(          v);  swap(other); return *this; }\n    value& operator=(      array&&  v) { auto other = value(std::move(v)); swap(other); return *this; }\n    value& operator=(const array&   v) { auto other = value(          v);  swap(other); return *this; }\n    value& operator=(      string&& v) { auto other = value(std::move(v)); swap(other); return *this; }\n    value& operator=(const string&  v) { auto other = value(          v);  swap(other); return *this; }\n    value& operator=(const char*    v) { auto other = value(          v);  swap(other); return *this; }\n    value& operator=(      boolean  v) { auto other = value(          v);  swap(other); return *this; }\n    value& operator=(      number   v) { auto other = value(          v);  swap(other); return *this; }\n\n    type_t type() const { return m_Type; }\n\n    operator type_t() const { return m_Type; }\n\n          value& operator[](size_t index);\n    const value& operator[](size_t index) const;\n          value& operator[](const string& key);\n    const value& operator[](const string& key) const;\n\n    bool contains(const string& key) const;\n\n    void push_back(const value& value);\n    void push_back(value&& value);\n\n    size_t erase(const string& key);\n\n    bool is_primitive()  const { return is_string() || is_number() || is_boolean() || is_null(); }\n    bool is_structured() const { return is_object() || is_array();   }\n    bool is_null()       const { return m_Type == type_t::null;      }\n    bool is_object()     const { return m_Type == type_t::object;    }\n    bool is_array()      const { return m_Type == type_t::array;     }\n    bool is_string()     const { return m_Type == type_t::string;    }\n    bool is_boolean()    const { return m_Type == type_t::boolean;   }\n    bool is_number()     const { return m_Type == type_t::number;    }\n    bool is_discarded()  const { return m_Type == type_t::discarded; }\n\n    template <typename T> const T& get() const;\n    template <typename T>       T& get();\n\n    template <typename T> const T* get_ptr() const;\n    template <typename T>       T* get_ptr();\n\n    string dump(const int indent = -1, const char indent_char = ' ') const;\n\n    void swap(value& other);\n\n    inline friend void swap(value& lhs, value& rhs) { lhs.swap(rhs); }\n\n    // Returns discarded value for invalid inputs.\n    static value parse(const string& data);\n\n# if CRUDE_JSON_IO\n    static std::pair<value, bool> load(const string& path);\n    bool save(const string& path, const int indent = -1, const char indent_char = ' ') const;\n# endif\n\nprivate:\n    struct parser;\n\n    // VS2015: std::max() is not constexpr yet.\n# define CRUDE_MAX2(a, b)           ((a) < (b) ? (b) : (a))\n# define CRUDE_MAX3(a, b, c)        CRUDE_MAX2(CRUDE_MAX2(a, b), c)\n# define CRUDE_MAX4(a, b, c, d)     CRUDE_MAX2(CRUDE_MAX3(a, b, c), d)\n# define CRUDE_MAX5(a, b, c, d, e)  CRUDE_MAX2(CRUDE_MAX4(a, b, c, d), e)\n    enum\n    {\n        max_size  = CRUDE_MAX5( sizeof(string),  sizeof(object),  sizeof(array),  sizeof(number),  sizeof(boolean)),\n        max_align = CRUDE_MAX5(alignof(string), alignof(object), alignof(array), alignof(number), alignof(boolean))\n    };\n# undef CRUDE_MAX5\n# undef CRUDE_MAX4\n# undef CRUDE_MAX3\n# undef CRUDE_MAX2\n    using storage_t = std::aligned_storage<max_size, max_align>::type;\n\n    static       object*   object_ptr(      storage_t& storage) { return reinterpret_cast<       object*>(&storage); }\n    static const object*   object_ptr(const storage_t& storage) { return reinterpret_cast<const  object*>(&storage); }\n    static       array*     array_ptr(      storage_t& storage) { return reinterpret_cast<        array*>(&storage); }\n    static const array*     array_ptr(const storage_t& storage) { return reinterpret_cast<const   array*>(&storage); }\n    static       string*   string_ptr(      storage_t& storage) { return reinterpret_cast<       string*>(&storage); }\n    static const string*   string_ptr(const storage_t& storage) { return reinterpret_cast<const  string*>(&storage); }\n    static       boolean* boolean_ptr(      storage_t& storage) { return reinterpret_cast<      boolean*>(&storage); }\n    static const boolean* boolean_ptr(const storage_t& storage) { return reinterpret_cast<const boolean*>(&storage); }\n    static       number*   number_ptr(      storage_t& storage) { return reinterpret_cast<       number*>(&storage); }\n    static const number*   number_ptr(const storage_t& storage) { return reinterpret_cast<const  number*>(&storage); }\n\n    static type_t construct(storage_t& storage, type_t type)\n    {\n        switch (type)\n        {\n            case type_t::object:    new (&storage) object();  break;\n            case type_t::array:     new (&storage) array();   break;\n            case type_t::string:    new (&storage) string();  break;\n            case type_t::boolean:   new (&storage) boolean(); break;\n            case type_t::number:    new (&storage) number();  break;\n            default: break;\n        }\n\n        return type;\n    }\n\n    static type_t construct(storage_t& storage,       null)           { (void)storage;                                        return type_t::null;    }\n    static type_t construct(storage_t& storage,       object&& value) { new (&storage)  object(std::forward<object>(value));  return type_t::object;  }\n    static type_t construct(storage_t& storage, const object&  value) { new (&storage)  object(value);                        return type_t::object;  }\n    static type_t construct(storage_t& storage,       array&&  value) { new (&storage)   array(std::forward<array>(value));   return type_t::array;   }\n    static type_t construct(storage_t& storage, const array&   value) { new (&storage)   array(value);                        return type_t::array;   }\n    static type_t construct(storage_t& storage,       string&& value) { new (&storage)  string(std::forward<string>(value));  return type_t::string;  }\n    static type_t construct(storage_t& storage, const string&  value) { new (&storage)  string(value);                        return type_t::string;  }\n    static type_t construct(storage_t& storage, const char*    value) { new (&storage)  string(value);                        return type_t::string;  }\n    static type_t construct(storage_t& storage,       boolean  value) { new (&storage) boolean(value);                        return type_t::boolean; }\n    static type_t construct(storage_t& storage,       number   value) { new (&storage)  number(value);                        return type_t::number;  }\n\n    static void destruct(storage_t& storage, type_t type)\n    {\n        switch (type)\n        {\n            case type_t::object: object_ptr(storage)->~object(); break;\n            case type_t::array:   array_ptr(storage)->~array();  break;\n            case type_t::string: string_ptr(storage)->~string(); break;\n            default: break;\n        }\n    }\n\n    struct dump_context_t\n    {\n        std::ostringstream out;\n        const int  indent = -1;\n        const char indent_char = ' ';\n\n        // VS2015: Aggregate initialization isn't a thing yet.\n        dump_context_t(const int indent, const char indent_char)\n            : indent(indent)\n            , indent_char(indent_char)\n        {\n        }\n\n        void write_indent(int level);\n        void write_separator();\n        void write_newline();\n    };\n\n    void dump(dump_context_t& context, int level) const;\n\n    storage_t m_Storage;\n    type_t    m_Type;\n};\n\ntemplate <> inline const object&  value::get<object>()  const { CRUDE_ASSERT(m_Type == type_t::object);  return *object_ptr(m_Storage);  }\ntemplate <> inline const array&   value::get<array>()   const { CRUDE_ASSERT(m_Type == type_t::array);   return *array_ptr(m_Storage);   }\ntemplate <> inline const string&  value::get<string>()  const { CRUDE_ASSERT(m_Type == type_t::string);  return *string_ptr(m_Storage);  }\ntemplate <> inline const boolean& value::get<boolean>() const { CRUDE_ASSERT(m_Type == type_t::boolean); return *boolean_ptr(m_Storage); }\ntemplate <> inline const number&  value::get<number>()  const { CRUDE_ASSERT(m_Type == type_t::number);  return *number_ptr(m_Storage);  }\n\ntemplate <> inline       object&  value::get<object>()        { CRUDE_ASSERT(m_Type == type_t::object);  return *object_ptr(m_Storage);  }\ntemplate <> inline       array&   value::get<array>()         { CRUDE_ASSERT(m_Type == type_t::array);   return *array_ptr(m_Storage);   }\ntemplate <> inline       string&  value::get<string>()        { CRUDE_ASSERT(m_Type == type_t::string);  return *string_ptr(m_Storage);  }\ntemplate <> inline       boolean& value::get<boolean>()       { CRUDE_ASSERT(m_Type == type_t::boolean); return *boolean_ptr(m_Storage); }\ntemplate <> inline       number&  value::get<number>()        { CRUDE_ASSERT(m_Type == type_t::number);  return *number_ptr(m_Storage);  }\n\ntemplate <> inline const object*  value::get_ptr<object>()  const { if (m_Type == type_t::object)  return object_ptr(m_Storage);  else return nullptr; }\ntemplate <> inline const array*   value::get_ptr<array>()   const { if (m_Type == type_t::array)   return array_ptr(m_Storage);   else return nullptr; }\ntemplate <> inline const string*  value::get_ptr<string>()  const { if (m_Type == type_t::string)  return string_ptr(m_Storage);  else return nullptr; }\ntemplate <> inline const boolean* value::get_ptr<boolean>() const { if (m_Type == type_t::boolean) return boolean_ptr(m_Storage); else return nullptr; }\ntemplate <> inline const number*  value::get_ptr<number>()  const { if (m_Type == type_t::number)  return number_ptr(m_Storage);  else return nullptr; }\n\ntemplate <> inline       object*  value::get_ptr<object>()        { if (m_Type == type_t::object)  return object_ptr(m_Storage);  else return nullptr; }\ntemplate <> inline       array*   value::get_ptr<array>()         { if (m_Type == type_t::array)   return array_ptr(m_Storage);   else return nullptr; }\ntemplate <> inline       string*  value::get_ptr<string>()        { if (m_Type == type_t::string)  return string_ptr(m_Storage);  else return nullptr; }\ntemplate <> inline       boolean* value::get_ptr<boolean>()       { if (m_Type == type_t::boolean) return boolean_ptr(m_Storage); else return nullptr; }\ntemplate <> inline       number*  value::get_ptr<number>()        { if (m_Type == type_t::number)  return number_ptr(m_Storage);  else return nullptr; }\n\n} // namespace crude_json\n\n# endif // __CRUDE_JSON_H__"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "external",
          "type": "tree",
          "content": null
        },
        {
          "name": "imgui_bezier_math.h",
          "type": "blob",
          "size": 6.697265625,
          "content": "//------------------------------------------------------------------------------\n// VERSION 0.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n//------------------------------------------------------------------------------\n# ifndef __IMGUI_BEZIER_MATH_H__\n# define __IMGUI_BEZIER_MATH_H__\n# pragma once\n\n\n//------------------------------------------------------------------------------\n# include \"imgui_extra_math.h\"\n\n\n//------------------------------------------------------------------------------\ntemplate <typename T>\nstruct ImCubicBezierPointsT\n{\n    T P0;\n    T P1;\n    T P2;\n    T P3;\n};\nusing ImCubicBezierPoints = ImCubicBezierPointsT<ImVec2>;\n\n\n//------------------------------------------------------------------------------\n// Low-level Bezier curve sampling.\ntemplate <typename T> inline T ImLinearBezier(const T& p0, const T& p1, float t);\ntemplate <typename T> inline T ImLinearBezierDt(const T& p0, const T& p1, float t);\ntemplate <typename T> inline T ImQuadraticBezier(const T& p0, const T& p1, const T& p2, float t);\ntemplate <typename T> inline T ImQuadraticBezierDt(const T& p0, const T& p1, const T& p2, float t);\ntemplate <typename T> inline T ImCubicBezier(const T& p0, const T& p1, const T& p2, const T& p3, float t);\ntemplate <typename T> inline T ImCubicBezierDt(const T& p0, const T& p1, const T& p2, const T& p3, float t);\n\n\n// High-level Bezier sampling, automatically collapse to lower level Bezier curves if control points overlap.\ntemplate <typename T> inline T ImCubicBezierSample(const T& p0, const T& p1, const T& p2, const T& p3, float t);\ntemplate <typename T> inline T ImCubicBezierSample(const ImCubicBezierPointsT<T>& curve, float t);\ntemplate <typename T> inline T ImCubicBezierTangent(const T& p0, const T& p1, const T& p2, const T& p3, float t);\ntemplate <typename T> inline T ImCubicBezierTangent(const ImCubicBezierPointsT<T>& curve, float t);\n\n\n// Calculate approximate length of Cubic Bezier curve.\ntemplate <typename T> inline float ImCubicBezierLength(const T& p0, const T& p1, const T& p2, const T& p3);\ntemplate <typename T> inline float ImCubicBezierLength(const ImCubicBezierPointsT<T>& curve);\n\n\n// Splits Cubic Bezier curve into two curves.\ntemplate <typename T>\nstruct ImCubicBezierSplitResultT\n{\n    ImCubicBezierPointsT<T> Left;\n    ImCubicBezierPointsT<T> Right;\n};\nusing ImCubicBezierSplitResult = ImCubicBezierSplitResultT<ImVec2>;\n\ntemplate <typename T> inline ImCubicBezierSplitResultT<T> ImCubicBezierSplit(const T& p0, const T& p1, const T& p2, const T& p3, float t);\ntemplate <typename T> inline ImCubicBezierSplitResultT<T> ImCubicBezierSplit(const ImCubicBezierPointsT<T>& curve, float t);\n\n\n// Returns bounding rectangle of Cubic Bezier curve.\ninline ImRect ImCubicBezierBoundingRect(const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3);\ninline ImRect ImCubicBezierBoundingRect(const ImCubicBezierPoints& curve);\n\n\n// Project point on Cubic Bezier curve.\nstruct ImProjectResult\n{\n    ImVec2 Point;    // Point on curve\n    float  Time;     // [0 - 1]\n    float  Distance; // Distance to curve\n};\n\ninline ImProjectResult ImProjectOnCubicBezier(const ImVec2& p, const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const int subdivisions = 100);\ninline ImProjectResult ImProjectOnCubicBezier(const ImVec2& p, const ImCubicBezierPoints& curve, const int subdivisions = 100);\n\n\n// Calculate intersection between line and a Cubic Bezier curve.\nstruct ImCubicBezierIntersectResult\n{\n    int Count;\n    ImVec2 Points[3];\n};\n\ninline ImCubicBezierIntersectResult ImCubicBezierLineIntersect(const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& a0, const ImVec2& a1);\ninline ImCubicBezierIntersectResult ImCubicBezierLineIntersect(const ImCubicBezierPoints& curve, const ImLine& line);\n\n\n// Adaptive Cubic Bezier subdivision.\nenum ImCubicBezierSubdivideFlags\n{\n    ImCubicBezierSubdivide_None        = 0,\n    ImCubicBezierSubdivide_SkipFirst   = 1\n};\n\nstruct ImCubicBezierSubdivideSample\n{\n    ImVec2 Point;\n    ImVec2 Tangent;\n};\n\nusing ImCubicBezierSubdivideCallback = void (*)(const ImCubicBezierSubdivideSample& p, void* user_pointer);\n\ninline void ImCubicBezierSubdivide(ImCubicBezierSubdivideCallback callback, void* user_pointer, const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float tess_tol = -1.0f, ImCubicBezierSubdivideFlags flags = ImCubicBezierSubdivide_None);\ninline void ImCubicBezierSubdivide(ImCubicBezierSubdivideCallback callback, void* user_pointer, const ImCubicBezierPoints& curve, float tess_tol = -1.0f, ImCubicBezierSubdivideFlags flags = ImCubicBezierSubdivide_None);\n\n\n// F has signature void(const ImCubicBezierSubdivideSample& p)\ntemplate <typename F> inline void ImCubicBezierSubdivide(F& callback, const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float tess_tol = -1.0f, ImCubicBezierSubdivideFlags flags = ImCubicBezierSubdivide_None);\ntemplate <typename F> inline void ImCubicBezierSubdivide(F& callback, const ImCubicBezierPoints& curve, float tess_tol = -1.0f, ImCubicBezierSubdivideFlags flags = ImCubicBezierSubdivide_None);\n\n// Fixed step Cubic Bezier subdivision.\nstruct ImCubicBezierFixedStepSample\n{\n    float  T;\n    float  Length;\n    ImVec2 Point;\n    bool   BreakSearch;\n};\n\nusing ImCubicBezierFixedStepCallback = void (*)(ImCubicBezierFixedStepSample& sample, void* user_pointer);\n\ninline void ImCubicBezierFixedStep(ImCubicBezierFixedStepCallback callback, void* user_pointer, const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float step, bool overshoot = false, float max_value_error = 1e-3f, float max_t_error = 1e-5f);\ninline void ImCubicBezierFixedStep(ImCubicBezierFixedStepCallback callback, void* user_pointer, const ImCubicBezierPoints& curve, float step, bool overshoot = false, float max_value_error = 1e-3f, float max_t_error = 1e-5f);\n\n\n// F has signature void(const ImCubicBezierFixedStepSample& p)\ntemplate <typename F> inline void ImCubicBezierFixedStep(F& callback, const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float step, bool overshoot = false, float max_value_error = 1e-3f, float max_t_error = 1e-5f);\ntemplate <typename F> inline void ImCubicBezierFixedStep(F& callback, const ImCubicBezierPoints& curve, float step, bool overshoot = false, float max_value_error = 1e-3f, float max_t_error = 1e-5f);\n\n\n//------------------------------------------------------------------------------\n# include \"imgui_bezier_math.inl\"\n\n\n//------------------------------------------------------------------------------\n# endif // __IMGUI_BEZIER_MATH_H__\n"
        },
        {
          "name": "imgui_bezier_math.inl",
          "type": "blob",
          "size": 23.3994140625,
          "content": "//------------------------------------------------------------------------------\n// VERSION 0.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n//------------------------------------------------------------------------------\n# ifndef __IMGUI_BEZIER_MATH_INL__\n# define __IMGUI_BEZIER_MATH_INL__\n# pragma once\n\n\n//------------------------------------------------------------------------------\n# include \"imgui_bezier_math.h\"\n# include <map> // used in ImCubicBezierFixedStep\n\n\n//------------------------------------------------------------------------------\ntemplate <typename T>\ninline T ImLinearBezier(const T& p0, const T& p1, float t)\n{\n    return p0 + t * (p1 - p0);\n}\n\ntemplate <typename T>\ninline T ImLinearBezierDt(const T& p0, const T& p1, float t)\n{\n    IM_UNUSED(t);\n\n    return p1 - p0;\n}\n\ntemplate <typename T>\ninline T ImQuadraticBezier(const T& p0, const T& p1, const T& p2, float t)\n{\n    const auto a = 1 - t;\n\n    return a * a * p0 + 2 * t * a * p1 + t * t * p2;\n}\n\ntemplate <typename T>\ninline T ImQuadraticBezierDt(const T& p0, const T& p1, const T& p2, float t)\n{\n    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n}\n\ntemplate <typename T>\ninline T ImCubicBezier(const T& p0, const T& p1, const T& p2, const T& p3, float t)\n{\n    const auto a = 1 - t;\n    const auto b = a * a * a;\n    const auto c = t * t * t;\n\n    return b * p0 + 3 * t * a * a * p1 + 3 * t * t * a * p2 + c * p3;\n}\n\ntemplate <typename T>\ninline T ImCubicBezierDt(const T& p0, const T& p1, const T& p2, const T& p3, float t)\n{\n    const auto a = 1 - t;\n    const auto b = a * a;\n    const auto c = t * t;\n    const auto d = 2 * t * a;\n\n    return -3 * p0 * b + 3 * p1 * (b - d) + 3 * p2 * (d - c) + 3 * p3 * c;\n}\n\ntemplate <typename T>\ninline T ImCubicBezierSample(const T& p0, const T& p1, const T& p2, const T& p3, float t)\n{\n    const auto cp0_zero = ImLengthSqr(p1 - p0) < 1e-5f;\n    const auto cp1_zero = ImLengthSqr(p3 - p2) < 1e-5f;\n\n    if (cp0_zero && cp1_zero)\n        return ImLinearBezier(p0, p3, t);\n    else if (cp0_zero)\n        return ImQuadraticBezier(p0, p2, p3, t);\n    else if (cp1_zero)\n        return ImQuadraticBezier(p0, p1, p3, t);\n    else\n        return ImCubicBezier(p0, p1, p2, p3, t);\n}\n\ntemplate <typename T>\ninline T ImCubicBezierSample(const ImCubicBezierPointsT<T>& curve, float t)\n{\n    return ImCubicBezierSample(curve.P0, curve.P1, curve.P2, curve.P3, t);\n}\n\ntemplate <typename T>\ninline T ImCubicBezierTangent(const T& p0, const T& p1, const T& p2, const T& p3, float t)\n{\n    const auto cp0_zero = ImLengthSqr(p1 - p0) < 1e-5f;\n    const auto cp1_zero = ImLengthSqr(p3 - p2) < 1e-5f;\n\n    if (cp0_zero && cp1_zero)\n        return ImLinearBezierDt(p0, p3, t);\n    else if (cp0_zero)\n        return ImQuadraticBezierDt(p0, p2, p3, t);\n    else if (cp1_zero)\n        return ImQuadraticBezierDt(p0, p1, p3, t);\n    else\n        return ImCubicBezierDt(p0, p1, p2, p3, t);\n}\n\ntemplate <typename T>\ninline T ImCubicBezierTangent(const ImCubicBezierPointsT<T>& curve, float t)\n{\n    return ImCubicBezierTangent(curve.P0, curve.P1, curve.P2, curve.P3, t);\n}\n\ntemplate <typename T>\ninline float ImCubicBezierLength(const T& p0, const T& p1, const T& p2, const T& p3)\n{\n    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n    static const float t_values[] =\n    {\n        -0.0640568928626056260850430826247450385909f,\n         0.0640568928626056260850430826247450385909f,\n        -0.1911188674736163091586398207570696318404f,\n         0.1911188674736163091586398207570696318404f,\n        -0.3150426796961633743867932913198102407864f,\n         0.3150426796961633743867932913198102407864f,\n        -0.4337935076260451384870842319133497124524f,\n         0.4337935076260451384870842319133497124524f,\n        -0.5454214713888395356583756172183723700107f,\n         0.5454214713888395356583756172183723700107f,\n        -0.6480936519369755692524957869107476266696f,\n         0.6480936519369755692524957869107476266696f,\n        -0.7401241915785543642438281030999784255232f,\n         0.7401241915785543642438281030999784255232f,\n        -0.8200019859739029219539498726697452080761f,\n         0.8200019859739029219539498726697452080761f,\n        -0.8864155270044010342131543419821967550873f,\n         0.8864155270044010342131543419821967550873f,\n        -0.9382745520027327585236490017087214496548f,\n         0.9382745520027327585236490017087214496548f,\n        -0.9747285559713094981983919930081690617411f,\n         0.9747285559713094981983919930081690617411f,\n        -0.9951872199970213601799974097007368118745f,\n         0.9951872199970213601799974097007368118745f\n    };\n\n    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n    static const float c_values[] =\n    {\n        0.1279381953467521569740561652246953718517f,\n        0.1279381953467521569740561652246953718517f,\n        0.1258374563468282961213753825111836887264f,\n        0.1258374563468282961213753825111836887264f,\n        0.1216704729278033912044631534762624256070f,\n        0.1216704729278033912044631534762624256070f,\n        0.1155056680537256013533444839067835598622f,\n        0.1155056680537256013533444839067835598622f,\n        0.1074442701159656347825773424466062227946f,\n        0.1074442701159656347825773424466062227946f,\n        0.0976186521041138882698806644642471544279f,\n        0.0976186521041138882698806644642471544279f,\n        0.0861901615319532759171852029837426671850f,\n        0.0861901615319532759171852029837426671850f,\n        0.0733464814110803057340336152531165181193f,\n        0.0733464814110803057340336152531165181193f,\n        0.0592985849154367807463677585001085845412f,\n        0.0592985849154367807463677585001085845412f,\n        0.0442774388174198061686027482113382288593f,\n        0.0442774388174198061686027482113382288593f,\n        0.0285313886289336631813078159518782864491f,\n        0.0285313886289336631813078159518782864491f,\n        0.0123412297999871995468056670700372915759f,\n        0.0123412297999871995468056670700372915759f\n    };\n\n    static_assert(sizeof(t_values) / sizeof(*t_values) == sizeof(c_values) / sizeof(*c_values), \"\");\n\n    auto arc = [p0, p1, p2, p3](float t)\n    {\n        const auto p = ImCubicBezierDt(p0, p1, p2, p3, t);\n        const auto l = ImLength(p);\n        return l;\n    };\n\n    const auto z = 0.5f;\n    const auto n = sizeof(t_values) / sizeof(*t_values);\n\n    auto accumulator = 0.0f;\n    for (size_t i = 0; i < n; ++i)\n    {\n        const auto t = z * t_values[i] + z;\n        accumulator += c_values[i] * arc(t);\n    }\n\n    return z * accumulator;\n}\n\ntemplate <typename T>\ninline float ImCubicBezierLength(const ImCubicBezierPointsT<T>& curve)\n{\n    return ImCubicBezierLength(curve.P0, curve.P1, curve.P2, curve.P3);\n}\n\ntemplate <typename T>\ninline ImCubicBezierSplitResultT<T> ImCubicBezierSplit(const T& p0, const T& p1, const T& p2, const T& p3, float t)\n{\n    const auto z1 = t;\n    const auto z2 = z1 * z1;\n    const auto z3 = z1 * z1 * z1;\n    const auto s1 = z1 - 1;\n    const auto s2 = s1 * s1;\n    const auto s3 = s1 * s1 * s1;\n\n    return ImCubicBezierSplitResultT<T>\n    {\n        ImCubicBezierPointsT<T>\n        {\n                                                                 p0,\n                                             z1      * p1 - s1 * p0,\n                          z2      * p2 - 2 * z1 * s1 * p1 + s2 * p0,\n            z3 * p3 - 3 * z2 * s1 * p2 + 3 * z1 * s2 * p1 - s3 * p0\n        },\n        ImCubicBezierPointsT<T>\n        {\n            z3 * p0 - 3 * z2 * s1 * p1 + 3 * z1 * s2 * p2 - s3 * p3,\n                          z2      * p1 - 2 * z1 * s1 * p2 + s2 * p3,\n                                             z1      * p2 - s1 * p3,\n                                                                 p3,\n        }\n    };\n}\n\ntemplate <typename T>\ninline ImCubicBezierSplitResultT<T> ImCubicBezierSplit(const ImCubicBezierPointsT<T>& curve, float t)\n{\n    return ImCubicBezierSplit(curve.P0, curve.P1, curve.P2, curve.P3, t);\n}\n\ninline ImRect ImCubicBezierBoundingRect(const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3)\n{\n    auto a = 3 * p3 - 9 * p2 + 9 * p1 - 3 * p0;\n    auto b = 6 * p0 - 12 * p1 + 6 * p2;\n    auto c = 3 * p1 - 3 * p0;\n    auto delta_squared = ImMul(b, b) - 4 * ImMul(a, c);\n\n    auto tl = ImMin(p0, p3);\n    auto rb = ImMax(p0, p3);\n\n# define IM_VEC2_INDEX(v, i) *(&v.x + i)\n\n    for (int i = 0; i < 2; ++i)\n    {\n        if (IM_VEC2_INDEX(a, i) == 0.0f)\n            continue;\n\n        if (IM_VEC2_INDEX(delta_squared, i) >= 0)\n        {\n            auto delta = ImSqrt(IM_VEC2_INDEX(delta_squared, i));\n\n            auto t0 = (-IM_VEC2_INDEX(b, i) + delta) / (2 * IM_VEC2_INDEX(a, i));\n            if (t0 > 0 && t0 < 1)\n            {\n                auto p = ImCubicBezier(IM_VEC2_INDEX(p0, i), IM_VEC2_INDEX(p1, i), IM_VEC2_INDEX(p2, i), IM_VEC2_INDEX(p3, i), t0);\n                IM_VEC2_INDEX(tl, i) = ImMin(IM_VEC2_INDEX(tl, i), p);\n                IM_VEC2_INDEX(rb, i) = ImMax(IM_VEC2_INDEX(rb, i), p);\n            }\n\n            auto t1 = (-IM_VEC2_INDEX(b, i) - delta) / (2 * IM_VEC2_INDEX(a, i));\n            if (t1 > 0 && t1 < 1)\n            {\n                auto p = ImCubicBezier(IM_VEC2_INDEX(p0, i), IM_VEC2_INDEX(p1, i), IM_VEC2_INDEX(p2, i), IM_VEC2_INDEX(p3, i), t1);\n                IM_VEC2_INDEX(tl, i) = ImMin(IM_VEC2_INDEX(tl, i), p);\n                IM_VEC2_INDEX(rb, i) = ImMax(IM_VEC2_INDEX(rb, i), p);\n            }\n        }\n    }\n\n# undef IM_VEC2_INDEX\n\n    return ImRect(tl, rb);\n}\n\ninline ImRect ImCubicBezierBoundingRect(const ImCubicBezierPoints& curve)\n{\n    return ImCubicBezierBoundingRect(curve.P0, curve.P1, curve.P2, curve.P3);\n}\n\ninline ImProjectResult ImProjectOnCubicBezier(const ImVec2& point, const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const int subdivisions)\n{\n    // http://pomax.github.io/bezierinfo/#projections\n\n    const float epsilon    = 1e-5f;\n    const float fixed_step = 1.0f / static_cast<float>(subdivisions - 1);\n\n    ImProjectResult result;\n    result.Point    = point;\n    result.Time     = 0.0f;\n    result.Distance = FLT_MAX;\n\n    // Step 1: Coarse check\n    for (int i = 0; i < subdivisions; ++i)\n    {\n        auto t = i * fixed_step;\n        auto p = ImCubicBezier(p0, p1, p2, p3, t);\n        auto s = point - p;\n        auto d = ImDot(s, s);\n\n        if (d < result.Distance)\n        {\n            result.Point    = p;\n            result.Time     = t;\n            result.Distance = d;\n        }\n    }\n\n    if (result.Time == 0.0f || ImFabs(result.Time - 1.0f) <= epsilon)\n    {\n        result.Distance = ImSqrt(result.Distance);\n        return result;\n    }\n\n    // Step 2: Fine check\n    auto left  = result.Time - fixed_step;\n    auto right = result.Time + fixed_step;\n    auto step  = fixed_step * 0.1f;\n\n    for (auto t = left; t < right + step; t += step)\n    {\n        auto p = ImCubicBezier(p0, p1, p2, p3, t);\n        auto s = point - p;\n        auto d = ImDot(s, s);\n\n        if (d < result.Distance)\n        {\n            result.Point    = p;\n            result.Time     = t;\n            result.Distance = d;\n        }\n    }\n\n    result.Distance = ImSqrt(result.Distance);\n\n    return result;\n}\n\ninline ImProjectResult ImProjectOnCubicBezier(const ImVec2& p, const ImCubicBezierPoints& curve, const int subdivisions)\n{\n    return ImProjectOnCubicBezier(p, curve.P0, curve.P1, curve.P2, curve.P3, subdivisions);\n}\n\ninline ImCubicBezierIntersectResult ImCubicBezierLineIntersect(const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& a0, const ImVec2& a1)\n{\n    auto cubic_roots = [](float a, float b, float c, float d, float* roots) -> int\n    {\n        int count = 0;\n\n        auto sign = [](float x) -> float { return x < 0 ? -1.0f : 1.0f; };\n\n        auto A = b / a;\n        auto B = c / a;\n        auto C = d / a;\n\n        auto Q = (3 * B - ImPow(A, 2)) / 9;\n        auto R = (9 * A * B - 27 * C - 2 * ImPow(A, 3)) / 54;\n        auto D = ImPow(Q, 3) + ImPow(R, 2);               // polynomial discriminant\n\n        if (D >= 0) // complex or duplicate roots\n        {\n            auto S = sign(R + ImSqrt(D)) * ImPow(ImFabs(R + ImSqrt(D)), (1.0f / 3.0f));\n            auto T = sign(R - ImSqrt(D)) * ImPow(ImFabs(R - ImSqrt(D)), (1.0f / 3.0f));\n\n            roots[0] = -A / 3 + (S + T);                // real root\n            roots[1] = -A / 3 - (S + T) / 2;            // real part of complex root\n            roots[2] = -A / 3 - (S + T) / 2;            // real part of complex root\n            auto Im = ImFabs(ImSqrt(3) * (S - T) / 2);  // complex part of root pair\n\n                                                        // discard complex roots\n            if (Im != 0)\n                count = 1;\n            else\n                count = 3;\n        }\n        else                                            // distinct real roots\n        {\n            auto th = ImAcos(R / ImSqrt(-ImPow(Q, 3)));\n\n            roots[0] = 2 * ImSqrt(-Q) * ImCos(th / 3) - A / 3;\n            roots[1] = 2 * ImSqrt(-Q) * ImCos((th + 2 * IM_PI) / 3) - A / 3;\n            roots[2] = 2 * ImSqrt(-Q) * ImCos((th + 4 * IM_PI) / 3) - A / 3;\n\n            count = 3;\n        }\n\n        return count;\n    };\n\n    // https://github.com/kaishiqi/Geometric-Bezier/blob/master/GeometricBezier/src/kaishiqi/geometric/intersection/Intersection.as\n    //\n    // Start with Bezier using Bernstein polynomials for weighting functions:\n    //     (1-t^3)P0 + 3t(1-t)^2P1 + 3t^2(1-t)P2 + t^3P3\n    //\n    // Expand and collect terms to form linear combinations of original Bezier\n    // controls.  This ends up with a vector cubic in t:\n    //     (-P0+3P1-3P2+P3)t^3 + (3P0-6P1+3P2)t^2 + (-3P0+3P1)t + P0\n    //             /\\                  /\\                /\\       /\\\n    //             ||                  ||                ||       ||\n    //             c3                  c2                c1       c0\n\n    // Calculate the coefficients\n    auto c3 =     -p0 + 3 * p1 - 3 * p2 + p3;\n    auto c2 =  3 * p0 - 6 * p1 + 3 * p2;\n    auto c1 = -3 * p0 + 3 * p1;\n    auto c0 =      p0;\n\n    // Convert line to normal form: ax + by + c = 0\n    auto a = a1.y - a0.y;\n    auto b = a0.x - a1.x;\n    auto c = a0.x * (a0.y - a1.y) + a0.y * (a1.x - a0.x);\n\n    // Rotate each cubic coefficient using line for new coordinate system?\n    // Find roots of rotated cubic\n    float roots[3];\n    auto rootCount = cubic_roots(\n        a * c3.x + b * c3.y,\n        a * c2.x + b * c2.y,\n        a * c1.x + b * c1.y,\n        a * c0.x + b * c0.y + c,\n        roots);\n\n    // Any roots in closed interval [0,1] are intersections on Bezier, but\n    // might not be on the line segment.\n    // Find intersections and calculate point coordinates\n\n    auto min = ImMin(a0, a1);\n    auto max = ImMax(a0, a1);\n\n    ImCubicBezierIntersectResult result;\n    auto points = result.Points;\n\n    for (int i = 0; i < rootCount; ++i)\n    {\n        auto root = roots[i];\n\n        if (0 <= root && root <= 1)\n        {\n            // We're within the Bezier curve\n            // Find point on Bezier\n            auto p = ImCubicBezier(p0, p1, p2, p3, root);\n\n            // See if point is on line segment\n            // Had to make special cases for vertical and horizontal lines due\n            // to slight errors in calculation of p00\n            if (a0.x == a1.x)\n            {\n                if (min.y <= p.y && p.y <= max.y)\n                    *points++ = p;\n            }\n            else if (a0.y == a1.y)\n            {\n                if (min.x <= p.x && p.x <= max.x)\n                    *points++ = p;\n            }\n            else if (p.x >= min.x && p.y >= min.y && p.x <= max.x && p.y <= max.y)\n            {\n                *points++ = p;\n            }\n        }\n    }\n\n    result.Count = static_cast<int>(points - result.Points);\n\n    return result;\n}\n\ninline ImCubicBezierIntersectResult ImCubicBezierLineIntersect(const ImCubicBezierPoints& curve, const ImLine& line)\n{\n    return ImCubicBezierLineIntersect(curve.P0, curve.P1, curve.P2, curve.P3, line.A, line.B);\n}\n\ninline void ImCubicBezierSubdivide(ImCubicBezierSubdivideCallback callback, void* user_pointer, const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float tess_tol, ImCubicBezierSubdivideFlags flags)\n{\n    return ImCubicBezierSubdivide(callback, user_pointer, ImCubicBezierPoints{ p0, p1, p2, p3 }, tess_tol, flags);\n}\n\ninline void ImCubicBezierSubdivide(ImCubicBezierSubdivideCallback callback, void* user_pointer, const ImCubicBezierPoints& curve, float tess_tol, ImCubicBezierSubdivideFlags flags)\n{\n    struct Tesselator\n    {\n        ImCubicBezierSubdivideCallback  Callback;\n        void*                           UserPointer;\n        float                           TesselationTollerance;\n        ImCubicBezierSubdivideFlags     Flags;\n\n        void Commit(const ImVec2& p, const ImVec2& t)\n        {\n            ImCubicBezierSubdivideSample sample;\n            sample.Point = p;\n            sample.Tangent = t;\n            Callback(sample, UserPointer);\n        }\n\n        void Subdivide(const ImCubicBezierPoints& curve, int level = 0)\n        {\n            float dx = curve.P3.x - curve.P0.x;\n            float dy = curve.P3.y - curve.P0.y;\n            float d2 = ((curve.P1.x - curve.P3.x) * dy - (curve.P1.y - curve.P3.y) * dx);\n            float d3 = ((curve.P2.x - curve.P3.x) * dy - (curve.P2.y - curve.P3.y) * dx);\n            d2 = (d2 >= 0) ? d2 : -d2;\n            d3 = (d3 >= 0) ? d3 : -d3;\n            if ((d2 + d3) * (d2 + d3) < TesselationTollerance * (dx * dx + dy * dy))\n            {\n                Commit(curve.P3, ImCubicBezierTangent(curve, 1.0f));\n            }\n            else if (level < 10)\n            {\n                const auto p12 = (curve.P0 + curve.P1) * 0.5f;\n                const auto p23 = (curve.P1 + curve.P2) * 0.5f;\n                const auto p34 = (curve.P2 + curve.P3) * 0.5f;\n                const auto p123 = (p12 + p23) * 0.5f;\n                const auto p234 = (p23 + p34) * 0.5f;\n                const auto p1234 = (p123 + p234) * 0.5f;\n\n                Subdivide(ImCubicBezierPoints { curve.P0, p12, p123, p1234 }, level + 1);\n                Subdivide(ImCubicBezierPoints { p1234, p234, p34, curve.P3 }, level + 1);\n            }\n        }\n    };\n\n    if (tess_tol < 0)\n        tess_tol = 1.118f; // sqrtf(1.25f)\n\n    Tesselator tesselator;\n    tesselator.Callback              = callback;\n    tesselator.UserPointer           = user_pointer;\n    tesselator.TesselationTollerance = tess_tol * tess_tol;\n    tesselator.Flags                 = flags;\n\n    if (!(tesselator.Flags & ImCubicBezierSubdivide_SkipFirst))\n        tesselator.Commit(curve.P0, ImCubicBezierTangent(curve, 0.0f));\n\n    tesselator.Subdivide(curve, 0);\n}\n\ntemplate <typename F> inline void ImCubicBezierSubdivide(F& callback, const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float tess_tol, ImCubicBezierSubdivideFlags flags)\n{\n    auto handler = [](const ImCubicBezierSubdivideSample& p, void* user_pointer)\n    {\n        auto& callback = *reinterpret_cast<F*>(user_pointer);\n        callback(p);\n    };\n\n    ImCubicBezierSubdivide(handler, &callback, ImCubicBezierPoints{ p0, p1, p2, p3 }, tess_tol, flags);\n}\n\ntemplate <typename F> inline void ImCubicBezierSubdivide(F& callback, const ImCubicBezierPoints& curve, float tess_tol, ImCubicBezierSubdivideFlags flags)\n{\n    auto handler = [](const ImCubicBezierSubdivideSample& p, void* user_pointer)\n    {\n        auto& callback = *reinterpret_cast<F*>(user_pointer);\n        callback(p);\n    };\n\n    ImCubicBezierSubdivide(handler, &callback, curve, tess_tol, flags);\n}\n\ninline void ImCubicBezierFixedStep(ImCubicBezierFixedStepCallback callback, void* user_pointer, const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float step, bool overshoot, float max_value_error, float max_t_error)\n{\n    if (step <= 0.0f || !callback || max_value_error <= 0 || max_t_error <= 0)\n        return;\n\n    ImCubicBezierFixedStepSample sample;\n    sample.T           = 0.0f;\n    sample.Length      = 0.0f;\n    sample.Point       = p0;\n    sample.BreakSearch = false;\n\n    callback(sample, user_pointer);\n    if (sample.BreakSearch)\n        return;\n\n    const auto total_length = ImCubicBezierLength(p0, p1, p2, p3);\n    const auto point_count  = static_cast<int>(total_length / step) + (overshoot ? 2 : 1);\n    const auto t_min        = 0.0f;\n    const auto t_max        = step * point_count / total_length;\n    const auto t_0          = (t_min + t_max) * 0.5f;\n\n    // #todo: replace map with ImVector + binary search\n    std::map<float, float> cache;\n    for (int point_index = 1; point_index < point_count; ++point_index)\n    {\n        const auto targetLength = point_index * step;\n\n        float t_start = t_min;\n        float t_end   = t_max;\n        float t       = t_0;\n\n        float t_best     = t;\n        float error_best = total_length;\n\n        while (true)\n        {\n            auto cacheIt = cache.find(t);\n            if (cacheIt == cache.end())\n            {\n                const auto front        = ImCubicBezierSplit(p0, p1, p2, p3, t).Left;\n                const auto split_length = ImCubicBezierLength(front);\n\n                cacheIt = cache.emplace(t, split_length).first;\n            }\n\n            const auto length   = cacheIt->second;\n            const auto error    = targetLength - length;\n\n            if (error < error_best)\n            {\n                error_best = error;\n                t_best     = t;\n            }\n\n            if (ImFabs(error) <= max_value_error || ImFabs(t_start - t_end) <= max_t_error)\n            {\n                sample.T      = t;\n                sample.Length = length;\n                sample.Point  = ImCubicBezier(p0, p1, p2, p3, t);\n\n                callback(sample, user_pointer);\n                if (sample.BreakSearch)\n                    return;\n\n                break;\n            }\n            else if (error < 0.0f)\n                t_end = t;\n            else // if (error > 0.0f)\n                t_start = t;\n\n            t = (t_start + t_end) * 0.5f;\n        }\n    }\n}\n\ninline void ImCubicBezierFixedStep(ImCubicBezierFixedStepCallback callback, void* user_pointer, const ImCubicBezierPoints& curve, float step, bool overshoot, float max_value_error, float max_t_error)\n{\n    ImCubicBezierFixedStep(callback, user_pointer, curve.P0, curve.P1, curve.P2, curve.P3, step, overshoot, max_value_error, max_t_error);\n}\n\n// F has signature void(const ImCubicBezierFixedStepSample& p)\ntemplate <typename F>\ninline void ImCubicBezierFixedStep(F& callback, const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float step, bool overshoot, float max_value_error, float max_t_error)\n{\n    auto handler = [](ImCubicBezierFixedStepSample& sample, void* user_pointer)\n    {\n        auto& callback = *reinterpret_cast<F*>(user_pointer);\n        callback(sample);\n    };\n\n    ImCubicBezierFixedStep(handler, &callback, p0, p1, p2, p3, step, overshoot, max_value_error, max_t_error);\n}\n\ntemplate <typename F>\ninline void ImCubicBezierFixedStep(F& callback, const ImCubicBezierPoints& curve, float step, bool overshoot, float max_value_error, float max_t_error)\n{\n    auto handler = [](ImCubicBezierFixedStepSample& sample, void* user_pointer)\n    {\n        auto& callback = *reinterpret_cast<F*>(user_pointer);\n        callback(sample);\n    };\n\n    ImCubicBezierFixedStep(handler, &callback, curve.P0, curve.P1, curve.P2, curve.P3, step, overshoot, max_value_error, max_t_error);\n}\n\n\n//------------------------------------------------------------------------------\n# endif // __IMGUI_BEZIER_MATH_INL__\n"
        },
        {
          "name": "imgui_canvas.cpp",
          "type": "blob",
          "size": 20.15625,
          "content": "# ifndef IMGUI_DEFINE_MATH_OPERATORS\n#     define IMGUI_DEFINE_MATH_OPERATORS\n# endif\n# include \"imgui_canvas.h\"\n# include <type_traits>\n\n// https://stackoverflow.com/a/36079786\n# define DECLARE_HAS_MEMBER(__trait_name__, __member_name__)                         \\\n                                                                                     \\\n    template <typename __boost_has_member_T__>                                       \\\n    class __trait_name__                                                             \\\n    {                                                                                \\\n        using check_type = ::std::remove_const_t<__boost_has_member_T__>;            \\\n        struct no_type {char x[2];};                                                 \\\n        using  yes_type = char;                                                      \\\n                                                                                     \\\n        struct  base { void __member_name__() {}};                                   \\\n        struct mixin : public base, public check_type {};                            \\\n                                                                                     \\\n        template <void (base::*)()> struct aux {};                                   \\\n                                                                                     \\\n        template <typename U> static no_type  test(aux<&U::__member_name__>*);       \\\n        template <typename U> static yes_type test(...);                             \\\n                                                                                     \\\n        public:                                                                      \\\n                                                                                     \\\n        static constexpr bool value = (sizeof(yes_type) == sizeof(test<mixin>(0)));  \\\n    }\n\n// Special sentinel value. This needs to be unique, so allow it to be overridden in the user's ImGui config\n# ifndef ImDrawCallback_ImCanvas\n#     define ImDrawCallback_ImCanvas        (ImDrawCallback)(-2)\n# endif\n\nnamespace ImCanvasDetails {\n\nDECLARE_HAS_MEMBER(HasFringeScale, _FringeScale);\n\nstruct FringeScaleRef\n{\n    // Overload is present when ImDrawList does have _FringeScale member variable.\n    template <typename T>\n    static float& Get(typename std::enable_if<HasFringeScale<T>::value, T>::type* drawList)\n    {\n        return drawList->_FringeScale;\n    }\n\n    // Overload is present when ImDrawList does not have _FringeScale member variable.\n    template <typename T>\n    static float& Get(typename std::enable_if<!HasFringeScale<T>::value, T>::type*)\n    {\n        static float placeholder = 1.0f;\n        return placeholder;\n    }\n};\n\nDECLARE_HAS_MEMBER(HasVtxCurrentOffset, _VtxCurrentOffset);\n\nstruct VtxCurrentOffsetRef\n{\n    // Overload is present when ImDrawList does have _FringeScale member variable.\n    template <typename T>\n    static unsigned int& Get(typename std::enable_if<HasVtxCurrentOffset<T>::value, T>::type* drawList)\n    {\n        return drawList->_VtxCurrentOffset;\n    }\n\n    // Overload is present when ImDrawList does not have _FringeScale member variable.\n    template <typename T>\n    static unsigned int& Get(typename std::enable_if<!HasVtxCurrentOffset<T>::value, T>::type* drawList)\n    {\n        return drawList->_CmdHeader.VtxOffset;\n    }\n};\n\n} // namespace ImCanvasDetails\n\n// Returns a reference to _FringeScale extension to ImDrawList\n//\n// If ImDrawList does not have _FringeScale a placeholder is returned.\nstatic inline float& ImFringeScaleRef(ImDrawList* drawList)\n{\n    using namespace ImCanvasDetails;\n    return FringeScaleRef::Get<ImDrawList>(drawList);\n}\n\nstatic inline unsigned int& ImVtxOffsetRef(ImDrawList* drawList)\n{\n    using namespace ImCanvasDetails;\n    return VtxCurrentOffsetRef::Get<ImDrawList>(drawList);\n}\n\nstatic inline ImVec2 ImSelectPositive(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x > 0.0f ? lhs.x : rhs.x, lhs.y > 0.0f ? lhs.y : rhs.y); }\n\nbool ImGuiEx::Canvas::Begin(const char* id, const ImVec2& size)\n{\n    return Begin(ImGui::GetID(id), size);\n}\n\nbool ImGuiEx::Canvas::Begin(ImGuiID id, const ImVec2& size)\n{\n    IM_ASSERT(m_InBeginEnd == false);\n\n    m_WidgetPosition = ImGui::GetCursorScreenPos();\n    m_WidgetSize = ImSelectPositive(size, ImGui::GetContentRegionAvail());\n    m_WidgetRect = ImRect(m_WidgetPosition, m_WidgetPosition + m_WidgetSize);\n    m_DrawList = ImGui::GetWindowDrawList();\n\n    UpdateViewTransformPosition();\n\n# if IMGUI_VERSION_NUM > 18415\n    if (ImGui::IsClippedEx(m_WidgetRect, id))\n        return false;\n# else\n    if (ImGui::IsClippedEx(m_WidgetRect, id, false))\n        return false;\n# endif\n\n    // Save current channel, so we can assert when user\n    // call canvas API with different one.\n    m_ExpectedChannel = m_DrawList->_Splitter._Current;\n\n    // #debug: Canvas content.\n    //m_DrawList->AddRectFilled(m_StartPos, m_StartPos + m_CurrentSize, IM_COL32(0, 0, 0, 64));\n    //m_DrawList->AddRect(m_WidgetRect.Min, m_WidgetRect.Max, IM_COL32(255, 0, 255, 64));\n\n    ImGui::SetCursorScreenPos(ImVec2(0.0f, 0.0f));\n\n# if IMGUI_EX_CANVAS_DEFERED()\n    m_Ranges.resize(0);\n# endif\n\n    SaveInputState();\n    SaveViewportState();\n\n    // Record cursor max to prevent scrollbars from appearing.\n    m_WindowCursorMaxBackup = ImGui::GetCurrentWindow()->DC.CursorMaxPos;\n\n    EnterLocalSpace();\n\n# if IMGUI_VERSION_NUM >= 18967\n    ImGui::SetNextItemAllowOverlap();\n# endif\n\n    // Emit dummy widget matching bounds of the canvas.\n    ImGui::SetCursorScreenPos(m_ViewRect.Min);\n    ImGui::Dummy(m_ViewRect.GetSize());\n\n    ImGui::SetCursorScreenPos(ImVec2(0.0f, 0.0f));\n\n    m_InBeginEnd = true;\n\n    return true;\n}\n\nvoid ImGuiEx::Canvas::End()\n{\n    // If you're here your call to Begin() returned false,\n    // or Begin() wasn't called at all.\n    IM_ASSERT(m_InBeginEnd == true);\n\n    // If you're here, please make sure you do not interleave\n    // channel splitter with canvas.\n    // Always call canvas function with using same channel.\n    IM_ASSERT(m_DrawList->_Splitter._Current == m_ExpectedChannel);\n\n    //auto& io = ImGui::GetIO();\n\n    // Check: Unmatched calls to Suspend() / Resume(). Please check your code.\n    IM_ASSERT(m_SuspendCounter == 0);\n\n    LeaveLocalSpace();\n\n    ImGui::GetCurrentWindow()->DC.CursorMaxPos = m_WindowCursorMaxBackup;\n\n# if IMGUI_VERSION_NUM < 18967\n    ImGui::SetItemAllowOverlap();\n# endif\n\n    // Emit dummy widget matching bounds of the canvas.\n    ImGui::SetCursorScreenPos(m_WidgetPosition);\n    ImGui::Dummy(m_WidgetSize);\n\n    // #debug: Rect around canvas. Content should be inside these bounds.\n    //m_DrawList->AddRect(m_WidgetPosition - ImVec2(1.0f, 1.0f), m_WidgetPosition + m_WidgetSize + ImVec2(1.0f, 1.0f), IM_COL32(196, 0, 0, 255));\n\n    m_InBeginEnd = false;\n}\n\nvoid ImGuiEx::Canvas::SetView(const ImVec2& origin, float scale)\n{\n    SetView(CanvasView(origin, scale));\n}\n\nvoid ImGuiEx::Canvas::SetView(const CanvasView& view)\n{\n    if (m_InBeginEnd)\n        LeaveLocalSpace();\n\n    if (m_View.Origin.x != view.Origin.x || m_View.Origin.y != view.Origin.y)\n    {\n        m_View.Origin = view.Origin;\n\n        UpdateViewTransformPosition();\n    }\n\n    if (m_View.Scale != view.Scale)\n    {\n        m_View.Scale    = view.Scale;\n        m_View.InvScale = view.InvScale;\n    }\n\n    if (m_InBeginEnd)\n        EnterLocalSpace();\n}\n\nvoid ImGuiEx::Canvas::CenterView(const ImVec2& canvasPoint)\n{\n    auto view = CalcCenterView(canvasPoint);\n    SetView(view);\n}\n\nImGuiEx::CanvasView ImGuiEx::Canvas::CalcCenterView(const ImVec2& canvasPoint) const\n{\n    auto localCenter = ToLocal(m_WidgetPosition + m_WidgetSize * 0.5f);\n    auto localOffset = canvasPoint - localCenter;\n    auto offset      = FromLocalV(localOffset);\n\n    return CanvasView{ m_View.Origin - offset, m_View.Scale };\n}\n\nvoid ImGuiEx::Canvas::CenterView(const ImRect& canvasRect)\n{\n    auto view = CalcCenterView(canvasRect);\n\n    SetView(view);\n}\n\nImGuiEx::CanvasView ImGuiEx::Canvas::CalcCenterView(const ImRect& canvasRect) const\n{\n    auto canvasRectSize = canvasRect.GetSize();\n\n    if (canvasRectSize.x <= 0.0f || canvasRectSize.y <= 0.0f)\n        return View();\n\n    auto widgetAspectRatio     = m_WidgetSize.y   > 0.0f ? m_WidgetSize.x   / m_WidgetSize.y   : 0.0f;\n    auto canvasRectAspectRatio = canvasRectSize.y > 0.0f ? canvasRectSize.x / canvasRectSize.y : 0.0f;\n\n    if (widgetAspectRatio <= 0.0f || canvasRectAspectRatio <= 0.0f)\n        return View();\n\n    auto newOrigin = m_View.Origin;\n    auto newScale  = m_View.Scale;\n    if (canvasRectAspectRatio > widgetAspectRatio)\n    {\n        // width span across view\n        newScale = m_WidgetSize.x / canvasRectSize.x;\n        newOrigin = canvasRect.Min * -newScale;\n        newOrigin.y += (m_WidgetSize.y - canvasRectSize.y * newScale) * 0.5f;\n    }\n    else\n    {\n        // height span across view\n        newScale = m_WidgetSize.y / canvasRectSize.y;\n        newOrigin = canvasRect.Min * -newScale;\n        newOrigin.x += (m_WidgetSize.x - canvasRectSize.x * newScale) * 0.5f;\n    }\n\n    return CanvasView{ newOrigin, newScale };\n}\n\nvoid ImGuiEx::Canvas::Suspend()\n{\n    // If you're here, please make sure you do not interleave\n    // channel splitter with canvas.\n    // Always call canvas function with using same channel.\n    IM_ASSERT(m_DrawList->_Splitter._Current == m_ExpectedChannel);\n\n    if (m_SuspendCounter == 0)\n        LeaveLocalSpace();\n\n    ++m_SuspendCounter;\n}\n\nvoid ImGuiEx::Canvas::Resume()\n{\n    // If you're here, please make sure you do not interleave\n    // channel splitter with canvas.\n    // Always call canvas function with using same channel.\n    IM_ASSERT(m_DrawList->_Splitter._Current == m_ExpectedChannel);\n\n    // Check: Number of calls to Resume() do not match calls to Suspend(). Please check your code.\n    IM_ASSERT(m_SuspendCounter > 0);\n    if (--m_SuspendCounter == 0)\n        EnterLocalSpace();\n}\n\nImVec2 ImGuiEx::Canvas::FromLocal(const ImVec2& point) const\n{\n    return point * m_View.Scale + m_ViewTransformPosition;\n}\n\nImVec2 ImGuiEx::Canvas::FromLocal(const ImVec2& point, const CanvasView& view) const\n{\n    return point * view.Scale + view.Origin + m_WidgetPosition;\n}\n\nImVec2 ImGuiEx::Canvas::FromLocalV(const ImVec2& vector) const\n{\n    return vector * m_View.Scale;\n}\n\nImVec2 ImGuiEx::Canvas::FromLocalV(const ImVec2& vector, const CanvasView& view) const\n{\n    return vector * view.Scale;\n}\n\nImVec2 ImGuiEx::Canvas::ToLocal(const ImVec2& point) const\n{\n    return (point - m_ViewTransformPosition) * m_View.InvScale;\n}\n\nImVec2 ImGuiEx::Canvas::ToLocal(const ImVec2& point, const CanvasView& view) const\n{\n    return (point - view.Origin - m_WidgetPosition) * view.InvScale;\n}\n\nImVec2 ImGuiEx::Canvas::ToLocalV(const ImVec2& vector) const\n{\n    return vector * m_View.InvScale;\n}\n\nImVec2 ImGuiEx::Canvas::ToLocalV(const ImVec2& vector, const CanvasView& view) const\n{\n    return vector * view.InvScale;\n}\n\nImRect ImGuiEx::Canvas::CalcViewRect(const CanvasView& view) const\n{\n    ImRect result;\n    result.Min = ImVec2(-view.Origin.x, -view.Origin.y) * view.InvScale;\n    result.Max = (m_WidgetSize - view.Origin) * view.InvScale;\n    return result;\n}\n\nvoid ImGuiEx::Canvas::UpdateViewTransformPosition()\n{\n    m_ViewTransformPosition = m_View.Origin + m_WidgetPosition;\n}\n\nvoid ImGuiEx::Canvas::SaveInputState()\n{\n    auto& io = ImGui::GetIO();\n    m_MousePosBackup = io.MousePos;\n    m_MousePosPrevBackup = io.MousePosPrev;\n    for (auto i = 0; i < IM_ARRAYSIZE(m_MouseClickedPosBackup); ++i)\n        m_MouseClickedPosBackup[i] = io.MouseClickedPos[i];\n}\n\nvoid ImGuiEx::Canvas::RestoreInputState()\n{\n    auto& io = ImGui::GetIO();\n    io.MousePos = m_MousePosBackup;\n    io.MousePosPrev = m_MousePosPrevBackup;\n    for (auto i = 0; i < IM_ARRAYSIZE(m_MouseClickedPosBackup); ++i)\n        io.MouseClickedPos[i] = m_MouseClickedPosBackup[i];\n}\n\nvoid ImGuiEx::Canvas::SaveViewportState()\n{\n# if defined(IMGUI_HAS_VIEWPORT)\n    auto window = ImGui::GetCurrentWindow();\n    auto viewport = ImGui::GetWindowViewport();\n\n    m_WindowPosBackup = window->Pos;\n    m_ViewportPosBackup = viewport->Pos;\n    m_ViewportSizeBackup = viewport->Size;\n# if IMGUI_VERSION_NUM > 18002\n    m_ViewportWorkPosBackup = viewport->WorkPos;\n    m_ViewportWorkSizeBackup = viewport->WorkSize;\n# else\n    m_ViewportWorkOffsetMinBackup = viewport->WorkOffsetMin;\n    m_ViewportWorkOffsetMaxBackup = viewport->WorkOffsetMax;\n# endif\n# endif\n}\n\nvoid ImGuiEx::Canvas::RestoreViewportState()\n{\n# if defined(IMGUI_HAS_VIEWPORT)\n    auto window = ImGui::GetCurrentWindow();\n    auto viewport = ImGui::GetWindowViewport();\n\n    window->Pos = m_WindowPosBackup;\n    viewport->Pos = m_ViewportPosBackup;\n    viewport->Size = m_ViewportSizeBackup;\n# if IMGUI_VERSION_NUM > 18002\n    viewport->WorkPos = m_ViewportWorkPosBackup;\n    viewport->WorkSize = m_ViewportWorkSizeBackup;\n# else\n    viewport->WorkOffsetMin = m_ViewportWorkOffsetMinBackup;\n    viewport->WorkOffsetMax = m_ViewportWorkOffsetMaxBackup;\n# endif\n# endif\n}\n\nvoid ImGuiEx::Canvas::EnterLocalSpace()\n{\n    // Prepare ImDrawList for drawing in local coordinate system:\n    //   - determine visible part of the canvas\n    //   - start unique draw command\n    //   - add clip rect matching canvas size\n    //   - record current command index\n    //   - record current vertex write index\n\n    // Determine visible part of the canvas. Make it before\n    // adding new command, to avoid round rip where command\n    // is removed in PopClipRect() and added again next PushClipRect().\n    ImGui::PushClipRect(m_WidgetPosition, m_WidgetPosition + m_WidgetSize, true);\n    auto clipped_clip_rect = m_DrawList->_ClipRectStack.back();\n    ImGui::PopClipRect();\n\n# if IMGUI_EX_CANVAS_DEFERED()\n    m_Ranges.resize(m_Ranges.Size + 1);\n    m_CurrentRange = &m_Ranges.back();\n    m_CurrentRange->BeginComandIndex = ImMax(m_DrawList->CmdBuffer.Size, 0);\n    m_CurrentRange->BeginVertexIndex = m_DrawList->_VtxCurrentIdx + ImVtxOffsetRef(m_DrawList);\n# endif\n    m_DrawListCommadBufferSize       = ImMax(m_DrawList->CmdBuffer.Size, 0);\n    m_DrawListStartVertexIndex       = m_DrawList->_VtxCurrentIdx + ImVtxOffsetRef(m_DrawList);\n\n    // Make sure we do not share draw command with anyone. We don't want to mess\n    // with someones clip rectangle.\n\n    // #FIXME:\n    //     This condition is not enough to avoid when user choose\n    //     to use channel splitter.\n    //\n    //     To deal with Suspend()/Resume() calls empty draw command\n    //     is always added then splitter is active. Otherwise\n    //     channel merger will collapse our draw command one with\n    //     different clip rectangle.\n    //\n    //     More investigation is needed. To get to the bottom of this.\n    if ((!m_DrawList->CmdBuffer.empty() && m_DrawList->CmdBuffer.back().ElemCount > 0) || m_DrawList->_Splitter._Count > 1)\n        m_DrawList->AddCallback(ImDrawCallback_ImCanvas, nullptr);\n\n    m_DrawListFirstCommandIndex = ImMax(m_DrawList->CmdBuffer.Size - 1, 0);\n\n# if defined(IMGUI_HAS_VIEWPORT)\n    auto window = ImGui::GetCurrentWindow();\n    window->Pos = ImVec2(0.0f, 0.0f);\n\n    auto viewport_min = m_ViewportPosBackup;\n    auto viewport_max = m_ViewportPosBackup + m_ViewportSizeBackup;\n\n    viewport_min.x = (viewport_min.x - m_ViewTransformPosition.x) * m_View.InvScale;\n    viewport_min.y = (viewport_min.y - m_ViewTransformPosition.y) * m_View.InvScale;\n    viewport_max.x = (viewport_max.x - m_ViewTransformPosition.x) * m_View.InvScale;\n    viewport_max.y = (viewport_max.y - m_ViewTransformPosition.y) * m_View.InvScale;\n\n    auto viewport = ImGui::GetWindowViewport();\n    viewport->Pos  = viewport_min;\n    viewport->Size = viewport_max - viewport_min;\n\n# if IMGUI_VERSION_NUM > 18002\n    viewport->WorkPos  = m_ViewportWorkPosBackup  * m_View.InvScale;\n    viewport->WorkSize = m_ViewportWorkSizeBackup * m_View.InvScale;\n# else\n    viewport->WorkOffsetMin = m_ViewportWorkOffsetMinBackup * m_View.InvScale;\n    viewport->WorkOffsetMax = m_ViewportWorkOffsetMaxBackup * m_View.InvScale;\n# endif\n# endif\n\n    // Clip rectangle in parent canvas space and move it to local space.\n    clipped_clip_rect.x = (clipped_clip_rect.x - m_ViewTransformPosition.x) * m_View.InvScale;\n    clipped_clip_rect.y = (clipped_clip_rect.y - m_ViewTransformPosition.y) * m_View.InvScale;\n    clipped_clip_rect.z = (clipped_clip_rect.z - m_ViewTransformPosition.x) * m_View.InvScale;\n    clipped_clip_rect.w = (clipped_clip_rect.w - m_ViewTransformPosition.y) * m_View.InvScale;\n    ImGui::PushClipRect(ImVec2(clipped_clip_rect.x, clipped_clip_rect.y), ImVec2(clipped_clip_rect.z, clipped_clip_rect.w), false);\n\n    // Transform mouse position to local space.\n    auto& io = ImGui::GetIO();\n    io.MousePos     = (m_MousePosBackup - m_ViewTransformPosition) * m_View.InvScale;\n    io.MousePosPrev = (m_MousePosPrevBackup - m_ViewTransformPosition) * m_View.InvScale;\n    for (auto i = 0; i < IM_ARRAYSIZE(m_MouseClickedPosBackup); ++i)\n        io.MouseClickedPos[i] = (m_MouseClickedPosBackup[i] - m_ViewTransformPosition) * m_View.InvScale;\n\n    m_ViewRect = CalcViewRect(m_View);;\n\n    auto& fringeScale = ImFringeScaleRef(m_DrawList);\n    m_LastFringeScale = fringeScale;\n    fringeScale *= m_View.InvScale;\n}\n\nvoid ImGuiEx::Canvas::LeaveLocalSpace()\n{\n    IM_ASSERT(m_DrawList->_Splitter._Current == m_ExpectedChannel);\n\n# if IMGUI_EX_CANVAS_DEFERED()\n    IM_ASSERT(m_CurrentRange != nullptr);\n\n    m_CurrentRange->EndVertexIndex  = m_DrawList->_VtxCurrentIdx + ImVtxOffsetRef(m_DrawList);\n    m_CurrentRange->EndCommandIndex = m_DrawList->CmdBuffer.size();\n    if (m_CurrentRange->BeginVertexIndex == m_CurrentRange->EndVertexIndex)\n    {\n        // Drop empty range\n        m_Ranges.resize(m_Ranges.Size - 1);\n    }\n    m_CurrentRange = nullptr;\n# endif\n\n    // Move vertices to screen space.\n    auto vertex    = m_DrawList->VtxBuffer.Data + m_DrawListStartVertexIndex;\n    auto vertexEnd = m_DrawList->VtxBuffer.Data + m_DrawList->_VtxCurrentIdx + ImVtxOffsetRef(m_DrawList);\n\n    // If canvas view is not scaled take a faster path.\n    if (m_View.Scale != 1.0f)\n    {\n        while (vertex < vertexEnd)\n        {\n            vertex->pos.x = vertex->pos.x * m_View.Scale + m_ViewTransformPosition.x;\n            vertex->pos.y = vertex->pos.y * m_View.Scale + m_ViewTransformPosition.y;\n            ++vertex;\n        }\n\n        // Move clip rectangles to screen space.\n        for (int i = m_DrawListFirstCommandIndex; i < m_DrawList->CmdBuffer.size(); ++i)\n        {\n            auto& command = m_DrawList->CmdBuffer[i];\n            command.ClipRect.x = command.ClipRect.x * m_View.Scale + m_ViewTransformPosition.x;\n            command.ClipRect.y = command.ClipRect.y * m_View.Scale + m_ViewTransformPosition.y;\n            command.ClipRect.z = command.ClipRect.z * m_View.Scale + m_ViewTransformPosition.x;\n            command.ClipRect.w = command.ClipRect.w * m_View.Scale + m_ViewTransformPosition.y;\n        }\n    }\n    else\n    {\n        while (vertex < vertexEnd)\n        {\n            vertex->pos.x = vertex->pos.x + m_ViewTransformPosition.x;\n            vertex->pos.y = vertex->pos.y + m_ViewTransformPosition.y;\n            ++vertex;\n        }\n\n        // Move clip rectangles to screen space.\n        for (int i = m_DrawListFirstCommandIndex; i < m_DrawList->CmdBuffer.size(); ++i)\n        {\n            auto& command = m_DrawList->CmdBuffer[i];\n            command.ClipRect.x = command.ClipRect.x + m_ViewTransformPosition.x;\n            command.ClipRect.y = command.ClipRect.y + m_ViewTransformPosition.y;\n            command.ClipRect.z = command.ClipRect.z + m_ViewTransformPosition.x;\n            command.ClipRect.w = command.ClipRect.w + m_ViewTransformPosition.y;\n        }\n    }\n\n    // Remove sentinel draw command if present\n    if (m_DrawListCommadBufferSize > 0)\n    {\n        if (m_DrawList->CmdBuffer.size() > m_DrawListCommadBufferSize && m_DrawList->CmdBuffer[m_DrawListCommadBufferSize].UserCallback == ImDrawCallback_ImCanvas)\n            m_DrawList->CmdBuffer.erase(m_DrawList->CmdBuffer.Data + m_DrawListCommadBufferSize);\n        else if (m_DrawList->CmdBuffer.size() >= m_DrawListCommadBufferSize && m_DrawList->CmdBuffer[m_DrawListCommadBufferSize - 1].UserCallback == ImDrawCallback_ImCanvas)\n            m_DrawList->CmdBuffer.erase(m_DrawList->CmdBuffer.Data + m_DrawListCommadBufferSize - 1);\n    }\n\n    auto& fringeScale = ImFringeScaleRef(m_DrawList);\n    fringeScale = m_LastFringeScale;\n\n    // And pop \\o/\n    ImGui::PopClipRect();\n\n    RestoreInputState();\n    RestoreViewportState();\n}\n"
        },
        {
          "name": "imgui_canvas.h",
          "type": "blob",
          "size": 9.1337890625,
          "content": "﻿// Canvas widget - view over infinite virtual space.\n//\n// Canvas allows you to draw your widgets anywhere over infinite space and provide\n// view over it with support for panning and scaling.\n//\n// When you enter a canvas ImGui is moved to virtual space which mean:\n//   - ImGui::GetCursorScreenPos() return (0, 0) and which correspond to top left corner\n//     of the canvas on the screen (this can be changed using CanvasView()).\n//   - Mouse input is brought to canvas space, so widgets works as usual.\n//   - Everything you draw with ImDrawList will be in virtual space.\n//\n// By default origin point is on top left corner of canvas widget. It can be\n// changed with call to CanvasView() where you can specify what part of space\n// should be viewed by setting viewport origin point and scale. Current state\n// can be queried with CanvasViewOrigin() and CanvasViewScale().\n//\n// Viewport size is controlled by 'size' parameter in BeginCanvas(). You can query\n// it using CanvasContentMin/Max/Size functions. They are useful if you to not specify\n// canvas size in which case all free space is used.\n//\n// Bounds of visible region of infinite space can be queried using CanvasViewMin/Max/Size\n// functions. Everything that is drawn outside of this region will be clipped\n// as usual in ImGui.\n//\n// While drawing inside canvas you can translate position from world (usual ImGui space)\n// to virtual space and back using CanvasFromWorld()/CanvasToWorld().\n//\n// Canvas can be nested in each other (they are regular widgets after all). There\n// is a way to transform position between current and parent canvas with\n// CanvasFromParent()/CanvasToParent().\n//\n// Sometimes in more elaborate scenarios you want to move out canvas virtual space,\n// do something and came back. You can do that with SuspendCanvas() and ResumeCanvas().\n//\n// Note:\n//     It is not valid to call canvas API outside of BeginCanvas() / EndCanvas() scope.\n//\n// VERSION 0.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n# ifndef __IMGUI_EX_CANVAS_H__\n# define __IMGUI_EX_CANVAS_H__\n# pragma once\n\n# include <imgui.h>\n# include <imgui_internal.h> // ImRect, ImFloor\n\n#ifndef IMGUIEX_CANVAS_API\n#define IMGUIEX_CANVAS_API\n#endif\n\nnamespace ImGuiEx {\n\nstruct CanvasView\n{\n    ImVec2 Origin;\n    float  Scale  = 1.0f;\n    float  InvScale = 1.0f;\n\n    CanvasView() = default;\n    CanvasView(const ImVec2& origin, float scale)\n        : Origin(origin)\n        , Scale(scale)\n        , InvScale(scale ? 1.0f / scale : 0.0f)\n    {\n    }\n\n    void Set(const ImVec2& origin, float scale)\n    {\n        *this = CanvasView(origin, scale);\n    }\n};\n\n// Canvas widget represent view over infinite plane.\n//\n// It acts like a child window without scroll bars with\n// ability to zoom to specific part of canvas plane.\n//\n// Widgets are clipped according to current view exactly\n// same way ImGui do. To avoid `missing widgets` artifacts first\n// setup visible region with SetView() then draw content.\n//\n// Everything drawn with ImDrawList betwen calls to Begin()/End()\n// will be drawn on canvas plane. This behavior can be suspended\n// by calling Suspend() and resumed by calling Resume().\n//\n// Warning:\n//     Please do not interleave canvas with use of channel splitter.\n//     Keep channel splitter contained inside canvas or always\n//     call canvas functions from same channel.\nstruct Canvas\n{\n    // Begins drawing content of canvas plane.\n    //\n    // When false is returned that mean canvas is not visible to the\n    // user can drawing should be skipped and End() not called.\n    // When true is returned drawing must be ended with call to End().\n    //\n    // If any size component is equal to zero or less canvas will\n    // automatically expand to all available area on that axis.\n    // So (0, 300) will take horizontal space and have height\n    // of 300 points. (0, 0) will take all remaining space of\n    // the window.\n    //\n    // You can query size of the canvas while it is being drawn\n    // by calling Rect().\n    IMGUIEX_CANVAS_API bool Begin(const char* id, const ImVec2& size);\n    IMGUIEX_CANVAS_API bool Begin(ImGuiID id, const ImVec2& size);\n\n    // Ends interaction with canvas plane.\n    //\n    // Must be called only when Begin() retuned true.\n    IMGUIEX_CANVAS_API void End();\n\n    // Sets visible region of canvas plane.\n    //\n    // Origin is an offset of infinite plane origin from top left\n    // corner of the canvas.\n    //\n    // Scale greater than 1 make canvas content be bigger, less than 1 smaller.\n    IMGUIEX_CANVAS_API void SetView(const ImVec2& origin, float scale);\n    IMGUIEX_CANVAS_API void SetView(const CanvasView& view);\n\n    // Centers view over specific point on canvas plane.\n    //\n    // View will be centered on specific point by changing origin\n    // but not scale.\n    IMGUIEX_CANVAS_API void CenterView(const ImVec2& canvasPoint);\n\n    // Calculates view over specific point on canvas plane.\n    IMGUIEX_CANVAS_API CanvasView CalcCenterView(const ImVec2& canvasPoint) const;\n\n    // Centers view over specific rectangle on canvas plane.\n    //\n    // Whole rectangle will fit in canvas view. This will affect both\n    // origin and scale.\n    IMGUIEX_CANVAS_API void CenterView(const ImRect& canvasRect);\n\n    // Calculates view over specific rectangle on canvas plane.\n    IMGUIEX_CANVAS_API CanvasView CalcCenterView(const ImRect& canvasRect) const;\n\n    // Suspends canvas by returning to normal ImGui transformation space.\n    // While suspended UI will not be drawn on canvas plane.\n    //\n    // Calls to Suspend()/Resume() are symetrical. Each call to Suspend()\n    // must be matched with call to Resume().\n    IMGUIEX_CANVAS_API void Suspend();\n    IMGUIEX_CANVAS_API void Resume();\n\n    // Transforms point from canvas plane to ImGui.\n    IMGUIEX_CANVAS_API ImVec2 FromLocal(const ImVec2& point) const;\n    IMGUIEX_CANVAS_API ImVec2 FromLocal(const ImVec2& point, const CanvasView& view) const;\n\n    // Transforms vector from canvas plant to ImGui.\n    IMGUIEX_CANVAS_API ImVec2 FromLocalV(const ImVec2& vector) const;\n    IMGUIEX_CANVAS_API ImVec2 FromLocalV(const ImVec2& vector, const CanvasView& view) const;\n\n    // Transforms point from ImGui to canvas plane.\n    IMGUIEX_CANVAS_API ImVec2 ToLocal(const ImVec2& point) const;\n    IMGUIEX_CANVAS_API ImVec2 ToLocal(const ImVec2& point, const CanvasView& view) const;\n\n    // Transforms vector from ImGui to canvas plane.\n    IMGUIEX_CANVAS_API ImVec2 ToLocalV(const ImVec2& vector) const;\n    IMGUIEX_CANVAS_API ImVec2 ToLocalV(const ImVec2& vector, const CanvasView& view) const;\n\n    // Returns widget bounds.\n    //\n    // Note:\n    //     Rect is valid after call to Begin().\n    const ImRect& Rect() const { return m_WidgetRect; }\n\n    // Returns visible region on canvas plane (in canvas plane coordinates).\n    const ImRect& ViewRect() const { return m_ViewRect; }\n\n    // Calculates visible region for view.\n    IMGUIEX_CANVAS_API ImRect CalcViewRect(const CanvasView& view) const;\n\n    // Returns current view.\n    const CanvasView& View() const { return m_View; }\n\n    // Returns origin of the view.\n    //\n    // Origin is an offset of infinite plane origin from top left\n    // corner of the canvas.\n    const ImVec2& ViewOrigin()  const { return m_View.Origin; }\n\n    // Returns scale of the view.\n    float ViewScale() const { return m_View.Scale; }\n\n    // Returns true if canvas is suspended.\n    //\n    // See: Suspend()/Resume()\n    bool IsSuspended() const { return m_SuspendCounter > 0; }\n\nprivate:\n# define IMGUI_EX_CANVAS_DEFERED() 0\n\n# if IMGUI_EX_CANVAS_DEFERED()\n    struct Range\n    {\n        int BeginVertexIndex = 0;\n        int EndVertexIndex   = 0;\n        int BeginComandIndex = 0;\n        int EndCommandIndex  = 0;\n    };\n# endif\n\n    void UpdateViewTransformPosition();\n\n    void SaveInputState();\n    void RestoreInputState();\n\n    void SaveViewportState();\n    void RestoreViewportState();\n\n    void EnterLocalSpace();\n    void LeaveLocalSpace();\n\n    bool m_InBeginEnd = false;\n\n    ImVec2 m_WidgetPosition;\n    ImVec2 m_WidgetSize;\n    ImRect m_WidgetRect;\n\n    ImDrawList* m_DrawList = nullptr;\n    int m_ExpectedChannel = 0;\n\n# if IMGUI_EX_CANVAS_DEFERED()\n    ImVector<Range> m_Ranges;\n    Range* m_CurrentRange = nullptr;\n# endif\n\n    int m_DrawListFirstCommandIndex = 0;\n    int m_DrawListCommadBufferSize = 0;\n    int m_DrawListStartVertexIndex = 0;\n\n    CanvasView  m_View;\n    ImRect      m_ViewRect;\n\n    ImVec2 m_ViewTransformPosition;\n\n    int m_SuspendCounter = 0;\n\n    float m_LastFringeScale = 1.0f;\n\n    ImVec2 m_MousePosBackup;\n    ImVec2 m_MousePosPrevBackup;\n    ImVec2 m_MouseClickedPosBackup[IM_ARRAYSIZE(ImGuiIO::MouseClickedPos)];\n    ImVec2 m_WindowCursorMaxBackup;\n\n# if defined(IMGUI_HAS_VIEWPORT)\n    ImVec2 m_WindowPosBackup;\n    ImVec2 m_ViewportPosBackup;\n    ImVec2 m_ViewportSizeBackup;\n# if IMGUI_VERSION_NUM > 18002\n    ImVec2 m_ViewportWorkPosBackup;\n    ImVec2 m_ViewportWorkSizeBackup;\n# else\n    ImVec2 m_ViewportWorkOffsetMinBackup;\n    ImVec2 m_ViewportWorkOffsetMaxBackup;\n# endif\n# endif\n};\n\n} // namespace ImGuiEx\n\n# endif // __IMGUI_EX_CANVAS_H__"
        },
        {
          "name": "imgui_extra_math.h",
          "type": "blob",
          "size": 2.4970703125,
          "content": "//------------------------------------------------------------------------------\n// VERSION 0.9.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n//------------------------------------------------------------------------------\n# ifndef __IMGUI_EXTRA_MATH_H__\n# define __IMGUI_EXTRA_MATH_H__\n# pragma once\n\n\n//------------------------------------------------------------------------------\n# ifndef IMGUI_DEFINE_MATH_OPERATORS\n#     define IMGUI_DEFINE_MATH_OPERATORS\n# endif\n# include <imgui.h>\n# include <imgui_internal.h>\n\n\n//------------------------------------------------------------------------------\nstruct ImLine\n{\n    ImVec2 A, B;\n};\n\n\n//------------------------------------------------------------------------------\n# if IMGUI_VERSION_NUM < 19002\ninline bool operator==(const ImVec2& lhs, const ImVec2& rhs);\ninline bool operator!=(const ImVec2& lhs, const ImVec2& rhs);\n# endif\ninline ImVec2 operator*(const float lhs, const ImVec2& rhs);\n# if IMGUI_VERSION_NUM < 18955\ninline ImVec2 operator-(const ImVec2& lhs);\n# endif\n\n\n//------------------------------------------------------------------------------\ninline float  ImLength(float v);\ninline float  ImLength(const ImVec2& v);\ninline float  ImLengthSqr(float v);\ninline ImVec2 ImNormalized(const ImVec2& v);\n\n\n//------------------------------------------------------------------------------\ninline bool   ImRect_IsEmpty(const ImRect& rect);\ninline ImVec2 ImRect_ClosestPoint(const ImRect& rect, const ImVec2& p, bool snap_to_edge);\ninline ImVec2 ImRect_ClosestPoint(const ImRect& rect, const ImVec2& p, bool snap_to_edge, float radius);\ninline ImVec2 ImRect_ClosestPoint(const ImRect& rect, const ImRect& b);\ninline ImLine ImRect_ClosestLine(const ImRect& rect_a, const ImRect& rect_b);\ninline ImLine ImRect_ClosestLine(const ImRect& rect_a, const ImRect& rect_b, float radius_a, float radius_b);\n\n\n\n//------------------------------------------------------------------------------\nnamespace ImEasing {\n\ntemplate <typename V, typename T>\ninline V EaseOutQuad(V b, V c, T t)\n{\n    return b - c * (t * (t - 2));\n}\n\n} // namespace ImEasing\n\n\n//------------------------------------------------------------------------------\n# include \"imgui_extra_math.inl\"\n\n\n//------------------------------------------------------------------------------\n# endif // __IMGUI_EXTRA_MATH_H__\n"
        },
        {
          "name": "imgui_extra_math.inl",
          "type": "blob",
          "size": 5.06640625,
          "content": "//------------------------------------------------------------------------------\n// VERSION 0.9.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n//------------------------------------------------------------------------------\n# ifndef __IMGUI_EXTRA_MATH_INL__\n# define __IMGUI_EXTRA_MATH_INL__\n# pragma once\n\n\n//------------------------------------------------------------------------------\n# include \"imgui_extra_math.h\"\n\n\n//------------------------------------------------------------------------------\n# if IMGUI_VERSION_NUM < 19002\ninline bool operator==(const ImVec2& lhs, const ImVec2& rhs)\n{\n    return lhs.x == rhs.x && lhs.y == rhs.y;\n}\n\ninline bool operator!=(const ImVec2& lhs, const ImVec2& rhs)\n{\n    return lhs.x != rhs.x || lhs.y != rhs.y;\n}\n# endif\n\ninline ImVec2 operator*(const float lhs, const ImVec2& rhs)\n{\n    return ImVec2(lhs * rhs.x, lhs * rhs.y);\n}\n\n# if IMGUI_VERSION_NUM < 18955\ninline ImVec2 operator-(const ImVec2& lhs)\n{\n    return ImVec2(-lhs.x, -lhs.y);\n}\n# endif\n\n\n//------------------------------------------------------------------------------\ninline float ImLength(float v)\n{\n    return v;\n}\n\ninline float ImLength(const ImVec2& v)\n{\n    return ImSqrt(ImLengthSqr(v));\n}\n\ninline float ImLengthSqr(float v)\n{\n    return v * v;\n}\n\ninline ImVec2 ImNormalized(const ImVec2& v)\n{\n    return v * ImInvLength(v, 0.0f);\n}\n\n\n\n\n//------------------------------------------------------------------------------\ninline bool ImRect_IsEmpty(const ImRect& rect)\n{\n    return rect.Min.x >= rect.Max.x\n        || rect.Min.y >= rect.Max.y;\n}\n\ninline ImVec2 ImRect_ClosestPoint(const ImRect& rect, const ImVec2& p, bool snap_to_edge)\n{\n    if (!snap_to_edge && rect.Contains(p))\n        return p;\n\n    return ImVec2(\n        (p.x > rect.Max.x) ? rect.Max.x : (p.x < rect.Min.x ? rect.Min.x : p.x),\n        (p.y > rect.Max.y) ? rect.Max.y : (p.y < rect.Min.y ? rect.Min.y : p.y)\n    );\n}\n\ninline ImVec2 ImRect_ClosestPoint(const ImRect& rect, const ImVec2& p, bool snap_to_edge, float radius)\n{\n    auto point = ImRect_ClosestPoint(rect, p, snap_to_edge);\n\n    const auto offset      = p - point;\n    const auto distance_sq = offset.x * offset.x + offset.y * offset.y;\n    if (distance_sq <= 0)\n        return point;\n\n    const auto distance = ImSqrt(distance_sq);\n\n    return point + offset * (ImMin(distance, radius) * (1.0f / distance));\n}\n\ninline ImVec2 ImRect_ClosestPoint(const ImRect& rect, const ImRect& other)\n{\n    ImVec2 result;\n    if (other.Min.x >= rect.Max.x)\n        result.x = rect.Max.x;\n    else if (other.Max.x <= rect.Min.x)\n        result.x = rect.Min.x;\n    else\n        result.x = (ImMax(rect.Min.x, other.Min.x) + ImMin(rect.Max.x, other.Max.x)) / 2;\n\n    if (other.Min.y >= rect.Max.y)\n        result.y = rect.Max.y;\n    else if (other.Max.y <= rect.Min.y)\n        result.y = rect.Min.y;\n    else\n        result.y = (ImMax(rect.Min.y, other.Min.y) + ImMin(rect.Max.y, other.Max.y)) / 2;\n\n    return result;\n}\n\ninline ImLine ImRect_ClosestLine(const ImRect& rect_a, const ImRect& rect_b)\n{\n    ImLine result;\n    result.A = ImRect_ClosestPoint(rect_a, rect_b);\n    result.B = ImRect_ClosestPoint(rect_b, rect_a);\n\n    auto distribute = [](float& a, float& b, float a0, float a1, float b0, float b1)\n    {\n        if (a0 >= b1 || a1 <= b0)\n            return;\n\n        const auto aw = a1 - a0;\n        const auto bw = b1 - b0;\n\n        if (aw > bw)\n        {\n            b = b0 + bw - bw * (a - a0) / aw;\n            a = b;\n        }\n        else if (aw < bw)\n        {\n            a = a0 + aw - aw * (b - b0) / bw;\n            b = a;\n        }\n    };\n\n    distribute(result.A.x, result.B.x, rect_a.Min.x, rect_a.Max.x, rect_b.Min.x, rect_b.Max.x);\n    distribute(result.A.y, result.B.y, rect_a.Min.y, rect_a.Max.y, rect_b.Min.y, rect_b.Max.y);\n\n    return result;\n}\n\ninline ImLine ImRect_ClosestLine(const ImRect& rect_a, const ImRect& rect_b, float radius_a, float radius_b)\n{\n    auto line = ImRect_ClosestLine(rect_a, rect_b);\n    if (radius_a < 0)\n        radius_a = 0;\n    if (radius_b < 0)\n        radius_b = 0;\n\n    if (radius_a == 0 && radius_b == 0)\n        return line;\n\n    const auto offset      = line.B - line.A;\n    const auto length_sq   = offset.x * offset.x + offset.y * offset.y;\n    const auto radius_a_sq = radius_a * radius_a;\n    const auto radius_b_sq = radius_b * radius_b;\n\n    if (length_sq <= 0)\n        return line;\n\n    const auto length    = ImSqrt(length_sq);\n    const auto direction = ImVec2(offset.x / length, offset.y / length);\n\n    const auto total_radius_sq = radius_a_sq + radius_b_sq;\n    if (total_radius_sq > length_sq)\n    {\n        const auto scale = length / (radius_a + radius_b);\n        radius_a *= scale;\n        radius_b *= scale;\n    }\n\n    line.A = line.A + (direction * radius_a);\n    line.B = line.B - (direction * radius_b);\n\n    return line;\n}\n\n\n//------------------------------------------------------------------------------\n# endif // __IMGUI_EXTRA_MATH_INL__\n"
        },
        {
          "name": "imgui_node_editor.cpp",
          "type": "blob",
          "size": 173.48046875,
          "content": "//------------------------------------------------------------------------------\n// VERSION 0.9.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n//------------------------------------------------------------------------------\n# include \"imgui_node_editor_internal.h\"\n# include <cstdio> // snprintf\n# include <string>\n# include <fstream>\n# include <bitset>\n# include <climits>\n# include <algorithm>\n# include <sstream>\n# include <streambuf>\n# include <type_traits>\n\n// https://stackoverflow.com/a/8597498\n# define DECLARE_HAS_NESTED(Name, Member)                                          \\\n                                                                                   \\\n    template<class T>                                                              \\\n    struct has_nested_ ## Name                                                     \\\n    {                                                                              \\\n        typedef char yes;                                                          \\\n        typedef yes(&no)[2];                                                       \\\n                                                                                   \\\n        template<class U> static yes test(decltype(U::Member)*);                   \\\n        template<class U> static no  test(...);                                    \\\n                                                                                   \\\n        static bool const value = sizeof(test<T>(0)) == sizeof(yes);               \\\n    };\n\n\nnamespace ax {\nnamespace NodeEditor {\nnamespace Detail {\n\n# if !defined(IMGUI_VERSION_NUM) || (IMGUI_VERSION_NUM < 18822)\n# define DECLARE_KEY_TESTER(Key)                                                                    \\\n    DECLARE_HAS_NESTED(Key, Key)                                                                    \\\n    struct KeyTester_ ## Key                                                                        \\\n    {                                                                                               \\\n        template <typename T>                                                                       \\\n        static int Get(typename std::enable_if<has_nested_ ## Key<ImGuiKey_>::value, T>::type*)     \\\n        {                                                                                           \\\n            return ImGui::GetKeyIndex(T::Key);                                                      \\\n        }                                                                                           \\\n                                                                                                    \\\n        template <typename T>                                                                       \\\n        static int Get(typename std::enable_if<!has_nested_ ## Key<ImGuiKey_>::value, T>::type*)    \\\n        {                                                                                           \\\n            return -1;                                                                              \\\n        }                                                                                           \\\n    }\n\nDECLARE_KEY_TESTER(ImGuiKey_F);\nDECLARE_KEY_TESTER(ImGuiKey_D);\n\nstatic inline int GetKeyIndexForF()\n{\n    return KeyTester_ImGuiKey_F::Get<ImGuiKey_>(nullptr);\n}\n\nstatic inline int GetKeyIndexForD()\n{\n    return KeyTester_ImGuiKey_D::Get<ImGuiKey_>(nullptr);\n}\n# else\nstatic inline ImGuiKey GetKeyIndexForF()\n{\n    return ImGuiKey_F;\n}\n\nstatic inline ImGuiKey GetKeyIndexForD()\n{\n    return ImGuiKey_D;\n}\n# endif\n\n} // namespace Detail\n} // namespace NodeEditor\n} // namespace ax\n\n\n//------------------------------------------------------------------------------\nnamespace ed = ax::NodeEditor::Detail;\n\n\n//------------------------------------------------------------------------------\nstatic const int c_BackgroundChannelCount = 1;\nstatic const int c_LinkChannelCount       = 4;\nstatic const int c_UserLayersCount        = 5;\n\nstatic const int c_UserLayerChannelStart  = 0;\nstatic const int c_BackgroundChannelStart = c_UserLayerChannelStart  + c_UserLayersCount;\nstatic const int c_LinkStartChannel       = c_BackgroundChannelStart + c_BackgroundChannelCount;\nstatic const int c_NodeStartChannel       = c_LinkStartChannel       + c_LinkChannelCount;\n\nstatic const int c_BackgroundChannel_SelectionRect = c_BackgroundChannelStart + 0;\n\nstatic const int c_UserChannel_Content         = c_UserLayerChannelStart + 1;\nstatic const int c_UserChannel_Grid            = c_UserLayerChannelStart + 2;\nstatic const int c_UserChannel_HintsBackground = c_UserLayerChannelStart + 3;\nstatic const int c_UserChannel_Hints           = c_UserLayerChannelStart + 4;\n\nstatic const int c_LinkChannel_Selection  = c_LinkStartChannel + 0;\nstatic const int c_LinkChannel_Links      = c_LinkStartChannel + 1;\nstatic const int c_LinkChannel_Flow       = c_LinkStartChannel + 2;\nstatic const int c_LinkChannel_NewLink    = c_LinkStartChannel + 3;\n\nstatic const int c_ChannelsPerNode           = 5;\nstatic const int c_NodeBaseChannel           = 0;\nstatic const int c_NodeBackgroundChannel     = 1;\nstatic const int c_NodeUserBackgroundChannel = 2;\nstatic const int c_NodePinChannel            = 3;\nstatic const int c_NodeContentChannel        = 4;\n\nstatic const float c_GroupSelectThickness       = 6.0f;  // canvas pixels\nstatic const float c_LinkSelectThickness        = 5.0f;  // canvas pixels\nstatic const float c_NavigationZoomMargin       = 0.1f;  // percentage of visible bounds\nstatic const float c_MouseZoomDuration          = 0.15f; // seconds\nstatic const float c_SelectionFadeOutDuration   = 0.15f; // seconds\n\nstatic const auto  c_MaxMoveOverEdgeSpeed       = 10.0f;\nstatic const auto  c_MaxMoveOverEdgeDistance    = 300.0f;\n\n#if IMGUI_VERSION_NUM > 18101\nstatic const auto  c_AllRoundCornersFlags = ImDrawFlags_RoundCornersAll;\n#else\nstatic const auto  c_AllRoundCornersFlags = 15;\n#endif\n\n\n//------------------------------------------------------------------------------\n# if defined(_DEBUG) && defined(_WIN32)\nextern \"C\" __declspec(dllimport) void __stdcall OutputDebugStringA(const char* string);\n\nstatic void LogV(const char* fmt, va_list args)\n{\n    const int buffer_size = 1024;\n    static char buffer[1024];\n\n    vsnprintf(buffer, buffer_size - 1, fmt, args);\n    buffer[buffer_size - 1] = 0;\n\n    ImGui::LogText(\"\\nNode Editor: %s\", buffer);\n\n    OutputDebugStringA(\"NodeEditor: \");\n    OutputDebugStringA(buffer);\n    OutputDebugStringA(\"\\n\");\n}\n# endif\n\nvoid ed::Log(const char* fmt, ...)\n{\n# if defined(_DEBUG) && defined(_WIN32)\n    va_list args;\n    va_start(args, fmt);\n    LogV(fmt, args);\n    va_end(args);\n# endif\n}\n\n\n//------------------------------------------------------------------------------\nstatic bool IsGroup(const ed::Node* node)\n{\n    if (node && node->m_Type == ed::NodeType::Group)\n        return true;\n    else\n        return false;\n}\n\n\n//------------------------------------------------------------------------------\nstatic void ImDrawListSplitter_Grow(ImDrawList* draw_list, ImDrawListSplitter* splitter, int channels_count)\n{\n    IM_ASSERT(splitter != nullptr);\n    IM_ASSERT(splitter->_Count <= channels_count);\n\n    if (splitter->_Count == 1)\n    {\n        splitter->Split(draw_list, channels_count);\n        return;\n    }\n\n    int old_channels_count = splitter->_Channels.Size;\n    if (old_channels_count < channels_count)\n    {\n        splitter->_Channels.reserve(channels_count);\n        splitter->_Channels.resize(channels_count);\n    }\n    int old_used_channels_count = splitter->_Count;\n    splitter->_Count = channels_count;\n\n    for (int i = old_used_channels_count; i < channels_count; i++)\n    {\n        if (i >= old_channels_count)\n        {\n            IM_PLACEMENT_NEW(&splitter->_Channels[i]) ImDrawChannel();\n        }\n        else\n        {\n            splitter->_Channels[i]._CmdBuffer.resize(0);\n            splitter->_Channels[i]._IdxBuffer.resize(0);\n        }\n    }\n}\n\nstatic void ImDrawList_ChannelsGrow(ImDrawList* draw_list, int channels_count)\n{\n    ImDrawListSplitter_Grow(draw_list, &draw_list->_Splitter, channels_count);\n}\n\nstatic void ImDrawListSplitter_SwapChannels(ImDrawListSplitter* splitter, int left, int right)\n{\n    IM_ASSERT(left < splitter->_Count && right < splitter->_Count);\n    if (left == right)\n        return;\n\n    auto currentChannel = splitter->_Current;\n\n    auto* leftCmdBuffer  = &splitter->_Channels[left]._CmdBuffer;\n    auto* leftIdxBuffer  = &splitter->_Channels[left]._IdxBuffer;\n    auto* rightCmdBuffer = &splitter->_Channels[right]._CmdBuffer;\n    auto* rightIdxBuffer = &splitter->_Channels[right]._IdxBuffer;\n\n    leftCmdBuffer->swap(*rightCmdBuffer);\n    leftIdxBuffer->swap(*rightIdxBuffer);\n\n    if (currentChannel == left)\n        splitter->_Current = right;\n    else if (currentChannel == right)\n        splitter->_Current = left;\n}\n\nstatic void ImDrawList_SwapChannels(ImDrawList* drawList, int left, int right)\n{\n    ImDrawListSplitter_SwapChannels(&drawList->_Splitter, left, right);\n}\n\nstatic void ImDrawList_SwapSplitter(ImDrawList* drawList, ImDrawListSplitter& splitter)\n{\n    auto& currentSplitter = drawList->_Splitter;\n\n    std::swap(currentSplitter._Current, splitter._Current);\n    std::swap(currentSplitter._Count, splitter._Count);\n    currentSplitter._Channels.swap(splitter._Channels);\n}\n\n//static void ImDrawList_TransformChannel_Inner(ImVector<ImDrawVert>& vtxBuffer, const ImVector<ImDrawIdx>& idxBuffer, const ImVector<ImDrawCmd>& cmdBuffer, const ImVec2& preOffset, const ImVec2& scale, const ImVec2& postOffset)\n//{\n//    auto idxRead = idxBuffer.Data;\n//\n//    int indexOffset = 0;\n//    for (auto& cmd : cmdBuffer)\n//    {\n//        auto idxCount = cmd.ElemCount;\n//\n//        if (idxCount == 0) continue;\n//\n//        auto minIndex = idxRead[indexOffset];\n//        auto maxIndex = idxRead[indexOffset];\n//\n//        for (auto i = 1u; i < idxCount; ++i)\n//        {\n//            auto idx = idxRead[indexOffset + i];\n//            minIndex = std::min(minIndex, idx);\n//            maxIndex = ImMax(maxIndex, idx);\n//        }\n//\n//        for (auto vtx = vtxBuffer.Data + minIndex, vtxEnd = vtxBuffer.Data + maxIndex + 1; vtx < vtxEnd; ++vtx)\n//        {\n//            vtx->pos.x = (vtx->pos.x + preOffset.x) * scale.x + postOffset.x;\n//            vtx->pos.y = (vtx->pos.y + preOffset.y) * scale.y + postOffset.y;\n//        }\n//\n//        indexOffset += idxCount;\n//    }\n//}\n\n//static void ImDrawList_TransformChannels(ImDrawList* drawList, int begin, int end, const ImVec2& preOffset, const ImVec2& scale, const ImVec2& postOffset)\n//{\n//    int lastCurrentChannel = drawList->_ChannelsCurrent;\n//    if (lastCurrentChannel != 0)\n//        drawList->ChannelsSetCurrent(0);\n//\n//    auto& vtxBuffer = drawList->VtxBuffer;\n//\n//    if (begin == 0 && begin != end)\n//    {\n//        ImDrawList_TransformChannel_Inner(vtxBuffer, drawList->IdxBuffer, drawList->CmdBuffer, preOffset, scale, postOffset);\n//        ++begin;\n//    }\n//\n//    for (int channelIndex = begin; channelIndex < end; ++channelIndex)\n//    {\n//        auto& channel = drawList->_Channels[channelIndex];\n//        ImDrawList_TransformChannel_Inner(vtxBuffer, channel.IdxBuffer, channel.CmdBuffer, preOffset, scale, postOffset);\n//    }\n//\n//    if (lastCurrentChannel != 0)\n//        drawList->ChannelsSetCurrent(lastCurrentChannel);\n//}\n\n//static void ImDrawList_ClampClipRects_Inner(ImVector<ImDrawCmd>& cmdBuffer, const ImVec4& clipRect, const ImVec2& offset)\n//{\n//    for (auto& cmd : cmdBuffer)\n//    {\n//        cmd.ClipRect.x = ImMax(cmd.ClipRect.x + offset.x, clipRect.x);\n//        cmd.ClipRect.y = ImMax(cmd.ClipRect.y + offset.y, clipRect.y);\n//        cmd.ClipRect.z = std::min(cmd.ClipRect.z + offset.x, clipRect.z);\n//        cmd.ClipRect.w = std::min(cmd.ClipRect.w + offset.y, clipRect.w);\n//    }\n//}\n\n//static void ImDrawList_TranslateAndClampClipRects(ImDrawList* drawList, int begin, int end, const ImVec2& offset)\n//{\n//    int lastCurrentChannel = drawList->_ChannelsCurrent;\n//    if (lastCurrentChannel != 0)\n//        drawList->ChannelsSetCurrent(0);\n//\n//    auto clipRect = drawList->_ClipRectStack.back();\n//\n//    if (begin == 0 && begin != end)\n//    {\n//        ImDrawList_ClampClipRects_Inner(drawList->CmdBuffer, clipRect, offset);\n//        ++begin;\n//    }\n//\n//    for (int channelIndex = begin; channelIndex < end; ++channelIndex)\n//    {\n//        auto& channel = drawList->_Channels[channelIndex];\n//        ImDrawList_ClampClipRects_Inner(channel.CmdBuffer, clipRect, offset);\n//    }\n//\n//    if (lastCurrentChannel != 0)\n//        drawList->ChannelsSetCurrent(lastCurrentChannel);\n//}\n\nstatic void ImDrawList_PathBezierOffset(ImDrawList* drawList, float offset, const ImVec2& p0, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3)\n{\n    using namespace ed;\n\n    auto acceptPoint = [drawList, offset](const ImCubicBezierSubdivideSample& r)\n    {\n        drawList->PathLineTo(r.Point + ImNormalized(ImVec2(-r.Tangent.y, r.Tangent.x)) * offset);\n    };\n\n    ImCubicBezierSubdivide(acceptPoint, p0, p1, p2, p3);\n}\n\n/*\nstatic void ImDrawList_PolyFillScanFlood(ImDrawList *draw, std::vector<ImVec2>* poly, ImColor color, int gap = 1, float strokeWidth = 1.0f)\n{\n    std::vector<ImVec2> scanHits;\n    ImVec2 min, max; // polygon min/max points\n    auto io = ImGui::GetIO();\n    float y;\n    bool isMinMaxDone = false;\n    unsigned int polysize = poly->size();\n\n    // find the orthagonal bounding box\n    // probably can put this as a predefined\n    if (!isMinMaxDone)\n    {\n        min.x = min.y = FLT_MAX;\n        max.x = max.y = FLT_MIN;\n        for (auto p : *poly)\n        {\n            if (p.x < min.x) min.x = p.x;\n            if (p.y < min.y) min.y = p.y;\n            if (p.x > max.x) max.x = p.x;\n            if (p.y > max.y) max.y = p.y;\n        }\n        isMinMaxDone = true;\n    }\n\n    // Bounds check\n    if ((max.x < 0) || (min.x > io.DisplaySize.x) || (max.y < 0) || (min.y > io.DisplaySize.y)) return;\n\n    // Vertically clip\n    if (min.y < 0) min.y = 0;\n    if (max.y > io.DisplaySize.y) max.y = io.DisplaySize.y;\n\n    // so we know we start on the outside of the object we step out by 1.\n    min.x -= 1;\n    max.x += 1;\n\n    // Initialise our starting conditions\n    y = min.y;\n\n    // Go through each scan line iteratively, jumping by 'gap' pixels each time\n    while (y < max.y)\n    {\n        scanHits.clear();\n\n        {\n            int jump = 1;\n            ImVec2 fp = poly->at(0);\n\n            for (size_t i = 0; i < polysize - 1; i++)\n            {\n                ImVec2 pa = poly->at(i);\n                ImVec2 pb = poly->at(i + 1);\n\n                // jump double/dud points\n                if (pa.x == pb.x && pa.y == pb.y) continue;\n\n                // if we encounter our hull/poly start point, then we've now created the\n                // closed\n                // hull, jump the next segment and reset the first-point\n                if ((!jump) && (fp.x == pb.x) && (fp.y == pb.y))\n                {\n                    if (i < polysize - 2)\n                    {\n                        fp = poly->at(i + 2);\n                        jump = 1;\n                        i++;\n                    }\n                }\n                else\n                {\n                    jump = 0;\n                }\n\n                // test to see if this segment makes the scan-cut.\n                if ((pa.y > pb.y && y < pa.y && y > pb.y) || (pa.y < pb.y && y > pa.y && y < pb.y))\n                {\n                    ImVec2 intersect;\n\n                    intersect.y = y;\n                    if (pa.x == pb.x)\n                    {\n                        intersect.x = pa.x;\n                    }\n                    else\n                    {\n                        intersect.x = (pb.x - pa.x) / (pb.y - pa.y) * (y - pa.y) + pa.x;\n                    }\n                    scanHits.push_back(intersect);\n                }\n            }\n\n            // Sort the scan hits by X, so we have a proper left->right ordering\n            sort(scanHits.begin(), scanHits.end(), [](ImVec2 const &a, ImVec2 const &b) { return a.x < b.x; });\n\n            // generate the line segments.\n            {\n                int i = 0;\n                int l = scanHits.size() - 1; // we need pairs of points, this prevents segfault.\n                for (i = 0; i < l; i += 2)\n                {\n                    draw->AddLine(scanHits[i], scanHits[i + 1], color, strokeWidth);\n                }\n            }\n        }\n        y += gap;\n    } // for each scan line\n    scanHits.clear();\n}\n*/\n\nstatic void ImDrawList_AddBezierWithArrows(ImDrawList* drawList, const ImCubicBezierPoints& curve, float thickness,\n    float startArrowSize, float startArrowWidth, float endArrowSize, float endArrowWidth,\n    bool fill, ImU32 color, float strokeThickness, const ImVec2* startDirHint = nullptr, const ImVec2* endDirHint = nullptr)\n{\n    using namespace ax;\n\n    if ((color >> 24) == 0)\n        return;\n\n    const auto half_thickness = thickness * 0.5f;\n\n    if (fill)\n    {\n        drawList->AddBezierCubic(curve.P0, curve.P1, curve.P2, curve.P3, color, thickness);\n\n        if (startArrowSize > 0.0f)\n        {\n            const auto start_dir  = ImNormalized(startDirHint ? *startDirHint : ImCubicBezierTangent(curve.P0, curve.P1, curve.P2, curve.P3, 0.0f));\n            const auto start_n    = ImVec2(-start_dir.y, start_dir.x);\n            const auto half_width = startArrowWidth * 0.5f;\n            const auto tip        = curve.P0 - start_dir * startArrowSize;\n\n            drawList->PathLineTo(curve.P0 - start_n * ImMax(half_width, half_thickness));\n            drawList->PathLineTo(curve.P0 + start_n * ImMax(half_width, half_thickness));\n            drawList->PathLineTo(tip);\n            drawList->PathFillConvex(color);\n        }\n\n        if (endArrowSize > 0.0f)\n        {\n            const auto    end_dir = ImNormalized(endDirHint ? -*endDirHint : ImCubicBezierTangent(curve.P0, curve.P1, curve.P2, curve.P3, 1.0f));\n            const auto    end_n   = ImVec2(  -end_dir.y,   end_dir.x);\n            const auto half_width = endArrowWidth * 0.5f;\n            const auto tip        = curve.P3 + end_dir * endArrowSize;\n\n            drawList->PathLineTo(curve.P3 + end_n * ImMax(half_width, half_thickness));\n            drawList->PathLineTo(curve.P3 - end_n * ImMax(half_width, half_thickness));\n            drawList->PathLineTo(tip);\n            drawList->PathFillConvex(color);\n        }\n    }\n    else\n    {\n        if (startArrowSize > 0.0f)\n        {\n            const auto start_dir  = ImNormalized(ImCubicBezierTangent(curve.P0, curve.P1, curve.P2, curve.P3, 0.0f));\n            const auto start_n    = ImVec2(-start_dir.y, start_dir.x);\n            const auto half_width = startArrowWidth * 0.5f;\n            const auto tip        = curve.P0 - start_dir * startArrowSize;\n\n            if (half_width > half_thickness)\n                drawList->PathLineTo(curve.P0 - start_n * half_width);\n            drawList->PathLineTo(tip);\n            if (half_width > half_thickness)\n                drawList->PathLineTo(curve.P0 + start_n * half_width);\n        }\n\n        ImDrawList_PathBezierOffset(drawList, half_thickness, curve.P0, curve.P1, curve.P2, curve.P3);\n\n        if (endArrowSize > 0.0f)\n        {\n            const auto    end_dir = ImNormalized(ImCubicBezierTangent(curve.P0, curve.P1, curve.P2, curve.P3, 1.0f));\n            const auto    end_n   = ImVec2(  -end_dir.y,   end_dir.x);\n            const auto half_width = endArrowWidth * 0.5f;\n            const auto tip        = curve.P3 + end_dir * endArrowSize;\n\n            if (half_width > half_thickness)\n                drawList->PathLineTo(curve.P3 + end_n * half_width);\n            drawList->PathLineTo(tip);\n            if (half_width > half_thickness)\n                drawList->PathLineTo(curve.P3 - end_n * half_width);\n        }\n\n        ImDrawList_PathBezierOffset(drawList, half_thickness, curve.P3, curve.P2, curve.P1, curve.P0);\n\n        drawList->PathStroke(color, true, strokeThickness);\n    }\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Pin\n//\n//------------------------------------------------------------------------------\nvoid ed::Pin::Draw(ImDrawList* drawList, DrawFlags flags)\n{\n    if (flags & Hovered)\n    {\n        drawList->ChannelsSetCurrent(m_Node->m_Channel + c_NodePinChannel);\n\n        drawList->AddRectFilled(m_Bounds.Min, m_Bounds.Max,\n            m_Color, m_Rounding, m_Corners);\n\n        if (m_BorderWidth > 0.0f)\n        {\n            FringeScaleScope fringe(1.0f);\n            drawList->AddRect(m_Bounds.Min, m_Bounds.Max,\n                m_BorderColor, m_Rounding, m_Corners, m_BorderWidth);\n        }\n\n        if (!Editor->IsSelected(m_Node))\n            m_Node->Draw(drawList, flags);\n    }\n}\n\nImVec2 ed::Pin::GetClosestPoint(const ImVec2& p) const\n{\n    auto pivot  = m_Pivot;\n    auto extent = m_Radius + m_ArrowSize;\n\n    if (m_SnapLinkToDir && extent > 0.0f)\n    {\n        pivot.Min += m_Dir * extent;\n        pivot.Max += m_Dir * extent;\n\n        extent = 0;\n    }\n\n    return ImRect_ClosestPoint(pivot, p, true, extent);\n}\n\nImLine ed::Pin::GetClosestLine(const Pin* pin) const\n{\n    auto pivotA  =      m_Pivot;\n    auto pivotB  = pin->m_Pivot;\n    auto extentA =      m_Radius +      m_ArrowSize;\n    auto extentB = pin->m_Radius + pin->m_ArrowSize;\n\n    if (m_SnapLinkToDir && extentA > 0.0f)\n    {\n        pivotA.Min += m_Dir * extentA;\n        pivotA.Max += m_Dir * extentA;\n\n        extentA = 0;\n    }\n\n    if (pin->m_SnapLinkToDir && extentB > 0.0f)\n    {\n        pivotB.Min += pin->m_Dir * extentB;\n        pivotB.Max += pin->m_Dir * extentB;\n\n        extentB = 0;\n    }\n\n    return ImRect_ClosestLine(pivotA, pivotB, extentA, extentB);\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Node\n//\n//------------------------------------------------------------------------------\nbool ed::Node::AcceptDrag()\n{\n    m_DragStart = m_Bounds.Min;\n    return true;\n}\n\nvoid ed::Node::UpdateDrag(const ImVec2& offset)\n{\n    auto size = m_Bounds.GetSize();\n    m_Bounds.Min = ImFloor(m_DragStart + offset);\n    m_Bounds.Max = m_Bounds.Min + size;\n}\n\nbool ed::Node::EndDrag()\n{\n    return m_Bounds.Min != m_DragStart;\n}\n\nvoid ed::Node::Draw(ImDrawList* drawList, DrawFlags flags)\n{\n    if (flags == Detail::Object::None)\n    {\n        drawList->ChannelsSetCurrent(m_Channel + c_NodeBackgroundChannel);\n\n        drawList->AddRectFilled(\n            m_Bounds.Min,\n            m_Bounds.Max,\n            m_Color, m_Rounding);\n\n        if (IsGroup(this))\n        {\n            drawList->AddRectFilled(\n                m_GroupBounds.Min,\n                m_GroupBounds.Max,\n                m_GroupColor, m_GroupRounding);\n\n            if (m_GroupBorderWidth > 0.0f)\n            {\n                FringeScaleScope fringe(1.0f);\n\n                drawList->AddRect(\n                    m_GroupBounds.Min,\n                    m_GroupBounds.Max,\n                    m_GroupBorderColor, m_GroupRounding, c_AllRoundCornersFlags, m_GroupBorderWidth);\n            }\n        }\n\n# if 0\n        // #debug: highlight group regions\n        auto drawRect = [drawList](const ImRect& rect, ImU32 color)\n        {\n            if (ImRect_IsEmpty(rect)) return;\n            drawList->AddRectFilled(rect.Min, rect.Max, color);\n        };\n\n        drawRect(GetRegionBounds(NodeRegion::Top), IM_COL32(255, 0, 0, 64));\n        drawRect(GetRegionBounds(NodeRegion::Bottom), IM_COL32(255, 0, 0, 64));\n        drawRect(GetRegionBounds(NodeRegion::Left), IM_COL32(0, 255, 0, 64));\n        drawRect(GetRegionBounds(NodeRegion::Right), IM_COL32(0, 255, 0, 64));\n        drawRect(GetRegionBounds(NodeRegion::TopLeft), IM_COL32(255, 0, 255, 64));\n        drawRect(GetRegionBounds(NodeRegion::TopRight), IM_COL32(255, 0, 255, 64));\n        drawRect(GetRegionBounds(NodeRegion::BottomLeft), IM_COL32(255, 0, 255, 64));\n        drawRect(GetRegionBounds(NodeRegion::BottomRight), IM_COL32(255, 0, 255, 64));\n        drawRect(GetRegionBounds(NodeRegion::Center), IM_COL32(0, 0, 255, 64));\n        drawRect(GetRegionBounds(NodeRegion::Header), IM_COL32(0, 255, 255, 64));\n# endif\n\n        DrawBorder(drawList, m_BorderColor, m_BorderWidth);\n    }\n    else if (flags & Selected)\n    {\n        const auto  borderColor = Editor->GetColor(StyleColor_SelNodeBorder);\n        const auto& editorStyle = Editor->GetStyle();\n\n        drawList->ChannelsSetCurrent(m_Channel + c_NodeBaseChannel);\n\n        DrawBorder(drawList, borderColor, editorStyle.SelectedNodeBorderWidth, editorStyle.SelectedNodeBorderOffset);\n    }\n    else if (!IsGroup(this) && (flags & Hovered))\n    {\n        const auto  borderColor = Editor->GetColor(StyleColor_HovNodeBorder);\n        const auto& editorStyle = Editor->GetStyle();\n\n        drawList->ChannelsSetCurrent(m_Channel + c_NodeBaseChannel);\n\n        DrawBorder(drawList, borderColor, editorStyle.HoveredNodeBorderWidth, editorStyle.HoverNodeBorderOffset);\n    }\n}\n\nvoid ed::Node::DrawBorder(ImDrawList* drawList, ImU32 color, float thickness, float offset)\n{\n    if (thickness > 0.0f)\n    {\n        const ImVec2 extraOffset = ImVec2(offset, offset);\n\n        drawList->AddRect(m_Bounds.Min - extraOffset, m_Bounds.Max + extraOffset,\n            color, ImMax(0.0f, m_Rounding + offset), c_AllRoundCornersFlags, thickness);\n    }\n}\n\nvoid ed::Node::GetGroupedNodes(std::vector<Node*>& result, bool append)\n{\n    if (!append)\n        result.resize(0);\n\n    if (!IsGroup(this))\n        return;\n\n    const auto firstNodeIndex = result.size();\n    Editor->FindNodesInRect(m_GroupBounds, result, true, false);\n\n    for (auto index = firstNodeIndex; index < result.size(); ++index)\n        result[index]->GetGroupedNodes(result, true);\n}\n\nImRect ed::Node::GetRegionBounds(NodeRegion region) const\n{\n    if (m_Type == NodeType::Node)\n    {\n        if (region == NodeRegion::Header)\n            return m_Bounds;\n    }\n    else if (m_Type == NodeType::Group)\n    {\n        const float activeAreaMinimumSize = ImMax(ImMax(\n            Editor->GetView().InvScale * c_GroupSelectThickness,\n            m_GroupBorderWidth), c_GroupSelectThickness);\n        const float minimumSize = activeAreaMinimumSize * 5;\n\n        auto bounds = m_Bounds;\n        if (bounds.GetWidth() < minimumSize)\n            bounds.Expand(ImVec2(minimumSize - bounds.GetWidth(), 0.0f));\n        if (bounds.GetHeight() < minimumSize)\n            bounds.Expand(ImVec2(0.0f, minimumSize - bounds.GetHeight()));\n\n        if (region == NodeRegion::Top)\n        {\n            bounds.Max.y = bounds.Min.y + activeAreaMinimumSize;\n            bounds.Min.x += activeAreaMinimumSize;\n            bounds.Max.x -= activeAreaMinimumSize;\n            return bounds;\n        }\n        else if (region == NodeRegion::Bottom)\n        {\n            bounds.Min.y = bounds.Max.y - activeAreaMinimumSize;\n            bounds.Min.x += activeAreaMinimumSize;\n            bounds.Max.x -= activeAreaMinimumSize;\n            return bounds;\n        }\n        else if (region == NodeRegion::Left)\n        {\n            bounds.Max.x = bounds.Min.x + activeAreaMinimumSize;\n            bounds.Min.y += activeAreaMinimumSize;\n            bounds.Max.y -= activeAreaMinimumSize;\n            return bounds;\n        }\n        else if (region == NodeRegion::Right)\n        {\n            bounds.Min.x = bounds.Max.x - activeAreaMinimumSize;\n            bounds.Min.y += activeAreaMinimumSize;\n            bounds.Max.y -= activeAreaMinimumSize;\n            return bounds;\n        }\n        else if (region == NodeRegion::TopLeft)\n        {\n            bounds.Max.x = bounds.Min.x + activeAreaMinimumSize * 2;\n            bounds.Max.y = bounds.Min.y + activeAreaMinimumSize * 2;\n            return bounds;\n        }\n        else if (region == NodeRegion::TopRight)\n        {\n            bounds.Min.x = bounds.Max.x - activeAreaMinimumSize * 2;\n            bounds.Max.y = bounds.Min.y + activeAreaMinimumSize * 2;\n            return bounds;\n        }\n        else if (region == NodeRegion::BottomRight)\n        {\n            bounds.Min.x = bounds.Max.x - activeAreaMinimumSize * 2;\n            bounds.Min.y = bounds.Max.y - activeAreaMinimumSize * 2;\n            return bounds;\n        }\n        else if (region == NodeRegion::BottomLeft)\n        {\n            bounds.Max.x = bounds.Min.x + activeAreaMinimumSize * 2;\n            bounds.Min.y = bounds.Max.y - activeAreaMinimumSize * 2;\n            return bounds;\n        }\n        else if (region == NodeRegion::Header)\n        {\n            bounds.Min.x += activeAreaMinimumSize;\n            bounds.Max.x -= activeAreaMinimumSize;\n            bounds.Min.y += activeAreaMinimumSize;\n            bounds.Max.y  = ImMax(bounds.Min.y + activeAreaMinimumSize, m_GroupBounds.Min.y);\n            return bounds;\n        }\n        else if (region == NodeRegion::Center)\n        {\n            bounds.Max.x -= activeAreaMinimumSize;\n            bounds.Min.y  = ImMax(bounds.Min.y + activeAreaMinimumSize, m_GroupBounds.Min.y);\n            bounds.Min.x += activeAreaMinimumSize;\n            bounds.Max.y -= activeAreaMinimumSize;\n            return bounds;\n        }\n    }\n\n    return ImRect();\n}\n\ned::NodeRegion ed::Node::GetRegion(const ImVec2& point) const\n{\n    if (m_Type == NodeType::Node)\n    {\n        if (m_Bounds.Contains(point))\n            return NodeRegion::Header;\n        else\n            return NodeRegion::None;\n    }\n    else if (m_Type == NodeType::Group)\n    {\n        static const NodeRegion c_Regions[] =\n        {\n            // Corners first, they may overlap other regions.\n            NodeRegion::TopLeft,\n            NodeRegion::TopRight,\n            NodeRegion::BottomLeft,\n            NodeRegion::BottomRight,\n            NodeRegion::Header,\n            NodeRegion::Top,\n            NodeRegion::Bottom,\n            NodeRegion::Left,\n            NodeRegion::Right,\n            NodeRegion::Center\n        };\n\n        for (auto region : c_Regions)\n        {\n            auto bounds = GetRegionBounds(region);\n            if (bounds.Contains(point))\n                return region;\n        }\n    }\n\n    return NodeRegion::None;\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Link\n//\n//------------------------------------------------------------------------------\nvoid ed::Link::Draw(ImDrawList* drawList, DrawFlags flags)\n{\n    if (flags == None)\n    {\n        drawList->ChannelsSetCurrent(c_LinkChannel_Links);\n\n        Draw(drawList, m_Color, 0.0f);\n    }\n    else if (flags & Selected)\n    {\n        const auto borderColor = Editor->GetColor(StyleColor_SelLinkBorder);\n\n        drawList->ChannelsSetCurrent(c_LinkChannel_Selection);\n\n        Draw(drawList, borderColor, 4.5f);\n    }\n    else if (flags & Hovered)\n    {\n        const auto borderColor = Editor->GetColor(StyleColor_HovLinkBorder);\n\n        drawList->ChannelsSetCurrent(c_LinkChannel_Selection);\n\n        Draw(drawList, borderColor, 2.0f);\n    }\n    else if (flags & Highlighted)\n    {\n        drawList->ChannelsSetCurrent(c_LinkChannel_Selection);\n\n        Draw(drawList, m_HighlightColor, 3.5f);\n    }\n}\n\nvoid ed::Link::Draw(ImDrawList* drawList, ImU32 color, float extraThickness) const\n{\n    if (!m_IsLive)\n        return;\n\n    const auto curve = GetCurve();\n\n    ImDrawList_AddBezierWithArrows(drawList, curve, m_Thickness + extraThickness,\n        m_StartPin && m_StartPin->m_ArrowSize  > 0.0f ? m_StartPin->m_ArrowSize  + extraThickness : 0.0f,\n        m_StartPin && m_StartPin->m_ArrowWidth > 0.0f ? m_StartPin->m_ArrowWidth + extraThickness : 0.0f,\n          m_EndPin &&   m_EndPin->m_ArrowSize  > 0.0f ?   m_EndPin->m_ArrowSize  + extraThickness : 0.0f,\n          m_EndPin &&   m_EndPin->m_ArrowWidth > 0.0f ?   m_EndPin->m_ArrowWidth + extraThickness : 0.0f,\n        true, color, 1.0f,\n        m_StartPin && m_StartPin->m_SnapLinkToDir ? &m_StartPin->m_Dir : nullptr,\n        m_EndPin   &&   m_EndPin->m_SnapLinkToDir ?   &m_EndPin->m_Dir : nullptr);\n}\n\nvoid ed::Link::UpdateEndpoints()\n{\n    const auto line = m_StartPin->GetClosestLine(m_EndPin);\n    m_Start = line.A;\n    m_End   = line.B;\n}\n\nImCubicBezierPoints ed::Link::GetCurve() const\n{\n    auto easeLinkStrength = [](const ImVec2& a, const ImVec2& b, float strength)\n    {\n        const auto distanceX    = b.x - a.x;\n        const auto distanceY    = b.y - a.y;\n        const auto distance     = ImSqrt(distanceX * distanceX + distanceY * distanceY);\n        const auto halfDistance = distance * 0.5f;\n\n        if (halfDistance < strength)\n            strength = strength * ImSin(IM_PI * 0.5f * halfDistance / strength);\n\n        return strength;\n    };\n\n    const auto startStrength = easeLinkStrength(m_Start, m_End, m_StartPin->m_Strength);\n    const auto   endStrength = easeLinkStrength(m_Start, m_End,   m_EndPin->m_Strength);\n    const auto           cp0 = m_Start + m_StartPin->m_Dir * startStrength;\n    const auto           cp1 =   m_End +   m_EndPin->m_Dir *   endStrength;\n\n    ImCubicBezierPoints result;\n    result.P0 = m_Start;\n    result.P1 = cp0;\n    result.P2 = cp1;\n    result.P3 = m_End;\n\n    return result;\n}\n\nbool ed::Link::TestHit(const ImVec2& point, float extraThickness) const\n{\n    if (!m_IsLive)\n        return false;\n\n    auto bounds = GetBounds();\n    if (extraThickness > 0.0f)\n        bounds.Expand(extraThickness);\n\n    if (!bounds.Contains(point))\n        return false;\n\n    const auto bezier = GetCurve();\n    const auto result = ImProjectOnCubicBezier(point, bezier.P0, bezier.P1, bezier.P2, bezier.P3, 50);\n\n    return result.Distance <= m_Thickness + extraThickness;\n}\n\nbool ed::Link::TestHit(const ImRect& rect, bool allowIntersect) const\n{\n    if (!m_IsLive)\n        return false;\n\n    const auto bounds = GetBounds();\n\n    if (rect.Contains(bounds))\n        return true;\n\n    if (!allowIntersect || !rect.Overlaps(bounds))\n        return false;\n\n    const auto bezier = GetCurve();\n\n    const auto p0 = rect.GetTL();\n    const auto p1 = rect.GetTR();\n    const auto p2 = rect.GetBR();\n    const auto p3 = rect.GetBL();\n\n    if (ImCubicBezierLineIntersect(bezier.P0, bezier.P1, bezier.P2, bezier.P3, p0, p1).Count > 0)\n        return true;\n    if (ImCubicBezierLineIntersect(bezier.P0, bezier.P1, bezier.P2, bezier.P3, p1, p2).Count > 0)\n        return true;\n    if (ImCubicBezierLineIntersect(bezier.P0, bezier.P1, bezier.P2, bezier.P3, p2, p3).Count > 0)\n        return true;\n    if (ImCubicBezierLineIntersect(bezier.P0, bezier.P1, bezier.P2, bezier.P3, p3, p0).Count > 0)\n        return true;\n\n    return false;\n}\n\nImRect ed::Link::GetBounds() const\n{\n    if (m_IsLive)\n    {\n        const auto curve = GetCurve();\n        auto bounds = ImCubicBezierBoundingRect(curve.P0, curve.P1, curve.P2, curve.P3);\n\n        if (bounds.GetWidth() == 0.0f)\n        {\n            bounds.Min.x -= 0.5f;\n            bounds.Max.x += 0.5f;\n        }\n\n        if (bounds.GetHeight() == 0.0f)\n        {\n            bounds.Min.y -= 0.5f;\n            bounds.Max.y += 0.5f;\n        }\n\n        if (m_StartPin->m_ArrowSize)\n        {\n            const auto start_dir = ImNormalized(ImCubicBezierTangent(curve.P0, curve.P1, curve.P2, curve.P3, 0.0f));\n            const auto p0 = curve.P0;\n            const auto p1 = curve.P0 - start_dir * m_StartPin->m_ArrowSize;\n            const auto min = ImMin(p0, p1);\n            const auto max = ImMax(p0, p1);\n            auto arrowBounds = ImRect(min, ImMax(max, min + ImVec2(1, 1)));\n            bounds.Add(arrowBounds);\n        }\n\n        if (m_EndPin->m_ArrowSize)\n        {\n            const auto end_dir = ImNormalized(ImCubicBezierTangent(curve.P0, curve.P1, curve.P2, curve.P3, 1.0f));\n            const auto p0 = curve.P3;\n            const auto p1 = curve.P3 + end_dir * m_EndPin->m_ArrowSize;\n            const auto min = ImMin(p0, p1);\n            const auto max = ImMax(p0, p1);\n            auto arrowBounds = ImRect(min, ImMax(max, min + ImVec2(1, 1)));\n            bounds.Add(arrowBounds);\n        }\n\n        return bounds;\n    }\n    else\n        return ImRect();\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Editor Context\n//\n//------------------------------------------------------------------------------\ned::EditorContext::EditorContext(const ax::NodeEditor::Config* config)\n    : m_Config(config)\n    , m_EditorActiveId(0)\n    , m_IsFirstFrame(true)\n    , m_IsFocused(false)\n    , m_IsHovered(false)\n    , m_IsHoveredWithoutOverlapp(false)\n    , m_ShortcutsEnabled(true)\n    , m_Style()\n    , m_Nodes()\n    , m_Pins()\n    , m_Links()\n    , m_SelectionId(1)\n    , m_LastActiveLink(nullptr)\n    , m_Canvas()\n    , m_IsCanvasVisible(false)\n    , m_NodeBuilder(this)\n    , m_HintBuilder(this)\n    , m_CurrentAction(nullptr)\n    , m_NavigateAction(this, m_Canvas)\n    , m_SizeAction(this)\n    , m_DragAction(this)\n    , m_SelectAction(this)\n    , m_ContextMenuAction(this)\n    , m_ShortcutAction(this)\n    , m_CreateItemAction(this)\n    , m_DeleteItemsAction(this)\n    , m_AnimationControllers{ &m_FlowAnimationController }\n    , m_FlowAnimationController(this)\n    , m_HoveredNode(0)\n    , m_HoveredPin(0)\n    , m_HoveredLink(0)\n    , m_DoubleClickedNode(0)\n    , m_DoubleClickedPin(0)\n    , m_DoubleClickedLink(0)\n    , m_BackgroundClickButtonIndex(-1)\n    , m_BackgroundDoubleClickButtonIndex(-1)\n    , m_IsInitialized(false)\n    , m_Settings()\n    , m_DrawList(nullptr)\n    , m_ExternalChannel(0)\n{\n}\n\ned::EditorContext::~EditorContext()\n{\n    if (m_IsInitialized)\n        SaveSettings();\n\n    for (auto link  : m_Links)  delete link.m_Object;\n    for (auto pin   : m_Pins)   delete pin.m_Object;\n    for (auto node  : m_Nodes)  delete node.m_Object;\n\n    m_Splitter.ClearFreeMemory();\n}\n\nvoid ed::EditorContext::Begin(const char* id, const ImVec2& size)\n{\n    m_EditorActiveId = ImGui::GetID(id);\n    ImGui::PushID(id);\n\n    auto availableContentSize = ImGui::GetContentRegionAvail();\n    ImVec2 canvasSize = ImFloor(size);\n    if (canvasSize.x <= 0.0f)\n        canvasSize.x = ImMax(4.0f, availableContentSize.x);\n    if (canvasSize.y <= 0.0f)\n        canvasSize.y = ImMax(4.0f, availableContentSize.y);\n\n    if (!m_IsInitialized)\n    {\n        // Cycle canvas, so it has a chance to initialize its size before settings are loaded\n        if (m_Canvas.Begin(id, canvasSize))\n            m_Canvas.End();\n\n        LoadSettings();\n        m_IsInitialized = true;\n    }\n\n    //ImGui::LogToClipboard();\n    //Log(\"---- begin ----\");\n\n    static auto resetAndCollect = [](auto& objects)\n    {\n        objects.erase(std::remove_if(objects.begin(), objects.end(), [](auto objectWrapper)\n        {\n            if (objectWrapper->m_DeleteOnNewFrame)\n            {\n                delete objectWrapper.m_Object;\n                return true;\n            }\n            else\n            {\n                objectWrapper->Reset();\n                return false;\n            }\n        }), objects.end());\n    };\n\n    resetAndCollect(m_Nodes);\n    resetAndCollect(m_Pins);\n    resetAndCollect(m_Links);\n\n    m_DrawList = ImGui::GetWindowDrawList();\n\n    ImDrawList_SwapSplitter(m_DrawList, m_Splitter);\n    m_ExternalChannel = m_DrawList->_Splitter._Current;\n\n    if (m_CurrentAction && m_CurrentAction->IsDragging() && m_NavigateAction.MoveOverEdge(canvasSize))\n    {\n        auto& io = ImGui::GetIO();\n        auto offset = m_NavigateAction.GetMoveScreenOffset();\n        for (int i = 0; i < 5; ++i)\n            io.MouseClickedPos[i] = io.MouseClickedPos[i] - offset;\n    }\n    else\n        m_NavigateAction.StopMoveOverEdge();\n\n    auto previousSize        = m_Canvas.Rect().GetSize();\n    auto previousVisibleRect = m_Canvas.ViewRect();\n    m_IsCanvasVisible = m_Canvas.Begin(id, canvasSize);\n\n    //ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0, 0, 0, 0));\n    //ImGui::BeginChild(id, size, false,\n    //    ImGuiWindowFlags_NoMove |\n    //    ImGuiWindowFlags_NoScrollbar |\n    //    ImGuiWindowFlags_NoScrollWithMouse);\n\n    m_IsFocused = ImGui::IsWindowFocused();\n\n    //\n    m_NavigateAction.SetWindow(m_Canvas.ViewRect().Min, m_Canvas.ViewRect().GetSize());\n\n    // Handle canvas size change. Scale to Y axis, center on X.\n    if (!ImRect_IsEmpty(previousVisibleRect) && previousSize != canvasSize)\n    {\n        m_NavigateAction.FinishNavigation();\n\n        auto centerX            = (previousVisibleRect.Max.x + previousVisibleRect.Min.x) * 0.5f;\n        auto centerY            = (previousVisibleRect.Max.y + previousVisibleRect.Min.y) * 0.5f;\n        auto currentVisibleRect = m_Canvas.ViewRect();\n        auto currentAspectRatio = currentVisibleRect.GetHeight() ? (currentVisibleRect.GetWidth() / currentVisibleRect.GetHeight()) : 0.0f;\n        auto width              = previousVisibleRect.GetWidth();\n        auto height             = previousVisibleRect.GetHeight();\n\n        if (m_Config.CanvasSizeMode == ax::NodeEditor::CanvasSizeMode::FitVerticalView)\n        {\n            height  = previousVisibleRect.GetHeight();\n            width   = height * currentAspectRatio;\n        }\n        else if (m_Config.CanvasSizeMode == ax::NodeEditor::CanvasSizeMode::FitHorizontalView)\n        {\n            width   = previousVisibleRect.GetWidth();\n            height  = width / currentAspectRatio;\n        }\n        else if (m_Config.CanvasSizeMode == ax::NodeEditor::CanvasSizeMode::CenterOnly)\n        {\n            width  = currentVisibleRect.GetWidth();\n            height = currentVisibleRect.GetHeight();\n        }\n\n        previousVisibleRect.Min.x = centerX - 0.5f * width;\n        previousVisibleRect.Max.x = centerX + 0.5f * width;\n        previousVisibleRect.Min.y = centerY - 0.5f * height;\n        previousVisibleRect.Max.y = centerY + 0.5f * height;\n\n        m_NavigateAction.NavigateTo(previousVisibleRect, Detail::NavigateAction::ZoomMode::Exact, 0.0f);\n    }\n\n    m_Canvas.SetView(m_NavigateAction.GetView());\n\n    // #debug #clip\n    //ImGui::Text(\"CLIP = { x=%g y=%g w=%g h=%g r=%g b=%g }\",\n    //    clipMin.x, clipMin.y, clipMax.x - clipMin.x, clipMax.y - clipMin.y, clipMax.x, clipMax.y);\n\n    // Reserve channels for background and links\n    ImDrawList_ChannelsGrow(m_DrawList, c_NodeStartChannel);\n\n    if (HasSelectionChanged())\n        ++m_SelectionId;\n\n    m_LastSelectedObjects = m_SelectedObjects;\n}\n\nvoid ed::EditorContext::End()\n{\n    //auto& io          = ImGui::GetIO();\n    auto  control     = BuildControl(m_CurrentAction && m_CurrentAction->IsDragging()); // NavigateAction.IsMovingOverEdge()\n    //auto& editorStyle = GetStyle();\n\n    m_HoveredNode             = control.HotNode && m_CurrentAction == nullptr ? control.HotNode->m_ID : 0;\n    m_HoveredPin              = control.HotPin  && m_CurrentAction == nullptr ? control.HotPin->m_ID  : 0;\n    m_HoveredLink             = control.HotLink && m_CurrentAction == nullptr ? control.HotLink->m_ID : 0;\n    m_DoubleClickedNode       = control.DoubleClickedNode ? control.DoubleClickedNode->m_ID : 0;\n    m_DoubleClickedPin        = control.DoubleClickedPin  ? control.DoubleClickedPin->m_ID  : 0;\n    m_DoubleClickedLink       = control.DoubleClickedLink ? control.DoubleClickedLink->m_ID : 0;\n    m_BackgroundClickButtonIndex       = control.BackgroundClickButtonIndex;\n    m_BackgroundDoubleClickButtonIndex = control.BackgroundDoubleClickButtonIndex;\n\n    //if (DoubleClickedNode) LOG_TRACE(0, \"DOUBLE CLICK NODE: %d\", DoubleClickedNode);\n    //if (DoubleClickedPin)  LOG_TRACE(0, \"DOUBLE CLICK PIN:  %d\", DoubleClickedPin);\n    //if (DoubleClickedLink) LOG_TRACE(0, \"DOUBLE CLICK LINK: %d\", DoubleClickedLink);\n    //if (BackgroundDoubleClicked) LOG_TRACE(0, \"DOUBLE CLICK BACKGROUND\", DoubleClickedLink);\n\n    const bool isSelecting = m_CurrentAction && m_CurrentAction->AsSelect() != nullptr;\n    const bool isDragging  = m_CurrentAction && m_CurrentAction->AsDrag()   != nullptr;\n    //const bool isSizing    = CurrentAction && CurrentAction->AsSize()   != nullptr;\n\n    // Draw nodes\n    for (auto node : m_Nodes)\n        if (node->m_IsLive && node->IsVisible())\n            node->Draw(m_DrawList);\n\n    // Draw links\n    for (auto link : m_Links)\n        if (link->m_IsLive && link->IsVisible())\n            link->Draw(m_DrawList);\n\n    // Highlight selected objects\n    {\n        auto selectedObjects = &m_SelectedObjects;\n        if (auto selectAction = m_CurrentAction ? m_CurrentAction->AsSelect() : nullptr)\n            selectedObjects = &selectAction->m_CandidateObjects;\n\n        for (auto selectedObject : *selectedObjects)\n        {\n            if (selectedObject->IsVisible())\n                selectedObject->Draw(m_DrawList, Object::Selected);\n        }\n\n        // Highlight adjacent links\n        static auto isLinkHighlightedForPin = [](const Pin& pin)\n        {\n            return pin.m_Node->m_HighlightConnectedLinks && pin.m_Node->m_IsSelected;\n        };\n\n        for (auto& link : m_Links)\n        {\n            if (!link->m_IsLive || !link->IsVisible())\n                continue;\n\n            auto isLinkHighlighted = isLinkHighlightedForPin(*link->m_StartPin) || isLinkHighlightedForPin(*link->m_EndPin);\n            if (!isLinkHighlighted)\n                continue;\n\n            link->Draw(m_DrawList, Object::Highlighted);\n        }\n    }\n\n    if (!isSelecting)\n    {\n        auto hoveredObject = control.HotObject;\n        if (auto dragAction = m_CurrentAction ? m_CurrentAction->AsDrag() : nullptr)\n            hoveredObject = dragAction->m_DraggedObject;\n        if (auto sizeAction = m_CurrentAction ? m_CurrentAction->AsSize() : nullptr)\n            hoveredObject = sizeAction->m_SizedNode;\n\n        if (hoveredObject && !IsSelected(hoveredObject) && hoveredObject->IsVisible())\n            hoveredObject->Draw(m_DrawList, Object::Hovered);\n    }\n\n    // Draw animations\n    for (auto controller : m_AnimationControllers)\n        controller->Draw(m_DrawList);\n\n    if (m_CurrentAction && !m_CurrentAction->Process(control))\n        m_CurrentAction = nullptr;\n\n    if (m_NavigateAction.m_IsActive)\n        m_NavigateAction.Process(control);\n    else\n        m_NavigateAction.Accept(control);\n\n    if (nullptr == m_CurrentAction)\n    {\n        EditorAction* possibleAction   = nullptr;\n\n        auto accept = [&possibleAction, &control](EditorAction& action)\n        {\n            auto result = action.Accept(control);\n\n            if (result == EditorAction::True)\n                return true;\n            else if (/*!possibleAction &&*/ result == EditorAction::Possible)\n                possibleAction = &action;\n            else if (result == EditorAction::Possible)\n                action.Reject();\n\n            return false;\n        };\n\n        if (accept(m_ContextMenuAction))\n            m_CurrentAction = &m_ContextMenuAction;\n        else if (accept(m_ShortcutAction))\n            m_CurrentAction = &m_ShortcutAction;\n        else if (accept(m_SizeAction))\n            m_CurrentAction = &m_SizeAction;\n        else if (accept(m_DragAction))\n            m_CurrentAction = &m_DragAction;\n        else if (accept(m_CreateItemAction))\n            m_CurrentAction = &m_CreateItemAction;\n        else if (accept(m_DeleteItemsAction))\n            m_CurrentAction = &m_DeleteItemsAction;\n        else if (accept(m_SelectAction))\n            m_CurrentAction = &m_SelectAction;\n\n        if (possibleAction)\n            ImGui::SetMouseCursor(possibleAction->GetCursor());\n\n        if (m_CurrentAction && possibleAction)\n            possibleAction->Reject();\n    }\n\n    if (m_CurrentAction)\n        ImGui::SetMouseCursor(m_CurrentAction->GetCursor());\n\n    // Draw selection rectangle\n    m_SelectAction.Draw(m_DrawList);\n\n    bool sortGroups = false;\n    if (control.ActiveNode)\n    {\n        if (!IsGroup(control.ActiveNode))\n        {\n            // Bring active node to front\n            auto activeNodeIt = std::find(m_Nodes.begin(), m_Nodes.end(), control.ActiveNode);\n            std::rotate(activeNodeIt, activeNodeIt + 1, m_Nodes.end());\n        }\n        else if (!isDragging && m_CurrentAction && m_CurrentAction->AsDrag())\n        {\n            // Bring content of dragged group to front\n            std::vector<Node*> nodes;\n            control.ActiveNode->GetGroupedNodes(nodes);\n\n            std::stable_partition(m_Nodes.begin(), m_Nodes.end(), [&nodes](Node* node)\n            {\n                return std::find(nodes.begin(), nodes.end(), node) == nodes.end();\n            });\n\n            sortGroups = true;\n        }\n    }\n\n    // Sort nodes if bounds of node changed\n    if (sortGroups || ((m_Settings.m_DirtyReason & (SaveReasonFlags::Position | SaveReasonFlags::Size)) != SaveReasonFlags::None))\n    {\n        // Bring all groups before regular nodes\n        auto groupsItEnd = std::stable_partition(m_Nodes.begin(), m_Nodes.end(), IsGroup);\n\n        // Sort groups by area\n        std::sort(m_Nodes.begin(), groupsItEnd, [this](Node* lhs, Node* rhs)\n        {\n            const auto& lhsSize = lhs == m_SizeAction.m_SizedNode ? m_SizeAction.GetStartGroupBounds().GetSize() : lhs->m_GroupBounds.GetSize();\n            const auto& rhsSize = rhs == m_SizeAction.m_SizedNode ? m_SizeAction.GetStartGroupBounds().GetSize() : rhs->m_GroupBounds.GetSize();\n\n            const auto lhsArea = lhsSize.x * lhsSize.y;\n            const auto rhsArea = rhsSize.x * rhsSize.y;\n\n            return lhsArea > rhsArea;\n        });\n    }\n\n    // Apply Z order\n    std::stable_sort(m_Nodes.begin(), m_Nodes.end(), [](const auto& lhs, const auto& rhs)\n    {\n        return lhs->m_ZPosition < rhs->m_ZPosition;\n    });\n\n# if 1\n    // Every node has few channels assigned. Grow channel list\n    // to hold twice as much of channels and place them in\n    // node drawing order.\n    {\n        // Copy group nodes\n        auto liveNodeCount = static_cast<int>(std::count_if(m_Nodes.begin(), m_Nodes.end(), [](Node* node) { return node->m_IsLive; }));\n\n        // Reserve two additional channels for sorted list of channels\n        auto nodeChannelCount = m_DrawList->_Splitter._Count;\n        ImDrawList_ChannelsGrow(m_DrawList, m_DrawList->_Splitter._Count + c_ChannelsPerNode * liveNodeCount + c_LinkChannelCount);\n\n        int targetChannel = nodeChannelCount;\n\n        auto copyNode = [this, &targetChannel](Node* node)\n        {\n            if (!node->m_IsLive)\n                return;\n\n            for (int i = 0; i < c_ChannelsPerNode; ++i)\n                ImDrawList_SwapChannels(m_DrawList, node->m_Channel + i, targetChannel + i);\n\n            node->m_Channel = targetChannel;\n            targetChannel += c_ChannelsPerNode;\n        };\n\n        auto groupsItEnd = std::find_if(m_Nodes.begin(), m_Nodes.end(), [](Node* node) { return !IsGroup(node); });\n\n        // Copy group nodes\n        std::for_each(m_Nodes.begin(), groupsItEnd, copyNode);\n\n        // Copy links\n        for (int i = 0; i < c_LinkChannelCount; ++i, ++targetChannel)\n            ImDrawList_SwapChannels(m_DrawList, c_LinkStartChannel + i, targetChannel);\n\n        // Copy normal nodes\n        std::for_each(groupsItEnd, m_Nodes.end(), copyNode);\n    }\n# endif\n\n    // ImGui::PopClipRect();\n\n    // Draw grid\n# if 1 // #FIXME\n    {\n        //auto& style = ImGui::GetStyle();\n\n        m_DrawList->ChannelsSetCurrent(c_UserChannel_Grid);\n\n        ImVec2 offset    = m_Canvas.ViewOrigin() * (1.0f / m_Canvas.ViewScale());\n        ImU32 GRID_COLOR = GetColor(StyleColor_Grid, ImClamp(m_Canvas.ViewScale() * m_Canvas.ViewScale(), 0.0f, 1.0f));\n        float GRID_SX    = 32.0f;// * m_Canvas.ViewScale();\n        float GRID_SY    = 32.0f;// * m_Canvas.ViewScale();\n        ImVec2 VIEW_POS  = m_Canvas.ViewRect().Min;\n        ImVec2 VIEW_SIZE = m_Canvas.ViewRect().GetSize();\n\n        m_DrawList->AddRectFilled(VIEW_POS, VIEW_POS + VIEW_SIZE, GetColor(StyleColor_Bg));\n\n        for (float x = fmodf(offset.x, GRID_SX); x < VIEW_SIZE.x; x += GRID_SX)\n            m_DrawList->AddLine(ImVec2(x, 0.0f) + VIEW_POS, ImVec2(x, VIEW_SIZE.y) + VIEW_POS, GRID_COLOR);\n        for (float y = fmodf(offset.y, GRID_SY); y < VIEW_SIZE.y; y += GRID_SY)\n            m_DrawList->AddLine(ImVec2(0.0f, y) + VIEW_POS, ImVec2(VIEW_SIZE.x, y) + VIEW_POS, GRID_COLOR);\n    }\n# endif\n\n# if 0\n    {\n        auto userChannel = drawList->_Splitter._Count;\n        auto channelsToCopy = c_UserLayersCount;\n        ImDrawList_ChannelsGrow(drawList, userChannel + channelsToCopy);\n        for (int i = 0; i < channelsToCopy; ++i)\n            ImDrawList_SwapChannels(drawList, userChannel + i, c_UserLayerChannelStart + i);\n    }\n# endif\n\n# if 0\n    {\n        auto preOffset  = ImVec2(0, 0);\n        auto postOffset = m_OldCanvas.WindowScreenPos + m_OldCanvas.ClientOrigin;\n        auto scale      = m_OldCanvas.Zoom;\n\n        ImDrawList_TransformChannels(drawList,                        0,                            1, preOffset, scale, postOffset);\n        ImDrawList_TransformChannels(drawList, c_BackgroundChannelStart, drawList->_ChannelsCount - 1, preOffset, scale, postOffset);\n\n        auto clipTranslation = m_OldCanvas.WindowScreenPos - m_OldCanvas.FromScreen(m_OldCanvas.WindowScreenPos);\n        ImGui::PushClipRect(m_OldCanvas.WindowScreenPos + ImVec2(1, 1), m_OldCanvas.WindowScreenPos + m_OldCanvas.WindowScreenSize - ImVec2(1, 1), false);\n        ImDrawList_TranslateAndClampClipRects(drawList,                        0,                            1, clipTranslation);\n        ImDrawList_TranslateAndClampClipRects(drawList, c_BackgroundChannelStart, drawList->_ChannelsCount - 1, clipTranslation);\n        ImGui::PopClipRect();\n\n        // #debug: Static grid in local space\n        //for (float x = 0; x < Canvas.WindowScreenSize.x; x += 100)\n        //    drawList->AddLine(ImVec2(x, 0.0f) + Canvas.WindowScreenPos, ImVec2(x, Canvas.WindowScreenSize.y) + Canvas.WindowScreenPos, IM_COL32(255, 0, 0, 128));\n        //for (float y = 0; y < Canvas.WindowScreenSize.y; y += 100)\n        //    drawList->AddLine(ImVec2(0.0f, y) + Canvas.WindowScreenPos, ImVec2(Canvas.WindowScreenSize.x, y) + Canvas.WindowScreenPos, IM_COL32(255, 0, 0, 128));\n    }\n# endif\n\n# if 1\n    // Move user and hint channels to top\n    {\n        // Clip plane is transformed to global space.\n        // These channels already have clip planes in global space, so\n        // we move them to clip plane. Batch transformation in canvas\n        // will bring them back to global space.\n        auto preTransformClipRect = [this](int channelIndex)\n        {\n            ImDrawChannel& channel = m_DrawList->_Splitter._Channels[channelIndex];\n            for (ImDrawCmd& cmd : channel._CmdBuffer)\n            {\n                auto a = ToCanvas(ImVec2(cmd.ClipRect.x, cmd.ClipRect.y));\n                auto b = ToCanvas(ImVec2(cmd.ClipRect.z, cmd.ClipRect.w));\n                cmd.ClipRect = ImVec4(a.x, a.y, b.x, b.y);\n            }\n        };\n\n        m_DrawList->ChannelsSetCurrent(0);\n\n        auto channelCount = m_DrawList->_Splitter._Count;\n        ImDrawList_ChannelsGrow(m_DrawList, channelCount + 3);\n        ImDrawList_SwapChannels(m_DrawList, c_UserChannel_HintsBackground, channelCount + 0);\n        ImDrawList_SwapChannels(m_DrawList, c_UserChannel_Hints,           channelCount + 1);\n        ImDrawList_SwapChannels(m_DrawList, c_UserChannel_Content,         channelCount + 2);\n\n        preTransformClipRect(channelCount + 0);\n        preTransformClipRect(channelCount + 1);\n        preTransformClipRect(channelCount + 2);\n    }\n# endif\n\n    UpdateAnimations();\n\n    m_DrawList->ChannelsMerge();\n\n    // #debug\n    // drawList->AddRectFilled(ImVec2(-10.0f, -10.0f), ImVec2(10.0f, 10.0f), IM_COL32(255, 0, 255, 255));\n\n    // ImGui::EndChild();\n    // ImGui::PopStyleColor();\n    if (m_IsCanvasVisible)\n        m_Canvas.End();\n\n    ImDrawList_SwapSplitter(m_DrawList, m_Splitter);\n\n    // Draw border\n    {\n        auto& style = ImGui::GetStyle();\n        auto borderShadoColor = style.Colors[ImGuiCol_BorderShadow];\n        auto borderColor = style.Colors[ImGuiCol_Border];\n        m_DrawList->AddRect(m_Canvas.Rect().Min + ImVec2(1, 1), m_Canvas.Rect().Max - ImVec2(1, 1), ImColor(borderShadoColor));\n        m_DrawList->AddRect(m_Canvas.Rect().Min, m_Canvas.Rect().Max, ImColor(borderColor));\n    }\n\n    // #metrics\n    // ShowMetrics(control);\n\n    ImGui::PopID();\n\n    if (!m_CurrentAction && m_IsFirstFrame && !m_Settings.m_Selection.empty())\n    {\n        ClearSelection();\n        for (auto id : m_Settings.m_Selection)\n            if (auto object = FindObject(id))\n                SelectObject(object);\n    }\n\n    if (HasSelectionChanged())\n        MakeDirty(SaveReasonFlags::Selection);\n\n    if (m_Settings.m_IsDirty && !m_CurrentAction)\n        SaveSettings();\n\n    m_DrawList = nullptr;\n    m_IsFirstFrame = false;\n}\n\nbool ed::EditorContext::DoLink(LinkId id, PinId startPinId, PinId endPinId, ImU32 color, float thickness)\n{\n    //auto& editorStyle = GetStyle();\n\n    auto startPin = FindPin(startPinId);\n    auto endPin   = FindPin(endPinId);\n\n    if (!startPin || !startPin->m_IsLive || !endPin || !endPin->m_IsLive)\n        return false;\n\n    startPin->m_HasConnection = true;\n      endPin->m_HasConnection = true;\n\n    auto link           = GetLink(id);\n    link->m_StartPin      = startPin;\n    link->m_EndPin        = endPin;\n    link->m_Color         = color;\n    link->m_HighlightColor= GetColor(StyleColor_HighlightLinkBorder);\n    link->m_Thickness     = thickness;\n    link->m_IsLive        = true;\n\n    link->UpdateEndpoints();\n\n    return true;\n}\n\nvoid ed::EditorContext::SetNodePosition(NodeId nodeId, const ImVec2& position)\n{\n    auto node = FindNode(nodeId);\n    if (!node)\n    {\n        node = CreateNode(nodeId);\n        node->m_IsLive = false;\n    }\n\n    if (node->m_Bounds.Min != position)\n    {\n        node->m_Bounds.Translate(position - node->m_Bounds.Min);\n        node->m_Bounds.Floor();\n        MakeDirty(NodeEditor::SaveReasonFlags::Position, node);\n    }\n}\n\nvoid ed::EditorContext::SetGroupSize(NodeId nodeId, const ImVec2& size)\n{\n    auto node = FindNode(nodeId);\n    if (!node)\n    {\n        node = CreateNode(nodeId);\n        node->m_IsLive = false;\n    }\n\n    node->m_Type = NodeType::Group;\n\n    if (node->m_GroupBounds.GetSize() != size)\n    {\n        node->m_GroupBounds.Min = node->m_Bounds.Min;\n        node->m_GroupBounds.Max = node->m_Bounds.Min + size;\n        node->m_GroupBounds.Floor();\n        MakeDirty(NodeEditor::SaveReasonFlags::Size, node);\n    }\n}\n\nImVec2 ed::EditorContext::GetNodePosition(NodeId nodeId)\n{\n    auto node = FindNode(nodeId);\n    if (!node)\n        return ImVec2(FLT_MAX, FLT_MAX);\n\n    return node->m_Bounds.Min;\n}\n\nImVec2 ed::EditorContext::GetNodeSize(NodeId nodeId)\n{\n    auto node = FindNode(nodeId);\n    if (!node)\n        return ImVec2(0, 0);\n\n    return node->m_Bounds.GetSize();\n}\n\nvoid ed::EditorContext::SetNodeZPosition(NodeId nodeId, float z)\n{\n    auto node = FindNode(nodeId);\n    if (!node)\n    {\n        node = CreateNode(nodeId);\n        node->m_IsLive = false;\n    }\n\n    node->m_ZPosition = z;\n}\n\nfloat ed::EditorContext::GetNodeZPosition(NodeId nodeId)\n{\n    auto node = FindNode(nodeId);\n    if (!node)\n        return 0.0f;\n\n    return node->m_ZPosition;\n}\n\nvoid ed::EditorContext::MarkNodeToRestoreState(Node* node)\n{\n    node->m_RestoreState = true;\n}\n\nvoid ed::EditorContext::UpdateNodeState(Node* node)\n{\n    bool tryLoadState = node->m_RestoreState;\n\n    node->m_RestoreState = false;\n\n    auto settings = m_Settings.FindNode(node->m_ID);\n    if (!settings)\n        return;\n\n    if (!tryLoadState && settings->m_WasUsed)\n        return;\n\n    if (!settings->m_WasUsed)\n    {\n        MakeDirty(SaveReasonFlags::AddNode, node);\n        settings->m_WasUsed = true;\n    }\n\n    // Load state from config (if possible)\n    if (tryLoadState)\n    {\n        NodeSettings newSettings = *settings;\n        if (NodeSettings::Parse(m_Config.LoadNode(node->m_ID), newSettings))\n            *settings = newSettings;\n    }\n\n    node->m_Bounds.Min      = settings->m_Location;\n    node->m_Bounds.Max      = node->m_Bounds.Min + settings->m_Size;\n    node->m_Bounds.Floor();\n    node->m_GroupBounds.Min = settings->m_Location;\n    node->m_GroupBounds.Max = node->m_GroupBounds.Min + settings->m_GroupSize;\n    node->m_GroupBounds.Floor();\n}\n\nvoid ed::EditorContext::RemoveSettings(Object* object)\n{\n    if (auto node = object->AsNode())\n    {\n        m_Settings.RemoveNode(node->m_ID);\n        MakeDirty(SaveReasonFlags::RemoveNode, node);\n    }\n}\n\nvoid ed::EditorContext::ClearSelection()\n{\n    for (auto& object : m_SelectedObjects)\n        object->m_IsSelected = false;\n\n    m_SelectedObjects.clear();\n}\n\nvoid ed::EditorContext::SelectObject(Object* object)\n{\n    m_SelectedObjects.push_back(object);\n    object->m_IsSelected = true;\n}\n\nvoid ed::EditorContext::DeselectObject(Object* object)\n{\n    auto objectIt = std::find(m_SelectedObjects.begin(), m_SelectedObjects.end(), object);\n    if (objectIt == m_SelectedObjects.end())\n        return;\n\n    object->m_IsSelected = false;\n    m_SelectedObjects.erase(objectIt);\n}\n\nvoid ed::EditorContext::SetSelectedObject(Object* object)\n{\n    ClearSelection();\n    SelectObject(object);\n}\n\nvoid ed::EditorContext::ToggleObjectSelection(Object* object)\n{\n    if (IsSelected(object))\n        DeselectObject(object);\n    else\n        SelectObject(object);\n}\n\nbool ed::EditorContext::IsSelected(Object* object)\n{\n    return object && object->m_IsSelected;\n    // return std::find(m_SelectedObjects.begin(), m_SelectedObjects.end(), object) != m_SelectedObjects.end();\n}\n\nconst ed::vector<ed::Object*>& ed::EditorContext::GetSelectedObjects()\n{\n    return m_SelectedObjects;\n}\n\nbool ed::EditorContext::IsAnyNodeSelected()\n{\n    for (auto object : m_SelectedObjects)\n        if (object->AsNode())\n            return true;\n\n    return false;\n}\n\nbool ed::EditorContext::IsAnyLinkSelected()\n{\n    for (auto object : m_SelectedObjects)\n        if (object->AsLink())\n            return true;\n\n    return false;\n}\n\nbool ed::EditorContext::HasSelectionChanged()\n{\n    return m_LastSelectedObjects != m_SelectedObjects;\n}\n\ned::Node* ed::EditorContext::FindNodeAt(const ImVec2& p)\n{\n    for (auto node : m_Nodes)\n        if (node->TestHit(p))\n            return node;\n\n    return nullptr;\n}\n\nvoid ed::EditorContext::FindNodesInRect(const ImRect& r, vector<Node*>& result, bool append, bool includeIntersecting)\n{\n    if (!append)\n        result.resize(0);\n\n    if (ImRect_IsEmpty(r))\n        return;\n\n    for (auto node : m_Nodes)\n        if (node->TestHit(r, includeIntersecting))\n            result.push_back(node);\n}\n\nvoid ed::EditorContext::FindLinksInRect(const ImRect& r, vector<Link*>& result, bool append)\n{\n    if (!append)\n        result.resize(0);\n\n    if (ImRect_IsEmpty(r))\n        return;\n\n    for (auto link : m_Links)\n        if (link->TestHit(r))\n            result.push_back(link);\n}\n\nbool ed::EditorContext::HasAnyLinks(NodeId nodeId) const\n{\n    for (auto link : m_Links)\n    {\n        if (!link->m_IsLive)\n            continue;\n\n        if (link->m_StartPin->m_Node->m_ID == nodeId || link->m_EndPin->m_Node->m_ID == nodeId)\n            return true;\n    }\n\n    return false;\n}\n\nbool ed::EditorContext::HasAnyLinks(PinId pinId) const\n{\n    for (auto link : m_Links)\n    {\n        if (!link->m_IsLive)\n            continue;\n\n        if (link->m_StartPin->m_ID == pinId || link->m_EndPin->m_ID == pinId)\n            return true;\n    }\n\n    return false;\n}\n\nint ed::EditorContext::BreakLinks(NodeId nodeId)\n{\n    int result = 0;\n    for (auto link : m_Links)\n    {\n        if (!link->m_IsLive)\n            continue;\n\n        if (link->m_StartPin->m_Node->m_ID == nodeId || link->m_EndPin->m_Node->m_ID == nodeId)\n        {\n            if (GetItemDeleter().Add(link))\n                ++result;\n        }\n    }\n    return result;\n}\n\nint ed::EditorContext::BreakLinks(PinId pinId)\n{\n    int result = 0;\n    for (auto link : m_Links)\n    {\n        if (!link->m_IsLive)\n            continue;\n\n        if (link->m_StartPin->m_ID == pinId || link->m_EndPin->m_ID == pinId)\n        {\n            if (GetItemDeleter().Add(link))\n                ++result;\n        }\n    }\n    return result;\n}\n\nvoid ed::EditorContext::FindLinksForNode(NodeId nodeId, vector<Link*>& result, bool add)\n{\n    if (!add)\n        result.clear();\n\n    for (auto link : m_Links)\n    {\n        if (!link->m_IsLive)\n            continue;\n\n        if (link->m_StartPin->m_Node->m_ID == nodeId || link->m_EndPin->m_Node->m_ID == nodeId)\n            result.push_back(link);\n    }\n}\n\nbool ed::EditorContext::PinHadAnyLinks(PinId pinId)\n{\n    auto pin = FindPin(pinId);\n    if (!pin || !pin->m_IsLive)\n        return false;\n\n    return pin->m_HasConnection || pin->m_HadConnection;\n}\n\nvoid ed::EditorContext::NotifyLinkDeleted(Link* link)\n{\n    if (m_LastActiveLink == link)\n        m_LastActiveLink = nullptr;\n}\n\nvoid ed::EditorContext::Suspend(SuspendFlags flags)\n{\n    IM_ASSERT(m_DrawList != nullptr && \"Suspend was called outiside of Begin/End.\");\n    auto lastChannel = m_DrawList->_Splitter._Current;\n    m_DrawList->ChannelsSetCurrent(m_ExternalChannel);\n    if (m_IsCanvasVisible)\n        m_Canvas.Suspend();\n    m_DrawList->ChannelsSetCurrent(lastChannel);\n    if ((flags & SuspendFlags::KeepSplitter) != SuspendFlags::KeepSplitter)\n        ImDrawList_SwapSplitter(m_DrawList, m_Splitter);\n}\n\nvoid ed::EditorContext::Resume(SuspendFlags flags)\n{\n    IM_ASSERT(m_DrawList != nullptr && \"Reasume was called outiside of Begin/End.\");\n    if ((flags & SuspendFlags::KeepSplitter) != SuspendFlags::KeepSplitter)\n        ImDrawList_SwapSplitter(m_DrawList, m_Splitter);\n    auto lastChannel = m_DrawList->_Splitter._Current;\n    m_DrawList->ChannelsSetCurrent(m_ExternalChannel);\n    if (m_IsCanvasVisible)\n        m_Canvas.Resume();\n    m_DrawList->ChannelsSetCurrent(lastChannel);\n}\n\nbool ed::EditorContext::IsSuspended()\n{\n    return m_Canvas.IsSuspended();\n}\n\nbool ed::EditorContext::IsFocused()\n{\n    return m_IsFocused;\n}\n\nbool ed::EditorContext::IsHovered() const\n{\n    return m_IsHovered;\n}\n\nbool ed::EditorContext::IsHoveredWithoutOverlapp() const\n{\n    return m_IsHoveredWithoutOverlapp;\n}\n\nbool ed::EditorContext::CanAcceptUserInput() const\n{\n    return m_IsFocused && m_IsHovered;\n}\n\nint ed::EditorContext::CountLiveNodes() const\n{\n    return (int)std::count_if(m_Nodes.begin(),  m_Nodes.end(),  [](const Node* node)  { return node->m_IsLive; });\n}\n\nint ed::EditorContext::CountLivePins() const\n{\n    return (int)std::count_if(m_Pins.begin(),   m_Pins.end(),   [](const Pin*  pin)   { return pin->m_IsLive; });\n}\n\nint ed::EditorContext::CountLiveLinks() const\n{\n    return (int)std::count_if(m_Links.begin(),  m_Links.end(),  [](const Link* link)  { return link->m_IsLive; });\n}\n\ned::Pin* ed::EditorContext::CreatePin(PinId id, PinKind kind)\n{\n    IM_ASSERT(nullptr == FindObject(id));\n    auto pin = new Pin(this, id, kind);\n    m_Pins.push_back({id, pin});\n    std::sort(m_Pins.begin(), m_Pins.end());\n    return pin;\n}\n\ned::Node* ed::EditorContext::CreateNode(NodeId id)\n{\n    IM_ASSERT(nullptr == FindObject(id));\n    auto node = new Node(this, id);\n    m_Nodes.push_back({id, node});\n    //std::sort(Nodes.begin(), Nodes.end());\n\n    auto settings = m_Settings.FindNode(id);\n    if (!settings)\n        settings = m_Settings.AddNode(id);\n\n    UpdateNodeState(node);\n\n    if (settings->m_GroupSize.x > 0 || settings->m_GroupSize.y > 0)\n        node->m_Type = NodeType::Group;\n\n    node->m_IsLive = false;\n\n    return node;\n}\n\ned::Link* ed::EditorContext::CreateLink(LinkId id)\n{\n    IM_ASSERT(nullptr == FindObject(id));\n    auto link = new Link(this, id);\n    m_Links.push_back({id, link});\n    std::sort(m_Links.begin(), m_Links.end());\n\n    return link;\n}\n\ntemplate <typename C, typename Id>\nstatic inline auto FindItemInLinear(C& container, Id id)\n{\n# if defined(_DEBUG)\n    auto start = container.data();\n    auto end   = container.data() + container.size();\n    for (auto it = start; it < end; ++it)\n        if ((*it).m_ID == id)\n            return it->m_Object;\n# else\n    for (auto item : container)\n        if (item.m_ID == id)\n            return item.m_Object;\n# endif\n\n   return static_cast<decltype(container[0].m_Object)>(nullptr);\n}\n\ntemplate <typename C, typename Id>\nstatic inline auto FindItemIn(C& container, Id id)\n{\n//# if defined(_DEBUG)\n//    auto start = container.data();\n//    auto end   = container.data() + container.size();\n//    for (auto it = start; it < end; ++it)\n//        if ((*it)->ID == id)\n//            return *it;\n//# else\n//    for (auto item : container)\n//        if (item->ID == id)\n//            return item;\n//# endif\n    auto key = typename C::value_type{ id, nullptr };\n    auto first = container.cbegin();\n    auto last  = container.cend();\n    auto it    = std::lower_bound(first, last, key);\n    if (it != last && (key.m_ID == it->m_ID))\n        return it->m_Object;\n    else\n        return static_cast<decltype(it->m_Object)>(nullptr);\n}\n\ned::Node* ed::EditorContext::FindNode(NodeId id)\n{\n    return FindItemInLinear(m_Nodes, id);\n}\n\ned::Pin* ed::EditorContext::FindPin(PinId id)\n{\n    return FindItemIn(m_Pins, id);\n}\n\ned::Link* ed::EditorContext::FindLink(LinkId id)\n{\n    return FindItemIn(m_Links, id);\n}\n\ned::Object* ed::EditorContext::FindObject(ObjectId id)\n{\n    if (id.IsNodeId())\n        return FindNode(id.AsNodeId());\n    else if (id.IsLinkId())\n        return FindLink(id.AsLinkId());\n    else if (id.IsPinId())\n        return FindPin(id.AsPinId());\n    else\n        return nullptr;\n}\n\ned::Node* ed::EditorContext::GetNode(NodeId id)\n{\n    auto node = FindNode(id);\n    if (!node)\n        node = CreateNode(id);\n    return node;\n}\n\ned::Pin* ed::EditorContext::GetPin(PinId id, PinKind kind)\n{\n    if (auto pin = FindPin(id))\n    {\n        pin->m_Kind = kind;\n        return pin;\n    }\n    else\n        return CreatePin(id, kind);\n}\n\ned::Link* ed::EditorContext::GetLink(LinkId id)\n{\n    if (auto link = FindLink(id))\n        return link;\n    else\n        return CreateLink(id);\n}\n\nvoid ed::EditorContext::LoadSettings()\n{\n    ed::Settings::Parse(m_Config.Load(), m_Settings);\n\n    if (ImRect_IsEmpty(m_Settings.m_VisibleRect))\n    {\n        m_NavigateAction.m_Scroll = m_Settings.m_ViewScroll;\n        m_NavigateAction.m_Zoom   = m_Settings.m_ViewZoom;\n    }\n    else\n    {\n        m_NavigateAction.NavigateTo(m_Settings.m_VisibleRect, NavigateAction::ZoomMode::Exact, 0.0f);\n    }\n}\n\nvoid ed::EditorContext::SaveSettings()\n{\n    m_Config.BeginSave();\n\n    for (auto& node : m_Nodes)\n    {\n        auto settings = m_Settings.FindNode(node->m_ID);\n        settings->m_Location = node->m_Bounds.Min;\n        settings->m_Size     = node->m_Bounds.GetSize();\n        if (IsGroup(node))\n            settings->m_GroupSize = node->m_GroupBounds.GetSize();\n\n        if (!node->m_RestoreState && settings->m_IsDirty && m_Config.SaveNodeSettings)\n        {\n            if (m_Config.SaveNode(node->m_ID, settings->Serialize().dump(), settings->m_DirtyReason))\n                settings->ClearDirty();\n        }\n    }\n\n    m_Settings.m_Selection.resize(0);\n    for (auto& object : m_SelectedObjects)\n        m_Settings.m_Selection.push_back(object->ID());\n\n    m_Settings.m_ViewScroll  = m_NavigateAction.m_Scroll;\n    m_Settings.m_ViewZoom    = m_NavigateAction.m_Zoom;\n    m_Settings.m_VisibleRect = m_NavigateAction.m_VisibleRect;\n\n    if (m_Config.Save(m_Settings.Serialize(), m_Settings.m_DirtyReason))\n        m_Settings.ClearDirty();\n\n    m_Config.EndSave();\n}\n\nvoid ed::EditorContext::MakeDirty(SaveReasonFlags reason)\n{\n    m_Settings.MakeDirty(reason);\n}\n\nvoid ed::EditorContext::MakeDirty(SaveReasonFlags reason, Node* node)\n{\n    m_Settings.MakeDirty(reason, node);\n}\n\ned::Link* ed::EditorContext::FindLinkAt(const ImVec2& p)\n{\n    for (auto& link : m_Links)\n        if (link->TestHit(p, c_LinkSelectThickness))\n            return link;\n\n    return nullptr;\n}\n\nImU32 ed::EditorContext::GetColor(StyleColor colorIndex) const\n{\n    return ImColor(m_Style.Colors[colorIndex]);\n}\n\nImU32 ed::EditorContext::GetColor(StyleColor colorIndex, float alpha) const\n{\n    auto color = m_Style.Colors[colorIndex];\n    return ImColor(color.x, color.y, color.z, color.w * alpha);\n}\n\nint ed::EditorContext::GetNodeIds(NodeId* nodes, int size) const\n{\n    if (size <= 0)\n        return 0;\n\n    int result = 0;\n    for (auto node : m_Nodes)\n    {\n        if (!node->m_IsLive)\n            continue;\n\n        *nodes++ = node->m_ID;\n        ++result;\n        if (--size == 0)\n            break;\n    }\n\n    return result;\n}\n\nvoid ed::EditorContext::RegisterAnimation(Animation* animation)\n{\n    m_LiveAnimations.push_back(animation);\n}\n\nvoid ed::EditorContext::UnregisterAnimation(Animation* animation)\n{\n    auto it = std::find(m_LiveAnimations.begin(), m_LiveAnimations.end(), animation);\n    if (it != m_LiveAnimations.end())\n        m_LiveAnimations.erase(it);\n}\n\nvoid ed::EditorContext::UpdateAnimations()\n{\n    m_LastLiveAnimations = m_LiveAnimations;\n\n    for (auto animation : m_LastLiveAnimations)\n    {\n        const bool isLive = (std::find(m_LiveAnimations.begin(), m_LiveAnimations.end(), animation) != m_LiveAnimations.end());\n\n        if (isLive)\n            animation->Update();\n    }\n}\n\nvoid ed::EditorContext::Flow(Link* link, FlowDirection direction)\n{\n    m_FlowAnimationController.Flow(link, direction);\n}\n\nvoid ed::EditorContext::SetUserContext(bool globalSpace)\n{\n    const auto mousePos = ImGui::GetMousePos();\n\n    // Move drawing cursor to mouse location and prepare layer for\n    // content added by user.\n    if (globalSpace)\n        ImGui::SetCursorScreenPos(m_Canvas.FromLocal(mousePos));\n    else\n        ImGui::SetCursorScreenPos(m_Canvas.FromLocal(mousePos));\n        //ImGui::SetCursorScreenPos(ImFloor(mousePos));\n        //ImGui::SetCursorScreenPos(ImVec2(floorf(mousePos.x), floorf(mousePos.y)));\n\n    if (!IsSuspended())\n    {\n        m_DrawList->ChannelsSetCurrent(c_UserChannel_Content);\n    }\n\n    // #debug\n    // drawList->AddCircleFilled(ImGui::GetMousePos(), 4, IM_COL32(0, 255, 0, 255));\n}\n\nvoid ed::EditorContext::EnableShortcuts(bool enable)\n{\n    m_ShortcutsEnabled = enable;\n}\n\nbool ed::EditorContext::AreShortcutsEnabled()\n{\n    return m_ShortcutsEnabled;\n}\n\ned::Control ed::EditorContext::BuildControl(bool allowOffscreen)\n{\n    m_IsHovered = false;\n    m_IsHoveredWithoutOverlapp = false;\n\n    const auto windowHovered = ImGui::IsWindowHovered();\n    const auto widgetHovered = ImGui::IsMouseHoveringRect(m_Canvas.ViewRect().Min, m_Canvas.ViewRect().Max, true);\n\n    if (!allowOffscreen && !windowHovered && !widgetHovered)\n        return Control();\n\n    const auto mousePos = ImGui::GetMousePos();\n\n    // Expand clip rectangle to always contain cursor\n    auto editorRect = m_Canvas.ViewRect();\n    auto isMouseOffscreen = allowOffscreen && !editorRect.Contains(mousePos);\n    if (isMouseOffscreen)\n    {\n        // Extend clip rect to capture off-screen mouse cursor\n        editorRect.Add(ImFloor(mousePos));\n        editorRect.Add(ImVec2(ImCeil(mousePos.x), ImCeil(mousePos.y)));\n\n        ImGui::PushClipRect(editorRect.Min, editorRect.Max, false);\n    }\n\n    ImGuiID activeId            = 0;\n    Object* hotObject           = nullptr;\n    Object* activeObject        = nullptr;\n    Object* clickedObject       = nullptr;\n    Object* doubleClickedObject = nullptr;\n\n    ImGuiButtonFlags extraFlags = ImGuiButtonFlags_None;\n    extraFlags |= ImGuiButtonFlags_MouseButtonLeft;\n    extraFlags |= ImGuiButtonFlags_MouseButtonRight;\n    extraFlags |= ImGuiButtonFlags_MouseButtonMiddle;\n\n    static auto invisibleButtonEx = [](const char* str_id, const ImVec2& size_arg, ImGuiButtonFlags extraFlags) -> int\n    {\n        using namespace ImGui;\n\n        ImGuiWindow* window = GetCurrentWindow();\n        if (window->SkipItems)\n            return -1;\n\n        if (size_arg.x == 0.0f || size_arg.y == 0.0f)\n            return false;\n\n        const ImGuiID id = window->GetID(str_id);\n        ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);\n        const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);\n        ItemSize(size);\n        if (!ItemAdd(bb, id))\n            return -1;\n\n        auto buttonIndex = ImGui::GetCurrentContext()->ActiveIdMouseButton;\n\n        bool hovered, held;\n        bool pressed = ButtonBehavior(bb, id, &hovered, &held, extraFlags);\n\n        return pressed ? buttonIndex : -1;\n    };\n\n    // Emits invisible button and returns true if it is clicked.\n    auto emitInteractiveAreaEx = [&activeId](ObjectId id, const ImRect& rect, ImGuiButtonFlags extraFlags) -> int\n    {\n        char idString[33] = { 0 }; // itoa can output 33 bytes maximum\n        snprintf(idString, 32, \"%p\", id.AsPointer());\n        ImGui::SetCursorScreenPos(rect.Min);\n\n        // debug\n        //if (id < 0) return ImGui::Button(idString, to_imvec(rect.size));\n\n        auto buttonIndex = invisibleButtonEx(idString, rect.GetSize(), extraFlags);\n\n        // #debug\n        //ImGui::GetWindowDrawList()->AddRectFilled(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(0, 255, 0, 64));\n\n        if (ImGui::IsItemActive())\n            activeId = ImGui::GetActiveID();\n\n        return buttonIndex;\n    };\n\n    auto emitInteractiveArea = [&emitInteractiveAreaEx, extraFlags](ObjectId id, const ImRect& rect)\n    {\n        return emitInteractiveAreaEx(id, rect, extraFlags);\n    };\n\n    // Check input interactions over area.\n    auto checkInteractionsInArea = [this, &emitInteractiveArea, &hotObject, &activeObject, &clickedObject, &doubleClickedObject](ObjectId id, const ImRect& rect, Object* object)\n    {\n        if (emitInteractiveArea(id, rect) >= 0)\n            clickedObject = object;\n        if (!doubleClickedObject && ImGui::IsMouseDoubleClicked(m_Config.DragButtonIndex) && ImGui::IsItemHovered())\n            doubleClickedObject = object;\n\n        if (!hotObject && ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))\n            hotObject = object;\n\n        if (ImGui::IsItemActive())\n            activeObject = object;\n    };\n\n    // Process live nodes and pins.\n    for (auto nodeIt = m_Nodes.rbegin(), nodeItEnd = m_Nodes.rend(); nodeIt != nodeItEnd; ++nodeIt)\n    {\n        auto node = *nodeIt;\n\n        if (!node->m_IsLive) continue;\n\n        // Check for interactions with live pins in node before\n        // processing node itself. Pins does not overlap each other\n        // and all are within node bounds.\n        for (auto pin = node->m_LastPin; pin; pin = pin->m_PreviousPin)\n        {\n            if (!pin->m_IsLive) continue;\n\n            checkInteractionsInArea(pin->m_ID, pin->m_Bounds, pin);\n        }\n\n        // Check for interactions with node.\n        if (node->m_Type == NodeType::Group)\n        {\n            // Node with a hole\n            ImGui::PushID(node->m_ID.AsPointer());\n\n            static const NodeRegion c_Regions[] =\n            {\n                NodeRegion::TopLeft,\n                NodeRegion::TopRight,\n                NodeRegion::BottomLeft,\n                NodeRegion::BottomRight,\n                NodeRegion::Top,\n                NodeRegion::Bottom,\n                NodeRegion::Left,\n                NodeRegion::Right,\n                NodeRegion::Header,\n            };\n\n            for (auto region : c_Regions)\n            {\n                auto bounds = node->GetRegionBounds(region);\n                if (ImRect_IsEmpty(bounds))\n                    continue;\n                checkInteractionsInArea(NodeId(static_cast<int>(region)), bounds, node);\n            }\n\n            ImGui::PopID();\n        }\n        else\n            checkInteractionsInArea(node->m_ID, node->m_Bounds, node);\n    }\n\n    // Links are not regular widgets and must be done manually since\n    // ImGui does not support interactive elements with custom hit maps.\n    //\n    // Links can steal input from background.\n\n    // Links are just over background. So if anything else\n    // is hovered we can skip them.\n    if (nullptr == hotObject)\n        hotObject = FindLinkAt(mousePos);\n\n    ImGuiButtonFlags backgroundExtraFlags = ImGuiButtonFlags_None;\n    if (m_Config.DragButtonIndex == 0 || m_Config.SelectButtonIndex == 0 || m_Config.NavigateButtonIndex == 0)\n        backgroundExtraFlags |= ImGuiButtonFlags_MouseButtonLeft;\n    if (m_Config.DragButtonIndex == 1 || m_Config.SelectButtonIndex == 1 || m_Config.NavigateButtonIndex == 1)\n        backgroundExtraFlags |= ImGuiButtonFlags_MouseButtonRight;\n    if (m_Config.DragButtonIndex == 2 || m_Config.SelectButtonIndex == 2 || m_Config.NavigateButtonIndex == 2)\n        backgroundExtraFlags |= ImGuiButtonFlags_MouseButtonMiddle;\n\n    auto isMouseDoubleClickOverBackground = [doubleClickedObject, backgroundExtraFlags]() -> int\n    {\n        if (doubleClickedObject)\n            return -1;\n\n        if (!ImGui::IsItemHovered())\n            return -1;\n\n        if ((backgroundExtraFlags & ImGuiButtonFlags_MouseButtonLeft) && ImGui::IsMouseDoubleClicked(ImGuiMouseButton_Left))\n            return ImGuiButtonFlags_MouseButtonLeft;\n        if ((backgroundExtraFlags & ImGuiButtonFlags_MouseButtonRight) && ImGui::IsMouseDoubleClicked(ImGuiButtonFlags_MouseButtonRight))\n            return ImGuiButtonFlags_MouseButtonRight;\n        if ((backgroundExtraFlags & ImGuiButtonFlags_MouseButtonMiddle) && ImGui::IsMouseDoubleClicked(ImGuiButtonFlags_MouseButtonMiddle))\n            return ImGuiButtonFlags_MouseButtonMiddle;\n\n        return -1;\n    };\n\n    // Check for interaction with background.\n    auto backgroundClickButonIndex        = emitInteractiveAreaEx(NodeId(0), editorRect, backgroundExtraFlags);\n    auto backgroundDoubleClickButtonIndex = isMouseDoubleClickOverBackground();\n    auto isBackgroundActive               = ImGui::IsItemActive();\n    auto isBackgroundHot                  = !hotObject;\n    auto isDragging                       = ImGui::IsMouseDragging(0, 1) || ImGui::IsMouseDragging(1, 1) || ImGui::IsMouseDragging(2, 1);\n\n    if (backgroundDoubleClickButtonIndex >= 0)\n        backgroundClickButonIndex = -1;\n\n    if (isMouseOffscreen)\n        ImGui::PopClipRect();\n\n    // Process link input using background interactions.\n    auto hotLink = hotObject ? hotObject->AsLink() : nullptr;\n\n    // ImGui take care of tracking active items. With link\n    // we must do this ourself.\n    if (!isDragging && isBackgroundActive && hotLink && !m_LastActiveLink)\n        m_LastActiveLink = hotLink;\n    if (isBackgroundActive && m_LastActiveLink)\n    {\n        activeObject       = m_LastActiveLink;\n        isBackgroundActive = false;\n    }\n    else if (!isBackgroundActive && m_LastActiveLink)\n        m_LastActiveLink = nullptr;\n\n    // Steal click from backgrounds if link is hovered.\n    if (!isDragging && backgroundClickButonIndex >= 0 && hotLink)\n    {\n        clickedObject             = hotLink;\n        backgroundClickButonIndex = -1;\n    }\n\n    // Steal double-click from backgrounds if link is hovered.\n    if (!isDragging && backgroundDoubleClickButtonIndex >= 0 && hotLink)\n    {\n        doubleClickedObject              = hotLink;\n        backgroundDoubleClickButtonIndex = -1;\n    }\n\n    if (activeId)\n        m_EditorActiveId = activeId;\n\n    if (ImGui::IsAnyItemActive() && ImGui::GetActiveID() != m_EditorActiveId)\n        return Control();\n\n    m_IsHovered = ImGui::IsItemHovered(ImGuiHoveredFlags_RectOnly);\n    m_IsHoveredWithoutOverlapp = ImGui::IsItemHovered();\n    if (!allowOffscreen && !m_IsHovered)\n        return Control();\n\n# if IMGUI_VERSION_NUM >= 18836\n    if (m_IsHoveredWithoutOverlapp)\n        ImGui::SetItemKeyOwner(ImGuiKey_MouseWheelY);\n# elif IMGUI_VERSION_NUM >= 17909\n    if (m_IsHoveredWithoutOverlapp)\n        ImGui::SetItemUsingMouseWheel();\n# endif\n\n    return Control(hotObject, activeObject, clickedObject, doubleClickedObject,\n        isBackgroundHot, isBackgroundActive, backgroundClickButonIndex, backgroundDoubleClickButtonIndex);\n}\n\nvoid ed::EditorContext::ShowMetrics(const Control& control)\n{\n    auto& io = ImGui::GetIO();\n\n    auto getObjectName = [](Object* object)\n    {\n        if (!object) return \"\";\n        else if (object->AsNode())  return \"Node\";\n        else if (object->AsPin())   return \"Pin\";\n        else if (object->AsLink())  return \"Link\";\n        else return \"\";\n    };\n\n    auto getHotObjectName = [&control, &getObjectName]()\n    {\n        if (control.HotObject)\n            return getObjectName(control.HotObject);\n        else if (control.BackgroundHot)\n            return \"Background\";\n        else\n            return \"<unknown>\";\n    };\n\n    auto getActiveObjectName = [&control, &getObjectName]()\n    {\n        if (control.ActiveObject)\n            return getObjectName(control.ActiveObject);\n        else if (control.BackgroundActive)\n            return \"Background\";\n        else\n            return \"<unknown>\";\n    };\n\n    auto liveNodeCount  = CountLiveNodes();\n    auto livePinCount   = CountLivePins();\n    auto liveLinkCount  = CountLiveLinks();\n\n    auto canvasRect     = m_Canvas.Rect();\n    auto viewRect       = m_Canvas.ViewRect();\n    auto localMousePos  = m_Canvas.ToLocal(io.MousePos);\n    auto globalMousePos = io.MousePos;\n\n    ImGui::SetCursorScreenPos(canvasRect.Min + ImVec2(5, 5));\n    ImGui::BeginGroup();\n    ImGui::Text(\"Is Focused: %s\", m_IsFocused ? \"true\" : \"false\");\n    ImGui::Text(\"Is Hovered: %s\", m_IsHovered ? \"true\" : \"false\");\n    ImGui::Text(\"Is Hovered (without overlapp): %s\", m_IsHoveredWithoutOverlapp ? \"true\" : \"false\");\n    ImGui::Text(\"Accept Input: %s\", CanAcceptUserInput() ? \"true\" : \"false\");\n    ImGui::Text(\"View Position: { x=%g y=%g }\", viewRect.Min.x, viewRect.Min.y);\n    ImGui::Text(\"View Size: { w=%g h=%g }\", viewRect.GetWidth(), viewRect.GetHeight());\n    ImGui::Text(\"Canvas Size: { w=%g h=%g }\", canvasRect.GetWidth(), canvasRect.GetHeight());\n    ImGui::Text(\"Mouse: { x=%.0f y=%.0f } global: { x=%g y=%g }\", localMousePos.x, localMousePos.y, globalMousePos.x, globalMousePos.y);\n    ImGui::Text(\"Live Nodes: %d\", liveNodeCount);\n    ImGui::Text(\"Live Pins: %d\", livePinCount);\n    ImGui::Text(\"Live Links: %d\", liveLinkCount);\n    ImGui::Text(\"Hot Object: %s (%p)\", getHotObjectName(), control.HotObject ? control.HotObject->ID().AsPointer() : nullptr);\n    if (auto node = control.HotObject ? control.HotObject->AsNode() : nullptr)\n    {\n        ImGui::SameLine();\n        ImGui::Text(\"{ x=%g y=%g w=%g h=%g }\", node->m_Bounds.Min.x, node->m_Bounds.Min.y, node->m_Bounds.GetWidth(), node->m_Bounds.GetHeight());\n    }\n    ImGui::Text(\"Active Object: %s (%p)\", getActiveObjectName(), control.ActiveObject ? control.ActiveObject->ID().AsPointer() : nullptr);\n    if (auto node = control.ActiveObject ? control.ActiveObject->AsNode() : nullptr)\n    {\n        ImGui::SameLine();\n        ImGui::Text(\"{ x=%g y=%g w=%g h=%g }\", node->m_Bounds.Min.x, node->m_Bounds.Min.y, node->m_Bounds.GetWidth(), node->m_Bounds.GetHeight());\n    }\n    ImGui::Text(\"Action: %s\", m_CurrentAction ? m_CurrentAction->GetName() : \"<none>\");\n    ImGui::Text(\"Action Is Dragging: %s\", m_CurrentAction && m_CurrentAction->IsDragging() ? \"Yes\" : \"No\");\n    m_NavigateAction.ShowMetrics();\n    m_SizeAction.ShowMetrics();\n    m_DragAction.ShowMetrics();\n    m_SelectAction.ShowMetrics();\n    m_ContextMenuAction.ShowMetrics();\n    m_CreateItemAction.ShowMetrics();\n    m_DeleteItemsAction.ShowMetrics();\n    ImGui::EndGroup();\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Node Settings\n//\n//------------------------------------------------------------------------------\nvoid ed::NodeSettings::ClearDirty()\n{\n    m_IsDirty     = false;\n    m_DirtyReason = SaveReasonFlags::None;\n}\n\nvoid ed::NodeSettings::MakeDirty(SaveReasonFlags reason)\n{\n    m_IsDirty     = true;\n    m_DirtyReason = m_DirtyReason | reason;\n}\n\ned::json::value ed::NodeSettings::Serialize()\n{\n    json::value result;\n    result[\"location\"][\"x\"] = m_Location.x;\n    result[\"location\"][\"y\"] = m_Location.y;\n\n    if (m_GroupSize.x > 0 || m_GroupSize.y > 0)\n    {\n        result[\"group_size\"][\"x\"] = m_GroupSize.x;\n        result[\"group_size\"][\"y\"] = m_GroupSize.y;\n    }\n\n    return result;\n}\n\nbool ed::NodeSettings::Parse(const std::string& string, NodeSettings& settings)\n{\n    auto settingsValue = json::value::parse(string);\n    if (settingsValue.is_discarded())\n        return false;\n\n    return Parse(settingsValue, settings);\n}\n\nbool ed::NodeSettings::Parse(const json::value& data, NodeSettings& result)\n{\n    if (!data.is_object())\n        return false;\n\n    auto tryParseVector = [](const json::value& v, ImVec2& result) -> bool\n    {\n        if (v.is_object())\n        {\n            auto xValue = v[\"x\"];\n            auto yValue = v[\"y\"];\n\n            if (xValue.is_number() && yValue.is_number())\n            {\n                result.x = static_cast<float>(xValue.get<double>());\n                result.y = static_cast<float>(yValue.get<double>());\n\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    if (!tryParseVector(data[\"location\"], result.m_Location))\n        return false;\n\n    if (data.contains(\"group_size\") && !tryParseVector(data[\"group_size\"], result.m_GroupSize))\n        return false;\n\n    return true;\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Settings\n//\n//------------------------------------------------------------------------------\ned::NodeSettings* ed::Settings::AddNode(NodeId id)\n{\n    m_Nodes.push_back(NodeSettings(id));\n    return &m_Nodes.back();\n}\n\ned::NodeSettings* ed::Settings::FindNode(NodeId id)\n{\n    for (auto& settings : m_Nodes)\n        if (settings.m_ID == id)\n            return &settings;\n\n    return nullptr;\n}\n\nvoid ed::Settings::RemoveNode(NodeId id)\n{\n    auto node = FindNode(id);\n    if (!node)\n        return;\n\n    *node = NodeSettings(id);\n}\n\nvoid ed::Settings::ClearDirty(Node* node)\n{\n    if (node)\n    {\n        auto settings = FindNode(node->m_ID);\n        IM_ASSERT(settings);\n        settings->ClearDirty();\n    }\n    else\n    {\n        m_IsDirty     = false;\n        m_DirtyReason = SaveReasonFlags::None;\n\n        for (auto& knownNode : m_Nodes)\n            knownNode.ClearDirty();\n    }\n}\n\nvoid ed::Settings::MakeDirty(SaveReasonFlags reason, Node* node)\n{\n    m_IsDirty     = true;\n    m_DirtyReason = m_DirtyReason | reason;\n\n    if (node)\n    {\n        auto settings = FindNode(node->m_ID);\n        IM_ASSERT(settings);\n\n        settings->MakeDirty(reason);\n    }\n}\n\nstd::string ed::Settings::Serialize()\n{\n    json::value result;\n\n    auto serializeObjectId = [](ObjectId id)\n    {\n        auto value = std::to_string(reinterpret_cast<uintptr_t>(id.AsPointer()));\n        switch (id.Type())\n        {\n            default:\n            case NodeEditor::Detail::ObjectType::None: return value;\n            case NodeEditor::Detail::ObjectType::Node: return \"node:\" + value;\n            case NodeEditor::Detail::ObjectType::Link: return \"link:\" + value;\n            case NodeEditor::Detail::ObjectType::Pin:  return \"pin:\"  + value;\n        }\n    };\n\n    auto& nodes = result[\"nodes\"];\n    for (auto& node : m_Nodes)\n    {\n        if (node.m_WasUsed)\n            nodes[serializeObjectId(node.m_ID)] = node.Serialize();\n    }\n\n    auto& selection = result[\"selection\"];\n    for (auto& id : m_Selection)\n        selection.push_back(serializeObjectId(id));\n\n    auto& view = result[\"view\"];\n    view[\"scroll\"][\"x\"] = m_ViewScroll.x;\n    view[\"scroll\"][\"y\"] = m_ViewScroll.y;\n    view[\"zoom\"]   = m_ViewZoom;\n    view[\"visible_rect\"][\"min\"][\"x\"] = m_VisibleRect.Min.x;\n    view[\"visible_rect\"][\"min\"][\"y\"] = m_VisibleRect.Min.y;\n    view[\"visible_rect\"][\"max\"][\"x\"] = m_VisibleRect.Max.x;\n    view[\"visible_rect\"][\"max\"][\"y\"] = m_VisibleRect.Max.y;\n\n    return result.dump();\n}\n\nbool ed::Settings::Parse(const std::string& string, Settings& settings)\n{\n    Settings result = settings;\n\n    auto settingsValue = json::value::parse(string);\n    if (settingsValue.is_discarded())\n        return false;\n\n    if (!settingsValue.is_object())\n        return false;\n\n    auto tryParseVector = [](const json::value& v, ImVec2& result) -> bool\n    {\n        if (v.is_object() && v.contains(\"x\") && v.contains(\"y\"))\n        {\n            auto xValue = v[\"x\"];\n            auto yValue = v[\"y\"];\n\n            if (xValue.is_number() && yValue.is_number())\n            {\n                result.x = static_cast<float>(xValue.get<double>());\n                result.y = static_cast<float>(yValue.get<double>());\n\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    auto deserializeObjectId = [](const std::string& str)\n    {\n        auto separator = str.find_first_of(':');\n        auto idStart   = str.c_str() + ((separator != std::string::npos) ? separator + 1 : 0);\n        auto id        = reinterpret_cast<void*>(strtoull(idStart, nullptr, 10));\n        if (str.compare(0, separator, \"node\") == 0)\n            return ObjectId(NodeId(id));\n        else if (str.compare(0, separator, \"link\") == 0)\n            return ObjectId(LinkId(id));\n        else if (str.compare(0, separator, \"pin\") == 0)\n            return ObjectId(PinId(id));\n        else\n            // fallback to old format\n            return ObjectId(NodeId(id)); //return ObjectId();\n    };\n\n    //auto& settingsObject = settingsValue.get<json::object>();\n\n    auto& nodesValue = settingsValue[\"nodes\"];\n    if (nodesValue.is_object())\n    {\n        for (auto& node : nodesValue.get<json::object>())\n        {\n            auto id = deserializeObjectId(node.first.c_str()).AsNodeId();\n\n            auto nodeSettings = result.FindNode(id);\n            if (!nodeSettings)\n                nodeSettings = result.AddNode(id);\n\n            NodeSettings::Parse(node.second, *nodeSettings);\n        }\n    }\n\n    auto& selectionValue = settingsValue[\"selection\"];\n    if (selectionValue.is_array())\n    {\n        const auto selectionArray = selectionValue.get<json::array>();\n\n        result.m_Selection.reserve(selectionArray.size());\n        result.m_Selection.resize(0);\n        for (auto& selection : selectionArray)\n        {\n            if (selection.is_string())\n                result.m_Selection.push_back(deserializeObjectId(selection.get<json::string>()));\n        }\n    }\n\n    auto& viewValue = settingsValue[\"view\"];\n    if (viewValue.is_object())\n    {\n        auto& viewScrollValue = viewValue[\"scroll\"];\n        auto& viewZoomValue   = viewValue[\"zoom\"];\n\n        if (!tryParseVector(viewScrollValue, result.m_ViewScroll))\n            result.m_ViewScroll = ImVec2(0, 0);\n\n        result.m_ViewZoom = viewZoomValue.is_number() ? static_cast<float>(viewZoomValue.get<double>()) : 1.0f;\n\n        if (!viewValue.contains(\"visible_rect\") || !tryParseVector(viewValue[\"visible_rect\"][\"min\"], result.m_VisibleRect.Min) || !tryParseVector(viewValue[\"visible_rect\"][\"max\"], result.m_VisibleRect.Max))\n            result.m_VisibleRect = {};\n    }\n\n    settings = std::move(result);\n\n    return true;\n}\n\n\n\n//------------------------------------------------------------------------------\n//\n// Animation\n//\n//------------------------------------------------------------------------------\ned::Animation::Animation(EditorContext* editor):\n    Editor(editor),\n    m_State(Stopped),\n    m_Time(0.0f),\n    m_Duration(0.0f)\n{\n}\n\ned::Animation::~Animation()\n{\n    Stop();\n}\n\nvoid ed::Animation::Play(float duration)\n{\n    if (IsPlaying())\n        Stop();\n\n    m_State = Playing;\n    if (duration < 0)\n        duration = 0.0f;\n\n    m_Time     = 0.0f;\n    m_Duration = duration;\n\n    OnPlay();\n\n    Editor->RegisterAnimation(this);\n\n    if (duration == 0.0f)\n        Finish();\n}\n\nvoid ed::Animation::Stop()\n{\n    if (!IsPlaying())\n        return;\n\n    m_State = Stopped;\n\n    Editor->UnregisterAnimation(this);\n\n    OnStop();\n}\n\nvoid ed::Animation::Finish()\n{\n    if (!IsPlaying())\n        return;\n\n    OnFinish();\n\n    Stop();\n}\n\nvoid ed::Animation::Update()\n{\n    if (!IsPlaying())\n        return;\n\n    m_Time += ImMax(0.0f, ImGui::GetIO().DeltaTime);\n    if (m_Time < m_Duration)\n    {\n        const float progress = GetProgress();\n        OnUpdate(progress);\n    }\n    else\n    {\n        OnFinish();\n        Stop();\n    }\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Navigate Animation\n//\n//------------------------------------------------------------------------------\ned::NavigateAnimation::NavigateAnimation(EditorContext* editor, NavigateAction& scrollAction):\n    Animation(editor),\n    Action(scrollAction)\n{\n}\n\nvoid ed::NavigateAnimation::NavigateTo(const ImRect& target, float duration)\n{\n    Stop();\n\n    m_Start      = Action.GetViewRect();\n    m_Target     = target;\n\n    // Skip tiny animations\n    auto minoffset = m_Target.Min - m_Start.Min;\n    auto maxOffset = m_Target.Max - m_Start.Max;\n    auto epsilon   = 1e-4f;\n    if (ImFabs(minoffset.x) < epsilon && ImFabs(minoffset.y) < epsilon &&\n        ImFabs(maxOffset.x) < epsilon && ImFabs(maxOffset.y) < epsilon)\n    {\n        duration = 0;\n    }\n\n    Play(duration);\n}\n\nvoid ed::NavigateAnimation::OnUpdate(float progress)\n{\n    ImRect current;\n    current.Min = ImEasing::EaseOutQuad(m_Start.Min, m_Target.Min - m_Start.Min, progress);\n    current.Max = ImEasing::EaseOutQuad(m_Start.Max, m_Target.Max - m_Start.Max, progress);\n    Action.SetViewRect(current);\n}\n\nvoid ed::NavigateAnimation::OnStop()\n{\n    Editor->MakeDirty(SaveReasonFlags::Navigation);\n}\n\nvoid ed::NavigateAnimation::OnFinish()\n{\n    Action.SetViewRect(m_Target);\n\n    Editor->MakeDirty(SaveReasonFlags::Navigation);\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Flow Animation\n//\n//------------------------------------------------------------------------------\ned::FlowAnimation::FlowAnimation(FlowAnimationController* controller):\n    Animation(controller->Editor),\n    Controller(controller),\n    m_Link(nullptr),\n    m_Offset(0.0f),\n    m_PathLength(0.0f)\n{\n}\n\nvoid ed::FlowAnimation::Flow(ed::Link* link, float markerDistance, float speed, float duration)\n{\n    Stop();\n\n    if (m_Link != link)\n    {\n        m_Offset = 0.0f;\n        ClearPath();\n    }\n\n    if (m_MarkerDistance != markerDistance)\n        ClearPath();\n\n    m_MarkerDistance = markerDistance;\n    m_Speed          = speed;\n    m_Link           = link;\n\n    Play(duration);\n}\n\nvoid ed::FlowAnimation::Draw(ImDrawList* drawList)\n{\n    if (!IsPlaying() || !IsLinkValid() || !m_Link->IsVisible())\n        return;\n\n    if (!IsPathValid())\n        UpdatePath();\n\n    m_Offset = fmodf(m_Offset, m_MarkerDistance);\n    if (m_Offset < 0)\n        m_Offset += m_MarkerDistance;\n\n    const auto progress    = GetProgress();\n\n    const auto flowAlpha = 1.0f - progress * progress;\n    const auto flowColor = Editor->GetColor(StyleColor_Flow, flowAlpha);\n    //const auto flowPath  = Link->GetCurve();\n\n    m_Link->Draw(drawList, flowColor, 2.0f);\n\n    if (IsPathValid())\n    {\n        //Offset = 0;\n\n        const auto markerAlpha  = powf(1.0f - progress, 0.35f);\n        const auto markerRadius = 4.0f * (1.0f - progress) + 2.0f;\n        const auto markerColor  = Editor->GetColor(StyleColor_FlowMarker, markerAlpha);\n\n        for (float d = m_Offset; d < m_PathLength; d += m_MarkerDistance)\n            drawList->AddCircleFilled(SamplePath(d), markerRadius, markerColor);\n    }\n}\n\nbool ed::FlowAnimation::IsLinkValid() const\n{\n    return m_Link && m_Link->m_IsLive;\n}\n\nbool ed::FlowAnimation::IsPathValid() const\n{\n    return m_Path.size() > 1 && m_PathLength > 0.0f && m_Link->m_Start == m_LastStart && m_Link->m_End == m_LastEnd;\n}\n\nvoid ed::FlowAnimation::UpdatePath()\n{\n    if (!IsLinkValid())\n    {\n        ClearPath();\n        return;\n    }\n\n    const auto curve  = m_Link->GetCurve();\n\n    m_LastStart  = m_Link->m_Start;\n    m_LastEnd    = m_Link->m_End;\n    m_PathLength = ImCubicBezierLength(curve.P0, curve.P1, curve.P2, curve.P3);\n\n    auto collectPointsCallback = [this](ImCubicBezierFixedStepSample& result)\n    {\n        m_Path.push_back(CurvePoint{ result.Length, result.Point });\n    };\n\n    const auto step = ImMax(m_MarkerDistance * 0.5f, 15.0f);\n\n    m_Path.resize(0);\n    ImCubicBezierFixedStep(collectPointsCallback, curve, step, false, 0.5f, 0.001f);\n}\n\nvoid ed::FlowAnimation::ClearPath()\n{\n    vector<CurvePoint>().swap(m_Path);\n    m_PathLength = 0.0f;\n}\n\nImVec2 ed::FlowAnimation::SamplePath(float distance) const\n{\n    //distance = ImMax(0.0f, std::min(distance, PathLength));\n\n    auto endPointIt = std::find_if(m_Path.begin(), m_Path.end(), [distance](const CurvePoint& p) { return distance < p.Distance; });\n    if (endPointIt == m_Path.end())\n        endPointIt = m_Path.end() - 1;\n    else if (endPointIt == m_Path.begin())\n        endPointIt = m_Path.begin() + 1;\n\n    const auto& start = endPointIt[-1];\n    const auto& end   = *endPointIt;\n    const auto  t     = (distance - start.Distance) / (end.Distance - start.Distance);\n\n    return start.Point + (end.Point - start.Point) * t;\n}\n\nvoid ed::FlowAnimation::OnUpdate(float progress)\n{\n    IM_UNUSED(progress);\n\n    m_Offset += m_Speed * ImGui::GetIO().DeltaTime;\n}\n\nvoid ed::FlowAnimation::OnStop()\n{\n    Controller->Release(this);\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Flow Animation Controller\n//\n//------------------------------------------------------------------------------\ned::FlowAnimationController::FlowAnimationController(EditorContext* editor):\n    AnimationController(editor)\n{\n}\n\ned::FlowAnimationController::~FlowAnimationController()\n{\n    for (auto animation : m_Animations)\n        delete animation;\n}\n\nvoid ed::FlowAnimationController::Flow(Link* link, FlowDirection direction)\n{\n    if (!link || !link->m_IsLive)\n        return;\n\n    auto& editorStyle = GetStyle();\n\n    auto animation = GetOrCreate(link);\n\n    float speedDirection = 1.0f;\n    if (direction == FlowDirection::Backward)\n        speedDirection = -1.0f;\n\n    animation->Flow(link, editorStyle.FlowMarkerDistance, editorStyle.FlowSpeed * speedDirection, editorStyle.FlowDuration);\n}\n\nvoid ed::FlowAnimationController::Draw(ImDrawList* drawList)\n{\n    if (m_Animations.empty())\n        return;\n\n    drawList->ChannelsSetCurrent(c_LinkChannel_Flow);\n\n    for (auto animation : m_Animations)\n        animation->Draw(drawList);\n}\n\ned::FlowAnimation* ed::FlowAnimationController::GetOrCreate(Link* link)\n{\n    // Return live animation which match target link\n    {\n        auto animationIt = std::find_if(m_Animations.begin(), m_Animations.end(), [link](FlowAnimation* animation) { return animation->m_Link == link; });\n        if (animationIt != m_Animations.end())\n            return *animationIt;\n    }\n\n    // There are no live animations for target link, try to reuse inactive old one\n    if (!m_FreePool.empty())\n    {\n        auto animation = m_FreePool.back();\n        m_FreePool.pop_back();\n        return animation;\n    }\n\n    // Cache miss, allocate new one\n    auto animation = new FlowAnimation(this);\n    m_Animations.push_back(animation);\n\n    return animation;\n}\n\nvoid ed::FlowAnimationController::Release(FlowAnimation* animation)\n{\n    IM_UNUSED(animation);\n}\n\n\n\n//------------------------------------------------------------------------------\n//\n// Navigate Action\n//\n//------------------------------------------------------------------------------\nconst float ed::NavigateAction::s_DefaultZoomLevels[] =\n{\n    0.1f, 0.15f, 0.20f, 0.25f, 0.33f, 0.5f, 0.75f, 1.0f, 1.25f, 1.50f, 2.0f, 2.5f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f\n};\n\nconst int ed::NavigateAction::s_DefaultZoomLevelCount = sizeof(s_DefaultZoomLevels) / sizeof(*s_DefaultZoomLevels);\n\ned::NavigateAction::NavigateAction(EditorContext* editor, ImGuiEx::Canvas& canvas):\n    EditorAction(editor),\n    m_IsActive(false),\n    m_Zoom(1),\n    m_VisibleRect(),\n    m_Scroll(0, 0),\n    m_ScrollStart(0, 0),\n    m_ScrollDelta(0, 0),\n    m_Canvas(canvas),\n    m_WindowScreenPos(0, 0),\n    m_WindowScreenSize(0, 0),\n    m_Animation(editor, *this),\n    m_Reason(NavigationReason::Unknown),\n    m_LastSelectionId(0),\n    m_LastObject(nullptr),\n    m_MovingOverEdge(false),\n    m_MoveScreenOffset(0, 0),\n    m_ZoomLevels(editor->GetConfig().CustomZoomLevels.Size > 0 ? editor->GetConfig().CustomZoomLevels.Data : s_DefaultZoomLevels),\n    m_ZoomLevelCount(editor->GetConfig().CustomZoomLevels.Size > 0 ? editor->GetConfig().CustomZoomLevels.Size : s_DefaultZoomLevelCount)\n{\n}\n\ned::EditorAction::AcceptResult ed::NavigateAction::Accept(const Control& control)\n{\n    IM_ASSERT(!m_IsActive);\n\n    if (m_IsActive)\n        return False;\n\n    if (Editor->CanAcceptUserInput() /*&& !ImGui::IsAnyItemActive()*/ && ImGui::IsMouseDragging(Editor->GetConfig().NavigateButtonIndex, 0.0f))\n    {\n        m_IsActive    = true;\n        m_ScrollStart = m_Scroll;\n        m_ScrollDelta = ImGui::GetMouseDragDelta(Editor->GetConfig().NavigateButtonIndex);\n        m_Scroll      = m_ScrollStart - m_ScrollDelta * m_Zoom;\n    }\n\n    auto& io = ImGui::GetIO();\n\n    if (Editor->CanAcceptUserInput() && ImGui::IsKeyPressed(GetKeyIndexForF()) && Editor->AreShortcutsEnabled())\n    {\n        const auto zoomMode = io.KeyShift ? NavigateAction::ZoomMode::WithMargin : NavigateAction::ZoomMode::None;\n\n        auto findHotObjectToZoom = [this, &control, &io]() -> Object*\n        {\n            if (control.HotObject)\n            {\n                if (auto pin = control.HotObject->AsPin())\n                    return pin->m_Node;\n                else\n                    return control.HotObject;\n            }\n            else if (control.BackgroundHot)\n            {\n                auto node = Editor->FindNodeAt(io.MousePos);\n                if (IsGroup(node))\n                    return node;\n            }\n\n            return nullptr;\n        };\n\n        bool navigateToContent = false;\n        if (!Editor->GetSelectedObjects().empty())\n        {\n            if (m_Reason != NavigationReason::Selection || m_LastSelectionId != Editor->GetSelectionId() || (zoomMode != NavigateAction::ZoomMode::None))\n            {\n                m_LastSelectionId = Editor->GetSelectionId();\n                NavigateTo(Editor->GetSelectionBounds(), zoomMode, -1.0f, NavigationReason::Selection);\n            }\n            else\n                navigateToContent = true;\n        }\n        else if(auto hotObject = findHotObjectToZoom())\n        {\n            if (m_Reason != NavigationReason::Object || m_LastObject != hotObject || (zoomMode != NavigateAction::ZoomMode::None))\n            {\n                m_LastObject = hotObject;\n                auto bounds = hotObject->GetBounds();\n                NavigateTo(bounds, zoomMode, -1.0f, NavigationReason::Object);\n            }\n            else\n                navigateToContent = true;\n        }\n        else\n            navigateToContent = true;\n\n        if (navigateToContent)\n            NavigateTo(Editor->GetContentBounds(), NavigateAction::ZoomMode::WithMargin, -1.0f, NavigationReason::Content);\n    }\n\n    auto visibleRect = GetViewRect();\n    if (m_VisibleRect.Min != visibleRect.Min || m_VisibleRect.Max != visibleRect.Max)\n    {\n        m_VisibleRect = visibleRect;\n        Editor->MakeDirty(SaveReasonFlags::Navigation);\n    }\n\n    // // #debug\n    // if (m_DrawList)\n    //     m_DrawList->AddCircleFilled(io.MousePos, 4.0f, IM_COL32(255, 0, 255, 255));\n\n    if (HandleZoom(control))\n        return True;\n\n    return m_IsActive ? True : False;\n}\n\nbool ed::NavigateAction::Process(const Control& control)\n{\n    IM_UNUSED(control);\n\n    if (!m_IsActive)\n        return false;\n\n    if (ImGui::IsMouseDragging(Editor->GetConfig().NavigateButtonIndex, 0.0f))\n    {\n        m_ScrollDelta = ImGui::GetMouseDragDelta(Editor->GetConfig().NavigateButtonIndex);\n        m_Scroll      = m_ScrollStart - m_ScrollDelta * m_Zoom;\n        m_VisibleRect = GetViewRect();\n//         if (IsActive && Animation.IsPlaying())\n//             Animation.Target = Animation.Target - ScrollDelta * Animation.TargetZoom;\n    }\n    else\n    {\n        if (m_Scroll != m_ScrollStart)\n            Editor->MakeDirty(SaveReasonFlags::Navigation);\n\n        m_IsActive = false;\n    }\n\n    // #TODO: Handle zoom while scrolling\n    // HandleZoom(control);\n\n    return m_IsActive;\n}\n\nbool ed::NavigateAction::HandleZoom(const Control& control)\n{\n    IM_UNUSED(control);\n\n    const auto currentAction  = Editor->GetCurrentAction();\n    const auto allowOffscreen = currentAction && currentAction->IsDragging();\n\n    auto& io = ImGui::GetIO();\n\n    if (!io.MouseWheel || (!allowOffscreen && !Editor->IsHoveredWithoutOverlapp()))// && !ImGui::IsAnyItemActive())\n        return false;\n\n    auto savedScroll = m_Scroll;\n    auto savedZoom   = m_Zoom;\n\n    m_Animation.Finish();\n\n    auto mousePos = io.MousePos;\n    auto newZoom  = GetNextZoom(io.MouseWheel);\n\n    auto oldView   = GetView();\n    m_Zoom = newZoom;\n    auto newView   = GetView();\n\n    auto screenPos = m_Canvas.FromLocal(mousePos, oldView);\n    auto canvasPos = m_Canvas.ToLocal(screenPos, newView);\n\n    auto offset       = (canvasPos - mousePos) * m_Zoom;\n    auto targetScroll = m_Scroll - offset;\n\n    auto visibleRect = GetViewRect();\n\n    if (m_Scroll != savedScroll || m_Zoom != savedZoom || m_VisibleRect.Min != visibleRect.Min || m_VisibleRect.Max != visibleRect.Max)\n    {\n        m_Scroll      = savedScroll;\n        m_Zoom        = savedZoom;\n        m_VisibleRect = visibleRect;\n\n        Editor->MakeDirty(SaveReasonFlags::Navigation);\n    }\n\n    auto targetRect = m_Canvas.CalcViewRect(ImGuiEx::CanvasView(-targetScroll, newZoom));\n\n    NavigateTo(targetRect, c_MouseZoomDuration, NavigationReason::MouseZoom);\n\n    return true;\n}\n\nvoid ed::NavigateAction::ShowMetrics()\n{\n    EditorAction::ShowMetrics();\n\n    ImGui::Text(\"%s:\", GetName());\n    ImGui::Text(\"    Active: %s\", m_IsActive ? \"yes\" : \"no\");\n    ImGui::Text(\"    Scroll: { x=%g y=%g }\", m_Scroll.x, m_Scroll.y);\n    ImGui::Text(\"    Zoom: %g\", m_Zoom);\n    ImGui::Text(\"    Visible Rect: { l=%g t=%g, r=%g b=%g w=%g h=%g }\",\n        m_VisibleRect.Min.x, m_VisibleRect.Min.y,\n        m_VisibleRect.Max.x, m_VisibleRect.Max.y,\n        m_VisibleRect.Max.x - m_VisibleRect.Min.x,\n        m_VisibleRect.Max.y - m_VisibleRect.Min.y);\n}\n\nvoid ed::NavigateAction::NavigateTo(const ImRect& bounds, ZoomMode zoomMode, float duration, NavigationReason reason)\n{\n    if (ImRect_IsEmpty(bounds))\n        return;\n\n    if (duration < 0.0f)\n        duration = GetStyle().ScrollDuration;\n\n    if (zoomMode == ZoomMode::None)\n    {\n        auto viewRect       = m_Canvas.ViewRect();\n        auto viewRectCenter = viewRect.GetCenter();\n        auto targetCenter   = bounds.GetCenter();\n\n        viewRect.Translate(targetCenter - viewRectCenter);\n\n        NavigateTo(viewRect, duration, reason);\n    }\n    else\n    {\n        // Grow rect by 5% to leave some reasonable margin\n        // from the edges of the canvas.\n        auto rect   = bounds;\n\n        if (zoomMode == ZoomMode::WithMargin)\n        {\n            auto extend = ImMax(rect.GetWidth(), rect.GetHeight());\n            rect.Expand(extend * c_NavigationZoomMargin * 0.5f);\n        }\n\n        NavigateTo(rect, duration, reason);\n    }\n}\n\nvoid ed::NavigateAction::NavigateTo(const ImRect& target, float duration, NavigationReason reason)\n{\n    m_Reason = reason;\n\n    m_Animation.NavigateTo(target, duration);\n}\n\nvoid ed::NavigateAction::StopNavigation()\n{\n    m_Animation.Stop();\n}\n\nvoid ed::NavigateAction::FinishNavigation()\n{\n    m_Animation.Finish();\n}\n\nbool ed::NavigateAction::MoveOverEdge(const ImVec2& canvasSize)\n{\n    // Don't interrupt non-edge animations\n    if (m_Animation.IsPlaying())\n        return false;\n\n    auto& io = ImGui::GetIO();\n\n    const auto screenMousePos   = io.MousePos;\n    const auto screenRect       = ImRect(ImGui::GetCursorScreenPos(), ImGui::GetCursorScreenPos() + canvasSize);\n\n    // Mouse is over screen, do nothing\n    if (screenRect.Contains(screenMousePos))\n        return false;\n\n    // Several backend move mouse position to -FLT_MAX to indicate\n    // uninitialized/unknown state. To prevent all sorts\n    // of math problems, we just ignore such state.\n    if (screenMousePos.x <= -FLT_MAX || screenMousePos.y <= -FLT_MAX)\n        return false;\n\n    const auto minDistance       = ImVec2(-c_MaxMoveOverEdgeDistance, -c_MaxMoveOverEdgeDistance);\n    const auto maxDistance       = ImVec2( c_MaxMoveOverEdgeDistance,  c_MaxMoveOverEdgeDistance);\n\n    const auto screenPointOnEdge  = ImRect_ClosestPoint(screenRect, screenMousePos, true);\n    const auto offset             = ImMin(ImMax(screenPointOnEdge - screenMousePos, minDistance), maxDistance);\n    const auto relativeOffset     = -offset * io.DeltaTime * c_MaxMoveOverEdgeSpeed;\n\n    m_Scroll = m_Scroll + relativeOffset;\n\n    m_MoveScreenOffset  = relativeOffset;\n    m_MovingOverEdge    = true;\n\n    return true;\n}\n\nvoid ed::NavigateAction::StopMoveOverEdge()\n{\n    if (m_MovingOverEdge)\n    {\n        Editor->MakeDirty(SaveReasonFlags::Navigation);\n\n        m_MoveScreenOffset  = ImVec2(0, 0);\n        m_MovingOverEdge    = false;\n    }\n}\n\nvoid ed::NavigateAction::SetWindow(ImVec2 position, ImVec2 size)\n{\n    m_WindowScreenPos  = position;\n    m_WindowScreenSize = size;\n}\n\nImGuiEx::CanvasView ed::NavigateAction::GetView() const\n{\n    return ImGuiEx::CanvasView(-m_Scroll, m_Zoom);\n}\n\nImVec2 ed::NavigateAction::GetViewOrigin() const\n{\n    return -m_Scroll;\n}\n\nfloat ed::NavigateAction::GetViewScale() const\n{\n    return m_Zoom;\n}\n\nvoid ed::NavigateAction::SetViewRect(const ImRect& rect)\n{\n    auto view = m_Canvas.CalcCenterView(rect);\n    m_Scroll = -view.Origin;\n    m_Zoom   =  view.Scale;\n}\n\nImRect ed::NavigateAction::GetViewRect() const\n{\n    return m_Canvas.CalcViewRect(GetView());\n}\n\nfloat ed::NavigateAction::GetNextZoom(float steps)\n{\n    if (this->Editor->GetConfig().EnableSmoothZoom)\n    {\n        return MatchSmoothZoom(steps);\n    }\n    else\n    {\n        auto fixedSteps = (int)steps;\n        return MatchZoom(fixedSteps, m_ZoomLevels[fixedSteps < 0 ? 0 : m_ZoomLevelCount - 1]);\n    }\n}\n\nfloat ed::NavigateAction::MatchSmoothZoom(float steps)\n{\n    const auto power = Editor->GetConfig().SmoothZoomPower;\n\n    const auto newZoom = m_Zoom * powf(power, steps);\n    if (newZoom < m_ZoomLevels[0])\n        return m_ZoomLevels[0];\n    else if (newZoom > m_ZoomLevels[m_ZoomLevelCount - 1])\n        return m_ZoomLevels[m_ZoomLevelCount - 1];\n    else\n        return newZoom;\n}\n\nfloat ed::NavigateAction::MatchZoom(int steps, float fallbackZoom)\n{\n    auto currentZoomIndex = MatchZoomIndex(steps);\n    if (currentZoomIndex < 0)\n        return fallbackZoom;\n\n    auto currentZoom = m_ZoomLevels[currentZoomIndex];\n    if (fabsf(currentZoom - m_Zoom) > 0.001f)\n        return currentZoom;\n\n    auto newIndex = currentZoomIndex + steps;\n    if (newIndex >= 0 && newIndex < m_ZoomLevelCount)\n        return m_ZoomLevels[newIndex];\n    else\n        return fallbackZoom;\n}\n\nint ed::NavigateAction::MatchZoomIndex(int direction)\n{\n    int   bestIndex    = -1;\n    float bestDistance = 0.0f;\n\n    for (int i = 0; i < m_ZoomLevelCount; ++i)\n    {\n        auto distance = fabsf(m_ZoomLevels[i] - m_Zoom);\n        if (distance < bestDistance || bestIndex < 0)\n        {\n            bestDistance = distance;\n            bestIndex    = i;\n        }\n    }\n\n    if (bestDistance > 0.001f)\n    {\n        if (direction > 0)\n        {\n            ++bestIndex;\n\n            if (bestIndex >= m_ZoomLevelCount)\n                bestIndex = m_ZoomLevelCount - 1;\n        }\n        else if (direction < 0)\n        {\n            --bestIndex;\n\n            if (bestIndex < 0)\n                bestIndex = 0;\n        }\n    }\n\n    return bestIndex;\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Size Action\n//\n//------------------------------------------------------------------------------\ned::SizeAction::SizeAction(EditorContext* editor):\n    EditorAction(editor),\n    m_IsActive(false),\n    m_Clean(false),\n    m_SizedNode(nullptr),\n    m_Pivot(NodeRegion::None),\n    m_Cursor(ImGuiMouseCursor_Arrow)\n{\n}\n\ned::EditorAction::AcceptResult ed::SizeAction::Accept(const Control& control)\n{\n    IM_ASSERT(!m_IsActive);\n\n    if (m_IsActive)\n        return False;\n\n    if (control.ActiveNode && IsGroup(control.ActiveNode) && ImGui::IsMouseDragging(Editor->GetConfig().DragButtonIndex, 1))\n    {\n        //const auto mousePos     = to_point(ImGui::GetMousePos());\n        //const auto closestPoint = control.ActiveNode->Bounds.get_closest_point_hollow(mousePos, static_cast<int>(control.ActiveNode->Rounding));\n\n        auto pivot = GetRegion(control.ActiveNode);\n        if (pivot != NodeRegion::Header && pivot != NodeRegion::Center)\n        {\n            m_StartBounds      = control.ActiveNode->m_Bounds;\n            m_StartGroupBounds = control.ActiveNode->m_GroupBounds;\n            m_LastSize         = control.ActiveNode->m_Bounds.GetSize();\n            m_MinimumSize      = ImVec2(0, 0);\n            m_LastDragOffset   = ImVec2(0, 0);\n            m_Pivot            = pivot;\n            m_Cursor           = ChooseCursor(m_Pivot);\n            m_SizedNode        = control.ActiveNode;\n            m_IsActive         = true;\n        }\n    }\n    else if (control.HotNode && IsGroup(control.HotNode))\n    {\n        m_Cursor = ChooseCursor(GetRegion(control.HotNode));\n        return Possible;\n    }\n\n    return m_IsActive ? True : False;\n}\n\nbool ed::SizeAction::Process(const Control& control)\n{\n    if (m_Clean)\n    {\n        m_Clean = false;\n\n        if (m_SizedNode->m_Bounds.Min != m_StartBounds.Min || m_SizedNode->m_GroupBounds.Min != m_StartGroupBounds.Min)\n            Editor->MakeDirty(SaveReasonFlags::Position | SaveReasonFlags::User, m_SizedNode);\n\n        if (m_SizedNode->m_Bounds.GetSize() != m_StartBounds.GetSize() || m_SizedNode->m_GroupBounds.GetSize() != m_StartGroupBounds.GetSize())\n            Editor->MakeDirty(SaveReasonFlags::Size | SaveReasonFlags::User, m_SizedNode);\n\n        m_SizedNode = nullptr;\n    }\n\n    if (!m_IsActive)\n        return false;\n\n    if (control.ActiveNode == m_SizedNode)\n    {\n        const auto dragOffset = (control.ActiveNode == m_SizedNode) ? ImGui::GetMouseDragDelta(0, 0.0f) : m_LastDragOffset;\n        m_LastDragOffset = dragOffset;\n\n        if (m_MinimumSize.x == 0.0f && m_LastSize.x != m_SizedNode->m_Bounds.GetWidth())\n            m_MinimumSize.x = m_SizedNode->m_Bounds.GetWidth();\n        if (m_MinimumSize.y == 0.0f && m_LastSize.y != m_SizedNode->m_Bounds.GetHeight())\n            m_MinimumSize.y = m_SizedNode->m_Bounds.GetHeight();\n\n        auto minimumSize = ImMax(m_MinimumSize, m_StartBounds.GetSize() - m_StartGroupBounds.GetSize());\n\n\n        auto newBounds = m_StartBounds;\n\n        if ((m_Pivot & NodeRegion::Top) == NodeRegion::Top)\n            newBounds.Min.y = ImMin(newBounds.Max.y - minimumSize.y, Editor->AlignPointToGrid(newBounds.Min.y + dragOffset.y));\n        if ((m_Pivot & NodeRegion::Bottom) == NodeRegion::Bottom)\n            newBounds.Max.y = ImMax(newBounds.Min.y + minimumSize.y, Editor->AlignPointToGrid(newBounds.Max.y + dragOffset.y));\n        if ((m_Pivot & NodeRegion::Left) == NodeRegion::Left)\n            newBounds.Min.x = ImMin(newBounds.Max.x - minimumSize.x, Editor->AlignPointToGrid(newBounds.Min.x + dragOffset.x));\n        if ((m_Pivot & NodeRegion::Right) == NodeRegion::Right)\n            newBounds.Max.x = ImMax(newBounds.Min.x + minimumSize.x, Editor->AlignPointToGrid(newBounds.Max.x + dragOffset.x));\n\n        newBounds.Floor();\n\n        m_LastSize = newBounds.GetSize();\n\n        m_SizedNode->m_Bounds      = newBounds;\n        m_SizedNode->m_GroupBounds = newBounds;\n        m_SizedNode->m_GroupBounds.Min.x -= m_StartBounds.Min.x - m_StartGroupBounds.Min.x;\n        m_SizedNode->m_GroupBounds.Min.y -= m_StartBounds.Min.y - m_StartGroupBounds.Min.y;\n        m_SizedNode->m_GroupBounds.Max.x -= m_StartBounds.Max.x - m_StartGroupBounds.Max.x;\n        m_SizedNode->m_GroupBounds.Max.y -= m_StartBounds.Max.y - m_StartGroupBounds.Max.y;\n    }\n    else if (!control.ActiveNode)\n    {\n        m_Clean = true;\n        m_IsActive = false;\n        return true;\n    }\n\n    return m_IsActive;\n}\n\nvoid ed::SizeAction::ShowMetrics()\n{\n    EditorAction::ShowMetrics();\n\n    auto getObjectName = [](Object* object)\n    {\n        if (!object) return \"\";\n        else if (object->AsNode())  return \"Node\";\n        else if (object->AsPin())   return \"Pin\";\n        else if (object->AsLink())  return \"Link\";\n        else return \"\";\n    };\n\n    ImGui::Text(\"%s:\", GetName());\n    ImGui::Text(\"    Active: %s\", m_IsActive ? \"yes\" : \"no\");\n    ImGui::Text(\"    Node: %s (%p)\", getObjectName(m_SizedNode), m_SizedNode ? m_SizedNode->m_ID.AsPointer() : nullptr);\n    if (m_SizedNode && m_IsActive)\n    {\n        ImGui::Text(\"    Bounds: { x=%g y=%g w=%g h=%g }\", m_SizedNode->m_Bounds.Min.x, m_SizedNode->m_Bounds.Min.y, m_SizedNode->m_Bounds.GetWidth(), m_SizedNode->m_Bounds.GetHeight());\n        ImGui::Text(\"    Group Bounds: { x=%g y=%g w=%g h=%g }\", m_SizedNode->m_GroupBounds.Min.x, m_SizedNode->m_GroupBounds.Min.y, m_SizedNode->m_GroupBounds.GetWidth(), m_SizedNode->m_GroupBounds.GetHeight());\n        ImGui::Text(\"    Start Bounds: { x=%g y=%g w=%g h=%g }\", m_StartBounds.Min.x, m_StartBounds.Min.y, m_StartBounds.GetWidth(), m_StartBounds.GetHeight());\n        ImGui::Text(\"    Start Group Bounds: { x=%g y=%g w=%g h=%g }\", m_StartGroupBounds.Min.x, m_StartGroupBounds.Min.y, m_StartGroupBounds.GetWidth(), m_StartGroupBounds.GetHeight());\n        ImGui::Text(\"    Minimum Size: { w=%g h=%g }\", m_MinimumSize.x, m_MinimumSize.y);\n        ImGui::Text(\"    Last Size: { w=%g h=%g }\", m_LastSize.x, m_LastSize.y);\n    }\n}\n\ned::NodeRegion ed::SizeAction::GetRegion(Node* node)\n{\n    return node->GetRegion(ImGui::GetMousePos());\n}\n\nImGuiMouseCursor ed::SizeAction::ChooseCursor(NodeRegion region)\n{\n    switch (region)\n    {\n        default:\n        case NodeRegion::Center:\n            return ImGuiMouseCursor_Arrow;\n\n        case NodeRegion::Top:\n        case NodeRegion::Bottom:\n            return ImGuiMouseCursor_ResizeNS;\n\n        case NodeRegion::Left:\n        case NodeRegion::Right:\n            return ImGuiMouseCursor_ResizeEW;\n\n        case NodeRegion::TopLeft:\n        case NodeRegion::BottomRight:\n            return ImGuiMouseCursor_ResizeNWSE;\n\n        case NodeRegion::TopRight:\n        case NodeRegion::BottomLeft:\n            return ImGuiMouseCursor_ResizeNESW;\n    }\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Drag Action\n//\n//------------------------------------------------------------------------------\ned::DragAction::DragAction(EditorContext* editor):\n    EditorAction(editor),\n    m_IsActive(false),\n    m_Clear(false),\n    m_DraggedObject(nullptr)\n{\n}\n\ned::EditorAction::AcceptResult ed::DragAction::Accept(const Control& control)\n{\n    IM_ASSERT(!m_IsActive);\n\n    if (m_IsActive)\n        return False;\n\n    if (Editor->CanAcceptUserInput() && control.ActiveObject && ImGui::IsMouseDragging(Editor->GetConfig().DragButtonIndex, 1))\n    {\n        if (!control.ActiveObject->AcceptDrag())\n            return False;\n\n        m_DraggedObject = control.ActiveObject;\n\n        m_Objects.resize(0);\n        m_Objects.push_back(m_DraggedObject);\n\n        if (Editor->IsSelected(m_DraggedObject))\n        {\n            for (auto selectedObject : Editor->GetSelectedObjects())\n                if (auto selectedNode = selectedObject->AsNode())\n                    if (selectedNode != m_DraggedObject && selectedNode->AcceptDrag())\n                        m_Objects.push_back(selectedNode);\n        }\n\n        auto& io = ImGui::GetIO();\n        if (!io.KeyShift)\n        {\n            std::vector<Node*> groupedNodes;\n            for (auto object : m_Objects)\n                if (auto node = object->AsNode())\n                    node->GetGroupedNodes(groupedNodes, true);\n\n            auto isAlreadyPicked = [this](Node* node)\n            {\n                return std::find(m_Objects.begin(), m_Objects.end(), node) != m_Objects.end();\n            };\n\n            for (auto candidate : groupedNodes)\n                if (!isAlreadyPicked(candidate) && candidate->AcceptDrag())\n                    m_Objects.push_back(candidate);\n        }\n\n        m_IsActive = true;\n    }\n    else if (control.HotNode && IsGroup(control.HotNode) && control.HotNode->GetRegion(ImGui::GetMousePos()) == NodeRegion::Header)\n    {\n        return Possible;\n    }\n\n    return m_IsActive ? True : False;\n}\n\nbool ed::DragAction::Process(const Control& control)\n{\n    if (m_Clear)\n    {\n        m_Clear = false;\n\n        for (auto object : m_Objects)\n        {\n            if (object->EndDrag())\n                Editor->MakeDirty(SaveReasonFlags::Position | SaveReasonFlags::User, object->AsNode());\n        }\n\n        m_Objects.resize(0);\n\n        m_DraggedObject = nullptr;\n    }\n\n    if (!m_IsActive)\n        return false;\n\n    if (control.ActiveObject == m_DraggedObject)\n    {\n        auto dragOffset = ImGui::GetMouseDragDelta(Editor->GetConfig().DragButtonIndex, 0.0f);\n\n        auto draggedOrigin  = m_DraggedObject->DragStartLocation();\n        auto alignPivot     = ImVec2(0, 0);\n\n        // TODO: Move this experimental alignment to closes pivot out of internals to node API\n        if (auto draggedNode = m_DraggedObject->AsNode())\n        {\n            float x = FLT_MAX;\n            float y = FLT_MAX;\n\n            auto testPivot = [this, &x, &y, &draggedOrigin, &dragOffset, &alignPivot](const ImVec2& pivot)\n            {\n                auto initial   = draggedOrigin + dragOffset + pivot;\n                auto candidate = Editor->AlignPointToGrid(initial) - draggedOrigin - pivot;\n\n                if (ImFabs(candidate.x) < ImFabs(ImMin(x, FLT_MAX)))\n                {\n                    x = candidate.x;\n                    alignPivot.x = pivot.x;\n                }\n\n                if (ImFabs(candidate.y) < ImFabs(ImMin(y, FLT_MAX)))\n                {\n                    y = candidate.y;\n                    alignPivot.y = pivot.y;\n                }\n            };\n\n            for (auto pin = draggedNode->m_LastPin; pin; pin = pin->m_PreviousPin)\n            {\n                auto pivot = pin->m_Pivot.GetCenter() - draggedNode->m_Bounds.Min;\n                testPivot(pivot);\n            }\n\n            //testPivot(point(0, 0));\n        }\n\n        auto alignedOffset  = Editor->AlignPointToGrid(draggedOrigin + dragOffset + alignPivot) - draggedOrigin - alignPivot;\n\n        if (!ImGui::GetIO().KeyAlt)\n            dragOffset = alignedOffset;\n\n        for (auto object : m_Objects)\n            object->UpdateDrag(dragOffset);\n    }\n    else if (!control.ActiveObject)\n    {\n        m_Clear = true;\n\n        m_IsActive = false;\n        return true;\n    }\n\n    return m_IsActive;\n}\n\nvoid ed::DragAction::ShowMetrics()\n{\n    EditorAction::ShowMetrics();\n\n    auto getObjectName = [](Object* object)\n    {\n        if (!object) return \"\";\n        else if (object->AsNode())  return \"Node\";\n        else if (object->AsPin())   return \"Pin\";\n        else if (object->AsLink())  return \"Link\";\n        else return \"\";\n    };\n\n    ImGui::Text(\"%s:\", GetName());\n    ImGui::Text(\"    Active: %s\", m_IsActive ? \"yes\" : \"no\");\n    ImGui::Text(\"    Node: %s (%p)\", getObjectName(m_DraggedObject), m_DraggedObject ? m_DraggedObject->ID().AsPointer() : nullptr);\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Select Action\n//\n//------------------------------------------------------------------------------\ned::SelectAction::SelectAction(EditorContext* editor):\n    EditorAction(editor),\n    m_IsActive(false),\n    m_SelectGroups(false),\n    m_SelectLinkMode(false),\n    m_CommitSelection(false),\n    m_StartPoint(),\n    m_Animation(editor)\n{\n}\n\ned::EditorAction::AcceptResult ed::SelectAction::Accept(const Control& control)\n{\n    IM_ASSERT(!m_IsActive);\n\n    if (m_IsActive)\n        return False;\n\n    auto& io = ImGui::GetIO();\n    m_SelectGroups   = io.KeyShift;\n    m_SelectLinkMode = io.KeyAlt;\n\n    m_SelectedObjectsAtStart.clear();\n\n    if (Editor->CanAcceptUserInput() && control.BackgroundHot && ImGui::IsMouseDragging(Editor->GetConfig().SelectButtonIndex, 1))\n    {\n        m_IsActive = true;\n        m_StartPoint = ImGui_GetMouseClickPos(Editor->GetConfig().SelectButtonIndex);\n        m_EndPoint   = m_StartPoint;\n\n        // Links and nodes cannot be selected together\n        if ((m_SelectLinkMode && Editor->IsAnyNodeSelected()) ||\n           (!m_SelectLinkMode && Editor->IsAnyLinkSelected()))\n        {\n            Editor->ClearSelection();\n        }\n\n        if (io.KeyCtrl)\n            m_SelectedObjectsAtStart = Editor->GetSelectedObjects();\n    }\n    else if (control.BackgroundClickButtonIndex == Editor->GetConfig().SelectButtonIndex)\n    {\n        Editor->ClearSelection();\n    }\n    else\n    {\n        Object* clickedObject = control.ClickedNode ? static_cast<Object*>(control.ClickedNode) : static_cast<Object*>(control.ClickedLink);\n\n        if (clickedObject)\n        {\n            // Links and nodes cannot be selected together\n            if ((clickedObject->AsLink() && Editor->IsAnyNodeSelected()) ||\n                (clickedObject->AsNode() && Editor->IsAnyLinkSelected()))\n            {\n                Editor->ClearSelection();\n            }\n\n            if (io.KeyCtrl)\n                Editor->ToggleObjectSelection(clickedObject);\n            else\n                Editor->SetSelectedObject(clickedObject);\n        }\n    }\n\n    if (m_IsActive)\n        m_Animation.Stop();\n\n    return m_IsActive ? True : False;\n}\n\nbool ed::SelectAction::Process(const Control& control)\n{\n    IM_UNUSED(control);\n\n    if (m_CommitSelection)\n    {\n        Editor->ClearSelection();\n        for (auto object : m_CandidateObjects)\n            Editor->SelectObject(object);\n\n        m_CandidateObjects.clear();\n\n        m_CommitSelection = false;\n    }\n\n    if (!m_IsActive)\n        return false;\n\n    if (ImGui::IsMouseDragging(Editor->GetConfig().SelectButtonIndex, 0))\n    {\n        m_EndPoint = ImGui::GetMousePos();\n\n        auto topLeft     = ImVec2(std::min(m_StartPoint.x, m_EndPoint.x), std::min(m_StartPoint.y, m_EndPoint.y));\n        auto bottomRight = ImVec2(ImMax(m_StartPoint.x, m_EndPoint.x), ImMax(m_StartPoint.y, m_EndPoint.y));\n        auto rect        = ImRect(topLeft, bottomRight);\n        if (rect.GetWidth() <= 0)\n            rect.Max.x = rect.Min.x + 1;\n        if (rect.GetHeight() <= 0)\n            rect.Max.y = rect.Min.y + 1;\n\n        vector<Node*> nodes;\n        vector<Link*> links;\n\n        if (m_SelectLinkMode)\n        {\n            Editor->FindLinksInRect(rect, links);\n            m_CandidateObjects.assign(links.begin(), links.end());\n        }\n        else\n        {\n            Editor->FindNodesInRect(rect, nodes);\n            m_CandidateObjects.assign(nodes.begin(), nodes.end());\n\n            if (m_SelectGroups)\n            {\n                auto endIt = std::remove_if(m_CandidateObjects.begin(), m_CandidateObjects.end(), [](Object* object) { return !IsGroup(object->AsNode()); });\n                m_CandidateObjects.erase(endIt, m_CandidateObjects.end());\n            }\n            else\n            {\n                auto endIt = std::remove_if(m_CandidateObjects.begin(), m_CandidateObjects.end(), [](Object* object) { return IsGroup(object->AsNode()); });\n                m_CandidateObjects.erase(endIt, m_CandidateObjects.end());\n            }\n        }\n\n        m_CandidateObjects.insert(m_CandidateObjects.end(), m_SelectedObjectsAtStart.begin(), m_SelectedObjectsAtStart.end());\n        std::sort(m_CandidateObjects.begin(), m_CandidateObjects.end());\n        m_CandidateObjects.erase(std::unique(m_CandidateObjects.begin(), m_CandidateObjects.end()), m_CandidateObjects.end());\n    }\n    else\n    {\n        m_IsActive = false;\n\n        m_Animation.Play(c_SelectionFadeOutDuration);\n\n        m_CommitSelection = true;\n\n        return true;\n    }\n\n    return m_IsActive;\n}\n\nvoid ed::SelectAction::ShowMetrics()\n{\n    EditorAction::ShowMetrics();\n\n    ImGui::Text(\"%s:\", GetName());\n    ImGui::Text(\"    Active: %s\", m_IsActive ? \"yes\" : \"no\");\n}\n\nvoid ed::SelectAction::Draw(ImDrawList* drawList)\n{\n    if (!m_IsActive && !m_Animation.IsPlaying())\n        return;\n\n    const auto alpha = m_Animation.IsPlaying() ? ImEasing::EaseOutQuad(1.0f, -1.0f, m_Animation.GetProgress()) : 1.0f;\n\n    const auto fillColor    = Editor->GetColor(m_SelectLinkMode ? StyleColor_LinkSelRect       : StyleColor_NodeSelRect, alpha);\n    const auto outlineColor = Editor->GetColor(m_SelectLinkMode ? StyleColor_LinkSelRectBorder : StyleColor_NodeSelRectBorder, alpha);\n\n    drawList->ChannelsSetCurrent(c_BackgroundChannel_SelectionRect);\n\n    auto min  = ImVec2(std::min(m_StartPoint.x, m_EndPoint.x), std::min(m_StartPoint.y, m_EndPoint.y));\n    auto max  = ImVec2(ImMax(m_StartPoint.x, m_EndPoint.x), ImMax(m_StartPoint.y, m_EndPoint.y));\n\n    drawList->AddRectFilled(min, max, fillColor);\n    drawList->AddRect(min, max, outlineColor);\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Context Menu Action\n//\n//------------------------------------------------------------------------------\ned::ContextMenuAction::ContextMenuAction(EditorContext* editor):\n    EditorAction(editor),\n    m_CandidateMenu(Menu::None),\n    m_CurrentMenu(Menu::None),\n    m_ContextId()\n{\n}\n\ned::EditorAction::AcceptResult ed::ContextMenuAction::Accept(const Control& control)\n{\n    const auto isPressed  = ImGui::IsMouseClicked(Editor->GetConfig().ContextMenuButtonIndex);\n    const auto isReleased = ImGui::IsMouseReleased(Editor->GetConfig().ContextMenuButtonIndex);\n    const auto isDragging = ImGui::IsMouseDragging(Editor->GetConfig().ContextMenuButtonIndex, 1);\n\n    if (isPressed || isReleased || isDragging)\n    {\n        Menu candidateMenu = ContextMenuAction::None;\n        ObjectId contextId;\n\n        if (auto hotObejct = control.HotObject)\n        {\n            if (hotObejct->AsNode())\n                candidateMenu = Node;\n            else if (hotObejct->AsPin())\n                candidateMenu = Pin;\n            else if (hotObejct->AsLink())\n                candidateMenu = Link;\n\n            if (candidateMenu != None)\n                contextId = hotObejct->ID();\n        }\n        else if (control.BackgroundHot)\n            candidateMenu = Background;\n\n        if (isPressed)\n        {\n            m_CandidateMenu = candidateMenu;\n            m_ContextId     = contextId;\n            return Possible;\n        }\n        else if (isReleased && m_CandidateMenu == candidateMenu && m_ContextId == contextId)\n        {\n            m_CurrentMenu   = m_CandidateMenu;\n            m_CandidateMenu = ContextMenuAction::None;\n            return True;\n        }\n        else\n        {\n            m_CandidateMenu = None;\n            m_CurrentMenu   = None;\n            m_ContextId     = ObjectId();\n            return False;\n        }\n    }\n\n    return False;\n}\n\nbool ed::ContextMenuAction::Process(const Control& control)\n{\n    IM_UNUSED(control);\n\n    m_CandidateMenu = None;\n    m_CurrentMenu   = None;\n    m_ContextId     = ObjectId();\n    return false;\n}\n\nvoid ed::ContextMenuAction::Reject()\n{\n    m_CandidateMenu = None;\n    m_CurrentMenu   = None;\n    m_ContextId     = ObjectId();\n}\n\nvoid ed::ContextMenuAction::ShowMetrics()\n{\n    EditorAction::ShowMetrics();\n\n    auto getMenuName = [](Menu menu)\n    {\n        switch (menu)\n        {\n            default:\n            case None:        return \"None\";\n            case Node:        return \"Node\";\n            case Pin:         return \"Pin\";\n            case Link:        return \"Link\";\n            case Background:  return \"Background\";\n        }\n    };\n\n\n    ImGui::Text(\"%s:\", GetName());\n    ImGui::Text(\"    Menu: %s\", getMenuName(m_CurrentMenu));\n}\n\nbool ed::ContextMenuAction::ShowNodeContextMenu(NodeId* nodeId)\n{\n    if (m_CurrentMenu != Node)\n        return false;\n\n    *nodeId = m_ContextId.AsNodeId();\n    Editor->SetUserContext();\n    return true;\n}\n\nbool ed::ContextMenuAction::ShowPinContextMenu(PinId* pinId)\n{\n    if (m_CurrentMenu != Pin)\n        return false;\n\n    *pinId = m_ContextId.AsPinId();\n    Editor->SetUserContext();\n    return true;\n}\n\nbool ed::ContextMenuAction::ShowLinkContextMenu(LinkId* linkId)\n{\n    if (m_CurrentMenu != Link)\n        return false;\n\n    *linkId = m_ContextId.AsLinkId();\n    Editor->SetUserContext();\n    return true;\n}\n\nbool ed::ContextMenuAction::ShowBackgroundContextMenu()\n{\n    if (m_CurrentMenu != Background)\n        return false;\n\n    Editor->SetUserContext();\n    return true;\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Cut/Copy/Paste Action\n//\n//------------------------------------------------------------------------------\ned::ShortcutAction::ShortcutAction(EditorContext* editor):\n    EditorAction(editor),\n    m_IsActive(false),\n    m_InAction(false),\n    m_CurrentAction(Action::None),\n    m_Context()\n{\n}\n\ned::EditorAction::AcceptResult ed::ShortcutAction::Accept(const Control& control)\n{\n    if (!Editor->IsFocused() || !Editor->AreShortcutsEnabled())\n        return False;\n\n    Action candidateAction = None;\n\n    auto& io = ImGui::GetIO();\n    if (io.KeyCtrl && !io.KeyShift && !io.KeyAlt && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_X)))\n        candidateAction = Cut;\n    if (io.KeyCtrl && !io.KeyShift && !io.KeyAlt && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_C)))\n        candidateAction = Copy;\n    if (io.KeyCtrl && !io.KeyShift && !io.KeyAlt && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_V)))\n        candidateAction = Paste;\n    if (io.KeyCtrl && !io.KeyShift && !io.KeyAlt && ImGui::IsKeyPressed(GetKeyIndexForD()))\n        candidateAction = Duplicate;\n    if (!io.KeyCtrl && !io.KeyShift && !io.KeyAlt && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Space)))\n        candidateAction = CreateNode;\n\n    if (candidateAction != None)\n    {\n        if (candidateAction != Paste && candidateAction != CreateNode)\n        {\n            auto& selection = Editor->GetSelectedObjects();\n            if (!selection.empty())\n            {\n                // #TODO: Find a way to simplify logic.\n\n                m_Context.assign(selection.begin(), selection.end());\n\n                // Expand groups\n                vector<Node*> extra;\n                for (auto object : m_Context)\n                {\n                    auto node = object->AsNode();\n                    if (IsGroup(node))\n                        node->GetGroupedNodes(extra, true);\n                }\n\n                // Apply groups and remove duplicates\n                if (!extra.empty())\n                {\n                    m_Context.insert(m_Context.end(), extra.begin(), extra.end());\n                    std::sort(m_Context.begin(), m_Context.end());\n                    m_Context.erase(std::unique(m_Context.begin(), m_Context.end()), m_Context.end());\n                }\n            }\n            else if (control.HotObject && control.HotObject->IsSelectable() && !IsGroup(control.HotObject->AsNode()))\n            {\n                m_Context.push_back(control.HotObject);\n            }\n\n            if (m_Context.empty())\n                return False;\n\n            // Does copying only links make sense?\n            //const auto hasOnlyLinks = std::all_of(Context.begin(), Context.end(), [](Object* object) { return object->AsLink() != nullptr; });\n            //if (hasOnlyLinks)\n            //    return False;\n\n            // If no links are selected, pick all links between nodes within context\n            const auto hasAnyLinks = std::any_of(m_Context.begin(), m_Context.end(), [](Object* object) { return object->AsLink() != nullptr; });\n            if (!hasAnyLinks && m_Context.size() > 1) // one node cannot make connection to anything\n            {\n                // Collect nodes in sorted vector viable for binary search\n                std::vector<ObjectWrapper<Node>> nodes;\n\n                nodes.reserve(m_Context.size());\n                std::for_each(m_Context.begin(), m_Context.end(), [&nodes](Object* object) { if (auto node = object->AsNode()) nodes.push_back({node->m_ID, node}); });\n\n                std::sort(nodes.begin(), nodes.end());\n\n                auto isNodeInContext = [&nodes](NodeId nodeId)\n                {\n                    return std::binary_search(nodes.begin(), nodes.end(), ObjectWrapper<Node>{nodeId, nullptr});\n                };\n\n                // Collect links connected to nodes and drop those reaching out of context\n                std::vector<Link*> links;\n\n                for (auto node : nodes)\n                    Editor->FindLinksForNode(node.m_ID, links, true);\n\n                // Remove duplicates\n                std::sort(links.begin(), links.end());\n                links.erase(std::unique(links.begin(), links.end()), links.end());\n\n                // Drop out of context links\n                links.erase(std::remove_if(links.begin(), links.end(), [&isNodeInContext](Link* link)\n                {\n                    return !isNodeInContext(link->m_StartPin->m_Node->m_ID) || !isNodeInContext(link->m_EndPin->m_Node->m_ID);\n                }), links.end());\n\n                // Append links and remove duplicates\n                m_Context.insert(m_Context.end(), links.begin(), links.end());\n            }\n        }\n        else\n            m_Context.resize(0);\n\n        m_IsActive      = true;\n        m_CurrentAction = candidateAction;\n\n        return True;\n    }\n\n    return False;\n}\n\nbool ed::ShortcutAction::Process(const Control& control)\n{\n    IM_UNUSED(control);\n\n    m_IsActive        = false;\n    m_CurrentAction   = None;\n    m_Context.resize(0);\n    return false;\n}\n\nvoid ed::ShortcutAction::Reject()\n{\n    m_IsActive        = false;\n    m_CurrentAction   = None;\n    m_Context.resize(0);\n}\n\nvoid ed::ShortcutAction::ShowMetrics()\n{\n    EditorAction::ShowMetrics();\n\n    auto getActionName = [](Action action)\n    {\n        switch (action)\n        {\n            default:\n            case None:       return \"None\";\n            case Cut:        return \"Cut\";\n            case Copy:       return \"Copy\";\n            case Paste:      return \"Paste\";\n            case Duplicate:  return \"Duplicate\";\n            case CreateNode: return \"CreateNode\";\n        }\n    };\n\n    ImGui::Text(\"%s:\", GetName());\n    ImGui::Text(\"    Action: %s\", getActionName(m_CurrentAction));\n}\n\nbool ed::ShortcutAction::Begin()\n{\n    if (m_IsActive)\n        m_InAction = true;\n    return m_IsActive;\n}\n\nvoid ed::ShortcutAction::End()\n{\n    if (m_IsActive)\n        m_InAction = false;\n}\n\nbool ed::ShortcutAction::AcceptCut()\n{\n    IM_ASSERT(m_InAction);\n    return m_CurrentAction == Cut;\n}\n\nbool ed::ShortcutAction::AcceptCopy()\n{\n    IM_ASSERT(m_InAction);\n    return m_CurrentAction == Copy;\n}\n\nbool ed::ShortcutAction::AcceptPaste()\n{\n    IM_ASSERT(m_InAction);\n    return m_CurrentAction == Paste;\n}\n\nbool ed::ShortcutAction::AcceptDuplicate()\n{\n    IM_ASSERT(m_InAction);\n    return m_CurrentAction == Duplicate;\n}\n\nbool ed::ShortcutAction::AcceptCreateNode()\n{\n    IM_ASSERT(m_InAction);\n    return m_CurrentAction == CreateNode;\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Create Item Action\n//\n//------------------------------------------------------------------------------\ned::CreateItemAction::CreateItemAction(EditorContext* editor):\n    EditorAction(editor),\n    m_InActive(false),\n    m_NextStage(None),\n    m_CurrentStage(None),\n    m_ItemType(NoItem),\n    m_UserAction(Unknown),\n    m_LinkColor(IM_COL32_WHITE),\n    m_LinkThickness(1.0f),\n    m_LinkStart(nullptr),\n    m_LinkEnd(nullptr),\n\n    m_IsActive(false),\n    m_DraggedPin(nullptr),\n\n    m_IsInGlobalSpace(false)\n{\n}\n\ned::EditorAction::AcceptResult ed::CreateItemAction::Accept(const Control& control)\n{\n    IM_ASSERT(!m_IsActive);\n\n    if (m_IsActive)\n        return EditorAction::False;\n\n    if (control.ActivePin && ImGui::IsMouseDragging(Editor->GetConfig().DragButtonIndex, 1))\n    {\n        m_DraggedPin = control.ActivePin;\n        DragStart(m_DraggedPin);\n\n        Editor->ClearSelection();\n    }\n    else if (control.HotPin)\n    {\n        return EditorAction::Possible;\n    }\n    else\n        return EditorAction::False;\n\n    m_IsActive = true;\n\n    return EditorAction::True;\n}\n\nbool ed::CreateItemAction::Process(const Control& control)\n{\n    IM_ASSERT(m_IsActive);\n\n    if (!m_IsActive)\n        return false;\n\n    if (m_DraggedPin && control.ActivePin == m_DraggedPin && (m_CurrentStage == Possible))\n    {\n        const auto draggingFromSource = (m_DraggedPin->m_Kind == PinKind::Output);\n\n        ed::Pin cursorPin(Editor, 0, draggingFromSource ? PinKind::Input : PinKind::Output);\n        cursorPin.m_Pivot    = ImRect(ImGui::GetMousePos(), ImGui::GetMousePos());\n        cursorPin.m_Dir      = -m_DraggedPin->m_Dir;\n        cursorPin.m_Strength =  m_DraggedPin->m_Strength;\n\n        ed::Link candidate(Editor, 0);\n        candidate.m_Color    = m_LinkColor;\n        candidate.m_StartPin = draggingFromSource ? m_DraggedPin : &cursorPin;\n        candidate.m_EndPin   = draggingFromSource ? &cursorPin : m_DraggedPin;\n\n        ed::Pin*& freePin  = draggingFromSource ? candidate.m_EndPin : candidate.m_StartPin;\n\n        if (control.HotPin)\n        {\n            DropPin(control.HotPin);\n\n            if (m_UserAction == UserAccept)\n                freePin = control.HotPin;\n        }\n        else if (control.BackgroundHot)\n            DropNode();\n        else\n            DropNothing();\n\n        auto drawList = Editor->GetDrawList();\n        drawList->ChannelsSetCurrent(c_LinkChannel_NewLink);\n\n        candidate.UpdateEndpoints();\n        candidate.Draw(drawList, m_LinkColor, m_LinkThickness);\n    }\n    else if (m_CurrentStage == Possible || !control.ActivePin)\n    {\n        if (!Editor->CanAcceptUserInput())\n        {\n            m_DraggedPin = nullptr;\n            DropNothing();\n        }\n\n        DragEnd();\n        m_IsActive = false;\n    }\n\n    return m_IsActive;\n}\n\nvoid ed::CreateItemAction::ShowMetrics()\n{\n    EditorAction::ShowMetrics();\n\n    auto getStageName = [](Stage stage)\n    {\n        switch (stage)\n        {\n            case None:     return \"None\";\n            case Possible: return \"Possible\";\n            case Create:   return \"Create\";\n            default:       return \"<unknown>\";\n        }\n    };\n\n    auto getActionName = [](Action action)\n    {\n        switch (action)\n        {\n            default:\n            case Unknown:     return \"Unknown\";\n            case UserReject:  return \"Reject\";\n            case UserAccept:  return \"Accept\";\n        }\n    };\n\n    auto getItemName = [](Type item)\n    {\n        switch (item)\n        {\n            default:\n            case NoItem: return \"None\";\n            case Node:   return \"Node\";\n            case Link:   return \"Link\";\n        }\n    };\n\n    ImGui::Text(\"%s:\", GetName());\n    ImGui::Text(\"    Stage: %s\", getStageName(m_CurrentStage));\n    ImGui::Text(\"    User Action: %s\", getActionName(m_UserAction));\n    ImGui::Text(\"    Item Type: %s\", getItemName(m_ItemType));\n}\n\nvoid ed::CreateItemAction::SetStyle(ImU32 color, float thickness)\n{\n    m_LinkColor     = color;\n    m_LinkThickness = thickness;\n}\n\nbool ed::CreateItemAction::Begin()\n{\n    IM_ASSERT(false == m_InActive);\n\n    m_InActive        = true;\n    m_CurrentStage    = m_NextStage;\n    m_UserAction      = Unknown;\n    m_LinkColor       = IM_COL32_WHITE;\n    m_LinkThickness   = 1.0f;\n\n    if (m_CurrentStage == None)\n        return false;\n\n    m_LastChannel = Editor->GetDrawList()->_Splitter._Current;\n\n    return true;\n}\n\nvoid ed::CreateItemAction::End()\n{\n    IM_ASSERT(m_InActive);\n\n    if (m_IsInGlobalSpace)\n    {\n        ImGui::PopClipRect();\n        Editor->Resume(SuspendFlags::KeepSplitter);\n\n        auto currentChannel = Editor->GetDrawList()->_Splitter._Current;\n        if (currentChannel != m_LastChannel)\n            Editor->GetDrawList()->ChannelsSetCurrent(m_LastChannel);\n\n        m_IsInGlobalSpace = false;\n    }\n\n    m_InActive = false;\n}\n\nvoid ed::CreateItemAction::DragStart(Pin* startPin)\n{\n    IM_ASSERT(!m_InActive);\n\n    m_NextStage = Possible;\n    m_LinkStart = startPin;\n    m_LinkEnd   = nullptr;\n}\n\nvoid ed::CreateItemAction::DragEnd()\n{\n    IM_ASSERT(!m_InActive);\n\n    if (m_CurrentStage == Possible && m_UserAction == UserAccept)\n    {\n        m_NextStage = Create;\n    }\n    else\n    {\n        m_NextStage = None;\n        m_ItemType  = NoItem;\n        m_LinkStart = nullptr;\n        m_LinkEnd   = nullptr;\n    }\n}\n\nvoid ed::CreateItemAction::DropPin(Pin* endPin)\n{\n    IM_ASSERT(!m_InActive);\n\n    m_ItemType = Link;\n    m_LinkEnd  = endPin;\n}\n\nvoid ed::CreateItemAction::DropNode()\n{\n    IM_ASSERT(!m_InActive);\n\n    m_ItemType = Node;\n    m_LinkEnd  = nullptr;\n}\n\nvoid ed::CreateItemAction::DropNothing()\n{\n    IM_ASSERT(!m_InActive);\n\n    m_ItemType = NoItem;\n    m_LinkEnd  = nullptr;\n}\n\ned::CreateItemAction::Result ed::CreateItemAction::RejectItem()\n{\n    IM_ASSERT(m_InActive);\n\n    if (!m_InActive || m_CurrentStage == None || m_ItemType == NoItem)\n        return Indeterminate;\n\n    m_UserAction = UserReject;\n\n    return True;\n}\n\ned::CreateItemAction::Result ed::CreateItemAction::AcceptItem()\n{\n    IM_ASSERT(m_InActive);\n\n    if (!m_InActive || m_CurrentStage == None || m_ItemType == NoItem)\n        return Indeterminate;\n\n    m_UserAction = UserAccept;\n\n    if (m_CurrentStage == Create)\n    {\n        m_NextStage = None;\n        m_ItemType  = NoItem;\n        m_LinkStart = nullptr;\n        m_LinkEnd   = nullptr;\n        return True;\n    }\n    else\n        return False;\n}\n\ned::CreateItemAction::Result ed::CreateItemAction::QueryLink(PinId* startId, PinId* endId)\n{\n    IM_ASSERT(m_InActive);\n\n    if (!m_InActive || m_CurrentStage == None || m_ItemType != Link)\n        return Indeterminate;\n\n    auto linkStartId = m_LinkStart->m_ID;\n    auto linkEndId   = m_LinkEnd->m_ID;\n\n    *startId = linkStartId;\n    *endId   = linkEndId;\n\n    Editor->SetUserContext(true);\n\n    if (!m_IsInGlobalSpace)\n    {\n        Editor->Suspend(SuspendFlags::KeepSplitter);\n\n        auto rect = Editor->GetRect();\n        ImGui::PushClipRect(rect.Min + ImVec2(1, 1), rect.Max - ImVec2(1, 1), false);\n        m_IsInGlobalSpace = true;\n    }\n\n    return True;\n}\n\ned::CreateItemAction::Result ed::CreateItemAction::QueryNode(PinId* pinId)\n{\n    IM_ASSERT(m_InActive);\n\n    if (!m_InActive || m_CurrentStage == None || m_ItemType != Node)\n        return Indeterminate;\n\n    *pinId = m_LinkStart ? m_LinkStart->m_ID : 0;\n\n    Editor->SetUserContext(true);\n\n    if (!m_IsInGlobalSpace)\n    {\n        Editor->Suspend(SuspendFlags::KeepSplitter);\n\n        auto rect = Editor->GetRect();\n        ImGui::PushClipRect(rect.Min + ImVec2(1, 1), rect.Max - ImVec2(1, 1), false);\n        m_IsInGlobalSpace = true;\n    }\n\n    return True;\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Delete Items Action\n//\n//------------------------------------------------------------------------------\ned::DeleteItemsAction::DeleteItemsAction(EditorContext* editor):\n    EditorAction(editor),\n    m_IsActive(false),\n    m_InInteraction(false),\n    m_CurrentItemType(Unknown),\n    m_UserAction(Undetermined)\n{\n}\n\nvoid ed::DeleteItemsAction::DeleteDeadLinks(NodeId nodeId)\n{\n    vector<ed::Link*> links;\n    Editor->FindLinksForNode(nodeId, links, true);\n    for (auto link : links)\n    {\n        link->m_DeleteOnNewFrame = true;\n\n        auto it = std::find(m_CandidateObjects.begin(), m_CandidateObjects.end(), link);\n        if (it != m_CandidateObjects.end())\n            continue;\n\n        m_CandidateObjects.push_back(link);\n    }\n}\n\nvoid ed::DeleteItemsAction::DeleteDeadPins(NodeId nodeId)\n{\n    auto node = Editor->FindNode(nodeId);\n    if (!node)\n        return;\n\n    for (auto pin = node->m_LastPin; pin; pin = pin->m_PreviousPin)\n        pin->m_DeleteOnNewFrame = true;\n}\n\ned::EditorAction::AcceptResult ed::DeleteItemsAction::Accept(const Control& control)\n{\n    IM_ASSERT(!m_IsActive);\n\n    if (m_IsActive)\n        return False;\n\n    auto& io = ImGui::GetIO();\n    if (Editor->CanAcceptUserInput() && ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Delete)) && Editor->AreShortcutsEnabled())\n    {\n        auto& selection = Editor->GetSelectedObjects();\n        if (!selection.empty())\n        {\n            m_CandidateObjects = selection;\n            m_IsActive = true;\n            return True;\n        }\n    }\n    else if (control.ClickedLink && io.KeyAlt)\n    {\n        m_CandidateObjects.clear();\n        m_CandidateObjects.push_back(control.ClickedLink);\n        m_IsActive = true;\n        return True;\n    }\n\n    else if (!m_ManuallyDeletedObjects.empty())\n    {\n        m_CandidateObjects = m_ManuallyDeletedObjects;\n        m_ManuallyDeletedObjects.clear();\n        m_IsActive = true;\n        return True;\n    }\n\n    return m_IsActive ? True : False;\n}\n\nbool ed::DeleteItemsAction::Process(const Control& control)\n{\n    IM_UNUSED(control);\n\n    if (!m_IsActive)\n        return false;\n\n    m_IsActive = false;\n    return true;\n}\n\nvoid ed::DeleteItemsAction::ShowMetrics()\n{\n    EditorAction::ShowMetrics();\n\n    //auto getObjectName = [](Object* object)\n    //{\n    //    if (!object) return \"\";\n    //    else if (object->AsNode()) return \"Node\";\n    //    else if (object->AsPin())  return \"Pin\";\n    //    else if (object->AsLink()) return \"Link\";\n    //    else return \"\";\n    //};\n\n    ImGui::Text(\"%s:\", GetName());\n    ImGui::Text(\"    Active: %s\", m_IsActive ? \"yes\" : \"no\");\n    //ImGui::Text(\"    Node: %s (%d)\", getObjectName(DeleteItemsgedNode), DeleteItemsgedNode ? DeleteItemsgedNode->ID : 0);\n}\n\nbool ed::DeleteItemsAction::Add(Object* object)\n{\n    if (Editor->GetCurrentAction() != nullptr)\n        return false;\n\n    m_ManuallyDeletedObjects.push_back(object);\n\n    return true;\n}\n\nbool ed::DeleteItemsAction::Begin()\n{\n    if (!m_IsActive)\n        return false;\n\n    IM_ASSERT(!m_InInteraction);\n    m_InInteraction = true;\n\n    m_CurrentItemType = Unknown;\n    m_UserAction      = Undetermined;\n\n    return m_IsActive;\n}\n\nvoid ed::DeleteItemsAction::End()\n{\n    if (!m_IsActive)\n        return;\n\n    IM_ASSERT(m_InInteraction);\n    m_InInteraction = false;\n}\n\nbool ed::DeleteItemsAction::QueryLink(LinkId* linkId, PinId* startId, PinId* endId)\n{\n    ObjectId objectId;\n    if (!QueryItem(&objectId, Link))\n        return false;\n\n    if (auto id = objectId.AsLinkId())\n        *linkId = id;\n    else\n        return false;\n\n    if (startId || endId)\n    {\n        auto link = Editor->FindLink(*linkId);\n        if (startId)\n            *startId = link->m_StartPin->m_ID;\n        if (endId)\n            *endId = link->m_EndPin->m_ID;\n    }\n\n    return true;\n}\n\nbool ed::DeleteItemsAction::QueryNode(NodeId* nodeId)\n{\n    ObjectId objectId;\n    if (!QueryItem(&objectId, Node))\n        return false;\n\n    if (auto id = objectId.AsNodeId())\n        *nodeId = id;\n    else\n        return false;\n\n    return true;\n}\n\nbool ed::DeleteItemsAction::QueryItem(ObjectId* itemId, IteratorType itemType)\n{\n    if (!m_InInteraction)\n        return false;\n\n    if (m_CurrentItemType != itemType)\n    {\n        m_CurrentItemType    = itemType;\n        m_CandidateItemIndex = 0;\n    }\n    else if (m_UserAction == Undetermined)\n    {\n        RejectItem();\n    }\n\n    m_UserAction = Undetermined;\n\n    auto itemCount = (int)m_CandidateObjects.size();\n    while (m_CandidateItemIndex < itemCount)\n    {\n        auto item = m_CandidateObjects[m_CandidateItemIndex];\n        if (itemType == Node)\n        {\n            if (auto node = item->AsNode())\n            {\n                *itemId = node->m_ID;\n                return true;\n            }\n        }\n        else if (itemType == Link)\n        {\n            if (auto link = item->AsLink())\n            {\n                *itemId = link->m_ID;\n                return true;\n            }\n        }\n\n        ++m_CandidateItemIndex;\n    }\n\n    if (m_CandidateItemIndex == itemCount)\n        m_CurrentItemType = Unknown;\n\n    return false;\n}\n\nbool ed::DeleteItemsAction::AcceptItem(bool deleteDependencies)\n{\n    if (!m_InInteraction)\n        return false;\n\n    m_UserAction = Accepted;\n\n    RemoveItem(deleteDependencies);\n\n    return true;\n}\n\nvoid ed::DeleteItemsAction::RejectItem()\n{\n    if (!m_InInteraction)\n        return;\n\n    m_UserAction = Rejected;\n\n    DropCurrentItem();\n}\n\nvoid ed::DeleteItemsAction::RemoveItem(bool deleteDependencies)\n{\n    auto item = DropCurrentItem();\n\n    Editor->DeselectObject(item);\n\n    Editor->RemoveSettings(item);\n\n    item->m_DeleteOnNewFrame = true;\n\n    if (deleteDependencies && m_CurrentItemType == Node)\n    {\n        auto node = item->ID().AsNodeId();\n        DeleteDeadLinks(node);\n        DeleteDeadPins(node);\n    }\n\n    if (m_CurrentItemType == Link)\n        Editor->NotifyLinkDeleted(item->AsLink());\n}\n\ned::Object* ed::DeleteItemsAction::DropCurrentItem()\n{\n    auto item = m_CandidateObjects[m_CandidateItemIndex];\n    m_CandidateObjects.erase(m_CandidateObjects.begin() + m_CandidateItemIndex);\n\n    return item;\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Node Builder\n//\n//------------------------------------------------------------------------------\ned::NodeBuilder::NodeBuilder(EditorContext* editor):\n    Editor(editor),\n    m_CurrentNode(nullptr),\n    m_CurrentPin(nullptr)\n{\n}\n\ned::NodeBuilder::~NodeBuilder()\n{\n    m_Splitter.ClearFreeMemory();\n    m_PinSplitter.ClearFreeMemory();\n}\n\nvoid ed::NodeBuilder::Begin(NodeId nodeId)\n{\n    IM_ASSERT(nullptr == m_CurrentNode);\n\n    m_CurrentNode = Editor->GetNode(nodeId);\n\n    Editor->UpdateNodeState(m_CurrentNode);\n\n    if (m_CurrentNode->m_CenterOnScreen)\n    {\n        auto bounds = Editor->GetViewRect();\n        auto offset = bounds.GetCenter() - m_CurrentNode->m_Bounds.GetCenter();\n\n        if (ImLengthSqr(offset) > 0)\n        {\n            if (::IsGroup(m_CurrentNode))\n            {\n                std::vector<Node*> groupedNodes;\n                m_CurrentNode->GetGroupedNodes(groupedNodes);\n                groupedNodes.push_back(m_CurrentNode);\n\n                for (auto node : groupedNodes)\n                {\n                    node->m_Bounds.Translate(ImFloor(offset));\n                    node->m_GroupBounds.Translate(ImFloor(offset));\n                    Editor->MakeDirty(SaveReasonFlags::Position | SaveReasonFlags::User, node);\n                }\n            }\n            else\n            {\n                m_CurrentNode->m_Bounds.Translate(ImFloor(offset));\n                m_CurrentNode->m_GroupBounds.Translate(ImFloor(offset));\n                Editor->MakeDirty(SaveReasonFlags::Position | SaveReasonFlags::User, m_CurrentNode);\n            }\n        }\n\n        m_CurrentNode->m_CenterOnScreen = false;\n    }\n\n    // Position node on screen\n    ImGui::SetCursorScreenPos(m_CurrentNode->m_Bounds.Min);\n\n    auto& editorStyle = Editor->GetStyle();\n\n    const auto alpha = ImGui::GetStyle().Alpha;\n\n    m_CurrentNode->m_IsLive           = true;\n    m_CurrentNode->m_LastPin          = nullptr;\n    m_CurrentNode->m_Color            = Editor->GetColor(StyleColor_NodeBg, alpha);\n    m_CurrentNode->m_BorderColor      = Editor->GetColor(StyleColor_NodeBorder, alpha);\n    m_CurrentNode->m_BorderWidth      = editorStyle.NodeBorderWidth;\n    m_CurrentNode->m_Rounding         = editorStyle.NodeRounding;\n    m_CurrentNode->m_GroupColor       = Editor->GetColor(StyleColor_GroupBg, alpha);\n    m_CurrentNode->m_GroupBorderColor = Editor->GetColor(StyleColor_GroupBorder, alpha);\n    m_CurrentNode->m_GroupBorderWidth = editorStyle.GroupBorderWidth;\n    m_CurrentNode->m_GroupRounding    = editorStyle.GroupRounding;\n    m_CurrentNode->m_HighlightConnectedLinks = editorStyle.HighlightConnectedLinks != 0.0f;\n\n    m_IsGroup = false;\n\n    // Grow channel list and select user channel\n    if (auto drawList = Editor->GetDrawList())\n    {\n        m_CurrentNode->m_Channel = drawList->_Splitter._Count;\n        ImDrawList_ChannelsGrow(drawList, drawList->_Splitter._Count + c_ChannelsPerNode);\n        drawList->ChannelsSetCurrent(m_CurrentNode->m_Channel + c_NodeContentChannel);\n\n        m_Splitter.Clear();\n        ImDrawList_SwapSplitter(drawList, m_Splitter);\n    }\n\n    // Begin outer group\n    ImGui::BeginGroup();\n\n    // Apply frame padding. Begin inner group if necessary.\n    if (editorStyle.NodePadding.x != 0 || editorStyle.NodePadding.y != 0 || editorStyle.NodePadding.z != 0 || editorStyle.NodePadding.w != 0)\n    {\n        ImGui::SetCursorPos(ImGui::GetCursorPos() + ImVec2(editorStyle.NodePadding.x, editorStyle.NodePadding.y));\n        ImGui::BeginGroup();\n    }\n}\n\nvoid ed::NodeBuilder::End()\n{\n    IM_ASSERT(nullptr != m_CurrentNode);\n\n    if (auto drawList = Editor->GetDrawList())\n    {\n        IM_ASSERT(drawList->_Splitter._Count == 1); // Did you forgot to call drawList->ChannelsMerge()?\n        ImDrawList_SwapSplitter(drawList, m_Splitter);\n    }\n\n    // Apply frame padding. This must be done in this convoluted way if outer group\n    // size must contain inner group padding.\n    auto& editorStyle = Editor->GetStyle();\n    if (editorStyle.NodePadding.x != 0 || editorStyle.NodePadding.y != 0 || editorStyle.NodePadding.z != 0 || editorStyle.NodePadding.w != 0)\n    {\n        ImGui::EndGroup();\n        ImGui::SameLine(0, editorStyle.NodePadding.z);\n        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));\n        ImGui::Dummy(ImVec2(0, 0)); // bump cursor at the end of the line and move to next one\n        ImGui::Dummy(ImVec2(0, editorStyle.NodePadding.w)); // apply padding\n        ImGui::PopStyleVar();\n    }\n\n    // End outer group.\n    ImGui::EndGroup();\n\n    m_NodeRect = ImGui_GetItemRect();\n    m_NodeRect.Floor();\n\n    if (m_CurrentNode->m_Bounds.GetSize() != m_NodeRect.GetSize())\n    {\n        m_CurrentNode->m_Bounds.Max = m_CurrentNode->m_Bounds.Min + m_NodeRect.GetSize();\n        Editor->MakeDirty(SaveReasonFlags::Size, m_CurrentNode);\n    }\n\n    if (m_IsGroup)\n    {\n        // Groups cannot have pins. Discard them.\n        for (auto pin = m_CurrentNode->m_LastPin; pin; pin = pin->m_PreviousPin)\n            pin->Reset();\n\n        m_CurrentNode->m_Type        = NodeType::Group;\n        m_CurrentNode->m_GroupBounds = m_GroupBounds;\n        m_CurrentNode->m_LastPin     = nullptr;\n    }\n    else\n        m_CurrentNode->m_Type        = NodeType::Node;\n\n    m_CurrentNode = nullptr;\n}\n\nvoid ed::NodeBuilder::BeginPin(PinId pinId, PinKind kind)\n{\n    IM_ASSERT(nullptr != m_CurrentNode);\n    IM_ASSERT(nullptr == m_CurrentPin);\n    IM_ASSERT(false   == m_IsGroup);\n\n    auto& editorStyle = Editor->GetStyle();\n\n    m_CurrentPin = Editor->GetPin(pinId, kind);\n    m_CurrentPin->m_Node = m_CurrentNode;\n\n    m_CurrentPin->m_IsLive      = true;\n    m_CurrentPin->m_Color       = Editor->GetColor(StyleColor_PinRect);\n    m_CurrentPin->m_BorderColor = Editor->GetColor(StyleColor_PinRectBorder);\n    m_CurrentPin->m_BorderWidth = editorStyle.PinBorderWidth;\n    m_CurrentPin->m_Rounding    = editorStyle.PinRounding;\n    m_CurrentPin->m_Corners     = static_cast<int>(editorStyle.PinCorners);\n    m_CurrentPin->m_Radius      = editorStyle.PinRadius;\n    m_CurrentPin->m_ArrowSize   = editorStyle.PinArrowSize;\n    m_CurrentPin->m_ArrowWidth  = editorStyle.PinArrowWidth;\n    m_CurrentPin->m_Dir         = kind == PinKind::Output ? editorStyle.SourceDirection : editorStyle.TargetDirection;\n    m_CurrentPin->m_Strength    = editorStyle.LinkStrength;\n    m_CurrentPin->m_SnapLinkToDir = editorStyle.SnapLinkToPinDir != 0.0f;\n\n    m_CurrentPin->m_PreviousPin = m_CurrentNode->m_LastPin;\n    m_CurrentNode->m_LastPin    = m_CurrentPin;\n\n    m_PivotAlignment          = editorStyle.PivotAlignment;\n    m_PivotSize               = editorStyle.PivotSize;\n    m_PivotScale              = editorStyle.PivotScale;\n    m_ResolvePinRect          = true;\n    m_ResolvePivot            = true;\n\n    if (auto drawList = Editor->GetDrawList())\n    {\n        m_PinSplitter.Clear();\n        ImDrawList_SwapSplitter(drawList, m_PinSplitter);\n    }\n\n    ImGui::BeginGroup();\n}\n\nvoid ed::NodeBuilder::EndPin()\n{\n    IM_ASSERT(nullptr != m_CurrentPin);\n\n    if (auto drawList = Editor->GetDrawList())\n    {\n        IM_ASSERT(drawList->_Splitter._Count == 1); // Did you forgot to call drawList->ChannelsMerge()?\n        ImDrawList_SwapSplitter(drawList, m_PinSplitter);\n    }\n\n    ImGui::EndGroup();\n\n    if (m_ResolvePinRect)\n        m_CurrentPin->m_Bounds = ImGui_GetItemRect();\n\n    if (m_ResolvePivot)\n    {\n        auto& pinRect = m_CurrentPin->m_Bounds;\n\n        if (m_PivotSize.x < 0)\n            m_PivotSize.x = pinRect.GetWidth();\n        if (m_PivotSize.y < 0)\n            m_PivotSize.y = pinRect.GetHeight();\n\n        m_CurrentPin->m_Pivot.Min = pinRect.Min + ImMul(pinRect.GetSize(), m_PivotAlignment);\n        m_CurrentPin->m_Pivot.Max = m_CurrentPin->m_Pivot.Min + ImMul(m_PivotSize, m_PivotScale);\n    }\n\n    // #debug: Draw pin bounds\n    //Editor->GetDrawList()->AddRect(m_CurrentPin->m_Bounds.Min, m_CurrentPin->m_Bounds.Max, IM_COL32(255, 255, 0, 255));\n\n    // #debug: Draw pin pivot rectangle\n    //Editor->GetDrawList()->AddRect(m_CurrentPin->m_Pivot.Min, m_CurrentPin->m_Pivot.Max, IM_COL32(255, 0, 255, 255));\n\n    m_CurrentPin = nullptr;\n}\n\nvoid ed::NodeBuilder::PinRect(const ImVec2& a, const ImVec2& b)\n{\n    IM_ASSERT(nullptr != m_CurrentPin);\n\n    m_CurrentPin->m_Bounds = ImRect(a, b);\n    m_CurrentPin->m_Bounds.Floor();\n    m_ResolvePinRect     = false;\n}\n\nvoid ed::NodeBuilder::PinPivotRect(const ImVec2& a, const ImVec2& b)\n{\n    IM_ASSERT(nullptr != m_CurrentPin);\n\n    m_CurrentPin->m_Pivot = ImRect(a, b);\n    m_ResolvePivot      = false;\n}\n\nvoid ed::NodeBuilder::PinPivotSize(const ImVec2& size)\n{\n    IM_ASSERT(nullptr != m_CurrentPin);\n\n    m_PivotSize    = size;\n    m_ResolvePivot = true;\n}\n\nvoid ed::NodeBuilder::PinPivotScale(const ImVec2& scale)\n{\n    IM_ASSERT(nullptr != m_CurrentPin);\n\n    m_PivotScale   = scale;\n    m_ResolvePivot = true;\n}\n\nvoid ed::NodeBuilder::PinPivotAlignment(const ImVec2& alignment)\n{\n    IM_ASSERT(nullptr != m_CurrentPin);\n\n    m_PivotAlignment = alignment;\n    m_ResolvePivot   = true;\n}\n\nvoid ed::NodeBuilder::Group(const ImVec2& size)\n{\n    IM_ASSERT(nullptr != m_CurrentNode);\n    IM_ASSERT(nullptr == m_CurrentPin);\n    IM_ASSERT(false   == m_IsGroup);\n\n    m_IsGroup = true;\n\n    if (IsGroup(m_CurrentNode))\n        ImGui::Dummy(m_CurrentNode->m_GroupBounds.GetSize());\n    else\n        ImGui::Dummy(size);\n\n    m_GroupBounds = ImGui_GetItemRect();\n    m_GroupBounds.Floor();\n}\n\nImDrawList* ed::NodeBuilder::GetUserBackgroundDrawList() const\n{\n    return GetUserBackgroundDrawList(m_CurrentNode);\n}\n\nImDrawList* ed::NodeBuilder::GetUserBackgroundDrawList(Node* node) const\n{\n    if (node && node->m_IsLive)\n    {\n        auto drawList = Editor->GetDrawList();\n        drawList->ChannelsSetCurrent(node->m_Channel + c_NodeUserBackgroundChannel);\n        return drawList;\n    }\n    else\n        return nullptr;\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Node Builder\n//\n//------------------------------------------------------------------------------\ned::HintBuilder::HintBuilder(EditorContext* editor):\n    Editor(editor),\n    m_IsActive(false),\n    m_CurrentNode(nullptr)\n{\n}\n\nbool ed::HintBuilder::Begin(NodeId nodeId)\n{\n    IM_ASSERT(nullptr == m_CurrentNode);\n\n    auto& view = Editor->GetView();\n    auto& rect = Editor->GetRect();\n\n    const float c_min_zoom = 0.75f;\n    const float c_max_zoom = 0.50f;\n\n    if (view.Scale > 0.75f)\n        return false;\n\n    auto node = Editor->FindNode(nodeId);\n    if (!IsGroup(node))\n        return false;\n\n    m_CurrentNode = node;\n\n    m_LastChannel = Editor->GetDrawList()->_Splitter._Current;\n\n    Editor->Suspend(SuspendFlags::KeepSplitter);\n\n    const auto alpha = ImMax(0.0f, std::min(1.0f, (view.Scale - c_min_zoom) / (c_max_zoom - c_min_zoom)));\n\n    Editor->GetDrawList()->ChannelsSetCurrent(c_UserChannel_HintsBackground);\n    ImGui::PushClipRect(rect.Min + ImVec2(1, 1), rect.Max - ImVec2(1, 1), false);\n\n    Editor->GetDrawList()->ChannelsSetCurrent(c_UserChannel_Hints);\n    ImGui::PushClipRect(rect.Min + ImVec2(1, 1), rect.Max - ImVec2(1, 1), false);\n\n    ImGui::PushStyleVar(ImGuiStyleVar_Alpha, alpha);\n\n    m_IsActive = true;\n\n    return true;\n}\n\nvoid ed::HintBuilder::End()\n{\n    if (!m_IsActive)\n        return;\n\n    ImGui::PopStyleVar();\n\n    Editor->GetDrawList()->ChannelsSetCurrent(c_UserChannel_Hints);\n    ImGui::PopClipRect();\n\n    Editor->GetDrawList()->ChannelsSetCurrent(c_UserChannel_HintsBackground);\n    ImGui::PopClipRect();\n\n    Editor->GetDrawList()->ChannelsSetCurrent(m_LastChannel);\n\n    Editor->Resume(SuspendFlags::KeepSplitter);\n\n    m_IsActive    = false;\n    m_CurrentNode = nullptr;\n}\n\nImVec2 ed::HintBuilder::GetGroupMin()\n{\n    IM_ASSERT(nullptr != m_CurrentNode);\n\n    return Editor->ToScreen(m_CurrentNode->m_Bounds.Min);\n}\n\nImVec2 ed::HintBuilder::GetGroupMax()\n{\n    IM_ASSERT(nullptr != m_CurrentNode);\n\n    return Editor->ToScreen(m_CurrentNode->m_Bounds.Max);\n}\n\nImDrawList* ed::HintBuilder::GetForegroundDrawList()\n{\n    IM_ASSERT(nullptr != m_CurrentNode);\n\n    auto drawList = Editor->GetDrawList();\n\n    drawList->ChannelsSetCurrent(c_UserChannel_Hints);\n\n    return drawList;\n}\n\nImDrawList* ed::HintBuilder::GetBackgroundDrawList()\n{\n    IM_ASSERT(nullptr != m_CurrentNode);\n\n    auto drawList = Editor->GetDrawList();\n\n    drawList->ChannelsSetCurrent(c_UserChannel_HintsBackground);\n\n    return drawList;\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Style\n//\n//------------------------------------------------------------------------------\nvoid ed::Style::PushColor(StyleColor colorIndex, const ImVec4& color)\n{\n    ColorModifier modifier;\n    modifier.Index = colorIndex;\n    modifier.Value = Colors[colorIndex];\n    m_ColorStack.push_back(modifier);\n    Colors[colorIndex] = color;\n}\n\nvoid ed::Style::PopColor(int count)\n{\n    while (count > 0)\n    {\n        auto& modifier = m_ColorStack.back();\n        Colors[modifier.Index] = modifier.Value;\n        m_ColorStack.pop_back();\n        --count;\n    }\n}\n\nvoid ed::Style::PushVar(StyleVar varIndex, float value)\n{\n    auto* var = GetVarFloatAddr(varIndex);\n    IM_ASSERT(var != nullptr);\n    VarModifier modifier;\n    modifier.Index = varIndex;\n    modifier.Value = ImVec4(*var, 0, 0, 0);\n    *var = value;\n    m_VarStack.push_back(modifier);\n}\n\nvoid ed::Style::PushVar(StyleVar varIndex, const ImVec2& value)\n{\n    auto* var = GetVarVec2Addr(varIndex);\n    IM_ASSERT(var != nullptr);\n    VarModifier modifier;\n    modifier.Index = varIndex;\n    modifier.Value = ImVec4(var->x, var->y, 0, 0);\n    *var = value;\n    m_VarStack.push_back(modifier);\n}\n\nvoid ed::Style::PushVar(StyleVar varIndex, const ImVec4& value)\n{\n    auto* var = GetVarVec4Addr(varIndex);\n    IM_ASSERT(var != nullptr);\n    VarModifier modifier;\n    modifier.Index = varIndex;\n    modifier.Value = *var;\n    *var = value;\n    m_VarStack.push_back(modifier);\n}\n\nvoid ed::Style::PopVar(int count)\n{\n    while (count > 0)\n    {\n        auto& modifier = m_VarStack.back();\n        if (auto floatValue = GetVarFloatAddr(modifier.Index))\n            *floatValue = modifier.Value.x;\n        else if (auto vec2Value = GetVarVec2Addr(modifier.Index))\n            *vec2Value = ImVec2(modifier.Value.x, modifier.Value.y);\n        else if (auto vec4Value = GetVarVec4Addr(modifier.Index))\n            *vec4Value = modifier.Value;\n        m_VarStack.pop_back();\n        --count;\n    }\n}\n\nconst char* ed::Style::GetColorName(StyleColor colorIndex) const\n{\n    switch (colorIndex)\n    {\n        case StyleColor_Bg: return \"Bg\";\n        case StyleColor_Grid: return \"Grid\";\n        case StyleColor_NodeBg: return \"NodeBg\";\n        case StyleColor_NodeBorder: return \"NodeBorder\";\n        case StyleColor_HovNodeBorder: return \"HoveredNodeBorder\";\n        case StyleColor_SelNodeBorder: return \"SelNodeBorder\";\n        case StyleColor_NodeSelRect: return \"NodeSelRect\";\n        case StyleColor_NodeSelRectBorder: return \"NodeSelRectBorder\";\n        case StyleColor_HovLinkBorder: return \"HoveredLinkBorder\";\n        case StyleColor_SelLinkBorder: return \"SelLinkBorder\";\n        case StyleColor_HighlightLinkBorder: return \"HighlightLinkBorder\";\n        case StyleColor_LinkSelRect: return \"LinkSelRect\";\n        case StyleColor_LinkSelRectBorder: return \"LinkSelRectBorder\";\n        case StyleColor_PinRect: return \"PinRect\";\n        case StyleColor_PinRectBorder: return \"PinRectBorder\";\n        case StyleColor_Flow: return \"Flow\";\n        case StyleColor_FlowMarker: return \"FlowMarker\";\n        case StyleColor_GroupBg: return \"GroupBg\";\n        case StyleColor_GroupBorder: return \"GroupBorder\";\n        case StyleColor_Count: break;\n    }\n\n    IM_ASSERT(0);\n    return \"Unknown\";\n}\n\nfloat* ed::Style::GetVarFloatAddr(StyleVar idx)\n{\n    switch (idx)\n    {\n        case StyleVar_NodeRounding:             return &NodeRounding;\n        case StyleVar_NodeBorderWidth:          return &NodeBorderWidth;\n        case StyleVar_HoveredNodeBorderWidth:   return &HoveredNodeBorderWidth;\n        case StyleVar_SelectedNodeBorderWidth:  return &SelectedNodeBorderWidth;\n        case StyleVar_PinRounding:              return &PinRounding;\n        case StyleVar_PinBorderWidth:           return &PinBorderWidth;\n        case StyleVar_LinkStrength:             return &LinkStrength;\n        case StyleVar_ScrollDuration:           return &ScrollDuration;\n        case StyleVar_FlowMarkerDistance:       return &FlowMarkerDistance;\n        case StyleVar_FlowSpeed:                return &FlowSpeed;\n        case StyleVar_FlowDuration:             return &FlowDuration;\n        case StyleVar_PinCorners:               return &PinCorners;\n        case StyleVar_PinRadius:                return &PinRadius;\n        case StyleVar_PinArrowSize:             return &PinArrowSize;\n        case StyleVar_PinArrowWidth:            return &PinArrowWidth;\n        case StyleVar_GroupRounding:            return &GroupRounding;\n        case StyleVar_GroupBorderWidth:         return &GroupBorderWidth;\n        case StyleVar_HighlightConnectedLinks:  return &HighlightConnectedLinks;\n        case StyleVar_SnapLinkToPinDir:         return &SnapLinkToPinDir;\n        case StyleVar_HoveredNodeBorderOffset:  return &HoverNodeBorderOffset;\n        case StyleVar_SelectedNodeBorderOffset: return &SelectedNodeBorderOffset;\n        default:                                return nullptr;\n    }\n}\n\nImVec2* ed::Style::GetVarVec2Addr(StyleVar idx)\n{\n    switch (idx)\n    {\n        case StyleVar_SourceDirection:  return &SourceDirection;\n        case StyleVar_TargetDirection:  return &TargetDirection;\n        case StyleVar_PivotAlignment:   return &PivotAlignment;\n        case StyleVar_PivotSize:        return &PivotSize;\n        case StyleVar_PivotScale:       return &PivotScale;\n        default:                        return nullptr;\n    }\n}\n\nImVec4* ed::Style::GetVarVec4Addr(StyleVar idx)\n{\n    switch (idx)\n    {\n        case StyleVar_NodePadding:  return &NodePadding;\n        default:                    return nullptr;\n    }\n}\n\n\n\n\n//------------------------------------------------------------------------------\n//\n// Config\n//\n//------------------------------------------------------------------------------\ned::Config::Config(const ax::NodeEditor::Config* config)\n{\n    if (config)\n        *static_cast<ax::NodeEditor::Config*>(this) = *config;\n}\n\nstd::string ed::Config::Load()\n{\n    std::string data;\n\n    if (LoadSettings)\n    {\n        const auto size = LoadSettings(nullptr, UserPointer);\n        if (size > 0)\n        {\n            data.resize(size);\n            LoadSettings(const_cast<char*>(data.data()), UserPointer);\n        }\n    }\n    else if (SettingsFile)\n    {\n        std::ifstream file(SettingsFile);\n        if (file)\n        {\n            file.seekg(0, std::ios_base::end);\n            auto size = static_cast<size_t>(file.tellg());\n            file.seekg(0, std::ios_base::beg);\n\n            data.reserve(size);\n            data.assign(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());\n        }\n    }\n\n    return data;\n}\n\nstd::string ed::Config::LoadNode(NodeId nodeId)\n{\n    std::string data;\n\n    if (LoadNodeSettings)\n    {\n        const auto size = LoadNodeSettings(nodeId, nullptr, UserPointer);\n        if (size > 0)\n        {\n            data.resize(size);\n            LoadNodeSettings(nodeId, const_cast<char*>(data.data()), UserPointer);\n        }\n    }\n\n    return data;\n}\n\nvoid ed::Config::BeginSave()\n{\n    if (BeginSaveSession)\n        BeginSaveSession(UserPointer);\n}\n\nbool ed::Config::Save(const std::string& data, SaveReasonFlags flags)\n{\n    if (SaveSettings)\n    {\n        return SaveSettings(data.c_str(), data.size(), flags, UserPointer);\n    }\n    else if (SettingsFile)\n    {\n        std::ofstream settingsFile(SettingsFile);\n        if (settingsFile)\n            settingsFile << data;\n\n        return !!settingsFile;\n    }\n\n    return false;\n}\n\nbool ed::Config::SaveNode(NodeId nodeId, const std::string& data, SaveReasonFlags flags)\n{\n    if (SaveNodeSettings)\n        return SaveNodeSettings(nodeId, data.c_str(), data.size(), flags, UserPointer);\n\n    return false;\n}\n\nvoid ed::Config::EndSave()\n{\n    if (EndSaveSession)\n        EndSaveSession(UserPointer);\n}\n"
        },
        {
          "name": "imgui_node_editor.h",
          "type": "blob",
          "size": 19.5751953125,
          "content": "//------------------------------------------------------------------------------\n// VERSION 0.9.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n//------------------------------------------------------------------------------\n# ifndef __IMGUI_NODE_EDITOR_H__\n# define __IMGUI_NODE_EDITOR_H__\n# pragma once\n\n\n//------------------------------------------------------------------------------\n# include <imgui.h>\n# include <cstdint> // std::uintXX_t\n# include <utility> // std::move\n\n\n//------------------------------------------------------------------------------\n# define IMGUI_NODE_EDITOR_VERSION      \"0.9.4\"\n# define IMGUI_NODE_EDITOR_VERSION_NUM  000904\n\n\n//------------------------------------------------------------------------------\n#ifndef IMGUI_NODE_EDITOR_API\n#define IMGUI_NODE_EDITOR_API\n#endif\n\n\n//------------------------------------------------------------------------------\nnamespace ax {\nnamespace NodeEditor {\n\n\n//------------------------------------------------------------------------------\nstruct NodeId;\nstruct LinkId;\nstruct PinId;\n\n\n//------------------------------------------------------------------------------\nenum class PinKind\n{\n    Input,\n    Output\n};\n\nenum class FlowDirection\n{\n    Forward,\n    Backward\n};\n\nenum class CanvasSizeMode\n{\n    FitVerticalView,        // Previous view will be scaled to fit new view on Y axis\n    FitHorizontalView,      // Previous view will be scaled to fit new view on X axis\n    CenterOnly,             // Previous view will be centered on new view\n};\n\n\n//------------------------------------------------------------------------------\nenum class SaveReasonFlags: uint32_t\n{\n    None       = 0x00000000,\n    Navigation = 0x00000001,\n    Position   = 0x00000002,\n    Size       = 0x00000004,\n    Selection  = 0x00000008,\n    AddNode    = 0x00000010,\n    RemoveNode = 0x00000020,\n    User       = 0x00000040\n};\n\ninline SaveReasonFlags operator |(SaveReasonFlags lhs, SaveReasonFlags rhs) { return static_cast<SaveReasonFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs)); }\ninline SaveReasonFlags operator &(SaveReasonFlags lhs, SaveReasonFlags rhs) { return static_cast<SaveReasonFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs)); }\n\nusing ConfigSaveSettings     = bool   (*)(const char* data, size_t size, SaveReasonFlags reason, void* userPointer);\nusing ConfigLoadSettings     = size_t (*)(char* data, void* userPointer);\n\nusing ConfigSaveNodeSettings = bool   (*)(NodeId nodeId, const char* data, size_t size, SaveReasonFlags reason, void* userPointer);\nusing ConfigLoadNodeSettings = size_t (*)(NodeId nodeId, char* data, void* userPointer);\n\nusing ConfigSession          = void   (*)(void* userPointer);\n\nstruct Config\n{\n    using CanvasSizeModeAlias = ax::NodeEditor::CanvasSizeMode;\n\n    const char*             SettingsFile;\n    ConfigSession           BeginSaveSession;\n    ConfigSession           EndSaveSession;\n    ConfigSaveSettings      SaveSettings;\n    ConfigLoadSettings      LoadSettings;\n    ConfigSaveNodeSettings  SaveNodeSettings;\n    ConfigLoadNodeSettings  LoadNodeSettings;\n    void*                   UserPointer;\n    ImVector<float>         CustomZoomLevels;\n    CanvasSizeModeAlias     CanvasSizeMode;\n    int                     DragButtonIndex;        // Mouse button index drag action will react to (0-left, 1-right, 2-middle)\n    int                     SelectButtonIndex;      // Mouse button index select action will react to (0-left, 1-right, 2-middle)\n    int                     NavigateButtonIndex;    // Mouse button index navigate action will react to (0-left, 1-right, 2-middle)\n    int                     ContextMenuButtonIndex; // Mouse button index context menu action will react to (0-left, 1-right, 2-middle)\n    bool                    EnableSmoothZoom;\n    float                   SmoothZoomPower;\n\n    Config()\n        : SettingsFile(\"NodeEditor.json\")\n        , BeginSaveSession(nullptr)\n        , EndSaveSession(nullptr)\n        , SaveSettings(nullptr)\n        , LoadSettings(nullptr)\n        , SaveNodeSettings(nullptr)\n        , LoadNodeSettings(nullptr)\n        , UserPointer(nullptr)\n        , CustomZoomLevels()\n        , CanvasSizeMode(CanvasSizeModeAlias::FitVerticalView)\n        , DragButtonIndex(0)\n        , SelectButtonIndex(0)\n        , NavigateButtonIndex(1)\n        , ContextMenuButtonIndex(1)\n        , EnableSmoothZoom(false)\n# ifdef __APPLE__\n        , SmoothZoomPower(1.1f)\n# else\n        , SmoothZoomPower(1.3f)\n# endif\n    {\n    }\n};\n\n\n//------------------------------------------------------------------------------\nenum StyleColor\n{\n    StyleColor_Bg,\n    StyleColor_Grid,\n    StyleColor_NodeBg,\n    StyleColor_NodeBorder,\n    StyleColor_HovNodeBorder,\n    StyleColor_SelNodeBorder,\n    StyleColor_NodeSelRect,\n    StyleColor_NodeSelRectBorder,\n    StyleColor_HovLinkBorder,\n    StyleColor_SelLinkBorder,\n    StyleColor_HighlightLinkBorder,\n    StyleColor_LinkSelRect,\n    StyleColor_LinkSelRectBorder,\n    StyleColor_PinRect,\n    StyleColor_PinRectBorder,\n    StyleColor_Flow,\n    StyleColor_FlowMarker,\n    StyleColor_GroupBg,\n    StyleColor_GroupBorder,\n\n    StyleColor_Count\n};\n\nenum StyleVar\n{\n    StyleVar_NodePadding,\n    StyleVar_NodeRounding,\n    StyleVar_NodeBorderWidth,\n    StyleVar_HoveredNodeBorderWidth,\n    StyleVar_SelectedNodeBorderWidth,\n    StyleVar_PinRounding,\n    StyleVar_PinBorderWidth,\n    StyleVar_LinkStrength,\n    StyleVar_SourceDirection,\n    StyleVar_TargetDirection,\n    StyleVar_ScrollDuration,\n    StyleVar_FlowMarkerDistance,\n    StyleVar_FlowSpeed,\n    StyleVar_FlowDuration,\n    StyleVar_PivotAlignment,\n    StyleVar_PivotSize,\n    StyleVar_PivotScale,\n    StyleVar_PinCorners,\n    StyleVar_PinRadius,\n    StyleVar_PinArrowSize,\n    StyleVar_PinArrowWidth,\n    StyleVar_GroupRounding,\n    StyleVar_GroupBorderWidth,\n    StyleVar_HighlightConnectedLinks,\n    StyleVar_SnapLinkToPinDir,\n    StyleVar_HoveredNodeBorderOffset,\n    StyleVar_SelectedNodeBorderOffset,\n\n    StyleVar_Count\n};\n\nstruct Style\n{\n    ImVec4  NodePadding;\n    float   NodeRounding;\n    float   NodeBorderWidth;\n    float   HoveredNodeBorderWidth;\n    float   HoverNodeBorderOffset;\n    float   SelectedNodeBorderWidth;\n    float   SelectedNodeBorderOffset;\n    float   PinRounding;\n    float   PinBorderWidth;\n    float   LinkStrength;\n    ImVec2  SourceDirection;\n    ImVec2  TargetDirection;\n    float   ScrollDuration;\n    float   FlowMarkerDistance;\n    float   FlowSpeed;\n    float   FlowDuration;\n    ImVec2  PivotAlignment;\n    ImVec2  PivotSize;\n    ImVec2  PivotScale;\n    float   PinCorners;\n    float   PinRadius;\n    float   PinArrowSize;\n    float   PinArrowWidth;\n    float   GroupRounding;\n    float   GroupBorderWidth;\n    float   HighlightConnectedLinks;\n    float   SnapLinkToPinDir; // when true link will start on the line defined by pin direction\n    ImVec4  Colors[StyleColor_Count];\n\n    Style()\n    {\n        NodePadding              = ImVec4(8, 8, 8, 8);\n        NodeRounding             = 12.0f;\n        NodeBorderWidth          = 1.5f;\n        HoveredNodeBorderWidth   = 3.5f;\n        HoverNodeBorderOffset    = 0.0f;\n        SelectedNodeBorderWidth  = 3.5f;\n        SelectedNodeBorderOffset = 0.0f;\n        PinRounding              = 4.0f;\n        PinBorderWidth           = 0.0f;\n        LinkStrength             = 100.0f;\n        SourceDirection          = ImVec2(1.0f, 0.0f);\n        TargetDirection          = ImVec2(-1.0f, 0.0f);\n        ScrollDuration           = 0.35f;\n        FlowMarkerDistance       = 30.0f;\n        FlowSpeed                = 150.0f;\n        FlowDuration             = 2.0f;\n        PivotAlignment           = ImVec2(0.5f, 0.5f);\n        PivotSize                = ImVec2(0.0f, 0.0f);\n        PivotScale               = ImVec2(1, 1);\n#if IMGUI_VERSION_NUM > 18101\n        PinCorners               = ImDrawFlags_RoundCornersAll;\n#else\n        PinCorners               = ImDrawCornerFlags_All;\n#endif\n        PinRadius                = 0.0f;\n        PinArrowSize             = 0.0f;\n        PinArrowWidth            = 0.0f;\n        GroupRounding            = 6.0f;\n        GroupBorderWidth         = 1.0f;\n        HighlightConnectedLinks  = 0.0f;\n        SnapLinkToPinDir         = 0.0f;\n\n        Colors[StyleColor_Bg]                 = ImColor( 60,  60,  70, 200);\n        Colors[StyleColor_Grid]               = ImColor(120, 120, 120,  40);\n        Colors[StyleColor_NodeBg]             = ImColor( 32,  32,  32, 200);\n        Colors[StyleColor_NodeBorder]         = ImColor(255, 255, 255,  96);\n        Colors[StyleColor_HovNodeBorder]      = ImColor( 50, 176, 255, 255);\n        Colors[StyleColor_SelNodeBorder]      = ImColor(255, 176,  50, 255);\n        Colors[StyleColor_NodeSelRect]        = ImColor(  5, 130, 255,  64);\n        Colors[StyleColor_NodeSelRectBorder]  = ImColor(  5, 130, 255, 128);\n        Colors[StyleColor_HovLinkBorder]      = ImColor( 50, 176, 255, 255);\n        Colors[StyleColor_SelLinkBorder]      = ImColor(255, 176,  50, 255);\n        Colors[StyleColor_HighlightLinkBorder]= ImColor(204, 105,   0, 255);\n        Colors[StyleColor_LinkSelRect]        = ImColor(  5, 130, 255,  64);\n        Colors[StyleColor_LinkSelRectBorder]  = ImColor(  5, 130, 255, 128);\n        Colors[StyleColor_PinRect]            = ImColor( 60, 180, 255, 100);\n        Colors[StyleColor_PinRectBorder]      = ImColor( 60, 180, 255, 128);\n        Colors[StyleColor_Flow]               = ImColor(255, 128,  64, 255);\n        Colors[StyleColor_FlowMarker]         = ImColor(255, 128,  64, 255);\n        Colors[StyleColor_GroupBg]            = ImColor(  0,   0,   0, 160);\n        Colors[StyleColor_GroupBorder]        = ImColor(255, 255, 255,  32);\n    }\n};\n\n\n//------------------------------------------------------------------------------\nstruct EditorContext;\n\n\n//------------------------------------------------------------------------------\nIMGUI_NODE_EDITOR_API void SetCurrentEditor(EditorContext* ctx);\nIMGUI_NODE_EDITOR_API EditorContext* GetCurrentEditor();\nIMGUI_NODE_EDITOR_API EditorContext* CreateEditor(const Config* config = nullptr);\nIMGUI_NODE_EDITOR_API void DestroyEditor(EditorContext* ctx);\nIMGUI_NODE_EDITOR_API const Config& GetConfig(EditorContext* ctx = nullptr);\n\nIMGUI_NODE_EDITOR_API Style& GetStyle();\nIMGUI_NODE_EDITOR_API const char* GetStyleColorName(StyleColor colorIndex);\n\nIMGUI_NODE_EDITOR_API void PushStyleColor(StyleColor colorIndex, const ImVec4& color);\nIMGUI_NODE_EDITOR_API void PopStyleColor(int count = 1);\n\nIMGUI_NODE_EDITOR_API void PushStyleVar(StyleVar varIndex, float value);\nIMGUI_NODE_EDITOR_API void PushStyleVar(StyleVar varIndex, const ImVec2& value);\nIMGUI_NODE_EDITOR_API void PushStyleVar(StyleVar varIndex, const ImVec4& value);\nIMGUI_NODE_EDITOR_API void PopStyleVar(int count = 1);\n\nIMGUI_NODE_EDITOR_API void Begin(const char* id, const ImVec2& size = ImVec2(0, 0));\nIMGUI_NODE_EDITOR_API void End();\n\nIMGUI_NODE_EDITOR_API void BeginNode(NodeId id);\nIMGUI_NODE_EDITOR_API void BeginPin(PinId id, PinKind kind);\nIMGUI_NODE_EDITOR_API void PinRect(const ImVec2& a, const ImVec2& b);\nIMGUI_NODE_EDITOR_API void PinPivotRect(const ImVec2& a, const ImVec2& b);\nIMGUI_NODE_EDITOR_API void PinPivotSize(const ImVec2& size);\nIMGUI_NODE_EDITOR_API void PinPivotScale(const ImVec2& scale);\nIMGUI_NODE_EDITOR_API void PinPivotAlignment(const ImVec2& alignment);\nIMGUI_NODE_EDITOR_API void EndPin();\nIMGUI_NODE_EDITOR_API void Group(const ImVec2& size);\nIMGUI_NODE_EDITOR_API void EndNode();\n\nIMGUI_NODE_EDITOR_API bool BeginGroupHint(NodeId nodeId);\nIMGUI_NODE_EDITOR_API ImVec2 GetGroupMin();\nIMGUI_NODE_EDITOR_API ImVec2 GetGroupMax();\nIMGUI_NODE_EDITOR_API ImDrawList* GetHintForegroundDrawList();\nIMGUI_NODE_EDITOR_API ImDrawList* GetHintBackgroundDrawList();\nIMGUI_NODE_EDITOR_API void EndGroupHint();\n\n// TODO: Add a way to manage node background channels\nIMGUI_NODE_EDITOR_API ImDrawList* GetNodeBackgroundDrawList(NodeId nodeId);\n\nIMGUI_NODE_EDITOR_API bool Link(LinkId id, PinId startPinId, PinId endPinId, const ImVec4& color = ImVec4(1, 1, 1, 1), float thickness = 1.0f);\n\nIMGUI_NODE_EDITOR_API void Flow(LinkId linkId, FlowDirection direction = FlowDirection::Forward);\n\nIMGUI_NODE_EDITOR_API bool BeginCreate(const ImVec4& color = ImVec4(1, 1, 1, 1), float thickness = 1.0f);\nIMGUI_NODE_EDITOR_API bool QueryNewLink(PinId* startId, PinId* endId);\nIMGUI_NODE_EDITOR_API bool QueryNewLink(PinId* startId, PinId* endId, const ImVec4& color, float thickness = 1.0f);\nIMGUI_NODE_EDITOR_API bool QueryNewNode(PinId* pinId);\nIMGUI_NODE_EDITOR_API bool QueryNewNode(PinId* pinId, const ImVec4& color, float thickness = 1.0f);\nIMGUI_NODE_EDITOR_API bool AcceptNewItem();\nIMGUI_NODE_EDITOR_API bool AcceptNewItem(const ImVec4& color, float thickness = 1.0f);\nIMGUI_NODE_EDITOR_API void RejectNewItem();\nIMGUI_NODE_EDITOR_API void RejectNewItem(const ImVec4& color, float thickness = 1.0f);\nIMGUI_NODE_EDITOR_API void EndCreate();\n\nIMGUI_NODE_EDITOR_API bool BeginDelete();\nIMGUI_NODE_EDITOR_API bool QueryDeletedLink(LinkId* linkId, PinId* startId = nullptr, PinId* endId = nullptr);\nIMGUI_NODE_EDITOR_API bool QueryDeletedNode(NodeId* nodeId);\nIMGUI_NODE_EDITOR_API bool AcceptDeletedItem(bool deleteDependencies = true);\nIMGUI_NODE_EDITOR_API void RejectDeletedItem();\nIMGUI_NODE_EDITOR_API void EndDelete();\n\nIMGUI_NODE_EDITOR_API void SetNodePosition(NodeId nodeId, const ImVec2& editorPosition);\nIMGUI_NODE_EDITOR_API void SetGroupSize(NodeId nodeId, const ImVec2& size);\nIMGUI_NODE_EDITOR_API ImVec2 GetNodePosition(NodeId nodeId);\nIMGUI_NODE_EDITOR_API ImVec2 GetNodeSize(NodeId nodeId);\nIMGUI_NODE_EDITOR_API void CenterNodeOnScreen(NodeId nodeId);\nIMGUI_NODE_EDITOR_API void SetNodeZPosition(NodeId nodeId, float z); // Sets node z position, nodes with higher value are drawn over nodes with lower value\nIMGUI_NODE_EDITOR_API float GetNodeZPosition(NodeId nodeId); // Returns node z position, defaults is 0.0f\n\nIMGUI_NODE_EDITOR_API void RestoreNodeState(NodeId nodeId);\n\nIMGUI_NODE_EDITOR_API void Suspend();\nIMGUI_NODE_EDITOR_API void Resume();\nIMGUI_NODE_EDITOR_API bool IsSuspended();\n\nIMGUI_NODE_EDITOR_API bool IsActive();\n\nIMGUI_NODE_EDITOR_API bool HasSelectionChanged();\nIMGUI_NODE_EDITOR_API int  GetSelectedObjectCount();\nIMGUI_NODE_EDITOR_API int  GetSelectedNodes(NodeId* nodes, int size);\nIMGUI_NODE_EDITOR_API int  GetSelectedLinks(LinkId* links, int size);\nIMGUI_NODE_EDITOR_API bool IsNodeSelected(NodeId nodeId);\nIMGUI_NODE_EDITOR_API bool IsLinkSelected(LinkId linkId);\nIMGUI_NODE_EDITOR_API void ClearSelection();\nIMGUI_NODE_EDITOR_API void SelectNode(NodeId nodeId, bool append = false);\nIMGUI_NODE_EDITOR_API void SelectLink(LinkId linkId, bool append = false);\nIMGUI_NODE_EDITOR_API void DeselectNode(NodeId nodeId);\nIMGUI_NODE_EDITOR_API void DeselectLink(LinkId linkId);\n\nIMGUI_NODE_EDITOR_API bool DeleteNode(NodeId nodeId);\nIMGUI_NODE_EDITOR_API bool DeleteLink(LinkId linkId);\n\nIMGUI_NODE_EDITOR_API bool HasAnyLinks(NodeId nodeId); // Returns true if node has any link connected\nIMGUI_NODE_EDITOR_API bool HasAnyLinks(PinId pinId); // Return true if pin has any link connected\nIMGUI_NODE_EDITOR_API int BreakLinks(NodeId nodeId); // Break all links connected to this node\nIMGUI_NODE_EDITOR_API int BreakLinks(PinId pinId); // Break all links connected to this pin\n\nIMGUI_NODE_EDITOR_API void NavigateToContent(float duration = -1);\nIMGUI_NODE_EDITOR_API void NavigateToSelection(bool zoomIn = false, float duration = -1);\n\nIMGUI_NODE_EDITOR_API bool ShowNodeContextMenu(NodeId* nodeId);\nIMGUI_NODE_EDITOR_API bool ShowPinContextMenu(PinId* pinId);\nIMGUI_NODE_EDITOR_API bool ShowLinkContextMenu(LinkId* linkId);\nIMGUI_NODE_EDITOR_API bool ShowBackgroundContextMenu();\n\nIMGUI_NODE_EDITOR_API void EnableShortcuts(bool enable);\nIMGUI_NODE_EDITOR_API bool AreShortcutsEnabled();\n\nIMGUI_NODE_EDITOR_API bool BeginShortcut();\nIMGUI_NODE_EDITOR_API bool AcceptCut();\nIMGUI_NODE_EDITOR_API bool AcceptCopy();\nIMGUI_NODE_EDITOR_API bool AcceptPaste();\nIMGUI_NODE_EDITOR_API bool AcceptDuplicate();\nIMGUI_NODE_EDITOR_API bool AcceptCreateNode();\nIMGUI_NODE_EDITOR_API int  GetActionContextSize();\nIMGUI_NODE_EDITOR_API int  GetActionContextNodes(NodeId* nodes, int size);\nIMGUI_NODE_EDITOR_API int  GetActionContextLinks(LinkId* links, int size);\nIMGUI_NODE_EDITOR_API void EndShortcut();\n\nIMGUI_NODE_EDITOR_API float GetCurrentZoom();\n\nIMGUI_NODE_EDITOR_API NodeId GetHoveredNode();\nIMGUI_NODE_EDITOR_API PinId GetHoveredPin();\nIMGUI_NODE_EDITOR_API LinkId GetHoveredLink();\nIMGUI_NODE_EDITOR_API NodeId GetDoubleClickedNode();\nIMGUI_NODE_EDITOR_API PinId GetDoubleClickedPin();\nIMGUI_NODE_EDITOR_API LinkId GetDoubleClickedLink();\nIMGUI_NODE_EDITOR_API bool IsBackgroundClicked();\nIMGUI_NODE_EDITOR_API bool IsBackgroundDoubleClicked();\nIMGUI_NODE_EDITOR_API ImGuiMouseButton GetBackgroundClickButtonIndex(); // -1 if none\nIMGUI_NODE_EDITOR_API ImGuiMouseButton GetBackgroundDoubleClickButtonIndex(); // -1 if none\n\nIMGUI_NODE_EDITOR_API bool GetLinkPins(LinkId linkId, PinId* startPinId, PinId* endPinId); // pass nullptr if particular pin do not interest you\n\nIMGUI_NODE_EDITOR_API bool PinHadAnyLinks(PinId pinId);\n\nIMGUI_NODE_EDITOR_API ImVec2 GetScreenSize();\nIMGUI_NODE_EDITOR_API ImVec2 ScreenToCanvas(const ImVec2& pos);\nIMGUI_NODE_EDITOR_API ImVec2 CanvasToScreen(const ImVec2& pos);\n\nIMGUI_NODE_EDITOR_API int GetNodeCount();                                // Returns number of submitted nodes since Begin() call\nIMGUI_NODE_EDITOR_API int GetOrderedNodeIds(NodeId* nodes, int size);    // Fills an array with node id's in order they're drawn; up to 'size` elements are set. Returns actual size of filled id's.\n\n\n\n\n\n\n\n//------------------------------------------------------------------------------\nnamespace Details {\n\ntemplate <typename T, typename Tag>\nstruct SafeType\n{\n    SafeType(T t)\n        : m_Value(std::move(t))\n    {\n    }\n\n    SafeType(const SafeType&) = default;\n\n    template <typename T2, typename Tag2>\n    SafeType(\n        const SafeType\n        <\n            typename std::enable_if<!std::is_same<T, T2>::value, T2>::type,\n            typename std::enable_if<!std::is_same<Tag, Tag2>::value, Tag2>::type\n        >&) = delete;\n\n    SafeType& operator=(const SafeType&) = default;\n\n    explicit operator T() const { return Get(); }\n\n    T Get() const { return m_Value; }\n\nprivate:\n    T m_Value;\n};\n\n\ntemplate <typename Tag>\nstruct SafePointerType\n    : SafeType<uintptr_t, Tag>\n{\n    static const Tag Invalid;\n\n    using SafeType<uintptr_t, Tag>::SafeType;\n\n    SafePointerType()\n        : SafePointerType(Invalid)\n    {\n    }\n\n    template <typename T = void> explicit SafePointerType(T* ptr): SafePointerType(reinterpret_cast<uintptr_t>(ptr)) {}\n    template <typename T = void> T* AsPointer() const { return reinterpret_cast<T*>(this->Get()); }\n\n    explicit operator bool() const { return *this != Invalid; }\n};\n\ntemplate <typename Tag>\nconst Tag SafePointerType<Tag>::Invalid = { 0 };\n\ntemplate <typename Tag>\ninline bool operator==(const SafePointerType<Tag>& lhs, const SafePointerType<Tag>& rhs)\n{\n    return lhs.Get() == rhs.Get();\n}\n\ntemplate <typename Tag>\ninline bool operator!=(const SafePointerType<Tag>& lhs, const SafePointerType<Tag>& rhs)\n{\n    return lhs.Get() != rhs.Get();\n}\n\n} // namespace Details\n\nstruct NodeId final: Details::SafePointerType<NodeId>\n{\n    using SafePointerType::SafePointerType;\n};\n\nstruct LinkId final: Details::SafePointerType<LinkId>\n{\n    using SafePointerType::SafePointerType;\n};\n\nstruct PinId final: Details::SafePointerType<PinId>\n{\n    using SafePointerType::SafePointerType;\n};\n\n\n//------------------------------------------------------------------------------\n} // namespace Editor\n} // namespace ax\n\n\n//------------------------------------------------------------------------------\n# endif // __IMGUI_NODE_EDITOR_H__\n"
        },
        {
          "name": "imgui_node_editor_api.cpp",
          "type": "blob",
          "size": 17.1279296875,
          "content": "//------------------------------------------------------------------------------\n// VERSION 0.9.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n//------------------------------------------------------------------------------\n# include \"imgui_node_editor_internal.h\"\n# include <algorithm>\n\n\n//------------------------------------------------------------------------------\nstatic ax::NodeEditor::Detail::EditorContext* s_Editor = nullptr;\n\n\n//------------------------------------------------------------------------------\ntemplate <typename C, typename I, typename F>\nstatic int BuildIdList(C& container, I* list, int listSize, F&& accept)\n{\n    if (list != nullptr)\n    {\n        int count = 0;\n        for (auto object : container)\n        {\n            if (listSize <= 0)\n                break;\n\n            if (accept(object))\n            {\n                list[count] = I(object->ID().AsPointer());\n                ++count;\n                --listSize;}\n        }\n\n        return count;\n    }\n    else\n        return static_cast<int>(std::count_if(container.begin(), container.end(), accept));\n}\n\n\n//------------------------------------------------------------------------------\nax::NodeEditor::EditorContext* ax::NodeEditor::CreateEditor(const Config* config)\n{\n    return reinterpret_cast<ax::NodeEditor::EditorContext*>(new ax::NodeEditor::Detail::EditorContext(config));\n}\n\nvoid ax::NodeEditor::DestroyEditor(EditorContext* ctx)\n{\n    auto lastContext = GetCurrentEditor();\n\n    // Set context we're about to destroy as current, to give callback valid context\n    if (lastContext != ctx)\n        SetCurrentEditor(ctx);\n\n    auto editor = reinterpret_cast<ax::NodeEditor::Detail::EditorContext*>(ctx);\n\n    delete editor;\n\n    if (lastContext != ctx)\n        SetCurrentEditor(lastContext);\n}\n\nconst ax::NodeEditor::Config& ax::NodeEditor::GetConfig(EditorContext* ctx)\n{\n    if (ctx == nullptr)\n        ctx = GetCurrentEditor();\n\n    if (ctx)\n    {\n        auto editor = reinterpret_cast<ax::NodeEditor::Detail::EditorContext*>(ctx);\n\n        return editor->GetConfig();\n    }\n    else\n    {\n        static Config s_EmptyConfig;\n        return s_EmptyConfig;\n    }\n}\n\nvoid ax::NodeEditor::SetCurrentEditor(EditorContext* ctx)\n{\n    s_Editor = reinterpret_cast<ax::NodeEditor::Detail::EditorContext*>(ctx);\n}\n\nax::NodeEditor::EditorContext* ax::NodeEditor::GetCurrentEditor()\n{\n    return reinterpret_cast<ax::NodeEditor::EditorContext*>(s_Editor);\n}\n\nax::NodeEditor::Style& ax::NodeEditor::GetStyle()\n{\n    return s_Editor->GetStyle();\n}\n\nconst char* ax::NodeEditor::GetStyleColorName(StyleColor colorIndex)\n{\n    return s_Editor->GetStyle().GetColorName(colorIndex);\n}\n\nvoid ax::NodeEditor::PushStyleColor(StyleColor colorIndex, const ImVec4& color)\n{\n    s_Editor->GetStyle().PushColor(colorIndex, color);\n}\n\nvoid ax::NodeEditor::PopStyleColor(int count)\n{\n    s_Editor->GetStyle().PopColor(count);\n}\n\nvoid ax::NodeEditor::PushStyleVar(StyleVar varIndex, float value)\n{\n    s_Editor->GetStyle().PushVar(varIndex, value);\n}\n\nvoid ax::NodeEditor::PushStyleVar(StyleVar varIndex, const ImVec2& value)\n{\n    s_Editor->GetStyle().PushVar(varIndex, value);\n}\n\nvoid ax::NodeEditor::PushStyleVar(StyleVar varIndex, const ImVec4& value)\n{\n    s_Editor->GetStyle().PushVar(varIndex, value);\n}\n\nvoid ax::NodeEditor::PopStyleVar(int count)\n{\n    s_Editor->GetStyle().PopVar(count);\n}\n\nvoid ax::NodeEditor::Begin(const char* id, const ImVec2& size)\n{\n    s_Editor->Begin(id, size);\n}\n\nvoid ax::NodeEditor::End()\n{\n    s_Editor->End();\n}\n\nvoid ax::NodeEditor::BeginNode(NodeId id)\n{\n    s_Editor->GetNodeBuilder().Begin(id);\n}\n\nvoid ax::NodeEditor::BeginPin(PinId id, PinKind kind)\n{\n    s_Editor->GetNodeBuilder().BeginPin(id, kind);\n}\n\nvoid ax::NodeEditor::PinRect(const ImVec2& a, const ImVec2& b)\n{\n    s_Editor->GetNodeBuilder().PinRect(a, b);\n}\n\nvoid ax::NodeEditor::PinPivotRect(const ImVec2& a, const ImVec2& b)\n{\n    s_Editor->GetNodeBuilder().PinPivotRect(a, b);\n}\n\nvoid ax::NodeEditor::PinPivotSize(const ImVec2& size)\n{\n    s_Editor->GetNodeBuilder().PinPivotSize(size);\n}\n\nvoid ax::NodeEditor::PinPivotScale(const ImVec2& scale)\n{\n    s_Editor->GetNodeBuilder().PinPivotScale(scale);\n}\n\nvoid ax::NodeEditor::PinPivotAlignment(const ImVec2& alignment)\n{\n    s_Editor->GetNodeBuilder().PinPivotAlignment(alignment);\n}\n\nvoid ax::NodeEditor::EndPin()\n{\n    s_Editor->GetNodeBuilder().EndPin();\n}\n\nvoid ax::NodeEditor::Group(const ImVec2& size)\n{\n    s_Editor->GetNodeBuilder().Group(size);\n}\n\nvoid ax::NodeEditor::EndNode()\n{\n    s_Editor->GetNodeBuilder().End();\n}\n\nbool ax::NodeEditor::BeginGroupHint(NodeId nodeId)\n{\n    return s_Editor->GetHintBuilder().Begin(nodeId);\n}\n\nImVec2 ax::NodeEditor::GetGroupMin()\n{\n    return s_Editor->GetHintBuilder().GetGroupMin();\n}\n\nImVec2 ax::NodeEditor::GetGroupMax()\n{\n    return s_Editor->GetHintBuilder().GetGroupMax();\n}\n\nImDrawList* ax::NodeEditor::GetHintForegroundDrawList()\n{\n    return s_Editor->GetHintBuilder().GetForegroundDrawList();\n}\n\nImDrawList* ax::NodeEditor::GetHintBackgroundDrawList()\n{\n    return s_Editor->GetHintBuilder().GetBackgroundDrawList();\n}\n\nvoid ax::NodeEditor::EndGroupHint()\n{\n    s_Editor->GetHintBuilder().End();\n}\n\nImDrawList* ax::NodeEditor::GetNodeBackgroundDrawList(NodeId nodeId)\n{\n    if (auto node = s_Editor->FindNode(nodeId))\n        return s_Editor->GetNodeBuilder().GetUserBackgroundDrawList(node);\n    else\n        return nullptr;\n}\n\nbool ax::NodeEditor::Link(LinkId id, PinId startPinId, PinId endPinId, const ImVec4& color/* = ImVec4(1, 1, 1, 1)*/, float thickness/* = 1.0f*/)\n{\n    return s_Editor->DoLink(id, startPinId, endPinId, ImColor(color), thickness);\n}\n\nvoid ax::NodeEditor::Flow(LinkId linkId, FlowDirection direction)\n{\n    if (auto link = s_Editor->FindLink(linkId))\n        s_Editor->Flow(link, direction);\n}\n\nbool ax::NodeEditor::BeginCreate(const ImVec4& color, float thickness)\n{\n    auto& context = s_Editor->GetItemCreator();\n\n    if (context.Begin())\n    {\n        context.SetStyle(ImColor(color), thickness);\n        return true;\n    }\n    else\n        return false;\n}\n\nbool ax::NodeEditor::QueryNewLink(PinId* startId, PinId* endId)\n{\n    using Result = ax::NodeEditor::Detail::CreateItemAction::Result;\n\n    auto& context = s_Editor->GetItemCreator();\n\n    return context.QueryLink(startId, endId) == Result::True;\n}\n\nbool ax::NodeEditor::QueryNewLink(PinId* startId, PinId* endId, const ImVec4& color, float thickness)\n{\n    using Result = ax::NodeEditor::Detail::CreateItemAction::Result;\n\n    auto& context = s_Editor->GetItemCreator();\n\n    auto result = context.QueryLink(startId, endId);\n    if (result != Result::Indeterminate)\n        context.SetStyle(ImColor(color), thickness);\n\n    return result == Result::True;\n}\n\nbool ax::NodeEditor::QueryNewNode(PinId* pinId)\n{\n    using Result = ax::NodeEditor::Detail::CreateItemAction::Result;\n\n    auto& context = s_Editor->GetItemCreator();\n\n    return context.QueryNode(pinId) == Result::True;\n}\n\nbool ax::NodeEditor::QueryNewNode(PinId* pinId, const ImVec4& color, float thickness)\n{\n    using Result = ax::NodeEditor::Detail::CreateItemAction::Result;\n\n    auto& context = s_Editor->GetItemCreator();\n\n    auto result = context.QueryNode(pinId);\n    if (result != Result::Indeterminate)\n        context.SetStyle(ImColor(color), thickness);\n\n    return result == Result::True;\n}\n\nbool ax::NodeEditor::AcceptNewItem()\n{\n    using Result = ax::NodeEditor::Detail::CreateItemAction::Result;\n\n    auto& context = s_Editor->GetItemCreator();\n\n    return context.AcceptItem() == Result::True;\n}\n\nbool ax::NodeEditor::AcceptNewItem(const ImVec4& color, float thickness)\n{\n    using Result = ax::NodeEditor::Detail::CreateItemAction::Result;\n\n    auto& context = s_Editor->GetItemCreator();\n\n    auto result = context.AcceptItem();\n    if (result != Result::Indeterminate)\n        context.SetStyle(ImColor(color), thickness);\n\n    return result == Result::True;\n}\n\nvoid ax::NodeEditor::RejectNewItem()\n{\n    auto& context = s_Editor->GetItemCreator();\n\n    context.RejectItem();\n}\n\nvoid ax::NodeEditor::RejectNewItem(const ImVec4& color, float thickness)\n{\n    using Result = ax::NodeEditor::Detail::CreateItemAction::Result;\n\n    auto& context = s_Editor->GetItemCreator();\n\n    if (context.RejectItem() != Result::Indeterminate)\n        context.SetStyle(ImColor(color), thickness);\n}\n\nvoid ax::NodeEditor::EndCreate()\n{\n    auto& context = s_Editor->GetItemCreator();\n\n    context.End();\n}\n\nbool ax::NodeEditor::BeginDelete()\n{\n    auto& context = s_Editor->GetItemDeleter();\n\n    return context.Begin();\n}\n\nbool ax::NodeEditor::QueryDeletedLink(LinkId* linkId, PinId* startId, PinId* endId)\n{\n    auto& context = s_Editor->GetItemDeleter();\n\n    return context.QueryLink(linkId, startId, endId);\n}\n\nbool ax::NodeEditor::QueryDeletedNode(NodeId* nodeId)\n{\n    auto& context = s_Editor->GetItemDeleter();\n\n    return context.QueryNode(nodeId);\n}\n\nbool ax::NodeEditor::AcceptDeletedItem(bool deleteDependencies)\n{\n    auto& context = s_Editor->GetItemDeleter();\n\n    return context.AcceptItem(deleteDependencies);\n}\n\nvoid ax::NodeEditor::RejectDeletedItem()\n{\n    auto& context = s_Editor->GetItemDeleter();\n\n    context.RejectItem();\n}\n\nvoid ax::NodeEditor::EndDelete()\n{\n    auto& context = s_Editor->GetItemDeleter();\n\n    context.End();\n}\n\nvoid ax::NodeEditor::SetNodePosition(NodeId nodeId, const ImVec2& position)\n{\n    s_Editor->SetNodePosition(nodeId, position);\n}\n\nvoid ax::NodeEditor::SetGroupSize(NodeId nodeId, const ImVec2& size)\n{\n    s_Editor->SetGroupSize(nodeId, size);\n}\n\nImVec2 ax::NodeEditor::GetNodePosition(NodeId nodeId)\n{\n    return s_Editor->GetNodePosition(nodeId);\n}\n\nImVec2 ax::NodeEditor::GetNodeSize(NodeId nodeId)\n{\n    return s_Editor->GetNodeSize(nodeId);\n}\n\nvoid ax::NodeEditor::CenterNodeOnScreen(NodeId nodeId)\n{\n    if (auto node = s_Editor->FindNode(nodeId))\n        node->CenterOnScreenInNextFrame();\n}\n\nvoid ax::NodeEditor::SetNodeZPosition(NodeId nodeId, float z)\n{\n    s_Editor->SetNodeZPosition(nodeId, z);\n}\n\nfloat ax::NodeEditor::GetNodeZPosition(NodeId nodeId)\n{\n    return s_Editor->GetNodeZPosition(nodeId);\n}\n\nvoid ax::NodeEditor::RestoreNodeState(NodeId nodeId)\n{\n    if (auto node = s_Editor->FindNode(nodeId))\n        s_Editor->MarkNodeToRestoreState(node);\n}\n\nvoid ax::NodeEditor::Suspend()\n{\n    s_Editor->Suspend();\n}\n\nvoid ax::NodeEditor::Resume()\n{\n    s_Editor->Resume();\n}\n\nbool ax::NodeEditor::IsSuspended()\n{\n    return s_Editor->IsSuspended();\n}\n\nbool ax::NodeEditor::IsActive()\n{\n    return s_Editor->IsFocused();\n}\n\nbool ax::NodeEditor::HasSelectionChanged()\n{\n    return s_Editor->HasSelectionChanged();\n}\n\nint ax::NodeEditor::GetSelectedObjectCount()\n{\n    return (int)s_Editor->GetSelectedObjects().size();\n}\n\nint ax::NodeEditor::GetSelectedNodes(NodeId* nodes, int size)\n{\n    return BuildIdList(s_Editor->GetSelectedObjects(), nodes, size, [](auto object)\n    {\n        return object->AsNode() != nullptr;\n    });\n}\n\nint ax::NodeEditor::GetSelectedLinks(LinkId* links, int size)\n{\n    return BuildIdList(s_Editor->GetSelectedObjects(), links, size, [](auto object)\n    {\n        return object->AsLink() != nullptr;\n    });\n}\n\nbool ax::NodeEditor::IsNodeSelected(NodeId nodeId)\n{\n    if (auto node = s_Editor->FindNode(nodeId))\n        return s_Editor->IsSelected(node);\n    else\n        return false;\n}\n\nbool ax::NodeEditor::IsLinkSelected(LinkId linkId)\n{\n    if (auto link = s_Editor->FindLink(linkId))\n        return s_Editor->IsSelected(link);\n    else\n        return false;\n}\n\nvoid ax::NodeEditor::ClearSelection()\n{\n    s_Editor->ClearSelection();\n}\n\nvoid ax::NodeEditor::SelectNode(NodeId nodeId, bool append)\n{\n    if (auto node = s_Editor->FindNode(nodeId))\n    {\n        if (append)\n            s_Editor->SelectObject(node);\n        else\n            s_Editor->SetSelectedObject(node);\n    }\n}\n\nvoid ax::NodeEditor::SelectLink(LinkId linkId, bool append)\n{\n    if (auto link = s_Editor->FindLink(linkId))\n    {\n        if (append)\n            s_Editor->SelectObject(link);\n        else\n            s_Editor->SetSelectedObject(link);\n    }\n}\n\nvoid ax::NodeEditor::DeselectNode(NodeId nodeId)\n{\n    if (auto node = s_Editor->FindNode(nodeId))\n        s_Editor->DeselectObject(node);\n}\n\nvoid ax::NodeEditor::DeselectLink(LinkId linkId)\n{\n    if (auto link = s_Editor->FindLink(linkId))\n        s_Editor->DeselectObject(link);\n}\n\nbool ax::NodeEditor::DeleteNode(NodeId nodeId)\n{\n    if (auto node = s_Editor->FindNode(nodeId))\n        return s_Editor->GetItemDeleter().Add(node);\n    else\n        return false;\n}\n\nbool ax::NodeEditor::DeleteLink(LinkId linkId)\n{\n    if (auto link = s_Editor->FindLink(linkId))\n        return s_Editor->GetItemDeleter().Add(link);\n    else\n        return false;\n}\n\nbool ax::NodeEditor::HasAnyLinks(NodeId nodeId)\n{\n    return s_Editor->HasAnyLinks(nodeId);\n}\n\nbool ax::NodeEditor::HasAnyLinks(PinId pinId)\n{\n    return s_Editor->HasAnyLinks(pinId);\n}\n\nint ax::NodeEditor::BreakLinks(NodeId nodeId)\n{\n    return s_Editor->BreakLinks(nodeId);\n}\n\nint ax::NodeEditor::BreakLinks(PinId pinId)\n{\n    return s_Editor->BreakLinks(pinId);\n}\n\nvoid ax::NodeEditor::NavigateToContent(float duration)\n{\n    s_Editor->NavigateTo(s_Editor->GetContentBounds(), true, duration);\n}\n\nvoid ax::NodeEditor::NavigateToSelection(bool zoomIn, float duration)\n{\n    s_Editor->NavigateTo(s_Editor->GetSelectionBounds(), zoomIn, duration);\n}\n\nbool ax::NodeEditor::ShowNodeContextMenu(NodeId* nodeId)\n{\n    return s_Editor->GetContextMenu().ShowNodeContextMenu(nodeId);\n}\n\nbool ax::NodeEditor::ShowPinContextMenu(PinId* pinId)\n{\n    return s_Editor->GetContextMenu().ShowPinContextMenu(pinId);\n}\n\nbool ax::NodeEditor::ShowLinkContextMenu(LinkId* linkId)\n{\n    return s_Editor->GetContextMenu().ShowLinkContextMenu(linkId);\n}\n\nbool ax::NodeEditor::ShowBackgroundContextMenu()\n{\n    return s_Editor->GetContextMenu().ShowBackgroundContextMenu();\n}\n\nvoid ax::NodeEditor::EnableShortcuts(bool enable)\n{\n    s_Editor->EnableShortcuts(enable);\n}\n\nbool ax::NodeEditor::AreShortcutsEnabled()\n{\n    return s_Editor->AreShortcutsEnabled();\n}\n\nbool ax::NodeEditor::BeginShortcut()\n{\n    return s_Editor->GetShortcut().Begin();\n}\n\nbool ax::NodeEditor::AcceptCut()\n{\n    return s_Editor->GetShortcut().AcceptCut();\n}\n\nbool ax::NodeEditor::AcceptCopy()\n{\n    return s_Editor->GetShortcut().AcceptCopy();\n}\n\nbool ax::NodeEditor::AcceptPaste()\n{\n    return s_Editor->GetShortcut().AcceptPaste();\n}\n\nbool ax::NodeEditor::AcceptDuplicate()\n{\n    return s_Editor->GetShortcut().AcceptDuplicate();\n}\n\nbool ax::NodeEditor::AcceptCreateNode()\n{\n    return s_Editor->GetShortcut().AcceptCreateNode();\n}\n\nint ax::NodeEditor::GetActionContextSize()\n{\n    return static_cast<int>(s_Editor->GetShortcut().m_Context.size());\n}\n\nint ax::NodeEditor::GetActionContextNodes(NodeId* nodes, int size)\n{\n    return BuildIdList(s_Editor->GetSelectedObjects(), nodes, size, [](auto object)\n    {\n        return object->AsNode() != nullptr;\n    });\n}\n\nint ax::NodeEditor::GetActionContextLinks(LinkId* links, int size)\n{\n    return BuildIdList(s_Editor->GetSelectedObjects(), links, size, [](auto object)\n    {\n        return object->AsLink() != nullptr;\n    });\n}\n\nvoid ax::NodeEditor::EndShortcut()\n{\n    return s_Editor->GetShortcut().End();\n}\n\nfloat ax::NodeEditor::GetCurrentZoom()\n{\n    return s_Editor->GetView().InvScale;\n}\n\nax::NodeEditor::NodeId ax::NodeEditor::GetHoveredNode()\n{\n    return s_Editor->GetHoveredNode();\n}\n\nax::NodeEditor::PinId ax::NodeEditor::GetHoveredPin()\n{\n    return s_Editor->GetHoveredPin();\n}\n\nax::NodeEditor::LinkId ax::NodeEditor::GetHoveredLink()\n{\n    return s_Editor->GetHoveredLink();\n}\n\nax::NodeEditor::NodeId ax::NodeEditor::GetDoubleClickedNode()\n{\n    return s_Editor->GetDoubleClickedNode();\n}\n\nax::NodeEditor::PinId ax::NodeEditor::GetDoubleClickedPin()\n{\n    return s_Editor->GetDoubleClickedPin();\n}\n\nax::NodeEditor::LinkId ax::NodeEditor::GetDoubleClickedLink()\n{\n    return s_Editor->GetDoubleClickedLink();\n}\n\nbool ax::NodeEditor::IsBackgroundClicked()\n{\n    return s_Editor->IsBackgroundClicked();\n}\n\nbool ax::NodeEditor::IsBackgroundDoubleClicked()\n{\n    return s_Editor->IsBackgroundDoubleClicked();\n}\n\nImGuiMouseButton ax::NodeEditor::GetBackgroundClickButtonIndex()\n{\n    return s_Editor->GetBackgroundClickButtonIndex();\n}\n\nImGuiMouseButton ax::NodeEditor::GetBackgroundDoubleClickButtonIndex()\n{\n    return s_Editor->GetBackgroundDoubleClickButtonIndex();\n}\n\nbool ax::NodeEditor::GetLinkPins(LinkId linkId, PinId* startPinId, PinId* endPinId)\n{\n    auto link = s_Editor->FindLink(linkId);\n    if (!link)\n        return false;\n\n    if (startPinId)\n        *startPinId = link->m_StartPin->m_ID;\n    if (endPinId)\n        *endPinId = link->m_EndPin->m_ID;\n\n    return true;\n}\n\nbool ax::NodeEditor::PinHadAnyLinks(PinId pinId)\n{\n    return s_Editor->PinHadAnyLinks(pinId);\n}\n\nImVec2 ax::NodeEditor::GetScreenSize()\n{\n    return s_Editor->GetRect().GetSize();\n}\n\nImVec2 ax::NodeEditor::ScreenToCanvas(const ImVec2& pos)\n{\n    return s_Editor->ToCanvas(pos);\n}\n\nImVec2 ax::NodeEditor::CanvasToScreen(const ImVec2& pos)\n{\n    return s_Editor->ToScreen(pos);\n}\n\nint ax::NodeEditor::GetNodeCount()\n{\n    return s_Editor->CountLiveNodes();\n}\n\nint ax::NodeEditor::GetOrderedNodeIds(NodeId* nodes, int size)\n{\n    return s_Editor->GetNodeIds(nodes, size);\n}\n"
        },
        {
          "name": "imgui_node_editor_internal.h",
          "type": "blob",
          "size": 43.490234375,
          "content": "//------------------------------------------------------------------------------\n// VERSION 0.9.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n//------------------------------------------------------------------------------\n# ifndef __IMGUI_NODE_EDITOR_INTERNAL_H__\n# define __IMGUI_NODE_EDITOR_INTERNAL_H__\n# pragma once\n\n\n//------------------------------------------------------------------------------\n# ifndef IMGUI_DEFINE_MATH_OPERATORS\n#     define IMGUI_DEFINE_MATH_OPERATORS\n# endif\n# include \"imgui_node_editor.h\"\n\n\n//------------------------------------------------------------------------------\n# include <imgui.h>\n# include <imgui_internal.h>\n# include \"imgui_extra_math.h\"\n# include \"imgui_bezier_math.h\"\n# include \"imgui_canvas.h\"\n\n# include \"crude_json.h\"\n\n# include <vector>\n# include <string>\n\n\n//------------------------------------------------------------------------------\nnamespace ax {\nnamespace NodeEditor {\nnamespace Detail {\n\n\n//------------------------------------------------------------------------------\nnamespace ed = ax::NodeEditor::Detail;\nnamespace json = crude_json;\n\n\n//------------------------------------------------------------------------------\nusing std::vector;\nusing std::string;\n\n\n//------------------------------------------------------------------------------\nvoid Log(const char* fmt, ...);\n\n\n//------------------------------------------------------------------------------\n//inline ImRect ToRect(const ax::rectf& rect);\n//inline ImRect ToRect(const ax::rect& rect);\ninline ImRect ImGui_GetItemRect();\ninline ImVec2 ImGui_GetMouseClickPos(ImGuiMouseButton buttonIndex);\n\n\n//------------------------------------------------------------------------------\n// https://stackoverflow.com/a/36079786\n# define DECLARE_HAS_MEMBER(__trait_name__, __member_name__)                         \\\n                                                                                     \\\n    template <typename __boost_has_member_T__>                                       \\\n    class __trait_name__                                                             \\\n    {                                                                                \\\n        using check_type = ::std::remove_const_t<__boost_has_member_T__>;            \\\n        struct no_type {char x[2];};                                                 \\\n        using  yes_type = char;                                                      \\\n                                                                                     \\\n        struct  base { void __member_name__() {}};                                   \\\n        struct mixin : public base, public check_type {};                            \\\n                                                                                     \\\n        template <void (base::*)()> struct aux {};                                   \\\n                                                                                     \\\n        template <typename U> static no_type  test(aux<&U::__member_name__>*);       \\\n        template <typename U> static yes_type test(...);                             \\\n                                                                                     \\\n        public:                                                                      \\\n                                                                                     \\\n        static constexpr bool value = (sizeof(yes_type) == sizeof(test<mixin>(0)));  \\\n    }\n\nDECLARE_HAS_MEMBER(HasFringeScale, _FringeScale);\n\n# undef DECLARE_HAS_MEMBER\n\nstruct FringeScaleRef\n{\n    // Overload is present when ImDrawList does have _FringeScale member variable.\n    template <typename T>\n    static float& Get(typename std::enable_if<HasFringeScale<T>::value, T>::type* drawList)\n    {\n        return drawList->_FringeScale;\n    }\n\n    // Overload is present when ImDrawList does not have _FringeScale member variable.\n    template <typename T>\n    static float& Get(typename std::enable_if<!HasFringeScale<T>::value, T>::type*)\n    {\n        static float placeholder = 1.0f;\n        return placeholder;\n    }\n};\n\nstatic inline float& ImFringeScaleRef(ImDrawList* drawList)\n{\n    return FringeScaleRef::Get<ImDrawList>(drawList);\n}\n\nstruct FringeScaleScope\n{\n\n    FringeScaleScope(float scale)\n        : m_LastFringeScale(ImFringeScaleRef(ImGui::GetWindowDrawList()))\n    {\n        ImFringeScaleRef(ImGui::GetWindowDrawList()) = scale;\n    }\n\n    ~FringeScaleScope()\n    {\n        ImFringeScaleRef(ImGui::GetWindowDrawList()) = m_LastFringeScale;\n    }\n\nprivate:\n    float m_LastFringeScale;\n};\n\n\n//------------------------------------------------------------------------------\nenum class ObjectType\n{\n    None,\n    Node,\n    Link,\n    Pin\n};\n\nusing ax::NodeEditor::PinKind;\nusing ax::NodeEditor::StyleColor;\nusing ax::NodeEditor::StyleVar;\nusing ax::NodeEditor::SaveReasonFlags;\n\nusing ax::NodeEditor::NodeId;\nusing ax::NodeEditor::PinId;\nusing ax::NodeEditor::LinkId;\n\nstruct ObjectId final: Details::SafePointerType<ObjectId>\n{\n    using Super = Details::SafePointerType<ObjectId>;\n    using Super::Super;\n\n    ObjectId():                  Super(Invalid),              m_Type(ObjectType::None)   {}\n    ObjectId(PinId  pinId):      Super(pinId.AsPointer()),    m_Type(ObjectType::Pin)    {}\n    ObjectId(NodeId nodeId):     Super(nodeId.AsPointer()),   m_Type(ObjectType::Node)   {}\n    ObjectId(LinkId linkId):     Super(linkId.AsPointer()),   m_Type(ObjectType::Link)   {}\n\n    explicit operator PinId()    const { return AsPinId();    }\n    explicit operator NodeId()   const { return AsNodeId();   }\n    explicit operator LinkId()   const { return AsLinkId();   }\n\n    PinId    AsPinId()    const { IM_ASSERT(IsPinId());    return PinId(AsPointer());    }\n    NodeId   AsNodeId()   const { IM_ASSERT(IsNodeId());   return NodeId(AsPointer());   }\n    LinkId   AsLinkId()   const { IM_ASSERT(IsLinkId());   return LinkId(AsPointer());   }\n\n    bool IsPinId()    const { return m_Type == ObjectType::Pin;    }\n    bool IsNodeId()   const { return m_Type == ObjectType::Node;   }\n    bool IsLinkId()   const { return m_Type == ObjectType::Link;   }\n\n    ObjectType Type() const { return m_Type; }\n\nprivate:\n    ObjectType m_Type;\n};\n\nstruct EditorContext;\n\nstruct Node;\nstruct Pin;\nstruct Link;\n\ntemplate <typename T, typename Id = typename T::IdType>\nstruct ObjectWrapper\n{\n    Id   m_ID;\n    T*   m_Object;\n\n          T* operator->()        { return m_Object; }\n    const T* operator->() const  { return m_Object; }\n\n    operator T*()             { return m_Object; }\n    operator const T*() const { return m_Object; }\n\n    bool operator<(const ObjectWrapper& rhs) const\n    {\n        return m_ID.AsPointer() < rhs.m_ID.AsPointer();\n    }\n};\n\nstruct Object\n{\n    enum DrawFlags\n    {\n        None     = 0,\n        Hovered  = 1,\n        Selected = 2,\n        Highlighted = 4,\n    };\n\n    inline friend DrawFlags operator|(DrawFlags lhs, DrawFlags rhs)  { return static_cast<DrawFlags>(static_cast<int>(lhs) | static_cast<int>(rhs)); }\n    inline friend DrawFlags operator&(DrawFlags lhs, DrawFlags rhs)  { return static_cast<DrawFlags>(static_cast<int>(lhs) & static_cast<int>(rhs)); }\n    inline friend DrawFlags& operator|=(DrawFlags& lhs, DrawFlags rhs) { lhs = lhs | rhs; return lhs; }\n    inline friend DrawFlags& operator&=(DrawFlags& lhs, DrawFlags rhs) { lhs = lhs & rhs; return lhs; }\n\n    EditorContext* const Editor;\n\n    bool    m_IsLive;\n    bool    m_IsSelected;\n    bool    m_DeleteOnNewFrame;\n\n    Object(EditorContext* editor)\n        : Editor(editor)\n        , m_IsLive(true)\n        , m_IsSelected(false)\n        , m_DeleteOnNewFrame(false)\n    {\n    }\n\n    virtual ~Object() = default;\n\n    virtual ObjectId ID() = 0;\n\n    bool IsVisible() const\n    {\n        if (!m_IsLive)\n            return false;\n\n        const auto bounds = GetBounds();\n\n        return ImGui::IsRectVisible(bounds.Min, bounds.Max);\n    }\n\n    virtual void Reset() { m_IsLive = false; }\n\n    virtual void Draw(ImDrawList* drawList, DrawFlags flags = None) = 0;\n\n    virtual bool AcceptDrag() { return false; }\n    virtual void UpdateDrag(const ImVec2& offset) { IM_UNUSED(offset); }\n    virtual bool EndDrag() { return false; }\n    virtual ImVec2 DragStartLocation() { return GetBounds().Min; }\n\n    virtual bool IsDraggable() { bool result = AcceptDrag(); EndDrag(); return result; }\n    virtual bool IsSelectable() { return false; }\n\n    virtual bool TestHit(const ImVec2& point, float extraThickness = 0.0f) const\n    {\n        if (!m_IsLive)\n            return false;\n\n        auto bounds = GetBounds();\n        if (extraThickness > 0)\n            bounds.Expand(extraThickness);\n\n        return bounds.Contains(point);\n    }\n\n    virtual bool TestHit(const ImRect& rect, bool allowIntersect = true) const\n    {\n        if (!m_IsLive)\n            return false;\n\n        const auto bounds = GetBounds();\n\n        return !ImRect_IsEmpty(bounds) && (allowIntersect ? bounds.Overlaps(rect) : rect.Contains(bounds));\n    }\n\n    virtual ImRect GetBounds() const = 0;\n\n    virtual Node*  AsNode()  { return nullptr; }\n    virtual Pin*   AsPin()   { return nullptr; }\n    virtual Link*  AsLink()  { return nullptr; }\n};\n\nstruct Pin final: Object\n{\n    using IdType = PinId;\n\n    PinId   m_ID;\n    PinKind m_Kind;\n    Node*   m_Node;\n    ImRect  m_Bounds;\n    ImRect  m_Pivot;\n    Pin*    m_PreviousPin;\n    ImU32   m_Color;\n    ImU32   m_BorderColor;\n    float   m_BorderWidth;\n    float   m_Rounding;\n    int     m_Corners;\n    ImVec2  m_Dir;\n    float   m_Strength;\n    float   m_Radius;\n    float   m_ArrowSize;\n    float   m_ArrowWidth;\n    bool    m_SnapLinkToDir;\n    bool    m_HasConnection;\n    bool    m_HadConnection;\n\n    Pin(EditorContext* editor, PinId id, PinKind kind)\n        : Object(editor)\n        , m_ID(id)\n        , m_Kind(kind)\n        , m_Node(nullptr)\n        , m_Bounds()\n        , m_PreviousPin(nullptr)\n        , m_Color(IM_COL32_WHITE)\n        , m_BorderColor(IM_COL32_BLACK)\n        , m_BorderWidth(0)\n        , m_Rounding(0)\n        , m_Corners(0)\n        , m_Dir(0, 0)\n        , m_Strength(0)\n        , m_Radius(0)\n        , m_ArrowSize(0)\n        , m_ArrowWidth(0)\n        , m_SnapLinkToDir(true)\n        , m_HasConnection(false)\n        , m_HadConnection(false)\n    {\n    }\n\n    virtual ObjectId ID() override { return m_ID; }\n\n    virtual void Reset() override final\n    {\n        m_HadConnection = m_HasConnection && m_IsLive;\n        m_HasConnection = false;\n\n        Object::Reset();\n    }\n\n    virtual void Draw(ImDrawList* drawList, DrawFlags flags = None) override final;\n\n    ImVec2 GetClosestPoint(const ImVec2& p) const;\n    ImLine GetClosestLine(const Pin* pin) const;\n\n    virtual ImRect GetBounds() const override final { return m_Bounds; }\n\n    virtual Pin* AsPin() override final { return this; }\n};\n\nenum class NodeType\n{\n    Node,\n    Group\n};\n\nenum class NodeRegion : uint8_t\n{\n    None        = 0x00,\n    Top         = 0x01,\n    Bottom      = 0x02,\n    Left        = 0x04,\n    Right       = 0x08,\n    Center      = 0x10,\n    Header      = 0x20,\n    TopLeft     = Top | Left,\n    TopRight    = Top | Right,\n    BottomLeft  = Bottom | Left,\n    BottomRight = Bottom | Right,\n};\n\ninline NodeRegion operator |(NodeRegion lhs, NodeRegion rhs) { return static_cast<NodeRegion>(static_cast<uint8_t>(lhs) | static_cast<uint8_t>(rhs)); }\ninline NodeRegion operator &(NodeRegion lhs, NodeRegion rhs) { return static_cast<NodeRegion>(static_cast<uint8_t>(lhs) & static_cast<uint8_t>(rhs)); }\n\n\nstruct Node final: Object\n{\n    using IdType = NodeId;\n\n    NodeId   m_ID;\n    NodeType m_Type;\n    ImRect   m_Bounds;\n    float    m_ZPosition;\n    int      m_Channel;\n    Pin*     m_LastPin;\n    ImVec2   m_DragStart;\n\n    ImU32    m_Color;\n    ImU32    m_BorderColor;\n    float    m_BorderWidth;\n    float    m_Rounding;\n\n    ImU32    m_GroupColor;\n    ImU32    m_GroupBorderColor;\n    float    m_GroupBorderWidth;\n    float    m_GroupRounding;\n    ImRect   m_GroupBounds;\n\n    bool     m_HighlightConnectedLinks;\n\n    bool     m_RestoreState;\n    bool     m_CenterOnScreen;\n\n    Node(EditorContext* editor, NodeId id)\n        : Object(editor)\n        , m_ID(id)\n        , m_Type(NodeType::Node)\n        , m_Bounds()\n        , m_ZPosition(0.0f)\n        , m_Channel(0)\n        , m_LastPin(nullptr)\n        , m_DragStart()\n        , m_Color(IM_COL32_WHITE)\n        , m_BorderColor(IM_COL32_BLACK)\n        , m_BorderWidth(0)\n        , m_Rounding(0)\n        , m_GroupBounds()\n        , m_HighlightConnectedLinks(false)\n        , m_RestoreState(false)\n        , m_CenterOnScreen(false)\n    {\n    }\n\n    virtual ObjectId ID() override { return m_ID; }\n\n    bool AcceptDrag() override;\n    void UpdateDrag(const ImVec2& offset) override;\n    bool EndDrag() override; // return true, when changed\n    ImVec2 DragStartLocation() override { return m_DragStart; }\n\n    virtual bool IsSelectable() override { return true; }\n\n    virtual void Draw(ImDrawList* drawList, DrawFlags flags = None) override final;\n    void DrawBorder(ImDrawList* drawList, ImU32 color, float thickness = 1.0f, float offset = 0.0f);\n\n    void GetGroupedNodes(std::vector<Node*>& result, bool append = false);\n\n    void CenterOnScreenInNextFrame() { m_CenterOnScreen = true; }\n\n    ImRect GetRegionBounds(NodeRegion region) const;\n    NodeRegion GetRegion(const ImVec2& point) const;\n\n    virtual ImRect GetBounds() const override final { return m_Bounds; }\n\n    virtual Node* AsNode() override final { return this; }\n};\n\nstruct Link final: Object\n{\n    using IdType = LinkId;\n\n    LinkId m_ID;\n    Pin*   m_StartPin;\n    Pin*   m_EndPin;\n    ImU32  m_Color;\n    ImU32  m_HighlightColor;\n    float  m_Thickness;\n    ImVec2 m_Start;\n    ImVec2 m_End;\n\n    Link(EditorContext* editor, LinkId id)\n        : Object(editor)\n        , m_ID(id)\n        , m_StartPin(nullptr)\n        , m_EndPin(nullptr)\n        , m_Color(IM_COL32_WHITE)\n        , m_Thickness(1.0f)\n    {\n    }\n\n    virtual ObjectId ID() override { return m_ID; }\n\n    virtual bool IsSelectable() override { return true; }\n\n    virtual void Draw(ImDrawList* drawList, DrawFlags flags = None) override final;\n    void Draw(ImDrawList* drawList, ImU32 color, float extraThickness = 0.0f) const;\n\n    void UpdateEndpoints();\n\n    ImCubicBezierPoints GetCurve() const;\n\n    virtual bool TestHit(const ImVec2& point, float extraThickness = 0.0f) const override final;\n    virtual bool TestHit(const ImRect& rect, bool allowIntersect = true) const override final;\n\n    virtual ImRect GetBounds() const override final;\n\n    virtual Link* AsLink() override final { return this; }\n};\n\nstruct NodeSettings\n{\n    NodeId m_ID;\n    ImVec2 m_Location;\n    ImVec2 m_Size;\n    ImVec2 m_GroupSize;\n    bool   m_WasUsed;\n\n    bool            m_Saved;\n    bool            m_IsDirty;\n    SaveReasonFlags m_DirtyReason;\n\n    NodeSettings(NodeId id)\n        : m_ID(id)\n        , m_Location(0, 0)\n        , m_Size(0, 0)\n        , m_GroupSize(0, 0)\n        , m_WasUsed(false)\n        , m_Saved(false)\n        , m_IsDirty(false)\n        , m_DirtyReason(SaveReasonFlags::None)\n    {\n    }\n\n    void ClearDirty();\n    void MakeDirty(SaveReasonFlags reason);\n\n    json::value Serialize();\n\n    static bool Parse(const std::string& string, NodeSettings& settings);\n    static bool Parse(const json::value& data, NodeSettings& result);\n};\n\nstruct Settings\n{\n    bool                 m_IsDirty;\n    SaveReasonFlags      m_DirtyReason;\n\n    vector<NodeSettings> m_Nodes;\n    vector<ObjectId>     m_Selection;\n    ImVec2               m_ViewScroll;\n    float                m_ViewZoom;\n    ImRect               m_VisibleRect;\n\n    Settings()\n        : m_IsDirty(false)\n        , m_DirtyReason(SaveReasonFlags::None)\n        , m_ViewScroll(0, 0)\n        , m_ViewZoom(1.0f)\n        , m_VisibleRect()\n    {\n    }\n\n    NodeSettings* AddNode(NodeId id);\n    NodeSettings* FindNode(NodeId id);\n    void RemoveNode(NodeId id);\n\n    void ClearDirty(Node* node = nullptr);\n    void MakeDirty(SaveReasonFlags reason, Node* node = nullptr);\n\n    std::string Serialize();\n\n    static bool Parse(const std::string& string, Settings& settings);\n};\n\nstruct Control\n{\n    Object* HotObject;\n    Object* ActiveObject;\n    Object* ClickedObject;\n    Object* DoubleClickedObject;\n    Node*   HotNode;\n    Node*   ActiveNode;\n    Node*   ClickedNode;\n    Node*   DoubleClickedNode;\n    Pin*    HotPin;\n    Pin*    ActivePin;\n    Pin*    ClickedPin;\n    Pin*    DoubleClickedPin;\n    Link*   HotLink;\n    Link*   ActiveLink;\n    Link*   ClickedLink;\n    Link*   DoubleClickedLink;\n    bool    BackgroundHot;\n    bool    BackgroundActive;\n    int     BackgroundClickButtonIndex;\n    int     BackgroundDoubleClickButtonIndex;\n\n    Control()\n        : Control(nullptr, nullptr, nullptr, nullptr, false, false, -1, -1)\n    {\n    }\n\n    Control(Object* hotObject, Object* activeObject, Object* clickedObject, Object* doubleClickedObject,\n        bool backgroundHot, bool backgroundActive, int backgroundClickButtonIndex, int backgroundDoubleClickButtonIndex)\n        : HotObject(hotObject)\n        , ActiveObject(activeObject)\n        , ClickedObject(clickedObject)\n        , DoubleClickedObject(doubleClickedObject)\n        , HotNode(nullptr)\n        , ActiveNode(nullptr)\n        , ClickedNode(nullptr)\n        , DoubleClickedNode(nullptr)\n        , HotPin(nullptr)\n        , ActivePin(nullptr)\n        , ClickedPin(nullptr)\n        , DoubleClickedPin(nullptr)\n        , HotLink(nullptr)\n        , ActiveLink(nullptr)\n        , ClickedLink(nullptr)\n        , DoubleClickedLink(nullptr)\n        , BackgroundHot(backgroundHot)\n        , BackgroundActive(backgroundActive)\n        , BackgroundClickButtonIndex(backgroundClickButtonIndex)\n        , BackgroundDoubleClickButtonIndex(backgroundDoubleClickButtonIndex)\n    {\n        if (hotObject)\n        {\n            HotNode  = hotObject->AsNode();\n            HotPin   = hotObject->AsPin();\n            HotLink  = hotObject->AsLink();\n\n            if (HotPin)\n                HotNode = HotPin->m_Node;\n        }\n\n        if (activeObject)\n        {\n            ActiveNode  = activeObject->AsNode();\n            ActivePin   = activeObject->AsPin();\n            ActiveLink  = activeObject->AsLink();\n        }\n\n        if (clickedObject)\n        {\n            ClickedNode  = clickedObject->AsNode();\n            ClickedPin   = clickedObject->AsPin();\n            ClickedLink  = clickedObject->AsLink();\n        }\n\n        if (doubleClickedObject)\n        {\n            DoubleClickedNode = doubleClickedObject->AsNode();\n            DoubleClickedPin  = doubleClickedObject->AsPin();\n            DoubleClickedLink = doubleClickedObject->AsLink();\n        }\n    }\n};\n\nstruct NavigateAction;\nstruct SizeAction;\nstruct DragAction;\nstruct SelectAction;\nstruct CreateItemAction;\nstruct DeleteItemsAction;\nstruct ContextMenuAction;\nstruct ShortcutAction;\n\nstruct AnimationController;\nstruct FlowAnimationController;\n\nstruct Animation\n{\n    enum State\n    {\n        Playing,\n        Stopped\n    };\n\n    EditorContext*  Editor;\n    State           m_State;\n    float           m_Time;\n    float           m_Duration;\n\n    Animation(EditorContext* editor);\n    virtual ~Animation();\n\n    void Play(float duration);\n    void Stop();\n    void Finish();\n    void Update();\n\n    bool IsPlaying() const { return m_State == Playing; }\n\n    float GetProgress() const { return m_Time / m_Duration; }\n\nprotected:\n    virtual void OnPlay() {}\n    virtual void OnFinish() {}\n    virtual void OnStop() {}\n\n    virtual void OnUpdate(float progress) { IM_UNUSED(progress); }\n};\n\nstruct NavigateAnimation final: Animation\n{\n    NavigateAction& Action;\n    ImRect      m_Start;\n    ImRect      m_Target;\n\n    NavigateAnimation(EditorContext* editor, NavigateAction& scrollAction);\n\n    void NavigateTo(const ImRect& target, float duration);\n\nprivate:\n    void OnUpdate(float progress) override final;\n    void OnStop() override final;\n    void OnFinish() override final;\n};\n\nstruct FlowAnimation final: Animation\n{\n    FlowAnimationController* Controller;\n    Link* m_Link;\n    float m_Speed;\n    float m_MarkerDistance;\n    float m_Offset;\n\n    FlowAnimation(FlowAnimationController* controller);\n\n    void Flow(Link* link, float markerDistance, float speed, float duration);\n\n    void Draw(ImDrawList* drawList);\n\nprivate:\n    struct CurvePoint\n    {\n        float  Distance;\n        ImVec2 Point;\n    };\n\n    ImVec2 m_LastStart;\n    ImVec2 m_LastEnd;\n    float  m_PathLength;\n    vector<CurvePoint> m_Path;\n\n    bool IsLinkValid() const;\n    bool IsPathValid() const;\n    void UpdatePath();\n    void ClearPath();\n\n    ImVec2 SamplePath(float distance) const;\n\n    void OnUpdate(float progress) override final;\n    void OnStop() override final;\n};\n\nstruct AnimationController\n{\n    EditorContext* Editor;\n\n    AnimationController(EditorContext* editor)\n        : Editor(editor)\n    {\n    }\n\n    virtual ~AnimationController()\n    {\n    }\n\n    virtual void Draw(ImDrawList* drawList)\n    {\n        IM_UNUSED(drawList);\n    }\n};\n\nstruct FlowAnimationController final : AnimationController\n{\n    FlowAnimationController(EditorContext* editor);\n    virtual ~FlowAnimationController();\n\n    void Flow(Link* link, FlowDirection direction = FlowDirection::Forward);\n\n    virtual void Draw(ImDrawList* drawList) override final;\n\n    void Release(FlowAnimation* animation);\n\nprivate:\n    FlowAnimation* GetOrCreate(Link* link);\n\n    vector<FlowAnimation*> m_Animations;\n    vector<FlowAnimation*> m_FreePool;\n};\n\nstruct EditorAction\n{\n    enum AcceptResult { False, True, Possible };\n\n    EditorAction(EditorContext* editor)\n        : Editor(editor)\n    {\n    }\n\n    virtual ~EditorAction() {}\n\n    virtual const char* GetName() const = 0;\n\n    virtual AcceptResult Accept(const Control& control) = 0;\n    virtual bool Process(const Control& control) = 0;\n    virtual void Reject() {} // celled when Accept return 'Possible' and was rejected\n\n    virtual ImGuiMouseCursor GetCursor() { return ImGuiMouseCursor_Arrow; }\n\n    virtual bool IsDragging() { return false; }\n\n    virtual void ShowMetrics() {}\n\n    virtual NavigateAction*     AsNavigate()     { return nullptr; }\n    virtual SizeAction*         AsSize()         { return nullptr; }\n    virtual DragAction*         AsDrag()         { return nullptr; }\n    virtual SelectAction*       AsSelect()       { return nullptr; }\n    virtual CreateItemAction*   AsCreateItem()   { return nullptr; }\n    virtual DeleteItemsAction*  AsDeleteItems()  { return nullptr; }\n    virtual ContextMenuAction*  AsContextMenu()  { return nullptr; }\n    virtual ShortcutAction* AsCutCopyPaste() { return nullptr; }\n\n    EditorContext* Editor;\n};\n\nstruct NavigateAction final: EditorAction\n{\n    enum class ZoomMode\n    {\n        None,\n        Exact,\n        WithMargin\n    };\n\n    enum class NavigationReason\n    {\n        Unknown,\n        MouseZoom,\n        Selection,\n        Object,\n        Content,\n        Edge\n    };\n\n    bool            m_IsActive;\n    float           m_Zoom;\n    ImRect          m_VisibleRect;\n    ImVec2          m_Scroll;\n    ImVec2          m_ScrollStart;\n    ImVec2          m_ScrollDelta;\n\n    NavigateAction(EditorContext* editor, ImGuiEx::Canvas& canvas);\n\n    virtual const char* GetName() const override final { return \"Navigate\"; }\n\n    virtual AcceptResult Accept(const Control& control) override final;\n    virtual bool Process(const Control& control) override final;\n\n    virtual void ShowMetrics() override final;\n\n    virtual NavigateAction* AsNavigate() override final { return this; }\n\n    void NavigateTo(const ImRect& bounds, ZoomMode zoomMode, float duration = -1.0f, NavigationReason reason = NavigationReason::Unknown);\n    void StopNavigation();\n    void FinishNavigation();\n\n    bool MoveOverEdge(const ImVec2& canvasSize);\n    void StopMoveOverEdge();\n    bool IsMovingOverEdge() const { return m_MovingOverEdge; }\n    ImVec2 GetMoveScreenOffset() const { return m_MoveScreenOffset; }\n\n    void SetWindow(ImVec2 position, ImVec2 size);\n    ImVec2 GetWindowScreenPos() const { return m_WindowScreenPos; };\n    ImVec2 GetWindowScreenSize() const { return m_WindowScreenSize; };\n\n    ImGuiEx::CanvasView GetView() const;\n    ImVec2 GetViewOrigin() const;\n    float GetViewScale() const;\n\n    void SetViewRect(const ImRect& rect);\n    ImRect GetViewRect() const;\n\nprivate:\n    ImGuiEx::Canvas&   m_Canvas;\n    ImVec2             m_WindowScreenPos;\n    ImVec2             m_WindowScreenSize;\n\n    NavigateAnimation  m_Animation;\n    NavigationReason   m_Reason;\n    uint64_t           m_LastSelectionId;\n    Object*            m_LastObject;\n    bool               m_MovingOverEdge;\n    ImVec2             m_MoveScreenOffset;\n\n    const float*       m_ZoomLevels;\n    int                m_ZoomLevelCount;\n\n    bool HandleZoom(const Control& control);\n\n    void NavigateTo(const ImRect& target, float duration = -1.0f, NavigationReason reason = NavigationReason::Unknown);\n\n    float GetNextZoom(float steps);\n    float MatchSmoothZoom(float steps);\n    float MatchZoom(int steps, float fallbackZoom);\n    int MatchZoomIndex(int direction);\n\n    static const float s_DefaultZoomLevels[];\n    static const int   s_DefaultZoomLevelCount;\n};\n\nstruct SizeAction final: EditorAction\n{\n    bool  m_IsActive;\n    bool  m_Clean;\n    Node* m_SizedNode;\n\n    SizeAction(EditorContext* editor);\n\n    virtual const char* GetName() const override final { return \"Size\"; }\n\n    virtual AcceptResult Accept(const Control& control) override final;\n    virtual bool Process(const Control& control) override final;\n\n    virtual ImGuiMouseCursor GetCursor() override final { return m_Cursor; }\n\n    virtual void ShowMetrics() override final;\n\n    virtual SizeAction* AsSize() override final { return this; }\n\n    virtual bool IsDragging() override final { return m_IsActive; }\n\n    const ImRect& GetStartGroupBounds() const { return m_StartGroupBounds; }\n\nprivate:\n    NodeRegion GetRegion(Node* node);\n    ImGuiMouseCursor ChooseCursor(NodeRegion region);\n\n    ImRect           m_StartBounds;\n    ImRect           m_StartGroupBounds;\n    ImVec2           m_LastSize;\n    ImVec2           m_MinimumSize;\n    ImVec2           m_LastDragOffset;\n    ed::NodeRegion   m_Pivot;\n    ImGuiMouseCursor m_Cursor;\n};\n\nstruct DragAction final: EditorAction\n{\n    bool            m_IsActive;\n    bool            m_Clear;\n    Object*         m_DraggedObject;\n    vector<Object*> m_Objects;\n\n    DragAction(EditorContext* editor);\n\n    virtual const char* GetName() const override final { return \"Drag\"; }\n\n    virtual AcceptResult Accept(const Control& control) override final;\n    virtual bool Process(const Control& control) override final;\n\n    virtual ImGuiMouseCursor GetCursor() override final { return ImGuiMouseCursor_ResizeAll; }\n\n    virtual bool IsDragging() override final { return m_IsActive; }\n\n    virtual void ShowMetrics() override final;\n\n    virtual DragAction* AsDrag() override final { return this; }\n};\n\nstruct SelectAction final: EditorAction\n{\n    bool            m_IsActive;\n\n    bool            m_SelectGroups;\n    bool            m_SelectLinkMode;\n    bool            m_CommitSelection;\n    ImVec2          m_StartPoint;\n    ImVec2          m_EndPoint;\n    vector<Object*> m_CandidateObjects;\n    vector<Object*> m_SelectedObjectsAtStart;\n\n    Animation       m_Animation;\n\n    SelectAction(EditorContext* editor);\n\n    virtual const char* GetName() const override final { return \"Select\"; }\n\n    virtual AcceptResult Accept(const Control& control) override final;\n    virtual bool Process(const Control& control) override final;\n\n    virtual void ShowMetrics() override final;\n\n    virtual bool IsDragging() override final { return m_IsActive; }\n\n    virtual SelectAction* AsSelect() override final { return this; }\n\n    void Draw(ImDrawList* drawList);\n};\n\nstruct ContextMenuAction final: EditorAction\n{\n    enum Menu { None, Node, Pin, Link, Background };\n\n    Menu m_CandidateMenu;\n    Menu m_CurrentMenu;\n    ObjectId m_ContextId;\n\n    ContextMenuAction(EditorContext* editor);\n\n    virtual const char* GetName() const override final { return \"Context Menu\"; }\n\n    virtual AcceptResult Accept(const Control& control) override final;\n    virtual bool Process(const Control& control) override final;\n    virtual void Reject() override final;\n\n    virtual void ShowMetrics() override final;\n\n    virtual ContextMenuAction* AsContextMenu() override final { return this; }\n\n    bool ShowNodeContextMenu(NodeId* nodeId);\n    bool ShowPinContextMenu(PinId* pinId);\n    bool ShowLinkContextMenu(LinkId* linkId);\n    bool ShowBackgroundContextMenu();\n};\n\nstruct ShortcutAction final: EditorAction\n{\n    enum Action { None, Cut, Copy, Paste, Duplicate, CreateNode };\n\n    bool            m_IsActive;\n    bool            m_InAction;\n    Action          m_CurrentAction;\n    vector<Object*> m_Context;\n\n    ShortcutAction(EditorContext* editor);\n\n    virtual const char* GetName() const override final { return \"Shortcut\"; }\n\n    virtual AcceptResult Accept(const Control& control) override final;\n    virtual bool Process(const Control& control) override final;\n    virtual void Reject() override final;\n\n    virtual void ShowMetrics() override final;\n\n    virtual ShortcutAction* AsCutCopyPaste() override final { return this; }\n\n    bool Begin();\n    void End();\n\n    bool AcceptCut();\n    bool AcceptCopy();\n    bool AcceptPaste();\n    bool AcceptDuplicate();\n    bool AcceptCreateNode();\n};\n\nstruct CreateItemAction final : EditorAction\n{\n    enum Stage\n    {\n        None,\n        Possible,\n        Create\n    };\n\n    enum Action\n    {\n        Unknown,\n        UserReject,\n        UserAccept\n    };\n\n    enum Type\n    {\n        NoItem,\n        Node,\n        Link\n    };\n\n    enum Result\n    {\n        True,\n        False,\n        Indeterminate\n    };\n\n    bool      m_InActive;\n    Stage     m_NextStage;\n\n    Stage     m_CurrentStage;\n    Type      m_ItemType;\n    Action    m_UserAction;\n    ImU32     m_LinkColor;\n    float     m_LinkThickness;\n    Pin*      m_LinkStart;\n    Pin*      m_LinkEnd;\n\n    bool      m_IsActive;\n    Pin*      m_DraggedPin;\n\n    int       m_LastChannel = -1;\n\n\n    CreateItemAction(EditorContext* editor);\n\n    virtual const char* GetName() const override final { return \"Create Item\"; }\n\n    virtual AcceptResult Accept(const Control& control) override final;\n    virtual bool Process(const Control& control) override final;\n\n    virtual ImGuiMouseCursor GetCursor() override final { return ImGuiMouseCursor_Arrow; }\n\n    virtual void ShowMetrics() override final;\n\n    virtual bool IsDragging() override final { return m_IsActive; }\n\n    virtual CreateItemAction* AsCreateItem() override final { return this; }\n\n    void SetStyle(ImU32 color, float thickness);\n\n    bool Begin();\n    void End();\n\n    Result RejectItem();\n    Result AcceptItem();\n\n    Result QueryLink(PinId* startId, PinId* endId);\n    Result QueryNode(PinId* pinId);\n\nprivate:\n    bool m_IsInGlobalSpace;\n\n    void DragStart(Pin* startPin);\n    void DragEnd();\n    void DropPin(Pin* endPin);\n    void DropNode();\n    void DropNothing();\n};\n\nstruct DeleteItemsAction final: EditorAction\n{\n    bool    m_IsActive;\n    bool    m_InInteraction;\n\n    DeleteItemsAction(EditorContext* editor);\n\n    virtual const char* GetName() const override final { return \"Delete Items\"; }\n\n    virtual AcceptResult Accept(const Control& control) override final;\n    virtual bool Process(const Control& control) override final;\n\n    virtual void ShowMetrics() override final;\n\n    virtual DeleteItemsAction* AsDeleteItems() override final { return this; }\n\n    bool Add(Object* object);\n\n    bool Begin();\n    void End();\n\n    bool QueryLink(LinkId* linkId, PinId* startId = nullptr, PinId* endId = nullptr);\n    bool QueryNode(NodeId* nodeId);\n\n    bool AcceptItem(bool deleteDependencies);\n    void RejectItem();\n\nprivate:\n    enum IteratorType { Unknown, Link, Node };\n    enum UserAction { Undetermined, Accepted, Rejected };\n\n    void DeleteDeadLinks(NodeId nodeId);\n    void DeleteDeadPins(NodeId nodeId);\n\n    bool QueryItem(ObjectId* itemId, IteratorType itemType);\n    void RemoveItem(bool deleteDependencies);\n    Object* DropCurrentItem();\n\n    vector<Object*> m_ManuallyDeletedObjects;\n\n    IteratorType    m_CurrentItemType;\n    UserAction      m_UserAction;\n    vector<Object*> m_CandidateObjects;\n    int             m_CandidateItemIndex;\n};\n\nstruct NodeBuilder\n{\n    EditorContext* const Editor;\n\n    Node* m_CurrentNode;\n    Pin*  m_CurrentPin;\n\n    ImRect m_NodeRect;\n\n    ImRect m_PivotRect;\n    ImVec2 m_PivotAlignment;\n    ImVec2 m_PivotSize;\n    ImVec2 m_PivotScale;\n    bool   m_ResolvePinRect;\n    bool   m_ResolvePivot;\n\n    ImRect m_GroupBounds;\n    bool   m_IsGroup;\n\n    ImDrawListSplitter m_Splitter;\n    ImDrawListSplitter m_PinSplitter;\n\n    NodeBuilder(EditorContext* editor);\n    ~NodeBuilder();\n\n    void Begin(NodeId nodeId);\n    void End();\n\n    void BeginPin(PinId pinId, PinKind kind);\n    void EndPin();\n\n    void PinRect(const ImVec2& a, const ImVec2& b);\n    void PinPivotRect(const ImVec2& a, const ImVec2& b);\n    void PinPivotSize(const ImVec2& size);\n    void PinPivotScale(const ImVec2& scale);\n    void PinPivotAlignment(const ImVec2& alignment);\n\n    void Group(const ImVec2& size);\n\n    ImDrawList* GetUserBackgroundDrawList() const;\n    ImDrawList* GetUserBackgroundDrawList(Node* node) const;\n};\n\nstruct HintBuilder\n{\n    EditorContext* const Editor;\n    bool  m_IsActive;\n    Node* m_CurrentNode;\n    float m_LastFringe = 1.0f;\n    int   m_LastChannel = 0;\n\n    HintBuilder(EditorContext* editor);\n\n    bool Begin(NodeId nodeId);\n    void End();\n\n    ImVec2 GetGroupMin();\n    ImVec2 GetGroupMax();\n\n    ImDrawList* GetForegroundDrawList();\n    ImDrawList* GetBackgroundDrawList();\n};\n\nstruct Style: ax::NodeEditor::Style\n{\n    void PushColor(StyleColor colorIndex, const ImVec4& color);\n    void PopColor(int count = 1);\n\n    void PushVar(StyleVar varIndex, float value);\n    void PushVar(StyleVar varIndex, const ImVec2& value);\n    void PushVar(StyleVar varIndex, const ImVec4& value);\n    void PopVar(int count = 1);\n\n    const char* GetColorName(StyleColor colorIndex) const;\n\nprivate:\n    struct ColorModifier\n    {\n        StyleColor  Index;\n        ImVec4      Value;\n    };\n\n    struct VarModifier\n    {\n        StyleVar Index;\n        ImVec4   Value;\n    };\n\n    float* GetVarFloatAddr(StyleVar idx);\n    ImVec2* GetVarVec2Addr(StyleVar idx);\n    ImVec4* GetVarVec4Addr(StyleVar idx);\n\n    vector<ColorModifier>   m_ColorStack;\n    vector<VarModifier>     m_VarStack;\n};\n\nstruct Config: ax::NodeEditor::Config\n{\n    Config(const ax::NodeEditor::Config* config);\n\n    std::string Load();\n    std::string LoadNode(NodeId nodeId);\n\n    void BeginSave();\n    bool Save(const std::string& data, SaveReasonFlags flags);\n    bool SaveNode(NodeId nodeId, const std::string& data, SaveReasonFlags flags);\n    void EndSave();\n};\n\nenum class SuspendFlags : uint8_t\n{\n    None = 0,\n    KeepSplitter = 1\n};\n\ninline SuspendFlags operator |(SuspendFlags lhs, SuspendFlags rhs) { return static_cast<SuspendFlags>(static_cast<uint8_t>(lhs) | static_cast<uint8_t>(rhs)); }\ninline SuspendFlags operator &(SuspendFlags lhs, SuspendFlags rhs) { return static_cast<SuspendFlags>(static_cast<uint8_t>(lhs) & static_cast<uint8_t>(rhs)); }\n\n\nstruct EditorContext\n{\n    EditorContext(const ax::NodeEditor::Config* config = nullptr);\n    ~EditorContext();\n\n    const Config& GetConfig() const { return m_Config; }\n\n    Style& GetStyle() { return m_Style; }\n\n    void Begin(const char* id, const ImVec2& size = ImVec2(0, 0));\n    void End();\n\n    bool DoLink(LinkId id, PinId startPinId, PinId endPinId, ImU32 color, float thickness);\n\n\n    NodeBuilder& GetNodeBuilder() { return m_NodeBuilder; }\n    HintBuilder& GetHintBuilder() { return m_HintBuilder; }\n\n    EditorAction* GetCurrentAction() { return m_CurrentAction; }\n\n    CreateItemAction& GetItemCreator() { return m_CreateItemAction; }\n    DeleteItemsAction& GetItemDeleter() { return m_DeleteItemsAction; }\n    ContextMenuAction& GetContextMenu() { return m_ContextMenuAction; }\n    ShortcutAction& GetShortcut() { return m_ShortcutAction; }\n\n    const ImGuiEx::CanvasView& GetView() const { return m_Canvas.View(); }\n    const ImRect& GetViewRect() const { return m_Canvas.ViewRect(); }\n    const ImRect& GetRect() const { return m_Canvas.Rect(); }\n\n    void SetNodePosition(NodeId nodeId, const ImVec2& screenPosition);\n    void SetGroupSize(NodeId nodeId, const ImVec2& size);\n    ImVec2 GetNodePosition(NodeId nodeId);\n    ImVec2 GetNodeSize(NodeId nodeId);\n\n    void SetNodeZPosition(NodeId nodeId, float z);\n    float GetNodeZPosition(NodeId nodeId);\n\n    void MarkNodeToRestoreState(Node* node);\n    void UpdateNodeState(Node* node);\n\n    void RemoveSettings(Object* object);\n\n    void ClearSelection();\n    void SelectObject(Object* object);\n    void DeselectObject(Object* object);\n    void SetSelectedObject(Object* object);\n    void ToggleObjectSelection(Object* object);\n    bool IsSelected(Object* object);\n    const vector<Object*>& GetSelectedObjects();\n    bool IsAnyNodeSelected();\n    bool IsAnyLinkSelected();\n    bool HasSelectionChanged();\n    uint64_t GetSelectionId() const { return m_SelectionId; }\n\n    Node* FindNodeAt(const ImVec2& p);\n    void FindNodesInRect(const ImRect& r, vector<Node*>& result, bool append = false, bool includeIntersecting = true);\n    void FindLinksInRect(const ImRect& r, vector<Link*>& result, bool append = false);\n\n    bool HasAnyLinks(NodeId nodeId) const;\n    bool HasAnyLinks(PinId pinId) const;\n\n    int BreakLinks(NodeId nodeId);\n    int BreakLinks(PinId pinId);\n\n    void FindLinksForNode(NodeId nodeId, vector<Link*>& result, bool add = false);\n\n    bool PinHadAnyLinks(PinId pinId);\n\n    ImVec2 ToCanvas(const ImVec2& point) const { return m_Canvas.ToLocal(point); }\n    ImVec2 ToScreen(const ImVec2& point) const { return m_Canvas.FromLocal(point); }\n\n    void NotifyLinkDeleted(Link* link);\n\n    void Suspend(SuspendFlags flags = SuspendFlags::None);\n    void Resume(SuspendFlags flags = SuspendFlags::None);\n    bool IsSuspended();\n\n    bool IsFocused();\n    bool IsHovered() const;\n    bool IsHoveredWithoutOverlapp() const;\n    bool CanAcceptUserInput() const;\n\n    void MakeDirty(SaveReasonFlags reason);\n    void MakeDirty(SaveReasonFlags reason, Node* node);\n\n    int CountLiveNodes() const;\n    int CountLivePins() const;\n    int CountLiveLinks() const;\n\n    Pin*    CreatePin(PinId id, PinKind kind);\n    Node*   CreateNode(NodeId id);\n    Link*   CreateLink(LinkId id);\n\n    Node*   FindNode(NodeId id);\n    Pin*    FindPin(PinId id);\n    Link*   FindLink(LinkId id);\n    Object* FindObject(ObjectId id);\n\n    Node*  GetNode(NodeId id);\n    Pin*   GetPin(PinId id, PinKind kind);\n    Link*  GetLink(LinkId id);\n\n    Link* FindLinkAt(const ImVec2& p);\n\n    template <typename T>\n    ImRect GetBounds(const std::vector<T*>& objects)\n    {\n        ImRect bounds(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);\n\n        for (auto object : objects)\n            if (object->m_IsLive)\n                bounds.Add(object->GetBounds());\n\n        if (ImRect_IsEmpty(bounds))\n            bounds = ImRect();\n\n        return bounds;\n    }\n\n    template <typename T>\n    ImRect GetBounds(const std::vector<ObjectWrapper<T>>& objects)\n    {\n        ImRect bounds(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);\n\n        for (auto object : objects)\n            if (object.m_Object->m_IsLive)\n                bounds.Add(object.m_Object->GetBounds());\n\n        if (ImRect_IsEmpty(bounds))\n            bounds = ImRect();\n\n        return bounds;\n    }\n\n    ImRect GetSelectionBounds() { return GetBounds(m_SelectedObjects); }\n    ImRect GetContentBounds() { return GetBounds(m_Nodes); }\n\n    ImU32 GetColor(StyleColor colorIndex) const;\n    ImU32 GetColor(StyleColor colorIndex, float alpha) const;\n\n    int GetNodeIds(NodeId* nodes, int size) const;\n\n    void NavigateTo(const ImRect& bounds, bool zoomIn = false, float duration = -1)\n    {\n        auto zoomMode = zoomIn ? NavigateAction::ZoomMode::WithMargin : NavigateAction::ZoomMode::None;\n        m_NavigateAction.NavigateTo(bounds, zoomMode, duration);\n    }\n\n    void RegisterAnimation(Animation* animation);\n    void UnregisterAnimation(Animation* animation);\n\n    void Flow(Link* link, FlowDirection direction);\n\n    void SetUserContext(bool globalSpace = false);\n\n    void EnableShortcuts(bool enable);\n    bool AreShortcutsEnabled();\n\n    NodeId GetHoveredNode()            const { return m_HoveredNode;             }\n    PinId  GetHoveredPin()             const { return m_HoveredPin;              }\n    LinkId GetHoveredLink()            const { return m_HoveredLink;             }\n    NodeId GetDoubleClickedNode()      const { return m_DoubleClickedNode;       }\n    PinId  GetDoubleClickedPin()       const { return m_DoubleClickedPin;        }\n    LinkId GetDoubleClickedLink()      const { return m_DoubleClickedLink;       }\n    bool   IsBackgroundClicked()                           const { return m_BackgroundClickButtonIndex >= 0; }\n    bool   IsBackgroundDoubleClicked()                     const { return m_BackgroundDoubleClickButtonIndex >= 0; }\n    ImGuiMouseButton GetBackgroundClickButtonIndex()       const { return m_BackgroundClickButtonIndex; }\n    ImGuiMouseButton GetBackgroundDoubleClickButtonIndex() const { return m_BackgroundDoubleClickButtonIndex; }\n\n    float AlignPointToGrid(float p) const\n    {\n        if (!ImGui::GetIO().KeyAlt)\n            return p - ImFmod(p, 16.0f);\n        else\n            return p;\n    }\n\n    ImVec2 AlignPointToGrid(const ImVec2& p) const\n    {\n        return ImVec2(AlignPointToGrid(p.x), AlignPointToGrid(p.y));\n    }\n\n    ImDrawList* GetDrawList() { return m_DrawList; }\n\nprivate:\n    void LoadSettings();\n    void SaveSettings();\n\n    Control BuildControl(bool allowOffscreen);\n\n    void ShowMetrics(const Control& control);\n\n    void UpdateAnimations();\n\n    Config              m_Config;\n\n    ImGuiID             m_EditorActiveId;\n    bool                m_IsFirstFrame;\n    bool                m_IsFocused;\n    bool                m_IsHovered;\n    bool                m_IsHoveredWithoutOverlapp;\n\n    bool                m_ShortcutsEnabled;\n\n    Style               m_Style;\n\n    vector<ObjectWrapper<Node>> m_Nodes;\n    vector<ObjectWrapper<Pin>>  m_Pins;\n    vector<ObjectWrapper<Link>> m_Links;\n\n    vector<Object*>     m_SelectedObjects;\n\n    vector<Object*>     m_LastSelectedObjects;\n    uint64_t            m_SelectionId;\n\n    Link*               m_LastActiveLink;\n\n    vector<Animation*>  m_LiveAnimations;\n    vector<Animation*>  m_LastLiveAnimations;\n\n    ImGuiEx::Canvas     m_Canvas;\n    bool                m_IsCanvasVisible;\n\n    NodeBuilder         m_NodeBuilder;\n    HintBuilder         m_HintBuilder;\n\n    EditorAction*       m_CurrentAction;\n    NavigateAction      m_NavigateAction;\n    SizeAction          m_SizeAction;\n    DragAction          m_DragAction;\n    SelectAction        m_SelectAction;\n    ContextMenuAction   m_ContextMenuAction;\n    ShortcutAction      m_ShortcutAction;\n    CreateItemAction    m_CreateItemAction;\n    DeleteItemsAction   m_DeleteItemsAction;\n\n    vector<AnimationController*> m_AnimationControllers;\n    FlowAnimationController      m_FlowAnimationController;\n\n    NodeId              m_HoveredNode;\n    PinId               m_HoveredPin;\n    LinkId              m_HoveredLink;\n    NodeId              m_DoubleClickedNode;\n    PinId               m_DoubleClickedPin;\n    LinkId              m_DoubleClickedLink;\n    int                 m_BackgroundClickButtonIndex;\n    int                 m_BackgroundDoubleClickButtonIndex;\n\n    bool                m_IsInitialized;\n    Settings            m_Settings;\n\n    ImDrawList*         m_DrawList;\n    int                 m_ExternalChannel;\n    ImDrawListSplitter  m_Splitter;\n};\n\n\n//------------------------------------------------------------------------------\n} // namespace Detail\n} // namespace Editor\n} // namespace ax\n\n\n//------------------------------------------------------------------------------\n# include \"imgui_node_editor_internal.inl\"\n\n\n//------------------------------------------------------------------------------\n# endif // __IMGUI_NODE_EDITOR_INTERNAL_H__\n"
        },
        {
          "name": "imgui_node_editor_internal.inl",
          "type": "blob",
          "size": 1.7841796875,
          "content": "//------------------------------------------------------------------------------\n// VERSION 0.9.1\n//\n// LICENSE\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// CREDITS\n//   Written by Michal Cichon\n//------------------------------------------------------------------------------\n# ifndef __IMGUI_NODE_EDITOR_INTERNAL_INL__\n# define __IMGUI_NODE_EDITOR_INTERNAL_INL__\n# pragma once\n\n\n//------------------------------------------------------------------------------\n# include \"imgui_node_editor_internal.h\"\n\n\n//------------------------------------------------------------------------------\nnamespace ax {\nnamespace NodeEditor {\nnamespace Detail {\n\n\n//------------------------------------------------------------------------------\n//inline ImRect ToRect(const ax::rectf& rect)\n//{\n//    return ImRect(\n//        to_imvec(rect.top_left()),\n//        to_imvec(rect.bottom_right())\n//    );\n//}\n//\n//inline ImRect ToRect(const ax::rect& rect)\n//{\n//    return ImRect(\n//        to_imvec(rect.top_left()),\n//        to_imvec(rect.bottom_right())\n//    );\n//}\n\ninline ImRect ImGui_GetItemRect()\n{\n    return ImRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax());\n}\n\ninline ImVec2 ImGui_GetMouseClickPos(ImGuiMouseButton buttonIndex)\n{\n    if (ImGui::IsMouseDown(buttonIndex))\n        return ImGui::GetIO().MouseClickedPos[buttonIndex];\n    else\n        return ImGui::GetMousePos();\n}\n\n\n//------------------------------------------------------------------------------\n} // namespace Detail\n} // namespace Editor\n} // namespace ax\n\n\n//------------------------------------------------------------------------------\n# endif // __IMGUI_NODE_EDITOR_INTERNAL_INL__\n"
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}