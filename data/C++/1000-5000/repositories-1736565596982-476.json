{
  "metadata": {
    "timestamp": 1736565596982,
    "page": 476,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "BinomialLLC/basis_universal",
      "stars": 2751,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1015625,
          "content": "build/\n\n# VS project and working files\n*.vcxproj.user\n.vs/\nDebug/\nRelease/\nx64/\n\n# Mac finder\n.DS_Store\n"
        },
        {
          "name": ".reuse",
          "type": "tree",
          "content": null
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 10.2744140625,
          "content": "# Important: The Basis Universal encoder and transcoder libraries must be compiled with -fno-strict-aliasing (MSVC's default, and also the Linux kernel).\n# It should also work without this option, but we do not test with it.\ncmake_minimum_required(VERSION 3.5)\n\nproject(basisu)\noption(STATIC \"static linking\" FALSE)\noption(SAN \"sanitize\" FALSE)\n\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)\n\n# For MSVC builds default to SSE enabled, and determine if it's a 64-bit (-A x64) vs. 32-bit (-A Win32) build.\nif (MSVC)\n    option(SSE \"SSE 4.1 support\" TRUE)\n    if ( CMAKE_GENERATOR_PLATFORM STREQUAL Win32 )    \n        set(BUILD_X64 0)\n    else()\n        set(BUILD_X64 1)\n    endif()\n\tadd_compile_options(/W4)\nelse()\n    option(SSE \"SSE 4.1 support\" FALSE)\n    option(BUILD_X64 \"build 64-bit\" TRUE)\nendif()\n\noption(ZSTD \"ZSTD support for KTX2 transcoding/encoding\" TRUE)\noption(OPENCL \"OpenCL support in encoder\" FALSE)\n\nmessage(\"Initial BUILD_X64=${BUILD_X64}\")\nmessage(\"Initial CMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}\")\nmessage(\"Initial SSE=${SSE}\")\nmessage(\"Initial ZSTD=${ZSTD}\")\nmessage(\"Initial OPENCL=${OPENCL}\")\nmessage(\"Initial SAN=${SAN}\")\n\nif ((NOT MSVC) AND OPENCL)\n    # With MSVC builds we use the Khronos lib/include files in the project's \"OpenCL\" directory, to completely avoid requiring fiddly to install vendor SDK's.\n    # Otherwise we use the system's (if any).\n    find_package(OpenCL)\n    message(STATUS \"OpenCL found: ${OPENCL_FOUND}\")\n    message(STATUS \"OpenCL includes: ${OpenCL_INCLUDE_DIRS}\")\n    message(STATUS \"OpenCL libraries: ${OpenCL_LIBRARIES}\")\nendif()\n\nif( NOT CMAKE_BUILD_TYPE )\n  set( CMAKE_BUILD_TYPE Release )\nendif()\n\nmessage(${PROJECT_NAME} \" build type: \" ${CMAKE_BUILD_TYPE})\n\nif (BUILD_X64)\n    message(\"Building 64-bit\")\nelse()\n    message(\"Building 32-bit\")\nendif()\n\nif (SSE)\n    message(\"SSE enabled\")\nelse()\n    message(\"SSE disabled\")\nendif()\n\nif (ZSTD)\n    message(\"Zstandard enabled\")\nelse()\n    message(\"Zstandard disabled\")\nendif()\n\nif (NOT MSVC)\n    set(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG} -g\")\n    set(CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG} -g\")\n   \n    set(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE}\")\n    set(CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE}\")\n\n    if (SAN)\n\t\tmessage(\"Enabling SAN\")\n\t\t\n\t\tset(SANITIZE_FLAGS \"-fsanitize=address -fno-omit-frame-pointer -fsanitize=undefined -fno-sanitize=alignment\")\n\t\t\n\t\tset(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG} ${SANITIZE_FLAGS}\")\n        set(CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG} ${SANITIZE_FLAGS}\")\n\t\n        set(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} ${SANITIZE_FLAGS}\")\n        set(CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE} ${SANITIZE_FLAGS}\")\n    endif()\n\n    set(CMAKE_CXX_FLAGS -std=c++11)\n    set(GCC_COMPILE_FLAGS \"-fvisibility=hidden -fPIC -fno-strict-aliasing -D_LARGEFILE64_SOURCE=1 -D_FILE_OFFSET_BITS=64 -Wall -Wextra -Wno-unused-local-typedefs -Wno-unused-value -Wno-unused-parameter -Wno-unused-variable -Wno-misleading-indentation -Wno-maybe-uninitialized -Wno-unused-function -Wno-stringop-overflow -Wno-unknown-warning-option\")\n    set(GCC_CXX_COMPILE_FLAGS \"-fvisibility=hidden -fPIC -fno-strict-aliasing -D_LARGEFILE64_SOURCE=1 -D_FILE_OFFSET_BITS=64 -Wall -Wextra -Wno-unused-local-typedefs -Wno-unused-value -Wno-unused-parameter -Wno-unused-variable -Wno-reorder -Wno-misleading-indentation -Wno-class-memaccess -Wno-deprecated-copy -Wno-maybe-uninitialized -Wno-unused-function -Wno-stringop-overflow -Wno-unknown-warning-option\")\n   \n    if (NOT BUILD_X64)\n        set(GCC_COMPILE_FLAGS \"${GCC_COMPILE_FLAGS} -m32\")\n        set(GCC_CXX_COMPILE_FLAGS \"${GCC_CXX_COMPILE_FLAGS} -m32\")\n    endif()\n\n    if (EMSCRIPTEN)\n        set(CMAKE_C_FLAGS  \"${CMAKE_C_FLAGS} -s ALLOW_MEMORY_GROWTH=1 -DBASISU_SUPPORT_SSE=0\")\n        set(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -s ALLOW_MEMORY_GROWTH=1 -DBASISU_SUPPORT_SSE=0\")\n\n        set(CMAKE_EXE_LINKER_FLAGS  \"${CMAKE_EXE_LINKER_FLAGS} ${GCC_LINK_FLAGS}\")\n    elseif (STATIC)\n        if (SSE)\n            set(CMAKE_C_FLAGS  \"${CMAKE_C_FLAGS} -DBASISU_SUPPORT_SSE=1 -msse4.1\")\n            set(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -DBASISU_SUPPORT_SSE=1 -msse4.1\")\n        else()\n            set(CMAKE_C_FLAGS  \"${CMAKE_C_FLAGS} -DBASISU_SUPPORT_SSE=0\")\n            set(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -DBASISU_SUPPORT_SSE=0\")\n        endif()\n      \n        set(CMAKE_EXE_LINKER_FLAGS  \"${CMAKE_EXE_LINKER_FLAGS} ${GCC_LINK_FLAGS} -static-libgcc -static-libstdc++ -static\")\n    else()\n        if (SSE)\n            set(CMAKE_C_FLAGS  \"${CMAKE_C_FLAGS} -DBASISU_SUPPORT_SSE=1 -msse4.1\")\n            set(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -DBASISU_SUPPORT_SSE=1 -msse4.1\")\n        else()\n            set(CMAKE_C_FLAGS  \"${CMAKE_C_FLAGS} -DBASISU_SUPPORT_SSE=0\")\n            set(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -DBASISU_SUPPORT_SSE=0\")\n        endif()\n      \n        set(CMAKE_EXE_LINKER_FLAGS  \"${CMAKE_EXE_LINKER_FLAGS} ${GCC_LINK_FLAGS} -Wl,-rpath .\")\n    endif()\n\n    set(CMAKE_C_FLAGS  \"${CMAKE_C_FLAGS} ${GCC_COMPILE_FLAGS}\")\n    set(CMAKE_C_FLAGS_RELEASE  \"${CMAKE_C_FLAGS_RELEASE} ${GCC_COMPILE_FLAGS}\")\n    set(CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG} ${GCC_COMPILE_FLAGS} -D_DEBUG\")\n\n    set(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} ${GCC_CXX_COMPILE_FLAGS}\")\n    set(CMAKE_CXX_FLAGS_RELEASE  \"${CMAKE_CXX_FLAGS_RELEASE} ${GCC_CXX_COMPILE_FLAGS}\")\n    set(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG} ${GCC_CXX_COMPILE_FLAGS} -D_DEBUG\")\nelse()\n    if (SSE)\n        set(CMAKE_C_FLAGS  \"${CMAKE_C_FLAGS} -DBASISU_SUPPORT_SSE=1\")\n        set(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -DBASISU_SUPPORT_SSE=1\")\n    else()\n        set(CMAKE_C_FLAGS  \"${CMAKE_C_FLAGS} -DBASISU_SUPPORT_SSE=0\")\n        set(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -DBASISU_SUPPORT_SSE=0\")\n    endif()\nendif()\n\n# Define the source files for the static library\nset(ENCODER_LIB_SRC_LIST\n    encoder/basisu_backend.cpp\n    encoder/basisu_basis_file.cpp\n    encoder/basisu_comp.cpp\n    encoder/basisu_enc.cpp\n    encoder/basisu_etc.cpp\n    encoder/basisu_frontend.cpp\n    encoder/basisu_gpu_texture.cpp\n    encoder/basisu_pvrtc1_4.cpp\n    encoder/basisu_resampler.cpp\n    encoder/basisu_resample_filters.cpp\n    encoder/basisu_ssim.cpp\n    encoder/basisu_uastc_enc.cpp\n    encoder/basisu_bc7enc.cpp\n    encoder/jpgd.cpp\n    encoder/basisu_kernels_sse.cpp\n    encoder/basisu_opencl.cpp\n    encoder/pvpngreader.cpp\n    encoder/basisu_astc_hdr_enc.cpp\n\tencoder/3rdparty/android_astc_decomp.cpp\n    encoder/3rdparty/tinyexr.cpp\n    transcoder/basisu_transcoder.cpp\n)\n\nif (ZSTD)\n    set(ENCODER_LIB_SRC_LIST ${ENCODER_LIB_SRC_LIST} zstd/zstd.c)\nendif()\n\n# Create the static library\nadd_library(basisu_encoder STATIC ${ENCODER_LIB_SRC_LIST})\n\n# Create the basisu executable and link against the static library\nadd_executable(basisu basisu_tool.cpp)\ntarget_link_libraries(basisu PRIVATE basisu_encoder)\n\n# Create the new example executable and link against the static library\nadd_executable(examples example/example.cpp)\ntarget_link_libraries(examples PRIVATE basisu_encoder)\n\nif (ZSTD)\n    target_compile_definitions(basisu PRIVATE BASISD_SUPPORT_KTX2_ZSTD=1)\n    target_compile_definitions(examples PRIVATE BASISD_SUPPORT_KTX2_ZSTD=1)\nelse()\n    target_compile_definitions(basisu PRIVATE BASISD_SUPPORT_KTX2_ZSTD=0)\n    target_compile_definitions(examples PRIVATE BASISD_SUPPORT_KTX2_ZSTD=0)\nendif()\n\nif (NOT MSVC)\n    # For Non-Windows builds, let cmake try and find the system OpenCL headers/libs for us.\n    if (OPENCL AND OPENCL_FOUND)\n        set(CMAKE_C_FLAGS  \"${CMAKE_C_FLAGS} -DBASISU_SUPPORT_OPENCL=1\")\n        set(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -DBASISU_SUPPORT_OPENCL=1\")    \n        \n        target_include_directories(basisu PRIVATE ${OpenCL_INCLUDE_DIRS})\n        target_include_directories(examples PRIVATE ${OpenCL_INCLUDE_DIRS})\n\t\ttarget_include_directories(basisu_encoder PRIVATE ${OpenCL_INCLUDE_DIRS})\n        set(BASISU_EXTRA_LIBS ${OpenCL_LIBRARIES})\n    endif()\nelse()\n    # For Windows builds, we use our local copies of the OpenCL import lib and Khronos headers.\n    if (OPENCL)\n        set(CMAKE_C_FLAGS  \"${CMAKE_C_FLAGS} -DBASISU_SUPPORT_OPENCL=1\")\n        set(CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} -DBASISU_SUPPORT_OPENCL=1\")    \n        \n        target_include_directories(basisu PRIVATE \"OpenCL\")\n        target_include_directories(examples PRIVATE \"OpenCL\")\n\t\ttarget_include_directories(basisu_encoder PRIVATE \"OpenCL\")\n\n        if (BUILD_X64)\n            target_link_libraries(basisu PRIVATE \"${CMAKE_SOURCE_DIR}/OpenCL/lib/OpenCL64.lib\")\n            target_link_libraries(examples PRIVATE \"${CMAKE_SOURCE_DIR}/OpenCL/lib/OpenCL64.lib\")\n        else()\n            target_link_libraries(basisu PRIVATE \"${CMAKE_SOURCE_DIR}/OpenCL/lib/OpenCL.lib\")\n            target_link_libraries(examples PRIVATE \"${CMAKE_SOURCE_DIR}/OpenCL/lib/OpenCL.lib\")\n        endif()\n    endif()\nendif()    \n\nif (NOT MSVC)\n    target_link_libraries(basisu PRIVATE m pthread ${BASISU_EXTRA_LIBS})\n    target_link_libraries(examples PRIVATE m pthread ${BASISU_EXTRA_LIBS})\nendif()\n\nif (NOT EMSCRIPTEN)\n    if (UNIX)\n        if (CMAKE_BUILD_TYPE STREQUAL Release)\n            if (APPLE)\n                add_custom_command(TARGET basisu POST_BUILD COMMAND strip -X -x ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/basisu)\n\t\t\t\t#message(\"strip command: strip -X -x ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/basisu\")\n            else()\n                add_custom_command(TARGET basisu POST_BUILD COMMAND strip -g -X -x ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/basisu)\n\t\t\t\t#message(\"strip command: strip -g -X -x ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/basisu\")\n            endif()\n        endif()\n    endif()\nendif()\n\nif (MSVC)\n\tset_target_properties(basisu PROPERTIES \n        RUNTIME_OUTPUT_NAME \"basisu\"\n        RUNTIME_OUTPUT_DIRECTORY_DEBUG ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\n        RUNTIME_OUTPUT_DIRECTORY_RELEASE ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\n        RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\n        RUNTIME_OUTPUT_DIRECTORY_MINSIZEREL ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\n    )\t\n\t\n\tset_target_properties(examples PROPERTIES \n        RUNTIME_OUTPUT_NAME \"examples\"\n        RUNTIME_OUTPUT_DIRECTORY_DEBUG ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\n        RUNTIME_OUTPUT_DIRECTORY_RELEASE ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\n        RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\n        RUNTIME_OUTPUT_DIRECTORY_MINSIZEREL ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\n    )\t\nendif()\n"
        },
        {
          "name": "CppProperties.json",
          "type": "blob",
          "size": 0.35546875,
          "content": "{\n  \"configurations\": [\n    {\n      \"inheritEnvironments\": [\n        \"msvc_x64\"\n      ],\n      \"name\": \"x64-Release\",\n      \"includePath\": [\n        \"${env.INCLUDE}\",\n        \"${workspaceRoot}\\\\**\"\n      ],\n      \"defines\": [\n        \"WIN32\",\n        \"NDEBUG\",\n        \"UNICODE\",\n        \"_UNICODE\"\n      ],\n      \"intelliSenseMode\": \"windows-msvc-x64\"\n    }\n  ]\n}"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "LICENSES",
          "type": "tree",
          "content": null
        },
        {
          "name": "OpenCL",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.162109375,
          "content": "# basis_universal\nAn LDR/HDR portable GPU compressed texture transcoding system.\n\n[![Build status](https://ci.appveyor.com/api/projects/status/87eb0o96pjho4sh0?svg=true)](https://ci.appveyor.com/project/BinomialLLC/basis-universal)\n\n----\n\nIntro\n-----\n\nBasis Universal is an open source [supercompressed](http://gamma.cs.unc.edu/GST/gst.pdf) LDR/HDR GPU compressed texture interchange system from Binomial LLC that supports two intermediate file formats: the [.KTX2 open standard from the Khronos Group](https://registry.khronos.org/KTX/specs/2.0/ktxspec.v2.html), and our own \".basis\" file format. These file formats support rapid transcoding to virtually any compressed [GPU texture format](https://en.wikipedia.org/wiki/Texture_compression) released in the past ~25 years. \n\nOur overall goal with this project is to simplify the encoding and efficient distribution of *portable* LDR and HDR GPU texture, image, and texture video content in a way that is compatible with any GPU or rendering/graphics API.\n\nThe system supports three modes: ETC1S, UASTC LDR, and UASTC HDR. The C/C++ encoder and transcoder libaries can be compiled to native code or WebAssembly, and all encoder/transcoder features can be accessed from Javascript.\n\nLinks\n-----\n\n- [Release Notes](https://github.com/BinomialLLC/basis_universal/wiki/Release-Notes)\n\n- [Live Encoder/Transcoder WebGL Examples](https://subquantumtech.com/uastchdr2/) \n\n- [Javascript API/WASM/WebGL info](https://github.com/BinomialLLC/basis_universal/tree/master/webgl)\n\n- [UASTC HDR Example Images](https://github.com/BinomialLLC/basis_universal/wiki/UASTC-HDR-Examples)\n\nSupported LDR GPU Texture Formats\n---------------------------------\n\nETC1S and UASTC LDR files can be transcoded to:\n\n- ASTC LDR 4x4 L/LA/RGB/RGBA 8bpp\n- BC1-5 RGB/RGBA/X/XY\n- BC7 RGB/RGBA\n- ETC1 RGB, ETC2 RGBA, and ETC2 EAC R11/RG11\n- PVRTC1 4bpp RGB/RGBA and PVRTC2 RGB/RGBA\n- ATC RGB/RGBA and FXT1 RGB\n- Uncompressed LDR raster image formats: 8888/565/4444\n\nSupported HDR GPU Texture Formats\n---------------------------------\n\nUASTC HDR files can be transcoded to:\n- ASTC HDR 4x4 RGB 8bpp\n- BC6H RGB\n- Uncompressed HDR raster image formats: RGB_16F/RGBA_16F (half float/FP16 RGB, 48 or 64bpp), 32-bit shared exponent [RGB_9E5](https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_shared_exponent.txt)\n\nSupported Texture Compression Modes\n-----------------------------------\n\n1. [ETC1S](https://github.com/BinomialLLC/basis_universal/wiki/.basis-File-Format-and-ETC1S-Texture-Video-Specification): A roughly .3-3bpp low to medium quality supercompressed mode based off a subset of ETC1 called \"ETC1S\". This mode supports variable quality vs. file size levels (like JPEG), alpha channels, built-in compression, and texture arrays optionally compressed as a video sequence using skip blocks ([Conditional Replenishment](https://en.wikipedia.org/wiki/MPEG-1)). This mode can be rapidly transcoded to all of the supported LDR texture formats.\n\n2. [UASTC LDR](https://richg42.blogspot.com/2020/01/uastc-block-format-encoding.html): An 8 bits/pixel LDR high quality mode. UASTC LDR is a 19 mode subset of the standard [ASTC LDR](https://en.wikipedia.org/wiki/Adaptive_scalable_texture_compression) 4x4 (8bpp) texture format, but with a custom block format containing transcoding hints. Transcoding UASTC LDR to ASTC LDR and BC7 are particularly fast and simple, because UASTC LDR is a common subset of both BC7 and ASTC. The transcoders for the other texture formats are accelerated by several format-specific hint bits present in each UASTC LDR block.\n\nThis mode supports an optional [Rate-Distortion Optimizated (RDO)](https://en.wikipedia.org/wiki/Rate%E2%80%93distortion_optimization) post-process stage that conditions the encoded UASTC LDR texture data in the .KTX2/.basis file so it can be more effectively LZ compressed. More details [here](https://github.com/BinomialLLC/basis_universal/wiki/UASTC-implementation-details).\n\nHere is the [UASTC LDR specification document](https://github.com/BinomialLLC/basis_universal/wiki/UASTC-Texture-Specification).\n\n3. [UASTC HDR](https://github.com/BinomialLLC/basis_universal/wiki/UASTC-HDR-Texture-Specification-v1.0): An 8 bits/pixel HDR high quality mode. This is a 24 mode subset of the standard [ASTC HDR](https://en.wikipedia.org/wiki/Adaptive_scalable_texture_compression) 4x4 (8bpp) texture format. It's designed to be high quality, supporting the 27 partition patterns in common between BC6H and ASTC, and fast to transcode with very little loss (typically a fraction of a dB PSNR) to the BC6H HDR texture format. Notably, **UASTC HDR data is 100% standard ASTC texture data**, so no transcoding at all is required on devices or API's supporting ASTC HDR. This mode can also be transcoded to various 32-64bpp uncompressed HDR texture/image formats.\n\nHere is the [UASTC HDR specification document](https://github.com/BinomialLLC/basis_universal/wiki/UASTC-HDR-Texture-Specification-v1.0), and some compressed [example images](https://github.com/BinomialLLC/basis_universal/wiki/UASTC-HDR-Examples).\n\n### Other Features\n\nBoth .basis and .KTX2 files support mipmap levels, texture arrays, cubemaps, cubemap arrays, and texture video, in all three modes. Additionally, .basis files support non-uniform texture arrays, where each image in the file can have a different resolution or number of mipmap levels.\n\nIn ETC1S mode, the compressor is able to exploit color and pattern correlations across all the images in the entire file using global endpoint/selector codebooks, so multiple images with mipmaps can be stored efficiently in a single file. The ETC1S mode also supports short video sequences, with skip blocks (Conditional Replenishment) used to not send blocks which haven't changed relative to the previous frame.\n\nThe LDR image formats supported for reading are .PNG, [.DDS with mipmaps](https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide), .TGA, .QOI, and .JPG. The HDR image formats supported for reading are .EXR, .HDR, and .DDS with mipmaps. It can write .basis, .KTX2, .DDS, .KTX (v1), .ASTC, .OUT, .EXR, and .PNG files.\n\nThe system now supports loading basic 2D .DDS files with optional mipmaps, but the .DDS file must be in one of the supported uncompressed formats: 24bpp RGB, 32bpp RGBA/BGRA, half-float RGBA, or float RGBA. Using .DDS files allows the user to control exactly how the mipmaps are generated before compression.\n\nBuilding\n--------\n\nThe encoding library and command line tool have no required 3rd party dependencies that are not already in the repo itself. The transcoder is a single .cpp source file (in `transcoder/basisu_transcoder.cpp`) which has no 3rd party dependencies.\n\nWe build and test under:\n- Windows x86/x64 using Visual Studio 2019/2022, MSVC, or clang\n- Mac OSX (M1) with clang v15.0\n- Ubuntu Linux with gcc v11.4 or clang v14\n- Arch Linux ARM, on a [Pinebook Pro](https://pine64.org/devices/pinebook_pro/), with gcc v12.1.\n\nUnder Windows with Visual Studio you can use the included `basisu.sln` file. Alternatively, you can use cmake to create new VS solution/project files.\n\nTo build, first [install cmake](https://cmake.org/), then:\n\n```\ncd build\ncmake ..\nmake\n```\n\nTo build with SSE 4.1 support on x86/x64 systems (encoding is roughly 15-30% faster), add `-DSSE=TRUE` to the cmake command line. Add `-DOPENCL=TRUE` to build with (optional) OpenCL support. Use `-DCMAKE_BUILD_TYPE=Debug` to build in debug. To build 32-bit executables, add `-DBUILD_X64=FALSE`.\n\nAfter building, the native command line tool used to create, validate, and transcode/unpack .basis/.KTX2 files is `bin/basisu`.\n\n### Testing the Codec\n\nThe command line tool includes some automated LDR/HDR encoding/transcoding tests:\n\n```\ncd ../bin\nbasisu -test\nbasisu -test_hdr\n```\n\nTo test the codec in OpenCL mode (must have OpenCL libs/headers/drivers installed and have compiled OpenCL support in by running cmake with `-DOPENCL=TRUE`):\n\n```\nbasisu -test -opencl\n```\n\nCompressing and Unpacking .KTX2/.basis Files\n--------------------------------------------\n\n- To compress an LDR sRGB PNG/QOI/TGA/JPEG/DDS image to an ETC1S .KTX2 file, at quality level 255 (the highest):\n\n`basisu -q 255 x.png`\n\n- For a linear LDR image, in ETC1S mode, at default quality (128):\n\n`basisu -linear x.png`\n\n- To compress to UASTC LDR, which is much higher quality than ETC1S:\n\n`basisu -uastc x.png`\n\n- To compress an [.EXR](https://en.wikipedia.org/wiki/OpenEXR), [Radiance .HDR](https://paulbourke.net/dataformats/pic/), or .DDS HDR image to a UASTC HDR .KTX2 file:\n\n`basisu x.exr`\n\nNote the .EXR reader we're using is [TinyEXR's](https://github.com/syoyo/tinyexr), which doesn't support all possible .EXR compression modes. Tools like [ImageMagick](https://imagemagick.org/) can be used to create .EXR files that TinyEXR can read.\n\nAlternatively, LDR images (such as .PNG) can be compressed to UASTC HDR by specifying `-hdr`. By default, LDR images, when compressed to UASTC HDR, are first converted from sRGB to linear light before compression. This conversion step can be disabled by specifying `-hdr_ldr_no_srgb_to_linear`. \n\nImportantly, for best quality, you should **supply basisu with original uncompressed source images**. Any other type of lossy compression applied before basisu (including ETC1/BC1-5, BC7, JPEG, etc.) will cause multi-generational artifacts to appear in the final output textures. \n\n### Some Useful Command Line Options\n\n- `-fastest` (which is equivalent to `-uastc_level 0`) puts the UASTC LDR/HDR encoders in their fastest (but lower quality) modes. \n\n- `-slower` puts the UASTC LDR/HDR encoders in higher quality but slower modes (equivalent to `-uastc_level 3`). The default level is 1, and the highest is 4 (which is quite slow).\n\n- `-q X`, where X ranges from [1,255], controls the ETC1S mode's quality vs. file size tradeoff level. 255 is the highest quality, and the default is 128.\n\n- `-debug` causes the encoder to print internal and developer-oriented verbose debug information.\n\n- `-stats` to see various quality (PSNR) statistics. \n\n- `-linear`: ETC1S defaults to sRGB colorspace metrics, UASTC LDR currently always uses linear metrics, and UASTC HDR defaults to weighted RGB metrics (with 2,3,1 weights). If the input is a normal map, or some other type of non-sRGB (non-photographic) texture content, be sure to use `-linear` to avoid extra unnecessary artifacts. (Angular normal map metrics for UASTC LDR/HDR are definitely doable and on our TODO list.)\n\n- Specifying `-opencl` enables OpenCL mode, which currently only accelerates ETC1S encoding.\n\n- The compressor is multithreaded by default, which can be disabled using the `-no_multithreading` command line option. The transcoder is currently single threaded, although it is thread safe (i.e. it supports decompressing multiple texture slices in parallel).\n\nMore Example Command Lines\n--------------------------\n\n- To compress an sRGB PNG/QOI/TGA/JPEG/DDS image to an RDO (Rate-Distortion Optimization) UASTC LDR .KTX2 file with mipmaps:\n\n`basisu -uastc -uastc_rdo_l 1.0 -mipmap x.png`\n\n`-uastc_rdo_l X` controls the RDO ([Rate-Distortion Optimization](https://en.wikipedia.org/wiki/Rate%E2%80%93distortion_optimization)) quality setting. The lower this value, the higher the quality, but the larger the compressed file size. Good values to try are between .2-3.0. The default is 1.0.\n\n- To add automatically generated mipmaps to a ETC1S .KTX2 file, at a higher than default quality level (which ranges from [1,255]):\n\n`basisu -mipmap -q 200 x.png`\n\nThere are several mipmap options to change the filter kernel, the filter colorspace for the RGB channels (linear vs. sRGB), the smallest mipmap dimension, etc. The tool also supports generating cubemap files, 2D/cubemap texture arrays, etc. To bypass the automatic mipmap generator, you can create LDR or HDR uncompressed [.DDS texture files](https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide) and feed them to the compressor.\n\n- To create a slightly higher quality ETC1S .KTX2 file (one with higher quality endpoint/selector codebooks) at the default quality level (128) - note this is much slower to encode:\n\n`basisu -comp_level 2 x.png`\n\nOn some rare images (ones with blue sky gradients come to bind), you may need to increase the ETC1S `-comp_level` setting, which ranges from 1,6. This controls the amount of overall effort the encoder uses to optimize the ETC1S codebooks and the compressed data stream. Higher comp_level's are *significantly* slower. \n\n- To manually set the ETC1S codebook sizes (instead of using -q), with a higher codebook generation level (this is useful with texture video):\n\n`basisu x.png -comp_level 2 -max_endpoints 16128 -max_selectors 16128`\n\n- To [tonemap](https://en.wikipedia.org/wiki/Tone_mapping) an HDR .EXR or .HDR image file to multiple LDR .PNG files at different exposures, using the Reinhard tonemap operator:\n\n`basisu -tonemap x.exr`\n\n- To compare two LDR images and print PSNR statistics:\n\n`basisu -compare a.png b.png`\n\n- To compare two HDR .EXR/.HDR images and print FP16 PSNR statistics:\n\n`basisu -compare_hdr a.exr b.exr`\n\nSee the help text for a complete listing of the tool's command line options. The command line tool is just a thin wrapper on top of the encoder library.\n\nUnpacking .KTX2/.basis files to .PNG/.EXR/.KTX/.DDS files\n---------------------------------------------------------\n\nYou can either use the command line tool or [call the transcoder directly](https://github.com/BinomialLLC/basis_universal/wiki/How-to-Use-and-Configure-the-Transcoder) from JavaScript or C/C++ code to decompress .KTX2/.basis files to GPU texture data or uncompressed image data. To unpack a .KTX2 or.basis file to multiple .png/.exr/.ktx/.dds files:\n\n`basisu x.ktx2`\n\nUse the `-no_ktx` and `-etc1_only`/`-format_only` options to unpack to less files. \n\n`-info` and `-validate` will just display file information and not output any files. \n\nThe written mipmapped, cubemap, or texture array .KTX/.DDS files will be in a wide variety of compressed GPU texture formats (PVRTC1 4bpp, ETC1-2, BC1-5, BC7, etc.), and to our knowledge there is unfortunately (as of 2024) still no single .KTX or .DDS viewer tool that correctly and reliably supports every GPU texture format that we support. BC1-5 and BC7 files are viewable using AMD's Compressonator, ETC1/2 using Mali's Texture Compression Tool, and PVRTC1 using Imagination Tech's PVRTexTool. [RenderDoc](https://renderdoc.org/) has a useful texture file viewer for many formats. The Mac OSX Finder supports previewing .EXR and .KTX files in various GPU formats. The Windows 11 Explorer can preview .DDS files. The [online OpenHDR Viewer](https://viewer.openhdr.org/) is useful for viewing .EXR/.HDR image files. \n\nWebGL Examples\n--------------\n\nThe 'WebGL' directory contains four simple WebGL demos that use the transcoder and compressor compiled to [WASM](https://webassembly.org/) with [emscripten](https://emscripten.org/). These demos are online [here](https://subquantumtech.com/uastchdr2/). See more details in the readme file [here](webgl/README.md).\n\n![Screenshot of 'texture' example running in a browser.](webgl/texture_test/preview.png)\n![Screenshot of 'gltf' example running in a browser.](webgl/gltf/preview.png)\n![Screenshot of 'encode_test' example running in a browser.](webgl/ktx2_encode_test/preview.png)\n\nBuilding the WASM Modules with [Emscripten](https://emscripten.org/) \n--------------------------------------------------------------------\n\nBoth the transcoder and encoder may be compiled using emscripten to WebAssembly and used on the web. A set of JavaScript wrappers to the codec, written in C++ with emscripten extensions, is located in `webgl/transcoding/basis_wrappers.cpp`. The JavaScript wrapper supports nearly all features and modes, including texture video. See the README.md and CMakeLists.txt files in `webgl/transcoder` and `webgl/encoder`. \n\nTo build the WASM transcoder, after installing emscripten:\n\n```\ncd webgl/transcoder/build\nemcmake cmake ..\nmake\n```\n\nTo build the WASM encoder:\n\n```\ncd webgl/encoder/build\nemcmake cmake ..\nmake\n```\n\nThere are two simple encoding/transcoding web demos, located in `webgl/ktx2_encode_test` and `webgl/texture_test`, that show how to use the encoder's and transcoder's Javascript wrapper API's.\n\nLow-level C++ Encoder/Transcoder API Examples\n---------------------------------------------\n\nSome simple examples showing how to directly call the C++ encoder and transcoder library API's are in [`example/examples.cpp`](https://github.com/BinomialLLC/basis_universal/blob/master/example/example.cpp).\n\nETC1S Texture Video Tips\n------------------------\n\nSee the wiki [here](https://github.com/BinomialLLC/basis_universal/wiki/Encoding-ETC1S-Texture-Video-Tips).\n\nInstallation using the vcpkg dependency manager\n-----------------------------------------------\n\nYou can download and install Basis Universal using the [vcpkg](https://github.com/Microsoft/vcpkg/) dependency manager:\n\n    git clone https://github.com/Microsoft/vcpkg.git\n    cd vcpkg\n    ./bootstrap-vcpkg.sh\n    ./vcpkg integrate install\n    vcpkg install basisu\n\nThe Basis Universal port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository. (9/10/2024: UASTC HDR support is not available here yet.)\n\nLicense\n-------\n\nThe transcoder and core encoder libraries are Apache 2.0. The transcoder utilizes no 3rd party libraries or dependencies. See [LICENSE](https://github.com/BinomialLLC/basis_universal/blob/master/LICENSE).\n\nThe encoder library is Apache 2.0, but it utilizes some open source 3rd party modules (in 'encoder/3rdparty' and in the 'Zstd' directory) to load [.QOI](https://qoiformat.org/), [.DDS](https://github.com/DeanoC/tiny_dds), [.EXR](https://github.com/syoyo/tinyexr) images, to handle [Zstd](https://github.com/facebook/zstd) compression, and to unpack ASTC texture blocks. See the [LICENSES](https://github.com/BinomialLLC/basis_universal/tree/master/LICENSES) and [.reuse](https://github.com/BinomialLLC/basis_universal/blob/master/.reuse/dep5) folders.\n\nRepository Licensing with REUSE\n-------------------------------\n\nThe repository has been updated to be compliant with the REUSE license\nchecking tool (https://reuse.software/). See the `.reuse` subdirectory.\n\nExternal Tool Links\n-------------------\n\n[Online .EXR HDR Image File Viewer](https://viewer.openhdr.org/)\n\n[Windows HDR + WCG Image Viewer](https://13thsymphony.github.io/hdrimageviewer/) - A true HDR image viewer for Windows. Also see [the github repo](https://github.com/13thsymphony/HDRImageViewer).\n\n[RenderDoc](https://renderdoc.org/)\n\n[AMD Compressonator](https://gpuopen.com/gaming-product/compressonator/)\n\n[Microsoft's DirectXTex](https://github.com/microsoft/DirectXTex)\n\n[PVRTexTool](https://www.imgtec.com/developers/powervr-sdk-tools/pvrtextool/)\n\n[Mali Texture Compression Tool](https://community.arm.com/support-forums/f/graphics-gaming-and-vr-forum/52390/announcement-mali-texture-compression-tool-end-of-life) - Now deprecated\n\nFor more useful links, papers, and tools/libraries, see the end of the [UASTC HDR texture specification](https://github.com/BinomialLLC/basis_universal/wiki/UASTC-HDR-Texture-Specification-v1.0).\n\n----\n\nE-mail: info @ binomial dot info, or contact us on [Twitter](https://twitter.com/_binomial)\n\nHere's the [Sponsors](https://github.com/BinomialLLC/basis_universal/wiki/Sponsors-and-Supporters) wiki page.\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.9208984375,
          "content": "---\n\nimage: \n  - macos\n  - Ubuntu2004\n  - Visual Studio 2019\n\nconfiguration: Release\n\nenvironment:\n  APPVEYOR_YML_DISABLE_PS_LINUX: true\n\ninstall:\n- sh: |\n    if [ \"$(uname)\" != \"Darwin\" ]; then\n      sudo apt-get update -y\n      sudo apt-get install -y dos2unix recode\n    fi\n    \nbuild_script:\n  - ps: |\n      New-Item -Path . -Name \"build\" -ItemType \"directory\"\n      cd build\n      cmake --version\n      cmake ../ -DCMAKE_BUILD_TYPE:STRING=\"$env:CONFIGURATION\"\n      cmake --build . --config $env:CONFIGURATION\n      cd ../\n  - sh: |\n      mkdir build\n      cd build\n      cmake --version\n      cmake ../ -DCMAKE_BUILD_TYPE:STRING=\"${CONFIGURATION}\"\n      cmake --build . --config ${CONFIGURATION}\n      cd ../\n\ntest_script:\n  - sh: |\n      if [ \"$(uname)\" != \"Darwin\" ]; then\n        bash ./format.sh\n      fi\n\nartifacts:\n  # Linux\n  - path: bin/basisu\n  # MacOS\n  - path: bin/basisu\n  # Windows\n  - path: bin\\$(configuration)\\basisu.exe\n"
        },
        {
          "name": "basisu.manifest",
          "type": "blob",
          "size": 0.3828125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<assembly manifestVersion=\"1.0\" xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n  <assemblyIdentity type=\"win32\" name=\"...\" version=\"6.0.0.0\"/>\n  <application>\n    <windowsSettings>\n      <activeCodePage xmlns=\"http://schemas.microsoft.com/SMI/2019/WindowsSettings\">UTF-8</activeCodePage>\n    </windowsSettings>\n  </application>\n</assembly>\n\n"
        },
        {
          "name": "basisu.sln",
          "type": "blob",
          "size": 2.828125,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 17\nVisualStudioVersion = 17.8.34322.80\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"basisu\", \"basisu.vcxproj\", \"{59586A07-8E7E-411D-BC3D-387E039AA423}\"\nEndProject\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"example\", \"example\\example.vcxproj\", \"{2F297CF8-B392-4A5A-88DE-7A10705ADD0A}\"\nEndProject\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"encoder_lib\", \"encoder_lib\\encoder_lib.vcxproj\", \"{97C34996-F458-4030-A402-B32C581872F1}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|x64 = Debug|x64\n\t\tDebug|x86 = Debug|x86\n\t\tRelease|x64 = Release|x64\n\t\tRelease|x86 = Release|x86\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{59586A07-8E7E-411D-BC3D-387E039AA423}.Debug|x64.ActiveCfg = Debug|x64\n\t\t{59586A07-8E7E-411D-BC3D-387E039AA423}.Debug|x64.Build.0 = Debug|x64\n\t\t{59586A07-8E7E-411D-BC3D-387E039AA423}.Debug|x86.ActiveCfg = Debug|Win32\n\t\t{59586A07-8E7E-411D-BC3D-387E039AA423}.Debug|x86.Build.0 = Debug|Win32\n\t\t{59586A07-8E7E-411D-BC3D-387E039AA423}.Release|x64.ActiveCfg = Release|x64\n\t\t{59586A07-8E7E-411D-BC3D-387E039AA423}.Release|x64.Build.0 = Release|x64\n\t\t{59586A07-8E7E-411D-BC3D-387E039AA423}.Release|x86.ActiveCfg = Release|Win32\n\t\t{59586A07-8E7E-411D-BC3D-387E039AA423}.Release|x86.Build.0 = Release|Win32\n\t\t{2F297CF8-B392-4A5A-88DE-7A10705ADD0A}.Debug|x64.ActiveCfg = Debug|x64\n\t\t{2F297CF8-B392-4A5A-88DE-7A10705ADD0A}.Debug|x64.Build.0 = Debug|x64\n\t\t{2F297CF8-B392-4A5A-88DE-7A10705ADD0A}.Debug|x86.ActiveCfg = Debug|Win32\n\t\t{2F297CF8-B392-4A5A-88DE-7A10705ADD0A}.Debug|x86.Build.0 = Debug|Win32\n\t\t{2F297CF8-B392-4A5A-88DE-7A10705ADD0A}.Release|x64.ActiveCfg = Release|x64\n\t\t{2F297CF8-B392-4A5A-88DE-7A10705ADD0A}.Release|x64.Build.0 = Release|x64\n\t\t{2F297CF8-B392-4A5A-88DE-7A10705ADD0A}.Release|x86.ActiveCfg = Release|Win32\n\t\t{2F297CF8-B392-4A5A-88DE-7A10705ADD0A}.Release|x86.Build.0 = Release|Win32\n\t\t{97C34996-F458-4030-A402-B32C581872F1}.Debug|x64.ActiveCfg = Debug|x64\n\t\t{97C34996-F458-4030-A402-B32C581872F1}.Debug|x64.Build.0 = Debug|x64\n\t\t{97C34996-F458-4030-A402-B32C581872F1}.Debug|x86.ActiveCfg = Debug|Win32\n\t\t{97C34996-F458-4030-A402-B32C581872F1}.Debug|x86.Build.0 = Debug|Win32\n\t\t{97C34996-F458-4030-A402-B32C581872F1}.Release|x64.ActiveCfg = Release|x64\n\t\t{97C34996-F458-4030-A402-B32C581872F1}.Release|x64.Build.0 = Release|x64\n\t\t{97C34996-F458-4030-A402-B32C581872F1}.Release|x86.ActiveCfg = Release|Win32\n\t\t{97C34996-F458-4030-A402-B32C581872F1}.Release|x86.Build.0 = Release|Win32\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {5E583429-7830-4B3A-9DDE-F01B115CE0D8}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "basisu.vcxproj",
          "type": "blob",
          "size": 10.08984375,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup Label=\"ProjectConfigurations\">\n    <ProjectConfiguration Include=\"Debug|Win32\">\n      <Configuration>Debug</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|Win32\">\n      <Configuration>Release</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Debug|x64\">\n      <Configuration>Debug</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|x64\">\n      <Configuration>Release</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n  </ItemGroup>\n  <PropertyGroup Label=\"Globals\">\n    <ProjectGuid>{59586A07-8E7E-411D-BC3D-387E039AA423}</ProjectGuid>\n    <RootNamespace>basisu</RootNamespace>\n    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseDebugLibraries>true</UseDebugLibraries>\n    <PlatformToolset>v143</PlatformToolset>\n    <CharacterSet>MultiByte</CharacterSet>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseDebugLibraries>false</UseDebugLibraries>\n    <PlatformToolset>v143</PlatformToolset>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <CharacterSet>MultiByte</CharacterSet>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseDebugLibraries>true</UseDebugLibraries>\n    <PlatformToolset>v143</PlatformToolset>\n    <CharacterSet>MultiByte</CharacterSet>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseDebugLibraries>false</UseDebugLibraries>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <CharacterSet>MultiByte</CharacterSet>\n    <PlatformToolset>v143</PlatformToolset>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n  <ImportGroup Label=\"ExtensionSettings\">\n  </ImportGroup>\n  <ImportGroup Label=\"Shared\">\n  </ImportGroup>\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <PropertyGroup Label=\"UserMacros\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <OutDir>$(SolutionDir)\\bin\\</OutDir>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n    <OutDir>$(SolutionDir)\\bin\\</OutDir>\n    <TargetName>$(ProjectName)D_x86</TargetName>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n    <OutDir>$(SolutionDir)\\bin\\</OutDir>\n    <TargetName>$(ProjectName)_x86</TargetName>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <OutDir>$(SolutionDir)\\bin\\</OutDir>\n    <TargetName>$(ProjectName)D</TargetName>\n  </PropertyGroup>\n  <PropertyGroup Label=\"Vcpkg\">\n    <VcpkgAutoLink>false</VcpkgAutoLink>\n  </PropertyGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n    <ClCompile>\n      <WarningLevel>Level4</WarningLevel>\n      <Optimization>Disabled</Optimization>\n      <SDLCheck>false</SDLCheck>\n      <OpenMPSupport>true</OpenMPSupport>\n      <AdditionalIncludeDirectories>OpenCL</AdditionalIncludeDirectories>\n      <PreprocessorDefinitions>_MBCS;%(PreprocessorDefinitions);BASISU_SUPPORT_SSE=1;BASISU_SUPPORT_OPENCL=1;_HAS_EXCEPTIONS=0</PreprocessorDefinitions>\n      <EnableEnhancedInstructionSet>StreamingSIMDExtensions</EnableEnhancedInstructionSet>\n    </ClCompile>\n    <Link>\n      <SubSystem>Console</SubSystem>\n      <AdditionalLibraryDirectories>OpenCL\\lib</AdditionalLibraryDirectories>\n      <AdditionalDependencies>opencl.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n      <PerUserRedirection>true</PerUserRedirection>\n    </Link>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <ClCompile>\n      <WarningLevel>Level4</WarningLevel>\n      <Optimization>Disabled</Optimization>\n      <SDLCheck>false</SDLCheck>\n      <AdditionalIncludeDirectories>OpenCL</AdditionalIncludeDirectories>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <OpenMPSupport>true</OpenMPSupport>\n      <PreprocessorDefinitions>_MBCS;%(PreprocessorDefinitions);BASISU_SUPPORT_SSE=1;BASISU_SUPPORT_OPENCL=1;</PreprocessorDefinitions>\n      <EnableEnhancedInstructionSet>AdvancedVectorExtensions</EnableEnhancedInstructionSet>\n    </ClCompile>\n    <Link>\n      <SubSystem>Console</SubSystem>\n      <AdditionalLibraryDirectories>OpenCL\\lib</AdditionalLibraryDirectories>\n      <AdditionalDependencies>opencl64.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n    </Link>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n    <ClCompile>\n      <WarningLevel>Level4</WarningLevel>\n      <Optimization>Full</Optimization>\n      <FunctionLevelLinking>true</FunctionLevelLinking>\n      <IntrinsicFunctions>true</IntrinsicFunctions>\n      <OpenMPSupport>true</OpenMPSupport>\n      <AdditionalIncludeDirectories>OpenCL</AdditionalIncludeDirectories>\n      <PreprocessorDefinitions>NDEBUG;_HAS_EXCEPTIONS=0;%(PreprocessorDefinitions);BASISU_SUPPORT_SSE=1;BASISU_SUPPORT_OPENCL=1</PreprocessorDefinitions>\n      <BufferSecurityCheck>false</BufferSecurityCheck>\n      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>\n      <EnableEnhancedInstructionSet>AdvancedVectorExtensions</EnableEnhancedInstructionSet>\n      <FloatingPointModel>Precise</FloatingPointModel>\n      <ExceptionHandling>false</ExceptionHandling>\n      <OmitFramePointers>true</OmitFramePointers>\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\n      <SDLCheck>false</SDLCheck>\n    </ClCompile>\n    <Link>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <OptimizeReferences>true</OptimizeReferences>\n      <SubSystem>Console</SubSystem>\n      <AdditionalLibraryDirectories>OpenCL\\lib</AdditionalLibraryDirectories>\n      <AdditionalDependencies>opencl.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n    </Link>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <ClCompile>\n      <WarningLevel>Level4</WarningLevel>\n      <Optimization>Full</Optimization>\n      <FunctionLevelLinking>true</FunctionLevelLinking>\n      <IntrinsicFunctions>true</IntrinsicFunctions>\n      <AdditionalIncludeDirectories>OpenCL</AdditionalIncludeDirectories>\n      <PreprocessorDefinitions>NDEBUG;_HAS_EXCEPTIONS=0;%(PreprocessorDefinitions);BASISU_SUPPORT_SSE=1;BASISU_SUPPORT_OPENCL=1;</PreprocessorDefinitions>\n      <BufferSecurityCheck>false</BufferSecurityCheck>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>\n      <ExceptionHandling>false</ExceptionHandling>\n      <FloatingPointModel>Precise</FloatingPointModel>\n      <OmitFramePointers>true</OmitFramePointers>\n      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>\n      <EnableEnhancedInstructionSet>AdvancedVectorExtensions</EnableEnhancedInstructionSet>\n      <SDLCheck>false</SDLCheck>\n    </ClCompile>\n    <Link>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <OptimizeReferences>true</OptimizeReferences>\n      <SubSystem>Console</SubSystem>\n      <AdditionalLibraryDirectories>OpenCL\\lib</AdditionalLibraryDirectories>\n      <AdditionalDependencies>opencl64.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n    </Link>\n  </ItemDefinitionGroup>\n  <ItemGroup>\n    <ClCompile Include=\"basisu_tool.cpp\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Manifest Include=\"basisu.manifest\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ProjectReference Include=\"encoder_lib\\encoder_lib.vcxproj\">\n      <Project>{97c34996-f458-4030-a402-b32c581872f1}</Project>\n    </ProjectReference>\n  </ItemGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n  <ImportGroup Label=\"ExtensionTargets\">\n  </ImportGroup>\n</Project>"
        },
        {
          "name": "basisu.vcxproj.filters",
          "type": "blob",
          "size": 0.279296875,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup>\n    <ClCompile Include=\"basisu_tool.cpp\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Manifest Include=\"basisu.manifest\" />\n  </ItemGroup>\n</Project>"
        },
        {
          "name": "basisu_tool.cpp",
          "type": "blob",
          "size": 188.0634765625,
          "content": "// basisu_tool.cpp\n// Copyright (C) 2019-2024 Binomial LLC. All Rights Reserved.\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n#if _MSC_VER\n// For sprintf(), strcpy() \n#define _CRT_SECURE_NO_WARNINGS (1)\n#endif\n\n#include \"transcoder/basisu.h\"\n#include \"transcoder/basisu_transcoder_internal.h\"\n#include \"encoder/basisu_enc.h\"\n#include \"encoder/basisu_etc.h\"\n#include \"encoder/basisu_gpu_texture.h\"\n#include \"encoder/basisu_frontend.h\"\n#include \"encoder/basisu_backend.h\"\n#include \"encoder/basisu_comp.h\"\n#include \"transcoder/basisu_transcoder.h\"\n#include \"encoder/basisu_ssim.h\"\n#include \"encoder/basisu_opencl.h\"\n\n#define MINIZ_HEADER_FILE_ONLY\n#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES\n#include \"encoder/basisu_miniz.h\"\n\n#ifdef _WIN32\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#endif\n// Set BASISU_CATCH_EXCEPTIONS if you want exceptions to crash the app, otherwise main() catches them.\n#ifndef BASISU_CATCH_EXCEPTIONS\n\t#define BASISU_CATCH_EXCEPTIONS 0\n#endif\n\nusing namespace basisu;\nusing namespace buminiz;\n\n#define BASISU_TOOL_VERSION \"1.50.0\"\n\n// Define to lower the -test and -test_hdr tolerances\n//#define USE_TIGHTER_TEST_TOLERANCES\n\n// Only enable to verify SAN is working.\n//#define FORCE_SAN_FAILURE\n\nenum tool_mode\n{\n\tcDefault,\n\tcCompress,\n\tcValidate,\n\tcInfo,\n\tcUnpack,\n\tcCompare,\n\tcHDRCompare,\n\tcVersion,\n\tcBench,\n\tcCompSize,\n\tcTestLDR,\n\tcTestHDR,\n\tcCLBench,\n\tcSplitImage,\n\tcCombineImages,\n\tcTonemapImage\n};\n\nstatic void print_usage()\n{\n\tprintf(\"\\nUsage: basisu filename [filename ...] <options>\\n\");\n\t\n\tputs(\"\\n\"\n\t\t\"The default mode is compression of one or more .PNG/.BMP/.TGA/.JPG/.QOI/.DDS/.EXR/.HDR files to a LDR or HDR .KTX2 file. Alternate modes:\\n\"\n\t\t\" -unpack: Use transcoder to unpack a .basis/.KTX2 file to one or more .KTX/.PNG files\\n\"\n\t\t\" -validate: Validate and display information about a .basis/.KTX2 file\\n\"\n\t\t\" -info: Display high-level information about a .basis/.KTX2 file\\n\"\n\t\t\" -compare: Compare two LDR PNG/BMP/TGA/JPG/QOI images specified with -file, output PSNR and SSIM statistics and RGB/A delta images\\n\"\n\t\t\" -compare_hdr: Compare two HDR .EXR/.HDR images specified with -file, output PSNR statistics and RGB delta images\\n\"\n\t\t\" -tonemap: Tonemap an HDR or EXR image to PNG at multiple exposures, use -file to specify filename\\n\"\n\t\t\" -version: Print version and exit\\n\"\n\t\t\"\\n\"\n\t\t\"Notes:\\n\"\n\t\t\"\\nUnless an explicit mode is specified, if one or more files have the .basis or .KTX2 extension this tool defaults to unpack mode.\\n\"\n\t\t\"\\nBy default, the compressor assumes the input is in the sRGB colorspace (like photos/albedo textures).\\n\"\n\t\t\"If the input is NOT sRGB (like a normal map), be sure to specify -linear for less artifacts. Depending on the content type, some experimentation may be needed.\\n\"\n\t\t\"\\n\"\n\t\t\"The TinyEXR library is used to read .EXR images. This library does not support all .EXR compression methods. For unsupported images, you can use ImageMagick to convert them to uncompressed .EXR.\\n\"\n\t\t\"\\n\"\n\t\t\"For .DDS source files: Mipmapped or not mipmapped 2D textures (but not cubemaps) are supported. Only uncompressed 32-bit RGBA/BGRA, half float RGBA, or float RGBA .DDS files are supported. In -tex_array mode, if a .DDS file is specified, all source files must be in .DDS format.\\n\"\n\t\t\"\\n\"\n\t\t\"Filenames prefixed with a @ symbol are read as filename listing files. Listing text files specify which actual filenames to process (one filename per line).\\n\"\n\t\t\"\\n\"\n\t\t\"Options:\\n\"\n\t\t\" -hdr: Encode input as UASTC HDR (automatic if any input file has the .EXR or .HDR extension, or if any .DDS file is HDR).\\n\"\n\t\t\" -fastest: Set UASTC LDR and HDR to fastest but lowest quality encoding mode (same as -uastc_level 0)\\n\"\n\t\t\" -slower: Set UASTC LDR and HDR to slower but a higher quality encoding mode (same as -uastc_level 3)\\n\"\n\t\t\" -opencl: Enable OpenCL usage (currently only accelerates ETC1S encoding)\\n\"\n\t\t\" -opencl_serialize: Serialize all calls to the OpenCL driver (to work around buggy drivers, only useful with -parallel)\\n\"\n\t\t\" -parallel: Compress multiple textures simumtanously (one per thread), instead of one at a time. Compatible with OpenCL mode. This is much faster, but in OpenCL mode the driver is pushed harder, and the CLI output will be jumbled.\\n\"\n\t\t\" -ktx2: Write .KTX2 files (the default). By default, UASTC LDR/HDR files will be compressed using Zstandard unless -ktx2_no_zstandard is specified.\\n\"\n\t\t\" -basis: Write .basis files instead of .KTX2 files (the previous default).\\n\"\n\t\t\" -file filename.png/bmp/tga/jpg/qoi: Input image filename, multiple images are OK, use -file X for each input filename (prefixing input filenames with -file is optional)\\n\"\n\t\t\" -alpha_file filename.png/bmp/tga/jpg/qoi: Input alpha image filename, multiple images are OK, use -file X for each input filename (must be paired with -file), images converted to REC709 grayscale and used as input alpha\\n\"\n\t\t\" -multifile_printf: printf() format strint to use to compose multiple filenames\\n\"\n\t\t\" -multifile_first: The index of the first file to process, default is 0 (must specify -multifile_printf and -multifile_num)\\n\"\n\t\t\" -multifile_num: The total number of files to process.\\n\"\n\t\t\" -q X: Set ETC1S quality level, 1-255, default is 128, lower=better compression/lower quality/faster, higher=less compression/higher quality/slower, default is 128. For even higher quality, use -max_endpoints/-max_selectors.\\n\"\n\t\t\" -linear: Use linear colorspace metrics (instead of the default sRGB or scaled RGB for HDR), and by default linear (not sRGB) mipmap filtering.\\n\"\n\t\t\" -output_file filename: Output .basis/.KTX2 filename\\n\"\n\t\t\" -output_path: Output .basis/.KTX2 files to specified directory.\\n\"\n\t\t\" -debug or -verbose: Enable codec debug print to stdout (slightly slower).\\n\"\n\t\t\" -debug_images: Enable codec debug images (much slower).\\n\"\n\t\t\" -stats: Compute and display image quality metrics (slightly to much slower).\\n\"\n\t\t\" -tex_type <2d, 2darray, 3d, video, cubemap>: Set Basis file header's texture type field. Cubemap arrays require multiples of 6 images, in X+, X-, Y+, Y-, Z+, Z- order, each image must be the same resolutions.\\n\"\n\t\t\"  2d=arbitrary 2D images, 2darray=2D array, 3D=volume texture slices, video=video frames, cubemap=array of faces. For 2darray/3d/cubemaps/video, each source image's dimensions and # of mipmap levels must be the same.\\n\"\n\t\t\" For video, the .basis file will be written with the first frame being an I-Frame, and subsequent frames being P-Frames (using conditional replenishment). Playback must always occur in order from first to last image.\\n\"\n\t\t\" -cubemap: same as -tex_type cubemap\\n\"\n\t\t\" -individual: Process input images individually and output multiple .basis/.KTX2 files (not as a texture array - this is now the default as of v1.16)\\n\"\n\t\t\" -tex_array: Process input images as a single texture array and write a single .basis/.KTX2 file (the former default before v1.16)\\n\"\n\t\t\" -comp_level X: Set ETC1S encoding speed vs. quality tradeoff. Range is 0-6, default is 1. Higher values=MUCH slower, but slightly higher quality. Higher levels intended for videos. Use -q first!\\n\"\n\t\t\" -fuzz_testing: Use with -validate: Disables CRC16 validation of file contents before transcoding\\n\"\n\t\t\"\\nUASTC options:\\n\"\n\t\t\" -uastc: Enable UASTC LDR texture mode, instead of the default ETC1S mode. Significantly higher texture quality, but larger files. (Note that UASTC .basis files must be losslessly compressed by the user.)\\n\"\n\t\t\" -uastc_level: Set UASTC LDR/HDR encoding level. LDR Range is [0,4], default is 2, higher=slower but higher quality. 0=fastest/lowest quality, 3=slowest practical option, 4=impractically slow/highest achievable quality\\n\"\n\t\t\"\t\t\t\tUASTC HDR range is [0,4] - higher=slower but higher quality. HDR default=1.\\n\"\n\t\t\" -uastc_rdo_l X: Enable UASTC LDR RDO post-processing and set UASTC RDO quality scalar (lambda) to X. Lower values=higher quality/larger LZ\\n\"\n\t\t\"                 compressed files, higher values=lower quality/smaller LZ compressed files. Good range to try is [.25-10].\\n\"\n\t\t\"                 Note: Previous versons used the -uastc_rdo_q option, which was removed because the RDO algorithm was changed.\\n\"\n\t\t\" -uastc_rdo_d X: Set UASTC LDR RDO dictionary size in bytes. Default is 4096, max is 65536. Lower values=faster, but less compression.\\n\"\n\t\t\" -uastc_rdo_b X: Set UASTC LDR RDO max smooth block error scale. Range is [1,300]. Default is 10.0, 1.0=disabled. Larger values suppress more artifacts (and allocate more bits) on smooth blocks.\\n\"\n\t\t\" -uastc_rdo_s X: Set UASTC LDR RDO max smooth block standard deviation. Range is [.01,65536]. Default is 18.0. Larger values expand the range of blocks considered smooth.\\n\"\n\t\t\" -uastc_rdo_f: Don't favor simpler UASTC LDR modes in RDO mode.\\n\"\n\t\t\" -uastc_rdo_m: Disable RDO multithreading (slightly higher compression, deterministic).\\n\"\n\t\t\"\\n\"\n\t\t\"HDR specific options:\\n\"\n\t\t\" -uastc_level X: Sets the UASTC HDR compressor's level. Valid range is [0,4] - higher=slower but higher quality. HDR default=1.\\n\"\n\t\t\"                 Level 0=fastest/lowest quality, 3=highest practical setting, 4=exhaustive\\n\"\n\t\t\" -hdr_ldr_no_srgb_to_linear: If specified, LDR images will NOT be converted to normalized linear light (via a sRGB->Linear conversion) before compressing as HDR.\\n\"\n\t\t\" -hdr_uber_mode: Allow the encoder to try varying the selectors more for slightly higher quality. This may negatively impact BC6H quality, however.\\n\"\n\t\t\" -hdr_favor_astc: By default the HDR encoder tries to strike a balance or even slightly favor BC6H quality. If this option is specified, ASTC HDR quality is favored instead.\\n\"\n\t\t\"\\n\"\n\t\t\"More options:\\n\"\n\t\t\" -test: Run an automated LDR ETC1S/UASTC encoding and transcoding test. Returns EXIT_FAILURE if any failures\\n\"\n\t\t\" -test_hdr: Run an automated UASTC HDR encoding and transcoding test. Returns EXIT_FAILURE if any failures\\n\"\n\t\t\" -test_dir: Optional directory of test files. Defaults to \\\"../test_files\\\".\\n\"\n\t\t\" -max_endpoints X: Manually set the max number of color endpoint clusters from 1-16128, use instead of -q\\n\"\n\t\t\" -max_selectors X: Manually set the max number of color selector clusters from 1-16128, use instead of -q\\n\"\n\t\t\" -y_flip: Flip input images vertically before compression\\n\"\n\t\t\" -normal_map: Tunes codec parameters for better quality on normal maps (linear colorspace metrics, linear mipmap filtering, no selector RDO, no sRGB)\\n\"\n\t\t\" -no_alpha: Always output non-alpha basis files, even if one or more inputs has alpha\\n\"\n\t\t\" -force_alpha: Always output alpha basis files, even if no inputs has alpha\\n\"\n\t\t\" -separate_rg_to_color_alpha: Separate input R and G channels to RGB and A (for tangent space XY normal maps)\\n\"\n\t\t\" -swizzle rgba: Specify swizzle for the 4 input color channels using r, g, b and a (the -separate_rg_to_color_alpha flag is equivalent to rrrg)\\n\"\n\t\t\" -renorm: Renormalize each input image before any further processing/compression\\n\"\n\t\t\" -no_multithreading: Disable multithreading\\n\"\n\t\t\" -max_threads X: Use at most X threads total when multithreading is enabled (this includes the main thread)\\n\"\n\t\t\" -no_ktx: Disable KTX writing when unpacking (faster, less output files)\\n\"\n\t\t\" -ktx_only: Only write KTX files when unpacking (faster, less output files)\\n\"\n\t\t\" -write_out: Write 3dfx OUT files when unpacking FXT1 textures\\n\"\n\t\t\" -format_only: Only unpack the specified format, by its numeric code.\\n\"\n\t\t\" -etc1_only: Only unpack to ETC1, skipping the other texture formats during -unpack\\n\"\n\t\t\" -disable_hierarchical_endpoint_codebooks: Disable hierarchical endpoint codebook usage, slower but higher quality on some compression levels\\n\"\n\t\t\" -compare_ssim: Compute and display SSIM of image comparison (slow)\\n\"\n\t\t\" -compare_plot: Display histogram plots in -compare mode\\n\"\n\t\t\" -bench: UASTC benchmark mode, for development only\\n\"\n\t\t\" -resample X Y: Resample all input textures to XxY pixels using a box filter\\n\"\n\t\t\" -resample_factor X: Resample all input textures by scale factor X using a box filter\\n\"\n\t\t\" -no_sse: Forbid all SSE instruction set usage\\n\"\n\t\t\" -validate_etc1s: Validate internal ETC1S compressor's data structures during compression (slower, intended for development).\\n\"\n\t\t\" -ktx2_animdata_duration X: Set KTX2animData duration field to integer value X (only valid/useful for -tex_type video, default is 1)\\n\"\n\t\t\" -ktx2_animdata_timescale X: Set KTX2animData timescale field to integer value X (only valid/useful for -tex_type video, default is 15)\\n\"\n\t\t\" -ktx2_animdata_loopcount X: Set KTX2animData loopcount field to integer value X (only valid/useful for -tex_type video, default is 0)\\n\"\n\t\t\" -framerate X: Set framerate in .basis header to X/frames sec.\\n\"\n\t\t\" -ktx2_no_zstandard: Don't compress UASTC texture data using Zstandard -- store it uncompressed instead.\\n\"\n\t\t\" -ktx2_zstandard_level X: Set ZStandard compression level to X (see Zstandard documentation, default level is 6)\\n\"\n\t\t\"\\n\"\n\t\t\"Mipmap generation options:\\n\"\n\t\t\" -mipmap: Generate mipmaps for each source image\\n\"\n\t\t\" -mip_srgb: Convert image to linear before filtering, then back to sRGB\\n\"\n\t\t\" -mip_linear: Keep image in linear light during mipmap filtering (i.e. do not convert to/from sRGB for filtering purposes)\\n\"\n\t\t\" -mip_scale X: Set mipmap filter kernel's scale, lower=sharper, higher=more blurry, default is 1.0\\n\"\n\t\t\" -mip_filter X: Set mipmap filter kernel, default is kaiser, filters: box, tent, bell, blackman, catmullrom, mitchell, etc.\\n\"\n\t\t\" -mip_renorm: Renormalize normal map to unit length vectors after filtering\\n\"\n\t\t\" -mip_clamp: Use clamp addressing on borders, instead of wrapping\\n\"\n\t\t\" -mip_fast: Use faster mipmap generation (resample from previous mip, not always first/largest mip level). The default (as of 1/2021)\\n\"\n\t\t\" -mip_slow: Always resample each mipmap level starting from the largest mipmap. Higher quality, but slower. Opposite of -mip_fast. Was the prior default before 1/2021.\\n\"\n\t\t\" -mip_smallest X: Set smallest pixel dimension for generated mipmaps, default is 1 pixel\\n\"\n\t\t\"By default, textures will be converted from sRGB to linear light before mipmap filtering, then back to sRGB (for the RGB color channels) unless -linear is specified.\\n\"\n\t\t\"You can override this behavior with -mip_srgb/-mip_linear.\\n\"\n\t\t\"\\n\"\n\t\t\"Backend endpoint/selector RDO codec options:\\n\"\n\t\t\" -no_selector_rdo: Disable backend's selector rate distortion optimizations (slightly faster, less noisy output, but lower quality per output bit)\\n\"\n\t\t\" -selector_rdo_thresh X: Set selector RDO quality threshold, default is 1.25, lower is higher quality but less quality per output bit (try 1.0-3.0)\\n\"\n\t\t\" -no_endpoint_rdo: Disable backend's endpoint rate distortion optimizations (slightly faster, less noisy output, but lower quality per output bit)\\n\"\n\t\t\" -endpoint_rdo_thresh X: Set endpoint RDO quality threshold, default is 1.5, lower is higher quality but less quality per output bit (try 1.0-3.0)\\n\"\n\t\t\"\\n\"\n\t\t\"Set various fields in the Basis file header:\\n\"\n\t\t\" -userdata0 X: Set 32-bit userdata0 field in Basis file header to X (X is a signed 32-bit int)\\n\"\n\t\t\" -userdata1 X: Set 32-bit userdata1 field in Basis file header to X (X is a signed 32-bit int)\\n\"\n\t\t\"\\n\"\n\t\t\"Example LDR command lines:\\n\"\n\t\t\" basisu x.png : Compress sRGB image x.png to x.ktx2 using default settings (multiple filenames OK, use -tex_array if you want a tex array vs. multiple output files)\\n\"\n\t\t\" basisu -basis x.qoi : Compress sRGB image x.qoi to x.basis (supports 24-bit or 32-bit .QOI files)\\n\"\n\t\t\" basisu x.ktx2 : Unpack x.basis to PNG/KTX files (multiple filenames OK)\\n\"\n\t\t\" basisu x.basis : Unpack x.basis to PNG/KTX files (multiple filenames OK)\\n\"\n\t\t\" basisu -uastc x.png -uastc_rdo_l 2.0 -ktx2 -stats : Compress to a UASTC .KTX2 file with RDO (rate distortion optimization) to reduce .KTX2 compressed file size\\n\"\n\t\t\" basisu -file x.png -mipmap -y_flip : Compress a mipmapped x.ktx2 file from an sRGB image named x.png, Y flip each source image\\n\"\n\t\t\" basisu -validate -file x.basis : Validate x.basis (check header, check file CRC's, attempt to transcode all slices)\\n\"\n\t\t\" basisu -unpack -file x.basis : Validates, transcodes and unpacks x.basis to mipmapped .KTX and RGB/A .PNG files (transcodes to all supported GPU texture formats)\\n\"\n\t\t\" basisu -q 255 -file x.png -mipmap -debug -stats : Compress sRGB x.png to x.ktx2 at quality level 255 with compressor debug output/statistics\\n\"\n\t\t\" basisu -linear -max_endpoints 16128 -max_selectors 16128 -file x.png : Compress non-sRGB x.png to x.ktx2 using the largest supported manually specified codebook sizes\\n\"\n\t\t\" basisu -basis -comp_level 2 -max_selectors 8192 -max_endpoints 8192 -tex_type video -framerate 20 -multifile_printf \\\"x%02u.png\\\" -multifile_first 1 -multifile_count 20 : Compress a 20 sRGB source image video sequence (x01.png, x02.png, x03.png, etc.) to x01.basis\\n\"\n\t\t\"\\n\"\n\t\t\"Example HDR command lines:\\n\"\n\t\t\" basisu x.exr : Compress a HDR .EXR image to a UASTC HDR .KTX2 file.\\n\"\n\t\t\" basisu x.hdr -uastc_level 0 : Compress a HDR .hdr image to a UASTC HDR .KTX2 file, fastest encoding but lowest quality\\n\"\n\t\t\" basisu -hdr x.png : Compress a LDR .PNG image to UASTC HDR (image is converted from sRGB to linear light first, use -hdr_ldr_no_srgb_to_linear to disable)\\n\"\n\t\t\" basisu x.hdr -uastc_level 3 : Compress a HDR .hdr image to UASTC HDR at higher quality (-uastc_level 4 is highest quality, but very slow encoding)\\n\"\n\t\t\" basisu x.hdr -uastc_level 3 -mipmap -basis -stats -debug -debug_images : Compress a HDR .hdr image to a UASTC HDR, .basis output file, at higher quality, generate mipmaps, output statistics and debug information, and write tone mapped debug images\\n\"\n\t\t\" basisu x.hdr -stats -hdr_favor_astc -hdr_uber_mode -uastc_level 4 : Highest achievable ASTC HDR quality (very slow encoding, BC6H quality is traded off)\\n\"\n\t\t\"\\n\"\n\t\t\"Video notes: For video use, it's recommended to encode on a machine with many cores. Use -comp_level 2 or higher for better codebook\\n\"\n\t\t\"generation, specify very large codebooks using -max_endpoints and -max_selectors, and reduce the default endpoint RDO threshold\\n\"\n\t\t\"(-endpoint_rdo_thresh) to around 1.25. Videos may have mipmaps and alpha channels. Videos must always be played back by the transcoder\\n\"\n\t\t\"in first to last image order.\\n\"\n\t\t\"Video files currently use I-Frames on the first image, and P-Frames using conditional replenishment on subsequent frames.\\n\"\n\t\t\"\\nETC1S Compression level (-comp_level X) details. This controls the ETC1S speed vs. quality trandeoff. (Use -q to control the quality vs. compressed size tradeoff.):\\n\"\n\t\t\" Level 0: Fastest, but has marginal quality and can be brittle on complex images. Avg. Y dB: 35.45\\n\"\n\t\t\" Level 1: Hierarchical codebook searching, faster ETC1S encoding. 36.87 dB, ~1.4x slower vs. level 0. (This is the default setting.)\\n\"\n\t\t\" Level 2: Use this or higher for video. Hierarchical codebook searching. 36.87 dB, ~1.4x slower vs. level 0. (This is the v1.12's default setting.)\\n\"\n\t\t\" Level 3: Full codebook searching. 37.13 dB, ~1.8x slower vs. level 0. (Equivalent the the initial release's default settings.)\\n\"\n\t\t\" Level 4: Hierarchical codebook searching, codebook k-means iterations. 37.15 dB, ~4x slower vs. level 0\\n\"\n\t\t\" Level 5: Full codebook searching, codebook k-means iterations. 37.41 dB, ~5.5x slower vs. level 0.\\n\"\n\t\t\" Level 6: Full codebook searching, twice as many codebook k-means iterations, best ETC1 endpoint opt. 37.43 dB, ~12x slower vs. level 0\\n\"\n\t);\n}\n\nstatic bool load_listing_file(const std::string &f, basisu::vector<std::string> &filenames)\n{\n\tstd::string filename(f);\n\tfilename.erase(0, 1);\n\n\tFILE *pFile = nullptr;\n#ifdef _WIN32\n\tfopen_s(&pFile, filename.c_str(), \"r\");\n#else\n\tpFile = fopen(filename.c_str(), \"r\");\n#endif\n\n\tif (!pFile)\n\t{\n\t\terror_printf(\"Failed opening listing file: \\\"%s\\\"\\n\", filename.c_str());\n\t\treturn false;\n\t}\n\n\tuint32_t total_filenames = 0;\n\n\tfor ( ; ; )\n\t{\n\t\tchar buf[3072];\n\t\tbuf[0] = '\\0';\n\n\t\tchar *p = fgets(buf, sizeof(buf), pFile);\n\t\tif (!p)\n\t\t{\n\t\t\tif (ferror(pFile))\n\t\t\t{\n\t\t\t\terror_printf(\"Failed reading from listing file: \\\"%s\\\"\\n\", filename.c_str());\n\n\t\t\t\tfclose(pFile);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstd::string read_filename(p);\n\t\twhile (read_filename.size())\n\t\t{\n\t\t\tif (read_filename[0] == ' ')\n\t\t\t\tread_filename.erase(0, 1);\n\t\t\telse \n\t\t\t\tbreak;\n\t\t}\n\n\t\twhile (read_filename.size())\n\t\t{\n\t\t\tconst char c = read_filename.back();\n\t\t\tif ((c == ' ') || (c == '\\n') || (c == '\\r'))\n\t\t\t\tread_filename.erase(read_filename.size() - 1, 1);\n\t\t\telse \n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (read_filename.size())\n\t\t{\n\t\t\tfilenames.push_back(read_filename);\n\t\t\ttotal_filenames++;\n\t\t}\n\t}\n\n\tfclose(pFile);\n\n\tprintf(\"Successfully read %u filenames(s) from listing file \\\"%s\\\"\\n\", total_filenames, filename.c_str());\n\n\treturn true;\n}\n\nclass command_line_params\n{\n\tBASISU_NO_EQUALS_OR_COPY_CONSTRUCT(command_line_params);\n\npublic:\n\tcommand_line_params() :\n\t\tm_mode(cDefault),\n\t\tm_ktx2_mode(true),\n\t\tm_ktx2_zstandard(true),\n\t\tm_ktx2_zstandard_level(6),\n\t\tm_ktx2_animdata_duration(1),\n\t\tm_ktx2_animdata_timescale(15),\n\t\tm_ktx2_animdata_loopcount(0),\n\t\tm_format_only(-1),\n\t\tm_multifile_first(0),\n\t\tm_multifile_num(0),\n\t\tm_max_threads(1024), // surely this is high enough\n\t\tm_individual(true),\n\t\tm_no_ktx(false),\n\t\tm_ktx_only(false),\n\t\tm_write_out(false),\n\t\tm_etc1_only(false),\n\t\tm_fuzz_testing(false),\n\t\tm_compare_ssim(false),\n\t\tm_compare_plot(false),\n\t\tm_parallel_compression(false)\n\t{\n\t\tm_comp_params.m_compression_level = basisu::maximum<int>(0, BASISU_DEFAULT_COMPRESSION_LEVEL - 1);\n\t\t\n\t\tm_comp_params.m_uastc_hdr_options.set_quality_level(astc_hdr_codec_options::cDefaultLevel);\n\n\t\tm_test_file_dir = \"../test_files\";\n\t}\n\n\tbool parse(int arg_c, const char **arg_v)\n\t{\n\t\tint arg_index = 1;\n\t\twhile (arg_index < arg_c)\n\t\t{\n\t\t\tconst char *pArg = arg_v[arg_index];\n\t\t\tconst int num_remaining_args = arg_c - (arg_index + 1);\n\t\t\tint arg_count = 1;\n\n#define REMAINING_ARGS_CHECK(n) if (num_remaining_args < (n)) { error_printf(\"Error: Expected %u values to follow %s!\\n\", n, pArg); return false; }\n\n\t\t\tif ((strcasecmp(pArg, \"-help\") == 0) || (strcasecmp(pArg, \"--help\") == 0))\n\t\t\t{\n\t\t\t\tprint_usage();\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-ktx2\") == 0)\n\t\t\t{\n\t\t\t\tm_ktx2_mode = true;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-basis\") == 0)\n\t\t\t{\n\t\t\t\tm_ktx2_mode = false;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-ktx2_no_zstandard\") == 0)\n\t\t\t{\n\t\t\t\tm_ktx2_zstandard = false;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-ktx2_zstandard_level\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_ktx2_zstandard_level = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-ktx2_animdata_duration\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_ktx2_animdata_duration = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-ktx2_animdata_timescale\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_ktx2_animdata_timescale = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-ktx2_animdata_loopcount\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_ktx2_animdata_loopcount = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-ldr\") == 0)\n\t\t\t{\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-compress\") == 0)\n\t\t\t\tm_mode = cCompress;\n\t\t\telse if (strcasecmp(pArg, \"-compare\") == 0)\n\t\t\t\tm_mode = cCompare;\n\t\t\telse if ((strcasecmp(pArg, \"-hdr_compare\") == 0) || (strcasecmp(pArg, \"-compare_hdr\") == 0))\n\t\t\t\tm_mode = cHDRCompare;\n\t\t\telse if (strcasecmp(pArg, \"-split\") == 0)\n\t\t\t\tm_mode = cSplitImage;\n\t\t\telse if (strcasecmp(pArg, \"-combine\") == 0)\n\t\t\t\tm_mode = cCombineImages;\n\t\t\telse if (strcasecmp(pArg, \"-tonemap\") == 0)\n\t\t\t\tm_mode = cTonemapImage;\n\t\t\telse if (strcasecmp(pArg, \"-unpack\") == 0)\n\t\t\t\tm_mode = cUnpack;\n\t\t\telse if (strcasecmp(pArg, \"-validate\") == 0)\n\t\t\t\tm_mode = cValidate;\n\t\t\telse if (strcasecmp(pArg, \"-info\") == 0)\n\t\t\t\tm_mode = cInfo;\n\t\t\telse if ((strcasecmp(pArg, \"-version\") == 0) || (strcasecmp(pArg, \"--version\") == 0))\n\t\t\t\tm_mode = cVersion;\n\t\t\telse if (strcasecmp(pArg, \"-compare_ssim\") == 0)\n\t\t\t\tm_compare_ssim = true;\n\t\t\telse if (strcasecmp(pArg, \"-compare_plot\") == 0)\n\t\t\t\tm_compare_plot = true;\n\t\t\telse if (strcasecmp(pArg, \"-bench\") == 0)\n\t\t\t\tm_mode = cBench;\n\t\t\telse if (strcasecmp(pArg, \"-comp_size\") == 0)\n\t\t\t\tm_mode = cCompSize;\n\t\t\telse if (strcasecmp(pArg, \"-hdr_ldr_no_srgb_to_linear\") == 0)\n\t\t\t\tm_comp_params.m_hdr_ldr_srgb_to_linear_conversion = false;\n\t\t\telse if (strcasecmp(pArg, \"-hdr_uber_mode\") == 0)\n\t\t\t\tm_comp_params.m_uastc_hdr_options.m_allow_uber_mode = true;\n\t\t\telse if (strcasecmp(pArg, \"-hdr_favor_astc\") == 0)\n\t\t\t\tm_comp_params.m_hdr_favor_astc = true;\n\t\t\telse if ((strcasecmp(pArg, \"-test\") == 0) || (strcasecmp(pArg, \"-test_ldr\") == 0))\n\t\t\t\tm_mode = cTestLDR;\n\t\t\telse if (strcasecmp(pArg, \"-test_hdr\") == 0)\n\t\t\t\tm_mode = cTestHDR;\n\t\t\telse if (strcasecmp(pArg, \"-clbench\") == 0)\n\t\t\t\tm_mode = cCLBench;\n\t\t\telse if (strcasecmp(pArg, \"-test_dir\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_test_file_dir = std::string(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-no_sse\") == 0)\n\t\t\t{\n#if BASISU_SUPPORT_SSE\n\t\t\t\tg_cpu_supports_sse41 = false;\n#endif\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-no_status_output\") == 0)\n\t\t\t{\n\t\t\t\tm_comp_params.m_status_output = false;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-file\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_input_filenames.push_back(std::string(arg_v[arg_index + 1]));\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-alpha_file\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_input_alpha_filenames.push_back(std::string(arg_v[arg_index + 1]));\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-multifile_printf\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_multifile_printf = std::string(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-multifile_first\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_multifile_first = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-multifile_num\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_multifile_num = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-uastc\") == 0)\n\t\t\t\tm_comp_params.m_uastc = true;\n\t\t\telse if (strcasecmp(pArg, \"-fastest\") == 0)\n\t\t\t{\n\t\t\t\tm_comp_params.m_pack_uastc_flags &= ~cPackUASTCLevelMask;\n\t\t\t\tm_comp_params.m_pack_uastc_flags |= cPackUASTCLevelFastest;\n\n\t\t\t\tm_comp_params.m_uastc_hdr_options.set_quality_level(0);\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-slower\") == 0)\n\t\t\t{\n\t\t\t\tm_comp_params.m_pack_uastc_flags &= ~cPackUASTCLevelMask;\n\t\t\t\tm_comp_params.m_pack_uastc_flags |= cPackUASTCLevelSlower;\n\n\t\t\t\tm_comp_params.m_uastc_hdr_options.set_quality_level(3);\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-uastc_level\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\n\t\t\t\tint uastc_level = atoi(arg_v[arg_index + 1]);\n\n\t\t\t\tuastc_level = clamp<int>(uastc_level, 0, TOTAL_PACK_UASTC_LEVELS - 1);\n\t\t\t\t\t\t\t\t\n\t\t\t\tstatic_assert(TOTAL_PACK_UASTC_LEVELS == 5, \"TOTAL_PACK_UASTC_LEVELS==5\");\n\t\t\t\tstatic const uint32_t s_level_flags[TOTAL_PACK_UASTC_LEVELS] = { cPackUASTCLevelFastest, cPackUASTCLevelFaster, cPackUASTCLevelDefault, cPackUASTCLevelSlower, cPackUASTCLevelVerySlow };\n\t\t\t\t\n\t\t\t\tm_comp_params.m_pack_uastc_flags &= ~cPackUASTCLevelMask;\n\t\t\t\tm_comp_params.m_pack_uastc_flags |= s_level_flags[uastc_level];\n\n\t\t\t\tm_comp_params.m_uastc_hdr_options.set_quality_level(uastc_level);\n\t\t\t\t\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-resample\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(2);\n\t\t\t\tm_comp_params.m_resample_width = atoi(arg_v[arg_index + 1]);\n\t\t\t\tm_comp_params.m_resample_height = atoi(arg_v[arg_index + 2]);\n\t\t\t\targ_count += 2;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-resample_factor\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_resample_factor = (float)atof(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-uastc_rdo_l\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_rdo_uastc_quality_scalar = (float)atof(arg_v[arg_index + 1]);\n\t\t\t\tm_comp_params.m_rdo_uastc = true;\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-uastc_rdo_d\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_rdo_uastc_dict_size = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-uastc_rdo_b\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_rdo_uastc_max_smooth_block_error_scale = (float)atof(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-uastc_rdo_s\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_rdo_uastc_smooth_block_max_std_dev = (float)atof(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-uastc_rdo_f\") == 0)\n\t\t\t\tm_comp_params.m_rdo_uastc_favor_simpler_modes_in_rdo_mode = false;\n\t\t\telse if (strcasecmp(pArg, \"-uastc_rdo_m\") == 0)\n\t\t\t\tm_comp_params.m_rdo_uastc_multithreading = false;\n\t\t\telse if (strcasecmp(pArg, \"-linear\") == 0)\n\t\t\t\tm_comp_params.m_perceptual = false;\n\t\t\telse if (strcasecmp(pArg, \"-srgb\") == 0)\n\t\t\t\tm_comp_params.m_perceptual = true;\n\t\t\telse if (strcasecmp(pArg, \"-q\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_quality_level = clamp<int>(atoi(arg_v[arg_index + 1]), BASISU_QUALITY_MIN, BASISU_QUALITY_MAX);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-output_file\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_output_filename = arg_v[arg_index + 1];\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-output_path\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_output_path = arg_v[arg_index + 1];\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if ((strcasecmp(pArg, \"-debug\") == 0) || (strcasecmp(pArg, \"-verbose\") == 0))\n\t\t\t{\n\t\t\t\tm_comp_params.m_debug = true;\n\t\t\t\tenable_debug_printf(true);\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-validate_etc1s\") == 0)\n\t\t\t{\n\t\t\t\tm_comp_params.m_validate_etc1s = true;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-validate_output\") == 0)\n\t\t\t{\n\t\t\t\tm_comp_params.m_validate_output_data = true;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-debug_images\") == 0)\n\t\t\t\tm_comp_params.m_debug_images = true;\n\t\t\telse if (strcasecmp(pArg, \"-stats\") == 0)\n\t\t\t\tm_comp_params.m_compute_stats = true;\n\t\t\telse if (strcasecmp(pArg, \"-gen_global_codebooks\") == 0)\n\t\t\t{\n\t\t\t\t// TODO\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-use_global_codebooks\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_etc1s_use_global_codebooks_file = arg_v[arg_index + 1];\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-comp_level\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_compression_level = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-max_endpoints\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_max_endpoint_clusters = clamp<int>(atoi(arg_v[arg_index + 1]), 1, BASISU_MAX_ENDPOINT_CLUSTERS);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-max_selectors\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_max_selector_clusters = clamp<int>(atoi(arg_v[arg_index + 1]), 1, BASISU_MAX_SELECTOR_CLUSTERS);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-y_flip\") == 0)\n\t\t\t\tm_comp_params.m_y_flip = true;\n\t\t\telse if (strcasecmp(pArg, \"-normal_map\") == 0)\n\t\t\t{\n\t\t\t\tm_comp_params.m_perceptual = false;\n\t\t\t\tm_comp_params.m_mip_srgb = false;\n\t\t\t\tm_comp_params.m_no_selector_rdo = true;\n\t\t\t\tm_comp_params.m_no_endpoint_rdo = true;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-no_alpha\") == 0)\n\t\t\t\tm_comp_params.m_check_for_alpha = false;\n\t\t\telse if (strcasecmp(pArg, \"-force_alpha\") == 0)\n\t\t\t\tm_comp_params.m_force_alpha = true;\n\t\t\telse if ((strcasecmp(pArg, \"-separate_rg_to_color_alpha\") == 0) ||\n\t\t\t        (strcasecmp(pArg, \"-seperate_rg_to_color_alpha\") == 0)) // was mispelled for a while - whoops!\n\t\t\t{\n\t\t\t\tm_comp_params.m_swizzle[0] = 0;\n\t\t\t\tm_comp_params.m_swizzle[1] = 0;\n\t\t\t\tm_comp_params.m_swizzle[2] = 0;\n\t\t\t\tm_comp_params.m_swizzle[3] = 1;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-swizzle\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tconst char *swizzle = arg_v[arg_index + 1];\n\t\t\t\tif (strlen(swizzle) != 4)\n\t\t\t\t{\n\t\t\t\t\terror_printf(\"Swizzle requires exactly 4 characters\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (int i=0; i<4; ++i)\n\t\t\t\t{\n\t\t\t\t\tif (swizzle[i] == 'r')\n\t\t\t\t\t\tm_comp_params.m_swizzle[i] = 0;\n\t\t\t\t\telse if (swizzle[i] == 'g')\n\t\t\t\t\t\tm_comp_params.m_swizzle[i] = 1;\n\t\t\t\t\telse if (swizzle[i] == 'b')\n\t\t\t\t\t\tm_comp_params.m_swizzle[i] = 2;\n\t\t\t\t\telse if (swizzle[i] == 'a')\n\t\t\t\t\t\tm_comp_params.m_swizzle[i] = 3;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Swizzle must be one of [rgba]\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-renorm\") == 0)\n\t\t\t\tm_comp_params.m_renormalize = true;\n\t\t\telse if ((strcasecmp(pArg, \"-no_multithreading\") == 0) || (strcasecmp(pArg, \"-no_threading\") == 0))\n\t\t\t{\n\t\t\t\tm_comp_params.m_multithreading = false;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-parallel\") == 0)\n\t\t\t{\n\t\t\t\tm_parallel_compression = true;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-max_threads\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_max_threads = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-mipmap\") == 0)\n\t\t\t\tm_comp_params.m_mip_gen = true;\n\t\t\telse if (strcasecmp(pArg, \"-no_ktx\") == 0)\n\t\t\t\tm_no_ktx = true;\n\t\t\telse if (strcasecmp(pArg, \"-ktx_only\") == 0)\n\t\t\t\tm_ktx_only = true;\n\t\t\telse if (strcasecmp(pArg, \"-write_out\") == 0)\n\t\t\t\tm_write_out = true;\n\t\t\telse if (strcasecmp(pArg, \"-format_only\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_format_only = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-etc1_only\") == 0)\n\t\t\t{\n\t\t\t\tm_etc1_only = true;\n\t\t\t\tm_format_only = (int)basist::transcoder_texture_format::cTFETC1_RGB;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-disable_hierarchical_endpoint_codebooks\") == 0)\n\t\t\t\tm_comp_params.m_disable_hierarchical_endpoint_codebooks = true;\n\t\t\telse if (strcasecmp(pArg, \"-hdr\") == 0)\n\t\t\t{\n\t\t\t\tm_comp_params.m_hdr = true;\n\t\t\t\tm_comp_params.m_uastc = true;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-opencl\") == 0)\n\t\t\t{\n\t\t\t\tm_comp_params.m_use_opencl = true;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-opencl_serialize\") == 0)\n\t\t\t{\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-mip_scale\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_mip_scale = (float)atof(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-mip_filter\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_mip_filter = arg_v[arg_index + 1];\n\t\t\t\t// TODO: Check filter \n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-mip_renorm\") == 0)\n\t\t\t\tm_comp_params.m_mip_renormalize = true;\n\t\t\telse if (strcasecmp(pArg, \"-mip_clamp\") == 0)\n\t\t\t\tm_comp_params.m_mip_wrapping = false;\n\t\t\telse if (strcasecmp(pArg, \"-mip_fast\") == 0)\n\t\t\t\tm_comp_params.m_mip_fast = true;\n\t\t\telse if (strcasecmp(pArg, \"-mip_slow\") == 0)\n\t\t\t\tm_comp_params.m_mip_fast = false;\n\t\t\telse if (strcasecmp(pArg, \"-mip_smallest\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_mip_smallest_dimension = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-mip_srgb\") == 0)\n\t\t\t\tm_comp_params.m_mip_srgb = true;\n\t\t\telse if (strcasecmp(pArg, \"-mip_linear\") == 0)\n\t\t\t\tm_comp_params.m_mip_srgb = false;\n\t\t\telse if (strcasecmp(pArg, \"-no_selector_rdo\") == 0)\n\t\t\t\tm_comp_params.m_no_selector_rdo = true;\n\t\t\telse if (strcasecmp(pArg, \"-selector_rdo_thresh\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_selector_rdo_thresh = (float)atof(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-no_endpoint_rdo\") == 0)\n\t\t\t\tm_comp_params.m_no_endpoint_rdo = true;\n\t\t\telse if (strcasecmp(pArg, \"-endpoint_rdo_thresh\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_endpoint_rdo_thresh = (float)atof(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-userdata0\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_userdata0 = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-userdata1\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_comp_params.m_userdata1 = atoi(arg_v[arg_index + 1]);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-framerate\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tdouble fps = atof(arg_v[arg_index + 1]);\n\t\t\t\tdouble us_per_frame = 0;\n\t\t\t\tif (fps > 0)\n\t\t\t\t\tus_per_frame = 1000000.0f / fps;\n\n\t\t\t\tm_comp_params.m_us_per_frame = clamp<int>(static_cast<int>(us_per_frame + .5f), 0, basist::cBASISMaxUSPerFrame);\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-cubemap\") == 0)\n\t\t\t{\n\t\t\t\tm_comp_params.m_tex_type = basist::cBASISTexTypeCubemapArray;\n\t\t\t\tm_individual = false;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-tex_type\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tconst char* pType = arg_v[arg_index + 1];\n\n\t\t\t\tif (strcasecmp(pType, \"2d\") == 0)\n\t\t\t\t\tm_comp_params.m_tex_type = basist::cBASISTexType2D;\n\t\t\t\telse if (strcasecmp(pType, \"2darray\") == 0)\n\t\t\t\t{\n\t\t\t\t\tm_comp_params.m_tex_type = basist::cBASISTexType2DArray;\n\t\t\t\t\tm_individual = false;\n\t\t\t\t}\n\t\t\t\telse if (strcasecmp(pType, \"3d\") == 0)\n\t\t\t\t{\n\t\t\t\t\tm_comp_params.m_tex_type = basist::cBASISTexTypeVolume;\n\t\t\t\t\tm_individual = false;\n\t\t\t\t}\n\t\t\t\telse if (strcasecmp(pType, \"cubemap\") == 0)\n\t\t\t\t{\n\t\t\t\t\tm_comp_params.m_tex_type = basist::cBASISTexTypeCubemapArray;\n\t\t\t\t\tm_individual = false;\n\t\t\t\t}\n\t\t\t\telse if (strcasecmp(pType, \"video\") == 0)\n\t\t\t\t{\n\t\t\t\t\tm_comp_params.m_tex_type = basist::cBASISTexTypeVideoFrames;\n\t\t\t\t\tm_individual = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terror_printf(\"Invalid texture type: %s\\n\", pType);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (strcasecmp(pArg, \"-individual\") == 0)\n\t\t\t\tm_individual = true;\n\t\t\telse if ((strcasecmp(pArg, \"-tex_array\") == 0) || (strcasecmp(pArg, \"-texarray\") == 0))\n\t\t\t\tm_individual = false;\n\t\t\telse if (strcasecmp(pArg, \"-fuzz_testing\") == 0)\n\t\t\t\tm_fuzz_testing = true;\n\t\t\telse if (strcasecmp(pArg, \"-csv_file\") == 0)\n\t\t\t{\n\t\t\t\tREMAINING_ARGS_CHECK(1);\n\t\t\t\tm_csv_file = arg_v[arg_index + 1];\n\t\t\t\tm_comp_params.m_compute_stats = true;\n\n\t\t\t\targ_count++;\n\t\t\t}\n\t\t\telse if (pArg[0] == '-')\n\t\t\t{\n\t\t\t\terror_printf(\"Unrecognized command line option: %s\\n\", pArg);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Let's assume it's a source filename, so globbing works\n\t\t\t\t//error_printf(\"Unrecognized command line option: %s\\n\", pArg);\n\t\t\t\tm_input_filenames.push_back(pArg);\n\t\t\t}\n\n\t\t\targ_index += arg_count;\n\t\t}\n\t\t\n\t\tif (m_comp_params.m_quality_level != -1)\n\t\t{\n\t\t\tm_comp_params.m_max_endpoint_clusters = 0;\n\t\t\tm_comp_params.m_max_selector_clusters = 0;\n\t\t}\n\t\telse if ((!m_comp_params.m_max_endpoint_clusters) || (!m_comp_params.m_max_selector_clusters))\n\t\t{\n\t\t\tm_comp_params.m_max_endpoint_clusters = 0;\n\t\t\tm_comp_params.m_max_selector_clusters = 0;\n\n\t\t\tm_comp_params.m_quality_level = 128;\n\t\t}\n\n\t\tif (!m_comp_params.m_mip_srgb.was_changed())\n\t\t{\n\t\t\t// They didn't specify what colorspace to do mipmap filtering in, so choose sRGB if they've specified that the texture is sRGB.\n\t\t\tif (m_comp_params.m_perceptual)\n\t\t\t\tm_comp_params.m_mip_srgb = true;\n\t\t\telse\n\t\t\t\tm_comp_params.m_mip_srgb = false;\n\t\t}\n\t\t\t\t\n\t\treturn true;\n\t}\n\n\tbool process_listing_files()\n\t{\n\t\tbasisu::vector<std::string> new_input_filenames;\n\t\tfor (uint32_t i = 0; i < m_input_filenames.size(); i++)\n\t\t{\n\t\t\tif (m_input_filenames[i][0] == '@')\n\t\t\t{\n\t\t\t\tif (!load_listing_file(m_input_filenames[i], new_input_filenames))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnew_input_filenames.push_back(m_input_filenames[i]);\n\t\t}\n\t\tnew_input_filenames.swap(m_input_filenames);\n\n\t\tbasisu::vector<std::string> new_input_alpha_filenames;\n\t\tfor (uint32_t i = 0; i < m_input_alpha_filenames.size(); i++)\n\t\t{\n\t\t\tif (m_input_alpha_filenames[i][0] == '@')\n\t\t\t{\n\t\t\t\tif (!load_listing_file(m_input_alpha_filenames[i], new_input_alpha_filenames))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnew_input_alpha_filenames.push_back(m_input_alpha_filenames[i]);\n\t\t}\n\t\tnew_input_alpha_filenames.swap(m_input_alpha_filenames);\n\t\t\n\t\treturn true;\n\t}\n\n\tbasis_compressor_params m_comp_params;\n\t\t\n\ttool_mode m_mode;\n\n\tbool m_ktx2_mode;\n\tbool m_ktx2_zstandard;\n\tint m_ktx2_zstandard_level;\n\tuint32_t m_ktx2_animdata_duration;\n\tuint32_t m_ktx2_animdata_timescale;\n\tuint32_t m_ktx2_animdata_loopcount;\n\t\t\n\tbasisu::vector<std::string> m_input_filenames;\n\tbasisu::vector<std::string> m_input_alpha_filenames;\n\n\tstd::string m_output_filename;\n\tstd::string m_output_path;\n\n\tint m_format_only;\n\n\tstd::string m_multifile_printf;\n\tuint32_t m_multifile_first;\n\tuint32_t m_multifile_num;\n\n\tstd::string m_csv_file;\n\n\tstd::string m_etc1s_use_global_codebooks_file;\n\n\tstd::string m_test_file_dir;\n\t\n\tuint32_t m_max_threads;\n\t\t\n\tbool m_individual;\n\tbool m_no_ktx;\n\tbool m_ktx_only;\n\tbool m_write_out;\n\tbool m_etc1_only;\n\tbool m_fuzz_testing;\n\tbool m_compare_ssim;\n\tbool m_compare_plot;\n\tbool m_parallel_compression;\n};\n\nstatic bool expand_multifile(command_line_params &opts)\n{\n\tif (!opts.m_multifile_printf.size())\n\t\treturn true;\n\t\n\tif (!opts.m_multifile_num)\n\t{\n\t\terror_printf(\"-multifile_printf specified, but not -multifile_num\\n\");\n\t\treturn false;\n\t}\n\t\n\tstd::string fmt(opts.m_multifile_printf);\n\t// Workaround for MSVC debugger issues. Questionable to leave in here.\n\tsize_t x = fmt.find_first_of('!');\n\tif (x != std::string::npos)\n\t\tfmt[x] = '%';\n\n\tif (string_find_right(fmt, '%') == -1)\n\t{\n\t\terror_printf(\"Must include C-style printf() format character '%%' in -multifile_printf string\\n\");\n\t\treturn false;\n\t}\n\t\t\n\tfor (uint32_t i = opts.m_multifile_first; i < opts.m_multifile_first + opts.m_multifile_num; i++)\n\t{\n\t\tchar buf[1024];\n#ifdef _WIN32\t\t\n\t\tsprintf_s(buf, sizeof(buf), fmt.c_str(), i);\n#else\n\t\tsnprintf(buf, sizeof(buf), fmt.c_str(), i);\n#endif\t\t\n\n\t\tif (buf[0])\n\t\t\topts.m_input_filenames.push_back(buf);\n\t}\n\n\treturn true;\n}\n\nstruct basis_data\n{\n\tbasis_data() : \n\t\tm_transcoder() \n\t{\n\t}\n\tuint8_vec m_file_data;\n\tbasist::basisu_transcoder m_transcoder;\n};\n\nstatic basis_data *load_basis_file(const char *pInput_filename, bool force_etc1s)\n{\n\tbasis_data* p = new basis_data;\n\tuint8_vec &basis_data = p->m_file_data;\n\tif (!basisu::read_file_to_vec(pInput_filename, basis_data))\n\t{\n\t\terror_printf(\"Failed reading file \\\"%s\\\"\\n\", pInput_filename);\n\t\tdelete p;\n\t\treturn nullptr;\n\t}\n\tprintf(\"Input file \\\"%s\\\"\\n\", pInput_filename);\n\tif (!basis_data.size())\n\t{\n\t\terror_printf(\"File is empty!\\n\");\n\t\tdelete p;\n\t\treturn nullptr;\n\t}\n\tif (basis_data.size() > UINT32_MAX)\n\t{\n\t\terror_printf(\"File is too large!\\n\");\n\t\tdelete p;\n\t\treturn nullptr;\n\t}\n\tif (force_etc1s)\n\t{\n\t\tif (p->m_transcoder.get_tex_format((const void*)&p->m_file_data[0], (uint32_t)p->m_file_data.size()) != basist::basis_tex_format::cETC1S)\n\t\t{\n\t\t\terror_printf(\"Global codebook file must be in ETC1S format!\\n\");\n\t\t\tdelete p;\n\t\t\treturn nullptr;\n\t\t}\n\t}\n\tif (!p->m_transcoder.start_transcoding(&basis_data[0], (uint32_t)basis_data.size()))\n\t{\n\t\terror_printf(\"start_transcoding() failed!\\n\");\n\t\tdelete p;\n\t\treturn nullptr;\n\t}\n\treturn p;\n}\n\nstatic bool compress_mode(command_line_params &opts)\n{\n\tuint32_t num_threads = 1;\n\n\tif (opts.m_comp_params.m_multithreading)\n\t{\n\t\t// We use std::thread::hardware_concurrency() as a hint to determine the default # of threads to put into a pool.\n\t\tnum_threads = std::thread::hardware_concurrency();\n\t\tif (num_threads < 1)\n\t\t\tnum_threads = 1;\n\t\tif (num_threads > opts.m_max_threads)\n\t\t\tnum_threads = opts.m_max_threads;\n\t}\n\n\tjob_pool compressor_jpool(opts.m_parallel_compression ? 1 : num_threads);\n\tif (!opts.m_parallel_compression)\n\t\topts.m_comp_params.m_pJob_pool = &compressor_jpool;\n\t\t\n\tif (!expand_multifile(opts))\n\t{\n\t\terror_printf(\"-multifile expansion failed!\\n\");\n\t\treturn false;\n\t}\n\n\tif (!opts.m_input_filenames.size())\n\t{\n\t\terror_printf(\"No input files to process!\\n\");\n\t\treturn false;\n\t}\n\t\t\n\tbasis_data* pGlobal_codebook_data = nullptr;\n\tif (opts.m_etc1s_use_global_codebooks_file.size())\n\t{\n\t\tpGlobal_codebook_data = load_basis_file(opts.m_etc1s_use_global_codebooks_file.c_str(), true);\n\t\tif (!pGlobal_codebook_data)\n\t\t\treturn false;\n\n\t\tprintf(\"Loaded global codebooks from .basis file \\\"%s\\\"\\n\", opts.m_etc1s_use_global_codebooks_file.c_str());\n\t}\n\t\t\t\t\t\t\n\tbasis_compressor_params &params = opts.m_comp_params;\n\n\tif (opts.m_ktx2_mode)\n\t{\n\t\tparams.m_create_ktx2_file = true;\n\t\tif (opts.m_ktx2_zstandard)\n\t\t\tparams.m_ktx2_uastc_supercompression = basist::KTX2_SS_ZSTANDARD;\n\t\telse\n\t\t\tparams.m_ktx2_uastc_supercompression = basist::KTX2_SS_NONE;\n\t\t\n\t\tparams.m_ktx2_srgb_transfer_func = opts.m_comp_params.m_perceptual;\n\n\t\tif (params.m_tex_type == basist::basis_texture_type::cBASISTexTypeVideoFrames)\n\t\t{\n\t\t\t// Create KTXanimData key value entry\n\t\t\t// TODO: Move this to basisu_comp.h\n\t\t\tbasist::ktx2_transcoder::key_value kv;\n\n\t\t\tconst char* pAD = \"KTXanimData\";\n\t\t\tkv.m_key.resize(strlen(pAD) + 1);\n\t\t\tstrcpy((char*)kv.m_key.data(), pAD);\n\t\t\t\n\t\t\tbasist::ktx2_animdata ad;\n\t\t\tad.m_duration = opts.m_ktx2_animdata_duration;\n\t\t\tad.m_timescale = opts.m_ktx2_animdata_timescale;\n\t\t\tad.m_loopcount = opts.m_ktx2_animdata_loopcount;\n\n\t\t\tkv.m_value.resize(sizeof(ad));\n\t\t\tmemcpy(kv.m_value.data(), &ad, sizeof(ad));\n\n\t\t\tparams.m_ktx2_key_values.push_back(kv);\n\t\t}\n\t\t\n\t\t// TODO- expose this to command line.\n\t\tparams.m_ktx2_zstd_supercompression_level = opts.m_ktx2_zstandard_level;\n\t}\n\n\tparams.m_read_source_images = true;\n\tparams.m_write_output_basis_or_ktx2_files = true;\n\tparams.m_pGlobal_codebooks = pGlobal_codebook_data ? &pGlobal_codebook_data->m_transcoder.get_lowlevel_etc1s_decoder() : nullptr; \n\t\n\tFILE *pCSV_file = nullptr;\n\tif (opts.m_csv_file.size())\n\t{\n\t\t//pCSV_file = fopen_safe(opts.m_csv_file.c_str(), \"a\");\n\t\tpCSV_file = fopen_safe(opts.m_csv_file.c_str(), \"w\");\n\t\tif (!pCSV_file)\n\t\t{\n\t\t\terror_printf(\"Failed opening CVS file \\\"%s\\\"\\n\", opts.m_csv_file.c_str());\n\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\treturn false;\n\t\t}\n\t\tfprintf(pCSV_file, \"Filename, Size, Slices, Width, Height, HasAlpha, BitsPerTexel, Slice0RGBAvgPSNR, Slice0RGBAAvgPSNR, Slice0Luma709PSNR, Slice0BestETC1SLuma709PSNR, Q, CL, Time, RGBAvgPSNRMin, RGBAvgPSNRAvg, AAvgPSNRMin, AAvgPSNRAvg, Luma709PSNRMin, Luma709PSNRAvg\\n\");\n\t}\n\n\tprintf(\"Processing %u total file(s)\\n\", (uint32_t)opts.m_input_filenames.size());\n\t\t\t\t\n\tinterval_timer all_tm;\n\tall_tm.start();\n\n\tbasisu::vector<basis_compressor_params> comp_params_vec;\n\n\tconst size_t total_files = (opts.m_individual ? opts.m_input_filenames.size() : 1U);\n\tbool result = true;\n\n\tif ((opts.m_individual) && (opts.m_output_filename.size()))\n\t{\n\t\tif (total_files > 1)\n\t\t{\n\t\t\terror_printf(\"-output_file specified in individual mode, but multiple input files have been specified which would cause the output file to be written multiple times.\\n\");\n\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tuint32_t total_successes = 0, total_failures = 0;\n\n\tfor (size_t file_index = 0; file_index < total_files; file_index++)\n\t{\n\t\tif (opts.m_individual)\n\t\t{\n\t\t\tparams.m_source_filenames.resize(1);\n\t\t\tparams.m_source_filenames[0] = opts.m_input_filenames[file_index];\n\n\t\t\tif (file_index < opts.m_input_alpha_filenames.size())\n\t\t\t{\n\t\t\t\tparams.m_source_alpha_filenames.resize(1);\n\t\t\t\tparams.m_source_alpha_filenames[0] = opts.m_input_alpha_filenames[file_index];\n\n\t\t\t\tif (params.m_status_output)\n\t\t\t\t\tprintf(\"Processing source file \\\"%s\\\", alpha file \\\"%s\\\"\\n\", params.m_source_filenames[0].c_str(), params.m_source_alpha_filenames[0].c_str());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparams.m_source_alpha_filenames.resize(0);\n\n\t\t\t\tif (params.m_status_output)\n\t\t\t\t\tprintf(\"Processing source file \\\"%s\\\"\\n\", params.m_source_filenames[0].c_str());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparams.m_source_filenames = opts.m_input_filenames;\n\t\t\tparams.m_source_alpha_filenames = opts.m_input_alpha_filenames;\n\t\t}\n\t\t\t\t\t\t\t\t\n\t\tif (opts.m_output_filename.size())\n\t\t\tparams.m_out_filename = opts.m_output_filename;\n\t\telse\n\t\t{\n\t\t\tstd::string filename;\n\n\t\t\tstring_get_filename(opts.m_input_filenames[file_index].c_str(), filename);\n\t\t\tstring_remove_extension(filename);\n\n\t\t\tif (opts.m_ktx2_mode)\n\t\t\t\tfilename += \".ktx2\";\n\t\t\telse\n\t\t\t\tfilename += \".basis\";\n\n\t\t\tif (opts.m_output_path.size())\n\t\t\t\tstring_combine_path(filename, opts.m_output_path.c_str(), filename.c_str());\n\n\t\t\tparams.m_out_filename = filename;\n\t\t}\n\n\t\tif (opts.m_parallel_compression)\n\t\t{\n\t\t\tcomp_params_vec.push_back(params);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbasis_compressor c;\n\n\t\t\tif (!c.init(opts.m_comp_params))\n\t\t\t{\n\t\t\t\terror_printf(\"basis_compressor::init() failed!\\n\");\n\n\t\t\t\tif (pCSV_file)\n\t\t\t\t{\n\t\t\t\t\tfclose(pCSV_file);\n\t\t\t\t\tpCSV_file = nullptr;\n\t\t\t\t}\n\n\t\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tinterval_timer tm;\n\t\t\ttm.start();\n\n\t\t\tbasis_compressor::error_code ec = c.process();\n\n\t\t\ttm.stop();\n\n\t\t\tif (ec == basis_compressor::cECSuccess)\n\t\t\t{\n\t\t\t\ttotal_successes++;\n\n\t\t\t\tif (params.m_status_output)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Compression succeeded to file \\\"%s\\\" size %u bytes in %3.3f secs\\n\", params.m_out_filename.c_str(),\n\t\t\t\t\t\topts.m_ktx2_mode ? c.get_output_ktx2_file().size() : c.get_output_basis_file().size(),\n\t\t\t\t\t\ttm.get_elapsed_secs());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttotal_failures++;\n\n\t\t\t\tresult = false;\n\n\t\t\t\tif (!params.m_status_output)\n\t\t\t\t{\n\t\t\t\t\terror_printf(\"Compression failed on file \\\"%s\\\"\\n\", params.m_out_filename.c_str());\n\t\t\t\t}\n\n\t\t\t\tbool exit_flag = true;\n\n\t\t\t\tswitch (ec)\n\t\t\t\t{\n\t\t\t\tcase basis_compressor::cECFailedReadingSourceImages:\n\t\t\t\t{\n\t\t\t\t\terror_printf(\"Compressor failed reading a source image!\\n\");\n\n\t\t\t\t\tif (opts.m_individual)\n\t\t\t\t\t\texit_flag = false;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase basis_compressor::cECFailedValidating:\n\t\t\t\t\terror_printf(\"Compressor failed 2darray/cubemap/video validation checks!\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase basis_compressor::cECFailedEncodeUASTC:\n\t\t\t\t\terror_printf(\"Compressor UASTC encode failed!\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase basis_compressor::cECFailedFrontEnd:\n\t\t\t\t\terror_printf(\"Compressor frontend stage failed!\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase basis_compressor::cECFailedFontendExtract:\n\t\t\t\t\terror_printf(\"Compressor frontend data extraction failed!\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase basis_compressor::cECFailedBackend:\n\t\t\t\t\terror_printf(\"Compressor backend stage failed!\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase basis_compressor::cECFailedCreateBasisFile:\n\t\t\t\t\terror_printf(\"Compressor failed creating Basis file data!\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase basis_compressor::cECFailedWritingOutput:\n\t\t\t\t\terror_printf(\"Compressor failed writing to output Basis file!\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase basis_compressor::cECFailedUASTCRDOPostProcess:\n\t\t\t\t\terror_printf(\"Compressor failed during the UASTC post process step!\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase basis_compressor::cECFailedCreateKTX2File:\n\t\t\t\t\terror_printf(\"Compressor failed creating KTX2 file data!\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\terror_printf(\"basis_compress::process() failed!\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (exit_flag)\n\t\t\t\t{\n\t\t\t\t\tif (pCSV_file)\n\t\t\t\t\t{\n\t\t\t\t\t\tfclose(pCSV_file);\n\t\t\t\t\t\tpCSV_file = nullptr;\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((pCSV_file) && (c.get_stats().size()))\n\t\t\t{\n\t\t\t\tif (c.get_stats().size())\n\t\t\t\t{\n\t\t\t\t\tfloat rgb_avg_psnr_min = 1e+9f, rgb_avg_psnr_avg = 0.0f;\n\t\t\t\t\tfloat a_avg_psnr_min = 1e+9f, a_avg_psnr_avg = 0.0f;\n\t\t\t\t\tfloat luma_709_psnr_min = 1e+9f, luma_709_psnr_avg = 0.0f;\n\n\t\t\t\t\tfor (size_t slice_index = 0; slice_index < c.get_stats().size(); slice_index++)\n\t\t\t\t\t{\n\t\t\t\t\t\trgb_avg_psnr_min = basisu::minimum(rgb_avg_psnr_min, c.get_stats()[slice_index].m_basis_rgb_avg_psnr);\n\t\t\t\t\t\trgb_avg_psnr_avg += c.get_stats()[slice_index].m_basis_rgb_avg_psnr;\n\n\t\t\t\t\t\ta_avg_psnr_min = basisu::minimum(a_avg_psnr_min, c.get_stats()[slice_index].m_basis_a_avg_psnr);\n\t\t\t\t\t\ta_avg_psnr_avg += c.get_stats()[slice_index].m_basis_a_avg_psnr;\n\n\t\t\t\t\t\tluma_709_psnr_min = basisu::minimum(luma_709_psnr_min, c.get_stats()[slice_index].m_basis_luma_709_psnr);\n\t\t\t\t\t\tluma_709_psnr_avg += c.get_stats()[slice_index].m_basis_luma_709_psnr;\n\t\t\t\t\t}\n\n\t\t\t\t\trgb_avg_psnr_avg /= c.get_stats().size();\n\t\t\t\t\ta_avg_psnr_avg /= c.get_stats().size();\n\t\t\t\t\tluma_709_psnr_avg /= c.get_stats().size();\n\n\t\t\t\t\tfprintf(pCSV_file, \"\\\"%s\\\", %u, %u, %u, %u, %u, %f, %f, %f, %f, %f, %u, %u, %f, %f, %f, %f, %f, %f, %f\\n\",\n\t\t\t\t\t\tparams.m_out_filename.c_str(),\n\t\t\t\t\t\tc.get_basis_file_size(),\n\t\t\t\t\t\t(uint32_t)c.get_stats().size(),\n\t\t\t\t\t\tc.get_stats()[0].m_width, c.get_stats()[0].m_height, (uint32_t)c.get_any_source_image_has_alpha(),\n\t\t\t\t\t\tc.get_basis_bits_per_texel(),\n\t\t\t\t\t\tc.get_stats()[0].m_basis_rgb_avg_psnr,\n\t\t\t\t\t\tc.get_stats()[0].m_basis_rgba_avg_psnr,\n\t\t\t\t\t\tc.get_stats()[0].m_basis_luma_709_psnr,\n\t\t\t\t\t\tc.get_stats()[0].m_best_etc1s_luma_709_psnr,\n\t\t\t\t\t\tparams.m_quality_level, (int)params.m_compression_level, tm.get_elapsed_secs(),\n\t\t\t\t\t\trgb_avg_psnr_min, rgb_avg_psnr_avg,\n\t\t\t\t\t\ta_avg_psnr_min, a_avg_psnr_avg,\n\t\t\t\t\t\tluma_709_psnr_min, luma_709_psnr_avg);\n\t\t\t\t\tfflush(pCSV_file);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//if ((opts.m_individual) && (params.m_status_output))\n\t\t\t//\tprintf(\"\\n\");\n\n\t\t} // if (opts.m_parallel_compression)\n\n\t} // file_index\n\n\tif (opts.m_parallel_compression)\n\t{\n\t\tbasisu::vector<parallel_results> results;\n\n\t\tbool any_failed = basis_parallel_compress(\n\t\t\tnum_threads,\n\t\t\tcomp_params_vec,\n\t\t\tresults);\n\t\tBASISU_NOTE_UNUSED(any_failed);\n\t\t\t\t\n\t\tfor (uint32_t i = 0; i < comp_params_vec.size(); i++)\n\t\t{\n\t\t\tif (results[i].m_error_code != basis_compressor::cECSuccess)\n\t\t\t{\n\t\t\t\tresult = false;\n\n\t\t\t\ttotal_failures++;\n\n\t\t\t\terror_printf(\"File %u (first source image: \\\"%s\\\", output file: \\\"%s\\\") failed with error code %i!\\n\", i, \n\t\t\t\t\tcomp_params_vec[i].m_source_filenames[0].c_str(), \n\t\t\t\t\tcomp_params_vec[i].m_out_filename.c_str(),\n\t\t\t\t\t(int)results[i].m_error_code);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttotal_successes++;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t} // if (opts.m_parallel_compression)\n\n\tprintf(\"Total successes: %u failures: %u\\n\", total_successes, total_failures);\n\t\t\n\tall_tm.stop();\n\n\tif (total_files > 1)\n\t\tprintf(\"Total compression time: %3.3f secs\\n\", all_tm.get_elapsed_secs());\n\n\tif (pCSV_file)\n\t{\n\t\tfclose(pCSV_file);\n\t\tpCSV_file = nullptr;\n\t}\n\tdelete pGlobal_codebook_data; \n\tpGlobal_codebook_data = nullptr;\n\n\treturn result;\n}\n\nstatic bool unpack_and_validate_ktx2_file(\n\tuint32_t file_index,\n\tconst std::string& base_filename,\n\tuint8_vec& ktx2_file_data,\n\tcommand_line_params& opts,\n\tFILE* pCSV_file,\n\tbasis_data* pGlobal_codebook_data,\n\tuint32_t& total_unpack_warnings,\n\tuint32_t& total_pvrtc_nonpow2_warnings)\n{\n\t// TODO\n\t(void)pCSV_file;\n\t(void)file_index;\n\n\tconst bool validate_flag = (opts.m_mode == cValidate);\n\n\tbasist::ktx2_transcoder dec;\n\n\tif (!dec.init(ktx2_file_data.data(), ktx2_file_data.size()))\n\t{\n\t\terror_printf(\"ktx2_transcoder::init() failed! File either uses an unsupported feature, is invalid, was corrupted, or this is a bug.\\n\");\n\t\treturn false;\n\t}\n\n\tif (!dec.start_transcoding())\n\t{\n\t\terror_printf(\"ktx2_transcoder::start_transcoding() failed! File either uses an unsupported feature, is invalid, was corrupted, or this is a bug.\\n\");\n\t\treturn false;\n\t}\n\t\t\n\tprintf(\"Resolution: %ux%u\\n\", dec.get_width(), dec.get_height());\n\tprintf(\"Mipmap Levels: %u\\n\", dec.get_levels());\n\tprintf(\"Texture Array Size (layers): %u\\n\", dec.get_layers());\n\tprintf(\"Total Faces: %u (%s)\\n\", dec.get_faces(), (dec.get_faces() == 6) ? \"CUBEMAP\" : \"2D\");\n\tprintf(\"Is Texture Video: %u\\n\", dec.is_video());\n\t\n\tconst bool is_etc1s = (dec.get_format() == basist::basis_tex_format::cETC1S);\n\t\n\tconst char* pFmt_str = \"ETC1S\";\n\tif (dec.get_format() == basist::basis_tex_format::cUASTC4x4)\n\t\tpFmt_str = \"UASTC\";\n\telse if (dec.get_format() == basist::basis_tex_format::cUASTC_HDR_4x4)\n\t\tpFmt_str = \"UASTC_HDR\";\n\n\tprintf(\"Supercompression Format: %s\\n\", pFmt_str);\n\t\n\tprintf(\"Supercompression Scheme: \");\n\tswitch (dec.get_header().m_supercompression_scheme)\n\t{\n\tcase basist::KTX2_SS_NONE: printf(\"NONE\\n\"); break;\n\tcase basist::KTX2_SS_BASISLZ: printf(\"BASISLZ\\n\"); break;\n\tcase basist::KTX2_SS_ZSTANDARD: printf(\"ZSTANDARD\\n\"); break;\n\tdefault:\n\t\terror_printf(\"Invalid/unknown/unsupported\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"Has Alpha: %u\\n\", (uint32_t)dec.get_has_alpha());\n\t\n\tprintf(\"\\nKTX2 header vk_format: 0x%X (decimal %u)\\n\", (uint32_t)dec.get_header().m_vk_format, (uint32_t)dec.get_header().m_vk_format);\n\t\n\tprintf(\"\\nData Format Descriptor (DFD):\\n\");\n\tprintf(\"DFD length in bytes: %u\\n\", dec.get_dfd().size());\n\tprintf(\"DFD color model: %u\\n\", dec.get_dfd_color_model());\n\tprintf(\"DFD color primaries: %u (%s)\\n\", dec.get_dfd_color_primaries(), basist::ktx2_get_df_color_primaries_str(dec.get_dfd_color_primaries()));\n\tprintf(\"DFD transfer func: %u (%s)\\n\", dec.get_dfd_transfer_func(),\n\t\t(dec.get_dfd_transfer_func() == basist::KTX2_KHR_DF_TRANSFER_LINEAR) ? \"LINEAR\" : ((dec.get_dfd_transfer_func() == basist::KTX2_KHR_DF_TRANSFER_SRGB) ? \"SRGB\" : \"?\"));\n\tprintf(\"DFD flags: %u\\n\", dec.get_dfd_flags());\n\tprintf(\"DFD samples: %u\\n\", dec.get_dfd_total_samples());\n\tif (is_etc1s)\n\t{\n\t\tprintf(\"DFD chan0: %s\\n\", basist::ktx2_get_etc1s_df_channel_id_str(dec.get_dfd_channel_id0()));\n\t\tif (dec.get_dfd_total_samples() == 2)\n\t\t\tprintf(\"DFD chan1: %s\\n\", basist::ktx2_get_etc1s_df_channel_id_str(dec.get_dfd_channel_id1()));\n\t}\n\telse\n\t\tprintf(\"DFD chan0: %s\\n\", basist::ktx2_get_uastc_df_channel_id_str(dec.get_dfd_channel_id0()));\n\t\t\n\tprintf(\"DFD hex values:\\n\");\n\tfor (uint32_t i = 0; i < dec.get_dfd().size(); i++)\n\t{\n\t\tprintf(\"0x%X\", dec.get_dfd()[i]);\n\t\tif ((i + 1) != dec.get_dfd().size())\n\t\t\tprintf(\",\");\n\t\tif ((i & 3) == 3)\n\t\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\n\n\tprintf(\"Total key values: %u\\n\", dec.get_key_values().size());\n\tfor (uint32_t i = 0; i < dec.get_key_values().size(); i++)\n\t{\n\t\tprintf(\"%u. Key: \\\"%s\\\", Value length in bytes: %u\", i, (const char*)dec.get_key_values()[i].m_key.data(), dec.get_key_values()[i].m_value.size());\n\n\t\tif (dec.get_key_values()[i].m_value.size() > 256)\n\t\t\tcontinue;\n\t\t\n\t\tbool is_ascii = true;\n\t\tfor (uint32_t j = 0; j < dec.get_key_values()[i].m_value.size(); j++)\n\t\t{\n\t\t\tuint8_t c = dec.get_key_values()[i].m_value[j];\n\t\t\tif (!( \n\t\t\t\t((c >= ' ') && (c < 0x80)) || \n\t\t\t\t((j == dec.get_key_values()[i].m_value.size() - 1) && (!c))\n\t\t\t\t))\n\t\t\t{\n\t\t\t\tis_ascii = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (is_ascii)\n\t\t{\n\t\t\tuint8_vec s(dec.get_key_values()[i].m_value);\n\t\t\ts.push_back(0);\n\t\t\tprintf(\" Value String: \\\"%s\\\"\", (const char *)s.data());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\" Value Bytes: \");\n\t\t\tfor (uint32_t j = 0; j < dec.get_key_values()[i].m_value.size(); j++)\n\t\t\t{\n\t\t\t\tif (j)\n\t\t\t\t\tprintf(\",\");\n\t\t\t\tprintf(\"0x%X\", dec.get_key_values()[i].m_value[j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (is_etc1s)\n\t{\n\t\tprintf(\"ETC1S header:\\n\");\n\n\t\tprintf(\"Endpoint Count: %u, Selector Count: %u, Endpoint Length: %u, Selector Length: %u, Tables Length: %u, Extended Length: %u\\n\",\n\t\t\t(uint32_t)dec.get_etc1s_header().m_endpoint_count, (uint32_t)dec.get_etc1s_header().m_selector_count,\n\t\t\t(uint32_t)dec.get_etc1s_header().m_endpoints_byte_length, (uint32_t)dec.get_etc1s_header().m_selectors_byte_length,\n\t\t\t(uint32_t)dec.get_etc1s_header().m_tables_byte_length, (uint32_t)dec.get_etc1s_header().m_extended_byte_length);\n\n\t\tprintf(\"Total ETC1S image descs: %u\\n\", dec.get_etc1s_image_descs().size());\n\t\tfor (uint32_t i = 0; i < dec.get_etc1s_image_descs().size(); i++)\n\t\t{\n\t\t\tprintf(\"%u. Flags: 0x%X, RGB Ofs: %u Len: %u, Alpha Ofs: %u, Len: %u\\n\", i,\n\t\t\t\t(uint32_t)dec.get_etc1s_image_descs()[i].m_image_flags,\n\t\t\t\t(uint32_t)dec.get_etc1s_image_descs()[i].m_rgb_slice_byte_offset, (uint32_t)dec.get_etc1s_image_descs()[i].m_rgb_slice_byte_length,\n\t\t\t\t(uint32_t)dec.get_etc1s_image_descs()[i].m_alpha_slice_byte_offset, (uint32_t)dec.get_etc1s_image_descs()[i].m_alpha_slice_byte_length);\n\t\t}\n\t}\n\n\tprintf(\"Levels:\\n\");\n\tfor (uint32_t i = 0; i < dec.get_levels(); i++)\n\t{\n\t\tprintf(\"%u. Offset: %llu, Length: %llu, Uncompressed Length: %llu\\n\",\n\t\t\ti, (long long unsigned int)dec.get_level_index()[i].m_byte_offset,\n\t\t\t(long long unsigned int)dec.get_level_index()[i].m_byte_length,\n\t\t\t(long long unsigned int)dec.get_level_index()[i].m_uncompressed_byte_length);\n\t}\n\n\tif (opts.m_mode == cInfo)\n\t{\n\t\treturn true;\n\t}\n\n\t// gpu_images[format][face][layer][level]\n\n\tbasisu::vector< gpu_image_vec > gpu_images[(int)basist::transcoder_texture_format::cTFTotalTextureFormats][6];\n\n\tint first_format = 0;\n\tint last_format = (int)basist::transcoder_texture_format::cTFTotalTextureFormats;\n\n\tif (opts.m_format_only > -1)\n\t{\n\t\tfirst_format = opts.m_format_only;\n\t\tlast_format = first_format + 1;\n\t}\n\n\tconst uint32_t total_layers = maximum<uint32_t>(1, dec.get_layers());\n\n\tfor (int format_iter = first_format; format_iter < last_format; format_iter++)\n\t{\n\t\tbasist::transcoder_texture_format tex_fmt = static_cast<basist::transcoder_texture_format>(format_iter);\n\n\t\tif (basist::basis_transcoder_format_is_uncompressed(tex_fmt))\n\t\t\tcontinue;\n\n\t\tif (!basis_is_format_supported(tex_fmt, dec.get_format()))\n\t\t\tcontinue;\n\n\t\tif (tex_fmt == basist::transcoder_texture_format::cTFBC7_ALT)\n\t\t\tcontinue;\n\n\t\tfor (uint32_t face_index = 0; face_index < dec.get_faces(); face_index++)\n\t\t{\n\t\t\tgpu_images[(int)tex_fmt][face_index].resize(total_layers);\n\n\t\t\tfor (uint32_t layer_index = 0; layer_index < total_layers; layer_index++)\n\t\t\t\tgpu_images[(int)tex_fmt][face_index][layer_index].resize(dec.get_levels());\n\t\t}\n\t}\n\n\t// Now transcode the file to all supported texture formats and save mipmapped KTX/DDS files\n\tfor (int format_iter = first_format; format_iter < last_format; format_iter++)\n\t{\n\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = static_cast<basist::transcoder_texture_format>(format_iter);\n\n\t\tif (basist::basis_transcoder_format_is_uncompressed(transcoder_tex_fmt))\n\t\t\tcontinue;\n\t\tif (!basis_is_format_supported(transcoder_tex_fmt, dec.get_format()))\n\t\t\tcontinue;\n\t\tif (transcoder_tex_fmt == basist::transcoder_texture_format::cTFBC7_ALT)\n\t\t\tcontinue;\n\n\t\tfor (uint32_t level_index = 0; level_index < dec.get_levels(); level_index++)\n\t\t{\n\t\t\tfor (uint32_t layer_index = 0; layer_index < total_layers; layer_index++)\n\t\t\t{\n\t\t\t\tfor (uint32_t face_index = 0; face_index < dec.get_faces(); face_index++)\n\t\t\t\t{\n\t\t\t\t\tbasist::ktx2_image_level_info level_info;\n\n\t\t\t\t\tif (!dec.get_image_level_info(level_info, level_index, layer_index, face_index))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed retrieving image level information (%u %u %u)!\\n\", layer_index, level_index, face_index);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((transcoder_tex_fmt == basist::transcoder_texture_format::cTFPVRTC1_4_RGB) || (transcoder_tex_fmt == basist::transcoder_texture_format::cTFPVRTC1_4_RGBA))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!is_pow2(level_info.m_width) || !is_pow2(level_info.m_height))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotal_pvrtc_nonpow2_warnings++;\n\n\t\t\t\t\t\t\tprintf(\"Warning: Will not transcode image %u level %u res %ux%u to PVRTC1 (one or more dimension is not a power of 2)\\n\", layer_index, level_index, level_info.m_width, level_info.m_height);\n\n\t\t\t\t\t\t\t// Can't transcode this image level to PVRTC because it's not a pow2 (we're going to support transcoding non-pow2 to the next larger pow2 soon)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbasisu::texture_format tex_fmt = basis_get_basisu_texture_format(transcoder_tex_fmt);\n\n\t\t\t\t\tgpu_image& gi = gpu_images[(int)transcoder_tex_fmt][face_index][layer_index][level_index];\n\t\t\t\t\tgi.init(tex_fmt, level_info.m_orig_width, level_info.m_orig_height);\n\n\t\t\t\t\t// Fill the buffer with psuedo-random bytes, to help more visibly detect cases where the transcoder fails to write to part of the output.\n\t\t\t\t\tfill_buffer_with_random_bytes(gi.get_ptr(), gi.get_size_in_bytes());\n\n\t\t\t\t\tuint32_t decode_flags = 0;\n\n\t\t\t\t\tif (!dec.transcode_image_level(level_index, layer_index, face_index, gi.get_ptr(), gi.get_total_blocks(), transcoder_tex_fmt, decode_flags))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed transcoding image level (%u %u %u %u)!\\n\", layer_index, level_index, face_index, format_iter);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"Transcode of layer %u level %u face %u res %ux%u format %s succeeded\\n\", layer_index, level_index, face_index, level_info.m_orig_width, level_info.m_orig_height, basist::basis_get_format_name(transcoder_tex_fmt));\n\t\t\t\t}\n\n\t\t\t} // format_iter\n\n\t\t} // level_index\n\n\t} // image_info\n\n\t// Return if we're just validating that transcoding succeeds\n\tif (validate_flag)\n\t\treturn true;\n\n\t// Now write KTX/DDS files and unpack them to individual PNG's/EXR's\n\tconst bool is_cubemap = (dec.get_faces() > 1);\n\tconst bool is_array = (total_layers > 1);\n\tconst bool is_cubemap_array = is_cubemap && is_array;\n\tconst bool is_mipmapped = dec.get_levels() > 1;\n\tBASISU_NOTE_UNUSED(is_cubemap_array);\n\tBASISU_NOTE_UNUSED(is_mipmapped);\n\t\n\t// The maximum Direct3D array size is 2048.\n\tconst uint32_t MAX_DDS_TEXARRAY_SIZE = 2048;\n\n\tfor (int format_iter = first_format; format_iter < last_format; format_iter++)\n\t{\n\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = static_cast<basist::transcoder_texture_format>(format_iter);\n\t\tconst basisu::texture_format tex_fmt = basis_get_basisu_texture_format(transcoder_tex_fmt);\n\t\t\t\t\n\t\tif (basist::basis_transcoder_format_is_uncompressed(transcoder_tex_fmt))\n\t\t\tcontinue;\n\t\tif (!basis_is_format_supported(transcoder_tex_fmt, dec.get_format()))\n\t\t\tcontinue;\n\t\tif (transcoder_tex_fmt == basist::transcoder_texture_format::cTFBC7_ALT)\n\t\t\tcontinue;\n\n\t\t// TODO: Could write DDS texture arrays.\n\t\t\n\t\t// No KTX tool that we know of supports cubemap arrays, so write individual cubemap files for each layer.\n\t\tif ((!opts.m_no_ktx) && (is_cubemap))\n\t\t{\n\t\t\t// Write a separate compressed texture file for each layer in a texarray.\n\t\t\tfor (uint32_t layer_index = 0; layer_index < total_layers; layer_index++)\n\t\t\t{\n\t\t\t\tbasisu::vector<gpu_image_vec> cubemap;\n\t\t\t\tfor (uint32_t face_index = 0; face_index < 6; face_index++)\n\t\t\t\t\tcubemap.push_back(gpu_images[format_iter][face_index][layer_index]);\n\n\t\t\t\t{\n\t\t\t\t\tstd::string ktx_filename(base_filename + string_format(\"_transcoded_cubemap_%s_layer_%u.ktx\", basist::basis_get_format_name(transcoder_tex_fmt), layer_index));\n\n\t\t\t\t\tif (!write_compressed_texture_file(ktx_filename.c_str(), cubemap, true, true))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed writing KTX file \\\"%s\\\"!\\n\", ktx_filename.c_str());\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"Wrote KTX cubemap file \\\"%s\\\"\\n\", ktx_filename.c_str());\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\tif (does_dds_support_format(cubemap[0][0].get_format()))\n\t\t\t\t{\n\t\t\t\t\tstd::string dds_filename(base_filename + string_format(\"_transcoded_cubemap_%s_layer_%u.dds\", basist::basis_get_format_name(transcoder_tex_fmt), layer_index));\n\n\t\t\t\t\tif (!write_compressed_texture_file(dds_filename.c_str(), cubemap, true, true))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed writing DDS file \\\"%s\\\"!\\n\", dds_filename.c_str());\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"Wrote DDS cubemap file \\\"%s\\\"\\n\", dds_filename.c_str());\n\t\t\t\t}\n\t\t\t} // layer_index\n\t\t}\n\n\t\t// For texture arrays, let's be adventurous and write a DDS texture array file. RenderDoc and DDSView (DirectXTex) can view them. (Only RenderDoc allows viewing them entirely.)\n\t\tif ((!opts.m_no_ktx) && (is_array) && (total_layers <= MAX_DDS_TEXARRAY_SIZE))\n\t\t{\n\t\t\tif (does_dds_support_format(tex_fmt))\n\t\t\t{\n\t\t\t\tbasisu::vector<gpu_image_vec> tex_array;\n\t\t\t\tfor (uint32_t layer_index = 0; layer_index < total_layers; layer_index++)\n\t\t\t\t\tfor (uint32_t face_index = 0; face_index < dec.get_faces(); face_index++)\n\t\t\t\t\t\ttex_array.push_back(gpu_images[format_iter][face_index][layer_index]);\n\n\t\t\t\tstd::string dds_filename(base_filename + string_format(\"_transcoded_array_%s.dds\", basist::basis_get_format_name(transcoder_tex_fmt)));\n\n\t\t\t\tif (!write_compressed_texture_file(dds_filename.c_str(), tex_array, is_cubemap, true))\n\t\t\t\t{\n\t\t\t\t\terror_printf(\"Failed writing DDS file \\\"%s\\\"!\\n\", dds_filename.c_str());\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tprintf(\"Wrote DDS texture array file \\\"%s\\\"\\n\", dds_filename.c_str());\n\t\t\t}\n\t\t}\n\n\t\t// Now unpack each layer and face individually and write KTX/DDS/PNG/EXR files for each\n\t\tfor (uint32_t layer_index = 0; layer_index < total_layers; layer_index++)\n\t\t{\n\t\t\tfor (uint32_t face_index = 0; face_index < dec.get_faces(); face_index++)\n\t\t\t{\n\t\t\t\tgpu_image_vec& gi = gpu_images[format_iter][face_index][layer_index];\n\n\t\t\t\tif (!gi.size())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tuint32_t level;\n\t\t\t\tfor (level = 0; level < gi.size(); level++)\n\t\t\t\t\tif (!gi[level].get_total_blocks())\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tif (level < gi.size())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Write separate compressed KTX/DDS textures with mipmap levels for each individual texarray layer and face.\n\t\t\t\tif (!opts.m_no_ktx)\n\t\t\t\t{\n\t\t\t\t\t// Write KTX\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string ktx_filename;\n\t\t\t\t\t\tif (is_cubemap)\n\t\t\t\t\t\t\tktx_filename = base_filename + string_format(\"_transcoded_%s_face_%u_layer_%04u.ktx\", basist::basis_get_format_name(transcoder_tex_fmt), face_index, layer_index);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tktx_filename = base_filename + string_format(\"_transcoded_%s_layer_%04u.ktx\", basist::basis_get_format_name(transcoder_tex_fmt), layer_index);\n\n\t\t\t\t\t\tif (!write_compressed_texture_file(ktx_filename.c_str(), gi, true))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing KTX file \\\"%s\\\"!\\n\", ktx_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote KTX file \\\"%s\\\"\\n\", ktx_filename.c_str());\n\t\t\t\t\t}\n\n\t\t\t\t\t// Write DDS if it supports this texture format\n\t\t\t\t\tif (does_dds_support_format(gi[0].get_format()))\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string dds_filename;\n\t\t\t\t\t\tif (is_cubemap)\n\t\t\t\t\t\t\tdds_filename = base_filename + string_format(\"_transcoded_%s_face_%u_layer_%04u.dds\", basist::basis_get_format_name(transcoder_tex_fmt), face_index, layer_index);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdds_filename = base_filename + string_format(\"_transcoded_%s_layer_%04u.dds\", basist::basis_get_format_name(transcoder_tex_fmt), layer_index);\n\n\t\t\t\t\t\tif (!write_compressed_texture_file(dds_filename.c_str(), gi, true))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing DDS file \\\"%s\\\"!\\n\", dds_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote DDS file \\\"%s\\\"\\n\", dds_filename.c_str());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Now unpack and save PNG/EXR files\n\t\t\t\tfor (uint32_t level_index = 0; level_index < gi.size(); level_index++)\n\t\t\t\t{\n\t\t\t\t\tbasist::ktx2_image_level_info level_info;\n\n\t\t\t\t\tif (!dec.get_image_level_info(level_info, level_index, layer_index, face_index))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed retrieving image level information (%u %u %u)!\\n\", layer_index, level_index, face_index);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (basist::basis_transcoder_format_is_hdr(transcoder_tex_fmt))\n\t\t\t\t\t{\n\t\t\t\t\t\timagef u;\n\n\t\t\t\t\t\tif (!gi[level_index].unpack_hdr(u))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"Warning: Failed unpacking HDR GPU texture data (%u %u %u %u). Unpacking as much as possible.\\n\", format_iter, layer_index, level_index, face_index);\n\t\t\t\t\t\t\ttotal_unpack_warnings++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!opts.m_ktx_only)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::string rgb_filename;\n\t\t\t\t\t\t\tif (gi.size() > 1)\n\t\t\t\t\t\t\t\trgb_filename = base_filename + string_format(\"_hdr_unpacked_rgb_%s_level_%u_face_%u_layer_%04u.exr\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, face_index, layer_index);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\trgb_filename = base_filename + string_format(\"_hdr_unpacked_rgb_%s_face_%u_layer_%04u.exr\", basist::basis_get_format_name(transcoder_tex_fmt), face_index, layer_index);\n\n\t\t\t\t\t\t\tif (!write_exr(rgb_filename.c_str(), u, 3, 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_printf(\"Failed writing to EXR file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"Wrote EXR file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\timage u;\n\t\t\t\t\t\tif (!gi[level_index].unpack(u))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"Warning: Failed unpacking GPU texture data (%u %u %u %u). Unpacking as much as possible.\\n\", format_iter, layer_index, level_index, face_index);\n\t\t\t\t\t\t\ttotal_unpack_warnings++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//u.crop(level_info.m_orig_width, level_info.m_orig_height);\n\n\t\t\t\t\t\tbool write_png = true;\n\n\t\t\t\t\t\t// Save PNG (ignoring alpha)\n\t\t\t\t\t\tif ((!opts.m_ktx_only) && (write_png))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::string rgb_filename;\n\t\t\t\t\t\t\tif (gi.size() > 1)\n\t\t\t\t\t\t\t\trgb_filename = base_filename + string_format(\"_unpacked_rgb_%s_level_%u_face_%u_layer_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, face_index, layer_index);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\trgb_filename = base_filename + string_format(\"_unpacked_rgb_%s_face_%u_layer_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), face_index, layer_index);\n\t\t\t\t\t\t\tif (!save_png(rgb_filename, u, cImageSaveIgnoreAlpha))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Save .OUT\n\t\t\t\t\t\tif ((transcoder_tex_fmt == basist::transcoder_texture_format::cTFFXT1_RGB) && (opts.m_write_out))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::string out_filename;\n\t\t\t\t\t\t\tif (gi.size() > 1)\n\t\t\t\t\t\t\t\tout_filename = base_filename + string_format(\"_unpacked_rgb_%s_level_%u_face_%u_layer_%04u.out\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, face_index, layer_index);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tout_filename = base_filename + string_format(\"_unpacked_rgb_%s_face_%u_layer_%04u.out\", basist::basis_get_format_name(transcoder_tex_fmt), face_index, layer_index);\n\t\t\t\t\t\t\tif (!write_3dfx_out_file(out_filename.c_str(), gi[level_index]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_printf(\"Failed writing to OUT file \\\"%s\\\"\\n\", out_filename.c_str());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"Wrote .OUT file \\\"%s\\\"\\n\", out_filename.c_str());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Save alpha\n\t\t\t\t\t\tif (basis_transcoder_format_has_alpha(transcoder_tex_fmt) && (!opts.m_ktx_only) && (write_png))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::string a_filename;\n\t\t\t\t\t\t\tif (gi.size() > 1)\n\t\t\t\t\t\t\t\ta_filename = base_filename + string_format(\"_unpacked_a_%s_level_%u_face_%u_layer_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, face_index, layer_index);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ta_filename = base_filename + string_format(\"_unpacked_a_%s_face_%u_layer_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), face_index, layer_index);\n\t\t\t\t\t\t\tif (!save_png(a_filename, u, cImageSaveGrayscale, 3))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", a_filename.c_str());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", a_filename.c_str());\n\n\t\t\t\t\t\t\tstd::string rgba_filename;\n\t\t\t\t\t\t\tif (gi.size() > 1)\n\t\t\t\t\t\t\t\trgba_filename = base_filename + string_format(\"_unpacked_rgba_%s_level_%u_face_%u_layer_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, face_index, layer_index);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\trgba_filename = base_filename + string_format(\"_unpacked_rgba_%s_face_%u_layer_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), face_index, layer_index);\n\t\t\t\t\t\t\tif (!save_png(rgba_filename, u))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", rgba_filename.c_str());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", rgba_filename.c_str());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} // is_hdr\n\n\t\t\t\t} // level_index\n\n\t\t\t} // face_index\n\n\t\t} // layer_index\n\n\t} // format_iter\n\n\t// TODO: transcode to unpacked texture formats, like we do for .basis. As this is mostly a transcode test, supporting this with .basis seems fine.\n\n\treturn true;\n}\n\nstatic bool unpack_and_validate_basis_file(\n\tuint32_t file_index,\n\tconst std::string &base_filename,\n\tuint8_vec &basis_file_data,\n\tcommand_line_params& opts, \n\tFILE *pCSV_file,\n\tbasis_data* pGlobal_codebook_data,\n\tuint32_t &total_unpack_warnings,\n\tuint32_t &total_pvrtc_nonpow2_warnings)\n{\n\tconst bool validate_flag = (opts.m_mode == cValidate);\n\n\tbasist::basisu_transcoder dec;\n\n\tif (pGlobal_codebook_data)\n\t{\n\t\tdec.set_global_codebooks(&pGlobal_codebook_data->m_transcoder.get_lowlevel_etc1s_decoder());\n\t}\n\n\tif (!opts.m_fuzz_testing)\n\t{\n\t\t// Skip the full validation, which CRC16's the entire file.\n\n\t\t// Validate the file - note this isn't necessary for transcoding\n\t\tif (!dec.validate_file_checksums(&basis_file_data[0], (uint32_t)basis_file_data.size(), true))\n\t\t{\n\t\t\terror_printf(\"File version is unsupported, or file failed one or more CRC checks!\\n\");\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprintf(\"File version and CRC checks succeeded\\n\");\n\n\tbasist::basisu_file_info fileinfo;\n\tif (!dec.get_file_info(&basis_file_data[0], (uint32_t)basis_file_data.size(), fileinfo))\n\t{\n\t\terror_printf(\"Failed retrieving Basis file information!\\n\");\n\t\treturn false;\n\t}\n\n\tassert(fileinfo.m_total_images == fileinfo.m_image_mipmap_levels.size());\n\tassert(fileinfo.m_total_images == dec.get_total_images(&basis_file_data[0], (uint32_t)basis_file_data.size()));\n\n\tprintf(\"File info:\\n\");\n\tprintf(\"  Version: %X\\n\", fileinfo.m_version);\n\tprintf(\"  Total header size: %u\\n\", fileinfo.m_total_header_size);\n\tprintf(\"  Total selectors: %u\\n\", fileinfo.m_total_selectors);\n\tprintf(\"  Selector codebook size: %u\\n\", fileinfo.m_selector_codebook_size);\n\tprintf(\"  Total endpoints: %u\\n\", fileinfo.m_total_endpoints);\n\tprintf(\"  Endpoint codebook size: %u\\n\", fileinfo.m_endpoint_codebook_size);\n\tprintf(\"  Tables size: %u\\n\", fileinfo.m_tables_size);\n\tprintf(\"  Slices size: %u\\n\", fileinfo.m_slices_size);\n\n\tconst bool is_hdr = (fileinfo.m_tex_format == basist::basis_tex_format::cUASTC_HDR_4x4);\n\t\n\tprintf(\"  Texture format: %s\\n\", is_hdr ? \"UASTC_HDR\" : ((fileinfo.m_tex_format == basist::basis_tex_format::cUASTC4x4) ? \"UASTC\" : \"ETC1S\"));\n\n\tprintf(\"  Texture type: %s\\n\", basist::basis_get_texture_type_name(fileinfo.m_tex_type));\n\tprintf(\"  us per frame: %u (%f fps)\\n\", fileinfo.m_us_per_frame, fileinfo.m_us_per_frame ? (1.0f / ((float)fileinfo.m_us_per_frame / 1000000.0f)) : 0.0f);\n\tprintf(\"  Total slices: %u\\n\", (uint32_t)fileinfo.m_slice_info.size());\n\tprintf(\"  Total images: %i\\n\", fileinfo.m_total_images);\n\tprintf(\"  Y Flipped: %u, Has alpha slices: %u\\n\", fileinfo.m_y_flipped, fileinfo.m_has_alpha_slices);\n\tprintf(\"  userdata0: 0x%X userdata1: 0x%X\\n\", fileinfo.m_userdata0, fileinfo.m_userdata1);\n\tprintf(\"  Per-image mipmap levels: \");\n\tfor (uint32_t i = 0; i < fileinfo.m_total_images; i++)\n\t\tprintf(\"%u \", fileinfo.m_image_mipmap_levels[i]);\n\tprintf(\"\\n\");\n\n\tuint32_t total_texels = 0;\n\n\tprintf(\"\\nImage info:\\n\");\n\tfor (uint32_t i = 0; i < fileinfo.m_total_images; i++)\n\t{\n\t\tbasist::basisu_image_info ii;\n\t\tif (!dec.get_image_info(&basis_file_data[0], (uint32_t)basis_file_data.size(), ii, i))\n\t\t{\n\t\t\terror_printf(\"get_image_info() failed!\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tprintf(\"Image %u: MipLevels: %u OrigDim: %ux%u, BlockDim: %ux%u, FirstSlice: %u, HasAlpha: %u\\n\", i, ii.m_total_levels, ii.m_orig_width, ii.m_orig_height,\n\t\t\tii.m_num_blocks_x, ii.m_num_blocks_y, ii.m_first_slice_index, (uint32_t)ii.m_alpha_flag);\n\n\t\ttotal_texels += ii.m_width * ii.m_height;\n\t}\n\n\tprintf(\"\\nSlice info:\\n\");\n\n\tfor (uint32_t i = 0; i < fileinfo.m_slice_info.size(); i++)\n\t{\n\t\tconst basist::basisu_slice_info& sliceinfo = fileinfo.m_slice_info[i];\n\t\tprintf(\"%u: OrigWidthHeight: %ux%u, BlockDim: %ux%u, TotalBlocks: %u, Compressed size: %u, Image: %u, Level: %u, UnpackedCRC16: 0x%X, alpha: %u, iframe: %i\\n\",\n\t\t\ti,\n\t\t\tsliceinfo.m_orig_width, sliceinfo.m_orig_height,\n\t\t\tsliceinfo.m_num_blocks_x, sliceinfo.m_num_blocks_y,\n\t\t\tsliceinfo.m_total_blocks,\n\t\t\tsliceinfo.m_compressed_size,\n\t\t\tsliceinfo.m_image_index, sliceinfo.m_level_index,\n\t\t\tsliceinfo.m_unpacked_slice_crc16,\n\t\t\t(uint32_t)sliceinfo.m_alpha_flag,\n\t\t\t(uint32_t)sliceinfo.m_iframe_flag);\n\t}\n\tprintf(\"\\n\");\n\n\tsize_t comp_size = 0;\n\tvoid* pComp_data = tdefl_compress_mem_to_heap(&basis_file_data[0], basis_file_data.size(), &comp_size, TDEFL_MAX_PROBES_MASK);// TDEFL_DEFAULT_MAX_PROBES);\n\tmz_free(pComp_data);\n\n\tconst float basis_bits_per_texel = basis_file_data.size() * 8.0f / total_texels;\n\tconst float comp_bits_per_texel = comp_size * 8.0f / total_texels;\n\n\tprintf(\"Original size: %u, bits per texel: %3.3f\\nCompressed size (Deflate): %u, bits per texel: %3.3f\\n\", (uint32_t)basis_file_data.size(), basis_bits_per_texel, (uint32_t)comp_size, comp_bits_per_texel);\n\n\tif (opts.m_mode == cInfo)\n\t{\n\t\treturn true;\n\t}\n\n\tif ((fileinfo.m_etc1s) && (fileinfo.m_selector_codebook_size == 0) && (fileinfo.m_endpoint_codebook_size == 0))\n\t{\n\t\t// File is ETC1S and uses global codebooks - make sure we loaded one\n\t\tif (!pGlobal_codebook_data)\n\t\t{\n\t\t\terror_printf(\"ETC1S file uses global codebooks, but none were loaded (see the -use_global_codebooks option)\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((pGlobal_codebook_data->m_transcoder.get_lowlevel_etc1s_decoder().get_endpoints().size() != fileinfo.m_total_endpoints) ||\n\t\t\t(pGlobal_codebook_data->m_transcoder.get_lowlevel_etc1s_decoder().get_selectors().size() != fileinfo.m_total_selectors))\n\t\t{\n\t\t\terror_printf(\"Supplied global codebook is not compatible with this file\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tinterval_timer tm;\n\ttm.start();\n\n\tif (!dec.start_transcoding(&basis_file_data[0], (uint32_t)basis_file_data.size()))\n\t{\n\t\terror_printf(\"start_transcoding() failed!\\n\");\n\t\treturn false;\n\t}\n\n\tconst double start_transcoding_time_ms = tm.get_elapsed_ms();\n\n\tprintf(\"start_transcoding time: %3.3f ms\\n\", start_transcoding_time_ms);\n\n\tbasisu::vector< gpu_image_vec > gpu_images[(int)basist::transcoder_texture_format::cTFTotalTextureFormats];\n\t\n\tdouble total_format_transcoding_time_ms[(int)basist::transcoder_texture_format::cTFTotalTextureFormats];\n\tclear_obj(total_format_transcoding_time_ms);\n\n\tint first_format = 0;\n\tint last_format = (int)basist::transcoder_texture_format::cTFTotalTextureFormats;\n\n\tif (opts.m_format_only > -1)\n\t{\n\t\tfirst_format = opts.m_format_only;\n\t\tlast_format = first_format + 1;\n\t}\n\n\tif ((pCSV_file) && (file_index == 0))\n\t{\n\t\tstd::string desc;\n\t\tdesc = \"filename,basis_bitrate,comp_bitrate,images,levels,slices,start_transcoding_time,\";\n\t\tfor (int format_iter = first_format; format_iter < last_format; format_iter++)\n\t\t{\n\t\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = static_cast<basist::transcoder_texture_format>(format_iter);\n\n\t\t\tif (!basis_is_format_supported(transcoder_tex_fmt, fileinfo.m_tex_format))\n\t\t\t\tcontinue;\n\t\t\tif (transcoder_tex_fmt == basist::transcoder_texture_format::cTFBC7_ALT)\n\t\t\t\tcontinue;\n\n\t\t\tdesc += std::string(basis_get_format_name(transcoder_tex_fmt));\n\t\t\tif (format_iter != last_format - 1)\n\t\t\t\tdesc += \",\";\n\t\t}\n\t\tfprintf(pCSV_file, \"%s\\n\", desc.c_str());\n\t}\n\n\tfor (int format_iter = first_format; format_iter < last_format; format_iter++)\n\t{\n\t\tbasist::transcoder_texture_format tex_fmt = static_cast<basist::transcoder_texture_format>(format_iter);\n\n\t\tif (basist::basis_transcoder_format_is_uncompressed(tex_fmt))\n\t\t\tcontinue;\n\n\t\tif (!basis_is_format_supported(tex_fmt, fileinfo.m_tex_format))\n\t\t\tcontinue;\n\n\t\tif (tex_fmt == basist::transcoder_texture_format::cTFBC7_ALT)\n\t\t\tcontinue;\n\n\t\tgpu_images[(int)tex_fmt].resize(fileinfo.m_total_images);\n\n\t\tfor (uint32_t image_index = 0; image_index < fileinfo.m_total_images; image_index++)\n\t\t\tgpu_images[(int)tex_fmt][image_index].resize(fileinfo.m_image_mipmap_levels[image_index]);\n\t}\n\n\t// Now transcode the file to all supported texture formats and save mipmapped KTX files\n\tfor (int format_iter = first_format; format_iter < last_format; format_iter++)\n\t{\n\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = static_cast<basist::transcoder_texture_format>(format_iter);\n\n\t\tif (basist::basis_transcoder_format_is_uncompressed(transcoder_tex_fmt))\n\t\t\tcontinue;\n\t\tif (!basis_is_format_supported(transcoder_tex_fmt, fileinfo.m_tex_format))\n\t\t\tcontinue;\n\t\tif (transcoder_tex_fmt == basist::transcoder_texture_format::cTFBC7_ALT)\n\t\t\tcontinue;\n\n\t\tfor (uint32_t image_index = 0; image_index < fileinfo.m_total_images; image_index++)\n\t\t{\n\t\t\tfor (uint32_t level_index = 0; level_index < fileinfo.m_image_mipmap_levels[image_index]; level_index++)\n\t\t\t{\n\t\t\t\tbasist::basisu_image_level_info level_info;\n\n\t\t\t\tif (!dec.get_image_level_info(&basis_file_data[0], (uint32_t)basis_file_data.size(), level_info, image_index, level_index))\n\t\t\t\t{\n\t\t\t\t\terror_printf(\"Failed retrieving image level information (%u %u)!\\n\", image_index, level_index);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif ((transcoder_tex_fmt == basist::transcoder_texture_format::cTFPVRTC1_4_RGB) || (transcoder_tex_fmt == basist::transcoder_texture_format::cTFPVRTC1_4_RGBA))\n\t\t\t\t{\n\t\t\t\t\tif (!is_pow2(level_info.m_width) || !is_pow2(level_info.m_height))\n\t\t\t\t\t{\n\t\t\t\t\t\ttotal_pvrtc_nonpow2_warnings++;\n\n\t\t\t\t\t\tprintf(\"Warning: Will not transcode image %u level %u res %ux%u to PVRTC1 (one or more dimension is not a power of 2)\\n\", image_index, level_index, level_info.m_width, level_info.m_height);\n\n\t\t\t\t\t\t// Can't transcode this image level to PVRTC because it's not a pow2 (we're going to support transcoding non-pow2 to the next larger pow2 soon)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbasisu::texture_format tex_fmt = basis_get_basisu_texture_format(transcoder_tex_fmt);\n\n\t\t\t\tgpu_image& gi = gpu_images[(int)transcoder_tex_fmt][image_index][level_index];\n\t\t\t\tgi.init(tex_fmt, level_info.m_orig_width, level_info.m_orig_height);\n\n\t\t\t\t// Fill the buffer with psuedo-random bytes, to help more visibly detect cases where the transcoder fails to write to part of the output.\n\t\t\t\tfill_buffer_with_random_bytes(gi.get_ptr(), gi.get_size_in_bytes());\n\n\t\t\t\tuint32_t decode_flags = 0;\n\n\t\t\t\ttm.start();\n\n\t\t\t\tif (!dec.transcode_image_level(&basis_file_data[0], (uint32_t)basis_file_data.size(), image_index, level_index, gi.get_ptr(), gi.get_total_blocks(), transcoder_tex_fmt, decode_flags))\n\t\t\t\t{\n\t\t\t\t\terror_printf(\"Failed transcoding image level (%u %u %u)!\\n\", image_index, level_index, format_iter);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tdouble total_transcode_time = tm.get_elapsed_ms();\n\n\t\t\t\ttotal_format_transcoding_time_ms[format_iter] += total_transcode_time;\n\n\t\t\t\tprintf(\"Transcode of image %u level %u res %ux%u format %s succeeded in %3.3f ms\\n\", image_index, level_index, level_info.m_orig_width, level_info.m_orig_height, basist::basis_get_format_name(transcoder_tex_fmt), total_transcode_time);\n\n\t\t\t} // format_iter\n\n\t\t} // level_index\n\n\t} // image_info\n\n\t// Upack UASTC files seperately, to validate we can transcode slices to UASTC and unpack them to pixels.\n\t// This is a special path because UASTC is not yet a valid transcoder_texture_format, but a lower-level block_format.\n\tif (fileinfo.m_tex_format == basist::basis_tex_format::cUASTC4x4)\n\t{\n\t\tfor (uint32_t image_index = 0; image_index < fileinfo.m_total_images; image_index++)\n\t\t{\n\t\t\tfor (uint32_t level_index = 0; level_index < fileinfo.m_image_mipmap_levels[image_index]; level_index++)\n\t\t\t{\n\t\t\t\tbasist::basisu_image_level_info level_info;\n\n\t\t\t\tif (!dec.get_image_level_info(&basis_file_data[0], (uint32_t)basis_file_data.size(), level_info, image_index, level_index))\n\t\t\t\t{\n\t\t\t\t\terror_printf(\"Failed retrieving image level information (%u %u)!\\n\", image_index, level_index);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tgpu_image gi;\n\t\t\t\tgi.init(basisu::texture_format::cUASTC4x4, level_info.m_orig_width, level_info.m_orig_height);\n\n\t\t\t\t// Fill the buffer with psuedo-random bytes, to help more visibly detect cases where the transcoder fails to write to part of the output.\n\t\t\t\tfill_buffer_with_random_bytes(gi.get_ptr(), gi.get_size_in_bytes());\n\n\t\t\t\t//uint32_t decode_flags = 0;\n\n\t\t\t\ttm.start();\n\n\t\t\t\tif (!dec.transcode_slice(\n\t\t\t\t\t&basis_file_data[0], (uint32_t)basis_file_data.size(), \n\t\t\t\t\tlevel_info.m_first_slice_index, gi.get_ptr(), gi.get_total_blocks(), basist::block_format::cUASTC_4x4, gi.get_bytes_per_block()))\n\t\t\t\t{\n\t\t\t\t\terror_printf(\"Failed transcoding image level (%u %u) to UASTC!\\n\", image_index, level_index);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tdouble total_transcode_time = tm.get_elapsed_ms();\n\n\t\t\t\tprintf(\"Transcode of image %u level %u res %ux%u format UASTC_4x4 succeeded in %3.3f ms\\n\", image_index, level_index, level_info.m_orig_width, level_info.m_orig_height, total_transcode_time);\n\n\t\t\t\tif ((!validate_flag) && (!opts.m_ktx_only))\n\t\t\t\t{\n\t\t\t\t\timage u;\n\t\t\t\t\tif (!gi.unpack(u))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Warning: Failed unpacking GPU texture data (%u %u) to UASTC. \\n\", image_index, level_index);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t//u.crop(level_info.m_orig_width, level_info.m_orig_height);\n\n\t\t\t\t\tstd::string rgb_filename;\n\t\t\t\t\tif (fileinfo.m_image_mipmap_levels[image_index] > 1)\n\t\t\t\t\t\trgb_filename = base_filename + string_format(\"_unpacked_rgb_UASTC_4x4_%u_%04u.png\", level_index, image_index);\n\t\t\t\t\telse\n\t\t\t\t\t\trgb_filename = base_filename + string_format(\"_unpacked_rgb_UASTC_4x4_%04u.png\", image_index);\n\n\t\t\t\t\tif (!save_png(rgb_filename, u, cImageSaveIgnoreAlpha))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\n\t\t\t\t\tstd::string alpha_filename;\n\t\t\t\t\tif (fileinfo.m_image_mipmap_levels[image_index] > 1)\n\t\t\t\t\t\talpha_filename = base_filename + string_format(\"_unpacked_a_UASTC_4x4_%u_%04u.png\", level_index, image_index);\n\t\t\t\t\telse\n\t\t\t\t\t\talpha_filename = base_filename + string_format(\"_unpacked_a_UASTC_4x4_%04u.png\", image_index);\n\t\t\t\t\tif (!save_png(alpha_filename, u, cImageSaveGrayscale, 3))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", alpha_filename.c_str());\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!validate_flag)\n\t{\n\t\t// Now write KTX files and unpack them to individual PNG's/EXR's\n\n\t\tfor (int format_iter = first_format; format_iter < last_format; format_iter++)\n\t\t{\n\t\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = static_cast<basist::transcoder_texture_format>(format_iter);\n\n\t\t\tif (basist::basis_transcoder_format_is_uncompressed(transcoder_tex_fmt))\n\t\t\t\tcontinue;\n\t\t\tif (!basis_is_format_supported(transcoder_tex_fmt, fileinfo.m_tex_format))\n\t\t\t\tcontinue;\n\t\t\tif (transcoder_tex_fmt == basist::transcoder_texture_format::cTFBC7_ALT)\n\t\t\t\tcontinue;\n\n\t\t\tif ((!opts.m_no_ktx) && (fileinfo.m_tex_type == basist::cBASISTexTypeCubemapArray))\n\t\t\t{\n\t\t\t\t// No KTX tool that we know of supports cubemap arrays, so write individual cubemap files.\n\t\t\t\tfor (uint32_t image_index = 0; image_index < fileinfo.m_total_images; image_index += 6)\n\t\t\t\t{\n\t\t\t\t\tbasisu::vector<gpu_image_vec> cubemap;\n\t\t\t\t\tfor (uint32_t i = 0; i < 6; i++)\n\t\t\t\t\t\tcubemap.push_back(gpu_images[format_iter][image_index + i]);\n\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string ktx_filename(base_filename + string_format(\"_transcoded_cubemap_%s_%u.ktx\", basist::basis_get_format_name(transcoder_tex_fmt), image_index / 6));\n\t\t\t\t\t\tif (!write_compressed_texture_file(ktx_filename.c_str(), cubemap, true, true))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing KTX file \\\"%s\\\"!\\n\", ktx_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote KTX file \\\"%s\\\"\\n\", ktx_filename.c_str());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (does_dds_support_format(cubemap[0][0].get_format()))\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string dds_filename(base_filename + string_format(\"_transcoded_cubemap_%s_%u.dds\", basist::basis_get_format_name(transcoder_tex_fmt), image_index / 6));\n\t\t\t\t\t\tif (!write_compressed_texture_file(dds_filename.c_str(), cubemap, true, true))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing DDS file \\\"%s\\\"!\\n\", dds_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote DDS file \\\"%s\\\"\\n\", dds_filename.c_str());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (uint32_t image_index = 0; image_index < fileinfo.m_total_images; image_index++)\n\t\t\t{\n\t\t\t\tgpu_image_vec& gi = gpu_images[format_iter][image_index];\n\n\t\t\t\tif (!gi.size())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tuint32_t level;\n\t\t\t\tfor (level = 0; level < gi.size(); level++)\n\t\t\t\t\tif (!gi[level].get_total_blocks())\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tif (level < gi.size())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ((!opts.m_no_ktx) && (fileinfo.m_tex_type != basist::cBASISTexTypeCubemapArray))\n\t\t\t\t{\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string ktx_filename(base_filename + string_format(\"_transcoded_%s_%04u.ktx\", basist::basis_get_format_name(transcoder_tex_fmt), image_index));\n\t\t\t\t\t\tif (!write_compressed_texture_file(ktx_filename.c_str(), gi, true))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing KTX file \\\"%s\\\"!\\n\", ktx_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote KTX file \\\"%s\\\"\\n\", ktx_filename.c_str());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (does_dds_support_format(gi[0].get_format()))\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string dds_filename(base_filename + string_format(\"_transcoded_%s_%04u.dds\", basist::basis_get_format_name(transcoder_tex_fmt), image_index));\n\t\t\t\t\t\tif (!write_compressed_texture_file(dds_filename.c_str(), gi, true))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing DDS file \\\"%s\\\"!\\n\", dds_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote DDS file \\\"%s\\\"\\n\", dds_filename.c_str());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (uint32_t level_index = 0; level_index < gi.size(); level_index++)\n\t\t\t\t{\n\t\t\t\t\tbasist::basisu_image_level_info level_info;\n\n\t\t\t\t\tif (!dec.get_image_level_info(&basis_file_data[0], (uint32_t)basis_file_data.size(), level_info, image_index, level_index))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed retrieving image level information (%u %u)!\\n\", image_index, level_index);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (basist::basis_transcoder_format_is_hdr(transcoder_tex_fmt))\n\t\t\t\t\t{\n\t\t\t\t\t\timagef u;\n\n\t\t\t\t\t\tif (!gi[level_index].unpack_hdr(u))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"Warning: Failed unpacking GPU texture data (%u %u %u). Unpacking as much as possible.\\n\", format_iter, image_index, level_index);\n\t\t\t\t\t\t\ttotal_unpack_warnings++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!opts.m_ktx_only)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::string rgb_filename;\n\t\t\t\t\t\t\tif (gi.size() > 1)\n\t\t\t\t\t\t\t\trgb_filename = base_filename + string_format(\"_hdr_unpacked_rgb_%s_%u_%04u.exr\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\trgb_filename = base_filename + string_format(\"_hdr_unpacked_rgb_%s_%04u.exr\", basist::basis_get_format_name(transcoder_tex_fmt), image_index);\n\n\t\t\t\t\t\t\tif (!write_exr(rgb_filename.c_str(), u, 3, 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_printf(\"Failed writing to EXR file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"Wrote EXR file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\timage u;\n\t\t\t\t\t\tif (!gi[level_index].unpack(u))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"Warning: Failed unpacking GPU texture data (%u %u %u). Unpacking as much as possible.\\n\", format_iter, image_index, level_index);\n\t\t\t\t\t\t\ttotal_unpack_warnings++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//u.crop(level_info.m_orig_width, level_info.m_orig_height);\n\n\t\t\t\t\t\tbool write_png = true;\n\n\t\t\t\t\t\tif ((!opts.m_ktx_only) && (write_png))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::string rgb_filename;\n\t\t\t\t\t\t\tif (gi.size() > 1)\n\t\t\t\t\t\t\t\trgb_filename = base_filename + string_format(\"_unpacked_rgb_%s_%u_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\trgb_filename = base_filename + string_format(\"_unpacked_rgb_%s_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), image_index);\n\t\t\t\t\t\t\tif (!save_png(rgb_filename, u, cImageSaveIgnoreAlpha))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((transcoder_tex_fmt == basist::transcoder_texture_format::cTFFXT1_RGB) && (opts.m_write_out))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::string out_filename;\n\t\t\t\t\t\t\tif (gi.size() > 1)\n\t\t\t\t\t\t\t\tout_filename = base_filename + string_format(\"_unpacked_rgb_%s_%u_%04u.out\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tout_filename = base_filename + string_format(\"_unpacked_rgb_%s_%04u.out\", basist::basis_get_format_name(transcoder_tex_fmt), image_index);\n\t\t\t\t\t\t\tif (!write_3dfx_out_file(out_filename.c_str(), gi[level_index]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_printf(\"Failed writing to OUT file \\\"%s\\\"\\n\", out_filename.c_str());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"Wrote .OUT file \\\"%s\\\"\\n\", out_filename.c_str());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (basis_transcoder_format_has_alpha(transcoder_tex_fmt) && (!opts.m_ktx_only) && (write_png))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::string a_filename;\n\t\t\t\t\t\t\tif (gi.size() > 1)\n\t\t\t\t\t\t\t\ta_filename = base_filename + string_format(\"_unpacked_a_%s_%u_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ta_filename = base_filename + string_format(\"_unpacked_a_%s_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), image_index);\n\t\t\t\t\t\t\tif (!save_png(a_filename, u, cImageSaveGrayscale, 3))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", a_filename.c_str());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", a_filename.c_str());\n\n\t\t\t\t\t\t\tstd::string rgba_filename;\n\t\t\t\t\t\t\tif (gi.size() > 1)\n\t\t\t\t\t\t\t\trgba_filename = base_filename + string_format(\"_unpacked_rgba_%s_%u_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\trgba_filename = base_filename + string_format(\"_unpacked_rgba_%s_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), image_index);\n\t\t\t\t\t\t\tif (!save_png(rgba_filename, u))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", rgba_filename.c_str());\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", rgba_filename.c_str());\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t} // is_hdr\n\n\t\t\t\t} // level_index\n\n\t\t\t} // image_index\n\n\t\t} // format_iter\n\n\t} // if (!validate_flag)\n\n\tuint32_t max_mipmap_levels = 0;\n\n\t//if (!opts.m_etc1_only)\n\tif ((opts.m_format_only == -1) && (!validate_flag))\n\t{\n\t\tif (is_hdr)\n\t\t{\n\t\t\t// Now unpack to RGBA_HALF using the transcoder itself to do the unpacking to raster images\n\t\t\tfor (uint32_t image_index = 0; image_index < fileinfo.m_total_images; image_index++)\n\t\t\t{\n\t\t\t\tfor (uint32_t level_index = 0; level_index < fileinfo.m_image_mipmap_levels[image_index]; level_index++)\n\t\t\t\t{\n\t\t\t\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = basist::transcoder_texture_format::cTFRGBA_HALF;\n\n\t\t\t\t\tbasist::basisu_image_level_info level_info;\n\n\t\t\t\t\tif (!dec.get_image_level_info(&basis_file_data[0], (uint32_t)basis_file_data.size(), level_info, image_index, level_index))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed retrieving image level information (%u %u)!\\n\", image_index, level_index);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst uint32_t total_pixels = level_info.m_orig_width * level_info.m_orig_height;\n\t\t\t\t\tbasisu::vector<basist::half_float> half_img(total_pixels * 4);\n\n\t\t\t\t\tfill_buffer_with_random_bytes(&half_img[0], half_img.size_in_bytes());\n\n\t\t\t\t\ttm.start();\n\n\t\t\t\t\tif (!dec.transcode_image_level(&basis_file_data[0], (uint32_t)basis_file_data.size(), image_index, level_index, \n\t\t\t\t\t\thalf_img.get_ptr(), total_pixels, transcoder_tex_fmt, 0, level_info.m_orig_width, nullptr, level_info.m_orig_height))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed transcoding image level (%u %u %u)!\\n\", image_index, level_index, transcoder_tex_fmt);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble total_transcode_time = tm.get_elapsed_ms();\n\n\t\t\t\t\ttotal_format_transcoding_time_ms[(int)transcoder_tex_fmt] += total_transcode_time;\n\n\t\t\t\t\tprintf(\"Transcode of image %u level %u res %ux%u format %s succeeded in %3.3f ms\\n\", image_index, level_index, level_info.m_orig_width, level_info.m_orig_height, basist::basis_get_format_name(transcoder_tex_fmt), total_transcode_time);\n\n\t\t\t\t\tif ((!validate_flag) && (!opts.m_ktx_only))\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO: HDR alpha support\n\t\t\t\t\t\timagef float_img(level_info.m_orig_width, level_info.m_orig_height);\n\n\t\t\t\t\t\tfor (uint32_t y = 0; y < level_info.m_orig_height; y++)\n\t\t\t\t\t\t\tfor (uint32_t x = 0; x < level_info.m_orig_width; x++)\n\t\t\t\t\t\t\t\tfor (uint32_t c = 0; c < 4; c++)\n\t\t\t\t\t\t\t\t\tfloat_img(x, y)[c] = basist::half_to_float(half_img[(x + y * level_info.m_orig_width) * 4 + c]);\n\n\t\t\t\t\t\tstd::string rgb_filename(base_filename + string_format(\"_hdr_unpacked_rgba_%s_%u_%04u.exr\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index));\n\t\t\t\t\t\tif (!write_exr(rgb_filename.c_str(), float_img, 3, 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing to EXR file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote EXR file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t}\n\n\t\t\t\t} // level_index\n\t\t\t} // image_index\n\n\t\t\t// Now unpack to RGB_HALF using the transcoder itself to do the unpacking to raster images\n\t\t\tfor (uint32_t image_index = 0; image_index < fileinfo.m_total_images; image_index++)\n\t\t\t{\n\t\t\t\tfor (uint32_t level_index = 0; level_index < fileinfo.m_image_mipmap_levels[image_index]; level_index++)\n\t\t\t\t{\n\t\t\t\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = basist::transcoder_texture_format::cTFRGB_HALF;\n\n\t\t\t\t\tbasist::basisu_image_level_info level_info;\n\n\t\t\t\t\tif (!dec.get_image_level_info(&basis_file_data[0], (uint32_t)basis_file_data.size(), level_info, image_index, level_index))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed retrieving image level information (%u %u)!\\n\", image_index, level_index);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst uint32_t total_pixels = level_info.m_orig_width * level_info.m_orig_height;\n\t\t\t\t\tbasisu::vector<basist::half_float> half_img(total_pixels * 3);\n\n\t\t\t\t\tfill_buffer_with_random_bytes(&half_img[0], half_img.size_in_bytes());\n\n\t\t\t\t\ttm.start();\n\n\t\t\t\t\tif (!dec.transcode_image_level(&basis_file_data[0], (uint32_t)basis_file_data.size(), image_index, level_index,\n\t\t\t\t\t\thalf_img.get_ptr(), total_pixels, transcoder_tex_fmt, 0, level_info.m_orig_width, nullptr, level_info.m_orig_height))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed transcoding image level (%u %u %u)!\\n\", image_index, level_index, transcoder_tex_fmt);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble total_transcode_time = tm.get_elapsed_ms();\n\n\t\t\t\t\ttotal_format_transcoding_time_ms[(int)transcoder_tex_fmt] += total_transcode_time;\n\n\t\t\t\t\tprintf(\"Transcode of image %u level %u res %ux%u format %s succeeded in %3.3f ms\\n\", image_index, level_index, level_info.m_orig_width, level_info.m_orig_height, basist::basis_get_format_name(transcoder_tex_fmt), total_transcode_time);\n\n\t\t\t\t\tif ((!validate_flag) && (!opts.m_ktx_only))\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO: HDR alpha support\n\t\t\t\t\t\timagef float_img(level_info.m_orig_width, level_info.m_orig_height);\n\n\t\t\t\t\t\tfor (uint32_t y = 0; y < level_info.m_orig_height; y++)\n\t\t\t\t\t\t\tfor (uint32_t x = 0; x < level_info.m_orig_width; x++)\n\t\t\t\t\t\t\t\tfor (uint32_t c = 0; c < 3; c++)\n\t\t\t\t\t\t\t\t\tfloat_img(x, y)[c] = basist::half_to_float(half_img[(x + y * level_info.m_orig_width) * 3 + c]);\n\n\t\t\t\t\t\tstd::string rgb_filename(base_filename + string_format(\"_hdr_unpacked_rgb_%s_%u_%04u.exr\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index));\n\t\t\t\t\t\tif (!write_exr(rgb_filename.c_str(), float_img, 3, 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing to EXR file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote EXR file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t}\n\n\t\t\t\t} // level_index\n\t\t\t} // image_index\n\n\t\t\t// Now unpack to RGB_9E5 using the transcoder itself to do the unpacking to raster images\n\t\t\tfor (uint32_t image_index = 0; image_index < fileinfo.m_total_images; image_index++)\n\t\t\t{\n\t\t\t\tfor (uint32_t level_index = 0; level_index < fileinfo.m_image_mipmap_levels[image_index]; level_index++)\n\t\t\t\t{\n\t\t\t\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = basist::transcoder_texture_format::cTFRGB_9E5;\n\n\t\t\t\t\tbasist::basisu_image_level_info level_info;\n\n\t\t\t\t\tif (!dec.get_image_level_info(&basis_file_data[0], (uint32_t)basis_file_data.size(), level_info, image_index, level_index))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed retrieving image level information (%u %u)!\\n\", image_index, level_index);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst uint32_t total_pixels = level_info.m_orig_width * level_info.m_orig_height;\n\t\t\t\t\tbasisu::vector<uint32_t> rgb9e5_img(total_pixels);\n\n\t\t\t\t\tfill_buffer_with_random_bytes(&rgb9e5_img[0], rgb9e5_img.size_in_bytes());\n\n\t\t\t\t\ttm.start();\n\n\t\t\t\t\tif (!dec.transcode_image_level(&basis_file_data[0], (uint32_t)basis_file_data.size(), image_index, level_index,\n\t\t\t\t\t\trgb9e5_img.get_ptr(), total_pixels, transcoder_tex_fmt, 0, level_info.m_orig_width, nullptr, level_info.m_orig_height))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed transcoding image level (%u %u %u)!\\n\", image_index, level_index, transcoder_tex_fmt);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble total_transcode_time = tm.get_elapsed_ms();\n\n\t\t\t\t\ttotal_format_transcoding_time_ms[(int)transcoder_tex_fmt] += total_transcode_time;\n\n\t\t\t\t\tprintf(\"Transcode of image %u level %u res %ux%u format %s succeeded in %3.3f ms\\n\", image_index, level_index, level_info.m_orig_width, level_info.m_orig_height, basist::basis_get_format_name(transcoder_tex_fmt), total_transcode_time);\n\n\t\t\t\t\tif ((!validate_flag) && (!opts.m_ktx_only))\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO: Write KTX or DDS\n\t\t\t\t\t\timagef float_img(level_info.m_orig_width, level_info.m_orig_height);\n\n\t\t\t\t\t\tfor (uint32_t y = 0; y < level_info.m_orig_height; y++)\n\t\t\t\t\t\t\tfor (uint32_t x = 0; x < level_info.m_orig_width; x++)\n\t\t\t\t\t\t\t\tastc_helpers::unpack_rgb9e5(rgb9e5_img[x + y * level_info.m_orig_width], float_img(x, y)[0], float_img(x, y)[1], float_img(x, y)[2]);\n\n\t\t\t\t\t\tstd::string rgb_filename(base_filename + string_format(\"_hdr_unpacked_rgb_%s_%u_%04u.exr\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index));\n\t\t\t\t\t\tif (!write_exr(rgb_filename.c_str(), float_img, 3, 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing to EXR file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote EXR file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t}\n\n\t\t\t\t} // level_index\n\t\t\t} // image_index\n\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Now unpack to RGBA using the transcoder itself to do the unpacking to raster images\n\t\t\tfor (uint32_t image_index = 0; image_index < fileinfo.m_total_images; image_index++)\n\t\t\t{\n\t\t\t\tfor (uint32_t level_index = 0; level_index < fileinfo.m_image_mipmap_levels[image_index]; level_index++)\n\t\t\t\t{\n\t\t\t\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = basist::transcoder_texture_format::cTFRGBA32;\n\n\t\t\t\t\tbasist::basisu_image_level_info level_info;\n\n\t\t\t\t\tif (!dec.get_image_level_info(&basis_file_data[0], (uint32_t)basis_file_data.size(), level_info, image_index, level_index))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed retrieving image level information (%u %u)!\\n\", image_index, level_index);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\timage img(level_info.m_orig_width, level_info.m_orig_height);\n\n\t\t\t\t\tfill_buffer_with_random_bytes(&img(0, 0), img.get_total_pixels() * sizeof(uint32_t));\n\n\t\t\t\t\ttm.start();\n\n\t\t\t\t\tif (!dec.transcode_image_level(&basis_file_data[0], (uint32_t)basis_file_data.size(), image_index, level_index, &img(0, 0).r, img.get_total_pixels(), transcoder_tex_fmt, 0, img.get_pitch(), nullptr, img.get_height()))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed transcoding image level (%u %u %u)!\\n\", image_index, level_index, transcoder_tex_fmt);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble total_transcode_time = tm.get_elapsed_ms();\n\n\t\t\t\t\ttotal_format_transcoding_time_ms[(int)transcoder_tex_fmt] += total_transcode_time;\n\n\t\t\t\t\tprintf(\"Transcode of image %u level %u res %ux%u format %s succeeded in %3.3f ms\\n\", image_index, level_index, level_info.m_orig_width, level_info.m_orig_height, basist::basis_get_format_name(transcoder_tex_fmt), total_transcode_time);\n\n\t\t\t\t\tif ((!validate_flag) && (!opts.m_ktx_only))\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string rgb_filename(base_filename + string_format(\"_unpacked_rgb_%s_%u_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index));\n\t\t\t\t\t\tif (!save_png(rgb_filename, img, cImageSaveIgnoreAlpha))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\n\t\t\t\t\t\tstd::string a_filename(base_filename + string_format(\"_unpacked_a_%s_%u_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index));\n\t\t\t\t\t\tif (!save_png(a_filename, img, cImageSaveGrayscale, 3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", a_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", a_filename.c_str());\n\t\t\t\t\t}\n\n\t\t\t\t} // level_index\n\t\t\t} // image_index\n\n\t\t\t// Now unpack to RGB565 using the transcoder itself to do the unpacking to raster images\n\t\t\tfor (uint32_t image_index = 0; image_index < fileinfo.m_total_images; image_index++)\n\t\t\t{\n\t\t\t\tfor (uint32_t level_index = 0; level_index < fileinfo.m_image_mipmap_levels[image_index]; level_index++)\n\t\t\t\t{\n\t\t\t\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = basist::transcoder_texture_format::cTFRGB565;\n\n\t\t\t\t\tbasist::basisu_image_level_info level_info;\n\n\t\t\t\t\tif (!dec.get_image_level_info(&basis_file_data[0], (uint32_t)basis_file_data.size(), level_info, image_index, level_index))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed retrieving image level information (%u %u)!\\n\", image_index, level_index);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tbasisu::vector<uint16_t> packed_img(level_info.m_orig_width * level_info.m_orig_height);\n\n\t\t\t\t\tfill_buffer_with_random_bytes(&packed_img[0], packed_img.size() * sizeof(uint16_t));\n\n\t\t\t\t\ttm.start();\n\n\t\t\t\t\tif (!dec.transcode_image_level(&basis_file_data[0], (uint32_t)basis_file_data.size(), image_index, level_index, &packed_img[0], (uint32_t)packed_img.size(), transcoder_tex_fmt, 0, level_info.m_orig_width, nullptr, level_info.m_orig_height))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed transcoding image level (%u %u %u)!\\n\", image_index, level_index, transcoder_tex_fmt);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble total_transcode_time = tm.get_elapsed_ms();\n\n\t\t\t\t\ttotal_format_transcoding_time_ms[(int)transcoder_tex_fmt] += total_transcode_time;\n\n\t\t\t\t\timage img(level_info.m_orig_width, level_info.m_orig_height);\n\t\t\t\t\tfor (uint32_t y = 0; y < level_info.m_orig_height; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (uint32_t x = 0; x < level_info.m_orig_width; x++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst uint16_t p = packed_img[x + y * level_info.m_orig_width];\n\t\t\t\t\t\t\tuint32_t r = p >> 11, g = (p >> 5) & 63, b = p & 31;\n\t\t\t\t\t\t\tr = (r << 3) | (r >> 2);\n\t\t\t\t\t\t\tg = (g << 2) | (g >> 4);\n\t\t\t\t\t\t\tb = (b << 3) | (b >> 2);\n\t\t\t\t\t\t\timg(x, y).set(r, g, b, 255);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"Transcode of image %u level %u res %ux%u format %s succeeded in %3.3f ms\\n\", image_index, level_index, level_info.m_orig_width, level_info.m_orig_height, basist::basis_get_format_name(transcoder_tex_fmt), total_transcode_time);\n\n\t\t\t\t\tif ((!validate_flag) && (!opts.m_ktx_only))\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string rgb_filename(base_filename + string_format(\"_unpacked_rgb_%s_%u_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index));\n\t\t\t\t\t\tif (!save_png(rgb_filename, img, cImageSaveIgnoreAlpha))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t}\n\n\t\t\t\t} // level_index\n\t\t\t} // image_index\n\n\t\t\t// Now unpack to RGBA4444 using the transcoder itself to do the unpacking to raster images\n\t\t\tfor (uint32_t image_index = 0; image_index < fileinfo.m_total_images; image_index++)\n\t\t\t{\n\t\t\t\tfor (uint32_t level_index = 0; level_index < fileinfo.m_image_mipmap_levels[image_index]; level_index++)\n\t\t\t\t{\n\t\t\t\t\tmax_mipmap_levels = basisu::maximum(max_mipmap_levels, fileinfo.m_image_mipmap_levels[image_index]);\n\n\t\t\t\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = basist::transcoder_texture_format::cTFRGBA4444;\n\n\t\t\t\t\tbasist::basisu_image_level_info level_info;\n\n\t\t\t\t\tif (!dec.get_image_level_info(&basis_file_data[0], (uint32_t)basis_file_data.size(), level_info, image_index, level_index))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed retrieving image level information (%u %u)!\\n\", image_index, level_index);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tbasisu::vector<uint16_t> packed_img(level_info.m_orig_width * level_info.m_orig_height);\n\n\t\t\t\t\tfill_buffer_with_random_bytes(&packed_img[0], packed_img.size() * sizeof(uint16_t));\n\n\t\t\t\t\ttm.start();\n\n\t\t\t\t\tif (!dec.transcode_image_level(&basis_file_data[0], (uint32_t)basis_file_data.size(), image_index, level_index, &packed_img[0], (uint32_t)packed_img.size(), transcoder_tex_fmt, 0, level_info.m_orig_width, nullptr, level_info.m_orig_height))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_printf(\"Failed transcoding image level (%u %u %u)!\\n\", image_index, level_index, transcoder_tex_fmt);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble total_transcode_time = tm.get_elapsed_ms();\n\n\t\t\t\t\ttotal_format_transcoding_time_ms[(int)transcoder_tex_fmt] += total_transcode_time;\n\n\t\t\t\t\timage img(level_info.m_orig_width, level_info.m_orig_height);\n\t\t\t\t\tfor (uint32_t y = 0; y < level_info.m_orig_height; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (uint32_t x = 0; x < level_info.m_orig_width; x++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst uint16_t p = packed_img[x + y * level_info.m_orig_width];\n\t\t\t\t\t\t\tuint32_t r = p >> 12, g = (p >> 8) & 15, b = (p >> 4) & 15, a = p & 15;\n\t\t\t\t\t\t\tr = (r << 4) | r;\n\t\t\t\t\t\t\tg = (g << 4) | g;\n\t\t\t\t\t\t\tb = (b << 4) | b;\n\t\t\t\t\t\t\ta = (a << 4) | a;\n\t\t\t\t\t\t\timg(x, y).set(r, g, b, a);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tprintf(\"Transcode of image %u level %u res %ux%u format %s succeeded in %3.3f ms\\n\", image_index, level_index, level_info.m_orig_width, level_info.m_orig_height, basist::basis_get_format_name(transcoder_tex_fmt), total_transcode_time);\n\n\t\t\t\t\tif ((!validate_flag) && (!opts.m_ktx_only))\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string rgb_filename(base_filename + string_format(\"_unpacked_rgb_%s_%u_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index));\n\t\t\t\t\t\tif (!save_png(rgb_filename, img, cImageSaveIgnoreAlpha))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", rgb_filename.c_str());\n\n\t\t\t\t\t\tstd::string a_filename(base_filename + string_format(\"_unpacked_a_%s_%u_%04u.png\", basist::basis_get_format_name(transcoder_tex_fmt), level_index, image_index));\n\t\t\t\t\t\tif (!save_png(a_filename, img, cImageSaveGrayscale, 3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror_printf(\"Failed writing to PNG file \\\"%s\\\"\\n\", a_filename.c_str());\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"Wrote PNG file \\\"%s\\\"\\n\", a_filename.c_str());\n\t\t\t\t\t}\n\n\t\t\t\t} // level_index\n\t\t\t} // image_index\n\t\t\n\t\t} // is_hdr\n\n\t} // if ((opts.m_format_only == -1) && (!validate_flag))\n\n\tif (pCSV_file)\n\t{\n\t\tfprintf(pCSV_file, \"%s, %3.3f, %3.3f, %u, %u, %u, %3.3f, \",\n\t\t\tbase_filename.c_str(),\n\t\t\tbasis_bits_per_texel,\n\t\t\tcomp_bits_per_texel,\n\t\t\tfileinfo.m_total_images,\n\t\t\tmax_mipmap_levels,\n\t\t\t(uint32_t)fileinfo.m_slice_info.size(),\n\t\t\tstart_transcoding_time_ms);\n\n\t\tfor (int format_iter = first_format; format_iter < last_format; format_iter++)\n\t\t{\n\t\t\tconst basist::transcoder_texture_format transcoder_tex_fmt = static_cast<basist::transcoder_texture_format>(format_iter);\n\n\t\t\tif (!basis_is_format_supported(transcoder_tex_fmt, fileinfo.m_tex_format))\n\t\t\t\tcontinue;\n\t\t\tif (transcoder_tex_fmt == basist::transcoder_texture_format::cTFBC7_ALT)\n\t\t\t\tcontinue;\n\n\t\t\tfprintf(pCSV_file, \"%3.3f\", total_format_transcoding_time_ms[format_iter]);\n\t\t\tif (format_iter != (last_format - 1))\n\t\t\t\tfprintf(pCSV_file, \",\");\n\t\t}\n\t\tfprintf(pCSV_file, \"\\n\");\n\t}\n\n\treturn true;\n}\n\nstatic bool unpack_and_validate_mode(command_line_params &opts)\n{\n\tinterval_timer tm;\n\ttm.start();\n\n\t//const bool validate_flag = (opts.m_mode == cValidate);\n\t\t\n\tbasis_data* pGlobal_codebook_data = nullptr;\n\tif (opts.m_etc1s_use_global_codebooks_file.size())\n\t{\n\t\tpGlobal_codebook_data = load_basis_file(opts.m_etc1s_use_global_codebooks_file.c_str(), true);\n\t\tif (!pGlobal_codebook_data)\n\t\t{\n\t\t\terror_printf(\"Failed loading global codebook data from file \\\"%s\\\"\\n\", opts.m_etc1s_use_global_codebooks_file.c_str());\n\t\t\treturn false;\n\t\t}\n\t\tprintf(\"Loaded global codebooks from file \\\"%s\\\"\\n\", opts.m_etc1s_use_global_codebooks_file.c_str());\n\t}\n\n\tif (!opts.m_input_filenames.size())\n\t{\n\t\terror_printf(\"No input files to process!\\n\");\n\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\treturn false;\n\t}\n\n\tFILE* pCSV_file = nullptr;\n\tif ((opts.m_csv_file.size()) && (opts.m_mode == cValidate))\n\t{\n\t\tpCSV_file = fopen_safe(opts.m_csv_file.c_str(), \"w\");\n\t\tif (!pCSV_file)\n\t\t{\n\t\t\terror_printf(\"Failed opening CVS file \\\"%s\\\"\\n\", opts.m_csv_file.c_str());\n\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\treturn false;\n\t\t}\n\t\t//fprintf(pCSV_file, \"Filename, Size, Slices, Width, Height, HasAlpha, BitsPerTexel, Slice0RGBAvgPSNR, Slice0RGBAAvgPSNR, Slice0Luma709PSNR, Slice0BestETC1SLuma709PSNR, Q, CL, Time, RGBAvgPSNRMin, RGBAvgPSNRAvg, AAvgPSNRMin, AAvgPSNRAvg, Luma709PSNRMin, Luma709PSNRAvg\\n\");\n\t}\n\n\tuint32_t total_unpack_warnings = 0;\n\tuint32_t total_pvrtc_nonpow2_warnings = 0;\n\n\tfor (uint32_t file_index = 0; file_index < opts.m_input_filenames.size(); file_index++)\n\t{\n\t\tconst char* pInput_filename = opts.m_input_filenames[file_index].c_str();\n\n\t\tstd::string base_filename;\n\t\tstring_split_path(pInput_filename, nullptr, nullptr, &base_filename, nullptr);\n\n\t\tuint8_vec file_data;\n\t\tif (!basisu::read_file_to_vec(pInput_filename, file_data))\n\t\t{\n\t\t\terror_printf(\"Failed reading file \\\"%s\\\"\\n\", pInput_filename);\n\t\t\tif (pCSV_file) fclose(pCSV_file);\n\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!file_data.size())\n\t\t{\n\t\t\terror_printf(\"File is empty!\\n\");\n\t\t\tif (pCSV_file) fclose(pCSV_file);\n\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (file_data.size() > UINT32_MAX)\n\t\t{\n\t\t\terror_printf(\"File is too large!\\n\");\n\t\t\tif (pCSV_file) fclose(pCSV_file);\n\t\t\tdelete pGlobal_codebook_data; pGlobal_codebook_data = nullptr;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tbool is_ktx2 = false;\n\t\tif (file_data.size() >= sizeof(basist::g_ktx2_file_identifier))\n\t\t{\n\t\t\tis_ktx2 = (memcmp(file_data.data(), basist::g_ktx2_file_identifier, sizeof(basist::g_ktx2_file_identifier)) == 0);\n\t\t}\n\n\t\tprintf(\"Input file \\\"%s\\\", KTX2: %u\\n\", pInput_filename, is_ktx2);\n\n\t\tbool status;\n\t\tif (is_ktx2)\n\t\t{\n\t\t\tstatus = unpack_and_validate_ktx2_file(\n\t\t\t\tfile_index,\n\t\t\t\tbase_filename,\n\t\t\t\tfile_data,\n\t\t\t\topts,\n\t\t\t\tpCSV_file,\n\t\t\t\tpGlobal_codebook_data,\n\t\t\t\ttotal_unpack_warnings,\n\t\t\t\ttotal_pvrtc_nonpow2_warnings);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatus = unpack_and_validate_basis_file(\n\t\t\t\tfile_index,\n\t\t\t\tbase_filename,\n\t\t\t\tfile_data,\n\t\t\t\topts,\n\t\t\t\tpCSV_file,\n\t\t\t\tpGlobal_codebook_data,\n\t\t\t\ttotal_unpack_warnings,\n\t\t\t\ttotal_pvrtc_nonpow2_warnings);\n\t\t}\n\n\t\tif (!status)\n\t\t{\n\t\t\tif (pCSV_file) \n\t\t\t\tfclose(pCSV_file);\n\n\t\t\tdelete pGlobal_codebook_data; \n\t\t\tpGlobal_codebook_data = nullptr;\n\n\t\t\treturn false;\n\t\t}\n\n\t} // file_index\n\n\tif (total_pvrtc_nonpow2_warnings)\n\t\tprintf(\"Warning: %u images could not be transcoded to PVRTC1 because one or both dimensions were not a power of 2\\n\", total_pvrtc_nonpow2_warnings);\n\n\tif (total_unpack_warnings)\n\t\tprintf(\"ATTENTION: %u total images had invalid GPU texture data!\\n\", total_unpack_warnings);\n\telse\n\t\tprintf(\"Success\\n\");\n\n\tdebug_printf(\"Elapsed time: %3.3f secs\\n\", tm.get_elapsed_secs());\n\n\tif (pCSV_file)\n\t{\n\t\tfclose(pCSV_file);\n\t\tpCSV_file = nullptr;\n\t}\n\tdelete pGlobal_codebook_data; \n\tpGlobal_codebook_data = nullptr;\n\n\treturn true;\n}\n\nstatic bool hdr_compare_mode(command_line_params& opts)\n{\n\tif (opts.m_input_filenames.size() != 2)\n\t{\n\t\terror_printf(\"Must specify two PNG filenames using -file\\n\");\n\t\treturn false;\n\t}\n\n\timagef a, b;\n\n\tif (!load_image_hdr(opts.m_input_filenames[0].c_str(), a))\n\t{\n\t\terror_printf(\"Failed loading image from file \\\"%s\\\"!\\n\", opts.m_input_filenames[0].c_str());\n\t\treturn false;\n\t}\n\n\tprintf(\"Loaded \\\"%s\\\", %ux%u\\n\", opts.m_input_filenames[0].c_str(), a.get_width(), a.get_height());\n\n\tif (!load_image_hdr(opts.m_input_filenames[1].c_str(), b))\n\t{\n\t\terror_printf(\"Failed loading image from file \\\"%s\\\"!\\n\", opts.m_input_filenames[1].c_str());\n\t\treturn false;\n\t}\n\n\tprintf(\"Loaded \\\"%s\\\", %ux%u\\n\", opts.m_input_filenames[1].c_str(), b.get_width(), b.get_height());\n\n\tif ((a.get_width() != b.get_width()) || (a.get_height() != b.get_height()))\n\t{\n\t\tprintf(\"Images don't have the same dimensions - cropping input images to smallest common dimensions\\n\");\n\n\t\tuint32_t w = minimum(a.get_width(), b.get_width());\n\t\tuint32_t h = minimum(a.get_height(), b.get_height());\n\n\t\ta.crop(w, h);\n\t\tb.crop(w, h);\n\t}\n\n\tprintf(\"Comparison image res: %ux%u\\n\", a.get_width(), a.get_height());\n\n\timage_metrics im;\n\t\t\n\tim.calc_half(a, b, 0, 1, true);\n\tim.print(\"R      \");\n\n\tim.calc_half(a, b, 1, 1, true);\n\tim.print(\"G      \");\n\n\tim.calc_half(a, b, 2, 1, true);\n\tim.print(\"B      \");\n\n\tim.calc_half(a, b, 0, 3, true);\n\tim.print(\"RGB    \");\n\n\treturn true;\n}\n\nstatic bool compare_mode(command_line_params &opts)\n{\n\tif (opts.m_input_filenames.size() != 2)\n\t{\n\t\terror_printf(\"Must specify two PNG filenames using -file\\n\");\n\t\treturn false;\n\t}\n\n\tstd::string ext0(string_get_extension(opts.m_input_filenames[0]));\n\tif ((strcasecmp(ext0.c_str(), \"exr\") == 0) || (strcasecmp(ext0.c_str(), \"hdr\") == 0))\n\t{\n\t\terror_printf(\"Can't compare HDR image files with this option. Use -hdr_compare instead.\\n\");\n\t\treturn false;\n\t}\n\n\tstd::string ext1(string_get_extension(opts.m_input_filenames[1]));\n\tif ((strcasecmp(ext1.c_str(), \"exr\") == 0) || (strcasecmp(ext1.c_str(), \"hdr\") == 0))\n\t{\n\t\terror_printf(\"Can't compare HDR image files with this option. Use -hdr_compare instead.\\n\");\n\t\treturn false;\n\t}\n\n\timage a, b;\n\tif (!load_image(opts.m_input_filenames[0].c_str(), a))\n\t{\n\t\terror_printf(\"Failed loading image from file \\\"%s\\\"!\\n\", opts.m_input_filenames[0].c_str());\n\t\treturn false;\n\t}\n\n\tprintf(\"Loaded \\\"%s\\\", %ux%u, has alpha: %u\\n\", opts.m_input_filenames[0].c_str(), a.get_width(), a.get_height(), a.has_alpha());\n\n\tif (!load_image(opts.m_input_filenames[1].c_str(), b))\n\t{\n\t\terror_printf(\"Failed loading image from file \\\"%s\\\"!\\n\", opts.m_input_filenames[1].c_str());\n\t\treturn false;\n\t}\n\n\tprintf(\"Loaded \\\"%s\\\", %ux%u, has alpha: %u\\n\", opts.m_input_filenames[1].c_str(), b.get_width(), b.get_height(), b.has_alpha());\n\n\tif ((a.get_width() != b.get_width()) || (a.get_height() != b.get_height()))\n\t{\n\t\tprintf(\"Images don't have the same dimensions - cropping input images to smallest common dimensions\\n\");\n\n\t\tuint32_t w = minimum(a.get_width(), b.get_width());\n\t\tuint32_t h = minimum(a.get_height(), b.get_height());\n\n\t\ta.crop(w, h);\n\t\tb.crop(w, h);\n\t}\n\n\tprintf(\"Comparison image res: %ux%u\\n\", a.get_width(), a.get_height());\n\n\timage_metrics im;\n\tim.calc(a, b, 0, 3);\n\tim.print(\"RGB    \");\n\n\tim.calc(a, b, 0, 4);\n\tim.print(\"RGBA   \");\n\n\tim.calc(a, b, 0, 1);\n\tim.print(\"R      \");\n\n\tim.calc(a, b, 1, 1);\n\tim.print(\"G      \");\n\n\tim.calc(a, b, 2, 1);\n\tim.print(\"B      \");\n\n\tim.calc(a, b, 3, 1);\n\tim.print(\"A      \");\n\n\tim.calc(a, b, 0, 0);\n\tim.print(\"Y 709  \" );\n\n\tim.calc(a, b, 0, 0, true, true);\n\tim.print(\"Y 601  \" );\n\t\n\tif (opts.m_compare_ssim)\n\t{\n\t\tvec4F s_rgb(compute_ssim(a, b, false, false));\n\n\t\tprintf(\"R SSIM: %f\\n\", s_rgb[0]);\n\t\tprintf(\"G SSIM: %f\\n\", s_rgb[1]);\n\t\tprintf(\"B SSIM: %f\\n\", s_rgb[2]);\n\t\tprintf(\"RGB Avg SSIM: %f\\n\", (s_rgb[0] + s_rgb[1] + s_rgb[2]) / 3.0f);\n\t\tprintf(\"A SSIM: %f\\n\", s_rgb[3]);\n\n\t\tvec4F s_y_709(compute_ssim(a, b, true, false));\n\t\tprintf(\"Y 709 SSIM: %f\\n\", s_y_709[0]);\n\n\t\tvec4F s_y_601(compute_ssim(a, b, true, true));\n\t\tprintf(\"Y 601 SSIM: %f\\n\", s_y_601[0]);\n\t}\n\n\timage delta_img(a.get_width(), a.get_height());\n\n\tconst int X = 2;\n\n\tfor (uint32_t y = 0; y < a.get_height(); y++)\n\t{\n\t\tfor (uint32_t x = 0; x < a.get_width(); x++)\n\t\t{\n\t\t\tcolor_rgba &d = delta_img(x, y);\n\n\t\t\tfor (int c = 0; c < 4; c++)\n\t\t\t\td[c] = (uint8_t)clamp<int>((a(x, y)[c] - b(x, y)[c]) * X + 128, 0, 255);\n\t\t} // x\n\t} // y\n\n\tsave_png(\"a_rgb.png\", a, cImageSaveIgnoreAlpha);\n\tsave_png(\"a_alpha.png\", a, cImageSaveGrayscale, 3);\n\tprintf(\"Wrote a_rgb.png and a_alpha.png\\n\");\n\n\tsave_png(\"b_rgb.png\", b, cImageSaveIgnoreAlpha);\n\tsave_png(\"b_alpha.png\", b, cImageSaveGrayscale, 3);\n\tprintf(\"Wrote b_rgb.png and b_alpha.png\\n\");\n\n\tsave_png(\"delta_img_rgb.png\", delta_img, cImageSaveIgnoreAlpha);\n\tprintf(\"Wrote delta_img_rgb.png\\n\");\n\t\n\tsave_png(\"delta_img_a.png\", delta_img, cImageSaveGrayscale, 3);\n\tprintf(\"Wrote delta_img_a.png\\n\");\n\n\tif (opts.m_compare_plot)\n\t{\n\t\tuint32_t bins[5][512];\n\t\tclear_obj(bins);\n\n\t\trunning_stat delta_stats[5];\n\t\tbasisu::rand rm;\n\n\t\tdouble avg[5];\n\t\tclear_obj(avg);\n\n\t\tfor (uint32_t y = 0; y < a.get_height(); y++)\n\t\t{\n\t\t\tfor (uint32_t x = 0; x < a.get_width(); x++)\n\t\t\t{\n\t\t\t\t//color_rgba& d = delta_img(x, y);\n\n\t\t\t\tfor (int c = 0; c < 4; c++)\n\t\t\t\t{\n\t\t\t\t\tint delta = a(x, y)[c] - b(x, y)[c];\n\n\t\t\t\t\t//delta = clamp<int>((int)std::round(rm.gaussian(70.0f, 10.0f)), -255, 255);\n\n\t\t\t\t\tbins[c][delta + 256]++;\n\t\t\t\t\tdelta_stats[c].push(delta);\n\n\t\t\t\t\tavg[c] += delta;\n\t\t\t\t}\n\n\t\t\t\tint y_delta = a(x, y).get_709_luma() - b(x, y).get_709_luma();\n\t\t\t\tbins[4][y_delta + 256]++;\n\t\t\t\tdelta_stats[4].push(y_delta);\n\n\t\t\t\tavg[4] += y_delta;\n\n\t\t\t} // x\n\t\t} // y\n\n\t\tfor (uint32_t i = 0; i <= 4; i++)\n\t\t\tavg[i] /= a.get_total_pixels();\n\n\t\tprintf(\"\\n\");\n\n\t\t//bins[2][256+-255] = 100000;\n\t\t//bins[2][256-56] = 50000;\n\n\t\tconst uint32_t X_SIZE = 128, Y_SIZE = 40;\n\n\t\tfor (uint32_t c = 0; c <= 4; c++)\n\t\t{\n\t\t\tstd::vector<uint8_t> plot[Y_SIZE + 1];\n\t\t\tfor (uint32_t i = 0; i < Y_SIZE; i++)\n\t\t\t{\n\t\t\t\tplot[i].resize(X_SIZE + 2);\n\t\t\t\tmemset(plot[i].data(), ' ', X_SIZE + 1);\n\t\t\t}\n\n\t\t\tuint32_t max_val = 0;\n\t\t\tint max_val_bin_index = 0;\n\t\t\tint lowest_bin_index = INT_MAX, highest_bin_index = INT_MIN;\n\t\t\tdouble avg_val = 0;\n\t\t\tdouble total_val = 0;\n\t\t\trunning_stat bin_stats;\n\n\t\t\tfor (int y = -255; y <= 255; y++)\n\t\t\t{\n\t\t\t\tuint32_t val = bins[c][256 + y];\n\t\t\t\tif (!val)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbin_stats.push(y);\n\n\t\t\t\ttotal_val += (double)val;\n\n\t\t\t\tlowest_bin_index = minimum(lowest_bin_index, y);\n\t\t\t\thighest_bin_index = maximum(highest_bin_index, y);\n\n\t\t\t\tif (val > max_val)\n\t\t\t\t{\n\t\t\t\t\tmax_val = val;\n\t\t\t\t\tmax_val_bin_index = y;\n\t\t\t\t}\n\t\t\t\tavg_val += y * (double)val;\n\t\t\t}\n\t\t\tavg_val /= total_val;\n\n\t\t\tint lo_limit = -(int)X_SIZE / 2;\n\t\t\tint hi_limit = X_SIZE / 2;\n\t\t\tfor (int x = lo_limit; x <= hi_limit; x++)\n\t\t\t{\n\t\t\t\tuint32_t total = 0;\n\t\t\t\tif (x == lo_limit)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = -255; i <= lo_limit; i++)\n\t\t\t\t\t\ttotal += bins[c][256 + i];\n\t\t\t\t}\n\t\t\t\telse if (x == hi_limit)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = hi_limit; i <= 255; i++)\n\t\t\t\t\t\ttotal += bins[c][256 + i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttotal = bins[c][256 + x];\n\t\t\t\t}\n\n\t\t\t\tuint32_t height = max_val ? (total * Y_SIZE + max_val - 1) / max_val : 0;\n\n\t\t\t\tif (height)\n\t\t\t\t{\n\t\t\t\t\tfor (uint32_t y = (Y_SIZE - 1) - (height - 1); y <= (Y_SIZE - 1); y++)\n\t\t\t\t\t\tplot[y][x + X_SIZE / 2] = '*';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%c delta histogram: total samples: %5.0f, max bin value: %u index: %i (%3.3f%% of total), range %i [%i,%i], weighted mean: %f\\n\", \"RGBAY\"[c], total_val, max_val, max_val_bin_index, max_val * 100.0f / total_val, highest_bin_index - lowest_bin_index + 1, lowest_bin_index, highest_bin_index, avg_val);\n\t\t\tprintf(\"bin mean: %f, bin std deviation: %f, non-zero bins: %u\\n\", bin_stats.get_mean(), bin_stats.get_std_dev(), bin_stats.get_num());\n\t\t\tprintf(\"delta mean: %f, delta std deviation: %f\\n\", delta_stats[c].get_mean(), delta_stats[c].get_std_dev());\n\t\t\tprintf(\"\\n\");\n\n\t\t\tfor (uint32_t y = 0; y < Y_SIZE; y++)\n\t\t\t\tprintf(\"%s\\n\", (char*)plot[y].data());\n\n\t\t\tchar tics[1024];\n\t\t\ttics[0] = '\\0';\n\t\t\tchar tics2[1024];\n\t\t\ttics2[0] = '\\0';\n\n\t\t\tfor (int x = 0; x <= (int)X_SIZE; x++)\n\t\t\t{\n\t\t\t\tchar buf[64];\n\t\t\t\tif (x == X_SIZE / 2)\n\t\t\t\t{\n\t\t\t\t\twhile ((int)strlen(tics) < x)\n\t\t\t\t\t\tstrcat(tics, \".\");\n\n\t\t\t\t\twhile ((int)strlen(tics2) < x)\n\t\t\t\t\t\tstrcat(tics2, \" \");\n\n\t\t\t\t\tsprintf(buf, \"0\");\n\t\t\t\t\tstrcat(tics, buf);\n\t\t\t\t}\n\t\t\t\telse if (((x & 7) == 0) || (x == X_SIZE))\n\t\t\t\t{\n\t\t\t\t\twhile ((int)strlen(tics) < x)\n\t\t\t\t\t\tstrcat(tics, \".\");\n\n\t\t\t\t\twhile ((int)strlen(tics2) < x)\n\t\t\t\t\t\tstrcat(tics2, \" \");\n\n\t\t\t\t\tint v = (x - (int)X_SIZE / 2);\n\t\t\t\t\tsprintf(buf, \"%i\", v / 10);\n\t\t\t\t\tstrcat(tics, buf);\n\n\t\t\t\t\tif (v < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (-v < 10)\n\t\t\t\t\t\t\tsprintf(buf, \"%i\", v % 10);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsprintf(buf, \" %i\", -v % 10);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(buf, \"%i\", v % 10);\n\t\t\t\t\tstrcat(tics2, buf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile ((int)strlen(tics) < x)\n\t\t\t\t\t\tstrcat(tics, \".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%s\\n\", tics);\n\t\t\tprintf(\"%s\\n\", tics2);\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t} // display_plot\n\t\n\treturn true;\n}\n\nstatic bool split_image_mode(command_line_params& opts)\n{\n\tif (opts.m_input_filenames.size() != 1)\n\t{\n\t\terror_printf(\"Must specify one image filename using -file\\n\");\n\t\treturn false;\n\t}\n\n\timage a;\n\tif (!load_image(opts.m_input_filenames[0].c_str(), a))\n\t{\n\t\terror_printf(\"Failed loading image from file \\\"%s\\\"!\\n\", opts.m_input_filenames[0].c_str());\n\t\treturn false;\n\t}\n\n\tprintf(\"Loaded \\\"%s\\\", %ux%u, has alpha: %u\\n\", opts.m_input_filenames[0].c_str(), a.get_width(), a.get_height(), a.has_alpha());\n\n\tif (!save_png(\"split_rgb.png\", a, cImageSaveIgnoreAlpha))\n\t{\n\t\tfprintf(stderr, \"Failed writing file split_rgb.png\\n\");\n\t\treturn false;\n\t}\n\tprintf(\"Wrote file split_rgb.png\\n\");\n\n\tfor (uint32_t i = 0; i < 4; i++)\n\t{\n\t\tchar buf[256];\n\t\tsnprintf(buf, sizeof(buf), \"split_%c.png\", \"RGBA\"[i]);\n\t\tif (!save_png(buf, a, cImageSaveGrayscale, i))\n\t\t{\n\t\t\tfprintf(stderr, \"Failed writing file %s\\n\", buf);\n\t\t\treturn false;\n\t\t}\n\t\tprintf(\"Wrote file %s\\n\", buf);\n\t}\n\t\n\treturn true;\n}\n\nstatic bool combine_images_mode(command_line_params& opts)\n{\n\tif (opts.m_input_filenames.size() != 2)\n\t{\n\t\terror_printf(\"Must specify two image filename using -file\\n\");\n\t\treturn false;\n\t}\n\n\timage a, b;\n\tif (!load_image(opts.m_input_filenames[0].c_str(), a))\n\t{\n\t\terror_printf(\"Failed loading image from file \\\"%s\\\"!\\n\", opts.m_input_filenames[0].c_str());\n\t\treturn false;\n\t}\n\n\tprintf(\"Loaded \\\"%s\\\", %ux%u, has alpha: %u\\n\", opts.m_input_filenames[0].c_str(), a.get_width(), a.get_height(), a.has_alpha());\n\n\tif (!load_image(opts.m_input_filenames[1].c_str(), b))\n\t{\n\t\terror_printf(\"Failed loading image from file \\\"%s\\\"!\\n\", opts.m_input_filenames[1].c_str());\n\t\treturn false;\n\t}\n\n\tprintf(\"Loaded \\\"%s\\\", %ux%u, has alpha: %u\\n\", opts.m_input_filenames[1].c_str(), b.get_width(), b.get_height(), b.has_alpha());\n\n\tconst uint32_t width = minimum(a.get_width(), b.get_width());\n\tconst uint32_t height = minimum(b.get_height(), b.get_height());\n\n\timage combined_img(width, height);\n\tfor (uint32_t y = 0; y < height; y++)\n\t{\n\t\tfor (uint32_t x = 0; x < width; x++)\n\t\t{\n\t\t\tcombined_img(x, y) = a(x, y);\n\t\t\tcombined_img(x, y).a = b(x, y).g;\n\t\t}\n\t}\n\n\tconst char* pOutput_filename = \"combined.png\";\n\tif (opts.m_output_filename.size())\n\t\tpOutput_filename = opts.m_output_filename.c_str();\n\t\t\n\tif (!save_png(pOutput_filename, combined_img))\n\t{\n\t\tfprintf(stderr, \"Failed writing file %s\\n\", pOutput_filename);\n\t\treturn false;\n\t}\n\tprintf(\"Wrote file %s\\n\", pOutput_filename);\n\n\treturn true;\n}\n\nstatic bool tonemap_image_mode(command_line_params& opts)\n{\n\tif (opts.m_input_filenames.size() != 1)\n\t{\n\t\terror_printf(\"Must specify one LDR image filename using -file\\n\");\n\t\treturn false;\n\t}\n\n\timagef hdr_img;\n\tif (!load_image_hdr(opts.m_input_filenames[0].c_str(), hdr_img, opts.m_comp_params.m_hdr_ldr_srgb_to_linear_conversion))\n\t{\n\t\terror_printf(\"Failed loading LDR image from file \\\"%s\\\"!\\n\", opts.m_input_filenames[0].c_str());\n\t\treturn false;\n\t}\n\n\thdr_img.clean_astc_hdr_pixels(1e+30f);\n\n\tconst uint32_t width = hdr_img.get_width(), height = hdr_img.get_height();\n\n\tprintf(\"Loaded \\\"%s\\\", %ux%u\\n\", opts.m_input_filenames[0].c_str(), width, height);\n\n\tstd::string output_filename;\n\tstring_get_filename(opts.m_input_filenames[0].c_str(), output_filename);\n\tstring_remove_extension(output_filename);\n\tif (!output_filename.size())\n\t\toutput_filename = \"tonemapped\";\n\n\tif (opts.m_output_path.size())\n\t\tstring_combine_path(output_filename, opts.m_output_path.c_str(), output_filename.c_str());\n\n\tconst char* pBasename = output_filename.c_str();\n\t\n\timage srgb_img(width, height);\n\n\tfor (uint32_t y = 0; y < height; y++)\n\t{\n\t\tfor (uint32_t x = 0; x < width; x++)\n\t\t{\n\t\t\tvec4F p(hdr_img(x, y));\n\n\t\t\tp[0] = clamp(p[0], 0.0f, 1.0f);\n\t\t\tp[1] = clamp(p[1], 0.0f, 1.0f);\n\t\t\tp[2] = clamp(p[2], 0.0f, 1.0f);\n\n\t\t\tint rc = (int)std::round(linear_to_srgb(p[0]) * 255.0f);\n\t\t\tint gc = (int)std::round(linear_to_srgb(p[1]) * 255.0f);\n\t\t\tint bc = (int)std::round(linear_to_srgb(p[2]) * 255.0f);\n\n\t\t\tsrgb_img.set_clipped(x, y, color_rgba(rc, gc, bc, 255));\n\t\t}\n\t}\n\n\t{\n\t\tconst std::string filename(string_format(\"%s_linear_clamped_to_srgb.png\", pBasename));\n\t\tsave_png(filename.c_str(), srgb_img);\n\t\tprintf(\"Wrote .PNG file %s\\n\", filename.c_str());\n\t}\n\n\t{\n\t\tconst std::string filename(string_format(\"%s_compressive_tonemapped.png\", pBasename));\n\t\timage compressive_tonemapped_img;\n\n\t\tbool status = tonemap_image_compressive(compressive_tonemapped_img, hdr_img);\n\t\tif (!status)\n\t\t{\n\t\t\terror_printf(\"tonemap_image_compressive() failed (invalid half-float input)\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsave_png(filename.c_str(), compressive_tonemapped_img);\n\t\t\tprintf(\"Wrote .PNG file %s\\n\", filename.c_str());\n\t\t}\n\t}\n\n\timage tonemapped_img;\n\n\tfor (int e = -5; e <= 5; e++)\n\t{\n\t\tconst float scale = powf(2.0f, (float)e);\n\n\t\ttonemap_image_reinhard(tonemapped_img, hdr_img, scale);\n\n\t\tstd::string filename(string_format(\"%s_reinhard_tonemapped_scale_%f.png\", pBasename, scale));\n\t\tsave_png(filename.c_str(), tonemapped_img, cImageSaveIgnoreAlpha);\n\t\tprintf(\"Wrote .PNG file %s\\n\", filename.c_str());\n\t}\n\n\treturn true;\n}\n\n//#include \"encoder/3rdparty/android_astc_decomp.h\"\n//#include \"encoder/basisu_pvrtc1_4.h\"\n\nstatic bool bench_mode(command_line_params& opts)\n{\n\tBASISU_NOTE_UNUSED(opts);\n\terror_printf(\"Unsupported\\n\");\n\treturn false;\n\n#if 0\n\n#if 0\n\tispc::bc7e_compress_block_init();\n\n\tispc::bc7e_compress_block_params pack_params;\n\tmemset(&pack_params, 0, sizeof(pack_params));\n\tispc::bc7e_compress_block_params_init_slow(&pack_params, false);\n#endif\n\n\tconst uint32_t JOB_POOL_SIZE = 7;\n\tjob_pool jpool(JOB_POOL_SIZE);\n\n\tfloat total_uastc_psnr = 0, total_uastc_a_psnr = 0, total_uastc_rgba_psnr = 0;\n\tfloat total_rdo_uastc_psnr = 0, total_rdo_uastc_a_psnr = 0, total_rdo_uastc_rgba_psnr = 0;\n\tfloat total_uastc2_psnr = 0, total_uastc2_a_psnr = 0, total_uastc2_rgba_psnr = 0;\n\tfloat total_bc7_psnr = 0, total_bc7_a_psnr = 0, total_bc7_rgba_psnr = 0;\n\tfloat total_rdo_bc7_psnr = 0, total_rdo_bc7_a_psnr = 0, total_rdo_bc7_rgba_psnr = 0;\n\tfloat total_obc1_psnr = 0;\n\tfloat total_obc1_2_psnr = 0;\n\tfloat total_obc1_psnr_sq = 0;\n\tfloat total_obc1_2_psnr_sq = 0;\n\tfloat total_bc1_psnr = 0;\n\tfloat total_bc1_psnr_sq = 0;\n\t//float total_obc7_psnr = 0, total_obc7_rgba_psnr = 0;\n\t//float total_obc7_a_psnr = 0;\n\t//float total_oastc_psnr = 0, total_oastc_rgba_psnr = 0;\n\tfloat total_bc7enc_psnr = 0, total_bc7enc_rgba_psnr = 0, total_bc7enc_a_psnr = 0;\n\t//float total_oastc_a_psnr = 0;\n\tfloat total_etc1_psnr = 0;\n\tfloat total_etc1_y_psnr = 0;\n\tfloat total_etc1_g_psnr = 0;\n\tfloat total_etc2_psnr = 0, total_etc2_rgba_psnr = 0;\n\tfloat total_etc2_a_psnr = 0;\n\tfloat total_bc3_psnr = 0, total_bc3_rgba_psnr = 0;\n\tfloat total_bc3_a_psnr = 0;\n\tfloat total_eac_r11_psnr = 0;\n\tfloat total_eac_rg11_psnr = 0;\n\tfloat total_pvrtc1_rgb_psnr = 0, total_pvrtc1_rgba_psnr = 0;\n\tfloat total_pvrtc1_a_psnr = 0;\n\tuint32_t total_images = 0;\n\tuint32_t total_a_images = 0;\n\tuint32_t total_pvrtc1_images = 0;\n\n\tuint64_t overall_mode_hist[basist::TOTAL_UASTC_MODES];\n\tmemset(overall_mode_hist, 0, sizeof(overall_mode_hist));\n\n\tstd::mutex mode_hist_mutex;\n\n\tuint32_t etc1_hint_hist[32];\n\tmemset(etc1_hint_hist, 0, sizeof(etc1_hint_hist));\n\n\tsrand(1023);\n\tuint32_t first_image = 96;\n\tuint32_t last_image = 96; //34\n\n\tif (opts.m_input_filenames.size() >= 1)\n\t{\n\t\tfirst_image = 1;\n\t\tlast_image = 1;\n\t}\n\n\tconst bool perceptual = false;\n\tconst bool force_la = false;\n\n\tinterval_timer otm;\n\totm.start();\n\n\t//const uint32_t flags = cPackUASTCLevelFastest;// | cPackUASTCETC1DisableFlipAndIndividual;// Slower;\n\t//const uint32_t flags = cPackUASTCLevelFaster;\n\t//const uint32_t flags = cPackUASTCLevelVerySlow;\n\tconst uint32_t flags = cPackUASTCLevelDefault;\n\n\tuint32_t etc1_inten_hist[8] = { 0,0,0,0,0,0,0,0 };\n\tuint32_t etc1_flip_hist[2] = { 0, 0 };\n\tuint32_t etc1_diff_hist[2] = { 0, 0 };\n\n\tdouble overall_total_enc_time = 0;\n\tdouble overall_total_bench_time = 0;\n\tdouble overall_total_bench2_time = 0;\n\tuint64_t overall_blocks = 0;\n\n\t//bc7enc_compress_block_params bc7enc_p;\n\t//bc7enc_compress_block_params_init(&bc7enc_p);\n\t//bc7enc_compress_block_params_init_linear_weights(&bc7enc_p);\n\t//bc7enc_p.m_uber_level = 3;\n\n\tuint64_t total_comp_size = 0;\n\tuint64_t total_raw_size = 0;\n\tuint64_t total_rdo_comp_size = 0;\n\tuint64_t total_rdo_raw_size = 0;\n\tuint64_t total_comp_blocks = 0;\n\n\tfor (uint32_t image_index = first_image; image_index <= last_image; image_index++)\n\t{\n\t\tuint64_t mode_hist[basist::TOTAL_UASTC_MODES];\n\t\tmemset(mode_hist, 0, sizeof(mode_hist));\n\n\t\tchar buf[1024];\n\t\tif (opts.m_input_filenames.size() >= 1)\n\t\t\tstrcpy(buf, opts.m_input_filenames[0].c_str());\n\t\telse\n\t\t\tsprintf(buf, \"c:/dev/test_images/photo_png/kodim%02u.png\", image_index);\n\n\t\tprintf(\"Image: %s\\n\", buf);\n\n\t\timage img;\n\t\tif (!load_image(buf, img))\n\t\t\treturn 0;\n\n\t\tif (opts.m_input_filenames.size() == 2)\n\t\t{\n\t\t\timage alpha_img;\n\t\t\tif (!load_image(opts.m_input_filenames[1].c_str(), alpha_img))\n\t\t\t\treturn 0;\n\n\t\t\tprintf(\"Alpha image: %s, %ux%u\\n\", opts.m_input_filenames[1].c_str(), alpha_img.get_width(), alpha_img.get_height());\n\n\t\t\tfor (uint32_t x = 0; x < alpha_img.get_width(); x++)\n\t\t\t\tfor (uint32_t y = 0; y < alpha_img.get_height(); y++)\n\t\t\t\t{\n\t\t\t\t\tif (x < img.get_width() && y < img.get_height())\n\t\t\t\t\t\timg(x, y)[3] = (uint8_t)alpha_img(x, y).get_709_luma();\n\t\t\t\t}\n\t\t}\n\n\t\tif (force_la)\n\t\t{\n\t\t\tfor (uint32_t x = 0; x < img.get_width(); x++)\n\t\t\t{\n\t\t\t\tfor (uint32_t y = 0; y < img.get_height(); y++)\n\t\t\t\t{\n\t\t\t\t\tconst color_rgba& c = img(x, y);\n\t\t\t\t\timg(x, y).set(c.r, c.r, c.r, c.g);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// HACK HACK\n\t\t//if (!img.has_alpha())\n\t\t//\tcontinue;\n\n\t\t// HACK HACK\n\t\t//img.crop(1024, 1024);\n\n\t\tconst uint32_t num_blocks_x = img.get_block_width(4);\n\t\tconst uint32_t num_blocks_y = img.get_block_height(4);\n\t\tconst uint32_t total_blocks = num_blocks_x * num_blocks_y;\n\t\tconst bool img_has_alpha = img.has_alpha();\n\n\t\timg.crop_dup_borders(num_blocks_x * 4, num_blocks_y * 4);\n\n\t\tprintf(\"%ux%u, has alpha: %u\\n\", img.get_width(), img.get_height(), img_has_alpha);\n\n\t\timage uastc_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage rdo_uastc_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage uastc2_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage opt_bc1_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage opt_bc1_2_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage bc1_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage bc3_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage eac_r11_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage eac_rg11_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage bc7_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage rdo_bc7_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage opt_bc7_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage etc1_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage etc1_g_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage etc2_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage part_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage opt_astc_img(num_blocks_x * 4, num_blocks_y * 4);\n\t\timage bc7enc_img(num_blocks_x * 4, num_blocks_y * 4);\n\n\t\tuint32_t total_bc1_hint0s = 0;\n\t\tuint32_t total_bc1_hint1s = 0;\n\t\tuint32_t total_bc1_hint01s = 0;\n\n\t\tdouble total_enc_time = 0;\n\t\tdouble total_bench_time = 0;\n\t\tdouble total_bench2_time = 0;\n\n\t\tbasisu::vector<basist::uastc_block> ublocks(total_blocks);\n\n#if 0\n\t\tastc_enc_settings astc_settings;\n\t\t//if (img_has_alpha)\n\t\tGetProfile_astc_alpha_slow(&astc_settings, 4, 4);\n\t\t//else\n\t\t//\tGetProfile_astc_fast(&astc_settings, 4, 4);\n#endif\n\n#if 0\n//#pragma omp parallel for\n\t\tfor (int by = 0; by < (int)num_blocks_y; by++)\n\t\t{\n\t\t\t// Process 64 blocks at a time, for efficient SIMD processing.\n\t\t\t// Ideally, N >= 8 (or more) and (N % 8) == 0.\n\t\t\tconst int N = 64;\n\n\t\t\tfor (uint32_t bx = 0; bx < num_blocks_x; bx += N)\n\t\t\t{\n\t\t\t\tconst uint32_t num_blocks_to_process = basisu::minimum<uint32_t>(num_blocks_x - bx, N);\n\n\t\t\t\tcolor_rgba pixels[16 * N];\n\n#if 0\n\t\t\t\t// BC7E\n\t\t\t\t// Extract num_blocks_to_process 4x4 pixel blocks from the source image and put them into the pixels[] array.\n\t\t\t\tfor (uint32_t b = 0; b < num_blocks_to_process; b++)\n\t\t\t\t\timg.extract_block_clamped(pixels + b * 16, (bx + b) * 4, by * 4, 4, 4);\n\n\t\t\t\t// Compress the blocks to BC7.\n\t\t\t\t// Note: If you've used Intel's ispc_texcomp, the input pixels are different. BC7E requires a pointer to an array of 16 pixels for each block.\n\t\t\t\tbasist::bc7_block packed_blocks[N];\n\t\t\t\tispc::bc7e_compress_blocks(num_blocks_to_process, (uint64_t*)packed_blocks, reinterpret_cast<const uint32_t*>(pixels), &pack_params);\n\n\t\t\t\tfor (uint32_t i = 0; i < num_blocks_to_process; i++)\n\t\t\t\t{\n\t\t\t\t\tcolor_rgba decoded_block[4][4];\n\n\t\t\t\t\t//detexDecompressBlockBPTC((uint8_t *)&packed_blocks[i], 0xFF, 0, (uint8_t *)&decoded_block[0][0]);\n\t\t\t\t\tunpack_block(texture_format::cBC7, &packed_blocks[i], &decoded_block[0][0]);\n\n\t\t\t\t\topt_bc7_img.set_block_clipped(&decoded_block[0][0], (bx + i) * 4, by * 4, 4, 4);\n\t\t\t\t}\n#endif\n\n#if 0\n\t\t\t\t// ispc_texcomp\n\t\t\t\tcolor_rgba raster_pixels[(N * 4) * 4];\n\n\t\t\t\tconst uint32_t raster_width = num_blocks_to_process * 4;\n\t\t\t\tconst uint32_t raster_height = 4;\n\n\t\t\t\trgba_surface surf;\n\t\t\t\tsurf.ptr = &raster_pixels[0].r;\n\t\t\t\tsurf.width = raster_width;\n\t\t\t\tsurf.height = 4;\n\t\t\t\tsurf.stride = raster_width * 4;\n\n\t\t\t\tfor (uint32_t b = 0; b < num_blocks_to_process; b++)\n\t\t\t\t\tfor (uint32_t y = 0; y < 4; y++)\n\t\t\t\t\t\tfor (uint32_t x = 0; x < 4; x++)\n\t\t\t\t\t\t\traster_pixels[y * raster_width + b * 4 + x] = pixels[b * 16 + y * 4 + x];\n\n\t\t\t\tuint8_t astc_blocks[16 * N];\n\t\t\t\tCompressBlocksASTC(&surf, astc_blocks, &astc_settings);\n\n\t\t\t\tfor (uint32_t i = 0; i < num_blocks_to_process; i++)\n\t\t\t\t{\n\t\t\t\t\tcolor_rgba decoded_astc_block[4][4];\n\t\t\t\t\tbasisu_astc::astc::decompress((uint8_t*)decoded_astc_block, (uint8_t*)&astc_blocks[i * 16], false, 4, 4);\n\n\t\t\t\t\topt_astc_img.set_block_clipped(&decoded_astc_block[0][0], (bx + i) * 4, by * 4, 4, 4);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n#endif\n\n\t\tconst uint32_t N = 128;\n\t\tfor (uint32_t block_index_iter = 0; block_index_iter < total_blocks; block_index_iter += N)\n\t\t{\n\t\t\tconst uint32_t first_index = block_index_iter;\n\t\t\tconst uint32_t last_index = minimum<uint32_t>(total_blocks, block_index_iter + N);\n\n\t\t\tjpool.add_job([first_index, last_index, &img, num_blocks_x, num_blocks_y,\n\t\t\t\t&opt_bc1_img, &opt_bc1_2_img, &mode_hist, &overall_mode_hist, &uastc_img, &uastc2_img, &bc7_img, &part_img, &mode_hist_mutex, &bc1_img, &etc1_img, &etc1_g_img, &etc2_img, &etc1_hint_hist, &perceptual,\n\t\t\t\t&total_bc1_hint0s, &total_bc1_hint1s, &total_bc1_hint01s, &bc3_img, &total_enc_time, &eac_r11_img, &eac_rg11_img, &ublocks, &flags, &etc1_inten_hist, &etc1_flip_hist, &etc1_diff_hist, &total_bench_time, &total_bench2_time,\n\t\t\t\t//&bc7enc_p, &bc7enc_img] {\n\t\t\t\t&bc7enc_img] {\n\n\t\t\t\t\tBASISU_NOTE_UNUSED(num_blocks_y);\n\t\t\t\t\tBASISU_NOTE_UNUSED(perceptual);\n\t\t\t\t\tBASISU_NOTE_UNUSED(flags);\n\n\t\t\t\t\tfor (uint32_t block_index = first_index; block_index < last_index; block_index++)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst uint32_t block_x = block_index % num_blocks_x;\n\t\t\t\t\t\tconst uint32_t block_y = block_index / num_blocks_x;\n\n\t\t\t\t\t\t//uint32_t block_x = 170;\n\t\t\t\t\t\t//uint32_t block_y = 167;\n\n\t\t\t\t\t\t// HACK HACK\n\t\t\t\t\t\t//if ((block_x == 77) && (block_y == 54))\n\t\t\t\t\t\t//\tprintf(\"!\");\n\n\t\t\t\t\t\tcolor_rgba block[4][4];\n\t\t\t\t\t\timg.extract_block_clamped(&block[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\tuint8_t bc7_block[16];\n\t\t\t\t\t\t//bc7enc_compress_block(bc7_block, block, &bc7enc_p);\n\t\t\t\t\t\tcolor_rgba decoded_bc7enc_blk[4][4];\n\t\t\t\t\t\tunpack_block(texture_format::cBC7, &bc7_block, &decoded_bc7enc_blk[0][0]);\n\t\t\t\t\t\tbc7enc_img.set_block_clipped(&decoded_bc7enc_blk[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\t// Pack near-optimal BC1\n\t\t\t\t\t\t// stb_dxt BC1 encoder\n\t\t\t\t\t\tuint8_t bc1_block[8];\n\n\t\t\t\t\t\tinterval_timer btm;\n\t\t\t\t\t\tbtm.start();\n\n\t\t\t\t\t\t//stb_compress_dxt_block(bc1_block, (uint8_t*)&block[0][0], 0, STB_DXT_HIGHQUAL);\n\t\t\t\t\t\tbasist::encode_bc1(bc1_block, (uint8_t*)&block[0][0], 0);// basist::cEncodeBC1HighQuality);\n\t\t\t\t\t\tdouble total_b_time = btm.get_elapsed_secs();\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::lock_guard<std::mutex> lck(mode_hist_mutex);\n\t\t\t\t\t\t\ttotal_bench_time += total_b_time;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcolor_rgba block_bc1[4][4];\n\t\t\t\t\t\tunpack_block(texture_format::cBC1, bc1_block, &block_bc1[0][0]);\n\t\t\t\t\t\topt_bc1_img.set_block_clipped(&block_bc1[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\t//uint64_t e1 = 0;\n\t\t\t\t\t\t//for (uint32_t i = 0; i < 16; i++)\n\t\t\t\t\t\t//\te1 += color_distance(((color_rgba*)block_bc1)[i], ((color_rgba*)block)[i], false);\n\n\t\t\t\t\t\t// My BC1 encoder\n\t\t\t\t\t\tuint8_t bc1_block_2[8];\n\t\t\t\t\t\tcolor_rgba block_bc1_2[4][4];\n\n\t\t\t\t\t\tbtm.start();\n\t\t\t\t\t\tbasist::encode_bc1_alt(bc1_block_2, (uint8_t*)&block[0][0], basist::cEncodeBC1HighQuality);\n\t\t\t\t\t\tdouble total_b2_time = btm.get_elapsed_secs();\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::lock_guard<std::mutex> lck(mode_hist_mutex);\n\t\t\t\t\t\t\ttotal_bench2_time += total_b2_time;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tunpack_block(texture_format::cBC1, bc1_block_2, &block_bc1_2[0][0]);\n\t\t\t\t\t\t//uint64_t e2 = 0;\n\t\t\t\t\t\t//for (uint32_t i = 0; i < 16; i++)\n\t\t\t\t\t\t//\te2 += color_distance(((color_rgba *)block_bc1_2)[i], ((color_rgba*)block)[i], false);\n\n\t\t\t\t\t\topt_bc1_2_img.set_block_clipped(&block_bc1_2[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\t// Encode to UASTC\n\t\t\t\t\t\tbasist::uastc_block encoded_uastc_blk;\n\n\t\t\t\t\t\tinterval_timer tm;\n\t\t\t\t\t\ttm.start();\n\t\t\t\t\t\tencode_uastc(&block[0][0].r, encoded_uastc_blk, flags);\n\t\t\t\t\t\tdouble total_time = tm.get_elapsed_secs();\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::lock_guard<std::mutex> lck(mode_hist_mutex);\n\t\t\t\t\t\t\ttotal_enc_time += total_time;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tublocks[block_x + block_y * num_blocks_x] = encoded_uastc_blk;\n\n#if 0\n\t\t\t\t\t\tfor (uint32_t i = 0; i < 16; i++)\n\t\t\t\t\t\t\tprintf(\"0x%X,\", encoded_uastc_blk.m_bytes[i]);\n\t\t\t\t\t\tprintf(\"\\n\");\n#endif\n\n\t\t\t\t\t\t// Unpack UASTC\n\t\t\t\t\t\tbasist::unpacked_uastc_block unpacked_uastc_blk;\n\t\t\t\t\t\tunpack_uastc(encoded_uastc_blk, unpacked_uastc_blk, false);\n\n\t\t\t\t\t\tcolor_rgba unpacked_uastc_block_pixels[4][4];\n\t\t\t\t\t\tbool success = basist::unpack_uastc(unpacked_uastc_blk, (basist::color32*) & unpacked_uastc_block_pixels[0][0], false);\n\t\t\t\t\t\t(void)success;\n\t\t\t\t\t\tassert(success);\n\n\t\t\t\t\t\tuastc_img.set_block_clipped(&unpacked_uastc_block_pixels[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\tconst uint32_t best_mode = unpacked_uastc_blk.m_mode;\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::lock_guard<std::mutex> lck(mode_hist_mutex);\n\t\t\t\t\t\t\tassert(best_mode < basist::TOTAL_UASTC_MODES);\n\t\t\t\t\t\t\tif (best_mode < basist::TOTAL_UASTC_MODES)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmode_hist[best_mode]++;\n\t\t\t\t\t\t\t\toverall_mode_hist[best_mode]++;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (basist::g_uastc_mode_has_etc1_bias[best_mode])\n\t\t\t\t\t\t\t\tetc1_hint_hist[unpacked_uastc_blk.m_etc1_bias]++;\n\n\t\t\t\t\t\t\ttotal_bc1_hint0s += unpacked_uastc_blk.m_bc1_hint0;\n\t\t\t\t\t\t\ttotal_bc1_hint1s += unpacked_uastc_blk.m_bc1_hint1;\n\t\t\t\t\t\t\ttotal_bc1_hint01s += (unpacked_uastc_blk.m_bc1_hint0 || unpacked_uastc_blk.m_bc1_hint1);\n\n\t\t\t\t\t\t\tetc1_inten_hist[unpacked_uastc_blk.m_etc1_inten0]++;\n\t\t\t\t\t\t\tetc1_inten_hist[unpacked_uastc_blk.m_etc1_inten1]++;\n\n\t\t\t\t\t\t\tetc1_flip_hist[unpacked_uastc_blk.m_etc1_flip]++;\n\t\t\t\t\t\t\tetc1_diff_hist[unpacked_uastc_blk.m_etc1_diff]++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Transcode to BC1\n\t\t\t\t\t\tcolor_rgba tblock_bc1[4][4];\n\n\t\t\t\t\t\tuint8_t tbc1_block[8];\n\t\t\t\t\t\ttranscode_uastc_to_bc1(encoded_uastc_blk, tbc1_block, false);\n\t\t\t\t\t\tunpack_block(texture_format::cBC1, tbc1_block, &tblock_bc1[0][0]);\n\t\t\t\t\t\tbc1_img.set_block_clipped(&tblock_bc1[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\t// Transcode to BC7\n\t\t\t\t\t\tbasist::bc7_optimization_results best_bc7_results;\n\t\t\t\t\t\ttranscode_uastc_to_bc7(unpacked_uastc_blk, best_bc7_results);\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbasist::bc7_block bc7_data;\n\t\t\t\t\t\t\tencode_bc7_block(&bc7_data, &best_bc7_results);\n\n\t\t\t\t\t\t\tcolor_rgba decoded_bc7_blk[4][4];\n\t\t\t\t\t\t\tunpack_block(texture_format::cBC7, &bc7_data, &decoded_bc7_blk[0][0]);\n\n\t\t\t\t\t\t\tbc7_img.set_block_clipped(&decoded_bc7_blk[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\t\t// Compute partition visualization image\n\t\t\t\t\t\t\tfor (uint32_t y = 0; y < 4; y++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (uint32_t x = 0; x < 4; x++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32_t part = 0;\n\t\t\t\t\t\t\t\t\tswitch (best_bc7_results.m_mode)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcase 7:\n\t\t\t\t\t\t\t\t\t\tpart = basist::g_bc7_partition2[best_bc7_results.m_partition * 16 + x + y * 4];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\tpart = basist::g_bc7_partition3[best_bc7_results.m_partition * 16 + x + y * 4];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcolor_rgba c(0, 255, 0, 255);\n\t\t\t\t\t\t\t\t\tif (part == 1)\n\t\t\t\t\t\t\t\t\t\tc.set(255, 0, 0, 255);\n\t\t\t\t\t\t\t\t\telse if (part == 2)\n\t\t\t\t\t\t\t\t\t\tc.set(0, 0, 255, 255);\n\n\t\t\t\t\t\t\t\t\tpart_img.set_clipped(block_x * 4 + x, block_y * 4 + y, c);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool high_quality = false;\n\n\t\t\t\t\t\t// Transcode UASTC->BC3\n\t\t\t\t\t\tuint8_t ublock_bc3[16];\n\t\t\t\t\t\ttranscode_uastc_to_bc3(encoded_uastc_blk, ublock_bc3, high_quality);\n\t\t\t\t\t\tcolor_rgba ublock_bc3_unpacked[4][4];\n\t\t\t\t\t\tunpack_block(texture_format::cBC3, &ublock_bc3, &ublock_bc3_unpacked[0][0]);\n\t\t\t\t\t\tbc3_img.set_block_clipped(&ublock_bc3_unpacked[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\t// Transcode UASTC->R11\n\t\t\t\t\t\tuint8_t ublock_eac_r11[8];\n\t\t\t\t\t\ttranscode_uastc_to_etc2_eac_r11(encoded_uastc_blk, ublock_eac_r11, high_quality, 0);\n\t\t\t\t\t\tcolor_rgba ublock_eac_r11_unpacked[4][4];\n\t\t\t\t\t\tfor (uint32_t y = 0; y < 4; y++)\n\t\t\t\t\t\t\tfor (uint32_t x = 0; x < 4; x++)\n\t\t\t\t\t\t\t\tublock_eac_r11_unpacked[y][x].set(0, 0, 0, 255);\n\t\t\t\t\t\tunpack_block(texture_format::cETC2_R11_EAC, &ublock_eac_r11, &ublock_eac_r11_unpacked[0][0]);\n\t\t\t\t\t\teac_r11_img.set_block_clipped(&ublock_eac_r11_unpacked[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\t// Transcode UASTC->RG11\n\t\t\t\t\t\tuint8_t ublock_eac_rg11[16];\n\t\t\t\t\t\ttranscode_uastc_to_etc2_eac_rg11(encoded_uastc_blk, ublock_eac_rg11, high_quality, 0, 1);\n\t\t\t\t\t\tcolor_rgba ublock_eac_rg11_unpacked[4][4];\n\t\t\t\t\t\tfor (uint32_t y = 0; y < 4; y++)\n\t\t\t\t\t\t\tfor (uint32_t x = 0; x < 4; x++)\n\t\t\t\t\t\t\t\tublock_eac_rg11_unpacked[y][x].set(0, 0, 0, 255);\n\t\t\t\t\t\tunpack_block(texture_format::cETC2_RG11_EAC, &ublock_eac_rg11, &ublock_eac_rg11_unpacked[0][0]);\n\t\t\t\t\t\teac_rg11_img.set_block_clipped(&ublock_eac_rg11_unpacked[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\t// ETC1\n\t\t\t\t\t\tetc_block unpacked_etc1;\n\t\t\t\t\t\ttranscode_uastc_to_etc1(encoded_uastc_blk, &unpacked_etc1);\n\t\t\t\t\t\tcolor_rgba unpacked_etc1_block[16];\n\t\t\t\t\t\tunpack_etc1(unpacked_etc1, unpacked_etc1_block);\n\t\t\t\t\t\tetc1_img.set_block_clipped(unpacked_etc1_block, block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\t// ETC1 Y\n\t\t\t\t\t\tetc_block unpacked_etc1_g;\n\n\t\t\t\t\t\ttranscode_uastc_to_etc1(encoded_uastc_blk, &unpacked_etc1_g, 1);\n\n\t\t\t\t\t\tcolor_rgba unpacked_etc1_g_block[16];\n\t\t\t\t\t\tunpack_etc1(unpacked_etc1_g, unpacked_etc1_g_block);\n\t\t\t\t\t\tetc1_g_img.set_block_clipped(unpacked_etc1_g_block, block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\t// ETC2\n\t\t\t\t\t\tetc2_rgba_block unpacked_etc2;\n\t\t\t\t\t\ttranscode_uastc_to_etc2_rgba(encoded_uastc_blk, &unpacked_etc2);\n\n\t\t\t\t\t\tcolor_rgba unpacked_etc2_block[16];\n\t\t\t\t\t\tunpack_block(texture_format::cETC2_RGBA, &unpacked_etc2, unpacked_etc2_block);\n\t\t\t\t\t\tetc2_img.set_block_clipped(unpacked_etc2_block, block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\t// UASTC->ASTC\n\t\t\t\t\t\tuint32_t tastc_data[4];\n\n\t\t\t\t\t\ttranscode_uastc_to_astc(encoded_uastc_blk, tastc_data);\n\n\t\t\t\t\t\tcolor_rgba decoded_tastc_block[4][4];\n                        clear_obj(decoded_tastc_block);\n\t\t\t\t\t\t//basisu_astc::astc::decompress((uint8_t*)decoded_tastc_block, (uint8_t*)&tastc_data, false, 4, 4);\n\n\t\t\t\t\t\tuastc2_img.set_block_clipped(&decoded_tastc_block[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\t\tfor (uint32_t y = 0; y < 4; y++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (uint32_t x = 0; x < 4; x++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (decoded_tastc_block[y][x] != unpacked_uastc_block_pixels[y][x])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tprintf(\"UASTC!=ASTC!\\n\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // block_index\n\n\t\t\t\t});\n\n\t\t} // block_index_iter\n\n\t\tjpool.wait_for_all();\n\n\t\t{\n\t\t\tsize_t comp_size = 0;\n\t\t\tvoid* pComp_data = tdefl_compress_mem_to_heap(&ublocks[0], ublocks.size() * 16, &comp_size, TDEFL_MAX_PROBES_MASK);// TDEFL_DEFAULT_MAX_PROBES);\n\n\t\t\tsize_t decomp_size;\n\t\t\tvoid* pDecomp_data = tinfl_decompress_mem_to_heap(pComp_data, comp_size, &decomp_size, 0);\n\n\t\t\tif ((decomp_size != ublocks.size() * 16) || (memcmp(pDecomp_data, &ublocks[0], decomp_size) != 0))\n\t\t\t{\n\t\t\t\tprintf(\"Compression or decompression failed!\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tmz_free(pComp_data);\n\t\t\tmz_free(pDecomp_data);\n\n\t\t\tprintf(\"Pre-RDO UASTC size: %u, compressed size: %u, %3.2f bits/texel\\n\",\n\t\t\t\t(uint32_t)ublocks.size() * 16,\n\t\t\t\t(uint32_t)comp_size,\n\t\t\t\tcomp_size * 8.0f / img.get_total_pixels());\n\n\t\t\ttotal_comp_size += comp_size;\n\t\t\ttotal_raw_size += ublocks.size() * 16;\n\t\t}\n\n\t\tbasisu::vector<color_rgba> orig_block_pixels(ublocks.size() * 16);\n\t\tfor (uint32_t block_y = 0; block_y < num_blocks_y; block_y++)\n\t\t\tfor (uint32_t block_x = 0; block_x < num_blocks_x; block_x++)\n\t\t\t\timg.extract_block_clamped(&orig_block_pixels[(block_x + block_y * num_blocks_x) * 16], block_x * 4, block_y * 4, 4, 4);\n\n\t\t// HACK HACK\n\t\tconst uint32_t max_rdo_jobs = 4;\n\t\t\n\t\tchar rdo_fname[256];\n\t\tFILE* pFile = nullptr;\n\t\tfor (uint32_t try_index = 0; try_index < 100; try_index++)\n\t\t{\n\t\t\tsprintf(rdo_fname, \"rdo_%02u_%u.csv\", image_index, try_index);\n\t\t\tpFile = fopen(rdo_fname, \"rb\");\n\t\t\tif (pFile)\n\t\t\t{\n\t\t\t\tfclose(pFile);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tpFile = fopen(rdo_fname, \"w\");\n\t\t\tif (!pFile)\n\t\t\t\tprintf(\"Cannot open CSV file %s\\n\", rdo_fname);\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"Opened CSV file %s\\n\", rdo_fname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (float q = .2f; q <= 10.0f; q += (q >= 1.0f ? .5f : .1f))\n\t\t{\n\t\t\tprintf(\"Q: %f\\n\", q);\n\n\t\t\tuastc_rdo_params p;\n\t\t\tp.m_lambda = q;\n\t\t\tp.m_max_allowed_rms_increase_ratio = 10.0f;\n\t\t\tp.m_skip_block_rms_thresh = 8.0f;\n\t\t\t\n\t\t\tbool rdo_status = uastc_rdo((uint32_t)ublocks.size(), &ublocks[0], &orig_block_pixels[0], p, flags, &jpool, max_rdo_jobs);\n\t\t\tif (!rdo_status)\n\t\t\t{\n\t\t\t\tprintf(\"uastc_rdo() failed!\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (uint32_t block_y = 0; block_y < num_blocks_y; block_y++)\n\t\t\t{\n\t\t\t\tfor (uint32_t block_x = 0; block_x < num_blocks_x; block_x++)\n\t\t\t\t{\n\t\t\t\t\tconst basist::uastc_block& blk = ublocks[block_x + block_y * num_blocks_x];\n\n\t\t\t\t\tcolor_rgba unpacked_block[4][4];\n\t\t\t\t\tif (!basist::unpack_uastc(blk, (basist::color32*)unpacked_block, false))\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"Block unpack failed!\\n\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\n\t\t\t\t\trdo_uastc_img.set_block_clipped(&unpacked_block[0][0], block_x * 4, block_y * 4, 4, 4);\n\n\t\t\t\t\tbasist::bc7_optimization_results best_bc7_results;\n\t\t\t\t\ttranscode_uastc_to_bc7(blk, best_bc7_results);\n\n\t\t\t\t\tbasist::bc7_block bc7_data;\n\t\t\t\t\tencode_bc7_block(&bc7_data, &best_bc7_results);\n\n\t\t\t\t\tcolor_rgba decoded_bc7_blk[4][4];\n\t\t\t\t\tunpack_block(texture_format::cBC7, &bc7_data, &decoded_bc7_blk[0][0]);\n\n\t\t\t\t\trdo_bc7_img.set_block_clipped(&decoded_bc7_blk[0][0], block_x * 4, block_y * 4, 4, 4);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timage_metrics em;\n\t\t\tem.calc(img, rdo_uastc_img, 0, 3);\n\t\t\tem.print(\"RDOUASTC RGB \");\n\n\t\t\tsize_t comp_size = 0;\n\t\t\tvoid* pComp_data = tdefl_compress_mem_to_heap(&ublocks[0], ublocks.size() * 16, &comp_size, TDEFL_MAX_PROBES_MASK);// TDEFL_DEFAULT_MAX_PROBES);\n\n\t\t\tsize_t decomp_size;\n\t\t\tvoid* pDecomp_data = tinfl_decompress_mem_to_heap(pComp_data, comp_size, &decomp_size, 0);\n\n\t\t\tif ((decomp_size != ublocks.size() * 16) || (memcmp(pDecomp_data, &ublocks[0], decomp_size) != 0))\n\t\t\t{\n\t\t\t\tprintf(\"Compression or decompression failed!\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tmz_free(pComp_data);\n\t\t\tmz_free(pDecomp_data);\n\n\t\t\tprintf(\"RDO UASTC size: %u, compressed size: %u, %3.2f bits/texel\\n\",\n\t\t\t\t(uint32_t)ublocks.size() * 16,\n\t\t\t\t(uint32_t)comp_size,\n\t\t\t\tcomp_size * 8.0f / img.get_total_pixels());\n\n\t\t\tif (pFile)\n\t\t\t\tfprintf(pFile, \"%f, %f, %f\\n\", q, comp_size * 8.0f / img.get_total_pixels(), em.m_psnr);\n\t\t}\n\t\tif (pFile)\n\t\t\tfclose(pFile);\n\t\t\n\t\t{\n\t\t\tsize_t comp_size = 0;\n\t\t\tvoid* pComp_data = tdefl_compress_mem_to_heap(&ublocks[0], ublocks.size() * 16, &comp_size, TDEFL_MAX_PROBES_MASK);// TDEFL_DEFAULT_MAX_PROBES);\n\n\t\t\tsize_t decomp_size;\n\t\t\tvoid* pDecomp_data = tinfl_decompress_mem_to_heap(pComp_data, comp_size, &decomp_size, 0);\n\n\t\t\tif ((decomp_size != ublocks.size() * 16) || (memcmp(pDecomp_data, &ublocks[0], decomp_size) != 0))\n\t\t\t{\n\t\t\t\tprintf(\"Compression or decompression failed!\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tmz_free(pComp_data);\n\t\t\tmz_free(pDecomp_data);\n\n\t\t\tprintf(\"RDO UASTC size: %u, compressed size: %u, %3.2f bits/texel\\n\",\n\t\t\t\t(uint32_t)ublocks.size() * 16,\n\t\t\t\t(uint32_t)comp_size,\n\t\t\t\tcomp_size * 8.0f / img.get_total_pixels());\n\n\t\t\ttotal_rdo_comp_size += comp_size;\n\t\t\ttotal_rdo_raw_size += ublocks.size() * 16;\n\t\t\ttotal_comp_blocks += ublocks.size();\n\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\tprintf(\"Total blocks: %u\\n\", total_blocks);\n\t\tprintf(\"Total BC1 hint 0's: %u %3.1f%%\\n\", total_bc1_hint0s, total_bc1_hint0s * 100.0f / total_blocks);\n\t\tprintf(\"Total BC1 hint 1's: %u %3.1f%%\\n\", total_bc1_hint1s, total_bc1_hint1s * 100.0f / total_blocks);\n\t\tprintf(\"Total BC1 hint 01's: %u %3.1f%%\\n\", total_bc1_hint01s, total_bc1_hint01s * 100.0f / total_blocks);\n\t\tprintf(\"Total enc time per block: %f us\\n\", total_enc_time / total_blocks * 1000000.0f);\n\t\tprintf(\"Total bench time per block: %f us\\n\", total_bench_time / total_blocks * 1000000.0f);\n\t\tprintf(\"Total bench2 time per block: %f us\\n\", total_bench2_time / total_blocks * 1000000.0f);\n\n\t\toverall_total_enc_time += total_enc_time;\n\t\toverall_total_bench_time += total_bench_time;\n\t\toverall_total_bench2_time += total_bench2_time;\n\t\toverall_blocks += total_blocks;\n\n\t\tprintf(\"ETC1 inten hist: %u %u %u %u %u %u %u %u\\n\", etc1_inten_hist[0], etc1_inten_hist[1], etc1_inten_hist[2], etc1_inten_hist[3],\n\t\t\tetc1_inten_hist[4], etc1_inten_hist[5], etc1_inten_hist[6], etc1_inten_hist[7]);\n\t\tprintf(\"ETC1 flip hist: %u %u\\n\", etc1_flip_hist[0], etc1_flip_hist[1]);\n\t\tprintf(\"ETC1 diff hist: %u %u\\n\", etc1_diff_hist[0], etc1_diff_hist[1]);\n\n\t\tprintf(\"UASTC mode histogram:\\n\");\n\t\tuint64_t total_hist = 0;\n\t\tfor (uint32_t i = 0; i < basist::TOTAL_UASTC_MODES; i++)\n\t\t\ttotal_hist += mode_hist[i];\n\t\tfor (uint32_t i = 0; i < basist::TOTAL_UASTC_MODES; i++)\n\t\t\tprintf(\"%u: %u %3.2f%%\\n\", i, (uint32_t)mode_hist[i], mode_hist[i] * 100.0f / total_hist);\n\n\t\tchar fn[256];\n\n#if 0\n\t\tfor (uint32_t y = 0; y < img.get_height(); y++)\n\t\t\tfor (uint32_t x = 0; x < img.get_width(); x++)\n\t\t\t{\n\t\t\t\t//static inline uint8_t to_5(uint32_t v) { ; }\n\t\t\t\tcolor_rgba &c = img(x, y);\n\n\t\t\t\tfor (uint32_t i = 0; i < 3; i++)\n\t\t\t\t{\n\t\t\t\t\tconst uint32_t limit = (i == 1) ? 63 : 31;\n\n\t\t\t\t\tuint32_t v = c[i];\n\t\t\t\t\tv = v * limit + 128; v = (uint8_t)((v + (v >> 8)) >> 8);\n\t\t\t\t\tv = (v * 255 + (limit / 2)) / limit;\n\n\t\t\t\t\tc[i] = (uint8_t)v;\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n#endif\n\n\t\tsprintf(fn, \"orig_%02u.png\", image_index);\n\t\tsave_png(fn, img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"orig_a_%02u.png\", image_index);\n\t\tsave_png(fn, img, cImageSaveGrayscale, 3);\n\n\t\tsprintf(fn, \"unpacked_uastc_%02u.png\", image_index);\n\t\tsave_png(fn, uastc_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_uastc_a_%02u.png\", image_index);\n\t\tsave_png(fn, uastc_img, cImageSaveGrayscale, 3);\n\n\t\tsprintf(fn, \"unpacked_rdo_uastc_%02u.png\", image_index);\n\t\tsave_png(fn, rdo_uastc_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_rdo_uastc_a_%02u.png\", image_index);\n\t\tsave_png(fn, rdo_uastc_img, cImageSaveGrayscale, 3);\n\n\t\tsprintf(fn, \"unpacked_uastc2_%02u.png\", image_index);\n\t\tsave_png(fn, uastc2_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_bc7_%02u.png\", image_index);\n\t\tsave_png(fn, bc7_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_bc7_a_%02u.png\", image_index);\n\t\tsave_png(fn, bc7_img, cImageSaveGrayscale, 3);\n\n\t\tsprintf(fn, \"unpacked_rdo_bc7_%02u.png\", image_index);\n\t\tsave_png(fn, rdo_bc7_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_rdo_bc7_a_%02u.png\", image_index);\n\t\tsave_png(fn, rdo_bc7_img, cImageSaveGrayscale, 3);\n\n\t\tsprintf(fn, \"unpacked_opt_bc7_%02u.png\", image_index);\n\t\tsave_png(fn, opt_bc7_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_opt_bc7_a_%02u.png\", image_index);\n\t\tsave_png(fn, opt_bc7_img, cImageSaveGrayscale, 3);\n\n\t\tsprintf(fn, \"unpacked_opt_astc_%02u.png\", image_index);\n\t\tsave_png(fn, opt_astc_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_opt_astc_a_%02u.png\", image_index);\n\t\tsave_png(fn, opt_astc_img, cImageSaveGrayscale, 3);\n\n\t\tsprintf(fn, \"unpacked_bc7enc_%02u.png\", image_index);\n\t\tsave_png(fn, bc7enc_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_bc7enc_a_%02u.png\", image_index);\n\t\tsave_png(fn, bc7enc_img, cImageSaveGrayscale, 3);\n\n\t\tsprintf(fn, \"unpacked_opt_bc1_%02u.png\", image_index);\n\t\tsave_png(fn, opt_bc1_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_opt_bc1_2_%02u.png\", image_index);\n\t\tsave_png(fn, opt_bc1_2_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_tbc1_%02u.png\", image_index);\n\t\tsave_png(fn, bc1_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_bc3_%02u.png\", image_index);\n\t\tsave_png(fn, bc3_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_eac_r11_%02u.png\", image_index);\n\t\tsave_png(fn, eac_r11_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_eac_rg11_%02u.png\", image_index);\n\t\tsave_png(fn, eac_rg11_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_bc3_a_%02u.png\", image_index);\n\t\tsave_png(fn, bc3_img, cImageSaveGrayscale, 3);\n\n\t\tsprintf(fn, \"part_vis_%02u.png\", image_index);\n\t\tsave_png(fn, part_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_etc1_%02u.png\", image_index);\n\t\tsave_png(fn, etc1_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_etc1_g_%02u.png\", image_index);\n\t\tsave_png(fn, etc1_g_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_etc2_%02u.png\", image_index);\n\t\tsave_png(fn, etc2_img, cImageSaveIgnoreAlpha);\n\n\t\tsprintf(fn, \"unpacked_etc2_a_%02u.png\", image_index);\n\t\tsave_png(fn, etc2_img, cImageSaveGrayscale, 3);\n\n\t\timage_metrics em;\n\n\t\t// UASTC\n\t\tem.calc(img, uastc_img, 0, 3);\n\t\tem.print(\"UASTC RGB  \");\n\t\ttotal_uastc_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, uastc_img, 3, 1);\n\t\tem.print(\"UASTC A    \");\n\t\tif (img_has_alpha)\n\t\t\ttotal_uastc_a_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, uastc_img, 0, 4);\n\t\tem.print(\"UASTC RGBA \");\n\t\ttotal_uastc_rgba_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t// RDO UASTC\n\t\tem.calc(img, rdo_uastc_img, 0, 3);\n\t\tem.print(\"RDOUASTC RGB \");\n\t\ttotal_rdo_uastc_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, rdo_uastc_img, 3, 1);\n\t\tem.print(\"RDOUASTC A \");\n\t\tif (img_has_alpha)\n\t\t\ttotal_rdo_uastc_a_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, rdo_uastc_img, 0, 4);\n\t\tem.print(\"RDOUASTC RGBA \");\n\t\ttotal_rdo_uastc_rgba_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t// UASTC2 \n\t\tem.calc(img, uastc2_img, 0, 3);\n\t\tem.print(\"UASTC2 RGB \");\n\t\ttotal_uastc2_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, uastc2_img, 3, 1);\n\t\tem.print(\"UASTC2 A   \");\n\t\tif (img_has_alpha)\n\t\t\ttotal_uastc2_a_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, uastc2_img, 0, 4);\n\t\tem.print(\"UASTC2 RGBA \");\n\t\ttotal_uastc2_rgba_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t// BC7\n\t\tem.calc(img, bc7_img, 0, 3);\n\t\tem.print(\"BC7 RGB    \");\n\t\ttotal_bc7_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, bc7_img, 3, 1);\n\t\tem.print(\"BC7 A      \");\n\t\tif (img_has_alpha)\n\t\t\ttotal_bc7_a_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, bc7_img, 0, 4);\n\t\tem.print(\"BC7 RGBA   \");\n\t\ttotal_bc7_rgba_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t// RDO BC7\n\t\tem.calc(img, rdo_bc7_img, 0, 3);\n\t\tem.print(\"RDOBC7 RGB \");\n\t\ttotal_rdo_bc7_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, rdo_bc7_img, 3, 1);\n\t\tem.print(\"RDOBC7 A   \");\n\t\tif (img_has_alpha)\n\t\t\ttotal_rdo_bc7_a_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, rdo_bc7_img, 0, 4);\n\t\tem.print(\"RDOBC7 RGBA \");\n\t\ttotal_rdo_bc7_rgba_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n#if 0\n\t\t// OBC7\n\t\tem.calc(img, opt_bc7_img, 0, 3);\n\t\tem.print(\"OBC7 RGB   \");\n\t\ttotal_obc7_psnr += basisu::minimum(99.0f, em.m_psnr);\n\n\t\tem.calc(img, opt_bc7_img, 3, 1);\n\t\tem.print(\"OBC7 A     \");\n\t\tif (img_has_alpha)\n\t\t\ttotal_obc7_a_psnr += basisu::minimum(99.0f, em.m_psnr);\n\n\t\tem.calc(img, opt_bc7_img, 0, 4);\n\t\tem.print(\"OBC7 RGBA  \");\n\t\ttotal_obc7_rgba_psnr += basisu::minimum(99.0f, em.m_psnr);\n\n\t\t// OASTC\n\t\tem.calc(img, opt_astc_img, 0, 3);\n\t\tem.print(\"OASTC RGB   \");\n\t\ttotal_oastc_psnr += basisu::minimum(99.0f, em.m_psnr);\n\n\t\tem.calc(img, opt_astc_img, 3, 1);\n\t\tem.print(\"OASTC A     \");\n\t\tif (img_has_alpha)\n\t\t\ttotal_oastc_a_psnr += basisu::minimum(99.0f, em.m_psnr);\n\n\t\tem.calc(img, opt_astc_img, 0, 4);\n\t\tem.print(\"OASTC RGBA  \");\n\t\ttotal_oastc_rgba_psnr += basisu::minimum(99.0f, em.m_psnr);\n#endif\n\n\t\t// bc7enc\n\t\tem.calc(img, bc7enc_img, 0, 3);\n\t\tem.print(\"BC7ENC RGB  \");\n\t\ttotal_bc7enc_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, bc7enc_img, 3, 1);\n\t\tem.print(\"BC7ENC A    \");\n\t\tif (img_has_alpha)\n\t\t\ttotal_bc7enc_a_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, bc7enc_img, 0, 4);\n\t\tem.print(\"BC7ENC RGBA \");\n\t\ttotal_bc7enc_rgba_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n#if 1\n\t\t// OBC1\n\t\tem.calc(img, opt_bc1_img, 0, 3);\n\t\tem.print(\"OBC1 RGB   \");\n\t\ttotal_obc1_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\t\ttotal_obc1_psnr_sq += (float)(basisu::minimum<double>(99.0f, em.m_psnr) * basisu::minimum<double>(99.0f, em.m_psnr));\n#endif\n\t\t\t\t\n\t\tem.calc(img, opt_bc1_2_img, 0, 3);\n\t\tem.print(\"OBC1 2 RGB \");\n\t\ttotal_obc1_2_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\t\ttotal_obc1_2_psnr_sq += (float)(basisu::minimum<double>(99.0f, em.m_psnr) * basisu::minimum<double>(99.0f, em.m_psnr));\n\n\t\tem.calc(img, bc1_img, 0, 3);\n\t\tem.print(\"BC1 RGB    \");\n\t\ttotal_bc1_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\t\ttotal_bc1_psnr_sq += (float)(basisu::minimum<double>(99.0f, em.m_psnr) * basisu::minimum<double>(99.0f, em.m_psnr));\n\n\t\t// ETC1\n\t\tem.calc(img, etc1_img, 0, 3);\n\t\tem.print(\"ETC1 RGB   \");\n\t\ttotal_etc1_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, etc1_img, 0, 0);\n\t\tem.print(\"ETC1 Y     \");\n\t\ttotal_etc1_y_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t// ETC1\n\t\tem.calc(img, etc1_g_img, 1, 1);\n\t\tem.print(\"ETC1 G     \");\n\t\ttotal_etc1_g_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t// ETC2\n\t\tem.calc(img, etc2_img, 0, 3);\n\t\tem.print(\"ETC2 RGB   \");\n\t\ttotal_etc2_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, etc2_img, 3, 1);\n\t\tem.print(\"ETC2 A     \");\n\t\tif (img_has_alpha)\n\t\t\ttotal_etc2_a_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, etc2_img, 0, 4);\n\t\tem.print(\"ETC2 RGBA  \");\n\t\ttotal_etc2_rgba_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t// BC3\n\t\tem.calc(img, bc3_img, 0, 3);\n\t\tem.print(\"BC3 RGB    \");\n\t\ttotal_bc3_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, bc3_img, 3, 1);\n\t\tem.print(\"BC3 A      \");\n\t\tif (img_has_alpha)\n\t\t\ttotal_bc3_a_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tem.calc(img, bc3_img, 0, 4);\n\t\tem.print(\"BC3 RGBA   \");\n\t\ttotal_bc3_rgba_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t// EAC R11\n\t\tem.calc(img, eac_r11_img, 0, 1);\n\t\tem.print(\"EAC R11    \");\n\t\ttotal_eac_r11_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t// EAC RG11\n\t\tem.calc(img, eac_rg11_img, 0, 2);\n\t\tem.print(\"EAC RG11   \");\n\t\ttotal_eac_rg11_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\tconst uint32_t width = num_blocks_x * 4;\n\t\tconst uint32_t height = num_blocks_y * 4;\n\t\tif (is_pow2(width) && is_pow2(height))\n\t\t{\n\t\t\tpvrtc4_image pi(width, height);\n\n\t\t\ttranscode_uastc_to_pvrtc1_4_rgba(&ublocks[0], pi.get_blocks().get_ptr(), num_blocks_x, num_blocks_y, false);\n\n\t\t\tpi.deswizzle();\n\n\t\t\t//pi.map_all_pixels(img, perceptual, false);\n\n\t\t\timage pi_unpacked;\n\t\t\tpi.unpack_all_pixels(pi_unpacked);\n\n#if 0\n\t\t\tsprintf(fn, \"unpacked_pvrtc1_rgb_before_%02u.png\", image_index);\n\t\t\tsave_png(fn, pi_unpacked, cImageSaveIgnoreAlpha);\n\n\t\t\tem.calc(img, pi_unpacked, 0, 3);\n\t\t\tem.print(\"PVRTC1 RGB Before \");\n\n\t\t\tfor (uint32_t pass = 0; pass < 1; pass++)\n\t\t\t{\n\t\t\t\tfor (uint32_t by = 0; by < num_blocks_y; by++)\n\t\t\t\t{\n\t\t\t\t\tfor (uint32_t bx = 0; bx < num_blocks_x; bx++)\n\t\t\t\t\t{\n\t\t\t\t\t\tpi.local_endpoint_optimization_opaque(bx, by, img, perceptual, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//pi.map_all_pixels(img, perceptual, false);\n\n\t\t\tpi.unpack_all_pixels(pi_unpacked);\n#endif\n\n\t\t\tsprintf(fn, \"unpacked_pvrtc1_%02u.png\", image_index);\n\t\t\tsave_png(fn, pi_unpacked, cImageSaveIgnoreAlpha);\n\n\t\t\tsprintf(fn, \"unpacked_pvrtc1_a_%02u.png\", image_index);\n\t\t\tsave_png(fn, pi_unpacked, cImageSaveGrayscale, 3);\n\n\t\t\tem.calc(img, pi_unpacked, 0, 3);\n\t\t\tem.print(\"PVRTC1 After RGB  \");\n\t\t\ttotal_pvrtc1_rgb_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t\tem.calc(img, pi_unpacked, 3, 1);\n\t\t\tem.print(\"PVRTC1 After A    \");\n\t\t\ttotal_pvrtc1_a_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t\tem.calc(img, pi_unpacked, 0, 4);\n\t\t\tem.print(\"PVRTC1 After RGBA \");\n\t\t\ttotal_pvrtc1_rgba_psnr += (float)basisu::minimum<double>(99.0f, em.m_psnr);\n\n\t\t\ttotal_pvrtc1_images++;\n\t\t}\n\n\t\tprintf(\"ETC1 hint histogram:\\n\");\n\t\tfor (uint32_t i = 0; i < 32; i++)\n\t\t\tprintf(\"%u \", etc1_hint_hist[i]);\n\t\tprintf(\"\\n\");\n\n\t\ttotal_images++;\n\t\tif (img_has_alpha)\n\t\t\ttotal_a_images++;\n\n\t} // image_index\n\n\tprintf(\"Total time: %f secs\\n\", otm.get_elapsed_secs());\n\t\n\tprintf(\"Total Non-RDO UASTC size: %llu, compressed size: %llu, %3.2f bits/texel\\n\",\n\t\t(unsigned long long)total_raw_size,\n\t\t(unsigned long long)total_comp_size,\n\t\ttotal_comp_size * 8.0f / (total_comp_blocks * 16));\n\n\tprintf(\"Total RDO UASTC size: %llu, compressed size: %llu, %3.2f bits/texel\\n\",\n\t\t(unsigned long long)total_rdo_raw_size,\n\t\t(unsigned long long)total_rdo_comp_size,\n\t\ttotal_rdo_comp_size * 8.0f / (total_comp_blocks * 16));\n\n\tprintf(\"Overall enc time per block: %f us\\n\", overall_total_enc_time / overall_blocks * 1000000.0f);\n\tprintf(\"Overall bench time per block: %f us\\n\", overall_total_bench_time / overall_blocks * 1000000.0f);\n\tprintf(\"Overall bench2 time per block: %f us\\n\", overall_total_bench2_time / overall_blocks * 1000000.0f);\n\n\tprintf(\"Overall ASTC mode histogram:\\n\");\n\tuint64_t total_hist = 0;\n\tfor (uint32_t i = 0; i < basist::TOTAL_UASTC_MODES; i++)\n\t\ttotal_hist += overall_mode_hist[i];\n\n\tfor (uint32_t i = 0; i < basist::TOTAL_UASTC_MODES; i++)\n\t\tprintf(\"%u: %u %3.2f%%\\n\", i, (uint32_t)overall_mode_hist[i], overall_mode_hist[i] * 100.0f / total_hist);\n\n\tprintf(\"Total images: %u, total images with alpha: %u, total PVRTC1 images: %u\\n\", total_images, total_a_images, total_pvrtc1_images);\n\n\tif (!total_a_images)\n\t\ttotal_a_images = 1;\n\n\tprintf(\"Avg UASTC RGB PSNR:    %f, A PSNR: %f, RGBA PSNR: %f\\n\", total_uastc_psnr / total_images, total_uastc_a_psnr / total_a_images, total_uastc_rgba_psnr / total_images);\n\tprintf(\"Avg UASTC2 RGB PSNR:   %f, A PSNR: %f, RGBA PSNR: %f\\n\", total_uastc2_psnr / total_images, total_uastc2_a_psnr / total_a_images, total_uastc2_rgba_psnr / total_images);\n\tprintf(\"Avg RDO UASTC RGB PSNR: %f, A PSNR: %f, RGBA PSNR: %f\\n\", total_rdo_uastc_psnr / total_images, total_rdo_uastc_a_psnr / total_a_images, total_rdo_uastc_rgba_psnr / total_images);\n\tprintf(\"Avg BC7 RGB PSNR:      %f, A PSNR: %f, RGBA PSNR: %f\\n\", total_bc7_psnr / total_images, total_bc7_a_psnr / total_a_images, total_bc7_rgba_psnr / total_images);\n\tprintf(\"Avg RDO BC7 RGB PSNR:  %f, A PSNR: %f, RGBA PSNR: %f\\n\", total_rdo_bc7_psnr / total_images, total_rdo_bc7_a_psnr / total_a_images, total_rdo_bc7_rgba_psnr / total_images);\n\t//printf(\"Avg Opt BC7 RGB PSNR:  %f, A PSNR: %f, RGBA PSNR: %f\\n\", total_obc7_psnr / total_images, total_obc7_a_psnr / total_a_images, total_obc7_rgba_psnr / total_images);\n\t//printf(\"Avg Opt ASTC RGB PSNR: %f, A PSNR: %f, RGBA PSNR: %f\\n\", total_oastc_psnr / total_images, total_oastc_a_psnr / total_a_images, total_oastc_rgba_psnr / total_images);\n\tprintf(\"Avg BC7ENC RGB PSNR:   %f, A PSNR: %f, RGBA PSNR: %f\\n\", total_bc7enc_psnr / total_images, total_bc7enc_a_psnr / total_a_images, total_bc7enc_rgba_psnr / total_images);\n\n\tprintf(\"Avg Opt BC1 PSNR: %f, std dev: %f\\n\", total_obc1_psnr / total_images, sqrtf(basisu::maximum(0.0f, (total_obc1_psnr_sq / total_images) - (total_obc1_psnr / total_images) * (total_obc1_psnr / total_images))));\n\n\tprintf(\"Avg Opt BC1 2 PSNR: %f, std dev: %f\\n\", total_obc1_2_psnr / total_images, sqrtf(basisu::maximum(0.0f, (total_obc1_2_psnr_sq / total_images) - (total_obc1_2_psnr / total_images) * (total_obc1_2_psnr / total_images))));\n\n\tprintf(\"Avg BC1 PSNR: %f, std dev: %f\\n\", total_bc1_psnr / total_images, sqrtf(basisu::maximum(0.0f, (total_bc1_psnr_sq / total_images) - (total_bc1_psnr / total_images) * (total_bc1_psnr / total_images))));\n\n\tprintf(\"Avg ETC1 RGB PSNR: %f\\n\", total_etc1_psnr / total_images);\n\tprintf(\"Avg ETC1 Y PSNR: %f\\n\", total_etc1_y_psnr / total_images);\n\tprintf(\"Avg ETC1 G PSNR: %f\\n\", total_etc1_g_psnr / total_images);\n\n\tprintf(\"Avg ETC2 RGB PSNR: %f\\n\", total_etc2_psnr / total_images);\n\tprintf(\"Avg ETC2 A PSNR: %f\\n\", total_etc2_a_psnr / total_a_images);\n\tprintf(\"Avg ETC2 RGBA PSNR: %f\\n\", total_etc2_rgba_psnr / total_images);\n\n\tprintf(\"Avg BC3 RGB PSNR: %f\\n\", total_bc3_psnr / total_images);\n\tprintf(\"Avg BC3 A PSNR: %f\\n\", total_bc3_a_psnr / total_a_images);\n\tprintf(\"Avg BC3 RGBA PSNR: %f\\n\", total_bc3_rgba_psnr / total_images);\n\n\tprintf(\"Avg EAC R11 PSNR: %f\\n\", total_eac_r11_psnr / total_images);\n\tprintf(\"Avg EAC RG11 PSNR: %f\\n\", total_eac_rg11_psnr / total_images);\n\n\tif (total_pvrtc1_images)\n\t{\n\t\tprintf(\"Avg PVRTC1 RGB PSNR: %f\\n\", total_pvrtc1_rgb_psnr / total_pvrtc1_images);\n\t\tprintf(\"Avg PVRTC1 A PSNR: %f\\n\", total_pvrtc1_a_psnr / total_pvrtc1_images);\n\t\tprintf(\"Avg PVRTC1 RGBA PSNR: %f\\n\", total_pvrtc1_rgba_psnr / total_pvrtc1_images);\n\t}\n\n\treturn true;\n#endif\n}\n\nstatic uint32_t compute_miniz_compressed_size(const char* pFilename, uint32_t &orig_size)\n{\n\torig_size = 0;\n\n\tuint8_vec buf;\n\tif (!read_file_to_vec(pFilename, buf))\n\t\treturn 0;\n\n\tif (!buf.size())\n\t\treturn 0;\n\n\torig_size = buf.size();\n\n\tsize_t comp_size = 0;\n\tvoid* pComp_data = tdefl_compress_mem_to_heap(&buf[0], buf.size(), &comp_size, TDEFL_MAX_PROBES_MASK);// TDEFL_DEFAULT_MAX_PROBES);\n\n\tmz_free(pComp_data);\n\n\treturn (uint32_t)comp_size;\n}\n\nstatic bool compsize_mode(command_line_params& opts)\n{\n\tif (opts.m_input_filenames.size() != 1)\n\t{\n\t\terror_printf(\"Must specify a filename using -file\\n\");\n\t\treturn false;\n\t}\n\n\tuint32_t orig_size;\n\tuint32_t comp_size = compute_miniz_compressed_size(opts.m_input_filenames[0].c_str(), orig_size);\n\tprintf(\"Original file size: %u bytes\\n\", orig_size);\n\tprintf(\"miniz compressed size: %u bytes\\n\", comp_size);\n\n\treturn true;\n}\n\nconst struct test_file\n{\n\tconst char* m_pFilename;\n\tuint32_t m_etc1s_size;\n\tfloat m_etc1s_psnr;\n\tfloat m_uastc_psnr;\n\t\n\tuint32_t m_etc1s_128_size;\n    float m_etc1s_128_psnr;\n} g_test_files[] = \n{\n\t{ \"black_1x1.png\", 189, 100.0f, 100.0f, 189, 100.0f },\n\t{ \"kodim01.png\", 30993, 27.40f, 44.14f, 58354, 30.356064f },\n\t{ \"kodim02.png\", 28529, 32.20f, 41.06f, 51411, 34.713940f },\n\t{ \"kodim03.png\", 23411, 32.57f, 44.87f, 49282, 36.709675f },\n\t{ \"kodim04.png\", 28256, 31.76f, 43.02f, 57003, 34.864861f },\n\t{ \"kodim05.png\", 32646, 25.94f, 40.28f, 65731, 29.935091f },\n\t{ \"kodim06.png\", 27336, 28.66f, 44.57f, 54963, 32.294220f },\n\t{ \"kodim07.png\", 26618, 31.51f, 43.94f, 53352, 35.576595f },\n\t{ \"kodim08.png\", 31133, 25.28f, 41.15f, 63347, 29.509914f },\n\t{ \"kodim09.png\", 24777, 32.05f, 45.85f, 51355, 35.985966f },\n\t{ \"kodim10.png\", 27247, 32.20f, 45.77f, 54291, 36.395000f },\n\t{ \"kodim11.png\", 26579, 29.22f, 43.68f, 55491, 33.468971f },\n\t{ \"kodim12.png\", 25102, 32.96f, 46.77f, 51465, 36.722233f },\n\t{ \"kodim13.png\", 31604, 24.25f, 41.25f, 62629, 27.588623f },\n\t{ \"kodim14.png\", 31162, 27.81f, 39.65f, 62866, 31.206463f },\n\t{ \"kodim15.png\", 25528, 31.26f, 42.87f, 53343, 35.026314f },\n\t{ \"kodim16.png\", 26894, 32.21f, 47.78f, 51325, 35.555458f },\n\t{ \"kodim17.png\", 29334, 31.40f, 45.66f, 55630, 35.909283f },\n\t{ \"kodim18.png\", 30929, 27.46f, 41.54f, 62421, 31.348171f },\n\t{ \"kodim19.png\", 27889, 29.69f, 44.95f, 55055, 33.613987f },\n\t{ \"kodim20.png\", 21104, 31.30f, 45.31f, 47136, 35.759407f },\n\t{ \"kodim21.png\", 25943, 28.53f, 44.45f, 54768, 32.415817f },\n\t{ \"kodim22.png\", 29277, 29.85f, 42.63f, 60889, 33.495415f },\n\t{ \"kodim23.png\", 23550, 31.69f, 45.11f, 53774, 36.223492f },\n\t{ \"kodim24.png\", 29613, 26.75f, 40.61f, 59014, 31.522869f },\n\t{ \"white_1x1.png\", 189, 100.0f, 100.0f, 189, 100.000000f },\n\t{ \"wikipedia.png\", 38961, 24.10f, 30.47f, 69558, 27.630802f },\n\t{ \"alpha0.png\", 766, 100.0f, 56.16f, 747, 100.000000f }\n};\nconst uint32_t TOTAL_TEST_FILES = sizeof(g_test_files) / sizeof(g_test_files[0]);\n\nstatic bool test_mode_ldr(command_line_params& opts)\n{\n\tuint32_t total_mismatches = 0;\n\n\t// TODO: Record min/max/avgs\n\t// TODO: Add another ETC1S quality level\n\n\t// Minor differences in how floating point code is optimized can result in slightly different generated files.\n#ifdef USE_TIGHTER_TEST_TOLERANCES\n\tconst float ETC1S_PSNR_THRESHOLD = .125f;\n\tconst float UASTC_PSNR_THRESHOLD = .125f;\n#else\n\tconst float ETC1S_PSNR_THRESHOLD = .3f;\n\tconst float UASTC_PSNR_THRESHOLD = .3f;\n#endif\n\tconst float ETC1S_FILESIZE_THRESHOLD = .045f;\n\n\tfor (uint32_t i = 0; i < TOTAL_TEST_FILES; i++)\n\t{\n\t\tstd::string filename(opts.m_test_file_dir);\n\t\tif (filename.size())\n\t\t{\n\t\t\tfilename.push_back('/');\n\t\t}\n\t\tfilename += std::string(g_test_files[i].m_pFilename);\n\n\t\tbasisu::vector<image> source_images(1);\n\n\t\timage& source_image = source_images[0];\n\t\tif (!load_png(filename.c_str(), source_image))\n\t\t{\n\t\t\terror_printf(\"Failed loading test image \\\"%s\\\"\\n\", filename.c_str());\n\t\t\treturn false;\n\t\t}\n\n\t\tprintf(\"Loaded file \\\"%s\\\", dimemsions %ux%u has alpha: %u\\n\", filename.c_str(), source_image.get_width(), source_image.get_height(), source_image.has_alpha());\n\n\t\timage_stats stats;\n\n\t\tuint32_t flags_and_quality;\n\t\tfloat uastc_rdo_quality = 0.0f;\n\t\tsize_t data_size = 0;\n\n\t\t// Test ETC1S\n\t\tflags_and_quality = (opts.m_comp_params.m_multithreading ? cFlagThreaded : 0) | cFlagPrintStats | cFlagPrintStatus;\n\t\t\n\t\t{\n\t\t\tprintf(\"**** Testing ETC1S non-OpenCL level 1\\n\");\n\n\t\t\t// Level 1\n\t\t\tvoid* pData = basis_compress(source_images, flags_and_quality, uastc_rdo_quality, &data_size, &stats);\n\t\t\tif (!pData)\n\t\t\t{\n\t\t\t\terror_printf(\"basis_compress() failed!\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbasis_free_data(pData);\n\n\t\t\tprintf(\"ETC1S level 1 Size: %u, PSNR: %f\\n\", (uint32_t)data_size, stats.m_basis_rgba_avg_psnr);\n\n\t\t\tfloat file_size_ratio = fabs((data_size / (float)g_test_files[i].m_etc1s_size) - 1.0f);\n\t\t\tif (file_size_ratio > ETC1S_FILESIZE_THRESHOLD)\n\t\t\t{\n\t\t\t\terror_printf(\"Expected ETC1S file size was %u, but got %u instead!\\n\", g_test_files[i].m_etc1s_size, (uint32_t)data_size);\n\t\t\t\ttotal_mismatches++;\n\t\t\t}\n\n\t\t\tif (fabs(stats.m_basis_rgba_avg_psnr - g_test_files[i].m_etc1s_psnr) > ETC1S_PSNR_THRESHOLD)\n\t\t\t{\n\t\t\t\terror_printf(\"Expected ETC1S RGBA Avg PSNR was %f, but got %f instead!\\n\", g_test_files[i].m_etc1s_psnr, stats.m_basis_rgba_avg_psnr);\n\t\t\t\ttotal_mismatches++;\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tprintf(\"**** Testing ETC1S non-OpenCL level 128\\n\");\n\n\t\t\t// Test ETC1S level 128\n\t\t\tflags_and_quality |= 128;\n\n\t\t\tvoid* pData = basis_compress(source_images, flags_and_quality, uastc_rdo_quality, &data_size, &stats);\n\t\t\tif (!pData)\n\t\t\t{\n\t\t\t\terror_printf(\"basis_compress() failed!\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbasis_free_data(pData);\n\n\t\t\tprintf(\"ETC1S level 128 Size: %u, PSNR: %f\\n\", (uint32_t)data_size, stats.m_basis_rgba_avg_psnr);\n\n\t\t\tfloat file_size_ratio = fabs((data_size / (float)g_test_files[i].m_etc1s_128_size) - 1.0f);\n\t\t\tif (file_size_ratio > ETC1S_FILESIZE_THRESHOLD)\n\t\t\t{\n\t\t\t\terror_printf(\"Expected ETC1S file size was %u, but got %u instead!\\n\", g_test_files[i].m_etc1s_128_size, (uint32_t)data_size);\n\t\t\t\ttotal_mismatches++;\n\t\t\t}\n\n\t\t\tif (fabs(stats.m_basis_rgba_avg_psnr - g_test_files[i].m_etc1s_128_psnr) > ETC1S_PSNR_THRESHOLD)\n\t\t\t{\n\t\t\t\terror_printf(\"Expected ETC1S RGBA Avg PSNR was %f, but got %f instead!\\n\", g_test_files[i].m_etc1s_128_psnr, stats.m_basis_rgba_avg_psnr);\n\t\t\t\ttotal_mismatches++;\n\t\t\t}\n\t\t}\n\n\t\tif (opencl_is_available())\n\t\t{\n\t\t\tprintf(\"**** Testing ETC1S OpenCL level 1\\n\");\n\n\t\t\t// Test ETC1S OpenCL level 1\n\t\t\tflags_and_quality = (opts.m_comp_params.m_multithreading ? cFlagThreaded : 0) | cFlagUseOpenCL | cFlagPrintStats | cFlagPrintStatus;\n\n\t\t\tvoid *pData = basis_compress(source_images, flags_and_quality, uastc_rdo_quality, &data_size, &stats);\n\t\t\tif (!pData)\n\t\t\t{\n\t\t\t\terror_printf(\"basis_compress() failed!\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbasis_free_data(pData);\n\n\t\t\tprintf(\"ETC1S+OpenCL Size: %u, PSNR: %f\\n\", (uint32_t)data_size, stats.m_basis_rgba_avg_psnr);\n\n\t\t\tfloat file_size_ratio = fabs((data_size / (float)g_test_files[i].m_etc1s_size) - 1.0f);\n\t\t\tif (file_size_ratio > .04f)\n\t\t\t{\n\t\t\t\terror_printf(\"Expected ETC1S+OpenCL file size was %u, but got %u instead!\\n\", g_test_files[i].m_etc1s_size, (uint32_t)data_size);\n\t\t\t\ttotal_mismatches++;\n\t\t\t}\n\n\t\t\tif (g_test_files[i].m_etc1s_psnr == 100.0f)\n\t\t\t{\n\t\t\t\t// TODO\n\t\t\t\tif (stats.m_basis_rgba_avg_psnr < 69.0f)\n\t\t\t\t{\n\t\t\t\t\terror_printf(\"Expected ETC1S+OpenCL RGBA Avg PSNR was %f, but got %f instead!\\n\", g_test_files[i].m_etc1s_psnr, stats.m_basis_rgba_avg_psnr);\n\t\t\t\t\ttotal_mismatches++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (fabs(stats.m_basis_rgba_avg_psnr - g_test_files[i].m_etc1s_psnr) > .2f)\n\t\t\t{\n\t\t\t\terror_printf(\"Expected ETC1S+OpenCL RGBA Avg PSNR was %f, but got %f instead!\\n\", g_test_files[i].m_etc1s_psnr, stats.m_basis_rgba_avg_psnr);\n\t\t\t\ttotal_mismatches++;\n\t\t\t}\n\t\t}\n\n\t\t// Test UASTC\n\t\t{\n\t\t\tprintf(\"**** Testing UASTC\\n\");\n\n\t\t\tflags_and_quality = (opts.m_comp_params.m_multithreading ? cFlagThreaded : 0) | cFlagUASTC | cFlagPrintStats | cFlagPrintStatus;\n\n\t\t\tvoid* pData = basis_compress(source_images, flags_and_quality, uastc_rdo_quality, &data_size, &stats);\n\t\t\tif (!pData)\n\t\t\t{\n\t\t\t\terror_printf(\"basis_compress() failed!\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbasis_free_data(pData);\n\n\t\t\tprintf(\"UASTC Size: %u, PSNR: %f\\n\", (uint32_t)data_size, stats.m_basis_rgba_avg_psnr);\n\n\t\t\tif (fabs(stats.m_basis_rgba_avg_psnr - g_test_files[i].m_uastc_psnr) > UASTC_PSNR_THRESHOLD)\n\t\t\t{\n\t\t\t\terror_printf(\"Expected UASTC RGBA Avg PSNR was %f, but got %f instead!\\n\", g_test_files[i].m_etc1s_psnr, stats.m_basis_rgba_avg_psnr);\n\t\t\t\ttotal_mismatches++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"Total LDR mismatches: %u\\n\", total_mismatches);\n\n\tbool result = true;\n\tif (total_mismatches)\n\t{\n\t\terror_printf(\"LDR test FAILED\\n\");\n\t\tresult = false;\n\t}\n\telse\n\t{\n\t\tprintf(\"LDR test succeeded\\n\");\n\t}\n\n\treturn result;\n}\n\nconst struct hdr_test_file\n{\n\tconst char* m_pFilename;\n\tfloat m_level_psnr_astc[5];\n\tfloat m_level_psnr_bc6h[5];\n} g_hdr_test_files[] =\n{\n\t{ \"black_1x1.png\",\t\t{ 1000.0f, 1000.0f, 1000.0f, 1000.0f, 1000.0f }, { 1000.0f, 1000.0f, 1000.0f, 1000.0f, 1000.0f } },\n\t{ \"atrium.exr\",\t\t\t{ 58.387924f, 58.976650f, 59.000862f, 58.951488f, 58.898571f }, { 58.103821f, 58.900017f, 58.910744f, 58.876980f, 58.810989f } },\n\t{ \"backyard.exr\",\t\t{ 63.704613f, 63.453190f, 63.600426f, 63.626850f, 63.938366f }, { 62.911961f, 63.353348f, 63.501392f, 63.533562f, 63.823147f } },\n\t{ \"Desk.exr\",\t\t\t{ 50.020317f, 50.580063f, 50.937798f, 51.024494f, 51.315540f }, { 49.944633f, 50.565235f, 50.914314f, 50.999512f, 51.293797f } },\n\t{ \"atrium.exr\",\t\t\t{ 58.387924f, 58.976650f, 59.000862f, 58.951488f, 58.898571f }, { 58.103821f, 58.900017f, 58.910744f, 58.876980f, 58.810989f } },\n\t{ \"yucca.exr\",\t\t\t{ 53.481602f, 53.905769f, 53.954353f, 54.074474f, 54.139977f }, { 53.437008f, 53.883400f, 53.929897f, 54.050571f, 54.117466f } },\n\t{ \"tough.png\",\t\t\t{ 39.680382f, 43.291210f, 43.637939f, 44.180916f, 46.030712f }, { 39.703949f, 43.255989f, 43.590729f, 44.132393f, 46.033344f } },\n\t{ \"kodim03.png\",\t\t{ 51.031773f, 51.275902f, 51.300705f, 51.338562f, 51.355114f }, { 50.982365f, 51.251923f, 51.275295f, 51.315796f, 51.332462f } },\n\t{ \"kodim18.png\",\t\t{ 48.362595f, 48.638092f, 48.610493f, 48.618176f, 48.520008f }, { 48.319820f, 48.635593f, 48.609116f, 48.621853f, 48.520535f } },\n\t{ \"kodim23.png\",\t\t{ 49.796471f, 50.144829f, 50.171085f, 50.325180f, 50.366810f }, { 49.779743f, 50.119869f, 50.147041f, 50.299568f, 50.341846f } }\n};\nconst uint32_t TOTAL_HDR_TEST_FILES = sizeof(g_hdr_test_files) / sizeof(g_hdr_test_files[0]);\n\nstatic bool test_mode_hdr(command_line_params& opts)\n{\n\tBASISU_ASSUME(astc_hdr_codec_options::cMaxLevel == 4);\n\n\tuint32_t total_mismatches = 0;\n\t\t\n#ifdef USE_TIGHTER_TEST_TOLERANCES\n\t// The PSNR's above were created with a MSVC compiled executable, x64. Hopefully this is not too low a threshold.\n\tconst float PSNR_THRESHOLD = .125f;\n#else\n\t// Minor differences in how floating point code is optimized can result in slightly different generated files.\n\tconst float PSNR_THRESHOLD = .3f;\n#endif\n\t\n\tdouble highest_delta = 0.0f;\n\n\tfor (uint32_t i = 0; i < TOTAL_HDR_TEST_FILES; i++)\n\t{\n\t\tstd::string filename(opts.m_test_file_dir);\n\t\tif (filename.size())\n\t\t{\n\t\t\tfilename.push_back('/');\n\t\t}\n\t\tfilename += std::string(g_hdr_test_files[i].m_pFilename);\n\n\t\tbasisu::vector<imagef> source_imagesf(1);\n\n\t\timagef& source_image = source_imagesf[0];\n\t\tif (!load_image_hdr(filename.c_str(), source_image))\n\t\t{\n\t\t\terror_printf(\"Failed loading test image \\\"%s\\\"\\n\", filename.c_str());\n\t\t\treturn false;\n\t\t}\n\n\t\tprintf(\"Loaded file \\\"%s\\\", dimemsions %ux%u\\n\", filename.c_str(), source_image.get_width(), source_image.get_height());\n\t\t\t\t\n\t\tfor (uint32_t uastc_hdr_level = 0; uastc_hdr_level <= 4; uastc_hdr_level++)\n\t\t{\n\t\t\timage_stats stats;\n\n\t\t\tuint32_t flags_and_quality;\n\t\t\tsize_t data_size = 0;\n\n\t\t\tprintf(\"**** Testing UASTC HDR Level %u\\n\", uastc_hdr_level);\n\n\t\t\tflags_and_quality = (opts.m_comp_params.m_multithreading ? cFlagThreaded : 0) | cFlagUASTC;// | cFlagPrintStats | cFlagPrintStatus;\n\t\t\tflags_and_quality |= cFlagHDRLDRImageSRGBToLinearConversion;\n\t\t\tflags_and_quality |= uastc_hdr_level;\n\n\t\t\tvoid* pData = basis_compress(source_imagesf, flags_and_quality, &data_size, &stats);\n\t\t\tif (!pData)\n\t\t\t{\n\t\t\t\terror_printf(\"basis_compress() failed!\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbasis_free_data(pData);\n\n\t\t\tdouble delta1, delta2;\n\n\t\t\tprintf(\"ASTC PSNR: %f (expected %f, delta %f), BC6H PSNR: %f (expected %f, delta %f)\\n\", \n\t\t\t\tstats.m_basis_rgb_avg_psnr, g_hdr_test_files[i].m_level_psnr_astc[uastc_hdr_level], delta1 = fabs(stats.m_basis_rgb_avg_psnr - g_hdr_test_files[i].m_level_psnr_astc[uastc_hdr_level]),\n\t\t\t\tstats.m_basis_rgb_avg_bc6h_psnr, g_hdr_test_files[i].m_level_psnr_bc6h[uastc_hdr_level], delta2 = fabs(stats.m_basis_rgb_avg_bc6h_psnr - g_hdr_test_files[i].m_level_psnr_bc6h[uastc_hdr_level]));\n\n\t\t\thighest_delta = maximum(highest_delta, delta1);\n\t\t\thighest_delta = maximum(highest_delta, delta2);\n\n\t\t\tif (fabs(stats.m_basis_rgb_avg_psnr - g_hdr_test_files[i].m_level_psnr_astc[uastc_hdr_level]) > PSNR_THRESHOLD)\n\t\t\t{\n\t\t\t\terror_printf(\"Expected UASTC HDR RGB Avg PSNR was %f, but got %f instead!\\n\", g_hdr_test_files[i].m_level_psnr_astc[uastc_hdr_level], stats.m_basis_rgb_avg_psnr);\n\t\t\t\ttotal_mismatches++;\n\t\t\t}\n\n\t\t\tif (fabs(stats.m_basis_rgb_avg_bc6h_psnr - g_hdr_test_files[i].m_level_psnr_bc6h[uastc_hdr_level]) > PSNR_THRESHOLD)\n\t\t\t{\n\t\t\t\terror_printf(\"Expected UASTC->BC6H HDR RGB Avg PSNR was %f, but got %f instead!\\n\", g_hdr_test_files[i].m_level_psnr_bc6h[uastc_hdr_level], stats.m_basis_rgb_avg_bc6h_psnr);\n\t\t\t\ttotal_mismatches++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"Total HDR mismatches: %u\\n\", total_mismatches);\n\tprintf(\"Highest delta: %f\\n\", highest_delta);\n\n\tbool result = true;\n\tif (total_mismatches)\n\t{\n\t\terror_printf(\"HDR test FAILED\\n\");\n\t\tresult = false;\n\t}\n\telse\n\t{\n\t\tprintf(\"HDR test succeeded\\n\");\n\t}\n\n\treturn result;\n}\n\nstatic bool clbench_mode(command_line_params& opts)\n{\n\tBASISU_NOTE_UNUSED(opts);\n\t\n\tbool opencl_failed = false;\n\tbool use_cl = basis_benchmark_etc1s_opencl(&opencl_failed);\n\tif (use_cl)\n\t\tprintf(\"OpenCL ETC1S encoding is faster on this machine\\n\");\n\telse\n\t{\n\t\tif (opencl_failed)\n\t\t\tprintf(\"OpenCL failed!\\n\");\n\t\tprintf(\"CPU ETC1S encoding is faster on this machine\\n\");\n\t}\n\n\treturn true;\n}\n\n#ifdef FORCE_SAN_FAILURE\nstatic void force_san_failure()\n{\n\t// Purposely do things that should trigger the address sanitizer\n\tint arr[5] = { 0, 1, 2, 3, 4 };\n\tprintf(\"Out of bounds element: %d\\n\", arr[10]);\n\n\t//uint8_t* p = (uint8_t *)malloc(10);\n\t//p[10] = 99;\n\n\t//uint8_t* p = (uint8_t *)malloc(10);\n\t//free(p);\n\t//p[0] = 99;\n}\n#endif // FORCE_SAN_FAILURE\n\nstatic int main_internal(int argc, const char **argv)\n{\n\tprintf(\"Basis Universal LDR/HDR GPU Texture Compression and Transcoding System v\" BASISU_TOOL_VERSION \"\\nCopyright (C) 2019-2024 Binomial LLC, All rights reserved\\n\");\n\n#ifdef FORCE_SAN_FAILURE\n\tforce_san_failure();\n#endif\n\t\t\n\t//interval_timer tm;\n\t//tm.start();\n\n\t// See if OpenCL support has been disabled. We don't want to parse the command line until the lib is initialized\n\tbool use_opencl = false;\n\tbool opencl_force_serialization = false;\n\t\n\tfor (int i = 1; i < argc; i++)\n\t{\n\t\tif ((strcmp(argv[i], \"-opencl\") == 0) || (strcmp(argv[i], \"-clbench\") == 0))\n\t\t\tuse_opencl = true;\n\t\tif (strcmp(argv[i], \"-opencl_serialize\") == 0)\n\t\t\topencl_force_serialization = true;\n\t}\n\n#ifndef BASISU_SUPPORT_OPENCL\n\tif (use_opencl)\n\t{\n\t\tfprintf(stderr, \"WARNING: -opencl specified, but OpenCL support was not enabled at compile time! With cmake, use -D OPENCL=1. Falling back to CPU compression.\\n\");\n\t}\n#endif\n\n\tbasisu_encoder_init(use_opencl, opencl_force_serialization);\n\t\t\n\t//printf(\"Encoder and transcoder libraries initialized in %3.3f ms\\n\", tm.get_elapsed_ms());\n\t\t\n\tif (argc == 1)\n\t{\n\t\tprint_usage();\n\t\treturn EXIT_FAILURE;\n\t}\n\t\t\n\tcommand_line_params opts;\n\tif (!opts.parse(argc, argv))\n\t{\n\t\t//print_usage();\n\t\treturn EXIT_FAILURE;\n\t}\n\n#if BASISU_SUPPORT_SSE\n\tprintf(\"Using SSE 4.1: %u, Multithreading: %u, Zstandard support: %u, OpenCL: %u\\n\", g_cpu_supports_sse41, (uint32_t)opts.m_comp_params.m_multithreading, basist::basisu_transcoder_supports_ktx2_zstd(), opencl_is_available());\n#else\n\tprintf(\"No SSE, Multithreading: %u, Zstandard support: %u, OpenCL: %u\\n\", (uint32_t)opts.m_comp_params.m_multithreading, basist::basisu_transcoder_supports_ktx2_zstd(), opencl_is_available());\n#endif\n\t\t\n\tif (!opts.process_listing_files())\n\t\treturn EXIT_FAILURE;\n\n\tif (opts.m_mode == cDefault)\n\t{\n\t\tfor (size_t i = 0; i < opts.m_input_filenames.size(); i++)\n\t\t{\n\t\t\tstd::string ext(string_get_extension(opts.m_input_filenames[i]));\n\t\t\tif ((strcasecmp(ext.c_str(), \"basis\") == 0) || (strcasecmp(ext.c_str(), \"ktx\") == 0) || (strcasecmp(ext.c_str(), \"ktx2\") == 0))\n\t\t\t{\n\t\t\t\t// If they haven't specified any modes, and they give us a .basis file, then assume they want to unpack it.\n\t\t\t\topts.m_mode = cUnpack;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool status = false;\n\n\tswitch (opts.m_mode)\n\t{\n\tcase cDefault:\n\tcase cCompress:\n\t\tstatus = compress_mode(opts);\n\t\tbreak;\n\tcase cValidate:\n\tcase cInfo:\n\tcase cUnpack:\n\t\tstatus = unpack_and_validate_mode(opts);\n\t\tbreak;\n\tcase cCompare:\n\t\tstatus = compare_mode(opts);\n\t\tbreak;\n\tcase cHDRCompare:\n\t\tstatus = hdr_compare_mode(opts);\n\t\tbreak;\n\tcase cVersion:\n\t\tstatus = true; // We printed the version at the beginning of main_internal\n\t\tbreak;\n\tcase cBench:\n\t\tstatus = bench_mode(opts);\n\t\tbreak;\n\tcase cCompSize:\n\t\tstatus = compsize_mode(opts);\n\t\tbreak;\n\tcase cTestLDR:\n\t\tstatus = test_mode_ldr(opts);\n\t\tbreak;\n\tcase cTestHDR:\n\t\tstatus = test_mode_hdr(opts);\n\t\tbreak;\n\tcase cCLBench:\n\t\tstatus = clbench_mode(opts);\n\t\tbreak;\n\tcase cSplitImage:\n\t\tstatus = split_image_mode(opts);\n\t\tbreak;\n\tcase cCombineImages:\n\t\tstatus = combine_images_mode(opts);\n\t\tbreak;\n\tcase cTonemapImage:\n\t\tstatus = tonemap_image_mode(opts);\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t\tbreak;\n\t}\n\n\treturn status ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\nint main(int argc, const char** argv)\n{\n#ifdef _WIN32\n\tSetConsoleOutputCP(CP_UTF8);\n#endif\n\n#if defined(DEBUG) || defined(_DEBUG)\n\tprintf(\"DEBUG build\\n\");\n#endif\n#ifdef __SANITIZE_ADDRESS__\n\tprintf(\"Address sanitizer enabled\\n\");\n#endif\n\t\t\n\tint status = EXIT_FAILURE;\n\n#if BASISU_CATCH_EXCEPTIONS\n\ttry\n\t{\n\t\t status = main_internal(argc, argv);\n\t}\n\tcatch (const std::exception &exc)\n\t{\n\t\t fprintf(stderr, \"Fatal error: Caught exception \\\"%s\\\"\\n\", exc.what());\n\t}\n\tcatch (...)\n\t{\n\t\tfprintf(stderr, \"Fatal error: Uncaught exception!\\n\");\n\t}\n#else\n\tstatus = main_internal(argc, argv);\n#endif\n\n\treturn status;\n}\n\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "encoder",
          "type": "tree",
          "content": null
        },
        {
          "name": "encoder_lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "encoder_lvl_vs_perf.png",
          "type": "blob",
          "size": 6.1787109375,
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "format.sh",
          "type": "blob",
          "size": 1.3759765625,
          "content": "#!/bin/bash\n\n# Loops through all text files tracked by Git.\ngit grep -zIl '' |\nwhile IFS= read -rd '' f; do\n    # Exclude some types of files.\n    if [[ $f == *\"proj\" ]]; then\n        continue\n    elif [[ $f == *\"filters\" ]]; then\n        continue\n    elif [[ $f == *\"sln\" ]]; then\n        continue\n    elif [[ $f == *\"json\" ]]; then\n        continue\n    elif [[ $f == *\"min.js\" ]]; then\n        continue\n    elif [[ $f == *\"coder.js\" ]]; then\n        continue\n    fi\n    # Ensures that files are UTF-8 formatted.\n    recode UTF-8 $f 2> /dev/null\n    # Ensures that files have LF line endings.\n    dos2unix $f 2> /dev/null\n    # Ensures that files do not contain a BOM.\n    sed -i '1s/^\\xEF\\xBB\\xBF//' \"$f\"\n    # Ensures that files end with newline characters.\n    tail -c1 < \"$f\" | read -r _ || echo >> \"$f\";\ndone\n\ngit diff > patch.patch\nFILESIZE=$(stat -c%s patch.patch)\nMAXSIZE=5\n\n# If no patch has been generated all is OK, clean up, and exit.\nif (( FILESIZE < MAXSIZE )); then\n    printf \"Files in this commit comply with the formatting rules.\\n\"\n    rm -f patch.patch\n    exit 0\nfi\n\n# A patch has been created, notify the user, clean up, and exit.\nprintf \"\\n*** The following differences were found between the code \"\nprintf \"and the formatting rules:\\n\\n\"\ncat patch.patch\nprintf \"\\n*** Aborting, please fix your commit(s) with 'git commit --amend' or 'git rebase -i <hash>'\\n\"\nrm -f patch.patch\nexit 1\n"
        },
        {
          "name": "test_files",
          "type": "tree",
          "content": null
        },
        {
          "name": "transcoder",
          "type": "tree",
          "content": null
        },
        {
          "name": "webgl",
          "type": "tree",
          "content": null
        },
        {
          "name": "zstd",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}