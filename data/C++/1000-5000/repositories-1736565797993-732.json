{
  "metadata": {
    "timestamp": 1736565797993,
    "page": 732,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "laverdet/isolated-vm",
      "stars": 2250,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-tidy",
          "type": "blob",
          "size": 0.8994140625,
          "content": "---\nChecks: 'bugprone-*,clang-*,hicpp-*,misc-*,modernize-*,performance-*,readability-*,-bugprone-easily-swappable-parameters,-hicpp-avoid-c-arrays,-hicpp-no-array-decay,-hicpp-no-malloc,-hicpp-signed-bitwise,-hicpp-use-override,-misc-const-correctness,-misc-no-recursion,-misc-non-private-member-variables-in-classes,-modernize-avoid-c-arrays,-modernize-use-nodiscard,-readability-else-after-return,-readability-magic-numbers,-readability-function-cognitive-complexity'\nHeaderFilterRegex: 'src/*'\nCheckOptions:\n  - key:             readability-identifier-length.MinimumVariableNameLength\n    value:           '2'\n  - key:             readability-identifier-length.MinimumParameterNameLength\n    value:           '2'\n  - key:             hicpp-special-member-functions.AllowMissingMoveFunctions\n    value:           '1'\n  - key:             hicpp-special-member-functions.AllowSoleDefaultDtor\n    value:           '1'\n...\n"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0810546875,
          "content": ".git\n.gitignore\n.dockerignore\nDockerfile*\nexamples\nnode_modules\nout\nprebuilds\nspec\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.083984375,
          "content": "build/\nnode_modules/\npackage-lock.json\nout/\n.cache/\ncompile_commands.json\n/prebuilds/\n"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.0810546875,
          "content": "test.js\ntests\nout/\nbuild/\nprebuild/\n.github/\n.prebuildrc\n.travis.yml\n.vscode/\n*.md\n"
        },
        {
          "name": ".prebuildrc",
          "type": "blob",
          "size": 0.0810546875,
          "content": "{\n  \"target\": [\n    \"18.20.4\",\n    \"20.18.0\",\n    \"22.11.0\"\n  ],\n  \"strip\": true\n}\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.77734375,
          "content": "## v4.3.0\n- v8 inspector API fixed in nodejs v16.x\n- `release` method added to `Module`\n\n## v4.2.0\n- `accessors` option added to `reference.get()`\n\n## v4.1.0\n- Support for nodejs v16.x\n- `onCatastrophicError` added\n- Fix for `null` error thrown from callback\n\n## v4.0.0\n- `Callback` class addeed.\n- When possible, `reference.get()` will return a function delegate instead of a `Reference`.\n- `reference.get()` will no longer return inherited properties by default.\n- `result` property on `eval` and `evalClosure` has been removed. The result is now just the return\nvalue.\n- All `isolated-vm` class prototypes, and most instances are frozen.\n- `isolate.cpuTime` and `isolate.wallTime` now return bigints.\n- Proxies and accessors are no longer tolerated via `reference.get`, and related functions.\n"
        },
        {
          "name": "Dockerfile.alpine",
          "type": "blob",
          "size": 0.2177734375,
          "content": "FROM node:22-alpine3.20 AS build\nWORKDIR /isolated-vm\nRUN apk add g++ make python3\nCOPY . .\nRUN npm install --ignore-scripts\nRUN MAKEFLAGS=-j$(nproc) npx -y prebuild\n\nFROM scratch\nCOPY --from=build /isolated-vm/prebuilds .\n"
        },
        {
          "name": "Dockerfile.debian",
          "type": "blob",
          "size": 0.287109375,
          "content": "FROM node:22-bullseye-slim AS build\nWORKDIR /isolated-vm\nRUN apt-get update && \\\n  apt-get install -y --no-install-recommends \\\n  g++ \\\n  make \\\n  python3\nCOPY . .\nRUN npm install --ignore-scripts\nRUN MAKEFLAGS=-j$(nproc) npx -y prebuild\nFROM scratch\nCOPY --from=build /isolated-vm/prebuilds .\n"
        },
        {
          "name": "ISSUE_TEMPLATE.md",
          "type": "blob",
          "size": 1.462890625,
          "content": "<!--\nPlease only submit complete issues and questions. YOU ARE A SOFTWARE ENGINEER! Ask yourself: \"if\nsomeone was reporting an issue about something that I wrote what information would be helpful?\".\nThat is, please include your nodejs version, your operating system version, your compiler version,\nwhat you've tried so far to fix the issue (especially this one!).. things like that.\n\nIf some specific code is triggering the issue then please include a FULL EXAMPLE of the code that\ncan be run on its own. Please no \"snippets\", if I can't run the code without modifications then I\ncan't help you.\n-->\n\n## Is Your Question Already Answered?\n- [ ] I have read the [Frequently Asked Question](https://github.com/laverdet/isolated-vm?tab=readme-ov-file#frequently-asked-question) in the README. My question is not the Frequently Asked Question.\n\n## Personal Diagnostics\nPlease answer the following questions:\n\n#### JavaScript includes a `setTimeout` function:\n- [ ] Yes\n- [ ] No\n\n#### Functions are a type of primitive value in JavaScript:\n- [ ] Yes\n- [ ] No\n\n#### Objects can be shared between isolates:\n- [ ] Yes\n- [ ] No\n\n## The Code\n- [ ] This code will parse and evaluate if I put it into a file called `main.mjs` and then run `node main.mjs`.\n\n```js\n// Replace this code with the code which demonstrates what you are asking about\nimport ivm from \"isolated-vm\";\nconst isolate = new ivm.Isolate();\nconst context = await isolate.createContext();\nconsole.log(await context.eval('\"hello world\"'));\n```\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.7119140625,
          "content": "Copyright 2017 Marcel Laverdet\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 40.4833984375,
          "content": "[![npm version](https://badgen.now.sh/npm/v/isolated-vm)](https://www.npmjs.com/package/isolated-vm)\n[![isc license](https://badgen.now.sh/npm/license/isolated-vm)](https://github.com/laverdet/isolated-vm/blob/main/LICENSE)\n[![github action](https://github.com/laverdet/isolated-vm/actions/workflows/build.yml/badge.svg)](https://github.com/laverdet/isolated-vm/actions/workflows/build.yml)\n[![npm downloads](https://badgen.now.sh/npm/dm/isolated-vm)](https://www.npmjs.com/package/isolated-vm)\n\nisolated-vm -- Access to multiple isolates in nodejs\n====================================================\n\n[![NPM](https://nodei.co/npm/isolated-vm.png)](https://www.npmjs.com/package/isolated-vm)\n\n`isolated-vm` is a library for nodejs which gives you access to v8's `Isolate` interface. This\nallows you to create JavaScript environments which are completely *isolated* from each other. This\ncan be a powerful tool to run code in a fresh JavaScript environment completely free of extraneous\ncapabilities provided by the nodejs runtime.\n\n\nPROJECT STATUS\n--------------\n\n`isolated-vm` is currently in *maintenance mode*. New features are not actively being added but\nexisting features and new versions of nodejs are supported as possible. There are some major\narchitectural changes which need to be added to improve the stability and security of the project. I\ndon't have as much spare time as I did when I started this project, so there is not currently any\nplan for these improvements.\n\n#### Wishlist\n\n1) Multi-process architecture. v8 is *not* resilient to out of memory conditions and is unable to\ngracefully unwind from these errors. Therefore it is possible, and even common, to crash a process\nwith poorly-written or hostile software. I implemented a band-aid for this with the\n`onCatastrophicError` callback which quarantines a corrupted isolate, but it is not reliable.\n\n2) Bundled v8 version. nodejs uses a patched version of v8 which makes development of this module\nmore difficult than it needs to be. For some reason they're also allowed to change the v8 ABI in\nsemver minor releases as well, which causes issues for users while upgrading nodejs. Also, some\nLinux distributions strip \"internal\" symbols from their nodejs binaries which makes usage of this\nmodule impossible. I think the way to go is to compile and link against our own version of v8.\n\nCONTENTS\n--------\n\n* [Requirements](#requirements)\n* [Who Is Using isolated-vm](#who-is-using-isolated-vm)\n* [Security](#security)\n* [API Documentation](#api-documentation)\n\t* [Isolate](#class-isolate-transferable)\n\t* [Context](#class-context-transferable)\n\t* [Script](#class-script-transferable)\n\t* [Module](#class-module-transferable)\n\t* [Callback](#class-callback-transferable)\n\t* [Reference](#class-reference-transferable)\n\t* [ExternalCopy](#class-externalcopy-transferable)\n* [Examples](#examples)\n* [ðŸš¨ Frequently Asked Question ðŸš¨](#frequently-asked-question)\n* [Alternatives](#alternatives)\n\n\nREQUIREMENTS\n------------\n\nThis project requires nodejs version 16.x (or later).\n\nðŸš¨ If you are using a version of nodejs 20.x or later, you must pass `--no-node-snapshot` to `node`.\n\nFurthermore, to install this module you will need a compiler installed. If you run into errors while\nrunning `npm install isolated-vm` it is likely you don't have a compiler set up, or your compiler is\ntoo old.\n\n* Windows + OS X users should follow the instructions here: [node-gyp](https://github.com/nodejs/node-gyp)\n* Ubuntu users should run: `sudo apt-get install python g++ build-essential`\n* Alpine users should run: `sudo apk add python3 make g++`\n* Amazon Linux AMI users should run: `sudo yum install gcc72 gcc72-c++`\n* Arch Linux users should run: `sudo pacman -S make gcc python`\n* Red Hat users should run: `sudo dnf install python3 make gcc gcc-c++ zlib-devel brotli-devel openssl-devel`\n\n\nWHO IS USING ISOLATED-VM\n------------------------\n\n* [Screeps](https://screeps.com/) - Screeps is an online JavaScript-based MMO+RPG game. They are\nusing isolated-vm to run arbitrary player-supplied code in secure environments which can persistent\nfor several days at a time.\n\n* [Fly](https://fly.io/) - Fly is a programmable CDN which hosts dynamic endpoints as opposed to\njust static resources. They are using isolated-vm to run globally distributed applications, where\neach application may have wildly different traffic patterns.\n\n* [Algolia](https://www.algolia.com) - Algolia is a Search as a Service provider. They use\n`isolated-vm` to power their [Custom Crawler](https://www.algolia.com/products/crawler/) product,\nwhich allows them to safely execute user-provided code for content extraction.\n\n* [Tripadvisor](https://www.tripadvisor.com) - Tripadvisor is the worldâ€™s largest travel platform.\nThey use `isolated-vm` to server-side render thousands of React pages per second.\n\n\nSECURITY\n--------\n\nRunning untrusted code is an extraordinarily difficult problem which must be approached with great\ncare. Use of `isolated-vm` to run untrusted code does not automatically make your application safe.\nThrough carelessness or misuse of the library it can be possible to leak sensitive data or grant\nundesired privileges to an isolate.\n\nAt a minimum you should take care not to leak any instances of `isolated-vm` objects (`Reference`,\n`ExternalCopy`, etc) to untrusted code. It is usually trivial for an attacker to use these instances\nas a springboard back into the nodejs isolate which will yield complete control over a process.\n\nAdditionally, it is wise to keep nodejs up to date through point releases which affect v8. You can\nfind these on the [nodejs changelog](https://github.com/nodejs/node/blob/master/CHANGELOG.md) by\nlooking for entries such as \"update V8 to 9.1.269.36 (MichaÃ«l Zasso) #38273\". Historically there\nhave usually been 3-5 of these updates within a single nodejs LTS release cycle. It is *not*\nrecommended to use odd-numbered nodejs releases since these frequently break ABI and API\ncompatibility and isolated-vm doesn't aim to be compatible with bleeding edge v8.\n\nv8 is a relatively robust runtime, but there are always new and exciting ways to crash, hang,\nexploit, or otherwise disrupt a process with plain old JavaScript. Your application must be\nresilient to these kinds of issues and attacks. It's a good idea to keep instances of `isolated-vm`\nin a different nodejs process than other critical infrastructure.\n\nIf [advanced persistent threats](https://en.wikipedia.org/wiki/Advanced_persistent_threat) are\nwithin your threat model it's a very good idea to architect your application using a foundation\nsimilar to Chromium's [site\nisolation](https://www.chromium.org/Home/chromium-security/site-isolation). You'll also need to make\nsure to keep your system kernel up to date against [local privilege\nescalation](https://en.wikipedia.org/wiki/Privilege_escalation) attacks. Running your service in a\ncontainer such as a Docker may be a good idea but it is important to research container escape\nattacks as well.\n\n\nAPI DOCUMENTATION\n-----------------\n\nSince isolates share no resources with each other, most of this API is built to provide primitives\nwhich make marshalling data between many isolates quick and easy. The only way to pass data from one\nisolate to another is to first make that data *transferable*. Primitives (except for `Symbol`) are\nalways transferable. This means if you invoke a function in a different isolate with a number or\nstring as the argument, it will work fine. If you need to pass more complex information you will\nhave to first make the data transferable with one of the methods here.\n\nMost methods will provide both a synchronous and an asynchronous version. Calling the synchronous\nfunctions will block your thread while the method runs and eventually returns a value. The\nasynchronous functions will return a\n[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\nwhile the work runs in a separate thread pool.\n\nThere are some rules about which functions may be called from certain contexts:\n\n1. Asynchronous functions may be called at any time\n2. Synchronous functions usually may not be called from an asynchronous function\n3. You may call a synchronous function from an asynchronous function as long as that function\n\tbelongs to current isolate\n4. You may call a synchronous function belonging to the default nodejs isolate at any time\n\nAdditionally, some methods will provide an \"ignored\" version which runs asynchronously but returns\nno promise. This can be a good option when the calling isolate would ignore the promise anyway,\nsince the ignored versions can skip an extra thread synchronization. Just be careful because this\nswallows any thrown exceptions which might make problems hard to track down.\n\nIt's also worth noting that all asynchronous invocations will run in the order they were queued,\nregardless of whether or not you wait on them. So, for instance, you could call several \"ignored\"\nmethods in a row and then `await` on a final async method to observe some side-effect of the\nignored methods.\n\n\n### Class: `Isolate` *[transferable]*\nThis is the main reference to an isolate. Every handle to an isolate is transferable, which means\nyou can give isolates references to each other. An isolate will remain valid as long as someone\nholds a handle to the isolate or anything created inside that isolate. Once an isolate is lost the\ngarbage collector should eventually find it and clean up its memory. Since an isolate and all it\ncontains can represent quite a large chunk of memory though you may want to explicitly call the\n`dispose()` method on isolates that you are finished with to get that memory back immediately.\n\n##### `new ivm.Isolate(options)`\n* `options` *[object]*\n\t* `memoryLimit` *[number]* - Memory limit that this isolate may use, in MB. Note that this is more\n\tof a guideline instead of a strict limit. A determined attacker could use 2-3 times this limit\n\tbefore their script is terminated. Against non-hostile code this limit should be pretty close. The\n\tdefault is 128MB and the minimum is 8MB.\n\t* `inspector` *[boolean]* - Enable v8 inspector support in this isolate. See\n\t`inspector-example.js` in this repository for an example of how to use this.\n\t* `snapshot` *[ExternalCopy[ArrayBuffer]]* - This is an optional snapshot created from\n\t`createSnapshot` which will be used to initialize the heap of this isolate.\n  * `onCatastrophicError` *[function]* - Callback to be invoked when a *very bad* error occurs. If\n    this is invoked it means that v8 has lost all control over the isolate, and all resources in use\n    are totally unrecoverable. If you receive this error you should log the error, stop serving\n    requests, finish outstanding work, and end the process by calling `process.abort()`.\n\n##### `ivm.Isolate.createSnapshot(scripts, warmup_script)`\n* `scripts` *[array]*\n\t* `code` *[string]* - Source code to set up this snapshot\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n* `warmup_script` *[string]* - Optional script to \"warmup\" the snapshot by triggering code\ncompilation\n\nðŸš¨ You should not use this feature. It was never all that stable to begin with and has grown\nincreasingly unstable due to changes in v8.\n\n**Note**: `createSnapshot` does not provide the same isolate protection like the rest of\nisolated-vm. If the script passed to `createSnapshot` uses too much memory the process will crash,\nand if it has an infinite loop it will stall the process. Furthermore newer v8 features may simply\nfail when attempting to take a snapshot that uses them. It is best to snapshot code that only\ndefines functions, class, and simple data structures.\n\n##### `isolate.compileScript(code)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.compileScriptSync(code)`\n* `code` *[string]* - The JavaScript code to compile.\n* `options` *[object]*\n\t* [`{ ...CachedDataOptions }`](#cacheddataoptions)\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\n* **return** A [`Script`](#class-script-transferable) object.\n\nNote that a [`Script`](#class-script-transferable) can only run in the isolate which created it.\n\n##### `isolate.compileModule(code)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.compileModuleSync(code)`\n* `code` *[string]* - The JavaScript code to compile.\n* `options` *[object]*\n  * `meta` *[function]* - Callback which will be invoked the first time this module accesses\n    `import.meta`. The `meta` object will be passed as the first argument. This option may only be\n    used when invoking `compileModule` from within the same isolate.\n\t* [`{ ...CachedDataOptions }`](#cacheddataoptions)\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\n* **return** A [`Module`](#class-module-transferable) object.\n\nNote that a [`Module`](#class-module-transferable) can only run in the isolate which created it.\n\n##### `isolate.createContext()` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.createContextSync()`\n* `options` *[object]*\n\t* `inspector` *[boolean]* - Enable the v8 inspector for this context. The inspector must have been\n\t\tenabled for the isolate as well.\n\n* **return** A [`Context`](#class-context-transferable) object.\n\n##### `isolate.dispose()`\nDestroys this isolate and invalidates all references obtained from it.\n\n##### `isolate.getHeapStatistics()` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `isolate.getHeapStatisticsSync()`\n* **return** [object]\n\nReturns heap statistics from v8. The return value is almost identical to the nodejs function\n[v8.getHeapStatistics()](https://nodejs.org/dist/latest-v8.x/docs/api/v8.html#v8_v8_getheapstatistics).\nThis function returns one additional property: `externally_allocated_size` which is the total amount\nof currently allocated memory which is not included in the v8 heap but counts against this isolate's\n`memoryLimit`. ArrayBuffer instances over a certain size are externally allocated and will be\ncounted here.\n\n##### `isolate.cpuTime` *bigint*\n##### `isolate.wallTime` *bigint*\nThe total CPU and wall time spent in this isolate, in nanoseconds. CPU time is the amount of time\nthe isolate has spent actively doing work on the CPU. Wall time is the amount of time the isolate\nhas been running, including passive time spent waiting (think \"wall\" like a clock on the wall). For\ninstance, if an isolate makes a call into another isolate, wall time will continue increasing while\nCPU time will remain the same.\n\nNote that in nodejs v10.x the return value is a regular number, since bigint isn't supported on\nearlier versions.\n\nAlso note that CPU time may vary drastically if there is contention for the CPU. This could occur if\nother processes are trying to do work, or if you have more than `require('os').cpus().length`\nisolates currently doing work in the same nodejs process.\n\n##### `isolate.isDisposed` *[boolean]*\nFlag that indicates whether this isolate has been disposed.\n\n##### `isolate.referenceCount` *[number]*\nReturns the total count of active `Reference` instances that belong to this isolate. Note that in\ncertain cases many `Reference` instances in JavaScript will point to the same underlying reference\nhandle, in which case this number will only reflect the underlying reference handle. This happens\nwhen you transfer a `Reference` instance via some method which accepts transferable values. This\nwill also include underlying reference handles created by isolated-vm like `Script` or `Context`\nobjects.\n\n##### `isolate.startCpuProfiler(title)` *[void]*\nStart a CPU profiler in the isolate, for performance profiling. It only collects cpu profiles when\nthe isolate is active in a thread.\n\n##### `isolate.stopCpuProfiler(title)` *[Promise<Array<ThreadCpuProfile>>]*\nStop a CPU profiler previously started using the same title. It returns an array of profiles dependening\non how many times the isolate get activated in a thread.\n\n\n* **return** An array of [`ThreadCpuProfile`](#thread-cpu-profile) objects.\n\n### Class: `Context` *[transferable]*\nA context is a sandboxed execution environment within an isolate. Each context contains its own\nbuilt-in objects and global space.\n\n##### `context.global` *[`Reference`](#class-reference-transferable)*\n[`Reference`](#class-reference-transferable) to this context's global object. Note that if you call\n`context.release()` the global reference will be released as well.\n\n##### `context.eval(code, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `context.evalIgnored(code, options)`\n##### `context.evalSync(code, options)`\n* `code` *[string]* - The code to run\n* `options` *[object]*\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this script is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** *[transferable]*\n\nCompiles and executes a script within a context. This will return the last value evaluated, as long\nas that value was transferable, otherwise `undefined` will be returned.\n\n##### `context.evalClosure(code, arguments, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `context.evalClosureIgnored(code, arguments, options)`\n##### `context.evalClosureSync(code, arguments, options)`\n* `code` *[string]* - The code to run\n* `arguments` *[array]` - Arguments to pass to this code\n* `options` *[object]*\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this script is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* [`{ ...ScriptOrigin }`](#scriptorigin)\n\t* `arguments` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n\t* `result` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** `*[transferable]*\n\nCompiles and runs code as if it were inside a function, similar to the seldom-used `new\nFunction(code)` constructor. You can pass arguments to the function and they will be available as\n`$0`, `$1`, and so on. You can also use `return` from the code.\n\n##### `context.release()`\n\nReleases this reference to the context. You can call this to free up v8 resources immediately, or\nyou can let the garbage collector handle it when it feels like it. Note that if there are other\nreferences to this context it will not be disposed. This only affects this reference to the context.\n\n\n### Class: `Script` *[transferable]*\nA script is a compiled chunk of JavaScript which can be executed in any context within a single\nisolate.\n\n##### `script.release()`\n\nReleases the reference to this script, allowing the script data to be garbage collected. Functions\nand data created in the isolate by previous invocations to `script.run(...)` will still be alive in\ntheir respective contexts-- this only means that you can't invoke `script.run(...)` again with this\nreference.\n\n##### `script.run(context, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `script.runIgnored(context, options)`\n##### `script.runSync(context, options)`\n* `context` *[`Context`](#class-context-transferable)* - The context in which this script will run.\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this script is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** *[transferable]*\n\nRuns a given script within a context. This will return the last value evaluated in a given script,\nas long as that value was transferable, otherwise `undefined` will be returned. For instance if your\nscript was \"let foo = 1; let bar = 2; bar = foo + bar\" then the return value will be 3 because that\nis the last expression.\n\n\n### Class: `Module` *[transferable]*\nA JavaScript module. Note that a [`Module`](#class-module-transferable) can only run in the isolate which created it.\n\n##### `module.dependencySpecifiers`\nA read-only array of all dependency specifiers the module has.\n\n\t\tconst code = `import something from './something';`;\n\t\tconst module = await isolate.compileModule(code);\n\t\tconst dependencySpecifiers = module.dependencySpecifiers;\n\t\t// dependencySpecifiers => [\"./something\"];\n\n##### `module.namespace`\nReturns a [`Reference`](#class-reference-transferable) containing all exported values.\n\n##### `module.instantiate(context, resolveCallback)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `module.instantiateSync(context, resolveCallback)`\n* `context` *[`Context`](#class-context-transferable)* - The context the module should use.\n* `resolveCallback` - This callback is responsible for resolving all direct and indirect\ndependencies of this module. It accepts two parameters: `specifier` and `referrer`. It must return a\n`Module` instance which will be used to satisfy the dependency. The asynchronous version of\n`instantiate` may return a promise from `resolveCallback`.\n\nInstantiate the module together with all its dependencies. Calling this more than once on a single\nmodule will have no effect.\n\n##### `module.evaluate(options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `module.evaluateSync(options)`\n* `options` *[object]* - Optional.\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this module is allowed to\n\trun before execution is canceled. Default is no timeout.\n* **return** *[transferable]*\n\nEvaluate the module and return the last expression (same as script.run). If `evaluate` is called\nmore than once on the same module the return value from the first invocation will be returned (or\nthrown).\n\n**Note:** nodejs v14.8.0 enabled top-level await by default which has the effect of breaking the\nreturn value of this function.\n\n##### `module.release()`\n\nReleases this module. This behaves the same as other `.release()` methods.\n\n### Class: `Callback` *[transferable]*\nCallbacks can be used to create cross-isolate references to simple functions. This can be easier and\nsafer than dealing with the more flexible [`Reference`](#class-reference-transferable) class.\nArguments passed to and returned from callbacks are always copied using the same method as\n[`ExternalCopy`](#class-externalcopy-transferable). When transferred to another isolate, instances\nof `Callback` will turn into a plain old function. Callbacks are created automatically when passing\nfunctions to most isolated-vm functions.\n\n##### `new ivm.Callback(fn, options)`\n* `options` *[object]*\n\t* `async` *[boolean]* - Function will invoke the callback in \"async\" mode, which immediately\n\t\treturns a promise.\n\t* `ignored` *[boolean]* - Function will invoke the callback in \"ignored\" mode, which immediately\n\t\treturns `undefined` and ignores the result of the function (including thrown exceptions)\n\t* `sync` *[boolean]* - Function will invoke the callback in \"sync\" mode, blocking for a response\n\t\t(default).\n\n\n### Class: `Reference` *[transferable]*\nA instance of [`Reference`](#class-reference-transferable) is a pointer to a value stored in any isolate.\n\n##### `new ivm.Reference(value, options)`\n* `value` - The value to create a reference to.\n* `options` *[object]*\n  * `unsafeInherit` *[boolean]* - If enabled then the `get` family of functions will follow the\n    object's prototype chain. References created with this option should never be given to untrusted\n    code.\n\n##### `reference.typeof` *[string]*\n\nThis is the typeof the referenced value, and is available at any time from any isolate. Note that\nthis differs from the real `typeof` operator in that `null` is \"null\", and Symbols are \"object\".\n\n##### `reference.copy()` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.copySync()`\n* **return** JavaScript value of the reference.\n\nCreates a copy of the referenced value and internalizes it into this isolate. This uses the same\ncopy rules as [`ExternalCopy`](#class-externalcopy-transferable).\n\n##### `reference.deref()`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n* **return** The value referenced by this handle.\n\nWill attempt to return the actual value or object pointed to by this reference. Note that in order\nto call this function the reference must be owned by the current isolate, otherwise an error will be\nthrown.\n\n##### `reference.derefInto()`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n* **return** *[transferable]*\n\nReturns an object, which when passed to another isolate will cause that isolate to dereference the\nhandle.\n\n##### `reference.release()`\n\nReleases this reference. If you're passing around a lot of references between isolates it's wise to\nrelease the references when you are done. Otherwise you may run into issues with isolates running\nout of memory because other isolates haven't garbage collected recently. After calling this method\nall attempts to access the reference will throw an error.\n\n##### `reference.delete(property)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.deleteIgnored(property)`\n##### `reference.deleteSync(property)`\n* `property` *[transferable]* - The property to access on this object.\n\nDelete a property from this reference, as if using `delete reference[property]`\n\n##### `reference.get(property, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.getSync(property, options)`\n* `property` *[transferable]* - The property to access on this object.\n* `options` *[object]*\n\t* `accessors` *[boolean]* - Whether or not to invoke accessors and proxies on the underlying\n\t\tobject. Note that there is no way to supply a timeout to this function so only use this option in\n\t\ttrusted code.\n\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** A [`Reference`](#class-reference-transferable) object.\n\nWill access a reference as if using `reference[property]` and transfer the value out.\n\nIf the object is a proxy, or if the property is a getter, this method will throw unless the\n`accessors` option is true.\n\n##### `reference.set(property, value, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.setIgnored(property, value, options)`\n##### `reference.setSync(property, value, options)`\n* `property` *[transferable]* - The property to set on this object.\n* `value` *[transferable]* - The value to set on this object.\n* `options` *[object]*\n\t* [`{ ...TransferOptions }`](#transferoptions)\n\n##### `reference.apply(receiver, arguments, options)` *[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)*\n##### `reference.applyIgnored(receiver, arguments, options)`\n##### `reference.applySync(receiver, arguments, options)`\n##### `reference.applySyncPromise(receiver, arguments, options)`\n* `receiver` *[transferable]* - The value which will be `this`.\n* `arguments` *[array]* - Array of transferables which will be passed to the function.\n* `options` *[object]*\n\t* `timeout` *[number]* - Maximum amount of time in milliseconds this function is allowed to run\n\t\tbefore execution is canceled. Default is no timeout.\n\t* `arguments` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n\t* `result` *[object]*\n\t\t* [`{ ...TransferOptions }`](#transferoptions)\n* **return** *[transferable]*\n\nWill attempt to invoke an object as if it were a function. If the return value is transferable it\nwill be returned to the caller of `apply`, otherwise it will return an instance of `Reference`. This\nbehavior can be changed with the `result` options.\n\n`applySyncPromise` is a special version of `applySync` which may only be invoked on functions\nbelonging to the default isolate AND may only be invoked from a non-default thread. Functions\ninvoked in this way may return a promise and the invoking isolate will wait for that promise to\nresolve before resuming execution. You can use this to implement functions like `readFileSync` in a\nway that doesn't block the default isolate. Note that the invoking isolate will not respond to any\nasync functions until this promise is resolved, however synchronous functions will still function\ncorrectly. Misuse of this feature may result in deadlocked isolates, though the default isolate\nwill never be at risk of a deadlock.\n\n\n### Class: `ExternalCopy` *[transferable]*\nInstances of this class represent some value that is stored outside of any v8 isolate. This value\ncan then be quickly copied into any isolate without any extra thread synchronization.\n\n##### `new ivm.ExternalCopy(value, options)`\n* `value` - The value to copy.\n* `options` *[object]*\n\t* `transferList` *[boolean]* - An array of `ArrayBuffer` instances to transfer ownership. This\n\t\tbehaves in a similar way to\n\t\t[`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage).\n\t* `transferOut` *[boolean]* - If true this will release ownership of the given resource from this\n\t\tisolate. This operation completes in constant time since it doesn't have to copy an arbitrarily\n\t\tlarge object. This only applies to ArrayBuffer and TypedArray instances.\n\nPrimitive values can be copied exactly as they are. Date objects will be copied as Dates.\nArrayBuffers, TypedArrays, and DataViews will be copied in an efficient format. SharedArrayBuffers\nwill simply copy a reference to the existing memory and when copied into another isolate the new\nSharedArrayBuffer will point to the same underlying data. After passing a SharedArrayBuffer to\nExternalCopy for the first time isolated-vm will take over management of the underlying memory\nblock, so a \"copied\" SharedArrayBuffer can outlive the isolate that created the memory originally.\n\nAll other objects will be copied in seralized form using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n`ExternalCopy` can copy objects with deeply nested *transferable* objects. For example:\n\n```js\nlet isolate = new ivm.Isolate;\nlet context = isolate.createContextSync();\nlet global = context.global;\nlet data = new ExternalCopy({ isolate, context, global });\n```\n\n##### `ExternalCopy.totalExternalSize` *[number]*\n\nThis is a static property which will return the total number of bytes that isolated-vm has allocated\noutside of v8 due to instances of `ExternalCopy`.\n\n##### `externalCopy.copy(options)`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n\t* `transferIn` *[boolean]* - If true this will transfer the resource directly into this isolate,\n\tinvalidating the ExternalCopy handle.\n* **return** - JavaScript value of the external copy.\n\nInternalizes the ExternalCopy data into this isolate.\n\n##### `externalCopy.copyInto(options)`\n* `options` *[object]*\n\t* `release` *[boolean]* - If true `release()` will automatically be called on this instance.\n\t* `transferIn` *[boolean]* - If true this will transfer the resource directly into this isolate,\n\tinvalidating the ExternalCopy handle.\n* **return** *[transferable]*\n\nReturns an object, which when passed to another isolate will cause that isolate to internalize a\ncopy of this value.\n\n#### `externalCopy.release()`\n\nReleases the reference to this copy. If there are other references to this copy elsewhere the copy\nwill still remain in memory, but this handle will no longer be active. Disposing ExternalCopy\ninstances isn't super important, v8 is a lot better at cleaning these up automatically because\nthere's no inter-isolate dependencies.\n\n### Shared Options\nMany methods in this library accept common options between them. They are documented here instead of\nbeing colocated with each instance.\n\n##### `CachedDataOptions`\n* `cachedData` *[ExternalCopy[ArrayBuffer]]* - This will consume cached compilation data from a\n\tprevious call to this function. `cachedDataRejected` will be set to `true` if the supplied data\n\twas rejected by V8.\n* `produceCachedData` *[boolean]* - Produce V8 cache data. Similar to the\n\t[VM.Script](https://nodejs.org/api/vm.html) option of the same name. If this is true then the\n\treturned object will have `cachedData` set to an ExternalCopy handle. Note that this differs from\n\tthe VM.Script option slightly in that `cachedDataProduced` is never set.\n\nMost functions which compile or run code can produce and consume cached data. You can produce cached\ndata and use the data in later invocations to drastically speed up parsing of the same script. You\ncan even save this data to disk and use it in a different process. You can set both `cachedData` and\n`produceCachedData`, in which case new cached data will only be produced if the data supplied was\ninvalid.\n\n*NOTE*: CachedData contains compiled machine code. That means you should not accept `cachedData`\npayloads from a user, otherwise they may be able to run arbitrary code.\n\n##### `ScriptOrigin`\n* `filename` *[string]* - Filename of this source code\n* `columnOffset` *[number]* - Column offset of this source code\n* `lineOffset` *[number]* - Line offset of this source code\n\nYou may optionally specify information on compiled code's filename. This is used in various\ndebugging contexts within v8, including stack traces and the inspector. It is recommended to use a\nvalid URI scheme, for example: `{ filename: 'file:///test.js' }`, otherwise some devtools may\nmalfunction.\n\n##### `TransferOptions`\n* `copy` *[boolean]* - Automatically deep copy value\n* `externalCopy` *[boolean]* - Automatically wrap value in `ExternalCopy` instance\n* `reference` *[boolean]* - Automatically wrap value in `Reference` instance\n* `promise` *[boolean]* - Automatically proxy any returned promises between isolates. This can be\n\tused in combination with the other transfer options.\n\nAny function which moves data between isolates will accept these transfer options. By default only\n*[transferable]* values may pass between isolates. Without specifying one of these options the\nfunction may ignore the value, throw, or wrap it in a reference depending on the context.\n\nMore advanced situations like transferring ownership of `ArrayBuffer` instances will require direct\nuse of [`ExternalCopy`](#class-externalcopy-transferable) or\n[`Reference`](#class-reference-transferable).\n\n\n\n##### `ThreadCpuProfile`\nIt's a object that contains a thread id and a [CpuProfile](#cpuprofile) info.\n\n* `threadId` *[number]* - The thread that isolate runs on.\n* `profile` *[CpuProfile]* - The [CpuProfile](#cpuprofile).\n\n##### `CpuProfile`\nThe CpuProfile Object that can be `JSON.stringify(cpuProfile)`, and save to any external file system\nfor later reloaded into chrome dev tool or any other js performance tool to review.\n\nThe format should matches the definition in: https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-Profile\n\n* `startTime` *[number]* - The start timestamp when calling `.startProfiling`.\n* `endTime` *[number]* - The end timestamp when calling `.stopProfiling`,\n* `samples` *[Array<number>]* - All sample node id has been collected.\n* `timeDeltas` *[Array<number>]* - All the time deltas related to the `samples`.\n* `nodes` *[Array<Node>]*\n\t* `hitCount` *[number]*\n\t* `id` *[id]*\n\t* `children` *[Array<number>]*\n\t* `callFrame` *[CallFrame]*\n\t\t* `functionName` *[string]*\n\t\t* `url` *[string]* - The `filename` used in [`ScriptOrigin`](#scriptorigin)\n\t\t* `scriptId` *[number]*\n\t\t* `lineNumber` *[number]*\n\t\t* `columnNumber` *[number]*\n\t\t* `bailoutReason` *[string?]* - When the JavaScript function bailed out from v8 optimization,\n\t\t\tthis field will present.\n\n\nEXAMPLES\n--------\n\nBelow is a sample program which shows basic usage of the library.\n\n```js\n// Create a new isolate limited to 128MB\nconst ivm = require('isolated-vm');\nconst isolate = new ivm.Isolate({ memoryLimit: 128 });\n\n// Create a new context within this isolate. Each context has its own copy of all the builtin\n// Objects. So for instance if one context does Object.prototype.foo = 1 this would not affect any\n// other contexts.\nconst context = isolate.createContextSync();\n\n// Get a Reference{} to the global object within the context.\nconst jail = context.global;\n\n// This makes the global object available in the context as `global`. We use `derefInto()` here\n// because otherwise `global` would actually be a Reference{} object in the new isolate.\njail.setSync('global', jail.derefInto());\n\n// We will create a basic `log` function for the new isolate to use.\njail.setSync('log', function(...args) {\n\tconsole.log(...args);\n});\n\n// And let's test it out:\ncontext.evalSync('log(\"hello world\")');\n// > hello world\n\n// Let's see what happens when we try to blow the isolate's memory\nconst hostile = isolate.compileScriptSync(`\n\tconst storage = [];\n\tconst twoMegabytes = 1024 * 1024 * 2;\n\twhile (true) {\n\t\tconst array = new Uint8Array(twoMegabytes);\n\t\tfor (let ii = 0; ii < twoMegabytes; ii += 4096) {\n\t\t\tarray[ii] = 1; // we have to put something in the array to flush to real memory\n\t\t}\n\t\tstorage.push(array);\n\t\tlog('I\\\\'ve wasted '+ (storage.length * 2)+ 'MB');\n\t}\n`);\n\n// Using the async version of `run` so that calls to `log` will get to the main node isolate\nhostile.run(context).catch(err => console.error(err));\n// I've wasted 2MB\n// I've wasted 4MB\n// ...\n// I've wasted 130MB\n// I've wasted 132MB\n// RangeError: Array buffer allocation failed\n```\n\n\nFREQUENTLY ASKED QUESTION\n-------------------------\n\nThere is only 1 frequently asked question:\n\n\"How do I pass a [module, function, object, library] into an isolate?\"\n\nYou don't! Isolates are `isolated`. An *isolate* is its own environment with its own heap which is\n*isolated* from all other **isolates**. It may help to think of the question in the context of a\nweb browser. How would you pass a function from nodejs into Firefox? You can't, it is nonsense.\n\nDepending on the function you could just pass the code for the function directly into the isolate\nand execute it there. That's how a `<script />` tag works in our browser metaphor. This works for\nfunctions that don't need to do anything such as file access or network requests. Check out Webpack,\nRollup, esbuild, etc for bundling solutions.\n\nIf you want to perform operations on files, network, native modules, etc then you will need to set\nup some kind of shim delegate which can perform the operation within nodejs and pass the result back\nto your isolate. In the browser metaphor this would be like a REST call back to your service.\n\nFinally, and I'm not trying to be mean here, if this explanation doesn't make sense then you really\nshould not be using this module. This is a low-level module which is just one piece of a very\ncomplicated problem. If your goal is to run code from untrusted sources then you *must* have a very\ncomprehensive understanding of JavaScript. You should know where the ECMAScript specification ends\nand where the HTML, DOM, and other web specifications begin. You should be a security-focused\nhacker, otherwise you will almost certain make a company-ending mistake. This is not a module for\nthe faint of heart. Turn back now!\n\n\nALTERNATIVES\n------------\n\nBelow is a quick summary of some other options available on nodejs and how they differ from\nisolated-vm. The table headers are defined as follows:\n\n* **Secure**: Obstructs access to unsafe nodejs capabilities\n* **Memory Limits**: Possible to set memory limits / safe against heap overflow DoS attacks\n* **Isolated**: Is garbage collection, heap, etc isolated from application\n* **Multithreaded**: Run code on many threads from a single process\n* **Module Support**: Is `require` supported out of the box\n* **Inspector Support**: Chrome DevTools supported\n\n| Module                                                                       | Secure | Memory Limits | Isolated | Multithreaded | Module Support | Inspector Support |\n| ---------------------------------------------------------------------------- | :----: | :-----------: | :------: | :-----------: | :------------: | :---------------: |\n| [vm](https://nodejs.org/api/vm.html)                                         |        |               |          |               |       âœ…       |        âœ…         |\n| [worker_threads](https://nodejs.org/api/worker_threads.html)                 |        |               |    âœ…    |      âœ…       |       âœ…       |        âœ…         |\n| [vm2](https://github.com/patriksimek/vm2)                                    |       |               |          |               |       âœ…       |        âœ…         |\n| [tiny-worker](https://github.com/avoidwork/tiny-worker)                      |        |               |    âœ…    |               |       âœ…       |                   |\n| isolated-vm                                                                  |   âœ…   |       âœ…      |    âœ…    |      âœ…       |                |        âœ…         |\n"
        },
        {
          "name": "binding.gyp",
          "type": "blob",
          "size": 3.2373046875,
          "content": "{\n\t'target_defaults': {\n\t\t'default_configuration': 'Release',\n\t\t'configurations': {\n\t\t\t'Common': {\n\t\t\t\t'cflags_cc': [ '-std=c++17', '-g', '-Wno-unknown-pragmas' ],\n\t\t\t\t'cflags_cc!': [ '-fno-exceptions' ],\n\t\t\t\t'include_dirs': [ './src', './vendor' ],\n\t\t\t\t'xcode_settings': {\n\t\t\t\t\t'GCC_ENABLE_CPP_EXCEPTIONS': 'YES',\n\t\t\t\t\t'GCC_GENERATE_DEBUGGING_SYMBOLS': 'YES',\n\t\t\t\t\t'CLANG_CXX_LANGUAGE_STANDARD': 'c++17',\n\t\t\t\t\t'MACOSX_DEPLOYMENT_TARGET': '10.12',\n\t\t\t\t},\n\t\t\t\t'msvs_settings': {\n\t\t\t\t\t'VCCLCompilerTool': {\n\t\t\t\t\t\t'AdditionalOptions': [ '-std:c++17', '/GR' ],\n\t\t\t\t\t\t'ExceptionHandling': '1',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t'msvs_disabled_warnings': [\n\t\t\t\t\t4101, # Unreferenced local (msvc fires these for ignored exception)\n\t\t\t\t\t4068, # Unknown pragma\n\t\t\t\t],\n\t\t\t\t'conditions': [\n\t\t\t\t\t[ 'OS == \"win\"', { 'defines': [ 'NOMSG', 'NOMINMAX', 'WIN32_LEAN_AND_MEAN' ] } ],\n\t\t\t\t],\n\t\t\t},\n\t\t\t'Release': {\n\t\t\t\t'inherit_from': [ 'Common' ],\n\t\t\t\t'cflags': [ '-Wno-deprecated-declarations' ],\n\t\t\t\t'xcode_settings': {\n\t\t\t\t\t'GCC_OPTIMIZATION_LEVEL': '3',\n\t\t\t\t\t'OTHER_CFLAGS': [ '-Wno-deprecated-declarations' ],\n\t\t\t\t},\n\t\t\t\t'msvs_disabled_warnings': [\n\t\t\t\t\t4996, # Deprecation\n\t\t\t\t],\n\t\t\t},\n\t\t\t'Debug': {\n\t\t\t\t'inherit_from': [ 'Common' ],\n\t\t\t\t'defines': [ 'V8_IMMINENT_DEPRECATION_WARNINGS' ],\n\t\t\t},\n\t\t},\n\t},\n\t'targets': [\n\t\t{\n\t\t\t'target_name': 'isolated_vm',\n\t\t\t'cflags_cc!': [ '-fno-rtti' ],\n\t\t\t'xcode_settings': {\n\t\t\t\t'GCC_ENABLE_CPP_RTTI': 'YES',\n\t\t\t},\n\t\t\t'msvs_settings': {\n\t\t\t\t'VCCLCompilerTool': {\n\t\t\t\t\t'RuntimeTypeInfo': 'true',\n\t\t\t\t},\n\t\t\t},\n\t\t\t'conditions': [\n\t\t\t\t[ 'OS == \"linux\"', { 'defines': [ 'USE_CLOCK_THREAD_CPUTIME_ID' ] } ],\n\t\t\t],\n\t\t\t'sources': [\n\t\t\t\t'src/external_copy/external_copy.cc',\n\t\t\t\t'src/external_copy/serializer.cc',\n\t\t\t\t'src/external_copy/serializer_nortti.cc',\n\t\t\t\t'src/external_copy/string.cc',\n\t\t\t\t'src/isolate/allocator_nortti.cc',\n\t\t\t\t'src/isolate/environment.cc',\n\t\t\t\t\"src/isolate/cpu_profile_manager.cc\",\n\t\t\t\t'src/isolate/executor.cc',\n\t\t\t\t'src/isolate/holder.cc',\n\t\t\t\t'src/isolate/inspector.cc',\n\t\t\t\t'src/isolate/platform_delegate.cc',\n\t\t\t\t'src/isolate/scheduler.cc',\n\t\t\t\t'src/isolate/stack_trace.cc',\n\t\t\t\t'src/isolate/three_phase_task.cc',\n\t\t\t\t'src/lib/thread_pool.cc',\n\t\t\t\t'src/lib/timer.cc',\n\t\t\t\t'src/module/callback.cc',\n\t\t\t\t'src/module/context_handle.cc',\n\t\t\t\t'src/module/evaluation.cc',\n\t\t\t\t'src/module/external_copy_handle.cc',\n\t\t\t\t'src/module/isolate.cc',\n\t\t\t\t'src/module/isolate_handle.cc',\n\t\t\t\t'src/module/lib_handle.cc',\n\t\t\t\t'src/module/module_handle.cc',\n\t\t\t\t'src/module/native_module_handle.cc',\n\t\t\t\t'src/module/reference_handle.cc',\n\t\t\t\t'src/module/script_handle.cc',\n\t\t\t\t'src/module/session_handle.cc',\n\t\t\t\t'src/module/transferable.cc'\n\t\t\t],\n\t\t\t'conditions': [\n\t\t\t\t[ 'OS != \"win\"', {\n\t\t\t\t\t'dependencies': [ 'nortti' ],\n\t\t\t\t\t'sources/': [ [ 'exclude', '_nortti\\\\.cc$'] ],\n\t\t\t\t} ],\n\t\t\t],\n\t\t\t'libraries': [\n\t\t\t\t'<!@(node -e \"process.config.target_defaults.libraries.map(flag=>console.log(flag))\")'\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\t'target_name': 'nortti',\n\t\t\t'type': 'static_library',\n\t\t\t'sources': [\n\t\t\t\t'src/external_copy/serializer_nortti.cc',\n\t\t\t\t'src/isolate/allocator_nortti.cc',\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\t'target_name': 'action_after_build',\n\t\t\t'type': 'none',\n\t\t\t'dependencies': [ 'isolated_vm' ],\n\t\t\t'copies': [ {\n\t\t\t\t'files': [ '<(PRODUCT_DIR)/isolated_vm.node' ],\n\t\t\t\t'destination': 'out',\n\t\t\t} ],\n\t\t},\n\t],\n}\n"
        },
        {
          "name": "include.js",
          "type": "blob",
          "size": 0.083984375,
          "content": "'use strict';\nconst path = require('path');\nconsole.log(path.join(__dirname, 'src'));\n"
        },
        {
          "name": "inspector-example.js",
          "type": "blob",
          "size": 1.8115234375,
          "content": "'use strict';\nlet WebSocket = require('ws');\nlet ivm = require('./isolated-vm');\n\n/**\n * IMPORTANT: Allowing untrusted users to access the v8 inspector will almost certainly result in a\n * security vulnerability. Access to these endpoints should be restricted.\n */\n\n// Launch an infinite loop in another thread\nlet isolate = new ivm.Isolate({ inspector: true });\n(async function() {\n\tlet context = await isolate.createContext({ inspector: true });\n\tconst inspector = isolate.createInspectorSession();\n\tinspector.dispatchProtocolMessage('{\"id\":1,\"method\":\"Debugger.enable\"}');\n\tawait context.eval('/* break on script start */debugger;');\n\tinspector.dispose();\n\tlet script = await isolate.compileScript('console.log(\"hello world\")', { filename: 'example.js' });\n\tawait script.run(context);\n}()).catch(console.error);\n\n// Create an inspector channel on port 10000\nlet wss = new WebSocket.Server({ port: 10000 });\n\nwss.on('connection', function(ws) {\n\t// Dispose inspector session on websocket disconnect\n\tlet channel = isolate.createInspectorSession();\n\tfunction dispose() {\n\t\ttry {\n\t\t\tchannel.dispose();\n\t\t} catch (err) {}\n\t}\n\tws.on('error', dispose);\n\tws.on('close', dispose);\n\n\t// Relay messages from frontend to backend\n\tws.on('message', function(message) {\n\t\tconsole.log('<', message.toString())\n\t\ttry {\n\t\t\tchannel.dispatchProtocolMessage(String(message));\n\t\t} catch (err) {\n\t\t\t// This happens if inspector session was closed unexpectedly\n\t\t\tws.close();\n\t\t}\n\t});\n\n\t// Relay messages from backend to frontend\n\tfunction send(message) {\n\t\tconsole.log('>', message.toString())\n\t\ttry {\n\t\t\tws.send(message);\n\t\t} catch (err) {\n\t\t\tdispose();\n\t\t}\n\t}\n\tchannel.onResponse = (callId, message) => send(message);\n\tchannel.onNotification = send;\n});\nconsole.log('Inspector: devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=127.0.0.1:10000');\n"
        },
        {
          "name": "isolated-vm.d.ts",
          "type": "blob",
          "size": 29.587890625,
          "content": "declare namespace IsolatedVM {\n\texport type Transferable =\n\t\t| null\n\t\t| undefined\n\t\t| string\n\t\t| number\n\t\t| boolean\n\t\t| Isolate\n\t\t| Context\n\t\t| Script\n\t\t| ExternalCopy<any>\n\t\t| Callback<any>\n\t\t| Copy<any>\n\t\t| Reference<any>\n\t\t| Dereference<any>\n\t\t| Module\n\t\t| ((...args: any[]) => any)\n\t\t| typeof IsolatedVM;\n\n\t/**\n\t * This is the main reference to an isolate. Every handle to an isolate is transferable, which\n\t * means you can give isolates references to each other. An isolate will remain valid as long as\n\t * someone holds a handle to the isolate or anything created inside that isolate. Once an isolate\n\t * is lost the garbage collector should eventually find it and clean up its memory. Since an\n\t * isolate and all it contains can represent quite a large chunk of memory though you may want to\n\t * explicitly call the `dispose()` method on isolates that you are finished with to get that memory\n\t * back immediately.\n\t */\n\texport class Isolate {\n\t\tprivate __ivm_isolate: undefined;\n\t\tconstructor(options?: IsolateOptions);\n\n\t\t/**\n\t\t * The total CPU time spent in this isolate. CPU time is the amount of time the isolate has\n\t\t * spent actively doing work on the CPU.\n\t\t *\n\t\t * Note that CPU time may vary drastically if there is contention for the CPU. This could occur\n\t\t * if other processes are trying to do work, or if you have more than\n\t\t * require('os').cpus().length isolates currently doing work in the same nodejs process.\n\t\t */\n\t\treadonly cpuTime: bigint;\n\n\t\t/**\n\t\t * Flag that indicates whether this isolate has been disposed.\n\t\t */\n\t\treadonly isDisposed: boolean;\n\n\t\t/**\n\t\t * The total wall time spent in this isolate. Wall time is the amount of time the isolate has\n\t\t * been running, including passive time spent waiting (think \"wall\" like a clock on the wall).\n\t\t * For instance, if an isolate makes a call into another isolate, wall time will continue\n\t\t * increasing while CPU time will remain the same.\n\t\t */\n\t\treadonly wallTime: bigint;\n\n\t\t/**\n\t\t * Returns the total count of active `Reference` instances that belong to this isolate. Note\n\t\t * that in certain cases many `Reference` instances in JavaScript will point to the same\n\t\t * underlying reference handle, in which case this number will only reflect the underlying\n\t\t * reference handle. This happens when you transfer a `Reference` instance via some method which\n\t\t * accepts transferable values. This will also include underlying reference handles created by\n\t\t * isolated-vm like `Script` or `Context` objects.\n\t\t */\n\t\treadonly referenceCount: number;\n\n\t\t/**\n\t\t * Isolate snapshots are a very useful feature if you intend to create several isolates running\n\t\t * common libraries between them. A snapshot serializes the entire v8 heap including parsed code,\n\t\t * global variables, and compiled code. Check out the examples section for tips on using this.\n\t\t *\n\t\t * **Please note that versions of nodejs 10.4.0 - 10.9.0 may crash while using the snapshot\n\t\t * feature.**\n\t\t *\n\t\t * @param warmup_script - Optional script to \"warmup\" the snapshot by triggering code compilation\n\t\t */\n\t\tstatic createSnapshot(scripts: SnapshotScriptInfo[], warmup_script?: string): ExternalCopy<ArrayBuffer>;\n\n\t\tcompileScript(code: string, scriptInfo?: ScriptInfo): Promise<Script>;\n\t\tcompileScriptSync(code: string, scriptInfo?: ScriptInfo): Script;\n\n\t\tcompileModule(code: string, options?: CompileModuleOptions): Promise<Module>;\n\t\tcompileModuleSync(code: string, options?: CompileModuleOptions): Module;\n\n\t\tcreateContext(options?: ContextOptions): Promise<Context>;\n\t\tcreateContextSync(options?: ContextOptions): Context;\n\n\t\tcreateInspectorSession(): InspectorSession;\n\n\t\t/**\n\t\t * Destroys this isolate and invalidates all references obtained from it.\n\t\t */\n\t\tdispose(): void;\n\n\t\t/**\n\t\t * Returns heap statistics from v8.\n\t\t *\n\t\t * The return value is almost identical to the nodejs function v8.getHeapStatistics().\n\t\t *\n\t\t * See: https://nodejs.org/dist/latest-v8.x/docs/api/v8.html#v8_v8_getheapstatistics.\n\t\t *\n\t\t * This function returns one additional property: \"externally_allocated_size\" which is the total\n\t\t * amount of currently allocated memory which is not included in the v8 heap but counts against\n\t\t * this isolate's \"memoryLimit\".\n\t\t *\n\t\t * ArrayBuffer instances over a certain size are externally allocated and will be counted here.\n\t\t */\n\t\tgetHeapStatistics(): Promise<HeapStatistics>;\n\t\tgetHeapStatisticsSync(): HeapStatistics;\n\n\t\t/**\n\t\t * Start profiling against the isolate with a specific title\n\t\t * \n\t\t * @param title the profile title\n\t\t */\n\t\tstartCpuProfiler(title: string): void;\n\n\t\t/**\n\t\t * Stop profiling against the isolate with a specific title\n\t\t * that started via `startCpuProfiler`. It will return more\n\t\t * than one cpu profiles because isolate can be run in different\n\t\t * threads. The `ThreadCpuProfile` contains the `thread_id` that\n\t\t * the isolate was running in.\n\t\t * \n\t\t * @param title \n\t\t */\n\t\tstopCpuProfiler(title: string): Promise<ThreadCpuProfile[]>;\n\n\t}\n\n\texport type IsolateOptions = {\n\t\t/**\n\t\t * Memory limit that this isolate may use, in MB. Note that this is more of a guideline\n\t\t * instead of a strict limit. A determined attacker could use 2-3 times this limit before\n\t\t * their script is terminated. Against non-hostile code this limit should be pretty close. The\n\t\t * default is 128MB and the mimium is 8MB.\n\t\t */\n\t\tmemoryLimit?: number;\n\n\t\t/**\n\t\t * Enable v8 inspector support in this isolate. See `inspector-example.js` in this repository\n\t\t * for an example of how to use this.\n\t\t */\n\t\tinspector?: boolean;\n\n\t\t/**\n\t\t * This is an optional snapshot created from `createSnapshot` which will be used to initialize\n\t\t * the heap of this isolate.\n\t\t */\n\t\tsnapshot?: ExternalCopy<ArrayBuffer>;\n\n\t\t/**\n\t\t * Callback to be invoked when a *very bad* error occurs. If this is invoked it means that v8\n\t\t * has lost all control over the isolate, and all resources in use are totally unrecoverable. If\n\t\t * you receive this error you should log the error, stop serving requests, finish outstanding\n\t\t * work, and end the process by calling `process.abort()`.\n\t\t */\n\t\tonCatastrophicError?: (message: string) => void;\n\t};\n\n\texport type ContextOptions = {\n\t\tinspector?: boolean;\n\t};\n\n\texport type HeapStatistics = {\n\t\ttotal_heap_size: number;\n\t\ttotal_heap_size_executable: number;\n\t\ttotal_physical_size: number;\n\t\ttotal_available_size: number;\n\t\tused_heap_size: number;\n\t\theap_size_limit: number;\n\t\tmalloced_memory: number;\n\t\tpeak_malloced_memory: number;\n\t\tdoes_zap_garbage: number;\n\n\t\t/**\n\t\t * The total amount of currently allocated memory which is not included in the v8 heap but\n\t\t * counts against this isolate's \"memoryLimit\".\n\t\t */\n\t\texternally_allocated_size: number;\n\t};\n\n\texport type CompileModuleOptions = ScriptInfo & {\n\t\t/**\n\t\t * Callback which will be invoked the first time this module accesses `import.meta`. The `meta`\n\t\t * object will be passed as the first argument. This option may only be used when invoking\n\t\t * `compileModule` from within the same isolate.\n\t\t */\n\t\tmeta?: (meta: any) => void;\n\t}\n\n\t/**\n\t * A context is a sandboxed execution environment within an isolate. Each context contains its own\n\t * built-in objects and global space.\n\t */\n\texport class Context {\n\t\tprivate __ivm_context: undefined;\n\t\tprivate constructor();\n\n\t\t/**\n\t\t * `Reference` to this context's global object. Note that if you call `context.release()` the\n\t\t * global reference will be released as well.\n\t\t */\n\t\treadonly global: Reference<Record<number | string | symbol, any>>;\n\n\t\t/**\n\t\t * Compiles and executes a script within a context. This will return the last value evaluated,\n\t\t * as long as that value was transferable, otherwise `undefined` will be returned.\n\t\t */\n\t\teval<Options extends ContextEvalOptions>(\n\t\t\tcode: string, options?: Options\n\t\t): Promise<ResultTypeSync<Options>>; // `ResultTypeSync` used intentionally\n\t\tevalIgnored(code: string, options?: ContextEvalOptions): void\n\t\tevalSync<Options extends ContextEvalOptions>(\n\t\t\tcode: string, options?: Options\n\t\t): ResultTypeSync<Options>;\n\n\t\t/**\n\t\t * Compiles and runs code as if it were inside a function, similar to the seldom-used `new\n\t\t * Function(code)` constructor. You can pass arguments to the function and they will be\n\t\t * available as `$0`, `$1`, and so on. You can also use `return` from the code.\n\t\t */\n\t\tevalClosure<Options extends ContextEvalClosureOptions>(\n\t\t\tcode: string, arguments?: ArgumentsTypeBidirectional<Options>, options?: Options\n\t\t): Promise<ResultTypeBidirectionalSync<Options>>; // `ResultTypeBidirectionalSync` used intentionally\n\t\tevalClosureIgnored<Options extends ContextEvalClosureOptions>(\n\t\t\tcode: string, arguments?: ArgumentsTypeBidirectional<Options>, options?: Options\n\t\t): void\n\t\tevalClosureSync<Options extends ContextEvalClosureOptions>(\n\t\t\tcode: string, arguments?: ArgumentsTypeBidirectional<Options>, options?: Options\n\t\t): ResultTypeBidirectionalSync<Options>;\n\n\t\t/**\n\t\t * Releases this reference to the context. You can call this to free up v8 resources\n\t\t * immediately, or you can let the garbage collector handle it when it feels like it. Note that\n\t\t * if there are other references to this context it will not be disposed. This only affects this\n\t\t * reference to the context.\n\t\t */\n\t\trelease(): void;\n\t}\n\n\texport type ContextEvalOptions = RunOptions & ScriptOrigin & TransferOptions;\n\texport type ContextEvalClosureOptions = RunOptions & ScriptOrigin & TransferOptionsBidirectional;\n\n\t/**\n\t * A script is a compiled chunk of JavaScript which can be executed in any context within a single\n\t * isolate.\n\t */\n\texport class Script {\n\t\tprivate __ivm_script: undefined;\n\t\tprivate constructor();\n\n\t\t/**\n\t\t * Releases the reference to this script, allowing the script data to be garbage collected.\n\t\t * Functions and data created in the isolate by previous invocations to `script.run(...)` will\n\t\t * still be alive in their respective contexts-- this only means that you can't invoke\n\t\t * `script.run(...)` again with this reference.\n\t\t */\n\t\trelease(): void;\n\n\t\t/**\n\t\t * Runs a given script within a context. This will return the last value evaluated in a given\n\t\t * script, as long as that value was transferable, otherwise `undefined` will be returned. For\n\t\t * instance if your script was \"let foo = 1; let bar = 2; bar = foo + bar\" then the return value\n\t\t * will be 3 because that is the last expression.\n\t\t */\n\t\trun<Options extends ScriptRunOptions>(context: Context, options?: Options): ResultTypeAsync<Options>;\n\t\trunIgnored(context: Context, options?: ScriptRunOptions): void;\n\t\trunSync<Options extends ScriptRunOptions>(context: Context, options?: Options): ResultTypeSync<Options>;\n\t}\n\n\texport type ScriptRunOptions = RunOptions & ReleaseOptions & TransferOptions;\n\n\t/**\n\t * A JavaScript module. Note that a Module can only run in the isolate which created it.\n\t */\n\texport class Module {\n\t\tprivate __ivm_module: undefined;\n\t\tprivate constructor();\n\n\t\t/**\n\t\t * A read-only array of all dependency specifiers the module has.\n\t\t */\n\t\treadonly dependencySpecifiers: string[];\n\n\t\t/**\n\t\t * Returns a Reference containing all exported values.\n\t\t */\n\t\treadonly namespace: Reference<any>;\n\n\t\t/**\n\t\t * Instantiate the module together with all its dependencies. Calling this more than once on a\n\t\t * single module will have no effect.\n\t\t * @param context The context the module should use.\n\t\t * @param resolveCallback This callback is responsible for resolving all direct and indirect\n\t\t * dependencies of this module. It accepts two parameters: specifier and referrer. It must\n\t\t * return a Module instance or a promise which will be used to satisfy the dependency.\n\t\t */\n\t\tinstantiate(\n\t\t\tcontext: Context,\n\t\t\tresolveCallback: (\n\t\t\t\tspecifier: string,\n\t\t\t\treferrer: Module\n\t\t\t) => Module | Promise<Module>\n\t\t): Promise<void>;\n\t\tinstantiateSync(\n\t\t\tcontext: Context,\n\t\t\tresolveCallback: (specifier: string, referrer: Module) => Module\n\t\t): void;\n\n\t\t/**\n\t\t * Evaluate the module and return the last expression (same as script.run). If evaluate is\n\t\t * called more than once on the same module the return value from the first invocation will be\n\t\t * returned (or thrown).\n\t\t * @param options Optional\n\t\t */\n\t\tevaluate(options?: ScriptRunOptions): Promise<Transferable>;\n\t\tevaluateSync(options?: ScriptRunOptions): Transferable;\n\n\t\t/**\n\t\t * Releases this module. This behaves the same as other `.release()` methods.\n\t\t */\n\t\trelease(): void;\n\t}\n\n\t/**\n\t * A instance of Reference is a pointer to a value stored in any isolate.\n\t */\n\texport class Reference<T = any> {\n\t\tprivate __ivm_reference: T;\n\t\tconstructor(value: T, options?: { unsafeInherit?: boolean });\n\n\t\t/**\n\t\t * This is the typeof the referenced value, and is available at any time\n\t\t * from any isolate. Note that this differs from the real typeof operator in\n\t\t * that null is \"null\", and Symbols are \"object\".\n\t\t */\n\t\treadonly typeof: string;\n\n\t\t/**\n\t\t * Creates a copy of the referenced value and internalizes it into this isolate. This uses the\n\t\t * same copy rules as ExternalCopy.\n\t\t */\n\t\tcopy(): Promise<T>;\n\n\t\t/**\n\t\t * Creates a copy of the referenced value and internalizes it into this isolate. This uses the\n\t\t * same copy rules as ExternalCopy.\n\t\t *\n\t\t * @return JavaScript value of the reference.\n\t\t */\n\t\tcopySync(): T;\n\n\t\t/**\n\t\t * Will attempt to return the actual value or object pointed to by this reference. Note that in\n\t\t * order to call this function the reference must be owned by the current isolate, otherwise an\n\t\t * error will be thrown.\n\t\t */\n\t\tderef(options?: ReleaseOptions): T;\n\n\t\t/**\n\t\t * Returns an object, which when passed to another isolate will cause that isolate to\n\t\t * dereference the handle.\n\t\t */\n\t\tderefInto(options?: ReleaseOptions): Dereference<T>;\n\n\t\t/**\n\t\t * Releases this reference. If you're passing around a lot of references between isolates it's\n\t\t * wise to release the references when you are done. Otherwise you may run into issues with\n\t\t * isolates running out of memory because other isolates haven't garbage collected recently.\n\t\t * After calling this method all attempts to access the reference will throw an error.\n\t\t */\n\t\trelease(): void;\n\n\t\t/**\n\t\t * Delete a property from this reference, as if using `delete reference[property]`\n\t\t */\n\t\t delete(property: keyof T): Promise<void>;\n\t\t deleteIgnored(property: keyof T): void;\n\t\t deleteSync(property: keyof T): void;\n\n\t\t/**\n\t\t * Will access a reference as if using reference[property] and return a reference to that value.\n\t\t *\n\t\t * If the object is a proxy, or if the property is a getter, this method will throw.\n\t\t */\n\t\tget<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, options?: Options): ResultTypeAsync<Options & FallbackReference, T[Key]>;\n\t\tgetSync<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, options?: Options): ResultTypeSync<Options & FallbackReference, T[Key]>;\n\n\t\t/**\n\t\t * Will access a reference as if using reference[property] and return a reference to that value.\n\t\t */\n\t\tset<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): Promise<void>;\n\t\tsetIgnored<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): void;\n\t\tsetSync<Options extends TransferOptions, Key extends keyof T>(\n\t\t\tproperty: Key, value: ArgumentType<Options, T[Key]>, options?: Options): void;\n\n\t\t/**\n\t\t * Will attempt to invoke an object as if it were a function. If the return\n\t\t * value is transferable it will be returned to the called of apply,\n\t\t * otherwise an error will be thrown.\n\t\t */\n\t\tapply<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): ResultTypeBidirectionalAsync<Options & FallbackReference, ApplyResult<T>>;\n\t\tapplyIgnored<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options & FallbackReference, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): void;\n\t\tapplySync<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): ResultTypeBidirectionalSync<Options & FallbackReference, ApplyResult<T>>;\n\n\t\t/**\n\t\t * `applySyncPromise` is a special version of `applySync` which may only be invoked on functions\n\t\t * belonging to the default isolate AND may only be invoked from a non-default thread. Functions\n\t\t * invoked in this way may return a promise and the invoking isolate will wait for that promise\n\t\t * to resolve before resuming execution. You can use this to implement functions like\n\t\t * readFileSync in a way that doesn't block the default isolate. Note that the invoking isolate\n\t\t * will not respond to any async functions until this promise is resolved, however synchronous\n\t\t * functions will still function correctly. Misuse of this feature may result in deadlocked\n\t\t * isolates, though the default isolate will never be at risk of a deadlock.\n\t\t */\n\t\tapplySyncPromise<Options extends ReferenceApplyOptions>(\n\t\t\treceiver?: ArgumentType<Options['arguments'], ApplyArgumentThis<T>>,\n\t\t\targuments?: ArgumentsTypeBidirectional<Options, ApplyArguments<T>>,\n\t\t\toptions?: Options\n\t\t): ResultTypeBidirectionalSync<Options & FallbackReference, ApplyResult<T>>;\n\t}\n\n\t/**\n\t * Dummy type referencing a type dereferenced into a different Isolate.\n\t */\n\texport class Dereference<T> {\n\t\tprivate constructor();\n\t\tprivate __ivm_deref: T;\n\t}\n\n\texport type ReferenceApplyOptions = RunOptions & TransferOptionsBidirectional;\n\n\t/**\n\t * Instances of this class represent some value that is stored outside of any v8\n\t * isolate. This value can then be quickly copied into any isolate.\n\t */\n\texport class ExternalCopy<T = any> {\n\t\tprivate __ivm_external_copy: T;\n\n\t\t/**\n\t\t * Primitive values can be copied exactly as they are. Date objects will be copied as as Dates.\n\t\t * ArrayBuffers, TypedArrays, and DataViews will be copied in an efficient format.\n\t\t * SharedArrayBuffers will simply copy a reference to the existing memory and when copied into\n\t\t * another isolate the new SharedArrayBuffer will point to the same underlying data. After\n\t\t * passing a SharedArrayBuffer to ExternalCopy for the first time isolated-vm will take over\n\t\t * management of the underlying memory block, so a \"copied\" SharedArrayBuffer can outlive the\n\t\t * isolate that created the memory originally.\n\t\t *\n\t\t * All other objects will be copied in seralized form using the [structured clone\n\t\t * algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n\t\t *\n\t\t * `ExternalCopy` can copy objects with deeply nested *transferable* objects.\n\t\t */\n\t\tconstructor(value: T, options?: ExternalCopyOptions);\n\n\t\t/**\n\t\t * Static property which will return the total number of bytes that isolated-vm has allocated\n\t\t * outside of v8 due to instances of `ExternalCopy`.\n\t\t */\n\t\tstatic readonly totalExternalSize: number;\n\n\t\t/**\n\t\t * Internalizes the ExternalCopy data into this isolate.\n\t\t *\n\t\t * @return JavaScript value of the external copy.\n\t\t */\n\t\tcopy(options?: ExternalCopyCopyOptions): T;\n\n\t\t/**\n\t\t * Returns an object, which when passed to another isolate will cause that isolate to\n\t\t * internalize a copy of this value.\n\t\t */\n\t\tcopyInto(options?: ExternalCopyCopyOptions): Copy<T>;\n\n\t\t/**\n\t\t * Releases the reference to this copy. If there are other references to this copy elsewhere the\n\t\t * copy will still remain in memory, but this handle will no longer be active. Disposing\n\t\t * ExternalCopy instances isn't super important, v8 is a lot better at cleaning these up\n\t\t * automatically because there's no inter-isolate dependencies.\n\t\t */\n\t\trelease(): void;\n\t}\n\n\t/**\n\t * Dummy type referencing a type copied into a different Isolate.\n\t */\n\texport class Copy<T> {\n\t\tprivate constructor();\n\t\tprivate __ivm_copy: T;\n\t}\n\n\texport type ExternalCopyOptions = {\n\t\t/**\n\t\t * An array of `ArrayBuffer` instances to transfer ownership. This behaves in a similar way to\n\t\t * [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage).\n\t\t */\n\t\ttransferList?: any[];\n\t\t/**\n\t\t * If true this will release ownership of the given resource from this isolate. This operation\n\t\t * completes in constant time since it doesn't have to copy an arbitrarily large object. This\n\t\t * only applies to ArrayBuffer and TypedArray instances.\n\t\t */\n\t\ttransferOut?: boolean;\n\t};\n\n\texport type ExternalCopyCopyOptions = ReleaseOptions & {\n\t\t/**\n\t\t * If true this will transfer the resource directly into this isolate, invalidating the\n\t\t * ExternalCopy handle.\n\t\t */\n\t\ttransferIn?: boolean;\n\t};\n\n\t/**\n   * Callbacks can be used to create cross-isolate references to simple functions. This can be\n\t * easier and safer than dealing with the more flexible\n\t * [`Reference`](#class-reference-transferable) class. Arguments passed to and returned from\n\t * callbacks are always copied using the same method as\n\t * [`ExternalCopy`](#class-externalcopy-transferable). When transferred to another isolate,\n\t * instances of `Callback` will turn into a plain old function. Callbacks are created\n\t * automatically when passing functions to most isolated-vm functions.\n\t */\n\t export class Callback<T extends (...args: any[]) => any = any> {\n\t\tprivate __ivm_callback: T;\n\n\t\tconstructor(value: T, options?: CallbackOptions);\n\t}\n\n\texport type CallbackOptions = {\n\t\t/**\n\t\t * Callback will be invoked asynchronously and will return a promise.\n\t\t */\n\t\tasync?: boolean;\n\n\t\t/**\n\t\t * Callback will be invoked asynchronously and will return a value (default).\n\t\t */\n\t\tsync?: boolean;\n\n\t\t/**\n\t\t * Callback will be invoked asynchronously and will ignore the result (including exceptions).\n\t\t */\n\t\tignored?: boolean;\n\n\t\t// The following ensures only 1 invocation option is given.\n\t} & ({\n\t\tasync?: true;\n\t\tsync?: never;\n\t\tignored?: never;\n\t} | {\n\t\tasync?: never;\n\t\tsync?: true;\n\t\tignored?: never;\n\t} | {\n\t\tasync?: never;\n\t\tsync?: never;\n\t\tignored?: true;\n\t});\n\n\t/**\n\t * C++ native module for v8 representation.\n\t */\n\texport class NativeModule {\n\t\tprivate __ivm_native_module: undefined;\n\n\t\t/**\n\t\t * Instantiate a native module with the full path to the compiled library.\n\t\t * For instance, filename would represent the path to a .node file\n\t\t * compiled using node-gyp.\n\t\t *\n\t\t * @param filename Full path to compiled library.\n\t\t */\n\t\tconstructor(filename: string);\n\n\t\t/**\n\t\t * Instantiates the module with a Context by running the `InitForContext`\n\t\t * symbol, throws if that symbol is not present.\n\t\t *\n\t\t * Returned Reference<NativeModule> should be dereferenced into a context\n\t\t *\n\t\t * @param context Context to initialize the module with.\n\t\t */\n\t\tcreate(context: Context): Promise<Reference<any>>;\n\n\t\t/**\n\t\t * Synchronous version of `create`\n\t\t *\n\t\t * @param context Context to initialize the module with.\n\t\t */\n\t\tcreateSync(context: Context): Reference<any>;\n\t}\n\n\texport type ThreadCpuProfile = {\n\t\tthreadId: number;\n\t\tprofile: CpuProfile;\n\t}\n\n\texport type CpuProfile = {\n\t\tstartTime: number;\n\t\tendTime: number;\n\t\tsamples: number[];\n\t\ttimeDeltas: number[];\n\t\tnodes: Array<{\n\t\t\tid: number;\n\t\t\thitCount: number;\n\t\t\tchildren: number[];\n\t\t\tcallFrame: {\n\t\t\t\tfunctionName: string;\n\t\t\t\turl: string;\n\t\t\t\tscriptId: number;\n\t\t\t\tlineNubmer: number;\n\t\t\t\tcolumnNumber: number;\n\t\t\t\tbailoutReason?: string;\n\t\t\t};\n\t\t}>;\n\t}\n\n\texport type InspectorSession = {\n\t\tdispatchProtocolMessage(message: string): void;\n\t\tdispose(): void;\n\t\tonNotification: (message: string) => void;\n\t\tonResponse: (callId: number, message: string) => void;\n\t};\n\n\t/**\n\t * Most functions which compile or run code can produce and consume cached data. You can produce\n\t * cached data and use the data in later invocations to drastically speed up parsing of the same\n\t * script. You can even save this data to disk and use it in a different process. You can set both\n\t * `cachedData` and `produceCachedData`, in which case new cached data will only be produced if\n\t * the data supplied was invalid.\n\t */\n\texport type CachedDataOptions = {\n\t\t/**\n\t\t * This will consume cached compilation data from a previous call to this function. Please don't\n\t\t * use `produceCachedData` and `cachedData` options at the same time. `cachedDataRejected` will\n\t\t * be set to `true` if the supplied data was rejected by V8.\n\t\t */\n\t\tcachedData?: ExternalCopy<ArrayBuffer>;\n\t\t/**\n\t\t * Produce V8 cache data. Similar to the [VM.Script](https://nodejs.org/api/vm.html) option of\n\t\t * the same name. If this is true then the returned object will have `cachedData` set to an\n\t\t * ExternalCopy handle. Note that this differs from the VM.Script option slightly in that\n\t\t * `cachedDataProduced` is never set.\n\t\t */\n\t\tproduceCachedData?: boolean;\n\t};\n\n\texport type CachedDataResult = {\n\t\tcachedData?: ExternalCopy<ArrayBuffer>;\n\t\tproducedCacheData?: boolean;\n\t};\n\n\texport type ReleaseOptions = {\n\t\t/**\n\t\t * If true release() will automatically be called on this instance.\n\t\t */\n\t\trelease?: boolean;\n\t};\n\n\texport type RunOptions = {\n\t\t/**\n\t\t * Maximum amount of time in milliseconds this script is allowed to run before execution is\n\t\t * canceled. Default is no timeout.\n\t\t */\n\t\ttimeout?: number;\n\t};\n\n\t/**\n\t * You may optionally specify information on compiled code's filename. This is used in various\n\t * debugging contexts within v8, including stack traces and the inspector. It is recommended to\n\t * use a valid URI scheme, for example: `{ filename: 'file:///test.js' }`, otherwise some devtools\n\t * may malfunction.\n\t */\n\texport type ScriptOrigin = {\n\t\t/**\n\t\t * Filename of this source code\n\t\t */\n\t\tfilename?: string;\n\n\t\t/**\n\t\t * Column offset of this source code\n\t\t */\n\t\tcolumnOffset?: number;\n\n\t\t/**\n\t\t * Line offset of this source code\n\t\t */\n\t\tlineOffset?: number;\n\t};\n\n\texport type SnapshotScriptInfo = ScriptOrigin & {\n\t\t/**\n\t\t * Source code to set up this snapshot\n\t\t */\n\t\tcode: string;\n\t};\n\texport type ScriptInfo = CachedDataOptions & ScriptOrigin;\n\n\t/**\n\t * Any function which moves data between isolates will accept these transfer options. By default\n\t * only *[transferable]* values may pass between isolates. Without specifying one of these options\n\t * the function may ignore the value, throw, or wrap it in a reference depending on the context.\n\t *\n\t * More advanced situations like transferring ownership of `ArrayBuffer` instances will require\n\t * direct use of `ExternalCopy` or `Reference`.\n\t */\n\texport type TransferOptions = {\n\t\t/**\n\t\t * Automatically proxy any returned promises between isolates. This can be used in combination\n\t\t * with the other transfer options.\n\t\t */\n\t\tpromise?: boolean;\n\n\t\t/**\n\t\t * Automatically deep copy value\n\t\t */\n\t\tcopy?: boolean;\n\n\t\t/**\n\t\t * Automatically wrap value in `ExternalCopy` instance\n\t\t */\n\t\texternalCopy?: boolean;\n\n\t\t/**\n\t\t * Automatically wrap value in `Reference` instance\n\t\t */\n\t\treference?: boolean;\n\n\t\t// The following ensures only 1 transfer option is given.\n\t} & ({\n\t\t copy?: true;\n\t\t externalCopy?: never;\n\t\t reference?: never;\n\t} | {\n\t\tcopy?: never;\n\t\texternalCopy?: true;\n\t\treference?: never;\n\t} | {\n\t\tcopy?: never;\n\t\texternalCopy?: never;\n\t\treference?: true;\n\t });\n\n\texport type TransferOptionsBidirectional = {\n\t\t/**\n\t\t * `TransferOptions` for the values going *into* this isolate.\n\t\t */\n\t\targuments?: TransferOptions;\n\t\t/**\n\t\t * `TransferOptions` for the values coming *out* of this isolate.\n\t\t */\n\t\tresult?: TransferOptions;\n\t};\n\n\t// Discriminating types for TransferOptions\n\ttype WithPromise = { promise: true };\n\ttype AsCopy = { copy: true };\n\ttype AsExternal = { externalCopy: true };\n\ttype AsReference = { reference: true };\n\ttype FallbackReference = { _reference: true };\n\ttype ApplyAsReference = { result: AsReference };\n\ttype WithTransfer = AsCopy | AsExternal | AsReference;\n\n\t// Wraps a type in Promise<> if the options specify { promise: true }\n\ttype CheckPromise<Options, Result> = Options extends WithPromise ? Promise<Result> : Result;\n\n\t// Type of a single argument for functions that accept TransferOptions\n\ttype ArgumentType<Options, Type> =\n\t\t(Options extends WithTransfer ? Type | CheckPromise<Options, Type> :\n\t\tType extends Transferable ? Type | CheckPromise<Options, Type> :\n\t\tTransferable | CheckPromise<Options, Transferable>) |\n\t\tCopy<Type> | Dereference<Type>;\n\n\t// Return type for functions that accept TransferOptions\n\ttype ResultTypeBase<Options, Result> =\n\t\tOptions extends AsCopy ? Result :\n\t\tOptions extends AsExternal ? ExternalCopy<Result> :\n\t\tOptions extends AsReference ? Reference<Result> :\n\t\tResult extends Transferable ? Result :\n\t\tResult extends void ? void :\n\t\tOptions extends FallbackReference ? Reference<Result> :\n\t\tTransferable;\n\ttype ResultTypeAsync<Options extends TransferOptions, Result = any> = Promise<ResultTypeBase<Options, Result>>;\n\ttype ResultTypeSync<Options extends TransferOptions, Result = any> = CheckPromise<Options, ResultTypeBase<Options, Result>>;\n\n\t// Arguments type for functions that accept TransferOptionsBidirectional\n\ttype ArgumentsTypeBidirectional<Options extends TransferOptionsBidirectional, Args extends any[] = any[]> = {\n\t\t[Key in keyof Args]: ArgumentType<Options['arguments'] extends TransferOptions ? Options['arguments'] : {}, Args[Key]>\n\t};\n\n\t// Result type for functions that accept TransferOptionsBidirectional\n\ttype ResultTypeBidirectionalBase<Options extends TransferOptionsBidirectional, Result> =\n\t\tResultTypeBase<Options['result'] extends TransferOptions ? Options['result'] : {}, Result>;\n\ttype ResultTypeBidirectionalAsync<Options extends TransferOptionsBidirectional, Result = any> =\n\t\tPromise<ResultTypeBidirectionalBase<Options, Result>>;\n\ttype ResultTypeBidirectionalSync<Options extends TransferOptionsBidirectional, Result = any> =\n\t\tCheckPromise<Options['result'], ResultTypeBidirectionalBase<Options, Result>>;\n\n\t// Types for `Reference.apply`\n\ttype ApplyArguments<Value> = Value extends (...args: infer Args) => unknown ? Args : any[];\n\ttype ApplyArgumentThis<Value> = Value extends (this: infer This, ...args: any) => unknown ? This : undefined | null;\n\ttype ApplyResult<Value> = Value extends (...args: any) => infer Result ? Result : unknown;\n}\nexport = IsolatedVM;\n"
        },
        {
          "name": "isolated-vm.js",
          "type": "blob",
          "size": 0.0498046875,
          "content": "module.exports = require('./out/isolated_vm').ivm;\n"
        },
        {
          "name": "native-example",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.935546875,
          "content": "{\n  \"name\": \"isolated-vm\",\n  \"version\": \"5.0.3\",\n  \"description\": \"Access to multiple isolates\",\n  \"main\": \"isolated-vm.js\",\n  \"types\": \"isolated-vm.d.ts\",\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"scripts\": {\n    \"install\": \"prebuild-install || (node-gyp rebuild --release -j max && node-gyp clean)\",\n    \"rebuild\": \"node-gyp rebuild --release -j max\",\n    \"lint\": \"find src -name '*.cc' | xargs -n1 clang-tidy\",\n    \"test\": \"node test.js\"\n  },\n  \"dependencies\": {\n    \"prebuild-install\": \"^7.1.2\"\n  },\n  \"devDependencies\": {\n    \"isolated-vm\": \".\",\n    \"prebuild\": \"^13.0.1\"\n  },\n  \"binary\": {\n    \"module_path\": \"out\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/laverdet/isolated-vm.git\"\n  },\n  \"author\": \"https://github.com/laverdet/\",\n  \"license\": \"ISC\",\n  \"gypfile\": true,\n  \"bugs\": {\n    \"url\": \"https://github.com/laverdet/isolated-vm/issues\"\n  },\n  \"homepage\": \"https://github.com/laverdet/isolated-vm#readme\"\n}\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.js",
          "type": "blob",
          "size": 1.697265625,
          "content": "#!/usr/bin/env node\nlet fs = require('fs');\nlet spawn = require('child_process').spawn;\nlet path = require('path');\n\nlet ret = 0;\nlet passCount = 0, failCount = 0;\nfunction runTest(test, cb) {\n\t// Copy env variables\n\tlet env = {};\n\tfor (let ii in process.env) {\n\t\tenv[ii] = process.env[ii];\n\t}\n\tenv.NODE_PATH = __dirname;\n\n\t// Get extra args\n\tlet args = [ '--no-node-snapshot' ];\n\tlet testPath = path.join('tests', test);\n\tlet content = fs.readFileSync(testPath, 'utf8');\n\tlet match = /node-args: *(.+)/.exec(content);\n\tif (match) {\n\t\targs.push(...match[1].split(/ /g));\n\t}\n\targs.push(testPath);\n\n\t// Launch process\n\tlet proc = spawn(process.execPath, args, { env });\n\tproc.stdout.setEncoding('utf8');\n\tproc.stderr.setEncoding('utf8');\n\n\tlet stdout = '', stderr = '';\n\tproc.stdout.on('data', function(data) {\n\t\tstdout += data;\n\t});\n\tproc.stderr.on('data', function(data) {\n\t\tstderr += data;\n\t});\n\tproc.stdin.end();\n\n\t// Wait for completion\n\tprocess.stderr.write(`${test}: `);\n\tproc.on('exit', function(code, signal) {\n\t\tif (stdout !== 'pass\\n' || stderr !== '') {\n\t\t\t++failCount;\n\t\t\tret = 1;\n\t\t\tconsole.error(\n\t\t\t\t`*fail*\\n`+\n\t\t\t\t`code: ${code} signal: ${signal}\\n`+\n\t\t\t\t`stderr: ${stderr}\\n`+\n\t\t\t\t`stdout: ${stdout}`\n\t\t\t);\n\t\t} else if (code !== 0) {\n\t\t\t++failCount;\n\t\t\tret = 1;\n\t\t\tconsole.error(`fail (${code})`);\n\t\t} else {\n\t\t\t++passCount;\n\t\t\tconsole.error(`pass`);\n\t\t}\n\t\tcb();\n\t});\n}\n\nlet cb = function() {\n\tconsole.log('\\nCompleted: '+ passCount+ ' passed, '+ failCount+ ' failed.');\n\tprocess.exit(ret);\n};\nfs.readdirSync('./tests').sort().reverse().forEach(function(file) {\n\tif (/\\.js$/.test(file)) {\n\t\tcb = new function(cb) {\n\t\t\treturn function(err) {\n\t\t\t\tif (err) return cb(err);\n\t\t\t\trunTest(file, cb);\n\t\t\t};\n\t\t}(cb);\n\t}\n});\ncb();\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}