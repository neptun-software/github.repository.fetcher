{
  "metadata": {
    "timestamp": 1736565473431,
    "page": 330,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "KhronosGroup/Vulkan-Hpp",
      "stars": 3187,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-format_11",
          "type": "blob",
          "size": 2.59375,
          "content": "﻿---\nAccessModifierOffset : -2\nAlignAfterOpenBracket : Align\nAlignConsecutiveAssignments : true\nAlignConsecutiveDeclarations : true\nAlignConsecutiveMacros : true\nAlignEscapedNewlines : Left\nAlignOperands : true\nAlignTrailingComments : true\nAllowAllArgumentsOnNextLine : true\nAllowAllConstructorInitializersOnNextLine : true\nAllowAllParametersOfDeclarationOnNextLine : true\nAllowShortBlocksOnASingleLine : Empty\nAllowShortCaseLabelsOnASingleLine : true\nAllowShortFunctionsOnASingleLine : Empty\nAllowShortIfStatementsOnASingleLine : Never\nAllowShortLambdasOnASingleLine : All\nAllowShortLoopsOnASingleLine : false\nAlwaysBreakAfterReturnType : None\nAlwaysBreakBeforeMultilineStrings : true\nAlwaysBreakTemplateDeclarations : Yes\nBinPackArguments : false\nBinPackParameters : false\nBraceWrapping :\n    AfterCaseLabel : true\n    AfterClass : true\n    AfterControlStatement : Always\n    AfterEnum : true\n    AfterFunction : true\n    AfterNamespace : true\n    AfterStruct : true\n    AfterUnion : true\n    AfterExternBlock : true\n    BeforeCatch : true\n    BeforeElse : true\n    BeforeLambdaBody : true\n    IndentBraces : false\n    SplitEmptyFunction : true\n    SplitEmptyRecord : true\n    SplitEmptyNamespace : true\nBreakBeforeBinaryOperators : None\nBreakBeforeBraces : Custom\nBreakBeforeTernaryOperators : true\nBreakConstructorInitializers : BeforeComma\nBreakInheritanceList : BeforeComma\nBreakStringLiterals : false\nColumnLimit : 160\nCompactNamespaces : false\nConstructorInitializerAllOnOneLineOrOnePerLine : true\nConstructorInitializerIndentWidth : 2\nContinuationIndentWidth : 2\nCpp11BracedListStyle : false\nFixNamespaceComments : true\nIncludeBlocks : Regroup\nIndentCaseBlocks : true\nIndentCaseLabels : true\nIndentPPDirectives : AfterHash\nIndentWidth : 2\nIndentWrappedFunctionNames : true\nKeepEmptyLinesAtTheStartOfBlocks : false\nMaxEmptyLinesToKeep : 1\nNamespaceIndentation : All\nPointerAlignment : Middle\nReflowComments : true\nSortIncludes : true\nSortUsingDeclarations : true\nSpaceAfterCStyleCast : false\nSpaceAfterLogicalNot : false\nSpaceAfterTemplateKeyword : true\nSpaceBeforeAssignmentOperators : true\nSpaceBeforeCpp11BracedList : false\nSpaceBeforeCtorInitializerColon : true\nSpaceBeforeInheritanceColon : true\nSpaceBeforeParens : ControlStatements\nSpaceBeforeRangeBasedForLoopColon : true\nSpaceBeforeSquareBrackets : false\nSpaceInEmptyBlock : false\nSpaceInEmptyParentheses : false\nSpacesBeforeTrailingComments : 2\nSpacesInAngles : false\nSpacesInCStyleCastParentheses : false\nSpacesInConditionalStatement : true\nSpacesInContainerLiterals : false\nSpacesInParentheses : true\nSpacesInSquareBrackets : false\nStandard : Latest\nUseCRLF : true\nUseTab : Never\n...\n"
        },
        {
          "name": ".clang-format_12",
          "type": "blob",
          "size": 2.9072265625,
          "content": "﻿---\nAccessModifierOffset : -2\nAlignAfterOpenBracket : Align\nAlignConsecutiveAssignments : Consecutive\nAlignConsecutiveBitFields : Consecutive\nAlignConsecutiveDeclarations : Consecutive\nAlignConsecutiveMacros : Consecutive\nAlignEscapedNewlines : Left\nAlignOperands : AlignAfterOperator\nAlignTrailingComments : true\nAllowAllArgumentsOnNextLine : true\nAllowAllConstructorInitializersOnNextLine : true\nAllowAllParametersOfDeclarationOnNextLine : true\nAllowShortBlocksOnASingleLine : Empty\nAllowShortCaseLabelsOnASingleLine : true\nAllowShortEnumsOnASingleLine : true\nAllowShortFunctionsOnASingleLine : Empty\nAllowShortIfStatementsOnASingleLine : Never\nAllowShortLambdasOnASingleLine : All\nAllowShortLoopsOnASingleLine : false\nAlwaysBreakAfterReturnType : None\nAlwaysBreakBeforeMultilineStrings : true\nAlwaysBreakTemplateDeclarations : Yes\nBinPackArguments : false\nBinPackParameters : false\nBitFieldColonSpacing : Both\nBraceWrapping :\n    AfterCaseLabel : true\n    AfterClass : true\n    AfterControlStatement : Always\n    AfterEnum : true\n    AfterFunction : true\n    AfterNamespace : true\n    AfterStruct : true\n    AfterUnion : true\n    AfterExternBlock : true\n    BeforeCatch : true\n    BeforeElse : true\n    BeforeLambdaBody : true\n    BeforeWhile : false\n    IndentBraces : false\n    SplitEmptyFunction : true\n    SplitEmptyRecord : true\n    SplitEmptyNamespace : true\nBreakBeforeBinaryOperators : None\nBreakBeforeBraces : Custom\nBreakBeforeTernaryOperators : true\nBreakConstructorInitializers : BeforeComma\nBreakInheritanceList : BeforeComma\nBreakStringLiterals : false\nColumnLimit : 160\nCompactNamespaces : false\nConstructorInitializerAllOnOneLineOrOnePerLine : true\nConstructorInitializerIndentWidth : 2\nContinuationIndentWidth : 2\nCpp11BracedListStyle : false\nEmptyLineBeforeAccessModifier : LogicalBlock\nFixNamespaceComments : true\nIncludeBlocks : Regroup\nIndentCaseBlocks : true\nIndentCaseLabels : true\nIndentExternBlock : true\nIndentPPDirectives : AfterHash\nIndentRequires : false\nIndentWidth : 2\nIndentWrappedFunctionNames : true\nKeepEmptyLinesAtTheStartOfBlocks : false\nMaxEmptyLinesToKeep : 1\nNamespaceIndentation : All\nPointerAlignment : Middle\nReflowComments : true\nSortIncludes : true\nSortUsingDeclarations : true\nSpaceAfterCStyleCast : false\nSpaceAfterLogicalNot : false\nSpaceAfterTemplateKeyword : true\nSpaceAroundPointerQualifiers : Both\nSpaceBeforeAssignmentOperators : true\nSpaceBeforeCaseColon : false\nSpaceBeforeCpp11BracedList : false\nSpaceBeforeCtorInitializerColon : true\nSpaceBeforeInheritanceColon : true\nSpaceBeforeParens : ControlStatements\nSpaceBeforeRangeBasedForLoopColon : true\nSpaceBeforeSquareBrackets : false\nSpaceInEmptyBlock : false\nSpaceInEmptyParentheses : false\nSpacesBeforeTrailingComments : 2\nSpacesInAngles : false\nSpacesInCStyleCastParentheses : false\nSpacesInConditionalStatement : true\nSpacesInContainerLiterals : false\nSpacesInParentheses : true\nSpacesInSquareBrackets : false\nStandard : Latest\nUseCRLF : true\nUseTab : Never\n...\n"
        },
        {
          "name": ".clang-format_13",
          "type": "blob",
          "size": 3.166015625,
          "content": "﻿---\nAccessModifierOffset : -2\nAlignAfterOpenBracket : Align\nAlignArrayOfStructures : None\nAlignConsecutiveAssignments : Consecutive\nAlignConsecutiveBitFields : Consecutive\nAlignConsecutiveDeclarations : Consecutive\nAlignConsecutiveMacros : Consecutive\nAlignEscapedNewlines : Left\nAlignOperands : AlignAfterOperator\nAlignTrailingComments : true\nAllowAllArgumentsOnNextLine : true\nAllowAllConstructorInitializersOnNextLine : true\nAllowAllParametersOfDeclarationOnNextLine : true\nAllowShortBlocksOnASingleLine : Empty\nAllowShortCaseLabelsOnASingleLine : true\nAllowShortEnumsOnASingleLine : true\nAllowShortFunctionsOnASingleLine : Empty\nAllowShortIfStatementsOnASingleLine : Never\nAllowShortLambdasOnASingleLine : All\nAllowShortLoopsOnASingleLine : false\nAlwaysBreakAfterReturnType : None\nAlwaysBreakBeforeMultilineStrings : true\nAlwaysBreakTemplateDeclarations : Yes\nBinPackArguments : false\nBinPackParameters : false\nBitFieldColonSpacing : Both\nBraceWrapping :\n    AfterCaseLabel : true\n    AfterClass : true\n    AfterControlStatement : Always\n    AfterEnum : true\n    AfterFunction : true\n    AfterNamespace : true\n    AfterStruct : true\n    AfterUnion : true\n    AfterExternBlock : true\n    BeforeCatch : true\n    BeforeElse : true\n    BeforeLambdaBody : true\n    BeforeWhile : false\n    IndentBraces : false\n    SplitEmptyFunction : true\n    SplitEmptyRecord : true\n    SplitEmptyNamespace : true\nBreakBeforeBinaryOperators : None\nBreakBeforeBraces : Custom\nBreakBeforeTernaryOperators : true\nBreakConstructorInitializers : BeforeComma\nBreakInheritanceList : BeforeComma\nBreakStringLiterals : false\nColumnLimit : 160\nCompactNamespaces : false\nConstructorInitializerAllOnOneLineOrOnePerLine : true\nConstructorInitializerIndentWidth : 2\nContinuationIndentWidth : 2\nCpp11BracedListStyle : false\nEmptyLineAfterAccessModifier : Never\nEmptyLineBeforeAccessModifier : LogicalBlock\nFixNamespaceComments : true\nIncludeBlocks : Regroup\nIndentAccessModifiers : false\nIndentCaseBlocks : true\nIndentCaseLabels : true\nIndentExternBlock : true\nIndentPPDirectives : AfterHash\nIndentRequires : false\nIndentWidth : 2\nIndentWrappedFunctionNames : true\nKeepEmptyLinesAtTheStartOfBlocks : false\nLambdaBodyIndentation : Signature\nMaxEmptyLinesToKeep : 1\nNamespaceIndentation : All\nPPIndentWidth : -1\nPointerAlignment : Middle\nReferenceAlignment : Pointer\nReflowComments : true\nShortNamespaceLines : 0\nSortIncludes : true\nSortUsingDeclarations : true\nSpaceAfterCStyleCast : false\nSpaceAfterLogicalNot : false\nSpaceAfterTemplateKeyword : true\nSpaceAroundPointerQualifiers : Both\nSpaceBeforeAssignmentOperators : true\nSpaceBeforeCaseColon : false\nSpaceBeforeCpp11BracedList : false\nSpaceBeforeCtorInitializerColon : true\nSpaceBeforeInheritanceColon : true\nSpaceBeforeParens : ControlStatements\nSpaceBeforeRangeBasedForLoopColon : true\nSpaceBeforeSquareBrackets : false\nSpaceInEmptyBlock : false\nSpaceInEmptyParentheses : false\nSpacesBeforeTrailingComments : 2\nSpacesInAngles : false\nSpacesInCStyleCastParentheses : false\nSpacesInConditionalStatement : true\nSpacesInContainerLiterals : false\nSpacesInLineCommentPrefix : \n    Minimum : 1\n    Maximum : -1\nSpacesInParentheses : true\nSpacesInSquareBrackets : false\nStandard : Latest\nUseCRLF : true\nUseTab : Never\n...\n"
        },
        {
          "name": ".clang-format_14",
          "type": "blob",
          "size": 3.1611328125,
          "content": "﻿---\nAccessModifierOffset : -2\nAlignAfterOpenBracket : Align\nAlignArrayOfStructures : None\nAlignConsecutiveAssignments : Consecutive\nAlignConsecutiveBitFields : Consecutive\nAlignConsecutiveDeclarations : Consecutive\nAlignConsecutiveMacros : Consecutive\nAlignEscapedNewlines : Left\nAlignOperands : AlignAfterOperator\nAlignTrailingComments : true\nAllowAllArgumentsOnNextLine : true\nAllowAllParametersOfDeclarationOnNextLine : true\nAllowShortBlocksOnASingleLine : Empty\nAllowShortCaseLabelsOnASingleLine : true\nAllowShortEnumsOnASingleLine : true\nAllowShortFunctionsOnASingleLine : Empty\nAllowShortIfStatementsOnASingleLine : Never\nAllowShortLambdasOnASingleLine : All\nAllowShortLoopsOnASingleLine : false\nAlwaysBreakAfterReturnType : None\nAlwaysBreakBeforeMultilineStrings : true\nAlwaysBreakTemplateDeclarations : Yes\nBinPackArguments : false\nBinPackParameters : false\nBitFieldColonSpacing : Both\nBraceWrapping :\n    AfterCaseLabel : true\n    AfterClass : true\n    AfterControlStatement : Always\n    AfterEnum : true\n    AfterFunction : true\n    AfterNamespace : true\n    AfterStruct : true\n    AfterUnion : true\n    AfterExternBlock : true\n    BeforeCatch : true\n    BeforeElse : true\n    BeforeLambdaBody : true\n    BeforeWhile : false\n    IndentBraces : false\n    SplitEmptyFunction : true\n    SplitEmptyRecord : true\n    SplitEmptyNamespace : true\nBreakBeforeBinaryOperators : None\nBreakBeforeBraces : Custom\nBreakBeforeTernaryOperators : true\nBreakConstructorInitializers : BeforeComma\nBreakInheritanceList : BeforeComma\nBreakStringLiterals : false\nColumnLimit : 160\nCompactNamespaces : false\nConstructorInitializerIndentWidth : 2\nContinuationIndentWidth : 2\nCpp11BracedListStyle : false\nEmptyLineAfterAccessModifier : Never\nEmptyLineBeforeAccessModifier : LogicalBlock\nFixNamespaceComments : true\nIncludeBlocks : Regroup\nIndentAccessModifiers : false\nIndentCaseBlocks : true\nIndentCaseLabels : true\nIndentExternBlock : true\nIndentPPDirectives : AfterHash\nIndentRequires : false\nIndentWidth : 2\nIndentWrappedFunctionNames : true\nKeepEmptyLinesAtTheStartOfBlocks : false\nLambdaBodyIndentation : Signature\nMaxEmptyLinesToKeep : 1\nNamespaceIndentation : All\nPackConstructorInitializers : NextLine\nPPIndentWidth : -1\nPointerAlignment : Middle\nReferenceAlignment : Pointer\nReflowComments : true\nRemoveBracesLLVM : false\nSeparateDefinitionBlocks : Always\nShortNamespaceLines : 0\nSortIncludes : true\nSortUsingDeclarations : true\nSpaceAfterCStyleCast : false\nSpaceAfterLogicalNot : false\nSpaceAfterTemplateKeyword : true\nSpaceAroundPointerQualifiers : Both\nSpaceBeforeAssignmentOperators : true\nSpaceBeforeCaseColon : false\nSpaceBeforeCpp11BracedList : false\nSpaceBeforeCtorInitializerColon : true\nSpaceBeforeInheritanceColon : true\nSpaceBeforeParens : ControlStatements\nSpaceBeforeRangeBasedForLoopColon : true\nSpaceBeforeSquareBrackets : false\nSpaceInEmptyBlock : false\nSpaceInEmptyParentheses : false\nSpacesBeforeTrailingComments : 2\nSpacesInAngles : false\nSpacesInCStyleCastParentheses : false\nSpacesInConditionalStatement : true\nSpacesInContainerLiterals : false\nSpacesInLineCommentPrefix : \n    Minimum : 1\n    Maximum : -1\nSpacesInParentheses : true\nSpacesInSquareBrackets : false\nStandard : Latest\nUseCRLF : true\nUseTab : Never\n...\n"
        },
        {
          "name": ".clang-format_15",
          "type": "blob",
          "size": 3.2197265625,
          "content": "﻿---\nAccessModifierOffset : -2\nAlignAfterOpenBracket : Align\nAlignArrayOfStructures : None\nAlignConsecutiveAssignments : Consecutive\nAlignConsecutiveBitFields : Consecutive\nAlignConsecutiveDeclarations : Consecutive\nAlignConsecutiveMacros : Consecutive\nAlignEscapedNewlines : Left\nAlignOperands : AlignAfterOperator\nAlignTrailingComments : true\nAllowAllArgumentsOnNextLine : true\nAllowAllParametersOfDeclarationOnNextLine : true\nAllowShortBlocksOnASingleLine : Empty\nAllowShortCaseLabelsOnASingleLine : true\nAllowShortEnumsOnASingleLine : true\nAllowShortFunctionsOnASingleLine : Empty\nAllowShortIfStatementsOnASingleLine : Never\nAllowShortLambdasOnASingleLine : All\nAllowShortLoopsOnASingleLine : false\nAlwaysBreakAfterReturnType : None\nAlwaysBreakBeforeMultilineStrings : true\nAlwaysBreakTemplateDeclarations : Yes\nBinPackArguments : false\nBinPackParameters : false\nBitFieldColonSpacing : Both\nBraceWrapping :\n    AfterCaseLabel : true\n    AfterClass : true\n    AfterControlStatement : Always\n    AfterEnum : true\n    AfterFunction : true\n    AfterNamespace : true\n    AfterStruct : true\n    AfterUnion : true\n    AfterExternBlock : true\n    BeforeCatch : true\n    BeforeElse : true\n    BeforeLambdaBody : true\n    BeforeWhile : false\n    IndentBraces : false\n    SplitEmptyFunction : true\n    SplitEmptyRecord : true\n    SplitEmptyNamespace : true\nBreakBeforeBinaryOperators : None\nBreakBeforeBraces : Custom\nBreakBeforeTernaryOperators : true\nBreakConstructorInitializers : BeforeComma\nBreakInheritanceList : BeforeComma\nBreakStringLiterals : false\nColumnLimit : 160\nCompactNamespaces : false\nConstructorInitializerIndentWidth : 2\nContinuationIndentWidth : 2\nCpp11BracedListStyle : false\nEmptyLineAfterAccessModifier : Never\nEmptyLineBeforeAccessModifier : LogicalBlock\nFixNamespaceComments : true\nIncludeBlocks : Regroup\nIndentAccessModifiers : false\nIndentCaseBlocks : true\nIndentCaseLabels : true\nIndentExternBlock : true\nIndentPPDirectives : AfterHash\nIndentRequiresClause : false\nIndentWidth : 2\nIndentWrappedFunctionNames : true\nInsertBraces : false\nKeepEmptyLinesAtTheStartOfBlocks : false\nLambdaBodyIndentation : Signature\nMaxEmptyLinesToKeep : 1\nNamespaceIndentation : All\nPackConstructorInitializers : NextLine\nPPIndentWidth : -1\nPointerAlignment : Middle\nReferenceAlignment : Pointer\nReflowComments : true\nRemoveBracesLLVM : false\nRequiresClausePosition : OwnLine\nSeparateDefinitionBlocks : Always\nShortNamespaceLines : 0\nSortIncludes : true\nSortUsingDeclarations : true\nSpaceAfterCStyleCast : false\nSpaceAfterLogicalNot : false\nSpaceAfterTemplateKeyword : true\nSpaceAroundPointerQualifiers : Both\nSpaceBeforeAssignmentOperators : true\nSpaceBeforeCaseColon : false\nSpaceBeforeCpp11BracedList : false\nSpaceBeforeCtorInitializerColon : true\nSpaceBeforeInheritanceColon : true\nSpaceBeforeParens : ControlStatements\nSpaceBeforeRangeBasedForLoopColon : true\nSpaceBeforeSquareBrackets : false\nSpaceInEmptyBlock : false\nSpaceInEmptyParentheses : false\nSpacesBeforeTrailingComments : 2\nSpacesInAngles : false\nSpacesInCStyleCastParentheses : false\nSpacesInConditionalStatement : true\nSpacesInContainerLiterals : false\nSpacesInLineCommentPrefix : \n    Minimum : 1\n    Maximum : -1\nSpacesInParentheses : true\nSpacesInSquareBrackets : false\nStandard : Latest\nUseCRLF : true\nUseTab : Never\n...\n"
        },
        {
          "name": ".clang-format_7",
          "type": "blob",
          "size": 2.267578125,
          "content": "﻿---\nAccessModifierOffset : -2\nAlignAfterOpenBracket : Align\nAlignConsecutiveAssignments : Consecutive\nAlignConsecutiveDeclarations : Consecutive\nAlignEscapedNewlines : Left\nAlignOperands : true\nAlignTrailingComments : true\nAllowAllParametersOfDeclarationOnNextLine : true\nAllowShortBlocksOnASingleLine : false\nAllowShortCaseLabelsOnASingleLine : true\nAllowShortFunctionsOnASingleLine : Empty\nAllowShortIfStatementsOnASingleLine : false\nAllowShortLoopsOnASingleLine : false\nAlwaysBreakAfterReturnType : None\nAlwaysBreakBeforeMultilineStrings : true\nAlwaysBreakTemplateDeclarations : Yes\nBinPackArguments : false\nBinPackParameters : false\nBraceWrapping :\n    AfterClass : true\n    AfterControlStatement : true\n    AfterEnum : true\n    AfterFunction : true\n    AfterNamespace : true\n    AfterStruct : true\n    AfterUnion : true\n    AfterExternBlock : true\n    BeforeCatch : true\n    BeforeElse : true\n    BeforeWhile : false\n    IndentBraces : false\n    SplitEmptyFunction : true\n    SplitEmptyRecord : true\n    SplitEmptyNamespace : true\nBreakBeforeBinaryOperators : None\nBreakBeforeBraces : Custom\nBreakBeforeTernaryOperators : true\nBreakConstructorInitializers : BeforeComma\nBreakInheritanceList : BeforeComma\nBreakStringLiterals : false\nColumnLimit : 160\nCompactNamespaces : false\nConstructorInitializerAllOnOneLineOrOnePerLine : true\nConstructorInitializerIndentWidth : 2\nContinuationIndentWidth : 2\nCpp11BracedListStyle : false\nFixNamespaceComments : true\nIncludeBlocks : Regroup\nIndentCaseLabels : true\nIndentPPDirectives : AfterHash\nIndentWidth : 2\nIndentWrappedFunctionNames : true\nKeepEmptyLinesAtTheStartOfBlocks : false\nMaxEmptyLinesToKeep : 1\nNamespaceIndentation : All\nPointerAlignment : Middle\nReflowComments : true\nSortIncludes : true\nSortUsingDeclarations : true\nSpaceAfterCStyleCast : false\nSpaceAfterTemplateKeyword : true\nSpaceBeforeAssignmentOperators : true\nSpaceBeforeCpp11BracedList : false\nSpaceBeforeCtorInitializerColon : true\nSpaceBeforeInheritanceColon : true\nSpaceBeforeParens : ControlStatements\nSpaceBeforeRangeBasedForLoopColon : true\nSpaceInEmptyParentheses : false\nSpacesBeforeTrailingComments : 2\nSpacesInAngles : false\nSpacesInCStyleCastParentheses : false\nSpacesInContainerLiterals : false\nSpacesInParentheses : true\nSpacesInSquareBrackets : false\nStandard : Cpp11\nUseTab : Never\n...\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.4189453125,
          "content": "[submodule \"glm\"]\n\tpath = glm\n\turl = https://github.com/g-truc/glm.git\n[submodule \"glslang\"]\n\tpath = glslang\n\turl = https://github.com/KhronosGroup/glslang.git\n[submodule \"tinyxml2\"]\n\tpath = tinyxml2\n\turl = https://github.com/leethomason/tinyxml2.git\n[submodule \"Vulkan-Headers\"]\n\tpath = Vulkan-Headers\n\turl = https://github.com/KhronosGroup/Vulkan-Headers.git\n[submodule \"glfw\"]\n\tpath = glfw\n\turl = https://github.com/glfw/glfw\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 17.67578125,
          "content": "# Copyright(c) 2015-2018, NVIDIA CORPORATION. All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#  * Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#  * Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#  * Neither the name of NVIDIA CORPORATION nor the names of its\n#    contributors may be used to endorse or promote products derived\n#    from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nif ( NOT CMAKE_CXX_STANDARD )\n\tset( CMAKE_CXX_STANDARD 11 )\nendif()\n\n# all the options for this project\noption( VULKAN_HPP_PRECOMPILE \"Precompile vulkan.hpp and vulkan_raii.hpp for sample builds\" ON )\noption( VULKAN_HPP_RUN_GENERATOR \"Run the HPP generator\" OFF )\noption( VULKAN_HPP_SAMPLES_BUILD \"Build samples\" OFF )\noption( VULKAN_HPP_TESTS_BUILD \"Build tests\" OFF )\noption( VULKAN_HPP_SAMPLES_BUILD_ONLY_DYNAMIC \"Build only dynamic. Required in case the Vulkan SDK is not available\" OFF )\noption( VULKAN_HPP_TESTS_BUILD_ONLY_DYNAMIC \"Build only dynamic\" OFF )\noption( VULKAN_HPP_BUILD_WITH_LOCAL_VULKAN_HPP \"Build with local Vulkan headers\" ON )\noption( VULKAN_HPP_ENABLE_CPP20_MODULES \"Build Vulkan-Hpp as C++20 module; requires minimum CMake version 3.28\" OFF )\noption( VULKAN_HPP_ENABLE_STD_MODULE \"Build Vulkan-Hpp with import std; requires minimum CMake version 3.30\" OFF )\noption( VULKAN_HPP_CPP20_MODULE_DYNAMIC_DISPATCHER \"Build C++20 module with dynamic Dispatcher\" ON )\n\nif ( VULKAN_HPP_ENABLE_CPP20_MODULES )\n\tcmake_minimum_required( VERSION 3.28 )\nelse()\n\tcmake_minimum_required( VERSION 3.12 )\nendif()\n\nproject( VulkanHppGenerator LANGUAGES CXX )\n\nfunction( vulkan_hpp__setup_platform )\n\tset( options )\n\tset( oneValueArgs NAME )\n\tset( multiValueArgs )\n\tcmake_parse_arguments( TARGET \"{options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\tif( WIN32 )\n\t\ttarget_compile_definitions( ${TARGET_NAME} PUBLIC VK_USE_PLATFORM_WIN32_KHR )\n\telseif( APPLE )\n\t\ttarget_compile_definitions( ${TARGET_NAME} PUBLIC VK_USE_PLATFORM_METAL_EXT )\n\telseif( UNIX )\n\t\ttarget_compile_definitions( ${TARGET_NAME} PUBLIC VK_USE_PLATFORM_XCB_KHR )\n\telse()\n\t\tmessage( FATAL_ERROR, \"Vulkan-Hpp: unhandled platform!\" )\n\tendif()\n\tif( !MSVC )\n\t\ttarget_compile_options( ${TARGET_NAME} PRIVATE -fno-strict-aliasing )\n\tendif()\nendfunction()\n\nfunction( vulkan_hpp__setup_vulkan_include )\n\tset( options )\n\tset( oneValueArgs NAME )\n\tset( multiValueArgs )\n\tcmake_parse_arguments( TARGET \"{options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\t\n\tif( VULKAN_HPP_BUILD_WITH_LOCAL_VULKAN_HPP )\n\t\ttarget_include_directories( ${TARGET_NAME} PUBLIC \"${CMAKE_CURRENT_FUNCTION_LIST_DIR}\" )\n\t\ttarget_include_directories( ${TARGET_NAME} PUBLIC \"${CMAKE_CURRENT_FUNCTION_LIST_DIR}/Vulkan-Headers/include\" )\n\t\tif( VULKAN_HPP_RUN_GENERATOR )\n\t\t\tadd_dependencies( ${TARGET_NAME} build_vulkan_hpp )\n\t\tendif()\n\telse()\n\t\ttarget_include_directories( ${TARGET_NAME} PUBLIC \"${Vulkan_INCLUDE_DIRS}\" )\n\tendif()\nendfunction()\n\nfunction( vulkan_hpp__setup_warning_level )\n\tset( options )\n\tset( oneValueArgs NAME )\n\tset( multiValueArgs )\n\tcmake_parse_arguments( TARGET \"{options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\tif( MSVC )\n\t\ttarget_compile_options(${TARGET_NAME} PRIVATE /W4 /WX )\n\t\tif( MSVC_VER GREATER_EQUAL 1910 )\n\t\t\ttarget_compile_options( ${TARGET_NAME} PRIVATE /permissive- )\n\t\tendif()\n\telse()\n\t\ttarget_compile_options( ${TARGET_NAME} PRIVATE -Wall -Wextra -pedantic -Werror )\n\tendif()\nendfunction()\n\nfunction( vulkan_hpp__setup_project )\n\tset( options )\n\tset( oneValueArgs NAME )\n\tset( multiValueArgs )\n\tcmake_parse_arguments( TARGET \"{options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\tproject( ${TARGET_NAME} LANGUAGES CXX )\nendfunction()\n\nfunction( vulkan_hpp__setup_library )\n\tset( options SHARED )\n\tset( oneValueArgs FOLDER NAME )\n\tset( multiValueArgs HEADERS SOURCES )\n\tcmake_parse_arguments( TARGET \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\tvulkan_hpp__setup_project( NAME ${TARGET_NAME} )\n\n\tif( \"${TARGET_SOURCES}\" STREQUAL \"\" )\n\t\tadd_library( ${TARGET_NAME} INTERFACE ${TARGET_HEADERS} )\n\telse()\n\t\tif( ${TARGET_SHARED} )\n\t\t\tadd_library( ${TARGET_NAME} SHARED ${TARGET_SOURCES} ${TARGET_HEADERS} )\n\t\telse()\n\t\t\tadd_library( ${TARGET_NAME} ${TARGET_SOURCES} ${TARGET_HEADERS} )\n\t\tendif()\n\t\tvulkan_hpp__setup_platform( NAME ${TARGET_NAME} )\n\t\tvulkan_hpp__setup_vulkan_include( NAME ${TARGET_NAME} )\n\t\tvulkan_hpp__setup_warning_level( NAME ${TARGET_NAME} )\n\t\tset_target_properties( ${TARGET_NAME} PROPERTIES CXX_STANDARD_REQUIRED ON )\n\tendif()\n\tset_target_properties( ${TARGET_NAME} PROPERTIES FOLDER ${TARGET_FOLDER} )\nendfunction()\n\nfunction( vulkan_hpp__setup_sample )\n\tset( options )\n\tset( oneValueArgs FOLDER NAME PCH_REUSE )\n\tset( multiValueArgs HEADERS INCLUDE_DIRS LIBS PCH SOURCES )\n\tcmake_parse_arguments( TARGET \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\tif( NOT (VULKAN_HPP_SAMPLES_BUILD_ONLY_DYNAMIC AND VULKAN_HPP_BUILD_WITH_LOCAL_VULKAN_HPP) )\n\t\tfind_package( Vulkan REQUIRED )\n\tendif()\n\n\tvulkan_hpp__setup_project( NAME ${TARGET_NAME} )\n\n\tadd_executable( ${TARGET_NAME} ${TARGET_HEADERS} ${TARGET_SOURCES} )\n\n\tvulkan_hpp__setup_platform( NAME ${TARGET_NAME} )\n\tvulkan_hpp__setup_vulkan_include( NAME ${TARGET_NAME} )\n\tvulkan_hpp__setup_warning_level( NAME ${TARGET_NAME} )\n\n\tset_target_properties( ${TARGET_NAME} PROPERTIES CXX_STANDARD_REQUIRED ON )\n\n\tif( TARGET_FOLDER )\n\t\tset_target_properties( ${TARGET_NAME} PROPERTIES FOLDER \"${TARGET_FOLDER}\" )\n\tendif()\n\n\tif( TARGET_INCLUDE_DIRS )\n\t\ttarget_include_directories( ${TARGET_NAME} PUBLIC ${TARGET_INCLUDE_DIRS} )\n\tendif()\n\n\tif( TARGET_LIBS )\n\t\ttarget_link_libraries( ${TARGET_NAME} PRIVATE \"${TARGET_LIBS}\" )\n\tendif()\n\n\tif( VULKAN_HPP_PRECOMPILE )\n\t\tif( TARGET_PCH_REUSE )\n\t\t\ttarget_precompile_headers( ${TARGET_NAME} REUSE_FROM \"${TARGET_PCH_REUSE}\" )\n\t\telseif( TARGET_PCH )\n\t\t\ttarget_precompile_headers( ${TARGET_NAME} PRIVATE \"${TARGET_PCH}\" )\n\t\tendif()\n\tendif()\nendfunction()\n\nfunction( vulkan_hpp__setup_sample_static )\n\tset( options )\n\tset( oneValueArgs NAME )\n\tset( multiValueArgs )\n\tcmake_parse_arguments( TARGET \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\tif( NOT VULKAN_HPP_SAMPLES_BUILD_ONLY_DYNAMIC )\n\t\tif( NOT TARGET_NAME )\n\t\t\tmessage( FATAL_ERROR \"NAME must be defined in vulkan_hpp__setup_sample_static\" )\n\t\tendif()\n\n\t\tfind_package( Vulkan REQUIRED )\n\n\t\tvulkan_hpp__setup_sample(\n\t\t\tNAME         ${TARGET_NAME}\n\t\t\tFOLDER       Samples\n\t\t\tPCH          <vulkan/vulkan.hpp>\n\t\t\tSOURCES      ${TARGET_NAME}.cpp\n\t\t\tLIBS         ${Vulkan_LIBRARIES} )\n\n\t\ttarget_compile_definitions( ${TARGET_NAME} PUBLIC VULKAN_HPP_DISPATCH_LOADER_DYNAMIC=0 )\n\tendif()\nendfunction()\n\nfunction( vulkan_hpp__setup_sample_dynamic )\n\tset( options )\n\tset( oneValueArgs NAME )\n\tset( multiValueArgs HEADERS INCLUDE_DIRS SOURCES )\n\tcmake_parse_arguments( TARGET \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\tif( NOT TARGET_NAME )\n\t\tmessage( FATAL_ERROR \"NAME must be defined in vulkan_hpp__setup_sample_dynamic\" )\n\tendif()\n\tif( NOT TARGET_SOURCES )\n\t\tset( TARGET_SOURCES ${TARGET_NAME}.cpp )\n\tendif()\n\n\tvulkan_hpp__setup_sample(\n\t\tNAME         ${TARGET_NAME}\n\t\tFOLDER       Samples\n\t\tPCH_REUSE    utils\n\t\tINCLUDE_DIRS ${TARGET_INCLUDE_DIRS}\n\t\tHEADERS      ${TARGET_HEADERS}\n\t\tSOURCES      ${TARGET_SOURCES}\n\t\tLIBS         utils )\nendfunction()\n\nfunction( vulkan_hpp__setup_sample_raii )\n\tset( options )\n\tset( oneValueArgs NAME )\n\tset( multiValueArgs HEADERS INCLUDE_DIRS SOURCES )\n\tcmake_parse_arguments( TARGET \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\tif( NOT TARGET_NAME )\n\t\tmessage( FATAL_ERROR \"NAME must be defined in vulkan_hpp__setup_sample_raii\" )\n\tendif()\n\tif( NOT TARGET_SOURCES )\n\t\tset( TARGET_SOURCES ${TARGET_NAME}.cpp )\n\tendif()\n\n\tvulkan_hpp__setup_sample(\n\t\tNAME         RAII_${TARGET_NAME}\n\t\tFOLDER       RAII_Samples\n\t\tPCH_REUSE    utils\n\t\tINCLUDE_DIRS ${TARGET_INCLUDE_DIRS}\n\t\tHEADERS      ${TARGET_HEADERS}\n\t\tSOURCES      ${TARGET_SOURCES}\n\t\tLIBS         utils )\nendfunction()\n\nfunction( vulkan_hpp__setup_test )\n\tset( options NO_UTILS )\n\tset( oneValueArgs CXX_STANDARD NAME )\n\tset( multiValueArgs LIBRARIES )\n\tcmake_parse_arguments( TARGET \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\tif( NOT (VULKAN_HPP_TESTS_BUILD_ONLY_DYNAMIC AND VULKAN_HPP_BUILD_WITH_LOCAL_VULKAN_HPP) )\n\t\tfind_package( Vulkan REQUIRED )\n\tendif()\n\n\tif( NOT TARGET_NAME )\n\t\tmessage( FATAL_ERROR \"NAME must be defined in vulkan_hpp__setup_test\" )\n\tendif()\n\tif( NOT TARGET_CXX_STANDARD )\n\t\tset( TARGET_CXX_STANDARD ${CMAKE_CXX_STANDARD} )\n\tendif()\n\n\tvulkan_hpp__setup_project( NAME ${TARGET_NAME} )\n\n\tadd_executable( ${TARGET_NAME} ${TARGET_NAME}.cpp )\n\n\tvulkan_hpp__setup_platform( NAME ${TARGET_NAME} )\n\tvulkan_hpp__setup_vulkan_include( NAME ${TARGET_NAME} )\n\tvulkan_hpp__setup_warning_level( NAME ${TARGET_NAME} )\n\n\tset_target_properties( ${TARGET_NAME} PROPERTIES CXX_STANDARD ${TARGET_CXX_STANDARD} CXX_STANDARD_REQUIRED ON FOLDER \"Tests\" )\n\ttarget_include_directories( ${TARGET_NAME} PUBLIC ${VulkanHeaders_INCLUDE_DIR} )\n\ttarget_include_directories( ${TARGET_NAME} PUBLIC \"${CMAKE_CURRENT_FUNCTION_LIST_DIR}/glm\" )\n\tif ( NOT ${TARGET_NO_UTILS} )\n\t\ttarget_link_libraries( ${TARGET_NAME} PRIVATE utils )\n\tendif()\n\ttarget_link_libraries( ${TARGET_NAME} PRIVATE ${TARGET_LIBRARIES} )\nendfunction()\n\nset_property( GLOBAL PROPERTY USE_FOLDERS ON )\n\n# find a clang-format version to format the generated header files\nfind_program(CLANG_FORMAT_EXECUTABLE NAMES clang-format)\nif( CLANG_FORMAT_EXECUTABLE )\n\t# get the clang-format version string\n\texecute_process( COMMAND ${CLANG_FORMAT_EXECUTABLE} \"--version\" OUTPUT_VARIABLE clangFormatVersion )\n\t# filter out the actual version\n\tstring( REGEX MATCH [0123456789.]+ clangFormatVersion \"${clangFormatVersion}\" )\n\t# we need at least version 7.0.0 !\n\tif( clangFormatVersion VERSION_LESS 7.0.0 )\n\t\tmessage( WARNING \" Found too old clang-format version <\" ${clangFormatVersion} \">, we need version 7 and up to nicely format vulkan.hpp and vulkan_raii.hpp\" )\n\telse()\n\t\tmessage( STATUS \" Found clang-format version <\" ${clangFormatVersion} \">.\" )\n\t\tadd_definitions( -DCLANG_FORMAT_EXECUTABLE=\"${CLANG_FORMAT_EXECUTABLE}\" )\n\t\tif( clangFormatVersion VERSION_LESS 11.0.0 )\n\t\t\tmessage( STATUS \" Using .clang-format version 7.\" )\n\t\t\tfile( READ \".clang-format_7\" clangFormat )\n\t\telseif( clangFormatVersion VERSION_LESS 12.0.0 )\n\t\t\tmessage( STATUS \" Using .clang-format version 11.\" )\n\t\t\tfile( READ \".clang-format_11\" clangFormat )\n\t\telseif( clangFormatVersion VERSION_LESS 13.0.0 )\n\t\t\tmessage( STATUS \" Using .clang-format version 12.\" )\n\t\t\tfile( READ \".clang-format_12\" clangFormat )\n\t\telseif( clangFormatVersion VERSION_LESS 14.0.0 )\n\t\t\tmessage( STATUS \" Using .clang-format version 13.\" )\n\t\t\tfile( READ \".clang-format_13\" clangFormat )\n\t\telseif( clangFormatVersion VERSION_LESS 15.0.0 )\n\t\t\tmessage( STATUS \" Using .clang-format version 14.\" )\n\t\t\tfile( READ \".clang-format_14\" clangFormat )\n\t\telse()\n\t\t\tmessage(STATUS \" Using .clang-format version 15.\" )\n\t\t\tfile( READ \".clang-format_15\" clangFormat )\n\t\tendif()\n\t\tfile( WRITE \".clang-format\" ${clangFormat} )\n\tendif()\nelse()\n\tmessage( WARNING \" Could not find clang-format. Generated vulkan.hpp and vulkan_raii.hpp will not be nicely formatted.\" )\nendif()\n\n# look for the file vk.xml, the ultimate source of truth for vulkan, to generate the headers from\nif( NOT DEFINED VulkanRegistry_DIR )\n\tif( DEFINED VULKAN_HPP_VULKAN_HEADERS_SRC_DIR )\n\t\tset( VulkanRegistry_DIR \"${VULKAN_HPP_VULKAN_HEADERS_SRC_DIR}/registry\" )\n\telse()\n\t\tset( VulkanRegistry_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/Vulkan-Headers/registry\" )\n\tendif()\nendif()\nfile( TO_NATIVE_PATH ${VulkanRegistry_DIR}/vk.xml vk_spec )\nstring( REPLACE \"\\\\\" \"\\\\\\\\\" vk_spec ${vk_spec} )\n\n# gather the tinyxml2 sources, to be used directly in the generator project\nif( NOT DEFINED VULKAN_HPP_TINYXML2_SRC_DIR )\n\tset( VULKAN_HPP_TINYXML2_SRC_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/tinyxml2\" )\nendif()\nset( TINYXML2_SOURCES ${VULKAN_HPP_TINYXML2_SRC_DIR}/tinyxml2.cpp )\nset( TINYXML2_HEADERS ${VULKAN_HPP_TINYXML2_SRC_DIR}/tinyxml2.h )\nsource_group( TinyXML2 FILES ${TINYXML2_HEADERS} ${TINYXML2_SOURCES} )\n\n# Build Vulkan-Hpp as a module\nif( VULKAN_HPP_ENABLE_CPP20_MODULES )\n\t# create a target to provide VulkanHpp as C++20 module\n\tadd_library( VulkanHppModule )\n\tset_target_properties( VulkanHppModule PROPERTIES\n\t\tCXX_STANDARD_REQUIRED ON\n\t\tCXX_EXTENSIONS OFF )\n\tif ( VULKAN_HPP_CPP20_MODULE_DYNAMIC_DISPATCHER )\n\t\ttarget_compile_definitions( VulkanHppModule PUBLIC VULKAN_HPP_DISPATCH_LOADER_DYNAMIC=1 )\n\telse()\n\t\ttarget_compile_definitions( VulkanHppModule PUBLIC VULKAN_HPP_DISPATCH_LOADER_DYNAMIC=0 )\n\tendif()\n\t\tif( VULKAN_HPP_ENABLE_STD_MODULE )\n\t\ttarget_compile_features( VulkanHppModule PUBLIC cxx_std_23 )\n\t\tset_target_properties( VulkanHppModule PROPERTIES CXX_MODULE_STD ON )\n\telse()\n\t\ttarget_compile_features( VulkanHppModule PUBLIC cxx_std_20 )\n\tendif()\n\ttarget_sources( VulkanHppModule\n\t\tPUBLIC\n\t\tFILE_SET vulkan_module_file BASE_DIRS ${CMAKE_CURRENT_SOURCE_DIR} TYPE CXX_MODULES FILES vulkan/vulkan.cppm )\n\ttarget_include_directories( VulkanHppModule PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} )\n\ttarget_include_directories( VulkanHppModule PUBLIC \"${CMAKE_CURRENT_SOURCE_DIR}/Vulkan-Headers/include\" )\nendif()\n\n# The generator executable\nadd_executable( VulkanHppGenerator VulkanHppGenerator.cpp VulkanHppGenerator.hpp XMLHelper.hpp ${TINYXML2_SOURCES} ${TINYXML2_HEADERS} )\nvulkan_hpp__setup_warning_level( NAME VulkanHppGenerator )\ntarget_compile_definitions( VulkanHppGenerator PUBLIC BASE_PATH=\"${CMAKE_CURRENT_SOURCE_DIR}\" VK_SPEC=\"${vk_spec}\" )\ntarget_include_directories( VulkanHppGenerator PRIVATE ${VULKAN_HPP_TINYXML2_SRC_DIR} )\nset_target_properties( VulkanHppGenerator PROPERTIES CXX_STANDARD 20 CXX_STANDARD_REQUIRED ON )\nif( UNIX )\n\ttarget_link_libraries( VulkanHppGenerator PUBLIC pthread )\nendif()\n\n# The video generator executable\nadd_executable( VideoHppGenerator VideoHppGenerator.cpp VideoHppGenerator.hpp XMLHelper.hpp ${TINYXML2_SOURCES} ${TINYXML2_HEADERS} )\nvulkan_hpp__setup_warning_level( NAME VideoHppGenerator )\nfile( TO_NATIVE_PATH ${VulkanRegistry_DIR}/video.xml video_spec )\nstring( REPLACE \"\\\\\" \"\\\\\\\\\" video_spec ${video_spec} )\ntarget_compile_definitions( VideoHppGenerator PUBLIC BASE_PATH=\"${CMAKE_CURRENT_SOURCE_DIR}\" VIDEO_SPEC=\"${video_spec}\" )\ntarget_include_directories( VideoHppGenerator PRIVATE  ${VULKAN_HPP_TINYXML2_SRC_DIR} )\nset_target_properties( VideoHppGenerator PROPERTIES CXX_STANDARD 20 CXX_STANDARD_REQUIRED ON )\n\n\n# if the generators are to be run, add a custom commands and targets\nif( VULKAN_HPP_RUN_GENERATOR )\n\tif( NOT DEFINED VulkanHeaders_INCLUDE_DIR )\n\t\tif( DEFINED VULKAN_HPP_PATH )\n\t\t\tset( VulkanHeaders_INCLUDE_DIR ${VULKAN_HPP_PATH} )\n\t\telse()\n\t\t\tset( VulkanHeaders_INCLUDE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}\" )\n\t\tendif()\n\tendif()\n\t\n\tfile( TO_NATIVE_PATH ${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan.hpp vulkan_hpp )\n\tstring( REPLACE \"\\\\\" \"\\\\\\\\\" vulkan_hpp ${vulkan_hpp} )\n\n\tadd_custom_command(\n\t\tCOMMAND VulkanHppGenerator\n\t\tOUTPUT \"${vulkan_hpp}\"\n\t\tWORKING_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}\"\n\t\tCOMMENT \"run VulkanHppGenerator\"\n\t\tDEPENDS VulkanHppGenerator \"${vk_spec}\" )\n\tadd_custom_target( build_vulkan_hpp ALL DEPENDS \"${vulkan_hpp}\" \"${vk_spec}\" )\n\n\tfile( TO_NATIVE_PATH ${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_video.hpp vulkan_video_hpp )\n\tstring( REPLACE \"\\\\\" \"\\\\\\\\\" vulkan_video_hpp ${vulkan_video_hpp} )\n\n\tadd_custom_command(\n\t\tCOMMAND VideoHppGenerator\n\t\tOUTPUT \"${vulkan_video_hpp}\"\n\t\tWORKING_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}\"\n\t\tCOMMENT \"run VideoHppGenerator\"\n\t\tDEPENDS VideoHppGenerator \"${video_spec}\" )\n\tadd_custom_target( build_video_hpp ALL DEPENDS \"${vulkan_video_hpp}\" \"${video_spec}\" )\nendif()\n\nif( VULKAN_HPP_SAMPLES_BUILD )\n\t# external libraries\n\tadd_subdirectory( glm )\n\tset( GLFW_BUILD_EXAMPLES OFF )\n\tset( GLFW_BUILD_TESTS OFF )\n\tadd_subdirectory( glfw )\n\tadd_subdirectory( glslang )\n\t# samples\n\tadd_subdirectory( samples )\n\tadd_subdirectory( RAII_Samples )\nendif()\n\nif( VULKAN_HPP_TESTS_BUILD )\n\tadd_subdirectory( tests )\nendif()\n\nif( ${VULKAN_HPP_INSTALL} )\n\tinclude( GNUInstallDirs )\n\n\tset( VK_GENERATED_VULKAN_HEADERS\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_enums.hpp\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_format_traits.hpp\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_funcs.hpp\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_handles.hpp\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_hash.hpp\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_hpp_macros.hpp\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_raii.hpp\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_static_assertions.hpp\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_structs.hpp\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_to_string.hpp\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan_video.hpp\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan.cppm\n\t\t${VulkanHeaders_INCLUDE_DIR}/vulkan/vulkan.hpp\n\t)\n\tinstall( FILES ${VK_GENERATED_VULKAN_HEADERS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/vulkan )\n\nendif()\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.2734375,
          "content": "A reminder that this issue tracker is managed by the Khronos Group. Interactions here should follow the Khronos Code of Conduct (https://www.khronos.org/developers/code-of-conduct), which prohibits aggressive or derogatory language. Please keep the discussion friendly and civil.\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 11.2890625,
          "content": "\r\n                                 Apache License\r\n                           Version 2.0, January 2004\r\n                        http://www.apache.org/licenses/\r\n\r\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\r\n\r\n   1. Definitions.\r\n\r\n      \"License\" shall mean the terms and conditions for use, reproduction,\r\n      and distribution as defined by Sections 1 through 9 of this document.\r\n\r\n      \"Licensor\" shall mean the copyright owner or entity authorized by\r\n      the copyright owner that is granting the License.\r\n\r\n      \"Legal Entity\" shall mean the union of the acting entity and all\r\n      other entities that control, are controlled by, or are under common\r\n      control with that entity. For the purposes of this definition,\r\n      \"control\" means (i) the power, direct or indirect, to cause the\r\n      direction or management of such entity, whether by contract or\r\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\r\n      outstanding shares, or (iii) beneficial ownership of such entity.\r\n\r\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\r\n      exercising permissions granted by this License.\r\n\r\n      \"Source\" form shall mean the preferred form for making modifications,\r\n      including but not limited to software source code, documentation\r\n      source, and configuration files.\r\n\r\n      \"Object\" form shall mean any form resulting from mechanical\r\n      transformation or translation of a Source form, including but\r\n      not limited to compiled object code, generated documentation,\r\n      and conversions to other media types.\r\n\r\n      \"Work\" shall mean the work of authorship, whether in Source or\r\n      Object form, made available under the License, as indicated by a\r\n      copyright notice that is included in or attached to the work\r\n      (an example is provided in the Appendix below).\r\n\r\n      \"Derivative Works\" shall mean any work, whether in Source or Object\r\n      form, that is based on (or derived from) the Work and for which the\r\n      editorial revisions, annotations, elaborations, or other modifications\r\n      represent, as a whole, an original work of authorship. For the purposes\r\n      of this License, Derivative Works shall not include works that remain\r\n      separable from, or merely link (or bind by name) to the interfaces of,\r\n      the Work and Derivative Works thereof.\r\n\r\n      \"Contribution\" shall mean any work of authorship, including\r\n      the original version of the Work and any modifications or additions\r\n      to that Work or Derivative Works thereof, that is intentionally\r\n      submitted to Licensor for inclusion in the Work by the copyright owner\r\n      or by an individual or Legal Entity authorized to submit on behalf of\r\n      the copyright owner. For the purposes of this definition, \"submitted\"\r\n      means any form of electronic, verbal, or written communication sent\r\n      to the Licensor or its representatives, including but not limited to\r\n      communication on electronic mailing lists, source code control systems,\r\n      and issue tracking systems that are managed by, or on behalf of, the\r\n      Licensor for the purpose of discussing and improving the Work, but\r\n      excluding communication that is conspicuously marked or otherwise\r\n      designated in writing by the copyright owner as \"Not a Contribution.\"\r\n\r\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\r\n      on behalf of whom a Contribution has been received by Licensor and\r\n      subsequently incorporated within the Work.\r\n\r\n   2. Grant of Copyright License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      copyright license to reproduce, prepare Derivative Works of,\r\n      publicly display, publicly perform, sublicense, and distribute the\r\n      Work and such Derivative Works in Source or Object form.\r\n\r\n   3. Grant of Patent License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      (except as stated in this section) patent license to make, have made,\r\n      use, offer to sell, sell, import, and otherwise transfer the Work,\r\n      where such license applies only to those patent claims licensable\r\n      by such Contributor that are necessarily infringed by their\r\n      Contribution(s) alone or by combination of their Contribution(s)\r\n      with the Work to which such Contribution(s) was submitted. If You\r\n      institute patent litigation against any entity (including a\r\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\r\n      or a Contribution incorporated within the Work constitutes direct\r\n      or contributory patent infringement, then any patent licenses\r\n      granted to You under this License for that Work shall terminate\r\n      as of the date such litigation is filed.\r\n\r\n   4. Redistribution. You may reproduce and distribute copies of the\r\n      Work or Derivative Works thereof in any medium, with or without\r\n      modifications, and in Source or Object form, provided that You\r\n      meet the following conditions:\r\n\r\n      (a) You must give any other recipients of the Work or\r\n          Derivative Works a copy of this License; and\r\n\r\n      (b) You must cause any modified files to carry prominent notices\r\n          stating that You changed the files; and\r\n\r\n      (c) You must retain, in the Source form of any Derivative Works\r\n          that You distribute, all copyright, patent, trademark, and\r\n          attribution notices from the Source form of the Work,\r\n          excluding those notices that do not pertain to any part of\r\n          the Derivative Works; and\r\n\r\n      (d) If the Work includes a \"NOTICE\" text file as part of its\r\n          distribution, then any Derivative Works that You distribute must\r\n          include a readable copy of the attribution notices contained\r\n          within such NOTICE file, excluding those notices that do not\r\n          pertain to any part of the Derivative Works, in at least one\r\n          of the following places: within a NOTICE text file distributed\r\n          as part of the Derivative Works; within the Source form or\r\n          documentation, if provided along with the Derivative Works; or,\r\n          within a display generated by the Derivative Works, if and\r\n          wherever such third-party notices normally appear. The contents\r\n          of the NOTICE file are for informational purposes only and\r\n          do not modify the License. You may add Your own attribution\r\n          notices within Derivative Works that You distribute, alongside\r\n          or as an addendum to the NOTICE text from the Work, provided\r\n          that such additional attribution notices cannot be construed\r\n          as modifying the License.\r\n\r\n      You may add Your own copyright statement to Your modifications and\r\n      may provide additional or different license terms and conditions\r\n      for use, reproduction, or distribution of Your modifications, or\r\n      for any such Derivative Works as a whole, provided Your use,\r\n      reproduction, and distribution of the Work otherwise complies with\r\n      the conditions stated in this License.\r\n\r\n   5. Submission of Contributions. Unless You explicitly state otherwise,\r\n      any Contribution intentionally submitted for inclusion in the Work\r\n      by You to the Licensor shall be under the terms and conditions of\r\n      this License, without any additional terms or conditions.\r\n      Notwithstanding the above, nothing herein shall supersede or modify\r\n      the terms of any separate license agreement you may have executed\r\n      with Licensor regarding such Contributions.\r\n\r\n   6. Trademarks. This License does not grant permission to use the trade\r\n      names, trademarks, service marks, or product names of the Licensor,\r\n      except as required for reasonable and customary use in describing the\r\n      origin of the Work and reproducing the content of the NOTICE file.\r\n\r\n   7. Disclaimer of Warranty. Unless required by applicable law or\r\n      agreed to in writing, Licensor provides the Work (and each\r\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\r\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\r\n      implied, including, without limitation, any warranties or conditions\r\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\r\n      PARTICULAR PURPOSE. You are solely responsible for determining the\r\n      appropriateness of using or redistributing the Work and assume any\r\n      risks associated with Your exercise of permissions under this License.\r\n\r\n   8. Limitation of Liability. In no event and under no legal theory,\r\n      whether in tort (including negligence), contract, or otherwise,\r\n      unless required by applicable law (such as deliberate and grossly\r\n      negligent acts) or agreed to in writing, shall any Contributor be\r\n      liable to You for damages, including any direct, indirect, special,\r\n      incidental, or consequential damages of any character arising as a\r\n      result of this License or out of the use or inability to use the\r\n      Work (including but not limited to damages for loss of goodwill,\r\n      work stoppage, computer failure or malfunction, or any and all\r\n      other commercial damages or losses), even if such Contributor\r\n      has been advised of the possibility of such damages.\r\n\r\n   9. Accepting Warranty or Additional Liability. While redistributing\r\n      the Work or Derivative Works thereof, You may choose to offer,\r\n      and charge a fee for, acceptance of support, warranty, indemnity,\r\n      or other liability obligations and/or rights consistent with this\r\n      License. However, in accepting such obligations, You may act only\r\n      on Your own behalf and on Your sole responsibility, not on behalf\r\n      of any other Contributor, and only if You agree to indemnify,\r\n      defend, and hold each Contributor harmless for any liability\r\n      incurred by, or claims asserted against, such Contributor by reason\r\n      of your accepting any such warranty or additional liability.\r\n\r\n   END OF TERMS AND CONDITIONS\r\n\r\n   APPENDIX: How to apply the Apache License to your work.\r\n\r\n      To apply the Apache License to your work, attach the following\r\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\r\n      replaced with your own identifying information. (Don't include\r\n      the brackets!)  The text should be enclosed in the appropriate\r\n      comment syntax for the file format. We also recommend that a\r\n      file or class name and description of purpose be included on the\r\n      same \"printed page\" as the copyright notice for easier\r\n      identification within third-party archives.\r\n\r\n   Copyright [yyyy] [name of copyright owner]\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n"
        },
        {
          "name": "RAII_Samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 63.0068359375,
          "content": "\r\n# Vulkan-Hpp: C++ Bindings for Vulkan\r\n\r\nThe goal of the Vulkan-Hpp is to provide header only C++ bindings for the Vulkan C API to improve the developers Vulkan experience without introducing CPU runtime cost. It adds features like type safety for enums and bitfields, STL container support, exceptions and simple enumerations.\r\n\r\n| Platform | Build Status |\r\n|:--------:|:------------:|\r\n| Linux    | [![Build Status](https://travis-ci.org/KhronosGroup/Vulkan-Hpp.svg?branch=master)](https://travis-ci.org/KhronosGroup/Vulkan-Hpp) |\r\n\r\n## Getting Started\r\n\r\nVulkan-Hpp is part of the [LunarG Vulkan SDK](https://www.lunarg.com/vulkan-sdk/) since version 1.0.24. Just `#include <vulkan/vulkan.hpp>` and you're ready to use the C++ bindings. If you're using a Vulkan version not yet supported by the Vulkan SDK, you can find the latest version of the headers [here](vulkan).\r\n\r\n### Minimum Requirements\r\n\r\nVulkan-Hpp requires a C++11 capable compiler to compile. The following compilers are known to work:\r\n* Visual Studio >= 2015\r\n* GCC >= 4.8.2 (earlier version might work, but are untested)\r\n* Clang >= 3.3\r\n\r\n### Building Vulkan-Hpp, Samples, and Tests\r\n\r\nTo build the local samples and tests you'll have to clone this repository and run CMake to generate the required build files\r\n\r\n0. Install dependencies.\r\n   * Ensure that you have CMake and git installed and accessible from a shell.\r\n   * Ensure that you have installed the Vulkan SDK.\r\n   * Optionally install clang-format >= 11.0 to get a nicely formatted Vulkan-Hpp header.\r\n1. Open a shell which provides git and clone the repository with:\r\n\r\n    `git clone --recurse-submodules https://github.com/KhronosGroup/Vulkan-Hpp.git`\r\n2. Change the current directory to the newly created Vulkan-Hpp directory.\r\n3. Create a build environment with CMake:\r\n\r\n    `cmake -DVULKAN_HPP_SAMPLES_BUILD=ON -DVULKAN_HPP_SAMPLES_BUILD_WITH_LOCAL_VULKAN_HPP=ON -DVULKAN_HPP_TESTS_BUILD=ON -DVULKAN_HPP_TESTS_BUILD_WITH_LOCAL_VULKAN_HPP=ON -B build`\r\n\r\n    You might need to specify a generator via `-G`, for a full list of generators execute `cmake -G`.\r\n    *  To rebuild `vulkan.hpp` from the `vk.xml` XML registry file, add the\r\n       `-DVULKAN_HPP_RUN_GENERATOR=ON` option to the CMake command line.\r\n4. Either open the generated project with an IDE, e.g. Visual Studio or launch the build process with `cmake --build build --parallel`.\r\n\r\nOptional: To update the Vulkan-Hpp and its submodules execute `git pull --recurse-submodules`.\r\n\r\n### Installing vulkan-hpp using vcpkg\r\n\r\nYou can download and install vulkan-hpp using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\r\n\r\n```bash\r\ngit clone https://github.com/Microsoft/vcpkg.git\r\ncd vcpkg\r\n./bootstrap-vcpkg.sh\r\n./vcpkg integrate install\r\n./vcpkg install vulkan-headers\r\n```\r\n\r\nThe vulkan-hpp port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\r\n\r\n### Optional Features\r\n\r\n#### Formatting\r\n\r\nIf the program clang-format is found by CMake, the define `CLANG_FORMAT_EXECUTABLE` is set accordingly. In that case, the generated `vulkan.hpp` is formatted using the `.clang-format` file located in the root directory of this project. Otherwise, it's formatted as hard-coded in the generator.\r\n\r\n#### Custom views of Vulkan-Hpp objects in Visual Studio\r\n\r\nThe file `VulkanHpp.natvis` provides a custom view on `vk::Flags` for Visual Studio. If you add this file to the user-specific natvis directory of your Visual Studio installation (%USERPROFILE%\\Documents\\Visual Studio 2022\\Visualizers), you get `vk::Flags` nicely formatted in your debugger with all your Visual Studio projects.\r\n\r\n## Usage\r\n\r\n### namespace vk\r\n\r\nTo avoid name collisions with the Vulkan C API, the C++ bindings reside in the `vk` namespace. The following rules apply to the new naming:\r\n\r\n* All functions, enums, handles, and structs have the `Vk` prefix removed. In addition to this the first letter of functions is lower case.\r\n  * `vkCreateInstance` can be accessed as `vk::createInstance`.\r\n  * `VkImageTiling` can be accessed as `vk::ImageTiling`.\r\n  * `VkImageCreateInfo` can be accessed as `vk::ImageCreateInfo`.\r\n* Enums are mapped to scoped enums to provide compile time type safety. The names have been changed to 'e' + CamelCase with the `VK_` prefix and type infix removed. If the enum type is an extension, the extension suffix has been removed from the enum values.\r\n\r\nIn all other cases the extension suffix has not been removed.\r\n  * `VK_IMAGETYPE_2D` is now `vk::ImageType::e2D`.\r\n  * `VK_COLOR_SPACE_SRGB_NONLINEAR_KHR` is now `vk::ColorSpaceKHR::eSrgbNonlinear`.\r\n  * `VK_STRUCTURE_TYPE_PRESENT_INFO_KHR` is now `vk::StructureType::ePresentInfoKHR`.\r\n* Flag bits are handled like scoped enums with the addition that the `_BIT` suffix has also been removed.\r\n\r\nIn some cases it might be necessary to move Vulkan-Hpp to a custom namespace. This can be achieved by defining `VULKAN_HPP_NAMESPACE` before including Vulkan-Hpp.\r\n\r\n### Handles\r\n\r\nVulkan-Hpp declares a class for all handles to ensure full type safety and to add support for member functions on handles. A member function has been added to a handle class for each function which accepts the corresponding handle as first parameter. Instead of `vkBindBufferMemory(device, ...)` one can write `device.bindBufferMemory(...)` or `vk::bindBufferMemory(device, ...)`.\r\n\r\n### namespace vk::raii\r\n\r\nThere is an additional header named [`vulkan_raii.hpp`](vulkan/vulkan_raii.hpp) generated. That header holds raii-compliant wrapper classes for the handle types. That is, for e.g. the handle type `VkInstance`, there's a raii-compliant wrapper `vk::raii::Instance`. Please have a look at the samples using those classes in the directory [RAII_Samples](RAII_Samples).\r\n\r\n### C/C++ Interop for Handles\r\n\r\nOn 64-bit platforms Vulkan-Hpp supports implicit conversions between C++ Vulkan handles and C Vulkan handles. On 32-bit platforms all non-dispatchable handles are defined as `uint64_t`, thus preventing type-conversion checks at compile time which would catch assignments between incompatible handle types. Due to that Vulkan-Hpp does not enable implicit conversion for 32-bit platforms by default and it is recommended to use a `static_cast` for the conversion like this: `VkImage = static_cast<VkImage>(cppImage)` to prevent converting some arbitrary int to a handle or vice versa by accident. If you're developing your code on a 64-bit platform, but want to compile your code for a 32-bit platform without adding the explicit casts, you can define `VULKAN_HPP_TYPESAFE_CONVERSION` to `1` in your build system or before including `vulkan.hpp`. On 64-bit platforms this define is set to `1` by default and can be set to `0` to disable implicit conversions.\r\n\r\n### Flags\r\n\r\nThe scoped enum feature adds type safety to the flags, but also prevents using the flag bits as input for bitwise operations such as `&` and `|`.\r\n\r\nAs solution Vulkan-Hpp provides a class template `vk::Flags` which brings the standard operations like `&=`, `|=`, `&`, and `|` to our scoped enums. Except for the initialization with `0` this class behaves exactly like a normal bitmask with the improvement that it is impossible to set bits not specified by the corresponding enum by accident. Here are a few examples for the bitmask handling:\r\n\r\n```c++\r\nvk::ImageUsageFlags iu1; // initialize a bitmask with no bit set\r\nvk::ImageUsageFlags iu2 = {}; // initialize a bitmask with no bit set\r\nvk::ImageUsageFlags iu3 = vk::ImageUsageFlagBits::eColorAttachment; // initialize with a single value\r\nvk::ImageUsageFlags iu4 = vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eStorage; // or two bits to get a bitmask\r\nPipelineShaderStageCreateInfo ci({} /* pass a flag without any bits set */, ...);\r\n```\r\n\r\n### CreateInfo structs\r\n\r\nWhen constructing a handle in Vulkan one usually has to create some `CreateInfo` struct which describes the new handle. This can result in quite lengthy code as can be seen in the following Vulkan C example:\r\n\r\n```c++\r\nVkImageCreateInfo ci;\r\nci.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;\r\nci.pNext = nullptr;\r\nci.flags = ...some flags...;\r\nci.imageType = VK_IMAGE_TYPE_2D;\r\nci.format = VK_FORMAT_R8G8B8A8_UNORM;\r\nci.extent = VkExtent3D { width, height, 1 };\r\nci.mipLevels = 1;\r\nci.arrayLayers = 1;\r\nci.samples = VK_SAMPLE_COUNT_1_BIT;\r\nci.tiling = VK_IMAGE_TILING_OPTIMAL;\r\nci.usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;\r\nci.sharingMode = VK_SHARING_MODE_EXCLUSIVE;\r\nci.queueFamilyIndexCount = 0;\r\nci.pQueueFamilyIndices = 0;\r\nci.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;\r\nvkCreateImage(device, &ci, allocator, &image);\r\n```\r\n\r\nThere are two typical issues Vulkan developers encounter when filling out a `CreateInfo` struct field by field:\r\n* One or more fields are left uninitialized.\r\n* `sType` is incorrect.\r\n\r\nEspecially the first one is hard to detect.\r\n\r\nVulkan-Hpp provides constructors for all `CreateInfo` objects which accept one parameter for each member variable. This way the compiler throws a compiler error if a value has been forgotten. In addition to this `sType` is automatically filled with the correct value and `pNext` set to a `nullptr` by default. Here's how the same code looks with a constructor:\r\n\r\n```c++\r\nvk::ImageCreateInfo ci({}, vk::ImageType::e2D, vk::Format::eR8G8B8A8Unorm,\r\n                       { width, height, 1 },\r\n                       1, 1, vk::SampleCountFlagBits::e1,\r\n                       vk::ImageTiling::eOptimal, vk::ImageUsageFlagBits::eColorAttachment,\r\n                       vk::SharingMode::eExclusive, 0, nullptr, vk::ImageLayout::eUndefined);\r\nvk::Image image = device.createImage(ci);\r\n```\r\n\r\nWith constructors for `CreateInfo` structures, one can also pass temporaries to Vulkan functions like this:\r\n\r\n```c++\r\nvk::Image image = device.createImage({{}, vk::ImageType::e2D, vk::Format::eR8G8B8A8Unorm,\r\n                                     { width, height, 1 },\r\n                                     1, 1, vk::SampleCountFlagBits::e1,\r\n                                     vk::ImageTiling::eOptimal, vk::ImageUsageFlagBits::eColorAttachment,\r\n                                     vk::SharingMode::eExclusive, 0, nullptr, vk::ImageLayout::eUndefined});\r\n```\r\n\r\n### Designated Initializers\r\n\r\nBeginning with C++20, C++ supports designated initializers. As that feature requires to not have any user-declared or inherited constructors, you have to `#define VULKAN_HPP_NO_CONSTRUCTORS`, which removes all the structure and union constructors from `vulkan.hpp`. Instead you can then use aggregate initialization. The first few vk-lines in your source might then look like:\r\n\r\n```c++\r\n// initialize the vk::ApplicationInfo structure\r\nvk::ApplicationInfo applicationInfo{ .pApplicationName   = AppName,\r\n                                     .applicationVersion = 1,\r\n                                     .pEngineName        = EngineName,\r\n                                     .engineVersion      = 1,\r\n                                     .apiVersion         = VK_API_VERSION_1_1 };\r\n\r\n// initialize the vk::InstanceCreateInfo\r\nvk::InstanceCreateInfo instanceCreateInfo{ .pApplicationInfo = &applicationInfo };\r\n```\r\n\r\ninstead of\r\n\r\n```c++\r\n// initialize the vk::ApplicationInfo structure\r\nvk::ApplicationInfo applicationInfo(AppName, 1, EngineName, 1, VK_API_VERSION_1_1);\r\n\r\n// initialize the vk::InstanceCreateInfo\r\nvk::InstanceCreateInfo instanceCreateInfo({}, &applicationInfo);\r\n```\r\n\r\nNote, that the designator order needs to match the declaration order.\r\nNote as well, that now you can explicitly set the `sType` member of vk-structures. This is neither neccessary (as they are correctly initialized by default) nor recommended.\r\n\r\n### Passing Arrays to Functions using ArrayProxy\r\n\r\nThe Vulkan API has several places which require (count, pointer) as two function arguments and C++ has a few containers which map perfectly to this pair. To simplify development the Vulkan-Hpp bindings have replaced those argument pairs with the `vk::ArrayProxy` class template which accepts empty arrays and a single value as well as STL containers `std::initializer_list`, `std::array` and `std::vector` as argument for construction. This way a single generated Vulkan version can accept a variety of inputs without having the combinatoric explosion which would occur when creating a function for each container type.\r\n\r\nHere are some code samples on how to use the `vk::ArrayProxy`:\r\n\r\n```c++\r\nvk::CommandBuffer c;\r\n\r\n// pass an empty array\r\nc.setScissor(0, nullptr);\r\n\r\n// pass a single value. Value is passed as reference\r\nvk::Rect2D scissorRect = { { 0, 0 }, { 640, 480 } };\r\nc.setScissor(0, scissorRect);\r\n\r\n// pass a temporary value.\r\nc.setScissor(0, { { 0, 0 }, { 640, 480 } });\r\n\r\n// pass a fixed size array\r\nvk::Rect2D scissorRects[2] = { { { 0, 0 }, { 320, 240 } }, { { 320, 240 }, { 320, 240 } } };\r\nc.setScissor(0, scissorRects);\r\n\r\n// generate a std::initializer_list using two rectangles from the stack. This might generate a copy of the rectangles.\r\nvk::Rect2D scissorRect1 = { { 0, 0 }, { 320, 240 } };\r\nvk::Rect2D scissorRect2 = { { 320, 240 }, { 320, 240 } };\r\nc.setScissor(0, { scissorRect, scissorRect2 });\r\n\r\n// construct a std::initializer_list using two temporary rectangles.\r\nc.setScissor(0, { { { 0, 0 }, { 320, 240 } },\r\n                { { 320, 240 }, { 320, 240 } } });\r\n\r\n// pass a std::array\r\nstd::array<vk::Rect2D, 2> arr{ scissorRect1, scissorRect2 };\r\nc.setScissor(0, arr);\r\n\r\n// pass a std::vector of dynamic size\r\nstd::vector<vk::Rect2D> vec;\r\nvec.push_back(scissorRect1);\r\nvec.push_back(scissorRect2);\r\nc.setScissor(0, vec);\r\n```\r\n\r\n### Passing Structs to Functions\r\n\r\nVulkan-Hpp generates references for pointers to structs. This conversion allows passing temporary structs to functions which can result in shorter code. In case the input is optional and thus accepting a null pointer, the parameter type will be `vk::Optional<T> const&`. This type accepts either a reference to `T` or `nullptr` as input and thus allows optional temporary structs.\r\n\r\n```c++\r\n// C\r\nVkImageSubresource subResource;\r\nsubResource.aspectMask = 0;\r\nsubResource.mipLevel = 0;\r\nsubResource.arrayLayer = 0;\r\nVkSubresourceLayout layout;\r\nvkGetImageSubresourceLayout(device, image, &subresource, &layout);\r\n\r\n// C++\r\nauto layout = device.getImageSubresourceLayout(image, { {} /* flags*/, 0 /* miplevel */, 0 /* arrayLayer */ });\r\n```\r\n\r\n### Structure Pointer Chains\r\n\r\nVulkan allows chaining of structures through the `pNext` pointer. Vulkan-Hpp has a variadic class template which allows constructing of such structure chains with minimal efforts. In addition to this it checks at compile time if the spec allows the construction of such a `pNext` chain.\r\n\r\n```c++\r\n// This will compile successfully.\r\nvk::StructureChain<vk::MemoryAllocateInfo, vk::ImportMemoryFdInfoKHR> c;\r\nvk::MemoryAllocateInfo &allocInfo = c.get<vk::MemoryAllocateInfo>();\r\nvk::ImportMemoryFdInfoKHR &fdInfo = c.get<vk::ImportMemoryFdInfoKHR>();\r\n\r\n// This will fail compilation since it's not valid according to the spec.\r\nvk::StructureChain<vk::MemoryAllocateInfo, vk::MemoryDedicatedRequirementsKHR> c;\r\nvk::MemoryAllocateInfo &allocInfo = c.get<vk::MemoryAllocateInfo>();\r\nvk::ImportMemoryFdInfoKHR &fdInfo = c.get<vk::ImportMemoryFdInfoKHR>();\r\n```\r\n\r\nVulkan-Hpp provides a constructor for these chains similar to the `CreateInfo` objects which accepts a list of all structures part of the chain. The `pNext` field is automatically set to the correct value:\r\n\r\n```c++\r\nvk::StructureChain<vk::MemoryAllocateInfo, vk::MemoryDedicatedAllocateInfo> c = {\r\n  vk::MemoryAllocateInfo(size, type),\r\n  vk::MemoryDedicatedAllocateInfo(image)\r\n};\r\n```\r\n\r\nIf one of the structures of a StructureChain is to be removed, maybe due to some optional settings, you can use the function `vk::StructureChain::unlink<ClassType>()`. It modifies the StructureChain such that the specified structure isn't part of the pNext-chain any more. Note, that the actual memory layout of the StructureChain is not modified by that function.\r\nIn case that very same structure has to be re-added to the StructureChain again, use `vk::StructureChain::relink<ClassType>()`.\r\n\r\nSometimes the user has to pass a preallocated structure chain to query information. For those cases there are two corresponding getter functions. One with a variadic template generating a structure chain of at least two elements to construct the return value:\r\n\r\n```c++\r\n// Query vk::MemoryRequirements2HR and vk::MemoryDedicatedRequirementsKHR when calling Device::getBufferMemoryRequirements2KHR:\r\nauto result = device.getBufferMemoryRequirements2KHR<vk::MemoryRequirements2KHR, vk::MemoryDedicatedRequirementsKHR>({});\r\nvk::MemoryRequirements2KHR &memReqs = result.get<vk::MemoryRequirements2KHR>();\r\nvk::MemoryDedicatedRequirementsKHR &dedMemReqs = result.get<vk::MemoryDedicatedRequirementsKHR>();\r\n```\r\n\r\nTo get just the base structure, without chaining, the other getter function provided does not need a template argument for the structure to get:\r\n\r\n```c++\r\n// Query just vk::MemoryRequirements2KHR\r\nvk::MemoryRequirements2KHR memoryRequirements = device.getBufferMemoryRequirements2KHR({});\r\n```\r\n\r\n### Return values, Error Codes & Exceptions\r\n\r\nBy default Vulkan-Hpp has exceptions enabled. This means that Vulkan-Hpp checks the return code of each function call which returns a `vk::Result`. If `vk::Result` is a failure a `std::runtime_error` will be thrown. Since there is no need to return the error code anymore the C++ bindings can now return the actual desired return value, i.e. a vulkan handle. In those cases `vk::ResultValue<SomeType>::type` is defined as the returned type.\r\n\r\nTo create a device you can now just write:\r\n\r\n```c++\r\nvk::Device device = physicalDevice.createDevice(createInfo);\r\n```\r\n\r\nSome functions allow more than just `vk::Result::eSuccess` to be considered as a success code. For those functions, we always return a `vk::ResultValue<SomeType>`. An example is `acquireNextImage2KHR`, that can be used like this:\r\n\r\n```c++\r\nvk::ResultValue<uint32_t> result = device->acquireNextImage2KHR(acquireNextImageInfo);\r\nswitch (result.result)\r\n{\r\n\tcase vk::Result::eSuccess:\r\n\t\tcurrentBuffer = result.value;\r\n\t\tbreak;\r\n\tcase vk::Result::eTimeout:\r\n\tcase vk::Result::eNotReady:\r\n\tcase vk::Result::eSuboptimalKHR:\r\n\t\t// do something meaningful\r\n\t\tbreak;\r\n\tdefault:\r\n\t\t// should not happen, as other return codes are considered to be an error and throw an exception\r\n\t\tbreak;\r\n}\r\n```\r\n\r\nAs time passes, some vulkan functions might change, such that they start to support more result codes than `vk::Result::eSuccess` as a success code. That logical change would not be visible in the C API, but in the C++ API, as such a function would now return a `vk::ResultValue<SomeType>` instead of just `SomeType`. In such (rare) cases, you would have to adjust your cpp-sources to reflect that API change.\r\n\r\nIf exception handling is disabled by defining `VULKAN_HPP_NO_EXCEPTIONS` the type of `vk::ResultValue<SomeType>::type` is a struct holding a `vk::Result` and a `SomeType`. This struct supports unpacking the return values by using `std::tie`.\r\n\r\nIn case you don’t want to use the `vk::ArrayProxy` and return value transformation, you can still call the plain C-style function. Below are three examples showing the 3 ways to use the API:\r\n\r\nThe first snippet shows how to use the API without exceptions and the return value transformation:\r\n\r\n```c++\r\n// No exceptions, no return value transformation\r\nvk::ShaderModuleCreateInfo createInfo(...);\r\nvk::ShaderModule shader1;\r\nvk::Result result = device.createShaderModule(&createInfo, allocator, &shader1);\r\nif (result.result != vk::Result::eSuccess)\r\n{\r\n  handle error code;\r\n  cleanup?\r\n  return?\r\n}\r\n\r\nvk::ShaderModule shader2;\r\nvk::Result result = device.createShaderModule(&createInfo, allocator, &shader2);\r\nif (result != vk::Result::eSuccess)\r\n{\r\n  handle error code;\r\n  cleanup?\r\n  return?\r\n}\r\n```\r\n\r\nThe second snippet shows how to use the API using return value transformation, but without exceptions. It’s already a little bit shorter than the original code:\r\n\r\n```c++\r\nvk::ResultValue<ShaderModule> shaderResult1 = device.createShaderModule({...} /* createInfo temporary */);\r\nif (shaderResult1.result != vk::Result::eSuccess)\r\n{\r\n  handle error code;\r\n  cleanup?\r\n  return?\r\n}\r\n\r\n// std::tie support.\r\nvk::Result result;\r\nvk::ShaderModule shaderModule2;\r\nstd::tie(result, shaderModule2) = device.createShaderModule({...} /* createInfo temporary */);\r\nif (result != vk::Result::eSuccess)\r\n{\r\n  handle error code;\r\n  cleanup?\r\n  return?\r\n}\r\n```\r\n\r\nA nicer way to unpack the result is using structured bindings in C++17. They will allow us to get the result with a single line of code:\r\n\r\n```c++\r\nauto [result, shaderModule2] = device.createShaderModule({...} /* createInfo temporary */);\r\n```\r\n\r\nFinally, the last code example is using exceptions and return value transformation. This is the default mode of the API.\r\n\r\n```c++\r\nvk::ShaderModule shader1;\r\nvk::ShaderModule shader2;\r\ntry\r\n{\r\n  shader1 = device.createShaderModule({...});\r\n  shader2 = device.createShaderModule({...});\r\n}\r\ncatch(std::exception const &e)\r\n{\r\n  // handle error and free resources\r\n}\r\n```\r\n\r\n> [!IMPORTANT]\r\n> The vulkan handles in the `vk`-namespace do not support RAII, hence you need to cleanup your resources in the error handler! Instead, you could use the handle wrapper classes in the `vk::raii`-namespace.\r\n\r\n### C++17: [[nodiscard]]\r\n\r\nWith C++17 and above, some functions are attributed with `[[nodiscard]]`, resulting in a warning if you don't use the return value in any way. You can switch those warnings off by defining `VULKAN_HPP_NO_NODISCARD_WARNINGS`.\r\n\r\n### Enumerations\r\n\r\nFor the return value transformation, there's one special class of return values which require special handling: Enumerations. For enumerations you usually have to write code like this:\r\n\r\n```c++\r\nstd::vector<LayerProperties, Allocator> properties;\r\nuint32_t propertyCount;\r\nvk::Result result;\r\ndo\r\n{\r\n  // determine number of elements to query\r\n  result = static_cast<vk::Result>(vk::enumerateDeviceLayerProperties(m_physicalDevice, &propertyCount, nullptr));\r\n  if ((result == vk::Result::eSuccess) && propertyCount)\r\n  {\r\n    // allocate memory & query again\r\n    properties.resize(propertyCount);\r\n    result = static_cast<vk::Result>(vk::enumerateDeviceLayerProperties(m_physicalDevice, &propertyCount, reinterpret_cast\r\n     <VkLayerProperties*>(properties.data())));\r\n  }\r\n} while (result == vk::Result::eIncomplete);\r\n// it's possible that the count has changed, start again if properties was not big enough\r\nproperties.resize(propertyCount);\r\n```\r\n\r\nSince writing this loop over and over again is tedious and error prone the C++ binding takes care of the enumeration so that you can just write:\r\n\r\n```c++\r\nstd::vector<LayerProperties> properties = physicalDevice.enumerateDeviceLayerProperties();\r\n```\r\n\r\n### UniqueHandle for automatic resource management\r\n\r\nVulkan-Hpp provides a `vk::UniqueHandle<Type, Deleter>` interface. For each Vulkan handle type `vk::Type` there is a unique handle `vk::UniqueType` which will delete the underlying Vulkan resource upon destruction, e.g. `vk::UniqueBuffer ` is the unique handle for `vk::Buffer`.\r\n\r\nFor each function which constructs a Vulkan handle of type `vk::Type` Vulkan-Hpp provides a second version which returns a `vk::UniqueType`. E.g. for `vk::Device::createBuffer` there is `vk::Device::createBufferUnique` and for `vk::allocateCommandBuffers` there is `vk::allocateCommandBuffersUnique`.\r\n\r\nNote that using `vk::UniqueHandle` comes at a cost since most deleters have to store the `vk::AllocationCallbacks` and parent handle used for construction because they are required for automatic destruction.\r\n\r\n### SharedHandle\r\n\r\nVulkan-Hpp provides a `vk::SharedHandle<Type>` interface. For each Vulkan handle type `vk::Type` there is a shared handle `vk::SharedType` which will delete the underlying Vulkan resource upon destruction, e.g. `vk::SharedBuffer` is the shared handle for `vk::Buffer`.\r\n\r\nUnlike `vk::UniqueHandle`, `vk::SharedHandle` takes shared ownership of the resource as well as its parent. This means that the parent handle will not be destroyed until all child resources are deleted. This is useful for resources that are shared between multiple threads or objects.\r\n\r\nThis mechanism ensures correct destruction order even if the parent `vk::SharedHandle` is destroyed before its child handle. Otherwise, the handle behaves like `std::shared_ptr`. `vk::SharedInstance` or any of its child object should be last to delete (first created, first in class declaration).\r\n\r\nThere are no functions which return a `vk::SharedHandle` directly yet. Instead, you can construct a `vk::SharedHandle` from a `vk::Handle`:\r\n\r\n```c++\r\nvk::Buffer buffer = device.createBuffer(...);\r\nvk::SharedBuffer sharedBuffer(buffer, device); // sharedBuffer now owns the buffer\r\n```\r\n\r\nThere are several specializations of `vk::SharedHandle` for different handle types. For example, `vk::SharedImage` may take an additional argument to specify if the image is owned by swapchain:\r\n\r\n```c++\r\nvk::Image image = swapchain.getImages(...)[0]; // get the first image from the swapchain\r\nvk::SharedImage sharedImage(image, device, SwapChainOwns::yes); // sharedImage now owns the image, but won't destroy it\r\n```\r\n\r\nThere is also a specialization for `vk::SwapchainKHR` which takes an additional argument to specify a surface:\r\n\r\n```c++\r\nvk::SwapchainKHR swapchain = device.createSwapchainKHR(...);\r\nvk::SharedSwapchainKHR sharedSwapchain(swapchain, device, surface); // sharedSwapchain now owns the swapchain and surface\r\n```\r\n\r\nYou can create a `vk::SharedHandle` overload for your own handle type or own shared handles by providing several template arguments to `SharedHandleBase`:\r\n - A handle type\r\n - A parent handle type or a header structure, that contains the parent\r\n - A class itself for CRTP\r\n\r\nWith this, provide a custom static destruction function `internalDestroy`, that takes in a parent handle and a handle to destroy. Don't forget to add a friend declaration for the base class.\r\n\r\n```c++\r\n// Example of a custom shared device, that takes in an instance as a parent\r\nclass shared_handle<VkDevice> : public vk::SharedHandleBase<VkDevice, vk::SharedInstance, shared_handle<VkDevice>>\r\n{\r\n  using base = vk::SharedHandleBase<VkDevice, vk::SharedInstance, shared_handle<VkDevice>>;\r\n  friend base;\r\n\r\npublic:\r\n  shared_handle() = default;\r\n  explicit shared_handle(VkDevice handle, vk::SharedInstance parent) noexcept\r\n    : base(handle, std::move(parent)) {}\r\n\r\n  const auto& getParent() const noexcept\r\n  {\r\n    return getHeader();\r\n  }\r\n\r\nprotected:\r\n  static void internalDestroy(const vk::SharedInstance& /*control*/, VkDevice handle) noexcept\r\n  {\r\n    kDestroyDevice(handle);\r\n  }\r\n};\r\n```\r\n\r\nThe API will be extended to provide creation functions in the future.\r\n\r\n## RAII-classes\r\n\r\nIn addition to `vk::UniqueHandles` and `vk::SharedHandles`, there's a set of wrapper classes for all the handle types that follow the RAII-paradigm (resource acquisition is initialization), provided in the `vk::raii` namespace.\r\n\r\nWhile a `vk::UniqueHandle` mimics a handle wrapped by a `std::unique_ptr`, and a `vk::SharedHandle` mimics a handle wrapped by a `std::shared_ptr`, including parent information, a `vk::raii::Handle` is just a class that acquires the underlying vk-handle in its constructor and releases it in its destructor. Thus, you're free to use them as values or wrap them with some smart pointer.\r\n\r\nOther than the `vk::Handles`, all those handle wrapper classes need to hold additional data, and thus are not binary identical with the vulkan C-handles.\r\n\r\nAs the `vk::UniqueHandles` and the `vk::SharedHandles` use the same dispatcher as the `vk::Handles`, they can be easily mixed-and-matched. The `vk::raii::Handles` use some slightly different dispatchers and thus are not compatible with the other handles! That is, for the `vk-Handles`, the `vk::UniqueHandles`, and the `vk::SharedHandles`, you need to instantiate a global dispatcher as described in https://github.com/KhronosGroup/Vulkan-Hpp#extensions--per-device-function-pointers. For the `vk::raii-Handles`, this is not needed, as they maintain their own dispatchers. The big advantage here is when you have multiple devices: the functions called via the `vk::raii-Handles` always call the device specific functions.\r\n\r\n### Custom allocators\r\n\r\nSometimes it is required to use `std::vector` with custom allocators. Vulkan-Hpp supports vectors with custom allocators as input for `vk::ArrayProxy` and for functions which do return a vector. For the latter case, add your favorite custom allocator as template argument to the function call like this:\r\n\r\n```c++\r\nstd::vector<LayerProperties, MyCustomAllocator> properties = physicalDevice.enumerateDeviceLayerProperties<MyCustomAllocator>();\r\n```\r\n\r\nYou can also use a stateful custom allocator by providing it as an argument to those functions. Unfortunately, to make the compilers happy, you also need to explicitly set the Dispatch argument. To get the default there, a simple `{}` would suffice:\r\n\r\n```c++\r\nMyStatefulCustomAllocator allocator;\r\nstd::vector<LayerProperties, MyStatefulCustomAllocator> properties = physicalDevice.enumerateDeviceLayerProperties(allocator, {});\r\n```\r\n\r\n### Custom assertions\r\n\r\nAll over `vulkan.hpp`, there are a couple of calls to an assert function. By defining `VULKAN_HPP_ASSERT`, you can specifiy your own custom assert function to be called instead.\r\n\r\nBy default, `VULKAN_HPP_ASSERT_ON_RESULT` will be used for checking results when `VULKAN_HPP_NO_EXCEPTIONS` is defined. If you want to handle errors by yourself, you can disable/customize it just like `VULKAN_HPP_ASSERT`.\r\n\r\nThere are a couple of static assertions for each handle class and each struct in the file [`vulkan_static_assertions.hpp`](vulkan/vulkan_static_assertions.hpp). You might include that file in at least one of your source files. By defining `VULKAN_HPP_STATIC_ASSERT`, you can specify your own custom static assertion to be used for those cases. That is, by defining it to be a NOP, you can reduce your compilation time a little.\r\n\r\n### Extensions / Per Device function pointers\r\n\r\nThe Vulkan loader exposes only the Vulkan core functions and a limited number of extensions. To use Vulkan-Hpp with extensions it's required to have either a library which provides stubs to all used Vulkan functions or to tell Vulkan-Hpp to dispatch those functions pointers. Vulkan-Hpp provides a per-function dispatch mechanism by accepting a dispatch class as last parameter in each function call. The dispatch class must provide a callable type for each used Vulkan function. Vulkan-Hpp provides one implementation, `DispatchLoaderDynamic`, which fetches all function pointers known to the library.\r\n\r\n```c++\r\n// Providing a function pointer resolving vkGetInstanceProcAddr, just the few functions not depending an an instance or a device are fetched\r\nvk::DispatchLoaderDynamic dld(getInstanceProcAddr);\r\n\r\n// Providing an already created VkInstance and a function pointer resolving vkGetInstanceProcAddr, all functions are fetched\r\nvk::DispatchLoaderDynamic dldi(instance, getInstanceProcAddr);\r\n\r\n// Providing also an already created VkDevice and optionally a function pointer resolving vkGetDeviceProcAddr, all functions are fetched as well, but now device-specific functions are fetched via vkDeviceGetProcAddr.\r\nvk::DispatchLoaderDynamic dldid( nstance, getInstanceProcAddr, device);\r\n\r\n// Pass dispatch class to function call as last parameter\r\ndevice.getQueue(graphics_queue_family_index, 0, &graphics_queue, dldid);\r\n```\r\n\r\nTo use the `vk::DispatchLoaderDynamic` as the default dispatcher (means: you don't need to explicitly add it to every function call),  you need to  `#define VULKAN_HPP_DISPATCH_LOADER_DYNAMIC 1`, and have the macro `VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE` exactly once in your source code to provide storage for that default dispatcher. Then you can use it by the macro `VULKAN_HPP_DEFAULT_DISPATCHER`, as is shown in the code snippets below.\r\nCreating a full featured `vk::DispatchLoaderDynamic` is a two- to three-step process, where you have three choices for the first step:\r\n1. Before any call into a vk-function you need to initialize the dynamic dispatcher by one of three methods\r\n- Let Vulkan-Hpp do all the work by internally using a little helper class `vk::DynamicLoader`:\r\n```c++\r\n    VULKAN_HPP_DEFAULT_DISPATCHER.init();\r\n```\r\n- Use your own dynamic loader, which just needs to provide a templated function `getProcAddress` (compare with `vk::DynamicLoader` in `vulkan.hpp`):\r\n```c++\r\n    YourDynamicLoader ydl;\r\n    VULKAN_HPP_DEFAULT_DISPATCHER.init(ydl);\r\n```\r\n> [!NOTE]\r\n> You need to keep that dynamic loader object alive until after the last call to a vulkan function in your program. For example by making it static, or storing it globally.\r\n- Use your own initial function pointer of type `PFN_vkGetInstanceProcAddr`:\r\n```c++\r\n    PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = your_own_function_pointer_getter();\r\n    VULKAN_HPP_DEFAULT_DISPATCHER.init(vkGetInstanceProcAddr);\r\n```\r\n2. initialize it with a `vk::Instance` to get all the other function pointers:\r\n```c++\r\n    vk::Instance instance = vk::createInstance({}, nullptr);\r\n    VULKAN_HPP_DEFAULT_DISPATCHER.init(instance);\r\n```\r\n3. optionally initialize it with a `vk::Device` to get device-specific function pointers\r\n```c++\r\n    std::vector<vk::PhysicalDevice> physicalDevices = instance.enumeratePhysicalDevices();\r\n    assert(!physicalDevices.empty());\r\n    vk::Device device = physicalDevices[0].createDevice({}, nullptr);\r\n    VULKAN_HPP_DEFAULT_DISPATCHER.init(device);\r\n```\r\nAfter the second step above, the dispatcher is fully functional. Adding the third step can potentially result in more efficient code. But if you intend to use multiple devices, you could just omit that third step and let the driver do the device-dispatching.\r\n\r\nIn some cases the storage for the DispatchLoaderDynamic should be embedded in a DLL. For those cases you need to define `VULKAN_HPP_STORAGE_SHARED` to tell Vulkan-Hpp that the storage resides in a DLL. When compiling the DLL with the storage it is also required to define `VULKAN_HPP_STORAGE_SHARED_EXPORT` to export the required symbols.\r\n\r\nFor all functions, that `VULKAN_HPP_DEFAULT_DISPATCHER` is the default for the last argument to that function. If you want to explicitly provide the dispatcher for each and every function call (when you have multiple dispatchers for different devices, for example) and you want to make sure, that you don't accidentally miss any function call, you can define `VULKAN_HPP_NO_DEFAULT_DISPATCHER` before you include `vulkan.hpp` to remove that default argument.\r\n\r\n### Type traits\r\n\r\n`vulkan.hpp` provides a couple of type traits, easing template metaprogramming:\r\n- `template <typename EnumType, EnumType value> struct CppType`\r\n\tMaps `IndexType` values (`IndexType::eUint16`, `IndexType::eUint32`, ...) to the corresponding type (`uint16_t`, `uint32_t`, ...) by the member type `Type`;\r\n\tMaps `ObjectType` values (`ObjectType::eInstance`, `ObjectType::eDevice`, ...) to the corresponding type (`vk::Instance`, `vk::Device`, ...) by the member type `Type`;\r\n\tMaps `DebugReportObjectType` values (`DebugReportObjectTypeEXT::eInstance`, `DebugReportObjectTypeEXT::eDevice`, ...) to the corresponding type (`vk::Instance`, `vk::Device`, ...) by the member type `Type`;\r\n- `template <typename T> struct IndexTypeValue`\r\n\tMaps scalar types (`uint16_t`, `uint32_t`, ...) to the corresponding `IndexType` value (`IndexType::eUint16`, `IndexType::eUint32`, ...).\r\n- `template <typename T> struct isVulkanHandleType`\r\n\tMaps a type to `true` if and only if it's a handle class (`vk::Instance`, `vk::Device`, ...) by the static member `value`.\r\n- `HandleClass::CType`\r\n\tMaps a handle class (`vk::Instance`, `vk::Device`, ...) to the corresponding C-type (`VkInstance`, `VkDevice`, ...) by the member type `CType`.\r\n- `HandleClass::objectType`\r\n\tMaps a handle class (`vk::Instance`, `vk::Device`, ...) to the corresponding `ObjectType` value (`ObjectType::eInstance`, `ObjectType::eDevice`, ...) by the static member `objectType`.\r\n- `HandleClass::debugReportObjectType`\r\n\tMaps a handle class (`vk::Instance`, `vk::Device`, ...) to the corresponding `DebugReportObjectTypeEXT` value (`DebugReportObjectTypeEXT::eInstance`, `DebugReportObjectTypeEXT::eDevice`, ...) by the static member `debugReportObjectType`.\r\n\r\n### vk::Format trait functions\r\n\r\nWith the additional header [`vulkan_format_traits.hpp`](vulkan/vulkan_format_traits.hpp), a couple of trait functions on `vk::Format` are provided. With C++14 and above, all those functions are marked as `constexpr`, that is with appropriate arguments, they are resolved at compile time.\r\n- `uin8_t blockSize( vk::Format format );`\r\n\tGets the texel block size of this format in bytes.\r\n- `uint8_t texelsPerBlock( vk::Format format );`\r\n\tGets the number of texels in a texel block.\r\n- `std::array<uint8_t, 3> blockExtent( vk::Format format );`\r\n\tGets the three-dimensional extent of texel blocks.\r\n- `char const * compressionScheme( vk::Format format );`\r\n\tGets a textual description of the compression scheme of this format, or an empty text if it is not compressed.\r\n- `bool isCompressed( vk::Format format );`\r\n\tTrue, if format is a compressed format, otherwise false.\r\n- `uint8_t packed( vk::Format format );`\r\n\tGets the number of bits into which the format is packed. A single image element in this format can be stored in the same space as a scalar type of this bit width.\r\n- `uint8_t componentCount( vk::Format format );`\r\n\tGets the number of components of this format.\r\n- `bool componentsAreCompressed( vk::Format format );`\r\n\tTrue, if the components of this format are compressed, otherwise False.\r\n- `uint8_t componentBits( vk::Format format, uint8_t component );`\r\n\tGets the number of bits in this component, if not compressed, otherwise 0.\r\n- `char const * componentName( vk::Format format, uint8_t component );`\r\n\tGets the name of this component as a c-string.\r\n- `char const * componentNumericFormat( vk::Format format, uint8_t component );`\r\n\tGets the numeric format of this component as a c-string.\r\n- `uint8_t componentPlaneIndex( vk::Format format, uint8_t component );`\r\n\tGets the plane index, this component lies in.\r\n- `uint8_t planeCount( vk::Format format );`\r\n\tGets the number of image planes of this format.\r\n- `vk::Format planeCompatibleFormat( vk::Format format, uint8_t plane );`\r\n\tGets a single-plane format compatible with this plane.\r\n- `uint8_t planeHeightDivisor( vk::Format format, uint8_t plane );`\r\n\tGets the relative height of this plane. A value of k means that this plane is 1/k the height of the overall format.\r\n- `uint8_t planeWidthDivisor( vk::Format format, uint8_t plane );`\r\n\tGets the relative width of this plane. A value of k means that this plane is 1/k the width of the overall format.\r\n\r\n### Hashing Vulkan types\r\n\r\nWith the additional header [`vulkan_hash.hpp`](vulkan/vulkan_hash.hpp), you get specializations of `std::hash` for the handle wrapper classes and, with C++14, for the structure wrappers. With `VULKAN_HPP_HASH_COMBINE`, you can define your own hash combining algorithm for the structure elements.\r\n\r\n### Extension Inspection\r\n\r\nWith the additional header [`vulkan_extension_inspection.hpp`](vulkan/vulkan_extension_inspection.hpp), some functions to inspect extensions are provided. With C++20 and above, some of those functions are marked as `constexpr`, that is with appropriate arguments, they are resolved at compile time.\r\nEach extension is identified by a string holding its name. Note that there exists a define with that name for each extension.\r\nSome functions might provide information that depends on the vulkan version. As all functions here work solely on strings, the vulkan versions are encoded by a string beginning with \"VK_VERSION_\", followed by the major and the minor version, separated by an undersore, like this: \"VK_VERSION_1_0\".\r\n- `std::set<std::string> const & getDeviceExtensions();`\r\n\tGets all device extensions specified for the current platform. Note, that not all of them might be supported by the actual devices.\r\n- `std::set<std::string> const & getInstanceExtensions();`\r\n\tGets all instance extensions specified for the current platform. Note, that not all of them might be supported by the actual instances.\r\n- `std::map<std::string, std::string> const & getDeprecatedExtensions();`\r\n\tGets a map of all deprecated extensions to the extension or vulkan version that is supposed to replace that functionality.\r\n- `std::map<std::string, std::vector<std::vector<std::string>>> const & getExtensionDepends( std::string const & extension );`\r\n\tSome extensions depends on other extensions. That dependencies might differ for different vulkan versions, and there might be different sets of dependencies for the very same vulkan version. This function gets a vector of vectors of extensions per vulkan version that the given extension depends on.\r\n- `std::pair<bool, std::vector<std::vector<std::string>> const &> getExtensionDepends( std::string const & version, std::string const & extension );`\r\n\tThe `first` member of the returned `std::pair` is true, if the given extension is specified for the given vulkan version, otherwise `false`. The `second` member of the returned `std::pair` is a vector of vectors of extensions, listing the separate sets of extensions the given extension depends on for the given vulkan version.\r\n- `std::map<std::string, std::string> const & getObsoletedExtensions();`\r\n\tGets a map of all obsoleted extensions to the extension or vulkan version that has obsoleted that extension.\r\n- `std::map<std::string, std::string> const & getPromotedExtensions();`\r\n\tGets a map of all extensions that got promoted to another extension or to a vulkan version to that extension of vulkan version.\r\n- `VULKAN_HPP_CONSTEXPR_20 std::string getExtensionDeprecatedBy( std::string const & extension );`\r\n\tGets the extension or vulkan version the given extension is deprecated by.\r\n- `VULKAN_HPP_CONSTEXPR_20 std::string getExtensionObsoletedBy( std::string const & extension );`\r\n\tGets the extension or vulkan version the given extension is obsoleted by.\r\n- `VULKAN_HPP_CONSTEXPR_20 std::string getExtensionPromotedTo( std::string const & extension );`\r\n\tGets the extension or vulkan version the given extension is promoted to.\r\n- `VULKAN_HPP_CONSTEXPR_20 bool isDeprecatedExtension( std::string const & extension );`\r\n\tReturns `true` if the given extension is deprecated by some other extension or vulkan version.\r\n- `VULKAN_HPP_CONSTEXPR_20 bool isDeviceExtension( std::string const & extension );`\r\n\tReturns `true` if the given extension is a device extension.\r\n- `VULKAN_HPP_CONSTEXPR_20 bool isInstanceExtension( std::string const & extension );`\r\n\tReturns `true` if the given extension is an instance extension.\r\n- `VULKAN_HPP_CONSTEXPR_20 bool isObsoletedExtension( std::string const & extension );`\r\n\tReturns `true` if the given extension is obsoleted by some other extension or vulkan version.\r\n- `VULKAN_HPP_CONSTEXPR_20 bool isPromotedExtension( std::string const & extension );`\r\n\tReturns `true` if the given extension is promoted to some other extension or vulkan version.\r\n\r\n### C++20 named module\r\n\r\n> [!WARNING]\r\n> The current version of Microsoft Visual Studio 2022 is not able to handle the vulkan.cppm module. A bug is filed (<https://developercommunity.visualstudio.com/t/On-building-a-C20-module:-fatal--error/10469799#T-ND10485943>). You can at least use this feature if you don't need or want to use `vk::UniqueHandle` or `vk::SharedHandle` by defining `VULKAN_HPP_NO_SMART_HANDLE`.\r\n\r\n#### Overview\r\n\r\nVulkan-Hpp provides a [C++ named module](https://en.cppreference.com/w/cpp/language/modules), `vulkan_hpp` in [`vulkan.cppm`](vulkan/vulkan.cppm).\r\nC++ modules are intended to supersede header files. Modules have potential to drastically improve compilation times for large projects, as declarations and definitions may be easily shared across translation units without repeatedly parsing headers.\r\nVulkan-Hpp has some extremely long headers (e.g. [`vulkan_structs.hpp`](vulkan/vulkan_structs.hpp)), and the C++ module is likely to shorten compile times for projects currently using it.\r\n\r\n#### Compiler support\r\n\r\nThis feature requires a recent compiler with complete C++20 support:\r\n\r\n* Visual Studio 2019 16.10 or later (providing `cl.exe` 19.28 or later)\r\n* Clang 15.0.0 or later\r\n\r\nIf you intend to use CMake's C++ module support (and possibly Ninja), then more recent tools are required:\r\n\r\n* Visual Studio 2022 17.4 or later (providing `cl.exe` 19.34 or later)\r\n* Clang 17.0.0 or later\r\n* GCC 14.0 or later\r\n* CMake 3.28 or later\r\n* Ninja 1.10.2 or later\r\n\r\n> [!WARNING]\r\n> The Vulkan-Hpp C++ named module is still experimental. Some suggested ways to use it in your projects are below. The long-term goal is to submit patches to the CMake [`FindVulkan`](https://cmake.org/cmake/help/latest/module/FindVulkan.html) module so that users may transparently configure the named module, without needing to declare it as an additional library in consumer CMake code.\r\n\r\n##### Usage with CMake\r\n\r\nCMake is recommended for use with the Vulkan-Hpp named module, as it provides a convenient platform-agnostic way to configure your project.\r\nCMake version 3.28 or later is required to support C++ modules. Refer to the [CMake documentation](https://cmake.org/cmake/help/latest/manual/cmake-cxxmodules.7.html) on the topic.\r\n\r\nCMake provides the [FindVulkan module](https://cmake.org/cmake/help/latest/module/FindVulkan.html), which may be used to source the Vulkan SDK and Vulkan headers on your system.\r\n\r\n```cmake\r\n# find Vulkan SDK\r\nfind_package( Vulkan REQUIRED )\r\n\r\n# Require Vulkan version ≥ 1.3.256 (earliest version when the Vulkan module was available)\r\nif( ${Vulkan_VERSION} VERSION_LESS \"1.3.256\" )\r\n  message( FATAL_ERROR \"Minimum required Vulkan version for C++ modules is 1.3.256. \"\r\n           \"Found ${Vulkan_VERSION}.\"\r\n  )\r\nendif()\r\n\r\n# set up Vulkan C++ module as a library\r\nadd_library( VulkanHppModule )\r\ntarget_sources( VulkanHppModule PRIVATE\r\n  FILE_SET CXX_MODULES\r\n  BASE_DIRS ${Vulkan_INCLUDE_DIR}\r\n  FILES ${Vulkan_INCLUDE_DIR}/vulkan/vulkan.cppm\r\n)\r\ntarget_compile_features( VulkanHppModule PUBLIC cxx_std_20 )\r\ntarget_link_libraries( VulkanHppModule PUBLIC Vulkan::Vulkan )\r\n\r\n# link Vulkan C++ module into your project\r\nadd_executable( YourProject main.cpp )\r\ntarget_link_libraries( YourProject PRIVATE VulkanHppModule )\r\n```\r\n\r\nConfiguring the named module is straightforward; add any required Vulkan-Hpp feature macros (listed in [Configuration Options](#configuration-options)) to `target_compile_definitions`. For instance:\r\n\r\n```cmake\r\n# Disable exceptions, disable smart handles, disable constructors\r\ntarget_compile_definitions( VulkanHppModule PRIVATE\r\n  VULKAN_HPP_NO_EXCEPTIONS\r\n  VULKAN_HPP_NO_SMART_HANDLE\r\n  VULKAN_HPP_NO_CONSTRUCTORS\r\n)\r\n```\r\n\r\nIt is important to have `VULKAN_HPP_DISPATCH_LOADER_DYNAMIC` defined equally for both the module and an importing project. To use the [dynamic dispatcher](#extensions--per-device-function-pointers), set it to `1`; otherwise, leave it undefined or set it to `0`. In CMake, do this in a single line with `target_compile_definitions` and the `PUBLIC` scope:\r\n\r\n```cmake\r\ntarget_compile_definitions( VulkanHppModule PUBLIC\r\n  VULKAN_HPP_DISPATCH_LOADER_DYNAMIC=1\r\n)\r\n# ...\r\ntarget_link_libraries( YourProject PRIVATE VulkanHppModule )\r\n```\r\n\r\nFurthermore, you may also prefer linking `VulkanHppModule` to just the `Vulkan::Headers` target with the `PUBLIC` scope instead of `Vulkan::Vulkan`, so that the `vulkan-1` library is not linked in, and the Vulkan headers are available to your consuming project, as detailed further below.\r\n\r\n```cmake\r\ntarget_link_libraries( VulkanHppModule PUBLIC Vulkan::Headers )\r\n```\r\n\r\nFinally, supply the macro `VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE` exactly once in your source code, just as in the non-module case. In order to have that macro available, include [`vulkan_hpp_macros.hpp`](vulkan/vulkan_hpp_macros.hpp), a lightweight header providing all Vulkan-Hpp related macros and defines. And as explained above, you need to initialize that dispatcher in two or three steps:\r\n\r\n```cpp\r\nimport vulkan_hpp;\r\n\r\n#include <vulkan/vulkan_hpp_macros.hpp>\r\n\r\n#if VULKAN_HPP_DISPATCH_LOADER_DYNAMIC == 1\r\nVULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE\r\n#endif\r\n\r\nauto main(int argc, char* const argv[]) -> int\r\n{\r\n#if ( VULKAN_HPP_DISPATCH_LOADER_DYNAMIC == 1 )\r\n    // initialize minimal set of function pointers\r\n    VULKAN_HPP_DEFAULT_DISPATCHER.init();\r\n#endif\r\n\r\n  auto appInfo = vk::ApplicationInfo(\"My App\", 1, \"My Engine\", 1, vk::makeApiVersion(1, 0, 0, 0));\r\n  // ...\r\n}\r\n```\r\n\r\nAn example is provided in [`tests/Cpp20Modules/Cpp20Modules.cpp`](tests/Cpp20Modules/Cpp20Modules.cpp).\r\n\r\nFinally, you can configure and build your project as usual.\r\nNote that CMake currently only supports the Ninja and Visual Studio generators for C++ modules.\r\n\r\n##### Command-line usage\r\n\r\nIf you want to use the Vulkan-Hpp C++ module without CMake, you must first pre-compile it, and then import it into your project.\r\nYou will also need to define any macros that control various features of Vulkan-Hpp, such as `VULKAN_HPP_NO_EXCEPTIONS` and `VULKAN_HPP_NO_SMART_HANDLE`.\r\nDifferent compilers have different command-lines for module pre-compilation; however, for initial use, some examples are provided below, assuming the same `main.cpp` consumer as above.\r\n\r\nFor MSVC, source `vcvars64.bat` or use a Developer Command Prompt/Developer PowerShell instance, and run the following:\r\n\r\n```cmd\r\ncl.exe /std:c++20 /interface /TP <path-to-vulkan-hpp>\\vulkan.cppm\r\ncl.exe /std:c++20 /reference vulkan=vulkan.ifc main.cpp vulkan.obj\r\n.\\main.exe\r\n```\r\n\r\nFor Clang, run the following:\r\n\r\n```shell\r\nclang++ -std=c++20 <path-to-vulkan-hpp>/vulkan.cppm -precompile -o vulkan.pcm\r\nclang++ -std=c++20 -fprebuilt-module-path=. main.cpp vulkan.pcm -o main\r\n./main\r\n```\r\n\r\nMore information about module compilation may be found at the respective compiler's documentation:\r\n\r\n* [MSVC](https://learn.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-170)\r\n* [Clang](https://clang.llvm.org/docs/StandardCPlusPlusModules.html)\r\n\r\n### Samples and Tests\r\n\r\nWhen you configure your project using CMake, you can enable SAMPLES_BUILD to add some sample projects to your solution. Most of them are ports from the LunarG samples, but there are some more, like CreateDebugUtilsMessenger, InstanceVersion, PhysicalDeviceDisplayProperties, PhysicalDeviceExtensions, PhysicalDeviceFeatures, PhysicalDeviceGroups, PhysicalDeviceMemoryProperties, PhysicalDeviceProperties, PhysicalDeviceQueueFamilyProperties, and RayTracing. All those samples should just compile and run.\r\nWhen you configure your project using CMake, you can enable TESTS_BUILD to add some test projects to your solution. Those tests are just compilation tests and are not required to run.\r\n\r\n### Compile time issues\r\nAs `vulkan.hpp` is pretty big, some compilers might need some time to digest all that stuff. In order to potentially reduce the time needed to compile that header, a couple of defines will be introduced, that allow you to hide certain features. Whenever you don't need that corresponding feature, defining that value might improve your compile time.\r\nCurrently, there are just a couple of such defines:\r\n- `VULKAN_HPP_NO_SPACESHIP_OPERATOR`, which removes the spaceship operator on structures (available with C++20)\r\n- `VULKAN_HPP_NO_TO_STRING`, which removes the various `vk::to_string` functions on enums and bitmasks.\r\n- `VULKAN_HPP_USE_REFLECT`, this one needs to be defined to use the reflection function on structures. It's very slow to compile, though!\r\n\r\n### Strict aliasing issue\r\n\r\nAs Vulkan-Hpp often needs to switch between C++ vk-types and corresponding bit-identical C-types, using `reinterpret_cast`, it is highly recommended to use the compile option `-fno-strict-aliasing` to prevent potentially breaking compile optimizations.\r\n\r\n## Configuration Options\r\n\r\nThere are a couple of defines you can use to control the feature set and behaviour of `vulkan.hpp`:\r\n\r\n#### VULKAN_HPP_ASSERT\r\n\r\nAt various places in `vulkan.hpp` an assertion statement is used. By default, the standard assert funtions from `<cassert>` is called. By defining `VULKAN_HPP_ASSERT` before including `vulkan.hpp`, you can change that to any function with the very same interface.\r\n\r\n#### VULKAN_HPP_ASSERT_ON_RESULT\r\n\r\nIf there are no exceptions enabled (see `VULKAN_HPP_NO_EXCEPTIONS`), an assertion statement checks for a valid success code returned from every vulkan call. By default, this is the very same assert function as defined by `VULKAN_HPP_ASSERT`, but by defining `VULKAN_HPP_ASSERT_ON_RESULT` you can replace just those assertions with your own function, using the very same interface.\r\n\r\n#### VULKAN_HPP_DEFAULT_DISPATCHER\r\n\r\nEvery vk-function gets a Dispatcher as its very last argument, which defaults to `VULKAN_HPP_DEFAULT_DISPATCHER`. If `VULKAN_HPP_DISPATCH_LOADER_DYNAMIC` is defined to be `1`, it is `defaultDispatchLoaderDynamic`. This in turn is the dispatcher instance, which is defined by `VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE`, which has to be used exactly once in your sources. If, on the other hand, `VULKAN_HPP_DISPATCH_LOADER_DYNAMIC` is defined to something different from `1`, `VULKAN_HPP_DEFAULT_DISPATCHER` is set to be `DispatchLoaderStatic()`.\r\nYou can use your own default dispatcher by setting `VULKAN_HPP_DEFAULT_DISPATCHER` to an object that provides the same API. If you explicitly set `VULKAN_HPP_DEFAULT_DISPATCHER`, you need to set `VULKAN_HPP_DEFAULT_DISPATCHER_TYPE` accordingly as well.\r\n\r\n#### VULKAN_HPP_DEFAULT_DISPATCHER_TYPE\r\n\r\nThis names the default dispatcher type, as specified by `VULKAN_HPP_DEFAULT_DISPATCHER`. Per default, it is DispatchLoaderDynamic or DispatchLoaderStatic, depending on `VULKAN_HPP_DISPATCH_LOADER_DYNAMIC` being `1` or not `1`, respectively. If you explicitly set `VULKAN_HPP_DEFAULT_DISPATCHER`, you need to set `VULKAN_HPP_DEFAULT_DISPATCHER_TYPE` accordingly as well.\r\n\r\n#### VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE\r\n\r\nIf you have not defined your own `VULKAN_HPP_DEFAULT_DISPATCHER`, and have `VULKAN_HPP_DISPATCH_LOADER_DYNAMIC` defined to be `1` (the default), you need to have the macro `VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE` exactly once in any of your source files to provide storage for that default dispatcher. `VULKAN_HPP_STORAGE_API` then controls the import/export status of that default dispatcher.\r\n\r\n#### VULKAN_HPP_DISABLE_ENHANCED_MODE\r\n\r\nWhen this is defined before including `vulkan.hpp`, you essentially disable all enhanced functionality. All you then get is:\r\n* improved compile time error detection, via scoped enums;\r\n* usage of the helper class `vk::Flags` for bitmasks;\r\n* wrapper structs for all vulkan structs providing default initialization;\r\n* the helper class `vk::StructureChain` for compile-time construction of structure chains.\r\n\r\nIf this is not defined, you additionally get:\r\n* enhanced versions of the commands (consuming `vk::ArrayProxy<>`), simplifying handling of array data; returning requested data; throwing exceptions on errors (as long as `VULKAN_HPP_NO_EXCEPTIONS` is not defined);\r\n* enhanced structure constructors (as long as `VULKAN_HPP_NO_STRUCT_CONSTRUCTORS` is not defined) (consuming `vk::ArrayProxyNoTemporaries<>`);\r\n* enhanced setter functions on some members of structs (consuming `vk::ArrayProxyNoTemporaries<>`);\r\n* the helper classes `vk::ArrayProxy<>` and `vk::ArrayProxyNoTemporaries<>`\r\n* all the RAII-stuff in `vulkan_raii.hpp`\r\n\r\n#### VULKAN_HPP_DISPATCH_LOADER_DYNAMIC\r\n\r\nThis either selects the dynamic (when it's `1`) or the static (when it's not `1`) DispatchLoader as the default one, as long as it's not explicitly specified by `VULKAN_HPP_DEFAULT_DISPATCHER`. By default, this is defined to be `1` if `VK_NO_PROTOTYPES` is defined, otherwise `0`.\r\n\r\n#### VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL\r\n\r\nBy default, a little helper class `DynamicLoader` is used to dynamically load the vulkan library. If you set it to something different than `1` before including `vulkan.hpp`, this helper is not available, and you need to explicitly provide your own loader type for the function `DispatchLoaderDynamic::init()`.\r\n\r\n#### VULKAN_HPP_EXPECTED\r\n\r\nWhen this is not externally defined and `VULKAN_HPP_CPP_VERSION` is at least `23`, `VULKAN_HPP_EXPECTED` is defined to be `std::expected`, and `VULKAN_HPP_UNEXPECTED` is defined to be `std::unexpected`.\r\n\r\n#### VULKAN_HPP_FLAGS_MASK_TYPE_AS_PUBLIC\r\n\r\nBy default, the member `m_mask` of the `Flags` class template is private. This is to prevent accidentally setting a `Flags` with some inappropriate value. But it also prevents using a `Flags`, or a structure holding a `Flags`, to be used as a non-type template parameter. If you really need that functionality, and accept the reduced security, you can use this define to change the access specifier for `m_mask` from private to public, which allows using a `Flags` as a non-type template parameter.\r\n\r\n#### VULKAN_HPP_HANDLES_MOVE_EXCHANGE\r\n\r\nThis define can be used to enable `m_handle = exchange( rhs.m_handle, {} )` in move constructors of Vulkan-Hpp handles, which default-initializes the `rhs` underlying value. By default Vulkan-Hpp handles behave like trivial types -- move constructors copying value.\r\n\r\n#### VULKAN_HPP_HASH_COMBINE\r\n\r\nThis define can be used to specify your own hash combiner function. In order to determine the hash of a vk-structure, the hashes of the members of that struct are to be combined. This is done by this define, which by default is identical to what the function `boost::hash_combine()` does. It gets the type of the to-be-combined value, the seed, which is the combined value up to that point, and finally the to-be-combined value. This hash calculation determines a \"shallow\" hash, as it takes the hashes of any pointer in a structure, and not the hash of a pointed-to value.\r\n\r\n#### VULKAN_HPP_INLINE\r\n\r\nThis is set to be the compiler-dependent attribute used to mark functions as inline. If your compiler happens to need some different attribute, you can set this define accordingly before including `vulkan.hpp`.\r\n\r\n#### VULKAN_HPP_NAMESPACE\r\n\r\nBy default, the namespace used with `vulkan.hpp` is `vk`. By defining `VULKAN_HPP_NAMESPACE` before including `vulkan.hpp`, you can adjust this.\r\n\r\n#### VULKAN_HPP_NO_TO_STRING\r\n\r\nBy default, the file [`vulkan_to_string.hpp`](vulkan/vulkan_to_string.hpp) is included by `vulkan.hpp` and provides functions `vk::to_string` for enums and bitmasks. If you don't need those functions, you can define `VULKAN_HPP_NO_TO_STRING` to prevent that inclusion. If you have certain files where you want to use those functions nevertheless, you can explicitly include `vulkan_to_string.hpp` there.\r\n\r\n#### VULKAN_HPP_NO_CONSTRUCTORS\r\n\r\nWith C++20, designated initializers are available. Their use requires the absence of any user-defined constructors. Define `VULKAN_HPP_NO_CONSTRUCTORS` to remove constructors from structs and unions.\r\n\r\n#### VULKAN_HPP_NO_EXCEPTIONS\r\n\r\nWhen a vulkan function returns an error code that is not specified to be a success code, an exception is thrown unless `VULKAN_HPP_NO_EXCEPTIONS` is defined before including `vulkan.hpp`.\r\n\r\n#### VULKAN_HPP_NO_NODISCARD_WARNINGS\r\n\r\nWith C++17, all vk-functions returning something are declared with the attribute `[[nodiscard]]`. This can be removed by defining `VULKAN_HPP_NO_NODISCARD_WARNINGS` before including `vulkan.hpp`.\r\n\r\n#### VULKAN_HPP_NO_SETTERS\r\n\r\nBy defining `VULKAN_HPP_NO_SETTERS` before including `vulkan.hpp`, setter member functions will not be available within structs and unions. Modifying their data members will then only be possible via direct assignment.\r\n\r\n#### VULKAN_HPP_NO_SMART_HANDLE\r\n\r\nBy defining `VULKAN_HPP_NO_SMART_HANDLE` before including `vulkan.hpp`, the helper class `vk::UniqueHandle` and all the unique handle types are not available.\r\n\r\n#### VULKAN_HPP_NO_SPACESHIP_OPERATOR\r\n\r\nWith C++20, the so-called spaceship-operator `<=>` is introduced. If that operator is supported, all the structs and classes in vulkan.hpp use the default implementation of it. As currently some implementations of this operator are very slow, and others seem to be incomplete, by defining `VULKAN_HPP_NO_SPACESHIP_OPERATOR` before including `vulkan.hpp` you can remove that operator from those structs and classes.\r\n\r\n#### VULKAN_HPP_NO_WIN32_PROTOTYPES\r\n\r\nBy default, if `VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL` is enabled on Win32, `vulkan.hpp` declares `HINSTANCE`, `LoadLibraryA`, and other required symbols. It could cause conflicts with the `Windows.h` alternatives, such as `WindowsHModular`.\r\nWith this define, you can disable these declarations, but you will have to declare them before the `vulkan.hpp` is included.\r\n\r\n#### VULKAN_HPP_RAII_NO_EXCEPTIONS\r\n\r\nIf both, `VULKAN_HPP_NO_EXCEPTIONS` and `VULKAN_HPP_EXPECTED` are defined, the vk::raii-classes don't throw exceptions. That is, the actual constructors are not available, but the creation-functions must be used. For more details have a look at the [`vk_raii_ProgrammingGuide.md`](vk_raii_ProgrammingGuide.md).\r\n\r\n#### VULKAN_HPP_SMART_HANDLE_IMPLICIT_CAST\r\n\r\nEven though `vk::UniqueHandle` and `vk::SharedHandle` are semantically close to pointers, an implicit cast operator to the underlying `vk::Handle` might be handy. You can add that implicit cast operator by defining `VULKAN_HPP_SMART_HANDLE_IMPLICIT_CAST`.\r\n\r\n#### VULKAN_HPP_STORAGE_API\r\n\r\nWith this define you can specify whether the `DispatchLoaderDynamic` is imported or exported (see `VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE`). If `VULKAN_HPP_STORAGE_API` is not defined externally, and `VULKAN_HPP_STORAGE_SHARED` is defined, depending on the `VULKAN_HPP_STORAGE_SHARED_EXPORT` being defined, `VULKAN_HPP_STORAGE_API` is either set to `__declspec( dllexport )` (for MSVC) / `__attribute__( ( visibility( \"default\" ) ) )` (for gcc or clang) or `__declspec( dllimport )` (for MSVC), respectively. For other compilers, you might specify the corresponding storage by defining `VULKAN_HPP_STORAGE_API` on your own.\r\n\r\n#### VULKAN_HPP_TYPESAFE_CONVERSION\r\n\r\n32-bit vulkan is not typesafe for non-dispatchable handles, so we don't allow copy constructors on this platform by default. To enable this feature on 32-bit platforms, `#define VULKAN_HPP_TYPESAFE_CONVERSION 1`. To disable this feature on 64-bit platforms, `#define VULKAN_HPP_TYPESAFE_CONVERSION 0`.\r\n\r\n#### VULKAN_HPP_UNEXPECTED\r\n\r\nSee `VULKAN_HPP_EXPECTED`.\r\n\r\n#### VULKAN_HPP_USE_REFLECT\r\n\r\nWith this define you can include a reflection mechanism on the vk-structures. It adds a function `reflect` that returns a tuple-version of the structure. That tuple then could easily be iterated. But at least for now, that feature takes lots of compile-time resources, so currently it is recommended to enable that feature only if you're willing to pay that price.\r\n\r\n## See Also\r\n\r\nFeel free to submit a PR to add to this list.\r\n\r\n- [Examples](https://github.com/jherico/vulkan) A port of Sascha Willems [examples](https://github.com/SaschaWillems/Vulkan) to Vulkan-Hpp\r\n- [Vookoo](https://github.com/andy-thomason/Vookoo/) Stateful helper classes for Vulkan-Hpp, [Introduction Article](https://accu.org/journals/overload/25/139/overload139.pdf#page=14).\r\n\r\n## License\r\n\r\nCopyright 2015-2020 The Khronos Group Inc.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n"
        },
        {
          "name": "VideoHppGenerator.cpp",
          "type": "blob",
          "size": 36.9677734375,
          "content": "// Copyright(c) 2023, NVIDIA CORPORATION. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"VideoHppGenerator.hpp\"\n\n#include \"XMLHelper.hpp\"\n\n#include <iostream>\n#include <vector>\n\nVideoHppGenerator::VideoHppGenerator( tinyxml2::XMLDocument const & document )\n{\n  // read the document and check its correctness\n  int                                       line     = document.GetLineNum();\n  std::vector<tinyxml2::XMLElement const *> elements = getChildElements( &document );\n  checkElements( line, elements, { { \"registry\", true } } );\n  checkForError( elements.size() == 1, line, \"encountered \" + std::to_string( elements.size() ) + \" elements named <registry> but only one is allowed\" );\n  readRegistry( elements[0] );\n  addImplicitlyRequiredTypes();\n  sortStructs();\n  checkCorrectness();\n}\n\nvoid VideoHppGenerator::generateHppFile() const\n{\n  std::string const video_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + \"vulkan_video.hpp\";\n  std::cout << \"VideoHppGenerator: Generating \" << video_hpp << \" ... \" << std::endl;\n\n  std::string const videoHppTemplate = R\"(${copyrightMessage}\n\n#ifndef VULKAN_VIDEO_HPP\n#define VULKAN_VIDEO_HPP\n\n// clang-format off\n#include <vulkan/vulkan.hpp>\n// clang-format on\n\n#include <vk_video/vulkan_video_codec_av1std.h>\n#include <vk_video/vulkan_video_codec_av1std_decode.h>\n#if ( 301 < VK_HEADER_VERSION )\n# include <vk_video/vulkan_video_codec_av1std_encode.h>\n#endif\n#include <vk_video/vulkan_video_codecs_common.h>\n#include <vk_video/vulkan_video_codec_h264std.h>\n#include <vk_video/vulkan_video_codec_h264std_decode.h>\n#include <vk_video/vulkan_video_codec_h264std_encode.h>\n#include <vk_video/vulkan_video_codec_h265std.h>\n#include <vk_video/vulkan_video_codec_h265std_decode.h>\n#include <vk_video/vulkan_video_codec_h265std_encode.h>\n\n#if !defined( VULKAN_HPP_VIDEO_NAMESPACE )\n#  define VULKAN_HPP_VIDEO_NAMESPACE video\n#endif\n\nnamespace VULKAN_HPP_NAMESPACE\n{\nnamespace VULKAN_HPP_VIDEO_NAMESPACE\n{\n${enums}\n${structs}\n}   // namespace VULKAN_HPP_VIDEO_NAMESPACE\n}   // namespace VULKAN_HPP_NAMESPACE\n#endif\n)\";\n\n  std::string str =\n    replaceWithMap( videoHppTemplate, { { \"copyrightMessage\", m_copyrightMessage }, { \"enums\", generateEnums() }, { \"structs\", generateStructs() } } );\n\n  writeToFile( str, video_hpp );\n}\n\nvoid VideoHppGenerator::addImplicitlyRequiredTypes()\n{\n  for ( auto & ext : m_extensions )\n  {\n    for ( auto reqIt = ext.requireData.types.begin(); reqIt != ext.requireData.types.end(); ++reqIt )\n    {\n      std::string name   = *reqIt;\n      auto        typeIt = m_types.find( *reqIt );\n      if ( ( typeIt != m_types.end() ) && ( typeIt->second.category == TypeCategory::Struct ) )\n      {\n        assert( typeIt->second.requiredBy.contains( ext.name ) );\n        reqIt = addImplicitlyRequiredTypes( typeIt, ext, reqIt );\n      }\n    }\n  }\n}\n\nstd::vector<std::string>::iterator VideoHppGenerator::addImplicitlyRequiredTypes( std::map<std::string, TypeData>::iterator typeIt,\n                                                                                  ExtensionData &                           extensionData,\n                                                                                  std::vector<std::string>::iterator        reqIt )\n{\n  auto structIt = m_structs.find( typeIt->first );\n  assert( structIt != m_structs.end() );\n  for ( auto const & member : structIt->second.members )\n  {\n    auto memberTypeIt = m_types.find( member.type.type );\n    if ( ( memberTypeIt != m_types.end() ) && ( memberTypeIt->second.category == TypeCategory::Struct ) )\n    {\n      reqIt = addImplicitlyRequiredTypes( memberTypeIt, extensionData, reqIt );\n    }\n  }\n  assert( typeIt->second.requiredBy.empty() || ( *typeIt->second.requiredBy.begin() == extensionData.name ) ||\n          ( *typeIt->second.requiredBy.begin() == extensionData.depends ) );\n  if ( typeIt->second.requiredBy.empty() && ( std::find( extensionData.requireData.types.begin(), reqIt, typeIt->first ) == reqIt ) )\n  {\n    assert( std::none_of( reqIt, extensionData.requireData.types.end(), [&typeIt]( std::string const & type ) { return type == typeIt->first; } ) );\n    typeIt->second.requiredBy.insert( extensionData.name );\n    reqIt = std::next( extensionData.requireData.types.insert( reqIt, typeIt->first ) );\n  }\n  return reqIt;\n}\n\nvoid VideoHppGenerator::checkCorrectness() const\n{\n  // only structs to check here!\n  for ( auto const & structure : m_structs )\n  {\n    // check that a struct is referenced somewhere\n    // I think, it's not forbidden to not reference a struct, but it would probably be not intended?\n    auto typeIt = m_types.find( structure.first );\n    assert( typeIt != m_types.end() );\n    checkForError( !typeIt->second.requiredBy.empty(), structure.second.xmlLine, \"structure <\" + structure.first + \"> not required by any extension\" );\n\n    assert( typeIt->second.requiredBy.size() == 1 );\n    auto extIt =\n      std::find_if( m_extensions.begin(), m_extensions.end(), [&typeIt]( ExtensionData const & ed ) { return ed.name == *typeIt->second.requiredBy.begin(); } );\n    assert( extIt != m_extensions.end() );\n\n    // checks on the members of a struct\n    for ( auto const & member : structure.second.members )\n    {\n      // check that each member type is known\n      checkForError( m_types.contains( member.type.type ), member.xmlLine, \"struct member uses unknown type <\" + member.type.type + \">\" );\n\n      // check that all member types are required in some extension (it's just a warning!!)\n      if ( member.type.type.starts_with( \"StdVideo\" ) )\n      {\n        auto memberTypeIt = m_types.find( member.type.type );\n        assert( memberTypeIt != m_types.end() );\n        checkForWarning( !memberTypeIt->second.requiredBy.empty(),\n                         member.xmlLine,\n                         \"struct member type <\" + member.type.type + \"> used in struct <\" + structure.first + \"> is never required for any extension\" );\n      }\n\n      // check that all array sizes are a known constant\n      for ( auto const & arraySize : member.arraySizes )\n      {\n        if ( !isNumber( arraySize ) )\n        {\n          bool found = extIt->requireData.constants.contains( arraySize );\n          if ( !found )\n          {\n            checkForError(\n              !extIt->depends.empty(), extIt->xmlLine, \"struct member <\" + member.name + \"> uses unknown constant <\" + arraySize + \"> as array size\" );\n            auto depIt = std::find_if( m_extensions.begin(), m_extensions.end(), [&extIt]( ExtensionData const & ed ) { return ed.name == extIt->depends; } );\n            assert( depIt != m_extensions.end() );\n            checkForError( depIt->requireData.constants.contains( arraySize ),\n                           member.xmlLine,\n                           \"struct member <\" + member.name + \"> uses unknown constant <\" + arraySize + \"> as array size\" );\n          }\n        }\n      }\n    }\n  }\n}\n\nstd::string VideoHppGenerator::generateEnum( std::pair<std::string, EnumData> const & enumData ) const\n{\n  std::string enumValues;\n#if !defined( NDEBUG )\n  std::map<std::string, std::string> valueToNameMap;\n#endif\n\n  // convert the enum name to upper case\n  std::string prefix = toUpperCase( enumData.first ) + \"_\";\n  for ( auto const & value : enumData.second.values )\n  {\n    std::string valueName = \"e\" + toCamelCase( stripPrefix( value.name, prefix ), true );\n    assert( valueToNameMap.insert( { valueName, value.name } ).second );\n    enumValues += \"    \" + valueName + \" = \" + value.name + \",\\n\";\n\n    for ( auto const & alias : value.aliases )\n    {\n      std::string aliasName = \"e\" + toCamelCase( stripPrefix( alias.first, prefix ), true );\n      assert( valueToNameMap.insert( { aliasName, alias.first } ).second );\n      enumValues += \"    \" + aliasName + \" VULKAN_HPP_DEPRECATED_17( \\\"\" + aliasName + \" is deprecated, \" + valueName +\n                    \" should be used instead.\\\" ) = \" + alias.first + \",\\n\";\n    }\n  }\n\n  if ( !enumValues.empty() )\n  {\n    size_t pos = enumValues.rfind( ',' );\n    assert( pos != std::string::npos );\n    enumValues.erase( pos, 1 );\n    enumValues = \"\\n\" + enumValues + \"  \";\n  }\n\n  const std::string enumTemplate = R\"(  enum class ${enumName}\n  {${enumValues}};\n)\";\n\n  return replaceWithMap( enumTemplate, { { \"enumName\", stripPrefix( enumData.first, \"StdVideo\" ) }, { \"enumValues\", enumValues } } );\n}\n\nstd::string VideoHppGenerator::generateEnums() const\n{\n  {\n    const std::string enumsTemplate = R\"(\n  //=============\n  //=== ENUMs ===\n  //=============\n\n${enums}\n)\";\n\n    std::string enums;\n    for ( auto const & extension : m_extensions )\n    {\n      enums += generateEnums( extension.requireData, extension.name );\n    }\n\n    return replaceWithMap( enumsTemplate, { { \"enums\", enums } } );\n  }\n}\n\nstd::string VideoHppGenerator::generateEnums( RequireData const & requireData, std::string const & title ) const\n{\n  std::string str;\n  for ( auto const & type : requireData.types )\n  {\n    auto enumIt = m_enums.find( type );\n    if ( enumIt != m_enums.end() )\n    {\n      str += \"\\n\" + generateEnum( *enumIt );\n    }\n  }\n  if ( !str.empty() )\n  {\n    str = \"\\n    //=== \" + title + \" ===\\n\" + str;\n  }\n  return str;\n}\n\nstd::string VideoHppGenerator::generateStruct( std::pair<std::string, StructureData> const & structData ) const\n{\n  static const std::string structureTemplate = R\"(  struct ${structureType}\n  {\n    using NativeType = StdVideo${structureType};\n\n    operator StdVideo${structureType} const &() const VULKAN_HPP_NOEXCEPT\n    {\n      return *reinterpret_cast<const StdVideo${structureType}*>( this );\n    }\n\n    operator StdVideo${structureType} &() VULKAN_HPP_NOEXCEPT\n    {\n      return *reinterpret_cast<StdVideo${structureType}*>( this );\n    }\n${compareOperators}\n    public:\n${members}\n  };\n)\";\n\n  return replaceWithMap( structureTemplate,\n                         { { \"compareOperators\", generateStructCompareOperators( structData ) },\n                           { \"members\", generateStructMembers( structData ) },\n                           { \"structureType\", stripPrefix( structData.first, \"StdVideo\" ) } } );\n}\n\nstd::string VideoHppGenerator::generateStructCompareOperators( std::pair<std::string, StructureData> const & structData ) const\n{\n  static const std::set<std::string> simpleTypes = { \"char\",   \"double\",  \"DWORD\",    \"float\",    \"HANDLE\",  \"HINSTANCE\", \"HMONITOR\",\n                                                     \"HWND\",   \"int\",     \"int8_t\",   \"int16_t\",  \"int32_t\", \"int64_t\",   \"LPCWSTR\",\n                                                     \"size_t\", \"uint8_t\", \"uint16_t\", \"uint32_t\", \"uint64_t\" };\n\n  // two structs are compared by comparing each of the elements\n  std::string compareMembers;\n  std::string intro = \"\";\n  for ( size_t i = 0; i < structData.second.members.size(); i++ )\n  {\n    MemberData const & member = structData.second.members[i];\n    auto               typeIt = m_types.find( member.type.type );\n    assert( typeIt != m_types.end() );\n    if ( ( typeIt->second.category == TypeCategory::ExternalType ) && member.type.postfix.empty() && !simpleTypes.contains( member.type.type ) )\n    {\n      // this type might support operator==() or operator<=>()... that is, use memcmp\n      compareMembers += intro + \"( memcmp( &\" + member.name + \", &rhs.\" + member.name + \", sizeof( \" + member.type.type + \" ) ) == 0 )\";\n    }\n    else\n    {\n      assert( member.type.type != \"char\" );\n      // for all others, we use the operator== of that type\n      compareMembers += intro + \"( \" + member.name + \" == rhs.\" + member.name + \" )\";\n    }\n    intro = \"\\n          && \";\n  }\n\n  static const std::string compareTemplate = R\"(\n    bool operator==( ${name} const & rhs ) const VULKAN_HPP_NOEXCEPT\n    {\n      return ${compareMembers};\n    }\n\n    bool operator!=( ${name} const & rhs ) const VULKAN_HPP_NOEXCEPT\n    {\n      return !operator==( rhs );\n    }\n)\";\n\n  return replaceWithMap( compareTemplate, { { \"name\", stripPrefix( structData.first, \"StdVideo\" ) }, { \"compareMembers\", compareMembers } } );\n}\n\nstd::string VideoHppGenerator::generateStructMembers( std::pair<std::string, StructureData> const & structData ) const\n{\n  std::string members;\n  for ( auto const & member : structData.second.members )\n  {\n    members += \"    \";\n    std::string type;\n    if ( !member.bitCount.empty() && member.type.type.starts_with( \"StdVideo\" ) )\n    {\n      assert( member.type.prefix.empty() && member.type.postfix.empty() );  // never encounterd a different case\n      type = member.type.type;\n    }\n    else if ( member.arraySizes.empty() )\n    {\n      type = member.type.compose( \"VULKAN_HPP_NAMESPACE::VULKAN_HPP_VIDEO_NAMESPACE\", \"StdVideo\" );\n    }\n    else\n    {\n      assert( member.type.prefix.empty() && member.type.postfix.empty() );\n      type = generateStandardArrayWrapper( member.type.compose( \"VULKAN_HPP_NAMESPACE::VULKAN_HPP_VIDEO_NAMESPACE\" ), member.arraySizes );\n    }\n    members += type + \" \" + member.name;\n\n    // as we don't have any meaningful default initialization values, everything can be initialized by just '{}' !\n    assert( member.arraySizes.empty() || member.bitCount.empty() );\n    if ( !member.bitCount.empty() )\n    {\n      members += \" : \" + member.bitCount;  // except for bitfield members, where no default member initialization\n                                           // is supported (up to C++20)\n    }\n    else\n    {\n      members += \" = \";\n      auto enumIt = m_enums.find( member.type.type );\n      if ( member.arraySizes.empty() && ( enumIt != m_enums.end() ) && member.type.postfix.empty() )\n      {\n        assert( member.type.prefix.empty() && member.arraySizes.empty() && !enumIt->second.values.empty() );\n\n        std::string prefix    = toUpperCase( member.type.type ) + \"_\";\n        std::string valueName = \"e\" + toCamelCase( stripPrefix( enumIt->second.values.front().name, prefix ), true );\n\n        members += type + \"::\" + valueName;\n      }\n      else\n      {\n        members += \"{}\";\n      }\n    }\n    members += \";\\n\";\n  }\n  return members;\n}\n\nstd::string VideoHppGenerator::generateStructs() const\n{\n  const std::string structsTemplate = R\"(\n  //===============\n  //=== STRUCTS ===\n  //===============\n\n${structs}\n)\";\n\n  std::string structs;\n  for ( auto const & extension : m_extensions )\n  {\n    structs += generateStructs( extension.requireData, extension.name );\n  }\n  return replaceWithMap( structsTemplate, { { \"structs\", structs } } );\n}\n\nstd::string VideoHppGenerator::generateStructs( RequireData const & requireData, std::string const & title ) const\n{\n  std::string str;\n  for ( auto const & type : requireData.types )\n  {\n    auto structIt = m_structs.find( type );\n    if ( structIt != m_structs.end() )\n    {\n      str += \"\\n\" + generateStruct( *structIt );\n    }\n  }\n  if ( !str.empty() )\n  {\n    str = \"\\n    //=== \" + title + \" ===\\n\" + str;\n  }\n  return str;\n}\n\nbool VideoHppGenerator::isExtension( std::string const & name ) const\n{\n  return std::any_of( m_extensions.begin(), m_extensions.end(), [&name]( ExtensionData const & ed ) { return ed.name == name; } );\n}\n\nvoid VideoHppGenerator::readEnums( tinyxml2::XMLElement const * element )\n{\n  int                                line       = element->GetLineNum();\n  std::map<std::string, std::string> attributes = getAttributes( element );\n  checkAttributes( line, attributes, { { \"name\", {} } }, { { \"type\", { \"enum\" } } } );\n  std::vector<tinyxml2::XMLElement const *> children = getChildElements( element );\n  checkElements( line, children, { { \"enum\", {} } }, { \"comment\" } );\n\n  std::string name;\n  for ( auto const & attribute : attributes )\n  {\n    if ( attribute.first == \"name\" )\n    {\n      name = attribute.second;\n    }\n    else if ( attribute.first == \"type\" )\n    {\n      assert( !name.empty() );\n      checkForError( attribute.second == \"enum\", line, \"unknown type <\" + attribute.second + \"> for enum <\" + name + \">\" );\n    }\n  }\n\n  // get the EnumData entry in enum map\n  auto enumIt = m_enums.find( name );\n  checkForError( enumIt != m_enums.end(), line, \"enum <\" + name + \"> is not listed as enum in the types section\" );\n  checkForError( enumIt->second.values.empty(), line, \"enum <\" + name + \"> already holds values\" );\n\n  // read the names of the enum values\n  for ( auto child : children )\n  {\n    std::string value = child->Value();\n    if ( value == \"enum\" )\n    {\n      readEnumsEnum( child, enumIt );\n    }\n  }\n}\n\nvoid VideoHppGenerator::readEnumsEnum( tinyxml2::XMLElement const * element, std::map<std::string, EnumData>::iterator enumIt )\n{\n  int                                line       = element->GetLineNum();\n  std::map<std::string, std::string> attributes = getAttributes( element );\n  if ( attributes.contains( \"alias\" ) )\n  {\n    checkAttributes( line, attributes, { { \"alias\", {} }, { \"deprecated\", { \"aliased\" } }, { \"name\", {} } }, {} );\n    checkElements( line, getChildElements( element ), {} );\n\n    std::string alias, name;\n    for ( auto const & attribute : attributes )\n    {\n      if ( attribute.first == \"alias\" )\n      {\n        alias = attribute.second;\n      }\n      else if ( attribute.first == \"name\" )\n      {\n        name = attribute.second;\n      }\n    }\n    assert( !name.empty() );\n\n    auto valueIt =\n      std::find_if( enumIt->second.values.begin(), enumIt->second.values.end(), [&alias]( EnumValueData const & evd ) { return evd.name == alias; } );\n    checkForError( valueIt != enumIt->second.values.end(), line, \"enum value <\" + name + \"> uses unknown alias <\" + alias + \">\" );\n    checkForError( std::find_if( valueIt->aliases.begin(), valueIt->aliases.end(), [&name]( auto const & alias ) { return alias.first == name; } ) ==\n                     valueIt->aliases.end(),\n                   line,\n                   \"enum alias <\" + name + \"> already listed for enum value <\" + alias + \">\" );\n\n    valueIt->aliases.push_back( { name, line } );\n  }\n  else\n  {\n    checkAttributes( line, attributes, { { \"name\", {} }, { \"value\", {} } }, { { \"comment\", {} } } );\n    checkElements( line, getChildElements( element ), {} );\n\n    std::string name, value;\n    for ( auto const & attribute : attributes )\n    {\n      if ( attribute.first == \"name\" )\n      {\n        name = attribute.second;\n      }\n      else if ( attribute.first == \"value\" )\n      {\n        value = attribute.second;\n      }\n    }\n\n    std::string prefix = toUpperCase( enumIt->first ) + \"_\";\n    checkForError( name.starts_with( prefix ), line, \"encountered enum value <\" + name + \"> that does not begin with expected prefix <\" + prefix + \">\" );\n    checkForError( isNumber( value ) || isHexNumber( value ), line, \"enum value uses unknown constant <\" + value + \">\" );\n\n    checkForError(\n      std::none_of( enumIt->second.values.begin(), enumIt->second.values.end(), [&name]( EnumValueData const & evd ) { return evd.name == name; } ),\n      line,\n      \"enum value <\" + name + \"> already part of enum <\" + enumIt->first + \">\" );\n    enumIt->second.values.push_back( { {}, name, value, line } );\n  }\n}\n\nvoid VideoHppGenerator::readExtension( tinyxml2::XMLElement const * element )\n{\n  int                                       line       = element->GetLineNum();\n  std::map<std::string, std::string>        attributes = getAttributes( element );\n  std::vector<tinyxml2::XMLElement const *> children   = getChildElements( element );\n\n  checkAttributes( line, attributes, { { \"name\", {} }, { \"comment\", {} }, { \"supported\", { \"vulkan\" } } }, {} );\n  checkElements( line, children, { { \"require\", false } } );\n\n  ExtensionData extensionData{ .xmlLine = line };\n  std::string   supported;\n  for ( auto const & attribute : attributes )\n  {\n    if ( attribute.first == \"name\" )\n    {\n      extensionData.name = attribute.second;\n      checkForError( !isExtension( extensionData.name ), line, \"already encountered extension <\" + extensionData.name + \">\" );\n    }\n    else if ( attribute.first == \"supported\" )\n    {\n      supported = attribute.second;\n    }\n  }\n  checkForError( supported == \"vulkan\", line, \"extension <\" + extensionData.name + \"> has unknown supported type <\" + supported + \">\" );\n\n  for ( auto child : children )\n  {\n    const std::string value = child->Value();\n    assert( value == \"require\" );\n    readExtensionRequire( child, extensionData );\n  }\n\n  m_extensions.push_back( extensionData );\n}\n\nvoid VideoHppGenerator::readExtensionRequire( tinyxml2::XMLElement const * element, ExtensionData & extensionData )\n{\n  int                                line       = element->GetLineNum();\n  std::map<std::string, std::string> attributes = getAttributes( element );\n  checkAttributes( line, attributes, {}, {} );\n  std::vector<tinyxml2::XMLElement const *> children = getChildElements( element );\n  checkElements( line, children, {}, { \"enum\", \"type\" } );\n\n  extensionData.requireData.xmlLine = line;\n\n  for ( auto child : children )\n  {\n    std::string value = child->Value();\n    if ( value == \"enum\" )\n    {\n      readRequireEnum( child, extensionData.requireData.constants );\n    }\n    else if ( value == \"type\" )\n    {\n      readRequireType( child, extensionData );\n    }\n  }\n  assert( !extensionData.requireData.types.empty() );\n}\n\nvoid VideoHppGenerator::readExtensions( tinyxml2::XMLElement const * element )\n{\n  int line = element->GetLineNum();\n  checkAttributes( line, getAttributes( element ), {}, {} );\n  std::vector<tinyxml2::XMLElement const *> children = getChildElements( element );\n  checkElements( line, children, { { \"extension\", false } } );\n\n  for ( auto child : children )\n  {\n    const std::string value = child->Value();\n    assert( value == \"extension\" );\n    readExtension( child );\n  }\n}\n\nvoid VideoHppGenerator::readRegistry( tinyxml2::XMLElement const * element )\n{\n  int line = element->GetLineNum();\n  checkAttributes( line, getAttributes( element ), {}, {} );\n\n  std::vector<tinyxml2::XMLElement const *> children = getChildElements( element );\n  checkElements( line, children, { { \"comment\", false }, { \"enums\", false }, { \"extensions\", true }, { \"types\", true } } );\n  for ( auto child : children )\n  {\n    const std::string value = child->Value();\n    if ( value == \"comment\" )\n    {\n      std::string comment = readComment( child );\n      if ( comment.find( \"\\nCopyright\" ) == 0 )\n      {\n        m_copyrightMessage = generateCopyrightMessage( comment );\n      }\n    }\n    else if ( value == \"enums\" )\n    {\n      readEnums( child );\n    }\n    else if ( value == \"extensions\" )\n    {\n      readExtensions( child );\n    }\n    else\n    {\n      assert( value == \"types\" );\n      readTypes( child );\n    }\n  }\n  checkForError( !m_copyrightMessage.empty(), -1, \"missing copyright message\" );\n}\n\nvoid VideoHppGenerator::readRequireEnum( tinyxml2::XMLElement const * element, std::map<std::string, ConstantData> & constants )\n{\n  int                                line       = element->GetLineNum();\n  std::map<std::string, std::string> attributes = getAttributes( element );\n  checkElements( line, getChildElements( element ), {} );\n  checkAttributes( line, attributes, { { \"name\", {} }, { \"value\", {} } }, {} );\n\n  std::string name, value;\n  for ( auto const & attribute : attributes )\n  {\n    if ( attribute.first == \"name\" )\n    {\n      name = attribute.second;\n    }\n    else if ( attribute.first == \"value\" )\n    {\n      value = attribute.second;\n    }\n  }\n\n  if ( !name.ends_with( \"_SPEC_VERSION\" ) && !name.ends_with( \"_EXTENSION_NAME\" ) )\n  {\n    checkForError( isNumber( value ) || isHexNumber( value ), line, \"enum value uses unknown constant <\" + value + \">\" );\n    checkForError( constants.insert( { name, { value, line } } ).second, line, \"required enum <\" + name + \"> already specified\" );\n  }\n}\n\nvoid VideoHppGenerator::readRequireType( tinyxml2::XMLElement const * element, ExtensionData & extensionData )\n{\n  int                                line       = element->GetLineNum();\n  std::map<std::string, std::string> attributes = getAttributes( element );\n  checkAttributes( line, attributes, { { \"name\", {} } }, { { \"comment\", {} } } );\n  checkElements( line, getChildElements( element ), {} );\n\n  std::string name = attributes.find( \"name\" )->second;\n  if ( name.starts_with( \"vk_video/vulkan_video_codec\" ) && name.ends_with( \".h\" ) )\n  {\n    checkForError( extensionData.depends.empty(), line, \"extension <\" + extensionData.name + \"> already depends on <\" + extensionData.name + \">\" );\n    extensionData.depends = stripPrefix( stripPostfix( name, \".h\" ), \"vk_video/\" );\n    checkForError( isExtension( extensionData.depends ), line, \"extension <\" + extensionData.name + \"> uses unknown header <\" + name + \">\" );\n  }\n  else\n  {\n    auto typeIt = m_types.find( name );\n    checkForError( typeIt != m_types.end(), line, \"unknown required type <\" + name + \">\" );\n    typeIt->second.requiredBy.insert( extensionData.name );\n    extensionData.requireData.types.push_back( name );\n  }\n}\n\nvoid VideoHppGenerator::readStructMember( tinyxml2::XMLElement const * element, std::vector<MemberData> & members )\n{\n  (void)members;\n  int                                line       = element->GetLineNum();\n  std::map<std::string, std::string> attributes = getAttributes( element );\n  checkAttributes( line, attributes, {}, {} );\n  std::vector<tinyxml2::XMLElement const *> children = getChildElements( element );\n  checkElements( line, children, { { \"name\", true }, { \"type\", true } }, { \"comment\", \"enum\" } );\n\n  MemberData memberData;\n  memberData.xmlLine = line;\n\n  std::string name;\n  for ( auto child : children )\n  {\n    int childLine = child->GetLineNum();\n    checkAttributes( childLine, getAttributes( child ), {}, {} );\n    checkElements( childLine, getChildElements( child ), {}, {} );\n\n    std::string value = child->Value();\n    if ( value == \"enum\" )\n    {\n      std::string enumString = child->GetText();\n\n      checkForError( child->PreviousSibling() && child->NextSibling(), line, \"struct member array specification is ill-formatted: <\" + enumString + \">\" );\n      std::string previous = child->PreviousSibling()->Value();\n      std::string next     = child->NextSibling()->Value();\n      checkForError( previous.ends_with( \"[\" ) && next.starts_with( \"]\" ), line, \"struct member array specification is ill-formatted: <\" + enumString + \">\" );\n\n      memberData.arraySizes.push_back( enumString );\n    }\n    else if ( value == \"name\" )\n    {\n      name                                                   = child->GetText();\n      std::tie( memberData.arraySizes, memberData.bitCount ) = readModifiers( child->NextSibling() );\n    }\n    else if ( value == \"type\" )\n    {\n      memberData.type = readTypeInfo( child );\n    }\n  }\n  assert( !name.empty() );\n\n  checkForError( std::none_of( members.begin(), members.end(), [&name]( MemberData const & md ) { return md.name == name; } ),\n                 line,\n                 \"struct member name <\" + name + \"> already used\" );\n  memberData.name = name;\n  members.push_back( memberData );\n}\n\nvoid VideoHppGenerator::readTypeDefine( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes )\n{\n  int line = element->GetLineNum();\n  checkAttributes( line, attributes, { { \"category\", { \"define\" } } }, { { \"requires\", {} } } );\n  std::vector<tinyxml2::XMLElement const *> children = getChildElements( element );\n  checkElements( line, children, { { \"name\", false } }, { \"type\" } );\n\n  std::string require;\n  for ( auto const & attribute : attributes )\n  {\n    if ( attribute.first == \"requires\" )\n    {\n      require = attribute.second;\n    }\n  }\n\n  std::string name, type;\n  for ( auto child : children )\n  {\n    const std::string value = child->Value();\n    if ( value == \"name\" )\n    {\n      name = child->GetText();\n    }\n    else if ( value == \"type\" )\n    {\n      type = child->GetText();\n    }\n  }\n  checkForError( require.empty() || m_defines.contains( require ), line, \"define <\" + name + \"> requires unknown type <\" + require + \">\" );\n  checkForError( type.empty() || m_defines.contains( type ), line, \"define <\" + name + \"> of unknown type <\" + type + \">\" );\n\n  checkForError( m_types.insert( { name, TypeData{ TypeCategory::Define, {}, line } } ).second, line, \"define <\" + name + \"> already specified\" );\n  assert( !m_defines.contains( name ) );\n  m_defines[name] = { require, line };\n}\n\nvoid VideoHppGenerator::readTypeEnum( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes )\n{\n  int line = element->GetLineNum();\n  checkAttributes( line, attributes, { { \"category\", { \"enum\" } }, { \"name\", {} } }, {} );\n  checkElements( line, getChildElements( element ), {} );\n\n  std::string name;\n  for ( auto const & attribute : attributes )\n  {\n    if ( attribute.first == \"name\" )\n    {\n      name = attribute.second;\n    }\n  }\n\n  checkForError( m_types.insert( { name, TypeData{ TypeCategory::Enum, {}, line } } ).second, line, \"enum <\" + name + \"> already specified\" );\n  assert( !m_enums.contains( name ) );\n  m_enums[name] = EnumData{ .xmlLine = line };\n}\n\nvoid VideoHppGenerator::readTypeInclude( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes )\n{\n  int line = element->GetLineNum();\n  checkAttributes( line, attributes, { { \"category\", { \"include\" } }, { \"name\", {} } }, {} );\n  checkElements( line, getChildElements( element ), {} );\n\n  std::string name = attributes.find( \"name\" )->second;\n  checkForError( m_types.insert( { name, TypeData{ TypeCategory::Include, {}, line } } ).second, line, \"type <\" + name + \"> already specified\" );\n  assert( !m_includes.contains( name ) );\n  m_includes[name] = { line };\n}\n\nvoid VideoHppGenerator::readTypeRequires( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes )\n{\n  int line = element->GetLineNum();\n  checkAttributes( line, attributes, { { \"name\", {} }, { \"requires\", {} } }, {} );\n  checkElements( line, getChildElements( element ), {} );\n\n  std::string name, require;\n  for ( auto attribute : attributes )\n  {\n    if ( attribute.first == \"name\" )\n    {\n      name = attribute.second;\n    }\n    else\n    {\n      assert( attribute.first == \"requires\" );\n      require = attribute.second;\n    }\n  }\n\n  checkForError( m_includes.contains( require ), line, \"type <\" + name + \"> requires unknown <\" + require + \">\" );\n  checkForError( m_types.insert( { name, TypeData{ TypeCategory::ExternalType, {}, line } } ).second, line, \"type <\" + name + \"> already specified\" );\n  assert( !m_externalTypes.contains( name ) );\n  m_externalTypes[name] = { require, line };\n}\n\nvoid VideoHppGenerator::readTypes( tinyxml2::XMLElement const * element )\n{\n  int line = element->GetLineNum();\n  checkAttributes( line, getAttributes( element ), { { \"comment\", {} } }, {} );\n  std::vector<tinyxml2::XMLElement const *> children = getChildElements( element );\n  checkElements( line, children, { { \"type\", false } } );\n\n  for ( auto child : children )\n  {\n    std::string value = child->Value();\n    if ( value == \"type\" )\n    {\n      readTypesType( child );\n    }\n  }\n}\n\nvoid VideoHppGenerator::readTypeStruct( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes )\n{\n  int line = element->GetLineNum();\n  checkAttributes( line, attributes, { { \"category\", { \"struct\" } }, { \"name\", {} } }, { { \"comment\", {} }, { \"requires\", {} } } );\n  std::vector<tinyxml2::XMLElement const *> children = getChildElements( element );\n  checkElements( line, children, { { \"member\", false } }, { \"comment\" } );\n\n  StructureData structureData{ .xmlLine = line };\n\n  std::string name, require;\n  for ( auto const & attribute : attributes )\n  {\n    if ( attribute.first == \"name\" )\n    {\n      name = attribute.second;\n    }\n    else if ( attribute.first == \"requires\" )\n    {\n      require = attribute.second;\n    }\n  }\n  assert( !name.empty() );\n  checkForError( require.empty() || m_types.contains( require ), line, \"struct <\" + name + \"> requires unknown type <\" + require + \">\" );\n  checkForError( m_types.insert( { name, TypeData{ TypeCategory::Struct, {}, line } } ).second, line, \"struct <\" + name + \"> already specified\" );\n  assert( !m_structs.contains( name ) );\n  std::map<std::string, StructureData>::iterator it = m_structs.insert( std::make_pair( name, structureData ) ).first;\n\n  for ( auto child : children )\n  {\n    std::string value = child->Value();\n    if ( value == \"member\" )\n    {\n      readStructMember( child, it->second.members );\n    }\n  }\n}\n\nvoid VideoHppGenerator::readTypesType( tinyxml2::XMLElement const * element )\n{\n  int                                line       = element->GetLineNum();\n  std::map<std::string, std::string> attributes = getAttributes( element );\n\n  auto categoryIt = attributes.find( \"category\" );\n  if ( categoryIt != attributes.end() )\n  {\n    if ( categoryIt->second == \"define\" )\n    {\n      readTypeDefine( element, attributes );\n    }\n    else if ( categoryIt->second == \"enum\" )\n    {\n      readTypeEnum( element, attributes );\n    }\n    else if ( categoryIt->second == \"include\" )\n    {\n      readTypeInclude( element, attributes );\n    }\n    else if ( categoryIt->second == \"struct\" )\n    {\n      readTypeStruct( element, attributes );\n    }\n    else\n    {\n      checkForError( false, line, \"unknown category <\" + categoryIt->second + \"> encountered\" );\n    }\n  }\n  else\n  {\n    auto requiresIt = attributes.find( \"requires\" );\n    if ( requiresIt != attributes.end() )\n    {\n      readTypeRequires( element, attributes );\n    }\n    else\n    {\n      checkForError( ( attributes.size() == 1 ) && ( attributes.begin()->first == \"name\" ) && ( attributes.begin()->second == \"int\" ), line, \"unknown type\" );\n      checkForError( m_types.insert( { \"int\", TypeData{ TypeCategory::Unknown, {}, line } } ).second, line, \"type <int> already specified\" );\n    }\n  }\n}\n\nvoid VideoHppGenerator::sortStructs()\n{\n  for ( auto & ext : m_extensions )\n  {\n    for ( auto reqIt = ext.requireData.types.begin(); reqIt != ext.requireData.types.end(); ++reqIt )\n    {\n      std::string name   = *reqIt;\n      auto        typeIt = m_types.find( *reqIt );\n      if ( ( typeIt != m_types.end() ) && ( typeIt->second.category == TypeCategory::Struct ) )\n      {\n        auto structIt = m_structs.find( typeIt->first );\n        assert( structIt != m_structs.end() );\n        for ( auto const & member : structIt->second.members )\n        {\n          auto memberTypeIt = m_types.find( member.type.type );\n          assert( memberTypeIt != m_types.end() );\n          if ( ( memberTypeIt->second.category == TypeCategory::Struct ) && ( std::find( ext.requireData.types.begin(), reqIt, member.type.type ) == reqIt ) )\n          {\n            auto it = std::find( std::next( reqIt ), ext.requireData.types.end(), member.type.type );\n            if ( it != ext.requireData.types.end() )\n            {\n              ext.requireData.types.erase( it );\n              reqIt = std::next( ext.requireData.types.insert( reqIt, member.type.type ) );\n            }\n#if !defined( NDEBUG )\n            else\n            {\n              auto depIt = std::find_if( m_extensions.begin(), m_extensions.end(), [&ext]( ExtensionData const & ed ) { return ed.name == ext.depends; } );\n              assert( ( depIt != m_extensions.end() ) && std::any_of( depIt->requireData.types.begin(),\n                                                                      depIt->requireData.types.end(),\n                                                                      [&member]( std::string const & type ) { return type == member.type.type; } ) );\n            }\n#endif\n          }\n        }\n      }\n    }\n  }\n}\n\nint main( int argc, char ** argv )\n{\n  if ( ( argc % 2 ) == 0 )\n  {\n    std::cout << \"VideoHppGenerator usage: VideoHppGenerator [-f filename]\" << std::endl;\n    std::cout << \"\\tdefault for filename is <\" << VIDEO_SPEC << \">\" << std::endl;\n    return -1;\n  }\n\n  std::string filename = VIDEO_SPEC;\n  for ( int i = 1; i < argc; i += 2 )\n  {\n    if ( strcmp( argv[i], \"-f\" ) == 0 )\n    {\n      filename = argv[i + 1];\n    }\n    else\n    {\n      std::cout << \"unsupported argument <\" << argv[i] << \">\" << std::endl;\n      return -1;\n    }\n  }\n\n#if defined( CLANG_FORMAT_EXECUTABLE )\n  std::cout << \"VideoHppGenerator: Found \";\n  std::string commandString = \"\\\"\" CLANG_FORMAT_EXECUTABLE \"\\\" --version \";\n  int         ret           = std::system( commandString.c_str() );\n  if ( ret != 0 )\n  {\n    std::cout << \"VideoHppGenerator: failed to determine clang_format version with error <\" << ret << \">\\n\";\n  }\n#endif\n\n  tinyxml2::XMLDocument doc;\n  std::cout << \"VideoHppGenerator: Loading \" << filename << std::endl;\n  tinyxml2::XMLError error = doc.LoadFile( filename.c_str() );\n  if ( error != tinyxml2::XML_SUCCESS )\n  {\n    std::cout << \"VideoHppGenerator: failed to load file \" << filename << \" with error <\" << toString( error ) << \">\" << std::endl;\n    return -1;\n  }\n\n  try\n  {\n    std::cout << \"VideoHppGenerator: Parsing \" << filename << std::endl;\n    VideoHppGenerator generator( doc );\n\n    generator.generateHppFile();\n\n#if !defined( CLANG_FORMAT_EXECUTABLE )\n    std::cout << \"VideoHppGenerator: could not find clang-format. The generated files will not be formatted accordingly.\\n\";\n#endif\n  }\n  catch ( std::exception const & e )\n  {\n    std::cout << \"caught exception: \" << e.what() << std::endl;\n    return -1;\n  }\n  catch ( ... )\n  {\n    std::cout << \"caught unknown exception\" << std::endl;\n    return -1;\n  }\n  return 0;\n}\n"
        },
        {
          "name": "VideoHppGenerator.hpp",
          "type": "blob",
          "size": 5.1220703125,
          "content": "// Copyright(c) 2023, NVIDIA CORPORATION. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"XMLHelper.hpp\"\n\n#include <map>\n#include <string>\n#include <tinyxml2.h>\n\nclass VideoHppGenerator\n{\npublic:\n  VideoHppGenerator( tinyxml2::XMLDocument const & document );\n\n  void generateHppFile() const;\n\nprivate:\n  struct ConstantData\n  {\n    std::string value   = {};\n    int         xmlLine = {};\n  };\n\n  struct DefineData\n  {\n    std::string require = {};\n    int         xmlLine = {};\n  };\n\n  struct EnumValueData\n  {\n    std::vector<std::pair<std::string, int>> aliases = {};\n    std::string                              name    = {};\n    std::string                              value   = {};\n    int                                      xmlLine = {};\n  };\n\n  struct EnumData\n  {\n    std::vector<EnumValueData> values  = {};\n    int                        xmlLine = {};\n  };\n\n  struct RequireData\n  {\n    std::map<std::string, ConstantData> constants = {};\n    std::vector<std::string>            types     = {};\n    int                                 xmlLine   = {};\n  };\n\n  struct ExtensionData\n  {\n    std::string depends     = {};\n    std::string name        = {};\n    RequireData requireData = {};\n    int         xmlLine     = 0;\n  };\n\n  struct MemberData\n  {\n    TypeInfo                 type       = {};\n    std::string              name       = {};\n    std::vector<std::string> arraySizes = {};\n    std::string              bitCount   = {};\n    int                      xmlLine    = {};\n  };\n\n  struct StructureData\n  {\n    std::vector<MemberData> members = {};\n    int                     xmlLine = {};\n  };\n\nprivate:\n  void addImplicitlyRequiredTypes();\n  std::vector<std::string>::iterator\n       addImplicitlyRequiredTypes( std::map<std::string, TypeData>::iterator typeIt, ExtensionData & extensionData, std::vector<std::string>::iterator reqIt );\n  void checkCorrectness() const;\n  std::string generateEnum( std::pair<std::string, EnumData> const & enumData ) const;\n  std::string generateEnums() const;\n  std::string generateEnums( RequireData const & requireData, std::string const & title ) const;\n  std::string generateStruct( std::pair<std::string, StructureData> const & structData ) const;\n  std::string generateStructCompareOperators( std::pair<std::string, StructureData> const & structData ) const;\n  std::string generateStructMembers( std::pair<std::string, StructureData> const & structData ) const;\n  std::string generateStructs() const;\n  std::string generateStructs( RequireData const & requireData, std::string const & title ) const;\n  bool        isExtension( std::string const & name ) const;\n  void        readEnums( tinyxml2::XMLElement const * element );\n  void        readEnumsEnum( tinyxml2::XMLElement const * element, std::map<std::string, EnumData>::iterator enumIt );\n  void        readExtension( tinyxml2::XMLElement const * element );\n  void        readExtensionRequire( tinyxml2::XMLElement const * element, ExtensionData & extensionData );\n  void        readExtensions( tinyxml2::XMLElement const * element );\n  void        readRegistry( tinyxml2::XMLElement const * element );\n  void        readRequireEnum( tinyxml2::XMLElement const * element, std::map<std::string, ConstantData> & constants );\n  void        readRequireType( tinyxml2::XMLElement const * element, ExtensionData & extensionData );\n  void        readStructMember( tinyxml2::XMLElement const * element, std::vector<MemberData> & members );\n  void        readTypeDefine( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void        readTypeEnum( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void        readTypeInclude( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void        readTypeRequires( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void        readTypes( tinyxml2::XMLElement const * element );\n  void        readTypeStruct( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void        readTypesType( tinyxml2::XMLElement const * element );\n  void        sortStructs();\n\nprivate:\n  std::string                             m_copyrightMessage;\n  std::map<std::string, DefineData>       m_defines;\n  std::map<std::string, EnumData>         m_enums;\n  std::vector<ExtensionData>              m_extensions;\n  std::map<std::string, ExternalTypeData> m_externalTypes;\n  std::map<std::string, IncludeData>      m_includes;\n  std::map<std::string, StructureData>    m_structs;\n  std::map<std::string, TypeData>         m_types;\n};"
        },
        {
          "name": "Vulkan-Headers",
          "type": "commit",
          "content": null
        },
        {
          "name": "VulkanHpp.natvis",
          "type": "blob",
          "size": 0.369140625,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<AutoVisualizer xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\">\n  <Type Name=\"vk::Flags&lt;*&gt;\">\n    <DisplayString>[{($T1)m_mask}]</DisplayString>\n  </Type>\n  <Type Name=\"vk::ArrayWrapper1D&lt;char,*&gt;\">\n    <DisplayString>{_Elems,s}</DisplayString>\n    <StringView>_Elems,s</StringView>\n  </Type>\n</AutoVisualizer>"
        },
        {
          "name": "VulkanHppGenerator.cpp",
          "type": "blob",
          "size": 729.865234375,
          "content": "// Copyright(c) 2015-2020, NVIDIA CORPORATION. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"VulkanHppGenerator.hpp\"\n\n#include \"XMLHelper.hpp\"\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <fstream>\n#include <future>\n#include <regex>\n#include <sstream>\n\nusing namespace std::literals;\n\nnamespace\n{\n  std::vector<std::pair<std::string, size_t>> filterNumbers( std::vector<std::string> const & names );\n  template <typename T>\n  typename std::vector<T>::iterator findByName( std::vector<T> & values, std::string const & name );\n  template <typename T>\n  typename std::map<std::string, T>::const_iterator findByNameOrAlias( std::map<std::string, T> const & values, std::string const & name );\n  template <typename T>\n  typename std::map<std::string, T>::iterator findByNameOrAlias( std::map<std::string, T> & values, std::string const & name );\n  template <typename T>\n  typename std::vector<T>::const_iterator findByNameOrAlias( std::vector<T> const & values, std::string const & name );\n  template <typename T>\n  typename std::vector<T>::iterator findByNameOrAlias( std::vector<T> & values, std::string const & name );\n  std::string                       generateCArraySizes( std::vector<std::string> const & sizes );\n  std::string                       generateList( std::vector<std::string> const & elements, std::string const & prefix, std::string const & separator );\n  std::string                       generateNamespacedType( std::string const & type );\n  std::string                       generateNoDiscard( bool returnsSomething, bool multiSuccessCodes, bool multiErrorCodes );\n  std::string                       generateStandardArray( std::string const & type, std::vector<std::string> const & sizes );\n  bool                              isAllUpper( std::string const & name );\n  VulkanHppGenerator::MacroData     parseMacro( std::vector<std::string> const & completeMacro );\n  std::string                       readSnippet( std::string const & snippetFile );\n  std::string                       startLowerCase( std::string const & input );\n  std::string                       startUpperCase( std::string const & input );\n  std::vector<std::string>          tokenizeAny( std::string const & tokenString, std::string const & separators );\n}  // namespace\n\nvoid writeToFile( std::string const & str, std::string const & fileName );\n\nconst std::set<std::string> specialPointerTypes = { \"Display\", \"IDirectFB\", \"wl_display\", \"xcb_connection_t\", \"_screen_window\" };\n\n//\n// VulkanHppGenerator public interface\n//\n\nVulkanHppGenerator::VulkanHppGenerator( tinyxml2::XMLDocument const & document, std::string const & api ) : m_api( api )\n{\n  // insert the default \"handle\" without class (for createInstance, and such)\n  m_handles.insert( std::make_pair( \"\", HandleData() ) );\n\n  // read the document and check its correctness\n  const int                                 line     = document.GetLineNum();\n  std::vector<tinyxml2::XMLElement const *> elements = getChildElements( &document );\n  checkElements( line, elements, { { \"registry\", true } } );\n  checkForError( elements.size() == 1, line, \"encountered \" + std::to_string( elements.size() ) + \" elements named <registry> but only one is allowed\" );\n  readRegistry( elements[0] );\n  filterLenMembers();\n  checkCorrectness();\n  handleRemovals();\n\n  // add the commands to the respective handles\n  // some \"FlagBits\" enums are not specified, but needed for our \"Flags\" handling -> add them here\n  for ( auto & feature : m_features )\n  {\n    addCommandsToHandle( feature.requireData );\n    addMissingFlagBits( feature.requireData, feature.name );\n  }\n  for ( auto & extension : m_extensions )\n  {\n    addCommandsToHandle( extension.requireData );\n    addMissingFlagBits( extension.requireData, extension.name );\n  }\n\n  m_definesPartition = partitionDefines( m_defines );\n}\n\nvoid VulkanHppGenerator::distributeSecondLevelCommands()\n{\n  // distribute commands from instance/device to second-level handles, like Queue, Event,... for RAII handles\n  for ( auto & handle : m_handles )\n  {\n    if ( !handle.first.empty() )\n    {\n      for ( auto command = handle.second.commands.begin(); command != handle.second.commands.end(); )\n      {\n        bool foundCommand = false;\n        if ( !m_RAIISpecialFunctions.contains( *command ) )\n        {\n          auto commandIt = findByNameOrAlias( m_commands, *command );\n          assert( commandIt != m_commands.end() );\n          assert( commandIt->second.params.front().type.type == handle.first );\n          if ( ( 1 < commandIt->second.params.size() ) && ( isHandleType( commandIt->second.params[1].type.type ) ) && !commandIt->second.params[1].optional )\n          {\n            auto handleIt = m_handles.find( commandIt->second.params[1].type.type );\n            assert( handleIt != m_handles.end() );\n            // filter out functions seem to fit due to taking handles as first and second argument, but the first argument is not the\n            // type to create the second one, and so it's unknown to the raii handle!\n            assert( !handleIt->second.constructorIts.empty() );\n            if ( ( *handleIt->second.constructorIts.begin() )->second.handle == handle.first )\n            {\n              assert( std::none_of( handleIt->second.constructorIts.begin(),\n                                    handleIt->second.constructorIts.end(),\n                                    [&handle]( auto const & constructorIt ) { return constructorIt->second.handle != handle.first; } ) );\n              handleIt->second.secondLevelCommands.insert( *command );\n              command      = handle.second.commands.erase( command );\n              foundCommand = true;\n            }\n          }\n        }\n        if ( !foundCommand )\n        {\n          ++command;\n        }\n      }\n    }\n  }\n}\n\nvoid VulkanHppGenerator::generateEnumsHppFile() const\n{\n  std::string const vulkan_enums_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_enums.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_enums_hpp + \" ...\\n\" );\n\n  std::string const vulkanEnumsHppTemplate = R\"(${licenseHeader}\n#ifndef VULKAN_ENUMS_HPP\n#  define VULKAN_ENUMS_HPP\n\n// include-what-you-use: make sure, vulkan.hpp is used by code-completers\n// IWYU pragma: private; include \"vulkan.hpp\"\n\nnamespace VULKAN_HPP_NAMESPACE\n{\n${Flags}\n\n${enums}\n${objectTypeToDebugReportObjectType}\n}   // namespace VULKAN_HPP_NAMESPACE\n#endif\n)\";\n\n  std::string str = replaceWithMap( vulkanEnumsHppTemplate,\n                                    { { \"enums\", generateEnums() },\n                                      { \"Flags\", readSnippet( \"Flags.hpp\" ) },\n                                      { \"licenseHeader\", m_vulkanLicenseHeader },\n                                      { \"objectTypeToDebugReportObjectType\", generateObjectTypeToDebugReportObjectType() } } );\n\n  writeToFile( str, vulkan_enums_hpp );\n}\n\nvoid VulkanHppGenerator::generateExtensionInspectionFile() const\n{\n  std::string const vulkan_extension_inspection_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_extension_inspection.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_extension_inspection_hpp + \" ...\\n\" );\n\n  std::string const vulkanExtensionInspectionHppTemplate = readSnippet( \"ExtensionInspection.hpp\" );\n  std::string const deprecatedExtensions = generateReplacedExtensionsList( []( ExtensionData const & extension ) { return extension.isDeprecated; },\n                                                                           []( ExtensionData const & extension ) { return extension.deprecatedBy; } );\n  std::string const deprecatedBy         = generateExtensionReplacedBy( []( ExtensionData const & extension ) { return extension.isDeprecated; },\n                                                                []( ExtensionData const & extension ) { return extension.deprecatedBy; } );\n  std::string const obsoletedBy          = generateExtensionReplacedBy( []( ExtensionData const & extension ) { return !extension.obsoletedBy.empty(); },\n                                                               []( ExtensionData const & extension ) { return extension.obsoletedBy; } );\n  std::string const obsoletedExtensions  = generateReplacedExtensionsList( []( ExtensionData const & extension ) { return !extension.obsoletedBy.empty(); },\n                                                                          []( ExtensionData const & extension ) { return extension.obsoletedBy; } );\n  std::string const promotedExtensions   = generateReplacedExtensionsList( []( ExtensionData const & extension ) { return !extension.promotedTo.empty(); },\n                                                                         []( ExtensionData const & extension ) { return extension.promotedTo; } );\n  std::string const promotedTo           = generateExtensionReplacedBy( []( ExtensionData const & extension ) { return !extension.promotedTo.empty(); },\n                                                              []( ExtensionData const & extension ) { return extension.promotedTo; } );\n\n  std::string str =\n    replaceWithMap( vulkanExtensionInspectionHppTemplate,\n                    { { \"api\", m_api },\n                      { \"deprecatedExtensions\", deprecatedExtensions },\n                      { \"deviceExtensions\", generateExtensionsList( \"device\" ) },\n                      { \"deviceTest\", generateExtensionTypeTest( \"device\" ) },\n                      { \"deprecatedBy\", deprecatedBy },\n                      { \"deprecatedTest\", generateExtensionReplacedTest( []( ExtensionData const & extension ) { return extension.isDeprecated; } ) },\n                      { \"extensionDependencies\", generateExtensionDependencies() },\n                      { \"getExtensionDependsByVersionDeclaration\", generateExtensionDependsByVersion( false ) },\n                      { \"getExtensionDependsByVersionDefinition\", generateExtensionDependsByVersion( true ) },\n                      { \"instanceExtensions\", generateExtensionsList( \"instance\" ) },\n                      { \"instanceTest\", generateExtensionTypeTest( \"instance\" ) },\n                      { \"licenseHeader\", m_vulkanLicenseHeader },\n                      { \"obsoletedBy\", obsoletedBy },\n                      { \"obsoletedExtensions\", obsoletedExtensions },\n                      { \"obsoletedTest\", generateExtensionReplacedTest( []( ExtensionData const & extension ) { return !extension.obsoletedBy.empty(); } ) },\n                      { \"promotedExtensions\", promotedExtensions },\n                      { \"promotedTest\", generateExtensionReplacedTest( []( ExtensionData const & extension ) { return !extension.promotedTo.empty(); } ) },\n                      { \"promotedTo\", promotedTo },\n                      { \"voidExtension\", ( m_api == \"vulkan\" ) ? \"\" : \"(void)extension;\" } } );\n\n  writeToFile( str, vulkan_extension_inspection_hpp );\n}\n\nvoid VulkanHppGenerator::generateFormatTraitsHppFile() const\n{\n  std::string const vulkan_format_traits_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_format_traits.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_format_traits_hpp + \" ...\\n\" );\n\n  std::string const vulkanFormatTraitsHppTemplate = R\"(${licenseHeader}\n#ifndef VULKAN_FORMAT_TRAITS_HPP\n#  define VULKAN_FORMAT_TRAITS_HPP\n\n#include <vulkan/${api}.hpp>\n\nnamespace VULKAN_HPP_NAMESPACE\n{\n${formatTraits}\n}   // namespace VULKAN_HPP_NAMESPACE\n#endif\n)\";\n\n  std::string str = replaceWithMap( vulkanFormatTraitsHppTemplate,\n                                    { { \"api\", m_api }, { \"formatTraits\", generateFormatTraits() }, { \"licenseHeader\", m_vulkanLicenseHeader } } );\n\n  writeToFile( str, vulkan_format_traits_hpp );\n}\n\nvoid VulkanHppGenerator::generateFuncsHppFile() const\n{\n  std::string const vulkan_funcs_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_funcs.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_funcs_hpp + \" ...\\n\" );\n\n  std::string const vulkanFuncsHppTemplate = R\"(${licenseHeader}\n#ifndef VULKAN_FUNCS_HPP\n#  define VULKAN_FUNCS_HPP\n\n// include-what-you-use: make sure, vulkan.hpp is used by code-completers\n// IWYU pragma: private; include \"vulkan.hpp\"\n\nnamespace VULKAN_HPP_NAMESPACE\n{\n${commandDefinitions}\n}   // namespace VULKAN_HPP_NAMESPACE\n#endif\n)\";\n\n  std::string str =\n    replaceWithMap( vulkanFuncsHppTemplate, { { \"commandDefinitions\", generateCommandDefinitions() }, { \"licenseHeader\", m_vulkanLicenseHeader } } );\n\n  writeToFile( str, vulkan_funcs_hpp );\n}\n\nvoid VulkanHppGenerator::generateHandlesHppFile() const\n{\n  std::string const vulkan_handles_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_handles.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_handles_hpp + \" ...\\n\" );\n\n  std::string const vulkanHandlesHppTemplate = R\"(${licenseHeader}\n#ifndef VULKAN_HANDLES_HPP\n#  define VULKAN_HANDLES_HPP\n\n// include-what-you-use: make sure, vulkan.hpp is used by code-completers\n// IWYU pragma: private; include \"vulkan.hpp\"\n\nnamespace VULKAN_HPP_NAMESPACE\n{\n  ${structForwardDeclarations}\n  ${handleForwardDeclarations}\n  ${funcPointerReturns}\n  ${uniqueHandles}\n  ${handles}\n\n  // operators to compare vk::-handles\n#  if defined( VULKAN_HPP_HAS_SPACESHIP_OPERATOR )\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::isVulkanHandleType<T>::value, int>::type = 0>\n  auto operator<=>( T const & lhs, T const & rhs )\n  {\n    return static_cast<typename T::NativeType>( lhs ) <=> static_cast<typename T::NativeType>( rhs );\n  }\n#else\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::isVulkanHandleType<T>::value, int>::type = 0>\n  bool operator==( T const & lhs, T const & rhs )\n  {\n    return static_cast<typename T::NativeType>( lhs ) == static_cast<typename T::NativeType>( rhs );\n  }\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::isVulkanHandleType<T>::value, int>::type = 0>\n  bool operator!=( T const & lhs, T const & rhs )\n  {\n    return static_cast<typename T::NativeType>( lhs ) != static_cast<typename T::NativeType>( rhs );\n  }\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::isVulkanHandleType<T>::value, int>::type = 0>\n  bool operator<( T const & lhs, T const & rhs )\n  {\n    return static_cast<typename T::NativeType>( lhs ) < static_cast<typename T::NativeType>( rhs );\n  }\n#endif\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::isVulkanHandleType<T>::value, int>::type = 0>\n  bool operator==( T const & v, std::nullptr_t )\n  {\n    return !v;\n  }\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::isVulkanHandleType<T>::value, int>::type = 0>\n  bool operator==( std::nullptr_t, T const & v )\n  {\n    return !v;\n  }\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::isVulkanHandleType<T>::value, int>::type = 0>\n  bool operator!=( T const & v, std::nullptr_t )\n  {\n    return !!v;\n  }\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::isVulkanHandleType<T>::value, int>::type = 0>\n  bool operator!=( std::nullptr_t, T const & v )\n  {\n    return !!v;\n  }\n}   // namespace VULKAN_HPP_NAMESPACE\n#endif\n)\";\n\n  std::string str = replaceWithMap( vulkanHandlesHppTemplate,\n                                    {\n                                      { \"funcPointerReturns\", generateFuncPointerReturns() },\n                                      { \"handles\", generateHandles() },\n                                      { \"handleForwardDeclarations\", generateHandleForwardDeclarations() },\n                                      { \"licenseHeader\", m_vulkanLicenseHeader },\n                                      { \"structForwardDeclarations\", generateStructForwardDeclarations() },\n                                      { \"uniqueHandles\", generateUniqueHandles() },\n                                    } );\n\n  writeToFile( str, vulkan_handles_hpp );\n}\n\nvoid VulkanHppGenerator::generateHashHppFile() const\n{\n  std::string const vulkan_hash_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_hash.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_hash_hpp + \" ...\\n\" );\n\n  std::string const vulkanHandlesHppTemplate = R\"(${licenseHeader}\n#ifndef VULKAN_HASH_HPP\n#  define VULKAN_HASH_HPP\n\n#include <vulkan/${api}.hpp>\n\nnamespace std\n{\n  //=======================================\n  //=== HASH structures for Flags types ===\n  //=======================================\n\n  template <typename BitType>\n  struct hash<VULKAN_HPP_NAMESPACE::Flags<BitType>>\n  {\n    std::size_t operator()( VULKAN_HPP_NAMESPACE::Flags<BitType> const & flags ) const VULKAN_HPP_NOEXCEPT\n    {\n      return std::hash<typename std::underlying_type<BitType>::type>{}(\n        static_cast<typename std::underlying_type<BitType>::type>( flags ) );\n    }\n  };\n\n${handleHashStructures}\n${structHashStructures}\n} // namespace std\n#endif\n)\";\n\n  std::string str = replaceWithMap( vulkanHandlesHppTemplate,\n                                    { { \"api\", m_api },\n                                      { \"handleHashStructures\", generateHandleHashStructures() },\n                                      { \"licenseHeader\", m_vulkanLicenseHeader },\n                                      { \"structHashStructures\", generateStructHashStructures() } } );\n\n  writeToFile( str, vulkan_hash_hpp );\n}\n\nvoid VulkanHppGenerator::generateHppFile() const\n{\n  std::string const vulkan_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \".hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_hpp + \" ...\\n\" );\n\n  std::string const vulkanHppTemplate = R\"(${licenseHeader}\n#ifndef VULKAN_HPP\n#  define VULKAN_HPP\n\n${includes}\n\nstatic_assert( VK_HEADER_VERSION == ${headerVersion}, \"Wrong VK_HEADER_VERSION!\" );\n\n${defines}\n\nnamespace VULKAN_HPP_NAMESPACE\n{\n  ${ArrayWrapper1D}\n  ${ArrayWrapper2D}\n#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )\n  ${ArrayProxy}\n  ${ArrayProxyNoTemporaries}\n  ${StridedArrayProxy}\n  ${Optional}\n  ${StructureChain}\n  ${UniqueHandle}\n#endif  // VULKAN_HPP_DISABLE_ENHANCED_MODE\n\n  namespace detail\n  {\n    ${DispatchLoaderBase}\n    ${DispatchLoaderStatic}\n  }\n  ${Exchange}\n\n#if !defined( VULKAN_HPP_NO_SMART_HANDLE )\n  struct AllocationCallbacks;\n\n  namespace detail\n  {\n    ${ObjectDestroy}\n    ${ObjectFree}\n    ${ObjectRelease}\n    ${PoolFree}\n  }\n#endif // !VULKAN_HPP_NO_SMART_HANDLE\n\n  ${baseTypes}\n\n  template <typename Type, Type value = Type{}>\n  struct CppType\n  {};\n} // namespace VULKAN_HPP_NAMESPACE\n\n#include <vulkan/${api}_enums.hpp>\n#if !defined( VULKAN_HPP_NO_TO_STRING )\n#include <vulkan/${api}_to_string.hpp>\n#endif\n\n#ifndef VULKAN_HPP_NO_EXCEPTIONS\nnamespace std\n{\n  template <>\n  struct is_error_code_enum<VULKAN_HPP_NAMESPACE::Result> : public true_type\n  {};\n}  // namespace std\n#endif\n\nnamespace VULKAN_HPP_NAMESPACE\n{\n#ifndef VULKAN_HPP_NO_EXCEPTIONS\n${Exceptions}\n${resultExceptions}\n${throwResultException}\n#endif\n\n${ResultValue}\n${resultChecks}\n${constexprDefines}\n} // namespace VULKAN_HPP_NAMESPACE\n\n// clang-format off\n#include <vulkan/${api}_handles.hpp>\n#include <vulkan/${api}_structs.hpp>\n#include <vulkan/${api}_funcs.hpp>\n// clang-format on\n\n\nnamespace VULKAN_HPP_NAMESPACE\n{\n#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )\n  ${structExtendsStructs}\n#endif // VULKAN_HPP_DISABLE_ENHANCED_MODE\n\n  namespace detail\n  {\n    ${DynamicLoader}\n    ${DispatchLoaderDynamic}\n  }\n}   // namespace VULKAN_HPP_NAMESPACE\n#endif\n)\";\n\n  std::string str = replaceWithMap(\n    vulkanHppTemplate,\n    { { \"api\", m_api },\n      { \"ArrayProxy\", readSnippet( \"ArrayProxy.hpp\" ) },\n      { \"ArrayProxyNoTemporaries\", readSnippet( \"ArrayProxyNoTemporaries.hpp\" ) },\n      { \"ArrayWrapper1D\", readSnippet( \"ArrayWrapper1D.hpp\" ) },\n      { \"ArrayWrapper2D\", readSnippet( \"ArrayWrapper2D.hpp\" ) },\n      { \"baseTypes\", generateBaseTypes() },\n      { \"constexprDefines\", generateConstexprDefines() },\n      { \"defines\", readSnippet( \"defines.hpp\" ) },\n      { \"DispatchLoaderBase\", readSnippet( \"DispatchLoaderBase.hpp\" ) },\n      { \"DispatchLoaderDynamic\", generateDispatchLoaderDynamic() },\n      { \"DispatchLoaderStatic\", generateDispatchLoaderStatic() },\n      { \"DynamicLoader\", readSnippet( \"DynamicLoader.hpp\" ) },\n      { \"Exceptions\", readSnippet( \"Exceptions.hpp\" ) },\n      { \"Exchange\", readSnippet( \"Exchange.hpp\" ) },\n      { \"headerVersion\", m_version },\n      { \"includes\", replaceWithMap( readSnippet( \"includes.hpp\" ), { { \"vulkan_h\", ( m_api == \"vulkan\" ) ? \"vulkan.h\" : \"vulkan_sc_core.h\" } } ) },\n      { \"licenseHeader\", m_vulkanLicenseHeader },\n      { \"ObjectDestroy\", readSnippet( \"ObjectDestroy.hpp\" ) },\n      { \"ObjectFree\", readSnippet( \"ObjectFree.hpp\" ) },\n      { \"ObjectRelease\", readSnippet( \"ObjectRelease.hpp\" ) },\n      { \"Optional\", readSnippet( \"Optional.hpp\" ) },\n      { \"PoolFree\", readSnippet( \"PoolFree.hpp\" ) },\n      { \"resultChecks\", readSnippet( \"resultChecks.hpp\" ) },\n      { \"resultExceptions\", generateResultExceptions() },\n      { \"structExtendsStructs\", generateStructExtendsStructs() },\n      { \"ResultValue\", readSnippet( \"ResultValue.hpp\" ) },\n      { \"StridedArrayProxy\", readSnippet( \"StridedArrayProxy.hpp\" ) },\n      { \"StructureChain\", readSnippet( \"StructureChain.hpp\" ) },\n      { \"throwResultException\", generateThrowResultException() },\n      { \"UniqueHandle\", readSnippet( \"UniqueHandle.hpp\" ) } } );\n\n  writeToFile( str, vulkan_hpp );\n}\n\nvoid VulkanHppGenerator::generateMacrosFile() const\n{\n  std::string const macros_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_hpp_macros.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + macros_hpp + \" ...\\n\" );\n\n  std::string const macrosTemplate = R\"(${licenseHeader}\n\n#ifndef VULKAN_HPP_MACROS_HPP\n#define VULKAN_HPP_MACROS_HPP\n\n${macros}\n\n#endif)\";\n\n  std::string str =\n    replaceWithMap( macrosTemplate,\n                    { { \"licenseHeader\", m_vulkanLicenseHeader },\n                      { \"macros\",\n                        replaceWithMap( readSnippet( \"macros.hpp\" ),\n                                        { { \"vulkan_hpp\", m_api + \".hpp\" },\n                                          { \"vulkan_64_bit_ptr_defines\", m_defines.at( \"VK_USE_64_BIT_PTR_DEFINES\" ).possibleDefinition } } ) } } );\n\n  writeToFile( str, macros_hpp );\n}\n\nvoid VulkanHppGenerator::generateRAIIHppFile() const\n{\n  std::string const vulkan_raii_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_raii.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_raii_hpp + \" ...\\n\" );\n\n  std::string const vulkanHandlesHppTemplate = R\"(${licenseHeader}\n#ifndef VULKAN_RAII_HPP\n#define VULKAN_RAII_HPP\n\n#include <vulkan/${api}.hpp>\n#if !( defined( VULKAN_HPP_ENABLE_STD_MODULE ) && defined( VULKAN_HPP_STD_MODULE ) )\n#  include <memory>   // std::unique_ptr\n#  include <utility>  // std::forward\n#endif\n\n#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )\nnamespace VULKAN_HPP_NAMESPACE\n{\n  namespace VULKAN_HPP_RAII_NAMESPACE\n  {\n    namespace detail\n    {\n      template <class T>\n      class CreateReturnType\n      {\n        public:\n#if defined( VULKAN_HPP_RAII_NO_EXCEPTIONS )\n          using Type = VULKAN_HPP_EXPECTED<T, VULKAN_HPP_NAMESPACE::Result>;\n#else\n          using Type = T;\n#endif\n      };\n\n      using PFN_dummy = void ( * )();\n\n      ${RAIIDispatchers}\n    }\n\n    ${RAIIHandles}\n    ${RAIICommandDefinitions}\n\n    //====================\n    //=== RAII Helpers ===\n    //====================\n\n    template <typename RAIIType>\n    std::vector<typename RAIIType::CppType> filterCppTypes( std::vector<RAIIType> const & raiiTypes )\n    {\n      std::vector<typename RAIIType::CppType> cppTypes( raiiTypes.size() );\n      std::transform( raiiTypes.begin(), raiiTypes.end(), cppTypes.begin(), []( RAIIType const & d ) { return *d; } );\n      return cppTypes;\n    }\n\n    template <typename RAIIType, class UnaryPredicate>\n    std::vector<typename RAIIType::CppType> filterCppTypes( std::vector<RAIIType> const & raiiTypes, UnaryPredicate p)\n    {\n      std::vector<typename RAIIType::CppType> cppTypes;\n      for (auto const& t : raiiTypes)\n      {\n        if (p(t))\n        {\n          cppTypes.push_back( *t );\n        }\n      }\n      return cppTypes;\n    }\n\n  } // namespace VULKAN_HPP_RAII_NAMESPACE\n}   // namespace VULKAN_HPP_NAMESPACE\n#endif\n#endif\n)\";\n\n  std::string str = replaceWithMap( vulkanHandlesHppTemplate,\n                                    { { \"api\", m_api },\n                                      { \"licenseHeader\", m_vulkanLicenseHeader },\n                                      { \"RAIICommandDefinitions\", generateRAIICommandDefinitions() },\n                                      { \"RAIIDispatchers\", generateRAIIDispatchers() },\n                                      { \"RAIIHandles\", generateRAIIHandles() } } );\n\n  writeToFile( str, vulkan_raii_hpp );\n}\n\nvoid VulkanHppGenerator::generateSharedHppFile() const\n{\n  std::string const vulkan_shared_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_shared.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_shared_hpp + \" ...\\n\" );\n\n  std::string const vulkanHandlesHppTemplate = R\"(${licenseHeader}\n#ifndef VULKAN_SHARED_HPP\n#define VULKAN_SHARED_HPP\n\n#include <vulkan/${api}.hpp>\n\n#if !( defined( VULKAN_HPP_ENABLE_STD_MODULE ) && defined( VULKAN_HPP_STD_MODULE ) )\n#include <atomic>  // std::atomic_size_t\n#endif\n\nnamespace VULKAN_HPP_NAMESPACE\n{\n#if !defined( VULKAN_HPP_NO_SMART_HANDLE )\n  ${sharedHandle}\n  namespace detail\n  {\n    ${sharedDestroy}\n  }\n  ${sharedHandles}\n  ${sharedHandleSpecializations}\n  ${sharedHandlesNoDestroy}\n#endif // !VULKAN_HPP_NO_SMART_HANDLE\n} // namespace VULKAN_HPP_NAMESPACE\n#endif // VULKAN_SHARED_HPP\n)\";\n\n  std::string str = replaceWithMap( vulkanHandlesHppTemplate,\n                                    {\n                                      { \"api\", m_api },\n                                      { \"licenseHeader\", m_vulkanLicenseHeader },\n                                      { \"sharedDestroy\", readSnippet( \"SharedDestroy.hpp\" ) },\n                                      { \"sharedHandle\", readSnippet( \"SharedHandle.hpp\" ) },\n                                      { \"sharedHandles\", generateSharedHandles() },\n                                      { \"sharedHandlesNoDestroy\", generateSharedHandlesNoDestroy() },\n                                      { \"sharedHandleSpecializations\", readSnippet( \"SharedHandleSpecializations.hpp\" ) },\n                                    } );\n\n  writeToFile( str, vulkan_shared_hpp );\n}\n\nvoid VulkanHppGenerator::generateStaticAssertionsHppFile() const\n{\n  std::string const static_assertions_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_static_assertions.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + static_assertions_hpp + \" ...\\n\" );\n\n  std::string const vulkanHandlesHppTemplate = R\"(${licenseHeader}\n#ifndef VULKAN_STATIC_ASSERTIONS_HPP\n#  define VULKAN_STATIC_ASSERTIONS_HPP\n\n#include <vulkan/${api}.hpp>\n\n//=========================\n//=== static_assertions ===\n//=========================\n\n${staticAssertions}\n#endif\n)\";\n\n  std::string str = replaceWithMap( vulkanHandlesHppTemplate,\n                                    { { \"api\", m_api }, { \"licenseHeader\", m_vulkanLicenseHeader }, { \"staticAssertions\", generateStaticAssertions() } } );\n\n  writeToFile( str, static_assertions_hpp );\n}\n\nvoid VulkanHppGenerator::generateStructsHppFile() const\n{\n  std::string const vulkan_structs_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_structs.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_structs_hpp + \" ...\\n\" );\n\n  std::string const vulkanHandlesHppTemplate = R\"(${licenseHeader}\n#ifndef VULKAN_STRUCTS_HPP\n#  define VULKAN_STRUCTS_HPP\n\n// include-what-you-use: make sure, vulkan.hpp is used by code-completers\n// IWYU pragma: private; include \"vulkan.hpp\"\n\n#include <cstring>  // strcmp\n\nnamespace VULKAN_HPP_NAMESPACE\n{\n${structs}\n}   // namespace VULKAN_HPP_NAMESPACE\n#endif\n)\";\n\n  std::string str = replaceWithMap( vulkanHandlesHppTemplate, { { \"licenseHeader\", m_vulkanLicenseHeader }, { \"structs\", generateStructs() } } );\n\n  writeToFile( str, vulkan_structs_hpp );\n}\n\nvoid VulkanHppGenerator::generateToStringHppFile() const\n{\n  std::string const vulkan_to_string_hpp = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \"_to_string.hpp\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_to_string_hpp + \" ...\\n\" );\n\n  std::string const vulkanHandlesHppTemplate = R\"(${licenseHeader}\n#ifndef VULKAN_TO_STRING_HPP\n#  define VULKAN_TO_STRING_HPP\n\n#include <vulkan/${api}.hpp>\n\n// ignore warnings on using deprecated enum values in this header\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#elif defined( _MSC_VER )\n#  pragma warning( push )\n#  pragma warning( disable : 4996 )\n#endif\n\n#if defined( VULKAN_HPP_ENABLE_STD_MODULE ) && defined( VULKAN_HPP_STD_MODULE )\nimport VULKAN_HPP_STD_MODULE;\n#else\n#  if __cpp_lib_format\n#    include <format>   // std::format\n#  else\n#    include <sstream>  // std::stringstream\n#  endif\n#endif\n\nnamespace VULKAN_HPP_NAMESPACE\n{\n${bitmasksToString}\n${enumsToString}\n} // namespace VULKAN_HPP_NAMESPACE\n\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic pop\n#elif defined( _MSC_VER )\n#  pragma warning( pop )\n#endif\n\n#endif\n)\";\n\n  std::string str = replaceWithMap( vulkanHandlesHppTemplate,\n                                    { { \"api\", m_api },\n                                      { \"bitmasksToString\", generateBitmasksToString() },\n                                      { \"enumsToString\", generateEnumsToString() },\n                                      { \"licenseHeader\", m_vulkanLicenseHeader } } );\n\n  writeToFile( str, vulkan_to_string_hpp );\n}\n\nvoid VulkanHppGenerator::generateCppModuleFile() const\n{\n  std::string const vulkan_cppm = std::string( BASE_PATH ) + \"/vulkan/\" + m_api + \".cppm\";\n  messager.message( \"VulkanHppGenerator: Generating \" + vulkan_cppm + \" ...\\n\" );\n\n  std::string const vulkanCppmTemplate = R\"(${licenseHeader}\n\n// Note: This module is still in an experimental state.\n// Any feedback is welcome on https://github.com/KhronosGroup/Vulkan-Hpp/issues.\n\nmodule;\n\n#include <vulkan/vulkan_hpp_macros.hpp>\n\n#if defined( __cpp_lib_modules ) && !defined( VULKAN_HPP_ENABLE_STD_MODULE )\n#define VULKAN_HPP_ENABLE_STD_MODULE\n#endif\n\n#include <vulkan/${api}.hpp>\n#include <vulkan/${api}_extension_inspection.hpp>\n#include <vulkan/${api}_format_traits.hpp>\n#include <vulkan/${api}_hash.hpp>\n#include <vulkan/${api}_raii.hpp>\n#include <vulkan/${api}_shared.hpp>\n#include <vulkan/${api}_to_string.hpp>\n\nexport module ${api}_hpp;\n\nexport namespace VULKAN_HPP_NAMESPACE\n{\n  ${usings}\n\n#if !defined( VULKAN_HPP_DISABLE_ENHANCED_MODE )\n  namespace VULKAN_HPP_RAII_NAMESPACE\n  {\n    ${raiiUsings}\n  } // namespace VULKAN_HPP_RAII_NAMESPACE\n#endif\n} // namespace VULKAN_HPP_NAMESPACE\n\nexport namespace std\n{\n  ${hashSpecializations}\n}\n\n// This VkFlags type is used as part of a bitfield in some structure.\n// As it that can't be mimiced by vk-data types, we need to export just that!!\nexport VkGeometryInstanceFlagsKHR;\n)\";\n\n  auto const str = replaceWithMap( vulkanCppmTemplate,\n                                   { { \"api\", m_api },\n                                     { \"hashSpecializations\", generateCppModuleHashSpecializations() },\n                                     { \"licenseHeader\", m_vulkanLicenseHeader },\n                                     { \"raiiUsings\", generateCppModuleRaiiUsings() },\n                                     { \"usings\", generateCppModuleUsings() } } );\n\n  writeToFile( str, vulkan_cppm );\n}\n\nvoid VulkanHppGenerator::prepareRAIIHandles()\n{\n  // filter out functions that are not usefull on this level of abstraction (like vkGetInstanceProcAddr)\n  // and all the destruction functions, as they are used differently\n  assert( m_handles.begin()->first.empty() );\n  for ( auto handleIt = std::next( m_handles.begin() ); handleIt != m_handles.end(); ++handleIt )\n  {\n    handleIt->second.destructorIt = determineRAIIHandleDestructor( handleIt->first );\n    if ( handleIt->second.destructorIt != m_commands.end() )\n    {\n      m_RAIISpecialFunctions.insert( handleIt->second.destructorIt->first );\n    }\n    handleIt->second.constructorIts = determineRAIIHandleConstructors( handleIt->first, handleIt->second.destructorIt );\n  }\n}\n\n//\n// VulkanHppGenerator private interface\n//\n\nvoid VulkanHppGenerator::addCommand( std::string const & name, CommandData & commandData )\n{\n  // find the handle this command is going to be associated to\n  checkForError( !commandData.params.empty(), commandData.xmlLine, \"command <\" + name + \"> with no params\" );\n  auto handleIt = m_handles.find( commandData.params[0].type.type );\n  if ( handleIt == m_handles.end() )\n  {\n    handleIt = m_handles.begin();\n    assert( handleIt->first == \"\" );\n  }\n  commandData.handle = handleIt->first;\n\n  // add this command to the list of commands\n  checkForError( m_commands.insert( std::make_pair( name, commandData ) ).second, commandData.xmlLine, \"already encountered command <\" + name + \">\" );\n}\n\nvoid VulkanHppGenerator::addCommandsToHandle( std::vector<RequireData> const & requireData )\n{\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & command : require.commands )\n    {\n      auto commandIt = findByNameOrAlias( m_commands, command.name );\n      assert( commandIt != m_commands.end() );\n      auto handleIt = m_handles.find( commandIt->second.handle );\n      assert( handleIt != m_handles.end() );\n      if ( !handleIt->second.commands.contains( command.name ) )\n      {\n        handleIt->second.commands.insert( command.name );\n        registerDeleter( command.name, commandIt->second );\n      }\n    }\n  }\n}\n\nvoid VulkanHppGenerator::addMissingFlagBits( std::vector<RequireData> & requireData, std::string const & requiredBy )\n{\n  for ( auto & require : requireData )\n  {\n    std::vector<NameLine> newTypes;\n    for ( auto const & type : require.types )\n    {\n      auto bitmaskIt = m_bitmasks.find( type.name );\n      if ( bitmaskIt != m_bitmasks.end() )\n      {\n        if ( bitmaskIt->second.require.empty() )\n        {\n          // generate the flagBits enum name out of the bitmask name: VkFooFlagsXXX -> VkFooFlagBitsXXX\n          const size_t pos = bitmaskIt->first.find( \"Flags\" );\n          assert( pos != std::string::npos );\n          std::string flagBits = bitmaskIt->first.substr( 0, pos + 4 ) + \"Bit\" + bitmaskIt->first.substr( pos + 4 );\n\n          bitmaskIt->second.require = flagBits;\n\n          // some flagsBits are specified but never listed as required for any flags!\n          // so, even if this bitmask has no enum listed as required, it might still already exist in the enums list\n          auto enumIt = m_enums.find( flagBits );\n          if ( enumIt == m_enums.end() )\n          {\n            m_enums.insert( std::make_pair( flagBits, EnumData{ .isBitmask = true, .xmlLine = 0 } ) );\n\n            assert( !m_types.contains( flagBits ) );\n            m_types.insert( std::make_pair( flagBits, TypeData{ TypeCategory::Bitmask, { requiredBy }, 0 } ) );\n          }\n          else\n          {\n            assert( m_types.contains( flagBits ) );\n            enumIt->second.isBitmask = true;\n          }\n        }\n        if ( std::none_of(\n               require.types.begin(), require.types.end(), [bitmaskIt]( auto const & requireType ) { return requireType.name == bitmaskIt->second.require; } ) )\n        {\n          // this bitmask requires a flags type that is not listed in here, so add it\n          newTypes.push_back( { bitmaskIt->second.require, bitmaskIt->second.xmlLine } );\n        }\n      }\n    }\n    // add all the newly created flagBits types to the require list as if they had been part of the vk.xml!\n    require.types.insert( require.types.end(), newTypes.begin(), newTypes.end() );\n  }\n}\n\nstd::string VulkanHppGenerator::addTitleAndProtection( std::string const & title, std::string const & strIf, std::string const & strElse ) const\n{\n  std::string str;\n  if ( !strIf.empty() )\n  {\n    const auto [enter, leave] = generateProtection( getProtectFromTitle( title ) );\n    str                       = \"\\n\" + enter + \"  //=== \" + title + \" ===\\n\" + strIf;\n    if ( !enter.empty() && !strElse.empty() )\n    {\n      str += \"#else \\n\" + strElse;\n    }\n    str += leave;\n  }\n  return str;\n}\n\nbool VulkanHppGenerator::allVectorSizesSupported( std::vector<ParamData> const & params, std::map<size_t, VectorParamData> const & vectorParams ) const\n{\n  // check if all vector sizes are by value and their type is one of \"uint32_t\", \"VkDeviceSize\", or \"VkSampleCountFlagBits\"\n  return std::all_of( vectorParams.begin(),\n                      vectorParams.end(),\n                      [&params]( auto const & vpi )\n                      {\n                        return params[vpi.second.lenParam].type.isValue() &&\n                               ( ( params[vpi.second.lenParam].type.type == \"uint32_t\" ) || ( params[vpi.second.lenParam].type.type == \"VkDeviceSize\" ) ||\n                                 ( params[vpi.second.lenParam].type.type == \"VkSampleCountFlagBits\" ) );\n                      } );\n}\n\nvoid VulkanHppGenerator::appendDispatchLoaderDynamicCommands( std::vector<RequireData> const & requireData,\n                                                              std::set<std::string> &          listedCommands,\n                                                              std::string const &              title,\n                                                              std::string &                    commandMembers,\n                                                              std::string &                    initialCommandAssignments,\n                                                              std::string &                    instanceCommandAssignments,\n                                                              std::string &                    deviceCommandAssignments ) const\n{\n  std::string members, initial, instance, device, placeholders;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & command : require.commands )\n    {\n      if ( listedCommands.insert( command.name ).second )\n      {\n        auto commandIt = findByNameOrAlias( m_commands, command.name );\n        assert( commandIt != m_commands.end() );\n\n        members += \"    PFN_\" + command.name + \" \" + command.name + \" = 0;\\n\";\n        placeholders += \"    PFN_dummy \" + command.name + \"_placeholder = 0;\\n\";\n        if ( commandIt->second.handle.empty() )\n        {\n          initial += generateDispatchLoaderDynamicCommandAssignment( command.name, commandIt->first, \"NULL\" );\n        }\n        else\n        {\n          instance += generateDispatchLoaderDynamicCommandAssignment( command.name, commandIt->first, \"instance\" );\n          if ( isDeviceCommand( commandIt->second ) )\n          {\n            device += generateDispatchLoaderDynamicCommandAssignment( command.name, commandIt->first, \"device\" );\n          }\n        }\n      }\n    }\n  }\n  const auto [enter, leave] = generateProtection( getProtectFromTitle( title ) );\n  std::string header        = \"\\n\" + enter + \"  //=== \" + title + \" ===\\n\";\n  if ( !members.empty() )\n  {\n    commandMembers += header + members;\n    if ( !enter.empty() )\n    {\n      commandMembers += \"#else\\n\" + placeholders;\n    }\n    commandMembers += leave;\n  }\n  if ( !initial.empty() )\n  {\n    initialCommandAssignments += header + initial + leave;\n  }\n  if ( !instance.empty() )\n  {\n    instanceCommandAssignments += header + instance + leave;\n  }\n  if ( !device.empty() )\n  {\n    deviceCommandAssignments += header + device + leave;\n  }\n}\n\nvoid VulkanHppGenerator::appendRAIIDispatcherCommands( std::vector<RequireData> const & requireData,\n                                                       std::set<std::string> &          listedCommands,\n                                                       std::string const &              title,\n                                                       std::string &                    contextInitializers,\n                                                       std::string &                    contextMembers,\n                                                       std::string &                    deviceAssignments,\n                                                       std::string &                    deviceMembers,\n                                                       std::string &                    instanceAssignments,\n                                                       std::string &                    instanceMembers ) const\n{\n  std::string ci, cm, da, dm, dmp, ia, im, imp;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & command : require.commands )\n    {\n      if ( listedCommands.insert( command.name ).second )\n      {\n        auto commandIt = findByNameOrAlias( m_commands, command.name );\n        if ( commandIt->second.handle.empty() )\n        {\n          ci += \", \" + command.name + \"( PFN_\" + command.name + \"( getProcAddr( NULL, \\\"\" + command.name + \"\\\" ) ) )\";\n\n          cm += \"      PFN_\" + command.name + \" \" + command.name + \" = 0;\\n\";\n        }\n        else if ( ( commandIt->second.handle == \"VkDevice\" ) || hasParentHandle( commandIt->second.handle, \"VkDevice\" ) )\n        {\n          da += \"        \" + command.name + \" = PFN_\" + command.name + \"( vkGetDeviceProcAddr( device, \\\"\" + command.name + \"\\\" ) );\\n\";\n          // if this is an alias'ed function, use it as a fallback for the original one\n          if ( command.name != commandIt->first )\n          {\n            da += \"        if ( !\" + commandIt->first + \" ) \" + commandIt->first + \" = \" + command.name + \";\\n\";\n          }\n\n          dm += \"      PFN_\" + command.name + \" \" + command.name + \" = 0;\\n\";\n          dmp += \"      PFN_dummy \" + command.name + \"_placeholder = 0;\\n\";\n        }\n        else\n        {\n          assert( ( commandIt->second.handle == \"VkInstance\" ) || hasParentHandle( commandIt->second.handle, \"VkInstance\" ) );\n\n          // filter out vkGetInstanceProcAddr, as starting with Vulkan 1.2 it can resolve itself only (!) with an\n          // instance nullptr !\n          if ( command.name != \"vkGetInstanceProcAddr\" )\n          {\n            ia += \"        \" + command.name + \" = PFN_\" + command.name + \"( vkGetInstanceProcAddr( instance, \\\"\" + command.name + \"\\\" ) );\\n\";\n            // if this is an alias'ed function, use it as a fallback for the original one\n            if ( command.name != commandIt->first )\n            {\n              ia += \"        if ( !\" + commandIt->first + \" ) \" + commandIt->first + \" = \" + command.name + \";\\n\";\n            }\n          }\n\n          im += +\"      PFN_\" + command.name + \" \" + command.name + \" = 0;\\n\";\n          imp += \"      PFN_dummy \" + command.name + \"_placeholder = 0;\\n\";\n        }\n      }\n    }\n  }\n  contextInitializers += addTitleAndProtection( title, ci );\n  contextMembers += addTitleAndProtection( title, cm );\n  deviceAssignments += addTitleAndProtection( title, da );\n  deviceMembers += addTitleAndProtection( title, dm, dmp );\n  instanceAssignments += addTitleAndProtection( title, ia );\n  instanceMembers += addTitleAndProtection( title, im, imp );\n}\n\nvoid VulkanHppGenerator::checkBitmaskCorrectness() const\n{\n  for ( auto const & bitmask : m_bitmasks )\n  {\n    // check that a bitmask is required somewhere\n    // I think, it's not forbidden to not reference a bitmask, but it would probably be not intended?\n    auto typeIt = m_types.find( bitmask.first );\n    assert( typeIt != m_types.end() );\n    checkForError( !typeIt->second.requiredBy.empty(), bitmask.second.xmlLine, \"bitmask <\" + bitmask.first + \"> not required in any feature or extension\" );\n\n    // check that the requirement is an enum\n    if ( !bitmask.second.require.empty() )\n    {\n      checkForError( m_enums.contains( bitmask.second.require ),\n                     bitmask.second.xmlLine,\n                     \"bitmask <\" + bitmask.first + \"> requires unknown enum <\" + bitmask.second.require + \">\" );\n    }\n  }\n}\n\nvoid VulkanHppGenerator::checkCommandCorrectness() const\n{\n  // prepare command checks by gathering all result codes (including aliases and not supported ones!) into one set of resultCodes\n  auto resultIt = m_enums.find( \"VkResult\" );\n  assert( resultIt != m_enums.end() );\n  std::set<std::string> resultCodes;\n  for ( auto rc : resultIt->second.values )\n  {\n    resultCodes.insert( rc.name );\n    for ( auto ac : rc.aliases )\n    {\n      resultCodes.insert( ac.name );\n    }\n  }\n  // some special handling needed for vulkansc!!\n  if ( m_api == \"vulkansc\" )\n  {\n    resultCodes.insert( { \"VK_ERROR_FRAGMENTATION_EXT\",\n                          \"VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR\",\n                          \"VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR\",\n                          \"VK_ERROR_NOT_PERMITTED_EXT\",\n                          \"VK_PIPELINE_COMPILE_REQUIRED_EXT\" } );\n  }\n\n  // command checks\n  for ( auto const & command : m_commands )\n  {\n    // check that a command is referenced somewhere\n    // I think, it's not forbidden to not reference a function, but it would probably be not intended?\n    checkForError( !command.second.requiredBy.empty(), command.second.xmlLine, \"command <\" + command.first + \"> not required in any feature or extension\" );\n\n    // check for unknown error or succes codes\n    for ( auto const & ec : command.second.errorCodes )\n    {\n      checkForError( resultCodes.contains( ec ), command.second.xmlLine, \"command uses unknown error code <\" + ec + \">\" );\n    }\n    for ( auto const & sc : command.second.successCodes )\n    {\n      checkForError( resultCodes.contains( sc ), command.second.xmlLine, \"command uses unknown success code <\" + sc + \">\" );\n    }\n\n    // check that functions returning a VkResult specify successcodes\n    if ( ( command.second.returnType == \"VkResult\" ) && command.second.successCodes.empty() )\n    {\n      // emit an error if this function is required in at least one supported feature or extension\n      // disabled or not supported features/extensions are still listed in requiredBy, but not in m_features/m_extensions\n      bool functionUsed = false;\n      for ( auto const & require : command.second.requiredBy )\n      {\n        functionUsed |= isSupportedFeature( require ) || isSupportedExtension( require );\n      }\n      if ( functionUsed )\n      {\n        checkForError( false, command.second.xmlLine, \"missing successcodes on command <\" + command.first + \"> returning VkResult!\" );\n      }\n    }\n\n    // check that all parameter types as well as the return type are known types\n    for ( auto const & p : command.second.params )\n    {\n      checkForError( m_types.contains( p.type.type ), p.xmlLine, \"comand uses parameter of unknown type <\" + p.type.type + \">\" );\n    }\n    checkForError(\n      m_types.contains( command.second.returnType ), command.second.xmlLine, \"command uses unknown return type <\" + command.second.returnType + \">\" );\n  }\n}\n\nvoid VulkanHppGenerator::checkCorrectness() const\n{\n  checkForError( !m_vulkanLicenseHeader.empty(), -1, \"missing license header\" );\n  checkBitmaskCorrectness();\n  checkCommandCorrectness();\n  checkDefineCorrectness();\n  checkEnumCorrectness();\n  checkExtensionCorrectness();\n  checkFeatureCorrectness();\n  checkFuncPointerCorrectness();\n  checkHandleCorrectness();\n  checkSpirVCapabilityCorrectness();\n  checkStructCorrectness();\n  checkSyncAccessCorrectness();\n  checkSyncStageCorrectness();\n}\n\nvoid VulkanHppGenerator::checkDefineCorrectness() const\n{\n  // check that any requirements of a define is known\n  for ( auto const & d : m_defines )\n  {\n    checkForError( d.second.require.empty() || m_types.contains( d.second.require ),\n                   d.second.xmlLine,\n                   \"define <\" + d.first + \"> uses unknown require <\" + d.second.require + \">\" );\n  }\n}\n\nvoid VulkanHppGenerator::checkEnumCorrectness() const\n{\n  for ( auto const & e : m_enums )\n  {\n    // check that a bitmask is required somewhere\n    // some bitmasks are never required, so make this a warning only\n    auto typeIt = m_types.find( e.first );\n    assert( typeIt != m_types.end() );\n    checkForWarning( !typeIt->second.requiredBy.empty(), e.second.xmlLine, \"enum <\" + e.first + \"> not required in any feature or extension\" );\n  }\n\n  // enum checks by features and extensions\n  for ( auto & feature : m_features )\n  {\n    checkEnumCorrectness( feature.requireData );\n  }\n  for ( auto & ext : m_extensions )\n  {\n    checkEnumCorrectness( ext.requireData );\n  }\n\n  // special check for VkFormat\n  if ( !m_formats.empty() )\n  {\n    auto enumIt = m_enums.find( \"VkFormat\" );\n    assert( enumIt != m_enums.end() );\n    assert( enumIt->second.values.front().name == \"VK_FORMAT_UNDEFINED\" );\n    for ( auto enumValueIt = std::next( enumIt->second.values.begin() ); enumValueIt != enumIt->second.values.end(); ++enumValueIt )\n    {\n      checkForError( !enumValueIt->supported || m_formats.contains( enumValueIt->name ),\n                     enumValueIt->xmlLine,\n                     \"missing format specification for <\" + enumValueIt->name + \">\" );\n    }\n  }\n}\n\nvoid VulkanHppGenerator::checkEnumCorrectness( std::vector<RequireData> const & requireData ) const\n{\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & type : require.types )\n    {\n      auto typeIt = m_types.find( type.name );\n      assert( typeIt != m_types.end() );\n      switch ( typeIt->second.category )\n      {\n        case TypeCategory::Bitmask:\n          {\n            // check that each \"require\" listed for a bitmask is listed for a feature or an extension\n            auto bitmaskIt = m_bitmasks.find( type.name );\n            if ( bitmaskIt != m_bitmasks.end() )\n            {\n              // not for every bitmask is a \"require\" listed\n              if ( !bitmaskIt->second.require.empty() )\n              {\n                auto requireTypeIt = m_types.find( bitmaskIt->second.require );\n                assert( requireTypeIt != m_types.end() );\n                checkForError( !requireTypeIt->second.requiredBy.empty(),\n                               bitmaskIt->second.xmlLine,\n                               \"bitmask <\" + bitmaskIt->first + \"> requires <\" + bitmaskIt->second.require +\n                                 \"> which is not required by any feature or extension!\" );\n              }\n            }\n          }\n          break;\n        case TypeCategory::Enum:\n          {\n            auto enumIt = m_enums.find( type.name );\n            if ( enumIt != m_enums.end() )\n            {\n              if ( enumIt->second.isBitmask && !enumIt->second.values.empty() )\n              {\n                // check that any non-empty enum of a bitmask is listed as \"require\" or \"bitvalues\" for a bitmask\n                auto bitmaskIt =\n                  std::find_if( m_bitmasks.begin(), m_bitmasks.end(), [&enumIt]( auto const & bitmask ) { return bitmask.second.require == enumIt->first; } );\n                checkForError( bitmaskIt != m_bitmasks.end(),\n                               enumIt->second.xmlLine,\n                               \"enum <\" + enumIt->first + \"> is not listed as an requires or bitvalues for any bitmask in the types section\" );\n\n                // check that bitwidth of the enum and type of the corresponding bitmask are equal\n                checkForError( ( enumIt->second.bitwidth != \"64\" ) || ( bitmaskIt->second.type == \"VkFlags64\" ),\n                               enumIt->second.xmlLine,\n                               \"enum <\" + enumIt->first + \"> is marked with bitwidth <64> but corresponding bitmask <\" + bitmaskIt->first +\n                                 \"> is not of type <VkFlags64>\" );\n              }\n            }\n            else\n            {\n              // every enum not listed in the m_enums, should be an alias of such a thing\n              checkForError(\n                findByNameOrAlias( m_enums, type.name ) != m_enums.end(), typeIt->second.xmlLine, \"enum type <\" + type.name + \"> is not listed as an enum\" );\n            }\n          }\n          break;\n        default: break;\n      }\n    }\n  }\n}\n\nbool VulkanHppGenerator::checkEquivalentSingularConstructor( std::vector<std::map<std::string, CommandData>::const_iterator> const & constructorIts,\n                                                             std::map<std::string, CommandData>::const_iterator                      constructorIt,\n                                                             std::vector<ParamData>::const_iterator                                  lenIt ) const\n{\n  // check, if there is no singular constructor with the very same arguments as this array constructor\n  // (besides the size, of course)\n  auto isEquivalentSingularConstructor = [constructorIt, lenIt]( std::map<std::string, CommandData>::const_iterator it )\n  {\n    if ( it->second.params.size() + 1 != constructorIt->second.params.size() )\n    {\n      return false;\n    }\n    const size_t lenIdx = std::distance( constructorIt->second.params.begin(), lenIt );\n    for ( size_t i = 0, j = 0; i < it->second.params.size(); ++i, ++j )\n    {\n      assert( j < constructorIt->second.params.size() );\n      if ( j == lenIdx )\n      {\n        ++j;\n      }\n      if ( it->second.params[i].type.type != constructorIt->second.params[j].type.type )\n      {\n        return false;\n      }\n    }\n    return true;\n  };\n  return ( std::any_of( constructorIts.begin(), constructorIts.end(), isEquivalentSingularConstructor ) );\n}\n\nvoid VulkanHppGenerator::checkExtensionCorrectness() const\n{\n  for ( auto const & extension : m_extensions )\n  {\n    // check for existence of any depends, deprecation, obsoletion, or promotion\n    for ( auto const & dependsByVersion : extension.depends )\n    {\n      checkForError( isFeature( dependsByVersion.first ),\n                     extension.xmlLine,\n                     \"extension <\" + extension.name + \"> lists an unknown feature <\" + dependsByVersion.first + \">\" );\n      for ( auto const & dependsSet : dependsByVersion.second )\n      {\n        for ( auto const & depends : dependsSet )\n        {\n          checkForError( isExtension( depends ), extension.xmlLine, \"extension <\" + extension.name + \"> lists an unknown depends <\" + depends + \">\" );\n        }\n      }\n    }\n    if ( !extension.deprecatedBy.empty() )\n    {\n      checkForError( isFeature( extension.deprecatedBy ) || isExtension( extension.deprecatedBy ),\n                     extension.xmlLine,\n                     \"extension <\" + extension.name + \"> is deprecated by unknown extension/version <\" + extension.deprecatedBy + \">\" );\n    }\n    if ( !extension.obsoletedBy.empty() )\n    {\n      checkForError( isFeature( extension.obsoletedBy ) || isExtension( extension.obsoletedBy ),\n                     extension.xmlLine,\n                     \"extension <\" + extension.name + \"> is obsoleted by unknown extension/version <\" + extension.obsoletedBy + \">\" );\n    }\n    if ( !extension.promotedTo.empty() )\n    {\n      checkForError( isFeature( extension.promotedTo ) || isExtension( extension.promotedTo ),\n                     extension.xmlLine,\n                     \"extension <\" + extension.name + \"> is promoted to unknown extension/version <\" + extension.promotedTo + \">\" );\n    }\n\n    // check for existence of any requirement\n    for ( auto const & require : extension.requireData )\n    {\n      if ( !require.depends.empty() )\n      {\n        std::vector<std::string> depends = tokenizeAny( require.depends, \",+()\" );\n        for ( auto const & depend : depends )\n        {\n          checkForError(\n            isFeature( depend ) || isExtension( depend ), require.xmlLine, \"extension <\" + extension.name + \"> lists an unknown depends <\" + depend + \">\" );\n        }\n      }\n    }\n  }\n}\n\nvoid VulkanHppGenerator::checkFeatureCorrectness() const\n{\n  // check that each require depends actually is an extension\n  // remove this check temporarily !\n  // for ( auto const & feature : m_features )\n  //{\n  //  for ( auto const & require : feature.requireData )\n  //  {\n  //    checkForError(\n  //      require.depends.empty() ||\n  //        std::any_of( m_extensions.begin(), m_extensions.end(), [&depends = require.depends]( ExtensionData const & ed ) { return ed.name == depends; } ),\n  //      require.xmlLine,\n  //      \"feature <\" + feature.name + \"> depends on an unknown extension <\" + require.depends + \">\" );\n  //  }\n  //}\n}\n\nvoid VulkanHppGenerator::checkFuncPointerCorrectness() const\n{\n  for ( auto const & funcPointer : m_funcPointers )\n  {\n    if ( !funcPointer.second.require.empty() )\n    {\n      checkForError(\n        m_types.contains( funcPointer.second.require ), funcPointer.second.xmlLine, \"funcpointer requires unknown <\" + funcPointer.second.require + \">\" );\n    }\n    for ( auto const & argument : funcPointer.second.arguments )\n    {\n      checkForError( m_types.contains( argument.type.type ), argument.xmlLine, \"funcpointer argument of unknown type <\" + argument.type.type + \">\" );\n    }\n  }\n}\n\nvoid VulkanHppGenerator::checkHandleCorrectness() const\n{\n  // prepare handle checks by getting the VkObjectType enum\n  auto objectTypeIt = m_enums.find( \"VkObjectType\" );\n  assert( objectTypeIt != m_enums.end() );\n\n  // handle checks\n  for ( auto const & handle : m_handles )\n  {\n    // check the existence of the parent\n    checkForError(\n      m_handles.contains( handle.second.parent ), handle.second.xmlLine, \"handle <\" + handle.first + \"> with unknown parent <\" + handle.second.parent + \">\" );\n\n    // check existence of objTypeEnum used with this handle type\n    if ( !handle.first.empty() )\n    {\n      assert( !handle.second.objTypeEnum.empty() );\n\n      // only check with used handles!\n      checkForError( !isTypeUsed( handle.first ) || contains( objectTypeIt->second.values, handle.second.objTypeEnum ),\n                     handle.second.xmlLine,\n                     \"handle <\" + handle.first + \"> specifies unknown \\\"objtypeenum\\\" <\" + handle.second.objTypeEnum + \">\" );\n    }\n  }\n\n  // check that all specified objectType values are used with a handle type\n  for ( auto const & objectTypeValue : objectTypeIt->second.values )\n  {\n    if ( objectTypeValue.name != \"VK_OBJECT_TYPE_UNKNOWN\" )\n    {\n      checkForError( std::any_of( m_handles.begin(),\n                                  m_handles.end(),\n                                  [&objectTypeValue]( std::pair<std::string, HandleData> const & hd )\n                                  { return hd.second.objTypeEnum == objectTypeValue.name; } ),\n                     objectTypeValue.xmlLine,\n                     \"VkObjectType value <\" + objectTypeValue.name + \"> not specified as \\\"objtypeenum\\\" for any handle\" );\n    }\n  }\n}\n\nvoid VulkanHppGenerator::checkSpirVCapabilityCorrectness() const\n{\n  for ( auto const & capability : m_spirVCapabilities )\n  {\n    for ( auto const & enable : capability.second.structs )\n    {\n      assert( !enable.second.empty() );\n      auto structIt = findByNameOrAlias( m_structs, enable.first );\n      checkForError( structIt != m_structs.end(),\n                     enable.second.begin()->second,\n                     \"unknown structure <\" + enable.first + \"> specified for SPIR-V capability <\" + capability.first + \">\" );\n\n      for ( auto const & member : enable.second )\n      {\n        auto memberIt =\n          std::find_if( structIt->second.members.begin(), structIt->second.members.end(), [&member]( auto const & md ) { return md.name == member.first; } );\n        checkForError( memberIt != structIt->second.members.end(),\n                       member.second,\n                       \"unknown member <\" + member.first + \"> in struct <\" + enable.first + \"> specified for SPIR-V capability <\" + capability.first + \">\" );\n      }\n    }\n  }\n}\n\nvoid VulkanHppGenerator::checkStructCorrectness() const\n{\n  std::set<std::string> sTypeValues;\n  for ( auto const & structure : m_structs )\n  {\n    // check that a struct is referenced somewhere\n    // I think, it's not forbidden to not reference a struct, but it would probably be not intended?\n    auto typeIt = m_types.find( structure.first );\n    assert( typeIt != m_types.end() );\n    checkForError(\n      !typeIt->second.requiredBy.empty(), structure.second.xmlLine, \"structure <\" + structure.first + \"> not required by any feature or extension\" );\n\n    // check for existence of all structs that are extended by this struct\n    for ( auto const & extend : structure.second.structExtends )\n    {\n      checkForError( findByNameOrAlias( m_structs, extend ) != m_structs.end(),\n                     structure.second.xmlLine,\n                     \"struct <\" + structure.first + \"> extends unknown <\" + extend + \">\" );\n    }\n\n    // checks on the members of a struct\n    checkStructMemberCorrectness( structure.first, structure.second.members, sTypeValues );\n  }\n\n  // enum VkStructureType checks (need to be after structure checks because of sTypeValues gathered there)\n  auto structureTypeIt = m_enums.find( \"VkStructureType\" );\n  assert( structureTypeIt != m_enums.end() );\n  static std::set<std::string> reservedValues = { \"VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO\",\n                                                  \"VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO\",\n                                                  \"VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV\" };\n  for ( auto const & enumValue : structureTypeIt->second.values )\n  {\n    if ( reservedValues.contains( enumValue.name ) )\n    {\n      checkForError( !sTypeValues.contains( enumValue.name ), enumValue.xmlLine, \"Reserved VkStructureType enum value <\" + enumValue.name + \"> is used\" );\n    }\n    else\n    {\n      checkForWarning( !enumValue.supported || ( sTypeValues.erase( enumValue.name ) == 1 ),\n                       enumValue.xmlLine,\n                       \"VkStructureType enum value <\" + enumValue.name + \"> never used\" );\n    }\n  }\n  assert( sTypeValues.empty() );\n}\n\nvoid VulkanHppGenerator::checkStructMemberCorrectness( std::string const &             structureName,\n                                                       std::vector<MemberData> const & members,\n                                                       std::set<std::string> &         sTypeValues ) const\n{\n  // determine if this struct is requird/used\n  const bool structUsed = isTypeUsed( structureName );\n\n  for ( auto const & member : members )\n  {\n    // check that all member types are required in some feature or extension\n    if ( member.type.type.starts_with( \"Vk\" ) )\n    {\n      auto memberTypeIt = m_types.find( member.type.type );\n      assert( memberTypeIt != m_types.end() );\n      checkForError( !memberTypeIt->second.requiredBy.empty(),\n                     member.xmlLine,\n                     \"struct member type <\" + member.type.type + \"> used in struct <\" + structureName + \"> is never required for any feature or extension\" );\n    }\n\n    // if a member specifies a selector, that member is a union and the selector is an enum\n    // check that there's a 1-1 connection between the specified selections and the values of that enum\n    if ( !member.selector.empty() )\n    {\n      auto selectorIt = findStructMemberIt( member.selector, members );\n      assert( selectorIt != members.end() );\n      auto selectorEnumIt = m_enums.find( selectorIt->type.type );\n      assert( selectorEnumIt != m_enums.end() );\n      auto unionIt = m_structs.find( member.type.type );\n      assert( ( unionIt != m_structs.end() ) && unionIt->second.isUnion );\n      for ( auto const & unionMember : unionIt->second.members )\n      {\n        // check that each union member has a selection, that is a value of the seleting enum\n        assert( !unionMember.selection.empty() );\n        for ( auto const & selection : unionMember.selection )\n        {\n          checkForError( contains( selectorEnumIt->second.values, selection ),\n                         unionMember.xmlLine,\n                         \"union member <\" + unionMember.name + \"> uses selection <\" + selection + \"> that is not part of the selector type <\" +\n                           selectorIt->type.type + \">\" );\n        }\n      }\n    }\n\n    // check that each member type is known\n    checkForError( m_types.contains( member.type.type ), member.xmlLine, \"struct member uses unknown type <\" + member.type.type + \">\" );\n\n    // check that any used constant is a known constant or some potentially externally defined constant\n    for ( auto const & arraySize : member.arraySizes )\n    {\n      if ( !isNumber( arraySize ) && !m_constants.contains( arraySize ) )\n      {\n        auto typeIt = m_types.find( arraySize );\n        checkForError( ( typeIt != m_types.end() ) && isAllUpper( arraySize ) && ( typeIt->second.category == TypeCategory::ExternalType ),\n                       member.xmlLine,\n                       \"struct member array size uses unknown constant <\" + arraySize + \">\" );\n      }\n    }\n\n    // checks if a value is specified\n    if ( !member.value.empty() )\n    {\n      auto enumIt = m_enums.find( member.type.type );\n      if ( enumIt != m_enums.end() )\n      {\n        // check that the value exists in the specified enum (if the struct is used at all)\n        if ( structUsed )\n        {\n          checkForError( contains( enumIt->second.values, member.value ),\n                         member.xmlLine,\n                         \"value <\" + member.value + \"> for member <\" + member.name + \"> in structure <\" + structureName + \"> of enum type <\" +\n                           member.type.type + \"> not listed\" );\n          // special handling for sType: no value should appear more than once\n          if ( member.name == \"sType\" )\n          {\n            checkForError( sTypeValues.insert( member.value ).second, member.xmlLine, \"sType value <\" + member.value + \"> has been used before\" );\n          }\n        }\n      }\n      else if ( member.type.type == \"uint32_t\" )\n      {\n        checkForError( isNumber( member.value ),\n                       member.xmlLine,\n                       \"value <\" + member.value + \"> for member <\" + member.name + \"> in structure <\" + structureName + \"> of type <\" + member.type.type +\n                         \"> is not a number\" );\n      }\n      else\n      {\n        // don't know the type of the value -> error out\n        checkForError( false,\n                       member.xmlLine,\n                       \"member <\" + member.name + \"> in structure <\" + structureName + \"> holds value <\" + member.value + \"> for an unhandled type <\" +\n                         member.type.type + \">\" );\n      }\n    }\n  }\n}\n\nvoid VulkanHppGenerator::checkSyncAccessCorrectness() const\n{\n  auto accessFlagBitsIt = m_enums.find( \"VkAccessFlagBits\" );\n  assert( accessFlagBitsIt != m_enums.end() );\n  auto accessFlagBits2It = m_enums.find( \"VkAccessFlagBits2\" );\n  assert( accessFlagBits2It != m_enums.end() );\n\n  for ( auto const & syncAccess : m_syncAccesses )\n  {\n    auto nameIt = findByNameOrAlias( accessFlagBits2It->second.values, syncAccess.first );\n    checkForError( nameIt != accessFlagBits2It->second.values.end(),\n                   syncAccess.second.xmlLine,\n                   \"syncaccess name <\" + syncAccess.first + \"> not specified as a VkAccessFlagBits value!\" );\n\n    if ( !syncAccess.second.name.empty() )\n    {\n      // with alias\n      auto aliasIt = findByNameOrAlias( accessFlagBitsIt->second.values, syncAccess.second.name );\n      checkForError( aliasIt != accessFlagBitsIt->second.values.end(),\n                     syncAccess.second.xmlLine,\n                     \"syncaccess alias <\" + syncAccess.second.name + \"> not specified as a VkAccessFlagBits value!\" );\n      checkForError( ( aliasIt->value == nameIt->value ) && ( aliasIt->bitpos == nameIt->bitpos ),\n                     syncAccess.second.xmlLine,\n                     \"syncaccess name <\" + syncAccess.first + \"> has an alias <\" + syncAccess.second.name + \"> with a different value or bitpos!\" );\n    }\n  }\n}\n\nvoid VulkanHppGenerator::checkSyncStageCorrectness() const\n{\n  auto stageFlagBitsIt = m_enums.find( \"VkPipelineStageFlagBits\" );\n  assert( stageFlagBitsIt != m_enums.end() );\n  auto stageFlagBits2It = m_enums.find( \"VkPipelineStageFlagBits2\" );\n  assert( stageFlagBits2It != m_enums.end() );\n\n  for ( auto const & syncStage : m_syncStages )\n  {\n    auto nameIt = findByNameOrAlias( stageFlagBits2It->second.values, syncStage.first );\n    checkForError( nameIt != stageFlagBits2It->second.values.end(),\n                   syncStage.second.xmlLine,\n                   \"syncstage name <\" + syncStage.first + \"> not specified as a VkPipelineStageFlagBits2 value!\" );\n\n    if ( !syncStage.second.name.empty() )\n    {\n      // with alias\n      auto aliasIt = findByNameOrAlias( stageFlagBitsIt->second.values, syncStage.second.name );\n      checkForError( aliasIt != stageFlagBitsIt->second.values.end(),\n                     syncStage.second.xmlLine,\n                     \"syncstage alias <\" + syncStage.second.name + \"> not specified as a VkPipelineStageFlagBits value!\" );\n      checkForError( ( aliasIt->value == nameIt->value ) && ( aliasIt->bitpos == nameIt->bitpos ),\n                     syncStage.second.xmlLine,\n                     \"syncstate name <\" + syncStage.first + \"> has an alias <\" + syncStage.second.name + \"> with a different value or bitpos!\" );\n    }\n  }\n}\n\nstd::string VulkanHppGenerator::combineDataTypes( std::map<size_t, VectorParamData> const & vectorParams,\n                                                  std::vector<size_t> const &               returnParams,\n                                                  bool                                      enumerating,\n                                                  std::vector<std::string> const &          dataTypes,\n                                                  CommandFlavourFlags                       flavourFlags,\n                                                  bool                                      raii ) const\n{\n  assert( dataTypes.size() == returnParams.size() );\n\n  std::vector<std::string> modifiedDataTypes( dataTypes.size() );\n  for ( size_t i = 0; i < returnParams.size(); ++i )\n  {\n    auto vectorParamIt   = vectorParams.find( returnParams[i] );\n    modifiedDataTypes[i] = ( vectorParamIt == vectorParams.end() || ( flavourFlags & CommandFlavourFlagBits::singular ) )\n                           ? dataTypes[i]\n                           : ( \"std::vector<\" + dataTypes[i] +\n                               ( raii || ( flavourFlags & CommandFlavourFlagBits::unique )\n                                   ? \">\"\n                                   : ( \", \" + startUpperCase( stripPrefix( dataTypes[i], \"VULKAN_HPP_NAMESPACE::\" ) ) + \"Allocator>\" ) ) );\n  }\n\n  std::string combinedType;\n  switch ( modifiedDataTypes.size() )\n  {\n    case 0: combinedType = \"void\"; break;\n    case 1: combinedType = modifiedDataTypes[0]; break;\n    case 2:\n      assert( !enumerating || ( vectorParams.contains( returnParams[1] ) && ( vectorParams.find( returnParams[1] )->second.lenParam == returnParams[0] ) ) );\n      combinedType = enumerating ? modifiedDataTypes[1] : ( \"std::pair<\" + modifiedDataTypes[0] + \", \" + modifiedDataTypes[1] + \">\" );\n      break;\n    case 3:\n      assert( enumerating );\n      switch ( vectorParams.size() )\n      {\n        case 1:\n          assert( ( vectorParams.begin()->first == returnParams[2] ) && ( vectorParams.begin()->second.lenParam == returnParams[1] ) );\n          combinedType = \"std::pair<\" + modifiedDataTypes[0] + \", \" + modifiedDataTypes[2] + \">\";\n          break;\n        case 2:\n          assert( ( vectorParams.begin()->first == returnParams[1] ) && ( vectorParams.begin()->second.lenParam == returnParams[0] ) &&\n                  ( std::next( vectorParams.begin() )->first == returnParams[2] ) &&\n                  ( std::next( vectorParams.begin() )->second.lenParam == returnParams[0] ) );\n          combinedType = \"std::pair<\" + modifiedDataTypes[1] + \", \" + modifiedDataTypes[2] + \">\";\n          break;\n        default: assert( false ); break;\n      }\n      break;\n    default: assert( false ); break;\n  }\n  return combinedType;\n}\n\nbool VulkanHppGenerator::contains( std::vector<EnumValueData> const & enumValues, std::string const & name ) const\n{\n  return std::any_of( enumValues.begin(),\n                      enumValues.end(),\n                      [&name]( EnumValueData const & ev ) {\n                        return ( ev.name == name ) ||\n                               std::any_of( ev.aliases.begin(), ev.aliases.end(), [&name]( auto const & eav ) { return eav.name == name; } );\n                      } );\n}\n\nbool VulkanHppGenerator::containsArray( std::string const & type ) const\n{\n  // a simple recursive check if a type is or contains an array\n  auto structureIt = m_structs.find( type );\n  bool found       = false;\n  if ( structureIt != m_structs.end() )\n  {\n    for ( auto memberIt = structureIt->second.members.begin(); memberIt != structureIt->second.members.end() && !found; ++memberIt )\n    {\n      found = !memberIt->arraySizes.empty() || containsArray( memberIt->type.type );\n    }\n  }\n  return found;\n}\n\nbool VulkanHppGenerator::containsFuncPointer( std::string const & type ) const\n{\n  // a simple recursive check if a type contains a funcpointer\n  auto structureIt = m_structs.find( type );\n  bool found       = false;\n  if ( structureIt != m_structs.end() )\n  {\n    for ( auto memberIt = structureIt->second.members.begin(); memberIt != structureIt->second.members.end() && !found; ++memberIt )\n    {\n      found = m_funcPointers.contains( memberIt->type.type ) || ( ( memberIt->type.type != type ) && containsFuncPointer( memberIt->type.type ) );\n    }\n  }\n  return found;\n}\n\nbool VulkanHppGenerator::containsFloatingPoints( std::vector<MemberData> const & members ) const\n{\n  for ( auto const & m : members )\n  {\n    if ( m.type.isValue() )\n    {\n      if ( ( m.type.type == \"float\" ) || ( m.type.type == \"double\" ) )\n      {\n        return true;\n      }\n      else\n      {\n        auto structureIt = m_structs.find( m.type.type );\n        if ( structureIt != m_structs.end() && containsFloatingPoints( structureIt->second.members ) )\n        {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nbool VulkanHppGenerator::containsUnion( std::string const & type ) const\n{\n  // a simple recursive check if a type is or contains a union\n  auto structureIt = m_structs.find( type );\n  bool found       = false;\n  if ( structureIt != m_structs.end() )\n  {\n    found = structureIt->second.isUnion;\n    for ( auto memberIt = structureIt->second.members.begin(); memberIt != structureIt->second.members.end() && !found; ++memberIt )\n    {\n      found = memberIt->type.isValue() && containsUnion( memberIt->type.type );\n    }\n  }\n  return found;\n}\n\nbool VulkanHppGenerator::describesVector( StructureData const & structure, std::string const & type ) const\n{\n  for ( auto const & member : structure.members )\n  {\n    if ( ( type.empty() ? true : ( member.type.type == type ) ) && member.type.isNonConstPointer() && ( member.lenMembers.size() == 1 ) )\n    {\n      assert( member.lenMembers[0].second < structure.members.size() );\n      auto const & lenMember = structure.members[member.lenMembers[0].second];\n      if ( lenMember.type.isValue() && ( ( lenMember.type.type == \"size_t\" ) || ( lenMember.type.type == \"uint32_t\" ) ) )\n      {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nstd::vector<size_t> VulkanHppGenerator::determineChainedReturnParams( std::vector<ParamData> const & params, std::vector<size_t> const & returnParams ) const\n{\n  std::vector<size_t> chainedParams;\n\n  for ( auto rp : returnParams )\n  {\n    if ( isStructureChainAnchor( params[rp].type.type ) )\n    {\n      chainedParams.push_back( rp );\n    }\n  }\n  return chainedParams;\n}\n\nstd::vector<size_t> VulkanHppGenerator::determineConstPointerParams( std::vector<ParamData> const & params ) const\n{\n  std::vector<size_t> constPointerParams;\n\n  for ( size_t i = 0; i < params.size(); i++ )\n  {\n    // very special handling for some types, which come in as non-const pointers, but are meant as const-pointers\n    if ( params[i].type.isConstPointer() || ( params[i].type.isNonConstPointer() && specialPointerTypes.contains( params[i].type.type ) ) )\n    {\n      constPointerParams.push_back( i );\n    }\n  }\n  return constPointerParams;\n}\n\nstd::vector<std::string> VulkanHppGenerator::determineDataTypes( std::vector<VulkanHppGenerator::ParamData> const & params,\n                                                                 std::map<size_t, VectorParamData> const &          vectorParams,\n                                                                 std::vector<size_t> const &                        returnParams,\n                                                                 std::set<size_t> const &                           templatedParams ) const\n{\n  std::vector<std::string> dataTypes;\n  for ( auto rp : returnParams )\n  {\n    auto vectorParamIt = vectorParams.find( rp );\n    if ( templatedParams.contains( rp ) )\n    {\n      assert( ( vectorParamIt == vectorParams.end() ) || !vectorParamIt->second.byStructure );\n      if ( ( vectorParamIt != vectorParams.end() ) &&\n           std::any_of( returnParams.begin(), returnParams.end(), [&vectorParamIt]( size_t rp ) noexcept { return rp == vectorParamIt->first; } ) &&\n           std::any_of( returnParams.begin(), returnParams.end(), [&vectorParamIt]( size_t rp ) noexcept { return rp == vectorParamIt->second.lenParam; } ) )\n      {\n        dataTypes.push_back( \"uint8_t\" );\n      }\n      else\n      {\n        dataTypes.push_back( ( stripPrefix( params[rp].name, \"p\" ) + \"Type\" ) );\n      }\n    }\n    else if ( ( vectorParamIt != vectorParams.end() ) && vectorParamIt->second.byStructure )\n    {\n      dataTypes.push_back( trimEnd( stripPostfix( vectorMemberByStructure( params[rp].type.type ).type.compose( \"VULKAN_HPP_NAMESPACE\" ), \"*\" ) ) );\n    }\n    else\n    {\n      dataTypes.push_back( trimEnd( stripPostfix( params[rp].type.compose( \"VULKAN_HPP_NAMESPACE\" ), \"*\" ) ) );\n    }\n  }\n  return dataTypes;\n}\n\nsize_t VulkanHppGenerator::determineDefaultStartIndex( std::vector<ParamData> const & params, std::set<size_t> const & skippedParams ) const\n{\n  // determine the index where the arguments start to have defaults\n  size_t defaultStartIndex = INVALID_INDEX;\n  for ( int i = static_cast<int>( params.size() ) - 1; ( 0 <= i ) && ( params[i].optional || skippedParams.contains( i ) ); --i )\n  {\n    defaultStartIndex = i;\n  }\n  return defaultStartIndex;\n}\n\nbool VulkanHppGenerator::determineEnumeration( std::map<size_t, VectorParamData> const & vectorParams, std::vector<size_t> const & returnParams ) const\n{\n  // a command is considered to be enumerating some data, if for at least one vectorParam the data is a returnParam and either the vectorParams is specified\n  // by a structure or the lenParam is a returnParam as well\n  return std::any_of( vectorParams.begin(),\n                      vectorParams.end(),\n                      [&returnParams]( auto const & vp )\n                      {\n                        return std::any_of( returnParams.begin(), returnParams.end(), [&vp]( size_t rp ) { return rp == vp.first; } ) &&\n                               ( vp.second.byStructure ||\n                                 std::any_of( returnParams.begin(), returnParams.end(), [&vp]( size_t rp ) { return rp == vp.second.lenParam; } ) );\n                      } );\n}\n\nsize_t VulkanHppGenerator::determineInitialSkipCount( std::string const & command ) const\n{\n  // determine the number of arguments to skip for a function\n  // -> 0: the command is not bound to an instance or a device (the corresponding handle has no name)\n  // -> 1: the command bound to an instance or a device (the corresponding handle has a name)\n  // -> 2: the command has been moved to a second handle\n  auto commandIt = findByNameOrAlias( m_commands, command );\n  assert( commandIt != m_commands.end() );\n  auto handleIt = m_handles.find( commandIt->second.handle );\n  assert( handleIt != m_handles.end() );\n  if ( !handleIt->second.commands.contains( command ) )\n  {\n    assert( 1 < commandIt->second.params.size() );\n    assert( m_handles.contains( commandIt->second.params[1].type.type ) );\n    return 2;\n  }\n  else\n  {\n    return handleIt->first.empty() ? 0 : 1;\n  }\n}\n\nstd::vector<size_t> VulkanHppGenerator::determineReturnParams( std::vector<ParamData> const & params ) const\n{\n  std::vector<size_t> nonConstPointerParamIndices;\n\n  for ( size_t i = 0; i < params.size(); i++ )\n  {\n    // very special handling of parameters of some types, which always come as a non-const pointer but are not meant\n    // to be a potential return value!\n    if ( params[i].type.isNonConstPointer() && !specialPointerTypes.contains( params[i].type.type ) )\n    {\n      nonConstPointerParamIndices.push_back( i );\n    }\n  }\n  return nonConstPointerParamIndices;\n}\n\nbool VulkanHppGenerator::isConstructorCandidate( std::pair<std::string, VulkanHppGenerator::CommandData> const & command, std::string const & handleType ) const\n{\n  return isSupported( command.second.requiredBy ) &&\n         std::any_of( command.second.params.begin(),\n                      command.second.params.end(),\n                      [this, &handleType]( ParamData const & pd ) { return isConstructorCandidate( pd, handleType ); } );\n}\n\nbool VulkanHppGenerator::isConstructorCandidate( ParamData const & paramData, std::string const & handleType ) const\n{\n  if ( paramData.type.isNonConstPointer() )\n  {\n    if ( paramData.type.type == handleType )\n    {\n      return true;\n    }\n    else\n    {\n      auto structIt = m_structs.find( paramData.type.type );\n      if ( structIt != m_structs.end() )\n      {\n        return describesVector( structIt->second, handleType );\n      }\n    }\n  }\n  return false;\n}\n\nstd::vector<std::map<std::string, VulkanHppGenerator::CommandData>::const_iterator>\n  VulkanHppGenerator::determineRAIIHandleConstructors( std::string const & handleType, std::map<std::string, CommandData>::const_iterator destructorIt ) const\n{\n  std::vector<std::map<std::string, CommandData>::const_iterator> constructorIts;\n  for ( auto commandIt = m_commands.begin(); commandIt != m_commands.end(); ++commandIt )\n  {\n    if ( isConstructorCandidate( *commandIt, handleType ) )\n    {\n      // only commands that provide all information needed for the destructor can be considered a constructor!\n      bool valid = true;\n      if ( destructorIt != m_commands.end() )\n      {\n        // get the destructors parameter to the handleType\n        auto desctructorHandleParamIt = std::find_if( destructorIt->second.params.begin(),\n                                                      destructorIt->second.params.end(),\n                                                      [&handleType]( ParamData const & pd ) { return pd.type.type == handleType; } );\n        assert( desctructorHandleParamIt != destructorIt->second.params.end() );\n\n        // lambda to check if a destructor parameter is a parameter of the constructor candidate\n        // (or it's just the len parameter, which is not needed for the constructor)\n        auto isConstructorCandidateParam = [&desctructorHandleParamIt, &commandIt, this]( ParamData const & destructorParam )\n        {\n          // check if the destructor param type equals this param type, or, if this param type is a struct, is part of\n          // that struct\n          auto isDestructorParamType = [&destructorParam, this]( ParamData const & pd )\n          {\n            if ( pd.type.type != destructorParam.type.type )\n            {\n              // check if the destructor param type equals a structure member type\n              auto structureIt = m_structs.find( pd.type.type );\n              return ( structureIt != m_structs.end() ) &&\n                     ( findStructMemberItByType( destructorParam.type.type, structureIt->second.members ) != structureIt->second.members.end() );\n            }\n            return true;\n          };\n\n          return ( destructorParam.name == desctructorHandleParamIt->lenExpression ) ||\n                 std::any_of( commandIt->second.params.begin(), commandIt->second.params.end(), isDestructorParamType );\n        };\n\n        // the constructor candidate is valid, if none of the (relevant) destructor parameters is missing in the\n        // constructor candidate params\n        valid = std::all_of( destructorIt->second.params.begin(), destructorIt->second.params.end(), isConstructorCandidateParam );\n      }\n      if ( valid )\n      {\n        constructorIts.push_back( commandIt );\n      }\n    }\n  }\n  return constructorIts;\n}\n\nstd::map<std::string, VulkanHppGenerator::CommandData>::const_iterator VulkanHppGenerator::determineRAIIHandleDestructor( std::string const & handleType ) const\n{\n  std::string type         = stripPrefix( handleType, \"Vk\" );\n  auto        destructorIt = m_commands.find( \"vkDestroy\" + type );\n  if ( destructorIt == m_commands.end() )\n  {\n    destructorIt = m_commands.find( \"vkFree\" + type + \"s\" );\n    if ( destructorIt == m_commands.end() )\n    {\n      destructorIt = m_commands.find( \"vkRelease\" + type );\n      if ( destructorIt == m_commands.end() )\n      {\n        if ( handleType == \"VkDeviceMemory\" )\n        {\n          // special handling for vkDeviceMemory\n          destructorIt = m_commands.find( \"vkFreeMemory\" );\n          assert( destructorIt != m_commands.end() );\n        }\n        else if ( handleType == \"VkDisplayKHR\" )\n        {\n          // special handling for VkDisplayKHR\n          destructorIt = m_commands.find( \"vkReleaseDisplayEXT\" );\n          assert( destructorIt != m_commands.end() );\n        }\n        else\n        {\n          assert( ( handleType == \"VkDisplayModeKHR\" ) || ( handleType == \"VkPhysicalDevice\" ) || ( handleType == \"VkQueue\" ) );\n        }\n      }\n    }\n  }\n  return destructorIt;\n}\n\nstd::set<size_t> VulkanHppGenerator::determineSingularParams( size_t returnParam, std::map<size_t, VectorParamData> const & vectorParams ) const\n{\n  auto returnVectorIt = vectorParams.find( returnParam );\n  assert( returnVectorIt != vectorParams.end() );\n  std::set<size_t> singularParams;\n  singularParams.insert( returnVectorIt->second.lenParam );\n  for ( auto const & vpi : vectorParams )\n  {\n    if ( vpi.second.lenParam == returnVectorIt->second.lenParam )\n    {\n      singularParams.insert( vpi.first );\n    }\n  }\n  return singularParams;\n}\n\nstd::set<size_t> VulkanHppGenerator::determineSkippedParams( std::vector<ParamData> const &            params,\n                                                             size_t                                    initialSkipCount,\n                                                             std::map<size_t, VectorParamData> const & vectorParams,\n                                                             std::vector<size_t> const &               returnParams,\n                                                             bool                                      singular ) const\n{\n  // skip the initial skips (get fed by the object)\n  assert( initialSkipCount <= params.size() );\n  std::set<size_t> skippedParams;\n  for ( size_t i = 0; i < initialSkipCount; ++i )\n  {\n    skippedParams.insert( i );\n  }\n\n  // skip the size parameters (get derived from an array), and a stride parameter\n  for ( auto const & vpi : vectorParams )\n  {\n    if ( !vpi.second.byStructure )\n    {\n      assert( !params[vpi.first].lenExpression.empty() );\n      if ( ( std::none_of( returnParams.begin(), returnParams.end(), [&vpi]( size_t rpi ) { return vpi.first == rpi; } ) &&\n             isParam( params[vpi.first].lenExpression, params ) ) ||\n           ( singular && params[vpi.second.lenParam].type.isValue() ) )\n      {\n        skippedParams.insert( vpi.second.lenParam );\n      }\n      if ( vpi.second.strideParam != INVALID_INDEX )\n      {\n        skippedParams.insert( vpi.second.strideParam );\n      }\n    }\n  }\n\n  // skip the return parameters (get resolved by local variables to be returned)\n  skippedParams.insert( returnParams.begin(), returnParams.end() );\n\n  return skippedParams;\n}\n\nstd::string VulkanHppGenerator::determineSubStruct( std::pair<std::string, StructureData> const & structure ) const\n{\n  if ( structure.second.members.front().name != \"sType\" )\n  {\n    // check if sd is a substruct of structure\n    auto isSubStruct = [&structure]( std::pair<std::string, StructureData> const & sd ) noexcept\n    {\n      // member-by-member comparison of type and name\n      auto memberIt = structure.second.members.begin();\n      auto isMember = [&memberIt]( MemberData const & md ) noexcept\n      {\n        if ( ( md.type == memberIt->type ) && ( md.name == memberIt->name ) )\n        {\n          ++memberIt;\n          return true;\n        }\n        return false;\n      };\n\n      return ( sd.second.members.size() < structure.second.members.size() ) && std::all_of( sd.second.members.begin(), sd.second.members.end(), isMember );\n    };\n\n    // look for a struct in m_structs that starts identically to structure\n    auto structIt = std::find_if( m_structs.begin(), m_structs.end(), isSubStruct );\n    return ( structIt == m_structs.end() ) ? \"\" : structIt->first;\n  }\n  return \"\";\n}\n\nstd::map<size_t, VulkanHppGenerator::VectorParamData> VulkanHppGenerator::determineVectorParams( std::vector<ParamData> const & params ) const\n{\n  std::map<size_t, VectorParamData> vectorParams;\n\n  // look for the parameters whose len equals the name of an other parameter\n  for ( size_t i = 0; i < params.size(); i++ )\n  {\n    if ( !params[i].lenExpression.empty() && ( params[i].lenExpression != \"null-terminated\" ) && ( params[i].lenExpression != \"1\" ) )\n    {\n      VectorParamData & vpd = vectorParams[i];\n\n      if ( params[i].lenParams.empty() )\n      {\n        std::string const & lenExpression = params[i].lenExpression;\n        assert( std::none_of( params.begin(), params.end(), [&lenExpression]( auto const & pd ) { return ( lenExpression == pd.name ); } ) );\n        auto lenIt =\n          std::find_if( params.begin(), params.end(), [this, &lenExpression]( auto const & pd ) { return isLenByStructMember( lenExpression, pd ); } );\n        assert( lenIt != params.end() );\n        vpd.lenParam = std::distance( params.begin(), lenIt );\n      }\n      else\n      {\n        assert( params[i].lenParams.size() == 1 );\n        vpd.lenParam = params[i].lenParams[0].second;\n      }\n      if ( !params[i].strideParam.first.empty() )\n      {\n        vpd.strideParam = params[i].strideParam.second;\n      }\n    }\n    else\n    {\n      auto structIt = m_structs.find( params[i].type.type );\n      if ( ( structIt != m_structs.end() ) && !isStructureChainAnchor( params[i].type.type ) && describesVector( structIt->second ) )\n      {\n        VectorParamData & vpd = vectorParams[i];\n        vpd.byStructure       = true;\n        vpd.lenParam          = 2;\n      }\n    }\n  }\n  return vectorParams;\n}\n\nstd::set<size_t> VulkanHppGenerator::determineVoidPointerParams( std::vector<ParamData> const & params ) const\n{\n  std::set<size_t> voidPointerParams;\n\n  for ( size_t i = 0; i < params.size(); i++ )\n  {\n    if ( !params[i].type.isValue() && ( params[i].type.type == \"void\" ) && ( params[i].type.postfix != \"**\" ) )\n    {\n      voidPointerParams.insert( i );\n    }\n  }\n  return voidPointerParams;\n}\n\nvoid VulkanHppGenerator::distributeEnumExtends()\n{\n  for ( auto const & extendedEnum : m_enumExtends )\n  {\n    assert( !extendedEnum.second.empty() );\n    auto typeIt = m_types.find( extendedEnum.first );\n    checkForError( typeIt != m_types.end(),\n                   extendedEnum.second.front().xmlLine,\n                   \"enum value <\" + extendedEnum.second.front().name + \"> extends unknown type <\" + extendedEnum.first + \">\" );\n    checkForError( typeIt->second.category == TypeCategory::Enum,\n                   extendedEnum.second.front().xmlLine,\n                   \"enum value <\" + extendedEnum.second.front().name + \"> extends non-enum type <\" + extendedEnum.first + \">\" );\n\n    const auto enumIt = m_enums.find( extendedEnum.first );\n    assert( enumIt != m_enums.end() );\n\n    for ( auto const & eed : extendedEnum.second )\n    {\n      for ( auto const & requiredBy : eed.requiredBy )\n      {\n        typeIt->second.requiredBy.insert( requiredBy );\n      }\n      enumIt->second.addEnumAlias(\n        eed.xmlLine, eed.name, eed.alias, getProtectFromPlatform( eed.platform ), ( eed.api.empty() || ( eed.api == m_api ) ) && eed.supported );\n    }\n  }\n  m_enumExtends.clear();\n}\n\nvoid VulkanHppGenerator::distributeEnumValueAliases()\n{\n  assert( m_enumExtends.empty() );\n\n  for ( auto & e : m_enums )\n  {\n    for ( auto & a : e.second.valueAliases )\n    {\n      auto valueIt = findByName( e.second.values, a.alias );\n      if ( valueIt == e.second.values.end() )\n      {\n        auto aliasIt = findByName( e.second.valueAliases, a.alias );\n        checkForError(\n          aliasIt != e.second.valueAliases.end(), a.xmlLine, \"enum value alias <\" + a.name + \"> aliases non-existent enum value <\" + a.alias + \">\" );\n        valueIt = findByName( e.second.values, aliasIt->alias );\n      }\n      checkForError( valueIt != e.second.values.end(), a.xmlLine, \"enum value alias <\" + a.name + \"> aliases non-existent enum value <\" + a.alias + \">\" );\n      checkForError(\n        a.protect == valueIt->protect, a.xmlLine, \"enum value alias <\" + a.name + \"> aliases enum value <\" + a.alias + \"> with different properties\" );\n      checkForError( std::none_of( valueIt->aliases.begin(), valueIt->aliases.end(), [&a]( auto const & eav ) { return a.name == eav.name; } ),\n                     a.xmlLine,\n                     \"enum value alias <\" + a.name + \"> already contained as alias for enum value <\" + a.alias + \">\" );\n      valueIt->aliases.push_back( a );\n    }\n    e.second.valueAliases.clear();\n  }\n}\n\nvoid VulkanHppGenerator::distributeRequirements()\n{\n  for ( auto const & feature : m_features )\n  {\n    distributeRequirements( feature.requireData, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    distributeRequirements( extension.requireData, extension.name );\n    distributeRequirements( extension.unsupportedRequireData, extension.name );\n  }\n  for ( auto const & feature : m_unsupportedFeatures )\n  {\n    distributeRequirements( feature.requireData, feature.name );\n  }\n  for ( auto const & extension : m_unsupportedExtensions )\n  {\n    distributeRequirements( extension.requireData, extension.name );\n    distributeRequirements( extension.unsupportedRequireData, extension.name );\n  }\n}\n\nvoid VulkanHppGenerator::distributeRequirements( std::vector<RequireData> const & requireData, std::string const & requiredBy )\n{\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & command : require.commands )\n    {\n      auto commandIt = findByNameOrAlias( m_commands, command.name );\n      checkForError( commandIt != m_commands.end(), command.xmlLine, \"unknown required command <\" + command.name + \">\" );\n      commandIt->second.requiredBy.insert( requiredBy );\n    }\n    for ( auto const & type : require.types )\n    {\n      auto typeIt = m_types.find( type.name );\n      checkForError( typeIt != m_types.end(), type.xmlLine, \"unknown required type <\" + type.name + \">\" );\n      typeIt->second.requiredBy.insert( requiredBy );\n    }\n  }\n}\n\nvoid VulkanHppGenerator::distributeStructAliases()\n{\n  for ( auto const & alias : m_structsAliases )\n  {\n    auto structIt = findByNameOrAlias( m_structs, alias.second.name );\n    checkForError(\n      structIt != m_structs.end(), alias.second.xmlLine, \"struct alias <\" + alias.first + \"> references an unknown struct <\" + alias.second.name + \">\" );\n    checkForError( structIt->second.aliases.insert( { alias.first, alias.second.xmlLine } ).second,\n                   alias.second.xmlLine,\n                   \"struct alias <\" + alias.first + \"> already listed as an alias for struct <\" + alias.second.name + \">\" );\n  }\n  m_structsAliases.clear();\n}\n\nvoid VulkanHppGenerator::filterLenMembers()\n{\n  for ( auto & sd : m_structs )\n  {\n    for ( auto & member : sd.second.members )\n    {\n      std::erase_if( member.lenMembers, [this]( std::pair<std::string, size_t> const & nameIndex ) { return m_constants.contains( nameIndex.first ); } );\n\n      for ( auto & lenMember : member.lenMembers )\n      {\n        if ( lenMember.second == static_cast<size_t>( ~0 ) )\n        {\n          auto lenMemberIt = findStructMemberIt( lenMember.first, sd.second.members );\n          checkForError( lenMemberIt != sd.second.members.end(),\n                         member.xmlLine,\n                         \"struct member <\" + member.name + \"> uses unknown len member <\" + lenMember.first + \"> in its \\\"altlen\\\" attribute <\" +\n                           member.lenExpressions[0] + \">\" );\n          lenMember.second = std::distance( sd.second.members.cbegin(), lenMemberIt );\n        }\n      }\n    }\n  }\n}\n\nstd::map<std::string, VulkanHppGenerator::NameLine>::const_iterator VulkanHppGenerator::findAlias( std::string const &                     name,\n                                                                                                   std::map<std::string, NameLine> const & aliases ) const\n{\n  auto lambda = [&name]( std::pair<std::string, NameLine> const & ad ) { return ad.second.name == name; };\n  auto it     = std::find_if( aliases.begin(), aliases.end(), lambda );\n  assert( ( it == aliases.end() ) || std::none_of( std::next( it ), aliases.end(), lambda ) );\n  return it;\n}\n\nstd::string VulkanHppGenerator::findBaseName( std::string aliasName, std::map<std::string, NameLine> const & aliases ) const\n{\n  std::string baseName = aliasName;\n  auto        aliasIt  = aliases.find( baseName );\n  while ( aliasIt != aliases.end() )\n  {\n    baseName = aliasIt->second.name;\n    aliasIt  = aliases.find( baseName );\n  }\n  return baseName;\n}\n\nstd::vector<VulkanHppGenerator::FeatureData>::const_iterator VulkanHppGenerator::findFeature( std::string const & name ) const\n{\n  return std::find_if( m_features.begin(), m_features.end(), [&name]( FeatureData const & fd ) { return fd.name == name; } );\n}\n\nstd::vector<VulkanHppGenerator::ParamData>::const_iterator VulkanHppGenerator::findParamIt( std::string const &            name,\n                                                                                            std::vector<ParamData> const & paramData ) const\n{\n  return std::find_if( paramData.begin(), paramData.end(), [&name]( ParamData const & pd ) { return pd.name == name; } );\n}\n\nstd::vector<VulkanHppGenerator::MemberData>::const_iterator VulkanHppGenerator::findStructMemberIt( std::string const &             name,\n                                                                                                    std::vector<MemberData> const & memberData ) const\n{\n  return std::find_if( memberData.begin(), memberData.end(), [&name]( MemberData const & md ) { return md.name == name; } );\n}\n\nstd::vector<VulkanHppGenerator::MemberData>::const_iterator VulkanHppGenerator::findStructMemberItByType( std::string const &             type,\n                                                                                                          std::vector<MemberData> const & memberData ) const\n{\n  return std::find_if( memberData.begin(), memberData.end(), [&type]( MemberData const & md ) { return md.type.type == type; } );\n}\n\nstd::vector<VulkanHppGenerator::ExtensionData>::const_iterator VulkanHppGenerator::findSupportedExtension( std::string const & name ) const\n{\n  return std::find_if( m_extensions.begin(), m_extensions.end(), [&name]( ExtensionData const & ed ) { return ed.name == name; } );\n}\n\nstd::string VulkanHppGenerator::findTag( std::string const & name, std::string const & postfix ) const\n{\n  auto tagIt = std::find_if(\n    m_tags.begin(), m_tags.end(), [&name, &postfix]( std::pair<std::string, TagData> const & t ) { return name.ends_with( t.first + postfix ); } );\n  return ( tagIt != m_tags.end() ) ? tagIt->first : \"\";\n}\n\nstd::pair<std::string, std::string> VulkanHppGenerator::generateAllocatorTemplates( std::vector<size_t> const &               returnParams,\n                                                                                    std::vector<std::string> const &          returnDataTypes,\n                                                                                    std::map<size_t, VectorParamData> const & vectorParams,\n                                                                                    std::vector<size_t> const &               chainedReturnParams,\n                                                                                    CommandFlavourFlags                       flavourFlags,\n                                                                                    bool                                      definition ) const\n{\n  assert( chainedReturnParams.size() <= 1 );\n  const bool chained  = flavourFlags & CommandFlavourFlagBits::chained;\n  const bool singular = flavourFlags & CommandFlavourFlagBits::singular;\n  const bool unique   = flavourFlags & CommandFlavourFlagBits::unique;\n\n  assert( returnParams.size() == returnDataTypes.size() );\n  std::string allocatorTemplates;\n  if ( !singular )\n  {\n    for ( size_t i = 0; i < returnParams.size(); i++ )\n    {\n      if ( vectorParams.contains( returnParams[i] ) )\n      {\n        if ( chained && !chainedReturnParams.empty() && ( chainedReturnParams[0] == returnParams[i] ) )\n        {\n          allocatorTemplates += \"typename StructureChainAllocator\";\n          if ( !definition )\n          {\n            allocatorTemplates += \" = std::allocator<StructureChain>\";\n          }\n        }\n        else\n        {\n          allocatorTemplates += \"typename \" + startUpperCase( stripPrefix( returnDataTypes[i], \"VULKAN_HPP_NAMESPACE::\" ) ) + \"Allocator\";\n          if ( !definition )\n          {\n            allocatorTemplates += \" = std::allocator<\" + ( unique ? ( \"UniqueHandle<\" + returnDataTypes[i] + \", Dispatch>\" ) : returnDataTypes[i] ) + \">\";\n          }\n        }\n        allocatorTemplates += \", \";\n      }\n    }\n  }\n  std::string uniqueHandleAllocatorTemplates;\n  if ( unique && !allocatorTemplates.empty() )\n  {\n    uniqueHandleAllocatorTemplates = \", \" + stripPostfix( allocatorTemplates, \", \" );\n    allocatorTemplates.clear();\n  }\n  return std::make_pair( allocatorTemplates, uniqueHandleAllocatorTemplates );\n}\n\nstd::string VulkanHppGenerator::generateArgumentListEnhanced( std::vector<ParamData> const &            params,\n                                                              std::vector<size_t> const &               returnParams,\n                                                              std::map<size_t, VectorParamData> const & vectorParams,\n                                                              std::set<size_t> const &                  skippedParams,\n                                                              std::set<size_t> const &                  singularParams,\n                                                              std::set<size_t> const &                  templatedParams,\n                                                              std::vector<size_t> const &               chainedReturnParams,\n                                                              bool                                      definition,\n                                                              CommandFlavourFlags                       flavourFlags,\n                                                              bool                                      withDispatcher ) const\n{\n  const bool   withAllocators    = flavourFlags & CommandFlavourFlagBits::withAllocator;\n  const size_t defaultStartIndex = withAllocators ? ~0 : determineDefaultStartIndex( params, skippedParams );\n\n  std::vector<std::string> arguments;\n  for ( size_t i = 0; i < params.size(); ++i )\n  {\n    if ( !skippedParams.contains( i ) )\n    {\n      bool hasDefaultAssignment = false;\n\n      std::string composedType = params[i].type.compose( \"VULKAN_HPP_NAMESPACE\" );\n\n      if ( singularParams.contains( i ) )\n      {\n        assert( !params[i].optional );\n        assert( params[i].type.isConstPointer() && !params[i].lenExpression.empty() && !isLenByStructMember( params[i].lenExpression, params ) &&\n                params[i].type.type.starts_with( \"Vk\" ) );\n        assert( !isHandleType( params[i].type.type ) );\n        assert( composedType.ends_with( \" *\" ) );\n        arguments.push_back( stripPostfix( composedType, \" *\" ) + \" & \" + stripPluralS( startLowerCase( stripPrefix( params[i].name, \"p\" ) ) ) );\n      }\n      else if ( params[i].type.isConstPointer() )\n      {\n        assert( composedType.ends_with( \" *\" ) );\n        std::string name = startLowerCase( stripPrefix( params[i].name, \"p\" ) );\n        if ( params[i].lenExpression.empty() )\n        {\n          assert( withDispatcher || !isHandleType( params[i].type.type ) );\n          assert( !params[i].type.prefix.empty() && ( params[i].type.postfix == \"*\" ) );\n          assert( params[i].arraySizes.empty() );\n          if ( params[i].type.type == \"void\" )\n          {\n            arguments.push_back( templatedParams.contains( i ) ? ( stripPrefix( params[i].name, \"p\" ) + \"Type const & \" + name )\n                                                               : ( composedType + \" \" + params[i].name ) );\n          }\n          else if ( params[i].optional )\n          {\n            arguments.push_back( \"Optional<\" + stripPostfix( composedType, \" *\" ) + \"> \" + name +\n                                 ( ( definition || withAllocators ) ? \"\" : \" VULKAN_HPP_DEFAULT_ARGUMENT_NULLPTR_ASSIGNMENT\" ) );\n            hasDefaultAssignment = true;\n          }\n          else\n          {\n            arguments.push_back( stripPostfix( composedType, \" *\" ) + \" & \" + name );\n          }\n        }\n        else\n        {\n          // a const-pointer with a non-empty len is either null-terminated (aka a string) or represented by an\n          // ArrayProxy\n          assert( params[i].arraySizes.empty() );\n          if ( params[i].lenExpression == \"null-terminated\" )\n          {\n            assert( params[i].type.type == \"char\" );\n            if ( params[i].optional )\n            {\n              arguments.push_back( \"Optional<const std::string> \" + name +\n                                   ( ( definition || withAllocators ) ? \"\" : \" VULKAN_HPP_DEFAULT_ARGUMENT_NULLPTR_ASSIGNMENT\" ) );\n              hasDefaultAssignment = true;\n            }\n            else\n            {\n              arguments.push_back( \"const std::string & \" + name );\n            }\n          }\n          else\n          {\n            // an ArrayProxy also covers no data, so any optional flag can be ignored here\n            std::string  type = stripPostfix( composedType, \" *\" );\n            const size_t pos  = type.find( \"void\" );\n            if ( pos != std::string::npos )\n            {\n              type.replace( pos, 4, stripPrefix( params[i].name, \"p\" ) + \"Type\" );\n            }\n            arguments.push_back( std::string( \"VULKAN_HPP_NAMESPACE::\" ) + ( params[i].strideParam.first.empty() ? \"\" : \"Strided\" ) + \"ArrayProxy<\" + type +\n                                 \"> const & \" + name );\n            if ( params[i].optional && !definition )\n            {\n              assert( params[i].strideParam.first.empty() );\n              arguments.back() += \" VULKAN_HPP_DEFAULT_ARGUMENT_NULLPTR_ASSIGNMENT\";\n              hasDefaultAssignment = true;\n            }\n          }\n        }\n      }\n      else if ( params[i].type.isNonConstPointer() )\n      {\n        if ( ( params[i].type.type == \"void\" ) && ( flavourFlags & CommandFlavourFlagBits::keepVoidPtr ) )\n        {\n          arguments.push_back( composedType + \" \" );\n        }\n        else\n        {\n          assert( withDispatcher || !isHandleType( params[i].type.type ) );\n          assert( params[i].lenExpression.empty() && !params[i].optional );\n          assert( composedType.ends_with( \" *\" ) );\n          arguments.push_back( stripPostfix( composedType, \" *\" ) + \" & \" );\n        }\n        arguments.back() += params[i].name;\n      }\n      else\n      {\n        assert( params[i].type.isValue() );\n        // parameters named \"objectType\" collide with the member variable -> append an _ to here\n        std::string paramName = ( definition && ( params[i].name == \"objectType\" ) ) ? \"objectType_\" : params[i].name;\n        arguments.push_back( composedType + \" \" + paramName + generateCArraySizes( params[i].arraySizes ) );\n      }\n      arguments.back() += std::string( !definition && ( defaultStartIndex <= i ) && !hasDefaultAssignment ? \" VULKAN_HPP_DEFAULT_ARGUMENT_ASSIGNMENT\" : \"\" );\n    }\n  }\n  if ( withAllocators )\n  {\n    if ( ( flavourFlags & CommandFlavourFlagBits::chained ) && needsStructureChainResize( vectorParams, chainedReturnParams ) )\n    {\n      arguments.push_back( \"StructureChainAllocator & structureChainAllocator\" );\n    }\n    else\n    {\n      for ( auto sp : skippedParams )\n      {\n        if ( !params[sp].lenExpression.empty() )\n        {\n          std::string type;\n          if ( templatedParams.contains( sp ) )\n          {\n            auto vectorParamIt = vectorParams.find( sp );\n            if ( ( vectorParamIt != vectorParams.end() ) &&\n                 std::any_of( returnParams.begin(), returnParams.end(), [&vectorParamIt]( size_t rp ) noexcept { return rp == vectorParamIt->first; } ) &&\n                 std::any_of(\n                   returnParams.begin(), returnParams.end(), [&vectorParamIt]( size_t rp ) noexcept { return rp == vectorParamIt->second.lenParam; } ) )\n            {\n              type = \"Uint8_t\";\n            }\n            else\n            {\n              type = stripPrefix( params[sp].name, \"p\" ) + \"Type\";\n            }\n          }\n          else\n          {\n            type = ( params[sp].type.type == \"void\" ) ? \"Uint8_t\" : startUpperCase( stripPrefix( params[sp].type.type, \"Vk\" ) );\n          }\n          arguments.push_back( type + \"Allocator & \" + startLowerCase( type ) + \"Allocator\" );\n        }\n        else if ( vectorParams.contains( sp ) && vectorParams.find( sp )->second.byStructure )\n        {\n          std::string type = stripPrefix( vectorMemberByStructure( params[sp].type.type ).type.type, \"Vk\" );\n          assert( isupper( type[0] ) );\n          arguments.push_back( type + \"Allocator & \" + startLowerCase( type ) + \"Allocator\" );\n        }\n      }\n    }\n  }\n  if ( withDispatcher )\n  {\n    arguments.push_back( std::string( \"Dispatch const & d\" ) + ( definition ? \"\" : \" VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT\" ) );\n  }\n  return generateList( arguments, \"\", \", \" );\n}\n\nstd::string VulkanHppGenerator::generateArgumentListStandard( std::vector<ParamData> const & params,\n                                                              std::set<size_t> const &       skippedParams,\n                                                              bool                           definition,\n                                                              bool                           withDispatcher ) const\n{\n  std::string argumentList;\n  for ( size_t i = 0; i < params.size(); ++i )\n  {\n    if ( !skippedParams.contains( i ) )\n    {\n      // parameters named \"objectType\" collide with the member variable -> append an _ to here\n      std::string paramName = ( definition && ( params[i].name == \"objectType\" ) ) ? \"objectType_\" : params[i].name;\n      argumentList += params[i].type.compose( \"VULKAN_HPP_NAMESPACE\" ) + \" \" + paramName + generateCArraySizes( params[i].arraySizes ) + \", \";\n    }\n  }\n  if ( withDispatcher )\n  {\n    argumentList += \"Dispatch const & d \";\n  }\n  else if ( !argumentList.empty() )\n  {\n    assert( argumentList.ends_with( \", \" ) );\n    argumentList = stripPostfix( argumentList, \", \" ) + \" \";\n  }\n  return argumentList;\n}\n\nstd::string VulkanHppGenerator::generateArgumentTemplates( std::vector<ParamData> const &            params,\n                                                           std::vector<size_t> const &               returnParams,\n                                                           std::map<size_t, VectorParamData> const & vectorParams,\n                                                           std::set<size_t> const &                  templatedParams,\n                                                           std::vector<size_t> const &               chainedReturnParams,\n                                                           bool                                      raii ) const\n{\n  std::string argumentTemplates;\n  if ( !chainedReturnParams.empty() )\n  {\n    assert( chainedReturnParams.size() == 1 );\n    argumentTemplates = vectorParams.contains( chainedReturnParams[0] ) ? \"typename StructureChain, \" : \"typename X, typename Y, typename... Z, \";\n  }\n  if ( !templatedParams.empty() )\n  {\n    for ( auto t : templatedParams )\n    {\n      assert( params[t].name.starts_with( \"p\" ) );\n      auto vectorParamIt = vectorParams.find( t );\n      if ( ( vectorParamIt == vectorParams.end() ) ||\n           std::none_of( returnParams.begin(), returnParams.end(), [&vectorParamIt]( size_t rp ) noexcept { return rp == vectorParamIt->first; } ) ||\n           std::none_of( returnParams.begin(), returnParams.end(), [&vectorParamIt]( size_t rp ) noexcept { return rp == vectorParamIt->second.lenParam; } ) )\n      {\n        assert( chainedReturnParams.empty() );\n        // only templated parameters that are not part of an enumeration are really templated\n        argumentTemplates += \"typename \" + stripPrefix( params[t].name, \"p\" ) + \"Type, \";\n      }\n    }\n  }\n  if ( !argumentTemplates.empty() && raii )\n  {\n    argumentTemplates = \"template <\" + stripPostfix( argumentTemplates, \", \" ) + \">\";\n  }\n  return argumentTemplates;\n}\n\nstd::string VulkanHppGenerator::generateBaseTypes() const\n{\n  assert( !m_baseTypes.empty() );\n  const std::string basetypesTemplate = R\"(\n  //==================\n  //=== BASE TYPEs ===\n  //==================\n\n${basetypes}\n)\";\n\n  std::string basetypes;\n  for ( auto const & baseType : m_baseTypes )\n  {\n    // filter out VkFlags and VkFlags64, as they are mapped to our own Flags class, and basetypes without any type information\n    if ( ( baseType.first != \"VkFlags\" ) && ( baseType.first != \"VkFlags64\" ) && !baseType.second.typeInfo.type.empty() )\n    {\n      basetypes += \"  using \" + stripPrefix( baseType.first, \"Vk\" ) + \" = \" + baseType.second.typeInfo.compose( \"VULKAN_HPP_NAMESPACE\" ) + \";\\n\";\n    }\n  }\n\n  return replaceWithMap( basetypesTemplate, { { \"basetypes\", basetypes } } );\n}\n\nstd::string VulkanHppGenerator::generateBitmask( std::map<std::string, BitmaskData>::const_iterator bitmaskIt, std::string const & surroundingProtect ) const\n{\n  auto bitmaskBitsIt = m_enums.find( bitmaskIt->second.require );\n  assert( bitmaskBitsIt != m_enums.end() );\n\n  std::string bitmaskName = stripPrefix( bitmaskIt->first, \"Vk\" );\n  std::string enumName    = stripPrefix( bitmaskBitsIt->first, \"Vk\" );\n\n  std::string allFlags;\n  if ( bitmaskBitsIt->second.values.empty() ||\n       std::none_of( bitmaskBitsIt->second.values.begin(), bitmaskBitsIt->second.values.end(), []( auto const & evd ) { return evd.supported; } ) )\n  {\n    allFlags = \" {};\";\n  }\n  else\n  {\n    bool        encounteredFlag = false;\n    std::string previousEnter, previousLeave;\n    for ( auto const & value : bitmaskBitsIt->second.values )\n    {\n      if ( value.supported )\n      {\n        // if the value's protect differs from the surrounding protect, generate protection code\n        std::string enter, leave;\n        if ( !value.protect.empty() && ( value.protect != surroundingProtect ) )\n        {\n          tie( enter, leave ) = generateProtection( value.protect );\n        }\n        std::string valueName = generateEnumValueName( bitmaskBitsIt->first, value.name, true );\n        allFlags += ( ( previousEnter != enter ) ? ( \"\\n\" + previousLeave + enter ) : \"\\n\" ) + \"        \" + ( encounteredFlag ? \"| \" : \"  \" ) + enumName +\n                    \"::\" + valueName;\n        encounteredFlag = true;\n        previousEnter   = enter;\n        previousLeave   = leave;\n      }\n    }\n    if ( !previousLeave.empty() )\n    {\n      allFlags += \"\\n\" + previousLeave;\n    }\n    allFlags += \";\";\n  }\n\n  std::string aliases;\n  for ( auto const & a : bitmaskIt->second.aliases )\n  {\n    aliases += \"  using \" + stripPrefix( a.first, \"Vk\" ) + \" = \" + bitmaskName + \";\\n\";\n  }\n\n  static const std::string bitmaskTemplate = R\"(\n  using ${bitmaskName} = Flags<${enumName}>;\n${aliases}\n\n  template <> struct FlagTraits<${enumName}>\n  {\n    static VULKAN_HPP_CONST_OR_CONSTEXPR bool isBitmask = true;\n    static VULKAN_HPP_CONST_OR_CONSTEXPR ${bitmaskName} allFlags = ${allFlags}\n  };\n)\";\n\n  return replaceWithMap( bitmaskTemplate, { { \"aliases\", aliases }, { \"allFlags\", allFlags }, { \"bitmaskName\", bitmaskName }, { \"enumName\", enumName } } );\n}\n\nstd::string VulkanHppGenerator::generateBitmasksToString() const\n{\n  const std::string bitmasksToStringTemplate = R\"(\n  //==========================\n  //=== BITMASKs to_string ===\n  //==========================\n\n${bitmasksToString}\n)\";\n\n  std::string           bitmasksToString;\n  std::set<std::string> listedBitmasks;\n  for ( auto const & feature : m_features )\n  {\n    bitmasksToString += generateBitmasksToString( feature.requireData, listedBitmasks, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    bitmasksToString += generateBitmasksToString( extension.requireData, listedBitmasks, extension.name );\n  }\n\n  return replaceWithMap( bitmasksToStringTemplate, { { \"bitmasksToString\", bitmasksToString } } );\n}\n\nstd::string VulkanHppGenerator::generateBitmasksToString( std::vector<RequireData> const & requireData,\n                                                          std::set<std::string> &          listedBitmasks,\n                                                          std::string const &              title ) const\n{\n  std::string str;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & type : require.types )\n    {\n      auto bitmaskIt = m_bitmasks.find( type.name );\n      if ( ( bitmaskIt != m_bitmasks.end() ) && !listedBitmasks.contains( type.name ) )\n      {\n        listedBitmasks.insert( type.name );\n        str += generateBitmaskToString( bitmaskIt );\n      }\n    }\n  }\n  return addTitleAndProtection( title, str );\n}\n\nstd::string VulkanHppGenerator::generateBitmaskToString( std::map<std::string, BitmaskData>::const_iterator bitmaskIt ) const\n{\n  auto bitmaskBitsIt = m_enums.find( bitmaskIt->second.require );\n  assert( bitmaskBitsIt != m_enums.end() );\n\n  std::string bitmaskName = stripPrefix( bitmaskIt->first, \"Vk\" );\n  std::string enumName    = stripPrefix( bitmaskBitsIt->first, \"Vk\" );\n\n  std::string str;\n  if ( bitmaskBitsIt->second.values.empty() ||\n       std::none_of( bitmaskBitsIt->second.values.begin(), bitmaskBitsIt->second.values.end(), []( auto const & evd ) { return evd.supported; } ) )\n  {\n    static std::string bitmaskToStringTemplate = R\"(\n  VULKAN_HPP_INLINE std::string to_string( ${bitmaskName} )\n  {\n    return \"{}\";\n  }\n)\";\n    str += replaceWithMap( bitmaskToStringTemplate, { { \"bitmaskName\", bitmaskName } } );\n  }\n  else\n  {\n    static const std::string bitmaskToStringTemplate = R\"(\n  VULKAN_HPP_INLINE std::string to_string( ${bitmaskName} value )\n  {\n    if ( !value )\n      return \"${emptyValue}\";\n\n    std::string result;\n${toStringChecks}\n    return \"{ \" + result.substr( 0, result.size() - 3 ) + \" }\";\n  }\n)\";\n\n    std::string emptyValue = \"{}\";\n    std::string toStringChecks;\n    std::string previousEnter, previousLeave;\n    for ( auto const & value : bitmaskBitsIt->second.values )\n    {\n      if ( value.supported )\n      {\n        std::string valueName = generateEnumValueName( bitmaskBitsIt->first, value.name, true );\n        if ( value.value == \"0\" )\n        {\n          assert( emptyValue == \"{}\" );\n          emptyValue = valueName.substr( 1 );\n        }\n        else if ( !value.bitpos.empty() )\n        {\n          const auto [enter, leave] = generateProtection( value.protect );\n          toStringChecks += ( ( previousEnter != enter ) ? ( previousLeave + enter ) : \"\" ) + \"    if ( value & \" + enumName + \"::\" + valueName +\n                            \" ) result += \\\"\" + valueName.substr( 1 ) + \" | \\\";\\n\";\n          previousEnter = enter;\n          previousLeave = leave;\n        }\n      }\n    }\n    if ( !previousLeave.empty() )\n    {\n      assert( previousLeave.ends_with( \"\\n\" ) );\n      toStringChecks += previousLeave;\n      previousLeave.resize( previousLeave.size() - strlen( \"\\n\" ) );\n    }\n\n    str += replaceWithMap( bitmaskToStringTemplate, { { \"bitmaskName\", bitmaskName }, { \"emptyValue\", emptyValue }, { \"toStringChecks\", toStringChecks } } );\n  }\n\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateCallArgumentsEnhanced( CommandData const &      commandData,\n                                                               size_t                   initialSkipCount,\n                                                               bool                     nonConstPointerAsNullptr,\n                                                               std::set<size_t> const & singularParams,\n                                                               std::set<size_t> const & templatedParams,\n                                                               bool                     raii,\n                                                               bool                     raiiFactory,\n                                                               CommandFlavourFlags      flavourFlags ) const\n{\n  assert( initialSkipCount <= commandData.params.size() );\n  std::vector<std::string> arguments;\n  if ( raii )\n  {\n    switch ( initialSkipCount )\n    {\n      case 0: break;\n      case 1:\n        assert( isHandleType( commandData.params[0].type.type ) && commandData.params[0].type.isValue() );\n        assert( commandData.params[0].arraySizes.empty() && commandData.params[0].lenExpression.empty() );\n        assert( commandData.params[0].type.type == commandData.handle );\n        arguments.push_back( \"static_cast<\" + commandData.handle + \">( m_\" + startLowerCase( stripPrefix( commandData.handle, \"Vk\" ) ) + \" )\" );\n        break;\n      case 2:\n        {\n          assert( isHandleType( commandData.params[0].type.type ) && commandData.params[0].type.isValue() );\n          assert( commandData.params[0].arraySizes.empty() && commandData.params[0].lenExpression.empty() );\n          assert( commandData.params[0].type.type == commandData.handle );\n          auto handleIt = m_handles.find( commandData.params[1].type.type );\n          assert( handleIt != m_handles.end() );\n          arguments.push_back( \"static_cast<\" + commandData.handle + \">( m_\" + startLowerCase( stripPrefix( commandData.handle, \"Vk\" ) ) + \" )\" );\n\n          assert( commandData.params[1].type.isValue() && commandData.params[1].arraySizes.empty() && commandData.params[1].lenExpression.empty() );\n          arguments.push_back( \"static_cast<\" + commandData.params[1].type.type + \">( m_\" +\n                               generateRAIIHandleConstructorParamName( handleIt->first, handleIt->second.destructorIt ) + \" )\" );\n        }\n        break;\n      default: assert( false ); break;\n    }\n  }\n  else\n  {\n    for ( size_t i = 0; i < initialSkipCount; ++i )\n    {\n      assert( isHandleType( commandData.params[i].type.type ) && commandData.params[i].type.isValue() );\n      assert( commandData.params[i].arraySizes.empty() && commandData.params[i].lenExpression.empty() );\n      arguments.push_back( \"m_\" + startLowerCase( stripPrefix( commandData.params[i].type.type, \"Vk\" ) ) );\n    }\n  }\n  for ( size_t i = initialSkipCount; i < commandData.params.size(); ++i )\n  {\n    arguments.push_back(\n      generateCallArgumentEnhanced( commandData.params, i, nonConstPointerAsNullptr, singularParams, templatedParams, flavourFlags, raiiFactory ) );\n  }\n  return generateList( arguments, \"\", \", \" );\n}\n\nstd::string VulkanHppGenerator::generateCallArgumentsStandard( std::vector<ParamData> const & params, size_t initialSkipCount ) const\n{\n  std::vector<std::string> arguments;\n  for ( size_t i = 0; i < initialSkipCount; ++i )\n  {\n    auto const & param = params[i];\n    assert( isHandleType( param.type.type ) && param.type.isValue() );\n    assert( param.arraySizes.empty() && param.lenExpression.empty() );\n    arguments.push_back( \"static_cast<\" + param.type.type + \">( m_\" + startLowerCase( stripPrefix( param.type.type, \"Vk\" ) ) + \" )\" );\n  }\n  for ( size_t i = initialSkipCount; i < params.size(); ++i )\n  {\n    auto const & param    = params[i];\n    std::string  argument = param.name;\n    if ( param.type.type.starts_with( \"Vk\" ) )\n    {\n      if ( !param.arraySizes.empty() )\n      {\n        assert( param.arraySizes.size() == 1 );\n        assert( param.type.isValue() );\n        assert( param.type.postfix.empty() );\n        argument = \"reinterpret_cast<\" + param.type.compose( \"\" ) + \" *>( \" + argument + \" )\";\n      }\n      else if ( param.type.isValue() )\n      {\n        // parameters named \"objectType\" collide with the member variable -> append an _ to here\n        if ( argument == \"objectType\" )\n        {\n          argument += \"_\";\n        }\n        argument = \"static_cast<\" + param.type.type + \">( \" + argument + \" )\";\n      }\n      else\n      {\n        assert( !param.type.postfix.empty() );\n        argument = \"reinterpret_cast<\" + param.type.compose( \"\" ) + \">( \" + argument + \" )\";\n      }\n    }\n    arguments.push_back( argument );\n  }\n  return generateList( arguments, \"\", \", \" );\n}\n\nstd::string VulkanHppGenerator::generateCallArgumentEnhanced( std::vector<ParamData> const & params,\n                                                              size_t                         paramIndex,\n                                                              bool                           nonConstPointerAsNullptr,\n                                                              std::set<size_t> const &       singularParams,\n                                                              std::set<size_t> const &       templatedParams,\n                                                              CommandFlavourFlags            flavourFlags,\n                                                              bool                           raiiFactory ) const\n{\n  std::string       argument;\n  ParamData const & param = params[paramIndex];\n  if ( param.type.isConstPointer() || specialPointerTypes.contains( param.type.type ) )\n  {\n    // parameter is a const-pointer or one of the special pointer types that are considered to be const-pointers\n    argument = generateCallArgumentEnhancedConstPointer( param, paramIndex, singularParams, templatedParams );\n  }\n  else if ( param.type.isNonConstPointer() && !specialPointerTypes.contains( param.type.type ) &&\n            !( ( param.type.type == \"void\" ) && ( flavourFlags & CommandFlavourFlagBits::keepVoidPtr ) ) )\n  {\n    // parameter is a non-const pointer, none of the special pointer types, that are considered const-pointers, and no void-ptr to keep\n    argument = generateCallArgumentEnhancedNonConstPointer( param, paramIndex, nonConstPointerAsNullptr, singularParams );\n  }\n  else\n  {\n    argument = generateCallArgumentEnhancedValue( params, paramIndex, singularParams, flavourFlags, raiiFactory );\n  }\n  assert( !argument.empty() );\n  return argument;\n}\n\nstd::string VulkanHppGenerator::generateCallArgumentEnhancedConstPointer( ParamData const &        param,\n                                                                          size_t                   paramIndex,\n                                                                          std::set<size_t> const & singularParams,\n                                                                          std::set<size_t> const & templatedParams ) const\n{\n  std::string argument;\n  std::string name = startLowerCase( stripPrefix( param.name, \"p\" ) );\n  if ( isHandleType( param.type.type ) && param.type.isValue() )\n  {\n    assert( !param.optional );\n    // if at all, this is the first argument, and it's the implicitly provided member handle\n    assert( paramIndex == 0 );\n    assert( param.arraySizes.empty() && param.lenExpression.empty() );\n    argument = \"m_\" + startLowerCase( stripPrefix( param.type.type, \"Vk\" ) );\n  }\n  else if ( param.lenExpression.empty() )\n  {\n    // this const-pointer parameter has no length, that is it's a const-pointer to a single value\n    if ( param.type.type == \"void\" )\n    {\n      argument =\n        templatedParams.contains( paramIndex ) ? \"reinterpret_cast<\" + param.type.compose( \"VULKAN_HPP_NAMESPACE\" ) + \">( &\" + name + \" )\" : param.name;\n    }\n    else if ( param.optional )\n    {\n      argument = \"static_cast<\" + param.type.compose( \"VULKAN_HPP_NAMESPACE\" ) + \">( \" + name + \" )\";\n    }\n    else\n    {\n      argument = \"&\" + name;\n    }\n    if ( param.type.type.starts_with( \"Vk\" ) )\n    {\n      argument = \"reinterpret_cast<\" + param.type.compose( \"\" ) + \">( \" + argument + \" )\";\n    }\n  }\n  else if ( param.lenExpression == \"null-terminated\" )\n  {\n    // this const-pointer parameter is \"null-terminated\", that is it's a string\n    assert( ( param.type.type == \"char\" ) && param.arraySizes.empty() );\n    if ( param.optional )\n    {\n      argument = name + \" ? \" + name + \"->c_str() : nullptr\";\n    }\n    else\n    {\n      argument = name + \".c_str()\";\n    }\n  }\n  else\n  {\n    // this const-pointer parameter has some explicit length\n    if ( singularParams.contains( paramIndex ) )\n    {\n      assert( !param.optional );\n      argument = \"&\" + stripPluralS( name );\n    }\n    else\n    {\n      // this const-parameter is represented by some array, where data() also works with no data (optional)\n      argument = name + \".data()\";\n    }\n    if ( param.type.type.starts_with( \"Vk\" ) || ( param.type.type == \"void\" ) )\n    {\n      argument = \"reinterpret_cast<\" + param.type.compose( \"\" ) + \">( \" + argument + \" )\";\n    }\n  }\n  return argument;\n}\n\nstd::string VulkanHppGenerator::generateCallArgumentEnhancedNonConstPointer( ParamData const &        param,\n                                                                             size_t                   paramIndex,\n                                                                             bool                     nonConstPointerAsNullptr,\n                                                                             std::set<size_t> const & singularParams ) const\n{\n  std::string argument;\n  std::string name = startLowerCase( stripPrefix( param.name, \"p\" ) );\n  if ( param.lenExpression.empty() || ( param.lenExpression == \"1\" ) )\n  {\n    assert( param.arraySizes.empty() );\n    if ( param.type.type.starts_with( \"Vk\" ) )\n    {\n      argument = \"reinterpret_cast<\" + param.type.compose( \"\" ) + \">( &\" + name + \" )\";\n    }\n    else\n    {\n      assert( !param.optional );\n      argument = \"&\" + name;\n    }\n  }\n  else\n  {\n    // the non-const pointer has a lenExpression -> it will be represented by some array\n    assert( param.arraySizes.empty() );\n    if ( nonConstPointerAsNullptr )\n    {\n      argument = \"nullptr\";\n    }\n    else\n    {\n      if ( singularParams.contains( paramIndex ) )\n      {\n        argument = \"&\" + stripPluralS( name );\n      }\n      else\n      {\n        // get the data of the array, which also covers no data -> no need to look at param.optional\n        argument = name + \".data()\";\n      }\n      if ( param.type.type.starts_with( \"Vk\" ) || ( param.type.type == \"void\" ) )\n      {\n        argument = \"reinterpret_cast<\" + param.type.compose( \"\" ) + \">( \" + argument + \" )\";\n      }\n    }\n  }\n  return argument;\n}\n\nstd::string VulkanHppGenerator::generateCallArgumentEnhancedValue(\n  std::vector<ParamData> const & params, size_t paramIndex, std::set<size_t> const & singularParams, CommandFlavourFlags flavourFlags, bool raiiFactory ) const\n{\n  std::string       argument;\n  ParamData const & param = params[paramIndex];\n  assert( ( flavourFlags & CommandFlavourFlagBits::keepVoidPtr ) || param.lenExpression.empty() );  // !keepVoidPtr -> no lenExpression\n  if ( param.type.type.starts_with( \"Vk\" ) )\n  {\n    if ( param.arraySizes.empty() )\n    {\n      // check if this param is used as the len of an other param\n      auto pointerIt = std::find_if( params.begin(), params.end(), [&param]( ParamData const & pd ) { return pd.lenExpression == param.name; } );\n      if ( pointerIt != params.end() )\n      {\n        assert( !param.optional );\n        argument = startLowerCase( stripPrefix( pointerIt->name, \"p\" ) ) + \".size()\";\n        if ( pointerIt->type.type == \"void\" )\n        {\n          argument += \" * sizeof( \" + stripPrefix( pointerIt->name, \"p\" ) + \"Type )\";\n        }\n      }\n      else if ( raiiFactory && m_handles.contains( param.type.type ) )\n      {\n        assert( param.type.isValue() && param.lenExpression.empty() );\n        if ( param.optional )\n        {\n          argument = param.name + \" ? static_cast<\" + param.type.type + \">( **\" + param.name + \" ) : 0\";\n        }\n        else\n        {\n          argument = \"static_cast<\" + param.type.type + \">( *\" + param.name + \" )\";\n        }\n      }\n      else\n      {\n        assert( param.type.isValue() );\n        // parameters named \"objectType\" collide with the member variable -> append an _ to here\n        std::string paramName = ( param.name == \"objectType\" ) ? \"objectType_\" : param.name;\n        argument              = \"static_cast<\" + param.type.type + \">( \" + paramName + \" )\";\n      }\n      // check if this param is used as the stride of an other param\n      assert( std::none_of( params.begin(), params.end(), [paramIndex]( ParamData const & pd ) { return pd.strideParam.second == paramIndex; } ) );\n    }\n    else\n    {\n      assert( !param.optional );\n      assert( param.arraySizes.size() == 1 );\n      assert( param.type.prefix == \"const\" );\n      argument = \"reinterpret_cast<\" + param.type.compose( \"\" ) + \" *>( \" + param.name + \" )\";\n    }\n  }\n  else\n  {\n    auto pointerIt = std::find_if( params.begin(), params.end(), [&param]( ParamData const & pd ) { return pd.lenExpression == param.name; } );\n    if ( ( pointerIt != params.end() ) && !( ( pointerIt->type.type == \"void\" ) && ( flavourFlags & CommandFlavourFlagBits::keepVoidPtr ) ) )\n    {\n      // this parameter is the len of some other -> replace it with that parameter's size\n      assert( param.arraySizes.empty() );\n      assert( ( param.type.type == \"size_t\" ) || ( param.type.type == \"uint32_t\" ) );\n      if ( singularParams.contains( paramIndex ) )\n      {\n        if ( pointerIt->type.type == \"void\" )\n        {\n          argument = \"sizeof( \" + stripPrefix( pointerIt->name, \"p\" ) + \"Type )\";\n        }\n        else\n        {\n          argument = \"1\";\n        }\n      }\n      else\n      {\n        argument = startLowerCase( stripPrefix( pointerIt->name, \"p\" ) ) + \".size()\";\n        if ( pointerIt->type.type == \"void\" )\n        {\n          argument += \" * sizeof( \" + stripPrefix( pointerIt->name, \"p\" ) + \"Type )\";\n        }\n      }\n    }\n    else\n    {\n      assert( !param.optional );\n      assert( param.arraySizes.size() <= 1 );\n      pointerIt = std::find_if( params.begin(), params.end(), [paramIndex]( ParamData const & pd ) { return pd.strideParam.second == paramIndex; } );\n      if ( pointerIt != params.end() )\n      {\n        // this parameter is the stride of some other -> replace it with that parameter's stride\n        assert( param.arraySizes.empty() );\n        assert( param.type.type == \"uint32_t\" );\n        assert( pointerIt->strideParam.first == param.name );\n        argument = startLowerCase( stripPrefix( pointerIt->name, \"p\" ) ) + \".stride()\";\n      }\n      else\n      {\n        argument = param.name;\n      }\n    }\n  }\n  return argument;\n}\n\nstd::string VulkanHppGenerator::generateCallSequence( std::string const &                       name,\n                                                      CommandData const &                       commandData,\n                                                      std::vector<size_t> const &               returnParams,\n                                                      std::map<size_t, VectorParamData> const & vectorParams,\n                                                      size_t                                    initialSkipCount,\n                                                      std::set<size_t> const &                  singularParams,\n                                                      std::set<size_t> const &                  templatedParams,\n                                                      std::vector<size_t> const &               chainedReturnParams,\n                                                      CommandFlavourFlags                       flavourFlags,\n                                                      bool                                      raii,\n                                                      bool                                      raiiFactory ) const\n{\n  std::string dispatcher = raii ? \"getDispatcher()->\" : \"d.\";\n\n  // first some special handling on vkCreatePipelineBinariesKHR !!\n  if ( name == \"vkCreatePipelineBinariesKHR\" )\n  {\n#if !defined( NDEBUG )\n    auto paramIt = std::find_if( commandData.params.begin(), commandData.params.end(), []( ParamData const & pd ) { return pd.name == \"pCreateInfo\"; } );\n    assert( paramIt != commandData.params.end() && ( paramIt->type.type == \"VkPipelineBinaryCreateInfoKHR\" ) );\n    auto structIt = m_structs.find( \"VkPipelineBinaryCreateInfoKHR\" );\n    assert( ( structIt != m_structs.end() ) &&\n            std::any_of( structIt->second.members.begin(), structIt->second.members.end(), []( MemberData const & md ) { return md.name == \"pipeline\"; } ) &&\n            std::any_of(\n              structIt->second.members.begin(), structIt->second.members.end(), []( MemberData const & md ) { return md.name == \"pPipelineCreateInfo\"; } ) );\n    auto memberIt =\n      std::find_if( structIt->second.members.begin(), structIt->second.members.end(), []( MemberData const & md ) { return md.name == \"pKeysAndDataInfo\"; } );\n    assert( memberIt != structIt->second.members.end() && ( memberIt->type.type == \"VkPipelineBinaryKeysAndDataKHR\" ) );\n    structIt = m_structs.find( \"VkPipelineBinaryKeysAndDataKHR\" );\n    assert( ( structIt != m_structs.end() ) &&\n            std::any_of( structIt->second.members.begin(), structIt->second.members.end(), []( MemberData const & md ) { return md.name == \"binaryCount\"; } ) );\n    structIt = m_structs.find( \"VkPipelineBinaryHandlesInfoKHR\" );\n    assert(\n      ( structIt != m_structs.end() ) &&\n      std::any_of(\n        structIt->second.members.begin(), structIt->second.members.end(), []( MemberData const & md ) { return md.name == \"pipelineBinaryCount\"; } ) &&\n      std::any_of( structIt->second.members.begin(), structIt->second.members.end(), []( MemberData const & md ) { return md.name == \"pPipelineBinaries\"; } ) );\n#endif\n\n    const std::string callSequenceTemplate = R\"(    VULKAN_HPP_NAMESPACE::Result result;\n    if ( createInfo.pKeysAndDataInfo )\n    {\n      VULKAN_HPP_ASSERT( !createInfo.pipeline && !createInfo.pPipelineCreateInfo );\n      pipelineBinaries.resize( createInfo.pKeysAndDataInfo->binaryCount );\n      binaries.pipelineBinaryCount = createInfo.pKeysAndDataInfo->binaryCount;\n      binaries.pPipelineBinaries = pipelineBinaries.data();\n      result = static_cast<VULKAN_HPP_NAMESPACE::Result>( ${dispatcher}${vkCommand}( ${callArguments} ) );\n    }\n    else\n    {\n      VULKAN_HPP_ASSERT( !createInfo.pipeline ^ !createInfo.pPipelineCreateInfo );\n      result = static_cast<VULKAN_HPP_NAMESPACE::Result>( ${dispatcher}${vkCommand}( ${callArguments} ) );\n      if ( result == VULKAN_HPP_NAMESPACE::Result::eSuccess )\n      {\n        pipelineBinaries.resize( binaries.pipelineBinaryCount );\n        binaries.pPipelineBinaries = pipelineBinaries.data();\n        result = static_cast<VULKAN_HPP_NAMESPACE::Result>( ${dispatcher}${vkCommand}( ${callArguments} ) );\n      }\n    }\n)\";\n\n    std::string callArguments =\n      generateCallArgumentsEnhanced( commandData, initialSkipCount, false, singularParams, templatedParams, raii, raiiFactory, flavourFlags );\n\n    return replaceWithMap( callSequenceTemplate, { { \"callArguments\", callArguments }, { \"dispatcher\", dispatcher }, { \"vkCommand\", name } } );\n  }\n\n  // if at least one returnParam is a size value of a vector param (and no singular params), we need two calls\n  if ( singularParams.empty() &&\n       std::any_of( returnParams.begin(),\n                    returnParams.end(),\n                    [&vectorParams]( size_t rp )\n                    { return std::any_of( vectorParams.begin(), vectorParams.end(), [rp]( auto const & vp ) { return vp.second.lenParam == rp; } ); } ) )\n  {\n    auto vectorParamIt = vectorParams.begin();\n    assert( std::any_of( returnParams.begin(), returnParams.end(), [&vectorParamIt]( size_t rp ) noexcept { return rp == vectorParamIt->first; } ) );\n    assert( std::any_of( returnParams.begin(), returnParams.end(), [&vectorParamIt]( size_t rp ) noexcept { return rp == vectorParamIt->second.lenParam; } ) );\n\n    std::string firstCallArguments = generateCallArgumentsEnhanced( commandData, initialSkipCount, true, {}, templatedParams, raii, raiiFactory, flavourFlags );\n    std::string secondCallArguments =\n      generateCallArgumentsEnhanced( commandData, initialSkipCount, false, {}, templatedParams, raii, raiiFactory, flavourFlags );\n    std::string vectorName, vectorSize;\n    if ( vectorParamIt->second.byStructure )\n    {\n      auto structIt = m_structs.find( commandData.params[vectorParamIt->first].type.type );\n      assert( structIt != m_structs.end() );\n      vectorName = structIt->second.members.back().name;\n      vectorSize = startLowerCase( stripPrefix( commandData.params[vectorParamIt->first].name, \"p\" ) ) + \".\" +\n                   structIt->second.members[vectorParamIt->second.lenParam].name;\n    }\n    else\n    {\n      vectorName = commandData.params[vectorParamIt->first].name;\n      vectorSize = startLowerCase( stripPrefix( commandData.params[vectorParamIt->second.lenParam].name, \"p\" ) );\n    }\n    vectorName = startLowerCase( stripPrefix( vectorName, \"p\" ) );\n\n    if ( ( flavourFlags & CommandFlavourFlagBits::chained ) && needsStructureChainResize( vectorParams, chainedReturnParams ) )\n    {\n      assert( vectorParams.size() == 1 );\n      // chained data needs some more handling!!\n      std::string vectorElementType = stripPostfix( commandData.params[vectorParamIt->first].type.compose( \"VULKAN_HPP_NAMESPACE\" ), \" *\" );\n\n      if ( commandData.returnType == \"VkResult\" )\n      {\n        const std::string callSequenceTemplate = R\"(VULKAN_HPP_NAMESPACE::Result result;\n    do\n    {\n      result = static_cast<VULKAN_HPP_NAMESPACE::Result>( ${dispatcher}${vkCommand}( ${firstCallArguments} ) );\n      if ( ( result == VULKAN_HPP_NAMESPACE::Result::eSuccess ) && ${counterName} )\n      {\n        structureChains.resize( ${counterName} );\n        ${vectorName}.resize( ${counterName} );\n        for ( ${counterType} i = 0; i < ${counterName}; i++ )\n        {\n          ${vectorName}[i].pNext = structureChains[i].template get<${vectorElementType}>().pNext;\n        }\n        result = static_cast<VULKAN_HPP_NAMESPACE::Result>( ${dispatcher}${vkCommand}( ${secondCallArguments} ) );\n      }\n    } while ( result == VULKAN_HPP_NAMESPACE::Result::eIncomplete );)\";\n\n        return replaceWithMap( callSequenceTemplate,\n                               { { \"counterName\", startLowerCase( stripPrefix( commandData.params[vectorParamIt->second.lenParam].name, \"p\" ) ) },\n                                 { \"counterType\", commandData.params[vectorParamIt->second.lenParam].type.type },\n                                 { \"dispatcher\", dispatcher },\n                                 { \"firstCallArguments\", firstCallArguments },\n                                 { \"secondCallArguments\", secondCallArguments },\n                                 { \"vectorElementType\", vectorElementType },\n                                 { \"vectorName\", vectorName },\n                                 { \"vkCommand\", name } } );\n      }\n      else\n      {\n        const std::string callSequenceTemplate =\n          R\"(${dispatcher}${vkCommand}( ${firstCallArguments} );\n    structureChains.resize( ${counterName} );\n    ${vectorName}.resize( ${counterName} );\n    for ( ${counterType} i = 0; i < ${counterName}; i++ )\n    {\n      ${vectorName}[i].pNext = structureChains[i].template get<${vectorElementType}>().pNext;\n    }\n    ${dispatcher}${vkCommand}( ${secondCallArguments} );)\";\n\n        return replaceWithMap( callSequenceTemplate,\n                               { { \"counterName\", startLowerCase( stripPrefix( commandData.params[vectorParamIt->second.lenParam].name, \"p\" ) ) },\n                                 { \"counterType\", commandData.params[vectorParamIt->second.lenParam].type.type },\n                                 { \"dispatcher\", dispatcher },\n                                 { \"firstCallArguments\", firstCallArguments },\n                                 { \"secondCallArguments\", secondCallArguments },\n                                 { \"vectorElementType\", vectorElementType },\n                                 { \"vectorName\", vectorName },\n                                 { \"vkCommand\", name } } );\n      }\n    }\n    else if ( commandData.returnType == \"VkResult\" )\n    {\n      std::string resizes;\n      for ( auto const & vp : vectorParams )\n      {\n        assert( std::any_of( returnParams.begin(), returnParams.end(), [&vp]( size_t rp ) { return rp == vp.first; } ) &&\n                std::any_of( returnParams.begin(), returnParams.end(), [&vp]( size_t rp ) { return rp == vp.second.lenParam; } ) );\n        resizes += startLowerCase( stripPrefix( commandData.params[vp.first].name, \"p\" ) ) + \".resize( \" +\n                   startLowerCase( stripPrefix( commandData.params[vp.second.lenParam].name, \"p\" ) ) + \" );\\n\";\n      }\n      resizes.pop_back();\n\n      switch ( commandData.successCodes.size() )\n      {\n        case 1:\n          assert( commandData.successCodes[0] == \"VK_SUCCESS\" );\n          if ( commandData.errorCodes.empty() )\n          {\n            std::string const callSequenceTemplate = R\"(${dispatcher}${vkCommand}( ${firstCallArguments} );\n      ${resizes}\n      ${dispatcher}${vkCommand}( ${secondCallArguments} );\n)\";\n\n            return replaceWithMap( callSequenceTemplate,\n                                   { { \"dispatcher\", dispatcher },\n                                     { \"firstCallArguments\", firstCallArguments },\n                                     { \"secondCallArguments\", secondCallArguments },\n                                     { \"resizes\", resizes },\n                                     { \"vkCommand\", name } } );\n          }\n          else\n          {\n            std::string const callSequenceTemplate =\n              R\"(VULKAN_HPP_NAMESPACE::Result result = static_cast<VULKAN_HPP_NAMESPACE::Result>( ${dispatcher}${vkCommand}( ${firstCallArguments} ) );\n      if ( result == VULKAN_HPP_NAMESPACE::Result::eSuccess )\n      {\n        ${resizes}\n        result = static_cast<VULKAN_HPP_NAMESPACE::Result>( ${dispatcher}${vkCommand}( ${secondCallArguments} ) );\n      }\n)\";\n\n            return replaceWithMap( callSequenceTemplate,\n                                   { { \"dispatcher\", dispatcher },\n                                     { \"firstCallArguments\", firstCallArguments },\n                                     { \"secondCallArguments\", secondCallArguments },\n                                     { \"resizes\", resizes },\n                                     { \"vkCommand\", name } } );\n          }\n        case 2:\n        case 3:\n          {\n            assert( ( commandData.successCodes[0] == \"VK_SUCCESS\" ) && ( commandData.successCodes[1] == \"VK_INCOMPLETE\" ) );\n            std::string const callSequenceTemplate = R\"(VULKAN_HPP_NAMESPACE::Result result;\n    do\n    {\n      result = static_cast<VULKAN_HPP_NAMESPACE::Result>( ${dispatcher}${vkCommand}( ${firstCallArguments} ) );\n      if ( ( result == VULKAN_HPP_NAMESPACE::Result::eSuccess ) && ${counterName} )\n      {\n        ${resizes}\n        result = static_cast<VULKAN_HPP_NAMESPACE::Result>( ${dispatcher}${vkCommand}( ${secondCallArguments} ) );\n      }\n    } while ( result == VULKAN_HPP_NAMESPACE::Result::eIncomplete );)\";\n\n            return replaceWithMap( callSequenceTemplate,\n                                   { { \"counterName\", startLowerCase( stripPrefix( commandData.params[vectorParamIt->second.lenParam].name, \"p\" ) ) },\n                                     { \"dispatcher\", dispatcher },\n                                     { \"firstCallArguments\", firstCallArguments },\n                                     { \"secondCallArguments\", secondCallArguments },\n                                     { \"resizes\", resizes },\n                                     { \"vkCommand\", name } } );\n          }\n        default: assert( false ); return \"\";\n      }\n    }\n    else\n    {\n      std::string resizeInstructions;\n      if ( vectorParamIt->second.byStructure )\n      {\n        std::string const resizeInstructionTemplate = R\"(${vectorName}.resize( ${vectorSize} );\n    ${structName}.${pointerName} = ${vectorName}.data();)\";\n\n        resizeInstructions = replaceWithMap( resizeInstructionTemplate,\n                                             { { \"pointerName\", \"p\" + startUpperCase( vectorName ) },\n                                               { \"structName\", startLowerCase( stripPrefix( commandData.params[vectorParamIt->first].name, \"p\" ) ) },\n                                               { \"vectorName\", vectorName },\n                                               { \"vectorSize\", vectorSize } } );\n      }\n      else\n      {\n        std::string const resizeInstructionTemplate = R\"(${vectorName}.resize( ${vectorSize} );)\";\n        resizeInstructions = replaceWithMap( resizeInstructionTemplate, { { \"vectorName\", vectorName }, { \"vectorSize\", vectorSize } } );\n      }\n\n      // no need to enumerate here, just two calls\n      assert( commandData.returnType == \"void\" );\n      std::string const callSequenceTemplate = R\"(${dispatcher}${vkCommand}( ${firstCallArguments} );\n    ${resizeInstructions}\n    ${dispatcher}${vkCommand}( ${secondCallArguments} );)\";\n\n      return replaceWithMap( callSequenceTemplate,\n                             { { \"dispatcher\", dispatcher },\n                               { \"firstCallArguments\", firstCallArguments },\n                               { \"resizeInstructions\", resizeInstructions },\n                               { \"secondCallArguments\", secondCallArguments },\n                               { \"vkCommand\", name } } );\n    }\n  }\n  else if ( ( commandData.returnType == \"VkResult\" ) && ( ( 1 < commandData.successCodes.size() ) || !commandData.errorCodes.empty() ) )\n  {\n    std::string const callSequenceTemplate =\n      R\"(VULKAN_HPP_NAMESPACE::Result result = static_cast<VULKAN_HPP_NAMESPACE::Result>( ${dispatcher}${vkCommand}( ${callArguments} ) );)\";\n\n    std::string callArguments =\n      generateCallArgumentsEnhanced( commandData, initialSkipCount, false, singularParams, templatedParams, raii, raiiFactory, flavourFlags );\n\n    return replaceWithMap( callSequenceTemplate, { { \"callArguments\", callArguments }, { \"dispatcher\", dispatcher }, { \"vkCommand\", name } } );\n  }\n  else\n  {\n    std::string const callSequenceTemplate = R\"(${resultAssignment}${dispatcher}${vkCommand}( ${callArguments} );)\";\n\n    std::string callArguments =\n      generateCallArgumentsEnhanced( commandData, initialSkipCount, false, singularParams, templatedParams, raii, raiiFactory, flavourFlags );\n    std::string resultAssignment = generateResultAssignment( commandData );\n\n    return replaceWithMap(\n      callSequenceTemplate,\n      { { \"callArguments\", callArguments }, { \"dispatcher\", dispatcher }, { \"resultAssignment\", resultAssignment }, { \"vkCommand\", name } } );\n  }\n}\n\nstd::string\n  VulkanHppGenerator::generateCommand( std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  std::string cmd;\n  if ( commandData.returnType == \"VkResult\" )\n  {\n    cmd = generateCommandResult( name, commandData, initialSkipCount, definition, raii );\n  }\n  else if ( commandData.returnType == \"void\" )\n  {\n    cmd = generateCommandVoid( name, commandData, initialSkipCount, definition, raii );\n  }\n  else\n  {\n    cmd = generateCommandValue( name, commandData, initialSkipCount, definition, raii );\n  }\n\n  if ( cmd.empty() )\n  {\n    throw std::runtime_error( \"Never encountered a function like <\" + name + \"> !\" );\n  }\n\n  return cmd;\n}\n\nstd::string VulkanHppGenerator::generateCommandDefinitions() const\n{\n  const std::string commandDefinitionsTemplate = R\"(\n  //===========================\n  //=== COMMAND Definitions ===\n  //===========================\n\n${commandDefinitions}\n)\";\n\n  std::string           commandDefinitions;\n  std::set<std::string> listedCommands;  // some commands are listed with more than one extension!\n  for ( auto const & feature : m_features )\n  {\n    commandDefinitions += generateCommandDefinitions( feature.requireData, listedCommands, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    commandDefinitions += generateCommandDefinitions( extension.requireData, listedCommands, extension.name );\n  }\n\n  return replaceWithMap( commandDefinitionsTemplate, { { \"commandDefinitions\", commandDefinitions } } );\n}\n\nstd::string VulkanHppGenerator::generateCommandDefinitions( std::vector<RequireData> const & requireData,\n                                                            std::set<std::string> &          listedCommands,\n                                                            std::string const &              title ) const\n{\n  std::string str;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & command : require.commands )\n    {\n      if ( listedCommands.insert( command.name ).second )\n      {\n        auto commandIt = findByNameOrAlias( m_commands, command.name );\n        assert( commandIt != m_commands.end() );\n        str += generateCommandDefinitions( command.name, commandIt->second.handle );\n      }\n    }\n  }\n  return addTitleAndProtection( title, str );\n}\n\nstd::string VulkanHppGenerator::generateCommandDefinitions( std::string const & command, std::string const & handle ) const\n{\n  auto commandIt = findByNameOrAlias( m_commands, command );\n  assert( commandIt != m_commands.end() );\n\n  std::string str = \"\\n\" + generateCommand( command, commandIt->second, handle.empty() ? 0 : 1, true, false );\n\n  // special handling for destroy functions, filter out alias functions\n  std::string commandName = generateCommandName( command, commandIt->second.params, 1 );\n  if ( ( command == commandIt->first ) && ( ( ( command.substr( 2, 7 ) == \"Destroy\" ) && ( commandName != \"destroy\" ) ) ||\n                                            ( command.substr( 2, 4 ) == \"Free\" ) || ( command == \"vkReleasePerformanceConfigurationINTEL\" ) ) )\n  {\n    CommandData specialCommandData = commandIt->second;\n    assert( ( 1 < specialCommandData.params.size() ) && ( specialCommandData.params[0].type.type == handle ) );\n    specialCommandData.params[1].optional = false;  // make sure, the object to destroy/free/release is not optional in the shortened version!\n\n    std::string destroyCommandString = generateCommand( command, specialCommandData, handle.empty() ? 0 : 1, true, false );\n    std::string shortenedName;\n    if ( command.substr( 2, 7 ) == \"Destroy\" )\n    {\n      shortenedName = \"destroy\";\n    }\n    else if ( command.substr( 2, 4 ) == \"Free\" )\n    {\n      shortenedName = \"free\";\n    }\n    else\n    {\n      assert( command == \"vkReleasePerformanceConfigurationINTEL\" );\n      shortenedName = \"release\";\n    }\n    size_t pos = destroyCommandString.find( commandName );\n    while ( pos != std::string::npos )\n    {\n      destroyCommandString.replace( pos, commandName.length(), shortenedName );\n      pos = destroyCommandString.find( commandName, pos );\n    }\n\n    // special handling for \"free\", to prevent interfering with MSVC debug free!\n    if ( shortenedName == \"free\" )\n    {\n      std::string toEncloseString = stripPrefix( handle, \"Vk\" ) + \"::free\";\n      std::string enclosedString  = \"( \" + toEncloseString + \" )\";\n      pos                         = destroyCommandString.find( toEncloseString );\n      while ( pos != std::string::npos )\n      {\n        destroyCommandString.replace( pos, toEncloseString.length(), enclosedString );\n        pos = destroyCommandString.find( toEncloseString, pos + enclosedString.length() );\n      }\n    }\n\n    // we need to remove the default argument for the first argument, to prevent ambiguities!\n    assert( 1 < commandIt->second.params.size() );\n    pos = destroyCommandString.find( commandIt->second.params[1].name );  // skip the standard version of the function\n    assert( pos != std::string::npos );\n    pos = destroyCommandString.find( commandIt->second.params[1].name,\n                                     pos + 1 );  // get the argument to destroy in the advanced version\n    assert( pos != std::string::npos );\n    pos = destroyCommandString.find( \" VULKAN_HPP_DEFAULT_ARGUMENT_ASSIGNMENT\", pos );\n    if ( pos != std::string::npos )\n    {\n      destroyCommandString.erase( pos, strlen( \" VULKAN_HPP_DEFAULT_ARGUMENT_ASSIGNMENT\" ) );\n    }\n    str += \"\\n\" + destroyCommandString;\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateCommandEnhanced( std::string const &                       name,\n                                                         CommandData const &                       commandData,\n                                                         size_t                                    initialSkipCount,\n                                                         bool                                      definition,\n                                                         std::map<size_t, VectorParamData> const & vectorParams,\n                                                         std::vector<size_t> const &               returnParams,\n                                                         CommandFlavourFlags                       flavourFlags ) const\n{\n  const bool chained  = flavourFlags & CommandFlavourFlagBits::chained;\n  const bool singular = flavourFlags & CommandFlavourFlagBits::singular;\n\n  assert( vectorParams.empty() || ( vectorParams.begin()->second.lenParam != INVALID_INDEX ) );\n  assert( !singular || !returnParams.empty() );  // if singular is true, then there is at least one returnParam !\n\n  std::set<size_t> skippedParams = determineSkippedParams( commandData.params, initialSkipCount, vectorParams, returnParams, singular );\n  std::set<size_t> templatedParams =\n    ( flavourFlags & CommandFlavourFlagBits::keepVoidPtr ) ? std::set<size_t>() : determineVoidPointerParams( commandData.params );\n  std::vector<size_t> chainedReturnParams;\n  if ( chained )\n  {\n    chainedReturnParams = determineChainedReturnParams( commandData.params, returnParams );\n    assert( chainedReturnParams.size() == 1 );\n  }\n  std::set<size_t> singularParams = singular ? determineSingularParams( returnParams[0], vectorParams ) : std::set<size_t>();\n  std::pair<bool, std::map<size_t, std::vector<size_t>>> vectorSizeCheck =\n    needsVectorSizeCheck( commandData.params, vectorParams, returnParams, singularParams, skippedParams );\n  const bool enumerating = determineEnumeration( vectorParams, returnParams );\n\n  std::vector<std::string> dataTypes = determineDataTypes( commandData.params, vectorParams, returnParams, templatedParams );\n  std::string              dataType  = combineDataTypes( vectorParams, returnParams, enumerating, dataTypes, flavourFlags, false );\n\n  std::string argumentTemplates = generateArgumentTemplates( commandData.params, returnParams, vectorParams, templatedParams, chainedReturnParams, false );\n  auto [allocatorTemplates, uniqueHandleAllocatorTemplates] =\n    generateAllocatorTemplates( returnParams, dataTypes, vectorParams, chainedReturnParams, flavourFlags, definition );\n  std::string typenameCheck       = generateTypenameCheck( returnParams, vectorParams, chainedReturnParams, definition, dataTypes, flavourFlags );\n  std::string nodiscard           = generateNoDiscard( !returnParams.empty(), 1 < commandData.successCodes.size(), 1 < commandData.errorCodes.size() );\n  std::string returnType          = generateReturnType( returnParams, vectorParams, flavourFlags, false, dataTypes );\n  std::string decoratedReturnType = generateDecoratedReturnType( commandData, returnParams, vectorParams, flavourFlags, false, returnType );\n  std::string className           = initialSkipCount ? stripPrefix( commandData.params[initialSkipCount - 1].type.type, \"Vk\" ) : \"\";\n  std::string classSeparator      = commandData.handle.empty() ? \"\" : \"::\";\n  std::string commandName         = generateCommandName( name, commandData.params, initialSkipCount, flavourFlags );\n  std::string argumentList        = generateArgumentListEnhanced(\n    commandData.params, returnParams, vectorParams, skippedParams, singularParams, templatedParams, chainedReturnParams, definition, flavourFlags, true );\n  std::string constString    = commandData.handle.empty() ? \"\" : \" const\";\n  std::string noexceptString = generateNoExcept( commandData.errorCodes, returnParams, vectorParams, flavourFlags, vectorSizeCheck.first, false );\n\n  if ( definition )\n  {\n    std::string vectorSizeCheckString =\n      vectorSizeCheck.first ? generateVectorSizeCheck( name, commandData, initialSkipCount, vectorSizeCheck.second, skippedParams, false ) : \"\";\n    std::string returnVariable   = generateReturnVariable( commandData, returnParams, vectorParams, flavourFlags );\n    std::string dataDeclarations = generateDataDeclarations(\n      commandData, returnParams, vectorParams, templatedParams, flavourFlags, false, dataTypes, dataType, returnType, returnVariable );\n    std::string dataPreparation =\n      generateDataPreparation( commandData, initialSkipCount, returnParams, vectorParams, templatedParams, flavourFlags, enumerating, dataTypes );\n    std::string dataSizeChecks = generateDataSizeChecks( commandData, returnParams, dataTypes, vectorParams, templatedParams, singular );\n    std::string callSequence   = generateCallSequence(\n      name, commandData, returnParams, vectorParams, initialSkipCount, singularParams, templatedParams, chainedReturnParams, flavourFlags, false, false );\n    std::string resultCheck     = generateResultCheck( commandData, className, classSeparator, commandName, enumerating );\n    std::string returnStatement = generateReturnStatement( name,\n                                                           commandData,\n                                                           returnVariable,\n                                                           returnType,\n                                                           decoratedReturnType,\n                                                           dataType,\n                                                           initialSkipCount,\n                                                           returnParams.empty() ? INVALID_INDEX : returnParams[0],\n                                                           flavourFlags,\n                                                           enumerating,\n                                                           false );\n\n    std::string const functionTemplate =\n      R\"(  template <${argumentTemplates}${allocatorTemplates}typename Dispatch${uniqueHandleAllocatorTemplates}${typenameCheck}>\n  ${nodiscard}VULKAN_HPP_INLINE ${decoratedReturnType} ${className}${classSeparator}${commandName}( ${argumentList} )${const}${noexcept}\n  {\n    VULKAN_HPP_ASSERT( d.getVkHeaderVersion() == VK_HEADER_VERSION );\n#if (VULKAN_HPP_DISPATCH_LOADER_DYNAMIC == 1 )\n${functionPointerCheck}\n#endif\n${vectorSizeCheck}\n    ${dataSizeChecks}\n    ${dataDeclarations}\n    ${callSequence}\n    ${resultCheck}\n    ${dataPreparation}\n    ${returnStatement}\n  })\";\n\n    return replaceWithMap( functionTemplate,\n                           { { \"allocatorTemplates\", allocatorTemplates },\n                             { \"argumentList\", argumentList },\n                             { \"argumentTemplates\", argumentTemplates },\n                             { \"callSequence\", callSequence },\n                             { \"className\", className },\n                             { \"classSeparator\", classSeparator },\n                             { \"commandName\", commandName },\n                             { \"const\", constString },\n                             { \"dataDeclarations\", dataDeclarations },\n                             { \"dataPreparation\", dataPreparation },\n                             { \"dataSizeChecks\", dataSizeChecks },\n                             { \"decoratedReturnType\", decoratedReturnType },\n                             { \"functionPointerCheck\", generateFunctionPointerCheck( name, commandData.requiredBy, false ) },\n                             { \"nodiscard\", nodiscard },\n                             { \"noexcept\", noexceptString },\n                             { \"resultCheck\", resultCheck },\n                             { \"returnStatement\", returnStatement },\n                             { \"typenameCheck\", typenameCheck },\n                             { \"uniqueHandleAllocatorTemplates\", uniqueHandleAllocatorTemplates },\n                             { \"vectorSizeCheck\", vectorSizeCheckString } } );\n  }\n  else\n  {\n    std::string const functionTemplate =\n      R\"(    template <${argumentTemplates}${allocatorTemplates}typename Dispatch = VULKAN_HPP_DEFAULT_DISPATCHER_TYPE${uniqueHandleAllocatorTemplates}${typenameCheck}>\n    ${nodiscard}${decoratedReturnType} ${commandName}( ${argumentList} )${const}${noexcept};)\";\n\n    return replaceWithMap( functionTemplate,\n                           { { \"allocatorTemplates\", allocatorTemplates },\n                             { \"argumentList\", argumentList },\n                             { \"argumentTemplates\", argumentTemplates },\n                             { \"commandName\", commandName },\n                             { \"const\", commandData.handle.empty() ? \"\" : \" const\" },\n                             { \"decoratedReturnType\", decoratedReturnType },\n                             { \"nodiscard\", nodiscard },\n                             { \"noexcept\", noexceptString },\n                             { \"typenameCheck\", typenameCheck },\n                             { \"uniqueHandleAllocatorTemplates\", uniqueHandleAllocatorTemplates } } );\n  }\n}\n\nstd::string VulkanHppGenerator::generateCommandName( std::string const &            vulkanCommandName,\n                                                     std::vector<ParamData> const & params,\n                                                     size_t                         initialSkipCount,\n                                                     CommandFlavourFlags            flavourFlags ) const\n{\n  std::string commandName( startLowerCase( stripPrefix( vulkanCommandName, \"vk\" ) ) );\n  for ( size_t i = initialSkipCount - 1; i < initialSkipCount; --i )  // count down to zero, then wrap around and stop\n  {\n    std::string const & argumentType = params[i].type.type;\n    std::string         searchName   = stripPrefix( argumentType, \"Vk\" );\n    std::string         argumentTag  = findTag( argumentType );\n    if ( !argumentTag.empty() )\n    {\n      searchName = stripPostfix( searchName, argumentTag );\n    }\n    size_t pos = commandName.find( searchName );\n    if ( pos == std::string::npos )\n    {\n      searchName = startLowerCase( searchName );\n      pos        = commandName.find( searchName );\n    }\n    if ( pos != std::string::npos )\n    {\n      size_t len = searchName.length();\n      if ( commandName.find( searchName + \"s\" ) == pos )\n      {\n        // filter out any plural of the searchName as well!\n        ++len;\n      }\n      commandName.erase( pos, len );\n    }\n    else if ( ( searchName == \"commandBuffer\" ) && commandName.starts_with( \"cmd\" ) )\n    {\n      commandName.erase( 0, 3 );\n      pos = 0;\n    }\n    if ( pos == 0 )\n    {\n      commandName = startLowerCase( commandName );\n    }\n    std::string commandTag = findTag( commandName );\n    if ( !argumentTag.empty() && ( argumentTag == commandTag ) )\n    {\n      commandName = stripPostfix( commandName, argumentTag );\n    }\n  }\n  if ( flavourFlags & CommandFlavourFlagBits::singular )\n  {\n    commandName = stripPluralS( commandName );\n  }\n  if ( flavourFlags & CommandFlavourFlagBits::unique )\n  {\n    commandName += \"Unique\";\n  }\n  return commandName;\n}\n\nstd::string VulkanHppGenerator::generateCommandResult(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  assert( !commandData.successCodes.empty() );\n  if ( commandData.successCodes.size() == 1 )\n  {\n    return generateCommandResultSingleSuccess( name, commandData, initialSkipCount, definition, raii );\n  }\n  else if ( commandData.errorCodes.empty() )\n  {\n    return generateCommandResultMultiSuccessNoErrors( name, commandData, initialSkipCount, definition, raii );\n  }\n  else\n  {\n    return generateCommandResultMultiSuccessWithErrors( name, commandData, initialSkipCount, definition, raii );\n  }\n}\n\nstd::string VulkanHppGenerator::generateCommandResultMultiSuccessNoErrors(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  std::vector<size_t> returnParams = determineReturnParams( commandData.params );\n  switch ( returnParams.size() )\n  {\n    case 0:\n      {\n        std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n        if ( vectorParams.empty() )\n        {\n          std::vector<size_t> constPointerParams = determineConstPointerParams( commandData.params );\n          if ( constPointerParams.empty() )\n          {\n            return generateCommandSetExclusive( name, commandData, initialSkipCount, definition, raii );\n          }\n        }\n      }\n      break;\n    case 2:\n      if ( ( commandData.successCodes.size() == 2 ) && ( commandData.successCodes[0] == \"VK_SUCCESS\" ) && ( commandData.successCodes[1] == \"VK_INCOMPLETE\" ) )\n      {\n        if ( ( commandData.params[returnParams[0]].type.type == \"size_t\" ) || ( commandData.params[returnParams[0]].type.type == \"uint32_t\" ) )\n        {\n          if ( ( commandData.params[returnParams[1]].type.type != \"void\" ) && !isHandleType( commandData.params[returnParams[1]].type.type ) &&\n               !isStructureChainAnchor( commandData.params[returnParams[1]].type.type ) )\n          {\n            std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n            if ( vectorParams.size() == 1 )\n            {\n              if ( returnParams[0] == vectorParams.begin()->second.lenParam )\n              {\n                if ( returnParams[1] == vectorParams.begin()->first )\n                {\n                  return generateCommandSetInclusive( name,\n                                                      commandData,\n                                                      initialSkipCount,\n                                                      definition,\n                                                      returnParams,\n                                                      vectorParams,\n                                                      false,\n                                                      { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator },\n                                                      raii,\n                                                      false,\n                                                      { CommandFlavourFlagBits::enhanced } );\n                }\n              }\n            }\n          }\n        }\n      }\n      break;\n    default: break;\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultMultiSuccessWithErrors(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  std::vector<size_t> returnParams = determineReturnParams( commandData.params );\n  switch ( returnParams.size() )\n  {\n    case 0: return generateCommandResultWithErrors0Return( name, commandData, initialSkipCount, definition, raii );\n    case 1: return generateCommandResultMultiSuccessWithErrors1Return( name, commandData, initialSkipCount, definition, returnParams[0], raii );\n    case 2: return generateCommandResultMultiSuccessWithErrors2Return( name, commandData, initialSkipCount, definition, returnParams, raii );\n    case 3: return generateCommandResultMultiSuccessWithErrors3Return( name, commandData, initialSkipCount, definition, returnParams, raii );\n    default: break;\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultMultiSuccessWithErrors1Return(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const\n{\n  if ( commandData.params[returnParam].type.type == \"void\" )\n  {\n    std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n    if ( vectorParams.size() == 1 )\n    {\n      if ( returnParam == vectorParams.begin()->first )\n      {\n        if ( commandData.params[vectorParams.begin()->second.lenParam].type.isValue() )\n        {\n          return generateCommandSetInclusive( name,\n                                              commandData,\n                                              initialSkipCount,\n                                              definition,\n                                              { returnParam },\n                                              vectorParams,\n                                              false,\n                                              { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::singular },\n                                              raii,\n                                              false,\n                                              { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::singular } );\n        }\n      }\n    }\n  }\n  else if ( isHandleType( commandData.params[returnParam].type.type ) )\n  {\n    std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n    if ( vectorParams.size() == 2 )\n    {\n      if ( returnParam == std::next( vectorParams.begin() )->first )\n      {\n        if ( vectorParams.begin()->second.lenParam == std::next( vectorParams.begin() )->second.lenParam )\n        {\n          if ( commandData.params[vectorParams.begin()->second.lenParam].type.type == \"uint32_t\" )\n          {\n            if ( ( ( commandData.params[vectorParams.begin()->first].type.type != \"void\" ) &&\n                   !isHandleType( commandData.params[vectorParams.begin()->first].type.type ) ) )\n            {\n              return generateCommandSetInclusive( name,\n                                                  commandData,\n                                                  initialSkipCount,\n                                                  definition,\n                                                  { returnParam },\n                                                  vectorParams,\n                                                  true,\n                                                  { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator, CommandFlavourFlagBits::singular },\n                                                  raii,\n                                                  true,\n                                                  { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::singular } );\n            }\n          }\n        }\n      }\n    }\n  }\n  else if ( isHandleTypeByStructure( commandData.params[returnParam].type.type ) )\n  {\n    std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n    if ( vectorParams.size() == 1 )\n    {\n      return generateCommandSetInclusive( name,\n                                          commandData,\n                                          initialSkipCount,\n                                          definition,\n                                          { returnParam },\n                                          vectorParams,\n                                          true,\n                                          { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator },\n                                          raii,\n                                          true,\n                                          { CommandFlavourFlagBits::enhanced } );\n    }\n  }\n  else if ( isVectorByStructure( commandData.params[returnParam].type.type ) )\n  {\n    // vector by structure is too complex to be supported! Just generate the standard version\n    return generateCommandSetInclusive( name, commandData, initialSkipCount, definition, { returnParam }, {}, false, {}, raii, false, {} );\n  }\n  else\n  {\n    std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n    if ( vectorParams.empty() )\n    {\n      return generateCommandSetInclusive( name,\n                                          commandData,\n                                          initialSkipCount,\n                                          definition,\n                                          { returnParam },\n                                          vectorParams,\n                                          false,\n                                          { CommandFlavourFlagBits::enhanced },\n                                          raii,\n                                          false,\n                                          { CommandFlavourFlagBits::enhanced } );\n    }\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultMultiSuccessWithErrors2Return( std::string const &         name,\n                                                                                    CommandData const &         commandData,\n                                                                                    size_t                      initialSkipCount,\n                                                                                    bool                        definition,\n                                                                                    std::vector<size_t> const & returnParams,\n                                                                                    bool                        raii ) const\n{\n  if ( ( 2 <= commandData.successCodes.size() ) && ( commandData.successCodes[0] == \"VK_SUCCESS\" ) && ( commandData.successCodes[1] == \"VK_INCOMPLETE\" ) )\n  {\n    if ( ( commandData.params[returnParams[0]].type.type == \"size_t\" ) || ( commandData.params[returnParams[0]].type.type == \"uint32_t\" ) )\n    {\n      // needs some very special handling of \"vkGetSwapchainImagesKHR\" !!\n      if ( isHandleType( commandData.params[returnParams[1]].type.type ) && ( name != \"vkGetSwapchainImagesKHR\" ) )\n      {\n        std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n        if ( vectorParams.size() == 1 )\n        {\n          if ( returnParams[0] == vectorParams.begin()->second.lenParam )\n          {\n            if ( returnParams[1] == vectorParams.begin()->first )\n            {\n              return generateCommandSetInclusive( name,\n                                                  commandData,\n                                                  initialSkipCount,\n                                                  definition,\n                                                  returnParams,\n                                                  vectorParams,\n                                                  false,\n                                                  { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator },\n                                                  raii,\n                                                  true,\n                                                  { CommandFlavourFlagBits::enhanced } );\n            }\n          }\n        }\n      }\n      else if ( isStructureChainAnchor( commandData.params[returnParams[1]].type.type ) )\n      {\n        std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n        if ( vectorParams.size() == 1 )\n        {\n          if ( returnParams[0] == vectorParams.begin()->second.lenParam )\n          {\n            if ( returnParams[1] == vectorParams.begin()->first )\n            {\n              return generateCommandSetInclusive( name,\n                                                  commandData,\n                                                  initialSkipCount,\n                                                  definition,\n                                                  returnParams,\n                                                  vectorParams,\n                                                  false,\n                                                  { CommandFlavourFlagBits::enhanced,\n                                                    CommandFlavourFlagBits::withAllocator,\n                                                    CommandFlavourFlagBits::chained,\n                                                    CommandFlavourFlagBits::chained | CommandFlavourFlagBits::withAllocator },\n                                                  raii,\n                                                  false,\n                                                  { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::chained } );\n            }\n          }\n        }\n      }\n      else\n      {\n        std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n        if ( vectorParams.size() == 1 )\n        {\n          if ( returnParams[0] == vectorParams.begin()->second.lenParam )\n          {\n            if ( returnParams[1] == vectorParams.begin()->first )\n            {\n              return generateCommandSetInclusive( name,\n                                                  commandData,\n                                                  initialSkipCount,\n                                                  definition,\n                                                  returnParams,\n                                                  vectorParams,\n                                                  false,\n                                                  { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator },\n                                                  raii,\n                                                  false,\n                                                  { CommandFlavourFlagBits::enhanced } );\n            }\n          }\n        }\n      }\n    }\n    else if ( isStructureType( commandData.params[returnParams[0]].type.type ) )\n    {\n      // can't generate an enhanced version for such a complex command! Just use the standard version\n      return generateCommandStandard( name, commandData, initialSkipCount, definition );\n    }\n  }\n\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultMultiSuccessWithErrors3Return( std::string const &         name,\n                                                                                    CommandData const &         commandData,\n                                                                                    size_t                      initialSkipCount,\n                                                                                    bool                        definition,\n                                                                                    std::vector<size_t> const & returnParams,\n                                                                                    bool                        raii ) const\n{\n  std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n  switch ( vectorParams.size() )\n  {\n    case 1:\n      if ( ( commandData.params[returnParams[0]].type.type != \"void\" ) && !isHandleType( commandData.params[returnParams[0]].type.type ) )\n      {\n        if ( ( commandData.params[returnParams[1]].type.type == \"size_t\" ) || ( commandData.params[returnParams[1]].type.type == \"uint32_t\" ) )\n        {\n          if ( ( commandData.params[returnParams[2]].type.type == \"void\" ) ||\n               ( !isHandleType( commandData.params[returnParams[2]].type.type ) && !isStructureChainAnchor( commandData.params[returnParams[2]].type.type ) ) )\n          {\n            if ( returnParams[1] == vectorParams.begin()->second.lenParam )\n            {\n              if ( returnParams[2] == vectorParams.begin()->first )\n              {\n                std::vector<CommandFlavourFlags> flags     = { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator };\n                std::vector<CommandFlavourFlags> raiiFlags = { CommandFlavourFlagBits::enhanced };\n                if ( isStructureChainAnchor( commandData.params[returnParams[0]].type.type ) )\n                {\n                  flags.push_back( CommandFlavourFlagBits::chained );\n                  flags.push_back( CommandFlavourFlagBits::chained | CommandFlavourFlagBits::withAllocator );\n                  raiiFlags.push_back( CommandFlavourFlagBits::chained );\n                }\n                return generateCommandSetInclusive(\n                  name, commandData, initialSkipCount, definition, returnParams, vectorParams, false, flags, raii, false, raiiFlags );\n              }\n            }\n          }\n        }\n      }\n      break;\n    case 2:\n      if ( commandData.params[returnParams[0]].type.type == \"uint32_t\" )\n      {\n        if ( isStructureType( commandData.params[returnParams[1]].type.type ) && !isStructureChainAnchor( commandData.params[returnParams[1]].type.type ) )\n        {\n          if ( isStructureType( commandData.params[returnParams[2]].type.type ) && !isStructureChainAnchor( commandData.params[returnParams[2]].type.type ) )\n          {\n            if ( vectorParams.begin()->second.lenParam == std::next( vectorParams.begin() )->second.lenParam )\n            {\n              if ( returnParams[0] == vectorParams.begin()->second.lenParam )\n              {\n                if ( returnParams[1] == vectorParams.begin()->first )\n                {\n                  if ( returnParams[2] == std::next( vectorParams.begin() )->first )\n                  {\n                    return generateCommandSetInclusive( name,\n                                                        commandData,\n                                                        initialSkipCount,\n                                                        definition,\n                                                        returnParams,\n                                                        vectorParams,\n                                                        false,\n                                                        { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator },\n                                                        raii,\n                                                        false,\n                                                        { CommandFlavourFlagBits::enhanced } );\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      break;\n    default: assert( false ); break;\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultSingleSuccess(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  if ( commandData.errorCodes.empty() )\n  {\n    return generateCommandResultSingleSuccessNoErrors( name, commandData, initialSkipCount, definition, raii );\n  }\n  else\n  {\n    return generateCommandResultSingleSuccessWithErrors( name, commandData, initialSkipCount, definition, raii );\n  }\n}\n\nstd::string VulkanHppGenerator::generateCommandResultSingleSuccessNoErrors(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  std::vector<size_t> returnParams = determineReturnParams( commandData.params );\n  switch ( returnParams.size() )\n  {\n    case 0:\n      {\n        std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n        switch ( vectorParams.size() )\n        {\n          case 0:\n            if ( determineConstPointerParams( commandData.params ).empty() )\n            {\n              return generateCommandSetExclusive( name, commandData, initialSkipCount, definition, raii );\n            }\n            else\n            {\n              return generateCommandSetInclusive( name,\n                                                  commandData,\n                                                  initialSkipCount,\n                                                  definition,\n                                                  returnParams,\n                                                  vectorParams,\n                                                  false,\n                                                  { CommandFlavourFlagBits::enhanced },\n                                                  raii,\n                                                  false,\n                                                  { CommandFlavourFlagBits::enhanced } );\n            }\n            break;\n          case 1:\n            if ( !raii )\n            {\n              if ( commandData.params[vectorParams.begin()->second.lenParam].type.isValue() )\n              {\n                if ( isHandleType( commandData.params[vectorParams.begin()->first].type.type ) )\n                {\n                  return generateCommandSet( definition,\n                                             generateCommandStandard( name, commandData, initialSkipCount, definition ),\n                                             { generateCommandEnhanced( name, commandData, initialSkipCount, definition, vectorParams, {}, {} ) } );\n                }\n              }\n            }\n            break;\n          default: break;\n        }\n      }\n      break;\n    case 1:\n      {\n        std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n        if ( vectorParams.empty() )\n        {\n          if ( isStructureType( commandData.params[returnParams[0]].type.type ) && !isStructureChainAnchor( commandData.params[returnParams[0]].type.type ) )\n          {\n            return generateCommandSetInclusive( name,\n                                                commandData,\n                                                initialSkipCount,\n                                                definition,\n                                                returnParams,\n                                                vectorParams,\n                                                false,\n                                                { CommandFlavourFlagBits::enhanced },\n                                                raii,\n                                                false,\n                                                { CommandFlavourFlagBits::enhanced } );\n          }\n        }\n      }\n      break;\n    case 2:\n      if ( ( commandData.params[returnParams[0]].type.type == \"size_t\" ) || ( commandData.params[returnParams[0]].type.type == \"uint32_t\" ) )\n      {\n        if ( isStructureType( commandData.params[returnParams[1]].type.type ) && !isStructureChainAnchor( commandData.params[returnParams[1]].type.type ) )\n        {\n          std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n          if ( vectorParams.size() == 1 )\n          {\n            if ( returnParams[0] == vectorParams.begin()->second.lenParam )\n            {\n              if ( returnParams[1] == vectorParams.begin()->first )\n              {\n                return generateCommandSetInclusive( name,\n                                                    commandData,\n                                                    initialSkipCount,\n                                                    definition,\n                                                    returnParams,\n                                                    vectorParams,\n                                                    false,\n                                                    { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator },\n                                                    raii,\n                                                    false,\n                                                    { CommandFlavourFlagBits::enhanced } );\n              }\n            }\n          }\n        }\n      }\n      break;\n    default: break;\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultSingleSuccessWithErrors(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  std::vector<size_t> returnParams = determineReturnParams( commandData.params );\n  switch ( returnParams.size() )\n  {\n    case 0: return generateCommandResultWithErrors0Return( name, commandData, initialSkipCount, definition, raii );\n    case 1: return generateCommandResultSingleSuccessWithErrors1Return( name, commandData, initialSkipCount, definition, returnParams[0], raii );\n    case 2: return generateCommandResultSingleSuccessWithErrors2Return( name, commandData, initialSkipCount, definition, returnParams, raii );\n    case 3: return generateCommandResultSingleSuccessWithErrors3Return( name, commandData, initialSkipCount, definition, returnParams, raii );\n    default: break;\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultSingleSuccessWithErrors1Return(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const\n{\n  if ( commandData.params[returnParam].type.type == \"void\" )\n  {\n    return generateCommandResultSingleSuccessWithErrors1ReturnVoid( name, commandData, initialSkipCount, definition, returnParam, raii );\n  }\n  else if ( isHandleType( commandData.params[returnParam].type.type ) )\n  {\n    return generateCommandResultSingleSuccessWithErrors1ReturnHandle( name, commandData, initialSkipCount, definition, returnParam, raii );\n  }\n  else if ( isStructureChainAnchor( commandData.params[returnParam].type.type ) )\n  {\n    return generateCommandResultSingleSuccessWithErrors1ReturnChain( name, commandData, initialSkipCount, definition, returnParam, raii );\n  }\n  else\n  {\n    return generateCommandResultSingleSuccessWithErrors1ReturnValue( name, commandData, initialSkipCount, definition, returnParam, raii );\n  }\n}\n\nstd::string VulkanHppGenerator::generateCommandResultSingleSuccessWithErrors1ReturnChain(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const\n{\n  std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n  if ( vectorParams.empty() )\n  {\n    return generateCommandSetInclusive( name,\n                                        commandData,\n                                        initialSkipCount,\n                                        definition,\n                                        { returnParam },\n                                        vectorParams,\n                                        false,\n                                        { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::chained },\n                                        raii,\n                                        false,\n                                        { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::chained } );\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultSingleSuccessWithErrors1ReturnHandle(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const\n{\n  std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n  switch ( vectorParams.size() )\n  {\n    case 0:\n      return generateCommandSetInclusive( name,\n                                          commandData,\n                                          initialSkipCount,\n                                          definition,\n                                          { returnParam },\n                                          vectorParams,\n                                          true,\n                                          { CommandFlavourFlagBits::enhanced },\n                                          raii,\n                                          true,\n                                          { CommandFlavourFlagBits::enhanced } );\n    case 1:\n      if ( returnParam == vectorParams.begin()->first )\n      {\n        if ( isLenByStructMember( commandData.params[vectorParams.begin()->first].lenExpression, commandData.params[vectorParams.begin()->second.lenParam] ) )\n        {\n          return generateCommandSetInclusive( name,\n                                              commandData,\n                                              initialSkipCount,\n                                              definition,\n                                              { returnParam },\n                                              vectorParams,\n                                              true,\n                                              { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator },\n                                              raii,\n                                              true,\n                                              { CommandFlavourFlagBits::enhanced } );\n        }\n      }\n      break;\n    case 2:\n      if ( returnParam == std::next( vectorParams.begin() )->first )\n      {\n        if ( vectorParams.begin()->second.lenParam == std::next( vectorParams.begin() )->second.lenParam )\n        {\n          if ( commandData.params[vectorParams.begin()->second.lenParam].type.isValue() )\n          {\n            if ( ( commandData.params[vectorParams.begin()->first].type.type != \"void\" ) &&\n                 !isHandleType( commandData.params[vectorParams.begin()->first].type.type ) )\n            {\n              return generateCommandSetInclusive( name,\n                                                  commandData,\n                                                  initialSkipCount,\n                                                  definition,\n                                                  { returnParam },\n                                                  vectorParams,\n                                                  true,\n                                                  { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator, CommandFlavourFlagBits::singular },\n                                                  raii,\n                                                  true,\n                                                  { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::singular } );\n            }\n          }\n        }\n      }\n      break;\n    default: break;\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultSingleSuccessWithErrors1ReturnValue(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const\n{\n  std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n  switch ( vectorParams.size() )\n  {\n    case 0:\n      {\n        CommandFlavourFlags flavourFlags = CommandFlavourFlagBits::enhanced;\n        if ( name == \"vkGetMemoryHostPointerPropertiesEXT\" )\n        {\n          // special handling for this function: need to keep the void* argument as a void*!\n          flavourFlags |= CommandFlavourFlagBits::keepVoidPtr;\n        }\n        return generateCommandSetInclusive(\n          name, commandData, initialSkipCount, definition, { returnParam }, vectorParams, false, { flavourFlags }, raii, false, { flavourFlags } );\n      }\n    case 2:\n      if ( returnParam == std::next( vectorParams.begin() )->first )\n      {\n        if ( vectorParams.begin()->second.lenParam == std::next( vectorParams.begin() )->second.lenParam )\n        {\n          if ( commandData.params[vectorParams.begin()->second.lenParam].type.type == \"uint32_t\" )\n          {\n            if ( isStructureType( commandData.params[vectorParams.begin()->first].type.type ) &&\n                 !isStructureChainAnchor( commandData.params[vectorParams.begin()->first].type.type ) )\n            {\n              return generateCommandSetInclusive( name,\n                                                  commandData,\n                                                  initialSkipCount,\n                                                  definition,\n                                                  { returnParam },\n                                                  vectorParams,\n                                                  false,\n                                                  { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator, CommandFlavourFlagBits::singular },\n                                                  raii,\n                                                  false,\n                                                  { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::singular } );\n            }\n          }\n        }\n      }\n      break;\n    default: break;\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultSingleSuccessWithErrors1ReturnVoid(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const\n{\n  std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n  switch ( vectorParams.size() )\n  {\n    case 0:\n      return generateCommandSetInclusive( name,\n                                          commandData,\n                                          initialSkipCount,\n                                          definition,\n                                          { returnParam },\n                                          vectorParams,\n                                          false,\n                                          { CommandFlavourFlagBits::enhanced },\n                                          raii,\n                                          false,\n                                          { CommandFlavourFlagBits::enhanced } );\n    case 1:\n      if ( returnParam == vectorParams.begin()->first )\n      {\n        if ( commandData.params[vectorParams.begin()->second.lenParam].type.isValue() )\n        {\n          return generateCommandSetInclusive( name,\n                                              commandData,\n                                              initialSkipCount,\n                                              definition,\n                                              { returnParam },\n                                              vectorParams,\n                                              false,\n                                              { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::singular },\n                                              raii,\n                                              false,\n                                              { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::singular } );\n        }\n      }\n      break;\n    case 2:\n      if ( returnParam == std::next( vectorParams.begin() )->first )\n      {\n        if ( vectorParams.begin()->second.lenParam != std::next( vectorParams.begin() )->second.lenParam )\n        {\n          if ( commandData.params[vectorParams.begin()->second.lenParam].type.isValue() )\n          {\n            if ( isHandleType( commandData.params[vectorParams.begin()->first].type.type ) )\n            {\n              if ( commandData.params[std::next( vectorParams.begin() )->second.lenParam].type.isValue() )\n              {\n                return generateCommandSetInclusive( name,\n                                                    commandData,\n                                                    initialSkipCount,\n                                                    definition,\n                                                    { returnParam },\n                                                    vectorParams,\n                                                    false,\n                                                    { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::singular },\n                                                    raii,\n                                                    false,\n                                                    { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::singular } );\n              }\n            }\n          }\n        }\n      }\n      break;\n    default: break;\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultSingleSuccessWithErrors2Return( std::string const &         name,\n                                                                                     CommandData const &         commandData,\n                                                                                     size_t                      initialSkipCount,\n                                                                                     bool                        definition,\n                                                                                     std::vector<size_t> const & returnParams,\n                                                                                     bool                        raii ) const\n{\n  if ( ( commandData.params[returnParams[0]].type.type != \"void\" ) && !isHandleType( commandData.params[returnParams[0]].type.type ) &&\n       !isStructureChainAnchor( commandData.params[returnParams[0]].type.type ) )\n  {\n    if ( ( commandData.params[returnParams[1]].type.type != \"void\" ) && !isHandleType( commandData.params[returnParams[1]].type.type ) &&\n         !isStructureChainAnchor( commandData.params[returnParams[1]].type.type ) )\n    {\n      std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n      if ( vectorParams.size() == 2 )\n      {\n        if ( returnParams[0] == std::next( vectorParams.begin() )->first )\n        {\n          if ( !vectorParams.contains( returnParams[1] ) )\n          {\n            assert( ( returnParams[1] != vectorParams.begin()->second.lenParam ) && ( returnParams[1] != std::next( vectorParams.begin() )->second.lenParam ) );\n            if ( vectorParams.begin()->second.lenParam == std::next( vectorParams.begin() )->second.lenParam )\n            {\n              if ( commandData.params[vectorParams.begin()->second.lenParam].type.isValue() )\n              {\n                if ( isStructureType( commandData.params[vectorParams.begin()->first].type.type ) &&\n                     !isStructureChainAnchor( commandData.params[vectorParams.begin()->first].type.type ) )\n                {\n                  return generateCommandSetInclusive(\n                    name,\n                    commandData,\n                    initialSkipCount,\n                    definition,\n                    returnParams,\n                    vectorParams,\n                    false,\n                    { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator, CommandFlavourFlagBits::singular },\n                    raii,\n                    false,\n                    { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::singular } );\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultSingleSuccessWithErrors3Return( std::string const &         name,\n                                                                                     CommandData const &         commandData,\n                                                                                     size_t                      initialSkipCount,\n                                                                                     bool                        definition,\n                                                                                     std::vector<size_t> const & returnParams,\n                                                                                     bool                        raii ) const\n{\n  if ( isStructureType( commandData.params[returnParams[0]].type.type ) && !isStructureChainAnchor( commandData.params[returnParams[0]].type.type ) &&\n       commandData.params[returnParams[0]].lenParams.empty() && ( commandData.params[returnParams[1]].type.type == \"size_t\" ) &&\n       commandData.params[returnParams[1]].lenParams.empty() && ( commandData.params[returnParams[2]].type.type == \"void\" ) &&\n       ( commandData.params[returnParams[2]].lenExpression == commandData.params[returnParams[1]].name ) )\n  {\n    std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n    if ( vectorParams.size() == 1 )\n    {\n      if ( ( returnParams[2] == vectorParams.begin()->first ) && ( returnParams[1] == vectorParams.begin()->second.lenParam ) )\n      {\n        return generateCommandSetInclusive( name,\n                                            commandData,\n                                            initialSkipCount,\n                                            definition,\n                                            returnParams,\n                                            vectorParams,\n                                            false,\n                                            { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator },\n                                            raii,\n                                            false,\n                                            { CommandFlavourFlagBits::enhanced } );\n      }\n    }\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandResultWithErrors0Return(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n  if ( vectorParams.empty() && determineConstPointerParams( commandData.params ).empty() )\n  {\n    return generateCommandSetExclusive( name, commandData, initialSkipCount, definition, raii );\n  }\n  else if ( allVectorSizesSupported( commandData.params, vectorParams ) )\n  {\n    return generateCommandSetInclusive( name,\n                                        commandData,\n                                        initialSkipCount,\n                                        definition,\n                                        {},\n                                        vectorParams,\n                                        false,\n                                        { CommandFlavourFlagBits::enhanced },\n                                        raii,\n                                        false,\n                                        { CommandFlavourFlagBits::enhanced } );\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandSet( bool                             definition,\n                                                    std::string const &              standard,\n                                                    std::vector<std::string> const & enhanced,\n                                                    std::vector<std::string> const & unique ) const\n{\n  assert( unique.empty() || ( enhanced.size() == unique.size() ) );\n\n  std::string commandSet = \"\\n\" + standard;\n  if ( !enhanced.empty() )\n  {\n    std::string separator = definition ? \"\\n\" : \"\";\n    commandSet += separator + \"\\n#ifndef VULKAN_HPP_DISABLE_ENHANCED_MODE\\n\";\n    bool firstEnhanced = true;\n    for ( auto const & e : enhanced )\n    {\n      if ( !firstEnhanced )\n      {\n        commandSet += separator + \"\\n\";\n      }\n      firstEnhanced = false;\n      commandSet += e;\n    }\n    if ( !unique.empty() )\n    {\n      commandSet += separator + \"\\n#  ifndef VULKAN_HPP_NO_SMART_HANDLE\\n\";\n      bool firstUnique = true;\n      for ( auto const & u : unique )\n      {\n        if ( !firstUnique )\n        {\n          commandSet += separator + \"\\n\";\n        }\n        firstUnique = false;\n        commandSet += u;\n      }\n      commandSet += \"\\n#  endif /* VULKAN_HPP_NO_SMART_HANDLE */\";\n    }\n    commandSet += \"\\n#endif /* VULKAN_HPP_DISABLE_ENHANCED_MODE */\";\n  }\n  commandSet += \"\\n\";\n  return commandSet;\n}\n\nstd::string VulkanHppGenerator::generateCommandSet( std::string const & standard, std::string const & enhanced ) const\n{\n  const std::string commandTemplate = R\"(\n#ifdef VULKAN_HPP_DISABLE_ENHANCED_MODE\n${commandStandard}\n#else\n${commandEnhanced}\n#endif /*VULKAN_HPP_DISABLE_ENHANCED_MODE*/\n)\";\n\n  return replaceWithMap( commandTemplate, std::map<std::string, std::string>( { { \"commandEnhanced\", enhanced }, { \"commandStandard\", standard } } ) );\n}\n\nstd::string VulkanHppGenerator::generateCommandSetExclusive(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  if ( raii )\n  {\n    return generateRAIIHandleCommandEnhanced( name, commandData, initialSkipCount, {}, {}, definition );\n  }\n  else\n  {\n    return generateCommandSet( generateCommandStandard( name, commandData, initialSkipCount, definition ),\n                               generateCommandEnhanced( name, commandData, initialSkipCount, definition, {}, {}, {} ) );\n  }\n}\n\nstd::string VulkanHppGenerator::generateCommandSetInclusive( std::string const &                      name,\n                                                             CommandData const &                      commandData,\n                                                             size_t                                   initialSkipCount,\n                                                             bool                                     definition,\n                                                             std::vector<size_t>                      returnParams,\n                                                             std::map<size_t, VectorParamData>        vectorParams,\n                                                             bool                                     unique,\n                                                             std::vector<CommandFlavourFlags> const & flags,\n                                                             bool                                     raii,\n                                                             bool                                     raiiFactory,\n                                                             std::vector<CommandFlavourFlags> const & raiiFlags ) const\n{\n  static const std::vector<size_t>               emptyReturnParams;\n  static const std::map<size_t, VectorParamData> emptyVectorParams;\n  if ( raii )\n  {\n    std::string raiiCommands;\n    if ( raiiFlags.empty() )\n    {\n      // Functions without enhancements need to have a standard implementation\n      raiiCommands = generateRAIIHandleCommandStandard( name, commandData, initialSkipCount, definition );\n    }\n    else\n    {\n      for ( auto flag : raiiFlags )\n      {\n        const bool noReturn = flag & CommandFlavourFlagBits::noReturn;\n        assert( !noReturn || !raiiFactory );  // noReturn => !raiiFactory\n        raiiCommands += raiiFactory ? generateRAIIHandleCommandFactory( name, commandData, initialSkipCount, returnParams, vectorParams, definition, flag )\n                                    : generateRAIIHandleCommandEnhanced( name,\n                                                                         commandData,\n                                                                         initialSkipCount,\n                                                                         noReturn ? emptyReturnParams : returnParams,\n                                                                         noReturn ? emptyVectorParams : vectorParams,\n                                                                         definition,\n                                                                         flag );\n      }\n    }\n    return raiiCommands;\n  }\n  else\n  {\n    std::vector<std::string> enhancedCommands, uniqueCommands;\n    for ( auto flag : flags )\n    {\n      const bool noReturn = flag & CommandFlavourFlagBits::noReturn;\n      assert( !noReturn || !unique );  // noReturn => !unique\n      enhancedCommands.push_back( generateCommandEnhanced(\n        name, commandData, initialSkipCount, definition, noReturn ? emptyVectorParams : vectorParams, noReturn ? emptyReturnParams : returnParams, flag ) );\n      if ( unique )\n      {\n        uniqueCommands.push_back(\n          generateCommandEnhanced( name, commandData, initialSkipCount, definition, vectorParams, returnParams, flag | CommandFlavourFlagBits::unique ) );\n      }\n    }\n    return generateCommandSet( definition, generateCommandStandard( name, commandData, initialSkipCount, definition ), enhancedCommands, uniqueCommands );\n  }\n}\n\nstd::string\n  VulkanHppGenerator::generateCommandStandard( std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition ) const\n{\n  std::set<size_t> skippedParams = determineSkippedParams( commandData.params, initialSkipCount, {}, {}, false );\n\n  std::string argumentList = generateArgumentListStandard( commandData.params, skippedParams, definition, true );\n  std::string commandName  = generateCommandName( name, commandData.params, initialSkipCount );\n  std::string nodiscard    = ( 1 < commandData.successCodes.size() + commandData.errorCodes.size() ) ? \"VULKAN_HPP_NODISCARD \" : \"\";\n  std::string returnType   = stripPrefix( commandData.returnType, \"Vk\" );\n\n  if ( definition )\n  {\n    std::string functionBody = \"d.\" + name + \"( \" + generateCallArgumentsStandard( commandData.params, initialSkipCount ) + \" )\";\n    if ( commandData.returnType.starts_with( \"Vk\" ) )\n    {\n      functionBody = \"return static_cast<\" + returnType + \">( \" + functionBody + \" )\";\n    }\n    else if ( commandData.returnType != \"void\" )\n    {\n      functionBody = \"return \" + functionBody;\n    }\n\n    std::string const functionTemplate =\n      R\"(  template <typename Dispatch>\n  ${nodiscard}VULKAN_HPP_INLINE ${returnType} ${className}${classSeparator}${commandName}( ${argumentList} )${const} VULKAN_HPP_NOEXCEPT\n  {\n    VULKAN_HPP_ASSERT( d.getVkHeaderVersion() == VK_HEADER_VERSION );\n    ${functionBody};\n  })\";\n\n    return replaceWithMap( functionTemplate,\n                           { { \"argumentList\", argumentList },\n                             { \"className\", initialSkipCount ? stripPrefix( commandData.params[initialSkipCount - 1].type.type, \"Vk\" ) : \"\" },\n                             { \"classSeparator\", commandData.handle.empty() ? \"\" : \"::\" },\n                             { \"commandName\", commandName },\n                             { \"const\", commandData.handle.empty() ? \"\" : \" const\" },\n                             { \"functionBody\", functionBody },\n                             { \"nodiscard\", nodiscard },\n                             { \"returnType\", returnType } } );\n  }\n  else\n  {\n    std::string const functionTemplate =\n      R\"(    template <typename Dispatch = VULKAN_HPP_DEFAULT_DISPATCHER_TYPE>\n    ${nodiscard}${returnType} ${commandName}( ${argumentList} VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT )${const} VULKAN_HPP_NOEXCEPT;)\";\n\n    return replaceWithMap( functionTemplate,\n                           { { \"argumentList\", argumentList },\n                             { \"commandName\", commandName },\n                             { \"const\", commandData.handle.empty() ? \"\" : \" const\" },\n                             { \"nodiscard\", nodiscard },\n                             { \"returnType\", returnType } } );\n  }\n}\n\nstd::string VulkanHppGenerator::generateCommandVoid(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  std::vector<size_t> returnParams = determineReturnParams( commandData.params );\n  switch ( returnParams.size() )\n  {\n    case 0: return generateCommandVoid0Return( name, commandData, initialSkipCount, definition, raii );\n    case 1: return generateCommandVoid1Return( name, commandData, initialSkipCount, definition, returnParams[0], raii );\n    case 2: return generateCommandVoid2Return( name, commandData, initialSkipCount, definition, returnParams, raii );\n    default: break;\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandValue(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  std::vector<size_t> returnParams = determineReturnParams( commandData.params );\n  if ( returnParams.empty() )\n  {\n    std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n    if ( vectorParams.empty() )\n    {\n      if ( determineConstPointerParams( commandData.params ).empty() )\n      {\n        return generateCommandSetInclusive(\n          name, commandData, initialSkipCount, definition, {}, vectorParams, false, {}, raii, false, { CommandFlavourFlagBits::enhanced } );\n      }\n      else\n      {\n        return generateCommandSetInclusive( name,\n                                            commandData,\n                                            initialSkipCount,\n                                            definition,\n                                            {},\n                                            vectorParams,\n                                            false,\n                                            { CommandFlavourFlagBits::enhanced },\n                                            raii,\n                                            false,\n                                            { CommandFlavourFlagBits::enhanced } );\n      }\n    }\n    else if ( vectorParams.size() <= 1 )\n    {\n      if ( !raii )\n      {\n        return generateCommandSet( definition,\n                                   generateCommandStandard( name, commandData, initialSkipCount, definition ),\n                                   { generateCommandEnhanced( name, commandData, initialSkipCount, definition, vectorParams, returnParams, {} ) } );\n      }\n    }\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandVoid0Return(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const\n{\n  std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n  if ( vectorParams.empty() && determineConstPointerParams( commandData.params ).empty() )\n  {\n    return generateCommandSetInclusive(\n      name, commandData, initialSkipCount, definition, {}, vectorParams, false, {}, raii, false, { CommandFlavourFlagBits::enhanced } );\n  }\n  else if ( allVectorSizesSupported( commandData.params, vectorParams ) )\n  {\n    // All the vectorParams have a counter by value, of type \"uint32_t\", \"VkDeviceSize\", or \"VkSampleCountFlagBits\" (!)\n    return generateCommandSetInclusive( name,\n                                        commandData,\n                                        initialSkipCount,\n                                        definition,\n                                        {},\n                                        vectorParams,\n                                        false,\n                                        { CommandFlavourFlagBits::enhanced },\n                                        raii,\n                                        false,\n                                        { CommandFlavourFlagBits::enhanced } );\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandVoid1Return(\n  std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const\n{\n  std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n  if ( ( commandData.params[returnParam].type.type == \"void\" ) )\n  {\n    switch ( vectorParams.size() )\n    {\n      case 0:\n        return generateCommandSetInclusive( name,\n                                            commandData,\n                                            initialSkipCount,\n                                            definition,\n                                            { returnParam },\n                                            vectorParams,\n                                            false,\n                                            { CommandFlavourFlagBits::enhanced },\n                                            raii,\n                                            false,\n                                            { CommandFlavourFlagBits::enhanced } );\n      case 1:\n        if ( returnParam == vectorParams.begin()->first )\n        {\n          if ( name == stripPluralS( name ) )\n          {\n            std::vector<CommandFlavourFlags> flavourFlags;\n            if ( name == \"vkGetDescriptorEXT\" )\n            {\n              // special handling for this function: do not return the void*, but keep its argument as it is\n              flavourFlags.push_back( CommandFlavourFlagBits::noReturn | CommandFlavourFlagBits::keepVoidPtr );\n            }\n            flavourFlags.push_back( CommandFlavourFlagBits::singular );\n            return generateCommandSetInclusive(\n              name, commandData, initialSkipCount, definition, { returnParam }, vectorParams, false, flavourFlags, raii, false, flavourFlags );\n          }\n        }\n        break;\n      default: break;\n    }\n  }\n  else if ( isHandleType( commandData.params[returnParam].type.type ) )\n  {\n    if ( vectorParams.empty() )\n    {\n      return generateCommandSetInclusive( name,\n                                          commandData,\n                                          initialSkipCount,\n                                          definition,\n                                          { returnParam },\n                                          vectorParams,\n                                          false,\n                                          { CommandFlavourFlagBits::enhanced },\n                                          raii,\n                                          true,\n                                          { CommandFlavourFlagBits::enhanced } );\n    }\n  }\n  else if ( isStructureChainAnchor( commandData.params[returnParam].type.type ) )\n  {\n    if ( vectorParams.empty() )\n    {\n      return generateCommandSetInclusive( name,\n                                          commandData,\n                                          initialSkipCount,\n                                          definition,\n                                          { returnParam },\n                                          vectorParams,\n                                          false,\n                                          { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::chained },\n                                          raii,\n                                          false,\n                                          { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::chained } );\n    }\n  }\n  else\n  {\n    switch ( vectorParams.size() )\n    {\n      case 0:\n        return generateCommandSetInclusive( name,\n                                            commandData,\n                                            initialSkipCount,\n                                            definition,\n                                            { returnParam },\n                                            vectorParams,\n                                            false,\n                                            { CommandFlavourFlagBits::enhanced },\n                                            raii,\n                                            false,\n                                            { CommandFlavourFlagBits::enhanced } );\n      case 1:\n        if ( returnParam == vectorParams.begin()->first )\n        {\n          // you get a vector of stuff, with the size being one of the parameters\n          return generateCommandSetInclusive( name,\n                                              commandData,\n                                              initialSkipCount,\n                                              definition,\n                                              { returnParam },\n                                              vectorParams,\n                                              false,\n                                              { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator },\n                                              raii,\n                                              false,\n                                              { CommandFlavourFlagBits::enhanced } );\n        }\n        else\n        {\n          if ( !isHandleType( commandData.params[vectorParams.begin()->first].type.type ) &&\n               !isStructureChainAnchor( commandData.params[vectorParams.begin()->first].type.type ) &&\n               ( commandData.params[vectorParams.begin()->first].type.type != \"void\" ) )\n          {\n            if ( isLenByStructMember( commandData.params[vectorParams.begin()->first].lenExpression,\n                                      commandData.params[vectorParams.begin()->second.lenParam] ) )\n            {\n              return generateCommandSetInclusive( name,\n                                                  commandData,\n                                                  initialSkipCount,\n                                                  definition,\n                                                  { returnParam },\n                                                  vectorParams,\n                                                  false,\n                                                  { CommandFlavourFlagBits::enhanced },\n                                                  raii,\n                                                  false,\n                                                  { CommandFlavourFlagBits::enhanced } );\n            }\n          }\n        }\n        break;\n      default: break;\n    }\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateCommandVoid2Return( std::string const &         name,\n                                                            CommandData const &         commandData,\n                                                            size_t                      initialSkipCount,\n                                                            bool                        definition,\n                                                            std::vector<size_t> const & returnParams,\n                                                            bool                        raii ) const\n{\n  std::map<size_t, VectorParamData> vectorParams = determineVectorParams( commandData.params );\n  switch ( vectorParams.size() )\n  {\n    case 0:\n      if ( isStructureType( commandData.params[returnParams[0]].type.type ) && !isStructureChainAnchor( commandData.params[returnParams[0]].type.type ) )\n      {\n        if ( isStructureType( commandData.params[returnParams[1]].type.type ) && !isStructureChainAnchor( commandData.params[returnParams[1]].type.type ) )\n        {\n          return generateCommandSetInclusive( name,\n                                              commandData,\n                                              initialSkipCount,\n                                              definition,\n                                              returnParams,\n                                              vectorParams,\n                                              false,\n                                              { CommandFlavourFlagBits::enhanced },\n                                              raii,\n                                              false,\n                                              { CommandFlavourFlagBits::enhanced } );\n        }\n      }\n      break;\n    case 1:\n      if ( ( returnParams[0] == vectorParams.begin()->second.lenParam ) && ( commandData.params[returnParams[0]].type.type == \"uint32_t\" ) )\n      {\n        if ( returnParams[1] == vectorParams.begin()->first )\n        {\n          if ( isStructureChainAnchor( commandData.params[returnParams[1]].type.type ) )\n          {\n            return generateCommandSetInclusive( name,\n                                                commandData,\n                                                initialSkipCount,\n                                                definition,\n                                                returnParams,\n                                                vectorParams,\n                                                false,\n                                                { CommandFlavourFlagBits::enhanced,\n                                                  CommandFlavourFlagBits::withAllocator,\n                                                  CommandFlavourFlagBits::chained,\n                                                  CommandFlavourFlagBits::chained | CommandFlavourFlagBits::withAllocator },\n                                                raii,\n                                                false,\n                                                { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::chained } );\n          }\n          else\n          {\n            return generateCommandSetInclusive( name,\n                                                commandData,\n                                                initialSkipCount,\n                                                definition,\n                                                returnParams,\n                                                vectorParams,\n                                                false,\n                                                { CommandFlavourFlagBits::enhanced, CommandFlavourFlagBits::withAllocator },\n                                                raii,\n                                                false,\n                                                { CommandFlavourFlagBits::enhanced } );\n          }\n        }\n      }\n      break;\n    default: break;\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateConstexprString( std::string const & structName ) const\n{\n  // structs with a VkBaseInStructure and VkBaseOutStructure can't be a constexpr!\n  const bool isConstExpression = ( structName != \"VkBaseInStructure\" ) && ( structName != \"VkBaseOutStructure\" );\n  return isConstExpression ? ( std::string( \"VULKAN_HPP_CONSTEXPR\" ) + ( ( containsUnion( structName ) || containsArray( structName ) ) ? \"_14 \" : \" \" ) ) : \"\";\n}\n\nstd::string VulkanHppGenerator::generateConstexprDefines() const\n{\n  auto const constexprFunctionTemplate = std::string{ R\"(  template <typename T, typename = typename std::enable_if<std::is_integral<T>::value>::type>\n  ${deprecated}VULKAN_HPP_CONSTEXPR uint32_t ${constName}( ${arguments} )\n  {\n    return ${implementation};\n  }\n)\" };\n  auto const constexprCallTemplate     = std::string{ R\"(  ${deprecated}VULKAN_HPP_CONSTEXPR_INLINE auto ${constName} = ${callee}( ${arguments} );\n)\" };\n  auto const constexprValueTemplate    = std::string{ R\"(  ${deprecated}VULKAN_HPP_CONSTEXPR_INLINE ${type} ${constName} = ${value};\n)\" };\n  auto const deprecatedAttribute       = std::string{ R\"(VULKAN_HPP_DEPRECATED(\"${reason}\") )\" };\n\n  // handle the value and callee macros first so they are visible for use in functions below.\n\n  auto constexprDefines = std::string{ R\"(\n  //===========================\n  //=== CONSTEXPR CONSTANTs ===\n  //===========================\n)\" };\n\n  {\n    auto const generateConstantsAndProtection =\n      [&constexprValueTemplate, this]( std::vector<RequireData> const & requireData, std::string const & title, std::set<std::string> & listedConstants )\n    {\n      auto constants = std::string{};\n      for ( auto const & require : requireData )\n      {\n        for ( auto const & constant : require.constants )\n        {\n          if ( !listedConstants.contains( constant ) )\n          {\n            auto        constIt = m_constants.find( constant );\n            std::string tag     = findTag( constant );\n            constants += replaceWithMap( constexprValueTemplate,\n                                         { { \"type\", constIt->second.type },\n                                           { \"constName\", stripPrefix( toCamelCase( stripPostfix( constant, tag ) ), \"Vk\" ) + tag },\n                                           { \"deprecated\", \"\" },\n                                           { \"value\", constant } } );\n            listedConstants.insert( constant );\n          }\n        }\n      }\n      return addTitleAndProtection( title, constants );\n    };\n\n    std::set<std::string> listedConstants;\n    for ( auto const & feature : m_features )\n    {\n      constexprDefines += generateConstantsAndProtection( feature.requireData, feature.name, listedConstants );\n    }\n    for ( auto const & extension : m_extensions )\n    {\n      constexprDefines += generateConstantsAndProtection( extension.requireData, extension.name, listedConstants );\n    }\n  }\n\n  // values\n  constexprDefines += R\"(\n  //========================\n  //=== CONSTEXPR VALUEs ===\n  //========================\n)\";\n  for ( auto const & [macro, data] : m_definesPartition.values )\n  {\n    auto const deprecated = data.deprecated ? replaceWithMap( deprecatedAttribute, { { \"reason\", data.deprecationReason } } ) : \"\";\n\n    // make `macro` PascalCase and strip the `Vk` prefix\n    auto const constName = stripPrefix( toCamelCase( macro ), \"Vk\" );\n    auto const valueString =\n      replaceWithMap( constexprValueTemplate, { { \"type\", \"uint32_t\" }, { \"constName\", constName }, { \"deprecated\", deprecated }, { \"value\", macro } } );\n\n    constexprDefines += valueString;\n  }\n\n  // functions\n  constexprDefines += R\"(\n  //=========================\n  //=== CONSTEXPR CALLEEs ===\n  //=========================\n)\";\n  for ( auto const & [macro, data] : m_definesPartition.callees )\n  {\n    auto const deprecated = data.deprecated ? replaceWithMap( deprecatedAttribute, { { \"reason\", data.deprecationReason } } ) : \"\";\n    // make `macro` camelCase and strip the `Vk` prefix\n    auto const constName = startLowerCase( stripPrefix( toCamelCase( macro ), \"Vk\" ) );\n    // for every parameter, need to use auto const and append a comma if needed (i.e. has more than one parameter, and not for the last one)\n    auto parametersString = std::string{};\n    for ( auto const & paramString : data.params )\n    {\n      parametersString += \"T const \" + paramString + \", \";\n    }\n    // trim the last two characters (i.e. the last comma and the space)\n    parametersString.resize( parametersString.size() - 2 );\n\n    auto const functionString = replaceWithMap(\n      constexprFunctionTemplate,\n      { { \"arguments\", parametersString }, { \"constName\", constName }, { \"deprecated\", deprecated }, { \"implementation\", data.possibleDefinition } } );\n\n    constexprDefines += functionString;\n  }\n\n  // callers\n  constexprDefines += R\"(\n  //=========================\n  //=== CONSTEXPR CALLERs ===\n  //=========================\n)\";\n  for ( auto const & [macro, data] : m_definesPartition.callers )\n  {\n    auto const deprecated = data.deprecated ? replaceWithMap( deprecatedAttribute, { { \"reason\", data.deprecationReason } } ) : \"\";\n    // make `macro` PascalCase and strip the `Vk` prefix\n    auto const constName       = stripPrefix( toCamelCase( macro ), \"Vk\" );\n    auto       argumentsString = std::string{};\n\n    // for every argument, append a comma if needed (i.e. has more than one parameter, and not for the last one)\n    for ( auto const & argString : data.params )\n    {\n      argumentsString += argString + \", \";\n    }\n    // trim the last two characters (i.e. the last comma and the space)\n    argumentsString.resize( argumentsString.size() - 2 );\n\n    auto const callerString = replaceWithMap(\n      constexprCallTemplate,\n      { { \"arguments\", argumentsString }, { \"callee\", startLowerCase( data.possibleCallee ) }, { \"constName\", constName }, { \"deprecated\", deprecated } } );\n    constexprDefines += callerString;\n  }\n\n  // extension constexprs\n  auto const extensionConstexprDefinesTemplate = std::string{ R\"(\n  //=================================\n  //=== CONSTEXPR EXTENSION NAMEs ===\n  //=================================\n\n  ${extensionConstexprs}\n)\" };\n\n  auto extensionConstexprs = std::string{};\n\n  static auto const extensionTemplate           = std::string{ R\"(${deprecated}VULKAN_HPP_CONSTEXPR_INLINE auto ${var} = ${macro};\n)\" };\n  static auto const deprecatedPrefixTemplate    = std::string{ R\"(VULKAN_HPP_DEPRECATED( ${message} ) )\" };\n  static auto const deprecatedByMessageTemplate = std::string{ R\"(\"The ${extensionName} extension has been deprecated by ${deprecatedBy}.\")\" };\n  static auto const deprecatedMessageTemplate   = std::string{ R\"(\"The ${extensionName} extension has been deprecated.\")\" };\n  static auto const obsoletedMessageTemplate    = std::string{ R\"(\"The ${extensionName} extension has been obsoleted by ${obsoletedBy}.\")\" };\n\n  // I really, really wish C++ had discards for structured bindings...\n  for ( auto const & extension : m_extensions )\n  {\n    auto const & requireDatas = extension.requireData;\n\n    // assert that requireDatas has at least one require...\n    // and the first require has at least two enumConstants, which we are going to use\n    assert( requireDatas.size() >= 1 );\n    assert( requireDatas.front().enumConstants.size() >= 2 );\n    auto const & enumConstants = requireDatas.front().enumConstants;\n\n    auto const VENDORPascalCaseStripPrefix = []( std::string const & macro )\n    {\n      auto       prefixStripped = stripPrefix( macro, \"VK_\" );\n      auto const vendor         = prefixStripped.substr( 0, prefixStripped.find( '_' ) );\n      return vendor + toCamelCase( stripPrefix( prefixStripped, vendor + \"_\" ) );\n    };\n\n    // add asserts so we don't get a nullptr exception below\n    auto const & extensionMacroPtr =\n      std::find_if( enumConstants.begin(), enumConstants.end(), []( auto const & keyval ) { return keyval.first.ends_with( \"_EXTENSION_NAME\" ); } );\n    auto const & specVersionMacroPtr =\n      std::find_if( enumConstants.begin(), enumConstants.end(), []( auto const & keyval ) { return keyval.first.ends_with( \"_SPEC_VERSION\" ); } );\n    assert( extensionMacroPtr != enumConstants.end() );\n    assert( specVersionMacroPtr != enumConstants.end() );\n\n    auto const & extensionMacro   = extensionMacroPtr->first;\n    auto const & specVersionMacro = specVersionMacroPtr->first;\n\n    auto const extensionVar   = VENDORPascalCaseStripPrefix( extensionMacro );\n    auto const specVersionVar = VENDORPascalCaseStripPrefix( specVersionMacro );\n\n    std::string deprecationMessage;\n    if ( extension.isDeprecated )\n    {\n      assert( extension.obsoletedBy.empty() && extension.promotedTo.empty() );\n      deprecationMessage = extension.deprecatedBy.empty()\n                           ? replaceWithMap( deprecatedMessageTemplate, { { \"extensionName\", extension.name } } )\n                           : replaceWithMap( deprecatedByMessageTemplate, { { \"extensionName\", extension.name }, { \"deprecatedBy\", extension.deprecatedBy } } );\n    }\n    else if ( !extension.obsoletedBy.empty() )\n    {\n      assert( extension.promotedTo.empty() );\n      deprecationMessage = replaceWithMap( obsoletedMessageTemplate, { { \"extensionName\", extension.name }, { \"obsoletedBy\", extension.obsoletedBy } } );\n    }\n    else if ( !extension.promotedTo.empty() )\n    {\n      // promoted extensions are _not_ deprecated!\n    }\n    auto const deprecatedPrefix = deprecationMessage.empty() ? \"\" : replaceWithMap( deprecatedPrefixTemplate, { { \"message\", deprecationMessage } } );\n\n    auto const thisExtensionConstexprs =\n      replaceWithMap( extensionTemplate, { { \"deprecated\", deprecatedPrefix }, { \"macro\", extensionMacro }, { \"var\", extensionVar } } ) +\n      replaceWithMap( extensionTemplate, { { \"deprecated\", deprecatedPrefix }, { \"macro\", specVersionMacro }, { \"var\", specVersionVar } } );\n\n    extensionConstexprs += addTitleAndProtection( extension.name, thisExtensionConstexprs );\n  }\n\n  constexprDefines += replaceWithMap( extensionConstexprDefinesTemplate, { { \"extensionConstexprs\", extensionConstexprs } } );\n\n  return constexprDefines;\n}\n\nstd::string VulkanHppGenerator::generateConstexprUsings() const\n{\n  auto constexprUsings = std::string{ R\"(\n  //===========================\n  //=== CONSTEXPR CONSTANTs ===\n  //===========================\n)\" };\n\n  auto const constexprUsingTemplate = std::string{ R\"(  using VULKAN_HPP_NAMESPACE::${constName};\n)\" };\n\n  auto const pascalCasePrefixStrip = []( std::string const & macro ) { return stripPrefix( toCamelCase( macro ), \"Vk\" ); };\n  auto const camelCasePrefixStrip  = []( std::string const & macro ) { return startLowerCase( stripPrefix( toCamelCase( macro ), \"Vk\" ) ); };\n  auto const VENDORCasePrefixStrip = []( std::string const & macro )\n  {\n    auto       prefixStripped = stripPrefix( macro, \"VK_\" );\n    auto const vendor         = prefixStripped.substr( 0, prefixStripped.find( '_' ) );\n    return vendor + toCamelCase( stripPrefix( prefixStripped, vendor + \"_\" ) );\n  };\n\n  // constants\n  {\n    auto const generateConstantsAndProtection =\n      [&]( std::vector<RequireData> const & requireData, std::string const & title, std::set<std::string> & listedConstants )\n    {\n      auto constants = std::string{};\n      for ( auto const & require : requireData )\n      {\n        for ( auto const & constant : require.constants )\n        {\n          if ( !listedConstants.contains( constant ) )\n          {\n            assert( m_constants.find( constant ) != m_constants.end() );\n            std::string tag = findTag( constant );\n            constants += replaceWithMap( constexprUsingTemplate, { { \"constName\", stripPrefix( toCamelCase( stripPostfix( constant, tag ) ), \"Vk\" ) + tag } } );\n            listedConstants.insert( constant );\n          }\n        }\n\n        for ( auto const & [key, _] : require.enumConstants )\n        {\n          // keys are the constants themselves. Values are their definitions, and don't need them...\n          // Again, recall these constants are all in the form VK_<vendor>_<name>_EXTENSION_NAME and VK_<vendor>_<name>_SPEC_VERSION\n          // strip the Vk, get the vendor, and PascalCase the rest\n          constants += replaceWithMap( constexprUsingTemplate, { { \"constName\", VENDORCasePrefixStrip( key ) } } );\n          listedConstants.insert( key );\n        }\n      }\n      return addTitleAndProtection( title, constants );\n    };\n\n    std::set<std::string> listedConstants;\n    for ( auto const & feature : m_features )\n    {\n      constexprUsings += generateConstantsAndProtection( feature.requireData, feature.name, listedConstants );\n    }\n    for ( auto const & extension : m_extensions )\n    {\n      constexprUsings += generateConstantsAndProtection( extension.requireData, extension.name, listedConstants );\n    }\n  }\n\n  // values\n  constexprUsings += R\"(\n  //========================\n  //=== CONSTEXPR VALUEs ===\n  //========================\n)\";\n  for ( auto const & macro : m_definesPartition.values )\n  {\n    // make `macro` PascalCase and strip the `Vk` prefix\n    auto const constName = pascalCasePrefixStrip( macro.first );\n    constexprUsings += replaceWithMap( constexprUsingTemplate, { { \"constName\", constName } } );\n  }\n\n  // callees\n  constexprUsings += R\"(\n  //=========================\n  //=== CONSTEXPR CALLEEs ===\n  //=========================\n)\";\n  for ( auto const & macro : m_definesPartition.callees )\n  {\n    // make `macro` camelCase and strip the `Vk` prefix\n    auto const constName = camelCasePrefixStrip( macro.first );\n    constexprUsings += replaceWithMap( constexprUsingTemplate, { { \"constName\", constName } } );\n  }\n\n  // callers\n  constexprUsings += R\"(\n  //==========================\n  //=== CONSTEXPR CALLERs ===\n  //==========================\n)\";\n  for ( auto const & macro : m_definesPartition.callers )\n  {\n    // make `macro` PascalCase and strip the `Vk` prefix\n    auto const constName = pascalCasePrefixStrip( macro.first );\n    constexprUsings += replaceWithMap( constexprUsingTemplate, { { \"constName\", constName } } );\n  }\n\n  return constexprUsings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleFuncpointerUsings() const\n{\n  std::string funcpointerUsings = R\"(\n  //====================\n  //=== FUNCPOINTERs ===\n  //====================\n)\";\n\n  auto const generateUsingsAndProtection = [this]( std::vector<RequireData> const & requireData, std::string const & title )\n  {\n    auto usings = std::string{};\n    for ( auto const & require : requireData )\n    {\n      for ( auto const & type : require.types )\n      {\n        if ( auto const & funcpointerIt = m_funcPointers.find( type.name ); funcpointerIt != m_funcPointers.end() )\n        {\n          usings += \"  using VULKAN_HPP_NAMESPACE::PFN_\" + stripPrefix( funcpointerIt->first, \"PFN_vk\" ) + \";\\n\";\n        }\n      }\n    }\n    return addTitleAndProtection( title, usings );\n  };\n\n  for ( auto const & feature : m_features )\n  {\n    funcpointerUsings += generateUsingsAndProtection( feature.requireData, feature.name );\n  }\n\n  for ( auto const & extension : m_extensions )\n  {\n    funcpointerUsings += generateUsingsAndProtection( extension.requireData, extension.name );\n  }\n\n  return funcpointerUsings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleHandleUsings() const\n{\n  auto const usingTemplate = std::string{ R\"(  using VULKAN_HPP_NAMESPACE::${className};\n)\" };\n\n  auto handleUsings = std::string{ R\"(\n  //===============\n  //=== HANDLEs ===\n  //===============\n\n  using VULKAN_HPP_NAMESPACE::isVulkanHandleType;\n)\" };\n\n  auto const generateUsingsAndProtection = [&usingTemplate, this]( std::vector<RequireData> const & requireData, std::string const & title )\n  {\n    auto usings = std::string{};\n    for ( auto const & require : requireData )\n    {\n      for ( auto const & type : require.types )\n      {\n        if ( auto const & handleIt = m_handles.find( type.name ); handleIt != m_handles.end() )\n        {\n          usings += replaceWithMap( usingTemplate, { { \"className\", stripPrefix( handleIt->first, \"Vk\" ) } } );\n        }\n      }\n    }\n    return addTitleAndProtection( title, usings );\n  };\n\n  for ( auto const & feature : m_features )\n  {\n    handleUsings += generateUsingsAndProtection( feature.requireData, feature.name );\n  }\n\n  for ( auto const & extension : m_extensions )\n  {\n    handleUsings += generateUsingsAndProtection( extension.requireData, extension.name );\n  }\n\n  return handleUsings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleStructUsings() const\n{\n  auto const usingTemplate = std::string{ R\"(  using VULKAN_HPP_NAMESPACE::${structName};\n)\" };\n\n  auto structUsings  = std::string{ R\"(\n  //===============\n  //=== STRUCTs ===\n  //===============\n)\" };\n  auto listedStructs = std::set<std::string>{};\n\n  auto const generateUsingsAndProtection = [&listedStructs, &usingTemplate, this]( std::vector<RequireData> const & requireData, std::string const & title )\n  {\n    auto localUsings = std::string{};\n    for ( auto const & require : requireData )\n    {\n      for ( auto const & type : require.types )\n      {\n        if ( auto const & structIt = m_structs.find( type.name ); structIt != m_structs.end() && listedStructs.insert( type.name ).second )\n        {\n          auto const structureType = stripPrefix( structIt->first, \"Vk\" );\n          localUsings += replaceWithMap( usingTemplate, { { \"structName\", structureType } } );\n\n          for ( auto const & alias : structIt->second.aliases )\n          {\n            localUsings += replaceWithMap( usingTemplate, { { \"structName\", stripPrefix( alias.first, \"Vk\" ) } } );\n          }\n        }\n      }\n    }\n    return addTitleAndProtection( title, localUsings );\n  };\n\n  for ( auto const & feature : m_features )\n  {\n    structUsings += generateUsingsAndProtection( feature.requireData, feature.name );\n  }\n\n  for ( auto const & extension : m_extensions )\n  {\n    structUsings += generateUsingsAndProtection( extension.requireData, extension.name );\n  }\n\n  return structUsings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleSharedHandleUsings() const\n{\n  auto const usingTemplate                        = std::string{ R\"(  using VULKAN_HPP_NAMESPACE::Shared${handleName};\n)\" };\n  auto       sharedHandleUsings                   = std::string{ R\"(\n  //======================\n  //=== SHARED HANDLEs ===\n  //======================\n)\" };\n  auto const [smartHandleEnter, smartHandleLeave] = generateProtection( \"VULKAN_HPP_NO_SMART_HANDLE\", false );\n\n  sharedHandleUsings += \"\\n\" + smartHandleEnter;\n\n  auto const generateUsingsAndProtection = [&usingTemplate, this]( std::vector<RequireData> const & requireData, std::string const & title )\n  {\n    auto usings = std::string{};\n    for ( auto const & require : requireData )\n    {\n      for ( auto const & type : require.types )\n      {\n        if ( auto const & handleIt = m_handles.find( type.name ); handleIt != m_handles.end() )\n        {\n          usings += replaceWithMap( usingTemplate, { { \"handleName\", stripPrefix( handleIt->first, \"Vk\" ) } } );\n        }\n      }\n    }\n    return addTitleAndProtection( title, usings );\n  };\n\n  for ( auto const & feature : m_features )\n  {\n    sharedHandleUsings += generateUsingsAndProtection( feature.requireData, feature.name );\n  }\n\n  for ( auto const & extension : m_extensions )\n  {\n    sharedHandleUsings += generateUsingsAndProtection( extension.requireData, extension.name );\n  }\n\n  sharedHandleUsings += R\"(  using VULKAN_HPP_NAMESPACE::SharedHandleTraits;\n)\";\n\n  sharedHandleUsings += smartHandleLeave + \"\\n\";\n\n  return sharedHandleUsings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleUniqueHandleUsings() const\n{\n  auto const usingTemplate                        = std::string{ R\"(  using VULKAN_HPP_NAMESPACE::Unique${handleName};\n)\" };\n  auto       uniqueHandleUsings                   = std::string{ R\"(\n  //======================\n  //=== UNIQUE HANDLEs ===\n  //======================\n)\" };\n  auto const [smartHandleEnter, smartHandleLeave] = generateProtection( \"VULKAN_HPP_NO_SMART_HANDLE\", false );\n\n  uniqueHandleUsings += \"\\n\" + smartHandleEnter;\n\n  auto const generateUsingsAndProtection = [&usingTemplate, this]( std::vector<RequireData> const & requireData, std::string const & title )\n  {\n    auto usings = std::string{};\n    for ( auto const & require : requireData )\n    {\n      for ( auto const & type : require.types )\n      {\n        if ( auto const & handleIt = m_handles.find( type.name ); handleIt != m_handles.end() && !handleIt->second.deleteCommand.empty() )\n        {\n          usings += replaceWithMap( usingTemplate, { { \"handleName\", stripPrefix( handleIt->first, \"Vk\" ) } } );\n        }\n      }\n    }\n    return addTitleAndProtection( title, usings );\n  };\n\n  for ( auto const & feature : m_features )\n  {\n    uniqueHandleUsings += generateUsingsAndProtection( feature.requireData, feature.name );\n  }\n\n  for ( auto const & extension : m_extensions )\n  {\n    uniqueHandleUsings += generateUsingsAndProtection( extension.requireData, extension.name );\n  }\n\n  uniqueHandleUsings += R\"(  using VULKAN_HPP_NAMESPACE::UniqueHandleTraits;\n)\";\n\n  uniqueHandleUsings += smartHandleLeave + \"\\n\";\n\n  return uniqueHandleUsings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleFuncsUsings() const\n{\n  auto const usingTemplate = std::string{ R\"(  using VULKAN_HPP_NAMESPACE::${funcName};\n)\" };\n\n  auto funcUsings = std::string{ R\"(\n  //===========================\n  //=== COMMAND Definitions ===\n  //===========================\n)\" };\n\n  for ( auto const & func : m_handles.at( \"\" ).commands )\n  {\n    funcUsings += replaceWithMap( usingTemplate, { { \"funcName\", startLowerCase( stripPrefix( func, \"vk\" ) ) } } );\n  }\n\n  auto const [enter, leave] = generateProtection( \"VULKAN_HPP_NO_SMART_HANDLE\", false );\n  funcUsings += \"\\n\" + enter + replaceWithMap( usingTemplate, { { \"funcName\", \"createInstanceUnique\" } } ) + leave + \"\\n\";\n\n  return funcUsings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleEnumUsings() const\n{\n  auto const usingTemplate = std::string{ R\"(  using VULKAN_HPP_NAMESPACE::${enumName};\n)\" };\n\n  auto enumUsings  = std::string{ R\"(\n  //=============\n  //=== ENUMs ===\n  //=============\n)\" };\n  auto listedEnums = std::set<std::string>{};\n\n  // insert CppType first\n  enumUsings += replaceWithMap( usingTemplate, { { \"enumName\", \"CppType\" } } );\n\n  auto const generateUsingsAndProtection = [&listedEnums, &usingTemplate, this]( std::vector<RequireData> const & requireData, std::string const & title )\n  {\n    auto localUsings = std::string{};\n    for ( auto const & require : requireData )\n    {\n      for ( auto const & type : require.types )\n      {\n        if ( auto const & enumIt = m_enums.find( type.name ); enumIt != m_enums.end() && listedEnums.insert( type.name ).second )\n        {\n          auto const enumName = stripPrefix( enumIt->first, \"Vk\" );\n          localUsings += replaceWithMap( usingTemplate, { { \"enumName\", enumName } } );\n\n          for ( auto const & alias : enumIt->second.aliases )\n          {\n            localUsings += replaceWithMap( usingTemplate, { { \"enumName\", stripPrefix( alias.first, \"Vk\" ) } } );\n          }\n\n          if ( auto const bitmaskIt =\n                 std::find_if( m_bitmasks.begin(),\n                               m_bitmasks.end(),\n                               [&enumIt]( std::pair<std::string, BitmaskData> const & bitmask ) { return bitmask.second.require == enumIt->first; } );\n               bitmaskIt != m_bitmasks.end() )\n          {\n            localUsings += replaceWithMap( usingTemplate, { { \"enumName\", stripPrefix( bitmaskIt->first, \"Vk\" ) } } );\n            for ( auto const & alias : bitmaskIt->second.aliases )\n            {\n              localUsings += replaceWithMap( usingTemplate, { { \"enumName\", stripPrefix( alias.first, \"Vk\" ) } } );\n            }\n          }\n        }\n      }\n    }\n    return addTitleAndProtection( title, localUsings );\n  };\n\n  for ( auto const & feature : m_features )\n  {\n    enumUsings += generateUsingsAndProtection( feature.requireData, feature.name );\n  }\n\n  for ( auto const & extension : m_extensions )\n  {\n    enumUsings += generateUsingsAndProtection( extension.requireData, extension.name );\n  }\n\n  // finally insert IndexTypeValue\n  auto const indexTypeComment = R\"(\n  //=========================\n  //=== Index Type Traits ===\n  //=========================\n)\";\n  enumUsings += indexTypeComment + replaceWithMap( usingTemplate, { { \"enumName\", \"IndexTypeValue\" } } );\n\n  return enumUsings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleFormatTraitsUsings() const\n{\n  // everything is hardcoded, so things are very easy...\n  auto formatTraitsUsings = std::string{ R\"(\n  //=====================\n  //=== Format Traits ===\n  //=====================\n)\" };\n\n  auto const usingTemplate        = std::string{ R\"(  using VULKAN_HPP_NAMESPACE::${function};\n)\" };\n  auto const formatTraitFunctions = std::array{ \"blockExtent\",\n                                                \"blockSize\",\n                                                \"compatibilityClass\",\n                                                \"componentBits\",\n                                                \"componentCount\",\n                                                \"componentName\",\n                                                \"componentNumericFormat\",\n                                                \"componentPlaneIndex\",\n                                                \"componentsAreCompressed\",\n                                                \"compressionScheme\",\n                                                \"isCompressed\",\n                                                \"packed\",\n                                                \"planeCompatibleFormat\",\n                                                \"planeCount\",\n                                                \"planeHeightDivisor\",\n                                                \"planeWidthDivisor\",\n                                                \"texelsPerBlock\" };\n\n  for ( auto const & func : formatTraitFunctions )\n  {\n    formatTraitsUsings += replaceWithMap( usingTemplate, { { \"function\", func } } );\n  }\n\n  return formatTraitsUsings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleExtensionInspectionUsings() const\n{\n  auto const usingTemplate = std::string{ R\"(  using VULKAN_HPP_NAMESPACE::${function};\n)\" };\n\n  auto extensionInspectionsUsings = std::string{ R\"(\n  //======================================\n  //=== Extension inspection functions ===\n  //======================================\n)\" };\n\n  auto const extensionInspectionFunctions =\n    std::array{ \"getDeviceExtensions\",    \"getInstanceExtensions\", \"getDeprecatedExtensions\",  \"getExtensionDepends\",     \"getExtensionDepends\",\n                \"getObsoletedExtensions\", \"getPromotedExtensions\", \"getExtensionDeprecatedBy\", \"getExtensionObsoletedBy\", \"getExtensionPromotedTo\",\n                \"isDeprecatedExtension\",  \"isDeviceExtension\",     \"isInstanceExtension\",      \"isObsoletedExtension\",    \"isPromotedExtension\" };\n\n  for ( auto const & func : extensionInspectionFunctions )\n  {\n    extensionInspectionsUsings += replaceWithMap( usingTemplate, { { \"function\", func } } );\n  }\n\n  return extensionInspectionsUsings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleUsings() const\n{\n  auto const usingTemplate = std::string{ R\"(  using VULKAN_HPP_NAMESPACE::${className};\n)\" };\n\n  auto const hardCodedEnhancedModeTypes      = std::array{ \"ArrayProxy\", \"ArrayProxyNoTemporaries\", \"StridedArrayProxy\", \"Optional\", \"StructureChain\" };\n  auto const hardCodedSmartHandleHelperTypes = std::array{ \"ObjectDestroy\",       \"ObjectFree\",       \"ObjectRelease\",       \"PoolFree\",\n                                                           \"ObjectDestroyShared\", \"ObjectFreeShared\", \"ObjectReleaseShared\", \"PoolFreeShared\" };\n  auto const hardCodedFunctions              = std::array{ \"exchange\" };\n\n  auto usings = std::string{ R\"(  //=====================================\n  //=== HARDCODED TYPEs AND FUNCTIONs ===\n  //=====================================\n  using VULKAN_HPP_NAMESPACE::ArrayWrapper1D;\n  using VULKAN_HPP_NAMESPACE::ArrayWrapper2D;\n  using VULKAN_HPP_NAMESPACE::Flags;\n  using VULKAN_HPP_NAMESPACE::FlagTraits;\n  namespace detail\n  {\n    using VULKAN_HPP_NAMESPACE::detail::DispatchLoaderBase;\n    using VULKAN_HPP_NAMESPACE::detail::DispatchLoaderDynamic;\n#if !defined( VK_NO_PROTOTYPES )\n    using VULKAN_HPP_NAMESPACE::detail::DispatchLoaderStatic;\n    using VULKAN_HPP_NAMESPACE::detail::getDispatchLoaderStatic;\n#endif /*VK_NO_PROTOTYPES*/\n  }\n)\" };\n\n  // insert the Flags bitwise operators\n  auto const flagsBitWiseOperatorsUsings = std::array{ \"operator&\", \"operator|\", \"operator^\", \"operator~\" };\n  for ( auto const & operatorName : flagsBitWiseOperatorsUsings )\n  {\n    usings += replaceWithMap( usingTemplate, { { \"className\", operatorName } } );\n  }\n\n  // delete the namespace declaration for the default dispatcher macro using statement\n  usings += R\"(using VULKAN_HPP_DEFAULT_DISPATCHER_TYPE;\n)\";\n\n  auto enhancedModeUsings = std::string{};\n  for ( auto const & className : hardCodedEnhancedModeTypes )\n  {\n    enhancedModeUsings += replaceWithMap( usingTemplate, { { \"className\", std::string{ className } } } );\n  }\n  // protect the enhanced-mode usings with a macro\n  const auto [enterEnhancedMode, leaveEnhancedMode] = generateProtection( \"VULKAN_HPP_DISABLE_ENHANCED_MODE\", false );\n  usings += \"\\n\" + enterEnhancedMode + enhancedModeUsings + leaveEnhancedMode + \"\\n\";\n\n  std::string smartHandleUsings = \"  namespace detail\\n  {\\n\";\n  for ( auto const & helperType : hardCodedSmartHandleHelperTypes )\n  {\n    smartHandleUsings += \"    using VULKAN_HPP_NAMESPACE::detail::\"s + helperType + \";\\n\";\n  }\n  smartHandleUsings += R\"(    }\n\n  using VULKAN_HPP_NAMESPACE::SharedHandle;\n  using VULKAN_HPP_NAMESPACE::UniqueHandle;\n)\";\n\n  // likewise for the smart-handle usings\n  const auto [enterNoSmartHandle, leaveNoSmartHandle] = generateProtection( \"VULKAN_HPP_NO_SMART_HANDLE\", false );\n  usings += \"\\n\" + enterNoSmartHandle + smartHandleUsings + leaveNoSmartHandle + \"\\n\";\n\n  for ( auto const & functionName : hardCodedFunctions )\n  {\n    usings += \"\\n\" + replaceWithMap( usingTemplate, { { \"className\", std::string{ functionName } } } );\n  }\n\n  // now generate baseTypes\n  auto baseTypes = std::string{ R\"(\n  //==================\n  //=== BASE TYPEs ===\n  //==================\n)\" };\n  for ( auto const & baseType : m_baseTypes )\n  {\n    if ( baseType.first != \"VkFlags\" && baseType.first != \"VkFlags64\" && !baseType.second.typeInfo.type.empty() )\n    {\n      baseTypes += replaceWithMap( usingTemplate, { { \"className\", stripPrefix( baseType.first, \"Vk\" ) } } );\n    }\n  }\n  usings += baseTypes;\n\n  // generate Enums\n  usings += generateCppModuleEnumUsings();\n\n  // to_string, toHexString\n  auto const toString                       = std::array{ \"to_string\", \"toHexString\" };\n  auto const [toStringEnter, toStringLeave] = generateProtection( \"VULKAN_HPP_NO_TO_STRING\", false );\n\n  usings += R\"(\n  //======================\n  //=== ENUM to_string ===\n  //======================\n)\" + toStringEnter;\n  for ( auto const & name : toString )\n  {\n    usings += replaceWithMap( usingTemplate, { { \"className\", name } } );\n  }\n  usings += toStringLeave + \"\\n\";\n\n  // hardcoded exceptions and functions\n  auto const hardCodedExceptionTypesAndFunctions =\n    std::array{ \"ErrorCategoryImpl\", \"Error\", \"LogicError\", \"SystemError\", \"errorCategory\", \"make_error_code\", \"make_error_condition\" };\n  const auto [exceptionsEnter, exceptionsLeave] = generateProtection( \"VULKAN_HPP_NO_EXCEPTIONS\", false );\n\n  auto exceptionsUsings = std::string{ R\"(\n  //=============================\n  //=== EXCEPTIONs AND ERRORs ===\n  //=============================\n)\" } + exceptionsEnter;\n\n  for ( auto const & name : hardCodedExceptionTypesAndFunctions )\n  {\n    exceptionsUsings += replaceWithMap( usingTemplate, { { \"className\", name } } );\n  }\n\n  usings += exceptionsUsings;\n\n  // result Exceptions\n  auto resultExceptionsUsings = std::string{};\n  auto const & [name, data]   = *m_enums.find( \"VkResult\" );\n  for ( auto const & value : data.values )\n  {\n    if ( value.supported && value.name.starts_with( \"VK_ERROR\" ) )\n    {\n      auto [enter, leave] = generateProtection( value.protect );\n      enter               = enter.empty() ? enter : \"\\n\" + enter;\n      leave               = leave.empty() ? leave : leave + \"\\n\";\n\n      auto const valueName = generateEnumValueName( name, value.name, false );\n      auto const className = stripPrefix( valueName, \"eError\" ) + \"Error\";\n\n      resultExceptionsUsings += enter + replaceWithMap( usingTemplate, { { \"className\", className } } ) + leave;\n    }\n  }\n  usings += resultExceptionsUsings;\n\n  usings += exceptionsLeave + \"\\n\";\n\n  // some hardcoded types\n  auto const hardCodedResultValueTypes = std::array{ \"ResultValue\", \"ResultValueType\" };\n  for ( auto const & valueType : hardCodedResultValueTypes )\n  {\n    usings += replaceWithMap( usingTemplate, { { \"className\", valueType } } );\n  }\n\n  usings += \"\\n\" + generateConstexprUsings() + \"\\n\";\n\n  // structs, handles, UniqueHandles, etc\n  usings += generateCppModuleFuncpointerUsings();\n  usings += generateCppModuleStructUsings();\n  usings += generateCppModuleHandleUsings();\n  usings += generateCppModuleUniqueHandleUsings();\n  usings += generateCppModuleSharedHandleUsings();\n  usings += generateCppModuleFuncsUsings();\n\n  auto const [enterDisableEnhanced, leaveDisableEnhanced] = generateProtection( \"VULKAN_HPP_DISABLE_ENHANCED_MODE\", false );\n  usings += \"\\n\" + enterDisableEnhanced + replaceWithMap( usingTemplate, { { \"className\", \"StructExtends\" } } ) + leaveDisableEnhanced + \"\\n\";\n\n  auto const dynamicLoaderUsing = std::string{ R\"(#if VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL\n  namespace detail\n  {\n    using VULKAN_HPP_NAMESPACE::detail::DynamicLoader;\n  }\n#endif /*VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL*/\n)\" };\n  usings += dynamicLoaderUsing;\n\n  usings += generateCppModuleFormatTraitsUsings();\n  usings += generateCppModuleExtensionInspectionUsings();\n\n  return usings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleRaiiUsings() const\n{\n  auto const raiiUsingTemplate = std::string{ R\"(    using VULKAN_HPP_RAII_NAMESPACE::${className};\n)\" };\n  auto       usings            = std::string{ R\"(    //======================\n    //=== RAII HARDCODED ===\n    //======================\n\n    using VULKAN_HPP_RAII_NAMESPACE::Context;\n    namespace detail\n    {\n      using VULKAN_HPP_RAII_NAMESPACE::detail::ContextDispatcher;\n      using VULKAN_HPP_RAII_NAMESPACE::detail::InstanceDispatcher;\n      using VULKAN_HPP_RAII_NAMESPACE::detail::DeviceDispatcher;\n    }\n\n    //====================\n    //=== RAII HANDLEs ===\n    //====================\n)\" };\n\n  auto const generateUsingsAndProtection = [&raiiUsingTemplate, this]( std::vector<RequireData> const & requireData, std::string const & title )\n  {\n    auto usings = std::string{};\n    for ( auto const & require : requireData )\n    {\n      for ( auto const & type : require.types )\n      {\n        if ( auto const & handleIt = m_handles.find( type.name ); handleIt != m_handles.end() )\n        {\n          usings += replaceWithMap( raiiUsingTemplate, { { \"className\", stripPrefix( handleIt->first, \"Vk\" ) } } );\n\n          // if there is an array constructor, generate the plural type also\n          if ( hasArrayConstructor( handleIt->second ) )\n          {\n            usings += replaceWithMap( raiiUsingTemplate, { { \"className\", stripPrefix( type.name, \"Vk\" ) + \"s\" } } );\n          }\n        }\n      }\n    }\n    return addTitleAndProtection( title, usings );\n  };\n\n  // now, insert features and extensions with protection, and strip Vk prefix\n  for ( auto const & feature : m_features )\n  {\n    usings += generateUsingsAndProtection( feature.requireData, feature.name );\n  }\n\n  for ( auto const & extension : m_extensions )\n  {\n    usings += generateUsingsAndProtection( extension.requireData, extension.name );\n  }\n\n  return usings;\n}\n\nstd::string VulkanHppGenerator::generateCppModuleHandleHashSpecializations() const\n{\n  const std::string hashesTemplate = R\"(\n  //========================================\n  //=== HASH specializations for handles ===\n  //========================================\n\n${specializations}\n)\";\n\n  auto const generateSpecializations = [this]( std::vector<RequireData> const & requireData, std::string const & title )\n  {\n    auto specializations = std::string{};\n    for ( auto const & require : requireData )\n    {\n      for ( auto const & type : require.types )\n      {\n        if ( auto const & handleIt = m_handles.find( type.name ); handleIt != m_handles.end() )\n        {\n          specializations += \"  template <> struct hash<VULKAN_HPP_NAMESPACE::\" + stripPrefix( handleIt->first, \"Vk\" ) + \">;\\n\";\n        }\n      }\n    }\n    return addTitleAndProtection( title, specializations );\n  };\n\n  std::string specializations;\n  for ( auto const & feature : m_features )\n  {\n    specializations += generateSpecializations( feature.requireData, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    specializations += generateSpecializations( extension.requireData, extension.name );\n  }\n  return replaceWithMap( hashesTemplate, { { \"specializations\", specializations } } );\n}\n\nstd::string VulkanHppGenerator::generateCppModuleHashSpecializations() const\n{\n  std::string const hasSpecializationsTemplate = R\"(\n  //=======================================\n  //=== HASH specialization for Flags types ===\n  //=======================================\n\n  template <typename BitType>\n  struct hash<VULKAN_HPP_NAMESPACE::Flags<BitType>>;\n\n  ${handleHashSpecializations}\n  ${structHashSpecializations}\n)\";\n\n  return replaceWithMap( hasSpecializationsTemplate,\n                         { { \"handleHashSpecializations\", generateCppModuleHandleHashSpecializations() },\n                           { \"structHashSpecializations\", generateCppModuleStructHashSpecializations() } } );\n}\n\nstd::string VulkanHppGenerator::generateCppModuleStructHashSpecializations() const\n{\n  const std::string hashesTemplate = R\"(\n  //========================================\n  //=== HASH specializations for structs ===\n  //========================================\n\n${specializations}\n)\";\n\n  auto const generateSpecializations = [this]( std::vector<RequireData> const & requireData, std::string const & title )\n  {\n    auto specializations = std::string{};\n    for ( auto const & require : requireData )\n    {\n      for ( auto const & type : require.types )\n      {\n        if ( auto const & structIt = m_structs.find( type.name ); structIt != m_structs.end() )\n        {\n          specializations += \"  template <> struct hash<VULKAN_HPP_NAMESPACE::\" + stripPrefix( structIt->first, \"Vk\" ) + \">;\\n\";\n        }\n      }\n    }\n    return addTitleAndProtection( title, specializations );\n  };\n\n  std::string specializations;\n  for ( auto const & feature : m_features )\n  {\n    specializations += generateSpecializations( feature.requireData, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    specializations += generateSpecializations( extension.requireData, extension.name );\n  }\n  return replaceWithMap( hashesTemplate, { { \"specializations\", specializations } } );\n}\n\nstd::string VulkanHppGenerator::generateDataDeclarations( CommandData const &                       commandData,\n                                                          std::vector<size_t> const &               returnParams,\n                                                          std::map<size_t, VectorParamData> const & vectorParams,\n                                                          std::set<size_t> const &                  templatedParams,\n                                                          CommandFlavourFlags                       flavourFlags,\n                                                          bool                                      raii,\n                                                          std::vector<std::string> const &          dataTypes,\n                                                          std::string const &                       dataType,\n                                                          std::string const &                       returnType,\n                                                          std::string const &                       returnVariable ) const\n{\n  assert( dataTypes.size() == returnParams.size() );\n\n  switch ( returnParams.size() )\n  {\n    case 0: return \"\";  // no returnParams -> no data declarations\n    case 1:\n      return generateDataDeclarations1Return(\n        commandData, returnParams, vectorParams, templatedParams, flavourFlags, dataTypes, dataType, returnType, returnVariable );\n    case 2:\n      assert( !( flavourFlags & CommandFlavourFlagBits::unique ) );\n      return generateDataDeclarations2Returns( commandData, returnParams, vectorParams, flavourFlags, raii, dataTypes, dataType, returnVariable );\n    case 3:\n      assert( !( flavourFlags & ( CommandFlavourFlagBits::singular | CommandFlavourFlagBits::unique ) ) );\n      return generateDataDeclarations3Returns( commandData, returnParams, vectorParams, flavourFlags, raii, dataTypes );\n    default: assert( false ); return \"\";\n  }\n}\n\nstd::string VulkanHppGenerator::generateDataDeclarations1Return( CommandData const &                       commandData,\n                                                                 std::vector<size_t> const &               returnParams,\n                                                                 std::map<size_t, VectorParamData> const & vectorParams,\n                                                                 std::set<size_t> const &                  templatedParams,\n                                                                 CommandFlavourFlags                       flavourFlags,\n                                                                 std::vector<std::string> const &          dataTypes,\n                                                                 std::string const &                       dataType,\n                                                                 std::string const &                       returnType,\n                                                                 std::string const &                       returnVariable ) const\n{\n  auto vectorParamIt = vectorParams.find( returnParams[0] );\n  if ( !( flavourFlags & CommandFlavourFlagBits::chained ) )\n  {\n    if ( ( vectorParamIt == vectorParams.end() ) || ( flavourFlags & CommandFlavourFlagBits::singular ) )\n    {\n      std::string const dataDeclarationsTemplate = R\"(${returnType} ${returnVariable};)\";\n      if ( dataType.starts_with( \"VULKAN_HPP_NAMESPACE\" ) )\n      {\n        return replaceWithMap( dataDeclarationsTemplate, { { \"returnType\", dataType }, { \"returnVariable\", returnVariable } } );\n      }\n      else\n      {\n        return replaceWithMap( dataDeclarationsTemplate, { { \"returnType\", returnType }, { \"returnVariable\", returnVariable } } );\n      }\n    }\n    else\n    {\n      std::string allocator = stripPrefix( dataTypes[0], \"VULKAN_HPP_NAMESPACE::\" ) + \"Allocator\";\n      if ( vectorParamIt->second.byStructure )\n      {\n        std::string vectorAllocator = ( ( flavourFlags & CommandFlavourFlagBits::withAllocator ) && !( flavourFlags & CommandFlavourFlagBits::unique ) )\n                                      ? ( \"( \" + startLowerCase( allocator ) + \" )\" )\n                                      : \"\";\n\n        std::string const dataDeclarationTemplate = R\"(${dataType} ${returnVariable}${vectorAllocator};\n    ${structType} ${structVariable};)\";\n\n        return replaceWithMap( dataDeclarationTemplate,\n                               { { \"dataType\", dataType },\n                                 { \"returnVariable\", returnVariable },\n                                 { \"structType\", stripPostfix( commandData.params[vectorParamIt->first].type.compose( \"VULKAN_HPP_NAMESPACE\" ), \"*\" ) },\n                                 { \"structVariable\", startLowerCase( stripPrefix( commandData.params[vectorParamIt->first].name, \"p\" ) ) },\n                                 { \"vectorAllocator\", stripPrefix( vectorAllocator, \",\" ) } } );\n      }\n      else\n      {\n        std::string vectorAllocator = ( ( flavourFlags & CommandFlavourFlagBits::withAllocator ) && !( flavourFlags & CommandFlavourFlagBits::unique ) )\n                                      ? ( \", \" + startLowerCase( allocator ) )\n                                      : \"\";\n        std::string vectorSize      = getVectorSize( commandData.params, vectorParams, returnParams[0], dataTypes[0], templatedParams );\n\n        std::string const dataDeclarationsTemplate = R\"(${dataType} ${returnVariable}( ${vectorSize}${vectorAllocator} );)\";\n\n        return replaceWithMap(\n          dataDeclarationsTemplate,\n          { { \"dataType\", dataType }, { \"returnVariable\", returnVariable }, { \"vectorAllocator\", vectorAllocator }, { \"vectorSize\", vectorSize } } );\n      }\n    }\n  }\n  else\n  {\n    assert( ( vectorParamIt == vectorParams.end() ) || ( flavourFlags & CommandFlavourFlagBits::singular ) );\n\n    std::string dataVariable = startLowerCase( stripPrefix( commandData.params[returnParams[0]].name, \"p\" ) );\n\n    std::string const dataDeclarationsTemplate = R\"(${returnType} ${returnVariable};\n    ${dataType} & ${dataVariable} = ${returnVariable}.template get<${dataType}>();)\";\n\n    return replaceWithMap( dataDeclarationsTemplate,\n                           { { \"dataType\", dataTypes[0] },\n                             { \"dataVariable\", dataVariable },\n                             { \"returnType\", ( commandData.returnType == \"void\" ) ? returnType : \"StructureChain<X, Y, Z...>\" },\n                             { \"returnVariable\", returnVariable } } );\n  }\n}\n\nstd::string VulkanHppGenerator::generateDataDeclarations2Returns( CommandData const &                       commandData,\n                                                                  std::vector<size_t> const &               returnParams,\n                                                                  std::map<size_t, VectorParamData> const & vectorParams,\n                                                                  CommandFlavourFlags                       flavourFlags,\n                                                                  bool                                      raii,\n                                                                  std::vector<std::string> const &          dataTypes,\n                                                                  std::string const &                       returnType,\n                                                                  std::string const &                       returnVariable ) const\n{\n  const bool chained       = flavourFlags & CommandFlavourFlagBits::chained;\n  const bool singular      = flavourFlags & CommandFlavourFlagBits::singular;\n  const bool withAllocator = flavourFlags & CommandFlavourFlagBits::withAllocator;\n\n  switch ( vectorParams.size() )\n  {\n    case 0:\n      assert( !singular && !chained );\n      {\n        std::string firstDataVariable  = startLowerCase( stripPrefix( commandData.params[returnParams[0]].name, \"p\" ) );\n        std::string secondDataVariable = startLowerCase( stripPrefix( commandData.params[returnParams[1]].name, \"p\" ) );\n\n        std::string const dataDeclarationTemplate = R\"(std::pair<${firstDataType},${secondDataType}> data_;\n    ${firstDataType} & ${firstDataVariable} = data_.first;\n    ${secondDataType} & ${secondDataVariable} = data_.second;)\";\n\n        return replaceWithMap( dataDeclarationTemplate,\n                               { { \"firstDataType\", dataTypes[0] },\n                                 { \"firstDataVariable\", firstDataVariable },\n                                 { \"secondDataType\", dataTypes[1] },\n                                 { \"secondDataVariable\", secondDataVariable } } );\n      }\n    case 1:\n      assert( ( returnParams[0] == vectorParams.begin()->second.lenParam ) && ( returnParams[1] == vectorParams.begin()->first ) && !singular );\n      {\n        std::string counterVariable = startLowerCase( stripPrefix( commandData.params[returnParams[0]].name, \"p\" ) );\n        if ( !chained )\n        {\n          std::string vectorAllocator = withAllocator ? ( \"( \" + startLowerCase( stripPrefix( dataTypes[1], \"VULKAN_HPP_NAMESPACE::\" ) ) + \"Allocator )\" ) : \"\";\n\n          std::string const dataDeclarationTemplate = R\"(${returnType} ${returnVariable}${vectorAllocator};\n    ${counterType} ${counterVariable};)\";\n\n          return replaceWithMap( dataDeclarationTemplate,\n                                 { { \"counterType\", dataTypes[0] },\n                                   { \"counterVariable\", counterVariable },\n                                   { \"returnType\", returnType },\n                                   { \"returnVariable\", returnVariable },\n                                   { \"vectorAllocator\", vectorAllocator } } );\n        }\n        else\n        {\n          std::string structureChainAllocator   = raii ? \"\" : \", StructureChainAllocator\";\n          std::string structureChainInitializer = withAllocator ? ( \"( structureChainAllocator )\" ) : \"\";\n          std::string vectorVariable            = startLowerCase( stripPrefix( commandData.params[returnParams[1]].name, \"p\" ) );\n\n          std::string const dataDeclarationTemplate =\n            R\"(std::vector<StructureChain${structureChainAllocator}> structureChains${structureChainInitializer};\n    std::vector<${vectorElementType}> ${vectorVariable};\n    ${counterType} ${counterVariable};)\";\n\n          return replaceWithMap( dataDeclarationTemplate,\n                                 {\n                                   { \"counterType\", dataTypes[0] },\n                                   { \"counterVariable\", counterVariable },\n                                   { \"structureChainAllocator\", structureChainAllocator },\n                                   { \"structureChainInitializer\", structureChainInitializer },\n                                   { \"vectorElementType\", dataTypes[1] },\n                                   { \"vectorVariable\", vectorVariable },\n                                 } );\n        }\n      }\n      break;\n    case 2:\n      assert( ( returnParams[0] == std::next( vectorParams.begin() )->first ) && !vectorParams.contains( returnParams[1] ) && !chained );\n      {\n        std::string firstDataVariable  = startLowerCase( stripPrefix( commandData.params[returnParams[0]].name, \"p\" ) );\n        std::string secondDataVariable = startLowerCase( stripPrefix( commandData.params[returnParams[1]].name, \"p\" ) );\n        if ( singular )\n        {\n          firstDataVariable = stripPluralS( firstDataVariable );\n\n          std::string const dataDeclarationTemplate = R\"(std::pair<${firstDataType},${secondDataType}> data_;\n    ${firstDataType} & ${firstDataVariable} = data_.first;\n    ${secondDataType} & ${secondDataVariable} = data_.second;)\";\n\n          return replaceWithMap( dataDeclarationTemplate,\n                                 { { \"firstDataType\", dataTypes[0] },\n                                   { \"firstDataVariable\", firstDataVariable },\n                                   { \"secondDataType\", dataTypes[1] },\n                                   { \"secondDataVariable\", secondDataVariable } } );\n        }\n        else\n        {\n          std::string allocatorType       = raii ? \"\" : ( startUpperCase( stripPrefix( dataTypes[0], \"VULKAN_HPP_NAMESPACE::\" ) ) + \"Allocator\" );\n          std::string allocateInitializer = withAllocator ? ( \", \" + startLowerCase( allocatorType ) ) : \"\";\n          if ( !raii )\n          {\n            allocatorType = \", \" + allocatorType;\n          }\n          std::string vectorSize = startLowerCase( stripPrefix( commandData.params[vectorParams.begin()->first].name, \"p\" ) ) + \".size()\";\n\n          std::string const dataDeclarationTemplate =\n            R\"(std::pair<std::vector<${firstDataType}${allocatorType}>,${secondDataType}> data_( std::piecewise_construct, std::forward_as_tuple( ${vectorSize}${allocateInitializer} ), std::forward_as_tuple( 0 ) );\n    std::vector<${firstDataType}${allocatorType}> & ${firstDataVariable} = data_.first;\n    ${secondDataType} & ${secondDataVariable} = data_.second;)\";\n\n          return replaceWithMap( dataDeclarationTemplate,\n                                 { { \"allocateInitializer\", allocateInitializer },\n                                   { \"allocatorType\", allocatorType },\n                                   { \"firstDataType\", dataTypes[0] },\n                                   { \"firstDataVariable\", firstDataVariable },\n                                   { \"secondDataType\", dataTypes[1] },\n                                   { \"secondDataVariable\", secondDataVariable },\n                                   { \"vectorSize\", vectorSize } } );\n        }\n      }\n      break;\n    default: assert( false ); return \"\";\n  }\n}\n\nstd::string VulkanHppGenerator::generateDataDeclarations3Returns( CommandData const &                       commandData,\n                                                                  std::vector<size_t> const &               returnParams,\n                                                                  std::map<size_t, VectorParamData> const & vectorParams,\n                                                                  CommandFlavourFlags                       flavourFlags,\n                                                                  bool                                      raii,\n                                                                  std::vector<std::string> const &          dataTypes ) const\n{\n  switch ( vectorParams.size() )\n  {\n    case 1:\n      {\n        assert( ( returnParams[1] == vectorParams.begin()->second.lenParam ) && ( returnParams[2] == vectorParams.begin()->first ) );\n\n        std::string valueVariable   = startLowerCase( stripPrefix( commandData.params[returnParams[0]].name, \"p\" ) );\n        std::string counterVariable = startLowerCase( stripPrefix( commandData.params[returnParams[1]].name, \"p\" ) );\n        std::string vectorVariable  = startLowerCase( stripPrefix( commandData.params[returnParams[2]].name, \"p\" ) );\n        std::string vectorAllocatorType, pairConstructor;\n        if ( !raii )\n        {\n          vectorAllocatorType = startUpperCase( stripPrefix( dataTypes[2], \"VULKAN_HPP_NAMESPACE::\" ) ) + \"Allocator\";\n          pairConstructor =\n            ( flavourFlags & CommandFlavourFlagBits::withAllocator )\n              ? ( \"( std::piecewise_construct, std::forward_as_tuple(), std::forward_as_tuple( \" + startLowerCase( vectorAllocatorType ) + \" ) )\" )\n              : \"\";\n          vectorAllocatorType = \", \" + vectorAllocatorType;\n        }\n\n        std::string const chainedDataDeclarationsTemplate =\n          R\"(std::pair<VULKAN_HPP_NAMESPACE::StructureChain<X,Y,Z...>,std::vector<${vectorElementType}${vectorAllocatorType}>> data_${pairConstructor};\n    ${valueType} & ${valueVariable} = data_.first.template get<${valueType}>();\n    std::vector<${vectorElementType}${vectorAllocatorType}> & ${vectorVariable} = data_.second;\n    ${counterType} ${counterVariable};)\";\n        std::string const dataDeclarationsTemplate =\n          R\"(std::pair<${valueType},std::vector<${vectorElementType}${vectorAllocatorType}>> data_${pairConstructor};\n    ${valueType} & ${valueVariable} = data_.first;\n    std::vector<${vectorElementType}${vectorAllocatorType}> & ${vectorVariable} = data_.second;\n    ${counterType} ${counterVariable};)\";\n\n        return replaceWithMap( ( flavourFlags & CommandFlavourFlagBits::chained ) ? chainedDataDeclarationsTemplate : dataDeclarationsTemplate,\n                               { { \"counterType\", dataTypes[1] },\n                                 { \"counterVariable\", counterVariable },\n                                 { \"vectorAllocatorType\", vectorAllocatorType },\n                                 { \"vectorElementType\", dataTypes[2] },\n                                 { \"vectorVariable\", vectorVariable },\n                                 { \"pairConstructor\", pairConstructor },\n                                 { \"valueType\", dataTypes[0] },\n                                 { \"valueVariable\", valueVariable } } );\n      }\n      break;\n    case 2:\n      {\n        assert( !( flavourFlags & CommandFlavourFlagBits::chained ) );\n        assert( ( returnParams[0] == vectorParams.begin()->second.lenParam ) && ( returnParams[1] == vectorParams.begin()->first ) &&\n                ( returnParams[2] == std::next( vectorParams.begin() )->first ) && ( returnParams[0] == std::next( vectorParams.begin() )->second.lenParam ) );\n\n        std::string counterVariable      = startLowerCase( stripPrefix( commandData.params[returnParams[0]].name, \"p\" ) );\n        std::string firstVectorVariable  = startLowerCase( stripPrefix( commandData.params[returnParams[1]].name, \"p\" ) );\n        std::string secondVectorVariable = startLowerCase( stripPrefix( commandData.params[returnParams[2]].name, \"p\" ) );\n        std::string firstVectorAllocatorType, secondVectorAllocatorType, pairConstructor;\n        if ( !raii )\n        {\n          firstVectorAllocatorType  = startUpperCase( stripPrefix( dataTypes[1], \"VULKAN_HPP_NAMESPACE::\" ) ) + \"Allocator\";\n          secondVectorAllocatorType = startUpperCase( stripPrefix( dataTypes[2], \"VULKAN_HPP_NAMESPACE::\" ) ) + \"Allocator\";\n          pairConstructor           = ( flavourFlags & CommandFlavourFlagBits::withAllocator )\n                                      ? ( \"( std::piecewise_construct, std::forward_as_tuple( \" + startLowerCase( firstVectorAllocatorType ) +\n                                \" ), std::forward_as_tuple( \" + startLowerCase( secondVectorAllocatorType ) + \" ) )\" )\n                                      : \"\";\n          firstVectorAllocatorType  = \", \" + firstVectorAllocatorType;\n          secondVectorAllocatorType = \", \" + secondVectorAllocatorType;\n        }\n\n        std::string const dataDeclarationsTemplate =\n          R\"(std::pair<std::vector<${firstVectorElementType}${firstVectorAllocatorType}>, std::vector<${secondVectorElementType}${secondVectorAllocatorType}>> data_${pairConstructor};\n    std::vector<${firstVectorElementType}${firstVectorAllocatorType}> & ${firstVectorVariable} = data_.first;\n    std::vector<${secondVectorElementType}${secondVectorAllocatorType}> & ${secondVectorVariable} = data_.second;\n    ${counterType} ${counterVariable};)\";\n\n        return replaceWithMap( dataDeclarationsTemplate,\n                               { { \"counterType\", dataTypes[0] },\n                                 { \"counterVariable\", counterVariable },\n                                 { \"firstVectorAllocatorType\", firstVectorAllocatorType },\n                                 { \"firstVectorElementType\", dataTypes[1] },\n                                 { \"firstVectorVariable\", firstVectorVariable },\n                                 { \"pairConstructor\", pairConstructor },\n                                 { \"secondVectorAllocatorType\", secondVectorAllocatorType },\n                                 { \"secondVectorElementType\", dataTypes[2] },\n                                 { \"secondVectorVariable\", secondVectorVariable } } );\n      }\n    default: assert( false ); return \"\";\n  }\n}\n\nstd::string VulkanHppGenerator::generateDataPreparation( CommandData const &                       commandData,\n                                                         size_t                                    initialSkipCount,\n                                                         std::vector<size_t> const &               returnParams,\n                                                         std::map<size_t, VectorParamData> const & vectorParams,\n                                                         std::set<size_t> const &                  templatedParams,\n                                                         CommandFlavourFlags                       flavourFlags,\n                                                         bool                                      enumerating,\n                                                         std::vector<std::string> const &          dataTypes ) const\n{\n  const bool chained  = flavourFlags & CommandFlavourFlagBits::chained;\n  const bool singular = flavourFlags & CommandFlavourFlagBits::singular;\n  const bool unique   = flavourFlags & CommandFlavourFlagBits::unique;\n\n  auto vectorParamIt = ( 1 < returnParams.size() ) ? vectorParams.find( returnParams[1] ) : vectorParams.end();\n  if ( vectorParamIt != vectorParams.end() )\n  {\n    assert( !unique );\n\n    std::string vectorName = startLowerCase( stripPrefix( commandData.params[vectorParamIt->first].name, \"p\" ) );\n\n    if ( chained )\n    {\n      assert( !singular );\n      assert( templatedParams.empty() );\n      assert( returnParams.size() == 2 );\n      assert( !vectorParams.contains( returnParams[0] ) );\n      assert( ( vectorParamIt != vectorParams.end() ) && ( vectorParamIt->second.lenParam == returnParams[0] ) );\n\n      std::string vectorElementType = stripPostfix( commandData.params[vectorParamIt->first].type.compose( \"VULKAN_HPP_NAMESPACE\" ), \" *\" );\n\n      if ( enumerating )\n      {\n        std::string const dataPreparationTemplate =\n          R\"(VULKAN_HPP_ASSERT( ${counterName} <= ${vectorName}.size() );\n      if ( ${counterName} < ${vectorName}.size() )\n      {\n        structureChains.resize( ${counterName} );\n      }\n      for ( ${counterType} i = 0; i < ${counterName}; i++ )\n      {\n        structureChains[i].template get<${vectorElementType}>() = ${vectorName}[i];\n      })\";\n\n        return replaceWithMap( dataPreparationTemplate,\n                               { { \"counterName\", startLowerCase( stripPrefix( commandData.params[vectorParamIt->second.lenParam].name, \"p\" ) ) },\n                                 { \"counterType\", commandData.params[vectorParamIt->second.lenParam].type.type },\n                                 { \"vectorElementType\", vectorElementType },\n                                 { \"vectorName\", vectorName } } );\n      }\n      else\n      {\n        std::string const dataPreparationTemplate =\n          R\"(for ( ${counterType} i = 0; i < ${counterName}; i++ )\n    {\n      structureChains[i].template get<${vectorElementType}>() = ${vectorName}[i];\n    })\";\n\n        return replaceWithMap( dataPreparationTemplate,\n                               { { \"counterName\", startLowerCase( stripPrefix( commandData.params[vectorParamIt->second.lenParam].name, \"p\" ) ) },\n                                 { \"counterType\", commandData.params[vectorParamIt->second.lenParam].type.type },\n                                 { \"vectorElementType\", vectorElementType },\n                                 { \"vectorName\", vectorName } } );\n      }\n    }\n    else if ( enumerating )\n    {\n      assert( !singular );\n      assert( ( vectorParams.size() != 2 ) ||\n              ( ( vectorParams.begin()->first == returnParams[1] ) && ( vectorParams.begin()->second.lenParam == returnParams[0] ) &&\n                ( std::next( vectorParams.begin() )->first == returnParams[2] ) &&\n                ( std::next( vectorParams.begin() )->second.lenParam == returnParams[0] ) ) );\n\n      std::string resizes;\n      for ( auto const & vp : vectorParams )\n      {\n        assert( std::any_of( returnParams.begin(), returnParams.end(), [&vp]( size_t rp ) { return rp == vp.first; } ) &&\n                std::any_of( returnParams.begin(), returnParams.end(), [&vp]( size_t rp ) { return rp == vp.second.lenParam; } ) );\n        resizes += startLowerCase( stripPrefix( commandData.params[vp.first].name, \"p\" ) ) + \".resize( \" +\n                   startLowerCase( stripPrefix( commandData.params[vp.second.lenParam].name, \"p\" ) ) + \" );\\n\";\n      }\n      resizes.pop_back();\n\n      std::string const dataPreparationTemplate =\n        R\"(VULKAN_HPP_ASSERT( ${counterName} <= ${vectorName}.size() );\n    if ( ${counterName} < ${vectorName}.size() )\n    {\n      ${resizes}\n    })\";\n\n      return replaceWithMap( dataPreparationTemplate,\n                             { { \"counterName\", startLowerCase( stripPrefix( commandData.params[vectorParamIt->second.lenParam].name, \"p\" ) ) },\n                               { \"resizes\", resizes },\n                               { \"vectorName\", vectorName } } );\n    }\n  }\n  else if ( unique && !singular && ( returnParams.size() == 1 ) && vectorParams.contains( returnParams[0] ) )\n  {\n    std::string className = initialSkipCount ? stripPrefix( commandData.params[initialSkipCount - 1].type.type, \"Vk\" ) : \"\";\n    std::string deleterDefinition, vectorName, vectorSize;\n    vectorParamIt = vectorParams.find( returnParams[0] );\n    if ( vectorParamIt != vectorParams.end() && vectorParamIt->second.byStructure )\n    {\n      deleterDefinition = \"detail::ObjectDestroy<\" + className + \", Dispatch> deleter( *this, allocator, d )\";\n      auto structIt     = m_structs.find( commandData.params[returnParams[0]].type.type );\n      assert( structIt != m_structs.end() );\n      vectorName = startLowerCase( stripPrefix( structIt->second.members.back().name, \"p\" ) );\n      vectorSize = vectorName + \".size()\";\n    }\n    else\n    {\n      std::vector<std::string> lenParts = tokenize( commandData.params[returnParams[0]].lenExpression, \"->\" );\n      switch ( lenParts.size() )\n      {\n        case 1: deleterDefinition = \"detail::ObjectDestroy<\" + className + \", Dispatch> deleter( *this, allocator, d )\"; break;\n        case 2:\n          {\n            auto vpiIt = vectorParams.find( returnParams[0] );\n            assert( vpiIt != vectorParams.end() );\n            std::string poolType, poolName;\n            std::tie( poolType, poolName ) = getPoolTypeAndName( commandData.params[vpiIt->second.lenParam].type.type );\n            assert( !poolType.empty() );\n            poolType          = stripPrefix( poolType, \"Vk\" );\n            poolName          = startLowerCase( stripPrefix( lenParts[0], \"p\" ) ) + \".\" + poolName;\n            deleterDefinition = \"detail::PoolFree<\" + className + \", \" + poolType + \", Dispatch> deleter( *this, \" + poolName + \", d )\";\n          }\n          break;\n        default: assert( false ); break;\n      }\n      vectorName = startLowerCase( stripPrefix( commandData.params[returnParams[0]].name, \"p\" ) );\n      vectorSize = getVectorSize( commandData.params, vectorParams, returnParams[0], commandData.params[returnParams[0]].type.type, templatedParams );\n    }\n\n    std::string handleType       = stripPrefix( dataTypes[0], \"VULKAN_HPP_NAMESPACE::\" );\n    std::string vectorAllocator  = ( flavourFlags & CommandFlavourFlagBits::withAllocator ) ? ( \"( \" + startLowerCase( handleType ) + \"Allocator )\" ) : \"\";\n    std::string elementName      = stripPluralS( vectorName );\n    std::string uniqueVectorName = \"unique\" + startUpperCase( vectorName );\n\n    std::string const dataPreparationTemplate =\n      R\"(std::vector<UniqueHandle<VULKAN_HPP_NAMESPACE::${handleType}, Dispatch>, ${handleType}Allocator> ${uniqueVectorName}${vectorAllocator};\n    ${uniqueVectorName}.reserve( ${vectorSize} );\n    ${deleterDefinition};\n    for ( auto const & ${elementName} : ${vectorName} )\n    {\n      ${uniqueVectorName}.push_back( UniqueHandle<${handleType}, Dispatch>( ${elementName}, deleter ) );\n    })\";\n\n    return replaceWithMap( dataPreparationTemplate,\n                           { { \"elementName\", elementName },\n                             { \"deleterDefinition\", deleterDefinition },\n                             { \"handleType\", handleType },\n                             { \"uniqueVectorName\", uniqueVectorName },\n                             { \"vectorAllocator\", vectorAllocator },\n                             { \"vectorName\", vectorName },\n                             { \"vectorSize\", vectorSize } } );\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateDataSizeChecks( CommandData const &                       commandData,\n                                                        std::vector<size_t> const &               returnParams,\n                                                        std::vector<std::string> const &          returnParamTypes,\n                                                        std::map<size_t, VectorParamData> const & vectorParams,\n                                                        std::set<size_t> const &                  templatedParams,\n                                                        bool                                      singular ) const\n{\n  assert( returnParams.size() == returnParamTypes.size() );\n  std::string dataSizeChecks;\n  if ( !singular )\n  {\n    const std::string dataSizeCheckTemplate = R\"(    VULKAN_HPP_ASSERT( ${dataSize} % sizeof( ${dataType} ) == 0 );)\";\n    for ( size_t i = 0; i < returnParams.size(); i++ )\n    {\n      auto vectorParamIt = vectorParams.find( returnParams[i] );\n      if ( ( vectorParamIt != vectorParams.end() ) && templatedParams.contains( returnParams[i] ) &&\n           std::none_of( returnParams.begin(), returnParams.end(), [&vectorParamIt]( size_t rp ) noexcept { return rp == vectorParamIt->second.lenParam; } ) )\n      {\n        dataSizeChecks += replaceWithMap( dataSizeCheckTemplate,\n                                          { { \"dataSize\", commandData.params[vectorParamIt->second.lenParam].name }, { \"dataType\", returnParamTypes[i] } } );\n      }\n    }\n  }\n\n  return dataSizeChecks;\n}\n\nstd::string VulkanHppGenerator::generateDebugReportObjectType( std::string const & objectType ) const\n{\n  std::string debugReportObjectType = objectType;\n  debugReportObjectType             = debugReportObjectType.replace( 3, 0, \"DEBUG_REPORT_\" ) + \"_EXT\";\n  auto enumIt                       = m_enums.find( \"VkDebugReportObjectTypeEXT\" );\n  assert( enumIt != m_enums.end() );\n  return contains( enumIt->second.values, debugReportObjectType ) ? generateEnumValueName( enumIt->first, debugReportObjectType, false ) : \"eUnknown\";\n}\n\nstd::string VulkanHppGenerator::generateDecoratedReturnType( CommandData const &                       commandData,\n                                                             std::vector<size_t> const &               returnParams,\n                                                             std::map<size_t, VectorParamData> const & vectorParams,\n                                                             CommandFlavourFlags                       flavourFlags,\n                                                             bool                                      raii,\n                                                             std::string const &                       returnType ) const\n{\n  const bool chained = flavourFlags & CommandFlavourFlagBits::chained;\n#if !defined( NDEBUG )\n  const bool unique = flavourFlags & CommandFlavourFlagBits::unique;\n#endif\n  assert( !( chained && unique ) );\n\n  std::string decoratedReturnType;\n  if ( ( 1 < commandData.successCodes.size() ) && returnParams.empty() && !chained )\n  {\n    assert( ( commandData.returnType == \"VkResult\" ) && !unique );\n    decoratedReturnType = \"VULKAN_HPP_NAMESPACE::Result\";\n  }\n  else if ( ( commandData.returnType != \"VkResult\" ) && ( commandData.returnType != \"void\" ) )\n  {\n    assert( returnParams.empty() && !chained && !unique );\n    if ( commandData.returnType.starts_with( \"Vk\" ) )\n    {\n      decoratedReturnType = generateNamespacedType( commandData.returnType );\n    }\n    else if ( commandData.returnType.starts_with( \"PFN_vk\" ) )\n    {\n      decoratedReturnType = \"VULKAN_HPP_NAMESPACE::PFN_\" + stripPrefix( commandData.returnType, \"PFN_vk\" );\n    }\n    else\n    {\n      decoratedReturnType = commandData.returnType;\n    }\n  }\n  else if ( ( commandData.returnType == \"void\" ) ||\n            ( ( commandData.returnType == \"VkResult\" ) && ( commandData.successCodes.size() == 1 ) && ( commandData.errorCodes.empty() || raii ) ) )\n  {\n    assert( !unique );\n    assert( ( commandData.returnType != \"void\" ) || ( returnParams.size() <= 2 ) );\n    decoratedReturnType = returnType;\n  }\n  else\n  {\n    assert( commandData.returnType == \"VkResult\" );\n    assert( !commandData.successCodes.empty() && ( commandData.successCodes[0] == \"VK_SUCCESS\" ) );\n    if ( ( commandData.successCodes.size() == 1 ) || ( ( commandData.successCodes.size() == 2 ) && ( commandData.successCodes[1] == \"VK_INCOMPLETE\" ) ) )\n    {\n      decoratedReturnType = raii ? returnType : ( \"typename ResultValueType<\" + returnType + \">::type\" );\n    }\n    else if ( !commandData.errorCodes.empty() && ( 1 < commandData.successCodes.size() ) &&\n              ( ( returnParams.size() == 1 ) ||\n                ( ( returnParams.size() == 2 ) && ( vectorParams.empty() || ( ( vectorParams.size() == 1 ) && ( commandData.successCodes.size() == 3 ) &&\n                                                                              ( commandData.successCodes[1] == \"VK_INCOMPLETE\" ) ) ) ) ) )\n    {\n      decoratedReturnType = ( raii ? \"std::pair<VULKAN_HPP_NAMESPACE::Result, \" : \"ResultValue<\" ) + returnType + \">\";\n    }\n    else\n    {\n      assert( false );\n    }\n  }\n  return decoratedReturnType;\n}\n\nstd::string VulkanHppGenerator::generateDeprecatedConstructors( std::string const & name ) const\n{\n  std::string str;\n  if ( name == \"VkAllocationCallbacks\" )\n  {\n    // To be removed around December 2025\n    str = R\"(\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic push\n#  if defined( __clang__ )\n#    pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  endif\n#  pragma GCC diagnostic ignored \"-Wcast-function-type\"\n#endif\n    VULKAN_HPP_DEPRECATED( \"This constructor is deprecated. Use the one taking function pointer types from the vk-namespace instead.\" )\n    AllocationCallbacks( void *                               pUserData_,\n                         PFN_vkAllocationFunction             pfnAllocation_,\n                         PFN_vkReallocationFunction           pfnReallocation_       = {},\n                         PFN_vkFreeFunction                   pfnFree_               = {},\n                         PFN_vkInternalAllocationNotification pfnInternalAllocation_ = {},\n                         PFN_vkInternalFreeNotification       pfnInternalFree_       = {} ) VULKAN_HPP_NOEXCEPT\n      : AllocationCallbacks( pUserData_,\n                             reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_AllocationFunction>( pfnAllocation_ ),\n                             reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_ReallocationFunction>( pfnReallocation_ ),\n                             reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_FreeFunction>( pfnFree_ ),\n                             reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_InternalAllocationNotification>( pfnInternalAllocation_ ),\n                             reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_InternalFreeNotification>( pfnInternalFree_ ) )\n    {\n    }\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic pop\n#endif\n)\";\n  }\n  else if ( name == \"VkDebugReportCallbackCreateInfoEXT\" )\n  {\n    // To be removed around December 2025\n    str = R\"(\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic push\n#  if defined( __clang__ )\n#    pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  endif\n#  pragma GCC diagnostic ignored \"-Wcast-function-type\"\n#endif\n    VULKAN_HPP_DEPRECATED( \"This constructor is deprecated. Use the one taking function pointer types from the vk-namespace instead.\" )\n    DebugReportCallbackCreateInfoEXT( VULKAN_HPP_NAMESPACE::DebugReportFlagsEXT flags_,\n                                      PFN_vkDebugReportCallbackEXT              pfnCallback_,\n                                      void *                                    pUserData_   = {},\n                                      const void *                              pNext_       = nullptr ) VULKAN_HPP_NOEXCEPT\n      : DebugReportCallbackCreateInfoEXT( flags_, reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_DebugReportCallbackEXT>( pfnCallback_ ), pUserData_, pNext_ )\n    {\n    }\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic pop\n#endif\n)\";\n  }\n  else if ( name == \"VkDebugUtilsMessengerCreateInfoEXT\" )\n  {\n    // To be removed around December 2025\n    str = R\"(\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic push\n#  if defined( __clang__ )\n#    pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  endif\n#  pragma GCC diagnostic ignored \"-Wcast-function-type\"\n#endif\n    VULKAN_HPP_DEPRECATED( \"This constructor is deprecated. Use the one taking function pointer types from the vk-namespace instead.\" )\n    DebugUtilsMessengerCreateInfoEXT( VULKAN_HPP_NAMESPACE::DebugUtilsMessengerCreateFlagsEXT flags_,\n                                      VULKAN_HPP_NAMESPACE::DebugUtilsMessageSeverityFlagsEXT messageSeverity_,\n                                      VULKAN_HPP_NAMESPACE::DebugUtilsMessageTypeFlagsEXT     messageType_,\n                                      PFN_vkDebugUtilsMessengerCallbackEXT                    pfnUserCallback_,\n                                      void *                                                  pUserData_       = {},\n                                      const void *                                            pNext_ = nullptr ) VULKAN_HPP_NOEXCEPT\n      : DebugUtilsMessengerCreateInfoEXT( flags_, messageSeverity_, messageType_, reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_DebugUtilsMessengerCallbackEXT>( pfnUserCallback_ ), pUserData_, pNext_ )\n    {\n    }\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic pop\n#endif\n)\";\n  }\n  else if ( name == \"VkDeviceDeviceMemoryReportCreateInfoEXT\" )\n  {\n    // To be removed around December 2025\n    str = R\"(\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic push\n#  if defined( __clang__ )\n#    pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  endif\n#  pragma GCC diagnostic ignored \"-Wcast-function-type\"\n#endif\n    VULKAN_HPP_DEPRECATED( \"This constructor is deprecated. Use the one taking function pointer types from the vk-namespace instead.\" )\n    DeviceDeviceMemoryReportCreateInfoEXT( VULKAN_HPP_NAMESPACE::DeviceMemoryReportFlagsEXT flags_,\n                                           PFN_vkDeviceMemoryReportCallbackEXT              pfnUserCallback_,\n                                           void *                                           pUserData_       = {},\n                                           const void *                                     pNext_ = nullptr ) VULKAN_HPP_NOEXCEPT\n      : DeviceDeviceMemoryReportCreateInfoEXT( flags_, reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_DeviceMemoryReportCallbackEXT>( pfnUserCallback_ ), pUserData_, pNext_ )\n    {\n    }\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic pop\n#endif\n)\";\n  }\n  else if ( name == \"DirectDriverLoadingInfoLUNARG\" )\n  {\n    // To be removed around December 2025\n    str = R\"(\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic push\n#  if defined( __clang__ )\n#    pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  endif\n#  pragma GCC diagnostic ignored \"-Wcast-function-type\"\n#endif\n    VULKAN_HPP_DEPRECATED( \"This constructor is deprecated. Use the one taking function pointer types from the vk-namespace instead.\" )\n    DirectDriverLoadingInfoLUNARG( VULKAN_HPP_NAMESPACE::DirectDriverLoadingFlagsLUNARG flags_,\n                                   PFN_vkGetInstanceProcAddrLUNARG                      pfnGetInstanceProcAddr_,\n                                   void *                                               pNext_ = nullptr ) VULKAN_HPP_NOEXCEPT\n      : DirectDriverLoadingInfoLUNARG( flags_, reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_GetInstanceProcAddrLUNARG>( pfnGetInstanceProcAddr_ ), pNext_ )\n    {\n    }\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic pop\n#endif\n)\";\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateDeprecatedStructSetters( std::string const & name ) const\n{\n  std::string str;\n  if ( name == \"VkAllocationCallbacks\" )\n  {\n    // To be removed around December 2025\n    str = R\"(\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic push\n#  if defined( __clang__ )\n#    pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  endif\n#  pragma GCC diagnostic ignored \"-Wcast-function-type\"\n#endif\n    VULKAN_HPP_DEPRECATED( \"This setter is deprecated. Use the one taking a function pointer type from the vk-namespace instead.\" )\n    AllocationCallbacks & setPfnAllocation( PFN_vkAllocationFunction pfnAllocation_ ) VULKAN_HPP_NOEXCEPT\n    {\n      return setPfnAllocation( reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_AllocationFunction>( pfnAllocation_ ) );\n    }\n\n    VULKAN_HPP_DEPRECATED( \"This setter is deprecated. Use the one taking a function pointer type from the vk-namespace instead.\" )\n    AllocationCallbacks & setPfnReallocation( PFN_vkReallocationFunction pfnReallocation_ ) VULKAN_HPP_NOEXCEPT\n    {\n      return setPfnReallocation( reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_ReallocationFunction>( pfnReallocation_ ) );\n    }\n\n    VULKAN_HPP_DEPRECATED( \"This setter is deprecated. Use the one taking a function pointer type from the vk-namespace instead.\" )\n    AllocationCallbacks & setPfnInternalAllocation( PFN_vkInternalAllocationNotification pfnInternalAllocation_ ) VULKAN_HPP_NOEXCEPT\n    {\n      return setPfnInternalAllocation( reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_InternalAllocationNotification>( pfnInternalAllocation_ ) );\n    }\n\n    VULKAN_HPP_DEPRECATED( \"This setter is deprecated. Use the one taking a function pointer type from the vk-namespace instead.\" )\n    AllocationCallbacks & setPfnInternalFree( PFN_vkInternalFreeNotification pfnInternalFree_ ) VULKAN_HPP_NOEXCEPT\n    {\n      return setPfnInternalFree( reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_InternalFreeNotification>( pfnInternalFree_ ) );\n    }\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic pop\n#endif\n)\";\n  }\n  else if ( name == \"VkDebugReportCallbackCreateInfoEXT\" )\n  {\n    // To be removed around December 2025\n    str = R\"(\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic push\n#  if defined( __clang__ )\n#    pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  endif\n#  pragma GCC diagnostic ignored \"-Wcast-function-type\"\n#endif\n    VULKAN_HPP_DEPRECATED( \"This setter is deprecated. Use the one taking a function pointer type from the vk-namespace instead.\" )\n    DebugReportCallbackCreateInfoEXT & setPfnCallback( PFN_vkDebugReportCallbackEXT pfnCallback_ ) VULKAN_HPP_NOEXCEPT\n    {\n      return setPfnCallback( reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_DebugReportCallbackEXT>( pfnCallback_ ) );\n    }\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic pop\n#endif\n)\";\n  }\n  else if ( name == \"VkDebugUtilsMessengerCreateInfoEXT\" )\n  {\n    // To be removed around December 2025\n    str = R\"(\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic push\n#  if defined( __clang__ )\n#    pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  endif\n#  pragma GCC diagnostic ignored \"-Wcast-function-type\"\n#endif\n    VULKAN_HPP_DEPRECATED( \"This setter is deprecated. Use the one taking a function pointer type from the vk-namespace instead.\" )\n    DebugUtilsMessengerCreateInfoEXT & setPfnUserCallback( PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback_ ) VULKAN_HPP_NOEXCEPT\n    {\n      return setPfnUserCallback( reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_DebugUtilsMessengerCallbackEXT>( pfnUserCallback_ ) );\n    }\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic pop\n#endif\n)\";\n  }\n  else if ( name == \"VkDeviceDeviceMemoryReportCreateInfoEXT\" )\n  {\n    // To be removed around December 2025\n    str = R\"(\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic push\n#  if defined( __clang__ )\n#    pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  endif\n#  pragma GCC diagnostic ignored \"-Wcast-function-type\"\n#endif\n    VULKAN_HPP_DEPRECATED( \"This setter is deprecated. Use the one taking a function pointer type from the vk-namespace instead.\" )\n    DeviceDeviceMemoryReportCreateInfoEXT & setPfnUserCallback( PFN_vkDeviceMemoryReportCallbackEXT pfnUserCallback_ ) VULKAN_HPP_NOEXCEPT\n    {\n      return setPfnUserCallback( reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_DeviceMemoryReportCallbackEXT>( pfnUserCallback_ ) );\n    }\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic pop\n#endif\n)\";\n  }\n  else if ( name == \"DirectDriverLoadingInfoLUNARG\" )\n  {\n    // To be removed around December 2025\n    str = R\"(\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic push\n#  if defined( __clang__ )\n#    pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  endif\n#  pragma GCC diagnostic ignored \"-Wcast-function-type\"\n#endif\n    VULKAN_HPP_DEPRECATED( \"This setter is deprecated. Use the one taking a function pointer type from the vk-namespace instead.\" )\n    DirectDriverLoadingInfoLUNARG & setPfnGetInstanceProcAddr( PFN_vkGetInstanceProcAddrLUNARG pfnGetInstanceProcAddr_ ) VULKAN_HPP_NOEXCEPT\n    {\n      return setPfnGetInstanceProcAddr( reinterpret_cast<VULKAN_HPP_NAMESPACE::PFN_GetInstanceProcAddLUNARG>( pfnGetInstanceProcAddr_ ) );\n    }\n#if defined( __clang__ ) || defined( __GNUC__ )\n#  pragma GCC diagnostic pop\n#endif\n)\";\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateDispatchLoaderDynamic() const\n{\n  const std::string dispatchLoaderDynamicTemplate = R\"(\n  using PFN_dummy = void ( * )();\n\n  class DispatchLoaderDynamic : public DispatchLoaderBase\n  {\n  public:\n${commandMembers}\n\n  public:\n    DispatchLoaderDynamic() VULKAN_HPP_NOEXCEPT = default;\n    DispatchLoaderDynamic( DispatchLoaderDynamic const & rhs ) VULKAN_HPP_NOEXCEPT = default;\n\n    DispatchLoaderDynamic(PFN_vkGetInstanceProcAddr getInstanceProcAddr) VULKAN_HPP_NOEXCEPT\n    {\n      init(getInstanceProcAddr);\n    }\n\n    // This interface does not require a linked vulkan library.\n    DispatchLoaderDynamic( VkInstance                instance,\n                           PFN_vkGetInstanceProcAddr getInstanceProcAddr,\n                           VkDevice                  device            = {},\n                           PFN_vkGetDeviceProcAddr   getDeviceProcAddr = nullptr ) VULKAN_HPP_NOEXCEPT\n    {\n      init( instance, getInstanceProcAddr, device, getDeviceProcAddr );\n    }\n\n    template <typename DynamicLoader\n#if VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL\n      = VULKAN_HPP_NAMESPACE::detail::DynamicLoader\n#endif\n    >\n    void init()\n    {\n      static DynamicLoader dl;\n      init( dl );\n    }\n\n    template <typename DynamicLoader>\n    void init( DynamicLoader const & dl ) VULKAN_HPP_NOEXCEPT\n    {\n      PFN_vkGetInstanceProcAddr getInstanceProcAddr = dl.template getProcAddress<PFN_vkGetInstanceProcAddr>( \"vkGetInstanceProcAddr\" );\n      init( getInstanceProcAddr );\n    }\n\n    void init( PFN_vkGetInstanceProcAddr getInstanceProcAddr ) VULKAN_HPP_NOEXCEPT\n    {\n      VULKAN_HPP_ASSERT(getInstanceProcAddr);\n\n      vkGetInstanceProcAddr = getInstanceProcAddr;\n\n${initialCommandAssignments}\n    }\n\n    // This interface does not require a linked vulkan library.\n    void init( VkInstance                instance,\n               PFN_vkGetInstanceProcAddr getInstanceProcAddr,\n               VkDevice                  device              = {},\n               PFN_vkGetDeviceProcAddr /*getDeviceProcAddr*/ = nullptr ) VULKAN_HPP_NOEXCEPT\n    {\n      VULKAN_HPP_ASSERT(instance && getInstanceProcAddr);\n      vkGetInstanceProcAddr = getInstanceProcAddr;\n      init( VULKAN_HPP_NAMESPACE::Instance(instance) );\n      if (device)\n      {\n        init( VULKAN_HPP_NAMESPACE::Device(device) );\n      }\n    }\n\n    void init( VULKAN_HPP_NAMESPACE::Instance instanceCpp ) VULKAN_HPP_NOEXCEPT\n    {\n      VkInstance instance = static_cast<VkInstance>(instanceCpp);\n\n${instanceCommandAssignments}\n    }\n\n    void init( VULKAN_HPP_NAMESPACE::Device deviceCpp ) VULKAN_HPP_NOEXCEPT\n    {\n      VkDevice device = static_cast<VkDevice>(deviceCpp);\n\n${deviceCommandAssignments}\n    }\n\n    template <typename DynamicLoader>\n    void init(VULKAN_HPP_NAMESPACE::Instance const & instance, VULKAN_HPP_NAMESPACE::Device const & device, DynamicLoader const & dl) VULKAN_HPP_NOEXCEPT\n    {\n      PFN_vkGetInstanceProcAddr getInstanceProcAddr = dl.template getProcAddress<PFN_vkGetInstanceProcAddr>(\"vkGetInstanceProcAddr\");\n      PFN_vkGetDeviceProcAddr getDeviceProcAddr = dl.template getProcAddress<PFN_vkGetDeviceProcAddr>(\"vkGetDeviceProcAddr\");\n      init(static_cast<VkInstance>(instance), getInstanceProcAddr, static_cast<VkDevice>(device), device ? getDeviceProcAddr : nullptr);\n    }\n\n    template <typename DynamicLoader\n#if VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL\n      = VULKAN_HPP_NAMESPACE::detail::DynamicLoader\n#endif\n    >\n    void init(VULKAN_HPP_NAMESPACE::Instance const & instance, VULKAN_HPP_NAMESPACE::Device const & device) VULKAN_HPP_NOEXCEPT\n    {\n      static DynamicLoader dl;\n      init(instance, device, dl);\n    }\n  };)\";\n\n  std::string           commandMembers, deviceCommandAssignments, initialCommandAssignments, instanceCommandAssignments;\n  std::set<std::string> listedCommands;  // some commands are listed with more than one extension!\n  for ( auto const & feature : m_features )\n  {\n    appendDispatchLoaderDynamicCommands(\n      feature.requireData, listedCommands, feature.name, commandMembers, initialCommandAssignments, instanceCommandAssignments, deviceCommandAssignments );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    appendDispatchLoaderDynamicCommands(\n      extension.requireData, listedCommands, extension.name, commandMembers, initialCommandAssignments, instanceCommandAssignments, deviceCommandAssignments );\n  }\n\n  return replaceWithMap( dispatchLoaderDynamicTemplate,\n                         { { \"commandMembers\", commandMembers },\n                           { \"deviceCommandAssignments\", deviceCommandAssignments },\n                           { \"initialCommandAssignments\", initialCommandAssignments },\n                           { \"instanceCommandAssignments\", instanceCommandAssignments } } );\n}\n\nstd::string VulkanHppGenerator::generateDispatchLoaderStatic() const\n{\n  const std::string dispatchLoaderStaticTemplate = R\"(\n#if !defined( VK_NO_PROTOTYPES ) || ( defined( VULKAN_HPP_DISPATCH_LOADER_DYNAMIC ) && ( VULKAN_HPP_DISPATCH_LOADER_DYNAMIC == 0 ) )\n  class DispatchLoaderStatic : public DispatchLoaderBase\n  {\n  public:\n${commands}\n  };\n\n  inline DispatchLoaderStatic & getDispatchLoaderStatic()\n  {\n    static DispatchLoaderStatic dls;\n    return dls;\n  }\n#endif\n)\";\n\n  std::string           commands;\n  std::set<std::string> listedCommands;\n  for ( auto const & feature : m_features )\n  {\n    commands += generateDispatchLoaderStaticCommands( feature.requireData, listedCommands, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    commands += generateDispatchLoaderStaticCommands( extension.requireData, listedCommands, extension.name );\n  }\n\n  return replaceWithMap( dispatchLoaderStaticTemplate, { { \"commands\", commands } } );\n}\n\nstd::string VulkanHppGenerator::generateDestroyCommand( std::string const & name, CommandData const & commandData ) const\n{\n  // special handling for destroy functions, filter out alias functions\n  std::string commandName = generateCommandName( name, commandData.params, 1 );\n  if ( m_commands.contains( name ) && ( ( ( name.substr( 2, 7 ) == \"Destroy\" ) && ( commandName != \"destroy\" ) ) || ( name.substr( 2, 4 ) == \"Free\" ) ||\n                                        ( name == \"vkReleasePerformanceConfigurationINTEL\" ) ) )\n  {\n    assert( 1 < commandData.params.size() );\n    // make sure, the object to destroy/free/release is not optional in the shortened version!\n    CommandData localCommandData        = commandData;\n    localCommandData.params[1].optional = false;\n\n    std::string destroyCommandString = generateCommand( name, localCommandData, 1, false, false );\n    std::string shortenedName;\n    if ( name.substr( 2, 7 ) == \"Destroy\" )\n    {\n      shortenedName = \"destroy\";\n    }\n    else if ( name.substr( 2, 4 ) == \"Free\" )\n    {\n      // enclose \"free\" in parenthesis to prevent interference with MSVC debug free\n      shortenedName = \"( free )\";\n    }\n    else\n    {\n      assert( name == \"vkReleasePerformanceConfigurationINTEL\" );\n      shortenedName = \"release\";\n    }\n    size_t pos = destroyCommandString.find( commandName );\n    while ( pos != std::string::npos )\n    {\n      destroyCommandString.replace( pos, commandName.length(), shortenedName );\n      pos = destroyCommandString.find( commandName, pos );\n    }\n    // we need to remove the default argument for the first argument, to prevent ambiguities!\n    assert( 1 < localCommandData.params.size() );\n    pos = destroyCommandString.find( localCommandData.params[1].name );  // skip the standard version of the function\n    assert( pos != std::string::npos );\n    pos = destroyCommandString.find( localCommandData.params[1].name,\n                                     pos + 1 );  // get the argument to destroy in the advanced version\n    assert( pos != std::string::npos );\n    pos = destroyCommandString.find( \" VULKAN_HPP_DEFAULT_ARGUMENT_ASSIGNMENT\", pos );\n    if ( pos != std::string::npos )\n    {\n      destroyCommandString.erase( pos, strlen( \" VULKAN_HPP_DEFAULT_ARGUMENT_ASSIGNMENT\" ) );\n    }\n    return \"\\n\" + destroyCommandString;\n  }\n  return \"\";\n}\n\nstd::string VulkanHppGenerator::generateDispatchLoaderDynamicCommandAssignment( std::string const & commandName,\n                                                                                std::string const & aliasName,\n                                                                                std::string const & firstArg ) const\n{\n  if ( commandName == \"vkGetInstanceProcAddr\" )\n  {\n    // Don't overwite vkGetInstanceProcAddr with NULL.\n    return \"\";\n  }\n  std::string str = \"      \" + commandName + \" = PFN_\" + commandName + \"( vkGet\" + ( ( firstArg == \"device\" ) ? \"Device\" : \"Instance\" ) + \"ProcAddr( \" +\n                    firstArg + \", \\\"\" + commandName + \"\\\" ) );\\n\";\n  // if this is an alias'ed function, use it as a fallback for the original one\n  if ( commandName != aliasName )\n  {\n    str += \"      if ( !\" + aliasName + \" ) \" + aliasName + \" = \" + commandName + \";\\n\";\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateDispatchLoaderStaticCommands( std::vector<RequireData> const & requireData,\n                                                                      std::set<std::string> &          listedCommands,\n                                                                      std::string const &              title ) const\n{\n  std::string str;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & command : require.commands )\n    {\n      // some commands are listed for multiple extensions !\n      if ( listedCommands.insert( command.name ).second )\n      {\n        auto commandIt = findByNameOrAlias( m_commands, command.name );\n        assert( commandIt != m_commands.end() );\n\n        str += \"\\n\";\n        std::string parameterList, parameters;\n        assert( !commandIt->second.params.empty() );\n        for ( auto param : commandIt->second.params )\n        {\n          parameterList += param.type.compose( \"\" ) + \" \" + param.name + generateCArraySizes( param.arraySizes ) + \", \";\n          parameters += param.name + \", \";\n        }\n        assert( parameterList.ends_with( \", \" ) && parameters.ends_with( \", \" ) );\n        parameterList.resize( parameterList.size() - 2 );\n        parameters.resize( parameters.size() - 2 );\n\n        const std::string commandTemplate = R\"(\n    ${returnType} ${commandName}( ${parameterList} ) const VULKAN_HPP_NOEXCEPT\n    {\n      return ::${commandName}( ${parameters} );\n    }\n)\";\n\n        str += replaceWithMap( commandTemplate,\n                               { { \"commandName\", command.name },\n                                 { \"parameterList\", parameterList },\n                                 { \"parameters\", parameters },\n                                 { \"returnType\", commandIt->second.returnType } } );\n      }\n    }\n  }\n  return addTitleAndProtection( title, str );\n}\n\nstd::string VulkanHppGenerator::generateEnum( std::pair<std::string, EnumData> const & enumData, std::string const & surroundingProtect ) const\n{\n  std::string baseType, bitmask;\n  if ( enumData.second.isBitmask )\n  {\n    auto bitmaskIt =\n      std::find_if( m_bitmasks.begin(), m_bitmasks.end(), [&enumData]( auto const & bitmask ) { return bitmask.second.require == enumData.first; } );\n    assert( bitmaskIt != m_bitmasks.end() );\n    baseType = \" : \" + bitmaskIt->first;\n    bitmask  = generateBitmask( bitmaskIt, surroundingProtect );\n  }\n\n  std::string                        enumValues, previousEnter, previousLeave;\n  std::map<std::string, std::string> valueToNameMap;\n  for ( auto const & value : enumData.second.values )\n  {\n    if ( value.supported )\n    {\n      std::string valueName = generateEnumValueName( enumData.first, value.name, enumData.second.isBitmask );\n      checkForError( valueToNameMap.insert( { valueName, value.name } ).second,\n                     value.xmlLine,\n                     \"generated enum value name <\" + valueName + \"> already listed for enum <\" + enumData.first + \">\" );\n\n      // if the value's protect differs from the surrounding protect, generate protection code\n      std::string enter, leave;\n      if ( !value.protect.empty() && ( value.protect != surroundingProtect ) )\n      {\n        tie( enter, leave ) = generateProtection( value.protect );\n      }\n      if ( previousEnter != enter )\n      {\n        enumValues += previousLeave + enter;\n      }\n      enumValues += \"    \" + valueName;\n      if ( value.deprecated )\n      {\n        enumValues += \" VULKAN_HPP_DEPRECATED_17( \\\"\" + valueName + \" is deprecated, but no reason was given in the API XML\\\" )\";\n      }\n      enumValues += \" = \" + value.name + \",\\n\";\n\n      for ( auto const & valueAlias : value.aliases )\n      {\n        // only generate supported aliases\n        if ( valueAlias.supported )\n        {\n          std::string enumName = enumData.first;\n          for ( auto aliasIt = enumData.second.aliases.begin(); ( aliasIt != enumData.second.aliases.end() ) && ( enumName == enumData.first ); ++aliasIt )\n          {\n            auto        enumAliasIt = enumData.second.aliases.begin();\n            std::string enumTag     = findTag( enumData.first );\n            std::string aliasTag    = findTag( enumAliasIt->first );\n            std::string valueTag    = findTag( valueAlias.name );\n            if ( ( stripPostfix( enumData.first, enumTag ) == stripPostfix( enumAliasIt->first, aliasTag ) ) && ( aliasTag == valueTag ) )\n            {\n              enumName = enumAliasIt->first;\n            }\n          }\n\n          std::string                                        aliasName = generateEnumValueName( enumName, valueAlias.name, enumData.second.isBitmask );\n          std::map<std::string, std::string>::const_iterator mapIt;\n          bool                                               inserted;\n          std::tie( mapIt, inserted ) = valueToNameMap.insert( { aliasName, valueAlias.name } );\n          if ( inserted )\n          {\n            enumValues += \"    \" + aliasName + \" = \" + valueAlias.name + \",\\n\";\n          }\n          else\n          {\n            // some aliases are so close to the original, that no new entry can be generated!\n            assert( mapIt->second != valueAlias.name );\n            checkForError( ( mapIt->second == value.name ) ||\n                             std::any_of( value.aliases.begin(), value.aliases.end(), [mapIt]( auto const & eav ) { return eav.name == mapIt->second; } ),\n                           valueAlias.xmlLine,\n                           \"generated enum alias value name <\" + aliasName + \">, generated from <\" + valueAlias.name +\n                             \"> is already generated from different enum value <\" + mapIt->second + \">\" );\n          }\n        }\n      }\n\n      previousEnter = enter;\n      previousLeave = leave;\n    }\n  }\n  enumValues += previousLeave;\n\n  if ( !enumValues.empty() )\n  {\n    const size_t pos = enumValues.rfind( ',' );\n    assert( pos != std::string::npos );\n    enumValues.erase( pos, 1 );\n    enumValues = \"\\n\" + enumValues + \"  \";\n  }\n\n  std::string enumUsing;\n  for ( auto const & alias : enumData.second.aliases )\n  {\n    enumUsing += \"  using \" + stripPrefix( alias.first, \"Vk\" ) + \" = \" + stripPrefix( enumData.first, \"Vk\" ) + \";\\n\";\n  }\n\n  std::string typeTraits;\n  if ( enumData.first == \"VkIndexType\" )\n  {\n    typeTraits = generateIndexTypeTraits( enumData );\n  }\n  else if ( enumData.first == \"VkLayerSettingTypeEXT\" )\n  {\n    typeTraits = generateLayerSettingTypeTraits();\n  }\n\n  const std::string enumTemplate = R\"(  enum class ${enumName}${baseType}\n  {${enumValues}};\n${typeTraits}${enumUsing}${bitmask})\";\n\n  return replaceWithMap( enumTemplate,\n                         { { \"baseType\", baseType },\n                           { \"bitmask\", bitmask },\n                           { \"enumName\", stripPrefix( enumData.first, \"Vk\" ) },\n                           { \"enumUsing\", enumUsing },\n                           { \"enumValues\", enumValues },\n                           { \"typeTraits\", typeTraits } } );\n}\n\nstd::string VulkanHppGenerator::generateEnums() const\n{\n  const std::string enumsTemplate = R\"(\n  //=============\n  //=== ENUMs ===\n  //=============\n\n${enums}\n)\";\n\n  std::string           enums;\n  std::set<std::string> listedEnums;\n  for ( auto const & feature : m_features )\n  {\n    enums += generateEnums( feature.requireData, listedEnums, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    enums += generateEnums( extension.requireData, listedEnums, extension.name );\n  }\n\n  return replaceWithMap( enumsTemplate, { { \"enums\", enums } } );\n}\n\nstd::string\n  VulkanHppGenerator::generateEnums( std::vector<RequireData> const & requireData, std::set<std::string> & listedEnums, std::string const & title ) const\n{\n  std::string surroundingProtect = getProtectFromTitle( title );\n  std::string str;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & type : require.types )\n    {\n      auto enumIt = m_enums.find( type.name );\n      if ( ( enumIt != m_enums.end() ) && !listedEnums.contains( type.name ) )\n      {\n        listedEnums.insert( type.name );\n        str += \"\\n\";\n        str += generateEnum( *enumIt, surroundingProtect );\n      }\n    }\n  }\n  return addTitleAndProtection( title, str );\n}\n\nstd::string VulkanHppGenerator::generateEnumsToString() const\n{\n  // start with toHexString, which is used in all the to_string functions here!\n  const std::string enumsToStringTemplate = R\"(\n  //=======================\n  //=== ENUMs to_string ===\n  //=======================\n\n  VULKAN_HPP_INLINE std::string toHexString( uint32_t value )\n  {\n#if __cpp_lib_format\n    return std::format( \"{:x}\", value );\n#else\n    std::stringstream stream;\n    stream << std::hex << value;\n    return stream.str();\n#endif\n  }\n\n${enumsToString}\n)\";\n\n  std::string           enumsToString;\n  std::set<std::string> listedEnums;\n  for ( auto const & feature : m_features )\n  {\n    enumsToString += generateEnumsToString( feature.requireData, listedEnums, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    enumsToString += generateEnumsToString( extension.requireData, listedEnums, extension.name );\n  }\n\n  return replaceWithMap( enumsToStringTemplate, { { \"enumsToString\", enumsToString } } );\n}\n\nstd::string VulkanHppGenerator::generateEnumsToString( std::vector<RequireData> const & requireData,\n                                                       std::set<std::string> &          listedEnums,\n                                                       std::string const &              title ) const\n{\n  std::string str;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & type : require.types )\n    {\n      auto enumIt = m_enums.find( type.name );\n      if ( ( enumIt != m_enums.end() ) && !listedEnums.contains( type.name ) )\n      {\n        listedEnums.insert( type.name );\n\n        str += \"\\n\";\n        str += generateEnumToString( *enumIt );\n      }\n    }\n  }\n  return addTitleAndProtection( title, str );\n}\n\nstd::string VulkanHppGenerator::generateEnumInitializer( TypeInfo const &                   type,\n                                                         std::vector<std::string> const &   arraySizes,\n                                                         std::vector<EnumValueData> const & values,\n                                                         bool                               bitmask ) const\n{\n  // enum arguments might need special initialization\n  assert( type.prefix.empty() && !values.empty() );\n  std::string valueName = generateEnumValueName( type.type, values.front().name, bitmask );\n  std::string value     = generateNamespacedType( type.type ) + \"::\" + valueName;\n  std::string str;\n  if ( arraySizes.empty() )\n  {\n    str += value;\n  }\n  else\n  {\n    assert( arraySizes.size() == 1 );\n    auto      constIt = m_constants.find( arraySizes[0] );\n    const int count   = std::stoi( ( constIt == m_constants.end() ) ? arraySizes[0] : constIt->second.value );\n    assert( 1 < count );\n    str += \"{ { \" + value;\n    for ( int i = 1; i < count; i++ )\n    {\n      str += \", \" + value;\n    }\n    str += \" } }\";\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateEnumToString( std::pair<std::string, EnumData> const & enumData ) const\n{\n  std::string enumName = stripPrefix( enumData.first, \"Vk\" );\n  std::string functionBody;\n  bool        isEmpty = enumData.second.values.empty() ||\n                 std::none_of( enumData.second.values.begin(), enumData.second.values.end(), []( auto const & evd ) { return evd.supported; } );\n  if ( isEmpty )\n  {\n    functionBody = R\"x(    return \"(void)\";)x\";\n  }\n  else\n  {\n    std::string cases, previousEnter, previousLeave;\n    for ( auto const & value : enumData.second.values )\n    {\n      if ( value.supported )\n      {\n        const auto [enter, leave] = generateProtection( value.protect );\n        if ( previousEnter != enter )\n        {\n          cases += previousLeave + enter;\n        }\n\n        const std::string caseTemplate = R\"(      case ${enumName}::e${valueName} : return \"${valueName}\";\n)\";\n        cases += replaceWithMap(\n          caseTemplate,\n          { { \"enumName\", enumName }, { \"valueName\", generateEnumValueName( enumData.first, value.name, enumData.second.isBitmask ).substr( 1 ) } } );\n\n        previousEnter = enter;\n        previousLeave = leave;\n      }\n    }\n    cases += previousLeave;\n\n    const std::string functionBodyTemplate =\n      R\"x(    switch ( value )\n    {\n${cases}      default: return \"invalid ( \" + VULKAN_HPP_NAMESPACE::toHexString( static_cast<uint32_t>( value ) ) + \" )\";\n    }\n)x\";\n\n    functionBody = replaceWithMap( functionBodyTemplate, { { \"cases\", cases } } );\n  }\n\n  const std::string enumToStringTemplate = R\"(\n  VULKAN_HPP_INLINE std::string to_string( ${enumName}${argument} )\n  {\n${functionBody}\n  }\n)\";\n\n  return replaceWithMap( enumToStringTemplate, { { \"argument\", isEmpty ? \"\" : \" value\" }, { \"enumName\", enumName }, { \"functionBody\", functionBody } } );\n}\n\nstd::pair<std::string, std::string> VulkanHppGenerator::generateEnumSuffixes( std::string const & name, bool bitmask ) const\n{\n  std::string prefix, postfix;\n  if ( name == \"VkResult\" )\n  {\n    prefix = \"VK_\";\n  }\n  else\n  {\n    if ( bitmask )\n    {\n      // for a bitmask enum, start with \"VK\", cut off the trailing \"FlagBits\", and convert that name to upper case\n      // end that with \"Bit\"\n      const size_t pos = name.find( \"FlagBits\" );\n      assert( pos != std::string::npos );\n      std::string shortenedName = name;\n      shortenedName.erase( pos, strlen( \"FlagBits\" ) );\n      std::string tag = findTag( shortenedName );\n      prefix          = toUpperCase( stripPostfix( shortenedName, tag ) ) + \"_\";\n    }\n    else\n    {\n      // for a non-bitmask enum, convert the name to upper case\n      prefix = toUpperCase( name ) + \"_\";\n    }\n\n    // if the enum name contains a tag move it from the prefix to the postfix to generate correct enum value\n    // names.\n    for ( auto const & tag : m_tags )\n    {\n      if ( prefix.ends_with( tag.first + \"_\" ) )\n      {\n        prefix.erase( prefix.length() - tag.first.length() - 1 );\n        postfix = \"_\" + tag.first;\n        break;\n      }\n      else if ( name.ends_with( tag.first ) )\n      {\n        postfix = \"_\" + tag.first;\n        break;\n      }\n    }\n  }\n\n  return std::make_pair( prefix, postfix );\n}\n\nstd::string VulkanHppGenerator::generateEnumValueName( std::string const & enumName, std::string const & valueName, bool bitmask ) const\n{\n  std::string prefix, postfix;\n  std::tie( prefix, postfix ) = generateEnumSuffixes( enumName, bitmask );\n  std::string tag             = findTag( valueName, \"\" );\n  if ( postfix == \"_\" + tag )\n  {\n    tag = findTag( valueName, postfix );\n  }\n\n  std::string result = \"e\" + toCamelCase( stripPostfix( stripPrefix( valueName, prefix ), postfix ) );\n  if ( bitmask )\n  {\n    const size_t pos = result.rfind( \"Bit\" );\n    if ( pos != std::string::npos )\n    {\n      result.erase( pos, 3 );\n    }\n  }\n  if ( !tag.empty() && ( result.substr( result.length() - tag.length() ) == toCamelCase( tag ) ) )\n  {\n    result = result.substr( 0, result.length() - tag.length() ) + tag;\n  }\n  return result;\n}\n\nstd::string VulkanHppGenerator::generateExtensionDependencies() const\n{\n  std::string extensionDependencies, previousEnter, previousLeave;\n  for ( auto const & extension : m_extensions )\n  {\n    if ( !extension.depends.empty() )\n    {\n      std::string dependsPerExtension = \"{ \\\"\" + extension.name + \"\\\", { \";\n      for ( auto const & dependsByVersion : extension.depends )\n      {\n        dependsPerExtension += \"{ \\\"\" + dependsByVersion.first + \"\\\", { \";\n        if ( !dependsByVersion.second.empty() )\n        {\n          dependsPerExtension += \" { \";\n          for ( auto const & dependsSet : dependsByVersion.second )\n          {\n            for ( auto const & depends : dependsSet )\n            {\n              dependsPerExtension += \"\\\"\" + depends + \"\\\", \";\n            }\n          }\n          dependsPerExtension += \" }, \";\n          assert( dependsPerExtension.ends_with( \", \" ) );\n          dependsPerExtension = dependsPerExtension.substr( 0, dependsPerExtension.length() - 2 );\n        }\n        dependsPerExtension += \" } }, \";\n      }\n      assert( dependsPerExtension.ends_with( \", \" ) );\n      dependsPerExtension = dependsPerExtension.substr( 0, dependsPerExtension.length() - 2 );\n      dependsPerExtension += \" } }, \";\n\n      const auto [enter, leave] = generateProtection( getProtectFromTitle( extension.name ) );\n      extensionDependencies += ( ( previousEnter != enter ) ? ( \"\\n\" + previousLeave + enter ) : \"\\n\" ) + dependsPerExtension;\n      previousEnter = enter;\n      previousLeave = leave;\n    }\n  }\n  assert( extensionDependencies.ends_with( \", \" ) );\n  extensionDependencies = extensionDependencies.substr( 0, extensionDependencies.length() - 2 );\n\n  if ( !previousLeave.empty() )\n  {\n    extensionDependencies += \"\\n\" + previousLeave;\n  }\n  return extensionDependencies;\n}\n\nstd::string VulkanHppGenerator::generateExtensionDependsByVersion( bool definition ) const\n{\n  if ( m_api != \"vulkan\" )\n  {\n    return \"\";\n  }\n\n  if ( definition )\n  {\n    const std::string generateExtensionDependsTemplate =\n      R\"(  VULKAN_HPP_INLINE std::pair<bool, std::vector<std::vector<std::string>> const &> getExtensionDepends( std::string const & version, std::string const & extension )\n    {\n#if !defined( NDEBUG )\n      static std::set<std::string> versions = { ${versions} };\n      assert( versions.find( version ) != versions.end() );\n#endif\n      static std::vector<std::vector<std::string>> noDependencies;\n\n      std::map<std::string, std::vector<std::vector<std::string>>> const & dependencies = getExtensionDepends( extension );\n      if ( dependencies.empty() )\n      {\n        return { true, noDependencies };\n      }\n      auto depIt = dependencies.lower_bound( version );\n      if ( ( depIt == dependencies.end() ) || ( depIt->first != version ) )\n      {\n        depIt = std::prev( depIt );\n      }\n      if ( depIt == dependencies.end() )\n      {\n        return { false, noDependencies };\n      }\n      else\n      {\n        return { true, depIt->second };\n      }\n    }\n)\";\n\n    std::string versions;\n    for ( auto const & feature : m_features )\n    {\n      versions += \"\\\"\" + feature.name + \"\\\", \";\n    }\n    assert( versions.ends_with( \", \" ) );\n    versions = versions.substr( 0, versions.length() - 2 );\n\n    return replaceWithMap( generateExtensionDependsTemplate, { { \"versions\", versions } } );\n  }\n  else\n  {\n    return \"std::pair<bool, std::vector<std::vector<std::string>> const &> getExtensionDepends( std::string const & version, std::string const & extension );\";\n  }\n}\n\ntemplate <class Predicate, class Extraction>\nstd::string VulkanHppGenerator::generateExtensionReplacedBy( Predicate p, Extraction e ) const\n{\n  std::string replacedBy, previousEnter, previousLeave;\n  for ( auto const & extension : m_extensions )\n  {\n    if ( p( extension ) )\n    {\n      const auto [enter, leave] = generateProtection( getProtectFromTitle( extension.name ) );\n      replacedBy += ( ( previousEnter != enter ) ? ( \"\\n\" + previousLeave + enter ) : \"\\n\" ) + \"  if ( extension == \\\"\" + extension.name + \"\\\" ) { return \\\"\" +\n                    e( extension ) + \"\\\"; }\";\n      previousEnter = enter;\n      previousLeave = leave;\n    }\n  }\n  if ( !previousLeave.empty() )\n  {\n    replacedBy += \"\\n\" + previousLeave;\n  }\n  replacedBy += \"\\n  return \\\"\\\";\";\n  return replacedBy;\n}\n\ntemplate <class Predicate>\nstd::string VulkanHppGenerator::generateExtensionReplacedTest( Predicate p ) const\n{\n  std::string replacedTest, previousEnter, previousLeave;\n  bool        unprotectedEntry = false;\n  for ( auto const & extension : m_extensions )\n  {\n    if ( p( extension ) )\n    {\n      const auto [enter, leave] = generateProtection( getProtectFromTitle( extension.name ) );\n      unprotectedEntry |= enter.empty();\n      replacedTest += ( ( previousEnter != enter ) ? ( \"\\n\" + previousLeave + enter ) : \"\\n\" ) + \"( extension == \\\"\" + extension.name + \"\\\" ) || \";\n      previousEnter = enter;\n      previousLeave = leave;\n    }\n  }\n  if ( unprotectedEntry )\n  {\n    assert( replacedTest.ends_with( \" || \" ) );\n    replacedTest = replacedTest.substr( 0, replacedTest.length() - 4 );\n  }\n  if ( !previousLeave.empty() )\n  {\n    replacedTest += \"\\n\" + previousLeave;\n  }\n  if ( !unprotectedEntry )\n  {\n    replacedTest += \"false\";  // there might be no replacements at all, so add a \"false\" at the end...\n  }\n  return replacedTest;\n}\n\nstd::string VulkanHppGenerator::generateExtensionsList( std::string const & type ) const\n{\n  std::string extensionsList, previousEnter, previousLeave;\n  for ( auto const & extension : m_extensions )\n  {\n    if ( extension.type == type )\n    {\n      const auto [enter, leave] = generateProtection( getProtectFromTitle( extension.name ) );\n      extensionsList += ( ( previousEnter != enter ) ? ( \"\\n\" + previousLeave + enter ) : \"\\n\" ) + \"\\\"\" + extension.name + \"\\\", \";\n      previousEnter = enter;\n      previousLeave = leave;\n    }\n  }\n  assert( extensionsList.ends_with( \", \" ) );\n  extensionsList = extensionsList.substr( 0, extensionsList.length() - 2 );\n  if ( !previousLeave.empty() )\n  {\n    extensionsList += \"\\n\" + previousLeave;\n  }\n  return extensionsList;\n}\n\nstd::string VulkanHppGenerator::generateExtensionTypeTest( std::string const & type ) const\n{\n  std::string typeTest, previousEnter, previousLeave;\n  bool        first = true;\n  for ( auto const & extension : m_extensions )\n  {\n    if ( extension.type == type )\n    {\n      const auto [enter, leave] = generateProtection( getProtectFromTitle( extension.name ) );\n      typeTest +=\n        ( ( previousEnter != enter ) ? ( \"\\n\" + previousLeave + enter ) : \"\\n\" ) + ( first ? \"\" : \" || \" ) + \"( extension == \\\"\" + extension.name + \"\\\" )\";\n      previousEnter = enter;\n      previousLeave = leave;\n      first         = false;\n    }\n  }\n  if ( !previousLeave.empty() )\n  {\n    typeTest += \"\\n\" + previousLeave;\n  }\n  return typeTest;\n}\n\nstd::string VulkanHppGenerator::generateFormatTraits() const\n{\n  if ( m_formats.empty() )\n  {\n    return \"\";\n  }\n\n  const std::string formatTraitsTemplate = R\"(\n  //=====================\n  //=== Format Traits ===\n  //=====================\n\n  // The three-dimensional extent of a texel block.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 std::array<uint8_t, 3> blockExtent( VULKAN_HPP_NAMESPACE::Format format )\n  {\n    switch( format )\n    {\n${blockExtentCases}\n      default: return {{1, 1, 1 }};\n    }\n  }\n\n  // The texel block size in bytes.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 uint8_t blockSize( VULKAN_HPP_NAMESPACE::Format format )\n  {\n    switch( format )\n    {\n${blockSizeCases}\n      default : VULKAN_HPP_ASSERT( false ); return 0;\n    }\n  }\n\n  // The class of the format (can't be just named \"class\"!)\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 char const * compatibilityClass( VULKAN_HPP_NAMESPACE::Format format )\n  {\n    switch( format )\n    {\n${classCases}\n      default : VULKAN_HPP_ASSERT( false ); return \"\";\n    }\n  }\n\n  // The number of bits in this component, if not compressed, otherwise 0.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 uint8_t componentBits( VULKAN_HPP_NAMESPACE::Format format, uint8_t component )\n  {\n    switch( format )\n    {\n${componentBitsCases}\n      default: return 0;\n    }\n  }\n\n  // The number of components of this format.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 uint8_t componentCount( VULKAN_HPP_NAMESPACE::Format format )\n  {\n    switch( format )\n    {\n${componentCountCases}\n      default: return 0;\n    }\n  }\n\n  // The name of the component\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 char const * componentName( VULKAN_HPP_NAMESPACE::Format format, uint8_t component )\n  {\n    switch( format )\n    {\n${componentNameCases}\n      default: return \"\";\n    }\n  }\n\n  // The numeric format of the component\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 char const * componentNumericFormat( VULKAN_HPP_NAMESPACE::Format format, uint8_t component )\n  {\n    switch( format )\n    {\n${componentNumericFormatCases}\n      default: return \"\";\n    }\n  }\n\n  // The plane this component lies in.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 uint8_t componentPlaneIndex( VULKAN_HPP_NAMESPACE::Format format, uint8_t component )\n  {\n    switch( format )\n    {\n${componentPlaneIndexCases}\n      default: return 0;\n    }\n  }\n\n  // True, if the components of this format are compressed, otherwise false.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 bool componentsAreCompressed( VULKAN_HPP_NAMESPACE::Format format )\n  {\n    switch( format )\n    {\n${componentsAreCompressedCases}\n        return true;\n      default: return false;\n    }\n  }\n\n  // A textual description of the compression scheme, or an empty string if it is not compressed\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 char const * compressionScheme( VULKAN_HPP_NAMESPACE::Format format )\n  {\n    switch( format )\n    {\n${compressionSchemeCases}\n      default: return \"\";\n    }\n  }\n\n  // True, if this format is a compressed one.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 bool isCompressed( VULKAN_HPP_NAMESPACE::Format format )\n  {\n    return ( *VULKAN_HPP_NAMESPACE::compressionScheme( format ) != 0 );\n  }\n\n  // The number of bits into which the format is packed. A single image element in this format\n  // can be stored in the same space as a scalar type of this bit width.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 uint8_t packed( VULKAN_HPP_NAMESPACE::Format format )\n  {\n    switch( format )\n    {\n${packedCases}\n      default: return 0;\n    }\n  }\n\n  // The single-plane format that this plane is compatible with.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 VULKAN_HPP_NAMESPACE::Format planeCompatibleFormat( VULKAN_HPP_NAMESPACE::Format format, uint8_t plane )\n  {\n    switch( format )\n    {\n${planeCompatibleCases}\n      default: VULKAN_HPP_ASSERT( plane == 0 ); return format;\n    }\n  }\n\n  // The number of image planes of this format.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 uint8_t planeCount( VULKAN_HPP_NAMESPACE::Format format )\n  {\n    switch( format )\n    {\n${planeCountCases}\n      default: return 1;\n    }\n  }\n\n  // The relative height of this plane. A value of k means that this plane is 1/k the height of the overall format.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 uint8_t planeHeightDivisor( VULKAN_HPP_NAMESPACE::Format format, uint8_t plane )\n  {\n    switch( format )\n    {\n${planeHeightDivisorCases}\n      default: VULKAN_HPP_ASSERT( plane == 0 ); return 1;\n    }\n  }\n\n  // The relative width of this plane. A value of k means that this plane is 1/k the width of the overall format.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 uint8_t planeWidthDivisor( VULKAN_HPP_NAMESPACE::Format format, uint8_t plane )\n  {\n    switch( format )\n    {\n${planeWidthDivisorCases}\n      default: VULKAN_HPP_ASSERT( plane == 0 ); return 1;\n    }\n  }\n\n  // The number of texels in a texel block.\n  VULKAN_HPP_INLINE VULKAN_HPP_CONSTEXPR_14 uint8_t texelsPerBlock( VULKAN_HPP_NAMESPACE::Format format )\n  {\n    switch( format )\n    {\n${texelsPerBlockCases}\n      default: VULKAN_HPP_ASSERT( false ); return 0;\n    }\n  }\n)\";\n\n  auto formatIt = m_enums.find( \"VkFormat\" );\n  assert( formatIt != m_enums.end() );\n  assert( formatIt->second.values.front().name == \"VK_FORMAT_UNDEFINED\" );\n\n  std::string blockSizeCases, blockExtentCases, classCases, componentBitsCases, componentCountCases, componentNameCases, componentNumericFormatCases,\n    componentPlaneIndexCases, componentsAreCompressedCases, compressionSchemeCases, packedCases, planeCompatibleCases, planeCountCases, planeHeightDivisorCases,\n    planeWidthDivisorCases, texelsPerBlockCases;\n  for ( auto formatValuesIt = std::next( formatIt->second.values.begin() ); formatValuesIt != formatIt->second.values.end(); ++formatValuesIt )\n  {\n    if ( formatValuesIt->supported )\n    {\n      auto traitIt = m_formats.find( formatValuesIt->name );\n      assert( traitIt != m_formats.end() );\n      std::string caseString = \"      case VULKAN_HPP_NAMESPACE::Format::\" + generateEnumValueName( \"VkFormat\", traitIt->first, false ) + \":\";\n\n      blockSizeCases += caseString + \" return \" + traitIt->second.blockSize + \";\\n\";\n\n      if ( !traitIt->second.blockExtent.empty() )\n      {\n        std::vector<std::string> blockExtent = tokenize( traitIt->second.blockExtent, \",\" );\n        assert( blockExtent.size() == 3 );\n        blockExtentCases += caseString + \" return {{ \" + blockExtent[0] + \", \" + blockExtent[1] + \", \" + blockExtent[2] + \" }};\\n\";\n      }\n\n      classCases += caseString + \" return \\\"\" + traitIt->second.classAttribute + \"\\\";\\n\";\n\n      if ( traitIt->second.components.front().bits != \"compressed\" )\n      {\n        const std::string componentBitsCaseTemplate = R\"(${caseString}\n        switch( component )\n        {\n${componentCases}\n          default: VULKAN_HPP_ASSERT( false ); return 0;\n        }\n)\";\n\n        std::string componentCases;\n        for ( size_t i = 0; i < traitIt->second.components.size(); ++i )\n        {\n          componentCases += \"          case \" + std::to_string( i ) + \": return \" + traitIt->second.components[i].bits + \";\\n\";\n        }\n        componentCases.pop_back();\n        componentBitsCases += replaceWithMap( componentBitsCaseTemplate, { { \"caseString\", caseString }, { \"componentCases\", componentCases } } );\n      }\n\n      componentCountCases += caseString + \" return \" + std::to_string( traitIt->second.components.size() ) + \";\\n\";\n\n      {\n        const std::string componentNameCaseTemplate = R\"(${caseString}\n        switch( component )\n        {\n${componentCases}\n          default: VULKAN_HPP_ASSERT( false ); return \"\";\n        }\n)\";\n\n        std::string componentCases;\n        for ( size_t i = 0; i < traitIt->second.components.size(); ++i )\n        {\n          componentCases += \"          case \" + std::to_string( i ) + \": return \\\"\" + traitIt->second.components[i].name + \"\\\";\\n\";\n        }\n        componentCases.pop_back();\n        componentNameCases += replaceWithMap( componentNameCaseTemplate, { { \"caseString\", caseString }, { \"componentCases\", componentCases } } );\n      }\n\n      {\n        const std::string componentNumericFormatCaseTemplate = R\"(${caseString}\n        switch( component )\n        {\n${componentCases}\n          default: VULKAN_HPP_ASSERT( false ); return \"\";\n        }\n)\";\n\n        std::string componentCases;\n        for ( size_t i = 0; i < traitIt->second.components.size(); ++i )\n        {\n          componentCases += \"          case \" + std::to_string( i ) + \": return \\\"\" + traitIt->second.components[i].numericFormat + \"\\\";\\n\";\n        }\n        componentCases.pop_back();\n        componentNumericFormatCases +=\n          replaceWithMap( componentNumericFormatCaseTemplate, { { \"caseString\", caseString }, { \"componentCases\", componentCases } } );\n      }\n\n      if ( !traitIt->second.components.front().planeIndex.empty() )\n      {\n        const std::string componentPlaneIndexCaseTemplate = R\"(${caseString}\n        switch( component )\n        {\n${componentCases}\n          default: VULKAN_HPP_ASSERT( false ); return 0;\n        }\n)\";\n\n        std::string componentCases;\n        for ( size_t i = 0; i < traitIt->second.components.size(); ++i )\n        {\n          componentCases += \"          case \" + std::to_string( i ) + \": return \" + traitIt->second.components[i].planeIndex + \";\\n\";\n        }\n        componentCases.pop_back();\n        componentPlaneIndexCases += replaceWithMap( componentPlaneIndexCaseTemplate, { { \"caseString\", caseString }, { \"componentCases\", componentCases } } );\n      }\n\n      if ( traitIt->second.components.front().bits == \"compressed\" )\n      {\n        componentsAreCompressedCases += caseString + \"\\n\";\n      }\n\n      if ( !traitIt->second.compressed.empty() )\n      {\n        compressionSchemeCases += caseString + \" return \\\"\" + traitIt->second.compressed + \"\\\";\\n\";\n      }\n\n      if ( !traitIt->second.packed.empty() )\n      {\n        packedCases += caseString + \" return \" + traitIt->second.packed + \";\\n\";\n      }\n\n      if ( !traitIt->second.planes.empty() )\n      {\n        const std::string planeCompatibleCaseTemplate = R\"(${caseString}\n        switch( plane )\n        {\n${compatibleCases}\n          default: VULKAN_HPP_ASSERT( false ); return VULKAN_HPP_NAMESPACE::Format::eUndefined;\n        }\n)\";\n\n        const std::string planeHeightDivisorCaseTemplate = R\"(${caseString}\n        switch( plane )\n        {\n${heightDivisorCases}\n          default: VULKAN_HPP_ASSERT( false ); return 1;\n        }\n)\";\n\n        const std::string planeWidthDivisorCaseTemplate = R\"(${caseString}\n        switch( plane )\n        {\n${widthDivisorCases}\n          default: VULKAN_HPP_ASSERT( false ); return 1;\n        }\n)\";\n\n        std::string compatibleCases, heightDivisorCases, widthDivisorCases;\n        for ( size_t i = 0; i < traitIt->second.planes.size(); ++i )\n        {\n          compatibleCases += \"          case \" + std::to_string( i ) +\n                             \": return VULKAN_HPP_NAMESPACE::Format::\" + generateEnumValueName( \"VkFormat\", traitIt->second.planes[i].compatible, false ) +\n                             \";\\n\";\n          heightDivisorCases += \"          case \" + std::to_string( i ) + \": return \" + traitIt->second.planes[i].heightDivisor + \";\\n\";\n          widthDivisorCases += \"          case \" + std::to_string( i ) + \": return \" + traitIt->second.planes[i].widthDivisor + \";\\n\";\n        }\n        compatibleCases.pop_back();\n        heightDivisorCases.pop_back();\n        widthDivisorCases.pop_back();\n\n        planeCompatibleCases += replaceWithMap( planeCompatibleCaseTemplate, { { \"caseString\", caseString }, { \"compatibleCases\", compatibleCases } } );\n\n        planeCountCases += caseString + \" return \" + std::to_string( traitIt->second.planes.size() ) + \";\\n\";\n\n        planeHeightDivisorCases +=\n          replaceWithMap( planeHeightDivisorCaseTemplate, { { \"caseString\", caseString }, { \"heightDivisorCases\", heightDivisorCases } } );\n\n        planeWidthDivisorCases += replaceWithMap( planeWidthDivisorCaseTemplate, { { \"caseString\", caseString }, { \"widthDivisorCases\", widthDivisorCases } } );\n      }\n\n      texelsPerBlockCases += caseString + \" return \" + traitIt->second.texelsPerBlock + \";\\n\";\n    }\n  }\n\n  return replaceWithMap( formatTraitsTemplate,\n                         { { \"blockExtentCases\", blockExtentCases },\n                           { \"blockSizeCases\", blockSizeCases },\n                           { \"classCases\", classCases },\n                           { \"componentBitsCases\", componentBitsCases },\n                           { \"componentCountCases\", componentCountCases },\n                           { \"componentNameCases\", componentNameCases },\n                           { \"componentNumericFormatCases\", componentNumericFormatCases },\n                           { \"componentPlaneIndexCases\", componentPlaneIndexCases },\n                           { \"componentsAreCompressedCases\", componentsAreCompressedCases },\n                           { \"compressionSchemeCases\", compressionSchemeCases },\n                           { \"packedCases\", packedCases },\n                           { \"planeCompatibleCases\", planeCompatibleCases },\n                           { \"planeCountCases\", planeCountCases },\n                           { \"planeHeightDivisorCases\", planeHeightDivisorCases },\n                           { \"planeWidthDivisorCases\", planeWidthDivisorCases },\n                           { \"texelsPerBlockCases\", texelsPerBlockCases } } );\n}\n\nstd::string VulkanHppGenerator::generateFuncPointer( std::pair<std::string, FuncPointerData> const & funcPointer, std::set<std::string> & listedStructs ) const\n{\n  std::string str;\n  for ( auto const & argument : funcPointer.second.arguments )\n  {\n    auto typeIt = m_types.find( argument.type.type );\n    assert( typeIt != m_types.end() );\n    if ( ( typeIt->second.category == TypeCategory::Struct ) || ( typeIt->second.category == TypeCategory::Union ) )\n    {\n      auto structIt = findByNameOrAlias( m_structs, argument.type.type );\n      assert( structIt != m_structs.end() );\n      if ( !listedStructs.contains( argument.type.type ) )\n      {\n        str += generateStruct( *structIt, listedStructs );\n      }\n    }\n    else\n    {\n      assert( typeIt->second.category != TypeCategory::FuncPointer );\n    }\n  }\n\n  const auto [enter, leave] = generateProtection( getProtectFromType( funcPointer.first ) );\n\n  std::string funcPointerArguments;\n  if ( !funcPointer.second.arguments.empty() )\n  {\n    for ( auto const & argument : funcPointer.second.arguments )\n    {\n      funcPointerArguments += argument.type.compose( \"VULKAN_HPP_NAMESPACE\" ) + \" \" + argument.name + \", \";\n    }\n    assert( !funcPointerArguments.empty() );\n    funcPointerArguments.pop_back();\n    funcPointerArguments.pop_back();\n  }\n\n  static const std::string funcPointerTemplate = R\"(\n  typedef ${returnType} (VKAPI_PTR *PFN_${funcPointerName})( ${funcPointerArguments} );\n)\";\n\n  str += \"\\n\" + enter +\n         replaceWithMap( funcPointerTemplate,\n                         { { \"funcPointerArguments\", funcPointerArguments },\n                           { \"funcPointerName\", stripPrefix( funcPointer.first, \"PFN_vk\" ) },\n                           { \"returnType\", funcPointer.second.returnType.compose( \"VULKAN_HPP_NAMESPACE\" ) } } ) +\n         leave;\n\n  listedStructs.insert( funcPointer.first );\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateFuncPointerReturns() const\n{\n  std::string           str;\n  std::set<std::string> listedFuncPointers;\n  for ( auto const & handle : m_handles )\n  {\n    for ( auto const & command : handle.second.commands )\n    {\n      auto commandIt = findByNameOrAlias( m_commands, command );\n      assert( commandIt != m_commands.end() );\n      auto funcPointerIt = m_funcPointers.find( commandIt->second.returnType );\n      if ( ( funcPointerIt != m_funcPointers.end() ) && !listedFuncPointers.contains( commandIt->second.returnType ) )\n      {\n        assert( funcPointerIt->second.arguments.empty() );\n        str += generateFuncPointer( *funcPointerIt, listedFuncPointers );\n      }\n    }\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateFunctionPointerCheck( std::string const & function, std::set<std::string> const & requiredBy, bool raii ) const\n{\n  std::string functionPointerCheck;\n  if ( !requiredBy.empty() )\n  {\n    std::string message = \"Function <\" + function + \"> requires <\" + *requiredBy.begin() + \">\";\n    for ( auto it = std::next( requiredBy.begin() ); it != requiredBy.end(); ++it )\n    {\n      message += \" or <\" + *it + \">\";\n    }\n\n    functionPointerCheck = std::string( \"VULKAN_HPP_ASSERT( \" ) + ( raii ? \"getDispatcher()->\" : \"d.\" ) + function + \" && \\\"\" + message + \"\\\" );\";\n  }\n  return functionPointerCheck;\n}\n\nstd::string VulkanHppGenerator::generateHandle( std::pair<std::string, HandleData> const & handleData, std::set<std::string> & listedHandles ) const\n{\n  assert( !listedHandles.contains( handleData.first ) );\n\n  // first check for any handle that needs to be listed before this one\n  std::string str = generateHandleDependencies( handleData, listedHandles );\n\n  // list the commands of this handle\n  if ( handleData.first.empty() )\n  {\n    // the free functions, not bound to any handle\n    str += generateHandleEmpty( handleData.second );\n  }\n  else\n  {\n    // list all the commands that are mapped to members of this class\n    std::string commands = generateHandleCommandDeclarations( handleData.second.commands );\n\n    std::string debugReportObjectType = generateDebugReportObjectType( handleData.second.objTypeEnum );\n\n    // create CPPType template specialization\n    std::string className = stripPrefix( handleData.first, \"Vk\" );\n    std::string cppType;\n    if ( debugReportObjectType != \"eUnknown\" )\n    {\n      static const std::string cppTypeFromDebugReportObjectTypeEXTTemplate = R\"(\n  template <>\n  struct CppType<VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT, VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT::e${className}>\n  {\n    using Type = VULKAN_HPP_NAMESPACE::${className};\n  };\n)\";\n      cppType = replaceWithMap( cppTypeFromDebugReportObjectTypeEXTTemplate, { { \"className\", className } } );\n    }\n\n    auto [enter, leave] = generateProtection( getProtectFromType( handleData.first ) );\n\n    assert( !handleData.second.objTypeEnum.empty() );\n    auto enumIt = m_enums.find( \"VkObjectType\" );\n    assert( enumIt != m_enums.end() );\n    assert( contains( enumIt->second.values, handleData.second.objTypeEnum ) );\n\n    std::string usingAlias;\n    for ( auto const & alias : handleData.second.aliases )\n    {\n      usingAlias += \"  using \" + stripPrefix( alias.first, \"Vk\" ) + \" = \" + stripPrefix( handleData.first, \"Vk\" ) + \";\\n\";\n    }\n\n    const std::string typesafeExplicitKeyword          = handleData.second.isDispatchable ? \"\" : \"VULKAN_HPP_TYPESAFE_EXPLICIT \";\n    const std::string typesafeConversionConditional    = handleData.second.isDispatchable ? \"\" : \"#if ( VULKAN_HPP_TYPESAFE_CONVERSION == 1 )\\n\";\n    const std::string typesafeConversionConditionalEnd = handleData.second.isDispatchable ? \"\" : \"#endif\\n\";\n\n    static const std::string templateString = R\"(\n${enter}  class ${className}\n  {\n  public:\n    using CType = Vk${className};\n    using NativeType = Vk${className};\n\n    static VULKAN_HPP_CONST_OR_CONSTEXPR VULKAN_HPP_NAMESPACE::ObjectType objectType = VULKAN_HPP_NAMESPACE::ObjectType::${objTypeEnum};\n    static VULKAN_HPP_CONST_OR_CONSTEXPR VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT debugReportObjectType = VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT::${debugReportObjectType};\n\n  public:\n    ${className}() VULKAN_HPP_NOEXCEPT {};    // = default - try to workaround a compiler issue\n    ${className}( ${className} const & rhs ) = default;\n    ${className} & operator=( ${className} const & rhs ) = default;\n\n#if !defined(VULKAN_HPP_HANDLES_MOVE_EXCHANGE)\n    ${className}( ${className} && rhs ) = default;\n    ${className} & operator=( ${className} && rhs ) = default;\n#else\n    ${className}( ${className} && rhs ) VULKAN_HPP_NOEXCEPT\n      : m_${memberName}( VULKAN_HPP_NAMESPACE::exchange( rhs.m_${memberName}, {} ) )\n    {}\n    ${className} & operator=( ${className} && rhs ) VULKAN_HPP_NOEXCEPT\n    {\n      m_${memberName} = VULKAN_HPP_NAMESPACE::exchange( rhs.m_${memberName}, {} );\n      return *this;\n    }\n#endif\n\n    VULKAN_HPP_CONSTEXPR ${className}( std::nullptr_t ) VULKAN_HPP_NOEXCEPT\n    {}\n    ${typesafeExplicitKeyword}${className}( Vk${className} ${memberName} ) VULKAN_HPP_NOEXCEPT\n      : m_${memberName}( ${memberName} )\n    {}\n\n${typesafeConversionConditional}    ${className} & operator=(Vk${className} ${memberName}) VULKAN_HPP_NOEXCEPT\n    {\n      m_${memberName} = ${memberName};\n      return *this;\n    }\n${typesafeConversionConditionalEnd}\n    ${className} & operator=( std::nullptr_t ) VULKAN_HPP_NOEXCEPT\n    {\n      m_${memberName} = {};\n      return *this;\n    }\n\n    ${commands}\n    ${typesafeExplicitKeyword}operator Vk${className}() const VULKAN_HPP_NOEXCEPT\n    {\n      return m_${memberName};\n    }\n\n    explicit operator bool() const VULKAN_HPP_NOEXCEPT\n    {\n      return m_${memberName} != VK_NULL_HANDLE;\n    }\n\n    bool operator!() const VULKAN_HPP_NOEXCEPT\n    {\n      return m_${memberName} == VK_NULL_HANDLE;\n    }\n\n  private:\n    Vk${className} m_${memberName} = {};\n  };\n\n  template <>\n  struct CppType<VULKAN_HPP_NAMESPACE::ObjectType, VULKAN_HPP_NAMESPACE::ObjectType::${objTypeEnum}>\n  {\n    using Type = VULKAN_HPP_NAMESPACE::${className};\n  };\n\n${CppType}\n\n#if ( VK_USE_64_BIT_PTR_DEFINES == 1 )\n  template <>\n  struct CppType<Vk${className}, VK_NULL_HANDLE>\n  {\n    using Type = VULKAN_HPP_NAMESPACE::${className};\n  };\n#endif\n\n  template <>\n  struct isVulkanHandleType<VULKAN_HPP_NAMESPACE::${className}>\n  {\n    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;\n  };\n${usingAlias}${leave})\";\n\n    str += replaceWithMap( templateString,\n                           { { \"className\", className },\n                             { \"commands\", commands },\n                             { \"CppType\", cppType },\n                             { \"debugReportObjectType\", debugReportObjectType },\n                             { \"enter\", enter },\n                             { \"leave\", leave },\n                             { \"memberName\", startLowerCase( stripPrefix( handleData.first, \"Vk\" ) ) },\n                             { \"objTypeEnum\", generateEnumValueName( enumIt->first, handleData.second.objTypeEnum, false ) },\n                             { \"usingAlias\", usingAlias },\n                             { \"typesafeExplicitKeyword\", typesafeExplicitKeyword },\n                             { \"typesafeConversionConditional\", typesafeConversionConditional },\n                             { \"typesafeConversionConditionalEnd\", typesafeConversionConditionalEnd } } );\n  }\n\n  listedHandles.insert( handleData.first );\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateHandleCommandDeclarations( std::set<std::string> const & commands ) const\n{\n  std::string           str;\n  std::set<std::string> listedCommands;  // some commands are listed with more than one extension!\n  for ( auto const & feature : m_features )\n  {\n    std::vector<std::string> commandNames = selectCommandsByHandle( feature.requireData, commands, listedCommands );\n    if ( !commandNames.empty() )\n    {\n      str += \"\\n  //=== \" + feature.name + \" ===\\n\";\n      for ( auto const & command : commandNames )\n      {\n        auto commandIt = m_commands.find( command );\n        assert( commandIt != m_commands.end() );\n\n        str += \"\\n\";\n        str += generateCommand( commandIt->first, commandIt->second, 1, false, false );\n        str += generateDestroyCommand( commandIt->first, commandIt->second );\n      }\n    }\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    std::vector<std::string> commandNames = selectCommandsByHandle( extension.requireData, commands, listedCommands );\n    if ( !commandNames.empty() )\n    {\n      const auto [enter, leave] = generateProtection( getProtectFromTitle( extension.name ) );\n      str += \"\\n\" + enter + \"  //=== \" + extension.name + \" ===\\n\";\n      for ( auto const & command : commandNames )\n      {\n        auto commandIt = findByNameOrAlias( m_commands, command );\n        assert( commandIt != m_commands.end() );\n\n        std::string commandString;\n        std::string commandName = generateCommandName( command, commandIt->second.params, 1 );\n        str += \"\\n\";\n        str += generateCommand( command, commandIt->second, 1, false, false );\n        str += generateDestroyCommand( command, commandIt->second );\n      }\n      str += leave;\n    }\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateHandleDependencies( std::pair<std::string, HandleData> const & handleData, std::set<std::string> & listedHandles ) const\n{\n  std::string str;\n  for ( auto const & command : handleData.second.commands )\n  {\n    auto commandIt = findByNameOrAlias( m_commands, command );\n    assert( commandIt != m_commands.end() );\n    for ( auto const & parameter : commandIt->second.params )\n    {\n      auto handleIt = m_handles.find( parameter.type.type );\n      if ( ( handleIt != m_handles.end() ) && ( parameter.type.type != handleData.first ) && !listedHandles.contains( parameter.type.type ) )\n      {\n        str += generateHandle( *handleIt, listedHandles );\n      }\n    }\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateHandleEmpty( HandleData const & handleData ) const\n{\n  std::string           str;\n  std::set<std::string> listedCommands;  // some commands are listed with more than one extension !\n  for ( auto const & feature : m_features )\n  {\n    std::vector<std::string> commands = selectCommandsByHandle( feature.requireData, handleData.commands, listedCommands );\n    if ( !commands.empty() )\n    {\n      str += \"\\n  //=== \"s + feature.name + \" ===\\n\";\n      for ( auto const & command : commands )\n      {\n        auto commandIt = m_commands.find( command );\n        assert( commandIt != m_commands.end() );\n        str += \"\\n\"s + generateCommand( commandIt->first, commandIt->second, 0, false, false );\n      }\n    }\n  }\n#if !defined( NDEBUG )\n  for ( auto const & extension : m_extensions )\n  {\n    assert( selectCommandsByHandle( extension.requireData, handleData.commands, listedCommands ).empty() );\n  }\n#endif\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateHandleForwardDeclarations() const\n{\n  const std::string fowardDeclarationsTemplate = R\"(\n  //===================================\n  //=== HANDLE forward declarations ===\n  //===================================\n\n${forwardDeclarations}\n)\";\n\n  std::string forwardDeclarations;\n  for ( auto const & feature : m_features )\n  {\n    forwardDeclarations += generateHandleForwardDeclarations( feature.requireData, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    forwardDeclarations += generateHandleForwardDeclarations( extension.requireData, extension.name );\n  }\n\n  return replaceWithMap( fowardDeclarationsTemplate, { { \"forwardDeclarations\", forwardDeclarations } } );\n}\n\nstd::string VulkanHppGenerator::generateHandleForwardDeclarations( std::vector<RequireData> const & requireData, std::string const & title ) const\n{\n  std::string str;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & type : require.types )\n    {\n      auto handleIt = m_handles.find( type.name );\n      if ( handleIt != m_handles.end() )\n      {\n        str += \"class \" + stripPrefix( handleIt->first, \"Vk\" ) + \";\\n\";\n      }\n    }\n  }\n  return addTitleAndProtection( title, str );\n}\n\nstd::string VulkanHppGenerator::generateHandleHashStructures( std::vector<RequireData> const & requireData, std::string const & title ) const\n{\n  const std::string hashTemplate = R\"(\n  template <> struct hash<VULKAN_HPP_NAMESPACE::${type}>\n  {\n    std::size_t operator()(VULKAN_HPP_NAMESPACE::${type} const & ${name}) const VULKAN_HPP_NOEXCEPT\n    {\n      return std::hash<Vk${type}>{}(static_cast<Vk${type}>(${name}));\n    }\n  };\n)\";\n\n  std::string str;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & type : require.types )\n    {\n      auto handleIt = m_handles.find( type.name );\n      if ( handleIt != m_handles.end() )\n      {\n        std::string handleType = stripPrefix( handleIt->first, \"Vk\" );\n        std::string handleName = startLowerCase( handleType );\n        str += replaceWithMap( hashTemplate, { { \"name\", handleName }, { \"type\", handleType } } );\n      }\n    }\n  }\n  return addTitleAndProtection( title, str );\n}\n\nstd::string VulkanHppGenerator::generateHandleHashStructures() const\n{\n  const std::string hashesTemplate = R\"(\n  //===================================\n  //=== HASH structures for handles ===\n  //===================================\n\n${hashes}\n)\";\n\n  std::string hashes;\n  for ( auto const & feature : m_features )\n  {\n    hashes += generateHandleHashStructures( feature.requireData, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    hashes += generateHandleHashStructures( extension.requireData, extension.name );\n  }\n  return replaceWithMap( hashesTemplate, { { \"hashes\", hashes } } );\n}\n\nstd::string VulkanHppGenerator::generateHandles() const\n{\n  // Note: reordering structs or handles by features and extensions is not possible!\n  std::string str = R\"(\n  //===============\n  //=== HANDLEs ===\n  //===============\n\n  template <typename Type>\n  struct isVulkanHandleType\n  {\n    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = false;\n  };\n)\";\n\n  std::set<std::string> listedHandles;\n  str += generateHandle( *m_handles.begin(), listedHandles );  // artificial handle without a name!\n  for ( auto handleIt = std::next( m_handles.begin() ); handleIt != m_handles.end(); ++handleIt )\n  {\n    if ( !listedHandles.contains( handleIt->first ) && isTypeUsed( handleIt->first ) )\n    {\n      str += generateHandle( *handleIt, listedHandles );\n    }\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateIndexTypeTraits( std::pair<std::string, EnumData> const & enumData ) const\n{\n  assert( enumData.first == \"VkIndexType\" );\n\n  std::string typeTraits;\n  for ( auto const & value : enumData.second.values )\n  {\n    assert( value.name.starts_with( \"VK_INDEX_TYPE_\" ) );\n    std::string type = stripPrefix( value.name, \"VK_INDEX_TYPE_\" );\n\n    if ( !type.starts_with( \"NONE\" ) )\n    {\n      checkForError( type.starts_with( \"UINT\" ), value.xmlLine, \"unknown VkIndexType <\" + value.name + \"> encountered\" );\n      std::string::size_type pos = type.find_first_of( \"0123456789\" );\n      assert( pos != std::string::npos );\n      std::string::size_type end   = type.find_first_not_of( \"0123456789\", pos );\n      std::string::size_type count = ( end != std::string::npos ) ? ( end - pos ) : end;\n\n      std::string valueName = generateEnumValueName( \"VkIndexType\", value.name, false );\n      std::string cppType   = \"uint\" + type.substr( pos, count ) + \"_t\";\n\n      const std::string typeTraitTemplate = R\"(  template <>\n  struct IndexTypeValue<${cppType}>\n  {\n    static VULKAN_HPP_CONST_OR_CONSTEXPR IndexType value = IndexType::${valueName};\n  };\n\n  template <>\n  struct CppType<IndexType, IndexType::${valueName}>\n  {\n    using Type = ${cppType};\n  };\n)\";\n\n      typeTraits += replaceWithMap( typeTraitTemplate, { { \"cppType\", cppType }, { \"valueName\", valueName } } );\n    }\n  }\n\n  const std::string typeTraitsTemplate = R\"(\n  //=========================\n  //=== Index Type Traits ===\n  //=========================\n\n  template<typename T>\n  struct IndexTypeValue\n  {};\n\n${typeTraits}\n)\";\n\n  return replaceWithMap( typeTraitsTemplate, { { \"typeTraits\", typeTraits } } );\n}\n\nstd::string VulkanHppGenerator::generateLayerSettingTypeTraits() const\n{\n#if !defined( NDEBUG )\n  auto enumIt = m_enums.find( \"VkLayerSettingTypeEXT\" );\n  assert( ( enumIt != m_enums.end() ) && ( enumIt->second.values.size() == 8 ) && ( enumIt->second.values[0].name == \"VK_LAYER_SETTING_TYPE_BOOL32_EXT\" ) &&\n          ( enumIt->second.values[1].name == \"VK_LAYER_SETTING_TYPE_INT32_EXT\" ) && ( enumIt->second.values[2].name == \"VK_LAYER_SETTING_TYPE_INT64_EXT\" ) &&\n          ( enumIt->second.values[3].name == \"VK_LAYER_SETTING_TYPE_UINT32_EXT\" ) && ( enumIt->second.values[4].name == \"VK_LAYER_SETTING_TYPE_UINT64_EXT\" ) &&\n          ( enumIt->second.values[5].name == \"VK_LAYER_SETTING_TYPE_FLOAT32_EXT\" ) &&\n          ( enumIt->second.values[6].name == \"VK_LAYER_SETTING_TYPE_FLOAT64_EXT\" ) && ( enumIt->second.values[7].name == \"VK_LAYER_SETTING_TYPE_STRING_EXT\" ) );\n#endif\n\n  const std::string typeTraits = R\"(\n  //=================================\n  //=== Layer Setting Type Traits ===\n  //=================================\n\n  template <>\n  struct CppType<LayerSettingTypeEXT, LayerSettingTypeEXT::eBool32>\n  {\n    using Type = vk::Bool32;\n  };\n\n  template <>\n  struct CppType<LayerSettingTypeEXT, LayerSettingTypeEXT::eInt32>\n  {\n    using Type = int32_t;\n  };\n\n  template <>\n  struct CppType<LayerSettingTypeEXT, LayerSettingTypeEXT::eInt64>\n  {\n    using Type = int64_t;\n  };\n\n  template <>\n  struct CppType<LayerSettingTypeEXT, LayerSettingTypeEXT::eUint32>\n  {\n    using Type = uint32_t;\n  };\n\n  template <>\n  struct CppType<LayerSettingTypeEXT, LayerSettingTypeEXT::eUint64>\n  {\n    using Type = uint64_t;\n  };\n\n  template <>\n  struct CppType<LayerSettingTypeEXT, LayerSettingTypeEXT::eFloat32>\n  {\n    using Type = float;\n  };\n\n  template <>\n  struct CppType<LayerSettingTypeEXT, LayerSettingTypeEXT::eFloat64>\n  {\n    using Type = double;\n  };\n\n  template <>\n  struct CppType<LayerSettingTypeEXT, LayerSettingTypeEXT::eString>\n  {\n    using Type = char *;\n  };\n\n  template <typename T>\n  bool isSameType( LayerSettingTypeEXT layerSettingType )\n  {\n    switch ( layerSettingType )\n    {\n      case LayerSettingTypeEXT::eBool32: return std::is_same<T, VULKAN_HPP_NAMESPACE::Bool32>::value;\n      case LayerSettingTypeEXT::eInt32: return std::is_same<T, int32_t>::value;\n      case LayerSettingTypeEXT::eInt64: return std::is_same<T, int64_t>::value;\n      case LayerSettingTypeEXT::eUint32: return std::is_same<T, uint32_t>::value;\n      case LayerSettingTypeEXT::eUint64: return std::is_same<T, uint64_t>::value;\n      case LayerSettingTypeEXT::eFloat32: return std::is_same<T, float>::value;\n      case LayerSettingTypeEXT::eFloat64: return std::is_same<T, double>::value;\n      case LayerSettingTypeEXT::eString: return std::is_same<T, char *>::value;\n      default: return false;\n    }\n  }\n)\";\n\n  return typeTraits;\n}\n\nstd::string VulkanHppGenerator::generateLenInitializer(\n  std::vector<MemberData>::const_iterator                                                                                 mit,\n  std::map<std::vector<MemberData>::const_iterator, std::vector<std::vector<MemberData>::const_iterator>>::const_iterator litit,\n  bool                                                                                                                    mutualExclusiveLens ) const\n{\n  std::string initializer;\n  if ( mutualExclusiveLens )\n  {\n    // there are multiple mutually exclusive arrays related to this len\n    for ( size_t i = 0; i + 1 < litit->second.size(); i++ )\n    {\n      auto        arrayIt      = litit->second[i];\n      std::string argumentName = startLowerCase( stripPrefix( arrayIt->name, \"p\" ) ) + \"_\";\n      initializer += \"!\" + argumentName + \".empty() ? \" + argumentName + \".size() : \";\n    }\n    auto        arrayIt      = litit->second.back();\n    std::string argumentName = startLowerCase( stripPrefix( arrayIt->name, \"p\" ) ) + \"_\";\n    initializer += argumentName + \".size()\";\n  }\n  else\n  {\n    auto arrayIt = litit->second.front();\n    assert( ( arrayIt->lenExpressions.front() == litit->first->name ) ||\n            ( ( arrayIt->lenExpressions.front() == \"codeSize / 4\" ) && ( litit->first->name == \"codeSize\" ) ) );\n\n    assert( arrayIt->type.isPointer() || !arrayIt->arraySizes.empty() );\n    assert( !arrayIt->type.isPointer() || arrayIt->name.starts_with( \"p\" ) );\n    std::string argumentName = ( arrayIt->type.isPointer() ? startLowerCase( stripPrefix( arrayIt->name, \"p\" ) ) : arrayIt->name ) + \"_\";\n\n    assert( mit->type.prefix.empty() && mit->type.postfix.empty() );\n    initializer = argumentName + \".size()\";\n    if ( arrayIt->lenExpressions.front() == \"codeSize / 4\" )\n    {\n      initializer += \" * 4\";\n    }\n    if ( ( arrayIt->type.type == \"void\" ) &&\n         ( std::count_if( arrayIt->type.postfix.begin(), arrayIt->type.postfix.end(), []( char c ) { return c == '*'; } ) < 2 ) )\n    {\n      initializer += \" * sizeof(T)\";\n    }\n  }\n  if ( mit->type.type != \"size_t\" )\n  {\n    initializer = \"static_cast<\" + mit->type.type + \">( \" + initializer + \" )\";\n  }\n  if ( !litit->second.front()->arraySizes.empty() )\n  {\n    assert( litit->second.front()->arraySizes.size() == 1 );\n    initializer = \"(std::min)( \" + initializer + \", \" + litit->second.front()->arraySizes[0] + \" )\";\n  }\n  return initializer;\n}\n\nstd::string VulkanHppGenerator::generateName( TypeInfo const & typeInfo ) const\n{\n  std::string name = stripPrefix( typeInfo.type, \"Vk\" );\n  assert( typeInfo.prefix.find( '*' ) == std::string::npos );\n  if ( typeInfo.postfix.find( '*' ) != std::string::npos )\n  {\n    assert( typeInfo.postfix.find_first_of( '*' ) == typeInfo.postfix.find_last_of( '*' ) );\n    name = \"p\" + name;\n  }\n  else\n  {\n    name = startLowerCase( name );\n  }\n  return name;\n}\n\nstd::string VulkanHppGenerator::generateNoExcept( std::vector<std::string> const &          errorCodes,\n                                                  std::vector<size_t> const &               returnParams,\n                                                  std::map<size_t, VectorParamData> const & vectorParams,\n                                                  CommandFlavourFlags                       flavourFlags,\n                                                  bool                                      vectorSizeCheck,\n                                                  bool                                      raii ) const\n{\n  // noexcept is only possible with no error codes, and the return param (if any) is not a vector param (unless it's the singular version)\n  return ( errorCodes.empty() &&\n           ( ( flavourFlags & CommandFlavourFlagBits::singular ) || returnParams.empty() ||\n             std::none_of( returnParams.begin(), returnParams.end(), [&vectorParams]( size_t rp ) { return vectorParams.contains( rp ); } ) ) )\n         ? ( vectorSizeCheck ? ( raii ? \"\" : \" VULKAN_HPP_NOEXCEPT_WHEN_NO_EXCEPTIONS\" ) : \" VULKAN_HPP_NOEXCEPT\" )\n         : \"\";\n}\n\nstd::string VulkanHppGenerator::generateObjectDeleter( std::string const & commandName,\n                                                       CommandData const & commandData,\n                                                       size_t              initialSkipCount,\n                                                       size_t              returnParam ) const\n{\n  std::string objectDeleter, allocator;\n  if ( ( commandName.find( \"Acquire\" ) != std::string::npos ) || ( commandName.find( \"Get\" ) != std::string::npos ) )\n  {\n    if ( ( commandName == \"vkAcquirePerformanceConfigurationINTEL\" ) || ( commandName == \"vkGetRandROutputDisplayEXT\" ) ||\n         ( commandName == \"vkGetWinrtDisplayNV\" ) || ( commandName == \"vkGetDrmDisplayEXT\" ) )\n    {\n      objectDeleter = \"detail::ObjectRelease\";\n    }\n    else\n    {\n      throw std::runtime_error( \"Found \" + commandName + \" which requires special handling for the object deleter\" );\n    }\n  }\n  else if ( commandName.find( \"Allocate\" ) != std::string::npos )\n  {\n    objectDeleter = \"detail::ObjectFree\";\n    allocator     = \"allocator, \";\n  }\n  else\n  {\n    assert( ( commandName.find( \"Create\" ) != std::string::npos ) || ( commandName.find( \"Register\" ) != std::string::npos ) );\n    objectDeleter = \"detail::ObjectDestroy\";\n    allocator     = \"allocator, \";\n  }\n  std::string className  = initialSkipCount ? stripPrefix( commandData.params[initialSkipCount - 1].type.type, \"Vk\" ) : \"\";\n  std::string parentName = ( className.empty() || ( commandData.params[returnParam].type.type == \"VkDevice\" ) ) ? \"detail::NoParent\" : className;\n  return objectDeleter + \"<\" + parentName + \", Dispatch>( \" + ( ( parentName == \"detail::NoParent\" ) ? \"\" : \"*this, \" ) + allocator + \"d )\";\n}\n\nstd::string VulkanHppGenerator::generateObjectTypeToDebugReportObjectType() const\n{\n  auto objectTypeToDebugReportObjectTypeTemplate = std::string{ R\"(\n  //===========================================================\n  //=== Mapping from ObjectType to DebugReportObjectTypeEXT ===\n  //===========================================================\n\n  VULKAN_HPP_INLINE VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT debugReportObjectType( VULKAN_HPP_NAMESPACE::ObjectType objectType )\n  {\n    switch( objectType )\n    {\n${objectTypeCases}\n      default:\n        VULKAN_HPP_ASSERT( false && \"unknown ObjectType\" );\n        return VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT::eUnknown;\n    }\n  }\n)\" };\n\n  auto const generateObjectTypeCases = [this]( std::vector<RequireData> const & requireData, std::string const & title )\n  {\n    static const std::string objectTypeCaseTemplate =\n      \"      case VULKAN_HPP_NAMESPACE::ObjectType::${objectType} : return VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT::${debugReportObjectType};\\n\";\n\n    std::string objectTypeCases;\n    for ( auto const & require : requireData )\n    {\n      for ( auto const & type : require.types )\n      {\n        auto handleIt = m_handles.find( type.name );\n        if ( handleIt != m_handles.end() )\n        {\n          objectTypeCases += replaceWithMap( objectTypeCaseTemplate,\n                                             { { \"debugReportObjectType\", generateDebugReportObjectType( handleIt->second.objTypeEnum ) },\n                                               { \"objectType\", generateEnumValueName( \"VkObjectType\", handleIt->second.objTypeEnum, false ) } } );\n        }\n      }\n    }\n    return addTitleAndProtection( title, objectTypeCases );\n  };\n\n  std::string objectTypeCases;\n  for ( auto const & feature : m_features )\n  {\n    objectTypeCases += generateObjectTypeCases( feature.requireData, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    objectTypeCases += generateObjectTypeCases( extension.requireData, extension.name );\n  }\n\n  return replaceWithMap( objectTypeToDebugReportObjectTypeTemplate, { { \"objectTypeCases\", objectTypeCases } } );\n}\n\nstd::pair<std::string, std::string> VulkanHppGenerator::generateProtection( std::string const & protect, bool defined ) const\n{\n  auto const openProtect = defined ? \"#if defined( \" : \"#if !defined( \";\n  return protect.empty() ? std::make_pair( \"\", \"\" ) : std::make_pair( openProtect + protect + \" )\\n\", \"#endif /*\" + protect + \"*/\\n\" );\n}\n\nstd::string VulkanHppGenerator::generateRAIICommandDefinitions() const\n{\n  const std::string commandDefinitionsTemplate = R\"(\n  //===========================\n  //=== COMMAND Definitions ===\n  //===========================\n\n${commandDefinitions}\n)\";\n\n  std::string           commandDefinitions;\n  std::set<std::string> listedCommands;  // some commands are listed with more than one extension!\n  for ( auto const & feature : m_features )\n  {\n    commandDefinitions += generateRAIICommandDefinitions( feature.requireData, listedCommands, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    commandDefinitions += generateRAIICommandDefinitions( extension.requireData, listedCommands, extension.name );\n  }\n\n  return replaceWithMap( commandDefinitionsTemplate, { { \"commandDefinitions\", commandDefinitions } } );\n}\n\nstd::string VulkanHppGenerator::generateRAIICommandDefinitions( std::vector<RequireData> const & requireData,\n                                                                std::set<std::string> &          listedCommands,\n                                                                std::string const &              title ) const\n{\n  std::string str;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & command : require.commands )\n    {\n      if ( listedCommands.insert( command.name ).second )\n      {\n        str += generateRAIIHandleCommand( command.name, determineInitialSkipCount( command.name ), true );\n      }\n    }\n  }\n  return addTitleAndProtection( title, str );\n}\n\nstd::string VulkanHppGenerator::generateRAIIDispatchers() const\n{\n  std::string contextInitializers, contextMembers, deviceAssignments, deviceMembers, instanceAssignments, instanceMembers;\n\n  std::set<std::string> listedCommands;\n  for ( auto const & feature : m_features )\n  {\n    appendRAIIDispatcherCommands( feature.requireData,\n                                  listedCommands,\n                                  feature.name,\n                                  contextInitializers,\n                                  contextMembers,\n                                  deviceAssignments,\n                                  deviceMembers,\n                                  instanceAssignments,\n                                  instanceMembers );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    appendRAIIDispatcherCommands( extension.requireData,\n                                  listedCommands,\n                                  extension.name,\n                                  contextInitializers,\n                                  contextMembers,\n                                  deviceAssignments,\n                                  deviceMembers,\n                                  instanceAssignments,\n                                  instanceMembers );\n  }\n\n  std::string contextDispatcherTemplate = R\"(\n    class ContextDispatcher : public ::VULKAN_HPP_NAMESPACE::detail::DispatchLoaderBase\n    {\n    public:\n      ContextDispatcher( PFN_vkGetInstanceProcAddr getProcAddr )\n        : vkGetInstanceProcAddr( getProcAddr )${contextInitializers}\n      {}\n\n    public:\n      PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = 0;\n${contextMembers}\n    };\n)\";\n\n  std::string str = replaceWithMap( contextDispatcherTemplate, { { \"contextInitializers\", contextInitializers }, { \"contextMembers\", contextMembers } } );\n\n  std::string instanceDispatcherTemplate = R\"(\n    class InstanceDispatcher : public ::VULKAN_HPP_NAMESPACE::detail::DispatchLoaderBase\n    {\n    public:\n      InstanceDispatcher( PFN_vkGetInstanceProcAddr getProcAddr, VkInstance instance )\n        : vkGetInstanceProcAddr( getProcAddr )\n      {\n${instanceAssignments}\n        vkGetDeviceProcAddr =\n          PFN_vkGetDeviceProcAddr( vkGetInstanceProcAddr( instance, \"vkGetDeviceProcAddr\" ) );\n      }\n\n    public:\n${instanceMembers}\n      PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr = 0;\n    };\n)\";\n\n  str += replaceWithMap( instanceDispatcherTemplate, { { \"instanceAssignments\", instanceAssignments }, { \"instanceMembers\", instanceMembers } } );\n\n  std::string deviceDispatcherTemplate = R\"(\n    class DeviceDispatcher : public ::VULKAN_HPP_NAMESPACE::detail::DispatchLoaderBase\n    {\n    public:\n      DeviceDispatcher( PFN_vkGetDeviceProcAddr getProcAddr, VkDevice device ) : vkGetDeviceProcAddr( getProcAddr )\n      {\n${deviceAssignments}\n      }\n\n    public:\n${deviceMembers}\n    };\n)\";\n\n  str += replaceWithMap( deviceDispatcherTemplate, { { \"deviceAssignments\", deviceAssignments }, { \"deviceMembers\", deviceMembers } } );\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateRAIIFactoryReturnStatements( std::vector<ParamData> const &   params,\n                                                                     std::vector<std::string> const & successCodes,\n                                                                     std::string const &              vkType,\n                                                                     bool                             enumerating,\n                                                                     std::string const &              returnType,\n                                                                     std::string const &              returnVariable,\n                                                                     bool                             singular ) const\n{\n  auto handleIt = m_handles.find( vkType );\n  assert( handleIt != m_handles.end() );\n\n  std::string successCodePassToElement = ( enumerating ? ( successCodes.size() <= 2 ) : ( successCodes.size() <= 1 ) ) ? \"\" : \", result\";\n  if ( returnType.starts_with( \"std::vector\" ) )\n  {\n    assert( !successCodes.empty() );\n\n    std::string const & returnTemplate = R\"(${returnType} ${returnVariable}RAII;\n        ${returnVariable}RAII.reserve( ${returnVariable}.size() );\n        for ( auto & ${element} : ${returnVariable} )\n        {\n          ${returnVariable}RAII.emplace_back( *this, ${handleConstructorArguments}${successCodePassToElement} );\n        }\n        return ${returnVariable}RAII;\n)\";\n\n    std::string element                    = stripPluralS( returnVariable );\n    std::string handleConstructorArguments = generateRAIIHandleSingularConstructorArguments( *handleIt, params, vkType, element );\n\n    return replaceWithMap( returnTemplate,\n                           { { \"element\", element },\n                             { \"handleConstructorArguments\", handleConstructorArguments },\n                             { \"successCodePassToElement\", successCodePassToElement },\n                             { \"returnType\", returnType },\n                             { \"returnVariable\", returnVariable } } );\n  }\n  else\n  {\n    std::string const & returnTemplate = \"return ${returnType}( *this, ${handleConstructorArguments}${successCodePassToElement} );\";\n\n    std::string handleConstructorArguments =\n      generateRAIIHandleSingularConstructorArguments( *handleIt, params, vkType, singular ? stripPluralS( returnVariable ) : returnVariable );\n\n    return replaceWithMap( returnTemplate,\n                           { { \"returnType\", returnType },\n                             { \"handleConstructorArguments\", handleConstructorArguments },\n                             { \"successCodePassToElement\", successCodePassToElement } } );\n  }\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandle( std::pair<std::string, HandleData> const & handle,\n                                                    std::set<std::string> &                    listedHandles,\n                                                    std::set<std::string> const &              specialFunctions ) const\n{\n  std::string str;\n  if ( !listedHandles.contains( handle.first ) )\n  {\n    rescheduleRAIIHandle( str, handle, listedHandles, specialFunctions );\n\n    auto [enter, leave]    = generateProtection( getProtectFromType( handle.first ) );\n    std::string handleType = stripPrefix( handle.first, \"Vk\" );\n    std::string handleName = generateRAIIHandleConstructorParamName( handle.first, handle.second.destructorIt );\n\n    auto [singularConstructors, arrayConstructors] = generateRAIIHandleConstructors( handle );\n\n    auto [clearMembers, getConstructorSuccessCode, memberVariables, moveConstructorInitializerList, moveAssignmentInstructions, swapMembers, releaseMembers] =\n      generateRAIIHandleDetails( handle );\n\n    std::string declarations = generateRAIIHandleCommandDeclarations( handle, specialFunctions );\n\n    assert( !handle.second.objTypeEnum.empty() );\n    auto enumIt = m_enums.find( \"VkObjectType\" );\n    assert( enumIt != m_enums.end() );\n    assert( contains( enumIt->second.values, handle.second.objTypeEnum ) );\n    std::string objTypeEnum = generateEnumValueName( enumIt->first, handle.second.objTypeEnum, false );\n\n    enumIt = m_enums.find( \"VkDebugReportObjectTypeEXT\" );\n    assert( enumIt != m_enums.end() );\n    std::string valueName             = handle.second.objTypeEnum;\n    valueName                         = valueName.replace( 3, 0, \"DEBUG_REPORT_\" ) + \"_EXT\";\n    std::string debugReportObjectType = contains( enumIt->second.values, valueName ) ? generateEnumValueName( enumIt->first, valueName, false ) : \"eUnknown\";\n\n    std::string dispatcherType = ( ( handle.first == \"VkDevice\" ) || ( handle.second.constructorIts.front()->second.params.front().type.type == \"VkDevice\" ) )\n                                 ? \"VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::DeviceDispatcher\"\n                                 : \"VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::InstanceDispatcher\";\n\n    std::string getParent;\n    if ( ( handle.first != \"VkInstance\" ) && ( handle.first != \"VkDevice\" ) && ( handle.second.destructorIt != m_commands.end() ) )\n    {\n      assert( !handle.second.destructorIt->second.params.empty() );\n      std::string parentType = stripPrefix( handle.second.destructorIt->second.params.front().type.type, \"Vk\" );\n      getParent              = \"    VULKAN_HPP_NAMESPACE::\" + parentType + \" get\" + parentType + \"() const\\n\";\n      getParent += \"    {\\n\";\n      getParent += \"      return m_\" + handle.second.destructorIt->second.params.front().name + \";\\n\";\n      getParent += \"    }\\n\";\n    }\n\n    std::string assignmentOperator, copyConstructor;\n    if ( handle.second.destructorIt == m_commands.end() )\n    {\n      // allow copy constructor and assignment operator for classes without destructor\n      std::string const copyConstructorTemplate =\n        R\"(      ${handleType}( ${handleType} const & rhs ) : m_${handleName}( rhs.m_${handleName} ), m_dispatcher( rhs.m_dispatcher ) {})\";\n      copyConstructor += replaceWithMap( copyConstructorTemplate, { { \"handleName\", handleName }, { \"handleType\", handleType } } );\n\n      std::string assignmentOperatorTemplate = R\"(      ${handleType} & operator=( ${handleType} const & rhs )\n      {\n        m_${handleName} = rhs.m_${handleName};\n        m_dispatcher    = rhs.m_dispatcher;\n        return *this;\n      })\";\n      assignmentOperator += replaceWithMap( assignmentOperatorTemplate, { { \"handleName\", handleName }, { \"handleType\", handleType } } );\n    }\n    else\n    {\n      std::string const copyConstructorTemplate = R\"(      ${handleType}( ${handleType} const & ) = delete;)\";\n      copyConstructor += replaceWithMap( copyConstructorTemplate, { { \"handleType\", handleType } } );\n\n      std::string const assignmentOperatorTemplate = R\"(      ${handleType} & operator=( ${handleType} const & ) = delete;)\";\n      assignmentOperator += replaceWithMap( assignmentOperatorTemplate, { { \"handleType\", handleType } } );\n    }\n\n    const std::string handleTemplate = R\"(\n${enter}  class ${handleType}\n  {\n  public:\n    using CType = Vk${handleType};\n    using CppType = VULKAN_HPP_NAMESPACE::${handleType};\n\n    static VULKAN_HPP_CONST_OR_CONSTEXPR VULKAN_HPP_NAMESPACE::ObjectType objectType = VULKAN_HPP_NAMESPACE::ObjectType::${objTypeEnum};\n    static VULKAN_HPP_CONST_OR_CONSTEXPR VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT debugReportObjectType = VULKAN_HPP_NAMESPACE::DebugReportObjectTypeEXT::${debugReportObjectType};\n\n  public:\n${singularConstructors}\n    ${handleType}( std::nullptr_t ) {}\n\n    ~${handleType}()\n    {\n      clear();\n    }\n\n    ${handleType}() = delete;\n${copyConstructor}\n    ${handleType}( ${handleType} && rhs ) VULKAN_HPP_NOEXCEPT\n      : ${moveConstructorInitializerList}\n    {}\n${assignmentOperator}\n    ${handleType} & operator=( ${handleType} && rhs ) VULKAN_HPP_NOEXCEPT\n    {\n      if ( this != &rhs )\n      {\n${moveAssignmentInstructions}\n      }\n      return *this;\n    }\n\n    VULKAN_HPP_NAMESPACE::${handleType} const & operator*() const VULKAN_HPP_NOEXCEPT\n    {\n      return m_${handleName};\n    }\n\n    operator VULKAN_HPP_NAMESPACE::${handleType}() const VULKAN_HPP_NOEXCEPT\n    {\n      return m_${handleName};\n    }\n\n    void clear() VULKAN_HPP_NOEXCEPT\n    {\n${clearMembers}\n    }\n\n    VULKAN_HPP_NAMESPACE::${handleType} release()\n    {\n${releaseMembers}\n    }\n\n${getConstructorSuccessCode}\n${getParent}\n    ${dispatcherType} const * getDispatcher() const\n    {\n      VULKAN_HPP_ASSERT( m_dispatcher->getVkHeaderVersion() == VK_HEADER_VERSION );\n      return ${getDispatcherReturn}m_dispatcher;\n    }\n\n    void swap( VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::${handleType} & rhs ) VULKAN_HPP_NOEXCEPT\n    {\n      ${swapMembers}\n    }\n\n    ${memberFunctionsDeclarations}\n\n  private:\n    ${memberVariables}\n  };\n\n  template <>\n  struct isVulkanRAIIHandleType<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::${handleType}>\n  {\n    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = true;\n  };\n\n${leave})\";\n\n    str += replaceWithMap( handleTemplate,\n                           { { \"assignmentOperator\", assignmentOperator },\n                             { \"clearMembers\", clearMembers },\n                             { \"copyConstructor\", copyConstructor },\n                             { \"debugReportObjectType\", debugReportObjectType },\n                             { \"dispatcherType\", dispatcherType },\n                             { \"enter\", enter },\n                             { \"getConstructorSuccessCode\", getConstructorSuccessCode },\n                             { \"getDispatcherReturn\", ( handleType == \"Device\" ) || ( handleType == \"Instance\" ) ? \"&*\" : \"\" },\n                             { \"getParent\", getParent },\n                             { \"handleName\", handleName },\n                             { \"handleType\", handleType },\n                             { \"leave\", leave },\n                             { \"memberFunctionsDeclarations\", declarations },\n                             { \"memberVariables\", memberVariables },\n                             { \"moveAssignmentInstructions\", moveAssignmentInstructions },\n                             { \"moveConstructorInitializerList\", moveConstructorInitializerList },\n                             { \"objTypeEnum\", objTypeEnum },\n                             { \"releaseMembers\", releaseMembers },\n                             { \"singularConstructors\", singularConstructors },\n                             { \"swapMembers\", swapMembers } } );\n\n    if ( !arrayConstructors.empty() )\n    {\n      // it's a handle class with a friendly handles class\n      const std::string handlesTemplate = R\"(\n${enter}  class ${handleType}s : public std::vector<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::${handleType}>\n  {\n  public:\n    ${arrayConstructors}\n    ${handleType}s( std::nullptr_t ) {}\n\n    ${handleType}s() = delete;\n    ${handleType}s( ${handleType}s const & ) = delete;\n    ${handleType}s( ${handleType}s && rhs ) = default;\n    ${handleType}s & operator=( ${handleType}s const & ) = delete;\n    ${handleType}s & operator=( ${handleType}s && rhs ) = default;\n\n  private:\n    ${handleType}s( std::vector<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::${handleType}> && rhs )\n      {\n        std::swap( *this, rhs );\n      }\n  };\n${leave}\n)\";\n\n      str +=\n        replaceWithMap( handlesTemplate, { { \"arrayConstructors\", arrayConstructors }, { \"enter\", enter }, { \"handleType\", handleType }, { \"leave\", leave } } );\n    }\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleCommand( std::string const & command, size_t initialSkipCount, bool definition ) const\n{\n  std::string str;\n  if ( !m_RAIISpecialFunctions.contains( command ) )\n  {\n    auto commandIt = findByNameOrAlias( m_commands, command );\n    assert( commandIt != m_commands.end() );\n    str = generateCommand( command, commandIt->second, initialSkipCount, definition, true );\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleCommandDeclarations( std::pair<std::string, HandleData> const & handle,\n                                                                       std::set<std::string> const &              specialFunctions ) const\n{\n  std::string                     functionDeclarations;\n  std::map<std::string, NameLine> listedCommands;  // some commands are listed with more than one extension !\n  for ( auto const & feature : m_features )\n  {\n    std::vector<std::string> firstLevelCommands, secondLevelCommands;\n\n    for ( auto const & require : feature.requireData )\n    {\n      for ( auto const & command : require.commands )\n      {\n        if ( !specialFunctions.contains( command.name ) )\n        {\n          if ( handle.second.commands.contains( command.name ) )\n          {\n            assert( !listedCommands.contains( command.name ) );\n            listedCommands.insert( { command.name, { feature.name, command.xmlLine } } );\n            firstLevelCommands.push_back( command.name );\n          }\n          else if ( handle.second.secondLevelCommands.contains( command.name ) )\n          {\n            auto listedIt = listedCommands.find( command.name );\n            if ( listedIt == listedCommands.end() )\n            {\n              listedCommands.insert( { command.name, { feature.name, command.xmlLine } } );\n              assert( !handle.first.empty() );\n              secondLevelCommands.push_back( command.name );\n            }\n            else\n            {\n              checkForError( listedIt->second.name == feature.name,\n                             command.xmlLine,\n                             \"command <\" + command.name + \"> already listed as required for feature <\" + listedIt->second.name + \"> on line \" +\n                               std::to_string( listedIt->second.xmlLine ) );\n            }\n          }\n        }\n      }\n    }\n    if ( !firstLevelCommands.empty() || !secondLevelCommands.empty() )\n    {\n      functionDeclarations += \"\\n  //=== \" + feature.name + \" ===\\n\";\n      for ( auto const & command : firstLevelCommands )\n      {\n        functionDeclarations += generateRAIIHandleCommand( command, handle.first.empty() ? 0 : 1, false );\n      }\n      for ( auto const & command : secondLevelCommands )\n      {\n        assert( !handle.first.empty() );\n        functionDeclarations += generateRAIIHandleCommand( command, 2, false );\n      }\n    }\n  }\n\n  for ( auto const & extension : m_extensions )\n  {\n    std::vector<std::string> firstLevelCommands, secondLevelCommands;\n    for ( auto & req : extension.requireData )\n    {\n      for ( auto const & command : req.commands )\n      {\n        if ( !specialFunctions.contains( command.name ) && !listedCommands.contains( command.name ) )\n        {\n          if ( handle.second.commands.contains( command.name ) )\n          {\n            listedCommands.insert( { command.name, { extension.name, command.xmlLine } } );\n            firstLevelCommands.push_back( command.name );\n          }\n          else if ( handle.second.secondLevelCommands.contains( command.name ) )\n          {\n            listedCommands.insert( { command.name, { extension.name, command.xmlLine } } );\n            secondLevelCommands.push_back( command.name );\n          }\n        }\n      }\n    }\n    if ( !firstLevelCommands.empty() || !secondLevelCommands.empty() )\n    {\n      std::string handleProtect = getProtectFromType( handle.first );\n      std::string titleProtect  = getProtectFromTitle( extension.name );\n      std::string enter, leave;\n      if ( !titleProtect.empty() && ( titleProtect != handleProtect ) )\n      {\n        std::tie( enter, leave ) = generateProtection( titleProtect );\n      }\n      functionDeclarations += \"\\n\" + enter + \"  //=== \" + extension.name + \" ===\\n\";\n      for ( auto const & command : firstLevelCommands )\n      {\n        functionDeclarations += generateRAIIHandleCommand( command, handle.first.empty() ? 0 : 1, false );\n      }\n      for ( auto const & command : secondLevelCommands )\n      {\n        assert( !handle.first.empty() );\n        functionDeclarations += generateRAIIHandleCommand( command, 2, false );\n      }\n      functionDeclarations += leave;\n    }\n  }\n  return functionDeclarations;\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleCommandEnhanced( std::string const &                       name,\n                                                                   CommandData const &                       commandData,\n                                                                   size_t                                    initialSkipCount,\n                                                                   std::vector<size_t> const &               returnParams,\n                                                                   std::map<size_t, VectorParamData> const & vectorParams,\n                                                                   bool                                      definition,\n                                                                   CommandFlavourFlags                       flavourFlags ) const\n{\n  const bool singular = flavourFlags & CommandFlavourFlagBits::singular;\n\n  std::set<size_t> skippedParams  = determineSkippedParams( commandData.params, initialSkipCount, vectorParams, returnParams, singular );\n  std::set<size_t> singularParams = singular ? determineSingularParams( returnParams[0], vectorParams ) : std::set<size_t>();\n  std::set<size_t> templatedParams =\n    ( flavourFlags & CommandFlavourFlagBits::keepVoidPtr ) ? std::set<size_t>() : determineVoidPointerParams( commandData.params );\n  std::vector<size_t> chainedReturnParams =\n    ( flavourFlags & CommandFlavourFlagBits::chained ) ? determineChainedReturnParams( commandData.params, returnParams ) : std::vector<size_t>();\n  assert( chainedReturnParams.size() <= 1 );\n\n  const bool               enumerating = determineEnumeration( vectorParams, returnParams );\n  std::vector<std::string> dataTypes   = determineDataTypes( commandData.params, vectorParams, returnParams, templatedParams );\n  std::string              dataType    = combineDataTypes( vectorParams, returnParams, enumerating, dataTypes, flavourFlags, true );\n\n  std::string argumentTemplates = generateArgumentTemplates( commandData.params, returnParams, vectorParams, templatedParams, chainedReturnParams, true );\n  std::string argumentList      = generateArgumentListEnhanced(\n    commandData.params, returnParams, vectorParams, skippedParams, singularParams, templatedParams, chainedReturnParams, definition, flavourFlags, false );\n  std::string commandName = generateCommandName( name, commandData.params, initialSkipCount, flavourFlags );\n  std::string nodiscard   = generateNoDiscard(\n    !returnParams.empty() || ( ( commandData.returnType != \"VkResult\" ) && ( commandData.returnType != \"void\" ) ), 1 < commandData.successCodes.size(), false );\n  std::pair<bool, std::map<size_t, std::vector<size_t>>> vectorSizeCheck =\n    needsVectorSizeCheck( commandData.params, vectorParams, returnParams, singularParams, skippedParams );\n  std::string noexceptString      = generateNoExcept( commandData.errorCodes, returnParams, vectorParams, flavourFlags, vectorSizeCheck.first, true );\n  std::string returnType          = generateReturnType( returnParams, vectorParams, flavourFlags, true, dataTypes );\n  std::string decoratedReturnType = generateDecoratedReturnType( commandData, returnParams, vectorParams, flavourFlags, true, returnType );\n\n  if ( definition )\n  {\n    std::string const definitionTemplate =\n      R\"(\n  ${argumentTemplates}\n  ${nodiscard} VULKAN_HPP_INLINE ${returnType} ${className}::${commandName}( ${argumentList} ) const ${noexcept}\n  {\n${functionPointerCheck}\n${vectorSizeCheck}\n    ${dataSizeChecks}\n    ${dataDeclarations}\n    ${callSequence}\n    ${resultCheck}\n    ${dataPreparation}\n    ${returnStatement}\n  }\n)\";\n\n    std::string callSequence = generateCallSequence(\n      name, commandData, returnParams, vectorParams, initialSkipCount, singularParams, templatedParams, chainedReturnParams, flavourFlags, true, false );\n    std::string className      = initialSkipCount ? stripPrefix( commandData.params[initialSkipCount - 1].type.type, \"Vk\" ) : \"Context\";\n    std::string returnVariable = generateReturnVariable( commandData, returnParams, vectorParams, flavourFlags );\n    std::string dataDeclarations =\n      generateDataDeclarations( commandData, returnParams, vectorParams, templatedParams, flavourFlags, true, dataTypes, dataType, returnType, returnVariable );\n    std::string dataPreparation =\n      generateDataPreparation( commandData, initialSkipCount, returnParams, vectorParams, templatedParams, flavourFlags, enumerating, dataTypes );\n    std::string dataSizeChecks  = generateDataSizeChecks( commandData, returnParams, dataTypes, vectorParams, templatedParams, singular );\n    std::string resultCheck     = generateResultCheck( commandData, className, \"::\", commandName, enumerating );\n    std::string returnStatement = generateReturnStatement( name,\n                                                           commandData,\n                                                           returnVariable,\n                                                           returnType,\n                                                           decoratedReturnType,\n                                                           dataType,\n                                                           initialSkipCount,\n                                                           returnParams.empty() ? INVALID_INDEX : returnParams[0],\n                                                           flavourFlags,\n                                                           enumerating,\n                                                           true );\n    std::string vectorSizeCheckString =\n      vectorSizeCheck.first ? generateVectorSizeCheck( name, commandData, initialSkipCount, vectorSizeCheck.second, skippedParams, false ) : \"\";\n\n    return replaceWithMap( definitionTemplate,\n                           { { \"argumentList\", argumentList },\n                             { \"argumentTemplates\", argumentTemplates },\n                             { \"callSequence\", callSequence },\n                             { \"className\", className },\n                             { \"commandName\", commandName },\n                             { \"dataDeclarations\", dataDeclarations },\n                             { \"dataPreparation\", dataPreparation },\n                             { \"dataSizeChecks\", dataSizeChecks },\n                             { \"functionPointerCheck\", generateFunctionPointerCheck( name, commandData.requiredBy, true ) },\n                             { \"nodiscard\", nodiscard },\n                             { \"noexcept\", noexceptString },\n                             { \"resultCheck\", resultCheck },\n                             { \"returnStatement\", returnStatement },\n                             { \"returnType\", decoratedReturnType },\n                             { \"vectorSizeCheck\", vectorSizeCheckString } } );\n  }\n  else\n  {\n    std::string const declarationTemplate =\n      R\"(\n    ${argumentTemplates}\n    ${nodiscard} ${returnType} ${commandName}( ${argumentList} ) const ${noexcept};\n)\";\n\n    return replaceWithMap( declarationTemplate,\n                           { { \"argumentList\", argumentList },\n                             { \"argumentTemplates\", argumentTemplates },\n                             { \"commandName\", commandName },\n                             { \"nodiscard\", nodiscard },\n                             { \"noexcept\", noexceptString },\n                             { \"returnType\", decoratedReturnType } } );\n  }\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleCommandFactory( std::string const &                       name,\n                                                                  CommandData const &                       commandData,\n                                                                  size_t                                    initialSkipCount,\n                                                                  std::vector<size_t> const &               returnParams,\n                                                                  std::map<size_t, VectorParamData> const & vectorParams,\n                                                                  bool                                      definition,\n                                                                  CommandFlavourFlags                       flavourFlags ) const\n{\n  assert( isHandleType( commandData.params[returnParams.back()].type.type ) ||\n          ( vectorParams.contains( returnParams.back() ) && vectorParams.find( returnParams.back() )->second.byStructure &&\n            isHandleType( vectorMemberByStructure( commandData.params[returnParams.back()].type.type ).type.type ) ) );\n  assert( ( returnParams.size() == 1 ) ||\n          ( ( returnParams.size() == 2 ) && ( vectorParams.size() == 1 ) && ( returnParams[0] == vectorParams.begin()->second.lenParam ) &&\n            ( returnParams[1] == vectorParams.begin()->first ) ) );\n  assert( determineVoidPointerParams( commandData.params ).empty() );\n\n  const bool       enumerating    = determineEnumeration( vectorParams, returnParams );\n  const bool       singular       = flavourFlags & CommandFlavourFlagBits::singular;\n  std::set<size_t> skippedParams  = determineSkippedParams( commandData.params, initialSkipCount, vectorParams, returnParams, singular );\n  std::set<size_t> singularParams = singular ? determineSingularParams( returnParams.back(), vectorParams ) : std::set<size_t>();\n  std::string      argumentList   = generateRAIIHandleCommandFactoryArgumentList( commandData.params, skippedParams, definition, singular );\n  std::string      commandName    = generateCommandName( name, commandData.params, initialSkipCount, flavourFlags );\n\n  std::string handleType;\n  if ( ( vectorParams.size() == 1 ) && vectorParams.begin()->second.byStructure )\n  {\n    assert( vectorParams.begin()->first == returnParams.back() );\n    handleType = vectorMemberByStructure( commandData.params.back().type.type ).type.compose( \"VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE\" );\n  }\n  else\n  {\n    handleType = commandData.params[returnParams.back()].type.compose( \"VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE\" );\n  }\n  handleType                 = stripPostfix( handleType, \" *\" );\n  std::string noexceptString = enumerating ? \"\" : \"VULKAN_HPP_RAII_CREATE_NOEXCEPT\";\n  std::string returnType     = handleType;\n  if ( vectorParams.contains( returnParams.back() ) && !singular )\n  {\n    noexceptString = \"\";\n    returnType     = \"std::vector<\" + handleType + \">\";\n    handleType += \"s\";\n  }\n\n  if ( definition )\n  {\n    std::string              className      = initialSkipCount ? stripPrefix( commandData.params[initialSkipCount - 1].type.type, \"Vk\" ) : \"Context\";\n    std::vector<std::string> dataTypes      = determineDataTypes( commandData.params, vectorParams, returnParams, {} );\n    std::string              dataType       = combineDataTypes( vectorParams, returnParams, enumerating, dataTypes, flavourFlags, true );\n    std::string              returnVariable = generateReturnVariable( commandData, returnParams, vectorParams, flavourFlags );\n    std::string              vulkanType;\n    auto                     vectorParamIt = vectorParams.find( returnParams.back() );\n    if ( ( vectorParamIt != vectorParams.end() ) && vectorParamIt->second.byStructure )\n    {\n      vulkanType = vectorMemberByStructure( commandData.params[returnParams.back()].type.type ).type.type;\n    }\n    else\n    {\n      vulkanType = commandData.params[returnParams.back()].type.type;\n    }\n\n    std::string dataDeclarations =\n      generateDataDeclarations( commandData, returnParams, vectorParams, {}, flavourFlags, true, dataTypes, dataType, returnType, returnVariable );\n    std::string callSequence =\n      generateCallSequence( name, commandData, returnParams, vectorParams, initialSkipCount, singularParams, {}, {}, flavourFlags, true, true );\n    std::string resultCheck = generateResultCheckExpected( commandData.successCodes, className, commandName );\n    std::string returnStatements =\n      generateRAIIFactoryReturnStatements( commandData.params, commandData.successCodes, vulkanType, enumerating, returnType, returnVariable, singular );\n\n    std::string const definitionTemplate =\n      R\"(\n  VULKAN_HPP_NODISCARD VULKAN_HPP_INLINE VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::CreateReturnType<${returnType}>::Type ${className}::${commandName}( ${argumentList} ) const ${noexcept}\n  {\n    ${dataDeclarations}\n    ${callSequence}\n    ${resultCheck}\n    ${returnStatements}\n  }\n)\";\n\n    return replaceWithMap( definitionTemplate,\n                           { { \"argumentList\", argumentList },\n                             { \"callSequence\", callSequence },\n                             { \"className\", className },\n                             { \"commandName\", commandName },\n                             { \"dataDeclarations\", dataDeclarations },\n                             { \"noexcept\", noexceptString },\n                             { \"resultCheck\", resultCheck },\n                             { \"returnStatements\", returnStatements },\n                             { \"returnType\", returnType } } );\n  }\n  else\n  {\n    std::string const declarationTemplate =\n      R\"(\n  VULKAN_HPP_NODISCARD VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::CreateReturnType<${returnType}>::Type ${commandName}( ${argumentList} ) const ${noexcept};\n)\";\n\n    return replaceWithMap( declarationTemplate,\n                           { { \"argumentList\", argumentList }, { \"commandName\", commandName }, { \"noexcept\", noexceptString }, { \"returnType\", returnType } } );\n  }\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleCommandFactoryArgumentList( std::vector<ParamData> const & params,\n                                                                              std::set<size_t> const &       skippedParams,\n                                                                              bool                           definition,\n                                                                              bool                           singular ) const\n{\n  std::vector<std::string> arguments;\n  for ( size_t i = 0; i < params.size(); ++i )\n  {\n    if ( !skippedParams.contains( i ) )\n    {\n      arguments.push_back( generateRAIIHandleConstructorArgument( params[i], definition, singular, false ) );\n    }\n  }\n  return generateList( arguments, \"\", \", \" );\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleCommandStandard( std::string const & name,\n                                                                   CommandData const & commandData,\n                                                                   size_t              initialSkipCount,\n                                                                   bool                definition ) const\n{\n  std::set<size_t> skippedParams = determineSkippedParams( commandData.params, initialSkipCount, {}, {}, false );\n  std::string      argumentList  = generateArgumentListStandard( commandData.params, skippedParams, definition, false );\n  std::string      commandName   = generateCommandName( name, commandData.params, initialSkipCount );\n  std::string      nodiscard     = ( commandData.returnType != \"void\" ) ? \"VULKAN_HPP_NODISCARD\" : \"\";\n  std::string      returnType =\n    commandData.returnType.starts_with( \"Vk\" ) ? \"VULKAN_HPP_NAMESPACE::\" + stripPrefix( commandData.returnType, \"Vk\" ) : commandData.returnType;\n\n  if ( definition )\n  {\n    std::string functionBody = \"getDispatcher()->\" + name + \"( \" + generateCallArgumentsStandard( commandData.params, initialSkipCount ) + \" )\";\n    if ( commandData.returnType.starts_with( \"Vk\" ) )\n    {\n      functionBody = \"return static_cast<\" + returnType + \">( \" + functionBody + \" )\";\n    }\n    else if ( commandData.returnType != \"void\" )\n    {\n      functionBody = \"return \" + functionBody;\n    }\n\n    std::string const functionTemplate =\n      R\"(  ${nodiscard} VULKAN_HPP_INLINE ${returnType} ${className}::${commandName}( ${argumentList} ) const VULKAN_HPP_NOEXCEPT\n  {\n    ${functionPointerCheck}\n    ${functionBody};\n  })\";\n\n    return replaceWithMap( functionTemplate,\n                           { { \"argumentList\", argumentList },\n                             { \"className\", initialSkipCount ? stripPrefix( commandData.params[initialSkipCount - 1].type.type, \"Vk\" ) : \"Context\" },\n                             { \"commandName\", commandName },\n                             { \"functionBody\", functionBody },\n                             { \"functionPointerCheck\", generateFunctionPointerCheck( name, commandData.requiredBy, true ) },\n                             { \"nodiscard\", nodiscard },\n                             { \"returnType\", returnType } } );\n  }\n  else\n  {\n    std::string const declarationTemplate =\n      R\"(\n    ${nodiscard} ${returnType} ${commandName}( ${argumentList} ) const VULKAN_HPP_NOEXCEPT;\n)\";\n\n    return replaceWithMap( declarationTemplate,\n                           { { \"argumentList\", argumentList }, { \"commandName\", commandName }, { \"nodiscard\", nodiscard }, { \"returnType\", returnType } } );\n  }\n}\n\nstd::pair<std::string, std::string> VulkanHppGenerator::generateRAIIHandleConstructor( std::pair<std::string, HandleData> const &         handle,\n                                                                                       std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                                                       std::string const &                                enter,\n                                                                                       std::string const &                                leave ) const\n{\n  std::string singularConstructor, arrayConstructor;\n  if ( constructorIt->second.returnType == \"VkResult\" )\n  {\n    std::tie( singularConstructor, arrayConstructor ) = generateRAIIHandleConstructorResult( handle, constructorIt, enter, leave );\n  }\n  else if ( constructorIt->second.returnType == \"void\" )\n  {\n    std::tie( singularConstructor, arrayConstructor ) = generateRAIIHandleConstructorVoid( handle, constructorIt, enter, leave );\n  }\n  if ( singularConstructor.empty() && arrayConstructor.empty() )\n  {\n    throw std::runtime_error( \"Never encountered a function like <\" + constructorIt->first + \"> !\" );\n  }\n  return std::make_pair( singularConstructor, arrayConstructor );\n}\n\nstd::pair<std::string, std::string>\n  VulkanHppGenerator::generateRAIIHandleConstructor1Return2Vector( std::pair<std::string, HandleData> const &         handle,\n                                                                   std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                                   std::string const &                                enter,\n                                                                   std::string const &                                leave,\n                                                                   size_t                                             returnParam,\n                                                                   std::map<size_t, VectorParamData> const &          vectorParams ) const\n{\n  if ( returnParam == std::next( vectorParams.begin() )->first )\n  {\n    if ( vectorParams.begin()->second.lenParam == std::next( vectorParams.begin() )->second.lenParam )\n    {\n      if ( constructorIt->second.params[vectorParams.begin()->second.lenParam].type.type == \"uint32_t\" )\n      {\n        if ( ( constructorIt->second.params[vectorParams.begin()->first].type.type != \"void\" ) &&\n             !isHandleType( constructorIt->second.params[vectorParams.begin()->first].type.type ) )\n        {\n          std::string singularConstructor;\n          auto        lenParamIt = constructorIt->second.params.begin() + vectorParams.begin()->second.lenParam;\n          if ( !checkEquivalentSingularConstructor( handle.second.constructorIts, constructorIt, lenParamIt ) )\n          {\n            singularConstructor = generateRAIIHandleConstructorByCall( handle, constructorIt, enter, leave, true, true );\n          }\n          return std::make_pair( singularConstructor, generateRAIIHandleConstructorByCall( handle, constructorIt, enter, leave, true, false ) );\n        }\n      }\n    }\n  }\n  return std::make_pair( \"\", \"\" );\n}\n\nstd::pair<std::string, std::string> VulkanHppGenerator::generateRAIIHandleConstructors( std::pair<std::string, HandleData> const & handle ) const\n{\n  const auto [enter, leave] = generateProtection( getProtectFromType( handle.first ) );\n\n  std::string singularConstructors, arrayConstructors;\n  for ( auto constructorIt : handle.second.constructorIts )\n  {\n    // there is a non-const parameter with handle type : the to-be-constructed handle\n\n    // check for additional enter/leave guards for the constructors\n    auto [constructorEnter, constructorLeave] = generateProtection( getProtectFromTitles( constructorIt->second.requiredBy ) );\n    if ( constructorEnter == enter )\n    {\n      constructorEnter.clear();\n      constructorLeave.clear();\n    }\n\n    const auto [singularConstructor, arrayConstructor] = generateRAIIHandleConstructor( handle, constructorIt, constructorEnter, constructorLeave );\n    arrayConstructors += arrayConstructor;\n    singularConstructors += singularConstructor;\n  }\n  singularConstructors += generateRAIIHandleConstructorTakeOwnership( handle );\n  return std::make_pair( singularConstructors, arrayConstructors );\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleConstructorArgument( ParamData const & param, bool definition, bool singular, bool takesOwnership ) const\n{\n  std::string argument;\n  if ( param.type.isConstPointer() )\n  {\n    assert( param.type.type.starts_with( \"Vk\" ) );\n    assert( param.name.starts_with( \"p\" ) );\n    std::string argumentName = startLowerCase( stripPrefix( param.name, \"p\" ) );\n    std::string argumentType = generateNamespacedType( param.type.type );\n    if ( param.optional )\n    {\n      assert( param.lenExpression.empty() );\n      argument = \"VULKAN_HPP_NAMESPACE::Optional<const \" + argumentType + \"> \" + argumentName + ( definition ? \"\" : \" = nullptr\" );\n    }\n    else if ( param.lenExpression.empty() )\n    {\n      argument = argumentType + \" const & \" + argumentName;\n    }\n    else if ( singular )\n    {\n      argument = argumentType + \" const & \" + stripPluralS( argumentName );\n    }\n    else\n    {\n      argument = \"VULKAN_HPP_NAMESPACE::ArrayProxy<\" + argumentType + \"> const & \" + argumentName;\n    }\n  }\n  else if ( specialPointerTypes.contains( param.type.type ) )\n  {\n    assert( !param.optional );\n    assert( param.type.isNonConstPointer() );\n    argument = param.type.type + \" & \" + param.name;\n  }\n  else if ( ( param.type.isValue() ) && isHandleType( param.type.type ) )\n  {\n    if ( takesOwnership )\n    {\n      assert( !param.optional );\n      argument = param.type.type + \" \" + param.name;\n    }\n    else\n    {\n      argument = \"VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::\" + stripPrefix( param.type.type, \"Vk\" );\n      if ( param.optional )\n      {\n        argument = \"VULKAN_HPP_NAMESPACE::Optional<const \" + argument + \">\";\n      }\n      argument += \" const & \" + param.name;\n    }\n  }\n  else\n  {\n    assert( !param.optional );\n    if ( param.arraySizes.empty() )\n    {\n      argument = param.type.compose( \"VULKAN_HPP_NAMESPACE\" ) + \" \";\n    }\n    else\n    {\n      argument = generateStandardArray( param.type.compose( \"VULKAN_HPP_NAMESPACE\" ), param.arraySizes ) + \" const & \";\n    }\n    argument += param.name;\n  }\n  return argument;\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleConstructorArguments( std::pair<std::string, HandleData> const &         handle,\n                                                                        std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                                        bool                                               singular,\n                                                                        bool                                               takesOwnership ) const\n{\n  auto [parentType, parentName] = getParentTypeAndName( handle );\n\n  std::string arguments = \"VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::\" + parentType + \" const & \" + parentName;\n  if ( takesOwnership )\n  {\n    arguments += \", \" + handle.first + \" \" + generateRAIIHandleConstructorParamName( handle.first, handle.second.destructorIt );\n  }\n\n  if ( constructorIt != m_commands.end() )\n  {\n    parentType      = \"Vk\" + parentType;\n    const bool skip = skipLeadingGrandParent( handle );\n    for ( size_t i = skip ? 1 : 0; i < constructorIt->second.params.size(); i++ )\n    {\n      ParamData const & param = constructorIt->second.params[i];\n      // filter parent and handle type\n      if ( ( param.type.type != parentType ) && ( param.type.type != handle.first ) )\n      {\n        // the specialPointerTypes are considered const-pointers!\n        if ( param.type.isNonConstPointer() && !specialPointerTypes.contains( param.type.type ) )\n        {\n          // this is supposed to be the returned size on an enumeration function!\n#if !defined( NDEBUG )\n          if ( ( param.type.type == \"size_t\" ) || ( param.type.type == \"uint32_t\" ) )\n          {\n            auto typeIt = std::find_if( constructorIt->second.params.begin(),\n                                        constructorIt->second.params.end(),\n                                        [&handle]( ParamData const & pd ) { return pd.type.type == handle.first; } );\n            assert( typeIt != constructorIt->second.params.end() );\n            assert( typeIt->lenExpression == param.name );\n          }\n          else\n          {\n            assert( vectorMemberByStructure( param.type.type ).type.type == handle.first );\n          }\n#endif\n          continue;\n        }\n        else if ( std::any_of( constructorIt->second.params.begin(),\n                               constructorIt->second.params.end(),\n                               [&param]( ParamData const & pd ) { return pd.lenExpression == param.name; } ) )\n        {\n          // this is the len of an other parameter, which will be mapped to an ArrayProxy\n          assert( param.type.isValue() && ( param.type.type == \"uint32_t\" ) );\n          assert( param.arraySizes.empty() && param.lenExpression.empty() && !param.optional );\n          continue;\n        }\n        arguments += \", \" + generateRAIIHandleConstructorArgument( param, false, singular, takesOwnership );\n      }\n    }\n  }\n  return arguments;\n}\n\nstd::string\n  VulkanHppGenerator::generateRAIIHandleConstructorInitializationList( std::pair<std::string, HandleData> const &                             handle,\n                                                                       std::map<std::string, VulkanHppGenerator::CommandData>::const_iterator constructorIt,\n                                                                       std::map<std::string, VulkanHppGenerator::CommandData>::const_iterator destructorIt,\n                                                                       bool takesOwnership ) const\n{\n  const auto [parentType, parentName] = getParentTypeAndName( handle );\n  std::string handleName              = generateRAIIHandleConstructorParamName( handle.first, destructorIt );\n\n  std::string initializationList;\n  if ( destructorIt != m_commands.end() )\n  {\n    for ( auto destructorParam : destructorIt->second.params )\n    {\n      if ( destructorParam.type.type == \"Vk\" + parentType )\n      {\n        initializationList += \"m_\" + parentName + \"( \" + parentName + \" ), \";\n      }\n      else if ( destructorParam.type.type == handle.first )\n      {\n        if ( takesOwnership )\n        {\n          initializationList += \"m_\" + handleName + \"( \" + handleName + \" ), \";\n        }\n      }\n      else if ( destructorParam.type.type == \"VkAllocationCallbacks\" )\n      {\n        assert( destructorParam.type.isConstPointer() && destructorParam.arraySizes.empty() && destructorParam.lenExpression.empty() &&\n                destructorParam.optional );\n        initializationList += \"m_allocator( static_cast<const VULKAN_HPP_NAMESPACE::AllocationCallbacks *>( allocator ) ), \";\n      }\n      else if ( isHandleType( destructorParam.type.type ) )\n      {\n        assert( destructorParam.type.isValue() && destructorParam.arraySizes.empty() && destructorParam.lenExpression.empty() && !destructorParam.optional );\n        initializationList += \"m_\" + destructorParam.name + \"( \";\n        auto constructorParamIt = std::find_if( constructorIt->second.params.begin(),\n                                                constructorIt->second.params.end(),\n                                                [&destructorParam]( ParamData const & pd ) { return pd.type.type == destructorParam.type.type; } );\n        if ( constructorParamIt != constructorIt->second.params.end() )\n        {\n          assert( constructorParamIt->type.isValue() && constructorParamIt->arraySizes.empty() && constructorParamIt->lenExpression.empty() &&\n                  !constructorParamIt->optional );\n          if ( constructorParamIt->type.type == \"Vk\" + parentType )\n          {\n            initializationList += \"*\";\n          }\n          initializationList += constructorParamIt->name;\n        }\n        else\n        {\n#if !defined( NDEBUG )\n          bool found = false;\n#endif\n          for ( auto constructorParam : constructorIt->second.params )\n          {\n            auto structureIt = m_structs.find( constructorParam.type.type );\n            if ( structureIt != m_structs.end() )\n            {\n              auto structureMemberIt = findStructMemberItByType( destructorParam.type.type, structureIt->second.members );\n              if ( structureMemberIt != structureIt->second.members.end() )\n              {\n                assert( constructorParam.type.isConstPointer() && constructorParam.arraySizes.empty() && constructorParam.lenExpression.empty() &&\n                        !constructorParam.optional );\n                initializationList += startLowerCase( stripPrefix( constructorParam.name, \"p\" ) ) + \".\" + structureMemberIt->name;\n#if !defined( NDEBUG )\n                found = true;\n#endif\n                break;\n              }\n            }\n          }\n          assert( found );\n        }\n        initializationList += \" ), \";\n      }\n      else\n      {\n        // we can ignore all other parameters here !\n      }\n    }\n  }\n  else\n  {\n    if ( !handle.second.secondLevelCommands.empty() )\n    {\n      assert( !handle.second.constructorIts.empty() );\n#if !defined( NDEBUG )\n      auto constructorCommandIt = m_commands.find( handle.second.constructorIts.front()->first );\n#endif\n      assert( ( constructorCommandIt != m_commands.end() ) && ( 1 < constructorCommandIt->second.params.size() ) );\n      assert( std::next( constructorCommandIt->second.params.begin() )->type.type == \"Vk\" + parentType );\n\n      auto commandIt = m_commands.find( *handle.second.secondLevelCommands.begin() );\n      assert( ( commandIt != m_commands.end() ) && ( 1 < commandIt->second.params.size() ) );\n      assert( commandIt->second.params.front().type.type == constructorCommandIt->second.params.front().type.type );\n      assert( std::next( commandIt->second.params.begin() )->type.type == handle.first );\n\n      std::string grandParentType = stripPrefix( commandIt->second.params.front().type.type, \"Vk\" );\n      initializationList += \"m_\" + startLowerCase( grandParentType ) + \"( \" + parentName + \".get\" + grandParentType + \"() ), \";\n    }\n    if ( takesOwnership )\n    {\n      initializationList += \"m_\" + handleName + \"( \" + handleName + \" ), \";\n    }\n  }\n  return initializationList.empty() ? initializationList : initializationList.substr( 0, initializationList.size() - 2 );\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleConstructorParamName( std::string const &                                type,\n                                                                        std::map<std::string, CommandData>::const_iterator destructorIt ) const\n{\n  if ( destructorIt != m_commands.end() )\n  {\n    auto destructorParamIt = std::find_if( destructorIt->second.params.begin(),\n                                           destructorIt->second.params.end(),\n                                           [&type]( ParamData const & destructorParam ) { return destructorParam.type.type == type; } );\n    if ( destructorParamIt != destructorIt->second.params.end() )\n    {\n      assert( std::none_of( std::next( destructorParamIt ),\n                            destructorIt->second.params.end(),\n                            [&type]( ParamData const & destructorParam ) { return destructorParam.type.type == type; } ) );\n      if ( !destructorParamIt->type.isValue() )\n      {\n        return startLowerCase( stripPrefix( stripPluralS( destructorParamIt->name ), \"p\" ) );\n      }\n      else\n      {\n        return destructorParamIt->name;\n      }\n    }\n  }\n  return startLowerCase( stripPrefix( type, \"Vk\" ) );\n}\n\nstd::pair<std::string, std::string> VulkanHppGenerator::generateRAIIHandleConstructorResult( std::pair<std::string, HandleData> const &         handle,\n                                                                                             std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                                                             std::string const &                                enter,\n                                                                                             std::string const &                                leave ) const\n{\n  assert( !constructorIt->second.successCodes.empty() );\n  assert( constructorIt->second.successCodes[0] == \"VK_SUCCESS\" );\n  switch ( constructorIt->second.successCodes.size() )\n  {\n    case 1:\n      if ( !constructorIt->second.errorCodes.empty() )\n      {\n        std::vector<size_t> returnParams = determineReturnParams( constructorIt->second.params );\n        if ( returnParams.size() == 1 )\n        {\n          assert( isHandleType( constructorIt->second.params[returnParams[0]].type.type ) );\n          std::map<size_t, VectorParamData> vectorParams = determineVectorParams( constructorIt->second.params );\n          switch ( vectorParams.size() )\n          {\n            case 0: return std::make_pair( generateRAIIHandleConstructorByCall( handle, constructorIt, enter, leave, false, false ), \"\" );\n            case 1:\n              if ( returnParams[0] == vectorParams.begin()->first )\n              {\n                if ( isLenByStructMember( constructorIt->second.params[vectorParams.begin()->first].lenExpression,\n                                          constructorIt->second.params[vectorParams.begin()->second.lenParam] ) )\n                {\n                  return std::make_pair( \"\", generateRAIIHandleConstructorByCall( handle, constructorIt, enter, leave, true, false ) );\n                }\n              }\n              break;\n            case 2: return generateRAIIHandleConstructor1Return2Vector( handle, constructorIt, enter, leave, returnParams[0], vectorParams );\n            default: break;\n          }\n        }\n      }\n      break;\n    case 2:\n    case 3:\n      if ( !constructorIt->second.errorCodes.empty() )\n      {\n        std::vector<size_t> returnParams = determineReturnParams( constructorIt->second.params );\n        switch ( returnParams.size() )\n        {\n          case 1:\n            {\n              std::map<size_t, VectorParamData> vectorParams = determineVectorParams( constructorIt->second.params );\n              if ( isHandleType( constructorIt->second.params[returnParams[0]].type.type ) )\n              {\n                if ( vectorParams.size() == 2 )\n                {\n                  return generateRAIIHandleConstructor1Return2Vector( handle, constructorIt, enter, leave, returnParams[0], vectorParams );\n                }\n              }\n              else if ( ( vectorParams.size() == 1 ) && ( vectorParams.begin()->first == returnParams[0] ) && vectorParams.begin()->second.byStructure )\n              {\n                assert( isHandleTypeByStructure( constructorIt->second.params[returnParams[0]].type.type ) );\n                return std::make_pair( \"\", generateRAIIHandleConstructorByCall( handle, constructorIt, enter, leave, true, false ) );\n              }\n            }\n            break;\n          case 2:\n            if ( ( constructorIt->second.params[returnParams[0]].type.type == \"size_t\" ) ||\n                 ( constructorIt->second.params[returnParams[0]].type.type == \"uint32_t\" ) )\n            {\n              assert( isHandleType( constructorIt->second.params[returnParams[1]].type.type ) );\n              std::map<size_t, VectorParamData> vectorParams = determineVectorParams( constructorIt->second.params );\n              if ( vectorParams.size() == 1 )\n              {\n                if ( returnParams[0] == vectorParams.begin()->second.lenParam )\n                {\n                  assert( returnParams[1] == vectorParams.begin()->first );\n                  assert( constructorIt->second.successCodes[1] == \"VK_INCOMPLETE\" );\n                  return std::make_pair( \"\", generateRAIIHandleConstructorByCall( handle, constructorIt, enter, leave, true, false ) );\n                }\n              }\n            }\n            break;\n          default: break;\n        }\n      }\n      break;\n    case 4:\n      if ( !constructorIt->second.errorCodes.empty() )\n      {\n        std::vector<size_t> returnParams = determineReturnParams( constructorIt->second.params );\n        if ( returnParams.size() == 1 )\n        {\n          assert( isHandleType( constructorIt->second.params[returnParams[0]].type.type ) );\n          std::map<size_t, VectorParamData> vectorParams = determineVectorParams( constructorIt->second.params );\n          if ( vectorParams.size() == 2 )\n          {\n            return generateRAIIHandleConstructor1Return2Vector( handle, constructorIt, enter, leave, returnParams[0], vectorParams );\n          }\n        }\n      }\n      break;\n    default: break;\n  }\n  return std::make_pair( \"\", \"\" );\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleConstructorByCall( std::pair<std::string, HandleData> const &         handle,\n                                                                     std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                                     std::string const &                                enter,\n                                                                     std::string const &                                leave,\n                                                                     bool                                               isPlural,\n                                                                     bool                                               forceSingular ) const\n{\n  const auto [parentType, parentName] = getParentTypeAndName( handle );\n\n  size_t skipCount = 0;\n  if ( constructorIt->second.handle == constructorIt->second.params[skipCount].type.type )\n  {\n    ++skipCount;\n  }\n  if ( handle.second.parent == constructorIt->second.params[skipCount].type.type )\n  {\n    ++skipCount;\n  }\n  std::string constructorArguments = generateRAIIHandleConstructorArguments( handle, constructorIt, forceSingular, false );\n  std::string createCall           = generateCommandName(\n    constructorIt->first, constructorIt->second.params, skipCount, forceSingular ? CommandFlavourFlagBits::singular : CommandFlavourFlagBits() );\n\n  std::string createArguments;\n  for ( size_t i = skipCount; i < constructorIt->second.params.size() - 1; ++i )\n  {\n    if ( constructorIt->second.params[i].type.isValue() || specialPointerTypes.contains( constructorIt->second.params[i].type.type ) )\n    {\n      createArguments += constructorIt->second.params[i].name + \", \";\n    }\n    else if ( constructorIt->second.params[i].type.isConstPointer() )\n    {\n      assert( constructorIt->second.params[i].lenParams.empty() || isPlural );\n      if ( !constructorIt->second.params[i].lenParams.empty() )\n      {\n        assert( constructorIt->second.params[i].lenParams.size() == 1 );\n        const std::string::size_type start = createArguments.find( constructorIt->second.params[i].lenParams[0].first );\n        assert( start != std::string::npos );\n        // remove the size/count argument, and its trailing \", \"\n        createArguments.replace( start, constructorIt->second.params[i].lenParams[0].first.length() + 2, \"\" );\n      }\n      std::string argument = startLowerCase( stripPrefix( constructorIt->second.params[i].name, \"p\" ) );\n      if ( isPlural && forceSingular )\n      {\n        argument = stripPluralS( argument );\n      }\n      createArguments += argument + \", \";\n    }\n    else\n    {\n      // this is the count argument (by pointer) for an enumeration function -> skip it\n    }\n  }\n  if ( !createArguments.empty() )\n  {\n    createArguments = stripPostfix( createArguments, \", \" );\n  }\n  assert( ( constructorIt->second.params.back().type.type == handle.first ) ||\n          ( vectorMemberByStructure( constructorIt->second.params.back().type.type ).type.type == handle.first ) );\n\n  const std::string constructorTemplate =\n    R\"(\n#if !defined( VULKAN_HPP_RAII_NO_EXCEPTIONS )\n${enter}    ${handleType}${plural}( ${constructorArguments} )\n    {\n      *this = ${parentName}.${createCall}( ${createArguments} );\n    }\n${leave}#endif\n)\";\n\n  return replaceWithMap( constructorTemplate,\n                         { { \"constructorArguments\", constructorArguments },\n                           { \"createArguments\", createArguments },\n                           { \"createCall\", createCall },\n                           { \"enter\", enter },\n                           { \"leave\", leave },\n                           { \"handleType\", stripPrefix( handle.first, \"Vk\" ) },\n                           { \"plural\", isPlural && !forceSingular ? \"s\" : \"\" },\n                           { \"parentName\", parentName } } );\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleConstructorTakeOwnership( std::pair<std::string, HandleData> const & handle ) const\n{\n  std::string handleType = stripPrefix( handle.first, \"Vk\" );\n  std::string handleName = startLowerCase( handleType );\n\n  const auto [parentType, parentName] = getParentTypeAndName( handle );\n\n  std::string constructorArguments = generateRAIIHandleConstructorArguments( handle, handle.second.destructorIt, false, true );\n  std::string initializationList   = generateRAIIHandleConstructorInitializationList( handle, handle.second.destructorIt, handle.second.destructorIt, true );\n  assert( !handle.second.constructorIts.empty() );\n  if ( ( 1 < handle.second.constructorIts[0]->second.successCodes.size() && ( handle.second.constructorIts[0]->second.successCodes[1] != \"VK_INCOMPLETE\" ) ) ||\n       ( 2 < handle.second.constructorIts[0]->second.successCodes.size() ) )\n  {\n#if !defined( NDEBUG )\n    for ( size_t i = 1; i < handle.second.constructorIts.size(); ++i )\n    {\n      assert( 1 < handle.second.constructorIts[i]->second.successCodes.size() );\n    }\n#endif\n    constructorArguments += \", VULKAN_HPP_NAMESPACE::Result successCode = VULKAN_HPP_NAMESPACE::Result::eSuccess\";\n    if ( isMultiSuccessCodeConstructor( handle.second.constructorIts ) )\n    {\n      initializationList += \", m_constructorSuccessCode( successCode )\";\n    }\n  }\n\n  std::string dispatcherInitializer;\n  if ( ( handle.first != \"VkInstance\" ) && ( handle.first != \"VkDevice\" ) )\n  {\n    dispatcherInitializer = \"m_dispatcher( \" + parentName + \".getDispatcher() )\";\n  }\n  if ( !initializationList.empty() && !dispatcherInitializer.empty() )\n  {\n    initializationList += \", \";\n  }\n\n  std::string dispatcherInit;\n  if ( ( handle.first == \"VkDevice\" ) || ( handle.first == \"VkInstance\" ) )\n  {\n    dispatcherInit = \"\\n        m_dispatcher.reset( new VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::\" + handleType + \"Dispatcher( \" + parentName +\n                     \".getDispatcher()->vkGet\" + handleType + \"ProcAddr, static_cast<\" + handle.first + \">( m_\" + startLowerCase( handleType ) + \" ) ) );\";\n  }\n\n  const std::string constructorTemplate =\n    R\"(\n    ${handleType}( ${constructorArguments} )\n      : ${initializationList}${dispatcherInitializer}\n    {${dispatcherInit}}\n)\";\n\n  return replaceWithMap( constructorTemplate,\n                         { { \"constructorArguments\", constructorArguments },\n                           { \"dispatcherInitializer\", dispatcherInitializer },\n                           { \"dispatcherInit\", dispatcherInit },\n                           { \"handleType\", handleType },\n                           { \"initializationList\", initializationList } } );\n}\n\nstd::pair<std::string, std::string> VulkanHppGenerator::generateRAIIHandleConstructorVoid( std::pair<std::string, HandleData> const &         handle,\n                                                                                           std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                                                           std::string const &                                enter,\n                                                                                           std::string const &                                leave ) const\n{\n  assert( constructorIt->second.successCodes.empty() && constructorIt->second.errorCodes.empty() );\n  std::vector<size_t> returnParams = determineReturnParams( constructorIt->second.params );\n  if ( returnParams.size() == 1 )\n  {\n    assert( isHandleType( constructorIt->second.params[returnParams[0]].type.type ) );\n    std::map<size_t, VectorParamData> vectorParams = determineVectorParams( constructorIt->second.params );\n    if ( vectorParams.empty() )\n    {\n      return std::make_pair( generateRAIIHandleConstructorByCall( handle, constructorIt, enter, leave, false, false ), \"\" );\n    }\n  }\n  return std::make_pair( \"\", \"\" );\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleContext( std::pair<std::string, HandleData> const & handle,\n                                                           std::set<std::string> const &              specialFunctions ) const\n{\n  const std::string contextTemplate = R\"(\n    class Context\n    {\n    public:\n#if VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL\n      Context()\n        : m_dispatcher( new VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::ContextDispatcher(\n            m_dynamicLoader.getProcAddress<PFN_vkGetInstanceProcAddr>( \"vkGetInstanceProcAddr\" ) ) )\n#else\n      Context( PFN_vkGetInstanceProcAddr getInstanceProcAddr )\n        : m_dispatcher( new VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::ContextDispatcher( getInstanceProcAddr ) )\n#endif\n      {}\n\n      ~Context() = default;\n\n      Context( Context const & ) = delete;\n      Context( Context && rhs ) VULKAN_HPP_NOEXCEPT\n#if VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL\n        : m_dynamicLoader( std::move( rhs.m_dynamicLoader ) )\n        , m_dispatcher( rhs.m_dispatcher.release() )\n#else\n        : m_dispatcher( rhs.m_dispatcher.release() )\n#endif\n      {}\n      Context & operator=( Context const & ) = delete;\n      Context & operator=( Context && rhs ) VULKAN_HPP_NOEXCEPT\n      {\n        if ( this != &rhs )\n        {\n#if VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL\n          m_dynamicLoader = std::move( rhs.m_dynamicLoader );\n#endif\n          m_dispatcher.reset( rhs.m_dispatcher.release() );\n        }\n        return *this;\n      }\n\n      VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::ContextDispatcher const * getDispatcher() const\n      {\n        VULKAN_HPP_ASSERT( m_dispatcher->getVkHeaderVersion() == VK_HEADER_VERSION );\n        return &*m_dispatcher;\n      }\n\n      void swap( VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::Context & rhs )\n      {\n#if VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL\n        std::swap( m_dynamicLoader, rhs.m_dynamicLoader );\n#endif\n        m_dispatcher.swap( rhs.m_dispatcher );\n      }\n\n${memberFunctionDeclarations}\n\n    private:\n#if VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL\n      VULKAN_HPP_NAMESPACE::detail::DynamicLoader m_dynamicLoader;\n#endif\n      std::unique_ptr<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::ContextDispatcher> m_dispatcher;\n    };\n\n)\";\n\n  return replaceWithMap( contextTemplate, { { \"memberFunctionDeclarations\", generateRAIIHandleCommandDeclarations( handle, specialFunctions ) } } );\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleDestructorCallArguments( std::string const &                                handleType,\n                                                                           std::map<std::string, CommandData>::const_iterator destructorIt ) const\n{\n  std::vector<std::string> arguments;\n  for ( auto param : destructorIt->second.params )\n  {\n    if ( param.type.type == handleType )\n    {\n      std::string handleName = param.name;\n      if ( param.type.isValue() )\n      {\n        arguments.push_back( \"static_cast<\" + handleType + \">( m_\" + handleName + \" )\" );\n      }\n      else\n      {\n        arguments.push_back( \"reinterpret_cast<\" + handleType + \" const *>( &m_\" + stripPluralS( startLowerCase( stripPrefix( handleName, \"p\" ) ) ) + \" )\" );\n      }\n    }\n    else if ( param.type.type == \"VkAllocationCallbacks\" )\n    {\n      // vk::AllocationCallbacks is stored as a member of the handle class\n      arguments.push_back( \"reinterpret_cast<const VkAllocationCallbacks *>( m_allocator )\" );\n    }\n    else if ( isHandleType( param.type.type ) )\n    {\n      assert( param.arraySizes.empty() );\n      std::string argument = \"m_\" + param.name;\n      if ( param.type.isValue() )\n      {\n        arguments.push_back( \"static_cast<\" + param.type.type + \">( \" + argument + \" )\" );\n      }\n      else\n      {\n        assert( param.type.isConstPointer() );\n        assert( !param.lenExpression.empty() && std::any_of( destructorIt->second.params.begin(),\n                                                             destructorIt->second.params.end(),\n                                                             [&param]( ParamData const & pd ) { return pd.name == param.lenExpression; } ) );\n        arguments.push_back( \"reinterpret_cast<\" + param.type.type + \" const *>( &\" + argument + \" )\" );\n      }\n    }\n    else\n    {\n      assert( ( param.type.type == \"uint32_t\" ) && param.type.isValue() && param.arraySizes.empty() && param.lenExpression.empty() && !param.optional );\n      assert( std::any_of(\n        destructorIt->second.params.begin(), destructorIt->second.params.end(), [&param]( ParamData const & pd ) { return pd.lenExpression == param.name; } ) );\n      arguments.push_back( \"1\" );\n    }\n  }\n  return generateList( arguments, \"\", \", \" );\n}\n\nstd::tuple<std::string, std::string, std::string, std::string, std::string, std::string, std::string>\n  VulkanHppGenerator::generateRAIIHandleDetails( std::pair<std::string, HandleData> const & handle ) const\n{\n  std::string getConstructorSuccessCode;\n  const bool  multiSuccessCodeContructor = isMultiSuccessCodeConstructor( handle.second.constructorIts );\n  if ( multiSuccessCodeContructor )\n  {\n    getConstructorSuccessCode = R\"(\n    VULKAN_HPP_NAMESPACE::Result getConstructorSuccessCode() const\n    {\n      return m_constructorSuccessCode;\n    }\n)\";\n  }\n\n  const auto [parentType, parentName] = getParentTypeAndName( handle );\n\n  std::string handleName = generateRAIIHandleConstructorParamName( handle.first, handle.second.destructorIt );\n\n  std::string clearMembers, moveConstructorInitializerList, moveAssignmentInstructions, memberVariables, swapMembers, releaseMembers;\n\n  if ( handle.second.destructorIt != m_commands.end() )\n  {\n    clearMembers = \"        if ( m_\" + handleName + \" )\\n\";\n    clearMembers += \"        {\\n\";\n    clearMembers += \"          getDispatcher()->\" + handle.second.destructorIt->first + \"( \" +\n                    generateRAIIHandleDestructorCallArguments( handle.first, handle.second.destructorIt ) + \" );\\n\";\n    clearMembers += \"        }\";\n    for ( auto const & destructorParam : handle.second.destructorIt->second.params )\n    {\n      std::string memberName, memberType;\n      if ( destructorParam.type.type == \"Vk\" + parentType )\n      {\n        memberName = parentName;\n        memberType = \"VULKAN_HPP_NAMESPACE::\" + parentType;\n      }\n      else if ( destructorParam.type.type == handle.first )\n      {\n        memberName = handleName;\n        memberType = generateNamespacedType( handle.first );\n      }\n      else if ( std::none_of( handle.second.destructorIt->second.params.begin(),\n                              handle.second.destructorIt->second.params.end(),\n                              [&destructorParam]( ParamData const & pd ) { return pd.lenExpression == destructorParam.name; } ) )\n      {\n        std::string name = destructorParam.name;\n        if ( !destructorParam.type.isValue() )\n        {\n          name = startLowerCase( stripPrefix( name, \"p\" ) );\n        }\n        memberName = name;\n        memberType = destructorParam.type.compose( \"VULKAN_HPP_NAMESPACE\" );\n      }\n      if ( !memberName.empty() )\n      {\n        clearMembers += \"\\n      m_\" + memberName + \" = nullptr;\";\n        moveConstructorInitializerList += \"m_\" + memberName + \"( VULKAN_HPP_NAMESPACE::exchange( rhs.m_\" + memberName + \", {} ) ), \";\n        moveAssignmentInstructions += \"\\n          std::swap( m_\" + memberName + \", rhs.m_\" + memberName + \" );\";\n        memberVariables += \"\\n    \" + memberType + \" m_\" + memberName + \" = {};\";\n        swapMembers += \"\\n      std::swap( m_\" + memberName + \", rhs.m_\" + memberName + \" );\";\n        if ( destructorParam.type.type != handle.first )\n        {\n          releaseMembers += \"\\n      m_\" + memberName + \" = nullptr;\";\n        }\n      }\n    }\n  }\n  else\n  {\n    if ( !handle.second.secondLevelCommands.empty() )\n    {\n      assert( !handle.second.constructorIts.empty() );\n      assert( !handle.second.constructorIts.front()->second.params.empty() );\n      auto const & frontType = handle.second.constructorIts.front()->second.params.front().type.type;\n      assert( isHandleType( frontType ) );\n#if !defined( NDEBUG )\n      auto handleIt = m_handles.find( \"Vk\" + parentType );\n#endif\n      assert( handleIt != m_handles.end() );\n      assert( handleIt->second.parent == frontType );\n      std::string frontName = handle.second.constructorIts.front()->second.params.front().name;\n\n      clearMembers += \"\\n        m_\" + frontName + \" = nullptr;\";\n      moveConstructorInitializerList = \"m_\" + frontName + \"( VULKAN_HPP_NAMESPACE::exchange( rhs.m_\" + frontName + \", {} ) ), \";\n      moveAssignmentInstructions     = \"\\n          std::swap( m_\" + frontName + \", rhs.m_\" + frontName + \" );\";\n      memberVariables                = \"\\n    VULKAN_HPP_NAMESPACE::\" + stripPrefix( frontType, \"Vk\" ) + \" m_\" + frontName + \" = {};\";\n      swapMembers                    = \"\\n      std::swap( m_\" + frontName + \", rhs.m_\" + frontName + \" );\";\n      releaseMembers += \"\\n        m_\" + frontName + \" = nullptr;\";\n    }\n    clearMembers += \"\\n        m_\" + handleName + \" = nullptr;\";\n    moveConstructorInitializerList += \"m_\" + handleName + \"( VULKAN_HPP_NAMESPACE::exchange( rhs.m_\" + handleName + \", {} ) ), \";\n    moveAssignmentInstructions += \"\\n          std::swap( m_\" + handleName + \", rhs.m_\" + handleName + \" );\";\n    memberVariables += \"\\n    \" + generateNamespacedType( handle.first ) + \" m_\" + handleName + \" = {};\";\n    swapMembers += \"\\n      std::swap( m_\" + handleName + \", rhs.m_\" + handleName + \" );\";\n  }\n\n  if ( multiSuccessCodeContructor )\n  {\n    clearMembers += \"\\n        m_constructorSuccessCode = VULKAN_HPP_NAMESPACE::Result::eErrorUnknown;\";\n    memberVariables += \"\\n    VULKAN_HPP_NAMESPACE::Result m_constructorSuccessCode = VULKAN_HPP_NAMESPACE::Result::eErrorUnknown;\";\n    swapMembers += \"\\n      std::swap( m_constructorSuccessCode, rhs.m_constructorSuccessCode );\";\n    moveConstructorInitializerList += \"m_constructorSuccessCode( VULKAN_HPP_NAMESPACE::exchange( rhs.m_constructorSuccessCode, {} ) ), \";\n    moveAssignmentInstructions += \"\\n          std::swap( m_constructorSuccessCode, rhs.m_constructorSuccessCode );\";\n    releaseMembers += \"\\n        m_constructorSuccessCode = VULKAN_HPP_NAMESPACE::Result::eErrorUnknown;\";\n  }\n\n  if ( handle.first == \"VkInstance\" )\n  {\n    memberVariables += \"\\n      std::unique_ptr<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::InstanceDispatcher> m_dispatcher;\";\n  }\n  else if ( handle.first == \"VkDevice\" )\n  {\n    memberVariables += \"\\n      std::unique_ptr<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::DeviceDispatcher> m_dispatcher;\";\n  }\n  else if ( handle.second.constructorIts.front()->second.params.front().type.type == \"VkDevice\" )\n  {\n    memberVariables += \"\\n      VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::DeviceDispatcher const * m_dispatcher = nullptr;\";\n  }\n  else\n  {\n    memberVariables += \"\\n      VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::detail::InstanceDispatcher const * m_dispatcher = nullptr;\";\n  }\n  clearMembers += \"\\n        m_dispatcher = nullptr;\";\n  swapMembers += \"\\n      std::swap( m_dispatcher, rhs.m_dispatcher );\";\n  releaseMembers += \"\\n        m_dispatcher = nullptr;\";\n  releaseMembers += \"\\n        return VULKAN_HPP_NAMESPACE::exchange( m_\" + handleName + \", nullptr );\";\n\n  if ( ( handle.first == \"VkInstance\" ) || ( handle.first == \"VkDevice\" ) )\n  {\n    moveConstructorInitializerList += \"m_dispatcher( rhs.m_dispatcher.release() )\";\n  }\n  else\n  {\n    moveConstructorInitializerList += \"m_dispatcher( VULKAN_HPP_NAMESPACE::exchange( rhs.m_dispatcher, nullptr ) )\";\n  }\n  moveAssignmentInstructions += \"\\n        std::swap( m_dispatcher, rhs.m_dispatcher );\";\n\n  return std::make_tuple(\n    clearMembers, getConstructorSuccessCode, memberVariables, moveConstructorInitializerList, moveAssignmentInstructions, swapMembers, releaseMembers );\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleForwardDeclarations( std::vector<RequireData> const & requireData, std::string const & title ) const\n{\n  std::string str;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & type : require.types )\n    {\n      auto handleIt = m_handles.find( type.name );\n      if ( handleIt != m_handles.end() )\n      {\n        str += \"  class \" + stripPrefix( handleIt->first, \"Vk\" ) + \";\\n\";\n      }\n    }\n  }\n  return addTitleAndProtection( title, str );\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandles() const\n{\n  const std::string raiiHandlesTemplate = R\"(\n  //========================================\n  //=== RAII HANDLE forward declarations ===\n  //========================================\n\n${forwardDeclarations}\n\n  //====================\n  //=== RAII HANDLES ===\n  //====================\n\n  template <typename Type>\n  struct isVulkanRAIIHandleType\n  {\n    static VULKAN_HPP_CONST_OR_CONSTEXPR bool value = false;\n  };\n\n${raiiHandles}\n\n  // operators to compare vk::raii-handles\n#if defined(VULKAN_HPP_HAS_SPACESHIP_OPERATOR)\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::isVulkanRAIIHandleType<T>::value,bool>::type = 0>\n  auto operator<=>( T const & a, T const & b ) VULKAN_HPP_NOEXCEPT\n  {\n    return *a <=> *b;\n  }\n#else\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::isVulkanRAIIHandleType<T>::value,bool>::type = 0>\n  bool operator==( T const & a, T const & b ) VULKAN_HPP_NOEXCEPT\n  {\n    return *a == *b;\n  }\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::isVulkanRAIIHandleType<T>::value,bool>::type = 0>\n  bool operator!=(T const & a, T const & b ) VULKAN_HPP_NOEXCEPT\n  {\n    return *a != *b;\n  }\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::isVulkanRAIIHandleType<T>::value,bool>::type = 0>\n  bool operator<(T const & a, T const & b ) VULKAN_HPP_NOEXCEPT\n  {\n    return *a < *b;\n  }\n#endif\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::isVulkanRAIIHandleType<T>::value,bool>::type = 0>\n  bool operator==( const T & v, std::nullptr_t ) VULKAN_HPP_NOEXCEPT\n  {\n    return !*v;\n  }\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::isVulkanRAIIHandleType<T>::value,bool>::type = 0>\n  bool operator==( std::nullptr_t, const T & v ) VULKAN_HPP_NOEXCEPT\n  {\n    return !*v;\n  }\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::isVulkanRAIIHandleType<T>::value,bool>::type = 0>\n  bool operator!=( const T & v, std::nullptr_t ) VULKAN_HPP_NOEXCEPT\n  {\n    return *v;\n  }\n\n  template <typename T, typename std::enable_if<VULKAN_HPP_NAMESPACE::VULKAN_HPP_RAII_NAMESPACE::isVulkanRAIIHandleType<T>::value,bool>::type = 0>\n  bool operator!=( std::nullptr_t, const T & v ) VULKAN_HPP_NOEXCEPT\n  {\n    return *v;\n  }\n)\";\n\n  std::string forwardDeclarations;\n  for ( auto const & feature : m_features )\n  {\n    forwardDeclarations += generateRAIIHandleForwardDeclarations( feature.requireData, feature.name );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    forwardDeclarations += generateRAIIHandleForwardDeclarations( extension.requireData, extension.name );\n  }\n\n  std::set<std::string> listedHandles;\n  auto                  handleIt = m_handles.begin();\n  assert( handleIt->first.empty() );\n  std::string raiiHandles = generateRAIIHandleContext( *handleIt, m_RAIISpecialFunctions );\n  for ( ++handleIt; handleIt != m_handles.end(); ++handleIt )\n  {\n    if ( isTypeUsed( handleIt->first ) )\n    {\n      raiiHandles += generateRAIIHandle( *handleIt, listedHandles, m_RAIISpecialFunctions );\n    }\n  }\n  return replaceWithMap( raiiHandlesTemplate, { { \"forwardDeclarations\", forwardDeclarations }, { \"raiiHandles\", raiiHandles } } );\n}\n\nstd::string VulkanHppGenerator::generateRAIIHandleSingularConstructorArguments( std::pair<std::string, HandleData> const & handle,\n                                                                                std::vector<ParamData> const &             params,\n                                                                                std::string const &                        argumentType,\n                                                                                std::string const &                        argumentName ) const\n{\n  std::string arguments = \"*reinterpret_cast<\" + argumentType + \" *>( &\" + argumentName + \" )\";\n  if ( handle.second.destructorIt != m_commands.end() )\n  {\n    auto [parentType, parentName] = getParentTypeAndName( handle );\n    parentType                    = \"Vk\" + parentType;\n    for ( auto const & destructorParam : handle.second.destructorIt->second.params )\n    {\n      if ( ( destructorParam.type.type != parentType ) && ( destructorParam.type.type != handle.first ) &&\n           std::none_of( handle.second.destructorIt->second.params.begin(),\n                         handle.second.destructorIt->second.params.end(),\n                         [&destructorParam]( ParamData const & pd ) { return pd.lenExpression == destructorParam.name; } ) )\n      {\n        if ( std::any_of( params.begin(), params.end(), [&destructorParam]( ParamData const & pd ) { return pd.type.type == destructorParam.type.type; } ) )\n        {\n          if ( isHandleType( destructorParam.type.type ) )\n          {\n            assert( destructorParam.type.isValue() );\n            arguments += \", static_cast<\" + destructorParam.type.type + \">( *\" + destructorParam.name + \" )\";\n          }\n          else\n          {\n            assert( destructorParam.type.type == \"VkAllocationCallbacks\" );\n            arguments += \", allocator\";\n          }\n        }\n        else\n        {\n#if !defined( NDEBUG )\n          bool found = false;\n#endif\n          for ( auto const & param : params )\n          {\n            auto structureIt = m_structs.find( param.type.type );\n            if ( structureIt != m_structs.end() )\n            {\n              auto memberIt = findStructMemberItByType( destructorParam.type.type, structureIt->second.members );\n              if ( memberIt != structureIt->second.members.end() )\n              {\n#if !defined( NDEBUG )\n                found = true;\n#endif\n                assert( !param.type.isValue() );\n                std::string argument = startLowerCase( stripPrefix( param.name, \"p\" ) ) + \".\" + memberIt->name;\n                if ( isHandleType( memberIt->type.type ) )\n                {\n                  argument = \"static_cast<\" + memberIt->type.type + \">( \" + argument + \" )\";\n                }\n                arguments += \", \" + argument;\n                break;\n              }\n            }\n          }\n          assert( found );\n        }\n      }\n    }\n  }\n  return arguments;\n}\n\ntemplate <class Predicate, class Extraction>\nstd::string VulkanHppGenerator::generateReplacedExtensionsList( Predicate p, Extraction e ) const\n{\n  std::string extensionsList, previousEnter, previousLeave;\n  for ( auto const & extension : m_extensions )\n  {\n    if ( p( extension ) )\n    {\n      const auto [enter, leave] = generateProtection( getProtectFromTitle( extension.name ) );\n      extensionsList +=\n        ( ( previousEnter != enter ) ? ( \"\\n\" + previousLeave + enter ) : \"\\n\" ) + \"{ \\\"\" + extension.name + \"\\\", \\\"\" + e( extension ) + \"\\\"}, \";\n      previousEnter = enter;\n      previousLeave = leave;\n    }\n  }\n  if ( !extensionsList.empty() )\n  {\n    assert( extensionsList.ends_with( \", \" ) );\n    extensionsList = extensionsList.substr( 0, extensionsList.length() - 2 );\n    if ( !previousLeave.empty() )\n    {\n      extensionsList += \"\\n\" + previousLeave;\n    }\n  }\n  return extensionsList;\n}\n\nstd::string VulkanHppGenerator::generateResultAssignment( CommandData const & commandData ) const\n{\n  std::string resultAssignment;\n  if ( ( commandData.returnType != \"void\" ) &&\n       !( ( commandData.returnType == \"VkResult\" ) && ( commandData.successCodes.size() == 1 ) && commandData.errorCodes.empty() ) )\n  {\n    resultAssignment = commandData.returnType + \" result = \";\n  }\n  return resultAssignment;\n}\n\nstd::string VulkanHppGenerator::generateResultCheck(\n  CommandData const & commandData, std::string const & className, std::string const & classSeparator, std::string commandName, bool enumerating ) const\n{\n  std::string resultCheck;\n  if ( !commandData.errorCodes.empty() )\n  {\n    std::string successCodeList = generateSuccessCodeList( commandData.successCodes, enumerating );\n\n    std::string const resultCheckTemplate =\n      R\"(VULKAN_HPP_NAMESPACE::detail::resultCheck( result, VULKAN_HPP_NAMESPACE_STRING \"::${className}${classSeparator}${commandName}\"${successCodeList} );)\";\n\n    resultCheck = replaceWithMap(\n      resultCheckTemplate,\n      { { \"className\", className }, { \"classSeparator\", classSeparator }, { \"commandName\", commandName }, { \"successCodeList\", successCodeList } } );\n  }\n  return resultCheck;\n}\n\nstd::string VulkanHppGenerator::generateResultCheckExpected( std::vector<std::string> const & successCodes,\n                                                             std::string const &              className,\n                                                             std::string const &              commandName ) const\n{\n  std::string resultCheck;\n  if ( !successCodes.empty() )\n  {\n    std::string condition = \"result != \" + generateSuccessCode( successCodes[0] );\n    if ( 1 < successCodes.size() )\n    {\n      condition = \"( \" + condition + \" )\";\n      for ( size_t i = 1; i < successCodes.size(); ++i )\n      {\n        condition += \" && ( result != \" + generateSuccessCode( successCodes[i] ) + \" )\";\n      }\n    }\n\n    std::string const resultCheckTemplate = R\"(if ( ${condition} )\n{\n#if defined( VULKAN_HPP_RAII_NO_EXCEPTIONS )\n  return VULKAN_HPP_UNEXPECTED( result );\n#else\n  VULKAN_HPP_NAMESPACE::detail::throwResultException( result, \"${className}::${commandName}\" );\n#endif\n}\n)\";\n\n    resultCheck = replaceWithMap( resultCheckTemplate, { { \"className\", className }, { \"commandName\", commandName }, { \"condition\", condition } } );\n  }\n  return resultCheck;\n}\n\n// Intended only for `enum class Result`!\nstd::string VulkanHppGenerator::generateResultExceptions() const\n{\n  const std::string templateString = R\"(\n${enter}  class ${className} : public SystemError\n  {\n  public:\n    ${className}( std::string const & message )\n      : SystemError( make_error_code( ${enumName}::${enumMemberName} ), message ) {}\n    ${className}( char const * message )\n      : SystemError( make_error_code( ${enumName}::${enumMemberName} ), message ) {}\n  };\n${leave})\";\n\n  std::string str;\n  auto        enumIt = m_enums.find( \"VkResult\" );\n  for ( auto const & value : enumIt->second.values )\n  {\n    if ( value.supported && value.name.starts_with( \"VK_ERROR\" ) )\n    {\n      auto [enter, leave]   = generateProtection( value.protect );\n      std::string valueName = generateEnumValueName( enumIt->first, value.name, false );\n      str += replaceWithMap( templateString,\n                             { { \"className\", stripPrefix( valueName, \"eError\" ) + \"Error\" },\n                               { \"enter\", enter },\n                               { \"enumName\", stripPrefix( enumIt->first, \"Vk\" ) },\n                               { \"enumMemberName\", valueName },\n                               { \"leave\", leave } } );\n    }\n  }\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateReturnStatement( std::string const & commandName,\n                                                         CommandData const & commandData,\n                                                         std::string const & returnVariable,\n                                                         std::string const & returnType,\n                                                         std::string const & decoratedReturnType,\n                                                         std::string const & dataType,\n                                                         size_t              initialSkipCount,\n                                                         size_t              returnParam,\n                                                         CommandFlavourFlags flavourFlags,\n                                                         bool                enumerating,\n                                                         bool                raii ) const\n{\n  const bool unique = flavourFlags & CommandFlavourFlagBits::unique;\n\n  std::string returnStatement;\n  if ( commandData.returnType.starts_with( \"Vk\" ) )\n  {\n    if ( ( commandData.successCodes.size() == 1 ) || ( enumerating && ( commandData.successCodes.size() == 2 ) ) )\n    {\n      assert( commandData.successCodes[0] == \"VK_SUCCESS\" );\n      if ( raii || commandData.errorCodes.empty() )\n      {\n        if ( !returnVariable.empty() )\n        {\n          returnStatement = \"return \" + returnVariable + \";\";\n        }\n      }\n      else\n      {\n        if ( returnVariable.empty() )\n        {\n          assert( !unique );\n          returnStatement = \"return VULKAN_HPP_NAMESPACE::detail::createResultValueType( result );\";\n        }\n        else if ( unique )\n        {\n          assert( returnParam != INVALID_INDEX );\n          returnStatement = \"return VULKAN_HPP_NAMESPACE::detail::createResultValueType( result, \";\n          if ( dataType.starts_with( \"std::\" ) )\n          {\n            returnStatement += \"std::move( unique\" + startUpperCase( returnVariable ) + \" )\";\n          }\n          else\n          {\n            assert( dataType.starts_with( \"VULKAN_HPP_NAMESPACE::\" ) );\n            returnStatement +=\n              returnType + \"( \" + returnVariable + \", \" + generateObjectDeleter( commandName, commandData, initialSkipCount, returnParam ) + \" )\";\n          }\n          returnStatement += \" );\";\n        }\n        else\n        {\n          returnStatement = \"return VULKAN_HPP_NAMESPACE::detail::createResultValueType( result, std::move( \" + returnVariable + \" ) );\";\n        }\n      }\n    }\n    else\n    {\n      if ( returnVariable.empty() )\n      {\n        assert( !unique );\n        returnStatement = \"return static_cast<VULKAN_HPP_NAMESPACE::\" + stripPrefix( commandData.returnType, \"Vk\" ) + \">( result );\";\n      }\n      else if ( unique )\n      {\n        assert( returnParam != INVALID_INDEX );\n        assert( decoratedReturnType.starts_with( \"ResultValue<\" ) && decoratedReturnType.ends_with( \">\" ) );\n        returnStatement = \"return \" + decoratedReturnType + \"( result, \";\n        if ( dataType.starts_with( \"std::\" ) )\n        {\n          returnStatement += \"std::move( unique\" + startUpperCase( returnVariable ) + \" )\";\n        }\n        else\n        {\n          returnStatement += \"UniqueHandle<\" + dataType + \", Dispatch>( \" + returnVariable + \", \" +\n                             generateObjectDeleter( commandName, commandData, initialSkipCount, returnParam ) + \" )\";\n        }\n        returnStatement += \" );\";\n      }\n      else\n      {\n        assert( decoratedReturnType.starts_with( raii ? \"std::pair<VULKAN_HPP_NAMESPACE::Result, \" : \"ResultValue<\" ) && decoratedReturnType.ends_with( \">\" ) );\n        returnStatement = \"return \" + ( raii ? \"std::make_pair\" : decoratedReturnType ) + \"( result, std::move( \" + returnVariable + \" ) );\";\n      }\n    }\n  }\n  else\n  {\n    assert( !unique );\n    if ( returnVariable.empty() )\n    {\n      if ( commandData.returnType != \"void\" )\n      {\n        returnStatement = \"return result;\";\n      }\n    }\n    else\n    {\n      returnStatement = \"return \" + returnVariable + \";\";\n    }\n  }\n  return returnStatement;\n}\n\nstd::string VulkanHppGenerator::generateReturnType( std::vector<size_t> const &               returnParams,\n                                                    std::map<size_t, VectorParamData> const & vectorParams,\n                                                    CommandFlavourFlags                       flavourFlags,\n                                                    bool                                      raii,\n                                                    std::vector<std::string> const &          dataTypes ) const\n{\n  assert( returnParams.size() == dataTypes.size() );\n  const bool chained  = flavourFlags & CommandFlavourFlagBits::chained;\n  const bool singular = flavourFlags & CommandFlavourFlagBits::singular;\n  const bool unique   = flavourFlags & CommandFlavourFlagBits::unique;\n  assert( !( chained && unique ) );\n\n  std::string returnType;\n  switch ( returnParams.size() )\n  {\n    case 0: returnType = \"void\"; break;\n    case 1:\n      if ( chained )\n      {\n        assert( vectorParams.empty() );\n        returnType = \"VULKAN_HPP_NAMESPACE::StructureChain<X, Y, Z...>\";\n      }\n      else if ( unique )\n      {\n        if ( vectorParams.contains( returnParams[0] ) && !singular )\n        {\n          returnType = \"std::vector<UniqueHandle<\" + dataTypes[0] + \", Dispatch>, \" + stripPrefix( dataTypes[0], \"VULKAN_HPP_NAMESPACE::\" ) + \"Allocator>\";\n        }\n        else\n        {\n          returnType = \"UniqueHandle<\" + dataTypes[0] + \", Dispatch>\";\n        }\n      }\n      else\n      {\n        if ( vectorParams.contains( returnParams[0] ) && !singular )\n        {\n          returnType = \"std::vector<\" + dataTypes[0] + ( raii ? \"\" : ( \", \" + stripPrefix( dataTypes[0], \"VULKAN_HPP_NAMESPACE::\" ) + \"Allocator\" ) ) + \">\";\n        }\n        else if ( dataTypes[0].starts_with( \"Vk\" ) )\n        {\n          returnType = \"VULKAN_HPP_NAMESPACE::\" + stripPrefix( dataTypes[0], \"Vk\" );\n        }\n        else\n        {\n          returnType = dataTypes[0];\n        }\n      }\n      break;\n    case 2:\n      assert( !unique );\n      if ( chained )\n      {\n#if !defined( NDEBUG )\n        auto vectorIt = vectorParams.find( returnParams[1] );\n#endif\n        assert( ( vectorIt != vectorParams.end() ) && ( vectorIt->second.lenParam == returnParams[0] ) );\n        returnType = std::string( \"std::vector<StructureChain\" ) + ( raii ? \"\" : \", StructureChainAllocator\" ) + \">\";\n      }\n      else\n      {\n        if ( vectorParams.contains( returnParams[0] ) )\n        {\n          if ( singular )\n          {\n            returnType = \"std::pair<\" + dataTypes[0] + \", \" + dataTypes[1] + \">\";\n          }\n          else\n          {\n            returnType =\n              \"std::pair<std::vector<\" + dataTypes[0] + ( raii ? \"\" : ( \", \" + startUpperCase( dataTypes[0] ) + \"Allocator\" ) ) + \">, \" + dataTypes[1] + \">\";\n          }\n        }\n        else if ( vectorParams.contains( returnParams[1] ) )\n        {\n          assert( vectorParams.find( returnParams[1] )->second.lenParam == returnParams[0] );\n          if ( dataTypes[1].starts_with( \"Vk\" ) )\n          {\n            std::string type = stripPrefix( dataTypes[1], \"Vk\" );\n            returnType       = \"std::vector<VULKAN_HPP_NAMESPACE::\" + type + ( raii ? \"\" : ( \", \" + type + \"Allocator\" ) ) + \">\";\n          }\n          else\n          {\n            returnType = \"std::vector<\" + dataTypes[1] +\n                         ( raii ? \"\" : ( \", \" + startUpperCase( stripPrefix( dataTypes[1], \"VULKAN_HPP_NAMESPACE::\" ) ) + \"Allocator\" ) ) + \">\";\n          }\n        }\n        else\n        {\n          returnType = \"std::pair<\" + dataTypes[0] + \", \" + dataTypes[1] + \">\";\n        }\n      }\n      break;\n    case 3:\n      assert( !unique );\n      if ( chained )\n      {\n        assert( dataTypes[2] == \"uint8_t\" );\n#if !defined( NDEBUG )\n        auto vectorIt = vectorParams.find( returnParams[2] );\n        assert( ( vectorIt != vectorParams.end() ) && ( vectorIt->second.lenParam == returnParams[1] ) );\n        assert( !vectorParams.contains( returnParams[0] ) );\n#endif\n        returnType = \"std::pair<VULKAN_HPP_NAMESPACE::StructureChain<X, Y, Z...>, std::vector<\" + dataTypes[2] +\n                     ( raii ? \"\" : ( \", \" + startUpperCase( dataTypes[2] ) + \"Allocator\" ) ) + \">>\";\n      }\n      else\n      {\n        if ( vectorParams.contains( returnParams[1] ) )\n        {\n#if !defined( NDEBUG )\n          auto vectorIt = vectorParams.find( returnParams[1] );\n          assert( ( vectorIt != vectorParams.end() ) && ( vectorIt->second.lenParam == returnParams[0] ) );\n          vectorIt = vectorParams.find( returnParams[2] );\n          assert( ( vectorIt != vectorParams.end() ) && ( vectorIt->second.lenParam == returnParams[0] ) );\n#endif\n          returnType = \"std::pair<std::vector<\" + dataTypes[1] +\n                       ( raii ? \"\" : ( \", \" + stripPrefix( dataTypes[1], \"VULKAN_HPP_NAMESPACE::\" ) + \"Allocator\" ) ) + \">, std::vector<\" + dataTypes[2] +\n                       ( raii ? \"\" : ( \", \" + stripPrefix( dataTypes[2], \"VULKAN_HPP_NAMESPACE::\" ) + \"Allocator\" ) ) + \">>\";\n        }\n        else\n        {\n#if !defined( NDEBUG )\n          auto vectorIt = vectorParams.find( returnParams[2] );\n          assert( ( vectorIt != vectorParams.end() ) && ( vectorIt->second.lenParam == returnParams[1] ) );\n          assert( !vectorParams.contains( returnParams[0] ) );\n#endif\n          returnType = \"std::pair<\" + dataTypes[0] + \", std::vector<\" + dataTypes[2] +\n                       ( raii ? \"\" : ( \", \" + startUpperCase( stripPrefix( dataTypes[2], \"VULKAN_HPP_NAMESPACE::\" ) ) + \"Allocator\" ) ) + \">>\";\n        }\n      }\n      break;\n    default: assert( false );\n  }\n\n  return returnType;\n}\n\nstd::string VulkanHppGenerator::generateReturnVariable( CommandData const &                       commandData,\n                                                        std::vector<size_t> const &               returnParams,\n                                                        std::map<size_t, VectorParamData> const & vectorParams,\n                                                        CommandFlavourFlags                       flavourFlags ) const\n{\n  const bool chained  = flavourFlags & CommandFlavourFlagBits::chained;\n  const bool singular = flavourFlags & CommandFlavourFlagBits::singular;\n\n  std::string returnVariable;\n  switch ( returnParams.size() )\n  {\n    case 0: break;  // no return variable\n    case 1:\n      if ( chained )\n      {\n        returnVariable = \"structureChain\";\n      }\n      else\n      {\n        auto vectorParamIt = vectorParams.find( returnParams[0] );\n        if ( ( vectorParamIt != vectorParams.end() ) && vectorParamIt->second.byStructure )\n        {\n          returnVariable = startLowerCase( stripPrefix( vectorMemberByStructure( commandData.params[returnParams[0]].type.type ).name, \"p\" ) );\n        }\n        else\n        {\n          returnVariable = startLowerCase( stripPrefix( commandData.params[returnParams[0]].name, \"p\" ) );\n        }\n        if ( singular )\n        {\n          returnVariable = stripPluralS( returnVariable );\n        }\n      }\n      break;\n    case 2:\n      if ( chained )\n      {\n        returnVariable = \"structureChains\";\n      }\n      else\n      {\n        auto vectorParamIt = vectorParams.find( returnParams[1] );\n        if ( vectorParamIt == vectorParams.end() )\n        {  // the return variable is simply named \"data_\", and holds the multi-return value stuff\n          returnVariable = \"data_\";\n        }\n        else\n        {\n          assert( vectorParamIt->second.lenParam == returnParams[0] );\n          assert( !singular );\n          returnVariable = startLowerCase( stripPrefix( commandData.params[returnParams[1]].name, \"p\" ) );\n        }\n      }\n      break;\n    case 3:\n      assert( !singular );\n      assert( ( ( vectorParams.size() == 1 ) && ( vectorParams.begin()->first == returnParams[2] ) &&\n                ( vectorParams.begin()->second.lenParam == returnParams[1] ) ) ||\n              ( ( vectorParams.size() == 2 ) && ( vectorParams.begin()->first == returnParams[1] ) &&\n                ( vectorParams.begin()->second.lenParam == returnParams[0] ) && ( std::next( vectorParams.begin() )->first == returnParams[2] ) &&\n                ( std::next( vectorParams.begin() )->second.lenParam == returnParams[0] ) ) );\n      returnVariable = \"data_\";\n      break;\n    default: assert( false ); break;\n  }\n  return returnVariable;\n}\n\nstd::string VulkanHppGenerator::generateSizeCheck( std::vector<std::vector<MemberData>::const_iterator> const & arrayIts,\n                                                   std::string const &                                          structName,\n                                                   bool                                                         mutualExclusiveLens ) const\n{\n  std::string sizeCheck;\n  if ( 1 < arrayIts.size() )\n  {\n    static const std::string throwTextTemplate = R\"(      if ( ${throwCheck} )\n      {\n        throw LogicError( VULKAN_HPP_NAMESPACE_STRING\"::${structName}::${structName}: ${throwCheck}\" );\n      }\n)\";\n\n    std::string assertionText, throwText;\n    if ( mutualExclusiveLens )\n    {\n      // exactly one of the arrays has to be non-empty\n      std::string sum;\n      for ( auto it : arrayIts )\n      {\n        sum += \"!\" + startLowerCase( stripPrefix( it->name, \"p\" ) ) + \"_.empty() + \";\n      }\n      sum.resize( sum.size() - 3 );\n      assertionText += \"      VULKAN_HPP_ASSERT( ( \" + sum + \" ) <= 1);\\n\";\n      throwText += replaceWithMap( throwTextTemplate, { { \"structName\", structName }, { \"throwCheck\", \"1 < ( \" + sum + \" )\" } } );\n    }\n    else\n    {\n      for ( size_t first = 0; first + 1 < arrayIts.size(); ++first )\n      {\n        assert( arrayIts[first]->name.starts_with( \"p\" ) );\n        std::string firstName = startLowerCase( stripPrefix( arrayIts[first]->name, \"p\" ) ) + \"_\";\n        for ( auto second = first + 1; second < arrayIts.size(); ++second )\n        {\n          assert( arrayIts[second]->name.starts_with( \"p\" ) );\n          std::string secondName     = startLowerCase( stripPrefix( arrayIts[second]->name, \"p\" ) ) + \"_\";\n          std::string assertionCheck = firstName + \".size() == \" + secondName + \".size()\";\n          std::string throwCheck     = firstName + \".size() != \" + secondName + \".size()\";\n          if ( ( !arrayIts[first]->optional.empty() && arrayIts[first]->optional.front() ) ||\n               ( !arrayIts[second]->optional.empty() && arrayIts[second]->optional.front() ) )\n          {\n            assertionCheck = \"( \" + assertionCheck + \" )\";\n            throwCheck     = \"( \" + throwCheck + \" )\";\n            if ( !arrayIts[second]->optional.empty() && arrayIts[second]->optional.front() )\n            {\n              assertionCheck = secondName + \".empty() || \" + assertionCheck;\n              throwCheck     = \"!\" + secondName + \".empty() && \" + throwCheck;\n            }\n            if ( !arrayIts[first]->optional.empty() && arrayIts[first]->optional.front() )\n            {\n              assertionCheck = firstName + \".empty() || \" + assertionCheck;\n              throwCheck     = \"!\" + firstName + \".empty() && \" + throwCheck;\n            }\n          }\n          assertionText += \"      VULKAN_HPP_ASSERT( \" + assertionCheck + \" );\\n\";\n          throwText += replaceWithMap( throwTextTemplate, { { \"structName\", structName }, { \"throwCheck\", throwCheck } } );\n        }\n      }\n    }\n    sizeCheck += \"\\n#ifdef VULKAN_HPP_NO_EXCEPTIONS\\n\" + assertionText + \"#else\\n\" + throwText + \"#endif /*VULKAN_HPP_NO_EXCEPTIONS*/\\n\" + \"    \";\n  }\n  return sizeCheck;\n}\n\nstd::string VulkanHppGenerator::generateStaticAssertions() const\n{\n  std::string           staticAssertions;\n  std::set<std::string> listedStructs;\n  for ( auto const & feature : m_features )\n  {\n    staticAssertions += generateStaticAssertions( feature.requireData, feature.name, listedStructs );\n  }\n  for ( auto const & extension : m_extensions )\n  {\n    staticAssertions += generateStaticAssertions( extension.requireData, extension.name, listedStructs );\n  }\n  return staticAssertions;\n}\n\nstd::string VulkanHppGenerator::generateStaticAssertions( std::vector<RequireData> const & requireData,\n                                                          std::string const &              title,\n                                                          std::set<std::string> &          listedStructs ) const\n{\n  std::string str;\n  for ( auto const & require : requireData )\n  {\n    for ( auto const & type : require.types )\n    {\n      auto handleIt = m_handles.find( type.name );\n      if ( handleIt != m_handles.end() )\n      {\n        std::string const assertionTemplate = R\"(\nVULKAN_HPP_STATIC_ASSERT( sizeof( VULKAN_HPP_NAMESPACE::${className} ) == sizeof( Vk${className} ), \"handle and wrapper have different size!\" );\nVULKAN_HPP_STATIC_ASSERT( std::is_copy_constructible<VULKAN_HPP_NAMESPACE::${className}>::value, \"${className} is not copy_constructible!\" );\nVULKAN_HPP_STATIC_ASSERT( std::is_nothrow_move_constructible<VULKAN_HPP_NAMESPACE::${className}>::value, \"${className} is not nothrow_move_constructible!\" );\n)\";\n        str += replaceWithMap( assertionTemplate, { { \"className\", stripPrefix( handleIt->first, \"Vk\" ) } } );\n      }\n      else\n      {\n        auto structIt = m_structs.find( type.name );\n        if ( ( structIt != m_structs.end() ) && listedStructs.insert( type.name ).second )\n        {\n          std::string const assertionTemplate = R\"(\nVULKAN_HPP_STATIC_ASSERT( sizeof( VULKAN_HPP_NAMESPACE::${structureType} ) == sizeof( Vk${structureType} ), \"struct and wrapper have different size!\" );\nVULKAN_HPP_STATIC_ASSERT( std::is_standard_layout<VULKAN_HPP_NAMESPACE::${structureType}>::value, \"struct wrapper is not a standard layout!\" );\nVULKAN_HPP_STATIC_ASSERT( std::is_nothrow_move_constructible<VULKAN_HPP_NAMESPACE::${structureType}>::value, \"${structureType} is not nothrow_move_constructible!\" );\n)\";\n          str += replaceWithMap( assertionTemplate, { { \"structureType\", stripPrefix( structIt->first, \"Vk\" ) } } );\n        }\n      }\n    }\n  }\n  return addTitleAndProtection( title, str );\n}\n\nstd::string VulkanHppGenerator::generateStruct( std::pair<std::string, StructureData> const & structure, std::set<std::string> & listedStructs ) const\n{\n  assert( !listedStructs.contains( structure.first ) );\n\n  std::string str;\n  for ( auto const & member : structure.second.members )\n  {\n    auto typeIt = m_types.find( member.type.type );\n    assert( typeIt != m_types.end() );\n    if ( ( typeIt->second.category == TypeCategory::Struct ) || ( typeIt->second.category == TypeCategory::Union ) )\n    {\n      auto structIt = findByNameOrAlias( m_structs, member.type.type );\n      assert( structIt != m_structs.end() );\n      if ( ( structure.first != member.type.type ) && !listedStructs.contains( member.type.type ) )\n      {\n        str += generateStruct( *structIt, listedStructs );\n      }\n    }\n    else if ( typeIt->second.category == TypeCategory::FuncPointer )\n    {\n      auto funcPtrIt = m_funcPointers.find( member.type.type );\n      assert( funcPtrIt != m_funcPointers.end() );\n      if ( !listedStructs.contains( member.type.type ) )\n      {\n        str += generateFuncPointer( *funcPtrIt, listedStructs );\n      }\n    }\n  }\n\n  if ( !structure.second.subStruct.empty() )\n  {\n    auto structureIt = m_structs.find( structure.second.subStruct );\n    if ( ( structureIt != m_structs.end() ) && !listedStructs.contains( structureIt->first ) )\n    {\n      str += generateStruct( *structureIt, listedStructs );\n    }\n  }\n\n  if ( structure.second.isUnion )\n  {\n    str += generateUnion( structure );\n  }\n  else\n  {\n    str += generateStructure( structure );\n  }\n\n  listedStructs.insert( structure.first );\n  return str;\n}\n\nstd::string VulkanHppGenerator::generateStructCompareOperators( std::pair<std::string, StructureData> const & structData ) const\n{\n  static const std::set<std::string> simpleTypes = { \"char\",   \"double\",  \"DWORD\",    \"float\",    \"HANDLE\",  \"HINSTANCE\", \"HMONITOR\",\n                                                     \"HWND\",   \"int\",     \"int8_t\",   \"int16_t\",  \"int32_t\", \"int64_t\",   \"LPCWSTR\",\n                                                     \"size_t\", \"uint8_t\", \"uint16_t\", \"uint32_t\", \"uint64_t\" };\n  // two structs are compared by comparing each of the elements\n  std::string compareMembers, spaceshipMembers;\n  std::string intro             = \"\";\n  bool        nonDefaultCompare = false;\n  std::string spaceshipOrdering = containsFloatingPoints( structData.second.members ) ? \"std::partial_ordering\" : \"std::strong_ordering\";\n  for ( size_t i = 0; i < structData.second.members.size(); i++ )\n  {\n    MemberData const & member = structData.second.members[i];\n    auto               typeIt = m_types.find( member.type.type );\n    assert( typeIt != m_types.end() );\n    if ( ( typeIt->second.category == TypeCategory::ExternalType ) && member.type.postfix.empty() && !simpleTypes.contains( member.type.type ) )\n    {\n      nonDefaultCompare = true;\n      // this type might support operator==() or operator<=>()... that is, use memcmp\n      compareMembers += intro + \"( memcmp( &\" + member.name + \", &rhs.\" + member.name + \", sizeof( \" + member.type.type + \" ) ) == 0 )\";\n\n      static const std::string spaceshipMemberTemplate =\n        R\"(      if ( auto cmp = memcmp( &${name}, &rhs.${name}, sizeof( ${type} ) ); cmp != 0 )\n        return ( cmp < 0 ) ? ${ordering}::less : ${ordering}::greater;\n)\";\n      spaceshipMembers +=\n        replaceWithMap( spaceshipMemberTemplate, { { \"name\", member.name }, { \"ordering\", spaceshipOrdering }, { \"type\", member.type.type } } );\n    }\n    else if ( member.type.type == \"char\" && !member.lenExpressions.empty() )\n    {\n      // compare null-terminated strings\n      nonDefaultCompare = true;\n      assert( member.lenExpressions.size() < 3 );\n      if ( member.lenExpressions.size() == 1 )\n      {\n        assert( member.lenExpressions[0] == \"null-terminated\" );\n        if ( member.arraySizes.empty() )\n        {\n          compareMembers += intro + \"( ( \" + member.name + \" == rhs.\" + member.name + \" ) || ( strcmp( \" + member.name + \", rhs.\" + member.name + \" ) == 0 ) )\";\n\n          static const std::string spaceshipMemberTemplate =\n            R\"(     if ( ${name} != rhs.${name} )\n        if ( auto cmp = strcmp( ${name}, rhs.${name} ); cmp != 0 )\n          return ( cmp < 0 ) ? ${ordering}::less : ${ordering}::greater;\n)\";\n          spaceshipMembers += replaceWithMap( spaceshipMemberTemplate, { { \"name\", member.name }, { \"ordering\", spaceshipOrdering } } );\n        }\n        else\n        {\n          assert( member.arraySizes.size() == 1 );\n          compareMembers += intro + \"( strcmp( \" + member.name + \", rhs.\" + member.name + \" ) == 0 )\";\n\n          static const std::string spaceshipMemberTemplate =\n            R\"(     if ( auto cmp = strcmp( ${name}, rhs.${name} ); cmp != 0 )\n          return ( cmp < 0 ) ? ${ordering}::less : ${ordering}::greater;\n)\";\n          spaceshipMembers += replaceWithMap( spaceshipMemberTemplate, { { \"name\", member.name }, { \"ordering\", spaceshipOrdering } } );\n        }\n      }\n      else\n      {\n        assert( member.lenExpressions[1] == \"null-terminated\" );\n        assert( ( member.type.prefix == \"const\" ) && ( member.type.postfix == \"* const *\" ) );\n        static const std::string compareMemberTemplate =\n          R\"(std::equal( ${name}, ${name} + ${count}, rhs.${name}, []( char const * left, char const * right ) { return ( left == right ) || ( strcmp( left, right ) == 0 ); } ))\";\n        compareMembers += intro + replaceWithMap( compareMemberTemplate, { { \"count\", member.lenExpressions[0] }, { \"name\", member.name } } );\n\n        static const std::string spaceshipMemberTemplate = R\"(      for ( size_t i = 0; i < ${count}; ++i )\n      {\n        if ( ${name}[i] != rhs.${name}[i] )\n          if ( auto cmp = strcmp( ${name}[i], rhs.${name}[i] ); cmp != 0 )\n            return cmp < 0 ? ${ordering}::less : ${ordering}::greater;\n      }\n)\";\n        spaceshipMembers +=\n          replaceWithMap( spaceshipMemberTemplate, { { \"count\", member.lenExpressions[0] }, { \"name\", member.name }, { \"ordering\", spaceshipOrdering } } );\n      }\n    }\n    else if ( !member.arraySizes.empty() && !member.lenExpressions.empty() )\n    {\n      nonDefaultCompare = true;\n\n      assert( ( member.arraySizes.size() == 1 ) && ( member.lenExpressions.size() == 1 ) );\n      assert( std::any_of( structData.second.members.begin(),\n                           structData.second.members.end(),\n                           [&member]( MemberData const & m ) { return m.name == member.lenExpressions[0]; } ) );\n\n      std::string type = member.type.type.starts_with( \"Vk\" ) ? member.type.compose( \"VULKAN_HPP_NAMESPACE\" ) : member.type.type;\n\n      static const std::string compareMemberTemplate = R\"(( memcmp( ${name}, rhs.${name}, ${count} * sizeof( ${type} ) ) == 0 ))\";\n      compareMembers += intro + replaceWithMap( compareMemberTemplate, { { \"count\", member.lenExpressions[0] }, { \"name\", member.name }, { \"type\", type } } );\n\n      static const std::string spaceshipMemberTemplate = R\"(      for ( size_t i = 0; i < ${count}; ++i )\n      {\n        if ( auto cmp = ${name}[i] <=> rhs.${name}[i]; cmp != 0 ) return cmp;\n      }\n)\";\n      spaceshipMembers += replaceWithMap( spaceshipMemberTemplate, { { \"count\", member.lenExpressions[0] }, { \"name\", member.name } } );\n    }\n    else\n    {\n      // for all others, we use the operator== of that type\n      compareMembers += intro + \"( \" + member.name + \" == rhs.\" + member.name + \" )\";\n      spaceshipMembers += \"      if ( auto cmp = \" + member.name + \" <=> rhs.\" + member.name + \"; cmp != 0 ) return cmp;\\n\";\n    }\n    intro = \"\\n          && \";\n  }\n\n  std::string structName = stripPrefix( structData.first, \"Vk\" );\n\n  std::string compareBody, spaceshipOperator, spaceshipOperatorIf, spaceshipOperatorElse, spaceshipOperatorEndif;\n  if ( nonDefaultCompare )\n  {\n    compareBody = \"      return \" + compareMembers + \";\";\n\n    if ( !containsFuncPointer( structData.first ) )\n    {\n      static const std::string spaceshipOperatorTemplate =\n        R\"(    ${ordering} operator<=>( ${name} const & rhs ) const VULKAN_HPP_NOEXCEPT\n    {\n${spaceshipMembers}\n      return ${ordering}::equivalent;\n    })\";\n      spaceshipOperatorIf = \"#if defined(VULKAN_HPP_HAS_SPACESHIP_OPERATOR)\";\n      spaceshipOperator =\n        replaceWithMap( spaceshipOperatorTemplate, { { \"name\", structName }, { \"ordering\", spaceshipOrdering }, { \"spaceshipMembers\", spaceshipMembers } } );\n      spaceshipOperatorElse  = \"#endif\\n\";\n      spaceshipOperatorEndif = \"\";\n    }\n  }\n  else\n  {\n    // use reflection only if VULKAN_HPP_USE_REFLECT is defined\n    static const std::string compareBodyTemplate = R\"(#if defined( VULKAN_HPP_USE_REFLECT )\n      return this->reflect() == rhs.reflect"
        },
        {
          "name": "VulkanHppGenerator.hpp",
          "type": "blob",
          "size": 84.3505859375,
          "content": "// Copyright(c) 2015-2019, NVIDIA CORPORATION. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"XMLHelper.hpp\"\n\n#include <iostream>\n#include <map>\n#include <set>\n#include <tinyxml2.h>\n#include <vector>\n\nconstexpr size_t INVALID_INDEX = static_cast<size_t>( ~0 );\n\ntemplate <typename BitType>\nclass Flags\n{\npublic:\n  using MaskType = typename std::underlying_type<BitType>::type;\n\n  constexpr Flags() noexcept : m_mask( 0 ) {}\n\n  constexpr Flags( BitType bit ) noexcept : m_mask( static_cast<MaskType>( bit ) ) {}\n\n  constexpr explicit Flags( MaskType flags ) noexcept : m_mask( flags ) {}\n\n  constexpr Flags<BitType> & operator|=( Flags<BitType> const & rhs ) noexcept\n  {\n    m_mask |= rhs.m_mask;\n    return *this;\n  }\n\n  constexpr bool operator!() const noexcept\n  {\n    return !m_mask;\n  }\n\n  constexpr bool operator&( BitType const & rhs ) const noexcept\n  {\n    return m_mask & static_cast<MaskType>( rhs );\n  }\n\n  constexpr Flags<BitType> operator&( Flags<BitType> const & rhs ) const noexcept\n  {\n    return Flags<BitType>( m_mask & rhs.m_mask );\n  }\n\n  constexpr Flags<BitType> operator|( Flags<BitType> const & rhs ) const noexcept\n  {\n    return Flags<BitType>( m_mask | rhs.m_mask );\n  }\n\nprivate:\n  MaskType m_mask;\n};\n\nenum class CommandFlavourFlagBits : uint8_t\n{\n  enhanced      = 1 << 0,\n  chained       = 1 << 1,\n  singular      = 1 << 2,\n  unique        = 1 << 3,\n  withAllocator = 1 << 4,\n  noReturn      = 1 << 5,\n  keepVoidPtr   = 1 << 6\n};\nusing CommandFlavourFlags = Flags<CommandFlavourFlagBits>;\n\nconstexpr CommandFlavourFlags operator|( CommandFlavourFlagBits const & lhs, CommandFlavourFlagBits const & rhs ) noexcept\n{\n  return CommandFlavourFlags( lhs ) | CommandFlavourFlags( rhs );\n}\n\nclass VulkanHppGenerator\n{\npublic:\n  VulkanHppGenerator( tinyxml2::XMLDocument const & document, std::string const & api );\n\n  VulkanHppGenerator()                                             = delete;\n  VulkanHppGenerator( VulkanHppGenerator const & rhs )             = delete;\n  VulkanHppGenerator( VulkanHppGenerator && rhs )                  = delete;\n  VulkanHppGenerator & operator=( VulkanHppGenerator const & rhs ) = delete;\n  VulkanHppGenerator & operator=( VulkanHppGenerator && rhs )      = delete;\n\n  void distributeSecondLevelCommands();\n  void generateEnumsHppFile() const;\n  void generateExtensionInspectionFile() const;\n  void generateFormatTraitsHppFile() const;\n  void generateFuncsHppFile() const;\n  void generateHandlesHppFile() const;\n  void generateHashHppFile() const;\n  void generateHppFile() const;\n  void generateMacrosFile() const;\n  void generateRAIIHppFile() const;\n  void generateSharedHppFile() const;\n  void generateStaticAssertionsHppFile() const;\n  void generateStructsHppFile() const;\n  void generateToStringHppFile() const;\n  void generateCppModuleFile() const;\n  void prepareRAIIHandles();\n\n  struct MacroData\n  {\n    std::string              deprecatedComment = {};\n    std::string              calleeMacro       = {};\n    std::vector<std::string> params            = {};\n    std::string              definition        = {};\n  };\n\nprivate:\n  struct NameLine\n  {\n    std::string name    = {};\n    int         xmlLine = {};\n  };\n\n  struct BaseTypeData\n  {\n    TypeInfo typeInfo = {};\n    int      xmlLine  = {};\n  };\n\n  struct BitmaskData\n  {\n    std::map<std::string, int> aliases = {};\n    std::string                require = {};\n    std::string                type    = {};\n    int                        xmlLine = {};\n  };\n\n  struct EnumValueAlias\n  {\n    std::string alias     = {};\n    std::string name      = {};\n    std::string protect   = {};\n    bool        supported = {};\n    int         xmlLine   = {};\n  };\n\n  struct EnumValueData\n  {\n    std::vector<EnumValueAlias> aliases    = {};\n    std::string                 bitpos     = {};\n    bool                        deprecated = {};\n    std::string                 name       = {};\n    std::string                 protect    = {};\n    bool                        supported  = {};\n    std::string                 value      = {};\n    int                         xmlLine    = {};\n  };\n\n  struct EnumData\n  {\n    void addEnumAlias( int line, std::string const & name, std::string const & alias, std::string const & protect, bool supported );\n    void addEnumValue( int                 line,\n                       std::string const & valueName,\n                       std::string const & protect,\n                       std::string const & bitpos,\n                       std::string const & value,\n                       bool                supported,\n                       bool                deprecated );\n\n    std::map<std::string, int>  aliases      = {};\n    std::string                 bitwidth     = {};\n    bool                        isBitmask    = false;\n    std::vector<EnumValueAlias> valueAliases = {};  // temporary storage for aliases, as they might be specified before the actual value is specified\n    std::vector<EnumValueData>  values       = {};\n    int                         xmlLine      = {};\n  };\n\n  struct EnumExtendData\n  {\n    std::string           alias      = {};\n    std::string           api        = {};\n    std::string           name       = {};\n    std::string           platform   = {};\n    std::set<std::string> requiredBy = {};\n    bool                  supported  = {};\n    int                   xmlLine    = {};\n  };\n\n  struct NameData\n  {\n    std::string              name       = {};\n    std::vector<std::string> arraySizes = {};\n  };\n\n  struct ParamData\n  {\n    TypeInfo                                    type          = {};\n    std::string                                 name          = {};\n    std::vector<std::string>                    arraySizes    = {};\n    std::string                                 lenExpression = {};\n    std::vector<std::pair<std::string, size_t>> lenParams     = {};\n    bool                                        optional      = false;\n    std::pair<std::string, size_t>              strideParam   = {};\n    int                                         xmlLine       = {};\n  };\n\n  struct CommandData\n  {\n    std::map<std::string, int> aliases      = {};\n    std::vector<std::string>   errorCodes   = {};\n    std::string                handle       = {};\n    std::vector<ParamData>     params       = {};\n    std::set<std::string>      requiredBy   = {};\n    std::string                returnType   = {};\n    std::vector<std::string>   successCodes = {};\n    int                        xmlLine      = {};\n  };\n\n  struct ConstantData\n  {\n    std::string type    = {};\n    std::string value   = {};\n    int         xmlLine = {};\n  };\n\n  struct DefineData\n  {\n    bool                     deprecated         = false;\n    std::string              require            = {};\n    int                      xmlLine            = {};\n    std::string              deprecationReason  = {};\n    std::string              possibleCallee     = {};\n    std::vector<std::string> params             = {};\n    std::string              possibleDefinition = {};\n  };\n\n  struct DefinesPartition\n  {\n    std::map<std::string, DefineData> callees = {};\n    std::map<std::string, DefineData> callers = {};\n    std::map<std::string, DefineData> values  = {};\n  };\n\n  struct RequireFeature\n  {\n    std::vector<std::string> name      = {};\n    std::string              structure = {};\n    int                      xmlLine   = {};\n  };\n\n  struct RemoveData\n  {\n    std::vector<std::string>    commands = {};\n    std::vector<std::string>    enums    = {};\n    std::vector<RequireFeature> features = {};\n    std::vector<std::string>    types    = {};\n    int                         xmlLine  = {};\n  };\n\n  struct RequireData\n  {\n    std::string                        api           = {};\n    std::string                        depends       = {};\n    std::vector<NameLine>              commands      = {};\n    std::map<std::string, std::string> enumConstants = {};\n    std::vector<std::string>           constants     = {};\n    std::vector<RequireFeature>        features      = {};\n    std::vector<NameLine>              types         = {};\n    int                                xmlLine       = {};\n  };\n\n  struct ExtensionData\n  {\n    std::string                                                  deprecatedBy           = {};\n    bool                                                         isDeprecated           = false;\n    std::string                                                  name                   = {};\n    std::string                                                  number                 = {};\n    std::string                                                  obsoletedBy            = {};\n    std::string                                                  platform               = {};\n    std::string                                                  promotedTo             = {};\n    std::map<std::string, std::vector<std::vector<std::string>>> depends                = {};\n    std::vector<std::string>                                     ratified               = {};\n    std::vector<RemoveData>                                      removeData             = {};\n    std::vector<RequireData>                                     requireData            = {};\n    std::vector<std::string>                                     supported              = {};\n    std::string                                                  type                   = {};\n    std::vector<RequireData>                                     unsupportedRequireData = {};\n    int                                                          xmlLine                = 0;\n  };\n\n  struct FeatureData\n  {\n    std::string              name        = {};\n    std::string              number      = {};\n    std::vector<RemoveData>  removeData  = {};\n    std::vector<RequireData> requireData = {};\n    int                      xmlLine     = {};\n  };\n\n  struct ExternalTypeData\n  {\n    std::string require = {};\n    int         xmlLine = 0;\n  };\n\n  struct ComponentData\n  {\n    std::string bits          = {};\n    std::string name          = {};\n    std::string numericFormat = {};\n    std::string planeIndex    = {};\n    int         xmlLine       = {};\n  };\n\n  struct PlaneData\n  {\n    std::string compatible    = {};\n    std::string heightDivisor = {};\n    std::string widthDivisor  = {};\n    int         xmlLine       = {};\n  };\n\n  struct FormatData\n  {\n    std::string                blockExtent      = {};\n    std::string                blockSize        = {};\n    std::string                chroma           = {};\n    std::string                classAttribute   = {};\n    std::vector<ComponentData> components       = {};\n    std::string                compressed       = {};\n    std::string                packed           = {};\n    std::vector<PlaneData>     planes           = {};\n    std::string                spirvImageFormat = {};\n    std::string                texelsPerBlock   = {};\n    int                        xmlLine          = {};\n  };\n\n  struct FuncPointerArgumentData\n  {\n    std::string name    = {};\n    TypeInfo    type    = {};\n    int         xmlLine = {};\n  };\n\n  struct FuncPointerData\n  {\n    std::vector<FuncPointerArgumentData> arguments  = {};\n    std::string                          require    = {};\n    TypeInfo                             returnType = {};\n    int                                  xmlLine    = {};\n  };\n\n  struct HandleData\n  {\n    std::map<std::string, int> aliases             = {};\n    std::set<std::string>      childrenHandles     = {};\n    std::set<std::string>      commands            = {};\n    std::string                deleteCommand       = {};\n    std::string                deletePool          = {};\n    std::string                destructorType      = {};\n    std::string                objTypeEnum         = {};\n    std::string                parent              = {};\n    std::set<std::string>      secondLevelCommands = {};\n    bool                       isDispatchable      = {};\n    int                        xmlLine             = {};\n\n    // RAII data\n    std::map<std::string, CommandData>::const_iterator              destructorIt   = {};\n    std::vector<std::map<std::string, CommandData>::const_iterator> constructorIts = {};\n  };\n\n  struct PlatformData\n  {\n    std::string protect = {};\n    int         xmlLine = {};\n  };\n\n  struct MemberData\n  {\n    std::string                                 defaultValue   = {};\n    TypeInfo                                    type           = {};\n    std::string                                 name           = {};\n    std::vector<std::string>                    arraySizes     = {};\n    std::string                                 bitCount       = {};\n    std::vector<std::string>                    lenExpressions = {};\n    std::vector<std::pair<std::string, size_t>> lenMembers     = {};\n    bool                                        noAutoValidity = {};\n    std::vector<bool>                           optional       = {};\n    std::vector<std::string>                    selection      = {};\n    std::string                                 selector       = {};\n    std::string                                 value          = {};\n    int                                         xmlLine        = {};\n  };\n\n  struct SpirVCapabilityData\n  {\n    std::map<std::string, std::map<std::string, int>> structs = {};  // map from structure to map from member to xmlLine\n    int                                               xmlLine = {};\n  };\n\n  struct StructureData\n  {\n    std::map<std::string, int> aliases             = {};\n    bool                       allowDuplicate      = {};\n    bool                       isExtended          = {};\n    bool                       isUnion             = {};\n    bool                       returnedOnly        = {};\n    bool                       mutualExclusiveLens = {};\n    std::vector<MemberData>    members             = {};\n    std::vector<std::string>   structExtends       = {};\n    std::string                subStruct           = {};\n    int                        xmlLine             = {};\n  };\n\n  struct TagData\n  {\n    int xmlLine = {};\n  };\n\n  struct VectorParamData\n  {\n    size_t lenParam    = INVALID_INDEX;\n    size_t strideParam = INVALID_INDEX;\n    bool   byStructure = false;\n  };\n\n  struct VideoRequireCapabilities\n  {\n    int         xmlLine = {};\n    std::string name;\n    std::string member;\n    std::string value;\n  };\n\n  struct VideoFormat\n  {\n    int                                   xmlLine = {};\n    std::vector<std::string>              formatProperties;\n    std::string                           name;\n    std::vector<std::string>              usage;\n    std::vector<VideoRequireCapabilities> requireCapabilities;\n  };\n\n  struct VideoProfile\n  {\n    int         xmlLine = {};\n    std::string name;\n    std::string value;\n  };\n\n  struct VideoProfileMember\n  {\n    int                       xmlLine = {};\n    std::string               name;\n    std::vector<VideoProfile> profiles;\n  };\n\n  struct VideoProfiles\n  {\n    int                             xmlLine = {};\n    std::string                     name;\n    std::vector<VideoProfileMember> members;\n  };\n\n  struct VideoCodec\n  {\n    int                        xmlLine = {};\n    std::string                name;\n    std::vector<std::string>   capabilities;\n    std::string                extend;\n    std::string                value;\n    std::vector<VideoFormat>   formats;\n    std::vector<VideoProfiles> profiles;\n  };\n\n  struct MacroVisitor final : tinyxml2::XMLVisitor\n  {\n    // comments, then name, then parameters and definition together, because that's how they appear in the xml!\n    // guaranteed to be 3 elements long\n    std::vector<std::string> macro;\n\n    bool Visit( tinyxml2::XMLText const & text ) override\n    {\n      if ( auto const nodeText = text.Value(); nodeText != nullptr )\n      {\n        macro.emplace_back( nodeText );\n      }\n      return true;\n    }\n  };\n\nprivate:\n  void        addCommand( std::string const & name, CommandData & commandData );\n  void        addCommandsToHandle( std::vector<RequireData> const & requireData );\n  void        addMissingFlagBits( std::vector<RequireData> & requireData, std::string const & requiredBy );\n  std::string addTitleAndProtection( std::string const & title, std::string const & strIf, std::string const & strElse = {} ) const;\n  bool        allVectorSizesSupported( std::vector<ParamData> const & params, std::map<size_t, VectorParamData> const & vectorParams ) const;\n  void        appendDispatchLoaderDynamicCommands( std::vector<RequireData> const & requireData,\n                                                   std::set<std::string> &          listedCommands,\n                                                   std::string const &              title,\n                                                   std::string &                    commandMembers,\n                                                   std::string &                    initialCommandAssignments,\n                                                   std::string &                    instanceCommandAssignments,\n                                                   std::string &                    deviceCommandAssignments ) const;\n  void        appendRAIIDispatcherCommands( std::vector<RequireData> const & requireData,\n                                            std::set<std::string> &          listedCommands,\n                                            std::string const &              title,\n                                            std::string &                    contextInitializers,\n                                            std::string &                    contextMembers,\n                                            std::string &                    deviceAssignments,\n                                            std::string &                    deviceMembers,\n                                            std::string &                    instanceAssignments,\n                                            std::string &                    instanceMembers ) const;\n  void        checkBitmaskCorrectness() const;\n  void        checkCommandCorrectness() const;\n  void        checkCorrectness() const;\n  void        checkDefineCorrectness() const;\n  void        checkEnumCorrectness() const;\n  void        checkEnumCorrectness( std::vector<RequireData> const & requireData ) const;\n  bool        checkEquivalentSingularConstructor( std::vector<std::map<std::string, CommandData>::const_iterator> const & constructorIts,\n                                                  std::map<std::string, CommandData>::const_iterator                      constructorIt,\n                                                  std::vector<ParamData>::const_iterator                                  lenIt ) const;\n  void        checkExtensionCorrectness() const;\n  void        checkFeatureCorrectness() const;\n  void        checkFuncPointerCorrectness() const;\n  void        checkHandleCorrectness() const;\n  void        checkSpirVCapabilityCorrectness() const;\n  void        checkStructCorrectness() const;\n  void checkStructMemberCorrectness( std::string const & structureName, std::vector<MemberData> const & members, std::set<std::string> & sTypeValues ) const;\n  void checkSyncAccessCorrectness() const;\n  void checkSyncStageCorrectness() const;\n  std::string              combineDataTypes( std::map<size_t, VectorParamData> const & vectorParams,\n                                             std::vector<size_t> const &               returnParams,\n                                             bool                                      enumerating,\n                                             std::vector<std::string> const &          dataTypes,\n                                             CommandFlavourFlags                       flavourFlags,\n                                             bool                                      raii ) const;\n  bool                     contains( std::vector<EnumValueData> const & enumValues, std::string const & name ) const;\n  bool                     containsArray( std::string const & type ) const;\n  bool                     containsFuncPointer( std::string const & type ) const;\n  bool                     containsFloatingPoints( std::vector<MemberData> const & members ) const;\n  bool                     containsUnion( std::string const & type ) const;\n  bool                     describesVector( StructureData const & structure, std::string const & type = \"\" ) const;\n  std::vector<size_t>      determineChainedReturnParams( std::vector<ParamData> const & params, std::vector<size_t> const & returnParams ) const;\n  std::vector<size_t>      determineConstPointerParams( std::vector<ParamData> const & params ) const;\n  std::vector<std::string> determineDataTypes( std::vector<VulkanHppGenerator::ParamData> const & params,\n                                               std::map<size_t, VectorParamData> const &          vectorParams,\n                                               std::vector<size_t> const &                        returnParams,\n                                               std::set<size_t> const &                           templatedParams ) const;\n  size_t                   determineDefaultStartIndex( std::vector<ParamData> const & params, std::set<size_t> const & skippedParams ) const;\n  bool                     determineEnumeration( std::map<size_t, VectorParamData> const & vectorParams, std::vector<size_t> const & returnParams ) const;\n  size_t                   determineInitialSkipCount( std::string const & command ) const;\n  std::vector<size_t>      determineReturnParams( std::vector<ParamData> const & params ) const;\n  std::vector<std::map<std::string, CommandData>::const_iterator>\n    determineRAIIHandleConstructors( std::string const & handleType, std::map<std::string, CommandData>::const_iterator destructorIt ) const;\n  std::map<std::string, CommandData>::const_iterator determineRAIIHandleDestructor( std::string const & handleType ) const;\n  std::set<size_t>                                determineSingularParams( size_t returnParam, std::map<size_t, VectorParamData> const & vectorParams ) const;\n  std::set<size_t>                                determineSkippedParams( std::vector<ParamData> const &            params,\n                                                                          size_t                                    initialSkipCount,\n                                                                          std::map<size_t, VectorParamData> const & vectorParams,\n                                                                          std::vector<size_t> const &               returnParam,\n                                                                          bool                                      singular ) const;\n  std::string                                     determineSubStruct( std::pair<std::string, StructureData> const & structure ) const;\n  std::map<size_t, VectorParamData>               determineVectorParams( std::vector<ParamData> const & params ) const;\n  std::set<size_t>                                determineVoidPointerParams( std::vector<ParamData> const & params ) const;\n  void                                            distributeEnumExtends();\n  void                                            distributeEnumValueAliases();\n  void                                            distributeRequirements();\n  void                                            distributeRequirements( std::vector<RequireData> const & requireData, std::string const & requiredBy );\n  void                                            distributeStructAliases();\n  void                                            filterLenMembers();\n  std::map<std::string, NameLine>::const_iterator findAlias( std::string const & name, std::map<std::string, NameLine> const & aliases ) const;\n  std::string                                     findBaseName( std::string aliasName, std::map<std::string, NameLine> const & aliases ) const;\n  std::vector<FeatureData>::const_iterator        findFeature( std::string const & name ) const;\n  std::vector<ParamData>::const_iterator          findParamIt( std::string const & name, std::vector<ParamData> const & paramData ) const;\n  std::vector<MemberData>::const_iterator         findStructMemberIt( std::string const & name, std::vector<MemberData> const & memberData ) const;\n  std::vector<MemberData>::const_iterator         findStructMemberItByType( std::string const & type, std::vector<MemberData> const & memberData ) const;\n  std::vector<ExtensionData>::const_iterator      findSupportedExtension( std::string const & name ) const;\n  std::string                                     findTag( std::string const & name, std::string const & postfix = \"\" ) const;\n  std::pair<std::string, std::string>             generateAllocatorTemplates( std::vector<size_t> const &               returnParams,\n                                                                              std::vector<std::string> const &          returnDataTypes,\n                                                                              std::map<size_t, VectorParamData> const & vectorParams,\n                                                                              std::vector<size_t> const &               chainedReturnParams,\n                                                                              CommandFlavourFlags                       flavourFlags,\n                                                                              bool                                      definition ) const;\n  std::string                                     generateArgumentListEnhanced( std::vector<ParamData> const &            params,\n                                                                                std::vector<size_t> const &               returnParams,\n                                                                                std::map<size_t, VectorParamData> const & vectorParams,\n                                                                                std::set<size_t> const &                  skippedParams,\n                                                                                std::set<size_t> const &                  singularParams,\n                                                                                std::set<size_t> const &                  templatedParams,\n                                                                                std::vector<size_t> const &               chainedReturnParams,\n                                                                                bool                                      definition,\n                                                                                CommandFlavourFlags                       flavourFlags,\n                                                                                bool                                      withDispatcher ) const;\n  std::string\n    generateArgumentListStandard( std::vector<ParamData> const & params, std::set<size_t> const & skippedParams, bool definition, bool withDispatcher ) const;\n  std::string generateArgumentTemplates( std::vector<ParamData> const &            params,\n                                         std::vector<size_t> const &               returnParams,\n                                         std::map<size_t, VectorParamData> const & vectorParams,\n                                         std::set<size_t> const &                  templatedParams,\n                                         std::vector<size_t> const &               chainedReturnParams,\n                                         bool                                      raii ) const;\n  std::string generateBaseTypes() const;\n  std::string generateBitmask( std::map<std::string, BitmaskData>::const_iterator bitmaskIt, std::string const & surroundingProtect ) const;\n  std::string generateBitmasksToString() const;\n  std::string generateBitmasksToString( std::vector<RequireData> const & requireData, std::set<std::string> & listedBitmasks, std::string const & title ) const;\n  std::string generateBitmaskToString( std::map<std::string, BitmaskData>::const_iterator bitmaskIt ) const;\n  std::string generateCallArgumentsEnhanced( CommandData const &      commandData,\n                                             size_t                   initialSkipCount,\n                                             bool                     nonConstPointerAsNullptr,\n                                             std::set<size_t> const & singularParams,\n                                             std::set<size_t> const & templatedParams,\n                                             bool                     raii,\n                                             bool                     raiiFactory,\n                                             CommandFlavourFlags      flavourFlags ) const;\n  std::string generateCallArgumentsStandard( std::vector<ParamData> const & params, size_t initialSkipCount ) const;\n  std::string generateCallArgumentEnhanced( std::vector<ParamData> const & params,\n                                            size_t                         paramIndex,\n                                            bool                           nonConstPointerAsNullptr,\n                                            std::set<size_t> const &       singularParams,\n                                            std::set<size_t> const &       templatedParams,\n                                            CommandFlavourFlags            flavourFlags,\n                                            bool                           raiiFactory ) const;\n  std::string generateCallArgumentEnhancedConstPointer( ParamData const &        param,\n                                                        size_t                   paramIndex,\n                                                        std::set<size_t> const & singularParams,\n                                                        std::set<size_t> const & templatedParams ) const;\n  std::string generateCallArgumentEnhancedNonConstPointer( ParamData const &        param,\n                                                           size_t                   paramIndex,\n                                                           bool                     nonConstPointerAsNullptr,\n                                                           std::set<size_t> const & singularParams ) const;\n  std::string generateCallArgumentEnhancedValue( std::vector<ParamData> const & params,\n                                                 size_t                         paramIndex,\n                                                 std::set<size_t> const &       singularParams,\n                                                 CommandFlavourFlags            flavourFlags,\n                                                 bool                           raiiFactory ) const;\n  std::string generateCallSequence( std::string const &                       name,\n                                    CommandData const &                       commandData,\n                                    std::vector<size_t> const &               returnParams,\n                                    std::map<size_t, VectorParamData> const & vectorParams,\n                                    size_t                                    initialSkipCount,\n                                    std::set<size_t> const &                  singularParams,\n                                    std::set<size_t> const &                  templatedParams,\n                                    std::vector<size_t> const &               chainedReturnParams,\n                                    CommandFlavourFlags                       flavourFlags,\n                                    bool                                      raii,\n                                    bool                                      raiiFactory ) const;\n  std::string generateChainTemplates( std::vector<size_t> const & returnParams, bool chained ) const;\n  std::string generateCommand( std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string generateCommandDefinitions() const;\n  std::string\n    generateCommandDefinitions( std::vector<RequireData> const & requireData, std::set<std::string> & listedCommands, std::string const & title ) const;\n  std::string generateCommandDefinitions( std::string const & command, std::string const & handle ) const;\n  std::string generateCommandEnhanced( std::string const &                       name,\n                                       CommandData const &                       commandData,\n                                       size_t                                    initialSkipCount,\n                                       bool                                      definition,\n                                       std::map<size_t, VectorParamData> const & vectorParams,\n                                       std::vector<size_t> const &               returnParams,\n                                       CommandFlavourFlags                       flavourFlags ) const;\n  std::string generateCommandName( std::string const &            vulkanCommandName,\n                                   std::vector<ParamData> const & params,\n                                   size_t                         initialSkipCount,\n                                   CommandFlavourFlags            flavourFlags = {} ) const;\n  std::string generateCommandResult( std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string generateCommandResultMultiSuccessNoErrors(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string generateCommandResultMultiSuccessWithErrors(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string generateCommandResultMultiSuccessWithErrors1Return(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const;\n  std::string generateCommandResultMultiSuccessWithErrors2Return( std::string const &         name,\n                                                                  CommandData const &         commandData,\n                                                                  size_t                      initialSkipCount,\n                                                                  bool                        definition,\n                                                                  std::vector<size_t> const & returnParamIndices,\n                                                                  bool                        raii ) const;\n  std::string generateCommandResultMultiSuccessWithErrors3Return( std::string const &         name,\n                                                                  CommandData const &         commandData,\n                                                                  size_t                      initialSkipCount,\n                                                                  bool                        definition,\n                                                                  std::vector<size_t> const & returnParamIndices,\n                                                                  bool                        raii ) const;\n  std::string\n    generateCommandResultSingleSuccess( std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string generateCommandResultSingleSuccessNoErrors(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string generateCommandResultSingleSuccessWithErrors(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string generateCommandResultSingleSuccessWithErrors1Return(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const;\n  std::string generateCommandResultSingleSuccessWithErrors1ReturnChain(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const;\n  std::string generateCommandResultSingleSuccessWithErrors1ReturnHandle(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const;\n  std::string generateCommandResultSingleSuccessWithErrors1ReturnValue(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const;\n  std::string generateCommandResultSingleSuccessWithErrors1ReturnVoid(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const;\n  std::string generateCommandResultSingleSuccessWithErrors2Return( std::string const &         name,\n                                                                   CommandData const &         commandData,\n                                                                   size_t                      initialSkipCount,\n                                                                   bool                        definition,\n                                                                   std::vector<size_t> const & returnParamIndices,\n                                                                   bool                        raii ) const;\n  std::string generateCommandResultSingleSuccessWithErrors3Return( std::string const &         name,\n                                                                   CommandData const &         commandData,\n                                                                   size_t                      initialSkipCount,\n                                                                   bool                        definition,\n                                                                   std::vector<size_t> const & returnParamIndices,\n                                                                   bool                        raii ) const;\n  std::string generateCommandResultWithErrors0Return(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string generateCommandSet( bool                             definition,\n                                  std::string const &              standard,\n                                  std::vector<std::string> const & enhanced = {},\n                                  std::vector<std::string> const & unique   = {} ) const;\n  std::string generateCommandSet( std::string const & standard, std::string const & enhanced ) const;\n  std::string generateCommandSetInclusive( std::string const &                      name,\n                                           CommandData const &                      commandData,\n                                           size_t                                   initialSkipCount,\n                                           bool                                     definition,\n                                           std::vector<size_t>                      returnParams,\n                                           std::map<size_t, VectorParamData>        vectorParams,\n                                           bool                                     unique,\n                                           std::vector<CommandFlavourFlags> const & flags,\n                                           bool                                     raii,\n                                           bool                                     raiiFactory,\n                                           std::vector<CommandFlavourFlags> const & raiiFlags ) const;\n  std::string\n    generateCommandSetExclusive( std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string generateCommandStandard( std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition ) const;\n  std::string generateCommandVoid( std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string generateCommandValue( std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string\n    generateCommandVoid0Return( std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, bool raii ) const;\n  std::string generateCommandVoid1Return(\n    std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition, size_t returnParam, bool raii ) const;\n  std::string generateCommandVoid2Return( std::string const &         name,\n                                          CommandData const &         commandData,\n                                          size_t                      initialSkipCount,\n                                          bool                        definition,\n                                          std::vector<size_t> const & returnParamIndices,\n                                          bool                        raii ) const;\n  std::string generateConstexprString( std::string const & structName ) const;\n  std::string generateConstexprDefines() const;\n  std::string generateConstexprUsings() const;\n  std::string generateCppModuleFuncpointerUsings() const;\n  std::string generateCppModuleHandleUsings() const;\n  std::string generateCppModuleStructUsings() const;\n  std::string generateCppModuleUniqueHandleUsings() const;\n  std::string generateCppModuleFuncsUsings() const;\n  std::string generateCppModuleEnumUsings() const;\n  std::string generateCppModuleFormatTraitsUsings() const;\n  std::string generateCppModuleExtensionInspectionUsings() const;\n  std::string generateCppModuleUsings() const;\n  std::string generateCppModuleRaiiUsings() const;\n  std::string generateCppModuleSharedHandleUsings() const;\n  std::string generateCppModuleHandleHashSpecializations() const;\n  std::string generateCppModuleHashSpecializations() const;\n  std::string generateCppModuleStructHashSpecializations() const;\n  std::string generateDataDeclarations( CommandData const &                       commandData,\n                                        std::vector<size_t> const &               returnParams,\n                                        std::map<size_t, VectorParamData> const & vectorParams,\n                                        std::set<size_t> const &                  templatedParams,\n                                        CommandFlavourFlags                       flavourFlags,\n                                        bool                                      raii,\n                                        std::vector<std::string> const &          dataTypes,\n                                        std::string const &                       dataType,\n                                        std::string const &                       returnType,\n                                        std::string const &                       returnVariable ) const;\n  std::string generateDataDeclarations1Return( CommandData const &                       commandData,\n                                               std::vector<size_t> const &               returnParams,\n                                               std::map<size_t, VectorParamData> const & vectorParams,\n                                               std::set<size_t> const &                  templatedParams,\n                                               CommandFlavourFlags                       flavourFlags,\n                                               std::vector<std::string> const &          dataTypes,\n                                               std::string const &                       dataType,\n                                               std::string const &                       returnType,\n                                               std::string const &                       returnVariable ) const;\n  std::string generateDataDeclarations2Returns( CommandData const &                       commandData,\n                                                std::vector<size_t> const &               returnParams,\n                                                std::map<size_t, VectorParamData> const & vectorParams,\n                                                CommandFlavourFlags                       flavourFlags,\n                                                bool                                      raii,\n                                                std::vector<std::string> const &          dataTypes,\n                                                std::string const &                       returnType,\n                                                std::string const &                       returnVariable ) const;\n  std::string generateDataDeclarations3Returns( CommandData const &                       commandData,\n                                                std::vector<size_t> const &               returnParams,\n                                                std::map<size_t, VectorParamData> const & vectorParams,\n                                                CommandFlavourFlags                       flavourFlags,\n                                                bool                                      raii,\n                                                std::vector<std::string> const &          dataTypes ) const;\n  std::string generateDataPreparation( CommandData const &                       commandData,\n                                       size_t                                    initialSkipCount,\n                                       std::vector<size_t> const &               returnParams,\n                                       std::map<size_t, VectorParamData> const & vectorParams,\n                                       std::set<size_t> const &                  templatedParams,\n                                       CommandFlavourFlags                       flavourFlags,\n                                       bool                                      enumerating,\n                                       std::vector<std::string> const &          dataTypes ) const;\n  std::string generateDataSizeChecks( CommandData const &                       commandData,\n                                      std::vector<size_t> const &               returnParams,\n                                      std::vector<std::string> const &          returnParamTypes,\n                                      std::map<size_t, VectorParamData> const & vectorParams,\n                                      std::set<size_t> const &                  templatedParams,\n                                      bool                                      singular ) const;\n  std::string generateDebugReportObjectType( std::string const & objectType ) const;\n  std::string generateDecoratedReturnType( CommandData const &                       commandData,\n                                           std::vector<size_t> const &               returnParams,\n                                           std::map<size_t, VectorParamData> const & vectorParams,\n                                           CommandFlavourFlags                       flavourFlags,\n                                           bool                                      raii,\n                                           std::string const &                       returnType ) const;\n  std::string generateDeprecatedConstructors( std::string const & name ) const;\n  std::string generateDeprecatedStructSetters( std::string const & name ) const;\n  std::string generateDispatchLoaderDynamic() const;  // uses vkGet*ProcAddress to get function pointers\n  std::string generateDispatchLoaderStatic() const;   // uses exported symbols from loader\n  std::string generateDestroyCommand( std::string const & name, CommandData const & commandData ) const;\n  std::string\n    generateDispatchLoaderDynamicCommandAssignment( std::string const & commandName, std::string const & aliasName, std::string const & firstArg ) const;\n  std::string generateDispatchLoaderStaticCommands( std::vector<RequireData> const & requireData,\n                                                    std::set<std::string> &          listedCommands,\n                                                    std::string const &              title ) const;\n  std::string generateEnum( std::pair<std::string, EnumData> const & enumData, std::string const & surroundingProtect ) const;\n  std::string generateEnumInitializer( TypeInfo const &                   type,\n                                       std::vector<std::string> const &   arraySizes,\n                                       std::vector<EnumValueData> const & values,\n                                       bool                               bitmask ) const;\n  std::string generateEnums() const;\n  std::string generateEnums( std::vector<RequireData> const & requireData, std::set<std::string> & listedEnums, std::string const & title ) const;\n  std::string generateEnumsToString() const;\n  std::string generateEnumsToString( std::vector<RequireData> const & requireData, std::set<std::string> & listedEnums, std::string const & title ) const;\n  std::string generateEnumToString( std::pair<std::string, EnumData> const & enumData ) const;\n  std::pair<std::string, std::string> generateEnumSuffixes( std::string const & name, bool bitmask ) const;\n  std::string                         generateEnumValueName( std::string const & enumName, std::string const & valueName, bool bitmask ) const;\n  std::string                         generateExtensionDependencies() const;\n  std::string                         generateExtensionDependsByVersion( bool definition ) const;\n  template <class Predicate, class Extraction>\n  std::string generateExtensionReplacedBy( Predicate p, Extraction e ) const;\n  template <class Predicate>\n  std::string generateExtensionReplacedTest( Predicate p ) const;\n  std::string generateExtensionsList( std::string const & type ) const;\n  std::string generateExtensionTypeTest( std::string const & type ) const;\n  std::string generateFormatTraits() const;\n  std::string generateFuncPointer( std::pair<std::string, FuncPointerData> const & funcPointer, std::set<std::string> & listedStructs ) const;\n  std::string generateFuncPointerReturns() const;\n  std::string generateFunctionPointerCheck( std::string const & function, std::set<std::string> const & requiredBy, bool raii ) const;\n  std::string generateHandle( std::pair<std::string, HandleData> const & handle, std::set<std::string> & listedHandles ) const;\n  std::string generateHandleCommandDeclarations( std::set<std::string> const & commands ) const;\n  std::string generateHandleDependencies( std::pair<std::string, HandleData> const & handle, std::set<std::string> & listedHandles ) const;\n  std::string generateHandleEmpty( HandleData const & handleData ) const;\n  std::string generateHandleForwardDeclarations() const;\n  std::string generateHandleForwardDeclarations( std::vector<RequireData> const & requireData, std::string const & title ) const;\n  std::string generateHandleHashStructures( std::vector<RequireData> const & requireData, std::string const & title ) const;\n  std::string generateHandleHashStructures() const;\n  std::string generateHandles() const;\n  std::string generateIndexTypeTraits( std::pair<std::string, EnumData> const & enumData ) const;\n  std::string generateLayerSettingTypeTraits() const;\n  std::string\n              generateLenInitializer( std::vector<MemberData>::const_iterator                                                                                 mit,\n                                      std::map<std::vector<MemberData>::const_iterator, std::vector<std::vector<MemberData>::const_iterator>>::const_iterator litit,\n                                      bool mutualExclusiveLens ) const;\n  std::string generateName( TypeInfo const & typeInfo ) const;\n  std::string generateNoExcept( std::vector<std::string> const &          errorCodes,\n                                std::vector<size_t> const &               returnParams,\n                                std::map<size_t, VectorParamData> const & vectorParams,\n                                CommandFlavourFlags                       flavourFlags,\n                                bool                                      vectorSizeCheck,\n                                bool                                      raii ) const;\n  std::string generateObjectDeleter( std::string const & commandName, CommandData const & commandData, size_t initialSkipCount, size_t returnParam ) const;\n  std::string generateObjectTypeToDebugReportObjectType() const;\n  std::pair<std::string, std::string> generateProtection( std::string const & protect, bool defined = true ) const;\n  std::string                         generateRAIICommandDefinitions() const;\n  std::string\n    generateRAIICommandDefinitions( std::vector<RequireData> const & requireData, std::set<std::string> & listedCommands, std::string const & title ) const;\n  std::string generateRAIIDispatchers() const;\n  std::string generateRAIIFactoryReturnStatements( std::vector<ParamData> const &   params,\n                                                   std::vector<std::string> const & successCodes,\n                                                   std::string const &              vkType,\n                                                   bool                             enumerating,\n                                                   std::string const &              returnType,\n                                                   std::string const &              returnVariable,\n                                                   bool                             singular ) const;\n  std::string generateRAIIHandle( std::pair<std::string, HandleData> const & handle,\n                                  std::set<std::string> &                    listedHandles,\n                                  std::set<std::string> const &              specialFunctions ) const;\n  std::string generateRAIIHandleCommand( std::string const & command, size_t initialSkipCount, bool definition ) const;\n  std::string generateRAIIHandleCommandDeclarations( std::pair<std::string, HandleData> const & handle, std::set<std::string> const & specialFunctions ) const;\n  std::string generateRAIIHandleCommandEnhanced( std::string const &                       name,\n                                                 CommandData const &                       commandData,\n                                                 size_t                                    initialSkipCount,\n                                                 std::vector<size_t> const &               returnParams,\n                                                 std::map<size_t, VectorParamData> const & vectorParamIndices,\n                                                 bool                                      definition,\n                                                 CommandFlavourFlags                       flavourFlags = {} ) const;\n  std::string generateRAIIHandleCommandFactory( std::string const &                       name,\n                                                CommandData const &                       commandData,\n                                                size_t                                    initialSkipCount,\n                                                std::vector<size_t> const &               returnParams,\n                                                std::map<size_t, VectorParamData> const & vectorParams,\n                                                bool                                      definition,\n                                                CommandFlavourFlags                       flavourFlags = {} ) const;\n  std::string generateRAIIHandleCommandFactoryArgumentList( std::vector<ParamData> const & params,\n                                                            std::set<size_t> const &       skippedParams,\n                                                            bool                           definition,\n                                                            bool                           singular ) const;\n  std::string generateRAIIHandleCommandStandard( std::string const & name, CommandData const & commandData, size_t initialSkipCount, bool definition ) const;\n  std::pair<std::string, std::string> generateRAIIHandleConstructor( std::pair<std::string, HandleData> const &         handle,\n                                                                     std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                                     std::string const &                                enter,\n                                                                     std::string const &                                leave ) const;\n  std::string                         generateRAIIHandleConstructorByCall( std::pair<std::string, HandleData> const &         handle,\n                                                                           std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                                           std::string const &                                enter,\n                                                                           std::string const &                                leave,\n                                                                           bool                                               isPlural,\n                                                                           bool                                               forceSingular ) const;\n  std::pair<std::string, std::string> generateRAIIHandleConstructor1Return2Vector( std::pair<std::string, HandleData> const &         handle,\n                                                                                   std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                                                   std::string const &                                enter,\n                                                                                   std::string const &                                leave,\n                                                                                   size_t                                             returnParam,\n                                                                                   std::map<size_t, VectorParamData> const & vectorParamIndices ) const;\n  std::pair<std::string, std::string> generateRAIIHandleConstructors( std::pair<std::string, HandleData> const & handle ) const;\n  std::string generateRAIIHandleConstructorArgument( ParamData const & param, bool definition, bool singular, bool takesOwnership ) const;\n  std::string generateRAIIHandleConstructorArguments( std::pair<std::string, HandleData> const &         handle,\n                                                      std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                      bool                                               singular,\n                                                      bool                                               takesOwnership ) const;\n  std::string generateRAIIHandleConstructorInitializationList( std::pair<std::string, HandleData> const &         handle,\n                                                               std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                               std::map<std::string, CommandData>::const_iterator destructorIt,\n                                                               bool                                               takesOwnership ) const;\n  std::string generateRAIIHandleConstructorParamName( std::string const & type, std::map<std::string, CommandData>::const_iterator destructorIt ) const;\n  std::pair<std::string, std::string> generateRAIIHandleConstructorResult( std::pair<std::string, HandleData> const &         handle,\n                                                                           std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                                           std::string const &                                enter,\n                                                                           std::string const &                                leave ) const;\n  std::string                         generateRAIIHandleConstructorTakeOwnership( std::pair<std::string, HandleData> const & handle ) const;\n  std::pair<std::string, std::string> generateRAIIHandleConstructorVoid( std::pair<std::string, HandleData> const &         handle,\n                                                                         std::map<std::string, CommandData>::const_iterator constructorIt,\n                                                                         std::string const &                                enter,\n                                                                         std::string const &                                leave ) const;\n  std::string generateRAIIHandleContext( std::pair<std::string, HandleData> const & handle, std::set<std::string> const & specialFunctions ) const;\n  std::string generateRAIIHandleDestructorCallArguments( std::string const &                                handleType,\n                                                         std::map<std::string, CommandData>::const_iterator destructorIt ) const;\n  std::tuple<std::string, std::string, std::string, std::string, std::string, std::string, std::string>\n              generateRAIIHandleDetails( std::pair<std::string, HandleData> const & handle ) const;\n  std::string generateRAIIHandleForwardDeclarations( std::vector<RequireData> const & requireData, std::string const & title ) const;\n  std::string generateRAIIHandles() const;\n  std::string generateRAIIHandleSingularConstructorArguments( std::pair<std::string, HandleData> const & handle,\n                                                              std::vector<ParamData> const &             params,\n                                                              std::string const &                        argumentType,\n                                                              std::string const &                        argumentName ) const;\n  template <class Predicate, class Extraction>\n  std::string generateReplacedExtensionsList( Predicate p, Extraction e ) const;\n  std::string generateResultAssignment( CommandData const & commandData ) const;\n  std::string generateResultCheck(\n    CommandData const & commandData, std::string const & className, std::string const & classSeparator, std::string commandName, bool enumerating ) const;\n  std::string\n    generateResultCheckExpected( std::vector<std::string> const & successCodes, std::string const & className, std::string const & commandName ) const;\n  std::string generateResultExceptions() const;\n  std::string generateReturnStatement( std::string const & commandName,\n                                       CommandData const & commandData,\n                                       std::string const & returnVariable,\n                                       std::string const & returnType,\n                                       std::string const & decoratedReturnType,\n                                       std::string const & dataType,\n                                       size_t              initialSkipCount,\n                                       size_t              returnParam,\n                                       CommandFlavourFlags flavourFlags,\n                                       bool                enumerating,\n                                       bool                raii ) const;\n  std::string generateReturnType( std::vector<size_t> const &               returnParams,\n                                  std::map<size_t, VectorParamData> const & vectorParams,\n                                  CommandFlavourFlags                       flavourFlags,\n                                  bool                                      raii,\n                                  std::vector<std::string> const &          dataTypes ) const;\n  std::string generateReturnVariable( CommandData const &                       commandData,\n                                      std::vector<size_t> const &               returnParams,\n                                      std::map<size_t, VectorParamData> const & vectorParams,\n                                      CommandFlavourFlags                       flavourFlags ) const;\n  std::string\n    generateSizeCheck( std::vector<std::vector<MemberData>::const_iterator> const & arrayIts, std::string const & structName, bool mutualExclusiveLens ) const;\n  std::string generateStaticAssertions() const;\n  std::string generateStaticAssertions( std::vector<RequireData> const & requireData, std::string const & title, std::set<std::string> & listedStructs ) const;\n  std::string generateStruct( std::pair<std::string, StructureData> const & structure, std::set<std::string> & listedStructs ) const;\n  std::string generateStructCompareOperators( std::pair<std::string, StructureData> const & structure ) const;\n  std::string generateStructConstructors( std::pair<std::string, StructureData> const & structData ) const;\n  std::string generateStructConstructorsEnhanced( std::pair<std::string, StructureData> const & structData ) const;\n  std::string generateStructConstructorArgument( MemberData const & memberData, bool withDefault ) const;\n  std::string generateStructHashStructure( std::pair<std::string, StructureData> const & structure, std::set<std::string> & listedStructs ) const;\n  std::string generateStructHashStructures() const;\n  std::string generateStructHashSum( std::string const & structName, std::vector<MemberData> const & members ) const;\n  std::string generateStructs() const;\n  std::string generateStructure( std::pair<std::string, StructureData> const & structure ) const;\n  std::string generateStructExtendsStructs() const;\n  std::string\n    generateStructExtendsStructs( std::vector<RequireData> const & requireData, std::set<std::string> & listedStructs, std::string const & title ) const;\n  std::string generateStructForwardDeclarations() const;\n  std::string\n    generateStructForwardDeclarations( std::vector<RequireData> const & requireData, std::string const & title, std::set<std::string> & listedStructs ) const;\n  std::tuple<std::string, std::string, std::string, std::string> generateStructMembers( std::pair<std::string, StructureData> const & structData ) const;\n  std::string                         generateStructSetter( std::string const & structureName, std::vector<MemberData> const & memberData, size_t index ) const;\n  std::string                         generateStructSubConstructor( std::pair<std::string, StructureData> const & structData ) const;\n  std::string                         generateSuccessCheck( std::vector<std::string> const & successCodes ) const;\n  std::string                         generateSuccessCode( std::string const & code ) const;\n  std::string                         generateSuccessCodeList( std::vector<std::string> const & successCodes, bool enumerating ) const;\n  std::string                         generateThrowResultException() const;\n  std::string                         generateTypenameCheck( std::vector<size_t> const &               returnParams,\n                                                             std::map<size_t, VectorParamData> const & vectorParams,\n                                                             std::vector<size_t> const &               chainedReturnParams,\n                                                             bool                                      definition,\n                                                             std::vector<std::string> const &          dataTypes,\n                                                             CommandFlavourFlags                       flavourFlags ) const;\n  std::string                         generateUnion( std::pair<std::string, StructureData> const & structure ) const;\n  std::string                         generateUniqueHandle( std::pair<std::string, HandleData> const & handleData ) const;\n  std::string                         generateUniqueHandle( std::vector<RequireData> const & requireData, std::string const & title ) const;\n  std::string                         generateUniqueHandles() const;\n  std::string                         generateSharedHandle( std::pair<std::string, HandleData> const & handleData ) const;\n  std::string                         generateSharedHandle( std::vector<RequireData> const & requireData, std::string const & title ) const;\n  std::string                         generateSharedHandleNoDestroy( std::pair<std::string, HandleData> const & handleData ) const;\n  std::string                         generateSharedHandleNoDestroy( std::vector<RequireData> const & requireData, std::string const & title ) const;\n  std::string                         generateSharedHandles() const;\n  std::string                         generateSharedHandlesNoDestroy() const;\n  std::string                         generateVectorSizeCheck( std::string const &                           name,\n                                                               CommandData const &                           commandData,\n                                                               size_t                                        initialSkipCount,\n                                                               std::map<size_t, std::vector<size_t>> const & countToVectorMap,\n                                                               std::set<size_t> const &                      skippedParams,\n                                                               bool                                          onlyThrows ) const;\n  std::pair<std::string, std::string> getParentTypeAndName( std::pair<std::string, HandleData> const & handle ) const;\n  std::string                         getPlatform( std::string const & title ) const;\n  std::pair<std::string, std::string> getPoolTypeAndName( std::string const & type ) const;\n  std::string                         getProtectFromPlatform( std::string const & platform ) const;\n  std::string                         getProtectFromTitle( std::string const & title ) const;\n  std::string                         getProtectFromTitles( std::set<std::string> const & titles ) const;\n  std::string                         getProtectFromType( std::string const & type ) const;\n  std::string                         getVectorSize( std::vector<ParamData> const &            params,\n                                                     std::map<size_t, VectorParamData> const & vectorParamIndices,\n                                                     size_t                                    returnParam,\n                                                     std::string const &                       returnParamType,\n                                                     std::set<size_t> const &                  templatedParams ) const;\n  void                                handleRemoval( RemoveData const & removeData );\n  bool                                handleRemovalCommand( std::string const & command, std::vector<RequireData> & requireData );\n  void                                handleRemovals();\n  bool                                handleRemovalType( std::string const & type, std::vector<RequireData> & requireData );\n  bool                                hasArrayConstructor( HandleData const & handleData ) const;\n  bool                                hasLen( MemberData const & md, std::vector<MemberData> const & members ) const;\n  bool                                hasParentHandle( std::string const & handle, std::string const & parent ) const;\n  bool isConstructorCandidate( std::pair<std::string, VulkanHppGenerator::CommandData> const & command, std::string const & handleType ) const;\n  bool isConstructorCandidate( ParamData const & paramData, std::string const & handleType ) const;\n  bool isDeviceCommand( CommandData const & commandData ) const;\n  bool isExtension( std::string const & name ) const;\n  bool isFeature( std::string const & name ) const;\n  bool isHandleType( std::string const & type ) const;\n  bool isHandleTypeByStructure( std::string const & type ) const;\n  bool isLenByStructMember( std::string const & name, std::vector<ParamData> const & params ) const;\n  bool isLenByStructMember( std::string const & name, ParamData const & param ) const;\n  bool isMultiSuccessCodeConstructor( std::vector<std::map<std::string, CommandData>::const_iterator> const & constructorIts ) const;\n  bool isParam( std::string const & name, std::vector<ParamData> const & params ) const;\n  bool isStructMember( std::string const & name, std::vector<MemberData> const & memberData ) const;\n  bool isStructureChainAnchor( std::string const & type ) const;\n  bool isStructureType( std::string const & type ) const;\n  bool isSupported( std::set<std::string> const & requiredBy ) const;\n  bool isSupportedExtension( std::string const & name ) const;\n  bool isSupportedFeature( std::string const & name ) const;\n  bool isTypeRequired( std::string const & type ) const;\n  bool isTypeUsed( std::string const & type ) const;\n  bool isUnsupportedExtension( std::string const & name ) const;\n  bool isUnsupportedFeature( std::string const & name ) const;\n  bool isVectorByStructure( std::string const & type ) const;\n  void markExtendedStructs();\n  bool needsStructureChainResize( std::map<size_t, VectorParamData> const & vectorParams, std::vector<size_t> const & chainedReturnParams ) const;\n  std::pair<bool, std::map<size_t, std::vector<size_t>>> needsVectorSizeCheck( std::vector<ParamData> const &            params,\n                                                                               std::map<size_t, VectorParamData> const & vectorParams,\n                                                                               std::vector<size_t> const &               returnParams,\n                                                                               std::set<size_t> const &                  singularParams,\n                                                                               std::set<size_t> const &                  skippedParams ) const;\n  void                                                   readCommand( tinyxml2::XMLElement const * element );\n  std::pair<bool, ParamData>                             readCommandParam( tinyxml2::XMLElement const * element, std::vector<ParamData> const & params );\n  std::pair<std::string, std::string>                    readCommandProto( tinyxml2::XMLElement const * element );\n  void                                                   readCommands( tinyxml2::XMLElement const * element );\n  void                                                   readEnums( tinyxml2::XMLElement const * element );\n  void                                                   readEnumsConstants( tinyxml2::XMLElement const * element );\n  void                          readEnumsEnum( tinyxml2::XMLElement const * element, std::map<std::string, EnumData>::iterator enumIt );\n  void                          readExtension( tinyxml2::XMLElement const * element );\n  void                          readExtensionRequire( tinyxml2::XMLElement const * element, ExtensionData & extensionData, bool extensionSupported );\n  void                          readExtensions( tinyxml2::XMLElement const * element );\n  void                          readFeature( tinyxml2::XMLElement const * element );\n  void                          readFeatureRequire( tinyxml2::XMLElement const * element, FeatureData & featureData, bool featureSupported );\n  void                          readFormat( tinyxml2::XMLElement const * element );\n  void                          readFormatComponent( tinyxml2::XMLElement const * element, FormatData & formatData );\n  void                          readFormatPlane( tinyxml2::XMLElement const * element, FormatData & formatData );\n  void                          readFormats( tinyxml2::XMLElement const * element );\n  void                          readFormatSPIRVImageFormat( tinyxml2::XMLElement const * element, FormatData & formatData );\n  std::string                   readName( tinyxml2::XMLElement const * elements );\n  std::pair<NameData, TypeInfo> readNameAndType( tinyxml2::XMLElement const * elements );\n  void                          readPlatform( tinyxml2::XMLElement const * element );\n  void                          readPlatforms( tinyxml2::XMLElement const * element );\n  void                          readRegistry( tinyxml2::XMLElement const * element );\n  RemoveData                    readRemoveData( tinyxml2::XMLElement const * element );\n  NameLine                      readRequireCommand( tinyxml2::XMLElement const * element );\n  void                          readRequireEnum(\n                             tinyxml2::XMLElement const * element, std::string const & requiredBy, std::string const & platform, bool supported, RequireData & requireData );\n  RequireFeature           readRequireFeature( tinyxml2::XMLElement const * element );\n  NameLine                 readRequireType( tinyxml2::XMLElement const * element );\n  void                     readSPIRVCapability( tinyxml2::XMLElement const * element );\n  void                     readSPIRVCapabilityEnable( tinyxml2::XMLElement const * element, SpirVCapabilityData & capability );\n  void                     readSPIRVCapabilities( tinyxml2::XMLElement const * element );\n  void                     readSPIRVExtension( tinyxml2::XMLElement const * element );\n  void                     readSPIRVExtensionEnable( tinyxml2::XMLElement const * element );\n  void                     readSPIRVExtensions( tinyxml2::XMLElement const * element );\n  void                     readStructMember( tinyxml2::XMLElement const * element, std::vector<MemberData> & members, bool isUnion );\n  void                     readSync( tinyxml2::XMLElement const * element );\n  void                     readSyncAccess( tinyxml2::XMLElement const * element, std::map<std::string, EnumData>::const_iterator accessFlagBits2It );\n  void                     readSyncAccessEquivalent( tinyxml2::XMLElement const * element, std::map<std::string, EnumData>::const_iterator accessFlagBits2It );\n  void                     readSyncAccessSupport( tinyxml2::XMLElement const * element );\n  void                     readSyncPipeline( tinyxml2::XMLElement const * element );\n  void                     readSyncStage( tinyxml2::XMLElement const * element, std::map<std::string, EnumData>::const_iterator stageFlagBits2It );\n  void                     readSyncStageEquivalent( tinyxml2::XMLElement const * element, std::map<std::string, EnumData>::const_iterator stageFlagBits2It );\n  void                     readSyncStageSupport( tinyxml2::XMLElement const * element );\n  void                     readTag( tinyxml2::XMLElement const * element );\n  void                     readTags( tinyxml2::XMLElement const * element );\n  void                     readTypeBasetype( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void                     readTypeBitmask( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  DefinesPartition         partitionDefines( std::map<std::string, DefineData> const & defines );\n  void                     readTypeDefine( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void                     readTypeEnum( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void                     readTypeFuncpointer( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void                     readTypeHandle( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void                     readTypeInclude( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void                     readTypeRequires( tinyxml2::XMLElement const * element, std::map<std::string, std::string> const & attributes );\n  void                     readTypeStruct( tinyxml2::XMLElement const * element, bool isUnion, std::map<std::string, std::string> const & attributes );\n  void                     readTypes( tinyxml2::XMLElement const * element );\n  void                     readTypesType( tinyxml2::XMLElement const * element );\n  TypeInfo                 readTypeInfo( tinyxml2::XMLElement const * element ) const;\n  void                     readVideoCapabilities( tinyxml2::XMLElement const * element, VideoCodec & videoCodec );\n  void                     readVideoCodec( tinyxml2::XMLElement const * element );\n  void                     readVideoCodecs( tinyxml2::XMLElement const * element );\n  void                     readVideoFormat( tinyxml2::XMLElement const * element, VideoCodec & videoCodec );\n  void                     readVideoProfileMember( tinyxml2::XMLElement const * element, VideoCodec & videoCodec );\n  void                     readVideoProfile( tinyxml2::XMLElement const * element, VideoCodec & videoCodec );\n  void                     readVideoProfiles( tinyxml2::XMLElement const * element, VideoCodec & videoCodec );\n  void                     readVideoFormatProperties( tinyxml2::XMLElement const * element, std::string const & videoCodec, VideoFormat & videoFormat );\n  void                     readVideoRequireCapabilities( tinyxml2::XMLElement const * element, VideoCodec & videoCodec );\n  void                     registerDeleter( std::string const & commandName, CommandData const & commandData );\n  void                     rescheduleRAIIHandle( std::string &                              str,\n                                                 std::pair<std::string, HandleData> const & handle,\n                                                 std::set<std::string> &                    listedHandles,\n                                                 std::set<std::string> const &              specialFunctions ) const;\n  std::vector<std::string> selectCommandsByHandle( std::vector<RequireData> const & requireData,\n                                                   std::set<std::string> const &    handleCommands,\n                                                   std::set<std::string> &          listedCommands ) const;\n  bool                     skipLeadingGrandParent( std::pair<std::string, HandleData> const & handle ) const;\n  std::string              stripPluralS( std::string const & name ) const;\n  std::string              toString( TypeCategory category );\n  MemberData const &       vectorMemberByStructure( std::string const & structureType ) const;\n\nprivate:\n  std::string                         m_api;\n  std::map<std::string, BaseTypeData> m_baseTypes;\n  std::map<std::string, BitmaskData>  m_bitmasks;\n  std::set<std::string>               m_commandQueues;\n  std::map<std::string, CommandData>  m_commands;\n  std::map<std::string, ConstantData> m_constants;\n  std::map<std::string, DefineData>   m_defines;\n  DefinesPartition                    m_definesPartition;  // partition defined macros into mutually-exclusive sets of callees, callers, and values\n  std::map<std::string, std::vector<EnumExtendData>> m_enumExtends;\n  std::map<std::string, EnumData>                    m_enums;\n  std::vector<ExtensionData>                         m_extensions;\n  std::map<std::string, ExternalTypeData>            m_externalTypes;\n  std::vector<FeatureData>                           m_features;\n  std::map<std::string, FormatData>                  m_formats;\n  std::map<std::string, FuncPointerData>             m_funcPointers;\n  std::map<std::string, HandleData>                  m_handles;\n  std::map<std::string, IncludeData>                 m_includes;\n  std::map<std::string, PlatformData>                m_platforms;\n  std::set<std::string>                              m_RAIISpecialFunctions;\n  std::map<std::string, SpirVCapabilityData>         m_spirVCapabilities;\n  std::map<std::string, StructureData>               m_structs;\n  std::vector<std::pair<std::string, NameLine>> m_structsAliases;  // temporary storage for aliases, as they might be listed before the actual struct is listed\n  std::map<std::string, NameLine>               m_syncAccesses;\n  std::map<std::string, NameLine>               m_syncStages;\n  std::map<std::string, TagData>                m_tags;\n  std::map<std::string, TypeData>               m_types;\n  std::vector<ExtensionData>                    m_unsupportedExtensions;\n  std::vector<FeatureData>                      m_unsupportedFeatures;\n  std::string                                   m_version;\n  std::vector<VideoCodec>                       m_videoCodecs;\n  std::string                                   m_vulkanLicenseHeader;\n};\n"
        },
        {
          "name": "XMLHelper.hpp",
          "type": "blob",
          "size": 20.8642578125,
          "content": "// Copyright(c) 2023, NVIDIA CORPORATION. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <map>\n#include <mutex>\n#include <regex>\n#include <set>\n#include <string>\n#include <tinyxml2.h>\n#include <vector>\n\nstruct TypeInfo;\n\nvoid                               checkAttributes( int                                                  line,\n                                                    std::map<std::string, std::string> const &           attributes,\n                                                    std::map<std::string, std::set<std::string>> const & required,\n                                                    std::map<std::string, std::set<std::string>> const & optional );\nvoid                               checkElements( int                                               line,\n                                                  std::vector<tinyxml2::XMLElement const *> const & elements,\n                                                  std::map<std::string, bool> const &               required,\n                                                  std::set<std::string> const &                     optional = {} );\nvoid                               checkForError( bool condition, int line, std::string const & message );\nvoid                               checkForWarning( bool condition, int line, std::string const & message );\nstd::string                        generateCopyrightMessage( std::string const & comment );\nstd::string                        generateStandardArrayWrapper( std::string const & type, std::vector<std::string> const & sizes );\nstd::map<std::string, std::string> getAttributes( tinyxml2::XMLElement const * element );\ntemplate <typename ElementContainer>\nstd::vector<tinyxml2::XMLElement const *>        getChildElements( ElementContainer const * element );\nstd::string                                      readComment( tinyxml2::XMLElement const * element );\nstd::pair<std::vector<std::string>, std::string> readModifiers( tinyxml2::XMLNode const * node );\nTypeInfo                                         readTypeInfo( tinyxml2::XMLElement const * element );\nstd::string                                      replaceWithMap( std::string const & input, std::map<std::string, std::string> replacements );\nstd::string                                      stripPostfix( std::string const & value, std::string const & postfix );\nstd::string                                      stripPrefix( std::string const & value, std::string const & prefix );\nstd::string                                      toCamelCase( std::string const & value, bool keepSeparatedNumbersSeparated = false );\nstd::vector<std::string>                         tokenize( std::string const & tokenString, std::string const & separator );\nstd::string                                      toString( tinyxml2::XMLError error );\nstd::string                                      toUpperCase( std::string const & name );\nstd::string                                      trim( std::string const & input );\nstd::string                                      trimEnd( std::string const & input );\nstd::string                                      trimStars( std::string const & input );\nvoid                                             writeToFile( std::string const & str, std::string const & fileName );\n\nclass SyncedMessageHandler\n{\npublic:\n  void message( std::string const & m )\n  {\n    std::lock_guard<std::mutex> guard( m_messageMutex );\n    std::cout << m;\n  }\n\nprivate:\n  std::mutex m_messageMutex;\n};\n\nSyncedMessageHandler messager;\n\nstruct TypeInfo\n{\n  std::string compose( std::string const & nameSpace, std::string const & prefix_ = \"Vk\" ) const\n  {\n    return prefix + ( prefix.empty() ? \"\" : \" \" ) +\n           ( nameSpace.empty() ? type : ( ( ( type.starts_with( prefix_ ) ) ? ( nameSpace + \"::\" ) : \"\" ) + stripPrefix( type, prefix_ ) ) ) +\n           ( postfix.empty() ? \"\" : \" \" ) + postfix;\n  }\n\n  bool operator==( TypeInfo const & rhs ) const noexcept\n  {\n    return ( prefix == rhs.prefix ) && ( type == rhs.type ) && ( postfix == rhs.postfix );\n  }\n\n  bool operator!=( TypeInfo const & rhs ) const noexcept\n  {\n    return !operator==( rhs );\n  }\n\n  bool operator<( TypeInfo const & rhs ) const noexcept\n  {\n    return ( prefix < rhs.prefix ) || ( ( prefix == rhs.prefix ) && ( ( type < rhs.type ) || ( ( type == rhs.type ) && ( postfix < rhs.postfix ) ) ) );\n  }\n\n  bool isConstPointer() const noexcept\n  {\n    return isPointer() && ( prefix.find( \"const\" ) != std::string::npos );\n  }\n\n  bool isNonConstPointer() const noexcept\n  {\n    return isPointer() && ( prefix.find( \"const\" ) == std::string::npos );\n  }\n\n  bool isPointer() const noexcept\n  {\n    return postfix.find( '*' ) != std::string::npos;\n  }\n\n  bool isValue() const noexcept\n  {\n    return ( ( prefix.find( '*' ) == std::string::npos ) && ( postfix.find( '*' ) == std::string::npos ) );\n  }\n\n  std::string prefix  = {};\n  std::string type    = {};\n  std::string postfix = {};\n};\n\nstruct ExternalTypeData\n{\n  std::string require = {};\n  int         xmlLine = 0;\n};\n\nstruct IncludeData\n{\n  int xmlLine = {};\n};\n\nenum class TypeCategory\n{\n  Bitmask,\n  BaseType,\n  Constant,\n  Define,\n  Enum,\n  ExternalType,\n  FuncPointer,\n  Handle,\n  Include,\n  Struct,\n  Union,\n  Unknown\n};\n\nstruct TypeData\n{\n  TypeCategory          category   = TypeCategory::Unknown;\n  std::set<std::string> requiredBy = {};\n  int                   xmlLine    = {};\n};\n\n// check the validity of an attributes map\n// line       : the line in the xml file where the attributes are listed\n// attributes : the map of name/value pairs of the encountered attributes\n// required   : the required attributes, with a set of allowed values per attribute\n// optional   : the optional attributes, with a set of allowed values per attribute\ninline void checkAttributes( int                                                  line,\n                             std::map<std::string, std::string> const &           attributes,\n                             std::map<std::string, std::set<std::string>> const & required,\n                             std::map<std::string, std::set<std::string>> const & optional )\n{\n  // check if all required attributes are included and if there is a set of allowed values, check if the actual\n  // value is part of that set\n  for ( auto const & r : required )\n  {\n    auto attributesIt = attributes.find( r.first );\n    checkForError( attributesIt != attributes.end(), line, \"missing attribute <\" + r.first + \">\" );\n    if ( !r.second.empty() )\n    {\n      std::vector<std::string> values = tokenize( attributesIt->second, \",\" );\n      for ( auto const & v : values )\n      {\n        checkForError( r.second.find( v ) != r.second.end(), line, \"unexpected attribute value <\" + v + \"> in attribute <\" + attributesIt->first + \">\" );\n      }\n    }\n  }\n  // check if all not required attributes or optional, and if there is a set of allowed values, check if the\n  // actual value is part of that set\n  for ( auto const & a : attributes )\n  {\n    if ( required.find( a.first ) == required.end() )\n    {\n      auto optionalIt = optional.find( a.first );\n      if ( optionalIt == optional.end() )\n      {\n        checkForWarning( false, line, \"unknown attribute <\" + a.first + \">\" );\n        continue;\n      }\n      else if ( !optionalIt->second.empty() )\n      {\n        std::vector<std::string> values = tokenize( a.second, \",\" );\n        for ( auto const & v : values )\n        {\n          checkForWarning(\n            optionalIt->second.find( v ) != optionalIt->second.end(), line, \"unexpected attribute value <\" + v + \"> in attribute <\" + a.first + \">\" );\n        }\n      }\n    }\n  }\n}\n\ninline void checkElements( int                                               line,\n                           std::vector<tinyxml2::XMLElement const *> const & elements,\n                           std::map<std::string, bool> const &               required,\n                           std::set<std::string> const &                     optional )\n{\n  std::map<std::string, size_t> encountered;\n  for ( auto const & e : elements )\n  {\n    std::string value = e->Value();\n    encountered[value]++;\n    checkForWarning(\n      ( required.find( value ) != required.end() ) || ( optional.find( value ) != optional.end() ), e->GetLineNum(), \"unknown element <\" + value + \">\" );\n  }\n  for ( auto const & r : required )\n  {\n    auto encounteredIt = encountered.find( r.first );\n    checkForError( encounteredIt != encountered.end(), line, \"missing required element <\" + r.first + \">\" );\n    // check: r.second (means: required excactly once) => (encouteredIt->second == 1)\n    checkForError( !r.second || ( encounteredIt->second == 1 ),\n                   line,\n                   \"required element <\" + r.first + \"> is supposed to be listed exactly once, but is listed \" + std::to_string( encounteredIt->second ) +\n                     \" times\" );\n  }\n}\n\ninline void checkForError( bool condition, int line, std::string const & message )\n{\n  if ( !condition )\n  {\n    throw std::runtime_error( \"VulkanHppGenerator: Spec error on line \" + std::to_string( line ) + \": \" + message );\n  }\n}\n\ninline void checkForWarning( bool condition, int line, std::string const & message )\n{\n  if ( !condition )\n  {\n    std::cerr << \"VulkanHppGenerator: Spec warning on line \" << std::to_string( line ) << \": \" << message << \"!\" << std::endl;\n  }\n}\n\ninline std::string generateCopyrightMessage( std::string const & comment )\n{\n  std::string copyrightMessage = comment;\n\n  // replace any '\\n' with \"\\n// \"\n  for ( size_t pos = copyrightMessage.find( '\\n' ); pos != std::string::npos; pos = copyrightMessage.find( '\\n', pos + 1 ) )\n  {\n    copyrightMessage.replace( pos, 1, \"\\n// \" );\n  }\n  // remove any trailing spaces\n  copyrightMessage = trimEnd( copyrightMessage );\n\n  // and add a little message on our own\n  copyrightMessage += \"\\n\\n// This header is generated from the Khronos Vulkan XML API Registry.\";\n  return trim( copyrightMessage ) + \"\\n\";\n}\n\ninline std::string generateStandardArrayWrapper( std::string const & type, std::vector<std::string> const & sizes )\n{\n  std::string arrayString = \"VULKAN_HPP_NAMESPACE::ArrayWrapper\" + std::to_string( sizes.size() ) + \"D<\" + type;\n  for ( auto const & size : sizes )\n  {\n    arrayString += \", \" + size;\n  }\n  arrayString += \">\";\n  return arrayString;\n}\n\ninline std::map<std::string, std::string> getAttributes( tinyxml2::XMLElement const * element )\n{\n  assert( element );\n  std::map<std::string, std::string> attributes;\n  for ( auto attribute = element->FirstAttribute(); attribute; attribute = attribute->Next() )\n  {\n    assert( attributes.find( attribute->Name() ) == attributes.end() );\n    attributes[attribute->Name()] = attribute->Value();\n  }\n  return attributes;\n}\n\ntemplate <typename ElementContainer>\ninline std::vector<tinyxml2::XMLElement const *> getChildElements( ElementContainer const * element )\n{\n  std::vector<tinyxml2::XMLElement const *> childElements;\n  for ( tinyxml2::XMLElement const * childElement = element->FirstChildElement(); childElement; childElement = childElement->NextSiblingElement() )\n  {\n    childElements.push_back( childElement );\n  }\n  return childElements;\n}\n\ninline bool isHexNumber( std::string const & name ) noexcept\n{\n  return name.starts_with( \"0x\" ) && ( name.find_first_not_of( \"0123456789ABCDEF\", 2 ) == std::string::npos );\n}\n\ninline bool isNumber( std::string const & name ) noexcept\n{\n  return name.find_first_not_of( \"0123456789\" ) == std::string::npos;\n}\n\ninline std::string readComment( tinyxml2::XMLElement const * element )\n{\n  const int line = element->GetLineNum();\n  checkAttributes( line, getAttributes( element ), {}, {} );\n  checkElements( line, getChildElements( element ), {} );\n  return element->GetText();\n}\n\ninline std::pair<std::vector<std::string>, std::string> readModifiers( tinyxml2::XMLNode const * node )\n{\n  std::vector<std::string> arraySizes;\n  std::string              bitCount;\n  if ( node && node->ToText() )\n  {\n    // following the name there might be some array size\n    std::string value = trim( node->Value() );\n    assert( !value.empty() );\n    if ( value[0] == '[' )\n    {\n      std::string::size_type endPos = 0;\n      while ( endPos + 1 != value.length() )\n      {\n        const std::string::size_type startPos = value.find( '[', endPos );\n        checkForError( startPos != std::string::npos, node->GetLineNum(), \"could not find '[' in <\" + value + \">\" );\n        endPos = value.find( ']', startPos );\n        checkForError( endPos != std::string::npos, node->GetLineNum(), \"could not find ']' in <\" + value + \">\" );\n        checkForError( startPos + 2 <= endPos, node->GetLineNum(), \"missing content between '[' and ']' in <\" + value + \">\" );\n        arraySizes.push_back( value.substr( startPos + 1, endPos - startPos - 1 ) );\n      }\n    }\n    else if ( value[0] == ':' )\n    {\n      bitCount = trim( value.substr( 1 ) );\n    }\n    else\n    {\n      checkForError( ( value[0] == ';' ) || ( value[0] == ')' ), node->GetLineNum(), \"unknown modifier <\" + value + \">\" );\n    }\n  }\n  return std::make_pair( arraySizes, bitCount );\n}\n\ninline TypeInfo readTypeInfo( tinyxml2::XMLElement const * element )\n{\n  TypeInfo                  typeInfo;\n  tinyxml2::XMLNode const * previousSibling = element->PreviousSibling();\n  if ( previousSibling && previousSibling->ToText() )\n  {\n    typeInfo.prefix = trim( previousSibling->Value() );\n  }\n  typeInfo.type                         = element->GetText();\n  tinyxml2::XMLNode const * nextSibling = element->NextSibling();\n  if ( nextSibling && nextSibling->ToText() )\n  {\n    typeInfo.postfix = trimStars( trimEnd( nextSibling->Value() ) );\n  }\n  return typeInfo;\n}\n\ninline std::string replaceWithMap( std::string const & input, std::map<std::string, std::string> replacements )\n{\n  // This will match ${someVariable} and contain someVariable in match group 1\n  std::regex re( R\"(\\$\\{([^\\}]+)\\})\" );\n  auto       it  = std::sregex_iterator( input.begin(), input.end(), re );\n  auto       end = std::sregex_iterator();\n\n  // No match, just return the original string\n  if ( it == end )\n  {\n    assert( replacements.empty() );\n    return input;\n  }\n\n#if !defined( NDEBUG )\n  std::set<std::string> matchedReplacements;\n#endif\n\n  std::string result = \"\";\n  while ( it != end )\n  {\n    std::smatch match         = *it;\n    auto        itReplacement = replacements.find( match[1].str() );\n    assert( itReplacement != replacements.end() );\n#if !defined( NDEBUG )\n    matchedReplacements.insert( match[1].str() );\n#endif\n\n    result += match.prefix().str() + ( ( itReplacement != replacements.end() ) ? itReplacement->second : match[0].str() );\n    ++it;\n\n    // we've passed the last match. Append the rest of the orignal string\n    if ( it == end )\n    {\n      result += match.suffix().str();\n    }\n  }\n#if !defined( NDEBUG )\n  std::set<std::string> missedReplacements;\n  for ( auto r : replacements )\n  {\n    if ( matchedReplacements.find( r.first ) == matchedReplacements.end() )\n    {\n      missedReplacements.insert( r.first );\n    }\n  }\n  assert( missedReplacements.empty() );\n#endif\n  return result;\n}\n\ninline std::string stripPostfix( std::string const & value, std::string const & postfix )\n{\n  std::string strippedValue = value;\n  if ( strippedValue.ends_with( postfix ) )\n  {\n    strippedValue.erase( strippedValue.length() - postfix.length() );\n  }\n  return strippedValue;\n}\n\ninline std::string stripPrefix( std::string const & value, std::string const & prefix )\n{\n  std::string strippedValue = value;\n  if ( strippedValue.starts_with( prefix ) )\n  {\n    strippedValue.erase( 0, prefix.length() );\n  }\n  return strippedValue;\n}\n\ninline std::string toCamelCase( std::string const & value, bool keepSeparatedNumbersSeparated )\n{\n  assert( value.empty() || isupper( value[0] ) || isdigit( value[0] ) );\n  std::string result;\n  result.reserve( value.size() );\n  for ( size_t i = 0; i < value.size(); ++i )\n  {\n    if ( value[i] == '_' )\n    {\n      if ( keepSeparatedNumbersSeparated && ( 0 < i ) && isdigit( value[i - 1] ) && ( i < value.size() - 1 ) && isdigit( value[i + 1] ) )\n      {\n        result.push_back( '_' );\n      }\n    }\n    else\n    {\n      result.push_back( ( ( 0 == i ) || ( value[i - 1] == '_' ) || isdigit( value[i - 1] ) ) ? value[i] : static_cast<char>( tolower( value[i] ) ) );\n    }\n  }\n  return result;\n}\n\ninline std::vector<std::string> tokenize( std::string const & tokenString, std::string const & separator )\n{\n  std::vector<std::string> tokens;\n  if ( !tokenString.empty() )\n  {\n    size_t start = 0, end;\n    do\n    {\n      end = tokenString.find( separator, start );\n      if ( start != end )\n      {\n        tokens.push_back( trim( tokenString.substr( start, end - start ) ) );\n      }\n      start = end + separator.length();\n    } while ( end != std::string::npos );\n  }\n  return tokens;\n}\n\ninline std::string toString( tinyxml2::XMLError error )\n{\n  switch ( error )\n  {\n    case tinyxml2::XML_SUCCESS: return \"XML_SUCCESS\";\n    case tinyxml2::XML_NO_ATTRIBUTE: return \"XML_NO_ATTRIBUTE\";\n    case tinyxml2::XML_WRONG_ATTRIBUTE_TYPE: return \"XML_WRONG_ATTRIBUTE_TYPE\";\n    case tinyxml2::XML_ERROR_FILE_NOT_FOUND: return \"XML_ERROR_FILE_NOT_FOUND\";\n    case tinyxml2::XML_ERROR_FILE_COULD_NOT_BE_OPENED: return \"XML_ERROR_FILE_COULD_NOT_BE_OPENED\";\n    case tinyxml2::XML_ERROR_FILE_READ_ERROR: return \"XML_ERROR_FILE_READ_ERROR\";\n    case tinyxml2::XML_ERROR_PARSING_ELEMENT: return \"XML_ERROR_PARSING_ELEMENT\";\n    case tinyxml2::XML_ERROR_PARSING_ATTRIBUTE: return \"XML_ERROR_PARSING_ATTRIBUTE\";\n    case tinyxml2::XML_ERROR_PARSING_TEXT: return \"XML_ERROR_PARSING_TEXT\";\n    case tinyxml2::XML_ERROR_PARSING_CDATA: return \"XML_ERROR_PARSING_CDATA\";\n    case tinyxml2::XML_ERROR_PARSING_COMMENT: return \"XML_ERROR_PARSING_COMMENT\";\n    case tinyxml2::XML_ERROR_PARSING_DECLARATION: return \"XML_ERROR_PARSING_DECLARATION\";\n    case tinyxml2::XML_ERROR_PARSING_UNKNOWN: return \"XML_ERROR_PARSING_UNKNOWN\";\n    case tinyxml2::XML_ERROR_EMPTY_DOCUMENT: return \"XML_ERROR_EMPTY_DOCUMENT\";\n    case tinyxml2::XML_ERROR_MISMATCHED_ELEMENT: return \"XML_ERROR_MISMATCHED_ELEMENT\";\n    case tinyxml2::XML_ERROR_PARSING: return \"XML_ERROR_PARSING\";\n    case tinyxml2::XML_CAN_NOT_CONVERT_TEXT: return \"XML_CAN_NOT_CONVERT_TEXT\";\n    case tinyxml2::XML_NO_TEXT_NODE: return \"XML_NO_TEXT_NODE\";\n    default: return \"unknown error code <\" + std::to_string( error ) + \">\";\n  }\n}\n\nstd::string toUpperCase( std::string const & name )\n{\n  std::string convertedName;\n  bool        previousIsLowerCase = false;\n  bool        previousIsDigit     = false;\n  for ( auto c : name )\n  {\n    if ( ( isupper( c ) && ( previousIsLowerCase || previousIsDigit ) ) || ( isdigit( c ) && previousIsLowerCase ) )\n    {\n      convertedName.push_back( '_' );\n    }\n    convertedName.push_back( static_cast<char>( toupper( c ) ) );\n    previousIsLowerCase = !!islower( c );\n    previousIsDigit     = !!isdigit( c );\n  }\n  return convertedName;\n}\n\ninline std::string trim( std::string const & input )\n{\n  std::string result = input;\n  result.erase( result.begin(), std::find_if( result.begin(), result.end(), []( char c ) noexcept { return !std::isspace( c ); } ) );\n  result.erase( std::find_if( result.rbegin(), result.rend(), []( char c ) noexcept { return !std::isspace( c ); } ).base(), result.end() );\n  return result;\n}\n\ninline std::string trimEnd( std::string const & input )\n{\n  std::string result = input;\n  result.erase( std::find_if( result.rbegin(), result.rend(), []( char c ) noexcept { return !std::isspace( c ); } ).base(), result.end() );\n  return result;\n}\n\ninline std::string trimStars( std::string const & input )\n{\n  std::string result = input;\n  size_t      pos    = result.find( '*' );\n  while ( pos != std::string::npos )\n  {\n    if ( ( 0 < pos ) && ( result[pos - 1] != ' ' ) && ( result[pos - 1] != '*' ) )\n    {\n      result.insert( pos, 1, ' ' );\n      ++pos;\n    }\n    else if ( ( pos < result.length() - 1 ) && ( result[pos + 1] != ' ' ) && ( result[pos + 1] != '*' ) )\n    {\n      result.insert( pos + 1, 1, ' ' );\n    }\n    pos = result.find( '*', pos + 1 );\n  }\n  return result;\n}\n\nvoid writeToFile( std::string const & str, std::string const & fileName )\n{\n  std::ofstream ofs( fileName );\n  assert( !ofs.fail() );\n  ofs << str;\n  ofs.close();\n\n#if defined( CLANG_FORMAT_EXECUTABLE )\n  messager.message( \"VulkanHppGenerator: Formatting \" + fileName + \" ...\\n\" );\n  const std::string commandString = \"\\\"\" CLANG_FORMAT_EXECUTABLE \"\\\" -i --style=file \" + fileName;\n  const int         ret           = std::system( commandString.c_str() );\n  if ( ret != 0 )\n  {\n    messager.message( \"VulkanHppGenerator: failed to format file \" + fileName + \" with error <\" + std::to_string( ret ) + \">\\n\" );\n  }\n#endif\n}\n"
        },
        {
          "name": "glfw",
          "type": "commit",
          "content": null
        },
        {
          "name": "glm",
          "type": "commit",
          "content": null
        },
        {
          "name": "glslang",
          "type": "commit",
          "content": null
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "snippets",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tinyxml2",
          "type": "commit",
          "content": null
        },
        {
          "name": "vk_raii_ProgrammingGuide.md",
          "type": "blob",
          "size": 27.404296875,
          "content": "\n\n# vulkan_raii.hpp: a programming guide\n\n## Introduction\n\nvulkan_raii.hpp is a C++ layer on top of vulkan.hpp that follows the RAII-principle (RAII: Resource Acquisition Is Initialization, see [https://en.cppreference.com/w/cpp/language/raii#:~:text=Resource%20Acquisition%20Is%20Initialization%20or,in%20limited%20supply](https://en.cppreference.com/w/cpp/language/raii#:~:text=Resource%20Acquisition%20Is%20Initialization%20or,in%20limited%20supply)). This header-only library uses all the enums and structure wrappers from vulkan.hpp and provides a new set of wrapper classes for the Vulkan handle types. Instead of creating Vulkan handles with vk*Allocate or vk*Create a constructor of the corresponding Vulkan handle wrapper class is used. And instead of destroying Vulkan handles with vk*Free or vk*Destroy, the destructor of that handle class is called.\n\n## General Usage\n\nAs a simple example, instead of creating a `vk::Device`\n\n    // create a vk::Device, given a vk::PhysicalDevice physicalDevice and a vk::DeviceCreateInfo deviceCreateInfo\n    vk::Device device = physicalDevice.createDevice( deviceCreateInfo );\n\nand destroying it at some point\n\n    // destroy a vk::Device\n    device.destroy();\n\nyou would create a `vk::raii::Device`\n\n    // create a vk::raii::Device, given a vk::raii::PhysicalDevice physicalDevice and a vk::DeviceCreateInfo deviceCreateInfo\n    vk::raii::Device device( physicalDevice, deviceCreateInfo );\n\nThat `vk::raii::Device` is automatically destroyed, when its scope is left.\n\nAlternatively, you can use a creation function to create a `vk::raii::Device`:\n\n    // create a vk::raii::Device, given a vk::raii::PhysicalDevice physicalDevice and a vk::DeviceCreateInfo deviceCreateInfo\n    vk::raii::Device device = physicalDevice.createDevice( deviceCreateInfo );\n\nFinally, if you have defined `VULKAN_HPP_NO_EXCEPTIONS` and compile for at least C++23, the constructors as described above are not available (they would potentially throw an exception which is not allowed then) but you have to use the construction functions. Those functions then do not return the created object, but a `std::expected<vk::raii::Object, vk::Result>`:\n\n    // create a vk::raii::Device, given a vk::raii::PhysicalDevice physicalDevice and a vk::DeviceCreateInfo deviceCreateInfo\n\t// when VULKAN_HPP_NO_EXCEPTIONS is defined and your using at least C++23\n\tauto deviceExpected = physicalDevice.createDevice( deviceCreateInfo );\n\tif ( deviceExpected.has_value() )\n\t{\n\t\tdevice = std::move( *deviceExpected );\n\t}\n\nIn the code snippets in this text, I will consistently use the constructor-approach.\n\n\nOther than the `vk::Device`, you can assign the `vk::raii::Device` to a smart pointer:\n\n    // create a smart-pointer to a vk::raii::Device, given a smart-pointer to a vk::raii::PhysicalDevice pPhysicalDevice and a vk::DeviceCreateInfo deviceCreateInfo\n    std::unique_ptr<vk::raii::Device> pDevice;\n    pDevice = std::make_unique<vk::raii::Device>( *pPhysicalDevice, deviceCreateInfo );\n\nNote that the vk::raii objects own the actual Vulkan resource. Therefore, all vk::raii objects that own destructable resources are just movable, but not copyable. Therefore, a few vk::raii objects, like vk::raii::PhysicalDevice are copyable as well.\n\nFor simplicity, in the rest of this document a vk::raii object is always directly instantiated on the stack. Obviously, that's not essential. You could assign them as well to a std::unique_ptr, a std::shared_ptr, or any other smart pointer or object managing data structure. And you can even assign them to a dumb pointer by using the new operator.\n\nSimilar to a `vk::Device`, a `vk::raii::Device` provides the functions related to that class. But other than the `vk::Device`, you don't need to provide a device-specific dispatcher to those functions to get multi-device functionality. That's already managed by the `vk::raii::Device`.\n\nThat is, calling a device-related function is identical for both cases:\n\n    // call waitIdle from a vk::Device\n    device.waitIdle();\n\n    // call waitIdle from a vk::raii::Device\n    device.waitIdle();\n\nvk::raii goes one step further. In the vk namespace, most of the functions are members of `vk::Device`. In the vk::raii namespace functions strongly related to a non-dispatchable handle are members of the corresponding vi::raii object. For example, to bind memory to a buffer, in vk namespace you write\n\n    // bind vk::DeviceMemory memory to a vk::Buffer buffer, given vk::DeviceSize memoryOffset\n    device.bindBufferMemory( buffer, memory, memoryOffset );\n\nIn vk::raii namespace you write\n\n    // bind vk::raii::DeviceMemory memory to a vk::raii::Buffer buffer, given vk::DeviceSize memoryOffset\n    buffer.bindMemory( *memory, memoryOffset );\n    \nNote that `vk::raii::Buffer::bindMemory()`takes a `vk::DeviceMemory` as its first argument, not a `vk::raii::DeviceMemory`. From a vk::raii object you get to the corresponding vk object by just dereferencing the vk::raii object.\n\n## First Steps\n\n### 00 Create a vk::raii::Context\n\nThe very first step when using classes from the vk::raii namespace is to instantiate a `vk::raii::Context`. This class has no counterpart in either the vk namespace or the pure C-API of Vulkan. It is the handle to the few functions that are not bound to a `VkInstance` or a `VkDevice`:\n\n    // instantiate a vk::raii::Context\n    vk::raii::Context context;\n\nTo use any of those \"global\" functions, your code would look like that:\n\n    // get the API version, using that context\n    uint32_t apiVersion = context.enumerateInstanceVersion();\n\n### 01 Create a vk::raii::Instance\n\nTo pass that information on to a `vk::raii::Instance`, its constructor gets a reference to that `vk::raii::Context`:\n\n    // instantiate a vk::raii::Instance, given a vk::raii::Context context and a vk::InstanceCreateInfo instanceCreateInfo\n    vk::raii::Instance instance( context, instanceCreateInfo );\n\nThe `vk::raii::Instance` now holds all the instance-related functions. For example, to get all the `vk::PhysicalDeviceGroupProperties` for an instance, your call would look like this:\n\n    // get all vk::PhysicalDeviceGroupProperties from a vk::raii::Instance instance\n    std::vector<vk::PhysicalDeviceGroupProperties> physicalDeviceGroupProperties = instance.enumeratePhysicalDeviceGroups();\n\n### 02 Enumerate the vk::raii::PhysicalDevices\n\nEnumerating the physical devices of an instance is slightly different in vk::raii namespace as you might be used to from the vk-namespace or the pure C-API. As there might be multiple physical devices attached, you would instantiate a `vk::raii::PhysicalDevices` (note the trailing 's' here!), which essentially is a `std::vector` of `vk::raii::PhysicalDevice`s (note the trailing 's' here!):\n\n    // enumerate the vk::raii::PhysicalDevices, given a vk::raii::Instance instance\n    vk::raii::PhysicalDevices physicalDevices( instance );\n\nAs vk::raii::PhysicalDevices is just a `std::vector<vk::raii::PhysicalDevice>`, you can access any specific `vk::raii:PhysicalDevice` by indexing into that `std::vector`:\n\n    // get the vk::LayerProperties of the vk::raii::PhysicalDevice with index physicalDeviceIndex, given a vk::raii::PhysicalDevices physicalDevices\n    std::vector<vk::LayerProperties> layerProperties = physicalDevices[physicalDeviceIndex].enumerateDeviceLayerProperties();\n\nYou can as well get one `vk::raii::PhysicalDevice` out of a `vk::raii::PhysicalDevices` like this:\n\n    // get the vk::raii::PhysicalDevice with index physicalDeviceIndex, given a vk::raii::PhysicalDevices physicalDevices object:\n    vk::raii::PhysicalDevice physicalDevice( std::move( physicalDevices[physicalDeviceIndex] ) );\n\nNote, that even though the actual `VkPhysicalDevice` owned by a `vk::raii::PhysicalDevice` is not a destructible resource, for consistency reasons a `vk::raii::PhysicalDevice` is a movable but not copyable object just like all the other vk::raii objects.\n\n### 03 Create a vk::raii::Device\n\nTo create a `vk::raii::Device`, you just instantiate an object of that class:\n\n    // create a vk::raii::Device, given a vk::raii::PhysicalDevice physicalDevice and a vk::DeviceCreateInfo deviceCreateInfo\n    vk::raii::Device device( physicalDevice, deviceCreateInfo );\n\nFor each instantiated `vk::raii::Device`, the device-specific Vulkan function pointers are resolved. That is, for multi-device programs, you automatically use the correct device-specific function pointers, and organizing a multi-device program is simplified:\n\n    // create a vk::raii::Device per vk::raii::PhysicalDevice, given a vk::raii::PhysicalDevices physicalDevices, and a corresponding array of vk::DeviceCreateInfo deviceCreateInfos\n    std::vector<vk::raii::Device> devices;\n    for ( size_t i = 0; i < physicalDevices.size(); i++ )\n    {\n      devices.push_back( vk::raii::Device( physicalDevices[i], deviceCreateInfos[i] ) );\n    }\n\n### 04 Create a vk::raii::CommandPool and vk::raii::CommandBuffers\n\nCreating a `vk::raii::CommandPool` is simply done by instantiating such an object:\n\n    // create a vk::raii::CommandPool, given a vk::raii::Device device and a vk::CommandPoolCreateInfo commandPoolCreateInfo\n    vk::raii::CommandPool commandPool( device, commandPoolCreateInfo );\n\nAs the number of `vk::raii::CommandBuffer`s to allocate from a `vk::raii::CommandPool` is given by the member `commandBufferCount` of a `vk::CommandBufferAllocateInfo` structure, it can't be instantiated as a single object. Instead you get a `vk::raii::CommandBuffers` (note the trailing 's' here!), which essentially is a `std::vector` of `vk::raii::CommandBuffer`s (note the trailing 's' here!).\n\n    // create a vk::raii::CommandBuffers, given a vk::raii::Device device and a vk::CommandBufferAllocateInfo commandBufferAllocateInfo\n    vk::raii::CommandBuffers commandBuffers( device, commandBufferAllocateInfo );\n\nNote, that the `vk::CommandBufferAllocateInfo` holds a `vk::CommandPool` member `commandPool`. To assign that from a `vk::raii::CommandPool` you can use the `operator*()`:\n\n    // assign vk::CommandBufferAllocateInfo::commandPool, given a vk::raii::CommandPool commandPool\n    commandBufferAllocateInfo.commandPool = *commandPool;\n\nAs a `vk::raii::CommandBuffers` is just a `std::vector<vk::raii::CommandBuffer>`, you can access any specific `vk::raii:CommandBuffer` by indexing into that `std::vector`:\n\n    // start recording of the vk::raii::CommandBuffer with index commandBufferIndex, given a vk::raii::CommandBuffers commandBuffers\n    commandBuffers[commandBufferIndex].begin();\n\nYou can as well get one `vk::raii::CommandBuffer` out of a `vk::raii::CommandBuffers` like this:\n\n    // get the vk::raii::CommandBuffer with index commandBufferIndex, given a vk::raii::CommandBuffers commandBuffers\n    vk::raii::CommandBuffer commandBuffer( std::move( commandBuffers[commandBufferIndex] ) );\n\n    // start recording\n    commandBuffer.begin();\n\nThere is one important thing to note, regarding command pool and command buffer handling. When you destroy a `VkCommandPool`, all `VkCommandBuffer`s allocated from that pool are implicitly freed. That automatism does not work well with the raii-approach. As the `vk::raii::CommandBuffers` are independent objects, they are not automatically destroyed when the `vk::raii::CommandPool` they are created from is destroyed. Instead, their destructor would try to use an invalid `vk::raii::CommandPool`, which obviously is an error.\n\nTo handle that correctly, you have to make sure, that all `vk::raii::CommandBuffers` generated from a `vk::raii::CommandPool` are explicitly destroyed before that `vk::raii::CommandPool` is destroyed!\n\n### 05 Create a vk::raii::SwapchainKHR\n\nTo initialize a swap chain, you first instantiate a `vk::raii::SwapchainKHR`:\n\n    // create a vk::raii::SwapchainKHR, given a vk::raii::Device device and a vk::SwapchainCreateInfoKHR swapChainCreateInfo\n    vk::raii::SwapchainKHR swapchain( device, swapChainCreateInfo );\n\nYou can get an array of presentable images associated with that swap chain:\n\n    // get presentable images associated with vk::raii::SwapchainKHR swapchain\n    std::vector<VkImage> images = swapchain.getImages();\n\nNote, that you don't get `vk::raii::Image`s here, but plain `VkImage`s. They are controlled by the swap chain, and you should not destroy them.\n\nBut you can create `vk::raii::ImageView`s out of them:\n\n    // create a vk::raii::ImageView per VkImage, given a vk::raii::Device sevice, a vector of VkImages images and a vk::ImageViewCreateInfo imageViewCreateInfo\n    std::vector<vk::raii::ImageView> imageViews;\n    for ( auto image : images )\n    {\n      imageViewCreatInfo.image = image;\n      imageViews.push_back( vk::raii::ImageView( device, imageViewCreateInfo ) );\n    }\n\n### 06 Create a Depth Buffer\n\nFor a depth buffer, you need an image and some device memory and bind the memory to that image. That is, you first create a vk::raii::Image\n\n    // create a vk::raii::Image image, given a vk::raii::Device device and a vk::ImageCreateInfo imageCreateInfo\n    // imageCreateInfo.usage should hold vk::ImageUsageFlagBits::eDepthStencilAttachment\n    vk::raii::Image depthImage( device, imageCreateInfo );\n\nTo create the corresponding vk::raii::DeviceMemory, you should determine appropriate values for the vk::MemoryAllocateInfo. That is, get the memory requirements from the pDepthImage, and determine some memoryTypeIndex from the pPhysicalDevice's memory properties, requiring vk::MemoryPropertyFlagBits::eDeviceLocal.\n\n    // get the vk::MemoryRequirements of the pDepthImage\n    vk::MemoryRequirements memoryRequirements = depthImage.getMemoryRequirements();\n\n    // determine appropriate memory type index, using some helper function determineMemoryTypeIndex\n    vk::PhysicalDeviceMemoryProperties memoryProperties = physicalDevice.getMemoryProperties();\n    uint32_t memoryTypeIndex = determineMemoryTypeIndex( memoryProperties, memoryRequirements.memoryTypeBits, vk::MemoryPropertyFlagBits::eDeviceLocal );\n\n    // create a vk::raii::DeviceMemory depthDeviceMemory for the depth buffer\n    vk::MemoryAllocateInfo memoryAllocateInfo( memoryRequirements.size, memoryTypeIndex );\n    vk::raii::DeviceMemory depthDeviceMemory( device, memoryAllocateInfo );\n\nThen you can bind the depth memory to the depth image\n\n    // bind the pDepthMemory to the pDepthImage\n    depthImage.bindMemory( *depthDeviceMemory, 0 );\n\nFinally, you can create an image view on that depth buffer image\n\n    // create a vk::raii::ImageView depthView, given a vk::ImageViewCreateInfo imageViewCreateInfo\n    imageViewCreateInfo.image = *depthImage;\n    vk::raii::ImageView depthImageView( device, imageViewCreateInfo );\n\n### 07 Create a Uniform Buffer\n\nInitializing a uniform buffer is very similar to initializing a depth buffer as described above. You just instantiate a `vk::raii::Buffer` instead of a `vk::raii::Image`, and a `vk::raii::DeviceMemory`, and bind the memory to the buffer:\n\n    // create a vk::raii::Buffer, given a vk::raii::Device device and a vk::BufferCreateInfo bufferCreateInfo\n    vk::raii::Buffer uniformBuffer( device, bufferCreateInfo );\n\n    // get memoryRequirements for this uniform buffer\n    vk::MemoryRequirements memoryRequirements = uniformBuffer.getMemoryRequirements();\n\n    // determine appropriate memory type index, using some helper function, given a vk::raii::PhysicalDevice physicalDevice and some memoryPropertyFlags\n    vk::PhysicalDeviceMemoryProperties memoryProperties = physicalDevice.getMemoryProperties();\n    uint32_t memoryTypeIndex = determineMemoryTypeIndex( memoryProperties, memoryRequirements.memoryTypeBits, memoryPropertyFlags );\n    \n    // create a vk::raii::DeviceMemory uniformDeviceMemory for the uniform buffer\n    vk::MemoryAllocateInfo memoryAllocateInfo( memoryRequirements.size, memoryTypeIndex );\n    vk::raii::DeviceMemory uniformDeviceMemory( device, memoryAllocateInfo );\n    \n    // bind the vk::raii::DeviceMemory uniformDeviceMemory to the vk::raii::Buffer uniformBuffer\n    uniformBuffer.bindMemory( *uniformDeviceMemory, 0 );\n\n### 08 Create a vk::raii::PipelineLayout\n\nTo initialize a Pipeline Layout you just have to instantiate a `vk::raii::DescriptorSetLayout` and a `vk::raii::PipelineLayout` using that `vk::raii::DescriptorSetLayout`:\n\n    // create a vk::raii::DescriptorSetLayout, given a vk::raii::Device device and a vk::DescriptorSetLayoutCreateInfo descriptorSetLayoutCreateInfo\n    vk::raii::DescriptorSetLayout descriptorSetLayout( device, descriptorSetLayoutCreateInfo );\n\n    // create a vk::raii::PipelineLayout, given a vk::raii::Device device and a vk::raii::DescriptorSetLayout\n    vk::PipelineLayoutCreateInfo pipelineLayoutCreateInfo( {}, *descriptorSetLayout );\n    vk::raii::PipelineLayout pipelineLayout( device, pipelineLayoutCreateInfo );\n\n### 09 Create a vk::raii::DescriptorPool and vk::raii::DescriptorSets\n\nThe Descriptor Set handling with `vk::raii` requires some special handling that is not needed when using the pure C-API or the vk-namespace!\n\nAs a `vk::raii::DescriptorSet` object destroys itself in the destructor, you have to instantiate the corresponding `vk::raii::DescriptorPool` with the `vk::DescriptorPoolCreateInfo::flags` set to (at least) `vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet`. Otherwise, such individual destruction of a `vk::raii::DescriptorSet` would not be allowed!\n\nThat is, an instantiation of a `vk::raii::DescriptorPool` would look like this:\n\n    // create a vk::raii::DescriptorPool, given a vk::raii::Device device and a vk::DescriptorPoolCreateInfo descriptorPoolCreateInfo\n    assert( descriptorPoolCreateInfo.flags & vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet );\n    vk::raii::DescriptorPool descriptorPool( device, descriptorPoolCreateInfo );\n\nTo actually instantiate a `vk::raii::DescriptorSet`, you need a `vk::raii::DescriptorPool`, as just described, and a `vk::raii::DescriptorSetLayout`, similar to the one described in the previous section.\n\nMoreover, as the number of `vk::raii::DescriptorSet`s to allocate from a `vk::raii::DescriptorPool` is given by the number of `vk::DescriptorSetLayouts` held by a `vk::DescriptorSetAllocateInfo`, it can't be instantiated as a single object. Instead you get a `vk::raii::DescriptorSets` (note the trailing 's' here!), which essentially is a `std::vector` of `vk::raii::DescriptorSet`s (note the trailing 's' here!).\n\nWhen you want to create just one `vk::raii::DescriptorSet`, using just one `vk::raii::DescriptorSetLayout`, your code might look like this:\n\n    // create a vk::raii::DescriptorSets, holding a single vk::raii::DescriptorSet, given a vk::raii::Device device, a vk::raii::DescriptorPool descriptorPool, and a single vk::raii::DescriptorSetLayout descriptorSetLayout\n    vk::DescriptorSetAllocateInfo descriptorSetAllocateInfo( *descriptorPool, *descriptorSetLayout );\n    vk::raii::DescriptorSets pDescriptorSets( device, descriptorSetAllocateInfo );\n\nAnd, again similar to the vk::raii::CommandBuffers handling described above, you can get one `vk::raii::DescriptorSet` out of a `vk::raii::DescriptorSets` like this:\n\n    // get the vk::raii::DescriptorSet with index descriptorSetIndex, given a vk::raii::DescriptorSets descriptorSets\n    vk::raii::DescriptorSet descriptorSet( std::move( descriptorSets[descriptorSetIndex] ) );\n\n### 10 Create a vk::raii::RenderPass\n\nCreating a `vk::raii::RenderPass` is pretty simple, given you already have a meaningful `vk::RenderPassCreateInfo`:\n\n    // create a vk::raii::RenderPass, given a vk::raii::Device device and a vk::RenderPassCreateInfo renderPassCreateInfo\n    vk::raii::RenderPass renderPass( device, renderPassCreateInfo );\n\n### 11 Create a vk::raii::ShaderModule\n\nAgain, creating a `vk::raii::ShaderModule` is simple, given a `vk::ShaderModuleCreateInfo` with some meaningful code:\n\n    // create a vk::raii::ShaderModule, given a vk::raii::Device device and a vk::ShaderModuleCreateInfo shaderModuleCreateInfo\n    vk::raii::ShaderModule shaderModule( device, shaderModuleCreateInfo );\n\n### 12 Create vk::raii::Framebuffers\n\nIf you have a `std::vector<vk::raii::ImageView>` as described in chapter 05 above, with one view per `VkImage` that you got from a `vk::raii::SwapchainKHR`; and one `vk::raii::ImageView` as described in chapter 06 above, which is a view on a `vk::raii::Image`, that is supposed to be a depth buffer, you can create a `vk::raii::Framebuffer` per swapchain image.\n\n    // create a vector of vk::raii::Framebuffer, given a vk::raii::ImageView depthImageView, a vector of vk::raii::ImageView swapchainImageViews, a vk::raii::RenderPass renderPass, a vk::raii::Devie device, and some width and height\n    // use the depth image view as the second attachment for each vk::raii::Framebuffer\n    std::array<vk::ImageView, 2> attachments;\n    attachments[1] = *depthImageView;\n    std::vector<vk::raii::Framebuffer> framebuffers;\n    for ( auto const & imageView : swapchainImageViews )\n    {\n      // use each image view from the swapchain as the first attachment\n      attachments[0] = *imageView;\n      vk::FramebufferCreateInfo framebufferCreateInfo( {}, *renderPass, attachments, width, height, 1 );\n      framebuffers.push_back( vk::raii::Framebuffer( device, framebufferCreateInfo ) );\n    }\n\n### 13 Initialize a Vertex Buffer\n\nTo initialize a vertex buffer, you essentially have to combine some of the pieces described in the chapters before. First, you need to create a `vk::raii::Buffer` and a `vk::raii::DeviceMemory` and bind them:\n\n    // create a vk::raii::Buffer vertexBuffer, given a vk::raii::Device device and some vertexData in host memory\n    vk::BufferCreateInfo bufferCreateInfo( {}, sizeof( vertexData ), vk::BufferUsageFlagBits::eVertexBuffer );\n    vk::raii::Buffer vertexBuffer( device, bufferCreateInfo );\n\n    // create a vk::raii::DeviceMemory vertexDeviceMemory, given a vk::raii::Device device and a uint32_t memoryTypeIndex\n    vk::MemoryRequirements memoryRequirements = vertexBuffer.getMemoryRequirements();\n    vk::MemoryAllocateInfo memoryAllocateInfo( memoryRequirements.size, memoryTypeIndex );\n    vk::raii::DeviceMemory vertexDeviceMemory( device, memoryAllocateInfo );\n\n    // bind the complete device memory to the vertex buffer\n    vertexBuffer.bindMemory( *vertexDeviceMemory, 0 );\n\n    // copy the vertex data into the vertexDeviceMemory\n    ...\n\nLater on, you can bind that vertex buffer to a command buffer:\n\n    // bind a complete single vk::raii::Buffer vertexBuffer as a vertex buffer, given a vk::raii::CommandBuffer commandBuffer\n    commandBuffer.bindVertexBuffer( 0, { *vertexBuffer }, { 0 } );\n\n### 14 Initialize a Graphics Pipeline\n\nInitializing a graphics pipeline is not very raii-specific. Just instantiate it, provided you have a valid vk::GraphicsPipelineCreateInfo:\n\n    // create a vk::raii::Pipeline, given a vk::raii::Device device and a vk::GraphicsPipelineCreateInfo graphicsPipelineCreateInfo\n    vk::raii::Pipeline graphicsPipeline( device, graphicsPipelineCreateInfo );\n\nThe only thing to keep in mind here is the dereferencing of raii handles, like `pipelineLayout` or `renderPass` in the `vk::GraphicsPipelineCreateInfo`:\n\n    vk::GraphicsPipelineCreateInfo graphicsPipelineCreateInfo(\n      {},                                    // flags\n      pipelineShaderStageCreateInfos,        // stages\n      &pipelineVertexInputStateCreateInfo,   // pVertexInputState\n      &pipelineInputAssemblyStateCreateInfo, // pInputAssemblyState\n      nullptr,                               // pTessellationState\n      &pipelineViewportStateCreateInfo,      // pViewportState\n      &pipelineRasterizationStateCreateInfo, // pRasterizationState\n      &pipelineMultisampleStateCreateInfo,   // pMultisampleState\n      &pipelineDepthStencilStateCreateInfo,  // pDepthStencilState\n      &pipelineColorBlendStateCreateInfo,    // pColorBlendState\n      &pipelineDynamicStateCreateInfo,       // pDynamicState\n      *pipelineLayout,                       // layout\n      *renderPass                            // renderPass\n    );\n\n### 15 Drawing a Cube\n\nFinally, we get all those pieces together and draw a cube.\n\nTo do so, you need a `vk::raii::Semaphore`:\n\n    // create a vk::raii::Semaphore, given a vk::raii::Device\n    vk::raii::Semaphore imageAcquiredSemphore( device, vk::SemaphoreCreateInfo() );\n\nThat semaphore can be used, to acquire the next imageIndex from the `vk::raii::SwapchainKHR` swapchain:\n\n    vk::Result result;\n    uint32_t imageIndex;\n    std::tie( result, imageIndex ) = swapchain.acquireNextImage( timeout, *imageAcquiredSemaphore );\n\nNote, `vk::raii::SwapchainKHR::acquireNextImage` returns a `std::pair<vk::Result, uint32_t>`, that can nicely be assigned onto two separate values using std::tie().\n\nAnd also note, the returned `vk::Result` can not only be `vk::Result::eSuccess`, but also `vk::Result::eTimeout`, `vk::Result::eNotReady`, or `vk::Result::eSuboptimalKHR`, which should be handled here accordingly!\n\nNext, you can record some commands into a `vk::raii::CommandBuffer`:\n\n    // open the commandBuffer for recording\n    commandBuffer.begin( {} );\n\n    // initialize a vk::RenderPassBeginInfo with the current imageIndex and some appropriate renderArea and clearValues\n    vk::RenderPassBeginInfo renderPassBeginInfo( *renderPass, *framebuffers[imageIndex], renderArea, clearValues );\n\n    // begin the render pass with an inlined subpass; no secondary command buffers allowed\n    commandBuffer.beginRenderPass( renderPassBeginInfo, vk::SubpassContents::eInline );\n\n    // bind the graphics pipeline\n    commandBuffer.bindPipeline( vk::PipelineBindPoint::eGraphics, *graphicsPipeline );\n\n    // bind an appropriate descriptor set\n    commandBuffer.bindDescriptorSets( vk::PipelineBindPoint::eGraphics, *pipelineLayout, 0, { *descriptorSet }, nullptr );\n\n    // bind the vertex buffer\n    commandBuffer.bindVertexBuffers( 0, { *vertexBuffer }, { 0 } );\n\n    // set viewport and scissor\n    commandBuffer.setViewport( 0, viewport );\n    commandBuffer.setScissor( renderArea );\n\n    // draw the 12 * 3 vertices once, starting with vertex 0 and instance 0\n    commandBuffer.draw( 12 * 3, 1, 0, 0 );\n\n    // end the render pass and stop recording\n    commandBuffer.endRenderPass();\n    commandBuffer.end();\n\nTo submit that command buffer to a `vk::raii::Queue` graphicsQueue you might want to use a `vk::raii::Fence`\n\n    // create a vk::raii::Fence, given a vk::raii::Device device\n    vk::raii::Fence fence( device, vk::FenceCreateInfo() );\n\nWith that, you can fill a `vk::SubmitInfo` and submit the command buffer\n\n    vk::PipelineStageFlags waitDestinationStageMask( vk::PipelineStageFlagBits::eColorAttachmentOutput );\n    vk::SubmitInfo submitInfo( *imageAcquiredSemaphore, waitDestinationStageMask, *commandBuffer );\n    graphicsQueue.submit( submitInfo, *fence );\n\nAt some later point, you can wait for that submit being ready by waiting for the fence\n\n    while ( vk::Result::eTimeout == device.waitForFences( { *fence }, VK_TRUE, timeout ) )\n      ;\n\nAnd finally, you can use the `vk::raii::Queue` presentQueue to, well, present that image\n\n    vk::PresentInfoKHR presentInfoKHR( nullptr, *swapChain, imageIndex );\n    result = presentQueue.presentKHR( presentInfoKHR );\n\nNote here, again, that `result` can not only be `vk::Result::eSuccess`, but also `vk::Result::eSuboptimalKHR`, which should be handled accordingly.\n\n## Conclusion\n\nWith the vk::raii namespace you've got a complete set of Vulkan handle wrapper classes following the RAII-paradigm. That is, they can easily be assigned to a smart pointer. And you can't miss their destruction.\n\nMoreover, the actual function pointer handling is done automatically by `vk::raii::Context`, `vk::raii::Instance`, and `vk::raii::Device`. That is, you always use the correct device-specific functions, no matter how many devices you're using.\n\nNote, though, that there are a few classes, like `vk::raii::CommandPool` and `vk::raii::DescriptorSet`, that need some special handling that deviates from what you can do with the pure C-API or the wrapper classes in the vk-namespace.\n"
        },
        {
          "name": "vulkan",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}