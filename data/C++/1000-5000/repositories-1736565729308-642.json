{
  "metadata": {
    "timestamp": 1736565729308,
    "page": 642,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "yuanming-hu/taichi_mpm",
      "stars": 2400,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0986328125,
          "content": "__pycache__\npaper/paper.out\n*.synctex.gz\n*.out\n*.aux\n*.log\n*.blg\npaper.pdf\ntech.pdf\n*.bbl\n.DS_Store\n\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.9189453125,
          "content": "set(TAICHI_PROJECT_NAME \"mpm\")\n\nif (\"${TARGET_ARCHITECTURE}\" MATCHES \"sandy-bridge\")\n    message(\"No -DHASWELL for sandy-bridge\")\nelse()\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DHASWELL\")\nendif()\n\nfile(GLOB PROJECT_SOURCES \"src/*.cpp\" \"external/SPGrid/*/*.cpp\" \"src/async/*.cpp\")\n\nadd_library(taichi_${TAICHI_PROJECT_NAME} SHARED ${PROJECT_SOURCES})\ninclude_directories(external/partio/include)\ninclude_directories(external/)\ninclude_directories(external/libccd/src)\n\nset(TAICHI_PROJECT_LIBRARIES ${TAICHI_PROJECT_LIBRARIES} ${TAICHI_PROJECT_NAME} PARENT_SCOPE)\ntarget_link_libraries(taichi_${TAICHI_PROJECT_NAME} ${CORE_LIBRARY_NAME})\ntarget_link_libraries(taichi_${TAICHI_PROJECT_NAME} partio)\n\nadd_subdirectory(external/libccd)\nadd_subdirectory(external/partio)\n\nfind_package(ZLIB)\nif (ZLIB_FOUND)\n    target_link_libraries(taichi_${TAICHI_PROJECT_NAME} z)\nendif(ZLIB_FOUND)\n\ntarget_link_libraries(taichi_${TAICHI_PROJECT_NAME} ccd)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.033203125,
          "content": "Copyright 2018 Taichi MPM Authors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.9482421875,
          "content": "#  High-Performance MLS-MPM Solver with Cutting and Coupling (CPIC)  *(MIT License)*\n<img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/water_wheel.gif\"> <img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/sand_paddles.gif\">\n\n**A Moving Least Squares Material Point Method with Displacement Discontinuity and Two-Way Rigid Body Coupling**, ACM Transactions on Graphics (SIGGRAPH 2018).\n\nBy [Yuanming Hu (MIT CSAIL)](https://yuanming.taichi.graphics/), [Yu Fang (Tsinghua University)](http://squarefk.com/), Ziheng Ge (University of Science and Technology of China), Ziyin Qu (University of Pennsylvania), [Yixin Zhu (UCLA)](https://www.yzhu.io/), [Andre Pradhana (University of Pennsylvania)](https://www.seas.upenn.edu/~apradh/menu/about.html), [Chenfanfu Jiang (University of Pennsylvania)](https://www.seas.upenn.edu/~cffjiang/).\n\nWelcome to join the [Discussion Forum](https://forum.taichi.graphics/).\n\n### News\n - (August 2019) Check out our [SIGGRAPH 2019 course on high-performance MPM](https://yuanming.taichi.graphics/publication/2019-mpm-tutorial/)!\n - (May 2019) Check out niall's MLS-MPM [Unity implementation](https://github.com/nialltl/incremental_mpm) and [tutorial](https://nialltl.neocities.org/articles/mpm_guide.html)! \n - (March 2019) David Medina contributed [mls-mpm88-explained.cpp](https://github.com/yuanming-hu/taichi_mpm/blob/master/mls-mpm88-explained.cpp) which is much easier to read than the original 88-line version.\n - (March 2019) Roberto Toro made [mls-mpm.js](https://github.com/r03ert0/mls-mpm.js) that [runs in your browser](https://r03ert0.github.io/mls-mpm.js/index.html)!\n - (March 2019) This software is now released under the **MIT license**. Feel free to use it commercially. We would appreciate your acknoledgements if our software helps you.\n\n#### [[Introduction & Demo Video](https://www.youtube.com/watch?v=8iyvhGF9f7o)] [[Paper](https://yuanming.taichi.graphics/publication/2018-mlsmpm/mls-mpm-cpic.pdf)] [[Supplemental Document](https://yuanming.taichi.graphics/publication/2018-mlsmpm/mls-mpm-cpic-supp.pdf)] [[88-Line MLS-MPM](https://github.com/yuanming-hu/taichi_mpm#88-line-version-mit-license-download-c--javascript-versions)]\n#### [[SIGGRAPH 2018 Fast Forward](https://youtu.be/9RlNEgwTtPI)] [[PDF Slides](https://github.com/yuanming-hu/taichi_mpm/releases/download/SIGGRAPH2018/mls-mpm-cpic-slides.pdf)] [[PDF Slides with Notes](https://github.com/yuanming-hu/taichi_mpm/releases/download/SIGGRAPH2018/mls-mpm-cpic-slides-with-notes.pdf)]\n\n\n<img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/armodillo.gif\" style=\"\"> <img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/debris_flow.gif\">\n<img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/sand-sweep.gif\"> <img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/sand_stir.gif\">\n<img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/bunny.gif\"> <img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/robot_forward.gif\">\n<img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/banana.gif\"> <img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/cheese.gif\">\n\n\n## 88-Line Version (MIT License) [[Download C++ & Javascript versions](https://github.com/yuanming-hu/taichi_mpm/releases/download/SIGGRAPH2018/mls-mpm88.zip)]\n\n--------\n\n**Update Nov 2021: with the new [Taichi programming language](https://github.com/taichi-dev/taichi), you can run [MLS-MPM on GPU](https://github.com/taichi-dev/taichi/blob/master/python/taichi/examples/simulation/mpm128.py) with Python 3 after `pip install taichi`**\n\n--------\n\nSupports Linux, OS X and Windows. Tested on Ubuntu 16.04, Ubuntu 18.04, Arch Linux, MinGW, VS2017, OS X 10.11~10.14.\nNo need to install `taichi` or `taichi_mpm` - see the end of code for instructions.\n\n<img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/mls-mpm88-lowres.gif\" width=\"400px\"> <img src=\"https://github.com/yuanming-hu/public_files/raw/master/graphics/mls-mpm-cpic/mls-mpm88-highres.gif\" width=\"400px\">\n\n\n``` C++\n//88-Line 2D Moving Least Squares Material Point Method (MLS-MPM)[with comments]\n//#define TC_IMAGE_IO   // Uncomment this line for image exporting functionality\n#include \"taichi.h\"    // Note: You DO NOT have to install taichi or taichi_mpm.\nusing namespace taichi;// You only need [taichi.h] - see below for instructions.\nconst int n = 80 /*grid resolution (cells)*/, window_size = 800;\nconst real dt = 1e-4_f, frame_dt = 1e-3_f, dx = 1.0_f / n, inv_dx = 1.0_f / dx;\nauto particle_mass = 1.0_f, vol = 1.0_f;\nauto hardening = 10.0_f, E = 1e4_f, nu = 0.2_f;\nreal mu_0 = E / (2 * (1 + nu)), lambda_0 = E * nu / ((1+nu) * (1 - 2 * nu));\nusing Vec = Vector2; using Mat = Matrix2; bool plastic = true;\nstruct Particle { Vec x, v; Mat F, C; real Jp; int c/*color*/;\n  Particle(Vec x, int c, Vec v=Vec(0)) : x(x), v(v), F(1), C(0), Jp(1), c(c){}};\nstd::vector<Particle> particles;\nVector3 grid[n + 1][n + 1];          // velocity + mass, node_res = cell_res + 1\n\nvoid advance(real dt) {\n  std::memset(grid, 0, sizeof(grid));                              // Reset grid\n  for (auto &p : particles) {                                             // P2G\n    Vector2i base_coord=(p.x*inv_dx-Vec(0.5_f)).cast<int>();//element-wise floor\n    Vec fx = p.x * inv_dx - base_coord.cast<real>();\n    // Quadratic kernels  [http://mpm.graphics   Eqn. 123, with x=fx, fx-1,fx-2]\n    Vec w[3]{Vec(0.5) * sqr(Vec(1.5) - fx), Vec(0.75) - sqr(fx - Vec(1.0)),\n             Vec(0.5) * sqr(fx - Vec(0.5))};\n    auto e = std::exp(hardening * (1.0_f - p.Jp)), mu=mu_0*e, lambda=lambda_0*e;\n    real J = determinant(p.F);         //                         Current volume\n    Mat r, s; polar_decomp(p.F, r, s); //Polar decomp. for fixed corotated model\n    auto stress =                           // Cauchy stress times dt and inv_dx\n        -4*inv_dx*inv_dx*dt*vol*(2*mu*(p.F-r) * transposed(p.F)+lambda*(J-1)*J);\n    auto affine = stress+particle_mass*p.C;\n    for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) { // Scatter to grid\n        auto dpos = (Vec(i, j) - fx) * dx;\n        Vector3 mv(p.v * particle_mass, particle_mass); //translational momentum\n        grid[base_coord.x + i][base_coord.y + j] +=\n            w[i].x*w[j].y * (mv + Vector3(affine*dpos, 0));\n      }\n  }\n  for(int i = 0; i <= n; i++) for(int j = 0; j <= n; j++) { //For all grid nodes\n      auto &g = grid[i][j];\n      if (g[2] > 0) {                                // No need for epsilon here\n        g /= g[2];                                   //        Normalize by mass\n        g += dt * Vector3(0, -200, 0);               //                  Gravity\n        real boundary=0.05,x=(real)i/n,y=real(j)/n; //boundary thick.,node coord\n        if (x < boundary||x > 1-boundary||y > 1-boundary) g=Vector3(0); //Sticky\n        if (y < boundary) g[1] = std::max(0.0_f, g[1]);             //\"Separate\"\n      }\n    }\n  for (auto &p : particles) {                                // Grid to particle\n    Vector2i base_coord=(p.x*inv_dx-Vec(0.5_f)).cast<int>();//element-wise floor\n    Vec fx = p.x * inv_dx - base_coord.cast<real>();\n    Vec w[3]{Vec(0.5) * sqr(Vec(1.5) - fx), Vec(0.75) - sqr(fx - Vec(1.0)),\n             Vec(0.5) * sqr(fx - Vec(0.5))};\n    p.C = Mat(0); p.v = Vec(0);\n    for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) {\n        auto dpos = (Vec(i, j) - fx),\n            grid_v = Vec(grid[base_coord.x + i][base_coord.y + j]);\n        auto weight = w[i].x * w[j].y;\n        p.v += weight * grid_v;                                      // Velocity\n        p.C += 4 * inv_dx * Mat::outer_product(weight * grid_v, dpos); // APIC C\n      }\n    p.x += dt * p.v;                                                // Advection\n    auto F = (Mat(1) + dt * p.C) * p.F;                      // MLS-MPM F-update\n    Mat svd_u, sig, svd_v; svd(F, svd_u, sig, svd_v);\n    for (int i = 0; i < 2 * int(plastic); i++)                // Snow Plasticity\n      sig[i][i] = clamp(sig[i][i], 1.0_f - 2.5e-2_f, 1.0_f + 7.5e-3_f);\n    real oldJ = determinant(F); F = svd_u * sig * transposed(svd_v);\n    real Jp_new = clamp(p.Jp * oldJ / determinant(F), 0.6_f, 20.0_f);\n    p.Jp = Jp_new; p.F = F;\n  }\n}\nvoid add_object(Vec center, int c) {   // Seed particles with position and color\n  for (int i = 0; i < 500; i++)  // Randomly sample 1000 particles in the square\n    particles.push_back(Particle((Vec::rand()*2.0_f-Vec(1))*0.08_f + center, c));\n}\nint main() {\n  GUI gui(\"Real-time 2D MLS-MPM\", window_size, window_size);\n  add_object(Vec(0.55,0.45), 0xED553B); add_object(Vec(0.45,0.65), 0xF2B134);\n  add_object(Vec(0.55,0.85), 0x068587); auto &canvas = gui.get_canvas();int f=0;\n  for (int i = 0;; i++) {                              //              Main Loop\n    advance(dt);                                       //     Advance simulation\n    if (i % int(frame_dt / dt) == 0) {                 //        Visualize frame\n      canvas.clear(0x112F41);                          //       Clear background\n      canvas.rect(Vec(0.04), Vec(0.96)).radius(2).color(0x4FB99F).close();// Box\n      for(auto p:particles)canvas.circle(p.x).radius(2).color(p.c);//Particles\n      gui.update();                                              // Update image\n      // canvas.img.write_as_image(fmt::format(\"tmp/{:05d}.png\", f++));\n    }\n  }\n} //----------------------------------------------------------------------------\n\n/* -----------------------------------------------------------------------------\n** Reference: A Moving Least Squares Material Point Method with Displacement\n              Discontinuity and Two-Way Rigid Body Coupling (SIGGRAPH 2018)\n\n  By Yuanming Hu (who also wrote this 88-line version), Yu Fang, Ziheng Ge,\n           Ziyin Qu, Yixin Zhu, Andre Pradhana, Chenfanfu Jiang\n\n\n** Build Instructions:\n\nStep 1: Download and unzip mls-mpm88.zip (Link: http://bit.ly/mls-mpm88)\n        Now you should have \"mls-mpm88.cpp\" and \"taichi.h\".\n\nStep 2: Compile and run\n\n* Linux:\n    g++ mls-mpm88.cpp -std=c++14 -g -lX11 -lpthread -O3 -o mls-mpm\n    ./mls-mpm\n\n\n* Windows (MinGW):\n    g++ mls-mpm88.cpp -std=c++14 -lgdi32 -lpthread -O3 -o mls-mpm\n    .\\mls-mpm.exe\n\n\n* Windows (Visual Studio 2017+):\n  - Create an \"Empty Project\"\n  - Use taichi.h as the only header, and mls-mpm88.cpp as the only source\n  - Change configuration to \"Release\" and \"x64\"\n  - Press F5 to compile and run\n\n\n* OS X:\n    g++ mls-mpm88.cpp -std=c++14 -framework Cocoa -lpthread -O3 -o mls-mpm\n    ./mls-mpm\n\n\n** FAQ:\nQ1: What does \"1e-4_f\" mean?\nA1: The same as 1e-4f, a float precision real number.\n\nQ2: What is \"real\"?\nA2: real = float in this file.\n\nQ3: What are the hex numbers like 0xED553B?\nA3: They are RGB color values.\n    The color scheme is borrowed from\n    https://color.adobe.com/Copy-of-Copy-of-Core-color-theme-11449181/\n\nQ4: How can I get higher-quality?\nA4: Change n to 320; Change dt to 1e-5; Change E to 2e4;\n    Change particle per cube from 500 to 8000 (Ln 72).\n    After the change the whole animation takes ~3 minutes on my computer.\n\nQ5: How to record the animation?\nA5: Uncomment Ln 2 and 85 and create a folder named \"tmp\".\n    The frames will be saved to \"tmp/XXXXX.png\".\n\n    To get a video, you can use ffmpeg. If you already have taichi installed,\n    you can simply go to the \"tmp\" folder and execute\n\n      ti video 60\n\n    where 60 stands for 60 FPS. A file named \"video.mp4\" is what you want.\n\nQ6: How was taichi.h generated?\nA6: Please check out my #include <taichi> talk:\n    http://taichi.graphics/wp-content/uploads/2018/11/include_taichi.pdf\n    and the generation script:\n    https://github.com/yuanming-hu/taichi/blob/master/misc/amalgamate.py\n    You can regenerate it using `ti amal`, if you have taichi installed.\n\nQuestions go to yuanming _at_ mit.edu\n                            or https://github.com/yuanming-hu/taichi_mpm/issues.\n\n                                                      Last Update: March 6, 2019\n                                                      Version 1.5\n\n----------------------------------------------------------------------------- */\n```\n\n## Installing the High-Performance 3D Solver\n(This is for installing the high-performance 2D/3D solver including MLS-MPM and CPIC. If you want to play with the 88-line MLS-MPM, you don't have to install anything - see [here](https://github.com/yuanming-hu/taichi_mpm#88-line-version-mit-license-download-c--javascript-versions))\n### Linux and OSX\nInstall [`taichi (legacy branch)`](https://github.com/taichi-dev/taichi/blob/5ab90f03ef37701506c7034c3f1955d225b39957/docs/installation.rst).\nThen, in command line\n```\nti install mpm\n```\nand it will install this taichi package automatically.\n\n### Windows\nSupport coming later.\n\n## Run demos\nEvery script under the folder `scripts/mls-cpic` is executable with `python3`.\n# Visualize the results\n - Outputs are in `taichi/outputs/mpm/`;\n - Install [Houdini Apprentice](https://www.sidefx.com/products/houdini-apprentice/) (which is free);\n - Create a `File` node in Houdini to visualize the `bgeo` (particles), `obj` (3D meshes), `poly` (2D polygons) files.\n\n# Python 3 API\n\n## MPM.initialize\n(You only need to specify `res` in most cases. The default parameters generally work well.) \nAll parameters:\n - res: (`Vector<dim, int>`) grid resolution. The length of this vector also specifies the dimensionality of the simulation.\n - base_delta_t : (`real`, default: `1e-4`) delta t\n - delta_x: (`real`, default: `1.0 / res[0]`)\n - particle_collision (`bool`, default: `False`): push particles inside level sets out (turn off when you are using sticky level sets)\n - pushing_force: (`real`, default: `20000.0`) If things do not separate, use this. Typical value: 20000.0.\n - gravity (`Vector<dim>`, default: `(0, -10, 0)` for 3D, `(0, -10)` for 2D)\n - frame_dt: (`real`, default: `0.01`) You can set to `1 / 24` for real frame rate.\n - num_threads: (`int`, default: `-1`) Number of threads to use. `-1` means maximum threads.\n - num_frames: (`int`, default: `1000`) Number of frames to simulate.\n - penalty: (`real`, default: `0`) Penetration penalty. Typical values are `1e3` ~ `1e4`.\n - optimized: (`bool`, default: `True`) Turn on optimization or not. Turning it off if you need to benchmark the less optimized transfers.\n - task_id: (`string`, default: `taichi` will use the current file name)\n - rigid_body_levelset_collision: (`bool`, default: `False`) Collide rigid body with level set? (Useful for wine & glass.)\n - rpic_damping: (`real`, default: `0`) RPIC damping value should be between 0 and 1 (inclusive).\n - apic_damping: (`real`, default: `0`) APIC damping value should be between 0 and 1 (inclusive).\n - warn_particle_deletion: (`bool`, default: `False`) Log warning when particles get deleted\n - verbose_bgeo: (`bool`, default: `false`) If `true`, output particle attributes other than `position`.\n - reorder_interval: (`int`, default: `1000`) If bigger than error, sort particle storage in memory every `reorder_interval` substeps.\n - clean_boundary: (`int`, default: `1000`) If bigger than error, sort particle storage in memory every `reorder_interval` substeps.\n - ...\n \n## MPM.add_particles\n - type: `rigid`, `snow`, `jelly`, `sand`. For non-rigid type, see [Particle Attributes](#attributes)\n - color: (`Vector<3, real>`)\n - pd : (`bool`, default: `True`) Is poisson disk sampling or not? Doesn't support type: `rigid`, `sdf`\n - pd_periodic : (`bool`, default: `True`) Is poisson disk periodic or not? Doesn't support 2D\n - pd_source : (`bool`, default: `False`) Is poisson disk sampling from source or not (need to define`frame_update`)? Doesn't support 2D\n - For type `rigid`:\n - rotation_axis : (`Vector<3, real>`, default: `(0, 0, 0)`) Let the object rotate along with only this axis. Useful for fans or wheels.\n - codimensional : (`bool`, must be explicitly specified) Is thin shell or not?\n - restitution: (`real`, default: `0.0`) Coefficient of restitution\n - friction: (`real`, default: `0.0`) Coefficient of friction\n - density: (`real`, default: `40` for thin shell, `400` for non-thin shell) Volume/area density.\n - scale: (`Vector<3, real>`, default: `(1, 1, 1)`) rescale the object, bigger or smaller\n - initial_position: (`Vector<dim, real>`, must be explicitly specified)\n - initial_velocity: (`Vector<dim, real>`, default: `(0, 0, 0)`)\n - scripted_position: (`function(real) => Vector<3, real>`)\n - initial_rotation: (`Vector<1 (2D) or 3 (3D), real>`, default: `(0, 0, 0)`) Euler angles\n - initial_angular_velocity: (`Vector<1 (2D) or 3 (3D), real>`, default: `(0, 0, 0)`)\n - scripted_rotation: (`function(real) => Vector<1 (2D) or 3 (3D), real>`) Takes time, returns Euler angles\n - (Translational/Rotational) static objects are also considered as scripted, but with a fixed scripting function i.e. `tc.constant_function13(tc.Vector(0, 0, 0))`\n - linear_damping: (`real`, default: `0`) damping of linear velocity. Typical value: `1`\n - angular_damping: (`real`, default: `0`) damping of angular velocity. Typical value: `1`\n - ...\n \n# <a name=\"attributes\"></a>Particle Attributes\n * `jelly`\n    - `E`:  (`real`, default: `1e5`) Young's modulus\n    - `nu`:  (`real`, default: `0.3`) Poisson's ratio\n * `snow`\n    - `hardeing` (`real`, default: `10`) Hardening coefficient\n    - `mu_0` (`real`, default: `58333.3`) Lame parameter\n    - `lambda_0` (`real`, default: `38888.9`) Lame parameter\n    - `theta_c` (`real`, default: `2.5e-2`) Critical compression\n    - `theta_s` (`real`, default: `7.5e-3`) Critical stretch\n * `sand`\n    - `mu_0` (`real`, default: `136038`) Lame parameter\n    - `lambda_0` (`real`, default: `204057`) Lame parameter\n    - `friction_angle` (`real`, default: `30`)\n    - `cohesion` (`real`, default: `0`)\n    - `beta` (`real`, default: `1`)\n * `water`\n    - `k`:  (`real`, default: `1e5`) Bulk modulus\n    - `gamma`:  (`real`, default: `7`)\n * `von_mises`\n    - `youngs_modulus`:  (`real`, default: `5e3`) Young's modulus (for elasticity)\n    - `poisson_ratio`:  (`real`, default: `0.4`) Poisson's ratio (for elasticity, usually no need to change)\n    - `yield_stress`: (`real`, default:`1.0`) Radius of yield surface (for plasticity)\n * ...\n\n## Script Examples\n - Scripted motion: `scripted_motion_3d.py`.\n - Rigid-ground collison: `rigid_ground_collision.py`.\n - When you're making an rotating wheel example, e.g. `thin_wheels_fans.py` and the wheel is not turning in the right direction, you can try `reverse_vertices=True`.\n - ...\n \n# Notes\n - Matrices in taichi are column major. E.g. A[3][1] is the element at row 2 and column 4.\n - All indices, unless explicitly specified, are 0-based.\n - Use `real`, in most cases, instead of `float` or `double`.\n - Float point constants should be suffixed with `_f`, so that it will have type `real`, instead of `float` or `double`. Example: `1.5_f` (`float` or `double` depending on build precision) instead of `1.5` (always `double`) or `1.5f` (always `float`)\n - Always pull `taichi` (the main lib, *master* branch) after updating `taichi_mpm`.\n - When a particles moves too close to the boundary (4-8 dx) it will be deleted.\n - Whenever you can any compile/linking problem:\n   - Make sure `taichi` is up-to-date\n   - Invoke `CMake` so that all no source files will be detected\n   - Rebuild\n - ...\n  \n# Friction Coefficient\n - Separate: positive values, `0.4` means coeff of friction `0.4`\n - Sticky: -1\n - Slip: -2\n - Slip with friction: `-2.4` means coeff of friction `0.4` with slip\n \n# Articulation\n\nSyntax:\n\n```$python\n    object1 = mpm.add_particles(...)\n    object2 = mpm.add_particles(...)\n\n    mpm.add_articulation(type='motor', obj0=object1, obj1=object2, axis=(0, 0, 1), power=0.05)\n```\n\n * Rotation: enforce two objects to have the same rotation.\n   - `type`:  `rotation`\n   - `obj0`, `obj1`: two objects\n   - Use case: blabe and wheel in `water wheel` examples \n   \n * Distance: enforce two points on two different object to have constant distance\n   - `type`:  `distance`\n   - `obj0`, `obj1`: two objects\n   - `offset0`, `offset1`: (`Vector<dim, real>`, default: `(0, 0, 0)`) offset of two points to the center of mass to each object, in world space\n   - `distance` (`real`, default: initial distance between two poitns) target distance\n   - `penalty` (`real`, default: `1e5`) corrective penalty\n   - Use case: hammer in `crashing_castle` examples \n   \n * Motor: enforce object to rotate along an axis on another object, and apply torque\n   - `type`:  `motor`\n   - `obj0`: the `wheel` object\n   - `obj1`: the `body` object\n   - `axis`: (`Vector<dim, real>`) the rotation axis in world space\n   - `power` (`real`, default: `0`) torque applied per second\n   - Use case: wheels for cars, and legs for the robot\n   - Example: `motor.py`\n * Stepper: enforce object to rotate along an axis on another object at a fixed angular velocity\n   - `type`:  `motor`\n   - `obj0`: the `wheel` object\n   - `obj1`: the `body` object\n   - `axis`: (`Vector<dim, real>`) the rotation axis in world space\n   - `angular_velocity` (`real`) \n   - Use case: Fixed-rotation-speed wheels for cars, and legs for the robot\n\n# Source Sampling\n - If you want to source particles continuously from a object, please set `pd_source = True` in `add_particles`\n - `initial_velocity` should be a non-zero vector\n - Remember to also set `delta_t=frame_dt` in `add_particles`, which enables the frequency of sampling to be consistent with its initial velocity\n - There might be some artifact due to the effect of gravity. You can reduce that artifact by  increasing `update_frequency`.\n - Example: `source_sampling.py`, `source_sampling_2d.py`\n\n\n## Mathematical Comparisons with Traditional MPM\n<img src=\"/images/comparisons.jpg\" with=\"1000\">\n\n# Performance\n\n# Bibtex\nPlease cite our [paper](https://yuanming.taichi.graphics/publication/2018-mlsmpm/) if you use this code for your research: \n```\n@article{hu2018mlsmpmcpic,\n  title={A Moving Least Squares Material Point Method with Displacement Discontinuity and Two-Way Rigid Body Coupling},\n  author={Hu, Yuanming and Fang, Yu and Ge, Ziheng and Qu, Ziyin and Zhu, Yixin and Pradhana, Andre and Jiang, Chenfanfu},\n  journal={ACM Transactions on Graphics (TOG)},\n  volume={37},\n  number={4},\n  pages={150},\n  year={2018},\n  publisher={ACM}\n}\n```\n"
        },
        {
          "name": "external",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "mls-mpm88-explained.cpp",
          "type": "blob",
          "size": 8.6376953125,
          "content": "//  88-Line 2D Moving Least Squares Material Point Method (MLS-MPM)\n// [Explained Version by David Medina]\n\n// Uncomment this line for image exporting functionality\n#define TC_IMAGE_IO\n\n// Note: You DO NOT have to install taichi or taichi_mpm.\n// You only need [taichi.h] - see below for instructions.\n#include \"taichi.h\"\n\nusing namespace taichi;\nusing Vec = Vector2;\nusing Mat = Matrix2;\n\n// Window\nconst int window_size = 800;\n\n// Grid resolution (cells)\nconst int n = 80;\n\nconst real dt = 1e-4_f;\nconst real frame_dt = 1e-3_f;\nconst real dx = 1.0_f / n;\nconst real inv_dx = 1.0_f / dx;\n\n// Snow material properties\nconst auto particle_mass = 1.0_f;\nconst auto vol = 1.0_f;        // Particle Volume\nconst auto hardening = 10.0_f; // Snow hardening factor\nconst auto E = 1e4_f;          // Young's Modulus\nconst auto nu = 0.2_f;         // Poisson ratio\nconst bool plastic = true;\n\n// Initial Lamé parameters\nconst real mu_0 = E / (2 * (1 + nu));\nconst real lambda_0 = E * nu / ((1+nu) * (1 - 2 * nu));\n\nstruct Particle {\n  // Position and velocity\n  Vec x, v;\n  // Deformation gradient\n  Mat F;\n  // Affine momentum from APIC\n  Mat C;\n  // Determinant of the deformation gradient (i.e. volume)\n  real Jp;\n  // Color\n  int c;\n\n  Particle(Vec x, int c, Vec v=Vec(0)) :\n    x(x),\n    v(v),\n    F(1),\n    C(0),\n    Jp(1),\n    c(c) {}\n};\n\nstd::vector<Particle> particles;\n\n// Vector3: [velocity_x, velocity_y, mass]\nVector3 grid[n + 1][n + 1];\n\nvoid advance(real dt) {\n  // Reset grid\n  std::memset(grid, 0, sizeof(grid));\n\n  // P2G\n  for (auto &p : particles) {\n    // element-wise floor\n    Vector2i base_coord = (p.x * inv_dx - Vec(0.5f)).cast<int>();\n\n    Vec fx = p.x * inv_dx - base_coord.cast<real>();\n\n    // Quadratic kernels [http://mpm.graphics Eqn. 123, with x=fx, fx-1,fx-2]\n    Vec w[3] = {\n      Vec(0.5) * sqr(Vec(1.5) - fx),\n      Vec(0.75) - sqr(fx - Vec(1.0)),\n      Vec(0.5) * sqr(fx - Vec(0.5))\n    };\n\n    // Compute current Lamé parameters [http://mpm.graphics Eqn. 86]\n    auto e = std::exp(hardening * (1.0f - p.Jp));\n    auto mu = mu_0 * e;\n    auto lambda = lambda_0 * e;\n\n    // Current volume\n    real J = determinant(p.F);\n\n    // Polar decomposition for fixed corotated model\n    Mat r, s;\n    polar_decomp(p.F, r, s);\n\n    // [http://mpm.graphics Paragraph after Eqn. 176]\n    real Dinv = 4 * inv_dx * inv_dx;\n    // [http://mpm.graphics Eqn. 52]\n    auto PF = (2 * mu * (p.F-r) * transposed(p.F) + lambda * (J-1) * J);\n\n    // Cauchy stress times dt and inv_dx\n    auto stress = - (dt * vol) * (Dinv * PF);\n\n    // Fused APIC momentum + MLS-MPM stress contribution\n    // See http://taichi.graphics/wp-content/uploads/2019/03/mls-mpm-cpic.pdf\n    // Eqn 29\n    auto affine = stress + particle_mass * p.C;\n\n    // P2G\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 3; j++) {\n        auto dpos = (Vec(i, j) - fx) * dx;\n        // Translational momentum\n        Vector3 mass_x_velocity(p.v * particle_mass, particle_mass);\n        grid[base_coord.x + i][base_coord.y + j] += (\n          w[i].x*w[j].y * (mass_x_velocity + Vector3(affine * dpos, 0))\n        );\n      }\n    }\n  }\n\n  // For all grid nodes\n  for(int i = 0; i <= n; i++) {\n    for(int j = 0; j <= n; j++) {\n      auto &g = grid[i][j];\n      // No need for epsilon here\n      if (g[2] > 0) {\n        // Normalize by mass\n        g /= g[2];\n        // Gravity\n        g += dt * Vector3(0, -200, 0);\n\n        // boundary thickness\n        real boundary = 0.05;\n        // Node coordinates\n        real x = (real) i / n;\n        real y = real(j) / n;\n\n        // Sticky boundary\n        if (x < boundary || x > 1-boundary || y > 1-boundary) {\n          g = Vector3(0);\n        }\n        // Separate boundary\n        if (y < boundary) {\n          g[1] = std::max(0.0f, g[1]);\n        }\n      }\n    }\n  }\n\n  // G2P\n  for (auto &p : particles) {\n    // element-wise floor\n    Vector2i base_coord = (p.x * inv_dx - Vec(0.5f)).cast<int>();\n    Vec fx = p.x * inv_dx - base_coord.cast<real>();\n    Vec w[3] = {\n                Vec(0.5) * sqr(Vec(1.5) - fx),\n                Vec(0.75) - sqr(fx - Vec(1.0)),\n                Vec(0.5) * sqr(fx - Vec(0.5))\n    };\n\n    p.C = Mat(0);\n    p.v = Vec(0);\n\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 3; j++) {\n        auto dpos = (Vec(i, j) - fx);\n        auto grid_v = Vec(grid[base_coord.x + i][base_coord.y + j]);\n        auto weight = w[i].x * w[j].y;\n        // Velocity\n        p.v += weight * grid_v;\n        // APIC C\n        p.C += 4 * inv_dx * Mat::outer_product(weight * grid_v, dpos);\n      }\n    }\n\n    // Advection\n    p.x += dt * p.v;\n\n    // MLS-MPM F-update\n    auto F = (Mat(1) + dt * p.C) * p.F;\n\n    Mat svd_u, sig, svd_v;\n    svd(F, svd_u, sig, svd_v);\n\n    // Snow Plasticity\n    for (int i = 0; i < 2 * int(plastic); i++) {\n      sig[i][i] = clamp(sig[i][i], 1.0f - 2.5e-2f, 1.0f + 7.5e-3f);\n    }\n\n    real oldJ = determinant(F);\n    F = svd_u * sig * transposed(svd_v);\n\n    real Jp_new = clamp(p.Jp * oldJ / determinant(F), 0.6f, 20.0f);\n\n    p.Jp = Jp_new;\n    p.F = F;\n  }\n}\n\n// Seed particles with position and color\nvoid add_object(Vec center, int c) {\n  // Randomly sample 1000 particles in the square\n  for (int i = 0; i < 1000; i++) {\n    particles.push_back(Particle((Vec::rand()*2.0f-Vec(1))*0.08f + center, c));\n  }\n}\n\nint main() {\n  GUI gui(\"Real-time 2D MLS-MPM\", window_size, window_size);\n  auto &canvas = gui.get_canvas();\n\n  add_object(Vec(0.55,0.45), 0xED553B);\n  add_object(Vec(0.45,0.65), 0xF2B134);\n  add_object(Vec(0.55,0.85), 0x068587);\n\n  int frame = 0;\n\n  // Main Loop\n  for (int step = 0;; step++) {\n    // Advance simulation\n    advance(dt);\n\n    // Visualize frame\n    if (step % int(frame_dt / dt) == 0) {\n      // Clear background\n      canvas.clear(0x112F41);\n      // Box\n      canvas.rect(Vec(0.04), Vec(0.96)).radius(2).color(0x4FB99F).close();\n      // Particles\n      for (auto p : particles) {\n        canvas.circle(p.x).radius(2).color(p.c);\n      }\n      // Update image\n      gui.update();\n\n      // Write to disk (optional)\n      // canvas.img.write_as_image(fmt::format(\"tmp/{:05d}.png\", frame++));\n    }\n  }\n}\n\n/* -----------------------------------------------------------------------------\n** Reference: A Moving Least Squares Material Point Method with Displacement\n              Discontinuity and Two-Way Rigid Body Coupling (SIGGRAPH 2018)\n\n  By Yuanming Hu (who also wrote this 88-line version), Yu Fang, Ziheng Ge,\n           Ziyin Qu, Yixin Zhu, Andre Pradhana, Chenfanfu Jiang\n\n\n** Build Instructions:\n\nStep 1: Download and unzip mls-mpm88.zip (Link: http://bit.ly/mls-mpm88)\n        Now you should have \"mls-mpm88.cpp\" and \"taichi.h\".\n\nStep 2: Compile and run\n\n* Linux:\n    g++ mls-mpm88-explained.cpp -std=c++14 -g -lX11 -lpthread -O3 -o mls-mpm\n    ./mls-mpm\n\n\n* Windows (MinGW):\n    g++ mls-mpm88-explained.cpp -std=c++14 -lgdi32 -lpthread -O3 -o mls-mpm\n    .\\mls-mpm.exe\n\n\n* Windows (Visual Studio 2017+):\n  - Create an \"Empty Project\"\n  - Use taichi.h as the only header, and mls-mpm88-explained.cpp as the only source\n  - Change configuration to \"Release\" and \"x64\"\n  - Press F5 to compile and run\n\n\n* OS X:\n    g++ mls-mpm88-explained.cpp -std=c++14 -framework Cocoa -lpthread -O3 -o mls-mpm\n    ./mls-mpm\n\n\n** FAQ:\nQ1: What does \"1e-4_f\" mean?\nA1: The same as 1e-4f, a float precision real number.\n\nQ2: What is \"real\"?\nA2: real = float in this file.\n\nQ3: What are the hex numbers like 0xED553B?\nA3: They are RGB color values.\n    The color scheme is borrowed from\n    https://color.adobe.com/Copy-of-Copy-of-Core-color-theme-11449181/\n\nQ4: How can I get higher-quality?\nA4: Change n to 320; Change dt to 1e-5; Change E to 2e4;\n    Change particle per cube from 500 to 8000 (Ln 72).\n    After the change the whole animation takes ~3 minutes on my computer.\n\nQ5: How to record the animation?\nA5: Uncomment Ln 2 and 85 and create a folder named \"tmp\".\n    The frames will be saved to \"tmp/XXXXX.png\".\n\n    To get a video, you can use ffmpeg. If you already have taichi installed,\n    you can simply go to the \"tmp\" folder and execute\n\n      ti video 60\n\n    where 60 stands for 60 FPS. A file named \"video.mp4\" is what you want.\n\nQ6: How is taichi.h generated?\nA6: Please check out my #include <taichi> talk:\n    http://taichi.graphics/wp-content/uploads/2018/11/include_taichi.pdf\n    and the generation script:\n    https://github.com/yuanming-hu/taichi/blob/master/misc/amalgamate.py\n    You can regenerate it using `ti amal`, if you have taichi installed.\n\nQuestions go to yuanming _at_ mit.edu\n                            or https://github.com/yuanming-hu/taichi_mpm/issues.\n\n                                                      Last Update: March 6, 2019\n                                                      Version 1.5\n\n----------------------------------------------------------------------------- */\n"
        },
        {
          "name": "mls-mpm88.cpp",
          "type": "blob",
          "size": 7.5107421875,
          "content": "//88-Line 2D Moving Least Squares Material Point Method (MLS-MPM)[with comments]\n#define TC_IMAGE_IO   // Uncomment this line for image exporting functionality\n#include \"taichi.h\"    // Note: You DO NOT have to install taichi or taichi_mpm.\nusing namespace taichi;// You only need [taichi.h] - see below for instructions.\nconst int n = 80 /*grid resolution (cells)*/, window_size = 800;\nconst real dt = 1e-4_f, frame_dt = 1e-3_f, dx = 1.0_f / n, inv_dx = 1.0_f / dx;\nauto particle_mass = 1.0_f, vol = 1.0_f;\nauto hardening = 10.0_f, E = 1e4_f, nu = 0.2_f;\nreal mu_0 = E / (2 * (1 + nu)), lambda_0 = E * nu / ((1+nu) * (1 - 2 * nu));\nusing Vec = Vector2; using Mat = Matrix2; bool plastic = true;\nstruct Particle { Vec x, v; Mat F, C; real Jp; int c/*color*/;\n  Particle(Vec x, int c, Vec v=Vec(0)) : x(x), v(v), F(1), C(0), Jp(1), c(c){}};\nstd::vector<Particle> particles;\nVector3 grid[n + 1][n + 1];          // velocity + mass, node_res = cell_res + 1\n\nvoid advance(real dt) {\n  std::memset(grid, 0, sizeof(grid));                              // Reset grid\n  for (auto &p : particles) {                                             // P2G\n    Vector2i base_coord=(p.x*inv_dx-Vec(0.5_f)).cast<int>();//element-wise floor\n    Vec fx = p.x * inv_dx - base_coord.cast<real>();\n    // Quadratic kernels  [http://mpm.graphics   Eqn. 123, with x=fx, fx-1,fx-2]\n    Vec w[3]{Vec(0.5) * sqr(Vec(1.5) - fx), Vec(0.75) - sqr(fx - Vec(1.0)),\n             Vec(0.5) * sqr(fx - Vec(0.5))};\n    auto e = std::exp(hardening * (1.0_f - p.Jp)), mu=mu_0*e, lambda=lambda_0*e;\n    real J = determinant(p.F);         //                         Current volume\n    Mat r, s; polar_decomp(p.F, r, s); //Polar decomp. for fixed corotated model\n    auto stress =                           // Cauchy stress times dt and inv_dx\n        -4*inv_dx*inv_dx*dt*vol*(2*mu*(p.F-r) * transposed(p.F)+lambda*(J-1)*J);\n    auto affine = stress+particle_mass*p.C;\n    for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) { // Scatter to grid\n        auto dpos = (Vec(i, j) - fx) * dx;\n        Vector3 mv(p.v * particle_mass, particle_mass); //translational momentum\n        grid[base_coord.x + i][base_coord.y + j] +=\n            w[i].x*w[j].y * (mv + Vector3(affine*dpos, 0));\n      }\n  }\n  for(int i = 0; i <= n; i++) for(int j = 0; j <= n; j++) { //For all grid nodes\n      auto &g = grid[i][j];\n      if (g[2] > 0) {                                // No need for epsilon here\n        g /= g[2];                                   //        Normalize by mass\n        g += dt * Vector3(0, -200, 0);               //                  Gravity\n        real boundary=0.05,x=(real)i/n,y=real(j)/n; //boundary thick.,node coord\n        if (x < boundary||x > 1-boundary||y > 1-boundary) g=Vector3(0); //Sticky\n        if (y < boundary) g[1] = std::max(0.0_f, g[1]);             //\"Separate\"\n      }\n    }\n  for (auto &p : particles) {                                // Grid to particle\n    Vector2i base_coord=(p.x*inv_dx-Vec(0.5_f)).cast<int>();//element-wise floor\n    Vec fx = p.x * inv_dx - base_coord.cast<real>();\n    Vec w[3]{Vec(0.5) * sqr(Vec(1.5) - fx), Vec(0.75) - sqr(fx - Vec(1.0)),\n             Vec(0.5) * sqr(fx - Vec(0.5))};\n    p.C = Mat(0); p.v = Vec(0);\n    for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) {\n        auto dpos = (Vec(i, j) - fx),\n            grid_v = Vec(grid[base_coord.x + i][base_coord.y + j]);\n        auto weight = w[i].x * w[j].y;\n        p.v += weight * grid_v;                                      // Velocity\n        p.C += 4 * inv_dx * Mat::outer_product(weight * grid_v, dpos); // APIC C\n      }\n    p.x += dt * p.v;                                                // Advection\n    auto F = (Mat(1) + dt * p.C) * p.F;                      // MLS-MPM F-update\n    Mat svd_u, sig, svd_v; svd(F, svd_u, sig, svd_v);\n    for (int i = 0; i < 2 * int(plastic); i++)                // Snow Plasticity\n      sig[i][i] = clamp(sig[i][i], 1.0_f - 2.5e-2_f, 1.0_f + 7.5e-3_f);\n    real oldJ = determinant(F); F = svd_u * sig * transposed(svd_v);\n    real Jp_new = clamp(p.Jp * oldJ / determinant(F), 0.6_f, 20.0_f);\n    p.Jp = Jp_new; p.F = F;\n  }\n}\nvoid add_object(Vec center, int c) {   // Seed particles with position and color\n  for (int i = 0; i < 1000; i++)  // Randomly sample 1000 particles in the square\n    particles.push_back(Particle((Vec::rand()*2.0_f-Vec(1))*0.08_f + center, c));\n}\nint main() {\n  GUI gui(\"Real-time 2D MLS-MPM\", window_size, window_size);\n  add_object(Vec(0.55,0.45), 0xED553B); add_object(Vec(0.45,0.65), 0xF2B134);\n  add_object(Vec(0.55,0.85), 0x068587); auto &canvas = gui.get_canvas();int f=0;\n  for (int i = 0;; i++) {                              //              Main Loop\n    advance(dt);                                       //     Advance simulation\n    if (i % int(frame_dt / dt) == 0) {                 //        Visualize frame\n      canvas.clear(0x112F41);                          //       Clear background\n      canvas.rect(Vec(0.04), Vec(0.96)).radius(2).color(0x4FB99F).close();// Box\n      for(auto p:particles)canvas.circle(p.x).radius(2).color(p.c);//Particles\n      gui.update();                                              // Update image\n      // canvas.img.write_as_image(fmt::format(\"tmp/{:05d}.png\", f++));\n    }\n  }\n} //----------------------------------------------------------------------------\n\n/* -----------------------------------------------------------------------------\n** Reference: A Moving Least Squares Material Point Method with Displacement\n              Discontinuity and Two-Way Rigid Body Coupling (SIGGRAPH 2018)\n\n  By Yuanming Hu (who also wrote this 88-line version), Yu Fang, Ziheng Ge,\n           Ziyin Qu, Yixin Zhu, Andre Pradhana, Chenfanfu Jiang\n\n\n** Build Instructions:\n\nStep 1: Download and unzip mls-mpm88.zip (Link: http://bit.ly/mls-mpm88)\n        Now you should have \"mls-mpm88.cpp\" and \"taichi.h\".\n\nStep 2: Compile and run\n\n* Linux:\n    g++ mls-mpm88.cpp -std=c++14 -g -lX11 -lpthread -O3 -o mls-mpm\n    ./mls-mpm\n\n\n* Windows (MinGW):\n    g++ mls-mpm88.cpp -std=c++14 -lgdi32 -lpthread -O3 -o mls-mpm\n    .\\mls-mpm.exe\n\n\n* Windows (Visual Studio 2017+):\n  - Create an \"Empty Project\"\n  - Use taichi.h as the only header, and mls-mpm88.cpp as the only source\n  - Change configuration to \"Release\" and \"x64\"\n  - Press F5 to compile and run\n\n\n* OS X:\n    g++ mls-mpm88.cpp -std=c++14 -framework Cocoa -lpthread -O3 -o mls-mpm\n    ./mls-mpm\n\n\n** FAQ:\nQ1: What does \"1e-4_f\" mean?\nA1: The same as 1e-4f.\n\nQ2: What is \"real\"?\nA2: real = float in this file.\n\nQ3: What are the hex numbers like 0xED553B?\nA3: They are RGB color values.\n    The color scheme is borrowed from\n    https://color.adobe.com/Copy-of-Copy-of-Core-color-theme-11449181/\n\nQ4: How can I get higher-quality?\nA4: Change n to 320; Change dt to 1e-5; Change E to 2e4;\n    Change particle per cube from 500 to 8000 (Ln 72).\n    After the change, the whole animation takes ~3 minutes on my computer.\n\nQ5: How to record the animation?\nA5: Uncomment Ln 2 and 85 and create a folder named \"tmp\".\n    The frames will be saved to \"tmp/XXXXX.png\".\n\n    To get a video, you can use ffmpeg. If you already have taichi installed,\n    you can simply go to the \"tmp\" folder and execute\n\n      ti video 60\n\n    where 60 stands for 60 FPS. A file named \"video.mp4\" is what you want.\n\n\nFor more questions, please email yuanming _at_ mit.edu\n                    or visit https://github.com/yuanming-hu/taichi_mpm/issues.\n\n                                                       Last Update: Nov 16, 2018\n                                                       Version 1.4\n\n----------------------------------------------------------------------------- */\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tetris.cpp",
          "type": "blob",
          "size": 6.03125,
          "content": "#include \"taichi.h\"  // Note: You DO NOT have to install taichi or taichi_mpm.\nusing namespace taichi;  // You only need [taichi.h] - see below for\n                         // instructions.\nconst int n = 160 /*grid resolution (cells)*/, window_size = 800;\nconst real dt = 60e-4_f / n, frame_dt = 1e-3_f, dx = 1.0_f / n,\n           inv_dx = 1.0_f / dx;\nauto particle_mass = 1.0_f, vol = 1.0_f;\nauto hardening = 10.0_f, E = 1e4_f, nu = 0.2_f;\nreal mu_0 = E / (2 * (1 + nu)), lambda_0 = E * nu / ((1 + nu) * (1 - 2 * nu));\nusing Vec = Vector2;\nusing Mat = Matrix2;\n\nstruct Particle {\n  Vec x, v;\n  Mat F, C;\n  real Jp;\n  int c /*color*/;\n  int type;  // 0: elastic   1: plastic   2: liquid\n  Particle(Vec x, int c, int type, Vec v = Vec(0))\n      : x(x), v(v), F(1), C(0), Jp(1), c(c), type(type) {\n  }\n};\nstd::vector<Particle> particles;\nVector3 grid[n + 1][n + 1];  // velocity + mass, node_res = cell_res + 1\n\n// http://zetcode.com/tutorials/javaswingtutorial/thetetrisgame/\nint tetris_offsets[7][3][2] = {\n    // excluding center\n    {{0, -1}, {1, 0}, {0, -2}},  {{1, 1}, {-1, 0}, {1, 0}},\n    {{0, -1}, {-1, 0}, {0, -2}}, {{0, 1}, {1, 0}, {1, -1}},\n    {{1, 0}, {2, 0}, {-1, 0}},   {{0, 1}, {1, 1}, {1, 1}},\n    {{-1, 0}, {1, 0}, {0, 1}}};\n\nvoid advance(real dt) {\n  std::memset(grid, 0, sizeof(grid));  // Reset grid\n  for (auto &p : particles) {          // P2G\n    Vector2i base_coord =\n        (p.x * inv_dx - Vec(0.5_f)).cast<int>();  // element-wise floor\n    Vec fx = p.x * inv_dx - base_coord.cast<real>();\n    // Quadratic kernels  [http://mpm.graphics   Eqn. 123, with x=fx, fx-1,fx-2]\n    Vec w[3]{Vec(0.5) * sqr(Vec(1.5) - fx), Vec(0.75) - sqr(fx - Vec(1.0)),\n             Vec(0.5) * sqr(fx - Vec(0.5))};\n    auto e = std::exp(hardening * (1.0_f - p.Jp)), mu = mu_0 * e,\n         lambda = lambda_0 * e;\n    real J = determinant(p.F);  //                         Current volume\n    Mat r, s;\n    polar_decomp(p.F, r, s);  // Polar decomp. for fixed corotated model\n    Mat cauchy;\n    if (p.type == 2) {\n      cauchy = Mat(0.2_f * E * (pow<1>(p.Jp) - 1));\n    } else {\n      cauchy = 2 * mu * (p.F - r) * transposed(p.F) + lambda * (J - 1) * J;\n    }\n    auto stress =  // Cauchy stress times dt and inv_dx\n        -4 * inv_dx * inv_dx * dt * vol * cauchy;\n    auto affine = stress + particle_mass * p.C;\n    for (int i = 0; i < 3; i++)\n      for (int j = 0; j < 3; j++) {  // Scatter to grid\n        auto dpos = (Vec(i, j) - fx) * dx;\n        Vector3 mv(p.v * particle_mass,\n                   particle_mass);  // translational momentum\n        grid[base_coord.x + i][base_coord.y + j] +=\n            w[i].x * w[j].y * (mv + Vector3(affine * dpos, 0));\n      }\n  }\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j <= n; j++) {  // For all grid nodes\n      auto &g = grid[i][j];\n      if (g[2] > 0) {                   // No need for epsilon here\n        g /= g[2];                      //        Normalize by mass\n        g += dt * Vector3(0, -200, 0);  //                  Gravity\n        real boundary = 0.05, x = (real)i / n,\n             y = real(j) / n;  // boundary thick.,node coord\n        if (x < boundary || x > 1 - boundary || y > 1 - boundary)\n          g = Vector3(0);  // Sticky\n        if (y < boundary)\n          g[1] = std::max(0.0_f, g[1]);  //\"Separate\"\n      }\n    }\n  for (auto &p : particles) {  // Grid to particle\n    Vector2i base_coord =\n        (p.x * inv_dx - Vec(0.5_f)).cast<int>();  // element-wise floor\n    Vec fx = p.x * inv_dx - base_coord.cast<real>();\n    Vec w[3]{Vec(0.5) * sqr(Vec(1.5) - fx), Vec(0.75) - sqr(fx - Vec(1.0)),\n             Vec(0.5) * sqr(fx - Vec(0.5))};\n    p.C = Mat(0);\n    p.v = Vec(0);\n    for (int i = 0; i < 3; i++)\n      for (int j = 0; j < 3; j++) {\n        auto dpos = (Vec(i, j) - fx),\n             grid_v = Vec(grid[base_coord.x + i][base_coord.y + j]);\n        auto weight = w[i].x * w[j].y;\n        p.v += weight * grid_v;  // Velocity\n        p.C +=\n            4 * inv_dx * Mat::outer_product(weight * grid_v, dpos);  // APIC C\n      }\n    p.x += dt * p.v;                       // Advection\n    if (p.type <= 1) {                     // plastic\n      auto F = (Mat(1) + dt * p.C) * p.F;  // MLS-MPM F-update\n      if (p.type == 1) {\n        Mat svd_u, sig, svd_v;\n        svd(F, svd_u, sig, svd_v);\n        for (int i = 0; i < 2; i++)  // Snow Plasticity\n          sig[i][i] = clamp(sig[i][i], 1.0_f - 2.5e-2_f, 1.0_f + 7.5e-3_f);\n        real oldJ = determinant(F);\n        F = svd_u * sig * transposed(svd_v);\n        real Jp_new = clamp(p.Jp * oldJ / determinant(F), 0.6_f, 20.0_f);\n        p.Jp = Jp_new;\n      }\n      p.F = F;\n    } else {  // liquid\n      p.Jp *= determinant(Mat(1) + dt * p.C);\n    }\n  }\n}\n\nvoid add_object(Vec center, int type, int block) {\n  auto gen = [&](int k) {\n    Vector2 offset(0, 0);\n    if (k >= 0)\n      offset =\n          Vector2(tetris_offsets[block][k][0], tetris_offsets[block][k][1]);\n    int colors[] {0xED553B, 0xF2B134, 0x068587};\n    for (int i = 0; i < 30 * pow<2>(n / 80.0); i++)\n      particles.push_back(\n          Particle((Vec::rand() + offset) * 0.05_f + center, colors[type], type));\n  };\n  gen(-1);\n  gen(0);\n  gen(1);\n  gen(2);\n}\n\nint main() {\n  GUI gui(\"MLS-MPM Tetris\", window_size, window_size);\n  for (int i = 0; i < 7; i++) {\n    add_object(Vector2(0.3 + i % 2 * 0.3, 0.2 + i * 0.08), i % 3, i);\n  }\n  auto &canvas = gui.get_canvas();\n  int f = 0;\n  for (int i = 0;; i++) {               //              Main Loop\n    advance(dt);                        //     Advance simulation\n    if (i % int(frame_dt / dt) == 0) {  //        Visualize frame\n      canvas.clear(0x112F41);           //       Clear background\n      canvas.rect(Vec(0.04), Vec(0.96))\n          .radius(2)\n          .color(0x4FB99F)\n          .close();  // Box\n      for (auto p : particles)\n        canvas.circle(p.x).radius(2).color(p.c);  // Particles\n      gui.update();                               // Update image\n      // canvas.img.write_as_image(fmt::format(\"tmp/{:05d}.png\", f++));\n    }\n  }\n}  //----------------------------------------------------------------------------\n\n// g++ tetris.cpp -std=c++14 -g -lX11 -lpthread -O3 -o tetris && ./tetris"
        }
      ]
    }
  ]
}