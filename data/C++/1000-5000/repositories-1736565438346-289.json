{
  "metadata": {
    "timestamp": 1736565438346,
    "page": 289,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Tencent/phxpaxos",
      "stars": 3358,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.6162109375,
          "content": "[submodule \"third_party/gtest\"]\n\tpath = third_party/gtest\n\turl = https://github.com/google/googletest\n\tbranch = release-1.6.0\n[submodule \"third_party/gflags\"]\n\tpath = third_party/gflags\n\turl = https://github.com/gflags/gflags\n[submodule \"third_party/protobuf\"]\n\tpath = third_party/protobuf\n\turl = https://github.com/google/protobuf\n[submodule \"third_party/glog\"]\n\tpath = third_party/glog\n\turl = https://github.com/google/glog\n[submodule \"third_party/leveldb\"]\n\tpath = third_party/leveldb\n\turl = https://github.com/google/leveldb\n[submodule \"third_party/gmock\"]\n\tpath = third_party/gmock\n\turl = https://github.com/google/googlemock\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.193359375,
          "content": "# Ubuntu 14.04 Trusty support\nsudo: required\ndist: trusty\n\nlanguage: cpp\ncompiler: g++\ngit:\n    submodules: false\nscript:\n    - ./build.sh\nnotifications:\n    email: true\nbranches:\n  only:\n  - /.*/\n\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.1494140625,
          "content": "# Names should be added to this file like so:\n# Name or Organization <email address>\n\nTencent Inc.\n\nHaochuan Cui \nDuokai Huang \nJunechao Chen \nMing Chen\n"
        },
        {
          "name": "INSTALL",
          "type": "blob",
          "size": 2.9990234375,
          "content": "Installation Instructions\n*************************\n\nCopyright (C) 2016 Tencent.\n\nThis file is free documentation; the Free Software Foundation gives\nunlimited permission to copy, distribute and modify it.\n\nPhxPaxos-Specific Installation Notes\n====================================\n\n*** NOTE FOR 64-BIT LINUX SYSTEMS\n\nThe PhxPaxos library has to be built on 64-bit systems or you may\nexperience some problems.\n\nBasic Installation\n==================\n\nBriefly, the shell commands `sh autoinstall.sh; make;' should configure \nand build this package. The following more-detailed instructions are \ngeneric; see the `README' file for instructions specific to this package.\n\n   The `autoinstall.sh' shell script attempts to guess correct values \nfor various system-dependent variables used during compilation. It \nuses those values and Makefile.define in each directory which describes \nthe source files infomation to create a `Makefile' in each directory of \nthe package. \n\n   The file `makefile.mk' is used to set options of the compilation \nenvironment. You need modify it if you want to change the options including\nthe paths of the third party libraries, like glog, leveldb, and protobuf.\n\n   The grpc library is required if you want to complile the example \nsource.\n\nThe simplest way to compile this package is:\n  1. Make sure the third party libraries, protobuf (3.0 or above) and \n  leveldb, have been installed in the system. If you want to test the \n  samples, libraries of glog and grpc are also required.\n\n  2. `cd' to the directory containing the package's source code and type\n     `sh autoinstall.sh' to configure the package for your system.\n\n  3. Type `make' to compile the package.\n\n  4. Type `make install' to install the programs and any data files and\n  documentation.\n\n  5. You can remove the program binaries and object files from the source \n  code directory by typing `make clean'.  \n\nCompilers and Options\n=====================\n\nGlibc 2.12 or above, as well as 64bit option and C++ 11 support in compiler,\nis required to build the library.\n\nIf you want to include more options, modifying the makefile.mk file in \nthe source code directory is a good idea.\n\nInstallation Position--------------TODO\n=====================\n\nLibraries are under ./lib and include files are under ./include, related to \nthe local source code directory.\n\nInstallation Names\n==================\n\nBy default, `make install' installs the package's commands under\n`./lib', include files under `./include', etc.  You\ncan specify an installation prefix by giving `autointall.sh' the option \n`--prefix=PREFIX'.\n\nInstallation Plugin \n==============\n\nUsage of Plugin can be found in plugin directory \n\nThe simplest way to compile this plugin is:\n\n  1. `cd plugin' to the plugin directory containing the plugin library's \n  source code.\n\n  2. Type `make' to compile the plugin.\n\n  3. Type `make install' to install the programs and any data files and\n  documentation.\n\n  4. You can remove the program binaries and object files from the source \n  code directory by typing `make clean'.  \n\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 9.2216796875,
          "content": "Tencent is pleased to support the open source community by making \nPhxPaxos available.  \n\nSee the AUTHORS file for names of contributors.\n\nCopyright (C) 2016 THL A29 Limited, a Tencent company.  \nAll rights reserved.\nIf you have downloaded a copy of the PhxPaxos binary from Tencent, \nplease note that the PhxPaxos binary is licensed under \nthe BSD 3-Clause License.\nIf you have downloaded a copy of the PhxPaxos source code from \nTencent, please note that PhxPaxos source code is licensed under \nthe BSD 3-Clause License, except for the third-party components \nlisted below which are subject to different license terms.  Your \nintegration of PhxPaxos into your own projects may require \ncompliance with the BSD 3-Clause License, as well as the other \nlicenses applicable to the third-party components included within \nPhxPaxos.\n\nA copy of the BSD 3-Clause License is included in this file.\nOther dependencies and licenses:\n\nOpen Source Software Licensed under the OpenSSL License:\n------------------------------------------------------------------\n1. OpenSSL  1.0.2h\nCopyright (c) 1998-2016 The OpenSSL Project.  \nAll rights reserved.\nCopyright (C) 1995-1998 Eric Young (eay@cryptsoft.com) \nAll rights reserved.\n\n\nTerms of the OpenSSL License:\n------------------------------------------------------------------\n\nOpenSSL \nThe OpenSSL toolkit stays under a dual license, i.e. both the \nconditions of the OpenSSL License and the original SSLeay license \napply to the toolkit.  The contents of this file are subject to \nOpenSSL License; you may not use this file except in compliance \nwith the License. You may obtain a copy of the License at \nhttp://www.openssl.org/source/license.html \n\nCopyright (c) 1998-2016 The OpenSSL Project.  \nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions \nare met:\n\n1. Redistributions of source code must retain the above copyright \nnotice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright \nnotice, this list of conditions and the following disclaimer in the \ndocumentation and/or other materials provided with the distribution.\n\n3. All advertising materials mentioning features or use of this \nsoftware must display the following acknowledgment: \n\"This product includes software developed by the OpenSSL Project \nfor use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n\n4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be \nused to endorse or promote products derived from this software \nwithout prior written permission.  For written permission, please \ncontact openssl-core@openssl.org.\n\n5. Products derived from this software may not be called \"OpenSSL\" \nnor may \"OpenSSL\" appear in their names without prior written \npermission of the OpenSSL Project.\n\n6. Redistributions of any form whatsoever must retain the following \nacknowledgment: \n\"This product includes software developed by the OpenSSL Project \nfor use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n\nTHIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY \nEXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, \nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR \nPURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE OpenSSL PROJECT OR \nITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF \nUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED \nAND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, \nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY \nOUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY \nOF SUCH DAMAGE. \n\n* This product includes cryptographic software written by Eric Young \n(eay@cryptsoft.com).  This product includes software written by \nTim Hudson (tjh@cryptsoft.com).\n\n====================================================================\n\nThe contents of this file are subject to SSLeay License; you may not \nuse this file except in compliance with the License. You may obtain \na copy of the License at \n\nhttp://www.openssl.org/source/license.html\nCopyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\nAll rights reserved.\n\nThis package is an SSL implementation written by Eric Young \n(eay@cryptsoft.com).\nThe implementation was written so as to conform with Netscapes SSL.\nThis library is free for commercial and non-commercial use as long \nas the following conditions are aheared to. The following conditions \napply to all code found in this distribution, be it the RC4, RSA, \nlhash, DES, etc., code; not just the SSL code. The SSL documentation \nincluded with this distribution is covered by the same copyright \nterms except that the holder is Tim Hudson (tjh@cryptsoft.com).  \nCopyright remains Eric Young's, and as such any Copyright notices \nin the code are not to be removed.  If this package is used in a \nproduct, Eric Young should be given attribution as the author of \nthe parts of the library used. This can be in the form of a textual \nmessage at program startup or in documentation (online or textual) \nprovided with the package. \n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions \nare met:\n1. Redistributions of source code must retain the copyright notice, \nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright \nnotice, this list of conditions and the following disclaimer in the \ndocumentation and/or other materials provided with the distribution.\n\n3. All advertising materials mentioning features or use of this \nsoftware must display the following acknowledgement:\" This product \nincludes cryptographic software written by Eric Young \n(eay@cryptsoft.com)\" The word 'cryptographic' can be left out if \nthe rouines from the library being used are not cryptographic \nrelated :-).\n\n4. If you include any Windows specific code (or a derivative thereof) \nfrom the apps directory (application code) you must include an \nacknowledgement: \"This product includes software written by Tim Hudson \n(tjh@cryptsoft.com)\"\n\nTHIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND ANY EXPRESS \nOR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \nARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE \nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, \nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, \nOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY \nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR \nTORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT \nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY \nOF SUCH DAMAGE. \n\nThe licence and distribution terms for any publically available \nversion or derivative of this code cannot be changed.  i.e. this \ncode cannot simply be copied and put under another distribution \nlicence [including the GNU Public Licence.]\n\n\nOpen Source Software Licensed under the BSD 3-Clause License:\n--------------------------------------------------------------------\n1. grpc  0.14.0.dev0\nCopyright 2015, Google Inc.\nAll rights reserved.\n\n2. glog  0.3.3\nCopyright (c) 2008, Google Inc.\nAll rights reserved.\nCopyright (c) 2003-2008, Jouni Malinen <j@w1.fi> and contributors\nAll Rights Reserved.\n\n3. leveldb  1.1\nCopyright (c) 2011 The LevelDB Authors.\nAll rights reserved.\n\n4. protobuf  3.0.0-beta-1\nCopyright 2014, Google Inc.  \nAll rights reserved.\n\n5. googletest  1.6.0\nCopyright 2008, Google Inc.\nAll rights reserved.\n\n\nTerms of the BSD 3-Clause License:\n--------------------------------------------------------------------\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions \nare met:\n\n1\tRedistributions of source code must retain the above copyright \nnotice, this list of conditions and the following disclaimer.\n\n2\tRedistributions in binary form must reproduce the above copyright \nnotice, this list of conditions and the following disclaimer in the \ndocumentation and/or other materials provided with the distribution.\n\n3\tNeither the name of [copyright holder] nor the names of its \ncontributors may be used to endorse or promote products derived from \nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS \nFOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE \nCOPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, \nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, \nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; \nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER \nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT \nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN \nANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \nPOSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "Makefile.define",
          "type": "blob",
          "size": 0.9287109375,
          "content": "# Tencent is pleased to support the open source community by making \n# PhxPaxos available.\n# Copyright (C) 2016 THL A29 Limited, a Tencent company. \n# All rights reserved.\n# \n# Licensed under the BSD 3-Clause License (the \"License\"); you may \n# not use this file except in compliance with the License. You may \n# obtain a copy of the License at\n# \n# https://opensource.org/licenses/BSD-3-Clause\n# \n# Unless required by applicable law or agreed to in writing, software \n# distributed under the License is distributed on an \"AS IS\" basis, \n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or \n# implied. See the License for the specific language governing \n# permissions and limitations under the License.\n# \n# See the AUTHORS file for names of contributors. \n\nallobject=elibphxpaxos.a \n\nPHXPAXOS_OBJ=\n\nPHXPAXOS_LIB=src/node:node include:include\n\nPHXPAXOS_SYS_LIB=\n\nPHXPAXOS_INCS=$(SRC_BASE_PATH)/ \n\nPHXPAXOS_EXTRA_CPPFLAGS=-Wall -Werror\n\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 0.185546875,
          "content": "This repository contains a C++ implementation of the Phxpaxos module.  \n\nSee INSTALL for (generic) installation instructions for C++: basically\n   sh autoinstall.sh && make  && make install\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.5390625,
          "content": "[简体中文README](https://github.com/Tencent/phxpaxos/blob/master/README.zh_CN.md)\n\n**PhxPaxos is a state-synchronization lib based on Paxos protocol, it is totally designed by Wechat independently. It can help your services in synchronizing the state from a single node to the other nodes to form a multi-copy cluster and handling fail-over automatically by calling functions in our lib.**\n\n**This lib has been used in Wechat production environment, we have also tested it in a large number of harsh environments to guarantee a stable consistency.**\n\nAuthors: Haochuan Cui, Ming Chen, Junchao Chen and Duokai Huang \n\nContact us: phxteam@tencent.com\n\n[Principle details(Chinese)](http://mp.weixin.qq.com/s?__biz=MzI4NDMyNTU2Mw==&mid=2247483695&idx=1&sn=91ea422913fc62579e020e941d1d059e#rd)\n\nPhxPaxos [![Build Status](https://travis-ci.org/Tencent/phxpaxos.png)](https://travis-ci.org/Tencent/phxpaxos)\n\n# Features\n  * Purely based on [Paxos Made Simple](http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf) by Lamport. \n  * Transfering message in a async mechanism architecture.\n  * Using `fsync` to guarantee the correctness in every IO write operations.\n  * Latency of a successful `Propose` is one RTT and one IO write. \n  * Using P2P stream protocol to learn paxos log.\n  * Cleaning `Checkpoint` and `PaxosLog` automatically.\n  * Pulling `Checkpoint` across nodes automatically.\n  * Supporting more than one state-machines in a single PhxPaxos Instance.\n  * Supporting recover checkpoint by snapshot+paxoslog automatically.\n  * Implementing Master election as a state-machine embedded in PhxPaxos\n  * Implementing reconfiguration as a state-machine embedded in PhxPaxos\n  * Using signature algorithm embedded in PhxPaxos to recognise invalid hosts.\n  * Using checksum to verifying the data consistency of increment data in realtime.\n  * Implementing Network, Stroage, Monitor, Logging module as a plugin, they can be implemented customly \n  * Supporting overload protection in a self-adaption way.\n  \n# Limitations\n  * Only a single process (possibly multi-threaded) can run a PhxPaxos instance at a time.\n  * There is no client-server support builtin to the library. An application that needs such support will have to wrap their own server around the library.\n  * PhxPaxos was only tested on Linux 64bit platform so far.\n  \n# Performance\n### Setup\n\n    CPU: 24 x Intel(R) Xeon(R) CPU E5-2420 0 @ 1.90GHz\n    Memory: 2 GB\n    Disk: ssd raid5\n    Network: Gigabit Ethernet\n    Cluster Nodes: 3\n    Ping: 0.05ms\n    Parallel client: 100 Threads\n    \n### Performance Test Result(QPS)\n> Request latency small than 10ms.\n###### Data set with small size(100B)\n    1 Group: 1171\n    20 Groups: 11931\n    50 Groups: 13424\n    100 Groups: 13962\n###### Data set with larse size(100KB)\n    1 Group: 280\n    20 Groups: 984\n    50 Groups: 1054\n    100 Groups: 1067\n###### BatchPropose(2KB)\n    100 Groups: 150000\n\n# Code Directory Introduction\n**include:** This directory includes all head files while using PhxPaxos. You may make some mistakes if you don't understand all the functions in this directory completely.\n>NOTE: The public interface is in include/*.h. Callers should not include or rely on the details of any other header files in this package. Those internal APIs may be changed without warning.\n\n**src:** This directory includes all implementation of Phapaxos, You can figure out the working principle of PhxPaoxs by reading this directorys. No neccessary to read it if you are only using PhxPaxos.\n\n**third_party:** This directory is designed to place all third party libs for compiling and running PhxPaxos. You can get a detail in the following compilation section. We have only two libs requirement: Protobuf and LevelDB.\n\n**plugin:** This directory provides the plugin of Logging module. Loggins is an important way to debug a program. But different organazations always implement it in a totally different way. So PhxPaxos does not provide a specific implementation of Logging, instead, it provides the mechanism of Logging so everyone can implement it customly. We also implement a specific Logging by using GLOG for you. If you are using GLOG this may help you in saving your development time.\n\n**sample:** This directory provides 3 samples based on PhxPaoxs, They representive different depth of using PhxPaxos, from easy to hard.\n * PhxElection: This is a very simple program. It implements a Master Election Program by a Master Election state-machine which is embedded in PhxPaxos.\n * PhxEcho: This shows how to program a status-machine and combine it with PhxPaxos.\n * PhxKV: This is a more complete system. which implements a KV state-machine. It shows how to implement a distributed KV storage system by PhxPaxos and how to delete PaxosLog by implementing the Checkpoint API. It also shows how to combine this code into a RPC(etc: GRPC) framework to get a complete distributed KV storage system.\n\n# Guide to Header Files:\n * **include/node.h** The beginning of PhxPaxos. We strongly suggest you to begin here.\n * **include/options.h** Some configurations and options needed while running PhxPaxos.\n * **include/sm.h** A base class of state-machine.\n * **include/def.h** Sets of return code.\n * **include/network.h** Abstract function of Network Module. You can use your own network protocol by overloading these functions.\n * **include/storage.h** Abstract function of Storage Module.\n * **include/log.h** Abstract function of Logging Module.\n * **include/breakpoint.h** Abstract function of breaking points, add your ownMonitor Module here to monitor these break points. \n \n# How to Compile\n### Third party libs preparation\nFollowing is a dependency relationship tablet of all directories.\n\n| Directories             | compilation target        | inner dependency       | third party dependency     |\n| ------------------ | -------------------- | ---------------------------------- | ---------------- |\n| root             | libphxpaxos.a        | None                                 | protobuf,leveldb |\n| plugin             | libphxpaxos_plugin.a | libphxpaxos.a                      | glog             |\n| sample/phxelection | Executable program           | libphxpaxos.a,libphxpaxos_plugin.a | None               |\n| sample/phxecho     | Executable program           | libphxpaxos.a,libphxpaxos_plugin.a | None               |\n| sample/phxkv       | Executable program           | libphxpaxos.a,libphxpaxos_plugin.a | grpc             |\n| src/ut             | Unit tests             | None                                 | gtest,gmock      |\n\nWe only need 2 third party libs: Protobuf and Leveldb while compiling PhxPaxos library(target is libphxpaoxs.a).But we need GLOG and GRPC while compiling other directories. All these third party libs should be prepared and palced in our `third_party` directory before PhxPaxos compilation. You can `git clone` them by adding `--recurse-submodules` on just download and link them.\n\n### Compilation Enviroment\n * Linux\n * GCC-4.8 or above\n \n### Compilation and Installation\n\n###### How to Complie libphxpaxos.a.\n \nExecute following shell commands in root directory of PhxPaxos\n```Bash\n./autoinstall.sh\nmake\nmake install\n```\n\n###### How to Complie libphxpaxos_plugin.a.\n \nExecute following shell commands in plugin directory.\n```Bash\nmake\nmake install\n```\n\n# How to Wrap Your Own Code Around PhxPaxos.\n### First choose a single node service.\nWe will show you this by a PhxEcho service in our `sample` directory, Echo is a common test functions while writing an RPC service. We will wrap this service's code around PhxPaxos to make Echo into a multi-node service.\n\nFirst, Assume following is the definition fo PhxEchoServer\n```c++\nclass PhxEchoServer\n{\npublic:\n    PhxEchoServer();\n    ~PhxEchoServer();\n\n    int Echo(const std::string & sEchoReqValue, std::string & sEchoRespValue);\n};\n```\nLet's wrap this code around PhxPaxos.\n\n### Second, implement a state-machine\nWe now define a PhxEchoSM state-machine which inherit from class `StateMachine` as the following\n```c++\nclass PhxEchoSM : public phxpaxos::StateMachine\n{\npublic:\n    PhxEchoSM();\n\n    bool Execute(const int iGroupIdx, const uint64_t llInstanceID, \n            const std::string & sPaxosValue, phxpaxos::SMCtx * poSMCtx);\n\n    const int SMID() const { return 1; }\n};\n```\n`SMID()` functions should return an unique identifier since PhxPaxos support more than 1 state-machines at the same time.\n\n`Execute()` is a state transition function of this state-machine. PhxPaxos guarantees all nodes will execute `sPaxosValue` in the same order to achieve strong consistency (`sPaxosValue` is one of input arguments of `Execute()`).  Following is the implementation of this functions:\n\n```c++\nbool PhxEchoSM :: Execute(const int iGroupIdx, const uint64_t llInstanceID, \n        const std::string & sPaxosValue, SMCtx * poSMCtx)\n{\n    printf(\"[SM Execute] ok, smid %d instanceid %lu value %s\\n\", \n            SMID(), llInstanceID, sPaxosValue.c_str());\n\n    //only commiter node have SMCtx.\n    if (poSMCtx != nullptr && poSMCtx->m_pCtx != nullptr)\n    {   \n        PhxEchoSMCtx * poPhxEchoSMCtx = (PhxEchoSMCtx *)poSMCtx->m_pCtx;\n        poPhxEchoSMCtx->iExecuteRet = 0;\n        poPhxEchoSMCtx->sEchoRespValue = sPaxosValue;\n    }   \n\n    return true;\n}\n```\nWe only print it on the screen as a prove of broadcasting this Echo message.\n\nHere we got a strange class `SMCtx`, following is the definition.\n```c++\nclass SMCtx\n{\npublic:\n    SMCtx();\n    SMCtx(const int iSMID, void * pCtx);\n\n    int m_iSMID;\n    void * m_pCtx;\n};\n```\n`SMCtx` is a context argument which is provide by proposer(we will offer more details in the following introduction), transmitted to `Execute()` function by PhxPaxos and finally callback to proposer.\n\n`m_iSMID` is related to `SMID()` function mentioned above.PhxPaxos will transmit this to a specific state-machine which owns the same id.\n\n`m_pCtx` is a customly context point address provided by proposer.\n\n>The context arguments of `Execute()` functions is a nullptr in all nodes except the one which propose it. \nDeveloper should judge if it is NULL while implementing, otherwise it will cause a segment fault.\n\nFollowing shows the context definition of Echo:\n```c++\nclass PhxEchoSMCtx\n{\npublic:\n    int iExecuteRet;\n    std::string sEchoRespValue;\n\n    PhxEchoSMCtx()\n    {   \n        iExecuteRet = -1; \n    }   \n};\n```\n`iExecuteRet` represents the return code of `Execute()` execution. \n\n`sEchoRespValue` represents the `sEchoReqValue` transmit by `Execute()`.\n\nWe finally construct a state-machine and a state transmittion function by classes above.\n\n>HINT: What you should do to make a service into a replicated service is to abstract the logic of it. And then implement it in a `Execute()` fuction. That's all:)\n\n### Running PhxPaxos\nAfter the implementation, We will try to run PhxPaxos with `PhxEchoSM` loaded.\n\nWe will do some modifications for `EchoServer class` first:\n```c++\nclass PhxEchoServer\n{\npublic:\n    PhxEchoServer(const phxpaxos::NodeInfo & oMyNode, const phxpaxos::NodeInfoList & vecNodeList);\n    ~PhxEchoServer();\n\n    int RunPaxos();\n    int Echo(const std::string & sEchoReqValue, std::string & sEchoRespValue);\n\n    phxpaxos::NodeInfo m_oMyNode;\n    phxpaxos::NodeInfoList m_vecNodeList;\n\n    phxpaxos::Node * m_poPaxosNode;\n    PhxEchoSM m_oEchoSM;\n};\n```\n\nWe add some arguments in construction function, `oMyNode` represents the information(IP, Port, etc...) of this node.\n`vecNodeList` represents informations of all nodes in this cluster.\nThese 2 arguments is pre-defined by PhxPaxos.\n\nExcept `m_oMyNode` and `m_vecNodeList`, `m_oEchoSM` is a state-machine we just finished, `m_poPaxosNode` represents the instance pointer of PhxPaxos running this time.\n\nPhxPaxos instance is actived by executing `RunPaxos()` function, following is the implementation of this function:\n\n```c++\nint PhxEchoServer :: RunPaxos()\n{\n    Options oOptions;\n\n    int ret = MakeLogStoragePath(oOptions.sLogStoragePath);\n    if (ret != 0)\n    {   \n        return ret;\n    }   \n\n    //this groupcount means run paxos group count.\n    //every paxos group is independent, there are no any communicate between any 2 paxos group.\n    oOptions.iGroupCount = 1;\n\n    oOptions.oMyNode = m_oMyNode;\n    oOptions.vecNodeInfoList = m_vecNodeList;\n\n    GroupSMInfo oSMInfo;\n    oSMInfo.iGroupIdx = 0;\n    //one paxos group can have multi state machine.\n    oSMInfo.vecSMList.push_back(&m_oEchoSM);\n    oOptions.vecGroupSMInfoList.push_back(oSMInfo);\n\n    //use logger_google to print log\n    LogFunc pLogFunc;\n    ret = LoggerGoogle :: GetLogger(\"phxecho\", \"./log\", 3, pLogFunc);\n    if (ret != 0)\n    {   \n        printf(\"get logger_google fail, ret %d\\n\", ret);\n        return ret;\n    }   \n\n    //set logger\n    oOptions.pLogFunc = pLogFunc;\n\n    ret = Node::RunNode(oOptions, m_poPaxosNode);\n    if (ret != 0)\n    {   \n        printf(\"run paxos fail, ret %d\\n\", ret);\n        return ret;\n    }   \n\n    printf(\"run paxos ok\\n\");\n    return 0;\n}\n```\nAll arguments and options have been included in `Option` variable while running PhxPaxos instance.\n\n`MakeLogStoragePath()` function genereate the path where to storage paxos data and it will be set to oOptions.sLogStoragePath.\n`oOptions.iGroupCount` represents how many groups running at the same time. They are identified by `GroupIdx`\n (the range is [0, oOptions.iGroupCount) ). Different groups run in a independent space and have no connection with the others groups. Why we put them into a single instance is to make them share the IP/Port.\n\nAfter configuring all IP/Port informations we will configure the state-machine we just finished.\n\n`oOptions.vecGroupSMInfoList` is a array of `GroupSMInfo` class, it represents a list of status-machines corresponding to every specific group. \n\n`GroupSMInfo` is a class which is used to describe a state-machine info for a specific group. `GroupSMInfo.iGroupIdx` is the identifier of this group. It will set to be 0 since we have only 1 group.\n\n`vecSMList` is an array of state-machine class. It represents a list of state-machines which we want to load into PhxPaxos. \n\nConfig the Logging functions next, we used GLOG here.\n\nAt last, Execute `Node::RunNode(oOptions, m_poPaxosNode)` to run PhxPaxos. Return code 0 means we have active it successfully and `m_poPaxosNode` point to this PhxPaxos instance.\n\n# Proposing Requests\nThe following codes shows how to reform `Echo()` in `EchoServer` to propose a value in PhxPaxos:\n```c++\nint PhxEchoServer :: Echo(const std::string & sEchoReqValue, std::string & sEchoRespValue)\n{\n    SMCtx oCtx;\n    PhxEchoSMCtx oEchoSMCtx;\n    //smid must same to PhxEchoSM.SMID().\n    oCtx.m_iSMID = 1;\n    oCtx.m_pCtx = (void *)&oEchoSMCtx;\n\n    uint64_t llInstanceID = 0;\n    int ret = m_poPaxosNode->Propose(0, sEchoReqValue, llInstanceID, &oCtx);\n    if (ret != 0)\n    {   \n        printf(\"paxos propose fail, ret %d\\n\", ret);\n        return ret;\n    }   \n\n    if (oEchoSMCtx.iExecuteRet != 0)\n    {   \n        printf(\"echo sm excute fail, excuteret %d\\n\", oEchoSMCtx.iExecuteRet);\n        return oEchoSMCtx.iExecuteRet;\n    }   \n\n    sEchoRespValue = oEchoSMCtx.sEchoRespValue.c_str();\n\n    return 0;\n}\n```\nFirst we define a context variable `oEchoSMCtx` and assigned to `oCtx.m_pCtx`.\n\n`oCtx.m_iSMID` set to 1 which corresponding to `SMID()` above, indicate this request will be executed in the state-machine which SMID is 1.\n\nThen call `m_poPaxosNode->Propose` with following arguments:\n\n`GroupIdx`: it indicates which group we will propose this request. The value is 0 here.\n`sEchoReqValue`: indicates what we want to propose.\n`llInsanceID`: A return arugments we got after proposed successfully, it is global incremented.\n`oCtx`: The context variable which will be transmitted to `Execute()` function.\n\nThe propose will return 0 if it was proposed successfully, You can get `sEchoRespValue` in the context variable.\n\nAfter all the steps above, we enhanced a Echo service from a single node into a cluster:)\n\n### The Running Perfomance\nThe output of Echo cluster is shown in the following. You can implement it by yourself or just compile `sample/phxeco` directory to get this program.\n\nWe have 3 nodes in this cluster. Following output came from The node which proposed the value:\n```c++\nrun paxos ok\necho server start, ip 127.0.0.1 port 11112\n\nplease input: <echo req value>\nhello phxpaxos:)\n[SM Execute] ok, smid 1 instanceid 0 value hello phxpaxos:)\necho resp value hello phxpaxos:)\n```\n\nWe listened on 127.0.0.1:11112. Add we sent \"hello phxpaxos\" as an input. Then `Execute()` funtion printed `[SM Execute] ok...` as the code we write above, we also got the same `EchoRespValue` at the context variable at the same time.\n\nLet's see what happend in the other nodes:\n```c++\nrun paxos ok\necho server start, ip 127.0.0.1 port 11113\n\nplease input: <echo req value>\n[SM Execute] ok, smid 1 instanceid 0 value hello phxpaxos:)\n```\n\nThis one listend on 127.0.0.1:11113, The `Execute()` function also printed \"hello phxpaxos\".\n\n# Got a election feature for your service by using Master Election in PhxPaxos.\n\nHere we want to explain the exact meaning of Master: Master is a special role in a cluster.At any given moment, there is only one node that considers itself as master at most (remember no master exists is legal.).\n\nThis is a very pratical. Assume there is a cluster of multi machines and we wish only one machines to serve at any given moment. The common way to achive this is to build up a Zookeeper cluster and implement a distributed lock service. But now\ndozens of lines of code will help you to implement this feature by using our Master Election feature. You don't any extra big modules now.\n\nFollowing will show you how to embed Master Election into your own service.\n\nFirst we construct a election class `PhxElection` for existing modules.\n```c++\nclass PhxElection\n{\npublic:\n    PhxElection(const phxpaxos::NodeInfo & oMyNode, const phxpaxos::NodeInfoList & vecNodeList);\n    ~PhxElection();\n\n    int RunPaxos();\n    const phxpaxos::NodeInfo GetMaster();\n    const bool IsIMMaster();\n\nprivate:\n    phxpaxos::NodeInfo m_oMyNode;\n    phxpaxos::NodeInfoList m_vecNodeList;\n    phxpaxos::Node * m_poPaxosNode;\n};\n```\nIt has two APIs: `GetMaster` to get current master of this cluster and `IsIMMaster` indicate whether I(the node) am master now.\n\nThen implement `RunPaxos()` function:\n```c++\nint PhxElection :: RunPaxos()\n{\n    Options oOptions;\n\n    int ret = MakeLogStoragePath(oOptions.sLogStoragePath);\n    if (ret != 0)\n    {   \n        return ret;\n    }   \n\n    oOptions.iGroupCount = 1;\n\n    oOptions.oMyNode = m_oMyNode;\n    oOptions.vecNodeInfoList = m_vecNodeList;\n\n    //open inside master state machine\n    GroupSMInfo oSMInfo;\n    oSMInfo.iGroupIdx = 0;\n    oSMInfo.bIsUseMaster = true;\n\n    oOptions.vecGroupSMInfoList.push_back(oSMInfo);\n\n    ret = Node::RunNode(oOptions, m_poPaxosNode);\n    if (ret != 0)\n    {   \n        printf(\"run paxos fail, ret %d\\n\", ret);\n        return ret;\n    }   \n\n    //you can change master lease in real-time.\n    m_poPaxosNode->SetMasterLease(0, 3000);\n\n    printf(\"run paxos ok\\n\");\n    return 0;\n}\n```\n\nThe difference between `MasterElection` and `Echo` is there is no neccessary to implement your own state-machine this time, instead, you can set `oSMInfo.bIsUseMaster` to `true` to enable our embedded MasterElection state-machine.\n\nThen, run `Node::RunNode()` to get the pointer of PhxPaxos instance.\nYou can set the lease length of Master by using `SetMasterLease` API at any moment.\n\nFinally, We can get master information from this pointer like following shows:\n\n```c++\nconst phxpaxos::NodeInfo PhxElection :: GetMaster()\n{\n    //only one group, so groupidx is 0.\n    return m_poPaxosNode->GetMaster(0);\n}\n\nconst bool PhxElection :: IsIMMaster()\n{\n    return m_poPaxosNode->IsIMMaster(0);\n}\n```\nNow, every node in the cluster can get master information now by the codes above.\n\n# Welcome to have a try and give us your suggestion :)\n"
        },
        {
          "name": "README.zh_CN.md",
          "type": "blob",
          "size": 19.5263671875,
          "content": "<img align=\"right\" src=\"http://mmbiz.qpic.cn/mmbiz/UqFrHRLeCAkOcYOjaX3oxIxWicXVJY0ODsbAyPybxk4DkPAaibgdm7trm1MNiatqJYRpF034J7PlfwCz33mbNUkew/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1\" hspace=\"15\" width=\"300px\" style=\"float: right\">\n\n**PhxPaxos是腾讯公司微信后台团队自主研发的一套基于Paxos协议的多机状态拷贝类库。它以库函数的方式嵌入到开发者的代码当中，\n使得一些单机状态服务可以扩展到多机器，从而获得强一致性的多副本以及自动容灾的特性。**\n**这个类库在微信服务里面经过一系列的工程验证，并且我们对它进行过大量的恶劣环境下的测试，使其在一致性的保证上更为健壮。**\n\n作者：Haochuan Cui, Ming Chen, Junchao Chen 和 Duokai Huang \n\n联系我们：phxteam@tencent.com\n\n想了解更多, 以及更详细的编译手册，请进入[中文WIKI](https://github.com/Tencent/phxpaxos/wiki)，和扫描右侧二维码关注我们的公众号\n\n[关于实现的一些原理细节](http://mp.weixin.qq.com/s?__biz=MzI4NDMyNTU2Mw==&mid=2247483695&idx=1&sn=91ea422913fc62579e020e941d1d059e#rd)\n\n# 特性\n  * 基于Lamport的 [Paxos Made Simple](http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf) 进行工程化，不进行任何算法变种。\n  * 使用基于消息传递机制的纯异步工程架构。\n  * 每次写盘使用fsync严格保证正确性。\n  * 一次Propose（写入数据）的Latency为一次RTT，均摊单机写盘次数为1次。\n  * 使用点对点流式协议进行快速学习。\n  * 支持Checkpoint以及对PaxosLog的自动清理。\n  * 支持跨机器的Checkpoint自动拉取。\n  * 一个PhxPaxos实例可以同时挂载多个状态机。\n  * 可使用镜像状态机模式进行Checkpoint的自动生成。\n  * 内置Master选举功能。\n  * 线上数据的实时增量checksum校验。\n  * 网络、存储、监控、日志模块插件化，可由开发者自定义。\n  * 基于Paxos算法的安全的成员变更。\n  * 基于Paxos算法的集群签名保护，隔离非法签名的错误机器。\n  * 自适应的过载保护。\n  \n# 局限\n  * 一个PhxPaxos实例任一时刻只允许运行在单一进程（容许多线程）。\n  * 这个类库没有内建对client-server的支持，开发者必须将类库的代码嵌入到自己的服务器代码里面，以实现这个功能。\n  * PhxPaxos只容许运行在64位的Linux平台。\n  \n# 性能\n### 运行环境\n\n    CPU：24 x Intel(R) Xeon(R) CPU E5-2420 0 @ 1.90GHz\n    内存：32 GB\n    硬盘：ssd raid5\n    网卡：千兆网卡\n    集群机器个数： 3个\n    集群间机器PING值： 0.05ms\n    请求写入并发：100个线程\n    \n### 性能测试结果(qps)\n> 请求延时小于10ms.\n###### 写入小数据(100B)\n    1个Group： 1171\n    20个Group： 11931\n    50个Group： 13424\n    100个Group： 13962\n###### 写入大数据(100KB)\n    1个Group： 280\n    20个Group： 984\n    50个Group： 1054\n    100个Group： 1067\n###### BatchPropose(2KB)\n    100个Group: 150000\n\n# 代码目录介绍\n**include**目录包含了使用PhxPaxos所需要用到的所有头文件，您需要理解这些头文件的所有类函数的含义，才能正确的使用PhxPaxos。\n>注：我们对外公共API都放在这个目录的头文件里，调用者切勿引用非此目录的头文件的一些内部API，\n这些API我们有可能会随时的进行调整而不进行兼容。\n\n**src**目录是PhxPaxos的源代码目录，如想深入研究PhxPaxos的工作原理，可详细阅读此目录的代码。\n如果你只是想使用PhxPaxos，则暂时不需要理解此目录代码。 \n\n**third_party**目录用于放置PhxPaxos所需要用到的一些第三方库；一般刚获得PhxPaxos源代码的时候，这是一个空目录。\n如何放置第三方库在后面编译方面的章节会详细介绍。使用PhxPaxos需要依赖到两个第三方库，分别是protobuf和leveldb。\n\n**plugin**目录提供日志插件模块。日志是调试程序的重要方式，但不同组织之间的日志功能通常有很大的区别，\n因此PhxPaxos的src目录并未提供具体的日志功能，而是提供了日志的插件机制，使得日志功能可以被定制。为了方便大家快速尝试PhxPaxos库，我们基于目前比较流行的glog库实现了一个日志插件。如果你刚好也使用glog，那么plugin目录的代码可以为你减少一些开发时间。\n\n**sample**目录提供了基于PhxPaxos实现的三个程序。这三个程序分别对应了使用PhxPaxos的由浅入深，从简单到入门到进阶的不同阶段。\n * PhxElection是一个极为简单的程序，它利用了PhxPaxos的内置Master选举功能，实现了一个选举Master的程序。\n * PhxEcho展示了如何编写一个状态机，并和Phxpaxos结合。\n * PhxKV则是一个更为完整的系统，他实现了一个KV的状态机，搭配PhxPaxos实现了分布式KV存储，并展示了如何实现Checkpoint来删除paxos log；\n 另外它同时展示了怎么将这些代码整合到一个RPC框架（我们使用了grpc作为演示），最终实现一个完整的分布式后台存储系统。\n \n# 公共头文件介绍\n * **include/node.h** PhxPaxos的主要API在这里，建议开发者从这里开始。\n * **include/options.h** 运行PhxPaxos所需的一些配置以及可定制的选项。\n * **include/sm.h** 状态机的基类。\n * **include/def.h** 返回值定义。\n * **include/network.h** 网络模块的抽象函数，如果您想使用自己的网络协议，通过重载这些函数实现网络模块的自定义。\n * **include/storage.h** 存储模块的抽象函数。\n * **include/log.h** 日志模块的抽象函数。\n * **include/breakpoint.h** 断点抽象函数，一般可用于实现自己的监控。\n \n# 如何编译\n### 编译前的第三方库准备\n首先我们看一下各目录的依赖关系。如下：\n\n| 目录               | 编译对象             | 内部依赖                           | 第三方库依赖     |\n| ------------------ | -------------------- | ---------------------------------- | ---------------- |\n| 根目录             | libphxpaxos.a        | 无                                 | protobuf,leveldb |\n| plugin             | libphxpaxos_plugin.a | libphxpaxos.a                      | glog             |\n| sample/phxelection | 可执行程序           | libphxpaxos.a,libphxpaxos_plugin.a | 无               |\n| sample/phxecho     | 可执行程序           | libphxpaxos.a,libphxpaxos_plugin.a | 无               |\n| sample/phxkv       | 可执行程序           | libphxpaxos.a,libphxpaxos_plugin.a | grpc             |\n| src/ut             | 单元测试             | 无                                 | gtest,gmock      |\n\n编译我们的Phxpaxo(libphxpaxos.a)类库，只需要protobuf和leveldb两个第三方库；而编译其他目录则需要glog和grpc这两个库。\n在编译前，需要先准备好这些第三方库，放在我们的third_party目录，可以直接放置，也可以通过软链的形式，也可以git clone时加上--recursive参数获取third_party目录下所有的submodule。\n\n### 编译环境\n * Linux。\n * GCC-4.8及以上版本。\n \n### 编译安装方法\n###### 编译libphxpaxos.a\n \n在PhxPaxos根目录下\n```Bash\n./autoinstall.sh\nmake\nmake install\n```\n\n###### 编译libphxpaxos_plugin.a\n \n在plugin目录下\n```Bash\nmake\nmake install\n```\n\n# 如何嵌入PhxPaxos到自己的代码\n### 选择一个单机服务\n我们选用sample目录里面的PhxEcho来说明PhxPaxos的使用方法。Echo是我们编写RPC服务的常见测试函数，\n我们尝试通过嵌入PhxPaxos的代码，使得我们的Echo可以扩展到多台机器。\n\n假设我们现在已有的EchoServer代码头文件类定义如下：\n```c++\nclass PhxEchoServer\n{\npublic:\n    PhxEchoServer();\n    ~PhxEchoServer();\n\n    int Echo(const std::string & sEchoReqValue, std::string & sEchoRespValue);\n};\n```\n接下来我们基于这个类来嵌入PhxPaxos的代码。\n\n### 实现一个状态机\n首先我们定义一个状态机叫PhxEchoSM，这个类继承自StateMachine类，如下：\n```c++\nclass PhxEchoSM : public phxpaxos::StateMachine\n{\npublic:\n    PhxEchoSM();\n\n    bool Execute(const int iGroupIdx, const uint64_t llInstanceID, \n            const std::string & sPaxosValue, phxpaxos::SMCtx * poSMCtx);\n\n    const int SMID() const { return 1; }\n};\n```\n因为一个PhxPaxos可以同时挂载多个状态机，所以需要SMID()这个函数返回这个状态机的唯一标识ID。\n\n其中Execute为状态机状态转移函数，输入为sPaxosValue， PhxPaxos保证多台机器都会执行相同系列的Execute(sPaxosValue)，\n从而获得强一致性。函数的实现如下：\n```c++\nbool PhxEchoSM :: Execute(const int iGroupIdx, const uint64_t llInstanceID, \n        const std::string & sPaxosValue, SMCtx * poSMCtx)\n{\n    printf(\"[SM Execute] ok, smid %d instanceid %lu value %s\\n\", \n            SMID(), llInstanceID, sPaxosValue.c_str());\n\n    //only commiter node have SMCtx.\n    if (poSMCtx != nullptr && poSMCtx->m_pCtx != nullptr)\n    {   \n        PhxEchoSMCtx * poPhxEchoSMCtx = (PhxEchoSMCtx *)poSMCtx->m_pCtx;\n        poPhxEchoSMCtx->iExecuteRet = 0;\n        poPhxEchoSMCtx->sEchoRespValue = sPaxosValue;\n    }   \n\n    return true;\n}\n```\n我们仅仅print一下这个sPaxosValue，作为多机化的一个验证。\n\n函数的参数出现了一个陌生的类型SMCtx，如下：\n```c++\nclass SMCtx\n{\npublic:\n    SMCtx();\n    SMCtx(const int iSMID, void * pCtx);\n\n    int m_iSMID;\n    void * m_pCtx;\n};\n```\nSMCtx类型参数作为一个上下文，由写入者提供（怎么提供后面会提到），并由PhxPaxos带到Execute函数，最终传递给用户使用。\n\nm_iSMID与上文提到的SMID()函数相对应，PhxPaxos会将这个上下文带给SMID()等于m_iSMID的状态机。\nm_pCtx则记录了用户自定义的上下文数据的所在地址。\n\n>Execute函数的上下文参数仅在请求写入所在进程可以获得，在其他机器这个指针为nullptr，\n所以Execute在处理这个参数的时候注意要进行空指针的判断。\n\n下面展示了我们的Echo上下文数据类型定义：\n```c++\nclass PhxEchoSMCtx\n{\npublic:\n    int iExecuteRet;\n    std::string sEchoRespValue;\n\n    PhxEchoSMCtx()\n    {   \n        iExecuteRet = -1; \n    }   \n};\n```\n通过iExecuteRet可以获得Execute的执行情况，通过sEchoRespValue可以获得Execute带入的sEchoReqValue。\n\n最终由以上几个类，我们构建了自己的状态机以及状态转移函数。\n\n>本小节要点：如果你想改造一个现有的服务模块使其多副本化，那么你要做的仅仅就是抽象你的服务逻辑，\n使其变成一个Execute函数，仅此而已。\n\n### 运行PhxPaxos\n在编写好Echo状态机之后，接下来要做的就是运行PhxPaxos，并且挂载上状态机。\n\n首先我们对原有的EchoServer类进行一下修改，如下：\n```c++\nclass PhxEchoServer\n{\npublic:\n    PhxEchoServer(const phxpaxos::NodeInfo & oMyNode, const phxpaxos::NodeInfoList & vecNodeList);\n    ~PhxEchoServer();\n\n    int RunPaxos();\n    int Echo(const std::string & sEchoReqValue, std::string & sEchoRespValue);\n\n    phxpaxos::NodeInfo m_oMyNode;\n    phxpaxos::NodeInfoList m_vecNodeList;\n\n    phxpaxos::Node * m_poPaxosNode;\n    PhxEchoSM m_oEchoSM;\n};\n```\n构造函数增加了几个参数，oMyNode标识本机的IP/PORT信息，vecNodeList标识多副本集群的所有机器信息，\n这些参数类型都是PhxPaxos的预设类型。\n\n私有成员方面，除了m_oMyNode和m_vecNodeList之外，m_oEchoSM是我们刚刚编写的状态机类，m_poPaxosNode则代表\n了本次我们需要运行的PhxPaxos实例指针。\n\n我们通过调用RunPaxos函数来运行PhxPaxos实例。这个函数的实现如下：\n```c++\nint PhxEchoServer :: RunPaxos()\n{\n    Options oOptions;\n\n    int ret = MakeLogStoragePath(oOptions.sLogStoragePath);\n    if (ret != 0)\n    {   \n        return ret;\n    }   \n\n    //this groupcount means run paxos group count.\n    //every paxos group is independent, there are no any communicate between any 2 paxos group.\n    oOptions.iGroupCount = 1;\n\n    oOptions.oMyNode = m_oMyNode;\n    oOptions.vecNodeInfoList = m_vecNodeList;\n\n    GroupSMInfo oSMInfo;\n    oSMInfo.iGroupIdx = 0;\n    //one paxos group can have multi state machine.\n    oSMInfo.vecSMList.push_back(&m_oEchoSM);\n    oOptions.vecGroupSMInfoList.push_back(oSMInfo);\n\n    //use logger_google to print log\n    LogFunc pLogFunc;\n    ret = LoggerGoogle :: GetLogger(\"phxecho\", \"./log\", 3, pLogFunc);\n    if (ret != 0)\n    {   \n        printf(\"get logger_google fail, ret %d\\n\", ret);\n        return ret;\n    }   \n\n    //set logger\n    oOptions.pLogFunc = pLogFunc;\n\n    ret = Node::RunNode(oOptions, m_poPaxosNode);\n    if (ret != 0)\n    {   \n        printf(\"run paxos fail, ret %d\\n\", ret);\n        return ret;\n    }   \n\n    printf(\"run paxos ok\\n\");\n    return 0;\n}\n```\nOption类型变量包含了运行这个PhxPaxos实例的所有参数以及选项。\n\nMakeLogStoragePath函数生成我们存放PhxPaxos产生的数据的目录路径，设置给oOptions.sLogStoragePath。\n设置oOptions.iGroupCount为1，标识我们想同时运行多少个PhxPaxos实例。我们通过GroupIdx来标识实例，\n其范围为[0,oOptions.iGroupCount)，我们支持并行运行多个实例，每个实例独立运作。不同实例直接无任何关联，\n支持多实例的目的仅仅是为了让它们可以共享同一个IP/PORT。\n\n然后设置好本机IP/PORT信息以及所有机器的信息。\n\n接下来非常重要的一步，设置我们刚才实现的状态机。\n\noOptions.vecGroupSMInfoList描述了多个PhxPaxos实例对应的状态机列表。他是一个GroupSMInfo类的数组。\n\nGroupSMInfo类型，用于描述一个PhxPaxos实例对应的状态机列表，GroupSMInfo.iGroupIdx标识这个实例，由于我们的GroupCount设置为1，\n所以GroupIdx设置为0，vecSMList标识需要挂载的状态机列表，它是一个状态机类型指针的数组。\n\n设置好我们的日志函数，这里我们用了plugin目录的glog日志方法。\n\n最后，调用Node::RunNode(oOptions, m_poPaxosNode)，传入参数选项，如果运行成功，函数返回0，\n并且m_poPaxosNode指向这个运行中的PhxPaxos实例。这样PhxPaxos实例就运行成功了。\n\n# 发起请求\n下面展示改造后的EchoServer的Echo函数，从而告诉大家如何使用PhxPaxos来发起写入请求，如下：\n```c++\nint PhxEchoServer :: Echo(const std::string & sEchoReqValue, std::string & sEchoRespValue)\n{\n    SMCtx oCtx;\n    PhxEchoSMCtx oEchoSMCtx;\n    //smid must same to PhxEchoSM.SMID().\n    oCtx.m_iSMID = 1;\n    oCtx.m_pCtx = (void *)&oEchoSMCtx;\n\n    uint64_t llInstanceID = 0;\n    int ret = m_poPaxosNode->Propose(0, sEchoReqValue, llInstanceID, &oCtx);\n    if (ret != 0)\n    {   \n        printf(\"paxos propose fail, ret %d\\n\", ret);\n        return ret;\n    }   \n\n    if (oEchoSMCtx.iExecuteRet != 0)\n    {   \n        printf(\"echo sm excute fail, excuteret %d\\n\", oEchoSMCtx.iExecuteRet);\n        return oEchoSMCtx.iExecuteRet;\n    }   \n\n    sEchoRespValue = oEchoSMCtx.sEchoRespValue.c_str();\n\n    return 0;\n}\n```\n首先定义上下文类型变量oEchoSMCtx，然后将这个变量指针设置到状态机上下文oCtx.m_pCtx里面，\n同时我们设置oCtx.m_iSMID为1，与我们刚刚编写的状态机的SMID()相对应，标识我们需要将这个请求送往SMID为1的状态机的Execute函数。\n\n然后调用m_poPaxosNode->Propose，第一个参数GroupIdx填入0，代表我们希望对实例0进行写入请求，第二个参数填入我们的请求内容。\nllInstanceID 是我们获得的回参，这个ID是一个全局递增的ID，最后一个参数传入我们的上下文。\n\n如果执行成功则函数返回0，通过上下文即可获得sEchoRespValue。\n\n经过以上几个步骤，我们就将一个单机的Echo函数，改造成了一个多机版本。\n\n### 运行效果\n下面展示我们编写的多副本Echo服务的运行效果。你可以照着上面的思路自己实现一遍，或者直接编译我们的sample/phxecho目录的程序。\n\n我们运行一个拥有三副本的phxecho集群，其中第一台机器：\n```c++\nrun paxos ok\necho server start, ip 127.0.0.1 port 11112\n\nplease input: <echo req value>\nhello phxpaxos:)\n[SM Execute] ok, smid 1 instanceid 0 value hello phxpaxos:)\necho resp value hello phxpaxos:)\n```\nIP为127.0.0.1，PORT为11112，可以看到我们给其输入一个EchoReqValue为”hello phxpaxos:)”，\n然后我们看到Execute的printf打出来的[SM Execute] ok...，最后我们通过上下文获得EchoRespValue为相同的”hello phxpaxos:)”。\n\n我们来看看其他副本机器的情况，这是第二台机器：\n```c++\nrun paxos ok\necho server start, ip 127.0.0.1 port 11113\n\nplease input: <echo req value>\n[SM Execute] ok, smid 1 instanceid 0 value hello phxpaxos:)\n```\nIP为127.0.0.1，PORT为11113， 可以看到他的Execute函数的信息也打印的了出来，value同样为”hello phxpaxos:)”。\n\n# 使用PhxPaxos的Master，给你的Server提供一个选举功能\n这里先解释一下Master的定义，Master是指在多台机器构建的集合里面，任一时刻，只有一台机器认为自己是Master或者没有任何机器认为自己是Master。\n\n这个功能非常实用。假设有那么一个多台机器组成的集群，我希望任一时刻只有一台机器在提供服务，相信大家可能会遇到这样的场景，\n而通常的做法可能是使用ZooKeeper来搭建分布式锁。那么使用我们的Master功能，只需编写短短的几十行代码，\n即可跟你现有的服务无缝结合起来，而不用引入额外的一些庞大的模块。\n\n下面展示如何嵌入Master到自己的代码里面。\n\n首先我们构建一个选举类PhxElection，这个类供已有的模块代码使用，如下：\n```c++\nclass PhxElection\n{\npublic:\n    PhxElection(const phxpaxos::NodeInfo & oMyNode, const phxpaxos::NodeInfoList & vecNodeList);\n    ~PhxElection();\n\n    int RunPaxos();\n    const phxpaxos::NodeInfo GetMaster();\n    const bool IsIMMaster();\n\nprivate:\n    phxpaxos::NodeInfo m_oMyNode;\n    phxpaxos::NodeInfoList m_vecNodeList;\n    phxpaxos::Node * m_poPaxosNode;\n};\n```\n这个类提供两个功能函数，GetMaster获得当前集群的Master，IsIMMaster判断自己是否当前Master。\n\nRunPaxos是运行PhxPaxos的函数，代码如下：\n\n```c++\nint PhxElection :: RunPaxos()\n{\n    Options oOptions;\n\n    int ret = MakeLogStoragePath(oOptions.sLogStoragePath);\n    if (ret != 0)\n    {   \n        return ret;\n    }   \n\n    oOptions.iGroupCount = 1;\n\n    oOptions.oMyNode = m_oMyNode;\n    oOptions.vecNodeInfoList = m_vecNodeList;\n\n    //open inside master state machine\n    GroupSMInfo oSMInfo;\n    oSMInfo.iGroupIdx = 0;\n    oSMInfo.bIsUseMaster = true;\n\n    oOptions.vecGroupSMInfoList.push_back(oSMInfo);\n\n    ret = Node::RunNode(oOptions, m_poPaxosNode);\n    if (ret != 0)\n    {   \n        printf(\"run paxos fail, ret %d\\n\", ret);\n        return ret;\n    }   \n\n    //you can change master lease in real-time.\n    m_poPaxosNode->SetMasterLease(0, 3000);\n\n    printf(\"run paxos ok\\n\");\n    return 0;\n}\n```\n与Echo不一样的是，这次我们并不需要实现自己的状态机，而是通过将oSMInfo.bIsUseMaster设置为true，开启我们内置的一个Master状态机。\n相同的，通过Node::RunNode即可获得PhxPaxos的实例指针。通过SetMasterLease可以随时修改Master的租约时间。\n最后，我们通过这个指针获得集群的Master信息，代码如下：\n\n```c++\nconst phxpaxos::NodeInfo PhxElection :: GetMaster()\n{\n    //only one group, so groupidx is 0.\n    return m_poPaxosNode->GetMaster(0);\n}\n\nconst bool PhxElection :: IsIMMaster()\n{\n    return m_poPaxosNode->IsIMMaster(0);\n}\n```\n通过这个简单的选举类，每台机器都可以获知当前的Master信息。\n\n# 欢迎使用，欢迎反馈你们的建议:)\n"
        },
        {
          "name": "autoinstall.sh",
          "type": "blob",
          "size": 1.51953125,
          "content": "#!/bin/bash\n\nbase_dir=`pwd`\nmake_file_tools=$base_dir/tools/create_makefile.py\ncheck_env_tools=$base_dir/tools/check_install.py\nsrc_dir=$base_dir/src_list\n\nfunction check_env(){\n\tpython $check_env_tools $base_dir\n\tif [ $? -gt 0 ];\n\tthen\n\t\texit 1\n\tfi\n}\n\nfunction create_makefile(){\n\tpython $make_file_tools $base_dir $1 \n}\n\nfunction scandir(){\n\tif [ $1 ];then\n\t\techo \"[creating makefile] $1\"\n\t\tcreate_makefile $1\n\t\tfor file in `ls $1`\n\t\tdo\n\t\t\tif ([ -d $1\"/\"$file ] && [ \"$file\" != \"glog\" ])\n\t\t\t\tthen\n\t\t\t\t\tscandir $1\"/\"$file\n\t\t\tfi\n\t\tdone\n\tfi\n}\n\nfunction process(){\n\tcreate_makefile $base_dir\n\tres=`cat $src_dir`\n\techo $res\n\tfor file in $res\n\tdo\n\t\tif ([ -d $base_dir\"/\"$file ] && [ \"$file\" != \"glog\" ])\n\t\t\tthen\n\t\t\t\tscandir $base_dir\"/\"$file\n\t\tfi\n\tdone\n}\n\nfunction check(){\n\tmake verify-install --file=makefile.mk\n\tif [ $? -eq 0 ]; then\n\t\treturn 0\n\telse\n\t\techo \"install fail\"\n\t\treturn 1\n\tfi\n}\n\nfunction showusage(){\n\techo \"Configuration:\"\n\techo \"  -h, --help              display this help and exit\"\n\techo \"Installation directories:\"\n\techo \"  --prefix=PREFIX         install architecture-independent files in PREFIX\"\n\techo \"                          [.]\"\n\texit\n}\n\nprefix=\n\nARGS=`getopt -o h -l prefix:,help -- \"$@\"`  \neval set -- \"${ARGS}\" \n\nwhile true  \ndo  \n\tcase \"$1\" in \n\t\t--prefix)  \n\t\t\tif [ $2 ]; then\n\t\t\t\tsed -i -r \"s#PREFIX=.*#PREFIX=$2#\" makefile.mk\n\t\t\tfi\n\t\t\tshift  \n\t\t\t;;  \n\t\t-h|--help)\n\t\t\tshowusage\n\t\t\tbreak\n\t\t\t;;\n\t\t--)  \n\t\t\tshift  \n\t\t\tbreak \n\t\t\t;;  \n\tesac  \nshift  \ndone \n\ncheck_env\necho \"check evn done\"\n#check \nif [ $? -eq 0 ]; then \nprocess \nfi\n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.1728515625,
          "content": "\nset -e  # exit immediately on error\nset -x  # display all commands\n\ngit submodule update --init --recursive\n\n(cd third_party && bash ./autoinstall.sh)\n\n./autoinstall.sh\n\nmake\n\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "makefile.mk",
          "type": "blob",
          "size": 3.9970703125,
          "content": "SRC_BASE_PATH ?= .\nPREFIX?=$(SRC_BASE_PATH)\nPHX_LIB_PATH = $(SRC_BASE_PATH)/.lib\nPHX_SBIN_PATH = $(SRC_BASE_PATH)/.sbin\nPHX_EXTLIB_PATH = $(PHX_LIB_PATH)/extlib\n\nNANOPBPATH=$(SRC_BASE_PATH)/third_party/nanopb/\n\nPROTOBUF_INCLUDE_PATH=$(SRC_BASE_PATH)/third_party/protobuf/include\nGRPC_INCLUDE_PATH=$(SRC_BASE_PATH)/third_party/grpc/include\nLEVELDB_INCLUDE_PATH=$(SRC_BASE_PATH)/third_party/leveldb/include\nGFLAGS_INCLUDE_PATH=$(SRC_BASE_PATH)/third_party/gflags/include\nGLOG_INCLUDE_PATH=$(SRC_BASE_PATH)/third_party/glog/include\nPHXPAXOS_INCLUDE_PATH=$(SRC_BASE_PATH)/include\nPHXPAXOS_PLUGIN_PATH=$(SRC_BASE_PATH)/plugin/include\n\nPROTOBUF_LIB_PATH=$(SRC_BASE_PATH)/third_party/protobuf/lib\nLEVELDB_LIB_PATH=$(SRC_BASE_PATH)/third_party/leveldb/lib\nGFLAGS_LIB_PATH=$(SRC_BASE_PATH)/third_party/gflags/lib\nGLOG_LIB_PATH=$(SRC_BASE_PATH)/third_party/glog/lib\nGRPC_LIBE_PATH=$(SRC_BASE_PATH)/third_party/grpc/lib\nOPEN_SSL_LIB_PATH=$(SRC_BASE_PATH)/third_party/openssl/lib\nPHXPAXOS_LIB_PATH=$(SRC_BASE_PATH)/lib\n\nifeq ($(debug),y)\n# (1) Debug\n\tOPT = -g2\nelse\n# (2) Production\n\tOPT = -O2\nendif\n\nCXX=g++\nCXXFLAGS+=-std=c++11 $(OPT)\nCPPFLAGS+=-I$(SRC_BASE_PATH) -I$(PROTOBUF_INCLUDE_PATH) -I$(LEVELDB_INCLUDE_PATH)\nCPPFLAGS+=-I$(GFLAGS_INCLUDE_PATH) -I$(GLOG_INCLUDE_PATH)\nCPPFLAGS+=-Wall -fPIC -m64  -Wno-unused-local-typedefs\n\n#LDFLAGS+=-shared\n#LDFLAGS+=-static\nLDFLAGS+=-L$(PHX_LIB_PATH) -L$(PROTOBUF_LIB_PATH) -L$(LEVELDB_LIB_PATH)\nLDFLAGS+=-L$(GFLAGS_LIB_PATH) -L$(GLOG_LIB_PATH) -L$(GRPC_LIBE_PATH) -L$(OPEN_SSL_LIB_PATH) -g\nLDFLAGS+=-Wl,--no-as-needed\n\n\n#=====================================================================================================\n\nPROTOC = $(SRC_BASE_PATH)/third_party/protobuf/bin/protoc\nPROTOS_PATH = .\nGRPC_CPP_PLUGIN = grpc_cpp_plugin\nGRPC_CPP_PLUGIN_PATH ?= `which $(GRPC_CPP_PLUGIN)`\nNANOPB_PLUGIN_PATH=$(NANOPBPATH)/generator/protoc-gen-nanopb\n\nvpath %.proto $(PROTOS_PATH)\n\n.PRECIOUS: %.grpc.pb.cc\n%.grpc.pb.cc: %.proto\n\t$(PROTOC) -I $(PROTOS_PATH) --grpc_out=. --plugin=protoc-gen-grpc=$(GRPC_CPP_PLUGIN_PATH) $<\n\n.PRECIOUS: %.nano.pb.cc\n%.nano.pb.cc: %.proto\n\t$(PROTOC) --plugin=protoc-gen-nanopb=$(NANOPB_PLUGIN_PATH) --nanopb_out=nanoproto/ $<\n\n\n.PRECIOUS: %.pb.cc\n%.pb.cc: %.proto\n\t$(PROTOC) -I $(PROTOS_PATH) --cpp_out=. $<\n\n\nPROTOC_CHECK_VERSION_CMD = $(PROTOC) --version | grep -q libprotoc.3\nHAS_VALID_PROTOC ?= $(shell $(PROTOC_CHECK_VERSION_CMD) 2> /dev/null && echo true || echo false)\n\nLEVELDB_CHECK_CMD = ls $(LEVELDB_INCLUDE_PATH) > /dev/null\nHAS_LEVEL_DB_CMD ?= $(shell $(LEVELDB_CHECK_CMD) 2> /dev/null && echo true || echo false)\n\n.PHONY:verify-install\nverify-install:\nifeq ($(HAS_VALID_PROTOC),true)\n\t@echo \"protobuf check [done]\"\nelse\n\t@echo \"The library requires protobuf-compiler 3.0.0+\"\n\t@echo \"But the third party directory doesn't have it\"\n\t@echo \"Please check it and make sure the protobuf \"\n\t@echo \"has been placed or linked in the third party directory\"\nendif\n\nifeq ($(HAS_LEVEL_DB_CMD),true)\n\t@echo \"level check [done]\"\nelse\n\t@echo \"The library requires the leveldb library\"\n\t@echo \"But the third party directory doesn't have it\"\n\t@echo \"Please check it and make sure the leveldb\"\n\t@echo \"has been placed or linked in the third party directory\"\nendif\n\n.PHONY:install\ninstall:\n\t@prefix_dir=`readlink $(PREFIX) -m`;\\\n\tsrc_dir=`readlink $(SRC_BASE_PATH) -m`;\\\n\tif ([ \"$$prefix_dir\" != \"$$src_dir\" ]); then \\\n\techo cp $(PHX_LIB_PATH) $(PREFIX)/include -rf;\\\n\tcp $(PHXPAXOS_INCLUDE_PATH) $(PREFIX)/include -rf;\\\n\tfi\n\techo INSTALL to $(PREFIX)/lib;\n\t@mkdir $(PREFIX)/lib -p;\\\n\trm $(PREFIX)/lib/* -rf;\\\n\tcp $(PHX_EXTLIB_PATH)/* $(PREFIX)/lib/ -rf;\n\nversion = 1.0.0\n\ndist: clean phxpaxos-$(version).src.tgz\nphxpaxos-$(version).src.tgz:\n\t@rm -rf phxpaxos-$(version).src.tgz\n\t@find ./* -name \"Makefile\" | xargs rm -rf\n\t@find . -type f | grep -v CVS | grep -v \"lib.*.a\" | grep -v \"license\\.py\" | grep -v .svn | grep -v .git | sed s:^./:phxpaxos-$(version)/: > MANIFEST\n\t@(cd ..; ln -s phxpaxos phxpaxos-$(version))\n\t(cd ..; tar cvf - `cat phxpaxos/MANIFEST` | gzip > phxpaxos/phxpaxos-$(version).src.tgz)\n\t@(cd ..; rm phxpaxos-$(version))\n\n"
        },
        {
          "name": "plugin",
          "type": "tree",
          "content": null
        },
        {
          "name": "sample",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "src_list",
          "type": "blob",
          "size": 0.025390625,
          "content": "src plugin include sample\n"
        },
        {
          "name": "third_party",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}