{
  "metadata": {
    "timestamp": 1736565943823,
    "page": 921,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hiyohiyo/CrystalDiskInfo",
      "stars": 1950,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 2.5087890625,
          "content": "###############################################################################\n# Set default behavior to automatically normalize line endings.\n###############################################################################\n* text=auto\n\n###############################################################################\n# Set default behavior for command prompt diff.\n#\n# This is need for earlier builds of msysgit that does not have it on by\n# default for csharp files.\n# Note: This is only used by command line\n###############################################################################\n#*.cs     diff=csharp\n*.lang working-tree-encoding=UTF-16LE-BOM eol=CRLF\n\n###############################################################################\n# Set the merge driver for project and solution files\n#\n# Merging from the command prompt will add diff markers to the files if there\n# are conflicts (Merging from VS is not affected by the settings below, in VS\n# the diff markers are never inserted). Diff markers may cause the following \n# file extensions to fail to load in VS. An alternative would be to treat\n# these files as binary and thus will always conflict and require user\n# intervention with every merge. To do so, just uncomment the entries below\n###############################################################################\n#*.sln       merge=binary\n#*.csproj    merge=binary\n#*.vbproj    merge=binary\n#*.vcxproj   merge=binary\n#*.vcproj    merge=binary\n#*.dbproj    merge=binary\n#*.fsproj    merge=binary\n#*.lsproj    merge=binary\n#*.wixproj   merge=binary\n#*.modelproj merge=binary\n#*.sqlproj   merge=binary\n#*.wwaproj   merge=binary\n\n###############################################################################\n# behavior for image files\n#\n# image files are treated as binary by default.\n###############################################################################\n#*.jpg   binary\n#*.png   binary\n#*.gif   binary\n\n###############################################################################\n# diff behavior for common document formats\n# \n# Convert binary document formats to text before diffing them. This feature\n# is only available from the command line. Turn it on by uncommenting the \n# entries below.\n###############################################################################\n#*.doc   diff=astextplain\n#*.DOC   diff=astextplain\n#*.docx  diff=astextplain\n#*.DOCX  diff=astextplain\n#*.dot   diff=astextplain\n#*.DOT   diff=astextplain\n#*.pdf   diff=astextplain\n#*.PDF   diff=astextplain\n#*.rtf   diff=astextplain\n#*.RTF   diff=astextplain\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3466796875,
          "content": "*.zip\n資料/\n*.opus\nbackup/\nSmart/\n*.ipch\n*.opensdf\n*.ini\n*.exe\n*.csv\n*.png\nx64/\nBuild/\n*.sdf\nDiskInfo.VC.opendb\nDiskInfo.VC.db\nAtaSmart.cpp.rej\nDiskInfo.VC.VC.opendb\n*.aps\n*.user\n.vs/\nenc_temp_folder/47375794a7a15ae9bc5c605bd6169eb2/stdafx.h\nUpgradeLog.htm\nlibraidapi32.a\nlibraidapi64.a\nlibgcc32.a\nlibgcc64.a\nJMicronUsbRaid32d.lib\nJMicronUsbRaid64d.lib\n"
        },
        {
          "name": "AboutDlg.cpp",
          "type": "blob",
          "size": 13.7392578125,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n#include \"AboutDlg.h\"\n\nIMPLEMENT_DYNCREATE(CAboutDlg, CDialog)\n\nCAboutDlg::CAboutDlg(CWnd* pParent /*=NULL*/)\n\t: CDialogFx(CAboutDlg::IDD, pParent)\n{\n\tCMainDialogFx* p = (CMainDialogFx*)pParent;\n\n\tm_ZoomType = p->GetZoomType();\n\tm_FontFace = p->GetFontFace();\n\tm_FontScale = p->GetFontScale();\n\tm_FontRatio = p->GetFontRatio();\n\tm_FontRender = p->GetFontRender();\n\tm_CurrentLangPath = p->GetCurrentLangPath();\n\tm_DefaultLangPath = p->GetDefaultLangPath();\n\tm_ThemeDir = p->GetThemeDir();\n\tm_CurrentTheme = p->GetCurrentTheme();\n\tm_DefaultTheme = p->GetDefaultTheme();\n\tm_Ini = p->GetIniPath();\n\n#ifdef SUISHO_AOI_SUPPORT\n\tm_BackgroundName = L\"AoiAbout\";\n#elif MSI_MEI_SUPPORT\n\tm_BackgroundName = L\"About\";\n#elif KUREI_KEI_SUPPORT\n\tm_BackgroundName = L\"KureiKeiAbout\";\n#elif SUISHO_SHIZUKU_SUPPORT\n\tm_BackgroundName = L\"ShizukuAbout\";\n#else\n\tm_BackgroundName = L\"\";\n#endif\n}\n\nCAboutDlg::~CAboutDlg()\n{\n}\n\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogFx::DoDataExchange(pDX);\n\tDDX_Control(pDX, IDC_LOGO, m_CtrlLogo);\n\n\tDDX_Control(pDX, IDC_PROJECT_SITE_1, m_CtrlProjectSite1);\n\tDDX_Control(pDX, IDC_PROJECT_SITE_2, m_CtrlProjectSite2);\n\tDDX_Control(pDX, IDC_PROJECT_SITE_3, m_CtrlProjectSite3);\n\tDDX_Control(pDX, IDC_PROJECT_SITE_4, m_CtrlProjectSite4);\n\tDDX_Control(pDX, IDC_PROJECT_SITE_5, m_CtrlProjectSite5);\n\n\tDDX_Control(pDX, IDC_SECRET_VOICE, m_CtrlSecretVoice);\n\tDDX_Control(pDX, IDC_VERSION, m_CtrlVersion);\n\tDDX_Control(pDX, IDC_LICENSE, m_CtrlLicense);\t\n\tDDX_Control(pDX, IDC_RELEASE, m_CtrlRelease);\n\tDDX_Control(pDX, IDC_COPYRIGHT1, m_CtrlCopyright1);\n\tDDX_Control(pDX, IDC_COPYRIGHT2, m_CtrlCopyright2);\n\tDDX_Control(pDX, IDC_EDITION, m_CtrlEdition);\n}\n\nBOOL CAboutDlg::OnInitDialog()\n{\n\tCDialogFx::OnInitDialog();\n\n\tSetWindowTitle(i18n(L\"WindowTitle\", L\"ABOUT\"));\n\n\tm_bShowWindow = TRUE;\n\tm_CtrlVersion.SetWindowTextW(PRODUCT_NAME L\" \" PRODUCT_VERSION);\n\tm_CtrlEdition.SetWindowTextW(PRODUCT_EDITION);\n\tm_CtrlRelease.SetWindowTextW(L\"Release: \" PRODUCT_RELEASE);\n\tm_CtrlCopyright1.SetWindowTextW(PRODUCT_COPYRIGHT_1);\n\tm_CtrlCopyright2.SetWindowTextW(PRODUCT_COPYRIGHT_2);\n\tm_CtrlLicense.SetWindowTextW(PRODUCT_LICENSE);\n\n#ifndef SUISHO_SHIZUKU_SUPPORT\n\tm_CtrlProjectSite1.ShowWindow(SW_HIDE);\n\tm_CtrlProjectSite2.ShowWindow(SW_HIDE);\n\tm_CtrlProjectSite3.ShowWindow(SW_HIDE);\n\tm_CtrlProjectSite4.ShowWindow(SW_HIDE);\n\tm_CtrlProjectSite5.ShowWindow(SW_HIDE);\n#endif\n\n\tUpdateDialogSize();\n\n\tCenterWindow();\n\tShowWindow(SW_SHOW);\n\treturn TRUE;\n}\n\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialogFx)\n\tON_WM_ERASEBKGND()\n\tON_BN_CLICKED(IDC_LOGO, &CAboutDlg::OnLogo)\n\tON_BN_CLICKED(IDC_LICENSE, &CAboutDlg::OnLicense)\n\tON_BN_CLICKED(IDC_VERSION, &CAboutDlg::OnVersion)\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tON_BN_CLICKED(IDC_SECRET_VOICE, &CAboutDlg::OnSecretVoice)\n\tON_BN_CLICKED(IDC_PROJECT_SITE_1, &CAboutDlg::OnProjectSite1)\n\tON_BN_CLICKED(IDC_PROJECT_SITE_2, &CAboutDlg::OnProjectSite2)\n\tON_BN_CLICKED(IDC_PROJECT_SITE_3, &CAboutDlg::OnProjectSite3)\n\tON_BN_CLICKED(IDC_PROJECT_SITE_4, &CAboutDlg::OnProjectSite4)\n\tON_BN_CLICKED(IDC_PROJECT_SITE_5, &CAboutDlg::OnProjectSite5)\n#endif\nEND_MESSAGE_MAP()\n\n\nvoid CAboutDlg::UpdateDialogSize()\n{\n\tCDialogFx::UpdateDialogSize();\n\n\tChangeZoomType(m_ZoomType);\n\tSetClientSize(SIZE_X, SIZE_Y, m_ZoomRatio);\n\tUpdateBackground(TRUE, m_bDarkMode);\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tm_CtrlProjectSite1.SetHandCursor();\n\tm_CtrlProjectSite2.SetHandCursor();\n\tm_CtrlProjectSite3.SetHandCursor();\n\tm_CtrlProjectSite4.SetHandCursor();\n\tm_CtrlProjectSite5.SetHandCursor();\n\tm_CtrlSecretVoice.SetHandCursor();\n#endif\n\n#ifdef SUISHO_AOI_SUPPORT\n\tm_CtrlProjectSite1.InitControl(184, 516, 148, 16, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite2.InitControl(244, 548, 108, 16, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite3.InitControl(232, 564, 180, 16, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite4.InitControl(244, 584, 120, 16, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite5.InitControl(0, 0, 0, 0, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlLogo.InitControl(32, 496, 128, 144, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlSecretVoice.InitControl(364, 264, 44, 20, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\n#elif MSI_MEI_SUPPORT\n\tm_CtrlProjectSite1.InitControl(24, 460, 348, 128, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite2.InitControl(168, 604, 36, 24, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite3.InitControl(332, 604, 104, 24, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite4.InitControl(20, 20, 120, 40, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite5.InitControl(464, 604, 168, 24, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlLogo.InitControl(80, 64, 128, 128, m_ZoomRatio, &m_BkDC, IP(L\"Logo\"), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\tm_CtrlSecretVoice.InitControl(392, 240, 48, 40, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\n#elif KUREI_KEI_SUPPORT\n\tm_CtrlProjectSite1.InitControl(340, 232, 268, 100, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite2.InitControl(386, 376, 48, 40, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite3.InitControl(492, 376, 108, 40, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite4.InitControl(386, 600, 224, 60, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite5.InitControl(0, 0, 0, 0, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite5.ShowWindow(SW_HIDE);\n\tm_CtrlLogo.InitControl(12, 20, 128, 128, m_ZoomRatio, &m_BkDC, IP(L\"Logo\"), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\tm_CtrlSecretVoice.InitControl(132, 324, 48, 28, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\n#elif SUISHO_SHIZUKU_SUPPORT\n\tm_CtrlProjectSite1.InitControl(64, 368, 140, 16, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite2.InitControl(64, 416, 148, 16, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite3.InitControl(64, 432, 184, 16, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite4.InitControl(40, 460, 208, 16, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlProjectSite5.InitControl(92, 504, 432, 124, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlLogo.InitControl(80, 12, 128, 128, m_ZoomRatio, &m_BkDC, IP(L\"Logo\"), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\tm_CtrlSecretVoice.InitControl(392, 280, 44, 24, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\n#else\n\tm_CtrlLogo.InitControl(12, 12, 128, 128, m_ZoomRatio, &m_BkDC, IP(L\"Logo\"), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n#endif\n\n\tm_CtrlLogo.SetHandCursor();\n\n#ifdef MSI_MEI_SUPPORT\n\tCOLORREF fontColor = RGB(255, 255, 255);\n#else\n\tCOLORREF fontColor = RGB(0, 0, 0);\n#endif\n\n\tm_CtrlVersion.SetFontEx(m_FontFace, 22, 22, m_ZoomRatio, m_FontRatio, fontColor, FW_BOLD, m_FontRender);\n\tm_CtrlEdition.SetFontEx(m_FontFace, 18, 18, m_ZoomRatio, m_FontRatio, fontColor, FW_BOLD, m_FontRender);\n\tm_CtrlRelease.SetFontEx(m_FontFace, 16, 16, m_ZoomRatio, m_FontRatio, fontColor, FW_NORMAL, m_FontRender);\n\tm_CtrlCopyright1.SetFontEx(m_FontFace, 16, 16, m_ZoomRatio, m_FontRatio, fontColor, FW_NORMAL, m_FontRender);\n\tm_CtrlCopyright2.SetFontEx(m_FontFace, 16, 16, m_ZoomRatio, m_FontRatio, fontColor, FW_NORMAL, m_FontRender);\n\tm_CtrlLicense.SetFontEx(m_FontFace, 16, 16, m_ZoomRatio, m_FontRatio, fontColor, FW_NORMAL, m_FontRender);\n\n\tm_CtrlVersion.SetHandCursor();\n\tm_CtrlLicense.SetHandCursor();\n\n#ifdef SUISHO_AOI_SUPPORT\n\tm_CtrlVersion.InitControl(0, 52, 288, 28, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlEdition.InitControl(0, 80, 288, 28, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlRelease.InitControl(0, 116, 288, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlCopyright1.InitControl(0, 136, 288, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlCopyright2.InitControl(0, 156, 288, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlLicense.InitControl(0, 176, 288, 20, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\n#elif MSI_MEI_SUPPORT\n\tm_CtrlVersion.InitControl(0, 204, 288, 28, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlEdition.InitControl(0, 232, 288, 28, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlRelease.InitControl(0, 268, 288, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlCopyright1.InitControl(0, 288, 288, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlCopyright2.InitControl(0, 308, 288, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlLicense.InitControl(0, 0, 0, 0, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\n#elif KUREI_KEI_SUPPORT\n\tm_CtrlVersion.InitControl(152, 12, 476, 28, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlEdition.InitControl(152, 40, 476, 28, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlRelease.InitControl(152, 72, 476, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlCopyright1.InitControl(152, 96, 476, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlCopyright2.InitControl(152, 116, 476, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlLicense.InitControl(152, 136, 476, 20, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\n#elif SUISHO_SHIZUKU_SUPPORT\n\tm_CtrlVersion.InitControl(0, 152, 288, 28, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlEdition.InitControl(0, 180, 288, 28, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlRelease.InitControl(0, 216, 288, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlCopyright1.InitControl(0, 236, 288, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlCopyright2.InitControl(0, 256, 288, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlLicense.InitControl(0, 276, 288, 20, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\n#else\n\tm_CtrlVersion.InitControl(140, 12, 340, 28, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlEdition.InitControl(140, 40, 340, 28, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlRelease.InitControl(140, 76, 340, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlCopyright1.InitControl(140, 100, 340, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlLicense.InitControl(140, 120, 340, 20, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlCopyright2.ShowWindow(SW_HIDE);\n#endif\n\n\tInvalidate();\n}\n\nBOOL CAboutDlg::OnEraseBkgnd(CDC* pDC)\n{\n\tCRect rect;\n\tGetClientRect(&rect);\n\n\treturn pDC->BitBlt(0, 0, rect.Width(), rect.Height(), &m_BkDC, 0, 0, SRCCOPY);\n}\n\nvoid CAboutDlg::OnLogo()\n{\n\tif (GetUserDefaultLCID() == 0x0411)// Japanese\n\t{\n\t\tOpenUrl(URL_MAIN_JA);\n\t}\n\telse // Other Language\n\t{\n\t\tOpenUrl(URL_MAIN_EN);\n\t}\n}\n\nvoid CAboutDlg::OnVersion()\n{\n\tif (GetUserDefaultLCID() == 0x0411)// Japanese\n\t{\n\t\tOpenUrl(URL_VERSION_JA);\n\t}\n\telse // Other Language\n\t{\n\t\tOpenUrl(URL_VERSION_EN);\n\t}\n\n}\nvoid CAboutDlg::OnLicense()\n{\n\tif (GetUserDefaultLCID() == 0x0411)// Japanese\n\t{\n\t\tOpenUrl(URL_LICENSE_JA);\n\t}\n\telse // Other Language\n\t{\n\t\tOpenUrl(URL_LICENSE_EN);\n\t}\n}\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\nvoid CAboutDlg::OnSecretVoice()\n{\n\t::PostMessage(m_ParentWnd->GetSafeHwnd(), MY_PLAY_ALERT_SOUND, 901, NULL);\n}\n\nvoid CAboutDlg::OnProjectSite1()\n{\n\tOpenUrl(URL_PROJECT_SITE_1);\n}\n\nvoid CAboutDlg::OnProjectSite2()\n{\n\tOpenUrl(URL_PROJECT_SITE_2);\n}\n\nvoid CAboutDlg::OnProjectSite3()\n{\n\tOpenUrl(URL_PROJECT_SITE_3);\n}\n\nvoid CAboutDlg::OnProjectSite4()\n{\n\tOpenUrl(URL_PROJECT_SITE_4);\n}\n\nvoid CAboutDlg::OnProjectSite5()\n{\n\tOpenUrl(URL_PROJECT_SITE_5);\n}\n#endif"
        },
        {
          "name": "AboutDlg.h",
          "type": "blob",
          "size": 1.7255859375,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n#include \"DialogFx.h\"\n#include \"StaticFx.h\"\n#include \"ButtonFx.h\"\n\nclass CAboutDlg : public CDialogFx\n{\n\tDECLARE_DYNCREATE(CAboutDlg)\n\n#ifdef SUISHO_AOI_SUPPORT\n\tstatic const int SIZE_X = 640;\n\tstatic const int SIZE_Y = 660;\n#elif MSI_MEI_SUPPORT\n\tstatic const int SIZE_X = 640;\n\tstatic const int SIZE_Y = 640;\n#elif SUISHO_SHIZUKU_SUPPORT\n\tstatic const int SIZE_X = 640;\n\tstatic const int SIZE_Y = 660;\n#else\n\tstatic const int SIZE_X = 480;\n\tstatic const int SIZE_Y = 152;\n#endif\n\npublic:\n\tCAboutDlg(CWnd* pParent = NULL);\n\tvirtual ~CAboutDlg();\n\n\tenum { IDD = IDD_ABOUT };\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\n\tvirtual BOOL OnInitDialog();\n\tvirtual void UpdateDialogSize();\n\n\tDECLARE_MESSAGE_MAP()\n\tafx_msg BOOL OnEraseBkgnd(CDC* pDC);\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tafx_msg void OnSecretVoice();\n#endif\n\tafx_msg void OnLogo();\n\tafx_msg void OnVersion();\n\tafx_msg void OnLicense();\n\tafx_msg void OnProjectSite1();\n\tafx_msg void OnProjectSite2();\n\tafx_msg void OnProjectSite3();\n\tafx_msg void OnProjectSite4();\n\tafx_msg void OnProjectSite5();\n\n\tCButtonFx m_CtrlLogo;\n\tCButtonFx m_CtrlSecretVoice;\n\tCButtonFx m_CtrlProjectSite1;\n\tCButtonFx m_CtrlProjectSite2;\n\tCButtonFx m_CtrlProjectSite3;\n\tCButtonFx m_CtrlProjectSite4;\n\tCButtonFx m_CtrlProjectSite5;\n\tCButtonFx m_CtrlVersion;\n\tCButtonFx m_CtrlLicense;\n\n\tCStaticFx m_CtrlEdition;\n\tCStaticFx m_CtrlRelease;\n\tCStaticFx m_CtrlCopyright1;\n\tCStaticFx m_CtrlCopyright2;\n};\n"
        },
        {
          "name": "AtaSmart.cpp",
          "type": "blob",
          "size": 405.7734375,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n// Reference : http://www.usefullcode.net/2007/02/hddsmart.html (ja)\n\n#include \"stdafx.h\"\n#include <comutil.h>\n\n#include \"AtaSmart.h\"\n#include \"Priscilla/UtilityFx.h\"\n#include <wbemcli.h>\n\n#include \"DnpService.h\"\n#include \"OsInfoFx.h\"\n\n#ifdef JMICRON_USB_RAID_SUPPORT\n#include \"JMicronUsbRaidDef.h\"\n#include \"JMicronUsbRaidInit.h\"\n#endif\n\n//warning : enum3, enum class\n#pragma warning(disable : 26812)\n\n#pragma comment(lib, \"wbemuuid.lib\")\n#define SAFE_RELEASE(p) { if(p) { (p)->Release(); (p)=NULL; } }\n\n#ifndef safeCloseHandle\n#define safeCloseHandle(h) { if( h != NULL ) { ::CloseHandle(h); h = NULL; } }\n#endif\n\n#ifndef safeVirtualFree\n#define safeVirtualFree(h,b,c) { if( h != NULL ) { ::VirtualFree(h, b, c); h = NULL; } }\n#endif\n\nCAtaSmart::CAtaSmart()\n{\n\tm_bAtaPassThrough = FALSE;\n\tm_bAtaPassThroughSmart = FALSE;\n\tm_bNVMeStorageQuery = FALSE;\n\n\tif (IsWindowsVersionOrGreaterFx(10, 0))\n\t{\n\t\tm_bAtaPassThrough = TRUE;\n\t\tm_bAtaPassThroughSmart = TRUE;\n\t\tm_bNVMeStorageQuery = TRUE;\n\t}\n\telse if (IsWindowsVersionOrGreaterFx(6, 0) || IsWindowsVersionOrGreaterFx(5, 2))\n\t{\n\t\tm_bAtaPassThrough = TRUE;\n\t\tm_bAtaPassThroughSmart = TRUE;\n\t}\n\telse if (IsWindowsVersionOrGreaterFx(5, 1))\n\t{\n\t\tif (IsWindowsVersionOrGreaterFx(5, 1, 2))\n\t\t{\n\t\t\tm_bAtaPassThrough = TRUE;\n\t\t\tm_bAtaPassThroughSmart = TRUE;\n\t\t}\n\t}\n\n\t// 2023/02/24 Lock Handle: Compatible with SIV\n\thMutexJMicron = CreateWorldMutex(L\"Access_JMicron_SMART\");\n}\n\nCAtaSmart::~CAtaSmart()\n{\n#ifdef JMICRON_USB_RAID_SUPPORT\n\tDeinitializeJMS56X(&hJMS56X);\n\tDeinitializeJMB39X(&hJMB39X);\n\tDeinitializeJMS586_20(&hJMS586_20);\n\tDeinitializeJMS586_40(&hJMS586_40);\n#endif\n\n\tsafeCloseHandle(hMutexJMicron);\n}\n\n/* PUBLIC FUNCTION */\nVOID CAtaSmart::SetAtaPassThroughSmart(BOOL flag)\n{\n\tm_bAtaPassThroughSmart = flag;\n}\n\n/* PUBLIC FUNCTION */\nDWORD CAtaSmart::UpdateSmartInfo(DWORD i)\n{\n\tif (vars.GetCount() == 0)\n\t{\n\t\treturn SMART_STATUS_NO_CHANGE;\n\t}\n\n\tstatic SMART_ATTRIBUTE attribute[MAX_DISK][MAX_ATTRIBUTE] = {0};\n\n\tif (vars[i].DiskVendorId == SSD_VENDOR_NVME)\n\t{\n\t\tNVMeSmartToATASmart(vars[i].SmartReadData, &(vars[i].Attribute));\n\n\t\tif (\n#if ! defined(_M_ARM) && ! defined(_M_ARM64)\n\t\t\t(vars[i].CommandType == COMMAND_TYPE::CMD_TYPE_AMD_RC2 && GetSmartDataAMD_RC2(vars[i].ScsiBus, &(vars[i]))) ||// +AMD_RC2\n#endif\n\t\t\t(m_bNVMeStorageQuery && vars[i].CommandType == CMD_TYPE_NVME_STORAGE_QUERY && GetSmartAttributeNVMeStorageQuery(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t||  (vars[i].CommandType == CMD_TYPE_NVME_INTEL && GetSmartAttributeNVMeIntel(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t||  (vars[i].CommandType == CMD_TYPE_NVME_INTEL_RST && GetSmartAttributeNVMeIntelRst(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t||  (vars[i].CommandType == CMD_TYPE_NVME_INTEL_VROC && GetSmartAttributeNVMeIntelVroc(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t||  (vars[i].CommandType == CMD_TYPE_NVME_SAMSUNG && GetSmartAttributeNVMeSamsung(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t||  (vars[i].CommandType == CMD_TYPE_NVME_SAMSUNG && GetSmartAttributeNVMeSamsung951(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t||  (vars[i].CommandType == CMD_TYPE_NVME_JMICRON && GetSmartAttributeNVMeJMicron(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t||  (vars[i].CommandType == CMD_TYPE_NVME_ASMEDIA && GetSmartAttributeNVMeASMedia(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t||  (vars[i].CommandType == CMD_TYPE_NVME_REALTEK && GetSmartAttributeNVMeRealtek(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t||  (vars[i].CommandType == CMD_TYPE_NVME_REALTEK9220DP && GetSmartAttributeNVMeRealtek9220DP(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n#ifdef JMICRON_USB_RAID_SUPPORT\n\t\t||  (vars[i].CommandType == CMD_TYPE_JMS586_40 && GetSmartAttributeNVMeJMS586_40(vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t||  (vars[i].CommandType == CMD_TYPE_JMS586_20 && GetSmartAttributeNVMeJMS586_20(vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n#endif\n\t\t\t)\n\t\t{\n\t\t\tvars[i].Temperature = vars[i].SmartReadData[0x2] * 256 + vars[i].SmartReadData[0x1] - 273;\n\t\t\tif (vars[i].Temperature == -273 || vars[i].Temperature > 200)\n\t\t\t{\n\t\t\t\tvars[i].Temperature = -1000;\n\t\t\t}\n\n\t\t\tvars[i].Life = 100 - vars[i].SmartReadData[0x05];\n\t\t\tif (vars[i].Life < 0)\n\t\t\t{\n\t\t\t\tvars[i].Life = 0;\n\t\t\t}\n\n\t\t\tvars[i].HostReads = (INT)((*((UINT64*)&vars[i].SmartReadData[0x20]) * 1000 ) >> 21 )// * 512 * 1000 / 1024 / 1024 / 1024\n\t\t\t\t/*(ULONG64)\n\t\t\t\t(((ULONG64)vars[i].SmartReadData[0x27] << 56)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x26] << 48)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x25] << 40)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x24] << 32)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x23] << 24)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x22] << 16)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x21] << 8)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x20])) * 512 * 1000 / 1024 / 1024 / 1024*/;\n\n\t\t\tvars[i].HostWrites = (INT)((*((UINT64*)&vars[i].SmartReadData[0x30]) * 1000) >> 21 )// * 512 * 1000 / 1024 / 1024 / 1024\n\t\t\t\t/*(ULONG64)\n\t\t\t\t(((ULONG64)vars[i].SmartReadData[0x37] << 56)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x36] << 48)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x35] << 40)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x34] << 32)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x33] << 24)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x32] << 16)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x31] << 8)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x30])) * 512 * 1000 / 1024 / 1024 / 1024*/;\n\n\t\t\tvars[i].PowerOnCount = (DWORD)*((UINT64*)&vars[i].SmartReadData[0x70])\n\t\t\t\t/*(ULONG64)\n\t\t\t\t(((ULONG64)vars[i].SmartReadData[0x77] << 56)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x76] << 48)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x75] << 40)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x74] << 32)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x73] << 24)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x72] << 16)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x71] << 8)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x70]))*/;\n\n\t\t\tvars[i].MeasuredPowerOnHours = vars[i].DetectedPowerOnHours = (INT)*((UINT64*)&vars[i].SmartReadData[0x80])\n\t\t\t\t/*(ULONG64)\n\t\t\t\t(((ULONG64)vars[i].SmartReadData[0x87] << 56)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x86] << 48)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x85] << 40)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x84] << 32)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x83] << 24)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x82] << 16)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x81] << 8)\n\t\t\t\t\t+ ((ULONG64)vars[i].SmartReadData[0x80]))*/;\n\t\t}\n\n\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\treturn SMART_STATUS_MAJOR_CHANGE;\n\t}\n\n\tif(vars[i].IsSmartEnabled && vars[i].IsSmartCorrect)\n\t{\n\t\tswitch(vars[i].CommandType)\n\t\t{\n\t\tcase CMD_TYPE_PHYSICAL_DRIVE:\n\t\t\tif(! GetSmartAttributePd(vars[i].PhysicalDriveId, vars[i].Target, &(vars[i])))\n\t\t\t{\n\t\t\t\tWakeUp(vars[i].PhysicalDriveId);\n\t\t\t\tif(! GetSmartAttributePd(vars[i].PhysicalDriveId, vars[i].Target, &(vars[i])))\n\t\t\t\t{\n\t\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n\t\tcase CMD_TYPE_SCSI_MINIPORT:\n\t\t\tif(! GetSmartAttributeScsi(vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t\t{\n\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n\t\tcase CMD_TYPE_SILICON_IMAGE:\n\t\t\tif(! GetSmartAttributeSi(vars[i].PhysicalDriveId, &(vars[i])))\n\t\t\t{\n\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n\t\tcase CMD_TYPE_CSMI:\n\t\t\tif(! GetSmartAttributeCsmi(vars[i].ScsiPort, &(vars[i].sasPhyEntity), &(vars[i])))\n\t\t\t{\n\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n\t\tcase CMD_TYPE_CSMI_PHYSICAL_DRIVE:\n\t\t\tif(! GetSmartAttributePd(vars[i].PhysicalDriveId, vars[i].Target, &(vars[i])))\n\t\t\t{\n\t\t\t\tWakeUp(vars[i].PhysicalDriveId);\n\t\t\t\tif(! GetSmartAttributePd(vars[i].PhysicalDriveId, vars[i].Target, &(vars[i])))\n\t\t\t\t{\n\t\t\t\t\tif(! GetSmartAttributeCsmi(vars[i].ScsiPort, &(vars[i].sasPhyEntity), &(vars[i])))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvars[i].CommandType = CMD_TYPE_CSMI;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n\t\t\n\t\tcase CMD_TYPE_SAT:\n\t\tcase CMD_TYPE_SAT_ASM1352R:\n\t\tcase CMD_TYPE_SUNPLUS:\n\t\tcase CMD_TYPE_IO_DATA:\n\t\tcase CMD_TYPE_LOGITEC:\n\t\tcase CMD_TYPE_PROLIFIC:\n\t\tcase CMD_TYPE_JMICRON:\n\t\tcase CMD_TYPE_CYPRESS:\n\t\t\tWakeUp(vars[i].PhysicalDriveId);\n\t\t\tif(! GetSmartAttributeSat(vars[i].PhysicalDriveId, vars[i].Target, &(vars[i])))\n\t\t\t{\n\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n\t\tcase CMD_TYPE_SAT_REALTEK9220DP:\n\t\t\tWakeUp(vars[i].PhysicalDriveId);\n\t\t\tif (RealtekSwitchMode(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, 1, 1))\n\t\t\t{\n\t\t\t\tif (!GetSmartAttributeSat(vars[i].PhysicalDriveId, vars[i].Target, &(vars[i])))\n\t\t\t\t{\n\t\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t\t}\n\t\t\t\tRealtekSwitchMode(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, 1, 0);\n\t\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_TYPE_WMI:\t\n\t\t\tif(! GetSmartAttributeWmi(&(vars[i])))\n\t\t\t{\n\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n\t\tcase CMD_TYPE_MEGARAID:\n\t\t\tif(! GetSmartAttributeMegaRAID(vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i])))\n\t\t\t{\n\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n#if ! defined(_M_ARM) && ! defined(_M_ARM64)\n\t\tcase CMD_TYPE_AMD_RC2:// +AMD_RC2\n\t\t\tif (!GetSmartDataAMD_RC2(vars[i].ScsiBus, &(vars[i])))\n\t\t\t{\n\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n#endif\n#ifdef JMICRON_USB_RAID_SUPPORT\n\t\tcase CMD_TYPE_JMS56X:\n\t\t\tif (! GetSmartInfoJMS56X(vars[i].ScsiBus, vars[i].ScsiPort, &(vars[i])))\n\t\t\t{\n\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n\t\tcase CMD_TYPE_JMB39X:\n\t\t\tif (!GetSmartInfoJMB39X(vars[i].ScsiBus, vars[i].ScsiPort, &(vars[i])))\n\t\t\t{\n\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n\t\tcase CMD_TYPE_JMS586_40:\n\t\t\tif (!GetSmartInfoJMS586_40(vars[i].ScsiBus, vars[i].ScsiPort, &(vars[i])))\n\t\t\t{\n\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n\t\tcase CMD_TYPE_JMS586_20:\n\t\t\tif (!GetSmartInfoJMS586_20(vars[i].ScsiBus, vars[i].ScsiPort, &(vars[i])))\n\t\t\t{\n\t\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t\t}\n\t\t\tvars[i].DiskStatus = CheckDiskStatus(i);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn SMART_STATUS_NO_CHANGE;\n\t\t}\n\t\treturn CheckSmartAttributeUpdate(i, attribute[i], vars[i].Attribute);\n\t}\n\n\treturn SMART_STATUS_NO_CHANGE;\n}\n\n/* PUBLIC FUNCTION */\nBOOL CAtaSmart::UpdateIdInfo(DWORD i)\n{\n\tBOOL flag = FALSE;\n\tswitch(vars[i].CommandType)\n\t{\n\tcase CMD_TYPE_PHYSICAL_DRIVE:\n\tcase CMD_TYPE_WMI:\n\tcase CMD_TYPE_CSMI_PHYSICAL_DRIVE:\n\t\tflag =  DoIdentifyDevicePd(vars[i].PhysicalDriveId, vars[i].Target, &(vars[i].IdentifyDevice));\n\t\tbreak;\n\tcase CMD_TYPE_SCSI_MINIPORT:\n\t\tflag =  DoIdentifyDeviceScsi(vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i].IdentifyDevice));\n\t\tbreak;\n\tcase CMD_TYPE_SILICON_IMAGE:\n\t\tflag =  DoIdentifyDeviceSi(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiBus, vars[i].SiliconImageType, &(vars[i].IdentifyDevice));\n\t\tbreak;\n\tcase CMD_TYPE_CSMI:\n\t\tflag = DoIdentifyDeviceCsmi(vars[i].ScsiPort, &(vars[i].sasPhyEntity), &(vars[i].IdentifyDevice));\n\t\tbreak;\n\tcase CMD_TYPE_SAT:\n\tcase CMD_TYPE_SAT_ASM1352R:\n\tcase CMD_TYPE_SUNPLUS:\n\tcase CMD_TYPE_IO_DATA:\n\tcase CMD_TYPE_LOGITEC:\n\tcase CMD_TYPE_PROLIFIC:\n\tcase CMD_TYPE_JMICRON:\n\tcase CMD_TYPE_CYPRESS:\n\t\tflag = DoIdentifyDeviceSat(vars[i].PhysicalDriveId, vars[i].Target, &(vars[i].IdentifyDevice), vars[i].CommandType);\n\t\tbreak;\n\tcase CMD_TYPE_SAT_REALTEK9220DP:\n\t\tif (RealtekSwitchMode(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, 1, 1))\n\t\t{\n\t\t\tflag = DoIdentifyDeviceSat(vars[i].PhysicalDriveId, vars[i].Target, &(vars[i].IdentifyDevice), vars[i].CommandType);\n\t\t\tRealtekSwitchMode(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, 1, 0);\n\t\t}\n\t\t break;\n\tcase CMD_TYPE_MEGARAID:\n\t\tflag =  DoIdentifyDeviceMegaRAID(vars[i].ScsiPort, vars[i].ScsiTargetId, &(vars[i].IdentifyDevice));\n\t\tbreak;\n#if ! defined(_M_ARM) && ! defined(_M_ARM64)\n\tcase CMD_TYPE_AMD_RC2:// +AMD_RC2\n\t\tflag = DoIdentifyDeviceAMD_RC2(vars[i].ScsiBus, NULL, NULL, &(vars[i].IdentifyDevice), NULL, NULL);\n\t\tbreak;\n#endif\n#ifdef JMICRON_USB_RAID_SUPPORT\n\tcase CMD_TYPE_JMS56X:\n\t\tflag = DoIdentifyDeviceJMS56X(vars[i].ScsiBus, vars[i].ScsiPort, & (vars[i].IdentifyDevice));\n\t\tbreak;\n\tcase CMD_TYPE_JMB39X:\n\t\tflag = DoIdentifyDeviceJMB39X(vars[i].ScsiBus, vars[i].ScsiPort, &(vars[i].IdentifyDevice));\n\t\tbreak;\n\tcase CMD_TYPE_JMS586_40:\n\t\tflag = DoIdentifyDeviceJMS586_40(vars[i].ScsiBus, vars[i].ScsiPort, &(vars[i].IdentifyDevice));\n\t\tbreak;\n\tcase CMD_TYPE_JMS586_20:\n\t\tflag = DoIdentifyDeviceJMS586_20(vars[i].ScsiBus, vars[i].ScsiPort, &(vars[i].IdentifyDevice));\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn FALSE;\n\t\tbreak;\n\t}\n\n\tif(vars[i].Major >= 3 && vars[i].IdentifyDevice.A.CommandSetSupported2 & (1 << 3))\n\t{\n\t\tvars[i].IsApmSupported = TRUE;\n\t\tif(vars[i].IdentifyDevice.A.CommandSetEnabled2 & (1 << 3))\n\t\t{\n\t\t\tvars[i].IsApmEnabled = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvars[i].IsApmEnabled = FALSE;\n\t\t}\n\t}\n\tif(vars[i].Major >= 5 && vars[i].IdentifyDevice.A.CommandSetSupported2 & (1 << 9))\n\t{\n\t\tvars[i].IsAamSupported = TRUE;\n\t\tif(vars[i].IdentifyDevice.A.CommandSetEnabled2 & (1 << 9))\n\t\t{\n\t\t\tvars[i].IsAamEnabled = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvars[i].IsAamEnabled = FALSE;\n\t\t}\n\t}\n\n\treturn flag;\n}\n\n/* PUBLIC FUNCTION */\nBYTE CAtaSmart::GetAamValue(DWORD i)\n{\n\treturn LOBYTE(vars[i].IdentifyDevice.A.AcoustricManagement);\n}\n\n/* PUBLIC FUNCTION */\nBYTE CAtaSmart::GetApmValue(DWORD i)\n{\n\treturn LOBYTE(vars[i].IdentifyDevice.A.CurrentPowerManagement);\n}\n\n/* PUBLIC FUNCTION */\nBYTE CAtaSmart::GetRecommendAamValue(DWORD i)\n{\n\treturn HIBYTE(vars[i].IdentifyDevice.A.AcoustricManagement);\n}\n\n/* PUBLIC FUNCTION */\nBYTE CAtaSmart::GetRecommendApmValue(DWORD i)\n{\n\treturn HIBYTE(vars[i].IdentifyDevice.A.CurrentPowerManagement);\n}\n\n/* PUBLIC FUNCTION */\nBOOL CAtaSmart::EnableAam(DWORD i, BYTE param)\n{\n\treturn SendAtaCommand(i, 0xEF, 0x42, param);\n}\n\n/* PUBLIC FUNCTION */\nBOOL CAtaSmart::DisableAam(DWORD i)\n{\n\treturn SendAtaCommand(i, 0xEF, 0xC2, 0);\n}\n\n/* PUBLIC FUNCTION */\nBOOL CAtaSmart::EnableApm(DWORD i, BYTE param)\n{\n\treturn SendAtaCommand(i, 0xEF, 0x05, param);\n}\n\n/* PUBLIC FUNCTION */\nBOOL CAtaSmart::DisableApm(DWORD i)\n{\n\treturn SendAtaCommand(i, 0xEF, 0x85, 0);\n}\n\nBOOL CAtaSmart::SendAtaCommand(DWORD i, BYTE main, BYTE sub, BYTE param)\n{\n\tBOOL rtn = FALSE;\n\tWakeUp(vars[i].PhysicalDriveId);\n\tswitch(vars[i].CommandType)\n\t{\n\tcase CMD_TYPE_PHYSICAL_DRIVE:\n\tcase CMD_TYPE_WMI:\n\tcase CMD_TYPE_CSMI_PHYSICAL_DRIVE:\n\t\treturn SendAtaCommandPd(vars[i].PhysicalDriveId, vars[i].Target, main, sub, param, NULL, 0);\n\t\tbreak;\n\tcase CMD_TYPE_SCSI_MINIPORT:\n\t\treturn SendAtaCommandScsi(vars[i].ScsiPort, vars[i].ScsiTargetId, main, sub, param);\n\t\tbreak;\n\tcase CMD_TYPE_SILICON_IMAGE:\n\t\treturn FALSE;\n\t\tbreak;\n\tcase CMD_TYPE_CSMI:\n\t\tif(vars[i].PhysicalDriveId >= 0 && main == 0xEF) // Enable/Disable AAM/APM\n\t\t{\n\t\t\treturn SendAtaCommandPd(vars[i].PhysicalDriveId, vars[i].Target, main, sub, param, NULL, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn SendAtaCommandCsmi(vars[i].ScsiPort, &(vars[i].sasPhyEntity), main, sub, param, NULL, 0);\n\t\t}\n\t\tbreak;\n\tcase CMD_TYPE_SAT:\n\tcase CMD_TYPE_SAT_ASM1352R:\n\tcase CMD_TYPE_SUNPLUS:\n\tcase CMD_TYPE_IO_DATA:\n\tcase CMD_TYPE_LOGITEC:\n\tcase CMD_TYPE_PROLIFIC:\n\tcase CMD_TYPE_JMICRON:\n\tcase CMD_TYPE_CYPRESS:\n\t\treturn SendAtaCommandSat(vars[i].PhysicalDriveId, vars[i].Target, main, sub, param, vars[i].CommandType);\n\t\tbreak;\n\tcase CMD_TYPE_SAT_REALTEK9220DP:\n\t\tif (RealtekSwitchMode(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, 1, 1))\n\t\t{\n\t\t\trtn = SendAtaCommandSat(vars[i].PhysicalDriveId, vars[i].Target, main, sub, param, vars[i].CommandType);\n\t\t\tRealtekSwitchMode(vars[i].PhysicalDriveId, vars[i].ScsiPort, vars[i].ScsiTargetId, 1, 0);\n\t\t\treturn rtn;\n\t\t\t}\n\t\tbreak;\n\tcase CMD_TYPE_MEGARAID:\n\t\treturn SendAtaCommandMegaRAID(vars[i].ScsiPort, vars[i].ScsiTargetId, main, sub, param);\n\t\tbreak;\n\tcase CMD_TYPE_AMD_RC2:// +AMD_RC2\n\tcase CMD_TYPE_JMS56X:\n\tcase CMD_TYPE_JMB39X:\n\tcase CMD_TYPE_JMS586_40:\n\tcase CMD_TYPE_JMS586_20:\n\tdefault:\n\t\treturn FALSE;\n\t\tbreak;\n\t}\n\treturn FALSE;\n}\n\nDWORD CAtaSmart::CheckSmartAttributeUpdate(DWORD index, SMART_ATTRIBUTE* pre, SMART_ATTRIBUTE* cur)\n{\n\tif(! vars[index].IsSmartCorrect)\n\t{\n\t\treturn SMART_STATUS_NO_CHANGE;\n\t}\n\n\tif(memcmp(pre, cur, sizeof(SMART_ATTRIBUTE) * MAX_ATTRIBUTE) == 0)\n\t{\n\t\treturn SMART_STATUS_NO_CHANGE;\n\t}\n\telse\n\t{\n\t\tfor(int i = 0; i < MAX_ATTRIBUTE; i++)\n\t\t{\n\t\t\tswitch(cur[i].Id)\n\t\t\t{\n\t\t\tcase 0x09: // Power on Hours\n\t\t\t\t{\n\t\t\t\t\tDWORD preRawValue = *((DWORD*)&pre[i].RawValue[0])\n\t\t\t\t\t/*MAKELONG(\n\t\t\t\t\t\tMAKEWORD(pre[i].RawValue[0], pre[i].RawValue[1]),\n\t\t\t\t\t\tMAKEWORD(pre[i].RawValue[2], pre[i].RawValue[3])\n\t\t\t\t\t\t)*/;\n\t\t\t\t\tDWORD curRawValue = *((DWORD*)&cur[i].RawValue[0])\n\t\t\t\t\t/*MAKELONG(\n\t\t\t\t\t\tMAKEWORD(cur[i].RawValue[0], cur[i].RawValue[1]),\n\t\t\t\t\t\tMAKEWORD(cur[i].RawValue[2], cur[i].RawValue[3])\n\t\t\t\t\t\t)*/;\n\n\t\t\t\t\tif(vars[index].DiskVendorId == SSD_VENDOR_INDILINX)\n\t\t\t\t\t{\n\t\t\t\t\t\tpreRawValue = pre[i].WorstValue * 256 + pre[i].CurrentValue;\n\t\t\t\t\t\tcurRawValue = cur[i].WorstValue * 256 + cur[i].CurrentValue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(GetPowerOnHours(preRawValue, vars[index].DetectedTimeUnitType)\n\t\t\t\t\t!= GetPowerOnHours(curRawValue, vars[index].DetectedTimeUnitType))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(pre, cur, sizeof(SMART_ATTRIBUTE) * MAX_ATTRIBUTE);\n\t\t\t\t\t\treturn SMART_STATUS_MAJOR_CHANGE;\n\t\t\t\t\t}\n\t\t\t\t\tif(GetPowerOnHours(preRawValue, vars[index].MeasuredTimeUnitType)\n\t\t\t\t\t!= GetPowerOnHours(curRawValue, vars[index].MeasuredTimeUnitType))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(pre, cur, sizeof(SMART_ATTRIBUTE) * MAX_ATTRIBUTE);\n\t\t\t\t\t\treturn SMART_STATUS_MAJOR_CHANGE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x0C: // Power On Count\n\t\t\t\t{\n\t\t\t\t\tDWORD preRawValue = *((DWORD*)&pre[i].RawValue[0])\n\t\t\t\t\t\t/*MAKELONG(\n\t\t\t\t\t\t\tMAKEWORD(pre[i].RawValue[0], pre[i].RawValue[1]),\n\t\t\t\t\t\t\tMAKEWORD(pre[i].RawValue[2], pre[i].RawValue[3])\n\t\t\t\t\t\t\t)*/;\n\t\t\t\t\tDWORD curRawValue = *((DWORD*)&cur[i].RawValue[0])\n\t\t\t\t\t\t/*MAKELONG(\n\t\t\t\t\t\t\tMAKEWORD(cur[i].RawValue[0], cur[i].RawValue[1]),\n\t\t\t\t\t\t\tMAKEWORD(cur[i].RawValue[2], cur[i].RawValue[3])\n\t\t\t\t\t\t\t)*/;\n\n\t\t\t\t\tif(vars[index].DiskVendorId == SSD_VENDOR_INDILINX)\n\t\t\t\t\t{\n\t\t\t\t\t\tpreRawValue = pre[i].WorstValue * 256 + pre[i].CurrentValue;\n\t\t\t\t\t\tcurRawValue = cur[i].WorstValue * 256 + cur[i].CurrentValue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(preRawValue != curRawValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(pre, cur, sizeof(SMART_ATTRIBUTE) * MAX_ATTRIBUTE);\n\t\t\t\t\t\treturn SMART_STATUS_MAJOR_CHANGE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xBE: // 3.9.4 or later\n\t\t\tcase 0xC2: // Temperature\n\t\t\t\tif(pre[i].RawValue[0] != cur[i].RawValue[0]\n\t\t\t\t|| pre[i].CurrentValue != cur[i].CurrentValue)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(pre, cur, sizeof(SMART_ATTRIBUTE) * MAX_ATTRIBUTE);\n\t\t\t\t\treturn SMART_STATUS_MAJOR_CHANGE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// 3.4.0 - \n\t\treturn SMART_STATUS_MAJOR_CHANGE;\n\t\t// return SMART_STATUS_MINOR_CHANGE;\n\t}\n}\n\n/* PUBLIC FUNCTION */\nBOOL CAtaSmart::MeasuredTimeUnit()\n{\n\tULONGLONG getTickCount = GetTickCountFx();\n\tif(getTickCount > MeasuredGetTickCount + 155000 || MeasuredGetTickCount + 125000 > getTickCount)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tfor(int i = 0; i < vars.GetCount(); i++)\n\t{\n\t\tif(vars[i].PowerOnRawValue < 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tUpdateSmartInfo(i);\n\n\t\tDWORD test = vars[i].PowerOnRawValue - vars[i].PowerOnStartRawValue;\n\n\t\tif(vars[i].DetectedTimeUnitType == POWER_ON_MILLI_SECONDS)\n\t\t{\n\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_MILLI_SECONDS;\n\t\t}\n\t\telse if(vars[i].DetectedTimeUnitType == POWER_ON_10_MINUTES)\n\t\t{\n\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_10_MINUTES;\n\t\t}\n\t\telse if(vars[i].DiskVendorId == SSD_VENDOR_INDILINX)\n\t\t{\n\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_HOURS;\n\t\t}\n\t\telse if(vars[i].Model.Find(_T(\"SAMSUNG\")) == 0)\n\t\t{\n\t\t\tif(test >= 2)\n\t\t\t{\n\t\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_HALF_MINUTES;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_HOURS;\n\t\t\t}\n\t\t}\n\t\telse if(vars[i].Model.Find(_T(\"FUJITSU\")) == 0)\n\t\t{\n\t\t\tif(test >= 6)\n\t\t\t{\n\t\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_SECONDS;\n\t\t\t}\n\t\t\telse if(test >= 4)\n\t\t\t{\n\t\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_HALF_MINUTES;\n\t\t\t}\n\t\t\telse if(test >= 2)\n\t\t\t{\n\t\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_MINUTES;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_HOURS;\n\t\t\t}\n\t\t}\n\t\telse if(vars[i].Model.Find(_T(\"MAXTOR\")) == 0)\n\t\t{\n\t\t\tif(test >= 2)\n\t\t\t{\n\t\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_MINUTES;\n\t\t\t\tvars[i].IsMaxtorMinute = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_HOURS;\n\t\t\t\tvars[i].IsMaxtorMinute = FALSE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(test >= 2)\n\t\t\t{\n\t\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_MINUTES;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvars[i].MeasuredTimeUnitType = POWER_ON_HOURS;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\t\n}\n\n/* PUBLIC FUNCTION */\nVOID CAtaSmart::Init(BOOL useWmi, BOOL advancedDiskSearch, PBOOL flagChangeDisk, BOOL workaroundHD204UI, BOOL workaroundAdataSsd, BOOL flagHideNoSmartDisk, BOOL flagSortDriveLetter)\n{\n\t/*\n\tif (1)\n\t{\n\t\tBYTE d[512] = { 0 };\n\n\t\tReadLogExtPd(1, 0xA0, 4, 7, (PBYTE)&d, 512);\n\t\tint WDGreenLife = 100 - d[8];\n\t\tReadLogExtPd(3, 0xA0, 4, 7, (PBYTE)&d, 512);\n\t\tint WDBlueLife = 100 - d[8];\n\t\tReadLogExtPd(2, 0xA0, 4, 7, (PBYTE)&d, 512);\n\t\tint KioxiaLife = 100 - d[8];\n\t\tReadLogExtSat(7, 0xA0, 4, 7, (PBYTE)&d, 512, CMD_TYPE_SAT);\n\t\tint SanDiskU100 = 100 - d[8];\n\n\t\tint debug = 0;\n\t}\n\t*/\n\n\t// Debug\n\t// useWmi = FALSE;\n\n\tIsAdvancedDiskSearch = advancedDiskSearch;\n\tIsEnabledWmi = FALSE;\n\tIsWorkaroundHD204UI = workaroundHD204UI;\n\tIsWorkaroundAdataSsd = workaroundAdataSsd;\n\tint AmdRaidDriverVersion = 0;\n\n\tFlagNvidiaController = FALSE;\n\tFlagMarvellController = FALSE;\n\n\tCArray<DISK_POSITION, DISK_POSITION> previous;\n\t\n\tif(flagChangeDisk != NULL)\n\t{\n\t\t*flagChangeDisk = FALSE;\n\t\tfor(int i = 0; i < vars.GetCount(); i++)\n\t\t{\n\t\t\tDISK_POSITION dp = { };\n\t\t\tdp.PhysicalDriveId = vars[i].PhysicalDriveId;\n\t\t\tdp.ScsiTargetId = vars[i].ScsiTargetId;\n\t\t\tdp.ScsiPort = vars[i].ScsiPort;\n\t\t\tmemcpy(&(dp.sasPhyEntity), &(vars[i].sasPhyEntity), sizeof(CSMI_SAS_PHY_ENTITY));\n\n\t\t\tprevious.Add(dp);\n\t\t}\n\t}\n\n\t// Init\n\tvars.RemoveAll();\n\texternals.RemoveAll();\n\tm_ControllerMap = _T(\"\");\n\tm_BlackIdeController.RemoveAll();\n\tm_BlackScsiController.RemoveAll();\n\tm_SiliconImageController.RemoveAll();\n\tm_UASPController.RemoveAll();\n\tm_SiliconImageControllerType.RemoveAll();\n\n\tBOOL detectUASPdisks = FALSE;\n\tBOOL detectUSBMemory = FALSE;\n\n\tm_BlackPhysicalDrive.RemoveAll();\n\tDWORD driveLetterMap[256] = {0};\n\n\tif(useWmi)\n\t{\n\t\tHRESULT hRes = S_OK;\n\t\tULONG   uReturned = 1;\n\n\t\tIWbemLocator*\t\t\tpIWbemLocator = NULL;\n\t\tIWbemServices*\t\t\tpIWbemServices = NULL;\n\t\tIEnumWbemClassObject*\tpEnumCOMDevs = NULL;\n\t\tIEnumWbemClassObject*\tpEnumCOMDevs2 = NULL;\n\t\tIWbemClassObject*\t\tpCOMDev = NULL;\n\n\t\t\n\t\tDebugPrint(_T(\"CAtaSmart::Init WMI on - Start\"));\n\n\t\tbool initWmi = true;\n\t\tCDnpService\tcService;\n\t\n\t\tif(! cService.IsServiceRunning(_T(\"Winmgmt\")))\n\t\t{\n\t\t\tDebugPrint(_T(\"Waiting... Winmgmt\"));\n\t\t\tinitWmi = cService.EasyStart(_T(\"Winmgmt\"));\n\t\t}\n\n\t\tif(initWmi)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t//\tDebugPrint(_T(\"CoInitialize()\"));\n\t\t\t//\tCoInitialize(NULL);\n\t\t\t\tDebugPrint(_T(\"CoInitializeSecurity()\"));\n\t\t\t\t(void)CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT,\n\t\t\t\t\tRPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);\n\t\t\t\tDebugPrint(_T(\"CoCreateInstance()\"));\n\t\t\t\t//CLSID_WbemAdministrativeLocator / \n\t\t\t\tif(FAILED(CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,\n\t\t\t\t\tIID_IWbemLocator, (LPVOID *)&pIWbemLocator)))\n\t\t\t\t{\n\t\t\t\t//\tCoUninitialize();\n\t\t\t\t\tDebugPrint(_T(\"NG:WMI Init 1\"));\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tlong securityFlag = 0;\n\t\t\t\t\tif(IsWindowsVersionOrGreaterFx(6, 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tsecurityFlag = WBEM_FLAG_CONNECT_USE_MAX_WAIT;\n\t\t\t\t\t}\n\n\t\t\t\t\tDebugPrint(_T(\"ConnectServer()\"));\n\t\t\t\t\tif (FAILED(pIWbemLocator->ConnectServer(_bstr_t(L\"\\\\\\\\.\\\\root\\\\cimv2\"),\n\t\t\t\t\t\tNULL, NULL, 0L,\n\t\t\t\t\t\tsecurityFlag,\n\t\t\t\t\t\tNULL, NULL, &pIWbemServices)))\n\t\t\t\t\t{\n\t\t\t\t\t//\tCoUninitialize();\n\t\t\t\t\t\tDebugPrint(_T(\"NG:WMI Init 2\"));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDebugPrint(_T(\"CoSetProxyBlanket()\"));\n\t\t\t\t\t\thRes = CoSetProxyBlanket(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,\n\t\t\t\t\t\t\tNULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);\n\t\t\t\t\t\tif(FAILED(hRes))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t//\tCoUninitialize();\n\t\t\t\t\t\t\tCString cstr;\n\t\t\t\t\t\t\tcstr.Format(_T(\"NG:WMI Init - %08X\"), hRes);\n\t\t\t\t\t\t\tDebugPrint(cstr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIsEnabledWmi = TRUE;\n\t\t\t\t\t\t\tDebugPrint(_T(\"OK:WMI Init\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSAFE_RELEASE(pIWbemLocator);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(...)\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"EX:WMI Init\"));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebugPrint(_T(\"NG:WMI Init 3\"));\n\t\t}\n\n\t\tif (IsEnabledWmi)\n\t\t{\n\t\t\tCStringArray csa;\n\t\t\tCString temp, cstr, cstr1, cstr2;\n\n\t\t\ttry // Workaround for AMD RAIDXpert2 \n\t\t\t{// Win32_PnPSignedDriver\n\t\t\t\thRes = pIWbemServices->ExecQuery(_bstr_t(L\"WQL\"),\n\t\t\t\t\t_bstr_t(L\"select DeviceName, DriverVersion from Win32_PnPSignedDriver\"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs);\n\t\t\t\tif (FAILED(hRes))\n\t\t\t\t{\n\t\t\t\t\tgoto safeRelease;\n\t\t\t\t}\n\t\t\t\tint workaround = 0;\n\t\t\t\twhile (pEnumCOMDevs && SUCCEEDED(pEnumCOMDevs->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1 && workaround < 512)\n\t\t\t\t{\n\t\t\t\t\tworkaround++;\n\t\t\t\t\tVARIANT  pVal;\n\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\tCString deviceName, driverVersion;\n\t\t\t\t\tif (pCOMDev->Get(L\"DriverVersion\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tdriverVersion = pVal.bstrVal;\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pCOMDev->Get(L\"DeviceName\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tdeviceName = pVal.bstrVal;\n\t\t\t\t\t\tif (deviceName.Find(L\"AMD-RAID Config\") >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDebugPrint(deviceName + L\" \" + driverVersion);\n\t\t\t\t\t\t\tCString cstr;\n\t\t\t\t\t\t\tint major = 0, minor = 0, revision = 0, build = 0;\n\t\t\t\t\t\t\tAfxExtractSubString(cstr, driverVersion, 0, L'.'); \tmajor = _wtoi(cstr);\n\t\t\t\t\t\t\tAfxExtractSubString(cstr, driverVersion, 1, L'.'); \tminor = _wtoi(cstr);\n\t\t\t\t\t\t\tAfxExtractSubString(cstr, driverVersion, 2, L'.'); \trevision = _wtoi(cstr);\n\t\t\t\t\t\t\tAfxExtractSubString(cstr, driverVersion, 3, L'.'); \tbuild = _wtoi(cstr);\n\n\t\t\t\t\t\t\tAmdRaidDriverVersion = major * 10 + minor;\n\t\t\t\t\t\t\tcstr.Format(L\"driverVersion=%d.%d.%d.%d\", major, minor, revision, build);\n\t\t\t\t\t\t\tDebugPrint(cstr);\n\t\t\t\t\t\t\tcstr.Format(L\"AmdRaidDriverVersion=%d\", AmdRaidDriverVersion);\n\t\t\t\t\t\t\tDebugPrint(cstr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\n\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (...)\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"EX:Win32_PnPSignedDriver\"));\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{// Win32_IDEController\n\t\t\t\thRes = pIWbemServices->ExecQuery(_bstr_t(L\"WQL\"),\n\t\t\t\t\t_bstr_t(L\"select Name, DeviceID from Win32_IDEController\"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs);\n\t\t\t\tif (FAILED(hRes))\n\t\t\t\t{\n\t\t\t\t\tgoto safeRelease;\n\t\t\t\t}\n\n\t\t\t\tint workaround = 0;\n\t\t\t\twhile (pEnumCOMDevs && SUCCEEDED(pEnumCOMDevs->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1 && workaround < 512)\n\t\t\t\t{\n\t\t\t\t\tworkaround++;\n\t\t\t\t\tBOOL flagBlackList = FALSE;\n\t\t\t\t\tVARIANT  pVal;\n\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\tCString name1, deviceId, channel;\n\t\t\t\t\tif (pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tdeviceId = pVal.bstrVal;\n\t\t\t\t\t\tif (deviceId.Find(_T(\"PCIIDE\\\\IDECHANNEL\")) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchannel = deviceId.Right(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeviceId.Replace(_T(\"\\\\\"), _T(\"\\\\\\\\\"));\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (pCOMDev->Get(L\"Name\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tname1 = pVal.bstrVal;\n\t\t\t\t\t\tif (!channel.IsEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname1 += _T(\" (\") + channel + _T(\")\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm_IdeController.Add(name1);\n\t\t\t\t\t\tVariantClear(&pVal);\n\n\t\t\t\t\t\t// Black List\n\t\t\t\t\t//\tif(name1.Find(_T(\"\")) == 0)\n\t\t\t\t\t//\t{\n\t\t\t\t\t//\t\tflagBlackList = TRUE;\n\t\t\t\t\t//\t}\n\t\t\t\t\t}\n\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\n\t\t\t\t\tif (cstr.Find(name1) == -1 || cstr.Find(name1 + _T(\" [ATA]\")) >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcsa.Add(cstr);\n\t\t\t\t\t\tcstr = _T(\"%%%\") + name1 + _T(\" [ATA]\");\n\t\t\t\t\t\tcstr += _T(\"\\r\\n\");\n\t\t\t\t\t}\n\n\t\t\t\t\tint workaroundDevice = 0;\n\t\t\t\t\tCString mapping;\n\t\t\t\t\tmapping.Format(_T(\"ASSOCIATORS OF {Win32_IDEController.DeviceID=\\\"%s\\\"} WHERE AssocClass = Win32_IDEControllerDevice\"), deviceId.GetString());\n\t\t\t\t\tpIWbemServices->ExecQuery(_bstr_t(L\"WQL\"), _bstr_t(mapping), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs2);\n\t\t\t\t\twhile (pEnumCOMDevs2 && SUCCEEDED(pEnumCOMDevs2->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1 && workaroundDevice < 256)\n\t\t\t\t\t{\n\t\t\t\t\t\tworkaroundDevice++;\n\t\t\t\t\t\tVARIANT pVal;\n\t\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\t\tCString name2, deviceId, channel;\n\t\t\t\t\t\tif (pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdeviceId = pVal.bstrVal;\n\t\t\t\t\t\t\tif (deviceId.Find(_T(\"PCIIDE\\\\IDECHANNEL\")) == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tchannel = deviceId.Right(1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (flagBlackList)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tm_BlackIdeController.Add(deviceId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pCOMDev->Get(L\"Name\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname2 = pVal.bstrVal;\n\t\t\t\t\t\t\tif (!channel.IsEmpty())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname2 += _T(\" (\") + channel + _T(\")\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\n\t\t\t\t\t\t// NVIDIA ATA Controller\n\t\t\t\t\t\tif (name1.Find(_T(\"NVIDIA\")) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFlagNvidiaController = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Marvell ATA Controller\n\t\t\t\t\t\tif (name1.Find(_T(\"Marvell\")) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFlagMarvellController = TRUE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (cstr.Find(_T(\"   - \") + name1) >= 0 || cstr.Find(_T(\"   + \") + name1) >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcstr1 = _T(\"- \") + name1;\n\t\t\t\t\t\t\tcstr2 = _T(\"+ \") + name1;\n\t\t\t\t\t\t\tcstr.Replace(cstr1, cstr2);\n\n\t\t\t\t\t\t\tcstr1 = name1 + _T(\"\\r\\n     - \") + name2;\n\t\t\t\t\t\t\tcstr.Replace(name1, cstr1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcstr += _T(\"   - \") + name2 + _T(\"\\r\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcstr.Replace(_T(\"%%%\"), _T(\" + \"));\n\t\t\t\t\t}\n\t\t\t\t\tcstr.Replace(_T(\"%%%\"), _T(\" - \"));\n\t\t\t\t\tSAFE_RELEASE(pEnumCOMDevs2);\n\t\t\t\t}\n\t\t\t\tcsa.Add(cstr);\n\t\t\t\tSAFE_RELEASE(pEnumCOMDevs);\n\t\t\t\tDebugPrint(_T(\"OK:Win32_IDEController\"));\n\t\t\t}\n\t\t\tcatch (...)\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"EX:Win32_IDEController\"));\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcstr = _T(\"\");\n\t\t\t\thRes = pIWbemServices->ExecQuery(_bstr_t(L\"WQL\"),\n\t\t\t\t\t_bstr_t(L\"select Name, DeviceID from Win32_SCSIController\"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs);\n\t\t\t\tif (FAILED(hRes))\n\t\t\t\t{\n\t\t\t\t\tgoto safeRelease;\n\t\t\t\t}\n\n\t\t\t\tint workaroundController = 0;\n\t\t\t\twhile (pEnumCOMDevs && SUCCEEDED(pEnumCOMDevs->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1 && workaroundController < 256)\n\t\t\t\t{\n\t\t\t\t\tworkaroundController++;\n\t\t\t\t\tBOOL flagUASP = FALSE;\n\t\t\t\t\tBOOL flagBlackList = FALSE;\n\t\t\t\t\tBOOL flagSiliconImage = FALSE;\n\t\t\t\t\tDWORD siliconImageType = 0;\n\n\t\t\t\t\tVARIANT  pVal;\n\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\tCString name1, deviceId;\n\t\t\t\t\tif (pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tdeviceId = pVal.bstrVal;\n\t\t\t\t\t\tdeviceId.Replace(_T(\"\\\\\"), _T(\"\\\\\\\\\"));\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (pCOMDev->Get(L\"Name\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tname1 = pVal.bstrVal;\n\t\t\t\t\t\tm_ScsiController.Add(name1);\n\t\t\t\t\t\tVariantClear(&pVal);\n\n\t\t\t\t\t\t// UASP List\n\t\t\t\t\t\tif (name1.Find(_T(\"USB\")) >= 0 || name1.Find(_T(\"UAS\")) >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagUASP = TRUE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Black List\n\t\t\t\t\t\tif (!IsAdvancedDiskSearch\n\t\t\t\t\t\t\t&& (name1.Find(_T(\"VIA VT6410\")) == 0)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagBlackList = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!IsAdvancedDiskSearch\n\t\t\t\t\t\t\t&& (name1.Find(_T(\"ITE IT8212\")) == 0)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagBlackList = TRUE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// NVIDIA SCSI Controller\n\t\t\t\t\t\tif (name1.Find(_T(\"NVIDIA\")) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFlagNvidiaController = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Marvell SCSI Controller\n\t\t\t\t\t\tif (name1.Find(_T(\"Marvell\")) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFlagMarvellController = TRUE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Workaround for DVDFab Virtual Drive\n\t\t\t\t\t\tif (name1.Find(_T(\"DVDFab Virtual Drive\")) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Silicon Image Controller\n\t\t\t\t\t\tif (name1.Find(_T(\"Silicon Image SiI \")) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagSiliconImage = TRUE;\n\t\t\t\t\t\t\tCString cstr;\n\t\t\t\t\t\t\tcstr = name1;\n\t\t\t\t\t\t\tcstr.Replace(_T(\"Silicon Image SiI \"), _T(\"\"));\n\t\t\t\t\t\t\tsiliconImageType = _tstoi(cstr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=836;id=diskinfo#836\n\t\t\t\t\t\telse if (name1.Find(_T(\"BUFFALO IFC-PCI2ES\")) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagSiliconImage = TRUE;\n\t\t\t\t\t\t\tsiliconImageType = 3112;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1270;id=diskinfo#1270\n\t\t\t\t\t\t// http://dream-drive.net/archives/2010/01/ifc-pcie2sawo.html\n\t\t\t\t\t\telse if (name1.Find(_T(\"BUFFALO IFC-PCIE2SA\")) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagSiliconImage = TRUE;\n\t\t\t\t\t\t\tsiliconImageType = 3132;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\t\t\t\t\tif (cstr.Find(name1) == -1 || cstr.Find(name1 + _T(\" [SCSI]\")) >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcsa.Add(cstr);\n\t\t\t\t\t\tcstr = _T(\"%%%\") + name1 + _T(\" [SCSI]\");\n\t\t\t\t\t\tcstr += _T(\"\\r\\n\");\n\t\t\t\t\t}\n\n\t\t\t\t\tint workaroundDevice = 0;\n\t\t\t\t\tCString mapping;\n\t\t\t\t\tmapping.Format(_T(\"ASSOCIATORS OF {Win32_SCSIController.DeviceID=\\\"%s\\\"} WHERE AssocClass = Win32_SCSIControllerDevice\"), deviceId.GetString());\n\t\t\t\t\tpIWbemServices->ExecQuery(_bstr_t(L\"WQL\"), _bstr_t(mapping), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs2);\n\t\t\t\t\twhile (pEnumCOMDevs2 && SUCCEEDED(pEnumCOMDevs2->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1 && workaroundDevice < 256)\n\t\t\t\t\t{\n\t\t\t\t\t\tworkaroundDevice++;\n\t\t\t\t\t\tVARIANT pVal;\n\t\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\t\tCString name2, deviceId;\n\t\t\t\t\t\tif (pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdeviceId = pVal.bstrVal;\n\t\t\t\t\t\t\tVariantClear(&pVal);\n\n\t\t\t\t\t\t\tif (flagUASP)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tm_UASPController.Add(deviceId);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flagBlackList)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tm_BlackScsiController.Add(deviceId);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (flagSiliconImage)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tm_SiliconImageController.Add(deviceId);\n\t\t\t\t\t\t\t\tm_SiliconImageControllerType.Add(siliconImageType);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pCOMDev->Get(L\"Name\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname2 = pVal.bstrVal;\n\t\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\n\t\t\t\t\t\tif (cstr.Find(_T(\"   - \") + name1) >= 0 || cstr.Find(_T(\"   + \") + name1) >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcstr1 = _T(\"- \") + name1;\n\t\t\t\t\t\t\tcstr2 = _T(\"+ \") + name1;\n\t\t\t\t\t\t\tcstr.Replace(cstr1, cstr2);\n\n\t\t\t\t\t\t\tcstr1 = name1 + _T(\"\\r\\n     - \") + name2;\n\t\t\t\t\t\t\tcstr.Replace(name1, cstr1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcstr += _T(\"   - \") + name2 + _T(\"\\r\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcstr.Replace(_T(\"%%%\"), _T(\" + \"));\n\t\t\t\t\t}\n\t\t\t\t\tcstr.Replace(_T(\"%%%\"), _T(\" - \"));\n\t\t\t\t\tSAFE_RELEASE(pEnumCOMDevs2);\n\t\t\t\t}\n\t\t\t\tcsa.Add(cstr);\n\t\t\t\tSAFE_RELEASE(pEnumCOMDevs);\n\t\t\t\tDebugPrint(_T(\"OK:Win32_SCSIController\"));\n\t\t\t}\n\t\t\tcatch (...)\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"EX:Win32_SCSIController\"));\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < csa.GetCount(); i++)\n\t\t\t{\n\t\t\t\tm_ControllerMap += csa.GetAt(i);\n\t\t\t}\n\n\t\t\tDebugPrint(_T(\"--ControllerMap--\\r\\n\") + m_ControllerMap);\n\n\t\t\ttry\n\t\t\t{// Win32_USBController\n\t\t\t\thRes = pIWbemServices->ExecQuery(_bstr_t(L\"WQL\"),\n\t\t\t\t\t_bstr_t(L\"select Name, DeviceID from Win32_USBController\"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs);\n\t\t\t\tif (FAILED(hRes))\n\t\t\t\t{\n\t\t\t\t\tgoto safeRelease;\n\t\t\t\t}\n\n\t\t\t\twhile (pEnumCOMDevs && SUCCEEDED(pEnumCOMDevs->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1)\n\t\t\t\t{\n\t\t\t\t\tVARIANT  pVal;\n\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\tCString deviceId, channel;\n\t\t\t\t\tif (pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tdeviceId = pVal.bstrVal;\n\t\t\t\t\t\tdeviceId.Replace(_T(\"\\\\\"), _T(\"\\\\\\\\\"));\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\n\t\t\t\t\tCString mapping, enclosure;\n\t\t\t\t\tmapping.Format(_T(\"ASSOCIATORS OF {Win32_USBController.DeviceID=\\\"%s\\\"} WHERE AssocClass = Win32_USBControllerDevice\"), deviceId.GetString());\n\t\t\t\t\tpIWbemServices->ExecQuery(_bstr_t(L\"WQL\"), _bstr_t(mapping), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs2);\n\t\t\t\t\twhile (pEnumCOMDevs2 && SUCCEEDED(pEnumCOMDevs2->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tVARIANT pVal;\n\t\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\t\tif (pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcstr = pVal.bstrVal;\n\t\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t\t\tif (cstr.Find(_T(\"USBSTOR\")) >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tEXTERNAL_DISK_INFO edi;\n\t\t\t\t\t\t\t\tedi.UsbProductId = 0;\n\t\t\t\t\t\t\t\tedi.UsbVendorId = 0;\n\t\t\t\t\t\t\t\tint curPos = 0;\n\t\t\t\t\t\t\t\tCString resToken;\n\t\t\t\t\t\t\t\tresToken = deviceId.Tokenize(_T(\"\\\\&\"), curPos);\n\t\t\t\t\t\t\t\twhile (resToken != _T(\"\"))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (resToken.Replace(_T(\"VID_\"), _T(\"\")) > 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tedi.UsbVendorId = _tcstol(resToken, NULL, 16);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (resToken.Replace(_T(\"PID_\"), _T(\"\")) > 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tedi.UsbProductId = _tcstol(resToken, NULL, 16);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tresToken = deviceId.Tokenize(_T(\"\\\\&\"), curPos);\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (pCOMDev->Get(L\"Name\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tedi.Enclosure = pVal.bstrVal;\n\t\t\t\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\texternals.Add(edi);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdeviceId = cstr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\t\t\t\t\t}\n\t\t\t\t\tSAFE_RELEASE(pEnumCOMDevs2);\n\t\t\t\t}\n\t\t\t\tSAFE_RELEASE(pEnumCOMDevs);\n\t\t\t\tDebugPrint(_T(\"OK:Win32_USBController\"));\n\n\t\t\t\tfor (int i = 0; i < externals.GetCount(); i++)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"VID=%04Xh, PID=%04Xh\"), externals[i].UsbVendorId, externals[i].UsbProductId);\n\t\t\t\t\tDebugPrint(cstr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (...)\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"EX:Win32_USBController\"));\n\t\t\t}\n\t\t\t/*\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{// Win32_1394Controller\n\t\t\t\t\t\t\tpIWbemServices->ExecQuery(_bstr_t(L\"WQL\"),\n\t\t\t\t\t\t\t\t_bstr_t(L\"select Name, DeviceID from Win32_1394Controller\"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs);\n\t\t\t\t\t\t\twhile(pEnumCOMDevs && SUCCEEDED(pEnumCOMDevs->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tVARIANT  pVal;\n\t\t\t\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\t\t\t\tCString deviceId, channel;\n\t\t\t\t\t\t\t\tif(pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdeviceId = pVal.bstrVal;\n\t\t\t\t\t\t\t\t\tdeviceId.Replace(_T(\"\\\\\"), _T(\"\\\\\\\\\"));\n\t\t\t\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\n\t\t\t\t\t\t\t\tCString mapping, enclosure;\n\t\t\t\t\t\t\t\tmapping.Format(_T(\"ASSOCIATORS OF {Win32_1394Controller.DeviceID=\\\"%s\\\"} WHERE AssocClass = Win32_1394ControllerDevice\"), deviceId);\n\t\t\t\t\t\t\t\tpIWbemServices->ExecQuery(_bstr_t(L\"WQL\"), _bstr_t(mapping), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs2);\n\t\t\t\t\t\t\t\twhile(pEnumCOMDevs2 && SUCCEEDED(pEnumCOMDevs2->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tVARIANT pVal;\n\t\t\t\t\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\t\t\t\t\tif(pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdeviceId = pVal.bstrVal;\n\t\t\t\t\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tSAFE_RELEASE(pEnumCOMDevs2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSAFE_RELEASE(pEnumCOMDevs);\n\t\t\t\t\t\t\tDebugPrint(_T(\"OK:Win32_1394Controller\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(...)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDebugPrint(_T(\"EX:Win32_1394Controller\"));\n\t\t\t\t\t\t}\n\t\t\t*/\n\t\t\t/* DEBUG\n\t\t\tfor(int i = 0; i < externals.GetCount(); i++)\n\t\t\t{\n\t\t\t\tCString cstr;\n\t\t\t\tcstr.Format(_T(\"Enclosure=%s, VID=%04X, PID=%04X\"),\n\t\t\t\t\texternals.GetAt(i).Enclosure,\n\t\t\t\t\texternals.GetAt(i).VendorId,\n\t\t\t\t\texternals.GetAt(i).ProductId);\n\n\t\t\t\tAfxMessageBox(cstr);\n\t\t\t}\n\t\t\t*/\n\t\t\tcstr.Format(_T(\"MAX_SEARCH_PHYSICAL_DRIVE\"));\n\n\t\t\tfor (int i = 0; i < MAX_SEARCH_PHYSICAL_DRIVE; i++)\n\t\t\t{\n\t\t\t\tBOOL\tbRet = FALSE;\n\t\t\t\tHANDLE\thIoCtrl = NULL;\n\t\t\t\tDWORD\tdwReturned = 0;\n\t\t\t\tDISK_GEOMETRY dg = { 0 };\n\t\t\t\t//CAtaSmart::INTERFACE_TYPE interfaceType = CAtaSmart::INTERFACE_TYPE::INTERFACE_TYPE_UNKNOWN;\n\t\t\t\t//CAtaSmart::VENDOR_ID vendor = CAtaSmart::VENDOR_ID::VENDOR_UNKNOWN;\n\n\t\t\t\thIoCtrl = GetIoCtrlHandle(i);\n\t\t\t\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t\t\t\t{\n\t\t\t\t\t///\tDebugPrint(_T(\"INVALID_HANDLE_VALUE - continue\"));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t///\tDebugPrint(_T(\"DeviceIoControl\"));\n\t\t\t\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_DISK_GET_DRIVE_GEOMETRY,\n\t\t\t\t\tNULL, 0, &dg, sizeof(DISK_GEOMETRY),\n\t\t\t\t\t&dwReturned, NULL);\n\t\t\t\tif (dg.MediaType == FixedMedia)\n\t\t\t\t{\n\t\t\t\t\tCString cstr;\n\t\t\t\t\tcstr.Format(_T(\"WakeUp(%d)\"), i);\n\t\t\t\t\tDebugPrint(cstr);\n\t\t\t\t\tWakeUp(i);\n\t\t\t\t}\n\t\t\t\tsafeCloseHandle(hIoCtrl);\n\t\t\t}\n\n#if ! defined(_M_ARM) && ! defined(_M_ARM64)\n\t\t\t///////////////////////////////\n\t\t\t// Intel/AMD RAID support\n\t\t\t///////////////////////////////\n\n\t\t\tDebugPrint(L\"CSMI\");\n\t\t\t//AMD RAIDXpert2 9.3.x// +AMD_RC2\n\t\t\tif (FlagAMD_RC2 && AmdRaidDriverVersion >= 93)\n\t\t\t{\n\t\t\t\tDebugPrint(L\"AddDiskAMD_RC2\");\n\t\t\t\tif (! AddDiskAMD_RC2())\n\t\t\t\t{\n\t\t\t\t\tDebugPrint(L\"AMD RAID (CSMI)\");\n\t\t\t\t\tfor (int i = 0; i < MAX_SEARCH_SCSI_PORT; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tAddDiskCsmi(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse // +AMD_RC2\n\t\t\t// AMD RAIDXpert2 9.2.0.x may cause BSoD\n\t\t\tif (AmdRaidDriverVersion != 92)// -2021/11/06\n\t\t\t{\n\t\t\t\tDebugPrint(L\"Intel/AMD RAID (CSMI)\");\n\t\t\t\tfor (int i = 0; i < MAX_SEARCH_SCSI_PORT; i++)\n\t\t\t\t{\n\t\t\t\t\tAddDiskCsmi(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Intel RST on Windows 11 22H2\n\t\t\t// https://crystalmark.info/board/c-board.cgi?cmd=one;no=2354;id=#2354\n\t\t\t/*\n\t\t\tif (CsmiType != CSMI_TYPE_DISABLE)\n\t\t\t{\n\t\t\t\tIDENTIFY_DEVICE identify = {};\n\t\t\t\tDWORD diskSize = 0;\n\t\t\t\tfor (int port = 0; port < 8; port++)\n\t\t\t\t{\n\t\t\t\t\tfor (int pathId = 0; pathId < 16; pathId++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcstr.Format(L\"DoIdentifyDeviceNVMeIntelRst(-1, %d, %d)\", port, pathId);\n\t\t\t\t\t\tDebugPrint(cstr);\n\t\t\t\t\t\tif (DoIdentifyDeviceNVMeIntelRst(-1, port, pathId, &identify, &diskSize))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDebugPrint(L\"AddDiskNVMe\");\n\t\t\t\t\t\t\tAddDiskNVMe(-1, port, pathId, 0, 0, CMD_TYPE_NVME_INTEL_RST, &identify, &diskSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n#endif\n\t\t\t///////////////////////////////\n\t\t\t// MegaRAID SAS support\n\t\t\t///////////////////////////////\n\t\t\tif(FlagMegaRAID)\n\t\t\t{\n\t\t\t\tDebugPrint(L\"MegaRAID\");\n\t\t\t\tfor(int i = 0; i < MAX_SEARCH_SCSI_PORT; i++)\n\t\t\t\t{\n\t\t\t\t\tAddDiskMegaRAID(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t///////////////////////////////\n\t\t\t// Inteel VROC support\n\t\t\t///////////////////////////////\n\t\t\tif(FlagIntelVROC)\n\t\t\t{\n\t\t\t\tIDENTIFY_DEVICE identify = {};\n\t\t\t\tDWORD diskSize = 0;\n\t\t\t\tfor (int port = 0; port < MAX_SEARCH_SCSI_PORT; port++)\n\t\t\t\t{\n\t\t\t\t\tfor (int target = 0; target < MAX_SEARCH_SCSI_TARGET_ID; target++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (DoIdentifyDeviceNVMeIntelVroc(-1, port, target, &identify, &diskSize))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAddDiskNVMe(-1, port, target, 0, 0, CMD_TYPE_NVME_INTEL_VROC, &identify, &diskSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t///////////////////////////////\n\t\t\t// JMicron USB RAID\n\t\t\t///////////////////////////////\n#ifdef JMICRON_USB_RAID_SUPPORT\n\t\t\tif (FlagUsbJMS56X)\n\t\t\t{\n\t\t\t\tDebugPrint(L\"JMS56X\");\n\n\t\t\t\tif(InitializeJMS56X(&hJMS56X))\n\t\t\t\t{\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tcount = pGetControllerCountJMS56X();\n\n\t\t\t\t\tcstr.Format(L\"ControllerCount: %d\", count);\n\t\t\t\t\tDebugPrint(cstr);\n\n\t\t\t\t\tfor (int i = 0; i < count; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tAddDiskJMS56X(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (FlagUsbJMB39X)\n\t\t\t{\n\t\t\t\tDebugPrint(L\"JMB39X\");\n\n\t\t\t\tif (InitializeJMB39X(&hJMB39X))\n\t\t\t\t{\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tcount = pGetControllerCountJMB39X();\n\n\t\t\t\t\tcstr.Format(L\"ControllerCount: %d\", count);\n\t\t\t\t\tDebugPrint(cstr);\n\n\t\t\t\t\tfor (int i = 0; i < count; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tAddDiskJMB39X(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\ttry\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"DO:SELECT * FROM Win32_DiskDrive\"));\n\t\t\t\thRes = pIWbemServices->ExecQuery(_bstr_t(L\"WQL\"), \n\t\t\t\t\t_bstr_t(L\"SELECT * FROM Win32_DiskDrive\"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs);\n\t\t\t\tif(FAILED(hRes))\n\t\t\t\t{\n\t\t\t\t\tgoto safeRelease;\n\t\t\t\t}\n\t\t\t\tDebugPrint(_T(\"OK1:SELECT * FROM Win32_DiskDrive\"));\n\n\t\t\t\tif(! pEnumCOMDevs)\n\t\t\t\t{\n\t\t\t\t\tDebugPrint(_T(\"pEnumCOMDevs == NULL\"));\n\t\t\t\t\tgoto safeRelease;\n\t\t\t\t}\n\n\t\t\t\twhile(SUCCEEDED(pEnumCOMDevs->Next(10000, 1, &pCOMDev, &uReturned)))\n\t\t\t\t{\n\t\t\t\t\tif(uReturned != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tDebugPrint(_T(\"uReturned != 1\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tDebugPrint(_T(\"while(pEnumCOMDevs ...\"));\n\t\t\t\t\tCString mapping1, mapping2;\n\t\t\t\t\tCString model, deviceId, diskSize, mediaType, interfaceTypeWmi, pnpDeviceId, firmware;\n\t\t\t\t\tINT physicalDriveId = -1, scsiPort = -1, scsiTargetId = -1, scsiBus = -1;\n\t\t\t\t\tBOOL flagTarget = FALSE;\n\t\t\t\t\tBOOL flagBlackList = FALSE;\n\t\t\t\t\tBOOL flagUasp = FALSE;\n\t\t\t\t\tBOOL flagNVMe = FALSE;\n\t\t\t\t\tDWORD siliconImageType = 0;\n\t\t\t\t\t\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tVARIANT pVal;\n\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\tif(pCOMDev->Get(L\"Size\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tdiskSize = pVal.bstrVal;\n\t\t\t\t\t\tDebugPrint(_T(\"diskSize:\") + diskSize);\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tdeviceId = pVal.bstrVal;\n\t\t\t\t\t\tDebugPrint(_T(\"deviceId:\") + deviceId);\n\t\t\t\t\t\tdeviceId.Replace(_T(\"\\\\\"), _T(\"\\\\\\\\\"));\n\t\t\t\t\t\tif(_ttoi(deviceId.Right(2)) >= 10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tphysicalDriveId = _ttoi(deviceId.Right(2));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tphysicalDriveId = _ttoi(deviceId.Right(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\t\t\t\t\tif(pCOMDev->Get(L\"Model\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel = pVal.bstrVal;\n\t\t\t\t\t\tDebugPrint(_T(\"model:\") + model);\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\t\t\t\t\tif(pCOMDev->Get(L\"FirmwareRevision\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tfirmware = pVal.bstrVal;\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\t\t\t\t\tif(pCOMDev->Get(L\"SCSIPort\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tscsiPort = pVal.intVal;\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\t\t\t\n\t\t\t\t\tif(pCOMDev->Get(L\"SCSITargetId\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tscsiTargetId = pVal.intVal;\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\t\t\t\t\tif(pCOMDev->Get(L\"SCSIBus\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tscsiBus = pVal.intVal;\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\t\t\t\t\tif(pCOMDev->Get(L\"MediaType\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tmediaType = pVal.bstrVal;\n\t\t\t\t\t\tDebugPrint(_T(\"mediaType:\") + mediaType);\n\t\t\t\t\t\tmediaType.MakeLower();\n\t\t\t\t\t\tVariantClear(&pVal);\n\n\t\t\t\t\t\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=994;id=diskinfo#994\n\t\t\t\t\t\tif(model.Find(_T(\"SanDisk Extreme\")) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagTarget = TRUE;\n\t\t\t\t\t\t\tdetectUSBMemory = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1198;id=diskinfo#1198\n\t\t\t\t\t\telse if(model.Find(_T(\"Kingston DT Ultimate\")) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagTarget = TRUE;\n\t\t\t\t\t\t\tdetectUSBMemory = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(FlagUsbMemory)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagTarget = TRUE;\n\t\t\t\t\t\t\tdetectUSBMemory = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(mediaType.Find(_T(\"removable\")) >= 0 || mediaType.IsEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagTarget = FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagTarget = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(pCOMDev->Get(L\"InterfaceType\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tinterfaceTypeWmi = pVal.bstrVal;\n\t\t\t\t\t\tDebugPrint(_T(\"interfaceTypeWmi:\") + interfaceTypeWmi);\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Added 3.3.1 (Controller Black List Support)\n\t\t\t\t\tif(pCOMDev->Get(L\"PNPDeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tpnpDeviceId = pVal.bstrVal;\n\t\t\t\t\t\tDebugPrint(_T(\"pnpDeviceId:\") + pnpDeviceId);\n\t\t\t\t\t\tpnpDeviceId.MakeUpper();\n\t\t\t\t\t\tVariantClear(&pVal);\n\n\t\t\t\t\t\t// Is UAS Controller (5.2.0-)\n\t\t\t\t\t\tfor(int i = 0; i < m_UASPController.GetCount(); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(m_UASPController.GetAt(i).Find(pnpDeviceId) >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDebugPrint(_T(\"UASPController:\") + pnpDeviceId);\n\t\t\t\t\t\t\t\tflagUasp = TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Is Silicon Image Controller\n\t\t\t\t\t\tfor(int i = 0; i < m_SiliconImageController.GetCount(); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(m_SiliconImageController.GetAt(i).Find(pnpDeviceId) >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDebugPrint(_T(\"SiliconImageController:\") + pnpDeviceId);\n\t\t\t\t\t\t\t\tsiliconImageType = m_SiliconImageControllerType.GetAt(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor(int i = 0; i < m_BlackIdeController.GetCount(); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(m_BlackIdeController.GetAt(i).Find(pnpDeviceId) >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDebugPrint(_T(\"BlackIdeController:\") + pnpDeviceId);\n\t\t\t\t\t\t\t\tm_BlackPhysicalDrive.Add(physicalDriveId);\n\t\t\t\t\t\t\t\tflagBlackList = TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int i = 0; i < m_BlackScsiController.GetCount(); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(m_BlackScsiController.GetAt(i).Find(pnpDeviceId) >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDebugPrint(_T(\"BlackScsiController:\") + pnpDeviceId);\n\t\t\t\t\t\t\t\tflagBlackList = TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\n\t\t\t\t\tif(! flagBlackList)\n\t\t\t\t\t{\n\t\t\t\t\t\t// GetDiskInfo\n\t\t\t\t\t\tCString cstr;\n\t\t\t\t\t\tcstr.Format(_T(\"DO:GetDiskInfo pd=%d, sp=%d, st=%d, mt=%s\"), physicalDriveId, scsiPort, scsiTargetId, mediaType.GetString());\n\t\t\t\t\t\tDebugPrint(cstr);\n\n\t\t\t\t\t\tINTERFACE_TYPE interfaceType = INTERFACE_TYPE::INTERFACE_TYPE_UNKNOWN;\n\t\t\t\t\t\tCOMMAND_TYPE commandType = COMMAND_TYPE::CMD_TYPE_UNKNOWN;\n\t\t\t\t\t\tVENDOR_ID usbVendorId = VENDOR_ID::VENDOR_UNKNOWN;\n\t\t\t\t\t\tDWORD usbProductId = 0;\n\n\t\t\t\t\t\tif(interfaceTypeWmi.Find(_T(\"1394\")) >= 0 || model.Find(_T(\" IEEE 1394 SBP2 Device\")) > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDebugPrint(_T(\"INTERFACE_TYPE_IEEE1394\"));\n\t\t\t\t\t\t\tinterfaceType = INTERFACE_TYPE_IEEE1394;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(interfaceTypeWmi.Find(_T(\"USB\")) >= 0 || model.Find(_T(\" USB Device\")) > 0 || flagUasp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDebugPrint(_T(\"INTERFACE_TYPE_USB\"));\n\t\t\t\t\t\t\tinterfaceType = INTERFACE_TYPE_USB;\n\n\t\t\t\t\t\t\tif (model.Find(_T(\"NVMe\")) >= 0 || pnpDeviceId.Find(_T(\"NVME\")) >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflagNVMe = TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (model.Find(_T(\"NVMe\")) >= 0 || pnpDeviceId.Find(_T(\"NVME\")) >= 0 || model.Find(_T(\"Optane\")) >= 0 || pnpDeviceId.Find(_T(\"OPTANE\")) >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDebugPrint(_T(\"INTERFACE_TYPE_NVME\"));\n\t\t\t\t\t\t\tinterfaceType = INTERFACE_TYPE_NVME;\n\t\t\t\t\t\t\tflagNVMe = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagTarget = TRUE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcstr.Format(L\"InterfaceTypeId=%d\", interfaceType);\n\t\t\t\t\t\tDebugPrint(cstr);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int i = 0; i < externals.GetCount(); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(model.Find(externals.GetAt(i).Enclosure) == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tusbVendorId = (VENDOR_ID)externals[i].UsbVendorId;\n\t\t\t\t\t\t\t\tusbProductId = externals[i].UsbProductId;\n\t\t\t\t\t\t\t\tcstr.Format(_T(\"usbVendorId=%04X, usbProductId=%04X\"), usbVendorId, usbProductId);\n\t\t\t\t\t\t\t\tDebugPrint(cstr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(IsAdvancedDiskSearch && mediaType.IsEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagTarget = TRUE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// [2010/12/05] Workaround for SAMSUNG HD204UI\n\t\t\t\t\t\t// http://sourceforge.net/apps/trac/smartmontools/wiki/SamsungF4EGBadBlocks\n\t\t\t\t\t\tif((model.Find(_T(\"SAMSUNG HD155UI\")) == 0 || model.Find(_T(\"SAMSUNG HD204UI\")) == 0) && firmware.Find(_T(\"1AQ10003\")) != 0 && IsWorkaroundHD204UI)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagTarget = FALSE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// [2018/10/24] Workaround for FuzeDrive (AMDStoreMi)\n\t\t\t\t\t\tif (model.Find(_T(\"FuzeDrive\")) != -1 || model.Find(_T(\"StoreMI\")) != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflagTarget = FALSE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint previousCount = (int)vars.GetCount();\n\t\t\t\t\t\tDebugPrint(_T(\"flagTarget && GetDiskInfo\"));\n\t\t\t\t\t\tif (flagTarget && GetDiskInfo(physicalDriveId, scsiPort, scsiTargetId, interfaceType, commandType, usbVendorId, usbProductId, scsiBus, siliconImageType, FlagNvidiaController, FlagMarvellController, pnpDeviceId, flagNVMe, flagUasp))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCString debug;\n\t\t\t\t\t\t\tdebug.Format(L\"index=%d\", (int)vars.GetCount() - 1);\n\t\t\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\t\t\t// for ASM1352 support\n\t\t\t\t\t\t\tfor(int index = (int)vars.GetCount() - 1; index + 1 > previousCount; index--)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdebug.Format(L\"index=%d, previousCount=%d\", (int)vars.GetCount() - 1, previousCount);\n\t\t\t\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\t\t\t//\tint index = (int)vars.GetCount() - 1;\n\t\t\t\t\t\t\t\tif (!diskSize.IsEmpty())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvars[index].DiskSizeWmi = (DWORD)(_ttoi64(diskSize) / 1000 / 1000 - 49);\n\t\t\t\t\t\t\t\t\tif (0 < vars[index].TotalDiskSize && vars[index].TotalDiskSize < 1000) // < 1GB\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//\tvars[index].TotalDiskSize == vars[index].DiskSizeChs;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (vars[index].TotalDiskSize < 10 * 1000) // < 10GB\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvars[index].TotalDiskSize = vars[index].DiskSizeWmi;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (vars[index].TotalDiskSize < vars[index].DiskSizeWmi)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//\tvars[index].TotalDiskSize = vars[index].DiskSizeWmi;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tBOOL flagSkipModelCheck = FALSE;\n\n\t\t\t\t\t\t\t\tvars[index].ModelWmi = model;\n\t\t\t\t\t\t\t\t// Model\n\t\t\t\t\t\t\t\tmodel.Replace(_T(\" SCSI Disk Device\"), _T(\"\"));\n\t\t\t\t\t\t\t\tmodel.Replace(_T(\" SATA Disk Device\"), _T(\"\"));\n\t\t\t\t\t\t\t\tmodel.Replace(_T(\" ATA Disk Device\"), _T(\"\"));\n\t\t\t\t\t\t\t\tmodel.Replace(_T(\" SCSI Device\"), _T(\"\"));\n\t\t\t\t\t\t\t\tmodel.Replace(_T(\" SATA Device\"), _T(\"\"));\n\t\t\t\t\t\t\t\tmodel.Replace(_T(\" ATA Device\"), _T(\"\"));\n\t\t\t\t\t\t\t\tmodel.Replace(_T(\"NVMe \"), _T(\"\"));\n\n\t\t\t\t\t\t\t\tif (flagUasp)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflagSkipModelCheck = TRUE;\n\t\t\t\t\t\t\t\t\tcstr.Format(_T(\"UASP (%s)\"), vars[index].Interface.GetString());\n\t\t\t\t\t\t\t\t\tvars[index].Interface = cstr;\n\t\t\t\t\t\t\t\t\tvars[index].InterfaceType = INTERFACE_TYPE_USB;\n\t\t\t\t\t\t\t\t\tvars[index].IsUasp = TRUE;\n\n\t\t\t\t\t\t\t\t\tdetectUASPdisks = TRUE;\n\t\t\t\t\t\t\t\t\tfor (int i = 0; i < externals.GetCount(); i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (externals.GetAt(i).Enclosure.Find(vars[index].ModelWmi) == 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tvars[index].Enclosure = externals.GetAt(i).Enclosure;\n\t\t\t\t\t\t\t\t\t\t\tvars[index].UsbVendorId = externals.GetAt(i).UsbVendorId;\n\t\t\t\t\t\t\t\t\t\t\tvars[index].UsbProductId = externals.GetAt(i).UsbProductId;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (model.Replace(_T(\" USB Device\"), _T(\"\")) > 0 || interfaceTypeWmi.Find(_T(\"USB\")) >= 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflagSkipModelCheck = TRUE;\n\t\t\t\t\t\t\t\t\tcstr.Format(_T(\"USB (%s)\"), vars[index].Interface.GetString());\n\t\t\t\t\t\t\t\t\tvars[index].Interface = cstr;\n\t\t\t\t\t\t\t\t\tvars[index].InterfaceType = INTERFACE_TYPE_USB;\n\n\t\t\t\t\t\t\t\t\tfor (int i = 0; i < externals.GetCount(); i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (externals.GetAt(i).Enclosure.Find(vars[index].ModelWmi) == 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tvars[index].Enclosure = externals.GetAt(i).Enclosure;\n\t\t\t\t\t\t\t\t\t\t\tvars[index].UsbVendorId = externals.GetAt(i).UsbVendorId;\n\t\t\t\t\t\t\t\t\t\t\tvars[index].UsbProductId = externals.GetAt(i).UsbProductId;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (model.Replace(_T(\" IEEE 1394 SBP2 Device\"), _T(\"\")) > 0 || interfaceTypeWmi.Find(_T(\"1394\")) >= 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tflagSkipModelCheck = TRUE;\n\t\t\t\t\t\t\t\t\tcstr.Format(_T(\"IEEE 1394 (%s)\"), vars[index].Interface.GetString());\n\t\t\t\t\t\t\t\t\tvars[index].Interface = cstr;\n\t\t\t\t\t\t\t\t\tvars[index].InterfaceType = INTERFACE_TYPE_IEEE1394;\n\t\t\t\t\t\t\t\t\tfor (int i = 0; i < externals.GetCount(); i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (externals.GetAt(i).Enclosure.Find(vars[index].ModelWmi) == 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tvars[index].Enclosure = externals.GetAt(i).Enclosure;\n\t\t\t\t\t\t\t\t\t\t\tvars[index].UsbVendorId = externals.GetAt(i).UsbVendorId;\n\t\t\t\t\t\t\t\t\t\t\tvars[index].UsbProductId = externals.GetAt(i).UsbProductId;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tCString cmp, cmp1, cmp2, cmp3;\n\t\t\t\t\t\t\t\tcmp = model;\n\t\t\t\t\t\t\t\tcmp.Replace(_T(\" \"), _T(\"\"));\n\t\t\t\t\t\t\t\tcmp1 = cmp.Left(8);\n\n\t\t\t\t\t\t\t\tcmp = vars[index].Model;\n\t\t\t\t\t\t\t\tcmp.Replace(_T(\" \"), _T(\"\"));\n\t\t\t\t\t\t\t\tcmp2 = cmp.Left(8);\n\n\t\t\t\t\t\t\t\tcmp = vars[index].ModelReverse;\n\t\t\t\t\t\t\t\tcmp.Replace(_T(\" \"), _T(\"\"));\n\t\t\t\t\t\t\t\tcmp3 = cmp.Left(8);\n\n\t\t\t\t\t\t\t\tif (vars[index].Model.IsEmpty())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDebugPrint(_T(\"WmiModel: \") + model);\n\t\t\t\t\t\t\t\t\tDebugPrint(_T(\"SerialNumber: \") + vars[index].SerialNumber);\n\t\t\t\t\t\t\t\t\tDebugPrint(_T(\"vars.RemoveAt(index) - 1\"));\n\t\t\t\t\t\t\t\t\tvars.RemoveAt(index);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (flagSkipModelCheck)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// None\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (model.IsEmpty() || cmp1.Compare(cmp2) == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// None\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (cmp1.Compare(cmp3) == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvars[index].SerialNumber = vars[index].SerialNumberReverse;\n\t\t\t\t\t\t\t\t\tvars[index].FirmwareRev = vars[index].FirmwareRevReverse;\n\t\t\t\t\t\t\t\t\tvars[index].Model = vars[index].ModelReverse;\n\t\t\t\t\t\t\t\t\tvars[index].ModelSerial = GetModelSerial(vars[index].Model, vars[index].SerialNumber);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (vars[index].InterfaceType == INTERFACE_TYPE_USB)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// None\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tDebugPrint(_T(\"WmiModel: \") + model);\n\t\t\t\t\t\t\t\t\tDebugPrint(_T(\"Model: \") + vars[index].Model);\n\t\t\t\t\t\t\t\t\tDebugPrint(_T(\"SerialNumber: \") + vars[index].SerialNumber);\n\t\t\t\t\t\t\t\t\tDebugPrint(_T(\"DISABLED: vars.RemoveAt(index) - 2\"));\n\t\t\t\t\t\t\t\t\t//\tvars.RemoveAt(index);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// DEBUG\n\t\t\t\t\t\t\t\t// vars[index].VendorId = VENDOR_MTRON;\n\t\t\t\t\t\t\t\tDebugPrint(_T(\"OK:Check Model Name\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(...)\n\t\t\t\t{\n\t\t\t\t\tDebugPrint(_T(\"EX:while(pEnumCOMDevs\"));\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSAFE_RELEASE(pEnumCOMDevs);\n\t\t\t\tDebugPrint(_T(\"OK2:SELECT * FROM Win32_DiskDrive\"));\n\t\t\t}\n\t\t\tcatch(...)\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"EX:SELECT * FROM Win32_DiskDrive\"));\n\t\t\t}\n\n\t\t\t// Drive Letter Mapping Start\n\t\t\t/*\n\t\t\ttry\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"DO:SELECT * FROM Win32_DiskPartition\"));\n\t\t\t\thRes = pIWbemServices->ExecQuery(_bstr_t(L\"WQL\"), \n\t\t\t\t\t_bstr_t(L\"SELECT * FROM Win32_DiskPartition\"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs);\n\t\t\t\tif(FAILED(hRes))\n\t\t\t\t{\n\t\t\t\t\tDebugPrint(_T(\"NG:SELECT * FROM Win32_DiskPartition\"));\n\t\t\t\t\tgoto safeRelease;\n\t\t\t\t}\n\t\t\t\tDebugPrint(_T(\"OK:SELECT * FROM Win32_DiskPartition\"));\n\n\t\t\t\twhile(pEnumCOMDevs && SUCCEEDED(pEnumCOMDevs->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1)\n\t\t\t\t{\n\t\t\t\t\tDWORD physicalDriveId = 0;\n\t\t\t\t\tCString partition, drive, mapping, cstr;\n\t\t\t\t\tVARIANT pVal;\n\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\tif(pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tpartition = pVal.bstrVal;\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t}\n\t\t\t\t\tcstr = partition;\n\t\t\t\t\tcstr.Replace(_T(\"Disk #\"), _T(\"\"));\n\t\t\t\t\tphysicalDriveId = _ttoi(cstr);\n\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\n\t\t\t\t\thRes = pIWbemServices->ExecQuery(_bstr_t(L\"WQL\"), \n\t\t\t\t\t\t_bstr_t(L\"SELECT * FROM Win32_LogicalDisk Where DriveType = 3\"), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs2);\n\t\t\t\t\tif(FAILED(hRes))\n\t\t\t\t\t{\n\t\t\t\t\t\tDebugPrint(_T(\"NG:SELECT * FROM Win32_LogicalDisk Where DriveType = 3\"));\n\t\t\t\t\t\tgoto safeRelease;\n\t\t\t\t\t}\n\n\t\t\t\t\twhile(pEnumCOMDevs2 && SUCCEEDED(pEnumCOMDevs2->Next(100000, 1, &pCOMDev, &uReturned)) && uReturned == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t\tif(pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdrive = pVal.bstrVal;\n\t\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\n\t\t\t\t\t\tIWbemContext *pCtx = 0;\n\t\t\t\t\t\tIWbemCallResult *pResult = 0;\n\t\t\t\t\t\tmapping.Format(_T(\"Win32_LogicalDiskToPartition.Antecedent=\\\"Win32_DiskPartition.DeviceID=\\\\\\\"%s\\\\\\\"\\\",Dependent=\\\"Win32_LogicalDisk.DeviceID=\\\\\\\"%s\\\\\\\"\\\"\"),\n\t\t\t\t\t\t\tpartition, drive);\n\t\t\t\t\t\t\n\t\t\t\t\t\tBSTR bstr;\n\t\t\t\t\t\tbstr = mapping.AllocSysString();\n\t\t\t\t\t\tpIWbemServices->GetObject(bstr, 0, pCtx, &pCOMDev, &pResult);\n\t\t\t\t\t\tSysFreeString(bstr);\n\t\t\t\t\t\tif(pCOMDev)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdriveLetterMap[physicalDriveId] |= 1 << (drive.GetAt(0) - 'A');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSAFE_RELEASE(pCOMDev);\n\t\t\t\t\t}\n\t\t\t\t\tSAFE_RELEASE(pEnumCOMDevs2);\n\t\t\t\t}\n\t\t\t\tSAFE_RELEASE(pEnumCOMDevs);\n\n\t\t\t\tDebugPrint(_T(\"OK:Drive Letter Mapping\"));\n\n\t\t\t}\n\t\t\tcatch(...)\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"EX:Drive Letter Mapping\"));\n\t\t\t}\n\t\t*/\nsafeRelease:\n\n\t\t\tSAFE_RELEASE(pCOMDev);\n\t\t\tSAFE_RELEASE(pEnumCOMDevs);\n\t\t\tSAFE_RELEASE(pEnumCOMDevs2);\n\t\t\tSAFE_RELEASE(pIWbemServices);\n\t\t//\tCoUninitialize();\n\t\t//  DebugPrint(_T(\"OK:CoUninitialize()\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\tDebugPrint(_T(\"CAtaSmart::Init WMI off - Start\"));\n\t}\n\t\n\t// \\\\\\\\.\\\\PhysicalDrive%d\n\tfor(int i = 0; i < MAX_SEARCH_PHYSICAL_DRIVE; i++)\n\t{\n\t\tBOOL\tflagChecked = FALSE;\n\t\tBOOL\tbRet = FALSE;\n\t\tHANDLE\thIoCtrl = NULL;\n\t\tDWORD\tdwReturned = 0;\n\t\tDISK_GEOMETRY dg = {};\n\t\tCAtaSmart::INTERFACE_TYPE interfaceType = CAtaSmart::INTERFACE_TYPE::INTERFACE_TYPE_UNKNOWN;\n\t\tCAtaSmart::COMMAND_TYPE commandType = CAtaSmart::COMMAND_TYPE::CMD_TYPE_UNKNOWN;\n\t\tCAtaSmart::VENDOR_ID vendor = CAtaSmart::VENDOR_ID::VENDOR_UNKNOWN;\n\n\t\tfor(int j = 0; j < vars.GetCount(); j++)\n\t\t{\n\t\t\tif(i == vars[j].PhysicalDriveId)\n\t\t\t{\n\t\t\t\tflagChecked = TRUE;\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = 0; j < m_BlackPhysicalDrive.GetCount(); j++)\n\t\t{\n\t\t\tif(i == m_BlackPhysicalDrive.GetAt(j))\n\t\t\t{\n\t\t\t\tflagChecked = TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif(flagChecked)\n\t\t{\n///\t\t\tDebugPrint(_T(\"flagChecked - continue\"));\n\t\t\tcontinue;\n\t\t}\n\n///\t\tDebugPrint(_T(\"GetIoCtrlHandle\"));\n\t\thIoCtrl = GetIoCtrlHandle(i);\n\t\tif(! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t\t{\n///\t\t\tDebugPrint(_T(\"INVALID_HANDLE_VALUE - continue\"));\n\t\t\tcontinue;\n\t\t}\n///\t\tDebugPrint(_T(\"DeviceIoControl\"));\n\t\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_DISK_GET_DRIVE_GEOMETRY, \n\t\t\tNULL, 0, &dg, sizeof(DISK_GEOMETRY),\n\t\t\t&dwReturned, NULL);\n\t\tif(bRet == FALSE || dwReturned != sizeof(DISK_GEOMETRY) || dg.MediaType != FixedMedia)\n\t\t{\n///\t\t\tDebugPrint(_T(\"CloseHandle - continue\"));\n\t\t\tsafeCloseHandle(hIoCtrl);\n\t\t\tcontinue;\n\t\t}\n\t\t// [2010/12/05] Workaround for SAMSUNG HD204UI\n\t\t// http://sourceforge.net/apps/trac/smartmontools/wiki/SamsungF4EGBadBlocks\n\n\t\tDWORD\tdwRet = 0;\n\t\tDWORD\tdwLen = 4096;\n\t\tBYTE*\tpcbData = new BYTE[dwLen];\n\t\tSTORAGE_DEVICE_DESCRIPTOR*\tpDescriptor = NULL;\n\t\tSTORAGE_PROPERTY_QUERY\t\tsQuery = {};\n\t\tCString model, firmware;\n\n\t\tif(pcbData == NULL)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tZeroMemory(pcbData, dwLen);\n\t\tsQuery.PropertyId\t= StorageDeviceProperty;\n\t\tsQuery.QueryType\t= PropertyStandardQuery;\n\t\tsQuery.AdditionalParameters[0] = NULL;\n\t\t\n\t\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_STORAGE_QUERY_PROPERTY, &sQuery, sizeof(STORAGE_PROPERTY_QUERY), pcbData,dwLen,&dwRet,NULL);\n\t\tif(bRet == FALSE)\n\t\t{\n\t\t\tdelete [] pcbData;\n\t\t\tsafeCloseHandle(hIoCtrl);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpDescriptor = (STORAGE_DEVICE_DESCRIPTOR*)pcbData;\n\t\tif(pDescriptor->ProductIdOffset)\n\t\t{\n\t\t\tmodel\t= (char*)pDescriptor + pDescriptor->ProductIdOffset;\n\t\t}\n\t\tif(pDescriptor->ProductRevisionOffset)\n\t\t{\n\t\t\tfirmware\t= (char*)pDescriptor + pDescriptor->ProductRevisionOffset;\n\t\t}\n\t\t// [2019/10/28] Workaround for NVMe SSD on MS Storage Space\n#ifdef _WIN64\n\t\tif(pDescriptor->BusType == BusTypeNvme)\n#else\n\t\tif (pDescriptor->BusType == 17/*BusTypeNvme*/)\n#endif\n\t\t{\n\t\t\tinterfaceType = INTERFACE_TYPE_NVME;\n\t\t}\n\n\t\tdelete [] pcbData;\n\n\t\t// [2010/12/05] Workaround for SAMSUNG HD204UI\n\t\t// http://sourceforge.net/apps/trac/smartmontools/wiki/SamsungF4EGBadBlocks\n\t\tif((model.Find(_T(\"SAMSUNG HD155UI\")) == 0 || model.Find(_T(\"SAMSUNG HD204UI\")) == 0) && firmware.Find(_T(\"1AQ10003\")) != 0 && IsWorkaroundHD204UI)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// [2018/10/24] Workaround for FuzeDrive (AMDStoreMi)\n\t\tif (model.Find(_T(\"FuzeDrive\")) != -1 || model.Find(_T(\"StoreMI\")) != -1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// USB-HDD Check\n\t\t// if(! IsEnabledWmi)\n\t\t{\n\t\t\tDebugPrint(_T(\"USB-HDD Check\"));\n\n\t\t\tDWORD dwRet = 0;\n\t\t\tBYTE cbData[4096] = {};\n\n\t\t\tSTORAGE_DEVICE_DESCRIPTOR*\tpDescriptor = NULL;\n\t\t\tSTORAGE_PROPERTY_QUERY\t\tsQuery = {};\n\n\t\t\tsQuery.PropertyId\t= StorageDeviceProperty;\n\t\t\tsQuery.QueryType\t= PropertyStandardQuery;\n\t\t\tsQuery.AdditionalParameters[0] = NULL;\n\n///\t\t\tDebugPrint(_T(\"DeviceIoControl\"));\n\t\t\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_STORAGE_QUERY_PROPERTY, &sQuery,\n\t\t\t\tsizeof(STORAGE_PROPERTY_QUERY), &cbData, 4096, &dwRet, NULL);\n\n\t\t\tif(bRet != FALSE)\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"Check Bus Type\"));\n\t\t\t\tpDescriptor = (STORAGE_DEVICE_DESCRIPTOR*)&cbData;\n\t\t\t\tif(pDescriptor->BusType == BusTypeUsb)\n\t\t\t\t{\n\t\t\t\t\tDebugPrint(_T(\"Bus Type = USB\"));\n\t\t\t\t\tinterfaceType = INTERFACE_TYPE_USB;\n\t\t\t\t\tvendor = USB_VENDOR_ALL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n///\t\tDebugPrint(_T(\"CloseHandle\"));\n\t\tsafeCloseHandle(hIoCtrl);\n\n\t\tDebugPrint(_T(\"DO:GetDiskInfo\"));\n\t\tif(GetDiskInfo(i, -1, -1, interfaceType, commandType, vendor))\n\t\t{\n\t\t\tDebugPrint(_T(\"OK:GetDiskInfo\"));\n\t\t\tint index = (int)vars.GetCount() - 1;\n\t\t\t\n\t\t\tCString cmp, cstr;\n\n///\t\t\tcstr.Format(_T(\"index: %d\"), index);\n\t\t\tcmp = vars[index].Model;\n\t\t\tDebugPrint(_T(\"Check Reverse\"));\n\t\t\tif(cmp.Find(_T(\"DW C\")) == 0 // WDC \n\t\t\t|| cmp.Find(_T(\"iHat\")) == 0 // Hitachi\n\t\t\t|| cmp.Find(_T(\"ASSM\")) == 0 // SAMSUNG\n\t\t\t|| cmp.Find(_T(\"aMtx\")) == 0 // Maxtor\n\t\t\t|| cmp.Find(_T(\"OTHS\")) == 0 // TOSHIBA\n\t\t\t|| cmp.Find(_T(\"UFIJ\")) == 0 // FUJITSU\n\t\t\t)\t\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"Reverse\"));\n\t\t\t\tvars[index].SerialNumber = vars[index].SerialNumberReverse;\n\t\t\t\tvars[index].FirmwareRev = vars[index].FirmwareRevReverse;\n\t\t\t\tvars[index].Model = vars[index].ModelReverse;\n\t\t\t\tvars[index].ModelSerial = GetModelSerial(vars[index].Model, vars[index].SerialNumber);\n\t\t\t}\n\n\t\t\tif(interfaceType == INTERFACE_TYPE_USB)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"USB (%s)\"), vars[index].Interface.GetString());\n\t\t\t\tvars[index].Interface = cstr;\n\t\t\t}\n\t\t}\n\t}\n\n\tDebugPrint(_T(\"OK:GetDiskInfo - PhysicalDrive\"));\n\t// Sort\n\t// ATA_SMART_INFO* p = vars.GetData();\n\t// qsort(p, vars.GetCount(), sizeof(ATA_SMART_INFO), Compare);\n\t// DebugPrint(_T(\"OK:qsort\"));\n\n\n\t///////////////////////////////\n\t// JMicron USB RAID\n\t///////////////////////////////\n\t#ifdef JMICRON_USB_RAID_SUPPORT\n\t\tif (FlagUsbJMS586_40)\n\t\t{\n\t\t\tDebugPrint(L\"JMS586_40\");\n\n\t\t\tif (InitializeJMS586_40(&hJMS586_40))\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tcount = pGetControllerCountJMS586_40();\n\n\t\t\t\tCString cstr;\n\t\t\t\tcstr.Format(L\"ControllerCount: %d\", count);\n\t\t\t\tDebugPrint(cstr);\n\n\t\t\t\tfor (int i = 0; i < count; i++)\n\t\t\t\t{\n\t\t\t\t\tAddDiskJMS586_40(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (FlagUsbJMS586_20)\n\t\t{\n\t\t\tDebugPrint(L\"JMS586_20\");\n\n\t\t\tif (InitializeJMS586_20(&hJMS586_20))\n\t\t\t{\n\t\t\t\tint count = 0;\n\t\t\t\tcount = pGetControllerCountJMS586_20();\n\n\t\t\t\tCString cstr;\n\t\t\t\tcstr.Format(L\"ControllerCount: %d\", count);\n\t\t\t\tDebugPrint(cstr);\n\n\t\t\t\tfor (int i = 0; i < count; i++)\n\t\t\t\t{\n\t\t\t\t\tAddDiskJMS586_20(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t#endif\n\n\t// Advanced Disk Search\n\tif(IsAdvancedDiskSearch)\n\t{\n\t\t// \\\\\\\\.\\\\Scsi%d:\n\t\tfor(int i = 0; i < MAX_SEARCH_SCSI_PORT; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < MAX_SEARCH_SCSI_TARGET_ID; j++)\n\t\t\t{\n\t\t\t\tif(GetDiskInfo(-1, i, j, INTERFACE_TYPE_UNKNOWN, CMD_TYPE_UNKNOWN, VENDOR_UNKNOWN))\n\t\t\t\t{\n\t\t\t\t\tint index = (int)vars.GetCount() - 1;\n\n\t\t\t\t\tCString cmp;\n\t\t\t\t\tcmp = vars[index].Model;\n\t\t\t\t\tif(cmp.Find(_T(\"DW C\")) == 0 // WDC \n\t\t\t\t\t|| cmp.Find(_T(\"iHat\")) == 0 // Hitachi\n\t\t\t\t\t|| cmp.Find(_T(\"ASSM\")) == 0 // SAMSUNG\n\t\t\t\t\t|| cmp.Find(_T(\"aMtx\")) == 0 // Maxtor\n\t\t\t\t\t|| cmp.Find(_T(\"OTHS\")) == 0 // TOSHIBA\n\t\t\t\t\t|| cmp.Find(_T(\"UFIJ\")) == 0 // FUJITSU\n\t\t\t\t\t)\t\n\t\t\t\t\t{\n\t\t\t\t\t\tvars[index].SerialNumber = vars[index].SerialNumberReverse;\n\t\t\t\t\t\tvars[index].FirmwareRev = vars[index].FirmwareRevReverse;\n\t\t\t\t\t\tvars[index].Model = vars[index].ModelReverse;\n\t\t\t\t\t\tvars[index].ModelSerial = GetModelSerial(vars[index].Model, vars[index].SerialNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDebugPrint(_T(\"OK:GetDiskInfo - Scsi\"));\n\t}\n\n\tDebugPrint(_T(\"Drive Letter Mapping - Start\"));\n\n\t// Drive Letter Mapping http://www.cplusplus.com/forum/windows/12196/\n\tfor(TCHAR c = 'A'; c <= 'Z'; c++)\n\t{\n\t\tCString cstr;\n\t\tTCHAR szPath[MAX_PATH] = {};\n\t\twsprintf(szPath, _T(\"%c:\\\\\"), c);\n\t\tcstr = szPath;\n\t\tDebugPrint(cstr);\n\n\t\tif(GetDriveType(cstr) == DRIVE_FIXED)\n\t\t{\n\t\t\t// None\n\t\t}\n\t\telse if(detectUSBMemory && GetDriveType(cstr) == DRIVE_REMOVABLE && c >= 'C')\n\t\t{\n\t\t\t// None\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebugPrint(_T(\"Drive Letter Mapping - != DRIVE_FIXED\"));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\twsprintf(szPath, _T(\"\\\\\\\\.\\\\%c:\"), c);\n\t\tcstr = szPath;\n\t\tDebugPrint(cstr);\n\n\t\tHANDLE hHandle = CreateFile(szPath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ,\n\t\t\tNULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\t\tif(hHandle == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\tDebugPrint(_T(\"Drive Letter Mapping - INVALID_HANDLE_VALUE\"));\n\t\t\tcontinue;\n\t\t}\n\t\tVOLUME_DISK_EXTENTS_LX volumeDiskExtents = {};\n\t\tDWORD dwBytesReturned = 0;\n\t\tBOOL bResult = DeviceIoControl(hHandle, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS, NULL, 0,\n\t\t\t&volumeDiskExtents, sizeof(volumeDiskExtents), &dwBytesReturned, NULL);\n\t\tsafeCloseHandle(hHandle);\n\t\tif(!bResult)\n\t\t{\n\t\t\tDebugPrint(_T(\"Drive Letter Mapping - bResult == FALSE\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\tcstr.Format(_T(\"volumeDiskExtents.NumberOfDiskExtents = %d\"), volumeDiskExtents.NumberOfDiskExtents);\n\t\tDebugPrint(cstr);\n\n\t\tfor (DWORD n = 0; n < volumeDiskExtents.NumberOfDiskExtents && volumeDiskExtents.NumberOfDiskExtents < 4; ++n)\n\t\t{\n\t\t\tPDISK_EXTENT pDiskExtent = &volumeDiskExtents.Extents[n];\n\n\t\t\t// Workaround for RamPhantom EX 1.1\n\t\t\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1178;id=diskinfo#1178\n\t\t\tif(pDiskExtent->ExtentLength.QuadPart == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(0 <= pDiskExtent->DiskNumber && pDiskExtent->DiskNumber < 256)\n\t\t\t{\n\t\t\t\tdriveLetterMap[pDiskExtent->DiskNumber] |= 1 << (c - 'A');\n\t\t\t}\n\t\t\tcstr.Format(_T(\"n = %d, pDiskExtent->DiskNumber = %d\"), n, pDiskExtent->DiskNumber);\n\t\t\tDebugPrint(cstr);\n\t\t}\n\t}\n\tDebugPrint(_T(\"Drive Letter Mapping - End\"));\n\n\tfor(int i = 0; i < vars.GetCount(); i++)\n\t{\n\t\tif(vars[i].PhysicalDriveId < 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tCString driveLetter = _T(\"\");\n\t\tfor(int j = 0; j < 26; j++)\n\t\t{\n\t\t\tif(driveLetterMap[vars[i].PhysicalDriveId] & (1 << j))\n\t\t\t{\n\t\t\t\tCString cstr;\n\t\t\t\tcstr.Format(_T(\"%C\"), j + 'A'); \n\t\t\t\tdriveLetter += cstr + _T(\": \");\n\t\t\t\tvars[i].DriveLetterMap += (1 << j);\n\t\t\t\tDebugPrint(cstr);\n\t\t\t}\n\t\t}\n\t\tvars[i].DriveMap.Append(driveLetter);\n\t\tvars[i].DriveMap.TrimRight();\n\t}\n\n\tMeasuredGetTickCount = GetTickCountFx();\n\tDebugPrint(_T(\"CAtaSmart::Init - Complete\"));\n\n\tif(flagChangeDisk != NULL)\n\t{\n\t\tif(vars.GetCount() != previous.GetCount())\n\t\t{\n\t\t\t*flagChangeDisk = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i = 0; i < vars.GetCount(); i++)\n\t\t\t{\n\t\t\t\tif(vars.GetAt(i).PhysicalDriveId != previous.GetAt(i).PhysicalDriveId\n\t\t\t\t|| vars.GetAt(i).ScsiTargetId != previous.GetAt(i).ScsiTargetId\n\t\t\t\t|| vars.GetAt(i).ScsiPort != previous.GetAt(i).ScsiPort\n\t\t\t\t|| memcmp(&(vars.GetAt(i).sasPhyEntity), &(previous.GetAt(i).sasPhyEntity), sizeof(CSMI_SAS_PHY_ENTITY)) != 0\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\t*flagChangeDisk = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// HideNoSmartDisk\n\tif(flagHideNoSmartDisk)\n\t{\n\t\tint count = (int)vars.GetCount();\n\t\tif(count > 0)\n\t\t{\n\t\t\tfor(int i = count - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif(vars[i].AttributeCount == 0)\n\t\t\t\t{\n\t\t\t\t\tvars.RemoveAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// [2023/02/25] Hide RAID Volume\n\tint count = (int)vars.GetCount();\n\tif (count > 0)\n\t{\n\t\tfor (int i = count - 1; i >= 0; i--)\n\t\t{\n\t\t\tCString model;\n\t\t\tmodel = vars[i].Model;\n\t\t\tmodel.MakeUpper();\n\t\t\tif (model.Find(L\"RAID\") >= 0)\n\t\t\t{\n\t\t\t\tvars.RemoveAt(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tATA_SMART_INFO* p = vars.GetData();\n\n\tif (flagSortDriveLetter)\n\t{\n\t\tDebugPrint(_T(\"Sort by DriveLetter\"));\n\t\tqsort(p, vars.GetCount(), sizeof(ATA_SMART_INFO), CompareDriveLetter);\n\t}\n\telse\n\t{\n\t\tDebugPrint(_T(\"Sort by PhysicalDriveId\"));\n\t\tqsort(p, vars.GetCount(), sizeof(ATA_SMART_INFO), ComparePhysicalDriveId);\n\t}\n}\n\nint CAtaSmart::CompareDriveLetter(const void *p1, const void *p2)\n{\n\tint dlm1 = -1; \n\tint dlm2 = -1;\n\n\tfor (int i = 0; i < 26; i++)\n\t{\n\t\tif(((ATA_SMART_INFO*)p1)->DriveLetterMap & 1 << i)\n\t\t{\n\t\t\tdlm1 = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 26; i++)\n\t{\n\t\tif (((ATA_SMART_INFO*)p2)->DriveLetterMap & 1 << i)\n\t\t{\n\t\t\tdlm2 = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint pdi1 = ((ATA_SMART_INFO*)p1)->PhysicalDriveId;\n\tint pdi2 = ((ATA_SMART_INFO*)p2)->PhysicalDriveId;\n\n\tint pepi1 = ((ATA_SMART_INFO*)p1)->sasPhyEntity.bPortIdentifier;\n\tint pepi2 = ((ATA_SMART_INFO*)p2)->sasPhyEntity.bPortIdentifier;\n\n\tif (pdi1 == -1) { pdi1 = 255; }\n\tif (pdi2 == -1) { pdi2 = 255; }\n\n\tif (dlm1 == -1) { dlm1 = 26 + 1; } /* Z + 1 */\n\tif (dlm2 == -1) { dlm2 = 26 + 1; } \n\n\tdlm1++;\n\tdlm2++;\n\n\tint sort1 = (dlm1 << 8) + pdi1;\n\tint sort2 = (dlm2 << 8) + pdi2;\n\n\tif(sort1 == sort2)\n\t{\n\t\treturn pepi1 - pepi2;\n\t}\n\telse\n\t{\n\t\treturn sort1 - sort2;\n\t}\n}\n\nint CAtaSmart::ComparePhysicalDriveId(const void* p1, const void* p2)\n{\n\tint pdi1 = ((ATA_SMART_INFO*)p1)->PhysicalDriveId;\n\tint pdi2 = ((ATA_SMART_INFO*)p2)->PhysicalDriveId;\n\n\tint pepi1 = ((ATA_SMART_INFO*)p1)->sasPhyEntity.bPortIdentifier;\n\tint pepi2 = ((ATA_SMART_INFO*)p2)->sasPhyEntity.bPortIdentifier;\n\n\tif (pdi1 == -1) { pdi1 = 255; }\n\tif (pdi2 == -1) { pdi2 = 255; }\n\n\tint sort1 = (pdi1 << 8) + pdi1;\n\tint sort2 = (pdi2 << 8) + pdi2;\n\n\tif (sort1 == sort2)\n\t{\n\t\treturn pepi1 - pepi2;\n\t}\n\telse\n\t{\n\t\treturn sort1 - sort2;\n\t}\n}\n\n/*\nint CAtaSmart::ComparePhysicalDriveId(const void *p1, const void *p2)\n{\n\tif(((ATA_SMART_INFO*)p1)->PhysicalDriveId == -1 && ((ATA_SMART_INFO*)p2)->PhysicalDriveId == -1)\n\t{\n\t\treturn ((ATA_SMART_INFO*)p1)->sasPhyEntity.bPortIdentifier - ((ATA_SMART_INFO*)p2)->sasPhyEntity.bPortIdentifier;\n\t}\n\telse\n\t{\n\t\treturn ((ATA_SMART_INFO*)p1)->PhysicalDriveId - ((ATA_SMART_INFO*)p2)->PhysicalDriveId;\n\t}\n}\n*/\n\nBOOL CAtaSmart::AddDisk(INT physicalDriveId, INT scsiPort, INT scsiTargetId, INT scsiBus, BYTE target, COMMAND_TYPE commandType, IDENTIFY_DEVICE* identify, INT siliconImageType, PCSMI_SAS_PHY_ENTITY sasPhyEntity, CString pnpDeviceId,\n\tDWORD TotalDiskSize// +AMD_RC2\n\t)\n{\n\tif(vars.GetCount() >= MAX_DISK)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tATA_SMART_INFO asi = {};\n\tATA_SMART_INFO asiCheck = {};\n\n\tmemcpy(&(asi.IdentifyDevice), identify, sizeof(ATA_IDENTIFY_DEVICE));\n\tasi.PhysicalDriveId = physicalDriveId;\n\tasi.ScsiBus = scsiBus;\n\tasi.ScsiPort =  scsiPort;\n\tasi.ScsiTargetId = scsiTargetId;\n\tasi.SiliconImageType = siliconImageType;\n\tasi.CommandType = commandType;\n\tasiCheck.CommandType = commandType;\n\tasi.SsdVendorString = _T(\"\");\n\n\tif(sasPhyEntity != NULL)\n\t{\n\t\tmemcpy(&(asi.sasPhyEntity), sasPhyEntity, sizeof(CSMI_SAS_PHY_ENTITY));\n\t}\n\n\tif(commandType == CMD_TYPE_PHYSICAL_DRIVE || CMD_TYPE_SAT <= commandType && commandType <= CMD_TYPE_SAT_REALTEK9220DP)\n\t{\n\t\tif(target == 0xB0)\n\t\t{\n\t\t\tasi.CommandTypeString.Format(_T(\"%s2\"), commandTypeString[commandType]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tasi.CommandTypeString.Format(_T(\"%s1\"), commandTypeString[commandType]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (commandType >= COMMAND_TYPE::CMD_TYPE_UNKNOWN && commandType <= COMMAND_TYPE::CMD_TYPE_DEBUG)\n\t\t{\n\t\t\tasi.CommandTypeString = commandTypeString[(UINT)commandType];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tasi.CommandTypeString = L\"\";//unknown\n\t\t}\n\t}\n\n\tfor(int i = 0; i < MAX_ATTRIBUTE; i++)\n\t{\n\t\t::ZeroMemory(&(asi.Attribute[i]), sizeof(SMART_ATTRIBUTE));\n\t\t::ZeroMemory(&(asi.Threshold[i]), sizeof(SMART_THRESHOLD));\n\t}\n\n\tfor(int i = 0; i < 512; i++)\n\t{\n\t\tasi.SmartReadData[i] = 0x00;\n\t\tasi.SmartReadThreshold[i] = 0x00;\n\t}\n\n\tasi.IsSmartEnabled = FALSE;\n\tasi.IsIdInfoIncorrect = FALSE;\n\tasi.IsSmartCorrect = FALSE;\n\tasi.IsThresholdCorrect = FALSE;\n\tasi.IsWord88 = FALSE;\n\tasi.IsWord64_76 = FALSE;\n\tasi.IsCheckSumError = FALSE;\n\tasi.IsRawValues8 = FALSE;\n\tasi.IsRawValues7 = FALSE;\n\tasi.Is9126MB = FALSE;\n\tasi.IsThresholdBug = FALSE;\n\n\tasi.IsSmartSupported = FALSE;\n\tasi.IsLba48Supported = FALSE;\n\tasi.IsNcqSupported = FALSE;\n\tasi.IsAamSupported = FALSE;\n\tasi.IsApmSupported = FALSE;\n\tasi.IsAamEnabled = FALSE;\n\tasi.IsApmEnabled = FALSE;\n\tasi.IsNvCacheSupported = FALSE;\n\tasi.IsDeviceSleepSupported = FALSE;\n\tasi.IsStreamingSupported = FALSE;\n\tasi.IsGplSupported = FALSE;\n\n\tasi.IsMaxtorMinute = FALSE;\n\tasi.IsSsd = FALSE;\n\tasi.IsTrimSupported = FALSE;\n\tasi.IsVolatileWriteCachePresent = FALSE;\n\n\tasi.IsNVMe = FALSE;\n\tasi.IsUasp = FALSE;\n\t\n\tasi.TotalDiskSize = 0;\n\tasi.Cylinder = 0;\n\tasi.Head = 0;\n\tasi.Sector = 0;\n\tasi.Sector28 = 0;\n\tasi.Sector48 = 0;\n\tasi.NumberOfSectors = 0;\n\tasi.DiskSizeChs = 0;\n\tasi.DiskSizeLba28 = 0;\n\tasi.DiskSizeLba48 = 0;\n\tasi.LogicalSectorSize = 512;\n\tasi.PhysicalSectorSize = 512;\n\tasi.DiskSizeWmi = 0;\n\tasi.BufferSize = 0;\n\tasi.NvCacheSize = 0;\n\tasi.TransferModeType = 0;\n\tasi.DetectedTimeUnitType = 0;\n\tasi.MeasuredTimeUnitType = 0;\n\tasi.AttributeCount = 0;\n\tasi.DetectedPowerOnHours = -1;\n\tasi.MeasuredPowerOnHours = -1;\n\tasi.PowerOnRawValue = -1;\n\tasi.PowerOnStartRawValue = -1;\n\tasi.PowerOnCount = 0;\n\tasi.Temperature = -1000;\n\tasi.TemperatureMultiplier = 1.0;\n\tasi.NominalMediaRotationRate = 0;\n//\tasi.Speed = 0.0;\n\tasi.Life = -1;\n\tasi.FlagLifeNoReport = FALSE;\n\tasi.FlagLifeRawValue = FALSE;\n\tasi.FlagLifeRawValueIncrement = FALSE;\n\tasi.FlagLifeSanDiskUsbMemory = FALSE;\n\tasi.FlagLifeSanDisk0_1 = FALSE;\n\tasi.FlagLifeSanDisk1 = FALSE;\n\tasi.FlagLifeSanDiskCloud = FALSE;\n\tasi.FlagLifeSanDiskLenovo = FALSE;\n\tasi.HostWrites = -1;\n\tasi.HostReads = -1;\n\tasi.GBytesErased = -1;\n\tasi.NandWrites = -1;\n\tasi.WearLevelingCount = -1;\n//\tasi.PlextorNandWritesUnit = 0;\n\n\tasi.Major = 0;\n\tasi.Minor = 0;\n\n\tasi.DiskStatus = 0;\n\tasi.DriveLetterMap = 0;\n\n\tasi.AlarmTemperature = 0;\n\n\tasi.InterfaceType = INTERFACE_TYPE_UNKNOWN;\n\tasi.HostReadsWritesUnit = HOST_READS_WRITES_UNKNOWN;\n\n\tasi.DiskVendorId = VENDOR_UNKNOWN;\n\tasi.UsbVendorId = VENDOR_UNKNOWN;\n\tasi.UsbProductId = 0;\n\tasi.Target = target;\n\t\n\tasi.SerialNumber = _T(\"\");\n\tasi.FirmwareRev = _T(\"\");\n\tasi.Model = _T(\"\");\n\tasi.ModelReverse = _T(\"\");\n\tasi.ModelWmi = _T(\"\");\n\tasi.ModelSerial = _T(\"\");\n\tasi.DriveMap = _T(\"\");\n\tasi.MaxTransferMode = _T(\"\");\n\tasi.CurrentTransferMode = _T(\"\");\n\tasi.MajorVersion = _T(\"\");\n\tasi.MinorVersion = _T(\"\");\n\tasi.Interface = _T(\"\");\n\tasi.Enclosure = _T(\"\");\n\tasi.DeviceNominalFormFactor = _T(\"\");\n\tasi.PnpDeviceId = pnpDeviceId;\n\tasi.MinorVersion = _T(\"\");\n\n\tCHAR buf[64] = {};\n\n\t// Check Sum Error\n\tBYTE sum = 0;\n\tBYTE checkSum[IDENTIFY_BUFFER_SIZE] = {};\n\tmemcpy(checkSum, (void *)identify, IDENTIFY_BUFFER_SIZE);\n\tfor(int j = 0; j < IDENTIFY_BUFFER_SIZE; j++)\n\t{\n\t\tsum += checkSum[j];\n\t}\n\tif(sum != 0)\n\t{\n\t\tasi.IsCheckSumError = TRUE;\n\t}\n\t\n\tif(CheckAsciiStringError(identify->A.SerialNumber, sizeof(identify->A.SerialNumber))\n\t|| CheckAsciiStringError(identify->A.FirmwareRev, sizeof(identify->A.FirmwareRev))\n\t|| CheckAsciiStringError(identify->A.Model, sizeof(identify->A.Model)))\n\t{\n\t\tasi.IsIdInfoIncorrect = TRUE;\n\t//\tDebugPrint(_T(\"CheckAsciiStringError\"));\n\t\treturn FALSE;\n\t}\n\n\t// Reverse\n\tstrncpy_s(buf, 64, identify->A.SerialNumber, sizeof(identify->A.SerialNumber));\n\tasi.SerialNumberReverse = buf;\n\tasi.SerialNumberReverse.TrimLeft();\n\tasi.SerialNumberReverse.TrimRight();\n\tstrncpy_s(buf, 64, identify->A.FirmwareRev, sizeof(identify->A.FirmwareRev));\n\tasi.FirmwareRevReverse = buf;\n\tasi.FirmwareRevReverse.TrimLeft();\n\tasi.FirmwareRevReverse.TrimRight();\n\tstrncpy_s(buf, 64, identify->A.Model, sizeof(identify->A.Model));\n\tasi.ModelReverse = buf;\n\tasi.ModelReverse.TrimLeft();\n\tasi.ModelReverse.TrimRight();\n\n\tChangeByteOrder(identify->A.SerialNumber, sizeof(identify->A.SerialNumber));\n\tChangeByteOrder(identify->A.FirmwareRev, sizeof(identify->A.FirmwareRev));\n\tChangeByteOrder(identify->A.Model, sizeof(identify->A.Model));\n\n\t// Normal\n\tstrncpy_s(buf, 64, identify->A.SerialNumber, sizeof(identify->A.SerialNumber));\n\tasi.SerialNumber = buf;\n\tasi.SerialNumber.TrimLeft();\n\tasi.SerialNumber.TrimRight();\n\tstrncpy_s(buf, 64, identify->A.FirmwareRev, sizeof(identify->A.FirmwareRev));\n\tasi.FirmwareRev = buf;\n\tasi.FirmwareRev.TrimLeft();\n\tasi.FirmwareRev.TrimRight();\n\tstrncpy_s(buf, 64, identify->A.Model, sizeof(identify->A.Model));\n\tasi.Model = buf;\n\tasi.Model.TrimLeft();\n\tasi.Model.TrimRight();\n\n\tif(asi.Model.IsEmpty() || asi.FirmwareRev.IsEmpty())\n\t{\n\t\tDebugPrint(_T(\"asi.Model.IsEmpty() || asi.FirmwareRev.IsEmpty()\"));\n\t\tasi.IsIdInfoIncorrect = TRUE;\n\t\treturn FALSE;\n\t}\n\n\tINT\tduplicatedId = -1;\n\t// Check duplicate device\n\tfor(int i = 0; i < vars.GetCount(); i++)\n\t{\n\t\tif(asi.Model.Compare(vars[i].Model) == 0 && asi.SerialNumber.Compare(vars[i].SerialNumber) == 0)\n\t\t{\n\t\t\t// for CSMI devices\n\t\t\tif(vars[i].PhysicalDriveId == -1)\n\t\t\t{\n\t\t\t\tvars[i].PhysicalDriveId = asi.PhysicalDriveId;\n\t\t\t\tif(CsmiType == CSMI_TYPE_ENABLE_AUTO)\n\t\t\t\t{\n\t\t\t\t\tduplicatedId = i;\n\t\t\t\t\tDebugPrint(_T(\"vars[i].CommandType = CMD_TYPE_CSMI_PHYSICAL_DRIVE\"));\n\t\t\t\t\tvars[i].CommandType = CMD_TYPE_CSMI_PHYSICAL_DRIVE;\n\t\t\t\t\tvars[i].CommandTypeString = commandTypeString[vars[i].CommandType];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (vars[i].ModelWmi.IsEmpty())\n\t\t\t{\n\t\t\t\tduplicatedId = i;\n\t\t\t}\n\t\t\telse if (asi.ModelWmi.IsEmpty())\n\t\t\t{\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (asi.ModelReverse.Compare(vars[i].Model) == 0 && asi.SerialNumberReverse.Compare(vars[i].SerialNumber) == 0)\n\t\t{\n\t\t\tCString cstr;\n\t\t\tcstr.Format(L\"Duplicate Check: %s:%s\", asi.Model.GetString(), asi.SerialNumber.GetString());\n\t\t\tDebugPrint(cstr);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tCString firmwareRevInt = asi.FirmwareRev;\n\tfirmwareRevInt.Replace(_T(\".\"), _T(\"\"));\n\tif(asi.Model.Find(_T(\"ADATA SSD\")) == 0 && _wtoi(firmwareRevInt) == 346)\n\t{\n\t\tasi.TemperatureMultiplier = 0.5;\n\t}\n\n\tasi.ModelSerial = GetModelSerial(asi.Model, asi.SerialNumber);\n\n\t// +AMD_RC2 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\tif (commandType == COMMAND_TYPE::CMD_TYPE_AMD_RC2) {\n\t\tasi.Major = 3;\n\t\tasi.IsSsd = (identify->A.SerialAtaCapabilities & 1);\n\t\tasi.IsSmartSupported = TRUE;\n\t\tasi.Interface = (identify->A.CurrentMediaSerialNo[0] == 'N' ? _T(\"AMD_RC2\") : _T(\"AMD_RC2 (Serial ATA)\"));\n\t\tasi.CurrentTransferMode = identify->A.CurrentMediaSerialNo;//tmp\n\t\tasi.CurrentTransferMode.Replace(L\"HDD\", L\"\");\n\t\tasi.CurrentTransferMode.Replace(L\"SSD\", L\"\");\n\t\tasi.CurrentTransferMode.Replace(L\"SATA\", L\"\");\n\t\tasi.CurrentTransferMode.Replace(L\"6Gb\", L\"SATA/600\");\n\t\tasi.CurrentTransferMode.Replace(L\"3Gb\", L\"SATA/300\");\n\t\tasi.CurrentTransferMode.Replace(L\"1.5Gb\", L\"SATA/150\");\n\t\tasi.CurrentTransferMode.Replace(L\"1Gb\", L\"SATA/150\");\n\t\tasi.CurrentTransferMode.Replace(L\" \", L\"\");\n\t\tasi.MaxTransferMode = L\"----\";\n\n\t\t// asi.MajorVersion = identify->A.CurrentMediaSerialNo;//tmp\n\t\tidentify->A.CurrentMediaSerialNo[0] = '\\0';\n\t\tidentify->A.SerialAtaCapabilities = 0;\n\t}\n#ifdef JMICRON_USB_RAID_SUPPORT\n\telse if (commandType == COMMAND_TYPE::CMD_TYPE_JMS56X)\n\t{\n\t\tasi.Major = 0;\n\t\tasi.IsSmartSupported = TRUE;\n\t\tasi.Interface = L\"USB (JMicron JMS56X)\";\n\t\tasi.CurrentTransferMode = L\"---\";\n\t\tasi.MaxTransferMode = L\"----\";\n\n\t\t     if (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0002) { asi.MaxTransferMode = L\"SATA/150\"; }\n\t\telse if (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0004) { asi.MaxTransferMode = L\"SATA/300\"; }\n\t\telse if (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0008) { asi.MaxTransferMode = L\"SATA/600\"; }\n\t}\n\telse if (commandType == COMMAND_TYPE::CMD_TYPE_JMB39X)\n\t{\n\t\tasi.Major = 0;\n\t\tasi.IsSmartSupported = TRUE;\n\t\tasi.Interface = L\"USB (JMicron JMB39X)\";\n\t\tasi.CurrentTransferMode = L\"---\";\n\t\tasi.MaxTransferMode = L\"----\";\n\n\t\tif (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0002) { asi.MaxTransferMode = L\"SATA/150\"; }\n\t\telse if (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0004) { asi.MaxTransferMode = L\"SATA/300\"; }\n\t\telse if (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0008) { asi.MaxTransferMode = L\"SATA/600\"; }\n\t}\n\telse if (commandType == COMMAND_TYPE::CMD_TYPE_JMS586_40)\n\t{\n\t\tasi.Major = 0;\n\t\tasi.IsSmartSupported = TRUE;\n\t\tasi.Interface = L\"USB (JMicron JMS586 NewFW)\";\n\t\tasi.CurrentTransferMode = L\"---\";\n\t\tasi.MaxTransferMode = L\"----\";\n\n\t\tif (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0002) { asi.MaxTransferMode = L\"SATA/150\"; }\n\t\telse if (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0004) { asi.MaxTransferMode = L\"SATA/300\"; }\n\t\telse if (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0008) { asi.MaxTransferMode = L\"SATA/600\"; }\n\t}\n\telse if (commandType == COMMAND_TYPE::CMD_TYPE_JMS586_20)\n\t{\n\t\tasi.Major = 0;\n\t\tasi.IsSmartSupported = TRUE;\n\t\tasi.Interface = L\"USB (JMicron JMS586)\";\n\t\tasi.CurrentTransferMode = L\"---\";\n\t\tasi.MaxTransferMode = L\"----\";\n\n\t\tif (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0002) { asi.MaxTransferMode = L\"SATA/150\"; }\n\t\telse if (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0004) { asi.MaxTransferMode = L\"SATA/300\"; }\n\t\telse if (asi.IdentifyDevice.A.SerialAtaCapabilities & 0x0008) { asi.MaxTransferMode = L\"SATA/600\"; }\n\t}\n#endif\n\telse {\n\t\t// +AMD_RC2 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n\t\tasi.Major = GetAtaMajorVersion(identify->A.MajorVersion, asi.MajorVersion);\n\t\tGetAtaMinorVersion(identify->A.MinorVersion, asi.MinorVersion);\n\t\tasi.TransferModeType = GetTransferMode(identify->A.MultiWordDma, identify->A.SerialAtaCapabilities,\n\t\t\t\t\t\t\tidentify->A.SerialAtaAdditionalCapabilities,\n\t\t\t\t\t\t\tidentify->A.UltraDmaMode, asi.CurrentTransferMode, asi.MaxTransferMode,\n\t\t\t\t\t\t\tasi.Interface, &asi.InterfaceType);\n\t// +AMD_RC2 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\t}\n\t// +AMD_RC2 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t\n\tasi.DetectedTimeUnitType = GetTimeUnitType(asi.Model, asi.FirmwareRev, asi.Major, asi.TransferModeType);\n\n\tif(asi.DetectedTimeUnitType == POWER_ON_MILLI_SECONDS)\n\t{\n\t\tasi.MeasuredTimeUnitType = POWER_ON_MILLI_SECONDS;\n\t}\n\telse if(asi.DetectedTimeUnitType == POWER_ON_10_MINUTES)\n\t{\n\t\tasi.MeasuredTimeUnitType = POWER_ON_10_MINUTES;\n\t}\n\n\t// Feature\n\tif(asi.Major >= 3 && asi.IdentifyDevice.A.CommandSetSupported1 & (1 << 0))\n\t{\n\t\tasi.IsSmartSupported = TRUE;\n\t}\n\tif(asi.Major >= 3 && asi.IdentifyDevice.A.CommandSetSupported2 & (1 << 3))\n\t{\n\t\tasi.IsApmSupported = TRUE;\n\t\tif(asi.IdentifyDevice.A.CommandSetEnabled2 & (1 << 3))\n\t\t{\n\t\t\tasi.IsApmEnabled = TRUE;\n\t\t}\n\t}\n\tif(asi.Major >= 5 && asi.IdentifyDevice.A.CommandSetSupported2 & (1 << 9))\n\t{\n\t\tasi.IsAamSupported = TRUE;\n\t\tif(asi.IdentifyDevice.A.CommandSetEnabled2 & (1 << 9))\n\t\t{\n\t\t\tasi.IsAamEnabled = TRUE;\n\t\t}\n\t}\n\n\tif(asi.Major >= 5 && asi.IdentifyDevice.A.CommandSetSupported2 & (1 << 10))\n\t{\n\t\tasi.IsLba48Supported = TRUE;\n\t}\n\n\tif(asi.Major >= 6 && asi.IdentifyDevice.A.SerialAtaCapabilities & (1 << 8))\n\t{\n\t\tasi.IsNcqSupported = TRUE;\n\t}\n\n\tif(asi.Major >= 7 && asi.IdentifyDevice.A.NvCacheCapabilities & (1 << 0))\n\t{\n\t\tasi.IsNvCacheSupported = TRUE;\n\t}\n\n\tif(asi.Major >= 7 && asi.IdentifyDevice.A.DataSetManagement & (1 << 0))\n\t{\n\t\tasi.IsTrimSupported = TRUE;\n\t}\n\n\t// 8.17.4 ATA Streaming feature set\n\tif (asi.Major >= 7 && asi.IdentifyDevice.A.CommandSetSupported3 & (1 << 4))\n\t{\n\t\tasi.IsStreamingSupported = TRUE;\n\t}\n\t// 8.17.4 GPL feature set\n\tif (asi.Major >= 7 && asi.IdentifyDevice.A.CommandSetSupported3 & (1 << 5))\n\t{\n\t\tasi.IsGplSupported = TRUE;\n\t}\n\n\t// http://ascii.jp/elem/000/000/203/203345/img.html\n\t// \"NominalMediaRotationRate\" is supported by ATA8-ACS but a part of ATA/ATAPI-7 devices support this field.\n\tif(asi.Major >= 7 && asi.IdentifyDevice.A.NominalMediaRotationRate == 0x01)\n\t{\n\t\tasi.IsSsd = TRUE;\n\t\tasi.NominalMediaRotationRate = 1;\n\t}\n\n\tif(asi.Major >= 7 && (asi.IdentifyDevice.A.NominalMediaRotationRate >= 0x401\n\t&& asi.IdentifyDevice.A.NominalMediaRotationRate < 0xFFFF))\n\t{\n\t\tasi.NominalMediaRotationRate = asi.IdentifyDevice.A.NominalMediaRotationRate;\n\t}\n\n\tif(asi.Major >= 7 \n\t&&(asi.IdentifyDevice.A.DeviceNominalFormFactor & 0xF) > 0\n\t&&(asi.IdentifyDevice.A.DeviceNominalFormFactor & 0xF) <= 5\n\t)\n\t{\n\t\tasi.DeviceNominalFormFactor.Format(_T(\"%s\"),  \n\t\t\tdeviceFormFactorString[asi.IdentifyDevice.A.DeviceNominalFormFactor & 0xF]);\n\t//\tAfxMessageBox(asi.DeviceNominalFormFactor);\n\t}\n\n\tif(asi.Major >= 7 && asi.IdentifyDevice.A.SerialAtaFeaturesSupported & (1 << 8))\n\t{\n\t\tasi.IsDeviceSleepSupported = TRUE;\n\t}\n\n\tCString model = asi.Model;\n\tmodel.MakeUpper();\n\tif(model.Find(_T(\"MAXTOR\")) == 0 && asi.DetectedTimeUnitType == POWER_ON_MINUTES)\n\t{\n\t\tasi.IsMaxtorMinute = TRUE;\n\t}\n\n\t// DiskSize & BufferSize\n\tif(identify->A.LogicalCylinders > 16383)\n\t{\n\t\tidentify->A.LogicalCylinders = 16383;\n\t\tasi.IsIdInfoIncorrect = TRUE;\n\t}\n\tif(identify->A.LogicalHeads > 16)\n\t{\n\t\tidentify->A.LogicalHeads = 16;\n\t\tasi.IsIdInfoIncorrect = TRUE;\n\t}\n\tif(identify->A.LogicalSectors > 63)\n\t{\n\t\tidentify->A.LogicalSectors = 63;\n\t\tasi.IsIdInfoIncorrect = TRUE;\n\t}\n\n\tasi.Cylinder = identify->A.LogicalCylinders;\n\tasi.Head = identify->A.LogicalHeads;\n\tasi.Sector = identify->A.LogicalSectors;\n\tasi.Sector28 = 0x0FFFFFFF & identify->A.TotalAddressableSectors;\n\tasi.Sector48 = 0x0000FFFFFFFFFFFF & identify->A.MaxUserLba;\n\n\tif ((identify->A.SectorSize & 0xC000) == 0x4000) // bit 14-15, bit14=1, bit15=0\n\t{\n\t\tif ((identify->A.SectorSize & 0x000F) == 0x3) // bit 0-3\n\t\t{\n\t\t\tasi.LogicalSectorSize = 512;\n\t\t\tasi.PhysicalSectorSize = 4096;\n\t\t}\n\t\telse if ((identify->A.SectorSize & 0x1000) == 0x1000) // bit 12=1\n\t\t{\n\t\t\tif (identify->A.WordsPerLogicalSector == 256 || identify->A.WordsPerLogicalSector == 0)\n\t\t\t{\n\t\t\t\tasi.LogicalSectorSize = 512;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tasi.LogicalSectorSize = identify->A.WordsPerLogicalSector * 2;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\n\tif (asi.PhysicalSectorSize < asi.LogicalSectorSize)\n\t{\n\t\tasi.PhysicalSectorSize = asi.LogicalSectorSize;\n\t}\n\n\tif(identify->A.TotalAddressableSectors == 0x01100003) // 9126807040 bytes\n\t{\n\t\tasi.Is9126MB = TRUE;\n\t}\n\n\tif (commandType == COMMAND_TYPE::CMD_TYPE_AMD_RC2) // +AMD_RC2\n\t{\n\t\tasi.IsLba48Supported = TRUE;\n\t\tasi.DiskSizeChs = 0;\n\t}\n\telse if (commandType == COMMAND_TYPE::CMD_TYPE_JMS56X || commandType == COMMAND_TYPE::CMD_TYPE_JMB39X || commandType == COMMAND_TYPE::CMD_TYPE_JMS586_20 || commandType == COMMAND_TYPE::CMD_TYPE_JMS586_40)\n\t{\n\t\tasi.IsLba48Supported = TRUE;\n\t\tasi.DiskSizeChs = 0;\n\t}\n\telse if(identify->A.LogicalCylinders == 0 || identify->A.LogicalHeads == 0 || identify->A.LogicalSectors == 0)\n\t{\n\t//\treturn FALSE;\n\t//\tasi.DiskSizeChs   = 0;\n\t\t// Realteck RTL9210 support (2024/01/19)\n\t\tif (identify->A.Capabilities1 == 0 && identify->A.Capabilities2 == 0 && commandType == COMMAND_TYPE::CMD_TYPE_SAT)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tasi.DiskSizeChs = 0;\n\t\t}\n\t}\n\telse if(((ULONGLONG)((ULONGLONG)identify->A.LogicalCylinders * identify->A.LogicalHeads * identify->A.LogicalSectors * 512) / 1000 / 1000) > 1000)\n\t{\n\t\tasi.DiskSizeChs   = (DWORD)(((ULONGLONG)identify->A.LogicalCylinders * identify->A.LogicalHeads * identify->A.LogicalSectors * 512) / 1000 / 1000 - 49);\n\t}\n\telse\n\t{\n\t\tasi.DiskSizeChs   = (DWORD)(((ULONGLONG)identify->A.LogicalCylinders * identify->A.LogicalHeads * identify->A.LogicalSectors * 512) / 1000 / 1000);\n\t}\n\n\tasi.NumberOfSectors = (ULONGLONG)identify->A.LogicalCylinders * identify->A.LogicalHeads * identify->A.LogicalSectors;\n\tif(asi.Sector28 > 0 && ((ULONGLONG)asi.Sector28 * 512) / 1000 / 1000 > 49)\n\t{\n\t\tasi.DiskSizeLba28 = (DWORD)(((ULONGLONG)asi.Sector28 * 512) / 1000 / 1000 - 49);\n\t\tasi.NumberOfSectors = asi.Sector28;\n\t}\n\telse\n\t{\n\t\tasi.DiskSizeLba28 = 0;\n\t}\n\n\tif(asi.IsLba48Supported && (asi.Sector48 * asi.LogicalSectorSize) / 1000 / 1000 > 49)\n\t{\n\t\tasi.DiskSizeLba48 = (DWORD)((asi.Sector48 * asi.LogicalSectorSize) / 1000 / 1000 - 49);\n\t\tasi.NumberOfSectors = asi.Sector48;\n\t}\n\telse\n\t{\n\t\tasi.DiskSizeLba48 = 0;\n\t}\n\n\tasi.BufferSize = identify->A.BufferSize * 512;\n\tif(asi.IsNvCacheSupported)\n\t{\n\t\tasi.NvCacheSize = (ULONGLONG)identify->A.NvCacheSizeLogicalBlocks * 512;\n\t}\n\n\t// +AMD_RC2 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\tif (commandType == COMMAND_TYPE::CMD_TYPE_AMD_RC2) {\n\t\tasi.TotalDiskSize = TotalDiskSize;\n\t}\n\telse\n\t// +AMD_RC2 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\tif(identify->A.TotalAddressableSectors > 0x0FFFFFFF)\n\t{\n\t\tasi.TotalDiskSize = 0;\n\t}\n\telse if(asi.DiskSizeLba48 > asi.DiskSizeLba28)\n\t{\n\t\tasi.TotalDiskSize = asi.DiskSizeLba48;\n\t}\n\telse if(asi.DiskSizeLba28 > asi.DiskSizeChs)\n\t{\n\t\tasi.TotalDiskSize = asi.DiskSizeLba28;\n\t}\n\telse\n\t{\n\t\tasi.TotalDiskSize = asi.DiskSizeChs;\n\t}\n\n\t// Error Check for External ATA Controller\n\tif(asi.IsLba48Supported && (identify->A.TotalAddressableSectors < 268435455 && asi.DiskSizeLba28 != asi.DiskSizeLba48))\n\t{\n\t\tasi.DiskSizeLba48 = 0;\n\t}\n\n\tCString debug;\n\t// Check S.M.A.R.T. Enabled or Diabled\n\tif(asi.IsSmartSupported || asi.Is9126MB || IsAdvancedDiskSearch)\n\t{\n\t\tswitch(asi.CommandType)\n\t\t{\n\t\tcase CMD_TYPE_PHYSICAL_DRIVE:\n\t\t\tdebug.Format(_T(\"GetSmartAttributePd(%d) - 1\"), physicalDriveId);\n\t\t\tDebugPrint(debug);\n\t\t\tif(GetSmartAttributePd(physicalDriveId, asi.Target, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\tGetSmartAttributePd(physicalDriveId, asi.Target, &asiCheck);\n\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t{\n\t\t\t\t\tdebug.Format(_T(\"GetSmartAttributePd(%d) - 1A\"), physicalDriveId);\n\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t}\n\n\t\t\t\tif(GetSmartThresholdPd(physicalDriveId, asi.Target, &asi))\n\t\t\t\t{\n\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t}\n\t\t\t//\tasi.DiskStatus = CheckDiskStatus(asi.Attribute, asi.Threshold, asi.AttributeCount, asi.DiskVendorId, asi.IsSmartCorrect, asi.IsSsd);\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\t\n\t\t\tif(! asi.IsSmartCorrect && ControlSmartStatusPd(physicalDriveId, asi.Target, ENABLE_SMART))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"GetSmartAttributePd(%d) - 2\"), physicalDriveId);\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif(GetSmartAttributePd(physicalDriveId, asi.Target, &asi))\n\t\t\t\t{\n\t\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t\tGetSmartAttributePd(physicalDriveId, asi.Target, &asiCheck);\n\t\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t\t{\n\t\t\t\t\t\tdebug.Format(_T(\"GetSmartAttributePd(%d) - 2A\"), physicalDriveId);\n\t\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif(GetSmartThresholdPd(physicalDriveId, asi.Target, &asi))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t//\tasi.DiskStatus = CheckDiskStatus(asi.Attribute, asi.Threshold, asi.AttributeCount, asi.DiskVendorId, asi.IsSmartCorrect, asi.IsSsd);\n\t\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2012/9/12 - https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=821;id=diskinfo#821\n\t\t\t// 2013/12/2 - https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1330;id=diskinfo#1330\n\t\t\tif (memcmp(asi.SmartReadData, asi.SmartReadThreshold, 512) == 0 && asi.DiskVendorId != SSD_VENDOR_INDILINX)\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"asi.SmartReadData == asi.SmartReadThreshold\"));\n\t\t\t\tasi.IsSmartCorrect = FALSE;\n\t\t\t\tasi.IsThresholdCorrect = FALSE;\n\t\t\t\tasi.IsSmartEnabled = FALSE;\n\n\t\t\t\t/* 2013/04/12 Disabled\n\t\t\t\tm_bAtaPassThroughSmart = TRUE; // Force Enable ATA_PASS_THROUGH\n\t\t\t\t\n\t\t\t\tdebug.Format(_T(\"GetSmartAttributePd(%d) - 1\"), physicalDriveId);\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif(GetSmartAttributePd(physicalDriveId, asi.Target, &asi))\n\t\t\t\t{\n\t\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t\tGetSmartAttributePd(physicalDriveId, asi.Target, &asiCheck);\n\t\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t\t{\n\t\t\t\t\t\tdebug.Format(_T(\"GetSmartAttributePd(%d) - 1A\"), physicalDriveId);\n\t\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(GetSmartThresholdPd(physicalDriveId, asi.Target, &asi))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t//\tasi.DiskStatus = CheckDiskStatus(asi.Attribute, asi.Threshold, asi.AttributeCount, asi.DiskVendorId, asi.IsSmartCorrect, asi.IsSsd);\n\t\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif(! asi.IsSmartCorrect && ControlSmartStatusPd(physicalDriveId, asi.Target, ENABLE_SMART))\n\t\t\t\t{\n\t\t\t\t\tdebug.Format(_T(\"GetSmartAttributePd(%d) - 2\"), physicalDriveId);\n\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\tif(GetSmartAttributePd(physicalDriveId, asi.Target, &asi))\n\t\t\t\t\t{\n\t\t\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t\t\tGetSmartAttributePd(physicalDriveId, asi.Target, &asiCheck);\n\t\t\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdebug.Format(_T(\"GetSmartAttributePd(%d) - 2A\"), physicalDriveId);\n\t\t\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(GetSmartThresholdPd(physicalDriveId, asi.Target, &asi))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t//\tasi.DiskStatus = CheckDiskStatus(asi.Attribute, asi.Threshold, asi.AttributeCount, asi.DiskVendorId, asi.IsSmartCorrect, asi.IsSsd);\n\t\t\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_TYPE_SCSI_MINIPORT:\n\t\t\tif(GetSmartAttributeScsi(scsiPort, scsiTargetId, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\tGetSmartAttributeScsi(scsiPort, scsiTargetId, &asiCheck);\n\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t{\n\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t}\n\t\t\t\tif(GetSmartThresholdScsi(scsiPort, scsiTargetId, &asi))\n\t\t\t\t{\n\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t}\n\t\t\t//\tasi.DiskStatus = CheckDiskStatus(asi.Attribute, asi.Threshold, asi.AttributeCount, asi.DiskVendorId, asi.IsSmartCorrect, asi.IsSsd);\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\t\n\t\t\tif(! asi.IsSmartCorrect && ControlSmartStatusScsi(scsiPort, scsiTargetId, ENABLE_SMART))\n\t\t\t{\n\t\t\t\tif(GetSmartAttributeScsi(scsiPort, scsiTargetId, &asi))\n\t\t\t\t{\n\t\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t\tGetSmartAttributeScsi(scsiPort, scsiTargetId, &asiCheck);\n\t\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif(GetSmartThresholdScsi(scsiPort, scsiTargetId, &asi))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t//\tasi.DiskStatus = CheckDiskStatus(asi.Attribute, asi.Threshold, asi.AttributeCount, asi.DiskVendorId, asi.IsSmartCorrect, asi.IsSsd);\n\t\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_TYPE_SILICON_IMAGE:\n\t\t\tDebugPrint(_T(\"GetSmartAttributeSi(physicalDriveId, &asi)\"));\n\t\t\tif(GetSmartAttributeSi(physicalDriveId, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\tDebugPrint(_T(\"GetSmartAttributeSi(physicalDriveId, &asiCheck)\"));\n\t\t\t\tGetSmartAttributeSi(physicalDriveId, &asiCheck);\n\t\t\t\tDebugPrint(_T(\"CheckSmartAttributeCorrect(&asi, &asiCheck) - 1\"));\n\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t{\n\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t\t// Compare Si and Pd \n\t\t\t\t\tGetSmartAttributePd(physicalDriveId, 0xA0, &asiCheck);\n\t\t\t\t\tDebugPrint(_T(\"CheckSmartAttributeCorrect(&asi, &asiCheck) - 2\"));\n\t\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t\t{\n\t\t\t\t\t\tDebugPrint(_T(\"GetSmartThresholdPd\"));\n\t\t\t\t\t\t// Does not support GetSmartThresholdSi\n\t\t\t\t\t\tGetSmartThresholdPd(physicalDriveId, 0xA0, &asi);\n\t\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t//\tasi.DiskStatus = CheckDiskStatus(asi.Attribute, asi.Threshold, asi.AttributeCount, asi.DiskVendorId, asi.IsSmartCorrect, asi.IsSsd);\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_TYPE_CSMI:\n\t\t\tif(GetSmartAttributeCsmi(scsiPort, sasPhyEntity, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\tGetSmartAttributeCsmi(scsiPort, sasPhyEntity, &asiCheck);\n\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t{\n\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t}\n\t\t\t\tif(GetSmartThresholdCsmi(scsiPort, sasPhyEntity, &asi))\n\t\t\t\t{\n\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t}\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\t\n\t\t\tif(! asi.IsSmartCorrect && ControlSmartStatusCsmi(scsiPort, sasPhyEntity, ENABLE_SMART))\n\t\t\t{\n\t\t\t\tif(GetSmartAttributeCsmi(scsiPort, sasPhyEntity, &asi))\n\t\t\t\t{\n\t\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t\tGetSmartAttributeCsmi(scsiPort, sasPhyEntity, &asiCheck);\n\t\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif(GetSmartThresholdCsmi(scsiPort, sasPhyEntity, &asi))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_TYPE_CSMI_PHYSICAL_DRIVE:\n\t\t\tdebug.Format(_T(\"GetSmartAttributePd(%d) - 1 CSMI\"), physicalDriveId);\n\t\t\tDebugPrint(debug);\n\t\t\tif(GetSmartAttributePd(physicalDriveId, asi.Target, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\tGetSmartAttributePd(physicalDriveId, asi.Target, &asiCheck);\n\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t{\n\t\t\t\t\tdebug.Format(_T(\"GetSmartAttributePd(%d) - 1A CSMI\"), physicalDriveId);\n\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t}\n\n\t\t\t\tif(GetSmartThresholdPd(physicalDriveId, asi.Target, &asi))\n\t\t\t\t{\n\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t}\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\n\t\t\tif(! asi.IsSmartEnabled || ! asi.IsSmartCorrect || ! asi.IsThresholdCorrect)\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"GetSmartAttributeCsmi - 1 CSMI\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif(GetSmartAttributeCsmi(scsiPort, sasPhyEntity, &asi))\n\t\t\t\t{\n\t\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t\tGetSmartAttributeCsmi(scsiPort, sasPhyEntity, &asiCheck);\n\t\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif(GetSmartThresholdCsmi(scsiPort, sasPhyEntity, &asi))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t\t}\n\n\t\t\t\tif(asi.IsSmartEnabled && asi.IsSmartCorrect && asi.IsThresholdCorrect)\n\t\t\t\t{\n\t\t\t\t\tasi.CommandType = CMD_TYPE_CSMI;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif(! asi.IsSmartCorrect && ControlSmartStatusCsmi(scsiPort, sasPhyEntity, ENABLE_SMART))\n\t\t\t\t{\n\t\t\t\t\tif(GetSmartAttributeCsmi(scsiPort, sasPhyEntity, &asi))\n\t\t\t\t\t{\n\t\t\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t\t\tGetSmartAttributeCsmi(scsiPort, sasPhyEntity, &asiCheck);\n\t\t\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(GetSmartThresholdCsmi(scsiPort, sasPhyEntity, &asi))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t\t\t\tasi.CommandType = CMD_TYPE_CSMI;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CMD_TYPE_SAT:\n\t\tcase CMD_TYPE_SAT_ASM1352R:\n\t\tcase CMD_TYPE_SAT_REALTEK9220DP:\n\t\tcase CMD_TYPE_SUNPLUS:\n\t\tcase CMD_TYPE_IO_DATA:\n\t\tcase CMD_TYPE_LOGITEC:\n\t\tcase CMD_TYPE_PROLIFIC:\n\t\tcase CMD_TYPE_JMICRON:\n\t\tcase CMD_TYPE_CYPRESS:\n\t\t\tdebug.Format(_T(\"GetSmartAttributeSat(%d) - 1 [%s]\"), physicalDriveId, commandTypeString[asi.CommandType]);\n\t\t\tDebugPrint(debug);\n\t\t\tif(GetSmartAttributeSat(physicalDriveId, asi.Target, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\tDebugPrint(_T(\"GetSmartAttributeSat - 1A\"));\n\t\t\t\tGetSmartAttributeSat(physicalDriveId, asi.Target, &asiCheck);\n\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t{\n\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t}\n\t\t\t\tif(GetSmartThresholdSat(physicalDriveId, asi.Target, &asi))\n\t\t\t\t{\n\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t}\n\t\t\t//\tasi.DiskStatus = CheckDiskStatus(asi.Attribute, asi.Threshold, asi.AttributeCount, asi.DiskVendorId, asi.IsSmartCorrect, asi.IsSsd);\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\t\n\t\t\tif(! asi.IsSmartCorrect && ControlSmartStatusSat(physicalDriveId, asi.Target, ENABLE_SMART, asi.CommandType))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"GetSmartAttributeSat - 2\"));\n\t\t\t\tif(GetSmartAttributeSat(physicalDriveId, asi.Target, &asi))\n\t\t\t\t{\n\t\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t\tDebugPrint(_T(\"GetSmartAttributeSat - 2A\"));\n\t\t\t\t\tGetSmartAttributeSat(physicalDriveId, asi.Target, &asiCheck);\n\t\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif(GetSmartThresholdSat(physicalDriveId, asi.Target, &asi))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t//\tasi.DiskStatus = CheckDiskStatus(asi.Attribute, asi.Threshold, asi.AttributeCount, asi.DiskVendorId, asi.IsSmartCorrect, asi.IsSsd);\n\t\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_TYPE_WMI:\n\t\t\tasi.IsSmartCorrect = GetSmartAttributeWmi(&asi);\n\t\t\tasi.IsThresholdCorrect = GetSmartThresholdWmi(&asi);\n\t\t\tif(asi.IsSmartCorrect)\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_TYPE_MEGARAID:\n\t\t\tif(GetSmartAttributeMegaRAID(scsiPort, scsiTargetId, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\tGetSmartAttributeMegaRAID(scsiPort, scsiTargetId, &asiCheck);\n\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t{\n\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t}\n\t\t\t\tif(GetSmartThresholdMegaRAID(scsiPort, scsiTargetId, &asi))\n\t\t\t\t{\n\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t}\n\t\t\t//\tasi.DiskStatus = CheckDiskStatus(asi.Attribute, asi.Threshold, asi.AttributeCount, asi.DiskVendorId, asi.IsSmartCorrect, asi.IsSsd);\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\t\n\t\t\tif(! asi.IsSmartCorrect && ControlSmartStatusMegaRAID(scsiPort, scsiTargetId, ENABLE_SMART))\n\t\t\t{\n\t\t\t\tif(GetSmartAttributeMegaRAID(scsiPort, scsiTargetId, &asi))\n\t\t\t\t{\n\t\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t\tGetSmartAttributeMegaRAID(scsiPort, scsiTargetId, &asiCheck);\n\t\t\t\t\tif(CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif(GetSmartThresholdMegaRAID(scsiPort, scsiTargetId, &asi))\n\t\t\t\t\t{\n\t\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t\t}\n\t\t\t\t//\tasi.DiskStatus = CheckDiskStatus(asi.Attribute, asi.Threshold, asi.AttributeCount, asi.DiskVendorId, asi.IsSmartCorrect, asi.IsSsd);\n\t\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#if ! defined(_M_ARM) && ! defined(_M_ARM64)\n\t\tcase CMD_TYPE_AMD_RC2:// +AMD_RC2\n\t\t\tif (GetSmartDataAMD_RC2(scsiBus, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\tGetSmartDataAMD_RC2(scsiBus, &asiCheck);\n\t\t\t\tif (CheckSmartAttributeCorrect(&asi, &asiCheck))\n\t\t\t\t{\n\t\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\t}\n\t\t\t\tif (GetSmartThresholdAMD_RC2(scsiBus, &asiCheck)) {\n\t\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\t}\n\t\t\t\tasi.IsSmartSupported = TRUE;\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifdef JMICRON_USB_RAID_SUPPORT\n\t\tcase CMD_TYPE_JMS56X:\n\t\t\tif (GetSmartInfoJMS56X(scsiBus, scsiPort, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t// GetSmartInfoJMicronUsbRaid(scsiBus, scsiPort, &asiCheck);\n\t\t\t\t// if (CheckSmartAttributeCorrect(&asi, &asiCheck)){}\n\t\t\t\tasi.IsSmartSupported = TRUE;\n\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_TYPE_JMB39X:\n\t\t\tif (GetSmartInfoJMB39X(scsiBus, scsiPort, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t// GetSmartInfoJMicronUsbRaid(scsiBus, scsiPort, &asiCheck);\n\t\t\t\t// if (CheckSmartAttributeCorrect(&asi, &asiCheck)){}\n\t\t\t\tasi.IsSmartSupported = TRUE;\n\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_TYPE_JMS586_40:\n\t\t\tif (GetSmartInfoJMS586_40(scsiBus, scsiPort, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t// GetSmartInfoJMicronUsbRaid(scsiBus, scsiPort, &asiCheck);\n\t\t\t\t// if (CheckSmartAttributeCorrect(&asi, &asiCheck)){}\n\t\t\t\tasi.IsSmartSupported = TRUE;\n\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_TYPE_JMS586_20:\n\t\t\tif (GetSmartInfoJMS586_20(scsiBus, scsiPort, &asi))\n\t\t\t{\n\t\t\t\tCheckSsdSupport(asi);\n\t\t\t\t// GetSmartInfoJMicronUsbRaid(scsiBus, scsiPort, &asiCheck);\n\t\t\t\t// if (CheckSmartAttributeCorrect(&asi, &asiCheck)){}\n\t\t\t\tasi.IsSmartSupported = TRUE;\n\t\t\t\tasi.IsSmartCorrect = TRUE;\n\t\t\t\tasi.IsThresholdCorrect = TRUE;\n\t\t\t\tasi.IsSmartEnabled = TRUE;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// OCZ-VERTEX3 2.02 Firmware Bug\n\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=303;id=diskinfo#303\n\t// http://www.ocztechnologyforum.com/forum/showthread.php?88540-Vertex-3-Issues-Errors-and-Slow-speeds.\n\t// OCZ-VERTEX2 1.27 Firmware Bug\n\t// http://sourceforge.jp/ticket/browse.php?group_id=4394&tid=28153\n\tif(asi.DiskVendorId == SSD_VENDOR_SANDFORCE \n\t&&((asi.Model.Find(_T(\"OCZ-VERTEX3\")) == 0 && asi.FirmwareRev.Find(_T(\"2.02\")) == 0) \n\t|| (asi.Model.Find(_T(\"OCZ-VERTEX2\")) == 0 && asi.FirmwareRev.Find(_T(\"1.27\")) == 0))\n\t)\n\t{\n\t\tasi.IsThresholdBug = TRUE;\n\t}\n\t// SSD G2 Serieas Firmware Bug\n\t// http://hardforum.com/showthread.php?t=1732629\n\telse if(asi.Model.Find(_T(\"SSD G2 Series\")) == 0 && asi.FirmwareRev.Find(_T(\"3.6.5\")) == 0)\n\t{\n\t\tasi.IsThresholdBug = TRUE;\n\t}\n\t\n\t// DEBUG\n\t// asi.IsSmartCorrect = rand() %2;\n\n\tasi.PowerOnStartRawValue = asi.PowerOnRawValue;\n\n\tif(! asi.IsSmartCorrect)\n\t{\n\t\tasi.DetectedPowerOnHours = -1;\n\t\tasi.MeasuredPowerOnHours = -1;\n\t\tasi.PowerOnRawValue = -1;\n\t\tasi.PowerOnStartRawValue = -1;\n\t\tasi.PowerOnCount = 0;\n\t\tasi.Temperature = -1000;\n\t\tasi.DiskStatus = DISK_STATUS_UNKNOWN;\n\t}\n\n\t// Workaround for Intel SSD\n\tif (asi.Model.Find(_T(\"Intel\")) == 0 && asi.MeasuredPowerOnHours > 0x0DA753)\n\t{\n\t\tasi.PowerOnRawValue -= 0x0DA753;\n\t\tasi.DetectedPowerOnHours -= 0x0DA753;\n\t\tasi.MeasuredPowerOnHours -= 0x0DA753;\n\t}\n\n\tif (asi.Model.Find(_T(\"JMicron RAlD\")) == 0)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif(asi.IsIdInfoIncorrect && (! IsAdvancedDiskSearch || commandType >= CMD_TYPE_SAT))\n\t{\n\t\treturn FALSE;\n\t}\n\n\t// for CSMI devices & RAM Drive\n\tif(duplicatedId != -1)\n\t{\n\t\tif(asi.IsSmartCorrect)\n\t\t{\n\t\t\t// Replace Disk\n\t\t\tvars.RemoveAt(duplicatedId);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// None (Not Add Disk)\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/*\n\tif (physicalDriveId == 8)\n\t{\n\t\tBYTE d[512] = {0};\n\t\tReadLogExtPd(physicalDriveId, 0xA0, 0, 0, (PBYTE)&d, 512);\n\t\tif (d[8] > 0)\n\t\t{\n\t\t\tReadLogExtPd(physicalDriveId, 0xA0, 4, 0, (PBYTE)&d, 512);\n\t\t\tfor (int i = 1; i <= d[8]; i++)\n\t\t\t{\n\t\t\t\tif (d[8 + i] == 7)\n\t\t\t\t{\n\t\t\t\t\tReadLogExtPd(physicalDriveId, 0xA0, 4, 7, (PBYTE)&d, 512);\n\t\t\t\t\tDWORD EnduranceIndicator = d[8];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tReadLogExtPd(physicalDriveId, 0xA0, 4, 1, (PBYTE)&d, 512);\n\t\tDWORD PowerOnCount = B8toB32(d[8], d[9], d[10], d[11]);\n\t\tDWORD PowerOnHours = B8toB32(d[16], d[17], d[18], d[19]);\n\t\tULONG64 LogicalSectorsWritten = B8toB64(d[24], d[25], d[26], d[27], d[28], d[29]);\n\t\tULONG64 NumberOfWirteCommands = B8toB64(d[32], d[33], d[34], d[35], d[36], d[37]);\n\t\tULONG64 LogicalSectorsRead = B8toB64(d[40], d[41], d[42], d[43], d[44], d[45]);\n\t\tULONG64 NumberOfReadCommands = B8toB64(d[48], d[49], d[50], d[51], d[52], d[53]);\n\t\tDWORD PendingErrorCount = B8toB32(d[64], d[65], d[66], d[67]);\n\t\tDWORD WorkloadUtilization = d[72];\n\t\tDWORD UsageRate = d[80];\n\t\tDWORD ResourceAvailability = d[88];\n\t\tDWORD RandomWriteResourcesUsed = d[96];\n\n\t\tReadLogExtPd(physicalDriveId, 0xA0, 4, 7, (PBYTE)&d, 512);\n\t\tDWORD EnduranceIndicator = d[8];\n\n\t\tReadLogExtPd(physicalDriveId, 0xA0, 0x30, 2, (PBYTE)&d, 512);\n\t\tULONG64 DeviceCapacity = B8toB64(d[8], d[9], d[10], d[11], d[12], d[13]);\n\t\tULONG64 PhysicalLogicalSectorSize = B8toB64(d[16], d[17], d[18], d[19], d[20], d[21], d[22], d[23]);\n\t\tDWORD LogicalSectorSize = B8toB32(d[24], d[25], d[26], d[27]);\n\t\tDWORD BufferSize = B8toB32(d[32], d[33], d[34], d[35]);\n\t}\n\n\tif (TRUE || asi.DiskVendorId == SSD_VENDOR_SAMSUNG)\n\t{\n\t\tBYTE d[512] = { 0 };\n\t\tReadLogExtSat(physicalDriveId, 0xA0, 0, 0, (PBYTE)&d, 512, CMD_TYPE_SAT);\n\n\t\tReadLogExtSat(physicalDriveId, 0xA0, 4, 7, (PBYTE)&d, 512, CMD_TYPE_SAT);\n\t\tDWORD EnduranceIndicator = d[8];\n\n\t\tasi.Life = 100 - EnduranceIndicator;\n\t}\n\t*/\n\n\t// GetLifeByGpl(asi);\n\n\tvars.Add(asi);\n\n\treturn TRUE;\n}\n\n\nBOOL CAtaSmart::AddDiskNVMe(INT physicalDriveId, INT scsiPort, INT scsiTargetId, INT scsiBus, BYTE target, COMMAND_TYPE commandType, IDENTIFY_DEVICE* identify, DWORD* diskSize,\n\tCString pnpDeviceId, NVME_PORT_20* nvmePort20, NVME_PORT_40* nvmePort40, NVME_ID* nvmeId\n)\n{\n\tif (vars.GetCount() >= MAX_DISK)\n\t{\n\t\treturn FALSE;\n\t}\n\tATA_SMART_INFO asi = {};\n\n\tmemcpy(&(asi.IdentifyDevice), identify, sizeof(NVME_IDENTIFY_DEVICE));\n\tasi.PhysicalDriveId = physicalDriveId;\n\tasi.ScsiBus = scsiBus;\n\tasi.ScsiPort = scsiPort;\n\tasi.ScsiTargetId = scsiTargetId;\n\tasi.CommandType = commandType;\n\tasi.SsdVendorString = _T(\"\");\n\tasi.CommandTypeString = commandTypeString[commandType];\n\n\tasi.IsSmartEnabled = TRUE;\n\tasi.IsIdInfoIncorrect = FALSE;\n\tasi.IsSmartCorrect = TRUE;\n\tasi.IsThresholdCorrect = TRUE;\n\tasi.IsWord88 = FALSE;\n\tasi.IsWord64_76 = FALSE;\n\tasi.IsCheckSumError = FALSE;\n\tasi.IsRawValues8 = FALSE;\n\tasi.IsRawValues7 = FALSE;\n\tasi.Is9126MB = FALSE;\n\tasi.IsThresholdBug = FALSE;\n\n\tasi.IsSmartSupported = TRUE;\n\tasi.IsLba48Supported = FALSE;\n\tasi.IsNcqSupported = FALSE;\n\tasi.IsAamSupported = FALSE;\n\tasi.IsApmSupported = FALSE;\n\tasi.IsAamEnabled = FALSE;\n\tasi.IsApmEnabled = FALSE;\n\tasi.IsNvCacheSupported = FALSE;\n\tasi.IsDeviceSleepSupported = FALSE;\n\tasi.IsStreamingSupported = FALSE;\n\tasi.IsGplSupported = FALSE;\n\n\tasi.IsMaxtorMinute = FALSE;\n\tasi.IsSsd = TRUE;\n\tasi.IsTrimSupported = FALSE;\n\tasi.IsVolatileWriteCachePresent = FALSE;\n\n\tasi.TotalDiskSize = 0;\n\tasi.Cylinder = 0;\n\tasi.Head = 0;\n\tasi.Sector = 0;\n\tasi.Sector28 = 0;\n\tasi.Sector48 = 0;\n\tasi.NumberOfSectors = 0;\n\tasi.DiskSizeChs = 0;\n\tasi.DiskSizeLba28 = 0;\n\tasi.DiskSizeLba48 = 0;\n\tasi.LogicalSectorSize = 512;\n\tasi.PhysicalSectorSize = 512;\n\tasi.DiskSizeWmi = 0;\n\tasi.BufferSize = 0;\n\tasi.NvCacheSize = 0;\n\tasi.TransferModeType = 0;\n\tasi.DetectedTimeUnitType = 0;\n\tasi.MeasuredTimeUnitType = 0;\n\tasi.AttributeCount = 0;\n\tasi.DetectedPowerOnHours = -1;\n\tasi.MeasuredPowerOnHours = -1;\n\tasi.PowerOnRawValue = -1;\n\tasi.PowerOnStartRawValue = -1;\n\tasi.PowerOnCount = 0;\n\tasi.Temperature = -1000;\n\tasi.TemperatureMultiplier = 1.0;\n\tasi.NominalMediaRotationRate = 1;\n\t//\tasi.Speed = 0.0;\n\tasi.Life = -1;\n\tasi.HostWrites = -1;\n\tasi.HostReads = -1;\n\tasi.GBytesErased = -1;\n\tasi.NandWrites = -1;\n\tasi.WearLevelingCount = -1;\n\t//\tasi.PlextorNandWritesUnit = 0;\n\n\tasi.Major = 0;\n\tasi.Minor = 0;\n\n\tasi.DiskStatus = 0;\n\tasi.DriveLetterMap = 0;\n\n\tasi.AlarmTemperature = 0;\n\tasi.IsNVMe = TRUE;\n\n\tif (commandType == CMD_TYPE_NVME_JMICRON || commandType == CMD_TYPE_NVME_ASMEDIA || commandType == CMD_TYPE_NVME_REALTEK || commandType == CMD_TYPE_NVME_REALTEK9220DP)\n\t{\n\t\tasi.InterfaceType = INTERFACE_TYPE_USB;\n\t}\n\telse\n\t{\n\t\tasi.InterfaceType = INTERFACE_TYPE_NVME;\n\t}\n\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\n\tasi.DiskVendorId = VENDOR_UNKNOWN;\n\tasi.UsbVendorId = VENDOR_UNKNOWN;\n\tasi.UsbProductId = 0;\n\tasi.Target = target;\n\n\tasi.SerialNumber = _T(\"\");\n\tasi.FirmwareRev = _T(\"\");\n\tasi.Model = _T(\"\");\n\tasi.ModelReverse = _T(\"\");\n\tasi.ModelWmi = _T(\"\");\n\tasi.ModelSerial = _T(\"\");\n\tasi.DriveMap = _T(\"\");\n\tasi.MaxTransferMode = _T(\"\");\n\tasi.CurrentTransferMode = _T(\"\");\n\tasi.MajorVersion = _T(\"\");\n\tasi.MinorVersion = _T(\"\");\n\tasi.Interface = _T(\"\");\n\tasi.Enclosure = _T(\"\");\n\tasi.DeviceNominalFormFactor = _T(\"\");\n\tasi.PnpDeviceId = pnpDeviceId;\n\tasi.MinorVersion = _T(\"\");\n\n\tif (nvmePort20 != NULL)\n\t{\n\t\tasi.Model = nvmePort20->ModelName;\n\t\tasi.SerialNumber = nvmePort20->SerialNumber;\n\t\tasi.Model.TrimRight();\n\t\tasi.SerialNumber.TrimRight();\n\t\tasi.TotalDiskSize = (((DWORD64)nvmePort20->Capacity << 32) + (DWORD64)nvmePort20->CapacityOffset) * (DWORD64)nvmePort20->SectorSize / 1000 / 1000;\n\t}\n\telse if (nvmePort40 != NULL && nvmeId != NULL)\n\t{\n\t\tasi.Model = nvmePort40->ModelName;\n\t\tasi.FirmwareRev = nvmeId->FirmwareRevision;\n\t\tasi.SerialNumber = nvmePort40->SerialNumber;\n\t\tasi.Model.TrimRight();\n\t\tasi.SerialNumber.TrimRight();\n\t\tasi.TotalDiskSize = (((DWORD64)nvmePort40->Capacity << 32) + (DWORD64)nvmePort40->CapacityOffset) * (DWORD64)nvmePort40->SectorSize / 1000 / 1000;\n\t}\n\telse\n\t{\n\t\tasi.Model = asi.IdentifyDevice.N.Model;\n\t\tasi.Model = asi.Model.Mid(0, 40);\n\t\tasi.Model.TrimRight();\n\n\t\tif (asi.Model.IsEmpty())\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tasi.SerialNumber = asi.IdentifyDevice.N.SerialNumber;\n\t\tasi.SerialNumber = asi.SerialNumber.Mid(0, 20);\n\t\tasi.SerialNumber.TrimRight();\n\n\t\tasi.FirmwareRev = asi.IdentifyDevice.N.FirmwareRev;\n\t\tasi.FirmwareRev = asi.FirmwareRev.Mid(0, 8);\n\t\tasi.FirmwareRev.TrimRight();\n\t}\n\n\tasi.ModelSerial = GetModelSerial(asi.Model, asi.SerialNumber);\n\n\tif (diskSize != NULL)\n\t{\n\t\tasi.TotalDiskSize = *diskSize;\n\t}\n\n\tif (asi.IdentifyDevice.B.Bin[520] & 0x4) // for Dataset Management Command support\n\t{\n\t\tasi.IsTrimSupported = TRUE;\n\t}\n\n\tif (asi.IdentifyDevice.B.Bin[525] & 0x1) // for Volatile Write Cache\n\t{\n\t\tasi.IsVolatileWriteCachePresent = TRUE;\n\t}\n\n\t// Check duplicate device\n\tfor (int i = 0; i < vars.GetCount(); i++)\n\t{\n\t\tif ( ((commandType == CMD_TYPE_JMS586_20 || commandType == CMD_TYPE_JMS586_40 )&& asi.SerialNumber.Compare(vars[i].SerialNumber) == 0)\n\t\t||   (asi.Model.Compare(vars[i].Model) == 0 && asi.SerialNumber.Compare(vars[i].SerialNumber) == 0)\n\t\t)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (asi.Model.IsEmpty())\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (\n#if ! defined(_M_ARM) && ! defined(_M_ARM64)\n\t\t(commandType == COMMAND_TYPE::CMD_TYPE_AMD_RC2 && GetSmartDataAMD_RC2(scsiBus, &asi)) ||// +AMD_RC2\n#endif\n\t\t(m_bNVMeStorageQuery && commandType == CMD_TYPE_NVME_STORAGE_QUERY && GetSmartAttributeNVMeStorageQuery(physicalDriveId, scsiPort, scsiTargetId, &asi))\n\t||  (commandType == CMD_TYPE_NVME_INTEL && GetSmartAttributeNVMeIntel(physicalDriveId, scsiPort, scsiTargetId, &asi))\n\t||  (commandType == CMD_TYPE_NVME_INTEL_RST && GetSmartAttributeNVMeIntelRst(physicalDriveId, scsiPort, scsiTargetId, &asi))\n\t||  (commandType == CMD_TYPE_NVME_INTEL_VROC && GetSmartAttributeNVMeIntelVroc(physicalDriveId, scsiPort, scsiTargetId, &asi))\n\t||  (commandType == CMD_TYPE_NVME_SAMSUNG && GetSmartAttributeNVMeSamsung(physicalDriveId, scsiPort, scsiTargetId, &asi))\n\t||  (commandType == CMD_TYPE_NVME_SAMSUNG && GetSmartAttributeNVMeSamsung951(physicalDriveId, scsiPort, scsiTargetId, &asi))\n\t||  (commandType == CMD_TYPE_NVME_JMICRON && GetSmartAttributeNVMeJMicron(physicalDriveId, scsiPort, scsiTargetId, &asi))\n\t||  (commandType == CMD_TYPE_NVME_ASMEDIA && GetSmartAttributeNVMeASMedia(physicalDriveId, scsiPort, scsiTargetId, &asi))\n\t||  (commandType == CMD_TYPE_NVME_REALTEK && GetSmartAttributeNVMeRealtek(physicalDriveId, scsiPort, scsiTargetId, &asi))\n\t||  (commandType == CMD_TYPE_NVME_REALTEK9220DP && GetSmartAttributeNVMeRealtek9220DP(physicalDriveId, scsiPort, scsiTargetId, &asi))\n#ifdef JMICRON_USB_RAID_SUPPORT\n\t||  (commandType == CMD_TYPE_JMS586_40 && GetSmartAttributeNVMeJMS586_40(scsiPort, scsiTargetId, &asi))\n\t||  (commandType == CMD_TYPE_JMS586_20 && GetSmartAttributeNVMeJMS586_20(scsiPort, scsiTargetId, &asi))\n#endif\n\n\t\t)\n\t{\n\t\tasi.IsSmartSupported = TRUE;\n\t\tasi.Temperature = asi.SmartReadData[0x2] * 256 + asi.SmartReadData[0x1] - 273;\n\t\tif (asi.Temperature == -273 || asi.Temperature > 100)\n\t\t{\n\t\t\tasi.Temperature = -1000;\n\t\t}\n\n\t\tasi.Life = 100 - asi.SmartReadData[0x05];\n\t\tif (asi.Life < 0)\n\t\t{\n\t\t\tasi.Life = 0;\n\t\t}\n\n\t\tasi.HostReads = (INT)((*((UINT64*)&asi.SmartReadData[0x20]) * 1000) >> 21);// * 512 * 1000 / 1024 / 1024 / 1024\n\t\tasi.HostWrites = (INT)((*((UINT64*)&asi.SmartReadData[0x30]) * 1000) >> 21);// * 512 * 1000 / 1024 / 1024 / 1024\n\t\tasi.PowerOnCount = (DWORD)*((UINT64*)&asi.SmartReadData[0x70]);\n\t\tasi.MeasuredPowerOnHours = asi.DetectedPowerOnHours = (INT)*((UINT64*)&asi.SmartReadData[0x80]);\n\n\t\tNVMeSmartToATASmart(asi.SmartReadData, &asi.Attribute);\n\t\tGetTransferModePCIe(asi.CurrentTransferMode, asi.MaxTransferMode, GetPCIeSlotSpeed(physicalDriveId, true));\n\t\tasi.AttributeCount = NVME_ATTRIBUTE;\n\n\t\tasi.SmartKeyName = _T(\"SmartNVMe\");\n\t\tasi.DiskVendorId = SSD_VENDOR_NVME;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t\tasi.IsSmartSupported = TRUE;\n\t\tasi.Interface = _T(\"NVM Express\"); \n\n\t\tif (asi.IdentifyDevice.N.MajorVersion == 0)\n\t\t{\n\t\t\tasi.MajorVersion = _T(\"NVM Express 1.0/1.1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tasi.MajorVersion.Format(_T(\"NVM Express %d.%d\"), asi.IdentifyDevice.N.MajorVersion, asi.IdentifyDevice.N.MinorVersion);\n\t\t}\n\n\t\tif (commandType == COMMAND_TYPE::CMD_TYPE_JMS586_40 && nvmePort40 != NULL)\n\t\t{\n\t\t\tasi.Interface = L\"USB (NVMe/JMS586 New)\";\n\t\t\tasi.MajorVersion = L\"NVM Express\";\n\t\t\tstatic const TCHAR* pcieSpeed[4] = { L\"Gen 1.0\", L\"Gen 2.0\", L\"Gen 3.0\", L\"Gen 4.0\" };\n\t\t\tstatic const TCHAR* pcieLane[5] = { L\"x1\", L\"x2\", L\"x4\", L\"x8\", L\"x16\" };\n\t\t\tif (\n\t\t\t\t(0 <= nvmePort40->PCIeSpeed && nvmePort40->PCIeSpeed < 4)\n\t\t\t&&  (0 <= nvmePort40->PCIeLANE && nvmePort40->PCIeLANE < 5)\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tasi.CurrentTransferMode.Format(L\"%s %s\", pcieSpeed[nvmePort40->PCIeSpeed], pcieLane[nvmePort40->PCIeLANE]);\n\t\t\t}\n\t\t}\n\n\t\tif (commandType == COMMAND_TYPE::CMD_TYPE_JMS586_20 && nvmePort20 != NULL)\n\t\t{\n\t\t\tasi.Interface = L\"USB (NVMe/JMS586)\";\n\t\t\tasi.MajorVersion = L\"NVM Express\";\n\t\t\tstatic const TCHAR* pcieSpeed[4] = { L\"Gen 1.0\", L\"Gen 2.0\", L\"Gen 3.0\", L\"Gen 4.0\" };\n\t\t\tstatic const TCHAR* pcieLane[5] = { L\"x1\", L\"x2\", L\"x4\", L\"x8\", L\"x16\" };\n\t\t\tif ((0 <= nvmePort20->PCIeSpeed && nvmePort20->PCIeSpeed < 4)\n\t\t\t\t&& (0 <= nvmePort20->PCIeLANE && nvmePort20->PCIeLANE < 5))\n\t\t\t{\n\t\t\t\tasi.CurrentTransferMode.Format(L\"%s %s\", pcieSpeed[nvmePort20->PCIeSpeed], pcieLane[nvmePort20->PCIeLANE]);\n\t\t\t}\n\t\t}\n\n\t\t// +AMD_RC2 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\t\tif (commandType == COMMAND_TYPE::CMD_TYPE_AMD_RC2) {\n\t\t\tasi.MajorVersion = L\"\";\n\t\t\tasi.CurrentTransferMode = identify->N.Reserved3;//tmp\n\t\t\tasi.CurrentTransferMode.Replace(L\"NVMe\", L\"PCIe\");\n\t\t\tasi.CurrentTransferMode.Replace(L\"Gen1\", L\"1.0\");\n\t\t\tasi.CurrentTransferMode.Replace(L\"Gen2\", L\"2.0\");\n\t\t\tasi.CurrentTransferMode.Replace(L\"Gen3\", L\"3.0\");\n\t\t\tasi.CurrentTransferMode.Replace(L\"Gen4\", L\"4.0\");\n\t\t\tasi.CurrentTransferMode.Replace(L\"Gen5\", L\"5.0\");\n\t\t\tasi.CurrentTransferMode.Replace(L\"Gen6\", L\"6.0\");\n\t\t\tasi.CurrentTransferMode.Replace(L\"Gen7\", L\"7.0\");\n\t\t\tasi.CurrentTransferMode.Replace(L\"Gen8\", L\"8.0\");\n\t\t\tasi.CurrentTransferMode.Replace(L\"Gen9\", L\"9.0\");\n\n\t\t\tidentify->N.Reserved3[0] = '\\0';\n\t\t\tasi.Interface = _T(\"AMD_RC2 (NVMe)\");\n\t\t}\n\t\t// +AMD_RC2 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\t}\n\n\tvars.Add(asi);\n\n\treturn TRUE;\n}\n\nVOID CAtaSmart::CheckSsdSupport(ATA_SMART_INFO &asi)\n{\n\t// Old SSD Detection\n\tif(IsSsdOld(asi))\n\t{\n\t\tasi.IsSsd = TRUE;\n\t}\n\n\tif(! asi.IsSsd) // HDD\n\t{\n\t\tasi.SmartKeyName = _T(\"Smart\");\n\t\tasi.DiskVendorId = HDD_GENERAL;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdAdataIndustrial(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartAdataIndustrial\");\n\t\tasi.DiskVendorId = SSD_VENDOR_ADATA_INDUSTRIAL;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdSanDisk(asi))\n\t{\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdWdc(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartWdc\");\n\t\tasi.DiskVendorId = SSD_VENDOR_WDC;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdSeagate(asi))\n\t{\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdMtron(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartMtron\");\n\t\tasi.DiskVendorId = SSD_VENDOR_MTRON;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdToshiba(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartToshiba\");\n\t\tasi.DiskVendorId = SSD_VENDOR_TOSHIBA;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdJMicron66x(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartJMicron66x\");\n\t\tasi.DiskVendorId = SSD_VENDOR_JMICRON;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if(IsSsdJMicron61x(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartJMicron61x\");\n\t\tasi.DiskVendorId = SSD_VENDOR_JMICRON;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if(IsSsdJMicron60x(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartJMicron60x\");\n\t\tasi.DiskVendorId = SSD_VENDOR_JMICRON;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t\tasi.IsRawValues8 = TRUE;\n\t}\n\telse if(IsSsdIndilinx(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartIndilinx\");\n\t\tasi.DiskVendorId = SSD_VENDOR_INDILINX;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t\tasi.IsRawValues8 = TRUE;\n\t}\n\telse if (IsSsdIntelDc(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartIntelDc\");\n\t\tasi.DiskVendorId = SSD_VENDOR_INTEL_DC;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if(IsSsdIntel(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartIntel\");\n\t\tasi.DiskVendorId = SSD_VENDOR_INTEL;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if(IsSsdSamsung(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartSamsung\");\n\t\tasi.DiskVendorId = SSD_VENDOR_SAMSUNG;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdMicronMU03(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartMicronMU03\");\n\t\tasi.DiskVendorId = SSD_VENDOR_MICRON_MU03;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdMicron(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartMicron\");\n\t\tasi.DiskVendorId = SSD_VENDOR_MICRON;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if(IsSsdSandForce(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartSandForce\");\n\t\tasi.DiskVendorId = SSD_VENDOR_SANDFORCE;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t\tasi.IsRawValues7 = TRUE;\n\t}\n\telse if(IsSsdOcz(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartOcz\");\n\t\tasi.DiskVendorId = SSD_VENDOR_OCZ;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if(IsSsdOczVector(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartOczVector\");\n\t\tasi.DiskVendorId = SSD_VENDOR_OCZ_VECTOR;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdSsstc(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartSsstc\");\n\t\tasi.DiskVendorId = SSD_VENDOR_SSSTC;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if(IsSsdPlextor(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartPlextor\");\n\t\tasi.DiskVendorId = SSD_VENDOR_PLEXTOR;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdKingston(asi))\n\t{\n\t\tasi.DiskVendorId = SSD_VENDOR_KINGSTON;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdCorsair(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartCorsair\");\n\t\tasi.DiskVendorId = SSD_VENDOR_CORSAIR;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdRealtek(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartRealtek\");\n\t\tasi.DiskVendorId = SSD_VENDOR_REALTEK;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdSKhynix(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartSKhynix\");\n\t\tasi.DiskVendorId = SSD_VENDOR_SKHYNIX;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdKioxia(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartKioxia\");\n\t\tasi.DiskVendorId = SSD_VENDOR_KIOXIA;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdSiliconMotionCVC(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartSiliconMotionCVC\");\n\t\tasi.DiskVendorId = SSD_VENDOR_SILICONMOTION_CVC;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdSiliconMotion(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartSiliconMotion\");\n\t\tasi.DiskVendorId = SSD_VENDOR_SILICONMOTION;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdPhison(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartPhison\");\n\t\tasi.DiskVendorId = SSD_VENDOR_PHISON;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdMarvell(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartMarvell\");\n\t\tasi.DiskVendorId = SSD_VENDOR_MARVELL;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdMaxiotek(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartMaxiotek\");\n\t\tasi.DiskVendorId = SSD_VENDOR_MAXIOTEK;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdApacer(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartApacer\");\n\t\tasi.DiskVendorId = SSD_VENDOR_APACER;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdYmtc(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartYmtc\");\n\t\tasi.DiskVendorId = SSD_VENDOR_YMTC;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdScy(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartScy\");\n\t\tasi.DiskVendorId = SSD_VENDOR_SCY;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if (IsSsdRecadata(asi))\n\t{\n\t\tasi.SmartKeyName = _T(\"SmartRecadata\");\n\t\tasi.DiskVendorId = SSD_VENDOR_RECADATA;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t}\n\telse if(IsSsdGeneral(asi))\n\t{\n\t\tasi.DiskVendorId = SSD_GENERAL;\n\t\tasi.SsdVendorString = ssdVendorString[asi.DiskVendorId];\n\t\tasi.SmartKeyName = _T(\"SmartSsd\");\n\t\treturn ;\n\t}\n\telse\n\t{\n\t\tasi.DiskVendorId = HDD_GENERAL;\n\t\tasi.SmartKeyName = _T(\"Smart\");\n\t\treturn ;\n\t}\n\n// Update Life\n\tfor(DWORD j = 0; j < asi.AttributeCount; j++)\n\t{\n\t\tswitch(asi.Attribute[j].Id)\n\t\t{\n\t\tcase 0xBB:\n\t\t\tif(asi.DiskVendorId == SSD_VENDOR_MTRON)\n\t\t\t{\n\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue;\n\t\t\t\tif (asi.Life < 0 || asi.Life > 100) { asi.Life = -1; }\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xCA:\n\t\t\tif (asi.DiskVendorId == SSD_VENDOR_MICRON || asi.DiskVendorId == SSD_VENDOR_MICRON_MU03 || asi.DiskVendorId == SSD_VENDOR_INTEL_DC || asi.DiskVendorId == SSD_VENDOR_SILICONMOTION_CVC)\n\t\t\t{\n\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue;\n\t\t\t\tif (asi.Life < 0 || asi.Life > 100) { asi.Life = -1; }\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xD1:\n\t\t\tif(asi.DiskVendorId == SSD_VENDOR_INDILINX)\n\t\t\t{\n\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue;\n\t\t\t\tif (asi.Life < 0 || asi.Life > 100) { asi.Life = -1; }\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xC9:\n\t\t\tif (asi.DiskVendorId == SSD_VENDOR_SANDISK_HP || asi.DiskVendorId == SSD_VENDOR_SANDISK_HP_VENUS)\n\t\t\t{\n\t\t\t\tint life = -1;\n\t\t\t\tlife = asi.Attribute[j].CurrentValue;\n\t\t\t\tif (life < 0) { life = -1; }\n\n\t\t\t\tasi.Life = life;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xE6:\n\t\t\tif (asi.DiskVendorId == SSD_VENDOR_WDC || asi.DiskVendorId == SSD_VENDOR_SANDISK)\n\t\t\t{\n\t\t\t\tint life = -1;\n\n\t\t\t\tif (asi.FlagLifeSanDiskUsbMemory)\n\t\t\t\t{\n\t\t\t\t\tlife = -1;\n\t\t\t\t}\n\t\t\t\telse if (asi.FlagLifeSanDisk0_1)\n\t\t\t\t{\n\t\t\t\t\tlife = 100 - (asi.Attribute[j].RawValue[1] * 256 + asi.Attribute[j].RawValue[0])/100;\n\t\t\t\t}\n\t\t\t\telse if(asi.FlagLifeSanDisk1)\n\t\t\t\t{\n\t\t\t\t\tlife = 100 - asi.Attribute[j].RawValue[1];\n\t\t\t\t}\n\t\t\t\telse if (asi.FlagLifeSanDiskLenovo)\n\t\t\t\t{\n\t\t\t\t\tlife = asi.Attribute[j].CurrentValue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlife = 100 - asi.Attribute[j].RawValue[1];\n\t\t\t\t}\n\n\t\t\t\tif (life < 0) { life = -1; }\n\n\t\t\t\tasi.Life = life;\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SANDISK_LENOVO || asi.DiskVendorId == SSD_VENDOR_SANDISK_DELL)\n\t\t\t{\n\t\t\t\tint life = -1;\n\t\t\t\tlife = asi.Attribute[j].CurrentValue;\n\t\t\t\tif (life < 0) { life = -1; }\n\n\t\t\t\tasi.Life = life;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xE8:\n\t\t\tif(asi.DiskVendorId == SSD_VENDOR_PLEXTOR)\n\t\t\t{\n\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue;\n\t\t\t\tif (asi.Life < 0 || asi.Life > 100) { asi.Life = -1; }\n\t\t\t}\n\t\t\telse if(asi.DiskVendorId == SSD_VENDOR_OCZ)\n\t\t\t{\n\t\t\t\tasi.HostWrites  = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], \n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xE9:\n\t\t\tif(asi.DiskVendorId == SSD_VENDOR_INTEL || asi.DiskVendorId == SSD_VENDOR_OCZ || asi.DiskVendorId == SSD_VENDOR_OCZ_VECTOR || asi.DiskVendorId == SSD_VENDOR_SKHYNIX)\n\t\t\t{\n\t\t\t\tif (asi.FlagLifeRawValue)\n\t\t\t\t{\n\t\t\t\t\tasi.Life = asi.Attribute[j].RawValue[0];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue;\n\t\t\t\t}\n\t\t\t\tif (asi.Life < 0 || asi.Life > 100) { asi.Life = -1; }\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS)\n\t\t\t{\n\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue;\n\t\t\t\tif (asi.Life < 0 || asi.Life > 100) { asi.Life = -1; }\n\t\t\t}\n\t\t\telse if ((asi.DiskVendorId == SSD_VENDOR_SANDISK || asi.DiskVendorId == SSD_VENDOR_SANDISK_LENOVO) && asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t{\n\t\t\t\tasi.NandWrites = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_PLEXTOR || asi.DiskVendorId == SSD_VENDOR_KINGSTON || asi.DiskVendorId == SSD_VENDOR_WDC || asi.DiskVendorId == SSD_VENDOR_SSSTC || asi.DiskVendorId == SSD_VENDOR_SEAGATE ||  asi.DiskVendorId == SSD_VENDOR_SILICONMOTION_CVC)\n\t\t\t{\n\t\t\t\tasi.NandWrites = *((INT*)&asi.Attribute[j].RawValue[0]);\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_JMICRON || asi.DiskVendorId == SSD_VENDOR_ADATA_INDUSTRIAL)\n\t\t\t{\n\t\t\t\tasi.NandWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_MAXIOTEK)\n\t\t\t{\n\t\t\t\tif (asi.HostReadsWritesUnit == HOST_READS_WRITES_512B)\n\t\t\t\t{\n\t\t\t\t\tasi.NandWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tasi.NandWrites = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xE1:\n\t\t\tif(asi.DiskVendorId == SSD_VENDOR_INTEL)\n\t\t\t{\n\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t    asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xEA:\n\t\t\tif (asi.DiskVendorId == SSD_VENDOR_KINGSTON || asi.DiskVendorId == SSD_VENDOR_SEAGATE\n\t\t\t\t||  (asi.DiskVendorId == SSD_VENDOR_SKHYNIX && asi.HostReadsWritesUnit ==  HOST_READS_WRITES_GB)\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tasi.NandWrites = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xEB:\n\t\t\tif (asi.DiskVendorId == SSD_VENDOR_INTEL_DC)\n\t\t\t{\n\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xF1:\n\t\t\tif (asi.DiskVendorId == SSD_GENERAL)\n\t\t\t{\n\t\t\t\tif (asi.HostReadsWritesUnit == HOST_READS_WRITES_512B)\n\t\t\t\t{\n\t\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\telse if (asi.HostReadsWritesUnit == HOST_READS_WRITES_1MB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 1024);\n\t\t\t\t}\n\t\t\t\telse if (asi.HostReadsWritesUnit == HOST_READS_WRITES_16MB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 64);\n\t\t\t\t}\n\t\t\t\telse if (asi.HostReadsWritesUnit == HOST_READS_WRITES_32MB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t}\n\t\t\t\telse if(asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostWrites = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_TOSHIBA && asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t{\n\t\t\t\tasi.HostWrites = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SILICONMOTION_CVC && asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t{\n\t\t\t\tasi.HostWrites = *((INT*)&asi.Attribute[j].RawValue[0]);\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_INTEL_DC)\n\t\t\t{\n\t\t\t\tasi.NandWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t    asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t}\n\t\t\telse if(asi.DiskVendorId == SSD_VENDOR_INTEL || asi.DiskVendorId == SSD_VENDOR_TOSHIBA || asi.DiskVendorId == SSD_VENDOR_KIOXIA || asi.DiskVendorId == SSD_VENDOR_SILICONMOTION)\n\t\t\t{\n\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SANDFORCE || asi.DiskVendorId == SSD_VENDOR_OCZ_VECTOR || asi.DiskVendorId == SSD_VENDOR_CORSAIR || asi.DiskVendorId == SSD_VENDOR_KINGSTON || asi.DiskVendorId == SSD_VENDOR_REALTEK\n\t\t\t\t  || asi.DiskVendorId == SSD_VENDOR_WDC || asi.DiskVendorId == SSD_VENDOR_SSSTC || asi.DiskVendorId == SSD_VENDOR_SKHYNIX || asi.DiskVendorId == SSD_VENDOR_PHISON || asi.DiskVendorId == SSD_VENDOR_SEAGATE || asi.DiskVendorId == SSD_VENDOR_MARVELL\n\t\t\t\t  || asi.DiskVendorId == SSD_VENDOR_MAXIOTEK || asi.DiskVendorId == SSD_VENDOR_YMTC || asi.DiskVendorId == SSD_VENDOR_SCY || asi.DiskVendorId == SSD_VENDOR_RECADATA || asi.DiskVendorId == SSD_VENDOR_MICRON_MU03\n\t\t\t\t  || asi.DiskVendorId == SSD_VENDOR_SANDISK_HP || asi.DiskVendorId == SSD_VENDOR_SANDISK_HP_VENUS || asi.DiskVendorId == SSD_VENDOR_SANDISK_LENOVO || asi.DiskVendorId == SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS || asi.DiskVendorId == SSD_VENDOR_SANDISK_DELL || asi.DiskVendorId == SSD_VENDOR_ADATA_INDUSTRIAL\n\t\t\t)\n\t\t\t{\n\t\t\t\tif (asi.HostReadsWritesUnit == HOST_READS_WRITES_512B)\n\t\t\t\t{\n\t\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\telse if (asi.HostReadsWritesUnit == HOST_READS_WRITES_1MB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 1024);\n\t\t\t\t}\n\t\t\t\telse if (asi.HostReadsWritesUnit == HOST_READS_WRITES_16MB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 64);\n\t\t\t\t}\n\t\t\t\telse if (asi.HostReadsWritesUnit == HOST_READS_WRITES_32MB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tasi.HostWrites  = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SAMSUNG && asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t{\n\t\t\t\tasi.HostWrites = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SAMSUNG || asi.DiskVendorId == SSD_VENDOR_APACER || asi.DiskVendorId == SSD_VENDOR_JMICRON)\n\t\t\t{\n\t\t\t\tasi.HostWrites  = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5]) \n\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t}\n\t\t\telse if(asi.DiskVendorId == SSD_VENDOR_PLEXTOR)\n\t\t\t{\n\t\t\t\tasi.HostWrites  = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;;\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SANDISK && asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t{\n\t\t\t\tasi.HostWrites = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SANDISK)\n\t\t\t{\n\t\t\t\tasi.HostWrites = (INT) (\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xF2:\n\t\t\tif (asi.DiskVendorId == SSD_GENERAL)\n\t\t\t{\n\t\t\t\tif (asi.HostReadsWritesUnit == HOST_READS_WRITES_512B)\n\t\t\t\t{\n\t\t\t\t\tasi.HostReads = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\telse if (asi.HostReadsWritesUnit == HOST_READS_WRITES_16MB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostReads = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 64);\n\t\t\t\t}\n\t\t\t\telse if (asi.HostReadsWritesUnit == HOST_READS_WRITES_32MB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostReads = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t}\n\t\t\t\telse if (asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostReads = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_TOSHIBA && asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t{\n\t\t\t\tasi.HostReads = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SILICONMOTION_CVC && asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t{\n\t\t\t\tasi.HostReads = *((INT*)&asi.Attribute[j].RawValue[0]);\n\t\t\t}\n\t\t\telse if(asi.DiskVendorId == SSD_VENDOR_INTEL || asi.DiskVendorId == SSD_VENDOR_TOSHIBA || asi.DiskVendorId == SSD_VENDOR_SILICONMOTION)\n\t\t\t{\n\t\t\t\tasi.HostReads  = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SANDFORCE || asi.DiskVendorId == SSD_VENDOR_OCZ_VECTOR || asi.DiskVendorId == SSD_VENDOR_CORSAIR || asi.DiskVendorId == SSD_VENDOR_KINGSTON || asi.DiskVendorId == SSD_VENDOR_REALTEK\n\t\t\t\t  || asi.DiskVendorId == SSD_VENDOR_WDC || asi.DiskVendorId == SSD_VENDOR_SSSTC || asi.DiskVendorId == SSD_VENDOR_SKHYNIX || asi.DiskVendorId == SSD_VENDOR_SEAGATE || asi.DiskVendorId == SSD_VENDOR_MARVELL\n\t\t\t\t  || asi.DiskVendorId == SSD_VENDOR_MAXIOTEK || asi.DiskVendorId == SSD_VENDOR_YMTC || asi.DiskVendorId == SSD_VENDOR_SCY || asi.DiskVendorId == SSD_VENDOR_RECADATA || asi.DiskVendorId == SSD_VENDOR_MICRON_MU03\n\t\t\t\t  || asi.DiskVendorId == SSD_VENDOR_SANDISK_HP || asi.DiskVendorId == SSD_VENDOR_SANDISK_HP_VENUS || asi.DiskVendorId == SSD_VENDOR_SANDISK_LENOVO || asi.DiskVendorId == SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS || asi.DiskVendorId == SSD_VENDOR_SANDISK_DELL || asi.DiskVendorId == SSD_VENDOR_ADATA_INDUSTRIAL\n\t\t\t)\n\t\t\t{\n\t\t\t\tif (asi.HostReadsWritesUnit == HOST_READS_WRITES_512B)\n\t\t\t\t{\n\t\t\t\t\tasi.HostReads = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5]) \n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\telse if (asi.HostReadsWritesUnit == HOST_READS_WRITES_16MB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostReads = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 64);\n\t\t\t\t}\n\t\t\t\telse if (asi.HostReadsWritesUnit == HOST_READS_WRITES_32MB)\n\t\t\t\t{\n\t\t\t\t\tasi.HostReads = (INT)(\n\t\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tasi.HostReads  = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SAMSUNG && asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t{\n\t\t\t\tasi.HostReads = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\telse if(asi.DiskVendorId == SSD_VENDOR_SAMSUNG || asi.DiskVendorId == SSD_VENDOR_JMICRON)\n\t\t\t{\n\t\t\t\tasi.HostReads  = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t}\n\t\t\telse if(asi.DiskVendorId == SSD_VENDOR_PLEXTOR)\n\t\t\t{\n\t\t\t\tasi.HostReads  = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SANDISK && asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t{\n\t\t\t\tasi.HostReads = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\telse if(asi.DiskVendorId == SSD_VENDOR_SANDISK)\n\t\t\t{\n\t\t\t\tasi.HostReads  = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_MICRON || asi.DiskVendorId == SSD_VENDOR_MICRON_MU03)\n\t\t\t{\n\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue;\n\t\t\t\tif (asi.Life < 0 || asi.Life > 100) { asi.Life = -1; }\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xF3:\n\t\t\tif (asi.DiskVendorId == SSD_VENDOR_YMTC)\n\t\t\t{\n\t\t\t\tif (asi.Attribute[j].RawValue[0] > 0)\n\t\t\t\t{\n\t\t\t\t\tasi.Temperature = asi.Attribute[j].RawValue[0];\n\t\t\t\t}\n\n\t\t\t\tif (asi.Temperature >= 100)\n\t\t\t\t{\n\t\t\t\t\tasi.Temperature = -1000;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_INTEL)\n\t\t\t{\n\t\t\t\tasi.NandWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xF9:\n\t\t\tif(asi.DiskVendorId == SSD_VENDOR_INTEL || asi.DiskVendorId == SSD_VENDOR_REALTEK || asi.DiskVendorId == SSD_VENDOR_WDC || (asi.DiskVendorId == SSD_VENDOR_SANDISK && asi.HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t|| asi.DiskVendorId == SSD_VENDOR_SANDISK_HP || asi.DiskVendorId == SSD_VENDOR_SANDISK_HP_VENUS || asi.DiskVendorId == SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS)\n\t\t\t{\n\t\t\t\tasi.NandWrites  = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\telse if(asi.DiskVendorId == SSD_VENDOR_OCZ_VECTOR)\n\t\t\t{\n\t\t\t\tasi.NandWrites  = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t* 16 / 1024 / 1024);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xFA:\n\t\t\tif (asi.DiskVendorId == SSD_VENDOR_REALTEK)\n\t\t\t{\n\t\t\t\tasi.NandWrites = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x64:\n\t\t\tif(asi.DiskVendorId == SSD_VENDOR_SANDFORCE)\n\t\t\t{\n\t\t\t\tasi.GBytesErased  = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xAD:\n\t\t\tif (asi.DiskVendorId == SSD_VENDOR_TOSHIBA || asi.DiskVendorId == SSD_VENDOR_KIOXIA)\n\t\t\t{\n\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue - 100;\n\t\t\t\tif (asi.Life < 0 || asi.Life > 100) { asi.Life = -1; }\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0xB1:\n\t\t\tif(asi.DiskVendorId == SSD_VENDOR_SAMSUNG)\n\t\t\t{\n\t\t\t\tasi.WearLevelingCount  = (INT)MAKELONG(\n\t\t\t\t\tMAKEWORD(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1]),\n\t\t\t\t\tMAKEWORD(asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3])\n\t\t\t\t\t);\n\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue;\n\t\t\t\tif (asi.Life < 0 || asi.Life > 100) { asi.Life = -1; }\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xE7:\n\t\t\tif (asi.DiskVendorId == SSD_VENDOR_SANDFORCE || asi.DiskVendorId == SSD_VENDOR_CORSAIR || asi.DiskVendorId == SSD_VENDOR_KINGSTON || asi.DiskVendorId == SSD_VENDOR_SKHYNIX || asi.DiskVendorId == SSD_VENDOR_REALTEK\n\t\t\t||  asi.DiskVendorId == SSD_VENDOR_SANDISK || asi.DiskVendorId == SSD_VENDOR_SSSTC || asi.DiskVendorId == SSD_VENDOR_APACER || asi.DiskVendorId == SSD_VENDOR_JMICRON || asi.DiskVendorId == SSD_VENDOR_PHISON \n\t\t\t||  asi.DiskVendorId == SSD_VENDOR_SEAGATE || asi.DiskVendorId == SSD_VENDOR_MAXIOTEK || asi.DiskVendorId == SSD_VENDOR_YMTC || asi.DiskVendorId == SSD_VENDOR_SCY || asi.DiskVendorId == SSD_VENDOR_RECADATA || asi.DiskVendorId == SSD_VENDOR_ADATA_INDUSTRIAL)\n\t\t\t{\n\t\t\t\tif (asi.FlagLifeNoReport)\n\t\t\t\t{\n\t\t\t\t\tasi.Life = -1;\n\t\t\t\t}\n\t\t\t\telse if (asi.FlagLifeRawValueIncrement)\n\t\t\t\t{\n\t\t\t\t\tasi.Life = 100 - asi.Attribute[j].RawValue[0];\n\t\t\t\t}\n\t\t\t\telse if (asi.FlagLifeRawValue)\n\t\t\t\t{\n\t\t\t\t\tasi.Life = asi.Attribute[j].RawValue[0];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue;\n\t\t\t\t}\n\t\t\t\tif (asi.Life < 0 || asi.Life > 100) { asi.Life = -1; }\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xA9:\n\t\t\tif(asi.DiskVendorId == SSD_VENDOR_REALTEK || (asi.DiskVendorId == SSD_VENDOR_KINGSTON && asi.HostReadsWritesUnit == HOST_READS_WRITES_32MB) || asi.DiskVendorId == SSD_VENDOR_SILICONMOTION)\n\t\t\t{\n\t\t\t\tif (asi.FlagLifeRawValueIncrement)\n\t\t\t\t{\n\t\t\t\t\tasi.Life = 100 - asi.Attribute[j].RawValue[0];\n\t\t\t\t}\n\t\t\t\telse if (asi.FlagLifeRawValue)\n\t\t\t\t{\n\t\t\t\t\tasi.Life = asi.Attribute[j].RawValue[0];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue;\n\t\t\t\t}\n\t\t\t\tif (asi.Life < 0 || asi.Life > 100) { asi.Life = -1; }\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xC6:\n\t\t\tif(asi.DiskVendorId == SSD_VENDOR_OCZ_VECTOR)\n\t\t\t{\n\t\t\t\tasi.HostReads = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xC7:\n\t\t\tif(asi.DiskVendorId == SSD_VENDOR_OCZ_VECTOR)\n\t\t\t{\n\t\t\t\tasi.HostWrites = *((INT*)&asi.Attribute[j].RawValue[0]);//(INT)(B8toB32(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2], asi.Attribute[j].RawValue[3]));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xF5:\n\t\t\t// Percent Drive Life Remaining (SanDisk/WD CloudSpeed)\n\t\t\tif (asi.DiskVendorId == SSD_VENDOR_SANDISK_CLOUD)\n\t\t\t{\n\t\t\t\tasi.Life = asi.Attribute[j].CurrentValue;\n\t\t\t}\n\t\t\t// NAND Page Size = 8KBytes\n\t\t\t// http://www.overclock.net/t/1145150/official-crucial-ssd-owners-club/1290\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_MICRON)\n\t\t\t{\n\t\t\t\tasi.NandWrites = (INT) (\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t* 8 / 1024 / 1024);\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_MICRON_MU03)\n\t\t\t{\n\t\t\t\tasi.NandWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5]) \n\t\t\t\t\t/ 32);\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_KINGSTON && asi.HostReadsWritesUnit == HOST_READS_WRITES_32MB)\n\t\t\t{\n\t\t\t\tasi.NandWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SILICONMOTION)\n\t\t\t{\n\t\t\t\tasi.NandWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_SCY)\n\t\t\t{\n\t\t\t\tasi.NandWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t}\n\t\t\telse if (asi.DiskVendorId == SSD_VENDOR_RECADATA)\n\t\t\t{\n\t\t\t\tasi.NandWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t\tasi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5]));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0xF6:\n\t\t\tif (asi.DiskVendorId == SSD_VENDOR_MICRON || asi.DiskVendorId == SSD_VENDOR_MICRON_MU03)\n\t\t\t{\n\t\t\t\tasi.HostWrites = (INT)(\n\t\t\t\t\tB8toB64(asi.Attribute[j].RawValue[0], asi.Attribute[j].RawValue[1], asi.Attribute[j].RawValue[2],\n\t\t\t\t\t        asi.Attribute[j].RawValue[3], asi.Attribute[j].RawValue[4], asi.Attribute[j].RawValue[5])\n\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\nINT CAtaSmart::CheckPlextorNandWritesUnit(ATA_SMART_INFO &asi)\n{\n\tCString model = asi.Model;\n\tCString serial = asi.SerialNumber;\n\tINT unit = 0;\n\tINT capacity = 0;\n\tmodel.Replace(L\"PLEXTOR PX-\", L\"\");\n\tcapacity = _wtoi(model);\n\n\t// Block Size: 2MB\n\tif (model.Find(L\"M2\") >= 0 || model.Find(L\"M3\") >= 0\n\t|| ((model.Find(L\"M5P\") >= 0 || model.Find(L\"M5S\")) && _wtoi(serial.Mid(1, 5)) <= 2247)\n\t)\n\t{\n\t\tif (capacity > 0)\n\t\t{\n\t\t\tunit = capacity / 2;\n\t\t}\n\t}\n\t// Block Size: 4MB\n\telse\n\t{\n\t\tif (capacity > 0)\n\t\t{\n\t\t\tunit = capacity;\n\t\t}\n\t}\n\t\n\treturn unit;\n}\n*/\n\nBOOL CAtaSmart::IsSsdOld(ATA_SMART_INFO &asi)\n{\n\treturn asi.Model.Find(_T(\"OCZ\")) == 0 \n\t\t|| asi.Model.Find(_T(\"SPCC\")) == 0\n\t\t|| asi.Model.Find(_T(\"PATRIOT\")) == 0\n\t\t|| asi.Model.Find(_T(\"Solid\")) >= 0\n\t\t|| asi.Model.Find(_T(\"SSD\")) >= 0\n\t\t|| asi.Model.Find(_T(\"SiliconHardDisk\")) >= 0\n\t\t|| asi.Model.Find(_T(\"PHOTOFAST\")) == 0\n\t\t|| asi.Model.Find(_T(\"STT_FTM\")) == 0\n\t\t|| asi.Model.Find(_T(\"Super Talent\")) == 0\n\t\t;\n}\n\nBOOL CAtaSmart::IsSsdMtron(ATA_SMART_INFO &asi)\n{\n\treturn ((asi.Attribute[ 0].Id == 0xBB && asi.AttributeCount == 1) || asi.Model.Find(_T(\"MTRON\")) == 0);\n}\n\nBOOL CAtaSmart::IsSsdJMicron60x(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif(asi.Attribute[ 0].Id == 0x0C\n\t&& asi.Attribute[ 1].Id == 0x09\n\t&& asi.Attribute[ 2].Id == 0xC2\n\t&& asi.Attribute[ 3].Id == 0xE5\n\t&& asi.Attribute[ 4].Id == 0xE8\n\t&& asi.Attribute[ 5].Id == 0xE9\n//\t&& asi.Attribute[ 6].Id == 0xEA\n//\t&& asi.Attribute[ 7].Id == 0xEB\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdJMicron61x(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif(asi.Attribute[ 0].Id == 0x01\n\t&& asi.Attribute[ 1].Id == 0x02\n\t&& asi.Attribute[ 2].Id == 0x03\n\t&& asi.Attribute[ 3].Id == 0x05\n\t&& asi.Attribute[ 4].Id == 0x07\n\t&& asi.Attribute[ 5].Id == 0x08\n\t&& asi.Attribute[ 6].Id == 0x09\n\t&& asi.Attribute[ 7].Id == 0x0A\n\t&& asi.Attribute[ 8].Id == 0x0C\n\t&& asi.Attribute[ 9].Id == 0xA8\n\t&& asi.Attribute[10].Id == 0xAF\n\t&& asi.Attribute[11].Id == 0xC0\n\t&& asi.Attribute[12].Id == 0xC2\n//\t&& asi.Attribute[13].Id == 0xF0\n//\t&& asi.Attribute[14].Id == 0xAA\n//\t&& asi.Attribute[15].Id == 0xAD\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdJMicron66x(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif(asi.Attribute[0].Id == 0x01\n\t&& asi.Attribute[1].Id == 0x02\n\t&& asi.Attribute[2].Id == 0x03\n\t&& asi.Attribute[3].Id == 0x05\n\t&& asi.Attribute[4].Id == 0x07\n\t&& asi.Attribute[5].Id == 0x08\n\t&& asi.Attribute[6].Id == 0x09\n\t&& asi.Attribute[7].Id == 0x0A\n\t&& asi.Attribute[8].Id == 0x0C\n\t&& asi.Attribute[9].Id == 0xA7\n\t&& asi.Attribute[10].Id == 0xA8\n\t&& asi.Attribute[11].Id == 0xA9\n\t&& asi.Attribute[12].Id == 0xAA\n\t&& asi.Attribute[13].Id == 0xAD\n\t&& asi.Attribute[14].Id == 0xAF\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\telse if (asi.Model.Find(_T(\"ADATA SU700\")) == 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdIndilinx(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif(asi.Attribute[ 0].Id == 0x01\n\t&& asi.Attribute[ 1].Id == 0x09\n\t&& asi.Attribute[ 2].Id == 0x0C\n\t&& asi.Attribute[ 3].Id == 0xB8\n\t&& asi.Attribute[ 4].Id == 0xC3\n\t&& asi.Attribute[ 5].Id == 0xC4\n//\t&& asi.Attribute[ 6].Id == 0xC5\n//\t&& asi.Attribute[ 7].Id == 0xC6\n//\t&& asi.Attribute[ 8].Id == 0xC7\n//\t&& asi.Attribute[ 9].Id == 0xC8\n//\t&& asi.Attribute[10].Id == 0xC9\n//\t&& asi.Attribute[11].Id == 0xCA\n//\t&& asi.Attribute[12].Id == 0xCB\n//\t&& asi.Attribute[13].Id == 0xCC\n//\t&& asi.Attribute[14].Id == 0xCD\n//\t&& asi.Attribute[15].Id == 0xCE\n//\t&& asi.Attribute[16].Id == 0xCF\n//\t&& asi.Attribute[17].Id == 0xD0\n//\t&& asi.Attribute[18].Id == 0xD1\n//\t&& asi.Attribute[19].Id == 0xD2\n//\t&& asi.Attribute[20].Id == 0xD3\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\t/*\n\t\tasi.Model.Find(_T(\"OCZ-VERTEX\")) == 0\n\t|| asi.Model.Find(_T(\"G-Monster-V3\")) == 0\n\t|| asi.Model.Find(_T(\"G-Monster-V5\")) == 0 \n\t|| (asi.Model.Find(_T(\"STT_FTM\")) == 0 && asi.Model.Find(_T(\"GX\")) > 0)\n\t|| asi.Model.Find(_T(\"Solidata\")) == 0\n\t*/\n\n\treturn flagSmartType;\n\n}\n\nBOOL CAtaSmart::IsSsdIntelDc(ATA_SMART_INFO& asi)\n{\n\t// https://github.com/hiyohiyo/CrystalDiskInfo/issues/18\n\treturn (asi.Model.Find(_T(\"INTEL SSDSCKHB\")) >= 0);\n}\n\nBOOL CAtaSmart::IsSsdIntel(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tCString modelUpper = asi.Model;\n\tmodelUpper.MakeUpper();\n\n\tif(asi.Attribute[ 0].Id == 0x03\n\t&& asi.Attribute[ 1].Id == 0x04\n\t&& asi.Attribute[ 2].Id == 0x05\n\t&& asi.Attribute[ 3].Id == 0x09\n\t&& asi.Attribute[ 4].Id == 0x0C\n\t)\n\t{\n\t\tif(asi.Attribute[ 5].Id == 0xC0 && asi.Attribute[ 6].Id == 0xE8 && asi.Attribute[ 7].Id == 0xE9)\n\t\t{\n\t\t\tflagSmartType = TRUE;\n\t\t}\n\t\telse if(asi.Attribute[ 5].Id == 0xC0 && asi.Attribute[ 6].Id == 0xE1)\n\t\t{\n\t\t\tflagSmartType = TRUE;\n\t\t}\n\t\telse if(asi.Attribute[ 5].Id == 0xAA && asi.Attribute[ 6].Id == 0xAB && asi.Attribute[ 7].Id == 0xAC)\n\t\t{\n\t\t\tflagSmartType = TRUE;\n\t\t}\n\t}\n\n\treturn (modelUpper.Find(_T(\"INTEL\")) >= 0 || modelUpper.Find(_T(\"SOLIDIGM\")) >= 0 || flagSmartType == TRUE);\n}\n\n\n// http://www.samsung.com/us/business/oem-solutions/pdfs/General_NSSD_25_SATA_III_Spec_0.2.pdf\nBOOL CAtaSmart::IsSsdSamsung(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\t// SM951\n\tif (asi.Attribute[0].Id == 0x05\n\t\t&& asi.Attribute[1].Id == 0x09\n\t\t&& asi.Attribute[2].Id == 0x0C\n\t\t&& asi.Attribute[3].Id == 0xAA\n\t\t&& asi.Attribute[4].Id == 0xAB\n\t\t&& asi.Attribute[5].Id == 0xAC\n\t\t&& asi.Attribute[6].Id == 0xAD\n\t\t&& asi.Attribute[7].Id == 0xAE\n\t\t&& asi.Attribute[8].Id == 0xB2\n\t\t&& asi.Attribute[9].Id == 0xB4\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t}\n\telse if(asi.Attribute[ 0].Id == 0x09\n\t&& asi.Attribute[ 1].Id == 0x0C\n\t&& asi.Attribute[ 2].Id == 0xB2\n\t&& asi.Attribute[ 3].Id == 0xB3\n\t&& asi.Attribute[ 4].Id == 0xB4\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\telse\n\tif(asi.Attribute[ 0].Id == 0x09\n\t&& asi.Attribute[ 1].Id == 0x0C\n\t&& asi.Attribute[ 2].Id == 0xB1\n\t&& asi.Attribute[ 3].Id == 0xB2\n\t&& asi.Attribute[ 4].Id == 0xB3\n\t&& asi.Attribute[ 5].Id == 0xB4\n\t&& asi.Attribute[ 6].Id == 0xB7\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\telse \n\tif(asi.Attribute[ 0].Id == 0x09\n\t&& asi.Attribute[ 1].Id == 0x0C\n\t&& asi.Attribute[ 2].Id == 0xAF\n\t&& asi.Attribute[ 3].Id == 0xB0\n\t&& asi.Attribute[ 4].Id == 0xB1\n\t&& asi.Attribute[ 5].Id == 0xB2\n\t&& asi.Attribute[ 6].Id == 0xB3\n\t&& asi.Attribute[ 7].Id == 0xB4\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\telse \n\tif(asi.Attribute[ 0].Id == 0x05\n\t&& asi.Attribute[ 1].Id == 0x09\n\t&& asi.Attribute[ 2].Id == 0x0C\n\t&& asi.Attribute[ 3].Id == 0xB1\n\t&& asi.Attribute[ 4].Id == 0xB3\n\t&& asi.Attribute[ 5].Id == 0xB5\n\t&& asi.Attribute[ 6].Id == 0xB6\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\treturn ((asi.Model.Find(_T(\"SAMSUNG\")) >= 0 && asi.IsSsd) || (asi.Model.Find(_T(\"MZ-\")) >= 0 && asi.IsSsd) || flagSmartType == TRUE);\n}\n\nBOOL CAtaSmart::IsSsdSandForce(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif(asi.Attribute[ 0].Id == 0x01\n\t&& asi.Attribute[ 1].Id == 0x05\n\t&& asi.Attribute[ 2].Id == 0x09\n\t&& asi.Attribute[ 3].Id == 0x0C\n\t&& asi.Attribute[ 4].Id == 0x0D\n\t&& asi.Attribute[ 5].Id == 0x64\n\t&& asi.Attribute[ 6].Id == 0xAA\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\tif(asi.Attribute[ 0].Id == 0x01\n\t&& asi.Attribute[ 1].Id == 0x05\n\t&& asi.Attribute[ 2].Id == 0x09\n\t&& asi.Attribute[ 3].Id == 0x0C\n\t&& asi.Attribute[ 4].Id == 0xAB\n\t&& asi.Attribute[ 5].Id == 0xAC\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\t// TOSHIBA + SandForce\n\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1116;id=diskinfo#1116\n\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1136;id=diskinfo#1136\n\tif(asi.Attribute[ 0].Id == 0x01\n\t&& asi.Attribute[ 1].Id == 0x02\n\t&& asi.Attribute[ 2].Id == 0x03\n\t&& asi.Attribute[ 3].Id == 0x05\n\t&& asi.Attribute[ 4].Id == 0x07\n\t&& asi.Attribute[ 5].Id == 0x08\n\t&& asi.Attribute[ 6].Id == 0x09\n\t&& asi.Attribute[ 7].Id == 0x0A\n\t&& asi.Attribute[ 8].Id == 0x0C\n\t&& asi.Attribute[ 9].Id == 0xA7\n\t&& asi.Attribute[10].Id == 0xA8\n\t&& asi.Attribute[11].Id == 0xA9\n\t&& asi.Attribute[12].Id == 0xAA\n\t&& asi.Attribute[13].Id == 0xAD\n\t&& asi.Attribute[14].Id == 0xAF\n\t&& asi.Attribute[15].Id == 0xB1\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\treturn (asi.Model.Find(_T(\"SandForce\")) >= 0 || flagSmartType == TRUE);\n}\n\n// Micron Crucial\nBOOL CAtaSmart::IsSsdMicronMU03(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tCString modelUpper = asi.Model;\n\tmodelUpper.MakeUpper();\n\n\n\tif ((\n\t\t   modelUpper.Find(_T(\"MICRON_M600\")) == 0 || modelUpper.Find(_T(\"MICRON M600\")) == 0\n\t\t|| modelUpper.Find(_T(\"MICRON_M550\")) == 0 || modelUpper.Find(_T(\"MICRON M550\")) == 0\n\t\t|| modelUpper.Find(_T(\"MICRON_M510\")) == 0 || modelUpper.Find(_T(\"MICRON M510\")) == 0\n\t\t|| modelUpper.Find(_T(\"MICRON_M500\")) == 0 || modelUpper.Find(_T(\"MICRON M500\")) == 0\n\t\t|| modelUpper.Find(_T(\"MICRON_1300\")) == 0 || modelUpper.Find(_T(\"MICRON 1300\")) == 0\n\t\t|| modelUpper.Find(_T(\"MICRON_1100\")) == 0 || modelUpper.Find(_T(\"MICRON 1100\")) == 0 || modelUpper.Find(_T(\"MTFDDA\")) == 0))\n\t{\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\t\tflagSmartType = TRUE;\n\t}\n\telse if (\n\t\t(  modelUpper.Find(_T(\"M500SSD\")) >= 0\n\t\t|| modelUpper.Find(_T(\"MX500SSD\")) >= 0 || modelUpper.Find(_T(\"BX500SSD\")) >= 0\n\t\t|| modelUpper.Find(_T(\"MX300SSD\")) >= 0 || modelUpper.Find(_T(\"BX300SSD\")) >= 0\n\t\t|| modelUpper.Find(_T(\"MX200SSD\")) >= 0 || modelUpper.Find(_T(\"BX200SSD\")) >= 0\n\t\t|| modelUpper.Find(_T(\"MX100SSD\")) >= 0 || modelUpper.Find(_T(\"BX100SSD\")) >= 0\n\t\t|| modelUpper.Find(L\"MTFD\") == 0)\n\t\t&& asi.FirmwareRev.Find(L\"MU01\") == -1 )//&& !asi.FirmwareRev.Find(L\"MU01\") == 0)\n\t{\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_32MB;\n\t\tflagSmartType = TRUE;\n\t}\n\n\treturn flagSmartType;\n}\n\n// Micron RealSSD & Crucial\nBOOL CAtaSmart::IsSsdMicron(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tCString modelUpper = asi.Model;\n\tmodelUpper.MakeUpper();\n\n\tif(asi.Attribute[ 0].Id == 0x01\n\t&& asi.Attribute[ 1].Id == 0x05\n\t&& asi.Attribute[ 2].Id == 0x09\n\t&& asi.Attribute[ 3].Id == 0x0C\n\t&& asi.Attribute[ 4].Id == 0xAA\n\t&& asi.Attribute[ 5].Id == 0xAB\n\t&& asi.Attribute[ 6].Id == 0xAC\n\t&& asi.Attribute[ 7].Id == 0xAD\n\t&& asi.Attribute[ 8].Id == 0xAE\n\t&& asi.Attribute[ 9].Id == 0xB5\n\t&& asi.Attribute[10].Id == 0xB7\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\treturn modelUpper.Find(_T(\"P600\")) == 0 || modelUpper.Find(_T(\"C600\")) == 0\n\t\t|| modelUpper.Find(_T(\"M6-\")) == 0 || modelUpper.Find(_T(\"M600\")) == 0\n\t\t|| modelUpper.Find(_T(\"P500\")) == 0\n\t\t|| (modelUpper.Find(_T(\"C500\")) == 0 && asi.FirmwareRev.Find(_T(\"H\")) != 0) // workaround for Maxiotek C500\n\t\t|| modelUpper.Find(_T(\"M5-\")) == 0 || modelUpper.Find(_T(\"M500\")) == 0\n\t\t|| modelUpper.Find(_T(\"P400\")) == 0 || modelUpper.Find(_T(\"C400\")) == 0 \n\t\t|| modelUpper.Find(_T(\"M4-\")) == 0 || modelUpper.Find(_T(\"M400\")) == 0\n\t\t|| modelUpper.Find(_T(\"P300\")) == 0 || modelUpper.Find(_T(\"C300\")) == 0\n\t\t|| modelUpper.Find(_T(\"M3-\")) == 0 || modelUpper.Find(_T(\"M300\")) == 0\n\t\t|| (modelUpper.Find(_T(\"CT\")) == 0 && modelUpper.Find(_T(\"SSD\")) != -1)\n\t\t|| modelUpper.Find(_T(\"CRUCIAL\")) == 0 || modelUpper.Find(_T(\"MICRON\")) == 0\n\t\t|| modelUpper.Find(L\"MTFD\") == 0\n\t\t|| flagSmartType == TRUE;\n}\n\nBOOL CAtaSmart::IsSsdOcz(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tCString modelUpper = asi.Model;\n\tmodelUpper.MakeUpper();\n\n\t// OCZ-TRION100 2015/11/25\n\tif (modelUpper.Find(_T(\"OCZ-TRION\")) == 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\t// 2012/3/11\n\t// OCZ-PETROL - https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=553;id=diskinfo#553\n\t// OCZ-OCTANE S2 - https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=577;id=diskinfo#577\n\t// OCZ-VERTEX 4 - http://imageshack.us/a/img269/7506/ocz2.png\n\tif(asi.Attribute[ 0].Id == 0x01\n\t&& asi.Attribute[ 1].Id == 0x03\n\t&& asi.Attribute[ 2].Id == 0x04\n\t&& asi.Attribute[ 3].Id == 0x05\n\t&& asi.Attribute[ 4].Id == 0x09\n\t&& asi.Attribute[ 5].Id == 0x0C\n\t&& asi.Attribute[ 6].Id == 0xE8\n\t&& asi.Attribute[ 7].Id == 0xE9\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\t\n\treturn (modelUpper.Find(_T(\"OCZ\")) == 0 && flagSmartType == TRUE);\n}\n\nBOOL CAtaSmart::IsSsdOczVector(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tCString modelUpper = asi.Model;\n\tmodelUpper.MakeUpper();\n\n\t// Radeon R7 2024/06/13\n\tif (modelUpper.Find(_T(\"RADEON R7\")) == 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t\treturn TRUE;\n\t}\n\n\t/*\n\t// 2013/1/19\n\t// OCZ-VECTOR - https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1031;id=diskinfo#1031\n\tif (asi.Attribute[0].Id == 0x05\n\t\t&& asi.Attribute[1].Id == 0x09\n\t\t&& asi.Attribute[2].Id == 0x0C\n\t\t&& asi.Attribute[3].Id == 0xAB\n\t\t&& asi.Attribute[4].Id == 0xAE\n\t\t&& asi.Attribute[5].Id == 0xBB\n\t\t&& asi.Attribute[6].Id == 0xC3\n\t\t&& asi.Attribute[7].Id == 0xC4\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\t// 2013/3/24\n\t// OCZ-VECTOR - FW 2.0\n\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1185;id=diskinfo#1185\n\tif (asi.Attribute[0].Id == 0x05\n\t\t&& asi.Attribute[1].Id == 0x09\n\t\t&& asi.Attribute[2].Id == 0x0C\n\t\t&& asi.Attribute[3].Id == 0xAB\n\t\t&& asi.Attribute[4].Id == 0xAE\n\t\t&& asi.Attribute[5].Id == 0xC3\n\t\t&& asi.Attribute[6].Id == 0xC4\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\t*/\n\n\t// 2015/11/25\n\t// PANASONIC RP-SSB240GAK\n\t// https://crystalmark.info/board/c-board.cgi?cmd=one;no=500;id=#500\n\tif (asi.Attribute[0].Id == 0x05\n\t\t&& asi.Attribute[1].Id == 0x09\n\t\t&& asi.Attribute[2].Id == 0x0C\n\t\t&& asi.Attribute[3].Id == 0xAB\n\t\t&& asi.Attribute[4].Id == 0xAE\n\t\t&& asi.Attribute[5].Id == 0xC3\n\t\t&& asi.Attribute[6].Id == 0xC4\n\t\t&& asi.Attribute[7].Id == 0xC5\n\t\t&& asi.Attribute[8].Id == 0xC6\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\tif (modelUpper.Find(_T(\"PANASONIC RP-SSB\")) == 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\t\n\treturn (modelUpper.Find(_T(\"OCZ\")) == 0 || flagSmartType == TRUE);\n}\n\nBOOL CAtaSmart::IsSsdSsstc(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif (asi.Model.Find(L\"CV8-\") >= 0 || asi.Model.Find(L\"CVB-\") >= 0 || asi.Model.Find(L\"ER2-\") >= 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdPlextor(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\t// 2012/10/10\n\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=739;id=diskinfo#739\n\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=829;id=diskinfo#829\n\tif(asi.Attribute[ 0].Id == 0x01\n\t&& asi.Attribute[ 1].Id == 0x05\n\t&& asi.Attribute[ 2].Id == 0x09\n\t&& asi.Attribute[ 3].Id == 0x0C\n\t&& asi.Attribute[ 4].Id == 0xB1\n\t&& asi.Attribute[ 5].Id == 0xB2\n\t&& asi.Attribute[ 6].Id == 0xB5\n\t&& asi.Attribute[ 7].Id == 0xB6\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\t// Added CFD's SSD\n\t// Added LITEON CV6-CQ (2018/9/17)\n\treturn \tasi.Model.Find(_T(\"PLEXTOR\")) == 0 || asi.Model.Find(_T(\"LITEON\")) == 0 || asi.Model.Find(_T(\"CV6-CQ\")) == 0 || asi.Model.Find(_T(\"CSSD-S6T128NM3PQ\")) == 0 || asi.Model.Find(_T(\"CSSD-S6T256NM3PQ\")) == 0\n\t\t|| flagSmartType == TRUE;\n}\n\nBOOL CAtaSmart::IsSsdSanDisk(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\t// 2013/10/7\n\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1425;id=diskinfo#1425\n\t// 2020/07/25\n\t// \n\tif (asi.Model.Find(_T(\"SanDisk\")) >= 0 || asi.Model.Find(_T(\"SD Ultra\")) >=0 || asi.Model.Find(_T(\"SDLF1\")) >= 0)\n\t{\n\t\tasi.DiskVendorId = SSD_VENDOR_SANDISK; // Default Vendor ID for SanDisk\n\t\tflagSmartType = TRUE;\n\n\t\tif (\n\t\t\t  (asi.Model.Find(_T(\"X600\")) >= 0 && asi.Model.Find(_T(\"2280\")) >= 0) // https://crystalmark.info/board/c-board.cgi?cmd=one;no=2123;id=#2123\n\t\t\t|| asi.Model.Find(_T(\"X400\")) >= 0\n\t\t\t|| asi.Model.Find(_T(\"X300\")) >= 0\n\t\t\t|| asi.Model.Find(_T(\"X110\")) >= 0\n\t\t\t|| asi.Model.Find(_T(\"SD5\")) >= 0\n\t\t\t)\n\t\t{\n\t\t\tif (asi.Attribute[2].Id == 0xAF || asi.Attribute[3].Id == 0xAF)\n\t\t\t{\n\t\t\t\tasi.SmartKeyName = _T(\"SmartSanDiskDell\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tasi.SmartKeyName = _T(\"SmartSanDiskGb\");\n\t\t\t}\n\t\t\tasi.FlagLifeSanDisk1 = TRUE;\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\n\t\t}\n\t\telse if (asi.Model.Find(_T(\"Z400\")) >= 0)\n\t\t{\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t\tasi.SmartKeyName = _T(\"SmartSanDiskDell\");\n\t\t}\n\t\t// 2022/04/24\n\t\t// https://osdn.net/projects/crystaldiskinfo/ticket/44354\n\t\telse if (asi.Model.Find(_T(\"1006\")) > 0) // HP OEM\n\t\t{\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_16MB;\n\t\t\tif (asi.Model.Find(_T(\"8U\")) > 0)\n\t\t\t{\n\t\t\t\tasi.DiskVendorId = SSD_VENDOR_SANDISK_HP_VENUS;\n\t\t\t\tasi.SmartKeyName = _T(\"SmartSanDiskHpVenus\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tasi.DiskVendorId = SSD_VENDOR_SANDISK_HP;\n\t\t\t\tasi.SmartKeyName = _T(\"SmartSanDiskHp\");\n\t\t\t}\n\t\t}\n\t\telse if (asi.Model.Find(_T(\"G1001\")) >= 0) // Lenovo OEM\n\t\t{\n\t\t\tasi.FlagLifeSanDiskLenovo = TRUE;\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t\tif (asi.Model.Find(_T(\"6S\")) > 0 || asi.Model.Find(_T(\"7S\")) > 0 || asi.Model.Find(_T(\"8U\")) > 0)\n\t\t\t{\n\t\t\t\tasi.DiskVendorId = SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS;\n\t\t\t\tasi.SmartKeyName = _T(\"SmartSanDiskLenovoHelenVenus\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tasi.DiskVendorId = SSD_VENDOR_SANDISK_LENOVO;\n\t\t\t\tasi.SmartKeyName = _T(\"SmartSanDiskLenovo\");\n\t\t\t}\t\t\t\n\t\t}\n\t\telse if (asi.Model.Find(_T(\"G1012\")) >= 0 || asi.Model.Find(_T(\"Z400s 2.5\")) >= 0) // DELL OEM\n\t\t{\n\t\t\tasi.DiskVendorId = SSD_VENDOR_SANDISK_DELL;\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t\tasi.SmartKeyName = _T(\"SmartSanDiskDell\");\n\t\t}\n\t\telse if (asi.Model.Find(_T(\"SSD P4\")) >= 0)\n\t\t{\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\t\t\tasi.FlagLifeSanDiskUsbMemory = TRUE; // No Life Report\n\t\t\tasi.SmartKeyName = _T(\"SmartSanDisk\");\n\t\t}\n\t\telse if (asi.Model.Find(_T(\"iSSD P4\")) >= 0)\n\t\t{\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\t\t\tasi.SmartKeyName = _T(\"SmartSanDiskGb\");\n\t\t}\n\t\telse if (\n\t\t   asi.Model.Find(_T(\"SDSSDP\")) >= 0\n\t\t|| asi.Model.Find(_T(\"SDSSDRC\")) >= 0 \n\t\t)\n\t\t{\n\t\t\tasi.FlagLifeSanDisk0_1 = TRUE;\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\t\t\tasi.SmartKeyName = _T(\"SmartSanDisk\");\n\t\t}\n\t\telse if (\n\t\t   asi.Model.Find(_T(\"SSD U100\")) >= 0\n\t\t|| asi.Model.Find(_T(\"SSD U110\")) >= 0\n\t\t|| asi.Model.Find(_T(\"SSD i100\")) >= 0\n\t\t|| asi.Model.Find(_T(\"SSD i110\")) >= 0\n\t\t|| asi.Model.Find(_T(\"pSSD\")) >= 0\n\t\t\t)\n\t\t{\n\t\t\tasi.FlagLifeSanDiskUsbMemory = TRUE;\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\t\t\tasi.SmartKeyName = _T(\"SmartSanDisk\");\n\t\t}\n\t\telse if (\n\t\t\t// CloudSpeed ECO Gen II Eco SSD\n\t\t\tasi.Model.Find(_T(\"SDLF1CRR-\")) >= 0\n\t\t\t|| asi.Model.Find(_T(\"SDLF1DAR-\")) >= 0\n\t\t\t// CloudSpeed ECO Gen II Ultra SSD\n\t\t\t|| asi.Model.Find(_T(\"SDLF1CRM-\")) >= 0\n\t\t\t|| asi.Model.Find(_T(\"SDLF1DAM-\")) >= 0\n\t\t\t)\n\t\t{\n\t\t\tasi.DiskVendorId = SSD_VENDOR_SANDISK_CLOUD;\n\t\t\tasi.FlagLifeSanDiskCloud = TRUE;\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t\tasi.SmartKeyName = _T(\"SmartSanDiskCloud\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tasi.FlagLifeSanDisk1 = TRUE;\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t\tasi.SmartKeyName = _T(\"SmartSanDiskGb\");\n\t\t}\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdKingston(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif (asi.Model.Find(L\"KINGSTON\") >= 0)\n\t{\n\t\tif (asi.Model.Find(L\"SM2280\") >= 0 || asi.Model.Find(L\"SEDC400\") >= 0 || asi.Model.Find(L\"SKC310\") >= 0 || asi.Model.Find(L\"SHSS\") >= 0 || asi.Model.Find(L\"SUV300\") >= 0 || asi.Model.Find(L\"SKC400\") >= 0)\n\t\t{\n\t\t\tflagSmartType = TRUE;\n\t\t\tasi.SmartKeyName = _T(\"SmartKingston\");\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t}\n\t\telse if (asi.Model.Find(L\"SA400\") >= 0)\n\t\t{\n\t\t\tflagSmartType = TRUE;\n\t\t\t// https://github.com/hiyohiyo/CrystalDiskInfo/issues/162\n\t\t\tif (asi.FirmwareRev.Find(L\"03070009\") == 0)\n\t\t\t{\n\t\t\t\tasi.FlagLifeRawValue = FALSE;\n\t\t\t}\n\t\t\t// https://github.com/hiyohiyo/CrystalDiskInfo/issues/201\n\t\t\telse if (asi.FirmwareRev.Find(L\"SBFK62C3\") == 0)\n\t\t\t{\n\t\t\t//\tasi.FlagLifeNoReport = TRUE;\n\t\t\t\tasi.FlagLifeRawValue = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tasi.FlagLifeRawValue = TRUE;\n\t\t\t}\n\t\t\tasi.SmartKeyName = _T(\"SmartKingstonSA400\");\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t}\n\t\telse if (asi.Model.Find(L\"KC600\") >= 0)\n\t\t{\n\t\t\tflagSmartType = TRUE;\n\t\t\tasi.SmartKeyName = _T(\"SmartKingstonKC600\");\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_32MB;\n\t\t}\n\t\telse if (asi.Model.Find(L\"DC500\") >= 0)\n\t\t{\n\t\t\tflagSmartType = TRUE;\n\t\t\tasi.SmartKeyName = _T(\"SmartKingstonDC500\");\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t}\n\t\telse if (asi.Model.Find(L\"SUV400\") >= 0 || asi.Model.Find(L\"SUV500\") >= 0)\n\t\t{\n\t\t\tflagSmartType = TRUE;\n\t\t\tasi.SmartKeyName = _T(\"SmartKingstonSuv\");\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t}\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdCorsair(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif (asi.Model.Find(L\"Corsair\") == 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tif (asi.Model.Find(_T(\"Voyager GTX\")) >= 0)\n\t\t{\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_1MB;\n\t\t}\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdToshiba(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tCString modelUpper = asi.Model;\n\tmodelUpper.MakeUpper();\n\n\tif (modelUpper.Find(_T(\"TOSHIBA\")) >= 0 && asi.IsSsd)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tif (asi.Model.Find(_T(\"THNSNC\")) >= 0 || asi.Model.Find(_T(\"THNSNJ\")) >= 0 || asi.Model.Find(_T(\"THNSNK\")) >= 0\n\t\t||  asi.Model.Find(_T(\"KSG60\")) >= 0\n\t\t||  asi.Model.Find(_T(\"TL100\")) >= 0 || asi.Model.Find(_T(\"TR150\")) >= 0 || asi.Model.Find(_T(\"TR200\")) >= 0\n\t\t)\n\t\t{\n\t\t\t// TOSHIBA HG3\n\t\t\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1106;id=diskinfo#1106\n\t\t\t// TOSHIBA KSG60ZMV\n\t\t\t// https://crystalmark.info/board/c-board.cgi?cmd=one;no=2425;id=#2425\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_32MB;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t}\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdRealtek(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif (asi.Attribute[0].Id == 0x01\n\t\t&& asi.Attribute[1].Id == 0x05\n\t\t&& asi.Attribute[2].Id == 0x09\n\t\t&& asi.Attribute[3].Id == 0x0C\n\t\t&& asi.Attribute[4].Id == 0xA1\n\t\t&& asi.Attribute[5].Id == 0xA2\n\t\t&& asi.Attribute[6].Id == 0xA3\n\t\t&& asi.Attribute[7].Id == 0xA4\n\t\t&& asi.Attribute[8].Id == 0xA6\n\t\t&& asi.Attribute[9].Id == 0xA7\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\tasi.SmartKeyName = _T(\"SmartRealtek\");\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdSKhynix(ATA_SMART_INFO &asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tif (asi.Model.Find(_T(\"SK hynix\")) >= 0 || asi.Model.Find(_T(\"HFS\")) == 0 || asi.Model.Find(_T(\"SHG\")) == 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.SmartKeyName = _T(\"SmartSKhynix\");\n\t}\n\n\t// https://crystalmark.info/board/c-board.cgi?cmd=one;no=1772;id=#1772\n\tif (\n\t   (asi.Model.Find(_T(\"HFS\")) >= 0 && asi.Model.Find(_T(\"TND\")) >= 0) // SL300\n\t|| (asi.Model.Find(_T(\"HFS\")) >= 0 && asi.Model.Find(_T(\"MND\")) >= 0) // SC210\n\t) \n\t{\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\tasi.FlagLifeRawValueIncrement = TRUE;\n\t}\n\telse if (asi.Model.Find(_T(\"HFS\")) >= 0 && asi.Model.Find(_T(\"TNF\")) >= 0)\n\t{\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\tasi.FlagLifeRawValue = TRUE;\n\t}\n\telse if (asi.Model.Find(_T(\"SC311\")) >= 0 || asi.Model.Find(_T(\"SC401\")) >= 0)\n\t{\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\t\tasi.FlagLifeRawValue = TRUE;\n\t}\n\telse\n\t{\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdKioxia(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tif (asi.Model.Find(_T(\"KIOXIA\")) >= 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_32MB;\n\t\tasi.SmartKeyName = _T(\"SmartKioxia\");\n\t}\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdApacer(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tif (asi.Model.Find(_T(\"Apacer\")) == 0\n\t||  asi.Model.Find(_T(\"ZADAK\")) == 0\n\t||  asi.FirmwareRev.Find(L\"AP\") == 0 \n\t||  asi.FirmwareRev.Find(L\"SF\") == 0\n\t||  asi.FirmwareRev.Find(L\"PN\") == 0\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\t\tasi.FlagLifeRawValue = TRUE;\n\t\tasi.SmartKeyName = _T(\"SmartApacer\");\n\t}\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdYmtc(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tif (asi.Model.Find(_T(\"ZHITAI\")) >= 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\t\tasi.SmartKeyName = _T(\"SmartYmtc\");\n\t}\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdScy(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tif (asi.Model.Find(_T(\"SCY\")) == 0) // SCY S500\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_32MB;\n\t\tasi.SmartKeyName = _T(\"SmartScy\");\n\t}\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdRecadata(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tif (asi.Model.Find(_T(\"RECADATA\")) == 0) \n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdSiliconMotionCVC(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\tif (asi.Model.Find(_T(\"CVC-\")) >= 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdSiliconMotion(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif (   asi.Attribute[ 0].Id == 0x01\n\t\t&& asi.Attribute[ 1].Id == 0x05\n\t\t&& asi.Attribute[ 2].Id == 0x09\n\t\t&& asi.Attribute[ 3].Id == 0x0C\n\t\t&& asi.Attribute[ 4].Id == 0xA0\n\t\t&& asi.Attribute[ 5].Id == 0xA1\n\t\t&& asi.Attribute[ 6].Id == 0xA3\n\t\t&& asi.Attribute[ 7].Id == 0xA4\n\t\t&& asi.Attribute[ 8].Id == 0xA5\n\t\t&& asi.Attribute[ 9].Id == 0xA6\n\t\t&& asi.Attribute[10].Id == 0xA7\n\t\t&& asi.Attribute[11].Id == 0xA8\n\t\t&& asi.Attribute[12].Id == 0xA9\n\t\t&& asi.Attribute[13].Id == 0xAF\n\t\t&& asi.Attribute[14].Id == 0xB0\n\t\t&& asi.Attribute[15].Id == 0xB1\n\t\t&& asi.Attribute[16].Id == 0xB2\n\t\t&& asi.Attribute[17].Id == 0xB5\n\t\t&& asi.Attribute[18].Id == 0xB6\n\t\t&& asi.Attribute[19].Id == 0xC0\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\telse if ( // ADATA SX950 https://crystalmark.info/board/c-board.cgi?cmd=one;no=1819;id=\n\t\t   asi.Attribute[0].Id == 0x01\n\t\t&& asi.Attribute[1].Id == 0x05\n\t\t&& asi.Attribute[2].Id == 0x09\n\t\t&& asi.Attribute[3].Id == 0x0C\n\t\t&& asi.Attribute[4].Id == 0xA0\n\t\t&& asi.Attribute[5].Id == 0xA1\n\t\t&& asi.Attribute[6].Id == 0xA3\n\t\t&& asi.Attribute[7].Id == 0xA4\n\t\t&& asi.Attribute[8].Id == 0xA5\n\t\t&& asi.Attribute[9].Id == 0xA6\n\t\t&& asi.Attribute[10].Id == 0xA7\n\t\t&& asi.Attribute[11].Id == 0x94\n\t\t&& asi.Attribute[12].Id == 0x95\n\t\t&& asi.Attribute[13].Id == 0x96\n\t\t&& asi.Attribute[14].Id == 0x97\n\t\t&& asi.Attribute[15].Id == 0xA9\n\t\t&& asi.Attribute[16].Id == 0xB1\n\t\t&& asi.Attribute[17].Id == 0xB5\n\t\t&& asi.Attribute[18].Id == 0xB6\n\t\t&& asi.Attribute[19].Id == 0xBB\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\telse if (\n\t\t   asi.Attribute[0].Id == 0x01\n\t\t&& asi.Attribute[1].Id == 0x05\n\t\t&& asi.Attribute[2].Id == 0x09\n\t\t&& asi.Attribute[3].Id == 0x0C\n\t\t&& asi.Attribute[4].Id == 0x94\n\t\t&& asi.Attribute[5].Id == 0x95\n\t\t&& asi.Attribute[6].Id == 0x96\n\t\t&& asi.Attribute[7].Id == 0x97\n\t\t&& asi.Attribute[8].Id == 0x9F\n\t\t&& asi.Attribute[9].Id == 0xA0\n\t\t&& asi.Attribute[10].Id == 0xA1\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\telse if (\n\t\t   asi.Attribute[0].Id == 0x01\n\t\t&& asi.Attribute[1].Id == 0x05\n\t\t&& asi.Attribute[2].Id == 0x09\n\t\t&& asi.Attribute[3].Id == 0x0C\n\t\t&& asi.Attribute[4].Id == 0xA0\n\t\t&& asi.Attribute[5].Id == 0xA1\n\t\t&& asi.Attribute[6].Id == 0xA3\n\t\t&& asi.Attribute[7].Id == 0xA4\n\t\t&& asi.Attribute[8].Id == 0xA5\n\t\t&& asi.Attribute[9].Id == 0xA6\n\t\t&& asi.Attribute[10].Id == 0xA7\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\telse if (\n\t\t   asi.Attribute[0].Id == 0x01\n\t\t&& asi.Attribute[1].Id == 0x05\n\t\t&& asi.Attribute[2].Id == 0x09\n\t\t&& asi.Attribute[3].Id == 0x0C\n\t\t&& asi.Attribute[4].Id == 0xA0\n\t\t&& asi.Attribute[5].Id == 0xA1\n\t\t&& asi.Attribute[6].Id == 0xA3\n\t\t&& asi.Attribute[7].Id == 0x94\n\t\t&& asi.Attribute[8].Id == 0x95\n\t\t&& asi.Attribute[9].Id == 0x96\n\t\t&& asi.Attribute[10].Id == 0x97\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\t// Transcend\n\telse if (asi.Model.Find(_T(\"TS\")) == 0)\n\t{\n\t\tif ((asi.SmartReadData[400] == 'T' && asi.SmartReadData[401] == 'S') // Transcend\n\t\t||   asi.SmartReadData[400] == 'S' && asi.SmartReadData[401] == 'M') // Silicon Motion\n\t\t{\n\t\t\tflagSmartType = TRUE;\n\t\t}\n\t}\n\telse if (asi.Model.Find(_T(\"ADATA SX950\")) == 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\tif (flagSmartType)\n\t{\n\t\tif (asi.Model.Find(_T(\"SSD\")) == 0 && asi.FirmwareRev.Find(_T(\"FW\")) == 0) // for Goldenfir SSD\n\t\t{\n\t\t// Disabled for harmful to other products (v8.12.8)\n\t\t//\tasi.FlagLifeRawValueIncrement = TRUE;\n\t\t}\n\t\t// WINTEC\n\t\telse if (asi.Model.Find(_T(\"WT200\")) == 0 || asi.Model.Find(_T(\"WT100\")) == 0 || asi.Model.Find(_T(\"WT \")) == 0)\n\t\t{\n\n\t\t}\n\t\telse if (asi.Model.Find(_T(\"tecmiyo\")) == 0) // https://github.com/hiyohiyo/CrystalDiskInfo/issues/191\n\t\t{\n\n\t\t}\n\t\telse if (asi.Model.Find(_T(\"ADATA SU650\")) == 0 && asi.FirmwareRev.Find(_T(\"XD0R3C0A\")) == 0) // Twitter DM\n\t\t{\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tasi.FlagLifeRawValue = TRUE;\n\t\t}\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdPhison(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif (   asi.Attribute[ 0].Id == 0x01\n\t\t&& asi.Attribute[ 1].Id == 0x09\n\t\t&& asi.Attribute[ 2].Id == 0x0C\n\t\t&& asi.Attribute[ 3].Id == 0xA8\n\t\t&& asi.Attribute[ 4].Id == 0xAA\n\t\t&& asi.Attribute[ 5].Id == 0xAD\n\t\t&& asi.Attribute[ 6].Id == 0xC0\n\t\t&& asi.Attribute[ 7].Id == 0xC2 // with Temperature Sensor\n\t\t&& asi.Attribute[ 8].Id == 0xDA\n\t\t&& asi.Attribute[ 9].Id == 0xE7\n\t\t&& asi.Attribute[10].Id == 0xF1\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\telse if(\n\t\t   asi.Attribute[0].Id == 0x01\n\t\t&& asi.Attribute[1].Id == 0x09\n\t\t&& asi.Attribute[2].Id == 0x0C\n\t\t&& asi.Attribute[3].Id == 0xA8\n\t\t&& asi.Attribute[4].Id == 0xAA\n\t\t&& asi.Attribute[5].Id == 0xAD\n\t\t&& asi.Attribute[6].Id == 0xC0\n\t\t&& asi.Attribute[7].Id == 0xDA\n\t\t&& asi.Attribute[8].Id == 0xE7\n\t\t&& asi.Attribute[9].Id == 0xF1\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\tif (flagSmartType)\n\t{\n\t\tasi.FlagLifeRawValue = TRUE;\n\t\tif (asi.FirmwareRev.Find(L\"S9\") == 0)\n\t\t{\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_1MB;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t}\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdWdc(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif (asi.Model.Find(_T(\"WDC \")) == 0 || asi.Model.Find(_T(\"WD \")) == 0)\n\t{\n\t\tflagSmartType = TRUE;\n\n\t\tif (asi.Model.Find(L\"SA530\") >= 0)\n\t\t{\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_16MB;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\t}\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdSeagate(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif (   asi.Attribute[0].Id == 0x01\n\t\t&& asi.Attribute[1].Id == 0x05\n\t\t&& asi.Attribute[2].Id == 0x09\n\t\t&& asi.Attribute[3].Id == 0x0C\n\t\t&& asi.Attribute[4].Id == 0x64\n\t\t&& asi.Attribute[5].Id == 0x66\n\t\t&& asi.Attribute[6].Id == 0x67\n\t\t&& asi.Attribute[7].Id == 0xAA\n\t\t&& asi.Attribute[8].Id == 0xAB\n\t\t&& asi.Attribute[9].Id == 0xAC\n\t\t&& asi.Attribute[10].Id == 0xAD\n\t\t&& asi.Attribute[11].Id == 0xAE\n\t\t&& asi.Attribute[12].Id == 0xB1\n\t\t&& asi.Attribute[13].Id == 0xB7\n\t\t&& asi.Attribute[14].Id == 0xBB\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.SmartKeyName = _T(\"SmartSeagateIronWolf\");\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\tasi.DiskVendorId = SSD_VENDOR_SEAGATE;\n\t}\n\telse if (asi.Model.Find(L\"Seagate\") == 0\n\t\t|| (asi.Model.Find(L\"STT\") != 0 && asi.Model.Find(L\"ST\") == 0)\n\t\t|| (asi.Model.Find(L\"ZA\") == 0)\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tif (asi.Model.Find(L\"BarraCuda\") >= 0)\n\t\t{\n\t\t\tasi.SmartKeyName = _T(\"SmartSeagateBarraCuda\");\n\t\t\tasi.FlagLifeRawValue = TRUE;\n\t\t}\n\t\telse if (asi.Model.Find(L\"HM\") >= 0 || asi.Model.Find(L\"FP\") >= 0)\n\t\t{\n\t\t\tasi.SmartKeyName = _T(\"SmartSeagate\");\n\t\t\tasi.FlagLifeRawValue = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tasi.SmartKeyName = _T(\"SmartSeagate\");\n\t\t\tasi.FlagLifeRawValue = TRUE;\n\t\t}\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t\tasi.DiskVendorId = SSD_VENDOR_SEAGATE;\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdMarvell(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tif (   asi.Attribute[0].Id == 0x05\n\t\t&& asi.Attribute[1].Id == 0x09\n\t\t&& asi.Attribute[2].Id == 0x0C\n\t\t&& asi.Attribute[3].Id == 0xA1\n\t\t&& asi.Attribute[4].Id == 0xA4\n\t\t&& asi.Attribute[5].Id == 0xA5\n\t\t&& asi.Attribute[6].Id == 0xA6\n\t\t&& asi.Attribute[7].Id == 0xA7\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\telse if (asi.Attribute[0].Id == 0x05\n\t\t&& asi.Attribute[1].Id == 0x09\n\t\t&& asi.Attribute[2].Id == 0x0C\n\t\t&& asi.Attribute[3].Id == 0xA4\n\t\t&& asi.Attribute[4].Id == 0xA5\n\t\t&& asi.Attribute[5].Id == 0xA6\n\t\t&& asi.Attribute[6].Id == 0xA7\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\tif (flagSmartType)\n\t{\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t}\n\n\t// https://crystalmark.info/board/c-board.cgi?cmd=one;no=2476;id=#2476\n\tCString modelUpper = asi.Model;\n\tmodelUpper.MakeUpper();\n\n\tif (modelUpper.Find(L\"LEXAR\") == 0 && asi.FirmwareRev.Find(L\"SN\") == 0)\n\t{\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_32MB;\n\t}\n\n\t// https://crystalmark.info/board/c-board.cgi?cmd=one;no=2523;id=#2523\n\tif ((modelUpper.Find(L\"HANYE-Q55\") == 0))\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdMaxiotek(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tCString modelUpper = asi.Model;\n\tmodelUpper.MakeUpper();\n\n\tif (modelUpper.Find(_T(\"MAXIO\")) == 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t}\n\telse if (modelUpper.Find(_T(\"CUSO C5S-EVO\")) == 0)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\t}\n\t// https://crystalmark.info/board/c-board.cgi?cmd=one;no=2523;id=#2523\n\telse if (modelUpper.Find(L\"HANYE-Q55\") == 0\n\t\t&& asi.Attribute[0].Id == 0x05\n\t\t&& asi.Attribute[1].Id == 0x09\n\t\t&& asi.Attribute[2].Id == 0x0C\n\t\t&& asi.Attribute[3].Id == 0xA4\n\t\t&& asi.Attribute[4].Id == 0xA5\n\t\t&& asi.Attribute[5].Id == 0xA6\n\t\t&& asi.Attribute[6].Id == 0xA7\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\telse if (\n\t\t   asi.Attribute[0].Id == 0x05\n\t\t&& asi.Attribute[1].Id == 0x09\n\t\t&& asi.Attribute[2].Id == 0x0C\n\t\t&& asi.Attribute[3].Id == 0xA7\n\t\t&& asi.Attribute[4].Id == 0xA8\n\t\t&& asi.Attribute[5].Id == 0xA9\n\t\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t}\n\n\treturn flagSmartType;\n}\n\nBOOL CAtaSmart::IsSsdAdataIndustrial(ATA_SMART_INFO& asi)\n{\n\tBOOL flagSmartType = FALSE;\n\n\tCString modelUpper = asi.Model;\n\tmodelUpper.MakeUpper();\n\n\tif (modelUpper.Find(_T(\"ADATA_IM2S\")) == 0\n\t||  modelUpper.Find(_T(\"ADATA_IMSS\")) == 0\n\t||  modelUpper.Find(_T(\"ADATA_ISSS\")) == 0\n\t||\tmodelUpper.Find(_T(\"IM2S\")) == 0\n\t||  modelUpper.Find(_T(\"IMSS\")) == 0\n\t||  modelUpper.Find(_T(\"ISSS\")) == 0\n\t)\n\t{\n\t\tflagSmartType = TRUE;\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\t}\n\n\treturn flagSmartType;\n}\n\n\nBOOL CAtaSmart::IsSsdGeneral(ATA_SMART_INFO& asi)\n{\n\tasi.HostReadsWritesUnit = HOST_READS_WRITES_UNKNOWN;\n\n\tif (\n\t\tasi.Model.Find(L\"ADATA SP580\") == 0\n\t)\n\t{\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_512B;\n\t}\n\telse if (\n\t   asi.Model.Find(L\"LITEON IT LMT\") == 0\n\t)\n\t{\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_32MB;\n\t}\n\telse if (\n\t   asi.Model.Find(L\"LITEON S960\") == 0\t\n\t)\n\t{\n\t\tasi.HostReadsWritesUnit = HOST_READS_WRITES_GB;\n\t}\n\n\treturn asi.IsSsd;\n}\n\nBOOL CAtaSmart::CheckSmartAttributeCorrect(ATA_SMART_INFO* asi1, ATA_SMART_INFO* asi2)\n{\n\tif(asi1->AttributeCount != asi2->AttributeCount)\n\t{\n\t\tDebugPrint(_T(\"asi1->AttributeCount != asi2->AttributeCount\"));\n\t\treturn FALSE;\n\t}\n\t\n\tfor(DWORD i = 0; i < asi1->AttributeCount; i++)\n\t{\n\t\tif(asi1->Attribute[i].Id != asi2->Attribute[i].Id)\n\t\t{\n\t\t\tDebugPrint(_T(\"asi1->Attribute[i].Id != asi2->Attribute[i].Id\"));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE; // Correct\n}\n\nVOID CAtaSmart::WakeUp(INT physicalDriveId)\n{\n\tHANDLE hFile = INVALID_HANDLE_VALUE;\n\tCString\tstrDevice;\n\tif(physicalDriveId < 0)\n\t{\n\t\treturn ;\n\t}\n\tif (FlagNoWakeUp)  return;// +M 20211216\n\n\tstrDevice.Format(_T(\"\\\\\\\\.\\\\PhysicalDrive%d\"), physicalDriveId);\n\thFile = ::CreateFile(strDevice, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);\n\tif(hFile != INVALID_HANDLE_VALUE)\n\t{\n\t\tBYTE buf[512] = {};\n\t\tconst DWORD bufSize = 512;\n\t\tDWORD readSize = 0;\n\t\tSetFilePointer(hFile, 0, NULL, FILE_BEGIN);\n\t\t(void)ReadFile(hFile, buf, bufSize, &readSize, NULL);\n\t\tsafeCloseHandle(hFile);\n\t}\n}\n\nBOOL CAtaSmart::GetDiskInfo(INT physicalDriveId, INT scsiPort, INT scsiTargetId,\n\tINTERFACE_TYPE interfaceType, COMMAND_TYPE commandType, VENDOR_ID usbVendorId, DWORD productId, INT scsiBus, DWORD siliconImageType, BOOL FlagNvidiaController, BOOL FlagMarvellController, CString pnpDeviceId,\n\tBOOL flagNVMe, BOOL flagUsap\n\t)\n{\n\tDebugPrint(_T(\"GetDiskInfo\"));\n\tif(vars.GetCount() > MAX_DISK)\n\t{\n\t\tDebugPrint(_T(\"GetDiskInfo - FALSE0\"));\n\t\treturn FALSE;\n\t}\n\t// Check overlap\n\tfor(int i = 0; i < vars.GetCount(); i++)\n\t{\n\t\tif(physicalDriveId >= 0 && vars[i].PhysicalDriveId == physicalDriveId)\n\t\t{\n\t\t\tDebugPrint(_T(\"GetDiskInfo - FALSE1\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\t/*\n\t\telse if(scsiPort >= 0 && scsiTargetId >= 0\n\t\t\t&& vars[i].ScsiPort == scsiPort && vars[i].ScsiTargetId == scsiTargetId\n\t\t\t&& vars[i].ScsiBus == scsiBus\n\t\t\t)\n\t\t{\n\t\t\tDebugPrint(_T(\"GetDiskInfo - FALSE2\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\t*/\n\t}\n\n\tIDENTIFY_DEVICE identify = {};\n\tDWORD diskSize = 0;\n\n\tCString debug;\n\tif(interfaceType == INTERFACE_TYPE_UNKNOWN || interfaceType == INTERFACE_TYPE_PATA || interfaceType == INTERFACE_TYPE_SATA)\n\t{\n\t\tif(siliconImageType)\n\t\t{\n\t\t\tWakeUp(physicalDriveId);\n\t\t\tdebug.Format(_T(\"physicalDriveId=%d, scsiPort=%d, scsiBus=%d, scsiTargetId=%d\"), physicalDriveId, scsiPort, scsiBus, scsiTargetId);\n\t\t\tDebugPrint(debug);\n\t\t\tif(DoIdentifyDeviceSi(physicalDriveId, scsiPort, scsiBus, siliconImageType, &identify))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - Si\"));\n\t\t\t\tif(AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_SILICON_IMAGE, &identify, siliconImageType, NULL, pnpDeviceId))\n\t\t\t\t{\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif(physicalDriveId >= 0)\n\t\t{\n\t\t\tdebug.Format(_T(\"DoIdentifyDevicePd(%d, 0xA0) - 1\"), physicalDriveId);\n\t\t\tDebugPrint(debug);\n\t\t\tif(! DoIdentifyDevicePd(physicalDriveId, 0xA0, &identify))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"WakeUp(%d)\"), physicalDriveId);\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tWakeUp(physicalDriveId);\n\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDevicePd(%d, 0xA0) - 2\"), physicalDriveId);\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif(! DoIdentifyDevicePd(physicalDriveId, 0xA0, &identify))\n\t\t\t\t{\n\t\t\t\t\tdebug.Format(_T(\"DoIdentifyDevicePd(%d, 0xB0) - 3\"), physicalDriveId);\n\t\t\t\t\tDebugPrint(debug);\n\n\t\t\t\t\tif(! DoIdentifyDevicePd(physicalDriveId, 0xB0, &identify))\n\t\t\t\t\t{\n\t\t\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceScsi(%d, %d) - 4\"), scsiPort, scsiTargetId);\n\t\t\t\t\t\tDebugPrint(debug);\n\n\t\t\t\t\t\tif ((FlagNvidiaController || FlagMarvellController || IsAdvancedDiskSearch) && scsiPort >= 0 && scsiTargetId >= 0 && DoIdentifyDeviceScsi(scsiPort, scsiTargetId, &identify))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdebug.Format(_T(\"AddDisk(%d, %d, %d) - 5\"), physicalDriveId, scsiPort, scsiTargetId);\n\t\t\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\t\t\treturn AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_SCSI_MINIPORT, &identify, siliconImageType, NULL, pnpDeviceId);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug.Format(_T(\"AddDisk(%d, %d, %d) - 6\"), physicalDriveId, scsiPort, scsiTargetId);\n\t\t\tDebugPrint(debug);\n\t\t\treturn AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_PHYSICAL_DRIVE, &identify, siliconImageType, NULL, pnpDeviceId);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdebug.Format(_T(\"DoIdentifyDeviceScsi(%d, %d) - 7\"), scsiPort, scsiTargetId);\n\t\t\tDebugPrint(debug);\n\t\t\tif(scsiPort >= 0 && scsiTargetId >= 0 && DoIdentifyDeviceScsi(scsiPort, scsiTargetId, &identify))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"AddDisk(%d, %d, %d) - 8\"), physicalDriveId, scsiPort, scsiTargetId);\n\t\t\t\tDebugPrint(debug);\n\t\t\t\treturn AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_SCSI_MINIPORT, &identify, siliconImageType, NULL, pnpDeviceId);\n\t\t\t}\n\t\t}\n\t}\n\telse if (interfaceType == INTERFACE_TYPE_NVME)\n\t{\n\n\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeStorageQuery\"));\n\t\tDebugPrint(debug);\n\t\tif (m_bNVMeStorageQuery && DoIdentifyDeviceNVMeStorageQuery(physicalDriveId, scsiPort, scsiTargetId, &identify, &diskSize))\n\t\t{\n\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_STORAGE_QUERY\"));\n\t\t\tDebugPrint(debug);\n\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_STORAGE_QUERY, &identify)){return TRUE; }\n\t\t}\n\n\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeIntelVroc\"));\n\t\tDebugPrint(debug);\n\t\tif (DoIdentifyDeviceNVMeIntelVroc(physicalDriveId, scsiPort, scsiTargetId, &identify, &diskSize))\n\t\t{\n\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_INTEL_VROC\"));\n\t\t\tDebugPrint(debug);\n\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_INTEL_VROC, &identify, &diskSize)) { return TRUE; }\n\t\t}\n\t\t\n\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeIntelRst\"));\n\t\tDebugPrint(debug);\n\t\tif (DoIdentifyDeviceNVMeIntelRst(physicalDriveId, scsiPort, scsiTargetId, &identify, &diskSize))\n\t\t{\n\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_INTEL_RST\"));\n\t\t\tDebugPrint(debug);\n\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_INTEL_RST, &identify, &diskSize)) { return TRUE; }\n\t\t}\n\n\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeSamsung\"));\n\t\tDebugPrint(debug);\n\t\tif (DoIdentifyDeviceNVMeSamsung(physicalDriveId, scsiPort, scsiTargetId, &identify))\n\t\t{\n\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_SAMSUNG\"));\n\t\t\tDebugPrint(debug);\n\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_SAMSUNG, &identify)){return TRUE; }\n\t\t}\n\n\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeIntel\"));\n\t\tDebugPrint(debug);\n\n\t\tif (DoIdentifyDeviceNVMeIntel(physicalDriveId, scsiPort, scsiTargetId, &identify, &diskSize))\n\t\t{\n\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_INTEL\"));\n\t\t\tDebugPrint(debug);\n\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_INTEL, &identify)){return TRUE; }\n\t\t}\n\t}\n\t\n\tif(physicalDriveId >= 0)\n\t{\n\t\t/** DEBUG\n\t\tif(TRUE)\n\t\t{\n\t\t\tDoIdentifyDeviceSat(physicalDriveId, &identify, CMD_TYPE_DEBUG);\n\t\t}\n\t\telse\n\t\t*/\n\n\t\tWakeUp(physicalDriveId);\n\n\t\tif(interfaceType == INTERFACE_TYPE_USB && usbVendorId == USB_VENDOR_LOGITEC && productId == 0x00D9)\n\t\t{\n\t\t\tDebugPrint(_T(\"FALSE: usbVendorId == USB_VENDOR_LOGITEC && productId == 0x00D9\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\t// 8.8.9 https://twitter.com/katmai_/status/1309815268315602945?s=20\n\t\tif (interfaceType == INTERFACE_TYPE_USB && usbVendorId == 0x05E3 && productId == 0x0702)\n\t\t{\n\t\t\tDebugPrint(_T(\"FALSE: usbVendorId == 0x05E3 && productId == 0x0702\"));\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (interfaceType == INTERFACE_TYPE_USB && usbVendorId == USB_VENDOR_JMICRON)\n\t\t{\n\t\t\tDebugPrint(_T(\"usbVendorId == USB_VENDOR_JMICRON\"));\n\t\t\tif (FlagUsbJmicron && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_JMICRON))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB0A\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_JMICRON, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\tif (FlagUsbSat && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_SAT))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB1A\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_SAT, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\tif (FlagUsbJmicron && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_JMICRON))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB0B\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_JMICRON, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\tif (FlagUsbSat && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_SAT))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB1B\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_SAT, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\tif (FlagUsbNVMeJMicron3 && DoIdentifyDeviceNVMeJMicron(physicalDriveId, scsiPort, scsiTargetId, &identify, FALSE))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeJMicron\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_JMICRON\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_JMICRON, &identify)){return TRUE; }\n\t\t\t}\n\t\t\tif (FlagUsbNVMeJMicron && DoIdentifyDeviceNVMeJMicron(physicalDriveId, scsiPort, scsiTargetId, &identify, TRUE))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeJMicron: USB2.0 mode\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_JMICRON\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_JMICRON, &identify)) { return TRUE; }\n\t\t\t}\n\t\t\t\n\t\t\tDebugPrint(_T(\"FALSE - USB0\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\t\n\t\tif (interfaceType == INTERFACE_TYPE_USB && usbVendorId == USB_VENDOR_REALTEK)\n\t\t{\n\t\t\tif (FlagUsbNVMeRealtek && DoIdentifyDeviceNVMeRealtek(physicalDriveId, scsiPort, scsiTargetId, &identify))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeRealtek\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_REALTEK\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tBOOL flag = AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_REALTEK, &identify);\n\t\t\t\t\n\t\t\t\tif (FlagUsbRealtek9220DP && RealtekRAIDMode(physicalDriveId, scsiPort, scsiTargetId))\n\t\t\t\t{\n\t\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeRealtek 2\"));\n\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\tif (RealtekSwitchMode(physicalDriveId, scsiPort, scsiTargetId, 1, 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (DoIdentifyDeviceNVMeRealtek(physicalDriveId, scsiPort, scsiTargetId, &identify))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_REALTEK9220DP\"));\n\t\t\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\t\t\tflag = AddDiskNVMe(physicalDriveId, (scsiPort + 1), (scsiTargetId + 1), scsiBus + 1, (BYTE)scsiTargetId, CMD_TYPE_NVME_REALTEK9220DP, &identify);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tRealtekSwitchMode(physicalDriveId, scsiPort, scsiTargetId, 1, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag == TRUE) { return TRUE; }\n\t\t\t}\n\t\t}\n\n\t\t// 2009/7/30, 2009/8/21\n\t\t// IO-DATA HDPS-U  https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=2918;id=report#2918\n\t\t//                 https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=2978;id=report#2978\n\t\t//                 https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=2985;id=report#2985\n\t\t// 2012/3/20\n\t\t// StoreJet         http://btmn.jp/2012/02/25/storejet-320gb-crystal-diskinfo/\n\t\tif(interfaceType == INTERFACE_TYPE_USB && (usbVendorId == USB_VENDOR_IO_DATA && productId == 0x0122))\n\t\t{\n\t\t\tDebugPrint(_T(\"(usbVendorId == USB_VENDOR_IO_DATA && productId == 0x0122)\"));\n\t\t\tif(FlagUsbJmicron && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify,  CMD_TYPE_JMICRON))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB0A\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0,  CMD_TYPE_JMICRON, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbSat && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_SAT))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB1A\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_SAT, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbJmicron && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify,  CMD_TYPE_JMICRON))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB0B\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0,  CMD_TYPE_JMICRON, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbSat && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_SAT))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB1B\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_SAT, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\tDebugPrint(_T(\"FALSE - USB0\"));\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif(interfaceType == INTERFACE_TYPE_USB && usbVendorId == USB_VENDOR_IO_DATA)\n\t\t{\n\t\t\tDebugPrint(_T(\"usbVendorId == USB_VENDOR_IO_DATA\"));\n\t\t\tif(FlagUsbIodata && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_IO_DATA))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB2\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_IO_DATA, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbIodata && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_IO_DATA))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB3\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_IO_DATA, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t}\n\n\t\tif(interfaceType == INTERFACE_TYPE_USB && usbVendorId == USB_VENDOR_SUNPLUS)\n\t\t{\n\t\t\tDebugPrint(_T(\"usbVendorId == USB_VENDOR_SUNPLUS\"));\n\t\t\tif(FlagUsbSunplus && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_SUNPLUS))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB4\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_SUNPLUS, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbSunplus && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_SUNPLUS))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB5\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_SUNPLUS, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(interfaceType == INTERFACE_TYPE_USB && usbVendorId == USB_VENDOR_CYPRESS)\n\t\t{\n\t\t\tDebugPrint(_T(\"usbVendorId == USB_VENDOR_CYPRESS\"));\n\t\t\tif(FlagUsbCypress && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_CYPRESS))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB6\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_CYPRESS, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbCypress && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_CYPRESS))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB7\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_CYPRESS, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(interfaceType == INTERFACE_TYPE_USB && \n\t\t\t(usbVendorId == USB_VENDOR_INITIO || usbVendorId == USB_VENDOR_OXFORD)\n\t\t\t)\n\t\t{\n\t\t\tDebugPrint(_T(\"usbVendorId == USB_VENDOR_INITIO || usbVendorId == USB_VENDOR_OXFORD\"));\n\n\t\t\tif(FlagUsbSat && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_SAT))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB8\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_SAT, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t\telse if(FlagUsbSat && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_SAT))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB9\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_SAT, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE; }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (interfaceType == INTERFACE_TYPE_USB && flagNVMe)\n\t\t{\n\t\t\tif (FlagUsbNVMeJMicron3 && DoIdentifyDeviceNVMeJMicron(physicalDriveId, scsiPort, scsiTargetId, &identify, FALSE))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeJMicron\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_JMICRON\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_JMICRON, &identify)) { return TRUE; }\n\t\t\t}\n\t\t\tif (FlagUsbNVMeJMicron && DoIdentifyDeviceNVMeJMicron(physicalDriveId, scsiPort, scsiTargetId, &identify, TRUE))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeJMicron: USB2.0 mode\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_JMICRON\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_JMICRON, &identify)) { return TRUE; }\n\t\t\t}\n\t\t\tif (FlagUsbNVMeASMedia && DoIdentifyDeviceNVMeASMedia(physicalDriveId, scsiPort, scsiTargetId, &identify))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeASMedia\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_ASMEDIA\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_ASMEDIA, &identify)) { return TRUE; }\n\t\t\t}\n\t\t\tif (FlagUsbNVMeRealtek && DoIdentifyDeviceNVMeRealtek(physicalDriveId, scsiPort, scsiTargetId, &identify))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeRealtek\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_REALTEK\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tBOOL flag = AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_REALTEK, &identify);\n\t\t\t\t\n\t\t\t\tif (FlagUsbRealtek9220DP && RealtekRAIDMode(physicalDriveId, scsiPort, scsiTargetId))\n\t\t\t\t{\n\t\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeRealtek 2\"));\n\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\tif (RealtekSwitchMode(physicalDriveId, scsiPort, scsiTargetId, 1, 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (DoIdentifyDeviceNVMeRealtek(physicalDriveId, scsiPort, scsiTargetId, &identify))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_REALTEK9220DP\"));\n\t\t\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\t\t\tflag = AddDiskNVMe(physicalDriveId, (scsiPort + 1), (scsiTargetId + 1), scsiBus + 1, (BYTE)scsiTargetId, CMD_TYPE_NVME_REALTEK9220DP, &identify);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tRealtekSwitchMode(physicalDriveId, scsiPort, scsiTargetId, 1, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag == TRUE) { return TRUE; }\n\t\t\t}\n\t\t}\n\n\t\tif(1)\n\t\t{\n\t\t\tDebugPrint(_T(\"else (USB-HDD)\"));\n\t\t\t/*\n\t\t\tif (DoIdentifyDeviceNVMeASMedia(physicalDriveId, scsiPort, scsiTargetId, &identify))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeASMedia\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_ASMEDIA\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\treturn AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, scsiTargetId, CMD_TYPE_NVME_ASMEDIA, &identify);\n\t\t\t}\n\t\t\t*/\n\t\t\tCString debug;\n\t\t\tdebug.Format(L\"FlagUsbSat=%d\", FlagUsbSat);\n\t\t\tDebugPrint(debug);\n\t\t\tif(FlagUsbSat && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_SAT))\n\t\t\t{\n\t\t\t\tBOOL flag = FALSE;\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB10\"));\n\t\t\t\tflag = AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_SAT, &identify, siliconImageType, NULL, pnpDeviceId);\n\n\t\t\t\t// for Buffalo SSD-SCTU3A\n\t\t\t\t// https://x.com/openlibsys/status/1830947904993071271\n\t\t\t\tCString cstr;\n\t\t\t\tcstr = identify.A.Model;\n\t\t\t\tif (flag && cstr.Find(L\"SSD-SCTU3A\") == 0 && DoIdentifyDeviceNVMeASMedia(physicalDriveId, scsiPort, scsiTargetId, &identify))\n\t\t\t\t{\n\t\t\t\t\tvars.RemoveAt(vars.GetCount() - 1);\n\t\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeASMedia\"));\n\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_ASMEDIA\"));\n\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_ASMEDIA, &identify)) { return TRUE; }\n\t\t\t\t}\n\n\t\t\t\t// for ASM1352R \n\t\t\t\tif (FlagUsbASM1352R && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_SAT_ASM1352R))\n\t\t\t\t{\n\t\t\t\t\tDebugPrint(_T(\"AddDisk - ASM1352R\"));\n\t\t\t\t\tflag = AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_SAT_ASM1352R, &identify, siliconImageType, NULL, pnpDeviceId);\n\t\t\t\t}\n\n\t\t\t\tif (FlagUsbRealtek9220DP && isRealtekProduct(physicalDriveId, scsiPort, scsiTargetId) && RealtekRAIDMode(physicalDriveId, scsiPort, scsiTargetId))\n\t\t\t\t{\n\t\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceSat CMD_TYPE_SAT_REALTEK9220DP\"));\n\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\tif (RealtekSwitchMode(physicalDriveId, scsiPort, scsiTargetId, 1, 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_SAT_REALTEK9220DP))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDebugPrint(_T(\"AddDisk - CMD_TYPE_SAT_REALTEK9220DP\"));\n\t\t\t\t\t\t\tflag = AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_SAT_REALTEK9220DP, &identify, siliconImageType, NULL, pnpDeviceId);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tRealtekSwitchMode(physicalDriveId, scsiPort, scsiTargetId, 1, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (flag == TRUE) { return TRUE; }\n\t\t\t}\n\t\t\t\n\t\t\tif(FlagUsbJmicron && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_JMICRON))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB11\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_JMICRON, &identify, siliconImageType, NULL, pnpDeviceId)){return TRUE;}\n\t\t\t}\n\t\t\tif(FlagUsbSunplus && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_SUNPLUS))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB12\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_SUNPLUS, &identify, siliconImageType, NULL, pnpDeviceId)) { return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbCypress && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_CYPRESS))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB13\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_CYPRESS, &identify, siliconImageType, NULL, pnpDeviceId)) { return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbLogitec && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_LOGITEC))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB14\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_LOGITEC, &identify, siliconImageType, NULL, pnpDeviceId)) { return TRUE; }\n\t\t\t}\n\t\t\tif (FlagUsbProlific && DoIdentifyDeviceSat(physicalDriveId, 0xA0, &identify, CMD_TYPE_PROLIFIC))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB14\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xA0, CMD_TYPE_PROLIFIC, &identify, siliconImageType, NULL, pnpDeviceId)) { return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbSat && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_SAT))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB15\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_SAT, &identify, siliconImageType, NULL, pnpDeviceId)) { return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbJmicron && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_JMICRON))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB16\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_JMICRON, &identify, siliconImageType, NULL, pnpDeviceId)) { return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbSunplus && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_SUNPLUS))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB17\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_SUNPLUS, &identify, siliconImageType, NULL, pnpDeviceId)) { return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbCypress && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_CYPRESS))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB18\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_CYPRESS, &identify, siliconImageType, NULL, pnpDeviceId)) { return TRUE; }\n\t\t\t}\n\t\t\tif(FlagUsbLogitec && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_LOGITEC))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB19\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_LOGITEC, &identify, siliconImageType, NULL, pnpDeviceId)) { return TRUE; }\n\t\t\t}\n\t\t\tif (FlagUsbProlific && DoIdentifyDeviceSat(physicalDriveId, 0xB0, &identify, CMD_TYPE_PROLIFIC))\n\t\t\t{\n\t\t\t\tDebugPrint(_T(\"AddDisk - USB20\"));\n\t\t\t\tif (AddDisk(physicalDriveId, scsiPort, scsiTargetId, scsiBus, 0xB0, CMD_TYPE_PROLIFIC, &identify, siliconImageType, NULL, pnpDeviceId)) { return TRUE; }\n\t\t\t}\n\t\t\t// USB-NVMe\n\t\t\tif (FlagUsbNVMeJMicron3 && DoIdentifyDeviceNVMeJMicron(physicalDriveId, scsiPort, scsiTargetId, &identify, FALSE))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeJMicron\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_JMICRON\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_JMICRON, &identify)) { return TRUE; }\n\t\t\t}\n\t\t\tif (FlagUsbNVMeJMicron && DoIdentifyDeviceNVMeJMicron(physicalDriveId, scsiPort, scsiTargetId, &identify, TRUE))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeJMicron: USB2.0 mode\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_JMICRON\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_JMICRON, &identify)) { return TRUE; }\n\t\t\t}\n\t\t\t// USB-NVMe\n\t\t\tif (FlagUsbNVMeASMedia && DoIdentifyDeviceNVMeASMedia(physicalDriveId, scsiPort, scsiTargetId, &identify))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeASMedia\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_ASMEDIA\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tif (AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_ASMEDIA, &identify)) { return TRUE; }\n\t\t\t}\n\t\t\t// USB-NVMe\n\t\t\tif (FlagUsbNVMeRealtek && DoIdentifyDeviceNVMeRealtek(physicalDriveId, scsiPort, scsiTargetId, &identify))\n\t\t\t{\n\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeRealtek\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_REALTEK\"));\n\t\t\t\tDebugPrint(debug);\n\t\t\t\tBOOL flag = AddDiskNVMe(physicalDriveId, scsiPort, scsiTargetId, scsiBus, (BYTE)scsiTargetId, CMD_TYPE_NVME_REALTEK, &identify);\n\t\t\t\t\n\t\t\t\tif (FlagUsbRealtek9220DP && RealtekRAIDMode(physicalDriveId, scsiPort, scsiTargetId))\n\t\t\t\t{\n\t\t\t\t\tdebug.Format(_T(\"DoIdentifyDeviceNVMeRealtek 2\"));\n\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\tif (RealtekSwitchMode(physicalDriveId, scsiPort, scsiTargetId, 1, 1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif (DoIdentifyDeviceNVMeRealtek(physicalDriveId, scsiPort, scsiTargetId, &identify))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdebug.Format(_T(\"AddDiskNVMe - CMD_TYPE_NVME_REALTEK9220DP\"));\n\t\t\t\t\t\t\tDebugPrint(debug);\n\t\t\t\t\t\t\tflag = AddDiskNVMe(physicalDriveId, (scsiPort + 1), (scsiTargetId + 1), scsiBus + 1, (BYTE)scsiTargetId, CMD_TYPE_NVME_REALTEK9220DP, &identify);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tRealtekSwitchMode(physicalDriveId, scsiPort, scsiTargetId, 1, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag == TRUE) { return TRUE; }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\n/*---------------------------------------------------------------------------*/\n// \\\\\\\\.\\\\PhysicalDriveX\n/*---------------------------------------------------------------------------*/\nHANDLE CAtaSmart::GetIoCtrlHandle(INT/*BYTE*/ index)\n{\n\tCString\tstrDevice;\n\tstrDevice.Format(_T(\"\\\\\\\\.\\\\PhysicalDrive%d\"), index);\n\n\treturn ::CreateFile(strDevice, GENERIC_READ | GENERIC_WRITE, \n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE,\n\t\tNULL, OPEN_EXISTING, 0, NULL);\n}\n\nBOOL CAtaSmart::DoIdentifyDevicePd(INT physicalDriveId, BYTE target, IDENTIFY_DEVICE* data)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tCString cstr;\n\n\tIDENTIFY_DEVICE_OUTDATA\tsendCmdOutParam = {};\n\tSENDCMDINPARAMS\tsendCmd = {};\n\n\tif(data == NULL)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\tif(m_bAtaPassThrough && m_bAtaPassThroughSmart)\n\t{\n\t\tDebugPrint(_T(\"SendAtaCommandPd - IDENTIFY_DEVICE (ATA_PASS_THROUGH)\"));\n\t\tbRet = SendAtaCommandPd(physicalDriveId, target, 0xEC, 0x00, 0x00, (PBYTE)data, sizeof(ATA_IDENTIFY_DEVICE));\n\t\tcstr = data->A.Model;\n\t}\n\n\tif(bRet == FALSE || cstr.IsEmpty())\n\t{\n\t\t::ZeroMemory(data, sizeof(ATA_IDENTIFY_DEVICE));\n\t\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\t\tif(! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\treturn\tFALSE;\n\t\t}\n\t\t//::ZeroMemory(&sendCmdOutParam, sizeof(IDENTIFY_DEVICE_OUTDATA));\n\t\t//::ZeroMemory(&sendCmd, sizeof(SENDCMDINPARAMS));\n\n\t\tsendCmd.irDriveRegs.bCommandReg\t\t\t= ID_CMD;\n\t\tsendCmd.irDriveRegs.bSectorCountReg\t\t= 1;\n\t\tsendCmd.irDriveRegs.bSectorNumberReg\t= 1;\n\t\tsendCmd.irDriveRegs.bDriveHeadReg\t\t= target;\n\t\tsendCmd.cBufferSize\t\t\t\t\t\t= IDENTIFY_BUFFER_SIZE;\n\n\t\tDebugPrint(_T(\"SendAtaCommandPd - IDENTIFY_DEVICE\"));\n\t\tbRet = ::DeviceIoControl(hIoCtrl, DFP_RECEIVE_DRIVE_DATA, \n\t\t\t&sendCmd, sizeof(SENDCMDINPARAMS),\n\t\t\t&sendCmdOutParam, sizeof(IDENTIFY_DEVICE_OUTDATA),\n\t\t\t&dwReturned, NULL);\n\n\t\tsafeCloseHandle(hIoCtrl);\n\t\t\n\t\tif(bRet == FALSE || dwReturned != sizeof(IDENTIFY_DEVICE_OUTDATA))\n\t\t{\n\t\t\treturn\tFALSE;\n\t\t}\n\n\t\tmemcpy_s(data, sizeof(ATA_IDENTIFY_DEVICE), sendCmdOutParam.SendCmdOutParam.bBuffer, sizeof(ATA_IDENTIFY_DEVICE));\n\t}\n\n\treturn\tTRUE;\n}\n\nBOOL CAtaSmart::GetSmartAttributePd(INT physicalDriveId, BYTE target, ATA_SMART_INFO* asi)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\n\tSMART_READ_DATA_OUTDATA\tsendCmdOutParam = {};\n\tSENDCMDINPARAMS\tsendCmd = {};\n\n\tif(m_bAtaPassThrough && m_bAtaPassThroughSmart)\n\t{\n\t\tDebugPrint(_T(\"SendAtaCommandPd - SMART_READ_DATA (ATA_PASS_THROUGH)\"));\n\t\tbRet = SendAtaCommandPd(physicalDriveId, target, SMART_CMD, READ_ATTRIBUTES, 0x00, \n\t\t(PBYTE)&(asi->SmartReadData), sizeof(asi->SmartReadData));\n\t}\n\n\tif(! bRet)\n\t{\n\t\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\t\tif(! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\treturn\tFALSE;\n\t\t}\n\n\t\t//::ZeroMemory(&sendCmdOutParam, sizeof(SMART_READ_DATA_OUTDATA));\n\t\t//::ZeroMemory(&sendCmd, sizeof(SENDCMDINPARAMS));\n\n\t\tsendCmd.irDriveRegs.bFeaturesReg\t= READ_ATTRIBUTES;\n\t\tsendCmd.irDriveRegs.bSectorCountReg = 1;\n\t\tsendCmd.irDriveRegs.bSectorNumberReg= 1;\n\t\tsendCmd.irDriveRegs.bCylLowReg\t\t= SMART_CYL_LOW;\n\t\tsendCmd.irDriveRegs.bCylHighReg\t\t= SMART_CYL_HI;\n\t\tsendCmd.irDriveRegs.bDriveHeadReg\t= target;\n\t\tsendCmd.irDriveRegs.bCommandReg\t\t= SMART_CMD;\n\t\tsendCmd.cBufferSize\t\t\t\t\t= READ_ATTRIBUTE_BUFFER_SIZE;\n\n\t\tDebugPrint(_T(\"SendAtaCommandPd - SMART_READ_DATA\"));\n\t\tbRet = ::DeviceIoControl(hIoCtrl, DFP_RECEIVE_DRIVE_DATA, \n\t\t\t&sendCmd, sizeof(SENDCMDINPARAMS),\n\t\t\t&sendCmdOutParam, sizeof(SMART_READ_DATA_OUTDATA),\n\t\t\t&dwReturned, NULL);\n\n\t\tsafeCloseHandle(hIoCtrl);\n\t\n\t\tif(bRet == FALSE || dwReturned != sizeof(SMART_READ_DATA_OUTDATA))\n\t\t{\n\t\t\treturn\tFALSE;\n\t\t}\n\n\t\tmemcpy_s(&(asi->SmartReadData), 512, &(sendCmdOutParam.SendCmdOutParam.bBuffer), 512);\n\t}\n\n\treturn FillSmartData(asi);\n}\n\nBOOL CAtaSmart::GetSmartThresholdPd(INT physicalDriveId, BYTE target, ATA_SMART_INFO* asi)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = INVALID_HANDLE_VALUE;\n\tDWORD\tdwReturned = 0;\n\n\tSMART_READ_DATA_OUTDATA\tsendCmdOutParam = {};\n\tSENDCMDINPARAMS\tsendCmd = {};\n\n\tif(m_bAtaPassThrough && m_bAtaPassThroughSmart)\n\t{\n\t\tDebugPrint(_T(\"SendAtaCommandPd - SMART_READ_THRESHOLDS (ATA_PASS_THROUGH)\"));\n\t\tbRet = SendAtaCommandPd(physicalDriveId, target, SMART_CMD, READ_THRESHOLDS, 0x00, \n\t\t\t(PBYTE)&(asi->SmartReadThreshold), sizeof(asi->SmartReadThreshold));\n\t}\n\n\tif(! bRet)\n\t{\n\t\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\t\tif(! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\treturn\tFALSE;\n\t\t}\n\n\t\t//::ZeroMemory(&sendCmdOutParam, sizeof(SMART_READ_DATA_OUTDATA));\n\t\t//::ZeroMemory(&sendCmd, sizeof(SENDCMDINPARAMS));\n\n\t\tsendCmd.irDriveRegs.bFeaturesReg\t= READ_THRESHOLDS;\n\t\tsendCmd.irDriveRegs.bSectorCountReg = 1;\n\t\tsendCmd.irDriveRegs.bSectorNumberReg= 1;\n\t\tsendCmd.irDriveRegs.bCylLowReg\t\t= SMART_CYL_LOW;\n\t\tsendCmd.irDriveRegs.bCylHighReg\t\t= SMART_CYL_HI;\n\t\tsendCmd.irDriveRegs.bDriveHeadReg\t= target;\n\t\tsendCmd.irDriveRegs.bCommandReg\t\t= SMART_CMD;\n\t\tsendCmd.cBufferSize\t\t\t\t\t= READ_THRESHOLD_BUFFER_SIZE;\n\n\t\tDebugPrint(_T(\"SendAtaCommandPd - SMART_READ_THRESHOLDS\"));\n\t\tbRet = ::DeviceIoControl(hIoCtrl, DFP_RECEIVE_DRIVE_DATA, \n\t\t\t&sendCmd, sizeof(SENDCMDINPARAMS),\n\t\t\t&sendCmdOutParam, sizeof(SMART_READ_DATA_OUTDATA),\n\t\t\t&dwReturned, NULL);\n\n\t\tsafeCloseHandle(hIoCtrl);\n\t\n\t\tif(bRet == FALSE || dwReturned != sizeof(SMART_READ_DATA_OUTDATA))\n\t\t{\n\t\t\treturn\tFALSE;\n\t\t}\n\n\t\tmemcpy_s(&(asi->SmartReadThreshold), 512, &(sendCmdOutParam.SendCmdOutParam.bBuffer), 512);\n\t}\n\t\n\treturn FillSmartThreshold(asi);\n}\n\nBOOL CAtaSmart::ControlSmartStatusPd(INT physicalDriveId, BYTE target, BYTE command)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\n\tSENDCMDINPARAMS\t\tsendCmd = {};\n\tSENDCMDOUTPARAMS\tsendCmdOutParam = {};\n\n\tif(m_bAtaPassThrough && m_bAtaPassThroughSmart)\n\t{\n\t\tDebugPrint(_T(\"SendAtaCommandPd - SMART_CONTROL_STATUS (ATA_PASS_THROUGH)\"));\n\t\tbRet = SendAtaCommandPd(physicalDriveId, target, SMART_CMD, command, 0x00, NULL, 0);\n\t}\n\n\tif(! bRet)\n\t{\n\t\tDebugPrint(_T(\"SendAtaCommandPd - SMART_CONTROL_STATUS\"));\n\t\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\t\tif(! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\treturn\tFALSE;\n\t\t}\n\n\t\t//::ZeroMemory(&sendCmd, sizeof(SENDCMDINPARAMS));\n\t\t//::ZeroMemory(&sendCmdOutParam, sizeof(SENDCMDOUTPARAMS));\n\n\t\tsendCmd.irDriveRegs.bFeaturesReg\t= command;\n\t\tsendCmd.irDriveRegs.bSectorCountReg = 1;\n\t\tsendCmd.irDriveRegs.bSectorNumberReg= 1;\n\t\tsendCmd.irDriveRegs.bCylLowReg\t\t= SMART_CYL_LOW;\n\t\tsendCmd.irDriveRegs.bCylHighReg\t\t= SMART_CYL_HI;\n\t\tsendCmd.irDriveRegs.bDriveHeadReg\t= target;\n\t\tsendCmd.irDriveRegs.bCommandReg\t\t= SMART_CMD;\n\t\tsendCmd.cBufferSize\t\t\t\t\t= 0;\n\n\t\tbRet = ::DeviceIoControl(hIoCtrl, DFP_SEND_DRIVE_COMMAND, \n\t\t\t&sendCmd, sizeof(SENDCMDINPARAMS) - 1,\n\t\t\t&sendCmdOutParam, sizeof(SENDCMDOUTPARAMS) -1,\n\t\t\t&dwReturned, NULL);\n\n\t\tsafeCloseHandle(hIoCtrl);\n\t}\n\t\n\treturn\tbRet;\n}\n\nBOOL CAtaSmart::ReadLogExtPd(INT physicalDriveId, BYTE target, BYTE logAddress, BYTE logPage, PBYTE data, DWORD dataSize)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t//if (TRUE || m_bAtaPassThrough) // *Always TRUE if\n\t{\n\t\tATA_PASS_THROUGH_EX_WITH_BUFFERS ab = {};\n\t\t//::ZeroMemory(&ab, sizeof(ab));\n\t\tab.Apt.Length = sizeof(ATA_PASS_THROUGH_EX);\n\t\tab.Apt.TimeOutValue = 2;\n\t\tDWORD size = offsetof(ATA_PASS_THROUGH_EX_WITH_BUFFERS, Buf);\n\t\tab.Apt.DataBufferOffset = size;\n\n\t\tif (dataSize > 0)\n\t\t{\n\t\t\tif (dataSize > sizeof(ab.Buf))\n\t\t\t{\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tab.Apt.AtaFlags = ATA_FLAGS_DATA_IN | ATA_FLAGS_48BIT_COMMAND;\n\t\t\tab.Apt.DataTransferLength = dataSize;\n\t\t\tab.Buf[0] = 0xCF; // magic number\n\t\t\tsize += dataSize;\n\t\t}\n\n\t\tab.Apt.CurrentTaskFile.bFeaturesReg = 0x00;\n\t\tab.Apt.CurrentTaskFile.bSectorCountReg = 0x01;\n\t\tab.Apt.CurrentTaskFile.bSectorNumberReg = logAddress;// Log Address\n\t\tab.Apt.CurrentTaskFile.bCylLowReg = logPage; // Page #\n\t\tab.Apt.CurrentTaskFile.bCylHighReg = 0;\n\t\tab.Apt.CurrentTaskFile.bDriveHeadReg = target;\n\t\tab.Apt.CurrentTaskFile.bCommandReg = 0x2F; // Read Log Ext\n\n\t\tab.Apt.PreviousTaskFile.bFeaturesReg = 0;\n\t\tab.Apt.PreviousTaskFile.bSectorCountReg = 0;\n\t\tab.Apt.PreviousTaskFile.bSectorNumberReg = 0;\n\t\tab.Apt.PreviousTaskFile.bCylLowReg = 0;\n\t\tab.Apt.PreviousTaskFile.bCylHighReg = 0;\n\t\tab.Apt.PreviousTaskFile.bDriveHeadReg = 0;\n\t\tab.Apt.PreviousTaskFile.bCommandReg = 0;\n\n\t\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_ATA_PASS_THROUGH,\n\t\t\t&ab, size, &ab, size, &dwReturned, NULL);\n\t\tsafeCloseHandle(hIoCtrl);\n\t\tif (bRet && dataSize && data != NULL)\n\t\t{\n\t\t\tmemcpy_s(data, dataSize, ab.Buf, dataSize);\n\t\t}\n\t}\n\n\treturn\tbRet;\n}\nBOOL CAtaSmart::SendAtaCommandPd(INT physicalDriveId, BYTE target, BYTE main, BYTE sub, BYTE param, PBYTE data, DWORD dataSize)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\tif (m_bAtaPassThrough)\n\t{\n\t\tATA_PASS_THROUGH_EX_WITH_BUFFERS ab = {};\n\t\t//::ZeroMemory(&ab, sizeof(ab));\n\t\tab.Apt.Length = sizeof(ATA_PASS_THROUGH_EX);\n\t\tab.Apt.TimeOutValue = 2;\n\t\tDWORD size = offsetof(ATA_PASS_THROUGH_EX_WITH_BUFFERS, Buf);\n\t\tab.Apt.DataBufferOffset = size;\n\n\t\tif (dataSize > 0)\n\t\t{\n\t\t\tif (dataSize > sizeof(ab.Buf))\n\t\t\t{\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tab.Apt.AtaFlags = ATA_FLAGS_DATA_IN;\n\t\t\tab.Apt.DataTransferLength = dataSize;\n\t\t\tab.Buf[0] = 0xCF; // magic number\n\t\t\tsize += dataSize;\n\t\t}\n\n\t\tab.Apt.CurrentTaskFile.bFeaturesReg = sub;\n\t\tab.Apt.CurrentTaskFile.bSectorCountReg = param;\n\t\tab.Apt.CurrentTaskFile.bDriveHeadReg = target;\n\t\tab.Apt.CurrentTaskFile.bCommandReg = main;\n\n\t\tif (main == SMART_CMD)\n\t\t{\n\t\t\tab.Apt.CurrentTaskFile.bCylLowReg = SMART_CYL_LOW;\n\t\t\tab.Apt.CurrentTaskFile.bCylHighReg = SMART_CYL_HI;\n\t\t\tab.Apt.CurrentTaskFile.bSectorCountReg = 1;\n\t\t\tab.Apt.CurrentTaskFile.bSectorNumberReg = 1;\n\t\t}\n\n\t\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_ATA_PASS_THROUGH,\n\t\t\t&ab, size, &ab, size, &dwReturned, NULL);\n\t\tsafeCloseHandle(hIoCtrl);\n\t\tif (bRet && dataSize && data != NULL)\n\t\t{\n\t\t\tmemcpy_s(data, dataSize, ab.Buf, dataSize);\n\t\t}\n\t}\n\telse\n\t{\n\t\tDWORD size = sizeof(CMD_IDE_PATH_THROUGH) - 1 + dataSize;\n\t\tCMD_IDE_PATH_THROUGH* buf = (CMD_IDE_PATH_THROUGH*)VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);\n\t\tif (buf != NULL) {\n\t\t\tbuf->reg.bFeaturesReg = sub;\n\t\t\tbuf->reg.bSectorCountReg = param;\n\t\t\tbuf->reg.bSectorNumberReg = 0;\n\t\t\tbuf->reg.bCylLowReg = 0;\n\t\t\tbuf->reg.bCylHighReg = 0;\n\t\t\tbuf->reg.bDriveHeadReg = target;\n\t\t\tbuf->reg.bCommandReg = main;\n\t\t\tbuf->reg.bReserved = 0;\n\t\t\tbuf->length = dataSize;\n\n\t\t\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_IDE_PASS_THROUGH,\n\t\t\t\tbuf, size, buf, size, &dwReturned, NULL);\n\t\t}\n\t\tsafeCloseHandle(hIoCtrl);\n\t\tif (bRet && dataSize && data != NULL)\n\t\t{\n\t\t\tmemcpy_s(data, dataSize, buf->buffer, dataSize);\n\t\t}\n\t\tsafeVirtualFree(buf, 0, MEM_RELEASE);\n\t}\n\n\treturn\tbRet;\n}\n\n/*---------------------------------------------------------------------------*/\n//  NVMe JMicron\n/*---------------------------------------------------------------------------*/\n\n// 2023/02/24 Compatible with SIV\nHANDLE CAtaSmart::CreateWorldMutex(CONST TCHAR* name)\t\t\t\t\t\t\t// Create/Open a Mutex with\n{                                                                               // appropriate protection\n\tHANDLE                    mhl;                                              // Mutex Handle\n\tSID*\t\t\t\t\t  sid;\t\t\t\t\t\t\t\t\t\t\t\t// Security ID\n\tSECURITY_ATTRIBUTES       sab[1]{};\t\t\t\t\t\t\t\t\t\t\t// Security Attributes Block\n\tSECURITY_DESCRIPTOR       sdb[1]{};\t\t\t\t\t\t\t\t\t\t\t// Security Descriptor Block\n\tACL                       acl[32];\t\t\t\t\t\t\t\t\t\t\t// ACL Area\n\tSID_IDENTIFIER_AUTHORITY  swa[1] = SECURITY_WORLD_SID_AUTHORITY;\t\t\t// World access\n\tTCHAR                     gtb[256]{};                                       // Global\\\\ text buffer\n\n\tInitializeSecurityDescriptor(sdb, SECURITY_DESCRIPTOR_REVISION);            // setup Security Descriptor\n\n\tsid = NULL;\t\t\t\t\t\t\t\t// in case AllocateAndInitializeSid fails\n\tif (AllocateAndInitializeSid(swa,       // SID Identifier Authority\n\t\t1,\t\t\t\t\t\t\t\t\t// Sub Authority count\n\t\tSECURITY_WORLD_RID,\t\t\t\t\t// Sub Authority 0\n\t\t0,\t\t\t\t\t\t\t\t\t// Sub Authority 1\n\t\t0,\t\t\t\t\t\t\t\t\t// Sub Authority 2\n\t\t0,\t\t\t\t\t\t\t\t\t// Sub Authority 3\n\t\t0,\t\t\t\t\t\t\t\t\t// Sub Authority 4\n\t\t0,\t\t\t\t\t\t\t\t\t// Sub Authority 5\n\t\t0,\t\t\t\t\t\t\t\t\t// Sub Authority 6\n\t\t0,\t\t\t\t\t\t\t\t\t// Sub Authority 7\n\t\t(PSID*)&sid) &&\t\t\t\t\t\t// returned SID\n\t\t(InitializeAcl(acl,                 // ACL setup OK and\n\t\t\tsizeof(acl),                    //\n\t\t\tACL_REVISION)) &&               //\n\t\t(AddAccessAllowedAce(acl,           // ACE setup OK and\n\t\t\tACL_REVISION,                   //\n\t\t\tMUTANT_ALL_ACCESS,              // Access Rights Mask\n\t\t\tsid)))                          //\n\t{\n\t\tSetSecurityDescriptorDacl(sdb, TRUE, acl, FALSE);  // yes, setup world access\n\t}\n\telse\n\t{\n#pragma warning(disable:6248)\n\t\tSetSecurityDescriptorDacl(sdb, TRUE, NULL, FALSE); // no, setup with default\n#pragma warning(default:6248)\n\t}\n\n\tsab->nLength = sizeof(sdb);                            // setup Security Attributes Block \n\tsab->bInheritHandle = FALSE;                           //\n\tsab->lpSecurityDescriptor = sdb;                       //\n\n\tswprintf_s(gtb, 256, TEXT(\"Global\\\\%s\"), name);        // name with Global\\ prefix\n\n\tif (((mhl = CreateMutex(sab,                           // Create/Open with Global\\ Unprotected or\n\t\tFALSE,                                             //\n\t\tgtb)) != NULL) ||                                  //\n\t\t((mhl = OpenMutex(READ_CONTROL | MUTANT_QUERY_STATE | SYNCHRONIZE,   // Open with Global\\ Protected or (probably Aquasuite)\n\t\t\tFALSE,\n\t\t\tgtb)) != NULL) ||\n\t\t((mhl = CreateMutex(sab,                           // Create/Open with no prefix Unprotected ?\n\t\t\tFALSE,                                         //\n\t\t\tname)) != NULL)) {\n\t}\n\n\tif (sid)\t\t\t\t\t\t\t\t\t\t\t   // need to free the SID ?\n\t{\n\t\tFreeSid(sid);                                      // yes, free it\n\t}\n\n\treturn mhl;                                            // return the handle\n}\n\nvoid CAtaSmart::AcquireMutexJMicron()\n{\n\tDWORD status = 0;\n\n\tif ((status = WaitForSingleObject(hMutexJMicron, INFINITE)) != WAIT_OBJECT_0)\n\t{\n\t\tif (status != WAIT_ABANDONED)\n\t\t{\n\t\t\tDebugPrint(_T(\"AcquireMutexJMicron() failed\"));\n\t\t}\n\t}\n}\n\nvoid CAtaSmart::ReleaseMutexJMicron()\n{\n\tif (!ReleaseMutex(hMutexJMicron))\n\t{\n\t\tDebugPrint(_T(\"ReleaseMutexJMicron() failed\"));\n\t}\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceNVMeJMicron(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data, BOOL flagUsb2mode)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength;\n\n\tDWORD transferLength = 4096;\n\n\t// 2023/02/19 Workaround for JMS583 firmware bug...\n\tif (flagUsb2mode)\n\t{\n\t\ttransferLength = 512;\n\t}\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS24 sptwb = {};\n\n\tif (data == NULL)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t::ZeroMemory(data, sizeof(NVME_IDENTIFY_DEVICE));\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_OUT;\n\tsptwb.Spt.DataTransferLength = transferLength;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, SenseBuf);\n\n\tsptwb.Spt.CdbLength = 12;\n\tsptwb.Spt.Cdb[0] = 0xA1; // NVME PASS THROUGH\n\tsptwb.Spt.Cdb[1] = 0x80; // ADMIN\n\tsptwb.Spt.Cdb[2] = 0;\n\tsptwb.Spt.Cdb[3] = 0;\n\tsptwb.Spt.Cdb[4] = 2;\n\tsptwb.Spt.Cdb[5] = 0;\n\tsptwb.Spt.Cdb[6] = 0;\n\tsptwb.Spt.Cdb[7] = 0;\n\tsptwb.Spt.Cdb[8] = 0;\n\tsptwb.Spt.Cdb[9] = 0;\n\tsptwb.Spt.Cdb[10]= 0;\n\tsptwb.Spt.Cdb[11]= 0;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_OUT;\n\tsptwb.DataBuf[0] = 'N';\n\tsptwb.DataBuf[1] = 'V';\n\tsptwb.DataBuf[2] = 'M';\n\tsptwb.DataBuf[3] = 'E';\n\tsptwb.DataBuf[8] = 0x06; // Identify\n\tsptwb.DataBuf[0x30] = 0x01;\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, DataBuf) + sptwb.Spt.DataTransferLength;\n\n\tAcquireMutexJMicron(); // 2023/02/24 Compatible with SIV\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tReleaseMutexJMicron();\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\t::ZeroMemory(&sptwb, sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS24));\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataTransferLength = transferLength;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, SenseBuf);\n\t\n\tsptwb.Spt.CdbLength = 12;\n\tsptwb.Spt.Cdb[0] = 0xA1; // NVME PASS THROUGH\n\tsptwb.Spt.Cdb[1] = 0x82; // ADMIN + DMA-IN\n\tsptwb.Spt.Cdb[2] = 0;\n\tsptwb.Spt.Cdb[3] = 0;\n\tsptwb.Spt.Cdb[4] = 2;\n\tsptwb.Spt.Cdb[5] = 0;\n\tsptwb.Spt.Cdb[6] = 0;\n\tsptwb.Spt.Cdb[7] = 0;\n\tsptwb.Spt.Cdb[8] = 0;\n\tsptwb.Spt.Cdb[9] = 0;\n\tsptwb.Spt.Cdb[10]= 0;\n\tsptwb.Spt.Cdb[11]= 0;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, DataBuf) + sptwb.Spt.DataTransferLength;\n\tdwReturned = sizeof(sptwb);\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\tReleaseMutexJMicron();\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += sptwb.DataBuf[i];\n\t}\n\tif (count == 0 || count == 317)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(data, sizeof(NVME_IDENTIFY_DEVICE), sptwb.DataBuf, sizeof(NVME_IDENTIFY_DEVICE));\n\n\tsafeCloseHandle(hIoCtrl);\n\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeJMicron(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS24 sptwb = {};\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_OUT;\n\tsptwb.Spt.DataTransferLength = IDENTIFY_BUFFER_SIZE;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, SenseBuf);\n\n\tsptwb.Spt.CdbLength = 12;\n\tsptwb.Spt.Cdb[0] = 0xA1; // NVME PASS THROUGH\n\tsptwb.Spt.Cdb[1] = 0x80; // ADMIN\n\tsptwb.Spt.Cdb[2] = 0;\n\tsptwb.Spt.Cdb[3] = 0;\n\tsptwb.Spt.Cdb[4] = 2;\n\tsptwb.Spt.Cdb[5] = 0;\n\tsptwb.Spt.Cdb[6] = 0;\n\tsptwb.Spt.Cdb[7] = 0;\n\tsptwb.Spt.Cdb[8] = 0;\n\tsptwb.Spt.Cdb[9] = 0;\n\tsptwb.Spt.Cdb[10] = 0;\n\tsptwb.Spt.Cdb[11] = 0;\n\tsptwb.DataBuf[0] = 'N';\n\tsptwb.DataBuf[1] = 'V';\n\tsptwb.DataBuf[2] = 'M';\n\tsptwb.DataBuf[3] = 'E';\n\tsptwb.DataBuf[8] = 0x02;  // GetLogPage, S.M.A.R.T.\n\tsptwb.DataBuf[10] = 0x56;\n\tsptwb.DataBuf[12] = 0xFF;\n\tsptwb.DataBuf[13] = 0xFF;\n\tsptwb.DataBuf[14] = 0xFF;\n\tsptwb.DataBuf[15] = 0xFF;\n\tsptwb.DataBuf[0x21] = 0x40;\n\tsptwb.DataBuf[0x22] = 0x7A;\n\tsptwb.DataBuf[0x30] = 0x02;\n\tsptwb.DataBuf[0x32] = 0x7F;\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, DataBuf) + sptwb.Spt.DataTransferLength;\n\n\tAcquireMutexJMicron(); // 2023/02/24 Compatible with SIV\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tReleaseMutexJMicron();\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\t::ZeroMemory(&sptwb, sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS24));\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = IDENTIFY_BUFFER_SIZE;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, SenseBuf);\n\n\tsptwb.Spt.CdbLength = 12;\n\tsptwb.Spt.Cdb[0] = 0xA1; // NVME PASS THROUGH\n\tsptwb.Spt.Cdb[1] = 0x82; // ADMIN + DMA-IN\n\tsptwb.Spt.Cdb[2] = 0;\n\tsptwb.Spt.Cdb[3] = 0;\n\tsptwb.Spt.Cdb[4] = 2;\n\tsptwb.Spt.Cdb[5] = 0;\n\tsptwb.Spt.Cdb[6] = 0;\n\tsptwb.Spt.Cdb[7] = 0;\n\tsptwb.Spt.Cdb[8] = 0;\n\tsptwb.Spt.Cdb[9] = 0;\n\tsptwb.Spt.Cdb[10] = 0;\n\tsptwb.Spt.Cdb[11] = 0;\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\tReleaseMutexJMicron();\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += sptwb.DataBuf[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(&(asi->SmartReadData), 512, sptwb.DataBuf, 512);\n\tsafeCloseHandle(hIoCtrl);\n\n\treturn TRUE;\n}\n\n/*---------------------------------------------------------------------------*/\n//  NVMe ASMedia\n/*---------------------------------------------------------------------------*/\n\nBOOL CAtaSmart::DoIdentifyDeviceNVMeASMedia(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\n\tif (data == NULL)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t::ZeroMemory(data, sizeof(NVME_IDENTIFY_DEVICE));\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t//::ZeroMemory(&sptwb, sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataTransferLength = 4096;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\n\tsptwb.Spt.CdbLength = 16;\n\tsptwb.Spt.Cdb[0] = 0xE6; // NVME PASS THROUGH\n\tsptwb.Spt.Cdb[1] = 0x06; // IDENTIFY\n\tsptwb.Spt.Cdb[3] = 0x01;\n\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += sptwb.DataBuf[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(data, sizeof(NVME_IDENTIFY_DEVICE), sptwb.DataBuf, sizeof(NVME_IDENTIFY_DEVICE));\n\n\tsafeCloseHandle(hIoCtrl);\n\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeASMedia(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t//::ZeroMemory(&sptwb, sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataTransferLength = 512;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\n\tsptwb.Spt.CdbLength = 16;\n\tsptwb.Spt.Cdb[0] = 0xE6; // NVME PASS THROUGH\n\tsptwb.Spt.Cdb[1] = 0x02; // GetLogPage\n\tsptwb.Spt.Cdb[3] = 0x02; // S.M.A.R.T.\n\tsptwb.Spt.Cdb[7] = 0x7F;\n\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += sptwb.DataBuf[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(&(asi->SmartReadData), 512, sptwb.DataBuf, 512);\n\n\tsafeCloseHandle(hIoCtrl);\n\n\treturn TRUE;\n}\n\n/*---------------------------------------------------------------------------*/\n//  NVMe Realtek\n/*---------------------------------------------------------------------------*/\n\nBOOL CAtaSmart::isRealtekProduct(INT physicalDriveId, INT scsiPort, INT scsiTargetId)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength;\n\t\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\t\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\t\n\tif (!hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.CdbLength = 16;\n\tsptwb.Spt.SenseInfoLength = 32;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = 512;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\t\n\tsptwb.Spt.Cdb[0] = 0x12;\n\tsptwb.Spt.Cdb[1] = 0x0;\n\tsptwb.Spt.Cdb[2] = 0x0;\n\tsptwb.Spt.Cdb[3] = (512 >> 8);\n\tsptwb.Spt.Cdb[4] = 512 & 0xFF;\n\tsptwb.Spt.Cdb[5] = 0x0;\n\t\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\t\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t\t\t&sptwb, length,\n\t\t\t\t&sptwb, length, &dwReturned, NULL);\n\t\n\tCString tmp;\n\ttmp.Format(L\"RealtekProduct IO fialed %d\", bRet);\n\tDebugPrint(tmp);\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\t\n\tbRet = false;\n\t\n\tif (strncmp((char*)sptwb.DataBuf + 32, \"1.01\", 4) == 0)\n\t{\n\t\tbRet = TRUE;\n\t}\n\telse if (strncmp((char*)sptwb.DataBuf + 8, \"Realtek RTL9220DP\", 17) == 0)\n\t{\n\t\tbRet = TRUE;\n\t}\n\t\n\ttmp.Format(L\"RealtekProduct get rtn %d\", bRet);\n\tDebugPrint(tmp);\n\t\n\treturn bRet;\n}\n\nBOOL CAtaSmart::RealtekRAIDMode(INT physicalDriveId, INT scsiPort, INT scsiTargetId)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength;\n\t\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\t\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\t\n\tif (!hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.CdbLength = 16;\n\tsptwb.Spt.SenseInfoLength = 32;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = 1;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\t\n\tsptwb.Spt.Cdb[0] = 0xE2;\n\tsptwb.Spt.Cdb[4] = 0xD3;\n\tsptwb.Spt.Cdb[12] = 0x01;\n\t\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\t\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t&sptwb, length,\n\t&sptwb, length, &dwReturned, NULL);\n\t\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t\t}\n\t\n\tsptwb.Spt.Cdb[0] = 0xE2;\n\tsptwb.Spt.Cdb[4] = 0xD2;\n\tsptwb.Spt.Cdb[12] = 0x01;\n\t\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\t\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t\t&sptwb, length,\n\t\t\t&sptwb, length, &dwReturned, NULL);\n\t\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\t\n\tDWORD count = 0;\n\tfor (int i = 0; i < 1; i++)\n\t{\n\t\tcount += sptwb.DataBuf[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\t\n\tsafeCloseHandle(hIoCtrl);\n\t\n\treturn (sptwb.DataBuf[0] > 0) ? TRUE : FALSE;\n}\n\nBOOL CAtaSmart::RealtekSwitchMode(INT physicalDriveId, INT scsiPort, INT scsiTargetId, INT dir, INT mode)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength;\n\t\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\t\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\tCString tmp;\n\t\n\tif (!hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\t\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.CdbLength = 16;\n\tsptwb.Spt.SenseInfoLength = 16;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_OUT;\n\tsptwb.Spt.DataTransferLength = 0;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\t\n\tif (dir)\n\t{\n\t\t// set\n\t\tsptwb.Spt.Cdb[0] = 0xE3;\n\t\tsptwb.Spt.Cdb[4] = 0x53;\n\t}\n\telse\n\t{\n\t\t// read\n\t\tsptwb.Spt.Cdb[0] = 0xE2;\n\t\tsptwb.Spt.Cdb[4] = 0xD4;\n\t}\n\tsptwb.Spt.Cdb[6] = mode;\n\t\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\t\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t\t&sptwb, length,\n\t\t\t&sptwb, length, &dwReturned, NULL);\n\t\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\t\n\tsafeCloseHandle(hIoCtrl);\n\t\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceNVMeRealtek(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\n\tif (data == NULL)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t::ZeroMemory(data, sizeof(NVME_IDENTIFY_DEVICE));\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t//::ZeroMemory(&sptwb, sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.CdbLength = 16;\n\tsptwb.Spt.SenseInfoLength = 32;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = 4096;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\n\tsptwb.Spt.Cdb[0] = 0xE4; // NVME READ\n\tsptwb.Spt.Cdb[1] = BYTE(4096);\n\tsptwb.Spt.Cdb[2] = BYTE(4096 >> 8);\n\tsptwb.Spt.Cdb[3] = 0x06; // IDENTIFY\n\tsptwb.Spt.Cdb[4] = 0x01;\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += sptwb.DataBuf[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(data, sizeof(NVME_IDENTIFY_DEVICE), sptwb.DataBuf, sizeof(NVME_IDENTIFY_DEVICE));\n\n\tsafeCloseHandle(hIoCtrl);\n\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeRealtek9220DP(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO * asi)\n{\n\tDebugPrint(_T(\"GetSmartAttributeNVMeRealtek9220DP\"));\n\tBOOL rtn = FALSE;\n\tif (FlagUsbRealtek9220DP && RealtekRAIDMode(physicalDriveId, scsiPort, scsiTargetId))\n\t{\n\t\tif (RealtekSwitchMode(physicalDriveId, scsiPort, scsiTargetId, 1, 1))\n\t\t{\n\t\t\trtn = GetSmartAttributeNVMeRealtek(physicalDriveId, scsiPort, scsiTargetId, asi);\n\t\t\tRealtekSwitchMode(physicalDriveId, scsiPort, scsiTargetId, 1, 0);\n\t\t}\n\t}\n\t\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeRealtek(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\n\tDebugPrint(_T(\"GetSmartAttributeNVMeRealtek\"));\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t//::ZeroMemory(&sptwb, sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.CdbLength = 16;\n\tsptwb.Spt.SenseInfoLength = 32;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = 512;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\n\tsptwb.Spt.Cdb[0] = 0xE4; // NVME READ\n\tsptwb.Spt.Cdb[1] = BYTE(512);\n\tsptwb.Spt.Cdb[2] = BYTE(512>>8);\n\tsptwb.Spt.Cdb[3] = 0x02; //GetLogPage\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += sptwb.DataBuf[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(&(asi->SmartReadData), 512, sptwb.DataBuf, 512);\n\n\tsafeCloseHandle(hIoCtrl);\n\n\treturn TRUE;\n}\n\n/*---------------------------------------------------------------------------*/\n//  NVMe SAMSUNG\n/*---------------------------------------------------------------------------*/\n\nBOOL CAtaSmart::DoIdentifyDeviceNVMeSamsung(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS24 sptwb = {};\n\n\tif (data == NULL)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t::ZeroMemory(data, sizeof(NVME_IDENTIFY_DEVICE));\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t//::ZeroMemory(&sptwb, sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS24));\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = 4096;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, SenseBuf);\n\n\tsptwb.Spt.CdbLength = 16;\n\tsptwb.Spt.Cdb[0] = 0xB5; // SECURITY PROTOCOL OUT\n\tsptwb.Spt.Cdb[1] = 0xFE; // SAMSUNG PROTOCOL\n\tsptwb.Spt.Cdb[2] = 0;\n\tsptwb.Spt.Cdb[3] = 5;\n\tsptwb.Spt.Cdb[4] = 0;\n\tsptwb.Spt.Cdb[5] = 0;\n\tsptwb.Spt.Cdb[6] = 0;\n\tsptwb.Spt.Cdb[7] = 0;\n\tsptwb.Spt.Cdb[8] = 0;\n\tsptwb.Spt.Cdb[9] = 0x40;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_OUT;\n\tsptwb.DataBuf[0] = 1;\n\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, DataBuf) + sptwb.Spt.DataTransferLength;\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tsptwb.Spt.CdbLength = 16;\n\tsptwb.Spt.Cdb[0] = 0xA2; // SECURITY PROTOCOL IN\n\tsptwb.Spt.Cdb[1] = 0xFE; // SAMSUNG PROTOCOL\n\tsptwb.Spt.Cdb[2] = 0;\n\tsptwb.Spt.Cdb[3] = 5;\n\tsptwb.Spt.Cdb[4] = 0;\n\tsptwb.Spt.Cdb[5] = 0;\n\tsptwb.Spt.Cdb[6] = 0;\n\tsptwb.Spt.Cdb[7] = 0;\n\tsptwb.Spt.Cdb[8] = 1;\n\tsptwb.Spt.Cdb[9] = 0;\n\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.DataBuf[0] = 0;\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += sptwb.DataBuf[i];\n\t}\n\tif(count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(data, sizeof(NVME_IDENTIFY_DEVICE), sptwb.DataBuf, sizeof(NVME_IDENTIFY_DEVICE));\n\n\tsafeCloseHandle(hIoCtrl);\n\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeSamsung(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS24 sptwb = {}\t;\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\n\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n//\t::ZeroMemory(&sptwb, sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS24));\n\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = IDENTIFY_BUFFER_SIZE;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, SenseBuf);\n\n\tsptwb.Spt.CdbLength = 16;\n\tsptwb.Spt.Cdb[0] = 0xB5; // SECURITY PROTOCOL OUT\n\tsptwb.Spt.Cdb[1] = 0xFE; // SAMSUNG PROTOCOL\n\tsptwb.Spt.Cdb[2] = 0;\n\tsptwb.Spt.Cdb[3] = 6;\n\tsptwb.Spt.Cdb[4] = 0;\n\tsptwb.Spt.Cdb[5] = 0;\n\tsptwb.Spt.Cdb[6] = 0;\n\tsptwb.Spt.Cdb[7] = 0;\n\tsptwb.Spt.Cdb[8] = 0;\n\tsptwb.Spt.Cdb[9] = 0x40;\n\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_OUT;\n\tsptwb.DataBuf[0] = 2;\n\tsptwb.DataBuf[4] = 0xFF;\n\tsptwb.DataBuf[5] = 0xFF;\n\tsptwb.DataBuf[6] = 0xFF;\n\tsptwb.DataBuf[7] = 0xFF;\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS24, DataBuf) + sptwb.Spt.DataTransferLength;\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tsptwb.Spt.CdbLength = 16;\n\tsptwb.Spt.Cdb[0] = 0xA2; // SECURITY PROTOCOL IN\n\tsptwb.Spt.Cdb[1] = 0xFE; // SAMSUNG PROTOCOL\n\tsptwb.Spt.Cdb[2] = 0;\n\tsptwb.Spt.Cdb[3] = 6;\n\tsptwb.Spt.Cdb[4] = 0;\n\tsptwb.Spt.Cdb[5] = 0;\n\tsptwb.Spt.Cdb[6] = 0;\n\tsptwb.Spt.Cdb[7] = 0;\n\tsptwb.Spt.Cdb[8] = 1;\n\tsptwb.Spt.Cdb[9] = 0;\n\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.DataBuf[0] = 0;\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, length,\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += sptwb.DataBuf[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(&(asi->SmartReadData), 512, sptwb.DataBuf, 512);\n\n\tsafeCloseHandle(hIoCtrl);\n\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeSamsung951(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tCString path;\n\tpath.Format(L\"\\\\\\\\.\\\\PhysicalDrive%d\", physicalDriveId);\n\n\tHANDLE hIoCtrl = CreateFile(GetScsiPath((TCHAR*)path.GetString()), GENERIC_READ | GENERIC_WRITE,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\tBOOL bRet = 0;\n\tNVME_PASS_THROUGH_IOCTL nptwb = {};\n\tDWORD length = sizeof(nptwb);\n\tDWORD dwReturned;\n\n\t//ZeroMemory(&nptwb, sizeof(NVME_PASS_THROUGH_IOCTL));\n\n\tnptwb.SrbIoCtrl.ControlCode = NVME_PASS_THROUGH_SRB_IO_CODE;\n\tnptwb.SrbIoCtrl.HeaderLength = sizeof(SRB_IO_CONTROL);\n\tmemcpy((UCHAR*)(&nptwb.SrbIoCtrl.Signature[0]), NVME_SIG_STR, NVME_SIG_STR_LEN);\n\tnptwb.SrbIoCtrl.Timeout = NVME_PT_TIMEOUT;\n\tnptwb.SrbIoCtrl.Length = length - sizeof(SRB_IO_CONTROL);\n\tnptwb.DataBufferLen = sizeof(nptwb.DataBuffer);\n\tnptwb.ReturnBufferLen = sizeof(nptwb);\n\tnptwb.Direction = NVME_FROM_DEV_TO_HOST;\n\n\tnptwb.NVMeCmd[0] = 2;  // GetLogPage\n\tnptwb.NVMeCmd[1] = 0xFFFFFFFF;  // GetLogPage\n\tnptwb.NVMeCmd[10] = 0x00000002; // S,M.A.R.T.\n\n\tbRet = DeviceIoControl(hIoCtrl, IOCTL_SCSI_MINIPORT,\n\t\t&nptwb, length, &nptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += nptwb.DataBuffer[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(&(asi->SmartReadData), 512, nptwb.DataBuffer, 512);\n\n\tsafeCloseHandle(hIoCtrl);\n\treturn bRet;\n}\n\n\n/*---------------------------------------------------------------------------*/\n// NVMe Intel \n// Reference: http://naraeon.net/en/archives/1126\n/*---------------------------------------------------------------------------*/\n\nCString CAtaSmart::GetScsiPath(const TCHAR* Path)\n{\n\tHANDLE hIoCtrl = CreateFile(Path, GENERIC_READ | GENERIC_WRITE,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\tSCSI_ADDRESS sadr = {};\n\tBOOL bRet = 0;\n\tDWORD dwReturned;\n\n\tbRet = DeviceIoControl(hIoCtrl, IOCTL_SCSI_GET_ADDRESS,\n\t\tNULL, 0, &sadr, sizeof(sadr), &dwReturned, NULL);\n\n\tCString result;\n\tresult.Format(L\"\\\\\\\\.\\\\SCSI%d:\", sadr.PortNumber);\n\n\tsafeCloseHandle(hIoCtrl);\n\treturn result;\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceNVMeIntel(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data, DWORD* diskSize)\n{\n\tCString path;\n\tpath.Format(L\"\\\\\\\\.\\\\PhysicalDrive%d\", physicalDriveId);\n\n\tHANDLE hIoCtrl = CreateFile(GetScsiPath((TCHAR*)path.GetString()), GENERIC_READ | GENERIC_WRITE,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\tBOOL bRet = 0;\n\tNVME_PASS_THROUGH_IOCTL nptwb = {};\n\tDWORD length = sizeof(nptwb);\n\tDWORD dwReturned;\n\n\t//ZeroMemory(&nptwb, sizeof(NVME_PASS_THROUGH_IOCTL));\n\n\tnptwb.SrbIoCtrl.ControlCode = NVME_PASS_THROUGH_SRB_IO_CODE;\n\tnptwb.SrbIoCtrl.HeaderLength = sizeof(SRB_IO_CONTROL);\n\tmemcpy((UCHAR*)(&nptwb.SrbIoCtrl.Signature[0]), NVME_SIG_STR, NVME_SIG_STR_LEN);\n\tnptwb.SrbIoCtrl.Timeout = NVME_PT_TIMEOUT;\n\tnptwb.SrbIoCtrl.Length = length - sizeof(SRB_IO_CONTROL);\n\tnptwb.DataBufferLen = sizeof(nptwb.DataBuffer);\n\tnptwb.ReturnBufferLen = sizeof(nptwb);\n\tnptwb.Direction = NVME_FROM_DEV_TO_HOST;\n\n\tnptwb.NVMeCmd[0] = 6;  // Identify\n\tnptwb.NVMeCmd[1] = 1;  // Namespace Identifier (CDW1.NSID)\n\tnptwb.NVMeCmd[10] = 0; // Controller or Namespace Structure (CNS)\n\n\tbRet = DeviceIoControl(hIoCtrl, IOCTL_SCSI_MINIPORT,\n\t\t&nptwb, length, &nptwb, length, &dwReturned, NULL);\n\n\tif (bRet)\n\t{\n\t\tULONG64 totalLBA = *(ULONG64*)&nptwb.DataBuffer[0];\n\t\tint sectorSize = 1 << nptwb.DataBuffer[130];\n\t\t*diskSize = (DWORD)(totalLBA * sectorSize / 1000 / 1000);\n\t}\n\n\tnptwb.NVMeCmd[1] = 0;  // Namespace Identifier (CDW1.NSID)\n\tnptwb.NVMeCmd[10] = 1; // Controller or Namespace Structure (CNS)\n\n\tbRet = DeviceIoControl(hIoCtrl, IOCTL_SCSI_MINIPORT,\n\t\t&nptwb, length, &nptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += nptwb.DataBuffer[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(data, sizeof(NVME_IDENTIFY_DEVICE), nptwb.DataBuffer, sizeof(NVME_IDENTIFY_DEVICE));\n\n\tsafeCloseHandle(hIoCtrl);\n\treturn bRet;\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeIntel(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tCString path;\n\tpath.Format(L\"\\\\\\\\.\\\\PhysicalDrive%d\", physicalDriveId);\n\n\tHANDLE hIoCtrl = CreateFile(GetScsiPath((TCHAR*)path.GetString()), GENERIC_READ | GENERIC_WRITE,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\tBOOL bRet = 0;\n\tNVME_PASS_THROUGH_IOCTL nptwb = {};\n\tDWORD length = sizeof(nptwb);\n\tDWORD dwReturned;\n\n\t//ZeroMemory(&nptwb, sizeof(NVME_PASS_THROUGH_IOCTL));\n\n\tnptwb.SrbIoCtrl.ControlCode = NVME_PASS_THROUGH_SRB_IO_CODE;\n\tnptwb.SrbIoCtrl.HeaderLength = sizeof(SRB_IO_CONTROL);\n\tmemcpy((UCHAR*)(&nptwb.SrbIoCtrl.Signature[0]), NVME_SIG_STR, NVME_SIG_STR_LEN);\n\tnptwb.SrbIoCtrl.Timeout = NVME_PT_TIMEOUT;\n\tnptwb.SrbIoCtrl.Length = length - sizeof(SRB_IO_CONTROL);\n\tnptwb.DataBufferLen = sizeof(nptwb.DataBuffer);\n\tnptwb.ReturnBufferLen = sizeof(nptwb);\n\tnptwb.Direction = NVME_FROM_DEV_TO_HOST;\n\n\tnptwb.NVMeCmd[0] = 2;  // GetLogPage\n\tnptwb.NVMeCmd[1] = 0xFFFFFFFF;  // GetLogPage\n\tnptwb.NVMeCmd[10] = 0x007f0002; // \n\n\tbRet = DeviceIoControl(hIoCtrl, IOCTL_SCSI_MINIPORT,\n\t\t&nptwb, length, &nptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += nptwb.DataBuffer[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(&(asi->SmartReadData), 512, nptwb.DataBuffer, 512);\n\n\tsafeCloseHandle(hIoCtrl);\n\treturn bRet;\n}\n\n/*---------------------------------------------------------------------------*/\n// NVMe Intel RST\n/*---------------------------------------------------------------------------*/\n\nBOOL CAtaSmart::GetScsiAddress(const TCHAR* Path, BYTE* PortNumber, BYTE* PathId, BYTE* TargetId, BYTE* Lun)\n{\n\tHANDLE hDevice = CreateFile(Path,\n\t\tGENERIC_READ | GENERIC_WRITE,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE,\n\t\tnullptr,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tnullptr);\n\tDWORD dwReturned = 0;\n\tSCSI_ADDRESS ScsiAddr = {};\n\tBOOL bRet = DeviceIoControl(hDevice, IOCTL_SCSI_GET_ADDRESS,\n\t\tnullptr, 0, &ScsiAddr, sizeof(ScsiAddr), &dwReturned, NULL);\n\n\tsafeCloseHandle(hDevice);\n\n\t*PortNumber = ScsiAddr.PortNumber;\n\t*PathId = ScsiAddr.PathId;\n\t*TargetId = ScsiAddr.TargetId;\n\t*Lun = ScsiAddr.Lun;\n\n\treturn bRet == TRUE;\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceNVMeIntelRst(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data, DWORD* diskSize)\n{\n\tCString path;\n\tBYTE portNumber = 0, pathId = 0, targetId = 0, lun = 0;\n\tCString drive;\n\n\tif (physicalDriveId == -1)\n\t{\n\t\tportNumber = (BYTE)scsiPort;\n\t\tpathId = (BYTE)scsiTargetId;\n\t}\n\telse\n\t{\n\t\tpath.Format(L\"\\\\\\\\.\\\\PhysicalDrive%d\", physicalDriveId);\n\t\tGetScsiAddress(path, &portNumber, &pathId, &targetId, &lun);\n\t}\n\n\tdrive.Format(L\"\\\\\\\\.\\\\Scsi%d:\", portNumber);\n\n\tHANDLE hIoCtrl = CreateFile(drive,\n\t\tGENERIC_READ | GENERIC_WRITE,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, nullptr,\n\t\tOPEN_EXISTING, 0, nullptr);\n\n\tif (hIoCtrl != INVALID_HANDLE_VALUE)\n\t{\n\t\tINTEL_NVME_PASS_THROUGH NVMeData;\n\t\tmemset(&NVMeData, 0, sizeof(NVMeData));\n\n\t\tNVMeData.SRB.HeaderLength = sizeof(SRB_IO_CONTROL);\n\t\tmemcpy(NVMeData.SRB.Signature, \"IntelNvm\", 8);\n\t\tNVMeData.SRB.Timeout = 10;\n\t\tNVMeData.SRB.ControlCode = IOCTL_INTEL_NVME_PASS_THROUGH;\n\t\tNVMeData.SRB.Length = sizeof(INTEL_NVME_PASS_THROUGH) - sizeof(SRB_IO_CONTROL);\n\n\t\tNVMeData.Payload.Version = 1;\n\t\tNVMeData.Payload.PathId = pathId;\n\t\tNVMeData.Payload.Cmd.CDW0.Opcode = 0x06; // ADMIN_IDENTIFY\n\t\tNVMeData.Payload.Cmd.NSID = 1;\n\t\tNVMeData.Payload.Cmd.u.IDENTIFY.CDW10.CNS = 0;\n\t\tNVMeData.Payload.ParamBufLen = sizeof(INTEL_NVME_PAYLOAD) + sizeof(SRB_IO_CONTROL); //0xA4;\n\t\tNVMeData.Payload.ReturnBufferLen = 0x1000;\n\t\tNVMeData.Payload.CplEntry[0] = 0;\n\n\t\tDWORD dummy = 0;\n\t\tif (DeviceIoControl(hIoCtrl, IOCTL_SCSI_MINIPORT,\n\t\t\t&NVMeData,\n\t\t\tsizeof(NVMeData),\n\t\t\t&NVMeData,\n\t\t\tsizeof(NVMeData),\n\t\t\t&dummy, nullptr))\n\t\t{\n\t\t\tULONG64 totalLBA = *(ULONG64*)&NVMeData.DataBuffer[0];\n\t\t\tint sectorSize = 1 << NVMeData.DataBuffer[130];\n\n\t\t\t*diskSize = (DWORD)(totalLBA * sectorSize / 1000 / 1000);\n\t\t}\n\n\t\tNVMeData.Payload.Cmd.NSID = 0;\n\t\tNVMeData.Payload.Cmd.u.IDENTIFY.CDW10.CNS = 1;\n\t\tif (DeviceIoControl(hIoCtrl, IOCTL_SCSI_MINIPORT,\n\t\t\t&NVMeData,\n\t\t\tsizeof(NVMeData),\n\t\t\t&NVMeData,\n\t\t\tsizeof(NVMeData),\n\t\t\t&dummy, nullptr))\n\t\t{\n\t\t\tmemcpy_s(data, sizeof(NVME_IDENTIFY_DEVICE), NVMeData.DataBuffer, sizeof(NVME_IDENTIFY_DEVICE));\n\n\t\t\tsafeCloseHandle(hIoCtrl);\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tsafeCloseHandle(hIoCtrl);\n\t}\n\treturn FALSE;\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeIntelRst(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tCString path;\n\tBYTE portNumber = 0, pathId = 0, targetId = 0, lun = 0;\n\tCString drive;\n\n\tif (physicalDriveId == -1)\n\t{\n\t\tportNumber = (BYTE)scsiPort;\n\t\tpathId = (BYTE)scsiTargetId;\n\t}\n\telse\n\t{\n\t\tpath.Format(L\"\\\\\\\\.\\\\PhysicalDrive%d\", physicalDriveId);\n\t\tGetScsiAddress(path, &portNumber, &pathId, &targetId, &lun);\n\t}\n\n\tdrive.Format(L\"\\\\\\\\.\\\\Scsi%d:\", portNumber);\n\n\tHANDLE hIoCtrl = CreateFile(drive,\n\t\tGENERIC_READ | GENERIC_WRITE,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, nullptr,\n\t\tOPEN_EXISTING, 0, nullptr);\n\n\tif (hIoCtrl != INVALID_HANDLE_VALUE)\n\t{\n\t\tINTEL_NVME_PASS_THROUGH NVMeData = {};\n\t\t//memset(&NVMeData, 0, sizeof(NVMeData));\n\n\t\tNVMeData.SRB.HeaderLength = sizeof(SRB_IO_CONTROL);\n\t\tmemcpy(NVMeData.SRB.Signature, \"IntelNvm\", 8);\n\t\tNVMeData.SRB.Timeout = 10;\n\t\tNVMeData.SRB.ControlCode = IOCTL_INTEL_NVME_PASS_THROUGH;\n\t\tNVMeData.SRB.Length = sizeof(INTEL_NVME_PASS_THROUGH) - sizeof(SRB_IO_CONTROL);\n\n\t\tNVMeData.Payload.Version = 1;\n\t\tNVMeData.Payload.PathId = pathId;\n\t\tNVMeData.Payload.Cmd.CDW0.Opcode = 0x02; // ADMIN_GET_LOG_PAGE\n\t\tNVMeData.Payload.Cmd.NSID = 0xFFFFFFFF; //  NVME_NAMESPACE_ALL;\n\t\tNVMeData.Payload.Cmd.u.GET_LOG_PAGE.CDW10.LID = 2; // = 0x7f0002;\n\t\tNVMeData.Payload.Cmd.u.GET_LOG_PAGE.CDW10.NUMD = 0x7F;\n\t\tNVMeData.Payload.ParamBufLen = sizeof(INTEL_NVME_PAYLOAD) + sizeof(SRB_IO_CONTROL); //0xA4;\n\t\tNVMeData.Payload.ReturnBufferLen = 0x1000;\n\t\tNVMeData.Payload.CplEntry[0] = 0;\n\n\t\tDWORD dummy;\n\t\tif (DeviceIoControl(hIoCtrl, IOCTL_SCSI_MINIPORT,\n\t\t\t&NVMeData,\n\t\t\tsizeof(NVMeData),\n\t\t\t&NVMeData,\n\t\t\tsizeof(NVMeData),\n\t\t\t&dummy, nullptr))\n\t\t{\n\t\t\tmemcpy_s(&(asi->SmartReadData), 512, NVMeData.DataBuffer, 512);\n\t\t\tsafeCloseHandle(hIoCtrl);\n\t\t\treturn TRUE;\n\t\t}\n\t\tsafeCloseHandle(hIoCtrl);\n\t}\n\treturn FALSE;\n}\n\n/*---------------------------------------------------------------------------*/\n// NVMe Intel VROC\n/*---------------------------------------------------------------------------*/\n\nBOOL CAtaSmart::DoIdentifyDeviceNVMeIntelVroc(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data, DWORD* diskSize)\n{\n\tCString path;\n\tCString drive;\n\tBYTE portNumber = 0, pathId = 0, targetId = 0, lun = 0;\n\n\tif (physicalDriveId >= 0)\n\t{\n\t\tpath.Format(L\"\\\\\\\\.\\\\PhysicalDrive%d\", physicalDriveId);\n\t\tGetScsiAddress(path, &portNumber, &pathId, &targetId, &lun);\n\t}\n\telse\n\t{\n\t\tportNumber = scsiPort;\n\t\ttargetId = scsiTargetId;\n\t}\n\n\tdrive.Format(L\"\\\\\\\\.\\\\Scsi%d:\", portNumber);\n\n\tHANDLE hIoCtrl = CreateFile(drive, GENERIC_READ | GENERIC_WRITE,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\n\tif (hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tBOOL bRet = 0;\n\n\tNVME_PASS_THROUGH_IOCTL nptwb = {};\n\tDWORD length = sizeof(nptwb);\n\tDWORD dwReturned;\n\n\tmemcpy((UCHAR*)(&nptwb.SrbIoCtrl.Signature[0]), \"NvmeRAID\", NVME_SIG_STR_LEN);\n\tnptwb.SrbIoCtrl.ControlCode = NVME_PASS_THROUGH_SRB_IO_CODE;\n\tnptwb.SrbIoCtrl.Timeout = NVME_PT_TIMEOUT;\n\tnptwb.SrbIoCtrl.HeaderLength = sizeof(SRB_IO_CONTROL);\n\tnptwb.SrbIoCtrl.Length = length - sizeof(SRB_IO_CONTROL);\n\n\tnptwb.SrbIoCtrl.ReturnCode = 0x86000000 + (pathId << 16) + (targetId << 8) + lun;\n\n\tnptwb.Direction = NVME_FROM_DEV_TO_HOST;\n\tnptwb.QueueId = 0;\n\tnptwb.MetaDataLen = 0;\n\tnptwb.DataBufferLen = sizeof(nptwb.DataBuffer);\n\tnptwb.ReturnBufferLen = sizeof(nptwb);\n\n\tnptwb.NVMeCmd[0] = 6;  // Identify\n\tnptwb.NVMeCmd[1] = 1;  // Namespace Identifier (CDW1.NSID)\n\tnptwb.NVMeCmd[10] = 0; // Controller or Namespace Structure (CNS)\n\n\tnptwb.DataBuffer[0] = TRUE;\n\n\tbRet = DeviceIoControl(hIoCtrl, IOCTL_SCSI_MINIPORT,\n\t\t&nptwb, length, &nptwb, length, &dwReturned, NULL);\n\n\tif (bRet)\n\t{\n\t\tULONG64 totalLBA = *(ULONG64*)&nptwb.DataBuffer[0];\n\t\tint sectorSize = 1 << nptwb.DataBuffer[130];\n\t\t*diskSize = (DWORD)(totalLBA * sectorSize / 1000 / 1000);\n\t}\n\n\tnptwb.SrbIoCtrl.ReturnCode = (0x86000000) + (pathId << 16) + (targetId << 8) + lun;\n\n\tnptwb.NVMeCmd[1] = 0;  // Namespace Identifier (CDW1.NSID)\n\tnptwb.NVMeCmd[10] = 1; // Controller or Namespace Structure (CNS)\n\n\tbRet = DeviceIoControl(hIoCtrl, IOCTL_SCSI_MINIPORT,\n\t\t&nptwb, length, &nptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += nptwb.DataBuffer[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(data, sizeof(NVME_IDENTIFY_DEVICE), nptwb.DataBuffer, sizeof(NVME_IDENTIFY_DEVICE));\n\n\tsafeCloseHandle(hIoCtrl);\n\treturn bRet;\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeIntelVroc(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tCString path;\n\tCString drive;\n\tBYTE portNumber = 0, pathId = 0, targetId = 0, lun = 0;\n\n\tif (physicalDriveId >= 0)\n\t{\n\t\tpath.Format(L\"\\\\\\\\.\\\\PhysicalDrive%d\", physicalDriveId);\n\t\tGetScsiAddress(path, &portNumber, &pathId, &targetId, &lun);\n\t}\n\telse\n\t{\n\t\tportNumber = scsiPort;\n\t\ttargetId = scsiTargetId;\n\t}\n\n\tdrive.Format(L\"\\\\\\\\.\\\\Scsi%d:\", portNumber);\n\n\tHANDLE hIoCtrl = CreateFile(drive, GENERIC_READ | GENERIC_WRITE,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\tif (hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn FALSE;\n\t}\n\tBOOL bRet = 0;\n\n\tNVME_PASS_THROUGH_IOCTL nptwb = {};\n\tDWORD length = sizeof(nptwb);\n\tDWORD dwReturned;\n\n\tmemcpy((UCHAR*)(&nptwb.SrbIoCtrl.Signature[0]), \"NvmeRAID\", NVME_SIG_STR_LEN);\n\tnptwb.SrbIoCtrl.ControlCode = NVME_PASS_THROUGH_SRB_IO_CODE;\n\tnptwb.SrbIoCtrl.Timeout = NVME_PT_TIMEOUT;\n\tnptwb.SrbIoCtrl.HeaderLength = sizeof(SRB_IO_CONTROL);\n\tnptwb.SrbIoCtrl.Length = length - sizeof(SRB_IO_CONTROL);\n\n\tnptwb.SrbIoCtrl.ReturnCode = 0x86000000 + (pathId << 16) + (targetId << 8) + lun;\n\n\tnptwb.Direction = NVME_FROM_DEV_TO_HOST;\n\tnptwb.QueueId = 0;\n\tnptwb.MetaDataLen = 0;\n\tnptwb.DataBufferLen = sizeof(nptwb.DataBuffer);\n\tnptwb.ReturnBufferLen = sizeof(nptwb);\n\n\tnptwb.NVMeCmd[0] = 0x02;  // Log Page\n\tnptwb.NVMeCmd[1] = 0xFFFFFFFF;  // Namespace Identifier (CDW1.NSID)\n\tnptwb.NVMeCmd[10] = 0x7f0002; // Controller or Namespace Structure (CNS)\n\n\tnptwb.DataBuffer[0] = TRUE;\n\n\tbRet = DeviceIoControl(hIoCtrl, IOCTL_SCSI_MINIPORT,\n\t\t&nptwb, length, &nptwb, length, &dwReturned, NULL);\n\n\tif (bRet == FALSE)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += nptwb.DataBuffer[i];\n\t}\n\tif (count == 0)\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(&(asi->SmartReadData), 512, nptwb.DataBuffer, 512);\n\n\tsafeCloseHandle(hIoCtrl);\n\treturn bRet;\n\n\treturn TRUE;\n}\n\n/*---------------------------------------------------------------------------*/\n// NVMe Storage Query\n// Reference: http://naraeon.net/en/archives/1338\n/*---------------------------------------------------------------------------*/\n\nBOOL CAtaSmart::DoIdentifyDeviceNVMeStorageQuery(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data, DWORD* diskSize)\n{\n\tCString path;\n\tpath.Format(L\"\\\\\\\\.\\\\PhysicalDrive%d\", physicalDriveId);\n\n\tHANDLE hIoCtrl = CreateFile(path, GENERIC_READ | GENERIC_WRITE,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\n\tStorageQuery::TStorageQueryWithBuffer nptwb;\n\tBOOL bRet = 0;\n\tZeroMemory(&nptwb, sizeof(nptwb));\n\n\tnptwb.ProtocolSpecific.ProtocolType = StorageQuery::ProtocolTypeNvme;\n\tnptwb.ProtocolSpecific.DataType = StorageQuery::NVMeDataTypeIdentify;\n\tnptwb.ProtocolSpecific.ProtocolDataOffset = sizeof(StorageQuery::TStorageProtocolSpecificData);\n\tnptwb.ProtocolSpecific.ProtocolDataLength = 4096;\n\tnptwb.ProtocolSpecific.ProtocolDataRequestValue = 0;\n\tnptwb.ProtocolSpecific.ProtocolDataRequestSubValue = 1;\n\tnptwb.Query.PropertyId = StorageQuery::StorageAdapterProtocolSpecificProperty;\n\tnptwb.Query.QueryType = StorageQuery::PropertyStandardQuery;\n\tDWORD dwReturned = 0;\n\t\n\tbRet = DeviceIoControl(hIoCtrl, IOCTL_STORAGE_QUERY_PROPERTY,\n\t\t&nptwb, sizeof(nptwb), &nptwb, sizeof(nptwb), &dwReturned, NULL);\n\n\tif (bRet)\n\t{\n\t\tULONG64 totalLBA = *(ULONG64*)&nptwb.Buffer[0];\n\t\tint sectorSize = 1 << nptwb.Buffer[130];\n\t\t*diskSize = (DWORD)(totalLBA * sectorSize / 1000 / 1000);\n\t}\n\n\tZeroMemory(&nptwb, sizeof(nptwb));\n\tnptwb.ProtocolSpecific.ProtocolType = StorageQuery::ProtocolTypeNvme;\n\tnptwb.ProtocolSpecific.DataType = StorageQuery::NVMeDataTypeIdentify;\n\tnptwb.ProtocolSpecific.ProtocolDataOffset = sizeof(StorageQuery::TStorageProtocolSpecificData);\n\tnptwb.ProtocolSpecific.ProtocolDataLength = 4096;\n\tnptwb.Query.PropertyId = StorageQuery::StorageAdapterProtocolSpecificProperty;\n\tnptwb.Query.QueryType = StorageQuery::PropertyStandardQuery;\n\tnptwb.ProtocolSpecific.ProtocolDataRequestValue = 1; /*NVME_IDENTIFY_CNS_CONTROLLER*/\n\tnptwb.ProtocolSpecific.ProtocolDataRequestSubValue = 0;\n\tdwReturned = 0;\n\n\tbRet = DeviceIoControl(hIoCtrl, IOCTL_STORAGE_QUERY_PROPERTY,\n\t\t&nptwb, sizeof(nptwb), &nptwb, sizeof(nptwb), &dwReturned, NULL);\n\tsafeCloseHandle(hIoCtrl);\n\n\tmemcpy_s(data, sizeof(NVME_IDENTIFY_DEVICE), nptwb.Buffer, sizeof(NVME_IDENTIFY_DEVICE));\n\n\treturn bRet;\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeStorageQuery(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tCString path;\n\tpath.Format(L\"\\\\\\\\.\\\\PhysicalDrive%d\", physicalDriveId);\n\n\tHANDLE hIoCtrl = CreateFile(path, GENERIC_READ | GENERIC_WRITE,\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\tBOOL bRet = 0;\n\n\tStorageQuery::TStorageQueryWithBuffer nptwb = {};\n\t//ZeroMemory(&nptwb, sizeof(nptwb));\n\n\tnptwb.ProtocolSpecific.ProtocolType = StorageQuery::ProtocolTypeNvme;\n\tnptwb.ProtocolSpecific.DataType = StorageQuery::NVMeDataTypeLogPage;\n\tnptwb.ProtocolSpecific.ProtocolDataRequestValue = 2; // SMART Health Information\n\tnptwb.ProtocolSpecific.ProtocolDataRequestSubValue = 0x00000000;\n\tnptwb.ProtocolSpecific.ProtocolDataOffset = sizeof(StorageQuery::TStorageProtocolSpecificData);\n\tnptwb.ProtocolSpecific.ProtocolDataLength = 4096;\n\tnptwb.Query.PropertyId = StorageQuery::StorageAdapterProtocolSpecificProperty;\n\tnptwb.Query.QueryType = StorageQuery::PropertyStandardQuery;\n\tDWORD dwReturned = 0;\n\n\tbRet = DeviceIoControl(hIoCtrl, IOCTL_STORAGE_QUERY_PROPERTY,\n\t\t&nptwb, sizeof(nptwb), &nptwb, sizeof(nptwb), &dwReturned, NULL);\n\tif (!bRet)\n\t{\n\t\tnptwb.ProtocolSpecific.ProtocolDataRequestSubValue = 0xFFFFFFFF;\n\t\tbRet = DeviceIoControl(hIoCtrl, IOCTL_STORAGE_QUERY_PROPERTY,\n\t\t\t&nptwb, sizeof(nptwb), &nptwb, sizeof(nptwb), &dwReturned, NULL);\n\t}\n\n\tsafeCloseHandle(hIoCtrl);\n\n\tmemcpy_s(&(asi->SmartReadData), 512, nptwb.Buffer, 512);\n\n\treturn bRet;\n}\n\n/*---------------------------------------------------------------------------*/\n//  \\\\\\\\.\\\\ScsiX\n/*---------------------------------------------------------------------------*/\n\nBOOL CAtaSmart::DoIdentifyDeviceScsi(INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data)\n{\n\tint done = FALSE;\n\t//int controller = 0;\n\t//int current = 0;\n\tHANDLE hScsiDriveIOCTL = 0;\n\tCString driveName;\n\tdriveName.Format(_T(\"\\\\\\\\.\\\\Scsi%d:\"), scsiPort);\n\thScsiDriveIOCTL = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n\tif(hScsiDriveIOCTL != INVALID_HANDLE_VALUE)\n\t{\n\t\tBYTE buffer[sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE] = {};\n\t\tSRB_IO_CONTROL *p = (SRB_IO_CONTROL *)buffer;\n\t\tSENDCMDINPARAMS *pin = (SENDCMDINPARAMS *)(buffer + sizeof(SRB_IO_CONTROL));\n\t\tDWORD dummy = 0;\n\t\t\n\t\t//memset(buffer, 0, sizeof(buffer));\n\t\tp->HeaderLength = sizeof (SRB_IO_CONTROL);\n\t\tp->Timeout = 2;\n\t\tp->Length = sizeof(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE;\n\t\tp->ControlCode = IOCTL_SCSI_MINIPORT_IDENTIFY;\n\t\tmemcpy((char *)p->Signature, \"SCSIDISK\", 8);\n\t\tpin->irDriveRegs.bCommandReg = ID_CMD;\n\t\tpin->bDriveNumber = (BYTE)scsiTargetId;\n\t\t\n\t\tif(DeviceIoControl(hScsiDriveIOCTL, IOCTL_SCSI_MINIPORT, \n\t\t\t\t\t\t\t\tbuffer, sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDINPARAMS) - 1,\n\t\t\t\t\t\t\t\tbuffer, sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE,\n\t\t\t\t\t\t\t\t&dummy, NULL))\n\t\t{\n\t\t\tSENDCMDOUTPARAMS *pOut = (SENDCMDOUTPARAMS *)(buffer + sizeof(SRB_IO_CONTROL));\n\t\t\tif(*(pOut->bBuffer) > 0)\n\t\t\t{\n\t\t\t\tdone = TRUE;\n\t\t\t\tmemcpy_s(data, sizeof(ATA_IDENTIFY_DEVICE), pOut->bBuffer, sizeof(ATA_IDENTIFY_DEVICE));\n\t\t\t}\n\t\t}\n\t\tsafeCloseHandle(hScsiDriveIOCTL);\n\t}\n\treturn done;\n}\n\nBOOL CAtaSmart::GetSmartAttributeScsi(INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tHANDLE hScsiDriveIOCTL = 0;\n\tCString driveName;\n\tdriveName.Format(_T(\"\\\\\\\\.\\\\Scsi%d:\"), scsiPort);\n\thScsiDriveIOCTL = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n\tif(hScsiDriveIOCTL != INVALID_HANDLE_VALUE)\n\t{\n\t\tBYTE buffer[sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDOUTPARAMS) + READ_ATTRIBUTE_BUFFER_SIZE] = {};\n\t\tSRB_IO_CONTROL *p = (SRB_IO_CONTROL *)buffer;\n\t\tSENDCMDINPARAMS *pin = (SENDCMDINPARAMS *)(buffer + sizeof(SRB_IO_CONTROL));\n\t\tDWORD dummy = 0;\n\t\t//memset(buffer, 0, sizeof(buffer));\n\t\tp->HeaderLength = sizeof(SRB_IO_CONTROL);\n\t\tp->Timeout = 2;\n\t\tp->Length = sizeof(SENDCMDOUTPARAMS) + READ_ATTRIBUTE_BUFFER_SIZE;\n\t\tp->ControlCode = IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS;\n\t\tmemcpy((char *)p->Signature, \"SCSIDISK\", 8);\n\t\tpin->irDriveRegs.bFeaturesReg\t\t= READ_ATTRIBUTES;\n\t\tpin->irDriveRegs.bSectorCountReg\t= 1;\n\t\tpin->irDriveRegs.bSectorNumberReg\t= 1;\n\t\tpin->irDriveRegs.bCylLowReg\t\t\t= SMART_CYL_LOW;\n\t\tpin->irDriveRegs.bCylHighReg\t\t= SMART_CYL_HI;\n\t\tpin->irDriveRegs.bCommandReg\t\t= SMART_CMD;\n\t\tpin->cBufferSize\t\t\t\t\t= READ_ATTRIBUTE_BUFFER_SIZE;\n\t\tpin->bDriveNumber\t\t\t\t\t= (BYTE)scsiTargetId;\n\n\t\tif(DeviceIoControl(hScsiDriveIOCTL, IOCTL_SCSI_MINIPORT, \n\t\t\t\t\t\t\t\tbuffer, sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDINPARAMS) - 1,\n\t\t\t\t\t\t\t\tbuffer, sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDOUTPARAMS) + READ_ATTRIBUTE_BUFFER_SIZE,\n\t\t\t\t\t\t\t\t&dummy, NULL))\n\t\t{\n\t\t\tSENDCMDOUTPARAMS *pOut = (SENDCMDOUTPARAMS *)(buffer + sizeof(SRB_IO_CONTROL));\n\n\t\t\tmemcpy_s(&(asi->SmartReadData), 512, &(pOut->bBuffer), 512);\n\t\t\tsafeCloseHandle(hScsiDriveIOCTL);\n\t\t\treturn FillSmartData(asi);\n\t\t}\n\t}\n\treturn FALSE;\n}\n\nBOOL CAtaSmart::GetSmartThresholdScsi(INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tHANDLE hScsiDriveIOCTL = 0;\n\tCString driveName;\n\tdriveName.Format(_T(\"\\\\\\\\.\\\\Scsi%d:\"), scsiPort);\n\thScsiDriveIOCTL = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n\tif(hScsiDriveIOCTL != INVALID_HANDLE_VALUE)\n\t{\n\t\tBYTE buffer[sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDOUTPARAMS) + READ_THRESHOLD_BUFFER_SIZE] = {};\n\t\tSRB_IO_CONTROL *p = (SRB_IO_CONTROL *)buffer;\n\t\tSENDCMDINPARAMS *pin = (SENDCMDINPARAMS *)(buffer + sizeof(SRB_IO_CONTROL));\n\t\tDWORD dummy = 0;\n\t\t//memset(buffer, 0, sizeof(buffer));\n\t\tp->HeaderLength = sizeof(SRB_IO_CONTROL);\n\t\tp->Timeout = 2;\n\t\tp->Length = sizeof(SENDCMDOUTPARAMS) + READ_THRESHOLD_BUFFER_SIZE;\n\t\tp->ControlCode = IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS;\n\t\tmemcpy((char *)p->Signature, \"SCSIDISK\", 8);\n\t\tpin->irDriveRegs.bFeaturesReg\t\t= READ_THRESHOLDS;\n\t\tpin->irDriveRegs.bSectorCountReg\t= 1;\n\t\tpin->irDriveRegs.bSectorNumberReg\t= 1;\n\t\tpin->irDriveRegs.bCylLowReg\t\t\t= SMART_CYL_LOW;\n\t\tpin->irDriveRegs.bCylHighReg\t\t= SMART_CYL_HI;\n\t\tpin->irDriveRegs.bCommandReg\t\t= SMART_CMD;\n\t\tpin->cBufferSize\t\t\t\t\t= READ_THRESHOLD_BUFFER_SIZE;\n\t\tpin->bDriveNumber\t\t\t\t\t= (BYTE)scsiTargetId;\n\n\t\tif(DeviceIoControl(hScsiDriveIOCTL, IOCTL_SCSI_MINIPORT, \n\t\t\t\t\t\t\t\tbuffer, sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDINPARAMS) - 1,\n\t\t\t\t\t\t\t\tbuffer, sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDOUTPARAMS) + READ_THRESHOLD_BUFFER_SIZE,\n\t\t\t\t\t\t\t\t&dummy, NULL))\n\t\t{\n\t\t\tSENDCMDOUTPARAMS *pOut = (SENDCMDOUTPARAMS *)(buffer + sizeof(SRB_IO_CONTROL));\n\t\t\tif(*(pOut->bBuffer) > 0)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tmemcpy_s(&(asi->SmartReadThreshold), 512, &(pOut->bBuffer), 512);\n\t\t\t\tsafeCloseHandle(hScsiDriveIOCTL);\n\t\t\t\treturn FillSmartThreshold(asi);\n\t\t\t}\n\t\t}\n\t}\n\treturn FALSE;\n}\n\nBOOL CAtaSmart::ControlSmartStatusScsi(INT scsiPort, INT scsiTargetId, BYTE command)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE hScsiDriveIOCTL = 0;\n\tCString driveName;\n\tdriveName.Format(_T(\"\\\\\\\\.\\\\Scsi%d:\"), scsiPort);\n\thScsiDriveIOCTL = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n\tif(hScsiDriveIOCTL != INVALID_HANDLE_VALUE)\n\t{\n\t\tBYTE buffer[sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDOUTPARAMS) + SCSI_MINIPORT_BUFFER_SIZE] = {};\n\t\tSRB_IO_CONTROL *p = (SRB_IO_CONTROL *)buffer;\n\t\tSENDCMDINPARAMS *pin = (SENDCMDINPARAMS *)(buffer + sizeof(SRB_IO_CONTROL));\n\t\tDWORD dummy = 0;\n\t\t//memset(buffer, 0, sizeof(buffer));\n\t\tp->HeaderLength = sizeof(SRB_IO_CONTROL);\n\t\tp->Timeout = 2;\n\t\tp->Length = sizeof(SENDCMDOUTPARAMS) + SCSI_MINIPORT_BUFFER_SIZE;\n\t\tif(command == DISABLE_SMART)\n\t\t{\n\t\t\tp->ControlCode = IOCTL_SCSI_MINIPORT_DISABLE_SMART;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp->ControlCode = IOCTL_SCSI_MINIPORT_ENABLE_SMART;\n\t\t}\n\t\tmemcpy((char *)p->Signature, \"SCSIDISK\", 8);\n\t\tpin->irDriveRegs.bFeaturesReg\t\t= command;\n\t\tpin->irDriveRegs.bSectorCountReg\t= 1;\n\t\tpin->irDriveRegs.bSectorNumberReg\t= 1;\n\t\tpin->irDriveRegs.bCylLowReg\t\t\t= SMART_CYL_LOW;\n\t\tpin->irDriveRegs.bCylHighReg\t\t= SMART_CYL_HI;\n\t\tpin->irDriveRegs.bCommandReg\t\t= SMART_CMD;\n\t\tpin->cBufferSize\t\t\t\t\t= SCSI_MINIPORT_BUFFER_SIZE;\n\t\tpin->bDriveNumber\t\t\t\t\t= (BYTE)scsiTargetId;\n\n\t\tbRet = DeviceIoControl(hScsiDriveIOCTL, IOCTL_SCSI_MINIPORT, \n\t\t\t\t\t\t\t\tbuffer, sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDINPARAMS) - 1,\n\t\t\t\t\t\t\t\tbuffer, sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDOUTPARAMS) + SCSI_MINIPORT_BUFFER_SIZE,\n\t\t\t\t\t\t\t\t&dummy, NULL);\n\t\tsafeCloseHandle(hScsiDriveIOCTL);\n\t\treturn bRet;\n\t}\n\n\treturn FALSE;\n}\n\n\nBOOL CAtaSmart::SendAtaCommandScsi(INT scsiPort, INT scsiTargetId, BYTE main, BYTE sub, BYTE param)\n{\n/** Does not work...\n\tBOOL\tbRet = FALSE;\n\tHANDLE hScsiDriveIOCTL = 0;\n\tCString driveName;\n\tdriveName.Format(_T(\"\\\\\\\\.\\\\Scsi%d:\"), scsiPort);\n\thScsiDriveIOCTL = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n\tif(hScsiDriveIOCTL != INVALID_HANDLE_VALUE)\n\t{\n\t\tDWORD dummy;\n\t\tCMD_ATA_PASS_THROUGH_WITH_BUFFERS capt;\n\t\t::ZeroMemory(&capt, sizeof(CMD_ATA_PASS_THROUGH_WITH_BUFFERS));\n\t\tcapt.apt.Length = sizeof(CMD_ATA_PASS_THROUGH);\n\t\tcapt.apt.PathId = 0;\n\t\tcapt.apt.TargetId = 0;\n\t\tcapt.apt.Lun = 0;\n\t\tcapt.apt.TimeOutValue = 10;\n\n\t\tDWORD size = offsetof(CMD_ATA_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\t\tcapt.apt.DataBufferOffset = size;\n\n\t\tcapt.apt.AtaFlags = 0x02;\n\t\tcapt.apt.DataTransferLength = 512;\n\t\tsize += 512;\n\t\tcapt.DataBuf[0] = 0xCF;\n\n\t\tcapt.apt.CurrentTaskFile.bFeaturesReg= sub;\n\t\tcapt.apt.CurrentTaskFile.bSectorCountReg = param;\n\t\tcapt.apt.CurrentTaskFile.bDriveHeadReg = 0xA0;\n\t\tcapt.apt.CurrentTaskFile.bCommandReg = main;\n\n\t\tbRet = DeviceIoControl(hScsiDriveIOCTL, IOCTL_ATA_PASS_THROUGH, \n\t\t\t\t\t\t\t\t&capt, size,\n\t\t\t\t\t\t\t\t&capt, size,\n\t\t\t\t\t\t\t\t&dummy, NULL);\n\t}\n\tsafeCloseHandle(hScsiDriveIOCTL);\n\n\treturn bRet;\n*/\n\treturn FALSE;\n}\n\n/*---------------------------------------------------------------------------*/\n//  SCSI / ATA Translation (SAT) \n/*---------------------------------------------------------------------------*/\n\nBOOL CAtaSmart::DoIdentifyDeviceSat(INT physicalDriveId, BYTE target, IDENTIFY_DEVICE* data, COMMAND_TYPE type)\n{\n\tCString debug;\n\tdebug.Format(L\"DoIdentifyDeviceSat pd=%d, tt=%d, ct=%d\", physicalDriveId, target, type);\n\tDebugPrint(debug);\n\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD\tlength = 0;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\n\tif (data == NULL)\n\t{\n\t\tDebugPrint(L\"data == NULL\");\n\t\treturn\tFALSE;\n\t}\n\n\t::ZeroMemory(data, sizeof(ATA_IDENTIFY_DEVICE));\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\tDebugPrint(L\"! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE\");\n\t\treturn\tFALSE;\n\t}\n\n\t//::ZeroMemory(&sptwb, sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));\n\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = IDENTIFY_BUFFER_SIZE;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\n\t// DEBUG\n\t//\tCString cstr;\n\t//\tcstr.Format(_T(\"DoIdentifyDevice TYPE=%d\"), (DWORD)type);\n\t//\tDebugPrint(cstr);\n\n\tif (type == CMD_TYPE_SAT)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1;//ATA PASS THROUGH(12) OPERATION CODE(A1h)\n\t\tsptwb.Spt.Cdb[1] = (4 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = 0;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 1;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 0;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = 0;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = 0;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = ID_CMD;//COMMAND\n\t}\n\telse if (type == CMD_TYPE_SAT_ASM1352R)\n\t{\n\t\t// PROTOCOL field should be \"0Dh”SATA port0 and \"0Eh\" SATA port1.\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1;//ATA PASS THROUGH(12) OPERATION CODE(A1h)\n\t\tsptwb.Spt.Cdb[1] = (0xE << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = 0;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 1;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 0;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = 0;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = 0;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = ID_CMD;//COMMAND\n\t}\n\telse if (type == CMD_TYPE_SAT_REALTEK9220DP)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1;//ATA PASS THROUGH(12) OPERATION CODE(A1h)\n\t\tsptwb.Spt.Cdb[1] = (4 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = 0;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 1;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 0;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = 0;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = 0;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = ID_CMD;//COMMAND\n\t}\n\telse if (type == CMD_TYPE_SUNPLUS)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xF8;\n\t\tsptwb.Spt.Cdb[1] = 0x00;\n\t\tsptwb.Spt.Cdb[2] = 0x22;\n\t\tsptwb.Spt.Cdb[3] = 0x10;\n\t\tsptwb.Spt.Cdb[4] = 0x01;\n\t\tsptwb.Spt.Cdb[5] = 0x00;\n\t\tsptwb.Spt.Cdb[6] = 0x01;\n\t\tsptwb.Spt.Cdb[7] = 0x00;\n\t\tsptwb.Spt.Cdb[8] = 0x00;\n\t\tsptwb.Spt.Cdb[9] = 0x00;\n\t\tsptwb.Spt.Cdb[10] = target;\n\t\tsptwb.Spt.Cdb[11] = 0xEC; // ID_CMD\n\t}\n\telse if (type == CMD_TYPE_IO_DATA)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xE3;\n\t\tsptwb.Spt.Cdb[1] = 0x00;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0x01;\n\t\tsptwb.Spt.Cdb[4] = 0x01;\n\t\tsptwb.Spt.Cdb[5] = 0x00;\n\t\tsptwb.Spt.Cdb[6] = 0x00;\n\t\tsptwb.Spt.Cdb[7] = target;\n\t\tsptwb.Spt.Cdb[8] = 0xEC;  // ID_CMD\n\t\tsptwb.Spt.Cdb[9] = 0x00;\n\t\tsptwb.Spt.Cdb[10] = 0x00;\n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t}\n\telse if (type == CMD_TYPE_LOGITEC)\n\t{\n\t\tsptwb.Spt.CdbLength = 10;\n\t\tsptwb.Spt.Cdb[0] = 0xE0;\n\t\tsptwb.Spt.Cdb[1] = 0x00;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0x00;\n\t\tsptwb.Spt.Cdb[4] = 0x00;\n\t\tsptwb.Spt.Cdb[5] = 0x00;\n\t\tsptwb.Spt.Cdb[6] = 0x00;\n\t\tsptwb.Spt.Cdb[7] = target;\n\t\tsptwb.Spt.Cdb[8] = 0xEC;  // ID_CMD\n\t\tsptwb.Spt.Cdb[9] = 0x4C;\n\t}\n\telse if (type == CMD_TYPE_PROLIFIC)\n\t{\n\t\tsptwb.Spt.CdbLength = 16;\n\t\tsptwb.Spt.Cdb[0] = 0xD8;\n\t\tsptwb.Spt.Cdb[1] = 0x15;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0x00;\n\t\tsptwb.Spt.Cdb[4] = 0x06;\n\t\tsptwb.Spt.Cdb[5] = 0x7B;\n\t\tsptwb.Spt.Cdb[6] = 0x00;\n\t\tsptwb.Spt.Cdb[7] = 0x00;\n\t\tsptwb.Spt.Cdb[8] = 0x02;\n\t\tsptwb.Spt.Cdb[9] = 0x00;\n\t\tsptwb.Spt.Cdb[10] = 0x01;\n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t\tsptwb.Spt.Cdb[12] = 0x00;\n\t\tsptwb.Spt.Cdb[13] = 0x00;\n\t\tsptwb.Spt.Cdb[14] = target; // \n\t\tsptwb.Spt.Cdb[15] = 0xEC; // ID_CMD\n\t}\n\telse if (type == CMD_TYPE_JMICRON)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xDF;\n\t\tsptwb.Spt.Cdb[1] = 0x10;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0x02;\n\t\tsptwb.Spt.Cdb[4] = 0x00;\n\t\tsptwb.Spt.Cdb[5] = 0x00;\n\t\tsptwb.Spt.Cdb[6] = 0x01;\n\t\tsptwb.Spt.Cdb[7] = 0x00;\n\t\tsptwb.Spt.Cdb[8] = 0x00;\n\t\tsptwb.Spt.Cdb[9] = 0x00;\n\t\tsptwb.Spt.Cdb[10] = target;\n\t\tsptwb.Spt.Cdb[11] = 0xEC; // ID_CMD\n\t}\n\telse if (type == CMD_TYPE_CYPRESS)\n\t{\n\t\tsptwb.Spt.CdbLength = 16;\n\t\tsptwb.Spt.Cdb[0] = 0x24;\n\t\tsptwb.Spt.Cdb[1] = 0x24;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0xBE;\n\t\tsptwb.Spt.Cdb[4] = 0x01;\n\t\tsptwb.Spt.Cdb[5] = 0x00;\n\t\tsptwb.Spt.Cdb[6] = 0x00;\n\t\tsptwb.Spt.Cdb[7] = 0x01;\n\t\tsptwb.Spt.Cdb[8] = 0x00;\n\t\tsptwb.Spt.Cdb[9] = 0x00;\n\t\tsptwb.Spt.Cdb[10] = 0x00;\n\t\tsptwb.Spt.Cdb[11] = target;\n\t\tsptwb.Spt.Cdb[12] = 0xEC; // ID_CMD\n\t\tsptwb.Spt.Cdb[13] = 0x00;\n\t\tsptwb.Spt.Cdb[14] = 0x00;\n\t\tsptwb.Spt.Cdb[15] = 0x00;\n\t}\n\t/*\n\telse if(type == CMD_TYPE_DEBUG)\n\t{\n\tsptwb.Spt.CdbLength = 16;\n\tfor(int i = 0xA0; i <= 0xFF; i++)\n\t{\n\tfor(int j = 8; j < 16; j++)\n\t{\n\t::ZeroMemory(&sptwb.Spt.Cdb, 16);\n\tsptwb.Spt.Cdb[0] = i;\n\tsptwb.Spt.Cdb[j - 1] = 0xA0;\n\tsptwb.Spt.Cdb[j] = 0xEC;\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t&sptwb, sizeof(SCSI_PASS_THROUGH),\n\t&sptwb, length,\t&dwReturned, NULL);\n\n\n\tif(bRet == FALSE || dwReturned != length)\n\t{\n\tcontinue;\n\t}\n\n\tCString cstr;\n\tcstr.Format(_T(\"i = %d, j = %d\"), i, j);\n\tAfxMessageBox(cstr);\n\n\tsafeCloseHandle(hIoCtrl);\n\tmemcpy_s(data, sizeof(ATA_IDENTIFY_DEVICE), sptwb.DataBuf, sizeof(ATA_IDENTIFY_DEVICE));\n\n\treturn TRUE;\n\t}\n\t}\n\t}\n\t*/\n\telse\n\t{\n\t\tDebugPrint(L\"COMMAND_TYPE_UNKNOWN\");\n\t\treturn FALSE;\n\t}\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, sizeof(SCSI_PASS_THROUGH),\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tsafeCloseHandle(hIoCtrl);\n\n\tif (bRet == FALSE || dwReturned != length)\n\t{\n\t\t\n\t\tdebug.Format(L\"bRet == FALSE || dwReturned != length / Error Coce: %08X\", GetLastError());\n\t\tDebugPrint(debug);\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += sptwb.DataBuf[i];\n\t}\n\tif (count == 0) // || sptwb.DataBuf[510] != 0xA5\n\t{\n\t\tDebugPrint(L\"count=0\");\n\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(data, sizeof(ATA_IDENTIFY_DEVICE), sptwb.DataBuf, sizeof(ATA_IDENTIFY_DEVICE));\n\n\treturn\tTRUE;\n}\n\nBOOL CAtaSmart::GetSmartAttributeSat(INT PhysicalDriveId, BYTE target, ATA_SMART_INFO* asi)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD length;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\n\thIoCtrl = GetIoCtrlHandle(PhysicalDriveId);\n\tif(! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t//::ZeroMemory(&sptwb,sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));\n\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = READ_ATTRIBUTE_BUFFER_SIZE;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\n// DEBUG\n//\tCString cstr;\n//\tcstr.Format(_T(\"SmartAttribute TYPE=%d\"), asi->CommandType);\n//\tDebugPrint(cstr);\n\n\tCOMMAND_TYPE type = asi->CommandType;\n\tif(type == CMD_TYPE_SAT)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1;//ATA PASS THROUGH(12) OPERATION CODE(A1h)\n\t\tsptwb.Spt.Cdb[1] = (4 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = READ_ATTRIBUTES;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 1;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 1;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = SMART_CYL_LOW;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = SMART_CYL_HI;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = SMART_CMD;//COMMAND\n\t}\n\telse if (type == CMD_TYPE_SAT_ASM1352R)\n\t{\n\t\t// PROTOCOL field should be \"0Dh”SATA port0 and \"0Eh\" SATA port1.\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1;//ATA PASS THROUGH(12) OPERATION CODE(A1h)\n\t\tsptwb.Spt.Cdb[1] = (0xE << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = READ_ATTRIBUTES;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 1;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 1;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = SMART_CYL_LOW;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = SMART_CYL_HI;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = SMART_CMD;//COMMAND\n\t}\n\telse if (type == CMD_TYPE_SAT_REALTEK9220DP)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1;//ATA PASS THROUGH(12) OPERATION CODE(A1h)\n\t\tsptwb.Spt.Cdb[1] = (4 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = READ_ATTRIBUTES;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 1;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 1;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = SMART_CYL_LOW;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = SMART_CYL_HI;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = SMART_CMD;//COMMAND\n\t}\n\telse if(type == CMD_TYPE_SUNPLUS)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xF8;\n\t\tsptwb.Spt.Cdb[1] = 0x00;\n\t\tsptwb.Spt.Cdb[2] = 0x22;\n\t\tsptwb.Spt.Cdb[3] = 0x10;\n\t\tsptwb.Spt.Cdb[4] = 0x01;\n\t\tsptwb.Spt.Cdb[5] = 0xD0;  // READ_ATTRIBUTES\n\t\tsptwb.Spt.Cdb[6] = 0x01; \n\t\tsptwb.Spt.Cdb[7] = 0x00; \n\t\tsptwb.Spt.Cdb[8] = 0x4F;  // SMART_CYL_LOW \n\t\tsptwb.Spt.Cdb[9] = 0xC2;  // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[10] = target; \n\t\tsptwb.Spt.Cdb[11] = 0xB0; // SMART_CMD\n\t}\n\telse if(type == CMD_TYPE_IO_DATA)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xE3;\n\t\tsptwb.Spt.Cdb[1] = 0x00; // ?\n\t\tsptwb.Spt.Cdb[2] = 0xD0; // READ_ATTRIBUTES\n\t\tsptwb.Spt.Cdb[3] = 0x00; // ?\n\t\tsptwb.Spt.Cdb[4] = 0x00; // ?\n\t\tsptwb.Spt.Cdb[5] = 0x4F; // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[6] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[7] = target; // \n\t\tsptwb.Spt.Cdb[8] = 0xB0; // SMART_CMD\n\t\tsptwb.Spt.Cdb[9] = 0x00;  \n\t\tsptwb.Spt.Cdb[10] = 0x00; \n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t}\n\telse if(type == CMD_TYPE_LOGITEC)\n\t{\n\t\tsptwb.Spt.CdbLength = 10;\n\t\tsptwb.Spt.Cdb[0] = 0xE0;\n\t\tsptwb.Spt.Cdb[1] = 0x00;\n\t\tsptwb.Spt.Cdb[2] = 0xD0; // READ_ATTRIBUTES\n\t\tsptwb.Spt.Cdb[3] = 0x00; \n\t\tsptwb.Spt.Cdb[4] = 0x00;\n\t\tsptwb.Spt.Cdb[5] = 0x4F; // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[6] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[7] = target; \n\t\tsptwb.Spt.Cdb[8] = 0xB0; // SMART_CMD\n\t\tsptwb.Spt.Cdb[9] = 0x4C;\n\t}\n\telse if (type == CMD_TYPE_PROLIFIC)\n\t{\n\t\tsptwb.Spt.CdbLength = 16;\n\t\tsptwb.Spt.Cdb[0] = 0xD8;\n\t\tsptwb.Spt.Cdb[1] = 0x15;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0xD0; // READ_ATTRIBUTES\n\t\tsptwb.Spt.Cdb[4] = 0x06;\n\t\tsptwb.Spt.Cdb[5] = 0x7B;\n\t\tsptwb.Spt.Cdb[6] = 0x00;\n\t\tsptwb.Spt.Cdb[7] = 0x00;\n\t\tsptwb.Spt.Cdb[8] = 0x02;\n\t\tsptwb.Spt.Cdb[9] = 0x00;\n\t\tsptwb.Spt.Cdb[10] = 0x01;\n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t\tsptwb.Spt.Cdb[12] = 0x4F; // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[13] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[14] = target; // \n\t\tsptwb.Spt.Cdb[15] = 0xB0;// SMART_CMD\n\t}\n\telse if(type == CMD_TYPE_JMICRON)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xDF;\n\t\tsptwb.Spt.Cdb[1] = 0x10;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0x02;\n\t\tsptwb.Spt.Cdb[4] = 0x00;\n\t\tsptwb.Spt.Cdb[5] = 0xD0;  // READ_ATTRIBUTES\n\t\tsptwb.Spt.Cdb[6] = 0x01; \n\t\tsptwb.Spt.Cdb[7] = 0x01; \n\t\tsptwb.Spt.Cdb[8] = 0x4F;  // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[9] = 0xC2;  // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[10] = target; \n\t\tsptwb.Spt.Cdb[11] = 0xB0; // SMART_CMD\n\t}\n\telse if(type == CMD_TYPE_CYPRESS)\n\t{\n\t\tsptwb.Spt.CdbLength = 16;\n\t\tsptwb.Spt.Cdb[0] = 0x24;\n\t\tsptwb.Spt.Cdb[1] = 0x24;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0xBE;\n\t\tsptwb.Spt.Cdb[4] = 0x01;\n\t\tsptwb.Spt.Cdb[5] = 0x00; \n\t\tsptwb.Spt.Cdb[6] = 0xD0;  // READ_ATTRIBUTES\n\t\tsptwb.Spt.Cdb[7] = 0x00; \n\t\tsptwb.Spt.Cdb[8] = 0x00;\n\t\tsptwb.Spt.Cdb[9] = 0x4F;  // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[10] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[11] = target;\n\t\tsptwb.Spt.Cdb[12] = 0xB0; // ID_CMD\n\t\tsptwb.Spt.Cdb[13] = 0x00;\n\t\tsptwb.Spt.Cdb[14] = 0x00;\n\t\tsptwb.Spt.Cdb[15] = 0x00;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH, \n\t\t&sptwb, sizeof(SCSI_PASS_THROUGH),\n\t\t&sptwb, length,\t&dwReturned, NULL);\n\n\tsafeCloseHandle(hIoCtrl);\n\t\n\tif(bRet == FALSE || dwReturned != length)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD count = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tcount += sptwb.DataBuf[i];\n\t}\n\tif (count == 0)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(&(asi->SmartReadData), 512, &(sptwb.DataBuf), 512);\n\treturn FillSmartData(asi);\n}\n\nBOOL CAtaSmart::GetSmartThresholdSat(INT physicalDriveId, BYTE target, ATA_SMART_INFO* asi)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\tDWORD length = 0;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\tif(! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t//::ZeroMemory(&sptwb,sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));\n\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = READ_THRESHOLD_BUFFER_SIZE;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\n// DEBUG\n//\tCString cstr;\n//\tcstr.Format(_T(\"SmartThreshold TYPE=%d\"), asi->CommandType);\n//\tDebugPrint(cstr);\n\n\tCOMMAND_TYPE type = asi->CommandType;\n\tif(type == CMD_TYPE_SAT)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1; ////ATA PASS THROUGH(12) OPERATION CODE (A1h)\n\t\tsptwb.Spt.Cdb[1] = (4 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = READ_THRESHOLDS;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 1;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 1;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = SMART_CYL_LOW;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = SMART_CYL_HI;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = SMART_CMD;//COMMAND\n\t}\n\telse if (type == CMD_TYPE_SAT_ASM1352R)\n\t{\n\t\t// PROTOCOL field should be \"0Dh”SATA port0 and \"0Eh\" SATA port1.\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1; ////ATA PASS THROUGH(12) OPERATION CODE (A1h)\n\t\tsptwb.Spt.Cdb[1] = (0xE << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = READ_THRESHOLDS;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 1;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 1;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = SMART_CYL_LOW;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = SMART_CYL_HI;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = SMART_CMD;//COMMAND\n\t}\n\telse if (type == CMD_TYPE_SAT_REALTEK9220DP)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1;//ATA PASS THROUGH(12) OPERATION CODE(A1h)\n\t\tsptwb.Spt.Cdb[1] = (4 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = 0;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 1;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 0;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = 0;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = 0;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = ID_CMD;//COMMAND\n\t}\n\telse if(type == CMD_TYPE_SUNPLUS)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xF8;\n\t\tsptwb.Spt.Cdb[1] = 0x00;\n\t\tsptwb.Spt.Cdb[2] = 0x22;\n\t\tsptwb.Spt.Cdb[3] = 0x10;\n\t\tsptwb.Spt.Cdb[4] = 0x01;\n\t\tsptwb.Spt.Cdb[5] = 0xD1; // READ_THRESHOLD\n\t\tsptwb.Spt.Cdb[6] = 0x01; \n\t\tsptwb.Spt.Cdb[7] = 0x01; \n\t\tsptwb.Spt.Cdb[8] = 0x4F; // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[9] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[10] = target; \n\t\tsptwb.Spt.Cdb[11] = 0xB0;// SMART_CMD\n\t}\n\telse if(type == CMD_TYPE_IO_DATA)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xE3;\n\t\tsptwb.Spt.Cdb[1] = 0x00; // ?\n\t\tsptwb.Spt.Cdb[2] = 0xD1; // READ_THRESHOLD\n\t\tsptwb.Spt.Cdb[3] = 0x00; // ?\n\t\tsptwb.Spt.Cdb[4] = 0x00; // ?\n\t\tsptwb.Spt.Cdb[5] = 0x4F; // SMART_CYL_LOW \n\t\tsptwb.Spt.Cdb[6] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[7] = target; // \n\t\tsptwb.Spt.Cdb[8] = 0xB0; // SMART_CMD\n\t\tsptwb.Spt.Cdb[9] = 0x00;  \n\t\tsptwb.Spt.Cdb[10] = 0x00; \n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t}\n\telse if(type == CMD_TYPE_LOGITEC)\n\t{\n\t\tsptwb.Spt.CdbLength = 10;\n\t\tsptwb.Spt.Cdb[0] = 0xE0;\n\t\tsptwb.Spt.Cdb[1] = 0x00;\n\t\tsptwb.Spt.Cdb[2] = 0xD1; // READ_THRESHOLD\n\t\tsptwb.Spt.Cdb[3] = 0x00;\n\t\tsptwb.Spt.Cdb[4] = 0x00;\n\t\tsptwb.Spt.Cdb[5] = 0x4F; // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[6] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[7] = target; \n\t\tsptwb.Spt.Cdb[8] = 0xB0; // SMART_CMD\n\t\tsptwb.Spt.Cdb[9] = 0x4C;\n\t}\n\telse if (type == CMD_TYPE_PROLIFIC)\n\t{\n\t\tsptwb.Spt.CdbLength = 16;\n\t\tsptwb.Spt.Cdb[0] = 0xD8;\n\t\tsptwb.Spt.Cdb[1] = 0x15;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0xD1; // READ_THRESHOLD\n\t\tsptwb.Spt.Cdb[4] = 0x06;\n\t\tsptwb.Spt.Cdb[5] = 0x7B;\n\t\tsptwb.Spt.Cdb[6] = 0x00;\n\t\tsptwb.Spt.Cdb[7] = 0x00;\n\t\tsptwb.Spt.Cdb[8] = 0x02;\n\t\tsptwb.Spt.Cdb[9] = 0x00;\n\t\tsptwb.Spt.Cdb[10]= 0x01;\n\t\tsptwb.Spt.Cdb[11]= 0x01;\n\t\tsptwb.Spt.Cdb[12]= 0x4F; // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[13]= 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[14]= target; // \n\t\tsptwb.Spt.Cdb[15]= 0xB0;// SMART_CMD\n\t}\n\telse if(type == CMD_TYPE_JMICRON)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xDF;\n\t\tsptwb.Spt.Cdb[1] = 0x10;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0x02;\n\t\tsptwb.Spt.Cdb[4] = 0x00;\n\t\tsptwb.Spt.Cdb[5] = 0xD1;  // READ_THRESHOLD\n\t\tsptwb.Spt.Cdb[6] = 0x01; \n\t\tsptwb.Spt.Cdb[7] = 0x01; \n\t\tsptwb.Spt.Cdb[8] = 0x4F;  // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[9] = 0xC2;  // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[10] = target; \n\t\tsptwb.Spt.Cdb[11] = 0xB0; // SMART_CMD\n\t}\n\telse if(type == CMD_TYPE_CYPRESS)\n\t{\n\t\tsptwb.Spt.CdbLength = 16;\n\t\tsptwb.Spt.Cdb[0] = 0x24;\n\t\tsptwb.Spt.Cdb[1] = 0x24;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0xBE;\n\t\tsptwb.Spt.Cdb[4] = 0x01;\n\t\tsptwb.Spt.Cdb[5] = 0x00; \n\t\tsptwb.Spt.Cdb[6] = 0xD1;  // READ_THRESHOLD  \n\t\tsptwb.Spt.Cdb[7] = 0x00; \n\t\tsptwb.Spt.Cdb[8] = 0x00;\n\t\tsptwb.Spt.Cdb[9] = 0x4F;  // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[10] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[11] = target;\n\t\tsptwb.Spt.Cdb[12] = 0xB0; // ID_CMD\n\t\tsptwb.Spt.Cdb[13] = 0x00;\n\t\tsptwb.Spt.Cdb[14] = 0x00;\n\t\tsptwb.Spt.Cdb[15] = 0x00;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\tlength = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH, \n\t\t&sptwb, sizeof(SCSI_PASS_THROUGH),\n\t\t&sptwb, length,\t&dwReturned, NULL);\n\t\n\tsafeCloseHandle(hIoCtrl);\n\t\n\tif(bRet == FALSE || dwReturned != length)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(&(asi->SmartReadThreshold), 512, &(sptwb.DataBuf), 512);\n\treturn\tFillSmartThreshold(asi);\n}\n\nBOOL CAtaSmart::ControlSmartStatusSat(INT physicalDriveId, BYTE target, BYTE command, COMMAND_TYPE type)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\tif(! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t//::ZeroMemory(&sptwb,sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));\n\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = 0;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\n\tif(type == CMD_TYPE_SAT)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1; //ATA PASS THROUGH (12) OPERATION CODE (A1h)\n\t\tsptwb.Spt.Cdb[1] = (3 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=3(Non-Data),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = command;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 0;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 1;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = SMART_CYL_LOW;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = SMART_CYL_HI;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = SMART_CMD;//COMMAND\n\t}\n\telse if (type == CMD_TYPE_SAT_ASM1352R)\n\t{\n\t\t// PROTOCOL field should be \"0Dh”SATA port0 and \"0Eh\" SATA port1.\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1; //ATA PASS THROUGH (12) OPERATION CODE (A1h)\n\t\tsptwb.Spt.Cdb[1] = (0xE << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=3(Non-Data),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = command;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 0;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 1;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = SMART_CYL_LOW;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = SMART_CYL_HI;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = SMART_CMD;//COMMAND\n\t}\n\telse if (type == CMD_TYPE_SAT_REALTEK9220DP)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1; //ATA PASS THROUGH (12) OPERATION CODE (A1h)\n\t\tsptwb.Spt.Cdb[1] = (3 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=3(Non-Data),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = command;//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = 0;//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 1;//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = SMART_CYL_LOW;//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = SMART_CYL_HI;//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\n\t\tsptwb.Spt.Cdb[9] = SMART_CMD;//COMMAND\n\t}\n\telse if(type == CMD_TYPE_SUNPLUS)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xF8;\n\t\tsptwb.Spt.Cdb[1] = 0x00;\n\t\tsptwb.Spt.Cdb[2] = 0x22;\n\t\tsptwb.Spt.Cdb[3] = 0x10;\n\t\tsptwb.Spt.Cdb[4] = 0x01;\n\t\tsptwb.Spt.Cdb[5] = command;\n\t\tsptwb.Spt.Cdb[6] = 0x01; \n\t\tsptwb.Spt.Cdb[7] = 0x00; \n\t\tsptwb.Spt.Cdb[8] = 0x4F;  // SMART_CYL_LOW \n\t\tsptwb.Spt.Cdb[9] = 0xC2;  // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[10] = target; \n\t\tsptwb.Spt.Cdb[11] = 0xB0; // SMART_CMD\n\t}\n\telse if(type == CMD_TYPE_IO_DATA)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xE3;\n\t\tsptwb.Spt.Cdb[1] = 0x00; // ?\n\t\tsptwb.Spt.Cdb[2] = command;\n\t\tsptwb.Spt.Cdb[3] = 0x00; // ?\n\t\tsptwb.Spt.Cdb[4] = 0x00; // ?\n\t\tsptwb.Spt.Cdb[5] = 0x4F; // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[6] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[7] = target; // \n\t\tsptwb.Spt.Cdb[8] = 0xB0; // SMART_CMD\n\t\tsptwb.Spt.Cdb[9] = 0x00;  \n\t\tsptwb.Spt.Cdb[10] = 0x00; \n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t}\n\telse if(type == CMD_TYPE_LOGITEC)\n\t{\n\t\tsptwb.Spt.CdbLength = 10;\n\t\tsptwb.Spt.Cdb[0] = 0xE0;\n\t\tsptwb.Spt.Cdb[1] = 0x00;\n\t\tsptwb.Spt.Cdb[2] = command;\n\t\tsptwb.Spt.Cdb[3] = 0x00; \n\t\tsptwb.Spt.Cdb[4] = 0x00;\n\t\tsptwb.Spt.Cdb[5] = 0x4F; // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[6] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[7] = target; \n\t\tsptwb.Spt.Cdb[8] = 0xB0; // SMART_CMD\n\t\tsptwb.Spt.Cdb[9] = 0x4C;\n\t}\n\telse if (type == CMD_TYPE_PROLIFIC)\n\t{\n\t\tsptwb.Spt.CdbLength = 16;\n\t\tsptwb.Spt.Cdb[0] = 0xD8;\n\t\tsptwb.Spt.Cdb[1] = 0x15;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = command;\n\t\tsptwb.Spt.Cdb[4] = 0x06;\n\t\tsptwb.Spt.Cdb[5] = 0x7B;\n\t\tsptwb.Spt.Cdb[6] = 0x00;\n\t\tsptwb.Spt.Cdb[7] = 0x00;\n\t\tsptwb.Spt.Cdb[8] = 0x02;\n\t\tsptwb.Spt.Cdb[9] = 0x00;\n\t\tsptwb.Spt.Cdb[10] = 0x01;\n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t\tsptwb.Spt.Cdb[12] = 0x4F; // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[13] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[14] = target; // \n\t\tsptwb.Spt.Cdb[15] = 0xB0;// SMART_CMD\n\t}\n\telse if(type == CMD_TYPE_JMICRON)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xDF;\n\t\tsptwb.Spt.Cdb[1] = 0x10;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0x02;\n\t\tsptwb.Spt.Cdb[4] = 0x00;\n\t\tsptwb.Spt.Cdb[5] = command;\n\t\tsptwb.Spt.Cdb[6] = 0x01; \n\t\tsptwb.Spt.Cdb[7] = 0x01; \n\t\tsptwb.Spt.Cdb[8] = 0x4F;  // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[9] = 0xC2;  // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[10] = target; \n\t\tsptwb.Spt.Cdb[11] = 0xB0; // SMART_CMD\n\t}\n\telse if(type == CMD_TYPE_CYPRESS)\n\t{\n\t\tsptwb.Spt.CdbLength = 16;\n\t\tsptwb.Spt.Cdb[0] = 0x24;\n\t\tsptwb.Spt.Cdb[1] = 0x24;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = 0xBE;\n\t\tsptwb.Spt.Cdb[4] = 0x00;\n\t\tsptwb.Spt.Cdb[5] = 0x00; \n\t\tsptwb.Spt.Cdb[6] = command; \n\t\tsptwb.Spt.Cdb[7] = 0x00; \n\t\tsptwb.Spt.Cdb[8] = 0x00;\n\t\tsptwb.Spt.Cdb[9] = 0x4F;  // SMART_CYL_LOW\n\t\tsptwb.Spt.Cdb[10] = 0xC2; // SMART_CYL_HIGH\n\t\tsptwb.Spt.Cdb[11] = target;\n\t\tsptwb.Spt.Cdb[12] = 0xB0; // ID_CMD\n\t\tsptwb.Spt.Cdb[13] = 0x00;\n\t\tsptwb.Spt.Cdb[14] = 0x00;\n\t\tsptwb.Spt.Cdb[15] = 0x00;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\tDWORD length = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH, \n\t\t&sptwb, sizeof(SCSI_PASS_THROUGH),\n\t\t&sptwb, length,\t&dwReturned, NULL);\n\n\tsafeCloseHandle(hIoCtrl);\n\n\treturn\tbRet;\n}\n\nBOOL CAtaSmart::SendAtaCommandSat(INT physicalDriveId, BYTE target, BYTE main, BYTE sub, BYTE param, COMMAND_TYPE type)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\tif(! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t//::ZeroMemory(&sptwb,sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));\n\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = 0;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\tif(type == CMD_TYPE_SAT)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0]  = 0xA1; //ATA PASS THROUGH (12) OPERATION CODE (A1h)\n\t\tsptwb.Spt.Cdb[1]  = (3 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=3(Non-Data),Reserved\n\t\tsptwb.Spt.Cdb[2]  = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3]  = sub;\t\t//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4]  = param;\t\t//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5]  = 0x00;\t\t//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6]  = 0x00;\t\t//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7]  = 0x00;\t\t//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8]  = target;\t\t//DEVICE_HEAD\n\t\tsptwb.Spt.Cdb[9]  = main;\t\t//COMMAND\n\t\tsptwb.Spt.Cdb[10] = 0x00;\n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t}\n\telse if (type == CMD_TYPE_SAT_ASM1352R)\n\t{\n\t\t// PROTOCOL field should be \"0Dh”SATA port0 and \"0Eh\" SATA port1.\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1; //ATA PASS THROUGH (12) OPERATION CODE (A1h)\n\t\tsptwb.Spt.Cdb[1] = (0xE << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=3(Non-Data),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = sub;\t\t//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = param;\t\t//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 0x00;\t\t//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = 0x00;\t\t//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = 0x00;\t\t//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\t\t//DEVICE_HEAD\n\t\tsptwb.Spt.Cdb[9] = main;\t\t//COMMAND\n\t\tsptwb.Spt.Cdb[10] = 0x00;\n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t}\n\telse if (type == CMD_TYPE_SAT_REALTEK9220DP)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0] = 0xA1; //ATA PASS THROUGH (12) OPERATION CODE (A1h)\n\t\tsptwb.Spt.Cdb[1] = (3 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=3(Non-Data),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = sub;\t\t//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[4] = param;\t\t//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[5] = 0x00;\t\t//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[6] = 0x00;\t\t//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[7] = 0x00;\t\t//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[8] = target;\t\t//DEVICE_HEAD\n\t\tsptwb.Spt.Cdb[9] = main;\t\t//COMMAND\n\t\tsptwb.Spt.Cdb[10] = 0x00;\n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t}\n\telse if(type == CMD_TYPE_SUNPLUS)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0]  = 0xF8;\n\t\tsptwb.Spt.Cdb[1]  = 0x00;\n\t\tsptwb.Spt.Cdb[2]  = 0x22;\n\t\tsptwb.Spt.Cdb[3]  = 0x10;\n\t\tsptwb.Spt.Cdb[4]  = 0x01;\n\t\tsptwb.Spt.Cdb[5]  = sub;\n\t\tsptwb.Spt.Cdb[6]  = param; \n\t\tsptwb.Spt.Cdb[7]  = 0x00; \n\t\tsptwb.Spt.Cdb[8]  = 0x00;\n\t\tsptwb.Spt.Cdb[9]  = 0x00;\n\t\tsptwb.Spt.Cdb[10] = target; \n\t\tsptwb.Spt.Cdb[11] = main;\n\t}\n\telse if(type == CMD_TYPE_IO_DATA)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0]  = 0xE3;\n\t\tsptwb.Spt.Cdb[1]  = 0x00;\n\t\tsptwb.Spt.Cdb[2]  = sub;\n\t\tsptwb.Spt.Cdb[3]  = param;\n\t\tsptwb.Spt.Cdb[4]  = 0x00;\n\t\tsptwb.Spt.Cdb[5]  = 0x00;\n\t\tsptwb.Spt.Cdb[6]  = 0x00;\n\t\tsptwb.Spt.Cdb[7]  = target;\n\t\tsptwb.Spt.Cdb[8]  = main;\n\t\tsptwb.Spt.Cdb[9]  = 0x00;  \n\t\tsptwb.Spt.Cdb[10] = 0x00; \n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t}\n\telse if(type == CMD_TYPE_LOGITEC)\n\t{\n\t\tsptwb.Spt.CdbLength = 10;\n\t\tsptwb.Spt.Cdb[0] = 0xE0;\n\t\tsptwb.Spt.Cdb[1] = 0x00;\n\t\tsptwb.Spt.Cdb[2] = sub;\n\t\tsptwb.Spt.Cdb[3] = param; \n\t\tsptwb.Spt.Cdb[4] = 0x00;\n\t\tsptwb.Spt.Cdb[5] = 0x00;\n\t\tsptwb.Spt.Cdb[6] = 0x00;\n\t\tsptwb.Spt.Cdb[7] = target; \n\t\tsptwb.Spt.Cdb[8] = main;\n\t\tsptwb.Spt.Cdb[9] = 0x4C;\t\t// ?\n\t}\n\telse if (type == CMD_TYPE_PROLIFIC)\n\t{\n\t\tsptwb.Spt.CdbLength = 16;\n\t\tsptwb.Spt.Cdb[0] = 0xD8;\n\t\tsptwb.Spt.Cdb[1] = 0x15;\n\t\tsptwb.Spt.Cdb[2] = 0x00;\n\t\tsptwb.Spt.Cdb[3] = sub;\n\t\tsptwb.Spt.Cdb[4] = 0x06;\n\t\tsptwb.Spt.Cdb[5] = 0x7B;\n\t\tsptwb.Spt.Cdb[6] = 0x00;\n\t\tsptwb.Spt.Cdb[7] = 0x00;\n\t\tsptwb.Spt.Cdb[8] = 0x00;\n\t\tsptwb.Spt.Cdb[9] = 0x00;\n\t\tsptwb.Spt.Cdb[10] = param;\n\t\tsptwb.Spt.Cdb[11] = 0x00;\n\t\tsptwb.Spt.Cdb[12] = 0x00;\n\t\tsptwb.Spt.Cdb[13] = 0x00;\n\t\tsptwb.Spt.Cdb[14] = target;\n\t\tsptwb.Spt.Cdb[15] = main;\n\t}\n\telse if(type == CMD_TYPE_JMICRON)\n\t{\n\t\tsptwb.Spt.CdbLength = 12;\n\t\tsptwb.Spt.Cdb[0]  = 0xDF;\n\t\tsptwb.Spt.Cdb[1]  = 0x10;\n\t\tsptwb.Spt.Cdb[2]  = 0x00;\n\t\tsptwb.Spt.Cdb[3]  = 0x02;\n\t\tsptwb.Spt.Cdb[4]  = 0x00;\n\t\tsptwb.Spt.Cdb[5]  = sub;\n\t\tsptwb.Spt.Cdb[6]  = param; \n\t\tsptwb.Spt.Cdb[7]  = 0x00; \n\t\tsptwb.Spt.Cdb[8]  = 0x00;\n\t\tsptwb.Spt.Cdb[9]  = 0x00;\n\t\tsptwb.Spt.Cdb[10] = target;\n\t\tsptwb.Spt.Cdb[11] = main;\n\t}\n\telse if(type == CMD_TYPE_CYPRESS)\n\t{\n\t\tsptwb.Spt.CdbLength = 16;\n\t\tsptwb.Spt.Cdb[0]  = 0x24;\n\t\tsptwb.Spt.Cdb[1]  = 0x24;\n\t\tsptwb.Spt.Cdb[2]  = 0x00;\n\t\tsptwb.Spt.Cdb[3]  = 0xBE;\n\t\tsptwb.Spt.Cdb[4]  = 0x00;\n\t\tsptwb.Spt.Cdb[5]  = 0x00; \n\t\tsptwb.Spt.Cdb[6]  = sub; \n\t\tsptwb.Spt.Cdb[7]  = param; \n\t\tsptwb.Spt.Cdb[8]  = 0x00;\n\t\tsptwb.Spt.Cdb[9]  = 0x00;\n\t\tsptwb.Spt.Cdb[10] = 0x00;\n\t\tsptwb.Spt.Cdb[11] = target;\n\t\tsptwb.Spt.Cdb[12] = main;\n\t\tsptwb.Spt.Cdb[13] = 0x00;\n\t\tsptwb.Spt.Cdb[14] = 0x00;\n\t\tsptwb.Spt.Cdb[15] = 0x00;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\tDWORD length = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH, \n\t\t&sptwb, sizeof(SCSI_PASS_THROUGH),\n\t\t&sptwb, length,\t&dwReturned, NULL);\n\n\tsafeCloseHandle(hIoCtrl);\n\n\treturn\tbRet;\n}\n\nBOOL CAtaSmart::ReadLogExtSat(INT physicalDriveId, BYTE target, BYTE logAddress, BYTE logPage, PBYTE data, DWORD dataSize, COMMAND_TYPE type)\n{\n\tBOOL\tbRet = FALSE;\n\tHANDLE\thIoCtrl = NULL;\n\tDWORD\tdwReturned = 0;\n\n\tSCSI_PASS_THROUGH_WITH_BUFFERS sptwb = {};\n\n\thIoCtrl = GetIoCtrlHandle(physicalDriveId);\n\tif (! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\t//::ZeroMemory(&sptwb, sizeof(SCSI_PASS_THROUGH_WITH_BUFFERS));\n\n\tsptwb.Spt.Length = sizeof(SCSI_PASS_THROUGH);\n\tsptwb.Spt.PathId = 0;\n\tsptwb.Spt.TargetId = 0;\n\tsptwb.Spt.Lun = 0;\n\tsptwb.Spt.SenseInfoLength = 24;\n\tsptwb.Spt.DataIn = SCSI_IOCTL_DATA_IN;\n\tsptwb.Spt.DataTransferLength = 512;\n\tsptwb.Spt.TimeOutValue = 2;\n\tsptwb.Spt.DataBufferOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf);\n\tsptwb.Spt.SenseInfoOffset = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, SenseBuf);\n\tif (type == CMD_TYPE_SAT)\n\t{\n\t\tsptwb.Spt.CdbLength = 16;\n\t\tsptwb.Spt.Cdb[0] = 0x85; //ATA PASS THROUGH (12) OPERATION CODE (A1h)\n\t\tsptwb.Spt.Cdb[1] = (4 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\t\tsptwb.Spt.Cdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\t\tsptwb.Spt.Cdb[3] = 0x00;\t\t//FEATURES (15:8)\n\t\tsptwb.Spt.Cdb[4] = 0x00;\t\t//FEATURES (7:0)\n\t\tsptwb.Spt.Cdb[5] = 0x00;\t\t//SECTOR_COUNT (15:8)\n\t\tsptwb.Spt.Cdb[6] = 0x01;\t\t//SECTOR_COUNT (7:0)\n\t\tsptwb.Spt.Cdb[7] = 0x00;\t\t//LBA_LOW (15:8)\n\t\tsptwb.Spt.Cdb[8] = logAddress;\t//LBA_LOW (7:0)\n\t\tsptwb.Spt.Cdb[9] = 0x00;\t\t//LBA_MID (15:8)\n\t\tsptwb.Spt.Cdb[10] = logPage;\t//LBA_MID (7:0)\n\t\tsptwb.Spt.Cdb[11] = 0x00;\t\t//LBA_HIGH (15:8)\n\t\tsptwb.Spt.Cdb[12] = 0x00;\t\t//LBA_HIGH (7:0)\n\t\tsptwb.Spt.Cdb[13] = target;\t\t//DEVICE_HEAD\n\t\tsptwb.Spt.Cdb[14] = 0x2F;\t\t//COMMAND\n\t\tsptwb.Spt.Cdb[15] = 0x00;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\tDWORD length = offsetof(SCSI_PASS_THROUGH_WITH_BUFFERS, DataBuf) + sptwb.Spt.DataTransferLength;\n\tbRet = ::DeviceIoControl(hIoCtrl, IOCTL_SCSI_PASS_THROUGH,\n\t\t&sptwb, sizeof(SCSI_PASS_THROUGH),\n\t\t&sptwb, length, &dwReturned, NULL);\n\n\tsafeCloseHandle(hIoCtrl);\n\n\tif (bRet == FALSE || dwReturned != length)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\tmemcpy_s(data, dataSize, &(sptwb.DataBuf), 512);\n\n\treturn\tbRet;\n}\n\n\n/*---------------------------------------------------------------------------*/\n// Silicon Image Support\n/*---------------------------------------------------------------------------*/\n\nHANDLE CAtaSmart::GetIoCtrlHandle(INT scsiPort, DWORD siliconImageType)\n{\n\tHANDLE hScsiDriveIOCTL = 0;\n\tCString driveName;\n\n\tdriveName.Format(_T(\"\\\\\\\\.\\\\Scsi%d:\"), scsiPort);\n\thScsiDriveIOCTL = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n\tif(hScsiDriveIOCTL == INVALID_HANDLE_VALUE)\n\t{\n\t\tTCHAR szBusPathBody[MAX_PATH] = {};\n\t\tTCHAR szSilDeviceName[MAX_PATH] = {};\n\n\t\tif(siliconImageType == 3512)\n\t\t{\n\t\t\tsiliconImageType = 3112;\n\t\t}\n\n\t\twsprintf(szBusPathBody, _T(\"tempBusSil%d\"), siliconImageType);\n\t\twsprintf(szSilDeviceName, _T(\"\\\\Device\\\\Scsi\\\\SI%d1\"), siliconImageType) ;\n\n\t\tif(DefineDosDevice(DDD_RAW_TARGET_PATH, szBusPathBody, szSilDeviceName))\n\t\t{\n\t\t\tdriveName.Format(_T(\"\\\\\\\\.\\\\%s\"), szBusPathBody);\n\t\t\treturn CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n\t\t}\n\t}\n\treturn hScsiDriveIOCTL;\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceSi(INT physicalDriveId, INT scsiPort, INT scsiBus, DWORD siliconImageType, IDENTIFY_DEVICE* data)\n{\n\tint done = FALSE;\n\t//int controller = 0;\n\t//int current = 0;\n\tHANDLE hScsiDriveIOCTL = 0;\n\n\thScsiDriveIOCTL = GetIoCtrlHandle(scsiPort, siliconImageType);\n\n\tif(hScsiDriveIOCTL != INVALID_HANDLE_VALUE)\n\t{\n\t\tSilIdentDev sid = {};\n\t\t//memset(&sid, 0, sizeof(sid));\n\t\t\n\t\tsid.sic.HeaderLength = sizeof(SRB_IO_CONTROL);\n\t\tmemcpy(sid.sic.Signature, \"CMD_IDE \", 8);\n\t\tsid.sic.Timeout = 5;\n\t\tsid.sic.ControlCode = CTL_CODE(FILE_DEVICE_CONTROLLER, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS);\n\t\tsid.sic.ReturnCode = 0xffffffff;\n\t\tsid.sic.Length = sizeof(sid) - offsetof(SilIdentDev, port);\n\t\tsid.port = (USHORT)scsiBus;\n\t\tsid.maybe_always1 = 1 ;\n\n\t\tDWORD dwReturnBytes;\n\t\tif(DeviceIoControl(hScsiDriveIOCTL, IOCTL_SCSI_MINIPORT, &sid, sizeof(sid), &sid, sizeof(sid), &dwReturnBytes, NULL))\n\t\t{\n\t\t\tdone = TRUE;\n\t\t\tmemcpy_s(data, sizeof(ATA_IDENTIFY_DEVICE), &sid.id_data, sizeof(ATA_IDENTIFY_DEVICE));\n\t\t}\n\n\t\tsafeCloseHandle(hScsiDriveIOCTL);\n\t}\n\treturn done;\n}\n\nBOOL CAtaSmart::GetSmartAttributeSi(INT physicalDriveId, ATA_SMART_INFO* asi)\n{\n//\treturn GetSmartAttributePd(physicalDriveId, 0xA0, asi);\n\n\tHANDLE hScsiDriveIOCTL = 0;\n\n\thScsiDriveIOCTL = GetIoCtrlHandle(physicalDriveId);\n\n\tSTORAGE_PREDICT_FAILURE spf = {};\n\tDWORD dwRetBytes = 0;\n\n\tif(hScsiDriveIOCTL != INVALID_HANDLE_VALUE)\n\t{\n\t\tif (DeviceIoControl(hScsiDriveIOCTL, IOCTL_STORAGE_PREDICT_FAILURE,\n\t\t\t&spf, sizeof(spf), &spf, sizeof(spf), &dwRetBytes, NULL))\n\t\t{\n\t\t\tmemcpy_s(&(asi->SmartReadData), 512, &(spf.VendorSpecific), 512);\n\t\t\tsafeCloseHandle(hScsiDriveIOCTL);\n\t\t\treturn FillSmartData(asi);\n\t\t}\n\t\tsafeCloseHandle(hScsiDriveIOCTL);\n\t}\n\treturn GetSmartAttributeWmi(asi);\n}\n\nBOOL CAtaSmart::GetSmartThresholdSi(INT physicalDriveId, ATA_SMART_INFO* asi)\n{\n\treturn GetSmartThresholdWmi(asi);\n}\n\n/*---------------------------------------------------------------------------*/\n// WMI\n/*---------------------------------------------------------------------------*/\n\nBOOL CAtaSmart::GetSmartAttributeWmi(ATA_SMART_INFO* asi)\n{\n\treturn GetSmartInfoWmi(WMI_SMART_DATA, asi);\n}\n\nBOOL CAtaSmart::GetSmartThresholdWmi(ATA_SMART_INFO* asi)\n{\n\tif(! IsWindowsVersionOrGreaterFx(5, 1))\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn GetSmartInfoWmi(WMI_SMART_THRESHOLD, asi);\n}\n\nBOOL CAtaSmart::GetSmartInfoWmi(DWORD type, ATA_SMART_INFO* asi)\n{\n\tif(asi->PnpDeviceId.IsEmpty())\n\t{\n\t\treturn FALSE;\n\t}\n\n\tCString query;\n\n\tif(type == WMI_SMART_DATA)\n\t{\n\t\tquery = L\"SELECT * FROM MSStorageDriver_FailurePredictData\";\n\t}\n\telse\n\t{\n\t\tquery = L\"SELECT * FROM MSStorageDriver_FailurePredictThresholds\";\n\t}\n\t\n\tIWbemLocator*\t\t\tpIWbemLocator = NULL;\n\tIWbemServices*\t\t\tpIWbemServices = NULL;\n\tIEnumWbemClassObject*\tpEnumCOMDevs = NULL;\n\tIWbemClassObject*\t\tpCOMDev = NULL;\n\tULONG\t\t\t\t\tuReturned = 0;\n\tBOOL\t\t\t\t\tflag = FALSE;\n\n\ttry\n\t{\n\t\tif(SUCCEEDED(CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,\n\t\t\t\tIID_IWbemLocator, (LPVOID *)&pIWbemLocator)))\n\t\t{\n\t\t\tlong securityFlag = 0;\n\t\t\tif(IsWindowsVersionOrGreaterFx(6, 0)){securityFlag = WBEM_FLAG_CONNECT_USE_MAX_WAIT;}\n\t\t\tif(SUCCEEDED(pIWbemLocator->ConnectServer(_bstr_t(L\"\\\\\\\\.\\\\root\\\\WMI\"), \n\t\t\t\tNULL, NULL, 0L, securityFlag, NULL, NULL, &pIWbemServices)))\n\t\t\t{\n\t\t\t\tif(SUCCEEDED(CoSetProxyBlanket(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,\n\t\t\t\t\tNULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE)))\n\t\t\t\t{\n\t\t\t\t\tif(SUCCEEDED(pIWbemServices->ExecQuery(_bstr_t(L\"WQL\"), \n\t\t\t\t\t\t_bstr_t(query), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs)))\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(pEnumCOMDevs && SUCCEEDED(pEnumCOMDevs->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCString name;\n\t\t\t\t\t\t\tVARIANT pVal;\n\t\t\t\t\t\t\tVariantInit(&pVal);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(pCOMDev->Get(L\"InstanceName\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname = pVal.bstrVal;\n\t\t\t\t\t\t\t\tname.MakeUpper();\n\t\t\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tVariantInit(&pVal);\n\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(name.Find(asi->PnpDeviceId) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(pCOMDev->Get(L\"VendorSpecific\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(type == WMI_SMART_DATA)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor(long i = 0; i < 512; i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSafeArrayGetElement(pVal.parray, &i, &(asi->SmartReadData[i]));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tflag = FillSmartData(asi);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor(long i = 0; i < 512; i++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSafeArrayGetElement(pVal.parray, &i, &(asi->SmartReadThreshold[i]));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tflag = FillSmartThreshold(asi);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcatch(...)\n\t{\n\t\tflag = FALSE;\n\t}\n\tSAFE_RELEASE(pCOMDev);\n\tSAFE_RELEASE(pEnumCOMDevs);\n\tSAFE_RELEASE(pIWbemServices);\n\tSAFE_RELEASE(pIWbemLocator);\n\n\treturn flag;\n}\n\n/*---------------------------------------------------------------------------*/\n// CSMI support (Intel/AMD RAID support)\n/*---------------------------------------------------------------------------*/\n\nHANDLE CAtaSmart::GetIoCtrlHandleCsmi(INT scsiPort)\n{\n\tHANDLE hScsiDriveIOCTL = 0;\n\tCString driveName;\n\n\tdriveName.Format(_T(\"\\\\\\\\.\\\\Scsi%d:\"), scsiPort);\n\thScsiDriveIOCTL = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n\treturn hScsiDriveIOCTL;\n}\n\nBOOL CAtaSmart::AddDiskCsmi(INT scsiPort)\n{\n\tCString cstr;\n\tcstr.Format(L\"AddDiskCsmi(%d)\", scsiPort);\n\tDebugPrint(cstr);\n\tif(CsmiType == CSMI_TYPE_DISABLE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tHANDLE hHandle = GetIoCtrlHandleCsmi(scsiPort);\n\tif(hHandle == INVALID_HANDLE_VALUE)\n\t{\n\t\tDebugPrint(_T(\"FAILED: INVALID_HANDLE_VALUE\"));\n\t\treturn FALSE;\n\t}\n\n\tCSMI_SAS_DRIVER_INFO_BUFFER driverInfoBuf = {};\n\tif(! CsmiIoctl(hHandle, CC_CSMI_SAS_GET_DRIVER_INFO, &driverInfoBuf.IoctlHeader, sizeof(driverInfoBuf)))\n\t{\n\t//\tsafeCloseHandle(hHandle);\n\t\tDebugPrint(_T(\"FAILED: CC_CSMI_SAS_GET_DRIVER_INFO\"));\n\t//\treturn FALSE;\n\t}\n\n\tCSMI_SAS_RAID_INFO_BUFFER raidInfoBuf = {};\n\tif(! CsmiIoctl(hHandle, CC_CSMI_SAS_GET_RAID_INFO, &raidInfoBuf.IoctlHeader, sizeof(raidInfoBuf)))\n\t{\n\t//\tsafeCloseHandle(hHandle);\n\t\tDebugPrint(_T(\"FAILED: CC_CSMI_SAS_GET_RAID_INFO\"));\n\t//\treturn FALSE;\n\t}\n\n//\tCArray<CSMI_SAS_RAID_DRIVES, CSMI_SAS_RAID_DRIVES> raidDrives;\n\tCArray<UCHAR, UCHAR> raidDrives;\n\n\tDWORD size = sizeof(CSMI_SAS_RAID_CONFIG_BUFFER) + sizeof(CSMI_SAS_RAID_DRIVES) * raidInfoBuf.Information.uNumRaidSets * raidInfoBuf.Information.uMaxDrivesPerSet;\n\tPCSMI_SAS_RAID_CONFIG_BUFFER buf = (PCSMI_SAS_RAID_CONFIG_BUFFER)VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);\n\tif(buf == NULL )\n\t{\n\t\tsafeCloseHandle(hHandle);\n\t\tDebugPrint(_T(\"FAILED: PCSMI_SAS_RAID_CONFIG_BUFFER Memory Alloc\"));\n\t\treturn FALSE;\n\t}\n\tfor(UINT i = 0; i < raidInfoBuf.Information.uNumRaidSets; i++)\n\t{\n\t\tbuf->Configuration.uRaidSetIndex = i;\n\t\tif(! CsmiIoctl(hHandle, CC_CSMI_SAS_GET_RAID_CONFIG, &(buf->IoctlHeader), size))\n\t\t{\n\t\t\tsafeCloseHandle(hHandle);\n\t\t\tDebugPrint(_T(\"FAILED: CC_CSMI_SAS_GET_RAID_CONFIG\"));\n\t\t\tsafeVirtualFree(buf, 0, MEM_RELEASE);\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(UINT j = 0; j < raidInfoBuf.Information.uMaxDrivesPerSet; j++)\n\t\t\t{\n\t\t\t\tif(buf->Configuration.Drives[j].bModel[0] != '\\0')\n\t\t\t\t{\n\t\t\t\t//\traidDrives.Add(buf->Configuration.Drives[j]);\n\t\t\t\t\traidDrives.Add(buf->Configuration.Drives[j].bSASAddress[2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsafeVirtualFree(buf, 0, MEM_RELEASE);\n\n\tCSMI_SAS_PHY_INFO phyInfo = {};\n\tCSMI_SAS_PHY_INFO_BUFFER phyInfoBuf = {};\n\tif (! CsmiIoctl(hHandle, CC_CSMI_SAS_GET_PHY_INFO, &phyInfoBuf.IoctlHeader, sizeof(phyInfoBuf)))\n\t{\n\t\tsafeCloseHandle(hHandle);\n\t\tDebugPrint(_T(\"FAILED: CC_CSMI_SAS_GET_PHY_INFO\"));\n\t\treturn FALSE;\n\t}\n\tmemcpy(&phyInfo, &(phyInfoBuf.Information), sizeof(phyInfoBuf.Information));\n\t\n\tIDENTIFY_DEVICE identify = {};\t\n\tDWORD diskSize = 0;\n\n\t// CSMI Driver Information\n\tCString cs;\n\tcs = driverInfoBuf.Information.szName;\n\tcstr.Format(L\"DriverName: %s\", cs.GetBuffer());\n\tDebugPrint(cstr);\n\tcstr.Format(L\"Revision: %d.%d.%d.%d\", driverInfoBuf.Information.usMajorRevision, driverInfoBuf.Information.usMinorRevision, driverInfoBuf.Information.usBuildRevision, driverInfoBuf.Information.usReleaseRevision);\n\tDebugPrint(cstr);\n\tcstr.Format(L\"CSMI Revision: %d.%d\", driverInfoBuf.Information.usCSMIMajorRevision, driverInfoBuf.Information.usCSMIMinorRevision);\n\tDebugPrint(cstr);\n\n\t// AMD-RAIDXpert2 support\n\tif(memcmp(driverInfoBuf.Information.szName, \"rcraid\", 7) == 0)\n\t{\n\t\tDebugPrint(_T(\"rcraid\"));\n\t\tfor(UINT i = 0; i < raidInfoBuf.Information.uMaxPhysicalDrives; i++)\n\t\t{\n\t\t\tif(i >= phyInfo.bNumberOfPhys)\n\t\t\t{\n\t\t\t\tmemcpy(&phyInfo.Phy[i], &phyInfo.Phy[0], sizeof(phyInfo.Phy[i]));\n\t\t\t}\n\t\t\tphyInfo.Phy[i].Attached.bPhyIdentifier = phyInfo.Phy[i].bPortIdentifier = (UCHAR)i;\n\t\t}\n\t\tphyInfo.bNumberOfPhys = (UCHAR)raidInfoBuf.Information.uMaxPhysicalDrives;\n\t}\n\telse\n\t{\n\t\t// Intel VROC NVMe RAID support\n\t\tfor (int j = 0; j < raidDrives.GetCount(); j++)\n\t\t{\n\t\t\tcstr.Format(L\"DoIdentifyDeviceNVMeIntelVroc(-1, %d, %d)\", scsiPort, raidDrives.GetAt(j));\n\t\t\tDebugPrint(cstr);\n\t\t\tif (DoIdentifyDeviceNVMeIntelVroc(-1, scsiPort, raidDrives.GetAt(j), &identify, &diskSize))\n\t\t\t{\n\t\t\t\tDebugPrint(L\"AddDiskNVMe\");\n\t\t\t\tAddDiskNVMe(-1, scsiPort, raidDrives.GetAt(j), 0, 0, CMD_TYPE_NVME_INTEL_VROC, &identify, &diskSize);\n\t\t\t}\n\t\t}\n\n\t\t// Intel RST NVMe RAID support\n\t\tfor (int j = 0; j < raidDrives.GetCount(); j++)\n\t\t{\n\t\t\tcstr.Format(L\"DoIdentifyDeviceNVMeIntelRst(-1, %d, %d)\", scsiPort, raidDrives.GetAt(j));\n\t\t\tDebugPrint(cstr);\n\t\t\tif (DoIdentifyDeviceNVMeIntelRst(-1, scsiPort, raidDrives.GetAt(j), &identify, &diskSize))\n\t\t\t{\n\t\t\t\tDebugPrint(L\"AddDiskNVMe\");\n\t\t\t\tAddDiskNVMe(-1, scsiPort, raidDrives.GetAt(j), 0, 0, CMD_TYPE_NVME_INTEL_RST, &identify, &diskSize);\n\t\t\t}\n\t\t}\n\t}\n\n\t// SATA support\n\tif(phyInfo.bNumberOfPhys <= sizeof(phyInfo.Phy)/sizeof(phyInfo.Phy[0]))\n\t{\n\t\tfor(int i = 0; i < phyInfo.bNumberOfPhys; i++)\n\t\t{\n\t\t\tif(CsmiType == CSMI_TYPE_ENABLE_RAID)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < raidDrives.GetCount(); j++)\n\t\t\t\t{\n\t\t\t\t//\tPCSMI_SAS_RAID_DRIVES test;\n\t\t\t\t//\ttest = &(raidDrives.GetAt(j));\n\t\t\t\t//\tif(memcmp(raidDrives.GetAt(j).bSASAddress, phyInfo.Phy[i].Attached.bSASAddress, 8) == 0)\n\t\t\t\t//\tif(raidDrives.GetAt(j).bSASAddress[2] == phyInfo.Phy[i].Attached.bSASAddress[2])\n\t\t\t\t\tif(raidDrives.GetAt(j) == phyInfo.Phy[i].Attached.bSASAddress[2])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(DoIdentifyDeviceCsmi(scsiPort, &(phyInfo.Phy[i]), &identify))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAddDisk(-1, scsiPort, -1, -1, 0xA0, CMD_TYPE_CSMI, &identify, FALSE, &(phyInfo.Phy[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(DoIdentifyDeviceCsmi(scsiPort, &(phyInfo.Phy[i]), &identify))\n\t\t\t\t{\n\t\t\t\t\tAddDisk(-1, scsiPort, -1, -1, 0xA0, CMD_TYPE_CSMI, &identify, FALSE, &(phyInfo.Phy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\n\tsafeCloseHandle(hHandle);\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::CsmiIoctl(HANDLE hHandle, UINT code, SRB_IO_CONTROL *csmiBuf, UINT csmiBufSize)\n{\n\t// Determine signature\n\tconst CHAR *sig = NULL;\n\tswitch (code)\n\t{\n\t\tcase CC_CSMI_SAS_GET_DRIVER_INFO:\n\t\t\tsig = CSMI_ALL_SIGNATURE;\n\t\t\tbreak;\n\t\tcase CC_CSMI_SAS_GET_PHY_INFO:\n\t\tcase CC_CSMI_SAS_STP_PASSTHRU:\n\t\t\tsig = CSMI_SAS_SIGNATURE;\n\t\t\tbreak;\n\t\tcase CC_CSMI_SAS_GET_RAID_INFO:\n\t\tcase CC_CSMI_SAS_GET_RAID_CONFIG:\n\t\t\tsig = CSMI_RAID_SIGNATURE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n\n\t// Set header\n\tcsmiBuf->HeaderLength = sizeof(IOCTL_HEADER);\n\tstrncpy_s((char *)csmiBuf->Signature, sizeof(csmiBuf->Signature), sig, sizeof(csmiBuf->Signature));\n\tcsmiBuf->Timeout = CSMI_SAS_TIMEOUT;\n\tcsmiBuf->ControlCode = code;\n\tcsmiBuf->ReturnCode = 0;\n\tcsmiBuf->Length = csmiBufSize - sizeof(IOCTL_HEADER);\n\n\t// Call function\n\tDWORD num_out = 0;\n\tif (!DeviceIoControl(hHandle, IOCTL_SCSI_MINIPORT, \n\t\tcsmiBuf, csmiBufSize, csmiBuf, csmiBufSize, &num_out, (OVERLAPPED*)0))\n\t{\n\t\tlong err = GetLastError();\n\t\t\n\t\tif (err == ERROR_INVALID_FUNCTION || err == ERROR_NOT_SUPPORTED \n\t\t\t|| err == ERROR_DEV_NOT_EXIST)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t// Check result\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceCsmi(INT scsiPort, PCSMI_SAS_PHY_ENTITY sasPhyEntity, IDENTIFY_DEVICE* data)\n{\n\t//BOOL flag = FALSE;\n\tDebugPrint(_T(\"DoIdentifyDeviceCsmi\"));\n\treturn SendAtaCommandCsmi(scsiPort, sasPhyEntity, 0xEC, 0x00, 0x00, (PBYTE)data, sizeof(ATA_IDENTIFY_DEVICE));\n}\n\nBOOL CAtaSmart::GetSmartAttributeCsmi(INT scsiPort, PCSMI_SAS_PHY_ENTITY sasPhyEntity, ATA_SMART_INFO* asi)\n{\n\tDebugPrint(_T(\"GetSmartAttributeCsmi\"));\n\tif(SendAtaCommandCsmi(scsiPort, sasPhyEntity, SMART_CMD, READ_ATTRIBUTES, 0x00, (PBYTE)asi->SmartReadData, sizeof(asi->SmartReadData)))\n\t{\n\t\tDebugPrint(_T(\"FillSmartData\"));\n\t\treturn FillSmartData(asi);\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n}\n\nBOOL CAtaSmart::GetSmartThresholdCsmi(INT scsiPort, PCSMI_SAS_PHY_ENTITY sasPhyEntity, ATA_SMART_INFO* asi)\n{\n\tDebugPrint(_T(\"GetSmartThresholdCsmi\"));\n\tif(SendAtaCommandCsmi(scsiPort, sasPhyEntity, SMART_CMD, READ_THRESHOLDS, 0x00, (PBYTE)asi->SmartReadThreshold, sizeof(asi->SmartReadThreshold)))\n\t{\n\t\tDebugPrint(_T(\"FillSmartThreshold\"));\n\t\treturn FillSmartThreshold(asi);\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n}\n\nBOOL CAtaSmart::ControlSmartStatusCsmi(INT scsiPort, PCSMI_SAS_PHY_ENTITY sasPhyEntity, BYTE command)\n{\n\tDebugPrint(_T(\"ControlSmartStatusCsmi\"));\n\treturn SendAtaCommandCsmi(scsiPort, sasPhyEntity, SMART_CMD, command, 0x00, NULL, 0);\n}\n\nBOOL CAtaSmart::SendAtaCommandCsmi(INT scsiPort, PCSMI_SAS_PHY_ENTITY sasPhyEntity, BYTE main, BYTE sub, BYTE param, PBYTE data, DWORD dataSize)\n{\n\tHANDLE hIoCtrl = GetIoCtrlHandleCsmi(scsiPort);\n\tif(! hIoCtrl || hIoCtrl == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn\tFALSE;\n\t}\n\n\tDWORD size = sizeof(CSMI_SAS_STP_PASSTHRU_BUFFER) + dataSize;\n\tCSMI_SAS_STP_PASSTHRU_BUFFER* buf = (CSMI_SAS_STP_PASSTHRU_BUFFER*)VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);\n\tif (buf == NULL)  return FALSE;\n\tbuf->Parameters.bPhyIdentifier = sasPhyEntity->Attached.bPhyIdentifier;\n\tbuf->Parameters.bPortIdentifier = sasPhyEntity->bPortIdentifier;\n\tmemcpy(&(buf->Parameters.bDestinationSASAddress), sasPhyEntity->Attached.bSASAddress, sizeof(sasPhyEntity->Attached.bSASAddress));\n\tbuf->Parameters.bConnectionRate = CSMI_SAS_LINK_RATE_NEGOTIATED;\n\n\tif(main == 0xEF) // AAM/APM\n\t{\n\t\tbuf->Parameters.uFlags = CSMI_SAS_STP_UNSPECIFIED;\n\t}\n\telse\n\t{\n\t\tbuf->Parameters.uFlags = CSMI_SAS_STP_PIO | CSMI_SAS_STP_READ;\n\t}\n\tbuf->Parameters.uDataLength = dataSize;\n\n\tbuf->Parameters.bCommandFIS[ 0] = 0x27; // Type: host-to-device FIS\n\tbuf->Parameters.bCommandFIS[ 1] = 0x80; // Bit7: Update command register\n\n\tif(main == SMART_CMD)\n\t{\n\t\tbuf->Parameters.bCommandFIS[ 2] = main;\n\t\tbuf->Parameters.bCommandFIS[ 3] = sub;\n\t\tbuf->Parameters.bCommandFIS[ 4] = 0;\n\t\tbuf->Parameters.bCommandFIS[ 5] = SMART_CYL_LOW;\n\t\tbuf->Parameters.bCommandFIS[ 6] = SMART_CYL_HI;\n\t\tbuf->Parameters.bCommandFIS[ 7] = 0xA0; // target\n\t\tbuf->Parameters.bCommandFIS[ 8] = 0;\n\t\tbuf->Parameters.bCommandFIS[ 9] = 0;\n\t\tbuf->Parameters.bCommandFIS[10] = 0;\n\t\tbuf->Parameters.bCommandFIS[11] = 0;\n\t\tbuf->Parameters.bCommandFIS[12] = param;\n\t\tbuf->Parameters.bCommandFIS[13] = 0;\n\t}\n\telse\n\t{\n\t\tbuf->Parameters.bCommandFIS[ 2] = main;\n\t\tbuf->Parameters.bCommandFIS[ 3] = sub;\n\t\tbuf->Parameters.bCommandFIS[ 4] = 0;\n\t\tbuf->Parameters.bCommandFIS[ 5] = 0;\n\t\tbuf->Parameters.bCommandFIS[ 6] = 0;\n\t\tbuf->Parameters.bCommandFIS[ 7] = 0xA0; // target\n\t\tbuf->Parameters.bCommandFIS[ 8] = 0;\n\t\tbuf->Parameters.bCommandFIS[ 9] = 0;\n\t\tbuf->Parameters.bCommandFIS[10] = 0;\n\t\tbuf->Parameters.bCommandFIS[11] = 0;\n\t\tbuf->Parameters.bCommandFIS[12] = param;\n\t\tbuf->Parameters.bCommandFIS[13] = 0;\n\t}\n\n\tif(! CsmiIoctl(hIoCtrl, CC_CSMI_SAS_STP_PASSTHRU, &buf->IoctlHeader, size))\n\t{\n\t\tsafeCloseHandle(hIoCtrl);\n\t\tsafeVirtualFree(buf, 0, MEM_RELEASE);\n\t\treturn FALSE;\n\t}\n\n\tif(main != 0xEF && buf->bDataBuffer && data != NULL)\n\t{\n\t\tmemcpy_s(data, dataSize, buf->bDataBuffer, dataSize);\n\t}\n\t\n\tsafeCloseHandle(hIoCtrl);\n\tsafeVirtualFree(buf, 0, MEM_RELEASE);\n\t\n\treturn\tTRUE;\n}\n\n/*---------------------------------------------------------------------------*/\n// MegaRAID SAS support\n// https://github.com/hiyohiyo/CrystalDiskInfo/pull/32\n/*---------------------------------------------------------------------------*/\n\nHANDLE CAtaSmart::GetIoCtrlHandleMegaRAID(INT scsiPort)\n{\n\tHANDLE hScsiDriveIOCTL = 0;\n\tCString driveName;\n\n\tdriveName.Format(_T(\"\\\\\\\\.\\\\Scsi%d:\"), scsiPort);\n\thScsiDriveIOCTL = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);\n\treturn hScsiDriveIOCTL;\n}\n\nBOOL CAtaSmart::SendDCommandMegaRAID(HANDLE hHandle, ULONG opcode, void* buf, size_t bufsize, BYTE* mbox, size_t mboxlen)\n{\n\tif ((mbox != NULL && (mboxlen == 0 || mboxlen > MFI_MBOX_SIZE)) ||\n\t\t(mbox == NULL && mboxlen != 0))\n\t{\n\t\treturn FALSE;\n\t}\n\n\tMEGARAID_DCOMD_IOCTL mdi = {};\n\t//memset(&mdi, 0, sizeof(mdi));\n\n\tmdi.SrbIoCtrl.HeaderLength = sizeof(SRB_IO_CONTROL);\n\tmemcpy(mdi.SrbIoCtrl.Signature, \"LSILOGIC\", 8);\n\tmdi.SrbIoCtrl.Timeout = 0;\n\tmdi.SrbIoCtrl.ControlCode = 0;\n\tmdi.SrbIoCtrl.Length = (ULONG)(sizeof(MEGARAID_DCOMD_IOCTL) - sizeof(mdi.DataBuf) + bufsize);\n\n\tif (mbox)\n\t{\n\t\tmemcpy(mdi.Mpt.Mbox, mbox, mboxlen);\n\t}\n\n\tmdi.Mpt.Cmd = MFI_CMD_DCMD;\n\tmdi.Mpt.TimeOutValue = 0;\n\tmdi.Mpt.Flags = 0;\n\tmdi.Mpt.DataTransferLength = (ULONG)bufsize;\n\tmdi.Mpt.Opcode = opcode;\n\n\tDWORD read_size = 0;\n\tif (!DeviceIoControl(hHandle, IOCTL_SCSI_MINIPORT,\n\t\t&mdi,\n\t\tsizeof(mdi),\n\t\t&mdi,\n\t\tsizeof(mdi),\n\t\t&read_size, nullptr))\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (read_size < sizeof(SRB_IO_CONTROL) + sizeof(MEGARAID_DCOMD))\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (mdi.Mpt.CmdStatus != MFI_STAT_OK)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (read_size - (sizeof(mdi) - sizeof(mdi.DataBuf)) < mdi.Mpt.DataTransferLength)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tmemcpy(buf, mdi.DataBuf, mdi.Mpt.DataTransferLength);\n\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::SendPassThroughCommandMegaRAID(INT scsiPort, INT scsiTargetId, void* buf, size_t bufsize, const UCHAR Cdb[], UCHAR CdbLength)\n{\n\tif (!Cdb || CdbLength == 0) \n\t{\n\t\treturn FALSE;\n\t}\n\n\tHANDLE hHandle = GetIoCtrlHandleMegaRAID(scsiPort);\n\tif (hHandle == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tMEGARAID_PASS_THROUGH_IOCTL mpti = {};\n\t//memset(&mpti, 0, sizeof(mpti));\n\n\tmpti.SrbIoCtrl.HeaderLength = sizeof(SRB_IO_CONTROL);\n\tmemcpy(mpti.SrbIoCtrl.Signature, \"LSILOGIC\", 8);\n\tmpti.SrbIoCtrl.Timeout = 0;\n\tmpti.SrbIoCtrl.ControlCode = 0;\n\tmpti.SrbIoCtrl.Length = (ULONG)(sizeof(MEGARAID_PASS_THROUGH_IOCTL) - sizeof(mpti.DataBuf) + bufsize);\n\n\tmpti.Mpt.Cmd = MFI_CMD_PD_SCSI_IO;\n\tmpti.Mpt.CmdStatus = 0xFF;\n\tmpti.Mpt.ScsiStatus = 0x00;\n\tmpti.Mpt.TargetId = (UCHAR)scsiTargetId;\n\tmpti.Mpt.Lun = 0;\n\tmpti.Mpt.CdbLength = CdbLength;\n\tmpti.Mpt.TimeOutValue = 0;\n\tmpti.Mpt.Flags = MFI_FRAME_DIR_READ;\n\tmpti.Mpt.DataTransferLength = (ULONG)bufsize;\n\n\tmemcpy_s(mpti.Mpt.Cdb, sizeof(mpti.Mpt.Cdb), Cdb, CdbLength);\n\n\tDWORD read_size = 0;\n\tif (!DeviceIoControl(hHandle, IOCTL_SCSI_MINIPORT,\n\t\t&mpti,\n\t\tsizeof(mpti),\n\t\t&mpti,\n\t\tsizeof(mpti),\n\t\t&read_size, nullptr))\n\t{\n\t\tsafeCloseHandle(hHandle);\n\t\treturn FALSE;\n\t}\n\n\tif (read_size < sizeof(SRB_IO_CONTROL) + sizeof(MEGARAID_DCOMD))\n\t{\n\t\tsafeCloseHandle(hHandle);\n\t\treturn FALSE;\n\t}\n\n\tif (mpti.Mpt.CmdStatus != MFI_STAT_OK)\n\t{\n\t\tsafeCloseHandle(hHandle);\n\t\treturn FALSE;\n\t}\n\n\tif (read_size - (sizeof(mpti) - sizeof(mpti.DataBuf)) < mpti.Mpt.DataTransferLength)\n\t{\n\t\tsafeCloseHandle(hHandle);\n\t\treturn FALSE;\n\t}\n\n\tif (buf)\n\t{\n\t\tmemcpy_s(buf, bufsize, mpti.DataBuf, mpti.Mpt.DataTransferLength);\n\t}\n\n\tsafeCloseHandle(hHandle);\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::AddDiskMegaRAID(INT scsiPort)\n{\n\tif(CsmiType == CSMI_TYPE_DISABLE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tHANDLE hHandle = GetIoCtrlHandleMegaRAID(scsiPort);\n\tif(hHandle == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tMEGARAID_PHYSICAL_DRIVE_LIST* list = NULL;\n\tfor (ULONG listSize = 1024; ; )\n\t{\n\t\tlist = (MEGARAID_PHYSICAL_DRIVE_LIST*)VirtualAlloc(NULL, listSize, MEM_COMMIT, PAGE_READWRITE);\n\t\tif (!list)\n\t\t{\n\t\t\tsafeCloseHandle(hHandle);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tmemset(list, 0, listSize);\n\t\tif (!SendDCommandMegaRAID(hHandle, MFI_DCMD_PD_GET_LIST, list, listSize, NULL, 0))\n\t\t{\n\t\t\tsafeCloseHandle(hHandle);\n\t\t\tsafeVirtualFree(list, 0, MEM_RELEASE);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (list->Size <= listSize)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tlistSize = list->Size;\n\n\t\tsafeVirtualFree(list, 0, MEM_RELEASE);\n\t\tlist = NULL;\n\t}\n\n\tIDENTIFY_DEVICE identify = {};\n\tfor (ULONG i = 0; i < list->Count; i++)\n\t{\n\t\tif (list->Addr[i].ScsiDevType > 0) // non disk device\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (DoIdentifyDeviceMegaRAID(scsiPort, list->Addr[i].DeviceId, &identify))\n\t\t{\n\t\t\tAddDisk(-1, scsiPort, list->Addr[i].DeviceId, -1, 0xA0, CMD_TYPE_MEGARAID, &identify);\n\t\t}\n\t}\n\n\tsafeCloseHandle(hHandle);\n\tsafeVirtualFree(list, 0, MEM_RELEASE);\n\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceMegaRAID(INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data)\n{\n\tUCHAR Cdb[16] = {};\n\tUCHAR CdbLength = 12;\n\t//memset(Cdb, 0, sizeof(Cdb));\n\n\tCdb[0] = 0xA1;//ATA PASS THROUGH(12) OPERATION CODE(A1h)\n\tCdb[1] = (4 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\tCdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\tCdb[3] = 0;//FEATURES (7:0)\n\tCdb[4] = 1;//SECTOR_COUNT (7:0)\n\tCdb[5] = 0;//LBA_LOW (7:0)\n\tCdb[6] = 0;//LBA_MID (7:0)\n\tCdb[7] = 0;//LBA_HIGH (7:0)\n\tCdb[8] = 0;//target\n\tCdb[9] = ID_CMD;//COMMAND\n\n\tif (!SendPassThroughCommandMegaRAID(scsiPort, scsiTargetId, data, sizeof(ATA_IDENTIFY_DEVICE), Cdb, CdbLength))\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn\tTRUE;\n}\n\nBOOL CAtaSmart::GetSmartAttributeMegaRAID(INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tIDEREGS irDriveRegs = {};\n\t//memset(&irDriveRegs, 0, sizeof(irDriveRegs));\n\n\tirDriveRegs.bFeaturesReg = READ_ATTRIBUTES;\n\tirDriveRegs.bSectorCountReg = 1;\n\tirDriveRegs.bSectorNumberReg = 0;\n\tirDriveRegs.bCylLowReg = SMART_CYL_LOW;\n\tirDriveRegs.bCylHighReg = SMART_CYL_HI;\n\tirDriveRegs.bDriveHeadReg = 0;\n\tirDriveRegs.bCommandReg = SMART_CMD;\n\n\tUCHAR Cdb[16] = {};\n\tUCHAR CdbLength = 12;\n\t//memset(Cdb, 0, sizeof(Cdb));\n\n\tCdb[0] = 0xA1;//ATA PASS THROUGH(12) OPERATION CODE(A1h)\n\tCdb[1] = (4 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\tCdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\tmemcpy_s(Cdb + 3, sizeof(Cdb) - 3, &irDriveRegs, sizeof(irDriveRegs));\n\n\tif (!SendPassThroughCommandMegaRAID(scsiPort, scsiTargetId, asi->SmartReadData, READ_ATTRIBUTE_BUFFER_SIZE, Cdb, CdbLength))\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn FillSmartData(asi);\n}\n\nBOOL CAtaSmart::GetSmartThresholdMegaRAID(INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi)\n{\n\tIDEREGS irDriveRegs = {};\n\t//memset(&irDriveRegs, 0, sizeof(irDriveRegs));\n\n\tirDriveRegs.bFeaturesReg = READ_THRESHOLDS;\n\tirDriveRegs.bSectorCountReg = 1;\n\tirDriveRegs.bSectorNumberReg = 0;\n\tirDriveRegs.bCylLowReg = SMART_CYL_LOW;\n\tirDriveRegs.bCylHighReg = SMART_CYL_HI;\n\tirDriveRegs.bCommandReg = SMART_CMD;\n\n\tUCHAR Cdb[16] = {};\n\tUCHAR CdbLength = 12;\n\t//memset(Cdb, 0, sizeof(Cdb));\n\n\tCdb[0] = 0xA1;//ATA PASS THROUGH(12) OPERATION CODE(A1h)\n\tCdb[1] = (4 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\tCdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\tmemcpy_s(Cdb + 3, sizeof(Cdb) - 3, &irDriveRegs, sizeof(irDriveRegs));\n\n\tif (!SendPassThroughCommandMegaRAID(scsiPort, scsiTargetId, asi->SmartReadThreshold, READ_THRESHOLD_BUFFER_SIZE, Cdb, CdbLength))\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn FillSmartThreshold(asi);\n}\n\nBOOL CAtaSmart::ControlSmartStatusMegaRAID(INT scsiPort, INT scsiTargetId, BYTE command)\n{\n\tIDEREGS irDriveRegs = {};\n\t//memset(&irDriveRegs, 0, sizeof(irDriveRegs));\n\n\tirDriveRegs.bFeaturesReg = command;\n\tirDriveRegs.bSectorCountReg = 1;\n\tirDriveRegs.bSectorNumberReg = 0;\n\tirDriveRegs.bCylLowReg = SMART_CYL_LOW;\n\tirDriveRegs.bCylHighReg = SMART_CYL_HI;\n\tirDriveRegs.bCommandReg = SMART_CMD;\n\n\tUCHAR Cdb[16] = {};\n\tUCHAR CdbLength = 12;\n\t//memset(Cdb, 0, sizeof(Cdb));\n\n\tCdb[0] = 0xA1;//ATA PASS THROUGH(12) OPERATION CODE(A1h)\n\tCdb[1] = (4 << 1) | 0; //MULTIPLE_COUNT=0,PROTOCOL=4(PIO Data-In),Reserved\n\tCdb[2] = (1 << 3) | (1 << 2) | 2;//OFF_LINE=0,CK_COND=0,Reserved=0,T_DIR=1(ToDevice),BYTE_BLOCK=1,T_LENGTH=2\n\tmemcpy_s(Cdb + 3, sizeof(Cdb) - 3, &irDriveRegs, sizeof(irDriveRegs));\n\n\tif (!SendPassThroughCommandMegaRAID(scsiPort, scsiTargetId, NULL, READ_ATTRIBUTE_BUFFER_SIZE, Cdb, CdbLength))\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn\tTRUE;\n}\n\nBOOL CAtaSmart::SendAtaCommandMegaRAID(INT scsiPort, INT scsiTargetId, BYTE main, BYTE sub, BYTE param)\n{\n/** Does not work...\n*/\n\treturn FALSE;\n}\n\n#ifdef JMICRON_USB_RAID_SUPPORT\nBOOL CAtaSmart::AddDiskJMS56X(INT index)\n{\n\tif (! hJMS56X) {\treturn FALSE; }\n\tIDENTIFY_DEVICE identify = { 0 };\n\n\tfor (int i = 0; i < 5 /*MAX_DISK_IN_CONTROLLER*/; i++)\n\t{\n\t\tif (DoIdentifyDeviceJMS56X(index, i, &identify))\n\t\t{\n\t\t\tAddDisk(-1, i, NULL, index, 0xA0, CMD_TYPE_JMS56X, &identify);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceJMS56X(INT index, BYTE port, IDENTIFY_DEVICE* identify)\n{\n\tif (!hJMS56X) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetIdentifyInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\treturn pGetIdentifyInfoJMS56X(index, port, (UNION_IDENTIFY_DEVICE*)identify);\n}\n\nBOOL CAtaSmart::GetSmartInfoJMS56X(INT index, BYTE port, ATA_SMART_INFO* asi)\n{\n\tif (!hJMS56X) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetSmartInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\tpGetSmartInfoJMS56X(index, port, (UNION_SMART_ATTRIBUTE*)&(asi->SmartReadData), (UNION_SMART_THRESHOLD*)&(asi->SmartReadThreshold));\n\tFillSmartData(asi);\n\tFillSmartThreshold(asi);\n\n\tif (asi->AttributeCount == 0)\n\t{\n\t\tSleep(1000);\n\t\tpGetSmartInfoJMS56X(index, port, (UNION_SMART_ATTRIBUTE*)&(asi->SmartReadData), (UNION_SMART_THRESHOLD*)&(asi->SmartReadThreshold));\n\t\tFillSmartData(asi);\n\t\tFillSmartThreshold(asi);\n\t}\n\n\tif (asi->AttributeCount > 0)\n\t{\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n\nBOOL CAtaSmart::AddDiskJMB39X(INT index)\n{\n\tif (!hJMB39X) { return FALSE; }\n\tIDENTIFY_DEVICE identify = { 0 };\n\n\tfor (int i = 0; i < 5 /*MAX_DISK_IN_CONTROLLER*/; i++)\n\t{\n\t\tif (DoIdentifyDeviceJMB39X(index, i, &identify))\n\t\t{\n\t\t\tAddDisk(-1, i, NULL, index, 0xA0, CMD_TYPE_JMB39X, &identify);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceJMB39X(INT index, BYTE port, IDENTIFY_DEVICE* identify)\n{\n\tif (!hJMB39X) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetIdentifyInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\treturn pGetIdentifyInfoJMB39X(index, port, (UNION_IDENTIFY_DEVICE*)identify);\n}\n\nBOOL CAtaSmart::GetSmartInfoJMB39X(INT index, BYTE port, ATA_SMART_INFO* asi)\n{\n\tif (!hJMB39X) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetSmartInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\tpGetSmartInfoJMB39X(index, port, (UNION_SMART_ATTRIBUTE*)&(asi->SmartReadData), (UNION_SMART_THRESHOLD*)&(asi->SmartReadThreshold));\n\tFillSmartData(asi);\n\tFillSmartThreshold(asi);\n\n\tif (asi->AttributeCount == 0)\n\t{\n\t\tSleep(1000);\n\t\tpGetSmartInfoJMB39X(index, port, (UNION_SMART_ATTRIBUTE*)&(asi->SmartReadData), (UNION_SMART_THRESHOLD*)&(asi->SmartReadThreshold));\n\t\tFillSmartData(asi);\n\t\tFillSmartThreshold(asi);\n\t}\n\n\tif (asi->AttributeCount > 0)\n\t{\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nBOOL CAtaSmart::AddDiskJMS586_20(INT index)\n{\n\tif (!hJMS586_20) { return FALSE; }\n\tIDENTIFY_DEVICE identify = { 0 };\n\tNVME_PORT_20 nvmePort = { 0 };\n\n\t/*\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif (DoIdentifyDeviceJMS586(index, i, &identify))\n\t\t{\n\t\t\tAddDisk(-1, i, NULL, index, 0xA0, CMD_TYPE_JMS586, &identify);\n\t\t}\n\t}\n\t*/\n\n\tfor (int i = 0; i < 2 /*MAX_DISK_IN_CONTROLLER*/; i++)\n\t{\n\t\tif (GetNVMePortInfoJMS586_20(index, i, &nvmePort))\n\t\t{\n\t\t\tAddDiskNVMe(-1, index, i, -1, -1, CMD_TYPE_JMS586_20, &identify, 0, L\"\", &nvmePort);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceJMS586_20(INT index, BYTE port, IDENTIFY_DEVICE* identify)\n{\n\tif (!hJMS586_20) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetIdentifyInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\treturn pGetIdentifyInfoJMS586_20(index, port, (UNION_IDENTIFY_DEVICE*)identify);\n}\n\nBOOL CAtaSmart::GetSmartInfoJMS586_20(INT index, BYTE port, ATA_SMART_INFO* asi)\n{\n\tif (!hJMS586_20) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetSmartInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\tpGetSmartInfoJMS586_20(index, port, (UNION_SMART_ATTRIBUTE*)&(asi->SmartReadData), (UNION_SMART_THRESHOLD*)&(asi->SmartReadThreshold));\n\tFillSmartData(asi);\n\tFillSmartThreshold(asi);\n\n\tif (asi->AttributeCount == 0)\n\t{\n\t\tSleep(1000);\n\t\tpGetSmartInfoJMS586_20(index, port, (UNION_SMART_ATTRIBUTE*)&(asi->SmartReadData), (UNION_SMART_THRESHOLD*)&(asi->SmartReadThreshold));\n\t\tFillSmartData(asi);\n\t\tFillSmartThreshold(asi);\n\t}\n\n\tif (asi->AttributeCount > 0)\n\t{\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nBOOL CAtaSmart::GetNVMePortInfoJMS586_20(INT index, BYTE port, NVME_PORT_20* nvmePort)\n{\n\tif (!hJMS586_20) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetNVMePortInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\treturn pGetNVMePortInfoJMS586_20(index, port, nvmePort);\n}\n\nBOOL CAtaSmart::GetNVMeSmartInfoJMS586_20(INT index, BYTE port, UNION_SMART_ATTRIBUTE* smartInfo)\n{\n\tif (!hJMS586_20) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetNVMeSmartInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\treturn pGetNVMeSmartInfoJMS586_20(index, port, smartInfo);\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeJMS586_20(INT index, INT port, ATA_SMART_INFO* asi)\n{\n\tBOOL flag = FALSE;\n\tUNION_SMART_ATTRIBUTE smartInfo;\n\tflag = GetNVMeSmartInfoJMS586_20(index, port, &smartInfo);\n\tmemcpy_s(&(asi->SmartReadData), 512, smartInfo.B.b, 512);\n\n\treturn flag;\n}\n\nBOOL CAtaSmart::AddDiskJMS586_40(INT index)\n{\n\tif (!hJMS586_40) { return FALSE; }\n\tIDENTIFY_DEVICE identify = { 0 };\n\tNVME_PORT_40 nvmePort = { 0 };\n\tNVME_ID nvmeId = { 0 };\n\n\tfor (int i = 0; i < 2 /*MAX_DISK_IN_CONTROLLER*/; i++)\n\t{\n\t\tif (GetNVMePortInfoJMS586_40(index, i, &nvmePort))\n\t\t{\n\t\t\tAddDiskNVMe(-1, index, i, -1, -1, CMD_TYPE_JMS586_40, &identify, 0, L\"\", NULL, &nvmePort, &nvmeId);\n\t\t\t\n\t\t\t/*\n\t\t\tint count = 0;\n\t\t\tcount = vars.GetCount();\n\n\t\t\tBYTE cid = 0;\n\n\t\t\tControllerSerialNum2IdJMS586_40(index, &cid);\n\t\t\tGetNVMeIdInfoJMS586_40(cid, i, &nvmeId);\n\n\t\t\t// Stack is broken\n\t\t\tcount = vars.GetCount();\n\n\t\t\tAddDiskNVMe(-1, index, i, -1, -1, CMD_TYPE_JMS586_40, &identify, 0, L\"\", NULL, &nvmePort, &nvmeId);\n\n\t\t\tif (GetNVMeIdInfoJMS586_40(index, i, &nvmeId))\n\t\t\t{\n\t\t\t\tAddDiskNVMe(-1, index, i, -1, -1, CMD_TYPE_JMS586_40, &identify, 0, L\"\", NULL, &nvmePort, &nvmeId);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceJMS586_40(BYTE index, BYTE port, IDENTIFY_DEVICE* identify)\n{\n\tif (!hJMS586_40) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetIdentifyInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\treturn pGetIdentifyInfoJMS586_40(index, port, (UNION_IDENTIFY_DEVICE*)identify);\n}\n\nBOOL CAtaSmart::GetSmartInfoJMS586_40(BYTE index, BYTE port, ATA_SMART_INFO* asi)\n{\n\tif (!hJMS586_40) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetSmartInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\tpGetSmartInfoJMS586_40(index, port, (UNION_SMART_ATTRIBUTE*)&(asi->SmartReadData), (UNION_SMART_THRESHOLD*)&(asi->SmartReadThreshold));\n\tFillSmartData(asi);\n\tFillSmartThreshold(asi);\n\n\tif (asi->AttributeCount == 0)\n\t{\n\t\tSleep(1000);\n\t\tpGetSmartInfoJMS586_40(index, port, (UNION_SMART_ATTRIBUTE*)&(asi->SmartReadData), (UNION_SMART_THRESHOLD*)&(asi->SmartReadThreshold));\n\t\tFillSmartData(asi);\n\t\tFillSmartThreshold(asi);\n\t}\n\n\tif (asi->AttributeCount > 0)\n\t{\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nBOOL CAtaSmart::GetNVMePortInfoJMS586_40(BYTE index, BYTE port, NVME_PORT_40* nvmePort)\n{\n\tif (!hJMS586_40) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetNVMePortInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\treturn pGetNVMePortInfoJMS586_40(index, port, nvmePort);\n}\n\nBOOL CAtaSmart::GetNVMeSmartInfoJMS586_40(BYTE index, BYTE port, UNION_SMART_ATTRIBUTE* smartInfo)\n{\n\tif (!hJMS586_40) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetNVMeSmartInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\treturn pGetNVMeSmartInfoJMS586_40(index, port, smartInfo);\n}\n\nBOOL CAtaSmart::GetSmartAttributeNVMeJMS586_40(BYTE index, BYTE port, ATA_SMART_INFO* asi)\n{\n\tBOOL flag = FALSE;\n\tUNION_SMART_ATTRIBUTE smartInfo;\n\tflag = GetNVMeSmartInfoJMS586_40(index, port, &smartInfo);\n\tmemcpy_s(&(asi->SmartReadData), 512, smartInfo.B.b, 512);\n\n\treturn flag;\n}\n\nBOOL CAtaSmart::GetNVMeIdInfoJMS586_40(BYTE index, BYTE port, NVME_ID* nvmeId)\n{\n\tif (!hJMS586_40) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"GetNVMeIdInfoFx: index %d, port %d\", index, port);\n\tDebugPrint(cstr);\n\n\treturn pGetNVMeIdInfoJMS586_40(index, port, nvmeId);\n}\n\n\nBOOL CAtaSmart::ControllerSerialNum2IdJMS586_40(BYTE index, BYTE* cid)\n{\n\tif (!hJMS586_40) { return FALSE; }\n\tCString cstr;\n\tcstr.Format(L\"ControllerSerialNum2IdFx: index %d, cid %d\", index, *cid);\n\tDebugPrint(cstr);\n\n\t//\treturn NULL;\n\treturn pControllerSerialNum2IdJMS586_40(index, cid);\n}\n\n#endif\n\n/*---------------------------------------------------------------------------*/\n// Fill S.M.A.R.T. Information\n/*---------------------------------------------------------------------------*/\n\nBOOL CAtaSmart::FillSmartData(ATA_SMART_INFO* asi)\n{\n\tCString str;\n\tasi->AttributeCount = 0;\n\tint j = 0;\n\tfor(int i = 0; i < MAX_ATTRIBUTE; i++)\n\t{\n\t\tDWORD rawValue = 0;\n\t\tmemcpy(\t&(asi->Attribute[j]), \n\t\t\t&(asi->SmartReadData[i * sizeof(SMART_ATTRIBUTE) + 2]), sizeof(SMART_ATTRIBUTE));\n\n\t\tif(asi->Attribute[j].Id != 0)\n\t\t{\n\t\t\tswitch(asi->Attribute[j].Id)\n\t\t\t{\n\t\t\tcase 0x09: // Power on Hours\n\t\t\t\trawValue = *(DWORD*)&asi->Attribute[j].RawValue[0];\n\t\t\t\t/*\tMAKELONG(\n\t\t\t\t\tMAKEWORD(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1]),\n\t\t\t\t\tMAKEWORD(asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3])\n\t\t\t\t\t);*/\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_INDILINX)\n\t\t\t\t{\n\t\t\t\t\trawValue = asi->Attribute[j].WorstValue * 256 + asi->Attribute[j].CurrentValue;\n\t\t\t\t}\n\t\t\t\t// Intel SSD 520 Series and etc...\n\t\t\t\telse if (\n\t\t\t\t\t(asi->DetectedTimeUnitType == POWER_ON_MILLI_SECONDS)\n\t\t\t\t||  (asi->DetectedTimeUnitType == POWER_ON_HOURS && rawValue >= 0x0DA000)\n\t\t\t\t|| (asi->Model.Find(_T(\"Intel\")) == 0 && rawValue >= 0x0DA000)\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tasi->MeasuredTimeUnitType = POWER_ON_MILLI_SECONDS;\n\t\t\t\t\tint value = 0; \n\t\t\t\t\trawValue = value = asi->Attribute[j].RawValue[2] * 256 * 256\n\t\t\t\t\t\t\t\t\t + asi->Attribute[j].RawValue[1] * 256\n\t\t\t\t\t\t\t\t\t + asi->Attribute[j].RawValue[0] - 0x0DA753; // https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=560;id=diskinfo#560\n\t\t\t\t\tif(value < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\trawValue = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tasi->PowerOnRawValue = rawValue;\n\t\t\t\tasi->DetectedPowerOnHours = GetPowerOnHours(rawValue, asi->DetectedTimeUnitType);\n\t\t\t\tasi->MeasuredPowerOnHours = GetPowerOnHours(rawValue, asi->MeasuredTimeUnitType);\n\t\t\t\tbreak;\n\t\t\tcase 0x0C: // Power On Count\n\t\t\t\trawValue = *(DWORD*)&asi->Attribute[j].RawValue[0]; \n\t\t\t\t/*MAKELONG(\n\t\t\t\t\tMAKEWORD(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1]),\n\t\t\t\t\tMAKEWORD(asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3])\n\t\t\t\t\t);*/\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_INDILINX)\n\t\t\t\t{\n\t\t\t\t\trawValue = asi->Attribute[j].WorstValue * 256 + asi->Attribute[j].CurrentValue;\n\t\t\t\t}\n\t\t\t\tasi->PowerOnCount = rawValue;\n\t\t\t\tbreak;\n\t\t\tcase 0xBE:\n\t\t\t\tif(asi->Attribute[j].RawValue[0] > 0 && asi->Attribute[j].RawValue[0] < 100)\n\t\t\t\t{\n\t\t\t\t\tasi->Temperature = asi->Attribute[j].RawValue[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xBF: // Clean PowerOff Count for Sandisk/WD CloudSpeed SSD\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_SANDISK_CLOUD)\n\t\t\t\t{\n\t\t\t\t\t// Use Clean Shutdowns to calculate Power On Count\n\t\t\t\t\trawValue = *(DWORD*)&asi->Attribute[j].RawValue[0];\n\t\t\t\t\tasi->PowerOnCount = rawValue + 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xC0: // UnClean PowerOff Count for Sandisk/WD CloudSpeed SSD\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_SANDISK_CLOUD)\n\t\t\t\t{\n\t\t\t\t\t// Use UnClean Shutdowns to calculate Power On Count\n\t\t\t\t\trawValue = *(DWORD*)&asi->Attribute[j].RawValue[0];\n\t\t\t\t\tasi->PowerOnCount += rawValue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xC2: // Temperature\n\t\t\t\tif(asi->Model.Find(_T(\"SAMSUNG SV\")) == 0 && (asi->Attribute[j].RawValue[1] != 0 || asi->Attribute[j].RawValue[0] > 70))\n\t\t\t\t{\n\t\t\t\t\tasi->Temperature = *(WORD*)&asi->Attribute[j].RawValue[0] / 10;//MAKEWORD(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1]) / 10;\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(asi->Attribute[j].RawValue[0] > 0 && asi->TemperatureMultiplier < 1.0)//(asi->DiskVendorId == SSD_VENDOR_SANDFORCE)\n\t\t\t\t{\n\t\t\t\t\tasi->Temperature = (DWORD)(asi->Attribute[j].RawValue[0] * asi->TemperatureMultiplier);\n\t\t\t\t}\n\t\t\t\telse if(asi->Attribute[j].RawValue[0] > 0)\n\t\t\t\t{\n\t\t\t\t\tasi->Temperature = asi->Attribute[j].RawValue[0];\n\t\t\t\t}\n\n\t\t\t\tif(asi->Temperature >= 100)\n\t\t\t\t{\n\t\t\t\t\tasi->Temperature = -1000;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xF3: // Temperature for YMTC\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_YMTC)\n\t\t\t\t{\n\t\t\t\t\tif (asi->Attribute[j].RawValue[0] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->Temperature = asi->Attribute[j].RawValue[0];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (asi->Temperature >= 100)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->Temperature = -1000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_INTEL)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 32); //  65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xBB:\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_MTRON)\n\t\t\t\t{\n\t\t\t\t\tasi->Life = asi->Attribute[j].CurrentValue;\n\t\t\t\t\tif (asi->Life < 0 || asi->Life > 100) { asi->Life = -1; }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xCA:\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_MICRON || asi->DiskVendorId == SSD_VENDOR_MICRON_MU03 || asi->DiskVendorId == SSD_VENDOR_INTEL_DC || asi->DiskVendorId == SSD_VENDOR_SILICONMOTION_CVC)\n\t\t\t\t{\n\t\t\t\t\tasi->Life = asi->Attribute[j].CurrentValue;\n\t\t\t\t\tif (asi->Life < 0 || asi->Life > 100) { asi->Life = -1; }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xD1:\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_INDILINX)\n\t\t\t\t{\n\t\t\t\t\tasi->Life = asi->Attribute[j].CurrentValue;\n\t\t\t\t\tif (asi->Life < 0 || asi->Life > 100) { asi->Life = -1; }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xC9:\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_SANDISK_HP || asi->DiskVendorId == SSD_VENDOR_SANDISK_HP_VENUS)\n\t\t\t\t{\n\t\t\t\t\tint life = -1;\n\t\t\t\t\tif (life < 0 || life > 100) { life = -1; }\n\t\t\t\t\tlife = asi->Attribute[j].CurrentValue;\n\t\t\t\t\tasi->Life = life;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xE6:\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_WDC || asi->DiskVendorId == SSD_VENDOR_SANDISK)\n\t\t\t\t{\n\t\t\t\t\tint life = -1;\n\t\t\t\t\tif (asi->FlagLifeSanDiskUsbMemory)\n\t\t\t\t\t{\n\t\t\t\t\t\tlife = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->FlagLifeSanDisk0_1)\n\t\t\t\t\t{\n\t\t\t\t\t\tlife = 100 - (asi->Attribute[j].RawValue[1]*256+asi->Attribute[j].RawValue[0])/100;\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->FlagLifeSanDisk1)\n\t\t\t\t\t{\n\t\t\t\t\t\tlife = 100 - asi->Attribute[j].RawValue[1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->FlagLifeSanDiskLenovo)\n\t\t\t\t\t{\n\t\t\t\t\t\tlife = asi->Attribute[j].CurrentValue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlife = 100 - asi->Attribute[j].RawValue[1];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (life < 0 || life > 100) { life = -1; }\n\n\t\t\t\t\tasi->Life = life;\n\t\t\t\t}\n\t\t\t\telse if(asi->DiskVendorId == SSD_VENDOR_SANDISK_LENOVO || asi->DiskVendorId == SSD_VENDOR_SANDISK_DELL)\n\t\t\t\t{\n\t\t\t\t\tint life = -1;\n\t\t\t\t\tif (life < 0 || life > 100) { life = -1; }\n\t\t\t\t\tlife = asi->Attribute[j].CurrentValue;\n\t\t\t\t\tasi->Life = life;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xE8:\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_PLEXTOR)\n\t\t\t\t{\n\t\t\t\t\tasi->Life = asi->Attribute[j].CurrentValue;\n\t\t\t\t\tif (asi->Life < 0 || asi->Life > 100) { asi->Life = -1; }\n\t\t\t\t}\n\t\t\t\telse if(asi->DiskVendorId == SSD_VENDOR_OCZ)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites  = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xE9:\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_INTEL || asi->DiskVendorId == SSD_VENDOR_OCZ || asi->DiskVendorId == SSD_VENDOR_OCZ_VECTOR || asi->DiskVendorId == SSD_VENDOR_SKHYNIX)\n\t\t\t\t{\n\t\t\t\t\tif (asi->FlagLifeRawValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->Life = asi->Attribute[j].RawValue[0];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->Life = asi->Attribute[j].CurrentValue;\n\t\t\t\t\t}\n\t\t\t\t\tif (asi->Life < 0 || asi->Life > 100) { asi->Life = -1; }\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS)\n\t\t\t\t{\n\t\t\t\t\tasi->Life = asi->Attribute[j].CurrentValue;\n\t\t\t\t\tif (asi->Life < 0 || asi->Life > 100) { asi->Life = -1; }\n\t\t\t\t}\n\t\t\t\telse if ((asi->DiskVendorId == SSD_VENDOR_SANDISK ||\n\t\t\t\t\t\tasi->DiskVendorId == SSD_VENDOR_SANDISK_LENOVO ||\n\t\t\t\t\t\tasi->DiskVendorId == SSD_VENDOR_SANDISK_CLOUD)\n\t\t\t\t\t&& asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = *(INT*)&asi->Attribute[j].RawValue[0];// (INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_PLEXTOR || asi->DiskVendorId == SSD_VENDOR_KINGSTON || asi->DiskVendorId == SSD_VENDOR_WDC || asi->DiskVendorId == SSD_VENDOR_SSSTC || asi->DiskVendorId == SSD_VENDOR_SEAGATE || asi->DiskVendorId == SSD_VENDOR_YMTC || asi->DiskVendorId == SSD_VENDOR_SILICONMOTION_CVC)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = *(INT*)&asi->Attribute[j].RawValue[0];\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_JMICRON || asi->DiskVendorId == SSD_VENDOR_ADATA_INDUSTRIAL)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_MAXIOTEK)\n\t\t\t\t{\n\t\t\t\t\tif (asi->HostReadsWritesUnit == HOST_READS_WRITES_512B)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->NandWrites = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->NandWrites = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xE1:\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_INTEL)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites  = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 32); //  65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xEA:\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_KINGSTON || asi->DiskVendorId == SSD_VENDOR_SEAGATE\n\t\t\t\t\t||  (asi->DiskVendorId == SSD_VENDOR_SKHYNIX && asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xEB:\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_INTEL_DC)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xF1:\n\t\t\t\tif (asi->DiskVendorId == SSD_GENERAL)\n\t\t\t\t{\n\t\t\t\t\tif (asi->HostReadsWritesUnit == HOST_READS_WRITES_512B)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostWrites = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->HostReadsWritesUnit == HOST_READS_WRITES_1MB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostWrites = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 1024);\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->HostReadsWritesUnit == HOST_READS_WRITES_16MB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostWrites = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 64);\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->HostReadsWritesUnit == HOST_READS_WRITES_32MB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostWrites = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostWrites = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_TOSHIBA && asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_SILICONMOTION_CVC && asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites = *((INT*)&asi->Attribute[j].RawValue[0]);\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_INTEL_DC)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5]) \n\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t}\n\t\t\t\telse if(asi->DiskVendorId == SSD_VENDOR_INTEL || asi->DiskVendorId == SSD_VENDOR_TOSHIBA || asi->DiskVendorId == SSD_VENDOR_KIOXIA || asi->DiskVendorId == SSD_VENDOR_SILICONMOTION)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites  = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_SANDFORCE || asi->DiskVendorId == SSD_VENDOR_OCZ_VECTOR || asi->DiskVendorId == SSD_VENDOR_CORSAIR || asi->DiskVendorId == SSD_VENDOR_KINGSTON || asi->DiskVendorId == SSD_VENDOR_REALTEK\n\t\t\t\t\t||   asi->DiskVendorId == SSD_VENDOR_WDC || asi->DiskVendorId == SSD_VENDOR_SSSTC || asi->DiskVendorId == SSD_VENDOR_SKHYNIX || asi->DiskVendorId == SSD_VENDOR_PHISON || asi->DiskVendorId == SSD_VENDOR_SEAGATE || asi->DiskVendorId == SSD_VENDOR_MARVELL\n\t\t\t\t\t||   asi->DiskVendorId == SSD_VENDOR_MAXIOTEK || asi->DiskVendorId == SSD_VENDOR_YMTC || asi->DiskVendorId == SSD_VENDOR_SCY || asi->DiskVendorId == SSD_VENDOR_RECADATA || asi->DiskVendorId == SSD_VENDOR_MICRON_MU03\n\t\t\t\t\t||   asi->DiskVendorId == SSD_VENDOR_SANDISK_HP || asi->DiskVendorId == SSD_VENDOR_SANDISK_HP_VENUS || asi->DiskVendorId == SSD_VENDOR_SANDISK_LENOVO || asi->DiskVendorId == SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS || asi->DiskVendorId == SSD_VENDOR_SANDISK_DELL || asi->DiskVendorId == SSD_VENDOR_ADATA_INDUSTRIAL\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tif (asi->HostReadsWritesUnit == HOST_READS_WRITES_512B)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostWrites = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5]) \n\t\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->HostReadsWritesUnit == HOST_READS_WRITES_1MB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostWrites = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 1024);\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->HostReadsWritesUnit == HOST_READS_WRITES_16MB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostWrites = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 64);\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->HostReadsWritesUnit == HOST_READS_WRITES_32MB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostWrites = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostWrites  = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_SAMSUNG && asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\telse if(asi->DiskVendorId == SSD_VENDOR_SAMSUNG || asi->DiskVendorId == SSD_VENDOR_APACER || asi->DiskVendorId == SSD_VENDOR_JMICRON)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites  = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\telse if(asi->DiskVendorId == SSD_VENDOR_PLEXTOR)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites  = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t / 32);\n\t\t\t\t}\n\t\t\t\telse if((asi->DiskVendorId == SSD_VENDOR_SANDISK ||\n\t\t\t\t\t\tasi->DiskVendorId == SSD_VENDOR_SANDISK_CLOUD)\n\t\t\t\t\t&& asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_SANDISK)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites = (INT) (\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xF2:\n\t\t\t\tif (asi->DiskVendorId == SSD_GENERAL)\n\t\t\t\t{\n\t\t\t\t\tif (asi->HostReadsWritesUnit == HOST_READS_WRITES_512B)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostReads = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->HostReadsWritesUnit == HOST_READS_WRITES_16MB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostReads = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 64);\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->HostReadsWritesUnit == HOST_READS_WRITES_32MB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostReads = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t\t}\n\t\t\t\t\telse if(asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostReads = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_TOSHIBA && asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t{\n\t\t\t\t\tasi->HostReads = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_SILICONMOTION_CVC && asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t{\n\t\t\t\t\tasi->HostReads = *(INT*)&asi->Attribute[j].RawValue[0];\n\t\t\t\t}\n\t\t\t\telse if(asi->DiskVendorId == SSD_VENDOR_INTEL || asi->DiskVendorId == SSD_VENDOR_TOSHIBA || asi->DiskVendorId == SSD_VENDOR_SILICONMOTION)\n\t\t\t\t{\n\t\t\t\t\tasi->HostReads  = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_SANDFORCE || asi->DiskVendorId == SSD_VENDOR_OCZ_VECTOR || asi->DiskVendorId == SSD_VENDOR_CORSAIR || asi->DiskVendorId == SSD_VENDOR_KINGSTON || asi->DiskVendorId == SSD_VENDOR_REALTEK\n\t\t\t\t\t||   asi->DiskVendorId == SSD_VENDOR_WDC || asi->DiskVendorId == SSD_VENDOR_SSSTC || asi->DiskVendorId == SSD_VENDOR_SKHYNIX || asi->DiskVendorId == SSD_VENDOR_SEAGATE || asi->DiskVendorId == SSD_VENDOR_MARVELL\n\t\t\t\t\t||   asi->DiskVendorId == SSD_VENDOR_MAXIOTEK || asi->DiskVendorId == SSD_VENDOR_YMTC || asi->DiskVendorId == SSD_VENDOR_SCY || asi->DiskVendorId == SSD_VENDOR_RECADATA || asi->DiskVendorId == SSD_VENDOR_MICRON_MU03\n\t\t\t\t\t||   asi->DiskVendorId == SSD_VENDOR_SANDISK_HP || asi->DiskVendorId == SSD_VENDOR_SANDISK_HP_VENUS || asi->DiskVendorId == SSD_VENDOR_SANDISK_LENOVO || asi->DiskVendorId == SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS || asi->DiskVendorId == SSD_VENDOR_SANDISK_DELL || asi->DiskVendorId == SSD_VENDOR_ADATA_INDUSTRIAL\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tif (asi->HostReadsWritesUnit == HOST_READS_WRITES_512B)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostReads = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->HostReadsWritesUnit == HOST_READS_WRITES_16MB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostReads = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 64);\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->HostReadsWritesUnit == HOST_READS_WRITES_32MB)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostReads = (INT)(\n\t\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t\t/ 32); // 65536 * 512 / 1024 / 1024 / 1024;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->HostReads  = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_SAMSUNG && asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t{\n\t\t\t\t\tasi->HostReads = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\telse if(asi->DiskVendorId == SSD_VENDOR_SAMSUNG || asi->DiskVendorId == SSD_VENDOR_JMICRON)\n\t\t\t\t{\n\t\t\t\t\tasi->HostReads  = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\telse if(asi->DiskVendorId == SSD_VENDOR_PLEXTOR)\n\t\t\t\t{\n\t\t\t\t\tasi->HostReads  = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 32);\n\t\t\t\t}\n\t\t\t\telse if ((asi->DiskVendorId == SSD_VENDOR_SANDISK ||\n\t\t\t\t\tasi->DiskVendorId == SSD_VENDOR_SANDISK_CLOUD)\n\t\t\t\t\t&& asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t{\n\t\t\t\t\tasi->HostReads = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_SANDISK)\n\t\t\t\t{\n\t\t\t\t\tasi->HostReads = (INT) (\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5]) \n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xF9:\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_INTEL || asi->DiskVendorId == SSD_VENDOR_REALTEK || asi->DiskVendorId == SSD_VENDOR_WDC || (asi->DiskVendorId == SSD_VENDOR_SANDISK && asi->HostReadsWritesUnit == HOST_READS_WRITES_GB)\n\t\t\t\t|| asi->DiskVendorId == SSD_VENDOR_SANDISK_HP || asi->DiskVendorId == SSD_VENDOR_SANDISK_HP_VENUS || asi->DiskVendorId == SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites  = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\telse if(asi->DiskVendorId == SSD_VENDOR_OCZ_VECTOR)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites  = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 64 / 1024); // 16 / 1024 / 1024\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xFA:\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_REALTEK)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0x64:\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_SANDFORCE)\n\t\t\t\t{\n\t\t\t\t\tasi->GBytesErased  = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xAD:\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_TOSHIBA || asi->DiskVendorId == SSD_VENDOR_KIOXIA)\n\t\t\t\t{\n\t\t\t\t\tasi->Life = asi->Attribute[j].CurrentValue - 100;\n\t\t\t\t\tif (asi->Life < 0 || asi->Life > 100) { asi->Life = -1; }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xB1:\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_SAMSUNG)\n\t\t\t\t{\n\t\t\t\t\tasi->WearLevelingCount  = *(INT*)&asi->Attribute[j].RawValue[0];\n\t\t\t\t\t\t/*(INT)MAKELONG(\n\t\t\t\t\t\tMAKEWORD(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1]),\n\t\t\t\t\t\tMAKEWORD(asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3])\n\t\t\t\t\t\t);*/\n\t\t\t\t\tasi->Life = asi->Attribute[j].CurrentValue;\n\t\t\t\t\tif (asi->Life < 0 || asi->Life > 100) { asi->Life = -1; }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xE7:\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_SANDFORCE || asi->DiskVendorId == SSD_VENDOR_CORSAIR || asi->DiskVendorId == SSD_VENDOR_KINGSTON || asi->DiskVendorId == SSD_VENDOR_SKHYNIX || asi->DiskVendorId == SSD_VENDOR_REALTEK\n\t\t\t\t||  asi->DiskVendorId == SSD_VENDOR_SANDISK || asi->DiskVendorId == SSD_VENDOR_SSSTC || asi->DiskVendorId == SSD_VENDOR_APACER || asi->DiskVendorId == SSD_VENDOR_JMICRON || asi->DiskVendorId == SSD_VENDOR_PHISON || asi->DiskVendorId == SSD_VENDOR_SEAGATE\n\t\t\t\t||  asi->DiskVendorId == SSD_VENDOR_MAXIOTEK || asi->DiskVendorId == SSD_VENDOR_YMTC || asi->DiskVendorId == SSD_VENDOR_SCY || asi->DiskVendorId == SSD_VENDOR_RECADATA || asi->DiskVendorId == SSD_VENDOR_ADATA_INDUSTRIAL)\n\t\t\t\t{\n\t\t\t\t\tif (asi->FlagLifeNoReport)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->Life = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->FlagLifeRawValueIncrement)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->Life = 100 - asi->Attribute[j].RawValue[0];\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->FlagLifeRawValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->Life = asi->Attribute[j].RawValue[0];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->Life = asi->Attribute[j].CurrentValue;\n\t\t\t\t\t}\n\t\t\t\t\tif (asi->Life < 0 || asi->Life > 100) { asi->Life = -1; }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xA9:\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_REALTEK || (asi->DiskVendorId == SSD_VENDOR_KINGSTON && asi->HostReadsWritesUnit == HOST_READS_WRITES_32MB) || asi->DiskVendorId == SSD_VENDOR_SILICONMOTION)\n\t\t\t\t{\n\t\t\t\t\tif (asi->FlagLifeRawValueIncrement)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->Life = 100 - asi->Attribute[j].RawValue[0];\n\t\t\t\t\t}\n\t\t\t\t\telse if (asi->FlagLifeRawValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->Life = asi->Attribute[j].RawValue[0];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tasi->Life = asi->Attribute[j].CurrentValue;\n\t\t\t\t\t}\n\t\t\t\t\tif (asi->Life < 0 || asi->Life > 100) { asi->Life = -1; }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xC6:\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_OCZ_VECTOR)\n\t\t\t\t{\n\t\t\t\t\tasi->HostReads  = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xC7:\n\t\t\t\tif(asi->DiskVendorId == SSD_VENDOR_OCZ_VECTOR)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites  = *(INT*)&asi->Attribute[j].RawValue[0];//(INT)B8toB32(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2], asi->Attribute[j].RawValue[3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xF5:\n\t\t\t\t// Percent Drive Life Remaining (SanDisk/WD CloudSpeed)\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_SANDISK_CLOUD)\n\t\t\t\t{\n\t\t\t\t\tasi->Life = asi->Attribute[j].CurrentValue;\n\t\t\t\t}\n\n\t\t\t\t// NAND Page Size = 8KBytes\n\t\t\t\t// http://www.overclock.net/t/1145150/official-crucial-ssd-owners-club/1290\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_MICRON)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = (INT) (\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t* 8 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_MICRON_MU03)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t) / 32;\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_KINGSTON && asi->HostReadsWritesUnit == HOST_READS_WRITES_32MB)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t) / 32;\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_SILICONMOTION)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t) / 32;\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_SCY)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t) / 32;\n\t\t\t\t}\n\t\t\t\telse if (asi->DiskVendorId == SSD_VENDOR_RECADATA)\n\t\t\t\t{\n\t\t\t\t\tasi->NandWrites = (INT)(\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tasi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xF6:\n\t\t\t\tif (asi->DiskVendorId == SSD_VENDOR_MICRON || asi->DiskVendorId == SSD_VENDOR_MICRON_MU03)\n\t\t\t\t{\n\t\t\t\t\tasi->HostWrites = (INT) (\n\t\t\t\t\t\tB8toB64(asi->Attribute[j].RawValue[0], asi->Attribute[j].RawValue[1], asi->Attribute[j].RawValue[2],\n\t\t\t\t\t\t        asi->Attribute[j].RawValue[3], asi->Attribute[j].RawValue[4], asi->Attribute[j].RawValue[5])\n\t\t\t\t\t\t/ 2 / 1024 / 1024);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\tasi->AttributeCount = j;\n\n\tif(asi->AttributeCount > 0)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n}\n\nBOOL CAtaSmart::FillSmartThreshold(ATA_SMART_INFO* asi)\n{\n\t// 2016/04/18\n\t// https://github.com/hiyohiyo/CrystalDiskInfo/issues/1\n\tint count = 0;\n\tfor (int i = 0; i < MAX_ATTRIBUTE; i++)\n\t{\n\t\tSMART_THRESHOLD* pst = (SMART_THRESHOLD*)&(asi->SmartReadThreshold[i * sizeof(SMART_THRESHOLD) + 2]);\n\t\tif (pst->Id != 0)\n\t\t{\n\t\t\tfor (DWORD j = 0; j < asi->AttributeCount; j++)\n\t\t\t{\n\t\t\t\tif (pst->Id == asi->Attribute[j].Id)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&(asi->Threshold[j]), pst, sizeof(SMART_THRESHOLD));\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2013/04/13 Added P400e SSD SMART Implementation support\n\t// Threshold = Attribute[].Reserved\n\tif(asi->DiskVendorId == SSD_VENDOR_MICRON && count == 0)\n\t{\n\t\tfor(int i = 0; i < MAX_ATTRIBUTE; i++)\n\t\t{\n\t\t\tif(asi->Attribute[i].Reserved > 0)\n\t\t\t{\n\t\t\t\tasi->Threshold[i].Id = asi->Attribute[i].Id;\n\t\t\t\tasi->Threshold[i].ThresholdValue = asi->Attribute[i].Reserved;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2023/02/19 Disabled Threshold Check\n\t// if(count > 0)\n\tif(asi->AttributeCount > 0)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n}\n\n/*---------------------------------------------------------------------------*/\n// Support Functions\n/*---------------------------------------------------------------------------*/\n\nDWORD CAtaSmart::CheckDiskStatus(DWORD i)\n{\n\tif (vars.GetCount() == 0)\n\t{\n\t\treturn DISK_STATUS_UNKNOWN;\n\t}\n\n\t// NVMe\n\tif (vars[i].DiskVendorId == SSD_VENDOR_NVME)\n\t{\n\t\t// https://github.com/hiyohiyo/CrystalDiskInfo/issues/99\n\t\tif (vars[i].Model.Find(_T(\"Parallels\")) == 0\n\t\t||  vars[i].Model.Find(_T(\"VMware\")) == 0\n\t\t||  vars[i].Model.Find(_T(\"QEMU\")) == 0\n\t\t)\n\t\t{\n\t\t\treturn DISK_STATUS_UNKNOWN;\n\t\t}\n\n\t\tif (vars[i].Attribute[0].RawValue[0] > 0)\n\t\t{\n\t\t\treturn DISK_STATUS_BAD;\n\t\t}\n\n\t\tif (vars[i].Attribute[3].RawValue[0] == 0 || vars[i].Attribute[3].RawValue[0] > 100) // Available Spare Threshold does not available.\n\t\t{\n\t\t}\n\t\telse if (vars[i].Attribute[2].RawValue[0] < vars[i].Attribute[3].RawValue[0])\n\t\t{\n\t\t\treturn DISK_STATUS_BAD;\n\t\t}\n\t\telse if (vars[i].Attribute[2].RawValue[0] == vars[i].Attribute[3].RawValue[0] && vars[i].Attribute[3].RawValue[0] != 100)\n\t\t{\n\t\t\treturn DISK_STATUS_CAUTION;\n\t\t}\n\n\t\tif (vars[i].Life > vars[i].ThresholdFF)\n\t\t{\n\t\t\treturn DISK_STATUS_GOOD;\n\t\t}\n\t\telse if (vars[i].Life <= vars[i].ThresholdFF)\n\t\t{\n\t\t\treturn DISK_STATUS_CAUTION;\n\t\t}\n\t}\n\n\tif(! vars[i].IsSmartCorrect)\n\t{\n\t\treturn DISK_STATUS_UNKNOWN;\n\t}\n\telse if(! vars[i].IsSsd && ! vars[i].IsThresholdCorrect) // HDD\n\t{\n\t\treturn DISK_STATUS_UNKNOWN;\n\t}\n\telse if(vars[i].IsThresholdBug)\n\t{\n\t\treturn DISK_STATUS_UNKNOWN;\n\t}\n\n\t// DEBUG //\n\t// vars[i].Attribute[3].RawValue[0] = rand() % 256;\n\n\tint error = 0;\n\tint caution = 0;\n\tBOOL flagUnknown = TRUE;\n\n\tfor (DWORD j = 0; j < vars[i].AttributeCount; j++)\n\t{\n\t\t// Check overlap\n\t\tfor(DWORD k = 0; k < j; k++)\n\t\t{\n\t\t\tif(vars[i].Attribute[k].Id != 0 && vars[i].Attribute[j].Id == vars[i].Attribute[k].Id)\n\t\t\t{\n\t\t\t\treturn DISK_STATUS_UNKNOWN;\n\t\t\t}\n\t\t}\n\n\t\t// Read Error Rate Bug\n\t\tif(vars[i].DiskVendorId == SSD_VENDOR_SANDFORCE && vars[i].Attribute[j].Id == 0x01\n\t\t\t&& vars[i].Attribute[j].CurrentValue == 0 && vars[i].Attribute[j].RawValue[0] == 0 && vars[i].Attribute[j].RawValue[1] == 0)\n\t\t{\n\t\t}\n\t\t// [2021/12/15] Workaround for SanDisk USB Memory\n\t\telse if (vars[i].Attribute[j].Id == 0xE8 && vars[i].FlagLifeSanDiskUsbMemory)\n\t\t{\n\n\t\t}\n\t\t// Temperature Threshold Bug\n\t\telse if(vars[i].Attribute[j].Id == 0xC2)\n\t\t{\n\t\t}\n\t\telse if(vars[i].IsSsd && vars[i].IsRawValues8)\n\t\t{\n\t\t}\n\t\telse if(vars[i].IsSsd && ! vars[i].IsRawValues8\n\t\t&&\tvars[i].Threshold[j].ThresholdValue != 0\n\t\t&& \tvars[i].Attribute[j].CurrentValue < vars[i].Threshold[j].ThresholdValue)\n\t\t{\n\t\t\terror++;\n\t\t}\n\t\telse if((\n\t\t\t(0x01 <= vars[i].Attribute[j].Id && vars[i].Attribute[j].Id <= 0x0D)\n\t\t||\tvars[i].Attribute[j].Id == 0x16\n\t\t||\t(0xBB <= vars[i].Attribute[j].Id && vars[i].Attribute[j].Id <= 0xBD)\n\t\t||\t(0xBF <= vars[i].Attribute[j].Id && vars[i].Attribute[j].Id <= 0xC1)\n\t\t||\t(0xC3 <= vars[i].Attribute[j].Id && vars[i].Attribute[j].Id <= 0xD1)\n\t\t||\t(0xD3 <= vars[i].Attribute[j].Id && vars[i].Attribute[j].Id <= 0xD4)\n\t\t||\t(0xDC <= vars[i].Attribute[j].Id && vars[i].Attribute[j].Id <= 0xE4)\n\t\t||\t(0xE6 <= vars[i].Attribute[j].Id && vars[i].Attribute[j].Id <= 0xE7)\n\t\t||\tvars[i].Attribute[j].Id == 0xF0\n\t\t||\tvars[i].Attribute[j].Id == 0xFA\n\t\t||\tvars[i].Attribute[j].Id == 0xFE\n\t\t)\n\t\t&&\tvars[i].Threshold[j].ThresholdValue != 0\n\t\t&& \tvars[i].Attribute[j].CurrentValue < vars[i].Threshold[j].ThresholdValue)\n\t\t{\n\t\t\terror++;\n\t\t}\n\n\t\tif(vars[i].IsSsd && vars[i].Threshold[j].ThresholdValue != 0)\n\t\t{\n\t\t\tflagUnknown = FALSE;\n\t\t}\n\n\t\tif( vars[i].Attribute[j].Id == 0x05 // Reallocated Sectors Count\n\t\t||\tvars[i].Attribute[j].Id == 0xC5 // Current Pending Sector Count\n\t\t||\tvars[i].Attribute[j].Id == 0xC6 // Off-Line Scan Uncorrectable Sector Count\n\t\t)\n\t\t{\n\t\t\tif(vars[i].Attribute[j].RawValue[0] == 0xFF\n\t\t\t&& vars[i].Attribute[j].RawValue[1] == 0xFF\n\t\t\t&& vars[i].Attribute[j].RawValue[2] == 0xFF\n\t\t\t&& vars[i].Attribute[j].RawValue[3] == 0xFF)\n\t\t\t{\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWORD raw = MAKEWORD(vars[i].Attribute[j].RawValue[0], vars[i].Attribute[j].RawValue[1]);\n\t\t\t\tWORD threshold = 0; \n\t\t\t\tswitch(vars[i].Attribute[j].Id)\n\t\t\t\t{\n\t\t\t\tcase 0x05:\n\t\t\t\t\tthreshold = vars[i].Threshold05;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xC5:\n\t\t\t\t\tthreshold = vars[i].ThresholdC5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xC6:\n\t\t\t\t\tthreshold = vars[i].ThresholdC6;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(threshold > 0 && raw >= threshold && ! vars[i].IsSsd)\n\t\t\t\t{\n\t\t\t\t\tcaution = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(! vars[i].IsSsd)\n\t\t\t{\n\t\t\t\tflagUnknown = FALSE;\n\t\t\t}\n\t\t}\n\t\telse \n\t\tif(\n\t\t   (vars[i].Attribute[j].Id == 0xA9 && (vars[i].DiskVendorId == SSD_VENDOR_REALTEK || (vars[i].DiskVendorId == SSD_VENDOR_KINGSTON && vars[i].HostReadsWritesUnit == HOST_READS_WRITES_32MB /*KingstonKC600*/) || vars[i].DiskVendorId == SSD_VENDOR_SILICONMOTION))\n\t\t|| (vars[i].Attribute[j].Id == 0xAD && vars[i].DiskVendorId == SSD_VENDOR_KIOXIA)\n\t\t|| (vars[i].Attribute[j].Id == 0xB1 && vars[i].DiskVendorId == SSD_VENDOR_SAMSUNG)\n\t\t|| (vars[i].Attribute[j].Id == 0xBB && vars[i].DiskVendorId == SSD_VENDOR_MTRON)\n\t\t|| (vars[i].Attribute[j].Id == 0xCA && (vars[i].DiskVendorId == SSD_VENDOR_MICRON || vars[i].DiskVendorId == SSD_VENDOR_MICRON_MU03 || vars[i].DiskVendorId == SSD_VENDOR_INTEL_DC || vars[i].DiskVendorId == SSD_VENDOR_SILICONMOTION_CVC))\n\t\t|| (vars[i].Attribute[j].Id == 0xD1 && vars[i].DiskVendorId == SSD_VENDOR_INDILINX)\n\t\t|| (vars[i].Attribute[j].Id == 0xE7 && (vars[i].DiskVendorId == SSD_VENDOR_SANDFORCE || vars[i].DiskVendorId == SSD_VENDOR_CORSAIR || vars[i].DiskVendorId == SSD_VENDOR_KINGSTON || vars[i].DiskVendorId == SSD_VENDOR_SKHYNIX\n\t\t\t                                || vars[i].DiskVendorId == SSD_VENDOR_REALTEK || vars[i].DiskVendorId == SSD_VENDOR_SANDISK || vars[i].DiskVendorId == SSD_VENDOR_SSSTC || vars[i].DiskVendorId == SSD_VENDOR_APACER || vars[i].DiskVendorId == SSD_VENDOR_PHISON\n\t\t\t                                || vars[i].DiskVendorId == SSD_VENDOR_JMICRON || vars[i].DiskVendorId == SSD_VENDOR_MAXIOTEK || vars[i].DiskVendorId == SSD_VENDOR_YMTC || vars[i].DiskVendorId == SSD_VENDOR_SCY || vars[i].DiskVendorId == SSD_VENDOR_RECADATA || vars[i].DiskVendorId == SSD_VENDOR_ADATA_INDUSTRIAL))\n\t\t|| (vars[i].Attribute[j].Id == 0xE8 && vars[i].DiskVendorId == SSD_VENDOR_PLEXTOR)\n\t\t|| (vars[i].Attribute[j].Id == 0xE9 && (vars[i].DiskVendorId == SSD_VENDOR_INTEL || vars[i].DiskVendorId == SSD_VENDOR_OCZ || vars[i].DiskVendorId == SSD_VENDOR_OCZ_VECTOR || vars[i].DiskVendorId == SSD_VENDOR_SKHYNIX))\n\t\t|| (vars[i].Attribute[j].Id == 0xE9 && vars[i].DiskVendorId == SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS)\n\t\t)\n\t\t{\n\t\t\tflagUnknown = FALSE;\n\t\t\tint life = 0;\n\n\t\t\tif (vars[i].FlagLifeNoReport)\n\t\t\t{\n\t\t\t\tlife = -1;\n\t\t\t}\n\t\t\telse if (vars[i].FlagLifeRawValueIncrement)\n\t\t\t{\n\t\t\t\tlife = 100 - vars[i].Attribute[j].RawValue[0];\n\t\t\t}\n\t\t\telse if (vars[i].FlagLifeRawValue)\n\t\t\t{\n\t\t\t\tlife = vars[i].Attribute[j].RawValue[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlife = vars[i].Attribute[j].CurrentValue;\n\t\t\t}\n\n\t\t\t// if (life <= 0) { life = 0; }\n\t\t\tif (life > 100) { life = 100; }\n\t\t\n\t\t\tif (life == -1)\n\t\t\t{\n\n\t\t\t}\n\t\t\telse if(life == 0 || (! (vars[i].FlagLifeRawValue || vars[i].FlagLifeRawValueIncrement) && life < vars[i].Threshold[j].ThresholdValue))\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t\telse if(life <= vars[i].ThresholdFF)\n\t\t\t{\n\t\t\t\tcaution = 1;\n\t\t\t}\n\t\t}\n\t\telse if(vars[i].Attribute[j].Id == 0xE6 && (vars[i].DiskVendorId == SSD_VENDOR_WDC || vars[i].DiskVendorId == SSD_VENDOR_SANDISK))\n\t\t{\n\t\t\tint life = 0;\n\t\t\tflagUnknown = FALSE;\n\n\t\t\tif (vars[i].FlagLifeSanDisk0_1)\n\t\t\t{\n\t\t\t\tlife = 100 - (vars[i].Attribute[j].RawValue[1]*256 + vars[i].Attribute[j].RawValue[0])/100;\n\t\t\t}\n\t\t\telse if (vars[i].FlagLifeSanDisk1)\n\t\t\t{\n\t\t\t\tlife = 100 - vars[i].Attribute[j].RawValue[1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlife = 100 - vars[i].Attribute[j].RawValue[1];\n\t\t\t}\n\t\t\tif (life <= 0) { life = 0; }\n\t\t\tif (life > 100) { life = 100; }\n\n\t\t\tif (vars[i].FlagLifeSanDiskUsbMemory)\n\t\t\t{\n\n\t\t\t}\n\t\t\telse if (life == 0)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t\telse if(life <= vars[i].ThresholdFF)\n\t\t\t{\n\t\t\t\tcaution = 1;\n\t\t\t}\n\t\t}\n\t\telse if (\n\t\t\t(vars[i].Attribute[j].Id == 0xE6 && (vars[i].DiskVendorId == SSD_VENDOR_SANDISK_LENOVO || vars[i].DiskVendorId == SSD_VENDOR_SANDISK_DELL))\n\t\t||  (vars[i].Attribute[j].Id == 0xC9 && (vars[i].DiskVendorId == SSD_VENDOR_SANDISK_HP || vars[i].DiskVendorId == SSD_VENDOR_SANDISK_HP_VENUS))\n\t\t)\n\t\t{\n\t\t\tint life = 0;\n\t\t\tflagUnknown = FALSE;\n\n\t\t\tlife = vars[i].Attribute[j].CurrentValue;\n\t\t\tif (life <= 0) { life = 0; }\n\t\t\tif (life > 100) { life = 100; }\t\t\t\n\t\t\tvars[i].Life = life;\n\n\t\t\tif (life == 0)\n\t\t\t{\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t\telse if (life <= vars[i].ThresholdFF)\n\t\t\t{\n\t\t\t\tcaution = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/*\n\tif (vars[i].DiskVendorId == SSD_VENDOR_SAMSUNG)\n\t{\n\t\t// GetLifeByGpl(vars[i]);\n\t\tif (vars[i].Life == -1)\n\t\t{\n\n\t\t}\n\t\telse if (vars[i].Life == 0)\n\t\t{\n\t\t\terror = 1;\n\t\t}\n\t\telse if (vars[i].Life <= vars[i].ThresholdFF)\n\t\t{\n\t\t\tcaution = 1;\n\t\t}\n\t}\n\t*/\n\n\tif(error > 0)\n\t{\n\t\treturn DISK_STATUS_BAD;\n\t}\n\telse if(flagUnknown)\n\t{\n\t\treturn DISK_STATUS_UNKNOWN;\n\t}\n\telse if(caution > 0)\n\t{\n\t\treturn DISK_STATUS_CAUTION;\n\t}\n\telse\n\t{\n\t\treturn DISK_STATUS_GOOD;\n\t}\n}\n\nVOID CAtaSmart::ChangeByteOrder(PCHAR str, DWORD length)\n{\n\tCHAR\ttemp;\n\tfor(DWORD i = 0; i < length; i += 2)\n\t{\n\t\ttemp = str[i];\n\t\tstr[i] = str[i+1];\n\t\tstr[i+1] = temp;\n\t}\n}\n\nBOOL CAtaSmart::CheckAsciiStringError(PCHAR str, DWORD length)\n{\n\tBOOL flag = FALSE;\n\tfor(DWORD i = 0; i < length; i++)\n\t{\n\t\tif((0x00 < str[i] && str[i] < 0x20))\n\t\t{\n\t\t\tstr[i] = 0x20;\n\t\t\tbreak;\n\t\t}\n\t\telse if(str[i] >= 0x7f)\n\t\t{ \n\t\t\tflag = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flag;\n}\n\nDWORD CAtaSmart::GetPowerOnHours(DWORD rawValue, DWORD timeUnitType)\n{\n\tswitch(timeUnitType)\n\t{\n\tcase POWER_ON_UNKNOWN:\n\t\treturn 0;\n\t\tbreak;\n\tcase POWER_ON_HOURS:\n\t\treturn rawValue;\n\t\tbreak;\n\tcase POWER_ON_MINUTES:\n\t\treturn rawValue / 60;\n\t\tbreak;\n\tcase POWER_ON_HALF_MINUTES:\n\t\treturn rawValue / 120;\n\t\tbreak;\n\tcase POWER_ON_SECONDS:\n\t\treturn rawValue / 60 / 60;\n\t\tbreak;\n\tcase POWER_ON_10_MINUTES:\n\t\treturn rawValue / 6;\n\t\tbreak;\n\tcase POWER_ON_MILLI_SECONDS:\n\t\treturn rawValue;\n\t\tbreak;\n\tdefault:\n\t\treturn rawValue;\n\t\tbreak;\n\t}\n}\n\nDWORD CAtaSmart::GetPowerOnHoursEx(DWORD i, DWORD timeUnitType)\n{\n\tDWORD rawValue = vars[i].PowerOnRawValue;\n\tswitch(timeUnitType)\n\t{\n\tcase POWER_ON_UNKNOWN:\n\t\treturn 0;\n\t\tbreak;\n\tcase POWER_ON_HOURS:\n\t\treturn rawValue;\n\t\tbreak;\n\tcase POWER_ON_MINUTES:\n\t\treturn rawValue / 60;\n\t\tbreak;\n\tcase POWER_ON_HALF_MINUTES:\n\t\treturn rawValue / 120;\n\t\tbreak;\n\tcase POWER_ON_SECONDS:\n\t\treturn rawValue / 60 / 60;\n\t\tbreak;\n\tcase POWER_ON_10_MINUTES:\n\t\treturn rawValue / 6;\n\t\tbreak;\n\tcase POWER_ON_MILLI_SECONDS:\n\t\treturn rawValue;\n\t\tbreak;\n\tdefault:\n\t\treturn rawValue;\n\t\tbreak;\n\t}\n}\n\nDWORD CAtaSmart::GetTransferMode(WORD w63, WORD w76, WORD w77, WORD w88, CString &current, CString &max, CString &type, INTERFACE_TYPE* interfaceType)\n{\n\tDWORD tm = TRANSFER_MODE_UNKNOWN;\n\tcurrent = max = _T(\"\");\n\ttype = _T(\"\");\n\t*interfaceType = INTERFACE_TYPE_UNKNOWN;\n\n\t// Multiword DMA or PIO\n\tif(w63 & 0x0700)\n\t{\n\t\ttm = TRANSFER_MODE_PIO_DMA;\n\t\tcurrent = max = _T(\"PIO/DMA\");\n\t}\n\n\tif (w88 & 0x7F)\n\t{\n\t\ttype = _T(\"Parallel ATA\");\n\t\t*interfaceType = INTERFACE_TYPE_PATA;\n\t}\n\n\t// Ultara DMA Max Transfer Mode\n\t\t if(w88 & 0x0040){tm = TRANSFER_MODE_ULTRA_DMA_133; max = _T(\"UDMA/133\");}\n\telse if(w88 & 0x0020){tm = TRANSFER_MODE_ULTRA_DMA_100; max = _T(\"UDMA/100\");}\n\telse if(w88 & 0x0010){tm = TRANSFER_MODE_ULTRA_DMA_66;  max = _T(\"UDMA/66\");}\n\telse if(w88 & 0x0008){tm = TRANSFER_MODE_ULTRA_DMA_44;  max = _T(\"UDMA/44\");}\n\telse if(w88 & 0x0004){tm = TRANSFER_MODE_ULTRA_DMA_33;  max = _T(\"UDMA/33\");}\n\telse if(w88 & 0x0002){tm = TRANSFER_MODE_ULTRA_DMA_25;  max = _T(\"UDMA/25\");}\n\telse if(w88 & 0x0001){tm = TRANSFER_MODE_ULTRA_DMA_16;  max = _T(\"UDMA/16\");}\n\n\t// Ultara DMA Current Transfer Mode\n\t\t if(w88 & 0x4000){current = _T(\"UDMA/133\");}\n\telse if(w88 & 0x2000){current = _T(\"UDMA/100\");}\n\telse if(w88 & 0x1000){current = _T(\"UDMA/66\");}\n\telse if(w88 & 0x0800){current = _T(\"UDMA/44\");}\n\telse if(w88 & 0x0400){current = _T(\"UDMA/33\");}\n\telse if(w88 & 0x0200){current = _T(\"UDMA/25\");}\n\telse if(w88 & 0x0100){current = _T(\"UDMA/16\");}\n\n\t// Serial ATA\n\tif(w76 != 0x0000 && w76 != 0xFFFF)\n\t{\n\t\tcurrent = max = _T(\"SATA/150\");\n\t\ttype = _T(\"Serial ATA\");\n\t\t*interfaceType = INTERFACE_TYPE_SATA;\n\t}\n\n\t\t if(w76 & 0x0010){tm = TRANSFER_MODE_UNKNOWN; current = max = _T(\"----\");}\n\telse if(w76 & 0x0008){tm = TRANSFER_MODE_SATA_600; current = _T(\"----\"); max = _T(\"SATA/600\");}\n\telse if(w76 & 0x0004){tm = TRANSFER_MODE_SATA_300; current = _T(\"----\"); max = _T(\"SATA/300\");}\n\telse if(w76 & 0x0002){tm = TRANSFER_MODE_SATA_150; current = _T(\"----\"); max = _T(\"SATA/150\");}\n\n\t// 2013/5/1 ACS-3\n\t\t if(((w77 & 0x000E) >> 1) == 3){current = _T(\"SATA/600\");}\n\telse if(((w77 & 0x000E) >> 1) == 2){current = _T(\"SATA/300\");}\n\telse if(((w77 & 0x000E) >> 1) == 1){current = _T(\"SATA/150\");}\n\n\treturn tm;\n}\n\nVOID CAtaSmart::GetTransferModePCIe(CString &current, CString &max, SlotMaxCurrSpeed slotspeed)\n{\n\tmax = SlotSpeedToString(slotspeed.Maximum);\n\tcurrent = SlotSpeedToString(slotspeed.Current);\n}\n\nDWORD CAtaSmart::GetTimeUnitType(CString model, CString firmware, DWORD major, DWORD transferMode)\n{\n\tmodel.MakeUpper();\n\n\tif(model.Find(_T(\"FUJITSU\")) == 0)\n\t{\n\t\tif(major >= 8)\n\t\t{\n\t\t\treturn POWER_ON_HOURS;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn POWER_ON_SECONDS;\n\t\t}\n\t}\n\telse if(model.Find(_T(\"HITACHI_DK\")) == 0)\n\t{\n\t\treturn POWER_ON_MINUTES;\n\t}\n\telse if(model.Find(_T(\"MAXTOR\")) == 0)\n\t{\n\t\tif(transferMode >= TRANSFER_MODE_SATA_300\n\t\t|| model.Find(_T(\"MAXTOR 6H\")) == 0\t\t// Maxtor DiamondMax 11 family\n\t\t|| model.Find(_T(\"MAXTOR 7H500\")) == 0\t// Maxtor MaXLine Pro 500 family\n\t\t|| model.Find(_T(\"MAXTOR 6L0\")) == 0\t// Maxtor DiamondMax Plus D740X family\n\t\t|| model.Find(_T(\"MAXTOR 4K\")) == 0\t\t// Maxtor DiamondMax D540X-4K family\n\t\t)\n\t\t{\n\t\t\treturn POWER_ON_HOURS;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn POWER_ON_MINUTES;\n\t\t}\n\t}\n\telse if(model.Find(_T(\"SAMSUNG\")) == 0)\n\t{\n\t\tif(transferMode >= TRANSFER_MODE_SATA_300)\n\t\t{\n\t\t\treturn POWER_ON_HOURS;\n\t\t}\n\t\telse if(-23 >= _tstoi(firmware.Right(3)) && _tstoi(firmware.Right(3)) >= -39)\n\t\t{\n\t\t\treturn POWER_ON_HALF_MINUTES;\n\t\t}\n\t\telse if(model.Find(_T(\"SAMSUNG SV\")) == 0\n\t\t||\t\tmodel.Find(_T(\"SAMSUNG SP\")) == 0\n\t\t||\t\tmodel.Find(_T(\"SAMSUNG HM\")) == 0\n\t\t||\t\tmodel.Find(_T(\"SAMSUNG MP\")) == 0\n\t\t)\n\t\t{\n\t\t\treturn POWER_ON_HALF_MINUTES;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn POWER_ON_HOURS;\n\t\t}\n\t}\n\t// 2012/1/15\n\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=504;id=diskinfo#504\n\t// http://sourceforge.jp/ticket/browse.php?group_id=4394&tid=27443\n\telse if(\n\t   ((model.Find(_T(\"CFD_CSSD-S6TM128NMPQ\")) == 0 || model.Find(_T(\"CFD_CSSD-S6TM256NMPQ\")) == 0) && (firmware.Find(_T(\"VM21\")) == 0 || firmware.Find(_T(\"VN21\")) == 0))\n\t|| ((model.Find(_T(\"PX-128M2P\")) != -1 || model.Find(_T(\"PX-256M2P\")) != -1) && _tstof(firmware) < 1.059)\n\t|| (model.Find(_T(\"Corsair Performance Pro\")) == 0 && _tstof(firmware) < 1.059)\n\t)\n\t{\n\t\treturn POWER_ON_10_MINUTES;\n\t}\n\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1174;id=diskinfo#1174\n\telse if(\n\t\t   (model.Find(_T(\"INTEL SSDSC2CW\")) == 0 && model.Find(_T(\"A3\")) > 0) // Intel SSD 520 Series\n\t\t|| (model.Find(_T(\"INTEL SSDSC2BW\")) == 0 && model.Find(_T(\"A3\")) > 0) // Intel SSD 520 Series\n\t\t|| (model.Find(_T(\"INTEL SSDSC2CT\")) == 0 && model.Find(_T(\"A3\")) > 0) // Intel SSD 330 Series\n\t\t)\n\t{\n\t\treturn POWER_ON_MILLI_SECONDS;\n\t}\n\telse\n\t{\n\t\treturn POWER_ON_HOURS;\n\t}\n}\n\nDWORD CAtaSmart::GetAtaMajorVersion(WORD w80, CString &majorVersion)\n{\n\tDWORD major = 0;\n\n\tif(w80 == 0x0000 || w80 == 0xFFFF)\n\t{\n\t\treturn 0;\n\t}\n\n\tfor(int i = 14; i > 0; i--)\n\t{\n\t\tif((w80 >> i) & 0x1)\n\t\t{\n\t\t\tmajor = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (major >= 9)\n\t{\n\t\tmajorVersion.Format(_T(\"ACS-%d\"), major - 7);\n\t}\n\telse if(major == 8)\n\t{\n\t\tmajorVersion = _T(\"ATA8-ACS\");\n\t}\n\telse if(major >= 4)\n\t{\n\t\tmajorVersion.Format(_T(\"ATA/ATAPI-%d\"), major);\n\t}\n\telse if(major == 0)\n\t{\n\t\tmajorVersion = _T(\"----\");\n\t}\n\telse\n\t{\n\t\tmajorVersion.Format(_T(\"ATA-%d\"), major);\n\t}\n\n\treturn major;\n}\n\n// Last Update : 2011/03/21\n// Reference : http://www.t13.org/Documents/MinutesDefault.aspx?DocumentType=4&DocumentStage=2\n//           - d2161r0-ATAATAPI_Command_Set_-_3.pdf\n//           - d1153r18-ATA-ATAPI-4.pdf \nVOID CAtaSmart::GetAtaMinorVersion(WORD w81, CString &minor)\n{\n\tswitch(w81)\n\t{\n\tcase 0x0000:\n\tcase 0xFFFF:\n\t\t\t\t//\tminor = _T(\"Not Reported\");\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tminor = _T(\"----\");\t\t\t\t\t\t\t\t\t\t\tbreak;\n\tcase 0x0001:\tminor = _T(\"ATA (ATA-1) X3T9.2 781D prior to revision 4\");\tbreak;\n\tcase 0x0002:\tminor = _T(\"ATA-1 published, ANSI X3.221-1994\");\t\t\tbreak;\n\tcase 0x0003:\tminor = _T(\"ATA (ATA-1) X3T10 781D revision 4\");\t\t\tbreak;\n\tcase 0x0004:\tminor = _T(\"ATA-2 published, ANSI X3.279-1996\");\t\t\tbreak;\n\tcase 0x0005:\tminor = _T(\"ATA-2 X3T10 948D prior to revision 2k\");\t\tbreak;\n\tcase 0x0006:\tminor = _T(\"ATA-3 X3T10 2008D revision 1\");\t\t\t\t\tbreak;\n\tcase 0x0007:\tminor = _T(\"ATA-2 X3T10 948D revision 2k\");\t\t\t\t\tbreak;\n\tcase 0x0008:\tminor = _T(\"ATA-3 X3T10 2008D revision 0\");\t\t\t\t\tbreak;\n\tcase 0x0009:\tminor = _T(\"ATA-2 X3T10 948D revision 3\");\t\t\t\t\tbreak;\n\tcase 0x000A:\tminor = _T(\"ATA-3 published, ANSI X3.298-199x\");\t\t\tbreak;\n\tcase 0x000B:\tminor = _T(\"ATA-3 X3T10 2008D revision 6\");\t\t\t\t\tbreak;\n\tcase 0x000C:\tminor = _T(\"ATA-3 X3T13 2008D revision 7 and 7a\");\t\t\tbreak;\n\tcase 0x000D:\tminor = _T(\"ATA/ATAPI-4 X3T13 1153D version 6\");\t\t\tbreak;\n\tcase 0x000E:\tminor = _T(\"ATA/ATAPI-4 T13 1153D version 13\");\t\t\t\tbreak;\n\tcase 0x000F:\tminor = _T(\"ATA/ATAPI-4 X3T13 1153D version 7\");\t\t\tbreak;\n\tcase 0x0010:\tminor = _T(\"ATA/ATAPI-4 T13 1153D version 18\");\t\t\t\tbreak;\n\tcase 0x0011:\tminor = _T(\"ATA/ATAPI-4 T13 1153D version 15\");\t\t\t\tbreak;\n\tcase 0x0012:\tminor = _T(\"ATA/ATAPI-4 published, ANSI INCITS 317-1998\");\tbreak;\n\tcase 0x0013:\tminor = _T(\"ATA/ATAPI-5 T13 1321D version 3\");\t\t\t\tbreak;\n\tcase 0x0014:\tminor = _T(\"ATA/ATAPI-4 T13 1153D version 14\");\t\t\t\tbreak;\n\tcase 0x0015:\tminor = _T(\"ATA/ATAPI-5 T13 1321D version 1\");\t\t\t\tbreak;\n\tcase 0x0016:\tminor = _T(\"ATA/ATAPI-5 published, ANSI INCITS 340-2000\");\tbreak;\n\tcase 0x0017:\tminor = _T(\"ATA/ATAPI-4 T13 1153D version 17\");\t\t\t\tbreak;\n\tcase 0x0018:\tminor = _T(\"ATA/ATAPI-6 T13 1410D version 0\");\t\t\t\tbreak;\n\tcase 0x0019:\tminor = _T(\"ATA/ATAPI-6 T13 1410D version 3a\");\t\t\t\tbreak;\n\tcase 0x001A:\tminor = _T(\"ATA/ATAPI-7 T13 1532D version 1\");\t\t\t\tbreak;\n\tcase 0x001B:\tminor = _T(\"ATA/ATAPI-6 T13 1410D version 2\");\t\t\t\tbreak;\n\tcase 0x001C:\tminor = _T(\"ATA/ATAPI-6 T13 1410D version 1\");\t\t\t\tbreak;\n\tcase 0x001D:\tminor = _T(\"ATA/ATAPI-7 published ANSI INCITS 397-2005.\");\tbreak;\n\tcase 0x001E:\tminor = _T(\"ATA/ATAPI-7 T13 1532D version 0\");\t\t\t\tbreak;\n\tcase 0x001F:\tminor = _T(\"ACS-3 Revision 3b\");\t\t\t\t\t\t\tbreak;\n\tcase 0x0021:\tminor = _T(\"ATA/ATAPI-7 T13 1532D version 4a\");\t\t\t\tbreak;\n\tcase 0x0022:\tminor = _T(\"ATA/ATAPI-6 published, ANSI INCITS 361-2002\");\tbreak;\n\tcase 0x0027:\tminor = _T(\"ATA8-ACS version 3c\");\t\t\t\t\t\t\tbreak;\n\tcase 0x0028:\tminor = _T(\"ATA8-ACS version 6\");\t\t\t\t\t\t\tbreak;\n\tcase 0x0029:\tminor = _T(\"ATA8-ACS version 4\");\t\t\t\t\t\t\tbreak;\n\tcase 0x0031:\tminor = _T(\"ACS-2 Revision 2\");\t\t\t\t\t\t\t\tbreak;\n\tcase 0x0033:\tminor = _T(\"ATA8-ACS version 3e\");\t\t\t\t\t\t\tbreak;\n\tcase 0x0039:\tminor = _T(\"ATA8-ACS version 4c\");\t\t\t\t\t\t\tbreak;\n\tcase 0x0042:\tminor = _T(\"ATA8-ACS version 3f\");\t\t\t\t\t\t\tbreak;\n\tcase 0x0052:\tminor = _T(\"ATA8-ACS version 3b\");\t\t\t\t\t\t\tbreak;\n\tcase 0x005E:\tminor = _T(\"ACS-4 Revision 5\");\t\t\t\t\t\t\t\tbreak;\n\tcase 0x006D:\tminor = _T(\"ACS-3 Revision 5\");\t\t\t\t\t\t\t\tbreak;\n\tcase 0x0082:\tminor = _T(\"ACS-2 published, ANSI INCITS 482-2012\");\t\tbreak;\n\tcase 0x009C:\tminor = _T(\"ACS-4 published, ANSI INCITS 529-2018\");\t\tbreak;\n\tcase 0x0107:\tminor = _T(\"ATA8-ACS version 2d\");\t\t\t\t\t\t\tbreak;\n\tcase 0x010A:\tminor = _T(\"ACS-3 published, ANSI INCITS 522-2014\");\t\tbreak;\n\tcase 0x0110:\tminor = _T(\"ACS-2 Revision 3\");\t\t\t\t\t\t\t\tbreak;\n\tcase 0x011B:\tminor = _T(\"ACS-3 Revision 4\");\t\t\t\t\t\t\t\tbreak;\n\tdefault:\t//\tminor.Format(_T(\"Reserved [%04Xh]\"), w81);\t\t\t\t\tbreak;\n\t\t\t\t\tminor.Format(_T(\"---- [%04Xh]\"), w81);\t\t\t\t\t\tbreak;\n\t}\n}\n\nCString CAtaSmart::GetModelSerial(CString &model, CString &serialNumber)\n{\n\tCString modelSerial;\n\tmodelSerial = model + serialNumber;\n\tmodelSerial.Replace(_T(\"\\\\\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"/\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\":\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"*\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"?\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"\\\"\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"<\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\">\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"|\"), _T(\"\"));\n\n\treturn modelSerial;\n}\n\n/*\nBOOL CAtaSmart::GetLifeByGpl(ATA_SMART_INFO& asi)\n{\n\tBYTE d[512] = { 0 };\n\n\t// General Purpose Log\n\t// Reference ACS-5 draft\n\tif (asi.DiskVendorId == SSD_VENDOR_SAMSUNG && asi.IsSsd)\n\t{\n\t\tif (asi.CommandType == CMD_TYPE_PHYSICAL_DRIVE)\n\t\t{\n\t\t\tReadLogExtPd(asi.PhysicalDriveId, 0xA0, 0, 0, (PBYTE)&d, 512);\n\t\t\tif (d[8] > 0)\n\t\t\t{\n\t\t\t\tReadLogExtPd(asi.PhysicalDriveId, 0xA0, 4, 0, (PBYTE)&d, 512);\n\t\t\t\tfor (int i = 1; i <= d[8]; i++)\n\t\t\t\t{\n\t\t\t\t\tif (d[8 + i] == 7)\n\t\t\t\t\t{\n\t\t\t\t\t\tReadLogExtPd(asi.PhysicalDriveId, 0xA0, 4, 7, (PBYTE)&d, 512);\n\t\t\t\t\t\tif (0 <= d[8] && d[8] <= 100)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tasi.Life = 100 - d[8];\n\t\t\t\t\t\t\treturn TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (FlagUsbSat16 && (asi.CommandType == CMD_TYPE_SAT || asi.CommandType == CMD_TYPE_JMICRON))\n\t\t{\n\t\t\tReadLogExtSat(asi.PhysicalDriveId, 0xA0, 0, 0, (PBYTE)&d, 512, CMD_TYPE_SAT);\n\t\t\tif (d[8] > 0)\n\t\t\t{\n\t\t\t\tReadLogExtSat(asi.PhysicalDriveId, 0xA0, 4, 0, (PBYTE)&d, 512, CMD_TYPE_SAT);\n\t\t\t\tfor (int i = 1; i <= d[8]; i++)\n\t\t\t\t{\n\t\t\t\t\tif (d[8 + i] == 7)\n\t\t\t\t\t{\n\t\t\t\t\t\tReadLogExtSat(asi.PhysicalDriveId, 0xA0, 4, 7, (PBYTE)&d, 512, CMD_TYPE_SAT);\n\t\t\t\t\t\tif (0 <= d[8] && d[8] <= 100)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tasi.Life = 100 - d[8];\n\t\t\t\t\t\t\treturn TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n*/\n\n\n// +AMD_RC2 >>>>>>>>>>>>>>>>>>>>>>>\n\n//#define _M_ARM\n//#undef AMD_RC2\n\n#if ! defined(_M_ARM) && ! defined(_M_ARM64)\n\nenum AMD_RC2_ERROR_CODE {\n\tAMD_RC2_uninitial,\n\tAMD_RC2_loaded,\n\tAMD_RC2_unloaded,\n\tAMD_RC2_failed_signature,\n\tAMD_RC2_driver_not_found,\n\tAMD_RC2_cannot_open,\n\tAMD_RC2_failed_memory_alloc,\n\tAMD_RC2_offset_overflow,\n\tAMD_RC2_driver_version_old,\n\tAMD_RC2_not_admin,\n\tAMD_RC2_name_failed,\n\tAMD_RC2_MAX\n};\n\ntypedef struct {\n\tUINT uStructSize;\n\tUINT uStructVersion;\n\tUINT uDiskNum;\n\tint iPhysicalDrive;\n\tUINT64 uDriveSize64;\n\tDWORD uDriveSize;\n\tBYTE isSSD;\n\tBYTE isNVMe;\n\tBYTE reserved1;\n\tBYTE reserved2;\n\tchar sModel[41];\n\tchar sSerialNumber[21];\n\tchar sFirmwareRev[9];\n\tchar sSpeed[60];\n\tBYTE reserved3[93];\n} AMD_RC2_IDENTIFY;\n\n#ifdef AMD_RC2\nBOOL AMD_RC2_GetIdentify(AMD_RC2_IDENTIFY* st_id);\nBOOL AMD_RC2_GetSmartData(UINT diskNum, BYTE* SmartReadData, UINT SmartReadDataLen, BYTE* SmartReadThreshold, UINT SmartReadThresholdLen);\nUINT AMD_RC2_GetDrives();\n#else\n\nBOOL g_AMD_RC2_init = FALSE;\nBOOL g_AMD_RC2_load = FALSE;\nHMODULE g_AMD_RC2_hmodule = NULL;\n\ntypedef UINT(__stdcall* A_AMD_RC2_UINT)();\nA_AMD_RC2_UINT AMD_RC2_Init = NULL;\nA_AMD_RC2_UINT AMD_RC2_GetStatus = NULL;\nA_AMD_RC2_UINT AMD_RC2_GetDrives = NULL;\nA_AMD_RC2_UINT AMD_RC2_Reload = NULL;\n\ntypedef BOOL(__stdcall* A_AMD_RC2_GetIdentify)(AMD_RC2_IDENTIFY* st_id);\nA_AMD_RC2_GetIdentify AMD_RC2_GetIdentify = NULL;\n\ntypedef BOOL(__stdcall* A_AMD_RC2_GetSmartData)(UINT diskNum, BYTE* SmartReadData, UINT SmartReadDataLen, BYTE* SmartReadThreshold, UINT SmartReadThresholdLen);\nA_AMD_RC2_GetSmartData AMD_RC2_GetSmartData = NULL;\n\n\n\n#include <Softpub.h>\n#pragma comment(lib, \"Wintrust.lib\")\n#pragma comment(lib, \"Crypt32.lib\")\n\nBOOL AMD_RC2_DLL_Load() {\n\n\tDebugPrint(L\"AMD_RC2_DLL_Load\");\n\n\tTCHAR fullPath[MAX_PATH] = {};\n\tTCHAR drive[MAX_PATH] = {};\n\tTCHAR path[MAX_PATH] = {};\n\tTCHAR dllPath[MAX_PATH] = {};\n\n\tGetModuleFileNameW(NULL, fullPath, MAX_PATH);\n\t_wsplitpath_s(fullPath, drive, MAX_PATH, path, MAX_PATH, NULL, 0, NULL, 0);\n\twcscat_s(dllPath, MAX_PATH, drive);\n\twcscat_s(dllPath, MAX_PATH, path);\n\twcscat_s(dllPath, MAX_PATH, DLL_DIR);\n\n#ifdef _M_AMD64\n\twcscat_s(dllPath, MAX_PATH, L\"AMD_RC2t7x64.dll\");\n#else\n\twcscat_s(dllPath, MAX_PATH, L\"AMD_RC2t7x86.dll\");\n#endif\n\n\t// check sign\n\n\tWINTRUST_FILE_INFO FileData = { sizeof(WINTRUST_FILE_INFO) };\n\tFileData.pcwszFilePath = dllPath;\n\n\tGUID WVTPolicyGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;\n\tWINTRUST_DATA WinTrustData = { sizeof(WinTrustData) };\n\tWinTrustData.dwUIChoice = WTD_UI_NONE;\n\tWinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;\n\tWinTrustData.dwUnionChoice = WTD_CHOICE_FILE;\n\tWinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;\n\tWinTrustData.pFile = &FileData;\n\n\tconst LONG ret = WinVerifyTrust(NULL, &WVTPolicyGUID, &WinTrustData);\n\n\tbool cert_chk = false;\n\n\tif (ret == ERROR_SUCCESS) {\n\t\t// retreive the signer certificate and display its information\n\t\tCRYPT_PROVIDER_DATA const* psProvData = NULL;\n\t\tCRYPT_PROVIDER_SGNR* psProvSigner = NULL;\n\t\tCRYPT_PROVIDER_CERT* psProvCert = NULL;\n\n\t\tpsProvData = WTHelperProvDataFromStateData(WinTrustData.hWVTStateData);\n\t\tif (psProvData) {\n\t\t\tpsProvSigner = WTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA)psProvData, 0, FALSE, 0);\n\t\t\tif (psProvSigner) {\n\t\t\t\tpsProvCert = WTHelperGetProvCertFromChain(psProvSigner, 0);\n\t\t\t\tif (psProvCert) {\n\t\t\t\t\twchar_t szCertName[200] = {};\n\t\t\t\t\tDWORD dwStrType = CERT_X500_NAME_STR;\n\t\t\t\t\tCertGetNameStringW(psProvCert->pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, &dwStrType, szCertName, 200);\n\t\t\t\t\tcert_chk = !(szCertName[0] == '\\0' || wcscmp(szCertName, L\"Gakuto Matsumura\") != 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tWinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;\n\t(void)WinVerifyTrust(NULL, &WVTPolicyGUID, &WinTrustData);\n\tif (!cert_chk)  return FALSE;\n\n\t// DLL load\n\n\tg_AMD_RC2_hmodule = LoadLibraryW(dllPath);\n\tif (!g_AMD_RC2_hmodule)  return FALSE;\n\n\t// get functions\n\n\tAMD_RC2_Init = (A_AMD_RC2_UINT)GetProcAddress(g_AMD_RC2_hmodule, \"AMD_RC2_Init\");\n\tAMD_RC2_GetStatus = (A_AMD_RC2_UINT)GetProcAddress(g_AMD_RC2_hmodule, \"AMD_RC2_GetStatus\");\n\tAMD_RC2_GetDrives = (A_AMD_RC2_UINT)GetProcAddress(g_AMD_RC2_hmodule, \"AMD_RC2_GetDrives\");\n\tAMD_RC2_Reload = (A_AMD_RC2_UINT)GetProcAddress(g_AMD_RC2_hmodule, \"AMD_RC2_Reload\");\n\tAMD_RC2_GetIdentify = (A_AMD_RC2_GetIdentify)GetProcAddress(g_AMD_RC2_hmodule, \"AMD_RC2_GetIdentify\");\n\tAMD_RC2_GetSmartData = (A_AMD_RC2_GetSmartData)GetProcAddress(g_AMD_RC2_hmodule, \"AMD_RC2_GetSmartData\");\n\tif (!AMD_RC2_Init || !AMD_RC2_GetStatus || !AMD_RC2_GetDrives || !AMD_RC2_Reload || !AMD_RC2_GetIdentify || !AMD_RC2_GetSmartData) {\n\t\treturn FALSE;\n\t}\n\n\t// init\n\n\tUINT status = AMD_RC2_Init();\n\n\t// check status\n\n\tg_AMD_RC2_load = (status == AMD_RC2_ERROR_CODE::AMD_RC2_loaded);\n\tif (!g_AMD_RC2_load) {\n\t\tif (status > AMD_RC2_ERROR_CODE::AMD_RC2_MAX)  status = AMD_RC2_ERROR_CODE::AMD_RC2_MAX;\n\n\t\tconstexpr const TCHAR* error_msg[] = {\n\t\t\t_T(\"AMD_RC2_uninitial\"),\n\t\t\t_T(\"AMD_RC2_loaded\"),\n\t\t\t_T(\"AMD_RC2_unloaded\"),\n\t\t\t_T(\"AMD_RC2_failed_signature\"),\n\t\t\t_T(\"AMD_RC2_driver_not_found\"),\n\t\t\t_T(\"AMD_RC2_cannot_open\"),\n\t\t\t_T(\"AMD_RC2_failed_memory_alloc\"),\n\t\t\t_T(\"AMD_RC2_offset_overflow\"),\n\t\t\t_T(\"AMD_RC2_driver_version_old\"),\n\t\t\t_T(\"AMD_RC2_not_admin\"),\n\t\t\t_T(\"AMD_RC2_name_failed\"),\n\t\t\t_T(\"AMD_RC2_unknown\")\n\t\t};\n\t\tDebugPrint(error_msg[status]);\n\t}\n\tg_AMD_RC2_init = TRUE;\n\treturn g_AMD_RC2_load;\n}\n#endif\n\n\nBOOL CAtaSmart::AddDiskAMD_RC2()\n{\n\tint count = 0;\n#ifndef AMD_RC2\n\tif (!g_AMD_RC2_init)  AMD_RC2_DLL_Load();\n\telse if (g_AMD_RC2_load) {\n\t\tAMD_RC2_Reload();\n\t}\n\tif (!g_AMD_RC2_load) return FALSE;\n#endif\n\tIDENTIFY_DEVICE identify = {};\n\tINT phy = 0;\n\tDWORD TotalDiskSize = 0;\n\tconst int Drives = AMD_RC2_GetDrives();\n\tDebugPrint(_T(\"DoIdentifyDeviceAMD_RC2:begin\"));\n\tfor (int i = 0; i < Drives; ++i) {\n\t\tBOOL isSSD = FALSE;\n\t\tBOOL isNVMe = FALSE;\n\t\tif (DoIdentifyDeviceAMD_RC2(i, &phy, &TotalDiskSize, &identify, &isSSD, &isNVMe)) {\n\t\t\tif (isNVMe) {//NVMe\n\n\t\t\t\tCString cs;\n\t\t\t\tcs.Format(_T(\"DoIdentifyDeviceAMD_RC2:%d > NVMe / diskSize:%u / PhysicalID:%d / Model:%hs\"), i, TotalDiskSize, phy, identify.A.Model);\n\t\t\t\tDebugPrint(cs);\n\n\t\t\t\tIDENTIFY_DEVICE identify2 = {};\n\t\t\t\t//identify2.N.MajorVersion = identify.A.MinorVersion & 0xF;\n\t\t\t\t//identify2.N.MinorVersion = (identify.A.MinorVersion & 0xF0) >> 4;\n\t\t\t\tmemcpy_s(identify2.N.Model, 40, identify.A.Model, 40);\n\t\t\t\tmemcpy_s(identify2.N.SerialNumber, 20, identify.A.SerialNumber, 20);\n\t\t\t\tmemcpy_s(identify2.N.FirmwareRev, 8, identify.A.FirmwareRev, 8);\n\t\t\t\tstrcpy_s(identify2.N.Reserved3, 60, identify.A.CurrentMediaSerialNo);\n\t\t\t\tif (AddDiskNVMe(phy, 0, 0, i, 0, COMMAND_TYPE::CMD_TYPE_AMD_RC2, &identify2, &TotalDiskSize))\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\t//AddDisk(phy, 0, 0, -1, 0, COMMAND_TYPE::CMD_TYPE_AMD_RC2, &identify, -1, NULL, L\"\", TotalDiskSize);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCString cs;\n\t\t\t\tcs.Format(_T(\"DoIdentifyDeviceAMD_RC2:%d > ATA / diskSize:%u / PhysicalID:%d / Model:%hs\"), i, TotalDiskSize, phy, identify.A.Model);\n\t\t\t\tDebugPrint(cs);\n\n\t\t\t\tif (isSSD) identify.A.SerialAtaCapabilities = 1;\n\t\t\t\tChangeByteOrder(identify.A.SerialNumber, sizeof(identify.A.SerialNumber));\n\t\t\t\tChangeByteOrder(identify.A.FirmwareRev, sizeof(identify.A.FirmwareRev));\n\t\t\t\tChangeByteOrder(identify.A.Model, sizeof(identify.A.Model));\n\t\t\t\tif (AddDisk(phy, 0, 0, i, 0, COMMAND_TYPE::CMD_TYPE_AMD_RC2, &identify, -1, NULL, L\"\", TotalDiskSize))\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCString cs;\n\t\t\tcs.Format(_T(\"DoIdentifyDeviceAMD_RC2:%d > AddDisk:end\"), i);\n\t\t\tDebugPrint(cs);\n\t\t}\n\t}\n\n\tCString cs;\n\tcs.Format(_T(\"DoIdentifyDeviceAMD_RC2:count=%d, Drives=%d\"), count, Drives);\n\tDebugPrint(cs);\n\n\tif (count > 0)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n}\n\nBOOL CAtaSmart::DoIdentifyDeviceAMD_RC2(INT diskNum, INT* phy, DWORD* TotalDiskSize, IDENTIFY_DEVICE* data, BOOL* isSSD, BOOL* isNVMe) {\n#if ! defined(_M_ARM) && ! defined(_M_ARM64)\n#ifndef AMD_RC2\n\tif (!g_AMD_RC2_init)  AMD_RC2_DLL_Load();\n\tif (!AMD_RC2_GetIdentify) return FALSE;\n#endif\n\tAMD_RC2_IDENTIFY st_id = { sizeof(AMD_RC2_IDENTIFY), 1 };\n\tst_id.uDiskNum = diskNum;\n\tconst BOOL ret = AMD_RC2_GetIdentify(&st_id);\n\tif (ret) {\n\t\tif (phy)  *phy = st_id.iPhysicalDrive;\n\t\tif (TotalDiskSize)  *TotalDiskSize = st_id.uDriveSize;\n\t\tif (isSSD)  *isSSD = st_id.isSSD;\n\t\tif (isNVMe)  *isNVMe = st_id.isNVMe;\n\t\tif (data) {\n\t\t\tmemcpy_s(data->A.Model, 40, st_id.sModel, 40);\n\t\t\tmemcpy_s(data->A.SerialNumber, 20, st_id.sSerialNumber, 20);\n\t\t\tmemcpy_s(data->A.FirmwareRev, 8, st_id.sFirmwareRev, 8);\n\t\t\tstrcpy_s(data->A.CurrentMediaSerialNo, 60, st_id.sSpeed);\n\t\t}\n\t}\n\treturn ret;\n#else\n\treturn FALSE;\n#endif\n}\n\nBOOL CAtaSmart::GetSmartDataAMD_RC2(INT diskNum, ATA_SMART_INFO* asi)\n{\n#if ! defined(_M_ARM) && ! defined(_M_ARM64)\n#ifndef AMD_RC2\n\tif (!g_AMD_RC2_init)  AMD_RC2_DLL_Load();\n\tif (!AMD_RC2_GetSmartData) return FALSE;\n#endif\n\tif (!AMD_RC2_GetSmartData(diskNum, asi->SmartReadData, READ_ATTRIBUTE_BUFFER_SIZE, asi->SmartReadThreshold, READ_THRESHOLD_BUFFER_SIZE))\n\t{\n\t\treturn FALSE;\n\t}\n\tif (asi->IsNVMe) return TRUE;\n\treturn FillSmartData(asi);\n#else\n\treturn FALSE;\n#endif\n}\n\nBOOL CAtaSmart::GetSmartThresholdAMD_RC2(INT diskNum, ATA_SMART_INFO* asi)\n{\n#if ! defined(_M_ARM) && ! defined(_M_ARM64)\n\tif (!AMD_RC2_GetSmartData(diskNum, asi->SmartReadThreshold, READ_THRESHOLD_BUFFER_SIZE, asi->SmartReadThreshold, READ_THRESHOLD_BUFFER_SIZE))\n\t{\n\t\treturn FALSE;\n\t}\n\treturn FillSmartThreshold(asi);\n#else\n\treturn FALSE;\n#endif\n}\n\n#endif\n\n// +AMD_RC2 <<<<<<<<<<<<<<<<<<<<<<<\n\n\n"
        },
        {
          "name": "AtaSmart.h",
          "type": "blob",
          "size": 64.3876953125,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n// Reference : http://www.usefullcode.net/2007/02/hddsmart.html (ja)\n\n#pragma once\n\n#include \"winioctl.h\"\n#include \"SPTIUtil.h\"\n#include \"SlotSpeedGetter.h\"\n#include \"NVMeInterpreter.h\"\n#include \"StorageQuery.h\"\n\n#define DLL_DIR\t\t\t\t\t    _T(\"CdiResource\\\\dll\\\\\")\n\n#ifdef JMICRON_USB_RAID_SUPPORT\n#include \"JMicronUsbRaidDef.h\"\n#endif\n\nstatic const TCHAR* commandTypeString[] =\n{\n\t_T(\"un\"),\n\t_T(\"pd\"),\n\t_T(\"sm\"),\n\t_T(\"si\"),\n\t_T(\"sa\"),\n\t_T(\"sp\"),\n\t_T(\"io\"),\n\t_T(\"lo\"),\n\t_T(\"pr\"),\n\t_T(\"jm\"),\n\t_T(\"cy\"),\n\t_T(\"ar\"), // ASM1352R\n\t_T(\"rr\"), // Realtek 9220DP\n\t_T(\"cs\"),\n\t_T(\"cp\"),\n\t_T(\"wm\"),\n\t_T(\"ns\"), // NVMe Samsung\n\t_T(\"ni\"), // NVMe Intel\n\t_T(\"sq\"), // NVMe Storage Query\n\t_T(\"nj\"), // NVMe JMicron\n\t_T(\"na\"), // NVMe ASMedia\n\t_T(\"nr\"), // NVMe Realtek\n\t_T(\"nt\"), // NVMe Intel RST\n\t_T(\"iv\"), // NVMe Intel VROC\n\t_T(\"mr\"), // MegaRAID SAS\n\t_T(\"rc\"), // +AMD RC2\n\t_T(\"j5\"), // JMS56X\n\t_T(\"j3\"), // JMB39X\n\t_T(\"j6\"), // JMS586_20\n\t_T(\"j4\"), // JMS586_40\n\t_T(\"dg\"), // Debug\n};\n\nstatic const TCHAR* ssdVendorString[] =\n{\n\t_T(\"\"),\n\t_T(\"\"),\n\t_T(\"mt\"), // MTron\n\t_T(\"ix\"), // Indilinx\n\t_T(\"jm\"), // JMicron\n\t_T(\"il\"), // Intel\n\t_T(\"sg\"), // SAMSUNG\n\t_T(\"sf\"), // SandForce\n\t_T(\"mi\"), // Micron\n\t_T(\"oz\"), // OCZ\n\t_T(\"st\"), // SEAGATE\n\t_T(\"wd\"), // WDC\n\t_T(\"px\"), // PLEXTOR\n\t_T(\"sd\"), // SanDisk\n\t_T(\"oz\"), // OCZ Vector\n\t_T(\"to\"), // TOSHIABA\n\t_T(\"co\"), // Corsair\n\t_T(\"ki\"), // Kingston\n\t_T(\"m3\"), // Micron MU03\n\t_T(\"nv\"), // NVMe\n\t_T(\"re\"), // Realtek\n\t_T(\"sk\"), // SKhynix\n\t_T(\"ki\"), // KIOXIA\n\t_T(\"ss\"), // SSSTC\n\t_T(\"id\"), // Intel DC\n\t_T(\"ap\"), // Apacer\n\t_T(\"sm\"), // SiliconMotion\n\t_T(\"ph\"), // Phison\n\t_T(\"ma\"), // Marvell\n\t_T(\"mk\"), // Maxiotek\n\t_T(\"ym\"), // YMTC\n\t_T(\"sc\"), // SCY\n\t_T(\"\"),\t  // _T(\"SmartJMicron60x\"),\n\t_T(\"\"),\t  // _T(\"SmartJMicron61x\"),\n\t_T(\"\"),\t  // _T(\"SmartJMicron66x\"),\n\t_T(\"\"),\t  // _T(\"SmartSeagateIronWolf\"),\n\t_T(\"\"),\t  // _T(\"SmartSeagateBarraCuda\"),\n\t_T(\"\"),\t  // _T(\"SmartSanDiskGb\"),\n\t_T(\"\"),\t  // _T(\"SmartKingstonSuv\"),\n\t_T(\"\"),\t  // _T(\"SmartKingstonKC600\"),\n\t_T(\"\"),\t  // _T(\"SmartKingstonDC500\"),\n\t_T(\"\"),\t  // _T(\"SmartKingstonSA400\"),\n\t_T(\"re\"), // RECADATA\n\t_T(\"\"),\t  // _T(\"SmartSanDiskDell\"),\n\t_T(\"\"),\t  // _T(\"SmartSanDiskHp\"),\n\t_T(\"\"),\t  // _T(\"SmartSanDiskHpVenus\"),\n\t_T(\"\"),\t  // _T(\"SmartSanDiskLenovo\"),\n\t_T(\"\"),\t  // _T(\"SmartSanDiskLenovoHelenVenus\"),\n\t_T(\"\"),\t  // _T(\"SmartSanDiskCloud\"),\n\t_T(\"mc\"), // _T(\"SmartSiliconMotionCVC\"),\n\t_T(\"ai\"), // _T(\"SmartAdataIndustrial\"),\n\n};\n\nstatic const TCHAR* attributeString[] =\n{\n\t_T(\"Smart\"),\n\t_T(\"SmartSsd\"),\n\t_T(\"SmartMtron\"),\n\t_T(\"SmartIndilinx\"),\n\t_T(\"SmartJMicron\"),\n\t_T(\"SmartIntel\"),\n\t_T(\"SmartSamsung\"),\n\t_T(\"SmartSandForce\"),\n\t_T(\"SmartMicron\"),\n\t_T(\"SmartOcz\"),\n\t_T(\"SmartSeagate\"),\n\t_T(\"SmartWdc\"),\n\t_T(\"SmartPlextor\"),\n\t_T(\"SmartSanDisk\"),\n\t_T(\"SmartOczVector\"),\n\t_T(\"SmartToshiba\"),\n\t_T(\"SmartCorsair\"),\n\t_T(\"SmartKingston\"),\n\t_T(\"SmartMicronMU03\"),\n\t_T(\"SmartNVMe\"),\n\t_T(\"SmartRealtek\"),\n\t_T(\"SmartSKhynix\"),\n\t_T(\"SmartKioxia\"),\n\t_T(\"SmartSsstc\"),\n\t_T(\"SmartIntelDc\"),\n\t_T(\"SmartApacer\"),\n\t_T(\"SmartSiliconMotion\"),\n\t_T(\"SmartPhison\"),\n\t_T(\"SmartMarvell\"),\n\t_T(\"SmartMaxiotek\"),\n\t_T(\"SmartYmtc\"),\n\t_T(\"SmartScy\"),\n\t_T(\"SmartJMicron60x\"),\n\t_T(\"SmartJMicron61x\"),\n\t_T(\"SmartJMicron66x\"),\n\t_T(\"SmartSeagateIronWolf\"),\n\t_T(\"SmartSeagateBarraCuda\"),\n\t_T(\"SmartSanDiskGb\"),\n\t_T(\"SmartKingstonSuv\"),\n\t_T(\"SmartKingstonKC600\"),\n\t_T(\"SmartKingstonDC500\"),\n\t_T(\"SmartKingstonSA400\"),\n\t_T(\"SmartRecadata\"),\n\t_T(\"SmartSanDiskDell\"),\n\t_T(\"SmartSanDiskHp\"),\n\t_T(\"SmartSanDiskHpVenus\"),\n\t_T(\"SmartSanDiskLenovo\"),\n\t_T(\"SmartSanDiskLenovoHelenVenus\"),\n\t_T(\"SmartSanDiskCloud\"),\n\t_T(\"SmartSiliconMotionCVC\"),\n\t_T(\"SmartAdataIndustrial\"),\n};\n\nstatic const TCHAR* deviceFormFactorString[] =\n{\n\t_T(\"\"),\n\t_T(\"5.25 inch\"),\n\t_T(\"3.5 inch\"),\n\t_T(\"2.5 inch\"),\n\t_T(\"1.8 inch\"),\n\t_T(\"< 1.8 inch\")\n};\n\ntypedef struct _VOLUME_DISK_EXTENTS_LX {\n    DWORD       NumberOfDiskExtents;\n    DISK_EXTENT Extents[4];\n} VOLUME_DISK_EXTENTS_LX, *PVOLUME_DISK_EXTENTS_LX;\n\nclass CAtaSmart\n{\n\npublic:\n\tstatic const int MAX_DISK = 80;// FIX\n\tstatic const int MAX_ATTRIBUTE = 30; // FIX\n\tstatic const int MAX_SEARCH_PHYSICAL_DRIVE = 56;\n\tstatic const int MAX_SEARCH_SCSI_PORT = 16;\n\tstatic const int MAX_SEARCH_SCSI_TARGET_ID = 8;\n\n\tstatic const int SCSI_MINIPORT_BUFFER_SIZE = 512;\n\npublic:\n\tCAtaSmart();\n\tvirtual ~CAtaSmart();\n\n\n\tenum VENDOR_ID\n\t{\n\t\tHDD_GENERAL = 0,\n\t\tSSD_GENERAL = 1,\n\t\tSSD_VENDOR_MTRON = 2,\n\t\tSSD_VENDOR_INDILINX = 3,\n\t\tSSD_VENDOR_JMICRON = 4,\n\t\tSSD_VENDOR_INTEL = 5,\n\t\tSSD_VENDOR_SAMSUNG = 6,\n\t\tSSD_VENDOR_SANDFORCE = 7,\n\t\tSSD_VENDOR_MICRON = 8,\n\t\tSSD_VENDOR_OCZ = 9,\n\t\tSSD_VENDOR_SEAGATE = 10,\n\t\tSSD_VENDOR_WDC = 11,\n\t\tSSD_VENDOR_PLEXTOR = 12,\n\t\tSSD_VENDOR_SANDISK = 13,\n\t\tSSD_VENDOR_OCZ_VECTOR = 14,\n\t\tSSD_VENDOR_TOSHIBA = 15,\n\t\tSSD_VENDOR_CORSAIR = 16,\n\t\tSSD_VENDOR_KINGSTON = 17,\n\t\tSSD_VENDOR_MICRON_MU03 = 18,\n\t\tSSD_VENDOR_NVME = 19,\n\t\tSSD_VENDOR_REALTEK = 20,\n\t\tSSD_VENDOR_SKHYNIX = 21,\n\t\tSSD_VENDOR_KIOXIA = 22,\n\t\tSSD_VENDOR_SSSTC = 23,\n\t\tSSD_VENDOR_INTEL_DC = 24,\n\t\tSSD_VENDOR_APACER = 25,\n\t\tSSD_VENDOR_SILICONMOTION = 26,\n\t\tSSD_VENDOR_PHISON = 27,\n\t\tSSD_VENDOR_MARVELL = 28,\n\t\tSSD_VENDOR_MAXIOTEK = 29,\n\t\tSSD_VENDOR_YMTC = 30,\n\t\tSSD_VENDOR_SCY = 31,\n\n\t\tSSD_VENDOR_JMICRON_60X = 32,\n\t\tSSD_VENDOR_JMICRON_61X = 33,\n\t\tSSD_VENDOR_JMICRON_66X = 34,\n\t\tSSD_VENDOR_SEAGATE_IRON_WOLF = 35,\n\t\tSSD_VENDOR_SEAGATE_BARRA_CUDA = 36,\n\t\tSSD_VENDOR_SANDISK_GB = 37,\n\t\tSSD_VENDOR_KINGSTON_SUV = 38,\n\t\tSSD_VENDOR_KINGSTON_KC600 = 39,\n\t\tSSD_VENDOR_KINGSTON_DC500 = 40,\n\t\tSSD_VENDOR_KINGSTON_SA400 = 41,\n\n\t\tSSD_VENDOR_RECADATA = 42,\n\n\t\tSSD_VENDOR_SANDISK_DELL = 43,\n\t\tSSD_VENDOR_SANDISK_HP = 44,\n\t\tSSD_VENDOR_SANDISK_HP_VENUS = 45,\n\t\tSSD_VENDOR_SANDISK_LENOVO = 46,\n\t\tSSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS = 47,\n\t\tSSD_VENDOR_SANDISK_CLOUD = 48,\n\n\t\tSSD_VENDOR_SILICONMOTION_CVC = 49,\n\t\tSSD_VENDOR_ADATA_INDUSTRIAL = 50,\n\n\t\tSSD_VENDOR_MAX = 99,\n\n\t\tVENDOR_UNKNOWN = 0x0000,\n\t\tUSB_VENDOR_BUFFALO = 0x0411,\n\t\tUSB_VENDOR_IO_DATA = 0x04BB,\n\t\tUSB_VENDOR_LOGITEC = 0x0789,\n\t\tUSB_VENDOR_INITIO = 0x13FD,\n\t\tUSB_VENDOR_SUNPLUS = 0x04FC,\n\t\tUSB_VENDOR_JMICRON = 0x152D,\n\t\tUSB_VENDOR_CYPRESS = 0x04B4,\n\t\tUSB_VENDOR_OXFORD = 0x0928,\n\t\tUSB_VENDOR_PROLIFIC = 0x067B,\n\t\tUSB_VENDOR_REALTEK = 0x0BDA,\n\t\tUSB_VENDOR_ALL = 0xFFFF,\n\t};\n\n\tenum SMART_STATUS\n\t{\n\t\tSMART_STATUS_NO_CHANGE = 0,\n\t\tSMART_STATUS_MINOR_CHANGE,\n\t\tSMART_STATUS_MAJOR_CHANGE\n\t};\n\n\tenum TRANSFER_MODE\n\t{\n\t\tTRANSFER_MODE_UNKNOWN = 0,\n\t\tTRANSFER_MODE_PIO,\n\t\tTRANSFER_MODE_PIO_DMA,\n\t\tTRANSFER_MODE_ULTRA_DMA_16,\n\t\tTRANSFER_MODE_ULTRA_DMA_25,\n\t\tTRANSFER_MODE_ULTRA_DMA_33,\n\t\tTRANSFER_MODE_ULTRA_DMA_44,\n\t\tTRANSFER_MODE_ULTRA_DMA_66,\n\t\tTRANSFER_MODE_ULTRA_DMA_100,\n\t\tTRANSFER_MODE_ULTRA_DMA_133,\n\t\tTRANSFER_MODE_SATA_150,\n\t\tTRANSFER_MODE_SATA_300,\n\t\tTRANSFER_MODE_SATA_600\n\t};\n\n\tenum DISK_STATUS\n\t{\n\t\tDISK_STATUS_UNKNOWN = 0,\n\t\tDISK_STATUS_GOOD,\n\t\tDISK_STATUS_CAUTION,\n\t\tDISK_STATUS_BAD\n\t};\n\n\tenum POWER_ON_HOURS_UNIT\n\t{\n\t\tPOWER_ON_UNKNOWN = 0,\n\t\tPOWER_ON_HOURS,\n\t\tPOWER_ON_MINUTES,\n\t\tPOWER_ON_HALF_MINUTES,\n\t\tPOWER_ON_SECONDS,\n\t\tPOWER_ON_10_MINUTES,\n\t\tPOWER_ON_MILLI_SECONDS,\n\t};\n\n\tenum HOST_READS_WRITES_UNIT\n\t{\n\t\tHOST_READS_WRITES_UNKNOWN = 0,\n\t\tHOST_READS_WRITES_512B,\n\t\tHOST_READS_WRITES_1MB,\n\t\tHOST_READS_WRITES_16MB,\n\t\tHOST_READS_WRITES_32MB,\n\t\tHOST_READS_WRITES_GB,\n\t};\n\n\tenum COMMAND_TYPE\n\t{\n\t\tCMD_TYPE_UNKNOWN = 0,\n\t\tCMD_TYPE_PHYSICAL_DRIVE,\n\t\tCMD_TYPE_SCSI_MINIPORT,\n\t\tCMD_TYPE_SILICON_IMAGE,\n\t\tCMD_TYPE_SAT,\t\t\t// SAT = SCSI_ATA_TRANSLATION\n\t\tCMD_TYPE_SUNPLUS,\n\t\tCMD_TYPE_IO_DATA,\n\t\tCMD_TYPE_LOGITEC,\n\t\tCMD_TYPE_PROLIFIC,\n\t\tCMD_TYPE_JMICRON,\n\t\tCMD_TYPE_CYPRESS,\n\t\tCMD_TYPE_SAT_ASM1352R,\t// AMS1352 2nd drive\n\t\tCMD_TYPE_SAT_REALTEK9220DP,\n\t\tCMD_TYPE_CSMI,\t\t\t\t// CSMI = Common Storage Management Interface\n\t\tCMD_TYPE_CSMI_PHYSICAL_DRIVE, // CSMI = Common Storage Management Interface \n\t\tCMD_TYPE_WMI,\n\t\tCMD_TYPE_NVME_SAMSUNG,\n\t\tCMD_TYPE_NVME_INTEL,\n\t\tCMD_TYPE_NVME_STORAGE_QUERY,\n\t\tCMD_TYPE_NVME_JMICRON,\n\t\tCMD_TYPE_NVME_ASMEDIA,\n\t\tCMD_TYPE_NVME_REALTEK,\n\t\tCMD_TYPE_NVME_REALTEK9220DP,\n\t\tCMD_TYPE_NVME_INTEL_RST,\n\t\tCMD_TYPE_NVME_INTEL_VROC,\n\t\tCMD_TYPE_MEGARAID,\n\t\tCMD_TYPE_AMD_RC2,// +AMD_RC2\n\t\tCMD_TYPE_JMS56X,\n\t\tCMD_TYPE_JMB39X,\n\t\tCMD_TYPE_JMS586_20,\n\t\tCMD_TYPE_JMS586_40,\n\t\tCMD_TYPE_DEBUG\n\t};\n\n\tenum CSMI_TYPE\n\t{\n\t\tCSMI_TYPE_DISABLE = 0,\n\t\tCSMI_TYPE_ENABLE_AUTO,\n\t\tCSMI_TYPE_ENABLE_RAID,\n\t\tCSMI_TYPE_ENABLE_ALL,\n\t};\n\n\tenum SMART_WMI_TYPE\n\t{\n\t\tWMI_SMART_DATA = 0,\n\t\tWMI_SMART_THRESHOLD\n\t};\n\n\tenum INTERFACE_TYPE\n\t{\n\t\tINTERFACE_TYPE_UNKNOWN = 0,\n\t\tINTERFACE_TYPE_PATA,\n\t\tINTERFACE_TYPE_SATA,\n\t\tINTERFACE_TYPE_USB,\n\t\tINTERFACE_TYPE_IEEE1394,\n\t//\tINTERFACE_TYPE_UASP,\n\t\tINTERFACE_TYPE_SCSI, \n\t\tINTERFACE_TYPE_NVME,\n\t\tINTERFACE_TYPE_AMD_RC2,// +AMD_RC2\n\t//\tINTERFACE_TYPE_USB_NVME,\n\t};\n\nprotected:\n\tenum IO_CONTROL_CODE\n\t{\n\t\tDFP_SEND_DRIVE_COMMAND\t= 0x0007C084,\n\t\tDFP_RECEIVE_DRIVE_DATA\t= 0x0007C088,\n\t\tIOCTL_SCSI_MINIPORT     = 0x0004D008,\n\t\tIOCTL_IDE_PASS_THROUGH  = 0x0004D028, // 2000 or later\n\t\tIOCTL_ATA_PASS_THROUGH  = 0x0004D02C, // XP SP2 and 2003 or later\n\t};\n\n#pragma pack(push,1)\n\n\ttypedef\tstruct _IDENTIFY_DEVICE_OUTDATA\n\t{\n\t\tSENDCMDOUTPARAMS\tSendCmdOutParam;\n\t\tBYTE\t\t\t\tData[IDENTIFY_BUFFER_SIZE - 1];\n\t} IDENTIFY_DEVICE_OUTDATA, *PIDENTIFY_DEVICE_OUTDATA;\n\n\ttypedef\tstruct _SMART_READ_DATA_OUTDATA\n\t{\n\t\tSENDCMDOUTPARAMS\tSendCmdOutParam;\n\t\tBYTE\t\t\t\tData[READ_ATTRIBUTE_BUFFER_SIZE - 1];\n\t} SMART_READ_DATA_OUTDATA, *PSMART_READ_DATA_OUTDATA;\n\n\ttypedef struct _CMD_IDE_PATH_THROUGH\n\t{\n\t\tIDEREGS\treg;\n\t\tDWORD   length;\n\t\tBYTE    buffer[1];\n\t} CMD_IDE_PATH_THROUGH, *PCMD_IDE_PATH_THROUGH;\n\n\tstatic const int ATA_FLAGS_DRDY_REQUIRED = 0x01;\n\tstatic const int ATA_FLAGS_DATA_IN       = 0x02;\n\tstatic const int ATA_FLAGS_DATA_OUT      = 0x04;\n\tstatic const int ATA_FLAGS_48BIT_COMMAND = 0x08;\n\n\ttypedef struct _ATA_PASS_THROUGH_EX\n\t{\n\t\tWORD    Length;\n\t\tWORD    AtaFlags;\n\t\tBYTE    PathId;\n\t\tBYTE    TargetId;\n\t\tBYTE    Lun;\n\t\tBYTE    ReservedAsUchar;\n\t\tDWORD   DataTransferLength;\n\t\tDWORD   TimeOutValue;\n\t\tDWORD   ReservedAsUlong;\n\t//\tDWORD   DataBufferOffset;\n#ifdef _WIN64\n\t\tDWORD\tpadding;\n#endif\n\t\tDWORD_PTR   DataBufferOffset;\n\t\tIDEREGS PreviousTaskFile;\n\t\tIDEREGS CurrentTaskFile;\n\t} ATA_PASS_THROUGH_EX, *PCMD_ATA_PASS_THROUGH_EX;\n\n\ttypedef struct\n\t{\n\t\tATA_PASS_THROUGH_EX Apt;\n\t\tDWORD Filer;\n\t\tBYTE  Buf[512];\n\t} ATA_PASS_THROUGH_EX_WITH_BUFFERS;\n\n\ttypedef\tstruct _SMART_THRESHOLD\n\t{\n\t\tBYTE\tId;\n\t\tBYTE\tThresholdValue;\n\t\tBYTE\tReserved[10];\n\t} SMART_THRESHOLD;\n\n\ttypedef struct _SRB_IO_CONTROL\n\t{\n\t   ULONG\tHeaderLength;\n\t   UCHAR\tSignature[8];\n\t   ULONG\tTimeout;\n\t   ULONG\tControlCode;\n\t   ULONG\tReturnCode;\n\t   ULONG\tLength;\n\t} SRB_IO_CONTROL;\n\n\ttypedef struct _SRB_IO_COMMAND\n\t{\n\t\tSRB_IO_CONTROL\tCntrol;\n\t\tIDEREGS\t\t\tIdeRegs;\n\t\tBYTE\t\t\tData[512];\n\t} SRB_IO_COMMAND;\n\n\ttypedef struct {\n\t\tSRB_IO_CONTROL sic ;\n\t\tUSHORT port ;\n\t\tUSHORT maybe_always1 ;\n\t\tULONG unknown[5] ;\n\t\t//IDENTIFY_DEVICE id_data ;\n\t\tWORD id_data[256] ;\n\t} SilIdentDev ;\n\n\tstruct BIN_IDENTIFY_DEVICE\n\t{\n\t\tBYTE\t\tBin[4096];\n\t};\n\n\tstruct NVME_IDENTIFY_DEVICE\n\t{\n\t\tCHAR\t\tReserved1[4];\n\t\tCHAR\t\tSerialNumber[20];\n\t\tCHAR\t\tModel[40];\n\t\tCHAR\t\tFirmwareRev[8];\n\t\tCHAR\t\tReserved2[9];\n\t\tCHAR\t\tMinorVersion;\n\t\tSHORT\t\tMajorVersion;\n\t\tCHAR\t\tReserved3[428];\n\t\tCHAR\t\tReserved4[3584];\n\t};\n\n\tstruct ATA_IDENTIFY_DEVICE\n\t{\n\t\tWORD\t\tGeneralConfiguration;\t\t\t\t\t//0\n\t\tWORD\t\tLogicalCylinders;\t\t\t\t\t\t//1\tObsolete\n\t\tWORD\t\tSpecificConfiguration;\t\t\t\t\t//2\n\t\tWORD\t\tLogicalHeads;\t\t\t\t\t\t\t//3 Obsolete\n\t\tWORD\t\tRetired1[2];\t\t\t\t\t\t\t//4-5\n\t\tWORD\t\tLogicalSectors;\t\t\t\t\t\t\t//6 Obsolete\n\t\tDWORD\t\tReservedForCompactFlash;\t\t\t\t//7-8\n\t\tWORD\t\tRetired2;\t\t\t\t\t\t\t\t//9\n\t\tCHAR\t\tSerialNumber[20];\t\t\t\t\t\t//10-19\n\t\tWORD\t\tRetired3;\t\t\t\t\t\t\t\t//20\n\t\tWORD\t\tBufferSize;\t\t\t\t\t\t\t\t//21 Obsolete\n\t\tWORD\t\tObsolute4;\t\t\t\t\t\t\t\t//22\n\t\tCHAR\t\tFirmwareRev[8];\t\t\t\t\t\t\t//23-26\n\t\tCHAR\t\tModel[40];\t\t\t\t\t\t\t\t//27-46\n\t\tWORD\t\tMaxNumPerInterupt;\t\t\t\t\t\t//47\n\t\tWORD\t\tReserved1;\t\t\t\t\t\t\t\t//48\n\t\tWORD\t\tCapabilities1;\t\t\t\t\t\t\t//49\n\t\tWORD\t\tCapabilities2;\t\t\t\t\t\t\t//50\n\t\tDWORD\t\tObsolute5;\t\t\t\t\t\t\t\t//51-52\n\t\tWORD\t\tField88and7064;\t\t\t\t\t\t\t//53\n\t\tWORD\t\tObsolute6[5];\t\t\t\t\t\t\t//54-58\n\t\tWORD\t\tMultSectorStuff;\t\t\t\t\t\t//59\n\t\tDWORD\t\tTotalAddressableSectors;\t\t\t\t//60-61\n\t\tWORD\t\tObsolute7;\t\t\t\t\t\t\t\t//62\n\t\tWORD\t\tMultiWordDma;\t\t\t\t\t\t\t//63\n\t\tWORD\t\tPioMode;\t\t\t\t\t\t\t\t//64\n\t\tWORD\t\tMinMultiwordDmaCycleTime;\t\t\t\t//65\n\t\tWORD\t\tRecommendedMultiwordDmaCycleTime;\t\t//66\n\t\tWORD\t\tMinPioCycleTimewoFlowCtrl;\t\t\t\t//67\n\t\tWORD\t\tMinPioCycleTimeWithFlowCtrl;\t\t\t//68\n\t\tWORD\t\tReserved2[6];\t\t\t\t\t\t\t//69-74\n\t\tWORD\t\tQueueDepth;\t\t\t\t\t\t\t\t//75\n\t\tWORD\t\tSerialAtaCapabilities;\t\t\t\t\t//76\n\t\tWORD\t\tSerialAtaAdditionalCapabilities;\t\t//77\n\t\tWORD\t\tSerialAtaFeaturesSupported;\t\t\t\t//78\n\t\tWORD\t\tSerialAtaFeaturesEnabled;\t\t\t\t//79\n\t\tWORD\t\tMajorVersion;\t\t\t\t\t\t\t//80\n\t\tWORD\t\tMinorVersion;\t\t\t\t\t\t\t//81\n\t\tWORD\t\tCommandSetSupported1;\t\t\t\t\t//82\n\t\tWORD\t\tCommandSetSupported2;\t\t\t\t\t//83\n\t\tWORD\t\tCommandSetSupported3;\t\t\t\t\t//84\n\t\tWORD\t\tCommandSetEnabled1;\t\t\t\t\t\t//85\n\t\tWORD\t\tCommandSetEnabled2;\t\t\t\t\t\t//86\n\t\tWORD\t\tCommandSetDefault;\t\t\t\t\t\t//87\n\t\tWORD\t\tUltraDmaMode;\t\t\t\t\t\t\t//88\n\t\tWORD\t\tTimeReqForSecurityErase;\t\t\t\t//89\n\t\tWORD\t\tTimeReqForEnhancedSecure;\t\t\t\t//90\n\t\tWORD\t\tCurrentPowerManagement;\t\t\t\t\t//91\n\t\tWORD\t\tMasterPasswordRevision;\t\t\t\t\t//92\n\t\tWORD\t\tHardwareResetResult;\t\t\t\t\t//93\n\t\tWORD\t\tAcoustricManagement;\t\t\t\t\t//94\n\t\tWORD\t\tStreamMinRequestSize;\t\t\t\t\t//95\n\t\tWORD\t\tStreamingTimeDma;\t\t\t\t\t\t//96\n\t\tWORD\t\tStreamingAccessLatency;\t\t\t\t\t//97\n\t\tDWORD\t\tStreamingPerformance;\t\t\t\t\t//98-99\n\t\tULONGLONG\tMaxUserLba;\t\t\t\t\t\t\t\t//100-103\n\t\tWORD\t\tStremingTimePio;\t\t\t\t\t\t//104\n\t\tWORD\t\tReserved3;\t\t\t\t\t\t\t\t//105\n\t\tWORD\t\tSectorSize;\t\t\t\t\t\t\t\t//106\n\t\tWORD\t\tInterSeekDelay;\t\t\t\t\t\t\t//107\n\t\tWORD\t\tIeeeOui;\t\t\t\t\t\t\t\t//108\n\t\tWORD\t\tUniqueId3;\t\t\t\t\t\t\t\t//109\n\t\tWORD\t\tUniqueId2;\t\t\t\t\t\t\t\t//110\n\t\tWORD\t\tUniqueId1;\t\t\t\t\t\t\t\t//111\n\t\tWORD\t\tReserved4[4];\t\t\t\t\t\t\t//112-115\n\t\tWORD\t\tReserved5;\t\t\t\t\t\t\t\t//116\n\t\tDWORD\t\tWordsPerLogicalSector;\t\t\t\t\t//117-118\n\t\tWORD\t\tReserved6[8];\t\t\t\t\t\t\t//119-126\n\t\tWORD\t\tRemovableMediaStatus;\t\t\t\t\t//127\n\t\tWORD\t\tSecurityStatus;\t\t\t\t\t\t\t//128\n\t\tWORD\t\tVendorSpecific[31];\t\t\t\t\t\t//129-159\n\t\tWORD\t\tCfaPowerMode1;\t\t\t\t\t\t\t//160\n\t\tWORD\t\tReservedForCompactFlashAssociation[7];\t//161-167\n\t\tWORD\t\tDeviceNominalFormFactor;\t\t\t\t//168\n\t\tWORD\t\tDataSetManagement;\t\t\t\t\t\t//169\n\t\tWORD\t\tAdditionalProductIdentifier[4];\t\t\t//170-173\n\t\tWORD\t\tReserved7[2];\t\t\t\t\t\t\t//174-175\n\t\tCHAR\t\tCurrentMediaSerialNo[60];\t\t\t\t//176-205\n\t\tWORD\t\tSctCommandTransport;\t\t\t\t\t//206\n\t\tWORD\t\tReservedForCeAta1[2];\t\t\t\t\t//207-208\n\t\tWORD\t\tAlignmentOfLogicalBlocks;\t\t\t\t//209\n\t\tDWORD\t\tWriteReadVerifySectorCountMode3;\t\t//210-211\n\t\tDWORD\t\tWriteReadVerifySectorCountMode2;\t\t//212-213\n\t\tWORD\t\tNvCacheCapabilities;\t\t\t\t\t//214\n\t\tDWORD\t\tNvCacheSizeLogicalBlocks;\t\t\t\t//215-216\n\t\tWORD\t\tNominalMediaRotationRate;\t\t\t\t//217\n\t\tWORD\t\tReserved8;\t\t\t\t\t\t\t\t//218\n\t\tWORD\t\tNvCacheOptions1;\t\t\t\t\t\t//219\n\t\tWORD\t\tNvCacheOptions2;\t\t\t\t\t\t//220\n\t\tWORD\t\tReserved9;\t\t\t\t\t\t\t\t//221\n\t\tWORD\t\tTransportMajorVersionNumber;\t\t\t//222\n\t\tWORD\t\tTransportMinorVersionNumber;\t\t\t//223\n\t\tWORD\t\tReservedForCeAta2[10];\t\t\t\t\t//224-233\n\t\tWORD\t\tMinimumBlocksPerDownloadMicrocode;\t\t//234\n\t\tWORD\t\tMaximumBlocksPerDownloadMicrocode;\t\t//235\n\t\tWORD\t\tReserved10[19];\t\t\t\t\t\t\t//236-254\n\t\tWORD\t\tIntegrityWord;\t\t\t\t\t\t\t//255\n\t};\n#pragma\tpack(pop)\n\n\n///////////////////////////////////////////////////\n// from http://naraeon.net/en/archives/1126\n///////////////////////////////////////////////////\n\n#define NVME_STORPORT_DRIVER 0xE000\n#define NVME_PASS_THROUGH_SRB_IO_CODE \\\n\tCTL_CODE( NVME_STORPORT_DRIVER, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\n#define NVME_SIG_STR \"NvmeMini\"\n#define NVME_SIG_STR_LEN 8\n#define NVME_FROM_DEV_TO_HOST 2\n#define NVME_IOCTL_VENDOR_SPECIFIC_DW_SIZE 6\n#define NVME_IOCTL_CMD_DW_SIZE 16\n#define NVME_IOCTL_COMPLETE_DW_SIZE 4\n#define NVME_PT_TIMEOUT 40\n\n#define IOCTL_SCSI_GET_ADDRESS \\\n\tCTL_CODE(IOCTL_SCSI_BASE, 0x0406, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\n\n\n\ttypedef struct _SCSI_ADDRESS {\n\t\tULONG Length;\n\t\tUCHAR PortNumber;\n\t\tUCHAR PathId;\n\t\tUCHAR TargetId;\n\t\tUCHAR Lun;\n\t} SCSI_ADDRESS, *PSCSI_ADDRESS;\n\n\tstruct NVME_PASS_THROUGH_IOCTL {\n\t\tSRB_IO_CONTROL SrbIoCtrl;\n\t\tDWORD          VendorSpecific[NVME_IOCTL_VENDOR_SPECIFIC_DW_SIZE];\n\t\tDWORD          NVMeCmd[NVME_IOCTL_CMD_DW_SIZE];\n\t\tDWORD          CplEntry[NVME_IOCTL_COMPLETE_DW_SIZE];\n\t\tDWORD          Direction;\n\t\tDWORD          QueueId;\n\t\tDWORD          DataBufferLen;\n\t\tDWORD          MetaDataLen;\n\t\tDWORD          ReturnBufferLen;\n\t\tUCHAR          DataBuffer[4096];\n\t};\n\n///////////////////\n// from csmisas.h\n///////////////////\n\n// IOCTL Control Codes\n// (IoctlHeader.ControlCode)\n\n// Control Codes requiring CSMI_ALL_SIGNATURE\n\n#define CC_CSMI_SAS_GET_DRIVER_INFO    1\n#define CC_CSMI_SAS_GET_CNTLR_CONFIG   2\n#define CC_CSMI_SAS_GET_CNTLR_STATUS   3\n#define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  4\n\n// Control Codes requiring CSMI_RAID_SIGNATURE\n\n#define CC_CSMI_SAS_GET_RAID_INFO      10\n#define CC_CSMI_SAS_GET_RAID_CONFIG    11\n#define CC_CSMI_SAS_GET_RAID_FEATURES  12\n#define CC_CSMI_SAS_SET_RAID_CONTROL   13\n#define CC_CSMI_SAS_GET_RAID_ELEMENT   14\n#define CC_CSMI_SAS_SET_RAID_OPERATION 15\n\n// Control Codes requiring CSMI_SAS_SIGNATURE\n\n#define CC_CSMI_SAS_GET_PHY_INFO       20\n#define CC_CSMI_SAS_SET_PHY_INFO       21\n#define CC_CSMI_SAS_GET_LINK_ERRORS    22\n#define CC_CSMI_SAS_SMP_PASSTHRU       23\n#define CC_CSMI_SAS_SSP_PASSTHRU       24\n#define CC_CSMI_SAS_STP_PASSTHRU       25\n#define CC_CSMI_SAS_GET_SATA_SIGNATURE 26\n#define CC_CSMI_SAS_GET_SCSI_ADDRESS   27\n#define CC_CSMI_SAS_GET_DEVICE_ADDRESS 28\n#define CC_CSMI_SAS_TASK_MANAGEMENT    29\n#define CC_CSMI_SAS_GET_CONNECTOR_INFO 30\n#define CC_CSMI_SAS_GET_LOCATION       31\n\n// Control Codes requiring CSMI_PHY_SIGNATURE\n\n#define CC_CSMI_SAS_PHY_CONTROL        60\n\n#define IOCTL_HEADER SRB_IO_CONTROL\n#define PIOCTL_HEADER PSRB_IO_CONTROL\n\n/*************************************************************************/\n/* OS INDEPENDENT CODE                                                   */\n/*************************************************************************/\n\n/* * * * * * * * * * Class Independent IOCTL Constants * * * * * * * * * */\n\n// Return codes for all IOCTL's regardless of class\n// (IoctlHeader.ReturnCode)\n\n#define CSMI_SAS_STATUS_SUCCESS              0\n#define CSMI_SAS_STATUS_FAILED               1\n#define CSMI_SAS_STATUS_BAD_CNTL_CODE        2\n#define CSMI_SAS_STATUS_INVALID_PARAMETER    3\n#define CSMI_SAS_STATUS_WRITE_ATTEMPTED      4\n\n// Signature value\n// (IoctlHeader.Signature)\n\n#define CSMI_ALL_SIGNATURE    \"CSMIALL\"\n\n// Timeout value default of 60 seconds\n// (IoctlHeader.Timeout)\n\n#define CSMI_ALL_TIMEOUT      60\n\n//  Direction values for data flow on this IOCTL\n// (IoctlHeader.Direction, Linux only)\n#define CSMI_SAS_DATA_READ    0\n#define CSMI_SAS_DATA_WRITE   1\n\n// I/O Bus Types\n// ISA and EISA bus types are not supported\n// (bIoBusType)\n\n#define CSMI_SAS_BUS_TYPE_PCI       3\n#define CSMI_SAS_BUS_TYPE_PCMCIA    4\n\n// Controller Status\n// (uStatus)\n\n#define CSMI_SAS_CNTLR_STATUS_GOOD     1\n#define CSMI_SAS_CNTLR_STATUS_FAILED   2\n#define CSMI_SAS_CNTLR_STATUS_OFFLINE  3\n#define CSMI_SAS_CNTLR_STATUS_POWEROFF 4\n\n// Offline Status Reason\n// (uOfflineReason)\n\n#define CSMI_SAS_OFFLINE_REASON_NO_REASON             0\n#define CSMI_SAS_OFFLINE_REASON_INITIALIZING          1\n#define CSMI_SAS_OFFLINE_REASON_BACKSIDE_BUS_DEGRADED 2\n#define CSMI_SAS_OFFLINE_REASON_BACKSIDE_BUS_FAILURE  3\n\n// Controller Class\n// (bControllerClass)\n\n#define CSMI_SAS_CNTLR_CLASS_HBA    5\n\n// Controller Flag bits\n// (uControllerFlags)\n\n#define CSMI_SAS_CNTLR_SAS_HBA          0x00000001\n#define CSMI_SAS_CNTLR_SAS_RAID         0x00000002\n#define CSMI_SAS_CNTLR_SATA_HBA         0x00000004\n#define CSMI_SAS_CNTLR_SATA_RAID        0x00000008\n#define CSMI_SAS_CNTLR_SMART_ARRAY      0x00000010\n\n// for firmware download\n#define CSMI_SAS_CNTLR_FWD_SUPPORT      0x00010000\n#define CSMI_SAS_CNTLR_FWD_ONLINE       0x00020000\n#define CSMI_SAS_CNTLR_FWD_SRESET       0x00040000\n#define CSMI_SAS_CNTLR_FWD_HRESET       0x00080000\n#define CSMI_SAS_CNTLR_FWD_RROM         0x00100000\n\n// for RAID configuration supported\n#define CSMI_SAS_CNTLR_RAID_CFG_SUPPORT 0x01000000\n\n// Download Flag bits\n// (uDownloadFlags)\n#define CSMI_SAS_FWD_VALIDATE       0x00000001\n#define CSMI_SAS_FWD_SOFT_RESET     0x00000002\n#define CSMI_SAS_FWD_HARD_RESET     0x00000004\n\n// Firmware Download Status\n// (usStatus)\n#define CSMI_SAS_FWD_SUCCESS        0\n#define CSMI_SAS_FWD_FAILED         1\n#define CSMI_SAS_FWD_USING_RROM     2\n#define CSMI_SAS_FWD_REJECT         3\n#define CSMI_SAS_FWD_DOWNREV        4\n\n// Firmware Download Severity\n// (usSeverity>\n#define CSMI_SAS_FWD_INFORMATION    0\n#define CSMI_SAS_FWD_WARNING        1\n#define CSMI_SAS_FWD_ERROR          2\n#define CSMI_SAS_FWD_FATAL          3\n\n/* * * * * * * * * * SAS RAID Class IOCTL Constants  * * * * * * * * */\n\n// Return codes for the RAID IOCTL's regardless of class\n// (IoctlHeader.ReturnCode)\n\n#define CSMI_SAS_RAID_SET_OUT_OF_RANGE       1000\n#define CSMI_SAS_RAID_SET_BUFFER_TOO_SMALL   1001\n#define CSMI_SAS_RAID_SET_DATA_CHANGED       1002\n\n// Signature value\n// (IoctlHeader.Signature)\n\n#define CSMI_RAID_SIGNATURE    \"CSMIARY\"\n\n// Timeout value default of 60 seconds\n// (IoctlHeader.Timeout)\n\n#define CSMI_RAID_TIMEOUT      60\n\n// RAID Types\n// (bRaidType)\n#define CSMI_SAS_RAID_TYPE_NONE     0\n#define CSMI_SAS_RAID_TYPE_0        1\n#define CSMI_SAS_RAID_TYPE_1        2\n#define CSMI_SAS_RAID_TYPE_10       3\n#define CSMI_SAS_RAID_TYPE_5        4\n#define CSMI_SAS_RAID_TYPE_15       5\n#define CSMI_SAS_RAID_TYPE_6        6\n#define CSMI_SAS_RAID_TYPE_50       7\n#define CSMI_SAS_RAID_TYPE_VOLUME   8\n#define CSMI_SAS_RAID_TYPE_1E       9\n#define CSMI_SAS_RAID_TYPE_OTHER    255\n// the last value 255 was already defined for other\n// so end is defined as 254\n#define CSMI_SAS_RAID_TYPE_END      254\n\n// RAID Status\n// (bStatus)\n#define CSMI_SAS_RAID_SET_STATUS_OK             0\n#define CSMI_SAS_RAID_SET_STATUS_DEGRADED       1\n#define CSMI_SAS_RAID_SET_STATUS_REBUILDING     2\n#define CSMI_SAS_RAID_SET_STATUS_FAILED         3\n#define CSMI_SAS_RAID_SET_STATUS_OFFLINE        4\n#define CSMI_SAS_RAID_SET_STATUS_TRANSFORMING   5\n#define CSMI_SAS_RAID_SET_STATUS_QUEUED_FOR_REBUILD         6\n#define CSMI_SAS_RAID_SET_STATUS_QUEUED_FOR_TRANSFORMATION  7\n\n// RAID Drive Count\n// (bDriveCount, 0xF1 to 0xFF are reserved)\n#define CSMI_SAS_RAID_DRIVE_COUNT_TOO_BIG   0xF1\n#define CSMI_SAS_RAID_DRIVE_COUNT_SUPRESSED 0xF2\n\n// RAID Data Type\n// (bDataType)\n#define CSMI_SAS_RAID_DATA_DRIVES           0\n#define CSMI_SAS_RAID_DATA_DEVICE_ID        1\n#define CSMI_SAS_RAID_DATA_ADDITIONAL_DATA  2\n\n// RAID Drive Status\n// (bDriveStatus)\n#define CSMI_SAS_DRIVE_STATUS_OK          0\n#define CSMI_SAS_DRIVE_STATUS_REBUILDING  1\n#define CSMI_SAS_DRIVE_STATUS_FAILED      2\n#define CSMI_SAS_DRIVE_STATUS_DEGRADED    3\n#define CSMI_SAS_DRIVE_STATUS_OFFLINE     4\n#define CSMI_SAS_DRIVE_STATUS_QUEUED_FOR_REBUILD 5\n\n// RAID Drive Usage\n// (bDriveUsage)\n#define CSMI_SAS_DRIVE_CONFIG_NOT_USED      0\n#define CSMI_SAS_DRIVE_CONFIG_MEMBER        1\n#define CSMI_SAS_DRIVE_CONFIG_SPARE         2\n#define CSMI_SAS_DRIVE_CONFIG_SPARE_ACTIVE  3\n\n// RAID Drive Type\n// (bDriveType)\n#define CSMI_SAS_DRIVE_TYPE_UNKNOWN         0\n#define CSMI_SAS_DRIVE_TYPE_SINGLE_PORT_SAS 1\n#define CSMI_SAS_DRIVE_TYPE_DUAL_PORT_SAS   2\n#define CSMI_SAS_DRIVE_TYPE_SATA            3\n#define CSMI_SAS_DRIVE_TYPE_SATA_PS         4\n#define CSMI_SAS_DRIVE_TYPE_OTHER           255\n\n// RAID Write Protect\n// (bWriteProtect)\n#define CSMI_SAS_RAID_SET_WRITE_PROTECT_UNKNOWN     0\n#define CSMI_SAS_RAID_SET_WRITE_PROTECT_UNCHANGED   0\n#define CSMI_SAS_RAID_SET_WRITE_PROTECT_ENABLED     1\n#define CSMI_SAS_RAID_SET_WRITE_PROTECT_DISABLED    2\n\n// RAID Cache Setting\n// (bCacheSetting)\n#define CSMI_SAS_RAID_SET_CACHE_UNKNOWN             0\n#define CSMI_SAS_RAID_SET_CACHE_UNCHANGED           0\n#define CSMI_SAS_RAID_SET_CACHE_ENABLED             1\n#define CSMI_SAS_RAID_SET_CACHE_DISABLED            2\n#define CSMI_SAS_RAID_SET_CACHE_CORRUPT             3\n\n// RAID Features\n// (uFeatures)\n#define CSMI_SAS_RAID_FEATURE_TRANSFORMATION    0x00000001\n#define CSMI_SAS_RAID_FEATURE_REBUILD           0x00000002\n#define CSMI_SAS_RAID_FEATURE_SPLIT_MIRROR      0x00000004\n#define CSMI_SAS_RAID_FEATURE_MERGE_MIRROR      0x00000008\n#define CSMI_SAS_RAID_FEATURE_LUN_RENUMBER      0x00000010\n#define CSMI_SAS_RAID_FEATURE_SURFACE_SCAN      0x00000020\n#define CSMI_SAS_RAID_FEATURE_SPARES_SHARED     0x00000040\n\n// RAID Priority\n// (bDefaultTransformPriority, etc.)\n#define CSMI_SAS_PRIORITY_UNKNOWN   0\n#define CSMI_SAS_PRIORITY_UNCHANGED 0\n#define CSMI_SAS_PRIORITY_AUTO      1\n#define CSMI_SAS_PRIORITY_OFF       2\n#define CSMI_SAS_PRIORITY_LOW       3\n#define CSMI_SAS_PRIORITY_MEDIUM    4\n#define CSMI_SAS_PRIORITY_HIGH      5\n\n// RAID Transformation Rules\n// (uRaidSetTransformationRules)\n#define CSMI_SAS_RAID_RULE_AVAILABLE_MEMORY     0x00000001\n#define CSMI_SAS_RAID_RULE_OVERLAPPED_EXTENTS   0x00000002\n\n// RAID Cache Ratios Supported\n// (bCacheRatiosSupported)\n// from 0 to 100 defines the write to read ratio, 0 is 100% write\n#define CSMI_SAS_RAID_CACHE_RATIO_RANGE     101\n#define CSMI_SAS_RAID_CACHE_RATIO_FIXED     102\n#define CSMI_SAS_RAID_CACHE_RATIO_AUTO      103\n#define CSMI_SAS_RAID_CACHE_RATIO_END       255\n\n// RAID Cache Ratio Flag\n// (bCacheRatioFlag)\n#define CSMI_SAS_RAID_CACHE_RATIO_DISABLE   0\n#define CSMI_SAS_RAID_CACHE_RATIO_ENABLE    1\n\n// RAID Clear Configuration Signature\n// (bClearConfiguration)\n#define CSMI_SAS_RAID_CLEAR_CONFIGURATION_SIGNATURE \"RAIDCLR\"\n\n// RAID Failure Codes\n// (uFailureCode)\n#define CSMI_SAS_FAIL_CODE_OK                           0\n#define CSMI_SAS_FAIL_CODE_PARAMETER_INVALID            1000\n#define CSMI_SAS_FAIL_CODE_TRANSFORM_PRIORITY_INVALID   1001\n#define CSMI_SAS_FAIL_CODE_REBUILD_PRIORITY_INVALID     1002\n#define CSMI_SAS_FAIL_CODE_CACHE_RATIO_INVALID          1003\n#define CSMI_SAS_FAIL_CODE_SURFACE_SCAN_INVALID         1004\n#define CSMI_SAS_FAIL_CODE_CLEAR_CONFIGURATION_INVALID  1005\n#define CSMI_SAS_FAIL_CODE_ELEMENT_INDEX_INVALID        1006\n#define CSMI_SAS_FAIL_CODE_SUBELEMENT_INDEX_INVALID     1007\n#define CSMI_SAS_FAIL_CODE_EXTENT_INVALID               1008\n#define CSMI_SAS_FAIL_CODE_BLOCK_COUNT_INVALID          1009\n#define CSMI_SAS_FAIL_CODE_DRIVE_INDEX_INVALID          1010\n#define CSMI_SAS_FAIL_CODE_EXISTING_LUN_INVALID         1011\n#define CSMI_SAS_FAIL_CODE_RAID_TYPE_INVALID            1012\n#define CSMI_SAS_FAIL_CODE_STRIPE_SIZE_INVALID          1013\n#define CSMI_SAS_FAIL_CODE_TRANSFORMATION_INVALID       1014\n#define CSMI_SAS_FAIL_CODE_CHANGE_COUNT_INVALID         1015\n#define CSMI_SAS_FAIL_CODE_ENUMERATION_TYPE_INVALID     1016\n\n#define CSMI_SAS_FAIL_CODE_EXCEEDED_RAID_SET_COUNT      2000\n#define CSMI_SAS_FAIL_CODE_DUPLICATE_LUN                2001\n\n#define CSMI_SAS_FAIL_CODE_WAIT_FOR_OPERATION           3000\n\n// RAID Enumeration Types\n// (uEnumerationType)\n#define CSMI_SAS_RAID_ELEMENT_TYPE_DRIVE                0\n#define CSMI_SAS_RAID_ELEMENT_TYPE_MODULE               1\n#define CSMI_SAS_RAID_ELEMENT_TYPE_DRIVE_RAID_SET       2\n#define CSMI_SAS_RAID_ELEMENT_TYPE_EXTENT_DRIVE         3\n\n// RAID Extent Types\n// (bExtentType)\n#define CSMI_SAS_RAID_EXTENT_RESERVED       0\n#define CSMI_SAS_RAID_EXTENT_METADATA       1\n#define CSMI_SAS_RAID_EXTENT_ALLOCATED      2\n#define CSMI_SAS_RAID_EXTENT_UNALLOCATED    3\n\n// RAID Operation Types\n// (uOperationType)\n#define CSMI_SAS_RAID_SET_CREATE            0\n#define CSMI_SAS_RAID_SET_LABEL             1\n#define CSMI_SAS_RAID_SET_TRANSFORM         2\n#define CSMI_SAS_RAID_SET_DELETE            3\n#define CSMI_SAS_RAID_SET_WRITE_PROTECT     4\n#define CSMI_SAS_RAID_SET_CACHE             5\n#define CSMI_SAS_RAID_SET_ONLINE_STATE      6\n#define CSMI_SAS_RAID_SET_SPARE             7\n\n// RAID Transform Types\n// (bTransformType)\n#define CSMI_SAS_RAID_SET_TRANSFORM_SPLIT_MIRROR    0\n#define CSMI_SAS_RAID_SET_TRANSFORM_MERGE_RAID_0    1\n#define CSMI_SAS_RAID_SET_TRANSFORM_LUN_RENUMBER    2\n#define CSMI_SAS_RAID_SET_TRANSFORM_RAID_SET        3\n\n// RAID Online State\n// (bOnlineState)\n#define CSMI_SAS_RAID_SET_STATE_UNKNOWN     0\n#define CSMI_SAS_RAID_SET_STATE_ONLINE      1\n#define CSMI_SAS_RAID_SET_STATE_OFFLINE     2\n\n/* * * * * * * * * * SAS HBA Class IOCTL Constants * * * * * * * * * */\n\n// Return codes for SAS IOCTL's\n// (IoctlHeader.ReturnCode)\n\n#define CSMI_SAS_PHY_INFO_CHANGED            CSMI_SAS_STATUS_SUCCESS\n#define CSMI_SAS_PHY_INFO_NOT_CHANGEABLE     2000\n#define CSMI_SAS_LINK_RATE_OUT_OF_RANGE      2001\n\n#define CSMI_SAS_PHY_DOES_NOT_EXIST          2002\n#define CSMI_SAS_PHY_DOES_NOT_MATCH_PORT     2003\n#define CSMI_SAS_PHY_CANNOT_BE_SELECTED      2004\n#define CSMI_SAS_SELECT_PHY_OR_PORT          2005\n#define CSMI_SAS_PORT_DOES_NOT_EXIST         2006\n#define CSMI_SAS_PORT_CANNOT_BE_SELECTED     2007\n#define CSMI_SAS_CONNECTION_FAILED           2008\n\n#define CSMI_SAS_NO_SATA_DEVICE              2009\n#define CSMI_SAS_NO_SATA_SIGNATURE           2010\n#define CSMI_SAS_SCSI_EMULATION              2011\n#define CSMI_SAS_NOT_AN_END_DEVICE           2012\n#define CSMI_SAS_NO_SCSI_ADDRESS             2013\n#define CSMI_SAS_NO_DEVICE_ADDRESS           2014\n\n// Signature value\n// (IoctlHeader.Signature)\n\n#define CSMI_SAS_SIGNATURE    \"CSMISAS\"\n\n// Timeout value default of 60 seconds\n// (IoctlHeader.Timeout)\n\n#define CSMI_SAS_TIMEOUT      60\n\n// Device types\n// (bDeviceType)\n\n#define CSMI_SAS_PHY_UNUSED               0x00\n#define CSMI_SAS_NO_DEVICE_ATTACHED       0x00\n#define CSMI_SAS_END_DEVICE               0x10\n#define CSMI_SAS_EDGE_EXPANDER_DEVICE     0x20\n#define CSMI_SAS_FANOUT_EXPANDER_DEVICE   0x30\n\n// Protocol options\n// (bInitiatorPortProtocol, bTargetPortProtocol)\n\n#define CSMI_SAS_PROTOCOL_SATA   0x01\n#define CSMI_SAS_PROTOCOL_SMP    0x02\n#define CSMI_SAS_PROTOCOL_STP    0x04\n#define CSMI_SAS_PROTOCOL_SSP    0x08\n\n// Negotiated and hardware link rates\n// (bNegotiatedLinkRate, bMinimumLinkRate, bMaximumLinkRate)\n\n#define CSMI_SAS_LINK_RATE_UNKNOWN  0x00\n#define CSMI_SAS_PHY_DISABLED       0x01\n#define CSMI_SAS_LINK_RATE_FAILED   0x02\n#define CSMI_SAS_SATA_SPINUP_HOLD   0x03\n#define CSMI_SAS_SATA_PORT_SELECTOR 0x04\n#define CSMI_SAS_LINK_RATE_1_5_GBPS 0x08\n#define CSMI_SAS_LINK_RATE_3_0_GBPS 0x09\n#define CSMI_SAS_LINK_VIRTUAL       0x10\n\n// Discover state\n// (bAutoDiscover)\n\n#define CSMI_SAS_DISCOVER_NOT_SUPPORTED   0x00\n#define CSMI_SAS_DISCOVER_NOT_STARTED     0x01\n#define CSMI_SAS_DISCOVER_IN_PROGRESS     0x02\n#define CSMI_SAS_DISCOVER_COMPLETE        0x03\n#define CSMI_SAS_DISCOVER_ERROR           0x04\n\n// Phy features\n\n#define CSMI_SAS_PHY_VIRTUAL_SMP          0x01\n\n// Programmed link rates\n// (bMinimumLinkRate, bMaximumLinkRate)\n// (bProgrammedMinimumLinkRate, bProgrammedMaximumLinkRate)\n\n#define CSMI_SAS_PROGRAMMED_LINK_RATE_UNCHANGED 0x00\n#define CSMI_SAS_PROGRAMMED_LINK_RATE_1_5_GBPS  0x08\n#define CSMI_SAS_PROGRAMMED_LINK_RATE_3_0_GBPS  0x09\n\n// Link rate\n// (bNegotiatedLinkRate in CSMI_SAS_SET_PHY_INFO)\n\n#define CSMI_SAS_LINK_RATE_NEGOTIATE      0x00\n#define CSMI_SAS_LINK_RATE_PHY_DISABLED   0x01\n\n// Signal class\n// (bSignalClass in CSMI_SAS_SET_PHY_INFO)\n\n#define CSMI_SAS_SIGNAL_CLASS_UNKNOWN     0x00\n#define CSMI_SAS_SIGNAL_CLASS_DIRECT      0x01\n#define CSMI_SAS_SIGNAL_CLASS_SERVER      0x02\n#define CSMI_SAS_SIGNAL_CLASS_ENCLOSURE   0x03\n\n// Link error reset\n// (bResetCounts)\n\n#define CSMI_SAS_LINK_ERROR_DONT_RESET_COUNTS   0x00\n#define CSMI_SAS_LINK_ERROR_RESET_COUNTS        0x01\n\n// Phy identifier\n// (bPhyIdentifier)\n\n#define CSMI_SAS_USE_PORT_IDENTIFIER   0xFF\n\n// Port identifier\n// (bPortIdentifier)\n\n#define CSMI_SAS_IGNORE_PORT           0xFF\n\n// Programmed link rates\n// (bConnectionRate)\n\n#define CSMI_SAS_LINK_RATE_NEGOTIATED  0x00\n#define CSMI_SAS_LINK_RATE_1_5_GBPS    0x08\n#define CSMI_SAS_LINK_RATE_3_0_GBPS    0x09\n#define CSMI_SAS_LINK_RATE_6_0_GBPS    0x0A\n#define CSMI_SAS_LINK_RATE_12_0_GBPS   0x0B\n\n// Connection status\n// (bConnectionStatus)\n\n#define CSMI_SAS_OPEN_ACCEPT                          0\n#define CSMI_SAS_OPEN_REJECT_BAD_DESTINATION          1\n#define CSMI_SAS_OPEN_REJECT_RATE_NOT_SUPPORTED       2\n#define CSMI_SAS_OPEN_REJECT_NO_DESTINATION           3\n#define CSMI_SAS_OPEN_REJECT_PATHWAY_BLOCKED          4\n#define CSMI_SAS_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED   5\n#define CSMI_SAS_OPEN_REJECT_RESERVE_ABANDON          6\n#define CSMI_SAS_OPEN_REJECT_RESERVE_CONTINUE         7\n#define CSMI_SAS_OPEN_REJECT_RESERVE_INITIALIZE       8\n#define CSMI_SAS_OPEN_REJECT_RESERVE_STOP             9\n#define CSMI_SAS_OPEN_REJECT_RETRY                    10\n#define CSMI_SAS_OPEN_REJECT_STP_RESOURCES_BUSY       11\n#define CSMI_SAS_OPEN_REJECT_WRONG_DESTINATION        12\n\n// SSP Status\n// (bSSPStatus)\n\n#define CSMI_SAS_SSP_STATUS_UNKNOWN     0x00\n#define CSMI_SAS_SSP_STATUS_WAITING     0x01\n#define CSMI_SAS_SSP_STATUS_COMPLETED   0x02\n#define CSMI_SAS_SSP_STATUS_FATAL_ERROR 0x03\n#define CSMI_SAS_SSP_STATUS_RETRY       0x04\n#define CSMI_SAS_SSP_STATUS_NO_TAG      0x05\n\n// SSP Flags\n// (uFlags)\n\n#define CSMI_SAS_SSP_READ           0x00000001\n#define CSMI_SAS_SSP_WRITE          0x00000002\n#define CSMI_SAS_SSP_UNSPECIFIED    0x00000004\n\n#define CSMI_SAS_SSP_TASK_ATTRIBUTE_SIMPLE         0x00000000\n#define CSMI_SAS_SSP_TASK_ATTRIBUTE_HEAD_OF_QUEUE  0x00000010\n#define CSMI_SAS_SSP_TASK_ATTRIBUTE_ORDERED        0x00000020\n#define CSMI_SAS_SSP_TASK_ATTRIBUTE_ACA            0x00000040\n\n// SSP Data present\n// (bDataPresent)\n\n#define CSMI_SAS_SSP_NO_DATA_PRESENT         0x00\n#define CSMI_SAS_SSP_RESPONSE_DATA_PRESENT   0x01\n#define CSMI_SAS_SSP_SENSE_DATA_PRESENT      0x02\n\n// STP Flags\n// (uFlags)\n\n#define CSMI_SAS_STP_READ           0x00000001\n#define CSMI_SAS_STP_WRITE          0x00000002\n#define CSMI_SAS_STP_UNSPECIFIED    0x00000004\n#define CSMI_SAS_STP_PIO            0x00000010\n#define CSMI_SAS_STP_DMA            0x00000020\n#define CSMI_SAS_STP_PACKET         0x00000040\n#define CSMI_SAS_STP_DMA_QUEUED     0x00000080\n#define CSMI_SAS_STP_EXECUTE_DIAG   0x00000100\n#define CSMI_SAS_STP_RESET_DEVICE   0x00000200\n\n// Task Management Flags\n// (uFlags)\n\n#define CSMI_SAS_TASK_IU               0x00000001\n#define CSMI_SAS_HARD_RESET_SEQUENCE   0x00000002\n#define CSMI_SAS_SUPPRESS_RESULT       0x00000004\n\n// Task Management Functions\n// (bTaskManagement)\n\n#define CSMI_SAS_SSP_ABORT_TASK           0x01\n#define CSMI_SAS_SSP_ABORT_TASK_SET       0x02\n#define CSMI_SAS_SSP_CLEAR_TASK_SET       0x04\n#define CSMI_SAS_SSP_LOGICAL_UNIT_RESET   0x08\n#define CSMI_SAS_SSP_CLEAR_ACA            0x40\n#define CSMI_SAS_SSP_QUERY_TASK           0x80\n\n// Task Management Information\n// (uInformation)\n\n#define CSMI_SAS_SSP_TEST           1\n#define CSMI_SAS_SSP_EXCEEDED       2\n#define CSMI_SAS_SSP_DEMAND         3\n#define CSMI_SAS_SSP_TRIGGER        4\n\n// Connector Pinout Information\n// (uPinout)\n\n#define CSMI_SAS_CON_UNKNOWN              0x00000001\n#define CSMI_SAS_CON_SFF_8482             0x00000002\n#define CSMI_SAS_CON_SFF_8470_LANE_1      0x00000100\n#define CSMI_SAS_CON_SFF_8470_LANE_2      0x00000200\n#define CSMI_SAS_CON_SFF_8470_LANE_3      0x00000400\n#define CSMI_SAS_CON_SFF_8470_LANE_4      0x00000800\n#define CSMI_SAS_CON_SFF_8484_LANE_1      0x00010000\n#define CSMI_SAS_CON_SFF_8484_LANE_2      0x00020000\n#define CSMI_SAS_CON_SFF_8484_LANE_3      0x00040000\n#define CSMI_SAS_CON_SFF_8484_LANE_4      0x00080000\n\n// Connector Location Information\n// (bLocation)\n\n// same as uPinout above...\n// #define CSMI_SAS_CON_UNKNOWN              0x01\n#define CSMI_SAS_CON_INTERNAL             0x02\n#define CSMI_SAS_CON_EXTERNAL             0x04\n#define CSMI_SAS_CON_SWITCHABLE           0x08\n#define CSMI_SAS_CON_AUTO                 0x10\n#define CSMI_SAS_CON_NOT_PRESENT          0x20\n#define CSMI_SAS_CON_NOT_CONNECTED        0x80\n\n// Device location identification\n// (bIdentify)\n\n#define CSMI_SAS_LOCATE_UNKNOWN           0x00\n#define CSMI_SAS_LOCATE_FORCE_OFF         0x01\n#define CSMI_SAS_LOCATE_FORCE_ON          0x02\n\n// Location Valid flags\n// (uLocationFlags)\n\n#define CSMI_SAS_LOCATE_SAS_ADDRESS_VALID           0x00000001\n#define CSMI_SAS_LOCATE_SAS_LUN_VALID               0x00000002\n#define CSMI_SAS_LOCATE_ENCLOSURE_IDENTIFIER_VALID  0x00000004\n#define CSMI_SAS_LOCATE_ENCLOSURE_NAME_VALID        0x00000008\n#define CSMI_SAS_LOCATE_BAY_PREFIX_VALID            0x00000010\n#define CSMI_SAS_LOCATE_BAY_IDENTIFIER_VALID        0x00000020\n#define CSMI_SAS_LOCATE_LOCATION_STATE_VALID        0x00000040\n\n/* * * * * * * * SAS Phy Control Class IOCTL Constants * * * * * * * * */\n\n// Return codes for SAS Phy Control IOCTL's\n// (IoctlHeader.ReturnCode)\n\n// Signature value\n// (IoctlHeader.Signature)\n\n#define CSMI_PHY_SIGNATURE    \"CSMIPHY\"\n\n// Phy Control Functions\n// (bFunction)\n\n// values 0x00 to 0xFF are consistent in definition with the SMP PHY CONTROL\n// function defined in the SAS spec\n#define CSMI_SAS_PC_NOP                   0x00000000\n#define CSMI_SAS_PC_LINK_RESET            0x00000001\n#define CSMI_SAS_PC_HARD_RESET            0x00000002\n#define CSMI_SAS_PC_PHY_DISABLE           0x00000003\n// 0x04 to 0xFF reserved...\n#define CSMI_SAS_PC_GET_PHY_SETTINGS      0x00000100\n\n// Link Flags\n#define CSMI_SAS_PHY_ACTIVATE_CONTROL     0x00000001\n#define CSMI_SAS_PHY_UPDATE_SPINUP_RATE   0x00000002\n#define CSMI_SAS_PHY_AUTO_COMWAKE         0x00000004\n\n// Device Types for Phy Settings\n// (bType)\n#define CSMI_SAS_UNDEFINED 0x00\n#define CSMI_SAS_SATA      0x01\n#define CSMI_SAS_SAS       0x02\n\n// Transmitter Flags\n// (uTransmitterFlags)\n#define CSMI_SAS_PHY_PREEMPHASIS_DISABLED    0x00000001\n\n// Receiver Flags\n// (uReceiverFlags)\n#define CSMI_SAS_PHY_EQUALIZATION_DISABLED   0x00000001\n\n// Pattern Flags\n// (uPatternFlags)\n// #define CSMI_SAS_PHY_ACTIVATE_CONTROL     0x00000001\n#define CSMI_SAS_PHY_DISABLE_SCRAMBLING      0x00000002\n#define CSMI_SAS_PHY_DISABLE_ALIGN           0x00000004\n#define CSMI_SAS_PHY_DISABLE_SSC             0x00000008\n\n#define CSMI_SAS_PHY_FIXED_PATTERN           0x00000010\n#define CSMI_SAS_PHY_USER_PATTERN            0x00000020\n\n// Fixed Patterns\n// (bFixedPattern)\n#define CSMI_SAS_PHY_CJPAT                   0x00000001\n#define CSMI_SAS_PHY_ALIGN                   0x00000002\n\n// Type Flags\n// (bTypeFlags)\n#define CSMI_SAS_PHY_POSITIVE_DISPARITY      0x01\n#define CSMI_SAS_PHY_NEGATIVE_DISPARITY      0x02\n#define CSMI_SAS_PHY_CONTROL_CHARACTER       0x04\n\n// Miscellaneous\n#define SLOT_NUMBER_UNKNOWN   0xFFFF\n\n#pragma pack(8)\n\n\ttypedef struct _CSMI_SAS_DRIVER_INFO\n\t{\n\t\tUCHAR  szName[81];\n\t\tUCHAR  szDescription[81];\n\t\tUSHORT usMajorRevision;\n\t\tUSHORT usMinorRevision;\n\t\tUSHORT usBuildRevision;\n\t\tUSHORT usReleaseRevision;\n\t\tUSHORT usCSMIMajorRevision;\n\t\tUSHORT usCSMIMinorRevision;\n\t} CSMI_SAS_DRIVER_INFO, *PCSMI_SAS_DRIVER_INFO;\n\n\ttypedef struct _CSMI_SAS_DRIVER_INFO_BUFFER\n\t{\n\t\tSRB_IO_CONTROL IoctlHeader;\n\t\tCSMI_SAS_DRIVER_INFO Information;\n\t} CSMI_SAS_DRIVER_INFO_BUFFER, *PCSMI_SAS_DRIVER_INFO_BUFFER;\n\n\ttypedef struct _CSMI_SAS_IDENTIFY\n\t{\n\t\tUCHAR bDeviceType;\n\t\tUCHAR bRestricted;\n\t\tUCHAR bInitiatorPortProtocol;\n\t\tUCHAR bTargetPortProtocol;\n\t\tUCHAR bRestricted2[8];\n\t\tUCHAR bSASAddress[8];\n\t\tUCHAR bPhyIdentifier;\n\t\tUCHAR bSignalClass;\n\t\tUCHAR bReserved[6];\n\t} CSMI_SAS_IDENTIFY, *PCSMI_SAS_IDENTIFY;\n\n\ttypedef struct _CSMI_SAS_PHY_ENTITY\n\t{\n\t\tCSMI_SAS_IDENTIFY Identify;\n\t\tUCHAR bPortIdentifier;\n\t\tUCHAR bNegotiatedLinkRate;\n\t\tUCHAR bMinimumLinkRate;\n\t\tUCHAR bMaximumLinkRate;\n\t\tUCHAR bPhyChangeCount;\n\t\tUCHAR bAutoDiscover;\n\t\tUCHAR bPhyFeatures;\n\t\tUCHAR bReserved;\n\t\tCSMI_SAS_IDENTIFY Attached;\n\t} CSMI_SAS_PHY_ENTITY, *PCSMI_SAS_PHY_ENTITY;\n\n\ttypedef struct _CSMI_SAS_PHY_INFO\n\t{\n\t\tUCHAR bNumberOfPhys;\n\t\tUCHAR bReserved[3];\n\t\tCSMI_SAS_PHY_ENTITY Phy[32];\n\t} CSMI_SAS_PHY_INFO, *PCSMI_SAS_PHY_INFO;\n\n\ttypedef struct _CSMI_SAS_PHY_INFO_BUFFER\n\t{\n\t\tIOCTL_HEADER IoctlHeader;\n\t\tCSMI_SAS_PHY_INFO Information;\n\t} CSMI_SAS_PHY_INFO_BUFFER, *PCSMI_SAS_PHY_INFO_BUFFER;\n\n\ttypedef struct _CSMI_SAS_STP_PASSTHRU\n\t{\n\t\tUCHAR bPhyIdentifier;\n\t\tUCHAR bPortIdentifier;\n\t\tUCHAR bConnectionRate;\n\t\tUCHAR bReserved;\n\t\tUCHAR bDestinationSASAddress[8];\n\t\tUCHAR bReserved2[4];\n\t\tUCHAR bCommandFIS[20];\n\t\tULONG uFlags;\n\t\tULONG uDataLength;\n\t} CSMI_SAS_STP_PASSTHRU, *PCSMI_SAS_STP_PASSTHRU;\n\t\n\ttypedef struct _CSMI_SAS_STP_PASSTHRU_STATUS\n\t{\n\t\tUCHAR bConnectionStatus;\n\t\tUCHAR bReserved[3];\n\t\tUCHAR bStatusFIS[20];\n\t\tULONG uSCR[16];\n\t\tULONG uDataBytes;\n\t} CSMI_SAS_STP_PASSTHRU_STATUS, *PCSMI_SAS_STP_PASSTHRU_STATUS;\n\t\n\ttypedef struct _CSMI_SAS_STP_PASSTHRU_BUFFER\n\t{\n\t\tSRB_IO_CONTROL IoctlHeader;\n\t\tCSMI_SAS_STP_PASSTHRU Parameters;\n\t\tCSMI_SAS_STP_PASSTHRU_STATUS Status;\n\t\tUCHAR bDataBuffer[1];\n\t} CSMI_SAS_STP_PASSTHRU_BUFFER, *PCSMI_SAS_STP_PASSTHRU_BUFFER;\n\n// CC_CSMI_SAS_RAID_INFO\n\n\ttypedef struct _CSMI_SAS_RAID_INFO\n\t{\n\t\tUINT uNumRaidSets;\n\t\tUINT uMaxDrivesPerSet;\n\t\tUINT uMaxRaidSets;\n\t\tUCHAR  bMaxRaidTypes;\n\t\tUCHAR  bReservedByteFields[7];\n\t\tstruct\n\t\t{\n\t\t\tUINT uLowPart;\n\t\t\tUINT uHighPart;\n\t\t} ulMinRaidSetBlocks;\n\t\tstruct\n\t\t{\n\t\t\tUINT uLowPart;\n\t\t\tUINT uHighPart;\n\t\t} ulMaxRaidSetBlocks;\n\t\tUINT uMaxPhysicalDrives;\n\t\tUINT uMaxExtents;\n\t\tUINT uMaxModules;\n\t\tUINT uMaxTransformationMemory;\n\t\tUINT uChangeCount;\n\t\tUCHAR  bReserved[44];\n\t} CSMI_SAS_RAID_INFO, *PCSMI_SAS_RAID_INFO;\n\n\ttypedef struct _CSMI_SAS_RAID_INFO_BUFFER\n\t{\n\t\tIOCTL_HEADER IoctlHeader;\n\t\tCSMI_SAS_RAID_INFO Information;\n\t} CSMI_SAS_RAID_INFO_BUFFER, *PCSMI_SAS_RAID_INFO_BUFFER;\n\n// CC_CSMI_SAS_GET_RAID_CONFIG\n\n\ttypedef struct _CSMI_SAS_RAID_DRIVES\n\t{\n\t\tUCHAR  bModel[40];\n\t\tUCHAR  bFirmware[8];\n\t\tUCHAR  bSerialNumber[40];\n\t\tUCHAR  bSASAddress[8];\n\t\tUCHAR  bSASLun[8];\n\t\tUCHAR  bDriveStatus;\n\t\tUCHAR  bDriveUsage;\n\t\tUSHORT usBlockSize;\n\t\tUCHAR  bDriveType;\n\t\tUCHAR  bReserved[15];\n\t\tUINT uDriveIndex;\n\t   struct\n\t   {\n\t\t  UINT uLowPart;\n\t\t  UINT uHighPart;\n\t   } ulTotalUserBlocks;\n\t} CSMI_SAS_RAID_DRIVES,\n\t  *PCSMI_SAS_RAID_DRIVES;\n\ntypedef struct _CSMI_SAS_RAID_DEVICE_ID {\n   UCHAR  bDeviceIdentificationVPDPage[1];\n} CSMI_SAS_RAID_DEVICE_ID,\n  *PCSMI_SAS_RAID_DEVICE_ID;\n\ntypedef struct _CSMI_SAS_RAID_SET_ADDITIONAL_DATA {\n   UCHAR  bLabel[16];\n   UCHAR  bRaidSetLun[8];\n   UCHAR  bWriteProtection;\n   UCHAR  bCacheSetting;\n   UCHAR  bCacheRatio;\n   USHORT usBlockSize;\n   UCHAR  bReservedBytes[11];\n   struct\n   {\n\t  UINT uLowPart;\n\t  UINT uHighPart;\n   } ulRaidSetExtentOffset;\n   struct\n   {\n\t  UINT uLowPart;\n\t  UINT uHighPart;\n   } ulRaidSetBlocks;\n   UINT uStripeSizeInBlocks;\n   UINT uSectorsPerTrack;\n   UCHAR  bApplicationScratchPad[16];\n   UINT uNumberOfHeads;\n   UINT uNumberOfTracks;\n   UCHAR  bReserved[24];\n} CSMI_SAS_RAID_SET_ADDITIONAL_DATA,\n  *PCSMI_SAS_RAID_SET_ADDITIONAL_DATA;\n\ntypedef struct _CSMI_SAS_RAID_CONFIG {\n   UINT uRaidSetIndex;\n   UINT uCapacity;\n   UINT uStripeSize;\n   UCHAR  bRaidType;\n   UCHAR  bStatus;\n   UCHAR  bInformation;\n   UCHAR  bDriveCount;\n   UCHAR  bDataType;\n   UCHAR  bReserved[11];\n   UINT uFailureCode;\n   UINT uChangeCount;\n   union {\n\t  CSMI_SAS_RAID_DRIVES Drives[1];\n\t  CSMI_SAS_RAID_DEVICE_ID DeviceId[1];\n\t  CSMI_SAS_RAID_SET_ADDITIONAL_DATA Data[1];\n   };\n} CSMI_SAS_RAID_CONFIG,\n   *PCSMI_SAS_RAID_CONFIG;\n\ntypedef struct _CSMI_SAS_RAID_CONFIG_BUFFER {\n   IOCTL_HEADER IoctlHeader;\n   CSMI_SAS_RAID_CONFIG Configuration;\n} CSMI_SAS_RAID_CONFIG_BUFFER,\n  *PCSMI_SAS_RAID_CONFIG_BUFFER;\n\n#pragma pack()\n\n//////////////////////////////////////////////////////////////////\n// for Intel RST NVMe\n//////////////////////////////////////////////////////////////////\n#pragma pack(push, 1)\n\ntypedef union\n{\n\tstruct\n\t{\n\t\tULONG Opcode : 8;\n\t\tULONG FUSE : 2;\n\t\tULONG _Rsvd : 4;\n\t\tULONG PSDT : 2;\n\t\tULONG CID : 16;\n\t} DUMMYSTRUCTNAME;\n\tULONG AsDWord;\n} NVME_CDW0, * PNVME_CDW0;\n\n// NVMe Command Format\n// See NVMe specification 1.3c Section 4.2, Figure 10\ntypedef union\n{\n\tstruct\n\t{\n\t\tULONG   CNS : 2;\n\t\tULONG   _Rsvd : 30;\n\t} DUMMYSTRUCTNAME;\n\tULONG AsDWord;\n} NVME_IDENTIFY_CDW10, * PNVME_IDENTIFY_CDW10;\n\n// NVMe Specification < 1.3\ntypedef union\n{\n\tstruct\n\t{\n\t\tULONG   LID : 8;\n\t\tULONG   _Rsvd1 : 8;\n\t\tULONG   NUMD : 12;\n\t\tULONG   _Rsvd2 : 4;\n\t} DUMMYSTRUCTNAME;\n\tULONG   AsDWord;\n} NVME_GET_LOG_PAGE_CDW10, * PNVME_GET_LOG_PAGE_CDW10;\n\n// NVMe Specification >= 1.3\ntypedef union\n{\n\tstruct\n\t{\n\t\tULONG   LID : 8;\n\t\tULONG   LSP : 4;\n\t\tULONG   Reserved0 : 3;\n\t\tULONG   RAE : 1;\n\t\tULONG   NUMDL : 16;\n\t} DUMMYSTRUCTNAME;\n\tULONG   AsDWord;\n} NVME_GET_LOG_PAGE_CDW10_V13, * PNVME_GET_LOG_PAGE_CDW10_V13;\n\ntypedef struct\n{\n\t// Common fields for all commands\n\tNVME_CDW0           CDW0;\n\n\tULONG               NSID;\n\tULONG               _Rsvd[2];\n\tULONGLONG           MPTR;\n\tULONGLONG           PRP1;\n\tULONGLONG           PRP2;\n\n\t// Command independent fields from CDW10 to CDW15\n\tunion\n\t{\n\t\t// Admin Command: Identify (6)\n\t\tstruct\n\t\t{\n\t\t\tNVME_IDENTIFY_CDW10 CDW10;\n\t\t\tULONG   CDW11;\n\t\t\tULONG   CDW12;\n\t\t\tULONG   CDW13;\n\t\t\tULONG   CDW14;\n\t\t\tULONG   CDW15;\n\t\t} IDENTIFY;\n\n\t\t// Admin Command: Get Log Page (2)\n\t\tstruct\n\t\t{\n\t\t\tNVME_GET_LOG_PAGE_CDW10 CDW10;\n\t\t\t//NVME_GET_LOG_PAGE_CDW10_V13 CDW10;\n\t\t\tULONG   CDW11;\n\t\t\tULONG   CDW12;\n\t\t\tULONG   CDW13;\n\t\t\tULONG   CDW14;\n\t\t\tULONG   CDW15;\n\t\t} GET_LOG_PAGE;\n\t} u;\n} NVME_CMD, * PNVME_CMD;\n\ntypedef struct _INTEL_NVME_PAYLOAD\n{\n\tBYTE    Version;        // 0x001C\n\tBYTE    PathId;         // 0x001D\n\tBYTE    TargetID;       // 0x001E\n\tBYTE    Lun;            // 0x001F\n\tNVME_CMD Cmd;           // 0x0020 ~ 0x005F\n\tDWORD   CplEntry[4];    // 0x0060 ~ 0x006F\n\tDWORD   QueueId;        // 0x0070 ~ 0x0073\n\tDWORD   ParamBufLen;    // 0x0074\n\tDWORD   ReturnBufferLen;// 0x0078\n\tBYTE    __rsvd2[0x28];  // 0x007C ~ 0xA3\n} INTEL_NVME_PAYLOAD, * PINTEL_NVME_PAYLOAD;\n\ntypedef struct _INTEL_NVME_PASS_THROUGH\n{\n\tSRB_IO_CONTROL SRB;     // 0x0000 ~ 0x001B\n\tINTEL_NVME_PAYLOAD Payload;\n\tBYTE DataBuffer[0x1000];\n} INTEL_NVME_PASS_THROUGH, * PINTEL_NVME_PASS_THROUGH;\n#pragma pack(pop)\n\n#define IOCTL_INTEL_NVME_PASS_THROUGH CTL_CODE(0xf000, 0xA02, METHOD_BUFFERED, FILE_ANY_ACCESS);\n\n//////////////////////////////////////////////////////////////////\n// for MegaRAID SAS\n//////////////////////////////////////////////////////////////////\n#pragma pack(push, 1)\n\n#define MAX_SYS_PDS               240\n\nstruct MEGARAID_PASS_THROUGH\n{\n\tUCHAR Cmd;\n\tUCHAR SenseLength;\n\tUCHAR CmdStatus;\n\tUCHAR ScsiStatus;\n\n\tUCHAR TargetId;\n\tUCHAR Lun;\n\tUCHAR CdbLength;\n\tUCHAR SenseInfoLength;\n\n\tULONG Context;\n\tULONG Padding0;\n\n\tUSHORT Flags;\n\tUSHORT TimeOutValue;\n\tULONG DataTransferLength;\n\n\tULONG SenseInfoOffsetLo;\n\tULONG SenseInfoOffsetHi;\n\n\tUCHAR Cdb[16];\n};\n\nstruct MEGARAID_PASS_THROUGH_IOCTL\n{\n\tSRB_IO_CONTROL    SrbIoCtrl;\n\tMEGARAID_PASS_THROUGH Mpt;\n\tUCHAR             SenseBuf[112];\n\tUCHAR             DataBuf[4096];\n};\n\nstruct MEGARAID_DCOMD\n{\n\tUCHAR Cmd;\n\tUCHAR Reserved0;\n\tUCHAR CmdStatus;\n\tUCHAR Reserved1[4];\n\tUCHAR SenseInfoLength;\n\n\tULONG Context;\n\tULONG Padding0;\n\n\tUSHORT Flags;\n\tUSHORT TimeOutValue;\n\n\tULONG DataTransferLength;\n\tULONG Opcode;\n\n\tUCHAR Mbox[12];\n};\n\nstruct MEGARAID_DCOMD_IOCTL\n{\n\tSRB_IO_CONTROL SrbIoCtrl;\n\tMEGARAID_DCOMD Mpt;\n\tUCHAR          SenseBuf[120];\n\tUCHAR          DataBuf[4096];\n};\n\nstruct MEGARAID_PHYSICAL_DRIVE_ADDRESS\n{\n\tUSHORT DeviceId;\n\tUSHORT EnclDeviceId;\n\tUCHAR  EnclIndex;\n\tUCHAR  SlotNumber;\n\tUCHAR  ScsiDevType;\n\tUCHAR  ConnectPortBitmap;\n\tUINT64 SasAddr[2];\n};\n\nstruct MEGARAID_PHYSICAL_DRIVE_LIST\n{\n\tULONG Size;\n\tULONG Count;\n\tMEGARAID_PHYSICAL_DRIVE_ADDRESS Addr[MAX_SYS_PDS];\n};\n#pragma pack(pop)\n\n#define MFI_CMD_PD_SCSI_IO        0x04\n#define MFI_CMD_DCMD              0x05\n\n#define MFI_STAT_OK               0x00\n\n#define MFI_DCMD_PD_GET_LIST      0x02010000\n\n#define MFI_MBOX_SIZE             12\n#define MFI_FRAME_DIR_NONE        0x0000\n#define MFI_FRAME_DIR_WRITE       0x0008\n#define MFI_FRAME_DIR_READ        0x0010\n#define MFI_FRAME_DIR_BOTH        0x0018\n\n\npublic:\n\tDWORD UpdateSmartInfo(DWORD index);\n\tBOOL UpdateIdInfo(DWORD index);\n\tBYTE GetAamValue(DWORD index);\n\tBYTE GetApmValue(DWORD index);\n\tBOOL EnableAam(DWORD index, BYTE param);\n\tBOOL EnableApm(DWORD index, BYTE param);\n\tBOOL DisableAam(DWORD index);\n\tBOOL DisableApm(DWORD index);\n\tBYTE GetRecommendAamValue(DWORD index);\n\tBYTE GetRecommendApmValue(DWORD index);\n\n\tVOID Init(BOOL useWmi, BOOL advancedDiskSearch, PBOOL flagChangeDisk, BOOL workaroundHD204UI, BOOL workaroundAdataSsd, BOOL flagHideNoSmartDisk, BOOL flagSortDriveLetter);\n\tBOOL MeasuredTimeUnit();\n\tDWORD GetPowerOnHours(DWORD rawValue, DWORD timeUnitType);\n\tDWORD GetPowerOnHoursEx(DWORD index, DWORD timeUnitType);\n\n\tVOID SetAtaPassThroughSmart(BOOL flag);\n\n\tstruct DISK_POSITION\n\t{\n\t\tINT\t\t\t\t\tPhysicalDriveId;\n\t\tINT\t\t\t\t\tScsiPort;\n\t\tINT\t\t\t\t\tScsiTargetId;\n\t\tCSMI_SAS_PHY_ENTITY sasPhyEntity;\n\t};\n\n\tunion IDENTIFY_DEVICE\n\t{\n\t\tATA_IDENTIFY_DEVICE\t A;\n\t\tNVME_IDENTIFY_DEVICE N;\n\t\tBIN_IDENTIFY_DEVICE\t B;\n\t};\n\n\tstruct ATA_SMART_INFO\n\t{\n\t\tIDENTIFY_DEVICE\t\tIdentifyDevice{};\n\t\tBYTE\t\t\t\tSmartReadData[512]{};\n\t\tBYTE\t\t\t\tSmartReadThreshold[512]{};\n\t\tSMART_ATTRIBUTE\t\tAttribute[MAX_ATTRIBUTE]{};\n\t\tSMART_THRESHOLD\t\tThreshold[MAX_ATTRIBUTE]{};\n\n\t\tBOOL\t\t\t\tIsSmartEnabled{};\n\t\tBOOL\t\t\t\tIsIdInfoIncorrect{};\n\t\tBOOL\t\t\t\tIsSmartCorrect{};\n\t\tBOOL\t\t\t\tIsThresholdCorrect{};\n\t\tBOOL\t\t\t\tIsCheckSumError{};\n\t\tBOOL\t\t\t\tIsWord88{};\n\t\tBOOL\t\t\t\tIsWord64_76{};\n\t\tBOOL\t\t\t\tIsRawValues8{};\n\t\tBOOL\t\t\t\tIsRawValues7{};\n\t\tBOOL\t\t\t\tIs9126MB{};\n\t\tBOOL\t\t\t\tIsThresholdBug{};\n\n\t\tBOOL\t\t\t\tIsSmartSupported{};\n\t\tBOOL\t\t\t\tIsLba48Supported{};\n\t\tBOOL\t\t\t\tIsAamSupported{};\n\t\tBOOL\t\t\t\tIsApmSupported{};\n\t\tBOOL\t\t\t\tIsAamEnabled{};\n\t\tBOOL\t\t\t\tIsApmEnabled{};\n\t\tBOOL\t\t\t\tIsNcqSupported{};\n\t\tBOOL\t\t\t\tIsNvCacheSupported{};\n\t\tBOOL\t\t\t\tIsDeviceSleepSupported{};\n\t\tBOOL\t\t\t\tIsStreamingSupported{};\n\t\tBOOL\t\t\t\tIsGplSupported{};\n\t\tBOOL\t\t\t\tIsMaxtorMinute{};\n\t\tBOOL\t\t\t\tIsSsd{};\n\t\tBOOL\t\t\t\tIsTrimSupported{};\n\t\tBOOL\t\t\t\tIsVolatileWriteCachePresent{};\n\n\t\tBOOL\t\t\t\tIsNVMe{};\n\t\tBOOL\t\t\t\tIsUasp{};\n\n\t\tINT\t\t\t\t\tPhysicalDriveId{};\n\t\tINT\t\t\t\t\tScsiPort{};\n\t\tINT\t\t\t\t\tScsiTargetId{};\n\t\tINT\t\t\t\t\tScsiBus{};\n\t\tINT\t\t\t\t\tSiliconImageType{};\n//\t\tINT\t\t\t\t\tAccessType;\n\n\t\tDWORD\t\t\t\tTotalDiskSize{};\n\t\tDWORD\t\t\t\tCylinder{};\n\t\tDWORD\t\t\t\tHead{};\n\t\tDWORD\t\t\t\tSector{};\n\t\tDWORD\t\t\t\tSector28{};\n\t\tULONGLONG\t\t\tSector48{};\n\t\tULONGLONG\t\t\tNumberOfSectors{};\n\t\tDWORD\t\t\t\tDiskSizeChs{};\n\t\tDWORD\t\t\t\tDiskSizeLba28{};\n\t\tDWORD\t\t\t\tDiskSizeLba48{};\n\t\tDWORD\t\t\t\tLogicalSectorSize{};\n\t\tDWORD\t\t\t\tPhysicalSectorSize{};\n\t\tDWORD\t\t\t\tDiskSizeWmi{};\n\t\tDWORD\t\t\t\tBufferSize{};\n\t\tULONGLONG\t\t\tNvCacheSize{};\n\t\tDWORD\t\t\t\tTransferModeType{};\n\t\tDWORD\t\t\t\tDetectedTimeUnitType{};\n\t\tDWORD\t\t\t\tMeasuredTimeUnitType{};\n\t\tDWORD\t\t\t\tAttributeCount{};\n\t\tINT\t\t\t\t\tDetectedPowerOnHours{};\n\t\tINT\t\t\t\t\tMeasuredPowerOnHours{};\n\t\tINT\t\t\t\t\tPowerOnRawValue{};\n\t\tINT\t\t\t\t\tPowerOnStartRawValue{};\n\t\tDWORD\t\t\t\tPowerOnCount{};\n\t\tINT\t\t\t\t\tTemperature{};\n\t\tdouble\t\t\t\tTemperatureMultiplier{};\n\t\tDWORD\t\t\t\tNominalMediaRotationRate{};\n//\t\tdouble\t\t\t\tSpeed;\n\t\tINT\t\t\t\t\tHostWrites{};\n\t\tINT\t\t\t\t\tHostReads{};\n\t\tINT\t\t\t\t\tGBytesErased{};\n\t\tINT\t\t\t\t\tNandWrites{};\n\t\tINT\t\t\t\t\tWearLevelingCount{};\n\n//\t\tINT\t\t\t\t\tPlextorNandWritesUnit;\n\n\t\tINT\t\t\t\t\tLife{};\n\t\tBOOL\t\t\t\tFlagLifeNoReport{};\n\t\tBOOL\t\t\t\tFlagLifeRawValue{};\n\t\tBOOL\t\t\t\tFlagLifeRawValueIncrement{};\n\t\tBOOL\t\t\t\tFlagLifeSanDiskUsbMemory{};\n\t\tBOOL\t\t\t\tFlagLifeSanDisk0_1{};\n\t\tBOOL\t\t\t\tFlagLifeSanDisk1{};\n\t\tBOOL\t\t\t\tFlagLifeSanDiskLenovo{};\n\t\tBOOL\t\t\t\tFlagLifeSanDiskCloud{};\n\n\t\tDWORD\t\t\t\tMajor{};\n\t\tDWORD\t\t\t\tMinor{};\n\n\t\tDWORD\t\t\t\tDiskStatus{};\n\t\tDWORD\t\t\t\tDriveLetterMap{};\n\t\t// \n\t\tINT \t\t\t\tAlarmTemperature{};\n\t\tBOOL\t\t\t\tAlarmHealthStatus{};\n\n\t\tINTERFACE_TYPE\t\tInterfaceType{};\n\t\tCOMMAND_TYPE\t\tCommandType{};\n\t\tHOST_READS_WRITES_UNIT HostReadsWritesUnit{};\n\n\t\tDWORD\t\t\t\tDiskVendorId{};\n\t\tDWORD\t\t\t\tUsbVendorId{};\n\t\tDWORD\t\t\t\tUsbProductId{};\n\t\tBYTE\t\t\t\tTarget{};\n\n\t\tWORD\t\t\t\tThreshold05{};\n\t\tWORD\t\t\t\tThresholdC5{};\n\t\tWORD\t\t\t\tThresholdC6{};\n\t\tWORD\t\t\t\tThresholdFF{};\n\n\t\tCSMI_SAS_PHY_ENTITY sasPhyEntity{};\n\n\t\tCString\t\t\t\tSerialNumber;\n\t\tCString\t\t\t\tSerialNumberReverse;\n\t\tCString\t\t\t\tFirmwareRev;\n\t\tCString\t\t\t\tFirmwareRevReverse;\n\t\tCString\t\t\t\tModel;\n\t\tCString\t\t\t\tModelReverse;\n\t\tCString\t\t\t\tModelWmi;\n\t\tCString\t\t\t\tModelSerial;\n\t\tCString\t\t\t\tDriveMap;\n\t\tCString\t\t\t\tMaxTransferMode;\n\t\tCString\t\t\t\tCurrentTransferMode;\n\t\tCString\t\t\t\tMajorVersion;\n\t\tCString\t\t\t\tMinorVersion;\n\t\tCString\t\t\t\tInterface;\n\t\tCString\t\t\t\tEnclosure;\n\t\tCString\t\t\t\tCommandTypeString;\n\t\tCString\t\t\t\tSsdVendorString;\n\t\tCString\t\t\t\tDeviceNominalFormFactor;\n\t\tCString\t\t\t\tPnpDeviceId;\n\n\t\tCString\t\t\t\tSmartKeyName;\n\t};\n\n\tstruct EXTERNAL_DISK_INFO\n\t{\n\t\tCString Enclosure;\n\t\tDWORD\tUsbVendorId{};\n\t\tDWORD\tUsbProductId{};\n\t};\n\n\tCArray<ATA_SMART_INFO, ATA_SMART_INFO> vars;\n\tCArray<EXTERNAL_DISK_INFO, EXTERNAL_DISK_INFO> externals;\n\n\tCStringArray m_IdeController;\n\tCStringArray m_ScsiController;\n\tCStringArray m_UsbController;\n\tCString m_ControllerMap;\n\tCStringArray m_BlackIdeController;\n\tCStringArray m_BlackScsiController;\n\tCStringArray m_SiliconImageController;\n\tCStringArray m_UASPController;\n\tCArray<DWORD, DWORD> m_SiliconImageControllerType;\n\tCArray<INT, INT> m_BlackPhysicalDrive;\n\n\tBOOL IsAdvancedDiskSearch = FALSE;\n\tBOOL IsEnabledWmi = FALSE;\n\n\tBOOL IsWorkaroundHD204UI = FALSE;\n\tBOOL IsWorkaroundAdataSsd = FALSE;\n\n\tULONGLONG MeasuredGetTickCount = 0;\n\n\tBOOL FlagNvidiaController = FALSE;\n\tBOOL FlagMarvellController = FALSE;\n\tBOOL FlagUsbSat = FALSE;\n\tBOOL FlagUsbSunplus = FALSE;\n\tBOOL FlagUsbIodata = FALSE;\n\tBOOL FlagUsbLogitec = FALSE;\n\tBOOL FlagUsbProlific = FALSE;\n\tBOOL FlagUsbJmicron = FALSE;\n\tBOOL FlagUsbCypress = FALSE;\n\tBOOL FlagUsbMemory = FALSE;\n//\tBOOL FlagUsbSat16 = FALSE;\n\tBOOL FlagUsbNVMeJMicron3 = FALSE;\n\tBOOL FlagUsbNVMeJMicron = FALSE;\n\tBOOL FlagUsbNVMeASMedia = FALSE;\n\tBOOL FlagUsbNVMeRealtek = FALSE;\n\tBOOL FlagMegaRAID = FALSE;\n\tBOOL FlagIntelVROC = FALSE;\n\tBOOL FlagUsbASM1352R = FALSE;\n\tBOOL FlagUsbRealtek9220DP = FALSE;\n\tBOOL FlagAMD_RC2 = FALSE;// +AMD_RC2\n#ifdef JMICRON_USB_RAID_SUPPORT\n\tBOOL FlagUsbJMS56X = FALSE;\n\tBOOL FlagUsbJMB39X = FALSE;\n\tBOOL FlagUsbJMS586_20 = FALSE;\n\tBOOL FlagUsbJMS586_40 = FALSE;\n#endif\n\tBOOL FlagNoWakeUp = FALSE;// +M 20211216\n\n\tDWORD CsmiType = 0;\n\n\tDWORD CheckDiskStatus(DWORD index);\n\nprotected:\n\n\tHMODULE hJMS56X{};\n\tHMODULE hJMB39X{};\n\tHMODULE hJMS586_20{};\n\tHMODULE hJMS586_40{};\n\t// 2023/02/24 Compatible with SIV\n\tHANDLE hMutexJMicron{};\n\tHANDLE CreateWorldMutex(CONST TCHAR* name);\n\tvoid AcquireMutexJMicron();\n\tvoid ReleaseMutexJMicron();\n\n\tCString m_SerialNumberA_Z[26];\n\tBOOL m_bAtaPassThrough;\n\tBOOL m_bAtaPassThroughSmart;\n\tBOOL m_bNVMeStorageQuery;\n\n\tBOOL GetDiskInfo(INT physicalDriveId, INT scsiPort, INT scsiTargetId, INTERFACE_TYPE interfaceType, COMMAND_TYPE commandType, VENDOR_ID vendorId, DWORD productId = 0, INT scsiBus = -1, DWORD siliconImageId = 0, BOOL FlagNvidiaController = 0, BOOL FlagMarvellController = 0, CString pnpDeviceId = _T(\"\"), BOOL FlagNVMe = FALSE, BOOL FlagUasp = FALSE);\n\tBOOL AddDisk(INT PhysicalDriveId, INT ScsiPort, INT scsiTargetId, INT scsiBus, BYTE target, COMMAND_TYPE commandType, IDENTIFY_DEVICE* identify, INT siliconImageType = -1, PCSMI_SAS_PHY_ENTITY sasPhyEntity = NULL, CString pnpDeviceId = _T(\"\")\n\t\t, DWORD TotalDiskSize = 0// +AMD_RC2\n\t);\n\tDWORD CheckSmartAttributeUpdate(DWORD index, SMART_ATTRIBUTE* pre, SMART_ATTRIBUTE* cur);\n\n\tBOOL CheckSmartAttributeCorrect(ATA_SMART_INFO* asi1, ATA_SMART_INFO* asi2);\n\n\tVOID WakeUp(INT physicalDriveId);\n//\tVOID InitAtaInfo();\n//\tVOID InitAtaInfoByWmi();\n//\tVOID InitStruct();\n\tVOID ChangeByteOrder(PCHAR str, DWORD length);\n\tBOOL CheckAsciiStringError(PCHAR str, DWORD length);\n\tHANDLE GetIoCtrlHandle(INT/*BYTE*/ index);\n\tHANDLE GetIoCtrlHandle(INT scsiPort, DWORD siliconImageType);\n\tHANDLE GetIoCtrlHandleCsmi(INT scsiPort);\n\tHANDLE GetIoCtrlHandleMegaRAID(INT scsiPort);\n\tBOOL SendAtaCommand(DWORD i, BYTE main, BYTE sub, BYTE param);\n\n\tBOOL DoIdentifyDevicePd(INT physicalDriveId, BYTE target, IDENTIFY_DEVICE* identify);\n\tBOOL GetSmartAttributePd(INT physicalDriveId, BYTE target, ATA_SMART_INFO* asi);\n\tBOOL GetSmartThresholdPd(INT physicalDriveId, BYTE target, ATA_SMART_INFO* asi);\n\tBOOL ControlSmartStatusPd(INT physicalDriveId, BYTE target, BYTE command);\n\tBOOL SendAtaCommandPd(INT physicalDriveId, BYTE target, BYTE main, BYTE sub, BYTE param, PBYTE data, DWORD dataSize);\n\tBOOL ReadLogExtPd(INT physicalDriveId, BYTE target, BYTE logAddress, BYTE logPage, PBYTE data, DWORD dataSize);\n\n\tBOOL AddDiskNVMe(INT PhysicalDriveId, INT ScsiPort, INT scsiTargetId, INT scsiBus, BYTE target, COMMAND_TYPE commandType, \n\t\tIDENTIFY_DEVICE* identify, DWORD* diskSize = NULL, CString pnpDeviceId = _T(\"\"), NVME_PORT_20* nvmePort20 = NULL, NVME_PORT_40* nvmePort40 = NULL, NVME_ID* nvmeId = NULL\n\t);\n\n\tBOOL DoIdentifyDeviceNVMeJMicron(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* identify, BOOL flagUSB2mode);\n\tBOOL GetSmartAttributeNVMeJMicron(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\n\tBOOL DoIdentifyDeviceNVMeASMedia(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* identify);\n\tBOOL GetSmartAttributeNVMeASMedia(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\t\n\tBOOL DoIdentifyDeviceNVMeRealtek(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data);\n\tBOOL GetSmartAttributeNVMeRealtek(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\n\tBOOL GetSmartAttributeNVMeRealtek9220DP(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\tBOOL RealtekRAIDMode(INT physicalDriveId, INT scsiPort, INT scsiTargetId);\n\tBOOL RealtekSwitchMode(INT physicalDriveId, INT scsiPort, INT scsiTargetId, INT dir, INT mode);\n\tBOOL isRealtekProduct(INT physicalDriveId, INT scsiPort, INT scsiTargetId);\n\n\tBOOL DoIdentifyDeviceNVMeSamsung(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* identify);\n\tBOOL GetSmartAttributeNVMeSamsung(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\tBOOL GetSmartAttributeNVMeSamsung951(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\n\tCString GetScsiPath(const TCHAR* Path);\n\tBOOL DoIdentifyDeviceNVMeIntel(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data, DWORD* diskSize);\n\tBOOL GetSmartAttributeNVMeIntel(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\n\tBOOL GetScsiAddress(const TCHAR* Path, BYTE* PortNumber, BYTE* PathId, BYTE* TargetId, BYTE* Lun);\n\tBOOL DoIdentifyDeviceNVMeIntelRst(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data, DWORD* diskSize);\n\tBOOL GetSmartAttributeNVMeIntelRst(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\n\tBOOL DoIdentifyDeviceNVMeIntelVroc(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data, DWORD* diskSize);\n\tBOOL GetSmartAttributeNVMeIntelVroc(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\n\tBOOL DoIdentifyDeviceNVMeStorageQuery(INT physicalDriveId, INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* data, DWORD* diskSize);\n\tBOOL GetSmartAttributeNVMeStorageQuery(INT physicalDriveId, INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\n\tBOOL DoIdentifyDeviceScsi(INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* identify);\n\tBOOL GetSmartAttributeScsi(INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\tBOOL GetSmartThresholdScsi(INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\tBOOL ControlSmartStatusScsi(INT scsiPort, INT scsiTargetId, BYTE command);\n\tBOOL SendAtaCommandScsi(INT scsiPort, INT scsiTargetId, BYTE main, BYTE sub, BYTE param);\n\n\tBOOL DoIdentifyDeviceSat(INT physicalDriveId, BYTE target, IDENTIFY_DEVICE* identify, COMMAND_TYPE commandType);\n\tBOOL GetSmartAttributeSat(INT physicalDriveId, BYTE target, ATA_SMART_INFO* asi);\n\tBOOL GetSmartThresholdSat(INT physicalDriveId, BYTE target, ATA_SMART_INFO* asi);\n\tBOOL ControlSmartStatusSat(INT physicalDriveId, BYTE target, BYTE command, COMMAND_TYPE commandType);\n\tBOOL SendAtaCommandSat(INT physicalDriveId, BYTE target, BYTE main, BYTE sub, BYTE param, COMMAND_TYPE commandType);\n\tBOOL ReadLogExtSat(INT physicalDriveId, BYTE target, BYTE logAddress, BYTE logPage, PBYTE data, DWORD dataSize, COMMAND_TYPE type);\n\n\tBOOL DoIdentifyDeviceSi(INT physicalDriveId, INT scsiPort, INT scsiBus, DWORD siliconImageId, IDENTIFY_DEVICE* identify);\n\tBOOL GetSmartAttributeSi(INT physicalDriveId, ATA_SMART_INFO* asi);\n\tBOOL GetSmartThresholdSi(INT physicalDriveId, ATA_SMART_INFO* asi);\n\n\tBOOL GetSmartAttributeWmi(ATA_SMART_INFO* asi);\n\tBOOL GetSmartThresholdWmi(ATA_SMART_INFO* asi);\n\tBOOL GetSmartInfoWmi(DWORD type, ATA_SMART_INFO* asi);\n\n\tBOOL AddDiskCsmi(INT scsiPort);\n//\tBOOL GetPhyInfo(INT scsiPort, CSMI_SAS_PHY_INFO & phyInfo);\n\tBOOL CsmiIoctl(HANDLE hHandle, UINT code, SRB_IO_CONTROL *csmiBuf, UINT csmiBufSize);\n\tBOOL DoIdentifyDeviceCsmi(INT scsiPort, PCSMI_SAS_PHY_ENTITY sasPhyEntity, IDENTIFY_DEVICE* identify);\n\tBOOL GetSmartAttributeCsmi(INT scsiPort, PCSMI_SAS_PHY_ENTITY sasPhyEntity, ATA_SMART_INFO* asi);\n\tBOOL GetSmartThresholdCsmi(INT scsiPort, PCSMI_SAS_PHY_ENTITY sasPhyEntity, ATA_SMART_INFO* asi);\n\tBOOL ControlSmartStatusCsmi(INT scsiPort, PCSMI_SAS_PHY_ENTITY sasPhyEntity, BYTE command);\n\tBOOL SendAtaCommandCsmi(INT scsiPort, PCSMI_SAS_PHY_ENTITY sasPhyEntity, BYTE main, BYTE sub, BYTE param, PBYTE data, DWORD dataSize);\n\n\tBOOL AddDiskMegaRAID(INT scsiPort);\n\tBOOL DoIdentifyDeviceMegaRAID(INT scsiPort, INT scsiTargetId, IDENTIFY_DEVICE* identify);\n\tBOOL GetSmartAttributeMegaRAID(INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\tBOOL GetSmartThresholdMegaRAID(INT scsiPort, INT scsiTargetId, ATA_SMART_INFO* asi);\n\tBOOL ControlSmartStatusMegaRAID(INT scsiPort, INT scsiTargetId, BYTE command);\n\tBOOL SendAtaCommandMegaRAID(INT scsiPort, INT scsiTargetId, BYTE main, BYTE sub, BYTE param);\n\tBOOL SendDCommandMegaRAID(HANDLE hHandle, ULONG opcode, void* buf, size_t bufsize, BYTE* mbox, size_t mboxlen);\n\tBOOL SendPassThroughCommandMegaRAID(INT scsiPort, INT scsiTargetId, void* buf, size_t bufsize, const UCHAR Cdb[], UCHAR CdbLength);\n\n#ifdef JMICRON_USB_RAID_SUPPORT\n\tBOOL AddDiskJMS56X(INT index);\n\tBOOL DoIdentifyDeviceJMS56X(INT index, BYTE port, IDENTIFY_DEVICE* identify);\n\tBOOL GetSmartInfoJMS56X(INT index, BYTE port, ATA_SMART_INFO* asi);\n\n\tBOOL AddDiskJMB39X(INT index);\n\tBOOL DoIdentifyDeviceJMB39X(INT index, BYTE port, IDENTIFY_DEVICE* identify);\n\tBOOL GetSmartInfoJMB39X(INT index, BYTE port, ATA_SMART_INFO* asi);\n\n\tBOOL AddDiskJMS586_20(INT index);\n\tBOOL DoIdentifyDeviceJMS586_20(INT index, BYTE port, IDENTIFY_DEVICE* identify);\n\tBOOL GetSmartInfoJMS586_20(INT index, BYTE port, ATA_SMART_INFO* asi);\n\tBOOL GetNVMePortInfoJMS586_20(INT index, BYTE port, NVME_PORT_20* nvmePort);\n\tBOOL GetNVMeSmartInfoJMS586_20(INT index, BYTE port, UNION_SMART_ATTRIBUTE* smartInfo);\n\tBOOL GetSmartAttributeNVMeJMS586_20(INT index, INT port, ATA_SMART_INFO* asi);\n\n\tBOOL AddDiskJMS586_40(INT index);\n\tBOOL DoIdentifyDeviceJMS586_40(BYTE index, BYTE port, IDENTIFY_DEVICE* identify);\n\tBOOL GetSmartInfoJMS586_40(BYTE index, BYTE port, ATA_SMART_INFO* asi);\n\tBOOL GetNVMePortInfoJMS586_40(BYTE index, BYTE port, NVME_PORT_40* nvmePort);\n\tBOOL GetNVMeSmartInfoJMS586_40(BYTE index, BYTE port, UNION_SMART_ATTRIBUTE* smartInfo);\n\tBOOL GetSmartAttributeNVMeJMS586_40(BYTE index, BYTE port, ATA_SMART_INFO* asi);\n\tBOOL GetNVMeIdInfoJMS586_40(BYTE index, BYTE port, NVME_ID* nvmeId);\n\tBOOL ControllerSerialNum2IdJMS586_40(BYTE csn, BYTE* cid);\n#endif\n\n\tDWORD GetTransferMode(WORD w63, WORD w76, WORD w77, WORD w88, CString &currentTransferMode, CString &maxTransferMode, CString &Interface, INTERFACE_TYPE *interfaceType);\n\tVOID GetTransferModePCIe(CString & current, CString & max, SlotMaxCurrSpeed slotspeed);\n\tDWORD GetTimeUnitType(CString model, CString firmware, DWORD major, DWORD transferMode);\n\tDWORD GetAtaMajorVersion(WORD w80, CString &majorVersion);\n\tVOID  GetAtaMinorVersion(WORD w81, CString &minor);\n//\tDWORD GetMaxtorPowerOnHours(DWORD currentValue, DWORD rawValue);\n\n\tBOOL FillSmartData(ATA_SMART_INFO* asi);\n\tBOOL FillSmartThreshold(ATA_SMART_INFO* asi);\n\t\n\tVOID CheckSsdSupport(ATA_SMART_INFO &asi);\n\tBOOL IsSsdOld(ATA_SMART_INFO &asi);\n\tBOOL IsSsdMtron(ATA_SMART_INFO &asi);\n\tBOOL IsSsdIndilinx(ATA_SMART_INFO &asi);\n\tBOOL IsSsdJMicron60x(ATA_SMART_INFO &asi);\n\tBOOL IsSsdJMicron61x(ATA_SMART_INFO &asi);\n\tBOOL IsSsdJMicron66x(ATA_SMART_INFO& asi);\n\tBOOL IsSsdIntel(ATA_SMART_INFO &asi);\n\tBOOL IsSsdIntelDc(ATA_SMART_INFO& asi);\n\tBOOL IsSsdSamsung(ATA_SMART_INFO &asi);\n\tBOOL IsSsdSandForce(ATA_SMART_INFO &asi);\n\tBOOL IsSsdMicronMU03(ATA_SMART_INFO &asi);\n\tBOOL IsSsdMicron(ATA_SMART_INFO &asi);\n\tBOOL IsSsdOcz(ATA_SMART_INFO &asi);\n\tBOOL IsSsdSsstc(ATA_SMART_INFO &asi);\n\tBOOL IsSsdPlextor(ATA_SMART_INFO& asi);\n\tBOOL IsSsdSanDisk(ATA_SMART_INFO &asi);\n\tBOOL IsSsdKingston(ATA_SMART_INFO &asi);\n\tBOOL IsSsdCorsair(ATA_SMART_INFO& asi);\n\tBOOL IsSsdOczVector(ATA_SMART_INFO &asi);\n\tBOOL IsSsdToshiba(ATA_SMART_INFO &asi);\n\tBOOL IsSsdRealtek(ATA_SMART_INFO &asi);\n\tBOOL IsSsdSKhynix(ATA_SMART_INFO& asi);\n\tBOOL IsSsdKioxia(ATA_SMART_INFO& asi);\n\tBOOL IsSsdApacer(ATA_SMART_INFO& asi);\n\tBOOL IsSsdSiliconMotion(ATA_SMART_INFO& asi);\n\tBOOL IsSsdSiliconMotionCVC(ATA_SMART_INFO& asi);\n\tBOOL IsSsdPhison(ATA_SMART_INFO& asi);\n\tBOOL IsSsdWdc(ATA_SMART_INFO& asi);\n\tBOOL IsSsdSeagate(ATA_SMART_INFO& asi);\n\tBOOL IsSsdMarvell(ATA_SMART_INFO& asi);\n\tBOOL IsSsdMaxiotek(ATA_SMART_INFO& asi);\n\tBOOL IsSsdYmtc(ATA_SMART_INFO& asi);\n\tBOOL IsSsdScy(ATA_SMART_INFO& asi);\n\tBOOL IsSsdRecadata(ATA_SMART_INFO& asi);\n\tBOOL IsSsdGeneral(ATA_SMART_INFO& asi);\n\tBOOL IsSsdAdataIndustrial(ATA_SMART_INFO& asi);\n\t\t\n\t//\tINT CheckPlextorNandWritesUnit(ATA_SMART_INFO &asi);\n\n\tstatic int __cdecl CompareDriveLetter(const void *p1, const void *p2);\n\tstatic int __cdecl ComparePhysicalDriveId(const void* p1, const void* p2);\n\n\tCString GetModelSerial(CString &model, CString &serialNumber);\n//\tBOOL GetLifeByGpl(ATA_SMART_INFO& asi);\n\n#ifndef _M_ARM\n\t// +AMD_RC2 >>>>>>>>\n\tBOOL AddDiskAMD_RC2();\n\tBOOL DoIdentifyDeviceAMD_RC2(INT diskNum, INT* phy, DWORD* TotalDiskSize, IDENTIFY_DEVICE* data, BOOL* isSSD, BOOL* isNVME);\n\tBOOL GetSmartDataAMD_RC2(INT diskNum, ATA_SMART_INFO* asi);\n\tBOOL GetSmartThresholdAMD_RC2(INT diskNum, ATA_SMART_INFO* asi);\n\t// +AMD_RC2 <<<<<<<<\n#endif\n};\n"
        },
        {
          "name": "CompileOptions.h",
          "type": "blob",
          "size": 0.5439453125,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n//------------------------------------------------\n// Option Flags\n//------------------------------------------------\n\n// For Task Tray Icon Feature\n#define OPTION_TASK_TRAY\n\n// JMicron JMB39x/JMS56x/JMS586 support\n#define JMICRON_USB_RAID_SUPPORT\n"
        },
        {
          "name": "DHtmlDialogEx.cpp",
          "type": "blob",
          "size": 11.576171875,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"resource.h\"\n#include \"DHtmlDialogEx.h\"\n\n#include \"OsInfoFx.h\"\n\n#include <Shlwapi.h>\n#include <strsafe.h>\n\nCDHtmlDialogEx::CDHtmlDialogEx(UINT dlgResouce, UINT dlgHtml, CWnd* pParent)\n\t\t\t\t:CDHtmlDialog(dlgResouce, dlgHtml, pParent)\n{\n\tm_bShowWindow = FALSE;\n\tm_bModelessDlg = FALSE;\n\tm_ParentWnd = NULL;\n\tm_DlgWnd = NULL;\n\tm_MenuId = 0;\n\tm_hAccelerator = NULL;\n\tm_Ini[0] = '\\0';\n\n\tm_ZoomRatio = 1.0;\n\tm_ZoomType = ZoomTypeAuto;\n}\n\nCDHtmlDialogEx::~CDHtmlDialogEx()\n{\n}\n\nvoid CDHtmlDialogEx::DoDataExchange(CDataExchange* pDX)\n{\n\tCDHtmlDialog::DoDataExchange(pDX);\n}\n\nBOOL CDHtmlDialogEx::OnInitDialog()\n{\n\tCDHtmlDialog::OnInitDialog();\n\n\tm_hAccelerator = ::LoadAccelerators(AfxGetInstanceHandle(),\n\t\t                                MAKEINTRESOURCE(IDR_ACCELERATOR));\n\treturn TRUE;\n}\n\nBEGIN_MESSAGE_MAP(CDHtmlDialogEx, CDHtmlDialog)\n\tON_WM_TIMER()\nEND_MESSAGE_MAP()\n\nBEGIN_DHTML_EVENT_MAP(CDHtmlDialogEx)\nEND_DHTML_EVENT_MAP()\n\nBOOL CDHtmlDialogEx::PreTranslateMessage(MSG* pMsg) \n{\n\tif(m_hAccelerator != NULL)\n\t{\n\t\tif(::TranslateAccelerator(m_hWnd, m_hAccelerator, pMsg) != 0)\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn CDialog::PreTranslateMessage(pMsg);\n}\n\nBOOL CDHtmlDialogEx::OnAmbientProperty(COleControlSite* pSite, DISPID dispid, VARIANT* pvar)\n{\n\tif(dispid == DISPID_AMBIENT_DLCONTROL)\n\t{\n\t\tpvar->vt\t= VT_I4;\n\t\tpvar->lVal |= DLCTL_DLIMAGES;\n\n\t\treturn TRUE;\n    }\n\treturn CDHtmlDialog::OnAmbientProperty(pSite, dispid, pvar);\n}\n\n/*\nvoid CDHtmlDialogEx::ChangeAmbient(void)\n{\n    LPOLECONTROL  pOleControl = NULL;\n\n    m_pBrowserApp.QueryInterface(&pOleControl);\n    pOleControl->OnAmbientPropertyChange(DISPID_AMBIENT_DLCONTROL);\n\n    if(pOleControl)pOleControl->Release();\n}\n*/\n\nvoid CDHtmlDialogEx::OnDocumentComplete(LPDISPATCH pDisp, LPCTSTR szUrl)\n{\n\tDebugPrint(_T(\"OnDocumentComplete\"));\n\tCString cstr = szUrl;\n\tif(cstr.Find(_T(\"html\")) != -1 || cstr.Find(_T(\"dlg\")) != -1)\n\t{\n\t\tInitDialogComplete();\n\t}\n}\n\nvoid CDHtmlDialogEx::InitDialogComplete()\n{\n\tDebugPrint(_T(\"InitDialogComplete\"));\n\tUpdateData(FALSE);\n\tm_bShowWindow = TRUE;\n\tShowWindow(SW_SHOW);\n\tDebugPrint(_T(\"InitDialogComplete - once\"));\n}\n\ndouble CDHtmlDialogEx::GetZoomRatio()\n{\n\treturn m_ZoomRatio;\n}\n\n#ifndef DOCHOSTUIFLAG_DPI_AWARE\n#define DOCHOSTUIFLAG_DPI_AWARE 0x40000000\n#endif\n\nvoid CDHtmlDialogEx::EnableDpiAware()\n{\n\tif(GetIeVersion() >= 800)\n\t{\n\t\tDOCHOSTUIINFO info = { sizeof(info) };\n\t\t//info.cbSize = sizeof(info);\n\t\tGetHostInfo(&info);\n\t\tSetHostFlags(info.dwFlags | DOCHOSTUIFLAG_DIALOG | DOCHOSTUIFLAG_THEME | DOCHOSTUIFLAG_DPI_AWARE);\n\t}\n}\n\nDWORD CDHtmlDialogEx::ChangeZoomType(DWORD zoomType)\n{\n\tif(GetIeVersion() < 800)\n\t{\n\t\treturn (DWORD)-1;\n\t}\n\n\tDWORD current;\n\tVARIANT zoom;\n\tVariantInit(&zoom);\n\tzoom.vt\t= VT_I4;\n\tm_pBrowserApp->ExecWB(OLECMDID_OPTICAL_ZOOM, OLECMDEXECOPT_DODEFAULT, NULL, &zoom);\n\tcurrent = zoom.lVal;\n\n\tif(zoomType == ZoomTypeAuto)\n\t{\n\t\tif(current >= 200)\n\t\t{\n\t\t\tzoomType = ZoomType200;\n\t\t}\n\t\telse if(current >= 150)\n\t\t{\n\t\t\tzoomType = ZoomType150;\n\t\t}\n\t\telse if(current >= 125)\n\t\t{\n\t\t\tzoomType = ZoomType125;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzoomType = ZoomType100;\n\t\t}\n\t}\n\n\t// Force reset Zoom value\n\tzoom.lVal = 10;\n\tm_pBrowserApp->ExecWB(OLECMDID_OPTICAL_ZOOM, OLECMDEXECOPT_DODEFAULT, &zoom, NULL);\n\tzoom.lVal = zoomType;\n\tm_pBrowserApp->ExecWB(OLECMDID_OPTICAL_ZOOM, OLECMDEXECOPT_DODEFAULT, &zoom, NULL);\n\n\tm_ZoomRatio = zoomType / 100.0;\n\n\tVariantClear(&zoom);\n\n\treturn zoomType;\n}\n\nvoid CDHtmlDialogEx::InitDialogEx(DWORD sizeX, DWORD sizeY, CString dialogPath)\n{\n// Enabled Visual Style\n\tDOCHOSTUIINFO info = { sizeof(info) };\n\t//info.cbSize = sizeof(info);\n\tGetHostInfo(&info);\n\tSetHostFlags(info.dwFlags | DOCHOSTUIFLAG_DIALOG | DOCHOSTUIFLAG_THEME);\n\n// ReSize Dialog\n\tSetClientRect((DWORD)(sizeX * m_ZoomRatio), (DWORD)(sizeY * m_ZoomRatio));\n\tCenterWindow();\n\n// Navigate\n//\tChangeAmbient();\n//\tNavigate(_T(\"file://\") + dialogPath, navNoHistory);\n\tTCHAR url[MAX_PATH * 3];\n\tDWORD length = MAX_PATH * 3;\n\tUrlCreateFromPath(dialogPath, url, &length, NULL);\n\tNavigate(url, navNoHistory);\n\n//\tDebugPrint(_T(\"SetTimer(TIMER_INIT_DHTML_DIALOG,\"));\n//\tSetTimer(TIMER_INIT_DHTML_DIALOG, 100, 0);\n}\n\n// 2008/1/19 //\nvoid CDHtmlDialogEx::SetClientRect(DWORD sizeX, DWORD sizeY, DWORD menuLine)\n{\n\tRECT rc{};\n\tRECT clientRc;\n\trc.left = 0;\n\trc.top = 0;\n\trc.right = sizeX;\n\trc.bottom = sizeY;\n\n\tGetClientRect(&clientRc);\n\tif(clientRc.bottom - clientRc.top == sizeY && clientRc.right - clientRc.left == sizeX)\n\t{\n\t\treturn;\n\t}\n\n\tWINDOWINFO wi = {0};\n\twi.cbSize = sizeof(WINDOWINFO);\n\tGetWindowInfo(&wi);\n\n// 0x94CE004C\n\n\tAdjustWindowRect(&rc, wi.dwStyle, TRUE);\n\tSetWindowPos(&CWnd::wndTop, -1, -1,\n\t\trc.right - rc.left,\n\t\trc.bottom - rc.top + GetSystemMetrics(SM_CYMENU) * menuLine,\n\t\tSWP_NOMOVE);\n\n\tGetClientRect(&clientRc);\n\tif(clientRc.bottom - clientRc.top != sizeY)\n\t{\n\t\tSetWindowPos(&CWnd::wndTop , -1, -1, \n\t\t\trc.right - rc.left,\n\t\t\trc.bottom - rc.top + GetSystemMetrics(SM_CYMENU) * menuLine + sizeY - (clientRc.bottom - clientRc.top), SWP_NOMOVE);\t\n\t}\n}\n\nBOOL CDHtmlDialogEx::Create(UINT nIDTemplate, CWnd* pDlgWnd, UINT menuId, CWnd* pParentWnd)\n{\n\tm_bModelessDlg = TRUE;\n\tm_ParentWnd = pParentWnd;\n\tm_DlgWnd = pDlgWnd;\n\tm_MenuId = menuId;\n\n\tif(m_MenuId != 0 && m_ParentWnd != NULL)\n\t{\n\t\tCMenu *menu = m_ParentWnd->GetMenu();\n\t\tmenu->EnableMenuItem(m_MenuId, MF_GRAYED);\n\t\tm_ParentWnd->SetMenu(menu);\n\t\tm_ParentWnd->DrawMenuBar();\n\t}\n\n\treturn CDialog::Create(nIDTemplate, pParentWnd);\n}\n\nvoid CDHtmlDialogEx::OnCancel() \n{\n\tif(m_bModelessDlg)\n\t{\n\t\tif(m_MenuId != 0 && m_ParentWnd != NULL)\n\t\t{\n\t\t\tCMenu *menu = m_ParentWnd->GetMenu();\n\t\t\tmenu->EnableMenuItem(m_MenuId, MF_ENABLED);\n\t\t\tm_ParentWnd->SetMenu(menu);\n\t\t\tm_ParentWnd->DrawMenuBar();\n\t\t}\n\t\tCWnd::DestroyWindow();\n\t}\n\telse\n\t{\n\t\tCDialog::OnCancel();\n\t}\n}\n\nvoid CDHtmlDialogEx::PostNcDestroy()\n{\n\tif(m_bModelessDlg)\n\t{\n\t\tm_DlgWnd = NULL;\n\t\tdelete this;\n\t}\n}\n\nvoid CDHtmlDialogEx::OnOK()\n{\n}\n\nvoid CDHtmlDialogEx::ShowWindowEx(int nCmdShow)\n{\n\tm_bShowWindow = TRUE;\n\tShowWindow(nCmdShow);\n\tSetForegroundWindow();\n}\n\nvoid CDHtmlDialogEx::SetElementPropertyEx(LPCTSTR szElementId, DISPID dispid, CString className)\n{\n\tCComPtr<IDispatch> spdispElem;\n\n\tGetElement(szElementId, &spdispElem);\n\tVARIANT v;\n\tVariantInit(&v);\n\tv.vt = VT_BSTR;\n\tv.bstrVal = CComBSTR(className);\n\n\tif(spdispElem)\n\t{\n\t\tDISPPARAMS dispparams = {NULL, NULL, 1, 1};\n\t\tdispparams.rgvarg = &v;\n\t\tDISPID dispidPut = DISPID_PROPERTYPUT;\n\t\tdispparams.rgdispidNamedArgs = &dispidPut;\n\n\t\tspdispElem->Invoke(dispid, IID_NULL,\n\t\t\t\tLOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT,\n\t\t\t\t&dispparams, NULL, NULL, NULL);\n\t}\n\tVariantClear(&v);\n}\n\nvoid CDHtmlDialogEx::SetElementOuterHtmlEx(LPCTSTR szElementId, CString outerHtml)\n{\n\tCComPtr<IHTMLElement> sphtmlElem;\n\tGetElement(szElementId, &sphtmlElem);\n\tif(sphtmlElem)\n\t{\n\t\tsphtmlElem->put_outerHTML(CComBSTR(outerHtml));\n\t}\n}\n\nvoid CDHtmlDialogEx::SetElementInnerHtmlEx(LPCTSTR szElementId, CString innerHtml)\n{\n\tCComPtr<IHTMLElement> sphtmlElem;\n\tGetElement(szElementId, &sphtmlElem);\n\tif(sphtmlElem)\n\t{\n\t\tsphtmlElem->put_innerHTML(CComBSTR(innerHtml));\n\t}\n}\n\nINT CDHtmlDialogEx::CallScript(CString function, CString argument)\n{\n\tCComPtr<IHTMLDocument2> pDocument;\n\tHRESULT hr = GetDHtmlDocument(&pDocument);\n\tif(hr != S_OK){DebugPrint(_T(\"CallScript - GetDHtmlDocument\"));}\n\tASSERT( hr == S_OK );\n\n\tCComPtr<IDispatch> script;\n\thr = pDocument->get_Script(&script);\n\tif(hr != S_OK){DebugPrint(_T(\"CallScript - pDocument->get_Script\"));}\n\tASSERT( hr == S_OK );\n\n\tCComBSTR name = CComBSTR(function);\n\n\tDISPID dispid;\n\thr = script->GetIDsOfNames(\n\t\t\tIID_NULL,\n\t\t\t&name,\n\t\t\t1,\n\t\t\tLOCALE_SYSTEM_DEFAULT,\n\t\t\t&dispid);\n\tASSERT( hr == S_OK );\n\tif(hr != S_OK){DebugPrint(_T(\"CallScript - script->GetIDsOfNames\"));}\n\n\tCComVariant arg1 = CComVariant(argument);\n\tDISPPARAMS params = {&arg1, NULL, 1, 0};\n\n\tVARIANT ret;\n\tVariantInit(&ret);\n\n\tEXCEPINFO exp;\n\n\thr = script->Invoke(\n\t\t\tdispid,\n\t\t\tIID_NULL,\n\t\t\tLOCALE_SYSTEM_DEFAULT,\n\t\t\tDISPATCH_METHOD,\n\t\t\t&params,\n\t\t\t&ret,\n\t\t\t&exp,\n\t\t\tNULL);\n\tASSERT( hr == S_OK );\n\tif(hr != S_OK){DebugPrint(_T(\"CallScript - script->Invoke\"));}\n\n\tINT result = 0;\n\n\tif(ret.vt == VT_I4)\n\t{\n\t\tresult = ret.intVal;\n\t}\n\tVariantClear(&ret);\n\n\treturn result;\n}\n\nCString CDHtmlDialogEx::i18n(CString section, CString key, BOOL inEnglish)\n{\n\tTCHAR str[256];\n\tCString cstr;\n\n\tif(inEnglish)\n\t{\n\t\tGetPrivateProfileStringFx(section, key, _T(\"\"), str, 256, m_DefaultLangPath);\n\t\tcstr = str;\n\t}\n\telse\n\t{\n\t\tGetPrivateProfileStringFx(section, key, _T(\"\"), str, 256, m_CurrentLangPath);\n\t\tcstr = str;\n\t\tif(cstr.IsEmpty())\n\t\t{\n\t\t\tGetPrivateProfileStringFx(section, key, _T(\"\"), str, 256, m_DefaultLangPath);\n\t\t\tcstr = str;\n\t\t}\n\t}\n\n\treturn cstr;\n}\n\n/////////////////////////////////////////////////////////////////////////\n// Added 2010/10/3 http://msdn.microsoft.com/ja-jp/library/aa753258.aspx\n/////////////////////////////////////////////////////////////////////////\n\nSTDMETHODIMP CDHtmlDialogEx::GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw)\n{\n\tHRESULT hr{};\n    WCHAR szKey[] = L\"Software\";\n\t\n\tsize_t cbLength{};\n    hr = StringCbLengthW(szKey, 1280, &cbLength);\n    //  TODO: Add error handling code here.\n\tif (SUCCEEDED(hr)) {\n\t\tif (pchKey)\n\t\t{\n\t\t\t*pchKey = (LPOLESTR)CoTaskMemAlloc(cbLength + sizeof(WCHAR));\n\t\t\t\tif (*pchKey)\n\t\t\t\t\thr = StringCbCopyW(*pchKey, cbLength + sizeof(WCHAR), szKey);\n\t\t}\n\t\telse\n\t\t\thr = E_INVALIDARG;\n\t}\n\n    return hr;\n}\n\nvoid CDHtmlDialogEx::SetLabel(CString& label, CString element, CString title)\n{\n\tlabel = title;\n\tSetElementPropertyEx(element, DISPID_IHTMLELEMENT_TITLE, title);\n}\n\n// 2012/5/6\n// http://msdn.microsoft.com/ja-jp/magazine/cc163834(en-us).aspx\nvoid CDHtmlDialogEx::OpenUrl(CString url)\n{\n\tINT_PTR result = 0;\n\tresult = (INT_PTR)ShellExecute(NULL, _T(\"open\"), url, NULL, NULL, SW_SHOWNORMAL);\n\tif(result <= 32)\n\t{\n\t\tresult = (INT_PTR)ShellExecuteW(NULL, _T(\"open\"), _T(\"iexplore.exe\"), url, NULL, SW_SHOWNORMAL);\n\t\tif(result <= 32)\n\t\t{\n\t\t\tCString args;\n\t\t\targs.Format(_T(\"url.dll,FileProtocolHandler %s\"), url.GetString());\n\t\t\tShellExecuteW(NULL, _T(\"open\"), _T(\"rundll32.exe\"), args, NULL, SW_SHOWNORMAL);\n\t\t}\n\t}\n}\n\n// 2012/10/12 Workaround for Duplicate Click Message\n\nBOOL CDHtmlDialogEx::ClickCheck()\n{\n\tstatic ULONGLONG preTime = 0;\n\tULONGLONG currentTime = GetTickCountFx();\n\n\t// CString cstr;\n\t// cstr.Format(_T(\"Cur=%d Pre=%d Sabun=%d\"), currentTime, preTime, currentTime - preTime);\n\t// AfxMessageBox(cstr);\n\n\tif(currentTime >= preTime + 100)\n\t{\n\t\tpreTime = currentTime;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nSTDMETHODIMP CDHtmlDialogEx::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)\n{\n\tif(dispIdMember == DISPID_HTMLELEMENTEVENTS_ONCLICK && ClickCheck())\n\t{\n\t\treturn CDHtmlEventSink::Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);\n\t}\n\treturn S_FALSE;\n}\n\nvoid CDHtmlDialogEx::OnTimer(UINT_PTR nIDEvent)\n{\n\tif(nIDEvent == TIMER_INIT_DHTML_DIALOG)\n\t{\n\t\tif(IsLoadHtmlCompleted())\n\t\t{\n\t\t\tDebugPrint(_T(\"KillTimer(TIMER_INIT_DHTML_DIALOG)\"));\n\t\t\tKillTimer(TIMER_INIT_DHTML_DIALOG);\n\t\t\tInitDialogComplete();\n\t\t}\n\t}\n\n\treturn CDHtmlDialog::OnTimer(nIDEvent);\n}\n\nBOOL CDHtmlDialogEx::IsLoadHtmlCompleted()\n{\n\tCComPtr<IHTMLElement> sphtmlElem = NULL;\n\tGetElement(_T(\"complete\"), &sphtmlElem);\n\tif(sphtmlElem)\n\t{\n\t\tDebugPrint(_T(\"IsLoadHtmlCompleted - TRUE\"));\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t//\tDebugPrint(_T(\"IsLoadHtmlCompleted - FALSE\"));\n\t\treturn FALSE;\n\t}\n}\n\nvoid CDHtmlDialogEx::HideControl(int nIDDlgItem)\n{\n\tGetDlgItem(nIDDlgItem)->ShowWindow(SW_HIDE);\n}"
        },
        {
          "name": "DHtmlDialogEx.h",
          "type": "blob",
          "size": 2.564453125,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n\nclass CDHtmlDialogEx : public CDHtmlDialog\n{\npublic:\n\tCDHtmlDialogEx(UINT dlgResouce, UINT dlgHtml, CWnd* pParent = NULL);\n\tvirtual ~CDHtmlDialogEx();\n\n\tvoid InitDialogEx(DWORD sizeX, DWORD sizeY, CString dlgPath);\n\tvoid SetClientRect(DWORD sizeX, DWORD sizeY, DWORD menuLine = 0);\n\tvoid ShowWindowEx(int nCmdShow);\n\n\tvirtual BOOL Create(UINT nIDTemplate, CWnd* dlgWnd, UINT menuId, CWnd* pParentWnd = NULL);\n\n\tCString m_CurrentLangPath;\n\tCString m_DefaultLangPath;\n\n\tenum ZOOM_TYPE\n\t{\n\t\tZoomTypeAuto = 0,\n\t\tZoomType100 = 100,\n\t\tZoomType125 = 125,\n\t\tZoomType150 = 150,\n\t\tZoomType200 = 200,\n\t};\n\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\n\n\tstatic const int TIMER_INIT_DHTML_DIALOG = 0x1000;\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\n\tvirtual BOOL OnInitDialog();\n\tvirtual void OnOK();\n\tvirtual void OnCancel();\n\n\tHACCEL m_hAccelerator;\n\tBOOL m_bShowWindow;\n\tBOOL m_bModelessDlg;\n\tCWnd* m_ParentWnd;\n\tCWnd* m_DlgWnd;\n\tUINT m_MenuId;\n\tTCHAR m_Ini[MAX_PATH];\n\n\tdouble m_ZoomRatio;\n\tDWORD m_ZoomType;\n\n\tvoid SetClassName(LPCTSTR szElementId, CString className);\n\tvoid SetTitle(LPCTSTR szElementId, CString title);\n\n\tvoid SetElementPropertyEx(LPCTSTR szElementId, DISPID dispid, CString className);\n\tvoid SetElementOuterHtmlEx(LPCTSTR szElementId, CString outerHtml);\n\tvoid SetElementInnerHtmlEx(LPCTSTR szElementId, CString innerHtml);\n\tINT CallScript(CString funcition, CString argument);\n\tvoid EnableDpiAware();\n\tDWORD ChangeZoomType(DWORD zoomType);\n\tdouble GetZoomRatio();\n\tCString i18n(CString section, CString key, BOOL inEnglish = FALSE);\n\tvoid SetLabel(CString &label, CString element, CString title);\n\tvoid OpenUrl(CString url);\n\tBOOL ClickCheck();\n\tBOOL IsLoadHtmlCompleted();\n\n\tvoid HideControl(int nIDDlgItem);\n\n\tvirtual BOOL PreTranslateMessage(MSG* pMsg);\n\tvirtual void OnDocumentComplete(LPDISPATCH pDisp, LPCTSTR szUrl);\n\tvirtual void PostNcDestroy();\n\tvirtual BOOL OnAmbientProperty(COleControlSite* pSite, DISPID dispid, VARIANT* pvar);\n\tvirtual STDMETHODIMP GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw);\n\tvirtual STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);\n\tvirtual void InitDialogComplete();\n\n\tDECLARE_MESSAGE_MAP()\n\n\tDECLARE_DHTML_EVENT_MAP()\n\n};\n"
        },
        {
          "name": "DHtmlMainDialog.cpp",
          "type": "blob",
          "size": 14.919921875,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n#include \"stdafx.h\"\n#include \"resource.h\"\n#include \"UtilityFx.h\"\n#include \"OsInfoFx.h\"\n\nUINT CDHtmlMainDialog::wmTaskbarCreated = ::RegisterWindowMessage(_T(\"TaskbarCreated\"));\n\nCDHtmlMainDialog::CDHtmlMainDialog(UINT dlgResouce, UINT dlgHtml, \n\t\tCString ThemeDir, DWORD ThemeIndex, CString LangDir, DWORD LangIndex,\n\t\tCWnd* pParent)\n\t\t:CDHtmlDialogEx(dlgResouce, dlgHtml, pParent)\n{\n\tm_ThemeDir = ThemeDir;\n\tm_ThemeIndex = ThemeIndex;\n\tm_LangDir = LangDir;\n\tm_LangIndex = LangIndex;\n\n\tm_bInitializing = TRUE;\n\tm_bWindoowMinimizeOnce = TRUE;\n\tm_bResidentMinimize = FALSE;\n}\n\nCDHtmlMainDialog::~CDHtmlMainDialog()\n{\n}\n\nBEGIN_MESSAGE_MAP(CDHtmlMainDialog, CDHtmlDialogEx)\n\tON_WM_WINDOWPOSCHANGING()\nEND_MESSAGE_MAP()\n\nBEGIN_DHTML_EVENT_MAP(CDHtmlMainDialog)\nEND_DHTML_EVENT_MAP()\n\nvoid CDHtmlMainDialog::SetWindowTitle(CString message, CString mode)\n{\n\tCString title;\n\n\tif(! message.IsEmpty())\n\t{\n\t\ttitle.Format(_T(\"%s - %s\"), PRODUCT_SHORT_NAME, message.GetString());\n\t}\n\telse if(! mode.IsEmpty())\n\t{\n\t\ttitle.Format(_T(\"%s %s %s\"), PRODUCT_NAME, PRODUCT_VERSION, mode.GetString());\n\t}\n\telse\n\t{\n\t\ttitle.Format(_T(\"%s %s %s\"), PRODUCT_NAME, PRODUCT_VERSION, PRODUCT_EDITION);\n\t}\n\tSetWindowText(title);\n}\n\nvoid CDHtmlMainDialog::InitThemeLang()\n{\n\tTCHAR str[256];\n\tTCHAR *ptrEnd;\n\n\tWIN32_FIND_DATA findData;\n\tHANDLE hFind;\n\tCString langPath;\n\tint i = 0;\n\tWORD PrimaryLangID;\n\tCString PrimaryLang;\n\n// Set Theme\n\tif(m_CurrentTheme.IsEmpty())\n\t{\n\t#ifdef SUISHO_AOI_SUPPORT\n\t\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"ThemeAoi\"), _T(\"default\"), str, 256, m_Ini);\n\t#elif MSI_MEI_SUPPORT\n\t\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"ThemeMSIMei\"), _T(\"default\"), str, 256, m_Ini);\n\t#elif KUREI_KEI_SUPPORT\n\t\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"ThemeKureiKei\"), _T(\"default\"), str, 256, m_Ini);\n\t#elif SUISHO_SHIZUKU_SUPPORT\n\t\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"ThemeShizuku\"), _T(\"default\"), str, 256, m_Ini);\n\t#else\n\t\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"Theme\"), _T(\"default\"), str, 256, m_Ini);\n\t#endif\n\t\tm_CurrentTheme = str;\n\t}\n\n// Set Language\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"Language\"), _T(\"\"), str, 256, m_Ini);\n\n\tlangPath.Format(_T(\"%s\\\\%s.lang\"), m_LangDir.GetString(), str);\n\tm_DefaultLangPath.Format(_T(\"%s\\\\%s.lang\"), m_LangDir.GetString(), _T(\"English\"));\n\n\tif(_tcscmp(str, _T(\"\")) != 0 && IsFileExist((const TCHAR*)langPath))\n\t{\n\t\tm_CurrentLang = str;\n\t\tm_CurrentLangPath.Format(_T(\"%s\\\\%s.lang\"), m_LangDir.GetString(), str);\n\t}\n\telse\n\t{\n\t\tm_CurrentLocalID.Format(_T(\"0x%04X\"), GetUserDefaultLCID());\n\t\tPrimaryLangID = PRIMARYLANGID(GetUserDefaultLCID());\n\n\t\tlangPath.Format(_T(\"%s\\\\*.lang\"), m_LangDir.GetString());\n\n\t\thFind = ::FindFirstFile(langPath, &findData);\n\t\tif(hFind != INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\tdo{\n\t\t\t\tif(findData.dwFileAttributes != FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tCString cstr;\n\t\t\t\t\tcstr.Format(_T(\"%s\\\\%s\"), m_LangDir.GetString(), findData.cFileName);\n\t\t\t\t\tGetPrivateProfileStringFx(_T(\"Language\"), _T(\"LOCALE_ID\"), _T(\"\"), str, 256, cstr);\n\t\t\t\t\tif((ptrEnd = _tcsrchr(findData.cFileName, '.')) != NULL){*ptrEnd = '\\0';}\n\n\t\t\t\t\tif(_tcsstr(str, m_CurrentLocalID) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_CurrentLang = findData.cFileName;\n\t\t\t\t\t\tm_CurrentLangPath.Format(_T(\"%s\\\\%s.lang\"), m_LangDir.GetString(), findData.cFileName);\n\t\t\t\t\t}\n\t\t\t\t\tif(PrimaryLangID == PRIMARYLANGID(_tcstol(str, NULL, 16)))\n\t\t\t\t\t{\n\t\t\t\t\t\tPrimaryLang = findData.cFileName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}while(::FindNextFile(hFind, &findData) && i <= 0xFF);\n\t\t}\n\t\tFindClose(hFind);\n\n\t\tif(m_CurrentLang.IsEmpty())\n\t\t{\n\t\t\tif(PrimaryLang.IsEmpty())\n\t\t\t{\n\t\t\t\tm_CurrentLang = _T(\"English\");\n\t\t\t\tm_CurrentLangPath.Format(_T(\"%s\\\\%s.lang\"), m_LangDir.GetString(), m_CurrentLang.GetString());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_CurrentLang = PrimaryLang;\n\t\t\t\tm_CurrentLangPath.Format(_T(\"%s\\\\%s.lang\"), m_LangDir.GetString(), PrimaryLang.GetString());\n\t\t\t}\t\n\t\t}\n\t}\n}\n\nvoid CDHtmlMainDialog::InitMenu()\n{\n\tCMenu menu;\n\tCMenu subMenu;\n\tBOOL FlagHitTheme = FALSE;\n\tBOOL FlagHitLang = FALSE;\n\tUINT newItemID = 0;\n\tUINT currentItemID = 0;\n\tUINT defaultStyleItemID = 0;\n\tWIN32_FIND_DATA findData;\n\tWIN32_FIND_DATA findCssData;\n\tHANDLE hFind;\n\tHANDLE hCssFind;\n\tCString themePath;\n\tCString themeCssPath;\n\tCString langPath;\n\tint i = 0;\n\tTCHAR *ptrEnd;\n\tTCHAR str[256];\n\t\n\tmenu.Attach(GetMenu()->GetSafeHmenu());\n\tsubMenu.Attach(menu.GetSubMenu(m_ThemeIndex)->GetSafeHmenu());\n//\tsubMenu.RemoveMenu(0, MF_BYPOSITION);\n\n\tthemePath.Format(_T(\"%s\\\\*.*\"), m_ThemeDir.GetString());\n\n\thFind = ::FindFirstFile(themePath, &findData);\n\tif(hFind != INVALID_HANDLE_VALUE)\n\t{\n\t\twhile(::FindNextFile(hFind, &findData) && i <= 0xFF)\n\t\t{\n\t\t\tif(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t{\n//\t\t\t\tthemeCssPath.Format(_T(\"%s\\\\%s\\\\%s\"), m_ThemeDir,\n//\t\t\t\t\t\t\t\t\tfindData.cFileName, MAIN_CSS_FILE_NAME);\n\t\t\t\thCssFind = ::FindFirstFile(themeCssPath, &findCssData);\n\t\t\t\tif(hCssFind != INVALID_HANDLE_VALUE)\n\t\t\t\t{\n\t\t\t\t\t// Add Theme\n\t\t\t\t\tnewItemID = WM_THEME_ID + i;\n\t\t\t\t\ti++;\n\t\t\t\t\tsubMenu.AppendMenu(MF_STRING, (UINT_PTR)newItemID, findData.cFileName);\n\t\t\t\t\tm_MenuArrayTheme.Add(findData.cFileName);\n\t\t\t\t\tif(m_CurrentTheme.Compare(findData.cFileName) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentItemID = newItemID;\n\t\t\t\t\t\tFlagHitTheme = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif(_tcsstr(findData.cFileName, _T(\"default\")) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tdefaultStyleItemID = newItemID;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tFindClose(hFind);\n\n\tif(! FlagHitTheme)\n\t{\n\t\tcurrentItemID = defaultStyleItemID;\n\t\tm_CurrentTheme = _T(\"default\");\n\t}\n\n\tsubMenu.CheckMenuRadioItem(WM_THEME_ID, WM_THEME_ID + (UINT)m_MenuArrayTheme.GetSize(),\n\t\t\t\t\t\t\t\tcurrentItemID, MF_BYCOMMAND);\n\n\tsubMenu.Detach();\n\n#ifdef _UNICODE\n\tsubMenu.Attach(menu.GetSubMenu(m_LangIndex)->GetSafeHmenu());\n\n\tCMenu subMenuAN;\n\tCMenu subMenuOZ;\n\n\tsubMenuAN.Attach(subMenu.GetSubMenu(0)->GetSafeHmenu()); // 1st is \"A~N\"\n\tsubMenuAN.RemoveMenu(0, MF_BYPOSITION);\n\tsubMenuOZ.Attach(subMenu.GetSubMenu(1)->GetSafeHmenu()); // 2nd is \"O~Z\"\n\tsubMenuOZ.RemoveMenu(0, MF_BYPOSITION);\n\n\tlangPath.Format(_T(\"%s\\\\*.lang\"), m_LangDir.GetString());\n\ti = 0;\n\thFind = ::FindFirstFile(langPath, &findData);\n\tif(hFind != INVALID_HANDLE_VALUE)\n\t{\n\t\tdo{\n\t\t\tif(findData.dwFileAttributes != FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t{\n\t\t\t\tnewItemID = WM_LANGUAGE_ID + i;\n\t\t\t\ti++;\n\n\t\t\t\t// Add Language\n\t\t\t\tCString cstr;\n\t\t\t\tcstr.Format(_T(\"%s\\\\%s\"), m_LangDir.GetString(), findData.cFileName);\n\t\t\t\tGetPrivateProfileStringFx(_T(\"Language\"), _T(\"LANGUAGE\"), _T(\"\"), str, 256, cstr);\n\t\t\t\tif((ptrEnd = _tcsrchr(findData.cFileName, '.')) != NULL)\n\t\t\t\t{\n\t\t\t\t\t*ptrEnd = '\\0';\n\t\t\t\t}\n\n\t\t\t\tcstr.Format(_T(\"%s, [%s]\"), str, findData.cFileName);\n\t\t\t\tif('A' <= findData.cFileName[0] && findData.cFileName[0] <= 'N')\n\t\t\t\t{\n\t\t\t\t\tsubMenuAN.AppendMenu(MF_STRING, (UINT_PTR)newItemID, cstr);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsubMenuOZ.AppendMenu(MF_STRING, (UINT_PTR)newItemID, cstr);\n\t\t\t\t}\n\t\t\t\tm_MenuArrayLang.Add(findData.cFileName);\n\n\t\t\t\tif(m_CurrentLang.Compare(findData.cFileName) == 0)\n\t\t\t\t{\n\t\t\t\t\tcurrentItemID = newItemID;\n\t\t\t\t\tFlagHitLang = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(::FindNextFile(hFind, &findData) && i <= 0xFF);\n\t}\n\tFindClose(hFind);\n\n\tsubMenuAN.CheckMenuRadioItem(WM_LANGUAGE_ID, WM_LANGUAGE_ID + (UINT)m_MenuArrayLang.GetSize(),\n\t\t\t\t\t\t\t\tcurrentItemID, MF_BYCOMMAND);\n\tsubMenuOZ.CheckMenuRadioItem(WM_LANGUAGE_ID, WM_LANGUAGE_ID + (UINT)m_MenuArrayLang.GetSize(),\n\t\t\t\t\t\t\t\tcurrentItemID, MF_BYCOMMAND);\n\n\tsubMenuOZ.Detach();\n\tsubMenuAN.Detach();\n\tsubMenu.Detach();\n\tmenu.Detach();\n#else\n\tsubMenu.Attach(menu.GetSubMenu(m_LangIndex)->GetSafeHmenu());\n\tsubMenu.RemoveMenu(0, MF_BYPOSITION);//A~N\n\tsubMenu.RemoveMenu(0, MF_BYPOSITION);//O~Z\n\tlangPath.Format(_T(\"%s\\\\*.lang\"), m_LangDir);\n\ti = 0;\n\thFind = ::FindFirstFile(langPath, &findData);\n\tif(hFind != INVALID_HANDLE_VALUE)\n\t{\n\t\tdo{\n\t\t\tif(findData.dwFileAttributes != FILE_ATTRIBUTE_DIRECTORY)\n\t\t\t{\n\t\t\t\tnewItemID = WM_LANGUAGE_ID + i;\n\t\t\t\ti++;\n\n\t\t\t\t// Add Language\n\t\t\t\tCString cstr;\n\t\t\t\tcstr.Format(_T(\"%s\\\\%s\"), m_LangDir, findData.cFileName);\n\t\t\t\tGetPrivateProfileStringFx(_T(\"Language\"), _T(\"LANGUAGE\"), _T(\"\"), str, 256, cstr);\n\t\t\t\tif((ptrEnd = _tcsrchr(findData.cFileName, '.')) != NULL){\n\t\t\t\t\t*ptrEnd = '\\0';\n\t\t\t\t}\n\n\t\t\t\tcstr.Format(_T(\"%s, [%s]\"), str, findData.cFileName);\n\t\t\t\tsubMenu.AppendMenu(MF_STRING, (UINT_PTR)newItemID, cstr);\n\t\t\t\tm_MenuArrayLang.Add(findData.cFileName);\n\n\t\t\t\tif(m_CurrentLang.Compare(findData.cFileName) == 0)\n\t\t\t\t{\n\t\t\t\t\tcurrentItemID = newItemID;\n\t\t\t\t\tFlagHitLang = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(::FindNextFile(hFind, &findData) && i <= 0xFF);\n\n\t}\n\tFindClose(hFind);\n\n\tsubMenu.CheckMenuRadioItem(WM_LANGUAGE_ID, WM_LANGUAGE_ID + (UINT)m_MenuArrayLang.GetSize(),\n\t\t\t\t\t\t\t\tcurrentItemID, MF_BYCOMMAND);\n\n\tsubMenu.Detach();\n\tmenu.Detach();\n#endif\n\tif(! FlagHitLang)\n\t{\n\t\tAfxMessageBox(_T(\"Fatal Error. Missing Language Files!!\"));\n\t}\n}\n\nBOOL CDHtmlMainDialog::OnInitDialog()\n{\n\treturn CDHtmlDialogEx::OnInitDialog();\n}\n\nvoid CDHtmlMainDialog::ChangeTheme(CString ThemeName)\n{\n\tCComPtr<IHTMLDocument2> pHtmlDoc;\n\tCComPtr<IHTMLStyleSheet> pHtmlStyleSheet;\n\tCComPtr<IHTMLStyleSheetsCollection> pStyleSheetsCollection;\n\n\tHRESULT hr;\n\tCComBSTR bstr;\n\tCString cstr;\n\tLONG length;\n\n\thr = GetDHtmlDocument(&pHtmlDoc);\n\tif(FAILED(hr)) return ;\n\n\thr = pHtmlDoc->get_styleSheets(&pStyleSheetsCollection);\n\tif(FAILED(hr)) return ;\n\n\thr = pStyleSheetsCollection->get_length(&length);\n\tif(FAILED(hr)) return ;\n\n\tVARIANT index;\n\tVariantInit(&index);\n// by ordinal\n\tindex.vt = VT_I4;\n\tindex.intVal = 0;\n// by name\n//\tindex.vt = VT_BSTR;\n//\tindex.bstrVal = L\"StyleSheet\";\n\tVARIANT dispatch;\n\tVariantInit(&dispatch);\n\tdispatch.vt = VT_DISPATCH;\n\n\thr = pStyleSheetsCollection->item(&index, &dispatch);\n\tif(FAILED(hr)) return ;\n\n\thr = dispatch.pdispVal->QueryInterface(IID_IHTMLStyleSheet, (void **) &pHtmlStyleSheet);\n\tif(FAILED(hr)) return ;\n\n\tcstr.Format(_T(\"%s\\\\%s\\\\%s\"), m_ThemeDir.GetString(), ThemeName.GetString(), MAIN_CSS_FILE_NAME);\n\tbstr = cstr;\n\thr = pHtmlStyleSheet->put_href(bstr);\n\tif(FAILED(hr)) return ;\n\n\tVariantClear(&index);\n\tVariantClear(&dispatch);\n\n#ifdef SUISHO_AOI_SUPPORT\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"ThemeAoi\"), ThemeName.GetString(), m_Ini);\n#elif MSI_MEI_SUPPORT\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"ThemeMSIMei\"), ThemeName.GetString(), m_Ini);\n#elif KUREI_KEI_SUPPORT\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"ThemeKureiKei\"), ThemeName.GetString(), m_Ini);\n#elif SUISHO_SHIZUKU_SUPPORT\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"ThemeShizuku\"), ThemeName.GetString(), m_Ini);\n#else\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Theme\"), ThemeName.GetString(), m_Ini);\n#endif\n\n\n\t\n}\n\nBOOL CDHtmlMainDialog::OnCommand(WPARAM wParam, LPARAM lParam) \n{\n\t// Select Theme\n\tif(WM_THEME_ID <= wParam && wParam < WM_THEME_ID + (WPARAM)m_MenuArrayTheme.GetSize())\n\t{\n\t\tCMenu menu;\n\t\tCMenu subMenu;\n\t\tmenu.Attach(GetMenu()->GetSafeHmenu());\n\t\tsubMenu.Attach(menu.GetSubMenu(m_ThemeIndex)->GetSafeHmenu());\n\n\t\tm_CurrentTheme = m_MenuArrayTheme.GetAt(wParam - WM_THEME_ID);\n\t\tChangeTheme(m_MenuArrayTheme.GetAt(wParam - WM_THEME_ID));\n\t\tsubMenu.CheckMenuRadioItem(WM_THEME_ID, WM_THEME_ID + (UINT)m_MenuArrayTheme.GetSize(),\n\t\t\t\t\t\t\t\t\t(UINT)wParam, MF_BYCOMMAND);\n\t\tsubMenu.Detach();\n\t\tmenu.Detach();\n\t}\n\n\treturn CDHtmlDialogEx::OnCommand(wParam, lParam);\n}\n\nvoid CDHtmlMainDialog::OnWindowPosChanging(WINDOWPOS * lpwndpos)\n{\n\tif(! m_bShowWindow)\n\t{\n\t\tlpwndpos->flags &= ~SWP_SHOWWINDOW;\n\t}\n\t\n\tif(m_bWindoowMinimizeOnce && ! m_bInitializing)\n\t{\n\t\tm_bWindoowMinimizeOnce = FALSE;\n\t\tif(m_bResident && m_bResidentMinimize)\n\t\t{\n\t\t\tShowWindow(SW_MINIMIZE);\n\t\t}\n\t}\n\n    CDialog::OnWindowPosChanging(lpwndpos);\n}\n\nDWORD CDHtmlMainDialog::GetZoomType()\n{\n\treturn GetPrivateProfileInt(_T(\"Setting\"), _T(\"ZoomType\"), ZoomTypeAuto, m_Ini);\n}\n\nvoid CDHtmlMainDialog::SetZoomType(DWORD zoomType)\n{\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), m_ZoomType);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"ZoomType\"), cstr, m_Ini);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n//\n// Task Tray\n//\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Add TaskTray\nBOOL CDHtmlMainDialog::AddTaskTray(UINT id, UINT callback, HICON icon, CString tip)\n{\n\tif(m_bResident)\n\t{\n\t\tNOTIFYICONDATA nidata = { sizeof(NOTIFYICONDATA) };\n\t\tnidata.hWnd = m_hWnd;\n\t\tnidata.uID = id;\n\t\tnidata.uFlags = NIF_TIP | NIF_ICON | NIF_MESSAGE;\n\t\tnidata.hIcon = icon;\n\t\tnidata.uVersion = NOTIFYICON_VERSION;\n\t\tnidata.uCallbackMessage = callback;\n\t\t_tcscpy_s(nidata.szTip, 128, tip.Left(127));\n\n\t\t::Shell_NotifyIcon(NIM_SETVERSION, &nidata);\n\t\tint waitCount = 10;\n\t\tif(m_bStartup)\n\t\t{\n\t\t\twaitCount = 20;\n\t\t}\n\t\tfor(int i = 0; i < waitCount; i++)\n\t\t{\n\t\t\tif(::Shell_NotifyIcon(NIM_ADD, &nidata))\n\t\t\t{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tSleep(100 * i);\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n// Update TaskTray Icon\nBOOL CDHtmlMainDialog::ModifyTaskTrayIcon(UINT id, HICON icon)\n{\n\tif(m_bResident)\n\t{\n\t\tNOTIFYICONDATA nidata = { sizeof(NOTIFYICONDATA) };\n\t\tnidata.hWnd = m_hWnd;\n\t\tnidata.uID = id;\n\t\tnidata.uFlags = NIF_ICON;\n\t\tnidata.hIcon = icon;\n\t\tfor(int i = 0; i < 3; i++)\n\t\t{\n\t\t\tif(::Shell_NotifyIcon(NIM_MODIFY, &nidata))\n\t\t\t{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tSleep(100 * i);\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n// Update TaskTray Tips\nBOOL CDHtmlMainDialog::ModifyTaskTrayTip(UINT id, CString tip)\n{\n\tif(m_bResident)\n\t{\n\t\tNOTIFYICONDATA nidata = { sizeof(NOTIFYICONDATA) };\n\t\tnidata.hWnd = m_hWnd;\n\t\tnidata.uID = id;\n\t\tnidata.uFlags = NIF_TIP;\n\t\n\t\t_tcscpy_s(nidata.szTip, 128, tip.Left(127));\n\n\t\tfor(int i = 0; i < 3; i++)\n\t\t{\n\t\t\tif(::Shell_NotifyIcon(NIM_MODIFY, &nidata))\n\t\t\t{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tSleep(100 * i);\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n// Update TaskTray\nBOOL CDHtmlMainDialog::ModifyTaskTray(UINT id, HICON icon, CString tip)\n{\n\tif(m_bResident)\n\t{\n\t\tNOTIFYICONDATA nidata = { sizeof(NOTIFYICONDATA) };\n\t\tnidata.hWnd = m_hWnd;\n\t\tnidata.uID = id;\n\t\tnidata.uFlags = NIF_TIP|NIF_ICON;\n\t\tnidata.hIcon = icon;\n\t\t_tcscpy_s(nidata.szTip, 128, tip.Left(127));\n\n\t\tfor(int i = 0; i < 3; i++)\n\t\t{\n\t\t\tif(::Shell_NotifyIcon(NIM_MODIFY, &nidata))\n\t\t\t{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tSleep(100 * i);\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n// Show Balloon\nBOOL CDHtmlMainDialog::ShowBalloon(UINT id, DWORD infoFlag, CString infoTitle, CString info)\n{\n\tif(m_bResident)\n\t{\n\t\tNOTIFYICONDATA nidata = { sizeof(NOTIFYICONDATA) };\n\t\tnidata.hWnd = m_hWnd;\n\t\tnidata.uID = id;\n\t\tnidata.uFlags = NIF_INFO;\n\t\tnidata.dwInfoFlags = infoFlag;\n\n\t\t_tcscpy_s(nidata.szInfo, 256, info.Left(255));\n\t\t_tcscpy_s(nidata.szInfoTitle, 64, infoTitle.Left(63));\n\n\t\tfor(int i = 0; i < 3; i++)\n\t\t{\n\t\t\tif(::Shell_NotifyIcon(NIM_MODIFY, &nidata))\n\t\t\t{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tSleep(100 * i);\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n// Remove TaskTray\nBOOL CDHtmlMainDialog::RemoveTaskTray(UINT id)\n{\n\tif(m_bResident)\n\t{\n\t\tNOTIFYICONDATA nidata = { sizeof(NOTIFYICONDATA) };\n\t\tnidata.hWnd = m_hWnd;\n\t\tnidata.uID = id;\n\n\t\tfor(int i = 0; i < 3; i++)\n\t\t{\n\t\t\tif(::Shell_NotifyIcon(NIM_DELETE, &nidata))\n\t\t\t{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tSleep(100 * i);\n\t\t}\n\t}\n\treturn FALSE;\n}\n"
        },
        {
          "name": "DHtmlMainDialog.h",
          "type": "blob",
          "size": 1.6708984375,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n\n#define MAIN_CSS_FILE_NAME\t_T(\"Main.css\")\n\nclass CDHtmlMainDialog : public CDHtmlDialogEx\n{\npublic:\n\tCDHtmlMainDialog(UINT dlgResouce, UINT dlgHtml, \n\t\tCString ThemeDir, DWORD ThemeIndex, CString LangDir, DWORD LangIndex,\n\t\tCWnd* pParent = NULL);\n\tvirtual ~CDHtmlMainDialog();\n\n\tCString m_CurrentLocalID;\n\n\tCString m_ThemeDir;\n\tCString m_LangDir;\n\tDWORD m_ThemeIndex;\n\tDWORD m_LangIndex;\n\n\tCStringArray m_MenuArrayTheme;\n\tCStringArray m_MenuArrayLang;\n\tCString m_CurrentTheme;\n\tCString m_CurrentLang;\n\n\tvoid InitMenu();\n\tvoid InitThemeLang();\n\tvoid ChangeTheme(CString ThemeName);\n\tvoid SetWindowTitle(CString message, CString mode = _T(\"\"));\n\n\tBOOL m_bStartup;\n\tBOOL m_bInitializing;\n\tBOOL m_bWindoowMinimizeOnce;\n\tBOOL m_bResidentMinimize;\n\n\t// Task Tray\n\tBOOL m_bResident;\n\tstatic UINT wmTaskbarCreated;\n\tBOOL AddTaskTray(UINT id, UINT callback, HICON icon, CString tip);\n\tBOOL RemoveTaskTray(UINT id);\n\tBOOL ModifyTaskTray(UINT id, HICON icon, CString tip);\n\tBOOL ModifyTaskTrayIcon(UINT id, HICON icon);\n\tBOOL ModifyTaskTrayTip(UINT id, CString tip);\n\tBOOL ShowBalloon(UINT id, DWORD infoFlag, CString infoTitle, CString info);\n\n\tDWORD GetZoomType();\n\tvoid SetZoomType(DWORD zoomType);\n\n\tafx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);\n\tvirtual BOOL OnInitDialog();\n\tvirtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);\n\n\tDECLARE_MESSAGE_MAP()\n\n\tDECLARE_DHTML_EVENT_MAP()\n\n};"
        },
        {
          "name": "DeclareDPIAware.manifest",
          "type": "blob",
          "size": 1.01171875,
          "content": "<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\" xmlns:asmv3=\"urn:schemas-microsoft-com:asm.v3\">\n  <compatibility xmlns=\"urn:schemas-microsoft-com:compatibility.v1\">\n    <application>\n      <!-- Windows Vista -->\n      <supportedOS Id=\"{e2011457-1546-43c5-a5fe-008deee3d3f0}\"/>\n      <!-- Windows 7 -->\n      <supportedOS Id=\"{35138b9a-5d96-4fbd-8e2d-a2440225f93a}\"/>\n      <!-- Windows 8 -->\n      <supportedOS Id=\"{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}\"/>\n      <!-- Windows 8.1 -->\n      <supportedOS Id=\"{1f676c76-80e1-4239-95bb-83d0f6d0da78}\"/>\n      <!-- Windows 10 -->\n      <supportedOS Id=\"{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}\"/>\n    </application>\n  </compatibility>\n  <asmv3:application>\n    <asmv3:windowsSettings xmlns=\"http://schemas.microsoft.com/SMI/2005/WindowsSettings\">\n      <dpiAware>True/PM</dpiAware>\n      <dpiAwareness xmlns=\"http://schemas.microsoft.com/SMI/2016/WindowsSettings\">PerMonitorV2, PerMonitor</dpiAwareness>\n    </asmv3:windowsSettings>\n  </asmv3:application>\n</assembly>\n"
        },
        {
          "name": "DiskInfo.cpp",
          "type": "blob",
          "size": 8.89453125,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n#include \"GraphDlg.h\"\n\n#include \"UtilityFx.h\"\n#include \"OsInfoFx.h\"\n\n#include <afxole.h>\n#include <stdio.h>\n\n#ifndef safeCloseHandle\n#define safeCloseHandle(h) { if( h != NULL ) { ::CloseHandle(h); h = NULL; } }\n#endif\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\nGdiplusStartupInput gdiplusStartupInput;\n\n// CDiskInfoApp\n\nBEGIN_MESSAGE_MAP(CDiskInfoApp, CWinApp)\n\tON_COMMAND(ID_HELP, &CWinApp::OnHelp)\nEND_MESSAGE_MAP()\n\n// CDiskInfoApp construction\n\nCDiskInfoApp::CDiskInfoApp()\n{\n\t// TODO: add construction code here,\n\t// Place all significant initialization in InitInstance\n}\n\nCDiskInfoApp::~CDiskInfoApp()\n{\n\tGdiplusShutdown(gdiplusToken);\n\tsafeCloseHandle(hMutex);\n}\n\n// The one and only CDiskInfoApp object\n\nCDiskInfoApp theApp;\n\n//-----------------------------------------------------------------------------\n// Prototypes\n//-----------------------------------------------------------------------------\nstatic BOOL IsFileExistEx(const TCHAR* path, const TCHAR* fileName);\nstatic BOOL RunAsRestart();\n\n// CDiskInfoApp initialization\nBOOL CDiskInfoApp::InitInstance()\n{\n\tBOOL flagEarthlight = FALSE;\n\tBOOL flagStartupExit = FALSE;\n\tm_bCopyExit = FALSE;\n\n\tint defaultDisk = -1;\n\n\tINITCOMMONCONTROLSEX InitCtrls = { sizeof(INITCOMMONCONTROLSEX) };\n\tInitCtrls.dwICC = ICC_WIN95_CLASSES;\n\tInitCommonControlsEx(&InitCtrls);\n\tCWinApp::InitInstance();\n\n\tGdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);\n\n\t// for WMI error\n\tSetErrorMode(SEM_FAILCRITICALERRORS);\n\n\t// Init m_Ini\n\tTCHAR *ptrEnd;\n\tTCHAR ini[MAX_PATH];\n\n\t::GetModuleFileName(NULL, ini, MAX_PATH);\n\tif((ptrEnd = _tcsrchr(ini, '\\\\')) != NULL)\n\t{\n\t\t*ptrEnd = '\\0';\n\t\tm_Ini = ini;\n\t\tm_Txt = ini;\n\t\t// _tcscat_s(ini, MAX_PATH, _T(\"\\\\DiskInfo.ini\"));\n\t}\n\tm_Ini += _T(\"\\\\DiskInfo.ini\");\n\tm_Txt += _T(\"\\\\DiskInfo.txt\");\n\n\tCString cstr;\n\tDWORD debugMode = GetPrivateProfileInt(_T(\"Setting\"), _T(\"DebugMode\"), 0, m_Ini);\n\tSetDebugMode(debugMode);\n\tcstr.Format(_T(\"%d\"), debugMode);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"DebugMode\"), cstr, m_Ini);\n\n\tint argc = 0;\n\t//int index = 0;\n\tLPWSTR *argv = CommandLineToArgvW(GetCommandLineW(), &argc);\n\n\tif(argc > 1)\n\t{\n\t\tCString cstr;\n\t\tcstr = argv[1];\n\t\n\t\tif(cstr.CompareNoCase(_T(\"/Earthlight\")) == 0)\n\t\t{\n\t\t\tflagEarthlight = TRUE;\n\t\t\tif(argc > 2)\n\t\t\t{\n\t\t\t\tdefaultDisk = _tstoi(argv[2]);\n\t\t\t}\n\t\t}\n\t\tif(cstr.CompareNoCase(_T(\"/Startup\")) == 0)\n\t\t{\n\t\t\tint time = 0;\n\t\t\ttime = GetPrivateProfileInt(_T(\"Setting\"), _T(\"StartupWaitTime\"), 30, m_Ini);\n\t\t\tif(time >= 0)\n\t\t\t{\n\t\t\t\tSleep(time * 1000);\n\t\t\t}\n\t\t\tTCHAR str[MAX_PATH] = {};\n\t\t\t::GetModuleFileName(NULL, str, MAX_PATH);\n\t\t\tShellExecute(NULL, NULL, str, NULL, NULL, SW_SHOWNORMAL);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif(cstr.CompareNoCase(_T(\"/Exit\")) == 0)\n\t\t{\n\t\t\tflagStartupExit = TRUE;\n\t\t}\t\t\n\t\tif(cstr.CompareNoCase(_T(\"/Copy\")) == 0)\n\t\t{\n\t\t\tm_SaveAsText = m_Txt;\n\t\t}\n\t\tif(cstr.CompareNoCase(_T(\"/CopyExit\")) == 0)\n\t\t{\n\t\t\tm_SaveAsText = m_Txt;\n\t\t\tm_bCopyExit = TRUE;\n\t\t}\n\t}\n\n\t// DEBUG\n\t// flagEarthlight = TRUE;\n\tDebugPrint(PRODUCT_VERSION);\n\tDebugPrint(PRODUCT_RELEASE);\n\n\tif(! flagEarthlight && ! m_bCopyExit)\n\t{\n\t\tDebugPrint(_T(\"CreateMutex\"));\n\t\thMutex = ::CreateMutex(NULL, FALSE, PROJECT_NAME);\n\t\tif(GetLastError() == ERROR_ALREADY_EXISTS)\n\t\t{\n\t\t\tDebugPrint(_T(\"ERROR_ALREADY_EXISTS\"));\n#ifndef _DEBUG\n\t\t\treturn FALSE;\n#endif\n\t\t}\n\t}\n\n\tCString DefaultTheme;\n\tCString DefaultLanguage;\n\tTCHAR tmp[MAX_PATH] = {};\n\n\tGetModuleFileName(NULL, tmp, MAX_PATH);\n\tif((ptrEnd = _tcsrchr(tmp, '\\\\')) != NULL)\n\t{\n\t\t*ptrEnd = '\\0';\n\t}\n\n\tm_ExeDir.Format(_T(\"%s\\\\\"), tmp);\n\tm_ThemeDir.Format(_T(\"%s\\\\%s\"), tmp, THEME_DIR);\n\tm_LangDir.Format(_T(\"%s\\\\%s\"), tmp, LANGUAGE_DIR);\n//\tm_GadgetDir.Format(_T(\"%s\\\\%s\"), tmp, GADGET_DIR);\n\n\t// Smart folder\n\tTCHAR smartDir[MAX_PATH] = {};\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"SmartDir\"), _T(\"\"), smartDir, MAX_PATH, m_Ini);\n\tif (_tcscmp(smartDir, _T(\"\")) != 0 || CreateDirectory(smartDir, nullptr) || GetLastError() == ERROR_ALREADY_EXISTS) {\n\t\tm_SmartDir.Format(_T(\"%s\"), smartDir);\n\t\tif (m_SmartDir.Right(1).Compare(_T(\"\\\\\")) != 0) // Add \"\\\"\n\t\t{\n\t\t\tm_SmartDir.Format(_T(\"%s\\\\\"), smartDir);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Default path\n\t\tm_SmartDir.Format(_T(\"%s\\\\%s\"), tmp, SMART_DIR);\n\t}\n\n\tif (IsDotNet48())\n\t{\n\t\tm_AlertMailPath.Format(_T(\"%s\\\\%s\"), tmp, ALERT_MAIL_48_PATH);\n\t}\n\telse if(IsDotNet4())\n\t{\n\t\tm_AlertMailPath.Format(_T(\"%s\\\\%s\"), tmp, ALERT_MAIL_4_PATH);\n\t}\n\telse if(IsDotNet2())\n\t{\n\t\tm_AlertMailPath.Format(_T(\"%s\\\\%s\"), tmp, ALERT_MAIL_PATH);\n\t}\n\telse\n\t{\n\t\tm_AlertMailPath = _T(\"\");\n\t}\n\tm_OpusDecPath.Format(_T(\"%s\\\\%s\"), tmp, OPUS_DEC_PATH);\n\n#ifdef SUISHO_AOI_SUPPORT\n\tTCHAR str[256];\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"Language\"), _T(\"\"), str, 256, m_Ini);\n\tcstr = str;\n\n\tif (cstr.IsEmpty()) // First Time\n\t{\n\t\tif (GetUserDefaultLCID() == 0x0411)// Japanese\n\t\t{\n\t\t\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"VoiceLanguage\"), _T(\"Japanese\"), str, 256, m_Ini);\n\t\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"VoiceLanguage\"), _T(\"Japanese\"), m_Ini);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"VoiceLanguage\"), _T(\"English\"), str, 256, m_Ini);\n\t\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"VoiceLanguage\"), _T(\"English\"), m_Ini);\n\t\t}\n\t}\n\telse\n\t{\n\t\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"VoiceLanguage\"), _T(\"Japanese\"), str, 256, m_Ini);\n\t}\n\t\t\n\tm_VoiceLanguage = str;\n\tif (m_VoiceLanguage.Find(L\"Japanese\") == 0)\n\t{\n\t\tm_VoicePath.Format(_T(\"%s\\\\%s\"), tmp, AOI_VOICE_JA_PATH);\n\t}\n\telse\n\t{\n\t\tm_VoicePath.Format(_T(\"%s\\\\%s\"), tmp, AOI_VOICE_EN_PATH);\n\t}\n\n#elif MSI_MEI_SUPPORT\n\tm_VoicePath.Format(_T(\"%s\\\\%s\"), tmp, MSI_MEI_VOICE_PATH);\n#elif KUREI_KEI_SUPPORT\n\tm_VoicePath.Format(_T(\"%s\\\\%s\"), tmp, KUREI_KEI_VOICE_PATH);\n#elif SUISHO_SHIZUKU_SUPPORT\n\tm_VoicePath.Format(_T(\"%s\\\\%s\"), tmp, SHIZUKU_VOICE_PATH);\n#endif\n\t\n\tm_ThemeIndex = MENU_THEME_INDEX;\n\tm_LangIndex = MENU_LANG_INDEX;\n\n\tDefaultTheme.Format(_T(\"%s\\\\%s\"), m_ThemeDir.GetString(), DEFAULT_THEME);\n\tDefaultLanguage.Format(_T(\"%s\\\\%s.lang\"), m_LangDir.GetString(), DEFAULT_LANGUAGE);\n\n\tif((BOOL)GetPrivateProfileInt(_T(\"Workaround\"), _T(\"IE8MODE\"), 0, m_Ini))\n\t{\n\t\tm_GraphDlgPath.Format(_T(\"%s\\\\\") DIALOG_DIR GRAPH_DIALOG_IE8, tmp);\n\n\t\tif(! IsFileExistEx(m_GraphDlgPath, GRAPH_DIALOG_IE8))\t\t{\treturn FALSE;\t}\n\t}\n\telse\n\t{\n\t\tm_GraphDlgPath.Format(_T(\"%s\\\\\") DIALOG_DIR GRAPH_DIALOG, tmp);\n\t\tif(! IsFileExistEx(m_GraphDlgPath, GRAPH_DIALOG))\t\t\t{\treturn FALSE;\t}\n\t}\n\n\tm_OptionDlgPath.Format(_T(\"%s\\\\\") DIALOG_DIR OPTION_DIALOG, tmp);\n\n//\tif(! IsFileExistEx(DefaultTheme, DEFAULT_THEME))\t\t\t\t{\treturn FALSE;\t}\n\tif(! IsFileExistEx(DefaultLanguage, DEFAULT_LANGUAGE))\t\t\t{\treturn FALSE;\t}\n\n\tif(! IsUserAnAdmin())\n\t{\n\t\tif( ! IsWindowsVersionOrGreaterFx(6, 0))\n\t\t{\n\t\t\tAfxMessageBox(_T(\"CrystalDiskInfo is required Administrator Privileges.\"));\n\t\t}\n\t\tRunAsRestart();\n\t\treturn FALSE;\n\t}\n\n\tBOOL flagAfxOleInit = FALSE;\n\n\tif(flagEarthlight)\n\t{\n\t\tCGraphDlg dlg(NULL, defaultDisk);\n\t\tm_pMainWnd = &dlg;\n\t\tdlg.DoModal();\n\t}\n\telse\n\t{\n\t\t// No Server Busy Dialog!!\n  \t\tDebugPrint(_T(\"AfxOleInit()\"));\n\t\tif(AfxOleInit())\n\t\t{\n\t\t\tflagAfxOleInit = TRUE;\n\t\t\tDebugPrint(_T(\"AfxOleGetMessageFilter()->SetMessagePendingDelay\"));\n\t\t\tAfxOleGetMessageFilter()->SetMessagePendingDelay(60 * 1000);\n\t\t\tDebugPrint(_T(\"AfxOleGetMessageFilter()->EnableNotRespondingDialog(FALSE)\"));\n\t\t\tAfxOleGetMessageFilter()->EnableNotRespondingDialog(FALSE);\n\t\t\tDebugPrint(_T(\"AfxOleGetMessageFilter()->EnableBusyDialog(FALSE)\"));\n\t\t\tAfxOleGetMessageFilter()->EnableBusyDialog(FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebugPrint(_T(\"CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\"));\n\t\t\t(void)CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\n\t\t}\n\n\t\tCDiskInfoDlg dlg(NULL, flagStartupExit);\n\t\tm_pMainWnd = &dlg;\n\n\t\tBOOL flagReExec = FALSE;\n\n\t\tDebugPrint(_T(\"dlg.DoModal()\"));\n\t\tif(dlg.DoModal() == RE_EXEC)\n\t\t{\n\t\t\tflagReExec = TRUE;\n\t\t}\n\n\t\tsafeCloseHandle(hMutex);\n\n\t\tif(flagReExec)\n\t\t{\n\t\t\tTCHAR str[MAX_PATH];\n\t\t\t::GetModuleFileName(NULL, str, MAX_PATH);\n\t\t\tShellExecute(NULL, NULL, str, NULL, NULL, SW_SHOWNORMAL);\n\t\t}\n\t}\n\n\tif(! flagAfxOleInit)\n\t{\n\t\tDebugPrint(_T(\"CoUninitialize();\"));\n\t\tCoUninitialize();\n\t}\n\t/**/\n\treturn FALSE;\n}\n\nBOOL IsFileExistEx(const TCHAR* path, const TCHAR* fileName)\n{\n\tif(! IsFileExist(path))\n\t{\n\t\tCString cstr;\n\t\tcstr.Format(_T(\"Not Found \\\"%s\\\".\"), fileName); \n\t\tAfxMessageBox(cstr);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL RunAsRestart()\n{\n\tint count;\n#ifdef _UNICODE\n\tTCHAR** cmd = ::CommandLineToArgvW(::GetCommandLine(), &count);\n#else\n\tTCHAR** cmd = ::__argv;\n\tcount = ::__argc;\n#endif\n\n\tif(count < 2 || _tcscmp(cmd[1], _T(\"runas\")) != 0)\n\t{\n\t\tTCHAR path[MAX_PATH];\n\t\t::GetModuleFileName(NULL, path, MAX_PATH);\n\t\tif(::ShellExecute(NULL, _T(\"runas\"), path, _T(\"runas\"), NULL, SW_SHOWNORMAL)\n\t\t\t> (HINSTANCE)32)\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}"
        },
        {
          "name": "DiskInfo.h",
          "type": "blob",
          "size": 2.6064453125,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n#pragma once\n\n#ifndef __AFXWIN_H__\n\t#error \"include 'stdafx.h' before including this file for PCH\"\n#endif\n\n#include \"Resource.h\"\t\t// main symbols\n\n// #define THEME_DIR\t\t\t\t\t_T(\"CdiResource\\\\themes\\\\\")\n// #define LANGUAGE_DIR\t\t\t\t_T(\"CdiResource\\\\language\\\\\")\n#define DIALOG_DIR\t\t\t\t\t_T(\"CdiResource\\\\dialog\\\\\")\n// #define GADGET_DIR\t\t\t\t\t_T(\"CdiResource\\\\gadget\\\\\")\n#define SMART_DIR\t\t\t\t\t_T(\"Smart\\\\\")\n#define SMART_INI\t\t\t\t\t_T(\"Smart.ini\")\n#define EXCHANGE_INI\t\t\t\t_T(\"Exchange.ini\")\n#define ALARM_HISTORY_CSV\t\t\t_T(\"AlarmHistory.csv\")\n#define ALERT_MAIL_PATH\t\t\t\t_T(\"CdiResource\\\\AlertMail.exe\")\n#define ALERT_MAIL_4_PATH\t\t\t_T(\"CdiResource\\\\AlertMail4.exe\")\n#define ALERT_MAIL_48_PATH\t\t\t_T(\"CdiResource\\\\AlertMail48.exe\")\n#define OPUS_DEC_PATH\t\t\t\t_T(\"CdiResource\\\\opus\\\\opusdec.exe\")\n#define SHIZUKU_VOICE_PATH\t\t\t_T(\"CdiResource\\\\voice\\\\ShizukuVoice.dll\")\n#define KUREI_KEI_VOICE_PATH\t\t_T(\"CdiResource\\\\voice\\\\KureiKeiVoice.dll\")\n#define MSI_MEI_VOICE_PATH\t\t\t_T(\"CdiResource\\\\voice\\\\MSIMeiVoice.dll\")\n#define AOI_VOICE_JA_PATH\t\t\t_T(\"CdiResource\\\\voice\\\\AoiVoice-ja.dll\")\n#define AOI_VOICE_EN_PATH\t\t\t_T(\"CdiResource\\\\voice\\\\AoiVoice-en.dll\")\n\n#define MENU_THEME_INDEX\t\t\t3\n#define MENU_LANG_INDEX\t\t\t\t6\n#define MENU_DRIVE_INDEX\t\t\t4\n\n#define GRAPH_DIALOG\t\t\t\t_T(\"Graph.html\")\n#define GRAPH_DIALOG_IE8\t\t\t_T(\"Graph8.html\")\n#define OPTION_DIALOG\t\t\t\t_T(\"Option.html\")\n\n#ifdef SUISHO_AOI_SUPPORT\n\t#define PROJECT_COPYRIGHT   L\"AoiCopyright\"\n#elif MSI_MEI_SUPPORT\n\t#define PROJECT_COPYRIGHT   L\"Copyright\"\n#elif KUREI_KEI_SUPPORT\n\t#define PROJECT_COPYRIGHT   L\"KureiKeiCopyright\"\n#else SUISHO_SHIZUKU_SUPPORT\n\t#define PROJECT_COPYRIGHT   L\"ShizukuCopyright\"\n#endif\n\nclass CDiskInfoApp : public CWinApp\n{\npublic:\n\tCDiskInfoApp();\n\t~CDiskInfoApp();\n\n\tULONG_PTR gdiplusToken{};\n\n\tCString m_GraphDlgPath;\n\tCString m_OptionDlgPath;\n\tCString m_SmartDir;\n\tCString m_ExeDir;\n//\tCString m_GadgetDir;\n\tCString m_AlertMailPath;\n\tCString m_OpusDecPath;\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tCString m_VoicePath;\n#endif\n#ifdef SUISHO_AOI_SUPPORT\n\tCString m_VoiceLanguage;\n#endif\n\tCString m_Ini;\n\tCString m_Txt;\n\tCString m_SaveAsText;\n\tBOOL m_bCopyExit{};\n\n\tCString m_ThemeDir;\n\tCString m_LangDir;\n\tDWORD m_ThemeIndex{};\n\tDWORD m_LangIndex{};\n\n// Overrides\n\tpublic:\n\tvirtual BOOL InitInstance();\n\n\tprivate:\n\tHANDLE hMutex{};\n\n// Implementation\n\n\tDECLARE_MESSAGE_MAP()\n};\n\nextern CDiskInfoApp theApp;"
        },
        {
          "name": "DiskInfo.rc",
          "type": "blob",
          "size": 74.3916015625,
          "content": "// Microsoft Visual C++ generated resource script.\n//\n#include \"resource.h\"\n\n#define APSTUDIO_READONLY_SYMBOLS\n/////////////////////////////////////////////////////////////////////////////\n//\n// Generated from the TEXTINCLUDE 2 resource.\n//\n#include \"afxres.h\"\n#include \"CompileOptions.h\"\n\n/////////////////////////////////////////////////////////////////////////////\n#undef APSTUDIO_READONLY_SYMBOLS\n\n/////////////////////////////////////////////////////////////////////////////\n// 日本語 (日本) resources\n\n#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_JPN)\nLANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT\n#pragma code_page(932)\n\n#ifdef APSTUDIO_INVOKED\n/////////////////////////////////////////////////////////////////////////////\n//\n// TEXTINCLUDE\n//\n\n1 TEXTINCLUDE \nBEGIN\n    \"resource.h\\0\"\nEND\n\n2 TEXTINCLUDE \nBEGIN\n    \"#include \"\"afxres.h\"\"\\r\\n\"\n    \"\\0\"\nEND\n\n3 TEXTINCLUDE \nBEGIN\n    \"#define _AFX_NO_SPLITTER_RESOURCES\\r\\n\"\n    \"#define _AFX_NO_OLE_RESOURCES\\r\\n\"\n    \"#define _AFX_NO_TRACKER_RESOURCES\\r\\n\"\n    \"#define _AFX_NO_PROPERTY_RESOURCES\\r\\n\"\n    \"\\r\\n\"\n    \"#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_JPN)\\r\\n\"\n    \"LANGUAGE 17, 1\\r\\n\"\n    \"#pragma code_page(932)\\r\\n\"\n    \"#include \"\"res\\\\DiskInfo.rc2\"\"  // non-Microsoft Visual C++ edited resources\\r\\n\"\n    \"#include \"\"afxres.rc\"\"     // Standard components\\r\\n\"\n    \"#endif\\r\\n\"\n    \"\\0\"\nEND\n\n#endif    // APSTUDIO_INVOKED\n\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// Icon\n//\n\n// Icon with lowest ID value placed first to ensure application icon\n// remains consistent on all systems.\n#ifdef SUISHO_AOI_SUPPORT\n\tIDR_MAINFRAME           ICON                \"resA\\\\DiskInfo.ico\"\n\tIDI_MINI_ICON           ICON                \"resA\\\\DiskInfo16.ico\"\n#elif MSI_MEI_SUPPORT\n    IDR_MAINFRAME           ICON                \"resM\\\\DiskInfo.ico\"\n    IDI_MINI_ICON           ICON                \"resM\\\\DiskInfo16.ico\"\n#elif KUREI_KEI_SUPPORT\n    IDR_MAINFRAME           ICON                \"resK\\\\DiskInfo.ico\"\n    IDI_MINI_ICON           ICON                \"resK\\\\DiskInfo16.ico\"\n#elif SUISHO_SHIZUKU_SUPPORT  \n\tIDR_MAINFRAME           ICON                \"resS\\\\DiskInfo.ico\"\n\tIDI_MINI_ICON           ICON                \"resS\\\\DiskInfo16.ico\"\n#else\n    IDR_MAINFRAME           ICON                \"resN\\\\DiskInfo.ico\"\n    IDI_MINI_ICON           ICON                \"resN\\\\DiskInfo16.ico\"\n#endif\n\nIDI_GOOD                 ICON                    \"res\\\\good.ico\"\nIDI_GOOD_GREEN           ICON                    \"res\\\\goodGreen.ico\"\nIDI_CAUTION              ICON                    \"res\\\\caution.ico\"\nIDI_BAD                  ICON                    \"res\\\\bad.ico\"\nIDI_UNKNOWN              ICON                    \"res\\\\unknown.ico\"\n\nIDI_TEMP_BC01            ICON                    \"res\\\\B001.ico\"\nIDI_TEMP_BC02            ICON                    \"res\\\\B002.ico\"\nIDI_TEMP_BC03            ICON                    \"res\\\\B003.ico\"\nIDI_TEMP_BC04            ICON                    \"res\\\\B004.ico\"\nIDI_TEMP_BC05            ICON                    \"res\\\\B005.ico\"\nIDI_TEMP_BC06            ICON                    \"res\\\\B006.ico\"\nIDI_TEMP_BC07            ICON                    \"res\\\\B007.ico\"\nIDI_TEMP_BC08            ICON                    \"res\\\\B008.ico\"\nIDI_TEMP_BC09            ICON                    \"res\\\\B009.ico\"\nIDI_TEMP_BC10            ICON                    \"res\\\\B010.ico\"\nIDI_TEMP_BC11            ICON                    \"res\\\\B011.ico\"\nIDI_TEMP_BC12            ICON                    \"res\\\\B012.ico\"\nIDI_TEMP_BC13            ICON                    \"res\\\\B013.ico\"\nIDI_TEMP_BC14            ICON                    \"res\\\\B014.ico\"\nIDI_TEMP_BC15            ICON                    \"res\\\\B015.ico\"\nIDI_TEMP_BC16            ICON                    \"res\\\\B016.ico\"\nIDI_TEMP_BC17            ICON                    \"res\\\\B017.ico\"\nIDI_TEMP_BC18            ICON                    \"res\\\\B018.ico\"\nIDI_TEMP_BC19            ICON                    \"res\\\\B019.ico\"\nIDI_TEMP_BC20            ICON                    \"res\\\\B020.ico\"\nIDI_TEMP_BC21            ICON                    \"res\\\\B021.ico\"\nIDI_TEMP_BC22            ICON                    \"res\\\\B022.ico\"\nIDI_TEMP_BC23            ICON                    \"res\\\\B023.ico\"\nIDI_TEMP_BC24            ICON                    \"res\\\\B024.ico\"\nIDI_TEMP_BC25            ICON                    \"res\\\\B025.ico\"\nIDI_TEMP_BC26            ICON                    \"res\\\\B026.ico\"\nIDI_TEMP_BC27            ICON                    \"res\\\\B027.ico\"\nIDI_TEMP_BC28            ICON                    \"res\\\\B028.ico\"\nIDI_TEMP_BC29            ICON                    \"res\\\\B029.ico\"\nIDI_TEMP_BC30            ICON                    \"res\\\\B030.ico\"\nIDI_TEMP_BC31            ICON                    \"res\\\\B031.ico\"\nIDI_TEMP_BC32            ICON                    \"res\\\\B032.ico\"\nIDI_TEMP_BC33            ICON                    \"res\\\\B033.ico\"\nIDI_TEMP_BC34            ICON                    \"res\\\\B034.ico\"\nIDI_TEMP_BC35            ICON                    \"res\\\\B035.ico\"\nIDI_TEMP_BC36            ICON                    \"res\\\\B036.ico\"\nIDI_TEMP_BC37            ICON                    \"res\\\\B037.ico\"\nIDI_TEMP_BC38            ICON                    \"res\\\\B038.ico\"\nIDI_TEMP_BC39            ICON                    \"res\\\\B039.ico\"\nIDI_TEMP_BC40            ICON                    \"res\\\\B040.ico\"\nIDI_TEMP_BC41            ICON                    \"res\\\\B041.ico\"\nIDI_TEMP_BC42            ICON                    \"res\\\\B042.ico\"\nIDI_TEMP_BC43            ICON                    \"res\\\\B043.ico\"\nIDI_TEMP_BC44            ICON                    \"res\\\\B044.ico\"\nIDI_TEMP_BC45            ICON                    \"res\\\\B045.ico\"\nIDI_TEMP_BC46            ICON                    \"res\\\\B046.ico\"\nIDI_TEMP_BC47            ICON                    \"res\\\\B047.ico\"\nIDI_TEMP_BC48            ICON                    \"res\\\\B048.ico\"\nIDI_TEMP_BC49            ICON                    \"res\\\\B049.ico\"\nIDI_TEMP_BC50            ICON                    \"res\\\\B050.ico\"\nIDI_TEMP_BC51            ICON                    \"res\\\\B051.ico\"\nIDI_TEMP_BC52            ICON                    \"res\\\\B052.ico\"\nIDI_TEMP_BC53            ICON                    \"res\\\\B053.ico\"\nIDI_TEMP_BC54            ICON                    \"res\\\\B054.ico\"\nIDI_TEMP_BC55            ICON                    \"res\\\\B055.ico\"\nIDI_TEMP_BC56            ICON                    \"res\\\\B056.ico\"\nIDI_TEMP_BC57            ICON                    \"res\\\\B057.ico\"\nIDI_TEMP_BC58            ICON                    \"res\\\\B058.ico\"\nIDI_TEMP_BC59            ICON                    \"res\\\\B059.ico\"\nIDI_TEMP_BC60            ICON                    \"res\\\\B060.ico\"\nIDI_TEMP_BC61            ICON                    \"res\\\\B061.ico\"\nIDI_TEMP_BC62            ICON                    \"res\\\\B062.ico\"\nIDI_TEMP_BC63            ICON                    \"res\\\\B063.ico\"\nIDI_TEMP_BC64            ICON                    \"res\\\\B064.ico\"\nIDI_TEMP_BC65            ICON                    \"res\\\\B065.ico\"\nIDI_TEMP_BC66            ICON                    \"res\\\\B066.ico\"\nIDI_TEMP_BC67            ICON                    \"res\\\\B067.ico\"\nIDI_TEMP_BC68            ICON                    \"res\\\\B068.ico\"\nIDI_TEMP_BC69            ICON                    \"res\\\\B069.ico\"\nIDI_TEMP_BC70            ICON                    \"res\\\\B070.ico\"\nIDI_TEMP_BC71            ICON                    \"res\\\\B071.ico\"\nIDI_TEMP_BC72            ICON                    \"res\\\\B072.ico\"\nIDI_TEMP_BC73            ICON                    \"res\\\\B073.ico\"\nIDI_TEMP_BC74            ICON                    \"res\\\\B074.ico\"\nIDI_TEMP_BC75            ICON                    \"res\\\\B075.ico\"\nIDI_TEMP_BC76            ICON                    \"res\\\\B076.ico\"\nIDI_TEMP_BC77            ICON                    \"res\\\\B077.ico\"\nIDI_TEMP_BC78            ICON                    \"res\\\\B078.ico\"\nIDI_TEMP_BC79            ICON                    \"res\\\\B079.ico\"\nIDI_TEMP_BC80            ICON                    \"res\\\\B080.ico\"\nIDI_TEMP_BC81            ICON                    \"res\\\\B081.ico\"\nIDI_TEMP_BC82            ICON                    \"res\\\\B082.ico\"\nIDI_TEMP_BC83            ICON                    \"res\\\\B083.ico\"\nIDI_TEMP_BC84            ICON                    \"res\\\\B084.ico\"\nIDI_TEMP_BC85            ICON                    \"res\\\\B085.ico\"\nIDI_TEMP_BC86            ICON                    \"res\\\\B086.ico\"\nIDI_TEMP_BC87            ICON                    \"res\\\\B087.ico\"\nIDI_TEMP_BC88            ICON                    \"res\\\\B088.ico\"\nIDI_TEMP_BC89            ICON                    \"res\\\\B089.ico\"\nIDI_TEMP_BC90            ICON                    \"res\\\\B090.ico\"\nIDI_TEMP_BC91            ICON                    \"res\\\\B091.ico\"\nIDI_TEMP_BC92            ICON                    \"res\\\\B092.ico\"\nIDI_TEMP_BC93            ICON                    \"res\\\\B093.ico\"\nIDI_TEMP_BC94            ICON                    \"res\\\\B094.ico\"\nIDI_TEMP_BC95            ICON                    \"res\\\\B095.ico\"\nIDI_TEMP_BC96            ICON                    \"res\\\\B096.ico\"\nIDI_TEMP_BC97            ICON                    \"res\\\\B097.ico\"\nIDI_TEMP_BC98            ICON                    \"res\\\\B098.ico\"\nIDI_TEMP_BC99            ICON                    \"res\\\\B099.ico\"\nIDI_TEMP_GC01            ICON                    \"res\\\\G001.ico\"\nIDI_TEMP_GC02            ICON                    \"res\\\\G002.ico\"\nIDI_TEMP_GC03            ICON                    \"res\\\\G003.ico\"\nIDI_TEMP_GC04            ICON                    \"res\\\\G004.ico\"\nIDI_TEMP_GC05            ICON                    \"res\\\\G005.ico\"\nIDI_TEMP_GC06            ICON                    \"res\\\\G006.ico\"\nIDI_TEMP_GC07            ICON                    \"res\\\\G007.ico\"\nIDI_TEMP_GC08            ICON                    \"res\\\\G008.ico\"\nIDI_TEMP_GC09            ICON                    \"res\\\\G009.ico\"\nIDI_TEMP_GC10            ICON                    \"res\\\\G010.ico\"\nIDI_TEMP_GC11            ICON                    \"res\\\\G011.ico\"\nIDI_TEMP_GC12            ICON                    \"res\\\\G012.ico\"\nIDI_TEMP_GC13            ICON                    \"res\\\\G013.ico\"\nIDI_TEMP_GC14            ICON                    \"res\\\\G014.ico\"\nIDI_TEMP_GC15            ICON                    \"res\\\\G015.ico\"\nIDI_TEMP_GC16            ICON                    \"res\\\\G016.ico\"\nIDI_TEMP_GC17            ICON                    \"res\\\\G017.ico\"\nIDI_TEMP_GC18            ICON                    \"res\\\\G018.ico\"\nIDI_TEMP_GC19            ICON                    \"res\\\\G019.ico\"\nIDI_TEMP_GC20            ICON                    \"res\\\\G020.ico\"\nIDI_TEMP_GC21            ICON                    \"res\\\\G021.ico\"\nIDI_TEMP_GC22            ICON                    \"res\\\\G022.ico\"\nIDI_TEMP_GC23            ICON                    \"res\\\\G023.ico\"\nIDI_TEMP_GC24            ICON                    \"res\\\\G024.ico\"\nIDI_TEMP_GC25            ICON                    \"res\\\\G025.ico\"\nIDI_TEMP_GC26            ICON                    \"res\\\\G026.ico\"\nIDI_TEMP_GC27            ICON                    \"res\\\\G027.ico\"\nIDI_TEMP_GC28            ICON                    \"res\\\\G028.ico\"\nIDI_TEMP_GC29            ICON                    \"res\\\\G029.ico\"\nIDI_TEMP_GC30            ICON                    \"res\\\\G030.ico\"\nIDI_TEMP_GC31            ICON                    \"res\\\\G031.ico\"\nIDI_TEMP_GC32            ICON                    \"res\\\\G032.ico\"\nIDI_TEMP_GC33            ICON                    \"res\\\\G033.ico\"\nIDI_TEMP_GC34            ICON                    \"res\\\\G034.ico\"\nIDI_TEMP_GC35            ICON                    \"res\\\\G035.ico\"\nIDI_TEMP_GC36            ICON                    \"res\\\\G036.ico\"\nIDI_TEMP_GC37            ICON                    \"res\\\\G037.ico\"\nIDI_TEMP_GC38            ICON                    \"res\\\\G038.ico\"\nIDI_TEMP_GC39            ICON                    \"res\\\\G039.ico\"\nIDI_TEMP_GC40            ICON                    \"res\\\\G040.ico\"\nIDI_TEMP_GC41            ICON                    \"res\\\\G041.ico\"\nIDI_TEMP_GC42            ICON                    \"res\\\\G042.ico\"\nIDI_TEMP_GC43            ICON                    \"res\\\\G043.ico\"\nIDI_TEMP_GC44            ICON                    \"res\\\\G044.ico\"\nIDI_TEMP_GC45            ICON                    \"res\\\\G045.ico\"\nIDI_TEMP_GC46            ICON                    \"res\\\\G046.ico\"\nIDI_TEMP_GC47            ICON                    \"res\\\\G047.ico\"\nIDI_TEMP_GC48            ICON                    \"res\\\\G048.ico\"\nIDI_TEMP_GC49            ICON                    \"res\\\\G049.ico\"\nIDI_TEMP_GC50            ICON                    \"res\\\\G050.ico\"\nIDI_TEMP_GC51            ICON                    \"res\\\\G051.ico\"\nIDI_TEMP_GC52            ICON                    \"res\\\\G052.ico\"\nIDI_TEMP_GC53            ICON                    \"res\\\\G053.ico\"\nIDI_TEMP_GC54            ICON                    \"res\\\\G054.ico\"\nIDI_TEMP_GC55            ICON                    \"res\\\\G055.ico\"\nIDI_TEMP_GC56            ICON                    \"res\\\\G056.ico\"\nIDI_TEMP_GC57            ICON                    \"res\\\\G057.ico\"\nIDI_TEMP_GC58            ICON                    \"res\\\\G058.ico\"\nIDI_TEMP_GC59            ICON                    \"res\\\\G059.ico\"\nIDI_TEMP_GC60            ICON                    \"res\\\\G060.ico\"\nIDI_TEMP_GC61            ICON                    \"res\\\\G061.ico\"\nIDI_TEMP_GC62            ICON                    \"res\\\\G062.ico\"\nIDI_TEMP_GC63            ICON                    \"res\\\\G063.ico\"\nIDI_TEMP_GC64            ICON                    \"res\\\\G064.ico\"\nIDI_TEMP_GC65            ICON                    \"res\\\\G065.ico\"\nIDI_TEMP_GC66            ICON                    \"res\\\\G066.ico\"\nIDI_TEMP_GC67            ICON                    \"res\\\\G067.ico\"\nIDI_TEMP_GC68            ICON                    \"res\\\\G068.ico\"\nIDI_TEMP_GC69            ICON                    \"res\\\\G069.ico\"\nIDI_TEMP_GC70            ICON                    \"res\\\\G070.ico\"\nIDI_TEMP_GC71            ICON                    \"res\\\\G071.ico\"\nIDI_TEMP_GC72            ICON                    \"res\\\\G072.ico\"\nIDI_TEMP_GC73            ICON                    \"res\\\\G073.ico\"\nIDI_TEMP_GC74            ICON                    \"res\\\\G074.ico\"\nIDI_TEMP_GC75            ICON                    \"res\\\\G075.ico\"\nIDI_TEMP_GC76            ICON                    \"res\\\\G076.ico\"\nIDI_TEMP_GC77            ICON                    \"res\\\\G077.ico\"\nIDI_TEMP_GC78            ICON                    \"res\\\\G078.ico\"\nIDI_TEMP_GC79            ICON                    \"res\\\\G079.ico\"\nIDI_TEMP_GC80            ICON                    \"res\\\\G080.ico\"\nIDI_TEMP_GC81            ICON                    \"res\\\\G081.ico\"\nIDI_TEMP_GC82            ICON                    \"res\\\\G082.ico\"\nIDI_TEMP_GC83            ICON                    \"res\\\\G083.ico\"\nIDI_TEMP_GC84            ICON                    \"res\\\\G084.ico\"\nIDI_TEMP_GC85            ICON                    \"res\\\\G085.ico\"\nIDI_TEMP_GC86            ICON                    \"res\\\\G086.ico\"\nIDI_TEMP_GC87            ICON                    \"res\\\\G087.ico\"\nIDI_TEMP_GC88            ICON                    \"res\\\\G088.ico\"\nIDI_TEMP_GC89            ICON                    \"res\\\\G089.ico\"\nIDI_TEMP_GC90            ICON                    \"res\\\\G090.ico\"\nIDI_TEMP_GC91            ICON                    \"res\\\\G091.ico\"\nIDI_TEMP_GC92            ICON                    \"res\\\\G092.ico\"\nIDI_TEMP_GC93            ICON                    \"res\\\\G093.ico\"\nIDI_TEMP_GC94            ICON                    \"res\\\\G094.ico\"\nIDI_TEMP_GC95            ICON                    \"res\\\\G095.ico\"\nIDI_TEMP_GC96            ICON                    \"res\\\\G096.ico\"\nIDI_TEMP_GC97            ICON                    \"res\\\\G097.ico\"\nIDI_TEMP_GC98            ICON                    \"res\\\\G098.ico\"\nIDI_TEMP_GC99            ICON                    \"res\\\\G099.ico\"\nIDI_TEMP_RC01            ICON                    \"res\\\\R001.ico\"\nIDI_TEMP_RC02            ICON                    \"res\\\\R002.ico\"\nIDI_TEMP_RC03            ICON                    \"res\\\\R003.ico\"\nIDI_TEMP_RC04            ICON                    \"res\\\\R004.ico\"\nIDI_TEMP_RC05            ICON                    \"res\\\\R005.ico\"\nIDI_TEMP_RC06            ICON                    \"res\\\\R006.ico\"\nIDI_TEMP_RC07            ICON                    \"res\\\\R007.ico\"\nIDI_TEMP_RC08            ICON                    \"res\\\\R008.ico\"\nIDI_TEMP_RC09            ICON                    \"res\\\\R009.ico\"\nIDI_TEMP_RC10            ICON                    \"res\\\\R010.ico\"\nIDI_TEMP_RC11            ICON                    \"res\\\\R011.ico\"\nIDI_TEMP_RC12            ICON                    \"res\\\\R012.ico\"\nIDI_TEMP_RC13            ICON                    \"res\\\\R013.ico\"\nIDI_TEMP_RC14            ICON                    \"res\\\\R014.ico\"\nIDI_TEMP_RC15            ICON                    \"res\\\\R015.ico\"\nIDI_TEMP_RC16            ICON                    \"res\\\\R016.ico\"\nIDI_TEMP_RC17            ICON                    \"res\\\\R017.ico\"\nIDI_TEMP_RC18            ICON                    \"res\\\\R018.ico\"\nIDI_TEMP_RC19            ICON                    \"res\\\\R019.ico\"\nIDI_TEMP_RC20            ICON                    \"res\\\\R020.ico\"\nIDI_TEMP_RC21            ICON                    \"res\\\\R021.ico\"\nIDI_TEMP_RC22            ICON                    \"res\\\\R022.ico\"\nIDI_TEMP_RC23            ICON                    \"res\\\\R023.ico\"\nIDI_TEMP_RC24            ICON                    \"res\\\\R024.ico\"\nIDI_TEMP_RC25            ICON                    \"res\\\\R025.ico\"\nIDI_TEMP_RC26            ICON                    \"res\\\\R026.ico\"\nIDI_TEMP_RC27            ICON                    \"res\\\\R027.ico\"\nIDI_TEMP_RC28            ICON                    \"res\\\\R028.ico\"\nIDI_TEMP_RC29            ICON                    \"res\\\\R029.ico\"\nIDI_TEMP_RC30            ICON                    \"res\\\\R030.ico\"\nIDI_TEMP_RC31            ICON                    \"res\\\\R031.ico\"\nIDI_TEMP_RC32            ICON                    \"res\\\\R032.ico\"\nIDI_TEMP_RC33            ICON                    \"res\\\\R033.ico\"\nIDI_TEMP_RC34            ICON                    \"res\\\\R034.ico\"\nIDI_TEMP_RC35            ICON                    \"res\\\\R035.ico\"\nIDI_TEMP_RC36            ICON                    \"res\\\\R036.ico\"\nIDI_TEMP_RC37            ICON                    \"res\\\\R037.ico\"\nIDI_TEMP_RC38            ICON                    \"res\\\\R038.ico\"\nIDI_TEMP_RC39            ICON                    \"res\\\\R039.ico\"\nIDI_TEMP_RC40            ICON                    \"res\\\\R040.ico\"\nIDI_TEMP_RC41            ICON                    \"res\\\\R041.ico\"\nIDI_TEMP_RC42            ICON                    \"res\\\\R042.ico\"\nIDI_TEMP_RC43            ICON                    \"res\\\\R043.ico\"\nIDI_TEMP_RC44            ICON                    \"res\\\\R044.ico\"\nIDI_TEMP_RC45            ICON                    \"res\\\\R045.ico\"\nIDI_TEMP_RC46            ICON                    \"res\\\\R046.ico\"\nIDI_TEMP_RC47            ICON                    \"res\\\\R047.ico\"\nIDI_TEMP_RC48            ICON                    \"res\\\\R048.ico\"\nIDI_TEMP_RC49            ICON                    \"res\\\\R049.ico\"\nIDI_TEMP_RC50            ICON                    \"res\\\\R050.ico\"\nIDI_TEMP_RC51            ICON                    \"res\\\\R051.ico\"\nIDI_TEMP_RC52            ICON                    \"res\\\\R052.ico\"\nIDI_TEMP_RC53            ICON                    \"res\\\\R053.ico\"\nIDI_TEMP_RC54            ICON                    \"res\\\\R054.ico\"\nIDI_TEMP_RC55            ICON                    \"res\\\\R055.ico\"\nIDI_TEMP_RC56            ICON                    \"res\\\\R056.ico\"\nIDI_TEMP_RC57            ICON                    \"res\\\\R057.ico\"\nIDI_TEMP_RC58            ICON                    \"res\\\\R058.ico\"\nIDI_TEMP_RC59            ICON                    \"res\\\\R059.ico\"\nIDI_TEMP_RC60            ICON                    \"res\\\\R060.ico\"\nIDI_TEMP_RC61            ICON                    \"res\\\\R061.ico\"\nIDI_TEMP_RC62            ICON                    \"res\\\\R062.ico\"\nIDI_TEMP_RC63            ICON                    \"res\\\\R063.ico\"\nIDI_TEMP_RC64            ICON                    \"res\\\\R064.ico\"\nIDI_TEMP_RC65            ICON                    \"res\\\\R065.ico\"\nIDI_TEMP_RC66            ICON                    \"res\\\\R066.ico\"\nIDI_TEMP_RC67            ICON                    \"res\\\\R067.ico\"\nIDI_TEMP_RC68            ICON                    \"res\\\\R068.ico\"\nIDI_TEMP_RC69            ICON                    \"res\\\\R069.ico\"\nIDI_TEMP_RC70            ICON                    \"res\\\\R070.ico\"\nIDI_TEMP_RC71            ICON                    \"res\\\\R071.ico\"\nIDI_TEMP_RC72            ICON                    \"res\\\\R072.ico\"\nIDI_TEMP_RC73            ICON                    \"res\\\\R073.ico\"\nIDI_TEMP_RC74            ICON                    \"res\\\\R074.ico\"\nIDI_TEMP_RC75            ICON                    \"res\\\\R075.ico\"\nIDI_TEMP_RC76            ICON                    \"res\\\\R076.ico\"\nIDI_TEMP_RC77            ICON                    \"res\\\\R077.ico\"\nIDI_TEMP_RC78            ICON                    \"res\\\\R078.ico\"\nIDI_TEMP_RC79            ICON                    \"res\\\\R079.ico\"\nIDI_TEMP_RC80            ICON                    \"res\\\\R080.ico\"\nIDI_TEMP_RC81            ICON                    \"res\\\\R081.ico\"\nIDI_TEMP_RC82            ICON                    \"res\\\\R082.ico\"\nIDI_TEMP_RC83            ICON                    \"res\\\\R083.ico\"\nIDI_TEMP_RC84            ICON                    \"res\\\\R084.ico\"\nIDI_TEMP_RC85            ICON                    \"res\\\\R085.ico\"\nIDI_TEMP_RC86            ICON                    \"res\\\\R086.ico\"\nIDI_TEMP_RC87            ICON                    \"res\\\\R087.ico\"\nIDI_TEMP_RC88            ICON                    \"res\\\\R088.ico\"\nIDI_TEMP_RC89            ICON                    \"res\\\\R089.ico\"\nIDI_TEMP_RC90            ICON                    \"res\\\\R090.ico\"\nIDI_TEMP_RC91            ICON                    \"res\\\\R091.ico\"\nIDI_TEMP_RC92            ICON                    \"res\\\\R092.ico\"\nIDI_TEMP_RC93            ICON                    \"res\\\\R093.ico\"\nIDI_TEMP_RC94            ICON                    \"res\\\\R094.ico\"\nIDI_TEMP_RC95            ICON                    \"res\\\\R095.ico\"\nIDI_TEMP_RC96            ICON                    \"res\\\\R096.ico\"\nIDI_TEMP_RC97            ICON                    \"res\\\\R097.ico\"\nIDI_TEMP_RC98            ICON                    \"res\\\\R098.ico\"\nIDI_TEMP_RC99            ICON                    \"res\\\\R099.ico\"\nIDI_TEMP_BF01            ICON                    \"res\\\\B033.ico\"\nIDI_TEMP_BF02            ICON                    \"res\\\\B035.ico\"\nIDI_TEMP_BF03            ICON                    \"res\\\\B037.ico\"\nIDI_TEMP_BF04            ICON                    \"res\\\\B039.ico\"\nIDI_TEMP_BF05            ICON                    \"res\\\\B041.ico\"\nIDI_TEMP_BF06            ICON                    \"res\\\\B042.ico\"\nIDI_TEMP_BF07            ICON                    \"res\\\\B044.ico\"\nIDI_TEMP_BF08            ICON                    \"res\\\\B046.ico\"\nIDI_TEMP_BF09            ICON                    \"res\\\\B048.ico\"\nIDI_TEMP_BF10            ICON                    \"res\\\\B050.ico\"\nIDI_TEMP_BF11            ICON                    \"res\\\\B051.ico\"\nIDI_TEMP_BF12            ICON                    \"res\\\\B053.ico\"\nIDI_TEMP_BF13            ICON                    \"res\\\\B055.ico\"\nIDI_TEMP_BF14            ICON                    \"res\\\\B057.ico\"\nIDI_TEMP_BF15            ICON                    \"res\\\\B059.ico\"\nIDI_TEMP_BF16            ICON                    \"res\\\\B060.ico\"\nIDI_TEMP_BF17            ICON                    \"res\\\\B062.ico\"\nIDI_TEMP_BF18            ICON                    \"res\\\\B064.ico\"\nIDI_TEMP_BF19            ICON                    \"res\\\\B066.ico\"\nIDI_TEMP_BF20            ICON                    \"res\\\\B068.ico\"\nIDI_TEMP_BF21            ICON                    \"res\\\\B069.ico\"\nIDI_TEMP_BF22            ICON                    \"res\\\\B071.ico\"\nIDI_TEMP_BF23            ICON                    \"res\\\\B073.ico\"\nIDI_TEMP_BF24            ICON                    \"res\\\\B075.ico\"\nIDI_TEMP_BF25            ICON                    \"res\\\\B077.ico\"\nIDI_TEMP_BF26            ICON                    \"res\\\\B078.ico\"\nIDI_TEMP_BF27            ICON                    \"res\\\\B080.ico\"\nIDI_TEMP_BF28            ICON                    \"res\\\\B082.ico\"\nIDI_TEMP_BF29            ICON                    \"res\\\\B084.ico\"\nIDI_TEMP_BF30            ICON                    \"res\\\\B086.ico\"\nIDI_TEMP_BF31            ICON                    \"res\\\\B087.ico\"\nIDI_TEMP_BF32            ICON                    \"res\\\\B089.ico\"\nIDI_TEMP_BF33            ICON                    \"res\\\\B091.ico\"\nIDI_TEMP_BF34            ICON                    \"res\\\\B093.ico\"\nIDI_TEMP_BF35            ICON                    \"res\\\\B095.ico\"\nIDI_TEMP_BF36            ICON                    \"res\\\\B096.ico\"\nIDI_TEMP_BF37            ICON                    \"res\\\\B098.ico\"\nIDI_TEMP_BF38            ICON                    \"res\\\\B100.ico\"\nIDI_TEMP_BF39            ICON                    \"res\\\\B102.ico\"\nIDI_TEMP_BF40            ICON                    \"res\\\\B104.ico\"\nIDI_TEMP_BF41            ICON                    \"res\\\\B105.ico\"\nIDI_TEMP_BF42            ICON                    \"res\\\\B107.ico\"\nIDI_TEMP_BF43            ICON                    \"res\\\\B109.ico\"\nIDI_TEMP_BF44            ICON                    \"res\\\\B111.ico\"\nIDI_TEMP_BF45            ICON                    \"res\\\\B113.ico\"\nIDI_TEMP_BF46            ICON                    \"res\\\\B114.ico\"\nIDI_TEMP_BF47            ICON                    \"res\\\\B116.ico\"\nIDI_TEMP_BF48            ICON                    \"res\\\\B118.ico\"\nIDI_TEMP_BF49            ICON                    \"res\\\\B120.ico\"\nIDI_TEMP_BF50            ICON                    \"res\\\\B122.ico\"\nIDI_TEMP_BF51            ICON                    \"res\\\\B123.ico\"\nIDI_TEMP_BF52            ICON                    \"res\\\\B125.ico\"\nIDI_TEMP_BF53            ICON                    \"res\\\\B127.ico\"\nIDI_TEMP_BF54            ICON                    \"res\\\\B129.ico\"\nIDI_TEMP_BF55            ICON                    \"res\\\\B131.ico\"\nIDI_TEMP_BF56            ICON                    \"res\\\\B132.ico\"\nIDI_TEMP_BF57            ICON                    \"res\\\\B134.ico\"\nIDI_TEMP_BF58            ICON                    \"res\\\\B136.ico\"\nIDI_TEMP_BF59            ICON                    \"res\\\\B138.ico\"\nIDI_TEMP_BF60            ICON                    \"res\\\\B140.ico\"\nIDI_TEMP_BF61            ICON                    \"res\\\\B141.ico\"\nIDI_TEMP_BF62            ICON                    \"res\\\\B143.ico\"\nIDI_TEMP_BF63            ICON                    \"res\\\\B145.ico\"\nIDI_TEMP_BF64            ICON                    \"res\\\\B147.ico\"\nIDI_TEMP_BF65            ICON                    \"res\\\\B149.ico\"\nIDI_TEMP_BF66            ICON                    \"res\\\\B150.ico\"\nIDI_TEMP_BF67            ICON                    \"res\\\\B152.ico\"\nIDI_TEMP_BF68            ICON                    \"res\\\\B154.ico\"\nIDI_TEMP_BF69            ICON                    \"res\\\\B156.ico\"\nIDI_TEMP_BF70            ICON                    \"res\\\\B158.ico\"\nIDI_TEMP_BF71            ICON                    \"res\\\\B159.ico\"\nIDI_TEMP_BF72            ICON                    \"res\\\\B161.ico\"\nIDI_TEMP_BF73            ICON                    \"res\\\\B163.ico\"\nIDI_TEMP_BF74            ICON                    \"res\\\\B165.ico\"\nIDI_TEMP_BF75            ICON                    \"res\\\\B167.ico\"\nIDI_TEMP_BF76            ICON                    \"res\\\\B168.ico\"\nIDI_TEMP_BF77            ICON                    \"res\\\\B170.ico\"\nIDI_TEMP_BF78            ICON                    \"res\\\\B172.ico\"\nIDI_TEMP_BF79            ICON                    \"res\\\\B174.ico\"\nIDI_TEMP_BF80            ICON                    \"res\\\\B176.ico\"\nIDI_TEMP_BF81            ICON                    \"res\\\\B177.ico\"\nIDI_TEMP_BF82            ICON                    \"res\\\\B179.ico\"\nIDI_TEMP_BF83            ICON                    \"res\\\\B181.ico\"\nIDI_TEMP_BF84            ICON                    \"res\\\\B183.ico\"\nIDI_TEMP_BF85            ICON                    \"res\\\\B185.ico\"\nIDI_TEMP_BF86            ICON                    \"res\\\\B186.ico\"\nIDI_TEMP_BF87            ICON                    \"res\\\\B188.ico\"\nIDI_TEMP_BF88            ICON                    \"res\\\\B190.ico\"\nIDI_TEMP_BF89            ICON                    \"res\\\\B192.ico\"\nIDI_TEMP_BF90            ICON                    \"res\\\\B194.ico\"\nIDI_TEMP_BF91            ICON                    \"res\\\\B195.ico\"\nIDI_TEMP_BF92            ICON                    \"res\\\\B197.ico\"\nIDI_TEMP_BF93            ICON                    \"res\\\\B199.ico\"\nIDI_TEMP_BF94            ICON                    \"res\\\\B201.ico\"\nIDI_TEMP_BF95            ICON                    \"res\\\\B203.ico\"\nIDI_TEMP_BF96            ICON                    \"res\\\\B204.ico\"\nIDI_TEMP_BF97            ICON                    \"res\\\\B206.ico\"\nIDI_TEMP_BF98            ICON                    \"res\\\\B208.ico\"\nIDI_TEMP_BF99            ICON                    \"res\\\\B210.ico\"\nIDI_TEMP_GF01            ICON                    \"res\\\\G033.ico\"\nIDI_TEMP_GF02            ICON                    \"res\\\\G035.ico\"\nIDI_TEMP_GF03            ICON                    \"res\\\\G037.ico\"\nIDI_TEMP_GF04            ICON                    \"res\\\\G039.ico\"\nIDI_TEMP_GF05            ICON                    \"res\\\\G041.ico\"\nIDI_TEMP_GF06            ICON                    \"res\\\\G042.ico\"\nIDI_TEMP_GF07            ICON                    \"res\\\\G044.ico\"\nIDI_TEMP_GF08            ICON                    \"res\\\\G046.ico\"\nIDI_TEMP_GF09            ICON                    \"res\\\\G048.ico\"\nIDI_TEMP_GF10            ICON                    \"res\\\\G050.ico\"\nIDI_TEMP_GF11            ICON                    \"res\\\\G051.ico\"\nIDI_TEMP_GF12            ICON                    \"res\\\\G053.ico\"\nIDI_TEMP_GF13            ICON                    \"res\\\\G055.ico\"\nIDI_TEMP_GF14            ICON                    \"res\\\\G057.ico\"\nIDI_TEMP_GF15            ICON                    \"res\\\\G059.ico\"\nIDI_TEMP_GF16            ICON                    \"res\\\\G060.ico\"\nIDI_TEMP_GF17            ICON                    \"res\\\\G062.ico\"\nIDI_TEMP_GF18            ICON                    \"res\\\\G064.ico\"\nIDI_TEMP_GF19            ICON                    \"res\\\\G066.ico\"\nIDI_TEMP_GF20            ICON                    \"res\\\\G068.ico\"\nIDI_TEMP_GF21            ICON                    \"res\\\\G069.ico\"\nIDI_TEMP_GF22            ICON                    \"res\\\\G071.ico\"\nIDI_TEMP_GF23            ICON                    \"res\\\\G073.ico\"\nIDI_TEMP_GF24            ICON                    \"res\\\\G075.ico\"\nIDI_TEMP_GF25            ICON                    \"res\\\\G077.ico\"\nIDI_TEMP_GF26            ICON                    \"res\\\\G078.ico\"\nIDI_TEMP_GF27            ICON                    \"res\\\\G080.ico\"\nIDI_TEMP_GF28            ICON                    \"res\\\\G082.ico\"\nIDI_TEMP_GF29            ICON                    \"res\\\\G084.ico\"\nIDI_TEMP_GF30            ICON                    \"res\\\\G086.ico\"\nIDI_TEMP_GF31            ICON                    \"res\\\\G087.ico\"\nIDI_TEMP_GF32            ICON                    \"res\\\\G089.ico\"\nIDI_TEMP_GF33            ICON                    \"res\\\\G091.ico\"\nIDI_TEMP_GF34            ICON                    \"res\\\\G093.ico\"\nIDI_TEMP_GF35            ICON                    \"res\\\\G095.ico\"\nIDI_TEMP_GF36            ICON                    \"res\\\\G096.ico\"\nIDI_TEMP_GF37            ICON                    \"res\\\\G098.ico\"\nIDI_TEMP_GF38            ICON                    \"res\\\\G100.ico\"\nIDI_TEMP_GF39            ICON                    \"res\\\\G102.ico\"\nIDI_TEMP_GF40            ICON                    \"res\\\\G104.ico\"\nIDI_TEMP_GF41            ICON                    \"res\\\\G105.ico\"\nIDI_TEMP_GF42            ICON                    \"res\\\\G107.ico\"\nIDI_TEMP_GF43            ICON                    \"res\\\\G109.ico\"\nIDI_TEMP_GF44            ICON                    \"res\\\\G111.ico\"\nIDI_TEMP_GF45            ICON                    \"res\\\\G113.ico\"\nIDI_TEMP_GF46            ICON                    \"res\\\\G114.ico\"\nIDI_TEMP_GF47            ICON                    \"res\\\\G116.ico\"\nIDI_TEMP_GF48            ICON                    \"res\\\\G118.ico\"\nIDI_TEMP_GF49            ICON                    \"res\\\\G120.ico\"\nIDI_TEMP_GF50            ICON                    \"res\\\\G122.ico\"\nIDI_TEMP_GF51            ICON                    \"res\\\\G123.ico\"\nIDI_TEMP_GF52            ICON                    \"res\\\\G125.ico\"\nIDI_TEMP_GF53            ICON                    \"res\\\\G127.ico\"\nIDI_TEMP_GF54            ICON                    \"res\\\\G129.ico\"\nIDI_TEMP_GF55            ICON                    \"res\\\\G131.ico\"\nIDI_TEMP_GF56            ICON                    \"res\\\\G132.ico\"\nIDI_TEMP_GF57            ICON                    \"res\\\\G134.ico\"\nIDI_TEMP_GF58            ICON                    \"res\\\\G136.ico\"\nIDI_TEMP_GF59            ICON                    \"res\\\\G138.ico\"\nIDI_TEMP_GF60            ICON                    \"res\\\\G140.ico\"\nIDI_TEMP_GF61            ICON                    \"res\\\\G141.ico\"\nIDI_TEMP_GF62            ICON                    \"res\\\\G143.ico\"\nIDI_TEMP_GF63            ICON                    \"res\\\\G145.ico\"\nIDI_TEMP_GF64            ICON                    \"res\\\\G147.ico\"\nIDI_TEMP_GF65            ICON                    \"res\\\\G149.ico\"\nIDI_TEMP_GF66            ICON                    \"res\\\\G150.ico\"\nIDI_TEMP_GF67            ICON                    \"res\\\\G152.ico\"\nIDI_TEMP_GF68            ICON                    \"res\\\\G154.ico\"\nIDI_TEMP_GF69            ICON                    \"res\\\\G156.ico\"\nIDI_TEMP_GF70            ICON                    \"res\\\\G158.ico\"\nIDI_TEMP_GF71            ICON                    \"res\\\\G159.ico\"\nIDI_TEMP_GF72            ICON                    \"res\\\\G161.ico\"\nIDI_TEMP_GF73            ICON                    \"res\\\\G163.ico\"\nIDI_TEMP_GF74            ICON                    \"res\\\\G165.ico\"\nIDI_TEMP_GF75            ICON                    \"res\\\\G167.ico\"\nIDI_TEMP_GF76            ICON                    \"res\\\\G168.ico\"\nIDI_TEMP_GF77            ICON                    \"res\\\\G170.ico\"\nIDI_TEMP_GF78            ICON                    \"res\\\\G172.ico\"\nIDI_TEMP_GF79            ICON                    \"res\\\\G174.ico\"\nIDI_TEMP_GF80            ICON                    \"res\\\\G176.ico\"\nIDI_TEMP_GF81            ICON                    \"res\\\\G177.ico\"\nIDI_TEMP_GF82            ICON                    \"res\\\\G179.ico\"\nIDI_TEMP_GF83            ICON                    \"res\\\\G181.ico\"\nIDI_TEMP_GF84            ICON                    \"res\\\\G183.ico\"\nIDI_TEMP_GF85            ICON                    \"res\\\\G185.ico\"\nIDI_TEMP_GF86            ICON                    \"res\\\\G186.ico\"\nIDI_TEMP_GF87            ICON                    \"res\\\\G188.ico\"\nIDI_TEMP_GF88            ICON                    \"res\\\\G190.ico\"\nIDI_TEMP_GF89            ICON                    \"res\\\\G192.ico\"\nIDI_TEMP_GF90            ICON                    \"res\\\\G194.ico\"\nIDI_TEMP_GF91            ICON                    \"res\\\\G195.ico\"\nIDI_TEMP_GF92            ICON                    \"res\\\\G197.ico\"\nIDI_TEMP_GF93            ICON                    \"res\\\\G199.ico\"\nIDI_TEMP_GF94            ICON                    \"res\\\\G201.ico\"\nIDI_TEMP_GF95            ICON                    \"res\\\\G203.ico\"\nIDI_TEMP_GF96            ICON                    \"res\\\\G204.ico\"\nIDI_TEMP_GF97            ICON                    \"res\\\\G206.ico\"\nIDI_TEMP_GF98            ICON                    \"res\\\\G208.ico\"\nIDI_TEMP_GF99            ICON                    \"res\\\\G210.ico\"\nIDI_TEMP_RF01            ICON                    \"res\\\\R033.ico\"\nIDI_TEMP_RF02            ICON                    \"res\\\\R035.ico\"\nIDI_TEMP_RF03            ICON                    \"res\\\\R037.ico\"\nIDI_TEMP_RF04            ICON                    \"res\\\\R039.ico\"\nIDI_TEMP_RF05            ICON                    \"res\\\\R041.ico\"\nIDI_TEMP_RF06            ICON                    \"res\\\\R042.ico\"\nIDI_TEMP_RF07            ICON                    \"res\\\\R044.ico\"\nIDI_TEMP_RF08            ICON                    \"res\\\\R046.ico\"\nIDI_TEMP_RF09            ICON                    \"res\\\\R048.ico\"\nIDI_TEMP_RF10            ICON                    \"res\\\\R050.ico\"\nIDI_TEMP_RF11            ICON                    \"res\\\\R051.ico\"\nIDI_TEMP_RF12            ICON                    \"res\\\\R053.ico\"\nIDI_TEMP_RF13            ICON                    \"res\\\\R055.ico\"\nIDI_TEMP_RF14            ICON                    \"res\\\\R057.ico\"\nIDI_TEMP_RF15            ICON                    \"res\\\\R059.ico\"\nIDI_TEMP_RF16            ICON                    \"res\\\\R060.ico\"\nIDI_TEMP_RF17            ICON                    \"res\\\\R062.ico\"\nIDI_TEMP_RF18            ICON                    \"res\\\\R064.ico\"\nIDI_TEMP_RF19            ICON                    \"res\\\\R066.ico\"\nIDI_TEMP_RF20            ICON                    \"res\\\\R068.ico\"\nIDI_TEMP_RF21            ICON                    \"res\\\\R069.ico\"\nIDI_TEMP_RF22            ICON                    \"res\\\\R071.ico\"\nIDI_TEMP_RF23            ICON                    \"res\\\\R073.ico\"\nIDI_TEMP_RF24            ICON                    \"res\\\\R075.ico\"\nIDI_TEMP_RF25            ICON                    \"res\\\\R077.ico\"\nIDI_TEMP_RF26            ICON                    \"res\\\\R078.ico\"\nIDI_TEMP_RF27            ICON                    \"res\\\\R080.ico\"\nIDI_TEMP_RF28            ICON                    \"res\\\\R082.ico\"\nIDI_TEMP_RF29            ICON                    \"res\\\\R084.ico\"\nIDI_TEMP_RF30            ICON                    \"res\\\\R086.ico\"\nIDI_TEMP_RF31            ICON                    \"res\\\\R087.ico\"\nIDI_TEMP_RF32            ICON                    \"res\\\\R089.ico\"\nIDI_TEMP_RF33            ICON                    \"res\\\\R091.ico\"\nIDI_TEMP_RF34            ICON                    \"res\\\\R093.ico\"\nIDI_TEMP_RF35            ICON                    \"res\\\\R095.ico\"\nIDI_TEMP_RF36            ICON                    \"res\\\\R096.ico\"\nIDI_TEMP_RF37            ICON                    \"res\\\\R098.ico\"\nIDI_TEMP_RF38            ICON                    \"res\\\\R100.ico\"\nIDI_TEMP_RF39            ICON                    \"res\\\\R102.ico\"\nIDI_TEMP_RF40            ICON                    \"res\\\\R104.ico\"\nIDI_TEMP_RF41            ICON                    \"res\\\\R105.ico\"\nIDI_TEMP_RF42            ICON                    \"res\\\\R107.ico\"\nIDI_TEMP_RF43            ICON                    \"res\\\\R109.ico\"\nIDI_TEMP_RF44            ICON                    \"res\\\\R111.ico\"\nIDI_TEMP_RF45            ICON                    \"res\\\\R113.ico\"\nIDI_TEMP_RF46            ICON                    \"res\\\\R114.ico\"\nIDI_TEMP_RF47            ICON                    \"res\\\\R116.ico\"\nIDI_TEMP_RF48            ICON                    \"res\\\\R118.ico\"\nIDI_TEMP_RF49            ICON                    \"res\\\\R120.ico\"\nIDI_TEMP_RF50            ICON                    \"res\\\\R122.ico\"\nIDI_TEMP_RF51            ICON                    \"res\\\\R123.ico\"\nIDI_TEMP_RF52            ICON                    \"res\\\\R125.ico\"\nIDI_TEMP_RF53            ICON                    \"res\\\\R127.ico\"\nIDI_TEMP_RF54            ICON                    \"res\\\\R129.ico\"\nIDI_TEMP_RF55            ICON                    \"res\\\\R131.ico\"\nIDI_TEMP_RF56            ICON                    \"res\\\\R132.ico\"\nIDI_TEMP_RF57            ICON                    \"res\\\\R134.ico\"\nIDI_TEMP_RF58            ICON                    \"res\\\\R136.ico\"\nIDI_TEMP_RF59            ICON                    \"res\\\\R138.ico\"\nIDI_TEMP_RF60            ICON                    \"res\\\\R140.ico\"\nIDI_TEMP_RF61            ICON                    \"res\\\\R141.ico\"\nIDI_TEMP_RF62            ICON                    \"res\\\\R143.ico\"\nIDI_TEMP_RF63            ICON                    \"res\\\\R145.ico\"\nIDI_TEMP_RF64            ICON                    \"res\\\\R147.ico\"\nIDI_TEMP_RF65            ICON                    \"res\\\\R149.ico\"\nIDI_TEMP_RF66            ICON                    \"res\\\\R150.ico\"\nIDI_TEMP_RF67            ICON                    \"res\\\\R152.ico\"\nIDI_TEMP_RF68            ICON                    \"res\\\\R154.ico\"\nIDI_TEMP_RF69            ICON                    \"res\\\\R156.ico\"\nIDI_TEMP_RF70            ICON                    \"res\\\\R158.ico\"\nIDI_TEMP_RF71            ICON                    \"res\\\\R159.ico\"\nIDI_TEMP_RF72            ICON                    \"res\\\\R161.ico\"\nIDI_TEMP_RF73            ICON                    \"res\\\\R163.ico\"\nIDI_TEMP_RF74            ICON                    \"res\\\\R165.ico\"\nIDI_TEMP_RF75            ICON                    \"res\\\\R167.ico\"\nIDI_TEMP_RF76            ICON                    \"res\\\\R168.ico\"\nIDI_TEMP_RF77            ICON                    \"res\\\\R170.ico\"\nIDI_TEMP_RF78            ICON                    \"res\\\\R172.ico\"\nIDI_TEMP_RF79            ICON                    \"res\\\\R174.ico\"\nIDI_TEMP_RF80            ICON                    \"res\\\\R176.ico\"\nIDI_TEMP_RF81            ICON                    \"res\\\\R177.ico\"\nIDI_TEMP_RF82            ICON                    \"res\\\\R179.ico\"\nIDI_TEMP_RF83            ICON                    \"res\\\\R181.ico\"\nIDI_TEMP_RF84            ICON                    \"res\\\\R183.ico\"\nIDI_TEMP_RF85            ICON                    \"res\\\\R185.ico\"\nIDI_TEMP_RF86            ICON                    \"res\\\\R186.ico\"\nIDI_TEMP_RF87            ICON                    \"res\\\\R188.ico\"\nIDI_TEMP_RF88            ICON                    \"res\\\\R190.ico\"\nIDI_TEMP_RF89            ICON                    \"res\\\\R192.ico\"\nIDI_TEMP_RF90            ICON                    \"res\\\\R194.ico\"\nIDI_TEMP_RF91            ICON                    \"res\\\\R195.ico\"\nIDI_TEMP_RF92            ICON                    \"res\\\\R197.ico\"\nIDI_TEMP_RF93            ICON                    \"res\\\\R199.ico\"\nIDI_TEMP_RF94            ICON                    \"res\\\\R201.ico\"\nIDI_TEMP_RF95            ICON                    \"res\\\\R203.ico\"\nIDI_TEMP_RF96            ICON                    \"res\\\\R204.ico\"\nIDI_TEMP_RF97            ICON                    \"res\\\\R206.ico\"\nIDI_TEMP_RF98            ICON                    \"res\\\\R208.ico\"\nIDI_TEMP_RF99            ICON                    \"res\\\\R210.ico\"\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// Dialog\n//\n\nIDD_DISKINFO_DIALOG DIALOGEX 0, 0, 507, 347\nSTYLE DS_SETFONT | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME\nEXSTYLE WS_EX_APPWINDOW\nCAPTION \"CrystalDiskInfo\"\nMENU IDR_MAIN_MENU\nFONT 8, \"MS Shell Dlg\", 0, 0, 0x1\nBEGIN\n    PUSHBUTTON      \"Disk0\",IDC_BUTTON_DISK0,0,0,40,40,BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk1\",IDC_BUTTON_DISK1,40,0,40,40,BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk2\",IDC_BUTTON_DISK2,80,0,40,40,BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk3\",IDC_BUTTON_DISK3,120,0,40,40,BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk4\",IDC_BUTTON_DISK4,160,0,40,40,BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk5\",IDC_BUTTON_DISK5,200,0,40,40,BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk6\",IDC_BUTTON_DISK6,240,0,40,40,BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk7\",IDC_BUTTON_DISK7,280,0,40,40,BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk8\", IDC_BUTTON_DISK8, 280, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk9\", IDC_BUTTON_DISK9, 280, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk10\", IDC_BUTTON_DISK10, 0, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk11\", IDC_BUTTON_DISK11, 40, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk12\", IDC_BUTTON_DISK12, 80, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk13\", IDC_BUTTON_DISK13, 120, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk14\", IDC_BUTTON_DISK14, 160, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk15\", IDC_BUTTON_DISK15, 200, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n#ifdef MAX_DRIVE_20\n    PUSHBUTTON      \"Disk16\", IDC_BUTTON_DISK16, 240, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk17\", IDC_BUTTON_DISK17, 280, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk18\", IDC_BUTTON_DISK18, 280, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"Disk19\", IDC_BUTTON_DISK19, 280, 0, 40, 40, BS_CENTER | BS_MULTILINE | BS_NOTIFY\n#endif\n    PUSHBUTTON      \"\",IDC_BUTTON_PRE_DISK,9,50,26,15,BS_MULTILINE\n    PUSHBUTTON      \"\",IDC_BUTTON_NEXT_DISK,465,45,26,15,BS_MULTILINE\n    CONTROL         \"Life\",IDC_BUTTON_LIFE,\"Button\",BS_OWNERDRAW | BS_CENTER | BS_MULTILINE | BS_NOTIFY | WS_TABSTOP,8,199,88,23\n    PUSHBUTTON      \"Good\",IDC_BUTTON_HEALTH_STATUS,8,94,89,34,BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"99 °C\",IDC_BUTTON_TEMPERATURE,7,159,89,34,BS_CENTER | BS_MULTILINE | BS_NOTIFY\n    PUSHBUTTON      \"\",IDC_BUTTON_VOICE,338,202,50,14\n    PUSHBUTTON      \"\",IDC_BUTTON_VOICE_HIDE, 338, 202, 50, 14\n    PUSHBUTTON      \"\",IDC_BUTTON_COPYRIGHT,406,202,50,14, BS_OWNERDRAW | BS_CENTER | BS_MULTILINE | BS_NOTIFY | WS_TABSTOP\n    CONTROL         \"\",IDC_LIST,\"SysListView32\",LVS_REPORT | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,0,257,501,89\n    CONTROL         \"\", IDC_VALUE_MODEL, \"EDIT\", WS_CHILD | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Firmware\",IDC_LABEL_FIRMWARE,107,82,67,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_FIRMWARE, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Serial Number\",IDC_LABEL_SERIAL_NUMBER,106,98,65,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_SERIAL_NUMBER, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Interface\",IDC_LABEL_INTERFACE,106,113,66,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_INTERFACE, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Transfer Mode\",IDC_LABEL_TRANSFER_MODE,106,129,69,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_TRANSFER_MODE, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Drive Letter\",IDC_LABEL_DRIVE_MAP,106,148,67,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_DRIVE_MAP, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Standard\",IDC_LABEL_ATA_ATAPI,106,164,67,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_ATA_ATAPI, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Feature\",IDC_LABEL_FEATURE,106,180,67,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_FEATURE, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Buffer Size\",IDC_LABEL_BUFFER_SIZE,287,79,67,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_BUFFER_SIZE, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"NV Cache Size\",IDC_LABEL_NV_CACHE_SIZE,286,97,67,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_NV_CACHE_SIZE, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Rotation Rate\",IDC_LABEL_ROTATION_RATE,287,113,67,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_ROTATION_RATE, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Power On Count\",IDC_LABEL_POWER_ON_COUNT,285,127,67,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_POWER_ON_COUNT, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Power On Hours\",IDC_LABEL_POWER_ON_HOURS,283,145,67,12,SS_NOTIFY\n    CONTROL         \"\", IDC_VALUE_POWER_ON_HOURS, \"EDIT\", WS_CHILD | ES_MULTILINE | ES_WANTRETURN | ES_READONLY, 1, 1, 1, 1,\n    LTEXT           \"Health Status\",IDC_LABEL_HEALTH_STATUS,12,82,67,12,SS_NOTIFY\n    CTEXT           \"Temperature\",IDC_LABEL_TEMPERATURE,9,145,67,12,SS_NOTIFY\nEND\n\nIDD_ABOUT DIALOGEX 0, 0, 477, 362\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\nCAPTION \"CrystalDiskInfo\"\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\nBEGIN\n    PUSHBUTTON      \"\", IDC_LOGO, 26, 17, 156, 107\n    PUSHBUTTON      \"\", IDC_VERSION, 240, 18, 193, 8\n    LTEXT           \"\", IDC_EDITION, 241, 38, 33, 8\n    LTEXT           \"\", IDC_RELEASE, 239, 62, 33, 8\n    LTEXT           \"\", IDC_COPYRIGHT1, 241, 84, 33, 8\n    LTEXT           \"\", IDC_COPYRIGHT2, 242, 84, 33, 8\n    PUSHBUTTON      \"\", IDC_LICENSE, 239, 110, 33, 8\n    PUSHBUTTON      \"\", IDC_PROJECT_SITE_1, 77, 144, 228, 21\n    PUSHBUTTON      \"\", IDC_PROJECT_SITE_2, 77, 194, 232, 22\n    PUSHBUTTON      \"\", IDC_PROJECT_SITE_3, 196, 229, 270, 31\n    PUSHBUTTON      \"\", IDC_PROJECT_SITE_4, 196, 267, 270, 31\n    PUSHBUTTON      \"\", IDC_PROJECT_SITE_5, 196, 267, 270, 31\n    PUSHBUTTON      \"\", IDC_SECRET_VOICE, 44, 226, 83, 22\nEND\n\nIDD_GRAPH DIALOGEX 0, 0, 187, 94\nSTYLE DS_SETFONT | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME\nEXSTYLE WS_EX_APPWINDOW\nCAPTION \"CrystalDiskInfo - Graph\"\nMENU IDR_GRAPH_MENU\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\nBEGIN\nEND\n\nIDD_OPTION DIALOGEX 0, 0, 187, 94\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\nCAPTION \"CrystalDiskInfo -Graph Customize-\"\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\nBEGIN\nEND\n\nIDD_SETTING DIALOGEX 0, 0, 333, 248\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | DS_CENTER | WS_POPUP | WS_CAPTION | WS_SYSMENU\nCAPTION \"AAM/APM Control\"\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\nBEGIN\n    COMBOBOX        IDC_SELECT_DISK,7,7,319,30, CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED | CBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP\n    SCROLLBAR       IDC_AAM_SCROLLBAR,20,68,240,11\n    PUSHBUTTON      \"Disable\",IDC_BUTTON_DISABLE_AAM,67,103,50,14,BS_CENTER\n    PUSHBUTTON      \"Enable\",IDC_BUTTON_ENABLE_AAM,171,104,50,14,BS_CENTER\n    SCROLLBAR       IDC_APM_SCROLLBAR,22,171,134,11\n    PUSHBUTTON      \"Disable\",IDC_BUTTON_DISABLE_APM,65,207,50,14,BS_CENTER\n    PUSHBUTTON      \"Enable\",IDC_BUTTON_ENABLE_APM,175,209,50,14,BS_CENTER\n    LTEXT           \"Automatic Acoustic Management (AAM)\",IDC_LABEL_AAM,15,27,301,15\n    LTEXT           \"Advanced Power Management (APM)\",IDC_LABEL_APM,15,127,300,16\n    LTEXT           \"Silent (80h)\",IDC_LABEL_AAM_LOW,21,51,38,8\n    LTEXT           \"Performance (FEh)\",IDC_LABEL_AAM_HIGH,149,51,61,8\n    CTEXT           \"AAM Status\",IDC_VALUE_AAM_STATUS,265,54,40,14\n    LTEXT           \"Recommend\",IDC_LABEL_AAM_RECOMMEND,203,91,40,8\n    CTEXT           \"Currnet AAM\",IDC_VALUE_CURRENT_AAM,264,68,40,14\n    CTEXT           \"Reommend AAM\",IDC_VALUE_RECOMMEND_AAM,265,87,40,14\n    LTEXT           \"Min Power (01h)\",IDC_LABEL_APM_LOW,21,154,53,8\n    LTEXT           \"Performance (FEh)\",IDC_LABEL_APM_HIGH,174,152,61,8\n    CTEXT           \"APM Status\",IDC_VALUE_APM_STATUS,260,165,40,14\n    CTEXT           \"Current APM\",IDC_VALUE_CURRENT_APM,265,182,40,14\nEND\n\nIDD_TEMPERATURE DIALOGEX 0, 0, 333, 248\n\tSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\n\tCAPTION \"Temperature Setting\"\n\tFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\n\tBEGIN\n\tCOMBOBOX        IDC_SELECT_DISK, 7, 7, 319, 30, CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED | CBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP\n\tSCROLLBAR       IDC_SCROLLBAR_TEMPERATURE, 20, 46, 134, 11\n\tPUSHBUTTON      \"default\", IDC_DEFAULT, 55, 185, 83, 14, BS_CENTER\n\tPUSHBUTTON      \"apply\", IDC_APPLY, 185, 185, 83, 14, BS_CENTER\n\tCTEXT           \"\", IDC_VALUE_TEMPERATURE, 195, 47, 33, 8\n\tCTEXT           \"\", IDC_VALUE_TEMPERATURE_F, 245, 44, 33, 8\nEND\n\nIDD_HEALTH DIALOGEX 0, 0, 333, 214\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\nCAPTION \"Health Status Setting\"\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\nBEGIN\n    COMBOBOX        IDC_SELECT_DISK,7,7,319,30, CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED | CBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP\n    SCROLLBAR       IDC_SCROLLBAR_05,20,46,134,11\n    SCROLLBAR       IDC_SCROLLBAR_C5,17,86,134,11\n    SCROLLBAR       IDC_SCROLLBAR_C6,15,128,134,11\n    SCROLLBAR       IDC_SCROLLBAR_FF,15,162,134,11\n    PUSHBUTTON      \"default\",IDC_DEFAULT,55,185,83,14,BS_CENTER\n    PUSHBUTTON      \"apply\",IDC_APPLY,185,185,83,14,BS_CENTER\n    LTEXT           \"\",IDC_LABEL_05,7,24,286,13\n    LTEXT           \"\",IDC_LABEL_C5,7,70,33,8\n    LTEXT           \"\",IDC_LABEL_C6,7,111,33,8\n    CTEXT           \"\",IDC_VALUE_05,195,47,33,8\n    CTEXT           \"\",IDC_VALUE_05X,245,44,33,8\n    CTEXT           \"\",IDC_VALUE_C5,195,87,33,8\n    CTEXT           \"\",IDC_VALUE_C5X,245,86,33,8\n    CTEXT           \"\",IDC_VALUE_C6,197,130,33,8\n    CTEXT           \"\",IDC_VALUE_C6X,248,130,33,8\n    LTEXT           \"\",IDC_LABEL_FF,7,145,33,8\n    CTEXT           \"\",IDC_VALUE_FF,197,164,33,8\n    CTEXT           \"\",IDC_VALUE_FFX,248,164,33,8\nEND\n\nIDD_FONT DIALOGEX 0, 0, 180, 89\nSTYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU\nCAPTION \"Font Setting\"\nFONT 12, \"MS Shell Dlg\", 400, 0, 0x80\nBEGIN\n    LTEXT           \"Font Face\", IDC_FONT_FACE, 1, 1, 1, 1\n    LTEXT           \"Font Scale\", IDC_FONT_SCALE, 1, 1, 1, 1\n    LTEXT           \"Render Method\", IDC_FONT_RENDER, 1, 1, 1, 1\n    COMBOBOX        IDC_FONT_FACE_COMBO, 7, 6, 166, 20, CBS_DROPDOWNLIST | CBS_OWNERDRAWVARIABLE | CBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP\n    COMBOBOX        IDC_FONT_SCALE_COMBO, 7, 28, 166, 148, CBS_DROPDOWNLIST | CBS_OWNERDRAWVARIABLE | CBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP\n    COMBOBOX        IDC_FONT_RENDER_COMBO, 7, 28, 166, 148, CBS_DROPDOWNLIST | CBS_OWNERDRAWVARIABLE | CBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP\n    PUSHBUTTON      \"Default\", IDC_SET_DEFAULT, 26, 17, 156, 107, BS_CENTER\n    PUSHBUTTON      \"OK\", IDC_OK, 48, 68, 83, 14, BS_CENTER\nEND\n\nIDD_ALARM_HISTORY DIALOGEX 0, 0, 316, 183\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\nCAPTION \"Dialog\"\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\nBEGIN\n    CONTROL         \"\",IDC_ALARM_LIST,\"SysListView32\",LVS_REPORT | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,7,302,169\nEND\n\nIDD_SOUND_SETTINGS DIALOGEX 0, 0, 723, 48\nSTYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU\nCAPTION \"Dialog\"\nFONT 8, \"MS Shell Dlg\", 400, 0, 0x1\nBEGIN\n    LTEXT           \"\",IDC_FILE_PATH,7,7,378,16,SS_NOTIFY\n    PUSHBUTTON      \"\",IDC_BUTTON_SELECT_FILE,393,7,50,14\n    PUSHBUTTON      \"\",IDC_BUTTON_PLAY,450,7,50,14\n    PUSHBUTTON      \"Default\",IDC_BUTTON_DEFAULT,53,26,50,14,BS_CENTER\n    PUSHBUTTON      \"OK\",IDC_BUTTON_OK,173,26,50,14,BS_CENTER\n    CONTROL         \"\",IDC_SLIDER_VOLUME,\"msctls_trackbar32\",TBS_BOTH | TBS_NOTICKS | TBS_FIXEDLENGTH | WS_TABSTOP,248,25,100,15\n//    SCROLLBAR       IDC_SLIDER_VOLUME, 17, 86, 134, 11\n    LTEXT           \"\",IDC_STATIC_VOLUME,606,32,8,8\n    CTEXT           \"\",IDC_VALUE_VOLUME, 245, 44, 33, 8\nEND\n\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// Version\n//\n\nVS_VERSION_INFO VERSIONINFO\n FILEVERSION 9, 5, 0, 0\n PRODUCTVERSION 9, 5, 0, 0\n FILEFLAGSMASK 0x3fL\n#ifdef _DEBUG\n FILEFLAGS 0x1L\n#else\n FILEFLAGS 0x0L\n#endif\n FILEOS 0x4L\n FILETYPE 0x1L\n FILESUBTYPE 0x0L\nBEGIN\n    BLOCK \"StringFileInfo\"\n    BEGIN\n        BLOCK \"080003a4\"\n        BEGIN\n#ifdef MSI_MEI_SUPPORT\n            VALUE \"Comments\", \"https://crystalmark.info/\"\n#else\n            VALUE \"Comments\", \"https://crystalmark.info/ MIT License\"\n#endif\n            VALUE \"CompanyName\", \"Crystal Dew World\"\n            VALUE \"FileVersion\", \"9.5.0.0\"\n            VALUE \"ProductVersion\", \"9.5.0.0\"\n            VALUE \"OriginalFilename\", \"DiskInfo.exe\"\n            VALUE \"InternalName\", \"DiskInfo.exe\"\n\n    #ifdef SUISHO_AOI_SUPPORT\n            VALUE \"FileDescription\", \"CrystalDiskInfo Aoi Edition\"\n            VALUE \"ProductName\", \"CrystalDiskInfo Aoi Edition\"\n            VALUE \"LegalCopyright\", \"(C) 2008-2024 hiyohiyo, (C) 2023-2024 nijihashi sola\"\n\n    #elif MSI_MEI_SUPPORT\n            VALUE \"FileDescription\", \"CrystalDiskInfo MSI Mei Mihoshi Edition\"\n            VALUE \"ProductName\", \"CrystalDiskInfo MSI Mei Mihoshi Edition\"\n            VALUE \"LegalCopyright\", \"(C) 2008-2024 hiyohiyo, (C) 2024 Micro-Star INT'L CO., LTD.\"\n\n    #elif KUREI_KEI_SUPPORT\n            VALUE \"FileDescription\", \"CrystalDiskInfo Kurei Kei Edition\"\n            VALUE \"ProductName\", \"CrystalDiskInfo Kurei Kei Edition\"\n            VALUE \"LegalCopyright\", \"(C) 2008-2024 hiyohiyo, (C) 2017-2024 Pronama LLC\"\n\n    #elif SUISHO_SHIZUKU_SUPPORT\n            VALUE \"FileDescription\", \"CrystalDiskInfo Shizuku Edition\"\n            VALUE \"ProductName\", \"CrystalDiskInfo Shizuku Edition\"\n            VALUE \"LegalCopyright\", \"(C) 2008-2024 hiyohiyo, (C) 2012-2024 kirino kasumu\"\n\n    #else\n            VALUE \"FileDescription\", \"CrystalDiskInfo\"\n            VALUE \"ProductName\", \"CrystalDiskInfo\"\n            VALUE \"LegalCopyright\", \"(C) 2008-2024 hiyohiyo\"\n    #endif\n        END\n    END\n    BLOCK \"VarFileInfo\"\n    BEGIN\n        VALUE \"Translation\", 0x800, 932\n    END\nEND\n\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// DESIGNINFO\n//\n\n#ifdef APSTUDIO_INVOKED\nGUIDELINES DESIGNINFO\nBEGIN\n    IDD_DISKINFO_DIALOG, DIALOG\n    BEGIN\n        RIGHTMARGIN, 501\n        BOTTOMMARGIN, 346\n    END\n\n    IDD_ABOUT, DIALOG\n    BEGIN\n        RIGHTMARGIN, 466\n        BOTTOMMARGIN, 357\n    END\n\n    IDD_GRAPH, DIALOG\n    BEGIN\n        LEFTMARGIN, 7\n        RIGHTMARGIN, 180\n        TOPMARGIN, 7\n        BOTTOMMARGIN, 87\n    END\n\n    IDD_OPTION, DIALOG\n    BEGIN\n        LEFTMARGIN, 7\n        RIGHTMARGIN, 180\n        TOPMARGIN, 7\n        BOTTOMMARGIN, 87\n    END\n\n    IDD_SETTING, DIALOG\n    BEGIN\n        LEFTMARGIN, 7\n        RIGHTMARGIN, 326\n        TOPMARGIN, 7\n        BOTTOMMARGIN, 241\n    END\n\n\tIDD_TEMPERATURE, DIALOG\n\t\tBEGIN\n\t\tLEFTMARGIN, 7\n\t\tRIGHTMARGIN, 326\n\t\tTOPMARGIN, 7\n\t\tBOTTOMMARGIN, 241\n\t\tEND\n\n    IDD_HEALTH, DIALOG\n    BEGIN\n        LEFTMARGIN, 7\n        RIGHTMARGIN, 326\n        TOPMARGIN, 7\n        BOTTOMMARGIN, 207\n    END\n\n    IDD_FONT, DIALOG\n    BEGIN\n        LEFTMARGIN, 7\n        RIGHTMARGIN, 173\n        TOPMARGIN, 6\n        BOTTOMMARGIN, 82\n    END\n\n    IDD_ALARM_HISTORY, DIALOG\n    BEGIN\n        LEFTMARGIN, 7\n        RIGHTMARGIN, 309\n        TOPMARGIN, 7\n        BOTTOMMARGIN, 176\n    END\n\n    IDD_SOUND_SETTINGS, DIALOG\n    BEGIN\n        LEFTMARGIN, 7\n        RIGHTMARGIN, 716\n        TOPMARGIN, 7\n        BOTTOMMARGIN, 40\n    END\nEND\n#endif    // APSTUDIO_INVOKED\n\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// Menu\n//\n\nIDR_MAIN_MENU MENU\nBEGIN\n    POPUP \"&File\"\n    BEGIN\n        MENUITEM \"Save (&text)\",                    ID_SAVE_TEXT\n        MENUITEM \"Save (&image)\",                   ID_SAVE_IMAGE\n        MENUITEM \"&Exit\",                           ID_EXIT\n    END\n    POPUP \"&Edit\"\n    BEGIN\n        MENUITEM \"&Copy\\tCtrl + Shift + C\",         ID_COPY\n        POPUP \"Options\"\n        BEGIN\n            MENUITEM \"IDENTIFY_DEVICE\",             ID_DUMP_IDENTIFY_DEVICE\n            MENUITEM \"SMART_READ_DATA\",             ID_DUMP_SMART_READ_DATA\n            MENUITEM \"SMART_READ_THRESHOLD\",        ID_DUMP_SMART_READ_THRESHOLD\n            MENUITEM SEPARATOR\n            MENUITEM \"ASCII View\",                  ID_ASCII_VIEW\n        END\n    END\n    POPUP \"F&unction\"\n    BEGIN\n        MENUITEM \"Refresh\\tF5\",                     ID_REFRESH\n        POPUP \"Auto Refresh\"\n        BEGIN\n            MENUITEM \"1 min.\",                      ID_AUTO_REFRESH_01_MIN\n            MENUITEM \"3 min.\",                      ID_AUTO_REFRESH_03_MIN\n            MENUITEM \"5 min.\",                      ID_AUTO_REFRESH_05_MIN\n            MENUITEM \"10 min.\",                     ID_AUTO_REFRESH_10_MIN\n            MENUITEM \"30 min.\",                     ID_AUTO_REFRESH_30_MIN\n            MENUITEM \"60 min.\",                     ID_AUTO_REFRESH_60_MIN\n\t\t\tMENUITEM \"120 min.\",\t\t\t\t\tID_AUTO_REFRESH_120_MIN\n\t\t\tMENUITEM \"180 min.\",\t\t\t\t\tID_AUTO_REFRESH_180_MIN\n\t\t\tMENUITEM \"360 min.\",\t\t\t\t\tID_AUTO_REFRESH_360_MIN\n\t\t\tMENUITEM \"720 min.\",\t\t\t\t\tID_AUTO_REFRESH_720_MIN\n\t\t\tMENUITEM \"1440 min.\",\t\t\t\t\tID_AUTO_REFRESH_1440_MIN\n\t\t\tMENUITEM \"Disable\",                     ID_AUTO_REFRESH_DISABLE\n        END\n        POPUP \"Auto Refresh Target\"\n        BEGIN\n            MENUITEM \"DUMMY\",                       ID_DUMMY\n        END\n        MENUITEM \"Rescan\\tF6\",                      ID_RESCAN\n        MENUITEM SEPARATOR\n        MENUITEM \"Graph\",                           ID_GRAPH\n        MENUITEM SEPARATOR\n        MENUITEM \"Hide Serial Number\",              ID_HIDE_SERIAL_NUMBER\n        MENUITEM \"Resident\",                        ID_RESIDENT\n        MENUITEM \"Startup\",                         ID_STARTUP\n\n        MENUITEM SEPARATOR\n        POPUP \"Alert Features\"\n        BEGIN\n            MENUITEM \"Alert Mail\",                  ID_ALERT_MAIL\n            MENUITEM \"Mail Settings\",               ID_MAIL_SETTINGS\n            MENUITEM \"Alert Sound\",                 ID_ALERT_SOUND\n            MENUITEM \"Sound Settings\",              ID_SOUND_SETTINGS\n            MENUITEM \"Event Log\",                   ID_EVENT_LOG\n        END\n        POPUP \"Advanced Features\"\n        BEGIN\n            MENUITEM \"AAM/APM Setting\",             ID_AAM_APM\n            MENUITEM \"Auto AAM/APM Adaptation\",     ID_AUTO_AAM_APM\n            MENUITEM \"Health Status Setting\",       ID_HEALTH_STATUS\n\t\t\tMENUITEM \"Temperature Setting\",\t\t\tID_TEMPERATURE\n            MENUITEM SEPARATOR\n            POPUP \"Temperature\"\n            BEGIN\n                MENUITEM \"Celsius\",                 ID_CELSIUS\n                MENUITEM \"Fahrenheit\",              ID_FAHRENHEIT\n            END\n            POPUP \"Auto Detection\"\n            BEGIN\n                MENUITEM \"5 sec.\",                  ID_AUTO_DETECTION_05_SEC\n                MENUITEM \"10 sec.\",                 ID_AUTO_DETECTION_10_SEC\n                MENUITEM \"20 sec.\",                 ID_AUTO_DETECTION_20_SEC\n                MENUITEM \"30 sec.\",                 ID_AUTO_DETECTION_30_SEC\n                MENUITEM \"Disable\",                 ID_AUTO_DETECTION_DISABLE\n            END\n            POPUP \"Raw Values\"\n            BEGIN\n                MENUITEM \"16 [HEX]\",                ID_RAW_VALUES_16\n                MENUITEM \"10 [DEC]\",                ID_RAW_VALUES_10_ALL\n                MENUITEM \"10 [DEC] - 2byte\",        ID_RAW_VALUES_2BYTE\n                MENUITEM \"10 [DEC] - 1byte\",        ID_RAW_VALUES_1BYTE\n            END\n            POPUP \"Wait Time at Startup\"\n            BEGIN\n                MENUITEM \"0 sec.\",                      ID_WAIT_0_SEC\n                MENUITEM \"5 sec.\",                      ID_WAIT_5_SEC\n                MENUITEM \"10 sec.\",                     ID_WAIT_10_SEC\n                MENUITEM \"15 sec.\",                     ID_WAIT_15_SEC\n                MENUITEM \"20 sec.\",                     ID_WAIT_20_SEC\n                MENUITEM \"30 sec.\",                     ID_WAIT_30_SEC\n                MENUITEM \"40 sec.\",                     ID_WAIT_40_SEC\n                MENUITEM \"50 sec.\",                     ID_WAIT_50_SEC\n                MENUITEM \"60 sec.\",                     ID_WAIT_60_SEC\n                MENUITEM \"90 sec.\",                     ID_WAIT_90_SEC\n                MENUITEM \"120 sec.\",                    ID_WAIT_120_SEC\n                MENUITEM \"150 sec.\",                    ID_WAIT_150_SEC\n                MENUITEM \"180 sec.\",                    ID_WAIT_180_SEC\n                MENUITEM \"210 sec.\",                    ID_WAIT_210_SEC\n                MENUITEM \"240 sec.\",                    ID_WAIT_240_SEC\n            END\n            POPUP \"Resident Style\"\n            BEGIN\n                MENUITEM \"Hide\",                        ID_RESIDENT_HIDE\n                MENUITEM \"Minimize\",                    ID_RESIDENT_MINIMIZE\n            END\n            POPUP \"Drive Sort Method\"\n            BEGIN\n                MENUITEM \"Physical Drive ID\",           ID_SORT_PHYSICAL_DRIVE_ID\n                MENUITEM \"Drive Letter\",                ID_SORT_DRIVE_LETTER\n            END\n            POPUP \"Drive Menu\"\n                BEGIN\n                MENUITEM \"8\",                           ID_DRIVE_MENU_8\n#ifdef MAX_DRIVE_20\n                MENUITEM \"10\",                          ID_DRIVE_MENU_10\n#endif\n                MENUITEM \"16\",                          ID_DRIVE_MENU_16\n#ifdef MAX_DRIVE_20\n                MENUITEM \"20\",                          ID_DRIVE_MENU_20\n#endif\n            END\n            MENUITEM SEPARATOR\n            MENUITEM \"&Advanced Disk Search\",           ID_ADVANCED_DISK_SEARCH\n            MENUITEM \"ATA_PASS_THROUGH\",                ID_ATA_PASS_THROUGH_SMART\n            POPUP \"USB/IEEE 1394\"\n            BEGIN\n                MENUITEM \"SCSI_ATA_TRANSLATION (SAT)\",  ID_USB_SAT\n                MENUITEM \"I-O DATA\",                    ID_USB_IODATA\n                MENUITEM \"Sunplus\",                     ID_USB_SUNPLUS\n                MENUITEM \"Logitec\",                     ID_USB_LOGITEC\n\t\t\t\tMENUITEM \"Prolific\",                    ID_USB_PROLIFIC\n                MENUITEM \"JMicron\",                     ID_USB_JMICRON\n                MENUITEM \"Cypress\",                     ID_USB_CYPRESS\n                MENUITEM \"ASMedia ASM1352R\",            ID_USB_ASM1352R\n                MENUITEM \"Realtek RTL9220DP\",           ID_USB_REALTEK9220DP\n#ifdef JMICRON_USB_RAID_SUPPORT\n                MENUITEM \"JMicron JMS56X\",              ID_USB_JMS56X\n                MENUITEM \"JMicron JMB39X\",              ID_USB_JMB39X\n                MENUITEM \"JMicron JMS586 (Model 20bytes/Beta)\",            ID_USB_JMS586_20\n//                MENUITEM \"JMicron JMS586 (Model 40bytes/NewFW/Beta)\",      ID_USB_JMS586_40\n#endif \n                MENUITEM \"USB Memory (SAT)\",            ID_USB_MEMORY\n//                MENUITEM \"SCSI_ATA_TRANSLATION_16BYTE (Samsung SATA SSD Life)\",   ID_USB_SAT16\n                MENUITEM \"SCSI_NVME_TRANSLATION (JMicron for USB3/4)\",   ID_USB_NVME_JMICRON3\n\t\t        MENUITEM \"SCSI_NVME_TRANSLATION (JMicron for USB2/3/4)\", ID_USB_NVME_JMICRON\n                MENUITEM \"SCSI_NVME_TRANSLATION (ASMedia)\",            ID_USB_NVME_ASMEDIA\n\t\t\t\tMENUITEM \"SCSI_NVME_TRANSLATION (Realtek)\",            ID_USB_NVME_REALTEK\n\n                MENUITEM SEPARATOR\n                MENUITEM \"Enable All\",                  ID_USB_ENABLE_ALL\n                MENUITEM \"Disable All\",                 ID_USB_DISABLE_ALL\n            END\n            POPUP \"Intel/AMD RAID (CSMI)\"\n            BEGIN\n                MENUITEM \"Enable (Auto Detection, default)\", ID_CSMI_ENABLE_AUTO\n                MENUITEM \"Enable (Access RAID Disks only)\", ID_CSMI_ENABLE_RAID\n                MENUITEM \"Enable (Access All Disks)\",   ID_CSMI_ENABLE_ALL\n                MENUITEM \"Disable\",                     ID_CSMI_DISABLE\n            END\n            MENUITEM \"AMD RAIDXpert2 (AMD_RC2t7)\", ID_AMD_RC2T7\n\t\t\tMENUITEM \"MegaRAID\", ID_MEGA_RAID\n            MENUITEM \"Intel VROC\", ID_INTEL_VROC\n\n            MENUITEM SEPARATOR\n            MENUITEM \"Gadget Support\",              ID_GADGET_SUPPORT\n//            MENUITEM \"Install Gadget\",              ID_INSTALL_GADGET\n            MENUITEM SEPARATOR\n            MENUITEM \"Hide S.M.A.R.T. Information\", ID_HIDE_SMART_INFO\n            MENUITEM \"Hide No S.M.A.R.T. Disk\",     ID_HIDE_NO_SMART_DISK\n        END\n        POPUP \"Workaround\"\n        BEGIN\n            MENUITEM \"[Firmware Bug] SAMSUNG HD155UI/HD204UI\", ID_WORKAROUND_HD204UI\n            MENUITEM \"[IE Bug] IE8 Mode\",           ID_WORKAROUND_IE8MODE\n            MENUITEM \"[Ignore] (C4) Reallocation Event Count\", ID_WORKAROUND_IGNORE_C4\n        END\n        MENUITEM SEPARATOR\n        MENUITEM \"Open \"\"Disk Management\"\"\",    ID_OPEN_DISK_MANAGEMENT\n        MENUITEM \"Open \"\"Device Manager\"\"\",     ID_OPEN_DEVICE_MANAGER\n    END\n    POPUP \"&Theme\"\n    BEGIN\n        POPUP \"Zoom\"\n        BEGIN\n            MENUITEM \"100%\",                        ID_ZOOM_100\n            MENUITEM \"125%\",                        ID_ZOOM_125\n            MENUITEM \"150%\",                        ID_ZOOM_150\n            MENUITEM \"200%\",                        ID_ZOOM_200\n            MENUITEM \"250%\",                        ID_ZOOM_250\n            MENUITEM \"300%\",                        ID_ZOOM_300\n            MENUITEM \"Auto\",                        ID_ZOOM_AUTO\n        END\n        MENUITEM \"Green Mode\",                  ID_GREEN_MODE\n//        MENUITEM \"Disable Dark Mode\",           ID_DISABLE_DARK_MODE\n        MENUITEM \"Font Setting\",                ID_FONT_SETTING\n        MENUITEM SEPARATOR\n    END\n    POPUP \"&Disk\"\n    BEGIN\n        MENUITEM \"DUMMY\",                       ID_DUMMY\n    END\n    POPUP \"&Help\"\n    BEGIN\n        MENUITEM \"Help [Web]\",                  ID_HELP\n        MENUITEM \"Crystal Dew World [Web]\",     ID_CRYSTALDEWWORLD\n        MENUITEM \"About S.M.A.R.T. (Wikipedia) [Web]\", ID_HELP_ABOUT_SMART\n        MENUITEM SEPARATOR\n        MENUITEM \"About CrystalDiskInfo\",       ID_ABOUT\n    END\n    POPUP \"&Language\"\n    BEGIN\n        POPUP \"A-N\"\n        BEGIN\n            MENUITEM \"DUMMY\",                       ID_DUMMY\n        END\n        POPUP \"O-Z\"\n        BEGIN\n            MENUITEM \"DUMMY\",                       ID_DUMMY\n        END\n#ifdef SUISHO_AOI_SUPPORT\n        POPUP \"&Voice\"\n        BEGIN\n            MENUITEM \"English, [English]\", ID_VOICE_ENGLISH\n            MENUITEM \"日本語, [Japanese]\", ID_VOICE_JAPANESE\n        END\n#endif \n#ifdef SUISHO_SHIZUKU_SUPPORT\n        MENUITEM \"Startup Voice\",               ID_STARTUP_VOICE\n#endif \n\n        MENUITEM \"S.M.A.R.T. in English\",       ID_SMART_ENGLISH\n    END\nEND\n\nIDR_GRAPH_MENU MENU\nBEGIN\n    POPUP \"File\"\n    BEGIN\n        MENUITEM \"&Customize\",                  ID_CUSTOMIZE\n        MENUITEM \"Exit\",                        ID_EXIT\n    END\n    POPUP \"Option\"\n    BEGIN\n        POPUP \"Legend Position\"\n        BEGIN\n            MENUITEM \"North West\",                  ID_NORTH_WEST\n            MENUITEM \"North East\",                  ID_NORTH_EAST\n            MENUITEM \"South West\",                  ID_SOUTH_WEST\n            MENUITEM \"South East\",                  ID_SOUTH_EAST\n        END\n        POPUP \"Max Number of Points\"\n        BEGIN\n            MENUITEM \"100\",                         ID_POINT_100\n            MENUITEM \"200\",                         ID_POINT_200\n            MENUITEM \"300\",                         ID_POINT_300\n            MENUITEM \"400\",                         ID_POINT_400\n            MENUITEM \"500\",                         ID_POINT_500\n            MENUITEM \"600\",                         ID_POINT_600\n            MENUITEM \"700\",                         ID_POINT_700\n            MENUITEM \"800\",                         ID_POINT_800\n            MENUITEM \"900\",                         ID_POINT_900\n            MENUITEM \"1000\",                        ID_POINT_1000\n            MENUITEM \"2000\",                        ID_POINT_2000\n            MENUITEM \"3000\",                        ID_POINT_3000\n            MENUITEM \"4000\",                        ID_POINT_4000\n            MENUITEM \"5000\",                        ID_POINT_5000\n            MENUITEM \"All\",                         ID_POINT_ALL\n        END\n        POPUP \"Time Format\"\n        BEGIN\n            MENUITEM \"MM/DD hh:mm\",                 ID_MDHM\n            MENUITEM \"MM/DD\",                       ID_MD\n            MENUITEM \"YYYY/MM/DD hh:mm\",            ID_YMDHM\n            MENUITEM \"YYYY/MM/DD\",                  ID_YMD\n            MENUITEM \"DD/MM/YYYY hh:mm\",            ID_DMYHM\n            MENUITEM \"DD/MM/YYYY\",                  ID_DMY\n            MENUITEM \"DD.MM.YYYY hh:mm\",            ID_DMYHM2\n            MENUITEM \"DD.MM.YYYY\",                  ID_DMY2\n        END\n        POPUP \"Attribute\"\n        BEGIN\n            MENUITEM \"HDD\",                         ID_HDD\n            MENUITEM \"SSD - ATA\",                   ID_SSD\n\t\t\tMENUITEM \"SSD - NVMe\",                  ID_SSD_NVME\n            MENUITEM \"SSD - Apacer\",                ID_SSD_APACER\n            MENUITEM \"SSD - CORSAIR\",               ID_SSD_CORSAIR\n            MENUITEM \"SSD - Indilinx\",              ID_SSD_INDILINX\n            MENUITEM \"SSD - Intel\",                 ID_SSD_INTEL\n            MENUITEM \"SSD - Intel DC\",              ID_SSD_INTEL_DC\n            MENUITEM \"SSD - JMicron 60x\",           ID_SSD_JMICRON_60X\n            MENUITEM \"SSD - JMicron 61x\",           ID_SSD_JMICRON_61X\n            MENUITEM \"SSD - JMicron 66x\",           ID_SSD_JMICRON_66X\n            MENUITEM \"SSD - Kingston\",              ID_SSD_KINGSTON\n            MENUITEM \"SSD - Kingston DC500\",        ID_SSD_KINGSTON_DC500\n            MENUITEM \"SSD - Kingston KC600\",        ID_SSD_KINGSTON_KC600\n            MENUITEM \"SSD - Kingston SA400\",        ID_SSD_KINGSTON_SA400\n            MENUITEM \"SSD - Kingston SUV\",          ID_SSD_KINGSTON_SUV\n            MENUITEM \"SSD - KIOXIA\",                ID_SSD_KIOXIA\n            MENUITEM \"SSD - Marvell\",               ID_SSD_MARVELL\n            MENUITEM \"SSD - Maxiotek\",              ID_SSD_MAXIOTEK\n            MENUITEM \"SSD - Micron\",                ID_SSD_MICRON\n            MENUITEM \"SSD - Micron MU03\",           ID_SSD_MICRON_MU03\n            MENUITEM \"SSD - MTRON\",                 ID_SSD_MTRON\n            MENUITEM \"SSD - OCZ\",                   ID_SSD_OCZ\n            MENUITEM \"SSD - OCZ VECTOR\",            ID_SSD_OCZ_VECTOR\n            MENUITEM \"SSD - PHISON\",                ID_SSD_PHISON\n            MENUITEM \"SSD - Plextor\",               ID_SSD_PLEXTOR\n\t\t\tMENUITEM \"SSD - Realtek\",               ID_SSD_REALTEK\n            MENUITEM \"SSD - RECADATA\",              ID_SSD_RECADATA\n            MENUITEM \"SSD - SAMSUNG\",               ID_SSD_SAMSUNG\n            MENUITEM \"SSD - SandForce\",             ID_SSD_SANDFORCE\n            MENUITEM \"SSD - SanDisk\",               ID_SSD_SANDISK\n            MENUITEM \"SSD - SanDisk GB\",            ID_SSD_SANDISK_GB\n\n            MENUITEM \"SSD - SanDisk DELL\",          ID_SSD_SANDISK_DELL,\n            MENUITEM \"SSD - SanDisk HP\",            ID_SSD_SANDISK_HP,\n            MENUITEM \"SSD - SanDisk HP (Venus)\",    ID_SSD_SANDISK_HP_VENUS,\n            MENUITEM \"SSD - SanDisk Lenovo\",        ID_SSD_SANDISK_LENOVO,\n            MENUITEM \"SSD - SanDisk Lenovo (Helen/Venus)\", ID_SSD_SANDISK_LENOVO_HELEN_VENUS,\n\n            MENUITEM \"SSD - Seagate\",               ID_SSD_SEAGATE\n            MENUITEM \"SSD - Seagate Barra Cuda\",    ID_SSD_SEAGATE_BARRA_CUDA\n            MENUITEM \"SSD - Seagate IronWolf\",      ID_SSD_SEAGATE_IRON_WOLF\n            MENUITEM \"SSD - SCY\",                   ID_SSD_SCY\n            MENUITEM \"SSD - Silicon Motion\",        ID_SSD_SILICONMOTION\n            MENUITEM \"SSD - SK Hynix\",              ID_SSD_SKHYNIX\n            MENUITEM \"SSD - SSSTC\",                 ID_SSD_SSSTC\n            MENUITEM \"SSD - TOSHIBA\",               ID_SSD_TOSHIBA\n            MENUITEM \"SSD - WDC\",                   ID_SSD_WDC\n            MENUITEM \"SSD - YMTC\",                  ID_SSD_YMTC\n            MENUITEM \"SSD - Silicon Motion CVC\",    ID_SSD_SILICONMOTION_CVC\n            MENUITEM \"SSD - ADATA Industrial\",      ID_SSD_ADATA_INDUSTRIAL\n        END\n        MENUITEM \"Paint Weekend\",               ID_PAINT_WEEKEND\n    END\nEND\n\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// Accelerator\n//\n\nIDR_ACCELERATOR ACCELERATORS\nBEGIN\n    \"C\",            ID_COPY,                VIRTKEY, CONTROL, SHIFT, NOINVERT\n    \"T\",            ID_SAVE_TEXT,           VIRTKEY, CONTROL, NOINVERT\n    \"S\",            ID_SAVE_IMAGE,          VIRTKEY, CONTROL, NOINVERT\n    VK_F4,          ID_EXIT,                VIRTKEY, ALT, NOINVERT\n    VK_F1,          ID_HELP,                VIRTKEY, NOINVERT\n    VK_F5,          ID_REFRESH,             VIRTKEY, NOINVERT\n    VK_F6,          ID_RESCAN,              VIRTKEY, NOINVERT\nEND\n\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// HTML\n//\n\nIDR_HTML_DUMMY          HTML                    \"res\\\\dummy.html\"\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// OPUS\n//\n\nCDI_SOUND_001        OPUS                    \"res\\\\001soundkenjin.opus\"\n#endif    // 日本語 (日本) resources\n/////////////////////////////////////////////////////////////////////////////\n\n\n\n#ifndef APSTUDIO_INVOKED\n/////////////////////////////////////////////////////////////////////////////\n//\n// Generated from the TEXTINCLUDE 3 resource.\n//\n#define _AFX_NO_SPLITTER_RESOURCES\n#define _AFX_NO_OLE_RESOURCES\n#define _AFX_NO_TRACKER_RESOURCES\n#define _AFX_NO_PROPERTY_RESOURCES\n\n#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_JPN)\nLANGUAGE 17, 1\n#pragma code_page(932)\n#include \"res\\DiskInfo.rc2\"  // non-Microsoft Visual C++ edited resources\n#include \"afxres.rc\"     // Standard components\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n#endif    // not APSTUDIO_INVOKED\n\n"
        },
        {
          "name": "DiskInfo.sln",
          "type": "blob",
          "size": 6.3564453125,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio Version 17\nVisualStudioVersion = 17.0.31912.275\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"DiskInfo\", \"DiskInfo.vcxproj\", \"{5496C268-D510-449C-8471-DE2B34898C28}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tDebug|ARM = Debug|ARM\n\t\tDebug|ARM64 = Debug|ARM64\n\t\tDebug|Win32 = Debug|Win32\n\t\tDebug|x64 = Debug|x64\n\t\tDebugGraph|ARM = DebugGraph|ARM\n\t\tDebugGraph|ARM64 = DebugGraph|ARM64\n\t\tDebugGraph|Win32 = DebugGraph|Win32\n\t\tDebugGraph|x64 = DebugGraph|x64\n\t\tRelease|ARM = Release|ARM\n\t\tRelease|ARM64 = Release|ARM64\n\t\tRelease|Win32 = Release|Win32\n\t\tRelease|x64 = Release|x64\n\t\tReleaseAoi|ARM = ReleaseAoi|ARM\n\t\tReleaseAoi|ARM64 = ReleaseAoi|ARM64\n\t\tReleaseAoi|Win32 = ReleaseAoi|Win32\n\t\tReleaseAoi|x64 = ReleaseAoi|x64\n\t\tReleaseKureiKei|ARM = ReleaseKureiKei|ARM\n\t\tReleaseKureiKei|ARM64 = ReleaseKureiKei|ARM64\n\t\tReleaseKureiKei|Win32 = ReleaseKureiKei|Win32\n\t\tReleaseKureiKei|x64 = ReleaseKureiKei|x64\n\t\tReleaseMSIMei|ARM = ReleaseMSIMei|ARM\n\t\tReleaseMSIMei|ARM64 = ReleaseMSIMei|ARM64\n\t\tReleaseMSIMei|Win32 = ReleaseMSIMei|Win32\n\t\tReleaseMSIMei|x64 = ReleaseMSIMei|x64\n\t\tReleaseShizuku|ARM = ReleaseShizuku|ARM\n\t\tReleaseShizuku|ARM64 = ReleaseShizuku|ARM64\n\t\tReleaseShizuku|Win32 = ReleaseShizuku|Win32\n\t\tReleaseShizuku|x64 = ReleaseShizuku|x64\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Debug|ARM.ActiveCfg = Debug|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Debug|ARM.Build.0 = Debug|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Debug|ARM64.ActiveCfg = Debug|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Debug|ARM64.Build.0 = Debug|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Debug|Win32.ActiveCfg = Debug|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Debug|Win32.Build.0 = Debug|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Debug|x64.ActiveCfg = Debug|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Debug|x64.Build.0 = Debug|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.DebugGraph|ARM.ActiveCfg = DebugGraph|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.DebugGraph|ARM.Build.0 = DebugGraph|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.DebugGraph|ARM64.ActiveCfg = DebugGraph|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.DebugGraph|ARM64.Build.0 = DebugGraph|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.DebugGraph|Win32.ActiveCfg = DebugGraph|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.DebugGraph|Win32.Build.0 = DebugGraph|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.DebugGraph|x64.ActiveCfg = DebugGraph|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.DebugGraph|x64.Build.0 = DebugGraph|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Release|ARM.ActiveCfg = Release|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Release|ARM.Build.0 = Release|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Release|ARM64.ActiveCfg = Release|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Release|ARM64.Build.0 = Release|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Release|Win32.ActiveCfg = Release|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Release|Win32.Build.0 = Release|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Release|x64.ActiveCfg = Release|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.Release|x64.Build.0 = Release|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseAoi|ARM.ActiveCfg = ReleaseAoi|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseAoi|ARM.Build.0 = ReleaseAoi|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseAoi|ARM64.ActiveCfg = ReleaseAoi|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseAoi|ARM64.Build.0 = ReleaseAoi|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseAoi|Win32.ActiveCfg = ReleaseAoi|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseAoi|Win32.Build.0 = ReleaseAoi|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseAoi|x64.ActiveCfg = ReleaseAoi|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseAoi|x64.Build.0 = ReleaseAoi|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseKureiKei|ARM.ActiveCfg = ReleaseKureiKei|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseKureiKei|ARM.Build.0 = ReleaseKureiKei|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseKureiKei|ARM64.ActiveCfg = ReleaseKureiKei|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseKureiKei|ARM64.Build.0 = ReleaseKureiKei|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseKureiKei|Win32.ActiveCfg = ReleaseKureiKei|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseKureiKei|Win32.Build.0 = ReleaseKureiKei|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseKureiKei|x64.ActiveCfg = ReleaseKureiKei|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseKureiKei|x64.Build.0 = ReleaseKureiKei|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseMSIMei|ARM.ActiveCfg = ReleaseMSIMei|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseMSIMei|ARM.Build.0 = ReleaseMSIMei|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseMSIMei|ARM64.ActiveCfg = ReleaseMSIMei|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseMSIMei|ARM64.Build.0 = ReleaseMSIMei|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseMSIMei|Win32.ActiveCfg = ReleaseMSIMei|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseMSIMei|Win32.Build.0 = ReleaseMSIMei|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseMSIMei|x64.ActiveCfg = ReleaseMSIMei|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseMSIMei|x64.Build.0 = ReleaseMSIMei|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseShizuku|ARM.ActiveCfg = ReleaseShizuku|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseShizuku|ARM.Build.0 = ReleaseShizuku|ARM\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseShizuku|ARM64.ActiveCfg = ReleaseShizuku|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseShizuku|ARM64.Build.0 = ReleaseShizuku|ARM64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseShizuku|Win32.ActiveCfg = ReleaseShizuku|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseShizuku|Win32.Build.0 = ReleaseShizuku|Win32\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseShizuku|x64.ActiveCfg = ReleaseShizuku|x64\n\t\t{5496C268-D510-449C-8471-DE2B34898C28}.ReleaseShizuku|x64.Build.0 = ReleaseShizuku|x64\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {18B3B99F-8681-43CD-96B4-A079ECE1D445}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "DiskInfo.vcxproj",
          "type": "blob",
          "size": 293.2216796875,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"15.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup Label=\"ProjectConfigurations\">\n    <ProjectConfiguration Include=\"DebugGraph|ARM\">\n      <Configuration>DebugGraph</Configuration>\n      <Platform>ARM</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"DebugGraph|ARM64\">\n      <Configuration>DebugGraph</Configuration>\n      <Platform>ARM64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"DebugGraph|Win32\">\n      <Configuration>DebugGraph</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"DebugGraph|x64\">\n      <Configuration>DebugGraph</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Debug|ARM\">\n      <Configuration>Debug</Configuration>\n      <Platform>ARM</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Debug|ARM64\">\n      <Configuration>Debug</Configuration>\n      <Platform>ARM64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Debug|Win32\">\n      <Configuration>Debug</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Debug|x64\">\n      <Configuration>Debug</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseAoi|ARM\">\n      <Configuration>ReleaseAoi</Configuration>\n      <Platform>ARM</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseAoi|ARM64\">\n      <Configuration>ReleaseAoi</Configuration>\n      <Platform>ARM64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseAoi|Win32\">\n      <Configuration>ReleaseAoi</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseAoi|x64\">\n      <Configuration>ReleaseAoi</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseKureiKei|ARM\">\n      <Configuration>ReleaseKureiKei</Configuration>\n      <Platform>ARM</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseKureiKei|ARM64\">\n      <Configuration>ReleaseKureiKei</Configuration>\n      <Platform>ARM64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseKureiKei|Win32\">\n      <Configuration>ReleaseKureiKei</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseKureiKei|x64\">\n      <Configuration>ReleaseKureiKei</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseMSIMei|ARM\">\n      <Configuration>ReleaseMSIMei</Configuration>\n      <Platform>ARM</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseMSIMei|ARM64\">\n      <Configuration>ReleaseMSIMei</Configuration>\n      <Platform>ARM64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseMSIMei|Win32\">\n      <Configuration>ReleaseMSIMei</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseMSIMei|x64\">\n      <Configuration>ReleaseMSIMei</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseShizuku|ARM\">\n      <Configuration>ReleaseShizuku</Configuration>\n      <Platform>ARM</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseShizuku|ARM64\">\n      <Configuration>ReleaseShizuku</Configuration>\n      <Platform>ARM64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseShizuku|Win32\">\n      <Configuration>ReleaseShizuku</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"ReleaseShizuku|x64\">\n      <Configuration>ReleaseShizuku</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|ARM\">\n      <Configuration>Release</Configuration>\n      <Platform>ARM</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|ARM64\">\n      <Configuration>Release</Configuration>\n      <Platform>ARM64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|Win32\">\n      <Configuration>Release</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|x64\">\n      <Configuration>Release</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n  </ItemGroup>\n  <PropertyGroup Label=\"Globals\">\n    <ProjectGuid>{5496C268-D510-449C-8471-DE2B34898C28}</ProjectGuid>\n    <RootNamespace>DiskInfo</RootNamespace>\n    <Keyword>MFCProj</Keyword>\n    <SccProjectName>\n    </SccProjectName>\n    <SccAuxPath>\n    </SccAuxPath>\n    <SccLocalPath>\n    </SccLocalPath>\n    <SccProvider>\n    </SccProvider>\n    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v142</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v142</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v142</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v142</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v142</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <PlatformToolset>v143</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <PlatformToolset>v143</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARMSupport>true</WindowsSDKDesktopARMSupport>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARMSupport>true</WindowsSDKDesktopARMSupport>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARMSupport>true</WindowsSDKDesktopARMSupport>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARMSupport>true</WindowsSDKDesktopARMSupport>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <WholeProgramOptimization>true</WholeProgramOptimization>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARMSupport>true</WindowsSDKDesktopARMSupport>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <PlatformToolset>v143</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <PlatformToolset>v143</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARMSupport>true</WindowsSDKDesktopARMSupport>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <UseOfMfc>Static</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n    <PlatformToolset>v143</PlatformToolset>\n    <WindowsSDKDesktopARMSupport>true</WindowsSDKDesktopARMSupport>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n  <ImportGroup Label=\"ExtensionSettings\">\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <PropertyGroup Label=\"UserMacros\" />\n  <PropertyGroup>\n    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <IntDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">Build\\$(Configuration)$(Platform)\\</IntDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">..\\Rugenia\\</OutDir>\n    <OutDir Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">..\\Rugenia\\</OutDir>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">true</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">true</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">false</LinkIncremental>\n    <LinkIncremental Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">false</LinkIncremental>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(ProjectName)32D</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">$(ProjectName)32D</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(ProjectName)64D</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">$(ProjectName)64D</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">$(ProjectName)A32D</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">$(ProjectName)A32D</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">$(ProjectName)A64D</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">$(ProjectName)A64D</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(ProjectName)32</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(ProjectName)64</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">$(ProjectName)A64</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">$(ProjectName)A32</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">$(ProjectName)32S</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">$(ProjectName)64S</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">$(ProjectName)A64S</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">$(ProjectName)A32S</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">$(ProjectName)32K</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">$(ProjectName)32A</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">$(ProjectName)32M</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">$(ProjectName)64K</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">$(ProjectName)64A</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">$(ProjectName)64M</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">$(ProjectName)A64K</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">$(ProjectName)A64A</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">$(ProjectName)A64M</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">$(ProjectName)A32K</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">$(ProjectName)A32A</TargetName>\n    <TargetName Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">$(ProjectName)A32M</TargetName>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">\n    <IncludePath>.\\Library;.\\Priscilla;$(IncludePath)</IncludePath>\n  </PropertyGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n    <Midl>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <ValidateAllParameters>false</ValidateAllParameters>\n    </Midl>\n    <ClCompile>\n      <Optimization>Disabled</Optimization>\n      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <LanguageStandard>Default</LanguageStandard>\n      <ConformanceMode>Default</ConformanceMode>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX86</TargetMachine>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <OutputFile>$(OutDir)$(ProjectName)32D.exe</OutputFile>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.01 %(AdditionalOptions)</AdditionalOptions>\n      <AdditionalDependencies>\n      </AdditionalDependencies>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <ManifestResourceCompile>\n      <ResourceOutputFileName />\n    </ManifestResourceCompile>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">\n    <Midl>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <ValidateAllParameters>false</ValidateAllParameters>\n    </Midl>\n    <ClCompile>\n      <Optimization>Disabled</Optimization>\n      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX86</TargetMachine>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <OutputFile>$(OutDir)$(ProjectName)32D.exe</OutputFile>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.01 %(AdditionalOptions)</AdditionalOptions>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <ManifestResourceCompile>\n      <ResourceOutputFileName>\n      </ResourceOutputFileName>\n    </ManifestResourceCompile>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <Midl>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <TargetEnvironment>X64</TargetEnvironment>\n    </Midl>\n    <ClCompile>\n      <Optimization>Disabled</Optimization>\n      <PreprocessorDefinitions>SUISHO_AOI_SUPPORT; SUISHO_SHIZUKU_SUPPORT; WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n      <StructMemberAlignment>Default</StructMemberAlignment>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>SUISHO_AOI_SUPPORT; SUISHO_SHIZUKU_SUPPORT;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)64D.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX64</TargetMachine>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <AdditionalDependencies>\n      </AdditionalDependencies>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n      <IgnoreAllDefaultLibraries>\n      </IgnoreAllDefaultLibraries>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <ManifestResourceCompile>\n      <ResourceOutputFileName />\n    </ManifestResourceCompile>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">\n    <Midl>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <TargetEnvironment>X64</TargetEnvironment>\n    </Midl>\n    <ClCompile>\n      <Optimization>Disabled</Optimization>\n      <PreprocessorDefinitions>SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n      <StructMemberAlignment>Default</StructMemberAlignment>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>SUISHO_SHIZUKU_SUPPORT;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)64D.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX64</TargetMachine>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <ManifestResourceCompile>\n      <ResourceOutputFileName>\n      </ResourceOutputFileName>\n    </ManifestResourceCompile>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">\n    <Midl>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>Disabled</Optimization>\n      <PreprocessorDefinitions>AOI_SUPPORT; SUISHO_SHIZUKU_SUPPORT; WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n      <StructMemberAlignment>Default</StructMemberAlignment>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A64D.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">\n    <Midl>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>Disabled</Optimization>\n      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n      <StructMemberAlignment>Default</StructMemberAlignment>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A64D.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">\n    <Midl>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>Disabled</Optimization>\n      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n      <StructMemberAlignment>Default</StructMemberAlignment>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A32D.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">\n    <Midl>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>Disabled</Optimization>\n      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n      <StructMemberAlignment>Default</StructMemberAlignment>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A32D.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <ValidateAllParameters>false</ValidateAllParameters>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <ExceptionHandling>Async</ExceptionHandling>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <LanguageStandard>Default</LanguageStandard>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX86</TargetMachine>\n      <IgnoreSpecificDefaultLibraries>\n      </IgnoreSpecificDefaultLibraries>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.01 %(AdditionalOptions)</AdditionalOptions>\n      <OutputFile>$(OutDir)$(ProjectName)32.exe</OutputFile>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <AdditionalDependencies>\n      </AdditionalDependencies>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <ValidateAllParameters>false</ValidateAllParameters>\n    </Midl>\n    <ClCompile>\n      <Optimization>MaxSpeed</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <ExceptionHandling>Async</ExceptionHandling>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX86</TargetMachine>\n      <IgnoreSpecificDefaultLibraries>\n      </IgnoreSpecificDefaultLibraries>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.01 %(AdditionalOptions)</AdditionalOptions>\n      <OutputFile>$(OutDir)$(ProjectName)32S.exe</OutputFile>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <ValidateAllParameters>false</ValidateAllParameters>\n    </Midl>\n    <ClCompile>\n      <Optimization>MaxSpeed</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <ExceptionHandling>Async</ExceptionHandling>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX86</TargetMachine>\n      <IgnoreSpecificDefaultLibraries>\n      </IgnoreSpecificDefaultLibraries>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.01 %(AdditionalOptions)</AdditionalOptions>\n      <OutputFile>$(OutDir)$(ProjectName)32K.exe</OutputFile>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <ValidateAllParameters>false</ValidateAllParameters>\n    </Midl>\n    <ClCompile>\n      <Optimization>MaxSpeed</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>SUISHO_AOI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <ExceptionHandling>Async</ExceptionHandling>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>SUISHO_AOI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX86</TargetMachine>\n      <IgnoreSpecificDefaultLibraries>\n      </IgnoreSpecificDefaultLibraries>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.01 %(AdditionalOptions)</AdditionalOptions>\n      <OutputFile>$(OutDir)$(ProjectName)32A.exe</OutputFile>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <ValidateAllParameters>false</ValidateAllParameters>\n    </Midl>\n    <ClCompile>\n      <Optimization>MaxSpeed</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>MSI_MEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <ExceptionHandling>Async</ExceptionHandling>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>MSI_MEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX86</TargetMachine>\n      <IgnoreSpecificDefaultLibraries>\n      </IgnoreSpecificDefaultLibraries>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.01 %(AdditionalOptions)</AdditionalOptions>\n      <OutputFile>$(OutDir)$(ProjectName)32M.exe</OutputFile>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <TargetEnvironment>X64</TargetEnvironment>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)64.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX64</TargetMachine>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.02 %(AdditionalOptions)</AdditionalOptions>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <AdditionalDependencies>\n      </AdditionalDependencies>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A64.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A32.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <TargetEnvironment>X64</TargetEnvironment>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)64S.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX64</TargetMachine>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.02 %(AdditionalOptions)</AdditionalOptions>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A64S.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A32S.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <TargetEnvironment>X64</TargetEnvironment>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)64K.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX64</TargetMachine>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.02 %(AdditionalOptions)</AdditionalOptions>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <TargetEnvironment>X64</TargetEnvironment>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>SUISHO_AOI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>SUISHO_AOI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)64A.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX64</TargetMachine>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.02 %(AdditionalOptions)</AdditionalOptions>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n      <TargetEnvironment>X64</TargetEnvironment>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>MSI_MEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>MSI_MEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)64M.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>false</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <TargetMachine>MachineX64</TargetMachine>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <AdditionalOptions>/SUBSYSTEM:WINDOWS,5.02 %(AdditionalOptions)</AdditionalOptions>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A64K.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>SUISHO_AOI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>SUISHO_AOI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A64A.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>MSI_MEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>MSI_MEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A64M.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A32K.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>SUISHO_AOI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>SUISHO_AOI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A32A.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">\n    <Midl>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MkTypLibCompatible>false</MkTypLibCompatible>\n    </Midl>\n    <ClCompile>\n      <Optimization>MinSpace</Optimization>\n      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>\n      <PreprocessorDefinitions>MSI_MEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <MinimalRebuild>false</MinimalRebuild>\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n      <PrecompiledHeader>Use</PrecompiledHeader>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <ProgramDataBaseFileName>Build\\$(Configuration)$(Platform)\\$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>\n      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\n      <WholeProgramOptimization>false</WholeProgramOptimization>\n    </ClCompile>\n    <ResourceCompile>\n      <PreprocessorDefinitions>MSI_MEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <Culture>0x0409</Culture>\n      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n    <Link>\n      <OutputFile>$(OutDir)$(ProjectName)A32M.exe</OutputFile>\n      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>\n      <GenerateDebugInformation>false</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OptimizeReferences>true</OptimizeReferences>\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n      <RandomizedBaseAddress>true</RandomizedBaseAddress>\n      <DataExecutionPrevention>\n      </DataExecutionPrevention>\n      <DelayLoadDLLs>oledlg.dll</DelayLoadDLLs>\n      <ProfileGuidedDatabase>Build\\$(Configuration)$(Platform)\\$(TargetName).pgd</ProfileGuidedDatabase>\n      <ProgramDatabaseFile>Build\\$(Configuration)$(Platform)\\$(TargetName).pdb</ProgramDatabaseFile>\n      <ManifestFile>Build\\$(Configuration)$(Platform)\\$(TargetExt).intermediate.manifest</ManifestFile>\n      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>\n      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>\n    </Link>\n    <BuildLog>\n      <Path>Build\\$(Configuration)$(Platform)\\$(MSBuildProjectName).log</Path>\n    </BuildLog>\n    <Manifest>\n      <EnableDpiAwareness>false</EnableDpiAwareness>\n      <AdditionalManifestFiles>%(AdditionalManifestFiles)</AdditionalManifestFiles>\n    </Manifest>\n  </ItemDefinitionGroup>\n  <ItemGroup>\n    <ClCompile Include=\"AboutDlg.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfo.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlg.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlgCopy.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlgInit.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlgMenu.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlgTray.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlgUpdate.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"FontSelectionDlg.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"GraphDlg.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"HealthDlg.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Library\\stdafx.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"NVMeInterpreter.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"OptionDlg.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\ButtonFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\ComboBoxFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\DarkMode.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\DialogFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\EditFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\FontComboBoxFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\HeaderCtrlFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\ListCtrlFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\MainDialogFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\OsInfoFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\SliderCtrlFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\StaticFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\UAHMenuBar.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\UtilityFx.cpp\">\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeaderFile Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">stdafx.h</PrecompiledHeaderFile>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"SettingDlg.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"SlotSpeedGetter.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"SoundSettingDlg.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"AtaSmart.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"DHtmlDialogEx.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"DHtmlMainDialog.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"EventLog.cpp\">\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n    <ClCompile Include=\"TemperatureDlg.cpp\">\n      <MinimalRebuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">false</MinimalRebuild>\n      <MinimalRebuild Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">false</MinimalRebuild>\n      <MinimalRebuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">false</MinimalRebuild>\n      <MinimalRebuild Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">false</MinimalRebuild>\n      <MinimalRebuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">false</MinimalRebuild>\n      <MinimalRebuild Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">false</MinimalRebuild>\n      <MinimalRebuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">false</MinimalRebuild>\n      <MinimalRebuild Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">false</MinimalRebuild>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">NotUsing</PrecompiledHeader>\n      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">NotUsing</PrecompiledHeader>\n    </ClCompile>\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"AboutDlg.h\" />\n    <ClInclude Include=\"CompileOptions.h\" />\n    <ClInclude Include=\"DiskInfo.h\" />\n    <ClInclude Include=\"DiskInfoDlg.h\" />\n    <ClInclude Include=\"FontSelectionDlg.h\" />\n    <ClInclude Include=\"GraphDlg.h\" />\n    <ClInclude Include=\"HealthDlg.h\" />\n    <ClInclude Include=\"JMicronUsbRaidDef.h\" />\n    <ClInclude Include=\"JMicronUsbRaidInit.h\" />\n    <ClInclude Include=\"Library\\Resource.h\" />\n    <ClInclude Include=\"Library\\resourceN.h\" />\n    <ClInclude Include=\"Library\\resourceS.h\" />\n    <ClInclude Include=\"Library\\stdafx.h\" />\n    <ClInclude Include=\"NVMeInterpreter.h\" />\n    <ClInclude Include=\"OptionDlg.h\" />\n    <ClInclude Include=\"Priscilla\\ButtonFx.h\" />\n    <ClInclude Include=\"Priscilla\\ComboBoxFx.h\" />\n    <ClInclude Include=\"Priscilla\\CommonFx.h\" />\n    <ClInclude Include=\"Priscilla\\DarkMode.h\" />\n    <ClInclude Include=\"Priscilla\\DialogFx.h\" />\n    <ClInclude Include=\"Priscilla\\EditFx.h\" />\n    <ClInclude Include=\"Priscilla\\FontComboBoxFx.h\" />\n    <ClInclude Include=\"Priscilla\\HeaderCtrlFx.h\" />\n    <ClInclude Include=\"Priscilla\\ListCtrlFx.h\" />\n    <ClInclude Include=\"Priscilla\\MainDialogFx.h\" />\n    <ClInclude Include=\"Priscilla\\OsInfoFx.h\" />\n    <ClInclude Include=\"Priscilla\\SliderCtrlFx.h\" />\n    <ClInclude Include=\"Priscilla\\StaticFx.h\" />\n    <ClInclude Include=\"Priscilla\\UAHMenuBar.h\" />\n    <ClInclude Include=\"Priscilla\\UtilityFx.h\" />\n    <ClInclude Include=\"SettingDlg.h\" />\n    <ClInclude Include=\"SlotSpeedGetter.h\" />\n    <ClInclude Include=\"SoundSettingDlg.h\" />\n    <ClInclude Include=\"AtaSmart.h\" />\n    <ClInclude Include=\"DHtmlDialogEx.h\" />\n    <ClInclude Include=\"DHtmlMainDialog.h\" />\n    <ClInclude Include=\"DnpService.h\" />\n    <ClInclude Include=\"EventLog.h\" />\n    <ClInclude Include=\"SPTIUtil.h\" />\n    <ClInclude Include=\"StorageQuery.h\" />\n    <ClInclude Include=\"TemperatureDlg.h\" />\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\".gitattributes\" />\n    <None Include=\".gitignore\" />\n    <None Include=\"resN\\DiskInfo.ico\" />\n    <None Include=\"resN\\DiskInfo16.ico\" />\n    <None Include=\"resS\\DiskInfo.ico\" />\n    <None Include=\"resS\\DiskInfo16.ico\" />\n    <None Include=\"res\\001soundkenjin.opus\" />\n    <None Include=\"res\\bad.ico\" />\n    <None Include=\"res\\caution.ico\" />\n    <None Include=\"res\\DiskInfo.rc2\" />\n    <None Include=\"res\\dummy.html\" />\n    <None Include=\"res\\good.ico\" />\n    <None Include=\"res\\goodGreen.ico\" />\n    <None Include=\"res\\unknown.ico\" />\n    <None Include=\"res\\00.ico\" />\n    <None Include=\"res\\01.ico\" />\n    <None Include=\"res\\02.ico\" />\n    <None Include=\"res\\03.ico\" />\n    <None Include=\"res\\04.ico\" />\n    <None Include=\"res\\05.ico\" />\n    <None Include=\"res\\06.ico\" />\n    <None Include=\"res\\07.ico\" />\n    <None Include=\"res\\08.ico\" />\n    <None Include=\"res\\09.ico\" />\n    <None Include=\"res\\10.ico\" />\n    <None Include=\"res\\11.ico\" />\n    <None Include=\"res\\12.ico\" />\n    <None Include=\"res\\13.ico\" />\n    <None Include=\"res\\14.ico\" />\n    <None Include=\"res\\15.ico\" />\n    <None Include=\"res\\16.ico\" />\n    <None Include=\"res\\17.ico\" />\n    <None Include=\"res\\18.ico\" />\n    <None Include=\"res\\19.ico\" />\n    <None Include=\"res\\20.ico\" />\n    <None Include=\"res\\21.ico\" />\n    <None Include=\"res\\22.ico\" />\n    <None Include=\"res\\23.ico\" />\n    <None Include=\"res\\24.ico\" />\n    <None Include=\"res\\25.ico\" />\n    <None Include=\"res\\26.ico\" />\n    <None Include=\"res\\27.ico\" />\n    <None Include=\"res\\28.ico\" />\n    <None Include=\"res\\29.ico\" />\n    <None Include=\"res\\30.ico\" />\n    <None Include=\"res\\31.ico\" />\n    <None Include=\"res\\32.ico\" />\n    <None Include=\"res\\33.ico\" />\n    <None Include=\"res\\34.ico\" />\n    <None Include=\"res\\35.ico\" />\n    <None Include=\"res\\36.ico\" />\n    <None Include=\"res\\37.ico\" />\n    <None Include=\"res\\38.ico\" />\n    <None Include=\"res\\39.ico\" />\n    <None Include=\"res\\40.ico\" />\n    <None Include=\"res\\41.ico\" />\n    <None Include=\"res\\42.ico\" />\n    <None Include=\"res\\43.ico\" />\n    <None Include=\"res\\44.ico\" />\n    <None Include=\"res\\45.ico\" />\n    <None Include=\"res\\46.ico\" />\n    <None Include=\"res\\47.ico\" />\n    <None Include=\"res\\48.ico\" />\n    <None Include=\"res\\49.ico\" />\n    <None Include=\"res\\50.ico\" />\n    <None Include=\"res\\51.ico\" />\n    <None Include=\"res\\52.ico\" />\n    <None Include=\"res\\53.ico\" />\n    <None Include=\"res\\54.ico\" />\n    <None Include=\"res\\55.ico\" />\n    <None Include=\"res\\56.ico\" />\n    <None Include=\"res\\57.ico\" />\n    <None Include=\"res\\58.ico\" />\n    <None Include=\"res\\59.ico\" />\n    <None Include=\"res\\60.ico\" />\n    <None Include=\"res\\61.ico\" />\n    <None Include=\"res\\62.ico\" />\n    <None Include=\"res\\63.ico\" />\n    <None Include=\"res\\64.ico\" />\n    <None Include=\"res\\65.ico\" />\n    <None Include=\"res\\66.ico\" />\n    <None Include=\"res\\67.ico\" />\n    <None Include=\"res\\68.ico\" />\n    <None Include=\"res\\69.ico\" />\n    <None Include=\"res\\70.ico\" />\n    <None Include=\"res\\71.ico\" />\n    <None Include=\"res\\72.ico\" />\n    <None Include=\"res\\73.ico\" />\n    <None Include=\"res\\74.ico\" />\n    <None Include=\"res\\75.ico\" />\n    <None Include=\"res\\76.ico\" />\n    <None Include=\"res\\77.ico\" />\n    <None Include=\"res\\78.ico\" />\n    <None Include=\"res\\79.ico\" />\n    <None Include=\"res\\80.ico\" />\n    <None Include=\"res\\81.ico\" />\n    <None Include=\"res\\82.ico\" />\n    <None Include=\"res\\83.ico\" />\n    <None Include=\"res\\84.ico\" />\n    <None Include=\"res\\85.ico\" />\n    <None Include=\"res\\86.ico\" />\n    <None Include=\"res\\87.ico\" />\n    <None Include=\"res\\88.ico\" />\n    <None Include=\"res\\89.ico\" />\n    <None Include=\"res\\90.ico\" />\n    <None Include=\"res\\91.ico\" />\n    <None Include=\"res\\92.ico\" />\n    <None Include=\"res\\93.ico\" />\n    <None Include=\"res\\94.ico\" />\n    <None Include=\"res\\95.ico\" />\n    <None Include=\"res\\96.ico\" />\n    <None Include=\"res\\97.ico\" />\n    <None Include=\"res\\98.ico\" />\n    <None Include=\"res\\99.ico\" />\n    <None Include=\"res\\F00.ico\" />\n    <None Include=\"res\\F01.ico\" />\n    <None Include=\"res\\F02.ico\" />\n    <None Include=\"res\\F03.ico\" />\n    <None Include=\"res\\F04.ico\" />\n    <None Include=\"res\\F05.ico\" />\n    <None Include=\"res\\F06.ico\" />\n    <None Include=\"res\\F07.ico\" />\n    <None Include=\"res\\F08.ico\" />\n    <None Include=\"res\\F09.ico\" />\n    <None Include=\"res\\F10.ico\" />\n    <None Include=\"res\\F11.ico\" />\n    <None Include=\"res\\F12.ico\" />\n    <None Include=\"res\\F13.ico\" />\n    <None Include=\"res\\F14.ico\" />\n    <None Include=\"res\\F15.ico\" />\n    <None Include=\"res\\F16.ico\" />\n    <None Include=\"res\\F17.ico\" />\n    <None Include=\"res\\F18.ico\" />\n    <None Include=\"res\\F19.ico\" />\n    <None Include=\"res\\F20.ico\" />\n    <None Include=\"res\\F21.ico\" />\n    <None Include=\"res\\F22.ico\" />\n    <None Include=\"res\\F23.ico\" />\n    <None Include=\"res\\F24.ico\" />\n    <None Include=\"res\\F25.ico\" />\n    <None Include=\"res\\F26.ico\" />\n    <None Include=\"res\\F27.ico\" />\n    <None Include=\"res\\F28.ico\" />\n    <None Include=\"res\\F29.ico\" />\n    <None Include=\"res\\F30.ico\" />\n    <None Include=\"res\\F31.ico\" />\n    <None Include=\"res\\F32.ico\" />\n    <None Include=\"res\\F33.ico\" />\n    <None Include=\"res\\F34.ico\" />\n    <None Include=\"res\\F35.ico\" />\n    <None Include=\"res\\F36.ico\" />\n    <None Include=\"res\\F37.ico\" />\n    <None Include=\"res\\F38.ico\" />\n    <None Include=\"res\\F39.ico\" />\n    <None Include=\"res\\F40.ico\" />\n    <None Include=\"res\\F41.ico\" />\n    <None Include=\"res\\F42.ico\" />\n    <None Include=\"res\\F43.ico\" />\n    <None Include=\"res\\F44.ico\" />\n    <None Include=\"res\\F45.ico\" />\n    <None Include=\"res\\F46.ico\" />\n    <None Include=\"res\\F47.ico\" />\n    <None Include=\"res\\F48.ico\" />\n    <None Include=\"res\\F49.ico\" />\n    <None Include=\"res\\F50.ico\" />\n    <None Include=\"res\\F51.ico\" />\n    <None Include=\"res\\F52.ico\" />\n    <None Include=\"res\\F53.ico\" />\n    <None Include=\"res\\F54.ico\" />\n    <None Include=\"res\\F55.ico\" />\n    <None Include=\"res\\F56.ico\" />\n    <None Include=\"res\\F57.ico\" />\n    <None Include=\"res\\F58.ico\" />\n    <None Include=\"res\\F59.ico\" />\n    <None Include=\"res\\F60.ico\" />\n    <None Include=\"res\\F61.ico\" />\n    <None Include=\"res\\F62.ico\" />\n    <None Include=\"res\\F63.ico\" />\n    <None Include=\"res\\F64.ico\" />\n    <None Include=\"res\\F65.ico\" />\n    <None Include=\"res\\F66.ico\" />\n    <None Include=\"res\\F67.ico\" />\n    <None Include=\"res\\F68.ico\" />\n    <None Include=\"res\\F69.ico\" />\n    <None Include=\"res\\F70.ico\" />\n    <None Include=\"res\\F71.ico\" />\n    <None Include=\"res\\F72.ico\" />\n    <None Include=\"res\\F73.ico\" />\n    <None Include=\"res\\F74.ico\" />\n    <None Include=\"res\\F75.ico\" />\n    <None Include=\"res\\F76.ico\" />\n    <None Include=\"res\\F77.ico\" />\n    <None Include=\"res\\F78.ico\" />\n    <None Include=\"res\\F79.ico\" />\n    <None Include=\"res\\F80.ico\" />\n    <None Include=\"res\\F81.ico\" />\n    <None Include=\"res\\F82.ico\" />\n    <None Include=\"res\\F83.ico\" />\n    <None Include=\"res\\F84.ico\" />\n    <None Include=\"res\\F85.ico\" />\n    <None Include=\"res\\F86.ico\" />\n    <None Include=\"res\\F87.ico\" />\n    <None Include=\"res\\F88.ico\" />\n    <None Include=\"res\\F89.ico\" />\n    <None Include=\"res\\F90.ico\" />\n    <None Include=\"res\\F91.ico\" />\n    <None Include=\"res\\F92.ico\" />\n    <None Include=\"res\\F93.ico\" />\n    <None Include=\"res\\F94.ico\" />\n    <None Include=\"res\\F95.ico\" />\n    <None Include=\"res\\F96.ico\" />\n    <None Include=\"res\\F97.ico\" />\n    <None Include=\"res\\F98.ico\" />\n    <None Include=\"res\\F99.ico\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"DiskInfo.rc\">\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">KUREI_KEI_SUPPORT;SUISHO_SHIZUKU_SUPPORT;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n    </ResourceCompile>\n    <ResourceCompile Include=\"EventMessage.rc\" />\n    <ResourceCompile Include=\"Normal.rc\">\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|Win32'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|x64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseShizuku|ARM'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|Win32'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|Win32'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|Win32'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|x64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|x64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|x64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseKureiKei|ARM'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseAoi|ARM'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='ReleaseMSIMei|ARM'\">true</ExcludedFromBuild>\n    </ResourceCompile>\n    <ResourceCompile Include=\"Shizuku.rc\">\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|ARM'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">false</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|Win32'\">false</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|x64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM64'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|ARM'\">true</ExcludedFromBuild>\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='DebugGraph|ARM'\">true</ExcludedFromBuild>\n    </ResourceCompile>\n  </ItemGroup>\n  <ItemGroup>\n    <Manifest Include=\"DeclareDPIAware.manifest\" />\n  </ItemGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n  <ImportGroup Label=\"ExtensionTargets\">\n  </ImportGroup>\n  <ProjectExtensions>\n    <VisualStudio>\n      <UserProperties RESOURCE_FILE=\"DiskInfo.rc\" />\n    </VisualStudio>\n  </ProjectExtensions>\n</Project>"
        },
        {
          "name": "DiskInfo.vcxproj.filters",
          "type": "blob",
          "size": 29.8935546875,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup>\n    <Filter Include=\"Source Files\">\n      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>\n      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>\n    </Filter>\n    <Filter Include=\"Header Files\">\n      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>\n      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>\n    </Filter>\n    <Filter Include=\"Resource Files\">\n      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>\n      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>\n    </Filter>\n    <Filter Include=\"Resource Files\\Temperature Icons\">\n      <UniqueIdentifier>{dca5264c-4f31-4543-a986-b4248350cdcb}</UniqueIdentifier>\n    </Filter>\n    <Filter Include=\"Library Files\">\n      <UniqueIdentifier>{ccf9d115-ef58-4a15-a3f1-d031a8749b44}</UniqueIdentifier>\n    </Filter>\n    <Filter Include=\"Prscilla\">\n      <UniqueIdentifier>{f4e869f9-d8e3-4338-9ff0-8fc30cd9ea8c}</UniqueIdentifier>\n    </Filter>\n  </ItemGroup>\n  <ItemGroup>\n    <ClCompile Include=\"AboutDlg.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfo.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlg.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlgCopy.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlgInit.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlgMenu.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlgTray.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"DiskInfoDlgUpdate.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"GraphDlg.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"OptionDlg.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"SettingDlg.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"AtaSmart.cpp\">\n      <Filter>Library Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"DHtmlDialogEx.cpp\">\n      <Filter>Library Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"DHtmlMainDialog.cpp\">\n      <Filter>Library Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"EventLog.cpp\">\n      <Filter>Library Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"SoundSettingDlg.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"HealthDlg.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"TemperatureDlg.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"FontSelectionDlg.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\ButtonFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\ComboBoxFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\DialogFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\FontComboBoxFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\HeaderCtrlFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\ListCtrlFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\MainDialogFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\OsInfoFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\StaticFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\UtilityFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\DarkMode.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\EditFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"SlotSpeedGetter.cpp\">\n      <Filter>Library Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"NVMeInterpreter.cpp\">\n      <Filter>Library Files</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\SliderCtrlFx.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Priscilla\\UAHMenuBar.cpp\">\n      <Filter>Prscilla</Filter>\n    </ClCompile>\n    <ClCompile Include=\"Library\\stdafx.cpp\">\n      <Filter>Source Files</Filter>\n    </ClCompile>\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"AboutDlg.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"DiskInfo.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"DiskInfoDlg.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"GraphDlg.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"OptionDlg.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"SettingDlg.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"AtaSmart.h\">\n      <Filter>Library Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"DHtmlDialogEx.h\">\n      <Filter>Library Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"DHtmlMainDialog.h\">\n      <Filter>Library Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"DnpService.h\">\n      <Filter>Library Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"EventLog.h\">\n      <Filter>Library Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"SPTIUtil.h\">\n      <Filter>Library Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"SoundSettingDlg.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"HealthDlg.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"resource.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"StorageQuery.h\">\n      <Filter>Library Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"TemperatureDlg.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"FontSelectionDlg.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\ButtonFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\ComboBoxFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\CommonFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\DialogFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\FontComboBoxFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\HeaderCtrlFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\ListCtrlFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\MainDialogFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\OsInfoFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\StaticFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\UtilityFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\DarkMode.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\EditFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"SlotSpeedGetter.h\">\n      <Filter>Library Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"NVMeInterpreter.h\">\n      <Filter>Library Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\SliderCtrlFx.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"JMicronUsbRaidDef.h\">\n      <Filter>Library Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"CompileOptions.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"JMicronUsbRaidInit.h\">\n      <Filter>Library Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Priscilla\\UAHMenuBar.h\">\n      <Filter>Prscilla</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Library\\stdafx.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Library\\Resource.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Library\\resourceN.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n    <ClInclude Include=\"Library\\resourceS.h\">\n      <Filter>Header Files</Filter>\n    </ClInclude>\n  </ItemGroup>\n  <ItemGroup>\n    <None Include=\"res\\bad.ico\">\n      <Filter>Resource Files</Filter>\n    </None>\n    <None Include=\"res\\caution.ico\">\n      <Filter>Resource Files</Filter>\n    </None>\n    <None Include=\"res\\DiskInfo.rc2\">\n      <Filter>Resource Files</Filter>\n    </None>\n    <None Include=\"res\\dummy.html\">\n      <Filter>Resource Files</Filter>\n    </None>\n    <None Include=\"res\\good.ico\">\n      <Filter>Resource Files</Filter>\n    </None>\n    <None Include=\"res\\unknown.ico\">\n      <Filter>Resource Files</Filter>\n    </None>\n    <None Include=\"res\\00.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\01.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\02.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\03.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\04.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\05.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\06.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\07.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\08.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\09.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\10.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\11.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\12.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\13.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\14.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\15.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\16.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\17.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\18.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\19.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\20.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\21.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\22.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\23.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\24.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\25.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\26.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\27.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\28.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\29.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\30.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\31.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\32.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\33.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\34.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\35.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\36.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\37.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\38.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\39.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\40.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\41.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\42.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\43.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\44.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\45.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\46.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\47.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\48.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\49.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\50.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\51.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\52.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\53.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\54.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\55.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\56.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\57.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\58.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\59.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\60.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\61.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\62.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\63.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\64.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\65.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\66.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\67.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\68.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\69.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\70.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\71.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\72.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\73.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\74.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\75.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\76.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\77.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\78.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\79.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\80.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\81.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\82.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\83.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\84.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\85.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\86.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\87.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\88.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\89.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\90.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\91.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\92.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\93.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\94.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\95.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\96.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\97.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\98.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\99.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F00.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F01.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F02.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F03.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F04.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F05.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F06.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F07.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F08.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F09.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F10.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F11.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F12.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F13.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F14.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F15.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F16.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F17.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F18.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F19.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F20.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F21.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F22.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F23.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F24.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F25.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F26.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F27.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F28.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F29.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F30.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F31.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F32.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F33.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F34.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F35.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F36.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F37.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F38.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F39.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F40.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F41.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F42.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F43.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F44.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F45.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F46.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F47.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F48.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F49.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F50.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F51.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F52.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F53.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F54.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F55.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F56.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F57.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F58.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F59.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F60.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F61.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F62.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F63.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F64.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F65.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F66.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F67.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F68.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F69.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F70.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F71.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F72.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F73.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F74.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F75.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F76.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F77.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F78.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F79.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F80.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F81.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F82.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F83.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F84.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F85.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F86.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F87.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F88.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F89.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F90.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F91.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F92.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F93.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F94.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F95.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F96.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F97.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F98.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\F99.ico\">\n      <Filter>Resource Files\\Temperature Icons</Filter>\n    </None>\n    <None Include=\"res\\goodGreen.ico\">\n      <Filter>Resource Files</Filter>\n    </None>\n    <None Include=\"resS\\DiskInfo.ico\">\n      <Filter>Resource Files</Filter>\n    </None>\n    <None Include=\"resS\\DiskInfo16.ico\">\n      <Filter>Resource Files</Filter>\n    </None>\n    <None Include=\"resN\\DiskInfo.ico\">\n      <Filter>Resource Files</Filter>\n    </None>\n    <None Include=\"resN\\DiskInfo16.ico\">\n      <Filter>Resource Files</Filter>\n    </None>\n    <None Include=\"res\\001soundkenjin.opus\" />\n    <None Include=\".gitattributes\" />\n    <None Include=\".gitignore\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"DiskInfo.rc\">\n      <Filter>Resource Files</Filter>\n    </ResourceCompile>\n    <ResourceCompile Include=\"EventMessage.rc\">\n      <Filter>Resource Files</Filter>\n    </ResourceCompile>\n    <ResourceCompile Include=\"Shizuku.rc\">\n      <Filter>Resource Files</Filter>\n    </ResourceCompile>\n    <ResourceCompile Include=\"Normal.rc\">\n      <Filter>Resource Files</Filter>\n    </ResourceCompile>\n  </ItemGroup>\n  <ItemGroup>\n    <Manifest Include=\"DeclareDPIAware.manifest\">\n      <Filter>Resource Files</Filter>\n    </Manifest>\n  </ItemGroup>\n</Project>"
        },
        {
          "name": "DiskInfoDlg.cpp",
          "type": "blob",
          "size": 91.275390625,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n#include \"AtaSmart.h\"\n\n#include \"UtilityFx.h\"\n#include \"OsInfoFx.h\"\n\n#include <mmsystem.h>\n\n#pragma comment(lib, \"winmm.lib\")\n\n#include \"locale.h\"\n#include <complex>\n\n#include \"digitalv.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n// Global\n\t// Task Tray\n\tUINT gRegMessageId = ::RegisterWindowMessage(_T(\"CrystalDiskInfo\"));\n\tUINT gRegIconId = ::RegisterWindowMessage(_T(\"CrystalDiskInfoIcon\"));\n\tUINT gTempIcon[CAtaSmart::MAX_DISK];\n\n\textern const GUID StrageGUID = { 0x53F56307, 0xB6BF, 0x11D0, \n\t\t\t\t\t  0x94,0xF2,0x00,0xA0,0xC9,0x1E,0xFB,0x8B };\n\nCDiskInfoDlg::CDiskInfoDlg(CWnd* pParent /*=NULL*/, BOOL flagStartupExit)\n\t: CMainDialogFx(CDiskInfoDlg::IDD, pParent)\n{\n\tDebugPrint(L\"CDiskInfoDlg::CDiskInfoDlg - START\");\n\n\tm_Ini = ((CDiskInfoApp*)AfxGetApp())->m_Ini;\n\tm_OffsetX = 0;\n\n#ifdef SUISHO_AOI_SUPPORT\n\tm_DefaultTheme = L\"Aoi\";\n\tm_RecommendTheme = L\"AoiLight\";\n\tm_ThemeKeyName = L\"ThemeAoi\";\n#elif MSI_MEI_SUPPORT\n\tm_DefaultTheme = L\"MSIMei\";\n\tm_RecommendTheme = L\"MSIMei\";\n\tm_ThemeKeyName = L\"ThemeMSIMei\";\n#elif KUREI_KEI_SUPPORT\n\tm_DefaultTheme = L\"KureiKei\";\n\tm_RecommendTheme = L\"KureiKeiRecoding\";\n\tm_ThemeKeyName = L\"ThemeKureiKei\";\n#elif SUISHO_SHIZUKU_SUPPORT\n\tm_DefaultTheme = L\"Shizuku\";\n\tm_RecommendTheme = L\"ShizukuIdol\";\n\tm_ThemeKeyName = L\"ThemeShizuku\";\n#else\n\tm_DefaultTheme = L\"Default\";\n\tm_RecommendTheme = L\"Default\";\n\tm_ThemeKeyName = L\"Theme\";\n#endif\n\n\tm_RandomThemeLabel = L\"Random\";\n\tm_BackgroundName = L\"Background\";\n\n\tm_hMenu = NULL;\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n\tm_hIconMini = AfxGetApp()->LoadIcon(IDI_MINI_ICON);\n\tm_MainIconId = gRegIconId;\n\n\tm_SmartDir = ((CDiskInfoApp*)AfxGetApp())->m_SmartDir;\n//\tm_GadgetDir = ((CDiskInfoApp*)AfxGetApp())->m_GadgetDir;\n\tm_ExeDir = ((CDiskInfoApp*)AfxGetApp())->m_ExeDir;\n\tm_AlertMailPath = ((CDiskInfoApp*)AfxGetApp())->m_AlertMailPath;\n\tm_OpusDecPath = ((CDiskInfoApp*)AfxGetApp())->m_OpusDecPath;\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tm_VoicePath = ((CDiskInfoApp*) AfxGetApp())->m_VoicePath;\n#endif\n#ifdef SUISHO_AOI_SUPPORT\n\tm_VoiceLanguage = ((CDiskInfoApp*)AfxGetApp())->m_VoiceLanguage;\n#endif\n\n\tTCHAR tempPath[MAX_PATH];\n\tGetTempPath(MAX_PATH, tempPath);\n\tm_TempFilePathOpus = tempPath;\n\tm_TempFilePathOpus += _T(\"CrystalDiskInfo.opus\");\n\tm_TempFilePathWave = tempPath;\n\tm_TempFilePathWave += _T(\"CrystalDiskInfo.wav\");\n\n\tm_bStartupExit = flagStartupExit;\n\n\tm_AboutDlg = NULL;\n\tm_SettingDlg = NULL;\n\tm_HealthDlg = NULL;\n\tm_OptionDlg = NULL;\n//\tm_AlarmHistoryDlg = NULL;\n\n\t// Set Default Locale for CStdioFile\n\t_tsetlocale(LC_ALL, _T(\"\"));\n\n\tfor(int i = 0; i < 300; i++)\n\t{\n\t\tm_hTempIcon[0][i] = NULL;\n\t\tm_hTempIcon[1][i] = NULL;\n\t}\n\n\tCString cstr;\n\tfor (int i = 0; i < CAtaSmart::MAX_DISK; i++)\n\t{\n\t\tcstr.Format(L\"TempIcon%d\", i);\n\t\tgTempIcon[i] = ::RegisterWindowMessage(cstr);\n\t\tm_TempIconIndex[i] = gTempIcon[i];\n\t}\n\n\tm_bTrayMainIcon = FALSE;\n\tfor(int i = 0; i < CAtaSmart::MAX_DISK; i++)\n\t{\n\t\tm_PreTemp[i] = 0;\n\t\tm_bTrayTemperatureIcon[i] = FALSE;\n\t}\n\n\tm_SelectDisk = 0;\n\tm_DriveMenuPage = 0;\n\tm_AutoRefreshStatus = 0;\n\tm_WaitTimeStatus = 0;\n\tm_AutoDetectionStatus = 0;\n\tm_RawValues = 0;\n\t\n\tm_NowDetectingUnitPowerOnHours = FALSE;\n\tm_bInitializing = TRUE;\n\n\tDebugPrint(L\"CDiskInfoDlg::CDiskInfoDlg - CENTER\");\n\n\tm_ImageList.Create(16, 16, ILC_COLOR32|ILC_MASK, 3, 1);\n\tm_ImageList.Add(AfxGetApp()->LoadIcon(IDI_GOOD));\n\tm_ImageList.Add(AfxGetApp()->LoadIcon(IDI_GOOD_GREEN));\n\tm_ImageList.Add(AfxGetApp()->LoadIcon(IDI_CAUTION));\n\tm_ImageList.Add(AfxGetApp()->LoadIcon(IDI_BAD));\n\tm_ImageList.Add(AfxGetApp()->LoadIcon(IDI_UNKNOWN));\n\n\tm_bAdvancedDiskSearch = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"AdvancedDiskSearch\"), 0, m_Ini);\n\tm_bWorkaroundHD204UI =  (BOOL)GetPrivateProfileInt(_T(\"Workaround\"), _T(\"HD204UI\"), 0, m_Ini);\n\tm_bWorkaroundIE8MODE =  (BOOL)GetPrivateProfileInt(_T(\"Workaround\"), _T(\"IE8MODE\"), 0, m_Ini);\n\tm_bWorkaroundAdataSsd =  (BOOL)GetPrivateProfileInt(_T(\"Workaround\"), _T(\"AdataSsd\"), 1, m_Ini);\n\tm_bWorkaroundIgnoreC4 = (BOOL) GetPrivateProfileInt(_T(\"Workaround\"), _T(\"IgnoreC4\"), 1, m_Ini);\n\tm_bEventLog = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"EventLog\"), 0, m_Ini);\n\tm_bAlertMail = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"AlertMail\"), 0, m_Ini);\n\tm_bAtaPassThroughSmart = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"AtaPassThroughSmart\"), 1, m_Ini);\n\tm_bAutoAamApm = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"AutoAamApm\"), 0, m_Ini);\n\tm_bDumpIdentifyDevice = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"DumpIdentifyDevice\"), 1, m_Ini);\t\t\t// Default = Enabled\n\tm_bDumpSmartReadData = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"DumpSmartReadData\"), 1, m_Ini);\n\tm_bDumpSmartReadThreshold = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"DumpSmartReadThreshold\"), 1, m_Ini);\n\tm_bResidentMinimize = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"ResidentMinimize\"), 0, m_Ini);\n\tm_bSortDriveLetter = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"SortDriveLetter\"), 1, m_Ini);\n\n\tm_bShowTemperatureIconOnly = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"ShowTemperatureIconOnly\"), 0, m_Ini);\n\tm_bAsciiView = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"AsciiView\"), 0, m_Ini);\n\tm_bSmartEnglish = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"SmartEnglish\"), 0, m_Ini);\n\tm_bAlertSound = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"AlertSound\"), 1, m_Ini);\n\tm_bHideNoSmartDisk = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"HideNoSmartDisk\"), 1, m_Ini);\n\tm_bGreenMode = (BOOL) GetPrivateProfileInt(_T(\"Setting\"), _T(\"GreenMode\"), 0, m_Ini);\n\tm_bForceDisableDarkMode = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"ForceDisableDarkMode\"), 0, m_Ini);\n\tm_bNarrowDriveMenu = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"NarrowDriveMenu\"), 0, m_Ini);\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\t#ifdef MSI_MEI_SUPPORT\n\tm_bStartupVoice = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"StartupVoice\"), 1, m_Ini);\n\t#else\n\tm_bStartupVoice = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"StartupVoice\"), 0, m_Ini);\n\t#endif\n#endif\n\n\tif((BOOL)GetPrivateProfileInt(_T(\"Workaround\"), _T(\"ExecFailed\"), 0, m_Ini))\n\t{\n\t\tm_bAtaPassThroughSmart = FALSE;\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AtaPassThroughSmart\"), _T(\"0\"), m_Ini);\n\t}\n\n\t// Added 2013/04/12 - Workaround for Exec Failed\n\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"ExecFailed\"), _T(\"1\"), m_Ini);\n\t\n\tTCHAR str[256];\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertSoundPath\"), _T(\"\"), str, 256, m_Ini);\n\tm_AlertSoundPath = str;\n\n\tm_bGadget = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"Gadget\"), 0, m_Ini);\n\n\tm_AutoDetectionStatus = GetPrivateProfileInt(_T(\"Setting\"), _T(\"AutoDetection\"), 0, m_Ini);\n\tif(m_AutoDetectionStatus < 0)\n\t{\n\t\tm_AutoDetectionStatus = 0;\n\t}\n\n\tm_RawValues = GetPrivateProfileInt(_T(\"Setting\"), _T(\"RawValues\"), 0, m_Ini);\n\tif(m_RawValues < 0 || m_RawValues > 3)\n\t{\n\t\tm_RawValues = 0;\n\t}\n\n\tm_ZoomType = GetPrivateProfileInt(_T(\"Setting\"), _T(\"ZoomType\"), ZoomTypeAuto, m_Ini);\n\n\t// Setting\n\tSAVE_SMART_PERIOD = GetPrivateProfileInt(_T(\"Setting\"), _T(\"SAVE_SMART_PERIOD\"), 150, m_Ini);\n\tALARM_TEMPERATURE_PERIOD = GetPrivateProfileInt(_T(\"Setting\"), _T(\"ALARM_TEMPERATURE_PERIOD\"), 60 * 60, m_Ini);\n\n\tif(m_bEventLog)\n\t{\n\t\tInstallEventSource();\n\t}\n\telse\n\t{\n\t\tUninstallEventSource();\n\t}\n\n\tif(m_bAtaPassThroughSmart)\n\t{\n\t\tm_Ata.SetAtaPassThroughSmart(TRUE);\n\t}\n\telse\n\t{\n\t\tm_Ata.SetAtaPassThroughSmart(FALSE);\n\t}\n\tm_Ata.CsmiType = GetPrivateProfileInt(_T(\"Setting\"), _T(\"CsmiType\"), m_Ata.CSMI_TYPE_ENABLE_AUTO, m_Ini);\n\n//\tm_BrushDlg.CreateHatchBrush(HS_BDIAGONAL, RGB(0xF0, 0xF0, 0xF0));\n//\tm_BrushDlg.CreatePatternBrush(&m_BitmapBk);\n\n#ifdef SUISHO_AOI_SUPPORT\n\tm_BackgroundName = L\"AoiBackground\";\n#elif MSI_MEI_SUPPORT\n\tm_BackgroundName = L\"Background\";\n#elif KUREI_KEI_SUPPORT\n\tm_BackgroundName = L\"KureiKeiBackground\";\n#elif SUISHO_SHIZUKU_SUPPORT\n\tm_BackgroundName = L\"ShizukuBackground\";\n#else\n\tm_BackgroundName = L\"Background\";\n#endif\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tm_hVoice = LoadLibrary(m_VoicePath);\n\tif (m_hVoice != NULL)\n\t{\n\t\tDebugPrint(L\"m_hVoice != NULL\");\n\t}\n\telse\n\t{\n\t\tDebugPrint(L\"m_hVoice == NULL\");\n\t}\n#endif\n\tDebugPrint(L\"CDiskInfoDlg::CDiskInfoDlg - END\");\n}\n\nCDiskInfoDlg::~CDiskInfoDlg()\n{\n\tif(m_hMenu != NULL)\n\t{\n\t\tDestroyMenu(m_hMenu);\n\t}\n\n\tAlertSound(-1, AS_DEINIT);\n\tDeleteShareInfo();\n\n\tDeleteFile(m_TempFilePathOpus);\n\tDeleteFile(m_TempFilePathWave);\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tif (m_hVoice)\n\t{\n\t\tFreeLibrary(m_hVoice);\n\t}\n#endif\n}\n\nvoid CDiskInfoDlg::OnCancel()\n{\n\tif(m_bResidentMinimize)\n\t{\n\t\tShowWindow(SW_MINIMIZE);\n\t}\n\telse\n\t{\n\t\tShowWindow(SW_HIDE);\n\t}\n\tif(! m_bResident)\n\t{\n\t\tSavePos();\n\n\t\tKillGraphDlg();\n\t\tif(m_hDevNotify)\n\t\t{\n\t\t\tUnregisterDeviceNotification(m_hDevNotify);\n\t\t}\n\t\tCMainDialogFx::OnCancel();\n\t}\n}\n\nvoid CDiskInfoDlg::OnSaveText()\n{\n\tCString path;\n\tSYSTEMTIME st;\n\tGetLocalTime(&st);\n\tpath.Format(L\"%s_%04d%02d%02d%02d%02d%02d\", PRODUCT_NAME, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);\n\n\tCString filter = L\"TEXT (*.txt)|*.txt||\";\n\tCFileDialog save(FALSE, L\"txt\", path, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_EXPLORER, filter);\n\n\tif (save.DoModal() == IDOK)\n\t{\n\t\tSaveText(save.GetPathName());\n\t}\t\n}\n\nvoid CDiskInfoDlg::OnSaveImage()\n{\n\tSaveImage();\n}\n\nvoid CDiskInfoDlg::OnExit()\n{\n\tSavePos();\n\n\tShowWindow(SW_HIDE);\n\tRemoveTrayMainIcon();\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tRemoveTemperatureIcon(i);\n\t}\n\tKillGraphDlg();\n\tCMainDialogFx::OnCancel();\n}\n\nvoid CDiskInfoDlg::OnOK()\n{\n\n}\n\nBOOL CALLBACK EnumWindowsProc(HWND hWnd, LPARAM lParam);\n\nvoid CDiskInfoDlg::KillGraphDlg()\n{\n\t//static HWND hWnd{};\n\tEnumWindows(EnumWindowsProc, (LPARAM)&m_GraphProcessId);\n}\n\nBOOL CALLBACK EnumWindowsProc(HWND hWnd, LPARAM lParam)\n{\n\tCArray<DWORD, DWORD> *id = (CArray<DWORD, DWORD>*)lParam;\n\n\tTCHAR str[1024];\n\tGetWindowText(hWnd, str, 1024);\n\tif(str[0] == 0)\n\t{\n\t\treturn TRUE;\n\t}\n\n\tCString cstr;\n\tcstr = str;\n\n\tif(cstr.Find(_T(\"CrystalDiskInfo - \")) == 0 && cstr.Find(_T(\" - Powered by Flot\")) > 0)\n\t{\n\t\tfor(int i = 0; i < id->GetCount(); i++)\n\t\t{\n\t\t\tDWORD processId = 0;\n\t\t\t::GetWindowThreadProcessId(hWnd, &processId);\n\t\t\tif(processId == id->GetAt(i))\n\t\t\t{\n\t\t\t\tPostMessage(hWnd, WM_QUIT, NULL, NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nvoid CDiskInfoDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCMainDialogFx::DoDataExchange(pDX);\n\n\tDDX_Control(pDX, IDC_LIST, m_List);\n\tDDX_Control(pDX, IDC_BUTTON_DISK0, m_ButtonDisk[0]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK1, m_ButtonDisk[1]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK2, m_ButtonDisk[2]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK3, m_ButtonDisk[3]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK4, m_ButtonDisk[4]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK5, m_ButtonDisk[5]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK6, m_ButtonDisk[6]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK7, m_ButtonDisk[7]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK8, m_ButtonDisk[8]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK9, m_ButtonDisk[9]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK10, m_ButtonDisk[10]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK11, m_ButtonDisk[11]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK12, m_ButtonDisk[12]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK13, m_ButtonDisk[13]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK14, m_ButtonDisk[14]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK15, m_ButtonDisk[15]);\n\n#ifdef MAX_DRIVE_20\n\tDDX_Control(pDX, IDC_BUTTON_DISK16, m_ButtonDisk[16]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK17, m_ButtonDisk[17]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK18, m_ButtonDisk[18]);\n\tDDX_Control(pDX, IDC_BUTTON_DISK19, m_ButtonDisk[19]);\n#endif\n\n\tDDX_Control(pDX, IDC_BUTTON_PRE_DISK, m_CtrlButtonPreDisk);\n\tDDX_Control(pDX, IDC_BUTTON_NEXT_DISK, m_CtrlButtonNextDisk);\n\n\tDDX_Control(pDX, IDC_LABEL_FIRMWARE, m_CtrlLabelFirmware);\n\tDDX_Control(pDX, IDC_LABEL_SERIAL_NUMBER, m_CtrlLabelSerialNumber);\n\tDDX_Control(pDX, IDC_LABEL_INTERFACE, m_CtrlLabelInterface);\n\tDDX_Control(pDX, IDC_LABEL_TRANSFER_MODE, m_CtrlLabelTransferMode);\n\tDDX_Control(pDX, IDC_LABEL_DRIVE_MAP, m_CtrlLabelDriveMap);\n\tDDX_Control(pDX, IDC_LABEL_BUFFER_SIZE, m_CtrlLabelBufferSize);\n\tDDX_Control(pDX, IDC_LABEL_NV_CACHE_SIZE, m_CtrlLabelNvCacheSize);\n\tDDX_Control(pDX, IDC_LABEL_ROTATION_RATE, m_CtrlLabelRotationRate);\n\tDDX_Control(pDX, IDC_LABEL_POWER_ON_COUNT, m_CtrlLabelPowerOnCount);\n\tDDX_Control(pDX, IDC_LABEL_POWER_ON_HOURS, m_CtrlLabelPowerOnHours);\n\tDDX_Control(pDX, IDC_LABEL_ATA_ATAPI, m_CtrlLabelAtaAtapi);\n\tDDX_Control(pDX, IDC_LABEL_FEATURE, m_CtrlLabelFeature);\n\tDDX_Control(pDX, IDC_LABEL_HEALTH_STATUS, m_CtrlLabelDiskStatus);\n\tDDX_Control(pDX, IDC_LABEL_TEMPERATURE, m_CtrlLabelTemperature);\n\n\tDDX_Control(pDX, IDC_VALUE_MODEL, m_CtrlModel);\n\tDDX_Control(pDX, IDC_VALUE_FIRMWARE, m_CtrlFirmware);\n\tDDX_Control(pDX, IDC_VALUE_SERIAL_NUMBER, m_CtrlSerialNumber);\n\tDDX_Control(pDX, IDC_VALUE_INTERFACE, m_CtrlInterface);\n\tDDX_Control(pDX, IDC_VALUE_TRANSFER_MODE, m_CtrlTransferMode);\n\tDDX_Control(pDX, IDC_VALUE_DRIVE_MAP, m_CtrlDriveMap);\n\tDDX_Control(pDX, IDC_VALUE_BUFFER_SIZE, m_CtrlBufferSize);\n\tDDX_Control(pDX, IDC_VALUE_NV_CACHE_SIZE, m_CtrlNvCacheSize);\n\tDDX_Control(pDX, IDC_VALUE_ROTATION_RATE, m_CtrlRotationRate);\n\tDDX_Control(pDX, IDC_VALUE_POWER_ON_COUNT, m_CtrlPowerOnCount);\n\tDDX_Control(pDX, IDC_VALUE_POWER_ON_HOURS, m_CtrlPowerOnHours);\n\tDDX_Control(pDX, IDC_VALUE_ATA_ATAPI, m_CtrlAtaAtapi);\n\tDDX_Control(pDX, IDC_VALUE_FEATURE, m_CtrlFeature);\n\tDDX_Control(pDX, IDC_BUTTON_HEALTH_STATUS, m_CtrlDiskStatus);\n\tDDX_Control(pDX, IDC_BUTTON_TEMPERATURE, m_CtrlTemperature);\n\tDDX_Control(pDX, IDC_BUTTON_LIFE, m_CtrlLife);\n\n\tDDX_Text(pDX, IDC_BUTTON_DISK0, m_LiDisk[0]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK1, m_LiDisk[1]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK2, m_LiDisk[2]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK3, m_LiDisk[3]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK4, m_LiDisk[4]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK5, m_LiDisk[5]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK6, m_LiDisk[6]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK7, m_LiDisk[7]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK8, m_LiDisk[8]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK9, m_LiDisk[9]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK10, m_LiDisk[10]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK11, m_LiDisk[11]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK12, m_LiDisk[12]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK13, m_LiDisk[13]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK14, m_LiDisk[14]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK15, m_LiDisk[15]);\n\n#ifdef MAX_DRIVE_20\n\tDDX_Text(pDX, IDC_BUTTON_DISK16, m_LiDisk[16]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK17, m_LiDisk[17]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK18, m_LiDisk[18]);\n\tDDX_Text(pDX, IDC_BUTTON_DISK19, m_LiDisk[19]);\n#endif\n\n\tDDX_Text(pDX, IDC_LABEL_FIRMWARE, m_LabelFirmware);\n\tDDX_Text(pDX, IDC_LABEL_SERIAL_NUMBER, m_LabelSerialNumber);\n\tDDX_Text(pDX, IDC_LABEL_INTERFACE, m_LabelInterface);\n\tDDX_Text(pDX, IDC_LABEL_TRANSFER_MODE, m_LabelTransferMode);\n\tDDX_Text(pDX, IDC_LABEL_DRIVE_MAP, m_LabelDriveMap);\n\tDDX_Text(pDX, IDC_LABEL_BUFFER_SIZE, m_LabelBufferSize);\n\tDDX_Text(pDX, IDC_LABEL_NV_CACHE_SIZE, m_LabelNvCacheSize);\n\tDDX_Text(pDX, IDC_LABEL_ROTATION_RATE, m_LabelRotationRate);\n\tDDX_Text(pDX, IDC_LABEL_POWER_ON_COUNT, m_LabelPowerOnCount);\n\tDDX_Text(pDX, IDC_LABEL_POWER_ON_HOURS, m_LabelPowerOnHours);\n\tDDX_Text(pDX, IDC_LABEL_ATA_ATAPI, m_LabelAtaAtapi);\n\tDDX_Text(pDX, IDC_LABEL_FEATURE, m_LabelFeature);\n\tDDX_Text(pDX, IDC_LABEL_HEALTH_STATUS, m_LabelDiskStatus);\n\tDDX_Text(pDX, IDC_LABEL_TEMPERATURE, m_LabelTemperature);\n\n\tDDX_Text(pDX, IDC_VALUE_MODEL, m_ModelCapacity);\n\tDDX_Text(pDX, IDC_VALUE_FIRMWARE, m_Firmware);\n\tDDX_Text(pDX, IDC_VALUE_SERIAL_NUMBER, m_SerialNumber);\n\tDDX_Text(pDX, IDC_VALUE_INTERFACE, m_Interface);\n\tDDX_Text(pDX, IDC_VALUE_TRANSFER_MODE, m_TransferMode);\n\tDDX_Text(pDX, IDC_VALUE_DRIVE_MAP, m_DriveMap);\n\tDDX_Text(pDX, IDC_VALUE_BUFFER_SIZE, m_BufferSize);\n\tDDX_Text(pDX, IDC_VALUE_NV_CACHE_SIZE, m_NvCacheSize);\n\tDDX_Text(pDX, IDC_VALUE_ROTATION_RATE, m_RotationRate);\n\tDDX_Text(pDX, IDC_VALUE_POWER_ON_COUNT, m_PowerOnCount);\n\tDDX_Text(pDX, IDC_VALUE_POWER_ON_HOURS, m_PowerOnHours);\n\tDDX_Text(pDX, IDC_VALUE_ATA_ATAPI, m_AtaAtapi);\n\tDDX_Text(pDX, IDC_VALUE_FEATURE, m_Feature);\n\tDDX_Text(pDX, IDC_BUTTON_HEALTH_STATUS, m_DiskStatus);\n\tDDX_Text(pDX, IDC_BUTTON_TEMPERATURE, m_Temperature);\n\tDDX_Text(pDX, IDC_BUTTON_LIFE, m_Life);\n\n\tDDX_Control(pDX, IDC_BUTTON_VOICE, m_CtrlVoice);\n\tDDX_Control(pDX, IDC_BUTTON_VOICE_HIDE, m_CtrlVoiceHide);\n\tDDX_Control(pDX, IDC_BUTTON_COPYRIGHT, m_CtrlCopyright);\n}\n\nBEGIN_MESSAGE_MAP(CDiskInfoDlg, CMainDialogFx)\n\t//}}AFX_MSG_MAP\n\tON_WM_PAINT()\n\tON_WM_GETMINMAXINFO()\n\tON_WM_SIZE()\n\tON_WM_TIMER()\n\tON_COMMAND(ID_SAVE_TEXT, &CDiskInfoDlg::OnSaveText)\n\tON_COMMAND(ID_SAVE_IMAGE, &CDiskInfoDlg::OnSaveImage)\n\tON_COMMAND(ID_EXIT, &CDiskInfoDlg::OnExit)\n\tON_COMMAND(ID_ABOUT, &CDiskInfoDlg::OnAbout)\n\tON_COMMAND(ID_HIDE_SMART_INFO, &CDiskInfoDlg::OnHideSmartInfo)\n\tON_COMMAND(ID_HIDE_SERIAL_NUMBER, &CDiskInfoDlg::OnHideSerialNumber)\n\tON_COMMAND(ID_COPY, &CDiskInfoDlg::OnCopy)\n\tON_COMMAND(ID_CRYSTALDEWWORLD, &CDiskInfoDlg::OnCrystalDewWorld)\n\tON_COMMAND(ID_REFRESH, &CDiskInfoDlg::OnRefresh)\n\tON_COMMAND(ID_HELP_ABOUT_SMART, &CDiskInfoDlg::OnHelpAboutSmart)\n\tON_COMMAND(ID_AUTO_REFRESH_DISABLE, &CDiskInfoDlg::OnAutoRefreshDisable)\n\tON_COMMAND(ID_AUTO_REFRESH_01_MIN, &CDiskInfoDlg::OnAutoRefresh01Min)\n\tON_COMMAND(ID_AUTO_REFRESH_03_MIN, &CDiskInfoDlg::OnAutoRefresh03Min)\n\tON_COMMAND(ID_AUTO_REFRESH_05_MIN, &CDiskInfoDlg::OnAutoRefresh05Min)\n\tON_COMMAND(ID_AUTO_REFRESH_10_MIN, &CDiskInfoDlg::OnAutoRefresh10Min)\n\tON_COMMAND(ID_AUTO_REFRESH_30_MIN, &CDiskInfoDlg::OnAutoRefresh30Min)\n\tON_COMMAND(ID_AUTO_REFRESH_60_MIN, &CDiskInfoDlg::OnAutoRefresh60Min)\n\tON_COMMAND(ID_AUTO_REFRESH_120_MIN, &CDiskInfoDlg::OnAutoRefresh120Min)\n\tON_COMMAND(ID_AUTO_REFRESH_180_MIN, &CDiskInfoDlg::OnAutoRefresh180Min)\n\tON_COMMAND(ID_AUTO_REFRESH_360_MIN, &CDiskInfoDlg::OnAutoRefresh360Min)\n\tON_COMMAND(ID_AUTO_REFRESH_720_MIN, &CDiskInfoDlg::OnAutoRefresh720Min)\n\tON_COMMAND(ID_AUTO_REFRESH_1440_MIN, &CDiskInfoDlg::OnAutoRefresh1440Min)\n\tON_COMMAND(ID_OPEN_DISK_MANAGEMENT, &CDiskInfoDlg::OnOpenDiskManagement)\n\tON_COMMAND(ID_OPEN_DEVICE_MANAGER, &CDiskInfoDlg::OnOpenDeviceManager)\n\tON_COMMAND(ID_ADVANCED_DISK_SEARCH, &CDiskInfoDlg::OnAdvancedDiskSearch)\n\tON_COMMAND(ID_WORKAROUND_HD204UI, &CDiskInfoDlg::OnWorkaroundHD204UI)\n\tON_COMMAND(ID_WORKAROUND_IE8MODE, &CDiskInfoDlg::OnWorkaroundIE8MODE)\n\tON_COMMAND(ID_GREEN_MODE, &CDiskInfoDlg::OnGreenMode)\n\tON_COMMAND(ID_DISABLE_DARK_MODE, &CDiskInfoDlg::OnDisableDarkMode)\n\n\tON_COMMAND(ID_WORKAROUND_ADATA_SSD, &CDiskInfoDlg::OnWorkaroundAdataSsd)\n\tON_COMMAND(ID_WORKAROUND_IGNORE_C4, &CDiskInfoDlg::OnWorkaroundIgnoreC4)\n\tON_COMMAND(ID_RESIDENT, &CDiskInfoDlg::OnResident)\n\n\tON_MESSAGE(WM_POWERBROADCAST, &CDiskInfoDlg::OnPowerBroadcast)\n\tON_MESSAGE(WM_DEVICECHANGE, &CDiskInfoDlg::OnDeviceChange)\n\n\tON_MESSAGE(WM_QUERYENDSESSION, &CDiskInfoDlg::OnQueryEndSession)\n\n\n\t// Task Tray\n\tON_REGISTERED_MESSAGE(gRegMessageId, OnRegMessage)\n\tON_REGISTERED_MESSAGE(wmTaskbarCreated, OnTaskbarCreated)\n\n\tON_REGISTERED_MESSAGE(gTempIcon[0], OnTempIcon0)\n\tON_REGISTERED_MESSAGE(gTempIcon[1], OnTempIcon1)\n\tON_REGISTERED_MESSAGE(gTempIcon[2], OnTempIcon2)\n\tON_REGISTERED_MESSAGE(gTempIcon[3], OnTempIcon3)\n\tON_REGISTERED_MESSAGE(gTempIcon[4], OnTempIcon4)\n\tON_REGISTERED_MESSAGE(gTempIcon[5], OnTempIcon5)\n\tON_REGISTERED_MESSAGE(gTempIcon[6], OnTempIcon6)\n\tON_REGISTERED_MESSAGE(gTempIcon[7], OnTempIcon7)\n\tON_REGISTERED_MESSAGE(gTempIcon[8], OnTempIcon8)\n\tON_REGISTERED_MESSAGE(gTempIcon[9], OnTempIcon9)\n\tON_REGISTERED_MESSAGE(gTempIcon[10], OnTempIcon10)\n\tON_REGISTERED_MESSAGE(gTempIcon[11], OnTempIcon11)\n\tON_REGISTERED_MESSAGE(gTempIcon[12], OnTempIcon12)\n\tON_REGISTERED_MESSAGE(gTempIcon[13], OnTempIcon13)\n\tON_REGISTERED_MESSAGE(gTempIcon[14], OnTempIcon14)\n\tON_REGISTERED_MESSAGE(gTempIcon[15], OnTempIcon15)\n\tON_REGISTERED_MESSAGE(gTempIcon[16], OnTempIcon16)\n\tON_REGISTERED_MESSAGE(gTempIcon[17], OnTempIcon17)\n\tON_REGISTERED_MESSAGE(gTempIcon[18], OnTempIcon18)\n\tON_REGISTERED_MESSAGE(gTempIcon[19], OnTempIcon19)\n\tON_REGISTERED_MESSAGE(gTempIcon[20], OnTempIcon20)\n\tON_REGISTERED_MESSAGE(gTempIcon[21], OnTempIcon21)\n\tON_REGISTERED_MESSAGE(gTempIcon[22], OnTempIcon22)\n\tON_REGISTERED_MESSAGE(gTempIcon[23], OnTempIcon23)\n\tON_REGISTERED_MESSAGE(gTempIcon[24], OnTempIcon24)\n\tON_REGISTERED_MESSAGE(gTempIcon[25], OnTempIcon25)\n\tON_REGISTERED_MESSAGE(gTempIcon[26], OnTempIcon26)\n\tON_REGISTERED_MESSAGE(gTempIcon[27], OnTempIcon27)\n\tON_REGISTERED_MESSAGE(gTempIcon[28], OnTempIcon28)\n\tON_REGISTERED_MESSAGE(gTempIcon[29], OnTempIcon29)\n\tON_REGISTERED_MESSAGE(gTempIcon[30], OnTempIcon30)\n\tON_REGISTERED_MESSAGE(gTempIcon[31], OnTempIcon31)\n\tON_REGISTERED_MESSAGE(gTempIcon[32], OnTempIcon32)\n\tON_REGISTERED_MESSAGE(gTempIcon[33], OnTempIcon33)\n\tON_REGISTERED_MESSAGE(gTempIcon[34], OnTempIcon34)\n\tON_REGISTERED_MESSAGE(gTempIcon[35], OnTempIcon35)\n\tON_REGISTERED_MESSAGE(gTempIcon[36], OnTempIcon36)\n\tON_REGISTERED_MESSAGE(gTempIcon[37], OnTempIcon37)\n\tON_REGISTERED_MESSAGE(gTempIcon[38], OnTempIcon38)\n\tON_REGISTERED_MESSAGE(gTempIcon[39], OnTempIcon39)\n\tON_REGISTERED_MESSAGE(gTempIcon[40], OnTempIcon40)\n\tON_REGISTERED_MESSAGE(gTempIcon[41], OnTempIcon41)\n\tON_REGISTERED_MESSAGE(gTempIcon[42], OnTempIcon42)\n\tON_REGISTERED_MESSAGE(gTempIcon[43], OnTempIcon43)\n\tON_REGISTERED_MESSAGE(gTempIcon[44], OnTempIcon44)\n\tON_REGISTERED_MESSAGE(gTempIcon[45], OnTempIcon45)\n\tON_REGISTERED_MESSAGE(gTempIcon[46], OnTempIcon46)\n\tON_REGISTERED_MESSAGE(gTempIcon[47], OnTempIcon47)\n\tON_REGISTERED_MESSAGE(gTempIcon[48], OnTempIcon48)\n\tON_REGISTERED_MESSAGE(gTempIcon[49], OnTempIcon49)\n\tON_REGISTERED_MESSAGE(gTempIcon[50], OnTempIcon50)\n\tON_REGISTERED_MESSAGE(gTempIcon[51], OnTempIcon51)\n\tON_REGISTERED_MESSAGE(gTempIcon[52], OnTempIcon52)\n\tON_REGISTERED_MESSAGE(gTempIcon[53], OnTempIcon53)\n\tON_REGISTERED_MESSAGE(gTempIcon[54], OnTempIcon54)\n\tON_REGISTERED_MESSAGE(gTempIcon[55], OnTempIcon55)\n\tON_REGISTERED_MESSAGE(gTempIcon[56], OnTempIcon56)\n\tON_REGISTERED_MESSAGE(gTempIcon[57], OnTempIcon57)\n\tON_REGISTERED_MESSAGE(gTempIcon[58], OnTempIcon58)\n\tON_REGISTERED_MESSAGE(gTempIcon[59], OnTempIcon59)\n\tON_REGISTERED_MESSAGE(gTempIcon[60], OnTempIcon60)\n\tON_REGISTERED_MESSAGE(gTempIcon[61], OnTempIcon61)\n\tON_REGISTERED_MESSAGE(gTempIcon[62], OnTempIcon62)\n\tON_REGISTERED_MESSAGE(gTempIcon[63], OnTempIcon63)\n\tON_REGISTERED_MESSAGE(gTempIcon[64], OnTempIcon64)\n\tON_REGISTERED_MESSAGE(gTempIcon[65], OnTempIcon65)\n\tON_REGISTERED_MESSAGE(gTempIcon[66], OnTempIcon66)\n\tON_REGISTERED_MESSAGE(gTempIcon[67], OnTempIcon67)\n\tON_REGISTERED_MESSAGE(gTempIcon[68], OnTempIcon68)\n\tON_REGISTERED_MESSAGE(gTempIcon[69], OnTempIcon69)\n\tON_REGISTERED_MESSAGE(gTempIcon[70], OnTempIcon70)\n\tON_REGISTERED_MESSAGE(gTempIcon[71], OnTempIcon71)\n\tON_REGISTERED_MESSAGE(gTempIcon[72], OnTempIcon72)\n\tON_REGISTERED_MESSAGE(gTempIcon[73], OnTempIcon73)\n\tON_REGISTERED_MESSAGE(gTempIcon[74], OnTempIcon74)\n\tON_REGISTERED_MESSAGE(gTempIcon[75], OnTempIcon75)\n\tON_REGISTERED_MESSAGE(gTempIcon[76], OnTempIcon76)\n\tON_REGISTERED_MESSAGE(gTempIcon[77], OnTempIcon77)\n\tON_REGISTERED_MESSAGE(gTempIcon[78], OnTempIcon78)\n\tON_REGISTERED_MESSAGE(gTempIcon[79], OnTempIcon79)\n/*\n\tON_REGISTERED_MESSAGE(gTempIcon[80], OnTempIcon80)\n\tON_REGISTERED_MESSAGE(gTempIcon[81], OnTempIcon81)\n\tON_REGISTERED_MESSAGE(gTempIcon[82], OnTempIcon82)\n\tON_REGISTERED_MESSAGE(gTempIcon[83], OnTempIcon83)\n\tON_REGISTERED_MESSAGE(gTempIcon[84], OnTempIcon84)\n\tON_REGISTERED_MESSAGE(gTempIcon[85], OnTempIcon85)\n\tON_REGISTERED_MESSAGE(gTempIcon[86], OnTempIcon86)\n\tON_REGISTERED_MESSAGE(gTempIcon[87], OnTempIcon87)\n\tON_REGISTERED_MESSAGE(gTempIcon[88], OnTempIcon88)\n\tON_REGISTERED_MESSAGE(gTempIcon[89], OnTempIcon89)\n\tON_REGISTERED_MESSAGE(gTempIcon[90], OnTempIcon90)\n\tON_REGISTERED_MESSAGE(gTempIcon[91], OnTempIcon91)\n\tON_REGISTERED_MESSAGE(gTempIcon[92], OnTempIcon92)\n\tON_REGISTERED_MESSAGE(gTempIcon[93], OnTempIcon93)\n\tON_REGISTERED_MESSAGE(gTempIcon[94], OnTempIcon94)\n\tON_REGISTERED_MESSAGE(gTempIcon[95], OnTempIcon95)\n\tON_REGISTERED_MESSAGE(gTempIcon[96], OnTempIcon96)\n\tON_REGISTERED_MESSAGE(gTempIcon[97], OnTempIcon97)\n\tON_REGISTERED_MESSAGE(gTempIcon[98], OnTempIcon98)\n\tON_REGISTERED_MESSAGE(gTempIcon[99], OnTempIcon99)\n\tON_REGISTERED_MESSAGE(gTempIcon[100], OnTempIcon100)\n\tON_REGISTERED_MESSAGE(gTempIcon[101], OnTempIcon101)\n\tON_REGISTERED_MESSAGE(gTempIcon[102], OnTempIcon102)\n\tON_REGISTERED_MESSAGE(gTempIcon[103], OnTempIcon103)\n\tON_REGISTERED_MESSAGE(gTempIcon[104], OnTempIcon104)\n\tON_REGISTERED_MESSAGE(gTempIcon[105], OnTempIcon105)\n\tON_REGISTERED_MESSAGE(gTempIcon[106], OnTempIcon106)\n\tON_REGISTERED_MESSAGE(gTempIcon[107], OnTempIcon107)\n\tON_REGISTERED_MESSAGE(gTempIcon[108], OnTempIcon108)\n\tON_REGISTERED_MESSAGE(gTempIcon[109], OnTempIcon109)\n\tON_REGISTERED_MESSAGE(gTempIcon[110], OnTempIcon110)\n\tON_REGISTERED_MESSAGE(gTempIcon[111], OnTempIcon111)\n\tON_REGISTERED_MESSAGE(gTempIcon[112], OnTempIcon112)\n\tON_REGISTERED_MESSAGE(gTempIcon[113], OnTempIcon113)\n\tON_REGISTERED_MESSAGE(gTempIcon[114], OnTempIcon114)\n\tON_REGISTERED_MESSAGE(gTempIcon[115], OnTempIcon115)\n\tON_REGISTERED_MESSAGE(gTempIcon[116], OnTempIcon116)\n\tON_REGISTERED_MESSAGE(gTempIcon[117], OnTempIcon117)\n\tON_REGISTERED_MESSAGE(gTempIcon[118], OnTempIcon118)\n\tON_REGISTERED_MESSAGE(gTempIcon[119], OnTempIcon119)\n\tON_REGISTERED_MESSAGE(gTempIcon[120], OnTempIcon120)\n\tON_REGISTERED_MESSAGE(gTempIcon[121], OnTempIcon121)\n\tON_REGISTERED_MESSAGE(gTempIcon[122], OnTempIcon122)\n\tON_REGISTERED_MESSAGE(gTempIcon[123], OnTempIcon123)\n\tON_REGISTERED_MESSAGE(gTempIcon[124], OnTempIcon124)\n\tON_REGISTERED_MESSAGE(gTempIcon[125], OnTempIcon125)\n\tON_REGISTERED_MESSAGE(gTempIcon[126], OnTempIcon126)\n\tON_REGISTERED_MESSAGE(gTempIcon[127], OnTempIcon127)\n*/\n\n\tON_COMMAND(ID_GRAPH, &CDiskInfoDlg::OnGraph)\n\tON_COMMAND(ID_HELP, &CDiskInfoDlg::OnHelp)\n\tON_COMMAND(ID_CUSTOMIZE, &CDiskInfoDlg::OnCustomize)\n\tON_COMMAND(ID_STARTUP, &CDiskInfoDlg::OnStartup)\n\tON_COMMAND(ID_WAIT_0_SEC, &CDiskInfoDlg::OnWait0Sec)\n\tON_COMMAND(ID_WAIT_5_SEC, &CDiskInfoDlg::OnWait5Sec)\n\tON_COMMAND(ID_WAIT_10_SEC, &CDiskInfoDlg::OnWait10Sec)\n\tON_COMMAND(ID_WAIT_15_SEC, &CDiskInfoDlg::OnWait15Sec)\n\tON_COMMAND(ID_WAIT_20_SEC, &CDiskInfoDlg::OnWait20Sec)\n\tON_COMMAND(ID_WAIT_30_SEC, &CDiskInfoDlg::OnWait30Sec)\n\tON_COMMAND(ID_WAIT_40_SEC, &CDiskInfoDlg::OnWait40Sec)\n\tON_COMMAND(ID_WAIT_50_SEC, &CDiskInfoDlg::OnWait50Sec)\n\tON_COMMAND(ID_WAIT_60_SEC, &CDiskInfoDlg::OnWait60Sec)\n\tON_COMMAND(ID_WAIT_90_SEC, &CDiskInfoDlg::OnWait90Sec)\n\tON_COMMAND(ID_WAIT_120_SEC, &CDiskInfoDlg::OnWait120Sec)\n\tON_COMMAND(ID_WAIT_150_SEC, &CDiskInfoDlg::OnWait150Sec)\n\tON_COMMAND(ID_WAIT_180_SEC, &CDiskInfoDlg::OnWait180Sec)\n\tON_COMMAND(ID_WAIT_210_SEC, &CDiskInfoDlg::OnWait210Sec)\n\tON_COMMAND(ID_WAIT_240_SEC, &CDiskInfoDlg::OnWait240Sec)\n\n\tON_COMMAND(ID_AUTO_DETECTION_05_SEC, &CDiskInfoDlg::OnAutoDetection05Sec)\n\tON_COMMAND(ID_AUTO_DETECTION_10_SEC, &CDiskInfoDlg::OnAutoDetection10Sec)\n\tON_COMMAND(ID_AUTO_DETECTION_20_SEC, &CDiskInfoDlg::OnAutoDetection20Sec)\n\tON_COMMAND(ID_AUTO_DETECTION_30_SEC, &CDiskInfoDlg::OnAutoDetection30Sec)\n\tON_COMMAND(ID_AUTO_DETECTION_DISABLE, &CDiskInfoDlg::OnAutoDetectionDisable)\n\n\tON_COMMAND(ID_EVENT_LOG, &CDiskInfoDlg::OnEventLog)\n\tON_COMMAND(ID_ATA_PASS_THROUGH_SMART, &CDiskInfoDlg::OnAtaPassThroughSmart)\n\tON_COMMAND(ID_GADGET_SUPPORT, &CDiskInfoDlg::OnGadgetSupport)\n\tON_COMMAND(ID_CELSIUS, &CDiskInfoDlg::OnCelsius)\n\tON_COMMAND(ID_FAHRENHEIT, &CDiskInfoDlg::OnFahrenheit)\n\tON_COMMAND(ID_AAM_APM, &CDiskInfoDlg::OnAamApm)\n\tON_COMMAND(ID_TEMPERATURE, &CDiskInfoDlg::OnTemperature)\n\tON_COMMAND(ID_AUTO_AAM_APM, &CDiskInfoDlg::OnAutoAamApm)\n\tON_COMMAND(ID_RESCAN, &CDiskInfoDlg::OnRescan)\n\tON_COMMAND(ID_USB_SAT, &CDiskInfoDlg::OnUsbSat)\n\tON_COMMAND(ID_USB_IODATA, &CDiskInfoDlg::OnUsbIodata)\n\tON_COMMAND(ID_USB_SUNPLUS, &CDiskInfoDlg::OnUsbSunplus)\n\tON_COMMAND(ID_USB_LOGITEC, &CDiskInfoDlg::OnUsbLogitec)\n\tON_COMMAND(ID_USB_PROLIFIC, &CDiskInfoDlg::OnUsbProlific)\n\tON_COMMAND(ID_USB_JMICRON, &CDiskInfoDlg::OnUsbJmicron)\n\tON_COMMAND(ID_USB_CYPRESS, &CDiskInfoDlg::OnUsbCypress)\n\tON_COMMAND(ID_USB_ASM1352R, &CDiskInfoDlg::OnUsbASM1352R)\n\tON_COMMAND(ID_USB_REALTEK9220DP, &CDiskInfoDlg::OnUsbRealtek9220DP)\n\tON_COMMAND(ID_USB_MEMORY, &CDiskInfoDlg::OnUsbMemory)\n\t//ON_COMMAND(ID_USB_SAT16, &CDiskInfoDlg::OnUsbSat16)\n\tON_COMMAND(ID_USB_NVME_JMICRON3, &CDiskInfoDlg::OnUsbNVMeJMicron3)\n\tON_COMMAND(ID_USB_NVME_JMICRON, &CDiskInfoDlg::OnUsbNVMeJMicron)\n\tON_COMMAND(ID_USB_NVME_ASMEDIA, &CDiskInfoDlg::OnUsbNVMeASMedia)\n\tON_COMMAND(ID_USB_NVME_REALTEK, &CDiskInfoDlg::OnUsbNVMeRealtek)\n\tON_COMMAND(ID_AMD_RC2T7, &CDiskInfoDlg::OnAMD_RC2)\n\tON_COMMAND(ID_MEGA_RAID, &CDiskInfoDlg::OnMegaRAID)\n\tON_COMMAND(ID_INTEL_VROC, &CDiskInfoDlg::OnIntelVROC)\n#ifdef JMICRON_USB_RAID_SUPPORT\n\tON_COMMAND(ID_USB_JMS56X, &CDiskInfoDlg::OnUsbJMS56X)\n\tON_COMMAND(ID_USB_JMB39X, &CDiskInfoDlg::OnUsbJMB39X)\n\tON_COMMAND(ID_USB_JMS586_20, &CDiskInfoDlg::OnUsbJMS586_20)\n\tON_COMMAND(ID_USB_JMS586_40, &CDiskInfoDlg::OnUsbJMS586_40)\n\n#endif\n\tON_COMMAND(ID_USB_ENABLE_ALL, &CDiskInfoDlg::OnUsbEnableAll)\n\tON_COMMAND(ID_USB_DISABLE_ALL, &CDiskInfoDlg::OnUsbDisableAll)\n\tON_COMMAND(ID_HEALTH_STATUS, &CDiskInfoDlg::OnHealthStatus)\n\tON_COMMAND(ID_SOUND_SETTINGS, &CDiskInfoDlg::OnSoundSetting)\n\tON_COMMAND(ID_DUMP_IDENTIFY_DEVICE, &CDiskInfoDlg::OnDumpIdentifyDevice)\n\tON_COMMAND(ID_DUMP_SMART_READ_DATA, &CDiskInfoDlg::OnDumpSmartReadData)\n\tON_COMMAND(ID_DUMP_SMART_READ_THRESHOLD, &CDiskInfoDlg::OnDumpSmartReadThreshold)\n\tON_COMMAND(ID_RESIDENT_HIDE, &CDiskInfoDlg::OnResidentHide)\n\tON_COMMAND(ID_RESIDENT_MINIMIZE, &CDiskInfoDlg::OnResidentMinimize)\n\tON_COMMAND(ID_SORT_PHYSICAL_DRIVE_ID, &CDiskInfoDlg::OnSortPhysicalDriveId)\n\tON_COMMAND(ID_SORT_DRIVE_LETTER, &CDiskInfoDlg::OnSortDriveLetter)\n\tON_COMMAND(ID_DRIVE_MENU_8, &CDiskInfoDlg::OnDriveMenu8)\n\tON_COMMAND(ID_DRIVE_MENU_16, &CDiskInfoDlg::OnDriveMenu16)\n#ifdef MAX_DRIVE_20\n\tON_COMMAND(ID_DRIVE_MENU_10, &CDiskInfoDlg::OnDriveMenu10)\n\tON_COMMAND(ID_DRIVE_MENU_20, &CDiskInfoDlg::OnDriveMenu20)\n#endif\n\tON_COMMAND(ID_ZOOM_100, &CDiskInfoDlg::OnZoom100)\n\tON_COMMAND(ID_ZOOM_125, &CDiskInfoDlg::OnZoom125)\n\tON_COMMAND(ID_ZOOM_150, &CDiskInfoDlg::OnZoom150)\n\tON_COMMAND(ID_ZOOM_200, &CDiskInfoDlg::OnZoom200)\n\tON_COMMAND(ID_ZOOM_250, &CDiskInfoDlg::OnZoom250)\n\tON_COMMAND(ID_ZOOM_300, &CDiskInfoDlg::OnZoom300)\n\tON_COMMAND(ID_ZOOM_AUTO, &CDiskInfoDlg::OnZoomAuto)\n\tON_COMMAND(ID_RAW_VALUES_16, &CDiskInfoDlg::OnRawValues16)\n\tON_COMMAND(ID_RAW_VALUES_10_ALL, &CDiskInfoDlg::OnRawValues10All)\n\tON_COMMAND(ID_RAW_VALUES_2BYTE, &CDiskInfoDlg::OnRawValues2byte)\n\tON_COMMAND(ID_RAW_VALUES_1BYTE, &CDiskInfoDlg::OnRawValues1byte)\n\tON_COMMAND(ID_ASCII_VIEW, &CDiskInfoDlg::OnAsciiView)\n\tON_COMMAND(ID_ALERT_MAIL, &CDiskInfoDlg::OnAlertMail)\n\tON_COMMAND(ID_MAIL_SETTINGS, &CDiskInfoDlg::OnMailSettings)\n\tON_COMMAND(ID_SMART_ENGLISH, &CDiskInfoDlg::OnSmartEnglish)\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\t\tON_COMMAND(ID_STARTUP_VOICE, &CDiskInfoDlg::OnStartupVoice)\n#endif\n#ifdef SUISHO_AOI_SUPPORT\n\t\tON_COMMAND(ID_VOICE_ENGLISH, &CDiskInfoDlg::OnVoiceEnglish)\n\t\tON_COMMAND(ID_VOICE_JAPANESE, &CDiskInfoDlg::OnVoiceJapanese)\n#endif\n\tON_COMMAND(ID_FONT_SETTING, &CDiskInfoDlg::OnFontSetting)\n\tON_COMMAND(ID_CSMI_DISABLE, &CDiskInfoDlg::OnCsmiDisable)\n\tON_COMMAND(ID_CSMI_ENABLE_AUTO, &CDiskInfoDlg::OnCsmiEnableAuto)\n\tON_COMMAND(ID_CSMI_ENABLE_RAID, &CDiskInfoDlg::OnCsmiEnableRaid)\n\tON_COMMAND(ID_CSMI_ENABLE_ALL, &CDiskInfoDlg::OnCsmiEnableAll)\n//\tON_COMMAND(ID_INSTALL_GADGET, &CDiskInfoDlg::OnInstallGadget)\n//\tON_COMMAND(ID_ALARM_HISTORY, &CDiskInfoDlg::OnAlarmHistory)\n\tON_COMMAND(ID_ALERT_SOUND, &CDiskInfoDlg::OnAlertSound)\n\tON_COMMAND(ID_HIDE_NO_SMART_DISK, &CDiskInfoDlg::OnHideNoSmartDisk)\n\n\tON_MESSAGE(MY_PLAY_ALERT_SOUND, OnPlayAlertSound)\n\tON_BN_CLICKED(IDC_BUTTON_DISK0, &CDiskInfoDlg::OnBnClickedButtonDisk0)\n\tON_BN_CLICKED(IDC_BUTTON_DISK1, &CDiskInfoDlg::OnBnClickedButtonDisk1)\n\tON_BN_CLICKED(IDC_BUTTON_DISK2, &CDiskInfoDlg::OnBnClickedButtonDisk2)\n\tON_BN_CLICKED(IDC_BUTTON_DISK3, &CDiskInfoDlg::OnBnClickedButtonDisk3)\n\tON_BN_CLICKED(IDC_BUTTON_DISK4, &CDiskInfoDlg::OnBnClickedButtonDisk4)\n\tON_BN_CLICKED(IDC_BUTTON_DISK5, &CDiskInfoDlg::OnBnClickedButtonDisk5)\n\tON_BN_CLICKED(IDC_BUTTON_DISK6, &CDiskInfoDlg::OnBnClickedButtonDisk6)\n\tON_BN_CLICKED(IDC_BUTTON_DISK7, &CDiskInfoDlg::OnBnClickedButtonDisk7)\n\tON_BN_CLICKED(IDC_BUTTON_DISK8, &CDiskInfoDlg::OnBnClickedButtonDisk8)\n\tON_BN_CLICKED(IDC_BUTTON_DISK9, &CDiskInfoDlg::OnBnClickedButtonDisk9)\n\tON_BN_CLICKED(IDC_BUTTON_DISK10, &CDiskInfoDlg::OnBnClickedButtonDisk10)\n\tON_BN_CLICKED(IDC_BUTTON_DISK11, &CDiskInfoDlg::OnBnClickedButtonDisk11)\n\tON_BN_CLICKED(IDC_BUTTON_DISK12, &CDiskInfoDlg::OnBnClickedButtonDisk12)\n\tON_BN_CLICKED(IDC_BUTTON_DISK13, &CDiskInfoDlg::OnBnClickedButtonDisk13)\n\tON_BN_CLICKED(IDC_BUTTON_DISK14, &CDiskInfoDlg::OnBnClickedButtonDisk14)\n\tON_BN_CLICKED(IDC_BUTTON_DISK15, &CDiskInfoDlg::OnBnClickedButtonDisk15)\n#ifdef MAX_DRIVE_20\n\tON_BN_CLICKED(IDC_BUTTON_DISK16, &CDiskInfoDlg::OnBnClickedButtonDisk16)\n\tON_BN_CLICKED(IDC_BUTTON_DISK17, &CDiskInfoDlg::OnBnClickedButtonDisk17)\n\tON_BN_CLICKED(IDC_BUTTON_DISK18, &CDiskInfoDlg::OnBnClickedButtonDisk18)\n\tON_BN_CLICKED(IDC_BUTTON_DISK19, &CDiskInfoDlg::OnBnClickedButtonDisk19)\n#endif\n\n\tON_BN_CLICKED(IDC_BUTTON_PRE_DISK, &CDiskInfoDlg::OnBnClickedButtonPreDisk)\n\tON_BN_CLICKED(IDC_BUTTON_NEXT_DISK, &CDiskInfoDlg::OnBnClickedButtonNextDisk)\n\tON_BN_CLICKED(IDC_BUTTON_HEALTH_STATUS, &CDiskInfoDlg::OnBnClickedButtonHealthStatus)\n\tON_BN_CLICKED(IDC_BUTTON_TEMPERATURE, &CDiskInfoDlg::OnBnClickedButtonTemperature)\n\tON_BN_CLICKED(IDC_BUTTON_VOICE, &CDiskInfoDlg::OnBnClickedButtonVoice)\n\tON_BN_CLICKED(IDC_BUTTON_COPYRIGHT, &CDiskInfoDlg::OnBnClickedButtonCopyright)\n\tON_BN_CLICKED(IDC_BUTTON_LIFE, &CDiskInfoDlg::OnBnClickedButtonLife)\n\tON_WM_SHOWWINDOW()\n\tON_WM_NCCREATE()\nEND_MESSAGE_MAP()\n\nLRESULT CDiskInfoDlg::OnPlayAlertSound(WPARAM wParam, LPARAM lParam)\n{\n\tstatic int id = 0;\n\tstatic int idlist[21] = {1, 2, 3, 4, 5, 6, 7, 8, 601, 602, 603, 604, 605, 606, 607, 701, 702, 703, 704, 705, 707};\n\n\tif(wParam == NULL)\n\t{\n\t\tid = idlist[rand() % 21];\n\t}\n\telse\n\t{\n\t\tid = (int)wParam;\n\t}\n\n\tTCHAR str[256];\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertSoundPath\"), _T(\"\"), str, 256, m_Ini);\n\tm_AlertSoundPath = str;\n\tif (m_AlertSoundPath.Compare(_T(\"\")) != 0)\n\t{\n\t\tid = 601;\n\t}\n\n\tAlertSound(id, AS_SET_SOUND_ID);\n\tAlertSound(1000, AS_PLAY_SOUND);\n\n\treturn 0;\n}\n\n// If you add a minimize button to your dialog, you will need the code below\n//  to draw the icon.  For MFC applications using the document/view model,\n//  this is automatically done for you by the framework.\nvoid CDiskInfoDlg::OnPaint()\n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // device context for painting\n\n\t\tSendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);\n\n\t\t// Center icon in client rectangle\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// Draw the icon\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t//\tCPaintDC dc(this);\n    //  dc.DrawState(CPoint(0, 0), CSize((int)(1000 * m_ZoomRatio), (int)(1000 * m_ZoomRatio)), m_BitmapBk, DST_BITMAP);\n\t\tCMainDialogFx::OnPaint();\n\t}\n}\n\n// The system calls this function to obtain the cursor to display while the user drags\n//  the minimized window.\nHCURSOR CDiskInfoDlg::OnQueryDragIcon()\n{\n\treturn static_cast<HCURSOR>(m_hIcon);\n}\n\n\nBOOL CDiskInfoDlg::OnCommand(WPARAM wParam, LPARAM lParam) \n{\n\tif(WM_LANGUAGE_ID <= wParam && wParam < (WPARAM)WM_LANGUAGE_ID + m_MenuArrayLang.GetSize())\n\t{\n#ifdef _UNICODE\n\t\tCMenu menu;\n\t\tCMenu subMenu;\n\t\tCMenu subMenuAN;\n\t\tCMenu subMenuOZ;\n\t\tmenu.Attach(GetMenu()->GetSafeHmenu());\n\t\tsubMenu.Attach(menu.GetSubMenu(MENU_LANG_INDEX)->GetSafeHmenu());\n\t\tsubMenuAN.Attach(subMenu.GetSubMenu(0)->GetSafeHmenu());\n\t\tsubMenuOZ.Attach(subMenu.GetSubMenu(1)->GetSafeHmenu());\n\n\t\tm_CurrentLang = m_MenuArrayLang.GetAt(wParam - WM_LANGUAGE_ID);\n\t\tChangeLang(m_MenuArrayLang.GetAt(wParam - WM_LANGUAGE_ID));\n\t\tsubMenuAN.CheckMenuRadioItem(WM_LANGUAGE_ID, WM_LANGUAGE_ID + (UINT)m_MenuArrayLang.GetSize(),\n\t\t\t\t\t\t\t\t\t(UINT)wParam, MF_BYCOMMAND);\n\t\tsubMenuOZ.CheckMenuRadioItem(WM_LANGUAGE_ID, WM_LANGUAGE_ID + (UINT)m_MenuArrayLang.GetSize(),\n\t\t\t\t\t\t\t\t\t(UINT)wParam, MF_BYCOMMAND);\n\n\t\tsubMenuOZ.Detach();\n\t\tsubMenuAN.Detach();\n\t\tsubMenu.Detach();\n\t\tmenu.Detach();\n#else\n\t\tCMenu menu;\n\t\tCMenu subMenu;\n\t\tmenu.Attach(GetMenu()->GetSafeHmenu());\n\t\tsubMenu.Attach(menu.GetSubMenu(MENU_LANG_INDEX)->GetSafeHmenu());\n\n\t\tm_CurrentLang = m_MenuArrayLang.GetAt(wParam - WM_LANGUAGE_ID);\n\t\tChangeLang(m_MenuArrayLang.GetAt(wParam - WM_LANGUAGE_ID));\n\t\tsubMenu.CheckMenuRadioItem(WM_LANGUAGE_ID, WM_LANGUAGE_ID + (UINT)m_MenuArrayLang.GetSize(),\n\t\t\t\t\t\t\t\t\t(UINT)wParam, MF_BYCOMMAND);\n\t\tsubMenu.Detach();\n\t\tmenu.Detach();\n#endif\n\t}\n\t// Task Tray Menu\n\telse if(wParam == MY_EXIT)\n\t{\n\t\tSavePos();\n\t\tRemoveTrayMainIcon();\n\t\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t\t{\n\t\t\tRemoveTemperatureIcon(i);\n\t\t}\n\t\tKillGraphDlg();\n\t\tCMainDialogFx::OnCancel();\n\t}\n\telse if(wParam == MY_SHOW_MAIN_DIALOG && m_bResidentMinimize)\n\t{\n\t\tif(! IsIconic())\n\t\t{\n\t\t\tShowWindowEx(SW_MINIMIZE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tShowWindowEx(SW_RESTORE);\n\t\t}\n\t}\n\telse if(wParam == MY_SHOW_MAIN_DIALOG)\n\t{\n\t\tif(IsWindowVisible())\n\t\t{\n\t\t\tShowWindowEx(SW_HIDE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tShowWindowEx(SW_RESTORE);\n\t\t}\n\t}\n\telse if(wParam == MY_SHOW_TEMPERATURE_ICON_ONLY)\n\t{\n\t\tShowTemperatureIconOnly();\n\t}\n\telse if(wParam == (WPARAM)SHOW_GRAPH_BASE + CAtaSmart::MAX_DISK)\n\t{\n\t\tShowGraphDlg(-1); // Using \"GraphHideDisk\" option\n\t}\n\telse if(SHOW_GRAPH_BASE <= wParam && wParam < (WPARAM)SHOW_GRAPH_BASE + CAtaSmart::MAX_DISK)\n\t{\n\t\tShowGraphDlg((int)wParam - SHOW_GRAPH_BASE);\n\t}\n\telse if(ALARM_SETTING_HEALTH_STATUS_BASE <= wParam && wParam <= (WPARAM)ALARM_SETTING_HEALTH_STATUS_BASE + CAtaSmart::MAX_DISK + 1)\n\t{\n\t\tint i = (int)(wParam - ALARM_SETTING_HEALTH_STATUS_BASE);\n\n\t\tif(i == CAtaSmart::MAX_DISK + 1) // Disable All\n\t\t{\n\t\t\tfor(int j = 0; j < m_Ata.vars.GetCount(); j++)\n\t\t\t{\n\t\t\t\tm_Ata.vars[j].AlarmHealthStatus = FALSE;\n\t\t\t\tWritePrivateProfileStringFx(_T(\"AlarmHealthStatus\"), m_Ata.vars[j].ModelSerial, _T(\"0\"), m_Ini);\n\t\t\t}\n\t\t}\n\t\telse if(i == CAtaSmart::MAX_DISK) // Enable All\n\t\t{\n\t\t\tfor(int j = 0; j < m_Ata.vars.GetCount(); j++)\n\t\t\t{\n\t\t\t\tm_Ata.vars[j].AlarmHealthStatus = TRUE;\n\t\t\t\tWritePrivateProfileStringFx(_T(\"AlarmHealthStatus\"), m_Ata.vars[j].ModelSerial, _T(\"1\"), m_Ini);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCString alarm;\n\t\t\tif(m_Ata.vars[i].AlarmHealthStatus)\n\t\t\t{\n\t\t\t\tm_Ata.vars[i].AlarmHealthStatus = FALSE;\n\t\t\t\talarm.Format(_T(\"%d\"), FALSE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_Ata.vars[i].AlarmHealthStatus = TRUE;\n\t\t\t\talarm.Format(_T(\"%d\"), TRUE);\n\t\t\t}\n\t\t\tWritePrivateProfileStringFx(_T(\"AlarmHealthStatus\"), m_Ata.vars[i].ModelSerial, alarm, m_Ini);\n\t\t}\n\t}\n\telse if(ALARM_SETTING_TEMPERATURE_BASE <= wParam && wParam <= (WPARAM)ALARM_SETTING_TEMPERATURE_BASE + ((WPARAM)CAtaSmart::MAX_DISK + 1) * 100)\n\t{\n\t\tint i = (int)(wParam - ALARM_SETTING_TEMPERATURE_BASE) / 100;\n\t\tint j = (int)(wParam - ALARM_SETTING_TEMPERATURE_BASE) % 100;\n\n\t\tif(i == CAtaSmart::MAX_DISK)\n\t\t{\n\t\t\tfor(int k = 0; k < m_Ata.vars.GetCount(); k++)\n\t\t\t{\n\t\t\t\tm_Ata.vars[k].AlarmTemperature = j;\n\t\t\t\tCString temperature;\n\t\t\t\ttemperature.Format(_T(\"%d\"), j);\n\t\t\t\tWritePrivateProfileStringFx(_T(\"AlarmTemperature\"), m_Ata.vars[k].Model + m_Ata.vars[k].SerialNumber, temperature, m_Ini);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_Ata.vars[i].AlarmTemperature = j;\n\t\t\tCString temperature;\n\t\t\ttemperature.Format(_T(\"%d\"), j);\n\t\t\tWritePrivateProfileStringFx(_T(\"AlarmTemperature\"), m_Ata.vars[i].ModelSerial, temperature, m_Ini);\n\t\t}\n\t}\n\telse if(TRAY_TEMPERATURE_ICON_BASE <= wParam && wParam <= (WPARAM)TRAY_TEMPERATURE_ICON_BASE + CAtaSmart::MAX_DISK + 1)\n\t{\n\t\tint i = (int)(wParam - TRAY_TEMPERATURE_ICON_BASE);\n\n\t\tif(i == CAtaSmart::MAX_DISK + 1) // Hide All\n\t\t{\n\t\t\tfor(int j = 0; j < m_Ata.vars.GetCount(); j++)\n\t\t\t{\n\t\t\t\tif(m_bTrayTemperatureIcon[j])\n\t\t\t\t{\n\t\t\t\t\tif(RemoveTemperatureIcon(j))\n\t\t\t\t\t{\n\t\t\t\t\t\tCString cstr;\n\t\t\t\t\t\tcstr.Format(_T(\"%d\"), 0);\n\t\t\t\t\t\tWritePrivateProfileStringFx(_T(\"TemperatureIcon\"), m_Ata.vars[j].ModelSerial, cstr, m_Ini);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m_bShowTemperatureIconOnly && ! IsTemperatureIconExist())\n\t\t\t{\n\t\t\t\tAddTrayMainIcon();\n\t\t\t}\n\t\t}\n\t\telse if(i == CAtaSmart::MAX_DISK) // Show All\n\t\t{\n\t\t\tint max = gRegIconId;\n\t\t\tfor(int j = (int)m_Ata.vars.GetCount() -1; j >= 0; j--)\n\t\t\t{\n\t\t\t\tif(! m_bTrayTemperatureIcon[j])\n\t\t\t\t{\n\t\t\t\t\tif(AddTemperatureIcon(j))\n\t\t\t\t\t{\n\t\t\t\t\t\tCString cstr;\n\t\t\t\t\t\tcstr.Format(_T(\"%d\"), 1);\n\t\t\t\t\t\tWritePrivateProfileStringFx(_T(\"TemperatureIcon\"), m_Ata.vars[j].ModelSerial, cstr, m_Ini);\n\t\t\t\t\t\tmax = TRAY_TEMPERATURE_ICON_BASE + j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m_bShowTemperatureIconOnly && IsTemperatureIconExist())\n\t\t\t{\n\t\t\t\tif(RemoveTrayMainIcon())\n\t\t\t\t{\n\t\t\t\t\tm_MainIconId = max;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAddTrayMainIcon();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(m_bTrayTemperatureIcon[i])\n\t\t\t{\n\t\t\t\tif(RemoveTemperatureIcon(i))\n\t\t\t\t{\n\t\t\t\t\tCString cstr;\n\t\t\t\t\tcstr.Format(_T(\"%d\"), 0);\n\t\t\t\t\tWritePrivateProfileStringFx(_T(\"TemperatureIcon\"), m_Ata.vars[i].ModelSerial, cstr, m_Ini);\n\t\t\t\t\t\n\t\t\t\t\tif(! IsTemperatureIconExist())\n\t\t\t\t\t{\n\t\t\t\t\t\tAddTrayMainIcon();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(AddTemperatureIcon(i))\n\t\t\t{\n\t\t\t\tCString cstr;\n\t\t\t\tcstr.Format(_T(\"%d\"), 1);\n\t\t\t\tWritePrivateProfileStringFx(_T(\"TemperatureIcon\"), m_Ata.vars[i].ModelSerial, cstr, m_Ini);\n\n\t\t\t\tif(m_bShowTemperatureIconOnly && IsTemperatureIconExist())\n\t\t\t\t{\n\t\t\t\t\tif(RemoveTrayMainIcon())\n\t\t\t\t\t{\n\t\t\t\t\t\tm_MainIconId = TRAY_TEMPERATURE_ICON_BASE + i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if(SELECT_DISK_BASE <= wParam && wParam < (WPARAM)SELECT_DISK_BASE + CAtaSmart::MAX_DISK)\n\t{\n\t\tint i = (int)(wParam - SELECT_DISK_BASE);\n\t\tm_DriveMenuPage = i / m_DriveMenuNumber;\n\t\tSelectDrive(i);\n\t}\n\telse if(AUTO_REFRESH_TARGET_BASE <= wParam && wParam <= (WPARAM)AUTO_REFRESH_TARGET_BASE + CAtaSmart::MAX_DISK + 1)\n\t{\n\t\tint i = (int)(wParam - AUTO_REFRESH_TARGET_BASE);\n\t\t// Target All Disk : AUTO_REFRESH_TARGET_BASE + CAtaSmart::MAX_DISK\n\t\t// Unarget All Disk : AUTO_REFRESH_TARGET_BASE + CAtaSmart::MAX_DISK\n\t\tCMenu *menu = GetMenu();\n\t\tif(i == CAtaSmart::MAX_DISK) // Target All Disk\n\t\t{\n\t\t\tfor(int j = 0; j < m_Ata.vars.GetCount(); j++)\n\t\t\t{\n\t\t\t\tm_bAutoRefreshTarget[j] = TRUE;\n\t\t\t\tmenu->CheckMenuItem(AUTO_REFRESH_TARGET_BASE + j, MF_CHECKED);\n\t\t\t\tWritePrivateProfileStringFx(_T(\"AutoRefreshTarget\"), m_Ata.vars[j].ModelSerial, _T(\"1\"), m_Ini);\n\t\t\t}\n\t\t}\n\t\telse if(i == CAtaSmart::MAX_DISK + 1) // Unarget All Disk\n\t\t{\n\t\t\tfor(int j = 0; j < m_Ata.vars.GetCount(); j++)\n\t\t\t{\n\t\t\t\tm_bAutoRefreshTarget[j] = FALSE;\n\t\t\t\tmenu->CheckMenuItem(AUTO_REFRESH_TARGET_BASE + j, MF_UNCHECKED);\n\t\t\t\tWritePrivateProfileStringFx(_T(\"AutoRefreshTarget\"), m_Ata.vars[j].ModelSerial, _T(\"0\"), m_Ini);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(m_bAutoRefreshTarget[i])\n\t\t\t{\n\t\t\t\tm_bAutoRefreshTarget[i] = FALSE;\n\t\t\t\tmenu->CheckMenuItem(AUTO_REFRESH_TARGET_BASE + i, MF_UNCHECKED);\n\t\t\t\tWritePrivateProfileStringFx(_T(\"AutoRefreshTarget\"), m_Ata.vars[i].ModelSerial, _T(\"0\"), m_Ini);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_bAutoRefreshTarget[i] = TRUE;\n\t\t\t\tmenu->CheckMenuItem(AUTO_REFRESH_TARGET_BASE + i, MF_CHECKED);\n\t\t\t\tWritePrivateProfileStringFx(_T(\"AutoRefreshTarget\"), m_Ata.vars[i].ModelSerial, _T(\"1\"), m_Ini);\n\t\t\t}\n\t\t}\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\telse if(WM_THEME_ID <= wParam && wParam < (WPARAM)WM_THEME_ID + m_MenuArrayTheme.GetSize())\n\t{\n#ifndef SUISHO_SHIZUKU_SUPPORT\n\t\tCMenu *menu = GetMenu();\n\t\tif (menu->GetMenuState(ID_GREEN_MODE, MF_BYCOMMAND) & MFS_CHECKED)\n\t\t{\n\t\t\tm_bGreenMode = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_bGreenMode = FALSE;\n\t\t}\n#endif\n\t\tCMainDialogFx::OnCommand(wParam, lParam);\n\n#ifndef SUISHO_SHIZUKU_SUPPORT\n\t\tif(m_CurrentTheme.Compare(_T(\"Simplicity\")) == 0)\n\t\t{\n\t\t\tm_bGreenMode = TRUE;\n\t\t}\n#endif\n\t\tUpdateListCtrl(m_SelectDisk);\n\t\treturn TRUE;\n\t}\n\n\treturn CMainDialogFx::OnCommand(wParam, lParam);\n}\n\nvoid CDiskInfoDlg::UpdateDialogSize()\n{\n\tCDialogFx::UpdateDialogSize();\n\n\tif (GetPrivateProfileInt(_T(\"Setting\"), _T(\"HideSmartInfo\"), 0, m_Ini))\n\t{\n\t\tm_SizeX = SIZE_X;\n\t\tm_SizeY = SIZE_MIN_Y;\n\t\tm_bHideSmartInfo = TRUE;\n\t\tSetClientSize(m_SizeX, m_SizeY, m_ZoomRatio);\n\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_HIDE_SMART_INFO, MF_CHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\telse\n\t{\n\t\tm_SizeX = SIZE_SMART_X;\n\t\tint y = GetPrivateProfileInt(_T(\"Setting\"), _T(\"Height\"), SIZE_SMART_Y, m_Ini);\n\t\tif (y > 0)\n\t\t{\n\t\t\tm_SizeY = y;\n\t\t}\n\n\t\tif (m_SizeY < SIZE_MIN_Y)\n\t\t{\n\t\t\tm_SizeY = SIZE_MIN_Y;\n\t\t}\n\t\telse if (m_SizeY > SIZE_MAX_Y)\n\t\t{\n\t\t\tm_SizeY = SIZE_MAX_Y;\n\t\t}\n\n\t\tSetClientSize(m_SizeX, m_SizeY, m_ZoomRatio);\n\t\tm_bHideSmartInfo = FALSE;\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_HIDE_SMART_INFO, MF_UNCHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\n\tUpdateBackground(TRUE, FALSE);\n\tSetControlFont();\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tint positionX = 0;\n\tif (m_CharacterPosition == 0)\n\t{\n\t\tm_OffsetX = OFFSET_X;\n\t\tpositionX = 0;\n\t}\n\telse\n\t{\n\t\tm_OffsetX = 0;\n\t\tpositionX = SIZE_X - OFFSET_X;\n\t}\n\tm_CtrlVoice.InitControl(positionX, 48, OFFSET_X, m_SizeY - 24 - 48, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlVoiceHide.InitControl(positionX, 0, OFFSET_X, 48, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlVoice.SetHandCursor();\n\n\tif (m_CurrentLang.Find(L\"Japanese\") == 0)\n\t{\n\t\t/* \n\t\tSYSTEMTIME systime;\n\t\tGetLocalTime(&systime);\n\t\tif ((systime.wYear == 2015 && systime.wMonth == 12 && systime.wDay <= 17)\n\t\t\t|| (systime.wYear == 2015 && systime.wMonth == 12 && systime.wDay == 18 && systime.wHour < 20))\n\t\t{\n\t\t\tm_CtrlCopyright.InitControl(0, m_SizeY - 24, OFFSET_X, 24, m_ZoomRatio, IP(L\"ShizukuAkibaMoe\"), 1, SS_CENTER, CButtonCx::OwnerDrawImage);\n\t\t}\n\t\telse \n\t\t{\t\t}\n\t\t*/\n\t\tm_CtrlCopyright.InitControl((int)(positionX * m_ZoomRatio), (int)(m_SizeY * m_ZoomRatio) - (int)(24 * m_ZoomRatio), (int)(OFFSET_X * m_ZoomRatio), (int)(24 * m_ZoomRatio), 1.0, &m_BkDC, IP(PROJECT_COPYRIGHT), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\t}\n\telse\n\t{\n\t\tm_CtrlCopyright.InitControl((int)(positionX * m_ZoomRatio), (int)(m_SizeY * m_ZoomRatio) - (int)(24 * m_ZoomRatio), (int)(OFFSET_X * m_ZoomRatio), (int)(24 * m_ZoomRatio), 1.0, &m_BkDC, IP(PROJECT_COPYRIGHT), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\t//\tm_CtrlCopyright.InitControl(positionX, m_SizeY - 24, OFFSET_X, 24, m_ZoomRatio, &m_BkDC, IP(PROJECT_COPYRIGHT), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE);\n\t}\n\t\n\tm_CtrlCopyright.SetHandCursor();\n#else\n\tm_CtrlVoice.ShowWindow(SW_HIDE);\n\tm_CtrlVoiceHide.ShowWindow(SW_HIDE);\n\tm_CtrlCopyright.ShowWindow(SW_HIDE);\n#endif\n\n\tint buttonDiskHeight = 48;\n\n\tif(m_bHighContrast){ buttonDiskHeight = 56;}\n\tfor(int i = 0; i < MAX_DRIVE_MENU; i++)\n\t{\n\t\tm_ButtonDisk[i].InitControl(DRIVE_MENU_SIZE / 2 * i + m_OffsetX, 0, DRIVE_MENU_SIZE / 2, buttonDiskHeight, m_ZoomRatio, &m_BkDC, IP(L\"noDisk\"), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\t\tm_ButtonDisk[i].SetMargin(0, 0, 3, 0, m_ZoomRatio);\n\t\tm_ButtonDisk[i].SetHandCursor(TRUE);\n\t}\n\n\tif (m_bHalfDriveMenu)\n\t{\n\t\tfor (int i = 0; i < m_DriveMenuNumber; i++)\n\t\t{\n\t\t\tm_ButtonDisk[i].InitControl(DRIVE_MENU_SIZE / 2 * i + m_OffsetX, 0, DRIVE_MENU_SIZE / 2, buttonDiskHeight, m_ZoomRatio, &m_BkDC, IP(L\"noDiskMini\"), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\t\t\tm_ButtonDisk[i].SetMargin(3, 0, 3, 0, m_ZoomRatio);\n\t\t\tm_ButtonDisk[i].SetHandCursor(TRUE);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < m_DriveMenuNumber; i++)\n\t\t{\n\t\t\tm_ButtonDisk[i].InitControl(DRIVE_MENU_SIZE * i + m_OffsetX, 0, DRIVE_MENU_SIZE, buttonDiskHeight, m_ZoomRatio, &m_BkDC, IP(L\"noDisk\"), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\t\t\tm_ButtonDisk[i].SetMargin(3, 0, 3, 0, m_ZoomRatio);\n\t\t\tm_ButtonDisk[i].SetHandCursor(TRUE);\n\t\t}\n\t}\n\n\tInitDriveList();\n\n\tm_CtrlButtonPreDisk.SetHandCursor(TRUE);\n\tm_CtrlButtonNextDisk.SetHandCursor(TRUE);\n\n\tif (m_bHighContrast)\n\t{\n\t\tm_CtrlModel.InitControl(40 + m_OffsetX, 56, 592, 32, m_ZoomRatio, &m_BkDC, NULL, 0, ES_CENTER, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\t\tm_CtrlButtonPreDisk.InitControl (  8 + m_OffsetX, 60, 24, 24, m_ZoomRatio, &m_BkDC, IP(L\"preDisk\"), 2, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\t\tm_CtrlButtonNextDisk.InitControl(640 + m_OffsetX, 60, 24, 24, m_ZoomRatio, &m_BkDC, IP(L\"nextDisk\"), 2, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\n\t\tm_CtrlButtonPreDisk.SetWindowTextW(L\"\");\n\t\tm_CtrlButtonNextDisk.SetWindowTextW(L\"\");\n\t}\n\telse\n\t{\n\t\tm_CtrlModel.InitControl(32 + m_OffsetX, 52, 608, 32, m_ZoomRatio, &m_BkDC, NULL, 0, ES_CENTER, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\t\tm_CtrlButtonPreDisk.InitControl(8 + m_OffsetX, 56, 24, 24, m_ZoomRatio, &m_BkDC, IP(L\"preDisk\"), 2, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\t\tm_CtrlButtonNextDisk.InitControl(640 + m_OffsetX, 56, 24, 24, m_ZoomRatio, &m_BkDC, IP(L\"nextDisk\"), 2, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\n\t\tm_CtrlButtonPreDisk.SetWindowTextW(L\"\");\n\t\tm_CtrlButtonNextDisk.SetWindowTextW(L\"\");\n\t}\n\tm_CtrlModel.Adjust();\n\n\tCString className;\n\tif (m_Ata.vars.GetCount())\n\t{\n\t\tclassName = GetDiskStatusClass(m_Ata.vars[m_SelectDisk].DiskStatus);\n\t}\n\telse\n\t{\n\t\tclassName = L\"diskStatusUnknown\";\n\t}\n\n\tint labelWidth = 128;\n\tif (m_bHighContrast) { labelWidth = 124; }\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tm_CtrlLabelDiskStatus.InitControl(128 + m_OffsetX, 260, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\tm_CtrlLabelTemperature.InitControl(436 + m_OffsetX, 260, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\n\tm_CtrlLabelDiskStatus.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelTemperature.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\n\tm_CtrlDiskStatus.InitControl       (256 + m_OffsetX, 256, 180, 28, m_ZoomRatio, &m_BkDC, IP(className), 1, BS_CENTER, OwnerDrawImage, m_bHighContrast, FALSE, FALSE);\n//\tm_CtrlDiskStatus.SetAlpha(IMAGE_ALPHA);\n\n\tclassName.Replace(L\"Green\", L\"\");\n\tif (m_Ata.vars.GetCount() && className.Find(L\"Good\") != -1 && m_Ata.vars[m_SelectDisk].Life == 100)\n\t{\n\t\tclassName += L\"100\";\n\t}\n\tm_CtrlLife.InitControl             (m_OffsetX, 88, 128, 192, m_ZoomRatio, &m_BkDC, IP(L\"SD\" + className), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\tm_CtrlLife.SetHandCursor(TRUE);\n#else\n\tm_CtrlLife.ShowWindow(SW_HIDE);\n\tm_CtrlLabelDiskStatus.InitControl  (8 + m_OffsetX,  88, 100, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\tm_CtrlLabelTemperature.InitControl (8 + m_OffsetX, 184, 100, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, FALSE, FALSE, FALSE);\n\n\tm_CtrlLabelDiskStatus.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelTemperature.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\n\tm_CtrlDiskStatus.InitControl       (8 + m_OffsetX, 112, 100, 60, m_ZoomRatio, &m_BkDC, IP(className), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n\tm_CtrlDiskStatus.SetMargin(4, 0, 4, 0, m_ZoomRatio);\n#endif\n\tm_CtrlDiskStatus.SetHandCursor(TRUE);\n\n\tif (m_Ata.vars.GetCount() && (m_Ata.vars[m_SelectDisk].IsSmartCorrect || m_Ata.vars[m_SelectDisk].DiskVendorId == m_Ata.SSD_VENDOR_NVME))\n\t{\n\t\tclassName = GetTemperatureClass(m_Ata.vars[m_SelectDisk].Temperature, m_Ata.vars[m_SelectDisk].AlarmTemperature);\n\t}\n\telse\n\t{\n\t\tclassName = _T(\"temperatureUnknown\");\n\t}\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tm_CtrlTemperature.InitControl      (564 + m_OffsetX, 256, 100, 28, m_ZoomRatio, &m_BkDC, IP(className), 1, BS_CENTER, OwnerDrawImage, m_bHighContrast, FALSE, FALSE);\n#else\n\tm_CtrlTemperature.InitControl      (8 + m_OffsetX, 208, 100, 40, m_ZoomRatio, &m_BkDC, IP(className), 1, BS_CENTER, OwnerDrawImage, m_bHighContrast, FALSE, FALSE);\n#endif\n\n\tm_CtrlDiskStatus.SetHandCursor(TRUE);\n\tm_CtrlTemperature.SetHandCursor(TRUE);\n\n\tm_CtrlLabelFirmware.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelSerialNumber.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelInterface.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelTransferMode.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelDriveMap.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelAtaAtapi.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelFeature.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\n\tm_CtrlLabelFirmware.InitControl(128 + m_OffsetX, 88, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\tm_CtrlLabelSerialNumber.InitControl(128 + m_OffsetX, 112, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\tm_CtrlLabelInterface.InitControl(128 + m_OffsetX, 136, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\tm_CtrlLabelTransferMode.InitControl(128 + m_OffsetX, 160, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\tm_CtrlLabelDriveMap.InitControl(128 + m_OffsetX, 184, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\tm_CtrlLabelAtaAtapi.InitControl(128 + m_OffsetX, 208, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\tm_CtrlLabelFeature.InitControl(128 + m_OffsetX, 232, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\n\tm_CtrlFirmware.SetGlassColor(m_Glass, m_GlassAlpha);\n\tm_CtrlSerialNumber.SetGlassColor(m_Glass, m_GlassAlpha);\n\tm_CtrlInterface.SetGlassColor(m_Glass, m_GlassAlpha);\n\tm_CtrlTransferMode.SetGlassColor(m_Glass, m_GlassAlpha);\n\tm_CtrlDriveMap.SetGlassColor(m_Glass, m_GlassAlpha);\n\tm_CtrlAtaAtapi.SetGlassColor(m_Glass, m_GlassAlpha);\n\tm_CtrlFeature.SetGlassColor(m_Glass, m_GlassAlpha);\n\n\tm_CtrlFirmware.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\tm_CtrlSerialNumber.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\tm_CtrlInterface.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\tm_CtrlTransferMode.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\tm_CtrlDriveMap.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\tm_CtrlAtaAtapi.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\tm_CtrlFeature.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\n\tm_CtrlFirmware.InitControl    (256 + m_OffsetX,  88, 180, 20, m_ZoomRatio, &m_BkDC, NULL, 0, ES_LEFT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\tm_CtrlSerialNumber.InitControl(256 + m_OffsetX, 112, 180, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\tm_CtrlInterface.InitControl   (256 + m_OffsetX, 136, 180, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\tm_CtrlTransferMode.InitControl(256 + m_OffsetX, 160, 180, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\tm_CtrlDriveMap.InitControl    (256 + m_OffsetX, 184, 180, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\tm_CtrlAtaAtapi.InitControl    (256 + m_OffsetX, 208, 408, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\tm_CtrlFeature.InitControl     (256 + m_OffsetX, 232, 408, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\n\tm_CtrlLabelBufferSize.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelNvCacheSize.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelRotationRate.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelPowerOnCount.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlLabelPowerOnHours.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\n\tm_CtrlLabelBufferSize.InitControl(436 + m_OffsetX, 88, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\tm_CtrlLabelNvCacheSize.InitControl(436 + m_OffsetX, 112, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\tm_CtrlLabelRotationRate.InitControl(436 + m_OffsetX, 136, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\tm_CtrlLabelPowerOnCount.InitControl(436 + m_OffsetX, 160, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\tm_CtrlLabelPowerOnHours.InitControl(436 + m_OffsetX, 184, labelWidth, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, FALSE, FALSE);\n\n\tm_CtrlBufferSize.SetGlassColor(m_Glass, m_GlassAlpha);\n\tm_CtrlNvCacheSize.SetGlassColor(m_Glass, m_GlassAlpha);\n\tm_CtrlRotationRate.SetGlassColor(m_Glass, m_GlassAlpha);\n\tm_CtrlPowerOnCount.SetGlassColor(m_Glass, m_GlassAlpha);\n\tm_CtrlPowerOnHours.SetGlassColor(m_Glass, m_GlassAlpha);\n\n\tm_CtrlBufferSize.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlNvCacheSize.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlRotationRate.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlPowerOnCount.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\tm_CtrlPowerOnHours.SetMargin(0, 0, 0, 4, m_ZoomRatio);\n\n\tm_CtrlBufferSize.InitControl  (564 + m_OffsetX,  88, 100, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\tm_CtrlNvCacheSize.InitControl (564 + m_OffsetX, 112, 100, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\tm_CtrlRotationRate.InitControl(564 + m_OffsetX, 136, 100, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\tm_CtrlPowerOnCount.InitControl(564 + m_OffsetX, 160, 100, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\tm_CtrlPowerOnHours.InitControl(564 + m_OffsetX, 184, 100, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawGlass, m_bHighContrast, FALSE, TRUE);\n\n\tm_CtrlFirmware.SetDrawFrame(TRUE);\n\tm_CtrlSerialNumber.SetDrawFrame(TRUE);\n\tm_CtrlInterface.SetDrawFrame(TRUE);\n\tm_CtrlTransferMode.SetDrawFrame(TRUE);\n\tm_CtrlDriveMap.SetDrawFrame(TRUE);\n\tm_CtrlAtaAtapi.SetDrawFrame(TRUE);\n\tm_CtrlFeature.SetDrawFrame(TRUE);\n\n\tm_CtrlBufferSize.SetDrawFrame(TRUE);\n\tm_CtrlNvCacheSize.SetDrawFrame(TRUE);\n\tm_CtrlRotationRate.SetDrawFrame(TRUE);\n\tm_CtrlPowerOnCount.SetDrawFrame(TRUE);\n\tm_CtrlPowerOnHours.SetDrawFrame(TRUE);\n\n\tm_CtrlFirmware.Adjust();\n\tm_CtrlSerialNumber.Adjust();\n\tm_CtrlInterface.Adjust();\n\tm_CtrlTransferMode.Adjust();\n\tm_CtrlDriveMap.Adjust();\n\tm_CtrlAtaAtapi.Adjust();\n\tm_CtrlFeature.Adjust();\n\n\tm_CtrlBufferSize.Adjust();\n\tm_CtrlNvCacheSize.Adjust();\n\tm_CtrlRotationRate.Adjust();\n\tm_CtrlPowerOnCount.Adjust();\n\tm_CtrlPowerOnHours.Adjust();\n\n\tCRect rect;\n\tGetClientRect(&rect);\n\n\tm_List.SetTextColor1(m_ListText1);\n\tm_List.SetTextColor2(m_ListText2);\n\tm_List.SetTextSelected(m_ListTextSelected);\n\tm_List.SetBkColor1(m_ListBk1);\n\tm_List.SetBkColor2(m_ListBk2);\n\tm_List.SetBkSelected(m_ListBkSelected);\n\tm_List.SetLineColor1(m_ListLine1);\n\tm_List.SetLineColor2(m_ListLine2);\n\tm_List.SetGlassColor(m_Glass, m_GlassAlpha);\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tm_List.InitControl(8 + m_OffsetX, SIZE_Y, 672 - 16, (int)(rect.Height() / m_ZoomRatio - SIZE_Y - 8), 672 - 16, 1000 - SIZE_Y - 8, m_ZoomRatio, &m_BkDC, OwnerDrawGlass, m_bHighContrast, FALSE);\n#else\n\tm_List.InitControl(8 + m_OffsetX, SIZE_Y, 672 - 16, (int)(rect.Height() / m_ZoomRatio - SIZE_Y - 8), 672 - 16, 1000 - SIZE_Y - 8, m_ZoomRatio, &m_BkDC, SystemDraw, m_bHighContrast, FALSE);\n#endif\n\n\tRebuildListHeader(m_SelectDisk, TRUE);\n\tUpdateListCtrl(m_SelectDisk);\n\n\tInvalidate();\n}\n\n\nvoid CDiskInfoDlg::OnSize(UINT nType, int cx, int cy)\n{\n\tCMainDialogFx::OnSize(nType, cx, cy);\n\n\tstatic BOOL flag = FALSE;\n\n\tif(flag)\n\t{\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\t\tint positionX = 0;\n\t\tif (m_CharacterPosition == 0)\n\t\t{\n\t\t\tpositionX = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpositionX = SIZE_X - OFFSET_X;\n\t\t}\n\t\tm_List.MoveWindow((int)((8 + m_OffsetX) * m_ZoomRatio), (int)(SIZE_Y * m_ZoomRatio), (int)((672 - 16) * m_ZoomRatio), (int)(cy - ((int)(SIZE_Y + 8) * m_ZoomRatio)));\n\t\tm_CtrlVoice.MoveWindow((int)(positionX * m_ZoomRatio), (int)(48 * m_ZoomRatio), (int)(OFFSET_X * m_ZoomRatio), (int)(cy - (int)((24 + 48) * m_ZoomRatio)));\n\t\t// m_CtrlCopyright.MoveWindow(0, (int)(cy - (24 * m_ZoomRatio)), (int)(m_OffsetX * m_ZoomRatio), (int)(24 * m_ZoomRatio));\n\t\tm_CtrlCopyright.InitControl((int)(positionX * m_ZoomRatio), (int)(cy - (24 * m_ZoomRatio)), (int)(OFFSET_X * m_ZoomRatio), (int)(24 * m_ZoomRatio), 1.0, &m_BkDC, IP(PROJECT_COPYRIGHT), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n#else\n\t\tm_List.MoveWindow((int)((8.0 + m_OffsetX) * m_ZoomRatio), (int)(SIZE_Y * m_ZoomRatio), (int)((672.0 - 16.0) * m_ZoomRatio), (int)(cy - ((SIZE_Y + 8.0) * m_ZoomRatio)));\n#endif\n\t}\n\tflag = TRUE;\n\t\n\tif(m_bHideSmartInfo == FALSE && m_bInitializing == FALSE && m_bDpiChanging == FALSE && cy > 0)\n\t{\n\t\tCString cstr;\n\t\tm_SizeY = (int)(cy / m_ZoomRatio);\n\t\tcstr.Format(_T(\"%d\"), m_SizeY);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Height\"), cstr, m_Ini);\n\t}\n}\n\nvoid CDiskInfoDlg::SetClientSize(int sizeX, int sizeY, double zoomRatio)\n{\n\tRECT rw, rc;\n\tGetWindowRect(&rw);\n\tGetClientRect(&rc);\n\n\tif (rc.right != 0)\n\t{\n\t\tint ncaWidth = (rw.right - rw.left) - (rc.right - rc.left);\n\t\tint ncaHeight = (rw.bottom - rw.top) - (rc.bottom - rc.top);\n\n\t\tm_MinSizeX = (int)(sizeX * zoomRatio) + ncaWidth;\n\t\tm_MaxSizeX = m_MinSizeX;\n\t\tm_MinSizeY = (int)(SIZE_MIN_Y * m_ZoomRatio + ncaHeight);\n\t\tm_MaxSizeY = (int)(SIZE_MAX_Y * m_ZoomRatio + ncaHeight);\n\n\t\tSetWindowPos(NULL, 0, 0, (int)(sizeX * zoomRatio) + ncaWidth, (int)(sizeY * zoomRatio) + ncaHeight, SWP_NOMOVE | SWP_NOZORDER);\n\t}\n}\n\nvoid CDiskInfoDlg::SavePos() const\n{\n\tWINDOWPLACEMENT place = { sizeof(WINDOWPLACEMENT) };\n\t//place.length = sizeof(WINDOWPLACEMENT);\n\tGetWindowPlacement(&place);\n\n\tCString x, y;\n\tx.Format(_T(\"%d\"), place.rcNormalPosition.left);\n\ty.Format(_T(\"%d\"), place.rcNormalPosition.top);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"X\"), x, m_Ini);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Y\"), y, m_Ini);\n}\n\nvoid CDiskInfoDlg::OnGetMinMaxInfo(MINMAXINFO* lpMMI)\n{\n\tlpMMI->ptMinTrackSize.x = m_MinSizeX;\n\tlpMMI->ptMinTrackSize.y = m_MinSizeY;\n\n\tlpMMI->ptMaxTrackSize.x = m_MaxSizeX;\n\tlpMMI->ptMaxTrackSize.y = m_MaxSizeY;\n\n\tCMainDialogFx::OnGetMinMaxInfo(lpMMI);\n}\n\nvoid CDiskInfoDlg::AlarmHealthStatus(DWORD i, CString dir, CString disk)\n{\n\tTCHAR str[256];\n\tCString cstr, alarm, name, title, id;\n\tDWORD niifType = NIIF_INFO;\n\tint pre = -1;\n\t\n\tname.Format(_T(\"(%d) %s / %s / %s\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].SerialNumber.GetString(), m_Ata.vars[i].DriveMap.GetString());\n\ttitle.Format(_T(\"(%d) %s / %s / %s\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].SerialNumber.GetString(), m_Ata.vars[i].DriveMap.GetString());\n\n\tGetPrivateProfileStringFx(disk, _T(\"HealthStatus\"), _T(\"0\"), str, 256, dir + _T(\"\\\\\") + SMART_INI);\n\tpre = _tstoi(str);\n\n\tif(m_Ata.vars[i].DiskStatus == m_Ata.DISK_STATUS_UNKNOWN)\n\t{\n\n\t}\n\telse if(m_Ata.vars[i].DiskStatus > (DWORD)pre && m_Ata.vars[i].DiskStatus != m_Ata.DISK_STATUS_GOOD)\n\t{\n\t\tcstr.Format(_T(\"%s: [%s] -> [%s]\\r\\n\"), i18n(_T(\"Dialog\"), _T(\"HEALTH_STATUS\")).GetString(),\n\t\t\t\t\tGetDiskStatus(pre).GetString(), GetDiskStatus(m_Ata.vars[i].DiskStatus).GetString());\n\t\talarm += cstr;\n\t\tniifType = NIIF_WARNING;\n\t\tAddEventLog(601, 2, name + cstr);\n\t\tSendMail(601, title, cstr);\n\t\tAddAlarmHistory(601, title, cstr);\n\t\tAlertSound(601, AS_SET_SOUND_ID);\n\t}\n\telse if(m_Ata.vars[i].DiskStatus < (DWORD)pre)\n\t{\n\t\tcstr.Format(_T(\"%s: [%s] -> [%s]\\r\\n\"), i18n(_T(\"Dialog\"), _T(\"HEALTH_STATUS\")).GetString(),\n\t\t\t\t\tGetDiskStatus(pre).GetString(), GetDiskStatus(m_Ata.vars[i].DiskStatus).GetString());\n\t\talarm += cstr;\n\t\tniifType = NIIF_INFO;\n\t\tAddEventLog(701, 4, name + cstr);\n\t\tSendMail(701, title, cstr);\n\t\tAddAlarmHistory(701, title, cstr);\n\t\tAlertSound(701, AS_SET_SOUND_ID);\n\t}\n\n\n\tGetPrivateProfileStringFx(disk, _T(\"Life\"), _T(\"-1\"), str, 256, dir + _T(\"\\\\\") + SMART_INI);\n\tpre = _tstoi(str);\n\n\tif(m_Ata.vars[i].Life == -1 || pre == -1)\n\t{\n\n\t}\n\telse if(m_Ata.vars[i].Life < pre)\n\t{\n\t\tcstr.Format(_T(\"%s: [%d] -> [%d]\\r\\n\"), i18n(_T(\"SmartSsd\"), _T(\"FF\")).GetString(), pre, m_Ata.vars[i].Life);\n\t\talarm += cstr;\n\t\tniifType = NIIF_WARNING;\n\t\tAddEventLog(607, 2, name + cstr);\n\t\tSendMail(607, title, cstr);\n\t\tAddAlarmHistory(607, title, cstr);\n\t\tAlertSound(607, AS_SET_SOUND_ID);\n\t}\n\telse if(m_Ata.vars[i].Life > pre)\n\t{\n\t\tcstr.Format(_T(\"%s: [%d] -> [%d]\\r\\n\"), i18n(_T(\"SmartSsd\"), _T(\"FF\")).GetString(), pre, m_Ata.vars[i].Life);\n\t\talarm += cstr;\n\t\tniifType = NIIF_INFO;\n\t\tAddEventLog(707, 4, name + cstr);\n\t\tSendMail(707, title, cstr);\n\t\tAddAlarmHistory(707, title, cstr);\n\t\tAlertSound(707, AS_SET_SOUND_ID);\n\t}\n\n\tfor(DWORD j = 0; j < m_Ata.vars[i].AttributeCount; j++)\n\t{\n\t\tif(( m_Ata.vars[i].Attribute[j].Id == 0x05 // Reallocated Sectors Count\n\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xC4 && ! m_bWorkaroundIgnoreC4)// Reallocation Event Count\n\t\t||  m_Ata.vars[i].Attribute[j].Id == 0xC5 // Current Pending Sector Count\n\t\t||  m_Ata.vars[i].Attribute[j].Id == 0xC6 // Off-Line Scan Uncorrectable Sector Count\n\t\t) && ! m_Ata.vars[i].IsSsd)\n\t\t{\n\t\t\tCString target;\n\t\t\tDWORD eventId = 0;\n\t\t\tif(m_Ata.vars[i].Attribute[j].Id == 0x05)\n\t\t\t{\n\t\t\t\ttarget = _T(\"ReallocatedSectorsCount\");\n\t\t\t\teventId = 602;\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].Attribute[j].Id == 0xC4)\n\t\t\t{\n\t\t\t\ttarget = _T(\"ReallocationEventCount\");\n\t\t\t\teventId = 603;\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].Attribute[j].Id == 0xC5)\n\t\t\t{\n\t\t\t\ttarget = _T(\"CurrentPendingSectorCount\");\n\t\t\t\teventId = 604;\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].Attribute[j].Id == 0xC6)\n\t\t\t{\n\t\t\t\ttarget = _T(\"UncorrectableSectorCount\");\n\t\t\t\teventId = 605;\n\t\t\t}\n\n\t\t\tGetPrivateProfileStringFx(disk, target, _T(\"-1\"), str, 256, dir + _T(\"\\\\\") + SMART_INI);\n\t\t\tpre = _tstoi(str);\n\t\t\tid.Format(_T(\"%02X\"), m_Ata.vars[i].Attribute[j].Id);\n\t\t\tint rawValue = MAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[0], m_Ata.vars[i].Attribute[j].RawValue[1]);\n\t\t\tif(rawValue > pre && pre != -1)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%s: (%02X) %s [%d->%d]\\r\\n\"), i18n(_T(\"Alarm\"), _T(\"DEGRADATION\")).GetString(),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].Id, i18n(_T(\"Smart\"), id).GetString(), pre, rawValue);\n\t\t\t\talarm += cstr;\n\t\t\t\tniifType = NIIF_WARNING;\n\t\t\t\tAddEventLog(eventId, 2, name + cstr);\n\t\t\t\tSendMail(eventId, title, cstr);\n\t\t\t\tAddAlarmHistory(eventId, title, cstr);\n\t\t\t\tAlertSound(eventId, AS_SET_SOUND_ID);\n\t\t\t}\n\t\t\telse if(rawValue < pre && pre != -1)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%s: (%02X) %s [%d->%d]\\r\\n\"), i18n(_T(\"Alarm\"), _T(\"RECOVERY\")).GetString(),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].Id, i18n(_T(\"Smart\"), id).GetString(), pre, rawValue);\n\t\t\t\talarm += cstr;\n\t\t\t\tniifType = NIIF_INFO;\n\t\t\t\tAddEventLog(eventId + 100, 4, name + cstr);\n\t\t\t\tSendMail(eventId + 100, title, cstr);\n\t\t\t\tAddAlarmHistory(eventId + 100, title, cstr);\n\t\t\t\tAlertSound(eventId + 100, AS_SET_SOUND_ID);\n\t\t\t}\n\t\t}\n\n\t\tstatic CTime preTime[CAtaSmart::MAX_DISK] = {0};\n\t\tif(m_Ata.vars[i].AlarmTemperature > 0 && m_Ata.vars[i].Temperature >= m_Ata.vars[i].AlarmTemperature)\n\t\t{\n\t\t\tif(CTime::GetTickCount() - preTime[i] > ALARM_TEMPERATURE_PERIOD)\n\t\t\t{\n\t\t\t\tif(m_bFahrenheit)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"%s: %d F\\r\\n\"), i18n(_T(\"Alarm\"), _T(\"ALARM_TEMPERATURE\")).GetString(), m_Ata.vars[i].Temperature * 9 / 5 + 32);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"%s: %d C\\r\\n\"), i18n(_T(\"Alarm\"), _T(\"ALARM_TEMPERATURE\")).GetString(), m_Ata.vars[i].Temperature);\n\t\t\t\t}\n\t\t\t\tAddEventLog(606, 2, name + cstr);\n\t\t\t\tSendMail(606, title, cstr);\n\t\t\t\tAddAlarmHistory(606, title, cstr);\n\t\t\t\tAlertSound(606, AS_SET_SOUND_ID);\n\n\t\t\t\tniifType = NIIF_WARNING;\n\t\t\t\tpreTime[i] = CTime::GetTickCount();\n\t\t\t}\n\t\t}\n\t}\n\n\tif(! alarm.IsEmpty())\n\t{\n\t\tcstr.Format(_T(\"(%d) %s\\n\"), i + 1, m_Ata.vars[i].Model.GetString());\n\t\tif(niifType == NIIF_WARNING)\n\t\t{\n\t\t\tShowBalloon(m_MainIconId, niifType, i18n(_T(\"Alarm\"), _T(\"ALARM_HEALTH_STATUS\")), cstr + alarm);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tShowBalloon(m_MainIconId, niifType, i18n(_T(\"Alarm\"), _T(\"INFO_HEALTH_STATUS\")), cstr + alarm);\n\t\t}\n\t}\n}\n\nBOOL CDiskInfoDlg::AddEventLog(DWORD eventId, WORD eventType, CString message)\n{\n\tif(! m_bEventLog)\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn WriteEventLog(eventId, eventType, _T(\"CrystalDiskInfo\"), message);\n}\n\nBOOL CDiskInfoDlg::SendMail(DWORD eventId, CString title, CString message)\n{\n\tif(! m_bAlertMail || m_AlertMailPath.IsEmpty())\n\t{\n\t\treturn FALSE;\n\t}\n\n\tTCHAR computer[MAX_COMPUTERNAME_LENGTH + 1];\n\tDWORD length = MAX_COMPUTERNAME_LENGTH + 1;\n\tGetComputerName(computer, &length);\n\n\tCString subject, body, option;\n\n\tsubject.Format(_T(\"[CDI] %s %s [%d]\"), computer, title.GetString(), eventId);\n\tbody.Format(_T(\"%s %s\\r\\n[%d] %s\"), computer, title.GetString(), eventId, message.GetString());\n\n\toption.Format(_T(\"Subject=\\\"%s\\\" Body=\\\"%s\\\"\"), subject.GetString(), body.GetString());\n\tif((INT_PTR)(ShellExecute(NULL, NULL, m_AlertMailPath, option, NULL, SW_SHOW)) > 32)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n}\n\nBOOL CDiskInfoDlg::AddAlarmHistory(DWORD eventId, CString disk, CString message)\n{\n\tCString cstr;\n\tcstr.Format(L\"[Alarm] EventID=%d, Disk=%s, Message=%s\", eventId, disk.GetString(), message.GetString());\n\tcstr.Replace(L\"\\n\", L\"\");\n\tDebugPrint(cstr);\n\treturn FALSE;\n// 2012/5/26 - \n/*\n\tCTime time = CTime::GetTickCount();\n\n\tCString line;\n\tline.Format(_T(\"%s,%d,%s,%s\"), time.Format(_T(\"%Y/%m/%d %H:%M:%S\")), eventId, disk, message);\n\tline.TrimRight();\n\tline += _T(\"\\n\");\n\n\tCStdioFile outFile;\n\tif(outFile.Open(m_SmartDir + ALARM_HISTORY_CSV,\n\t\tCFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::typeText))\n\t{\n\t\toutFile.SeekToEnd();\n\t\toutFile.WriteString(line);\n\t\toutFile.Close();\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n*/\n}\n\nint ExecAndWait(TCHAR *pszCmd, BOOL bNoWindow)\n{\n\tDWORD Code;\n\tBOOL bSuccess;\n\tSTARTUPINFO si;\n\tPROCESS_INFORMATION pi;\n\n\tmemset(&si, 0, sizeof(STARTUPINFO));\n\tsi.cb = sizeof(STARTUPINFO);\n\n\tif (bNoWindow) {\n\t\tsi.dwFlags = STARTF_USESHOWWINDOW;\n\t\tsi.wShowWindow = SW_HIDE;\n\t}\n\tbSuccess = CreateProcess(\n\t\tNULL,\t// lpApplicationName\n\t\tpszCmd,\t// lpCommandLine\n\t\tNULL,\t// lpProcessAttributes\n\t\tNULL,\t// lpThreadAttributes\n\t\tFALSE,\t// bInheritHandle\n\t\t0,\t\t// dwCreationFlag\n\t\tNULL,\t// lpEnvironment\n\t\tNULL,\t// lpCurrentDirectory\n\t\t&si,\t// lpStartupInfo\n\t\t&pi\t\t// lpProcessInformation\n\t);\n\tif (bSuccess != TRUE) return 0;\n\n\tWaitForInputIdle(pi.hProcess, INFINITE);\n\tWaitForSingleObject(pi.hProcess, INFINITE);\n\n\tGetExitCodeProcess(pi.hProcess, &Code);\n\n\tCloseHandle(pi.hThread);\n\tCloseHandle(pi.hProcess);\n\n\treturn Code;\n}\n\n\nBOOL CDiskInfoDlg::AlertSound(DWORD eventId, DWORD mode)\n{\n\tif(mode != AS_SET_SOUND_ID && eventId != 1000 && ! m_bAlertSound)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tstatic DWORD soundId = 0;\n\n\tif(mode == AS_SET_SOUND_ID)\n\t{\n\t\tif(eventId == 0 || soundId == 0 || soundId > eventId)\n\t\t{\n\t\t\tsoundId = eventId;\n\t\t}\n\t\treturn TRUE;\n\t}\n\tif(soundId == 0)\n\t{\n\t\treturn TRUE;\n\t}\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tif (600 <= soundId && soundId < 800)\n\t{\n\t\tm_bStartupVoiceDisabled = TRUE;\n\t}\n#endif\n\n\tif (600 <= soundId && soundId < 800 && IsFileExist(m_AlertSoundPath))\n\t{\n\t\tif (mode == AS_DEINIT)\n\t\t{\n\t\t\treturn AlertSound(_T(\"\"));\n\t\t}\n\n\t\t// mode == AS_PLAY_SOUND\n\t\t// Play\n\t\tif (AlertSound(m_AlertSoundPath) == FALSE)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// mode == AS_PLAY_SOUND\n\n\t\tHRSRC hrs;\n\t\t// Choose OPUS resource\n\t\tCString resource;\n\t\tHMODULE hModule = nullptr;\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\t#ifdef SUISHO_AOI_SUPPORT\n\t\t\tif (m_hVoice != nullptr)\n\t\t\t{\n\t\t\t\thModule = m_hVoice;\n\t\t\t\tresource.Format(_T(\"CDI_VOICE_%03d\"), soundId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresource = _T(\"CDI_SOUND_001\");\n\t\t\t}\t\t\n\t#else\n\t\t\t// For Japanese\n\t\t\tif (m_CurrentLang.Find(_T(\"Japanese\")) == 0 || GetUserDefaultLCID() == 0x0411)\n\t\t\t{\n\t\t\t\tif (m_hVoice != nullptr)\n\t\t\t\t{\n\t\t\t\t\thModule = m_hVoice;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t\tresource.Format(_T(\"CDI_VOICE_%03d\"), soundId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresource = _T(\"CDI_SOUND_001\");\n\t\t\t}\n\t#endif\n#else\n\t\tresource = _T(\"CDI_SOUND_001\");\n#endif\n\t\thrs = FindResource(hModule, resource, _T(\"OPUS\"));\n\t\t// Resource to TempFile\n\t\tif (hrs == nullptr)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst HGLOBAL hOpus = LoadResource(hModule, hrs);\n\t\tif (!hOpus)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\tconst LPBYTE lpOpus = static_cast<LPBYTE>(LockResource(hOpus));\n\t\tif (!lpOpus)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\tDWORD dwWrite = 0;\n\n\t\tconst HANDLE hFile = CreateFile(m_TempFilePathOpus, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, nullptr);\n\t\tif (hFile != INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\tif (WriteFile(hFile, lpOpus, SizeofResource(hModule, hrs), &dwWrite, nullptr) == 0)\n\t\t\t{\n\t\t\t\tCloseHandle(hFile);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tCloseHandle(hFile);\n\t\t}\n\n\t\t// Play\n\t\tif (AlertSound(m_TempFilePathOpus) == FALSE)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tsoundId = 0;\n\n\treturn TRUE;\n}\n\nBOOL CDiskInfoDlg::AlertSound(const CString& alertSoundPath) const\n{\n\tstatic MCI_OPEN_PARMS mop = { 0 };\n\tstatic MCI_PLAY_PARMS mpp = { 0 };\n\tstatic MCI_GENERIC_PARMS mgp = { 0 };\n\tMCIERROR error = 0;\n\n\tif (mop.wDeviceID != 0)\n\t{\n\t\t// Stop and close\n\t\terror = mciSendCommandW(mop.wDeviceID, MCI_STOP, MCI_WAIT, (DWORD_PTR)&mop);\n\t\terror = mciSendCommandW(mop.wDeviceID, MCI_CLOSE, MCI_WAIT, (DWORD_PTR)&mop);\n\t\tmop.wDeviceID = 0;\n\t\tZeroMemory(&mop, sizeof(MCI_OPEN_PARMS));\n\t\tif (error)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (alertSoundPath.Right(5).MakeUpper().Compare(_T(\".OPUS\")) == 0)\n\t{\n\t\t// Convert Opus to WAV\n\t\tCString option;\n\t\toption.Format(_T(\"\\\"%s\\\" \\\"%s\\\" \\\"%s\\\"\"), m_OpusDecPath.GetString(), alertSoundPath.GetString(), m_TempFilePathWave.GetString());\n\t\tExecAndWait(const_cast<TCHAR*>(option.GetString()), TRUE);\n\n\t\treturn AlertSound(m_TempFilePathWave);\n\t}\n\n\tif (alertSoundPath.Compare(_T(\"\")) == 0) {\n\t\t// mode == AS_DEINIT\n\t\t// Close\n\t\terror = mciSendCommandW(mop.wDeviceID, MCI_CLOSE, 0, reinterpret_cast<DWORD_PTR>(&mop));\n\t\tif (error)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\n\t// Open\n\tmop.lpstrDeviceType = _T(\"MPEGVideo\");\n\tmop.lpstrElementName = alertSoundPath;\n\terror = mciSendCommandW(NULL, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, reinterpret_cast<DWORD_PTR>(&mop));\n\tif (error)\n\t{\n\t\treturn FALSE;\n\t}\n\n\t// Set volume\n\tint volume = GetPrivateProfileInt(_T(\"Setting\"), _T(\"AlertSoundVolume\"), 80, m_Ini);\n\tif (volume < 0 || volume > 100) volume = 80;\n\n\tMCI_DGV_SETAUDIO_PARMS parms = { 0 };\n\tparms.dwItem = MCI_DGV_SETAUDIO_VOLUME;\n\tparms.dwValue = volume * 10; // 0-1000\n\terror = mciSendCommand(mop.wDeviceID, MCI_SETAUDIO, MCI_DGV_SETAUDIO_ITEM | MCI_DGV_SETAUDIO_VALUE, (DWORD_PTR)&parms);\n\n\t// Seek\n\terror = mciSendCommand(mop.wDeviceID, MCI_SEEK, MCI_SEEK_TO_START, reinterpret_cast<DWORD_PTR>(&mgp));\n\tif (error)\n\t{\n\t\treturn FALSE;\n\t}\n\n\t// Play\n\terror = mciSendCommandW(mop.wDeviceID, MCI_PLAY, 0, reinterpret_cast<DWORD_PTR>(&mpp));\n\tif (error)\n\t{\n\t\treturn FALSE;\n\t}\n\t\n\treturn TRUE;\n}\n\nvoid CDiskInfoDlg::AlarmOverheat()\n{\n\tCString cstr;\n\tCString overheat;\n\tCString diskStatus;\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tif(m_Ata.vars[i].AlarmTemperature > 0 && m_Ata.vars[i].Temperature >= m_Ata.vars[i].AlarmTemperature)\n\t\t{\n\t\t\tdiskStatus = GetDiskStatus(m_Ata.vars[i].DiskStatus);\n\t\t\t\n\t\t\tif(m_bFahrenheit)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"(%d) %s [%s] %d F\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(), diskStatus.GetString(), m_Ata.vars[i].Temperature * 9 / 5 + 32);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"(%d) %s [%s] %d C\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(), diskStatus.GetString(), m_Ata.vars[i].Temperature);\n\t\t\t}\n\t\t\t\n\t\t\toverheat += cstr;\n\t\t}\n\t}\n\toverheat.Trim();\n\tif(! overheat.IsEmpty())\n\t{\n\t\tShowBalloon(m_MainIconId, NIIF_WARNING, i18n(_T(\"Alarm\"), _T(\"ALARM_TEMPERATURE\")), overheat);\n\t}\n}\n\nvoid CDiskInfoDlg::OnTimer(UINT_PTR nIDEvent)\n{\n\tif(nIDEvent == TIMER_SET_POWER_ON_UNIT)\n\t{\n\t\tKillTimer(TIMER_SET_POWER_ON_UNIT);\n\n\t\tSetWindowTitle(_T(\"\"));\n\t\tm_NowDetectingUnitPowerOnHours = FALSE;\n\t\tif(m_Ata.MeasuredTimeUnit())\n\t\t{\n\t\t\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t\t\t{\n\t\t\t\tm_Ata.vars[i].MeasuredPowerOnHours = m_Ata.GetPowerOnHoursEx(i, m_Ata.vars[i].MeasuredTimeUnitType);\n\t\t\t\t\n\t\t\t\tCString cstr;\n\t\t\t\tcstr.Format(_T(\"%d\"), m_Ata.vars[i].MeasuredTimeUnitType);\n\t\t\t\tWritePrivateProfileStringFx(_T(\"PowerOnUnit\"), m_Ata.vars[i].ModelSerial, cstr, m_Ini);\n\t\t\t\tSaveSmartInfo(i);\n\t\t\t}\n\n\t\t\tAlertSound(0, AS_PLAY_SOUND);\n\n\t\t\tif(m_SelectDisk < (DWORD)m_Ata.vars.GetCount() && m_Ata.vars[m_SelectDisk].IsSmartCorrect && m_Ata.vars[m_SelectDisk].MeasuredPowerOnHours > 0)\n\t\t\t{\n\t\t\t\tCString IsMinutesT, title;\n\t\t\t\tif(m_Ata.vars[m_SelectDisk].MeasuredTimeUnitType == CAtaSmart::POWER_ON_MINUTES && m_Ata.vars[m_SelectDisk].IsMaxtorMinute)\n\t\t\t\t{\n\t\t\t\t\tIsMinutesT = _T(\" (?)\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIsMinutesT = _T(\"\");\n\t\t\t\t}\n\n\t\t\t\tconst int years = m_Ata.vars[m_SelectDisk].MeasuredPowerOnHours / (365 * 24);\n\t\t\t\tconst int days = (m_Ata.vars[m_SelectDisk].MeasuredPowerOnHours - 365 * 24 * years) / 24;\n\t\t\t\tconst int hours = m_Ata.vars[m_SelectDisk].MeasuredPowerOnHours % 24;\n\t\t\t\tif (years > 0)\n\t\t\t\t{\n\t\t\t\t\ttitle.Format(_T(\"%d %s %d %s %d %s%s\"),\n\t\t\t\t\t\tyears, i18n(_T(\"Dialog\"), _T(\"POWER_ON_YEARS_UNIT\")).GetString(),\n\t\t\t\t\t\tdays, i18n(_T(\"Dialog\"), _T(\"POWER_ON_DAYS_UNIT\")).GetString(),\n\t\t\t\t\t\thours, i18n(_T(\"Dialog\"), _T(\"POWER_ON_HOURS_UNIT\")).GetString(),\n\t\t\t\t\t\tIsMinutesT.GetString());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttitle.Format(_T(\"%d %s %d %s%s\"),\n\t\t\t\t\t\tdays, i18n(_T(\"Dialog\"), _T(\"POWER_ON_DAYS_UNIT\")).GetString(),\n\t\t\t\t\t\thours, i18n(_T(\"Dialog\"), _T(\"POWER_ON_HOURS_UNIT\")).GetString(),\n\t\t\t\t\t\tIsMinutesT.GetString());\n\t\t\t\t}\n\t\t\t\tm_CtrlPowerOnHours.SetToolTipText(title + L\"  \");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_CtrlPowerOnHours.SetToolTipText(L\"\");\n\t\t\t}\n\t\t}\n\t}\n\telse if(nIDEvent == TIMER_AUTO_REFRESH)\n\t{\n\t\tRefresh(FALSE);\n\t}\n\telse if(nIDEvent == TIMER_FORCE_REFRESH)\n\t{\n\t\tKillTimer(TIMER_FORCE_REFRESH);\n\t\tRefresh(FALSE);\n\n\t\tAutoAamApmAdaption();\n\t}\n\telse if(nIDEvent == TIMER_AUTO_DETECT)\n\t{\n\t\tCWaitCursor wait;\n\t\tBOOL flagChangeDisk = FALSE;\n\t\tKillTimer(TIMER_AUTO_DETECT);\n\n\t\tInitAta(TRUE, m_bAdvancedDiskSearch, &flagChangeDisk, m_bWorkaroundHD204UI, m_bWorkaroundAdataSsd);\n\n\t\tif(flagChangeDisk)\n\t\t{\n\t\t\t// Update Menu and Dialog\n\t\t\tm_SelectDisk = 0;\n\t\t\tm_DriveMenuPage = 0;\n\t\t\tChangeLang(m_CurrentLang);\n\t\t\tif(m_bResident)\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < CAtaSmart::MAX_DISK; i++)\n\t\t\t\t{\n\t\t\t\t\tRemoveTemperatureIcon(i);\n\t\t\t\t}\n\t\t\t\tCheckTrayTemperatureIcon();\n\t\t\t}\n\n\t\t\tif(m_SettingDlg != NULL)\n\t\t\t{\n\t\t\t\t::SendMessage(m_SettingDlg->m_hWnd, WM_CLOSE, 0, 0);\n\t\t\t}\n\t\t\tif(m_HealthDlg != NULL)\n\t\t\t{\n\t\t\t\t::SendMessage(m_HealthDlg->m_hWnd, WM_CLOSE, 0, 0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tRefresh(TRUE);\n\t\t}\n\t}\n\telse if(nIDEvent == TIMER_UPDATE_TRAY_ICON)\n\t{\n\t\tKillTimer(TIMER_UPDATE_TRAY_ICON);\n\t\tfor(int i = 0; i < CAtaSmart::MAX_DISK; i++)\n\t\t{\n\t\t\tRemoveTemperatureIcon(i);\n\t\t}\n\t\tCheckTrayTemperatureIcon();\n\t\tShowWindow(SW_SHOW);\n\t}\n\n\tCMainDialogFx::OnTimer(nIDEvent);\n}\n\nLRESULT CDiskInfoDlg::OnPowerBroadcast(WPARAM wParam, LPARAM lParam)\n{\n\tswitch(wParam)\n\t{\n\tcase PBT_APMRESUMESUSPEND:\n\t\tSetTimer(TIMER_FORCE_REFRESH, 5 * 1000, 0);\n//\t\tMessageBox(_T(\"PBT_APMRESUMESUSPEND\"));\n\t\tbreak;\n//\tcase PBT_APMSUSPEND:\n//\t\tMessageBox(_T(\"PBT_APMSUSPEND\"));\n//\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\n\nLRESULT CDiskInfoDlg::OnQueryEndSession(WPARAM wParam, LPARAM lParam)\n{\n\treturn TRUE;\n}\n\nLRESULT CDiskInfoDlg::OnDeviceChange(WPARAM wParam, LPARAM lParam)\n{\n\tif(m_AutoDetectionStatus <= 0)\n\t{\n\t\treturn FALSE;\n\t}\n\n\t//CString cstr;\n\tswitch(wParam)\n\t{\n\tcase DBT_DEVICEARRIVAL:\n\t\t{\n\t\t\t//cstr.Format(_T(\"DBT_DEVICEARRIVAL: LPARAM=%08X\\n\"), lParam);\n\t\t\tPDEV_BROADCAST_HDR pdbh = (PDEV_BROADCAST_HDR)lParam;\n\t\t\tswitch(pdbh->dbch_devicetype)\n\t\t\t{\n\t\t\tcase DBT_DEVTYP_DEVICEINTERFACE:\n\t\t\t\t{\n\t\t\t\t\t//cstr += _T(\"DBT_DEVTYP_DEVICEINTERFACE\");\n\t\t\t\t\tPDEV_BROADCAST_DEVICEINTERFACE pdbd = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;\n\t\t\t\t\tif(pdbd->dbcc_classguid == StrageGUID)\n\t\t\t\t\t{\n\t\t\t\t\t//\tAfxMessageBox(pdbd->dbcc_name);\n\t\t\t\t\t\n\t\t\t\t\t// Disabled 2008/11/20 (This feature will be enabled on future release...)\n\t\t\t\t\t\tKillTimer(TIMER_AUTO_DETECT);\n\t\t\t\t\t\tSetTimer(TIMER_AUTO_DETECT, m_AutoDetectionStatus * 1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DBT_DEVTYP_HANDLE:\n\t\t\t\t// cstr += _T(\"DBT_DEVTYP_HANDLE\");\n\t\t\t\tbreak;\n\t\t\tcase DBT_DEVTYP_OEM:\n\t\t\t\t// cstr += _T(\"DBT_DEVTYP_OEM\");\n\t\t\t\tbreak;\n\t\t\tcase DBT_DEVTYP_PORT:\n\t\t\t\t// cstr += _T(\"DBT_DEVTYP_PORT\");\n\t\t\t\tbreak;\n\t\t\tcase DBT_DEVTYP_VOLUME:\n\t\t\t\t// cstr += _T(\"DBT_DEVTYP_VOLUME\\n\");\n\t\t\t\t// PDEV_BROADCAST_VOLUME pdbv = (PDEV_BROADCAST_VOLUME)lParam;\n\t\t\t\t// CString temp;\n\t\t\t\t// temp.Format(_T(\"Flags=%d, UnitMask=%08X\"), pdbv->dbcv_flags, pdbv->dbcv_unitmask);\n\t\t\t\t// cstr += temp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t//\tAfxMessageBox(cstr);\n\t\t}\n\t\tbreak;\n\tcase DBT_DEVICEREMOVECOMPLETE:\n\t\t{\n\t\t\t// cstr.Format(_T(\"DBT_DEVICEREMOVECOMPLETE: LPARAM=%08X\\n\"), lParam);\n\t\t\tPDEV_BROADCAST_HDR pdbh = (PDEV_BROADCAST_HDR)lParam;\n\t\t\tswitch(pdbh->dbch_devicetype)\n\t\t\t{\n\t\t\tcase DBT_DEVTYP_DEVICEINTERFACE:\n\t\t\t\t{\n\t\t\t\t//\tcstr += _T(\"DBT_DEVTYP_DEVICEINTERFACE\");\n\t\t\t\t\tPDEV_BROADCAST_DEVICEINTERFACE pdbd = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;\n\t\t\t\t\tif(pdbd->dbcc_classguid == StrageGUID)\n\t\t\t\t\t{\n\t\t\t\t\t//\tAfxMessageBox(pdbd->dbcc_name);\n\t\t\t\t\t// Disabled 2008/11/20 (This feature will be enabled on future release...)\n\t\t\t\t\t\tKillTimer(TIMER_AUTO_DETECT);\n\t\t\t\t\t\tSetTimer(TIMER_AUTO_DETECT, m_AutoDetectionStatus * 1000, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DBT_DEVTYP_HANDLE:\n\t\t\t//\tcstr += _T(\"DBT_DEVTYP_HANDLE\");\n\t\t\t\tbreak;\n\t\t\tcase DBT_DEVTYP_OEM:\n\t\t\t//\tcstr += _T(\"DBT_DEVTYP_OEM\");\n\t\t\t\tbreak;\n\t\t\tcase DBT_DEVTYP_PORT:\n\t\t\t//\tcstr += _T(\"DBT_DEVTYP_PORT\");\n\t\t\t\tbreak;\n\t\t\tcase DBT_DEVTYP_VOLUME:\n\t\t\t//\tcstr += _T(\"DBT_DEVTYP_VOLUME\\n\");\n\t\t\t//\tPDEV_BROADCAST_VOLUME pdbv = (PDEV_BROADCAST_VOLUME)lParam;\n\t\t\t//\tCString temp;\n\t\t\t//\ttemp.Format(_T(\"Flags=%d, UnitMask=%08X\"), pdbv->dbcv_flags, pdbv->dbcv_unitmask);\n\t\t\t//\tcstr += temp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t//\tAfxMessageBox(cstr);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t//\tcstr.Format(_T(\"WPARAM=%08X, LPARAM=%08X\"), wParam, lParam);\n\t//\tAfxMessageBox(cstr);\n\t\tbreak;\n\t}\n\treturn TRUE;\n}\n\nvoid CDiskInfoDlg::AutoAamApmAdaption()\n{\n\tif(! m_bAutoAamApm)\n\t{\n\t\treturn ;\n\t}\n\n\tint status = 0;\n\tint value = 0;\n\n\t//DEBUG\n\tDebugPrint(_T(\"AutoAamApmAdaption\"));\n\t// AAM\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tif(! m_Ata.vars[i].IsAamSupported)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = GetPrivateProfileIntFx(_T(\"AamStatus\"), m_Ata.vars[i].ModelSerial, -1, m_Ini);\n\t\tvalue =  GetPrivateProfileIntFx(_T(\"AamValue\"), m_Ata.vars[i].ModelSerial, -1, m_Ini);\n\t\tif(status == 1 /* Enabled */ && value != -1)\n\t\t{\n\t\t\tm_Ata.EnableAam(i, (BYTE)value);\n\t\t\tm_Ata.UpdateIdInfo(i);\n\t\t\tDebugPrint(_T(\"m_Ata.EnableAam\"));\n\t\t}\n\t\telse if(status == 0 /* Disabled */ )\n\t\t{\n\t\t\tm_Ata.DisableAam(i);\n\t\t\tm_Ata.UpdateIdInfo(i);\n\t\t\tDebugPrint(_T(\"m_Ata.DisableAam\"));\n\t\t}\n\t}\n\n\t// APM\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tif(! m_Ata.vars[i].IsApmSupported)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = GetPrivateProfileIntFx(_T(\"ApmStatus\"), m_Ata.vars[i].ModelSerial, -1, m_Ini);\n\t\tvalue  = GetPrivateProfileIntFx(_T(\"ApmValue\"), m_Ata.vars[i].ModelSerial, -1, m_Ini);\n\t\tif(status == 1 /* Enabled */ && value != -1)\n\t\t{\n\t\t\tm_Ata.EnableApm(i, (BYTE)value);\n\t\t\tm_Ata.UpdateIdInfo(i);\n\t\t\tDebugPrint(_T(\"m_Ata.EnableApm\"));\n\t\t}\n\t\telse if(status == 0 /* Disabled */ )\n\t\t{\n\t\t\tm_Ata.DisableApm(i);\n\t\t\tm_Ata.UpdateIdInfo(i);\n\t\t\tDebugPrint(_T(\"m_Ata.DisableApm\"));\n\t\t}\n\t}\n}\n\nvoid CDiskInfoDlg::ReExecute()\n{\n\t// Added 2013/04/12 - Workaround for Exec Failed\n\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"ExecFailed\"), _T(\"0\"), m_Ini);\n\n\tShowWindow(SW_HIDE);\n\tRemoveTrayMainIcon();\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tRemoveTemperatureIcon(i);\n\t}\n\tKillGraphDlg();\n\tEndDialog(RE_EXEC);\n}\n\nDWORD CDiskInfoDlg::GetSelectDisk()\n{\n\treturn m_SelectDisk;\n}\n\nvoid CDiskInfoDlg::OnBnClickedButtonDisk0(){SelectDrive(0 + m_DriveMenuPage * m_DriveMenuNumber);}\nvoid CDiskInfoDlg::OnBnClickedButtonDisk1(){SelectDrive(1 + m_DriveMenuPage * m_DriveMenuNumber);}\nvoid CDiskInfoDlg::OnBnClickedButtonDisk2(){SelectDrive(2 + m_DriveMenuPage * m_DriveMenuNumber);}\nvoid CDiskInfoDlg::OnBnClickedButtonDisk3(){SelectDrive(3 + m_DriveMenuPage * m_DriveMenuNumber);}\nvoid CDiskInfoDlg::OnBnClickedButtonDisk4(){SelectDrive(4 + m_DriveMenuPage * m_DriveMenuNumber);}\nvoid CDiskInfoDlg::OnBnClickedButtonDisk5(){SelectDrive(5 + m_DriveMenuPage * m_DriveMenuNumber);}\nvoid CDiskInfoDlg::OnBnClickedButtonDisk6(){SelectDrive(6 + m_DriveMenuPage * m_DriveMenuNumber);}\nvoid CDiskInfoDlg::OnBnClickedButtonDisk7(){SelectDrive(7 + m_DriveMenuPage * m_DriveMenuNumber);}\nvoid CDiskInfoDlg::OnBnClickedButtonDisk8() { SelectDrive(8 + m_DriveMenuPage * m_DriveMenuNumber); }\nvoid CDiskInfoDlg::OnBnClickedButtonDisk9() { SelectDrive(9 + m_DriveMenuPage * m_DriveMenuNumber); }\nvoid CDiskInfoDlg::OnBnClickedButtonDisk10() { SelectDrive(10 + m_DriveMenuPage * m_DriveMenuNumber); }\nvoid CDiskInfoDlg::OnBnClickedButtonDisk11() { SelectDrive(11 + m_DriveMenuPage * m_DriveMenuNumber); }\nvoid CDiskInfoDlg::OnBnClickedButtonDisk12() { SelectDrive(12 + m_DriveMenuPage * m_DriveMenuNumber); }\nvoid CDiskInfoDlg::OnBnClickedButtonDisk13() { SelectDrive(13 + m_DriveMenuPage * m_DriveMenuNumber); }\nvoid CDiskInfoDlg::OnBnClickedButtonDisk14() { SelectDrive(14 + m_DriveMenuPage * m_DriveMenuNumber); }\nvoid CDiskInfoDlg::OnBnClickedButtonDisk15() { SelectDrive(15 + m_DriveMenuPage * m_DriveMenuNumber); }\n\n#ifdef MAX_DRIVE_20\nvoid CDiskInfoDlg::OnBnClickedButtonDisk16() { SelectDrive(16 + m_DriveMenuPage * m_DriveMenuNumber); }\nvoid CDiskInfoDlg::OnBnClickedButtonDisk17() { SelectDrive(17 + m_DriveMenuPage * m_DriveMenuNumber); }\nvoid CDiskInfoDlg::OnBnClickedButtonDisk18() { SelectDrive(18 + m_DriveMenuPage * m_DriveMenuNumber); }\nvoid CDiskInfoDlg::OnBnClickedButtonDisk19() { SelectDrive(19 + m_DriveMenuPage * m_DriveMenuNumber); }\n#endif\n\nvoid CDiskInfoDlg::SetControlFont()\n{\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\t//BYTE textAlpha = TEXT_ALPHA;\n//\tCOLORREF textColor = RGB(77, 77, 77);\n\t//COLORREF textColor = m_LabelText;\n#else\n\t///BYTE textAlpha = 255;\n\t//COLORREF textColor = m_LabelText;\n#endif\n\n\tm_List.SetFontEx(m_FontFace, 12, m_ZoomRatio, m_FontRatio, FW_NORMAL, m_FontRender);\n\n\tfor(int i = 0; i < MAX_DRIVE_MENU; i++)\n\t{\n\t\tm_ButtonDisk[i].SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\t}\n\n\tif (m_bHighContrast)\n\t{\n\t\tm_CtrlModel.SetFontEx(m_FontFace, 20, 20, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\t}\n\telse\n\t{\n\t\tm_CtrlModel.SetFontEx(m_FontFace, 24, 24, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\t}\n\n\tm_CtrlButtonPreDisk.SetFontEx(m_FontFace, 24, 24, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlButtonNextDisk.SetFontEx(m_FontFace, 24, 24, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\t\n\tm_CtrlLabelFirmware.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio,m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelSerialNumber.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelInterface.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelTransferMode.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelDriveMap.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelBufferSize.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelNvCacheSize.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelRotationRate.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelPowerOnCount.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelPowerOnHours.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelAtaAtapi.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelFeature.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelDiskStatus.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlLabelTemperature.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\n\tm_CtrlFirmware.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlSerialNumber.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlInterface.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlTransferMode.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlDriveMap.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlBufferSize.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlNvCacheSize.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlRotationRate.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlPowerOnCount.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlPowerOnHours.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlAtaAtapi.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\tm_CtrlFeature.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, m_LabelText, FW_NORMAL, m_FontRender);\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tm_CtrlDiskStatus.SetFontEx(m_FontFace, 16, 16, m_ZoomRatio, m_FontRatio, m_ButtonText, FW_BOLD, m_FontRender);\n\tm_CtrlTemperature.SetFontEx(m_FontFace, 18, 18, m_ZoomRatio, m_FontRatio, m_ButtonText, FW_BOLD, m_FontRender);\n\tm_CtrlLife.SetFontEx(m_FontFace, 18, 18, m_ZoomRatio, m_FontRatio, m_ButtonText, FW_NORMAL, m_FontRender);\n#else\n\tm_CtrlDiskStatus.SetFontEx(m_FontFace, 18, 18, m_ZoomRatio, m_FontRatio, m_ButtonText, FW_BOLD, m_FontRender);\n\tm_CtrlTemperature.SetFontEx(m_FontFace, 20, 20, m_ZoomRatio, m_FontRatio, m_ButtonText, FW_BOLD, m_FontRender);\n#endif\n}\n\nvoid CDiskInfoDlg::OnBnClickedButtonPreDisk()\n{\n\tSelectDrive(m_SelectDisk - 1);\n}\n\nvoid CDiskInfoDlg::OnBnClickedButtonNextDisk()\n{\n\tSelectDrive(m_SelectDisk + 1);\n}\n\nvoid CDiskInfoDlg::OnBnClickedButtonHealthStatus()\n{\n\tCMenu *menu = GetMenu();\n\tif(! (menu->GetMenuState(ID_HEALTH_STATUS, MF_BYCOMMAND) & MF_GRAYED))\n\t{\n\t\tm_HealthDlg = new CHealthDlg(this);\n\t\tm_HealthDlg->Create(CHealthDlg::IDD, m_HealthDlg, ID_HEALTH_STATUS, this);\n\t}\n}\n\nvoid CDiskInfoDlg::OnBnClickedButtonTemperature()\n{\n\tCMenu* menu = GetMenu();\n\tif (!(menu->GetMenuState(ID_TEMPERATURE, MF_BYCOMMAND) & MF_GRAYED))\n\t{\n\t\tm_TemperatureDlg = new CTemperatureDlg(this);\n\t\tm_TemperatureDlg->Create(CTemperatureDlg::IDD, m_TemperatureDlg, ID_TEMPERATURE, this);\n\t}\n}\n\nvoid CDiskInfoDlg::OnBnClickedButtonVoice()\n{\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tDWORD id;\n\tif(GetTickCountFx() % 2)\n\t{\n\t\tid = 7;\n\t}\n\telse\n\t{\n\t\tid = 8;\n\t}\n\tAlertSound(id, AS_SET_SOUND_ID);\n\tAlertSound(1000, AS_PLAY_SOUND);\n#endif\n}\n\n\nvoid CDiskInfoDlg::OnBnClickedButtonCopyright()\n{\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\t/*\n\tif (m_CurrentLang.Find(L\"Japanese\") == 0)\n\t{\n\t\tSYSTEMTIME systime;\n\t\tGetLocalTime(&systime);\n\t\tif ((systime.wYear == 2015 && systime.wMonth == 12 && systime.wDay <= 17)\n\t\t\t|| (systime.wYear == 2015 && systime.wMonth == 12 && systime.wDay == 18 && systime.wHour < 20))\n\t\t{\n\t\t\tOpenUrl(L\"http://akiba-pc.watch.impress.co.jp/docs/sp/20151207_733688.html\");\n\t\t}\n\t}\n\t*/\n\tUINT themeIndex = rand() % (UINT)m_MenuArrayTheme.GetSize();\n\tSendMessage(WM_COMMAND, WM_THEME_ID + themeIndex);\n#endif\n}\n\n\nvoid CDiskInfoDlg::OnBnClickedButtonLife()\n{\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tDWORD id;\n\tif (m_Ata.vars.GetCount() > 0)\n\t{\n\t\tswitch(m_Ata.vars[m_SelectDisk].DiskStatus)\n\t\t{\n\t\tcase  CAtaSmart::DISK_STATUS_GOOD:\n\t\t\tif(m_Ata.vars[m_SelectDisk].Life == 100)\n\t\t\t{\n\t\t\t\tid = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tid = 3;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase  CAtaSmart::DISK_STATUS_CAUTION:\n\t\t\tid = 4;\n\t\t\tbreak;\n\t\tcase CAtaSmart::DISK_STATUS_BAD:\n\t\t\tid = 5;\n\t\t\tbreak;\n\t\tcase CAtaSmart::DISK_STATUS_UNKNOWN:\n\t\tdefault:\n\t\t\tid = 6;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\tid = 6;\n\t}\n\n\tAlertSound(id, AS_SET_SOUND_ID);\n\tAlertSound(1000, AS_PLAY_SOUND);\n#endif\n}\n\nvoid CDiskInfoDlg::SetLabel(CStaticFx& ctrl, CString& label, CString title)\n{\n\tctrl.SetToolTipText(title);\n\tlabel = title;\n}\n\nvoid CDiskInfoDlg::OnShowWindow(BOOL bShow, UINT nStatus)\n{\n\tCMainDialogFx::OnShowWindow(bShow, nStatus);\n}\n\nvoid CDiskInfoDlg::ShowWindowEx(int nCmdShow)\n{\n\tif (nCmdShow != SW_HIDE)\n\t{\n\t\tm_bShowWindow = TRUE;\n\t\tShowWindow(nCmdShow);\n\t\tSetForegroundWindow();\n\t}\n\telse\n\t{\n\t\tShowWindow(nCmdShow);\n\t\tm_bShowWindow = FALSE;\n\t}\n}\n\nBOOL CDiskInfoDlg::CheckThemeEdition(CString name)\n{\n#ifdef SUISHO_AOI_SUPPORT\n\tif (name.Find(L\"Aoi\") == 0) { return TRUE; }\n#elif MSI_MEI_SUPPORT\n\tif (name.Find(L\"MSIMei\") == 0) { return TRUE; }\n#elif KUREI_KEI_SUPPORT\n\tif (name.Find(L\"KureiKei\") == 0) { return TRUE; }\n#elif SUISHO_SHIZUKU_SUPPORT\n\tif (name.Find(L\"Shizuku\") == 0) { return TRUE; }\n#else\n\tif (name.Find(L\"Shizuku\") != 0 && name.Find(L\"KureiKei\") != 0 && name.Find(L\"Aoi\") != 0 && name.Find(L\"MSIMei\") != 0 && name.Find(L\".\") != 0) { return TRUE; }\n#endif\n\n\treturn FALSE;\n}\n"
        },
        {
          "name": "DiskInfoDlg.h",
          "type": "blob",
          "size": 23.7900390625,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n#pragma once\n\n#include \"AtaSmart.h\"\n#include \"AboutDlg.h\"\n#include \"SettingDlg.h\"\n#include \"HealthDlg.h\"\n#include \"OptionDlg.h\"\n#include \"FontSelectionDlg.h\"\n#include \"SoundSettingDlg.h\"\n#include \"GraphDlg.h\"\n#include \"TemperatureDlg.h\"\n#include \"EventLog.h\"\n\n#include \"DialogFx.h\"\n#include \"MainDialogFx.h\"\n#include \"EditFx.h\"\n#include \"ListCtrlFx.h\"\n#include \"OsInfoFx.h\"\n\n#include <Dbt.h>\n\n#define REGISTRY_PATH _T(\"software\\\\Crystal Dew World\\\\CrystalDiskInfo\")\n\n// Task Tray\nenum\n{\n\tMY_EXIT = (WM_APP + 0x1100),\n\tMY_SHOW_MAIN_DIALOG,\n\tMY_SHOW_TEMPERATURE_ICON_ONLY,\n\tMY_PLAY_ALERT_SOUND,\n};\n\n// CDiskInfoDlg dialog\nclass CDiskInfoDlg : public CMainDialogFx\n{\n// Construction\npublic:\n\tCDiskInfoDlg(CWnd* pParent /*=NULL*/, BOOL flagStarupExit);\n\tvirtual ~CDiskInfoDlg();\n\n\tCAtaSmart m_Ata;\n\n// Dialog Data\n\tenum { IDD = IDD_DISKINFO_DIALOG };\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tstatic const int SIZE_SMART_Y = 640;\n\tstatic const int SIZE_MIN_Y = 500;\n\tstatic const int SIZE_MAX_Y = 1000;\n\tstatic const int SIZE_Y = 288;\n\tstatic const int IMAGE_ALPHA = 192;\n\tstatic const int TEXT_ALPHA = 255;\n\tstatic const int LIST_CTL_ALPHA = 192;\n\tstatic const int DRIVE_MENU_SIZE = 84;\n#ifdef BRILLIANT_AZURE_SUPPORT\n\tstatic const int SIZE_X = 1200;\n\tstatic const int SIZE_SMART_X = 1200;\n\tstatic const int OFFSET_X = 360;\n#else\n\tstatic const int SIZE_X = 1000;\n\tstatic const int SIZE_SMART_X = 1000;\n\tstatic const int OFFSET_X = 328;\n#endif\n\n#else\n\tstatic const int SIZE_X = 672;\n\tstatic const int SIZE_SMART_X = 672;\n\tstatic const int SIZE_SMART_Y = 640;\n\tstatic const int SIZE_MIN_Y = 260;\n\tstatic const int SIZE_Y = 260;\n\tstatic const int SIZE_MAX_Y = 1000;\n\tstatic const int OFFSET_X = 0;\n\tstatic const int DRIVE_MENU_SIZE = 84;\n#endif\n\npublic:\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tHMODULE m_hVoice;\n#endif\n\n\t// Timer\n\tstatic const int TIMER_SET_POWER_ON_UNIT = 0x2001;\n\tstatic const int TIMER_AUTO_REFRESH      = 0x2002;\n\tstatic const int TIMER_FORCE_REFRESH     = 0x2003;\n\tstatic const int TIMER_AUTO_DETECT       = 0x2004;\n\tstatic const int TIMER_UPDATE_TRAY_ICON  = 0x2005;\n\n\t// Setting\n\tint SAVE_SMART_PERIOD;\t\t\t// sec\n\tint ALARM_TEMPERATURE_PERIOD;\t// sec\n\n\t// Icon\n\tenum\n\t{\n\t\tICON_GOOD = 0,\n\t\tICON_GOOD_GREEN,\n\t\tICON_CAUTION,\n\t\tICON_BAD,\n\t\tICON_UNKNOWN\n\t};\n\n\tHMENU m_hMenu;\n\tvoid CreateMainMenu(DWORD index);\n\n\tDWORD GetSelectDisk();\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\t// DDX/DDV support\n\n// Implementation\nprotected:\n\tHICON m_hIcon;\n\tHICON m_hIconMini;\n\tHICON m_hTempIcon[2][300];\n\tUINT m_TempIconIndex[CAtaSmart::MAX_DISK];\n\n\tUINT m_MainIconId;\n\n\tCAboutDlg*\t\t\tm_AboutDlg;\n\tCSettingDlg*\t\tm_SettingDlg;\n\tCTemperatureDlg*\tm_TemperatureDlg;\n\tCHealthDlg*\t\t\tm_HealthDlg;\n\tCOptionDlg*\t\t\tm_OptionDlg;\n//\tCAlarmHistoryDlg*\tm_AlarmHistoryDlg;\n\tCSoundSettingDlg*\tm_SoundSettingDlg;\n\tCGraphDlg*\t\t\tm_GraphDlg;\n\tCListCtrlFx\t\t\tm_List;\n\tCImageList\t\t\tm_ImageList;\n\n\tCButtonFx\t\t\tm_ButtonDisk[MAX_DRIVE_MENU];\n\tCButtonFx\t\t\tm_CtrlButtonPreDisk;\n\tCButtonFx\t\t\tm_CtrlButtonNextDisk;\n\n\tCStaticFx\t\t\tm_CtrlLabelFirmware;\n\tCStaticFx\t\t\tm_CtrlLabelSerialNumber;\n\tCStaticFx\t\t\tm_CtrlLabelInterface;\n\tCStaticFx\t\t\tm_CtrlLabelTransferMode;\n\tCStaticFx\t\t\tm_CtrlLabelDriveMap;\n\tCStaticFx\t\t\tm_CtrlLabelBufferSize;\n\tCStaticFx\t\t\tm_CtrlLabelNvCacheSize;\n\tCStaticFx\t\t\tm_CtrlLabelRotationRate;\n\tCStaticFx\t\t\tm_CtrlLabelPowerOnCount;\n\tCStaticFx\t\t\tm_CtrlLabelPowerOnHours;\n\tCStaticFx\t\t\tm_CtrlLabelAtaAtapi;\n\tCStaticFx\t\t\tm_CtrlLabelFeature;\n\tCStaticFx\t\t\tm_CtrlLabelDiskStatus;\n\tCStaticFx\t\t\tm_CtrlLabelTemperature;\n\n\tCEditFx\t\t\t\tm_CtrlModel;\n\tCEditFx\t\t\t\tm_CtrlFirmware;\n\tCEditFx\t\t\t\tm_CtrlSerialNumber;\n\tCEditFx\t\t\t\tm_CtrlInterface;\n\tCEditFx\t\t\t\tm_CtrlTransferMode;\n\tCEditFx\t\t\t\tm_CtrlDriveMap;\n\tCEditFx\t\t\t\tm_CtrlBufferSize;\n\tCEditFx\t\t\t\tm_CtrlNvCacheSize;\n\tCEditFx\t\t\t\tm_CtrlRotationRate;\n\tCEditFx\t\t\t\tm_CtrlPowerOnCount;\n\tCEditFx\t\t\t\tm_CtrlPowerOnHours;\n\tCEditFx\t\t\t\tm_CtrlAtaAtapi;\n\tCEditFx\t\t\t\tm_CtrlFeature;\n\tCButtonFx\t\t\tm_CtrlDiskStatus;\n\tCButtonFx\t\t\tm_CtrlTemperature;\n\tCButtonFx\t\t\tm_CtrlLife;\n\tCButtonFx\t\t\tm_CtrlVoice;\n\tCButtonFx\t\t\tm_CtrlVoiceHide;\n\tCButtonFx\t\t\tm_CtrlCopyright;\n\n\tHDEVNOTIFY m_hDevNotify;\n\n\tCString\t\tm_SmartDir;\n//\tCString\t\tm_GadgetDir;\n\tCString\t\tm_ExeDir;\n\tCString\t\tm_AlertMailPath;\n\tCString\t\tm_OpusDecPath;\n\tCString\t\tm_AlertSoundPath;\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tCString\t\tm_VoicePath;\n#endif\n#ifdef SUISHO_AOI_SUPPORT\n\tCString m_VoiceLanguage;\n#endif\n\n\tDWORD m_SelectDisk;\n\tDWORD m_DriveMenuPage;\n\tDWORD m_AutoRefreshStatus;\n\tDWORD m_WaitTimeStatus;\n\tDWORD m_AutoDetectionStatus;\n\tDWORD m_RawValues;\n\tBOOL m_NowDetectingUnitPowerOnHours;\n\n\tCArray<DWORD, DWORD> m_GraphProcessId;\n\n\tint m_SizeX{};\n\tint m_SizeY{};\n\n\tint m_PreTemp[CAtaSmart::MAX_DISK]{};\n\tBOOL m_bTrayTemperatureIcon[CAtaSmart::MAX_DISK]{};\n\tBOOL m_bAutoRefreshTarget[CAtaSmart::MAX_DISK]{};\n\tBOOL m_bTrayMainIcon;\n\n\t// Options\n\tBOOL m_bNarrowDriveMenu{};\n\tBOOL m_bStartupExit{};\n\tBOOL m_bHideSmartInfo{};\n\tBOOL m_bHideSerialNumber{};\n\tBOOL m_bAdvancedDiskSearch{};\n\tBOOL m_bWorkaroundHD204UI{};\n\tBOOL m_bWorkaroundIE8MODE{};\n\tBOOL m_bWorkaroundAdataSsd{};\n\tBOOL m_bWorkaroundIgnoreC4{};\n\tBOOL m_bEventLog{};\n\tBOOL m_bAlertMail{};\n\tBOOL m_bAtaPassThroughSmart{};\n//\tBOOL m_bUseEventCreate;\t\t// Use eventcreate.exe (XP Pro or later)\n\tBOOL m_bFahrenheit{};\n\tBOOL m_bAutoAamApm{};\n\tBOOL m_bDumpIdentifyDevice{};\n\tBOOL m_bDumpSmartReadData{};\n\tBOOL m_bDumpSmartReadThreshold{};\n\tBOOL m_bShowTemperatureIconOnly{};\n\tBOOL m_bAsciiView{};\n\tBOOL m_bSmartEnglish{};\n\tBOOL m_bGadget{};\n\tBOOL m_bGreenMode{};\n\tBOOL m_bWinDarkMode{};\n\tBOOL m_bAlertSound{};\n\tBOOL m_bHideNoSmartDisk{};\n\tBOOL m_bForceDisableDarkMode{};\n\tBOOL m_bSortDriveLetter{};\n\tBOOL m_bHalfDriveMenu{};\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tBOOL m_bStartupVoice{};\n\tBOOL m_bStartupVoiceDisabled{};\n#endif\n\n\tINT m_DriveMenuNumber{};\n\n\tBOOL AddTemperatureIcon(DWORD index);\n\tBOOL RemoveTemperatureIcon(DWORD index);\n\tBOOL ModifyTemperatureIcon(DWORD index);\n\n\tCString m_LiDisk[20];\n\n\tCString m_Model;\n\tCString m_ModelCapacity;\n\tCString m_Firmware;\n\tCString m_SerialNumber;\n\tCString m_Capacity;\n\tCString m_Temperature;\n\tCString m_Life;\n\tCString m_PowerOnHours;\n\tCString m_PowerOnCount;\n\tCString m_Feature;\n\tCString m_BufferSize;\n\tCString m_NvCacheSize;\n\tCString m_RotationRate;\n\tCString m_LbaSize;\n\tCString m_DriveMap;\n\tCString m_Interface;\n\tCString m_TransferMode;\n\tCString m_AtaAtapi;\n\tCString m_DiskStatus;\n\tCString m_SmartStatus;\n\n\tCString m_LabelFirmware;\n\tCString m_LabelSerialNumber;\n\tCString m_LabelCapacity;\n\tCString m_LabelTemperature;\n\tCString m_LabelPowerOnHours;\n\tCString m_LabelPowerOnCount;\n\tCString m_LabelFeature;\n\tCString m_LabelBufferSize;\n\tCString m_LabelNvCacheSize;\n\tCString m_LabelRotationRate;\n\tCString m_LabelLbaSize;\n\tCString m_LabelDriveMap;\n\tCString m_LabelInterface;\n\tCString m_LabelTransferMode;\n\tCString m_LabelAtaAtapi;\n\tCString m_LabelDiskStatus;\n\tCString m_StatusTip;\n\n\tBOOL ChangeDisk(DWORD index);\n\tBOOL UpdateListCtrl(DWORD index);\n\tvoid SelectDrive(DWORD index);\n\tvoid InitDriveList();\n\tvoid InitListCtrl();\n\tvoid InitAta(BOOL useWmi, BOOL advancedDiskSearch, PBOOL flagChangeDisk, BOOL workaroundHD204UI, BOOL workaroundAdataSsd);\n\n\tvoid ChangeLang(CString LangName);\n\tvoid UpdateDialogSize();\n\tvoid CheckHideSerialNumber();\n\tvoid CheckResident();\n\tvoid CheckStartup();\n\tvoid AutoAamApmAdaption();\n\tvoid ShowTemperatureIconOnly();\n\n\tvoid SetControlFont();\n\tvirtual void SetClientSize(int sizeX, int sizeY, double zoomRatio);\n\n\tvoid SavePos() const;\n\tvoid RestorePos();\n\t\n\tvoid UpdateShareInfo(); // For Sidebar Gadget Support\n\tvoid DeleteShareInfo();\n\n\tBOOL AddTrayMainIcon();\n\tBOOL RemoveTrayMainIcon();\n\n\tCString GetDiskStatus(DWORD statusCode);\n\tCString GetDiskStatusClass(DWORD statusCode);\n\tCString GetDiskStatusReason(DWORD index);\n\tCString GetTemperatureClass(INT temperature, INT alarmTemperature);\n\tCString GetLogicalDriveInfo(DWORD index, INT maxLength = 65535);\n\n\tCString Encode10X(DWORD value);\n\tDWORD Decode10X(CString cstr);\n\n\tvoid CheckRadioAutoRefresh(int id, int value);\n\tvoid CheckRadioWaitTime(int id, int value);\n\tBOOL CheckRadioZoomType(int id, int value);\n\tvoid CheckRadioRawValues(int id, int value);\n\tvoid CheckRadioAutoDetection(int id, int value);\n\tvoid CheckRadioAutoRefresh();\n\tvoid CheckRadioWaitTime();\n\tvoid CheckRadioZoomType();\n\tvoid CheckRadioRawValues();\n\tvoid CheckRadioAutoDetection();\n\tvoid CheckRadioCsmiType(int id, int value);\n\tvoid CheckRadioCsmiType();\n\tvoid ReExecute();\n\tvoid AlarmOverheat();\n\tvoid AlarmHealthStatus(DWORD i, CString dir, CString disk);\n\tvoid CheckPage();\n\tvoid CheckTrayTemperatureIcon();\n\tvoid UpdateTrayTemperatureIcon(BOOL flagForce);\n\tvoid UpdateToolTip();\n\tBOOL IsTemperatureIconExist();\n\n\tvoid TaskTrayRightMenu(DWORD index);\n\tvoid SaveSmartInfo(DWORD index);\n\tvoid ShowGraphDlg(int index);\n\tvoid CreateExchangeInfo();\n\tvoid KillGraphDlg();\n\tvoid SetLabel(CStaticFx& ctrl, CString& label, CString title);\n\n\tBOOL RegisterStartup();\n\tBOOL UnregisterStartup();\n\n\tCString __Number(DWORD value);\n\tCHAR AsciiFilter(BYTE c);\n\n\tvoid ShowWindowEx(int nCmdShow);\n\tvirtual BOOL CheckThemeEdition(CString name);\n\n\t// Generated message map functions\n\tvirtual void OnOK();\n\tvirtual void OnCancel();\n\tvirtual BOOL OnInitDialog();\n\tvirtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);\n//\tvirtual void OnDocumentComplete(LPDISPATCH pDisp, LPCTSTR szUrl);\n\tvirtual void InitDialogComplete();\n\tvoid OnPreDisk();\n\tvoid OnNextDisk();\n\tvoid OnDiskStatus();\n\n\tLRESULT OnPowerBroadcast(WPARAM wParam, LPARAM lParam);\n\tLRESULT OnDeviceChange(WPARAM wParam, LPARAM lParam);\n\tLRESULT OnQueryEndSession(WPARAM wParam, LPARAM lParam);\n\n\tvoid Refresh(DWORD flagForceUpdate);\n\tBOOL AppendLog(CString dir, CString disk, CString file, CTime time, int value, BOOL firstTime = FALSE, int threshold = 0);\n\tBOOL AddEventLog(DWORD eventId, WORD eventType, CString message);\n\tBOOL SendMail(DWORD eventId, CString title, CString message);\n\tBOOL AddAlarmHistory(DWORD eventId, CString disk, CString message);\n\n#define AS_SET_SOUND_ID 1\n#define AS_PLAY_SOUND   2\n#define AS_DEINIT       3\n\tBOOL AlertSound(DWORD eventId, DWORD mode);\n\tBOOL AlertSound(const CString& alertSoundPath) const;\n\tCString m_TempFilePathWave;\n\tCString m_TempFilePathOpus;\n\n\tvoid RebuildListHeader(DWORD index, BOOL forceUpdate = FALSE);\n\n\tvoid SaveText(CString fileName);\n\n\tafx_msg void OnPaint();\n\tafx_msg HCURSOR OnQueryDragIcon();\n\tDECLARE_MESSAGE_MAP()\n\npublic:\n\tint GetSelectedDrive();\n\n\tafx_msg void OnCopy();\n\tafx_msg void OnSaveText();\n\tafx_msg void OnSaveImage();\n\tafx_msg void OnExit();\n\tafx_msg void OnAbout();\n\tafx_msg void OnHideSmartInfo();\n\tafx_msg void OnHideSerialNumber();\n\tafx_msg void OnCrystalDewWorld();\n\tafx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg void OnRefresh();\n\tafx_msg void OnTimer(UINT_PTR nIDEvent);\n\tafx_msg void OnHelpAboutSmart();\n\tafx_msg void OnAutoRefreshDisable();\n\tafx_msg void OnAutoRefresh01Min();\n\tafx_msg void OnAutoRefresh03Min();\n\tafx_msg void OnAutoRefresh05Min();\n\tafx_msg void OnAutoRefresh10Min();\n\tafx_msg void OnAutoRefresh30Min();\n\tafx_msg void OnAutoRefresh60Min();\n\tafx_msg void OnAutoRefresh120Min();\n\tafx_msg void OnAutoRefresh180Min();\n\tafx_msg void OnAutoRefresh360Min();\n\tafx_msg void OnAutoRefresh720Min();\n\tafx_msg void OnAutoRefresh1440Min();\n\tafx_msg void OnOpenDiskManagement();\n\tafx_msg void OnOpenDeviceManager();\n\tafx_msg void OnAdvancedDiskSearch();\n\tafx_msg void OnWorkaroundHD204UI();\n\tafx_msg void OnWorkaroundIE8MODE();\n\tafx_msg void OnWorkaroundAdataSsd();\n\tafx_msg void OnWorkaroundIgnoreC4();\n\tafx_msg void OnGreenMode();\n\tafx_msg void OnDisableDarkMode();\n\tafx_msg void OnResident();\n\n\t// Task Tray\n\tLRESULT TempIcon(int index, WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnRegMessage(WPARAM, LPARAM);\n\tafx_msg LRESULT OnTaskbarCreated(WPARAM, LPARAM);\n\tafx_msg LRESULT OnTempIcon0(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon1(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon2(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon3(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon4(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon5(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon6(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon7(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon8(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon9(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon10(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon11(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon12(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon13(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon14(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon15(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon16(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon17(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon18(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon19(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon20(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon21(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon22(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon23(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon24(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon25(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon26(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon27(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon28(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon29(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon30(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon31(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon32(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon33(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon34(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon35(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon36(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon37(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon38(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon39(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon40(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon41(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon42(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon43(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon44(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon45(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon46(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon47(WPARAM wParam,LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon48(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon49(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon50(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon51(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon52(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon53(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon54(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon55(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon56(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon57(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon58(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon59(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon60(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon61(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon62(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon63(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon64(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon65(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon66(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon67(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon68(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon69(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon70(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon71(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon72(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon73(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon74(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon75(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon76(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon77(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon78(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon79(WPARAM wParam, LPARAM lParam);\n/*\n\tafx_msg LRESULT OnTempIcon80(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon81(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon82(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon83(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon84(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon85(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon86(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon87(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon88(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon89(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon90(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon91(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon92(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon93(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon94(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon95(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon96(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon97(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon98(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon99(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon100(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon101(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon102(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon103(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon104(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon105(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon106(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon107(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon108(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon109(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon110(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon111(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon112(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon113(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon114(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon115(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon116(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon117(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon118(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon119(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon120(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon121(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon122(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon123(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon124(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon125(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon126(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnTempIcon127(WPARAM wParam, LPARAM lParam);\n*/\n\tafx_msg LRESULT OnPlayAlertSound(WPARAM wParam, LPARAM lParam);\n\n\tafx_msg void OnGraph();\n\tafx_msg void OnHelp();\n\tafx_msg void OnCustomize();\n\tafx_msg void OnStartup();\n\tafx_msg void OnWait0Sec();\n\tafx_msg void OnWait5Sec();\n\tafx_msg void OnWait10Sec();\n\tafx_msg void OnWait15Sec();\n\tafx_msg void OnWait20Sec();\n\tafx_msg void OnWait30Sec();\n\tafx_msg void OnWait40Sec();\n\tafx_msg void OnWait50Sec();\n\tafx_msg void OnWait60Sec();\n\tafx_msg void OnWait90Sec();\n\tafx_msg void OnWait120Sec();\n\tafx_msg void OnWait150Sec();\n\tafx_msg void OnWait180Sec();\n\tafx_msg void OnWait210Sec();\n\tafx_msg void OnWait240Sec();\n\tafx_msg void OnAutoDetection05Sec();\n\tafx_msg void OnAutoDetection10Sec();\n\tafx_msg void OnAutoDetection20Sec();\n\tafx_msg void OnAutoDetection30Sec();\n\tafx_msg void OnAutoDetectionDisable();\n\tafx_msg void OnEventLog();\n\tafx_msg void OnAtaPassThroughSmart();\n\tafx_msg void OnGadgetSupport();\n\tafx_msg void OnCelsius();\n\tafx_msg void OnFahrenheit();\n\tafx_msg void OnAamApm();\n\tafx_msg void OnTemperature();\n\tafx_msg void OnAutoAamApm();\n\tafx_msg void OnRescan();\n\tafx_msg void OnUsbSat();\n\tafx_msg void OnUsbIodata();\n\tafx_msg void OnUsbSunplus();\n\tafx_msg void OnUsbLogitec();\n\tafx_msg void OnUsbProlific();\n\tafx_msg void OnUsbJmicron();\n\tafx_msg void OnUsbCypress();\n\tafx_msg void OnUsbMemory();\n\tafx_msg void OnUsbASM1352R();\n\tafx_msg void OnUsbRealtek9220DP();\n//\tafx_msg void OnUsbSat16();\n\tafx_msg void OnUsbNVMeJMicron3();\n\tafx_msg void OnUsbNVMeJMicron();\n\tafx_msg void OnUsbNVMeASMedia();\n\tafx_msg void OnUsbNVMeRealtek();\n\tafx_msg void OnUsbEnableAll();\n\tafx_msg void OnUsbDisableAll();\n\tafx_msg void OnAMD_RC2();\n\tafx_msg void OnMegaRAID();\n\tafx_msg void OnIntelVROC();\n#ifdef JMICRON_USB_RAID_SUPPORT\n\tafx_msg void OnUsbJMS56X();\n\tafx_msg void OnUsbJMB39X();\n\tafx_msg void OnUsbJMS586_20();\n\tafx_msg void OnUsbJMS586_40();\n#endif\n\tafx_msg void OnHealthStatus();\n\tafx_msg void OnSoundSetting();\n\tafx_msg void OnDumpIdentifyDevice();\n\tafx_msg void OnDumpSmartReadData();\n\tafx_msg void OnDumpSmartReadThreshold();\n\tafx_msg void OnResidentMinimize();\n\tafx_msg void OnResidentHide();\n\tafx_msg void OnSortPhysicalDriveId();\n\tafx_msg void OnSortDriveLetter();\n\tafx_msg void OnDriveMenu8();\n\tafx_msg void OnDriveMenu16();\n#ifdef MAX_DRIVE_20\n\tafx_msg void OnDriveMenu10();\n\tafx_msg void OnDriveMenu20();\n#endif\n\tafx_msg void OnZoom100();\n\tafx_msg void OnZoom125();\n\tafx_msg void OnZoom150();\n\tafx_msg void OnZoom200();\n\tafx_msg void OnZoom250();\n\tafx_msg void OnZoom300();\n\tafx_msg void OnZoomAuto();\n\tafx_msg void OnRawValues16();\n\tafx_msg void OnRawValues10All();\n\tafx_msg void OnRawValues2byte();\n\tafx_msg void OnRawValues1byte();\n//\tafx_msg void OnAutoDetection();\n\tafx_msg void OnAsciiView();\n\tafx_msg void OnAlertMail();\n\tafx_msg void OnMailSettings();\n\tafx_msg void OnSmartEnglish();\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tafx_msg void OnStartupVoice();\n#endif\n#ifdef SUISHO_AOI_SUPPORT\n\tafx_msg void OnVoiceEnglish();\n\tafx_msg void OnVoiceJapanese();\n#endif\n\n\tafx_msg void OnFontSetting();\n\tafx_msg void OnCsmiDisable();\n\tafx_msg void OnCsmiEnableAuto();\n\tafx_msg void OnCsmiEnableRaid();\n\tafx_msg void OnCsmiEnableAll();\n//\tafx_msg void OnInstallGadget();\n//\tafx_msg void OnAlarmHistory();\n\tafx_msg void OnAlertSound();\n\tafx_msg void OnHideNoSmartDisk();\n\tafx_msg void OnBnClickedButtonDisk0();\n\tafx_msg void OnBnClickedButtonDisk1();\n\tafx_msg void OnBnClickedButtonDisk2();\n\tafx_msg void OnBnClickedButtonDisk3();\n\tafx_msg void OnBnClickedButtonDisk4();\n\tafx_msg void OnBnClickedButtonDisk5();\n\tafx_msg void OnBnClickedButtonDisk6();\n\tafx_msg void OnBnClickedButtonDisk7();\n\tafx_msg void OnBnClickedButtonDisk8();\n\tafx_msg void OnBnClickedButtonDisk9();\n\tafx_msg void OnBnClickedButtonDisk10();\n\tafx_msg void OnBnClickedButtonDisk11();\n\tafx_msg void OnBnClickedButtonDisk12();\n\tafx_msg void OnBnClickedButtonDisk13();\n\tafx_msg void OnBnClickedButtonDisk14();\n\tafx_msg void OnBnClickedButtonDisk15();\n#ifdef MAX_DRIVE_20\n\tafx_msg void OnBnClickedButtonDisk16();\n\tafx_msg void OnBnClickedButtonDisk17();\n\tafx_msg void OnBnClickedButtonDisk18();\n\tafx_msg void OnBnClickedButtonDisk19();\n#endif\n\tafx_msg void OnBnClickedButtonPreDisk();\n\tafx_msg void OnBnClickedButtonNextDisk();\n\tafx_msg void OnBnClickedButtonHealthStatus();\n\tafx_msg void OnBnClickedButtonTemperature();\n\tafx_msg void OnBnClickedButtonVoice();\n\tafx_msg void OnBnClickedButtonCopyright();\n\n\tafx_msg void OnBnClickedButtonLife();\n\tafx_msg void OnShowWindow(BOOL bShow, UINT nStatus);\n//\tafx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);\n};\n"
        },
        {
          "name": "DiskInfoDlgCopy.cpp",
          "type": "blob",
          "size": 29.52734375,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\nCString CDiskInfoDlg::__Number(DWORD value)\n{\n\tCString cstr;\n\n\tif(value >= 1000)\n\t{\n\t\tcstr = _T(\"\");\n\t}\n\telse if(value >= 100)\n\t{\n\t\tcstr.Format(_T(\"%3d\"), value);\n\t}\n\telse if(value >= 10)\n\t{\n\t\tcstr.Format(_T(\"_%2d\"), value);\n\t}\n\telse\n\t{\n\t\tcstr.Format(_T(\"__%1d\"), value);\n\t}\n\n\treturn cstr;\n}\n\nCHAR CDiskInfoDlg::AsciiFilter(BYTE ch)\n{\n\tif((0x00 <= ch && ch < 0x20) || ch >= 0x7f)\n\t{\n\t\treturn '.';\n\t}\n\treturn ch;\n}\n\nvoid CDiskInfoDlg::SaveText(CString fileName)\n{\n\tCString cstr, clip, driveTemplate, drive, feature, temp, line, csd;\n\n\tUpdateData(TRUE);\n\n\tclip = _T(\"\\\n----------------------------------------------------------------------------\\r\\n\\\n%PRODUCT% %VERSION% (C) %COPY_YEAR% hiyohiyo\\r\\n\\\n                                Crystal Dew World: https://crystalmark.info/\\r\\n\\\n----------------------------------------------------------------------------\\r\\n\\\n\\r\\n\\\n    OS : %OS%\\r\\n\\\n  Date : %DATE%\\r\\n\\\n\\r\\n\\\n-- Controller Map ----------------------------------------------------------\\r\\n\\\n%CONTROLLER_MAP%\\\n\\r\\n\\\n-- Disk List ---------------------------------------------------------------\\r\\n\\\n%DISK_LIST%\\\n\\r\\n\");\n\tclip.Replace(_T(\"%PRODUCT%\"), PRODUCT_NAME);\n\tCString version;\n\tversion = PRODUCT_VERSION; \n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tversion +=  _T(\" \") PRODUCT_EDITION;\n#endif\n\tclip.Replace(_T(\"%VERSION%\"), version);\n\tclip.Replace(_T(\"%COPY_YEAR%\"), PRODUCT_COPY_YEAR);\n\n\tSYSTEMTIME st;\n\tGetLocalTime(&st);\n\tcstr.Format(_T(\"%04d/%02d/%02d %d:%02d:%02d\"), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);\n\tclip.Replace(_T(\"%DATE%\"), cstr);\n\n\tclip.Replace(_T(\"%CONTROLLER_MAP%\"), m_Ata.m_ControllerMap);\n\n\tCString osFullName, osName, osVersion, osArchitecture;\n\tGetOsName(osFullName, osName, osVersion, osArchitecture);\n\tclip.Replace(_T(\"%OS%\"), osFullName);\n\n\tcstr = _T(\"\");\n\ttemp = _T(\"\");\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tif(m_Ata.vars[i].TotalDiskSize >= 1000)\n\t\t{\n\t\t\ttemp.Format(_T(\" (%02d) %s : %.1f GB\"), i + 1,\n\t\t\t\tm_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize / 1000.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemp.Format(_T(\" (%02d) %s : %d MB\"), i + 1,\n\t\t\t\tm_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize);\n\t\t}\n\n\t\tcstr += temp;\n\t\tif(m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_CSMI)\n\t\t{\n\t\t\tif(m_Ata.vars[i].PhysicalDriveId < 0)\n\t\t\t{\n\t\t\t\ttemp.Format(_T(\" [X/%d/%d, %s]\"),\n\t\t\t\t\tm_Ata.vars[i].ScsiPort, m_Ata.vars[i].sasPhyEntity.bPortIdentifier, m_Ata.vars[i].CommandTypeString.GetString());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp.Format(_T(\" [%d/%d/%d, %s]\"),\n\t\t\t\t\tm_Ata.vars[i].PhysicalDriveId, m_Ata.vars[i].ScsiPort, m_Ata.vars[i].sasPhyEntity.bPortIdentifier, m_Ata.vars[i].CommandTypeString.GetString());\n\t\t\t}\n\t\t}\n\t\telse if(m_Ata.vars[i].PhysicalDriveId < 0)\n\t\t{\n\t\t\ttemp.Format(_T(\" [X/%d/%d, %s]\"),\n\t\t\t\tm_Ata.vars[i].ScsiPort, m_Ata.vars[i].ScsiTargetId, m_Ata.vars[i].CommandTypeString.GetString());\n\t\t}\n\t\telse if(m_Ata.vars[i].ScsiPort < 0)\n\t\t{\n\t\t\tif(m_Ata.vars[i].UsbVendorId > 0 && m_Ata.vars[i].UsbProductId > 0)\n\t\t\t{\n\t\t\t\ttemp.Format(_T(\" [%d/X/X, %s] (V=%04X, P=%04X)\"),\n\t\t\t\t\tm_Ata.vars[i].PhysicalDriveId, m_Ata.vars[i].CommandTypeString.GetString(), m_Ata.vars[i].UsbVendorId, m_Ata.vars[i].UsbProductId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp.Format(_T(\" [%d/X/X, %s]\"),\n\t\t\t\t\tm_Ata.vars[i].PhysicalDriveId, m_Ata.vars[i].CommandTypeString.GetString());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemp.Format(_T(\" [%d/%d/%d, %s]\"),\n\t\t\t\tm_Ata.vars[i].PhysicalDriveId, m_Ata.vars[i].ScsiPort, m_Ata.vars[i].ScsiTargetId, m_Ata.vars[i].CommandTypeString.GetString());\n\t\t}\n\n\t\tcstr += temp;\n\n\t\tif(! m_Ata.vars[i].SsdVendorString.IsEmpty())\n\t\t{\n\t\t\tcstr += _T(\" - \") + m_Ata.vars[i].SsdVendorString;\n\t\t}\n\n\t\tcstr += _T(\"\\r\\n\");\n\t}\n\tclip.Replace(_T(\"%DISK_LIST%\"), cstr);\n\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tif (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_NVME)\n\t\t{\n\t\t\tdriveTemplate = _T(\"\\\n----------------------------------------------------------------------------\\r\\n\\\n (%I%) %MODEL%\\r\\n\\\n----------------------------------------------------------------------------\\r\\n\\\n%ENCLOSURE%\\\n           Model : %MODEL%\\r\\n\\\n        Firmware : %FIRMWARE%\\r\\n\\\n   Serial Number : %SERIAL_NUMBER%\\r\\n\\\n       Disk Size : %TOTAL_DISK_SIZE%\\r\\n\\\n       Interface : %INTERFACE%\\r\\n\\\n        Standard : %MAJOR_VERSION%\\r\\n\\\n   Transfer Mode : %TRANSFER_MODE%\\r\\n\\\n  Power On Hours : %POWER_ON_HOURS%\\r\\n\\\n  Power On Count : %POWER_ON_COUNT%\\r\\n\\\n%HOST_READS%\\\n%HOST_WRITES%\\\n     Temperature : %TEMPERATURE%\\r\\n\\\n   Health Status : %DISK_STATUS%\\r\\n\\\n        Features : %SUPPORTED_FEATURE%\\r\\n\\\n    Drive Letter : %DRIVE_LETTER%\\r\\n\\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdriveTemplate = _T(\"\\\n----------------------------------------------------------------------------\\r\\n\\\n (%I%) %MODEL%\\r\\n\\\n----------------------------------------------------------------------------\\r\\n\\\n%ENCLOSURE%\\\n           Model : %MODEL%\\r\\n\\\n        Firmware : %FIRMWARE%\\r\\n\\\n   Serial Number : %SERIAL_NUMBER%\\r\\n\\\n       Disk Size : %TOTAL_DISK_SIZE%\\r\\n\\\n     Buffer Size : %BUFFER_SIZE%\\r\\n\\\n%NV_CACHE_SIZE%\\\n%QUEUE_DEPTH%\\\n    # of Sectors : %NUMBER_OF_SECTORS%\\r\\n\\\n   Rotation Rate : %ROTATION_RATE%\\r\\n\\\n       Interface : %INTERFACE%\\r\\n\\\n   Major Version : %MAJOR_VERSION%\\r\\n\\\n   Minor Version : %MINOR_VERSION%\\r\\n\\\n   Transfer Mode : %TRANSFER_MODE%\\r\\n\\\n  Power On Hours : %POWER_ON_HOURS%\\r\\n\\\n  Power On Count : %POWER_ON_COUNT%\\r\\n\\\n%HOST_READS%\\\n%HOST_WRITES%\\\n%NAND_WRITES%\\\n%GBYTES_ERASED%\\\n%WEAR_LEVELING_COUNT%\\\n     Temperature : %TEMPERATURE%\\r\\n\\\n   Health Status : %DISK_STATUS%\\r\\n\\\n        Features : %SUPPORTED_FEATURE%\\r\\n\\\n       APM Level : %APM_LEVEL%\\r\\n\\\n       AAM Level : %AAM_LEVEL%\\r\\n\\\n    Drive Letter : %DRIVE_LETTER%\\r\\n\\\n\");\n\t\t}\n\n\t\tdriveTemplate += _T(\"\\r\\n\");\n\n\t\tdrive = driveTemplate;\n\t\tcstr.Format(_T(\"%02d\"), i + 1);\n\t\tdrive.Replace(_T(\"%I%\"), cstr);\n\t\tif(m_Ata.vars[i].Enclosure.IsEmpty())\n\t\t{\n\t\t\tdrive.Replace(_T(\"%ENCLOSURE%\"), _T(\"\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"       Enclosure : %s (V=%04X, P=%04X, %s)\"),\n\t\t\t\tm_Ata.vars[i].Enclosure.GetString(), m_Ata.vars[i].UsbVendorId, m_Ata.vars[i].UsbProductId, m_Ata.vars[i].CommandTypeString.GetString());\n\t\t\tif(! m_Ata.vars[i].SsdVendorString.IsEmpty())\n\t\t\t{\n\t\t\t\tcstr += _T(\" - \") + m_Ata.vars[i].SsdVendorString;\n\t\t\t}\n\t\t\tcstr += _T(\"\\r\\n\");\n\t\t\tdrive.Replace(_T(\"%ENCLOSURE%\"), cstr);\n\t\t}\n\t\tdrive.Replace(_T(\"%MODEL%\"), m_Ata.vars[i].Model);\n//\t\tdrive.Replace(_T(\"%MODEL_WMI%\"), m_Ata.vars[i].ModelWmi);\n\t\tdrive.Replace(_T(\"%FIRMWARE%\"), m_Ata.vars[i].FirmwareRev);\n\t\tif(m_bHideSerialNumber)\n\t\t{\n\t\t\tCString temp = _T(\"\");\n\t\t\tfor(int j = 0; j < m_Ata.vars[i].SerialNumber.GetLength(); j++)\n\t\t\t{\n\t\t\t\ttemp += _T(\"*\");\n\t\t\t}\n\t\t\tdrive.Replace(_T(\"%SERIAL_NUMBER%\"), temp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdrive.Replace(_T(\"%SERIAL_NUMBER%\"), m_Ata.vars[i].SerialNumber);\n\t\t}\n\t\tdrive.Replace(_T(\"%INTERFACE%\"), m_Ata.vars[i].Interface);\n\t\tif (m_Ata.vars[i].MajorVersion.IsEmpty())\n\t\t{\n\t\t\tdrive.Replace(_T(\"%MAJOR_VERSION%\"), i18n(_T(\"Dialog\"), _T(\"UNKNOWN\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdrive.Replace(_T(\"%MAJOR_VERSION%\"), m_Ata.vars[i].MajorVersion);\n\t\t}\n\t\tif (m_Ata.vars[i].MajorVersion.IsEmpty())\n\t\t{\n\t\t\tdrive.Replace(_T(\"%MINOR_VERSION%\"), i18n(_T(\"Dialog\"), _T(\"UNKNOWN\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdrive.Replace(_T(\"%MINOR_VERSION%\"), m_Ata.vars[i].MinorVersion);\n\t\t}\t\t\n\n\t\ttemp.Format(_T(\"%s | %s\"), m_Ata.vars[i].CurrentTransferMode.GetString(), m_Ata.vars[i].MaxTransferMode.GetString());\n\t\tdrive.Replace(_T(\"%TRANSFER_MODE%\"), temp);\n\n\t\tif (m_Ata.vars[i].NumberOfSectors <= 0)\n\t\t{\n\t\t\ttemp = i18n(_T(\"Dialog\"), _T(\"UNKNOWN\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemp.Format(_T(\"%I64d\"), m_Ata.vars[i].NumberOfSectors);\n\t\t}\n\t\tdrive.Replace(_T(\"%NUMBER_OF_SECTORS%\"), temp);\n\t\t// Temporary ///////////////////////\n\n\n\t\tCString diskStatus;\n\t\tdiskStatus = GetDiskStatus(m_Ata.vars[i].DiskStatus);\n\t\tif(m_Ata.vars[i].Life >= 0)\n\t\t{\n\t\t\tcstr.Format(_T(\" (%d %%)\"), m_Ata.vars[i].Life);\n\t\t\tdiskStatus += cstr; \n\t\t}\n\t\tdrive.Replace(_T(\"%DISK_STATUS%\"), diskStatus);\n\n\t\tCString IsMinutes;\n\n\t\tif(m_Ata.vars[i].MeasuredPowerOnHours > 0)\n\t\t{\n\t\t\tif(m_Ata.vars[i].MeasuredTimeUnitType == CAtaSmart::POWER_ON_MINUTES)\n\t\t\t{\n\t\t\t\tif(m_Ata.vars[i].IsMaxtorMinute)\n\t\t\t\t{\n\t\t\t\t\tIsMinutes = _T(\" (?)\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIsMinutes = _T(\"\");\n\t\t\t}\n\t\t\tcstr.Format(_T(\"%d %s%s\"), m_Ata.vars[i].MeasuredPowerOnHours, i18n(_T(\"Dialog\"), _T(\"POWER_ON_HOURS_UNIT\")).GetString(), IsMinutes.GetString());\n\t\t}\n\t\telse if(m_Ata.vars[i].DetectedPowerOnHours >= 0)\n\t\t{\n\t\t\tif(m_Ata.vars[i].DetectedTimeUnitType == CAtaSmart::POWER_ON_MINUTES)\n\t\t\t{\n\t\t\t\tif(m_Ata.vars[i].IsMaxtorMinute)\n\t\t\t\t{\n\t\t\t\t\tIsMinutes = _T(\" (?)\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIsMinutes = _T(\"\");\n\t\t\t}\n\t\t\tcstr.Format(_T(\"%d %s%s\"), m_Ata.vars[i].DetectedPowerOnHours, i18n(_T(\"Dialog\"), _T(\"POWER_ON_HOURS_UNIT\")).GetString(), IsMinutes.GetString());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr = i18n(_T(\"Dialog\"), _T(\"UNKNOWN\"));\n\t\t}\n\t\tdrive.Replace(_T(\"%POWER_ON_HOURS%\"), cstr);\n\n\t\tif(m_Ata.vars[i].PowerOnCount > 0)\n\t\t{\n\t\t\tcstr.Format(_T(\"%d %s\"), m_Ata.vars[i].PowerOnCount, i18n(_T(\"Dialog\"), _T(\"POWER_ON_COUNT_UNIT\")).GetString());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr = i18n(_T(\"Dialog\"), _T(\"UNKNOWN\"));\n\t\t}\n\t\tdrive.Replace(_T(\"%POWER_ON_COUNT%\"), cstr);\n\n\t\tif(m_Ata.vars[i].NvCacheSize > 0)\n\t\t{\n\t\t\tcstr.Format(_T(\"%d MB\"), (int)(m_Ata.vars[i].NvCacheSize / 1024 / 1024));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr = _T(\"----\");\n\t\t}\n\n\t\tif(m_Ata.vars[i].NvCacheSize == 0)\n\t\t{\n\t\t\tdrive.Replace(_T(\"%NV_CACHE_SIZE%\"), _T(\"\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"   NV Cache Size : %d MB\\r\\n\"), (int)(m_Ata.vars[i].NvCacheSize / 1024 / 1024));\n\t\t\tdrive.Replace(_T(\"%NV_CACHE_SIZE%\"), cstr);\n\t\t}\n\n\t\tif(m_Ata.vars[i].HostWrites == -1)\n\t\t{\n\t\t\tdrive.Replace(_T(\"%HOST_WRITES%\"), _T(\"\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"     Host Writes : %d GB\\r\\n\"), m_Ata.vars[i].HostWrites);\t\t\n\t\t\tdrive.Replace(_T(\"%HOST_WRITES%\"), cstr);\n\t\t}\n\n\t\tif(m_Ata.vars[i].HostReads == -1)\n\t\t{\n\t\t\tdrive.Replace(_T(\"%HOST_READS%\"), _T(\"\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"      Host Reads : %d GB\\r\\n\"), m_Ata.vars[i].HostReads);\t\t\n\t\t\tdrive.Replace(_T(\"%HOST_READS%\"), cstr);\n\t\t}\n\n\t\tif(m_Ata.vars[i].NandWrites == -1)\n\t\t{\n\t\t\tdrive.Replace(_T(\"%NAND_WRITES%\"), _T(\"\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\tif (m_Ata.vars[i].PlextorNandWritesUnit)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"     NAND Writes : %d GB (?)\\r\\n\"), m_Ata.vars[i].NandWrites);\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"     NAND Writes : %d GB\\r\\n\"), m_Ata.vars[i].NandWrites);\n\t\t\t}\n\t\t\t*/\n\t\t\tcstr.Format(_T(\"     NAND Writes : %d GB\\r\\n\"), m_Ata.vars[i].NandWrites);\n\t\t\tdrive.Replace(_T(\"%NAND_WRITES%\"), cstr);\n\t\t}\n\n\t\tif(m_Ata.vars[i].GBytesErased == -1)\n\t\t{\n\t\t\tdrive.Replace(_T(\"%GBYTES_ERASED%\"), _T(\"\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"   GBytes Erased : %d GB\\r\\n\"), m_Ata.vars[i].GBytesErased);\t\n\t\t\tdrive.Replace(_T(\"%GBYTES_ERASED%\"), cstr);\n\t\t}\n\n\t\tif(m_Ata.vars[i].WearLevelingCount == -1)\n\t\t{\n\t\t\tdrive.Replace(_T(\"%WEAR_LEVELING_COUNT%\"), _T(\"\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"Wear Level Count : %d\\r\\n\"), m_Ata.vars[i].WearLevelingCount);\t\t\n\t\t\tdrive.Replace(_T(\"%WEAR_LEVELING_COUNT%\"), cstr);\n\t\t}\n\n\t\tif(m_Ata.vars[i].Temperature > -300)\n\t\t{\n\t\t\tcstr.Format(_T(\"%d C (%d F)\"), m_Ata.vars[i].Temperature, m_Ata.vars[i].Temperature * 9 / 5 + 32);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr = i18n(_T(\"Dialog\"), _T(\"UNKNOWN\"));\n\t\t}\n\t\tdrive.Replace(_T(\"%TEMPERATURE%\"), cstr);\n\n\t\tif (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_NVME || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_AMD_RC2 \n\t\t|| m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS56X || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMB39X\n\t\t|| m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS586_20 || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS586_40\n\t\t)\n\t\t{\n\t\t\tcstr.Format(_T(\"%.1f GB\"), m_Ata.vars[i].TotalDiskSize / 1000.0);\n\t\t}\n\t\telse if (m_Ata.vars[i].DiskSizeWmi > 0)\n\t\t{\n\t\t\tif(m_Ata.vars[i].TotalDiskSize < 1000)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%d MB (%.2f/----/----/%.2f)\"),\n\t\t\t\t\tm_Ata.vars[i].TotalDiskSize,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeChs / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeWmi / 1000.0);\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].IsLba48Supported)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%.1f GB (%.1f/%.1f/%.1f/%.1f)\"),\n\t\t\t\t\tm_Ata.vars[i].TotalDiskSize / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeChs / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeLba28 / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeLba48 / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeWmi / 1000.0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%.1f GB (%.1f/%.1f/----/%.1f)\"),\n\t\t\t\t\tm_Ata.vars[i].TotalDiskSize / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeChs / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeLba28 / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeWmi / 1000.0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(m_Ata.vars[i].TotalDiskSize < 1000)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%d MB (%.2f/----/----/----)\"),\n\t\t\t\t\tm_Ata.vars[i].TotalDiskSize,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeChs / 1000.0);\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].IsLba48Supported)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%.1f GB (%.1f/%.1f/%.1f/----)\"),\n\t\t\t\t\tm_Ata.vars[i].TotalDiskSize / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeChs / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeLba28 / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeLba48 / 1000.0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%.1f GB (%.1f/%.1f/----/----)\"),\n\t\t\t\t\tm_Ata.vars[i].TotalDiskSize / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeChs / 1000.0,\n\t\t\t\t\tm_Ata.vars[i].DiskSizeLba28 / 1000.0);\n\t\t\t}\n\t\t}\n\t\tdrive.Replace(_T(\"%TOTAL_DISK_SIZE%\"), cstr);\n\n\n\t\tif(m_Ata.vars[i].IsSsd && m_Ata.vars[i].BufferSize == 0xFFFF * 512)\n\t\t{\n\t\t\tcstr.Format(_T(\">= %d KB\"), m_Ata.vars[i].BufferSize / 1024);\n\t\t}\n\t\telse if(m_Ata.vars[i].BufferSize > 0)\n\t\t{\n\t\t\tcstr.Format(_T(\"%d KB\"), m_Ata.vars[i].BufferSize / 1024);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr = i18n(_T(\"Dialog\"), _T(\"UNKNOWN\"));\n\t\t}\n\t\tdrive.Replace(_T(\"%BUFFER_SIZE%\"), cstr);\n\n\n\t\tif (m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_AMD_RC2 || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS56X \n\t\t|| m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMB39X || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS586_20 || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS586_40)\n\t\t{\n\t\t\tcstr.Format(_T(\"     Queue Depth : %s\\r\\n\"), i18n(_T(\"Dialog\"), _T(\"UNKNOWN\")).GetString());\n\t\t}\n\t\telse if(0 <= m_Ata.vars[i].IdentifyDevice.A.QueueDepth && m_Ata.vars[i].IdentifyDevice.A.QueueDepth < 32)\n\t\t{\n\t\t\tcstr.Format(_T(\"     Queue Depth : %d\\r\\n\"), m_Ata.vars[i].IdentifyDevice.A.QueueDepth + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"     Queue Depth : 1\\n\"));\n\t\t}\n\t\tdrive.Replace(_T(\"%QUEUE_DEPTH%\"), cstr);\n\n\t\tif (m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_AMD_RC2 || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS56X\n\t\t|| m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMB39X || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS586_20 || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS586_40)\n\t\t{\n\t\t\tcstr = i18n(_T(\"Dialog\"), _T(\"UNKNOWN\"));\n\t\t}\n\t\telse if(m_Ata.vars[i].NominalMediaRotationRate == 1)\n\t\t{\n\t\t\tcstr = _T(\"---- (SSD)\");\n\t\t}\n\t\telse if(m_Ata.vars[i].NominalMediaRotationRate > 0)\n\t\t{\n\t\t\tcstr.Format(_T(\"%d RPM\"), m_Ata.vars[i].NominalMediaRotationRate);\n\t\t}\t\t\n\t\telse\n\t\t{\n\t\t\tcstr = i18n(_T(\"Dialog\"), _T(\"UNKNOWN\"));\n\t\t}\n\t\tdrive.Replace(_T(\"%ROTATION_RATE%\"), cstr);\n\n\t\tfeature = _T(\"\");\n\t\tif(m_Ata.vars[i].IsSmartSupported)\n\t\t{\n\t\t\tfeature += _T(\"S.M.A.R.T., \");\n\t\t}\n\t\tif(m_Ata.vars[i].IsApmSupported)\n\t\t{\n\t\t\tfeature += _T(\"APM, \");\n\t\t}\n\t\tif(m_Ata.vars[i].IsAamSupported)\n\t\t{\n\t\t\tfeature += _T(\"AAM, \");\n\t\t}\n\t\tif(m_Ata.vars[i].IsNcqSupported)\n\t\t{\n\t\t\tfeature += _T(\"NCQ, \");\n\t\t}\n\t\tif(m_Ata.vars[i].IsTrimSupported)\n\t\t{\n\t\t\tfeature += _T(\"TRIM, \");\n\t\t}\n\t\tif(m_Ata.vars[i].IsDeviceSleepSupported)\n\t\t{\n\t\t\tfeature += _T(\"DevSleep, \");\n\t\t}\n\t\tif (m_Ata.vars[i].IsStreamingSupported)\n\t\t{\n\t\t\tfeature += _T(\"Streaming, \");\n\t\t}\n\t\tif (m_Ata.vars[i].IsGplSupported)\n\t\t{\n\t\t\tfeature += _T(\"GPL, \");\n\t\t}\n\t\tif (m_Ata.vars[i].IsVolatileWriteCachePresent)\n\t\t{\n\t\t\tfeature += _T(\"VolatileWriteCache, \");\n\t\t}\n\n\t\t/*\n\t\tif(m_Ata.vars[i].IsNvCacheSupported)\n\t\t{\n\t\t\tfeature += _T(\"NV Cache, \");\n\t\t}\n\n\t\tif(m_Ata.vars[i].IsSsd)\n\t\t{\n\t\t\tfeature += _T(\"SSD, \");\n\t\t}\n\t\t*/\n\t\t\n\t\tif(! feature.IsEmpty())\n\t\t{\n\t\t\tfeature.Delete(feature.GetLength() - 2, 2);\n\t\t}\n\n\t\tif (m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_AMD_RC2 || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS56X\n\t\t|| m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMB39X || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS586_20 || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS586_40)\n\t\t{\n\t\t\tfeature = i18n(_T(\"Dialog\"), _T(\"UNKNOWN\"));\n\t\t}\n\n\t\tdrive.Replace(_T(\"%SUPPORTED_FEATURE%\"), feature);\n\n\t\tif(m_Ata.vars[i].IsAamSupported)\n\t\t{\n\t\t\tcstr.Format(_T(\"%04Xh\"), m_Ata.vars[i].IdentifyDevice.A.AcoustricManagement);\n\t\t\tif(m_Ata.vars[i].IsAamEnabled)\n\t\t\t{\n\t\t\t\tcstr += _T(\" [ON]\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr += _T(\" [OFF]\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr = _T(\"----\");\n\t\t}\n\t\tdrive.Replace(_T(\"%AAM_LEVEL%\"), cstr);\n\n\t\tif(m_Ata.vars[i].IsApmSupported)\n\t\t{\n\t\t\tcstr.Format(_T(\"%04Xh\"), m_Ata.vars[i].IdentifyDevice.A.CurrentPowerManagement);\n\t\t\tif(m_Ata.vars[i].IsApmEnabled)\n\t\t\t{\n\t\t\t\tcstr += _T(\" [ON]\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr += _T(\" [OFF]\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr = _T(\"----\");\n\t\t}\n\t\tdrive.Replace(_T(\"%APM_LEVEL%\"), cstr);\n\n\n\t\tdrive.Replace(_T(\"%DRIVE_LETTER%\"), m_Ata.vars[i].DriveMap);\n\n\n\t\tclip += drive;\n\n\t\tCString vendorSpecific;\n\t\tvendorSpecific = i18n(_T(\"Smart\"), _T(\"VENDOR_SPECIFIC\"), m_bSmartEnglish);\n\n\t\tif(m_Ata.vars[i].AttributeCount > 0)\n\t\t{\n\t\t\tcstr.Format(_T(\"-- S.M.A.R.T. --------------------------------------------------------------\\r\\n\"));\n\t\t\tline = cstr;\n\t\t\t\n\t\t\tif(m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_NVME)\n\t\t\t{\n\t\t\t\tline += _T(\"ID RawValues(6) Attribute Name\\r\\n\");\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].IsRawValues8)\n\t\t\t{\n\t\t\t\tline += _T(\"ID Raw Values (8)   Attribute Name\\r\\n\");\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].IsRawValues7)\n\t\t\t{\n\t\t\t\tline += _T(\"ID Cur Wor Thr Raw Values (7) Attribute Name\\r\\n\");\n\t\t\t}\t\t\t\n\t\t\telse\n\t\t\t{\n\t\t\t\tline += _T(\"ID Cur Wor Thr RawValues(6) Attribute Name\\r\\n\");\n\t\t\t}\n\n\t\t\tfor(DWORD j = 0; j < m_Ata.vars[i].AttributeCount; j++)\n\t\t\t{\n\t\t\t\tTCHAR str[256];\n\t\t\t\tif (m_Ata.vars[i].Attribute[j].Id == 0)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcstr.Format(_T(\"%02X\"), m_Ata.vars[i].Attribute[j].Id);\n\n\t\t\t\tif (m_bSmartEnglish)\n\t\t\t\t{\n\t\t\t\t\tGetPrivateProfileStringFx(m_Ata.vars[i].SmartKeyName, cstr, vendorSpecific, str, 256, m_DefaultLangPath);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tGetPrivateProfileStringFx(m_Ata.vars[i].SmartKeyName, cstr, L\"\", str, 256, m_DefaultLangPath);\n\t\t\t\t\tCString en = str;\n\t\t\t\t\tif (en.IsEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tGetPrivateProfileStringFx(m_Ata.vars[i].SmartKeyName, cstr, vendorSpecific, str, 256, m_CurrentLangPath);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tGetPrivateProfileStringFx(m_Ata.vars[i].SmartKeyName, cstr, en, str, 256, m_CurrentLangPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_NVME)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"%02X %02X%02X%02X%02X%02X%02X %s\\r\\n\"),\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].Id,\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0],\n\t\t\t\t\t\tstr\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if(m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDFORCE)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"%02X %s %s %s %02X%02X%02X%02X%02X%02X%02X %s\\r\\n\"),\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].Id,\n\t\t\t\t\t\t__Number(m_Ata.vars[i].Attribute[j].CurrentValue).GetString(),\n\t\t\t\t\t\t__Number(m_Ata.vars[i].Attribute[j].WorstValue).GetString(),\n\t\t\t\t\t\t__Number(m_Ata.vars[i].Threshold[j].ThresholdValue).GetString(),\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].Reserved,\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0],\n\t\t\t\t\t\tstr\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// For JMicron 60x\n\t\t\t\telse if(m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_JMICRON && m_Ata.vars[i].IsRawValues8)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"%02X %s %02X%02X%02X%02X%02X%02X%02X%02X %s\\r\\n\"),\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].Id,\n\t\t\t\t\t\t__Number(m_Ata.vars[i].Attribute[j].CurrentValue).GetString(),\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].Reserved,\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].WorstValue,\n\t\t\t\t\t\tstr\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if(m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_INDILINX)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"%02X %02X%02X%02X%02X%02X%02X%02X%02X %s\\r\\n\"),\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].Id,\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0],\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].WorstValue,\n\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].CurrentValue,\n\t\t\t\t\t\tstr\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(m_Ata.vars[i].IsThresholdCorrect)\n\t\t\t\t\t{\n\t\t\t\t\t\tcstr.Format(_T(\"%02X %s %s %s %02X%02X%02X%02X%02X%02X %s\\r\\n\"),\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].Id,\n\t\t\t\t\t\t\t__Number(m_Ata.vars[i].Attribute[j].CurrentValue).GetString(),\n\t\t\t\t\t\t\t__Number(m_Ata.vars[i].Attribute[j].WorstValue).GetString(),\n\t\t\t\t\t\t\t__Number(m_Ata.vars[i].Threshold[j].ThresholdValue).GetString(),\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0],\n\t\t\t\t\t\t\tstr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcstr.Format(_T(\"%02X %s %s --- %02X%02X%02X%02X%02X%02X %s\\r\\n\"),\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].Id,\n\t\t\t\t\t\t\t__Number(m_Ata.vars[i].Attribute[j].CurrentValue).GetString(),\n\t\t\t\t\t\t\t__Number(m_Ata.vars[i].Attribute[j].WorstValue).GetString(),\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0],\n\t\t\t\t\t\t\tstr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tline += cstr;\n\t\t\t}\n\t\t\tclip += line;\n\t\t\tclip += _T(\"\\r\\n\");\n\t\t}\n\n\t\tWORD data[256];\n\t\tif(m_bDumpIdentifyDevice)\n\t\t{\n\t\t\tmemcpy(data, &(m_Ata.vars[i].IdentifyDevice), 512);\n\t\t\tif(m_bHideSerialNumber)\n\t\t\t{\n\t\t\t\tif (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_NVME)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 2; j <= 11; j++) // Serial Number : WORD[2-11]\n\t\t\t\t\t{\n\t\t\t\t\t\tdata[j] = 0xFFFF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 10; j <= 19; j++) // Serial Number : WORD[10-19]\n\t\t\t\t\t{\n\t\t\t\t\t\tdata[j] = 0xFFFF;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tcstr.Format(_T(\"-- IDENTIFY_DEVICE ---------------------------------------------------------\\r\\n\"));\n\t\t\tline = cstr;\n\n\t\t\tline += _T(\"        0    1    2    3    4    5    6    7    8    9\\r\\n\");\n\t\t\tfor(int k = 0; k < 25; k++)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%03d: %04X %04X %04X %04X %04X %04X %04X %04X %04X %04X\"),\n\t\t\t\t\t\t\t\tk * 10,\n\t\t\t\t\t\t\t\tdata[10 * k + 0], data[10 * k + 1], data[10 * k + 2], data[10 * k + 3], data[10 * k + 4],\n\t\t\t\t\t\t\t\tdata[10 * k + 5], data[10 * k + 6], data[10 * k + 7], data[10 * k + 8], data[10 * k + 9]);\n\t\t\t\tline += cstr;\n\t\t\t\tif(m_bAsciiView)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"  %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\"),\n\t\t\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[10 * k + 0])), AsciiFilter(LOBYTE(data[10 * k + 0])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[10 * k + 1])), AsciiFilter(LOBYTE(data[10 * k + 1])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[10 * k + 2])), AsciiFilter(LOBYTE(data[10 * k + 2])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[10 * k + 3])), AsciiFilter(LOBYTE(data[10 * k + 3])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[10 * k + 4])), AsciiFilter(LOBYTE(data[10 * k + 4])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[10 * k + 5])), AsciiFilter(LOBYTE(data[10 * k + 5])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[10 * k + 6])), AsciiFilter(LOBYTE(data[10 * k + 6])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[10 * k + 7])), AsciiFilter(LOBYTE(data[10 * k + 7])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[10 * k + 8])), AsciiFilter(LOBYTE(data[10 * k + 8])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[10 * k + 9])), AsciiFilter(LOBYTE(data[10 * k + 9])));\n\t\t\t\t\tline += cstr;\t\n\t\t\t\t}\n\t\t\t\tline += _T(\"\\r\\n\");\n\t\t\t}\n\t\t\t\t\n\t\t\tcstr.Format(_T(\"%03d: %04X %04X %04X %04X %04X %04X\"),\n\t\t\t\t\t\t\t\t250,\n\t\t\t\t\t\t\t\tdata[250], data[251], data[252], data[253], data[254], data[255]);\n\t\t\tline += cstr;\n\t\t\tif(m_bAsciiView)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"                      %c%c%c%c%c%c%c%c%c%c%c%c\"),\n\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[250])), AsciiFilter(LOBYTE(data[250])),\n\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[251])), AsciiFilter(LOBYTE(data[251])),\n\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[252])), AsciiFilter(LOBYTE(data[252])),\n\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[253])), AsciiFilter(LOBYTE(data[253])),\n\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[254])), AsciiFilter(LOBYTE(data[254])),\n\t\t\t\t\t\t\tAsciiFilter(HIBYTE(data[255])), AsciiFilter(LOBYTE(data[255])));\n\t\t\t\tline += cstr;\n\t\t\t}\n\t\t\tline += _T(\"\\r\\n\");\n\n\n\t\t\tclip += line;\n\t\t\tclip += _T(\"\\r\\n\");\n\t\t}\n\n\t\tif(m_bDumpSmartReadData)\n\t\t{\n\t\t\tmemcpy(data, &(m_Ata.vars[i].SmartReadData), 512);\n\t\t\tif (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_NVME)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"-- SMART_NVME --------------------------------------------------------------\\r\\n\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"-- SMART_READ_DATA ---------------------------------------------------------\\r\\n\"));\n\t\t\t}\n\n\t\t\tline = cstr;\n\t\t\tline += _T(\"     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F\\r\\n\");\n\t\t\tfor(int k = 0; k < 32; k++)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%03X: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X\"),\n\t\t\t\t\t\t\t\tk * 16,\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 0]), HIBYTE(data[8 * k + 0]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 1]), HIBYTE(data[8 * k + 1]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 2]), HIBYTE(data[8 * k + 2]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 3]), HIBYTE(data[8 * k + 3]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 4]), HIBYTE(data[8 * k + 4]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 5]), HIBYTE(data[8 * k + 5]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 6]), HIBYTE(data[8 * k + 6]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 7]), HIBYTE(data[8 * k + 7]));\n\t\t\t\tline += cstr;\n\t\t\t\tif(m_bAsciiView)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"  %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\\r\\n\"),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 0])), AsciiFilter(HIBYTE(data[8 * k + 0])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 1])), AsciiFilter(HIBYTE(data[8 * k + 1])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 2])), AsciiFilter(HIBYTE(data[8 * k + 2])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 3])), AsciiFilter(HIBYTE(data[8 * k + 3])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 4])), AsciiFilter(HIBYTE(data[8 * k + 4])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 5])), AsciiFilter(HIBYTE(data[8 * k + 5])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 6])), AsciiFilter(HIBYTE(data[8 * k + 6])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 7])), AsciiFilter(HIBYTE(data[8 * k + 7])));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcstr = _T(\"\\r\\n\");\n\t\t\t\t}\n\t\t\t\tline += cstr;\n\t\t\t}\n\t\t\tclip += line;\n\t\t\tclip += _T(\"\\r\\n\");\n\t\t}\n\n\t\tif(m_bDumpSmartReadThreshold && (m_Ata.vars[i].DiskVendorId != m_Ata.SSD_VENDOR_NVME))\n\t\t{\n\t\t\tmemcpy(data, &(m_Ata.vars[i].SmartReadThreshold), 512);\n\t\t\tcstr.Format(_T(\"-- SMART_READ_THRESHOLD ----------------------------------------------------\\r\\n\"));\n\t\t\tline = cstr;\n\t\t\tline += _T(\"     +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F\\r\\n\");\n\t\t\tfor(int k = 0; k < 32; k++)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%03X: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X\"),\n\t\t\t\t\t\t\t\tk * 16,\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 0]), HIBYTE(data[8 * k + 0]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 1]), HIBYTE(data[8 * k + 1]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 2]), HIBYTE(data[8 * k + 2]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 3]), HIBYTE(data[8 * k + 3]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 4]), HIBYTE(data[8 * k + 4]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 5]), HIBYTE(data[8 * k + 5]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 6]), HIBYTE(data[8 * k + 6]),\n\t\t\t\t\t\t\t\tLOBYTE(data[8 * k + 7]), HIBYTE(data[8 * k + 7]));\n\t\t\t\tline += cstr;\n\t\t\t\tif(m_bAsciiView)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"  %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\\r\\n\"),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 0])), AsciiFilter(HIBYTE(data[8 * k + 0])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 1])), AsciiFilter(HIBYTE(data[8 * k + 1])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 2])), AsciiFilter(HIBYTE(data[8 * k + 2])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 3])), AsciiFilter(HIBYTE(data[8 * k + 3])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 4])), AsciiFilter(HIBYTE(data[8 * k + 4])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 5])), AsciiFilter(HIBYTE(data[8 * k + 5])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 6])), AsciiFilter(HIBYTE(data[8 * k + 6])),\n\t\t\t\t\t\t\t\t\tAsciiFilter(LOBYTE(data[8 * k + 7])), AsciiFilter(HIBYTE(data[8 * k + 7])));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcstr = _T(\"\\r\\n\");\n\t\t\t\t}\n\t\t\t\tline += cstr;\n\t\t\t}\n\t\t\tclip += line;\n\t\t\tclip += _T(\"\\r\\n\");\n\t\t}\n\t}\n\n\tif (fileName.IsEmpty())\n\t{\n\t\tif (OpenClipboard())\n\t\t{\n\t\t\tHGLOBAL clipbuffer;\n\t\t\tTCHAR* buffer;\n\t\t\tEmptyClipboard();\n\t\t\tclipbuffer = GlobalAlloc(GMEM_DDESHARE, sizeof(TCHAR) * ((size_t)clip.GetLength() + 1));\n\t\t\tif (clipbuffer) {\n\t\t\t\tbuffer = (TCHAR*)GlobalLock(clipbuffer);\n\t\t\t\tif (buffer) {\n\t\t\t\t\t_tcscpy_s(buffer, (size_t)clip.GetLength() + 1, LPCTSTR(clip));\n\t\t\t\t\tGlobalUnlock(clipbuffer);\n#ifdef _UNICODE\n\t\t\t\t\tSetClipboardData(CF_UNICODETEXT, clipbuffer);\n#else\n\t\t\t\t\tSetClipboardData(CF_OEMTEXT, clipbuffer);\n#endif\n\t\t\t\t\tCloseClipboard();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tCT2A utf8(clip, CP_UTF8);\n\n\t\tCFile file;\n\t\tif (file.Open(fileName, CFile::modeCreate | CFile::modeWrite))\n\t\t{\n\t\t\tfile.Write((char*)utf8, (UINT)strlen(utf8));\n\t\t\tfile.Close();\n\t\t}\n\t}\n}\n\nvoid CDiskInfoDlg::OnCopy()\n{\n\tSaveText(_T(\"\"));\n}"
        },
        {
          "name": "DiskInfoDlgInit.cpp",
          "type": "blob",
          "size": 28.9248046875,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n#include \"UtilityFx.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\ntypedef BOOL(WINAPI *FuncEnableNonClientDpiScaling) (HWND hWnd);\n\nextern const GUID StrageGUID;\n\nint CALLBACK EnumFontFamExProcDefaultFont(ENUMLOGFONTEX *lpelfe, NEWTEXTMETRICEX *lpntme, int FontType, LPARAM lParam)\n{\n\tif(_tcscmp(lpelfe->elfLogFont.lfFaceName, DEFAULT_FONT_FACE_1) == 0)\n\t{\n\t\t*((BOOL*)lParam) = TRUE;\n\t}\n    return TRUE;\n}\n\nBOOL CDiskInfoDlg::OnInitDialog()\n{\n\t//BOOL result = FALSE;\n\n\tCMainDialogFx::OnInitDialog();\n\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIconMini, FALSE);\t// Set small icon\n\n\tInitThemeLang();\n\tInitMenu();\n//\tChangeTheme(m_CurrentTheme);\n\tUpdateThemeInfo();\n//\tChangeLang(m_CurrentLang);\n\n\tTCHAR str[256];\n\t\n\tCClientDC dc(this);\n    LOGFONT logfont;\n\tCString defaultFontFace;\n\tBOOL hasDefaultFont = FALSE;\n    ZeroMemory(&logfont, sizeof(LOGFONT)); \n    logfont.lfCharSet = DEFAULT_CHARSET;\n    ::EnumFontFamiliesExW(dc.m_hDC, &logfont, (FONTENUMPROC)EnumFontFamExProcDefaultFont, (INT_PTR)(&hasDefaultFont), 0);\n\t\n\tif(hasDefaultFont)\n\t{\n\t\tdefaultFontFace = DEFAULT_FONT_FACE_1;\n\t}\n\telse\n\t{\n\t\tdefaultFontFace = DEFAULT_FONT_FACE_2;\n\t}\n\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"FontFace\"), defaultFontFace, str, 256, m_Ini);\n\tm_FontFace = str;\n\tm_FontScale = GetPrivateProfileInt(L\"Setting\", L\"FontScale\", 100, m_Ini);\n\tif (m_FontScale > 150 || m_FontScale < 50)\n\t{\n\t\tm_FontScale = 100;\n\t\tm_FontRatio = 1.0;\n\t}\n\telse\n\t{\n\t\tm_FontRatio = m_FontScale / 100.0;\n\t}\n\n\tm_FontRender = (BYTE)GetPrivateProfileInt(L\"Setting\", L\"FontRender\", CLEARTYPE_NATURAL_QUALITY, m_Ini);\n\tif (m_FontRender > CLEARTYPE_NATURAL_QUALITY)\n\t{\n\t\tm_FontRender = CLEARTYPE_NATURAL_QUALITY;\n\t}\n\n\tswitch(GetPrivateProfileInt(_T(\"Setting\"), _T(\"AutoRefresh\"), 10, m_Ini))\n\t{\n\tcase  1: OnAutoRefresh01Min(); break;\n\tcase  3: OnAutoRefresh03Min(); break;\n\tcase  5: OnAutoRefresh05Min(); break;\n\tcase 10: OnAutoRefresh10Min(); break;\n\tcase 30: OnAutoRefresh30Min(); break;\n\tcase 60: OnAutoRefresh60Min(); break;\n\tcase 120:OnAutoRefresh120Min(); break;\n\tcase 180:OnAutoRefresh180Min(); break;\n\tcase 360:OnAutoRefresh360Min(); break;\n\tcase 720:OnAutoRefresh720Min(); break;\n\tcase 1440:OnAutoRefresh1440Min(); break;\n\tdefault: OnAutoRefreshDisable(); break;\n\t}\n\n\tswitch(GetPrivateProfileInt(_T(\"Setting\"), _T(\"StartupWaitTime\"), 30, m_Ini))\n\t{\n\tcase   0: OnWait0Sec();   break;\n\tcase   5: OnWait5Sec();   break;\n\tcase  10: OnWait10Sec();  break;\n\tcase  15: OnWait15Sec();  break;\n\tcase  20: OnWait20Sec();  break;\n\tcase  30: OnWait30Sec();  break;\n\tcase  40: OnWait40Sec();  break;\n\tcase  50: OnWait50Sec();  break;\n\tcase  60: OnWait60Sec();  break;\n\tcase  90: OnWait90Sec();  break;\n\tcase 120: OnWait120Sec(); break;\n\tcase 150: OnWait150Sec(); break;\n\tcase 180: OnWait180Sec(); break;\n\tcase 210: OnWait210Sec(); break;\n\tcase 240: OnWait240Sec(); break;\n\tdefault:  OnWait0Sec();   break;\n\t}\n\n\tswitch(GetPrivateProfileInt(_T(\"Setting\"), _T(\"ZoomType\"), 0, m_Ini))\n\t{\n\tcase 100:  CheckRadioZoomType(ID_ZOOM_100, 100); break;\n\tcase 125:  CheckRadioZoomType(ID_ZOOM_125, 125); break;\n\tcase 150:  CheckRadioZoomType(ID_ZOOM_150, 150); break;\n\tcase 200:  CheckRadioZoomType(ID_ZOOM_200, 200); break;\n\tcase 250:  CheckRadioZoomType(ID_ZOOM_250, 250); break;\n\tcase 300:  CheckRadioZoomType(ID_ZOOM_300, 300); break;\n\tdefault:   CheckRadioZoomType(ID_ZOOM_AUTO, 0); break;\n\t}\n\n\tswitch(GetPrivateProfileInt(_T(\"Setting\"), _T(\"Temperature\"), 0, m_Ini))\n\t{\n\tcase   1:\tOnFahrenheit(); break;\n\tdefault:\tOnCelsius();\tbreak;\n\t}\n\n\tswitch(GetPrivateProfileInt(_T(\"Setting\"), _T(\"ResidentMinimize\"), 0, m_Ini))\n\t{\n\tcase   1:\tOnResidentMinimize(); break;\n\tdefault:\tOnResidentHide();\t  break;\n\t}\n\n\tswitch (GetPrivateProfileInt(_T(\"Setting\"), _T(\"SortDriveLetter\"), 1, m_Ini))\n\t{\n\tcase   1:\tOnSortDriveLetter();\t break;\n\tdefault:\tOnSortPhysicalDriveId(); break;\n\t}\n\n\tswitch (GetPrivateProfileInt(_T(\"Setting\"), _T(\"DriveMenu\"), 8, m_Ini))\n\t{\n\tcase   16:\tOnDriveMenu16();\tbreak;\n#ifdef MAX_DRIVE_20\n\tcase   10:\tOnDriveMenu10();\tbreak;\n\tcase   20:\tOnDriveMenu20();\tbreak;\n#endif\n\tdefault:\tOnDriveMenu8(); \tbreak;\n\t}\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tif (m_bStartupVoice)\n\t{\n\t\tm_bStartupVoice = FALSE;\n\t\tOnStartupVoice();\n\t}\n#endif\n\n\t// USB/IEEE1394 Support\n\tm_Ata.FlagUsbSat     = ! GetPrivateProfileInt(_T(\"USB\"), _T(\"SAT\"), 1, m_Ini);\n\tm_Ata.FlagUsbIodata  = ! GetPrivateProfileInt(_T(\"USB\"), _T(\"IODATA\"), 1, m_Ini);\n\tm_Ata.FlagUsbSunplus = ! GetPrivateProfileInt(_T(\"USB\"), _T(\"Sunplus\"), 1, m_Ini);\n\tm_Ata.FlagUsbLogitec = ! GetPrivateProfileInt(_T(\"USB\"), _T(\"Logitec\"), 1, m_Ini);\n\tm_Ata.FlagUsbProlific = !GetPrivateProfileInt(_T(\"USB\"), _T(\"Prolific\"), 1, m_Ini);\n\tm_Ata.FlagUsbJmicron = ! GetPrivateProfileInt(_T(\"USB\"), _T(\"JMicron\"), 1, m_Ini);\n\tm_Ata.FlagUsbCypress = ! GetPrivateProfileInt(_T(\"USB\"), _T(\"Cypress\"), 1, m_Ini);\n\tm_Ata.FlagUsbASM1352R = !GetPrivateProfileInt(_T(\"USB\"), _T(\"ASM1352R\"), 0, m_Ini);\n\tm_Ata.FlagUsbRealtek9220DP = !GetPrivateProfileInt(_T(\"USB\"), _T(\"RTL9220DP\"), 0, m_Ini);\n\tm_Ata.FlagUsbMemory  = ! GetPrivateProfileInt(_T(\"USB\"), _T(\"UsbMemory\"), 0, m_Ini);\n//\tm_Ata.FlagUsbSat16 = !GetPrivateProfileInt(_T(\"USB\"), _T(\"UsbSAT16\"), 1, m_Ini);\n\tm_Ata.FlagUsbNVMeJMicron3 = !GetPrivateProfileInt(_T(\"USB\"), _T(\"NVMeJMicron3\"), 0, m_Ini);\n\tm_Ata.FlagUsbNVMeJMicron = !GetPrivateProfileInt(_T(\"USB\"), _T(\"NVMeJMicron\"), 1, m_Ini);\n\tm_Ata.FlagUsbNVMeASMedia = !GetPrivateProfileInt(_T(\"USB\"), _T(\"NVMeASMedia\"), 1, m_Ini);\n\tm_Ata.FlagUsbNVMeRealtek = !GetPrivateProfileInt(_T(\"USB\"), _T(\"NVMeRealtek\"), 1, m_Ini);\n\tm_Ata.FlagAMD_RC2 = !GetPrivateProfileInt(_T(\"Setting\"), _T(\"AMD_RC2\"), 1, m_Ini);\n\tm_Ata.FlagMegaRAID = !GetPrivateProfileInt(_T(\"Setting\"), _T(\"MegaRAID\"), 1, m_Ini);\n\tm_Ata.FlagIntelVROC = !GetPrivateProfileInt(_T(\"Setting\"), _T(\"IntelVROC\"), 1, m_Ini);\n\n#ifdef JMICRON_USB_RAID_SUPPORT\n\tm_Ata.FlagUsbJMS56X = !GetPrivateProfileInt(_T(\"Setting\"), _T(\"JMS56X\"), 0, m_Ini); // Default Off\n\tm_Ata.FlagUsbJMB39X = !GetPrivateProfileInt(_T(\"Setting\"), _T(\"JMB39X\"), 0, m_Ini); // Default Off\n\tm_Ata.FlagUsbJMS586_20 = !GetPrivateProfileInt(_T(\"Setting\"), _T(\"JMS586_20\"), 0, m_Ini); // Default Off\n\tm_Ata.FlagUsbJMS586_40 = !GetPrivateProfileInt(_T(\"Setting\"), _T(\"JMS586_40\"), 0, m_Ini); // Default Off\n#endif\n\n\tOnUsbSat();\n\tOnUsbIodata();\n\tOnUsbSunplus();\n\tOnUsbLogitec();\n\tOnUsbProlific();\n\tOnUsbJmicron();\n\tOnUsbCypress();\n\tOnUsbASM1352R();\n\tOnUsbRealtek9220DP();\n\tOnUsbMemory();\n//\tOnUsbSat16();\n\tOnUsbNVMeJMicron3();\n\tOnUsbNVMeJMicron();\n\tOnUsbNVMeASMedia();\n\tOnUsbNVMeRealtek();\n\tOnAMD_RC2();\n\tOnMegaRAID();\n\tOnIntelVROC();\n#ifdef JMICRON_USB_RAID_SUPPORT\n\tOnUsbJMS56X();\n\tOnUsbJMB39X();\n\tOnUsbJMS586_20();\n\tOnUsbJMS586_40();\n#endif\n\n\tDebugPrint(_T(\"InitAta\"));\n\tInitAta((BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"UseWMI\"), 1, m_Ini), m_bAdvancedDiskSearch, NULL, m_bWorkaroundHD204UI, m_bWorkaroundAdataSsd);\n\n\tif(m_bStartupExit)\n\t{\n\t\t// Added 2013/04/12 - Workaround for Exec Failed\n\t\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"ExecFailed\"), _T(\"0\"), m_Ini);\n\t\tDebugPrint(_T(\"EndDialog(0)\"));\n\t\tEndDialog(0);\n\t\treturn FALSE;\n\t}\n\n\tm_SizeX = SIZE_X;\n\tm_SizeY = SIZE_Y;\n\n\tDEV_BROADCAST_DEVICEINTERFACE filter;\n\tfilter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);\n\tfilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;\n\tfilter.dbcc_classguid = StrageGUID;\n\n\tDebugPrint(_T(\"RegisterDeviceNotification\"));\n\tm_hDevNotify = RegisterDeviceNotification(m_hWnd, &filter, DEVICE_NOTIFY_WINDOW_HANDLE);\n\n\tInitDialogComplete();\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tif (m_bStartupVoice && ! m_bStartupVoiceDisabled)\n\t{\n\t\tAlertSound(1, AS_SET_SOUND_ID);\n\t\tAlertSound(1000, AS_PLAY_SOUND);\n\t}\n#endif\n\n\tif (m_bResident)\n\t{\n\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\treturn TRUE;\n\t}\n}\n\nvoid CDiskInfoDlg::RestorePos()\n{\n\tconst int x = GetPrivateProfileInt(_T(\"Setting\"), _T(\"X\"), INT_MIN, m_Ini);\n\tconst int y = GetPrivateProfileInt(_T(\"Setting\"), _T(\"Y\"), INT_MIN, m_Ini);\n\n\tRECT rw, rc;\n\tGetWindowRect(&rw);\n\n\trc.left = x;\n\trc.top = y;\n\trc.right = x + rw.right - rw.left;\n\trc.bottom = y + rw.bottom - rw.top;\n\n\tHMONITOR hMonitor = MonitorFromRect(&rc, MONITOR_DEFAULTTONULL);\n\tif (hMonitor == nullptr)\n\t{\n\t\tDebugPrint(_T(\"CenterWindow()\"));\n\t\tCenterWindow();\n\t}\n\telse\n\t{\n\t\t// Get Taskbar Size\n\t\tAPPBARDATA\ttaskbarInfo = { 0 };\n\t\ttaskbarInfo.cbSize = sizeof(APPBARDATA);\n\t\ttaskbarInfo.hWnd = m_hWnd;\n\t\tSHAppBarMessage(ABM_GETTASKBARPOS, &taskbarInfo);\n\t\tCRect taskbarRect = taskbarInfo.rc;\n\n\t\t/// <summary>\n\t\t/// Debug Code\n\t\t/// </summary>\n\t\t/// CString cstr;\n\t\t/// cstr.Format(L\"top=%d, bottom=%d, left=%d, right=%d\", taskbarInfo.rc.top, taskbarInfo.rc.bottom, taskbarInfo.rc.left, taskbarInfo.rc.right);\n\t\t/// AfxMessageBox(cstr);\n\n\t\tif (taskbarInfo.rc.top <= 0 && taskbarInfo.rc.left <= 0) // Top Side or Left Side\n\t\t{\n\t\t\tif (taskbarRect.Height() > taskbarRect.Width()) // Left Side\n\t\t\t{\n\t\t\t\tif (x < taskbarRect.Width()) // Overlap\n\t\t\t\t{\n\t\t\t\t\tSetWindowPos(nullptr, taskbarRect.Width(), y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetWindowPos(nullptr, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\telse // Top Side\n\t\t\t{\n\t\t\t\tif (y < taskbarRect.Height()) // Overlap\n\t\t\t\t{\n\t\t\t\t\tSetWindowPos(nullptr, x, taskbarRect.Height(), 0, 0, SWP_NOSIZE | SWP_NOZORDER);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetWindowPos(nullptr, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetWindowPos(nullptr, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);\n\t\t}\t\t\n\t}\n}\n\nvoid CDiskInfoDlg::InitDialogComplete()\n{\n\tDebugPrint(_T(\"InitDialogComplete\"));\n\tstatic BOOL once = FALSE;\n\tif(! once)\n\t{\n\t\tDebugPrint(_T(\"RestorePos()\"));\n\t\tRestorePos();\n\n\t\tDebugPrint(_T(\"CheckStartup\"));\n\t\tCheckStartup();\n\t\t// CheckResident();\n\t\tDebugPrint(_T(\"CheckHideSerialNumber\"));\n\t\tCheckHideSerialNumber();\n\t//\tDebugPrint(_T(\"ChangeTheme\"));\n\t//\tChangeTheme(m_CurrentTheme);\n\n\t\tDebugPrint(_T(\"ChangeZoomType\"));\n\t\tChangeZoomType(m_ZoomType);\n\t\tDebugPrint(_T(\"UpdateDialogSize\"));\n\t\tUpdateDialogSize();\n\t\tDebugPrint(_T(\"ChangeLang\"));\n\t\tChangeLang(m_CurrentLang);\n\t\tDebugPrint(_T(\"CheckPage()\"));\n\t\tCheckPage();\n\t\t\t\n\t\tm_bShowWindow = TRUE;\n\n\t\tif(m_bResident)\n\t\t{\n\t\t\tDebugPrint(_T(\"AlarmOverheat()\"));\n\t\t\tAlarmOverheat();\n\t\t//\tCheckTrayTemperatureIcon();\n\t\t\tif(! m_bResidentMinimize)\n\t\t\t{\n\t\t\t\tm_bShowWindow = FALSE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebugPrint(_T(\"ShowWindow(SW_SHOW)\"));\n\t\t\tShowWindow(SW_SHOW);\n\t\t}\n\n\t\tif(m_NowDetectingUnitPowerOnHours != TRUE)\n\t\t{\n\t\t\tDebugPrint(_T(\"SetWindowTitle()\"));\n\t\t\tSetWindowTitle(_T(\"\"));\n\t\t}\n\n\t\tonce = TRUE;\n\t\tm_bInitializing = FALSE;\n\n\n\t\t// Added 2013/04/12 - Workaround for Exec Failed\n\t\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"ExecFailed\"), _T(\"0\"), m_Ini);\n\n\t\tif(! ((CDiskInfoApp*)AfxGetApp())->m_SaveAsText.IsEmpty())\n\t\t{\n\t\t\tSaveText(((CDiskInfoApp*)AfxGetApp())->m_SaveAsText);\n\t\t}\n\n\t\tif(((CDiskInfoApp*)AfxGetApp())->m_bCopyExit)\n\t\t{\n\t\t\tDebugPrint(_T(\"EndDialog(0)\"));\n\t\t\tEndDialog(0);\n\t\t}\n\t}\n}\n\nvoid CDiskInfoDlg::InitAta(BOOL useWmi, BOOL advancedDiskSearch, PBOOL flagChangeDisk, BOOL workaroundHD204UI, BOOL workaroundAdataSsd)\n{\n\tstatic BOOL once = FALSE;\n\n\tKillTimer(TIMER_SET_POWER_ON_UNIT);\n\tSetWindowTitle(i18n(_T(\"Message\"), _T(\"DETECT_DISK\")));\n\tm_NowDetectingUnitPowerOnHours = FALSE;\n\n\tm_Ata.Init(useWmi, advancedDiskSearch, flagChangeDisk, workaroundHD204UI, workaroundAdataSsd, m_bHideNoSmartDisk, m_bSortDriveLetter);\n\t\n\tDWORD errorCount = 0;\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tint unitType = GetPrivateProfileIntFx(_T(\"PowerOnUnit\"), m_Ata.vars[i].ModelSerial, -1, m_Ini);\n\t\tif(unitType >= 0)\n\t\t{\n\t\t\tif(m_Ata.vars[i].DetectedTimeUnitType == m_Ata.POWER_ON_MILLI_SECONDS)\n\t\t\t{\n\t\t\t\tunitType = m_Ata.POWER_ON_MILLI_SECONDS;\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].DetectedTimeUnitType == m_Ata.POWER_ON_10_MINUTES)\n\t\t\t{\n\t\t\t\tunitType = m_Ata.POWER_ON_10_MINUTES;\n\t\t\t}\n\t\t\tm_Ata.vars[i].MeasuredTimeUnitType = unitType;\n\t\t\tm_Ata.vars[i].MeasuredPowerOnHours = m_Ata.GetPowerOnHoursEx(i, unitType);\n\t\t}\n\t\telse if(m_Ata.vars[i].PowerOnRawValue > 0)\n\t\t{\n\t\t\terrorCount++;\n\t\t}\n\n\t\tm_bAutoRefreshTarget[i] = GetPrivateProfileIntFx(_T(\"AutoRefreshTarget\"), m_Ata.vars[i].ModelSerial, 1, m_Ini);\n\t\tif (m_Ata.vars[i].IsSsd)\n\t\t{\n\t\t\tm_Ata.vars[i].AlarmTemperature = GetPrivateProfileIntFx(_T(\"AlarmTemperature\"), m_Ata.vars[i].ModelSerial, 60, m_Ini);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_Ata.vars[i].AlarmTemperature = GetPrivateProfileIntFx(_T(\"AlarmTemperature\"), m_Ata.vars[i].ModelSerial, 50, m_Ini);\n\t\t}\n\t\tm_Ata.vars[i].AlarmHealthStatus = GetPrivateProfileIntFx(_T(\"AlarmHealthStatus\"), m_Ata.vars[i].ModelSerial, 1, m_Ini);\n\n\t\tm_Ata.vars[i].Threshold05     = (WORD)GetPrivateProfileIntFx(_T(\"ThreasholdOfCaution05\"), m_Ata.vars[i].ModelSerial, 1, m_Ini);\n\t\tm_Ata.vars[i].ThresholdC5     = (WORD)GetPrivateProfileIntFx(_T(\"ThreasholdOfCautionC5\"), m_Ata.vars[i].ModelSerial, 1, m_Ini);\n\t\tm_Ata.vars[i].ThresholdC6     = (WORD)GetPrivateProfileIntFx(_T(\"ThreasholdOfCautionC6\"), m_Ata.vars[i].ModelSerial, 1, m_Ini);\n\t\tm_Ata.vars[i].ThresholdFF     = (WORD)GetPrivateProfileIntFx(_T(\"ThreasholdOfCautionFF\"), m_Ata.vars[i].ModelSerial, 10, m_Ini);\n\n\t\tm_Ata.vars[i].DiskStatus = m_Ata.CheckDiskStatus(i);\n\t\tDebugPrint(_T(\"SaveSmartInfo(i)\"));\n\t\tSaveSmartInfo(i);\n\t}\n\n\tif (!once)\n\t{\n\t\tDebugPrint(_T(\"CheckResident()\"));\n\t\tCheckResident();\n\t\tonce = TRUE;\n\t}\n\n\tAlertSound(0, AS_PLAY_SOUND);\n\tif(errorCount)\n\t{\n\t\tDebugPrint(_T(\"SetTimer(TIMER_SET_POWER_ON_UNIT, 130000, 0)\"));\n\t\tSetTimer(TIMER_SET_POWER_ON_UNIT, 130000, 0);\n\t\tm_NowDetectingUnitPowerOnHours = TRUE;\n\t}\n\tSetWindowTitle(_T(\"\"));\n\n\tDebugPrint(_T(\"AutoAamApmAdaption()\"));\n\tAutoAamApmAdaption();\n\n\tDebugPrint(_T(\"UpdateShareInfo()\"));\n\tUpdateShareInfo();\n}\n\nvoid CDiskInfoDlg::InitListCtrl()\n{\n\tDWORD style = ListView_GetExtendedListViewStyle(m_List.m_hWnd);\n\tstyle |= LVS_EX_FULLROWSELECT | /*LVS_EX_GRIDLINES |*/ LVS_EX_LABELTIP ;\n\tListView_SetExtendedListViewStyle(m_List.m_hWnd, style);\n\n\tm_List.SetImageList(&m_ImageList, LVSIL_SMALL);\n}\n\nCString CDiskInfoDlg::GetDiskStatus(DWORD statusCode)\n{\n\tswitch(statusCode)\n\t{\n\tcase CAtaSmart::DISK_STATUS_GOOD:\n\t\treturn i18n(_T(\"DiskStatus\"), _T(\"GOOD\"));\n\t\tbreak;\n\tcase CAtaSmart::DISK_STATUS_CAUTION:\n\t\treturn i18n(_T(\"DiskStatus\"), _T(\"CAUTION\"));\n\t\tbreak;\n\tcase CAtaSmart::DISK_STATUS_BAD:\n\t\treturn i18n(_T(\"DiskStatus\"), _T(\"BAD\"));\n\t\tbreak;\n\tcase CAtaSmart::DISK_STATUS_UNKNOWN:\n\tdefault:\n\t\treturn i18n(_T(\"DiskStatus\"), _T(\"UNKNOWN\"));\n\t\tbreak;\n\t}\n}\n\nCString CDiskInfoDlg::GetDiskStatusClass(DWORD statusCode)\n{\n\tswitch(statusCode)\n\t{\n\tcase CAtaSmart::DISK_STATUS_GOOD:\n\t\tif (m_bGreenMode)\n\t\t{\n\t\t\treturn _T(\"diskStatusGoodGreen\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn _T(\"diskStatusGood\");\n\t\t}\t\t\n\t\tbreak;\n\tcase CAtaSmart::DISK_STATUS_CAUTION:\n\t\treturn _T(\"diskStatusCaution\");\n\t\tbreak;\n\tcase CAtaSmart::DISK_STATUS_BAD:\n\t\treturn _T(\"diskStatusBad\");\n\t\tbreak;\n\tcase CAtaSmart::DISK_STATUS_UNKNOWN:\n\tdefault:\n\t\treturn _T(\"diskStatusUnknown\");\n\t\tbreak;\n\t}\n}\n\nCString CDiskInfoDlg::GetTemperatureClass(INT temperature, INT alarmTemperature)\n{\n\tif(temperature >= alarmTemperature)\n\t{\n\t\treturn _T(\"temperatureBad\");\n\t}/*\n\telse if(temperature == alarmTemperature)\n\t{\n\t\treturn _T(\"temperatureCaution\");\n\t}*/\n\telse if(temperature == -1000)\n\t{\n\t\treturn _T(\"temperatureUnknown\");\n\t}\n\telse\n\t{\n\t\tif (m_bGreenMode)\n\t\t{\n\t\t\treturn _T(\"temperatureGoodGreen\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn _T(\"temperatureGood\");\n\t\t}\n\t}\n}\n\nCString CDiskInfoDlg::GetDiskStatusReason(DWORD index)\n{\n\tCString result, cstr;\n\tDWORD value = 0;\n\n\tif (m_Ata.vars[index].IsNVMe)\n\t{\n\t\tBYTE cw = m_Ata.vars[index].SmartReadData[0];\n\t\tif (cw & 0x01) { result += L\"NG: Available spare capacity has fallen below the threshold.\\r\\n\"; };\n\t\tif (cw & 0x02) { result += L\"NG: Temperature error (Overheat or Overcool)\\r\\n\"; };\n\t\tif (cw & 0x04) { result += L\"NG: NVM subsystem reliability has been degraded.\\r\\n\"; };\n\t\tif (cw & 0x08) { result += L\"NG: Media has been placed in Read Only Mode.\\r\\n\"; };\n\t\tif (cw & 0x10) { result += L\"NG: Volatile memory backup device has Failed.\\r\\n\"; };\n\t\tif (cw & 0x20) { result += L\"NG: Persistent memory region has become Read-Only.\\r\\n\"; };\n\n\t\tresult.TrimRight();\n\t\treturn result;\n\t}\n\t\n\tif(m_Ata.vars[index].DiskStatus == CAtaSmart::DISK_STATUS_BAD)\n\t{\n\t\tif(m_Ata.vars[index].IsSsd && m_Ata.vars[index].IsRawValues8)\n\t\t{\n\t\t}\n\t\telse if(m_Ata.vars[index].IsSsd)\n\t\t{\n\t\t\tfor(DWORD j = 0; j < m_Ata.vars[index].AttributeCount; j++)\n\t\t\t{\n\t\t\t\tif( m_Ata.vars[index].Threshold[j].ThresholdValue != 0\n\t\t\t\t&& \tm_Ata.vars[index].Attribute[j].CurrentValue < m_Ata.vars[index].Threshold[j].ThresholdValue)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"%02X\"), m_Ata.vars[index].Attribute[j].Id);\n\t\t\t\t\tresult += i18n(_T(\"DiskStatus\"), _T(\"BAD\")) + _T(\" (\") + cstr + _T(\") \")+ i18n(m_Ata.vars[index].SmartKeyName, cstr);\n\t\t\t\t\tcstr.Format(_T(\"\\n\"));\n\t\t\t\t\tresult += cstr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(DWORD j = 0; j < m_Ata.vars[index].AttributeCount; j++)\n\t\t\t{\n\t\t\t\tif(((0x01 <= m_Ata.vars[index].Attribute[j].Id && m_Ata.vars[index].Attribute[j].Id <= 0x0D)\n//\t\t\t\t||\tm_Ata.vars[index].Attribute[j].Id == 0xB8\n\t\t\t\t||\t(0xBB <= m_Ata.vars[index].Attribute[j].Id && m_Ata.vars[index].Attribute[j].Id <= 0xC1)\n\t\t\t\t||\t(0xC3 <= m_Ata.vars[index].Attribute[j].Id && m_Ata.vars[index].Attribute[j].Id <= 0xD1)\n\t\t\t\t||\t(0xD3 <= m_Ata.vars[index].Attribute[j].Id && m_Ata.vars[index].Attribute[j].Id <= 0xD4)\n\t\t\t\t||\t(0xDC <= m_Ata.vars[index].Attribute[j].Id && m_Ata.vars[index].Attribute[j].Id <= 0xE4)\n\t\t\t\t||\t(0xE6 <= m_Ata.vars[index].Attribute[j].Id && m_Ata.vars[index].Attribute[j].Id <= 0xE7)\n\t\t\t\t||\tm_Ata.vars[index].Attribute[j].Id == 0xF0\n\t\t\t\t||\tm_Ata.vars[index].Attribute[j].Id == 0xFA\n\t\t\t\t||\tm_Ata.vars[index].Attribute[j].Id == 0xFE\n\t\t\t\t)\n\t\t\t\t&&\tm_Ata.vars[index].Threshold[j].ThresholdValue != 0\n\t\t\t\t&& \tm_Ata.vars[index].Attribute[j].CurrentValue < m_Ata.vars[index].Threshold[j].ThresholdValue)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"%02X\"), m_Ata.vars[index].Attribute[j].Id);\n\t\t\t\t\tresult += i18n(_T(\"DiskStatus\"), _T(\"BAD\")) + _T(\" (\") + cstr + _T(\") \")+ i18n(m_Ata.vars[index].SmartKeyName, cstr);\n\t\t\t\t\tcstr.Format(_T(\"\\n\"));\n\t\t\t\t\tresult += cstr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(m_Ata.vars[index].DiskStatus == CAtaSmart::DISK_STATUS_CAUTION\n\t|| m_Ata.vars[index].DiskStatus == CAtaSmart::DISK_STATUS_BAD)\n\t{\n\t\tfor(DWORD j = 0; j < m_Ata.vars[index].AttributeCount; j++)\n\t\t{\n\t\t\tif(m_Ata.vars[index].Attribute[j].Id == 0x05 // Reallocated Sectors Count\n\t\t\t|| m_Ata.vars[index].Attribute[j].Id == 0xC5 // Current Pending Sector Count\n\t\t\t|| m_Ata.vars[index].Attribute[j].Id == 0xC6 // Off-Line Scan Uncorrectable Sector Count\n\t\t\t)\n\t\t\t{\n\t\t\t\tvalue = MAKELONG(\n\t\t\t\t\t\t\tMAKEWORD(\n\t\t\t\t\t\t\t\tm_Ata.vars[index].Attribute[j].RawValue[0],\n\t\t\t\t\t\t\t\tm_Ata.vars[index].Attribute[j].RawValue[1]),\n\t\t\t\t\t\t\tMAKEWORD(\n\t\t\t\t\t\t\t\tm_Ata.vars[index].Attribute[j].RawValue[2],\n\t\t\t\t\t\t\t\tm_Ata.vars[index].Attribute[j].RawValue[3])\n\t\t\t\t\t\t\t);\n\t\t\t\tif(value != 0xFFFFFFFF && value != 0x0 && ! m_Ata.vars[index].IsSsd)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"%02X\"), m_Ata.vars[index].Attribute[j].Id);\n\t\t\t\t\tresult += i18n(_T(\"DiskStatus\"), _T(\"CAUTION\")) + _T(\" [\") + cstr + _T(\"] \")+ i18n(_T(\"Smart\"), cstr);\n\t\t\t\t\tcstr.Format(_T(\" : %d\\n\"), value);\n\t\t\t\t\tresult += cstr;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(\n\t\t\t   (m_Ata.vars[index].Attribute[j].Id == 0xA9 && (m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_REALTEK || (m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_KINGSTON && m_Ata.vars[index].HostReadsWritesUnit == m_Ata.HOST_READS_WRITES_32MB) || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SILICONMOTION))\n\t\t\t|| (m_Ata.vars[index].Attribute[j].Id == 0xAD && (m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_TOSHIBA || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_KIOXIA))\n\t\t\t|| (m_Ata.vars[index].Attribute[j].Id == 0xB1 && m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SAMSUNG)\n\t\t\t|| (m_Ata.vars[index].Attribute[j].Id == 0xBB && m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_MTRON)\n\t\t\t|| (m_Ata.vars[index].Attribute[j].Id == 0xCA && (m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_MICRON || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_MICRON_MU03 || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_INTEL_DC || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SILICONMOTION_CVC))\n\t\t\t|| (m_Ata.vars[index].Attribute[j].Id == 0xD1 && m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_INDILINX)\n\t\t\t|| (m_Ata.vars[index].Attribute[j].Id == 0xE6 && (m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_WDC || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK_LENOVO || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK_DELL))\n\t\t\t|| (m_Ata.vars[index].Attribute[j].Id == 0xE8 && m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_PLEXTOR)\n\t\t\t|| (m_Ata.vars[index].Attribute[j].Id == 0xE7 && (m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SANDFORCE || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_CORSAIR || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_KINGSTON || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SKHYNIX\n\t\t\t\t                                          || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_REALTEK || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SSSTC || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_APACER\n\t\t\t\t                                          || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_JMICRON || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SEAGATE || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_MAXIOTEK || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_YMTC\n\t\t\t\t                                          || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SCY || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_RECADATA || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_ADATA_INDUSTRIAL))\n\t\t\t|| (m_Ata.vars[index].Attribute[j].Id == 0xE9 && (m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_INTEL || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_OCZ || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_OCZ_VECTOR || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SKHYNIX))\n\t\t\t|| (m_Ata.vars[index].Attribute[j].Id == 0xE9 && m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS)\n\t\t\t|| (m_Ata.vars[index].Attribute[j].Id == 0xC9 && (m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK_HP || m_Ata.vars[index].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK_HP_VENUS))\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%02X\"), m_Ata.vars[index].Attribute[j].Id);\n\t\t\t\tif(m_Ata.vars[index].DiskStatus == CAtaSmart::DISK_STATUS_CAUTION)\n\t\t\t\t{\n\t\t\t\t\tresult += i18n(_T(\"DiskStatus\"), _T(\"CAUTION\")) + _T(\" [\") + cstr + _T(\"] \") + i18n(m_Ata.vars[index].SmartKeyName, cstr);\n\t\t\t\t}\n\t\t\t\telse if(m_Ata.vars[index].DiskStatus == CAtaSmart::DISK_STATUS_BAD)\n\t\t\t\t{\n\t\t\t\t\tresult += i18n(_T(\"DiskStatus\"), _T(\"BAD\")) + _T(\" [\") + cstr + _T(\"] \") + i18n(m_Ata.vars[index].SmartKeyName, cstr);\n\t\t\t\t}\n\t\t\t\tcstr.Format(_T(\" : %d\\n\"), m_Ata.vars[index].Life);\n\t\t\t\tresult += cstr;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult.TrimRight();\n\treturn result;\n}\n\nCString CDiskInfoDlg::GetLogicalDriveInfo(DWORD index, INT maxLength)\n{\n\tDWORD map = m_Ata.vars[index].DriveLetterMap;\n\tCString resultS, resultM, resultL;\n\tULARGE_INTEGER freeBytesAvailableToCaller = {};\n\tULARGE_INTEGER totalNumberOfBytes = {};\n\tULARGE_INTEGER totalNumberOfFreeBytes = {};\n\n\tfor(int j = 0; j < 26; j++)\n\t{\n\t\tif(map & (1 << j))\n\t\t{\n\t\t\tCString cstr;\n\t\t\tCString letter;\n\t\t\tTCHAR volumeNameBuffer[256] = {};\n\n\t\t\tletter.Format(_T(\"%C:\\\\\"), j + 'A');\n\t\t\tGetDiskFreeSpaceEx(letter, &freeBytesAvailableToCaller,\n\t\t\t\t&totalNumberOfBytes, &totalNumberOfFreeBytes);\n\t\t\tGetVolumeInformation(letter,  volumeNameBuffer, 256, NULL, NULL, NULL, NULL, 0);\n\n\t\t\tif (totalNumberOfBytes.QuadPart == 0)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%C: %s\\r\\n\"), j + 'A', volumeNameBuffer);\n\t\t\t}\n\t\t\telse if (totalNumberOfFreeBytes.QuadPart < totalNumberOfBytes.QuadPart)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%C: %s [%.1f/%.1f GB (%.1f %%)]\\r\\n\"), \n\t\t\t\t\tj + 'A', volumeNameBuffer,\n\t\t\t\t\ttotalNumberOfFreeBytes.QuadPart / 1024 / 1024 / 1024.0,\n\t\t\t\t\ttotalNumberOfBytes.QuadPart  / 1024 / 1024 / 1024.0,\n\t\t\t\t\t(double)totalNumberOfFreeBytes.QuadPart / (double)totalNumberOfBytes.QuadPart * 100);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%C: %s [%.1f/%.1f GB]\\r\\n\"),\n\t\t\t\t\tj + 'A', volumeNameBuffer,\n\t\t\t\t\ttotalNumberOfFreeBytes.QuadPart / 1024 / 1024 / 1024.0,\n\t\t\t\t\ttotalNumberOfBytes.QuadPart / 1024 / 1024 / 1024.0);\n\t\t\t}\n\t\t\n\t\t\tresultL += cstr;\n\n\t\t\tcstr.Format(_T(\"%C: %s [%.1f GB]\\r\\n\"), \n\t\t\t\tj + 'A', volumeNameBuffer,\n\t\t\t\ttotalNumberOfBytes.QuadPart  / 1024 / 1024 / 1024.0);\n\n\t\t\tresultM += cstr;\n\n\t\t\tcstr.Format(_T(\"%C: %s\\r\\n\"), \n\t\t\t\tj + 'A', volumeNameBuffer);\n\n\t\t\tresultS += cstr;\n\t\t}\n\t}\n\tresultL.TrimRight();\n\tresultM.TrimRight();\n\tresultS.TrimRight();\n\n\tif(resultL.GetLength() < maxLength)\n\t{\n\t\treturn resultL;\n\t}\n\telse if(resultM.GetLength() < maxLength)\n\t{\n\t\treturn resultM;\n\t}\n\telse\n\t{\n\t\treturn resultS;\n\t}\n}\n\nvoid CDiskInfoDlg::InitDriveList()\n{\n\tCString cstr;\n\tCString delimiter;\n\tCString mini = L\"\";\n\n\tif (m_bHalfDriveMenu)\n\t{\n\t\tmini = L\"Mini\";\n\t}\n\n\tif (m_Ata.vars.GetCount() / m_DriveMenuNumber == m_DriveMenuPage)\n\t{\n\t\tfor(int i = m_Ata.vars.GetCount() % m_DriveMenuNumber; i < m_DriveMenuNumber; i++)\n\t\t{\n\t\t\tm_LiDisk[i] = _T(\"\");\n\t\t\tm_ButtonDisk[i].ReloadImage(IP(L\"noDisk\" + mini), 1);\n\t\t\tm_ButtonDisk[i].SetToolTipText(L\"\");\n\t\t//\tm_ButtonDisk[i].EnableWindow(FALSE);\n\t\t\tm_ButtonDisk[i].SetHandCursor(FALSE);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m_DriveMenuNumber; i++)\n\t{\n\t\tm_ButtonDisk[i].ShowWindow(SW_SHOW);\n\t\tm_ButtonDisk[i].SetSelected(FALSE);\n\t}\n\tfor (int i = m_DriveMenuNumber; i < MAX_DRIVE_MENU; i++)\n\t{\n\t\tm_ButtonDisk[i].ShowWindow(SW_HIDE);\n\t}\n\n\tdelimiter = _T(\"\\r\\n\");\n\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tCString className, driveLetter, diskStatus;\n\t\tif(m_Ata.vars[i].DriveMap.IsEmpty())\n\t\t{\n\t\t\tif(m_Ata.vars[i].PhysicalDriveId >= 0)\n\t\t\t{\n\t\t\t\tdriveLetter.Format(_T(\"Disk %d\"), m_Ata.vars[i].PhysicalDriveId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdriveLetter.Format(_T(\"Disk --\"));\n\t\t\t}\n\t\t}\n\t\telse if(m_Ata.vars[i].DriveMap.GetLength() > 15)\n\t\t{\n\t\t\tdriveLetter = m_Ata.vars[i].DriveMap.Left(11) + _T(\" ...\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdriveLetter = m_Ata.vars[i].DriveMap;\n\t\t}\n\n\t\tdiskStatus = GetDiskStatus(m_Ata.vars[i].DiskStatus);\n\t\tclassName = GetDiskStatusClass(m_Ata.vars[i].DiskStatus);\n\n\t\tif (m_bHalfDriveMenu)\n\t\t{\n\t\t\tclassName += L\"Mini\";\n\t\t\tdiskStatus = L\" \";\n\t\t\tdriveLetter.Replace(L\":\", L\"\");\n\t\t\tdriveLetter.Replace(L\" \", L\"\");\t\n\t\t}\n\n\t\tif(m_SelectDisk == i)\n\t\t{\n\t\t\tm_ButtonDisk[i % m_DriveMenuNumber].SetSelected(TRUE);\n\t\t}\n\n\t\t// DriveMenu\n\t\tif(i / m_DriveMenuNumber == m_DriveMenuPage)\n\t\t{\n\t\t\tCString targetDisk;\n\t\t\ttargetDisk.Format(_T(\"Disk%d\"), i % m_DriveMenuNumber);\n\t\t\tif (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_NVME && m_Ata.vars[i].Temperature > -300)\n\t\t\t{\n\t\t\t\tif (m_bFahrenheit)\n\t\t\t\t{\n\t\t\t\t\tm_LiDisk[i % m_DriveMenuNumber].Format(_T(\"%s%s%d °F%s%s\"),\n\t\t\t\t\t\tdiskStatus.GetString(), delimiter.GetString(), m_Ata.vars[i].Temperature * 9 / 5 + 32, delimiter.GetString(), driveLetter.GetString());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_LiDisk[i % m_DriveMenuNumber].Format(_T(\"%s%s%d °C%s%s\"),\n\t\t\t\t\t\tdiskStatus.GetString(), delimiter.GetString(), m_Ata.vars[i].Temperature, delimiter.GetString(), driveLetter.GetString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].IsSmartEnabled && m_Ata.vars[i].Temperature > -300)\n\t\t\t{\n\t\t\t\tif(m_bFahrenheit)\n\t\t\t\t{\n\t\t\t\t\tm_LiDisk[i % m_DriveMenuNumber].Format(_T(\"%s%s%d °F%s%s\"),\n\t\t\t\t\t\t\t\tdiskStatus.GetString(), delimiter.GetString(), m_Ata.vars[i].Temperature * 9 / 5 + 32, delimiter.GetString(), driveLetter.GetString());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_LiDisk[i % m_DriveMenuNumber].Format(_T(\"%s%s%d °C%s%s\"),\n\t\t\t\t\t\t\t\tdiskStatus.GetString(), delimiter.GetString(), m_Ata.vars[i].Temperature, delimiter.GetString(), driveLetter.GetString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].IsSmartEnabled)\n\t\t\t{\n\t\t\t\tif(m_bFahrenheit)\n\t\t\t\t{\n\t\t\t\t\tm_LiDisk[i % m_DriveMenuNumber].Format(_T(\"%s%s-- °F%s%s\"), diskStatus.GetString(), delimiter.GetString(), delimiter.GetString(), driveLetter.GetString());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_LiDisk[i % m_DriveMenuNumber].Format(_T(\"%s%s-- °C%s%s\"), diskStatus.GetString(), delimiter.GetString(), delimiter.GetString(), driveLetter.GetString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(m_bFahrenheit)\n\t\t\t\t{\n\t\t\t\t\tm_LiDisk[i % m_DriveMenuNumber].Format(_T(\"----%s-- °F%s%s\"), delimiter.GetString(), delimiter.GetString(), driveLetter.GetString());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_LiDisk[i % m_DriveMenuNumber].Format(_T(\"----%s-- °C%s%s\"), delimiter.GetString(), delimiter.GetString(), driveLetter.GetString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(m_Ata.vars[i].PhysicalDriveId >= 0)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"Disk %d : %s : %.1f GB\\n%s\"), m_Ata.vars[i].PhysicalDriveId, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize / 1000.0, GetLogicalDriveInfo(i).GetString());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"Disk -- : %s : %.1f GB\\n%s\"), m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize / 1000.0, GetLogicalDriveInfo(i).GetString());\n\t\t\t}\n\t\t\t\n\t\t\tm_ButtonDisk[i % m_DriveMenuNumber].SetToolTipText(cstr);\n\t\t\tclassName.Replace(L\"Status\", L\"\");\n\t\t\tm_ButtonDisk[i % m_DriveMenuNumber].ReloadImage(IP(className), 4);\n\t\t\tm_ButtonDisk[i % m_DriveMenuNumber].SetHandCursor(TRUE);\n\t\t//\tm_ButtonDisk[i % m_DriveMenuNumber].EnableWindow(TRUE);\n\t\t}\n\t}\n\n\tUpdateData(FALSE);\n}\n"
        },
        {
          "name": "DiskInfoDlgMenu.cpp",
          "type": "blob",
          "size": 50.744140625,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n#include <complex>\n\n//  Include the task header file.\n#include <taskschd.h>\n# pragma comment(lib, \"taskschd.lib\")\n# pragma comment(lib, \"comsupp.lib\")\n# pragma comment(lib, \"credui.lib\")\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n#ifndef SAFE_RELEASE\n#define SAFE_RELEASE(p)      { if (p) { (p)->Release(); (p)=NULL; } }\n#endif\n\nCString CDiskInfoDlg::Encode10X(DWORD value)\n{\n\tCString cstr;\n\tcstr.Format(_T(\"%010d%08X\"), value, value);\n\n\treturn cstr;\n}\n\nDWORD CDiskInfoDlg::Decode10X(CString cstr)\n{\n\tDWORD d, x;\n\tTCHAR *endPtr;\n\td = _tcstol(cstr.Left(10), &endPtr, 10);\n\tx = _tcstol(cstr.Mid(10, 8), &endPtr, 16);\n\n\tif(d == x)\n\t{\n\t\treturn d;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}\n\nvoid CDiskInfoDlg::OnAbout()\n{\n\tm_AboutDlg = new CAboutDlg(this);\n\tm_AboutDlg->Create(CAboutDlg::IDD, m_AboutDlg, ID_ABOUT, this);\n}\n\nvoid CDiskInfoDlg::OnCustomize()\n{\n\tm_OptionDlg = new COptionDlg(this);\n\tm_OptionDlg->Create(COptionDlg::IDD, m_OptionDlg, ID_CUSTOMIZE, this);\n}\n\nvoid CDiskInfoDlg::OnAamApm()\n{\n\tm_SettingDlg = new CSettingDlg(this);\n\tm_SettingDlg->Create(CSettingDlg::IDD, m_SettingDlg, ID_AAM_APM, this);\n}\n\nvoid CDiskInfoDlg::OnTemperature()\n{\n\tm_TemperatureDlg = new CTemperatureDlg(this);\n\tm_TemperatureDlg->Create(CTemperatureDlg::IDD, m_TemperatureDlg, ID_TEMPERATURE, this);\n}\n\nvoid CDiskInfoDlg::OnHealthStatus()\n{\n\tCMenu *menu = GetMenu();\n\tif(! (menu->GetMenuState(ID_HEALTH_STATUS, MF_BYCOMMAND) & MF_GRAYED))\n\t{\n\t\tm_HealthDlg = new CHealthDlg(this);\n\t\tm_HealthDlg->Create(CHealthDlg::IDD, m_HealthDlg, ID_HEALTH_STATUS, this);\n\t}\n}\n\n/*\nvoid CDiskInfoDlg::OnAlarmHistory()\n{\n\tm_AlarmHistoryDlg = new CAlarmHistoryDlg(this);\n\tm_AlarmHistoryDlg->Create(CAlarmHistoryDlg::IDD, m_AlarmHistoryDlg, ID_ALARM_HISTORY, this);\n}\n*/\n\nvoid CDiskInfoDlg::OnSoundSetting()\n{\n\tm_SoundSettingDlg = new CSoundSettingDlg(this);\n\tm_SoundSettingDlg->Create(CSoundSettingDlg::IDD, m_SoundSettingDlg, ID_SOUND_SETTINGS, this);\n}\n\nvoid CDiskInfoDlg::OnGraph()\n{\n\tShowGraphDlg(-1);\n}\n\nvoid CDiskInfoDlg::ShowGraphDlg(int index)\n{\n//\tm_GraphDlg = new CGraphDlg(this);\n//\tm_GraphDlg->Create(CGraphDlg::IDD, m_GraphDlg, ID_GRAPH, this);\n\n\tCreateExchangeInfo();\n\n\tTCHAR path[MAX_PATH];\n\tCString cstr;\n\tGetModuleFileName(NULL, path, MAX_PATH);\n\n\tSTARTUPINFO si = { sizeof(STARTUPINFO) };\n\tPROCESS_INFORMATION pi = {};\n\tsi.dwFlags\t\t= STARTF_USESHOWWINDOW;\n\tsi.wShowWindow\t= SW_SHOWNORMAL;\n\tcstr.Format(_T(\"\\\"%s\\\" /Earthlight %d\"), path, index); \n\t::CreateProcess(NULL, (LPWSTR)cstr.GetString(), NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);\n\n\tm_GraphProcessId.Add(pi.dwProcessId);\n\n\tCloseHandle(pi.hThread);\n\tCloseHandle(pi.hProcess);\n}\n\nvoid CDiskInfoDlg::CreateExchangeInfo()\n{\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), (DWORD)m_Ata.vars.GetCount());\n\tWritePrivateProfileStringFx(_T(\"EXCHANGE\"), _T(\"DetectedDisk\"), cstr, m_SmartDir + EXCHANGE_INI);\n\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tcstr.Format(_T(\"%d\"), i);\n\t\tWritePrivateProfileStringFx(_T(\"MODEL\"), cstr, m_Ata.vars[i].Model, m_SmartDir + EXCHANGE_INI);\n\t\tWritePrivateProfileStringFx(_T(\"SERIAL\"), cstr, m_Ata.vars[i].SerialNumber, m_SmartDir + EXCHANGE_INI);\n\t\tWritePrivateProfileStringFx(_T(\"DRIVE\"), cstr, m_Ata.vars[i].DriveMap, m_SmartDir + EXCHANGE_INI);\n\t}\n}\n\nvoid CDiskInfoDlg::OnHideSmartInfo()\n{\n\tCMenu *menu = GetMenu();\t\t\n\tif(m_bHideSmartInfo)\n\t{\n\t\tm_SizeX = SIZE_SMART_X;\n\t\tm_SizeY = SIZE_SMART_Y;\n\t\tSetClientSize(m_SizeX, m_SizeY, m_ZoomRatio);\n\t\tmenu->CheckMenuItem(ID_HIDE_SMART_INFO, MF_UNCHECKED);\n\t\tm_bHideSmartInfo = FALSE;\n\t\tWritePrivateProfileStringW(_T(\"Setting\"), _T(\"HideSmartInfo\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_SizeX = SIZE_X;\n\t\tm_SizeY = SIZE_Y;\n\t\tSetClientSize(m_SizeX, m_SizeY, m_ZoomRatio);\n\t\tmenu->CheckMenuItem(ID_HIDE_SMART_INFO, MF_CHECKED);\n\t\tm_bHideSmartInfo = TRUE;\n\t\tWritePrivateProfileStringW(_T(\"Setting\"), _T(\"HideSmartInfo\"), _T(\"1\"), m_Ini);\n\t}\n\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), m_SizeY);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Height\"), cstr, m_Ini);\n\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnGreenMode()\n{\n\tCMenu *menu = GetMenu();\n\tif (menu->GetMenuState(ID_GREEN_MODE, MF_BYCOMMAND) & MFS_CHECKED)\n\t{\n\t\tmenu->CheckMenuItem(ID_GREEN_MODE, MF_UNCHECKED);\n\t\tm_bGreenMode = FALSE;\n\t\tWritePrivateProfileStringW(_T(\"Setting\"), _T(\"GreenMode\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_GREEN_MODE, MF_CHECKED);\n\t\tm_bGreenMode = TRUE;\n\t\tWritePrivateProfileStringW(_T(\"Setting\"), _T(\"GreenMode\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tUpdateTrayTemperatureIcon(TRUE);\n\n\tUpdateDialogSize();\n}\n\nvoid CDiskInfoDlg::OnDisableDarkMode()\n{\n\tCMenu* menu = GetMenu();\n\tif (menu->GetMenuState(ID_DISABLE_DARK_MODE, MF_BYCOMMAND) & MFS_CHECKED)\n\t{\n\t\tmenu->CheckMenuItem(ID_DISABLE_DARK_MODE, MF_UNCHECKED);\n\t\tm_bForceDisableDarkMode = FALSE;\n\t\tWritePrivateProfileStringW(_T(\"Setting\"), _T(\"DisableDarkMode\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_DISABLE_DARK_MODE, MF_CHECKED);\n\t\tm_bForceDisableDarkMode = TRUE;\n\t\tWritePrivateProfileStringW(_T(\"Setting\"), _T(\"DisableDarkMode\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tUpdateDialogSize();\n}\n\nvoid CDiskInfoDlg::CheckHideSerialNumber()\n{\n\tCMenu *menu = GetMenu();\n\tif(GetPrivateProfileInt(_T(\"Setting\"), _T(\"HideSerialNumber\"), 0, m_Ini))\n\t{\n\t\tm_bHideSerialNumber = TRUE;\n\t\tmenu->CheckMenuItem(ID_HIDE_SERIAL_NUMBER, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tm_bHideSerialNumber = FALSE;\n\t\tmenu->CheckMenuItem(ID_HIDE_SERIAL_NUMBER, MF_UNCHECKED);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnHideSerialNumber()\n{\n\tCMenu *menu = GetMenu();\t\t\n\tif(m_bHideSerialNumber)\n\t{\n\t\tm_bHideSerialNumber = FALSE;\n\t\tmenu->CheckMenuItem(ID_HIDE_SERIAL_NUMBER, MF_UNCHECKED);\n\t\tWritePrivateProfileStringW(_T(\"Setting\"), _T(\"HideSerialNumber\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bHideSerialNumber = TRUE;\n\t\tmenu->CheckMenuItem(ID_HIDE_SERIAL_NUMBER, MF_CHECKED);\n\t\tWritePrivateProfileStringW(_T(\"Setting\"), _T(\"HideSerialNumber\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tChangeDisk(m_SelectDisk);\n}\n\nvoid CDiskInfoDlg::OnCrystalDewWorld()\n{\n\tif(GetUserDefaultLCID() == 0x0411) // Japanese\n\t{\n\t\tOpenUrl(URL_CRYSTAL_DEW_WORLD_JA);\n\t}\n\telse // Other Language\n\t{\n\t\tOpenUrl(URL_CRYSTAL_DEW_WORLD_EN);\n\t}\t\n}\n\n\nvoid CDiskInfoDlg::OnHelp()\n{\n\tif(GetUserDefaultLCID() == 0x0411) // Japanese\n\t{\n\t\tOpenUrl(URL_HELP_JA);\n\t}\n\telse // Other Language\n\t{\n\t\tOpenUrl(URL_HELP_EN);\n\t}\t\n}\n\nvoid CDiskInfoDlg::OnRefresh()\n{\n\tRefresh(TRUE);\n}\n\nvoid CDiskInfoDlg::OnRescan()\n{\n\tCWaitCursor wait;\n\tBOOL flagChangeDisk = FALSE;\n\n\tInitAta(TRUE, m_bAdvancedDiskSearch, &flagChangeDisk, m_bWorkaroundHD204UI, m_bWorkaroundAdataSsd);\n\n\tif(flagChangeDisk)\n\t{\n\t\t// Update Menu and Dialog\n\t\tm_SelectDisk = 0;\n\t\tm_DriveMenuPage = 0;\n\t\tChangeLang(m_CurrentLang);\n\t}\n\telse\n\t{\n\t\tRebuildListHeader(m_SelectDisk, TRUE);\n\t\tRefresh(TRUE);\n\t}\n\n\tif(m_bResident && flagChangeDisk)\n\t{\n\t\tfor(int i = 0; i < CAtaSmart::MAX_DISK; i++)\n\t\t{\n\t\t\tRemoveTemperatureIcon(i);\n\t\t}\n\t\tCheckTrayTemperatureIcon();\n\t}\n}\n\nvoid CDiskInfoDlg::OnHelpAboutSmart()\n{\n\tTCHAR url[256];\n\tGetPrivateProfileStringFx(_T(\"Url\"), _T(\"WIKIPEDIA_SMART\"), _T(\"https://en.wikipedia.org/wiki/Self-Monitoring,_Analysis_and_Reporting_Technology\"), url, 256, m_CurrentLangPath);\n\n\tOpenUrl(url);\n}\n\nvoid CDiskInfoDlg::OnAutoRefreshDisable(){\tCheckRadioAutoRefresh(ID_AUTO_REFRESH_DISABLE, 0);}\nvoid CDiskInfoDlg::OnAutoRefresh01Min(){\tCheckRadioAutoRefresh(ID_AUTO_REFRESH_01_MIN, 1);}\nvoid CDiskInfoDlg::OnAutoRefresh03Min(){\tCheckRadioAutoRefresh(ID_AUTO_REFRESH_03_MIN, 3);}\nvoid CDiskInfoDlg::OnAutoRefresh05Min(){\tCheckRadioAutoRefresh(ID_AUTO_REFRESH_05_MIN, 5);}\nvoid CDiskInfoDlg::OnAutoRefresh10Min(){\tCheckRadioAutoRefresh(ID_AUTO_REFRESH_10_MIN, 10);}\nvoid CDiskInfoDlg::OnAutoRefresh30Min(){\tCheckRadioAutoRefresh(ID_AUTO_REFRESH_30_MIN, 30);}\nvoid CDiskInfoDlg::OnAutoRefresh60Min(){\tCheckRadioAutoRefresh(ID_AUTO_REFRESH_60_MIN, 60);}\nvoid CDiskInfoDlg::OnAutoRefresh120Min(){ CheckRadioAutoRefresh(ID_AUTO_REFRESH_120_MIN, 120); }\nvoid CDiskInfoDlg::OnAutoRefresh180Min(){ CheckRadioAutoRefresh(ID_AUTO_REFRESH_180_MIN, 180); }\nvoid CDiskInfoDlg::OnAutoRefresh360Min(){ CheckRadioAutoRefresh(ID_AUTO_REFRESH_360_MIN, 360); }\nvoid CDiskInfoDlg::OnAutoRefresh720Min(){ CheckRadioAutoRefresh(ID_AUTO_REFRESH_720_MIN, 720); }\nvoid CDiskInfoDlg::OnAutoRefresh1440Min(){ CheckRadioAutoRefresh(ID_AUTO_REFRESH_1440_MIN, 1440); }\n\nvoid CDiskInfoDlg::CheckRadioAutoRefresh(int id, int value)\n{\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_AUTO_REFRESH_DISABLE, ID_AUTO_REFRESH_1440_MIN, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tm_AutoRefreshStatus = value;\n\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), value);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AutoRefresh\"), cstr, m_Ini);\n\n\tif(value == 0)\n\t{\n\t\tKillTimer(TIMER_AUTO_REFRESH);\n\t}\n\telse\n\t{\n\t\tKillTimer(TIMER_AUTO_REFRESH);\n\t\tSetTimer(TIMER_AUTO_REFRESH, 1000 * 60 * value, 0);\n\t}\n}\n\nvoid CDiskInfoDlg::CheckRadioAutoRefresh()\n{\n\tint id = ID_AUTO_REFRESH_DISABLE;\n\n\tswitch(m_AutoRefreshStatus)\n\t{\n\tcase    1: id = ID_AUTO_REFRESH_01_MIN; break;\n\tcase    3: id = ID_AUTO_REFRESH_03_MIN; break;\n\tcase    5: id = ID_AUTO_REFRESH_05_MIN; break;\n\tcase   10: id = ID_AUTO_REFRESH_10_MIN; break;\n\tcase   30: id = ID_AUTO_REFRESH_30_MIN; break;\n\tcase   60: id = ID_AUTO_REFRESH_60_MIN; break;\n\tcase  120: id = ID_AUTO_REFRESH_120_MIN; break;\n\tcase  180: id = ID_AUTO_REFRESH_180_MIN; break;\n\tcase  360: id = ID_AUTO_REFRESH_360_MIN; break;\n\tcase  720: id = ID_AUTO_REFRESH_720_MIN; break;\n\tcase 1440: id = ID_AUTO_REFRESH_1440_MIN; break;\n\n\tdefault: id = ID_AUTO_REFRESH_DISABLE; break;\n\t}\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_AUTO_REFRESH_DISABLE, ID_AUTO_REFRESH_1440_MIN, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\n\nvoid CDiskInfoDlg::OnWait0Sec()\n{\n\tCheckRadioWaitTime(ID_WAIT_0_SEC, 0);\n}\n\nvoid CDiskInfoDlg::OnWait5Sec(){\tCheckRadioWaitTime(ID_WAIT_5_SEC, 5);\t}\nvoid CDiskInfoDlg::OnWait10Sec(){\tCheckRadioWaitTime(ID_WAIT_10_SEC, 10);\t}\nvoid CDiskInfoDlg::OnWait15Sec(){\tCheckRadioWaitTime(ID_WAIT_15_SEC, 15);\t}\nvoid CDiskInfoDlg::OnWait20Sec(){\tCheckRadioWaitTime(ID_WAIT_20_SEC, 20);\t}\nvoid CDiskInfoDlg::OnWait30Sec(){\tCheckRadioWaitTime(ID_WAIT_30_SEC, 30);\t}\nvoid CDiskInfoDlg::OnWait40Sec(){\tCheckRadioWaitTime(ID_WAIT_40_SEC, 40);\t}\nvoid CDiskInfoDlg::OnWait50Sec(){\tCheckRadioWaitTime(ID_WAIT_50_SEC, 50);\t}\nvoid CDiskInfoDlg::OnWait60Sec(){\tCheckRadioWaitTime(ID_WAIT_60_SEC, 60);\t}\nvoid CDiskInfoDlg::OnWait90Sec(){\tCheckRadioWaitTime(ID_WAIT_90_SEC, 90);\t}\nvoid CDiskInfoDlg::OnWait120Sec(){\tCheckRadioWaitTime(ID_WAIT_120_SEC, 120);}\nvoid CDiskInfoDlg::OnWait150Sec(){\tCheckRadioWaitTime(ID_WAIT_150_SEC, 150);}\nvoid CDiskInfoDlg::OnWait180Sec(){\tCheckRadioWaitTime(ID_WAIT_180_SEC, 180);}\nvoid CDiskInfoDlg::OnWait210Sec(){\tCheckRadioWaitTime(ID_WAIT_210_SEC, 210);}\nvoid CDiskInfoDlg::OnWait240Sec(){\tCheckRadioWaitTime(ID_WAIT_240_SEC, 240);}\n\nvoid CDiskInfoDlg::CheckRadioWaitTime(int id, int value)\n{\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_WAIT_0_SEC, ID_WAIT_240_SEC, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tm_WaitTimeStatus = value;\n\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), value);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"StartupWaitTime\"), cstr, m_Ini);\n}\n\nvoid CDiskInfoDlg::CheckRadioWaitTime()\n{\n\tint id = ID_WAIT_0_SEC;\n\n\tswitch(m_WaitTimeStatus)\n\t{\n\tcase   0: id = ID_WAIT_0_SEC;\tbreak;\n\tcase   5: id = ID_WAIT_5_SEC;\tbreak;\n\tcase  10: id = ID_WAIT_10_SEC;\tbreak;\n\tcase  15: id = ID_WAIT_15_SEC;\tbreak;\n\tcase  20: id = ID_WAIT_20_SEC;\tbreak;\n\tcase  30: id = ID_WAIT_30_SEC;\tbreak;\n\tcase  40: id = ID_WAIT_40_SEC;\tbreak;\n\tcase  50: id = ID_WAIT_50_SEC;\tbreak;\n\tcase  60: id = ID_WAIT_60_SEC;\tbreak;\n\tcase  90: id = ID_WAIT_90_SEC;\tbreak;\n\tcase 120: id = ID_WAIT_120_SEC;\tbreak;\n\tcase 150: id = ID_WAIT_150_SEC;\tbreak;\n\tcase 180: id = ID_WAIT_180_SEC;\tbreak;\n\tcase 210: id = ID_WAIT_210_SEC;\tbreak;\n\tcase 240: id = ID_WAIT_240_SEC;\tbreak;\n\tdefault:  id = ID_WAIT_0_SEC;\tbreak;\n\t}\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_WAIT_0_SEC, ID_WAIT_240_SEC, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnRawValues16()\n{\n\tCheckRadioRawValues(ID_RAW_VALUES_16, 0);\n}\n\nvoid CDiskInfoDlg::OnRawValues10All()\n{\n\tCheckRadioRawValues(ID_RAW_VALUES_10_ALL, 1);\n}\n\nvoid CDiskInfoDlg::OnRawValues2byte()\n{\n\tCheckRadioRawValues(ID_RAW_VALUES_2BYTE, 2);\n}\n\nvoid CDiskInfoDlg::OnRawValues1byte()\n{\n\tCheckRadioRawValues(ID_RAW_VALUES_1BYTE, 3);\n}\n\nvoid CDiskInfoDlg::CheckRadioRawValues(int id, int value)\n{\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_RAW_VALUES_16, ID_RAW_VALUES_1BYTE, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tm_RawValues = value;\n\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), value);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"RawValues\"), cstr, m_Ini);\n\n\tRefresh(TRUE);\n}\n\nvoid CDiskInfoDlg::CheckRadioRawValues()\n{\n\tint id = ID_RAW_VALUES_16;\n\n\tswitch(m_RawValues)\n\t{\n\tcase   0: id = ID_RAW_VALUES_16;\tbreak;\n\tcase   1: id = ID_RAW_VALUES_10_ALL;break;\n\tcase   2: id = ID_RAW_VALUES_2BYTE;\tbreak;\n\tcase   3: id = ID_RAW_VALUES_1BYTE;\tbreak;\n\tdefault:  id = ID_RAW_VALUES_16;\tbreak;\n\t}\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_RAW_VALUES_16, ID_RAW_VALUES_1BYTE, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnOpenDiskManagement()\n{\n\tShellExecute(NULL, NULL, _T(\"diskmgmt.msc\"), NULL, NULL, SW_SHOWNORMAL);\t\n}\n\nvoid CDiskInfoDlg::OnOpenDeviceManager()\n{\n\tShellExecute(NULL, NULL, _T(\"devmgmt.msc\"), NULL, NULL, SW_SHOWNORMAL);\t\n}\n\nvoid CDiskInfoDlg::OnAdvancedDiskSearch()\n{\n\tCWaitCursor wait;\n\tBOOL flagChangeDisk = FALSE;\n\n\tif(m_bAdvancedDiskSearch)\n\t{\n\t\tm_bAdvancedDiskSearch = FALSE;\n\t\tInitAta(TRUE, m_bAdvancedDiskSearch, &flagChangeDisk, m_bWorkaroundHD204UI, m_bWorkaroundAdataSsd);\n\n\t\tif(flagChangeDisk)\n\t\t{\n\t\t\t// Update Menu and Dialog\n\t\t\tChangeLang(m_CurrentLang);\n\t\t}\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AdvancedDiskSearch\"), _T(\"0\"), m_Ini);\n\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_ADVANCED_DISK_SEARCH, MF_UNCHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\telse\n\t{\n\t\tm_bAdvancedDiskSearch = TRUE;\n\t\tInitAta(TRUE, m_bAdvancedDiskSearch, &flagChangeDisk, m_bWorkaroundHD204UI, m_bWorkaroundAdataSsd);\n\n\t\tif(flagChangeDisk)\n\t\t{\n\t\t\t// Update Menu and Dialog\n\t\t\tChangeLang(m_CurrentLang);\n\t\t}\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AdvancedDiskSearch\"), _T(\"1\"), m_Ini);\n\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_ADVANCED_DISK_SEARCH, MF_CHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\n\tif(m_bResident && flagChangeDisk)\n\t{\n\t\tfor(int i = 0; i < CAtaSmart::MAX_DISK; i++)\n\t\t{\n\t\t\tRemoveTemperatureIcon(i);\n\t\t}\n\t\tCheckTrayTemperatureIcon();\n\t}\n}\n\nvoid CDiskInfoDlg::OnWorkaroundHD204UI()\n{\n\tCWaitCursor wait;\n\tBOOL flagChangeDisk = FALSE;\n\n\tif(m_bWorkaroundHD204UI)\n\t{\n\t\tm_bWorkaroundHD204UI = FALSE;\n\t\tInitAta(TRUE, m_bAdvancedDiskSearch, &flagChangeDisk, m_bWorkaroundHD204UI, m_bWorkaroundAdataSsd);\n\n\t\tif(flagChangeDisk)\n\t\t{\n\t\t\t// Update Menu and Dialog\n\t\t\tChangeLang(m_CurrentLang);\n\t\t}\n\t\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"HD204UI\"), _T(\"0\"), m_Ini);\n\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_HD204UI, MF_UNCHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\telse\n\t{\n\t\tm_bWorkaroundHD204UI = TRUE;\n\t\tInitAta(TRUE, m_bAdvancedDiskSearch, &flagChangeDisk, m_bWorkaroundHD204UI, m_bWorkaroundAdataSsd);\n\n\t\tif(flagChangeDisk)\n\t\t{\n\t\t\t// Update Menu and Dialog\n\t\t\tChangeLang(m_CurrentLang);\n\t\t}\n\t\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"HD204UI\"), _T(\"1\"), m_Ini);\n\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_HD204UI, MF_CHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\n\tif(m_bResident && flagChangeDisk)\n\t{\n\t\tfor(int i = 0; i < CAtaSmart::MAX_DISK; i++)\n\t\t{\n\t\t\tRemoveTemperatureIcon(i);\n\t\t}\n\t\tCheckTrayTemperatureIcon();\n\t}\n}\n\nvoid CDiskInfoDlg::OnWorkaroundIE8MODE()\n{\n\tCWaitCursor wait;\n\t//BOOL flagChangeDisk = FALSE;\n\n\tif(m_bWorkaroundIE8MODE)\n\t{\n\t\tm_bWorkaroundIE8MODE = FALSE;\n\t\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"IE8MODE\"), _T(\"0\"), m_Ini);\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_IE8MODE, MF_UNCHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\telse\n\t{\n\t\tm_bWorkaroundIE8MODE = TRUE;\n\t\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"IE8MODE\"), _T(\"1\"), m_Ini);\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_IE8MODE, MF_CHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n}\n\nvoid CDiskInfoDlg::OnWorkaroundAdataSsd()\n{\n\tCWaitCursor wait;\n\tBOOL flagChangeDisk = FALSE;\n\n\tif(m_bWorkaroundAdataSsd)\n\t{\n\t\tm_bWorkaroundAdataSsd = FALSE;\n\t\tInitAta(TRUE, m_bAdvancedDiskSearch, &flagChangeDisk, m_bWorkaroundHD204UI, m_bWorkaroundAdataSsd);\n\n\t\tif(flagChangeDisk)\n\t\t{\n\t\t\t// Update Menu and Dialog\n\t\t\tChangeLang(m_CurrentLang);\n\t\t}\n\t\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"AdataSsd\"), _T(\"0\"), m_Ini);\n\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_ADATA_SSD, MF_UNCHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\telse\n\t{\n\t\tm_bWorkaroundAdataSsd = TRUE;\n\t\tInitAta(TRUE, m_bAdvancedDiskSearch, &flagChangeDisk, m_bWorkaroundHD204UI, m_bWorkaroundAdataSsd);\n\n\t\tif(flagChangeDisk)\n\t\t{\n\t\t\t// Update Menu and Dialog\n\t\t\tChangeLang(m_CurrentLang);\n\t\t}\n\t\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"AdataSsd\"), _T(\"1\"), m_Ini);\n\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_ADATA_SSD, MF_CHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\n\tif(m_bResident && flagChangeDisk)\n\t{\n\t\tfor(int i = 0; i < CAtaSmart::MAX_DISK; i++)\n\t\t{\n\t\t\tRemoveTemperatureIcon(i);\n\t\t}\n\t\tCheckTrayTemperatureIcon();\n\t}\n}\n\nvoid CDiskInfoDlg::OnWorkaroundIgnoreC4()\n{\n\tCWaitCursor wait;\n\t//BOOL flagChangeDisk = FALSE;\n\n\tif (m_bWorkaroundIgnoreC4)\n\t{\n\t\tm_bWorkaroundIgnoreC4 = FALSE;\n\t\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"IgnoreC4\"), _T(\"0\"), m_Ini);\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_IGNORE_C4, MF_UNCHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\telse\n\t{\n\t\tm_bWorkaroundIgnoreC4 = TRUE;\n\t\tWritePrivateProfileStringFx(_T(\"Workaround\"), _T(\"IgnoreC4\"), _T(\"1\"), m_Ini);\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_IGNORE_C4, MF_CHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n}\n\nvoid CDiskInfoDlg::OnAtaPassThroughSmart()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bAtaPassThroughSmart)\n\t{\n\t\tm_bAtaPassThroughSmart = FALSE;\n\t\tm_Ata.SetAtaPassThroughSmart(FALSE);\n\t\tmenu->CheckMenuItem(ID_ATA_PASS_THROUGH_SMART, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AtaPassThroughSmart\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bAtaPassThroughSmart = TRUE;\n\t\tm_Ata.SetAtaPassThroughSmart(TRUE);\n\t\tmenu->CheckMenuItem(ID_ATA_PASS_THROUGH_SMART, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AtaPassThroughSmart\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnEventLog()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bEventLog)\n\t{\n\t\tm_bEventLog = FALSE;\n\t\tmenu->CheckMenuItem(ID_EVENT_LOG, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"EventLog\"), _T(\"0\"), m_Ini);\n\n\t//\tif(! m_bUseEventCreate)\n\t//\t{\n\t\t\tUninstallEventSource();\n\t//\t}\n\t}\n\telse\n\t{\n\t\tm_bEventLog = TRUE;\n\t\tmenu->CheckMenuItem(ID_EVENT_LOG, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"EventLog\"), _T(\"1\"), m_Ini);\n\n\t//\tif(m_bUseEventCreate)\n\t//\t{\n\t\t\tInstallEventSource();\n\t//\t}\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnAlertMail()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bAlertMail)\n\t{\n\t\tm_bAlertMail = FALSE;\n\t\tmenu->CheckMenuItem(ID_ALERT_MAIL, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertMail\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bAlertMail = TRUE;\n\t\tmenu->CheckMenuItem(ID_ALERT_MAIL, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertMail\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnAlertSound()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bAlertSound)\n\t{\n\t\tm_bAlertSound = FALSE;\n\t\tmenu->CheckMenuItem(ID_ALERT_SOUND, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertSound\"), _T(\"0\"), m_Ini);\n\t\tAlertSound(0, AS_SET_SOUND_ID);\n\t}\n\telse\n\t{\n\t\tm_bAlertSound = TRUE;\n\t\tmenu->CheckMenuItem(ID_ALERT_SOUND, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertSound\"), _T(\"1\"), m_Ini);\n\t\tAlertSound(0, AS_SET_SOUND_ID);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnHideNoSmartDisk()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bHideNoSmartDisk)\n\t{\n\t\tm_bHideNoSmartDisk = FALSE;\n\t\tmenu->CheckMenuItem(ID_HIDE_NO_SMART_DISK, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"HideNoSmartDisk\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bHideNoSmartDisk = TRUE;\n\t\tmenu->CheckMenuItem(ID_HIDE_NO_SMART_DISK, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"HideNoSmartDisk\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tOnRescan();\n}\n\nvoid CDiskInfoDlg::OnGadgetSupport()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bGadget)\n\t{\n\t\tm_bGadget = FALSE;\n\t\tmenu->CheckMenuItem(ID_GADGET_SUPPORT, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Gadget\"), _T(\"0\"), m_Ini);\n\t\tDeleteShareInfo();\n\t}\n\telse\n\t{\n\t\tm_bGadget = TRUE;\n\t\tmenu->CheckMenuItem(ID_GADGET_SUPPORT, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Gadget\"), _T(\"1\"), m_Ini);\n\t\tUpdateShareInfo();\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnMailSettings()\n{\n\tif(! m_AlertMailPath.IsEmpty())\n\t{\n\t\tShellExecuteW(NULL, NULL, m_AlertMailPath, _T(\"/Settings\"), NULL, SW_SHOW);\n\t}\n}\n\nvoid CDiskInfoDlg::CheckStartup()\n{\n\tif(GetPrivateProfileInt(_T(\"Setting\"), _T(\"Startup\"), 0, m_Ini) == 1)\n\t{\n\t\tm_bStartup = TRUE;\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_STARTUP, MF_CHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\n\t\tif(GetPrivateProfileInt(_T(\"Setting\"), _T(\"StartupFixed\"), 0, m_Ini) != 1)\n\t\t{\n\t\t\tRegisterStartup();\n\t\t\t// Fixed in 5.2.2  \n\t\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"StartupFixed\"), _T(\"1\"), m_Ini);\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_bStartup = FALSE;\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"StartupFixed\"), _T(\"1\"), m_Ini);\n\t}\n}\n\nvoid CDiskInfoDlg::OnStartup()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bStartup)\n\t{\n\t\tUnregisterStartup();\n\t\tm_bStartup = FALSE;\n\t\tmenu->CheckMenuItem(ID_STARTUP, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Startup\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tRegisterStartup();\n\t\tm_bStartup = TRUE;\n\t\tmenu->CheckMenuItem(ID_STARTUP, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Startup\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nBOOL CDiskInfoDlg::RegisterStartup()\n{\n\tTCHAR path[MAX_PATH] = {};\n\tGetModuleFileName(NULL, path, MAX_PATH);\n\tCString cstr;\n\n\tif(IsWindowsVersionOrGreaterFx(6, 0))\n\t{\n\t\tSTARTUPINFO si = {0};\n\t\tPROCESS_INFORMATION pi = {0};\n\t\tsi.cb\t\t\t= sizeof(STARTUPINFO);\n\t\tsi.dwFlags\t\t= STARTF_USESHOWWINDOW;\n\t\tsi.wShowWindow\t= SW_HIDE;\n\t\tcstr.Format(_T(\"schtasks.exe /Create /tn CrystalDiskInfo /tr \\\"\\\\\\\"%s\\\\\\\" \\\"/Startup\\\"\\\" /sc ONLOGON /RL HIGHEST /F\"), path);\n\t\t::CreateProcess(NULL, (LPWSTR)cstr.GetString(), NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);\n\t\tWaitForSingleObject(pi.hProcess, 1000);\n\t\tCloseHandle(pi.hThread);\n\t\tCloseHandle(pi.hProcess);\n\n\t\t// Change \"StopIfGoingOnBatteries\" and \"DisallowStartIfOnBatteries\"\n\t\tHRESULT hr = S_OK;\n\n\t\tITaskService *pService = NULL;\n\t\tITaskFolder *pRootFolder = NULL;\n\t\tIRegisteredTask *pRegisteredTask = NULL;\n\t\tITaskDefinition *pDefinition = NULL;\n\t\tITaskSettings *pSettings = NULL;\n\t\tLPCWSTR wszTaskName = L\"CrystalDiskInfo\";\n\n\t\thr = CoCreateInstance(CLSID_TaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_ITaskService, (void **) &pService);\n\t\tif(SUCCEEDED(hr))\n\t\t{\n\t\t\thr = pService->Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t());\t\t\t\n\t\t\tif(SUCCEEDED(hr))\n\t\t\t{\n\t\t\t\thr = pService->GetFolder(_bstr_t(L\"\\\\\"), &pRootFolder);\n\t\t\t\tif(SUCCEEDED(hr))\n\t\t\t\t{\n\t\t\t\t\thr = pRootFolder->GetTask(_bstr_t(wszTaskName), &pRegisteredTask);\n\t\t\t\t\tif(SUCCEEDED(hr))\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\thr = pRegisteredTask->get_Definition(&pDefinition);\n\t\t\t\t\t\tif(SUCCEEDED(hr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVARIANT_BOOL flag = FALSE;\n\t\t\t\t\t\t\tpDefinition->get_Settings(&pSettings);\n\t\t\t\t\t\t\tpSettings->put_DisallowStartIfOnBatteries(flag);\n\t\t\t\t\t\t\tpSettings->put_StopIfGoingOnBatteries(flag);\n\t\t\t\t\t\t\tpSettings->put_Priority(5);\n\n\t\t\t\t\t\t\tSAFE_RELEASE(pRegisteredTask);\n\t\t\t\t\t\t\thr = pRootFolder->RegisterTaskDefinition(\n\t\t\t\t\t\t\t\t_bstr_t(wszTaskName), pDefinition, TASK_CREATE_OR_UPDATE, \n\t\t\t\t\t\t\t\t_variant_t(), _variant_t(), TASK_LOGON_INTERACTIVE_TOKEN,\n\t\t\t\t\t\t\t\t_variant_t(L\"\"), &pRegisteredTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSAFE_RELEASE(pSettings);\n\t\tSAFE_RELEASE(pDefinition);\n\t\tSAFE_RELEASE(pRegisteredTask);\n\t\tSAFE_RELEASE(pRootFolder);\n\t\tSAFE_RELEASE(pService);\n\t}\n\telse\n\t{\n\t\tHKEY hKey;\n\t\tDWORD disposition;\n\t\tLONG result;\n\t\tTCHAR lpClass[1]{};\n\t\tresult = ::RegCreateKeyEx(HKEY_CURRENT_USER, \n\t\t\t_T(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\"), 0, lpClass/*_T(\"\")*/,\n\t\t\tREG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &disposition);\n\t\tif(result == ERROR_SUCCESS)\n\t\t{\n\t\t\tcstr.Format(_T(\"\\\"%s\\\" /Startup\"), path);\n\t\t\t::RegSetValueEx(hKey, _T(\"CrystalDiskInfo\"), 0, REG_SZ,\n\t\t\t\t(CONST BYTE*)(LPCTSTR)cstr,\n\t\t\t\t((DWORD)_tcslen(cstr) + 3) * 2);\n\t\t\t::RegCloseKey(hKey);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CDiskInfoDlg::UnregisterStartup()\n{\n\tif(IsWindowsVersionOrGreaterFx(6, 0))\n\t{\n\t\tCString cstr;\n\n\t\tSTARTUPINFO si = { sizeof(STARTUPINFO) };\n\t\tPROCESS_INFORMATION pi = {};\n\t\t//si.cb\t\t\t= sizeof(STARTUPINFO);\n\t\tsi.dwFlags\t\t= STARTF_USESHOWWINDOW;\n\t\tsi.wShowWindow\t= SW_HIDE;\n\t\tcstr.Format(_T(\"schtasks.exe /Delete /tn CrystalDiskInfo /F\")); \n\t\t::CreateProcess(NULL, (LPWSTR)cstr.GetString(), NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);\n\t\tWaitForSingleObject(pi.hProcess, 1000);\n\t\tCloseHandle(pi.hThread);\n\t\tCloseHandle(pi.hProcess);\n\t}\n\telse\n\t{\n\t\tHKEY hKey;\n\t\tDWORD disposition;\n\t\tLONG result;\n\t\tTCHAR lpClass[1]{};\n\t\tresult = ::RegCreateKeyEx(HKEY_CURRENT_USER, \n\t\t\t_T(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\"), 0, lpClass/*_T(\"\")*/,\n\t\t\tREG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &disposition);\n\t\tif(result == ERROR_SUCCESS)\n\t\t{\n\t\t\t::RegDeleteValue(hKey, _T(\"CrystalDiskInfo\"));\n\t\t\t::RegCloseKey(hKey);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nvoid CDiskInfoDlg::OnCelsius()\n{\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_CELSIUS, ID_FAHRENHEIT, ID_CELSIUS, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\tm_bFahrenheit = FALSE;\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Temperature\"), _T(\"0\"), m_Ini);\n\n\tSelectDrive(m_SelectDisk);\n}\n\nvoid CDiskInfoDlg::OnFahrenheit()\n{\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_CELSIUS, ID_FAHRENHEIT, ID_FAHRENHEIT, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\tm_bFahrenheit = TRUE;\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Temperature\"), _T(\"1\"), m_Ini);\n\n\tSelectDrive(m_SelectDisk);\n}\n\nvoid CDiskInfoDlg::OnAutoAamApm()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bAutoAamApm)\n\t{\n\t\tm_bAutoAamApm = FALSE;\n\t\tmenu->CheckMenuItem(ID_AUTO_AAM_APM, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AutoAamApm\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bAutoAamApm = TRUE;\n\t\tmenu->CheckMenuItem(ID_AUTO_AAM_APM, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AutoAamApm\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbSat()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_Ata.FlagUsbSat)\n\t{\n\t\tm_Ata.FlagUsbSat = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_SAT, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"SAT\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbSat = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_SAT, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"SAT\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbIodata()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_Ata.FlagUsbIodata)\n\t{\n\t\tm_Ata.FlagUsbIodata = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_IODATA, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"IODATA\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbIodata = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_IODATA, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"IODATA\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbSunplus()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_Ata.FlagUsbSunplus)\n\t{\n\t\tm_Ata.FlagUsbSunplus = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_SUNPLUS, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"Sunplus\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbSunplus = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_SUNPLUS, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"Sunplus\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbLogitec()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_Ata.FlagUsbLogitec)\n\t{\n\t\tm_Ata.FlagUsbLogitec = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_LOGITEC, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"Logitec\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbLogitec = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_LOGITEC, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"Logitec\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbProlific()\n{\n\tCMenu *menu = GetMenu();\n\tif (m_Ata.FlagUsbProlific)\n\t{\n\t\tm_Ata.FlagUsbProlific = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_PROLIFIC, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"Prolific\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbProlific = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_PROLIFIC, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"Prolific\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbJmicron()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_Ata.FlagUsbJmicron)\n\t{\n\t\tm_Ata.FlagUsbJmicron = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_JMICRON, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"JMicron\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbJmicron = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_JMICRON, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"JMicron\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbCypress()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_Ata.FlagUsbCypress)\n\t{\n\t\tm_Ata.FlagUsbCypress = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_CYPRESS, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"Cypress\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbCypress = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_CYPRESS, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"Cypress\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbMemory()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_Ata.FlagUsbMemory)\n\t{\n\t\tm_Ata.FlagUsbMemory = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_MEMORY, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"UsbMemory\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbMemory = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_MEMORY, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"UsbMemory\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\n/*\nvoid CDiskInfoDlg::OnUsbSat16()\n{\n\tCMenu* menu = GetMenu();\n\tif (m_Ata.FlagUsbSat16)\n\t{\n\t\tm_Ata.FlagUsbSat16 = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_SAT16, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"UsbSAT16\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbSat16 = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_SAT16, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"UsbSAT16\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n*/\n\nvoid CDiskInfoDlg::OnUsbNVMeJMicron()\n{\n\tCMenu *menu = GetMenu();\n\tif (m_Ata.FlagUsbNVMeJMicron)\n\t{\n\t\tm_Ata.FlagUsbNVMeJMicron = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_NVME_JMICRON, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"NVMeJMicron\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbNVMeJMicron = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_NVME_JMICRON, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"NVMeJMicron\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbNVMeJMicron3()\n{\n\tCMenu* menu = GetMenu();\n\tif (m_Ata.FlagUsbNVMeJMicron3)\n\t{\n\t\tm_Ata.FlagUsbNVMeJMicron3 = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_NVME_JMICRON3, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"NVMeJMicron3\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbNVMeJMicron3 = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_NVME_JMICRON3, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"NVMeJMicron3\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbNVMeASMedia()\n{\n\tCMenu *menu = GetMenu();\n\tif (m_Ata.FlagUsbNVMeASMedia)\n\t{\n\t\tm_Ata.FlagUsbNVMeASMedia = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_NVME_ASMEDIA, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"NVMeASMedia\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbNVMeASMedia = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_NVME_ASMEDIA, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"NVMeASMedia\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbNVMeRealtek()\n{\n\tCMenu *menu = GetMenu();\n\tif (m_Ata.FlagUsbNVMeRealtek)\n\t{\n\t\tm_Ata.FlagUsbNVMeRealtek = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_NVME_REALTEK, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"NVMeRealtek\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbNVMeRealtek = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_NVME_REALTEK, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"NVMeRealtek\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnAMD_RC2()\n{\n\tCMenu* menu = GetMenu();\n\tif (m_Ata.FlagAMD_RC2)\n\t{\n\t\tm_Ata.FlagAMD_RC2 = FALSE;\n\t\tmenu->CheckMenuItem(ID_AMD_RC2T7, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AMD_RC2\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagAMD_RC2 = TRUE;\n\t\tmenu->CheckMenuItem(ID_AMD_RC2T7, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AMD_RC2\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnMegaRAID()\n{\n\tCMenu *menu = GetMenu();\n\tif (m_Ata.FlagMegaRAID)\n\t{\n\t\tm_Ata.FlagMegaRAID = FALSE;\n\t\tmenu->CheckMenuItem(ID_MEGA_RAID, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"MegaRAID\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagMegaRAID = TRUE;\n\t\tmenu->CheckMenuItem(ID_MEGA_RAID, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"MegaRAID\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnIntelVROC()\n{\n\tCMenu* menu = GetMenu();\n\tif (m_Ata.FlagIntelVROC)\n\t{\n\t\tm_Ata.FlagIntelVROC = FALSE;\n\t\tmenu->CheckMenuItem(ID_INTEL_VROC, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"IntelVROC\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagIntelVROC = TRUE;\n\t\tmenu->CheckMenuItem(ID_INTEL_VROC, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"IntelVROC\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbASM1352R()\n{\n\tCMenu* menu = GetMenu();\n\tif (m_Ata.FlagUsbASM1352R)\n\t{\n\t\tm_Ata.FlagUsbASM1352R = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_ASM1352R, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"ASM1352R\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbASM1352R = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_ASM1352R, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"ASM1352R\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbRealtek9220DP()\n{\n\tCMenu * menu = GetMenu();\n\tif (m_Ata.FlagUsbRealtek9220DP)\n\t{\n\t\tm_Ata.FlagUsbRealtek9220DP = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_REALTEK9220DP, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"RTL9220DP\"), _T(\"0\"), m_Ini);\n\t\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbRealtek9220DP = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_REALTEK9220DP, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"USB\"), _T(\"RTL9220DP\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbJMS56X()\n{\n\tCMenu* menu = GetMenu();\n\tif (m_Ata.FlagUsbJMS56X)\n\t{\n\t\tm_Ata.FlagUsbJMS56X = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_JMS56X, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"JMS56X\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbJMS56X = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_JMS56X, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"JMS56X\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbJMB39X()\n{\n\tCMenu* menu = GetMenu();\n\tif (m_Ata.FlagUsbJMB39X)\n\t{\n\t\tm_Ata.FlagUsbJMB39X = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_JMB39X, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"JMB39X\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbJMB39X = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_JMB39X, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"JMB39X\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbJMS586_20()\n{\n\tCMenu* menu = GetMenu();\n\tif (m_Ata.FlagUsbJMS586_20)\n\t{\n\t\tm_Ata.FlagUsbJMS586_20 = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_JMS586_20, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"JMS586_20\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbJMS586_20 = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_JMS586_20, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"JMS586_20\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbJMS586_40()\n{\n\tCMenu* menu = GetMenu();\n\tif (m_Ata.FlagUsbJMS586_40)\n\t{\n\t\tm_Ata.FlagUsbJMS586_40 = FALSE;\n\t\tmenu->CheckMenuItem(ID_USB_JMS586_40, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"JMS586_40\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_Ata.FlagUsbJMS586_40 = TRUE;\n\t\tmenu->CheckMenuItem(ID_USB_JMS586_40, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"JMS586_40\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnUsbEnableAll()\n{\n\tm_Ata.FlagUsbSat     = FALSE;\n\tm_Ata.FlagUsbIodata  = FALSE;\n\tm_Ata.FlagUsbSunplus = FALSE;\n\tm_Ata.FlagUsbLogitec = FALSE;\n\tm_Ata.FlagUsbProlific = FALSE;\n\tm_Ata.FlagUsbJmicron = FALSE;\n\tm_Ata.FlagUsbCypress = FALSE;\n\tm_Ata.FlagUsbASM1352R = FALSE;\n\tm_Ata.FlagUsbJMS56X = FALSE;\n\tm_Ata.FlagUsbJMB39X = FALSE;\n\tm_Ata.FlagUsbJMS586_20 = FALSE;\n\tm_Ata.FlagUsbJMS586_40 = FALSE;\n\tm_Ata.FlagUsbMemory  = FALSE;\n\t//\tm_Ata.FlagUsbSat16 = FALSE;\n\tm_Ata.FlagUsbNVMeJMicron3 = FALSE;\n\tm_Ata.FlagUsbNVMeJMicron = FALSE;\n\tm_Ata.FlagUsbNVMeASMedia = FALSE;\n\tm_Ata.FlagUsbNVMeRealtek = FALSE;\n\tm_Ata.FlagUsbRealtek9220DP = FALSE;\n\n\tOnUsbSat();\n\tOnUsbIodata();\n\tOnUsbSunplus();\n\tOnUsbLogitec();\n\tOnUsbProlific();\n\tOnUsbJmicron();\n\tOnUsbCypress();\n\tOnUsbASM1352R();\n\tOnUsbRealtek9220DP();\n\tOnUsbJMS56X();\n\tOnUsbJMB39X();\n\tOnUsbJMS586_20();\n\tOnUsbJMS586_40();\n\tOnUsbMemory();\n//\tOnUsbSat16();\n\tOnUsbNVMeJMicron3();\n\tOnUsbNVMeJMicron();\n\tOnUsbNVMeASMedia();\n\tOnUsbNVMeRealtek();\n}\n\nvoid CDiskInfoDlg::OnUsbDisableAll()\n{\n\tm_Ata.FlagUsbSat     = TRUE;\n\tm_Ata.FlagUsbIodata  = TRUE;\n\tm_Ata.FlagUsbSunplus = TRUE;\n\tm_Ata.FlagUsbLogitec = TRUE;\n\tm_Ata.FlagUsbProlific = TRUE;\n\tm_Ata.FlagUsbJmicron = TRUE;\n\tm_Ata.FlagUsbCypress = TRUE;\n\tm_Ata.FlagUsbASM1352R = TRUE;\n\tm_Ata.FlagUsbJMS56X = TRUE;\n\tm_Ata.FlagUsbJMB39X = TRUE;\n\tm_Ata.FlagUsbJMS586_20 = TRUE;\n\tm_Ata.FlagUsbJMS586_40 = TRUE;\n\tm_Ata.FlagUsbMemory  = TRUE;\n//\tm_Ata.FlagUsbSat16 = FALSE;\n\tm_Ata.FlagUsbNVMeJMicron3 = TRUE;\n\tm_Ata.FlagUsbNVMeJMicron = TRUE;\n\tm_Ata.FlagUsbNVMeASMedia = TRUE;\n\tm_Ata.FlagUsbNVMeRealtek = TRUE;\n\tm_Ata.FlagUsbRealtek9220DP = TRUE;\n\n\tOnUsbSat();\n\tOnUsbIodata();\n\tOnUsbSunplus();\n\tOnUsbLogitec();\n\tOnUsbProlific();\n\tOnUsbJmicron();\n\tOnUsbCypress();\n\tOnUsbASM1352R();\n\tOnUsbRealtek9220DP();\n\tOnUsbJMS56X();\n\tOnUsbJMB39X();\n\tOnUsbJMS586_20();\n\tOnUsbJMS586_40();\n\tOnUsbMemory();\n//\tOnUsbSat16();\n\tOnUsbNVMeJMicron3();\n\tOnUsbNVMeJMicron();\n\tOnUsbNVMeASMedia();\n\tOnUsbNVMeRealtek();\n}\n\nvoid CDiskInfoDlg::OnDumpIdentifyDevice()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bDumpIdentifyDevice)\n\t{\n\t\tm_bDumpIdentifyDevice = FALSE;\n\t\tmenu->CheckMenuItem(ID_DUMP_IDENTIFY_DEVICE, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"DumpIdentifyDevice\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bDumpIdentifyDevice = TRUE;\n\t\tmenu->CheckMenuItem(ID_DUMP_IDENTIFY_DEVICE, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"DumpIdentifyDevice\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnDumpSmartReadData()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bDumpSmartReadData)\n\t{\n\t\tm_bDumpSmartReadData = FALSE;\n\t\tmenu->CheckMenuItem(ID_DUMP_SMART_READ_DATA, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"DumpSmartReadData\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bDumpSmartReadData = TRUE;\n\t\tmenu->CheckMenuItem(ID_DUMP_SMART_READ_DATA, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"DumpSmartReadData\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnDumpSmartReadThreshold()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bDumpSmartReadThreshold)\n\t{\n\t\tm_bDumpSmartReadThreshold = FALSE;\n\t\tmenu->CheckMenuItem(ID_DUMP_SMART_READ_THRESHOLD, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"DumpSmartReadThreshold\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bDumpSmartReadThreshold = TRUE;\n\t\tmenu->CheckMenuItem(ID_DUMP_SMART_READ_THRESHOLD, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"DumpSmartReadThreshold\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\n\nvoid CDiskInfoDlg::OnAsciiView()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bAsciiView)\n\t{\n\t\tm_bAsciiView = FALSE;\n\t\tmenu->CheckMenuItem(ID_ASCII_VIEW, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AsciiView\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bAsciiView = TRUE;\n\t\tmenu->CheckMenuItem(ID_ASCII_VIEW, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AsciiView\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnSmartEnglish()\n{\n\tCMenu *menu = GetMenu();\n\tif(m_bSmartEnglish)\n\t{\n\t\tm_bSmartEnglish = FALSE;\n\t\tmenu->CheckMenuItem(ID_SMART_ENGLISH, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"SmartEnglish\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bSmartEnglish = TRUE;\n\t\tmenu->CheckMenuItem(ID_SMART_ENGLISH, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"SmartEnglish\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tUpdateListCtrl(m_SelectDisk);\n}\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\nvoid CDiskInfoDlg::OnStartupVoice()\n{\n\tCMenu* menu = GetMenu();\n\tif (m_bStartupVoice)\n\t{\n\t\tm_bStartupVoice = FALSE;\n\t\tmenu->CheckMenuItem(ID_STARTUP_VOICE, MF_UNCHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"StartupVoice\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bStartupVoice = TRUE;\n\t\tmenu->CheckMenuItem(ID_STARTUP_VOICE, MF_CHECKED);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"StartupVoice\"), _T(\"1\"), m_Ini);\n\t}\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n#endif\n\n#ifdef SUISHO_AOI_SUPPORT\nvoid CDiskInfoDlg::OnVoiceEnglish()\n{\n\tCMenu* menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_VOICE_ENGLISH, ID_VOICE_JAPANESE, ID_VOICE_ENGLISH, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"VoiceLanguage\"), L\"English\", m_Ini);\n\tm_VoiceLanguage = L\"English\";\n\n\tTCHAR* ptrEnd;\n\tTCHAR tmp[MAX_PATH] = {};\n\tGetModuleFileName(NULL, tmp, MAX_PATH);\n\tif ((ptrEnd = _tcsrchr(tmp, '\\\\')) != NULL)\n\t{\n\t\t*ptrEnd = '\\0';\n\t}\n\tm_VoicePath.Format(_T(\"%s\\\\%s\"), tmp, AOI_VOICE_EN_PATH);\n\n\tif (m_hVoice != NULL)\n\t{\n\t\tFreeLibrary(m_hVoice);\n\t\tm_hVoice = LoadLibrary(m_VoicePath);\n\t}\n}\n\nvoid CDiskInfoDlg::OnVoiceJapanese()\n{\n\tCMenu* menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_VOICE_ENGLISH, ID_VOICE_JAPANESE, ID_VOICE_JAPANESE, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"VoiceLanguage\"), L\"Japanese\", m_Ini);\n\tm_VoiceLanguage = L\"Japanese\";\n\n\tTCHAR* ptrEnd;\n\tTCHAR tmp[MAX_PATH] = {};\n\tGetModuleFileName(NULL, tmp, MAX_PATH);\n\tif ((ptrEnd = _tcsrchr(tmp, '\\\\')) != NULL)\n\t{\n\t\t*ptrEnd = '\\0';\n\t}\n\tm_VoicePath.Format(_T(\"%s\\\\%s\"), tmp, AOI_VOICE_JA_PATH);\n\n\tif (m_hVoice != NULL)\n\t{\n\t\tFreeLibrary(m_hVoice);\n\t\tm_hVoice = LoadLibrary(m_VoicePath);\n\t}\n}\n#endif\n\nvoid CDiskInfoDlg::OnFontSetting()\n{\n\tCFontSelectionDlg fontSelection(this);\n\tif (fontSelection.DoModal() == IDOK)\n\t{\n\t\tm_FontFace = fontSelection.GetFontFace();\n\t\tm_FontScale = fontSelection.GetFontScale();\n\t\tm_FontRatio = m_FontScale / 100.0;\n\t\tm_FontRender = fontSelection.GetFontRender();\n\n\t\tCString cstr;\n\t\tWritePrivateProfileStringFx(L\"Setting\", L\"FontFace\", m_FontFace, m_Ini);\n\t\tcstr.Format(L\"%d\", m_FontScale);\n\t\tWritePrivateProfileStringFx(L\"Setting\", L\"FontScale\", cstr, m_Ini);\n\t\tcstr.Format(L\"%d\", m_FontRender);\n\t\tWritePrivateProfileStringFx(L\"Setting\", L\"FontRender\", cstr, m_Ini);\n\n\t\tUpdateDialogSize();\n\t}\n}\n\n\nvoid CDiskInfoDlg::OnResidentHide()\n{\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_RESIDENT_HIDE, ID_RESIDENT_MINIMIZE, ID_RESIDENT_HIDE, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\tm_bResidentMinimize = FALSE;\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"ResidentMinimize\"), _T(\"0\"), m_Ini);\n}\n\nvoid CDiskInfoDlg::OnResidentMinimize()\n{\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_RESIDENT_HIDE, ID_RESIDENT_MINIMIZE, ID_RESIDENT_MINIMIZE, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\tm_bResidentMinimize = TRUE;\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"ResidentMinimize\"), _T(\"1\"), m_Ini);\n}\n\nvoid CDiskInfoDlg::OnSortPhysicalDriveId()\n{\n\tCMenu* menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_SORT_PHYSICAL_DRIVE_ID, ID_SORT_DRIVE_LETTER, ID_SORT_PHYSICAL_DRIVE_ID, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\tm_bSortDriveLetter = FALSE;\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"SortDriveLetter\"), _T(\"0\"), m_Ini);\n}\n\nvoid CDiskInfoDlg::OnSortDriveLetter()\n{\n\tCMenu* menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_SORT_PHYSICAL_DRIVE_ID, ID_SORT_DRIVE_LETTER, ID_SORT_DRIVE_LETTER, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\tm_bSortDriveLetter = TRUE;\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"SortDriveLetter\"), _T(\"1\"), m_Ini);\n}\n\nvoid CDiskInfoDlg::OnDriveMenu8()\n{\n\tCMenu* menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_DRIVE_MENU_8, ID_DRIVE_MENU_20, ID_DRIVE_MENU_8, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tm_DriveMenuNumber = 8;\n\tm_bHalfDriveMenu = FALSE;\n\tSelectDrive(0);\n\t\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"DriveMenu\"), _T(\"8\"), m_Ini);\n\n\tUpdateDialogSize();\n}\n\nvoid CDiskInfoDlg::OnDriveMenu16()\n{\n\tCMenu* menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_DRIVE_MENU_8, ID_DRIVE_MENU_20, ID_DRIVE_MENU_16, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tm_DriveMenuNumber = 16;\n\tm_bHalfDriveMenu = TRUE;\n\tSelectDrive(0);\n\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"DriveMenu\"), _T(\"16\"), m_Ini);\n\n\tUpdateDialogSize();\n}\n\n#ifdef MAX_DRIVE_20\nvoid CDiskInfoDlg::OnDriveMenu10()\n{\n\tCMenu* menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_DRIVE_MENU_8, ID_DRIVE_MENU_20, ID_DRIVE_MENU_10, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tm_DriveMenuNumber = 10;\n\tm_bHalfDriveMenu = FALSE;\n\tSelectDrive(0);\n\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"DriveMenu\"), _T(\"10\"), m_Ini);\n\n\tUpdateDialogSize();\n}\n\nvoid CDiskInfoDlg::OnDriveMenu20()\n{\n\tCMenu* menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_DRIVE_MENU_8, ID_DRIVE_MENU_20, ID_DRIVE_MENU_20, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tm_DriveMenuNumber = 20;\n\tm_bHalfDriveMenu = TRUE;\n\tSelectDrive(0);\n\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"DriveMenu\"), _T(\"20\"), m_Ini);\n\n\tUpdateDialogSize();\n}\n#endif\n\nvoid CDiskInfoDlg::OnZoom100()\n{\n\tif(CheckRadioZoomType(ID_ZOOM_100, 100))\n\t{\n\t//\tReExecute();\n\t\tUpdateDialogSize();\n\t}\n}\n\nvoid CDiskInfoDlg::OnZoom125()\n{\n\tif(CheckRadioZoomType(ID_ZOOM_125, 125))\n\t{\n\t//\tReExecute();\n\t\tUpdateDialogSize();\n\t}\n}\n\nvoid CDiskInfoDlg::OnZoom150()\n{\n\tif(CheckRadioZoomType(ID_ZOOM_150, 150))\n\t{\n\t//\tReExecute();\n\t\tUpdateDialogSize();\n\t}\n}\n\nvoid CDiskInfoDlg::OnZoom200()\n{\n\tif(CheckRadioZoomType(ID_ZOOM_200, 200))\n\t{\n\t//\tReExecute();\n\t\tUpdateDialogSize();\n\t}\n}\n\nvoid CDiskInfoDlg::OnZoom250()\n{\n\tif (CheckRadioZoomType(ID_ZOOM_250, 250))\n\t{\n\t\t//\tReExecute();\n\t\tUpdateDialogSize();\n\t}\n}\n\nvoid CDiskInfoDlg::OnZoom300()\n{\n\tif(CheckRadioZoomType(ID_ZOOM_300, 300))\n\t{\n\t//\tReExecute();\n\t\tUpdateDialogSize();\n\t}\n}\n\n\nvoid CDiskInfoDlg::OnZoomAuto()\n{\n\tif(CheckRadioZoomType(ID_ZOOM_AUTO, 0))\n\t{\n\t//\tReExecute();\n\t\tUpdateDialogSize();\n\t}\n}\n\nBOOL CDiskInfoDlg::CheckRadioZoomType(int id, int value)\n{\n\tif(m_ZoomType == value)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_ZOOM_100, ID_ZOOM_AUTO, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tm_ZoomType = value;\n\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), value);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"ZoomType\"), cstr, m_Ini);\n\n\tChangeZoomType(m_ZoomType);\n\n\treturn TRUE;\n}\n\nvoid CDiskInfoDlg::CheckRadioZoomType()\n{\n\tint id = ID_ZOOM_AUTO;\n\n\tswitch(m_ZoomType)\n\t{\n\tcase 100: id = ID_ZOOM_100;\tbreak;\n\tcase 125: id = ID_ZOOM_125;\tbreak;\n\tcase 150: id = ID_ZOOM_150;\tbreak;\n\tcase 200: id = ID_ZOOM_200;\tbreak;\n\tcase 250: id = ID_ZOOM_250;\tbreak;\n\tcase 300: id = ID_ZOOM_300;\tbreak;\n\tdefault:  id = ID_ZOOM_AUTO;\tbreak;\n\t}\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_ZOOM_100, ID_ZOOM_AUTO, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::CheckRadioAutoDetection()\n{\n\tint id = ID_AUTO_DETECTION_DISABLE;\n\n\tswitch(m_AutoDetectionStatus)\n\t{\n\tcase   5: id = ID_AUTO_DETECTION_05_SEC;\tbreak;\n\tcase  10: id = ID_AUTO_DETECTION_10_SEC;\tbreak;\n\tcase  20: id = ID_AUTO_DETECTION_20_SEC;\tbreak;\n\tcase  30: id = ID_AUTO_DETECTION_30_SEC;\tbreak;\n\tdefault:  id = ID_AUTO_DETECTION_DISABLE;\tbreak;\n\t}\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_AUTO_DETECTION_05_SEC, ID_AUTO_DETECTION_DISABLE, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CDiskInfoDlg::OnAutoDetectionDisable()\n{\n\tCheckRadioAutoDetection(ID_AUTO_DETECTION_DISABLE, 0);\n}\n\nvoid CDiskInfoDlg::OnAutoDetection05Sec(){\tCheckRadioAutoDetection(ID_AUTO_DETECTION_05_SEC, 5);}\nvoid CDiskInfoDlg::OnAutoDetection10Sec(){\tCheckRadioAutoDetection(ID_AUTO_DETECTION_10_SEC, 10);\t}\nvoid CDiskInfoDlg::OnAutoDetection20Sec(){\tCheckRadioAutoDetection(ID_AUTO_DETECTION_20_SEC, 20);\t}\nvoid CDiskInfoDlg::OnAutoDetection30Sec(){\tCheckRadioAutoDetection(ID_AUTO_DETECTION_30_SEC, 30);\t}\n\nvoid CDiskInfoDlg::CheckRadioAutoDetection(int id, int value)\n{\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_AUTO_DETECTION_05_SEC, ID_AUTO_DETECTION_DISABLE, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tm_AutoDetectionStatus = value;\n\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), value);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AutoDetection\"), cstr, m_Ini);\n}\n\nvoid CDiskInfoDlg::OnCsmiDisable()\n{\n\tCheckRadioCsmiType(ID_CSMI_DISABLE, 0);\n}\n\nvoid CDiskInfoDlg::OnCsmiEnableAuto()\n{\n\tCheckRadioCsmiType(ID_CSMI_ENABLE_AUTO, 1);\n}\n\nvoid CDiskInfoDlg::OnCsmiEnableRaid()\n{\n\tCheckRadioCsmiType(ID_CSMI_ENABLE_RAID, 2);\n}\n\nvoid CDiskInfoDlg::OnCsmiEnableAll()\n{\n\tCheckRadioCsmiType(ID_CSMI_ENABLE_ALL, 3);\n}\n\nvoid CDiskInfoDlg::CheckRadioCsmiType(int id, int value)\n{\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_CSMI_DISABLE, ID_CSMI_ENABLE_ALL, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tm_Ata.CsmiType = value;\n\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), value);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"CsmiType\"), cstr, m_Ini);\n\n\tOnRescan();\n}\n\nvoid CDiskInfoDlg::CheckRadioCsmiType()\n{\n\tint id = ID_CSMI_DISABLE;\n\n\tswitch(m_Ata.CsmiType)\n\t{\n\tcase   0: id = ID_CSMI_DISABLE;\tbreak;\n\tcase   1: id = ID_CSMI_ENABLE_AUTO;\tbreak;\n\tcase   2: id = ID_CSMI_ENABLE_RAID;\tbreak;\n\tcase   3: id = ID_CSMI_ENABLE_ALL;\tbreak;\n\tdefault:  id = ID_CSMI_ENABLE_AUTO;\tbreak;\n\t}\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_CSMI_DISABLE, ID_CSMI_ENABLE_ALL, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\n/*\nvoid CDiskInfoDlg::OnInstallGadget()\n{\n\tShellExecute(NULL, _T(\"open\"), m_GadgetDir, NULL, NULL, SW_SHOWNORMAL);\n}\n*/\n"
        },
        {
          "name": "DiskInfoDlgTray.cpp",
          "type": "blob",
          "size": 35.6298828125,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\nextern UINT gRegMessageId;\nextern UINT gRegIconId;\n\nvoid CDiskInfoDlg::TaskTrayRightMenu(DWORD index)\n{\n\tPOINT pt;\n\tCreateMainMenu(index);\n\tSetForegroundWindow();\n\tGetCursorPos(&pt);\n\tTrackPopupMenu(m_hMenu, TPM_RIGHTALIGN|TPM_BOTTOMALIGN, pt.x, pt.y, 0, m_hWnd, NULL);\n\tPostMessage(WM_NULL);\n}\n\nLRESULT CDiskInfoDlg::TempIcon(int index, WPARAM wParam, LPARAM lParam)\n{\n\tif (lParam == WM_LBUTTONDOWN)\n\t{\n\t\tShowWindowEx(SW_RESTORE);\n\t\tSelectDrive(index);\n\t}\n\telse if (lParam == WM_RBUTTONDOWN)\n\t{\n\t\tTaskTrayRightMenu(index);\n\t}\n\treturn 0;\n}\n\nLRESULT CDiskInfoDlg::OnTempIcon0(WPARAM w, LPARAM l) { return TempIcon(0, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon1(WPARAM w, LPARAM l) { return TempIcon(1, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon2(WPARAM w, LPARAM l) { return TempIcon(2, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon3(WPARAM w, LPARAM l) { return TempIcon(3, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon4(WPARAM w, LPARAM l) { return TempIcon(4, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon5(WPARAM w, LPARAM l) { return TempIcon(5, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon6(WPARAM w, LPARAM l) { return TempIcon(6, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon7(WPARAM w, LPARAM l) { return TempIcon(7, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon8(WPARAM w, LPARAM l) { return TempIcon(8, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon9(WPARAM w, LPARAM l) { return TempIcon(9, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon10(WPARAM w, LPARAM l) { return TempIcon(10, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon11(WPARAM w, LPARAM l) { return TempIcon(11, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon12(WPARAM w, LPARAM l) { return TempIcon(12, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon13(WPARAM w, LPARAM l) { return TempIcon(13, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon14(WPARAM w, LPARAM l) { return TempIcon(14, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon15(WPARAM w, LPARAM l) { return TempIcon(15, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon16(WPARAM w, LPARAM l) { return TempIcon(16, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon17(WPARAM w, LPARAM l) { return TempIcon(17, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon18(WPARAM w, LPARAM l) { return TempIcon(18, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon19(WPARAM w, LPARAM l) { return TempIcon(19, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon20(WPARAM w, LPARAM l) { return TempIcon(20, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon21(WPARAM w, LPARAM l) { return TempIcon(21, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon22(WPARAM w, LPARAM l) { return TempIcon(22, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon23(WPARAM w, LPARAM l) { return TempIcon(23, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon24(WPARAM w, LPARAM l) { return TempIcon(24, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon25(WPARAM w, LPARAM l) { return TempIcon(25, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon26(WPARAM w, LPARAM l) { return TempIcon(26, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon27(WPARAM w, LPARAM l) { return TempIcon(27, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon28(WPARAM w, LPARAM l) { return TempIcon(28, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon29(WPARAM w, LPARAM l) { return TempIcon(29, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon30(WPARAM w, LPARAM l) { return TempIcon(30, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon31(WPARAM w, LPARAM l) { return TempIcon(31, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon32(WPARAM w, LPARAM l) { return TempIcon(32, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon33(WPARAM w, LPARAM l) { return TempIcon(33, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon34(WPARAM w, LPARAM l) { return TempIcon(34, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon35(WPARAM w, LPARAM l) { return TempIcon(35, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon36(WPARAM w, LPARAM l) { return TempIcon(36, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon37(WPARAM w, LPARAM l) { return TempIcon(37, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon38(WPARAM w, LPARAM l) { return TempIcon(38, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon39(WPARAM w, LPARAM l) { return TempIcon(39, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon40(WPARAM w, LPARAM l) { return TempIcon(40, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon41(WPARAM w, LPARAM l) { return TempIcon(41, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon42(WPARAM w, LPARAM l) { return TempIcon(42, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon43(WPARAM w, LPARAM l) { return TempIcon(43, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon44(WPARAM w, LPARAM l) { return TempIcon(44, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon45(WPARAM w, LPARAM l) { return TempIcon(45, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon46(WPARAM w, LPARAM l) { return TempIcon(46, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon47(WPARAM w, LPARAM l) { return TempIcon(47, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon48(WPARAM w, LPARAM l) { return TempIcon(48, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon49(WPARAM w, LPARAM l) { return TempIcon(49, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon50(WPARAM w, LPARAM l) { return TempIcon(50, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon51(WPARAM w, LPARAM l) { return TempIcon(51, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon52(WPARAM w, LPARAM l) { return TempIcon(52, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon53(WPARAM w, LPARAM l) { return TempIcon(53, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon54(WPARAM w, LPARAM l) { return TempIcon(54, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon55(WPARAM w, LPARAM l) { return TempIcon(55, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon56(WPARAM w, LPARAM l) { return TempIcon(56, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon57(WPARAM w, LPARAM l) { return TempIcon(57, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon58(WPARAM w, LPARAM l) { return TempIcon(58, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon59(WPARAM w, LPARAM l) { return TempIcon(59, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon60(WPARAM w, LPARAM l) { return TempIcon(60, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon61(WPARAM w, LPARAM l) { return TempIcon(61, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon62(WPARAM w, LPARAM l) { return TempIcon(62, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon63(WPARAM w, LPARAM l) { return TempIcon(63, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon64(WPARAM w, LPARAM l) { return TempIcon(64, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon65(WPARAM w, LPARAM l) { return TempIcon(65, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon66(WPARAM w, LPARAM l) { return TempIcon(66, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon67(WPARAM w, LPARAM l) { return TempIcon(67, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon68(WPARAM w, LPARAM l) { return TempIcon(68, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon69(WPARAM w, LPARAM l) { return TempIcon(69, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon70(WPARAM w, LPARAM l) { return TempIcon(70, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon71(WPARAM w, LPARAM l) { return TempIcon(71, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon72(WPARAM w, LPARAM l) { return TempIcon(72, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon73(WPARAM w, LPARAM l) { return TempIcon(73, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon74(WPARAM w, LPARAM l) { return TempIcon(74, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon75(WPARAM w, LPARAM l) { return TempIcon(75, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon76(WPARAM w, LPARAM l) { return TempIcon(76, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon77(WPARAM w, LPARAM l) { return TempIcon(77, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon78(WPARAM w, LPARAM l) { return TempIcon(78, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon79(WPARAM w, LPARAM l) { return TempIcon(79, w, l); }\n/*\nLRESULT CDiskInfoDlg::OnTempIcon80(WPARAM w, LPARAM l) { return TempIcon(80, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon81(WPARAM w, LPARAM l) { return TempIcon(81, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon82(WPARAM w, LPARAM l) { return TempIcon(82, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon83(WPARAM w, LPARAM l) { return TempIcon(83, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon84(WPARAM w, LPARAM l) { return TempIcon(84, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon85(WPARAM w, LPARAM l) { return TempIcon(85, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon86(WPARAM w, LPARAM l) { return TempIcon(86, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon87(WPARAM w, LPARAM l) { return TempIcon(87, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon88(WPARAM w, LPARAM l) { return TempIcon(88, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon89(WPARAM w, LPARAM l) { return TempIcon(89, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon90(WPARAM w, LPARAM l) { return TempIcon(90, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon91(WPARAM w, LPARAM l) { return TempIcon(91, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon92(WPARAM w, LPARAM l) { return TempIcon(92, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon93(WPARAM w, LPARAM l) { return TempIcon(93, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon94(WPARAM w, LPARAM l) { return TempIcon(94, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon95(WPARAM w, LPARAM l) { return TempIcon(95, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon96(WPARAM w, LPARAM l) { return TempIcon(96, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon97(WPARAM w, LPARAM l) { return TempIcon(97, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon98(WPARAM w, LPARAM l) { return TempIcon(98, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon99(WPARAM w, LPARAM l) { return TempIcon(99, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon100(WPARAM w, LPARAM l) { return TempIcon(100, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon101(WPARAM w, LPARAM l) { return TempIcon(101, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon102(WPARAM w, LPARAM l) { return TempIcon(102, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon103(WPARAM w, LPARAM l) { return TempIcon(103, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon104(WPARAM w, LPARAM l) { return TempIcon(104, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon105(WPARAM w, LPARAM l) { return TempIcon(105, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon106(WPARAM w, LPARAM l) { return TempIcon(106, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon107(WPARAM w, LPARAM l) { return TempIcon(107, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon108(WPARAM w, LPARAM l) { return TempIcon(108, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon109(WPARAM w, LPARAM l) { return TempIcon(109, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon110(WPARAM w, LPARAM l) { return TempIcon(110, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon111(WPARAM w, LPARAM l) { return TempIcon(111, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon112(WPARAM w, LPARAM l) { return TempIcon(112, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon113(WPARAM w, LPARAM l) { return TempIcon(113, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon114(WPARAM w, LPARAM l) { return TempIcon(114, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon115(WPARAM w, LPARAM l) { return TempIcon(115, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon116(WPARAM w, LPARAM l) { return TempIcon(116, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon117(WPARAM w, LPARAM l) { return TempIcon(117, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon118(WPARAM w, LPARAM l) { return TempIcon(118, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon119(WPARAM w, LPARAM l) { return TempIcon(119, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon120(WPARAM w, LPARAM l) { return TempIcon(120, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon121(WPARAM w, LPARAM l) { return TempIcon(121, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon122(WPARAM w, LPARAM l) { return TempIcon(122, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon123(WPARAM w, LPARAM l) { return TempIcon(123, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon124(WPARAM w, LPARAM l) { return TempIcon(124, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon125(WPARAM w, LPARAM l) { return TempIcon(125, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon126(WPARAM w, LPARAM l) { return TempIcon(126, w, l); }\nLRESULT CDiskInfoDlg::OnTempIcon127(WPARAM w, LPARAM l) { return TempIcon(127, w, l); }\n*/\nLRESULT CDiskInfoDlg::OnRegMessage(WPARAM wParam, LPARAM lParam)\n{\n\tif(lParam == WM_LBUTTONDOWN && m_bResidentMinimize)\n\t{\n\t\tif(! IsIconic())\n\t\t{\n\t\t\tShowWindowEx(SW_MINIMIZE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tShowWindowEx(SW_RESTORE);\n\t\t}\n\t}\n\telse if(lParam == WM_LBUTTONDOWN)\n\t{\n\t\tif(IsWindowVisible())\n\t\t{\n\t\t\tShowWindowEx(SW_HIDE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tShowWindowEx(SW_RESTORE);\n\t\t}\n\t}\n\telse if(lParam == WM_RBUTTONDOWN)\n\t{\n\t\tTaskTrayRightMenu(CAtaSmart::MAX_DISK);\n\t}\n\treturn 0;\n}\n\nLRESULT CDiskInfoDlg::OnTaskbarCreated(WPARAM, LPARAM) \n{\n\tif(m_bResident)\n\t{\n\t\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t\t{\n\t\t\tif(m_bTrayTemperatureIcon[i])\n\t\t\t{\n\t\t\t\tm_bTrayTemperatureIcon[i] = FALSE; // Force Add Temperature Icon\n\t\t\t\tAddTemperatureIcon(i);\n\t\t\t}\n\t\t}\n\t\tif(m_bTrayMainIcon)\n\t\t{\n\t\t\tm_bTrayMainIcon = FALSE; // Force Add Main Icon\n\t\t\tAddTrayMainIcon();\n\t\t}\n\t}\n\n\tUpdateToolTip();\n\n\treturn 0;\n}\n\nvoid CDiskInfoDlg::CreateMainMenu(DWORD index)\n{\n\tCString cstr;\n\n\tif(m_hMenu != NULL)\n\t{\n\t\tDestroyMenu(m_hMenu);\n\t}\n\n\tm_hMenu = CreatePopupMenu();\n\tHMENU hSubMenu = CreateMenu();\n\n\n\tHMENU hDiskTemp[CAtaSmart::MAX_DISK + 1];\n\tHMENU hDiskMenu[CAtaSmart::MAX_DISK + 1];\n\tHMENU hDiskHealth;\n\n\tMENUITEMINFO menuInfo;\n\tZeroMemory(&menuInfo, sizeof(MENUITEMINFO));\n\tmenuInfo.cbSize = sizeof(MENUITEMINFO);\n\tmenuInfo.fMask = MIIM_CHECKMARKS|MIIM_TYPE|MIIM_STATE|MIIM_ID|MIIM_SUBMENU;\n\tmenuInfo.fType = MFT_RADIOCHECK;\n\tmenuInfo.hbmpChecked = NULL;\n\tmenuInfo.fState = MFS_UNCHECKED;\n\n\tMENUITEMINFO subMenuInfo;\n\tZeroMemory(&subMenuInfo, sizeof(MENUITEMINFO));\n\tsubMenuInfo.cbSize = sizeof(MENUITEMINFO);\n\tsubMenuInfo.fMask = MIIM_CHECKMARKS|MIIM_TYPE|MIIM_STATE|MIIM_ID|MIIM_SUBMENU;\n\tsubMenuInfo.fType = MFT_RADIOCHECK;\n\tsubMenuInfo.hbmpChecked = NULL;\n\tsubMenuInfo.fState = MFS_UNCHECKED;\n\tsubMenuInfo.hSubMenu = NULL;\n\n\tMENUITEMINFO subSubMenuInfo;\n\tZeroMemory(&subSubMenuInfo, sizeof(MENUITEMINFO));\n\tsubSubMenuInfo.cbSize = sizeof(MENUITEMINFO);\n\tsubSubMenuInfo.fMask = MIIM_CHECKMARKS|MIIM_TYPE|MIIM_STATE|MIIM_ID|MIIM_SUBMENU;\n\tsubSubMenuInfo.fType = MFT_RADIOCHECK;\n\tsubSubMenuInfo.hbmpChecked = NULL;\n\tsubSubMenuInfo.fState = MFS_UNCHECKED;\n\tsubSubMenuInfo.hSubMenu = NULL;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Alarm Temperature & Temperature Icon\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\thDiskTemp[i] = CreateMenu();\n\t\thDiskMenu[i] = CreateMenu();\n\t\tfor(int j = 20; j <= 80; j++)\n\t\t{\n\t\t\tif(m_bFahrenheit)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%d C (%d F)\"), j, j * 9 / 5 + 32);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%d C\"), j);\n\t\t\t}\n\n\t\t\tsubSubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\t\t\tsubSubMenuInfo.wID = ALARM_SETTING_TEMPERATURE_BASE + i * 100 + j;\n\t\t\tif(m_Ata.vars[i].AlarmTemperature == j)\n\t\t\t{\n\t\t\t\tsubSubMenuInfo.fState = MFS_CHECKED;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsubSubMenuInfo.fState = MFS_UNCHECKED;\n\t\t\t}\n\t\t\tInsertMenuItem(hDiskTemp[i], -1, TRUE, &subSubMenuInfo);\n\t\t}\n\t\tcstr = i18n(_T(\"TrayMenu\"), _T(\"DISABLE\"));\n\t\tsubSubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\t\tsubSubMenuInfo.wID = ALARM_SETTING_TEMPERATURE_BASE + i * 100 + 0;\n\t\tif(m_Ata.vars[i].AlarmTemperature == 0)\n\t\t{\n\t\t\tsubSubMenuInfo.fState = MFS_CHECKED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsubSubMenuInfo.fState = MFS_UNCHECKED;\n\t\t}\n\t\tInsertMenuItem(hDiskTemp[i], -1, TRUE, &subSubMenuInfo);\n\n\t\tcstr = i18n(_T(\"TrayMenu\"), _T(\"ALARM_SETTING_TEMPERATURE\"));\n\t\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\t\tsubMenuInfo.wID= 0;\n\t\tif(m_Ata.vars[i].Temperature <= 0)\n\t\t{\n\t\t\tsubMenuInfo.fState = MFS_DISABLED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsubMenuInfo.fState = MFS_UNCHECKED;\n\t\t}\n\t\tsubMenuInfo.hSubMenu = hDiskTemp[i];\n\t\tInsertMenuItem(hDiskMenu[i], -1, TRUE, &subMenuInfo);\n\n\t\tsubMenuInfo.fType = 0;\n\t\tcstr = i18n(_T(\"TrayMenu\"), _T(\"ALARM_SETTING_HEALTH_STATUS\"));\n\t\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\t\tif(m_Ata.vars[i].AlarmHealthStatus)\n\t\t{\n\t\t\tsubMenuInfo.fState = MFS_CHECKED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsubMenuInfo.fState = MFS_UNCHECKED;\n\t\t}\n\t\tsubMenuInfo.wID = ALARM_SETTING_HEALTH_STATUS_BASE + i;\n\t\tsubMenuInfo.hSubMenu = NULL;\n\t\tInsertMenuItem(hDiskMenu[i], -1, TRUE, &subMenuInfo);\n\n\t\tcstr = i18n(_T(\"TrayMenu\"), _T(\"SHOW_TEMPERATURE_ICON\"));\n\t\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\t\tsubMenuInfo.fType = 0;\n\n\t\tif(m_Ata.vars[i].Temperature <= 0)\n\t\t{\n\t\t\tsubMenuInfo.fState = MFS_DISABLED;\n\t\t}\n\t\telse if(m_bTrayTemperatureIcon[i])\n\t\t{\n\t\t\tsubMenuInfo.fState = MFS_CHECKED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsubMenuInfo.fState = MFS_UNCHECKED;\n\t\t}\n\t\tsubMenuInfo.wID = TRAY_TEMPERATURE_ICON_BASE + i;\n\t\tsubMenuInfo.hSubMenu = NULL;\n\t\tInsertMenuItem(hDiskMenu[i], -1, TRUE, &subMenuInfo);\n\t\t\n\t\tcstr = i18n(_T(\"TrayMenu\"), _T(\"AUTO_REFRESH_TARGET\"));\n\t\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\t\tsubMenuInfo.fType = 0;\n\n\t\tif(m_bAutoRefreshTarget[i])\n\t\t{\n\t\t\tsubMenuInfo.fState = MFS_CHECKED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsubMenuInfo.fState = MFS_UNCHECKED;\n\t\t}\n\t\tsubMenuInfo.wID = AUTO_REFRESH_TARGET_BASE + i;\n\t\tsubMenuInfo.hSubMenu = NULL;\n\t\tInsertMenuItem(hDiskMenu[i], -1, TRUE, &subMenuInfo);\n\n\t\tCString cstr;\n\t\tcstr.Format(_T(\"(%d) %s\"), i + 1, m_Ata.vars[i].Model.GetString());\n\t\tmenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\t\tmenuInfo.wID = 0;\n\t\tmenuInfo.hSubMenu = hDiskMenu[i];\n\t\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\t}\n\n\t//\tCollective Setting\n\thDiskTemp[CAtaSmart::MAX_DISK] = CreateMenu();\n\thDiskMenu[CAtaSmart::MAX_DISK] = CreateMenu();\n\thDiskHealth = CreateMenu();\n\tfor(int j = 20; j <= 80; j++)\n\t{\n\t\tif(m_bFahrenheit)\n\t\t{\n\t\t\tcstr.Format(_T(\"%d C (%d F)\"), j, j * 9 / 5 + 32);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"%d C\"), j);\n\t\t}\n\t\tsubSubMenuInfo.fState = MFS_UNCHECKED;\n\t\tsubSubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\t\tsubSubMenuInfo.wID = ALARM_SETTING_TEMPERATURE_BASE + CAtaSmart::MAX_DISK * 100 + j;\n\t\tInsertMenuItem(hDiskTemp[CAtaSmart::MAX_DISK], -1, TRUE, &subSubMenuInfo);\n\t}\n\tsubMenuInfo.fState = MFS_UNCHECKED;\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"DISABLE\"));\n\tsubSubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubSubMenuInfo.wID = ALARM_SETTING_TEMPERATURE_BASE + CAtaSmart::MAX_DISK * 100 + 0;\n\tInsertMenuItem(hDiskTemp[CAtaSmart::MAX_DISK], -1, TRUE, &subSubMenuInfo);\n\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"ALARM_SETTING_TEMPERATURE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.wID= 0;\n\tsubMenuInfo.hSubMenu = hDiskTemp[CAtaSmart::MAX_DISK];\n\tInsertMenuItem(hDiskMenu[CAtaSmart::MAX_DISK], -1, TRUE, &subMenuInfo);\n\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"ENABLE_ALL\"));\n\tsubSubMenuInfo.fState = MFS_UNCHECKED;\n\tsubSubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubSubMenuInfo.wID = ALARM_SETTING_HEALTH_STATUS_BASE + CAtaSmart::MAX_DISK;\n\tInsertMenuItem(hDiskHealth, -1, TRUE, &subSubMenuInfo);\n\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"DISABLE_ALL\"));\n\tsubSubMenuInfo.fState = MFS_UNCHECKED;\n\tsubSubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubSubMenuInfo.wID = ALARM_SETTING_HEALTH_STATUS_BASE + CAtaSmart::MAX_DISK + 1;\n\tInsertMenuItem(hDiskHealth, -1, TRUE, &subSubMenuInfo);\n\n\t// All Alarm Health Status == CAtaSmart::MAX_DISK\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"ALARM_SETTING_HEALTH_STATUS\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.fType = 0;\n\tsubMenuInfo.wID = 0;//ALARM_SETTING_HEALTH_STATUS_BASE + CAtaSmart::MAX_DISK;\n\tsubMenuInfo.hSubMenu = hDiskHealth;\n\tInsertMenuItem(hDiskMenu[CAtaSmart::MAX_DISK], -1, TRUE, &subMenuInfo);\n\n\t// Show All == CAtaSmart::MAX_DISK\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"SHOW_ALL_TEMPERATURE_ICON\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.fType = 0;\n\tsubMenuInfo.wID = TRAY_TEMPERATURE_ICON_BASE + CAtaSmart::MAX_DISK;\n\tsubMenuInfo.hSubMenu = NULL;\n\tInsertMenuItem(hDiskMenu[CAtaSmart::MAX_DISK], -1, TRUE, &subMenuInfo);\n\n\t// Hide All == CAtaSmart::MAX_DISK + 1\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"HIDE_ALL_TEMPERATURE_ICON\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.fType = 0;\n\tsubMenuInfo.wID = TRAY_TEMPERATURE_ICON_BASE + CAtaSmart::MAX_DISK + 1;\n\tsubMenuInfo.hSubMenu = NULL;\n\tInsertMenuItem(hDiskMenu[CAtaSmart::MAX_DISK], -1, TRUE, &subMenuInfo);\n\n\t// Target Auto Refresh All Disk == CAtaSmart::MAX_DISK\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"AUTO_REFRESH_TARGET_ALL_DISK\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.fType = 0;\n\tsubMenuInfo.wID= AUTO_REFRESH_TARGET_BASE + CAtaSmart::MAX_DISK;\n\tsubMenuInfo.hSubMenu = NULL;\n\tInsertMenuItem(hDiskMenu[CAtaSmart::MAX_DISK], -1, TRUE, &subMenuInfo);\n\n\t// Untarget Auto Refresh All Disk == CAtaSmart::MAX_DISK + 1\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"AUTO_REFRESH_UNTARGET_ALL_DISK\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.fType = 0;\n\tsubMenuInfo.wID= AUTO_REFRESH_TARGET_BASE + CAtaSmart::MAX_DISK + 1;\n\tsubMenuInfo.hSubMenu = NULL;\n\tInsertMenuItem(hDiskMenu[CAtaSmart::MAX_DISK], -1, TRUE, &subMenuInfo);\n\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"COLLECTIVE_SETTING\"));\n\tmenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tmenuInfo.wID = 0;\n\tmenuInfo.hSubMenu = hDiskMenu[CAtaSmart::MAX_DISK];\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\n\t// Separator\n\tmenuInfo.fType = MFT_SEPARATOR;\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\tmenuInfo.fType = MFT_RADIOCHECK;\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Auto Refresh\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\tsubMenuInfo.fType = MFT_RADIOCHECK;\n\tcstr = _T(\"1 \") + i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.wID= ID_AUTO_REFRESH_01_MIN;\n\tif(m_AutoRefreshStatus == 1){subMenuInfo.fState = MFS_CHECKED;}else{subMenuInfo.fState = MFS_UNCHECKED;}\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n\tcstr = _T(\"3 \") + i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.wID= ID_AUTO_REFRESH_03_MIN;\n\tif(m_AutoRefreshStatus == 3){subMenuInfo.fState = MFS_CHECKED;}else{subMenuInfo.fState = MFS_UNCHECKED;}\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n\tcstr = _T(\"5 \") + i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.wID= ID_AUTO_REFRESH_05_MIN;\n\tif(m_AutoRefreshStatus == 5){subMenuInfo.fState = MFS_CHECKED;}else{subMenuInfo.fState = MFS_UNCHECKED;}\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n\tcstr = _T(\"10 \") + i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.wID= ID_AUTO_REFRESH_10_MIN;\n\tif(m_AutoRefreshStatus == 10){subMenuInfo.fState = MFS_CHECKED;}else{subMenuInfo.fState = MFS_UNCHECKED;}\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n\tcstr = _T(\"30 \") + i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.wID= ID_AUTO_REFRESH_30_MIN;\n\tif(m_AutoRefreshStatus == 30){subMenuInfo.fState = MFS_CHECKED;}else{subMenuInfo.fState = MFS_UNCHECKED;}\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n\tcstr = _T(\"60 \") + i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.wID= ID_AUTO_REFRESH_60_MIN;\n\tif(m_AutoRefreshStatus == 60){subMenuInfo.fState = MFS_CHECKED;}else{subMenuInfo.fState = MFS_UNCHECKED;}\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n\tcstr = _T(\"120 \") + i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR) cstr.GetString();\n\tsubMenuInfo.wID = ID_AUTO_REFRESH_120_MIN;\n\tif (m_AutoRefreshStatus == 120){ subMenuInfo.fState = MFS_CHECKED; }\n\telse{ subMenuInfo.fState = MFS_UNCHECKED; }\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n\tcstr = _T(\"180 \") + i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR) cstr.GetString();\n\tsubMenuInfo.wID = ID_AUTO_REFRESH_180_MIN;\n\tif (m_AutoRefreshStatus == 180){ subMenuInfo.fState = MFS_CHECKED; }\n\telse{ subMenuInfo.fState = MFS_UNCHECKED; }\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n\tcstr = _T(\"360 \") + i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR) cstr.GetString();\n\tsubMenuInfo.wID = ID_AUTO_REFRESH_360_MIN;\n\tif (m_AutoRefreshStatus == 360){ subMenuInfo.fState = MFS_CHECKED; }\n\telse{ subMenuInfo.fState = MFS_UNCHECKED; }\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n\tcstr = _T(\"720 \") + i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR) cstr.GetString();\n\tsubMenuInfo.wID = ID_AUTO_REFRESH_720_MIN;\n\tif (m_AutoRefreshStatus == 720){ subMenuInfo.fState = MFS_CHECKED; }\n\telse{ subMenuInfo.fState = MFS_UNCHECKED; }\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n\tcstr = _T(\"1440 \") + i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR) cstr.GetString();\n\tsubMenuInfo.wID = ID_AUTO_REFRESH_1440_MIN;\n\tif (m_AutoRefreshStatus == 1440){ subMenuInfo.fState = MFS_CHECKED; }\n\telse{ subMenuInfo.fState = MFS_UNCHECKED; }\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"DISABLE\"));\n\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubMenuInfo.wID= ID_AUTO_REFRESH_DISABLE;\n\tif(m_AutoRefreshStatus == 0){subMenuInfo.fState = MFS_CHECKED;}else{subMenuInfo.fState = MFS_UNCHECKED;}\n\tInsertMenuItem(hSubMenu, -1, TRUE, &subMenuInfo);\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Main Menu\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\tmenuInfo.fType = MFT_STRING;\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"AUTO_REFRESH\"));\n\tmenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tmenuInfo.wID = ID_AUTO_REFRESH;\n\tmenuInfo.hSubMenu = hSubMenu;\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\n\tmenuInfo.hSubMenu = NULL;\n\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"REFRESH\"));\n\tmenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tmenuInfo.wID = ID_REFRESH;\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\n\tmenuInfo.fType = MFT_STRING;\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"RESCAN\"));\n\tmenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tmenuInfo.wID = ID_RESCAN;\n\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\tmenuInfo.fType = MFT_SEPARATOR;\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\n\tmenuInfo.fType = MFT_STRING;\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"GRAPH\"));\n\tmenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tmenuInfo.wID = SHOW_GRAPH_BASE + index;\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\n\tmenuInfo.fType = MFT_SEPARATOR;\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\n\tmenuInfo.fType = MFT_STRING;\n\n\tif(m_bShowTemperatureIconOnly)\n\t{\n\t\tmenuInfo.fState = MFS_CHECKED;\n\t}\n\telse\n\t{\n\t\tmenuInfo.fState = MFS_UNCHECKED;\n\t}\n\tif(!IsTemperatureIconExist())\n\t{\n\t\tmenuInfo.fState |= MFS_DISABLED;\n\t}\n\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"SHOW_TEMPERATURE_ICON_ONLY\"));\n\tmenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tmenuInfo.wID = MY_SHOW_TEMPERATURE_ICON_ONLY;\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\n\tif(m_bResidentMinimize)\n\t{\n\t\tif(! IsIconic())\n\t\t{\n\t\t\tmenuInfo.fState = MFS_CHECKED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmenuInfo.fState = MFS_UNCHECKED;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(IsWindowVisible())\n\t\t{\n\t\t\tmenuInfo.fState = MFS_CHECKED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmenuInfo.fState = MFS_UNCHECKED;\n\t\t}\n\t}\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"SHOW_MAIN_WINDOW\"));\n\tmenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tmenuInfo.wID = MY_SHOW_MAIN_DIALOG;\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\n\tmenuInfo.fType = MFT_SEPARATOR;\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"EXIT\"));\n\tmenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tmenuInfo.wID = MY_EXIT;\n\tmenuInfo.fType = MFT_STRING;\n\tmenuInfo.fState = MFS_UNCHECKED;\n\tInsertMenuItem(m_hMenu, -1, TRUE, &menuInfo);\n}\n\n\nBOOL CDiskInfoDlg::AddTemperatureIcon(DWORD i)\n{\n\tif(m_Ata.vars[i].Temperature <= 0 || m_bTrayTemperatureIcon[i] == TRUE)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tCString cstr;\n\tCString diskStatus;\n\tdiskStatus = GetDiskStatus(m_Ata.vars[i].DiskStatus);\n\tcstr.Format(_T(\"(%d) %s [%s]\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(), diskStatus.GetString());\n\n\tcstr += GetLogicalDriveInfo(i, 128);\n\tcstr.TrimRight();\n\n\tINT TemperatureOffset = 0;\n\tif (m_Ata.vars[i].Temperature >= m_Ata.vars[i].AlarmTemperature)\n\t{\n\t\tTemperatureOffset = 200;\n\t}\n\telse if (m_bGreenMode)\n\t{\n\t\tTemperatureOffset = 100;\n\t}\n\n\tif(m_hTempIcon[m_bFahrenheit][TemperatureOffset + m_Ata.vars[i].Temperature] == NULL)\n\t{\n\t\tm_hTempIcon[m_bFahrenheit][TemperatureOffset + m_Ata.vars[i].Temperature] = \n\t\t(HICON)::LoadImageW(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_TEMP_00 + m_bFahrenheit * 300 + TemperatureOffset + m_Ata.vars[i].Temperature), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);\n\t}\n\n\tcstr.Format(L\"CrystalDiskInfo_%2d\", i + 1);\n\n\tif(AddTaskTray(TRAY_TEMPERATURE_ICON_BASE + i, m_TempIconIndex[i], m_hTempIcon[m_bFahrenheit][TemperatureOffset + m_Ata.vars[i].Temperature], cstr))\n\t{\n\t\tm_bTrayTemperatureIcon[i] = TRUE;\n\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nBOOL CDiskInfoDlg::RemoveTemperatureIcon(DWORD i)\n{\n\tif(RemoveTaskTray(TRAY_TEMPERATURE_ICON_BASE + i))\n\t{\n\t\tm_bTrayTemperatureIcon[i] = FALSE;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nBOOL CDiskInfoDlg::ModifyTemperatureIcon(DWORD i)\n{\n\tif(m_Ata.vars[i].Temperature <= 0)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tCString cstr;\n\tCString diskStatus;\n\tdiskStatus = GetDiskStatus(m_Ata.vars[i].DiskStatus);\n\tcstr.Format(_T(\"(%d) %s [%s]\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(), diskStatus.GetString());\n\tcstr += GetLogicalDriveInfo(i, 128);\n\tcstr.TrimRight();\n\n\tINT TemperatureOffset = 0;\n\tif (m_Ata.vars[i].Temperature >= m_Ata.vars[i].AlarmTemperature)\n\t{\n\t\tTemperatureOffset = 200;\n\t}\n\telse if (m_bGreenMode)\n\t{\n\t\tTemperatureOffset = 100;\n\t}\n\n\tif (m_hTempIcon[m_bFahrenheit][TemperatureOffset + m_Ata.vars[i].Temperature] == NULL)\n\t{\n\t\tm_hTempIcon[m_bFahrenheit][TemperatureOffset + m_Ata.vars[i].Temperature] =\n\t\t\t(HICON)::LoadImageW(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_TEMP_00 + m_bFahrenheit * 300 + TemperatureOffset + m_Ata.vars[i].Temperature), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);\n\t}\n\n\tif(ModifyTaskTray(TRAY_TEMPERATURE_ICON_BASE + i, m_hTempIcon[m_bFahrenheit][TemperatureOffset + m_Ata.vars[i].Temperature], cstr))\n\t{\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nvoid CDiskInfoDlg::CheckTrayTemperatureIcon()\n{\n\tfor(int i = (int)m_Ata.vars.GetCount() - 1; i >= 0; i--)\n\t{\n\t\tif(GetPrivateProfileIntFx(_T(\"TemperatureIcon\"), m_Ata.vars[i].ModelSerial, 1, m_Ini))\n\t\t{\n\t\t\tif(m_Ata.vars[i].Temperature > -300)\n\t\t\t{\n\t\t\t\tAddTemperatureIcon(i);\n\t\t\t}\n\t\t}\n\t}\n\tUpdateToolTip();\n}\n\nvoid CDiskInfoDlg::UpdateTrayTemperatureIcon(BOOL flagForce)\n{\n\tstatic int preFlagFahrenheit = -1;\n\tif(preFlagFahrenheit != m_bFahrenheit)\n\t{\n\t\tflagForce = TRUE;\n\t\tpreFlagFahrenheit = m_bFahrenheit;\n\t}\n\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tif(m_Ata.vars[i].Temperature > -300 && (flagForce || m_Ata.vars[i].Temperature != m_PreTemp[i]))\n\t\t{\n\t\t\tm_PreTemp[i] = m_Ata.vars[i].Temperature;\n\t\t\tModifyTemperatureIcon(i);\n\t\t}\n\t}\n}\n\nvoid CDiskInfoDlg::UpdateToolTip()\n{\n\tif(m_bResident)\n\t{\n\t\tCString cstr;\n\t\tCString tipFull, tipMid, tipShort;\n\t\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t\t{\n\t\t\tCString diskStatus;\n\t\t\tdiskStatus = GetDiskStatus(m_Ata.vars[i].DiskStatus);\n\n\t\t\t// Tooltip\n\t\t\tif(m_Ata.vars[i].IsSmartEnabled && m_Ata.vars[i].Temperature > -300)\n\t\t\t{\n\t\t\t\tif(m_bFahrenheit)\n\t\t\t\t{\n\t\t\t\t\tif(m_Ata.vars[i].TotalDiskSize >= 1000)\n\t\t\t\t\t{\n\t\t\t\t\t\tcstr.Format(_T(\"(%d) %s %.1f GB [%s] %d F\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(),\n\t\t\t\t\t\t\tm_Ata.vars[i].TotalDiskSize / 1000.0, diskStatus.GetString(), m_Ata.vars[i].Temperature * 9 / 5 + 32);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcstr.Format(_T(\"(%d) %s %d MB [%s] %d F\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(),\n\t\t\t\t\t\t\tm_Ata.vars[i].TotalDiskSize, diskStatus.GetString(), m_Ata.vars[i].Temperature * 9 / 5 + 32);\n\t\t\t\t\t}\n\t\t\t\t\ttipFull += cstr;\n\t\t\t\t\tcstr.Format(_T(\"(%d) %s %d F\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].Temperature * 9 / 5 + 32);\n\t\t\t\t\ttipMid += cstr;\n\t\t\t\t\tcstr.Format(_T(\"(%d)%dF\\r\\n\"), i + 1, m_Ata.vars[i].Temperature * 9 / 5 + 32);\n\t\t\t\t\ttipShort += cstr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(m_Ata.vars[i].TotalDiskSize >= 1000)\n\t\t\t\t\t{\n\t\t\t\t\t\tcstr.Format(_T(\"(%d) %s %.1f GB [%s] %d C\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(),\n\t\t\t\t\t\t\tm_Ata.vars[i].TotalDiskSize / 1000.0, diskStatus.GetString(), m_Ata.vars[i].Temperature);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcstr.Format(_T(\"(%d) %s %d MB [%s] %d C\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(),\n\t\t\t\t\t\t\tm_Ata.vars[i].TotalDiskSize, diskStatus.GetString(), m_Ata.vars[i].Temperature);\n\t\t\t\t\t}\n\t\t\t\t\ttipFull += cstr;\n\t\t\t\t\tcstr.Format(_T(\"(%d) %s %d C\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].Temperature);\n\t\t\t\t\ttipMid += cstr;\n\t\t\t\t\tcstr.Format(_T(\"(%d)%dC\\r\\n\"), i + 1, m_Ata.vars[i].Temperature);\n\t\t\t\t\ttipShort += cstr;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(m_Ata.vars[i].TotalDiskSize >= 1000)\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"(%d) %s %.1f GB [%s]\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(),\n\t\t\t\t\t\tm_Ata.vars[i].TotalDiskSize / 1000.0, diskStatus.GetString());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"(%d) %s %d MB [%s]\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(),\n\t\t\t\t\t\tm_Ata.vars[i].TotalDiskSize, diskStatus.GetString());\n\t\t\t\t}\n\t\t\t\ttipFull += cstr;\n\t\t\t\tcstr.Format(_T(\"(%d) %s [%s]\\r\\n\"), i + 1, m_Ata.vars[i].Model.GetString(), diskStatus.GetString());\n\t\t\t\ttipMid += cstr;\n\t\t\t\tcstr.Format(_T(\"(%d)[%s]\\r\\n\"), i + 1, diskStatus.GetString());\n\t\t\t\ttipShort += cstr;\n\t\t\t}\n\t\t}\n\n\t\ttipFull.Trim();\n\t\ttipMid.Trim();\n\t\ttipShort.Trim();\n\t\tif(tipFull.GetLength() < 128)\n\t\t{\n\t\t\tm_StatusTip = tipFull;\n\t\t}\n\t\telse if(tipMid.GetLength() < 128)\n\t\t{\n\t\t\tm_StatusTip = tipMid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_StatusTip = tipShort;\n\t\t}\t\n\n\t\tModifyTaskTrayTip(gRegIconId, m_StatusTip);\n\t\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t\t{\n\t\t\tif(m_bTrayTemperatureIcon[i])\n\t\t\t{\n\t\t\t\tModifyTemperatureIcon(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CDiskInfoDlg::CheckResident()\n{\n\tif(GetPrivateProfileInt(_T(\"Setting\"), _T(\"Resident\"), 0, m_Ini) == 0)\n\t{\n\t\tm_bResident = FALSE;\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_RESIDENT, MF_UNCHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\telse\n\t{\n\t\tm_bResident = TRUE;\n\t\tCheckTrayTemperatureIcon();\n\n\t\tif(! m_bShowTemperatureIconOnly || ! IsTemperatureIconExist())\n\t\t{\n\t\t\tAddTrayMainIcon();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t\t\t{\n\t\t\t\tif(m_bTrayTemperatureIcon[i])\n\t\t\t\t{\n\t\t\t\t\tm_MainIconId = TRAY_TEMPERATURE_ICON_BASE + i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_RESIDENT, MF_CHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n}\n\nvoid CDiskInfoDlg::OnResident()\n{\n\tm_bWindowMinimizeOnce = FALSE;\n\tif(m_bResident)\n\t{\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_RESIDENT, MF_UNCHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\n\t\tRemoveTrayMainIcon();\n\t\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t\t{\n\t\t\tif(m_bTrayTemperatureIcon[i])\n\t\t\t{\n\t\t\t\tRemoveTemperatureIcon(i);\n\t\t\t}\n\t\t}\n\t\tm_bResident = FALSE;\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Resident\"), _T(\"0\"), m_Ini);\n\t}\n\telse\n\t{\n\t\tm_bResident = TRUE;\n\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_RESIDENT, MF_CHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Resident\"), _T(\"1\"), m_Ini);\n\t\tCheckTrayTemperatureIcon();\n\n\t\tif(! m_bShowTemperatureIconOnly || ! IsTemperatureIconExist())\n\t\t{\n\t\t\tAddTrayMainIcon();\n\t\t}\n\t}\n}\n\nvoid CDiskInfoDlg::ShowTemperatureIconOnly()\n{\n\tif(m_bShowTemperatureIconOnly)\n\t{\n\t\tm_bShowTemperatureIconOnly = FALSE;\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"ShowTemperatureIconOnly\"), _T(\"0\"), m_Ini);\n\n\t\tAddTrayMainIcon();\n\t}\n\telse\n\t{\n\t\tm_bShowTemperatureIconOnly = TRUE;\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"ShowTemperatureIconOnly\"), _T(\"1\"), m_Ini);\n\n\t\tif(IsTemperatureIconExist())\n\t\t{\n\t\t\tif(RemoveTrayMainIcon())\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t\t\t\t{\n\t\t\t\t\tif(m_bTrayTemperatureIcon[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tm_MainIconId = TRAY_TEMPERATURE_ICON_BASE + i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nBOOL CDiskInfoDlg::AddTrayMainIcon()\n{\n\tif(m_bTrayMainIcon)\n\t{\n\t\treturn TRUE;\n\t}\n\telse if(AddTaskTray(gRegIconId, gRegMessageId, m_hIconMini, L\"CrystalDiskInfo\"))\n\t{\n\t\tm_bTrayMainIcon = TRUE;\n\t\tm_MainIconId = gRegIconId;\n\t}\n\treturn FALSE;\n}\n\nBOOL CDiskInfoDlg::RemoveTrayMainIcon()\n{\n\tif(! m_bTrayMainIcon)\n\t{\n\t\treturn TRUE;\n\t}\n\telse if(RemoveTaskTray(gRegIconId))\n\t{\n\t\tm_bTrayMainIcon = FALSE;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nBOOL CDiskInfoDlg::IsTemperatureIconExist()\n{\n\tfor(int j = 0; j < m_Ata.vars.GetCount(); j++)\n\t{\n\t\tif(m_bTrayTemperatureIcon[j])\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}"
        },
        {
          "name": "DiskInfoDlgUpdate.cpp",
          "type": "blob",
          "size": 83.859375,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\nvoid CDiskInfoDlg::Refresh(DWORD flagForceUpdate)\n{\n\tCWaitCursor wait;\n\tBOOL flagUpdate = FALSE;\n\tDWORD smartUpdate[CAtaSmart::MAX_DISK] = { 0 };\n\n\tfor (int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tif (flagForceUpdate || m_bAutoRefreshTarget[i])\n\t\t{\n\t\t\tswitch (m_Ata.UpdateSmartInfo(i))\n\t\t\t{\n\t\t\tcase CAtaSmart::SMART_STATUS_MAJOR_CHANGE:\n\t\t\t\tflagUpdate = TRUE;\n\t\t\t\tsmartUpdate[i] = CAtaSmart::SMART_STATUS_MAJOR_CHANGE;\n\t\t\t\tSaveSmartInfo(i);\n\t\t\t\tbreak;\n\t\t\tcase CAtaSmart::SMART_STATUS_MINOR_CHANGE:\n\t\t\t\tsmartUpdate[i] = CAtaSmart::SMART_STATUS_MINOR_CHANGE;\n\t\t\t\tSaveSmartInfo(i);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tAlertSound(0, AS_PLAY_SOUND);\n\tif (flagForceUpdate || smartUpdate[m_SelectDisk] == CAtaSmart::SMART_STATUS_MAJOR_CHANGE)\n\t{\n\t\tChangeDisk(m_SelectDisk);\n\t\tUpdateListCtrl(m_SelectDisk);\n\t}\n\telse if (smartUpdate[m_SelectDisk] == CAtaSmart::SMART_STATUS_MINOR_CHANGE)\n\t{\n\t\tUpdateListCtrl(m_SelectDisk);\n\t}\n\n\tif (flagForceUpdate || flagUpdate)\n\t{\n\t\tInitDriveList();\n\t\tUpdateToolTip();\n\n\t\tif (m_bResident)\n\t\t{\n\t\t\tAlarmOverheat();\n\t\t\tUpdateTrayTemperatureIcon(TRUE);\n\t\t}\n\t\tUpdateShareInfo();\n\t}\n}\n\nvoid CDiskInfoDlg::UpdateShareInfo()\n{\n\tif (!m_bGadget || m_Ata.vars.GetCount() == 0)\n\t{\n\t\treturn;\n\t}\n\n\tHKEY hKey, hSubKey;\n\tCString key, cstr;\n\tDWORD result;\n\tDWORD value;\n\tTCHAR str[256]{};\n\tTCHAR lpClass[1]{};\n\n\tSHDeleteKey(HKEY_CURRENT_USER, REGISTRY_PATH);\n\tresult = RegCreateKeyEx(HKEY_CURRENT_USER, REGISTRY_PATH, 0, lpClass/*_T(\"\")*/,\n\t\tREG_OPTION_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);\n\n\tif (result != ERROR_SUCCESS)\n\t{\n\t\treturn;\n\t}\n\n\tvalue = 1;\n\tRegSetValueEx(hKey, _T(\"Version\"), 0, REG_DWORD, (CONST BYTE*)&value, sizeof(DWORD));\n\tvalue = (DWORD)GetTickCountFx();\n\tRegSetValueEx(hKey, _T(\"LastUpdate\"), 0, REG_DWORD, (CONST BYTE*)&value, sizeof(DWORD));\n\tvalue = (DWORD)m_Ata.vars.GetCount();\n\tRegSetValueEx(hKey, _T(\"DiskCount\"), 0, REG_DWORD, (CONST BYTE*)&value, sizeof(DWORD));\n\n\tconstexpr DWORD sizeof_TCHAR = sizeof(TCHAR);\n\tfor (int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tresult = RegCreateKeyEx(hKey, m_Ata.vars[i].ModelSerial, 0, NULL,\n\t\t\tREG_OPTION_VOLATILE, KEY_ALL_ACCESS, NULL, &hSubKey, NULL);\n\t\tif (result != ERROR_SUCCESS)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey.Format(_T(\"Disk%d\"), i);\n\t\twsprintf(str, m_Ata.vars[i].ModelSerial);\n\t\tRegSetValueEx(hKey, key, 0, REG_SZ,\n\t\t\t(CONST BYTE*)&str, (DWORD)(_tcslen(str) + 1) * sizeof_TCHAR);\n\n\n\t\twsprintf(str, m_Ata.vars[i].DriveMap);\n\t\tRegSetValueEx(hSubKey, _T(\"DriveLetter\"), 0, REG_SZ,\n\t\t\t(CONST BYTE*)&str, (DWORD)(_tcslen(str) + 1) * sizeof_TCHAR);\n\t\twsprintf(str, m_Ata.vars[i].Model);\n\t\tRegSetValueEx(hSubKey, _T(\"Model\"), 0, REG_SZ,\n\t\t\t(CONST BYTE*)&str, (DWORD)(_tcslen(str) + 1) * sizeof_TCHAR);\n\n\t\tif (m_Ata.vars[i].TotalDiskSize >= 1000)\n\t\t{\n\t\t\t_stprintf_s(str, 256, _T(\"%.1f GB\"), m_Ata.vars[i].TotalDiskSize / 1000.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_stprintf_s(str, 256, _T(\"%d MB\"), m_Ata.vars[i].TotalDiskSize);\n\t\t}\n\t\tRegSetValueEx(hSubKey, _T(\"DiskSize\"), 0, REG_SZ,\n\t\t\t(CONST BYTE*)&str, (DWORD)(_tcslen(str) + 1) * sizeof_TCHAR);\n\n\t\tif (m_bFahrenheit)\n\t\t{\n\t\t\tif (m_Ata.vars[i].Temperature > -300)\n\t\t\t{\n\t\t\t\tDWORD f = m_Ata.vars[i].Temperature * 9 / 5 + 32;\n\t\t\t\tif (f > 100)\n\t\t\t\t{\n\t\t\t\t\t_stprintf_s(str, 256, _T(\"%d °F\"), f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_stprintf_s(str, 256, _T(\"%d  °F\"), f);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_stprintf_s(str, 256, _T(\"-- °F\"));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (m_Ata.vars[i].Temperature > -300)\n\t\t\t{\n\t\t\t\t_stprintf_s(str, 256, _T(\"%d °C\"), m_Ata.vars[i].Temperature);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_stprintf_s(str, 256, _T(\"-- °C\"));\n\t\t\t}\n\t\t}\n\t\tRegSetValueEx(hSubKey, _T(\"Temperature\"), 0, REG_SZ,\n\t\t\t(CONST BYTE*)&str, (DWORD)(_tcslen(str) + 1) * sizeof_TCHAR);\n\n\t\tcstr = GetTemperatureClass(m_Ata.vars[i].Temperature, m_Ata.vars[i].AlarmTemperature);\n\t\tcstr.Replace(L\"Green\", L\"\");\n\t\t_stprintf_s(str, 256, _T(\"%s\"), (LPCTSTR)cstr);\n\t\tRegSetValueEx(hSubKey, _T(\"TemperatureClass\"), 0, REG_SZ,\n\t\t\t(CONST BYTE*)&str, (DWORD)(_tcslen(str) + 1) * sizeof_TCHAR);\n\n\t\tvalue = m_Ata.vars[i].DiskStatus;\n\t\tRegSetValueEx(hSubKey, _T(\"DiskStatus\"), 0, REG_DWORD, (CONST BYTE*)&value, sizeof(DWORD));\n\n\t\tRegCloseKey(hSubKey);\n\t}\n\tRegCloseKey(hKey);\n}\n\nvoid CDiskInfoDlg::DeleteShareInfo()\n{\n\tSHDeleteKey(HKEY_CURRENT_USER, REGISTRY_PATH);\n}\n\n\nvoid CDiskInfoDlg::RebuildListHeader(DWORD i, BOOL forceUpdate)\n{\n\tstatic DWORD preVendorId = (DWORD)-1;\n\tint width = 0;\n\n\tHMODULE hModule = GetModuleHandle(L\"user32.dll\");\n\ttypedef int(WINAPI* FuncGetSystemMetricsForDpi) (int nIndex, UINT dpi);\n\ttypedef UINT(WINAPI* FuncGetDpiForWindow) (HWND hWnd);\n\tFuncGetSystemMetricsForDpi pGetSystemMetricsForDpi = NULL;\n\tFuncGetDpiForWindow pGetDpiForWindow = NULL;\n\tif (hModule)\n\t{\n\t\tpGetSystemMetricsForDpi = (FuncGetSystemMetricsForDpi)GetProcAddress(hModule, \"GetSystemMetricsForDpi\");\n\t\tpGetDpiForWindow = (FuncGetDpiForWindow)GetProcAddress(hModule, \"GetDpiForWindow\");\n\t}\n\n\tif (pGetSystemMetricsForDpi && pGetDpiForWindow)\n\t{\n\t\twidth = (int)((656 * m_ZoomRatio - (pGetSystemMetricsForDpi(SM_CXVSCROLL, pGetDpiForWindow(m_hWnd)))) - 4);\n\t}\n\telse\n\t{\n\t\twidth = (int)(656 * m_ZoomRatio - GetSystemMetrics(SM_CXVSCROLL) - 4);\n\t}\n\n\tif (m_Ata.vars.GetCount() == 0)\n\t{\n\t\tm_List.InsertColumn(0, _T(\"\"), LVCFMT_CENTER, 0, 0);\n\t\tm_List.EnableHeaderOwnerDraw(TRUE);\n\t\treturn;\n\t}\n\n\tm_List.DeleteAllItems();\n\tif (preVendorId == m_Ata.vars[i].DiskVendorId && !forceUpdate)\n\t{\n\t\treturn;\n\t}\n\n\twhile (m_List.DeleteColumn(0)) {}\n\tif (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_NVME)\n\t{\n\t\tm_List.InsertColumn(0, _T(\"\"), LVCFMT_CENTER, 25, 0);\n\t\tm_List.InsertColumn(1, i18n(_T(\"Dialog\"), _T(\"LIST_ID\"), m_bSmartEnglish), LVCFMT_CENTER, (int)(32 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(3, i18n(_T(\"Dialog\"), _T(\"LIST_CURRENT\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(0 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(4, i18n(_T(\"Dialog\"), _T(\"LIST_WORST\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(0 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(5, i18n(_T(\"Dialog\"), _T(\"LIST_THRESHOLD\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(0 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(6, i18n(_T(\"Dialog\"), _T(\"LIST_RAW_VALUES\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(140 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(2, i18n(_T(\"Dialog\"), _T(\"LIST_ATTRIBUTE_NAME\"), m_bSmartEnglish), LVCFMT_LEFT, (int)(width - 172 * m_ZoomRatio - 25), 0);\n\t\tpreVendorId = m_Ata.SSD_VENDOR_NVME;\n\t}\n\telse if (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDFORCE)\n\t{\n\t\tm_List.InsertColumn(0, _T(\"\"), LVCFMT_CENTER, 25, 0);\n\t\tm_List.InsertColumn(1, i18n(_T(\"Dialog\"), _T(\"LIST_ID\"), m_bSmartEnglish), LVCFMT_CENTER, (int)(32 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(3, i18n(_T(\"Dialog\"), _T(\"LIST_CURRENT\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(72 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(4, i18n(_T(\"Dialog\"), _T(\"LIST_WORST\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(72 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(5, i18n(_T(\"Dialog\"), _T(\"LIST_THRESHOLD\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(72 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(6, i18n(_T(\"Dialog\"), _T(\"LIST_RAW_VALUES\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(136 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(2, i18n(_T(\"Dialog\"), _T(\"LIST_ATTRIBUTE_NAME\"), m_bSmartEnglish), LVCFMT_LEFT, (int)(width - 384 * m_ZoomRatio - 25), 0);\n\t\tpreVendorId = m_Ata.SSD_VENDOR_SANDFORCE;\n\t}\n\t// JMicron 60x\n\telse if (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_JMICRON && m_Ata.vars[i].IsRawValues8)\n\t{\n\t\tm_List.InsertColumn(0, _T(\"\"), LVCFMT_CENTER, 25, 0);\n\t\tm_List.InsertColumn(1, i18n(_T(\"Dialog\"), _T(\"LIST_ID\"), m_bSmartEnglish), LVCFMT_CENTER, (int)(32 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(3, i18n(_T(\"Dialog\"), _T(\"LIST_CURRENT\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(72 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(4, i18n(_T(\"Dialog\"), _T(\"LIST_WORST\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(0 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(5, i18n(_T(\"Dialog\"), _T(\"LIST_THRESHOLD\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(0 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(6, i18n(_T(\"Dialog\"), _T(\"LIST_RAW_VALUES\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(140 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(2, i18n(_T(\"Dialog\"), _T(\"LIST_ATTRIBUTE_NAME\"), m_bSmartEnglish), LVCFMT_LEFT, (int)(width - 244 * m_ZoomRatio - 25), 0);\n\t\tpreVendorId = m_Ata.SSD_VENDOR_JMICRON;\n\t}\n\telse if (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_INDILINX)\n\t{\n\t\tm_List.InsertColumn(0, _T(\"\"), LVCFMT_CENTER, 25, 0);\n\t\tm_List.InsertColumn(1, i18n(_T(\"Dialog\"), _T(\"LIST_ID\"), m_bSmartEnglish), LVCFMT_CENTER, (int)(32 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(3, i18n(_T(\"Dialog\"), _T(\"LIST_CURRENT\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(0 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(4, i18n(_T(\"Dialog\"), _T(\"LIST_WORST\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(0 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(5, i18n(_T(\"Dialog\"), _T(\"LIST_THRESHOLD\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(0 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(6, i18n(_T(\"Dialog\"), _T(\"LIST_RAW_VALUES\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(140 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(2, i18n(_T(\"Dialog\"), _T(\"LIST_ATTRIBUTE_NAME\"), m_bSmartEnglish), LVCFMT_LEFT, (int)(width - 172 * m_ZoomRatio - 25), 0);\n\t\tpreVendorId = m_Ata.SSD_VENDOR_INDILINX;\n\t}\n\telse\n\t{\n\t\tm_List.InsertColumn(0, _T(\"\"), LVCFMT_CENTER, 25, 0);\n\t\tm_List.InsertColumn(1, i18n(_T(\"Dialog\"), _T(\"LIST_ID\"), m_bSmartEnglish), LVCFMT_CENTER, (int)(32 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(3, i18n(_T(\"Dialog\"), _T(\"LIST_CURRENT\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(72 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(4, i18n(_T(\"Dialog\"), _T(\"LIST_WORST\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(72 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(5, i18n(_T(\"Dialog\"), _T(\"LIST_THRESHOLD\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(72 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(6, i18n(_T(\"Dialog\"), _T(\"LIST_RAW_VALUES\"), m_bSmartEnglish), LVCFMT_RIGHT, (int)(108 * m_ZoomRatio), 0);\n\t\tm_List.InsertColumn(2, i18n(_T(\"Dialog\"), _T(\"LIST_ATTRIBUTE_NAME\"), m_bSmartEnglish), LVCFMT_LEFT, (int)(width - 356 * m_ZoomRatio - 25), 0);\n\t\tpreVendorId = m_Ata.HDD_GENERAL;\n\t}\n\n\tm_List.EnableHeaderOwnerDraw(TRUE);\n}\n\nBOOL CDiskInfoDlg::UpdateListCtrl(DWORD i)\n{\n\tstatic DWORD preSelectDisk = 0;\n\n\tif (m_Ata.vars.GetCount() == 0)\n\t{\n\t\tm_List.DeleteAllItems();\n\t\treturn FALSE;\n\t}\n\n\tBOOL flag = FALSE;\n\tif (i == preSelectDisk && m_List.GetItemCount() > 0)\n\t{\n\t\tflag = TRUE;\n\t}\n\telse\n\t{\n\t\tm_List.SetRedraw(FALSE);\n\t\tRebuildListHeader(i);\n\t\tpreSelectDisk = i;\n\t}\n\n\tCString cstr;\n\tDWORD caution = 0;\n\tUINT mask = LVIF_IMAGE;\n\n\tDWORD k = 0;\n\n\tTCHAR str[256];\n\tCString unknown;\n\tCString vendorSpecific;\n\n\t//\tunknown = i18n(_T(\"Smart\"), _T(\"UNKNOWN\"), m_bSmartEnglish);\n\tvendorSpecific = i18n(_T(\"Smart\"), _T(\"VENDOR_SPECIFIC\"), m_bSmartEnglish);\n\n\tfor (DWORD j = 0; j < m_Ata.vars[i].AttributeCount; j++)\n\t{\n\t\tif (m_Ata.vars[i].Attribute[j].Id == 0x00 || m_Ata.vars[i].Attribute[j].Id == 0xFF)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m_Ata.vars[i].IsNVMe)\n\t\t{\n\t\t\tUINT icon = ICON_GOOD + m_bGreenMode;\n\n\t\t\tif (m_Ata.vars[i].Model.Find(_T(\"Parallels\")) == 0\n\t\t\t||  m_Ata.vars[i].Model.Find(_T(\"VMware\")) == 0\n\t\t\t||  m_Ata.vars[i].Model.Find(_T(\"QEMU\")) == 0\n\t\t\t\t)\n\t\t\t{\n\t\t\t\ticon = ICON_UNKNOWN;\n\t\t\t}\n\t\t\telse if (m_Ata.vars[i].Attribute[j].Id == 0x01 && m_Ata.vars[i].Attribute[j].RawValue[0])\n\t\t\t{\n\t\t\t\ticon = ICON_BAD;\n\t\t\t}\n\t\t\telse if (m_Ata.vars[i].Attribute[j].Id == 0x02)\n\t\t\t{\n\t\t\t\tif ((MAKEWORD(m_Ata.vars[i].Attribute[1].RawValue[0], m_Ata.vars[i].Attribute[1].RawValue[1]) - 273) >= m_Ata.vars[i].AlarmTemperature)\n\t\t\t\t{\n\t\t\t\t\ticon = ICON_BAD;\n\t\t\t\t}\n\t\t\t\telse if ((MAKEWORD(m_Ata.vars[i].Attribute[1].RawValue[0], m_Ata.vars[i].Attribute[1].RawValue[1]) - 273) == m_Ata.vars[i].AlarmTemperature)\n\t\t\t\t{\n\t\t\t\t\ticon = ICON_CAUTION;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2022/10/02 Workaround for no support Available Spare Threshold devices\n\t\t\t// https://github.com/hiyohiyo/CrystalDiskInfo/issues/186\n\t\t\telse if (m_Ata.vars[i].Attribute[j].Id == 0x03 && m_Ata.vars[i].Attribute[3].RawValue[0] > 100)\n\t\t\t{\n\t\t\t\ticon = ICON_GOOD;\n\t\t\t}\n\t\t\t// 2022/03/26 Workaround for WD_BLACK AN1500 (No support Available Spare/Available Spare Threshold)\n\t\t\telse if (m_Ata.vars[i].Attribute[j].Id == 0x03 && (m_Ata.vars[i].Attribute[2].RawValue[0] == 0 && m_Ata.vars[i].Attribute[3].RawValue[0] == 0))\n\t\t\t{\n\t\t\t\ticon = ICON_GOOD;\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].Attribute[j].Id == 0x03 && (m_Ata.vars[i].Attribute[2].RawValue[0] < m_Ata.vars[i].Attribute[3].RawValue[0]))\n\t\t\t{\n\t\t\t\ticon = ICON_BAD;\n\t\t\t}\n\t\t\telse if (m_Ata.vars[i].Attribute[j].Id == 0x03 && (m_Ata.vars[i].Attribute[2].RawValue[0] == m_Ata.vars[i].Attribute[3].RawValue[0] && m_Ata.vars[i].Attribute[3].RawValue[0] != 100))\n\t\t\t{\n\t\t\t\ticon = ICON_CAUTION;\n\t\t\t}\n\t\t\telse if (m_Ata.vars[i].Attribute[j].Id == 0x05 && ((100 - m_Ata.vars[i].Attribute[j].RawValue[0]) <= m_Ata.vars[i].ThresholdFF))\n\t\t\t{\n\t\t\t\ticon = ICON_CAUTION;\n\t\t\t}\n\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), icon, 0, 0, 0, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_List.InsertItem(k, _T(\"\"), icon);\n\t\t\t}\n\t\t}\n\t\telse if (m_Ata.vars[i].IsSmartCorrect && m_Ata.vars[i].IsThresholdCorrect && !m_Ata.vars[i].IsThresholdBug)\n\t\t{\n\t\t\tif (!m_Ata.vars[i].IsSsd &&\n\t\t\t\t(m_Ata.vars[i].Attribute[j].Id == 0x05 // Reallocated Sectors Count\n\t\t\t\t\t|| m_Ata.vars[i].Attribute[j].Id == 0xC5 // Current Pending Sector Count\n\t\t\t\t\t|| m_Ata.vars[i].Attribute[j].Id == 0xC6 // Off-Line Scan Uncorrectable Sector Count\n\t\t\t\t\t))\n\t\t\t{\n\t\t\t\tWORD raw = MAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[0], m_Ata.vars[i].Attribute[j].RawValue[1]);\n\t\t\t\tWORD threshold = 0;\n\t\t\t\tswitch (m_Ata.vars[i].Attribute[j].Id)\n\t\t\t\t{\n\t\t\t\tcase 0x05:\n\t\t\t\t\tthreshold = m_Ata.vars[i].Threshold05;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xC5:\n\t\t\t\t\tthreshold = m_Ata.vars[i].ThresholdC5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xC6:\n\t\t\t\t\tthreshold = m_Ata.vars[i].ThresholdC6;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (threshold > 0 && raw >= threshold)\n\t\t\t\t{\n\t\t\t\t\tcaution = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcaution = 0;\n\t\t\t\t}\n\n\t\t\t\tif (m_Ata.vars[i].Threshold[j].ThresholdValue != 0\n\t\t\t\t\t&& m_Ata.vars[i].Attribute[j].CurrentValue < m_Ata.vars[i].Threshold[j].ThresholdValue)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_BAD, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_BAD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (caution > 0)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_CAUTION, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_CAUTION);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// [2021/12/15] Workaround for SanDisk USB Memory\n\t\t\telse if (m_Ata.vars[i].Attribute[j].Id == 0xE8 && m_Ata.vars[i].FlagLifeSanDiskUsbMemory)\n\t\t\t{\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Temperature\n\t\t\telse if (m_Ata.vars[i].Attribute[j].Id == 0xC2)\n\t\t\t{\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// End-to-End Error\n\t\t\t// https://crystalmark.info/bbs/c-board.cgi?cmd=one;no=1090;id=diskinfo#1090\n\t\t\t// http://h20000.www2.hp.com/bc/docs/support/SupportManual/c01159621/c01159621.pdf\n\t\t\telse if (m_Ata.vars[i].Attribute[j].Id == 0xB8)\n\t\t\t{\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Life for WDC/SanDisk\n\t\t\telse if (m_Ata.vars[i].Attribute[j].Id == 0xE6 && (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_WDC || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK))\n\t\t\t{\n\t\t\t\tint life = -1;\n\n\t\t\t\tif (m_Ata.vars[i].FlagLifeSanDiskUsbMemory)\n\t\t\t\t{\n\t\t\t\t\tlife = -1;\n\t\t\t\t}\n\t\t\t\telse if (m_Ata.vars[i].FlagLifeSanDisk0_1)\n\t\t\t\t{\n\t\t\t\t\tlife = 100 - (m_Ata.vars[i].Attribute[j].RawValue[1] * 256 + m_Ata.vars[i].Attribute[j].RawValue[0]) / 100;\n\t\t\t\t}\n\t\t\t\telse if (m_Ata.vars[i].FlagLifeSanDisk1)\n\t\t\t\t{\n\t\t\t\t\tlife = 100 - m_Ata.vars[i].Attribute[j].RawValue[1];\n\t\t\t\t}\n\t\t\t\telse if (m_Ata.vars[i].FlagLifeSanDiskLenovo)\n\t\t\t\t{\n\t\t\t\t\tlife = m_Ata.vars[i].Attribute[j].CurrentValue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlife = 100 - m_Ata.vars[i].Attribute[j].RawValue[1];\n\t\t\t\t}\n\n\t\t\t\tif (life <= 0) { life = 0; }\n\n\t\t\t\tif(m_Ata.vars[i].FlagLifeSanDiskUsbMemory)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (life == 0)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_BAD, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_BAD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (life <= m_Ata.vars[i].ThresholdFF)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_CAUTION, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_CAUTION);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Life\n\t\t\telse if (\n\t\t\t\t   (m_Ata.vars[i].Attribute[j].Id == 0xA9 && (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_REALTEK || (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_KINGSTON && m_Ata.vars[i].HostReadsWritesUnit == m_Ata.HOST_READS_WRITES_32MB) || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SILICONMOTION))\n\t\t\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xAD && (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_TOSHIBA || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_KIOXIA))\n\t\t\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xB1 && m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SAMSUNG)\n\t\t\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xBB && m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_MTRON)\n\t\t\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xCA && (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_MICRON || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_MICRON_MU03 || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_INTEL_DC || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SILICONMOTION_CVC))\n\t\t\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xD1 && m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_INDILINX)\n\t\t\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xE7 && (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDFORCE || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_CORSAIR || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_KINGSTON || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SKHYNIX\n\t\t\t\t                                          || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_REALTEK || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SSSTC || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_APACER\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_JMICRON || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SEAGATE || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_MAXIOTEK\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_YMTC || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SCY || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_RECADATA || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_ADATA_INDUSTRIAL))\n\t\t\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xE8 && m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_PLEXTOR)\n\t\t\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xE9 && (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_INTEL || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_OCZ || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_OCZ_VECTOR || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SKHYNIX))\n\t\t\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xE9 && m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS)\n\t\t\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xE6 && (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK_LENOVO || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK_DELL))\n\t\t\t\t|| (m_Ata.vars[i].Attribute[j].Id == 0xC9 && (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK_HP || m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDISK_HP_VENUS))\n\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tif (m_Ata.vars[i].FlagLifeRawValue || m_Ata.vars[i].FlagLifeRawValueIncrement)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (m_Ata.vars[i].Attribute[j].CurrentValue == 0\n\t\t\t\t\t|| m_Ata.vars[i].Attribute[j].CurrentValue < m_Ata.vars[i].Threshold[j].ThresholdValue)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_BAD, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_BAD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (m_Ata.vars[i].Attribute[j].CurrentValue <= m_Ata.vars[i].ThresholdFF)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_CAUTION, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_CAUTION);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (m_Ata.vars[i].Attribute[j].Id == 0x01 // Read Error Rate for SandForce Bug\n\t\t\t\t&& m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDFORCE)\n\t\t\t{\n\t\t\t\tif (m_Ata.vars[i].Attribute[j].CurrentValue == 0\n\t\t\t\t\t&& m_Ata.vars[i].Attribute[j].RawValue[0] == 0\n\t\t\t\t\t&& m_Ata.vars[i].Attribute[j].RawValue[1] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (m_Ata.vars[i].Threshold[j].ThresholdValue != 0\n\t\t\t\t\t&& m_Ata.vars[i].Attribute[j].CurrentValue < m_Ata.vars[i].Threshold[j].ThresholdValue)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_BAD, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_BAD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((m_Ata.vars[i].IsSsd && !m_Ata.vars[i].IsRawValues8)\n\t\t\t\t|| ((0x01 <= m_Ata.vars[i].Attribute[j].Id && m_Ata.vars[i].Attribute[j].Id <= 0x0D)\n\t\t\t\t\t||\tm_Ata.vars[i].Attribute[j].Id == 0x16\n\t\t\t\t\t|| (0xBB <= m_Ata.vars[i].Attribute[j].Id && m_Ata.vars[i].Attribute[j].Id <= 0xC1)\n\t\t\t\t\t|| (0xC3 <= m_Ata.vars[i].Attribute[j].Id && m_Ata.vars[i].Attribute[j].Id <= 0xD1)\n\t\t\t\t\t|| (0xD3 <= m_Ata.vars[i].Attribute[j].Id && m_Ata.vars[i].Attribute[j].Id <= 0xD4)\n\t\t\t\t\t|| (0xDC <= m_Ata.vars[i].Attribute[j].Id && m_Ata.vars[i].Attribute[j].Id <= 0xE4)\n\t\t\t\t\t|| (0xE6 <= m_Ata.vars[i].Attribute[j].Id && m_Ata.vars[i].Attribute[j].Id <= 0xE7)\n\t\t\t\t\t|| m_Ata.vars[i].Attribute[j].Id == 0xF0\n\t\t\t\t\t|| m_Ata.vars[i].Attribute[j].Id == 0xFA\n\t\t\t\t\t|| m_Ata.vars[i].Attribute[j].Id == 0xFE\n\t\t\t\t\t))\n\t\t\t{\n\t\t\t\tif (m_Ata.vars[i].Threshold[j].ThresholdValue != 0\n\t\t\t\t\t&& m_Ata.vars[i].Attribute[j].CurrentValue < m_Ata.vars[i].Threshold[j].ThresholdValue)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_BAD, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_BAD);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_GOOD + m_bGreenMode, 0, 0, 0, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_GOOD + m_bGreenMode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tm_List.SetItem(k, 0, mask, _T(\"\"), ICON_UNKNOWN, 0, 0, 0, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_List.InsertItem(k, _T(\"\"), ICON_UNKNOWN);\n\t\t\t}\n\t\t}\n\n\t\tcstr.Format(_T(\"%02X\"), m_Ata.vars[i].Attribute[j].Id);\n\t\tm_List.SetItemText(k, 1, cstr);\n\n\t\t//BYTE id = m_Ata.vars[i].Attribute[j].Id;\n\n\t\tif (m_bSmartEnglish)\n\t\t{\n\t\t\tGetPrivateProfileStringFx(m_Ata.vars[i].SmartKeyName, cstr, vendorSpecific, str, 256, m_DefaultLangPath);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGetPrivateProfileStringFx(m_Ata.vars[i].SmartKeyName, cstr, L\"\", str, 256, m_DefaultLangPath);\n\t\t\tCString en = str;\n\t\t\tif (en.IsEmpty())\n\t\t\t{\n\t\t\t\tGetPrivateProfileStringFx(m_Ata.vars[i].SmartKeyName, cstr, vendorSpecific, str, 256, m_CurrentLangPath);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGetPrivateProfileStringFx(m_Ata.vars[i].SmartKeyName, cstr, en, str, 256, m_CurrentLangPath);\n\t\t\t}\n\t\t}\n\n\t\tm_List.SetItemText(k, 2, str);\n\n\t\tif (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_SANDFORCE)\n\t\t{\n\t\t\tcstr.Format(_T(\"%d\"), m_Ata.vars[i].Attribute[j].CurrentValue);\n\t\t\tcstr.Format(_T(\"%d\"), m_Ata.vars[i].Attribute[j].CurrentValue);\n\t\t\tm_List.SetItemText(k, 3, cstr);\n\t\t\tcstr.Format(_T(\"%d\"), m_Ata.vars[i].Attribute[j].WorstValue);\n\t\t\tm_List.SetItemText(k, 4, cstr);\n\t\t\tif (m_Ata.vars[i].IsThresholdCorrect)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%d\"), m_Ata.vars[i].Threshold[j].ThresholdValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr = _T(\"---\");\n\t\t\t}\n\t\t\tm_List.SetItemText(k, 5, cstr);\n\n\t\t\tswitch (m_RawValues)\n\t\t\t{\n\t\t\tcase 3:\n\t\t\t\tcstr.Format(_T(\"%d %d %d %d %d %d %d\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].Reserved,\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0]);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcstr.Format(_T(\"%d %d %d %d\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].Reserved,\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[4], m_Ata.vars[i].Attribute[j].RawValue[5]),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[2], m_Ata.vars[i].Attribute[j].RawValue[3]),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[0], m_Ata.vars[i].Attribute[j].RawValue[1]));\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcstr.Format(_T(\"%I64u\"),\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].Reserved << 48) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[5] << 40) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[4] << 32) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[3] << 24) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[2] << 16) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[1] << 8) +\n\t\t\t\t\t(UINT64)m_Ata.vars[i].Attribute[j].RawValue[0]);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tdefault:\n\t\t\t\tcstr.Format(_T(\"%02X%02X%02X%02X%02X%02X%02X\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].Reserved,\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//\tm_List.SetItemText(k, 6, _T(\"DDDDDDDDDDDDDD\"));\n\t\t\tm_List.SetItemText(k, 6, cstr);\n\t\t}\n\t\telse if (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_JMICRON && m_Ata.vars[i].IsRawValues8)\n\t\t{\n\t\t\tcstr.Format(_T(\"%d\"), m_Ata.vars[i].Attribute[j].CurrentValue);\n\t\t\tm_List.SetItemText(k, 3, cstr);\n\t\t\tm_List.SetItemText(k, 4, _T(\"---\"));\n\t\t\tm_List.SetItemText(k, 5, _T(\"---\"));\n\t\t\tswitch (m_RawValues)\n\t\t\t{\n\t\t\tcase 3:\n\t\t\t\tcstr.Format(_T(\"%d %d %d %d %d %d %d %d\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].Reserved,\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].WorstValue);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcstr.Format(_T(\"%d %d %d %d\"),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[5], m_Ata.vars[i].Attribute[j].Reserved),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[3], m_Ata.vars[i].Attribute[j].RawValue[4]),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[1], m_Ata.vars[i].Attribute[j].RawValue[2]),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].WorstValue, m_Ata.vars[i].Attribute[j].RawValue[0]));\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcstr.Format(_T(\"%I64u\"),\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].Reserved << 56) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[5] << 48) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[4] << 40) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[3] << 32) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[2] << 24) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[1] << 16) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[0] << 8) +\n\t\t\t\t\t(UINT64)m_Ata.vars[i].Attribute[j].WorstValue);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tdefault:\n\t\t\t\tcstr.Format(_T(\"%02X%02X%02X%02X%02X%02X%02X%02X\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].Reserved,\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].WorstValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_List.SetItemText(k, 6, cstr);\n\t\t\t//\tm_List.SetItemText(k, 6, _T(\"DDDDDDDDDDDDDDDD\"));\n\t\t}\n\t\telse if (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_INDILINX)\n\t\t{\n\t\t\tm_List.SetItemText(k, 3, _T(\"---\"));\n\t\t\tm_List.SetItemText(k, 4, _T(\"---\"));\n\t\t\tm_List.SetItemText(k, 5, _T(\"---\"));\n\t\t\tswitch (m_RawValues)\n\t\t\t{\n\t\t\tcase 3:\n\t\t\t\tcstr.Format(_T(\"%d %d %d %d %d %d %d %d\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].WorstValue,\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].CurrentValue);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcstr.Format(_T(\"%d %d %d %d\"),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[4], m_Ata.vars[i].Attribute[j].RawValue[5]),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[2], m_Ata.vars[i].Attribute[j].RawValue[3]),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[0], m_Ata.vars[i].Attribute[j].RawValue[1]),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].CurrentValue, m_Ata.vars[i].Attribute[j].WorstValue));\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcstr.Format(_T(\"%I64u\"),\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[5] << 56) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[4] << 48) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[3] << 40) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[2] << 32) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[1] << 24) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[0] << 16) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].WorstValue << 8) +\n\t\t\t\t\t(UINT64)m_Ata.vars[i].Attribute[j].CurrentValue);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tdefault:\n\t\t\t\tcstr.Format(_T(\"%02X%02X%02X%02X%02X%02X%02X%02X\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].WorstValue,\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].CurrentValue);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_List.SetItemText(k, 6, cstr);\n\t\t\t//\tm_List.SetItemText(k, 6, _T(\"DDDDDDDDDDDDDDDD\"));\n\t\t}\n\t\telse if (m_Ata.vars[i].DiskVendorId == m_Ata.SSD_VENDOR_NVME)\n\t\t{\n\t\t\tcstr = _T(\"---\");\n\t\t\tm_List.SetItemText(k, 3, cstr);\n\t\t\tm_List.SetItemText(k, 4, cstr);\n\t\t\tm_List.SetItemText(k, 5, cstr);\n\t\t\tswitch (m_RawValues)\n\t\t\t{\n\t\t\tcase 3:\n\t\t\t\tcstr.Format(_T(\"%d %d %d %d %d %d %d\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].Reserved,\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0]);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcstr.Format(_T(\"%d %d %d %d\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].Reserved,\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[4], m_Ata.vars[i].Attribute[j].RawValue[5]),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[2], m_Ata.vars[i].Attribute[j].RawValue[3]),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[0], m_Ata.vars[i].Attribute[j].RawValue[1]));\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcstr.Format(_T(\"%I64u\"),\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].Reserved << 48) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[5] << 40) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[4] << 32) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[3] << 24) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[2] << 16) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[1] << 8) +\n\t\t\t\t\t(UINT64)m_Ata.vars[i].Attribute[j].RawValue[0]);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tdefault:\n\t\t\t\tcstr.Format(_T(\"%02X%02X%02X%02X%02X%02X%02X\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].Reserved,\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_List.SetItemText(k, 6, cstr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"%d\"), m_Ata.vars[i].Attribute[j].CurrentValue);\n\t\t\tm_List.SetItemText(k, 3, cstr);\n\t\t\tcstr.Format(_T(\"%d\"), m_Ata.vars[i].Attribute[j].WorstValue);\n\t\t\tm_List.SetItemText(k, 4, cstr);\n\t\t\tif (m_Ata.vars[i].IsThresholdCorrect)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%d\"), m_Ata.vars[i].Threshold[j].ThresholdValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr = _T(\"---\");\n\t\t\t}\n\t\t\tm_List.SetItemText(k, 5, cstr);\n\n\t\t\tswitch (m_RawValues)\n\t\t\t{\n\t\t\tcase 3:\n\t\t\t\tcstr.Format(_T(\"%d %d %d %d %d %d\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0]);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcstr.Format(_T(\"%d %d %d\"),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[4], m_Ata.vars[i].Attribute[j].RawValue[5]),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[2], m_Ata.vars[i].Attribute[j].RawValue[3]),\n\t\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[0], m_Ata.vars[i].Attribute[j].RawValue[1]));\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcstr.Format(_T(\"%I64u\"),\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[5] << 40) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[4] << 32) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[3] << 24) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[2] << 16) +\n\t\t\t\t\t((UINT64)m_Ata.vars[i].Attribute[j].RawValue[1] << 8) +\n\t\t\t\t\t(UINT64)m_Ata.vars[i].Attribute[j].RawValue[0]);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tdefault:\n\t\t\t\tcstr.Format(_T(\"%02X%02X%02X%02X%02X%02X\"),\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[5],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[4],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[3],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[2],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[1],\n\t\t\t\t\tm_Ata.vars[i].Attribute[j].RawValue[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//\tm_List.SetItemText(k, 6, _T(\"DDDDDDDDDDDD\"));\n\t\t\tm_List.SetItemText(k, 6, cstr);\n\t\t}\n\t\tk++;\n\t}\n\n\tif (!flag)\n\t{\n\t\tm_List.SetRedraw(TRUE);\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CDiskInfoDlg::ChangeDisk(DWORD i)\n{\n\tBOOL flagUpdate = FALSE;\n\n\t//\tm_CtrlDiskStatus.SetToolTipText(L\"\");\n\tm_CtrlDriveMap.SetToolTipText(L\"\");\n\tm_CtrlModel.SetToolTipText(L\"\");\n\tm_CtrlPowerOnHours.SetToolTipText(L\"\");\n\tm_CtrlPowerOnCount.SetToolTipText(L\"\");\n\tm_CtrlBufferSize.SetToolTipText(L\"\");\n\tm_CtrlNvCacheSize.SetToolTipText(L\"\");\n\tm_CtrlRotationRate.SetToolTipText(L\"\");\n\tm_CtrlTransferMode.SetToolTipText(L\"\");\n\tm_CtrlAtaAtapi.SetToolTipText(L\"\");\n\n\tif (m_Ata.vars.GetCount() == 0)\n\t{\n\t\tm_Model = _T(\"\");\n\t\tm_ModelCapacity = i18n(_T(\"Message\"), _T(\"DISK_NOT_FOUND\"));\n\t\tm_Firmware = _T(\"\");\n\t\tm_SerialNumber = _T(\"\");\n\t\tm_PowerOnCount = _T(\"\");\n\t\tm_PowerOnHours = _T(\"\");\n\t\tm_BufferSize = _T(\"\");\n\t\tm_NvCacheSize = _T(\"\");\n\t\tm_RotationRate = _T(\"\");\n\t\tm_LbaSize = _T(\"\");\n\t\tm_Capacity = _T(\"\");\n\t\tm_TransferMode = _T(\"\");\n\t\tm_Interface = _T(\"\");\n\t\tm_AtaAtapi = _T(\"\");\n\t\tm_DiskStatus = _T(\"\");\n\t\tm_Temperature = _T(\"\");\n\t\tm_Life = _T(\"\");\n\t\tm_Feature = _T(\"\");\n\t\tm_DriveMap = _T(\"\");\n\t\tUpdateData(FALSE);\n\t\tUpdateListCtrl(i);\n\n\t\tm_CtrlDiskStatus.ReloadImage(IP(L\"diskStatusUnknown\"), 1);\n\t\tm_CtrlTemperature.ReloadImage(IP(L\"temperatureUnknown\"), 1);\n\n\t\treturn FALSE;\n\t}\n\n\tstatic int preSelectedDisk = -1;\n\tif (preSelectedDisk != i)\n\t{\n\t\tflagUpdate = TRUE;\n\t\tpreSelectedDisk = i;\n\t}\n\n\tstatic int preFlagFahrenheit = -1;\n\tif (preFlagFahrenheit != m_bFahrenheit)\n\t{\n\t\tflagUpdate = TRUE;\n\t\tpreFlagFahrenheit = m_bFahrenheit;\n\t}\n\n\tstatic CString preLang = _T(\"\");\n\tif (preLang.Compare(m_CurrentLang) != 0)\n\t{\n\t\tflagUpdate = TRUE;\n\t\tpreLang = m_CurrentLang;\n\t}\n\n\tCString cstr, diskStatus, diskStatusReason, className, logicalDriveInfo;\n\tstatic CString preDiskStatus = _T(\"\");\n\tstatic CString preDiskStatusReason = _T(\"\");\n\tstatic CString preTemperatureStatus = _T(\"\");\n\tstatic CString preLogicalDriveInfo = _T(\"\");\n\tstatic BOOL preFlagHideSerialNumber = FALSE;\n\n\tdiskStatus = GetDiskStatus(m_Ata.vars[i].DiskStatus);\n\tclassName = GetDiskStatusClass(m_Ata.vars[i].DiskStatus);\n\tdiskStatusReason = GetDiskStatusReason(i);\n\n\tif (preDiskStatus.Compare(className) != 0)\n\t{\n\t\tpreDiskStatus = className;\n\t}\n\tif (preDiskStatusReason.Compare(diskStatusReason) != 0)\n\t{\n\t\tpreDiskStatusReason = diskStatusReason;\n\t}\n\n\tif (m_Ata.vars[i].Life >= 0)\n\t{\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\t\tcstr.Format(_T(\" (%d %%)\"), m_Ata.vars[i].Life);\n#else\n\t\tcstr.Format(_T(\"\\n%d %%\"), m_Ata.vars[i].Life);\n#endif\n\t\tm_DiskStatus.Format(_T(\"%s %s\"), diskStatus.GetString(), cstr.GetString());\n\t}\n\telse\n\t{\n\t\tm_DiskStatus.Format(_T(\"%s\"), diskStatus.GetString());\n\t}\n\tm_CtrlDiskStatus.SetToolTipText(diskStatusReason);\n\tm_CtrlDiskStatus.ReloadImage(IP(className), 1);\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tclassName.Replace(L\"Green\", L\"\");\n\tif (m_Ata.vars[i].DiskStatus == CAtaSmart::DISK_STATUS_GOOD && m_Ata.vars[i].Life == 100)\n\t{\n\t\tclassName += L\"100\";\n\t}\n\t m_CtrlLife.ReloadImage(IP(L\"SD\" + className), 1);\n#endif\n\n\tclassName = GetTemperatureClass(m_Ata.vars[i].Temperature, m_Ata.vars[i].AlarmTemperature);\n\n\tif (preTemperatureStatus.Compare(className) != 0)\n\t{\n\t\tpreTemperatureStatus = className;\n\t}\n\n\t// static int preTemperature = -1;\n\t// if(preTemperature != m_Ata.vars[i].Temperature || flagUpdate)\n\t{\n\t\tif (m_Ata.vars[i].Temperature > -300)\n\t\t{\n\t\t\tif (m_bFahrenheit)\n\t\t\t{\n\t\t\t\tm_Temperature.Format(_T(\"%d °F\"), m_Ata.vars[i].Temperature * 9 / 5 + 32);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_Temperature.Format(_T(\"%d °C\"), m_Ata.vars[i].Temperature);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (m_bFahrenheit)\n\t\t\t{\n\t\t\t\tm_Temperature.Format(_T(\"-- °F\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_Temperature.Format(_T(\"-- °C\"));\n\t\t\t}\n\t\t}\n\t}\n\tm_CtrlTemperature.ReloadImage(IP(className), 1);\n\n\tlogicalDriveInfo = GetLogicalDriveInfo(i);\n\t//\tif(preLogicalDriveInfo.Compare(logicalDriveInfo) != 0)\n\t{\n\t\tpreLogicalDriveInfo = logicalDriveInfo;\n\t\tm_CtrlDriveMap.SetToolTipText(logicalDriveInfo + L\"  \");\n\t}\n\n\t/*\n\tif(m_Ata.vars[i].Sector48 >= m_Ata.vars[i].Sector28)\n\t{\n\tcstr.Format(_T(\"%I64d\"), m_Ata.vars[i].Sector48);\n\t//\tSetElementPropertyEx(_T(\"LbaSize\"), DISPID_IHTMLELEMENT_TITLE, cstr);\n\t//\tm_LabelLbaSize = _T(\"48bit LBA\");\n\t}\n\telse if(m_Ata.vars[i].Sector28 > 0)\n\t{\n\tcstr.Format(_T(\"%d\"), m_Ata.vars[i].Sector28);\n\t//\tSetElementPropertyEx(_T(\"LbaSize\"), DISPID_IHTMLELEMENT_TITLE, cstr);\n\t//\tm_LabelLbaSize = _T(\"28bit LBA\");\n\t}\n\telse\n\t{\n\tcstr = _T(\"\");\n\t//\tSetElementPropertyEx(_T(\"LbaSize\"), DISPID_IHTMLELEMENT_TITLE, cstr);\n\t//\tm_LabelLbaSize = _T(\"CHS\");\n\t}\n\t*/\n\n\tif (preFlagHideSerialNumber != m_bHideSerialNumber)\n\t{\n\t\tpreFlagHideSerialNumber = m_bHideSerialNumber;\n\t\tflagUpdate = TRUE;\n\t}\n\n\tif (m_bHideSerialNumber)\n\t{\n\t\tm_SerialNumber = _T(\"\");\n\t\tfor (int j = 0; j < m_Ata.vars[i].SerialNumber.GetLength(); j++)\n\t\t{\n\t\t\tm_SerialNumber += _T(\"*\");\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_SerialNumber = m_Ata.vars[i].SerialNumber;\n\t}\n\n\tm_Model = m_Ata.vars[i].Model;\n\tm_Firmware = m_Ata.vars[i].FirmwareRev;\n\n\tstatic int prePowerOnCount = -1;\n\tif (flagUpdate || prePowerOnCount != m_Ata.vars[i].PowerOnCount)\n\t{\n\t\tif (m_Ata.vars[i].PowerOnCount > 0)\n\t\t{\n\t\t\tm_PowerOnCount.Format(_T(\"%d %s\"), m_Ata.vars[i].PowerOnCount, i18n(_T(\"Dialog\"), _T(\"POWER_ON_COUNT_UNIT\")).GetString());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_PowerOnCount = i18n(_T(\"Dialog\"), _T(\"UNKNOWN\"));\n\t\t}\n\t\tprePowerOnCount = m_Ata.vars[i].PowerOnCount;\n\t\tflagUpdate = TRUE;\n\t}\n\n\tCString IsMinutes;\n\tCString IsMinutesT;\n\tCString title;\tstatic int prePowerOnHours = -1;\n\n\tconst INT powerOnHours = m_Ata.vars[i].MeasuredPowerOnHours > 0 ? m_Ata.vars[i].MeasuredPowerOnHours : m_Ata.vars[i].DetectedPowerOnHours;\n\tconst DWORD timeUnitType = m_Ata.vars[i].MeasuredPowerOnHours > 0 ? m_Ata.vars[i].MeasuredTimeUnitType : m_Ata.vars[i].DetectedTimeUnitType;\n\n\tif (powerOnHours >= 0)\n\t{\n\t\t//if(flagUpdate || prePowerOnHours != powerOnHours)\n\t\t{\n\t\t\tif (timeUnitType == CAtaSmart::POWER_ON_MINUTES && m_Ata.vars[i].IsMaxtorMinute)\n\t\t\t{\n\t\t\t\tIsMinutes = _T(\"?\");\n\t\t\t\tIsMinutesT = _T(\" (?)\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIsMinutes = _T(\" \");\n\t\t\t\tIsMinutesT = _T(\"\");\n\t\t\t}\n\n\t\t\tconst int years = powerOnHours / (365 * 24);\n\t\t\tconst int days = (powerOnHours - 365 * 24 * years) / 24;\n\t\t\tconst int hours = powerOnHours % 24;\n\t\t\t\n\t\t\tif (m_NowDetectingUnitPowerOnHours)\n\t\t\t{\n\t\t\t\tif (years > 0)\n\t\t\t\t{\n\t\t\t\t\ttitle.Format(_T(\"%d %s %d %s %d %s%s\\r\\n%s\"),\n\t\t\t\t\t\tyears, i18n(_T(\"Dialog\"), _T(\"POWER_ON_YEARS_UNIT\")).GetString(),\n\t\t\t\t\t\tdays, i18n(_T(\"Dialog\"), _T(\"POWER_ON_DAYS_UNIT\")).GetString(),\n\t\t\t\t\t\thours, i18n(_T(\"Dialog\"), _T(\"POWER_ON_HOURS_UNIT\")).GetString(),\n\t\t\t\t\t\tIsMinutesT.GetString(), i18n(_T(\"Message\"), _T(\"DETECT_UNIT_POWER_ON_HOURS\")).GetString());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttitle.Format(_T(\"%d %s %d %s%s\\r\\n%s\"),\n\t\t\t\t\t\tdays, i18n(_T(\"Dialog\"), _T(\"POWER_ON_DAYS_UNIT\")).GetString(),\n\t\t\t\t\t\thours, i18n(_T(\"Dialog\"), _T(\"POWER_ON_HOURS_UNIT\")).GetString(),\n\t\t\t\t\t\tIsMinutesT.GetString(), i18n(_T(\"Message\"), _T(\"DETECT_UNIT_POWER_ON_HOURS\")).GetString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (years > 0)\n\t\t\t\t{\n\t\t\t\t\ttitle.Format(_T(\"%d %s %d %s %d %s%s\"),\n\t\t\t\t\t\tyears, i18n(_T(\"Dialog\"), _T(\"POWER_ON_YEARS_UNIT\")).GetString(),\n\t\t\t\t\t\tdays, i18n(_T(\"Dialog\"), _T(\"POWER_ON_DAYS_UNIT\")).GetString(),\n\t\t\t\t\t\thours, i18n(_T(\"Dialog\"), _T(\"POWER_ON_HOURS_UNIT\")).GetString(),\n\t\t\t\t\t\tIsMinutesT.GetString());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttitle.Format(_T(\"%d %s %d %s%s\"),\n\t\t\t\t\t\tdays, i18n(_T(\"Dialog\"), _T(\"POWER_ON_DAYS_UNIT\")).GetString(),\n\t\t\t\t\t\thours, i18n(_T(\"Dialog\"), _T(\"POWER_ON_HOURS_UNIT\")).GetString(),\n\t\t\t\t\t\tIsMinutesT.GetString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm_PowerOnHours.Format(_T(\"%d%s%s\"),\n\t\t\t\tpowerOnHours, IsMinutes.GetString(), i18n(_T(\"Dialog\"), _T(\"POWER_ON_HOURS_UNIT\")).GetString());\n\n\t\t\tm_CtrlPowerOnHours.SetToolTipText(title + L\"  \");\n\n\t\t\tprePowerOnHours = powerOnHours;\n\t\t\tflagUpdate = TRUE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (flagUpdate || prePowerOnHours != 0)\n\t\t{\n\t\t\tm_PowerOnHours = i18n(_T(\"Dialog\"), _T(\"UNKNOWN\"));\n\t\t\tprePowerOnHours = 0;\n\t\t\tflagUpdate = TRUE;\n\t\t\tm_CtrlPowerOnHours.SetToolTipText(L\"\");\n\t\t}\n\t}\n\n\tif (m_Ata.vars[i].HostReads >= 0)\n\t{\n\t\tcstr = L\"\";\n\n\t\tif(m_Ata.vars[i].HostReads > 1024 * 1024)\n\t\t{\n\t\t\tcstr.Format(_T(\"%.3f PB\"), m_Ata.vars[i].HostReads / 1024.0 / 1024.0);\n\t\t}\n\t\telse if(m_Ata.vars[i].HostReads > 1024)\n\t\t{\n\t\t\tcstr.Format(_T(\"%.3f TB\"), m_Ata.vars[i].HostReads / 1024.0);\n\t\t}\n\t\telse if (m_Ata.vars[i].HostReads)\n\t\t{\n\t\t\tcstr.Format(_T(\"%d GB\"), m_Ata.vars[i].HostReads);\n\t\t}\n\n\t\tm_BufferSize.Format(_T(\"%d GB\"), m_Ata.vars[i].HostReads);\n\t\tm_LabelBufferSize = i18n(_T(\"Dialog\"), _T(\"TOTAL_HOST_READS\"));\n\t\tm_CtrlBufferSize.SetToolTipText(cstr + L\"  \");\n\t\tm_CtrlLabelBufferSize.SetToolTipText(i18n(_T(\"Dialog\"), _T(\"TOTAL_HOST_READS\")));\n\t}\n\telse if (m_Ata.vars[i].BufferSize == 0xFFFF * 512)\n\t{\n\t\tm_BufferSize.Format(_T(\">= 32 MB\"));\n\t\tm_LabelBufferSize = i18n(_T(\"Dialog\"), _T(\"BUFFER_SIZE\"));\n\t\tm_CtrlBufferSize.SetToolTipText(L\"\");\n\t\tm_CtrlLabelBufferSize.SetToolTipText(i18n(_T(\"Dialog\"), _T(\"BUFFER_SIZE\")));\n\t}\n\telse if (m_Ata.vars[i].BufferSize > 0)\n\t{\n\t\tm_BufferSize.Format(_T(\"%d KB\"), m_Ata.vars[i].BufferSize / 1024);\n\t\tm_LabelBufferSize = i18n(_T(\"Dialog\"), _T(\"BUFFER_SIZE\"));\n\t\tm_CtrlBufferSize.SetToolTipText(L\"\");\n\t\tm_CtrlLabelBufferSize.SetToolTipText(i18n(_T(\"Dialog\"), _T(\"BUFFER_SIZE\")));\n\t}\n\telse\n\t{\n\t\tm_BufferSize = _T(\"----\");\n\t\tm_LabelBufferSize = _T(\"----\");\n\t\tm_CtrlBufferSize.SetToolTipText(L\"\");\n\t\tm_CtrlLabelBufferSize.SetToolTipText(L\"\");\n\t}\n\n\tif (m_Ata.vars[i].HostWrites >= 0)\n\t{\n\t\tcstr = L\"\";\n\n\t\tif(m_Ata.vars[i].HostWrites > 1024 * 1024)\n\t\t{\n\t\t\tcstr.Format(_T(\"%.3f PB\"), m_Ata.vars[i].HostWrites / 1024.0 / 1024.0);\n\t\t}\n\t\telse if(m_Ata.vars[i].HostWrites > 1024)\n\t\t{\n\t\t\tcstr.Format(_T(\"%.3f TB\"), m_Ata.vars[i].HostWrites / 1024.0);\n\t\t}\n\t\telse if (m_Ata.vars[i].HostWrites)\n\t\t{\n\t\t\tcstr.Format(_T(\"%d GB\"), m_Ata.vars[i].HostWrites);\n\t\t}\n\n\t\tm_NvCacheSize.Format(_T(\"%d GB\"), m_Ata.vars[i].HostWrites);\n\t\tm_LabelNvCacheSize = i18n(_T(\"Dialog\"), _T(\"TOTAL_HOST_WRITES\"));\n\t\tm_CtrlNvCacheSize.SetToolTipText(cstr + L\"  \");\n\t\tm_CtrlLabelNvCacheSize.SetToolTipText(i18n(_T(\"Dialog\"), _T(\"TOTAL_HOST_WRITES\")));\n\t}\n\telse if (m_Ata.vars[i].NvCacheSize > 0)\n\t{\n\t\tm_NvCacheSize.Format(_T(\"%d MB\"), (DWORD)(m_Ata.vars[i].NvCacheSize / 1024 / 1024));\n\t\tm_LabelNvCacheSize = i18n(_T(\"Dialog\"), _T(\"NV_CACHE_SIZE\"));\n\t\tm_CtrlNvCacheSize.SetToolTipText(L\"\");\n\t\tm_CtrlLabelNvCacheSize.SetToolTipText(i18n(_T(\"Dialog\"), _T(\"NV_CACHE_SIZE\")));\n\t}\n\telse\n\t{\n\t\tm_NvCacheSize = _T(\"----\");\n\t\tm_LabelNvCacheSize = _T(\"----\");\n\t\tm_CtrlNvCacheSize.SetToolTipText(L\"\");\n\t\tm_CtrlLabelNvCacheSize.SetToolTipText(L\"\");\n\t}\n\n\tif (m_Ata.vars[i].NandWrites >= 0)\n\t{\n\t\tcstr = L\"\";\n\n\t\tif(m_Ata.vars[i].NandWrites > 1024 * 1024)\n\t\t{\n\t\t\tcstr.Format(_T(\"%.3f PB\"), m_Ata.vars[i].NandWrites / 1024.0 / 1024.0);\n\t\t}\n\t\telse if(m_Ata.vars[i].NandWrites > 1024)\n\t\t{\n\t\t\tcstr.Format(_T(\"%.3f TB\"), m_Ata.vars[i].NandWrites / 1024.0);\n\t\t}\n\t\telse if (m_Ata.vars[i].NandWrites)\n\t\t{\n\t\t\tcstr.Format(_T(\"%d GB\"), m_Ata.vars[i].NandWrites);\n\t\t}\n\n\t\tm_RotationRate.Format(_T(\"%d GB\"), m_Ata.vars[i].NandWrites);\n\t\t/*\n\t\tif (m_Ata.vars[i].PlextorNandWritesUnit)\n\t\t{\n\t\tm_RotationRate += L\" (?)\";\n\t\tcstr += L\" (?)\";\n\t\t}\n\t\t*/\n\n\t\tm_LabelRotationRate = i18n(_T(\"Dialog\"), _T(\"TOTAL_NAND_WRITES\"));\n\t\tm_CtrlRotationRate.SetToolTipText(cstr + L\"  \");\n\t\tm_CtrlLabelRotationRate.SetToolTipText(i18n(_T(\"Dialog\"), _T(\"TOTAL_NAND_WRITES\")));\n\t}\n\telse if (m_Ata.vars[i].GBytesErased >= 0)\n\t{\n\t\tcstr = L\"\";\n\t\t/*\n\t\tif(m_Ata.vars[i].GBytesErased > 1024 * 1024)\n\t\t{\n\t\tcstr.Format(_T(\"%.3f PB\"), m_Ata.vars[i].GBytesErased / 1024.0 / 1024.0);\n\t\t}\n\t\telse if(m_Ata.vars[i].GBytesErased > 1024)\n\t\t{\n\t\tcstr.Format(_T(\"%.3f TB\"), m_Ata.vars[i].GBytesErased / 1024.0);\n\t\t}\n\t\t*/\n\t\tm_RotationRate.Format(_T(\"%d GB\"), m_Ata.vars[i].GBytesErased);\n\t\tm_LabelRotationRate = i18n(_T(\"SmartSandForce\"), _T(\"64\"));\n\t\tm_CtrlRotationRate.SetToolTipText(cstr);\n\t\tm_CtrlLabelRotationRate.SetToolTipText(i18n(_T(\"SmartSandForce\"), _T(\"64\")));\n\t}\n\t/*\n\telse if(m_Ata.vars[i].WearLevelingCount >= 0)\n\t{\n\tm_RotationRate.Format(_T(\"%d %s\"), m_Ata.vars[i].WearLevelingCount, i18n(_T(\"Dialog\"), _T(\"POWER_ON_COUNT_UNIT\")));\n\t//\tm_LabelRotationRate = i18n(_T(\"Dialog\"), _T(\"WEAR_LEVELING_COUNT\"));\n\tSetLabel(m_LabelRotationRate, _T(\"RotationRate\"),i18n(_T(\"Dialog\"), _T(\"WEAR_LEVELING_COUNT\")));\n\t//\tSetElementPropertyEx(_T(\"RotationRate\"), DISPID_IHTMLELEMENT_CLASSNAME, _T(\"supported\"));\n\t}\n\t*/\n\telse if (m_Ata.vars[i].NominalMediaRotationRate == 1) // SSD\n\t{\n\t\tm_RotationRate = _T(\"---- (SSD)\");\n\t\tm_LabelRotationRate = i18n(_T(\"Dialog\"), _T(\"ROTATION_RATE\"));\n\t\tm_CtrlRotationRate.SetToolTipText(L\"\");\n\t\tm_CtrlLabelRotationRate.SetToolTipText(i18n(_T(\"Dialog\"), _T(\"ROTATION_RATE\")));\n\t}\n\telse if (m_Ata.vars[i].NominalMediaRotationRate > 0)\n\t{\n\t\tm_RotationRate.Format(_T(\"%d RPM\"), m_Ata.vars[i].NominalMediaRotationRate);\n\t\tm_LabelRotationRate = i18n(_T(\"Dialog\"), _T(\"ROTATION_RATE\"));\n\t\tm_CtrlLabelRotationRate.SetToolTipText(i18n(_T(\"Dialog\"), _T(\"ROTATION_RATE\")));\n\t}\n\telse\n\t{\n\t\tm_RotationRate = _T(\"----\");\n\t\tm_LabelRotationRate = _T(\"----\");\n\t\tm_CtrlRotationRate.SetToolTipText(L\"\");\n\t\tm_CtrlLabelRotationRate.SetToolTipText(L\"\");\n\t}\n\n\tif (m_Ata.vars[i].DiskSizeLba48 >= m_Ata.vars[i].DiskSizeLba28)\n\t{\n\t\tm_LbaSize.Format(_T(\"%.1f GB\"), m_Ata.vars[i].DiskSizeLba48 / 1000.0);\n\t}\n\telse if (m_Ata.vars[i].DiskSizeLba28 > 0)\n\t{\n\t\tm_LbaSize.Format(_T(\"%.1f GB\"), m_Ata.vars[i].DiskSizeLba28 / 1000.0);\n\t}\n\telse if (m_Ata.vars[i].DiskSizeChs > 0)\n\t{\n\t\tm_LbaSize.Format(_T(\"%.1f GB\"), m_Ata.vars[i].DiskSizeChs / 1000.0);\n\t}\n\telse\n\t{\n\t\tm_LbaSize = _T(\"----\");\n\t}\n\n\tm_DriveMap = m_Ata.vars[i].DriveMap;\n\tif (m_Ata.vars[i].TotalDiskSize >= 1000)\n\t{\n\t\tm_Capacity.Format(_T(\"%.1f GB\"), m_Ata.vars[i].TotalDiskSize / 1000.0);\n\t}\n\telse if (m_Ata.vars[i].TotalDiskSize > 0)\n\t{\n\t\tm_Capacity.Format(_T(\"%d MB\"), m_Ata.vars[i].TotalDiskSize);\n\t}\n\telse\n\t{\n\t\tm_Capacity = i18n(_T(\"Dialog\"), _T(\"UNKNOWN\"));\n\t}\n\t\n\tif (m_Ata.vars[i].CurrentTransferMode.IsEmpty() && m_Ata.vars[i].MaxTransferMode.IsEmpty())\n\t{\n\t\tm_TransferMode = L\"\";\n\t}\n\telse\n\t{\n\t\tm_TransferMode = m_Ata.vars[i].CurrentTransferMode + _T(\" | \") + m_Ata.vars[i].MaxTransferMode;\n\t}\n\tm_CtrlTransferMode.SetToolTipText(i18n(_T(\"Dialog\"), _T(\"CURRENT_MODE_SUPPORTED_MODE\")));\n\n\tm_Interface = m_Ata.vars[i].Interface;\n\tif (!m_Ata.vars[i].MinorVersion.IsEmpty())\n\t{\n\t\tm_AtaAtapi = m_Ata.vars[i].MajorVersion + _T(\" | \") + m_Ata.vars[i].MinorVersion;\n\t}\n\telse\n\t{\n\t\tm_AtaAtapi = m_Ata.vars[i].MajorVersion;\n\t}\n\n\tm_CtrlAtaAtapi.SetToolTipText(i18n(_T(\"Dialog\"), _T(\"MAJOR_VERSION_MINOR_VERSION\")));\n\tm_Feature = _T(\"\");\n\t\n\tif (m_Ata.vars[i].IsNVMe)\n\t{\n\t\tcstr = L\"\\\nS.M.A.R.T.: Self-Monitoring, Analysis and Reporting Technology\\n\\\nTRIM: Trim function of DATA SET MANAGEMENT command\\n\\\nVolatileWriteCache: Volatile Write Cache Present\\n\\\n\";\n\t}\n\telse\n\t{\n\t\tcstr = L\"\\\nS.M.A.R.T.: Self-Monitoring, Analysis and Reporting Technology\\n\\\nAPM: Advanced Power Management\\n\\\nAAM: Automatic Acoustic Management\\n\\\nNCQ: Native Command Queuing\\n\\\nTRIM: Trim function of DATA SET MANAGEMENT command\\n\\\nDevSleep: Device Sleep\\n\\\nStreaming: Streaming Feature Set\\n\\\nGPL: General Purpose Log\\n\\\n\";\n\t}\n\n\tm_CtrlFeature.SetToolTipText(cstr);\n\n\tif (m_Ata.vars[i].IsSmartSupported)\n\t{\n\t\tm_Feature += _T(\"S.M.A.R.T., \");\n\t}\n\n\tif (m_Ata.vars[i].IsApmSupported)\n\t{\n\t\tm_Feature += _T(\"APM, \");\n\t}\n\n\tif (m_Ata.vars[i].IsAamSupported)\n\t{\n\t\tm_Feature += _T(\"AAM, \");\n\t}\n\n\tif (m_Ata.vars[i].IsNcqSupported)\n\t{\n\t\tm_Feature += _T(\"NCQ, \");\n\t}\n\n\tif (m_Ata.vars[i].IsTrimSupported)\n\t{\n\t\tm_Feature += _T(\"TRIM, \");\n\t}\n\n\tif (m_Ata.vars[i].IsDeviceSleepSupported)\n\t{\n\t\tm_Feature += _T(\"DevSleep, \");\n\t}\n\n\tif (m_Ata.vars[i].IsStreamingSupported)\n\t{\n\t\tm_Feature += _T(\"Streaming, \");\n\t}\n\n\tif (m_Ata.vars[i].IsGplSupported)\n\t{\n\t\tm_Feature += _T(\"GPL, \");\n\t}\n\n\tif (m_Ata.vars[i].IsVolatileWriteCachePresent)\n\t{\n\t\tm_Feature += _T(\"VolatileWriteCache, \");\n\t}\n\tif (!m_Feature.IsEmpty())\n\t{\n\t\tm_Feature.Delete(m_Feature.GetLength() - 2, 2);\n\t}\n\n\t/*\n\tif (m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_AMD_RC2 || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMS56X || m_Ata.vars[i].CommandType == m_Ata.CMD_TYPE_JMB39X)\n\t{\n\t//\tm_Feature = L\"\";\n\t}\n\t*/\n\n\tm_ModelCapacity = m_Model + L\" : \" + m_Capacity;\n\n\tm_CtrlModel.SetToolTipText(m_ModelCapacity + L\"\\r\\n\" + m_Ata.vars[i].Enclosure);\n\n\t/*\n\tif(m_Ata.vars[i].Life >= 0)\n\t{\n\tm_Life.Format(L\"%d %%\", m_Ata.vars[i].Life);\n\t}\n\telse\n\t{\n\tm_Life = L\"\";\n\t}\n\t*/\n\n\tUpdateData(FALSE);\n\n\treturn TRUE;\n}\n\nvoid CDiskInfoDlg::ChangeLang(CString LangName)\n{\n\tif (m_SelectDisk >= (DWORD)m_Ata.vars.GetCount())\n\t{\n\t\tm_SelectDisk = 0;\n\t}\n\n\tm_CurrentLangPath.Format(_T(\"%s\\\\%s.lang\"), m_LangDir.GetString(), LangName.GetString());\n\tCString cstr;\n\tCMenu *menu = GetMenu();\n\tCMenu subMenu;\n\tCMenu subSubMenu;\n\tUINT menuState = 0;\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"FILE\"));\n\tmenu->ModifyMenu(0, MF_BYPOSITION | MF_STRING, 0, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"EDIT\"));\n\tmenu->ModifyMenu(1, MF_BYPOSITION | MF_STRING, 1, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"FUNCTION\"));\n\tmenu->ModifyMenu(2, MF_BYPOSITION | MF_STRING, 2, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"THEME\"));\n\tmenu->ModifyMenu(3, MF_BYPOSITION | MF_STRING, 3, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"DISK\"));\n\tmenu->ModifyMenu(4, MF_BYPOSITION | MF_STRING, 4, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"HELP\"));\n\tmenu->ModifyMenu(5, MF_BYPOSITION | MF_STRING, 5, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"LANGUAGE\"));\n\n\n\t//////////////////////////////////////////////////////////////////////////////////\n\t// Language\n\t//////////////////////////////////////////////////////////////////////////////////\n\n\tif (cstr.Find(_T(\"Language\")) >= 0)\n\t{\n\t\tcstr = _T(\"&Language\");\n\t\tmenu->ModifyMenu(6, MF_BYPOSITION | MF_STRING, 6, cstr);\n\t}\n\telse\n\t{\n\t\tmenu->ModifyMenu(6, MF_BYPOSITION | MF_STRING, 6, cstr + _T(\"(&Language)\"));\n\t}\n\n#ifdef SUISHO_AOI_SUPPORT\n\tsubMenu.Attach(menu->GetSubMenu(6)->GetSafeHmenu());\n\tcstr = i18n(_T(\"Menu\"), _T(\"VOICE\"));\n\tsubMenu.ModifyMenuW(2, MF_BYPOSITION, 2, cstr);\n\tsubMenu.Detach();\n\n\tif (m_VoiceLanguage.Find(L\"Japanese\") == 0)\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_VOICE_ENGLISH, ID_VOICE_JAPANESE, ID_VOICE_JAPANESE, MF_BYCOMMAND);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_VOICE_ENGLISH, ID_VOICE_JAPANESE, ID_VOICE_ENGLISH, MF_BYCOMMAND);\n\t}\t\n#endif\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"CUSTOMIZE\"));\n\tmenuState = menu->GetMenuState(ID_CUSTOMIZE, MF_BYCOMMAND);\n\tmenu->ModifyMenu(ID_CUSTOMIZE, MF_STRING, ID_CUSTOMIZE, cstr);\n\tmenu->EnableMenuItem(ID_CUSTOMIZE, menuState);\n\n\t//////////////////////////////////////////////////////////////////////////////////\n\t// File\n\t//////////////////////////////////////////////////////////////////////////////////\n\tcstr = i18n(_T(\"Menu\"), _T(\"SAVE_TEXT\"));\n\tcstr += _T(\"\\tCtrl + T\");\n\tmenu->ModifyMenu(ID_SAVE_TEXT, MF_STRING, ID_SAVE_TEXT, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"SAVE_IMAGE\"));\n\tcstr += _T(\"\\tCtrl + S\");\n\tmenu->ModifyMenu(ID_SAVE_IMAGE, MF_STRING, ID_SAVE_IMAGE, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"EXIT\"));\n\tcstr += _T(\"\\tAlt + F4\");\n\tmenu->ModifyMenu(ID_EXIT, MF_STRING, ID_EXIT, cstr);\n\n\t//////////////////////////////////////////////////////////////////////////////////\n\t// Edit\n\t//////////////////////////////////////////////////////////////////////////////////\n\tcstr = i18n(_T(\"Menu\"), _T(\"COPY\"));\n\tcstr += _T(\"\\tCtrl + Shift + C\");\n\tmenu->ModifyMenu(ID_COPY, MF_STRING, ID_COPY, cstr);\n\n\tsubMenu.Attach(menu->GetSubMenu(1)->GetSafeHmenu());\n\tcstr = i18n(_T(\"Menu\"), _T(\"COPY_OPTION\"));\n\tsubMenu.ModifyMenu(1, MF_BYPOSITION, 1, cstr);\n\tsubMenu.Detach();\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"ASCII_VIEW\"));\n\tmenu->ModifyMenu(ID_ASCII_VIEW, MF_STRING, ID_ASCII_VIEW, cstr);\n\n\t//////////////////////////////////////////////////////////////////////////////////\n\t// Function\n\t//////////////////////////////////////////////////////////////////////////////////\n\tcstr = i18n(_T(\"Menu\"), _T(\"HIDE_SMART_INFO\"));\n\tmenu->ModifyMenu(ID_HIDE_SMART_INFO, MF_STRING, ID_HIDE_SMART_INFO, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"HIDE_SERIAL_NUMBER\"));\n\tmenu->ModifyMenu(ID_HIDE_SERIAL_NUMBER, MF_STRING, ID_HIDE_SERIAL_NUMBER, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"HIDE_NO_SMART_DISK\"));\n\tmenu->ModifyMenu(ID_HIDE_NO_SMART_DISK, MF_STRING, ID_HIDE_NO_SMART_DISK, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"ADVANCED_DISK_SEARCH\"));\n\tmenu->ModifyMenu(ID_ADVANCED_DISK_SEARCH, MF_STRING, ID_ADVANCED_DISK_SEARCH, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"EVENT_LOG\"));\n\tmenu->ModifyMenu(ID_EVENT_LOG, MF_STRING, ID_EVENT_LOG, cstr);\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"ALERT_SOUND\"));\n\tmenu->ModifyMenu(ID_ALERT_SOUND, MF_STRING, ID_ALERT_SOUND, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"ALARM_HISTORY\"));\n\tmenu->ModifyMenu(ID_ALARM_HISTORY, MF_STRING, ID_ALARM_HISTORY, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"SOUND_SETTINGS\"));\n\tmenu->ModifyMenu(ID_SOUND_SETTINGS, MF_STRING, ID_SOUND_SETTINGS, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"GADGET_SUPPORT\"));\n\tmenu->ModifyMenu(ID_GADGET_SUPPORT, MF_STRING, ID_GADGET_SUPPORT, cstr);\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"DISABLE\"));\n\tmenu->ModifyMenu(ID_CSMI_DISABLE, MF_STRING, ID_CSMI_DISABLE, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"ENABLE_AUTO\"));\n\tmenu->ModifyMenu(ID_CSMI_ENABLE_AUTO, MF_STRING, ID_CSMI_ENABLE_AUTO, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"ENABLE_RAID\"));\n\tmenu->ModifyMenu(ID_CSMI_ENABLE_RAID, MF_STRING, ID_CSMI_ENABLE_RAID, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"ENABLE_ALL\"));\n\tmenu->ModifyMenu(ID_CSMI_ENABLE_ALL, MF_STRING, ID_CSMI_ENABLE_ALL, cstr);\n//\tcstr = i18n(_T(\"Menu\"), _T(\"INSTALL_GADGET\"));\n//\tmenu->ModifyMenu(ID_INSTALL_GADGET, MF_STRING, ID_INSTALL_GADGET, cstr);\n/*\n\tif (HasSidebar())\n\t{\n\t\tmenu->EnableMenuItem(ID_INSTALL_GADGET, MF_ENABLED);\n\t}\n\telse\n\t{\n\t\tmenu->EnableMenuItem(ID_INSTALL_GADGET, MF_GRAYED);\n\t}\n*/\n\n\tif (IsDotNet4() || IsDotNet2())\n\t{\n\t\tcstr = i18n(_T(\"Menu\"), _T(\"ALERT_MAIL\"));\n\t\tmenu->ModifyMenu(ID_ALERT_MAIL, MF_STRING, ID_ALERT_MAIL, cstr);\n\t\tmenu->EnableMenuItem(ID_ALERT_MAIL, MF_ENABLED);\n\t\tcstr = i18n(_T(\"Menu\"), _T(\"MAIL_SETTINGS\"));\n\t\tmenu->ModifyMenu(ID_MAIL_SETTINGS, MF_STRING, ID_MAIL_SETTINGS, cstr);\n\t\tmenu->EnableMenuItem(ID_MAIL_SETTINGS, MF_ENABLED);\n\t}\n\telse\n\t{\n\t\tcstr = i18n(_T(\"Menu\"), _T(\"ALERT_MAIL\")) + _T(\" [.NET 2.0-]\");\n\t\tmenu->ModifyMenu(ID_ALERT_MAIL, MF_STRING, ID_ALERT_MAIL, cstr);\n\t\tmenu->EnableMenuItem(ID_ALERT_MAIL, MF_GRAYED);\n\t\tcstr = i18n(_T(\"Menu\"), _T(\"MAIL_SETTINGS\")) + _T(\" [.NET 2.0-]\");\n\t\tmenu->ModifyMenu(ID_MAIL_SETTINGS, MF_STRING, ID_MAIL_SETTINGS, cstr);\n\t\tmenu->EnableMenuItem(ID_MAIL_SETTINGS, MF_GRAYED);\n\t}\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"RESIDENT\"));\n\tmenu->ModifyMenu(ID_RESIDENT, MF_STRING, ID_RESIDENT, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"HEALTH_STATUS_SETTING\"));\n\tmenu->ModifyMenu(ID_HEALTH_STATUS, MF_STRING, ID_HEALTH_STATUS, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"AAM_APM_CONTROL\"));\n\tmenuState = menu->GetMenuState(ID_AAM_APM, MF_BYCOMMAND);\n\tmenu->ModifyMenu(ID_AAM_APM, MF_STRING, ID_AAM_APM, cstr);\n\n\tcstr = i18n(_T(\"Alarm\"), _T(\"ALARM_TEMPERATURE\"));\n\tmenuState = menu->GetMenuState(ID_TEMPERATURE, MF_BYCOMMAND);\n\tmenu->ModifyMenu(ID_TEMPERATURE, MF_STRING, ID_TEMPERATURE, cstr);\n\n\t/*\n\tif(m_Ata.vars.GetCount() && menuState != MF_GRAYED)\n\t{\n\tmenu->EnableMenuItem(ID_AAM_APM, MF_ENABLED);\n\tmenu->EnableMenuItem(ID_HEALTH_STATUS, MF_ENABLED);\n\t}\n\telse\n\t{\n\tmenu->EnableMenuItem(ID_AAM_APM, MF_GRAYED);\n\tmenu->EnableMenuItem(ID_HEALTH_STATUS, MF_GRAYED);\n\t}\n\t*/\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"AUTO_AAM_APM_ADAPTION\"));\n\tmenu->ModifyMenu(ID_AUTO_AAM_APM, MF_STRING, ID_AUTO_AAM_APM, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"STARTUP\"));\n\tmenu->ModifyMenu(ID_STARTUP, MF_STRING, ID_STARTUP, cstr);\n\n#ifdef UWP\n\tmenu->EnableMenuItem(ID_STARTUP, MF_GRAYED);\n#endif\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"GRAPH\"));\n\tmenu->ModifyMenu(ID_GRAPH, MF_STRING, ID_GRAPH, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"REFRESH\"));\n\tcstr += _T(\"\\tF5\");\n\tmenu->ModifyMenu(ID_REFRESH, MF_STRING, ID_REFRESH, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"RESCAN\"));\n\tcstr += _T(\"\\tF6\");\n\tmenu->ModifyMenu(ID_RESCAN, MF_STRING, ID_RESCAN, cstr);\n\n\tsubMenu.Attach(menu->GetSubMenu(2)->GetSafeHmenu());\n\tcstr = i18n(_T(\"Menu\"), _T(\"AUTO_REFRESH\"));\n\tsubMenu.ModifyMenu(1, MF_BYPOSITION, 1, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"AUTO_REFRESH_TARGET\"));\n\tsubMenu.ModifyMenu(2, MF_BYPOSITION, 2, cstr);\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"ALERT_FEATURES\"));\n\tsubMenu.ModifyMenu(11, MF_BYPOSITION, 11, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"ADVANCED_FEATURE\"));\n\tsubMenu.ModifyMenu(12, MF_BYPOSITION, 12, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"WORKAROUND\"));\n\tsubMenu.ModifyMenu(13, MF_BYPOSITION, 13, cstr);\n\tsubMenu.Detach();\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"OPEN_DISK_MANAGEMENT\"));\n\tmenu->ModifyMenu(ID_OPEN_DISK_MANAGEMENT, MF_STRING, ID_OPEN_DISK_MANAGEMENT, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"OPEN_DEVICE_MANAGER\"));\n\tmenu->ModifyMenu(ID_OPEN_DEVICE_MANAGER, MF_STRING, ID_OPEN_DEVICE_MANAGER, cstr);\n\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"DISABLE\"));\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_DISABLE, MF_STRING, ID_AUTO_REFRESH_DISABLE, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"MINUTE\"));\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_01_MIN, MF_STRING, ID_AUTO_REFRESH_01_MIN, _T(\"1 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_03_MIN, MF_STRING, ID_AUTO_REFRESH_03_MIN, _T(\"3 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_05_MIN, MF_STRING, ID_AUTO_REFRESH_05_MIN, _T(\"5 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_10_MIN, MF_STRING, ID_AUTO_REFRESH_10_MIN, _T(\"10 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_30_MIN, MF_STRING, ID_AUTO_REFRESH_30_MIN, _T(\"30 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_60_MIN, MF_STRING, ID_AUTO_REFRESH_60_MIN, _T(\"60 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_120_MIN, MF_STRING, ID_AUTO_REFRESH_120_MIN, _T(\"120 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_180_MIN, MF_STRING, ID_AUTO_REFRESH_180_MIN, _T(\"180 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_360_MIN, MF_STRING, ID_AUTO_REFRESH_360_MIN, _T(\"360 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_720_MIN, MF_STRING, ID_AUTO_REFRESH_720_MIN, _T(\"720 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_REFRESH_1440_MIN, MF_STRING, ID_AUTO_REFRESH_1440_MIN, _T(\"1440 \") + cstr);\n\n\tCheckRadioAutoRefresh();\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"SECOND\"));\n\tmenu->ModifyMenu(ID_WAIT_0_SEC, MF_STRING, ID_WAIT_0_SEC, _T(\"0 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_5_SEC, MF_STRING, ID_WAIT_5_SEC, _T(\"5 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_10_SEC, MF_STRING, ID_WAIT_10_SEC, _T(\"10 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_15_SEC, MF_STRING, ID_WAIT_15_SEC, _T(\"15 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_20_SEC, MF_STRING, ID_WAIT_20_SEC, _T(\"20 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_30_SEC, MF_STRING, ID_WAIT_30_SEC, _T(\"30 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_40_SEC, MF_STRING, ID_WAIT_40_SEC, _T(\"40 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_50_SEC, MF_STRING, ID_WAIT_50_SEC, _T(\"50 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_60_SEC, MF_STRING, ID_WAIT_60_SEC, _T(\"60 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_90_SEC, MF_STRING, ID_WAIT_90_SEC, _T(\"90 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_120_SEC, MF_STRING, ID_WAIT_120_SEC, _T(\"120 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_150_SEC, MF_STRING, ID_WAIT_150_SEC, _T(\"150 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_180_SEC, MF_STRING, ID_WAIT_180_SEC, _T(\"180 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_210_SEC, MF_STRING, ID_WAIT_210_SEC, _T(\"210 \") + cstr);\n\tmenu->ModifyMenu(ID_WAIT_240_SEC, MF_STRING, ID_WAIT_240_SEC, _T(\"240 \") + cstr);\n\n\tCheckRadioWaitTime();\n\n\t// Advanced Features\n\tsubMenu.Attach(menu->GetSubMenu(2)->GetSubMenu(12)->GetSafeHmenu());\n\tcstr = i18n(_T(\"Menu\"), _T(\"TEMPERATURE_TYPE\"));\n\tsubMenu.ModifyMenu(5, MF_BYPOSITION, 5, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"AUTO_DTECTION\"));\n\tsubMenu.ModifyMenu(6, MF_BYPOSITION, 6, cstr);\n\tcstr = i18n(_T(\"Dialog\"), _T(\"LIST_RAW_VALUES\"));\n\tsubMenu.ModifyMenu(7, MF_BYPOSITION, 7, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"WAIT_TIME_AT_STARTUP\"));\n\tsubMenu.ModifyMenu(8, MF_BYPOSITION, 8, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"RESIDENT_STYLE\"));\n\tsubMenu.ModifyMenu(9, MF_BYPOSITION, 9, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"DRIVE_SORT_METHOD\"));\n\tsubMenu.ModifyMenu(10, MF_BYPOSITION, 10, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"DRIVE_MENU_NUMBER\"));\n\tsubMenu.ModifyMenu(11, MF_BYPOSITION, 11, cstr);\n#ifdef UWP\n\tsubMenu.EnableMenuItem(7, MF_GRAYED);\n#endif\n\tsubMenu.Detach();\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"SECOND\"));\n\tmenu->ModifyMenu(ID_AUTO_DETECTION_05_SEC, MF_STRING, ID_AUTO_DETECTION_05_SEC, _T(\"5 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_DETECTION_10_SEC, MF_STRING, ID_AUTO_DETECTION_10_SEC, _T(\"10 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_DETECTION_20_SEC, MF_STRING, ID_AUTO_DETECTION_20_SEC, _T(\"20 \") + cstr);\n\tmenu->ModifyMenu(ID_AUTO_DETECTION_30_SEC, MF_STRING, ID_AUTO_DETECTION_30_SEC, _T(\"30 \") + cstr);\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"DISABLE\"));\n\tmenu->ModifyMenu(ID_AUTO_DETECTION_DISABLE, MF_STRING, ID_AUTO_DETECTION_DISABLE, cstr);\n\n\tCheckRadioAutoDetection();\n\tCheckRadioRawValues();\n\tCheckRadioCsmiType();\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"CELSIUS\"));\n\tmenu->ModifyMenu(ID_CELSIUS, MF_STRING, ID_CELSIUS, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"FAHRENHEIT\"));\n\tmenu->ModifyMenu(ID_FAHRENHEIT, MF_STRING, ID_FAHRENHEIT, cstr);\n\n\tif (m_bFahrenheit)\n\t{\n\t\tOnFahrenheit();\n\t}\n\telse\n\t{\n\t\tOnCelsius();\n\t}\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"HIDE\"));\n\tmenu->ModifyMenu(ID_RESIDENT_HIDE, MF_STRING, ID_RESIDENT_HIDE, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"MINIMIZE\"));\n\tmenu->ModifyMenu(ID_RESIDENT_MINIMIZE, MF_STRING, ID_RESIDENT_MINIMIZE, cstr);\n\n\tif (m_bResidentMinimize)\n\t{\n\t\tOnResidentMinimize();\n\t}\n\telse\n\t{\n\t\tOnResidentHide();\n\t}\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"PHYSICAL_DRIVE_ID\"));\n\tmenu->ModifyMenu(ID_SORT_PHYSICAL_DRIVE_ID, MF_STRING, ID_SORT_PHYSICAL_DRIVE_ID, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"DRIVE_LETTER\"));\n\tmenu->ModifyMenu(ID_SORT_DRIVE_LETTER, MF_STRING, ID_SORT_DRIVE_LETTER, cstr);\n\n\tif (m_bSortDriveLetter)\n\t{\n\t\tOnSortDriveLetter();\n\t}\n\telse\n\t{\n\t\tOnSortPhysicalDriveId();\n\t}\n\n\tswitch (m_DriveMenuNumber)\n\t{\n\tcase 16: OnDriveMenu16(); break;\n#ifdef MAX_DRIVE_20\n\tcase 10: OnDriveMenu10(); break;\n\tcase 20: OnDriveMenu20(); break;\n#endif\n\tdefault: OnDriveMenu8();  break;\n\t}\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"HELP_WEB\")) + _T(\"\\tF1\");\n\tmenu->ModifyMenu(ID_HELP, MF_STRING, ID_HELP, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"HELP_ABOUT\"));\n\tmenuState = menu->GetMenuState(ID_ABOUT, MF_BYCOMMAND);\n\tmenu->ModifyMenu(ID_ABOUT, MF_STRING, ID_ABOUT, cstr);\n\tmenu->EnableMenuItem(ID_ABOUT, menuState);\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"HELP_ABOUT_SMART\"));\n\tmenu->ModifyMenu(ID_HELP_ABOUT_SMART, MF_STRING, ID_HELP_ABOUT_SMART, cstr);\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"ENABLE_ALL\"));\n\tmenu->ModifyMenu(ID_USB_ENABLE_ALL, MF_STRING, ID_USB_ENABLE_ALL, cstr);\n\tcstr = i18n(_T(\"TrayMenu\"), _T(\"DISABLE_ALL\"));\n\tmenu->ModifyMenu(ID_USB_DISABLE_ALL, MF_STRING, ID_USB_DISABLE_ALL, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"SMART_IN_ENGLISH\"));\n\tmenu->ModifyMenu(ID_SMART_ENGLISH, MF_STRING, ID_SMART_ENGLISH, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"FONT_SETTING\"));\n\tmenu->ModifyMenu(ID_FONT_SETTING, MF_STRING, ID_FONT_SETTING, cstr);\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tcstr = i18n(_T(\"Menu\"), _T(\"STARTUP_VOICE\"));\n\tmenu->ModifyMenu(ID_STARTUP_VOICE, MF_STRING, ID_STARTUP_VOICE, cstr);\n#endif\n\n\t// Check Status\n\n\tif (m_bDumpIdentifyDevice)\n\t{\n\t\tmenu->CheckMenuItem(ID_DUMP_IDENTIFY_DEVICE, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_DUMP_IDENTIFY_DEVICE, MF_UNCHECKED);\n\t}\n\n\tif (m_bDumpSmartReadData)\n\t{\n\t\tmenu->CheckMenuItem(ID_DUMP_SMART_READ_DATA, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_DUMP_SMART_READ_DATA, MF_UNCHECKED);\n\t}\n\n\tif (m_bDumpSmartReadThreshold)\n\t{\n\t\tmenu->CheckMenuItem(ID_DUMP_SMART_READ_THRESHOLD, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_DUMP_SMART_READ_THRESHOLD, MF_UNCHECKED);\n\t}\n\n\tif (m_bAsciiView)\n\t{\n\t\tmenu->CheckMenuItem(ID_ASCII_VIEW, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_ASCII_VIEW, MF_UNCHECKED);\n\t}\n\n#ifdef SUISHO_SHIZUKU_SUPPORT\n\tif (m_bStartupVoice)\n\t{\n\t\tmenu->CheckMenuItem(ID_STARTUP_VOICE, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_STARTUP_VOICE, MF_UNCHECKED);\n\t}\n#endif\n\n\tif (m_bSmartEnglish)\n\t{\n\t\tmenu->CheckMenuItem(ID_SMART_ENGLISH, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_SMART_ENGLISH, MF_UNCHECKED);\n\t}\n\n\tif (m_bHideSerialNumber)\n\t{\n\t\tmenu->CheckMenuItem(ID_HIDE_SERIAL_NUMBER, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_HIDE_SERIAL_NUMBER, MF_UNCHECKED);\n\t}\n\n\tif (m_bHideSmartInfo)\n\t{\n\t\tmenu->CheckMenuItem(ID_HIDE_SMART_INFO, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_HIDE_SMART_INFO, MF_UNCHECKED);\n\t}\n\n\tif (m_bHideNoSmartDisk)\n\t{\n\t\tmenu->CheckMenuItem(ID_HIDE_NO_SMART_DISK, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_HIDE_NO_SMART_DISK, MF_UNCHECKED);\n\t}\n\n\tif (m_bAdvancedDiskSearch)\n\t{\n\t\tmenu->CheckMenuItem(ID_ADVANCED_DISK_SEARCH, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_ADVANCED_DISK_SEARCH, MF_UNCHECKED);\n\t}\n\n\tif (m_bWorkaroundHD204UI)\n\t{\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_HD204UI, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_HD204UI, MF_UNCHECKED);\n\t}\n\n\tif (m_bWorkaroundIE8MODE)\n\t{\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_IE8MODE, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_IE8MODE, MF_UNCHECKED);\n\t}\n\n\tif (m_bWorkaroundIgnoreC4)\n\t{\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_IGNORE_C4, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_WORKAROUND_IGNORE_C4, MF_UNCHECKED);\n\t}\n\n\tif (GetIeVersion() >= 900)\n\t{\n\t\tmenu->EnableMenuItem(ID_WORKAROUND_IE8MODE, MF_ENABLED);\n\t}\n\telse\n\t{\n\t\tmenu->EnableMenuItem(ID_WORKAROUND_IE8MODE, MF_GRAYED);\n\t}\n\n\tif (GetIeVersion() >= 600)\n\t{\n\t\tmenu->EnableMenuItem(ID_GRAPH, MF_ENABLED);\n\t}\n\telse\n\t{\n\t\tmenu->EnableMenuItem(ID_GRAPH, MF_GRAYED);\n\t}\n\n\tif (m_bEventLog)\n\t{\n\t\tmenu->CheckMenuItem(ID_EVENT_LOG, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_EVENT_LOG, MF_UNCHECKED);\n\t}\n\n\tif (m_bAlertMail)\n\t{\n\t\tmenu->CheckMenuItem(ID_ALERT_MAIL, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_ALERT_MAIL, MF_UNCHECKED);\n\t}\n\n\tif (m_bAtaPassThroughSmart)\n\t{\n\t\tmenu->CheckMenuItem(ID_ATA_PASS_THROUGH_SMART, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_ATA_PASS_THROUGH_SMART, MF_UNCHECKED);\n\t}\n\n\tif (m_bGadget)\n\t{\n\t\tmenu->CheckMenuItem(ID_GADGET_SUPPORT, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_GADGET_SUPPORT, MF_UNCHECKED);\n\t}\n\n\tif (m_bAutoAamApm)\n\t{\n\t\tmenu->CheckMenuItem(ID_AUTO_AAM_APM, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_AUTO_AAM_APM, MF_UNCHECKED);\n\t}\n\n\tif (m_bResident)\n\t{\n\t\tmenu->CheckMenuItem(ID_RESIDENT, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_RESIDENT, MF_UNCHECKED);\n\t}\n\n\tif (m_bStartup)\n\t{\n\t\tmenu->CheckMenuItem(ID_STARTUP, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_STARTUP, MF_UNCHECKED);\n\t}\n\n\tif (m_bAlertSound)\n\t{\n\t\tmenu->CheckMenuItem(ID_ALERT_SOUND, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_ALERT_SOUND, MF_UNCHECKED);\n\t}\n\n\t//\tmenu->EnableMenuItem(ID_ALARM_HISTORY, MF_GRAYED);\n\t//\tmenu->EnableMenuItem(ID_ALERT_SOUND, MF_GRAYED);\n\t//\tmenu->EnableMenuItem(ID_SOUND_SETTINGS, MF_GRAYED);\n\n\t//////////////////////////////////////////////////////////////////////////////////\n\t// Theme\n\t//////////////////////////////////////////////////////////////////////////////////\n\tsubMenu.Attach(menu->GetSubMenu(3)->GetSafeHmenu());\n\tcstr = i18n(_T(\"Menu\"), _T(\"ZOOM\"));\n\tsubMenu.ModifyMenu(0, MF_BYPOSITION, 0, cstr);\n\tsubMenu.Detach();\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"AUTO\"));\n\tmenu->ModifyMenu(ID_ZOOM_AUTO, MF_STRING, ID_ZOOM_AUTO, cstr);\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"GREEN_MODE\"));\n\tmenu->ModifyMenu(ID_GREEN_MODE, MF_STRING, ID_GREEN_MODE, cstr);\n\n//\tcstr = i18n(_T(\"Menu\"), _T(\"DISABLE_DARK_MODE\"));\n//\tmenu->ModifyMenu(ID_DISABLE_DARK_MODE, MF_STRING, ID_DISABLE_DARK_MODE, cstr);\n\n\tCheckRadioZoomType();\n\n\tif (m_bGreenMode)\n\t{\n\t\tmenu->CheckMenuItem(ID_GREEN_MODE, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_GREEN_MODE, MF_UNCHECKED);\n\t}\n\n\tif (m_bForceDisableDarkMode)\n\t{\n\t\tmenu->CheckMenuItem(ID_DISABLE_DARK_MODE, MF_CHECKED);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuItem(ID_DISABLE_DARK_MODE, MF_UNCHECKED);\n\t}\n\n\t//////////////////////////////////////////////////////////////////////////////////\n\t// Disk\n\t//////////////////////////////////////////////////////////////////////////////////\n\tsubMenu.Attach(menu->GetSubMenu(MENU_DRIVE_INDEX)->GetSafeHmenu());\n\twhile (subMenu.RemoveMenu(0, MF_BYPOSITION));\n\n\tMENUITEMINFO subMenuInfo;\n\tZeroMemory(&subMenuInfo, sizeof(MENUITEMINFO));\n\tsubMenuInfo.cbSize = sizeof(MENUITEMINFO);\n\tsubMenuInfo.fMask = MIIM_CHECKMARKS | MIIM_TYPE | MIIM_STATE | MIIM_ID | MIIM_SUBMENU;\n\tsubMenuInfo.fType = MFT_RADIOCHECK;\n\tsubMenuInfo.hbmpChecked = NULL;\n\tsubMenuInfo.fState = MFS_UNCHECKED;\n\tsubMenuInfo.hSubMenu = NULL;\n\n\tfor (int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tCString cstr;\n\t\tif (m_Ata.vars[i].TotalDiskSize >= 1000)\n\t\t{\n\t\t\tif (! m_Ata.vars[i].DriveMap.IsEmpty())\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"(%d) %s : %.1f GB [%s]\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize / 1000.0, m_Ata.vars[i].DriveMap.GetString());\n\t\t\t}\n\t\t\telse if(m_Ata.vars[i].PhysicalDriveId >= 0)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"(%d) %s : %.1f GB [Disk %d]\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize / 1000.0, m_Ata.vars[i].PhysicalDriveId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"(%d) %s : %.1f GB\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize / 1000.0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!m_Ata.vars[i].DriveMap.IsEmpty())\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"(%d) %s : %d MB [%s]\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize, m_Ata.vars[i].DriveMap.GetString());\n\t\t\t}\n\t\t\telse if (m_Ata.vars[i].PhysicalDriveId >= 0)\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"(%d) %s : %d MB [Disk %d]\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize, m_Ata.vars[i].PhysicalDriveId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"(%d) %s : %d MB\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize);\n\t\t\t}\n\t\t}\n\t\tsubMenuInfo.wID = SELECT_DISK_BASE + i;\n\t\tsubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\t\tsubMenu.InsertMenuItem(-1, &subMenuInfo);\n\n\t\tif (i % m_DriveMenuNumber == (m_DriveMenuNumber - 1) && i + (INT_PTR)1 != m_Ata.vars.GetCount())\n\t\t{\n\t\t\tsubMenu.AppendMenu(MF_SEPARATOR);\n\t\t}\n\t}\n\tsubMenu.CheckMenuRadioItem(SELECT_DISK_BASE, SELECT_DISK_BASE + (INT)m_Ata.vars.GetCount(),\n\t\tSELECT_DISK_BASE + m_SelectDisk, MF_BYCOMMAND);\n\tsubMenu.Detach();\n\n\t// Auto Refresh Target\n\tsubSubMenu.Attach(menu->GetSubMenu(2)->GetSubMenu(2)->GetSafeHmenu());\n\twhile (subSubMenu.RemoveMenu(0, MF_BYPOSITION));\n\n\tMENUITEMINFO subSubMenuInfo;\n\tZeroMemory(&subSubMenuInfo, sizeof(MENUITEMINFO));\n\tsubSubMenuInfo.cbSize = sizeof(MENUITEMINFO);\n\tsubSubMenuInfo.fMask = MIIM_CHECKMARKS | MIIM_TYPE | MIIM_STATE | MIIM_ID;\n\tsubSubMenuInfo.fType = NULL;\n\tsubSubMenuInfo.hbmpChecked = NULL;\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"AUTO_REFRESH_TARGET_ALL_DISK\"));\n\tsubSubMenuInfo.wID = AUTO_REFRESH_TARGET_BASE + CAtaSmart::MAX_DISK;\n\tsubSubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubSubMenu.InsertMenuItem(-1, &subSubMenuInfo);\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"AUTO_REFRESH_UNTARGET_ALL_DISK\"));\n\tsubSubMenuInfo.wID = AUTO_REFRESH_TARGET_BASE + CAtaSmart::MAX_DISK + 1;\n\tsubSubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\tsubSubMenu.InsertMenuItem(-1, &subSubMenuInfo);\n\n\tsubSubMenu.AppendMenu(MF_SEPARATOR);\n\tfor (int i = 0; i < m_Ata.vars.GetCount(); i++)\n\t{\n\t\tif (m_Ata.vars[i].TotalDiskSize >= 1000)\n\t\t{\n\t\t\tcstr.Format(_T(\"(%d) %s %.1f GB\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize / 1000.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"(%d) %s %d MB\"), i + 1, m_Ata.vars[i].Model.GetString(), m_Ata.vars[i].TotalDiskSize);\n\t\t}\n\t\tsubSubMenuInfo.wID = AUTO_REFRESH_TARGET_BASE + i;\n\t\tsubSubMenuInfo.dwTypeData = (LPWSTR)cstr.GetString();\n\t\tif (m_bAutoRefreshTarget[i])\n\t\t{\n\t\t\tsubSubMenuInfo.fState = MFS_CHECKED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsubSubMenuInfo.fState = MFS_UNCHECKED;\n\t\t}\n\n\t\tsubSubMenu.InsertMenuItem(-1, &subSubMenuInfo);\n\n\t\tif (i % m_DriveMenuNumber == (m_DriveMenuNumber - 1) && i + (INT_PTR)1 != m_Ata.vars.GetCount())\n\t\t{\n\t\t\tsubSubMenu.AppendMenu(MF_SEPARATOR);\n\t\t}\n\t}\n\tsubSubMenu.Detach();\n\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\t//////////////////////////////////////////////////////////////////////////////////\n\t// Main Window\n\t//////////////////////////////////////////////////////////////////////////////////\n\tSetLabel(m_CtrlLabelFirmware, m_LabelFirmware, i18n(_T(\"Dialog\"), _T(\"FIRMWARE\")));\n\tSetLabel(m_CtrlLabelSerialNumber, m_LabelSerialNumber, i18n(_T(\"Dialog\"), _T(\"SERIAL_NUMBER\")));\n\tSetLabel(m_CtrlLabelTemperature, m_LabelTemperature, i18n(_T(\"Dialog\"), _T(\"TEMPERATURE\")));\n\tSetLabel(m_CtrlLabelPowerOnHours, m_LabelPowerOnHours, i18n(_T(\"Dialog\"), _T(\"POWER_ON_HOURS\")));\n\tSetLabel(m_CtrlLabelPowerOnCount, m_LabelPowerOnCount, i18n(_T(\"Dialog\"), _T(\"POWER_ON_COUNT\")));\n\tSetLabel(m_CtrlLabelFeature, m_LabelFeature, i18n(_T(\"Dialog\"), _T(\"FEATURE\")));\n\tSetLabel(m_CtrlLabelDriveMap, m_LabelDriveMap, i18n(_T(\"Dialog\"), _T(\"DRIVE_LETTER\")));\n\tSetLabel(m_CtrlLabelInterface, m_LabelInterface, i18n(_T(\"Dialog\"), _T(\"INTERFACE\")));\n\tSetLabel(m_CtrlLabelTransferMode, m_LabelTransferMode, i18n(_T(\"Dialog\"), _T(\"TRANSFER_MODE\")));\n\tSetLabel(m_CtrlLabelAtaAtapi, m_LabelAtaAtapi, i18n(_T(\"Dialog\"), _T(\"STANDARD\")));\n\tSetLabel(m_CtrlLabelDiskStatus, m_LabelDiskStatus, i18n(_T(\"Dialog\"), _T(\"HEALTH_STATUS\")));\n\tSetLabel(m_CtrlLabelBufferSize, m_LabelBufferSize, i18n(_T(\"Dialog\"), _T(\"BUFFER_SIZE\")));\n\tSetLabel(m_CtrlLabelNvCacheSize, m_LabelNvCacheSize, i18n(_T(\"Dialog\"), _T(\"NV_CACHE_SIZE\")));\n\tSetLabel(m_CtrlLabelRotationRate, m_LabelRotationRate, i18n(_T(\"Dialog\"), _T(\"ROTATION_RATE\")));\n\n\tif (m_Ata.vars.GetCount() > 0)\n\t{\n\t\tif (m_Ata.vars[m_SelectDisk].HostReads >= 0)\n\t\t{\n\t\t\tSetLabel(m_CtrlLabelBufferSize, m_LabelBufferSize, i18n(_T(\"Dialog\"), _T(\"TOTAL_HOST_READS\")));\n\t\t}\n\n\t\tif (m_Ata.vars[m_SelectDisk].HostWrites >= 0)\n\t\t{\n\t\t\tSetLabel(m_CtrlLabelNvCacheSize, m_LabelNvCacheSize, i18n(_T(\"Dialog\"), _T(\"TOTAL_HOST_WRITES\")));\n\t\t}\n\n\t\tif (m_Ata.vars[m_SelectDisk].NandWrites >= 0)\n\t\t{\n\t\t\tSetLabel(m_CtrlLabelRotationRate, m_LabelRotationRate, i18n(_T(\"Dialog\"), _T(\"TOTAL_NAND_WRITES\")));\n\t\t}\n\t\telse if (m_Ata.vars[m_SelectDisk].GBytesErased >= 0)\n\t\t{\n\t\t\tSetLabel(m_CtrlLabelRotationRate, m_LabelRotationRate, i18n(_T(\"SmartSandForce\"), _T(\"64\")));\n\t\t}\n\t\t/*\n\t\telse if(m_Ata.vars[m_SelectDisk].WearLevelingCount >= 0)\n\t\t{\n\t\t//\tm_LabelRotationRate = i18n(_T(\"Dialog\"), _T(\"WEAR_LEVELING_COUNT\"));\n\t\tSetLabel(m_LabelRotationRate, _T(\"LabelRotationRate\"), i18n(_T(\"Dialog\"), _T(\"WEAR_LEVELING_COUNT\")));\n\t\t}\n\t\t*/\n\t}\n\n\tUpdateData(FALSE);\n\n\tRebuildListHeader(m_SelectDisk, TRUE);\n\tChangeDisk(m_SelectDisk);\n\tInitDriveList();\n\tUpdateToolTip();\n\tInitListCtrl();\n\tUpdateListCtrl(m_SelectDisk);\n\n\tif (m_bResident)\n\t{\n\t\tUpdateTrayTemperatureIcon(TRUE);\n\t}\n\n\tSetClientSize(m_SizeX, m_SizeY, m_ZoomRatio);\n\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Language\"), LangName, m_Ini);\n}\n\nvoid CDiskInfoDlg::OnDiskStatus() { OnHealthStatus(); }\nvoid CDiskInfoDlg::OnPreDisk() { SelectDrive(m_SelectDisk - 1); }\nvoid CDiskInfoDlg::OnNextDisk() { SelectDrive(m_SelectDisk + 1); }\n\nint CDiskInfoDlg::GetSelectedDrive()\n{\n\treturn m_SelectDisk;\n}\n\nvoid CDiskInfoDlg::SelectDrive(DWORD i)\n{\n\tif (i >= (DWORD)m_Ata.vars.GetCount())\n\t{\n\t\treturn;\n\t}\n\n\tCWaitCursor wait;\n\tstatic int preFlagFahrenheit = -1;\n\n\tswitch (m_Ata.UpdateSmartInfo(i))\n\t{\n\tcase CAtaSmart::SMART_STATUS_MAJOR_CHANGE:\n\tcase CAtaSmart::SMART_STATUS_MINOR_CHANGE:\n\t\tSaveSmartInfo(i);\n\t\tAlertSound(0, AS_PLAY_SOUND);\n\t\tUpdateShareInfo();\n\t\tbreak;\n\tdefault:\n\t\tif (m_SelectDisk == i)\n\t\t{\n\t\t\tif (preFlagFahrenheit == m_bFahrenheit)\n\t\t\t{\n\t\t\t\t//\treturn ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpreFlagFahrenheit = m_bFahrenheit;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tm_SelectDisk = i;\n\tm_DriveMenuPage = i / m_DriveMenuNumber;\n\tChangeDisk(i);\n\tUpdateListCtrl(i);\n\tInitDriveList();\n\tUpdateToolTip();\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(SELECT_DISK_BASE, SELECT_DISK_BASE + (INT)m_Ata.vars.GetCount(),\n\t\tSELECT_DISK_BASE + m_SelectDisk, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\tCheckPage();\n\n\tif (m_bResident)\n\t{\n\t\tUpdateTrayTemperatureIcon(FALSE);\n\t}\n}\n\nvoid CDiskInfoDlg::CheckPage()\n{\n\tCString cstr;\n\tif (m_Ata.vars.GetCount() > 1)\n\t{\n\t\tif (0 < m_SelectDisk)\n\t\t{\n\t\t\tm_CtrlButtonPreDisk.ShowWindow(SW_SHOW);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_CtrlButtonPreDisk.ShowWindow(SW_HIDE);\n\t\t}\n\n\t\tif (m_SelectDisk < (DWORD)m_Ata.vars.GetCount() - 1)\n\t\t{\n\t\t\tm_CtrlButtonNextDisk.ShowWindow(SW_SHOW);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_CtrlButtonNextDisk.ShowWindow(SW_HIDE);\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_CtrlButtonPreDisk.ShowWindow(SW_HIDE);\n\t\tm_CtrlButtonNextDisk.ShowWindow(SW_HIDE);\n\t}\n}\n\nvoid CDiskInfoDlg::SaveSmartInfo(DWORD i)\n{\n\tif (!m_Ata.vars[i].IsSmartCorrect)\n\t{\n\t\treturn;\n\t}\n\n\tstatic CTime preTime[CAtaSmart::MAX_DISK] = { 0 };\n\tCTime time = CTime::GetTickCount();\n\n\tif (time - preTime[i] < SAVE_SMART_PERIOD)\n\t{\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tpreTime[i] = time;\n\t}\n\n\tCString line;\n\tCString cstr;\n\tCStdioFile outFile;\n\tCString dir;\n\tCString disk;\n\tCString path;\n\tBOOL flagFirst = FALSE;\n\tTCHAR str[256];\n\n\tdir = m_SmartDir;\n\tCreateDirectory(dir, NULL);\n\n\tdisk = m_Ata.vars[i].ModelSerial;\n\tdir += disk;\n\tCreateDirectory(dir, NULL);\n\n\tAlarmHealthStatus(i, dir, disk);\n\n\n\t// Computer Name\n\t// \n\tDWORD length = 256;\n\tGetComputerNameW(str, &length);\n\tWritePrivateProfileStringFx(L\"PC\", L\"ComputerName\", str, dir + _T(\"\\\\\") + SMART_INI);\n\n\tGetPrivateProfileStringFx(disk, _T(\"Date\"), _T(\"\"), str, 256, dir + _T(\"\\\\\") + SMART_INI);\n\tcstr = str;\n\tif (cstr.IsEmpty())\n\t{\n\t\tflagFirst = TRUE;\n\t\t_stprintf_s(str, 256, _T(\"%s\"), time.Format(_T(\"%Y/%m/%d %H:%M:%S\")).GetBuffer());\n\t\tWritePrivateProfileStringFx(disk + _T(\"FIRST\"), _T(\"Date\"), str, dir + _T(\"\\\\\") + SMART_INI);\n\n\t\t_stprintf_s(str, 256, _T(\"%d\"), m_Ata.vars[i].DiskStatus);\n\t\tWritePrivateProfileStringFx(disk + _T(\"FIRST\"), _T(\"HealthStatus\"), str, dir + _T(\"\\\\\") + SMART_INI);\n\t}\n\n\t// Check Threshold of Reallocated Sectors Count\n\tGetPrivateProfileStringFx(disk + _T(\"THRESHOLD\"), _T(\"05\"), _T(\"\"), str, 256, dir + _T(\"\\\\\") + SMART_INI);\n\tcstr = str;\n\tif (cstr.IsEmpty())\n\t{\n\t\tflagFirst = TRUE;\n\t}\n\n\t_stprintf_s(str, 256, _T(\"%s\"), time.Format(_T(\"%Y/%m/%d %H:%M:%S\")).GetBuffer());\n\tWritePrivateProfileStringFx(disk, _T(\"Date\"), str, dir + _T(\"\\\\\") + SMART_INI);\n\n\t_stprintf_s(str, 256, _T(\"%d\"), m_Ata.vars[i].DiskStatus);\n\tWritePrivateProfileStringFx(disk, _T(\"HealthStatus\"), str, dir + _T(\"\\\\\") + SMART_INI);\n\n\tif (m_Ata.vars[i].Temperature > -300)\n\t{\n\t\tAppendLog(dir, disk, _T(\"Temperature\"), time, m_Ata.vars[i].Temperature, flagFirst);\n\t}\n\n\tif (m_Ata.vars[i].MeasuredPowerOnHours > 0 && m_NowDetectingUnitPowerOnHours == FALSE)\n\t{\n\t\tAppendLog(dir, disk, _T(\"PowerOnHours\"), time, m_Ata.vars[i].MeasuredPowerOnHours, flagFirst);\n\t}\n\n\tif (m_Ata.vars[i].PowerOnCount >= 0)\n\t{\n\t\tAppendLog(dir, disk, _T(\"PowerOnCount\"), time, m_Ata.vars[i].PowerOnCount, flagFirst);\n\t}\n\n\tif (m_Ata.vars[i].Life >= 0)\n\t{\n\t\tAppendLog(dir, disk, _T(\"Life\"), time, m_Ata.vars[i].Life, flagFirst);\n\t}\n\n\tif (m_Ata.vars[i].HostWrites >= 0)\n\t{\n\t\tAppendLog(dir, disk, _T(\"HostWrites\"), time, m_Ata.vars[i].HostWrites, flagFirst);\n\t}\n\n\tif (m_Ata.vars[i].HostReads >= 0)\n\t{\n\t\tAppendLog(dir, disk, _T(\"HostReads\"), time, m_Ata.vars[i].HostReads, flagFirst);\n\t}\n\n\tif (m_Ata.vars[i].NandWrites >= 0)\n\t{\n\t\tAppendLog(dir, disk, _T(\"NandWrites\"), time, m_Ata.vars[i].NandWrites, flagFirst);\n\t}\n\n\tif (m_Ata.vars[i].GBytesErased >= 0)\n\t{\n\t\tAppendLog(dir, disk, _T(\"GBytesErased\"), time, m_Ata.vars[i].GBytesErased, flagFirst);\n\t}\n\n\tif (m_Ata.vars[i].WearLevelingCount >= 0)\n\t{\n\t\tAppendLog(dir, disk, _T(\"WearLevelingCount\"), time, m_Ata.vars[i].WearLevelingCount, flagFirst);\n\t}\n\n\tfor (DWORD j = 0; j < m_Ata.vars[i].AttributeCount; j++)\n\t{\n\t\tcstr.Format(_T(\"%02X\"), m_Ata.vars[i].Attribute[j].Id);\n\t\tAppendLog(dir, disk, cstr, time, m_Ata.vars[i].Attribute[j].CurrentValue,\n\t\t\tflagFirst, m_Ata.vars[i].Threshold[j].ThresholdValue);\n\n\t\tswitch (m_Ata.vars[i].Attribute[j].Id)\n\t\t{\n\t\tcase 0x05: // Reallocated Sectors Count\n\t\t\tAppendLog(dir, disk, _T(\"ReallocatedSectorsCount\"), time,\n\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[0], m_Ata.vars[i].Attribute[j].RawValue[1]), flagFirst);\n\t\t\tbreak;\n\t\tcase 0xC4: // Reallocation Event Count\n\t\t\tAppendLog(dir, disk, _T(\"ReallocationEventCount\"), time,\n\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[0], m_Ata.vars[i].Attribute[j].RawValue[1]), flagFirst);\n\t\t\tbreak;\n\t\tcase 0xC5: // Current Pending Sector Count\n\t\t\tAppendLog(dir, disk, _T(\"CurrentPendingSectorCount\"), time,\n\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[0], m_Ata.vars[i].Attribute[j].RawValue[1]), flagFirst);\n\t\t\tbreak;\n\t\tcase 0xC6: // Off-Line Scan Uncorrectable Sector Count\n\t\t\tAppendLog(dir, disk, _T(\"UncorrectableSectorCount\"), time,\n\t\t\t\tMAKEWORD(m_Ata.vars[i].Attribute[j].RawValue[0], m_Ata.vars[i].Attribute[j].RawValue[1]), flagFirst);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nBOOL CDiskInfoDlg::AppendLog(CString dir, CString disk, CString file, CTime time, int value, BOOL flagFirst, int threshold)\n{\n\tTCHAR str[256];\n\n\t// First Time\n\tif (flagFirst)\n\t{\n\t\twsprintf(str, _T(\"%d\"), value);\n\t\tWritePrivateProfileStringFx(disk + _T(\"FIRST\"), file, str, dir + _T(\"\\\\\") + SMART_INI);\n\n\t\tif (file.GetLength() == 2)\n\t\t{\n\t\t\twsprintf(str, _T(\"%d\"), threshold);\n\t\t\tWritePrivateProfileStringFx(disk + _T(\"THRESHOLD\"), file, str, dir + _T(\"\\\\\") + SMART_INI);\n\t\t}\n\t}\n\n\tGetPrivateProfileStringFx(disk, file, _T(\"-1\"), str, 256, dir + _T(\"\\\\\") + SMART_INI);\n\tint pre = _tstoi(str);\n\n\tif (pre != value)\n\t{\n\t\t// Update\n\t\twsprintf(str, _T(\"%d\"), value);\n\t\tWritePrivateProfileStringFx(disk, file, str, dir + _T(\"\\\\\") + SMART_INI);\n\n\t\tCString line;\n\t\tline.Format(_T(\"%s,%d\\n\"), time.Format(_T(\"%Y/%m/%d %H:%M:%S\")).GetString(), value);\n\n\t\tCStdioFile outFile;\n\t\tif (outFile.Open(dir + _T(\"\\\\\") + file + _T(\".csv\"),\n\t\t\tCFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::typeText))\n\t\t{\n\t\t\tULONGLONG fileLength = outFile.GetLength();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (outFile.SeekToEnd() == fileLength)\n\t\t\t\t{\n\t\t\t\t\toutFile.WriteString(line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (CFileException * e)\n\t\t\t{\n\t\t\t\tDebugPrint(L\"CFileException\");\n\t\t\t\te->Delete();\n\t\t\t}\n\t\t\toutFile.Close();\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n"
        },
        {
          "name": "DnpService.h",
          "type": "blob",
          "size": 5.8134765625,
          "content": "﻿// http://www.dinop.com/vc/service_ctrl.html (ja)\n\n#pragma once\n\n#include <winsvc.h>\n#include \"atlstr.h\"\n\nclass\tCDnpService\n{\n\t//\n\t//\tサービスの起動／停止用スレッドクラス\n\t//\n\tclass CServiceThread\n\t{\n\tpublic:\n\t\tCServiceThread()\n\t\t{\n\t\t\t_bCancel = false;\n\t\t}\n\n\tprivate:\n\n\t\tbool\t\t\t\t\t_bCancel;\t\t\t//サービスの起動／停止処理中断用変数、trueなら中断開始\n\t\tCComAutoCriticalSection\t_secbCancel;\t\t//サービスの起動／停止処理中断用クリティカルセクション\n\n\tpublic:\n\n\t\t//\n\t\t//\tサービスの起動／停止処理中断用関数\n\t\t//\n\t\t//\t中断したい場合はIsCancel(true,true)を呼び出す\n\t\t//\n\t\tbool\tIsCancel(bool bSave=false,bool bNewValue=false)\n\t\t{\n\t\t\tbool\tret;\n\n\t\t\t_secbCancel.Lock();\n\t\t\t\tif(bSave)\n\t\t\t\t{\n\t\t\t\t\t_bCancel = bNewValue;\n\t\t\t\t\tret = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tret = _bCancel;\n\t\t\t_secbCancel.Unlock();\n\n\t\t\treturn\tret;\n\t\t}\n\n\n\n\t\t//\n\t\t//\tサービスの簡易コントロール\n\t\t//\n\t\t//\tそのまま呼び出すとサービスが起動／停止するまで無限ループで待機する。\n\t\t//\tスレッド中で呼び出し、IsCancel()を利用することで無限ループに陥らない\n\t\t//\tコントロールが可能。\n\t\t//\n\t\tbool EasyStartStop(LPCTSTR pszName, bool b)\n\t\t{\n\t\t\t//bool\t\t\tret = false;\n\t\t\tBOOL\t\t\tbRet = FALSE;\n\t\t\tSC_HANDLE\t\thManager = NULL;\n\t\t\tSC_HANDLE\t\thService = NULL;\n\t\t\tSERVICE_STATUS\tsStatus;\n\n\t\t\thManager = ::OpenSCManager(NULL,NULL,GENERIC_EXECUTE);\n\t\t\tif(hManager == NULL)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\thService = ::OpenService(hManager, pszName, SERVICE_START | SERVICE_QUERY_STATUS);\n\t\t\tif(hService == NULL)\n\t\t\t{\n\t\t\t\tif(hManager){::CloseServiceHandle(hManager);}\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\t::ZeroMemory(&sStatus,sizeof(SERVICE_STATUS));\n\t\t\tbRet = ::QueryServiceStatus(hService,&sStatus);\n\t\t\tif(bRet == FALSE)\n\t\t\t{\n\t\t\t\tif(hService){::CloseServiceHandle(hService);}\n\t\t\t\tif(hManager){::CloseServiceHandle(hManager);}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif(sStatus.dwCurrentState == SERVICE_RUNNING)\n\t\t\t{\n\t\t\t\tif(hService){::CloseServiceHandle(hService);}\n\t\t\t\tif(hManager){::CloseServiceHandle(hManager);}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tCString cstr;\n\t\t\tcstr.Format(_T(\"sStatus.dwCurrentState:%08X\"), sStatus.dwCurrentState);\n\t\t\tDebugPrint(cstr);\n\n\t\t\t//サービス開始要求\n\t\t\tDebugPrint(_T(\"StartService - 1\"));\n\t\t\tbRet = ::StartService(hService, NULL, NULL);\n\n\t\t\t//開始まで無限ループで待機\n\t\t\tDebugPrint(_T(\"QueryServiceStatus - 1\"));\n\t\t\tint count = 0;\n\t\t\twhile(::QueryServiceStatus(hService, &sStatus))\n\t\t\t{\n\t\t\t\t// 無限ループを回避 (最大 1 秒間 WMI の初期化を待つ)\n\t\t\t\tif(count >= 4)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(sStatus.dwCurrentState == SERVICE_RUNNING)\n\t\t\t\t{\n\t\t\t\t\tDebugPrint(_T(\"StartService Completed : SERVICE_RUNNING\"));\n\t\t\t\t\tif(hService){::CloseServiceHandle(hService);}\n\t\t\t\t\tif(hManager){::CloseServiceHandle(hManager);}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t::Sleep(100 * count);\n\t\t\t\tDebugPrint(_T(\"Sleep\"));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\t\n\t\t\t// サービスの起動モードを auto に強制変更\n\t\t\tShellExecute(NULL, NULL, _T(\"sc\"), _T(\"config Winmgmt start= auto\"), NULL, SW_HIDE);\n\t\t\tcount = 0;\n\t\t\tDebugPrint(_T(\"QueryServiceStatus - 2\"));\n\t\t\twhile(::QueryServiceStatus(hService, &sStatus))\n\t\t\t{\n\t\t\t\t//サービス開始要求\n\t\t\t\tDebugPrint(_T(\"StartService - 2\"));\n\t\t\t\t::StartService(hService, NULL, NULL);\n\n\t\t\t\t// 無限ループを回避 (最大 5 秒間 WMI の初期化を待つ)\n\t\t\t\tif(count >= 10)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(sStatus.dwCurrentState == SERVICE_RUNNING)\n\t\t\t\t{\n\t\t\t\t\tDebugPrint(_T(\"StartService Completed : SERVICE_RUNNING\"));\n\t\t\t\t\tif(hService){::CloseServiceHandle(hService);}\n\t\t\t\t\tif(hManager){::CloseServiceHandle(hManager);}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t::Sleep(500);\n\t\t\t\tDebugPrint(_T(\"Sleep\"));\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\tif(hService){::CloseServiceHandle(hService);}\n\t\t\tif(hManager){::CloseServiceHandle(hManager);}\n\t\t\treturn false;\n\t\t}\n\t};\n\n\npublic:\n\n\n\t//\n\t//\tサービスの簡易コントロール\n\t//\n\t//\tサービスが起動/停止するまで無限ループで待機する。\n\t//\n\tbool\tEasyStartStop(LPCTSTR pszName,bool bStart)\n\t{\n\t\tCServiceThread\tcThread;\n\n\t\treturn\tcThread.EasyStartStop(pszName,bStart);\n\t}\n\n\n\t//\n\t//\tサービスの簡易起動\n\t//\n\t//\tサービスが起動するまで無限ループで待機する。\n\t//\n\tbool\tEasyStart(LPCTSTR pszName)\n\t{\n\t\treturn\tEasyStartStop(pszName,true);\n\t}\n\n\t//\n\t//\tサービスの簡易停止\n\t//\n\t//\tサービスが停止するまで無限ループで待機する。\n\t//\n\tbool\tEasyStop(LPCTSTR pszName)\n\t{\n\t\treturn\tEasyStartStop(pszName,false);\n\t}\n\n\n\t//\n\t//\tサービスの簡易再起動\n\t//\n\t//\tサービスが再起動するまで無限ループで待機する。\n\t//\n\tbool\tEasyRestart(LPCTSTR pszName)\n\t{\n\t\tbool\t\t\tret;\n\t\tCServiceThread\tcThread;\n\n\t\tret = cThread.EasyStartStop(pszName,false);\n\t\tif(ret)\n\t\t\tret = cThread.EasyStartStop(pszName,true);\n\n\t\treturn\tret;\n\t}\n\n\n\n\t//\n\t//\t指定するサービスが動いているかのチェック\n\t//\n\t//\tfalseの場合は\"停止\"とは限らない。サービスが存在しない場合などもfalseとなる。\n\t//\n\tbool\tIsServiceRunning(LPCTSTR pszName)\n\t{\n\t\tbool\t\t\tret;\n\t\tBOOL\t\t\tbRet;\n\t\tSC_HANDLE\t\thManager;\n\t\tSC_HANDLE\t\thService;\n\t\tSERVICE_STATUS\tsStatus;\n\n\t\tret = false;\n\t\thManager = NULL;\n\t\thService = NULL;\n\t\twhile(1)\t\t\t//無限ループではない！\n\t\t{\n\t\t\thManager = ::OpenSCManager(NULL,NULL,GENERIC_EXECUTE);\n\t\t\tATLASSERT(hManager);\n\t\t\tif(hManager == NULL)\n\t\t\t\tbreak;\n\n\t\t\thService = ::OpenService(hManager,pszName,SERVICE_QUERY_STATUS);\n\t\t\tATLASSERT(hService);\n\t\t\tif(hService == NULL)\n\t\t\t\tbreak;\n\n\t\t\t::ZeroMemory(&sStatus,sizeof(SERVICE_STATUS));\n\t\t\tbRet = ::QueryServiceStatus(hService,&sStatus);\n\t\t\tATLASSERT(bRet);\n\t\t\tif(bRet == FALSE)\n\t\t\t\tbreak;\n\n\t\t\tif(sStatus.dwCurrentState == SERVICE_RUNNING)\n\t\t\t\tret = true;\n\n\t\t\tbreak;\t\t//必須\n\t\t}\n\n\t\tif(hService)\n\t\t\t::CloseServiceHandle(hService);\n\t\tif(hManager)\n\t\t\t::CloseServiceHandle(hManager);\n\n\t\treturn\tret;\n\t}\n};\n"
        },
        {
          "name": "EnumVolumeDrive.cpp",
          "type": "blob",
          "size": 5.43359375,
          "content": "﻿\n#include \"stdafx.h\"\n#include <windows.h>\n#include <tchar.h>\n#include <assert.h>\n#include <atlbase.h>\n#include <atlstr.h>\n#include <atlcoll.h>\n#include <cfgmgr32.h>\n#include <setupapi.h>\n#pragma comment(lib, \"setupapi.lib\")\n\n\n/////////////////////////////////////////////////////////////////////////////\n\nstruct DiskDriveInfo\n{\n    CString\t\tDriveLetter;\t// ドライブレター\n\tCString\t\tDevicePath;\t\t// デバイスパス\n\tCString\t\tVolumeName;\t\t// ボリューム名\n\tCString\t\tParentDevId;\t// 親階層デバイスのデバイスID\n};\n\n\n/////////////////////////////////////////////////////////////////////////////\n\n// ディスクドライブ情報\nCAtlArray< DiskDriveInfo >\tgDriveInfos;\n\n\n/////////////////////////////////////////////////////////////////////////////\n\nBOOL GetVolumeNameFromDriveLetter()\n{\n\tTCHAR szDriveLetter[] = _T(\"A:\\\\\");\n\tTCHAR szVolumeName[MAX_PATH];\n\tBOOL bRet;\n\n\tfor ( int i = 0; i < 25; i++ )\n\t{\n\t\tszDriveLetter[0] = _T('A') + i;\n\n\t\t// ドライブレターからボリューム名を取得\n\t\tbRet = GetVolumeNameForVolumeMountPoint(\n\t\t\t\t\t\tszDriveLetter,\n\t\t\t\t\t\tszVolumeName,\n\t\t\t\t\t\tsizeof( szVolumeName ) / sizeof( TCHAR ) );\n\n\t\t// 取得成功\n\t\tif ( bRet )\n\t\t{\n\t\t\tDiskDriveInfo info;\n\n\t\t\tinfo.DriveLetter = szDriveLetter;\n\t\t\tinfo.VolumeName  = szVolumeName;\n\n\t\t\tgDriveInfos.Add( info );\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n\nBOOL GetVolumeNameFromDiskDevicePath()\n{\n\tIID\t\t\t\t\t\t\t\t\tiidVolumeClass;\n\tHDEVINFO\t\t\t\t\t\t\thDevInfo;\n\tSP_DEVICE_INTERFACE_DATA\t\t\tsDevIfData;\n\tSP_DEVINFO_DATA\t\t\t\t\t\tsDevInfoData;\n\tPSP_DEVICE_INTERFACE_DETAIL_DATA\tpDevIfDetail;\n\tULONG\t\t\t\t\t\t\t\tulLength;\n\tTCHAR\t\t\t\t\t\t\t\tszDevicePath[MAX_PATH];\n\tTCHAR\t\t\t\t\t\t\t\tszVolumeName[MAX_PATH];\n\tBOOL\t\t\t\t\t\t\t\tbRet;\n\n\t// Volume Device Class\n\tIIDFromString( L\"{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}\", &iidVolumeClass);\n\n\thDevInfo = SetupDiGetClassDevs(\n\t\t\t\t\t\t&iidVolumeClass,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tDIGCF_PRESENT | DIGCF_DEVICEINTERFACE );\n\n\tif ( hDevInfo == INVALID_HANDLE_VALUE )\n\t{\n\t\treturn FALSE;\n\t}\n\n\tsDevIfData.cbSize = sizeof( SP_DEVICE_INTERFACE_DATA );\n\n\t// ディスクデバイスを列挙し、デバイスパスからボリューム名を取得する。\n\tfor (ULONG nIndex = 0; ; nIndex++)\n\t{\n\t\tbRet = SetupDiEnumDeviceInterfaces(\n\t\t\t\t\t\t\thDevInfo,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t&iidVolumeClass,\n\t\t\t\t\t\t\tnIndex,\n\t\t\t\t\t\t\t&sDevIfData );\n\n\t\tif ( !bRet )\n\t\t{\n\t\t\tbreak;\t// 列挙終了\n\t\t}\n\n\t\tZeroMemory( &sDevInfoData, sizeof( SP_DEVINFO_DATA ) );\n\n\t\tsDevInfoData.cbSize = sizeof( SP_DEVINFO_DATA );\n\n\t\t// デバイス詳細情報の長さを取得\n\t\tSetupDiGetDeviceInterfaceDetail(\n\t\t\t\t\t\t\thDevInfo,\n\t\t\t\t\t\t\t&sDevIfData,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t&ulLength,\n\t\t\t\t\t\t\t&sDevInfoData );\n\n\t\t// デバイス詳細情報用メモリ確保\n\t\tpDevIfDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA) malloc( ulLength );\n\n\t\tassert( pDevIfDetail != NULL );\n\n\t\tpDevIfDetail->cbSize = sizeof( SP_DEVICE_INTERFACE_DETAIL_DATA );\n\n\t\t// デバイス詳細情報取得\n\t\tbRet = SetupDiGetDeviceInterfaceDetail(\n\t\t\t\t\t\t\thDevInfo,\n\t\t\t\t\t\t\t&sDevIfData,\n\t\t\t\t\t\t\tpDevIfDetail,\n\t\t\t\t\t\t\tulLength,\n\t\t\t\t\t\t\t&ulLength,\n\t\t\t\t\t\t\t&sDevInfoData );\n\n\t\t// デバイス詳細情報取得成功\n\t\tif ( bRet )\n\t\t{\n\t\t\t// デバイスパス（末尾に'\\'を付ける）\n\t\t\t_tcscpy( szDevicePath, pDevIfDetail->DevicePath );\n\t\t\t_tcscat( szDevicePath, _T(\"\\\\\") );\n\n\t\t\t// デバイスパスからボリューム名を取得\n\t\t\tbRet = GetVolumeNameForVolumeMountPoint(\n\t\t\t\t\t\t\t\tszDevicePath,\n\t\t\t\t\t\t\t\tszVolumeName,\n\t\t\t\t\t\t\t\tsizeof( szVolumeName ) / sizeof( TCHAR ) );\n\n\t\t\t// ボリューム名取得成功\n\t\t\tif ( bRet )\n\t\t\t{\n\t\t\t\t// ★ドライブレターから取得したボリューム名と比較し\n\t\t\t\t//   ドライブレターと関連付ける。\n\t\t\t\tfor ( size_t i = 0; i < gDriveInfos.GetCount(); i++ )\n\t\t\t\t{\n\t\t\t\t\tDiskDriveInfo& rInfo = gDriveInfos[i];\n\n\t\t\t\t\t// ボリューム名が一致\n\t\t\t\t\tif ( rInfo.VolumeName.CompareNoCase( szVolumeName ) == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\trInfo.DevicePath = szDevicePath;\n\n\t\t\t\t\t\t// ★ボリュームデバイスの親階層(ディスクデバイス?)の\n\t\t\t\t\t\t// 　デバイスIDを取得する。\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDEVINST hDevInst = sDevInfoData.DevInst;\n\t\t\t\t\t\t\tDEVINST hParentDev;\n\t\t\t\t\t\t\tULONG ulParentDevIdLen;\n\t\t\t\t\t\t\tLPTSTR pParentDevId;\n\t\t\t\t\t\t\tCONFIGRET cRet;\n\n\t\t\t\t\t\t\tcRet = CM_Get_Parent( &hParentDev, hDevInst, 0 );\n\n\t\t\t\t\t\t\tif ( cRet == CR_SUCCESS )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCM_Get_Device_ID_Size( &ulParentDevIdLen, hParentDev, 0 );\n\t\t\t\t\t\t\t\t++ulParentDevIdLen; // ヌル文字分\n\n\t\t\t\t\t\t\t\tpParentDevId = (LPTSTR)malloc( ulParentDevIdLen * sizeof( TCHAR ) );\n\n\t\t\t\t\t\t\t\tassert( pParentDevId != NULL );\n\n\t\t\t\t\t\t\t\tZeroMemory( pParentDevId, ulParentDevIdLen * sizeof( TCHAR ) );\n\n\t\t\t\t\t\t\t\tcRet = CM_Get_Device_ID( hParentDev, pParentDevId, ulParentDevIdLen, 0 );\n\n\t\t\t\t\t\t\t\tif ( cRet == CR_SUCCESS )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\trInfo.ParentDevId = pParentDevId;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfree( pParentDevId );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree( pDevIfDetail );\n\t}\n\n\tSetupDiDestroyDeviceInfoList( hDevInfo );\n\n\treturn TRUE;\n}\n\nvoid ShowData()\n{\n\tCString cstr, clip;\n\n\tfor ( size_t i = 0; i < gDriveInfos.GetCount(); i++ )\n\t{\n\t\tDiskDriveInfo& rInfo = gDriveInfos[i];\n\n\t\tcstr.Format(_T(\"Drive Letter : %s\\nDevice Path  : %s\\nVolume Name  : %s\\nParent DevId : %s\\n\\n\"), (LPCTSTR)rInfo.DriveLetter, (LPCTSTR)rInfo.DevicePath, (LPCTSTR)rInfo.VolumeName, (LPCTSTR)rInfo.ParentDevId);\n\t\tclip += cstr;\n\t}\n\tCStdioFile file;\n\tfile.Open(_T(\"test.txt\"), CFile::modeCreate | CFile::modeWrite | CFile::typeText );\n\tfile.WriteString(clip);\n\tfile.Close();\n}\n"
        },
        {
          "name": "EnumVolumeDrive.h",
          "type": "blob",
          "size": 0.09375,
          "content": "﻿BOOL GetVolumeNameFromDriveLetter();\nBOOL GetVolumeNameFromDiskDevicePath();\nVOID ShowData();"
        },
        {
          "name": "EventLog.cpp",
          "type": "blob",
          "size": 2.462890625,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"EventLog.h\"\n\n#define REGISTRY_KEY _T(\"SYSTEM\\\\CurrentControlSet\\\\Services\\\\EventLog\\\\Application\\\\CrystalDiskInfo\")\n\nBOOL InstallEventSource()\n{\n    HKEY hk = NULL;\n\tDWORD level{};\n    DWORD length = MAX_PATH;\n\tTCHAR fileName[MAX_PATH]{};\n\n    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_KEY, 0, KEY_ALL_ACCESS, &hk) != ERROR_SUCCESS)\n\t{\n\t\tif(RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_KEY, 0, NULL, REG_OPTION_NON_VOLATILE,\n\t\t\t\t\t\tKEY_ALL_ACCESS, NULL, &hk, NULL) != ERROR_SUCCESS)\n\t\t{\n\t\t\treturn FALSE;\n        }\n    }\n\n    if(RegQueryValueEx(hk, _T(\"EventMessageFile\"), NULL, NULL, \n\t\t\t\t\t\t(LPBYTE)fileName, &length) != ERROR_SUCCESS)\n\t{\n\t\t::GetModuleFileName(NULL, fileName, MAX_PATH);\n        if(RegSetValueEx(hk, _T(\"EventMessageFile\"), 0,REG_EXPAND_SZ, \n\t\t\t(LPBYTE)fileName, (DWORD)(_tcslen(fileName) + 1) * 2) != ERROR_SUCCESS)\n\t\t{\n\t\t\tRegCloseKey(hk);\n\t\t\treturn FALSE;\n        }\n    }\n\n    if(RegQueryValueEx(hk, _T(\"TypesSupported\"), NULL, NULL, (LPBYTE)&level,\n                        (LPDWORD)&length) != ERROR_SUCCESS)\n\t{\n        level = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;\n\t\tlength = sizeof(DWORD);\n        if(RegSetValueEx(hk, _T(\"TypesSupported\"), 0, REG_DWORD, (LPBYTE)&level, length) != ERROR_SUCCESS)\n\t\t{\n\t\t\tRegCloseKey(hk);\n\t\t\treturn FALSE;\n        }\n    }\n\n    if(RegCloseKey(hk) == ERROR_SUCCESS)\n\t{\n\t\treturn TRUE;\n    }\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n}\n\nBOOL WriteEventLog(DWORD eventId, WORD eventType, const TCHAR*/*PTCHAR*/ source, CString message)\n{\n\tHANDLE hEventLog = NULL;\n\tDWORD flag = 0;\n\tBOOL result = FALSE;\n\n\thEventLog = RegisterEventSource(NULL, source);\n\tif(hEventLog == NULL)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tLPCTSTR str[1]{};\n\tstr[0] = message.GetString();\n\n\tif(600 <= eventId && eventId < 700)\n\t{\n\t\tflag = 0x80000000; // Warning\n\t}\n\telse\n\t{\n\t\tflag = 0x40000000; // Informational\n\t}\n\n\tresult = ReportEventW(hEventLog, eventType, 0, eventId + flag, NULL,\n\t\t\t\t\t\t1, 0, (LPCWSTR *)str, NULL);\n\n\tif(! result)\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn DeregisterEventSource(hEventLog);\n}\n\nBOOL UninstallEventSource()\n{\n\tif(SHDeleteKey(HKEY_LOCAL_MACHINE, REGISTRY_KEY) == ERROR_SUCCESS)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n}\n"
        },
        {
          "name": "EventLog.h",
          "type": "blob",
          "size": 0.466796875,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n\nBOOL InstallEventSource();\nBOOL WriteEventLog(DWORD eventId, WORD eventType, const TCHAR*/* PTCHAR*/ source, CString message);\nBOOL UninstallEventSource();"
        },
        {
          "name": "EventMessage.h",
          "type": "blob",
          "size": 2.2001953125,
          "content": "//\n//  Values are 32 bit values laid out as follows:\n//\n//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1\n//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\n//  +---+-+-+-----------------------+-------------------------------+\n//  |Sev|C|R|     Facility          |               Code            |\n//  +---+-+-+-----------------------+-------------------------------+\n//\n//  where\n//\n//      Sev - is the severity code\n//\n//          00 - Success\n//          01 - Informational\n//          10 - Warning\n//          11 - Error\n//\n//      C - is the Customer code flag\n//\n//      R - is a reserved bit\n//\n//      Facility - is the facility code\n//\n//      Code - is the facility's status code\n//\n//\n// Define the facility codes\n//\n\n\n//\n// Define the severity codes\n//\n\n\n//\n// MessageId: MSG_601\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_601                          0x80000259L\n\n//\n// MessageId: MSG_602\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_602                          0x8000025AL\n\n//\n// MessageId: MSG_603\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_603                          0x8000025BL\n\n//\n// MessageId: MSG_604\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_604                          0x8000025CL\n\n//\n// MessageId: MSG_605\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_605                          0x8000025DL\n\n//\n// MessageId: MSG_606\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_606                          0x8000025EL\n\n//\n// MessageId: MSG_607\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_607                          0x8000025FL\n\n//\n// MessageId: MSG_701\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_701                          0x400002BDL\n\n//\n// MessageId: MSG_702\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_702                          0x400002BEL\n\n//\n// MessageId: MSG_703\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_703                          0x400002BFL\n\n//\n// MessageId: MSG_704\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_704                          0x400002C0L\n\n//\n// MessageId: MSG_705\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_705                          0x400002C1L\n\n//\n// MessageId: MSG_707\n//\n// MessageText:\n//\n// %1!s!\n//\n#define MSG_707                          0x400002C3L\n\n"
        },
        {
          "name": "EventMessage.mc",
          "type": "blob",
          "size": 1.4599609375,
          "content": "LanguageNames = (English=0x409:MSG00409)\n\nMessageId = 601\nSeverity = Warning\nFacility = Application\nSymbolicName = MSG_601\nLanguage = English\n%1!s!\n.\n\nMessageId = 602\nSeverity = Warning\nFacility = Application\nSymbolicName = MSG_602\nLanguage = English\n%1!s!\n.\n\nMessageId = 603\nSeverity = Warning\nFacility = Application\nSymbolicName = MSG_603\nLanguage = English\n%1!s!\n.\n\nMessageId = 604\nSeverity = Warning\nFacility = Application\nSymbolicName = MSG_604\nLanguage = English\n%1!s!\n.\n\nMessageId = 605\nSeverity = Warning\nFacility = Application\nSymbolicName = MSG_605\nLanguage = English\n%1!s!\n.\n\nMessageId = 606\nSeverity = Warning\nFacility = Application\nSymbolicName = MSG_606\nLanguage = English\n%1!s!\n.\n\nMessageId = 607\nSeverity = Warning\nFacility = Application\nSymbolicName = MSG_607\nLanguage = English\n%1!s!\n.\n\nMessageId = 701\nSeverity = Informational\nFacility = Application\nSymbolicName = MSG_701\nLanguage = English\n%1!s!\n.\n\nMessageId = 702\nSeverity = Informational\nFacility = Application\nSymbolicName = MSG_702\nLanguage = English\n%1!s!\n.\n\nMessageId = 703\nSeverity = Informational\nFacility = Application\nSymbolicName = MSG_703\nLanguage = English\n%1!s!\n.\n\nMessageId = 704\nSeverity = Informational\nFacility = Application\nSymbolicName = MSG_704\nLanguage = English\n%1!s!\n.\n\nMessageId = 705\nSeverity = Informational\nFacility = Application\nSymbolicName = MSG_705\nLanguage = English\n%1!s!\n.\n\nMessageId = 707\nSeverity = Informational\nFacility = Application\nSymbolicName = MSG_707\nLanguage = English\n%1!s!\n.\n\n"
        },
        {
          "name": "EventMessage.rc",
          "type": "blob",
          "size": 0.0361328125,
          "content": "LANGUAGE 0x9,0x1\n1 11 \"MSG00409.bin\"\n"
        },
        {
          "name": "FontSelectionDlg.cpp",
          "type": "blob",
          "size": 8.1552734375,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n#include \"FontSelectionDlg.h\"\n\nint CALLBACK EnumFontFamExProc(ENUMLOGFONTEX *lpelfe, NEWTEXTMETRICEX *lpntme, int FontType, LPARAM lParam);\n\nIMPLEMENT_DYNAMIC(CFontSelectionDlg, CDialog)\n\nCFontSelectionDlg::CFontSelectionDlg(CWnd* pParent)\n\t: CDialogFx(CFontSelectionDlg::IDD, pParent)\n{\n\tCMainDialogFx* p = (CMainDialogFx*)pParent;\n\n\tm_ZoomType = p->GetZoomType();\n\tm_FontScale = p->GetFontScale();\n\tm_FontRatio = 1.0; // p->GetFontRatio();\n\tm_FontFace = p->GetFontFace();\n\tm_FontRender = p->GetFontRender();\n\tm_CurrentLangPath = p->GetCurrentLangPath();\n\tm_DefaultLangPath = p->GetDefaultLangPath();\n\tm_ThemeDir = p->GetThemeDir();\n\tm_CurrentTheme = p->GetCurrentTheme();\n\tm_DefaultTheme = p->GetDefaultTheme();\n\tm_Ini = p->GetIniPath();\n\n\tm_BackgroundName = L\"\";\n}\n\nCFontSelectionDlg::~CFontSelectionDlg()\n{\n}\n\nvoid CFontSelectionDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\tDDX_Control(pDX, IDC_OK, m_CtrlOk);\n\tDDX_Control(pDX, IDC_FONT_FACE,  m_LabelFontFace);\n\tDDX_Control(pDX, IDC_FONT_SCALE, m_LabelFontScale);\n\tDDX_Control(pDX, IDC_FONT_RENDER, m_LabelFontRender);\n\tDDX_Control(pDX, IDC_FONT_FACE_COMBO, m_CtrlFontFace);\n\tDDX_Control(pDX, IDC_FONT_SCALE_COMBO, m_CtrlFontScale);\n\tDDX_Control(pDX, IDC_FONT_RENDER_COMBO, m_CtrlFontRender);\n\tDDX_Control(pDX, IDC_SET_DEFAULT, m_CtrlDefault);\n}\n\nBEGIN_MESSAGE_MAP(CFontSelectionDlg, CDialogFx)\n\tON_BN_CLICKED(IDC_OK, &CFontSelectionDlg::OnOk)\n\tON_BN_CLICKED(IDC_SET_DEFAULT, &CFontSelectionDlg::OnSetDefault)\nEND_MESSAGE_MAP()\n\nBOOL CFontSelectionDlg::OnInitDialog()\n{\n\tCDialogFx::OnInitDialog();\n\n\tSetWindowTitle(i18n(L\"WindowTitle\", L\"FONT_SETTING\"));\n\n\tSetDefaultFont(m_FontFace);\n\n\tCString cstr;\n\tfor (int i = 50; i <= 150; i += 10)\n\t{\n\t\tcstr.Format(L\"%d\", i);\n\t\tm_CtrlFontScale.AddString(cstr);\n\t\tif (m_FontScale == i) { m_CtrlFontScale.SetCurSel(m_CtrlFontScale.GetCount() - 1);  }\n\t}\n\n\tm_CtrlFontRender.AddString(i18n(L\"Dialog\", L\"ENABLED\"));\n\tm_CtrlFontRender.AddString(i18n(L\"Dialog\", L\"DISABLED\"));\n\n\tif (m_FontRender == CLEARTYPE_NATURAL_QUALITY)\n\t{\n\t\tm_CtrlFontRender.SetCurSel(0);\n\t}\n\telse\n\t{\n\t\tm_CtrlFontRender.SetCurSel(1);\n\t}\n\n\tm_LabelFontFace.SetWindowTextW(i18n(L\"Dialog\", L\"FONT_FACE\"));\n\tm_LabelFontScale.SetWindowTextW(i18n(L\"Dialog\", L\"FONT_SCALE\"));\n\tm_LabelFontRender.SetWindowTextW(L\"ClearType\");\n\tm_CtrlDefault.SetWindowTextW(i18n(L\"Dialog\", L\"DEFAULT\"));\n\tm_CtrlOk.SetWindowTextW(i18n(L\"Dialog\", L\"OK\"));\n\n\tUpdateDialogSize();\n\n\treturn TRUE;\n}\n\nvoid CFontSelectionDlg::UpdateDialogSize()\n{\n\tCDialogFx::UpdateDialogSize();\n\n\tCOLORREF textColor = RGB(0, 0, 0);\n\tCOLORREF textSelectedColor = RGB(0, 0, 0);\n\n\tChangeZoomType(m_ZoomType);\n\tSetClientSize(SIZE_X, SIZE_Y, m_ZoomRatio);\n\n\tUpdateBackground(FALSE, m_bDarkMode);\n\n\tm_LabelFontFace.SetFontEx(m_FontFace, 16, 16, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_LabelFontScale.SetFontEx(m_FontFace, 16, 16, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_LabelFontRender.SetFontEx(m_FontFace, 16, 16, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\n\tm_LabelFontFace.InitControl(8, 8, 432, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_LabelFontScale.InitControl(8, 80, 208, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_LabelFontRender.InitControl(240, 80, 208, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlFontFace.InitControl(20, 32, 440, 360, m_ZoomRatio, &m_BkDC, NULL, 0, ES_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, RGB(255, 255, 255), RGB(160, 220, 255), RGB(255, 255, 255), 0);\n\tm_CtrlFontScale.InitControl(20, 104, 208, 360, m_ZoomRatio, &m_BkDC, NULL, 0, ES_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, RGB(255, 255, 255), RGB(160, 220, 255), RGB(255, 255, 255), 0);\n\tm_CtrlFontRender.InitControl(252, 104, 208, 360, m_ZoomRatio, &m_BkDC, NULL, 0, ES_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, RGB(255, 255, 255), RGB(160, 220, 255), RGB(255, 255, 255), 0);\n\n\tm_CtrlDefault.InitControl(40, 156, 168, 32, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlOk.InitControl(272, 156, 168, 32, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, FALSE);\n\n\tm_CtrlFontFace.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\tm_CtrlFontScale.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\tm_CtrlFontRender.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\n\tm_CtrlFontFace.SetFontHeight(20, m_ZoomRatio, m_FontRatio);\n\tm_CtrlFontFace.SetFontEx(m_FontFace, 20, 20, m_ZoomRatio, m_FontRatio, textColor, textSelectedColor, FW_NORMAL, m_FontRender);\n\tm_CtrlFontFace.SetItemHeightEx(-1, 36, m_ZoomRatio, m_FontRatio);\n\tfor (int i = 0; i < m_CtrlFontFace.GetCount(); i++)\n\t{\n\t\tm_CtrlFontFace.SetItemHeightEx(i, 32, m_ZoomRatio, m_FontRatio);\n\t}\n\n\tm_CtrlFontScale.SetFontHeight(20, m_ZoomRatio, m_FontRatio);\n\tm_CtrlFontScale.SetFontEx(m_FontFace, 20, 20, m_ZoomRatio, m_FontRatio, textColor, textSelectedColor, FW_NORMAL, m_FontRender);\n\tm_CtrlFontScale.SetItemHeightEx(-1, 36, m_ZoomRatio, m_FontRatio);\n\tfor (int i = 0; i < m_CtrlFontScale.GetCount(); i++)\n\t{\n\t\tm_CtrlFontScale.SetItemHeightEx(i, 32, m_ZoomRatio, m_FontRatio);\n\t}\n\n\tm_CtrlFontRender.SetFontHeight(20, m_ZoomRatio, m_FontRatio);\n\tm_CtrlFontRender.SetFontEx(m_FontFace, 20, 20, m_ZoomRatio, m_FontRatio, textColor, textSelectedColor, FW_NORMAL, m_FontRender);\n\tm_CtrlFontRender.SetItemHeightEx(-1, 36, m_ZoomRatio, m_FontRatio);\n\tfor (int i = 0; i < m_CtrlFontRender.GetCount(); i++)\n\t{\n\t\tm_CtrlFontRender.SetItemHeightEx(i, 32, m_ZoomRatio, m_FontRatio);\n\t}\n\n\tm_CtrlDefault.SetFontEx(m_FontFace, 16, 16, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlOk.SetFontEx(m_FontFace, 16, 16, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\t\n\tm_CtrlDefault.SetHandCursor();\n\tm_CtrlOk.SetHandCursor();\n\n\tSetDarkModeControl(m_CtrlDefault.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_CtrlOk.GetSafeHwnd(), m_bDarkMode);\n\n\tInvalidate();\n}\n\nvoid CFontSelectionDlg::OnOk()\n{\n\tCString cstr;\n\n\tm_CtrlFontFace.GetLBText(m_CtrlFontFace.GetCurSel(), m_FontFace);\n\tm_CtrlFontScale.GetLBText(m_CtrlFontScale.GetCurSel(), cstr);\n\tm_FontScale = _wtoi(cstr);\n\tif (m_CtrlFontRender.GetCurSel() == 0)\n\t{\n\t\tm_FontRender = CLEARTYPE_NATURAL_QUALITY;\n\t}\n\telse\n\t{\n\t\tm_FontRender = ANTIALIASED_QUALITY;\n\t}\n\n\tCDialog::OnOK();\n}\n\nint CALLBACK EnumFontFamExProc(ENUMLOGFONTEX *lpelfe, NEWTEXTMETRICEX *lpntme, int FontType, LPARAM lParam)\n{\n\tCFontComboBox* pFontComboBox = (CFontComboBox*)lParam;\n\tif(pFontComboBox->FindStringExact(0, (TCHAR*)lpelfe->elfLogFont.lfFaceName) == CB_ERR\n\t&& _tcschr((TCHAR*)lpelfe->elfLogFont.lfFaceName, L'@') == NULL\n\t&& lpelfe->elfLogFont.lfCharSet != SYMBOL_CHARSET\n\t)\n\t{\n\t\tpFontComboBox->AddString((TCHAR*)lpelfe->elfLogFont.lfFaceName);\n\t}\n    return TRUE;\n}\n\nvoid CFontSelectionDlg::OnSetDefault()\n{\n\tSetDefaultFont(L\"\");\n\tm_CtrlFontScale.SetCurSel(5);\n\tm_CtrlFontRender.SetCurSel(0);\n}\n\nvoid CFontSelectionDlg::SetDefaultFont(CString fontFace)\n{\n\tm_CtrlFontFace.ResetContent();\n\n\tCClientDC dc(this);\n\tLOGFONT logfont;\n\tZeroMemory(&logfont, sizeof(LOGFONT));\n\tlogfont.lfCharSet = DEFAULT_CHARSET;\n\n\t::EnumFontFamiliesExW(dc.m_hDC, &logfont, (FONTENUMPROC)EnumFontFamExProc, (LPARAM)&m_CtrlFontFace, 0);\n\n\tint no = m_CtrlFontFace.FindStringExact(0, fontFace);\n\tif (no >= 0)\n\t{\n\t\tm_CtrlFontFace.SetCurSel(no);\n\t}\n\telse\n\t{\n\t\tno = m_CtrlFontFace.FindStringExact(0, DEFAULT_FONT_FACE_1);\n\t\tif (no >= 0)\n\t\t{\n\t\t\tm_CtrlFontFace.SetCurSel(no);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tno = m_CtrlFontFace.FindStringExact(0, DEFAULT_FONT_FACE_2);\n\t\t\tif (no >= 0)\n\t\t\t{\n\t\t\t\tm_CtrlFontFace.SetCurSel(no);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_CtrlFontFace.SetCurSel(0);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m_CtrlFontFace.GetCount(); i++)\n\t{\n\t\tm_CtrlFontFace.SetItemHeightEx(i, 32, m_ZoomRatio, m_FontRatio);\n\t}\n}"
        },
        {
          "name": "FontSelectionDlg.h",
          "type": "blob",
          "size": 1.1240234375,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n\n#include \"afxwin.h\"\n#include \"ButtonFx.h\"\n#include \"ComboBoxFx.h\"\n#include \"FontComboBoxFx.h\"\n\nclass CFontSelectionDlg : public CDialogFx\n{\n\tDECLARE_DYNAMIC(CFontSelectionDlg)\n\n\tstatic const int SIZE_X = 480;\n\tstatic const int SIZE_Y = 204;\n\tenum { IDD = IDD_FONT };\n\npublic:\n\tCFontSelectionDlg(CWnd* pParent = NULL);\n\tvirtual ~CFontSelectionDlg();\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\n\tvirtual BOOL OnInitDialog();\n\tvirtual void UpdateDialogSize();\n\n\tvoid SetDefaultFont(CString fontFace);\n\n\tDECLARE_MESSAGE_MAP()\n\tafx_msg void OnSetDefault();\n\tafx_msg void OnOk();\n\n\tCStaticFx m_LabelFontFace;\n\tCStaticFx m_LabelFontScale;\n\tCStaticFx m_LabelFontRender;\n\tCButtonFx m_CtrlOk;\n\tCButtonFx m_CtrlDefault;\n\n\tCFontComboBox m_CtrlFontFace;\n\tCComboBoxFx   m_CtrlFontScale;\n\tCComboBoxFx   m_CtrlFontRender;\n\n};\n"
        },
        {
          "name": "GraphDlg.cpp",
          "type": "blob",
          "size": 67.6728515625,
          "content": "/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"AtaSmart.h\"\n#include \"DiskInfo.h\"\n#include \"GraphDlg.h\"\n#include \"DiskInfoDlg.h\"\n\n#include \"OsInfoFx.h\"\n#include \"AtaSmart.h\"\n\n#define SMART_TEMPERATURE                  300\n#define SMART_POWER_ON_HOURS               301\n#define SMART_POWER_ON_COUNT               302\n#define SMART_REALLOCATED_SECTORS_COUNT    303\n#define SMART_REALLOCATED_EVENT_COUNT      304\n#define SMART_CURRENT_PENDING_SECTOR_COUNT 305\n#define SMART_UNCORRECTABLE_SECTOR_COUNT   306\n#define SMART_HOST_WRITES                  307\n#define SMART_HOST_READS                   308\n#define SMART_NAND_WRITES                  309\n#define SMART_NAND_ERASED                  310\n#define SMART_WEAR_LEVELING_COUNT          311\n#define SMART_LIFE                         312\n\nIMPLEMENT_DYNCREATE(CGraphDlg, CDHtmlDialog)\n\nCGraphDlg::CGraphDlg(CWnd* pParent /*=NULL*/, int defaultDisk)\n\t: CDHtmlMainDialog(CGraphDlg::IDD, CGraphDlg::IDH,\n\t((CDiskInfoApp*)AfxGetApp())->m_ThemeDir,\n\t((CDiskInfoApp*)AfxGetApp())->m_ThemeIndex,\n\t((CDiskInfoApp*)AfxGetApp())->m_LangDir,\n\t((CDiskInfoApp*)AfxGetApp())->m_LangIndex,\n\tpParent)\n{\n\tCString cstr;\n\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n\tm_hIconMini = AfxGetApp()->LoadIcon(IDI_MINI_ICON);\n\tm_SmartDir = ((CDiskInfoApp*)AfxGetApp())->m_SmartDir;\n\t_tcscpy_s(m_Ini, MAX_PATH, ((CDiskInfoApp*)AfxGetApp())->m_Ini.GetString());\n\tm_bSmartEnglish = (BOOL)GetPrivateProfileInt(_T(\"Setting\"), _T(\"SmartEnglish\"), 0, m_Ini);\n\n\tInitVars(defaultDisk);\n\n\tm_ZoomType = GetZoomType();\n}\n\nCGraphDlg::~CGraphDlg()\n{\n\tCString index, value;\n\tfor(int i = 0; i < m_DetectedDisk; i++)\n\t{\n\t\tindex.Format(_T(\"Disk%d\"), i);\n\t\tvalue.Format(_T(\"%d\"), ( ! m_bGraph[i] ? 1 : 0 ) );\n\t\tWritePrivateProfileStringFx(_T(\"GraphHideDisk\"), index, value, m_Ini);\n\t}\n}\n\nvoid CGraphDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDHtmlMainDialog::DoDataExchange(pDX);\n\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Title\"),  m_Title);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk0\"),  m_LiDisk[0]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk1\"),  m_LiDisk[1]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk2\"),  m_LiDisk[2]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk3\"),  m_LiDisk[3]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk4\"),  m_LiDisk[4]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk5\"),  m_LiDisk[5]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk6\"),  m_LiDisk[6]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk7\"),  m_LiDisk[7]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk8\"),  m_LiDisk[8]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk9\"),  m_LiDisk[9]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk10\"), m_LiDisk[10]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk11\"), m_LiDisk[11]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk12\"), m_LiDisk[12]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk13\"), m_LiDisk[13]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk14\"), m_LiDisk[14]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk15\"), m_LiDisk[15]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk16\"), m_LiDisk[16]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk17\"), m_LiDisk[17]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk18\"), m_LiDisk[18]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk19\"), m_LiDisk[19]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk20\"), m_LiDisk[20]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk21\"), m_LiDisk[21]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk22\"), m_LiDisk[22]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk23\"), m_LiDisk[23]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk24\"), m_LiDisk[24]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk25\"), m_LiDisk[25]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk26\"), m_LiDisk[26]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk27\"), m_LiDisk[27]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk28\"), m_LiDisk[28]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk29\"), m_LiDisk[29]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk30\"), m_LiDisk[30]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk31\"), m_LiDisk[31]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk32\"), m_LiDisk[32]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk33\"), m_LiDisk[33]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk34\"), m_LiDisk[34]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk35\"), m_LiDisk[35]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk36\"), m_LiDisk[36]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk37\"), m_LiDisk[37]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk38\"), m_LiDisk[38]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk39\"), m_LiDisk[39]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk40\"), m_LiDisk[40]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk41\"), m_LiDisk[41]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk42\"), m_LiDisk[42]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk43\"), m_LiDisk[43]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk44\"), m_LiDisk[44]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk45\"), m_LiDisk[45]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk46\"), m_LiDisk[46]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk47\"), m_LiDisk[47]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk48\"), m_LiDisk[48]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk49\"), m_LiDisk[49]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk50\"), m_LiDisk[50]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk51\"), m_LiDisk[51]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk52\"), m_LiDisk[52]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk53\"), m_LiDisk[53]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk54\"), m_LiDisk[54]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk55\"), m_LiDisk[55]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk56\"), m_LiDisk[56]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk57\"), m_LiDisk[57]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk58\"), m_LiDisk[58]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk59\"), m_LiDisk[59]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk60\"), m_LiDisk[60]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk61\"), m_LiDisk[61]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk62\"), m_LiDisk[62]);\n\tDDX_DHtml_ElementInnerHtml(pDX, _T(\"Disk63\"), m_LiDisk[63]);\n\n\tDDX_DHtml_SelectValue(pDX, _T(\"SelectAttributeId\"), m_SelectAttributeId);\n\tDDX_DHtml_SelectIndex(pDX, _T(\"SelectAttributeId\"), m_SelectAttributeIdCtrl);\n}\n\nBOOL CGraphDlg::OnInitDialog()\n{\n\tCDHtmlMainDialog::OnInitDialog();\n\n\tSetIcon(m_hIcon, TRUE);\t\t\t// Set big icon\n\tSetIcon(m_hIconMini, FALSE);\t// Set small icon\n\n\tEnableDpiAware();\n\n\tInitThemeLang();\n\tInitMenu();\n\n\tSetWindowText(_T(\"CrystalDiskInfo - \") + i18n(_T(\"WindowTitle\"), _T(\"GRAPH\")) + _T(\" - Powered by Flot\"));\n\n\tm_IeVersion = GetIeVersion();\n\n\tInitDialogEx(m_SizeX, m_SizeY, ((CDiskInfoApp*)AfxGetApp())->m_GraphDlgPath);\n\n\treturn TRUE;\n}\n\nBEGIN_MESSAGE_MAP(CGraphDlg, CDHtmlMainDialog)\n\tON_WM_GETMINMAXINFO()\n\tON_WM_SIZE()\n\tON_COMMAND(ID_EXIT, &CGraphDlg::OnExit)\n\tON_COMMAND(ID_NORTH_WEST, &CGraphDlg::OnNorthWest)\n\tON_COMMAND(ID_NORTH_EAST, &CGraphDlg::OnNorthEast)\n\tON_COMMAND(ID_SOUTH_WEST, &CGraphDlg::OnSouthWest)\n\tON_COMMAND(ID_SOUTH_EAST, &CGraphDlg::OnSouthEast)\n\tON_COMMAND(ID_PAINT_WEEKEND, &CGraphDlg::OnPaintWeekend)\n\tON_COMMAND(ID_POINT_100, &CGraphDlg::OnPoint100)\n\tON_COMMAND(ID_POINT_200, &CGraphDlg::OnPoint200)\n\tON_COMMAND(ID_POINT_300, &CGraphDlg::OnPoint300)\n\tON_COMMAND(ID_POINT_400, &CGraphDlg::OnPoint400)\n\tON_COMMAND(ID_POINT_500, &CGraphDlg::OnPoint500)\n\tON_COMMAND(ID_POINT_600, &CGraphDlg::OnPoint600)\n\tON_COMMAND(ID_POINT_700, &CGraphDlg::OnPoint700)\n\tON_COMMAND(ID_POINT_800, &CGraphDlg::OnPoint800)\n\tON_COMMAND(ID_POINT_900, &CGraphDlg::OnPoint900)\n\tON_COMMAND(ID_POINT_1000, &CGraphDlg::OnPoint1000)\n\tON_COMMAND(ID_POINT_2000, &CGraphDlg::OnPoint2000)\n\tON_COMMAND(ID_POINT_3000, &CGraphDlg::OnPoint3000)\n\tON_COMMAND(ID_POINT_4000, &CGraphDlg::OnPoint4000)\n\tON_COMMAND(ID_POINT_5000, &CGraphDlg::OnPoint5000)\n\tON_COMMAND(ID_POINT_ALL, &CGraphDlg::OnPointAll)\n\tON_COMMAND(ID_CUSTOMIZE, &CGraphDlg::OnCustomize)\n\tON_MESSAGE(MY_UPDATE_BG_IMAGE, OnUpdateBkImage)\n\tON_MESSAGE(MY_UPDATE_LINE_COLOR, OnUpdateLineColor)\n\tON_COMMAND(ID_MDHM, &CGraphDlg::OnMdhm)\n\tON_COMMAND(ID_MD, &CGraphDlg::OnMd)\n\tON_COMMAND(ID_YMDHM, &CGraphDlg::OnYmdhm)\n\tON_COMMAND(ID_YMD, &CGraphDlg::OnYmd)\n\tON_COMMAND(ID_DMYHM, &CGraphDlg::OnDmyhm)\n\tON_COMMAND(ID_DMY, &CGraphDlg::OnDmy)\n\tON_COMMAND(ID_DMYHM2, &CGraphDlg::OnDmyhm2)\n\tON_COMMAND(ID_DMY2, &CGraphDlg::OnDmy2)\n\n\tON_COMMAND(ID_HDD, &CGraphDlg::OnHdd)\n\tON_COMMAND(ID_SSD, &CGraphDlg::OnSsd)\n\tON_COMMAND(ID_SSD_MTRON, &CGraphDlg::OnSsdMtron)\n\tON_COMMAND(ID_SSD_INDILINX, &CGraphDlg::OnSsdIndilinx)\n\n\tON_COMMAND(ID_SSD_JMICRON, &CGraphDlg::OnSsdJmicron)\n\tON_COMMAND(ID_SSD_JMICRON_60X, &CGraphDlg::OnSsdJmicron60x)\n\tON_COMMAND(ID_SSD_JMICRON_61X, &CGraphDlg::OnSsdJmicron61x)\n\tON_COMMAND(ID_SSD_JMICRON_66X, &CGraphDlg::OnSsdJmicron66x)\n\n\tON_COMMAND(ID_SSD_INTEL, &CGraphDlg::OnSsdIntel)\n\tON_COMMAND(ID_SSD_SAMSUNG, &CGraphDlg::OnSsdSamsung)\n\tON_COMMAND(ID_SSD_SANDFORCE, &CGraphDlg::OnSsdSandforce)\n\tON_COMMAND(ID_SSD_MICRON, &CGraphDlg::OnSsdMicron)\n\tON_COMMAND(ID_SSD_OCZ, &CGraphDlg::OnSsdOcz)\n\tON_COMMAND(ID_SSD_SEAGATE, &CGraphDlg::OnSsdSeagate)\n\n\tON_COMMAND(ID_SSD_SEAGATE_IRON_WOLF, &CGraphDlg::OnSsdSeagateIronWolf)\n\tON_COMMAND(ID_SSD_SEAGATE_BARRA_CUDA, &CGraphDlg::OnSsdSeagateBarraCuda)\n\n\tON_COMMAND(ID_SSD_WDC, &CGraphDlg::OnSsdWdc)\n\tON_COMMAND(ID_SSD_PLEXTOR, &CGraphDlg::OnSsdPlextor)\n\tON_COMMAND(ID_SSD_SANDISK, &CGraphDlg::OnSsdSanDisk)\n\n\tON_COMMAND(ID_SSD_SANDISK_GB, &CGraphDlg::OnSsdSanDiskGb)\n\n\tON_COMMAND(ID_SSD_OCZ_VECTOR, &CGraphDlg::OnSsdOczVector)\n\tON_COMMAND(ID_SSD_TOSHIBA, &CGraphDlg::OnSsdToshiba)\n\tON_COMMAND(ID_SSD_CORSAIR, &CGraphDlg::OnSsdCorsair)\n\tON_COMMAND(ID_SSD_KINGSTON, &CGraphDlg::OnSsdKingston)\n\n\tON_COMMAND(ID_SSD_KINGSTON_SUV, &CGraphDlg::OnSsdKingstonSuv)\n\tON_COMMAND(ID_SSD_KINGSTON_KC600, &CGraphDlg::OnSsdKingstonKC600)\n\tON_COMMAND(ID_SSD_KINGSTON_DC500, &CGraphDlg::OnSsdKingstonDC500)\n\tON_COMMAND(ID_SSD_KINGSTON_SA400, &CGraphDlg::OnSsdKingstonSA400)\n\n\tON_COMMAND(ID_SSD_MICRON_MU03, &CGraphDlg::OnSsdMicronMU03)\n\tON_COMMAND(ID_SSD_REALTEK, &CGraphDlg::OnSsdRealtek)\n\tON_COMMAND(ID_SSD_NVME, &CGraphDlg::OnSsdNVMe)\n\tON_COMMAND(ID_SSD_SKHYNIX, &CGraphDlg::OnSsdSkHynix)\n\tON_COMMAND(ID_SSD_KIOXIA, &CGraphDlg::OnSsdKioxia)\n\tON_COMMAND(ID_SSD_SSSTC, &CGraphDlg::OnSsdSsstc)\n\tON_COMMAND(ID_SSD_INTEL_DC, &CGraphDlg::OnSsdIntelDc)\n\tON_COMMAND(ID_SSD_APACER, &CGraphDlg::OnSsdApacer)\n\tON_COMMAND(ID_SSD_SILICONMOTION, &CGraphDlg::OnSsdSiliconMotion)\n\tON_COMMAND(ID_SSD_PHISON, &CGraphDlg::OnSsdPhison)\n\tON_COMMAND(ID_SSD_MARVELL, &CGraphDlg::OnSsdMarvell)\n\tON_COMMAND(ID_SSD_MAXIOTEK, &CGraphDlg::OnSsdMaxiotek)\n\tON_COMMAND(ID_SSD_YMTC, &CGraphDlg::OnSsdYmtc)\n\tON_COMMAND(ID_SSD_SCY, &CGraphDlg::OnSsdScy)\n\tON_COMMAND(ID_SSD_RECADATA, &CGraphDlg::OnSsdRecadata)\n\n\tON_COMMAND(ID_SSD_SANDISK_DELL, &CGraphDlg::OnSsdSanDiskDell)\n\tON_COMMAND(ID_SSD_SANDISK_HP, &CGraphDlg::OnSsdSanDiskHp)\n\tON_COMMAND(ID_SSD_SANDISK_HP_VENUS, &CGraphDlg::OnSsdSanDiskHpVenus)\n\tON_COMMAND(ID_SSD_SANDISK_LENOVO, &CGraphDlg::OnSsdSanDiskLenovo)\n\tON_COMMAND(ID_SSD_SANDISK_LENOVO_HELEN_VENUS, &CGraphDlg::OnSsdSanDiskLenovoHelenVenus)\n\n\tON_COMMAND(ID_SSD_SILICONMOTION_CVC, &CGraphDlg::OnSsdSiliconMotionCVC)\n\tON_COMMAND(ID_SSD_ADATA_INDUSTRIAL, &CGraphDlg::OnSsdAdataIndustrial)\n\n\nEND_MESSAGE_MAP()\n\nBEGIN_DHTML_EVENT_MAP(CGraphDlg)\n\tDHTML_EVENT_ONCLICK(_T(\"SelectAttributeId\"), OnSelectAttributeId)\n\tDHTML_EVENT_ONCLICK(_T(\"AllOn\"), OnAllOn)\n\tDHTML_EVENT_ONCLICK(_T(\"AllOff\"), OnAllOff)\n\tDHTML_EVENT_ONCLICK(_T(\"Reset\"), OnReset)\n\n\tDHTML_EVENT_ONCLICK(_T(\"Disk0\"),  OnDisk0)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk1\"),  OnDisk1)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk2\"),  OnDisk2)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk3\"),  OnDisk3)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk4\"),  OnDisk4)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk5\"),  OnDisk5)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk6\"),  OnDisk6)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk7\"),  OnDisk7)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk8\"),  OnDisk8)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk9\"),  OnDisk9)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk10\"), OnDisk10)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk11\"), OnDisk11)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk12\"), OnDisk12)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk13\"), OnDisk13)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk14\"), OnDisk14)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk15\"), OnDisk15)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk16\"), OnDisk16)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk17\"), OnDisk17)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk18\"), OnDisk18)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk19\"), OnDisk19)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk20\"), OnDisk20)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk21\"), OnDisk21)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk22\"), OnDisk22)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk23\"), OnDisk23)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk24\"), OnDisk24)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk25\"), OnDisk25)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk26\"), OnDisk26)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk27\"), OnDisk27)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk28\"), OnDisk28)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk29\"), OnDisk29)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk30\"), OnDisk30)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk31\"), OnDisk31)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk32\"), OnDisk32)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk33\"), OnDisk33)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk34\"), OnDisk34)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk35\"), OnDisk35)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk36\"), OnDisk36)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk37\"), OnDisk37)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk38\"), OnDisk38)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk39\"), OnDisk39)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk40\"), OnDisk40)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk41\"), OnDisk41)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk42\"), OnDisk42)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk43\"), OnDisk43)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk44\"), OnDisk44)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk45\"), OnDisk45)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk46\"), OnDisk46)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk47\"), OnDisk47)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk48\"), OnDisk48)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk49\"), OnDisk49)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk50\"), OnDisk50)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk51\"), OnDisk51)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk52\"), OnDisk52)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk53\"), OnDisk53)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk54\"), OnDisk54)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk55\"), OnDisk55)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk56\"), OnDisk56)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk57\"), OnDisk57)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk58\"), OnDisk58)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk59\"), OnDisk59)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk60\"), OnDisk60)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk61\"), OnDisk61)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk62\"), OnDisk62)\n\tDHTML_EVENT_ONCLICK(_T(\"Disk63\"), OnDisk63)\nEND_DHTML_EVENT_MAP()\n\n// If you add a minimize button to your dialog, you will need the code below\n//  to draw the icon.  For MFC applications using the document/view model,\n//  this is automatically done for you by the framework.\n\nvoid CGraphDlg::OnPaint()\n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // device context for painting\n\n\t\tSendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);\n\n\t\t// Center icon in client rectangle\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// Draw the icon\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tCDHtmlMainDialog::OnPaint();\n\t}\n}\n\n// The system calls this function to obtain the cursor to display while the user drags\n//  the minimized window.\nHCURSOR CGraphDlg::OnQueryDragIcon()\n{\n\treturn static_cast<HCURSOR>(m_hIcon);\n}\n\nvoid CGraphDlg::InitDialogComplete()\n{\n\tDebugPrint(_T(\"InitDialogComplete\"));\n\tstatic BOOL once = FALSE;\n\tif(! once)\n\t{\n\t\tm_bShowWindow = TRUE;\n\n\t\tInitMenuBar();\n\t\tUpdateBkImage();\n\n\t\tfor(int i = 0; i < m_DetectedDisk; i++)\n\t\t{\n\t\t\tif(m_DefaultDisk[i])\n\t\t\t{\n\t\t\t\tCheckDisk(i);\n\t\t\t}\n\t\t}\n\t\tm_bInitializing = FALSE;\n\n\t\tUpdateData(TRUE);\n\t\tm_AttributeId = _tstoi(m_SelectAttributeId);\n\n\t\tUpdateDialogSize();\n\t\tUpdateGraph();\n\t\tCenterWindow();\n\t\tShowWindow(SW_SHOW);\n\t\tonce = TRUE;\n\t}\n}\n\nvoid CGraphDlg::InitVars(int defaultDisk)\n{\n\tTCHAR str[256];\n\tCString cstr;\n\tint temp;\n\n\tGetPrivateProfileStringFx(_T(\"EXCHANGE\"), _T(\"DetectedDisk\"), _T(\"-1\"), str, 256, m_SmartDir + EXCHANGE_INI);\n\ttemp = _tstoi(str);\n\tif(0 < temp && temp <= CAtaSmart::MAX_DISK)\n\t{\n\t\tm_DetectedDisk = temp;\n\t}\n\telse\n\t{\n\t\tm_DetectedDisk = 0;\n\t}\n\n\tfor(int i = 0; i < CAtaSmart::MAX_DISK; i++)\n\t{\n\t\tm_bGraph[i] = FALSE;\n\t\tm_DefaultDisk[i] = FALSE;\n\t}\n\n\tif(0 <= defaultDisk && defaultDisk < m_DetectedDisk)\n\t{\n\t\tm_DefaultDisk[defaultDisk] = TRUE;\n\t}\n\telse\n\t{\n\t\tfor(int i = 0; i < m_DetectedDisk; i++)\n\t\t{\n\t\t\tcstr.Format(_T(\"Disk%d\"), i);\n\t\t\tif(GetPrivateProfileInt(_T(\"GraphHideDisk\"), cstr, 0, m_Ini) == 0)\n\t\t\t{\n\t\t\t\tm_DefaultDisk[i] = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < m_DetectedDisk; i++)\n\t{\n\t\tcstr.Format(_T(\"%d\"), i);\n\t\tGetPrivateProfileStringFx(_T(\"MODEL\"), cstr, _T(\"\"), str, 256, m_SmartDir + EXCHANGE_INI);\n\t\tm_Model[i] = str;\n\t\tm_ModelEscape[i] = str;\n\t\tm_ModelEscape[i].Replace(_T(\"\\\"\"), _T(\"\\\\\\\"\"));\n\t\tGetPrivateProfileStringFx(_T(\"SERIAL\"), cstr, _T(\"\"), str, 256, m_SmartDir + EXCHANGE_INI);\n\t\tm_Serial[i] = str;\n\t\tGetPrivateProfileStringFx(_T(\"DRIVE\"), cstr, _T(\"\"), str, 256, m_SmartDir + EXCHANGE_INI);\n\t\tm_Drive[i] = str;\n\t}\n\n\t// LegendPosition\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"LegendPosition\"), _T(\"sw\"), str, 256, m_Ini);\n\tcstr = str;\n\tif(cstr.Compare(_T(\"nw\")) == 0 || cstr.Compare(_T(\"ne\")) == 0 || cstr.Compare(_T(\"sw\")) == 0 || cstr.Compare(_T(\"se\")) == 0)\n\t{\n\t\tm_LegendPositon = str;\n\t}\n\telse\n\t{\n\t\tm_LegendPositon = _T(\"sw\");\n\t}\n\n\t// Date Style\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"TimeFormat\"), _T(\"mdhm\"), str, 256, m_Ini);\n\tcstr = str;\n\tif(cstr.Compare(_T(\"%m/%d %H:%M\")) == 0\n\t|| cstr.Compare(_T(\"%m/%d\")) == 0\n\t|| cstr.Compare(_T(\"%y/%m/%d %H:%M\")) == 0\n\t|| cstr.Compare(_T(\"%y/%m/%d\")) == 0\n\t|| cstr.Compare(_T(\"%d/%m/%y\")) == 0\n\t|| cstr.Compare(_T(\"%d/%m/%y %H:%M\")) == 0\n\t|| cstr.Compare(_T(\"%d.%m.%y\")) == 0\n\t|| cstr.Compare(_T(\"%d.%m.%y %H:%M\")) == 0)\n\t{\n\t\tm_TimeFormat = str;\n\t}\n\telse\n\t{\n\t\tm_TimeFormat = _T(\"%m/%d %H:%M\");\n\t}\n\n\t// Paint Weekend\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"PaintWeekend\"), _T(\"0\"), str, 256, m_Ini);\n\tif(_tstoi(str) > 0)\n\t{\n\t\tm_bPaintWeekend = TRUE;\n\t}\n\telse\n\t{\n\t\tm_bPaintWeekend = FALSE;\n\t}\n\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"MaxPlotPoint\"), _T(\"100\"), str, 256, m_Ini);\n\tif(_tstoi(str) > 0)\n\t{\n\t\tm_MaxPlotPoint = _tstoi(str);\n\t}\n\telse\n\t{\n\t\tm_MaxPlotPoint = 0;\n\t}\n\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"Attribute\"), _T(\"0\"), str, 256, m_Ini);\n\tif(_tstoi(str) > 0)\n\t{\n\t\tm_Attribute = _tstoi(str);\n\t}\n\telse\n\t{\n\t\tm_Attribute = 0;\n\t}\n\n\tfor (int i = 0; i < CAtaSmart::MAX_DISK + 1; i++)\n\t{\n\t\tm_DefaultLineColor[i] = 0x000000;\n\t}\n\n\t// Graph Color\n\tm_DefaultLineColor[0] = 0xff9797;\n\tm_DefaultLineColor[1] = 0x40c2ed;\n\tm_DefaultLineColor[2] = 0x4b4bcb;\n\tm_DefaultLineColor[3] = 0xc6ac8c;\n\tm_DefaultLineColor[4] = 0x4da74d;\n\tm_DefaultLineColor[5] = 0xaa1c4a;\n\tm_DefaultLineColor[6] = 0x1191bb;\n\tm_DefaultLineColor[7] = 0x47189e;\n\tm_DefaultLineColor[8] = 0xc17453;\n\tm_DefaultLineColor[9] = 0x1a7612;\n\tm_DefaultLineColor[10] = 0xff6c35;\n\tm_DefaultLineColor[11] = 0x24676f;\n\tm_DefaultLineColor[12] = 0x0b29a4;\n\tm_DefaultLineColor[13] = 0xd2958c;\n\tm_DefaultLineColor[14] = 0x575700;\n\tm_DefaultLineColor[15] = 0x808080;\n\tm_DefaultLineColor[16] = 0x787878;\n\tm_DefaultLineColor[17] = 0x707070;\n\tm_DefaultLineColor[18] = 0x686868;\n\tm_DefaultLineColor[19] = 0x606060;\n\tm_DefaultLineColor[20] = 0x585858;\n\tm_DefaultLineColor[21] = 0x505050;\n\tm_DefaultLineColor[22] = 0x484848;\n\tm_DefaultLineColor[23] = 0x404040;\n\tm_DefaultLineColor[24] = 0x383838;\n\tm_DefaultLineColor[25] = 0x303030;\n\tm_DefaultLineColor[26] = 0x282828;\n\tm_DefaultLineColor[27] = 0x202020;\n\tm_DefaultLineColor[28] = 0x181818;\n\tm_DefaultLineColor[29] = 0x101010;\n\tm_DefaultLineColor[30] = 0x080808;\n\tm_DefaultLineColor[31] = 0x000000;\n\n\tm_DefaultLineColor[CAtaSmart::MAX_DISK] = 0x4a24ff;\t// Threshold\n\n\tswitch(GetPrivateProfileInt(_T(\"Setting\"), _T(\"Temperature\"), 0, m_Ini))\n\t{\n\tcase   1:\tm_bFahrenheit = TRUE; break;\n\tdefault:\tm_bFahrenheit = FALSE;break;\n\t}\n\n\tm_bInitializing = TRUE;\n\n\tUpdateColor();\n}\n\nvoid CGraphDlg::UpdateColor()\n{\n\tfor(int i = 0; i < m_DetectedDisk; i++)\n\t{\n\t\tm_LineColor[i] = GetLineColor(i);\n\t}\n\t// Threshold\n\tm_LineColor[CAtaSmart::MAX_DISK] = GetLineColor(CAtaSmart::MAX_DISK);\n}\n\nCOLORREF CGraphDlg::GetLineColor(DWORD index)\n{\n\tTCHAR str[256];\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), index);\n\tGetPrivateProfileStringFx(_T(\"LineColor\"), cstr, _T(\"-1\"), str, 256, m_Ini);\n\n\tif(str[0] == '#')\n\t{\n\t\tint r, g, b;\n\t\tcstr = str;\n\t\tr = _tcstol(cstr.Mid(1,2), NULL, 16);\n\t\tg = _tcstol(cstr.Mid(3,2), NULL, 16);\n\t\tb = _tcstol(cstr.Mid(5,2), NULL, 16);\n\t\treturn RGB(r, g, b);\n\t}\n\telse if(_tstoi(str) <= -1 || _tstoi(str) > 0x00FFFFFF)\n\t{\n\t\treturn m_DefaultLineColor[index];\n\t}\n\telse\n\t{\n\t\treturn _tstoi(str);\n\t}\n}\n\nHRESULT CGraphDlg::OnSelectAttributeId(IHTMLElement* /*pElement*/)\n{\n\tUpdateData(TRUE);\n\n\tif(m_AttributeId != _tstoi(m_SelectAttributeId))\n\t{\n\t\tm_AttributeId = _tstoi(m_SelectAttributeId);\n\t\tUpdateGraph();\n\t\tCString cstr;\n\t\tcstr.Format(_T(\"%d\"), m_AttributeId);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"SelectedAttributeId\"), cstr, m_Ini);\n\t}\n\n\treturn S_FALSE;\n}\n\nHRESULT CGraphDlg::OnDisk0(IHTMLElement* /*pElement*/){CheckDisk(0);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk1(IHTMLElement* /*pElement*/){CheckDisk(1);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk2(IHTMLElement* /*pElement*/){CheckDisk(2);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk3(IHTMLElement* /*pElement*/){CheckDisk(3);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk4(IHTMLElement* /*pElement*/){CheckDisk(4);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk5(IHTMLElement* /*pElement*/){CheckDisk(5);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk6(IHTMLElement* /*pElement*/){CheckDisk(6);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk7(IHTMLElement* /*pElement*/){CheckDisk(7);UpdateGraph();return S_FALSE;}\n\nHRESULT CGraphDlg::OnDisk8(IHTMLElement* /*pElement*/){CheckDisk(8);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk9(IHTMLElement* /*pElement*/){CheckDisk(9);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk10(IHTMLElement* /*pElement*/){CheckDisk(10);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk11(IHTMLElement* /*pElement*/){CheckDisk(11);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk12(IHTMLElement* /*pElement*/){CheckDisk(12);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk13(IHTMLElement* /*pElement*/){CheckDisk(13);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk14(IHTMLElement* /*pElement*/){CheckDisk(14);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk15(IHTMLElement* /*pElement*/){CheckDisk(15);UpdateGraph();return S_FALSE;}\n\nHRESULT CGraphDlg::OnDisk16(IHTMLElement* /*pElement*/){CheckDisk(16);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk17(IHTMLElement* /*pElement*/){CheckDisk(17);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk18(IHTMLElement* /*pElement*/){CheckDisk(18);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk19(IHTMLElement* /*pElement*/){CheckDisk(19);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk20(IHTMLElement* /*pElement*/){CheckDisk(20);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk21(IHTMLElement* /*pElement*/){CheckDisk(21);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk22(IHTMLElement* /*pElement*/){CheckDisk(22);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk23(IHTMLElement* /*pElement*/){CheckDisk(23);UpdateGraph();return S_FALSE;}\n\nHRESULT CGraphDlg::OnDisk24(IHTMLElement* /*pElement*/){CheckDisk(24);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk25(IHTMLElement* /*pElement*/){CheckDisk(25);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk26(IHTMLElement* /*pElement*/){CheckDisk(26);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk27(IHTMLElement* /*pElement*/){CheckDisk(27);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk28(IHTMLElement* /*pElement*/){CheckDisk(28);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk29(IHTMLElement* /*pElement*/){CheckDisk(29);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk30(IHTMLElement* /*pElement*/){CheckDisk(30);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk31(IHTMLElement* /*pElement*/){CheckDisk(31);UpdateGraph();return S_FALSE;}\n\nHRESULT CGraphDlg::OnDisk32(IHTMLElement* /*pElement*/){CheckDisk(32);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk33(IHTMLElement* /*pElement*/){CheckDisk(33);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk34(IHTMLElement* /*pElement*/){CheckDisk(34);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk35(IHTMLElement* /*pElement*/){CheckDisk(35);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk36(IHTMLElement* /*pElement*/){CheckDisk(36);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk37(IHTMLElement* /*pElement*/){CheckDisk(37);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk38(IHTMLElement* /*pElement*/){CheckDisk(38);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk39(IHTMLElement* /*pElement*/){CheckDisk(39);UpdateGraph();return S_FALSE;}\n\nHRESULT CGraphDlg::OnDisk40(IHTMLElement* /*pElement*/){CheckDisk(40);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk41(IHTMLElement* /*pElement*/){CheckDisk(41);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk42(IHTMLElement* /*pElement*/){CheckDisk(42);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk43(IHTMLElement* /*pElement*/){CheckDisk(43);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk44(IHTMLElement* /*pElement*/){CheckDisk(44);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk45(IHTMLElement* /*pElement*/){CheckDisk(45);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk46(IHTMLElement* /*pElement*/){CheckDisk(46);UpdateGraph();return S_FALSE;}\nHRESULT CGraphDlg::OnDisk47(IHTMLElement* /*pElement*/){CheckDisk(47);UpdateGraph();return S_FALSE;}\n\nHRESULT CGraphDlg::OnDisk48(IHTMLElement* /*pElement*/){ CheckDisk(48); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk49(IHTMLElement* /*pElement*/){ CheckDisk(49); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk50(IHTMLElement* /*pElement*/){ CheckDisk(50); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk51(IHTMLElement* /*pElement*/){ CheckDisk(51); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk52(IHTMLElement* /*pElement*/){ CheckDisk(52); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk53(IHTMLElement* /*pElement*/){ CheckDisk(53); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk54(IHTMLElement* /*pElement*/){ CheckDisk(54); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk55(IHTMLElement* /*pElement*/){ CheckDisk(55); UpdateGraph(); return S_FALSE; }\n\nHRESULT CGraphDlg::OnDisk56(IHTMLElement* /*pElement*/){ CheckDisk(56); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk57(IHTMLElement* /*pElement*/){ CheckDisk(57); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk58(IHTMLElement* /*pElement*/){ CheckDisk(58); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk59(IHTMLElement* /*pElement*/){ CheckDisk(59); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk60(IHTMLElement* /*pElement*/){ CheckDisk(60); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk61(IHTMLElement* /*pElement*/){ CheckDisk(61); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk62(IHTMLElement* /*pElement*/){ CheckDisk(62); UpdateGraph(); return S_FALSE; }\nHRESULT CGraphDlg::OnDisk63(IHTMLElement* /*pElement*/){ CheckDisk(63); UpdateGraph(); return S_FALSE; }\n\n\nHRESULT CGraphDlg::OnAllOn(IHTMLElement* /*pElement*/)\n{\n\tCString cstr;\n\tfor(int i = 0; i < m_DetectedDisk; i++)\n\t{\n\t\tcstr.Format(_T(\"Disk%d\"), i);\n\t\tm_bGraph[i] = TRUE;\n\t\tSetElementPropertyEx(cstr, DISPID_IHTMLELEMENT_CLASSNAME, _T(\"selected\"));\n\t}\n\tUpdateGraph();\n\n\treturn S_FALSE;\n}\n\nHRESULT CGraphDlg::OnAllOff(IHTMLElement* /*pElement*/)\n{\n\tCString cstr;\n\tfor(int i = 0; i < m_DetectedDisk; i++)\n\t{\n\t\tcstr.Format(_T(\"Disk%d\"), i);\n\t\tm_bGraph[i] = FALSE;\n\t\tSetElementPropertyEx(cstr, DISPID_IHTMLELEMENT_CLASSNAME, _T(\"\"));\n\t}\n\tUpdateGraph();\n\n\treturn S_FALSE;\n}\n\nHRESULT CGraphDlg::OnReset(IHTMLElement* /*pElement*/)\n{\n\tUpdateGraph();\n\treturn S_FALSE;\n}\n\nBOOL CGraphDlg::CheckDisk(DWORD disk)\n{\n\tCString cstr;\n\n\tm_bGraph[disk] = ( ! m_bGraph[disk] ? TRUE : FALSE );\n\n\tcstr.Format(_T(\"Disk%d\"), disk);\n\tif(m_bGraph[disk])\n\t{\n\t\tSetElementPropertyEx(cstr, DISPID_IHTMLELEMENT_CLASSNAME, _T(\"selected\"));\n\t}\n\telse\n\t{\n\t\tSetElementPropertyEx(cstr, DISPID_IHTMLELEMENT_CLASSNAME, _T(\"\"));\n\t}\n\n\treturn TRUE;\n}\n\nvoid CGraphDlg::InitMenuBar()\n{\n\tCString cstr, temp, space;\n\n\tint counter = 0, index = 0;\n\tm_SelectAttributeIdCtrl = 0;\n\tDWORD SelectedAttributeId = GetPrivateProfileInt(_T(\"Setting\"), _T(\"SelectedAttributeId\"), 0, m_Ini);\n\n\tfor(int i = 0; i < CAtaSmart::MAX_DISK; i++)\n\t{\n\t\tm_LiDisk[i] = _T(\"\");\n\t\tcstr.Format(_T(\"Disk%d\"), i);\n\t\tSetElementPropertyEx(cstr, DISPID_IHTMLELEMENT_CLASSNAME, _T(\"hidden\"));\n\t}\n\n\tfor(int i = 0; i < m_DetectedDisk; i++)\n\t{\n\t\tcstr.Format(_T(\"%d\"), i + 1);\n\t\tm_LiDisk[i] = cstr;\n\t\tcstr.Format(_T(\"Disk%d\"), i);\n\t\tSetElementPropertyEx(cstr, DISPID_IHTMLELEMENT_CLASSNAME, _T(\"visible\"));\n\t\t\n\t\ttemp.Format(_T(\"%s\\r\\n%s\"), m_Model[i].GetString(), m_Serial[i].GetString());\n\t\tif(! m_Drive[i].IsEmpty())\n\t\t{\n\t\t\ttemp += (_T(\"\\r\\n\") + m_Drive[i]);\n\t\t}\n\t\tSetElementPropertyEx(cstr, DISPID_IHTMLELEMENT_TITLE, temp);\n\t}\n\n\tSetElementPropertyEx(_T(\"AllOn\"), DISPID_IHTMLELEMENT_TITLE, i18n(_T(\"Graph\"), _T(\"ALL_ON\")));\n\tSetElementPropertyEx(_T(\"AllOff\"), DISPID_IHTMLELEMENT_TITLE, i18n(_T(\"Graph\"), _T(\"ALL_OFF\")));\n\tSetElementPropertyEx(_T(\"Reset\"), DISPID_IHTMLELEMENT_TITLE, i18n(_T(\"Graph\"), _T(\"RESET\")));\n\n\tCString select;\n\n\tcstr.Format(_T(\"<select id=\\\"SelectAttributeId\\\" title=\\\"%s\\\" onchange=\\\"this.click()\\\">\"), i18n(_T(\"Graph\"), _T(\"PLEASE_SELECT_ITEM\"), m_bSmartEnglish).GetString());\n\tselect = cstr;\n\n\tif(m_IeVersion >= 700)\n\t{\n\t\tcstr.Format(_T(\"<optgroup label=\\\"%s\\\">\"), i18n(_T(\"Graph\"), _T(\"ACTUAL_VALUE\"), m_bSmartEnglish).GetString());\n\t\tselect += cstr;\n\t}\n\telse\n\t{\n\t\tcstr.Format(_T(\"<option value=\\\"513\\\">%s</option>\"), i18n(_T(\"Graph\"), _T(\"ACTUAL_VALUE\"), m_bSmartEnglish).GetString());\n\t\tselect += cstr;\n\t\tspace = _T(\"&nbsp;&nbsp;\");\n\t\tif(SelectedAttributeId == 513)\n\t\t{\n\t\t\tindex = counter;\n\t\t}\n\t\tcounter++;\n\t}\n\t\n\tBOOL flagAttribute[256] = {0};\n\tCString dir, disk;\n\tTCHAR str[256];\n\tfor(int i = 0; i < m_DetectedDisk; i++)\n\t{\n\t\tdir = m_SmartDir;\n\t\tdisk = GetModelSerial(m_Model[i], m_Serial[i]);\n\t\tdir += disk;\n\t\tfor(int j = 1; j < 255; j++)\n\t\t{\n\t\t\tcstr.Format(_T(\"%02X\"), j);\n\t\t\tGetPrivateProfileStringFx(disk, cstr, _T(\"-1\"), str, 256, dir + _T(\"\\\\\") + SMART_INI);\n\t\t\tif(_tstoi(str) >= 0)\n\t\t\t{\n\t\t\t\tflagAttribute[j] = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (m_Attribute != CAtaSmart::SSD_VENDOR_NVME)\n\t{\n\t\t// Reallocated Sectors Count\n\t\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[05] %s</option>\"), SMART_REALLOCATED_SECTORS_COUNT, i18n(_T(\"Smart\"), _T(\"05\"), m_bSmartEnglish).GetString());\n\t\tselect += cstr; if (SelectedAttributeId == SMART_REALLOCATED_SECTORS_COUNT) { index = counter; }counter++;\n\t}\n\n\t// PowerOnHours\n\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[09] %s</option>\"), SMART_POWER_ON_HOURS, i18n(_T(\"Smart\"), _T(\"09\"), m_bSmartEnglish).GetString());\n\tselect += cstr;if(SelectedAttributeId == SMART_POWER_ON_HOURS){index = counter;}counter++;\n\n\t// PowerOnCount\n\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[0C] %s</option>\"), SMART_POWER_ON_COUNT, i18n(_T(\"Smart\"), _T(\"0C\"), m_bSmartEnglish).GetString());\n\tselect += cstr;if(SelectedAttributeId == SMART_POWER_ON_COUNT){index = counter;}counter++;\n\n\t// Temperature\n\tif(m_bFahrenheit)\n\t{\n\t\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[C2] %s (&deg;F)</option>\"), SMART_TEMPERATURE, i18n(_T(\"Smart\"), _T(\"C2\"), m_bSmartEnglish).GetString());\n\t}\n\telse\n\t{\n\t\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[C2] %s (&deg;C)</option>\"), SMART_TEMPERATURE, i18n(_T(\"Smart\"), _T(\"C2\"), m_bSmartEnglish).GetString());\n\t}\n\tselect += cstr;if(SelectedAttributeId == SMART_TEMPERATURE){index = counter;}counter++;\n\t\n\tif (m_Attribute != CAtaSmart::SSD_VENDOR_NVME)\n\t{\n\t\t// Reallocation Event Count\n\t\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[C4] %s</option>\"), SMART_REALLOCATED_EVENT_COUNT, i18n(_T(\"Smart\"), _T(\"C4\"), m_bSmartEnglish).GetString());\n\t\tselect += cstr; if (SelectedAttributeId == SMART_REALLOCATED_EVENT_COUNT) { index = counter; }counter++;\n\n\t\t// Current Pending Sector Count\n\t\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[C5] %s</option>\"), SMART_CURRENT_PENDING_SECTOR_COUNT, i18n(_T(\"Smart\"), _T(\"C5\"), m_bSmartEnglish).GetString());\n\t\tselect += cstr; if (SelectedAttributeId == SMART_CURRENT_PENDING_SECTOR_COUNT) { index = counter; }counter++;\n\n\t\t// Off-Line Scan Uncorrectable Sector Count\n\t\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[C6] %s</option>\"), SMART_UNCORRECTABLE_SECTOR_COUNT, i18n(_T(\"Smart\"), _T(\"C6\"), m_bSmartEnglish).GetString());\n\t\tselect += cstr; if (SelectedAttributeId == SMART_UNCORRECTABLE_SECTOR_COUNT) { index = counter; }counter++;\n\t}\n\n\t// Life\n\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[XX] %s</option>\"), SMART_LIFE, i18n(_T(\"SmartSsd\"), _T(\"FF\"), m_bSmartEnglish).GetString());\n\tselect += cstr;if(SelectedAttributeId == SMART_LIFE){index = counter;}counter++;\n\t\n\t// HostWrites\n\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[XX] %s (GB)</option>\"), SMART_HOST_WRITES, i18n(_T(\"Dialog\"), _T(\"TOTAL_HOST_WRITES\"), m_bSmartEnglish).GetString());\n\tselect += cstr;if(SelectedAttributeId == SMART_HOST_WRITES){index = counter;}counter++;\n\t\n\t// HostReads\n\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[XX] %s (GB)</option>\"), SMART_HOST_READS, i18n(_T(\"Dialog\"), _T(\"TOTAL_HOST_READS\"), m_bSmartEnglish).GetString());\n\tselect += cstr;if(SelectedAttributeId == SMART_HOST_READS){index = counter;}counter++;\n\n\tif (m_Attribute != CAtaSmart::SSD_VENDOR_NVME)\n\t{\n\t\t// NandWrites\n\t\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[XX] %s (GB)</option>\"), SMART_NAND_WRITES, i18n(_T(\"Dialog\"), _T(\"TOTAL_NAND_WRITES\"), m_bSmartEnglish).GetString());\n\t\tselect += cstr; if (SelectedAttributeId == SMART_NAND_WRITES) { index = counter; }counter++;\n\n\n\t\t// GBytes Erased\n\t\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[XX] %s (GB)</option>\"), SMART_NAND_ERASED, i18n(_T(\"SmartSandForce\"), _T(\"64\"), m_bSmartEnglish).GetString());\n\t\tselect += cstr; if (SelectedAttributeId == SMART_NAND_ERASED) { index = counter; }counter++;\n\n\t\t// Wear Leveling Count for Micron\n\t\tcstr.Format(_T(\"<option value=\\\"%d\\\" selected=\\\"selected\\\">[XX] %s</option>\"), SMART_WEAR_LEVELING_COUNT, i18n(_T(\"Dialog\"), _T(\"WEAR_LEVELING_COUNT\"), m_bSmartEnglish).GetString());\n\t\tselect += cstr; if (SelectedAttributeId == SMART_WEAR_LEVELING_COUNT) { index = counter; }counter++;\n\t}\n\n\tif (m_Attribute != CAtaSmart::SSD_VENDOR_NVME)\n\t{\n\t\tif (m_IeVersion >= 700)\n\t\t{\n\t\t\tcstr.Format(_T(\"<optgroup label=\\\"%s\\\">\"), i18n(_T(\"Graph\"), _T(\"NORMALIZED_VALUE\"), m_bSmartEnglish).GetString());\n\t\t\tselect += cstr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"<option value=\\\"514\\\">%s</option>\"), i18n(_T(\"Graph\"), _T(\"NORMALIZED_VALUE\"), m_bSmartEnglish).GetString());\n\t\t\tselect += cstr;\n\t\t\tif (SelectedAttributeId == 514)\n\t\t\t{\n\t\t\t\tindex = counter;\n\t\t\t}\n\t\t\tcounter++;\n\t\t}\n\n\t\tCString sectionName = attributeString[m_Attribute];\n\n\t\tfor (int i = 1; i < 255; i++)\n\t\t{\n\t\t\tif (flagAttribute[i])\n\t\t\t{\n\t\t\t\tcstr.Format(_T(\"%02X\"), i);\n\t\t\t\tif (i18n(sectionName, cstr).IsEmpty())\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"<option value=\\\"%d\\\">%s(%02X) %s</option>\"), i, space.GetString(), i, i18n(_T(\"Smart\"), _T(\"UNKNOWN\"), m_bSmartEnglish).GetString());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcstr.Format(_T(\"<option value=\\\"%d\\\">%s(%02X) %s</option>\"), i, space.GetString(), i, i18n(sectionName, cstr, m_bSmartEnglish).GetString());\n\t\t\t\t}\n\t\t\t\tif (SelectedAttributeId == i)\n\t\t\t\t{\n\t\t\t\t\tindex = counter;\n\t\t\t\t}\n\t\t\t\tselect += cstr;\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t}\n\n\tselect += _T(\"</select>\");\n\tSetElementOuterHtmlEx(_T(\"SelectAttributeId\"), select);\n\n\tm_SelectAttributeIdCtrl = index;\n\tUpdateData(FALSE);\n}\n\nBOOL CGraphDlg::UpdateGraph()\n{\n\tCString cstr, line, values, thresholds, maxMin, points;\n\tCString smartFile, fileName;\n\tCStdioFile inFile;\n\tDWORD threshold = 0;\n\tint max = -1, min = -1;\n\n\tif(m_AttributeId > 0x200)\n\t{\n\t\tCallScript(_T(\"updateData\"), _T(\"[]\"));\n\t//\tCallScript(_T(\"reDraw\"), NULL);\n\t\tCallScript(_T(\"changeSize\"), NULL); // Redraw\n\t\treturn FALSE;\n\t}\n\telse if(m_AttributeId < 0x100)\n\t{\n\t\tfileName.Format(_T(\"%02X\"), m_AttributeId);\n\t\tmax = 255;\n\t\tmin = 0;\n\t}\n\telse if(m_AttributeId >= 0x100)\n\t{\n\t\tswitch(m_AttributeId)\n\t\t{\n\t\tcase SMART_TEMPERATURE:                  fileName = _T(\"Temperature\");\t\t\t\tmin = 0;break;\n\t\tcase SMART_POWER_ON_HOURS:               fileName = _T(\"PowerOnHours\");\t\t\t\tbreak;\n\t\tcase SMART_POWER_ON_COUNT:               fileName = _T(\"PowerOnCount\");\t\t\t\tbreak;\n\t\tcase SMART_REALLOCATED_SECTORS_COUNT:    fileName = _T(\"ReallocatedSectorsCount\");\tmin = 0; break;\n\t\tcase SMART_REALLOCATED_EVENT_COUNT:      fileName = _T(\"ReallocationEventCount\");\tmin = 0; break;\n\t\tcase SMART_CURRENT_PENDING_SECTOR_COUNT: fileName = _T(\"CurrentPendingSectorCount\");min = 0; break;\n\t\tcase SMART_UNCORRECTABLE_SECTOR_COUNT:   fileName = _T(\"UncorrectableSectorCount\");\tmin = 0; break;\n\t\tcase SMART_HOST_WRITES:                  fileName = _T(\"HostWrites\");\t\t\t\tmin = 0; break;\n\t\tcase SMART_HOST_READS:                   fileName = _T(\"HostReads\");\t\t\t\tmin = 0; break;\n\t\tcase SMART_NAND_WRITES:                  fileName = _T(\"NandWrites\");\t\t\t\tmin = 0; break;\n\t\tcase SMART_NAND_ERASED:                  fileName = _T(\"GBytesErased\");\t\t\t\tmin = 0; break;\n\t\tcase SMART_WEAR_LEVELING_COUNT:          fileName = _T(\"WearLevelingCount\");\t\tmin = 0; break;\n\t\tcase SMART_LIFE:                         fileName = _T(\"Life\");\t\t\t\t\t\tmax = 100;\tmin = 0; break;\n\t\tdefault:\n\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\t// Update Time Zone Information\n\tGetTimeZoneInformation(&m_TimeZoneInformation);\n\n\tUpdateColor();\n\n\tDWORD value = 0;\n\ttime_t dateTime;\n\tULONGLONG startTime = 0;\n\tint count = 0;\n\tint drive = 0;\n\tint index = 0; // Only One Disk\n\tCString arg;\n\n\targ = _T(\"[\");\n\n\tfor(int i = 0; i < m_DetectedDisk; i++)\n\t{\n\t\tif(m_bGraph[i] == FALSE)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tcount = 0;\n\t\tvalues = _T(\"\");\n\n\t\tsmartFile = m_SmartDir;\n\t\tsmartFile += GetModelSerial(m_Model[i], m_Serial[i]);\n\t\tsmartFile += _T(\"\\\\\") + fileName + _T(\".csv\");\n\t\tif(! inFile.Open(smartFile, CFile::modeRead | CFile::typeText))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint end = 0;\n\t\t\tint start = 0;\n\t\t\tint count = 0;\n\t\t\tCStringArray lines;\n\t\t\t/*\n\t\t\twhile(inFile.ReadString(line) != NULL)\n\t\t\t{\n\t\t\t\tif(line.GetLength() > 0)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\n\t\t\t// 20140602 - Skip null\n\t\t\twhile (inFile.GetPosition() < inFile.GetLength())\n\t\t\t{\n\t\t\t\twhile (inFile.ReadString(line) != NULL)\n\t\t\t\t{\n\t\t\t\t\tif (line.GetLength() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(count > (int)m_MaxPlotPoint && m_MaxPlotPoint != 0)\n\t\t\t{\n\t\t\t\tstart = count - (int)m_MaxPlotPoint;\n\t\t\t\tend = m_MaxPlotPoint;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstart = 0;\n\t\t\t\tend = count;\n\t\t\t}\n\t\t\tinFile.SeekToBegin();\n\t\t\tcount = 0;\n\t\t\twhile (inFile.GetPosition() < inFile.GetLength())\n\t\t\t{\n\t\t\t\twhile (inFile.ReadString(line) != NULL)\n\t\t\t\t{\n\t\t\t\t\tif (line.GetLength() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif (start < count && count <= start + end)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlines.Add(line);\n\t\t\t\t\t\t\tDebugPrint(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tinFile.Close();\n\n\t\t\tcount = 0;\n\t\t\tif(m_AttributeId == SMART_TEMPERATURE && m_bFahrenheit) // Fahrenheit\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < end; i++)\n\t\t\t\t{\n\t\t\t\t\tline = lines.GetAt(i);\n\t\t\t\t\tdateTime = GetTimeT(line.Left(19));\n\t\t\t\t\tif(count != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcstr.Format(_T(\"[%I64d, %d], \"), dateTime * 1000, value * 9 / 5 + 32); \n\t\t\t\t\t\tvalues += cstr;\n\t\t\t\t\t}\n\t\t\t\t\tif(count == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTime = dateTime * 1000;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = _tstoi(line.Mid(20));\n\t\t\t\t\tcstr.Format(_T(\"[%I64d, %d], \"), dateTime * 1000, value * 9 / 5 + 32); \n\t\t\t\t\tvalues += cstr;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < end; i++)\n\t\t\t\t{\n\t\t\t\t\tline = lines.GetAt(i);\n\t\t\t\t\tdateTime = GetTimeT(line.Left(19));\n\t\t\t\t\tif(count != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcstr.Format(_T(\"[%I64d, %d], \"), dateTime * 1000, value); \n\t\t\t\t\t\tvalues += cstr;\n\t\t\t\t\t}\n\t\t\t\t\tif(count == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTime = dateTime * 1000;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = _tstoi(line.Mid(20));\n\t\t\t\t\tcstr.Format(_T(\"[%I64d, %d], \"), dateTime * 1000, value); \n\t\t\t\t\tvalues += cstr;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdrive++;\n\t\tindex = i;\n\n\t\t// Latest\n\t\t_tzset();\n\t\tif(m_AttributeId == SMART_TEMPERATURE && m_bFahrenheit) // Fahrenheit\n\t\t{\n\t\t\tcstr.Format(_T(\"[%I64d, %d]\"), (ULONGLONG)(time(&dateTime) - (time_t)m_TimeZoneInformation.Bias * 60) * 1000, value * 9 / 5 + 32);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"[%I64d, %d]\"), (ULONGLONG)(time(&dateTime) - (time_t)m_TimeZoneInformation.Bias * 60) * 1000, value);\n\t\t}\n\t\tvalues += cstr;\n/*\t\tcstr.Format(_T(\"{label: \\\"(%d) %s\\\", data:[%s]}, \"),\n\t\t\ti + 1, m_Model[i],\n\t\t\tvalues);\n*/\n\t\tif(m_Drive[i].IsEmpty())\n\t\t{\n\t\t\tcstr.Format(_T(\"{label: \\\"(%d) %s\\\", color: \\\"rgb(%d, %d, %d)\\\", data:[%s]}, \"),\n\t\t\t\ti + 1, m_ModelEscape[i].GetString(),\n\t\t\t\tGetRValue(m_LineColor[i]), GetGValue(m_LineColor[i]), GetBValue(m_LineColor[i]), values.GetString());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcstr.Format(_T(\"{label: \\\"(%d) %s [%s]\\\", color: \\\"rgb(%d, %d, %d)\\\", data:[%s]}, \"),\n\t\t\t\ti + 1, m_ModelEscape[i].GetString(), m_Drive[i].GetString(),\n\t\t\t\tGetRValue(m_LineColor[i]), GetGValue(m_LineColor[i]), GetBValue(m_LineColor[i]), values.GetString());\n\t\t}\n\n\t//\tcstr.Format(_T(\"{label: \\\"%s\\\", color: \\\"rgb(%d, %d, %d)\\\", data:[%s]}, \"),\n\t//\t\tm_Ata->vars[i].Model, rand() % 256, rand() % 256, rand() % 256, values);\n\t\targ += cstr;\n\t}\n\n\tif(m_AttributeId < 0x100 && drive == 1)\n\t{\n\t\tCString dir, disk;\n\t\tdir = m_SmartDir;\n\t\tdisk = GetModelSerial(m_Model[index], m_Serial[index]);\n\t\tdir += disk;\n\t\tTCHAR str[256];\n\t\tcstr.Format(_T(\"%02X\"), m_AttributeId);\n\t\tGetPrivateProfileStringFx(disk + _T(\"THRESHOLD\"), cstr, _T(\"-1\"), str, 256, dir + _T(\"\\\\\") + SMART_INI);\n\t\tthreshold = _tstoi(str);\n\t\tif(threshold >= 0)\n\t\t{\n\t\t\tcstr.Format(_T(\"{label: \\\"%s\\\", color: \\\"rgb(%d, %d, %d)\\\", data:[\"),\n\t\t\t\ti18n(_T(\"Dialog\"), _T(\"LIST_THRESHOLD\"), m_bSmartEnglish).GetString(),\n\t\t\t\tGetRValue(m_LineColor[CAtaSmart::MAX_DISK]),\n\t\t\t\tGetGValue(m_LineColor[CAtaSmart::MAX_DISK]),\n\t\t\t\tGetBValue(m_LineColor[CAtaSmart::MAX_DISK])\n\t\t\t\t);\n\t\t\targ += cstr;\n\t\t\tcstr.Format(_T(\"[%I64d, %d], \"), startTime, threshold); \n\t\t\targ += cstr; \n\t\t\tcstr.Format(_T(\"[%I64d, %d]\"), (ULONGLONG)(time(&dateTime) - (time_t)m_TimeZoneInformation.Bias * 60) * 1000, threshold);\n\t\t\targ += cstr;\n\t\t\targ += _T(\"]}, \");\n\t\t}\n\t}\n\n\tif(arg.GetLength() > 3)\n\t{\n\t\targ.Delete(arg.GetLength() - 2, 2);\n\t}\n\targ += _T(\"]\");\n\n\tCString options, overViewOptions, grid;\n\n\tif(m_bPaintWeekend)\n\t{\n\t\tgrid = _T(\"grid: { hoverable: true, clickable: true, coloredAreas: weekendAreas },\");\n\t}\n\telse\n\t{\n\t\tgrid = _T(\"grid: { hoverable: true, clickable: true },\");\n\t}\n\n\t// Options\n\tif(max == -1 && min == -1) // Auto\n\t{\n\toptions.Format(_T(\"{\\\nxaxis: { mode: \\\"time\\\", ticks: 4, timeformat: \\\"%s\\\", minTickSize: [60, \\\"minute\\\"]},\\\nyaxis: { minTickSize: 1, min: null, max: null },\\\nselection: { mode: \\\"xy\\\" },\\\n%s\\\nlegend: { position: \\\"%s\\\", margin: 20 },\\\nlines: { show: true }\\\n}\"), m_TimeFormat.GetString(), grid.GetString(), m_LegendPositon.GetString());\n\t}\n\telse if(max == -1)\n\t{\n\toptions.Format(_T(\"{\\\nxaxis: { mode: \\\"time\\\", ticks: 4, timeformat: \\\"%s\\\", minTickSize: [60, \\\"minute\\\"]},\\\nyaxis: { minTickSize: 1, min: %d, max: null },\\\nselection: { mode: \\\"xy\\\" },\\\n%s\\\nlegend: { position: \\\"%s\\\", margin: 20 },\\\nlines: { show: true }\\\n%s\\\n}\"), m_TimeFormat.GetString(), min, grid.GetString(), m_LegendPositon.GetString(), points.GetString());\n\t}\n\telse\n\t{\n\toptions.Format(_T(\"{\\\nxaxis: { mode: \\\"time\\\", ticks: 4, timeformat: \\\"%s\\\", minTickSize: [60, \\\"minute\\\"]},\\\nyaxis: { minTickSize: 1, min: %d, max: %d },\\\nselection: { mode: \\\"xy\\\" },\\\n%s\\\nlegend: { position: \\\"%s\\\", margin: 20 },\\\nlines: { show: true }\\\n%s\\\n}\"), m_TimeFormat.GetString(), min, max, grid.GetString(), m_LegendPositon.GetString(), points.GetString());\n\t}\n\n\t// overViewOptions\n\tif(max == -1 && min == -1)\n\t{\n\toverViewOptions.Format(_T(\"{\\\nxaxis: { ticks: [], mode: \\\"time\\\" },\\\nyaxis: { ticks: [], min: 0, max: null  },\\\nselection: { mode: \\\"x\\\" },\\\n%s\\\nlegend: { show: false },\\\nlines: { show: true }\\\n}\"), grid.GetString());\n\t}\n\telse if(max == -1)\n\t{\n\toverViewOptions.Format(_T(\"{\\\nxaxis: { ticks: [], mode: \\\"time\\\" },\\\nyaxis: { ticks: [], min: 0, max: null  },\\\nselection: { mode: \\\"x\\\" },\\\n%s\\\nlegend: { show: false },\\\nlines: { show: true }\\\n}\"), grid.GetString());\n\t}\n\telse\n\t{\n\toverViewOptions.Format(_T(\"{\\\nxaxis: { ticks: [], mode: \\\"time\\\" },\\\nyaxis: { ticks: [], min: %d, max: %d },\\\nselection: { mode: \\\"x\\\" },\\\n%s\\\nlegend: { show: false },\\\nlines: { show: true }\\\n}\"), min, max, grid.GetString());\n\t}\n\tCallScript(_T(\"updateData\"), arg);\n\tCallScript(_T(\"updateMainViewOptions\"), options);\n\tCallScript(_T(\"updateOverViewOptions\"), overViewOptions);\n//\tCallScript(_T(\"reDraw\"), NULL);\n\tCallScript(_T(\"changeSize\"), NULL); // Redraw\n\n\tif(m_AttributeId >= 0x100)\n\t{\n\t\tcstr.Format(_T(\"%02X\"), m_AttributeId % 256);\n\t\tm_Title.Format(_T(\"%s\"), i18n(_T(\"Smart\"), cstr, m_bSmartEnglish).GetString());\n\t}\n\telse\n\t{\n\t\tcstr.Format(_T(\"%02X\"), m_AttributeId);\n\t\tm_Title.Format(_T(\"(%02X) %s\"), m_AttributeId, i18n(_T(\"Smart\"), cstr, m_bSmartEnglish).GetString());\n\t}\n\n\tUpdateData(FALSE);\n\treturn TRUE;\n}\n\n\nvoid CGraphDlg::InitMenu()\n{\n\tCString cstr, temp;\n\tCMenu *menu = GetMenu();\n\tCMenu subMenu;\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"FILE\"));\n\tmenu->ModifyMenu(0, MF_BYPOSITION | MF_STRING, 0, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"OPTION\"));\n\tmenu->ModifyMenu(1, MF_BYPOSITION | MF_STRING, 1, cstr);\n\n\tcstr = i18n(_T(\"Menu\"), _T(\"CUSTOMIZE\"));\n\tmenu->ModifyMenu(ID_CUSTOMIZE, MF_STRING, ID_CUSTOMIZE, cstr);\n \tcstr = i18n(_T(\"Menu\"), _T(\"EXIT\"));\n\tmenu->ModifyMenu(ID_EXIT, MF_STRING, ID_EXIT, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"PAINT_WEEKEND\"));\n\tmenu->ModifyMenu(ID_PAINT_WEEKEND, MF_STRING, ID_PAINT_WEEKEND, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"ALL\"));\n\tmenu->ModifyMenu(ID_POINT_ALL, MF_STRING, ID_POINT_ALL, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"NORTH_WEST\"));\n\tmenu->ModifyMenu(ID_NORTH_WEST, MF_STRING, ID_NORTH_WEST, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"NORTH_EAST\"));\n\tmenu->ModifyMenu(ID_NORTH_EAST, MF_STRING, ID_NORTH_EAST, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"SOUTH_WEST\"));\n\tmenu->ModifyMenu(ID_SOUTH_WEST, MF_STRING, ID_SOUTH_WEST, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"SOUTH_EAST\"));\n\tmenu->ModifyMenu(ID_SOUTH_EAST, MF_STRING, ID_SOUTH_EAST, cstr);\n\n\tsubMenu.Attach(menu->GetSubMenu(1)->GetSafeHmenu());\n\tcstr = i18n(_T(\"Menu\"), _T(\"LEGEND_POSITION\"));\n\tsubMenu.ModifyMenu(0, MF_BYPOSITION, 0, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"MAX_PLOT_POINT\"));\n\tsubMenu.ModifyMenu(1, MF_BYPOSITION, 1, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"TIME_FORMAT\"));\n\tsubMenu.ModifyMenu(2, MF_BYPOSITION, 2, cstr);\n\tcstr = i18n(_T(\"Menu\"), _T(\"ATTRIBUTE\"));\n\tsubMenu.ModifyMenu(3, MF_BYPOSITION, 3, cstr);\n\n\tsubMenu.Detach();\n\n\tif(m_bPaintWeekend)\n\t{\n\t\tmenu->CheckMenuItem(ID_PAINT_WEEKEND, MF_CHECKED);\n\t}\n\n\tif(m_LegendPositon.Compare(_T(\"nw\")) == 0)\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_NORTH_WEST, ID_SOUTH_EAST, ID_NORTH_WEST, MF_BYCOMMAND);\n\t}\n\telse if(m_LegendPositon.Compare(_T(\"ne\")) == 0)\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_NORTH_WEST, ID_SOUTH_EAST, ID_NORTH_EAST, MF_BYCOMMAND);\n\t}\n\telse if(m_LegendPositon.Compare(_T(\"sw\")) == 0)\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_NORTH_WEST, ID_SOUTH_EAST, ID_SOUTH_WEST, MF_BYCOMMAND);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_NORTH_WEST, ID_SOUTH_EAST, ID_SOUTH_EAST, MF_BYCOMMAND);\n\t}\n\n\tif(m_TimeFormat.Compare(_T(\"%m/%d\")) == 0)\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_MDHM, ID_DMY2, ID_MD, MF_BYCOMMAND);\n\t}\n\telse if(m_TimeFormat.Compare(_T(\"%y/%m/%d %H:%M\")) == 0)\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_MDHM, ID_DMY2, ID_YMDHM, MF_BYCOMMAND);\n\t}\n\telse if(m_TimeFormat.Compare(_T(\"%y/%m/%d\")) == 0)\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_MDHM, ID_DMY2, ID_YMD, MF_BYCOMMAND);\n\t}\n\telse if(m_TimeFormat.Compare(_T(\"%d/%m/%y\")) == 0)\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_MDHM, ID_DMY2, ID_DMY, MF_BYCOMMAND);\n\t}\n\telse if(m_TimeFormat.Compare(_T(\"%d/%m/%y %H:%M\")) == 0)\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_MDHM, ID_DMY2, ID_DMYHM, MF_BYCOMMAND);\n\t}\n\telse if(m_TimeFormat.Compare(_T(\"%d.%m.%y %H:%M\")) == 0)\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_MDHM, ID_DMY2, ID_DMYHM2, MF_BYCOMMAND);\n\t}\n\telse if(m_TimeFormat.Compare(_T(\"%d.%m.%y\")) == 0)\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_MDHM, ID_DMY2, ID_DMY2, MF_BYCOMMAND);\n\t}\n\telse\n\t{\n\t\tmenu->CheckMenuRadioItem(ID_MDHM, ID_DMY2, ID_MDHM, MF_BYCOMMAND);\n\t}\n\n\tswitch(m_MaxPlotPoint)\n\t{\n\tcase 100:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_100, MF_BYCOMMAND);break;\n\tcase 200:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_200, MF_BYCOMMAND);break;\n\tcase 300:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_300, MF_BYCOMMAND);break;\n\tcase 400:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_400, MF_BYCOMMAND);break;\n\tcase 500:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_500, MF_BYCOMMAND);break;\n\tcase 600:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_600, MF_BYCOMMAND);break;\n\tcase 700:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_700, MF_BYCOMMAND);break;\n\tcase 800:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_800, MF_BYCOMMAND);break;\n\tcase 900:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_900, MF_BYCOMMAND);break;\n\tcase 1000:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_1000, MF_BYCOMMAND);break;\n\tcase 2000:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_2000, MF_BYCOMMAND);break;\n\tcase 3000:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_3000, MF_BYCOMMAND);break;\n\tcase 4000:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_4000, MF_BYCOMMAND);break;\n\tcase 5000:menu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_5000, MF_BYCOMMAND);break;\n\tdefault:\n\t\tm_MaxPlotPoint = 0;\n\t\tmenu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, ID_POINT_ALL, MF_BYCOMMAND);\n\t\tbreak;\n\t}\n\n\tswitch(m_Attribute)\n\t{\n\tcase CAtaSmart::HDD_GENERAL: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_HDD, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_GENERAL: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_MTRON: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_MTRON, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_INDILINX: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_INDILINX, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_JMICRON: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_JMICRON, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_INTEL: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_INTEL, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_SAMSUNG: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SAMSUNG, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_SANDFORCE: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SANDFORCE, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_MICRON: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_MICRON, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_OCZ: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_OCZ, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_SEAGATE: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SEAGATE, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_WDC: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_WDC, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_PLEXTOR: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_PLEXTOR, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_SANDISK: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SANDISK, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_OCZ_VECTOR: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_OCZ_VECTOR, MF_BYCOMMAND);break;\n\tcase CAtaSmart::SSD_VENDOR_TOSHIBA: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_TOSHIBA, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_CORSAIR: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_CORSAIR, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_KINGSTON: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_KINGSTON, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_MICRON_MU03: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_MICRON_MU03, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_REALTEK: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_REALTEK, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_NVME: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_NVME, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SKHYNIX: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SKHYNIX, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_KIOXIA: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_KIOXIA, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SSSTC: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SSSTC, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_INTEL_DC: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_INTEL_DC, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_APACER: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_APACER, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SILICONMOTION: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SILICONMOTION, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_PHISON: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_PHISON, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_MARVELL: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_MARVELL, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_MAXIOTEK: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_MAXIOTEK, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_YMTC: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_YMTC, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SCY: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SCY, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SILICONMOTION_CVC: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SILICONMOTION_CVC, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_ADATA_INDUSTRIAL: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_ADATA_INDUSTRIAL, MF_BYCOMMAND); break;\n\n\tcase CAtaSmart::SSD_VENDOR_JMICRON_60X: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_JMICRON_60X, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_JMICRON_61X: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_JMICRON_61X, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_JMICRON_66X: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_JMICRON_66X, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SEAGATE_IRON_WOLF: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SEAGATE_IRON_WOLF, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SEAGATE_BARRA_CUDA: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SEAGATE_BARRA_CUDA, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SANDISK_GB: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SANDISK_GB, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_KINGSTON_SUV: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_KINGSTON_SUV, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_KINGSTON_KC600: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_KINGSTON_KC600, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_KINGSTON_DC500: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_KINGSTON_DC500, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_KINGSTON_SA400: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_KINGSTON_SA400, MF_BYCOMMAND); break;\n\n\tcase CAtaSmart::SSD_VENDOR_RECADATA: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_RECADATA, MF_BYCOMMAND); break;\n\n\tcase CAtaSmart::SSD_VENDOR_SANDISK_DELL: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SANDISK_DELL, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SANDISK_HP: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SANDISK_HP, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SANDISK_HP_VENUS: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SANDISK_HP_VENUS, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SANDISK_LENOVO: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SANDISK_LENOVO, MF_BYCOMMAND); break;\n\tcase CAtaSmart::SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS: menu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_SSD_SANDISK_LENOVO_HELEN_VENUS, MF_BYCOMMAND); break;\n\n\tdefault:\n\t\tm_Attribute = CAtaSmart::HDD_GENERAL;\n\t\tmenu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, ID_HDD, MF_BYCOMMAND);\n\t\tbreak;\n\t}\n\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nBOOL CGraphDlg::OnCommand(WPARAM wParam, LPARAM lParam)\n{\n\tif(GRAPH_DISK_INDEX <= wParam && wParam <= GRAPH_DISK_INDEX + (CAtaSmart::MAX_DISK + 1) * 100)\n\t{\n\t\t//int i = (int)(wParam - GRAPH_DISK_INDEX) / 100;\n\t\t//int j = (int)(wParam - GRAPH_DISK_INDEX) % 100;\n\n\t\tUpdateGraph();\n\t}\n\n\treturn CDHtmlDialogEx::OnCommand(wParam, lParam);\n}\n\ntime_t CGraphDlg::GetTimeT(CString time)\n{\n\tCString token;\n\tint currentPosition = 0;\n\tint index = 0;\n\ttm t = {0};\n\n\ttoken = time.Tokenize(_T(\" :/\"), currentPosition);\n\twhile(token != _T(\"\"))\n\t{\n\t\tswitch(index)\n\t\t{\n\t\tcase 0:\n\t\t\tt.tm_year = _ttoi(token) - 1900;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tt.tm_mon = _ttoi(token) - 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tt.tm_mday = _ttoi(token);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tt.tm_hour = _ttoi(token);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tt.tm_min = _ttoi(token);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tt.tm_sec = _ttoi(token);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ttoken = time.Tokenize(_T(\" :/\"), currentPosition);\n\t\tindex++;\n\t}\n\n\treturn mktime(&t) - (time_t)m_TimeZoneInformation.Bias * 60;\n}\n\nvoid CGraphDlg::OnGetMinMaxInfo(MINMAXINFO* lpMMI)\n{\n\tlpMMI->ptMinTrackSize.x = (LONG)(SIZE_X * m_ZoomRatio) + GetSystemMetrics(SM_CXFRAME) * 2;\n\tlpMMI->ptMinTrackSize.y = (LONG)(SIZE_Y * m_ZoomRatio) + GetSystemMetrics(SM_CYMENU) + GetSystemMetrics(SM_CYSIZEFRAME) * 2 + GetSystemMetrics(SM_CYCAPTION);\n\n\tCDHtmlDialogEx::OnGetMinMaxInfo(lpMMI);\n}\n\nvoid CGraphDlg::UpdateDialogSize()\n{\n\tChangeZoomType(m_ZoomType);\n\n\tif(GetPrivateProfileInt(_T(\"Setting\"), _T(\"GraphHeight\"), 0, m_Ini) > 0)\n\t{\n\t\tm_SizeY = GetPrivateProfileInt(_T(\"Setting\"), _T(\"GraphHeight\"), 0, m_Ini);\n\t}\n\telse\n\t{\n\t\tm_SizeY = SIZE_Y;\n\t}\n\tif(GetPrivateProfileInt(_T(\"Setting\"), _T(\"GraphWidth\"), 0, m_Ini) > 0)\n\t{\n\t\tm_SizeX = GetPrivateProfileInt(_T(\"Setting\"), _T(\"GraphWidth\"), 0, m_Ini);\n\t}\n\telse\n\t{\n\t\tm_SizeX = SIZE_X;\n\t}\n\n\tSetClientRect((DWORD)(m_SizeX * m_ZoomRatio), (DWORD)(m_SizeY * m_ZoomRatio), 1);\n}\n\nvoid CGraphDlg::OnSize(UINT nType, int cx, int cy)\n{\n\tCDHtmlMainDialog::OnSize(nType, cx, cy);\n\n\tif(m_bInitializing == FALSE)\n\t{\n\t\tRECT rect;\n\t\tCString cstr;\n\t\tGetClientRect(&rect);\n\t\tcstr.Format(_T(\"%d\"), (DWORD)(((double)rect.bottom - rect.top) / m_ZoomRatio));\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"GraphHeight\"), cstr, m_Ini);\t\n\t\tcstr.Format(_T(\"%d\"), (DWORD)(((double)rect.right - rect.left) / m_ZoomRatio));\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"GraphWidth\"), cstr, m_Ini);\n\t}\n}\n\nvoid CGraphDlg::OnExit()\n{\n\tOnCancel();\n}\n\n// Legend Position\nvoid CGraphDlg::OnNorthWest(){SetLegendPosition(ID_NORTH_WEST, _T(\"nw\"));}\nvoid CGraphDlg::OnNorthEast(){SetLegendPosition(ID_NORTH_EAST, _T(\"ne\"));}\nvoid CGraphDlg::OnSouthWest(){SetLegendPosition(ID_SOUTH_WEST, _T(\"sw\"));}\nvoid CGraphDlg::OnSouthEast(){SetLegendPosition(ID_SOUTH_EAST, _T(\"se\"));}\n\nvoid CGraphDlg::SetLegendPosition(DWORD id, CString position)\n{\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"LegendPosition\"), position, m_Ini);\n\tm_LegendPositon = position;\n\tUpdateGraph();\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_NORTH_WEST, ID_SOUTH_EAST, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CGraphDlg::OnMdhm()  {SetTimeFormat(ID_MDHM,   _T(\"%m/%d %H:%M\"));}\nvoid CGraphDlg::OnMd()    {SetTimeFormat(ID_MD,     _T(\"%m/%d\"));}\nvoid CGraphDlg::OnYmdhm() {SetTimeFormat(ID_YMDHM,  _T(\"%y/%m/%d %H:%M\"));}\nvoid CGraphDlg::OnYmd()   {SetTimeFormat(ID_YMD,    _T(\"%y/%m/%d\"));}\nvoid CGraphDlg::OnDmyhm() {SetTimeFormat(ID_DMYHM,  _T(\"%d/%m/%y %H:%M\"));}\nvoid CGraphDlg::OnDmy()   {SetTimeFormat(ID_DMY,    _T(\"%d/%m/%y\"));}\nvoid CGraphDlg::OnDmyhm2(){SetTimeFormat(ID_DMYHM2, _T(\"%d.%m.%y %H:%M\"));}\nvoid CGraphDlg::OnDmy2()  {SetTimeFormat(ID_DMY2,   _T(\"%d.%m.%y\"));}\n\nvoid CGraphDlg::SetTimeFormat(DWORD id, CString format)\n{\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"TimeFormat\"), format, m_Ini);\n\tm_TimeFormat = format;\n\tUpdateGraph();\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_MDHM, ID_DMY2, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CGraphDlg::OnPaintWeekend()\n{\n\tif(m_bPaintWeekend)\n\t{\n\t\tm_bPaintWeekend = FALSE;\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"PaintWeekend\"), _T(\"0\"), m_Ini);\n\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_PAINT_WEEKEND, MF_UNCHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\telse\n\t{\n\t\tm_bPaintWeekend = TRUE;\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"PaintWeekend\"), _T(\"1\"), m_Ini);\n\n\t\tCMenu *menu = GetMenu();\n\t\tmenu->CheckMenuItem(ID_PAINT_WEEKEND, MF_CHECKED);\n\t\tSetMenu(menu);\n\t\tDrawMenuBar();\n\t}\n\tUpdateGraph();\n}\n\nvoid CGraphDlg::OnPoint100(){SetPlotPoint(ID_POINT_100, 100);}\nvoid CGraphDlg::OnPoint200(){SetPlotPoint(ID_POINT_200, 200);}\nvoid CGraphDlg::OnPoint300(){SetPlotPoint(ID_POINT_300, 300);}\nvoid CGraphDlg::OnPoint400(){SetPlotPoint(ID_POINT_400, 400);}\nvoid CGraphDlg::OnPoint500(){SetPlotPoint(ID_POINT_500, 500);}\nvoid CGraphDlg::OnPoint600(){SetPlotPoint(ID_POINT_600, 600);}\nvoid CGraphDlg::OnPoint700(){SetPlotPoint(ID_POINT_700, 700);}\nvoid CGraphDlg::OnPoint800(){SetPlotPoint(ID_POINT_800, 800);}\nvoid CGraphDlg::OnPoint900(){SetPlotPoint(ID_POINT_900, 900);}\nvoid CGraphDlg::OnPoint1000(){SetPlotPoint(ID_POINT_1000, 1000);}\nvoid CGraphDlg::OnPoint2000(){SetPlotPoint(ID_POINT_2000, 2000);}\nvoid CGraphDlg::OnPoint3000(){SetPlotPoint(ID_POINT_3000, 3000);}\nvoid CGraphDlg::OnPoint4000(){SetPlotPoint(ID_POINT_4000, 4000);}\nvoid CGraphDlg::OnPoint5000(){SetPlotPoint(ID_POINT_5000, 5000);}\nvoid CGraphDlg::OnPointAll(){SetPlotPoint(ID_POINT_ALL, 0);}\n\nvoid CGraphDlg::SetPlotPoint(DWORD id, DWORD point)\n{\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), point);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"MaxPlotPoint\"), cstr, m_Ini);\n\tm_MaxPlotPoint = point;\n\tUpdateGraph();\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_POINT_100, ID_POINT_ALL, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n}\n\nvoid CGraphDlg::OnCustomize()\n{\n\tm_OptionDlg = new COptionDlg(this);\n\tm_OptionDlg->Create(COptionDlg::IDD, m_OptionDlg, ID_CUSTOMIZE, this);\n}\n\nvoid CGraphDlg::UpdateBkImage()\n{\n\tTCHAR str[256];\n\tCString cstr;\n\tGetPrivateProfileStringFx(_T(\"Customize\"), _T(\"GraphBkImage\"), _T(\"\"), str, 256, m_Ini);\n\tcstr = str;\n\tcstr.Replace(_T(\"\\\\\"), _T(\"/\"));\n\tif(cstr.IsEmpty())\n\t{\n\t\tcstr = _T(\"image/background.png\");\n\t}\n\tCallScript(_T(\"changeBackgroundImage\"), _T(\"url(\") + cstr + _T(\")\"));\n}\n\nLRESULT CGraphDlg::OnUpdateBkImage(WPARAM wParam, LPARAM lParam)\n{\n\tUpdateBkImage();\n\treturn 0;\n}\n\nLRESULT CGraphDlg::OnUpdateLineColor(WPARAM wParam, LPARAM lParam)\n{\n\tUpdateGraph();\n\treturn 0;\n}\n\nvoid CGraphDlg::OnHdd(){SetAttribute(ID_HDD, CAtaSmart::HDD_GENERAL);}\nvoid CGraphDlg::OnSsd(){SetAttribute(ID_SSD, CAtaSmart::SSD_GENERAL);}\nvoid CGraphDlg::OnSsdMtron(){SetAttribute(ID_SSD_MTRON, CAtaSmart::SSD_VENDOR_MTRON);}\nvoid CGraphDlg::OnSsdIndilinx(){SetAttribute(ID_SSD_INDILINX, CAtaSmart::SSD_VENDOR_INDILINX);}\nvoid CGraphDlg::OnSsdJmicron(){SetAttribute(ID_SSD_JMICRON, CAtaSmart::SSD_VENDOR_JMICRON);}\nvoid CGraphDlg::OnSsdIntel(){SetAttribute(ID_SSD_INTEL, CAtaSmart::SSD_VENDOR_INTEL);}\nvoid CGraphDlg::OnSsdSamsung(){SetAttribute(ID_SSD_SAMSUNG, CAtaSmart::SSD_VENDOR_SAMSUNG);}\nvoid CGraphDlg::OnSsdSandforce(){SetAttribute(ID_SSD_SANDFORCE, CAtaSmart::SSD_VENDOR_SANDFORCE);}\nvoid CGraphDlg::OnSsdMicron(){SetAttribute(ID_SSD_MICRON, CAtaSmart::SSD_VENDOR_MICRON);}\nvoid CGraphDlg::OnSsdOcz(){SetAttribute(ID_SSD_OCZ, CAtaSmart::SSD_VENDOR_OCZ);}\n\nvoid CGraphDlg::OnSsdSeagate() { SetAttribute(ID_SSD_SEAGATE, CAtaSmart::SSD_VENDOR_SEAGATE); }\nvoid CGraphDlg::OnSsdWdc() { SetAttribute(ID_SSD_WDC, CAtaSmart::SSD_VENDOR_WDC); }\n\nvoid CGraphDlg::OnSsdPlextor(){SetAttribute(ID_SSD_PLEXTOR, CAtaSmart::SSD_VENDOR_PLEXTOR);}\nvoid CGraphDlg::OnSsdSanDisk(){SetAttribute(ID_SSD_SANDISK, CAtaSmart::SSD_VENDOR_SANDISK);}\nvoid CGraphDlg::OnSsdOczVector(){SetAttribute(ID_SSD_OCZ_VECTOR, CAtaSmart::SSD_VENDOR_OCZ_VECTOR);}\n\nvoid CGraphDlg::OnSsdToshiba() { SetAttribute(ID_SSD_TOSHIBA, CAtaSmart::SSD_VENDOR_TOSHIBA); }\nvoid CGraphDlg::OnSsdCorsair() { SetAttribute(ID_SSD_CORSAIR, CAtaSmart::SSD_VENDOR_CORSAIR); }\nvoid CGraphDlg::OnSsdKingston() { SetAttribute(ID_SSD_KINGSTON, CAtaSmart::SSD_VENDOR_KINGSTON); }\nvoid CGraphDlg::OnSsdMicronMU03() { SetAttribute(ID_SSD_MICRON_MU03, CAtaSmart::SSD_VENDOR_MICRON_MU03); }\n\nvoid CGraphDlg::OnSsdRealtek(){SetAttribute(ID_SSD_REALTEK, CAtaSmart::SSD_VENDOR_REALTEK);}\nvoid CGraphDlg::OnSsdNVMe(){SetAttribute(ID_SSD_NVME, CAtaSmart::SSD_VENDOR_NVME);}\n\nvoid CGraphDlg::OnSsdSkHynix() { SetAttribute(ID_SSD_SKHYNIX, CAtaSmart::SSD_VENDOR_SKHYNIX); }\nvoid CGraphDlg::OnSsdKioxia() { SetAttribute(ID_SSD_KIOXIA, CAtaSmart::SSD_VENDOR_KIOXIA); }\nvoid CGraphDlg::OnSsdSsstc() { SetAttribute(ID_SSD_SSSTC, CAtaSmart::SSD_VENDOR_SSSTC); }\nvoid CGraphDlg::OnSsdIntelDc() { SetAttribute(ID_SSD_INTEL_DC, CAtaSmart::SSD_VENDOR_INTEL_DC); }\nvoid CGraphDlg::OnSsdApacer() { SetAttribute(ID_SSD_APACER, CAtaSmart::SSD_VENDOR_APACER); }\nvoid CGraphDlg::OnSsdSiliconMotion() { SetAttribute(ID_SSD_SILICONMOTION, CAtaSmart::SSD_VENDOR_SILICONMOTION); }\nvoid CGraphDlg::OnSsdPhison() { SetAttribute(ID_SSD_PHISON, CAtaSmart::SSD_VENDOR_PHISON); }\nvoid CGraphDlg::OnSsdMarvell() { SetAttribute(ID_SSD_MARVELL, CAtaSmart::SSD_VENDOR_MARVELL); }\nvoid CGraphDlg::OnSsdMaxiotek() { SetAttribute(ID_SSD_MAXIOTEK, CAtaSmart::SSD_VENDOR_MAXIOTEK); }\nvoid CGraphDlg::OnSsdYmtc() { SetAttribute(ID_SSD_YMTC, CAtaSmart::SSD_VENDOR_YMTC); }\nvoid CGraphDlg::OnSsdScy() { SetAttribute(ID_SSD_SCY, CAtaSmart::SSD_VENDOR_SCY); }\nvoid CGraphDlg::OnSsdRecadata() { SetAttribute(ID_SSD_RECADATA, CAtaSmart::SSD_VENDOR_RECADATA); }\n\nvoid CGraphDlg::OnSsdSanDiskDell() { SetAttribute(ID_SSD_SANDISK_DELL, CAtaSmart::SSD_VENDOR_SANDISK_DELL); }\nvoid CGraphDlg::OnSsdSanDiskHp() { SetAttribute(ID_SSD_SANDISK_HP, CAtaSmart::SSD_VENDOR_SANDISK_HP); }\nvoid CGraphDlg::OnSsdSanDiskHpVenus() { SetAttribute(ID_SSD_SANDISK_HP_VENUS, CAtaSmart::SSD_VENDOR_SANDISK_HP_VENUS); }\nvoid CGraphDlg::OnSsdSanDiskLenovo() { SetAttribute(ID_SSD_SANDISK_LENOVO, CAtaSmart::SSD_VENDOR_SANDISK_LENOVO); }\nvoid CGraphDlg::OnSsdSanDiskLenovoHelenVenus() { SetAttribute(ID_SSD_SANDISK_LENOVO_HELEN_VENUS, CAtaSmart::SSD_VENDOR_SANDISK_LENOVO_HELEN_VENUS); }\n\nvoid CGraphDlg::OnSsdJmicron60x() { SetAttribute(ID_SSD_JMICRON_60X, CAtaSmart::SSD_VENDOR_JMICRON_60X); }\nvoid CGraphDlg::OnSsdJmicron61x() { SetAttribute(ID_SSD_JMICRON_61X, CAtaSmart::SSD_VENDOR_JMICRON_61X); }\nvoid CGraphDlg::OnSsdJmicron66x() { SetAttribute(ID_SSD_JMICRON_66X, CAtaSmart::SSD_VENDOR_JMICRON_66X); }\nvoid CGraphDlg::OnSsdSeagateIronWolf() { SetAttribute(ID_SSD_SEAGATE_IRON_WOLF, CAtaSmart::SSD_VENDOR_SEAGATE_IRON_WOLF); }\nvoid CGraphDlg::OnSsdSeagateBarraCuda() { SetAttribute(ID_SSD_SEAGATE_BARRA_CUDA, CAtaSmart::SSD_VENDOR_SEAGATE_BARRA_CUDA); }\nvoid CGraphDlg::OnSsdSanDiskGb() { SetAttribute(ID_SSD_SANDISK_GB, CAtaSmart::SSD_VENDOR_SANDISK_GB); };\nvoid CGraphDlg::OnSsdKingstonSuv() { SetAttribute(ID_SSD_KINGSTON_SUV, CAtaSmart::SSD_VENDOR_KINGSTON_SUV); }\nvoid CGraphDlg::OnSsdKingstonKC600() { SetAttribute(ID_SSD_KINGSTON_KC600, CAtaSmart::SSD_VENDOR_KINGSTON_KC600); }\nvoid CGraphDlg::OnSsdKingstonDC500() { SetAttribute(ID_SSD_KINGSTON_DC500, CAtaSmart::SSD_VENDOR_KINGSTON_DC500); }\nvoid CGraphDlg::OnSsdKingstonSA400() { SetAttribute(ID_SSD_KINGSTON_SA400, CAtaSmart::SSD_VENDOR_KINGSTON_SA400); }\n\nvoid CGraphDlg::OnSsdSiliconMotionCVC() { SetAttribute(ID_SSD_SILICONMOTION_CVC, CAtaSmart::SSD_VENDOR_SILICONMOTION_CVC); }\nvoid CGraphDlg::OnSsdAdataIndustrial() { SetAttribute(ID_SSD_ADATA_INDUSTRIAL, CAtaSmart::SSD_VENDOR_ADATA_INDUSTRIAL); }\n\n\nvoid CGraphDlg::SetAttribute(DWORD id, DWORD type)\n{\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), type);\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"Attribute\"), cstr, m_Ini);\n\tif(type <= CAtaSmart::SSD_VENDOR_MAX)\n\t{\n\t\tm_Attribute = type;\n\t}\n\telse\n\t{\n\t\tm_Attribute = CAtaSmart::HDD_GENERAL;\n\t}\n\n\tCMenu *menu = GetMenu();\n\tmenu->CheckMenuRadioItem(ID_HDD, ID_SSD_MAX, id, MF_BYCOMMAND);\n\tSetMenu(menu);\n\tDrawMenuBar();\n\n\tInitMenuBar();\n}\n\nCString CGraphDlg::GetModelSerial(CString &model, CString &serialNumber)\n{\n\tCString modelSerial;\n\tmodelSerial = model + serialNumber;\n\tmodelSerial.Replace(_T(\"\\\\\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"/\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\":\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"*\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"?\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"\\\"\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"<\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\">\"), _T(\"\"));\n\tmodelSerial.Replace(_T(\"|\"), _T(\"\"));\n\n\treturn modelSerial;\n}"
        },
        {
          "name": "GraphDlg.h",
          "type": "blob",
          "size": 7.779296875,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n\n#include \"AtaSmart.h\"\n#include \"OptionDlg.h\"\n\n// Task Tray\nenum\n{\n\tMY_UPDATE_BG_IMAGE = (WM_APP + 0x1100),\n\tMY_UPDATE_LINE_COLOR,\n};\n\nclass CGraphDlg : public CDHtmlMainDialog\n{\n\tDECLARE_DYNCREATE(CGraphDlg)\n\n\tstatic const int SIZE_X = 640;\n\tstatic const int SIZE_Y = 480;\n\npublic:\n\tCGraphDlg(CWnd* pParent = NULL, int defaultDisk = -1);\n\tvirtual ~CGraphDlg();\n\n\tCString\tm_SmartDir;\n\tBOOL m_bSmartEnglish;\n\n\tint m_SizeX;\n\tint m_SizeY;\n\t\n\tBOOL m_bGraph[CAtaSmart::MAX_DISK];\n\tCOLORREF m_LineColor[CAtaSmart::MAX_DISK + 1];\n\tCOLORREF m_DefaultLineColor[CAtaSmart::MAX_DISK + 1];\n\n\tCString m_LiDisk[CAtaSmart::MAX_DISK];\n\n\tDWORD m_AttributeId;\n\tint m_DefaultDisk[CAtaSmart::MAX_DISK];\n\tint m_DetectedDisk;\n\n\tDWORD m_IeVersion;\n\n\tCString m_Model[CAtaSmart::MAX_DISK];\n\tCString m_ModelEscape[CAtaSmart::MAX_DISK];\n\tCString m_Serial[CAtaSmart::MAX_DISK];\n\tCString m_Drive[CAtaSmart::MAX_DISK];\n\n\tCOptionDlg* m_OptionDlg;\n\tCString m_Title;\n\tCString m_SelectAttributeId;\n\tlong m_SelectAttributeIdCtrl;\n\n\tCString m_LegendPositon;\n\tCString m_TimeFormat;\n\n\tenum { IDD = IDD_GRAPH, IDH = IDR_HTML_DUMMY };\n\nprotected:\n\tHICON m_hIcon;\n\tHICON m_hIconMini;\n\ttime_t GetTimeT(CString time);\n\tTIME_ZONE_INFORMATION m_TimeZoneInformation;\n\n\tvirtual void DoDataExchange(CDataExchange* pDX);\n\tvirtual BOOL OnInitDialog();\n\tvirtual void InitDialogComplete();\n\tvirtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);\n\n\tvoid UpdateDialogSize();\n\n\tHRESULT OnAllOn(IHTMLElement *pElement);\n\tHRESULT OnAllOff(IHTMLElement *pElement);\n\tHRESULT OnReset(IHTMLElement *pElement);\n\n\tHRESULT OnDisk0(IHTMLElement *pElement);\n\tHRESULT OnDisk1(IHTMLElement *pElement);\n\tHRESULT OnDisk2(IHTMLElement *pElement);\n\tHRESULT OnDisk3(IHTMLElement *pElement);\n\tHRESULT OnDisk4(IHTMLElement *pElement);\n\tHRESULT OnDisk5(IHTMLElement *pElement);\n\tHRESULT OnDisk6(IHTMLElement *pElement);\n\tHRESULT OnDisk7(IHTMLElement *pElement);\n\tHRESULT OnDisk8(IHTMLElement *pElement);\n\tHRESULT OnDisk9(IHTMLElement *pElement);\n\tHRESULT OnDisk10(IHTMLElement *pElement);\n\tHRESULT OnDisk11(IHTMLElement *pElement);\n\tHRESULT OnDisk12(IHTMLElement *pElement);\n\tHRESULT OnDisk13(IHTMLElement *pElement);\n\tHRESULT OnDisk14(IHTMLElement *pElement);\n\tHRESULT OnDisk15(IHTMLElement *pElement);\n\tHRESULT OnDisk16(IHTMLElement *pElement);\n\tHRESULT OnDisk17(IHTMLElement *pElement);\n\tHRESULT OnDisk18(IHTMLElement *pElement);\n\tHRESULT OnDisk19(IHTMLElement *pElement);\n\tHRESULT OnDisk20(IHTMLElement *pElement);\n\tHRESULT OnDisk21(IHTMLElement *pElement);\n\tHRESULT OnDisk22(IHTMLElement *pElement);\n\tHRESULT OnDisk23(IHTMLElement *pElement);\n\tHRESULT OnDisk24(IHTMLElement *pElement);\n\tHRESULT OnDisk25(IHTMLElement *pElement);\n\tHRESULT OnDisk26(IHTMLElement *pElement);\n\tHRESULT OnDisk27(IHTMLElement *pElement);\n\tHRESULT OnDisk28(IHTMLElement *pElement);\n\tHRESULT OnDisk29(IHTMLElement *pElement);\n\tHRESULT OnDisk30(IHTMLElement *pElement);\n\tHRESULT OnDisk31(IHTMLElement *pElement);\n\tHRESULT OnDisk32(IHTMLElement *pElement);\n\tHRESULT OnDisk33(IHTMLElement *pElement);\n\tHRESULT OnDisk34(IHTMLElement *pElement);\n\tHRESULT OnDisk35(IHTMLElement *pElement);\n\tHRESULT OnDisk36(IHTMLElement *pElement);\n\tHRESULT OnDisk37(IHTMLElement *pElement);\n\tHRESULT OnDisk38(IHTMLElement *pElement);\n\tHRESULT OnDisk39(IHTMLElement *pElement);\n\tHRESULT OnDisk40(IHTMLElement *pElement);\n\tHRESULT OnDisk41(IHTMLElement *pElement);\n\tHRESULT OnDisk42(IHTMLElement *pElement);\n\tHRESULT OnDisk43(IHTMLElement *pElement);\n\tHRESULT OnDisk44(IHTMLElement *pElement);\n\tHRESULT OnDisk45(IHTMLElement *pElement);\n\tHRESULT OnDisk46(IHTMLElement *pElement);\n\tHRESULT OnDisk47(IHTMLElement *pElement);\n\tHRESULT OnDisk48(IHTMLElement *pElement);\n\tHRESULT OnDisk49(IHTMLElement *pElement);\n\tHRESULT OnDisk50(IHTMLElement *pElement);\n\tHRESULT OnDisk51(IHTMLElement *pElement);\n\tHRESULT OnDisk52(IHTMLElement *pElement);\n\tHRESULT OnDisk53(IHTMLElement *pElement);\n\tHRESULT OnDisk54(IHTMLElement *pElement);\n\tHRESULT OnDisk55(IHTMLElement *pElement);\n\tHRESULT OnDisk56(IHTMLElement *pElement);\n\tHRESULT OnDisk57(IHTMLElement *pElement);\n\tHRESULT OnDisk58(IHTMLElement *pElement);\n\tHRESULT OnDisk59(IHTMLElement *pElement);\n\tHRESULT OnDisk60(IHTMLElement *pElement);\n\tHRESULT OnDisk61(IHTMLElement *pElement);\n\tHRESULT OnDisk62(IHTMLElement *pElement);\n\tHRESULT OnDisk63(IHTMLElement *pElement);\n\n\n\tHRESULT OnSelectAttributeId(IHTMLElement *pElement);\n\n\tvoid InitMenu();\n\tvoid InitMenuBar();\n\tBOOL UpdateGraph();\n\tBOOL CheckDisk(DWORD disk);\n\tvoid SetLegendPosition(DWORD id, CString position);\n\tvoid SetTimeFormat(DWORD id, CString format);\n\tvoid SetPlotPoint(DWORD id, DWORD point);\n\tvoid SetAttribute(DWORD id, DWORD type);\n\tvoid InitVars(int defaultDisk);\n\tvoid UpdateColor();\n\tvoid UpdateBkImage();\n\n\tCString GetModelSerial(CString &model, CString &serialNumber);\n\n\tBOOL m_bFahrenheit;\n\tBOOL m_bPaintWeekend;\n\tDWORD m_MaxPlotPoint;\n\tDWORD m_Attribute;\n\n\tafx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);\n\tafx_msg void OnPaint();\n\tafx_msg HCURSOR OnQueryDragIcon();\n\tafx_msg LRESULT OnUpdateBkImage(WPARAM wParam, LPARAM lParam);\n\tafx_msg LRESULT OnUpdateLineColor(WPARAM wParam, LPARAM lParam);\n\n\tDECLARE_MESSAGE_MAP()\n\n\tDECLARE_DHTML_EVENT_MAP()\n\npublic:\n\tCOLORREF GetLineColor(DWORD index);\n\n\tafx_msg void OnExit();\n\tafx_msg void OnNorthWest();\n\tafx_msg void OnNorthEast();\n\tafx_msg void OnSouthWest();\n\tafx_msg void OnSouthEast();\n\tafx_msg void OnPaintWeekend();\n\tafx_msg void OnPoint100();\n\tafx_msg void OnPoint200();\n\tafx_msg void OnPoint300();\n\tafx_msg void OnPoint400();\n\tafx_msg void OnPoint500();\n\tafx_msg void OnPoint600();\n\tafx_msg void OnPoint700();\n\tafx_msg void OnPoint800();\n\tafx_msg void OnPoint900();\n\tafx_msg void OnPoint1000();\n\tafx_msg void OnPoint2000();\n\tafx_msg void OnPoint3000();\n\tafx_msg void OnPoint4000();\n\tafx_msg void OnPoint5000();\n\tafx_msg void OnPointAll();\n\tafx_msg void OnCustomize();\n\tafx_msg void OnMdhm();\n\tafx_msg void OnMd();\n\tafx_msg void OnYmdhm();\n\tafx_msg void OnYmd();\n\tafx_msg void OnDmyhm();\n\tafx_msg void OnDmy();\n\tafx_msg void OnDmyhm2();\n\tafx_msg void OnDmy2();\n\n\tafx_msg void OnSize(UINT nType, int cx, int cy);\n\tafx_msg void OnHdd();\n\tafx_msg void OnSsd();\n\tafx_msg void OnSsdMtron();\n\tafx_msg void OnSsdIndilinx();\n\tafx_msg void OnSsdJmicron();\n\tafx_msg void OnSsdIntel();\n\tafx_msg void OnSsdSamsung();\n\tafx_msg void OnSsdSandforce();\n\tafx_msg void OnSsdMicron();\n\tafx_msg void OnSsdOcz();\n\tafx_msg void OnSsdSeagate();\n\tafx_msg void OnSsdWdc();\n\tafx_msg void OnSsdPlextor();\n\tafx_msg void OnSsdSanDisk();\n\tafx_msg void OnSsdOczVector();\n\tafx_msg void OnSsdToshiba();\n\tafx_msg void OnSsdCorsair();\n\tafx_msg void OnSsdKingston();\n\tafx_msg void OnSsdMicronMU03();\n\tafx_msg void OnSsdRealtek();\n\tafx_msg void OnSsdNVMe();\n\tafx_msg void OnSsdSkHynix();\n\tafx_msg void OnSsdKioxia();\n\tafx_msg void OnSsdSsstc();\n\tafx_msg void OnSsdIntelDc();\n\tafx_msg void OnSsdApacer();\n\tafx_msg void OnSsdSiliconMotion();\n\tafx_msg void OnSsdPhison();\n\tafx_msg void OnSsdMarvell();\n\tafx_msg void OnSsdMaxiotek();\n\tafx_msg void OnSsdYmtc();\n\tafx_msg void OnSsdScy();\n\tafx_msg void OnSsdRecadata();\n\tafx_msg void OnSsdSanDiskDell();\n\tafx_msg void OnSsdSanDiskHp();\n\tafx_msg void OnSsdSanDiskHpVenus();\n\tafx_msg void OnSsdSanDiskLenovo();\n\tafx_msg void OnSsdSanDiskLenovoHelenVenus();\n\n\tafx_msg void OnSsdJmicron60x();\n\tafx_msg void OnSsdJmicron61x();\n\tafx_msg void OnSsdJmicron66x();\n\tafx_msg void OnSsdSeagateIronWolf();\n\tafx_msg void OnSsdSeagateBarraCuda();\n\tafx_msg void OnSsdSanDiskGb();\n\tafx_msg void OnSsdKingstonSuv();\n\tafx_msg void OnSsdKingstonKC600();\n\tafx_msg void OnSsdKingstonDC500();\n\tafx_msg void OnSsdKingstonSA400();\n\n\tafx_msg void OnSsdSiliconMotionCVC();\n\tafx_msg void OnSsdAdataIndustrial();\n};\n"
        },
        {
          "name": "HealthDlg.cpp",
          "type": "blob",
          "size": 16.064453125,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n#include \"HealthDlg.h\"\n\nstatic CDiskInfoDlg* p;\n\nIMPLEMENT_DYNAMIC(CHealthDlg, CDialog)\n\nCHealthDlg::CHealthDlg(CWnd* pParent /*=NULL*/)\n\t: CDialogFx(CHealthDlg::IDD, pParent)\n{\n\tp = (CDiskInfoDlg*)pParent;\n\n\tm_ZoomType = p->GetZoomType();\n\tm_FontFace = p->GetFontFace();\n\tm_FontScale = p->GetFontScale();\n\tm_FontRatio = p->GetFontRatio();\n\tm_FontRender = p->GetFontRender();\n\tm_CurrentLangPath = p->GetCurrentLangPath();\n\tm_DefaultLangPath = p->GetDefaultLangPath();\n\tm_ThemeDir = p->GetThemeDir();\n\tm_CurrentTheme = p->GetCurrentTheme();\n\tm_DefaultTheme = p->GetDefaultTheme();\n\tm_Ini = p->GetIniPath();\n}\n\nCHealthDlg::~CHealthDlg()\n{\n}\n\nvoid CHealthDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogFx::DoDataExchange(pDX);\n\n\tDDX_Text(pDX, IDC_VALUE_05, m_Value05);\n\tDDX_Text(pDX, IDC_VALUE_C5, m_ValueC5);\n\tDDX_Text(pDX, IDC_VALUE_C6, m_ValueC6);\n\tDDX_Text(pDX, IDC_VALUE_FF, m_ValueFF);\n\tDDX_Text(pDX, IDC_VALUE_05X, m_Value05X);\n\tDDX_Text(pDX, IDC_VALUE_C5X, m_ValueC5X);\n\tDDX_Text(pDX, IDC_VALUE_C6X, m_ValueC6X);\n\tDDX_Text(pDX, IDC_VALUE_FFX, m_ValueFFX);\n\tDDX_Text(pDX, IDC_LABEL_05, m_Label05);\n\tDDX_Text(pDX, IDC_LABEL_C5, m_LabelC5);\n\tDDX_Text(pDX, IDC_LABEL_C6, m_LabelC6);\n\tDDX_Text(pDX, IDC_LABEL_FF, m_LabelFF);\n\n\tDDX_Control(pDX, IDC_SCROLLBAR_05, m_CtrlScrollbar05);\n\tDDX_Control(pDX, IDC_SCROLLBAR_C5, m_CtrlScrollbarC5);\n\tDDX_Control(pDX, IDC_SCROLLBAR_C6, m_CtrlScrollbarC6);\n\tDDX_Control(pDX, IDC_SCROLLBAR_FF, m_CtrlScrollbarFF);\n\tDDX_Control(pDX, IDC_VALUE_05, m_CtrlValue05);\n\tDDX_Control(pDX, IDC_VALUE_C5, m_CtrlValueC5);\n\tDDX_Control(pDX, IDC_VALUE_C6, m_CtrlValueC6);\n\tDDX_Control(pDX, IDC_VALUE_FF, m_CtrlValueFF);\n\tDDX_Control(pDX, IDC_VALUE_05X, m_CtrlValue05X);\n\tDDX_Control(pDX, IDC_VALUE_C5X, m_CtrlValueC5X);\n\tDDX_Control(pDX, IDC_VALUE_C6X, m_CtrlValueC6X);\n\tDDX_Control(pDX, IDC_VALUE_FFX, m_CtrlValueFFX);\n\tDDX_Control(pDX, IDC_LABEL_05, m_CtrlLabel05);\n\tDDX_Control(pDX, IDC_LABEL_C5, m_CtrlLabelC5);\n\tDDX_Control(pDX, IDC_LABEL_C6, m_CtrlLabelC6);\n\tDDX_Control(pDX, IDC_LABEL_FF, m_CtrlLabelFF);\n\tDDX_Control(pDX, IDC_SELECT_DISK, m_CtrlSelectDisk);\n\tDDX_Control(pDX, IDC_APPLY, m_CtrlApply);\n\tDDX_Control(pDX, IDC_DEFAULT, m_CtrlDefault);\n}\n\n\nBEGIN_MESSAGE_MAP(CHealthDlg, CDialogFx)\n\tON_WM_HSCROLL()\n\tON_BN_CLICKED(IDC_APPLY, &CHealthDlg::OnApply)\n\tON_BN_CLICKED(IDC_DEFAULT, &CHealthDlg::OnDefault)\n\tON_CBN_SELCHANGE(IDC_SELECT_DISK, &CHealthDlg::OnCbnSelchangeSelectDisk)\nEND_MESSAGE_MAP()\n\nBOOL CHealthDlg::OnInitDialog()\n{\n\tCDialogFx::OnInitDialog();\n\n\tSetWindowTitle(i18n(_T(\"WindowTitle\"), _T(\"HEALTH_STATUS_SETTING\"))\n\t\t+ _T(\" - \") + i18n(_T(\"HealthStatus\"), _T(\"THRESHOLD_OF_CAUTION\"))\n\t\t+ _T(\" (\") + i18n(_T(\"Dialog\"), _T(\"LIST_RAW_VALUES\")) + _T(\")\"));\n\n\tm_CtrlScrollbar05.SetScrollRange(0x00, 0xFF);\n\tm_CtrlScrollbarC5.SetScrollRange(0x00, 0xFF);\n\tm_CtrlScrollbarC6.SetScrollRange(0x00, 0xFF);\n\tm_CtrlScrollbarFF.SetScrollRange(0x00, 0x63);\n\n\tm_bShowWindow = TRUE;\n\n\tInitLang();\n\tInitSelectDisk();\n\n\tUpdateDialogSize();\n\n\tCenterWindow();\n\tShowWindow(SW_SHOW);\n\n\tif (p->m_Ata.vars.GetCount() == 0)\n\t{\n\t\tm_CtrlSelectDisk.EnableWindow(FALSE);\n\n\t\tm_CtrlScrollbar05.EnableWindow(FALSE);\n\t\tm_CtrlScrollbarC5.EnableWindow(FALSE);\n\t\tm_CtrlScrollbarC6.EnableWindow(FALSE);\n\t\tm_CtrlScrollbarFF.EnableWindow(FALSE);\n\n\t\tm_CtrlLabel05.EnableWindow(FALSE);\n\t\tm_CtrlLabelC5.EnableWindow(FALSE);\n\t\tm_CtrlLabelC6.EnableWindow(FALSE);\n\t\tm_CtrlLabelFF.EnableWindow(FALSE);\n\n\t\tm_CtrlValue05.EnableWindow(FALSE);\n\t\tm_CtrlValueC5.EnableWindow(FALSE);\n\t\tm_CtrlValueC6.EnableWindow(FALSE);\n\t\tm_CtrlValueFF.EnableWindow(FALSE);\n\n\t\tm_CtrlValue05X.EnableWindow(FALSE);\n\t\tm_CtrlValueC5X.EnableWindow(FALSE);\n\t\tm_CtrlValueC6X.EnableWindow(FALSE);\n\t\tm_CtrlValueFFX.EnableWindow(FALSE);\n\n\t\tm_CtrlApply.EnableWindow(FALSE);\n\t\tm_CtrlDefault.EnableWindow(FALSE);\n\t}\n\n\treturn TRUE;\n}\n\nvoid CHealthDlg::UpdateDialogSize()\n{\n\tCDialogFx::UpdateDialogSize();\n\n\tChangeZoomType(m_ZoomType);\n\tSetClientSize(SIZE_X, SIZE_Y, m_ZoomRatio);\n\tUpdateBackground(FALSE, m_bDarkMode);\n\n\tm_CtrlScrollbar05.MoveWindow((int)(16 * m_ZoomRatio), (int)( 72 * m_ZoomRatio), (int)(280 * m_ZoomRatio), (int)(20 * m_ZoomRatio));\n\tm_CtrlScrollbarC5.MoveWindow((int)(16 * m_ZoomRatio), (int)(128 * m_ZoomRatio), (int)(280 * m_ZoomRatio), (int)(20 * m_ZoomRatio));\n\tm_CtrlScrollbarC6.MoveWindow((int)(16 * m_ZoomRatio), (int)(184 * m_ZoomRatio), (int)(280 * m_ZoomRatio), (int)(20 * m_ZoomRatio));\n\tm_CtrlScrollbarFF.MoveWindow((int)(16 * m_ZoomRatio), (int)(240 * m_ZoomRatio), (int)(280 * m_ZoomRatio), (int)(20 * m_ZoomRatio));\n\n\tm_CtrlLabel05.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlLabelC5.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlLabelC6.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlLabelFF.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\n\tm_CtrlValue05.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlValueC5.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlValueC6.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlValueFF.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\n\tm_CtrlValue05X.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlValueC5X.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlValueC6X.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlValueFFX.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\n\tm_CtrlLabel05.InitControl(8,  44, 384, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, CStaticFx::Border::UNDERLINE);\n\tm_CtrlLabelC5.InitControl(8, 100, 384, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, CStaticFx::Border::UNDERLINE);\n\tm_CtrlLabelC6.InitControl(8, 156, 384, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, CStaticFx::Border::UNDERLINE);\n\tm_CtrlLabelFF.InitControl(8, 212, 384, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, CStaticFx::Border::UNDERLINE);\n\n\tm_CtrlValue05.InitControl(300,  72, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlValueC5.InitControl(300, 128, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlValueC6.InitControl(300, 184, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlValueFF.InitControl(300, 240, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\n\tm_CtrlValue05X.InitControl(344,  72, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlValueC5X.InitControl(344, 128, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlValueC6X.InitControl(344, 184, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlValueFFX.InitControl(344, 240, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\n\tm_CtrlApply.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlDefault.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\n\tm_CtrlApply.InitControl(220, 272, 160, 24, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlDefault.InitControl(20, 272, 160, 24, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, FALSE);\n\n\tm_CtrlSelectDisk.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlSelectDisk.InitControl(8, 8, 384, 40, m_ZoomRatio, &m_BkDC, NULL, 0, ES_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, RGB(255, 255, 255), RGB(160, 220, 255), RGB(255, 255, 255), 0);\n\tm_CtrlSelectDisk.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\n\tm_CtrlValue05.SetDrawFrame(TRUE);\n\tm_CtrlValueC5.SetDrawFrame(TRUE);\n\tm_CtrlValueC6.SetDrawFrame(TRUE);\n\tm_CtrlValueFF.SetDrawFrame(TRUE);\n\tm_CtrlValue05X.SetDrawFrame(TRUE);\n\tm_CtrlValueC5X.SetDrawFrame(TRUE);\n\tm_CtrlValueC6X.SetDrawFrame(TRUE);\n\tm_CtrlValueFFX.SetDrawFrame(TRUE);\n\n\tm_CtrlApply.SetHandCursor();\n\tm_CtrlDefault.SetHandCursor();\n\n\tSetDarkModeControl(m_CtrlApply.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_CtrlDefault.GetSafeHwnd(), m_bDarkMode);\n\n\tSetDarkModeControl(m_CtrlScrollbar05.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_CtrlScrollbarC5.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_CtrlScrollbarC6.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_CtrlScrollbarFF.GetSafeHwnd(), m_bDarkMode);\n\n\t// SetLayeredWindow(m_CtrlSelectDisk.GetListHwnd(), m_ComboAlpha);\n\tfor (int i = -1; i < m_CtrlSelectDisk.GetCount(); i++)\n\t{\n\t\tm_CtrlSelectDisk.SetItemHeightEx(i, 24, m_ZoomRatio, m_FontRatio);\n\t}\n\n\tInvalidate();\n}\n\nvoid CHealthDlg::InitLang()\n{\n\tm_CtrlLabel05.SetWindowTextW(_T(\"[05] \") + i18n(_T(\"Smart\"), _T(\"05\")));\n\tm_CtrlLabelC5.SetWindowTextW(_T(\"[C5] \") + i18n(_T(\"Smart\"), _T(\"C5\")));\n\tm_CtrlLabelC6.SetWindowTextW(_T(\"[C6] \") + i18n(_T(\"Smart\"), _T(\"C6\")));\n\tm_CtrlLabelFF.SetWindowTextW(_T(\"[FF] \") + i18n(_T(\"SmartSsd\"), _T(\"FF\")));\n\n\tm_CtrlApply.SetWindowTextW(i18n(_T(\"HealthStatus\"), _T(\"APPLY\")));\n\tm_CtrlDefault.SetWindowTextW(i18n(_T(\"HealthStatus\"), _T(\"DEFAULT\")));\n\n\tUpdateData(TRUE);\n}\n\nvoid CHealthDlg::InitSelectDisk()\n{\n\tCString select;\n\tCString cstr;\n\n\tif(p->m_Ata.vars.GetCount() <= 0)\n\t{\n\t\treturn ;\n\t}\n\n\tfor(int i = 0; i < p->m_Ata.vars.GetCount(); i++)\n\t{\n\t\tCString temp;\n\t\tif(p->m_Ata.vars[i].IsSsd)\n\t\t{\n\t\t\ttemp = _T(\"[SSD]\");\t\n\t\t}\n\n\t\tCString driveLetter;\n\t\tif (p->m_Ata.vars[i].DriveMap.IsEmpty())\n\t\t{\n\t\t\tif (p->m_Ata.vars[i].PhysicalDriveId >= 0)\n\t\t\t{\n\t\t\t\tdriveLetter.Format(_T(\"(Disk %d)\"), p->m_Ata.vars[i].PhysicalDriveId);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdriveLetter.Format(_T(\"(%s)\"), p->m_Ata.vars[i].DriveMap.GetString());\n\t\t}\n\t\tcstr.Format(_T(\"(%02d) %s %s %s\"), i + 1, p->m_Ata.vars.GetAt(i).Model.GetString(), temp.GetString(), driveLetter.GetString());\n\n\t\tm_CtrlSelectDisk.AddString(cstr);\n\n\t\tif (i == p->GetSelectedDrive())\n\t\t{\n\t\t\tm_CtrlSelectDisk.SetCurSel(i);\n\t\t\tm_DiskIndex = i;\n\t\t}\n\t}\n\n\tUpdateSelectDisk(m_DiskIndex);\n}\n\n\nvoid CHealthDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)\n{\n\tint position = pScrollBar->GetScrollPos();\n\tswitch(nSBCode)\n\t{\n\n\tcase SB_LINELEFT:\n\t\tposition -= 1;\n\t\tbreak;\n\tcase SB_LINERIGHT:\n\t\tposition += 1;\n\t\tbreak;\n\tcase SB_PAGELEFT:\n\t\tposition -= 8;\n\t\tbreak;\n\tcase SB_PAGERIGHT:\n\t\tposition += 8;\n\t\tbreak;\n\tcase SB_LEFT:\n\t\tbreak;\n\tcase SB_RIGHT:\n\t\tbreak;\n\tcase SB_THUMBTRACK:\n\t\tposition = nPos;\n\t\tbreak;\n\t}\n\tpScrollBar->SetScrollPos(position);\n\n\tCString cstr;\n\tif(*pScrollBar == m_CtrlScrollbar05)\n\t{\n\t\tm_Value05X.Format(L\"%02Xh\", m_CtrlScrollbar05.GetScrollPos());\n\t\tm_Value05.Format(L\"%d\", m_CtrlScrollbar05.GetScrollPos());\n\t}\n\telse if(*pScrollBar == m_CtrlScrollbarC5)\n\t{\n\t\tm_ValueC5X.Format(L\"%02Xh\", m_CtrlScrollbarC5.GetScrollPos());\n\t\tm_ValueC5.Format(L\"%d\", m_CtrlScrollbarC5.GetScrollPos());\n\t}\n\telse if(*pScrollBar == m_CtrlScrollbarC6)\n\t{\n\t\tm_ValueC6X.Format(L\"%02Xh\", m_CtrlScrollbarC6.GetScrollPos());\n\t\tm_ValueC6.Format(L\"%d\", m_CtrlScrollbarC6.GetScrollPos());\n\t}\n\telse if(*pScrollBar == m_CtrlScrollbarFF)\n\t{\n\t\tm_ValueFFX.Format(L\"%02Xh\", m_CtrlScrollbarFF.GetScrollPos());\n\t\tm_ValueFF.Format(L\"%d\", m_CtrlScrollbarFF.GetScrollPos());\n\t}\n\n\tUpdateData(FALSE);\n\n\tCDialogFx::OnHScroll(nSBCode, nPos, pScrollBar);\n}\n\nvoid CHealthDlg::UpdateSelectDisk(DWORD index)\n{\n\tif(p->m_Ata.vars[index].IsSsd)\n\t{\n\t\tm_CtrlScrollbar05.SetScrollPos(0);\n\t\tm_CtrlScrollbarC5.SetScrollPos(0);\n\t\tm_CtrlScrollbarC6.SetScrollPos(0);\n\t\tif(p->m_Ata.vars[index].Life < 0)\n\t\t{\n\t\t\tm_CtrlScrollbarFF.SetScrollPos(0);\n\t\t\tm_CtrlScrollbarFF.EnableWindow(FALSE);\n\t\t\tm_ValueFF = L\"\";\n\t\t\tm_ValueFFX = L\"\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_CtrlScrollbarFF.SetScrollPos(GetPrivateProfileIntFx(_T(\"ThreasholdOfCautionFF\"), p->m_Ata.vars[index].ModelSerial, 10, m_Ini));\n\t\t\tm_CtrlScrollbarFF.EnableWindow(TRUE);\n\t\t\tm_ValueFF.Format(_T(\"%d\"), m_CtrlScrollbarFF.GetScrollPos());\n\t\t\tm_ValueFFX.Format(_T(\"%02Xh\"), m_CtrlScrollbarFF.GetScrollPos());\n\t\t}\n\t\tm_CtrlScrollbar05.EnableWindow(FALSE);\n\t\tm_CtrlScrollbarC5.EnableWindow(FALSE);\n\t\tm_CtrlScrollbarC6.EnableWindow(FALSE);\n\t\tm_Value05 = L\"\";\n\t\tm_Value05X = L\"\";\n\t\tm_ValueC5 = L\"\";\n\t\tm_ValueC5X = L\"\";\n\t\tm_ValueC6 = L\"\";\n\t\tm_ValueC6X = L\"\";\n\t}\n\telse\n\t{\n\t\tm_CtrlScrollbar05.SetScrollPos(GetPrivateProfileIntFx(_T(\"ThreasholdOfCaution05\"), p->m_Ata.vars[index].ModelSerial, 1, m_Ini));\n\t\tm_CtrlScrollbarC5.SetScrollPos(GetPrivateProfileIntFx(_T(\"ThreasholdOfCautionC5\"), p->m_Ata.vars[index].ModelSerial, 1, m_Ini));\n\t\tm_CtrlScrollbarC6.SetScrollPos(GetPrivateProfileIntFx(_T(\"ThreasholdOfCautionC6\"), p->m_Ata.vars[index].ModelSerial, 1, m_Ini));\n\t\tm_CtrlScrollbarFF.SetScrollPos(0);\n\n\t\tm_CtrlScrollbar05.EnableWindow(TRUE);\n\t\tm_CtrlScrollbarC5.EnableWindow(TRUE);\n\t\tm_CtrlScrollbarC6.EnableWindow(TRUE);\n\t\tm_CtrlScrollbarFF.EnableWindow(FALSE);\n\t\tm_Value05.Format(_T(\"%d\"), m_CtrlScrollbar05.GetScrollPos());\n\t\tm_ValueC5.Format(_T(\"%d\"), m_CtrlScrollbarC5.GetScrollPos());\n\t\tm_ValueC6.Format(_T(\"%d\"), m_CtrlScrollbarC6.GetScrollPos());\n\t\tm_Value05X.Format(_T(\"%02Xh\"), m_CtrlScrollbar05.GetScrollPos());\n\t\tm_ValueC5X.Format(_T(\"%02Xh\"), m_CtrlScrollbarC5.GetScrollPos());\n\t\tm_ValueC6X.Format(_T(\"%02Xh\"), m_CtrlScrollbarC6.GetScrollPos());\n\t\tm_ValueFF = L\"\";\n\t\tm_ValueFFX = L\"\";\n\t}\n\tUpdateData(FALSE);\n}\n\nvoid CHealthDlg::OnApply()\n{\n\tUpdateData(TRUE);\n\n\tif(! p->m_Ata.vars[m_DiskIndex].IsSsd)\n\t{\n\t\tWritePrivateProfileStringFx(_T(\"ThreasholdOfCaution05\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, m_Value05, m_Ini);\n\t\tWritePrivateProfileStringFx(_T(\"ThreasholdOfCautionC5\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, m_ValueC5, m_Ini);\n\t\tWritePrivateProfileStringFx(_T(\"ThreasholdOfCautionC6\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, m_ValueC6, m_Ini);\n\n\t\tp->m_Ata.vars[m_DiskIndex].Threshold05 = (WORD)_tstoi(m_Value05);\n\t\tp->m_Ata.vars[m_DiskIndex].ThresholdC5 = (WORD)_tstoi(m_ValueC5);\n\t\tp->m_Ata.vars[m_DiskIndex].ThresholdC6 = (WORD)_tstoi(m_ValueC6);\n\t}\n\telse if(p->m_Ata.vars[m_DiskIndex].Life >= 0)\n\t{\n\t\tWritePrivateProfileStringFx(_T(\"ThreasholdOfCautionFF\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, m_ValueFF, m_Ini);\n\t\tp->m_Ata.vars[m_DiskIndex].ThresholdFF = (WORD)_tstoi(m_ValueFF);\n\t}\n\tp->SendMessage(WM_COMMAND, ID_REFRESH);\n}\n\nvoid CHealthDlg::OnDefault()\n{\n\tif(! p->m_Ata.vars[m_DiskIndex].IsSsd)\n\t{\n\t\tm_CtrlScrollbar05.SetScrollPos(1);\n\t\tm_CtrlScrollbarC5.SetScrollPos(1);\n\t\tm_CtrlScrollbarC6.SetScrollPos(1);\n\t\tm_Value05.Format(_T(\"%d\"), m_CtrlScrollbar05.GetScrollPos());\n\t\tm_ValueC5.Format(_T(\"%d\"), m_CtrlScrollbarC5.GetScrollPos());\n\t\tm_ValueC6.Format(_T(\"%d\"), m_CtrlScrollbarC6.GetScrollPos());\n\t\tm_Value05X.Format(_T(\"%02Xh\"), m_CtrlScrollbar05.GetScrollPos());\n\t\tm_ValueC5X.Format(_T(\"%02Xh\"), m_CtrlScrollbarC5.GetScrollPos());\n\t\tm_ValueC6X.Format(_T(\"%02Xh\"), m_CtrlScrollbarC6.GetScrollPos());\n\n\t}\n\telse if(p->m_Ata.vars[m_DiskIndex].Life >= 0)\n\t{\n\t\tm_CtrlScrollbarFF.SetScrollPos(10);\n\t\tm_ValueFF.Format(_T(\"%d\"), m_CtrlScrollbarFF.GetScrollPos());\n\t\tm_ValueFFX.Format(_T(\"%02Xh\"), m_CtrlScrollbarFF.GetScrollPos());\n\t}\n\tUpdateData(FALSE);\n}\n\nvoid CHealthDlg::OnCbnSelchangeSelectDisk()\n{\n\tif(m_DiskIndex != m_CtrlSelectDisk.GetCurSel())\n\t{\n\t\tm_DiskIndex = m_CtrlSelectDisk.GetCurSel();\n\t\tUpdateSelectDisk(m_DiskIndex);\n\t}\n}\n"
        },
        {
          "name": "HealthDlg.h",
          "type": "blob",
          "size": 1.7880859375,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n#include \"DialogFx.h\"\n#include \"StaticFx.h\"\n#include \"ButtonFx.h\"\n#include \"ComboBoxFx.h\"\n\nclass CHealthDlg : public CDialogFx\n{\n\tDECLARE_DYNAMIC(CHealthDlg)\n\n\tstatic const int SIZE_X = 400;\n\tstatic const int SIZE_Y = 304;\n\npublic:\n\tCHealthDlg(CWnd* pParent = NULL);\n\tvirtual ~CHealthDlg();\n\n\tenum { IDD = IDD_HEALTH };\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\n\tvirtual BOOL OnInitDialog();\n\tvirtual void UpdateDialogSize();\n\n\tvoid InitSelectDisk();\n\tvoid InitLang();\n\tvoid UpdateSelectDisk(DWORD index);\n\n\tDECLARE_MESSAGE_MAP()\n\tafx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);\n\tafx_msg void OnApply();\n\tafx_msg void OnDefault();\n\tafx_msg void OnCbnSelchangeSelectDisk();\n\n\tDWORD m_DiskIndex;\n\tCString m_Value05;\n\tCString m_ValueC5;\n\tCString m_ValueC6;\n\tCString m_ValueFF;\n\tCString m_Value05X;\n\tCString m_ValueC5X;\n\tCString m_ValueC6X;\n\tCString m_ValueFFX;\n\tCString m_Label05;\n\tCString m_LabelC5;\n\tCString m_LabelC6;\n\tCString m_LabelFF;\n\n\tCScrollBar m_CtrlScrollbar05;\n\tCScrollBar m_CtrlScrollbarC5;\n\tCScrollBar m_CtrlScrollbarC6;\n\tCScrollBar m_CtrlScrollbarFF;\n\tCStaticFx m_CtrlValue05;\n\tCStaticFx m_CtrlValueC5;\n\tCStaticFx m_CtrlValueC6;\n\tCStaticFx m_CtrlValueFF;\n\tCStaticFx m_CtrlValue05X;\n\tCStaticFx m_CtrlValueC5X;\n\tCStaticFx m_CtrlValueC6X;\n\tCStaticFx m_CtrlValueFFX;\n\tCStaticFx m_CtrlLabel05;\n\tCStaticFx m_CtrlLabelC5;\n\tCStaticFx m_CtrlLabelC6;\n\tCStaticFx m_CtrlLabelFF;\n\tCComboBoxFx m_CtrlSelectDisk;\n\tCButtonFx m_CtrlApply;\n\tCButtonFx m_CtrlDefault; \n};\n"
        },
        {
          "name": "JMicronUsbRaidDef.h",
          "type": "blob",
          "size": 10.125,
          "content": "/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : The MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n\n//-----------------------------------------------------------------------------\n//\n// Struct Defines\n//\n//-----------------------------------------------------------------------------\n\n#define NUMBER_ATA_SMART_ATTRIBUTES 30\n\n#pragma pack(push,1)\n\ntypedef struct _IDENTIFY_DEVICE\n{\n\tWORD\t\tGeneralConfiguration;\t\t\t\t\t//0\n\tWORD\t\tLogicalCylinders;\t\t\t\t\t\t//1\tObsolete\n\tWORD\t\tSpecificConfiguration;\t\t\t\t\t//2\n\tWORD\t\tLogicalHeads;\t\t\t\t\t\t\t//3 Obsolete\n\tWORD\t\tRetired1[2];\t\t\t\t\t\t\t//4-5\n\tWORD\t\tLogicalSectors;\t\t\t\t\t\t\t//6 Obsolete\n\tDWORD\t\tReservedForCompactFlash;\t\t\t\t//7-8\n\tWORD\t\tRetired2;\t\t\t\t\t\t\t\t//9\n\tCHAR\t\tSerialNumber[20];\t\t\t\t\t\t//10-19\n\tWORD\t\tRetired3;\t\t\t\t\t\t\t\t//20\n\tWORD\t\tBufferSize;\t\t\t\t\t\t\t\t//21 Obsolete\n\tWORD\t\tObsolute4;\t\t\t\t\t\t\t\t//22\n\tCHAR\t\tFirmwareRev[8];\t\t\t\t\t\t\t//23-26\n\tCHAR\t\tModel[40];\t\t\t\t\t\t\t\t//27-46\n\tWORD\t\tMaxNumPerInterupt;\t\t\t\t\t\t//47\n\tWORD\t\tReserved1;\t\t\t\t\t\t\t\t//48\n\tWORD\t\tCapabilities1;\t\t\t\t\t\t\t//49\n\tWORD\t\tCapabilities2;\t\t\t\t\t\t\t//50\n\tDWORD\t\tObsolute5;\t\t\t\t\t\t\t\t//51-52\n\tWORD\t\tField88and7064;\t\t\t\t\t\t\t//53\n\tWORD\t\tObsolute6[5];\t\t\t\t\t\t\t//54-58\n\tWORD\t\tMultSectorStuff;\t\t\t\t\t\t//59\n\tDWORD\t\tTotalAddressableSectors;\t\t\t\t//60-61\n\tWORD\t\tObsolute7;\t\t\t\t\t\t\t\t//62\n\tWORD\t\tMultiWordDma;\t\t\t\t\t\t\t//63\n\tWORD\t\tPioMode;\t\t\t\t\t\t\t\t//64\n\tWORD\t\tMinMultiwordDmaCycleTime;\t\t\t\t//65\n\tWORD\t\tRecommendedMultiwordDmaCycleTime;\t\t//66\n\tWORD\t\tMinPioCycleTimewoFlowCtrl;\t\t\t\t//67\n\tWORD\t\tMinPioCycleTimeWithFlowCtrl;\t\t\t//68\n\tWORD\t\tReserved2[6];\t\t\t\t\t\t\t//69-74\n\tWORD\t\tQueueDepth;\t\t\t\t\t\t\t\t//75\n\tWORD\t\tSerialAtaCapabilities;\t\t\t\t\t//76\n\tWORD\t\tSerialAtaAdditionalCapabilities;\t\t//77\n\tWORD\t\tSerialAtaFeaturesSupported;\t\t\t\t//78\n\tWORD\t\tSerialAtaFeaturesEnabled;\t\t\t\t//79\n\tWORD\t\tMajorVersion;\t\t\t\t\t\t\t//80\n\tWORD\t\tMinorVersion;\t\t\t\t\t\t\t//81\n\tWORD\t\tCommandSetSupported1;\t\t\t\t\t//82\n\tWORD\t\tCommandSetSupported2;\t\t\t\t\t//83\n\tWORD\t\tCommandSetSupported3;\t\t\t\t\t//84\n\tWORD\t\tCommandSetEnabled1;\t\t\t\t\t\t//85\n\tWORD\t\tCommandSetEnabled2;\t\t\t\t\t\t//86\n\tWORD\t\tCommandSetDefault;\t\t\t\t\t\t//87\n\tWORD\t\tUltraDmaMode;\t\t\t\t\t\t\t//88\n\tWORD\t\tTimeReqForSecurityErase;\t\t\t\t//89\n\tWORD\t\tTimeReqForEnhancedSecure;\t\t\t\t//90\n\tWORD\t\tCurrentPowerManagement;\t\t\t\t\t//91\n\tWORD\t\tMasterPasswordRevision;\t\t\t\t\t//92\n\tWORD\t\tHardwareResetResult;\t\t\t\t\t//93\n\tWORD\t\tAcoustricManagement;\t\t\t\t\t//94\n\tWORD\t\tStreamMinRequestSize;\t\t\t\t\t//95\n\tWORD\t\tStreamingTimeDma;\t\t\t\t\t\t//96\n\tWORD\t\tStreamingAccessLatency;\t\t\t\t\t//97\n\tDWORD\t\tStreamingPerformance;\t\t\t\t\t//98-99\n\tULONGLONG\tMaxUserLba;\t\t\t\t\t\t\t\t//100-103\n\tWORD\t\tStremingTimePio;\t\t\t\t\t\t//104\n\tWORD\t\tReserved3;\t\t\t\t\t\t\t\t//105\n\tWORD\t\tSectorSize;\t\t\t\t\t\t\t\t//106\n\tWORD\t\tInterSeekDelay;\t\t\t\t\t\t\t//107\n\tWORD\t\tIeeeOui;\t\t\t\t\t\t\t\t//108\n\tWORD\t\tUniqueId3;\t\t\t\t\t\t\t\t//109\n\tWORD\t\tUniqueId2;\t\t\t\t\t\t\t\t//110\n\tWORD\t\tUniqueId1;\t\t\t\t\t\t\t\t//111\n\tWORD\t\tReserved4[4];\t\t\t\t\t\t\t//112-115\n\tWORD\t\tReserved5;\t\t\t\t\t\t\t\t//116\n\tDWORD\t\tWordsPerLogicalSector;\t\t\t\t\t//117-118\n\tWORD\t\tReserved6[8];\t\t\t\t\t\t\t//119-126\n\tWORD\t\tRemovableMediaStatus;\t\t\t\t\t//127\n\tWORD\t\tSecurityStatus;\t\t\t\t\t\t\t//128\n\tWORD\t\tVendorSpecific[31];\t\t\t\t\t\t//129-159\n\tWORD\t\tCfaPowerMode1;\t\t\t\t\t\t\t//160\n\tWORD\t\tReservedForCompactFlashAssociation[7];\t//161-167\n\tWORD\t\tDeviceNominalFormFactor;\t\t\t\t//168\n\tWORD\t\tDataSetManagement;\t\t\t\t\t\t//169\n\tWORD\t\tAdditionalProductIdentifier[4];\t\t\t//170-173\n\tWORD\t\tReserved7[2];\t\t\t\t\t\t\t//174-175\n\tCHAR\t\tCurrentMediaSerialNo[60];\t\t\t\t//176-205\n\tWORD\t\tSctCommandTransport;\t\t\t\t\t//206\n\tWORD\t\tReservedForCeAta1[2];\t\t\t\t\t//207-208\n\tWORD\t\tAlignmentOfLogicalBlocks;\t\t\t\t//209\n\tDWORD\t\tWriteReadVerifySectorCountMode3;\t\t//210-211\n\tDWORD\t\tWriteReadVerifySectorCountMode2;\t\t//212-213\n\tWORD\t\tNvCacheCapabilities;\t\t\t\t\t//214\n\tDWORD\t\tNvCacheSizeLogicalBlocks;\t\t\t\t//215-216\n\tWORD\t\tNominalMediaRotationRate;\t\t\t\t//217\n\tWORD\t\tReserved8;\t\t\t\t\t\t\t\t//218\n\tWORD\t\tNvCacheOptions1;\t\t\t\t\t\t//219\n\tWORD\t\tNvCacheOptions2;\t\t\t\t\t\t//220\n\tWORD\t\tReserved9;\t\t\t\t\t\t\t\t//221\n\tWORD\t\tTransportMajorVersionNumber;\t\t\t//222\n\tWORD\t\tTransportMinorVersionNumber;\t\t\t//223\n\tWORD\t\tReservedForCeAta2[10];\t\t\t\t\t//224-233\n\tWORD\t\tMinimumBlocksPerDownloadMicrocode;\t\t//234\n\tWORD\t\tMaximumBlocksPerDownloadMicrocode;\t\t//235\n\tWORD\t\tReserved10[19];\t\t\t\t\t\t\t//236-254\n\tWORD\t\tIntegrityWord;\t\t\t\t\t\t\t//255\n}IDENTIFY_DEVICE;\n\ntypedef\tstruct _SMART_THRESHOLD\n{\n\tBYTE\tId;\n\tBYTE\tThresholdValue;\n\tBYTE\tReserved[10];\n} SMART_THRESHOLD;\n\n/*\ntypedef\tstruct _SMART_ATTRIBUTE\n{\n\tBYTE\tId;\n\tWORD\tStatusFlags;\n\tBYTE\tCurrentValue;\n\tBYTE\tWorstValue;\n\tBYTE\tRawValue[6];\n\tBYTE\tReserved;\n} SMART_ATTRIBUTE;\n*/\n\ntypedef struct _SMART_READ_DATA\n{\n\tBYTE revision[2];\n\tSMART_ATTRIBUTE attribute[NUMBER_ATA_SMART_ATTRIBUTES];\n\tBYTE reserved[150];\n} SMART_READ_DATA;\n\ntypedef struct _SMART_READ_THRESHOLD\n{\n\tBYTE revision[2];\n\tSMART_THRESHOLD threshold[NUMBER_ATA_SMART_ATTRIBUTES];\n\tBYTE reserved[150];\n} SMART_READ_THRESHOLD;\n\ntypedef struct _BYTE512\n{\n\tBYTE b[512];\n} BYTE512;\n\ntypedef struct _NVME_IDENTIFY_DEVICE\n{\n\tCHAR\t\tReserved1[4];\n\tCHAR\t\tSerialNumber[20];\n\tCHAR\t\tModel[40];\n\tCHAR\t\tFirmwareRev[8];\n\tCHAR\t\tReserved2[9];\n\tCHAR\t\tMinorVersion;\n\tSHORT\t\tMajorVersion;\n\tCHAR\t\tReserved3[428];\n}NVME_IDENTIFY_DEVICE;\n\ntypedef union _UNION_IDENTIFY_DEVICE\n{\n\tIDENTIFY_DEVICE I;\n\tNVME_IDENTIFY_DEVICE N;\n\tBYTE512 B;\n} UNION_IDENTIFY_DEVICE;\n\ntypedef union _UNION_SMART_ATTRIBUTE\n{\n\tSMART_READ_DATA A;\n\tBYTE512 B;\n} UNION_SMART_ATTRIBUTE;\n\ntypedef union _UNION_SMART_THRESHOLD\n{\n\tSMART_READ_THRESHOLD T;\n\tBYTE512 B;\n} UNION_SMART_THRESHOLD;\n\n#define DISKNAME_LENGTH\t\t\t\t\t\t\t\t\t(40+1)\t\n#define MODELNAME_LENGTH\t\t\t\t\t\t\t\t(20+1)\n#define SERIALNUMBER_LENGTH\t\t\t\t\t\t\t\t(20+1)\n#define DISK_FIRMWAREVERSION_LENGTH\t\t\t\t\t\t9\n\ntypedef struct _NVME_PORT_40\n{\n\tuint8_t\t\t\tModelName[41];\t\t\t\t\t\t\t\t\t/* Model name of disk\t\t*/\n\tuint8_t\t\t\tSerialNumber[SERIALNUMBER_LENGTH];\t\t\t\t/* Serial number of disk\t*/\n\tuint32_t\t\tSectorSize;\t\t\t\t\t\t\t\t\t\t/* 512 bytes or 4K          */\n\tuint32_t\t\tCapacity;\t\t\t\t\t\t\t\t\t\t/* Disk capacity        \t*/\n\tuint32_t\t\tCapacityOffset;\t\t\t\t\t\t\t\t\t/* Disk capacity        \t*/\n\tuint8_t\t\t\tDeviceState;\t\t\t\t\t\t\t\t\t/* Device State\t\t\t\t*/\n\tuint8_t\t\t\tRaidIndex;\t\t\t\t\t\t\t\t\t\t/* RAID Index\t\t\t\t*/\n\tuint8_t\t\t\tMemberIndex;\t\t\t\t\t\t\t\t\t/* Member Index\t\t\t\t*/\n\tuint8_t\t\t\tPortType;\t\t\t\t\t\t\t\t\t\t/* Port Type\t\t\t\t*/\n\tuint8_t\t\t\tPCIeSpeed;\t\t\t\t\t\t\t\t\t\t/* PCIe Speed\t\t\t\t*/\n\tuint8_t         PCIeLANE;                                       /* PCIe LANE                */\n\tuint16_t\t\tPortErrorStatus;\t\t\t\t\t\t\t\t/* NVMe port error status\t*/\n\tuint8_t         DiskType;\n} NVME_PORT_40;\n\ntypedef struct _NVME_PORT_20\n{\n\tuint8_t\t\t\tModelName[21];\t\t\t\t\t\t\t\t\t/* Model name of disk\t\t*/\n\tuint8_t\t\t\tSerialNumber[SERIALNUMBER_LENGTH];\t\t\t\t/* Serial number of disk\t*/\n\tuint32_t\t\tSectorSize;\t\t\t\t\t\t\t\t\t\t/* 512 bytes or 4K          */\n\tuint32_t\t\tCapacity;\t\t\t\t\t\t\t\t\t\t/* Disk capacity        \t*/\n\tuint32_t\t\tCapacityOffset;\t\t\t\t\t\t\t\t\t/* Disk capacity        \t*/\n\tuint8_t\t\t\tDeviceState;\t\t\t\t\t\t\t\t\t/* Device State\t\t\t\t*/\n\tuint8_t\t\t\tRaidIndex;\t\t\t\t\t\t\t\t\t\t/* RAID Index\t\t\t\t*/\n\tuint8_t\t\t\tMemberIndex;\t\t\t\t\t\t\t\t\t/* Member Index\t\t\t\t*/\n\tuint8_t\t\t\tPortType;\t\t\t\t\t\t\t\t\t\t/* Port Type\t\t\t\t*/\n\tuint8_t\t\t\tPCIeSpeed;\t\t\t\t\t\t\t\t\t\t/* PCIe Speed\t\t\t\t*/\n\tuint8_t         PCIeLANE;                                       /* PCIe LANE                */\n\tuint16_t\t\tPortErrorStatus;\t\t\t\t\t\t\t\t/* NVMe port error status\t*/\n\tuint8_t         DiskType;\n} NVME_PORT_20;\n\ntypedef struct _NVME_ID\n{\n\tuint16_t        PCIeVID;\n\tuint16_t        PCIeSubSysVID;\n\tuint8_t         ControllerMultIO;\n\tuint8_t         MaxTransferSize;\n\tuint16_t        ControllerID;\n\tuint8_t         FirmwareRevision[8];\n\tuint8_t         FGUID[16];\n\tuint16_t        WarnTemperatureThreshold;\n\tuint16_t        CriticalTemperatureThreshold;\n\tuint16_t        MinThermalTemperature;\n\tuint16_t        MaxThermalTemperature;\n\tuint32_t        NumOFNamespace;\n\tuint8_t         IeeeOuiID[3];\n} NVME_ID;\n\n#pragma\tpack(pop)\n\n//-----------------------------------------------------------------------------\n//\n// Type Defines\n//\n//-----------------------------------------------------------------------------\n\n// JMicron JMS56X API\ntypedef DWORD(WINAPI* _GetDllVersionJMS56X) (PBYTE major, PBYTE minor, PBYTE revision, PBYTE release);\ntypedef int(WINAPI* _GetControllerCountJMS56X) ();\ntypedef BOOL(WINAPI* _GetSmartInfoJMS56X) (int index, unsigned char port, UNION_SMART_ATTRIBUTE* attribute, UNION_SMART_THRESHOLD* threshold);\ntypedef BOOL(WINAPI* _GetIdentifyInfoJMS56X) (int index, unsigned char port, UNION_IDENTIFY_DEVICE* identify);\n\n// JMicron JMB39X API\ntypedef DWORD(WINAPI* _GetDllVersionJMB39X) (PBYTE major, PBYTE minor, PBYTE revision, PBYTE release);\ntypedef int(WINAPI* _GetControllerCountJMB39X) ();\ntypedef BOOL(WINAPI* _GetSmartInfoJMB39X) (int index, unsigned char port, UNION_SMART_ATTRIBUTE* attribute, UNION_SMART_THRESHOLD* threshold);\ntypedef BOOL(WINAPI* _GetIdentifyInfoJMB39X) (int index, unsigned char port, UNION_IDENTIFY_DEVICE* identify);\n\n// JMicron JMS586_Old API\ntypedef DWORD(WINAPI* _GetDllVersionJMS586_20) (PBYTE major, PBYTE minor, PBYTE revision, PBYTE release);\ntypedef int(WINAPI* _GetControllerCountJMS586_20) ();\ntypedef BOOL(WINAPI* _GetSmartInfoJMS586_20) (int index, unsigned char port, UNION_SMART_ATTRIBUTE* attribute, UNION_SMART_THRESHOLD* threshold);\ntypedef BOOL(WINAPI* _GetIdentifyInfoJMS586_20) (int index, unsigned char port, UNION_IDENTIFY_DEVICE* identify);\n\ntypedef BOOL(WINAPI* _GetNVMePortInfoJMS586_20) (int index, unsigned char port, NVME_PORT_20* nvmePort);\ntypedef BOOL(WINAPI* _GetNVMeSmartInfoJMS586_20) (int index, unsigned char port, UNION_SMART_ATTRIBUTE* smartInfo);\n\n// JMicron JMS586_New API\ntypedef DWORD(WINAPI* _GetDllVersionJMS586_40) (PBYTE major, PBYTE minor, PBYTE revision, PBYTE release);\ntypedef int(WINAPI* _GetControllerCountJMS586_40) ();\ntypedef BOOL(WINAPI* _GetSmartInfoJMS586_40) (BYTE index, unsigned char port, UNION_SMART_ATTRIBUTE* attribute, UNION_SMART_THRESHOLD* threshold);\ntypedef BOOL(WINAPI* _GetIdentifyInfoJMS586_40) (BYTE index, unsigned char port, UNION_IDENTIFY_DEVICE* identify);\n\ntypedef BOOL(WINAPI* _GetNVMePortInfoJMS586_40) (BYTE index, unsigned char port, NVME_PORT_40* nvmePort);\ntypedef BOOL(WINAPI* _GetNVMeSmartInfoJMS586_40) (BYTE index, unsigned char port, UNION_SMART_ATTRIBUTE* smartInfo);\ntypedef BOOL(WINAPI* _GetNVMeIdInfoJMS586_40) (BYTE index, unsigned char port, NVME_ID* nvmeId);\ntypedef BOOL(WINAPI* _ControllerSerialNum2IdJMS586_40) (BYTE csn, BYTE* cid);\n\n"
        },
        {
          "name": "JMicronUsbRaidInit.h",
          "type": "blob",
          "size": 10.8388671875,
          "content": "/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : The MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n\n//-----------------------------------------------------------------------------\n//\n// Prototypes\n//\n//-----------------------------------------------------------------------------\n\nBOOL InitializeJMS56X(HMODULE* hModule);\nBOOL DeinitializeJMS56X(HMODULE* hModule);\n\nBOOL InitializeJMB39X(HMODULE* hModule);\nBOOL DeinitializeJMB39X(HMODULE* hModule);\n\nBOOL InitializeJMS586_20(HMODULE* hModule);\nBOOL DeinitializeJMS586_20(HMODULE* hModule);\n\nBOOL InitializeJMS586_40(HMODULE* hModule);\nBOOL DeinitializeJMS586_40(HMODULE* hModule);\n\n//-----------------------------------------------------------------------------\n//\n// Funtions\n//\n//-----------------------------------------------------------------------------\n\n_GetDllVersionJMS56X pGetDllVersionJMS56X = NULL;\n_GetControllerCountJMS56X pGetControllerCountJMS56X = NULL;\n_GetSmartInfoJMS56X pGetSmartInfoJMS56X = NULL;\n_GetIdentifyInfoJMS56X pGetIdentifyInfoJMS56X = NULL;\n\n_GetDllVersionJMB39X pGetDllVersionJMB39X = NULL;\n_GetControllerCountJMB39X pGetControllerCountJMB39X = NULL;\n_GetSmartInfoJMB39X pGetSmartInfoJMB39X = NULL;\n_GetIdentifyInfoJMB39X pGetIdentifyInfoJMB39X = NULL;\n\n_GetDllVersionJMS586_20 pGetDllVersionJMS586_20 = NULL;\n_GetControllerCountJMS586_20 pGetControllerCountJMS586_20 = NULL;\n_GetSmartInfoJMS586_20 pGetSmartInfoJMS586_20 = NULL;\n_GetIdentifyInfoJMS586_20 pGetIdentifyInfoJMS586_20 = NULL;\n_GetNVMePortInfoJMS586_20 pGetNVMePortInfoJMS586_20 = NULL;\n_GetNVMeSmartInfoJMS586_20 pGetNVMeSmartInfoJMS586_20 = NULL;\n\n_GetDllVersionJMS586_40 pGetDllVersionJMS586_40 = NULL;\n_GetControllerCountJMS586_40 pGetControllerCountJMS586_40 = NULL;\n_GetSmartInfoJMS586_40 pGetSmartInfoJMS586_40 = NULL;\n_GetIdentifyInfoJMS586_40 pGetIdentifyInfoJMS586_40 = NULL;\n_GetNVMePortInfoJMS586_40 pGetNVMePortInfoJMS586_40 = NULL;\n_GetNVMeSmartInfoJMS586_40 pGetNVMeSmartInfoJMS586_40 = NULL;\n_GetNVMeIdInfoJMS586_40 pGetNVMeIdInfoJMS586_40 = NULL;\n_ControllerSerialNum2IdJMS586_40 pControllerSerialNum2IdJMS586_40 = NULL;\n\n//-----------------------------------------------------------------------------\n//\n// Initialize\n//\n//-----------------------------------------------------------------------------\n\nBOOL InitializeJMS56X(HMODULE* hModule)\n{\n\tTCHAR fullPath[MAX_PATH] = {};\n\tTCHAR drive[MAX_PATH] = {};\n\tTCHAR path[MAX_PATH] = {};\n\tTCHAR dllPath[MAX_PATH] = {};\n\n\tGetModuleFileNameW(NULL, fullPath, MAX_PATH);\n\t_wsplitpath_s(fullPath, drive, MAX_PATH, path, MAX_PATH, NULL, 0, NULL, 0);\n\twcscat_s(dllPath, MAX_PATH, drive);\n\twcscat_s(dllPath, MAX_PATH, path);\n\twcscat_s(dllPath, MAX_PATH, DLL_DIR);\n\n#ifdef _M_ARM64\n\twcscat_s(dllPath, MAX_PATH, L\"JMS56xA64.dll\");\n#elif _M_X64\n\twcscat_s(dllPath, MAX_PATH, L\"JMS56x64.dll\");\n#else\n\twcscat_s(dllPath, MAX_PATH, L\"JMS56x86.dll\");\n#endif\n\n\tif (!CheckCodeSign(CERTNAME_JMS56X, dllPath)) { return FALSE; }\n\t* hModule = LoadLibraryW(dllPath);\n\n\tif (*hModule == NULL)\n\t{\n\t\treturn FALSE;\n\t}\n\n\t//-----------------------------------------------------------------------------\n\t// GetProcAddress\n\t//-----------------------------------------------------------------------------\n\tpGetDllVersionJMS56X = (_GetDllVersionJMS56X)GetProcAddress(*hModule, \"GetDllVersion\");\n\tpGetControllerCountJMS56X = (_GetControllerCountJMS56X)GetProcAddress(*hModule, \"GetControllerCount\");\n\tpGetSmartInfoJMS56X = (_GetSmartInfoJMS56X)GetProcAddress(*hModule, \"GetSmartInfoFx\");\n\tpGetIdentifyInfoJMS56X = (_GetIdentifyInfoJMS56X)GetProcAddress(*hModule, \"GetIdentifyInfoFx\");\n\n\t//-----------------------------------------------------------------------------\n\t// Check Functions\n\t//-----------------------------------------------------------------------------\n\tif (!( pGetDllVersionJMS56X\n\t\t&& pGetControllerCountJMS56X\n\t\t&& pGetSmartInfoJMS56X\n\t\t&& pGetIdentifyInfoJMS56X\n\t\t))\n\t{\n\t\tFreeLibrary(*hModule);\n\t\t*hModule = NULL;\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL InitializeJMB39X(HMODULE* hModule)\n{\n\tTCHAR fullPath[MAX_PATH] = {};\n\tTCHAR drive[MAX_PATH] = {};\n\tTCHAR path[MAX_PATH] = {};\n\tTCHAR dllPath[MAX_PATH] = {};\n\n\tGetModuleFileNameW(NULL, fullPath, MAX_PATH);\n\t_wsplitpath_s(fullPath, drive, MAX_PATH, path, MAX_PATH, NULL, 0, NULL, 0);\n\twcscat_s(dllPath, MAX_PATH, drive);\n\twcscat_s(dllPath, MAX_PATH, path);\n\twcscat_s(dllPath, MAX_PATH, DLL_DIR);\n\n#ifdef _M_ARM64\n\twcscat_s(dllPath, MAX_PATH, L\"JMB39xA64.dll\");\n#elif _M_X64\n\twcscat_s(dllPath, MAX_PATH, L\"JMB39x64.dll\");\n#else\n\twcscat_s(dllPath, MAX_PATH, L\"JMB39x86.dll\");\n#endif\n\n\tif (!CheckCodeSign(CERTNAME_JMB39X, dllPath)) { return FALSE; }\n\t*hModule = LoadLibraryW(dllPath);\n\n\tif (*hModule == NULL)\n\t{\n\t\treturn FALSE;\n\t}\n\n\t//-----------------------------------------------------------------------------\n\t// GetProcAddress\n\t//-----------------------------------------------------------------------------\n\tpGetDllVersionJMB39X = (_GetDllVersionJMB39X)GetProcAddress(*hModule, \"GetDllVersion\");\n\tpGetControllerCountJMB39X = (_GetControllerCountJMB39X)GetProcAddress(*hModule, \"GetControllerCount\");\n\tpGetSmartInfoJMB39X = (_GetSmartInfoJMB39X)GetProcAddress(*hModule, \"GetSmartInfoFx\");\n\tpGetIdentifyInfoJMB39X = (_GetIdentifyInfoJMB39X)GetProcAddress(*hModule, \"GetIdentifyInfoFx\");\n\n\t//-----------------------------------------------------------------------------\n\t// Check Functions\n\t//-----------------------------------------------------------------------------\n\tif (!( pGetDllVersionJMB39X\n\t\t&& pGetControllerCountJMB39X\n\t\t&& pGetSmartInfoJMB39X\n\t\t&& pGetIdentifyInfoJMB39X\n\t\t))\n\t{\n\t\tFreeLibrary(*hModule);\n\t\t*hModule = NULL;\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL InitializeJMS586_20(HMODULE* hModule)\n{\n\tTCHAR fullPath[MAX_PATH] = {};\n\tTCHAR drive[MAX_PATH] = {};\n\tTCHAR path[MAX_PATH] = {};\n\tTCHAR dllPath[MAX_PATH] = {};\n\n\tGetModuleFileNameW(NULL, fullPath, MAX_PATH);\n\t_wsplitpath_s(fullPath, drive, MAX_PATH, path, MAX_PATH, NULL, 0, NULL, 0);\n\twcscat_s(dllPath, MAX_PATH, drive);\n\twcscat_s(dllPath, MAX_PATH, path);\n\twcscat_s(dllPath, MAX_PATH, DLL_DIR);\n\n#ifdef _M_ARM64\n\twcscat_s(dllPath, MAX_PATH, L\"JMS586A64.dll\");\n#elif _M_X64\n\twcscat_s(dllPath, MAX_PATH, L\"JMS586x64.dll\");\n#else\n\twcscat_s(dllPath, MAX_PATH, L\"JMS586x86.dll\");\n#endif\n\n\tif (!CheckCodeSign(CERTNAME_JMS586_20, dllPath)) { return FALSE; }\n\t*hModule = LoadLibraryW(dllPath);\n\n\tif (*hModule == NULL)\n\t{\n\t\treturn FALSE;\n\t}\n\n\t//-----------------------------------------------------------------------------\n\t// GetProcAddress\n\t//-----------------------------------------------------------------------------\n\tpGetDllVersionJMS586_20 = (_GetDllVersionJMS586_20)GetProcAddress(*hModule, \"GetDllVersion\");\n\tpGetControllerCountJMS586_20 = (_GetControllerCountJMS586_20)GetProcAddress(*hModule, \"GetControllerCount\");\n\tpGetSmartInfoJMS586_20 = (_GetSmartInfoJMS586_20)GetProcAddress(*hModule, \"GetSmartInfoFx\");\n\tpGetIdentifyInfoJMS586_20 = (_GetIdentifyInfoJMS586_20)GetProcAddress(*hModule, \"GetIdentifyInfoFx\");\n\tpGetNVMePortInfoJMS586_20 = (_GetNVMePortInfoJMS586_20)GetProcAddress(*hModule, \"GetNVMePortInfoFx\");\n\tpGetNVMeSmartInfoJMS586_20 = (_GetNVMeSmartInfoJMS586_20)GetProcAddress(*hModule, \"GetNVMeSmartInfoFx\");\n\n\t//-----------------------------------------------------------------------------\n\t// Check Functions\n\t//-----------------------------------------------------------------------------\n\tif (!(pGetDllVersionJMS586_20\n\t\t&& pGetControllerCountJMS586_20\n\t\t&& pGetSmartInfoJMS586_20\n\t\t&& pGetIdentifyInfoJMS586_20\n\t\t&& pGetNVMePortInfoJMS586_20\n\t\t&& pGetNVMeSmartInfoJMS586_20\n\t\t))\n\t{\n\t\tFreeLibrary(*hModule);\n\t\t*hModule = NULL;\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL InitializeJMS586_40(HMODULE* hModule)\n{\n\tTCHAR fullPath[MAX_PATH] = {};\n\tTCHAR drive[MAX_PATH] = {};\n\tTCHAR path[MAX_PATH] = {};\n\tTCHAR dllPath[MAX_PATH] = {};\n\n\tGetModuleFileNameW(NULL, fullPath, MAX_PATH);\n\t_wsplitpath_s(fullPath, drive, MAX_PATH, path, MAX_PATH, NULL, 0, NULL, 0);\n\twcscat_s(dllPath, MAX_PATH, drive);\n\twcscat_s(dllPath, MAX_PATH, path);\n\twcscat_s(dllPath, MAX_PATH, DLL_DIR);\n\n#ifdef _M_ARM64\n\twcscat_s(dllPath, MAX_PATH, L\"JMS586_40A64.dll\");\n#elif _M_X64\n\twcscat_s(dllPath, MAX_PATH, L\"JMS586_40x64.dll\");\n#else\n\twcscat_s(dllPath, MAX_PATH, L\"JMS586_40x86.dll\");\n#endif\n\n\tif (!CheckCodeSign(CERTNAME_JMS586_40, dllPath)) { return FALSE; }\n\t*hModule = LoadLibraryW(dllPath);\n\n\tif (*hModule == NULL)\n\t{\n\t\treturn FALSE;\n\t}\n\n\t//-----------------------------------------------------------------------------\n\t// GetProcAddress\n\t//-----------------------------------------------------------------------------\n\tpGetDllVersionJMS586_40 = (_GetDllVersionJMS586_40)GetProcAddress(*hModule, \"GetDllVersion\");\n\tpGetControllerCountJMS586_40 = (_GetControllerCountJMS586_40)GetProcAddress(*hModule, \"GetControllerCount\");\n\tpGetSmartInfoJMS586_40 = (_GetSmartInfoJMS586_40)GetProcAddress(*hModule, \"GetSmartInfoFx\");\n\tpGetIdentifyInfoJMS586_40 = (_GetIdentifyInfoJMS586_40)GetProcAddress(*hModule, \"GetIdentifyInfoFx\");\n\tpGetNVMePortInfoJMS586_40 = (_GetNVMePortInfoJMS586_40)GetProcAddress(*hModule, \"GetNVMePortInfoFx\");\n\tpGetNVMeSmartInfoJMS586_40 = (_GetNVMeSmartInfoJMS586_40)GetProcAddress(*hModule, \"GetNVMeSmartInfoFx\");\n\tpGetNVMeIdInfoJMS586_40 = (_GetNVMeIdInfoJMS586_40)GetProcAddress(*hModule, \"GetNVMeIdInfoFx\");\n\tpControllerSerialNum2IdJMS586_40 = (_ControllerSerialNum2IdJMS586_40)GetProcAddress(*hModule, \"ControllerSerialNum2IdFx\");\n\n\t//-----------------------------------------------------------------------------\n\t// Check Functions\n\t//-----------------------------------------------------------------------------\n\tif (!(pGetDllVersionJMS586_40\n\t\t&& pGetControllerCountJMS586_40\n\t\t&& pGetSmartInfoJMS586_40\n\t\t&& pGetIdentifyInfoJMS586_40\n\t\t&& pGetNVMePortInfoJMS586_40\n\t\t&& pGetNVMeSmartInfoJMS586_40\n\t\t&& pGetNVMeIdInfoJMS586_40\n\t\t&& pControllerSerialNum2IdJMS586_40\n\t\t))\n\t{\n\t\tFreeLibrary(*hModule);\n\t\t*hModule = NULL;\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n\n//-----------------------------------------------------------------------------\n//\n// Deinitialize\n//\n//-----------------------------------------------------------------------------\n\nBOOL DeinitializeJMS56X(HMODULE* hModule)\n{\n\tBOOL result = FALSE;\n\n\tif (*hModule == NULL)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\tresult = FreeLibrary(*hModule);\n\t\t*hModule = NULL;\n\n\t\treturn result;\n\t}\n}\n\nBOOL DeinitializeJMB39X(HMODULE* hModule)\n{\n\tBOOL result = FALSE;\n\n\tif (*hModule == NULL)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\tresult = FreeLibrary(*hModule);\n\t\t*hModule = NULL;\n\n\t\treturn result;\n\t}\n}\n\nBOOL DeinitializeJMS586_20(HMODULE* hModule)\n{\n\tBOOL result = FALSE;\n\n\tif (*hModule == NULL)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\tresult = FreeLibrary(*hModule);\n\t\t*hModule = NULL;\n\n\t\treturn result;\n\t}\n}\n\nBOOL DeinitializeJMS586_40(HMODULE* hModule)\n{\n\tBOOL result = FALSE;\n\n\tif (*hModule == NULL)\n\t{\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\tresult = FreeLibrary(*hModule);\n\t\t*hModule = NULL;\n\n\t\treturn result;\n\t}\n}"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2008-2023 hiyohiyo\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Language",
          "type": "tree",
          "content": null
        },
        {
          "name": "Library",
          "type": "tree",
          "content": null
        },
        {
          "name": "MSG00409.bin",
          "type": "blob",
          "size": 0.29296875,
          "content": null
        },
        {
          "name": "NVMeInterpreter.cpp",
          "type": "blob",
          "size": 5.3515625,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : Minkyu Kim\n//          Web : http://naraeon.net/\n//                https://github.com/ebangin127/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"StdAfx.h\"\n#include \"nvmeinterpreter.h\"\n\nvoid AddToATASmartBuf(SMART_ATTRIBUTE_LIST* ATASmartBuf, INT IdxInBuf, SMART_ATTRIBUTE AttrToAdd)\n{\n\t(*ATASmartBuf)[IdxInBuf] = AttrToAdd;\n}\n\nSMART_ATTRIBUTE SeperateCriticalWarningFrom(UCHAR* NVMeSmartBuf)\n{\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 1;\n\tattr.RawValue[0] = NVMeSmartBuf[0];\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperateTemperatureFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int TemperatureStart = 1;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 2;\n\tattr.RawValue[0] = NVMeSmartBuf[TemperatureStart];\n\tattr.RawValue[1] = NVMeSmartBuf[TemperatureStart + 1];\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperateAvailableSpareFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int AvailableSpareStart = 3;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 3;\n\tattr.RawValue[0] = NVMeSmartBuf[AvailableSpareStart];\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperateAvailableSpareThresholdFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int AvailableSpareThresholdStart = 4;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 4;\n\tattr.RawValue[0] = NVMeSmartBuf[AvailableSpareThresholdStart];\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperatePercentageUsedFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int PercentageUsedStart = 5;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 5;\n\tattr.RawValue[0] = NVMeSmartBuf[PercentageUsedStart];\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperateDataUnitsReadFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int DataUnitsReadStart = 32;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 6;\n\tmemcpy(attr.RawValue, &NVMeSmartBuf[DataUnitsReadStart], sizeof(attr.RawValue));\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperateDataUnitsWrittenFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int DataUnitsWrittenStart = 48;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 7;\n\tmemcpy(attr.RawValue, &NVMeSmartBuf[DataUnitsWrittenStart], sizeof(attr.RawValue));\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperateHostReadCommandsFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int ReadStart = 64;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 8;\n\tmemcpy(attr.RawValue, &NVMeSmartBuf[ReadStart], sizeof(attr.RawValue));\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperateHostWriteCommandsFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int WriteStart = 80;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 9;\n\tmemcpy(attr.RawValue, &NVMeSmartBuf[WriteStart], sizeof(attr.RawValue));\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperateControllerBusyTimeFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int BusyTimeStart = 96;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 10;\n\tmemcpy(attr.RawValue, &NVMeSmartBuf[BusyTimeStart], sizeof(attr.RawValue));\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperatePowerCyclesFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int PowerCycleStart = 112;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 11;\n\tmemcpy(attr.RawValue, &NVMeSmartBuf[PowerCycleStart], sizeof(attr.RawValue));\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperatePowerOnHoursFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int PowerOnHoursStart = 128;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 12;\n\tmemcpy(attr.RawValue, &NVMeSmartBuf[PowerOnHoursStart], sizeof(attr.RawValue));\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperateUnsafeShutdownsFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int UnsafeShutdownsStart = 144;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 13;\n\tmemcpy(attr.RawValue, &NVMeSmartBuf[UnsafeShutdownsStart], sizeof(attr.RawValue));\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperateMediaErrorsFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int MediaErrorsStart = 160;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 14;\n\tmemcpy(attr.RawValue, &NVMeSmartBuf[MediaErrorsStart], sizeof(attr.RawValue));\n\treturn attr;\n}\n\nSMART_ATTRIBUTE SeperateNumberOfErrorsFrom(UCHAR* NVMeSmartBuf)\n{\n\tconst int NumberOfErrorsStart = 176;\n\tSMART_ATTRIBUTE attr = {};\n\tattr.Id = 15;\n\tmemcpy(attr.RawValue, &NVMeSmartBuf[NumberOfErrorsStart], sizeof(attr.RawValue));\n\treturn attr;\n}\n\nvoid NVMeSmartToATASmart(UCHAR* NVMeSmartBuf, void* ATASmartBufUncasted)\n{\n\tSMART_ATTRIBUTE_LIST* ATASmartBuf = (SMART_ATTRIBUTE_LIST*) ATASmartBufUncasted;\n\tint IdxInBuf = 0;\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateCriticalWarningFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateTemperatureFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateAvailableSpareFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateAvailableSpareThresholdFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperatePercentageUsedFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateDataUnitsReadFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateDataUnitsWrittenFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateHostReadCommandsFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateHostWriteCommandsFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateControllerBusyTimeFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperatePowerCyclesFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperatePowerOnHoursFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateUnsafeShutdownsFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateMediaErrorsFrom(NVMeSmartBuf));\n\tAddToATASmartBuf(ATASmartBuf, IdxInBuf++, SeperateNumberOfErrorsFrom(NVMeSmartBuf));\n}"
        },
        {
          "name": "NVMeInterpreter.h",
          "type": "blob",
          "size": 0.7333984375,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : Minkyu Kim\n//          Web : http://naraeon.net/\n//                https://github.com/ebangin127/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n#include <windows.h>\n\nstatic const int MAX_ATTRIBUTE = 30;\nstatic const int NVME_ATTRIBUTE = 15;\n\n#pragma pack(push,1)\ntypedef\tstruct _SMART_ATTRIBUTE\n{\n\tBYTE\tId;\n\tWORD\tStatusFlags;\n\tBYTE\tCurrentValue;\n\tBYTE\tWorstValue;\n\tBYTE\tRawValue[6];\n\tBYTE\tReserved;\n} SMART_ATTRIBUTE;\n#pragma\tpack(pop)\n\ntypedef SMART_ATTRIBUTE SMART_ATTRIBUTE_LIST[MAX_ATTRIBUTE];\n\nvoid NVMeSmartToATASmart(UCHAR* NVMeSmartBuf, void* ATASmartBufUncasted);"
        },
        {
          "name": "Normal.rc",
          "type": "blob",
          "size": 2.599609375,
          "content": "﻿// Microsoft Visual C++ generated resource script.\r\n//\r\n#include \"resourceN.h\"\r\n\r\n#define APSTUDIO_READONLY_SYMBOLS\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Generated from the TEXTINCLUDE 2 resource.\r\n//\r\n#include \"afxres.h\"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n#undef APSTUDIO_READONLY_SYMBOLS\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// 日本語 (日本) resources\r\n\r\n#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_JPN)\r\nLANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT\r\n\r\n#ifdef APSTUDIO_INVOKED\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// TEXTINCLUDE\r\n//\r\n\r\n1 TEXTINCLUDE \r\nBEGIN\r\n    \"resourceN.h\\0\"\r\nEND\r\n\r\n2 TEXTINCLUDE \r\nBEGIN\r\n    \"#include \"\"afxres.h\"\"\\r\\n\"\r\n    \"\\0\"\r\nEND\r\n\r\n3 TEXTINCLUDE \r\nBEGIN\r\n    \"\\r\\n\"\r\n    \"\\0\"\r\nEND\r\n\r\n#endif    // APSTUDIO_INVOKED\r\n\r\n#endif    // 日本語 (日本) resources\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n#ifndef APSTUDIO_INVOKED\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Generated from the TEXTINCLUDE 3 resource.\r\n//\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n#endif    // not APSTUDIO_INVOKED\r\n\r\n"
        },
        {
          "name": "OptionDlg.cpp",
          "type": "blob",
          "size": 18.56640625,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"GraphDlg.h\"\n#include \"OptionDlg.h\"\n\nIMPLEMENT_DYNCREATE(COptionDlg, CDHtmlDialog)\n\nCOptionDlg::COptionDlg(CWnd* pParent /*=NULL*/)\n\t: CDHtmlDialogEx(COptionDlg::IDD, COptionDlg::IDH, pParent)\n{\n\t_tcscpy_s(m_Ini, MAX_PATH, ((CDiskInfoApp*)AfxGetApp())->m_Ini.GetString());\n\t\n\tm_CurrentLangPath = ((CDHtmlMainDialog*)pParent)->m_CurrentLangPath;\n\tm_DefaultLangPath = ((CDHtmlMainDialog*)pParent)->m_DefaultLangPath;\n\tm_ZoomType = ((CDHtmlMainDialog*)pParent)->GetZoomType();\n\n\tfor(int i = 0; i <= CAtaSmart::MAX_DISK; i++)\n\t{\n\t\tm_CurrentLineColor[i] = ((CGraphDlg*)pParent)->GetLineColor(i);\n\t\tm_DefaultLineColor[i] = ((CGraphDlg*)pParent)->m_DefaultLineColor[i];\n\t}\n}\n\nCOptionDlg::~COptionDlg()\n{\n}\n\nvoid COptionDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDHtmlDialogEx::DoDataExchange(pDX);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"LabelThreshold\"), m_LabelThreshold);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"LabelLineColor\"), m_LabelLineColor);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"LabelBkImage\"), m_LabelBkImage);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"BkImage\"), m_BkImage);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"Reset\"), m_Reset);\n\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode0\"), m_ColorCode[0]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode1\"), m_ColorCode[1]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode2\"), m_ColorCode[2]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode3\"), m_ColorCode[3]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode4\"), m_ColorCode[4]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode5\"), m_ColorCode[5]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode6\"), m_ColorCode[6]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode7\"), m_ColorCode[7]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode8\"), m_ColorCode[8]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode9\"), m_ColorCode[9]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode10\"), m_ColorCode[10]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode11\"), m_ColorCode[11]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode12\"), m_ColorCode[12]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode13\"), m_ColorCode[13]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode14\"), m_ColorCode[14]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode15\"), m_ColorCode[15]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode16\"), m_ColorCode[16]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode17\"), m_ColorCode[17]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode18\"), m_ColorCode[18]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode19\"), m_ColorCode[19]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode20\"), m_ColorCode[20]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode21\"), m_ColorCode[21]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode22\"), m_ColorCode[22]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode23\"), m_ColorCode[23]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode24\"), m_ColorCode[24]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode25\"), m_ColorCode[25]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode26\"), m_ColorCode[26]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode27\"), m_ColorCode[27]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode28\"), m_ColorCode[28]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode29\"), m_ColorCode[29]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode30\"), m_ColorCode[30]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode31\"), m_ColorCode[31]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode32\"), m_ColorCode[32]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode33\"), m_ColorCode[33]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode34\"), m_ColorCode[34]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode35\"), m_ColorCode[35]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode36\"), m_ColorCode[36]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode37\"), m_ColorCode[37]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode38\"), m_ColorCode[38]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode39\"), m_ColorCode[39]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode40\"), m_ColorCode[40]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode41\"), m_ColorCode[41]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode42\"), m_ColorCode[42]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode43\"), m_ColorCode[43]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode44\"), m_ColorCode[44]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode45\"), m_ColorCode[45]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode46\"), m_ColorCode[46]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode47\"), m_ColorCode[47]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode48\"), m_ColorCode[48]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode49\"), m_ColorCode[49]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode50\"), m_ColorCode[50]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode51\"), m_ColorCode[51]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode52\"), m_ColorCode[52]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode53\"), m_ColorCode[53]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode54\"), m_ColorCode[54]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode55\"), m_ColorCode[55]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode56\"), m_ColorCode[56]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode57\"), m_ColorCode[57]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode58\"), m_ColorCode[58]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode59\"), m_ColorCode[59]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode60\"), m_ColorCode[60]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode61\"), m_ColorCode[61]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode62\"), m_ColorCode[62]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode63\"), m_ColorCode[63]);\n\tDDX_DHtml_ElementInnerText(pDX, _T(\"ColorCode80\"), m_ColorCode[80]);\n}\n\nBOOL COptionDlg::OnInitDialog()\n{\n\tCDHtmlDialogEx::OnInitDialog();\n\n\tSetWindowText(L\"  \" + i18n(_T(\"WindowTitle\"), _T(\"CUSTOMIZE\")));\n\n\tEnableDpiAware();\n\tInitDialogEx(SIZE_X, SIZE_Y, ((CDiskInfoApp*)AfxGetApp())->m_OptionDlgPath);\n\n\treturn TRUE;\n}\n\nBEGIN_MESSAGE_MAP(COptionDlg, CDHtmlDialogEx)\nEND_MESSAGE_MAP()\n\nBEGIN_DHTML_EVENT_MAP(COptionDlg)\n\tDHTML_EVENT_ONCLICK(_T(\"Select0\"), OnSelect0)\n\tDHTML_EVENT_ONCLICK(_T(\"Select1\"), OnSelect1)\n\tDHTML_EVENT_ONCLICK(_T(\"Select2\"), OnSelect2)\n\tDHTML_EVENT_ONCLICK(_T(\"Select3\"), OnSelect3)\n\tDHTML_EVENT_ONCLICK(_T(\"Select4\"), OnSelect4)\n\tDHTML_EVENT_ONCLICK(_T(\"Select5\"), OnSelect5)\n\tDHTML_EVENT_ONCLICK(_T(\"Select6\"), OnSelect6)\n\tDHTML_EVENT_ONCLICK(_T(\"Select7\"), OnSelect7)\n\tDHTML_EVENT_ONCLICK(_T(\"Select8\"), OnSelect8)\n\tDHTML_EVENT_ONCLICK(_T(\"Select9\"), OnSelect9)\n\tDHTML_EVENT_ONCLICK(_T(\"Select10\"), OnSelect10)\n\tDHTML_EVENT_ONCLICK(_T(\"Select11\"), OnSelect11)\n\tDHTML_EVENT_ONCLICK(_T(\"Select12\"), OnSelect12)\n\tDHTML_EVENT_ONCLICK(_T(\"Select13\"), OnSelect13)\n\tDHTML_EVENT_ONCLICK(_T(\"Select14\"), OnSelect14)\n\tDHTML_EVENT_ONCLICK(_T(\"Select15\"), OnSelect15)\n\tDHTML_EVENT_ONCLICK(_T(\"Select16\"), OnSelect16)\n\tDHTML_EVENT_ONCLICK(_T(\"Select17\"), OnSelect17)\n\tDHTML_EVENT_ONCLICK(_T(\"Select18\"), OnSelect18)\n\tDHTML_EVENT_ONCLICK(_T(\"Select19\"), OnSelect19)\n\tDHTML_EVENT_ONCLICK(_T(\"Select20\"), OnSelect20)\n\tDHTML_EVENT_ONCLICK(_T(\"Select21\"), OnSelect21)\n\tDHTML_EVENT_ONCLICK(_T(\"Select22\"), OnSelect22)\n\tDHTML_EVENT_ONCLICK(_T(\"Select23\"), OnSelect23)\n\tDHTML_EVENT_ONCLICK(_T(\"Select24\"), OnSelect24)\n\tDHTML_EVENT_ONCLICK(_T(\"Select25\"), OnSelect25)\n\tDHTML_EVENT_ONCLICK(_T(\"Select26\"), OnSelect26)\n\tDHTML_EVENT_ONCLICK(_T(\"Select27\"), OnSelect27)\n\tDHTML_EVENT_ONCLICK(_T(\"Select28\"), OnSelect28)\n\tDHTML_EVENT_ONCLICK(_T(\"Select29\"), OnSelect29)\n\tDHTML_EVENT_ONCLICK(_T(\"Select30\"), OnSelect30)\n\tDHTML_EVENT_ONCLICK(_T(\"Select31\"), OnSelect31)\n\tDHTML_EVENT_ONCLICK(_T(\"Select32\"), OnSelect32)\n\tDHTML_EVENT_ONCLICK(_T(\"Select33\"), OnSelect33)\n\tDHTML_EVENT_ONCLICK(_T(\"Select34\"), OnSelect34)\n\tDHTML_EVENT_ONCLICK(_T(\"Select35\"), OnSelect35)\n\tDHTML_EVENT_ONCLICK(_T(\"Select36\"), OnSelect36)\n\tDHTML_EVENT_ONCLICK(_T(\"Select37\"), OnSelect37)\n\tDHTML_EVENT_ONCLICK(_T(\"Select38\"), OnSelect38)\n\tDHTML_EVENT_ONCLICK(_T(\"Select39\"), OnSelect39)\n\tDHTML_EVENT_ONCLICK(_T(\"Select40\"), OnSelect40)\n\tDHTML_EVENT_ONCLICK(_T(\"Select41\"), OnSelect41)\n\tDHTML_EVENT_ONCLICK(_T(\"Select42\"), OnSelect42)\n\tDHTML_EVENT_ONCLICK(_T(\"Select43\"), OnSelect43)\n\tDHTML_EVENT_ONCLICK(_T(\"Select44\"), OnSelect44)\n\tDHTML_EVENT_ONCLICK(_T(\"Select45\"), OnSelect45)\n\tDHTML_EVENT_ONCLICK(_T(\"Select46\"), OnSelect46)\n\tDHTML_EVENT_ONCLICK(_T(\"Select47\"), OnSelect47)\n\tDHTML_EVENT_ONCLICK(_T(\"Select48\"), OnSelect48)\n\tDHTML_EVENT_ONCLICK(_T(\"Select49\"), OnSelect49)\n\tDHTML_EVENT_ONCLICK(_T(\"Select50\"), OnSelect50)\n\tDHTML_EVENT_ONCLICK(_T(\"Select51\"), OnSelect51)\n\tDHTML_EVENT_ONCLICK(_T(\"Select52\"), OnSelect52)\n\tDHTML_EVENT_ONCLICK(_T(\"Select53\"), OnSelect53)\n\tDHTML_EVENT_ONCLICK(_T(\"Select54\"), OnSelect54)\n\tDHTML_EVENT_ONCLICK(_T(\"Select55\"), OnSelect55)\n\tDHTML_EVENT_ONCLICK(_T(\"Select56\"), OnSelect56)\n\tDHTML_EVENT_ONCLICK(_T(\"Select57\"), OnSelect57)\n\tDHTML_EVENT_ONCLICK(_T(\"Select58\"), OnSelect58)\n\tDHTML_EVENT_ONCLICK(_T(\"Select59\"), OnSelect59)\n\tDHTML_EVENT_ONCLICK(_T(\"Select60\"), OnSelect60)\n\tDHTML_EVENT_ONCLICK(_T(\"Select61\"), OnSelect61)\n\tDHTML_EVENT_ONCLICK(_T(\"Select62\"), OnSelect62)\n\tDHTML_EVENT_ONCLICK(_T(\"Select63\"), OnSelect63)\n\tDHTML_EVENT_ONCLICK(_T(\"Select80\"), OnSelect80)\n\n\n\n\tDHTML_EVENT_ONCLICK(_T(\"SelectBkImage\"), OnSelectBkImage)\n\tDHTML_EVENT_ONCLICK(_T(\"NoBkImage\"), OnNoBkImage)\n\tDHTML_EVENT_ONCLICK(_T(\"Reset\"), OnReset)\nEND_DHTML_EVENT_MAP()\n\nvoid COptionDlg::InitDialogComplete()\n{\n\tDebugPrint(_T(\"InitDialogComplete\"));\n\n\tCString cstr;\n\tm_bShowWindow = TRUE;\n\n\tm_LabelThreshold = i18n(_T(\"Dialog\"), _T(\"LIST_THRESHOLD\"));\n\tm_LabelLineColor = i18n(_T(\"Customize\"), _T(\"LINE_COLOR\"));\n\tm_LabelBkImage   = i18n(_T(\"Customize\"), _T(\"BACKGROUND_IMAGE\"));\n\tm_Reset          = i18n(_T(\"Graph\"), _T(\"RESET\"));\n\n\tTCHAR str[256];\n\tGetPrivateProfileStringFx(_T(\"Customize\"), _T(\"GraphBkImage\"), _T(\"\"), str, 256, m_Ini);\n\tm_BkImage = str;\n\tSetElementPropertyEx(_T(\"GraphBkImage\"), DISPID_IHTMLELEMENT_TITLE, m_BkImage);\n\n\tfor(int i = 0; i <= CAtaSmart::MAX_DISK; i++)\n\t{\n\t\tcstr.Format(_T(\"%d\"), i);\n\t\tm_ColorCode[i].Format(_T(\"#%02x%02x%02x\"),\n\t\t\tGetRValue(m_CurrentLineColor[i]),\n\t\t\tGetGValue(m_CurrentLineColor[i]),\n\t\t\tGetBValue(m_CurrentLineColor[i]));\n\t\tCallScript(_T(\"changeBackgroundColor\"), cstr + _T(\", \") + m_ColorCode[i]);\n\t}\n\n\tUpdateData(FALSE);\n\tChangeZoomType(m_ZoomType);\n\tSetClientRect((DWORD)(SIZE_X * m_ZoomRatio), (DWORD)(SIZE_Y * m_ZoomRatio), 0);\n\n\tShowWindow(SW_SHOW);\n}\n\nHRESULT COptionDlg::OnSelect0(IHTMLElement* /*pElement*/){SelectColor(0);return S_FALSE;}\nHRESULT COptionDlg::OnSelect1(IHTMLElement* /*pElement*/){SelectColor(1);return S_FALSE;}\nHRESULT COptionDlg::OnSelect2(IHTMLElement* /*pElement*/){SelectColor(2);return S_FALSE;}\nHRESULT COptionDlg::OnSelect3(IHTMLElement* /*pElement*/){SelectColor(3);return S_FALSE;}\nHRESULT COptionDlg::OnSelect4(IHTMLElement* /*pElement*/){SelectColor(4);return S_FALSE;}\nHRESULT COptionDlg::OnSelect5(IHTMLElement* /*pElement*/){SelectColor(5);return S_FALSE;}\nHRESULT COptionDlg::OnSelect6(IHTMLElement* /*pElement*/){SelectColor(6);return S_FALSE;}\nHRESULT COptionDlg::OnSelect7(IHTMLElement* /*pElement*/){SelectColor(7);return S_FALSE;}\nHRESULT COptionDlg::OnSelect8(IHTMLElement* /*pElement*/){SelectColor(8);return S_FALSE;}\nHRESULT COptionDlg::OnSelect9(IHTMLElement* /*pElement*/){SelectColor(9);return S_FALSE;}\nHRESULT COptionDlg::OnSelect10(IHTMLElement* /*pElement*/){SelectColor(10);return S_FALSE;}\nHRESULT COptionDlg::OnSelect11(IHTMLElement* /*pElement*/){SelectColor(11);return S_FALSE;}\nHRESULT COptionDlg::OnSelect12(IHTMLElement* /*pElement*/){SelectColor(12);return S_FALSE;}\nHRESULT COptionDlg::OnSelect13(IHTMLElement* /*pElement*/){SelectColor(13);return S_FALSE;}\nHRESULT COptionDlg::OnSelect14(IHTMLElement* /*pElement*/){SelectColor(14);return S_FALSE;}\nHRESULT COptionDlg::OnSelect15(IHTMLElement* /*pElement*/){SelectColor(15);return S_FALSE;}\nHRESULT COptionDlg::OnSelect16(IHTMLElement* /*pElement*/){SelectColor(16);return S_FALSE;}\nHRESULT COptionDlg::OnSelect17(IHTMLElement* /*pElement*/){SelectColor(17);return S_FALSE;}\nHRESULT COptionDlg::OnSelect18(IHTMLElement* /*pElement*/){SelectColor(18);return S_FALSE;}\nHRESULT COptionDlg::OnSelect19(IHTMLElement* /*pElement*/){SelectColor(19);return S_FALSE;}\nHRESULT COptionDlg::OnSelect20(IHTMLElement* /*pElement*/){SelectColor(20);return S_FALSE;}\nHRESULT COptionDlg::OnSelect21(IHTMLElement* /*pElement*/){SelectColor(21);return S_FALSE;}\nHRESULT COptionDlg::OnSelect22(IHTMLElement* /*pElement*/){SelectColor(22);return S_FALSE;}\nHRESULT COptionDlg::OnSelect23(IHTMLElement* /*pElement*/){SelectColor(23);return S_FALSE;}\nHRESULT COptionDlg::OnSelect24(IHTMLElement* /*pElement*/){SelectColor(24);return S_FALSE;}\nHRESULT COptionDlg::OnSelect25(IHTMLElement* /*pElement*/){SelectColor(25);return S_FALSE;}\nHRESULT COptionDlg::OnSelect26(IHTMLElement* /*pElement*/){SelectColor(26);return S_FALSE;}\nHRESULT COptionDlg::OnSelect27(IHTMLElement* /*pElement*/){SelectColor(27);return S_FALSE;}\nHRESULT COptionDlg::OnSelect28(IHTMLElement* /*pElement*/){SelectColor(28);return S_FALSE;}\nHRESULT COptionDlg::OnSelect29(IHTMLElement* /*pElement*/){SelectColor(29);return S_FALSE;}\nHRESULT COptionDlg::OnSelect30(IHTMLElement* /*pElement*/){SelectColor(30);return S_FALSE;}\nHRESULT COptionDlg::OnSelect31(IHTMLElement* /*pElement*/){SelectColor(31);return S_FALSE;}\nHRESULT COptionDlg::OnSelect32(IHTMLElement* /*pElement*/){SelectColor(32);return S_FALSE;}\nHRESULT COptionDlg::OnSelect33(IHTMLElement* /*pElement*/){SelectColor(33);return S_FALSE;}\nHRESULT COptionDlg::OnSelect34(IHTMLElement* /*pElement*/){SelectColor(34);return S_FALSE;}\nHRESULT COptionDlg::OnSelect35(IHTMLElement* /*pElement*/){SelectColor(35);return S_FALSE;}\nHRESULT COptionDlg::OnSelect36(IHTMLElement* /*pElement*/){SelectColor(36);return S_FALSE;}\nHRESULT COptionDlg::OnSelect37(IHTMLElement* /*pElement*/){SelectColor(37);return S_FALSE;}\nHRESULT COptionDlg::OnSelect38(IHTMLElement* /*pElement*/){SelectColor(38);return S_FALSE;}\nHRESULT COptionDlg::OnSelect39(IHTMLElement* /*pElement*/){SelectColor(39);return S_FALSE;}\nHRESULT COptionDlg::OnSelect40(IHTMLElement* /*pElement*/){SelectColor(40);return S_FALSE;}\nHRESULT COptionDlg::OnSelect41(IHTMLElement* /*pElement*/){SelectColor(41);return S_FALSE;}\nHRESULT COptionDlg::OnSelect42(IHTMLElement* /*pElement*/){SelectColor(42);return S_FALSE;}\nHRESULT COptionDlg::OnSelect43(IHTMLElement* /*pElement*/){SelectColor(43);return S_FALSE;}\nHRESULT COptionDlg::OnSelect44(IHTMLElement* /*pElement*/){SelectColor(44);return S_FALSE;}\nHRESULT COptionDlg::OnSelect45(IHTMLElement* /*pElement*/){SelectColor(45);return S_FALSE;}\nHRESULT COptionDlg::OnSelect46(IHTMLElement* /*pElement*/){SelectColor(46);return S_FALSE;}\nHRESULT COptionDlg::OnSelect47(IHTMLElement* /*pElement*/){SelectColor(47);return S_FALSE;}\nHRESULT COptionDlg::OnSelect48(IHTMLElement* /*pElement*/){SelectColor(48);return S_FALSE;}\nHRESULT COptionDlg::OnSelect49(IHTMLElement* /*pElement*/){ SelectColor(49); return S_FALSE; }\nHRESULT COptionDlg::OnSelect50(IHTMLElement* /*pElement*/){ SelectColor(50); return S_FALSE; }\nHRESULT COptionDlg::OnSelect51(IHTMLElement* /*pElement*/){ SelectColor(51); return S_FALSE; }\nHRESULT COptionDlg::OnSelect52(IHTMLElement* /*pElement*/){ SelectColor(52); return S_FALSE; }\nHRESULT COptionDlg::OnSelect53(IHTMLElement* /*pElement*/){ SelectColor(53); return S_FALSE; }\nHRESULT COptionDlg::OnSelect54(IHTMLElement* /*pElement*/){ SelectColor(54); return S_FALSE; }\nHRESULT COptionDlg::OnSelect55(IHTMLElement* /*pElement*/){ SelectColor(55); return S_FALSE; }\nHRESULT COptionDlg::OnSelect56(IHTMLElement* /*pElement*/){ SelectColor(56); return S_FALSE; }\nHRESULT COptionDlg::OnSelect57(IHTMLElement* /*pElement*/){ SelectColor(57); return S_FALSE; }\nHRESULT COptionDlg::OnSelect58(IHTMLElement* /*pElement*/){ SelectColor(58); return S_FALSE; }\nHRESULT COptionDlg::OnSelect59(IHTMLElement* /*pElement*/){ SelectColor(59); return S_FALSE; }\nHRESULT COptionDlg::OnSelect60(IHTMLElement* /*pElement*/){ SelectColor(60); return S_FALSE; }\nHRESULT COptionDlg::OnSelect61(IHTMLElement* /*pElement*/){ SelectColor(61); return S_FALSE; }\nHRESULT COptionDlg::OnSelect62(IHTMLElement* /*pElement*/){ SelectColor(62); return S_FALSE; }\nHRESULT COptionDlg::OnSelect63(IHTMLElement* /*pElement*/){ SelectColor(63); return S_FALSE; }\nHRESULT COptionDlg::OnSelect80(IHTMLElement* /*pElement*/){ SelectColor(80); return S_FALSE; }\n\nvoid COptionDlg::SelectColor(DWORD i)\n{\n\tCColorDialog dlg;\n\tif(dlg.DoModal() == IDOK)\n\t{\n\t\tCOLORREF color = dlg.GetColor();\n\t\tCString cstr1, cstr2;\n\t\tcstr1.Format(_T(\"%d\"), i);\n\t\tcstr2.Format(_T(\"#%02x%02x%02x\"), GetRValue(color), GetGValue(color), GetBValue(color));\n\t\tWritePrivateProfileStringFx(_T(\"LineColor\"), cstr1, cstr2, m_Ini);\n\t\tm_ColorCode[i] = cstr2;\n\n\t\tCallScript(_T(\"changeBackgroundColor\"), cstr1 + _T(\", \") + cstr2);\n\t\tUpdateData(FALSE);\n\t\t::PostMessage(m_ParentWnd->GetSafeHwnd(), MY_UPDATE_LINE_COLOR, NULL, NULL);\n\t}\n}\n\nHRESULT COptionDlg::OnSelectBkImage(IHTMLElement* /*pElement*/)\n{\n\tCFileDialog dlg(TRUE, _T(\"\"), _T(\"\"), OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_EXPLORER,\n\t\ti18n(_T(\"Customize\"), _T(\"SUPPORTED_IMAGE_FORMAT\"))\n\t\t+ _T(\"|*.bmp;*.png;*.jpg;*.jpeg;*.gif|BMP (*.bmp)|*.bmp|PNG (*.png)|*.png|JPEG (*.jpg *.jpeg)|*.jpg;*.jpeg|GIF (*.gif)|*.gif;|\")\n\t\t+ i18n(_T(\"Customize\"), _T(\"ALL_FILES\"))\n\t\t+ _T(\" (*.*)|*.*||\"));\n\n\tif(dlg.DoModal() == IDOK)\n\t{\n\t\tm_BkImage = dlg.GetPathName();\n\t\tWritePrivateProfileStringFx(_T(\"Customize\"), _T(\"GraphBkImage\"), m_BkImage, m_Ini);\n\t\tSetElementPropertyEx(_T(\"GraphBkImage\"), DISPID_IHTMLELEMENT_TITLE, m_BkImage);\n\t\tUpdateData(FALSE);\n\t\t::PostMessage(m_ParentWnd->GetSafeHwnd(), MY_UPDATE_BG_IMAGE, NULL, NULL);\n\t}\n\treturn S_FALSE;\n}\n\nHRESULT COptionDlg::OnNoBkImage(IHTMLElement* /*pElement*/)\n{\n\tm_BkImage = _T(\"\");\n\tWritePrivateProfileStringFx(_T(\"Customize\"), _T(\"GraphBkImage\"), m_BkImage, m_Ini);\n\tSetElementPropertyEx(_T(\"GraphBkImage\"), DISPID_IHTMLELEMENT_TITLE, m_BkImage);\n\tUpdateData(FALSE);\n\t::PostMessage(m_ParentWnd->GetSafeHwnd(), MY_UPDATE_BG_IMAGE, NULL, NULL);\n\treturn S_FALSE;\n}\n\nHRESULT COptionDlg::OnReset(IHTMLElement* /*pElement*/)\n{\n\tfor(int i = 0; i <= CAtaSmart::MAX_DISK; i++)\n\t{\n\t\tCOLORREF color = m_DefaultLineColor[i];\n\t\tCString cstr1, cstr2;\n\t\tcstr1.Format(_T(\"%d\"), i);\n\t\tcstr2.Format(_T(\"#%02x%02x%02x\"), GetRValue(color), GetGValue(color), GetBValue(color));\n\t\tWritePrivateProfileStringFx(_T(\"LineColor\"), cstr1, cstr2, m_Ini);\n\t\tm_ColorCode[i] = cstr2;\n\n\t\tCallScript(_T(\"changeBackgroundColor\"), cstr1 + _T(\", \") + cstr2);\n\t}\n\t::PostMessage(m_ParentWnd->GetSafeHwnd(), MY_UPDATE_LINE_COLOR, NULL, NULL);\n\tUpdateData(FALSE);\n\n\treturn S_FALSE;\n}"
        },
        {
          "name": "OptionDlg.h",
          "type": "blob",
          "size": 4.0537109375,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n\n#include \"AtaSmart.h\"\n\nclass COptionDlg : public CDHtmlDialogEx\n{\n\tDECLARE_DYNCREATE(COptionDlg)\n\n\tstatic const int SIZE_X = 480;\n\tstatic const int SIZE_Y = 580;\n\npublic:\n\tCOptionDlg(CWnd* pParent = NULL);\n\tvirtual ~COptionDlg();\n\tCOLORREF m_CurrentLineColor[CAtaSmart::MAX_DISK + 1];\n\tCOLORREF m_DefaultLineColor[CAtaSmart::MAX_DISK + 1];\n\n\tenum { IDD = IDD_OPTION, IDH = IDR_HTML_DUMMY };\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\n\tvirtual BOOL OnInitDialog();\n\tvirtual void InitDialogComplete();\n\n\tCString m_ColorCode[CAtaSmart::MAX_DISK + 1];\n\tCString m_LabelLineColor;\n\tCString m_LabelThreshold;\n\tCString m_LabelBkImage;\n\tCString m_BkImage;\n\tCString m_Reset;\n\n\tHRESULT OnSelect0(IHTMLElement *pElement);\n\tHRESULT OnSelect1(IHTMLElement *pElement);\n\tHRESULT OnSelect2(IHTMLElement *pElement);\n\tHRESULT OnSelect3(IHTMLElement *pElement);\n\tHRESULT OnSelect4(IHTMLElement *pElement);\n\tHRESULT OnSelect5(IHTMLElement *pElement);\n\tHRESULT OnSelect6(IHTMLElement *pElement);\n\tHRESULT OnSelect7(IHTMLElement *pElement);\n\tHRESULT OnSelect8(IHTMLElement *pElement);\n\tHRESULT OnSelect9(IHTMLElement *pElement);\n\tHRESULT OnSelect10(IHTMLElement *pElement);\n\tHRESULT OnSelect11(IHTMLElement *pElement);\n\tHRESULT OnSelect12(IHTMLElement *pElement);\n\tHRESULT OnSelect13(IHTMLElement *pElement);\n\tHRESULT OnSelect14(IHTMLElement *pElement);\n\tHRESULT OnSelect15(IHTMLElement *pElement);\n\tHRESULT OnSelect16(IHTMLElement *pElement);\n\tHRESULT OnSelect17(IHTMLElement *pElement);\n\tHRESULT OnSelect18(IHTMLElement *pElement);\n\tHRESULT OnSelect19(IHTMLElement *pElement);\n\tHRESULT OnSelect20(IHTMLElement *pElement);\n\tHRESULT OnSelect21(IHTMLElement *pElement);\n\tHRESULT OnSelect22(IHTMLElement *pElement);\n\tHRESULT OnSelect23(IHTMLElement *pElement);\n\tHRESULT OnSelect24(IHTMLElement *pElement);\n\tHRESULT OnSelect25(IHTMLElement *pElement);\n\tHRESULT OnSelect26(IHTMLElement *pElement);\n\tHRESULT OnSelect27(IHTMLElement *pElement);\n\tHRESULT OnSelect28(IHTMLElement *pElement);\n\tHRESULT OnSelect29(IHTMLElement *pElement);\n\tHRESULT OnSelect30(IHTMLElement *pElement);\n\tHRESULT OnSelect31(IHTMLElement *pElement);\n\tHRESULT OnSelect32(IHTMLElement *pElement);\n\tHRESULT OnSelect33(IHTMLElement *pElement);\n\tHRESULT OnSelect34(IHTMLElement *pElement);\n\tHRESULT OnSelect35(IHTMLElement *pElement);\n\tHRESULT OnSelect36(IHTMLElement *pElement);\n\tHRESULT OnSelect37(IHTMLElement *pElement);\n\tHRESULT OnSelect38(IHTMLElement *pElement);\n\tHRESULT OnSelect39(IHTMLElement *pElement);\n\tHRESULT OnSelect40(IHTMLElement *pElement);\n\tHRESULT OnSelect41(IHTMLElement *pElement);\n\tHRESULT OnSelect42(IHTMLElement *pElement);\n\tHRESULT OnSelect43(IHTMLElement *pElement);\n\tHRESULT OnSelect44(IHTMLElement *pElement);\n\tHRESULT OnSelect45(IHTMLElement *pElement);\n\tHRESULT OnSelect46(IHTMLElement *pElement);\n\tHRESULT OnSelect47(IHTMLElement *pElement);\n\tHRESULT OnSelect48(IHTMLElement *pElement);\n\tHRESULT OnSelect49(IHTMLElement *pElement);\n\tHRESULT OnSelect50(IHTMLElement *pElement);\n\tHRESULT OnSelect51(IHTMLElement *pElement);\n\tHRESULT OnSelect52(IHTMLElement *pElement);\n\tHRESULT OnSelect53(IHTMLElement *pElement);\n\tHRESULT OnSelect54(IHTMLElement *pElement);\n\tHRESULT OnSelect55(IHTMLElement *pElement);\n\tHRESULT OnSelect56(IHTMLElement *pElement);\n\tHRESULT OnSelect57(IHTMLElement *pElement);\n\tHRESULT OnSelect58(IHTMLElement *pElement);\n\tHRESULT OnSelect59(IHTMLElement *pElement);\n\tHRESULT OnSelect60(IHTMLElement *pElement);\n\tHRESULT OnSelect61(IHTMLElement *pElement);\n\tHRESULT OnSelect62(IHTMLElement *pElement);\n\tHRESULT OnSelect63(IHTMLElement *pElement);\n\tHRESULT OnSelect80(IHTMLElement *pElement);\n\n\tHRESULT OnSelectBkImage(IHTMLElement *pElement);\n\tHRESULT OnNoBkImage(IHTMLElement *pElement);\n\tHRESULT OnReset(IHTMLElement *pElement);\n\n\tvoid SelectColor(DWORD index);\n\n\tDECLARE_MESSAGE_MAP()\n\n\tDECLARE_DHTML_EVENT_MAP()\n\n};\n"
        },
        {
          "name": "Priscilla",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.ja.md",
          "type": "blob",
          "size": 1.712890625,
          "content": "[英語](./README.md) | 日本語 | [中国語（簡体字）](./README.sc.md)\n\n# CrystalDiskInfo\n\n## 概要\nCrystalDiskInfo はディスク情報ツールです。\n\nCrystalDiskInfo は以下に対応しています:\n- PATA ドライブ\n- SATA ドライブ\n\n以下には部分的に対応しています:\n- USB ドライブ\n- RAID コントローラ (IRST)\n- NVMe ドライブ\n- RAID コントローラ (Intel(R) VROC)\n- RAID コントローラ (AMD-RAIDXpert2 *AMD_RC2t7が必要*)\n- USB RAID コントローラ (JMicron JMS56X,JMB39X)\n\n## 通知\nこのリポジトリにはリソースファイルは含まれていないので、以下のリンクからダウンロードして下さい。\n- [ダウンロードページへのリンク](https://crystalmark.info/redirect.php?product=CrystalDiskInfo)\n\n## ビルド\n\n*DiskInfo.sln* を開いてビルドします。\n\n### ノート\n[ダウンロードファイル](https://crystalmark.info/redirect.php?product=CrystalDiskInfo) にある *CdiResource* フォルダーをビルド時に作られた *Rugenia* フォルダーへコピーします。実行時に *CdiResource* フォルダーがない場合、「Not Found \"Graph.html\"」と表示されます。\n\n[AMD_RC2t7](https://thilmera.com/project/AMD_RC2t7/)は[弦生ささとさん](https://twitter.com/thilmera7)によって開発されたAMD RAIDのSMART情報(SATA/NVMe)を取得する機能を提供するライブラリです。\n\n## プロジェクトのページ\n- [Crystal Dew World](https://crystalmark.info/)\n\n## ライセンス\nMIT ライセンス\n- [日本語版](https://crystalmark.info/ja/software/crystaldiskinfo/crystaldiskinfo-license/)\n- [英語版](https://crystalmark.info/en/software/crystaldiskinfo/crystaldiskinfo-license/)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.416015625,
          "content": "English | [Japanese](./README.ja.md) | [Chinese (Simplified)](./README.sc.md)\n\n# CrystalDiskInfo\n\n## Overview\nCrystalDiskInfo is a disk information tool.\n\nCrystalDiskInfo supports:\n- PATA drives\n- SATA drives\n\nPartially supports:\n- USB drives\n- RAID controllers (IRST)\n- NVMe drives\n- RAID controllers (Intel(R) VROC)\n- RAID controllers (AMD-RAIDXpert2 *Requires AMD_RC2t7*)\n- USB RAID controllers (JMicron JMS56X,JMB39X)\n\n## Notification\nThis repository does not include resource files, so please download them from below.\n- [Download for resource files](https://crystalmark.info/redirect.php?product=CrystalDiskInfo)\n\n## Building\n\nOpen *DiskInfo.sln* and build.\n\n### Note\nCopy *CdiResource* folder in the [Download CdiResource](https://crystalmark.info/redirect.php?product=CrystalDiskInfo) to *../Rugenia* folder created in the build. If the *CdiResource* folder does not exist at runtime, the app displays \"*Not Found 'Graph.html'*\".\n\n[AMD_RC2t7](https://thilmera.com/project/AMD_RC2t7/) is a library that provides functionality to acquire SMART information (SATA/NVMe) of AMD RAID. It is developed by [Gakuto Matsumura](https://twitter.com/thilmera7).\n\n## Project Page\n- [Crystal Dew World](https://crystalmark.info/)\n\n## License\nThe MIT License\n- [Japanese version](https://crystalmark.info/ja/software/crystaldiskinfo/crystaldiskinfo-license/)\n- [English version](https://crystalmark.info/en/software/crystaldiskinfo/crystaldiskinfo-license/)\n"
        },
        {
          "name": "README.sc.md",
          "type": "blob",
          "size": 1.4013671875,
          "content": "[英语](./README.md) | [日语](./README.ja.md) | 简体中文\n\n# CrystalDiskInfo\n\n## 简介\nCrystalDiskInfo 是一款查看硬盘信息状况的工具。\n\nCrystalDiskInfo 支持:\n- PATA 设备\n- SATA 设备\n\n仅部分功能支持:\n-USB驱动器\n- RAID控制器（IRST）\n- NVMe驱动器\n- RAID控制器(Intel(R) VROC)\n- RAID控制器(AMD-RAIDXpert2 *需要AMD_RC2t7*)\n- USB RAID控制器(JMicron JMS56X,JMB39X)\n## 小贴士\n这个仓库不包括资源文件，请从点击下方链接下载。\n- [下载资源文件](https://crystalmark.info/redirect.php?product=CrystalDiskInfo)\n\n## 编译\n\n打开 *DiskInfo.sln* 文件并编译。\n\n### 注意\n将[（下载 CdiResource）](https://crystalmark.info/redirect.php?product=CrystalDiskInfo)中的*CdiResource*文件夹复制到编译时创建的*../Rugenia*文件夹中。如果*CdiResource*文件夹在运行时不存在，应用程序会显示 \"*Not Found 'Graph.html'\"。\n\n[AMD_RC2t7](https://thilmera.com/project/AMD_RC2t7/)是一个提供获取AMD RAID的SMART信息（SATA/NVMe）的功能的库，它由[佐佐木玄策](https://twitter.com/thilmera7)开发。\n\n## 本项目的网站\n- [Crystal Dew World](https://crystalmark.info/)\n\n## 开源协议\n本开源项目使用MIT开源协议\n- [日语版本](https://crystalmark.info/ja/software/crystaldiskinfo/crystaldiskinfo-license/)\n- [英语版本](https://crystalmark.info/en/software/crystaldiskinfo/crystaldiskinfo-license/)\n"
        },
        {
          "name": "SPTIUtil.h",
          "type": "blob",
          "size": 1.662109375,
          "content": "﻿//From DDK\n\n#define\tFILE_DEVICE_SCSI\t\t\t\t\t\t\t0x0000001b\n#define\tIOCTL_SCSI_MINIPORT_IDENTIFY\t\t\t\t((FILE_DEVICE_SCSI << 16) + 0x0501)\n#define\tIOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS\t\t((FILE_DEVICE_SCSI << 16) + 0x0502)\n#define IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS\t((FILE_DEVICE_SCSI << 16) + 0x0503)\n#define IOCTL_SCSI_MINIPORT_ENABLE_SMART\t\t\t((FILE_DEVICE_SCSI << 16) + 0x0504)\n#define IOCTL_SCSI_MINIPORT_DISABLE_SMART\t\t\t((FILE_DEVICE_SCSI << 16) + 0x0505)\n\n#define IOCTL_SCSI_BASE                 FILE_DEVICE_CONTROLLER\n#define IOCTL_SCSI_PASS_THROUGH         CTL_CODE(IOCTL_SCSI_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)\n\n//\n// Define values for pass-through DataIn field.\n//\n#define SCSI_IOCTL_DATA_OUT          0\n#define SCSI_IOCTL_DATA_IN           1\n#define SCSI_IOCTL_DATA_UNSPECIFIED  2\n\n//\n// Define the SCSI pass through structure.\n//\ntypedef struct _SCSI_PASS_THROUGH {\n\tUSHORT Length;\n\tUCHAR ScsiStatus;\n\tUCHAR PathId;\n\tUCHAR TargetId;\n\tUCHAR Lun;\n\tUCHAR CdbLength;\n\tUCHAR SenseInfoLength;\n\tUCHAR DataIn;\n\tULONG DataTransferLength;\n\tULONG TimeOutValue;\n\tULONG_PTR DataBufferOffset;\n\tULONG SenseInfoOffset;\n\tUCHAR Cdb[16];\n}SCSI_PASS_THROUGH, *PSCSI_PASS_THROUGH;\n\ntypedef struct _SCSI_PASS_THROUGH_WITH_BUFFERS {\nSCSI_PASS_THROUGH Spt;\nULONG             Filler;      // realign buffers to double word boundary\nUCHAR             SenseBuf[32];\nUCHAR             DataBuf[4096];\n} SCSI_PASS_THROUGH_WITH_BUFFERS, *PSCSI_PASS_THROUGH_WITH_BUFFERS;\n\ntypedef struct _SCSI_PASS_THROUGH_WITH_BUFFERS24 {\n\tSCSI_PASS_THROUGH Spt;\n\tUCHAR             SenseBuf[24];\n\tUCHAR             DataBuf[4096];\n} SCSI_PASS_THROUGH_WITH_BUFFERS24, *PSCSI_PASS_THROUGH_WITH_BUFFERS24;\n"
        },
        {
          "name": "SettingDlg.cpp",
          "type": "blob",
          "size": 17.8623046875,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n#include \"SettingDlg.h\"\n\nIMPLEMENT_DYNCREATE(CSettingDlg, CDialog)\n\nstatic CDiskInfoDlg* p;\n\nCSettingDlg::CSettingDlg(CWnd* pParent /*=NULL*/)\n\t: CDialogFx(CSettingDlg::IDD, pParent)\n{\n\tp = (CDiskInfoDlg*)pParent;\n\n\tm_ZoomType = p->GetZoomType();\n\tm_FontFace = p->GetFontFace();\n\tm_FontScale = p->GetFontScale();\n\tm_FontRatio = p->GetFontRatio();\n\tm_FontRender = p->GetFontRender();\n\tm_CurrentLangPath = p->GetCurrentLangPath();\n\tm_DefaultLangPath = p->GetDefaultLangPath();\n\tm_ThemeDir = p->GetThemeDir();\n\tm_CurrentTheme = p->GetCurrentTheme();\n\tm_DefaultTheme = p->GetDefaultTheme();\n\tm_Ini = p->GetIniPath();\n}\n\nCSettingDlg::~CSettingDlg()\n{\n}\n\nvoid CSettingDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogFx::DoDataExchange(pDX);\n\n\tDDX_Text(pDX, IDC_VALUE_AAM_STATUS, m_AamStatus);\n\tDDX_Text(pDX, IDC_VALUE_APM_STATUS, m_ApmStatus);\n\tDDX_Text(pDX, IDC_LABEL_AAM, m_LabelAam);\n\tDDX_Text(pDX, IDC_LABEL_APM, m_LabelApm);\n\tDDX_Text(pDX, IDC_LABEL_AAM_LOW, m_AamLow);\n\tDDX_Text(pDX, IDC_LABEL_AAM_HIGH, m_AamHigh);\n\tDDX_Text(pDX, IDC_LABEL_AAM_RECOMMEND, m_AamRecommend);\n\tDDX_Text(pDX, IDC_LABEL_APM_LOW, m_ApmLow);\n\tDDX_Text(pDX, IDC_LABEL_APM_HIGH, m_ApmHigh);\n\tDDX_Text(pDX, IDC_VALUE_CURRENT_AAM, m_CurrentAam);\n\tDDX_Text(pDX, IDC_VALUE_RECOMMEND_AAM, m_RecommendAam);\n\tDDX_Text(pDX, IDC_VALUE_CURRENT_APM, m_CurrentApm);\n\tDDX_Text(pDX, IDC_BUTTON_ENABLE_AAM, m_EnableAam);\n\tDDX_Text(pDX, IDC_BUTTON_DISABLE_AAM, m_DisableAam);\n\tDDX_Text(pDX, IDC_BUTTON_ENABLE_APM, m_EnableApm);\n\tDDX_Text(pDX, IDC_BUTTON_DISABLE_APM, m_DisableApm);\n\n\tDDX_Control(pDX, IDC_VALUE_AAM_STATUS, m_CtrlAamStatus);\n\tDDX_Control(pDX, IDC_VALUE_APM_STATUS, m_CtrlApmStatus);\n\tDDX_Control(pDX, IDC_LABEL_AAM, m_CtrlLabelAam);\n\tDDX_Control(pDX, IDC_LABEL_APM, m_CtrlLabelApm);\n\tDDX_Control(pDX, IDC_LABEL_AAM_LOW, m_CtrlLabelAamLow);\n\tDDX_Control(pDX, IDC_LABEL_AAM_HIGH, m_CtrlLabelAamHigh);\n\tDDX_Control(pDX, IDC_LABEL_AAM_RECOMMEND, m_CtrlLabelAamRecommend);\n\tDDX_Control(pDX, IDC_LABEL_APM_LOW, m_CtrlLabelApmLow);\n\tDDX_Control(pDX, IDC_LABEL_APM_HIGH, m_CtrlLabelApmHigh);\n\tDDX_Control(pDX, IDC_VALUE_CURRENT_AAM, m_CtrlCurrentAam);\n\tDDX_Control(pDX, IDC_VALUE_RECOMMEND_AAM, m_CtrlRecommendAam);\n\tDDX_Control(pDX, IDC_VALUE_CURRENT_APM, m_CtrlCurrentApm);\n\tDDX_Control(pDX, IDC_BUTTON_ENABLE_AAM, m_CtrlEnableAam);\n\tDDX_Control(pDX, IDC_BUTTON_DISABLE_AAM, m_CtrlDisableAam);\n\tDDX_Control(pDX, IDC_BUTTON_ENABLE_APM, m_CtrlEnableApm);\n\tDDX_Control(pDX, IDC_BUTTON_DISABLE_APM, m_CtrlDisableApm);\n\tDDX_Control(pDX, IDC_SELECT_DISK, m_CtrlSelectDisk);\n\n\tDDX_Control(pDX, IDC_AAM_SCROLLBAR, m_AamScrollbar);\n\tDDX_Control(pDX, IDC_APM_SCROLLBAR, m_ApmScrollbar);\n}\n\nBOOL CSettingDlg::OnInitDialog()\n{\n\tCDialogFx::OnInitDialog();\n\n\tSetWindowTitle(i18n(_T(\"WindowTitle\"), _T(\"AAM_APM_CONTROL\")));\n\n\tm_AamScrollbar.SetScrollRange(0x80, 0xFE);\n\tm_ApmScrollbar.SetScrollRange(0x01, 0xFE);\n\n\tm_bShowWindow = TRUE;\n\tInitLang();\n\tInitSelectDisk();\n\n\tUpdateDialogSize();\n\t\n\tCenterWindow();\n\tShowWindow(SW_SHOW);\n\n\tif(p->m_Ata.vars.GetCount() == 0)\n\t{\n\t\tm_CtrlSelectDisk.EnableWindow(FALSE);\n\n\t\tm_AamScrollbar.EnableWindow(FALSE);\n\t\tm_ApmScrollbar.EnableWindow(FALSE);\n\n\t\tm_CtrlLabelAam.EnableWindow(FALSE);\n\t\tm_CtrlLabelApm.EnableWindow(FALSE);\n\n\t\tm_CtrlLabelAamLow.EnableWindow(FALSE);\n\t\tm_CtrlLabelAamHigh.EnableWindow(FALSE);\n\t\tm_CtrlLabelAamRecommend.EnableWindow(FALSE);\n\t\tm_CtrlLabelApmLow.EnableWindow(FALSE);\n\t\tm_CtrlLabelApmHigh.EnableWindow(FALSE);\n\n\t\tm_CtrlAamStatus.EnableWindow(FALSE);\n\t\tm_CtrlCurrentAam.EnableWindow(FALSE);\n\t\tm_CtrlRecommendAam.EnableWindow(FALSE);\n\t\tm_CtrlApmStatus.EnableWindow(FALSE);\n\t\tm_CtrlCurrentApm.EnableWindow(FALSE);\n\n\t\tm_CtrlEnableAam.EnableWindow(FALSE);\n\t\tm_CtrlDisableAam.EnableWindow(FALSE);\n\t\tm_CtrlEnableApm.EnableWindow(FALSE);\n\t\tm_CtrlDisableApm.EnableWindow(FALSE);\n\t}\n\treturn TRUE;\n}\n\nvoid CSettingDlg::UpdateDialogSize()\n{\n\tCDialogFx::UpdateDialogSize();\n\n\tChangeZoomType(m_ZoomType);\n\tSetClientSize(SIZE_X, SIZE_Y, m_ZoomRatio);\n\tUpdateBackground(FALSE, m_bDarkMode);\n\n\tm_CtrlLabelAam.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlLabelApm.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\n\tm_CtrlLabelAamLow.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlLabelAamHigh.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlLabelAamRecommend.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlLabelApmLow.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlLabelApmHigh.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\n\tm_CtrlAamStatus.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlCurrentAam.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlRecommendAam.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlApmStatus.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlCurrentApm.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\n\tm_CtrlEnableAam.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlDisableAam.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlEnableApm.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlDisableApm.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\n\tm_CtrlLabelAam.InitControl(8, 44, 384, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, CStaticFx::Border::UNDERLINE);\n\tm_CtrlLabelApm.InitControl(8, 188, 384, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, CStaticFx::Border::UNDERLINE);\n\n\tm_CtrlLabelAamLow.InitControl(16, 72, 160, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlLabelAamHigh.InitControl(176, 72, 160, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlLabelAamRecommend.InitControl(176, 120, 160, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlLabelApmLow.InitControl(16, 216, 160, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlLabelApmHigh.InitControl(176, 216, 160, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_RIGHT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, FALSE);\n\n\tm_CtrlAamStatus.InitControl(344, 72, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlCurrentAam.InitControl(344, 96, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlRecommendAam.InitControl(344, 120, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlApmStatus.InitControl(344, 216, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlCurrentApm.InitControl(344, 240, 40, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\n\tm_CtrlEnableAam.InitControl(220, 148, 160, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlDisableAam.InitControl(20, 148, 160, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlEnableApm.InitControl(220, 272, 160, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlDisableApm.InitControl(20, 272, 160, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, FALSE);\n\n\tm_CtrlSelectDisk.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio);\n\tm_CtrlSelectDisk.InitControl(8, 8, 384, 40, m_ZoomRatio, &m_BkDC, NULL, 0, ES_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, RGB(255, 255, 255), RGB(160, 220, 255), RGB(255, 255, 255), 0);\n\tm_CtrlSelectDisk.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\n\tm_AamScrollbar.MoveWindow((DWORD)(16 * m_ZoomRatio), (DWORD)(96 * m_ZoomRatio), (DWORD)(324 * m_ZoomRatio), (DWORD)(20 * m_ZoomRatio));\n\tm_ApmScrollbar.MoveWindow((DWORD)(16 * m_ZoomRatio), (DWORD)(240 * m_ZoomRatio), (DWORD)(324 * m_ZoomRatio), (DWORD)(20 * m_ZoomRatio));\n\n\tm_CtrlAamStatus.SetDrawFrame(TRUE);\n\tm_CtrlCurrentAam.SetDrawFrame(TRUE);\n\tm_CtrlRecommendAam.SetDrawFrame(TRUE);\n\tm_CtrlApmStatus.SetDrawFrame(TRUE);\n\tm_CtrlCurrentApm.SetDrawFrame(TRUE);\n\n\tm_CtrlEnableAam.SetHandCursor();\n\tm_CtrlDisableAam.SetHandCursor();\n\tm_CtrlEnableApm.SetHandCursor();\n\tm_CtrlDisableApm.SetHandCursor();\n\n\tSetDarkModeControl(m_CtrlEnableAam.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_CtrlDisableAam.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_CtrlEnableApm.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_CtrlDisableApm.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_AamScrollbar.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_ApmScrollbar.GetSafeHwnd(), m_bDarkMode);\n\n\t// SetLayeredWindow(m_CtrlSelectDisk.GetListHwnd(), m_ComboAlpha);\n\tfor (int i = -1; i < m_CtrlSelectDisk.GetCount(); i++)\n\t{\n\t\tm_CtrlSelectDisk.SetItemHeightEx(i, 24, m_ZoomRatio, m_FontRatio);\n\t}\n\n\tInvalidate();\n}\n\nBEGIN_MESSAGE_MAP(CSettingDlg, CDialogFx)\n\tON_WM_HSCROLL()\n\tON_BN_CLICKED(IDC_BUTTON_ENABLE_AAM, &CSettingDlg::OnEnableAam)\n\tON_BN_CLICKED(IDC_BUTTON_ENABLE_APM, &CSettingDlg::OnEnableApm)\n\tON_BN_CLICKED(IDC_BUTTON_DISABLE_AAM, &CSettingDlg::OnDisableAam)\n\tON_BN_CLICKED(IDC_BUTTON_DISABLE_APM, &CSettingDlg::OnDisableApm)\n\tON_CBN_SELCHANGE(IDC_SELECT_DISK, &CSettingDlg::OnCbnSelchangeSelectDisk)\nEND_MESSAGE_MAP()\n\nvoid CSettingDlg::InitLang()\n{\n\tm_AamLow = i18n(_T(\"AamApm\"), _T(\"AAM_LOW\"));\n\tm_AamHigh = i18n(_T(\"AamApm\"), _T(\"AAM_HIGH\"));\n\tm_AamRecommend = i18n(_T(\"AamApm\"), _T(\"AAM_RECOMMEND\"));\n\n\tm_ApmLow = i18n(_T(\"AamApm\"), _T(\"APM_LOW\"));\n\tm_ApmHigh = i18n(_T(\"AamApm\"), _T(\"APM_HIGH\"));\n\n\tm_LabelAam = i18n(_T(\"AamApm\"), _T(\"AUTOMATIC_ACOUSTIC_MANAGEMENT\"));\n\tm_LabelApm = i18n(_T(\"AamApm\"), _T(\"ADVANCED_POWER_MANAGEMENT\"));\n\n\tm_EnableAam = i18n(_T(\"TrayMenu\"), _T(\"ENABLE\"));\n\tm_DisableAam = i18n(_T(\"TrayMenu\"), _T(\"DISABLE\"));\n\tm_EnableApm = i18n(_T(\"TrayMenu\"), _T(\"ENABLE\"));\n\tm_DisableApm = i18n(_T(\"TrayMenu\"), _T(\"DISABLE\"));\n\n\tUpdateData(FALSE);\n}\n\nvoid CSettingDlg::InitSelectDisk()\n{\n\tCString select;\n\tCString cstr;\n\n\tif(p->m_Ata.vars.GetCount() <= 0)\n\t{\n\t\treturn ;\n\t}\n\n\tfor(int i = 0; i < p->m_Ata.vars.GetCount(); i++)\n\t{\n\t\tCString temp;\n\t\tif(p->m_Ata.vars.GetAt(i).IsAamSupported && p->m_Ata.vars.GetAt(i).IsApmSupported)\n\t\t{\n\t\t\ttemp = _T(\"[AAM, APM]\");\t\n\t\t}\n\t\telse if(p->m_Ata.vars.GetAt(i).IsAamSupported)\n\t\t{\n\t\t\ttemp = _T(\"[AAM]\");\t\n\t\t}\n\t\telse if(p->m_Ata.vars.GetAt(i).IsApmSupported)\n\t\t{\n\t\t\ttemp = _T(\"[APM]\");\t\n\t\t}\n\n\t\tCString driveLetter;\n\t\tif (p->m_Ata.vars[i].DriveMap.IsEmpty())\n\t\t{\n\t\t\tif (p->m_Ata.vars[i].PhysicalDriveId >= 0)\n\t\t\t{\n\t\t\t\tdriveLetter.Format(_T(\"(Disk %d)\"), p->m_Ata.vars[i].PhysicalDriveId);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdriveLetter.Format(_T(\"(%s)\"), p->m_Ata.vars[i].DriveMap.GetString());\n\t\t}\n\n\t\tcstr.Format(_T(\"(%02d) %s %s %s\"), i + 1, p->m_Ata.vars.GetAt(i).Model.GetString(), temp.GetString(), driveLetter.GetString());\n\t\tm_CtrlSelectDisk.AddString(cstr);\n\n\t\tif (i == p->GetSelectedDrive())\n\t\t{\n\t\t\tm_CtrlSelectDisk.SetCurSel(i);\n\t\t\tm_DiskIndex = i;\n\t\t}\n\t}\n\n\tUpdateSelectDisk(m_DiskIndex);\n}\n\n/* Memo 2008/11/8\nAamStatus/ApmStatus\n1 : Enabled\n0 : Disabled\n-1: Unsupported\n*/\n\nvoid CSettingDlg::OnEnableAam()\n{\n\tif(! p->m_Ata.vars.GetAt(m_DiskIndex).IsAamSupported)\n\t{\n\t\treturn ;\n\t}\n\n\tint targetValue = m_AamScrollbar.GetScrollPos();\n\tp->m_Ata.EnableAam(m_DiskIndex, (BYTE)targetValue);\n\tp->m_Ata.UpdateIdInfo(m_DiskIndex);\n\n\tif(p->m_Ata.vars.GetAt(m_DiskIndex).IsAamEnabled)\n\t{\n\t\tm_AamStatus = _T(\"ON\");\n\t}\n\tm_AamScrollbar.SetScrollPos(p->m_Ata.GetAamValue(m_DiskIndex));\n\tm_CurrentAam.Format(_T(\"%02Xh\"), p->m_Ata.GetAamValue(m_DiskIndex));\n\tm_RecommendAam.Format(_T(\"%02Xh\"), p->m_Ata.GetRecommendAamValue(m_DiskIndex));\n\tUpdateData(FALSE);\n\n\t// Save Settings\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), targetValue);\n\tWritePrivateProfileStringFx(_T(\"AamStatus\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, _T(\"1\"), m_Ini);\n\tWritePrivateProfileStringFx(_T(\"AamValue\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, cstr, m_Ini);\n}\n\nvoid  CSettingDlg::OnDisableAam()\n{\n\tif(! p->m_Ata.vars.GetAt(m_DiskIndex).IsAamSupported)\n\t{\n\t\treturn ;\n\t}\n\n\tp->m_Ata.DisableAam(m_DiskIndex);\n\tp->m_Ata.UpdateIdInfo(m_DiskIndex);\n\n\tif(! p->m_Ata.vars.GetAt(m_DiskIndex).IsAamEnabled)\n\t{\n\t\tm_AamStatus = _T(\"OFF\");\n\t}\n\tm_AamScrollbar.SetScrollPos(p->m_Ata.GetAamValue(m_DiskIndex));\n\tm_CurrentAam.Format(_T(\"%02Xh\"), p->m_Ata.GetAamValue(m_DiskIndex));\n\tm_RecommendAam.Format(_T(\"%02Xh\"), p->m_Ata.GetRecommendAamValue(m_DiskIndex));\n\tUpdateData(FALSE);\n\n\t// Save Settings\n//\tCString cstr;\n//\tcstr.Format(_T(\"%d\"), m_AamScrollbar.GetScrollPos());\n\tWritePrivateProfileStringFx(_T(\"AamStatus\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, _T(\"0\"), m_Ini);\n//\tWritePrivateProfileStringFx(_T(\"AamValue\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, cstr, m_Ini);\n}\n\nvoid  CSettingDlg::OnEnableApm()\n{\n\tif(! p->m_Ata.vars.GetAt(m_DiskIndex).IsApmSupported)\n\t{\n\t\treturn ;\n\t}\n\n\tint targetValue = m_ApmScrollbar.GetScrollPos();\n\tp->m_Ata.EnableApm(m_DiskIndex, (BYTE)targetValue);\n\tp->m_Ata.UpdateIdInfo(m_DiskIndex);\n\n\tif(p->m_Ata.vars.GetAt(m_DiskIndex).IsApmEnabled)\n\t{\n\t\tm_ApmStatus = _T(\"ON\");\n\t}\n\tm_ApmScrollbar.SetScrollPos(p->m_Ata.GetApmValue(m_DiskIndex));\n\tm_CurrentApm.Format(_T(\"%02Xh\"), p->m_Ata.GetApmValue(m_DiskIndex));\n\tUpdateData(FALSE);\n\n\t// Save Settings\n\tCString cstr;\n\tcstr.Format(_T(\"%d\"), targetValue);\n\tWritePrivateProfileStringFx(_T(\"ApmStatus\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, _T(\"1\"), m_Ini);\n\tWritePrivateProfileStringFx(_T(\"ApmValue\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, cstr, m_Ini);\n}\n\nvoid  CSettingDlg::OnDisableApm()\n{\n\tif(! p->m_Ata.vars.GetAt(m_DiskIndex).IsApmSupported)\n\t{\n\t\treturn ;\n\t}\n\n\tp->m_Ata.DisableApm(m_DiskIndex);\n\tp->m_Ata.UpdateIdInfo(m_DiskIndex);\n\n\tif(! p->m_Ata.vars.GetAt(m_DiskIndex).IsApmEnabled)\n\t{\n\t\tm_ApmStatus = _T(\"OFF\");\n\t}\n\tm_ApmScrollbar.SetScrollPos(p->m_Ata.GetApmValue(m_DiskIndex));\n\tm_CurrentApm.Format(_T(\"%02Xh\"), p->m_Ata.GetApmValue(m_DiskIndex));\n\tUpdateData(FALSE);\n\n\t// Save Settings\n//\tCString cstr;\n//\tcstr.Format(_T(\"%d\"), m_ApmScrollbar.GetScrollPos());\n\tWritePrivateProfileStringFx(_T(\"ApmStatus\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, _T(\"0\"), m_Ini);\n//\tWritePrivateProfileStringFx(_T(\"ApmValue\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, cstr, m_Ini);\n}\n\nvoid CSettingDlg::UpdateSelectDisk(DWORD index)\n{\n\tm_AamScrollbar.SetScrollPos(p->m_Ata.GetAamValue(index));\n\tm_CurrentAam.Format(_T(\"%02Xh\"), p->m_Ata.GetAamValue(index));\n\tm_RecommendAam.Format(_T(\"%02Xh\"), p->m_Ata.GetRecommendAamValue(index));\n\n\tm_ApmScrollbar.SetScrollPos(p->m_Ata.GetApmValue(index));\n\tm_CurrentApm.Format(_T(\"%02Xh\"), p->m_Ata.GetApmValue(index));\n\n\tif(p->m_Ata.vars.GetAt(index).IsAamSupported \n\t\t&& p->m_Ata.vars.GetAt(index).CommandType != p->m_Ata.CMD_TYPE_SCSI_MINIPORT\n\t\t&& p->m_Ata.vars.GetAt(index).CommandType != p->m_Ata.CMD_TYPE_SILICON_IMAGE\n\t\t&& p->m_Ata.vars.GetAt(index).CommandType != p->m_Ata.CMD_TYPE_CSMI\n\t\t)\n\t{\n\t\tm_AamScrollbar.EnableWindow(TRUE);\n\t\tm_CtrlEnableAam.EnableWindow(TRUE);\n\t\tm_CtrlDisableAam.EnableWindow(TRUE);\n\t\tif(p->m_Ata.vars.GetAt(index).IsAamEnabled)\n\t\t{\n\t\t\tm_AamStatus = _T(\"ON\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_AamStatus = _T(\"OFF\");\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_AamScrollbar.EnableWindow(FALSE);\n\t\tm_CtrlEnableAam.EnableWindow(FALSE);\n\t\tm_CtrlDisableAam.EnableWindow(FALSE);\n\t\tm_AamStatus = _T(\"\");\n\t\tm_CurrentAam = _T(\"\");\n\t\tm_RecommendAam = _T(\"\");\n\t}\n\n\tif(p->m_Ata.vars.GetAt(index).IsApmSupported\n\t\t&& p->m_Ata.vars.GetAt(index).CommandType != p->m_Ata.CMD_TYPE_SCSI_MINIPORT\n\t\t&& p->m_Ata.vars.GetAt(index).CommandType != p->m_Ata.CMD_TYPE_SILICON_IMAGE\n\t\t&& p->m_Ata.vars.GetAt(index).CommandType != p->m_Ata.CMD_TYPE_CSMI\n\t\t)\n\t{\n\t\tm_ApmScrollbar.EnableWindow(TRUE);\n\t\tm_CtrlEnableApm.EnableWindow(TRUE);\n\t\tm_CtrlDisableApm.EnableWindow(TRUE);\n\t\tif(p->m_Ata.vars.GetAt(index).IsApmEnabled)\n\t\t{\n\t\t\tm_ApmStatus = _T(\"ON\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_ApmStatus = _T(\"OFF\");\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_ApmScrollbar.EnableWindow(FALSE);\n\t\tm_CtrlEnableApm.EnableWindow(FALSE);\n\t\tm_CtrlDisableApm.EnableWindow(FALSE);\n\t\tm_ApmStatus = _T(\"\");\n\t\tm_CurrentApm = _T(\"\");\n\t}\n\n\tUpdateData(FALSE);\n}\n\nvoid CSettingDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)\n{\n\tint position = pScrollBar->GetScrollPos();\n\tswitch(nSBCode)\n\t{\n\n\tcase SB_LINELEFT:\n\t\tposition -= 1;\n\t\tbreak;\n\tcase SB_LINERIGHT:\n\t\tposition += 1;\n\t\tbreak;\n\tcase SB_PAGELEFT:\n\t\tposition -= 8;\n\t\tbreak;\n\tcase SB_PAGERIGHT:\n\t\tposition += 8;\n\t\tbreak;\n\tcase SB_LEFT:\n\t\tbreak;\n\tcase SB_RIGHT:\n\t\tbreak;\n\tcase SB_THUMBTRACK:\n\t\tposition = nPos;\n\t\tbreak;\n\t}\n\tpScrollBar->SetScrollPos(position);\n\n\tif(*pScrollBar == m_AamScrollbar)\n\t{\n\t\tm_CurrentAam.Format(_T(\"%02Xh\"), m_AamScrollbar.GetScrollPos());\n\t}\n\telse if(*pScrollBar == m_ApmScrollbar)\n\t{\n\t\tm_CurrentApm.Format(_T(\"%02Xh\"), m_ApmScrollbar.GetScrollPos());\n\t}\n\n\tUpdateData(FALSE);\n\t\n\tCDialogFx::OnHScroll(nSBCode, nPos, pScrollBar);\n}\n\n\nvoid CSettingDlg::OnCbnSelchangeSelectDisk()\n{\n\tif(m_DiskIndex != m_CtrlSelectDisk.GetCurSel())\n\t{\n\t\tm_DiskIndex = m_CtrlSelectDisk.GetCurSel();\n\t\tUpdateSelectDisk(m_DiskIndex);\n\t}\n}\n"
        },
        {
          "name": "SettingDlg.h",
          "type": "blob",
          "size": 2.09375,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n//\n//                                Copyright 2008 hiyohiyo. All rights reserved.\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n#include \"afxwin.h\"\n#include \"DialogFx.h\"\n\n#include \"StaticFx.h\"\n#include \"ButtonFx.h\"\n#include \"ComboBoxFx.h\"\n\nclass CSettingDlg : public CDialogFx\n{\n\tDECLARE_DYNCREATE(CSettingDlg)\n\n\tstatic const int SIZE_X = 400;\n\tstatic const int SIZE_Y = 304;\n\npublic:\n\tCSettingDlg(CWnd* pParent = NULL);\n\tvirtual ~CSettingDlg();\n\n\tenum { IDD = IDD_SETTING };\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\n\tvirtual BOOL OnInitDialog();\n\tvirtual void UpdateDialogSize();\n\n\tvoid InitSelectDisk();\n\tvoid InitLang();\n\n\tvoid OnEnableAam();\n\tvoid OnDisableAam();\n\tvoid OnEnableApm();\n\tvoid OnDisableApm();\n\n\tvoid UpdateSelectDisk(DWORD index);\n\n\tDECLARE_MESSAGE_MAP()\n\tafx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);\n\tafx_msg void OnCbnSelchangeSelectDisk();\n\n\tDWORD m_DiskIndex;\n\tCString m_SelectDisk;\n\tCString m_AamLow;\n\tCString m_AamHigh;\n\tCString m_AamRecommend;\n\tCString m_ApmLow;\n\tCString m_ApmHigh;\n\tCString m_AamStatus;\n\tCString m_ApmStatus;\n\tCString m_LabelAam;\n\tCString m_LabelApm;\n\tCString m_CurrentAam;\n\tCString m_RecommendAam;\n\tCString m_CurrentApm;\n\tCString m_EnableAam;\n\tCString m_DisableAam;\n\tCString m_EnableApm;\n\tCString m_DisableApm;\n\n\tCStaticFx m_CtrlAamStatus;\n\tCStaticFx m_CtrlApmStatus;\n\tCStaticFx m_CtrlCurrentAam;\n\tCStaticFx m_CtrlCurrentApm;\n\tCStaticFx m_CtrlRecommendAam;\n\tCStaticFx m_CtrlLabelAam;\n\tCStaticFx m_CtrlLabelApm;\n\tCStaticFx m_CtrlLabelAamLow;\n\tCStaticFx m_CtrlLabelAamHigh;\n\tCStaticFx m_CtrlLabelAamRecommend;\n\tCStaticFx m_CtrlLabelApmLow;\n\tCStaticFx m_CtrlLabelApmHigh;\n\n\tCButtonFx m_CtrlEnableAam;\n\tCButtonFx m_CtrlDisableAam;\n\tCButtonFx m_CtrlEnableApm;\n\tCButtonFx m_CtrlDisableApm;\n\tCComboBoxFx\tm_CtrlSelectDisk;\n\tCScrollBar m_AamScrollbar;\n\tCScrollBar m_ApmScrollbar;\n};\n"
        },
        {
          "name": "Shizuku.rc",
          "type": "blob",
          "size": 2.599609375,
          "content": "﻿// Microsoft Visual C++ generated resource script.\r\n//\r\n#include \"resourceS.h\"\r\n\r\n#define APSTUDIO_READONLY_SYMBOLS\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Generated from the TEXTINCLUDE 2 resource.\r\n//\r\n#include \"afxres.h\"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n#undef APSTUDIO_READONLY_SYMBOLS\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// 日本語 (日本) resources\r\n\r\n#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_JPN)\r\nLANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT\r\n\r\n#ifdef APSTUDIO_INVOKED\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// TEXTINCLUDE\r\n//\r\n\r\n1 TEXTINCLUDE \r\nBEGIN\r\n    \"resourceS.h\\0\"\r\nEND\r\n\r\n2 TEXTINCLUDE \r\nBEGIN\r\n    \"#include \"\"afxres.h\"\"\\r\\n\"\r\n    \"\\0\"\r\nEND\r\n\r\n3 TEXTINCLUDE \r\nBEGIN\r\n    \"\\r\\n\"\r\n    \"\\0\"\r\nEND\r\n\r\n#endif    // APSTUDIO_INVOKED\r\n\r\n#endif    // 日本語 (日本) resources\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n#ifndef APSTUDIO_INVOKED\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Generated from the TEXTINCLUDE 3 resource.\r\n//\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n#endif    // not APSTUDIO_INVOKED\r\n\r\n"
        },
        {
          "name": "SlotSpeedGetter.cpp",
          "type": "blob",
          "size": 6.7041015625,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : Minkyu Kim\n//          Web : http://naraeon.net/\n//                https://github.com/ebangin127/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"SlotSpeedGetter.h\"\n#include <wbemcli.h>\n#include <comutil.h>\n#include <Setupapi.h>\n#include <Cfgmgr32.h>\n//#pragma comment(lib, \"Cfgmgr32.lib\")\n#pragma comment(lib, \"Setupapi.lib\")\n#pragma comment(lib, \"wbemuuid.lib\")\n#define SAFE_RELEASE(p) { if(p) { (p)->Release(); (p)=NULL; } }\n\nDEFINE_GUID(GUID_DEVCLASS_SCSIADAPTER, 0x4D36E97B, 0xE325, 0x11CE, 0xBF, 0xC1, 0x08, 0x00, 0x2B, 0xE1, 0x03, 0x18);\n\n\ntypedef BOOL(WINAPI *FN_SetupDiGetDeviceProperty)(\n\t__in       HDEVINFO DeviceInfoSet,\n\t__in       PSP_DEVINFO_DATA DeviceInfoData,\n\t__in       const DEVPROPKEY *PropertyKey,\n\t__out      DEVPROPTYPE *PropertyType,\n\t__out_opt  PBYTE PropertyBuffer,\n\t__in       DWORD PropertyBufferSize,\n\t__out_opt  PDWORD RequiredSize,\n\t__in       DWORD Flags\n\t);\n\nCString GetStringValueFromQuery(IWbemServices* pIWbemServices, const CString query, const CString valuename)\n{\n\tIEnumWbemClassObject* pEnumCOMDevs = NULL;\n\tIWbemClassObject* pCOMDev = NULL;\n\tULONG uReturned = 0;\n\tCString\tresult = L\"\";\n\n\ttry\n\t{\n\t\tif (SUCCEEDED(pIWbemServices->ExecQuery(_bstr_t(L\"WQL\"),\n\t\t\t_bstr_t(query), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnumCOMDevs)))\n\t\t{\n\t\t\twhile (pEnumCOMDevs && SUCCEEDED(pEnumCOMDevs->Next(10000, 1, &pCOMDev, &uReturned)) && uReturned == 1)\n\t\t\t{\n\t\t\t\tVARIANT pVal;\n\t\t\t\tVariantInit(&pVal);\n\n\t\t\t\tif (pCOMDev->Get(L\"DeviceID\", 0L, &pVal, NULL, NULL) == WBEM_S_NO_ERROR && pVal.vt > VT_NULL)\n\t\t\t\t{\n\t\t\t\t\tresult = pVal.bstrVal;\n\t\t\t\t\tVariantClear(&pVal);\n\t\t\t\t}\n\t\t\t\tVariantInit(&pVal);\n\t\t\t}\n\t\t}\n\t}\n\tcatch (...)\n\t{\n\t\tresult = L\"\";\n\t}\n\n\tSAFE_RELEASE(pCOMDev);\n\tSAFE_RELEASE(pEnumCOMDevs);\n\treturn result;\n}\n\nCString GetDeviceIDFromPhysicalDriveID(const INT physicalDriveId, const BOOL IsKernelVerEqualOrOver6)\n{\n\tconst CString query2findstorage = L\"ASSOCIATORS OF {Win32_DiskDrive.DeviceID='\\\\\\\\.\\\\PhysicalDrive%d'} WHERE ResultClass=Win32_PnPEntity\";\n\tconst CString query2findcontroller = L\"ASSOCIATORS OF {Win32_PnPEntity.DeviceID='%s'} WHERE AssocClass=Win32_SCSIControllerDevice\";\n\tCString query;\n\tCString result;\n\tIWbemLocator* pIWbemLocator = NULL;\n\tIWbemServices* pIWbemServices = NULL;\n\t//BOOL flag = FALSE;\n\n\ttry\n\t{\n\t\tif (SUCCEEDED(CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,\n\t\t\tIID_IWbemLocator, (LPVOID *)&pIWbemLocator)))\n\t\t{\n\t\t\tlong securityFlag = 0;\n\t\t\tif (IsKernelVerEqualOrOver6) { securityFlag = WBEM_FLAG_CONNECT_USE_MAX_WAIT; }\n\t\t\tif (SUCCEEDED(pIWbemLocator->ConnectServer(_bstr_t(L\"\\\\\\\\.\\\\root\\\\cimv2\"),\n\t\t\t\tNULL, NULL, 0L, securityFlag, NULL, NULL, &pIWbemServices)))\n\t\t\t{\n\t\t\t\tif (SUCCEEDED(CoSetProxyBlanket(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,\n\t\t\t\t\tNULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE)))\n\t\t\t\t{\n\t\t\t\t\tquery.Format(query2findstorage, physicalDriveId);\n\t\t\t\t\tCString StorageID = GetStringValueFromQuery(pIWbemServices, query, L\"DeviceID\");\n\t\t\t\t\tif(!StorageID.IsEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tquery.Format(query2findcontroller.GetString(), StorageID.GetString());\n\t\t\t\t\t\tCString ControllerID = GetStringValueFromQuery(pIWbemServices, query, L\"DeviceID\");\n\t\t\t\t\t\tresult = ControllerID;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = L\"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcatch (...)\n\t{\n\t\tresult = L\"\";\n\t}\n\tSAFE_RELEASE(pIWbemServices);\n\tSAFE_RELEASE(pIWbemLocator);\n\treturn result;\n}\n\nSlotMaxCurrSpeed ConvertOSResult(const OSSlotMaxCurrSpeed OSLevelResult)\n{\n\tSlotMaxCurrSpeed result{};\n\tresult.Current.LinkWidth = PCIeDataWidth(OSLevelResult.Current.LinkWidth);\n\tresult.Current.SpecVersion = PCIeSpecification(OSLevelResult.Current.SpecVersion);\n\tresult.Maximum.LinkWidth = PCIeDataWidth(OSLevelResult.Maximum.LinkWidth);\n\tresult.Maximum.SpecVersion = PCIeSpecification(OSLevelResult.Maximum.SpecVersion);\n\treturn result;\n}\n\nSlotMaxCurrSpeed GetSlotMaxCurrSpeedFromDeviceID(const CString DeviceID)\n{\n\tDWORD CurrentDevice = 0;\n\tOSSlotMaxCurrSpeed OSLevelResult{};\n\tGUID SCSIAdapterGUID = GUID_DEVCLASS_SCSIADAPTER;\n\tHDEVINFO ClassDeviceInformations = SetupDiGetClassDevs(&SCSIAdapterGUID, nullptr, 0, DIGCF_PRESENT);\n\n\tBOOL LastResult{};\n\tdo\n\t{\n\t\tSP_DEVINFO_DATA DeviceInfoData = {sizeof(SP_DEVINFO_DATA)};\n\t\tLastResult = SetupDiEnumDeviceInfo(ClassDeviceInformations, CurrentDevice, &DeviceInfoData);\n\n\t\tBOOL DeviceIDFound = FALSE;\t\n\t\tTCHAR DeviceIDBuffer[MAX_PATH] = {};\n\t\tBOOL GetDeviceResult = CM_Get_Device_ID(DeviceInfoData.DevInst, DeviceIDBuffer, MAX_PATH, 0);\n\t\tDeviceIDFound = (GetDeviceResult == ERROR_SUCCESS) && (DeviceID.Compare(DeviceIDBuffer) == 0);\n\t\tif (LastResult && DeviceIDFound)\n\t\t{\n\t\t\tDEVPROPTYPE PropertyType{};\n\t\t\tBYTE ResultBuffer[1024]{};\n\t\t\tDWORD RequiredSize{};\n\n\t\t\tconst HMODULE hMod = LoadLibrary(TEXT(\"Setupapi.dll\"));\n\t\t\tif (hMod && hMod != INVALID_HANDLE_VALUE) {\n\t\t\t\tFN_SetupDiGetDeviceProperty SetupDiGetDeviceProperty =\n\t\t\t\t\t(FN_SetupDiGetDeviceProperty)GetProcAddress(hMod, \"SetupDiGetDevicePropertyW\");\n\t\t\t\t//Compatible with pre-vista era windows.\n\t\t\t\tif (SetupDiGetDeviceProperty) {\n\t\t\t\t\tSetupDiGetDeviceProperty(ClassDeviceInformations, &DeviceInfoData,\n\t\t\t\t\t\t&DEVPKEY_PciDevice_MaxLinkWidth, &PropertyType, ResultBuffer,\n\t\t\t\t\t\tsizeof(ResultBuffer), &RequiredSize, 0);\n\t\t\t\t\tOSLevelResult.Maximum.LinkWidth = ResultBuffer[0];\n\t\t\t\t\tSetupDiGetDeviceProperty(ClassDeviceInformations, &DeviceInfoData,\n\t\t\t\t\t\t&DEVPKEY_PciDevice_MaxLinkSpeed, &PropertyType, ResultBuffer,\n\t\t\t\t\t\tsizeof(ResultBuffer), &RequiredSize, 0);\n\t\t\t\t\tOSLevelResult.Maximum.SpecVersion = ResultBuffer[0];\n\n\t\t\t\t\tSetupDiGetDeviceProperty(ClassDeviceInformations, &DeviceInfoData,\n\t\t\t\t\t\t&DEVPKEY_PciDevice_CurrentLinkWidth, &PropertyType, ResultBuffer,\n\t\t\t\t\t\tsizeof(ResultBuffer), &RequiredSize, 0);\n\t\t\t\t\tOSLevelResult.Current.LinkWidth = ResultBuffer[0];\n\t\t\t\t\tSetupDiGetDeviceProperty(ClassDeviceInformations, &DeviceInfoData,\n\t\t\t\t\t\t&DEVPKEY_PciDevice_CurrentLinkSpeed, &PropertyType, ResultBuffer,\n\t\t\t\t\t\tsizeof(ResultBuffer), &RequiredSize, 0);\n\t\t\t\t\tOSLevelResult.Current.SpecVersion = ResultBuffer[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t++CurrentDevice;\n\t} while (LastResult);\n\n\treturn ConvertOSResult(OSLevelResult);\n}\n\nSlotMaxCurrSpeed GetPCIeSlotSpeed(const INT physicalDriveId, const BOOL IsKernelVerEqualOrOver6)\n{\n\tCString DeviceID = GetDeviceIDFromPhysicalDriveID(physicalDriveId, IsKernelVerEqualOrOver6);\n\treturn GetSlotMaxCurrSpeedFromDeviceID(DeviceID);\n}\n\nCString SlotSpeedToString(SlotSpeed speedtoconv)\n{\n\tCString result = L\"\";\n\tif (speedtoconv.SpecVersion == 0 || speedtoconv.LinkWidth == 0)\n\t{\n\t\tresult.Format(L\"----\");\n\t}\n\telse\n\t{\n\t\tresult.Format(L\"PCIe %d.0 x%d\", speedtoconv.SpecVersion, speedtoconv.LinkWidth);\n\t}\n\treturn result;\n}"
        },
        {
          "name": "SlotSpeedGetter.h",
          "type": "blob",
          "size": 1.5673828125,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : Minkyu Kim\n//          Web : http://naraeon.net/\n//                https://github.com/ebangin127/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n#include <initguid.h>\n#include <devpkey.h>\n\ntypedef enum _PCIeSpecification  {\n\tPCIe1d0 = 1,\n\tPCIe2d0 = 2,\n\tPCIe3d0 = 3,\n\tPCIe4d0 = 4,\n\tPCIe5d0 = 5\n} PCIeSpecification;\n\ntypedef enum _PCIeDataWidth {\n\tPCIex1 = 1,\n\tPCIex2 = 2,\n\tPCIex4 = 4,\n\tPCIex8 = 8,\n\tPCIex12 = 12,\n\tPCIex16 = 16,\n\tPCIex32 = 32\n} PCIeDataWidth;\n\ntypedef struct _SlotSpeed  {\n\tPCIeSpecification SpecVersion;\n\tPCIeDataWidth LinkWidth;\n} SlotSpeed;\n\ntypedef struct _SlotMaxCurrSpeed {\n\tSlotSpeed Maximum;\n\tSlotSpeed Current;\n} SlotMaxCurrSpeed;\n\ntypedef struct _OSSlotSpeed {\n\tBYTE SpecVersion;\n\tBYTE LinkWidth;\n} OSSlotSpeed;\n\ntypedef struct _OSSlotMaxCurrSpeed {\n\tOSSlotSpeed Maximum;\n\tOSSlotSpeed Current;\n} OSSlotMaxCurrSpeed;\n\n#define DEFINE_PCI_DEVICE_DEVPKEY(_DevPkeyName, _Pid) \\\n   DEFINE_DEVPROPKEY((_DevPkeyName), 0x3ab22e31, 0x8264, 0x4b4e, 0x9a, 0xf5, 0xa8, 0xd2, 0xd8, 0xe3, 0x3e, 0x62, (_Pid))\n\nDEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_CurrentLinkSpeed, 9);\nDEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_CurrentLinkWidth, 10);\nDEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_MaxLinkSpeed, 11);\nDEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_MaxLinkWidth, 12);\n\nSlotMaxCurrSpeed GetPCIeSlotSpeed(const INT physicalDriveId, const BOOL IsKernelVerEqualOrOver6);\nCString SlotSpeedToString(SlotSpeed speedtoconv);"
        },
        {
          "name": "SoundSettingDlg.cpp",
          "type": "blob",
          "size": 7.5625,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n#include \"SoundSettingDlg.h\"\n\nIMPLEMENT_DYNCREATE(CSoundSettingDlg, CDialog)\n\nstatic CDiskInfoDlg* p;\n\nCSoundSettingDlg::CSoundSettingDlg(CWnd* pParent /*=NULL*/)\n\t: CDialogFx(CDiskInfoDlg::IDD, pParent)\n{\n\tp = (CDiskInfoDlg*)pParent;\n\n\tm_ZoomType = p->GetZoomType();\n\tm_FontFace = p->GetFontFace();\n\tm_FontScale = p->GetFontScale();\n\tm_FontRatio = p->GetFontRatio();\n\tm_FontRender = p->GetFontRender();\n\tm_CurrentLangPath = p->GetCurrentLangPath();\n\tm_DefaultLangPath = p->GetDefaultLangPath();\n\tm_ThemeDir = p->GetThemeDir();\n\tm_CurrentTheme = p->GetCurrentTheme();\n\tm_DefaultTheme = p->GetDefaultTheme();\n\tm_Ini = p->GetIniPath();\n}\n\nCSoundSettingDlg::~CSoundSettingDlg()\n{\n}\n\nvoid CSoundSettingDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogFx::DoDataExchange(pDX);\n\n\tDDX_Text(pDX, IDC_FILE_PATH, m_FilePath);\n\n\tDDX_Control(pDX, IDC_FILE_PATH, m_CtrlFilePath);\n\tDDX_Control(pDX, IDC_BUTTON_SELECT_FILE, m_CtrlSelectFile);\n\tDDX_Control(pDX, IDC_BUTTON_PLAY, m_CtrlPlay);\n\tDDX_Control(pDX, IDC_SLIDER_VOLUME, m_CtrlSlider);\n\tDDX_Control(pDX, IDC_STATIC_VOLUME, m_CtrlVolume);\n\tDDX_Control(pDX, IDC_VALUE_VOLUME, m_CtrlValueVolume);\n\tDDX_Control(pDX, IDC_BUTTON_DEFAULT, m_CtrlDefault);\n\tDDX_Control(pDX, IDC_BUTTON_OK, m_CtrlOk);\n}\n\nBOOL CSoundSettingDlg::OnInitDialog()\n{\n\tCDialogFx::OnInitDialog();\n\n\tSetWindowTitle(i18n(_T(\"WindowTitle\"), _T(\"SOUND_SETTINGS\")));\n\n\tm_bShowWindow = TRUE;\n\n\tTCHAR str[256];\n\tGetPrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertSoundPath\"), _T(\"\"), str, 256, m_Ini);\n\tm_FilePath = str;\n\tUpdateData(FALSE);\n\n\tm_InitialVolume = GetPrivateProfileInt(_T(\"Setting\"), _T(\"AlertSoundVolume\"), 80, m_Ini);\n\tif (m_InitialVolume < 0 || m_InitialVolume > 100)\n\t{\n\t\tm_InitialVolume = 80;\n\t}\n\tm_CurrentVolume = m_InitialVolume;\n\tCString cstr;\n\tcstr.Format(L\"%d\", m_CurrentVolume);\n\tm_CtrlValueVolume.SetWindowTextW(cstr);\n\n\tm_CtrlDefault.SetWindowTextW(i18n(_T(\"HealthStatus\"), _T(\"DEFAULT\")));\n\tm_CtrlOk.SetWindowTextW(i18n(_T(\"Dialog\"), _T(\"OK\")));\n\n\tUpdateDialogSize();\n\n\tCenterWindow();\n\tShowWindow(SW_SHOW);\n\n\treturn TRUE;\n}\n\nBEGIN_MESSAGE_MAP(CSoundSettingDlg, CDialogFx)\n\tON_WM_CTLCOLOR()\n\tON_WM_HSCROLL()\n\tON_BN_CLICKED(IDC_BUTTON_SELECT_FILE, &CSoundSettingDlg::OnSelectFile)\n\tON_BN_CLICKED(IDC_BUTTON_PLAY, &CSoundSettingDlg::OnPlay)\n\tON_BN_CLICKED(IDC_BUTTON_DEFAULT, &CSoundSettingDlg::OnDefault)\n\tON_BN_CLICKED(IDC_BUTTON_OK, &CSoundSettingDlg::OnOk)\nEND_MESSAGE_MAP()\n\nvoid CSoundSettingDlg::UpdateDialogSize()\n{\n\tCDialogFx::UpdateDialogSize();\n\n\tChangeZoomType(m_ZoomType);\n\tSetClientSize(SIZE_X, SIZE_Y, m_ZoomRatio);\n\tUpdateBackground(FALSE, m_bDarkMode);\n\n\tm_CtrlFilePath.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlSelectFile.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlPlay.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlValueVolume.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlDefault.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlOk.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\n\tm_CtrlFilePath.InitControl(8, 8, 416, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlSelectFile.InitControl(428, 8, 24, 24, m_ZoomRatio, &m_BkDC, IP(L\"selectSound\"), 2, BS_CENTER, OwnerDrawImage, FALSE, m_bDarkMode, FALSE);\n\tm_CtrlSelectFile.SetHandCursor();\n\tm_CtrlPlay.InitControl(456, 8, 24, 24, m_ZoomRatio, &m_BkDC, IP(L\"playSound\"), 2, BS_CENTER, OwnerDrawImage, FALSE, m_bDarkMode, FALSE);\n\tm_CtrlPlay.SetHandCursor();\n\tm_CtrlSlider.InitControl(32, 40, 396, 24, m_ZoomRatio, &m_BkDC, SystemDraw, m_bHighContrast, m_bDarkMode, 0, 100, m_InitialVolume);\n\tSetVolumeImage();\n\tm_CtrlValueVolume.InitControl(428, 40, 52, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlDefault.InitControl(40, 72, 160, 24, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlOk.InitControl(280, 72, 160, 24, m_ZoomRatio, &m_BkDC, NULL, 0, BS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, FALSE);\n\n\tm_CtrlFilePath.SetDrawFrame(TRUE);\n\tm_CtrlValueVolume.SetDrawFrame(TRUE);\n\n\tm_CtrlOk.SetHandCursor();\n\tm_CtrlDefault.SetHandCursor();\n\n\tSetDarkModeControl(m_CtrlOk.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_CtrlDefault.GetSafeHwnd(), m_bDarkMode);\n\n\tInvalidate();\n}\n\nvoid CSoundSettingDlg::OnSelectFile()\n{\n\tCFileDialog dlg(TRUE, _T(\"\"), _T(\"\"), OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_EXPLORER,\n\t\ti18n(_T(\"Customize\"), _T(\"SUPPORTED_SOUND_FORMAT\"))\n\t\t+ _T(\"|*.wav;*.mp3;*.opus;|WAVE (*.wav)|*.wav|MP3 (*.mp3)|*.mp3|Opus (*.opus)|*.opus|\")\n\t\t+ i18n(_T(\"Customize\"), _T(\"ALL_FILES\"))\n\t\t+ _T(\" (*.*)|*.*||\"));\n\n\tif(dlg.DoModal() == IDOK)\n\t{\n\t\tm_FilePath = dlg.GetPathName();\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertSoundPath\"), m_FilePath, m_Ini);\n\t\tm_CtrlFilePath.SetToolTipText(m_FilePath);\n\t\tUpdateData(FALSE);\n\t}\n}\n\nvoid CSoundSettingDlg::OnPlay()\n{\n\tconst int pos = m_CtrlSlider.GetPos();\n\tif (pos != m_CurrentVolume)\n\t{\n\t\tm_CurrentVolume = pos;\n\t\tCString volume;\n\t\tvolume.Format(_T(\"%d\"), m_CurrentVolume);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertSoundVolume\"), volume, m_Ini);\n\t}\n\n\t::PostMessage(m_ParentWnd->GetSafeHwnd(), MY_PLAY_ALERT_SOUND, NULL, NULL);\n}\n\nvoid CSoundSettingDlg::OnDefault()\n{\n\tm_CtrlSlider.SetPos(80);\n\tm_CtrlValueVolume.SetWindowTextW(L\"80\");\n\n\tm_FilePath = _T(\"\");\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertSoundPath\"), m_FilePath, m_Ini);\n\tm_CtrlFilePath.SetToolTipText(m_FilePath);\n\tUpdateData(FALSE);\n}\n\nvoid CSoundSettingDlg::OnOk()\n{\n\tCString volume;\n\tvolume.Format(_T(\"%d\"), m_CtrlSlider.GetPos());\n\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertSoundVolume\"), volume, m_Ini);\n\n\tCDialogFx::OnCancel();\n}\n\nvoid CSoundSettingDlg::OnCancel()\n{\n\t// Revert\n\tif (m_CurrentVolume != m_InitialVolume)\n\t{\n\t\tCString volume;\n\t\tvolume.Format(_T(\"%d\"), m_InitialVolume);\n\t\tWritePrivateProfileStringFx(_T(\"Setting\"), _T(\"AlertSoundVolume\"), volume, m_Ini);\n\t}\n\n\tCDialogFx::OnCancel();\n}\n\nHBRUSH CSoundSettingDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)\n{\n\tHBRUSH hbr = CDialogFx::OnCtlColor(pDC, pWnd, nCtlColor);\n\n\tswitch (nCtlColor)\n\t{\n\tcase CTLCOLOR_STATIC:\n\t\tif (pWnd->m_hWnd == m_CtrlSlider.m_hWnd && !m_CtrlSlider.m_bHighContrast)\n\t\t{\n\t\t\tpDC->SetBkMode(TRANSPARENT);\n\t\t\treturn m_CtrlSlider.m_BkBrush;\n\t\t}\n\t\treturn hbr;\n\t\tbreak;\n\tdefault:\n\t\treturn hbr;\n\t}\n}\n\nvoid CSoundSettingDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)\n{\n\tCDialogFx::OnHScroll(nSBCode, nPos, pScrollBar);\n\n\tCString cstr;\n\tcstr.Format(L\"%d\", m_CtrlSlider.GetPos());\n\tm_CtrlValueVolume.SetWindowTextW(cstr);\n\tSetVolumeImage();\n}\n\nvoid CSoundSettingDlg::SetVolumeImage()\n{\n\tint volume = m_CtrlSlider.GetPos();\n\tCString imageName = L\"\";\n\tif (volume > 66)\n\t{\n\t\timageName = L\"volumeL\";\n\t}\n\telse if (volume > 33)\n\t{\n\t\timageName = L\"volumeM\";\n\t}\n\telse if (volume > 0)\n\t{\n\t\timageName = L\"volumeS\";\n\t}\n\telse\n\t{\n\t\timageName = L\"volumeZ\";\n\t}\n\tm_CtrlVolume.InitControl(8, 40, 24, 24, m_ZoomRatio, &m_BkDC, IP(imageName), 1, BS_CENTER, OwnerDrawImage, FALSE, FALSE, FALSE);\n}\n"
        },
        {
          "name": "SoundSettingDlg.h",
          "type": "blob",
          "size": 1.3671875,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n#include \"DialogFx.h\"\n#include \"ButtonFx.h\"\n#include \"SliderCtrlFx.h\"\n#include \"StaticFX.h\"\n\nclass CSoundSettingDlg : public CDialogFx\n{\n\tDECLARE_DYNCREATE(CSoundSettingDlg)\n\n\tstatic const int SIZE_X = 488;\n\tstatic const int SIZE_Y = 104;\n\npublic:\n\tCSoundSettingDlg(CWnd* pParent = NULL);\n\tvirtual ~CSoundSettingDlg();\n\n\tenum { IDD = IDD_SOUND_SETTINGS};\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\n\tvirtual BOOL OnInitDialog();\n\tvirtual void UpdateDialogSize();\n\tvirtual void OnCancel();\n\tvoid SetVolumeImage();\n\t\n\tDECLARE_MESSAGE_MAP()\n\tafx_msg void OnSelectFile();\n\tafx_msg void OnPlay();\n\tafx_msg void OnDefault();\n\tafx_msg void OnOk();\n\tafx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);\n\tafx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);\n\n\tCString m_FilePath;\n\tCStaticFx m_CtrlFilePath;\n\tCButtonFx m_CtrlSelectFile;\n\tCButtonFx m_CtrlPlay;\n\tint m_InitialVolume;\n\tint m_CurrentVolume;\n\tCSliderCtrlFx m_CtrlSlider;\n\tCButtonFx m_CtrlDefault;\n\tCButtonFx m_CtrlOk;\n\tCStaticFx m_CtrlVolume;\n\tCStaticFx m_CtrlValueVolume;\n};\n"
        },
        {
          "name": "StorageQuery.h",
          "type": "blob",
          "size": 1.9716796875,
          "content": "﻿#pragma once\n\nnamespace StorageQuery {\n\ttypedef enum {\n\t\tStorageDeviceProperty = 0,\n\t\tStorageAdapterProperty,\n\t\tStorageDeviceIdProperty,\n\t\tStorageDeviceUniqueIdProperty,\n\t\tStorageDeviceWriteCacheProperty,\n\t\tStorageMiniportProperty,\n\t\tStorageAccessAlignmentProperty,\n\t\tStorageDeviceSeekPenaltyProperty,\n\t\tStorageDeviceTrimProperty,\n\t\tStorageDeviceWriteAggregationProperty,\n\t\tStorageDeviceDeviceTelemetryProperty,\n\t\tStorageDeviceLBProvisioningProperty,\n\t\tStorageDevicePowerProperty,\n\t\tStorageDeviceCopyOffloadProperty,\n\t\tStorageDeviceResiliencyProperty,\n\t\tStorageDeviceMediumProductType,\n\t\tStorageDeviceRpmbProperty,\n\t\tStorageDeviceIoCapabilityProperty = 48,\n\t\tStorageAdapterProtocolSpecificProperty,\n\t\tStorageDeviceProtocolSpecificProperty,\n\t\tStorageAdapterTemperatureProperty,\n\t\tStorageDeviceTemperatureProperty,\n\t\tStorageAdapterPhysicalTopologyProperty,\n\t\tStorageDevicePhysicalTopologyProperty,\n\t\tStorageDeviceAttributesProperty,\n\t} TStoragePropertyId;\n\n\ttypedef enum {\n\t\tPropertyStandardQuery = 0,\n\t\tPropertyExistsQuery,\n\t\tPropertyMaskQuery,\n\t\tPropertyQueryMaxDefined\n\t} TStorageQueryType;\n\n\ttypedef struct {\n\t\tTStoragePropertyId PropertyId;\n\t\tTStorageQueryType QueryType;\n\t} TStoragePropertyQuery;\n\n\ttypedef enum {\n\t\tProtocolTypeUnknown = 0x00,\n\t\tProtocolTypeScsi,\n\t\tProtocolTypeAta,\n\t\tProtocolTypeNvme,\n\t\tProtocolTypeSd,\n\t\tProtocolTypeProprietary = 0x7E,\n\t\tProtocolTypeMaxReserved = 0x7F\n\t} TStroageProtocolType;\n\n\ttypedef struct {\n\t\tTStroageProtocolType ProtocolType;\n\t\tDWORD   DataType;\n\t\tDWORD   ProtocolDataRequestValue;\n\t\tDWORD   ProtocolDataRequestSubValue;\n\t\tDWORD   ProtocolDataOffset;\n\t\tDWORD   ProtocolDataLength;\n\t\tDWORD   FixedProtocolReturnData;\n\t\tDWORD   Reserved[3];\n\t} TStorageProtocolSpecificData;\n\n\ttypedef enum {\n\t\tNVMeDataTypeUnknown = 0,\n\t\tNVMeDataTypeIdentify,\n\t\tNVMeDataTypeLogPage,\n\t\tNVMeDataTypeFeature,\n\t} TStorageProtocolNVMeDataType;\n\n\ttypedef struct {\n\t\tTStoragePropertyQuery Query;\n\t\tTStorageProtocolSpecificData ProtocolSpecific;\n\t\tBYTE Buffer[4096];\n\t} TStorageQueryWithBuffer;\n}\n"
        },
        {
          "name": "TemperatureDlg.cpp",
          "type": "blob",
          "size": 7.814453125,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#include \"stdafx.h\"\n#include \"DiskInfo.h\"\n#include \"DiskInfoDlg.h\"\n#include \"TemperatureDlg.h\"\n\nstatic CDiskInfoDlg* p;\n\nIMPLEMENT_DYNAMIC(CTemperatureDlg, CDialog)\n\nCTemperatureDlg::CTemperatureDlg(CWnd* pParent /*=NULL*/)\n\t: CDialogFx(CTemperatureDlg::IDD, pParent)\n{\n\tp = (CDiskInfoDlg*)pParent;\n\n\tm_ZoomType = p->GetZoomType();\n\tm_FontScale = p->GetFontScale();\n\tm_FontRatio = p->GetFontRatio();\n\tm_FontFace = p->GetFontFace();\n\tm_CurrentLangPath = p->GetCurrentLangPath();\n\tm_DefaultLangPath = p->GetDefaultLangPath();\n\tm_ThemeDir = p->GetThemeDir();\n\tm_CurrentTheme = p->GetCurrentTheme();\n\tm_DefaultTheme = p->GetDefaultTheme();\n\tm_Ini = p->GetIniPath();\n}\n\nCTemperatureDlg::~CTemperatureDlg()\n{\n}\n\nvoid CTemperatureDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogFx::DoDataExchange(pDX);\n\n\tDDX_Text(pDX, IDC_VALUE_TEMPERATURE, m_ValueTemperature);\n\tDDX_Text(pDX, IDC_VALUE_TEMPERATURE_F, m_ValueTemperatureF);\n\tDDX_Control(pDX, IDC_SCROLLBAR_TEMPERATURE, m_CtrlScrollbarTemperature);\n\tDDX_Control(pDX, IDC_VALUE_TEMPERATURE, m_CtrlValueTemperature);\n\tDDX_Control(pDX, IDC_VALUE_TEMPERATURE_F, m_CtrlValueTemperatureF);\n\tDDX_Control(pDX, IDC_SELECT_DISK, m_CtrlSelectDisk);\n\tDDX_Control(pDX, IDC_APPLY, m_CtrlApply);\n\tDDX_Control(pDX, IDC_DEFAULT, m_CtrlDefault);\n}\n\nBEGIN_MESSAGE_MAP(CTemperatureDlg, CDialogFx)\n\tON_WM_HSCROLL()\n\tON_BN_CLICKED(IDC_APPLY, &CTemperatureDlg::OnApply)\n\tON_BN_CLICKED(IDC_DEFAULT, &CTemperatureDlg::OnDefault)\n\tON_CBN_SELCHANGE(IDC_SELECT_DISK, &CTemperatureDlg::OnCbnSelchangeSelectDisk)\nEND_MESSAGE_MAP()\n\nBOOL CTemperatureDlg::OnInitDialog()\n{\n\tCDialogFx::OnInitDialog();\n\n\tSetWindowTitle(i18n(_T(\"Alarm\"), _T(\"ALARM_TEMPERATURE\")));\n\n\tm_CtrlScrollbarTemperature.SetScrollRange(20, 80);\n\n\tm_bShowWindow = TRUE;\n\n\tInitLang();\n\tInitSelectDisk();\n\n\tUpdateDialogSize();\n\n\tCenterWindow();\n\tShowWindow(SW_SHOW);\n\n\tif (p->m_Ata.vars.GetCount() == 0)\n\t{\n\t\tm_CtrlSelectDisk.EnableWindow(FALSE);\n\t\tm_CtrlScrollbarTemperature.EnableWindow(FALSE);\n\t\tm_CtrlValueTemperature.EnableWindow(FALSE);\n\t\tm_CtrlValueTemperatureF.EnableWindow(FALSE);\n\t\tm_CtrlApply.EnableWindow(FALSE);\n\t\tm_CtrlDefault.EnableWindow(FALSE);\n\t}\n\n\treturn TRUE;\n}\n\nvoid CTemperatureDlg::UpdateDialogSize()\n{\n\tCDialogFx::UpdateDialogSize();\n\n\tChangeZoomType(m_ZoomType);\n\tSetClientSize(SIZE_X, SIZE_Y, m_ZoomRatio);\n\tUpdateBackground(FALSE, m_bDarkMode);\n\n\tm_CtrlScrollbarTemperature.MoveWindow((int)(8 * m_ZoomRatio), (int)(44 * m_ZoomRatio), (int)(280 * m_ZoomRatio), (int)(20 * m_ZoomRatio));\n\tm_CtrlValueTemperature.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n   \tm_CtrlValueTemperatureF.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlValueTemperature.InitControl(292, 44, 48, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\tm_CtrlValueTemperatureF.InitControl(344, 44, 48, 20, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, TRUE);\n\n\tm_CtrlApply.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlDefault.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\n\tm_CtrlApply.InitControl(220, 80, 160, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, FALSE);\n\tm_CtrlDefault.InitControl(20, 80, 160, 24, m_ZoomRatio, &m_BkDC, NULL, 0, SS_CENTER, SystemDraw, m_bHighContrast, m_bDarkMode, FALSE);\n\n\tm_CtrlSelectDisk.SetFontEx(m_FontFace, 12, 12, m_ZoomRatio, m_FontRatio, RGB(0, 0, 0), RGB(0, 0, 0), FW_NORMAL, m_FontRender);\n\tm_CtrlSelectDisk.InitControl(8, 8, 384, 40, m_ZoomRatio, &m_BkDC, NULL, 0, ES_LEFT, OwnerDrawTransparent, m_bHighContrast, m_bDarkMode, RGB(255, 255, 255), RGB(160, 220, 255), RGB(255, 255, 255), 0);\n\tm_CtrlSelectDisk.SetMargin(0, 4, 0, 0, m_ZoomRatio);\n\n\tm_CtrlValueTemperature.SetDrawFrame(TRUE);\n\tm_CtrlValueTemperatureF.SetDrawFrame(TRUE);\n\n\tm_CtrlApply.SetHandCursor();\n\tm_CtrlDefault.SetHandCursor();\n\n\tSetDarkModeControl(m_CtrlApply.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_CtrlDefault.GetSafeHwnd(), m_bDarkMode);\n\tSetDarkModeControl(m_CtrlScrollbarTemperature.GetSafeHwnd(), m_bDarkMode);\n\n\tm_CtrlSelectDisk.SetItemHeightAll(24, m_ZoomRatio, m_FontRatio);\n\n\tInvalidate();\n}\n\nvoid CTemperatureDlg::InitLang()\n{\n\tm_CtrlApply.SetWindowTextW(i18n(_T(\"HealthStatus\"), _T(\"APPLY\")));\n\tm_CtrlDefault.SetWindowTextW(i18n(_T(\"HealthStatus\"), _T(\"DEFAULT\")));\n}\n\nvoid CTemperatureDlg::InitSelectDisk()\n{\n\tCString select;\n\tCString cstr;\n\n\tif (p->m_Ata.vars.GetCount() <= 0)\n\t{\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < p->m_Ata.vars.GetCount(); i++)\n\t{\n\t\tCString temp;\n\t\tif (p->m_Ata.vars[i].IsSsd)\n\t\t{\n\t\t\ttemp = _T(\"[SSD]\");\n\t\t}\n\n\t\tCString driveLetter;\n\t\tif (p->m_Ata.vars[i].DriveMap.IsEmpty())\n\t\t{\n\t\t\tif (p->m_Ata.vars[i].PhysicalDriveId >= 0)\n\t\t\t{\n\t\t\t\tdriveLetter.Format(_T(\"(Disk %d)\"), p->m_Ata.vars[i].PhysicalDriveId);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdriveLetter.Format(_T(\"(%s)\"), p->m_Ata.vars[i].DriveMap.GetString());\n\t\t}\n\t\tcstr.Format(_T(\"(%02d) %s %s %s\"), i + 1, p->m_Ata.vars.GetAt(i).Model.GetString(), temp.GetString(), driveLetter.GetString());\n\n\t\tm_CtrlSelectDisk.AddString(cstr);\n\t\tif (i == p->GetSelectedDrive())\n\t\t{\n\t\t\tm_CtrlSelectDisk.SetCurSel(i);\n\t\t\tm_DiskIndex = i;\n\t\t}\n\t}\n\n\tUpdateSelectDisk(m_DiskIndex);\n}\n\n\nvoid CTemperatureDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)\n{\n\tint position = pScrollBar->GetScrollPos();\n\tswitch (nSBCode)\n\t{\n\n\tcase SB_LINELEFT:\n\t\tposition -= 1;\n\t\tbreak;\n\tcase SB_LINERIGHT:\n\t\tposition += 1;\n\t\tbreak;\n\tcase SB_PAGELEFT:\n\t\tposition -= 5;\n\t\tbreak;\n\tcase SB_PAGERIGHT:\n\t\tposition += 5;\n\t\tbreak;\n\tcase SB_LEFT:\n\t\tbreak;\n\tcase SB_RIGHT:\n\t\tbreak;\n\tcase SB_THUMBTRACK:\n\t\tposition = nPos;\n\t\tbreak;\n\t}\n\tpScrollBar->SetScrollPos(position);\n\n\tCString cstr;\n\tif (*pScrollBar == m_CtrlScrollbarTemperature)\n\t{\n\t\tm_ValueTemperature.Format(L\"%d °C\", m_CtrlScrollbarTemperature.GetScrollPos());\n\t\tm_ValueTemperatureF.Format(L\"%d °F\", m_CtrlScrollbarTemperature.GetScrollPos() * 9 / 5 + 32);\n\t}\n\n\tUpdateData(FALSE);\n\n\tCDialogFx::OnHScroll(nSBCode, nPos, pScrollBar);\n}\n\nvoid CTemperatureDlg::UpdateSelectDisk(DWORD index)\n{\n\tif (p->m_Ata.vars[index].IsSsd)\n\t{\n\t\tm_CtrlScrollbarTemperature.SetScrollPos(GetPrivateProfileIntFx(_T(\"AlarmTemperature\"), p->m_Ata.vars[index].ModelSerial, 60, m_Ini));\n\t}\n\telse\n\t{\n\t\tm_CtrlScrollbarTemperature.SetScrollPos(GetPrivateProfileIntFx(_T(\"AlarmTemperature\"), p->m_Ata.vars[index].ModelSerial, 50, m_Ini));\n\t}\n\tm_CtrlScrollbarTemperature.EnableWindow(TRUE);\n\n\tm_ValueTemperature.Format(L\"%d °C\", m_CtrlScrollbarTemperature.GetScrollPos());\n\tm_ValueTemperatureF.Format(L\"%d °F\", m_CtrlScrollbarTemperature.GetScrollPos() * 9 / 5 + 32);\n\tUpdateData(FALSE);\n}\n\nvoid CTemperatureDlg::OnApply()\n{\n\tUpdateData(TRUE);\n\n\tWritePrivateProfileStringFx(_T(\"AlarmTemperature\"), p->m_Ata.vars[m_DiskIndex].ModelSerial, m_ValueTemperature, m_Ini);\n\tp->m_Ata.vars[m_DiskIndex].AlarmTemperature = _tstoi(m_ValueTemperature);\n\tp->SendMessage(WM_COMMAND, ID_REFRESH);\n}\n\nvoid CTemperatureDlg::OnDefault()\n{\n\tif (p->m_Ata.vars[m_DiskIndex].IsSsd)\n\t{\n\t\tm_CtrlScrollbarTemperature.SetScrollPos(60);\n\t}\n\telse\n\t{\n\t\tm_CtrlScrollbarTemperature.SetScrollPos(50);\n\t}\n\t\n\tm_ValueTemperature.Format(L\"%d °C\", m_CtrlScrollbarTemperature.GetScrollPos());\n\tm_ValueTemperatureF.Format(L\"%d °F\", m_CtrlScrollbarTemperature.GetScrollPos() * 9 / 5 + 32);\n\n\tUpdateData(FALSE);\n}\n\nvoid CTemperatureDlg::OnCbnSelchangeSelectDisk()\n{\n\tif (m_DiskIndex != m_CtrlSelectDisk.GetCurSel())\n\t{\n\t\tm_DiskIndex = m_CtrlSelectDisk.GetCurSel();\n\t\tUpdateSelectDisk(m_DiskIndex);\n\t}\n}\n"
        },
        {
          "name": "TemperatureDlg.h",
          "type": "blob",
          "size": 1.310546875,
          "content": "﻿/*---------------------------------------------------------------------------*/\n//       Author : hiyohiyo\n//         Mail : hiyohiyo@crystalmark.info\n//          Web : https://crystalmark.info/\n//      License : MIT License\n/*---------------------------------------------------------------------------*/\n\n#pragma once\n#include \"DialogFx.h\"\n#include \"StaticFx.h\"\n#include \"ButtonFx.h\"\n#include \"ComboBoxFx.h\"\n\nclass CTemperatureDlg : public CDialogFx\n{\n\tDECLARE_DYNAMIC(CTemperatureDlg)\n\n\tstatic const int SIZE_X = 400;\n\tstatic const int SIZE_Y = 112;\n\npublic:\n\tCTemperatureDlg(CWnd* pParent = NULL);\n\tvirtual ~CTemperatureDlg();\n\n\tenum { IDD = IDD_TEMPERATURE };\n\nprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);\n\tvirtual BOOL OnInitDialog();\n\tvirtual void UpdateDialogSize();\n\n\tvoid InitSelectDisk();\n\tvoid InitLang();\n\tvoid UpdateSelectDisk(DWORD index);\n\t\n\tDECLARE_MESSAGE_MAP()\n\tafx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);\n\tafx_msg void OnApply();\n\tafx_msg void OnDefault();\n\tafx_msg void OnCbnSelchangeSelectDisk();\n\n\tDWORD m_DiskIndex;\n\tCString m_ValueTemperature;\n\tCString m_ValueTemperatureF;\n\tCScrollBar m_CtrlScrollbarTemperature;\n\tCStaticFx m_CtrlValueTemperature;\n\tCStaticFx m_CtrlValueTemperatureF;\n\tCComboBoxFx m_CtrlSelectDisk;\n\n\tCButtonFx m_CtrlApply;\n\tCButtonFx m_CtrlDefault;\n};\n"
        },
        {
          "name": "qrcodegen.cpp",
          "type": "blob",
          "size": 41.0830078125,
          "content": "/* \n * QR Code generator library (C)\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n#include <assert.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"qrcodegen.h\"\n\n#ifndef QRCODEGEN_TEST\n\t#define testable static  // Keep functions private\n#else\n\t#define testable  // Expose private functions\n#endif\n\n\n/*---- Forward declarations for private functions ----*/\n\n// Regarding all public and private functions defined in this source file:\n// - They require all pointer/array arguments to be not null unless the array length is zero.\n// - They only read input scalar/array arguments, write to output pointer/array\n//   arguments, and return scalar values; they are \"pure\" functions.\n// - They don't read mutable global variables or write to any global variables.\n// - They don't perform I/O, read the clock, print to console, etc.\n// - They allocate a small and constant amount of stack memory.\n// - They don't allocate or free any memory on the heap.\n// - They don't recurse or mutually recurse. All the code\n//   could be inlined into the top-level public functions.\n// - They run in at most quadratic time with respect to input arguments.\n//   Most functions run in linear time, and some in constant time.\n//   There are no unbounded loops or non-obvious termination conditions.\n// - They are completely thread-safe if the caller does not give the\n//   same writable buffer to concurrent calls to these functions.\n\ntestable void appendBitsToBuffer(unsigned int val, int numBits, uint8_t buffer[], int *bitLen);\n\ntestable void addEccAndInterleave(uint8_t data[], int version, enum qrcodegen_Ecc ecl, uint8_t result[]);\ntestable int getNumDataCodewords(int version, enum qrcodegen_Ecc ecl);\ntestable int getNumRawDataModules(int ver);\n\ntestable void reedSolomonComputeDivisor(int degree, uint8_t result[]);\ntestable void reedSolomonComputeRemainder(const uint8_t data[], int dataLen,\n\tconst uint8_t generator[], int degree, uint8_t result[]);\ntestable uint8_t reedSolomonMultiply(uint8_t x, uint8_t y);\n\ntestable void initializeFunctionModules(int version, uint8_t qrcode[]);\nstatic void drawLightFunctionModules(uint8_t qrcode[], int version);\nstatic void drawFormatBits(enum qrcodegen_Ecc ecl, enum qrcodegen_Mask mask, uint8_t qrcode[]);\ntestable int getAlignmentPatternPositions(int version, uint8_t result[7]);\nstatic void fillRectangle(int left, int top, int width, int height, uint8_t qrcode[]);\n\nstatic void drawCodewords(const uint8_t data[], int dataLen, uint8_t qrcode[]);\nstatic void applyMask(const uint8_t functionModules[], uint8_t qrcode[], enum qrcodegen_Mask mask);\nstatic long getPenaltyScore(const uint8_t qrcode[]);\nstatic int finderPenaltyCountPatterns(const int runHistory[7], int qrsize);\nstatic int finderPenaltyTerminateAndCount(bool currentRunColor, int currentRunLength, int runHistory[7], int qrsize);\nstatic void finderPenaltyAddHistory(int currentRunLength, int runHistory[7], int qrsize);\n\ntestable bool getModuleBounded(const uint8_t qrcode[], int x, int y);\ntestable void setModuleBounded(uint8_t qrcode[], int x, int y, bool isDark);\ntestable void setModuleUnbounded(uint8_t qrcode[], int x, int y, bool isDark);\nstatic bool getBit(int x, int i);\n\ntestable int calcSegmentBitLength(enum qrcodegen_Mode mode, size_t numChars);\ntestable int getTotalBits(const struct qrcodegen_Segment segs[], size_t len, int version);\nstatic int numCharCountBits(enum qrcodegen_Mode mode, int version);\n\n\n\n/*---- Private tables of constants ----*/\n\n// The set of all legal characters in alphanumeric mode, where each character\n// value maps to the index in the string. For checking text and encoding segments.\nstatic const char *ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n\n// Sentinel value for use in only some functions.\n#define LENGTH_OVERFLOW -1\n\n// For generating error correction codes.\ntestable const int8_t ECC_CODEWORDS_PER_BLOCK[4][41] = {\n\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t{-1,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Low\n\t{-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28},  // Medium\n\t{-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // Quartile\n\t{-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30},  // High\n};\n\n#define qrcodegen_REED_SOLOMON_DEGREE_MAX 30  // Based on the table above\n\n// For generating error correction codes.\ntestable const int8_t NUM_ERROR_CORRECTION_BLOCKS[4][41] = {\n\t// Version: (note that index 0 is for padding, and is set to an illegal value)\n\t//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n\t{-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25},  // Low\n\t{-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49},  // Medium\n\t{-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68},  // Quartile\n\t{-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81},  // High\n};\n\n// For automatic mask pattern selection.\nstatic const int PENALTY_N1 =  3;\nstatic const int PENALTY_N2 =  3;\nstatic const int PENALTY_N3 = 40;\nstatic const int PENALTY_N4 = 10;\n\n\n\n/*---- High-level QR Code encoding functions ----*/\n\n// Public function - see documentation comment in header file.\nbool qrcodegen_encodeText(const char *text, uint8_t tempBuffer[], uint8_t qrcode[],\n\t\tenum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl) {\n\t\n\tsize_t textLen = strlen(text);\n\tif (textLen == 0)\n\t\treturn qrcodegen_encodeSegmentsAdvanced(NULL, 0, ecl, minVersion, maxVersion, mask, boostEcl, tempBuffer, qrcode);\n\tsize_t bufLen = (size_t)qrcodegen_BUFFER_LEN_FOR_VERSION(maxVersion);\n\t\n\tstruct qrcodegen_Segment seg;\n\tif (qrcodegen_isNumeric(text)) {\n\t\tif (qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_NUMERIC, textLen) > bufLen)\n\t\t\tgoto fail;\n\t\tseg = qrcodegen_makeNumeric(text, tempBuffer);\n\t} else if (qrcodegen_isAlphanumeric(text)) {\n\t\tif (qrcodegen_calcSegmentBufferSize(qrcodegen_Mode_ALPHANUMERIC, textLen) > bufLen)\n\t\t\tgoto fail;\n\t\tseg = qrcodegen_makeAlphanumeric(text, tempBuffer);\n\t} else {\n\t\tif (textLen > bufLen)\n\t\t\tgoto fail;\n\t\tfor (size_t i = 0; i < textLen; i++)\n\t\t\ttempBuffer[i] = (uint8_t)text[i];\n\t\tseg.mode = qrcodegen_Mode_BYTE;\n\t\tseg.bitLength = calcSegmentBitLength(seg.mode, textLen);\n\t\tif (seg.bitLength == LENGTH_OVERFLOW)\n\t\t\tgoto fail;\n\t\tseg.numChars = (int)textLen;\n\t\tseg.data = tempBuffer;\n\t}\n\treturn qrcodegen_encodeSegmentsAdvanced(&seg, 1, ecl, minVersion, maxVersion, mask, boostEcl, tempBuffer, qrcode);\n\t\nfail:\n\tqrcode[0] = 0;  // Set size to invalid value for safety\n\treturn false;\n}\n\n\n// Public function - see documentation comment in header file.\nbool qrcodegen_encodeBinary(uint8_t dataAndTemp[], size_t dataLen, uint8_t qrcode[],\n\t\tenum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl) {\n\t\n\tstruct qrcodegen_Segment seg;\n\tseg.mode = qrcodegen_Mode_BYTE;\n\tseg.bitLength = calcSegmentBitLength(seg.mode, dataLen);\n\tif (seg.bitLength == LENGTH_OVERFLOW) {\n\t\tqrcode[0] = 0;  // Set size to invalid value for safety\n\t\treturn false;\n\t}\n\tseg.numChars = (int)dataLen;\n\tseg.data = dataAndTemp;\n\treturn qrcodegen_encodeSegmentsAdvanced(&seg, 1, ecl, minVersion, maxVersion, mask, boostEcl, dataAndTemp, qrcode);\n}\n\n\n// Appends the given number of low-order bits of the given value to the given byte-based\n// bit buffer, increasing the bit length. Requires 0 <= numBits <= 16 and val < 2^numBits.\ntestable void appendBitsToBuffer(unsigned int val, int numBits, uint8_t buffer[], int *bitLen) {\n\tassert(0 <= numBits && numBits <= 16 && (unsigned long)val >> numBits == 0);\n\tfor (int i = numBits - 1; i >= 0; i--, (*bitLen)++)\n\t\tbuffer[*bitLen >> 3] |= ((val >> i) & 1) << (7 - (*bitLen & 7));\n}\n\n\n\n/*---- Low-level QR Code encoding functions ----*/\n\n// Public function - see documentation comment in header file.\nbool qrcodegen_encodeSegments(const struct qrcodegen_Segment segs[], size_t len,\n\t\tenum qrcodegen_Ecc ecl, uint8_t tempBuffer[], uint8_t qrcode[]) {\n\treturn qrcodegen_encodeSegmentsAdvanced(segs, len, ecl,\n\t\tqrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true, tempBuffer, qrcode);\n}\n\n\n// Public function - see documentation comment in header file.\nbool qrcodegen_encodeSegmentsAdvanced(const struct qrcodegen_Segment segs[], size_t len, enum qrcodegen_Ecc ecl,\n\t\tint minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl, uint8_t tempBuffer[], uint8_t qrcode[]) {\n\tassert(segs != NULL || len == 0);\n\tassert(qrcodegen_VERSION_MIN <= minVersion && minVersion <= maxVersion && maxVersion <= qrcodegen_VERSION_MAX);\n\tassert(0 <= (int)ecl && (int)ecl <= 3 && -1 <= (int)mask && (int)mask <= 7);\n\t\n\t// Find the minimal version number to use\n\tint version, dataUsedBits;\n\tfor (version = minVersion; ; version++) {\n\t\tint dataCapacityBits = getNumDataCodewords(version, ecl) * 8;  // Number of data bits available\n\t\tdataUsedBits = getTotalBits(segs, len, version);\n\t\tif (dataUsedBits != LENGTH_OVERFLOW && dataUsedBits <= dataCapacityBits)\n\t\t\tbreak;  // This version number is found to be suitable\n\t\tif (version >= maxVersion) {  // All versions in the range could not fit the given data\n\t\t\tqrcode[0] = 0;  // Set size to invalid value for safety\n\t\t\treturn false;\n\t\t}\n\t}\n\tassert(dataUsedBits != LENGTH_OVERFLOW);\n\t\n\t// Increase the error correction level while the data still fits in the current version number\n\tfor (int i = (int)qrcodegen_Ecc_MEDIUM; i <= (int)qrcodegen_Ecc_HIGH; i++) {  // From low to high\n\t\tif (boostEcl && dataUsedBits <= getNumDataCodewords(version, (enum qrcodegen_Ecc)i) * 8)\n\t\t\tecl = (enum qrcodegen_Ecc)i;\n\t}\n\t\n\t// Concatenate all segments to create the data bit string\n\tmemset(qrcode, 0, (size_t)qrcodegen_BUFFER_LEN_FOR_VERSION(version) * sizeof(qrcode[0]));\n\tint bitLen = 0;\n\tfor (size_t i = 0; i < len; i++) {\n\t\tconst struct qrcodegen_Segment *seg = &segs[i];\n\t\tappendBitsToBuffer((unsigned int)seg->mode, 4, qrcode, &bitLen);\n\t\tappendBitsToBuffer((unsigned int)seg->numChars, numCharCountBits(seg->mode, version), qrcode, &bitLen);\n\t\tfor (int j = 0; j < seg->bitLength; j++) {\n\t\t\tint bit = (seg->data[j >> 3] >> (7 - (j & 7))) & 1;\n\t\t\tappendBitsToBuffer((unsigned int)bit, 1, qrcode, &bitLen);\n\t\t}\n\t}\n\tassert(bitLen == dataUsedBits);\n\t\n\t// Add terminator and pad up to a byte if applicable\n\tint dataCapacityBits = getNumDataCodewords(version, ecl) * 8;\n\tassert(bitLen <= dataCapacityBits);\n\tint terminatorBits = dataCapacityBits - bitLen;\n\tif (terminatorBits > 4)\n\t\tterminatorBits = 4;\n\tappendBitsToBuffer(0, terminatorBits, qrcode, &bitLen);\n\tappendBitsToBuffer(0, (8 - bitLen % 8) % 8, qrcode, &bitLen);\n\tassert(bitLen % 8 == 0);\n\t\n\t// Pad with alternating bytes until data capacity is reached\n\tfor (uint8_t padByte = 0xEC; bitLen < dataCapacityBits; padByte ^= 0xEC ^ 0x11)\n\t\tappendBitsToBuffer(padByte, 8, qrcode, &bitLen);\n\t\n\t// Compute ECC, draw modules\n\taddEccAndInterleave(qrcode, version, ecl, tempBuffer);\n\tinitializeFunctionModules(version, qrcode);\n\tdrawCodewords(tempBuffer, getNumRawDataModules(version) / 8, qrcode);\n\tdrawLightFunctionModules(qrcode, version);\n\tinitializeFunctionModules(version, tempBuffer);\n\t\n\t// Do masking\n\tif (mask == qrcodegen_Mask_AUTO) {  // Automatically choose best mask\n\t\tlong minPenalty = LONG_MAX;\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tenum qrcodegen_Mask msk = (enum qrcodegen_Mask)i;\n\t\t\tapplyMask(tempBuffer, qrcode, msk);\n\t\t\tdrawFormatBits(ecl, msk, qrcode);\n\t\t\tlong penalty = getPenaltyScore(qrcode);\n\t\t\tif (penalty < minPenalty) {\n\t\t\t\tmask = msk;\n\t\t\t\tminPenalty = penalty;\n\t\t\t}\n\t\t\tapplyMask(tempBuffer, qrcode, msk);  // Undoes the mask due to XOR\n\t\t}\n\t}\n\tassert(0 <= (int)mask && (int)mask <= 7);\n\tapplyMask(tempBuffer, qrcode, mask);  // Apply the final choice of mask\n\tdrawFormatBits(ecl, mask, qrcode);  // Overwrite old format bits\n\treturn true;\n}\n\n\n\n/*---- Error correction code generation functions ----*/\n\n// Appends error correction bytes to each block of the given data array, then interleaves\n// bytes from the blocks and stores them in the result array. data[0 : dataLen] contains\n// the input data. data[dataLen : rawCodewords] is used as a temporary work area and will\n// be clobbered by this function. The final answer is stored in result[0 : rawCodewords].\ntestable void addEccAndInterleave(uint8_t data[], int version, enum qrcodegen_Ecc ecl, uint8_t result[]) {\n\t// Calculate parameter numbers\n\tassert(0 <= (int)ecl && (int)ecl < 4 && qrcodegen_VERSION_MIN <= version && version <= qrcodegen_VERSION_MAX);\n\tint numBlocks = NUM_ERROR_CORRECTION_BLOCKS[(int)ecl][version];\n\tint blockEccLen = ECC_CODEWORDS_PER_BLOCK  [(int)ecl][version];\n\tint rawCodewords = getNumRawDataModules(version) / 8;\n\tint dataLen = getNumDataCodewords(version, ecl);\n\tint numShortBlocks = numBlocks - rawCodewords % numBlocks;\n\tint shortBlockDataLen = rawCodewords / numBlocks - blockEccLen;\n\t\n\t// Split data into blocks, calculate ECC, and interleave\n\t// (not concatenate) the bytes into a single sequence\n\tuint8_t rsdiv[qrcodegen_REED_SOLOMON_DEGREE_MAX];\n\treedSolomonComputeDivisor(blockEccLen, rsdiv);\n\tconst uint8_t *dat = data;\n\tfor (int i = 0; i < numBlocks; i++) {\n\t\tint datLen = shortBlockDataLen + (i < numShortBlocks ? 0 : 1);\n\t\tuint8_t *ecc = &data[dataLen];  // Temporary storage\n\t\treedSolomonComputeRemainder(dat, datLen, rsdiv, blockEccLen, ecc);\n\t\tfor (int j = 0, k = i; j < datLen; j++, k += numBlocks) {  // Copy data\n\t\t\tif (j == shortBlockDataLen)\n\t\t\t\tk -= numShortBlocks;\n\t\t\tresult[k] = dat[j];\n\t\t}\n\t\tfor (int j = 0, k = dataLen + i; j < blockEccLen; j++, k += numBlocks)  // Copy ECC\n\t\t\tresult[k] = ecc[j];\n\t\tdat += datLen;\n\t}\n}\n\n\n// Returns the number of 8-bit codewords that can be used for storing data (not ECC),\n// for the given version number and error correction level. The result is in the range [9, 2956].\ntestable int getNumDataCodewords(int version, enum qrcodegen_Ecc ecl) {\n\tint v = version, e = (int)ecl;\n\tassert(0 <= e && e < 4);\n\treturn getNumRawDataModules(v) / 8\n\t\t- ECC_CODEWORDS_PER_BLOCK    [e][v]\n\t\t* NUM_ERROR_CORRECTION_BLOCKS[e][v];\n}\n\n\n// Returns the number of data bits that can be stored in a QR Code of the given version number, after\n// all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n// The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\ntestable int getNumRawDataModules(int ver) {\n\tassert(qrcodegen_VERSION_MIN <= ver && ver <= qrcodegen_VERSION_MAX);\n\tint result = (16 * ver + 128) * ver + 64;\n\tif (ver >= 2) {\n\t\tint numAlign = ver / 7 + 2;\n\t\tresult -= (25 * numAlign - 10) * numAlign - 55;\n\t\tif (ver >= 7)\n\t\t\tresult -= 36;\n\t}\n\tassert(208 <= result && result <= 29648);\n\treturn result;\n}\n\n\n\n/*---- Reed-Solomon ECC generator functions ----*/\n\n// Computes a Reed-Solomon ECC generator polynomial for the given degree, storing in result[0 : degree].\n// This could be implemented as a lookup table over all possible parameter values, instead of as an algorithm.\ntestable void reedSolomonComputeDivisor(int degree, uint8_t result[]) {\n\tassert(1 <= degree && degree <= qrcodegen_REED_SOLOMON_DEGREE_MAX);\n\t// Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.\n\t// For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array {255, 8, 93}.\n\tmemset(result, 0, (size_t)degree * sizeof(result[0]));\n\tresult[degree - 1] = 1;  // Start off with the monomial x^0\n\t\n\t// Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n\t// drop the highest monomial term which is always 1x^degree.\n\t// Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n\tuint8_t root = 1;\n\tfor (int i = 0; i < degree; i++) {\n\t\t// Multiply the current product by (x - r^i)\n\t\tfor (int j = 0; j < degree; j++) {\n\t\t\tresult[j] = reedSolomonMultiply(result[j], root);\n\t\t\tif (j + 1 < degree)\n\t\t\t\tresult[j] ^= result[j + 1];\n\t\t}\n\t\troot = reedSolomonMultiply(root, 0x02);\n\t}\n}\n\n\n// Computes the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n// The remainder when data[0 : dataLen] is divided by divisor[0 : degree] is stored in result[0 : degree].\n// All polynomials are in big endian, and the generator has an implicit leading 1 term.\ntestable void reedSolomonComputeRemainder(const uint8_t data[], int dataLen,\n\t\tconst uint8_t generator[], int degree, uint8_t result[]) {\n\tassert(1 <= degree && degree <= qrcodegen_REED_SOLOMON_DEGREE_MAX);\n\tmemset(result, 0, (size_t)degree * sizeof(result[0]));\n\tfor (int i = 0; i < dataLen; i++) {  // Polynomial division\n\t\tuint8_t factor = data[i] ^ result[0];\n\t\tmemmove(&result[0], &result[1], (size_t)(degree - 1) * sizeof(result[0]));\n\t\tresult[degree - 1] = 0;\n\t\tfor (int j = 0; j < degree; j++)\n\t\t\tresult[j] ^= reedSolomonMultiply(generator[j], factor);\n\t}\n}\n\n#undef qrcodegen_REED_SOLOMON_DEGREE_MAX\n\n\n// Returns the product of the two given field elements modulo GF(2^8/0x11D).\n// All inputs are valid. This could be implemented as a 256*256 lookup table.\ntestable uint8_t reedSolomonMultiply(uint8_t x, uint8_t y) {\n\t// Russian peasant multiplication\n\tuint8_t z = 0;\n\tfor (int i = 7; i >= 0; i--) {\n\t\tz = (uint8_t)((z << 1) ^ ((z >> 7) * 0x11D));\n\t\tz ^= ((y >> i) & 1) * x;\n\t}\n\treturn z;\n}\n\n\n\n/*---- Drawing function modules ----*/\n\n// Clears the given QR Code grid with light modules for the given\n// version's size, then marks every function module as dark.\ntestable void initializeFunctionModules(int version, uint8_t qrcode[]) {\n\t// Initialize QR Code\n\tint qrsize = version * 4 + 17;\n\tmemset(qrcode, 0, (size_t)((qrsize * qrsize + 7) / 8 + 1) * sizeof(qrcode[0]));\n\tqrcode[0] = (uint8_t)qrsize;\n\t\n\t// Fill horizontal and vertical timing patterns\n\tfillRectangle(6, 0, 1, qrsize, qrcode);\n\tfillRectangle(0, 6, qrsize, 1, qrcode);\n\t\n\t// Fill 3 finder patterns (all corners except bottom right) and format bits\n\tfillRectangle(0, 0, 9, 9, qrcode);\n\tfillRectangle(qrsize - 8, 0, 8, 9, qrcode);\n\tfillRectangle(0, qrsize - 8, 9, 8, qrcode);\n\t\n\t// Fill numerous alignment patterns\n\tuint8_t alignPatPos[7];\n\tint numAlign = getAlignmentPatternPositions(version, alignPatPos);\n\tfor (int i = 0; i < numAlign; i++) {\n\t\tfor (int j = 0; j < numAlign; j++) {\n\t\t\t// Don't draw on the three finder corners\n\t\t\tif (!((i == 0 && j == 0) || (i == 0 && j == numAlign - 1) || (i == numAlign - 1 && j == 0)))\n\t\t\t\tfillRectangle(alignPatPos[i] - 2, alignPatPos[j] - 2, 5, 5, qrcode);\n\t\t}\n\t}\n\t\n\t// Fill version blocks\n\tif (version >= 7) {\n\t\tfillRectangle(qrsize - 11, 0, 3, 6, qrcode);\n\t\tfillRectangle(0, qrsize - 11, 6, 3, qrcode);\n\t}\n}\n\n\n// Draws light function modules and possibly some dark modules onto the given QR Code, without changing\n// non-function modules. This does not draw the format bits. This requires all function modules to be previously\n// marked dark (namely by initializeFunctionModules()), because this may skip redrawing dark function modules.\nstatic void drawLightFunctionModules(uint8_t qrcode[], int version) {\n\t// Draw horizontal and vertical timing patterns\n\tint qrsize = qrcodegen_getSize(qrcode);\n\tfor (int i = 7; i < qrsize - 7; i += 2) {\n\t\tsetModuleBounded(qrcode, 6, i, false);\n\t\tsetModuleBounded(qrcode, i, 6, false);\n\t}\n\t\n\t// Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n\tfor (int dy = -4; dy <= 4; dy++) {\n\t\tfor (int dx = -4; dx <= 4; dx++) {\n\t\t\tint dist = abs(dx);\n\t\t\tif (abs(dy) > dist)\n\t\t\t\tdist = abs(dy);\n\t\t\tif (dist == 2 || dist == 4) {\n\t\t\t\tsetModuleUnbounded(qrcode, 3 + dx, 3 + dy, false);\n\t\t\t\tsetModuleUnbounded(qrcode, qrsize - 4 + dx, 3 + dy, false);\n\t\t\t\tsetModuleUnbounded(qrcode, 3 + dx, qrsize - 4 + dy, false);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Draw numerous alignment patterns\n\tuint8_t alignPatPos[7];\n\tint numAlign = getAlignmentPatternPositions(version, alignPatPos);\n\tfor (int i = 0; i < numAlign; i++) {\n\t\tfor (int j = 0; j < numAlign; j++) {\n\t\t\tif ((i == 0 && j == 0) || (i == 0 && j == numAlign - 1) || (i == numAlign - 1 && j == 0))\n\t\t\t\tcontinue;  // Don't draw on the three finder corners\n\t\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\t\tfor (int dx = -1; dx <= 1; dx++)\n\t\t\t\t\tsetModuleBounded(qrcode, alignPatPos[i] + dx, alignPatPos[j] + dy, dx == 0 && dy == 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Draw version blocks\n\tif (version >= 7) {\n\t\t// Calculate error correction code and pack bits\n\t\tint rem = version;  // version is uint6, in the range [7, 40]\n\t\tfor (int i = 0; i < 12; i++)\n\t\t\trem = (rem << 1) ^ ((rem >> 11) * 0x1F25);\n\t\tlong bits = (long)version << 12 | rem;  // uint18\n\t\tassert(bits >> 18 == 0);\n\t\t\n\t\t// Draw two copies\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tint k = qrsize - 11 + j;\n\t\t\t\tsetModuleBounded(qrcode, k, i, (bits & 1) != 0);\n\t\t\t\tsetModuleBounded(qrcode, i, k, (bits & 1) != 0);\n\t\t\t\tbits >>= 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// Draws two copies of the format bits (with its own error correction code) based\n// on the given mask and error correction level. This always draws all modules of\n// the format bits, unlike drawLightFunctionModules() which might skip dark modules.\nstatic void drawFormatBits(enum qrcodegen_Ecc ecl, enum qrcodegen_Mask mask, uint8_t qrcode[]) {\n\t// Calculate error correction code and pack bits\n\tassert(0 <= (int)mask && (int)mask <= 7);\n\tstatic const int table[] = {1, 0, 3, 2};\n\tint data = table[(int)ecl] << 3 | (int)mask;  // errCorrLvl is uint2, mask is uint3\n\tint rem = data;\n\tfor (int i = 0; i < 10; i++)\n\t\trem = (rem << 1) ^ ((rem >> 9) * 0x537);\n\tint bits = (data << 10 | rem) ^ 0x5412;  // uint15\n\tassert(bits >> 15 == 0);\n\t\n\t// Draw first copy\n\tfor (int i = 0; i <= 5; i++)\n\t\tsetModuleBounded(qrcode, 8, i, getBit(bits, i));\n\tsetModuleBounded(qrcode, 8, 7, getBit(bits, 6));\n\tsetModuleBounded(qrcode, 8, 8, getBit(bits, 7));\n\tsetModuleBounded(qrcode, 7, 8, getBit(bits, 8));\n\tfor (int i = 9; i < 15; i++)\n\t\tsetModuleBounded(qrcode, 14 - i, 8, getBit(bits, i));\n\t\n\t// Draw second copy\n\tint qrsize = qrcodegen_getSize(qrcode);\n\tfor (int i = 0; i < 8; i++)\n\t\tsetModuleBounded(qrcode, qrsize - 1 - i, 8, getBit(bits, i));\n\tfor (int i = 8; i < 15; i++)\n\t\tsetModuleBounded(qrcode, 8, qrsize - 15 + i, getBit(bits, i));\n\tsetModuleBounded(qrcode, 8, qrsize - 8, true);  // Always dark\n}\n\n\n// Calculates and stores an ascending list of positions of alignment patterns\n// for this version number, returning the length of the list (in the range [0,7]).\n// Each position is in the range [0,177), and are used on both the x and y axes.\n// This could be implemented as lookup table of 40 variable-length lists of unsigned bytes.\ntestable int getAlignmentPatternPositions(int version, uint8_t result[7]) {\n\tif (version == 1)\n\t\treturn 0;\n\tint numAlign = version / 7 + 2;\n\tint step = (version == 32) ? 26 :\n\t\t(version * 4 + numAlign * 2 + 1) / (numAlign * 2 - 2) * 2;\n\tfor (int i = numAlign - 1, pos = version * 4 + 10; i >= 1; i--, pos -= step)\n\t\tresult[i] = (uint8_t)pos;\n\tresult[0] = 6;\n\treturn numAlign;\n}\n\n\n// Sets every module in the range [left : left + width] * [top : top + height] to dark.\nstatic void fillRectangle(int left, int top, int width, int height, uint8_t qrcode[]) {\n\tfor (int dy = 0; dy < height; dy++) {\n\t\tfor (int dx = 0; dx < width; dx++)\n\t\t\tsetModuleBounded(qrcode, left + dx, top + dy, true);\n\t}\n}\n\n\n\n/*---- Drawing data modules and masking ----*/\n\n// Draws the raw codewords (including data and ECC) onto the given QR Code. This requires the initial state of\n// the QR Code to be dark at function modules and light at codeword modules (including unused remainder bits).\nstatic void drawCodewords(const uint8_t data[], int dataLen, uint8_t qrcode[]) {\n\tint qrsize = qrcodegen_getSize(qrcode);\n\tint i = 0;  // Bit index into the data\n\t// Do the funny zigzag scan\n\tfor (int right = qrsize - 1; right >= 1; right -= 2) {  // Index of right column in each column pair\n\t\tif (right == 6)\n\t\t\tright = 5;\n\t\tfor (int vert = 0; vert < qrsize; vert++) {  // Vertical counter\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tint x = right - j;  // Actual x coordinate\n\t\t\t\tbool upward = ((right + 1) & 2) == 0;\n\t\t\t\tint y = upward ? qrsize - 1 - vert : vert;  // Actual y coordinate\n\t\t\t\tif (!getModuleBounded(qrcode, x, y) && i < dataLen * 8) {\n\t\t\t\t\tbool dark = getBit(data[i >> 3], 7 - (i & 7));\n\t\t\t\t\tsetModuleBounded(qrcode, x, y, dark);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t// If this QR Code has any remainder bits (0 to 7), they were assigned as\n\t\t\t\t// 0/false/light by the constructor and are left unchanged by this method\n\t\t\t}\n\t\t}\n\t}\n\tassert(i == dataLen * 8);\n}\n\n\n// XORs the codeword modules in this QR Code with the given mask pattern\n// and given pattern of function modules. The codeword bits must be drawn\n// before masking. Due to the arithmetic of XOR, calling applyMask() with\n// the same mask value a second time will undo the mask. A final well-formed\n// QR Code needs exactly one (not zero, two, etc.) mask applied.\nstatic void applyMask(const uint8_t functionModules[], uint8_t qrcode[], enum qrcodegen_Mask mask) {\n\tassert(0 <= (int)mask && (int)mask <= 7);  // Disallows qrcodegen_Mask_AUTO\n\tint qrsize = qrcodegen_getSize(qrcode);\n\tfor (int y = 0; y < qrsize; y++) {\n\t\tfor (int x = 0; x < qrsize; x++) {\n\t\t\tif (getModuleBounded(functionModules, x, y))\n\t\t\t\tcontinue;\n\t\t\tbool invert;\n\t\t\tswitch ((int)mask) {\n\t\t\t\tcase 0:  invert = (x + y) % 2 == 0;                    break;\n\t\t\t\tcase 1:  invert = y % 2 == 0;                          break;\n\t\t\t\tcase 2:  invert = x % 3 == 0;                          break;\n\t\t\t\tcase 3:  invert = (x + y) % 3 == 0;                    break;\n\t\t\t\tcase 4:  invert = (x / 3 + y / 2) % 2 == 0;            break;\n\t\t\t\tcase 5:  invert = x * y % 2 + x * y % 3 == 0;          break;\n\t\t\t\tcase 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;    break;\n\t\t\t\tcase 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;  break;\n\t\t\t\tdefault:  assert(false);  return;\n\t\t\t}\n\t\t\tbool val = getModuleBounded(qrcode, x, y);\n\t\t\tsetModuleBounded(qrcode, x, y, val ^ invert);\n\t\t}\n\t}\n}\n\n\n// Calculates and returns the penalty score based on state of the given QR Code's current modules.\n// This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\nstatic long getPenaltyScore(const uint8_t qrcode[]) {\n\tint qrsize = qrcodegen_getSize(qrcode);\n\tlong result = 0;\n\t\n\t// Adjacent modules in row having same color, and finder-like patterns\n\tfor (int y = 0; y < qrsize; y++) {\n\t\tbool runColor = false;\n\t\tint runX = 0;\n\t\tint runHistory[7] = {0};\n\t\tfor (int x = 0; x < qrsize; x++) {\n\t\t\tif (getModuleBounded(qrcode, x, y) == runColor) {\n\t\t\t\trunX++;\n\t\t\t\tif (runX == 5)\n\t\t\t\t\tresult += PENALTY_N1;\n\t\t\t\telse if (runX > 5)\n\t\t\t\t\tresult++;\n\t\t\t} else {\n\t\t\t\tfinderPenaltyAddHistory(runX, runHistory, qrsize);\n\t\t\t\tif (!runColor)\n\t\t\t\t\tresult += finderPenaltyCountPatterns(runHistory, qrsize) * PENALTY_N3;\n\t\t\t\trunColor = getModuleBounded(qrcode, x, y);\n\t\t\t\trunX = 1;\n\t\t\t}\n\t\t}\n\t\tresult += finderPenaltyTerminateAndCount(runColor, runX, runHistory, qrsize) * PENALTY_N3;\n\t}\n\t// Adjacent modules in column having same color, and finder-like patterns\n\tfor (int x = 0; x < qrsize; x++) {\n\t\tbool runColor = false;\n\t\tint runY = 0;\n\t\tint runHistory[7] = {0};\n\t\tfor (int y = 0; y < qrsize; y++) {\n\t\t\tif (getModuleBounded(qrcode, x, y) == runColor) {\n\t\t\t\trunY++;\n\t\t\t\tif (runY == 5)\n\t\t\t\t\tresult += PENALTY_N1;\n\t\t\t\telse if (runY > 5)\n\t\t\t\t\tresult++;\n\t\t\t} else {\n\t\t\t\tfinderPenaltyAddHistory(runY, runHistory, qrsize);\n\t\t\t\tif (!runColor)\n\t\t\t\t\tresult += finderPenaltyCountPatterns(runHistory, qrsize) * PENALTY_N3;\n\t\t\t\trunColor = getModuleBounded(qrcode, x, y);\n\t\t\t\trunY = 1;\n\t\t\t}\n\t\t}\n\t\tresult += finderPenaltyTerminateAndCount(runColor, runY, runHistory, qrsize) * PENALTY_N3;\n\t}\n\t\n\t// 2*2 blocks of modules having same color\n\tfor (int y = 0; y < qrsize - 1; y++) {\n\t\tfor (int x = 0; x < qrsize - 1; x++) {\n\t\t\tbool  color = getModuleBounded(qrcode, x, y);\n\t\t\tif (  color == getModuleBounded(qrcode, x + 1, y) &&\n\t\t\t      color == getModuleBounded(qrcode, x, y + 1) &&\n\t\t\t      color == getModuleBounded(qrcode, x + 1, y + 1))\n\t\t\t\tresult += PENALTY_N2;\n\t\t}\n\t}\n\t\n\t// Balance of dark and light modules\n\tint dark = 0;\n\tfor (int y = 0; y < qrsize; y++) {\n\t\tfor (int x = 0; x < qrsize; x++) {\n\t\t\tif (getModuleBounded(qrcode, x, y))\n\t\t\t\tdark++;\n\t\t}\n\t}\n\tint total = qrsize * qrsize;  // Note that size is odd, so dark/total != 1/2\n\t// Compute the smallest integer k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%\n\tint k = (int)((labs(dark * 20L - total * 10L) + total - 1) / total) - 1;\n\tassert(0 <= k && k <= 9);\n\tresult += k * PENALTY_N4;\n\tassert(0 <= result && result <= 2568888L);  // Non-tight upper bound based on default values of PENALTY_N1, ..., N4\n\treturn result;\n}\n\n\n// Can only be called immediately after a light run is added, and\n// returns either 0, 1, or 2. A helper function for getPenaltyScore().\nstatic int finderPenaltyCountPatterns(const int runHistory[7], int qrsize) {\n\tint n = runHistory[1];\n\tassert(n <= qrsize * 3);  (void)qrsize;\n\tbool core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n\t// The maximum QR Code size is 177, hence the dark run length n <= 177.\n\t// Arithmetic is promoted to int, so n*4 will not overflow.\n\treturn (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0)\n\t     + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n}\n\n\n// Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\nstatic int finderPenaltyTerminateAndCount(bool currentRunColor, int currentRunLength, int runHistory[7], int qrsize) {\n\tif (currentRunColor) {  // Terminate dark run\n\t\tfinderPenaltyAddHistory(currentRunLength, runHistory, qrsize);\n\t\tcurrentRunLength = 0;\n\t}\n\tcurrentRunLength += qrsize;  // Add light border to final run\n\tfinderPenaltyAddHistory(currentRunLength, runHistory, qrsize);\n\treturn finderPenaltyCountPatterns(runHistory, qrsize);\n}\n\n\n// Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\nstatic void finderPenaltyAddHistory(int currentRunLength, int runHistory[7], int qrsize) {\n\tif (runHistory[0] == 0)\n\t\tcurrentRunLength += qrsize;  // Add light border to initial run\n\tmemmove(&runHistory[1], &runHistory[0], 6 * sizeof(runHistory[0]));\n\trunHistory[0] = currentRunLength;\n}\n\n\n\n/*---- Basic QR Code information ----*/\n\n// Public function - see documentation comment in header file.\nint qrcodegen_getSize(const uint8_t qrcode[]) {\n\tassert(qrcode != NULL);\n\tint result = qrcode[0];\n\tassert((qrcodegen_VERSION_MIN * 4 + 17) <= result\n\t\t&& result <= (qrcodegen_VERSION_MAX * 4 + 17));\n\treturn result;\n}\n\n\n// Public function - see documentation comment in header file.\nbool qrcodegen_getModule(const uint8_t qrcode[], int x, int y) {\n\tassert(qrcode != NULL);\n\tint qrsize = qrcode[0];\n\treturn (0 <= x && x < qrsize && 0 <= y && y < qrsize) && getModuleBounded(qrcode, x, y);\n}\n\n\n// Returns the color of the module at the given coordinates, which must be in bounds.\ntestable bool getModuleBounded(const uint8_t qrcode[], int x, int y) {\n\tint qrsize = qrcode[0];\n\tassert(21 <= qrsize && qrsize <= 177 && 0 <= x && x < qrsize && 0 <= y && y < qrsize);\n\tint index = y * qrsize + x;\n\treturn getBit(qrcode[(index >> 3) + 1], index & 7);\n}\n\n\n// Sets the color of the module at the given coordinates, which must be in bounds.\ntestable void setModuleBounded(uint8_t qrcode[], int x, int y, bool isDark) {\n\tint qrsize = qrcode[0];\n\tassert(21 <= qrsize && qrsize <= 177 && 0 <= x && x < qrsize && 0 <= y && y < qrsize);\n\tint index = y * qrsize + x;\n\tint bitIndex = index & 7;\n\tint byteIndex = (index >> 3) + 1;\n\tif (isDark)\n\t\tqrcode[byteIndex] |= 1 << bitIndex;\n\telse\n\t\tqrcode[byteIndex] &= (1 << bitIndex) ^ 0xFF;\n}\n\n\n// Sets the color of the module at the given coordinates, doing nothing if out of bounds.\ntestable void setModuleUnbounded(uint8_t qrcode[], int x, int y, bool isDark) {\n\tint qrsize = qrcode[0];\n\tif (0 <= x && x < qrsize && 0 <= y && y < qrsize)\n\t\tsetModuleBounded(qrcode, x, y, isDark);\n}\n\n\n// Returns true iff the i'th bit of x is set to 1. Requires x >= 0 and 0 <= i <= 14.\nstatic bool getBit(int x, int i) {\n\treturn ((x >> i) & 1) != 0;\n}\n\n\n\n/*---- Segment handling ----*/\n\n// Public function - see documentation comment in header file.\nbool qrcodegen_isNumeric(const char *text) {\n\tassert(text != NULL);\n\tfor (; *text != '\\0'; text++) {\n\t\tif (*text < '0' || *text > '9')\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n\n// Public function - see documentation comment in header file.\nbool qrcodegen_isAlphanumeric(const char *text) {\n\tassert(text != NULL);\n\tfor (; *text != '\\0'; text++) {\n\t\tif (strchr(ALPHANUMERIC_CHARSET, *text) == NULL)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n\n// Public function - see documentation comment in header file.\nsize_t qrcodegen_calcSegmentBufferSize(enum qrcodegen_Mode mode, size_t numChars) {\n\tint temp = calcSegmentBitLength(mode, numChars);\n\tif (temp == LENGTH_OVERFLOW)\n\t\treturn SIZE_MAX;\n\tassert(0 <= temp && temp <= INT16_MAX);\n\treturn ((size_t)temp + 7) / 8;\n}\n\n\n// Returns the number of data bits needed to represent a segment\n// containing the given number of characters using the given mode. Notes:\n// - Returns LENGTH_OVERFLOW on failure, i.e. numChars > INT16_MAX\n//   or the number of needed bits exceeds INT16_MAX (i.e. 32767).\n// - Otherwise, all valid results are in the range [0, INT16_MAX].\n// - For byte mode, numChars measures the number of bytes, not Unicode code points.\n// - For ECI mode, numChars must be 0, and the worst-case number of bits is returned.\n//   An actual ECI segment can have shorter data. For non-ECI modes, the result is exact.\ntestable int calcSegmentBitLength(enum qrcodegen_Mode mode, size_t numChars) {\n\t// All calculations are designed to avoid overflow on all platforms\n\tif (numChars > (unsigned int)INT16_MAX)\n\t\treturn LENGTH_OVERFLOW;\n\tlong result = (long)numChars;\n\tif (mode == qrcodegen_Mode_NUMERIC)\n\t\tresult = (result * 10 + 2) / 3;  // ceil(10/3 * n)\n\telse if (mode == qrcodegen_Mode_ALPHANUMERIC)\n\t\tresult = (result * 11 + 1) / 2;  // ceil(11/2 * n)\n\telse if (mode == qrcodegen_Mode_BYTE)\n\t\tresult *= 8;\n\telse if (mode == qrcodegen_Mode_KANJI)\n\t\tresult *= 13;\n\telse if (mode == qrcodegen_Mode_ECI && numChars == 0)\n\t\tresult = 3 * 8;\n\telse {  // Invalid argument\n\t\tassert(false);\n\t\treturn LENGTH_OVERFLOW;\n\t}\n\tassert(result >= 0);\n\tif (result > INT16_MAX)\n\t\treturn LENGTH_OVERFLOW;\n\treturn (int)result;\n}\n\n\n// Public function - see documentation comment in header file.\nstruct qrcodegen_Segment qrcodegen_makeBytes(const uint8_t data[], size_t len, uint8_t buf[]) {\n\tassert(data != NULL || len == 0);\n\tstruct qrcodegen_Segment result;\n\tresult.mode = qrcodegen_Mode_BYTE;\n\tresult.bitLength = calcSegmentBitLength(result.mode, len);\n\tassert(result.bitLength != LENGTH_OVERFLOW);\n\tresult.numChars = (int)len;\n\tif (len > 0)\n\t\tmemcpy(buf, data, len * sizeof(buf[0]));\n\tresult.data = buf;\n\treturn result;\n}\n\n\n// Public function - see documentation comment in header file.\nstruct qrcodegen_Segment qrcodegen_makeNumeric(const char *digits, uint8_t buf[]) {\n\tassert(digits != NULL);\n\tstruct qrcodegen_Segment result;\n\tsize_t len = strlen(digits);\n\tresult.mode = qrcodegen_Mode_NUMERIC;\n\tint bitLen = calcSegmentBitLength(result.mode, len);\n\tassert(bitLen != LENGTH_OVERFLOW);\n\tresult.numChars = (int)len;\n\tif (bitLen > 0)\n\t\tmemset(buf, 0, ((size_t)bitLen + 7) / 8 * sizeof(buf[0]));\n\tresult.bitLength = 0;\n\t\n\tunsigned int accumData = 0;\n\tint accumCount = 0;\n\tfor (; *digits != '\\0'; digits++) {\n\t\tchar c = *digits;\n\t\tassert('0' <= c && c <= '9');\n\t\taccumData = accumData * 10 + (unsigned int)(c - '0');\n\t\taccumCount++;\n\t\tif (accumCount == 3) {\n\t\t\tappendBitsToBuffer(accumData, 10, buf, &result.bitLength);\n\t\t\taccumData = 0;\n\t\t\taccumCount = 0;\n\t\t}\n\t}\n\tif (accumCount > 0)  // 1 or 2 digits remaining\n\t\tappendBitsToBuffer(accumData, accumCount * 3 + 1, buf, &result.bitLength);\n\tassert(result.bitLength == bitLen);\n\tresult.data = buf;\n\treturn result;\n}\n\n\n// Public function - see documentation comment in header file.\nstruct qrcodegen_Segment qrcodegen_makeAlphanumeric(const char *text, uint8_t buf[]) {\n\tassert(text != NULL);\n\tstruct qrcodegen_Segment result;\n\tsize_t len = strlen(text);\n\tresult.mode = qrcodegen_Mode_ALPHANUMERIC;\n\tint bitLen = calcSegmentBitLength(result.mode, len);\n\tassert(bitLen != LENGTH_OVERFLOW);\n\tresult.numChars = (int)len;\n\tif (bitLen > 0)\n\t\tmemset(buf, 0, ((size_t)bitLen + 7) / 8 * sizeof(buf[0]));\n\tresult.bitLength = 0;\n\t\n\tunsigned int accumData = 0;\n\tint accumCount = 0;\n\tfor (; *text != '\\0'; text++) {\n\t\tconst char *temp = strchr(ALPHANUMERIC_CHARSET, *text);\n\t\tassert(temp != NULL);\n\t\taccumData = accumData * 45 + (unsigned int)(temp - ALPHANUMERIC_CHARSET);\n\t\taccumCount++;\n\t\tif (accumCount == 2) {\n\t\t\tappendBitsToBuffer(accumData, 11, buf, &result.bitLength);\n\t\t\taccumData = 0;\n\t\t\taccumCount = 0;\n\t\t}\n\t}\n\tif (accumCount > 0)  // 1 character remaining\n\t\tappendBitsToBuffer(accumData, 6, buf, &result.bitLength);\n\tassert(result.bitLength == bitLen);\n\tresult.data = buf;\n\treturn result;\n}\n\n\n// Public function - see documentation comment in header file.\nstruct qrcodegen_Segment qrcodegen_makeEci(long assignVal, uint8_t buf[]) {\n\tstruct qrcodegen_Segment result;\n\tresult.mode = qrcodegen_Mode_ECI;\n\tresult.numChars = 0;\n\tresult.bitLength = 0;\n\tif (assignVal < 0)\n\t\tassert(false);\n\telse if (assignVal < (1 << 7)) {\n\t\tmemset(buf, 0, 1 * sizeof(buf[0]));\n\t\tappendBitsToBuffer((unsigned int)assignVal, 8, buf, &result.bitLength);\n\t} else if (assignVal < (1 << 14)) {\n\t\tmemset(buf, 0, 2 * sizeof(buf[0]));\n\t\tappendBitsToBuffer(2, 2, buf, &result.bitLength);\n\t\tappendBitsToBuffer((unsigned int)assignVal, 14, buf, &result.bitLength);\n\t} else if (assignVal < 1000000L) {\n\t\tmemset(buf, 0, 3 * sizeof(buf[0]));\n\t\tappendBitsToBuffer(6, 3, buf, &result.bitLength);\n\t\tappendBitsToBuffer((unsigned int)(assignVal >> 10), 11, buf, &result.bitLength);\n\t\tappendBitsToBuffer((unsigned int)(assignVal & 0x3FF), 10, buf, &result.bitLength);\n\t} else\n\t\tassert(false);\n\tresult.data = buf;\n\treturn result;\n}\n\n\n// Calculates the number of bits needed to encode the given segments at the given version.\n// Returns a non-negative number if successful. Otherwise returns LENGTH_OVERFLOW if a segment\n// has too many characters to fit its length field, or the total bits exceeds INT16_MAX.\ntestable int getTotalBits(const struct qrcodegen_Segment segs[], size_t len, int version) {\n\tassert(segs != NULL || len == 0);\n\tlong result = 0;\n\tfor (size_t i = 0; i < len; i++) {\n\t\tint numChars  = segs[i].numChars;\n\t\tint bitLength = segs[i].bitLength;\n\t\tassert(0 <= numChars  && numChars  <= INT16_MAX);\n\t\tassert(0 <= bitLength && bitLength <= INT16_MAX);\n\t\tint ccbits = numCharCountBits(segs[i].mode, version);\n\t\tassert(0 <= ccbits && ccbits <= 16);\n\t\tif (numChars >= (1L << ccbits))\n\t\t\treturn LENGTH_OVERFLOW;  // The segment's length doesn't fit the field's bit width\n\t\tresult += 4L + ccbits + bitLength;\n\t\tif (result > INT16_MAX)\n\t\t\treturn LENGTH_OVERFLOW;  // The sum might overflow an int type\n\t}\n\tassert(0 <= result && result <= INT16_MAX);\n\treturn (int)result;\n}\n\n\n// Returns the bit width of the character count field for a segment in the given mode\n// in a QR Code at the given version number. The result is in the range [0, 16].\nstatic int numCharCountBits(enum qrcodegen_Mode mode, int version) {\n\tassert(qrcodegen_VERSION_MIN <= version && version <= qrcodegen_VERSION_MAX);\n\tint i = (version + 7) / 17;\n\tswitch (mode) {\n\t\tcase qrcodegen_Mode_NUMERIC     : { static const int temp[] = {10, 12, 14}; return temp[i]; }\n\t\tcase qrcodegen_Mode_ALPHANUMERIC: { static const int temp[] = { 9, 11, 13}; return temp[i]; }\n\t\tcase qrcodegen_Mode_BYTE        : { static const int temp[] = { 8, 16, 16}; return temp[i]; }\n\t\tcase qrcodegen_Mode_KANJI       : { static const int temp[] = { 8, 10, 12}; return temp[i]; }\n\t\tcase qrcodegen_Mode_ECI         : return 0;\n\t\tdefault:  assert(false);  return -1;  // Dummy value\n\t}\n}\n\n\n#undef LENGTH_OVERFLOW\n"
        },
        {
          "name": "qrcodegen.h",
          "type": "blob",
          "size": 21.3642578125,
          "content": "/* \n * QR Code generator library (C)\n * \n * Copyright (c) Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/qr-code-generator-library\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n#pragma once\n\n/// #include <stdbool.h>\n#ifndef _STDBOOL\n#define _STDBOOL\n\n#define __bool_true_false_are_defined 1\n\n#ifndef __cplusplus\n\n#define bool  _Bool\n#define false 0\n#define true  1\n\n#endif /* __cplusplus */\n\n#endif /* _STDBOOL */\n\n#include <stddef.h>\n\n///#include <stdint.h>\n#define _STDINT\n\n//#include <vcruntime.h>\n\n//#if _VCRT_COMPILER_PREPROCESSOR\n\n//#pragma warning(push)\n//#pragma warning(disable: _VCRUNTIME_DISABLED_WARNINGS)\n\ntypedef signed char        int8_t;\ntypedef short              int16_t;\ntypedef int                int32_t;\n//typedef long long          int64_t;\ntypedef unsigned char      uint8_t;\ntypedef unsigned short     uint16_t;\ntypedef unsigned int       uint32_t;\n//typedef unsigned long long uint64_t;\n\ntypedef signed char        int_least8_t;\ntypedef short              int_least16_t;\ntypedef int                int_least32_t;\n//typedef long long          int_least64_t;\ntypedef unsigned char      uint_least8_t;\ntypedef unsigned short     uint_least16_t;\ntypedef unsigned int       uint_least32_t;\n//typedef unsigned long long uint_least64_t;\n\ntypedef signed char        int_fast8_t;\ntypedef int                int_fast16_t;\ntypedef int                int_fast32_t;\n//typedef long long          int_fast64_t;\ntypedef unsigned char      uint_fast8_t;\ntypedef unsigned int       uint_fast16_t;\ntypedef unsigned int       uint_fast32_t;\n//typedef unsigned long long uint_fast64_t;\n\n//typedef long long          intmax_t;\n//typedef unsigned long long uintmax_t;\n\n// These macros must exactly match those in the Windows SDK's intsafe.h.\n#define INT8_MIN         (-127i8 - 1)\n#define INT16_MIN        (-32767i16 - 1)\n#define INT32_MIN        (-2147483647i32 - 1)\n#define INT64_MIN        (-9223372036854775807i64 - 1)\n#define INT8_MAX         127i8\n#define INT16_MAX        32767i16\n#define INT32_MAX        2147483647i32\n#define INT64_MAX        9223372036854775807i64\n#define UINT8_MAX        0xffui8\n#define UINT16_MAX       0xffffui16\n#define UINT32_MAX       0xffffffffui32\n#define UINT64_MAX       0xffffffffffffffffui64\n\n#define INT_LEAST8_MIN   INT8_MIN\n#define INT_LEAST16_MIN  INT16_MIN\n#define INT_LEAST32_MIN  INT32_MIN\n#define INT_LEAST64_MIN  INT64_MIN\n#define INT_LEAST8_MAX   INT8_MAX\n#define INT_LEAST16_MAX  INT16_MAX\n#define INT_LEAST32_MAX  INT32_MAX\n#define INT_LEAST64_MAX  INT64_MAX\n#define UINT_LEAST8_MAX  UINT8_MAX\n#define UINT_LEAST16_MAX UINT16_MAX\n#define UINT_LEAST32_MAX UINT32_MAX\n#define UINT_LEAST64_MAX UINT64_MAX\n\n#define INT_FAST8_MIN    INT8_MIN\n#define INT_FAST16_MIN   INT32_MIN\n#define INT_FAST32_MIN   INT32_MIN\n#define INT_FAST64_MIN   INT64_MIN\n#define INT_FAST8_MAX    INT8_MAX\n#define INT_FAST16_MAX   INT32_MAX\n#define INT_FAST32_MAX   INT32_MAX\n#define INT_FAST64_MAX   INT64_MAX\n#define UINT_FAST8_MAX   UINT8_MAX\n#define UINT_FAST16_MAX  UINT32_MAX\n#define UINT_FAST32_MAX  UINT32_MAX\n#define UINT_FAST64_MAX  UINT64_MAX\n\n#ifdef _WIN64\n#define INTPTR_MIN   INT64_MIN\n#define INTPTR_MAX   INT64_MAX\n#define UINTPTR_MAX  UINT64_MAX\n#else\n#define INTPTR_MIN   INT32_MIN\n#define INTPTR_MAX   INT32_MAX\n#define UINTPTR_MAX  UINT32_MAX\n#endif\n\n#define INTMAX_MIN       INT64_MIN\n#define INTMAX_MAX       INT64_MAX\n#define UINTMAX_MAX      UINT64_MAX\n\n#define PTRDIFF_MIN      INTPTR_MIN\n#define PTRDIFF_MAX      INTPTR_MAX\n\n#ifndef SIZE_MAX\n\t// SIZE_MAX definition must match exactly with limits.h for modules support.\n#ifdef _WIN64\n#define SIZE_MAX 0xffffffffffffffffui64\n#else\n#define SIZE_MAX 0xffffffffui32\n#endif\n#endif\n\n#define SIG_ATOMIC_MIN   INT32_MIN\n#define SIG_ATOMIC_MAX   INT32_MAX\n\n//#define WCHAR_MIN        0x0000\n//#define WCHAR_MAX        0xffff\n\n#define WINT_MIN         0x0000\n#define WINT_MAX         0xffff\n\n#define INT8_C(x)    (x)\n#define INT16_C(x)   (x)\n#define INT32_C(x)   (x)\n#define INT64_C(x)   (x ## LL)\n\n#define UINT8_C(x)   (x)\n#define UINT16_C(x)  (x)\n#define UINT32_C(x)  (x ## U)\n#define UINT64_C(x)  (x ## ULL)\n\n#define INTMAX_C(x)  INT64_C(x)\n#define UINTMAX_C(x) UINT64_C(x)\n\n//#pragma warning(pop) // _VCRUNTIME_DISABLED_WARNINGS\n\n//#endif // _VCRT_COMPILER_PREPROCESSOR\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* \n * This library creates QR Code symbols, which is a type of two-dimension barcode.\n * Invented by Denso Wave and described in the ISO/IEC 18004 standard.\n * A QR Code structure is an immutable square grid of dark and light cells.\n * The library provides functions to create a QR Code from text or binary data.\n * The library covers the QR Code Model 2 specification, supporting all versions (sizes)\n * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.\n * \n * Ways to create a QR Code object:\n * - High level: Take the payload data and call qrcodegen_encodeText() or qrcodegen_encodeBinary().\n * - Low level: Custom-make the list of segments and call\n *   qrcodegen_encodeSegments() or qrcodegen_encodeSegmentsAdvanced().\n * (Note that all ways require supplying the desired error correction level and various byte buffers.)\n */\n\n\n/*---- Enum and struct types----*/\n\n/* \n * The error correction level in a QR Code symbol.\n */\nenum qrcodegen_Ecc {\n\t// Must be declared in ascending order of error protection\n\t// so that an internal qrcodegen function works properly\n\tqrcodegen_Ecc_LOW = 0 ,  // The QR Code can tolerate about  7% erroneous codewords\n\tqrcodegen_Ecc_MEDIUM  ,  // The QR Code can tolerate about 15% erroneous codewords\n\tqrcodegen_Ecc_QUARTILE,  // The QR Code can tolerate about 25% erroneous codewords\n\tqrcodegen_Ecc_HIGH    ,  // The QR Code can tolerate about 30% erroneous codewords\n};\n\n\n/* \n * The mask pattern used in a QR Code symbol.\n */\nenum qrcodegen_Mask {\n\t// A special value to tell the QR Code encoder to\n\t// automatically select an appropriate mask pattern\n\tqrcodegen_Mask_AUTO = -1,\n\t// The eight actual mask patterns\n\tqrcodegen_Mask_0 = 0,\n\tqrcodegen_Mask_1,\n\tqrcodegen_Mask_2,\n\tqrcodegen_Mask_3,\n\tqrcodegen_Mask_4,\n\tqrcodegen_Mask_5,\n\tqrcodegen_Mask_6,\n\tqrcodegen_Mask_7,\n};\n\n\n/* \n * Describes how a segment's data bits are interpreted.\n */\nenum qrcodegen_Mode {\n\tqrcodegen_Mode_NUMERIC      = 0x1,\n\tqrcodegen_Mode_ALPHANUMERIC = 0x2,\n\tqrcodegen_Mode_BYTE         = 0x4,\n\tqrcodegen_Mode_KANJI        = 0x8,\n\tqrcodegen_Mode_ECI          = 0x7,\n};\n\n\n/* \n * A segment of character/binary/control data in a QR Code symbol.\n * The mid-level way to create a segment is to take the payload data\n * and call a factory function such as qrcodegen_makeNumeric().\n * The low-level way to create a segment is to custom-make the bit buffer\n * and initialize a qrcodegen_Segment struct with appropriate values.\n * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.\n * Any segment longer than this is meaningless for the purpose of generating QR Codes.\n * Moreover, the maximum allowed bit length is 32767 because\n * the largest QR Code (version 40) has 31329 modules.\n */\nstruct qrcodegen_Segment {\n\t// The mode indicator of this segment.\n\tenum qrcodegen_Mode mode;\n\t\n\t// The length of this segment's unencoded data. Measured in characters for\n\t// numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n\t// Always zero or positive. Not the same as the data's bit length.\n\tint numChars;\n\t\n\t// The data bits of this segment, packed in bitwise big endian.\n\t// Can be null if the bit length is zero.\n\tuint8_t *data;\n\t\n\t// The number of valid data bits used in the buffer. Requires\n\t// 0 <= bitLength <= 32767, and bitLength <= (capacity of data array) * 8.\n\t// The character count (numChars) must agree with the mode and the bit buffer length.\n\tint bitLength;\n};\n\n\n\n/*---- Macro constants and functions ----*/\n\n#define qrcodegen_VERSION_MIN   1  // The minimum version number supported in the QR Code Model 2 standard\n#define qrcodegen_VERSION_MAX  40  // The maximum version number supported in the QR Code Model 2 standard\n\n// Calculates the number of bytes needed to store any QR Code up to and including the given version number,\n// as a compile-time constant. For example, 'uint8_t buffer[qrcodegen_BUFFER_LEN_FOR_VERSION(25)];'\n// can store any single QR Code from version 1 to 25 (inclusive). The result fits in an int (or int16).\n// Requires qrcodegen_VERSION_MIN <= n <= qrcodegen_VERSION_MAX.\n#define qrcodegen_BUFFER_LEN_FOR_VERSION(n)  ((((n) * 4 + 17) * ((n) * 4 + 17) + 7) / 8 + 1)\n\n// The worst-case number of bytes needed to store one QR Code, up to and including\n// version 40. This value equals 3918, which is just under 4 kilobytes.\n// Use this more convenient value to avoid calculating tighter memory bounds for buffers.\n#define qrcodegen_BUFFER_LEN_MAX  qrcodegen_BUFFER_LEN_FOR_VERSION(qrcodegen_VERSION_MAX)\n\n\n\n/*---- Functions (high level) to generate QR Codes ----*/\n\n/* \n * Encodes the given text string to a QR Code, returning true if successful.\n * If the data is too long to fit in any version in the given range\n * at the given ECC level, then false is returned.\n * \n * The input text must be encoded in UTF-8 and contain no NULs.\n * Requires 1 <= minVersion <= maxVersion <= 40.\n * \n * The smallest possible QR Code version within the given range is automatically\n * chosen for the output. Iff boostEcl is true, then the ECC level of the result\n * may be higher than the ecl argument if it can be done without increasing the\n * version. The mask is either between qrcodegen_Mask_0 to 7 to force that mask, or\n * qrcodegen_Mask_AUTO to automatically choose an appropriate mask (which may be slow).\n * \n * About the arrays, letting len = qrcodegen_BUFFER_LEN_FOR_VERSION(maxVersion):\n * - Before calling the function:\n *   - The array ranges tempBuffer[0 : len] and qrcode[0 : len] must allow\n *     reading and writing; hence each array must have a length of at least len.\n *   - The two ranges must not overlap (aliasing).\n *   - The initial state of both ranges can be uninitialized\n *     because the function always writes before reading.\n * - After the function returns:\n *   - Both ranges have no guarantee on which elements are initialized and what values are stored.\n *   - tempBuffer contains no useful data and should be treated as entirely uninitialized.\n *   - If successful, qrcode can be passed into qrcodegen_getSize() and qrcodegen_getModule().\n * \n * If successful, the resulting QR Code may use numeric,\n * alphanumeric, or byte mode to encode the text.\n * \n * In the most optimistic case, a QR Code at version 40 with low ECC\n * can hold any UTF-8 string up to 2953 bytes, or any alphanumeric string\n * up to 4296 characters, or any digit string up to 7089 characters.\n * These numbers represent the hard upper limit of the QR Code standard.\n * \n * Please consult the QR Code specification for information on\n * data capacities per version, ECC level, and text encoding mode.\n */\nbool qrcodegen_encodeText(const char *text, uint8_t tempBuffer[], uint8_t qrcode[],\n\tenum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl);\n\n\n/* \n * Encodes the given binary data to a QR Code, returning true if successful.\n * If the data is too long to fit in any version in the given range\n * at the given ECC level, then false is returned.\n * \n * Requires 1 <= minVersion <= maxVersion <= 40.\n * \n * The smallest possible QR Code version within the given range is automatically\n * chosen for the output. Iff boostEcl is true, then the ECC level of the result\n * may be higher than the ecl argument if it can be done without increasing the\n * version. The mask is either between qrcodegen_Mask_0 to 7 to force that mask, or\n * qrcodegen_Mask_AUTO to automatically choose an appropriate mask (which may be slow).\n * \n * About the arrays, letting len = qrcodegen_BUFFER_LEN_FOR_VERSION(maxVersion):\n * - Before calling the function:\n *   - The array ranges dataAndTemp[0 : len] and qrcode[0 : len] must allow\n *     reading and writing; hence each array must have a length of at least len.\n *   - The two ranges must not overlap (aliasing).\n *   - The input array range dataAndTemp[0 : dataLen] should normally be\n *     valid UTF-8 text, but is not required by the QR Code standard.\n *   - The initial state of dataAndTemp[dataLen : len] and qrcode[0 : len]\n *     can be uninitialized because the function always writes before reading.\n * - After the function returns:\n *   - Both ranges have no guarantee on which elements are initialized and what values are stored.\n *   - dataAndTemp contains no useful data and should be treated as entirely uninitialized.\n *   - If successful, qrcode can be passed into qrcodegen_getSize() and qrcodegen_getModule().\n * \n * If successful, the resulting QR Code will use byte mode to encode the data.\n * \n * In the most optimistic case, a QR Code at version 40 with low ECC can hold any byte\n * sequence up to length 2953. This is the hard upper limit of the QR Code standard.\n * \n * Please consult the QR Code specification for information on\n * data capacities per version, ECC level, and text encoding mode.\n */\nbool qrcodegen_encodeBinary(uint8_t dataAndTemp[], size_t dataLen, uint8_t qrcode[],\n\tenum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl);\n\n\n/*---- Functions (low level) to generate QR Codes ----*/\n\n/* \n * Encodes the given segments to a QR Code, returning true if successful.\n * If the data is too long to fit in any version at the given ECC level,\n * then false is returned.\n * \n * The smallest possible QR Code version is automatically chosen for\n * the output. The ECC level of the result may be higher than the\n * ecl argument if it can be done without increasing the version.\n * \n * About the byte arrays, letting len = qrcodegen_BUFFER_LEN_FOR_VERSION(qrcodegen_VERSION_MAX):\n * - Before calling the function:\n *   - The array ranges tempBuffer[0 : len] and qrcode[0 : len] must allow\n *     reading and writing; hence each array must have a length of at least len.\n *   - The two ranges must not overlap (aliasing).\n *   - The initial state of both ranges can be uninitialized\n *     because the function always writes before reading.\n *   - The input array segs can contain segments whose data buffers overlap with tempBuffer.\n * - After the function returns:\n *   - Both ranges have no guarantee on which elements are initialized and what values are stored.\n *   - tempBuffer contains no useful data and should be treated as entirely uninitialized.\n *   - Any segment whose data buffer overlaps with tempBuffer[0 : len]\n *     must be treated as having invalid values in that array.\n *   - If successful, qrcode can be passed into qrcodegen_getSize() and qrcodegen_getModule().\n * \n * Please consult the QR Code specification for information on\n * data capacities per version, ECC level, and text encoding mode.\n * \n * This function allows the user to create a custom sequence of segments that switches\n * between modes (such as alphanumeric and byte) to encode text in less space.\n * This is a low-level API; the high-level API is qrcodegen_encodeText() and qrcodegen_encodeBinary().\n */\nbool qrcodegen_encodeSegments(const struct qrcodegen_Segment segs[], size_t len,\n\tenum qrcodegen_Ecc ecl, uint8_t tempBuffer[], uint8_t qrcode[]);\n\n\n/* \n * Encodes the given segments to a QR Code, returning true if successful.\n * If the data is too long to fit in any version in the given range\n * at the given ECC level, then false is returned.\n * \n * Requires 1 <= minVersion <= maxVersion <= 40.\n * \n * The smallest possible QR Code version within the given range is automatically\n * chosen for the output. Iff boostEcl is true, then the ECC level of the result\n * may be higher than the ecl argument if it can be done without increasing the\n * version. The mask is either between qrcodegen_Mask_0 to 7 to force that mask, or\n * qrcodegen_Mask_AUTO to automatically choose an appropriate mask (which may be slow).\n * \n * About the byte arrays, letting len = qrcodegen_BUFFER_LEN_FOR_VERSION(qrcodegen_VERSION_MAX):\n * - Before calling the function:\n *   - The array ranges tempBuffer[0 : len] and qrcode[0 : len] must allow\n *     reading and writing; hence each array must have a length of at least len.\n *   - The two ranges must not overlap (aliasing).\n *   - The initial state of both ranges can be uninitialized\n *     because the function always writes before reading.\n *   - The input array segs can contain segments whose data buffers overlap with tempBuffer.\n * - After the function returns:\n *   - Both ranges have no guarantee on which elements are initialized and what values are stored.\n *   - tempBuffer contains no useful data and should be treated as entirely uninitialized.\n *   - Any segment whose data buffer overlaps with tempBuffer[0 : len]\n *     must be treated as having invalid values in that array.\n *   - If successful, qrcode can be passed into qrcodegen_getSize() and qrcodegen_getModule().\n * \n * Please consult the QR Code specification for information on\n * data capacities per version, ECC level, and text encoding mode.\n * \n * This function allows the user to create a custom sequence of segments that switches\n * between modes (such as alphanumeric and byte) to encode text in less space.\n * This is a low-level API; the high-level API is qrcodegen_encodeText() and qrcodegen_encodeBinary().\n */\nbool qrcodegen_encodeSegmentsAdvanced(const struct qrcodegen_Segment segs[], size_t len, enum qrcodegen_Ecc ecl,\n\tint minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl, uint8_t tempBuffer[], uint8_t qrcode[]);\n\n\n/* \n * Tests whether the given string can be encoded as a segment in numeric mode.\n * A string is encodable iff each character is in the range 0 to 9.\n */\nbool qrcodegen_isNumeric(const char *text);\n\n\n/* \n * Tests whether the given string can be encoded as a segment in alphanumeric mode.\n * A string is encodable iff each character is in the following set: 0 to 9, A to Z\n * (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n */\nbool qrcodegen_isAlphanumeric(const char *text);\n\n\n/* \n * Returns the number of bytes (uint8_t) needed for the data buffer of a segment\n * containing the given number of characters using the given mode. Notes:\n * - Returns SIZE_MAX on failure, i.e. numChars > INT16_MAX or the internal\n *   calculation of the number of needed bits exceeds INT16_MAX (i.e. 32767).\n * - Otherwise, all valid results are in the range [0, ceil(INT16_MAX / 8)], i.e. at most 4096.\n * - It is okay for the user to allocate more bytes for the buffer than needed.\n * - For byte mode, numChars measures the number of bytes, not Unicode code points.\n * - For ECI mode, numChars must be 0, and the worst-case number of bytes is returned.\n *   An actual ECI segment can have shorter data. For non-ECI modes, the result is exact.\n */\nsize_t qrcodegen_calcSegmentBufferSize(enum qrcodegen_Mode mode, size_t numChars);\n\n\n/* \n * Returns a segment representing the given binary data encoded in\n * byte mode. All input byte arrays are acceptable. Any text string\n * can be converted to UTF-8 bytes and encoded as a byte mode segment.\n */\nstruct qrcodegen_Segment qrcodegen_makeBytes(const uint8_t data[], size_t len, uint8_t buf[]);\n\n\n/* \n * Returns a segment representing the given string of decimal digits encoded in numeric mode.\n */\nstruct qrcodegen_Segment qrcodegen_makeNumeric(const char *digits, uint8_t buf[]);\n\n\n/* \n * Returns a segment representing the given text string encoded in alphanumeric mode.\n * The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n * dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n */\nstruct qrcodegen_Segment qrcodegen_makeAlphanumeric(const char *text, uint8_t buf[]);\n\n\n/* \n * Returns a segment representing an Extended Channel Interpretation\n * (ECI) designator with the given assignment value.\n */\nstruct qrcodegen_Segment qrcodegen_makeEci(long assignVal, uint8_t buf[]);\n\n\n/*---- Functions to extract raw data from QR Codes ----*/\n\n/* \n * Returns the side length of the given QR Code, assuming that encoding succeeded.\n * The result is in the range [21, 177]. Note that the length of the array buffer\n * is related to the side length - every 'uint8_t qrcode[]' must have length at least\n * qrcodegen_BUFFER_LEN_FOR_VERSION(version), which equals ceil(size^2 / 8 + 1).\n */\nint qrcodegen_getSize(const uint8_t qrcode[]);\n\n\n/* \n * Returns the color of the module (pixel) at the given coordinates, which is false\n * for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n * If the given coordinates are out of bounds, then false (light) is returned.\n */\nbool qrcodegen_getModule(const uint8_t qrcode[], int x, int y);\n\n\n#ifdef __cplusplus\n}\n#endif\n"
        },
        {
          "name": "res",
          "type": "tree",
          "content": null
        },
        {
          "name": "resA",
          "type": "tree",
          "content": null
        },
        {
          "name": "resK",
          "type": "tree",
          "content": null
        },
        {
          "name": "resM",
          "type": "tree",
          "content": null
        },
        {
          "name": "resN",
          "type": "tree",
          "content": null
        },
        {
          "name": "resS",
          "type": "tree",
          "content": null
        },
        {
          "name": "schtasks.xml",
          "type": "blob",
          "size": 2.892578125,
          "content": "﻿<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n<Task version=\"1.2\" xmlns=\"http://schemas.microsoft.com/windows/2004/02/mit/task\">\r\n  <RegistrationInfo>\r\n    <Date>2009-11-20T12:49:45</Date>\r\n    <Author>CrystalDiskInfo</Author>\r\n  </RegistrationInfo>\r\n  <Triggers>\r\n    <LogonTrigger>\r\n      <Enabled>true</Enabled>\r\n    </LogonTrigger>\r\n  </Triggers>\r\n  <Principals>\r\n    <Principal id=\"Author\">\r\n      <GroupId>S-1-5-32-544</GroupId>\r\n      <RunLevel>HighestAvailable</RunLevel>\r\n    </Principal>\r\n  </Principals>\r\n  <Settings>\r\n    <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>\r\n    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>\r\n    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>\r\n    <AllowHardTerminate>false</AllowHardTerminate>\r\n    <StartWhenAvailable>false</StartWhenAvailable>\r\n    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>\r\n    <IdleSettings>\r\n      <StopOnIdleEnd>true</StopOnIdleEnd>\r\n      <RestartOnIdle>false</RestartOnIdle>\r\n    </IdleSettings>\r\n    <AllowStartOnDemand>true</AllowStartOnDemand>\r\n    <Enabled>true</Enabled>\r\n    <Hidden>false</Hidden>\r\n    <RunOnlyIfIdle>false</RunOnlyIfIdle>\r\n    <WakeToRun>false</WakeToRun>\r\n    <ExecutionTimeLimit>PT0S</ExecutionTimeLimit>\r\n    <Priority>7</Priority>\r\n  </Settings>\r\n  <Actions Context=\"Author\">\r\n    <Exec>\r\n      <Command>\"D:\\HotProject\\DiskInfo\\Feena\\DiskInfo.exe\"</Command>\r\n      <Arguments>/Startup</Arguments>\r\n    </Exec>\r\n  </Actions>\r\n</Task>"
        }
      ]
    }
  ]
}