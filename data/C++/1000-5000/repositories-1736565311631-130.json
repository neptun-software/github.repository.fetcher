{
  "metadata": {
    "timestamp": 1736565311631,
    "page": 130,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Chlumsky/msdfgen",
      "stars": 4060,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.01171875,
          "content": "* text=auto\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3388671875,
          "content": "/build/\n/Debug/\n/Release/\n/Release OpenMP/\n/Debug Library/\n/Release Library/\n/Release Library OpenMP/\n/x86/\n/x64/\n.vs/\n.vscode/\n.DS_Store\n*.exe\n*.zip\n*.user\n*.sdf\n*.pdb\n*.ipdb\n*.iobj\n*.suo\n*.VC.opendb\n*.VC.db\n/bin/*.lib\n/bin/msdfgen\noutput.png\nrender.png\nCMakeUserPresets.json\nout/\n/all-in-one/\n/build_xcode/\n/cmake-gen.bat\n/line-ending-check.bat\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 7.755859375,
          "content": "\n## Version 1.12 (2024-05-18)\n\n- Added the possibility to specify asymmetrical distance range (`-arange`, `-apxrange`)\n- Added the ability to export the shape into an SVG file (`-exportsvg`)\n- Edge coloring no longer colors smooth contours white, which has been found suboptimal\n- Fixed incorrect scaling of font glyph coordinates. To preserve backwards compatibility, the user has to enable the fix with an explicit additional argument:\n    - `-emnormalize` in standalone, `FONT_SCALING_EM_NORMALIZED` in API for coordinates in ems\n    - `-noemnormalize` in standalone, `FONT_SCALING_NONE` in API for raw integer coordinates\n    - The default (backwards-compatible) behavior will change in a future version; a warning will be displayed if neither option is set\n- Added two new developer-friendly export image formats: RGBA and FL32\n- `-size` parameter renamed to `-dimensions` for clarity (old one will be kept for compatibility)\n- `generate*SDF` functions now combine projection and range into a single argument (`SDFTransformation`)\n- Conversion of floating point color values to 8-bit integers adjusted to match graphics hardware\n- Improved edge deconvergence procedure and made sure that calling `Shape::normalize` a second time has no effect\n- Fixed certain edge cases where Skia geometry preprocessing wouldn't make the geometry fully compliant\n- The term \"perpendicular distance\" now used instead of \"pseudo-distance\" (PSDF instead of PseudoSDF in API)\n- Fixed a bug in `savePng` where `fclose` could be called on null pointer\n- Minor code improvements\n\n## Version 1.11 (2023-11-11)\n\n- Reworked SVG parser, which now supports multiple paths and other shapes - requires Skia\n- Major performance improvements due to inlining certain low-level classes\n- A limited version of the standalone executable can now be built without any dependencies\n- Fixed `listFontVariationAxes` which previously reported incorrectly scaled values\n- Fixed potential crash when generating SDF from an empty `Shape`\n- Fixed a small bug in the error correction routine\n- Errors now reported to `stderr` rather than `stdout`\n- All command line arguments can now also be passed with two dashes instead of one\n- Added `-version` argument to print the program's version\n- `Shape` can now be loaded from a pointer to FreeType's `FT_Outline`\n- Added hidden CMake options to selectively disable PNG, SVG, or variable font support\n- Added CMake presets\n- Other minor bug fixes\n\n## Version 1.10 (2023-01-15)\n\n- Switched to vcpkg as the primary dependency management system\n- Switched to libpng as the primary PNG file encoder\n- Parameters of variable fonts can be specified\n- Fixed a bug that prevented glyph 0 to be specified in a glyphset\n\n### Version 1.9.2 (2021-12-01)\n\n- Improved detection of numerical errors in cubic equation solver\n- Added -windingpreprocess option\n- Fixed edge coloring not restored if lost during preprocessing\n\n### Version 1.9.1 (2021-07-09)\n\n- Fixed an edge case bug in the new MSDF error correction algorithm\n\n## Version 1.9 (2021-05-28)\n\n- Error correction of multi-channel distance fields has been completely reworked\n- Added new edge coloring strategy that optimizes colors based on distances between edges\n- Added some minor functions for the library API\n- Minor code refactor and optimizations\n\n## Version 1.8 (2020-10-17)\n\n- Integrated the Skia library into the project, which is used to preprocess the shape geometry and eliminate any self-intersections and other irregularities previously unsupported by the software\n    - The scanline pass and overlapping contour mode is made obsolete by this step and has been disabled by default. The preprocess step can be disabled by the new `-nopreprocess` switch and the former enabled by `-scanline` and `-overlap` respectively.\n    - The project can be built without the Skia library, forgoing the geometry preprocessing feature. This is controlled by the macro definition `MSDFGEN_USE_SKIA`\n- Significantly improved performance of the core algorithm by reusing results from previously computed pixels\n- Introduced an additional error correction routine which eliminates MSDF artifacts by analytically predicting results of bilinear interpolation\n- Added the possibility to load font glyphs by their index rather than a Unicode value (use the prefix `g` before the character code in `-font` argument)\n- Added `-distanceshift` argument that can be used to adjust the center of the distance range in the output distance field\n- Fixed several errors in the evaluation of curve distances\n- Fixed an issue with paths containing convergent corners (those whose inner angle is zero)\n- The algorithm for pseudo-distance computation slightly changed, fixing certain rare edge cases and improving consistency\n- Added the ability to supply own `FT_Face` handle to the msdfgen library\n- Minor refactor of the core algorithm\n\n### Version 1.7.1 (2020-03-09)\n\n- Fixed an edge case bug in scanline rasterization\n\n## Version 1.7 (2020-03-07)\n\n- Added `mtsdf` mode - a combination of `msdf` with `sdf` in the alpha channel\n- Distance fields can now be stored as uncompressed TIFF image files with floating point precision\n- Bitmap class refactor - template argument split into data type and number of channels, bitmap reference classes introduced\n- Added a secondary \"ink trap\" edge coloring heuristic, can be selected using `-coloringstrategy inktrap`\n- Added computation of estimated rendering error for a given SDF\n- Added computation of bounding box that includes sharp mitered corners\n- The API for bounds computation of the `Shape` class changed for clarity\n- Fixed several edge case bugs\n\n## Version 1.6 (2019-04-08)\n\n- Core algorithm rewritten to split up advanced edge selection logic into modular template arguments.\n- Pseudo-distance evaluation reworked to eliminate discontinuities at the midpoint between edges.\n- MSDF error correction reworked to also fix distances away from edges and consider diagonal pairs. Code simplified.\n- Added scanline rasterization support for `Shape`.\n- Added a scanline pass in the standalone version, which corrects the signs in the distance field according to the selected fill rule (`-fillrule`). Can be disabled using `-noscanline`.\n- Fixed autoframe scaling, which previously caused the output to have unnecessary empty border.\n- `-guessorder` switch no longer enabled by default, as the functionality is now provided by the scanline pass.\n- Updated FreeType and other libraries, changed to static linkage\n- Added 64-bit and static library builds to the Visual Studio solution\n\n## Version 1.5 (2017-07-23)\n\n- Fixed rounding error in cubic curve splitting.\n- SVG parser fixes and support for additional path commands.\n- Added CMake build script.\n\n## Version 1.4 (2017-02-09)\n\n- Reworked contour combining logic to support overlapping contours. Original algorithm preserved in functions with `_legacy` suffix, which are invoked by the new `-legacy` switch.\n- Fixed a severe bug in cubic curve distance computation, where a control point lies at the endpoint.\n- Standalone version now automatically detects if the input has the wrong orientation and adjusts the distance field accordingly. Can be disabled by `-keeporder` or `-reverseorder` switch.\n- SVG parser fixes and improvements.\n\n## Version 1.3 (2016-12-07)\n\n- Fixed `-reverseorder` switch.\n- Fixed glyph loading to use the proper method of acquiring outlines from FreeType.\n\n## Version 1.2 (2016-07-20)\n\n- Added option to specify that shape vertices are listed in reverse order (`-reverseorder`).\n- Added option to set a seed for the edge coloring heuristic (-seed \\<n\\>), which can be used to adjust the output.\n- Fixed parsing of glyph contours that start with a curve control point.\n\n## Version 1.1 (2016-05-08)\n\n- Switched to MIT license due to popular demand.\n- Fixed SDF rendering anti-aliasing when the output is smaller than the distance field.\n\n## Version 1.0 (2016-04-28)\n\n- Project published.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 14.2626953125,
          "content": "\ncmake_minimum_required(VERSION 3.15)\ninclude(cmake/version.cmake)\n\noption(MSDFGEN_CORE_ONLY \"Only build the core library with no dependencies\" OFF)\noption(MSDFGEN_BUILD_STANDALONE \"Build the msdfgen standalone executable\" ON)\noption(MSDFGEN_USE_VCPKG \"Use vcpkg package manager to link project dependencies\" ON)\noption(MSDFGEN_USE_OPENMP \"Build with OpenMP support for multithreaded code\" OFF)\noption(MSDFGEN_USE_CPP11 \"Build with C++11 enabled\" ON)\noption(MSDFGEN_USE_SKIA \"Build with the Skia library\" ON)\noption(MSDFGEN_INSTALL \"Generate installation target\" OFF)\noption(MSDFGEN_DYNAMIC_RUNTIME \"Link dynamic runtime library instead of static\" OFF)\noption(BUILD_SHARED_LIBS \"Generate dynamic library files instead of static\" OFF)\n\nif(MSDFGEN_CORE_ONLY AND MSDFGEN_USE_VCPKG)\n    message(STATUS \"Option MSDFGEN_USE_VCPKG ignored due to MSDFGEN_CORE_ONLY - core has no dependencies\")\n    set(MSDFGEN_USE_VCPKG OFF)\nendif()\n\nget_property(MULTI_CONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)\nif(NOT MULTI_CONFIG AND NOT CMAKE_BUILD_TYPE)\n    message(STATUS \"CMAKE_BUILD_TYPE not set, defaulting to Release\")\n    set(CMAKE_BUILD_TYPE Release)\nendif()\n\nif(MSDFGEN_USE_VCPKG)\n    # Make sure that vcpkg toolchain file is set\n    if(NOT CMAKE_TOOLCHAIN_FILE)\n        if(DEFINED ENV{VCPKG_ROOT})\n            set(CMAKE_TOOLCHAIN_FILE \"$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake\")\n        else()\n            message(SEND_ERROR \"Vcpkg toolchain not configured. Either set VCPKG_ROOT environment variable or pass -DCMAKE_TOOLCHAIN_FILE=VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake to cmake\")\n        endif()\n    endif()\n    # Default to statically linked vcpkg triplet on Windows\n    if(WIN32 AND NOT VCPKG_TARGET_TRIPLET AND NOT MSDFGEN_DYNAMIC_RUNTIME)\n        if(CMAKE_GENERATOR_PLATFORM MATCHES \"64$\" AND NOT CMAKE_GENERATOR_PLATFORM STREQUAL \"ARM64\")\n            set(VCPKG_TARGET_TRIPLET \"x64-windows-static\")\n        elseif(CMAKE_GENERATOR_PLATFORM MATCHES \"32$\" OR CMAKE_GENERATOR_PLATFORM STREQUAL \"x86\")\n            set(VCPKG_TARGET_TRIPLET \"x86-windows-static\")\n        else()\n            if(CMAKE_GENERATOR_PLATFORM)\n                message(WARNING \"Vcpkg triplet not explicitly specified and could not be deduced. Recommend using -DVCPKG_TARGET_TRIPLET=x64-windows-static or similar\")\n            else()\n                message(WARNING \"Vcpkg triplet not explicitly specified and could not be deduced. Recommend using -A to explicitly select platform (Win32 or x64)\")\n            endif()\n        endif()\n    endif()\n    # Select project features\n    if(NOT MSDFGEN_VCPKG_FEATURES_SET)\n        set(VCPKG_MANIFEST_NO_DEFAULT_FEATURES ON)\n        if(NOT MSDFGEN_CORE_ONLY)\n            list(APPEND VCPKG_MANIFEST_FEATURES \"extensions\")\n        endif()\n        if(MSDFGEN_BUILD_STANDALONE)\n            list(APPEND VCPKG_MANIFEST_FEATURES \"standalone\")\n        endif()\n        if(MSDFGEN_USE_SKIA)\n            list(APPEND VCPKG_MANIFEST_FEATURES \"geometry-preprocessing\")\n        endif()\n        if(MSDFGEN_USE_OPENMP)\n            list(APPEND VCPKG_MANIFEST_FEATURES \"openmp\")\n        endif()\n    endif()\nendif()\n\n# Version is specified in vcpkg.json\nproject(msdfgen VERSION ${MSDFGEN_VERSION} LANGUAGES CXX)\n\nif(MSDFGEN_DYNAMIC_RUNTIME)\n    set(MSDFGEN_MSVC_RUNTIME \"MultiThreaded$<$<CONFIG:Debug>:Debug>DLL\")\nelse()\n    set(MSDFGEN_MSVC_RUNTIME \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\nendif()\n\nif(BUILD_SHARED_LIBS)\n    set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)\nendif()\n\nif(MAX_WARNING_LEVEL)\n    if (MSVC)\n        add_compile_options(/W4)\n    else()\n        add_compile_options(-Wall -Wextra -Wpedantic)\n    endif()\nendif()\n\nfile(GLOB_RECURSE MSDFGEN_CORE_HEADERS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} \"core/*.h\" \"core/*.hpp\")\nfile(GLOB_RECURSE MSDFGEN_CORE_SOURCES RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} \"core/*.cpp\")\nfile(GLOB_RECURSE MSDFGEN_EXT_HEADERS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} \"ext/*.h\" \"ext/*.hpp\")\nfile(GLOB_RECURSE MSDFGEN_EXT_SOURCES RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} \"ext/*.cpp\" \"lib/*.cpp\")\n\n# Core library\nadd_library(msdfgen-core \"${CMAKE_CURRENT_SOURCE_DIR}/msdfgen.h\" ${MSDFGEN_CORE_HEADERS} ${MSDFGEN_CORE_SOURCES})\nadd_library(msdfgen::msdfgen-core ALIAS msdfgen-core)\nset_target_properties(msdfgen-core PROPERTIES PUBLIC_HEADER \"${MSDFGEN_CORE_HEADERS}\")\nset_property(TARGET msdfgen-core PROPERTY MSVC_RUNTIME_LIBRARY \"${MSDFGEN_MSVC_RUNTIME}\")\ntarget_compile_definitions(msdfgen-core PUBLIC\n    MSDFGEN_VERSION=${MSDFGEN_VERSION}\n    MSDFGEN_VERSION_MAJOR=${MSDFGEN_VERSION_MAJOR}\n    MSDFGEN_VERSION_MINOR=${MSDFGEN_VERSION_MINOR}\n    MSDFGEN_VERSION_REVISION=${MSDFGEN_VERSION_REVISION}\n    MSDFGEN_COPYRIGHT_YEAR=${MSDFGEN_COPYRIGHT_YEAR}\n)\ntarget_include_directories(msdfgen-core INTERFACE\n    $<INSTALL_INTERFACE:include/msdfgen>\n    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/>\n)\nset_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT msdfgen-core)\n\nif(MSDFGEN_USE_CPP11)\n    target_compile_features(msdfgen-core PUBLIC cxx_std_11)\n    target_compile_definitions(msdfgen-core PUBLIC MSDFGEN_USE_CPP11)\nendif()\n\nif(MSDFGEN_USE_OPENMP)\n    # Note: Clang doesn't support OpenMP by default...\n    find_package(OpenMP REQUIRED COMPONENTS CXX)\n    target_compile_definitions(msdfgen-core PUBLIC MSDFGEN_USE_OPENMP)\n    target_link_libraries(msdfgen-core PUBLIC OpenMP::OpenMP_CXX)\nendif()\n\nif(BUILD_SHARED_LIBS AND WIN32)\n    target_compile_definitions(msdfgen-core PRIVATE \"MSDFGEN_PUBLIC=__declspec(dllexport)\")\n    target_compile_definitions(msdfgen-core INTERFACE \"MSDFGEN_PUBLIC=__declspec(dllimport)\")\nelse()\n    target_compile_definitions(msdfgen-core PUBLIC MSDFGEN_PUBLIC=)\nendif()\n\n# Extensions library\nif(NOT MSDFGEN_CORE_ONLY)\n    if(NOT TARGET Freetype::Freetype)\n        find_package(Freetype REQUIRED)\n    endif()\n    if(NOT MSDFGEN_DISABLE_SVG AND NOT TARGET tinyxml2::tinyxml2)\n        find_package(tinyxml2 REQUIRED)\n    endif()\n    if(NOT MSDFGEN_DISABLE_PNG AND NOT TARGET PNG::PNG)\n        find_package(PNG REQUIRED)\n    endif()\n\n    add_library(msdfgen-ext \"${CMAKE_CURRENT_SOURCE_DIR}/msdfgen-ext.h\" ${MSDFGEN_EXT_HEADERS} ${MSDFGEN_EXT_SOURCES})\n    add_library(msdfgen::msdfgen-ext ALIAS msdfgen-ext)\n    set_target_properties(msdfgen-ext PROPERTIES PUBLIC_HEADER \"${MSDFGEN_EXT_HEADERS}\")\n    set_property(TARGET msdfgen-ext PROPERTY MSVC_RUNTIME_LIBRARY \"${MSDFGEN_MSVC_RUNTIME}\")\n    target_compile_definitions(msdfgen-ext INTERFACE MSDFGEN_EXTENSIONS)\n    if(NOT MSDFGEN_DISABLE_SVG)\n        target_compile_definitions(msdfgen-ext PUBLIC MSDFGEN_USE_TINYXML2)\n        target_link_libraries(msdfgen-ext PRIVATE tinyxml2::tinyxml2)\n    else()\n        target_compile_definitions(msdfgen-ext PUBLIC MSDFGEN_DISABLE_SVG)\n    endif()\n    if(NOT MSDFGEN_DISABLE_PNG)\n        target_compile_definitions(msdfgen-ext PUBLIC MSDFGEN_USE_LIBPNG)\n        target_link_libraries(msdfgen-ext PRIVATE PNG::PNG)\n    else()\n        target_compile_definitions(msdfgen-ext PUBLIC MSDFGEN_DISABLE_PNG)\n    endif()\n    if(MSDFGEN_DISABLE_VARIABLE_FONTS)\n        target_compile_definitions(msdfgen-ext PUBLIC MSDFGEN_DISABLE_VARIABLE_FONTS)\n    endif()\n    target_link_libraries(msdfgen-ext PRIVATE Freetype::Freetype msdfgen::msdfgen-core)\n    target_include_directories(msdfgen-ext\n        PUBLIC\n            $<INSTALL_INTERFACE:include/msdfgen>\n            $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n        PRIVATE\n            ${CMAKE_CURRENT_SOURCE_DIR}/include\n    )\n    set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT msdfgen-ext)\n\n    if(MSDFGEN_USE_SKIA)\n        set(MSDFGEN_SKIA_LIB skia)\n        set(CMAKE_THREAD_PREFER_PTHREAD TRUE)\n        set(THREADS_PREFER_PTHREAD_FLAG TRUE)\n        find_package(Threads REQUIRED)\n        if(NOT TARGET skia)\n            if(MSDFGEN_USE_VCPKG)\n                find_package(unofficial-skia REQUIRED)\n                set(MSDFGEN_SKIA_LIB unofficial::skia::skia)\n            else()\n                find_package(skia REQUIRED)\n            endif()\n        endif()\n        target_compile_features(msdfgen-ext PUBLIC cxx_std_17)\n        target_compile_definitions(msdfgen-ext PUBLIC MSDFGEN_USE_SKIA)\n        target_link_libraries(msdfgen-ext PRIVATE Threads::Threads ${MSDFGEN_SKIA_LIB})\n    endif()\n\n    if(BUILD_SHARED_LIBS AND WIN32)\n        target_compile_definitions(msdfgen-ext PRIVATE \"MSDFGEN_EXT_PUBLIC=__declspec(dllexport)\")\n        target_compile_definitions(msdfgen-ext INTERFACE \"MSDFGEN_EXT_PUBLIC=__declspec(dllimport)\")\n    else()\n        target_compile_definitions(msdfgen-ext PUBLIC MSDFGEN_EXT_PUBLIC=)\n    endif()\n\n    add_library(msdfgen-full INTERFACE)\n    add_library(msdfgen::msdfgen ALIAS msdfgen-full)\n    target_link_libraries(msdfgen-full INTERFACE msdfgen::msdfgen-core msdfgen::msdfgen-ext)\nelse()\n    add_library(msdfgen::msdfgen ALIAS msdfgen-core)\nendif()\n\n# Standalone executable\nif(MSDFGEN_BUILD_STANDALONE)\n    set(MSDFGEN_STANDALONE_SOURCES \"${CMAKE_CURRENT_SOURCE_DIR}/main.cpp\")\n    if(MSVC)\n        set(MSDFGEN_STANDALONE_SOURCES ${MSDFGEN_STANDALONE_SOURCES} \"${CMAKE_CURRENT_SOURCE_DIR}/msdfgen.rc\")\n    endif()\n    add_executable(msdfgen ${MSDFGEN_STANDALONE_SOURCES})\n    target_compile_definitions(msdfgen PUBLIC MSDFGEN_STANDALONE)\n    target_compile_definitions(msdfgen PRIVATE MSDFGEN_VERSION_UNDERLINE=${MSDFGEN_VERSION_UNDERLINE})\n    set_property(TARGET msdfgen PROPERTY MSVC_RUNTIME_LIBRARY \"${MSDFGEN_MSVC_RUNTIME}\")\n    target_link_libraries(msdfgen PRIVATE msdfgen::msdfgen)\n    set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT msdfgen)\nendif()\n\n# Hide ZERO_CHECK and ALL_BUILD targets\nset_property(GLOBAL PROPERTY USE_FOLDERS ON)\nset_property(GLOBAL PROPERTY PREDEFINED_TARGETS_FOLDER meta)\n\n# Installation\nif(MSDFGEN_INSTALL)\n    include(GNUInstallDirs)\n    include(CMakePackageConfigHelpers)\n    set(MSDFGEN_CONFIG_PATH \"lib/cmake/msdfgen\")\n\n    # Generate msdfgen-config.h\n    if(BUILD_SHARED_LIBS AND WIN32)\n        set(MSDFGEN_PUBLIC_MACRO_VALUE \" __declspec(dllimport)\")\n    else()\n        set(MSDFGEN_PUBLIC_MACRO_VALUE \"\")\n    endif()\n    set(MSDFGEN_ADDITIONAL_DEFINES \"\")\n    if(MSDFGEN_USE_CPP11)\n        set(MSDFGEN_ADDITIONAL_DEFINES \"${MSDFGEN_ADDITIONAL_DEFINES}\\n#define MSDFGEN_USE_CPP11\")\n    endif()\n    if(MSDFGEN_USE_OPENMP)\n        set(MSDFGEN_ADDITIONAL_DEFINES \"${MSDFGEN_ADDITIONAL_DEFINES}\\n#define MSDFGEN_USE_OPENMP\")\n    endif()\n    if(NOT MSDFGEN_CORE_ONLY)\n        set(MSDFGEN_ADDITIONAL_DEFINES \"${MSDFGEN_ADDITIONAL_DEFINES}\\n#define MSDFGEN_EXTENSIONS\")\n        if(MSDFGEN_USE_SKIA)\n            set(MSDFGEN_ADDITIONAL_DEFINES \"${MSDFGEN_ADDITIONAL_DEFINES}\\n#define MSDFGEN_USE_SKIA\")\n        endif()\n        if(NOT MSDFGEN_DISABLE_SVG)\n            set(MSDFGEN_ADDITIONAL_DEFINES \"${MSDFGEN_ADDITIONAL_DEFINES}\\n#define MSDFGEN_USE_TINYXML2\")\n        else()\n            set(MSDFGEN_ADDITIONAL_DEFINES \"${MSDFGEN_ADDITIONAL_DEFINES}\\n#define MSDFGEN_DISABLE_SVG\")\n        endif()\n        if(NOT MSDFGEN_DISABLE_PNG)\n            set(MSDFGEN_ADDITIONAL_DEFINES \"${MSDFGEN_ADDITIONAL_DEFINES}\\n#define MSDFGEN_USE_LIBPNG\")\n        else()\n            set(MSDFGEN_ADDITIONAL_DEFINES \"${MSDFGEN_ADDITIONAL_DEFINES}\\n#define MSDFGEN_DISABLE_PNG\")\n        endif()\n        if(MSDFGEN_DISABLE_VARIABLE_FONTS)\n            set(MSDFGEN_ADDITIONAL_DEFINES \"${MSDFGEN_ADDITIONAL_DEFINES}\\n#define MSDFGEN_DISABLE_VARIABLE_FONTS\")\n        endif()\n    endif()\n    configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/cmake/msdfgen-config.h.in\" msdfgen-config.h)\n\n    write_basic_package_version_file(\n        \"${CMAKE_CURRENT_BINARY_DIR}/msdfgenConfigVersion.cmake\"\n        VERSION ${PROJECT_VERSION}\n        COMPATIBILITY SameMajorVersion\n    )\n\n    configure_package_config_file(\n        \"${CMAKE_CURRENT_SOURCE_DIR}/cmake/msdfgenConfig.cmake.in\"\n        ${MSDFGEN_CONFIG_PATH}/msdfgenConfig.cmake\n        INSTALL_DESTINATION ${MSDFGEN_CONFIG_PATH}\n        NO_CHECK_REQUIRED_COMPONENTS_MACRO\n    )\n\n    configure_file(\n        \"${CMAKE_CURRENT_SOURCE_DIR}/cmake/msdfgenConfig.cmake.in\"\n        msdfgenConfig.cmake\n        @ONLY\n    )\n\n    install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/msdfgen-config.h\" DESTINATION include/msdfgen)\n    install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/msdfgen-config.h\" DESTINATION include/msdfgen/msdfgen)\n    install(TARGETS msdfgen-core EXPORT msdfgenTargets\n        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        FRAMEWORK DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/msdfgen/core\n    )\n    install(FILES \"${CMAKE_CURRENT_SOURCE_DIR}/msdfgen.h\" DESTINATION include/msdfgen)\n    if(MSVC AND BUILD_SHARED_LIBS)\n        install(FILES $<TARGET_PDB_FILE:msdfgen-core> DESTINATION ${CMAKE_INSTALL_BINDIR} OPTIONAL)\n    endif()\n\n    if(NOT MSDFGEN_CORE_ONLY)\n        install(TARGETS msdfgen-ext EXPORT msdfgenTargets\n            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            FRAMEWORK DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/msdfgen/ext\n        )\n        install(FILES \"${CMAKE_CURRENT_SOURCE_DIR}/msdfgen-ext.h\" DESTINATION include/msdfgen)\n        if(MSVC AND BUILD_SHARED_LIBS)\n            install(FILES $<TARGET_PDB_FILE:msdfgen-ext> DESTINATION ${CMAKE_INSTALL_BINDIR} OPTIONAL)\n        endif()\n        install(TARGETS msdfgen-full EXPORT msdfgenTargets)\n    endif()\n\n    export(EXPORT msdfgenTargets NAMESPACE msdfgen:: FILE \"${CMAKE_CURRENT_BINARY_DIR}/msdfgenTargets.cmake\")\n    install(EXPORT msdfgenTargets FILE msdfgenTargets.cmake NAMESPACE msdfgen:: DESTINATION ${MSDFGEN_CONFIG_PATH})\n\n    if(MSDFGEN_BUILD_STANDALONE)\n        install(TARGETS msdfgen EXPORT msdfgenBinaryTargets DESTINATION ${CMAKE_INSTALL_BINDIR})\n        if(MSVC)\n            install(FILES $<TARGET_PDB_FILE:msdfgen> DESTINATION ${CMAKE_INSTALL_BINDIR} OPTIONAL)\n        endif()\n        export(EXPORT msdfgenBinaryTargets NAMESPACE msdfgen-standalone:: FILE \"${CMAKE_CURRENT_BINARY_DIR}/msdfgenBinaryTargets.cmake\")\n        install(EXPORT msdfgenBinaryTargets FILE msdfgenBinaryTargets.cmake NAMESPACE msdfgen-standalone:: DESTINATION ${MSDFGEN_CONFIG_PATH})\n    endif()\n\n    install(\n        FILES\n            \"${CMAKE_CURRENT_BINARY_DIR}/${MSDFGEN_CONFIG_PATH}/msdfgenConfig.cmake\"\n            \"${CMAKE_CURRENT_BINARY_DIR}/msdfgenConfigVersion.cmake\"\n        DESTINATION ${MSDFGEN_CONFIG_PATH}\n    )\nendif()\n"
        },
        {
          "name": "CMakePresets.json",
          "type": "blob",
          "size": 8.92578125,
          "content": "{\n    \"version\": 4,\n    \"cmakeMinimumRequired\": {\n        \"major\": 3,\n        \"minor\": 23,\n        \"patch\": 0\n    },\n    \"include\": [\n        \"cmake/CMakePresets.json\"\n    ],\n    \"configurePresets\": [\n        {\n            \"name\": \"win64\",\n            \"displayName\": \"Windows x64 default config (static, vcpkg, Skia)\",\n            \"inherits\": [ \"win64-base\", \"vcpkg\", \"skia\" ]\n        }, {\n            \"name\": \"win32\",\n            \"displayName\": \"Windows x86 default config (static, vcpkg, Skia)\",\n            \"inherits\": [ \"win32-base\", \"vcpkg\", \"skia\" ]\n        }, {\n            \"name\": \"win64-omp\",\n            \"displayName\": \"Windows x64 config with OpenMP (static, vcpkg, Skia)\",\n            \"inherits\": [ \"win64-base\", \"openmp\", \"vcpkg\", \"skia\" ],\n            \"binaryDir\": \"${sourceDir}/build/win64-omp\"\n        }, {\n            \"name\": \"win32-omp\",\n            \"displayName\": \"Windows x86 config with OpenMP (static, vcpkg, Skia)\",\n            \"inherits\": [ \"win32-base\", \"openmp\", \"vcpkg\", \"skia\" ],\n            \"binaryDir\": \"${sourceDir}/build/win32-omp\"\n        }, {\n            \"name\": \"win64-dynamic\",\n            \"displayName\": \"Windows x64 dynamic config (vcpkg, Skia)\",\n            \"inherits\": [ \"win64-base\", \"vcpkg\", \"skia\", \"dynamic-runtime\", \"dynamic-lib\" ],\n            \"binaryDir\": \"${sourceDir}/build/win64-dynamic\"\n        }, {\n            \"name\": \"win32-dynamic\",\n            \"displayName\": \"Windows x86 dynamic config (vcpkg, Skia)\",\n            \"inherits\": [ \"win32-base\", \"vcpkg\", \"skia\", \"dynamic-runtime\", \"dynamic-lib\" ],\n            \"binaryDir\": \"${sourceDir}/build/win32-dynamic\"\n        }, {\n            \"name\": \"win64-no-skia\",\n            \"displayName\": \"Windows x64 config without Skia (static, vcpkg)\",\n            \"inherits\": [ \"win64-base\", \"vcpkg\", \"no-skia\" ]\n        }, {\n            \"name\": \"win32-no-skia\",\n            \"displayName\": \"Windows x86 config without Skia (static, vcpkg)\",\n            \"inherits\": [ \"win32-base\", \"vcpkg\", \"no-skia\" ]\n        }, {\n            \"name\": \"win64-core\",\n            \"displayName\": \"Windows x64 core-only config (static)\",\n            \"inherits\": [ \"win64-base\", \"core-only\" ],\n            \"binaryDir\": \"${sourceDir}/build/win64-core\"\n        }, {\n            \"name\": \"win32-core\",\n            \"displayName\": \"Windows x86 core-only config (static)\",\n            \"inherits\": [ \"win32-base\", \"core-only\" ],\n            \"binaryDir\": \"${sourceDir}/build/win32-core\"\n        },\n\n        {\n            \"name\": \"osx-vcpkg-rel\",\n            \"displayName\": \"Mac OS release config with vcpkg and Skia (static)\",\n            \"inherits\": [ \"osx-rel-base\", \"vcpkg\", \"skia\" ]\n        }, {\n            \"name\": \"osx-vcpkg-dbg\",\n            \"displayName\": \"Mac OS debug config with vcpkg and Skia (static)\",\n            \"inherits\": [ \"osx-dbg-base\", \"vcpkg\", \"skia\" ]\n        }, {\n            \"name\": \"osx-no-skia-rel\",\n            \"displayName\": \"Mac OS release config with system libraries and no Skia (static, install)\",\n            \"inherits\": [ \"osx-rel-base\", \"no-vcpkg\", \"no-skia\", \"install\" ]\n        }, {\n            \"name\": \"osx-no-skia-dbg\",\n            \"displayName\": \"Mac OS debug config with system libraries and no Skia (static, install)\",\n            \"inherits\": [ \"osx-dbg-base\", \"no-vcpkg\", \"no-skia\", \"install\" ]\n        }, {\n            \"name\": \"osx-core-rel\",\n            \"displayName\": \"Mac OS release core-only config (static, install)\",\n            \"inherits\": [ \"osx-rel-base\", \"core-only\", \"install\" ],\n            \"binaryDir\": \"${sourceDir}/build/osx-core-rel\"\n        }, {\n            \"name\": \"osx-core-dbg\",\n            \"displayName\": \"Mac OS debug core-only config (static, install)\",\n            \"inherits\": [ \"osx-dbg-base\", \"core-only\", \"install\" ],\n            \"binaryDir\": \"${sourceDir}/build/osx-core-dbg\"\n        },\n\n        {\n            \"name\": \"linux-vcpkg-rel\",\n            \"displayName\": \"Linux release config with vcpkg and Skia (static)\",\n            \"inherits\": [ \"linux-rel-base\", \"vcpkg\", \"skia\" ]\n        }, {\n            \"name\": \"linux-vcpkg-dbg\",\n            \"displayName\": \"Linux debug config with vcpkg and Skia (static)\",\n            \"inherits\": [ \"linux-dbg-base\", \"vcpkg\", \"skia\" ]\n        }, {\n            \"name\": \"linux-no-skia-rel\",\n            \"displayName\": \"Linux release config with system libraries and no Skia (static, install)\",\n            \"inherits\": [ \"linux-rel-base\", \"no-vcpkg\", \"no-skia\", \"install\" ]\n        }, {\n            \"name\": \"linux-no-skia-dbg\",\n            \"displayName\": \"Linux debug config with system libraries and no Skia (static, install)\",\n            \"inherits\": [ \"linux-dbg-base\", \"no-vcpkg\", \"no-skia\", \"install\" ]\n        }, {\n            \"name\": \"linux-core-rel\",\n            \"displayName\": \"Linux release core-only config (static, install)\",\n            \"inherits\": [ \"linux-rel-base\", \"core-only\", \"install\" ],\n            \"binaryDir\": \"${sourceDir}/build/linux-core-rel\"\n        }, {\n            \"name\": \"linux-core-dbg\",\n            \"displayName\": \"Linux debug core-only config (static, install)\",\n            \"inherits\": [ \"linux-dbg-base\", \"core-only\", \"install\" ],\n            \"binaryDir\": \"${sourceDir}/build/linux-core-dbg\"\n        }\n    ],\n    \"buildPresets\": [\n        {\n            \"name\": \"win64-rel\",\n            \"configurePreset\": \"win64\",\n            \"configuration\": \"Release\"\n        }, {\n            \"name\": \"win64-dbg\",\n            \"configurePreset\": \"win64\",\n            \"configuration\": \"Debug\"\n        }, {\n            \"name\": \"win32-rel\",\n            \"configurePreset\": \"win32\",\n            \"configuration\": \"Release\"\n        }, {\n            \"name\": \"win32-dbg\",\n            \"configurePreset\": \"win32\",\n            \"configuration\": \"Debug\"\n        }, {\n            \"name\": \"win64-omp-rel\",\n            \"configurePreset\": \"win64-omp\",\n            \"configuration\": \"Release\"\n        }, {\n            \"name\": \"win64-omp-dbg\",\n            \"configurePreset\": \"win64-omp\",\n            \"configuration\": \"Debug\"\n        }, {\n            \"name\": \"win32-omp-rel\",\n            \"configurePreset\": \"win32-omp\",\n            \"configuration\": \"Release\"\n        }, {\n            \"name\": \"win32-omp-dbg\",\n            \"configurePreset\": \"win32-omp\",\n            \"configuration\": \"Debug\"\n        }, {\n            \"name\": \"win64-dynamic-rel\",\n            \"configurePreset\": \"win64-dynamic\",\n            \"configuration\": \"Release\"\n        }, {\n            \"name\": \"win64-dynamic-dbg\",\n            \"configurePreset\": \"win64-dynamic\",\n            \"configuration\": \"Debug\"\n        }, {\n            \"name\": \"win32-dynamic-rel\",\n            \"configurePreset\": \"win32-dynamic\",\n            \"configuration\": \"Release\"\n        }, {\n            \"name\": \"win32-dynamic-dbg\",\n            \"configurePreset\": \"win32-dynamic\",\n            \"configuration\": \"Debug\"\n        }, {\n            \"name\": \"win64-no-skia-rel\",\n            \"configurePreset\": \"win64-no-skia\",\n            \"configuration\": \"Release\"\n        }, {\n            \"name\": \"win64-no-skia-dbg\",\n            \"configurePreset\": \"win64-no-skia\",\n            \"configuration\": \"Debug\"\n        }, {\n            \"name\": \"win32-no-skia-rel\",\n            \"configurePreset\": \"win32-no-skia\",\n            \"configuration\": \"Release\"\n        }, {\n            \"name\": \"win32-no-skia-dbg\",\n            \"configurePreset\": \"win32-no-skia\",\n            \"configuration\": \"Debug\"\n        }, {\n            \"name\": \"win64-core-rel\",\n            \"configurePreset\": \"win64-core\",\n            \"configuration\": \"Release\"\n        }, {\n            \"name\": \"win64-core-dbg\",\n            \"configurePreset\": \"win64-core\",\n            \"configuration\": \"Debug\"\n        }, {\n            \"name\": \"win32-core-rel\",\n            \"configurePreset\": \"win32-core\",\n            \"configuration\": \"Release\"\n        }, {\n            \"name\": \"win32-core-dbg\",\n            \"configurePreset\": \"win32-core\",\n            \"configuration\": \"Debug\"\n        },\n\n        {\n            \"name\": \"osx-vcpkg-rel\",\n            \"configurePreset\": \"osx-vcpkg-rel\"\n        }, {\n            \"name\": \"osx-vcpkg-dbg\",\n            \"configurePreset\": \"osx-vcpkg-dbg\"\n        }, {\n            \"name\": \"osx-no-skia-rel\",\n            \"configurePreset\": \"osx-no-skia-rel\"\n        }, {\n            \"name\": \"osx-no-skia-dbg\",\n            \"configurePreset\": \"osx-no-skia-dbg\"\n        }, {\n            \"name\": \"osx-core-rel\",\n            \"configurePreset\": \"osx-core-rel\"\n        }, {\n            \"name\": \"osx-core-dbg\",\n            \"configurePreset\": \"osx-core-dbg\"\n        },\n\n        {\n            \"name\": \"linux-vcpkg-rel\",\n            \"configurePreset\": \"linux-vcpkg-rel\"\n        }, {\n            \"name\": \"linux-vcpkg-dbg\",\n            \"configurePreset\": \"linux-vcpkg-dbg\"\n        }, {\n            \"name\": \"linux-no-skia-rel\",\n            \"configurePreset\": \"linux-no-skia-rel\"\n        }, {\n            \"name\": \"linux-no-skia-dbg\",\n            \"configurePreset\": \"linux-no-skia-dbg\"\n        }, {\n            \"name\": \"linux-core-rel\",\n            \"configurePreset\": \"linux-core-rel\"\n        }, {\n            \"name\": \"linux-core-dbg\",\n            \"configurePreset\": \"linux-core-dbg\"\n        }\n    ]\n}\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0537109375,
          "content": "MIT License\n\nCopyright (c) 2014 - 2024 Viktor Chlumsky\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.5146484375,
          "content": "# Multi-channel signed distance field generator\n\nThis is a utility for generating signed distance fields from vector shapes and font glyphs,\nwhich serve as a texture representation that can be used in real-time graphics to efficiently reproduce said shapes.\nAlthough it can also be used to generate conventional signed distance fields best known from\n[this Valve paper](https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf)\nand perpendicular distance fields, its primary purpose is to generate multi-channel distance fields,\nusing a method I have developed. Unlike monochrome distance fields, they have the ability\nto reproduce sharp corners almost perfectly by utilizing all three color channels.\n\nThe following comparison demonstrates the improvement in image quality.\n\n![demo-msdf16](https://user-images.githubusercontent.com/18639794/106391899-e37ebe80-63ef-11eb-988b-4764004bb196.png)\n![demo-sdf16](https://user-images.githubusercontent.com/18639794/106391905-e679af00-63ef-11eb-96c3-993176330911.png)\n![demo-sdf32](https://user-images.githubusercontent.com/18639794/106391906-e7aadc00-63ef-11eb-8f84-d402d0dd9174.png)\n\n- To learn more about this method, you can read my [Master's thesis](https://github.com/Chlumsky/msdfgen/files/3050967/thesis.pdf).\n- Check out my [MSDF-Atlas-Gen](https://github.com/Chlumsky/msdf-atlas-gen) if you want to generate entire font atlases for text rendering.\n- See what's new in the [changelog](CHANGELOG.md).\n\n## Getting started\n\nThe project can be used either as a library or as a console program. It is divided into two parts, **[core](core)**\nand **[extensions](ext)**. The core module has no dependencies and only uses bare C++. It contains all\nkey data structures and algorithms, which can be accessed through the [msdfgen.h](msdfgen.h) header.\nExtensions contain utilities for loading fonts and SVG files, as well as saving PNG images.\nThose are exposed by the [msdfgen-ext.h](msdfgen-ext.h) header. This module uses\n[FreeType](https://freetype.org/),\n[TinyXML2](https://www.grinninglizard.com/tinyxml2/),\n[libpng](http://www.libpng.org/pub/png/libpng.html),\nand (optionally) [Skia](https://skia.org/).\n\nAdditionally, there is the [main.cpp](main.cpp), which wraps the functionality into\na comprehensive standalone console program. To start using the program immediately,\nthere is a Windows binary available for download in the [\"Releases\" section](https://github.com/Chlumsky/msdfgen/releases).\nTo use the project as a library, you may install it via the [vcpkg](https://vcpkg.io) package manager as\n```\nvcpkg install msdfgen\n```\nOr, to build the project from source, you may use the included [CMake script](CMakeLists.txt).\nIn its default configuration, it requires [vcpkg](https://vcpkg.io) as the provider for third-party library dependencies.\nIf you set the environment variable `VCPKG_ROOT` to the vcpkg directory,\nthe CMake configuration will take care of fetching all required packages from vcpkg.\n\n## Console commands\n\nThe standalone program is executed as\n```\nmsdfgen.exe <mode> <input> <options>\n```\nwhere only the input specification is required.\n\nMode can be one of:\n - **sdf** &ndash; generates a conventional monochrome (true) signed distance field.\n - **psdf** &ndash; generates a monochrome signed perpendicular distance field.\n - **msdf** (default) &ndash; generates a multi-channel signed distance field using my new method.\n - **mtsdf** &ndash; generates a combined multi-channel and true signed distance field in the alpha channel.\n\nThe input can be specified as one of:\n - **-font \\<filename.ttf\\> \\<character code\\>** &ndash; to load a glyph from a font file.\n   Character code can be expressed as either a decimal (63) or hexadecimal (0x3F) Unicode value, or an ASCII character\n   in single quotes ('?').\n - **-svg \\<filename.svg\\>** &ndash; to load an SVG file. Note that only the last vector path in the file will be used.\n - **-shapedesc \\<filename.txt\\>**, -defineshape \\<definition\\>, -stdin &ndash; to load a text description of the shape\n   from either a file, the next argument, or the standard input, respectively. Its syntax is documented further down.\n\nThe complete list of available options can be printed with **-help**.\nSome of the important ones are:\n - **-o \\<filename\\>** &ndash; specifies the output file name. The desired format will be deduced from the extension\n   (png, bmp, tiff, rgba, fl32, txt, bin). Otherwise, use -format.\n - **-dimensions \\<width\\> \\<height\\>** &ndash; specifies the dimensions of the output distance field (in pixels).\n - **-range \\<range\\>**, **-pxrange \\<range\\>** &ndash; specifies the width of the range around the shape\n   between the minimum and maximum representable signed distance in shape units or distance field pixels, respectivelly.\n - **-scale \\<scale\\>** &ndash; sets the scale used to convert shape units to distance field pixels.\n - **-translate \\<x\\> \\<y\\>** &ndash; sets the translation of the shape in shape units. Otherwise the origin (0, 0)\n   lies in the bottom left corner.\n - **-autoframe** &ndash; automatically frames the shape to fit the distance field. If the output must be precisely aligned,\n   you should manually position it using -translate and -scale instead.\n - **-angle \\<angle\\>** &ndash; specifies the maximum angle to be considered a corner.\n   Can be expressed in radians (3.0) or degrees with D at the end (171.9D).\n - **-testrender \\<filename.png\\> \\<width\\> \\<height\\>** - tests the generated distance field by using it to render an image\n   of the original shape into a PNG file with the specified dimensions. Alternatively, -testrendermulti renders\n   an image without combining the color channels, and may give you an insight in how the multi-channel distance field works.\n - **-exportshape \\<filename.txt\\>** - saves the text description of the shape with edge coloring to the specified file.\n   This can be later edited and used as input through -shapedesc.\n - **-printmetrics** &ndash; prints some useful information about the shape's layout.\n\nFor example,\n```\nmsdfgen.exe msdf -font C:\\Windows\\Fonts\\arialbd.ttf 'M' -o msdf.png -dimensions 32 32 -pxrange 4 -autoframe -testrender render.png 1024 1024\n```\n\nwill take the glyph capital M from the Arial Bold typeface, generate a 32&times;32 multi-channel distance field\nwith a 4 pixels wide distance range, store it into msdf.png, and create a test render of the glyph as render.png.\n\n**Note:** Do not use `-autoframe` to generate character maps! It is intended as a quick preview only.\n\n## Library API\n\nIf you choose to use this utility inside your own program, there are a few simple steps you need to perform\nin order to generate a distance field. Please note that all classes and functions are in the `msdfgen` namespace.\n\n - Acquire a `Shape` object. You can either load it via `loadGlyph` or `loadSvgShape`, or construct it manually.\n   It consists of closed contours, which in turn consist of edges. An edge is represented by a `LinearEdge`, `QuadraticEdge`,\n   or `CubicEdge`. You can construct them from two endpoints and 0 to 2 Bézier control points.\n - Normalize the shape using its `normalize` method and assign colors to edges if you need a multi-channel SDF.\n   This can be performed automatically using the `edgeColoringSimple` (or other) heuristic, or manually by setting each edge's\n   `color` member. Keep in mind that at least two color channels must be turned on in each edge.\n - Call `generateSDF`, `generatePSDF`, `generateMSDF`, or `generateMTSDF` to generate a distance field into a floating point\n   `Bitmap` object. This can then be worked with further or saved to a file using `saveBmp`, `savePng`, `saveTiff`, etc.\n - You may also render an image from the distance field using `renderSDF`. Consider calling `simulate8bit`\n   on the distance field beforehand to simulate the standard 8 bits/channel image format.\n\nExample:\n```c++\n#include <msdfgen.h>\n#include <msdfgen-ext.h>\n\nusing namespace msdfgen;\n\nint main() {\n    if (FreetypeHandle *ft = initializeFreetype()) {\n        if (FontHandle *font = loadFont(ft, \"C:\\\\Windows\\\\Fonts\\\\arialbd.ttf\")) {\n            Shape shape;\n            if (loadGlyph(shape, font, 'A', FONT_SCALING_EM_NORMALIZED)) {\n                shape.normalize();\n                //                      max. angle\n                edgeColoringSimple(shape, 3.0);\n                //          output width, height\n                Bitmap<float, 3> msdf(32, 32);\n                //                            scale, translation (in em's)\n                SDFTransformation t(Projection(32.0, Vector2(0.125, 0.125)), Range(0.125));\n                generateMSDF(msdf, shape, t);\n                savePng(msdf, \"output.png\");\n            }\n            destroyFont(font);\n        }\n        deinitializeFreetype(ft);\n    }\n    return 0;\n}\n```\n\n## Using a multi-channel distance field\n\nUsing a multi-channel distance field generated by this program is similarly simple to how a monochrome distance field is used.\nThe only additional operation is computing the **median** of the three channels inside the fragment shader,\nright after sampling the distance field. This signed distance value can then be used the same way as usual.\n\nThe following is an example GLSL fragment shader with anti-aliasing:\n\n```glsl\nin vec2 texCoord;\nout vec4 color;\nuniform sampler2D msdf;\nuniform vec4 bgColor;\nuniform vec4 fgColor;\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nvoid main() {\n    vec3 msd = texture(msdf, texCoord).rgb;\n    float sd = median(msd.r, msd.g, msd.b);\n    float screenPxDistance = screenPxRange()*(sd - 0.5);\n    float opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n    color = mix(bgColor, fgColor, opacity);\n}\n```\n\nHere, `screenPxRange()` represents the distance field range in output screen pixels. For example, if the pixel range was set to 2\nwhen generating a 32x32 distance field, and it is used to draw a quad that is 72x72 pixels on the screen,\nit should return 4.5 (because 72/32 * 2 = 4.5).\n**For 2D rendering, this can generally be replaced by a precomputed uniform value.**\n\nFor rendering in a **3D perspective only**, where the texture scale varies across the screen,\nyou may want to implement this function with fragment derivatives in the following way.\nI would suggest precomputing `unitRange` as a uniform variable instead of `pxRange` for better performance.\n\n```glsl\nuniform float pxRange; // set to distance field's pixel range\n\nfloat screenPxRange() {\n    vec2 unitRange = vec2(pxRange)/vec2(textureSize(msdf, 0));\n    vec2 screenTexSize = vec2(1.0)/fwidth(texCoord);\n    return max(0.5*dot(unitRange, screenTexSize), 1.0);\n}\n```\n\n`screenPxRange()` must never be lower than 1. If it is lower than 2, there is a high probability that the anti-aliasing will fail\nand you may want to re-generate your distance field with a wider range.\n\n## Shape description syntax\n\nThe text shape description has the following syntax.\n - Each closed contour is enclosed by braces: `{ <contour 1> } { <contour 2> }`\n - Each point (and control point) is written as two real numbers separated by a comma.\n - Points in a contour are separated with semicolons.\n - The last point of each contour must be equal to the first, or the symbol `#` can be used, which represents the first point.\n - There can be an edge segment specification between any two points, also separated by semicolons.\n   This can include the edge's color (`c`, `m`, `y` or `w`) and/or one or two Bézier curve control points inside parentheses.\n\nFor example,\n```\n{ -1, -1; m; -1, +1; y; +1, +1; m; +1, -1; y; # }\n```\nwould represent a square with magenta and yellow edges,\n```\n{ 0, 1; (+1.6, -0.8; -1.6, -0.8); # }\n```\nis a teardrop shape formed by a single cubic Bézier curve.\n"
        },
        {
          "name": "build-release.bat",
          "type": "blob",
          "size": 3.1650390625,
          "content": "@echo off\nsetlocal\npushd \"%~dp0\"\n\nif \"%VCVARSALL%\"==\"\" set \"VCVARSALL=C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvarsall.bat\"\nif \"%VCTOOLSET%\"==\"\" set \"VCTOOLSET=VC143\"\n\nif not exist \"%VCVARSALL%\" (\n    echo vcvarsall.bat not found, set VCVARSALL to its path\n    exit /b 1\n)\n\nif \"%1\"==\"\" (\n    echo No version specified, using current\n    set \"version=current\"\n) else (\n    set \"version=%1\"\n)\nset \"builddir=%~dp0\\build\\release-%version%\"\n\nif exist \"%builddir%\" (\n    echo Deleting contents of %builddir%\n    rd /s /q \"%builddir%\"\n)\n\ncmake --preset win32 -B \"%builddir%\\build-win32\"\ncmake --preset win32-omp -B \"%builddir%\\build-win32-omp\"\ncmake --preset win64 -B \"%builddir%\\build-win64\"\ncmake --preset win64-omp -B \"%builddir%\\build-win64-omp\"\n\ncmake --build \"%builddir%\\build-win32\" --config Release\ncmake --build \"%builddir%\\build-win32-omp\" --config Release\ncmake --build \"%builddir%\\build-win64\" --config Release\ncmake --build \"%builddir%\\build-win64-omp\" --config Release\n\nmkdir \"%builddir%\\rel-win32\\msdfgen\"\nmkdir \"%builddir%\\rel-win32-omp\\msdfgen\"\nmkdir \"%builddir%\\rel-win64\\msdfgen\"\nmkdir \"%builddir%\\rel-win64-omp\\msdfgen\"\n\ncopy \"%builddir%\\build-win32\\Release\\msdfgen.exe\" \"%builddir%\\rel-win32\\msdfgen\"\ncopy \"%builddir%\\build-win32-omp\\Release\\msdfgen.exe\" \"%builddir%\\rel-win32-omp\\msdfgen\"\ncopy \"%builddir%\\build-win64\\Release\\msdfgen.exe\" \"%builddir%\\rel-win64\\msdfgen\"\ncopy \"%builddir%\\build-win64-omp\\Release\\msdfgen.exe\" \"%builddir%\\rel-win64-omp\\msdfgen\"\n\necho msdfgen.exe -defineshape \"{ 1471,0; 1149,0; 1021,333; 435,333; 314,0; 0,0; 571,1466; 884,1466; # }{ 926,580; 724,1124; 526,580; # }\" -size 16 16 -autoframe -testrender render.png 1024 1024 > \"%builddir%\\example.bat\"\n\ncopy \"%builddir%\\example.bat\" \"%builddir%\\rel-win32\\msdfgen\"\ncopy \"%builddir%\\example.bat\" \"%builddir%\\rel-win32-omp\\msdfgen\"\ncopy \"%builddir%\\example.bat\" \"%builddir%\\rel-win64\\msdfgen\"\ncopy \"%builddir%\\example.bat\" \"%builddir%\\rel-win64-omp\\msdfgen\"\n\ncall \"%VCVARSALL%\" x64\n\nset \"omp32dll=%VCToolsRedistDir%\\x86\\Microsoft.%VCTOOLSET%.OPENMP\\vcomp140.dll\"\nset \"omp64dll=%VCToolsRedistDir%\\x64\\Microsoft.%VCTOOLSET%.OPENMP\\vcomp140.dll\"\n\nif not exist \"%omp32dll%\" (\n    echo vcomp140.dll [x86] not found, make sure to set VCTOOLSET or update this script\n    exit /b 1\n)\nif not exist \"%omp64dll%\" (\n    echo vcomp140.dll [x64] not found, make sure to set VCTOOLSET or update this script\n    exit /b 1\n)\n\ncopy \"%omp32dll%\" \"%builddir%\\rel-win32-omp\\msdfgen\"\ncopy \"%omp64dll%\" \"%builddir%\\rel-win64-omp\\msdfgen\"\n\nif not exist \"C:\\Program Files\\7-Zip\\7z.exe\" (\n    echo 7-Zip not found, you have to package it manually\n    exit /b 0\n)\n\npushd \"%builddir%\\rel-win32\"\n\"C:\\Program Files\\7-Zip\\7z.exe\" a \"..\\msdfgen-%version%-win32.zip\" msdfgen\ncd msdfgen\ncall example.bat\npopd\npushd \"%builddir%\\rel-win32-omp\"\n\"C:\\Program Files\\7-Zip\\7z.exe\" a \"..\\msdfgen-%version%-win32-openmp.zip\" msdfgen\ncd msdfgen\ncall example.bat\npopd\npushd \"%builddir%\\rel-win64\"\n\"C:\\Program Files\\7-Zip\\7z.exe\" a \"..\\msdfgen-%version%-win64.zip\" msdfgen\ncd msdfgen\ncall example.bat\npopd\npushd \"%builddir%\\rel-win64-omp\"\n\"C:\\Program Files\\7-Zip\\7z.exe\" a \"..\\msdfgen-%version%-win64-openmp.zip\" msdfgen\ncd msdfgen\ncall example.bat\npopd\n\npopd\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "core",
          "type": "tree",
          "content": null
        },
        {
          "name": "ext",
          "type": "tree",
          "content": null
        },
        {
          "name": "icon.ico",
          "type": "blob",
          "size": 31.287109375,
          "content": null
        },
        {
          "name": "main.cpp",
          "type": "blob",
          "size": 55.44140625,
          "content": "\n/*\n * MULTI-CHANNEL SIGNED DISTANCE FIELD GENERATOR - standalone console program\n * --------------------------------------------------------------------------\n * A utility by Viktor Chlumsky, (c) 2014 - 2024\n *\n */\n\n#ifdef MSDFGEN_STANDALONE\n\n#ifndef _USE_MATH_DEFINES\n#define _USE_MATH_DEFINES\n#endif\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n\n#include \"msdfgen.h\"\n#ifdef MSDFGEN_EXTENSIONS\n#include \"msdfgen-ext.h\"\n#endif\n\n#include \"core/ShapeDistanceFinder.h\"\n\n#define SDF_ERROR_ESTIMATE_PRECISION 19\n#define DEFAULT_ANGLE_THRESHOLD 3.\n\n#if defined(MSDFGEN_EXTENSIONS) && !defined(MSDFGEN_DISABLE_PNG)\n#define DEFAULT_IMAGE_EXTENSION \"png\"\n#define SAVE_DEFAULT_IMAGE_FORMAT savePng\n#else\n#define DEFAULT_IMAGE_EXTENSION \"tiff\"\n#define SAVE_DEFAULT_IMAGE_FORMAT saveTiff\n#endif\n\nusing namespace msdfgen;\n\nenum Format {\n    AUTO,\n    PNG,\n    BMP,\n    TIFF,\n    RGBA,\n    FL32,\n    TEXT,\n    TEXT_FLOAT,\n    BINARY,\n    BINARY_FLOAT,\n    BINARY_FLOAT_BE\n};\n\nstatic bool is8bitFormat(Format format) {\n    return format == PNG || format == BMP || format == RGBA || format == TEXT || format == BINARY;\n}\n\nstatic char toupper(char c) {\n    return c >= 'a' && c <= 'z' ? c-'a'+'A' : c;\n}\n\nstatic bool parseUnsigned(unsigned &value, const char *arg) {\n    char *end = NULL;\n    value = (unsigned) strtoul(arg, &end, 10);\n    return end > arg && !*end;\n}\n\nstatic bool parseUnsignedDecOrHex(unsigned &value, const char *arg) {\n    char *end = NULL;\n    if (arg[0] == '0' && (arg[1] == 'x' || arg[1] == 'X')) {\n        arg += 2;\n        value = (unsigned) strtoul(arg, &end, 16);\n    } else\n        value = (unsigned) strtoul(arg, &end, 10);\n    return end > arg && !*end;\n    }\n\nstatic bool parseUnsignedLL(unsigned long long &value, const char *arg) {\n    if (*arg >= '0' && *arg <= '9') {\n        value = 0;\n        do {\n            value = 10*value+(*arg++-'0');\n        } while (*arg >= '0' && *arg <= '9');\n        return !*arg;\n}\n    return false;\n}\n\nstatic bool parseDouble(double &value, const char *arg) {\n    char *end = NULL;\n    value = strtod(arg, &end);\n    return end > arg && !*end;\n}\n\nstatic bool parseAngle(double &value, const char *arg) {\n    char *end = NULL;\n    value = strtod(arg, &end);\n    if (end > arg) {\n        arg = end;\n        if (*arg == 'd' || *arg == 'D') {\n            ++arg;\n        value *= M_PI/180;\n    }\n        return !*arg;\n    }\n    return false;\n}\n\nstatic void parseColoring(Shape &shape, const char *edgeAssignment) {\n    unsigned c = 0, e = 0;\n    if (shape.contours.size() < c) return;\n    Contour *contour = &shape.contours[c];\n    bool change = false;\n    bool clear = true;\n    for (const char *in = edgeAssignment; *in; ++in) {\n        switch (*in) {\n            case ',':\n                if (change)\n                    ++e;\n                if (clear)\n                    while (e < contour->edges.size()) {\n                        contour->edges[e]->color = WHITE;\n                        ++e;\n                    }\n                ++c, e = 0;\n                if (shape.contours.size() <= c) return;\n                contour = &shape.contours[c];\n                change = false;\n                clear = true;\n                break;\n            case '?':\n                clear = false;\n                break;\n            case 'C': case 'M': case 'W': case 'Y': case 'c': case 'm': case 'w': case 'y':\n                if (change) {\n                    ++e;\n                    change = false;\n                }\n                if (e < contour->edges.size()) {\n                    contour->edges[e]->color = EdgeColor(\n                        (*in == 'C' || *in == 'c')*CYAN|\n                        (*in == 'M' || *in == 'm')*MAGENTA|\n                        (*in == 'Y' || *in == 'y')*YELLOW|\n                        (*in == 'W' || *in == 'w')*WHITE);\n                    change = true;\n                }\n                break;\n        }\n    }\n}\n\n#ifdef MSDFGEN_EXTENSIONS\nstatic bool parseUnicode(unicode_t &unicode, const char *arg) {\n    unsigned uuc;\n    if (parseUnsignedDecOrHex(uuc, arg)) {\n        unicode = uuc;\n        return true;\n    }\n    if (arg[0] == '\\'' && arg[1] && arg[2] == '\\'' && !arg[3]) {\n        unicode = (unicode_t) (unsigned char) arg[1];\n        return true;\n    }\n    return false;\n}\n\n#ifndef MSDFGEN_DISABLE_VARIABLE_FONTS\nstatic FontHandle *loadVarFont(FreetypeHandle *library, const char *filename) {\n    std::string buffer;\n    while (*filename && *filename != '?')\n        buffer.push_back(*filename++);\n    FontHandle *font = loadFont(library, buffer.c_str());\n    if (font && *filename++ == '?') {\n        do {\n            buffer.clear();\n            while (*filename && *filename != '=')\n                buffer.push_back(*filename++);\n            if (*filename == '=') {\n                char *end = NULL;\n                double value = strtod(++filename, &end);\n                if (end > filename) {\n                    filename = end;\n                    setFontVariationAxis(library, font, buffer.c_str(), value);\n                }\n            }\n        } while (*filename++ == '&');\n    }\n    return font;\n}\n#endif\n#endif\n\ntemplate <int N>\nstatic void invertColor(const BitmapRef<float, N> &bitmap) {\n    const float *end = bitmap.pixels+N*bitmap.width*bitmap.height;\n    for (float *p = bitmap.pixels; p < end; ++p)\n        *p = 1.f-*p;\n}\n\nstatic bool writeTextBitmap(FILE *file, const float *values, int cols, int rows) {\n    for (int row = 0; row < rows; ++row) {\n        for (int col = 0; col < cols; ++col) {\n            int v = clamp(int((*values++)*0x100), 0xff);\n            fprintf(file, col ? \" %02X\" : \"%02X\", v);\n        }\n        fprintf(file, \"\\n\");\n    }\n    return true;\n}\n\nstatic bool writeTextBitmapFloat(FILE *file, const float *values, int cols, int rows) {\n    for (int row = 0; row < rows; ++row) {\n        for (int col = 0; col < cols; ++col) {\n            fprintf(file, col ? \" %.9g\" : \"%.9g\", *values++);\n        }\n        fprintf(file, \"\\n\");\n    }\n    return true;\n}\n\nstatic bool writeBinBitmap(FILE *file, const float *values, int count) {\n    for (int pos = 0; pos < count; ++pos) {\n        unsigned char v = clamp(int((*values++)*0x100), 0xff);\n        fwrite(&v, 1, 1, file);\n    }\n    return true;\n}\n\n#ifdef __BIG_ENDIAN__\nstatic bool writeBinBitmapFloatBE(FILE *file, const float *values, int count)\n#else\nstatic bool writeBinBitmapFloat(FILE *file, const float *values, int count)\n#endif\n{\n    return (int) fwrite(values, sizeof(float), count, file) == count;\n}\n\n#ifdef __BIG_ENDIAN__\nstatic bool writeBinBitmapFloat(FILE *file, const float *values, int count)\n#else\nstatic bool writeBinBitmapFloatBE(FILE *file, const float *values, int count)\n#endif\n{\n    for (int pos = 0; pos < count; ++pos) {\n        const unsigned char *b = reinterpret_cast<const unsigned char *>(values++);\n        for (int i = sizeof(float)-1; i >= 0; --i)\n            fwrite(b+i, 1, 1, file);\n    }\n    return true;\n}\n\nstatic bool cmpExtension(const char *path, const char *ext) {\n    for (const char *a = path+strlen(path)-1, *b = ext+strlen(ext)-1; b >= ext; --a, --b)\n        if (a < path || toupper(*a) != toupper(*b))\n            return false;\n    return true;\n}\n\ntemplate <int N>\nstatic const char *writeOutput(const BitmapConstRef<float, N> &bitmap, const char *filename, Format &format) {\n    if (filename) {\n        if (format == AUTO) {\n        #if defined(MSDFGEN_EXTENSIONS) && !defined(MSDFGEN_DISABLE_PNG)\n            if (cmpExtension(filename, \".png\")) format = PNG;\n        #else\n            if (cmpExtension(filename, \".png\"))\n                return \"PNG format is not available in core-only version.\";\n        #endif\n            else if (cmpExtension(filename, \".bmp\")) format = BMP;\n            else if (cmpExtension(filename, \".tiff\") || cmpExtension(filename, \".tif\")) format = TIFF;\n            else if (cmpExtension(filename, \".rgba\")) format = RGBA;\n            else if (cmpExtension(filename, \".fl32\")) format = FL32;\n            else if (cmpExtension(filename, \".txt\")) format = TEXT;\n            else if (cmpExtension(filename, \".bin\")) format = BINARY;\n            else\n                return \"Could not deduce format from output file name.\";\n        }\n        switch (format) {\n        #if defined(MSDFGEN_EXTENSIONS) && !defined(MSDFGEN_DISABLE_PNG)\n            case PNG: return savePng(bitmap, filename) ? NULL : \"Failed to write output PNG image.\";\n        #endif\n            case BMP: return saveBmp(bitmap, filename) ? NULL : \"Failed to write output BMP image.\";\n            case TIFF: return saveTiff(bitmap, filename) ? NULL : \"Failed to write output TIFF image.\";\n            case RGBA: return saveRgba(bitmap, filename) ? NULL : \"Failed to write output RGBA image.\";\n            case FL32: return saveFl32(bitmap, filename) ? NULL : \"Failed to write output FL32 image.\";\n            case TEXT: case TEXT_FLOAT: {\n                FILE *file = fopen(filename, \"w\");\n                if (!file) return \"Failed to write output text file.\";\n                if (format == TEXT)\n                    writeTextBitmap(file, bitmap.pixels, N*bitmap.width, bitmap.height);\n                else if (format == TEXT_FLOAT)\n                    writeTextBitmapFloat(file, bitmap.pixels, N*bitmap.width, bitmap.height);\n                fclose(file);\n                return NULL;\n            }\n            case BINARY: case BINARY_FLOAT: case BINARY_FLOAT_BE: {\n                FILE *file = fopen(filename, \"wb\");\n                if (!file) return \"Failed to write output binary file.\";\n                if (format == BINARY)\n                    writeBinBitmap(file, bitmap.pixels, N*bitmap.width*bitmap.height);\n                else if (format == BINARY_FLOAT)\n                    writeBinBitmapFloat(file, bitmap.pixels, N*bitmap.width*bitmap.height);\n                else if (format == BINARY_FLOAT_BE)\n                    writeBinBitmapFloatBE(file, bitmap.pixels, N*bitmap.width*bitmap.height);\n                fclose(file);\n                return NULL;\n            }\n            default:;\n        }\n    } else {\n        if (format == AUTO || format == TEXT)\n            writeTextBitmap(stdout, bitmap.pixels, N*bitmap.width, bitmap.height);\n        else if (format == TEXT_FLOAT)\n            writeTextBitmapFloat(stdout, bitmap.pixels, N*bitmap.width, bitmap.height);\n        else\n            return \"Unsupported format for standard output.\";\n    }\n    return NULL;\n}\n\n#define STRINGIZE_(x) #x\n#define STRINGIZE(x) STRINGIZE_(x)\n#define MSDFGEN_VERSION_STRING STRINGIZE(MSDFGEN_VERSION)\n#ifdef MSDFGEN_VERSION_UNDERLINE\n    #define VERSION_UNDERLINE STRINGIZE(MSDFGEN_VERSION_UNDERLINE)\n#else\n    #define VERSION_UNDERLINE \"--------\"\n#endif\n\n#if defined(MSDFGEN_EXTENSIONS) && (defined(MSDFGEN_DISABLE_SVG) || defined(MSDFGEN_DISABLE_PNG) || defined(MSDFGEN_DISABLE_VARIABLE_FONTS))\n    #define TITLE_SUFFIX     \" - custom config\"\n    #define SUFFIX_UNDERLINE \"----------------\"\n#elif !defined(MSDFGEN_EXTENSIONS) && defined(MSDFGEN_USE_OPENMP)\n    #define TITLE_SUFFIX     \" - core with OpenMP\"\n    #define SUFFIX_UNDERLINE \"-------------------\"\n#elif !defined(MSDFGEN_EXTENSIONS)\n    #define TITLE_SUFFIX     \" - core only\"\n    #define SUFFIX_UNDERLINE \"------------\"\n#elif defined(MSDFGEN_USE_SKIA) && defined(MSDFGEN_USE_OPENMP)\n    #define TITLE_SUFFIX     \" with Skia & OpenMP\"\n    #define SUFFIX_UNDERLINE \"-------------------\"\n#elif defined(MSDFGEN_USE_SKIA)\n    #define TITLE_SUFFIX     \" with Skia\"\n    #define SUFFIX_UNDERLINE \"----------\"\n#elif defined(MSDFGEN_USE_OPENMP)\n    #define TITLE_SUFFIX     \" with OpenMP\"\n    #define SUFFIX_UNDERLINE \"------------\"\n#else\n    #define TITLE_SUFFIX\n    #define SUFFIX_UNDERLINE\n#endif\n\nstatic const char *const versionText =\n    \"MSDFgen v\" MSDFGEN_VERSION_STRING TITLE_SUFFIX \"\\n\"\n    \"(c) 2016 - \" STRINGIZE(MSDFGEN_COPYRIGHT_YEAR) \" Viktor Chlumsky\";\n\nstatic const char *const helpText =\n    \"\\n\"\n    \"Multi-channel signed distance field generator by Viktor Chlumsky v\" MSDFGEN_VERSION_STRING TITLE_SUFFIX \"\\n\"\n    \"------------------------------------------------------------------\" VERSION_UNDERLINE SUFFIX_UNDERLINE \"\\n\"\n    \"  Usage: msdfgen\"\n    #ifdef _WIN32\n        \".exe\"\n    #endif\n        \" <mode> <input specification> <options>\\n\"\n    \"\\n\"\n    \"MODES\\n\"\n    \"  sdf - Generate conventional monochrome (true) signed distance field.\\n\"\n    \"  psdf - Generate monochrome signed perpendicular distance field.\\n\"\n    \"  msdf - Generate multi-channel signed distance field. This is used by default if no mode is specified.\\n\"\n    \"  mtsdf - Generate combined multi-channel and true signed distance field in the alpha channel.\\n\"\n    \"  metrics - Report shape metrics only.\\n\"\n    \"\\n\"\n    \"INPUT SPECIFICATION\\n\"\n    \"  -defineshape <definition>\\n\"\n        \"\\tDefines input shape using the ad-hoc text definition.\\n\"\n#ifdef MSDFGEN_EXTENSIONS\n    \"  -font <filename.ttf> <character code>\\n\"\n        \"\\tLoads a single glyph from the specified font file.\\n\"\n        \"\\tFormat of character code is '?', 63, 0x3F (Unicode value), or g34 (glyph index).\\n\"\n#endif\n    \"  -shapedesc <filename.txt>\\n\"\n        \"\\tLoads text shape description from a file.\\n\"\n    \"  -stdin\\n\"\n        \"\\tReads text shape description from the standard input.\\n\"\n#if defined(MSDFGEN_EXTENSIONS) && !defined(MSDFGEN_DISABLE_SVG)\n    \"  -svg <filename.svg>\\n\"\n        \"\\tLoads the last vector path found in the specified SVG file.\\n\"\n#endif\n#if defined(MSDFGEN_EXTENSIONS) && !defined(MSDFGEN_DISABLE_VARIABLE_FONTS)\n    \"  -varfont <filename and variables> <character code>\\n\"\n        \"\\tLoads a single glyph from a variable font. Specify variable values as x.ttf?var1=0.5&var2=1\\n\"\n#endif\n    \"\\n\"\n    // Keep alphabetical order!\n    \"OPTIONS\\n\"\n    \"  -angle <angle>\\n\"\n        \"\\tSpecifies the minimum angle between adjacent edges to be considered a corner. Append D for degrees.\\n\"\n    \"  -apxrange <outermost distance> <innermost distance>\\n\"\n        \"\\tSpecifies the outermost (negative) and innermost representable distance in pixels.\\n\"\n    \"  -arange <outermost distance> <innermost distance>\\n\"\n        \"\\tSpecifies the outermost (negative) and innermost representable distance in shape units.\\n\"\n    \"  -ascale <x scale> <y scale>\\n\"\n        \"\\tSets the scale used to convert shape units to pixels asymmetrically.\\n\"\n    \"  -autoframe\\n\"\n        \"\\tAutomatically scales (unless specified) and translates the shape to fit.\\n\"\n    \"  -coloringstrategy <simple / inktrap / distance>\\n\"\n        \"\\tSelects the strategy of the edge coloring heuristic.\\n\"\n    \"  -dimensions <width> <height>\\n\"\n        \"\\tSets the dimensions of the output image.\\n\"\n    \"  -edgecolors <sequence>\\n\"\n        \"\\tOverrides automatic edge coloring with the specified color sequence.\\n\"\n#ifdef MSDFGEN_EXTENSIONS\n    \"  -emnormalize\\n\"\n        \"\\tBefore applying scale, normalizes font glyph coordinates so that 1 = 1 em.\\n\"\n#endif\n    \"  -errorcorrection <mode>\\n\"\n        \"\\tChanges the MSDF/MTSDF error correction mode. Use -errorcorrection help for a list of valid modes.\\n\"\n    \"  -errordeviationratio <ratio>\\n\"\n        \"\\tSets the minimum ratio between the actual and maximum expected distance delta to be considered an error.\\n\"\n    \"  -errorimproveratio <ratio>\\n\"\n        \"\\tSets the minimum ratio between the pre-correction distance error and the post-correction distance error.\\n\"\n    \"  -estimateerror\\n\"\n        \"\\tComputes and prints the distance field's estimated fill error to the standard output.\\n\"\n    \"  -exportshape <filename.txt>\\n\"\n        \"\\tSaves the shape description into a text file that can be edited and loaded using -shapedesc.\\n\"\n    \"  -exportsvg <filename.svg>\\n\"\n        \"\\tSaves the shape geometry into a simple SVG file.\\n\"\n    \"  -fillrule <nonzero / evenodd / positive / negative>\\n\"\n        \"\\tSets the fill rule for the scanline pass. Default is nonzero.\\n\"\n#if defined(MSDFGEN_EXTENSIONS) && !defined(MSDFGEN_DISABLE_PNG)\n    \"  -format <png / bmp / tiff / rgba / fl32 / text / textfloat / bin / binfloat / binfloatbe>\\n\"\n#else\n    \"  -format <bmp / tiff / rgba / fl32 / text / textfloat / bin / binfloat / binfloatbe>\\n\"\n#endif\n        \"\\tSpecifies the output format of the distance field. Otherwise it is chosen based on output file extension.\\n\"\n    \"  -guessorder\\n\"\n        \"\\tAttempts to detect if shape contours have the wrong winding and generates the SDF with the right one.\\n\"\n    \"  -help\\n\"\n        \"\\tDisplays this help.\\n\"\n    \"  -legacy\\n\"\n        \"\\tUses the original (legacy) distance field algorithms.\\n\"\n#ifdef MSDFGEN_EXTENSIONS\n    \"  -noemnormalize\\n\"\n        \"\\tRaw integer font glyph coordinates will be used. Without this option, legacy scaling will be applied.\\n\"\n#endif\n#ifdef MSDFGEN_USE_SKIA\n    \"  -nopreprocess\\n\"\n        \"\\tDisables path preprocessing which resolves self-intersections and overlapping contours.\\n\"\n#else\n    \"  -nooverlap\\n\"\n        \"\\tDisables resolution of overlapping contours.\\n\"\n    \"  -noscanline\\n\"\n        \"\\tDisables the scanline pass, which corrects the distance field's signs according to the selected fill rule.\\n\"\n#endif\n    \"  -o <filename>\\n\"\n        \"\\tSets the output file name. The default value is \\\"output.\" DEFAULT_IMAGE_EXTENSION \"\\\".\\n\"\n#ifdef MSDFGEN_USE_SKIA\n    \"  -overlap\\n\"\n        \"\\tSwitches to distance field generator with support for overlapping contours.\\n\"\n#endif\n    \"  -printmetrics\\n\"\n        \"\\tPrints relevant metrics of the shape to the standard output.\\n\"\n    \"  -pxrange <range>\\n\"\n        \"\\tSets the width of the range between the lowest and highest signed distance in pixels.\\n\"\n    \"  -range <range>\\n\"\n        \"\\tSets the width of the range between the lowest and highest signed distance in shape units.\\n\"\n    \"  -reverseorder\\n\"\n        \"\\tGenerates the distance field as if the shape's vertices were in reverse order.\\n\"\n    \"  -scale <scale>\\n\"\n        \"\\tSets the scale used to convert shape units to pixels.\\n\"\n#ifdef MSDFGEN_USE_SKIA\n    \"  -scanline\\n\"\n        \"\\tPerforms an additional scanline pass to fix the signs of the distances.\\n\"\n#endif\n    \"  -seed <n>\\n\"\n        \"\\tSets the random seed for edge coloring heuristic.\\n\"\n    \"  -stdout\\n\"\n        \"\\tPrints the output instead of storing it in a file. Only text formats are supported.\\n\"\n    \"  -testrender <filename.\" DEFAULT_IMAGE_EXTENSION \"> <width> <height>\\n\"\n#if defined(MSDFGEN_EXTENSIONS) && !defined(MSDFGEN_DISABLE_PNG)\n        \"\\tRenders an image preview using the generated distance field and saves it as a PNG file.\\n\"\n#else\n        \"\\tRenders an image preview using the generated distance field and saves it as a TIFF file.\\n\"\n#endif\n    \"  -testrendermulti <filename.\" DEFAULT_IMAGE_EXTENSION \"> <width> <height>\\n\"\n        \"\\tRenders an image preview without flattening the color channels.\\n\"\n    \"  -translate <x> <y>\\n\"\n        \"\\tSets the translation of the shape in shape units.\\n\"\n    \"  -version\\n\"\n        \"\\tPrints the version of the program.\\n\"\n    \"  -windingpreprocess\\n\"\n        \"\\tAttempts to fix only the contour windings assuming no self-intersections and even-odd fill rule.\\n\"\n    \"  -yflip\\n\"\n        \"\\tInverts the Y axis in the output distance field. The default order is bottom to top.\\n\"\n    \"\\n\";\n\nstatic const char *errorCorrectionHelpText =\n    \"\\n\"\n    \"ERROR CORRECTION MODES\\n\"\n    \"  auto-fast\\n\"\n        \"\\tDetects inversion artifacts and distance errors that do not affect edges by range testing.\\n\"\n    \"  auto-full\\n\"\n        \"\\tDetects inversion artifacts and distance errors that do not affect edges by exact distance evaluation.\\n\"\n    \"  auto-mixed (default)\\n\"\n        \"\\tDetects inversions by distance evaluation and distance errors that do not affect edges by range testing.\\n\"\n    \"  disabled\\n\"\n        \"\\tDisables error correction.\\n\"\n    \"  distance-fast\\n\"\n        \"\\tDetects distance errors by range testing. Does not care if edges and corners are affected.\\n\"\n    \"  distance-full\\n\"\n        \"\\tDetects distance errors by exact distance evaluation. Does not care if edges and corners are affected, slow.\\n\"\n    \"  edge-fast\\n\"\n        \"\\tDetects inversion artifacts only by range testing.\\n\"\n    \"  edge-full\\n\"\n        \"\\tDetects inversion artifacts only by exact distance evaluation.\\n\"\n    \"  help\\n\"\n        \"\\tDisplays this help.\\n\"\n    \"\\n\";\n\nint main(int argc, const char *const *argv) {\n    #define ABORT(msg) do { fputs(msg \"\\n\", stderr); return 1; } while (false)\n\n    // Parse command line arguments\n    enum {\n        NONE,\n        SVG,\n        FONT,\n        VAR_FONT,\n        DESCRIPTION_ARG,\n        DESCRIPTION_STDIN,\n        DESCRIPTION_FILE\n    } inputType = NONE;\n    enum {\n        SINGLE,\n        PERPENDICULAR,\n        MULTI,\n        MULTI_AND_TRUE,\n        METRICS\n    } mode = MULTI;\n    enum {\n        NO_PREPROCESS,\n        WINDING_PREPROCESS,\n        FULL_PREPROCESS\n    } geometryPreproc = (\n        #ifdef MSDFGEN_USE_SKIA\n            FULL_PREPROCESS\n        #else\n            NO_PREPROCESS\n        #endif\n    );\n    bool legacyMode = false;\n    MSDFGeneratorConfig generatorConfig;\n    generatorConfig.overlapSupport = geometryPreproc == NO_PREPROCESS;\n    bool scanlinePass = geometryPreproc == NO_PREPROCESS;\n    FillRule fillRule = FILL_NONZERO;\n    Format format = AUTO;\n    const char *input = NULL;\n    const char *output = \"output.\" DEFAULT_IMAGE_EXTENSION;\n    const char *shapeExport = NULL;\n    const char *svgExport = NULL;\n    const char *testRender = NULL;\n    const char *testRenderMulti = NULL;\n    bool outputSpecified = false;\n#ifdef MSDFGEN_EXTENSIONS\n    bool glyphIndexSpecified = false;\n    GlyphIndex glyphIndex;\n    unicode_t unicode = 0;\n    FontCoordinateScaling fontCoordinateScaling = FONT_SCALING_LEGACY;\n    bool fontCoordinateScalingSpecified = false;\n#endif\n\n    int width = 64, height = 64;\n    int testWidth = 0, testHeight = 0;\n    int testWidthM = 0, testHeightM = 0;\n    bool autoFrame = false;\n    enum {\n        RANGE_UNIT,\n        RANGE_PX\n    } rangeMode = RANGE_PX;\n    Range range(1);\n    Range pxRange(2);\n    Vector2 translate;\n    Vector2 scale = 1;\n    bool scaleSpecified = false;\n    double angleThreshold = DEFAULT_ANGLE_THRESHOLD;\n    float outputDistanceShift = 0.f;\n    const char *edgeAssignment = NULL;\n    bool yFlip = false;\n    bool printMetrics = false;\n    bool estimateError = false;\n    bool skipColoring = false;\n    enum {\n        KEEP,\n        REVERSE,\n        GUESS\n    } orientation = KEEP;\n    unsigned long long coloringSeed = 0;\n    void (*edgeColoring)(Shape &, double, unsigned long long) = &edgeColoringSimple;\n    bool explicitErrorCorrectionMode = false;\n\n    int argPos = 1;\n    bool suggestHelp = false;\n    while (argPos < argc) {\n        const char *arg = argv[argPos];\n        #define ARG_CASE(s, p) if ((!strcmp(arg, s)) && argPos+(p) < argc && (++argPos, true))\n        #define ARG_CASE_OR ) || !strcmp(arg,\n        #define ARG_MODE(s, m) if (!strcmp(arg, s)) { mode = m; ++argPos; continue; }\n        #define ARG_IS(s) (!strcmp(argv[argPos], s))\n        #define SET_FORMAT(fmt, ext) do { format = fmt; if (!outputSpecified) output = \"output.\" ext; } while (false)\n\n        // Accept arguments prefixed with -- instead of -\n        if (arg[0] == '-' && arg[1] == '-')\n            ++arg;\n\n        ARG_MODE(\"sdf\", SINGLE)\n        ARG_MODE(\"psdf\", PERPENDICULAR)\n        ARG_MODE(\"msdf\", MULTI)\n        ARG_MODE(\"mtsdf\", MULTI_AND_TRUE)\n        ARG_MODE(\"metrics\", METRICS)\n\n    #if defined(MSDFGEN_EXTENSIONS) && !defined(MSDFGEN_DISABLE_SVG)\n        ARG_CASE(\"-svg\", 1) {\n            inputType = SVG;\n            input = argv[argPos++];\n            continue;\n        }\n    #endif\n    #ifdef MSDFGEN_EXTENSIONS\n        //ARG_CASE -font, -varfont\n        if (argPos+2 < argc && (\n            (!strcmp(arg, \"-font\") && (inputType = FONT, true))\n            #ifndef MSDFGEN_DISABLE_VARIABLE_FONTS\n                || (!strcmp(arg, \"-varfont\") && (inputType = VAR_FONT, true))\n            #endif\n        ) && (++argPos, true)) {\n            input = argv[argPos++];\n            const char *charArg = argv[argPos++];\n            unsigned gi;\n            switch (charArg[0]) {\n                case 'G': case 'g':\n                    if (parseUnsignedDecOrHex(gi, charArg+1)) {\n                        glyphIndex = GlyphIndex(gi);\n                        glyphIndexSpecified = true;\n                    }\n                    break;\n                case 'U': case 'u':\n                    ++charArg;\n                    // fallthrough\n                default:\n                    parseUnicode(unicode, charArg);\n            }\n            continue;\n        }\n        ARG_CASE(\"-noemnormalize\", 0) {\n            fontCoordinateScaling = FONT_SCALING_NONE;\n            fontCoordinateScalingSpecified = true;\n            continue;\n        }\n        ARG_CASE(\"-emnormalize\", 0) {\n            fontCoordinateScaling = FONT_SCALING_EM_NORMALIZED;\n            fontCoordinateScalingSpecified = true;\n            continue;\n        }\n        ARG_CASE(\"-legacyfontscaling\", 0) {\n            fontCoordinateScaling = FONT_SCALING_LEGACY;\n            fontCoordinateScalingSpecified = true;\n            continue;\n        }\n    #else\n        ARG_CASE(\"-svg\", 1) {\n            ABORT(\"SVG input is not available in core-only version.\");\n        }\n        ARG_CASE(\"-font\", 2) {\n            ABORT(\"Font input is not available in core-only version.\");\n        }\n        ARG_CASE(\"-varfont\", 2) {\n            ABORT(\"Variable font input is not available in core-only version.\");\n        }\n    #endif\n        ARG_CASE(\"-defineshape\", 1) {\n            inputType = DESCRIPTION_ARG;\n            input = argv[argPos++];\n            continue;\n        }\n        ARG_CASE(\"-stdin\", 0) {\n            inputType = DESCRIPTION_STDIN;\n            input = \"stdin\";\n            continue;\n        }\n        ARG_CASE(\"-shapedesc\", 1) {\n            inputType = DESCRIPTION_FILE;\n            input = argv[argPos++];\n            continue;\n        }\n        ARG_CASE(\"-o\" ARG_CASE_OR \"-out\" ARG_CASE_OR \"-output\" ARG_CASE_OR \"-imageout\", 1) {\n            output = argv[argPos++];\n            outputSpecified = true;\n            continue;\n        }\n        ARG_CASE(\"-stdout\", 0) {\n            output = NULL;\n            continue;\n        }\n        ARG_CASE(\"-legacy\", 0) {\n            legacyMode = true;\n        #ifdef MSDFGEN_EXTENSIONS\n            fontCoordinateScaling = FONT_SCALING_LEGACY;\n            fontCoordinateScalingSpecified = true;\n        #endif\n            continue;\n        }\n        ARG_CASE(\"-nopreprocess\", 0) {\n            geometryPreproc = NO_PREPROCESS;\n            continue;\n        }\n        ARG_CASE(\"-windingpreprocess\", 0) {\n            geometryPreproc = WINDING_PREPROCESS;\n            continue;\n        }\n        ARG_CASE(\"-preprocess\", 0) {\n            geometryPreproc = FULL_PREPROCESS;\n            continue;\n        }\n        ARG_CASE(\"-nooverlap\", 0) {\n            generatorConfig.overlapSupport = false;\n            continue;\n        }\n        ARG_CASE(\"-overlap\", 0) {\n            generatorConfig.overlapSupport = true;\n            continue;\n        }\n        ARG_CASE(\"-noscanline\", 0) {\n            scanlinePass = false;\n            continue;\n        }\n        ARG_CASE(\"-scanline\", 0) {\n            scanlinePass = true;\n            continue;\n        }\n        ARG_CASE(\"-fillrule\", 1) {\n            scanlinePass = true;\n            if (ARG_IS(\"nonzero\")) fillRule = FILL_NONZERO;\n            else if (ARG_IS(\"evenodd\") || ARG_IS(\"odd\")) fillRule = FILL_ODD;\n            else if (ARG_IS(\"positive\")) fillRule = FILL_POSITIVE;\n            else if (ARG_IS(\"negative\")) fillRule = FILL_NEGATIVE;\n            else\n                fputs(\"Unknown fill rule specified.\\n\", stderr);\n            ++argPos;\n            continue;\n        }\n        ARG_CASE(\"-format\", 1) {\n            if (ARG_IS(\"auto\")) format = AUTO;\n        #if defined(MSDFGEN_EXTENSIONS) && !defined(MSDFGEN_DISABLE_PNG)\n            else if (ARG_IS(\"png\")) SET_FORMAT(PNG, \"png\");\n        #else\n            else if (ARG_IS(\"png\"))\n                fputs(\"PNG format is not available in core-only version.\\n\", stderr);\n        #endif\n            else if (ARG_IS(\"bmp\")) SET_FORMAT(BMP, \"bmp\");\n            else if (ARG_IS(\"tiff\") || ARG_IS(\"tif\")) SET_FORMAT(TIFF, \"tiff\");\n            else if (ARG_IS(\"rgba\")) SET_FORMAT(RGBA, \"rgba\");\n            else if (ARG_IS(\"fl32\")) SET_FORMAT(FL32, \"fl32\");\n            else if (ARG_IS(\"text\") || ARG_IS(\"txt\")) SET_FORMAT(TEXT, \"txt\");\n            else if (ARG_IS(\"textfloat\") || ARG_IS(\"txtfloat\")) SET_FORMAT(TEXT_FLOAT, \"txt\");\n            else if (ARG_IS(\"bin\") || ARG_IS(\"binary\")) SET_FORMAT(BINARY, \"bin\");\n            else if (ARG_IS(\"binfloat\") || ARG_IS(\"binfloatle\")) SET_FORMAT(BINARY_FLOAT, \"bin\");\n            else if (ARG_IS(\"binfloatbe\")) SET_FORMAT(BINARY_FLOAT_BE, \"bin\");\n            else\n                fputs(\"Unknown format specified.\\n\", stderr);\n            ++argPos;\n            continue;\n        }\n        ARG_CASE(\"-dimensions\" ARG_CASE_OR \"-size\", 2) {\n            unsigned w, h;\n            if (!(parseUnsigned(w, argv[argPos++]) && parseUnsigned(h, argv[argPos++]) && w && h))\n                ABORT(\"Invalid dimensions. Use -dimensions <width> <height> with two positive integers.\");\n            width = w, height = h;\n            continue;\n        }\n        ARG_CASE(\"-autoframe\", 0) {\n            autoFrame = true;\n            continue;\n        }\n        ARG_CASE(\"-range\" ARG_CASE_OR \"-unitrange\", 1) {\n            double r;\n            if (!parseDouble(r, argv[argPos++]))\n                ABORT(\"Invalid range argument. Use -range <range> with a real number.\");\n            if (r == 0)\n                ABORT(\"Range must be non-zero.\");\n            rangeMode = RANGE_UNIT;\n            range = Range(r);\n            continue;\n        }\n        ARG_CASE(\"-pxrange\", 1) {\n            double r;\n            if (!parseDouble(r, argv[argPos++]))\n                ABORT(\"Invalid range argument. Use -pxrange <range> with a real number.\");\n            if (r == 0)\n                ABORT(\"Range must be non-zero.\");\n            rangeMode = RANGE_PX;\n            pxRange = Range(r);\n            continue;\n        }\n        ARG_CASE(\"-arange\" ARG_CASE_OR \"-aunitrange\", 2) {\n            double r0, r1;\n            if (!(parseDouble(r0, argv[argPos++]) && parseDouble(r1, argv[argPos++])))\n                ABORT(\"Invalid range arguments. Use -arange <minimum> <maximum> with two real numbers.\");\n            if (r0 == r1)\n                ABORT(\"Range must be non-empty.\");\n            rangeMode = RANGE_UNIT;\n            range = Range(r0, r1);\n            continue;\n        }\n        ARG_CASE(\"-apxrange\", 2) {\n            double r0, r1;\n            if (!(parseDouble(r0, argv[argPos++]) && parseDouble(r1, argv[argPos++])))\n                ABORT(\"Invalid range arguments. Use -apxrange <minimum> <maximum> with two real numbers.\");\n            if (r0 == r1)\n                ABORT(\"Range must be non-empty.\");\n            rangeMode = RANGE_PX;\n            pxRange = Range(r0, r1);\n            continue;\n        }\n        ARG_CASE(\"-scale\", 1) {\n            double s;\n            if (!(parseDouble(s, argv[argPos++]) && s > 0))\n                ABORT(\"Invalid scale argument. Use -scale <scale> with a positive real number.\");\n            scale = s;\n            scaleSpecified = true;\n            continue;\n        }\n        ARG_CASE(\"-ascale\", 2) {\n            double sx, sy;\n            if (!(parseDouble(sx, argv[argPos++]) && parseDouble(sy, argv[argPos++]) && sx > 0 && sy > 0))\n                ABORT(\"Invalid scale arguments. Use -ascale <x> <y> with two positive real numbers.\");\n            scale.set(sx, sy);\n            scaleSpecified = true;\n            continue;\n        }\n        ARG_CASE(\"-translate\", 2) {\n            double tx, ty;\n            if (!(parseDouble(tx, argv[argPos++]) && parseDouble(ty, argv[argPos++])))\n                ABORT(\"Invalid translate arguments. Use -translate <x> <y> with two real numbers.\");\n            translate.set(tx, ty);\n            continue;\n        }\n        ARG_CASE(\"-angle\", 1) {\n            double at;\n            if (!parseAngle(at, argv[argPos++]))\n                ABORT(\"Invalid angle threshold. Use -angle <min angle> with a positive real number less than PI or a value in degrees followed by 'd' below 180d.\");\n            angleThreshold = at;\n            continue;\n        }\n        ARG_CASE(\"-errorcorrection\", 1) {\n            if (ARG_IS(\"disable\") || ARG_IS(\"disabled\") || ARG_IS(\"0\") || ARG_IS(\"none\") || ARG_IS(\"false\")) {\n                generatorConfig.errorCorrection.mode = ErrorCorrectionConfig::DISABLED;\n                generatorConfig.errorCorrection.distanceCheckMode = ErrorCorrectionConfig::DO_NOT_CHECK_DISTANCE;\n            } else if (ARG_IS(\"default\") || ARG_IS(\"auto\") || ARG_IS(\"auto-mixed\") || ARG_IS(\"mixed\")) {\n                generatorConfig.errorCorrection.mode = ErrorCorrectionConfig::EDGE_PRIORITY;\n                generatorConfig.errorCorrection.distanceCheckMode = ErrorCorrectionConfig::CHECK_DISTANCE_AT_EDGE;\n            } else if (ARG_IS(\"auto-fast\") || ARG_IS(\"fast\")) {\n                generatorConfig.errorCorrection.mode = ErrorCorrectionConfig::EDGE_PRIORITY;\n                generatorConfig.errorCorrection.distanceCheckMode = ErrorCorrectionConfig::DO_NOT_CHECK_DISTANCE;\n            } else if (ARG_IS(\"auto-full\") || ARG_IS(\"full\")) {\n                generatorConfig.errorCorrection.mode = ErrorCorrectionConfig::EDGE_PRIORITY;\n                generatorConfig.errorCorrection.distanceCheckMode = ErrorCorrectionConfig::ALWAYS_CHECK_DISTANCE;\n            } else if (ARG_IS(\"distance\") || ARG_IS(\"distance-fast\") || ARG_IS(\"indiscriminate\") || ARG_IS(\"indiscriminate-fast\")) {\n                generatorConfig.errorCorrection.mode = ErrorCorrectionConfig::INDISCRIMINATE;\n                generatorConfig.errorCorrection.distanceCheckMode = ErrorCorrectionConfig::DO_NOT_CHECK_DISTANCE;\n            } else if (ARG_IS(\"distance-full\") || ARG_IS(\"indiscriminate-full\")) {\n                generatorConfig.errorCorrection.mode = ErrorCorrectionConfig::INDISCRIMINATE;\n                generatorConfig.errorCorrection.distanceCheckMode = ErrorCorrectionConfig::ALWAYS_CHECK_DISTANCE;\n            } else if (ARG_IS(\"edge-fast\")) {\n                generatorConfig.errorCorrection.mode = ErrorCorrectionConfig::EDGE_ONLY;\n                generatorConfig.errorCorrection.distanceCheckMode = ErrorCorrectionConfig::DO_NOT_CHECK_DISTANCE;\n            } else if (ARG_IS(\"edge\") || ARG_IS(\"edge-full\")) {\n                generatorConfig.errorCorrection.mode = ErrorCorrectionConfig::EDGE_ONLY;\n                generatorConfig.errorCorrection.distanceCheckMode = ErrorCorrectionConfig::ALWAYS_CHECK_DISTANCE;\n            } else if (ARG_IS(\"help\")) {\n                puts(errorCorrectionHelpText);\n                return 0;\n            } else\n                fputs(\"Unknown error correction mode. Use -errorcorrection help for more information.\\n\", stderr);\n            ++argPos;\n            explicitErrorCorrectionMode = true;\n            continue;\n        }\n        ARG_CASE(\"-errordeviationratio\", 1) {\n            double edr;\n            if (!(parseDouble(edr, argv[argPos++]) && edr > 0))\n                ABORT(\"Invalid error deviation ratio. Use -errordeviationratio <ratio> with a positive real number.\");\n            generatorConfig.errorCorrection.minDeviationRatio = edr;\n            continue;\n        }\n        ARG_CASE(\"-errorimproveratio\", 1) {\n            double eir;\n            if (!(parseDouble(eir, argv[argPos++]) && eir > 0))\n                ABORT(\"Invalid error improvement ratio. Use -errorimproveratio <ratio> with a positive real number.\");\n            generatorConfig.errorCorrection.minImproveRatio = eir;\n            continue;\n        }\n        ARG_CASE(\"-coloringstrategy\" ARG_CASE_OR \"-edgecoloring\", 1) {\n            if (ARG_IS(\"simple\")) edgeColoring = &edgeColoringSimple;\n            else if (ARG_IS(\"inktrap\")) edgeColoring = &edgeColoringInkTrap;\n            else if (ARG_IS(\"distance\")) edgeColoring = &edgeColoringByDistance;\n            else\n                fputs(\"Unknown coloring strategy specified.\\n\", stderr);\n            ++argPos;\n            continue;\n        }\n        ARG_CASE(\"-edgecolors\", 1) {\n            static const char *allowed = \" ?,cmwyCMWY\";\n            for (int i = 0; argv[argPos][i]; ++i) {\n                for (int j = 0; allowed[j]; ++j)\n                    if (argv[argPos][i] == allowed[j])\n                        goto EDGE_COLOR_VERIFIED;\n                ABORT(\"Invalid edge coloring sequence. Use -edgecolors <color sequence> with only the colors C, M, Y, and W. Separate contours by commas and use ? to keep the default assigment for a contour.\");\n            EDGE_COLOR_VERIFIED:;\n            }\n            edgeAssignment = argv[argPos++];\n            continue;\n        }\n        ARG_CASE(\"-distanceshift\", 1) {\n            double ds;\n            if (!parseDouble(ds, argv[argPos++]))\n                ABORT(\"Invalid distance shift. Use -distanceshift <shift> with a real value.\");\n            outputDistanceShift = (float) ds;\n            continue;\n        }\n        ARG_CASE(\"-exportshape\", 1) {\n            shapeExport = argv[argPos++];\n            continue;\n        }\n        ARG_CASE(\"-exportsvg\", 1) {\n            svgExport = argv[argPos++];\n            continue;\n        }\n        ARG_CASE(\"-testrender\", 3) {\n            unsigned w, h;\n            testRender = argv[argPos++];\n            if (!(parseUnsigned(w, argv[argPos++]) && parseUnsigned(h, argv[argPos++]) && (int) w > 0 && (int) h > 0))\n                ABORT(\"Invalid arguments for test render. Use -testrender <output.\" DEFAULT_IMAGE_EXTENSION \"> <width> <height>.\");\n            testWidth = w, testHeight = h;\n            continue;\n        }\n        ARG_CASE(\"-testrendermulti\", 3) {\n            unsigned w, h;\n            testRenderMulti = argv[argPos++];\n            if (!(parseUnsigned(w, argv[argPos++]) && parseUnsigned(h, argv[argPos++]) && (int) w > 0 && (int) h > 0))\n                ABORT(\"Invalid arguments for test render. Use -testrendermulti <output.\" DEFAULT_IMAGE_EXTENSION \"> <width> <height>.\");\n            testWidthM = w, testHeightM = h;\n            continue;\n        }\n        ARG_CASE(\"-yflip\", 0) {\n            yFlip = true;\n            continue;\n        }\n        ARG_CASE(\"-printmetrics\", 0) {\n            printMetrics = true;\n            continue;\n        }\n        ARG_CASE(\"-estimateerror\", 0) {\n            estimateError = true;\n            continue;\n        }\n        ARG_CASE(\"-keeporder\", 0) {\n            orientation = KEEP;\n            continue;\n        }\n        ARG_CASE(\"-reverseorder\", 0) {\n            orientation = REVERSE;\n            continue;\n        }\n        ARG_CASE(\"-guessorder\", 0) {\n            orientation = GUESS;\n            continue;\n        }\n        ARG_CASE(\"-seed\", 1) {\n            if (!parseUnsignedLL(coloringSeed, argv[argPos++]))\n                ABORT(\"Invalid seed. Use -seed <N> with N being a non-negative integer.\");\n            continue;\n        }\n        ARG_CASE(\"-version\", 0) {\n            puts(versionText);\n            return 0;\n        }\n        ARG_CASE(\"-help\", 0) {\n            puts(helpText);\n            return 0;\n        }\n        fprintf(stderr, \"Unknown setting or insufficient parameters: %s\\n\", argv[argPos++]);\n        suggestHelp = true;\n    }\n    if (suggestHelp)\n        fprintf(stderr, \"Use -help for more information.\\n\");\n\n    // Load input\n    Shape::Bounds svgViewBox = { };\n    double glyphAdvance = 0;\n    if (!inputType || !input) {\n        #ifdef MSDFGEN_EXTENSIONS\n            #ifdef MSDFGEN_DISABLE_SVG\n                ABORT(\"No input specified! Use -font <file.ttf/otf> <character code> or see -help.\");\n            #else\n                ABORT(\"No input specified! Use either -svg <file.svg> or -font <file.ttf/otf> <character code>, or see -help.\");\n            #endif\n        #else\n            ABORT(\"No input specified! See -help.\");\n        #endif\n    }\n    if (mode == MULTI_AND_TRUE && (format == BMP || (format == AUTO && output && cmpExtension(output, \".bmp\"))))\n        ABORT(\"Incompatible image format. A BMP file cannot contain alpha channel, which is required in mtsdf mode.\");\n    Shape shape;\n    switch (inputType) {\n    #if defined(MSDFGEN_EXTENSIONS) && !defined(MSDFGEN_DISABLE_SVG)\n        case SVG: {\n            int svgImportFlags = loadSvgShape(shape, svgViewBox, input);\n            if (!(svgImportFlags&SVG_IMPORT_SUCCESS_FLAG))\n                ABORT(\"Failed to load shape from SVG file.\");\n            if (svgImportFlags&SVG_IMPORT_PARTIAL_FAILURE_FLAG)\n                fputs(\"Warning: Failed to load part of SVG file.\\n\", stderr);\n            if (svgImportFlags&SVG_IMPORT_INCOMPLETE_FLAG)\n                fputs(\"Warning: SVG file contains multiple paths or shapes but this version is only able to load one.\\n\", stderr);\n            else if (svgImportFlags&SVG_IMPORT_UNSUPPORTED_FEATURE_FLAG)\n                fputs(\"Warning: SVG file likely contains elements that are unsupported.\\n\", stderr);\n            if (svgImportFlags&SVG_IMPORT_TRANSFORMATION_IGNORED_FLAG)\n                fputs(\"Warning: SVG path transformation ignored.\\n\", stderr);\n            break;\n        }\n    #endif\n    #ifdef MSDFGEN_EXTENSIONS\n        case FONT: case VAR_FONT: {\n            if (!glyphIndexSpecified && !unicode)\n                ABORT(\"No character specified! Use -font <file.ttf/otf> <character code>. Character code can be a Unicode index (65, 0x41), a character in apostrophes ('A'), or a glyph index prefixed by g (g36, g0x24).\");\n            struct FreetypeFontGuard {\n                FreetypeHandle *ft;\n                FontHandle *font;\n                FreetypeFontGuard() : ft(), font() { }\n                ~FreetypeFontGuard() {\n                    if (ft) {\n                        if (font)\n                            destroyFont(font);\n                        deinitializeFreetype(ft);\n                    }\n                }\n            } guard;\n            if (!(guard.ft = initializeFreetype()))\n                ABORT(\"Failed to initialize FreeType library.\");\n            if (!(guard.font = (\n                #ifndef MSDFGEN_DISABLE_VARIABLE_FONTS\n                    inputType == VAR_FONT ? loadVarFont(guard.ft, input) :\n                #endif\n                loadFont(guard.ft, input)\n            )))\n                ABORT(\"Failed to load font file.\");\n            if (unicode)\n                getGlyphIndex(glyphIndex, guard.font, unicode);\n            if (!loadGlyph(shape, guard.font, glyphIndex, fontCoordinateScaling, &glyphAdvance))\n                ABORT(\"Failed to load glyph from font file.\");\n            if (!fontCoordinateScalingSpecified && (!autoFrame || scaleSpecified || rangeMode == RANGE_UNIT || mode == METRICS || printMetrics || shapeExport || svgExport)) {\n                fputs(\n                    \"Warning: Using legacy font coordinate conversion for compatibility reasons.\\n\"\n                    \"         The implicit scaling behavior will likely change in a future version resulting in different output.\\n\"\n                    \"         To silence this warning, use one of the following options:\\n\"\n                    \"           -noemnormalize to switch to the correct native font coordinates,\\n\"\n                    \"           -emnormalize to switch to coordinates normalized to 1 em, or\\n\"\n                    \"           -legacyfontscaling to keep current behavior and make sure it will not change.\\n\", stderr);\n            }\n            break;\n        }\n    #endif\n        case DESCRIPTION_ARG: {\n            if (!readShapeDescription(input, shape, &skipColoring))\n                ABORT(\"Parse error in shape description.\");\n            break;\n        }\n        case DESCRIPTION_STDIN: {\n            if (!readShapeDescription(stdin, shape, &skipColoring))\n                ABORT(\"Parse error in shape description.\");\n            break;\n        }\n        case DESCRIPTION_FILE: {\n            FILE *file = fopen(input, \"r\");\n            if (!file)\n                ABORT(\"Failed to load shape description file.\");\n            bool readSuccessful = readShapeDescription(file, shape, &skipColoring);\n            fclose(file);\n            if (!readSuccessful)\n                ABORT(\"Parse error in shape description.\");\n            break;\n        }\n        default:;\n    }\n\n    // Validate and normalize shape\n    if (!shape.validate())\n        ABORT(\"The geometry of the loaded shape is invalid.\");\n    switch (geometryPreproc) {\n        case NO_PREPROCESS:\n            break;\n        case WINDING_PREPROCESS:\n            shape.orientContours();\n            break;\n        case FULL_PREPROCESS:\n            #ifdef MSDFGEN_USE_SKIA\n                if (!resolveShapeGeometry(shape))\n                    fputs(\"Shape geometry preprocessing failed, skipping.\\n\", stderr);\n                else if (skipColoring) {\n                    skipColoring = false;\n                    fputs(\"Note: Input shape coloring won't be preserved due to geometry preprocessing.\\n\", stderr);\n                }\n            #else\n                ABORT(\"Shape geometry preprocessing (-preprocess) is not available in this version because the Skia library is not present.\");\n            #endif\n            break;\n    }\n    shape.normalize();\n    if (yFlip)\n        shape.inverseYAxis = !shape.inverseYAxis;\n\n    double avgScale = .5*(scale.x+scale.y);\n    Shape::Bounds bounds = { };\n    if (autoFrame || mode == METRICS || printMetrics || orientation == GUESS || svgExport)\n        bounds = shape.getBounds();\n\n    if (outputDistanceShift) {\n        Range &rangeRef = rangeMode == RANGE_PX ? pxRange : range;\n        double rangeShift = -outputDistanceShift*(rangeRef.upper-rangeRef.lower);\n        rangeRef.lower += rangeShift;\n        rangeRef.upper += rangeShift;\n    }\n\n    // Auto-frame\n    if (autoFrame) {\n        double l = bounds.l, b = bounds.b, r = bounds.r, t = bounds.t;\n        Vector2 frame(width, height);\n        if (!scaleSpecified) {\n            if (rangeMode == RANGE_UNIT)\n                l += range.lower, b += range.lower, r -= range.lower, t -= range.lower;\n            else\n                frame += 2*pxRange.lower;\n        }\n        if (l >= r || b >= t)\n            l = 0, b = 0, r = 1, t = 1;\n        if (frame.x <= 0 || frame.y <= 0)\n            ABORT(\"Cannot fit the specified pixel range.\");\n        Vector2 dims(r-l, t-b);\n        if (scaleSpecified)\n            translate = .5*(frame/scale-dims)-Vector2(l, b);\n        else {\n            if (dims.x*frame.y < dims.y*frame.x) {\n                translate.set(.5*(frame.x/frame.y*dims.y-dims.x)-l, -b);\n                scale = avgScale = frame.y/dims.y;\n            } else {\n                translate.set(-l, .5*(frame.y/frame.x*dims.x-dims.y)-b);\n                scale = avgScale = frame.x/dims.x;\n            }\n        }\n        if (rangeMode == RANGE_PX && !scaleSpecified)\n            translate -= pxRange.lower/scale;\n    }\n\n    if (rangeMode == RANGE_PX)\n        range = pxRange/min(scale.x, scale.y);\n\n    // Print metrics\n    if (mode == METRICS || printMetrics) {\n        FILE *out = stdout;\n        if (mode == METRICS && outputSpecified)\n            out = fopen(output, \"w\");\n        if (!out)\n            ABORT(\"Failed to write output file.\");\n        if (shape.inverseYAxis)\n            fprintf(out, \"inverseY = true\\n\");\n        if (svgViewBox.l < svgViewBox.r && svgViewBox.b < svgViewBox.t)\n            fprintf(out, \"view box = %.17g, %.17g, %.17g, %.17g\\n\", svgViewBox.l, svgViewBox.b, svgViewBox.r, svgViewBox.t);\n        if (bounds.l < bounds.r && bounds.b < bounds.t)\n            fprintf(out, \"bounds = %.17g, %.17g, %.17g, %.17g\\n\", bounds.l, bounds.b, bounds.r, bounds.t);\n        if (glyphAdvance != 0)\n            fprintf(out, \"advance = %.17g\\n\", glyphAdvance);\n        if (autoFrame) {\n            if (!scaleSpecified)\n                fprintf(out, \"scale = %.17g\\n\", avgScale);\n            fprintf(out, \"translate = %.17g, %.17g\\n\", translate.x, translate.y);\n        }\n        if (rangeMode == RANGE_PX)\n            fprintf(out, \"range %.17g to %.17g\\n\", range.lower, range.upper);\n        if (mode == METRICS && outputSpecified)\n            fclose(out);\n    }\n\n    // Compute output\n    SDFTransformation transformation(Projection(scale, translate), range);\n    Bitmap<float, 1> sdf;\n    Bitmap<float, 3> msdf;\n    Bitmap<float, 4> mtsdf;\n    MSDFGeneratorConfig postErrorCorrectionConfig(generatorConfig);\n    if (scanlinePass) {\n        if (explicitErrorCorrectionMode && generatorConfig.errorCorrection.distanceCheckMode != ErrorCorrectionConfig::DO_NOT_CHECK_DISTANCE) {\n            const char *fallbackModeName = \"unknown\";\n            switch (generatorConfig.errorCorrection.mode) {\n                case ErrorCorrectionConfig::DISABLED: fallbackModeName = \"disabled\"; break;\n                case ErrorCorrectionConfig::INDISCRIMINATE: fallbackModeName = \"distance-fast\"; break;\n                case ErrorCorrectionConfig::EDGE_PRIORITY: fallbackModeName = \"auto-fast\"; break;\n                case ErrorCorrectionConfig::EDGE_ONLY: fallbackModeName = \"edge-fast\"; break;\n            }\n            fprintf(stderr, \"Selected error correction mode not compatible with scanline pass, falling back to %s.\\n\", fallbackModeName);\n        }\n        generatorConfig.errorCorrection.mode = ErrorCorrectionConfig::DISABLED;\n        postErrorCorrectionConfig.errorCorrection.distanceCheckMode = ErrorCorrectionConfig::DO_NOT_CHECK_DISTANCE;\n    }\n    switch (mode) {\n        case SINGLE: {\n            sdf = Bitmap<float, 1>(width, height);\n            if (legacyMode)\n                generateSDF_legacy(sdf, shape, range, scale, translate);\n            else\n                generateSDF(sdf, shape, transformation, generatorConfig);\n            break;\n        }\n        case PERPENDICULAR: {\n            sdf = Bitmap<float, 1>(width, height);\n            if (legacyMode)\n                generatePSDF_legacy(sdf, shape, range, scale, translate);\n            else\n                generatePSDF(sdf, shape, transformation, generatorConfig);\n            break;\n        }\n        case MULTI: {\n            if (!skipColoring)\n                edgeColoring(shape, angleThreshold, coloringSeed);\n            if (edgeAssignment)\n                parseColoring(shape, edgeAssignment);\n            msdf = Bitmap<float, 3>(width, height);\n            if (legacyMode)\n                generateMSDF_legacy(msdf, shape, range, scale, translate, generatorConfig.errorCorrection);\n            else\n                generateMSDF(msdf, shape, transformation, generatorConfig);\n            break;\n        }\n        case MULTI_AND_TRUE: {\n            if (!skipColoring)\n                edgeColoring(shape, angleThreshold, coloringSeed);\n            if (edgeAssignment)\n                parseColoring(shape, edgeAssignment);\n            mtsdf = Bitmap<float, 4>(width, height);\n            if (legacyMode)\n                generateMTSDF_legacy(mtsdf, shape, range, scale, translate, generatorConfig.errorCorrection);\n            else\n                generateMTSDF(mtsdf, shape, transformation, generatorConfig);\n            break;\n        }\n        default:;\n    }\n\n    if (orientation == GUESS) {\n        // Get sign of signed distance outside bounds\n        Point2 p(bounds.l-(bounds.r-bounds.l)-1, bounds.b-(bounds.t-bounds.b)-1);\n        double distance = SimpleTrueShapeDistanceFinder::oneShotDistance(shape, p);\n        orientation = distance <= 0 ? KEEP : REVERSE;\n    }\n    if (orientation == REVERSE) {\n        switch (mode) {\n            case SINGLE:\n            case PERPENDICULAR:\n                invertColor<1>(sdf);\n                break;\n            case MULTI:\n                invertColor<3>(msdf);\n                break;\n            case MULTI_AND_TRUE:\n                invertColor<4>(mtsdf);\n                break;\n            default:;\n        }\n    }\n    if (scanlinePass) {\n        switch (mode) {\n            case SINGLE:\n            case PERPENDICULAR:\n                distanceSignCorrection(sdf, shape, transformation, fillRule);\n                break;\n            case MULTI:\n                distanceSignCorrection(msdf, shape, transformation, fillRule);\n                msdfErrorCorrection(msdf, shape, transformation, postErrorCorrectionConfig);\n                break;\n            case MULTI_AND_TRUE:\n                distanceSignCorrection(mtsdf, shape, transformation, fillRule);\n                msdfErrorCorrection(msdf, shape, transformation, postErrorCorrectionConfig);\n                break;\n            default:;\n        }\n    }\n\n    // Save output\n    if (shapeExport) {\n        if (FILE *file = fopen(shapeExport, \"w\")) {\n            writeShapeDescription(file, shape);\n            fclose(file);\n        } else\n            fputs(\"Failed to write shape export file.\\n\", stderr);\n    }\n    if (svgExport) {\n        if (!saveSvgShape(shape, bounds, svgExport))\n            fputs(\"Failed to write shape SVG file.\\n\", stderr);\n    }\n    const char *error = NULL;\n    switch (mode) {\n        case SINGLE:\n        case PERPENDICULAR:\n            if ((error = writeOutput<1>(sdf, output, format))) {\n                fprintf(stderr, \"%s\\n\", error);\n                return 1;\n            }\n            if (is8bitFormat(format) && (testRenderMulti || testRender || estimateError))\n                simulate8bit(sdf);\n            if (estimateError) {\n                double sdfError = estimateSDFError(sdf, shape, transformation, SDF_ERROR_ESTIMATE_PRECISION, fillRule);\n                printf(\"SDF error ~ %e\\n\", sdfError);\n            }\n            if (testRenderMulti) {\n                Bitmap<float, 3> render(testWidthM, testHeightM);\n                renderSDF(render, sdf, avgScale*range);\n                if (!SAVE_DEFAULT_IMAGE_FORMAT(render, testRenderMulti))\n                    fputs(\"Failed to write test render file.\\n\", stderr);\n            }\n            if (testRender) {\n                Bitmap<float, 1> render(testWidth, testHeight);\n                renderSDF(render, sdf, avgScale*range);\n                if (!SAVE_DEFAULT_IMAGE_FORMAT(render, testRender))\n                    fputs(\"Failed to write test render file.\\n\", stderr);\n            }\n            break;\n        case MULTI:\n            if ((error = writeOutput<3>(msdf, output, format))) {\n                fprintf(stderr, \"%s\\n\", error);\n                return 1;\n            }\n            if (is8bitFormat(format) && (testRenderMulti || testRender || estimateError))\n                simulate8bit(msdf);\n            if (estimateError) {\n                double sdfError = estimateSDFError(msdf, shape, transformation, SDF_ERROR_ESTIMATE_PRECISION, fillRule);\n                printf(\"SDF error ~ %e\\n\", sdfError);\n            }\n            if (testRenderMulti) {\n                Bitmap<float, 3> render(testWidthM, testHeightM);\n                renderSDF(render, msdf, avgScale*range);\n                if (!SAVE_DEFAULT_IMAGE_FORMAT(render, testRenderMulti))\n                    fputs(\"Failed to write test render file.\\n\", stderr);\n            }\n            if (testRender) {\n                Bitmap<float, 1> render(testWidth, testHeight);\n                renderSDF(render, msdf, avgScale*range);\n                if (!SAVE_DEFAULT_IMAGE_FORMAT(render, testRender))\n                    fputs(\"Failed to write test render file.\\n\", stderr);\n            }\n            break;\n        case MULTI_AND_TRUE:\n            if ((error = writeOutput<4>(mtsdf, output, format))) {\n                fprintf(stderr, \"%s\\n\", error);\n                return 1;\n            }\n            if (is8bitFormat(format) && (testRenderMulti || testRender || estimateError))\n                simulate8bit(mtsdf);\n            if (estimateError) {\n                double sdfError = estimateSDFError(mtsdf, shape, transformation, SDF_ERROR_ESTIMATE_PRECISION, fillRule);\n                printf(\"SDF error ~ %e\\n\", sdfError);\n            }\n            if (testRenderMulti) {\n                Bitmap<float, 4> render(testWidthM, testHeightM);\n                renderSDF(render, mtsdf, avgScale*range);\n                if (!SAVE_DEFAULT_IMAGE_FORMAT(render, testRenderMulti))\n                    fputs(\"Failed to write test render file.\\n\", stderr);\n            }\n            if (testRender) {\n                Bitmap<float, 1> render(testWidth, testHeight);\n                renderSDF(render, mtsdf, avgScale*range);\n                if (!SAVE_DEFAULT_IMAGE_FORMAT(render, testRender))\n                    fputs(\"Failed to write test render file.\\n\", stderr);\n            }\n            break;\n        default:;\n    }\n\n    return 0;\n}\n\n#endif\n"
        },
        {
          "name": "msdfgen-ext.h",
          "type": "blob",
          "size": 0.72265625,
          "content": "\n#pragma once\n\n/*\n * MULTI-CHANNEL SIGNED DISTANCE FIELD GENERATOR\n * ---------------------------------------------\n * A utility by Viktor Chlumsky, (c) 2014 - 2024\n *\n * The extension module provides ways to easily load input and save output using popular formats.\n *\n * Third party dependencies in extension module:\n * - Skia by Google\n *   (to resolve self-intersecting paths)\n * - FreeType 2\n *   (to load input font files)\n * - TinyXML 2 by Lee Thomason\n *   (to aid in parsing input SVG files)\n * - libpng by the PNG Development Group\n * - or LodePNG by Lode Vandevenne\n *   (to save output PNG images)\n *\n */\n\n#include \"ext/resolve-shape-geometry.h\"\n#include \"ext/save-png.h\"\n#include \"ext/import-svg.h\"\n#include \"ext/import-font.h\"\n"
        },
        {
          "name": "msdfgen.h",
          "type": "blob",
          "size": 5.2802734375,
          "content": "\n#pragma once\n\n/*\n * MULTI-CHANNEL SIGNED DISTANCE FIELD GENERATOR\n * ---------------------------------------------\n * A utility by Viktor Chlumsky, (c) 2014 - 2024\n *\n * The technique used to generate multi-channel distance fields in this code\n * has been developed by Viktor Chlumsky in 2014 for his master's thesis,\n * \"Shape Decomposition for Multi-Channel Distance Fields\". It provides improved\n * quality of sharp corners in glyphs and other 2D shapes compared to monochrome\n * distance fields. To reconstruct an image of the shape, apply the median of three\n * operation on the triplet of sampled signed distance values.\n *\n */\n\n#include \"core/base.h\"\n#include \"core/arithmetics.hpp\"\n#include \"core/Vector2.hpp\"\n#include \"core/Range.hpp\"\n#include \"core/Projection.h\"\n#include \"core/DistanceMapping.h\"\n#include \"core/SDFTransformation.h\"\n#include \"core/Scanline.h\"\n#include \"core/Shape.h\"\n#include \"core/BitmapRef.hpp\"\n#include \"core/Bitmap.h\"\n#include \"core/bitmap-interpolation.hpp\"\n#include \"core/pixel-conversion.hpp\"\n#include \"core/edge-coloring.h\"\n#include \"core/generator-config.h\"\n#include \"core/msdf-error-correction.h\"\n#include \"core/render-sdf.h\"\n#include \"core/rasterization.h\"\n#include \"core/sdf-error-estimation.h\"\n#include \"core/save-bmp.h\"\n#include \"core/save-tiff.h\"\n#include \"core/save-rgba.h\"\n#include \"core/save-fl32.h\"\n#include \"core/shape-description.h\"\n#include \"core/export-svg.h\"\n\nnamespace msdfgen {\n\n/// Generates a conventional single-channel signed distance field.\nvoid generateSDF(const BitmapRef<float, 1> &output, const Shape &shape, const SDFTransformation &transformation, const GeneratorConfig &config = GeneratorConfig());\n\n/// Generates a single-channel signed perpendicular distance field.\nvoid generatePSDF(const BitmapRef<float, 1> &output, const Shape &shape, const SDFTransformation &transformation, const GeneratorConfig &config = GeneratorConfig());\n\n/// Generates a multi-channel signed distance field. Edge colors must be assigned first! (See edgeColoringSimple)\nvoid generateMSDF(const BitmapRef<float, 3> &output, const Shape &shape, const SDFTransformation &transformation, const MSDFGeneratorConfig &config = MSDFGeneratorConfig());\n\n/// Generates a multi-channel signed distance field with true distance in the alpha channel. Edge colors must be assigned first.\nvoid generateMTSDF(const BitmapRef<float, 4> &output, const Shape &shape, const SDFTransformation &transformation, const MSDFGeneratorConfig &config = MSDFGeneratorConfig());\n\n// Old version of the function API's kept for backwards compatibility\nvoid generateSDF(const BitmapRef<float, 1> &output, const Shape &shape, const Projection &projection, Range range, const GeneratorConfig &config = GeneratorConfig());\nvoid generatePSDF(const BitmapRef<float, 1> &output, const Shape &shape, const Projection &projection, Range range, const GeneratorConfig &config = GeneratorConfig());\nvoid generatePseudoSDF(const BitmapRef<float, 1> &output, const Shape &shape, const Projection &projection, Range range, const GeneratorConfig &config = GeneratorConfig());\nvoid generateMSDF(const BitmapRef<float, 3> &output, const Shape &shape, const Projection &projection, Range range, const MSDFGeneratorConfig &config = MSDFGeneratorConfig());\nvoid generateMTSDF(const BitmapRef<float, 4> &output, const Shape &shape, const Projection &projection, Range range, const MSDFGeneratorConfig &config = MSDFGeneratorConfig());\n\nvoid generateSDF(const BitmapRef<float, 1> &output, const Shape &shape, Range range, const Vector2 &scale, const Vector2 &translate, bool overlapSupport = true);\nvoid generatePSDF(const BitmapRef<float, 1> &output, const Shape &shape, Range range, const Vector2 &scale, const Vector2 &translate, bool overlapSupport = true);\nvoid generatePseudoSDF(const BitmapRef<float, 1> &output, const Shape &shape, Range range, const Vector2 &scale, const Vector2 &translate, bool overlapSupport = true);\nvoid generateMSDF(const BitmapRef<float, 3> &output, const Shape &shape, Range range, const Vector2 &scale, const Vector2 &translate, const ErrorCorrectionConfig &errorCorrectionConfig = ErrorCorrectionConfig(), bool overlapSupport = true);\nvoid generateMTSDF(const BitmapRef<float, 4> &output, const Shape &shape, Range range, const Vector2 &scale, const Vector2 &translate, const ErrorCorrectionConfig &errorCorrectionConfig = ErrorCorrectionConfig(), bool overlapSupport = true);\n\n// Original simpler versions of the previous functions, which work well under normal circumstances, but cannot deal with overlapping contours.\nvoid generateSDF_legacy(const BitmapRef<float, 1> &output, const Shape &shape, Range range, const Vector2 &scale, const Vector2 &translate);\nvoid generatePSDF_legacy(const BitmapRef<float, 1> &output, const Shape &shape, Range range, const Vector2 &scale, const Vector2 &translate);\nvoid generatePseudoSDF_legacy(const BitmapRef<float, 1> &output, const Shape &shape, Range range, const Vector2 &scale, const Vector2 &translate);\nvoid generateMSDF_legacy(const BitmapRef<float, 3> &output, const Shape &shape, Range range, const Vector2 &scale, const Vector2 &translate, ErrorCorrectionConfig errorCorrectionConfig = ErrorCorrectionConfig());\nvoid generateMTSDF_legacy(const BitmapRef<float, 4> &output, const Shape &shape, Range range, const Vector2 &scale, const Vector2 &translate, ErrorCorrectionConfig errorCorrectionConfig = ErrorCorrectionConfig());\n\n}\n"
        },
        {
          "name": "msdfgen.rc",
          "type": "blob",
          "size": 4.4609375,
          "content": "﻿// Microsoft Visual C++ generated resource script.\r\n//\r\n#include \"resource.h\"\r\n\r\n#define APSTUDIO_READONLY_SYMBOLS\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Generated from the TEXTINCLUDE 2 resource.\r\n//\r\n#include \"winres.h\"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n#undef APSTUDIO_READONLY_SYMBOLS\r\n\r\n#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)\r\nLANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US\r\n\r\n#ifdef APSTUDIO_INVOKED\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// TEXTINCLUDE\r\n//\r\n\r\n1 TEXTINCLUDE \r\nBEGIN\r\n    \"resource.h\\0\"\r\nEND\r\n\r\n2 TEXTINCLUDE \r\nBEGIN\r\n    \"#include \"\"winres.h\"\"\\r\\n\"\r\n    \"\\0\"\r\nEND\r\n\r\n3 TEXTINCLUDE \r\nBEGIN\r\n    \"\\r\\n\"\r\n    \"\\0\"\r\nEND\r\n\r\n#endif    // APSTUDIO_INVOKED\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Version\r\n//\r\n\r\nVS_VERSION_INFO VERSIONINFO\r\n FILEVERSION MSDFGEN_VERSION_MAJOR, MSDFGEN_VERSION_MINOR, MSDFGEN_VERSION_REVISION, 0\r\n PRODUCTVERSION MSDFGEN_VERSION_MAJOR, MSDFGEN_VERSION_MINOR, MSDFGEN_VERSION_REVISION, 0\r\n FILEFLAGSMASK 0x3fL\r\n#ifdef _DEBUG\r\n FILEFLAGS 0x1L\r\n#else\r\n FILEFLAGS 0x0L\r\n#endif\r\n FILEOS 0x40004L\r\n FILETYPE 0x1L\r\n FILESUBTYPE 0x0L\r\nBEGIN\r\n    BLOCK \"StringFileInfo\"\r\n    BEGIN\r\n        BLOCK \"000904b0\"\r\n        BEGIN\r\n            VALUE \"CompanyName\", \"Viktor Chlumský\"\r\n            VALUE \"FileDescription\", \"MSDFgen command line utility\"\r\n            VALUE \"FileVersion\", MSDFGEN_VERSION_STRING\r\n            VALUE \"InternalName\", \"msdfgen.exe\"\r\n            VALUE \"LegalCopyright\", \"Copyright (C) \" MSDFGEN_COPYRIGHT_YEAR_STRING \" Viktor Chlumský\"\r\n            VALUE \"OriginalFilename\", \"msdfgen.exe\"\r\n            VALUE \"ProductName\", \"Multi-channel signed distance field generator\"\r\n            VALUE \"ProductVersion\", MSDFGEN_VERSION_STRING\r\n        END\r\n    END\r\n    BLOCK \"VarFileInfo\"\r\n    BEGIN\r\n        VALUE \"Translation\", 0x9, 1200\r\n    END\r\nEND\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Icon\r\n//\r\n\r\n// Icon with lowest ID value placed first to ensure application icon\r\n// remains consistent on all systems.\r\nIDI_ICON1               ICON                    \"icon.ico\"\r\n\r\n#endif\r\n"
        },
        {
          "name": "resource.h",
          "type": "blob",
          "size": 1.267578125,
          "content": "﻿\r\n#define STRINGIZE_(x) #x\r\n#define STRINGIZE(x) STRINGIZE_(x)\r\n#define MSDFGEN_VERSION_STRING STRINGIZE(MSDFGEN_VERSION)\r\n#define MSDFGEN_COPYRIGHT_YEAR_STRING STRINGIZE(MSDFGEN_COPYRIGHT_YEAR)\r\n\r\n//{{NO_DEPENDENCIES}}\r\n// Microsoft Visual C++ generated include file.\r\n// Used by msdfgen.rc\r\n//\r\n#define IDI_ICON1                       101\r\n\r\n// Next default values for new objects\r\n// \r\n#ifdef APSTUDIO_INVOKED\r\n#ifndef APSTUDIO_READONLY_SYMBOLS\r\n#define _APS_NEXT_RESOURCE_VALUE        102\r\n#define _APS_NEXT_COMMAND_VALUE         40001\r\n#define _APS_NEXT_CONTROL_VALUE         1001\r\n#define _APS_NEXT_SYMED_VALUE           101\r\n#endif\r\n#endif\r\n"
        },
        {
          "name": "vcpkg.json",
          "type": "blob",
          "size": 1.26171875,
          "content": "{\n    \"$schema\": \"https://raw.githubusercontent.com/microsoft/vcpkg-tool/master/docs/vcpkg.schema.json\",\n    \"name\": \"msdfgen\",\n    \"version\": \"1.12.0\",\n    \"default-features\": [\n        \"extensions\",\n        \"geometry-preprocessing\",\n        \"standalone\"\n    ],\n    \"features\": {\n        \"openmp\": {\n            \"description\": \"Parallelization of the core algorithm via the OpenMP framework\"\n        },\n        \"extensions\": {\n            \"description\": \"Extended functionality that depends on external libraries - loading fonts and SVG files, generating PNG images\",\n            \"dependencies\": [\n                \"freetype\",\n                \"tinyxml2\",\n                \"libpng\"\n            ]\n        },\n        \"geometry-preprocessing\": {\n            \"description\": \"Preprocessing of non-compliant vector geometry via the Skia library\",\n            \"dependencies\": [ {\n                \"name\": \"msdfgen\",\n                \"default-features\": false,\n                \"features\": [ \"extensions\" ]\n            }, {\n                \"name\": \"skia\",\n                \"default-features\": false,\n                \"version>=\": \"0.36.0#3\"\n            } ]\n        },\n        \"standalone\": {\n            \"description\": \"Build a command line utility that wraps the library's functionality\"\n        }\n    }\n}\n"
        }
      ]
    }
  ]
}