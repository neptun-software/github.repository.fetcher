{
  "metadata": {
    "timestamp": 1736565744002,
    "page": 663,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "wangyu-/tinyfecVPN",
      "stars": 2360,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.0693359375,
          "content": "SortIncludes: false\nBasedOnStyle: Google\nColumnLimit: 0\nIndentWidth: 4\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.0908203125,
          "content": "[submodule \"UDPspeeder\"]\n\tpath = UDPspeeder\n\turl = https://github.com/wangyu-/UDPspeeder.git\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 1.169921875,
          "content": "#note: experimental\n#      currently only used for generating `compile_commands.json` for clangd\n#      to build this project, it's suggested to use `makefile` instead\n\ncmake_minimum_required(VERSION 3.7)\nproject(tinyvpn)\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\nset(CMAKE_CXX_STANDARD 11)\n\nset(SOURCE_FILES\n        UDPspeeder/log.cpp\n        UDPspeeder/common.cpp\n        UDPspeeder/lib/fec.cpp\n        UDPspeeder/lib/rs.cpp\n        UDPspeeder/packet.cpp\n        UDPspeeder/delay_manager.cpp\n        UDPspeeder/fd_manager.cpp\n        UDPspeeder/connection.cpp\n        UDPspeeder/fec_manager.cpp\n        UDPspeeder/misc.cpp\n        UDPspeeder/my_ev.cpp\n        main.cpp\n        tun_dev_client.cpp\n        tun_dev_server.cpp\n        tun_dev.cpp\n)\nset(CMAKE_CXX_FLAGS \"-Wall -Wextra -Wno-unused-variable -Wno-unused-parameter -Wno-missing-field-initializers -O2 -g -fsanitize=address,undefined\")\n\n#target_include_directories(speederv2 PRIVATE .)\n#set(CMAKE_LINK_LIBRARY_FLAG \"-lrt\")\nadd_executable(tinyvpn ${SOURCE_FILES})\ntarget_link_libraries(tinyvpn rt)\ntarget_link_libraries(tinyvpn pthread)\ninclude_directories(SYSTEM \"UDPspeeder/libev\")\ninclude_directories(\"UDPspeeder\")\ninclude_directories(\".\")\n"
        },
        {
          "name": "ISSUE_TEMPLATE.md",
          "type": "blob",
          "size": 0.013671875,
          "content": "English Only.\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0625,
          "content": "MIT License\n\nCopyright (c) 2017 Yu Wang (wangyucn at gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.9990234375,
          "content": "# tinyfecVPN\n\nA Lightweight VPN with Build-in Forward Error Correction Support(or A Network Improving Tool which works at VPN mode). Improves your Network Quality on a High-latency Lossy Link. \n\n![image](/images/tinyFecVPN3.PNG)\n\ntinyfecVPN uses Forward Error Correction(Reed-Solomon code) to reduce packet loss rate, at the cost of additional bandwidth usage. \n\nAssume your local network to your server is lossy. Just establish a VPN connection to your server with tinyfecVPN, access your server via this VPN connection, then your connection quality will be significantly improved. With well-tuned parameters , you can easily reduce  IP or UDP/ICMP packet-loss-rate to less than 0.01% . Besides reducing packet-loss-rate, tinyfecVPN can also significantly improve your TCP latency and TCP single-thread download speed.\n\ntinyfecVPN uses same lib as [UDPspeeder](https://github.com/wangyu-/UDPspeeder), supports all FEC features of UDPspeeder. tinyfecVPN works at VPN mode,while UDPspeeder works at UDP tunnel mode.\n\n[tinyfecVPN wiki](https://github.com/wangyu-/tinyfecVPN/wiki)\n\n[简体中文](/doc/README.zh-cn.md)\n\n##### Note\nUDPspeeder's repo:\n\nhttps://github.com/wangyu-/UDPspeeder\n\n# Efficacy\nTested on a link with 100ms roundtrip and 10% packet loss at both direction. You can easily reproduce the test result by yourself.\n\n### Ping Packet Loss\n![](/images/en/ping_compare2.PNG)\n\n### SCP Copy Speed\n![](/images/en/scp_compare2.PNG)\n\n# Supported Platforms\nLinux host (including desktop Linux,<del>Android phone/tablet</del>, OpenWRT router, or Raspberry PI).Binaries for `amd64` `x86` `mips_be` `mips_le` `arm` are provided.\n\nFor Windows and MacOS, You can run tinyfecVPN inside [this](https://github.com/wangyu-/udp2raw-tunnel/releases/download/20171108.0/lede-17.01.2-x86_virtual_machine_image.zip) 7.5mb virtual machine image.\n\nNeed root or at least CAP_NET_ADMIN permission to run, for creating tun device.\n\n# How does it work\n\ntinyfecVPN uses FEC(Forward Error Correction) to reduce packet loss rate, at the cost of additional bandwidth usage. The algorithm for FEC is called Reed-Solomon.\n\n![](/images/FEC.PNG)\n\n### Reed-Solomon\n\n`\nIn coding theory, the Reed–Solomon code belongs to the class of non-binary cyclic error-correcting codes. The Reed–Solomon code is based on univariate polynomials over finite fields.\n`\n\n`\nIt is able to detect and correct multiple symbol errors. By adding t check symbols to the data, a Reed–Solomon code can detect any combination of up to t erroneous symbols, or correct up to ⌊t/2⌋ symbols. As an erasure code, it can correct up to t known erasures, or it can detect and correct combinations of errors and erasures. Reed–Solomon codes are also suitable as multiple-burst bit-error correcting codes, since a sequence of b + 1 consecutive bit errors can affect at most two symbols of size b. The choice of t is up to the designer of the code, and may be selected within wide limits.\n`\n\n![](/images/en/rs.png)\n\nCheck wikipedia for more info, https://en.wikipedia.org/wiki/Reed–Solomon_error_correction\n\n\n# Getting Started\n\n### Installing\n\nDownload binary release from https://github.com/wangyu-/tinyfecVPN/releases\n\n### Running\n\nAssume your server ip is `44.55.66.77`, you have a service listening on udp/tcp port `0.0.0.0:7777`. \n\n```\n# Run at server side:\n./tinyvpn -s -l0.0.0.0:4096 -f20:10 -k \"passwd\" --sub-net 10.22.22.0\n\n# Run at client side\n./tinyvpn -c -r44.55.66.77:4096 -f20:10 -k \"passwd\" --sub-net 10.22.22.0\n```\n\nNow, use `10.22.22.1:7777` to connect to your service,all traffic will be improved by FEC. If you ping `10.22.22.1`, you will get ping reply.\n\n##### Note\n\n`-f20:10` means sending 10 redundant packets for every 20 original packets.\n\n`-k` enables simple XOR encryption\n\nTo create tun device, you need root or cap_net_admin permission. Its suggested to run tinyfecVPN as non-root, check [this link](https://github.com/wangyu-/tinyfecVPN/wiki/run-tinyfecVPN-as-non-root) for more info.\n\nCurrently one server supports only one client. For multiple clients, start multiple servers. \n\n##### Note2\n\nYou can use udp2raw with tinyfecVPN together to get better speed on some ISP with UDP QoS(UDP throttling).\n\nudp2raw's repo：\n\nhttps://github.com/wangyu-/udp2raw-tunnel\n\n# Advanced Topic\n\n### Usage\n```\ntinyfecVPN\ngit version: b03df1b586    build date: Oct 31 2017 19:46:50\nrepository: https://github.com/wangyu-/tinyfecVPN/\n\nusage:\n    run as client: ./this_program -c -r server_ip:server_port  [options]\n    run as server: ./this_program -s -l server_listen_ip:server_port  [options]\n\ncommon options, must be same on both sides:\n    -k,--key              <string>        key for simple xor encryption. if not set, xor is disabled\nmain options:\n    --sub-net             <number>        specify sub-net, for example: 192.168.1.0 , default: 10.22.22.0\n    --tun-dev             <number>        sepcify tun device name, for example: tun10, default: a random name such as tun987\n    -f,--fec              x:y             forward error correction, send y redundant packets for every x packets\n    --timeout             <number>        how long could a packet be held in queue before doing fec, unit: ms, default: 8ms\n    --mode                <number>        fec-mode,available values: 0, 1; 0 cost less bandwidth, 1 cost less latency;default: 0)\n    --report              <number>        turn on send/recv report, and set a period for reporting, unit: s\n    --keep-reconnect                      re-connect after lost connection,only for client.\nadvanced options:\n    --mtu                 <number>        mtu. for mode 0, the program will split packet to segment smaller than mtu_value.\n                                          for mode 1, no packet will be split, the program just check if the mtu is exceed.\n                                          default value: 1250\n    -j,--jitter           <number>        simulated jitter. randomly delay first packet for 0~<number> ms, default value: 0.\n                                          do not use if you dont know what it means.\n    -i,--interval         <number>        scatter each fec group to a interval of <number> ms, to protect burst packet loss.\n                                          default value: 0. do not use if you dont know what it means.\n    --random-drop         <number>        simulate packet loss, unit: 0.01%. default value: 0\n    --disable-obscure     <number>        disable obscure, to save a bit bandwidth and cpu\ndeveloper options:\n    --tun-mtu             <number >       mtu of the tun interface,most time you shouldnt change this\n    --disable-mssfix      <number >       disable mssfix for tcp connection\n    --fifo                <string>        use a fifo(named pipe) for sending commands to the running program, so that you\n                                          can change fec encode parameters dynamically, check readme.md in repository for\n                                          supported commands.\n    -j ,--jitter          jmin:jmax       similiar to -j above, but create jitter randomly between jmin and jmax\n    -i,--interval         imin:imax       similiar to -i above, but scatter randomly between imin and imax\n    -q,--queue-len        <number>        max fec queue len, only for mode 0\n    --decode-buf          <number>        size of buffer of fec decoder,u nit: packet, default: 2000\n    --fix-latency                         try to stabilize latency, only for mode 0\n    --delay-capacity      <number>        max number of delayed packets\n    --disable-fec         <number>        completely disable fec, turn the program into a normal udp tunnel\n    --sock-buf            <number>        buf size for socket, >=10 and <=10240, unit: kbyte, default: 1024\nlog and help options:\n    --log-level           <number>        0: never    1: fatal   2: error   3: warn\n                                          4: info (default)      5: debug   6: trace\n    --log-position                        enable file name, function name, line number in log\n    --disable-color                       disable log color\n    -h,--help                             print this help message\n\n```\n### FEC Options\n\nThe program supports all options of UDPspeeder,check UDPspeeder repo for details:\n\nhttps://github.com/wangyu-/UDPspeeder\n\n### Addtional Options\n\n##### `--tun-dev`\n\nSpecify a tun device name to use. Example: `--tun-dev tun100`.\n\nIf not set,tinyfecVPN will randomly chose a name,such as `tun987`.\n\n##### `--sub-net`\n\nSpecify the sub-net of VPN. Example: `--sub-net 10.10.10.0`, in this way,server IP will be `10.10.10.1`,client IP will be `10.10.10.2`.\n\nThe last number of option should be zero, for exmaple `10.10.10.123` is invalild, and will be corrected automatically to `10.10.10.0`.\n\n##### `--keep-reconnect`\n\nOnly works at client side.\n\ntinyfecVPN server only handles one client at same time,the connection of a new client will kick old client,after being kicked,old client will just exit by default.\n\nIf `--keep-reconnect` is enabled , client will try to get connection back after lost connection or being kicked.\n\n# Performance Test(throughput)\n\nServer is a Vulr VPS in japan，CPU: single core 2.4GHz,ram: 512mb. Client is a Bandwagonhost VPS in USA，CPU: single core 2.0GHZ,ram: 96mb. To put pressure on the FEC algorithm, an additional 10% packet-loss rate was introduced at both direction.\n\n### Test command\n\n```\nServer side：\n./tinyvpn_amd64 -s -l 0.0.0.0:5533 --mode 0 -f20:10\niperf3 -s\n\nClient side：\n./tinyvpn_amd64 -c -r 44.55.66.77:5533 --mode 0 -f20:10\niperf3 -c 10.22.22.1 -P10\n```\n\n### Test result\n\n![image](/images/performance2.PNG)\n\nNote: the performance is mainly limited by the RS code lib.\n\n# Other\n\nAs a VPN software may contradict with local regulations, I had to introduce an intended restriction in the pre-released binaries: you can only use tinyfecVPN to access your own server.\n\nYou can easily get rid of this restriction by compiling the source code by yourself (take a look at the makefile). This restriction exits only at server side, only the server side binary needs to be compiled by yourself.\n\n(If you want to compile by yourself, use `git clone --recursive` instead of `git clone`, otherwise the submodule wont be cloned)\n"
        },
        {
          "name": "UDPspeeder",
          "type": "commit",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.cpp",
          "type": "blob",
          "size": 8.4365234375,
          "content": "/*\n * tun.cpp\n *\n *  Created on: Oct 26, 2017\n *      Author: root\n */\n\n#include \"common.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"tun_dev.h\"\n#include \"git_version.h\"\nusing namespace std;\n\nstatic void print_help() {\n    char git_version_buf[100] = {0};\n    strncpy(git_version_buf, gitversion, 10);\n\n    printf(\"tinyFecVPN\\n\");\n    printf(\"git version: %s    \", git_version_buf);\n    printf(\"build date: %s %s\\n\", __DATE__, __TIME__);\n    printf(\"repository: https://github.com/wangyu-/tinyFecVPN/\\n\");\n    printf(\"\\n\");\n    printf(\"usage:\\n\");\n    printf(\"    run as client: ./this_program -c -r server_ip:server_port  [options]\\n\");\n    printf(\"    run as server: ./this_program -s -l server_listen_ip:server_port  [options]\\n\");\n    printf(\"\\n\");\n    printf(\"common options, must be same on both sides:\\n\");\n    printf(\"    -k,--key              <string>        key for simple xor encryption. if not set, xor is disabled\\n\");\n\n    printf(\"main options:\\n\");\n    printf(\"    --sub-net             <number>        specify sub-net, for example: 192.168.1.0 , default: 10.22.22.0\\n\");\n    printf(\"    --tun-dev             <number>        sepcify tun device name, for example: tun10, default: a random name such as tun987\\n\");\n    printf(\"    -f,--fec              x:y             forward error correction, send y redundant packets for every x packets\\n\");\n    printf(\"    --timeout             <number>        how long could a packet be held in queue before doing fec, unit: ms, default: 8ms\\n\");\n    printf(\"    --report              <number>        turn on send/recv report, and set a period for reporting, unit: s\\n\");\n    printf(\"    --keep-reconnect                      re-connect after lost connection,only for client. \\n\");\n\n    printf(\"advanced options:\\n\");\n    printf(\"    --mode                <number>        fec-mode,available values: 0,1; mode 0(default) costs less bandwidth,no mtu problem.\\n\");\n    printf(\"                                          mode 1 usually introduces less latency, but you have to care about mtu.\\n\");\n    printf(\"    --mtu                 <number>        mtu for fec. for mode 0, the program will split packet to segment smaller than mtu.\\n\");\n    printf(\"                                          for mode 1, no packet will be split, the program just check if the mtu is exceed.\\n\");\n    printf(\"                                          default value: 1250\\n\");\n    printf(\"    -j,--jitter           <number>        simulated jitter. randomly delay first packet for 0~<number> ms, default value: 0.\\n\");\n    printf(\"                                          do not use if you dont know what it means.\\n\");\n    printf(\"    -i,--interval         <number>        scatter each fec group to a interval of <number> ms, to defend burst packet loss.\\n\");\n    printf(\"                                          default value: 0. do not use if you dont know what it means.\\n\");\n    printf(\"    -f,--fec              x1:y1,x2:y2,..  similiar to -f/--fec above,fine-grained fec parameters,may help save bandwidth.\\n\");\n    printf(\"                                          example: \\\"-f 1:3,2:4,10:6,20:10\\\". check repo for details\\n\");\n    printf(\"    --random-drop         <number>        simulate packet loss, unit: 0.01%%. default value: 0\\n\");\n    printf(\"    --disable-obscure     <number>        disable obscure, to save a bit bandwidth and cpu\\n\");\n    printf(\"    --disable-checksum    <number>        disable checksum to save a bit bandwdith and cpu\\n\");\n    // printf(\"    --disable-xor         <number>        disable xor\\n\");\n    printf(\"    --persist-tun         <number>        make the tun device persistent, so that it wont be deleted after exited.\\n\");\n    printf(\"    --mssfix              <number>        do mssfix for tcp connection, use 0 to disable. default value: 1250\\n\");\n\n    printf(\"developer options:\\n\");\n    printf(\"    --tun-mtu             <number>        mtu of the tun interface,most time you shouldnt change this\\n\");\n    printf(\"    --manual-set-tun      <number>        tell tinyfecvpn to not setup the tun device automatically(e.g. assign ip address),\\n\");\n    printf(\"                                          so that you can do it manually later\\n\");\n    printf(\"    --fifo                <string>        use a fifo(named pipe) for sending commands to the running program, so that you\\n\");\n    printf(\"                                          can change fec encode parameters dynamically, check readme.md in repository for\\n\");\n    printf(\"                                          supported commands.\\n\");\n    printf(\"    -j ,--jitter          jmin:jmax       similiar to -j above, but create jitter randomly between jmin and jmax\\n\");\n    printf(\"    -i,--interval         imin:imax       similiar to -i above, but scatter randomly between imin and imax\\n\");\n    printf(\"    -q,--queue-len        <number>        fec queue len, only for mode 0, fec will be performed immediately after queue is full.\\n\");\n    printf(\"                                          default value: 200. \\n\");\n    printf(\"    --decode-buf          <number>        size of buffer of fec decoder,u nit: packet, default: 2000\\n\");\n    //    printf(\"    --fix-latency         <number>        try to stabilize latency, only for mode 0\\n\");\n    printf(\"    --delay-capacity      <number>        max number of delayed packets, 0 means unlimited, default: 0\\n\");\n    printf(\"    --disable-fec         <number>        completely disable fec, turn the program into a normal udp tunnel\\n\");\n    printf(\"    --sock-buf            <number>        buf size for socket, >=10 and <=10240, unit: kbyte, default: 1024\\n\");\n    printf(\"    --out-addr            ip:port         force all output packets of '-r' end to go through this address, port 0 for random port.\\n\");\n    printf(\"    --out-interface       <string>        force all output packets of '-r' end to go through this interface.\\n\");\n\n    printf(\"log and help options:\\n\");\n    printf(\"    --log-level           <number>        0: never    1: fatal   2: error   3: warn \\n\");\n    printf(\"                                          4: info (default)      5: debug   6: trace\\n\");\n    printf(\"    --log-position                        enable file name, function name, line number in log\\n\");\n    printf(\"    --disable-color                       disable log color\\n\");\n    printf(\"    -h,--help                             print this help message\\n\");\n\n    // printf(\"common options,these options must be same on both side\\n\");\n}\n\nvoid sigpipe_cb(struct ev_loop *l, ev_signal *w, int revents) {\n    mylog(log_info, \"got sigpipe, ignored\");\n}\n\nvoid sigterm_cb(struct ev_loop *l, ev_signal *w, int revents) {\n    mylog(log_info, \"got sigterm, exit\");\n    myexit(0);\n}\n\nvoid sigint_cb(struct ev_loop *l, ev_signal *w, int revents) {\n    mylog(log_info, \"got sigint, exit\");\n    myexit(0);\n}\n\nint main(int argc, char *argv[]) {\n    working_mode = tun_dev_mode;\n    struct ev_loop *loop = ev_default_loop(0);\n#if !defined(__MINGW32__)\n    ev_signal signal_watcher_sigpipe;\n    ev_signal_init(&signal_watcher_sigpipe, sigpipe_cb, SIGPIPE);\n    ev_signal_start(loop, &signal_watcher_sigpipe);\n#else\n    enable_log_color = 0;\n#endif\n\n    ev_signal signal_watcher_sigterm;\n    ev_signal_init(&signal_watcher_sigterm, sigterm_cb, SIGTERM);\n    ev_signal_start(loop, &signal_watcher_sigterm);\n\n    ev_signal signal_watcher_sigint;\n    ev_signal_init(&signal_watcher_sigint, sigint_cb, SIGINT);\n    ev_signal_start(loop, &signal_watcher_sigint);\n\n    assert(sizeof(u64_t) == 8);\n    assert(sizeof(i64_t) == 8);\n    assert(sizeof(u32_t) == 4);\n    assert(sizeof(i32_t) == 4);\n    assert(sizeof(u16_t) == 2);\n    assert(sizeof(i16_t) == 2);\n    dup2(1, 2);  // redirect stderr to stdout\n    int i, j, k;\n    if (argc == 1) {\n        print_help();\n        myexit(-1);\n    }\n    for (i = 0; i < argc; i++) {\n        if (strcmp(argv[i], \"-h\") == 0 || strcmp(argv[i], \"--help\") == 0) {\n            print_help();\n            myexit(0);\n        }\n    }\n\n    // g_fec_mode=0;\n\n    process_arg(argc, argv);\n\n    delay_manager.set_capacity(delay_capacity);\n    // local_ip_uint32=inet_addr(local_ip);\n    // remote_ip_uint32=inet_addr(remote_ip);\n    sub_net_uint32 = inet_addr(sub_net);\n\n    if (strlen(tun_dev) == 0) {\n        sprintf(tun_dev, \"tun%u\", get_fake_random_number() % 1000);\n    }\n    mylog(log_info, \"using interface %s\\n\", tun_dev);\n    /*if(tun_mtu==0)\n    {\n            tun_mtu=g_fec_mtu;\n    }*/\n    if (program_mode == client_mode) {\n        tun_dev_client_event_loop();\n    } else {\n        tun_dev_server_event_loop();\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "makefile",
          "type": "blob",
          "size": 3.5986328125,
          "content": "cc_cross=/toolchains/tmp/OpenWrt-SDK-15.05.1-ar71xx-generic_gcc-4.8-linaro_uClibc-0.9.33.2.Linux-x86_64/staging_dir/toolchain-mips_34kc_gcc-4.8-linaro_uClibc-0.9.33.2/bin/mips-openwrt-linux-g++ -s\ncc_local=g++\n#cc_mips34kc=/toolchains/OpenWrt-SDK-ar71xx-for-linux-x86_64-gcc-4.8-linaro_uClibc-0.9.33.2/staging_dir/toolchain-mips_34kc_gcc-4.8-linaro_uClibc-0.9.33.2/bin/mips-openwrt-linux-g++\ncc_mips24kc_be=/toolchains/lede-sdk-17.01.2-ar71xx-generic_gcc-5.4.0_musl-1.1.16.Linux-x86_64/staging_dir/toolchain-mips_24kc_gcc-5.4.0_musl-1.1.16/bin/mips-openwrt-linux-musl-g++\ncc_mips24kc_le=/toolchains/lede-sdk-17.01.2-ramips-mt7621_gcc-5.4.0_musl-1.1.16.Linux-x86_64/staging_dir/toolchain-mipsel_24kc_gcc-5.4.0_musl-1.1.16/bin/mipsel-openwrt-linux-musl-g++\n#cc_arm= /toolchains/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabi/bin/arm-linux-gnueabi-g++ -march=armv6 -marm \ncc_arm= /toolchains/arm-2014.05/bin/arm-none-linux-gnueabi-g++\n#cc_bcm2708=/home/wangyu/raspberry/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-g++ \nFLAGS= -std=c++11   -Wall -Wextra -Wno-unused-variable -Wno-unused-parameter -Wno-missing-field-initializers -ggdb -I. -IUDPspeeder -isystem UDPspeeder/libev ${OPT} \n\nSOURCES=`ls UDPspeeder/*.cpp UDPspeeder/lib/*.cpp|grep -v main.cpp|grep -v tunnel.cpp` main.cpp tun_dev.cpp tun_dev_client.cpp tun_dev_server.cpp\n\n#INCLUDE= -I.  -IUDPspeeder\n\nNAME=tinyvpn\n\nTARGETS=amd64 arm mips24kc_be x86  mips24kc_le\n\nTAR=${NAME}_binaries.tar.gz `echo ${TARGETS}|sed -r 's/([^ ]+)/tinyvpn_\\1/g'` version.txt\n\nexport STAGING_DIR=/tmp/    #just for supress warning of staging_dir not define\n\nall:git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}      ${INCLUDE}  ${SOURCES} ${FLAGS} -lrt -ggdb -static -O2\n\ndebug: git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -Wformat-nonliteral -D MY_DEBUG \ndebug2: git_version\n\trm -f ${NAME}\n\t${cc_local}   -o ${NAME}          -I. ${SOURCES} ${FLAGS} -lrt -Wformat-nonliteral -ggdb\n\ninit:\n\tgit submodule init\n\tgit submodule update\n\nmips24kc_be: git_version\n\t${cc_mips24kc_be}  -o ${NAME}_$@   -I. ${SOURCES} ${FLAGS} -lrt -lgcc_eh -static -O3\n\nmips24kc_be_debug: git_version\n\t${cc_mips24kc_be}  -o ${NAME}_$@   -I. ${SOURCES} ${FLAGS} -lrt -lgcc_eh -static -ggdb\n\nmips24kc_le: git_version\n\t${cc_mips24kc_le}  -o ${NAME}_$@   -I. ${SOURCES} ${FLAGS} -lrt -lgcc_eh -static -O3\n\namd64:git_version\n\t${cc_local}   -o ${NAME}_$@    -I. ${SOURCES} ${FLAGS} -lrt -static -O3\namd64_debug:git_version\n\t${cc_local}   -o ${NAME}_$@    -I. ${SOURCES} ${FLAGS} -lrt -static -ggdb\nx86:git_version\n\t${cc_local}   -o ${NAME}_$@      -I. ${SOURCES} ${FLAGS} -lrt -static -O3 -m32\narm:git_version\n\t${cc_arm}   -o ${NAME}_$@      -I. ${SOURCES} ${FLAGS} -lrt -static -O3\n\narm_debug:git_version\n\t${cc_arm}   -o ${NAME}_$@      -I. ${SOURCES} ${FLAGS} -lrt -static -ggdb\n\ncross:git_version\n\t${cc_cross}   -o ${NAME}_cross    -I. ${SOURCES} ${FLAGS} -lrt -O3\n\ncross2:git_version\n\t${cc_cross}   -o ${NAME}_cross    -I. ${SOURCES} ${FLAGS} -lrt -static -lgcc_eh -O3   \n\ncross3:git_version\n\t${cc_cross}   -o ${NAME}_cross    -I. ${SOURCES} ${FLAGS} -lrt -static -O3\n\nrelease: ${TARGETS} \n\tcp git_version.h version.txt\n\ttar -zcvf ${TAR}\n\nclean:\t\n\trm -f ${TAR}\n\trm -f speeder speeder_cross\n\trm -f git_version.h\n\ngit_version:\n\t    echo \"const char * const gitversion = \\\"$(shell git rev-parse HEAD)\\\";\" > git_version.h\n\t\n\n# targets without restrictions:\nnolimit:\n\tmake OPT=-DNOLIMIT\nnolimit_all:\n\tmake OPT=-DNOLIMIT\nnolimit_cross:\n\tmake cross OPT=-DNOLIMIT\nnolimit_cross2:\n\tmake cross2 OPT=-DNOLIMIT\nnolimit_cross3:\n\tmake cross3 OPT=-DNOLIMIT\nnolimit_release:\n\tmake release OPT=-DNOLIMIT\n"
        },
        {
          "name": "tun_dev.cpp",
          "type": "blob",
          "size": 8.5078125,
          "content": "/*\n * tun.cpp\n *\n *  Created on: Oct 26, 2017\n *      Author: root\n */\n\n#include \"tun_dev.h\"\n\nmy_time_t last_keep_alive_time = 0;\n\nint get_tun_fd(char *dev_name) {\n    int tun_fd = open(\"/dev/net/tun\", O_RDWR);\n\n    if (tun_fd < 0) {\n        mylog(log_fatal, \"open /dev/net/tun failed\");\n        myexit(-1);\n    }\n    struct ifreq ifr;\n    memset(&ifr, 0, sizeof(ifr));\n    ifr.ifr_flags = IFF_TUN | IFF_NO_PI;\n\n    strncpy(ifr.ifr_name, dev_name, IFNAMSIZ);\n\n    if (ioctl(tun_fd, TUNSETIFF, (void *)&ifr) != 0) {\n        mylog(log_fatal, \"open /dev/net/tun failed\");\n        myexit(-1);\n    }\n\n    if (persist_tun == 1) {\n        if (ioctl(tun_fd, TUNSETPERSIST, 1) != 0) {\n            mylog(log_warn, \"failed to set tun persistent\");\n        }\n    }\n    return tun_fd;\n}\n\nint set_tun(char *if_name, u32_t local_ip, u32_t remote_ip, int mtu) {\n    if (manual_set_tun) return 0;\n\n    // printf(\"i m here1\\n\");\n    struct ifreq ifr;\n    struct sockaddr_in sai;\n    memset(&ifr, 0, sizeof(ifr));\n    memset(&sai, 0, sizeof(struct sockaddr));\n\n    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    strncpy(ifr.ifr_name, if_name, IFNAMSIZ);\n\n    sai.sin_family = AF_INET;\n    sai.sin_port = 0;\n\n    sai.sin_addr.s_addr = local_ip;\n    memcpy(&ifr.ifr_addr, &sai, sizeof(struct sockaddr));\n    assert(ioctl(sockfd, SIOCSIFADDR, &ifr) == 0);  // set source ip\n\n    sai.sin_addr.s_addr = remote_ip;\n    memcpy(&ifr.ifr_addr, &sai, sizeof(struct sockaddr));\n    assert(ioctl(sockfd, SIOCSIFDSTADDR, &ifr) == 0);  // set dest ip\n\n    ifr.ifr_mtu = mtu;\n    assert(ioctl(sockfd, SIOCSIFMTU, &ifr) == 0);  // set mtu\n\n    assert(ioctl(sockfd, SIOCGIFFLAGS, &ifr) == 0);\n    // ifr.ifr_flags |= ( IFF_UP|IFF_POINTOPOINT|IFF_RUNNING|IFF_NOARP|IFF_MULTICAST );\n    ifr.ifr_flags = (IFF_UP | IFF_POINTOPOINT | IFF_RUNNING | IFF_NOARP | IFF_MULTICAST);  // set interface flags\n    assert(ioctl(sockfd, SIOCSIFFLAGS, &ifr) == 0);\n\n    // printf(\"i m here2\\n\");\n    return 0;\n}\n\nint put_header(char header, char *data, int &len) {\n    assert(len >= 0);\n    data[len] = header;\n    len += 1;\n    return 0;\n}\nint get_header(char &header, char *data, int &len) {\n    assert(len >= 0);\n    if (len < 1) return -1;\n    len -= 1;\n    header = data[len];\n\n    return 0;\n}\nint from_normal_to_fec2(conn_info_t &conn_info, dest_t &dest, char *data, int len, char header) {\n    int out_n;\n    char **out_arr;\n    int *out_len;\n    my_time_t *out_delay;\n\n    from_normal_to_fec(conn_info, data, len, out_n, out_arr, out_len, out_delay);\n\n    for (int i = 0; i < out_n; i++) {\n        char tmp_buf[buf_len];\n        int tmp_len = out_len[i];\n        memcpy(tmp_buf, out_arr[i], out_len[i]);\n        put_header(header, tmp_buf, tmp_len);\n        delay_send(out_delay[i], dest, tmp_buf, tmp_len);  // this is slow but safer.just use this one\n\n        // put_header(header,out_arr[i],out_len[i]);//modify in place\n        // delay_send(out_delay[i],dest,out_arr[i],out_len[i]);//warning this is currently okay,but if you modified fec encoder,you  may have to use the above code\n    }\n    return 0;\n}\n\nint from_fec_to_normal2(conn_info_t &conn_info, dest_t &dest, char *data, int len) {\n    int out_n;\n    char **out_arr;\n    int *out_len;\n    my_time_t *out_delay;\n\n    from_fec_to_normal(conn_info, data, len, out_n, out_arr, out_len, out_delay);\n\n    for (int i = 0; i < out_n; i++) {\n#if 0\n        if (program_mode == server_mode) {\n            char *tmp_data = out_arr[i];\n            int tmp_len = out_len[i];\n            iphdr *iph;\n            iph = (struct iphdr *)tmp_data;\n            if (tmp_len >= int(sizeof(iphdr)) && iph->version == 4) {\n                u32_t dest_ip = iph->daddr;\n                // printf(\"%s\\n\",my_ntoa(dest_ip));\n                if ((ntohl(sub_net_uint32) & 0xFFFFFF00) != (ntohl(dest_ip) & 0xFFFFFF00)) {\n                    string sub = my_ntoa(dest_ip);\n                    string dst = my_ntoa(htonl(ntohl(sub_net_uint32) & 0xFFFFFF00));\n                    mylog(log_warn, \"[restriction]packet's dest ip [%s] not in subnet [%s],dropped, maybe you need to compile an un-restricted server\\n\", sub.c_str(), dst.c_str());\n                    continue;\n                }\n            }\n        }\n#endif\n        delay_send(out_delay[i], dest, out_arr[i], out_len[i]);\n    }\n\n    return 0;\n}\nint do_mssfix(char *s, int len)  // currently only for ipv4\n{\n    if (mssfix == 0) {\n        return 0;\n    }\n\n    if (len < int(sizeof(iphdr))) {\n        mylog(log_debug, \"packet from tun len=%d <20\\n\", len);\n        return -1;\n    }\n    iphdr *iph;\n    iph = (struct iphdr *)s;\n    if (iph->version != 4) {\n        // mylog(log_trace,\"not ipv4\");\n        return 0;\n    }\n\n    if (iph->protocol != IPPROTO_TCP) {\n        // mylog(log_trace,\"not tcp\");\n        return 0;\n    }\n\n    int ip_len = ntohs(iph->tot_len);\n    int ip_hdr_len = iph->ihl * 4;\n\n    if (len < ip_hdr_len) {\n        mylog(log_debug, \"len<ip_hdr_len,%d %d\\n\", len, ip_hdr_len);\n        return -1;\n    }\n    if (len < ip_len) {\n        mylog(log_debug, \"len<ip_len,%d %d\\n\", len, ip_len);\n        return -1;\n    }\n    if (ip_hdr_len > ip_len) {\n        mylog(log_debug, \"ip_hdr_len<ip_len,%d %d\\n\", ip_hdr_len, ip_len);\n        return -1;\n    }\n\n    if ((ntohs(iph->frag_off) & (short)(0x1FFF)) != 0) {\n        // not first segment\n\n        // printf(\"line=%d %x  %x \\n\",__LINE__,(u32_t)ntohs(iph->frag_off),u32_t( ntohs(iph->frag_off) &0xFFF8));\n        return 0;\n    }\n    if ((ntohs(iph->frag_off) & (short)(0x80FF)) != 0) {\n        // not whole segment\n        // printf(\"line=%d   \\n\",__LINE__);\n        return 0;\n    }\n\n    char *tcp_begin = s + ip_hdr_len;\n    int tcp_len = ip_len - ip_hdr_len;\n\n    if (tcp_len < 20) {\n        mylog(log_debug, \"tcp_len<20,%d\\n\", tcp_len);\n        return -1;\n    }\n\n    tcphdr *tcph = (struct tcphdr *)tcp_begin;\n\n    if (int(tcph->syn) == 0)  // fast fail\n    {\n        mylog(log_trace, \"tcph->syn==0\\n\");\n        return 0;\n    }\n\n    int tcp_hdr_len = tcph->doff * 4;\n\n    if (tcp_len < tcp_hdr_len) {\n        mylog(log_debug, \"tcp_len <tcp_hdr_len, %d %d\\n\", tcp_len, tcp_hdr_len);\n        return -1;\n    }\n\n    /*\n    if(tcp_hdr_len==20)\n    {\n        //printf(\"line=%d\\n\",__LINE__);\n        mylog(log_trace,\"no tcp option\\n\");\n        return 0;\n    }*/\n\n    char *ptr = tcp_begin + 20;\n    char *option_end = tcp_begin + tcp_hdr_len;\n    while (ptr < option_end) {\n        if (*ptr == 0) {\n            return 0;\n        } else if (*ptr == 1) {\n            ptr++;\n        } else if (*ptr == 2) {\n            if (ptr + 1 >= option_end) {\n                mylog(log_debug, \"invaild option ptr+1==option_end,for mss\\n\");\n                return -1;\n            }\n            if (*(ptr + 1) != 4) {\n                mylog(log_debug, \"invaild mss len\\n\");\n                return -1;\n            }\n            if (ptr + 3 >= option_end) {\n                mylog(log_debug, \"ptr+4>option_end for mss\\n\");\n                return -1;\n            }\n            int mss = read_u16(ptr + 2);  // uint8_t(ptr[2])*256+uint8_t(ptr[3]);\n            int new_mss = mss;\n            if (new_mss > ::mssfix - 40 - 10)  // minus extra 10 for safe\n            {\n                new_mss = ::mssfix - 40 - 10;\n            }\n            write_u16(ptr + 2, (unsigned short)new_mss);\n\n            pseudo_header psh;\n\n            psh.source_address = iph->saddr;\n            psh.dest_address = iph->daddr;\n            psh.placeholder = 0;\n            psh.protocol = iph->protocol;\n            psh.tcp_length = htons(tcp_len);\n\n            tcph->check = 0;\n            tcph->check = tcp_csum(psh, (unsigned short *)tcph, tcp_len);\n\n            mylog(log_trace, \"mss=%d  syn=%d ack=%d, changed mss to %d \\n\", mss, (int)tcph->syn, (int)tcph->ack, new_mss);\n\n            // printf(\"test=%x\\n\",u32_t(1));\n            // printf(\"frag=%x\\n\",u32_t( ntohs(iph->frag_off) ));\n\n            return 0;\n        } else {\n            if (ptr + 1 >= option_end) {\n                mylog(log_debug, \"invaild option ptr+1==option_end\\n\");\n                return -1;\n            } else {\n                int len = (unsigned char)*(ptr + 1);\n                if (len <= 1) {\n                    mylog(log_debug, \"invaild option len %d\\n\", len);\n                    return -1;\n                }\n                ptr += len;\n            }\n        }\n    }\n\n    return 0;\n}\nint do_keep_alive(dest_t &dest) {\n    if (get_current_time() - last_keep_alive_time > u64_t(keep_alive_interval)) {\n        last_keep_alive_time = get_current_time();\n        char data[buf_len];\n        int len;\n        data[0] = header_keep_alive;\n        len = 1;\n\n        assert(dest.cook == 1);\n        // do_cook(data,len);\n\n        delay_send(0, dest, data, len);\n    }\n    return 0;\n}\n"
        },
        {
          "name": "tun_dev.h",
          "type": "blob",
          "size": 1.1357421875,
          "content": "/*\n * tun.h\n *\n *  Created on: Oct 26, 2017\n *      Author: root\n */\n\n#ifndef TUN_DEV_H_\n#define TUN_DEV_H_\n\n#include \"common.h\"\n#include \"log.h\"\n#include \"misc.h\"\n\n#include <netinet/tcp.h>  //Provides declarations for tcp header\n#include <netinet/udp.h>\n#include <netinet/ip.h>  //Provides declarations for ip header\n#include <netinet/if_ether.h>\n\n#include <linux/if.h>\n#include <linux/if_tun.h>\n\nextern my_time_t last_keep_alive_time;\n\nconst int keep_alive_interval = 3000;  // 3000ms\n\nconst char header_normal = 1;\nconst char header_new_connect = 2;\nconst char header_reject = 3;\nconst char header_keep_alive = 4;\n\nint set_tun(char *if_name, u32_t local_ip, u32_t remote_ip, int mtu);\n\nint get_tun_fd(char *dev_name);\n\nint put_header(char header, char *data, int &len);\n\nint get_header(char &header, char *data, int &len);\nint from_normal_to_fec2(conn_info_t &conn_info, dest_t &dest, char *data, int len, char header);\n\nint from_fec_to_normal2(conn_info_t &conn_info, dest_t &dest, char *data, int len);\nint do_mssfix(char *s, int len);\nint do_keep_alive(dest_t &dest);\n\nint tun_dev_client_event_loop();\n\nint tun_dev_server_event_loop();\n\n#endif /* TUN_H_ */\n"
        },
        {
          "name": "tun_dev_client.cpp",
          "type": "blob",
          "size": 8.8798828125,
          "content": "#include \"tun_dev.h\"\n\nstatic int got_feed_back = 0;\n\nstatic dest_t udp_dest;\nstatic dest_t tun_dest;\n\nstatic void remote_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    char data[buf_len];\n    int len;\n\n    fd64_t fd64 = watcher->u64;\n    int fd = fd_manager.to_fd(fd64);\n\n    len = recv(fd, data, max_data_len + 1, 0);\n\n    if (len == max_data_len + 1) {\n        mylog(log_warn, \"huge packet, data_len > %d,dropped\\n\", max_data_len);\n        return;\n    }\n\n    if (len < 0) {\n        mylog(log_warn, \"recv return %d,errno=%s\\n\", len, strerror(errno));\n        return;\n    }\n\n    if (de_cook(data, len) < 0) {\n        mylog(log_warn, \"de_cook(data,len)failed \\n\");\n        return;\n    }\n\n    char header = 0;\n    if (get_header(header, data, len) != 0) {\n        mylog(log_warn, \"get_header failed\\n\");\n        return;\n    }\n\n    if (header == header_keep_alive) {\n        mylog(log_trace, \"got keep_alive packet\\n\");\n        return;\n    }\n\n    if (header == header_reject) {\n        if (keep_reconnect == 0) {\n            mylog(log_fatal, \"server restarted or switched to handle another client,exited. maybe you need --keep-reconnect\\n\");\n            myexit(-1);\n        } else {\n            if (got_feed_back == 1)\n                mylog(log_warn, \"server restarted or switched to handle another client,but keep-reconnect enabled,trying to reconnect\\n\");\n            got_feed_back = 0;\n        }\n        return;\n    } else if (header == header_normal) {\n        if (got_feed_back == 0)\n            mylog(log_info, \"connection accepted by server\\n\");\n        got_feed_back = 1;\n    } else {\n        mylog(log_warn, \"invalid header %d %d\\n\", int(header), len);\n        return;\n    }\n\n    mylog(log_trace, \"Received packet from udp,len: %d\\n\", len);\n\n    from_fec_to_normal2(conn_info, tun_dest, data, len);\n}\n\nstatic void tun_fd_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    char data[buf_len];\n    int len;\n    int tun_fd = watcher->fd;\n\n    len = read(tun_fd, data, max_data_len + 1);\n\n    if (len == max_data_len + 1) {\n        mylog(log_warn, \"huge packet, data_len > %d,dropped\\n\", max_data_len);\n        return;\n    }\n\n    if (len < 0) {\n        mylog(log_warn, \"read from tun_fd return %d,errno=%s\\n\", len, strerror(errno));\n        return;\n    }\n\n    do_mssfix(data, len);\n\n    mylog(log_trace, \"Received packet from tun,len: %d\\n\", len);\n\n    char header = (got_feed_back == 0 ? header_new_connect : header_normal);\n    from_normal_to_fec2(conn_info, udp_dest, data, len, header);\n}\n\nstatic void delay_manager_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    // do nothing\n}\n\nstatic void fec_encode_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    mylog(log_trace, \"fec_encode_cb() called\\n\");\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    /// int ret;\n    /// fd64_t fd64=watcher->u64;\n    /// mylog(log_trace,\"events[idx].data.u64 == conn_info.fec_encode_manager.get_timer_fd64()\\n\");\n\n    /// uint64_t value;\n    /// if(!fd_manager.exist(fd64))   //fd64 has been closed\n    ///{\n    ///\tmylog(log_trace,\"!fd_manager.exist(fd64)\");\n    ///\treturn;\n    /// }\n    /// if((ret=read(fd_manager.to_fd(fd64), &value, 8))!=8)\n    ///{\n    ///\tmylog(log_trace,\"(ret=read(fd_manager.to_fd(fd64), &value, 8))!=8,ret=%d\\n\",ret);\n    ///\treturn;\n    /// }\n    /// if(value==0)\n    ///{\n    ///\tmylog(log_debug,\"value==0\\n\");\n    ///\treturn;\n    /// }\n    /// assert(value==1);\n\n    char header = (got_feed_back == 0 ? header_new_connect : header_normal);\n    from_normal_to_fec2(conn_info, udp_dest, 0, 0, header);\n}\n\nstatic void conn_timer_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    /// uint64_t value;\n    /// read(conn_info.timer.get_timer_fd(), &value, 8);\n    /// mylog(log_trace,\"events[idx].data.u64==(u64_t)conn_info.timer.get_timer_fd()\\n\");\n\n    mylog(log_trace, \"conn_timer_cb() called\\n\");\n    conn_info.stat.report_as_client();\n    if (got_feed_back) do_keep_alive(udp_dest);\n}\n\nstatic void fifo_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n    int fifo_fd = watcher->fd;\n\n    char buf[buf_len];\n    int len = read(fifo_fd, buf, sizeof(buf));\n    if (len < 0) {\n        mylog(log_warn, \"fifo read failed len=%d,errno=%s\\n\", len, strerror(errno));\n        return;\n    }\n    buf[len] = 0;\n    handle_command(buf);\n}\n\nstatic void prepare_cb(struct ev_loop *loop, struct ev_prepare *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    delay_manager.check();\n}\n\nint tun_dev_client_event_loop() {\n    // char data[buf_len];\n    // int len;\n    int i, j, k, ret;\n    int tun_fd;\n\n    int remote_fd;\n    fd64_t remote_fd64;\n\n    conn_info_t *conn_info_p = new conn_info_t;\n    conn_info_t &conn_info = *conn_info_p;  // huge size of conn_info,do not allocate on stack\n\n    tun_fd = get_tun_fd(tun_dev);\n    assert(tun_fd > 0);\n\n    assert(new_connected_socket2(remote_fd, remote_addr, out_addr, out_interface) == 0);\n    remote_fd64 = fd_manager.create(remote_fd);\n\n    assert(set_tun(tun_dev, htonl((ntohl(sub_net_uint32) & 0xFFFFFF00) | 2), htonl((ntohl(sub_net_uint32) & 0xFFFFFF00) | 1), tun_mtu) == 0);\n\n    tun_dest.type = type_write_fd;\n    tun_dest.inner.fd = tun_fd;\n\n    udp_dest.cook = 1;\n    udp_dest.type = type_fd64;\n    udp_dest.inner.fd64 = remote_fd64;\n\n    /// epoll_fd = epoll_create1(0);\n    /// assert(epoll_fd>0);\n\n    /// const int max_events = 4096;\n    /// struct epoll_event ev, events[max_events];\n    /// if (epoll_fd < 0) {\n    ///\tmylog(log_fatal,\"epoll return %d\\n\", epoll_fd);\n    ///\tmyexit(-1);\n    /// }\n\n    struct ev_loop *loop = ev_default_loop(0);\n    assert(loop != NULL);\n    conn_info.loop = loop;\n\n    /// ev.events = EPOLLIN;\n    /// ev.data.u64 = remote_fd64;\n    /// ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, remote_fd, &ev);\n    /// if (ret!=0) {\n    ///\tmylog(log_fatal,\"add  remote_fd64 error\\n\");\n    ///\tmyexit(-1);\n    /// }\n\n    struct ev_io remote_watcher;\n    remote_watcher.data = &conn_info;\n    remote_watcher.u64 = remote_fd64;\n\n    ev_io_init(&remote_watcher, remote_cb, remote_fd, EV_READ);\n    ev_io_start(loop, &remote_watcher);\n\n    /// ev.events = EPOLLIN;\n    /// ev.data.u64 = tun_fd;\n    /// ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, tun_fd, &ev);\n    /// if (ret!=0) {\n    ///\tmylog(log_fatal,\"add  tun_fd error\\n\");\n    ///\tmyexit(-1);\n    /// }\n\n    struct ev_io tun_fd_watcher;\n    tun_fd_watcher.data = &conn_info;\n\n    ev_io_init(&tun_fd_watcher, tun_fd_cb, tun_fd, EV_READ);\n    ev_io_start(loop, &tun_fd_watcher);\n\n    /// ev.events = EPOLLIN;\n    /// ev.data.u64 = delay_manager.get_timer_fd();\n\n    /// mylog(log_debug,\"delay_manager.get_timer_fd()=%d\\n\",delay_manager.get_timer_fd());\n    /// ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, delay_manager.get_timer_fd(), &ev);\n    /// if (ret!= 0) {\n    ///\tmylog(log_fatal,\"add delay_manager.get_timer_fd() error\\n\");\n    ///\tmyexit(-1);\n    /// }\n\n    delay_manager.set_loop_and_cb(loop, delay_manager_cb);\n\n    /// u64_t tmp_timer_fd64=conn_info.fec_encode_manager.get_timer_fd64();\n    /// ev.events = EPOLLIN;\n    /// ev.data.u64 = tmp_timer_fd64;\n\n    /// mylog(log_debug,\"conn_info.fec_encode_manager.get_timer_fd64()=%llu\\n\",conn_info.fec_encode_manager.get_timer_fd64());\n    /// ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd_manager.to_fd(tmp_timer_fd64), &ev);\n    /// if (ret!= 0) {\n    ///\tmylog(log_fatal,\"add fec_encode_manager.get_timer_fd64() error\\n\");\n    ///\tmyexit(-1);\n    /// }\n\n    conn_info.fec_encode_manager.set_data(&conn_info);\n    conn_info.fec_encode_manager.set_loop_and_cb(loop, fec_encode_cb);\n\n    // conn_info.timer.add_fd_to_epoll(epoll_fd);\n    //  conn_info.timer.data=&conn_info;\n\n    conn_info.timer.data = &conn_info;\n    ev_init(&conn_info.timer, conn_timer_cb);\n    ev_timer_set(&conn_info.timer, 0, timer_interval / 1000.0);\n    ev_timer_start(loop, &conn_info.timer);\n\n    struct ev_io fifo_watcher;\n\n    int fifo_fd = -1;\n\n    if (fifo_file[0] != 0) {\n        fifo_fd = create_fifo(fifo_file);\n        /// ev.events = EPOLLIN;\n        /// ev.data.u64 = fifo_fd;\n\n        /// ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fifo_fd, &ev);\n        /// if (ret!= 0) {\n        ///\tmylog(log_fatal,\"add fifo_fd to epoll error %s\\n\",strerror(errno));\n        ///\tmyexit(-1);\n        /// }\n        ev_io_init(&fifo_watcher, fifo_cb, fifo_fd, EV_READ);\n        ev_io_start(loop, &fifo_watcher);\n\n        mylog(log_info, \"fifo_file=%s\\n\", fifo_file);\n    }\n\n    ev_prepare prepare_watcher;\n    ev_init(&prepare_watcher, prepare_cb);\n    ev_prepare_start(loop, &prepare_watcher);\n\n    ev_run(loop, 0);\n\n    mylog(log_warn, \"ev_run returned\\n\");\n    myexit(0);\n\n    return 0;\n}\n"
        },
        {
          "name": "tun_dev_server.cpp",
          "type": "blob",
          "size": 9.83203125,
          "content": "#include \"tun_dev.h\"\n\nstatic dest_t udp_dest;\nstatic dest_t tun_dest;\n\nstatic void local_listen_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    char data[buf_len];\n    int len;\n\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    int local_listen_fd = watcher->fd;\n\n    // struct sockaddr_in udp_new_addr_in={0};\n    // socklen_t udp_new_addr_len = sizeof(sockaddr_in);\n    address_t::storage_t udp_new_addr_in = {0};\n    socklen_t udp_new_addr_len = sizeof(address_t::storage_t);\n\n    if ((len = recvfrom(local_listen_fd, data, max_data_len + 1, 0,\n                        (struct sockaddr *)&udp_new_addr_in, &udp_new_addr_len)) < 0) {\n        mylog(log_error, \"recv_from error,this shouldnt happen,err=%s,but we can try to continue\\n\", strerror(errno));\n        return;\n        // myexit(1);\n    };\n\n    address_t new_addr;\n    new_addr.from_sockaddr((struct sockaddr *)&udp_new_addr_in, udp_new_addr_len);\n\n    if (len == max_data_len + 1) {\n        mylog(log_warn, \"huge packet, data_len > %d,dropped\\n\", max_data_len);\n        return;\n    }\n\n    if (de_cook(data, len) < 0) {\n        mylog(log_warn, \"de_cook(data,len)failed \\n\");\n        return;\n    }\n\n    char header = 0;\n    if (get_header(header, data, len) != 0) {\n        mylog(log_warn, \"get_header() failed\\n\");\n        return;\n    }\n\n    if (udp_dest.inner.fd_addr.addr == new_addr) {\n        if (header == header_keep_alive) {\n            mylog(log_trace, \"got keep_alive packet\\n\");\n            return;\n        }\n\n        if (header != header_new_connect && header != header_normal) {\n            mylog(log_warn, \"invalid header\\n\");\n            return;\n        }\n    } else {\n        if (header == header_keep_alive) {\n            mylog(log_debug, \"got keep_alive packet from unexpected client\\n\");\n            return;\n        }\n\n        if (header == header_new_connect) {\n            mylog(log_info, \"new connection from %s\\n\", new_addr.get_str());\n            udp_dest.inner.fd_addr.addr = new_addr;\n            // udp_dest.inner.fd_ip_port.ip_port.ip=udp_new_addr_in.sin_addr.s_addr;\n            // udp_dest.inner.fd_ip_port.ip_port.port=ntohs(udp_new_addr_in.sin_port);\n            conn_info.fec_decode_manager.clear();\n            conn_info.fec_encode_manager.clear_data();\n            conn_info.stat.clear();\n        } else if (header == header_normal) {\n            mylog(log_debug, \"rejected connection from %s\\n\", new_addr.get_str());\n\n            len = 1;\n            data[0] = header_reject;\n            do_cook(data, len);\n\n            dest_t tmp_dest;\n            tmp_dest.type = type_fd_addr;\n\n            tmp_dest.inner.fd_addr.fd = local_listen_fd;\n            tmp_dest.inner.fd_addr.addr = new_addr;\n\n            delay_manager.add(0, tmp_dest, data, len);\n            ;\n            return;\n        } else {\n            mylog(log_warn, \"invalid header\\n\");\n        }\n    }\n\n    mylog(log_trace, \"Received packet from %s,len: %d\\n\", new_addr.get_str(), len);\n\n    from_fec_to_normal2(conn_info, tun_dest, data, len);\n}\nstatic void tun_fd_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    char data[buf_len];\n    int len;\n\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n    int tun_fd = watcher->fd;\n\n    len = read(tun_fd, data, max_data_len + 1);\n\n    if (len == max_data_len + 1) {\n        mylog(log_warn, \"huge packet, data_len > %d,dropped\\n\", max_data_len);\n        return;\n    }\n\n    if (len < 0) {\n        mylog(log_warn, \"read from tun_fd return %d,errno=%s\\n\", len, strerror(errno));\n        return;\n    }\n\n    do_mssfix(data, len);\n\n    mylog(log_trace, \"Received packet from tun,len: %d\\n\", len);\n\n    if (udp_dest.inner.fd_addr.addr.is_vaild() == 0) {\n        mylog(log_debug, \"received packet from tun,but there is no client yet,dropped packet\\n\");\n        return;\n    }\n\n    from_normal_to_fec2(conn_info, udp_dest, data, len, header_normal);\n}\n\nstatic void delay_manager_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    // do nothing\n}\n\nstatic void fec_encode_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    mylog(log_trace, \"fec_encode_cb() called\\n\");\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    assert(udp_dest.inner.fd_addr.addr.is_vaild() != 0);\n    /// mylog(log_trace,\"events[idx].data.u64 == conn_info.fec_encode_manager.get_timer_fd64()\\n\");\n    /// uint64_t fd64=events[idx].data.u64;\n    /// uint64_t value;\n    /// if(!fd_manager.exist(fd64))   //fd64 has been closed\n    ///{\n    ///\tmylog(log_trace,\"!fd_manager.exist(fd64)\");\n    ///\tcontinue;\n    /// }\n    /// if((ret=read(fd_manager.to_fd(fd64), &value, 8))!=8)\n    ///{\n    ///\tmylog(log_trace,\"(ret=read(fd_manager.to_fd(fd64), &value, 8))!=8,ret=%d\\n\",ret);\n    ///\tcontinue;\n    /// }\n    /// if(value==0)\n    ///{\n    ///\tmylog(log_debug,\"value==0\\n\");\n    ///\tcontinue;\n    /// }\n    /// assert(value==1);\n\n    from_normal_to_fec2(conn_info, udp_dest, 0, 0, header_normal);\n}\n\nstatic void fifo_cb(struct ev_loop *loop, struct ev_io *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n    int fifo_fd = watcher->fd;\n\n    char buf[buf_len];\n    int len = read(fifo_fd, buf, sizeof(buf));\n    if (len < 0) {\n        mylog(log_warn, \"fifo read failed len=%d,errno=%s\\n\", len, strerror(errno));\n        return;\n    }\n    buf[len] = 0;\n    handle_command(buf);\n}\n\nstatic void conn_timer_cb(struct ev_loop *loop, struct ev_timer *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    conn_info_t &conn_info = *((conn_info_t *)watcher->data);\n\n    mylog(log_trace, \"conn_timer_cb() called\\n\");\n\n    // uint64_t value;\n    // read(conn_info.timer.get_timer_fd(), &value, 8);\n\n    if (udp_dest.inner.fd_addr.addr.is_vaild() == 0) {\n        return;\n    }\n    conn_info.stat.report_as_server(udp_dest.inner.fd_addr.addr);\n    do_keep_alive(udp_dest);\n}\n\nstatic void prepare_cb(struct ev_loop *loop, struct ev_prepare *watcher, int revents) {\n    assert(!(revents & EV_ERROR));\n\n    delay_manager.check();\n}\n\nint tun_dev_server_event_loop() {\n    int i, j, k, ret;\n    int tun_fd;\n    int local_listen_fd;\n\n    conn_info_t *conn_info_p = new conn_info_t;\n    conn_info_t &conn_info = *conn_info_p;  // huge size of conn_info,do not allocate on stack\n\n    tun_fd = get_tun_fd(tun_dev);\n    assert(tun_fd > 0);\n\n    assert(new_listen_socket2(local_listen_fd, local_addr) == 0);\n    assert(set_tun(tun_dev, htonl((ntohl(sub_net_uint32) & 0xFFFFFF00) | 1), htonl((ntohl(sub_net_uint32) & 0xFFFFFF00) | 2), tun_mtu) == 0);\n\n    udp_dest.cook = 1;\n    udp_dest.type = type_fd_addr;\n\n    udp_dest.inner.fd_addr.fd = local_listen_fd;\n    udp_dest.inner.fd_addr.addr.clear();\n\n    tun_dest.type = type_write_fd;\n    tun_dest.inner.fd = tun_fd;\n\n    /// epoll_fd = epoll_create1(0);\n    /// assert(epoll_fd>0);\n\n    /// const int max_events = 4096;\n    /// struct epoll_event ev, events[max_events];\n    /// if (epoll_fd < 0) {\n    ///\tmylog(log_fatal,\"epoll return %d\\n\", epoll_fd);\n    ///\tmyexit(-1);\n    /// }\n\n    struct ev_loop *loop = ev_default_loop(0);\n    assert(loop != NULL);\n    conn_info.loop = loop;\n\n    /// ev.events = EPOLLIN;\n    /// ev.data.u64 = local_listen_fd;\n    /// ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, local_listen_fd, &ev);\n    /// if (ret!=0) {\n    ///\tmylog(log_fatal,\"add  udp_listen_fd error\\n\");\n    ///\tmyexit(-1);\n    /// }\n\n    struct ev_io local_listen_watcher;\n    local_listen_watcher.data = &conn_info;\n    ev_io_init(&local_listen_watcher, local_listen_cb, local_listen_fd, EV_READ);\n    ev_io_start(loop, &local_listen_watcher);\n\n    /// ev.events = EPOLLIN;\n    /// ev.data.u64 = tun_fd;\n    /// ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, tun_fd, &ev);\n    /// if (ret!=0) {\n    ///\tmylog(log_fatal,\"add  tun_fd error\\n\");\n    ///\tmyexit(-1);\n    /// }\n\n    struct ev_io tun_fd_watcher;\n    tun_fd_watcher.data = &conn_info;\n\n    ev_io_init(&tun_fd_watcher, tun_fd_cb, tun_fd, EV_READ);\n    ev_io_start(loop, &tun_fd_watcher);\n\n    /// ev.events = EPOLLIN;\n    /// ev.data.u64 = delay_manager.get_timer_fd();\n\n    /// mylog(log_debug,\"delay_manager.get_timer_fd()=%d\\n\",delay_manager.get_timer_fd());\n    /// ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, delay_manager.get_timer_fd(), &ev);\n    /// if (ret!= 0) {\n    ///\tmylog(log_fatal,\"add delay_manager.get_timer_fd() error\\n\");\n    ///\tmyexit(-1);\n    /// }\n\n    delay_manager.set_loop_and_cb(loop, delay_manager_cb);\n\n    /// u64_t tmp_timer_fd64=conn_info.fec_encode_manager.get_timer_fd64();\n    /// ev.events = EPOLLIN;\n    /// ev.data.u64 = tmp_timer_fd64;\n\n    /// mylog(log_debug,\"conn_info.fec_encode_manager.get_timer_fd64()=%llu\\n\",conn_info.fec_encode_manager.get_timer_fd64());\n    /// ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd_manager.to_fd(tmp_timer_fd64), &ev);\n    /// if (ret!= 0) {\n    ///\tmylog(log_fatal,\"add fec_encode_manager.get_timer_fd64() error\\n\");\n    ///\tmyexit(-1);\n    /// }\n\n    conn_info.fec_encode_manager.set_data(&conn_info);\n    conn_info.fec_encode_manager.set_loop_and_cb(loop, fec_encode_cb);\n\n    /// conn_info.timer.add_fd_to_epoll(epoll_fd);\n    /// conn_info.timer.set_timer_repeat_us(timer_interval*1000);\n\n    conn_info.timer.data = &conn_info;\n    ev_init(&conn_info.timer, conn_timer_cb);\n    ev_timer_set(&conn_info.timer, 0, timer_interval / 1000.0);\n    ev_timer_start(loop, &conn_info.timer);\n\n    struct ev_io fifo_watcher;\n    int fifo_fd = -1;\n\n    if (fifo_file[0] != 0) {\n        fifo_fd = create_fifo(fifo_file);\n\n        ev_io_init(&fifo_watcher, fifo_cb, fifo_fd, EV_READ);\n        ev_io_start(loop, &fifo_watcher);\n\n        mylog(log_info, \"fifo_file=%s\\n\", fifo_file);\n    }\n\n    ev_prepare prepare_watcher;\n    ev_init(&prepare_watcher, prepare_cb);\n    ev_prepare_start(loop, &prepare_watcher);\n\n    mylog(log_info, \"now listening at %s\\n\", local_addr.get_str());\n\n    ev_run(loop, 0);\n\n    mylog(log_warn, \"ev_run returned\\n\");\n    myexit(0);\n\n    return 0;\n}\n"
        }
      ]
    }
  ]
}