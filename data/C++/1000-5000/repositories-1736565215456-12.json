{
  "metadata": {
    "timestamp": 1736565215456,
    "page": 12,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "NVIDIA/thrust",
      "stars": 4940,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 2.48828125,
          "content": "BasedOnStyle: LLVM\nAccessModifierOffset: -2\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: true\nAlignEscapedNewlines: Right\nAlignOperands: true\nAllowAllArgumentsOnNextLine: false\nAllowAllConstructorInitializersOnNextLine: false\nAllowAllParametersOfDeclarationOnNextLine: false\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: All\nAllowShortIfStatementsOnASingleLine: Never\nAllowShortLambdasOnASingleLine: All\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterReturnType: None\nAlwaysBreakTemplateDeclarations: Yes\nBinPackArguments: false\nBinPackParameters: false\nBreakBeforeBraces: Custom\nBraceWrapping:\n  AfterCaseLabel: false\n  AfterClass: true\n  AfterControlStatement: true\n  AfterEnum: true\n  AfterFunction: true\n  AfterNamespace: true\n  AfterStruct: true\n  AfterUnion: true\n  BeforeCatch: true\n  BeforeElse: true\n  IndentBraces: false\n  SplitEmptyFunction: false\n  SplitEmptyRecord: false\nBreakBeforeBinaryOperators: None\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializers: BeforeComma\nBreakInheritanceList: BeforeComma\nColumnLimit: 100\nCompactNamespaces: false\nContinuationIndentWidth: 2\nIncludeBlocks:   Regroup\nIncludeCategories:\n  - Regex:           '^<cub'\n    Priority:        1\n  - Regex:           '^<thrust'\n    Priority:        2\n  - Regex:           '^<cuda'\n    Priority:        3\n  - Regex:           '^<[a-z]*>$'\n    Priority:        4\n  - Regex:           '^<unittest'\n    Priority:        5    \n  - Regex:           '.*'\n    Priority:        6\nIndentCaseLabels: true\nIndentPPDirectives: None\nIndentWidth: 2\nKeepEmptyLinesAtTheStartOfBlocks: true\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nPenaltyBreakAssignment: 30\nPenaltyBreakBeforeFirstCallParameter: 50\nPenaltyBreakComment: 0\nPenaltyBreakFirstLessLess: 0\nPenaltyBreakString: 70\nPenaltyBreakTemplateDeclaration: 0\nPenaltyExcessCharacter: 100\nPenaltyReturnTypeOnItsOwnLine: 90\nPointerAlignment: Right\nReflowComments: true\nSortIncludes: CaseInsensitive\nSpaceAfterCStyleCast: false\nSpaceAfterLogicalNot: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeCpp11BracedList: false\nSpaceBeforeCtorInitializerColon: true\nSpaceBeforeInheritanceColon: true\nSpaceBeforeParens: ControlStatements\nSpaceBeforeRangeBasedForLoopColon: true\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 1\nSpacesInAngles: false\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard: c++11\nTabWidth: 2\nUseTab: Never\n"
        },
        {
          "name": ".git-blame-ignore-revs",
          "type": "blob",
          "size": 0.431640625,
          "content": "# Exclude these commits from git-blame and similar tools.\n#\n# To use this file, run the following command from the repo root:\n#\n# ```\n# $ git config blame.ignoreRevsFile .git-blame-ignore-revs\n# ```\n#\n# Include a brief comment with each commit added, for example:\n#\n# ```\n# d92d9f8baac5ec48a8f8718dd69f415a45efe372 # Initial clang-format\n# ```\n#\n# Only add commits that are pure formatting changes (e.g.\n# clang-format version changes, etc).\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0439453125,
          "content": "discrete_voronoi.pgm\n*build*/\n.idea/\n.vscode\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.1396484375,
          "content": "[submodule \"cub\"]\n\tpath = dependencies/cub\n\turl = ../cub.git\n[submodule \"libcudacxx\"]\n\tpath = dependencies/libcudacxx\n\turl = ../libcudacxx.git\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 98.2529296875,
          "content": "# Changelog\n\n## Thrust 2.1.0\n\n### New Features\n\n- NVIDIA/thrust#1805: Add default constructors to `transform_output_iterator`\n  and `transform_input_output_iterator`. Thanks to Mark Harris (@harrism) for this contribution.\n- NVIDIA/thrust#1836: Enable constructions of vectors from `std::initializer_list`.\n\n### Bug Fixes\n\n- NVIDIA/thrust#1768: Fix type conversion warning in the `thrust::complex` utilities. Thanks to\n  Zishi Wu (@zishiwu123) for this contribution.\n- NVIDIA/thrust#1809: Fix some warnings about usage of `__host__` functions in `__device__` code.\n- NVIDIA/thrust#1825: Fix Thrust's CMake install rules. Thanks to Robert Maynard (@robertmaynard)\n  for this contribution.\n- NVIDIA/thrust#1827: Fix `thrust::reduce_by_key` when using non-default-initializable iterators.\n- NVIDIA/thrust#1832: Fix bug in device-side CDP `thrust::reduce` when using a large number of\n  inputs.\n\n### Other Enhancements\n\n- NVIDIA/thrust#1815: Update Thrust's libcu++ git submodule to version 1.8.1.\n- NVIDIA/thrust#1841: Fix invalid code in execution policy documentation example. Thanks to Raphaël\n  Frantz (@Eren121) for this contribution.\n- NVIDIA/thrust#1848: Improve error messages when attempting to launch a kernel on a device that is\n  not supported by compiled PTX versions. Thanks to Zahra Khatami (@zkhatami) for this contribution.\n- NVIDIA/thrust#1855: Remove usage of deprecated CUDA error codes.\n\n## Thrust 2.0.1\n\n### Other Enhancements\n\n- Disable CDP parallelization of device-side invocations of Thrust algorithms on SM90+. The removal\n  of device-side synchronization support in recent architectures makes Thrust's fork-join model\n  unimplementable on device, so a serial implementation will be used instead. Host-side invocations\n  of Thrust algorithms are not affected.\n\n## Thrust 2.0.0\n\n### Summary\n\nThe Thrust 2.0.0 major release adds a dependency on libcu++ and contains several\nbreaking changes. These include new diagnostics when inspecting device-only\nlambdas from the host, removal of the `cub` symlink in the Thrust repository\nroot, and removal of the deprecated `THRUST_*_BACKEND` macros. It also includes\nseveral minor bugfixes and cleanups.\n\n### Breaking Changes\n\n- NVIDIA/thrust#1605: Add libcu++ dependency.\n    - A suitable version of libcu++ is provided through\n      the `${THRUST_ROOT}/dependencies/libcudacxx/` submodule.\n    - Non-cmake users may need to add the libcu++ include path to their\n      builds (`-I ${THRUST_ROOT}/dependencies/libcudacxx/include/`).\n    - The Thrust CMake packages have been updated to add this include path.\n- NVIDIA/thrust#1605: The following macros are no longer defined by default.\n  They can be re-enabled by defining `THRUST_PROVIDE_LEGACY_ARCH_MACROS`. These\n  will be removed completely in a future release.\n    - `THRUST_IS_HOST_CODE`: Replace with `NV_IF_TARGET`.\n    - `THRUST_IS_DEVICE_CODE`: Replace with `NV_IF_TARGET`.\n    - `THRUST_INCLUDE_HOST_CODE`: Replace with `NV_IF_TARGET`.\n    - `THRUST_INCLUDE_DEVICE_CODE`: Replace with `NV_IF_TARGET`.\n    - `THRUST_DEVICE_CODE`: Replace with `NV_IF_TARGET`.\n- NVIDIA/thrust#1661: Thrust's CUDA Runtime support macros have been updated to\n  support `NV_IF_TARGET`. They are now defined consistently across all\n  host/device compilation passes. This should not affect most usages of these\n  macros, but may require changes for some edge cases.\n    - `THRUST_RUNTIME_FUNCTION`: Execution space annotations for functions that\n      invoke CUDA Runtime APIs.\n        - Old behavior:\n            - RDC enabled: Defined to `__host__ __device__`\n            - RDC not enabled:\n                - NVCC host pass: Defined to `__host__ __device__`\n                - NVCC device pass: Defined to `__host__`\n        - New behavior:\n            - RDC enabled: Defined to `__host__ __device__`\n            - RDC not enabled: Defined to `__host__`\n    - `__THRUST_HAS_CUDART__`: No change in behavior, but no longer used in\n      Thrust. Provided for legacy support only. Legacy behavior:\n        - RDC enabled: Defined to 1.\n        - RDC not enabled:\n            - NVCC host pass: Defined to 1.\n            - NVCC device pass: Defined to 0.\n    - `THRUST_RDC_ENABLED`: New macro, may be combined with `NV_IF_TARGET` to\n      replace most usages of `__THRUST_HAS_CUDART__`. Behavior:\n        - RDC enabled: Macro is defined.\n        - RDC not enabled: Macro is not defined.\n- NVIDIA/thrust#1701: Remove the `cub` symlink from the root of the Thrust\n  repository.\n    - This symlink caused issues in certain build environments (e.g.\n      NVIDIA/thrust#1328).\n    - Builds that relied on this symlink will need to add the full CUB include\n      path (`-I ${THRUST_ROOT}/dependencies/cub`).\n    - CMake builds that use the Thrust packages via CPM, `add_subdirectory`,\n      or `find_package` are not affected.\n- NVIDIA/thrust#1760: A compile-time error is now emitted when a `__device__`\n  -only lambda's return type is queried from host code (requires libcu++ ≥\n  1.9.0).\n    - Due to limitations in the CUDA programming model, the result of this query\n      is unreliable, and will silently return an incorrect result. This leads to\n      difficult to debug errors.\n    - When using libcu++ 1.9.0, an error will be emitted with information about\n      work-arounds:\n        - Use a named function object with a `__device__`-only implementation\n          of `operator()`.\n        - Use a `__host__ __device__` lambda.\n        - Use `cuda::proclaim_return_type` (Added in libcu++ 1.9.0)\n- NVIDIA/thrust#1761: Removed support for deprecated `THRUST_DEVICE_BACKEND`\n  and `THRUST_HOST_BACKEND` macros. The `THRUST_DEVICE_SYSTEM`\n  and `THRUST_HOST_SYSTEM` macros should be used instead.\n\n### Bug Fixes\n\n- NVIDIA/thrust#1605: Fix some execution space warnings in the allocator\n  library.\n- NVIDIA/thrust#1683: Fix bug in `iterator_category_to_traversal` metafunctions.\n- NVIDIA/thrust#1715: Add missing `__thrust_exec_check_disable__` annotation\n  to `thrust::make_zip_function`. Thanks to @mfbalin for this contribution.\n- NVIDIA/thrust#1722: Remove CUDA-specific error handler from code that may be\n  executed on non-CUDA backends. Thanks to @dkolsen-pgi for this contribution.\n- NVIDIA/thrust#1756: Fix `copy_if` for output iterators that don't support copy\n  assignment. Thanks for @mfbalin for this contribution.\n\n### Other Enhancements\n\n- NVIDIA/thrust#1605: Removed special case code for unsupported CUDA\n  architectures.\n- NVIDIA/thrust#1605: Replace several usages of `__CUDA_ARCH__`\n  with `<nv/target>` to handle host/device code divergence.\n- NVIDIA/thrust#1752: Remove a leftover merge conflict from a documentation\n  file. Thanks to @tabedzki for this contribution.\n\n## Thrust 1.17.2\n\n### Summary\n\nThrust 1.17.2 is a minor bugfix release that provides an updated version of CUB.\n\n## Thrust 1.17.1\n\n### Summary\n\nThrust 1.17.1 is a minor bugfix release that provides an updated version of CUB.\n\n## Thrust 1.17.0\n\n### Summary\n\nThrust 1.17.0 is the final minor release of the 1.X series. This release\nprovides GDB pretty-printers for device vectors/references, a new `unique_count`\nalgorithm, and an easier way to create tagged Thrust iterators. Several\ndocumentation fixes are included, which can be found on the new Thrust\ndocumentation site at https://nvidia.github.io/thrust. We'll be migrating\nexisting documentation sources to this new location over the next few months.\n\n### New Features\n\n- NVIDIA/thrust#1586: Add new `thrust::make_tagged_iterator` convenience\n  function. Thanks to @karthikeyann for this contribution.\n- NVIDIA/thrust#1619: Add `unique_count` algorithm. Thanks to @upsj for this\n  contribution.\n- NVIDIA/thrust#1631: Add GDB pretty-printers for device vectors/references\n  to `scripts/gdb-pretty-printers.py`. Thanks to @upsj for this contribution.\n\n### Bug Fixes\n\n- NVIDIA/thrust#1671: Fixed `reduce_by_key` when called with 2^31 elements.\n\n### Other Enhancements\n\n- NVIDIA/thrust#1512: Use CUB to implement `adjacent_difference`.\n- NVIDIA/thrust#1555: Use CUB to implement `scan_by_key`.\n- NVIDIA/thrust#1611: Add new doxybook-based Thrust documentation\n  at https://nvidia.github.io/thrust.\n- NVIDIA/thrust#1639: Fixed broken link in documentation. Thanks to @jrhemstad\n  for this contribution.\n- NVIDIA/thrust#1644: Increase contrast of search input text in new doc site.\n  Thanks to @bdice for this contribution.\n- NVIDIA/thrust#1647: Add `__forceinline__` annotations to a functor wrapper.\n  Thanks to @mkuron for this contribution.\n- NVIDIA/thrust#1660: Fixed typo in documentation example for\n  `permutation_iterator`.\n- NVIDIA/thrust#1669: Add a new `explicit_cuda_stream.cu` example that shows how\n  to use explicit CUDA streams and `par`/`par_nosync` execution policies.\n\n## Thrust 1.16.0\n\n### Summary\n\nThrust 1.16.0 provides a new “nosync” hint for the CUDA backend, as well as\nnumerous bugfixes and stability improvements.\n\n#### New `thrust::cuda::par_nosync` Execution Policy\n\nMost of Thrust's parallel algorithms are fully synchronous and will block the\ncalling CPU thread until all work is completed. This design avoids many pitfalls\nassociated with asynchronous GPU programming, resulting in simpler and\nless-error prone usage for new CUDA developers. Unfortunately, this improvement\nin user experience comes at a performance cost that often frustrates more\nexperienced CUDA programmers.\n\nPrior to this release, the only synchronous-to-asynchronous migration path for\nexisting Thrust codebases involved significant refactoring, replacing calls\nto `thrust` algorithms with a limited set of `future`-based `thrust::async`\nalgorithms or lower-level CUB kernels. The new `thrust::cuda::par_nosync`\nexecution policy provides a new, less-invasive entry point for asynchronous\ncomputation.\n\n`par_nosync` is a hint to the Thrust execution engine that any non-essential\ninternal synchronizations should be skipped and that an explicit synchronization\nwill be performed by the caller before accessing results.\n\nWhile some Thrust algorithms require internal synchronization to safely compute\ntheir results, many do not. For example, multiple `thrust::for_each` invocations\ncan be launched without waiting for earlier calls to complete:\n\n```cpp\n// Queue three `for_each` kernels:\nthrust::for_each(thrust::cuda::par_nosync, vec1.begin(), vec1.end(), Op{});\nthrust::for_each(thrust::cuda::par_nosync, vec2.begin(), vec2.end(), Op{});\nthrust::for_each(thrust::cuda::par_nosync, vec3.begin(), vec3.end(), Op{});\n\n// Do other work while kernels execute:\ndo_something();\n\n// Must explictly synchronize before accessing `for_each` results:\ncudaDeviceSynchronize();\n```\n\nThanks to @fkallen for this contribution.\n\n### Deprecation Notices\n\n#### CUDA Dynamic Parallelism Support\n\n**A future version of Thrust will remove support for CUDA Dynamic Parallelism\n(CDP).**\n\nThis will only affect calls to Thrust algorithms made from CUDA device-side code\nthat currently launches a kernel; such calls will instead execute sequentially\non the calling GPU thread instead of launching a device-wide kernel.\n\n### Breaking Changes\n\n- Thrust 1.14.0 included a change that aliased the `cub` namespace\n  to `thrust::cub`. This has caused issues with ambiguous namespaces for\n  projects that declare `using namespace thrust;` from the global namespace. We\n  recommend against this practice.\n- NVIDIA/thrust#1572: Removed several unnecessary header includes. Downstream\n  projects may need to update their includes if they were relying on this\n  behavior.\n\n### New Features\n\n- NVIDIA/thrust#1568: Add `thrust::cuda::par_nosync` policy. Thanks to @fkallen\n  for this contribution.\n\n### Enhancements\n\n- NVIDIA/thrust#1511: Use CUB's new `DeviceMergeSort` API and remove Thrust's\n  internal implementation.\n- NVIDIA/thrust#1566: Improved performance of `thrust::shuffle`. Thanks to\n  @djns99 for this contribution.\n- NVIDIA/thrust#1584: Support user-defined `CMAKE_INSTALL_INCLUDEDIR` values in\n  Thrust's CMake install rules. Thanks to @robertmaynard for this contribution.\n\n### Bug Fixes\n\n- NVIDIA/thrust#1496: Fix some issues affecting `icc` builds.\n- NVIDIA/thrust#1552: Fix some collisions with the `min`/`max`  macros defined\n  in `windows.h`.\n- NVIDIA/thrust#1582: Fix issue with function type alias on 32-bit MSVC builds.\n- NVIDIA/thrust#1591: Workaround issue affecting compilation with `nvc++`.\n- NVIDIA/thrust#1597: Fix some collisions with the `small` macro defined\n  in `windows.h`.\n- NVIDIA/thrust#1599, NVIDIA/thrust#1603: Fix some issues with version handling\n  in Thrust's CMake packages.\n- NVIDIA/thrust#1614: Clarify that scan algorithm results are non-deterministic\n  for pseudo-associative operators (e.g. floating-point addition).\n\n## Thrust 1.15.0\n\n### Summary\n\nThrust 1.15.0 provides numerous bugfixes, including non-numeric\n`thrust::sequence` support, several MSVC-related compilation fixes, fewer\nconversion warnings, `counting_iterator` initialization, and documentation\nupdates.\n\n### Deprecation Notices\n\n**A future version of Thrust will remove support for CUDA Dynamic Parallelism\n(CDP).**\n\nThis will only affect calls to Thrust algorithms made from CUDA device-side code\nthat currently launches a kernel; such calls will instead execute sequentially\non the calling GPU thread instead of launching a device-wide kernel.\n\n### Bug Fixes\n\n- NVIDIA/thrust#1507: Allow `thrust::sequence` to work with non-numeric types.\n  Thanks to Ben Jude (@bjude) for this contribution.\n- NVIDIA/thrust#1509: Avoid macro collision when calling `max()` on MSVC. Thanks\n  to Thomas (@tomintheshell) for this contribution.\n- NVIDIA/thrust#1514: Initialize all members in `counting_iterator`'s default\n  constructor.\n- NVIDIA/thrust#1518: Fix `std::allocator_traits` on MSVC + C++17.\n- NVIDIA/thrust#1530: Fix several `-Wconversion` warnings. Thanks to Matt\n  Stack (@matt-stack) for this contribution.\n- NVIDIA/thrust#1539: Fixed typo in `thrust::for_each` documentation. Thanks to\n  Salman (@untamedImpala) for this contribution.\n- NVIDIA/thrust#1548: Avoid name collision with `B0` macro in termios.h system\n  header. Thanks to Philip Deegan (@PhilipDeegan) for this contribution.\n\n## Thrust 1.14.0 (NVIDIA HPC SDK 21.9)\n\nThrust 1.14.0 is a major release accompanying the NVIDIA HPC SDK 21.9.\n\nThis release adds the ability to wrap the `thrust::` namespace in an external\nnamespace, providing a workaround for a variety of shared library linking\nissues. Thrust also learned to detect when CUB's symbols are in a wrapped\nnamespace and properly import them. To enable this feature, use\n`#define THRUST_CUB_WRAPPED_NAMESPACE foo` to wrap both Thrust and CUB in the\n`foo::` namespace. See `thrust/detail/config/namespace.h` for details and more\nnamespace options.\n\nSeveral bugfixes are also included: The `tuple_size` and `tuple_element` helpers\nnow support cv-qualified types. `scan_by_key` uses less memory.\n`thrust::iterator_traits` is better integrated with `std::iterator_traits`.\nSee below for more details and references.\n\n### Breaking Changes\n\n- Thrust 1.14.0 included a change that aliased the `cub` namespace\n  to `thrust::cub`. This has caused issues with ambiguous namespaces for\n  projects that declare `using namespace thrust;` from the global namespace. We\n  recommend against this practice.\n\n### New Features\n\n- NVIDIA/thrust#1464: Add preprocessor hooks that allow `thrust::` to be wrapped\n  in an external namespace, and support cases when CUB is wrapped in an external\n  namespace.\n\n### Bug Fixes\n\n- NVIDIA/thrust#1457: Support cv-qualified types in `thrust::tuple_size` and\n  `thrust::tuple_element`. Thanks to Jake Hemstad for this contribution.\n- NVIDIA/thrust#1471: Fixed excessive memory allocation in `scan_by_key`. Thanks\n  to Lilo Huang for this contribution.\n- NVIDIA/thrust#1476: Removed dead code from the `expand` example. Thanks to\n  Lilo Huang for this contribution.\n- NVIDIA/thrust#1488: Fixed the path to the installed CUB headers in the CMake\n  `find_package` configuration files.\n- NVIDIA/thrust#1491: Fallback to `std::iterator_traits` when no\n  `thrust::iterator_traits` specialization exists for an iterator type. Thanks\n  to Divye Gala for this contribution.\n\n## Thrust 1.13.1 (CUDA Toolkit 11.5)\n\nThrust 1.13.1 is a minor release accompanying the CUDA Toolkit 11.5.\n\nThis release provides a new hook for embedding the `thrust::` namespace inside a\ncustom namespace. This is intended to work around various issues related to\nlinking multiple shared libraries that use Thrust. The existing `CUB_NS_PREFIX`\nand `CUB_NS_POSTFIX` macros already provided this capability for CUB; this\nupdate provides a simpler mechanism that is extended to and integrated with\nThrust. Simply define `THRUST_CUB_WRAPPED_NAMESPACE` to a namespace name, and\nboth `thrust::` and `cub::` will be placed inside the new namespace. Using\ndifferent wrapped namespaces for each shared library will prevent issues like\nthose reported in NVIDIA/thrust#1401.\n\n### New Features\n\n- NVIDIA/thrust#1464: Add `THRUST_CUB_WRAPPED_NAMESPACE` hooks.\n\n### Bug Fixes\n\n- NVIDIA/thrust#1488: Fix path to installed CUB in Thrust's CMake config files.\n\n## Thrust 1.13.0 (NVIDIA HPC SDK 21.7)\n\nThrust 1.13.0 is the major release accompanying the NVIDIA HPC SDK 21.7 release.\nNotable changes include `bfloat16` radix sort support (via `thrust::sort`) and\n  memory handling fixes in the `reserve` method of Thrust's vectors.\nThe `CONTRIBUTING.md` file has been expanded to include instructions for\n  building CUB as a component of Thrust, and API documentation now refers to\n  [cppreference](https://cppreference.com) instead of SGI's old STL reference.\n\n### Breaking Changes\n\n- NVIDIA/thrust#1459: Remove deprecated aliases `thrust::host_space_tag` and\n  `thrust::device_space_tag`. Use the equivalent `thrust::host_system_tag` and\n  `thrust::device_system_tag` instead.\n\n### New Features\n\n- NVIDIA/cub#306: Add radix-sort support for `bfloat16` in `thrust::sort`.\n  Thanks to Xiang Gao (@zasdfgbnm) for this contribution.\n- NVIDIA/thrust#1423: `thrust::transform_iterator` now supports non-copyable\n  types. Thanks to Jake Hemstad (@jrhemstad) for this contribution.\n- NVIDIA/thrust#1459: Introduce a new `THRUST_IGNORE_DEPRECATED_API` macro that\n  disables deprecation warnings on Thrust and CUB APIs.\n\n### Bug Fixes\n\n- NVIDIA/cub#277: Fixed sanitizer warnings when `thrust::sort` calls\n  into `cub::DeviceRadixSort`. Thanks to Andy Adinets (@canonizer) for this\n  contribution.\n- NVIDIA/thrust#1442: Reduce extraneous comparisons in `thrust::sort`'s merge\n  sort implementation.\n- NVIDIA/thrust#1447: Fix memory leak and avoid overallocation when\n  calling `reserve` on Thrust's vector containers. Thanks to Kai Germaschewski\n  (@germasch) for this contribution.\n\n### Other Enhancements\n\n- NVIDIA/thrust#1405: Update links to standard C++ documentations from sgi to\n  cppreference. Thanks to Muhammad Adeel Hussain (@AdeilH) for this\n  contribution.\n- NVIDIA/thrust#1432: Updated build instructions in `CONTRIBUTING.md` to include\n  details on building CUB's test suite as part of Thrust.\n\n## Thrust 1.12.1 (CUDA Toolkit 11.4)\n\nThrust 1.12.1 is a trivial patch release that slightly changes the phrasing of\na deprecation message.\n\n## Thrust 1.12.0 (NVIDIA HPC SDK 21.3)\n\nThrust 1.12.0 is the major release accompanying the NVIDIA HPC SDK 21.3\n  and the CUDA Toolkit 11.4.\nIt includes a new `thrust::universal_vector`, which holds data that is\n  accessible from both host and device. This allows users to easily leverage\n  CUDA's unified memory with Thrust.\nNew asynchronous `thrust::async:exclusive_scan` and `inclusive_scan` algorithms\n  have been added, and the synchronous versions of these have been updated to\n  use `cub::DeviceScan` directly.\nCUB radix sort for floating point types is now stable when both +0.0 and -0.0\n  are present in the input. This affects some usages of `thrust::sort` and\n  `thrust::stable_sort`.\nMany compilation warnings and subtle overflow bugs were fixed in the device\n  algorithms, including a long-standing bug that returned invalid temporary\n  storage requirements when `num_items` was close to (but not\n  exceeding) `INT32_MAX`.\nThis release deprecates support for Clang < 7.0 and MSVC < 2019 (aka\n  19.20/16.0/14.20).\n\n### Breaking Changes\n\n- NVIDIA/thrust#1372: Deprecate Clang < 7 and MSVC < 2019.\n- NVIDIA/thrust#1376: Standardize `thrust::scan_by_key` functors / accumulator\n    types.\n  This may change the results from `scan_by_key` when input, output, and\n    initial value types are not the same type.\n\n### New Features\n\n- NVIDIA/thrust#1251: Add two new `thrust::async::` algorithms: `inclusive_scan`\n    and `exclusive_scan`.\n- NVIDIA/thrust#1334: Add `thrust::universal_vector`, `universal_ptr`,\n    and `universal_allocator`.\n\n### Bug Fixes\n\n- NVIDIA/thrust#1347: Qualify calls to `make_reverse_iterator`.\n- NVIDIA/thrust#1359: Enable stricter warning flags. This fixes several\n  outstanding issues:\n  - NVIDIA/cub#221: Overflow in `temp_storage_bytes` when `num_items` close to\n      (but not over) `INT32_MAX`.\n  - NVIDIA/cub#228: CUB uses non-standard C++ extensions that break strict\n      compilers.\n  - NVIDIA/cub#257: Warning when compiling `GridEvenShare` with unsigned\n      offsets.\n  - NVIDIA/thrust#974: Conversion warnings in `thrust::transform_reduce`.\n  - NVIDIA/thrust#1091: Conversion warnings in `thrust::counting_iterator`.\n- NVIDIA/thrust#1373: Fix compilation error when a standard library type is\n    wrapped in `thrust::optional`.\n  Thanks to Vukasin Milovanovic for this contribution.\n- NVIDIA/thrust#1388: Fix `signbit(double)` implementation on MSVC.\n- NVIDIA/thrust#1389: Support building Thrust tests without CUDA enabled.\n\n### Other Enhancements\n\n- NVIDIA/thrust#1304: Use `cub::DeviceScan` to implement\n    `thrust::exclusive_scan` and `thrust::inclusive_scan`.\n- NVIDIA/thrust#1362, NVIDIA/thrust#1370: Update smoke test naming.\n- NVIDIA/thrust#1380: Fix typos in `set_operation` documentation.\n    Thanks to Hongyu Cai for this contribution.\n- NVIDIA/thrust#1383: Include FreeBSD license in LICENSE.md for\n  `thrust::complex` implementation.\n- NVIDIA/thrust#1384: Add missing precondition to `thrust::gather`\n    documentation.\n\n## Thrust 1.11.0 (CUDA Toolkit 11.3)\n\nThrust 1.11.0 is a major release providing bugfixes and performance\n  enhancements.\nIt includes a new sort algorithm that provides up to 2x more performance\n  from `thrust::sort` when used with certain key types and hardware.\nThe new `thrust::shuffle` algorithm has been tweaked to improve the randomness\n  of the output.\nOur CMake package and build system continue to see improvements with\n  better `add_subdirectory` support, installation rules, status messages, and\n  other features that make Thrust easier to use from CMake projects.\nThe release includes several other bugfixes and modernizations, and received\n  updates from 12 contributors.\n\n### New Features\n\n- NVIDIA/cub#204: New implementation for `thrust::sort` on CUDA when using\n    32/64-bit numeric keys on Pascal and up (SM60+).\n  This improved radix sort algorithm provides up to 2x more performance.\n  Thanks for Andy Adinets for this contribution.\n- NVIDIA/thrust#1310, NVIDIA/thrust#1312: Various tuple-related APIs have been\n    updated to use variadic templates.\n  Thanks for Andrew Corrigan for these contributions.\n- NVIDIA/thrust#1297: Optionally add install rules when included with\n    CMake's `add_subdirectory`.\n  Thanks to Kai Germaschewski for this contribution.\n\n### Bug Fixes\n\n- NVIDIA/thrust#1309: Fix `thrust::shuffle` to produce better quality random\n    distributions.\n  Thanks to Rory Mitchell and Daniel Stokes for this contribution.\n- NVIDIA/thrust#1337: Fix compile-time regression in `transform_inclusive_scan`\n    and `transform_exclusive_scan`.\n- NVIDIA/thrust#1306: Fix binary search `middle` calculation to avoid overflows.\n    Thanks to Richard Barnes for this contribution.\n- NVIDIA/thrust#1314: Use `size_t` for the index type parameter\n    in `thrust::tuple_element`.\n  Thanks to Andrew Corrigan for this contribution.\n- NVIDIA/thrust#1329: Fix runtime error when copying an empty\n    `thrust::device_vector` in MSVC Debug builds.\n  Thanks to Ben Jude for this contribution.\n- NVIDIA/thrust#1323: Fix and add test for cmake package install rules.\n  Thanks for Keith Kraus and Kai Germaschewski for testing and discussion.\n- NVIDIA/thrust#1338: Fix GCC version checks in `thrust::detail::is_pod`\n    implementation.\n  Thanks to Anatoliy Tomilov for this contribution.\n- NVIDIA/thrust#1289: Partial fixes for Clang 10 as host compiler.\n  Filed an NVCC bug that will be fixed in a future version of the CUDA Toolkit\n    (NVBug 3136307).\n- NVIDIA/thrust#1272: Fix ambiguous `iter_swap` call when\n    using `thrust::partition` with STL containers.\n  Thanks to Isaac Deutsch for this contribution.\n- NVIDIA/thrust#1281: Update our bundled `FindTBB.cmake` module to support\n    latest MSVC.\n- NVIDIA/thrust#1298: Use semantic versioning rules for our CMake package's\n    compatibility checks.\n  Thanks to Kai Germaschewski for this contribution.\n- NVIDIA/thrust#1300: Use `FindPackageHandleStandardArgs` to print standard\n    status messages when our CMake package is found.\n  Thanks to Kai Germaschewski for this contribution.\n- NVIDIA/thrust#1320: Use feature-testing instead of a language dialect check\n    for `thrust::remove_cvref`.\n  Thanks to Andrew Corrigan for this contribution.\n- NVIDIA/thrust#1319: Suppress GPU deprecation warnings.\n\n### Other Enhancements\n\n- NVIDIA/cub#213: Removed some tuning policies for unsupported hardware (<SM35).\n- References to the old Github repository and branch names were updated.\n  - Github's `thrust/cub` repository is now `NVIDIA/cub`.\n  - Development has moved from the `master` branch to the `main` branch.\n\n## Thrust 1.10.0 (NVIDIA HPC SDK 20.9, CUDA Toolkit 11.2)\n\nThrust 1.10.0 is the major release accompanying the NVIDIA HPC SDK 20.9 release\n  and the CUDA Toolkit 11.2 release.\nIt drops support for C++03, GCC < 5, Clang < 6, and MSVC < 2017.\nIt also overhauls CMake support.\nFinally, we now have a Code of Conduct for contributors:\nhttps://github.com/NVIDIA/thrust/blob/main/CODE_OF_CONDUCT.md\n\n### Breaking Changes\n\n- C++03 is no longer supported.\n- GCC < 5, Clang < 6, and MSVC < 2017 are no longer supported.\n- C++11 is deprecated.\n  Using this dialect will generate a compile-time warning.\n  These warnings can be suppressed by defining\n    `THRUST_IGNORE_DEPRECATED_CPP_DIALECT` or `THRUST_IGNORE_DEPRECATED_CPP_11`.\n  Suppression is only a short term solution.\n  We will be dropping support for C++11 in the near future.\n- Asynchronous algorithms now require C++14.\n- CMake < 3.15 is no longer supported.\n- The default branch on GitHub is now called `main`.\n- Allocator and vector classes have been replaced with alias templates.\n\n### New Features\n\n- NVIDIA/thrust#1159: CMake multi-config support, which allows multiple\n    combinations of host and device systems to be built and tested at once.\n  More details can be found here: https://github.com/NVIDIA/thrust/blob/main/CONTRIBUTING.md#multi-config-cmake-options\n- CMake refactoring:\n  - Added install targets to CMake builds.\n  - Added support for CUB tests and examples.\n  - Thrust can be added to another CMake project by calling `add_subdirectory`\n      with the Thrust source root (see NVIDIA/thrust#976).\n    An example can be found here:\n      https://github.com/NVIDIA/thrust/blob/main/examples/cmake/add_subdir/CMakeLists.txt\n  - CMake < 3.15 is no longer supported.\n  - Dialects are now configured through target properties.\n    A new `THRUST_CPP_DIALECT` option has been added for single config mode.\n    Logic that modified `CMAKE_CXX_STANDARD` and `CMAKE_CUDA_STANDARD` has been\n      eliminated.\n  - Testing related CMake code has been moved to `testing/CMakeLists.txt`\n  - Example related CMake code has been moved to `examples/CMakeLists.txt`\n  - Header testing related CMake code has been moved to `cmake/ThrustHeaderTesting.cmake`\n  - CUDA configuration CMake code has been moved to to `cmake/ThrustCUDAConfig.cmake`.\n  - Now we explicitly `include(cmake/*.cmake)` files rather than searching\n      `CMAKE_MODULE_PATH` - we only want to use the ones in the repo.\n- `thrust::transform_input_output_iterator`, a variant of transform iterator\n    adapter that works as both an input iterator and an output iterator.\n  The given input function is applied after reading from the wrapped iterator\n    while the output function is applied before writing to the wrapped iterator.\n  Thanks to Trevor Smith for this contribution.\n\n### Other Enhancements\n\n- Contributor documentation: https://github.com/NVIDIA/thrust/blob/main/CONTRIBUTING.md\n- Code of Conduct: https://github.com/NVIDIA/thrust/blob/main/CODE_OF_CONDUCT.md.\n  Thanks to Conor Hoekstra for this contribution.\n- Support for all combinations of host and device systems.\n- C++17 support.\n- NVIDIA/thrust#1221: Allocator and vector classes have been replaced with\n    alias templates.\n  Thanks to Michael Francis for this contribution.\n- NVIDIA/thrust#1186: Use placeholder expressions to simplify the definitions\n    of a number of algorithms.\n  Thanks to Michael Francis for this contribution.\n- NVIDIA/thrust#1170: More conforming semantics for scan algorithms:\n  - Follow P0571's guidance regarding intermediate types.\n    - https://wg21.link/P0571\n    - The accumulator's type is now:\n      - The type of the user-supplied initial value (if provided), or\n      - The input iterator's value type if no initial value.\n  - Follow C++ standard guidance for default binary operator type.\n    - https://eel.is/c++draft/exclusive.scan#1\n    - Thrust binary/unary functors now specialize a default void template\n        parameter.\n      Types are deduced and forwarded transparently.\n    - Updated the scan's default binary operator to the new `thrust::plus<>`\n        specialization.\n  - The `thrust::intermediate_type_from_function_and_iterators` helper is no\n      longer needed and has been removed.\n- NVIDIA/thrust#1255: Always use `cudaStreamSynchronize` instead of\n    `cudaDeviceSynchronize` if the execution policy has a stream attached to it.\n  Thanks to Rong Ou for this contribution.\n- NVIDIA/thrust#1201: Tests for correct handling of legacy and per-thread\n    default streams.\n  Thanks to Rong Ou for this contribution.\n\n### Bug Fixes\n\n- NVIDIA/thrust#1260: Fix `thrust::transform_inclusive_scan` with heterogeneous\n    types.\n  Thanks to Rong Ou for this contribution.\n- NVIDIA/thrust#1258, NVC++ FS #28463: Ensure the CUDA radix sort backend\n    synchronizes before returning; otherwise, copies from temporary storage will\n    race with destruction of said temporary storage.\n- NVIDIA/thrust#1264: Evaluate `CUDA_CUB_RET_IF_FAIL` macro argument only once.\n  Thanks to Jason Lowe for this contribution.\n- NVIDIA/thrust#1262: Add missing `<stdexcept>` header.\n- NVIDIA/thrust#1250: Restore some `THRUST_DECLTYPE_RETURNS` macros in async\n    test implementations.\n- NVIDIA/thrust#1249: Use `std::iota` in `CUDATestDriver::target_devices`.\n  Thanks to Michael Francis for this contribution.\n- NVIDIA/thrust#1244: Check for macro collisions with system headers during\n    header testing.\n- NVIDIA/thrust#1224: Remove unnecessary SFINAE contexts from asynchronous\n    algorithms.\n- NVIDIA/thrust#1190: Make `out_of_memory_recovery` test trigger faster.\n- NVIDIA/thrust#1187: Elminate superfluous iterators specific to the CUDA\n    backend.\n- NVIDIA/thrust#1181: Various fixes for GoUDA.\n  Thanks to Andrei Tchouprakov for this contribution.\n- NVIDIA/thrust#1178, NVIDIA/thrust#1229: Use transparent functionals in\n    placeholder expressions, fixing issues with `thrust::device_reference` and\n    placeholder expressions and `thrust::find` with asymmetric equality\n    operators.\n- NVIDIA/thrust#1153: Switch to placement new instead of assignment to\n    construct items in uninitialized memory.\n  Thanks to Hugh Winkler for this contribution.\n- NVIDIA/thrust#1050: Fix compilation of asynchronous algorithms when RDC is\n    enabled.\n- NVIDIA/thrust#1042: Correct return type of\n    `thrust::detail::predicate_to_integral` from `bool` to `IntegralType`.\n  Thanks to Andreas Hehn for this contribution.\n- NVIDIA/thrust#1009: Avoid returning uninitialized allocators.\n  Thanks to Zhihao Yuan for this contribution.\n- NVIDIA/thrust#990: Add missing `<thrust/system/cuda/memory.h>` include to\n    `<thrust/system/cuda/detail/malloc_and_free.h>`.\n  Thanks to Robert Maynard for this contribution.\n- NVIDIA/thrust#966: Fix spurious MSVC conversion with loss of data warning in\n    sort algorithms.\n  Thanks to Zhihao Yuan for this contribution.\n- Add more metadata to mock specializations for testing iterator in\n   `testing/copy.cu`.\n- Add missing include to shuffle unit test.\n- Specialize `thrust::wrapped_function` for `void` return types because MSVC is\n    not a fan of the pattern `return static_cast<void>(expr);`.\n- Replace deprecated `tbb/tbb_thread.h` with `<thread>`.\n- Fix overcounting of initial value in TBB scans.\n- Use `thrust::advance` instead of `+=` for generic iterators.\n- Wrap the OMP flags in `-Xcompiler` for NVCC\n- Extend `ASSERT_STATIC_ASSERT` skip for the OMP backend.\n- Add missing header caught by `tbb.cuda` configs.\n- Fix \"unsafe API\" warnings in examples on MSVC: `s/fopen/fstream/`\n- Various C++17 fixes.\n\n## Thrust 1.9.10-1 (NVIDIA HPC SDK 20.7, CUDA Toolkit 11.1)\n\nThrust 1.9.10-1 is the minor release accompanying the NVIDIA HPC SDK 20.7 release\n  and the CUDA Toolkit 11.1 release.\n\n### Bug Fixes\n\n- #1214, NVBug 200619442: Stop using `std::allocator` APIs deprecated in C++17.\n- #1216, NVBug 200540293: Make `thrust::optional` work with Clang when used\n    with older libstdc++.\n- #1207, NVBug 200618218: Don't force C++14 with older compilers that don't\n    support it.\n- #1218: Wrap includes of `<memory>` and `<algorithm>` to avoid circular\n    inclusion with NVC++.\n\n## Thrust 1.9.10 (NVIDIA HPC SDK 20.5)\n\nThrust 1.9.10 is the release accompanying the NVIDIA HPC SDK 20.5 release.\nIt adds CMake support for compilation with NVC++ and a number of minor bug fixes\n  for NVC++.\nIt also adds CMake `find_package` support, which replaces the broken 3rd-party\n  legacy `FindThrust.cmake` script.\nC++03, C++11, GCC < 5, Clang < 6, and MSVC < 2017 are now deprecated.\nStarting with the upcoming 1.10.0 release, C++03 support will be dropped\n  entirely.\n\n### Breaking Changes\n\n- #1082: Thrust now checks that it is compatible with the version of CUB found\n    in your include path, generating an error if it is not.\n  If you are using your own version of CUB, it may be too old.\n  It is recommended to simply delete your own version of CUB and use the\n    version of CUB that comes with Thrust.\n- #1089: C++03 and C++11 are deprecated.\n  Using these dialects will generate a compile-time warning.\n  These warnings can be suppressed by defining\n    `THRUST_IGNORE_DEPRECATED_CPP_DIALECT` (to suppress C++03 and C++11\n    deprecation warnings) or `THRUST_IGNORE_DEPRECATED_CPP11` (to suppress C++11\n    deprecation warnings).\n  Suppression is only a short term solution.\n  We will be dropping support for C++03 in the 1.10.0 release and C++11 in the\n    near future.\n- #1089: GCC < 5, Clang < 6, and MSVC < 2017 are deprecated.\n  Using these compilers will generate a compile-time warning.\n  These warnings can be suppressed by defining\n    `THRUST_IGNORE_DEPRECATED_COMPILER`.\n  Suppression is only a short term solution.\n  We will be dropping support for these compilers in the near future.\n\n### New Features\n\n- #1130: CMake `find_package` support.\n  This is significant because there is a legacy `FindThrust.cmake` script\n    authored by a third party in widespread use in the community which has a\n    bug in how it parses Thrust version numbers which will cause it to\n    incorrectly parse 1.9.10.\n  This script only handles the first digit of each part of the Thrust version\n    number correctly: for example, Thrust 17.17.17 would be interpreted as\n    Thrust 1.1.1701717.\n  You can find directions for using the new CMake `find_package` support and\n    migrating away from the legacy `FindThrust.cmake` [here](https://github.com/NVIDIA/thrust/blob/main/thrust/cmake/README.md)\n- #1129: Added `thrust::detail::single_device_tls_caching_allocator`, a\n    convenient way to get an MR caching allocator for device memory, which is\n    used by NVC++.\n\n### Other Enhancements\n\n- #1129: Refactored RDC handling in CMake to be a global option and not create\n    two targets for each example and test.\n\n### Bug Fixes\n\n- #1129: Fix the legacy `thrust::return_temporary_buffer` API to support\n    passing a size.\n  This was necessary to enable usage of Thrust caching MR allocators with\n    synchronous Thrust algorithms.\n  This change has allowed NVC++'s C++17 Parallel Algorithms implementation to\n    switch to use Thrust caching MR allocators for device temporary storage,\n    which gives a 2x speedup on large multi-GPU systems such as V100 and A100\n    DGX where `cudaMalloc` is very slow.\n- #1128: Respect `CUDA_API_PER_THREAD_DEFAULT_STREAM`.\n  Thanks to Rong Ou for this contribution.\n- #1131: Fix the one-policy overload of `thrust::async::copy` to not copy the\n    policy, resolving use-afer-move issues.\n- #1145: When cleaning up type names in `unittest::base_class_name`, only call\n    `std::string::replace` if we found the substring we are looking to replace.\n- #1139: Don't use `cxx::__demangle` in NVC++.\n- #1102: Don't use `thrust::detail::normal_distribution_nvcc` for Feta because\n    it uses `erfcinv`, a non-standard function that Feta doesn't have.\n\n## Thrust 1.9.9 (CUDA Toolkit 11.0)\n\nThrust 1.9.9 adds support for NVC++, which uses Thrust to implement\n  GPU-accelerated C++17 Parallel Algorithms.\n`thrust::zip_function` and `thrust::shuffle` were also added.\nC++03, C++11, GCC < 5, Clang < 6, and MSVC < 2017 are now deprecated.\nStarting with the upcoming 1.10.0 release, C++03 support will be dropped\n  entirely.\nAll other deprecated platforms will be dropped in the near future.\n\n### Breaking Changes\n\n- #1082: Thrust now checks that it is compatible with the version of CUB found\n    in your include path, generating an error if it is not.\n  If you are using your own version of CUB, it may be too old.\n  It is recommended to simply delete your own version of CUB and use the\n    version of CUB that comes with Thrust.\n- #1089: C++03 and C++11 are deprecated.\n  Using these dialects will generate a compile-time warning.\n  These warnings can be suppressed by defining\n    `THRUST_IGNORE_DEPRECATED_CPP_DIALECT` (to suppress C++03 and C++11\n    deprecation warnings) or `THRUST_IGNORE_DEPRECATED_CPP_11` (to suppress C++11\n    deprecation warnings).\n  Suppression is only a short term solution.\n  We will be dropping support for C++03 in the 1.10.0 release and C++11 in the\n    near future.\n- #1089: GCC < 5, Clang < 6, and MSVC < 2017 are deprecated.\n  Using these compilers will generate a compile-time warning.\n  These warnings can be suppressed by defining\n  `THRUST_IGNORE_DEPRECATED_COMPILER`.\n  Suppression is only a short term solution.\n  We will be dropping support for these compilers in the near future.\n\n### New Features\n\n- #1086: Support for NVC++ aka \"Feta\".\n  The most significant change is in how we use `__CUDA_ARCH__`.\n  Now, there are four macros that must be used:\n  - `THRUST_IS_DEVICE_CODE`, which should be used in an `if` statement around\n      device-only code.\n  - `THRUST_INCLUDE_DEVICE_CODE`, which should be used in an `#if` preprocessor\n      directive inside of the `if` statement mentioned in the prior bullet.\n  - `THRUST_IS_HOST_CODE`, which should be used in an `if` statement around\n      host-only code.\n  - `THRUST_INCLUDE_HOST_CODE`, which should be used in an `#if` preprocessor\n      directive inside of the `if` statement mentioned in the prior bullet.\n- #1085: `thrust::shuffle`.\n  Thanks to Rory Mitchell for this contribution.\n- #1029: `thrust::zip_function`, a facility for zipping functions that take N\n    parameters instead of a tuple of N parameters as `thrust::zip_iterator`\n    does.\n  Thanks to Ben Jude for this contribution.\n- #1068: `thrust::system::cuda::managed_memory_pointer`, a universal memory\n    strongly typed pointer compatible with the ISO C++ Standard Library.\n\n### Other Enhancements\n\n- #1029: Thrust is now built and tested with NVCC warnings treated as errors.\n- #1029: MSVC C++11 support.\n- #1029: `THRUST_DEPRECATED` abstraction for generating compile-time\n    deprecation warning messages.\n- #1029: `thrust::pointer<T>::pointer_to(reference)`.\n- #1070: Unit test for `thrust::inclusive_scan` with a user defined types.\n  Thanks to Conor Hoekstra for this contribution.\n\n### Bug Fixes\n\n- #1088: Allow `thrust::replace` to take functions that have non-`const`\n    `operator()`.\n- #1094: Add missing `constexpr` to `par_t` constructors.\n  Thanks to Patrick Stotko for this contribution.\n- #1077: Remove `__device__` from CUDA MR-based device allocators to fix\n    obscure \"host function called from host device function\" warning that occurs\n    when you use the new Thrust MR-based allocators.\n- #1029: Remove inconsistently-used `THRUST_BEGIN`/`END_NS` macros.\n- #1029: Fix C++ dialect detection on newer MSVC.\n- #1029 Use `_Pragma`/`__pragma` instead of `#pragma` in macros.\n- #1029: Replace raw `__cplusplus` checks with the appropriate Thrust macros.\n- #1105: Add a missing `<math.h>` include.\n- #1103: Fix regression of `thrust::detail::temporary_allocator` with non-CUDA\n    back ends.\n- #1111: Use Thrust's random number engine instead of `std::`s in device code.\n- #1108: Get rid of a GCC 9 warning about deprecated generation of copy ctors.\n\n## Thrust 1.9.8-1 (NVIDIA HPC SDK 20.3)\n\nThrust 1.9.8-1 is a variant of 1.9.8 accompanying the NVIDIA HPC SDK 20.3\n  release.\nIt contains modifications necessary to serve as the implementation of NVC++'s\n  GPU-accelerated C++17 Parallel Algorithms when using the CUDA Toolkit 11.0\n  release.\n\n## Thrust 1.9.8 (CUDA Toolkit 11.0 Early Access)\n\nThrust 1.9.8, which is included in the CUDA Toolkit 11.0 release, removes\n  Thrust's internal derivative of CUB, upstreams all relevant changes too CUB,\n  and adds CUB as a Git submodule.\nIt will now be necessary to do `git clone --recursive` when checking out\n  Thrust, and to update the CUB submodule when pulling in new Thrust changes.\nAdditionally, CUB is now included as a first class citizen in the CUDA toolkit.\nThrust 1.9.8 also fixes bugs preventing most Thrust algorithms from working\n  with more than `2^31-1` elements.\nNow, `thrust::reduce`, `thrust::*_scan`, and related algorithms (aka most of\n  Thrust) work with large element counts.\n\n### Breaking Changes\n\n- Thrust will now use the version of CUB in your include path instead of its own\n    internal copy.\n  If you are using your own version of CUB, it may be older and incompatible\n    with Thrust.\n  It is recommended to simply delete your own version of CUB and use the\n    version of CUB that comes with Thrust.\n\n### Other Enhancements\n\n- Refactor Thrust and CUB to support 64-bit indices in most algorithms.\n  In most cases, Thrust now selects between kernels that use 32-bit indices and\n    64-bit indices at runtime depending on the size of the input.\n  This means large element counts work, but small element counts do not have to\n    pay for the register usage of 64-bit indices if they are not needed.\n  Now, `thrust::reduce`, `thrust::*_scan`, and related algorithms (aka most of\n    Thrust) work with more than `2^31-1` elements.\n  Notably, `thrust::sort` is still limited to less than `2^31-1` elements.\n- CUB is now a submodule and the internal copy of CUB has been removed.\n- #1051: Stop specifying the `__launch_bounds__` minimum blocks parameter\n    because it messes up register allocation and increases register pressure,\n    and we don't actually know at compile time how many blocks we will use\n    (aside from single tile kernels).\n\n### Bug Fixes\n\n- #1020: After making a CUDA API call, always clear the global CUDA error state\n    by calling `cudaGetLastError`.\n- #1021: Avoid calling destroy in the destructor of a Thrust vector if the\n    vector is empty.\n- #1046: Actually throw `thrust::bad_alloc` when `thrust::system::cuda::malloc`\n    fails instead of just constructing a temporary and doing nothing with it.\n- Add missing copy constructor or copy assignment operator to all classes that\n    GCC 9's `-Wdeprecated-copy` complains about\n- Add missing move operations to `thrust::system::cuda::vector`.\n- #1015: Check that the backend is CUDA before using CUDA-specifics in\n    `thrust::detail::temporary_allocator`.\n  Thanks to Hugh Winkler for this contribution.\n- #1055: More correctly detect the presence of aligned/sized `new`/`delete`.\n- #1043: Fix ill-formed specialization of `thrust::system::is_error_code_enum`\n    for `thrust::event_errc`.\n  Thanks to Toru Niina for this contribution.\n- #1027: Add tests for `thrust::tuple_for_each` and `thrust::tuple_subset`.\n  Thanks to Ben Jude for this contribution.\n- #1027: Use correct macro in `thrust::tuple_for_each`.\n  Thanks to Ben Jude for this contribution.\n- #1026: Use correct MSVC version formatting in CMake.\n  Thanks to Ben Jude for this contribution.\n- Workaround an NVCC issue with type aliases with template template arguments\n    containing a parameter pack.\n- Remove unused functions from the CUDA backend which call slow CUDA attribute\n    query APIs.\n- Replace `CUB_RUNTIME_FUNCTION` with `THRUST_RUNTIME_FUNCTION`.\n- Correct typo in `thrust::transform` documentation.\n  Thanks to Eden Yefet for this contribution.\n\n### Known Issues\n\n- `thrust::sort` remains limited to `2^31-1` elements for now.\n\n## Thrust 1.9.7-1 (CUDA Toolkit 10.2 for Tegra)\n\nThrust 1.9.7-1 is a minor release accompanying the CUDA Toolkit 10.2 release\n  for Tegra.\nIt is nearly identical to 1.9.7.\n\n### Bug Fixes\n\n- Remove support for GCC's broken nodiscard-like attribute.\n\n## Thrust 1.9.7 (CUDA Toolkit 10.2)\n\nThrust 1.9.7 is a minor release accompanying the CUDA Toolkit 10.2 release.\nUnfortunately, although the version and patch numbers are identical, one bug\n  fix present in Thrust 1.9.7 (NVBug 2646034: Fix incorrect dependency handling\n  for stream acquisition in `thrust::future`) was not included in the CUDA\n  Toolkit 10.2 preview release for AArch64 SBSA.\nThe tag `cuda-10.2aarch64sbsa` contains the exact version of Thrust present\n  in the CUDA Toolkit 10.2 preview release for AArch64 SBSA.\n\n### Bug Fixes\n\n- #967, NVBug 2448170: Fix the CUDA backend `thrust::for_each` so that it\n    supports large input sizes with 64-bit indices.\n- NVBug 2646034: Fix incorrect dependency handling for stream acquisition in\n    `thrust::future`.\n  - Not present in the CUDA Toolkit 10.2 preview release for AArch64 SBSA.\n- #968, NVBug 2612102: Fix the `thrust::mr::polymorphic_adaptor` to actually\n    use its template parameter.\n\n## Thrust 1.9.6-1 (NVIDIA HPC SDK 20.3)\n\nThrust 1.9.6-1 is a variant of 1.9.6 accompanying the NVIDIA HPC SDK 20.3\n  release.\nIt contains modifications necessary to serve as the implementation of NVC++'s\n  GPU-accelerated C++17 Parallel Algorithms when using the CUDA Toolkit 10.1\n  Update 2 release.\n\n## Thrust 1.9.6 (CUDA Toolkit 10.1 Update 2)\n\nThrust 1.9.6 is a minor release accompanying the CUDA Toolkit 10.1 Update 2\n  release.\n\n### Bug Fixes\n\n- NVBug 2509847: Inconsistent alignment of `thrust::complex`\n- NVBug 2586774: Compilation failure with Clang + older libstdc++ that doesn't\n    have `std::is_trivially_copyable`\n- NVBug 200488234: CUDA header files contain Unicode characters which leads\n    compiling errors on Windows\n- #949, #973, NVBug 2422333, NVBug 2522259, NVBug 2528822:\n    `thrust::detail::aligned_reinterpret_cast` must be annotated with\n    `__host__ __device__`.\n- NVBug 2599629: Missing include in the OpenMP sort implementation\n- NVBug 200513211: Truncation warning in test code under VC142\n\n## Thrust 1.9.5 (CUDA Toolkit 10.1 Update 1)\n\nThrust 1.9.5 is a minor release accompanying the CUDA Toolkit 10.1 Update 1\n  release.\n\n### Bug Fixes\n\n- NVBug 2502854: Fixed assignment of\n    `thrust::device_vector<thrust::complex<T>>` between host and device.\n\n## Thrust 1.9.4 (CUDA Toolkit 10.1)\n\nThrust 1.9.4 adds asynchronous interfaces for parallel algorithms, a new\n  allocator system including caching allocators and unified memory support, as\n  well as a variety of other enhancements, mostly related to\n  C++11/C++14/C++17/C++20 support.\nThe new asynchronous algorithms in the `thrust::async` namespace return\n  `thrust::event` or `thrust::future` objects, which can be waited upon to\n  synchronize with the completion of the parallel operation.\n\n### Breaking Changes\n\nSynchronous Thrust algorithms now block until all of their operations have\n  completed.\nUse the new asynchronous Thrust algorithms for non-blocking behavior.\n\n### New Features\n\n- `thrust::event` and `thrust::future<T>`, uniquely-owned asynchronous handles\n    consisting of a state (ready or not ready), content (some value; for\n    `thrust::future` only), and an optional set of objects that should be\n    destroyed only when the future's value is ready and has been consumed.\n  - The design is loosely based on C++11's `std::future`.\n  - They can be `.wait`'d on, and the value of a future can be waited on and\n      retrieved with `.get` or `.extract`.\n  - Multiple `thrust::event`s and `thrust::future`s can be combined with\n      `thrust::when_all`.\n  - `thrust::future`s can be converted to `thrust::event`s.\n  - Currently, these primitives are only implemented for the CUDA backend and\n      are C++11 only.\n- New asynchronous algorithms that return `thrust::event`/`thrust::future`s,\n    implemented as C++20 range style customization points:\n    - `thrust::async::reduce`.\n    - `thrust::async::reduce_into`, which takes a target location to store the\n        reduction result into.\n    - `thrust::async::copy`, including a two-policy overload that allows\n        explicit cross system copies which execution policy properties can be\n        attached to.\n    - `thrust::async::transform`.\n    - `thrust::async::for_each`.\n    - `thrust::async::stable_sort`.\n    - `thrust::async::sort`.\n    - By default the asynchronous algorithms use the new caching allocators.\n        Deallocation of temporary storage is deferred until the destruction of\n        the returned `thrust::future`. The content of `thrust::future`s is\n        stored in either device or universal memory and transferred to the host\n        only upon request to prevent unnecessary data migration.\n    - Asynchronous algorithms are currently only implemented for the CUDA\n        system and are C++11 only.\n- `exec.after(f, g, ...)`, a new execution policy method that takes a set of\n    `thrust::event`/`thrust::future`s and returns an execution policy that\n    operations on that execution policy should depend upon.\n- New logic and mindset for the type requirements for cross-system sequence\n    copies (currently only used by `thrust::async::copy`), based on:\n  - `thrust::is_contiguous_iterator` and `THRUST_PROCLAIM_CONTIGUOUS_ITERATOR`\n      for detecting/indicating that an iterator points to contiguous storage.\n  - `thrust::is_trivially_relocatable` and\n      `THRUST_PROCLAIM_TRIVIALLY_RELOCATABLE` for detecting/indicating that a\n      type is `memcpy`able (based on principles from\n      [P1144](https://wg21.link/P1144)).\n  - The new approach reduces buffering, increases performance, and increases\n      correctness.\n  - The fast path is now enabled when copying CUDA `__half` and vector types with\n      `thrust::async::copy`.\n- All Thrust synchronous algorithms for the CUDA backend now actually\n    synchronize. Previously, any algorithm that did not allocate temporary\n    storage (counterexample: `thrust::sort`) and did not have a\n    computation-dependent result (counterexample: `thrust::reduce`) would\n    actually be launched asynchronously. Additionally, synchronous algorithms\n    that allocated temporary storage would become asynchronous if a custom\n    allocator was supplied that did not synchronize on allocation/deallocation,\n    unlike `cudaMalloc`/`cudaFree`. So, now `thrust::for_each`,\n    `thrust::transform`, `thrust::sort`, etc are truly synchronous. In some\n    cases this may be a performance regression; if you need asynchrony, use the\n    new asynchronous algorithms.\n- Thrust's allocator framework has been rewritten. It now uses a memory\n    resource system, similar to C++17's `std::pmr` but supporting static\n    polymorphism. Memory resources are objects that allocate untyped storage and\n    allocators are cheap handles to memory resources in this new model. The new\n    facilities live in `<thrust/mr/*>`.\n  - `thrust::mr::memory_resource<Pointer>`, the memory resource base class,\n      which takes a (possibly tagged) pointer to `void` type as a parameter.\n  - `thrust::mr::allocator<T, MemoryResource>`, an allocator backed by a memory\n      resource object.\n  - `thrust::mr::polymorphic_adaptor_resource<Pointer>`, a type-erased memory\n      resource adaptor.\n  - `thrust::mr::polymorphic_allocator<T>`, a C++17-style polymorphic allocator\n      backed by a type-erased memory resource object.\n  - New tunable C++17-style caching memory resources,\n      `thrust::mr::(disjoint_)?(un)?synchronized_pool_resource`, designed to\n      cache both small object allocations and large repetitive temporary\n      allocations. The disjoint variants use separate storage for management of\n      the pool, which is necessary if the memory being allocated cannot be\n      accessed on the host (e.g.  device memory).\n  - System-specific allocators were rewritten to use the new memory resource\n      framework.\n  - New `thrust::device_memory_resource` for allocating device memory.\n  - New `thrust::universal_memory_resource` for allocating memory that can be\n      accessed from both the host and device (e.g. `cudaMallocManaged`).\n  - New `thrust::universal_host_pinned_memory_resource` for allocating memory\n      that can be accessed from the host and the device but always resides in\n      host memory (e.g. `cudaMallocHost`).\n  - `thrust::get_per_device_resource` and `thrust::per_device_allocator`, which\n      lazily create and retrieve a per-device singleton memory resource.\n  - Rebinding mechanisms (`rebind_traits` and `rebind_alloc`) for\n      `thrust::allocator_traits`.\n  - `thrust::device_make_unique`, a factory function for creating a\n      `std::unique_ptr` to a newly allocated object in device memory.\n  - `<thrust/detail/memory_algorithms>`, a C++11 implementation of the C++17\n      uninitialized memory algorithms.\n  - `thrust::allocate_unique` and friends, based on the proposed C++23\n      [`std::allocate_unique`](https://wg21.link/P0211).\n- New type traits and metaprogramming facilities. Type traits are slowly being\n    migrated out of `thrust::detail::` and `<thrust/detail/*>`; their new home\n    will be `thrust::` and `<thrust/type_traits/*>`.\n  - `thrust::is_execution_policy`.\n  - `thrust::is_operator_less_or_greater_function_object`, which detects\n      `thrust::less`, `thrust::greater`, `std::less`, and `std::greater`.\n  - `thrust::is_operator_plus_function_object``, which detects `thrust::plus`\n      and `std::plus`.\n  - `thrust::remove_cvref(_t)?`, a C++11 implementation of C++20's\n      `thrust::remove_cvref(_t)?`.\n  - `thrust::void_t`, and various other new type traits.\n  - `thrust::integer_sequence` and friends, a C++11 implementation of C++20's\n      `std::integer_sequence`\n  - `thrust::conjunction`, `thrust::disjunction`, and `thrust::disjunction`, a\n      C++11 implementation of C++17's logical metafunctions.\n  - Some Thrust type traits (such as `thrust::is_constructible`) have been\n      redefined in terms of C++11's type traits when they are available.\n- `<thrust/detail/tuple_algorithms.h>`, new `std::tuple` algorithms:\n  - `thrust::tuple_transform`.\n  - `thrust::tuple_for_each`.\n  - `thrust::tuple_subset`.\n- Miscellaneous new `std::`-like facilities:\n  - `thrust::optional`, a C++11 implementation of C++17's `std::optional`.\n  - `thrust::addressof`, an implementation of C++11's `std::addressof`.\n  - `thrust::next` and `thrust::prev`, an implementation of C++11's `std::next`\n      and `std::prev`.\n  - `thrust::square`, a `<functional>` style unary function object that\n      multiplies its argument by itself.\n  - `<thrust/limits.h>` and `thrust::numeric_limits`, a customized version of\n      `<limits>` and `std::numeric_limits`.\n- `<thrust/detail/preprocessor.h>`, new general purpose preprocessor facilities:\n  - `THRUST_PP_CAT[2-5]`, concatenates two to five tokens.\n  - `THRUST_PP_EXPAND(_ARGS)?`, performs double expansion.\n  - `THRUST_PP_ARITY` and `THRUST_PP_DISPATCH`, tools for macro overloading.\n  - `THRUST_PP_BOOL`, boolean conversion.\n  - `THRUST_PP_INC` and `THRUST_PP_DEC`, increment/decrement.\n  - `THRUST_PP_HEAD`, a variadic macro that expands to the first argument.\n  - `THRUST_PP_TAIL`, a variadic macro that expands to all its arguments after\n      the first.\n  - `THRUST_PP_IIF`, bitwise conditional.\n  - `THRUST_PP_COMMA_IF`, and `THRUST_PP_HAS_COMMA`, facilities for adding and\n      detecting comma tokens.\n  - `THRUST_PP_IS_VARIADIC_NULLARY`, returns true if called with a nullary\n      `__VA_ARGS__`.\n  - `THRUST_CURRENT_FUNCTION`, expands to the name of the current function.\n- New C++11 compatibility macros:\n  - `THRUST_NODISCARD`, expands to `[[nodiscard]]` when available and the best\n      equivalent otherwise.\n  - `THRUST_CONSTEXPR`, expands to `constexpr` when available and the best\n      equivalent otherwise.\n  - `THRUST_OVERRIDE`, expands to `override` when available and the best\n      equivalent otherwise.\n  - `THRUST_DEFAULT`, expands to `= default;` when available and the best\n      equivalent otherwise.\n  - `THRUST_NOEXCEPT`, expands to `noexcept` when available and the best\n      equivalent otherwise.\n  - `THRUST_FINAL`, expands to `final` when available and the best equivalent\n      otherwise.\n  - `THRUST_INLINE_CONSTANT`, expands to `inline constexpr` when available and\n      the best equivalent otherwise.\n- `<thrust/detail/type_deduction.h>`, new C++11-only type deduction helpers:\n  - `THRUST_DECLTYPE_RETURNS*`, expand to function definitions with suitable\n      conditional `noexcept` qualifiers and trailing return types.\n  - `THRUST_FWD(x)`, expands to `::std::forward<decltype(x)>(x)`.\n  - `THRUST_MVCAP`, expands to a lambda move capture.\n  - `THRUST_RETOF`, expands to a decltype computing the return type of an\n      invocable.\n- New CMake build system.\n\n### New Examples\n\n- `mr_basic` demonstrates how to use the new memory resource allocator system.\n\n### Other Enhancements\n\n- Tagged pointer enhancements:\n  - New `thrust::pointer_traits` specialization for `void const*`.\n  - `nullptr` support to Thrust tagged pointers.\n  - New `explicit operator bool` for Thrust tagged pointers when using C++11\n      for `std::unique_ptr` interoperability.\n  - Added `thrust::reinterpret_pointer_cast` and `thrust::static_pointer_cast`\n      for casting Thrust tagged pointers.\n- Iterator enhancements:\n  - `thrust::iterator_system` is now SFINAE friendly.\n  - Removed cv qualifiers from iterator types when using\n      `thrust::iterator_system`.\n- Static assert enhancements:\n  - New `THRUST_STATIC_ASSERT_MSG`, takes an optional string constant to be\n      used as the error message when possible.\n  - Update `THRUST_STATIC_ASSERT(_MSG)` to use C++11's `static_assert` when\n      it's available.\n  - Introduce a way to test for static assertions.\n- Testing enhancements:\n  - Additional scalar and sequence types, including non-builtin types and\n      vectors with unified memory allocators, have been added to the list of\n      types used by generic unit tests.\n  - The generation of random input data has been improved to increase the range\n      of values used and catch more corner cases.\n  - New `unittest::truncate_to_max_representable` utility for avoiding the\n      generation of ranges that cannot be represented by the underlying element\n      type in generic unit test code.\n  - The test driver now synchronizes with CUDA devices and check for errors\n      after each test, when switching devices, and after each raw kernel launch.\n  - The `warningtester` uber header is now compiled with NVCC to avoid needing\n      to disable CUDA-specific code with the preprocessor.\n  - Fixed the unit test framework's `ASSERT_*` to print `char`s as `int`s.\n  - New `DECLARE_INTEGRAL_VARIABLE_UNITTEST` test declaration macro.\n  - New `DECLARE_VARIABLE_UNITTEST_WITH_TYPES_AND_NAME` test declaration macro.\n  - `thrust::system_error` in the CUDA backend now print out its `cudaError_t`\n      enumerator in addition to the diagnostic message.\n  - Stopped using conditionally signed types like `char`.\n\n### Bug Fixes\n\n- #897, NVBug 2062242: Fix compilation error when using `__device__` lambdas\n    with `thrust::reduce` on MSVC.\n- #908, NVBug 2089386: Static assert that `thrust::generate`/`thrust::fill`\n    isn't operating on const iterators.\n- #919 Fix compilation failure with `thrust::zip_iterator` and\n    `thrust::complex`.\n- #924, NVBug 2096679, NVBug 2315990: Fix dispatch for the CUDA backend's\n    `thrust::reduce` to use two functions (one with the pragma for disabling\n    exec checks, one with `THRUST_RUNTIME_FUNCTION`) instead of one. This fixes\n    a regression with device compilation that started in CUDA Toolkit 9.2.\n- #928, NVBug 2341455: Add missing `__host__ __device__` annotations to a\n    `thrust::complex::operator=` to satisfy GoUDA.\n- NVBug 2094642: Make `thrust::vector_base::clear` not depend on the element\n    type being default constructible.\n- NVBug 2289115: Remove flaky `simple_cuda_streams` example.\n- NVBug 2328572: Add missing `thrust::device_vector` constructor that takes an\n    allocator parameter.\n- NVBug 2455740: Update the `range_view` example to not use device-side launch.\n- NVBug 2455943: Ensure that sized unit tests that use\n    `thrust::counting_iterator` perform proper truncation.\n- NVBug 2455952: Refactor questionable `thrust::copy_if` unit tests.\n\n## Thrust 1.9.3 (CUDA Toolkit 10.0)\n\nThrust 1.9.3 unifies and integrates CUDA Thrust and GitHub Thrust.\n\n### Bug Fixes\n\n- #725, #850, #855, #859, #860: Unify the `thrust::iter_swap` interface and fix\n    `thrust::device_reference` swapping.\n- NVBug 2004663: Add a `data` method to `thrust::detail::temporary_array` and\n    refactor temporary memory allocation in the CUDA backend to be exception\n    and leak safe.\n- #886, #894, #914: Various documentation typo fixes.\n- #724: Provide `NVVMIR_LIBRARY_DIR` environment variable to NVCC.\n- #878: Optimize `thrust::min/max_element` to only use\n    `thrust::detail::get_iterator_value` for non-numeric types.\n- #899: Make `thrust::cuda::experimental::pinned_allocator`'s comparison\n    operators `const`.\n- NVBug 2092152: Remove all includes of `<cuda.h>`.\n- #911: Fix default comparator element type for `thrust::merge_by_key`.\n\n### Acknowledgments\n\n- Thanks to Andrew Corrigan for contributing fixes for swapping interfaces.\n- Thanks to Francisco Facioni for contributing optimizations for\n    `thrust::min/max_element`.\n\n## Thrust 1.9.2 (CUDA Toolkit 9.2)\n\nThrust 1.9.2 brings a variety of performance enhancements, bug fixes and test\n  improvements.\nCUB 1.7.5 was integrated, enhancing the performance of `thrust::sort` on\n  small data types and `thrust::reduce`.\nChanges were applied to `complex` to optimize memory access.\nThrust now compiles with compiler warnings enabled and treated as errors.\nAdditionally, the unit test suite and framework was enhanced to increase\n  coverage.\n\n### Breaking Changes\n\n- The `fallback_allocator` example was removed, as it was buggy and difficult\n    to support.\n\n### New Features\n\n- `<thrust/detail/alignment.h>`, utilities for memory alignment:\n  - `thrust::aligned_reinterpret_cast`.\n  - `thrust::aligned_storage_size`, which computes the amount of storage needed\n      for an object of a particular size and alignment.\n  - `thrust::alignment_of`, a C++03 implementation of C++11's\n      `std::alignment_of`.\n  - `thrust::aligned_storage`, a C++03 implementation of C++11's\n      `std::aligned_storage`.\n  - `thrust::max_align_t`, a C++03 implementation of C++11's\n      `std::max_align_t`.\n\n### Bug Fixes\n\n- NVBug 200385527, NVBug 200385119, NVBug 200385113, NVBug 200349350, NVBug\n    2058778: Various compiler warning issues.\n- NVBug 200355591: `thrust::reduce` performance issues.\n- NVBug 2053727: Fixed an ADL bug that caused user-supplied `allocate` to be\n    overlooked but `deallocate` to be called with GCC <= 4.3.\n- NVBug 1777043: Fixed `thrust::complex` to work with `thrust::sequence`.\n\n## Thrust 1.9.1-2 (CUDA Toolkit 9.1)\n\nThrust 1.9.1-2 integrates version 1.7.4 of CUB and introduces a new CUDA backend\n  for `thrust::reduce` based on CUB.\n\n### Bug Fixes\n\n- NVBug 1965743: Remove unnecessary static qualifiers.\n- NVBug 1940974: Fix regression causing a compilation error when using\n    `thrust::merge_by_key` with `thrust::constant_iterator`s.\n- NVBug 1904217: Allow callables that take non-const refs to be used with\n    `thrust::reduce` and `thrust::*_scan`.\n\n## Thrust 1.9.0-5 (CUDA Toolkit 9.0)\n\nThrust 1.9.0-5 replaces the original CUDA backend (bulk) with a new one\n  written using CUB, a high performance CUDA collectives library.\nThis brings a substantial performance improvement to the CUDA backend across\n  the board.\n\n### Breaking Changes\n\n- Any code depending on CUDA backend implementation details will likely be\n    broken.\n\n### New Features\n\n- New CUDA backend based on CUB which delivers substantially higher performance.\n- `thrust::transform_output_iterator`, a fancy iterator that applies a function\n    to the output before storing the result.\n\n### New Examples\n\n- `transform_output_iterator` demonstrates use of the new fancy iterator\n    `thrust::transform_output_iterator`.\n\n### Other Enhancements\n\n- When C++11 is enabled, functors do not have to inherit from\n    `thrust::(unary|binary)_function` anymore to be used with\n    `thrust::transform_iterator`.\n- Added C++11 only move constructors and move assignment operators for\n    `thrust::detail::vector_base`-based classes, e.g. `thrust::host_vector`,\n    `thrust::device_vector`, and friends.\n\n### Bug Fixes\n\n- `sin(thrust::complex<double>)` no longer has precision loss to float.\n\n### Acknowledgments\n\n- Thanks to Manuel Schiller for contributing a C++11 based enhancement\n    regarding the deduction of functor return types, improving the performance\n    of `thrust::unique` and implementing `thrust::transform_output_iterator`.\n- Thanks to Thibault Notargiacomo for the implementation of move semantics for\n    the `thrust::vector_base`-based classes.\n- Thanks to Duane Merrill for developing CUB and helping to integrate it into\n    Thrust's backend.\n\n## Thrust 1.8.3 (CUDA Toolkit 8.0)\n\nThrust 1.8.3 is a small bug fix release.\n\n### New Examples\n\n- `range_view` demonstrates the use of a view (a non-owning wrapper for an\n    iterator range with a container-like interface).\n\n### Bug Fixes\n\n- `thrust::(min|max|minmax)_element` can now accept raw device pointers when\n    an explicit device execution policy is used.\n- `thrust::clear` operations on vector types no longer requires the element\n    type to have a default constructor.\n\n## Thrust 1.8.2 (CUDA Toolkit 7.5)\n\nThrust 1.8.2 is a small bug fix release.\n\n### Bug Fixes\n\n- Avoid warnings and errors concerning user functions called from\n    `__host__ __device__` functions.\n- #632: Fix an error in `thrust::set_intersection_by_key` with the CUDA backend.\n- #651: `thrust::copy` between host and device now accepts execution policies\n    with streams attached, i.e. `thrust::::cuda::par.on(stream)`.\n- #664: `thrust::for_each` and algorithms based on it no longer ignore streams\n    attached to execution policys.\n\n### Known Issues\n\n- #628: `thrust::reduce_by_key` for the CUDA backend fails for Compute\n    Capability 5.0 devices.\n\n## Thrust 1.8.1 (CUDA Toolkit 7.0)\n\nThrust 1.8.1 is a small bug fix release.\n\n### Bug Fixes\n\n- #615, #620: Fixed `thrust::for_each` and `thrust::reduce` to no longer fail on\n    large inputs.\n\n### Known Issues\n\n- #628: `thrust::reduce_by_key` for the CUDA backend fails for Compute\n    Capability 5.0 devices.\n\n## Thrust 1.8.0\n\nThrust 1.8.0 introduces support for algorithm invocation from CUDA device\n  code, support for CUDA streams, and algorithm performance improvements.\nUsers may now invoke Thrust algorithms from CUDA device code, providing a\n  parallel algorithms library to CUDA programmers authoring custom kernels, as\n  well as allowing Thrust programmers to nest their algorithm calls within\n  functors.\nThe `thrust::seq` execution policy allows users to require sequential algorithm\n  execution in the calling thread and makes a sequential algorithms library\n  available to individual CUDA threads.\nThe `.on(stream)` syntax allows users to request a CUDA stream for kernels\n  launched during algorithm execution.\nFinally, new CUDA algorithm implementations provide substantial performance\n  improvements.\n\n### New Features\n\n- Algorithms in CUDA Device Code:\n    - Thrust algorithms may now be invoked from CUDA `__device__` and\n        `__host__` __device__ functions.\n      Algorithms invoked in this manner must be invoked with an execution\n        policy as the first parameter.\n      The following execution policies are supported in CUDA __device__ code:\n      - `thrust::seq`\n      - `thrust::cuda::par`\n      - `thrust::device`, when THRUST_DEVICE_SYSTEM == THRUST_DEVICE_SYSTEM_CUDA.\n  - Device-side algorithm execution may not be parallelized unless CUDA Dynamic\n      Parallelism is available.\n- Execution Policies:\n  - CUDA Streams\n    - The `thrust::cuda::par.on(stream)` syntax allows users to request that\n        CUDA kernels launched during algorithm execution should occur on a given\n        stream.\n    - Algorithms executed with a CUDA stream in this manner may still\n        synchronize with other streams when allocating temporary storage or\n        returning results to the CPU.\n  - `thrust::seq`, which allows users to require that an algorithm execute\n      sequentially in the calling thread.\n- `thrust::complex`, a complex number data type.\n\n### New Examples\n\n- simple_cuda_streams demonstrates how to request a CUDA stream during\n    algorithm execution.\n- async_reduce demonstrates ways to achieve algorithm invocations which are\n    asynchronous with the calling thread.\n\n### Other Enhancements\n\n- CUDA sort performance for user-defined types is 300% faster on Tesla K20c for\n    large problem sizes.\n- CUDA merge performance is 200% faster on Tesla K20c for large problem sizes.\n- CUDA sort performance for primitive types is 50% faster on Tesla K20c for\n    large problem sizes.\n- CUDA reduce_by_key performance is 25% faster on Tesla K20c for large problem\n    sizes.\n- CUDA scan performance is 15% faster on Tesla K20c for large problem sizes.\n- fallback_allocator example is simpler.\n\n### Bug Fixes\n\n- #364: Iterators with unrelated system tags may be used with algorithms invoked\n    with an execution policy\n- #371: Do not redefine `__CUDA_ARCH__`.\n- #379: Fix crash when dereferencing transform_iterator on the host.\n- #391: Avoid use of uppercase variable names.\n- #392: Fix `thrust::copy` between `cusp::complex` and `std::complex`.\n- #396: Program compiled with gcc < 4.3 hangs during comparison sort.\n- #406: `fallback_allocator.cu` example checks device for unified addressing support.\n- #417: Avoid using `std::less<T>` in binary search algorithms.\n- #418: Avoid various warnings.\n- #443: Including version.h no longer configures default systems.\n- #578: NVCC produces warnings when sequential algorithms are used with CPU systems.\n\n### Known Issues\n\n- When invoked with primitive data types, thrust::sort, thrust::sort_by_key,\n    thrust::stable_sort, & thrust::stable_sort_by_key may\n- Sometimes linking fails when compiling with `-rdc=true` with NVCC.\n- The CUDA implementation of thrust::reduce_by_key incorrectly outputs the last\n    element in a segment of equivalent keys instead of the first.\n\n### Acknowledgments\n\n- Thanks to Sean Baxter for contributing faster CUDA reduce, merge, and scan\n    implementations.\n- Thanks to Duane Merrill for contributing a faster CUDA radix sort implementation.\n- Thanks to Filipe Maia for contributing the implementation of thrust::complex.\n\n## Thrust 1.7.2 (CUDA Toolkit 6.5)\n\nThrust 1.7.2 is a minor bug fix release.\n\n### Bug Fixes\n\n- Avoid use of `std::min` in generic find implementation.\n\n## Thrust 1.7.1 (CUDA Toolkit 6.0)\n\nThrust 1.7.1 is a minor bug fix release.\n\n### Bug Fixes\n\n- Eliminate identifiers in `set_operations.cu` example with leading underscore.\n- Eliminate unused variable warning in CUDA `reduce_by_key` implementation.\n- Avoid deriving function objects from `std::unary_function` and\n    `std::binary_function`.\n\n## Thrust 1.7.0 (CUDA Toolkit 5.5)\n\nThrust 1.7.0 introduces a new interface for controlling algorithm execution as\n  well as several new algorithms and performance improvements.\nWith this new interface, users may directly control how algorithms execute as\n  well as details such as the allocation of temporary storage.\nKey/value versions of thrust::merge and the set operation algorithms have been\n  added, as well stencil versions of partitioning algorithms.\nthrust::tabulate has been introduced to tabulate the values of functions taking\n  integers.\nFor 32b types, new CUDA merge and set operations provide 2-15x faster\n  performance while a new CUDA comparison sort provides 1.3-4x faster\n  performance.\nFinally, a new TBB reduce_by_key implementation provides 80% faster\n  performance.\n\n### Breaking Changes\n\n- Dispatch:\n  - Custom user backend systems' tag types must now inherit from the\n      corresponding system's execution_policy template (e.g.\n      thrust::cuda::execution_policy) instead of the tag struct (e.g.\n      thrust::cuda::tag). Otherwise, algorithm specializations will silently go\n      unfound during dispatch. See examples/minimal_custom_backend.cu and\n      examples/cuda/fallback_allocator.cu for usage examples.\n  - thrust::advance and thrust::distance are no longer dispatched based on\n      iterator system type and thus may no longer be customized.\n- Iterators:\n  - iterator_facade and iterator_adaptor's Pointer template parameters have\n      been eliminated.\n  - iterator_adaptor has been moved into the thrust namespace (previously\n      thrust::experimental::iterator_adaptor).\n  - iterator_facade has been moved into the thrust namespace (previously\n      thrust::experimental::iterator_facade).\n  - iterator_core_access has been moved into the thrust namespace (previously\n      thrust::experimental::iterator_core_access).\n  - All iterators' nested pointer typedef (the type of the result of\n      operator->) is now void instead of a pointer type to indicate that such\n      expressions are currently impossible.\n  - Floating point counting_iterators' nested difference_type typedef is now a\n      signed integral type instead of a floating point type.\n- Other:\n  - normal_distribution has been moved into the thrust::random namespace\n      (previously thrust::random::experimental::normal_distribution).\n  - Placeholder expressions may no longer include the comma operator.\n\n### New Features\n- Execution Policies:\n  - Users may directly control the dispatch of algorithm invocations with\n      optional execution policy arguments.\n    For example, instead of wrapping raw pointers allocated by cudaMalloc with\n      thrust::device_ptr, the thrust::device execution_policy may be passed as\n      an argument to an algorithm invocation to enable CUDA execution.\n  - The following execution policies are supported in this version:\n    - `thrust::host`\n    - `thrust::device`\n    - `thrust::cpp::par`\n    - `thrust::cuda::par`\n    - `thrust::omp::par`\n    - `thrust::tbb::par`\n- Algorithms:\n  - `thrust::merge_by_key`\n  - `thrust::partition` with stencil\n  - `thrust::partition_copy` with stencil\n  - `thrust::set_difference_by_key`\n  - `thrust::set_intersection_by_key`\n  - `thrust::set_symmetric_difference_by_key`\n  - `thrust::set_union_by_key`\n  - `thrust::stable_partition with stencil`\n  - `thrust::stable_partition_copy with stencil`\n  - `thrust::tabulate`\n- Memory Allocation:\n\t- `thrust::malloc`\n\t- `thrust::free`\n  - `thrust::get_temporary_buffer`\n  - `thrust::return_temporary_buffer`\n\n### New Examples\n\n- uninitialized_vector demonstrates how to use a custom allocator to avoid the\n    automatic initialization of elements in thrust::device_vector.\n\n### Other Enhancements\n\n- Authors of custom backend systems may manipulate arbitrary state during\n    algorithm dispatch by incorporating it into their execution_policy parameter.\n- Users may control the allocation of temporary storage during algorithm\n    execution by passing standard allocators as parameters via execution policies\n    such as thrust::device.\n- THRUST_DEVICE_SYSTEM_CPP has been added as a compile-time target for the\n    device backend.\n- CUDA merge performance is 2-15x faster.\n- CUDA comparison sort performance is 1.3-4x faster.\n- CUDA set operation performance is 1.5-15x faster.\n- TBB reduce_by_key performance is 80% faster.\n- Several algorithms have been parallelized with TBB.\n- Support for user allocators in vectors has been improved.\n- The sparse_vector example is now implemented with merge_by_key instead of\n    sort_by_key.\n- Warnings have been eliminated in various contexts.\n- Warnings about __host__ or __device__-only functions called from __host__\n    __device__ functions have been eliminated in various contexts.\n- Documentation about algorithm requirements have been improved.\n- Simplified the minimal_custom_backend example.\n- Simplified the cuda/custom_temporary_allocation example.\n- Simplified the cuda/fallback_allocator example.\n\n### Bug Fixes\n\n- #248: Fix broken `thrust::counting_iterator<float>` behavior with OpenMP.\n- #231, #209: Fix set operation failures with CUDA.\n- #187: Fix incorrect occupancy calculation with CUDA.\n- #153: Fix broken multi GPU behavior with CUDA.\n- #142: Eliminate warning produced by `thrust::random::taus88` and MSVC 2010.\n- #208: Correctly initialize elements in temporary storage when necessary.\n- #16: Fix compilation error when sorting bool with CUDA.\n- #10: Fix ambiguous overloads of `thrust::reinterpret_tag`.\n\n### Known Issues\n\n- GCC 4.3 and lower may fail to dispatch thrust::get_temporary_buffer correctly\n    causing infinite recursion in examples such as\n    cuda/custom_temporary_allocation.\n\n### Acknowledgments\n\n- Thanks to Sean Baxter, Bryan Catanzaro, and Manjunath Kudlur for contributing\n    a faster merge implementation for CUDA.\n- Thanks to Sean Baxter for contributing a faster set operation implementation\n    for CUDA.\n- Thanks to Cliff Woolley for contributing a correct occupancy calculation\n    algorithm.\n\n## Thrust 1.6.0\n\nThrust 1.6.0 provides an interface for customization and extension and a new\n  backend system based on the Threading Building Blocks library.\nWith this new interface, programmers may customize the behavior of specific\n  algorithms as well as control the allocation of temporary storage or invent\n  entirely new backends.\nThese enhancements also allow multiple different backend systems\n  such as CUDA and OpenMP to coexist within a single program.\nSupport for TBB allows Thrust programs to integrate more naturally into\n  applications which may already employ the TBB task scheduler.\n\n### Breaking Changes\n\n- The header <thrust/experimental/cuda/pinned_allocator.h> has been moved to\n    <thrust/system/cuda/experimental/pinned_allocator.h>\n- thrust::experimental::cuda::pinned_allocator has been moved to\n    thrust::cuda::experimental::pinned_allocator\n- The macro THRUST_DEVICE_BACKEND has been renamed THRUST_DEVICE_SYSTEM\n- The macro THRUST_DEVICE_BACKEND_CUDA has been renamed THRUST_DEVICE_SYSTEM_CUDA\n- The macro THRUST_DEVICE_BACKEND_OMP has been renamed THRUST_DEVICE_SYSTEM_OMP\n- thrust::host_space_tag has been renamed thrust::host_system_tag\n- thrust::device_space_tag has been renamed thrust::device_system_tag\n- thrust::any_space_tag has been renamed thrust::any_system_tag\n- thrust::iterator_space has been renamed thrust::iterator_system\n\n### New Features\n\n- Backend Systems\n  - Threading Building Blocks (TBB) is now supported\n- Algorithms\n  - `thrust::for_each_n`\n  - `thrust::raw_reference_cast`\n- Types\n  - `thrust::pointer`\n  - `thrust::reference`\n\n### New Examples\n\n- `cuda/custom_temporary_allocation`\n- `cuda/fallback_allocator`\n- `device_ptr`\n- `expand`\n- `minimal_custom_backend`\n- `raw_reference_cast`\n- `set_operations`\n\n### Other Enhancements\n\n- `thrust::for_each` now returns the end of the input range similar to most\n    other algorithms.\n- `thrust::pair` and `thrust::tuple` have swap functionality.\n- All CUDA algorithms now support large data types.\n- Iterators may be dereferenced in user `__device__` or `__global__` functions.\n- The safe use of different backend systems is now possible within a single\n  binary\n\n### Bug Fixes\n\n- #469 `min_element` and `max_element` algorithms no longer require a const comparison operator\n\n### Known Issues\n\n- NVCC may crash when parsing TBB headers on Windows.\n\n## Thrust 1.5.3 (CUDA Toolkit 5.0)\n\nThrust 1.5.3 is a minor bug fix release.\n\n### Bug Fixes\n\n- Avoid warnings about potential race due to `__shared__` non-POD variable\n\n## Thrust 1.5.2 (CUDA Toolkit 4.2)\n\nThrust 1.5.2 is a minor bug fix release.\n\n### Bug Fixes\n\n- Fixed warning about C-style initialization of structures\n\n## Thrust 1.5.1 (CUDA Toolkit 4.1)\n\nThrust 1.5.1 is a minor bug fix release.\n\n### Bug Fixes\n\n- Sorting data referenced by permutation_iterators on CUDA produces invalid results\n\n## Thrust 1.5.0\n\nThrust 1.5.0 provides introduces new programmer productivity and performance\n  enhancements.\nNew functionality for creating anonymous \"lambda\" functions has been added.\nA faster host sort provides 2-10x faster performance for sorting arithmetic\n  types on (single-threaded) CPUs.\nA new OpenMP sort provides 2.5x-3.0x speedup over the host sort using a\n  quad-core CPU.\nWhen sorting arithmetic types with the OpenMP backend the combined performance\n  improvement is 5.9x for 32-bit integers and ranges from 3.0x (64-bit types) to\n  14.2x (8-bit types).\nA new CUDA `reduce_by_key` implementation provides 2-3x faster\n  performance.\n\n### Breaking Changes\n- device_ptr<void> no longer unsafely converts to device_ptr<T> without an\n    explicit cast.\n  Use the expression device_pointer_cast(static_cast<int*>(void_ptr.get())) to\n    convert, for example, device_ptr<void> to device_ptr<int>.\n\n### New Features\n\n- Algorithms:\n  - Stencil-less `thrust::transform_if`.\n- Lambda placeholders\n\n### New Examples\n- lambda\n\n### Other Enhancements\n\n- Host sort is 2-10x faster for arithmetic types\n- OMP sort provides speedup over host sort\n- `reduce_by_key` is 2-3x faster\n- `reduce_by_key` no longer requires O(N) temporary storage\n- CUDA scan algorithms are 10-40% faster\n- `host_vector` and `device_vector` are now documented\n- out-of-memory exceptions now provide detailed information from CUDART\n- improved histogram example\n- `device_reference` now has a specialized swap\n- `reduce_by_key` and scan algorithms are compatible with `discard_iterator`\n\n### Bug Fixes\n\n- #44: Allow `thrust::host_vector` to compile when `value_type` uses\n    `__align__`.\n- #198: Allow `thrust::adjacent_difference` to permit safe in-situ operation.\n- #303: Make thrust thread-safe.\n- #313: Avoid race conditions in `thrust::device_vector::insert`.\n- #314: Avoid unintended ADL invocation when dispatching copy.\n- #365: Fix merge and set operation failures.\n\n### Known Issues\n\n- None\n\n### Acknowledgments\n\n- Thanks to Manjunath Kudlur for contributing his Carbon library, from which\n    the lambda functionality is derived.\n- Thanks to Jean-Francois Bastien for suggesting a fix for #303.\n\n## Thrust 1.4.0 (CUDA Toolkit 4.0)\n\nThrust 1.4.0 is the first release of Thrust to be included in the CUDA Toolkit.\nAdditionally, it brings many feature and performance improvements.\nNew set theoretic algorithms operating on sorted sequences have been added.\nAdditionally, a new fancy iterator allows discarding redundant or otherwise\n  unnecessary output from algorithms, conserving memory storage and bandwidth.\n\n### Breaking Changes\n\n- Eliminations\n  - `thrust/is_sorted.h`\n  - `thrust/utility.h`\n  - `thrust/set_intersection.h`\n  - `thrust/experimental/cuda/ogl_interop_allocator.h` and the functionality\n      therein\n  - `thrust::deprecated::copy_when`\n  - `thrust::deprecated::absolute_value`\n  - `thrust::deprecated::copy_when`\n  - `thrust::deprecated::absolute_value`\n  - `thrust::deprecated::copy_when`\n  - `thrust::deprecated::absolute_value`\n  - `thrust::gather` and `thrust::scatter` from host to device and vice versa\n      are no longer supported.\n  - Operations which modify the elements of a thrust::device_vector are no longer\n      available from source code compiled without nvcc when the device backend\n      is CUDA.\n    Instead, use the idiom from the cpp_interop example.\n\n### New Features\n\n- Algorithms:\n  - `thrust::copy_n`\n  - `thrust::merge`\n  - `thrust::set_difference`\n  - `thrust::set_symmetric_difference`\n  - `thrust::set_union`\n\n- Types\n  - `thrust::discard_iterator`\n\n- Device Support:\n  - Compute Capability 2.1 GPUs.\n\n### New Examples\n\n- run_length_decoding\n\n### Other Enhancements\n\n- Compilation warnings are substantially reduced in various contexts.\n- The compilation time of thrust::sort, thrust::stable_sort,\n    thrust::sort_by_key, and thrust::stable_sort_by_key are substantially\n    reduced.\n- A fast sort implementation is used when sorting primitive types with\n    thrust::greater.\n- The performance of thrust::set_intersection is improved.\n- The performance of thrust::fill is improved on SM 1.x devices.\n- A code example is now provided in each algorithm's documentation.\n- thrust::reverse now operates in-place\n\n### Bug Fixes\n\n- #212: `thrust::set_intersection` works correctly for large input sizes.\n- #275: `thrust::counting_iterator` and `thrust::constant_iterator` work\n    correctly with OpenMP as the backend when compiling with optimization.\n- #256: `min` and `max` correctly return their first argument as a tie-breaker\n- #248: `NDEBUG` is interpreted incorrectly\n\n### Known Issues\n\n- NVCC may generate code containing warnings when compiling some Thrust\n    algorithms.\n- When compiling with `-arch=sm_1x`, some Thrust algorithms may cause NVCC to\n    issue benign pointer advisories.\n- When compiling with `-arch=sm_1x` and -G, some Thrust algorithms may fail to\n    execute correctly.\n- `thrust::inclusive_scan`, `thrust::exclusive_scan`,\n    `thrust::inclusive_scan_by_key`, and `thrust::exclusive_scan_by_key` are\n    currently incompatible with `thrust::discard_iterator`.\n\n### Acknowledgments\n\n- Thanks to David Tarjan for improving the performance of set_intersection.\n- Thanks to Duane Merrill for continued help with sort.\n- Thanks to Nathan Whitehead for help with CUDA Toolkit integration.\n\n## Thrust 1.3.0\n\nThrust 1.3.0 provides support for CUDA Toolkit 3.2 in addition to many feature\n  and performance enhancements.\nPerformance of the sort and sort_by_key algorithms is improved by as much as 3x\n  in certain situations.\nThe performance of stream compaction algorithms, such as copy_if, is improved\n  by as much as 2x.\nCUDA errors are now converted to runtime exceptions using the system_error\n  interface.\nCombined with a debug mode, also new in 1.3, runtime errors can be located with\n  greater precision.\nLastly, a few header files have been consolidated or renamed for clarity.\nSee the deprecations section below for additional details.\n\n### Breaking Changes\n\n- Promotions\n  - thrust::experimental::inclusive_segmented_scan has been renamed\n      thrust::inclusive_scan_by_key and exposes a different interface\n  - thrust::experimental::exclusive_segmented_scan has been renamed\n      thrust::exclusive_scan_by_key and exposes a different interface\n  - thrust::experimental::partition_copy has been renamed\n      thrust::partition_copy and exposes a different interface\n  - thrust::next::gather has been renamed thrust::gather\n  - thrust::next::gather_if has been renamed thrust::gather_if\n  - thrust::unique_copy_by_key has been renamed thrust::unique_by_key_copy\n- Deprecations\n  - thrust::copy_when has been renamed thrust::deprecated::copy_when\n  - thrust::absolute_value has been renamed thrust::deprecated::absolute_value\n  - The header thrust/set_intersection.h is now deprecated; use\n      thrust/set_operations.h instead\n  - The header thrust/utility.h is now deprecated; use thrust/swap.h instead\n  - The header thrust/swap_ranges.h is now deprecated; use thrust/swap.h instead\n- Eliminations\n  - thrust::deprecated::gather\n  - thrust::deprecated::gather_if\n  - thrust/experimental/arch.h and the functions therein\n  - thrust/sorting/merge_sort.h\n  - thrust/sorting/radix_sort.h\n- NVCC 2.3 is no longer supported\n\n### New Features\n\n- Algorithms:\n  - `thrust::exclusive_scan_by_key`\n  - `thrust::find`\n  - `thrust::find_if`\n  - `thrust::find_if_not`\n  - `thrust::inclusive_scan_by_key`\n  - `thrust::is_partitioned`\n  - `thrust::is_sorted_until`\n  - `thrust::mismatch`\n  - `thrust::partition_point`\n  - `thrust::reverse`\n  - `thrust::reverse_copy`\n  - `thrust::stable_partition_copy`\n\n- Types:\n  - `thrust::system_error` and related types.\n  - `thrust::experimental::cuda::ogl_interop_allocator`.\n  - `thrust::bit_and`, `thrust::bit_or`, and `thrust::bit_xor`.\n\n- Device Support:\n  - GF104-based GPUs.\n\n### New Examples\n\n- opengl_interop.cu\n- repeated_range.cu\n- simple_moving_average.cu\n- sparse_vector.cu\n- strided_range.cu\n\n### Other Enhancements\n\n- Performance of thrust::sort and thrust::sort_by_key is substantially improved\n    for primitive key types\n- Performance of thrust::copy_if is substantially improved\n- Performance of thrust::reduce and related reductions is improved\n- THRUST_DEBUG mode added\n- Callers of Thrust functions may detect error conditions by catching\n    thrust::system_error, which derives from std::runtime_error\n- The number of compiler warnings generated by Thrust has been substantially\n    reduced\n- Comparison sort now works correctly for input sizes > 32M\n- min & max usage no longer collides with <windows.h> definitions\n- Compiling against the OpenMP backend no longer requires nvcc\n- Performance of device_vector initialized in .cpp files is substantially\n    improved in common cases\n- Performance of thrust::sort_by_key on the host is substantially improved\n\n### Bug Fixes\n\n- Debug device code now compiles correctly\n- thrust::uninitialized_copy and thrust::uninitialized_fill now dispatch\n    constructors on the device rather than the host\n\n### Known Issues\n\n- #212 set_intersection is known to fail for large input sizes\n- partition_point is known to fail for 64b types with nvcc 3.2\n\nAcknowledgments\n- Thanks to Duane Merrill for contributing a fast CUDA radix sort implementation\n- Thanks to Erich Elsen for contributing an implementation of find_if\n- Thanks to Andrew Corrigan for contributing changes which allow the OpenMP\n    backend to compile in the absence of nvcc\n- Thanks to Andrew Corrigan, Cliff Wooley, David Coeurjolly, Janick Martinez\n    Esturo, John Bowers, Maxim Naumov, Michael Garland, and Ryuta Suzuki for\n    bug reports\n- Thanks to Cliff Woolley for help with testing\n\n## Thrust 1.2.1\n\nThrust 1.2.1 is a small bug fix release that is compatible with the CUDA\n  Toolkit 3.1 release.\n\n### Known Issues\n\n- `thrust::inclusive_scan` and `thrust::exclusive_scan` may fail with very\n    large types.\n- MSVC may fail to compile code using both sort and binary search algorithms.\n- `thrust::uninitialized_fill` and `thrust::uninitialized_copy` dispatch\n    constructors on the host rather than the device.\n- #109: Some algorithms may exhibit poor performance with the OpenMP backend\n    with large numbers (>= 6) of CPU threads.\n- `thrust::default_random_engine::discard` is not accelerated with NVCC 2.3\n- NVCC 3.1 may fail to compile code using types derived from\n    `thrust::subtract_with_carry_engine`, such as `thrust::ranlux24` and\n    `thrust::ranlux48`.\n\n## Thrust 1.2.0\n\nThrust 1.2.0 introduces support for compilation to multicore CPUs and the Ocelot\n  virtual machine, and several new facilities for pseudo-random number\n  generation.\nNew algorithms such as set intersection and segmented reduction have also been\n  added.\nLastly, improvements to the robustness of the CUDA backend ensure correctness\n  across a broad set of (uncommon) use cases.\n\n### Breaking Changes\n\n- `thrust::gather`'s interface was incorrect and has been removed.\n  The old interface is deprecated but will be preserved for Thrust version 1.2\n    at `thrust::deprecated::gather` and `thrust::deprecated::gather_if`.\n  The new interface is provided at `thrust::next::gather` and\n    `thrust::next::gather_if`.\n  The new interface will be promoted to `thrust::` in Thrust version 1.3.\n  For more details, please refer to [this thread](http://groups.google.com/group/thrust-users/browse_thread/thread/f5f0583cb97b51fd).\n- The `thrust::sorting` namespace has been deprecated in favor of the top-level\n    sorting functions, such as `thrust::sort` and `thrust::sort_by_key`.\n- Removed support for `thrust::equal` between host & device sequences.\n- Removed support for `thrust::scatter` between host & device sequences.\n\n### New Features\n\n- Algorithms:\n  - `thrust::reduce_by_key`\n  - `thrust::set_intersection`\n  - `thrust::unique_copy`\n  - `thrust::unique_by_key`\n  - `thrust::unique_copy_by_key`\n- Types\n- Random Number Generation:\n  - `thrust::discard_block_engine`\n  - `thrust::default_random_engine`\n  - `thrust::linear_congruential_engine`\n  - `thrust::linear_feedback_shift_engine`\n  - `thrust::subtract_with_carry_engine`\n  - `thrust::xor_combine_engine`\n  - `thrust::minstd_rand`\n  - `thrust::minstd_rand0`\n  - `thrust::ranlux24`\n  - `thrust::ranlux48`\n  - `thrust::ranlux24_base`\n  - `thrust::ranlux48_base`\n  - `thrust::taus88`\n  - `thrust::uniform_int_distribution`\n  - `thrust::uniform_real_distribution`\n  - `thrust::normal_distribution` (experimental)\n- Function Objects:\n  - `thrust::project1st`\n  - `thrust::project2nd`\n- `thrust::tie`\n- Fancy Iterators:\n  - `thrust::permutation_iterator`\n  - `thrust::reverse_iterator`\n- Vector Functions:\n  - `operator!=`\n  - `rbegin`\n  - `crbegin`\n  - `rend`\n  - `crend`\n  - `data`\n  - `shrink_to_fit`\n- Device Support:\n  - Multicore CPUs via OpenMP.\n  - Fermi-class GPUs.\n  - Ocelot virtual machines.\n- Support for NVCC 3.0.\n\n### New Examples\n\n- `cpp_integration`\n- `histogram`\n- `mode`\n- `monte_carlo`\n- `monte_carlo_disjoint_sequences`\n- `padded_grid_reduction`\n- `permutation_iterator`\n- `row_sum`\n- `run_length_encoding`\n- `segmented_scan`\n- `stream_compaction`\n- `summary_statistics`\n- `transform_iterator`\n- `word_count`\n\n### Other Enhancements\n\n- Integer sorting performance is improved when max is large but (max - min) is\n    small and when min is negative\n- Performance of `thrust::inclusive_scan` and `thrust::exclusive_scan` is\n    improved by 20-25% for primitive types.\n\n### Bug Fixes\n\n- #8 cause a compiler error if the required compiler is not found rather than a\n    mysterious error at link time\n- #42 device_ptr & device_reference are classes rather than structs,\n    eliminating warnings on certain platforms\n- #46 gather & scatter handle any space iterators correctly\n- #51 thrust::experimental::arch functions gracefully handle unrecognized GPUs\n- #52 avoid collisions with common user macros such as BLOCK_SIZE\n- #62 provide better documentation for device_reference\n- #68 allow built-in CUDA vector types to work with device_vector in pure C++\n    mode\n- #102 eliminated a race condition in device_vector::erase\n- various compilation warnings eliminated\n\n### Known Issues\n\n- inclusive_scan & exclusive_scan may fail with very large types\n- MSVC may fail to compile code using both sort and binary search algorithms\n- uninitialized_fill & uninitialized_copy dispatch constructors on the host\n    rather than the device\n- #109 some algorithms may exhibit poor performance with the OpenMP backend\n    with large numbers (>= 6) of CPU threads\n- default_random_engine::discard is not accelerated with nvcc 2.3\n\n### Acknowledgments\n\n- Thanks to Gregory Diamos for contributing a CUDA implementation of\n    set_intersection\n- Thanks to Ryuta Suzuki & Gregory Diamos for rigorously testing Thrust's unit\n    tests and examples against Ocelot\n- Thanks to Tom Bradley for contributing an implementation of normal_distribution\n- Thanks to Joseph Rhoads for contributing the example summary_statistics\n\n## Thrust 1.1.1\n\nThrust 1.1.1 is a small bug fix release that is compatible with the CUDA\n  Toolkit 2.3a release and Mac OSX Snow Leopard.\n\n## Thrust 1.1.0\n\nThrust 1.1.0 introduces fancy iterators, binary search functions, and several\n  specialized reduction functions.\nExperimental support for segmented scans has also been added.\n\n### Breaking Changes\n\n- `thrust::counting_iterator` has been moved into the `thrust` namespace\n    (previously `thrust::experimental`).\n\n### New Features\n\n- Algorithms:\n  - `thrust::copy_if`\n  - `thrust::lower_bound`\n  - `thrust::upper_bound`\n  - `thrust::vectorized lower_bound`\n  - `thrust::vectorized upper_bound`\n  - `thrust::equal_range`\n  - `thrust::binary_search`\n  - `thrust::vectorized binary_search`\n  - `thrust::all_of`\n  - `thrust::any_of`\n  - `thrust::none_of`\n  - `thrust::minmax_element`\n  - `thrust::advance`\n  - `thrust::inclusive_segmented_scan` (experimental)\n  - `thrust::exclusive_segmented_scan` (experimental)\n- Types:\n  - `thrust::pair`\n  - `thrust::tuple`\n  - `thrust::device_malloc_allocator`\n- Fancy Iterators:\n  - `thrust::constant_iterator`\n  - `thrust::counting_iterator`\n  - `thrust::transform_iterator`\n  - `thrust::zip_iterator`\n\n### New Examples\n\n- Computing the maximum absolute difference between vectors.\n- Computing the bounding box of a two-dimensional point set.\n- Sorting multiple arrays together (lexicographical sorting).\n- Constructing a summed area table.\n- Using `thrust::zip_iterator` to mimic an array of structs.\n- Using `thrust::constant_iterator` to increment array values.\n\n### Other Enhancements\n\n- Added pinned memory allocator (experimental).\n- Added more methods to host_vector & device_vector (issue #4).\n- Added variant of remove_if with a stencil argument (issue #29).\n- Scan and reduce use cudaFuncGetAttributes to determine grid size.\n- Exceptions are reported when temporary device arrays cannot be allocated.\n\n### Bug Fixes\n\n- #5: Make vector work for larger data types\n- #9: stable_partition_copy doesn't respect OutputIterator concept semantics\n- #10: scans should return OutputIterator\n- #16: make algorithms work for larger data types\n- #27: Dispatch radix_sort even when comp=less<T> is explicitly provided\n\n### Known Issues\n\n- Using functors with Thrust entry points may not compile on Mac OSX with gcc\n    4.0.1.\n- `thrust::uninitialized_copy` and `thrust::uninitialized_fill` dispatch\n    constructors on the host rather than the device.\n- `thrust::inclusive_scan`, `thrust::inclusive_scan_by_key`,\n    `thrust::exclusive_scan`, and `thrust::exclusive_scan_by_key` may fail when\n    used with large types with the CUDA Toolkit 3.1.\n\n## Thrust 1.0.0\n\nFirst production release of Thrust.\n\n### Breaking Changes\n\n- Rename top level namespace `komrade` to `thrust`.\n- Move `thrust::partition_copy` & `thrust::stable_partition_copy` into\n    `thrust::experimental` namespace until we can easily provide the standard\n    interface.\n- Rename `thrust::range` to `thrust::sequence` to avoid collision with\n    Boost.Range.\n- Rename `thrust::copy_if` to `thrust::copy_when` due to semantic differences\n    with C++0x `std::copy_if`.\n\n### New Features\n\n- Add C++0x style `cbegin` & `cend` methods to `thrust::host_vector` and\n    `thrust::device_vector`.\n- Add `thrust::transform_if` function.\n- Add stencil versions of `thrust::replace_if` & `thrust::replace_copy_if`.\n- Allow `counting_iterator` to work with `thrust::for_each`.\n- Allow types with constructors in comparison `thrust::sort` and\n    `thrust::reduce`.\n\n### Other Enhancements\n\n- `thrust::merge_sort` and `thrust::stable_merge_sort` are now 2x to 5x faster\n    when executed on the parallel device.\n\n### Bug Fixes\n\n- Komrade 6: Workaround an issue where an incremented iterator causes NVCC to\n    crash.\n- Komrade 7: Fix an issue where `const_iterator`s could not be passed to\n    `thrust::transform`.\n\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 5.2841796875,
          "content": "# 3.15 is the minimum for including the project with add_subdirectory.\n# 3.17 for building the project's standalone tests/examples/etc.\n# 3.18.3 for C++17 + CUDA\ncmake_minimum_required(VERSION 3.15)\n\n# Remove this when we use the new CUDA_ARCHITECTURES properties with both\n# nvcc and nvc++.\nif (CMAKE_VERSION VERSION_GREATER_EQUAL 3.18)\n  cmake_policy(SET CMP0104 OLD)\nendif()\n\nproject(Thrust NONE)\n\n# Determine whether Thrust is the top-level project or included into\n# another project via add_subdirectory()\nif (\"${CMAKE_SOURCE_DIR}\" STREQUAL \"${CMAKE_CURRENT_LIST_DIR}\")\n  set(THRUST_TOPLEVEL_PROJECT ON)\nelse()\n  set(THRUST_TOPLEVEL_PROJECT OFF)\nendif()\n\n## thrust_fix_clang_nvcc_build_for \n#\n# Modifies the given target to include a fix for the clang host compiler case.\n# The fix consists of force-including a header into each compilation unit.\n#\nfunction(thrust_fix_clang_nvcc_build_for target)\n  if (UNIX)\n    # Path to the header containing the fix for clang + nvcc < 11.6. For more info,\n    # check the content of this header.\n    set(clang_fix_header_path \"${CMAKE_CURRENT_FUNCTION_LIST_DIR}/testing/fix_clang_nvcc_11.5.h\")\n\n    # Only affects host compiler\n    target_compile_options(${target} PRIVATE \n        \"$<$<COMPILE_LANGUAGE:CUDA>:-include${clang_fix_header_path}>\")\n  endif()\nendfunction()\n\n# This must be done before any languages are enabled:\nif (THRUST_TOPLEVEL_PROJECT)\n  include(cmake/ThrustCompilerHacks.cmake)\nendif()\n\n# This must appear after our Compiler Hacks or else CMake will delete the cache\n# and reconfigure from scratch.\n# This must also appear before the installation rules, as it is required by the\n# GNUInstallDirs CMake module.\nenable_language(CXX)\n\n# Optionally include installation rules for non-top-level builds:\noption(THRUST_ENABLE_INSTALL_RULES \"Enable installation of Thrust\" ${THRUST_TOPLEVEL_PROJECT})\nif (THRUST_ENABLE_INSTALL_RULES)\n  include(cmake/ThrustInstallRules.cmake)\nendif()\n\n# Support adding Thrust to a parent project via add_subdirectory.\n# See examples/cmake/add_subdir/CMakeLists.txt for details.\nif (NOT THRUST_TOPLEVEL_PROJECT)\n  include(cmake/ThrustAddSubdir.cmake)\n  return()\nendif()\n\n# We use 3.17 features when building our tests, etc.\ncmake_minimum_required(VERSION 3.17)\n\noption(THRUST_ENABLE_HEADER_TESTING \"Test that all public headers compile.\" \"ON\")\noption(THRUST_ENABLE_TESTING \"Build Thrust testing suite.\" \"ON\")\noption(THRUST_ENABLE_EXAMPLES \"Build Thrust examples.\" \"ON\")\noption(THRUST_ENABLE_BENCHMARKS \"Build Thrust runtime benchmarks.\" \"OFF\")\noption(THRUST_INCLUDE_CUB_CMAKE \"Build CUB tests and examples. (Requires CUDA).\" \"OFF\")\n\n# Mark this option as advanced for now. We'll revisit this later once the new\n# benchmarks are ready. For now, we just need to expose a way to compile\n# bench.cu from CMake for NVIDIA's internal builds.\nmark_as_advanced(THRUST_ENABLE_BENCHMARKS)\n\n# Check if we're actually building anything before continuing. If not, no need\n# to search for deps, etc. This is a common approach for packagers that just\n# need the install rules. See GH issue NVIDIA/thrust#1211.\nif (NOT (THRUST_ENABLE_HEADER_TESTING OR\n         THRUST_ENABLE_TESTING OR\n         THRUST_ENABLE_EXAMPLES OR\n         THRUST_ENABLE_BENCHMARKS OR\n         THRUST_INCLUDE_CUB_CMAKE))\n  return()\nendif()\n\ninclude(cmake/AppendOptionIfAvailable.cmake)\ninclude(cmake/ThrustBuildCompilerTargets.cmake)\ninclude(cmake/ThrustBuildTargetList.cmake)\ninclude(cmake/ThrustFindThrust.cmake)\ninclude(cmake/ThrustMultiConfig.cmake)\ninclude(cmake/ThrustUtilities.cmake)\n\n# Add cache string options for CMAKE_BUILD_TYPE and default to RelWithDebInfo.\nif (\"\" STREQUAL \"${CMAKE_BUILD_TYPE}\")\n  set(CMAKE_BUILD_TYPE \"RelWithDebInfo\" CACHE STRING \"Choose the type of build.\" FORCE)\n\n  set_property(\n    CACHE CMAKE_BUILD_TYPE\n    PROPERTY STRINGS Debug Release RelWithDebInfo MinSizeRel\n  )\nendif ()\n\n# Disable compiler extensions:\nset(CMAKE_CXX_EXTENSIONS OFF)\n\n# Where to put build outputs. Use CMAKE_BINARY_DIR so they'll show up in the\n# top-level project's dir when building Thrust via add_subdirectory.\nset(THRUST_LIBRARY_OUTPUT_DIR \"${CMAKE_BINARY_DIR}/lib\")\nset(THRUST_EXECUTABLE_OUTPUT_DIR \"${CMAKE_BINARY_DIR}/bin\")\n\nthrust_configure_multiconfig()\nthrust_find_thrust()\nthrust_build_compiler_targets()\nthrust_update_system_found_flags()\nif (THRUST_CUDA_FOUND)\n  include(cmake/ThrustCudaConfig.cmake)\nendif()\nthrust_build_target_list()\n\nmessage(STATUS \"CPP system found?  ${THRUST_CPP_FOUND}\")\nmessage(STATUS \"CUDA system found? ${THRUST_CUDA_FOUND}\")\nmessage(STATUS \"TBB system found?  ${THRUST_TBB_FOUND}\")\nmessage(STATUS \"OMP system found?  ${THRUST_OMP_FOUND}\")\n\nif (THRUST_ENABLE_HEADER_TESTING)\n  include(cmake/ThrustHeaderTesting.cmake)\nendif()\n\n# Both testing and examples use ctest\nif (THRUST_ENABLE_TESTING OR THRUST_ENABLE_EXAMPLES)\n  include(CTest)\n  enable_testing()\nendif()\n\nif (THRUST_ENABLE_TESTING)\n  add_subdirectory(testing)\nendif()\n\nif (THRUST_ENABLE_EXAMPLES)\n  add_subdirectory(examples)\nendif()\n\nif (THRUST_ENABLE_BENCHMARKS)\n  add_subdirectory(internal/benchmark)\nendif()\n\nif (THRUST_INCLUDE_CUB_CMAKE AND THRUST_CUDA_FOUND)\n  set(CUB_IN_THRUST ON)\n  # CUB's path is specified generically to support both GitHub and Perforce\n  # source tree layouts. The include directory used by cub-config.cmake\n  # for source layouts is the same as the project root.\n  add_subdirectory(\"${_CUB_INCLUDE_DIR}\" dependencies/cub)\nendif()\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.7236328125,
          "content": "# Code of Conduct\n\n## Overview\n\nThis document defines the Code of Conduct followed and enforced for NVIDIA C++\n  Core Compute Libraries.\n\n### Intended Audience\n\n* Community\n* Developers\n* Project Leads\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\n  contributors and maintainers pledge to making participation in our project and\n  our community a harassment-free experience for everyone, regardless of age,\n  body size, disability, ethnicity, sex characteristics, gender identity and\n  expression, level of experience, education, socio-economic status, nationality,\n  personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n- Using welcoming and inclusive language.\n- Being respectful of differing viewpoints and experiences.\n- Gracefully accepting constructive criticism.\n- Focusing on what is best for the community.\n- Showing empathy towards other community members.\n\nExamples of unacceptable behavior by participants include:\n\n- The use of sexualized language or imagery and unwelcome sexual attention or\n    advances.\n- Trolling, insulting/derogatory comments, and personal or political attacks.\n- Public or private harassment.\n- Publishing others’ private information, such as a physical or electronic\n    address, without explicit permission.\n- Other conduct which could reasonably be considered inappropriate.\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\n  behavior and are expected to take appropriate and fair corrective action in\n  response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\n  reject comments, commits, code, wiki edits, issues, and other contributions\n  that are not aligned to this Code of Conduct, or to ban temporarily or\n  permanently any contributor for other behaviors that they deem inappropriate,\n  threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\n  when an individual is representing the project or its community.\nExamples of representing a project or community include using an official\n  project email address, posting via an official social media account, or acting\n  as an appointed representative at an online or offline event.\nRepresentation of a project may be further defined and clarified by project\n  maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\n  reported by contacting [cpp-conduct@nvidia.com](mailto:cpp-conduct@nvidia.com).\nAll complaints will be reviewed and investigated and will result in a response\n  that is deemed necessary and appropriate to the circumstances.\nThe project team is obligated to maintain confidentiality with regard to the\n  reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\n  faith may face temporary or permanent repercussions as determined by other\n  members of the project’s leadership.\n\n## Attribution\n\nThis Code of Conduct was taken from the [NVIDIA RAPIDS] project, which was\n  adapted from the [Contributor Covenant version 1.4].\n\nPlease see this [FAQ] for answers to common questions about this Code of Conduct.\n\n## Contact\n\nPlease email [cpp-conduct@nvidia.com] for any Code of Conduct related matters.\n\n\n[cpp-conduct@nvidia.com]: mailto:cpp-conduct@nvidia.com\n\n[FAQ]: https://www.contributor-covenant.org/faq\n\n[NVIDIA RAPIDS]: https://docs.rapids.ai/resources/conduct/\n[Contributor Covenant version 1.4]: https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 13.640625,
          "content": "Unless otherwise noted, Thrust's source code is released under the Apache\nLicense, Version 2.0:\n\n================================================================================\n\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n================================================================================\n\nSome portions of Thrust may be licensed under other compatible open-source\nlicenses. Any divergence from the Apache 2 license will be noted in the source\ncode where applicable.\n\nPortions under other terms include, but are not limited to:\n\n================================================================================\n\nVarious C++ utility classes in Thrust are based on the Boost Iterator, Tuple,\nSystem, and Random Number libraries, which are provided under the Boost Software\nLicense:\n\n    Boost Software License - Version 1.0 - August 17th, 2003\n\n    Permission is hereby granted, free of charge, to any person or organization\n    obtaining a copy of the software and accompanying documentation covered by\n    this license (the \"Software\") to use, reproduce, display, distribute,\n    execute, and transmit the Software, and to prepare derivative works of the\n    Software, and to permit third-parties to whom the Software is furnished to\n    do so, all subject to the following:\n\n    The copyright notices in the Software and this entire statement, including\n    the above license grant, this restriction and the following disclaimer,\n    must be included in all copies of the Software, in whole or in part, and\n    all derivative works of the Software, unless such copies or derivative\n    works are solely in the form of machine-executable object code generated by\n    a source language processor.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n    DEALINGS IN THE SOFTWARE.\n\n================================================================================\n\nPortions of the thrust::complex implementation are derived from FreeBSD with the\nfollowing terms:\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice[1] unmodified, this list of conditions, and the following\n       disclaimer.\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in the\n       documentation and/or other materials provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n    IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n    NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n[1] Individual copyright notices from the original authors are included in\n    the relevant source files.\n\n================================================================================\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.4619140625,
          "content": "# Copyright 2010-2020 NVIDIA Corporation.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#\t\thttp://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Makefile for building Thrust unit test driver\n\n# Force C++11 mode. NVCC will ignore it if the host compiler doesn't support it.\nexport CXX_STD := c++11\n\nexport CCCL_ENABLE_DEPRECATIONS := 1\n\nexport VERBOSE := 1\n\nifndef PROFILE\n  ifdef VULCAN_TOOLKIT_BASE\n    include $(VULCAN_TOOLKIT_BASE)/build/getprofile.mk\n    include $(VULCAN_TOOLKIT_BASE)/build/config/$(PROFILE).mk\n  else\n    include ../build/getprofile.mk\n    include ../build/config/$(PROFILE).mk\n  endif\nendif\n\nSOLNDIR := .\n\nifdef VULCAN_TOOLKIT_BASE\n  include $(VULCAN_TOOLKIT_BASE)/build/config/DetectOS.mk\nelse\n  include ../build/config/DetectOS.mk\nendif\n\nTMP_DIR      := built\nTMP_PREFIX   := $(ROOTDIR)\nTMP_ARCH     := $(ARCH)_$(PROFILE)_agnostic\nTHRUST_MKDIR := $(TMP_PREFIX)/$(TMP_DIR)/$(TMP_ARCH)/thrust/mk\nTHRUST_DIR   := $(ROOTDIR)/thrust\n\nres:=$(shell $(PYTHON) ./generate_mk.py $(THRUST_MKDIR) $(THRUST_DIR))\n\n# Use these environment variables to control what gets built:\n#\n#   TEST_ALL\n#   TEST_UNITTESTS\n#   TEST_EXAMPLES\n#   TEST_BENCH\n#   TEST_OTHER\n\nifneq ($(TEST_ALL),)\n  override TEST_UNITTESTS := 1\n  override TEST_EXAMPLES := 1\n  override TEST_BENCH := 1\n  override TEST_OTHER := 1\nendif\n\nifeq ($(TEST_UNITTESTS)$(TEST_EXAMPLES)$(TEST_BENCH)$(TEST_OTHER),)\n  override TEST_UNITTESTS := 1\n  override TEST_EXAMPLES := 1\n  override TEST_BENCH := 1\n  override TEST_OTHER := 1\nendif\n\nifneq ($(TEST_OTHER),)\n  PROJECTS += internal/build/warningstester\nendif\n\nifneq ($(TEST_BENCH),)\n  PROJECTS += internal/benchmark/bench\nendif\n\nifneq ($(TEST_UNITTESTS),)\n  # copy existing projects\n  PROJECTS_COPY := $(PROJECTS)\n\n  # empty PROJECTS\n  PROJECTS :=\n\n  # populate PROJECTS with unit tests.\n  include $(THRUST_MKDIR)/testing.mk\n\n  # Once PROJECTS is populated with unit tests, re-add the previous projects.\n  PROJECTS += $(PROJECTS_COPY)\nendif\n\nifneq ($(TEST_EXAMPLES),)\n  # Copy existing projects.\n  PROJECTS_COPY := $(PROJECTS)\n\n  # Empty PROJECTS.\n  PROJECTS :=\n\n  # Populate PROJECTS with examples.\n  include $(THRUST_MKDIR)/examples.mk\n\n  # Once PROJECTS is populated with examples, re-add the previous projects.\n  PROJECTS += $(PROJECTS_COPY)\nendif\n\nifdef VULCAN_TOOLKIT_BASE\n  include $(VULCAN_TOOLKIT_BASE)/build/common.mk\nelse\n  include ../build/common.mk\nendif\n\nifeq ($(OS), win32)\n  CREATE_DVS_PACKAGE = $(ZIP) -r built/CUDA-thrust-package.zip bin thrust/internal/test thrust/internal/scripts thrust/internal/benchmark $(DVS_COMMON_TEST_PACKAGE_FILES)\n  APPEND_H_DVS_PACKAGE = $(ZIP) -rg built/CUDA-thrust-package.zip thrust -9 -i *.h\n  APPEND_INL_DVS_PACKAGE = $(ZIP) -rg built/CUDA-thrust-package.zip thrust -9 -i *.inl\n  APPEND_CUH_DVS_PACKAGE = $(ZIP) -rg built/CUDA-thrust-package.zip thrust -9 -i *.cuh\n  MAKE_DVS_PACKAGE = $(CREATE_DVS_PACKAGE) && $(APPEND_H_DVS_PACKAGE) && $(APPEND_INL_DVS_PACKAGE) && $(APPEND_CUH_DVS_PACKAGE)\nelse\n  TAR_FILES = bin thrust/internal/test thrust/internal/scripts thrust/internal/benchmark $(DVS_COMMON_TEST_PACKAGE_FILES)\n  TAR_FILES += `find -L thrust \\( -name \"*.cuh\" -o -name \"*.h\" -o -name \"*.inl\" \\)`\n  MAKE_DVS_PACKAGE = tar -I bzip2 -chvf built/CUDA-thrust-package.tar.bz2 $(TAR_FILES)\nendif\n\nCOPY_CUB_FOR_PACKAGING = rm -rf cub && cp -rp ../cub/cub cub\n\nDVS_OPTIONS :=\n\nifneq ($(TARGET_ARCH),$(HOST_ARCH))\n  DVS_OPTIONS += TARGET_ARCH=$(TARGET_ARCH)\nendif\nifeq ($(TARGET_ARCH),ARMv7)\n  DVS_OPTIONS += ABITYPE=$(ABITYPE)\nendif\n\nTHRUST_DVS_BUILD = release\n\npack:\n\t$(COPY_CUB_FOR_PACKAGING)\n\tcd .. && $(MAKE_DVS_PACKAGE)\n\ndvs:\n\t$(COPY_CUB_FOR_PACKAGING)\n# Build the CUDA Runtime in GVS, because GVS has no CUDA Runtime component.\n# This is a temporary workaround until the Tegra team adds a CUDA Runtime\n# component, which they have promised to do.\nifdef GVS\n\t$(MAKE) $(DVS_OPTIONS) -s -C ../cuda $(THRUST_DVS_BUILD)\nendif\n\t$(MAKE) $(DVS_OPTIONS) $(THRUST_DVS_BUILD) THRUST_DVS=1\n\tcd .. && $(MAKE_DVS_PACKAGE)\n\ndvs_release:\n\t$(MAKE) dvs THRUST_DVS_BUILD=release\n\ndvs_debug:\n\t$(MAKE) dvs THRUST_DVS_BUILD=debug\n\ninclude $(THRUST_MKDIR)/dependencies.mk\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.4736328125,
          "content": ":warning: **The Thrust repository has been archived and is now part of the unified [nvidia/cccl repository](https://github.com/nvidia/cccl). See the [announcement here](https://github.com/NVIDIA/cccl/discussions/520) for more information. Please visit the new repository for the latest updates.** :warning:\n\n# Thrust: The C++ Parallel Algorithms Library\n\n<table><tr>\n<th><b><a href=\"https://github.com/nvidia/thrust/tree/main/examples\">Examples</a></b></th>\n<th><b><a href=\"https://godbolt.org/z/8E8W764E6\">Godbolt</a></b></th>\n<th><b><a href=\"https://nvidia.github.io/thrust\">Documentation</a></b></th>\n</tr></table>\n\nThrust is the C++ parallel algorithms library which inspired the introduction\n  of parallel algorithms to the C++ Standard Library.\nThrust's **high-level** interface greatly enhances programmer **productivity**\n  while enabling performance portability between GPUs and multicore CPUs.\nIt builds on top of established parallel programming frameworks (such as CUDA,\n  TBB, and OpenMP).\nIt also provides a number of general-purpose facilities similar to those found\n  in the C++ Standard Library.\n\nThe NVIDIA C++ Standard Library is an open source project; it is available on\n  [GitHub] and included in the NVIDIA HPC SDK and CUDA Toolkit.\nIf you have one of those SDKs installed, no additional installation or compiler\n  flags are needed to use libcu++.\n\n## Examples\n\nThrust is best learned through examples.\n\nThe following example generates random numbers serially and then transfers them\n  to a parallel device where they are sorted.\n\n```cuda\n#include <thrust/host_vector.h>\n#include <thrust/device_vector.h>\n#include <thrust/generate.h>\n#include <thrust/sort.h>\n#include <thrust/copy.h>\n#include <thrust/random.h>\n\nint main() {\n  // Generate 32M random numbers serially.\n  thrust::default_random_engine rng(1337);\n  thrust::uniform_int_distribution<int> dist;\n  thrust::host_vector<int> h_vec(32 << 20);\n  thrust::generate(h_vec.begin(), h_vec.end(), [&] { return dist(rng); });\n\n  // Transfer data to the device.\n  thrust::device_vector<int> d_vec = h_vec;\n\n  // Sort data on the device.\n  thrust::sort(d_vec.begin(), d_vec.end());\n\n  // Transfer data back to host.\n  thrust::copy(d_vec.begin(), d_vec.end(), h_vec.begin());\n}\n```\n\n[See it on Godbolt](https://godbolt.org/z/GeWEd8Er9)\n\nThis example demonstrates computing the sum of some random numbers in parallel:\n\n```cuda\n#include <thrust/host_vector.h>\n#include <thrust/device_vector.h>\n#include <thrust/generate.h>\n#include <thrust/reduce.h>\n#include <thrust/functional.h>\n#include <thrust/random.h>\n\nint main() {\n  // Generate random data serially.\n  thrust::default_random_engine rng(1337);\n  thrust::uniform_real_distribution<double> dist(-50.0, 50.0);\n  thrust::host_vector<double> h_vec(32 << 20);\n  thrust::generate(h_vec.begin(), h_vec.end(), [&] { return dist(rng); });\n\n  // Transfer to device and compute the sum.\n  thrust::device_vector<double> d_vec = h_vec;\n  double x = thrust::reduce(d_vec.begin(), d_vec.end(), 0, thrust::plus<int>());\n}\n```\n\n[See it on Godbolt](https://godbolt.org/z/cnsbWWME7)\n\nThis example show how to perform such a reduction asynchronously:\n\n```cuda\n#include <thrust/host_vector.h>\n#include <thrust/device_vector.h>\n#include <thrust/generate.h>\n#include <thrust/async/copy.h>\n#include <thrust/async/reduce.h>\n#include <thrust/functional.h>\n#include <thrust/random.h>\n#include <numeric>\n\nint main() {\n  // Generate 32M random numbers serially.\n  thrust::default_random_engine rng(123456);\n  thrust::uniform_real_distribution<double> dist(-50.0, 50.0);\n  thrust::host_vector<double> h_vec(32 << 20);\n  thrust::generate(h_vec.begin(), h_vec.end(), [&] { return dist(rng); });\n\n  // Asynchronously transfer to the device.\n  thrust::device_vector<double> d_vec(h_vec.size());\n  thrust::device_event e = thrust::async::copy(h_vec.begin(), h_vec.end(),\n                                               d_vec.begin());\n\n  // After the transfer completes, asynchronously compute the sum on the device.\n  thrust::device_future<double> f0 = thrust::async::reduce(thrust::device.after(e),\n                                                           d_vec.begin(), d_vec.end(),\n                                                           0.0, thrust::plus<double>());\n\n  // While the sum is being computed on the device, compute the sum serially on\n  // the host.\n  double f1 = std::accumulate(h_vec.begin(), h_vec.end(), 0.0, thrust::plus<double>());\n}\n```\n\n[See it on Godbolt](https://godbolt.org/z/be54efaKj)\n\n## Getting The Thrust Source Code\n\nThrust is a header-only library; there is no need to build or install the project\nunless you want to run the Thrust unit tests.\n\nThe CUDA Toolkit provides a recent release of the Thrust source code in\n`include/thrust`. This will be suitable for most users.\n\nUsers that wish to contribute to Thrust or try out newer features should\nrecursively clone the Thrust Github repository:\n\n```\ngit clone --recursive https://github.com/NVIDIA/thrust.git\n```\n\n## Using Thrust From Your Project\n\nFor CMake-based projects, we provide a CMake package for use with\n`find_package`. See the [CMake README](thrust/cmake/README.md) for more\ninformation. Thrust can also be added via `add_subdirectory` or tools like\nthe [CMake Package Manager](https://github.com/cpm-cmake/CPM.cmake).\n\nFor non-CMake projects, compile with:\n- The Thrust include path (`-I<thrust repo root>`)\n- The libcu++ include path (`-I<thrust repo root>/dependencies/libcudacxx/`)\n- The CUB include path, if using the CUDA device system (`-I<thrust repo root>/dependencies/cub/`)\n- By default, the CPP host system and CUDA device system are used.\n  These can be changed using compiler definitions:\n  - `-DTHRUST_HOST_SYSTEM=THRUST_HOST_SYSTEM_XXX`,\n     where `XXX` is `CPP` (serial, default), `OMP` (OpenMP), or `TBB` (Intel TBB)\n  - `-DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_SYSTEM_XXX`, where `XXX` is\n    `CPP`, `OMP`, `TBB`, or `CUDA` (default).\n\n## Developing Thrust\n\nThrust uses the [CMake build system] to build unit tests, examples, and header\n  tests.\nTo build Thrust as a developer, it is recommended that you use our\n  containerized development system:\n\n```bash\n# Clone Thrust and CUB repos recursively:\ngit clone --recursive https://github.com/NVIDIA/thrust.git\ncd thrust\n\n# Build and run tests and examples:\nci/local/build.bash\n```\n\nThat does the equivalent of the following, but in a clean containerized\n  environment which has all dependencies installed:\n\n```bash\n# Clone Thrust and CUB repos recursively:\ngit clone --recursive https://github.com/NVIDIA/thrust.git\ncd thrust\n\n# Create build directory:\nmkdir build\ncd build\n\n# Configure -- use one of the following:\ncmake ..   # Command line interface.\nccmake ..  # ncurses GUI (Linux only).\ncmake-gui  # Graphical UI, set source/build directories in the app.\n\n# Build:\ncmake --build . -j ${NUM_JOBS} # Invokes make (or ninja, etc).\n\n# Run tests and examples:\nctest\n```\n\nBy default, a serial `CPP` host system, `CUDA` accelerated device system, and\n  C++14 standard are used.\nThis can be changed in CMake and via flags to `ci/local/build.bash`\n\nMore information on configuring your Thrust build and creating a pull request\n  can be found in the [contributing section].\n\n## Licensing\n\nThrust is an open source project developed on [GitHub].\nThrust is distributed under the [Apache License v2.0 with LLVM Exceptions];\n  some parts are distributed under the [Apache License v2.0] and the\n  [Boost License v1.0].\n\n## CI Status\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-gpu-build/CXX_TYPE=gcc,CXX_VER=9,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-gpu-build/CXX_TYPE=gcc,CXX_VER=9,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20GCC%209%20build%20and%20device%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=11,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=11,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20GCC%2011%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=10,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=10,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20GCC%2010%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=9,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=9,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20GCC%209%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=8,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=8,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20GCC%208%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=7,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=7,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20GCC%207%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=6,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=6,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20GCC%206%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=5,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=gcc,CXX_VER=5,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20GCC%205%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=12,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=12,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20Clang%2012%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=11,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=11,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20Clang%2011%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=10,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=10,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20Clang%2010%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=9,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=9,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20Clang%209%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=8,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=8,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20Clang%208%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=7,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=clang,CXX_VER=7,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20Clang%207%20build%20and%20host%20tests'></a>\n\n<a href='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=icc,CXX_VER=latest,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/'><img src='https://gpuci.gpuopenanalytics.com/job/nvidia/job/thrust/job/branch/job/thrust-cpu-build/CXX_TYPE=icc,CXX_VER=latest,OS_TYPE=ubuntu,OS_VER=20.04,SDK_TYPE=cuda,SDK_VER=11.7.0-devel/badge/icon?subject=NVCC%2011.7.0%20%2B%20ICC%20build%20and%20host%20tests'></a>\n\n\n\n[GitHub]: https://github.com/nvidia/thrust\n\n[CMake section]: https://nvidia.github.io/thrust/setup/cmake_options.html\n[contributing section]: https://nvidia.github.io/thrust/contributing.html\n\n[CMake build system]: https://cmake.org\n\n[Apache License v2.0 with LLVM Exceptions]: https://llvm.org/LICENSE.txt\n[Apache License v2.0]: https://www.apache.org/licenses/LICENSE-2.0.txt\n[Boost License v1.0]: https://www.boost.org/LICENSE_1_0.txt\n\n"
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "dependencies",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "generate_mk.py",
          "type": "blob",
          "size": 4.39453125,
          "content": "#!/usr/bin/env python\n# Generate set of projects mk files. \n# Usage: python generate_mk.py PROJECTS_MK_DIR  THRUST_SOURCE_DIR\n#   The program scans through unit tests and examples in THRUST_SOURCE_DIR\n#   and generates project mk for each of the tests and examples in PROJECTS_MK_DIR\n#   A single example or unit test source file generates its own executable\n#   This program is called by a top level Makefile, but can also be used stand-alone for debugging\n#   This program also generates testing.mk, examples.mk and dependencies.mk\nfrom __future__ import print_function\nimport sys\nimport shutil as sh\nimport os\nimport glob\nimport re\n\ntest_template = \"\"\"\nTEST_SRC   := %(TEST_SRC)s\nTEST_NAME  := %(TEST_NAME)s\ninclude $(ROOTDIR)/thrust/internal/build/generic_test.mk\n\"\"\"\nexample_template = \"\"\"\nEXAMPLE_SRC   := %(EXAMPLE_SRC)s\nEXAMPLE_NAME  := %(EXAMPLE_NAME)s\ninclude $(ROOTDIR)/thrust/internal/build/generic_example.mk\n\"\"\"\n\ndef Glob(pattern, directory,exclude='\\B'):\n    src = glob.glob(os.path.join(directory,pattern))\n    p = re.compile(exclude)\n    src = [s for s in src if not p.match(s)]\n    return src\n\n\ndef generate_test_mk(mk_path, test_path, group, TEST_DIR):\n    print('Generating makefiles in \"'+mk_path+'\" for tests in \"'+test_path+'\"')\n    src_cu  = Glob(\"*.cu\",  test_path, \".*testframework.cu$\")\n    src_cxx = Glob(\"*.cpp\", test_path)\n    src_cu.sort();\n    src_cxx.sort();\n    src_all = src_cu + src_cxx;\n    tests_all = []\n    dependencies_all = []\n    for s in src_all:\n        fn = os.path.splitext(os.path.basename(s));\n        t = \"thrust.\"+group+\".\"+fn[0]\n        e = fn[1]\n        mkfile = test_template % {\"TEST_SRC\" : s,  \"TEST_NAME\" : t}\n        f = open(os.path.join(mk_path,t+\".mk\"), 'w')\n        f.write(mkfile)\n        f.close()\n        tests_all.append(os.path.join(mk_path,t))\n        dependencies_all.append(t+\": testframework\")\n    return [tests_all, dependencies_all]\n\ndef generate_example_mk(mk_path, example_path, group, EXAMPLE_DIR):\n    print('Generating makefiles in \"'+mk_path+'\" for examples in \"'+example_path+'\"')\n    src_cu  = Glob(\"*.cu\",  example_path)\n    src_cxx = Glob(\"*.cpp\", example_path)\n    src_cu.sort();\n    src_cxx.sort();\n    src_all = src_cu + src_cxx;\n    examples_all = []\n    for s in src_all:\n        fn = os.path.splitext(os.path.basename(s));\n        t = \"thrust.\"+group+\".\"+fn[0]\n        e = fn[1]\n        mkfile = example_template % {\"EXAMPLE_SRC\" : s, \"EXAMPLE_NAME\" : t}\n        f = open(os.path.join(mk_path,t+\".mk\"), 'w')\n        f.write(mkfile)\n        f.close()\n        examples_all.append(os.path.join(mk_path,t))\n    return examples_all\n\n\n## relpath : backported from os.relpath form python 2.6+\ndef relpath(path, start):\n    \"\"\"Return a relative version of a path\"\"\"\n\n    import posixpath\n    if not path:\n        raise ValueError(\"no path specified\")\n    start_list = posixpath.abspath(start).split(posixpath.sep)\n    path_list = posixpath.abspath(path).split(posixpath.sep)\n    # Work out how much of the filepath is shared by start and path.\n    i = len(posixpath.commonprefix([start_list, path_list]))\n    rel_list = [posixpath.pardir] * (len(start_list)-i) + path_list[i:]\n    if not rel_list:\n        return posixpath.curdir\n    return posixpath.join(*rel_list)\n\nmk_path=sys.argv[1]\nREL_DIR=\"../../\"\nif (len(sys.argv) > 2):\n    root_path=sys.argv[2];\n    mk_path = relpath(mk_path, root_path)\n    REL_DIR = relpath(root_path,mk_path)\n\ntry:\n    sh.rmtree(mk_path)\nexcept:\n    pass\nos.makedirs(mk_path)\n\ntests_all, dependencies_all = generate_test_mk(mk_path, \"testing/\", \"test\", REL_DIR)\ntests_cu,  dependencies_cu  = generate_test_mk(mk_path, \"testing/cuda/\", \"test.cuda\", REL_DIR)\ntests_all.extend(tests_cu)\ndependencies_all.extend(dependencies_cu)\n\ntesting_mk  = \"\"\n\nfor t in tests_all:\n    testing_mk += \"PROJECTS += \"+t+\"\\n\"\ntesting_mk += \"PROJECTS += internal/build/testframework\\n\"\n\n\nf = open(os.path.join(mk_path,\"testing.mk\"),'w')\nf.write(testing_mk)\nf.close()\n\ndependencies_mk = \"\"\nfor d in dependencies_all:\n    dependencies_mk += d + \"\\n\"\n\nf = open(os.path.join(mk_path,\"dependencies.mk\"),'w')\nf.write(dependencies_mk)\nf.close()\n\n\nexamples_mk = \"\"\nexamples_all  = generate_example_mk(mk_path, \"examples/\", \"example\", REL_DIR)\nexamples_cuda = generate_example_mk(mk_path, \"examples/cuda/\", \"example.cuda\", REL_DIR)\nexamples_all.extend(examples_cuda)\nfor e in examples_all:\n    examples_mk += \"PROJECTS += \"+e+\"\\n\"\n\nf = open(os.path.join(mk_path,\"examples.mk\"),'w')\nf.write(examples_mk)\nf.close()\n\n\n\n\n\n\n\n\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "thrust",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}