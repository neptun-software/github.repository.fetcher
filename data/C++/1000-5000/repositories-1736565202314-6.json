{
  "metadata": {
    "timestamp": 1736565202314,
    "page": 6,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "itinance/react-native-fs",
      "stars": 4982,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".flowconfig",
          "type": "blob",
          "size": 2.322265625,
          "content": "[ignore]\n; We fork some components by platform\n.*/*[.]android.js\n\n; Ignore \"BUCK\" generated dirs\n<PROJECT_ROOT>/\\.buckd/\n\n; Ignore unexpected extra \"@providesModule\"\n.*/node_modules/.*/node_modules/fbjs/.*\n\n; Ignore duplicate module providers\n; For RN Apps installed via npm, \"Libraries\" folder is inside\n; \"node_modules/react-native\" but in the source repo it is in the root\n.*/Libraries/react-native/React.js\n\n; Ignore polyfills\n.*/Libraries/polyfills/.*\n\n; Ignore metro\n.*/node_modules/metro/.*\n\n; Ignore react-native-windows\n.*/node_modules/react-native-windows/.*\n\n[include]\n\n[libs]\nnode_modules/react-native/Libraries/react-native/react-native-interface.js\nnode_modules/react-native/flow/\nnode_modules/react-native/flow-github/\n\n[options]\nemoji=true\n\nesproposal.optional_chaining=enable\nesproposal.nullish_coalescing=enable\n\nmodule.system=haste\nmodule.system.haste.use_name_reducers=true\n# get basename\nmodule.system.haste.name_reducers='^.*/\\([a-zA-Z0-9$_.-]+\\.js\\(\\.flow\\)?\\)$' -> '\\1'\n# strip .js or .js.flow suffix\nmodule.system.haste.name_reducers='^\\(.*\\)\\.js\\(\\.flow\\)?$' -> '\\1'\n# strip .ios suffix\nmodule.system.haste.name_reducers='^\\(.*\\)\\.ios$' -> '\\1'\nmodule.system.haste.name_reducers='^\\(.*\\)\\.android$' -> '\\1'\nmodule.system.haste.name_reducers='^\\(.*\\)\\.native$' -> '\\1'\nmodule.system.haste.paths.blacklist=.*/__tests__/.*\nmodule.system.haste.paths.blacklist=.*/__mocks__/.*\nmodule.system.haste.paths.blacklist=<PROJECT_ROOT>/node_modules/react-native/Libraries/Animated/src/polyfills/.*\nmodule.system.haste.paths.whitelist=<PROJECT_ROOT>/node_modules/react-native/Libraries/.*\n\nmunge_underscores=true\n\nmodule.name_mapper='^[./a-zA-Z0-9$_-]+\\.\\(bmp\\|gif\\|jpg\\|jpeg\\|png\\|psd\\|svg\\|webp\\|m4v\\|mov\\|mp4\\|mpeg\\|mpg\\|webm\\|aac\\|aiff\\|caf\\|m4a\\|mp3\\|wav\\|html\\|pdf\\)$' -> 'RelativeImageStub'\n\nmodule.file_ext=.js\nmodule.file_ext=.jsx\nmodule.file_ext=.json\nmodule.file_ext=.native.js\n\nsuppress_type=$FlowIssue\nsuppress_type=$FlowFixMe\nsuppress_type=$FlowFixMeProps\nsuppress_type=$FlowFixMeState\n\nsuppress_comment=\\\\(.\\\\|\\n\\\\)*\\\\$FlowFixMe\\\\($\\\\|[^(]\\\\|(\\\\(<VERSION>\\\\)? *\\\\(site=[a-z,_]*react_native[a-z,_]*\\\\)?)\\\\)\nsuppress_comment=\\\\(.\\\\|\\n\\\\)*\\\\$FlowIssue\\\\((\\\\(<VERSION>\\\\)? *\\\\(site=[a-z,_]*react_native[a-z,_]*\\\\)?)\\\\)?:? #[0-9]+\nsuppress_comment=\\\\(.\\\\|\\n\\\\)*\\\\$FlowFixedInNextDeploy\nsuppress_comment=\\\\(.\\\\|\\n\\\\)*\\\\$FlowExpectedError\n\n[version]\n0.109.0\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.4443359375,
          "content": "node_modules\nworkbench\n*.log\n# Xcode\n.DS_Store\nbuild/\n*.pbxuser\n!default.pbxuser\n*.mode1v3\n!default.mode1v3\n*.mode2v3\n!default.mode2v3\n*.perspectivev3\n!default.perspectivev3\n*.xcworkspace\n!default.xcworkspace\nxcuserdata\nprofile\n*.moved-aside\nDerivedData\n.idea/\n# Pods - for those of you who use CocoaPods\nPods\nupdate-test.sh\n.vscode/\nandroid/.gradle/*\nandroid/gradle/*\nandroid/*.iml\nandroid/local.properties\nandroid/.settings\nandroid/.project\nSession.vim\n"
        },
        {
          "name": ".jshintrc",
          "type": "blob",
          "size": 1.3837890625,
          "content": "{\n  \"-W093\": true,\n  \"asi\": false,\n  \"bitwise\": true,\n  \"boss\": false,\n  \"browser\": false,\n  \"camelcase\": true,\n  \"couch\": false,\n  \"curly\": true,\n  \"debug\": false,\n  \"devel\": true,\n  \"dojo\": false,\n  \"eqeqeq\": true,\n  \"eqnull\": false,\n  \"esnext\": true,\n  \"evil\": false,\n  \"expr\": true,\n  \"forin\": false,\n  \"freeze\": true,\n  \"funcscope\": true,\n  \"gcl\": false,\n  \"globalstrict\": true,\n  \"immed\": false,\n  \"indent\": 2,\n  \"iterator\": false,\n  \"jquery\": false,\n  \"lastsemic\": false,\n  \"latedef\": false,\n  \"laxbreak\": true,\n  \"laxcomma\": false,\n  \"loopfunc\": false,\n  \"maxcomplexity\": false,\n  \"maxdepth\": false,\n  \"maxerr\": 50,\n  \"maxlen\": 80,\n  \"maxparams\": false,\n  \"maxstatements\": false,\n  \"mootools\": false,\n  \"moz\": false,\n  \"multistr\": false,\n  \"newcap\": true,\n  \"noarg\": true,\n  \"node\": true,\n  \"noempty\": true,\n  \"nonbsp\": true,\n  \"nonew\": true,\n  \"nonstandard\": false,\n  \"notypeof\": false,\n  \"noyield\": false,\n  \"phantom\": false,\n  \"plusplus\": false,\n  \"predef\": [\n    \"jasmine\",\n    \"describe\",\n    \"beforeEach\",\n    \"it\",\n    \"jest\",\n    \"pit\",\n    \"expect\",\n    \"rootRequire\"\n  ],\n  \"proto\": false,\n  \"prototypejs\": false,\n  \"quotmark\": true,\n  \"rhino\": false,\n  \"scripturl\": false,\n  \"shadow\": false,\n  \"smarttabs\": false,\n  \"strict\": true,\n  \"sub\": false,\n  \"supernew\": false,\n  \"trailing\": true,\n  \"undef\": true,\n  \"unused\": true,\n  \"validthis\": false,\n  \"worker\": false,\n  \"wsh\": false,\n  \"yui\": false\n}\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 6.861328125,
          "content": "# Changelog\n\n## Changes for v2.20\n\n- #1037 Invalidate upload session\n\n## Changes vor v2.19\n\n- #1048  fix: use correct type for stat size #1048\n- #1063 RNFSManager:readDir iOS crash fix #1063\n- #1036 fix: addListener and removeListeners methods wass added to pass warning with Native Event Emitter #1036\n- RNFSManager iOS crash in readDir\n- fix: use correct type for stat size\n- make react-native-windows peer dependency optional #1016\n\n## Changes for v2.17\n\n- #938 Manually flush & invalidate session upon completion\n- #954 Switch to using channels for byte copying.\n- #962 Size limit with copyAssetsVideoIOS\n- #963 Add basic support for Android content URIs in stat\n- #972 Manually flush & invalidate completed session\n- #974 Add content for copyAssetsFileIOS method\n- #975 Fix copyAssetsFileIOS's image resizing option to resize to exact width and height\n- #985 README.md: clarify usage of readFileRes\n- #986 macOS support\n\n## Changes for v2.16\n- #797 Added path to the Android download folder\n- #842 Fixes #811 Concurrent downloads send progress updates to all progress callbacks\n- #783 Import RCTImageLoaderProtocol instead of RCTImageLoader to fix iOS build on RN>0.60\n\n## Changes for v2.15\n- #717 bugfix #443: Add option progressInterval for downloadFile \n- #759 Fix for issue #749: RNFS.uploadFiles upload raw not multipart \n- #728 Correctly read binaryStreamOnly param\n- #752 Fix Xcode and Java deprecation warnings \n- #779 Add conditional comments around methods not supported in Mac Catalyst\n- #736 Added support for ph:// uris to copyAssetsFileIOS\n\n## Changes for v2.14\n- #718 Add tvOS deployment target to podspec\n- #710 Added existsRes function to Android\n- #702 Fix: S3 pre signed uploads or similar binary stream uploads writing corrupt files\n- #695 Added .Net46 side of windows support\n- #691 Add `androidx` suppport\n- #669 Changed \"size\" from Int to Double\n- #660 add a custom error for cancelled downloadFile Requests\n\n## Changes for v2.13\n- #544 [Android] Add scanFile method\n- #597 [Android] Perform copyFile in background thread to prevent UI blocking\n- #587 [Windows] Fixed implementation for Windows\n- #585 [Android] Fix EISDIR on stat directory\n- #583 [Android] fix Android downloadFile overflow contentLength and bytesWritten\n\n## Changes for v2.12\n- #601 [iOS] Another fix for copyAssetsVideoIOS\n- #599 [iOS] Fix for copyAssetsVideoIOS regarding iCloud-Files\n- #564 [Android] Upgrade to Gradle 3 (BREAKING compatiblity for < RN 0.57)\n- #571 [Android] Fix issue #566 android progress callback not sync and handle uppercase file extension mimetype\n\n## Changes for v2.11\n- Prepared for RN 0.56 thanx to [#535](https://github.com/itinance/react-native-fs/pull/535) by [rmevans9](https://github.com/rmevans9)\n- #503 make sure to return the original file uri if content:// scheme is not used\n- #510 Fixes an IndexOutOfBounds while uploading files in Android\n- #515 Add cacheable option to downloadFile on iOScompletion callback\n- #516 [iOS] Ensure _bytesWritten is correct in download\n- #519 updated compilesdkversion and buildtoolsversion\n- #535 Make this work with RN56\n- #558 [Android] fixed missing parameter in movefile and writefile\n- #557 [Android] copyFile: fix missing parameter on Android\n- #564 [Android] Replace deprecated 'compile' gradle configuration with 'implementation\n\n## Changes for v2.10\n- UploadFiles is now also available for Android [#486](https://github.com/itinance/react-native-fs/pull/486) by [hank121314](https://github.com/hank121314)\n- Fixed a memory leak that caused after running many simultaneous upload jobs on iOS [#502](https://github.com/itinance/react-native-fs/pull/502) by [Ignigena](https://github.com/Ignigena)\n- Android: Resolve filepath for content URI [480](https://github.com/itinance/react-native-fs/pull/480) by [andtos90](https://github.com/andtos90)\n- (Android only) Add ExternalCachesDirectoryPath [490](https://github.com/itinance/react-native-fs/pull/490) by [superandrew213](https://github.com/superandrew213)\n\n## Changes for v2.9\n- (iOS only) Resumable downloads and better background downloads handling [#335](https://github.com/itinance/react-native-fs/pull/335) by [ptelad](https://github.com/ptelad)\n- (Android only) getAllExternalFilesDirs() added by [ngrj](https://github.com/ngrj)\n- Content URI support [#395](https://github.com/itinance/react-native-fs/pull/395) by [krzysztof-miemiec](https://github.com/krzysztof-miemiec)\n- Fixed Cocoapods-Installation\n\n## Changes for v2.8\n- Fix for [#346](https://github.com/itinance/react-native-fs/pull/347): compressed file assets are detected as directories thx to [jacargentina](https://github.com/jacargentina)\n- added support for Video-Assets on iOS (copyAssetsVideoIOS) and setReadable() on Android by [itinance](https://github.com/itinance)\n- Added react-native-windows support for UWP [#337](https://github.com/itinance/react-native-fs/pull/337) thx to [rozele](https://github.com/rozele)\n- Expose the iOS `discretionary` flag on `downloadFile` [#360](https://github.com/itinance/react-native-fs/pull/360) thx to [jamesreggio](https://github.com/jamesreggio)\n\n## Changes for v2.5\n- breaking change for RN 0.47 at android (https://github.com/facebook/react-native/releases/tag/v0.47.0)\n\n## Changes for v2.4\n- Made new thread for other native processes [ANDROID] (https://github.com/itinance/react-native-fs/commit/ad36b078db9728489155a55c1b7daa42ed191945) thx to [codesinghanoop](https://github.com/codesinghanoop)\n- Upgrade gradle build tools to 25 (https://github.com/itinance/react-native-fs/commit/239bccb9d56fe9308daafb86920ed29eb9e5cfe4) thx to [markusguenther](https://github.com/markusguenther)\n- Fixed Podfile Path-Error (https://github.com/itinance/react-native-fs/commit/9fd51e7e977400f3194c100af88b4c25e7510530) thx to [colorfulberry](https://github.com/colorfulberry)\n- Add read-method with length and position params (https://github.com/itinance/react-native-fs/commit/a39c22be81f0c1f2263dbe60f3cd6cfcc902d2ac) thx to [simitti](https://github.com/simitii)\n\n## Changes for v2.3\n\n- React-Native 0.40 is minimum required for compiling on iOS (otherwise install an older release, see below)\n- Access to iOS-based \"assets-library\" is now supported with `copyAssetsFileIOS`\n- `readDir` will return now creation- and modification-time of files as with `stat()` (thanks @Ignigena)\n- optional connectionTimeout and readTimeout-Settings on `downloadFile` for Android (thanks @drunksaint)\n\n## Breaking change in v2.0\n\n- Removed attributes from `writeFile` and `appendFile` for iOS / Android consistency\n- `downloadFile` takes `options` object rather than parameters\n- `stopDownload` will cause the rejection of promise returned by `downloadFile`\n- `uploadFiles` promise result `response` property is now `body`\n- A boolean is no longer returned from any method except `exists`\n- `downloadFile` and `uploadFiles` return an object of the form `{ jobId: number, promise: Promise }`\n- `mkdir` takes optional 2nd parameter `options` for iOS users to set the `NSURLIsExcludedFromBackupKey` attribute\n"
        },
        {
          "name": "Downloader.h",
          "type": "blob",
          "size": 1.9111328125,
          "content": "#import <Foundation/Foundation.h>\n\ntypedef void (^DownloadCompleteCallback)(NSNumber*, NSNumber*);\ntypedef void (^ErrorCallback)(NSError*);\ntypedef void (^BeginCallback)(NSNumber*, NSNumber*, NSDictionary*);\ntypedef void (^ProgressCallback)(NSNumber*, NSNumber*);\ntypedef void (^ResumableCallback)(void);\n\n@interface RNFSDownloadParams : NSObject\n\n@property (copy) NSString* fromUrl;\n@property (copy) NSString* toFile;\n@property (copy) NSDictionary* headers;\n@property (copy) DownloadCompleteCallback completeCallback;   // Download has finished (data written)\n@property (copy) ErrorCallback errorCallback;                 // Something went wrong\n@property (copy) BeginCallback beginCallback;                 // Download has started (headers received)\n@property (copy) ProgressCallback progressCallback;           // Download is progressing\n@property (copy) ResumableCallback resumableCallback;         // Download has stopped but is resumable\n@property        bool background;                             // Whether to continue download when app is in background\n@property        bool discretionary;                          // Whether the file may be downloaded at the OS's discretion (iOS only)\n@property        bool cacheable;                              // Whether the file may be stored in the shared NSURLCache (iOS only)\n@property (copy) NSNumber* progressInterval;\n@property (copy) NSNumber* progressDivider;\n@property (copy) NSNumber* readTimeout;                       // How long (in milliseconds) a task should wait for additional data to arrive before giving up\n@property (copy) NSNumber* backgroundTimeout;                 // How long (in milliseconds) to wait for an entire resource to transfer before giving up\n\n\n@end\n\n@interface RNFSDownloader : NSObject <NSURLSessionDelegate, NSURLSessionDownloadDelegate>\n\n- (NSString *)downloadFile:(RNFSDownloadParams*)params;\n- (void)stopDownload;\n- (void)resumeDownload;\n- (BOOL)isResumable;\n\n@end\n"
        },
        {
          "name": "Downloader.m",
          "type": "blob",
          "size": 7.123046875,
          "content": "#import \"Downloader.h\"\n\n@implementation RNFSDownloadParams\n\n@end\n\n@interface RNFSDownloader()\n\n@property (copy) RNFSDownloadParams* params;\n\n@property (retain) NSURLSession* session;\n@property (retain) NSURLSessionDownloadTask* task;\n@property (retain) NSNumber* statusCode;\n@property (assign) NSTimeInterval lastProgressEmitTimestamp;\n@property (retain) NSNumber* lastProgressValue;\n@property (retain) NSNumber* contentLength;\n@property (retain) NSNumber* bytesWritten;\n@property (retain) NSData* resumeData;\n\n@property (retain) NSFileHandle* fileHandle;\n\n@end\n\n@implementation RNFSDownloader\n\n- (NSString *)downloadFile:(RNFSDownloadParams*)params\n{\n    NSString *uuid = nil;\n\n    _params = params;\n\n  _lastProgressEmitTimestamp = 0;\n  _bytesWritten = 0;\n\n  NSURL* url = [NSURL URLWithString:_params.fromUrl];\n\n  if ([[NSFileManager defaultManager] fileExistsAtPath:_params.toFile]) {\n    _fileHandle = [NSFileHandle fileHandleForWritingAtPath:_params.toFile];\n\n    if (!_fileHandle) {\n      NSError* error = [NSError errorWithDomain:@\"Downloader\" code:NSURLErrorFileDoesNotExist\n                                userInfo:@{NSLocalizedDescriptionKey: [NSString stringWithFormat: @\"Failed to write target file at path: %@\", _params.toFile]}];\n\n      _params.errorCallback(error);\n      return nil;\n    } else {\n      [_fileHandle closeFile];\n    }\n  }\n\n  NSURLSessionConfiguration *config;\n  if (_params.background) {\n    uuid = [[NSUUID UUID] UUIDString];\n    config = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:uuid];\n    config.discretionary = _params.discretionary;\n  } else {\n    config = [NSURLSessionConfiguration defaultSessionConfiguration];\n  }\n\n  if (!_params.cacheable) {\n    config.URLCache = nil;\n  }\n\n  config.HTTPAdditionalHeaders = _params.headers;\n  config.timeoutIntervalForRequest = [_params.readTimeout intValue] / 1000.0;\n  config.timeoutIntervalForResource = [_params.backgroundTimeout intValue] / 1000.0;\n\n  _session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil];\n  _task = [_session downloadTaskWithURL:url];\n  [_task resume];\n\n    return uuid;\n}\n\n- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite\n{\n  NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)downloadTask.response;\n  if (_params.beginCallback && !_statusCode) {\n    _statusCode = [NSNumber numberWithLong:httpResponse.statusCode];\n    _contentLength = [NSNumber numberWithLong:httpResponse.expectedContentLength];\n    return _params.beginCallback(_statusCode, _contentLength, httpResponse.allHeaderFields);\n  }\n\n  if (_params.progressCallback && [_statusCode isEqualToNumber:[NSNumber numberWithInt:200]]) {\n    _bytesWritten = @(totalBytesWritten);\n\n    if(_params.progressInterval.integerValue > 0){\n      NSTimeInterval timestamp = [[NSDate date] timeIntervalSince1970];\n      if(timestamp - _lastProgressEmitTimestamp > _params.progressInterval.integerValue / 1000.0){\n        _lastProgressEmitTimestamp = timestamp;\n        return _params.progressCallback(_contentLength, _bytesWritten);\n      }\n    }else if (_params.progressDivider.integerValue <= 0) {\n      return _params.progressCallback(_contentLength, _bytesWritten);\n    } else {\n      double doubleBytesWritten = (double)[_bytesWritten longValue];\n      double doubleContentLength = (double)[_contentLength longValue];\n      double doublePercents = doubleBytesWritten / doubleContentLength * 100;\n      NSNumber* progress = [NSNumber numberWithUnsignedInt: floor(doublePercents)];\n      if ([progress unsignedIntValue] % [_params.progressDivider integerValue] == 0) {\n        if (([progress unsignedIntValue] != [_lastProgressValue unsignedIntValue]) || ([_bytesWritten unsignedIntegerValue] == [_contentLength longValue])) {\n            NSLog(@\"---Progress callback EMIT--- %u\", [progress unsignedIntValue]);\n          _lastProgressValue = [NSNumber numberWithUnsignedInt:[progress unsignedIntValue]];\n          return _params.progressCallback(_contentLength, _bytesWritten);\n        }\n      }\n    }\n  }\n}\n\n- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location\n{\n  NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)downloadTask.response;\n  if (!_statusCode) {\n    _statusCode = [NSNumber numberWithLong:httpResponse.statusCode];\n  }\n  NSURL *destURL = [NSURL fileURLWithPath:_params.toFile];\n  NSFileManager *fm = [NSFileManager defaultManager];\n  NSError *error = nil;\n  if([_statusCode integerValue] >= 200 && [_statusCode integerValue] < 300) {\n    [fm removeItemAtURL:destURL error:nil];       // Remove file at destination path, if it exists\n    [fm moveItemAtURL:location toURL:destURL error:&error];\n    // There are no guarantees about how often URLSession:downloadTask:didWriteData: will fire,\n    // so we read an authoritative number of bytes written here.\n    _bytesWritten = @([fm attributesOfItemAtPath:_params.toFile error:nil].fileSize);\n  }\n  if (error) {\n    NSLog(@\"RNFS download: unable to move tempfile to destination. %@, %@\", error, error.userInfo);\n  }\n\n  // When numerous downloads are called the sessions are not always invalidated and cleared by iOS14. \n  // This leads to error 28 – no space left on device so we manually flush and invalidate to free up space\n  if(session != nil){\n    [session flushWithCompletionHandler:^{\n      [session finishTasksAndInvalidate];\n    }];\n  }\n\n  return _params.completeCallback(_statusCode, _bytesWritten);\n}\n\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error\n{\n  if (error) {\n    NSLog(@\"RNFS download: didCompleteWithError %@, %@\", error, error.userInfo);\n    if (error.code != NSURLErrorCancelled) {\n      _resumeData = error.userInfo[NSURLSessionDownloadTaskResumeData];\n      if (_resumeData != nil) {\n        if (_params.resumableCallback) {\n            _params.resumableCallback();\n        }\n      } else {\n          _params.errorCallback(error);\n      }\n    }\n  }\n}\n\n- (void)stopDownload\n{\n  if (_task.state == NSURLSessionTaskStateRunning) {\n    [_task cancelByProducingResumeData:^(NSData * _Nullable resumeData) {\n        if (resumeData != nil) {\n            self.resumeData = resumeData;\n            if (self->_params.resumableCallback) {\n                self->_params.resumableCallback();\n            }\n        } else {\n            NSError *error = [NSError errorWithDomain:@\"RNFS\"\n                                                 code:0 //used to pass an NSString @\"Aborted\" here, but it needs an NSInteger\n                                             userInfo:@{\n                                                        NSLocalizedDescriptionKey: @\"Download has been aborted\"\n                                                        }];\n\n            self->_params.errorCallback(error);\n        }\n    }];\n\n  }\n}\n\n- (void)resumeDownload\n{\n    if (_resumeData != nil) {\n        _task = [_session downloadTaskWithResumeData:_resumeData];\n        [_task resume];\n        _resumeData = nil;\n    }\n}\n\n- (BOOL)isResumable\n{\n    return _resumeData != nil;\n}\n\n@end\n"
        },
        {
          "name": "Examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "FS.common.js",
          "type": "blob",
          "size": 23.8662109375,
          "content": "/**\n * React Native FS\n * @flow\n */\n\n'use strict';\n\n// This file supports both iOS and Android\n\nvar RNFSManager = require('react-native').NativeModules.RNFSManager;\n\nvar NativeEventEmitter = require('react-native').NativeEventEmitter;\n\nvar RNFS_NativeEventEmitter = new NativeEventEmitter(RNFSManager);\n\nvar base64 = require('base-64');\nvar utf8 = require('utf8');\nvar isIOS = require('react-native').Platform.OS === 'ios';\nvar isWindows = require('react-native').Platform.OS === 'windows'; // To accommodate Windows\n\nvar RNFSFileTypeRegular = RNFSManager.RNFSFileTypeRegular;\nvar RNFSFileTypeDirectory = RNFSManager.RNFSFileTypeDirectory;\n\nvar jobId = 0;\n\nvar getJobId = () => {\n  jobId += 1;\n  return jobId;\n};\n\nvar normalizeFilePath = (path: string) => (path.startsWith('file://') ? path.slice(7) : path);\n\ntype MkdirOptions = {\n  NSURLIsExcludedFromBackupKey?: boolean; // iOS only\n  NSFileProtectionKey?: string; // IOS only\n};\n\ntype FileOptions = {\n  NSFileProtectionKey?: string; // IOS only\n};\n\ntype ReadDirItem = {\n  ctime: ?Date;    // The creation date of the file (iOS only)\n  mtime: ?Date;    // The last modified date of the file\n  name: string;     // The name of the item\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n\ntype StatResult = {\n  name: ?string;     // The name of the item TODO: why is this not documented?\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes\n  mode: number;     // UNIX file mode\n  ctime: number;    // Created date\n  mtime: number;    // Last modified date\n  originalFilepath: string;    // In case of content uri this is the pointed file path, otherwise is the same as path\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n\ntype Headers = { [name: string]: string };\ntype Fields = { [name: string]: string };\n\ntype DownloadFileOptions = {\n  fromUrl: string;          // URL to download file from\n  toFile: string;           // Local filesystem path to save the file to\n  headers?: Headers;        // An object of headers to be passed to the server\n  background?: boolean;     // Continue the download in the background after the app terminates (iOS only)\n  discretionary?: boolean;  // Allow the OS to control the timing and speed of the download to improve perceived performance  (iOS only)\n  cacheable?: boolean;      // Whether the download can be stored in the shared NSURLCache (iOS only)\n  progressInterval?: number;\n  progressDivider?: number;\n  begin?: (res: DownloadBeginCallbackResult) => void;\n  progress?: (res: DownloadProgressCallbackResult) => void;\n  resumable?: () => void;    // only supported on iOS yet\n  connectionTimeout?: number; // only supported on Android yet\n  readTimeout?: number;       // supported on Android and iOS\n  backgroundTimeout?: number; // Maximum time (in milliseconds) to download an entire resource (iOS only, useful for timing out background downloads)\n};\n\ntype DownloadBeginCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  contentLength: number;  // The total size in bytes of the download resource\n  headers: Headers;       // The HTTP response headers from the server\n};\n\ntype DownloadProgressCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  contentLength: number;  // The total size in bytes of the download resource\n  bytesWritten: number;   // The number of bytes written to the file so far\n};\n\ntype DownloadResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  bytesWritten: number;   // The number of bytes written to the file\n};\n\ntype UploadFileOptions = {\n  toUrl: string;            // URL to upload file to\n  binaryStreamOnly?: boolean; // Allow for binary data stream for file to be uploaded without extra headers, Default is 'false'\n  files: UploadFileItem[];  // An array of objects with the file information to be uploaded.\n  headers?: Headers;        // An object of headers to be passed to the server\n  fields?: Fields;          // An object of fields to be passed to the server\n  method?: string;          // Default is 'POST', supports 'POST' and 'PUT'\n  beginCallback?: (res: UploadBeginCallbackResult) => void; // deprecated\n  progressCallback?: (res: UploadProgressCallbackResult) => void; // deprecated\n  begin?: (res: UploadBeginCallbackResult) => void;\n  progress?: (res: UploadProgressCallbackResult) => void;\n};\n\ntype UploadFileItem = {\n  name: string;       // Name of the file, if not defined then filename is used\n  filename: string;   // Name of file\n  filepath: string;   // Path to file\n  filetype: string;   // The mimetype of the file to be uploaded, if not defined it will get mimetype from `filepath` extension\n};\n\ntype UploadBeginCallbackResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n};\n\ntype UploadProgressCallbackResult = {\n  jobId: number;                      // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  totalBytesExpectedToSend: number;   // The total number of bytes that will be sent to the server\n  totalBytesSent: number;             // The number of bytes sent to the server\n};\n\ntype UploadResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  statusCode: number;   // The HTTP status code\n  headers: Headers;     // The HTTP response headers from the server\n  body: string;         // The HTTP response body\n};\n\ntype FSInfoResult = {\n  totalSpace: number;   // The total amount of storage space on the device (in bytes).\n  freeSpace: number;    // The amount of available storage space on the device (in bytes).\n};\n\n/**\n * Generic function used by readFile and readFileAssets\n */\nfunction readFileGeneric(filepath: string, encodingOrOptions: ?string, command: Function) {\n  var options = {\n    encoding: 'utf8'\n  };\n\n  if (encodingOrOptions) {\n    if (typeof encodingOrOptions === 'string') {\n      options.encoding = encodingOrOptions;\n    } else if (typeof encodingOrOptions === 'object') {\n      options = encodingOrOptions;\n    }\n  }\n\n  return command(normalizeFilePath(filepath)).then((b64) => {\n    var contents;\n\n    if (options.encoding === 'utf8') {\n      contents = utf8.decode(base64.decode(b64));\n    } else if (options.encoding === 'ascii') {\n      contents = base64.decode(b64);\n    } else if (options.encoding === 'base64') {\n      contents = b64;\n    } else {\n      throw new Error('Invalid encoding type \"' + String(options.encoding) + '\"');\n    }\n\n    return contents;\n  });\n}\n\n/**\n * Generic function used by readDir and readDirAssets\n */\nfunction readDirGeneric(dirpath: string, command: Function) {\n  return command(normalizeFilePath(dirpath)).then(files => {\n    return files.map(file => ({\n      ctime: file.ctime && new Date(file.ctime * 1000) || null,\n      mtime: file.mtime && new Date(file.mtime * 1000) || null,\n      name: file.name,\n      path: file.path,\n      size: file.size,\n      isFile: () => file.type === RNFSFileTypeRegular,\n      isDirectory: () => file.type === RNFSFileTypeDirectory,\n    }));\n  });\n}\n\nvar RNFS = {\n\n  mkdir(filepath: string, options: MkdirOptions = {}): Promise<void> {\n    return RNFSManager.mkdir(normalizeFilePath(filepath), options).then(() => void 0);\n  },\n\n  moveFile(filepath: string, destPath: string, options: FileOptions = {}): Promise<void> {\n    return RNFSManager.moveFile(normalizeFilePath(filepath), normalizeFilePath(destPath), options).then(() => void 0);\n  },\n\n  copyFile(filepath: string, destPath: string, options: FileOptions = {}): Promise<void> {\n    return RNFSManager.copyFile(normalizeFilePath(filepath), normalizeFilePath(destPath), options).then(() => void 0);\n  },\n\n  // Windows workaround for slow copying of large folders of files\n  copyFolder(filepath: string, destPath: string): Promise<void> {\n    if(isWindows) {\n      return RNFSManager.copyFolder(normalizeFilePath(filepath), normalizeFilePath(destPath));\n    }\n  },\n\n  pathForBundle(bundleNamed: string): Promise<string> {\n    return RNFSManager.pathForBundle(bundleNamed);\n  },\n\n  pathForGroup(groupName: string): Promise<string> {\n    return RNFSManager.pathForGroup(groupName);\n  },\n\n  getFSInfo(): Promise<FSInfoResult> {\n    return RNFSManager.getFSInfo();\n  },\n\n  getAllExternalFilesDirs(): Promise<string> {\n    return RNFSManager.getAllExternalFilesDirs();\n  },\n\n  unlink(filepath: string): Promise<void> {\n    return RNFSManager.unlink(normalizeFilePath(filepath)).then(() => void 0);\n  },\n\n  exists(filepath: string): Promise<boolean> {\n    return RNFSManager.exists(normalizeFilePath(filepath));\n  },\n\n  stopDownload(jobId: number): void {\n    RNFSManager.stopDownload(jobId);\n  },\n\n  resumeDownload(jobId: number): void {\n    RNFSManager.resumeDownload(jobId);\n  },\n\n  isResumable(jobId: number): Promise<bool> {\n    return RNFSManager.isResumable(jobId);\n  },\n\n  stopUpload(jobId: number): void {\n    RNFSManager.stopUpload(jobId);\n  },\n\n  completeHandlerIOS(jobId: number): void {\n    return RNFSManager.completeHandlerIOS(jobId);\n  },\n\n  readDir(dirpath: string): Promise<ReadDirItem[]> {\n    return readDirGeneric(dirpath, RNFSManager.readDir);\n  },\n\n  // Android-only\n  readDirAssets(dirpath: string): Promise<ReadDirItem[]> {\n    if (!RNFSManager.readDirAssets) {\n      throw new Error('readDirAssets is not available on this platform');\n    }\n    return readDirGeneric(dirpath, RNFSManager.readDirAssets);\n  },\n\n  // Android-only\n  existsAssets(filepath: string) {\n    if (!RNFSManager.existsAssets) {\n      throw new Error('existsAssets is not available on this platform');\n    }\n    return RNFSManager.existsAssets(filepath);\n  },\n\n  // Android-only\n  existsRes(filename: string) {\n    if (!RNFSManager.existsRes) {\n      throw new Error('existsRes is not available on this platform');\n    }\n    return RNFSManager.existsRes(filename);\n  },\n\n  // Node style version (lowercase d). Returns just the names\n  readdir(dirpath: string): Promise<string[]> {\n    return RNFS.readDir(normalizeFilePath(dirpath)).then(files => {\n      return files.map(file => file.name);\n    });\n  },\n\n  // setReadable for Android\n  setReadable(filepath: string, readable: boolean, ownerOnly: boolean): Promise<boolean> {\n    return RNFSManager.setReadable(filepath, readable, ownerOnly).then((result) => {\n      return result;\n    })\n  },\n\n  stat(filepath: string): Promise<StatResult> {\n    return RNFSManager.stat(normalizeFilePath(filepath)).then((result) => {\n      return {\n        'path': filepath,\n        'ctime': new Date(result.ctime * 1000),\n        'mtime': new Date(result.mtime * 1000),\n        'size': result.size,\n        'mode': result.mode,\n        'originalFilepath': result.originalFilepath,\n        isFile: () => result.type === RNFSFileTypeRegular,\n        isDirectory: () => result.type === RNFSFileTypeDirectory,\n      };\n    });\n  },\n\n  readFile(filepath: string, encodingOrOptions?: any): Promise<string> {\n    return readFileGeneric(filepath, encodingOrOptions, RNFSManager.readFile);\n  },\n\n  read(filepath: string, length: number = 0, position: number = 0, encodingOrOptions?: any): Promise<string> {\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    return RNFSManager.read(normalizeFilePath(filepath), length, position).then((b64) => {\n      var contents;\n\n      if (options.encoding === 'utf8') {\n        contents = utf8.decode(base64.decode(b64));\n      } else if (options.encoding === 'ascii') {\n        contents = base64.decode(b64);\n      } else if (options.encoding === 'base64') {\n        contents = b64;\n      } else {\n        throw new Error('Invalid encoding type \"' + String(options.encoding) + '\"');\n      }\n\n      return contents;\n    });\n  },\n\n  // Android only\n  readFileAssets(filepath: string, encodingOrOptions?: any): Promise<string> {\n    if (!RNFSManager.readFileAssets) {\n      throw new Error('readFileAssets is not available on this platform');\n    }\n    return readFileGeneric(filepath, encodingOrOptions, RNFSManager.readFileAssets);\n  },\n\n  // Android only\n  readFileRes(filename: string, encodingOrOptions?: any): Promise<string> {\n    if (!RNFSManager.readFileRes) {\n      throw new Error('readFileRes is not available on this platform');\n    }\n    return readFileGeneric(filename, encodingOrOptions, RNFSManager.readFileRes);\n  },\n\n  hash(filepath: string, algorithm: string): Promise<string> {\n    return RNFSManager.hash(normalizeFilePath(filepath), algorithm);\n  },\n\n  // Android only\n  copyFileAssets(filepath: string, destPath: string) {\n    if (!RNFSManager.copyFileAssets) {\n      throw new Error('copyFileAssets is not available on this platform');\n    }\n    return RNFSManager.copyFileAssets(normalizeFilePath(filepath), normalizeFilePath(destPath)).then(() => void 0);\n  },\n\n  // Android only\n  copyFileRes(filename: string, destPath: string) {\n    if (!RNFSManager.copyFileRes) {\n      throw new Error('copyFileRes is not available on this platform');\n    }\n    return RNFSManager.copyFileRes(filename, normalizeFilePath(destPath)).then(() => void 0);\n  },\n\n  // iOS only\n  // Copies fotos from asset-library (camera-roll) to a specific location\n  // with a given width or height\n  // @see: https://developer.apple.com/reference/photos/phimagemanager/1616964-requestimageforasset\n  copyAssetsFileIOS(imageUri: string, destPath: string, width: number, height: number,\n    scale: number = 1.0, compression: number = 1.0, resizeMode: string = 'contain'): Promise<string> {\n    return RNFSManager.copyAssetsFileIOS(imageUri, destPath, width, height, scale, compression, resizeMode);\n  },\n\n  // iOS only\n  // Copies fotos from asset-library (camera-roll) to a specific location\n  // with a given width or height\n  // @see: https://developer.apple.com/reference/photos/phimagemanager/1616964-requestimageforasset\n  copyAssetsVideoIOS(imageUri: string, destPath: string): Promise<string> {\n    return RNFSManager.copyAssetsVideoIOS(imageUri, destPath);\n  },\n\n  writeFile(filepath: string, contents: string, encodingOrOptions?: any): Promise<void> {\n    var b64;\n\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = {\n          ...options,\n          ...encodingOrOptions\n        };\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.writeFile(normalizeFilePath(filepath), b64, options).then(() => void 0);\n  },\n\n  appendFile(filepath: string, contents: string, encodingOrOptions?: any): Promise<void> {\n    var b64;\n\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.appendFile(normalizeFilePath(filepath), b64);\n  },\n\n  write(filepath: string, contents: string, position?: number, encodingOrOptions?: any): Promise<void> {\n    var b64;\n\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    if (position === undefined) {\n      position = -1;\n    }\n\n    return RNFSManager.write(normalizeFilePath(filepath), b64, position).then(() => void 0);\n  },\n\n  downloadFile(options: DownloadFileOptions): { jobId: number, promise: Promise<DownloadResult> } {\n    if (typeof options !== 'object') throw new Error('downloadFile: Invalid value for argument `options`');\n    if (typeof options.fromUrl !== 'string') throw new Error('downloadFile: Invalid value for property `fromUrl`');\n    if (typeof options.toFile !== 'string') throw new Error('downloadFile: Invalid value for property `toFile`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('downloadFile: Invalid value for property `headers`');\n    if (options.background && typeof options.background !== 'boolean') throw new Error('downloadFile: Invalid value for property `background`');\n    if (options.progressDivider && typeof options.progressDivider !== 'number') throw new Error('downloadFile: Invalid value for property `progressDivider`');\n    if (options.progressInterval && typeof options.progressInterval !== 'number') throw new Error('downloadFile: Invalid value for property `progressInterval`');\n    if (options.readTimeout && typeof options.readTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `readTimeout`');\n    if (options.connectionTimeout && typeof options.connectionTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `connectionTimeout`');\n    if (options.backgroundTimeout && typeof options.backgroundTimeout !== 'number') throw new Error('downloadFile: Invalid value for property `backgroundTimeout`');\n\n    var jobId = getJobId();\n    var subscriptions = [];\n\n    if (options.begin) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadBegin', (res) => {\n        if (res.jobId === jobId) options.begin(res);\n      }));\n    }\n\n    if (options.progress) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadProgress', (res) => {\n        if (res.jobId === jobId) options.progress(res);\n      }));\n    }\n\n    if (options.resumable) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('DownloadResumable', (res) => {\n        if (res.jobId === jobId) options.resumable(res);\n      }));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      fromUrl: options.fromUrl,\n      toFile: normalizeFilePath(options.toFile),\n      headers: options.headers || {},\n      background: !!options.background,\n      progressDivider: options.progressDivider || 0,\n      progressInterval: options.progressInterval || 0,\n      readTimeout: options.readTimeout || 15000,\n      connectionTimeout: options.connectionTimeout || 5000,\n      backgroundTimeout: options.backgroundTimeout || 3600000, // 1 hour\n      hasBeginCallback: options.begin instanceof Function,\n      hasProgressCallback: options.progress instanceof Function,\n      hasResumableCallback: options.resumable instanceof Function,\n    };\n\n    return {\n      jobId,\n      promise: RNFSManager.downloadFile(bridgeOptions).then(res => {\n        subscriptions.forEach(sub => sub.remove());\n        return res;\n      })\n        .catch(e => {\n          return Promise.reject(e);\n        })\n    };\n  },\n\n  uploadFiles(options: UploadFileOptions): { jobId: number, promise: Promise<UploadResult> } {\n    if (!RNFSManager.uploadFiles) {\n      return {\n        jobId: -1,\n        promise: Promise.reject(new Error('`uploadFiles` is unsupported on this platform'))\n      };\n    }\n\n    var jobId = getJobId();\n    var subscriptions = [];\n\n    if (typeof options !== 'object') throw new Error('uploadFiles: Invalid value for argument `options`');\n    if (typeof options.toUrl !== 'string') throw new Error('uploadFiles: Invalid value for property `toUrl`');\n    if (!Array.isArray(options.files)) throw new Error('uploadFiles: Invalid value for property `files`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('uploadFiles: Invalid value for property `headers`');\n    if (options.fields && typeof options.fields !== 'object') throw new Error('uploadFiles: Invalid value for property `fields`');\n    if (options.method && typeof options.method !== 'string') throw new Error('uploadFiles: Invalid value for property `method`');\n\n    if (options.begin) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadBegin', options.begin));\n    } else if (options.beginCallback) {\n      // Deprecated\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadBegin', options.beginCallback));\n    }\n\n    if (options.progress) {\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadProgress', options.progress));\n    } else if (options.progressCallback) {\n      // Deprecated\n      subscriptions.push(RNFS_NativeEventEmitter.addListener('UploadProgress', options.progressCallback));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      toUrl: options.toUrl,\n      files: options.files,\n      binaryStreamOnly: options.binaryStreamOnly || false,\n      headers: options.headers || {},\n      fields: options.fields || {},\n      method: options.method || 'POST',\n      hasBeginCallback: options.begin instanceof Function || options.beginCallback instanceof Function,\n      hasProgressCallback: options.progress instanceof Function || options.progressCallback instanceof Function,\n    };\n\n    return {\n      jobId,\n      promise: RNFSManager.uploadFiles(bridgeOptions).then(res => {\n        subscriptions.forEach(sub => sub.remove());\n        return res;\n      })\n    };\n  },\n\n  touch(filepath: string, mtime?: Date, ctime?: Date, Creation?: boolean): Promise<void> {\n    if (ctime && !(ctime instanceof Date)) throw new Error('touch: Invalid value for argument `ctime`');\n    if (mtime && !(mtime instanceof Date)) throw new Error('touch: Invalid value for argument `mtime`');\n    var ctimeTime = 0;\n    if (isIOS || isWindows) { // Modified to accommodate Windows\n      ctimeTime = ctime && ctime.getTime();\n    }\n    if (isWindows) {\n      var modifyCreationTime = !ctime ? false: true;\n      return RNFSManager.touch(\n        normalizeFilePath(filepath),\n        mtime && mtime.getTime(),\n        ctimeTime,\n        modifyCreationTime\n      );\n    }\n    else {\n      return RNFSManager.touch(\n        normalizeFilePath(filepath),\n        mtime && mtime.getTime(),\n        ctimeTime\n      );\n    }\n  },\n\n  scanFile(path: string): Promise<ReadDirItem[]> {\n    return RNFSManager.scanFile(path);\n  },\n\n  MainBundlePath: RNFSManager.RNFSMainBundlePath,\n  CachesDirectoryPath: RNFSManager.RNFSCachesDirectoryPath,\n  ExternalCachesDirectoryPath: RNFSManager.RNFSExternalCachesDirectoryPath,\n  DocumentDirectoryPath: RNFSManager.RNFSDocumentDirectoryPath,\n  DownloadDirectoryPath: RNFSManager.RNFSDownloadDirectoryPath,\n  ExternalDirectoryPath: RNFSManager.RNFSExternalDirectoryPath,\n  ExternalStorageDirectoryPath: RNFSManager.RNFSExternalStorageDirectoryPath,\n  TemporaryDirectoryPath: RNFSManager.RNFSTemporaryDirectoryPath,\n  LibraryDirectoryPath: RNFSManager.RNFSLibraryDirectoryPath,\n  PicturesDirectoryPath: RNFSManager.RNFSPicturesDirectoryPath, // For Windows\n  FileProtectionKeys: RNFSManager.RNFSFileProtectionKeys,\n  RoamingDirectoryPath: RNFSManager.RNFSRoamingDirectoryPath, // For Windows\n};\n\nmodule.exports = RNFS;\n"
        },
        {
          "name": "IntegrationTests",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0556640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Johannes Lumpe\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "NSArray+Map.h",
          "type": "blob",
          "size": 0.2548828125,
          "content": "//\n//  NSArray+Map.h\n//  RNFS\n//\n// taken from http://stackoverflow.com/questions/6127638/nsarray-equivalent-of-map\n\n#import <Foundation/Foundation.h>\n\n@interface NSArray (Map)\n\n- (NSArray *)rnfs_mapObjectsUsingBlock:(id (^)(id obj, NSUInteger idx))block;\n\n@end"
        },
        {
          "name": "NSArray+Map.m",
          "type": "blob",
          "size": 0.3798828125,
          "content": "//\n//  NSArray+Map.m\n//  RNFS\n\n#import \"NSArray+Map.h\"\n\n@implementation NSArray (Map)\n\n- (NSArray *)rnfs_mapObjectsUsingBlock:(id (^)(id obj, NSUInteger idx))block\n{\n  NSMutableArray *result = [NSMutableArray arrayWithCapacity:[self count]];\n\n  [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {\n    [result addObject:block(obj, idx)];\n  }];\n\n  return result;\n}\n\n@end"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.9365234375,
          "content": "# react-native-fs\n\nNative filesystem access for react-native\n\n## IMPORTANT\n\nFor RN < 0.57 and/or Gradle < 3 you MUST install react-native-fs at version @2.11.17!\n\nFor RN >= 0.57 and/or Gradle >= 3 you MUST install react-native-fs at version >= @2.13.2!\n\nFor RN >= 0.61 please install react-native-fs at version >= @2.16.0!\n\n## Table of Contents\n1. [Changelog](#Changelog)\n1. Usage\n    1. [iOS](#usage-ios)\n    1. [Android](#usage-android)\n    1. [Windows](#usage-windows)\n1. [Examples](#Examples)\n1. [API](#API)\n1. [Background Downloads Tutorial (iOS)](#background-downloads-tutorial-ios)\n1. [Test / Demo App](#test--demo-app)\n\n## Changelog\n\nView the changelog [here](https://github.com/itinance/react-native-fs/blob/master/CHANGELOG.md).\n\n## Usage (iOS/macOS)\n\nFirst you need to install react-native-fs:\n\n```\nnpm install react-native-fs --save\n```\n\n**Note:** If your react-native version is < 0.40 install with this tag instead:\n\n```\nnpm install react-native-fs@2.0.1-rc.2 --save\n```\n\nAs @a-koka pointed out, you should then update your package.json to\n`\"react-native-fs\": \"2.0.1-rc.2\"` (without the tilde)\n\n### Adding automatically with react-native link\n\nAt the command line, in your project folder, type:\n\n`react-native link react-native-fs`\n\nDone! No need to worry about manually adding the library to your project.\n\n###  Adding with CocoaPods\n\n Add the RNFS pod to your list of application pods in your Podfile, using the path from the Podfile to the installed module:~~\n\n```\npod 'RNFS', :path => '../node_modules/react-native-fs'\n```\n\nInstall pods as usual:\n```\npod install\n```\n\n### Adding Manually in XCode\n\nIn XCode, in the project navigator, right click Libraries ➜ Add Files to [your project's name] Go to node_modules ➜ react-native-fs and add the .xcodeproj file\n\nIn XCode, in the project navigator, select your project. Add the `lib*.a` from the RNFS project to your project's Build Phases ➜ Link Binary With Libraries. Click the .xcodeproj file you added before in the project navigator and go the Build Settings tab. Make sure 'All' is toggled on (instead of 'Basic'). Look for Header Search Paths and make sure it contains both `$(SRCROOT)/../react-native/React` and `$(SRCROOT)/../../React` - mark both as recursive.\n\nRun your project (Cmd+R)\n\n## Usage (Android)\n\nAndroid support is currently limited to only the `DocumentDirectory`. This maps to the app's `files` directory.\n\nMake alterations to the following files:\n\n* `android/settings.gradle`\n\n```gradle\n...\ninclude ':react-native-fs'\nproject(':react-native-fs').projectDir = new File(settingsDir, '../node_modules/react-native-fs/android')\n```\n\n* `android/app/build.gradle`\n\n```gradle\n...\ndependencies {\n    ...\n    implementation project(':react-native-fs')\n}\n```\n\n* register module (in MainActivity.java)\n\n  * For react-native below 0.19.0 (use `cat ./node_modules/react-native/package.json | grep version`)\n\n```java\nimport com.rnfs.RNFSPackage;  // <--- import\n\npublic class MainActivity extends Activity implements DefaultHardwareBackBtnHandler {\n\n  ......\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    mReactRootView = new ReactRootView(this);\n\n    mReactInstanceManager = ReactInstanceManager.builder()\n      .setApplication(getApplication())\n      .setBundleAssetName(\"index.android.bundle\")\n      .setJSMainModuleName(\"index.android\")\n      .addPackage(new MainReactPackage())\n      .addPackage(new RNFSPackage())      // <------- add package\n      .setUseDeveloperSupport(BuildConfig.DEBUG)\n      .setInitialLifecycleState(LifecycleState.RESUMED)\n      .build();\n\n    mReactRootView.startReactApplication(mReactInstanceManager, \"ExampleRN\", null);\n\n    setContentView(mReactRootView);\n  }\n\n  ......\n\n}\n```\n\n  * For react-native 0.19.0 and higher\n```java\nimport com.rnfs.RNFSPackage; // <------- add package\n\npublic class MainActivity extends ReactActivity {\n   // ...\n    @Override\n    protected List<ReactPackage> getPackages() {\n      return Arrays.<ReactPackage>asList(\n        new MainReactPackage(), // <---- add comma\n        new RNFSPackage() // <---------- add package\n      );\n    }\n```\n\n  * For react-native 0.29.0 and higher ( in MainApplication.java )\n```java\nimport com.rnfs.RNFSPackage; // <------- add package\n\npublic class MainApplication extends Application implements ReactApplication {\n   // ...\n    @Override\n    protected List<ReactPackage> getPackages() {\n      return Arrays.<ReactPackage>asList(\n        new MainReactPackage(), // <---- add comma\n        new RNFSPackage() // <---------- add package\n      );\n    }\n```\n\n## Usage (Windows)\n\n### Adding automatically with react-native link\n\nThe `link` command also works for adding the native dependency on Windows:\n\n`react-native link react-native-fs`\n\n### Adding Manually in Visual Studio\n\nFollow the instructions in the ['Linking Libraries'](https://github.com/Microsoft/react-native-windows/blob/master/docs/LinkingLibrariesWindows.md) documentation on the react-native-windows GitHub repo. For the first step of adding the project to the Visual Studio solution file, the path to the project should be `../node_modules/react-native-fs/windows/RNFS/RNFS.csproj`.\n\n## Examples\n\n### Basic\n\n```javascript\n// require the module\nvar RNFS = require('react-native-fs');\n\n// get a list of files and directories in the main bundle\nRNFS.readDir(RNFS.MainBundlePath) // On Android, use \"RNFS.DocumentDirectoryPath\" (MainBundlePath is not defined)\n  .then((result) => {\n    console.log('GOT RESULT', result);\n\n    // stat the first file\n    return Promise.all([RNFS.stat(result[0].path), result[0].path]);\n  })\n  .then((statResult) => {\n    if (statResult[0].isFile()) {\n      // if we have a file, read it\n      return RNFS.readFile(statResult[1], 'utf8');\n    }\n\n    return 'no file';\n  })\n  .then((contents) => {\n    // log the file contents\n    console.log(contents);\n  })\n  .catch((err) => {\n    console.log(err.message, err.code);\n  });\n```\n\n### File creation\n\n```javascript\n// require the module\nvar RNFS = require('react-native-fs');\n\n// create a path you want to write to\n// :warning: on iOS, you cannot write into `RNFS.MainBundlePath`,\n// but `RNFS.DocumentDirectoryPath` exists on both platforms and is writable\nvar path = RNFS.DocumentDirectoryPath + '/test.txt';\n\n// write the file\nRNFS.writeFile(path, 'Lorem ipsum dolor sit amet', 'utf8')\n  .then((success) => {\n    console.log('FILE WRITTEN!');\n  })\n  .catch((err) => {\n    console.log(err.message);\n  });\n\n```\n\n### File deletion\n```javascript\n// create a path you want to delete\nvar path = RNFS.DocumentDirectoryPath + '/test.txt';\n\nreturn RNFS.unlink(path)\n  .then(() => {\n    console.log('FILE DELETED');\n  })\n  // `unlink` will throw an error, if the item to unlink does not exist\n  .catch((err) => {\n    console.log(err.message);\n  });\n```\n\n### File upload (Android and IOS only)\n\n```javascript\n// require the module\nvar RNFS = require('react-native-fs');\n\nvar uploadUrl = 'http://requestb.in/XXXXXXX';  // For testing purposes, go to http://requestb.in/ and create your own link\n// create an array of objects of the files you want to upload\nvar files = [\n  {\n    name: 'test1',\n    filename: 'test1.w4a',\n    filepath: RNFS.DocumentDirectoryPath + '/test1.w4a',\n    filetype: 'audio/x-m4a'\n  }, {\n    name: 'test2',\n    filename: 'test2.w4a',\n    filepath: RNFS.DocumentDirectoryPath + '/test2.w4a',\n    filetype: 'audio/x-m4a'\n  }\n];\n\nvar upload\n= (response) => {\n  var jobId = response.jobId;\n  console.log('UPLOAD HAS BEGUN! JobId: ' + jobId);\n};\n\nvar uploadProgress = (response) => {\n  var percentage = Math.floor((response.totalBytesSent/response.totalBytesExpectedToSend) * 100);\n  console.log('UPLOAD IS ' + percentage + '% DONE!');\n};\n\n// upload files\nRNFS.uploadFiles({\n  toUrl: uploadUrl,\n  files: files,\n  method: 'POST',\n  headers: {\n    'Accept': 'application/json',\n  },\n  fields: {\n    'hello': 'world',\n  },\n  begin: uploadBegin,\n  progress: uploadProgress\n}).promise.then((response) => {\n    if (response.statusCode == 200) {\n      console.log('FILES UPLOADED!'); // response.statusCode, response.headers, response.body\n    } else {\n      console.log('SERVER ERROR');\n    }\n  })\n  .catch((err) => {\n    if(err.description === \"cancelled\") {\n      // cancelled by user\n    }\n    console.log(err);\n  });\n\n```\n\n## API\n\n### Constants\n\nThe following constants are available on the `RNFS` export:\n\n- `MainBundlePath` (`String`) The absolute path to the main bundle directory (not available on Android)\n- `CachesDirectoryPath` (`String`) The absolute path to the caches directory\n- `ExternalCachesDirectoryPath` (`String`) The absolute path to the external caches directory (android only)\n- `DocumentDirectoryPath`  (`String`) The absolute path to the document directory\n- `DownloadDirectoryPath` (`String`) The absolute path to the download directory (on android and Windows only)\n- `TemporaryDirectoryPath` (`String`) The absolute path to the temporary directory (falls back to Caching-Directory on Android)\n- `LibraryDirectoryPath` (`String`) The absolute path to the NSLibraryDirectory (iOS only)\n- `ExternalDirectoryPath` (`String`) The absolute path to the external files, shared directory (android only)\n- `ExternalStorageDirectoryPath` (`String`) The absolute path to the external storage, shared directory (android only)\n- `PicturesDirectoryPath` (`String`) The absolute path to the pictures directory (Windows only)\n- `RoamingDirectoryPath` (`String`) The absolute path to the roaming directory (Windows only)\n\n\nIMPORTANT: when using `ExternalStorageDirectoryPath` it's necessary to request permissions (on Android) to read and write on the external storage, here an example: [React Native Offical Doc](https://facebook.github.io/react-native/docs/permissionsandroid)\n\n### `readDir(dirpath: string): Promise<ReadDirItem[]>`\n\nReads the contents of `path`. This must be an absolute path. Use the above path constants to form a usable file path.\n\nThe returned promise resolves with an array of objects with the following properties:\n\n```js\ntype ReadDirItem = {\n  ctime: date;     // The creation date of the file (iOS only)\n  mtime: date;     // The last modified date of the file\n  name: string;     // The name of the item\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes\n  isFile: () => boolean;        // Is the item just a file?\n  isDirectory: () => boolean;   // Is the item a directory?\n};\n```\n\n### `readDirAssets(dirpath: string): Promise<ReadDirItem[]>`\n\nReads the contents of `dirpath ` in the Android app's assets folder.\n`dirpath ` is the relative path to the file from the root of the `assets` folder.\n\nThe returned promise resolves with an array of objects with the following properties:\n\n```js\ntype ReadDirItem = {\n  name: string;     // The name of the item\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes.\n  \t\t\t\t\t\t// Note that the size of files compressed during the creation of the APK (such as JSON files) cannot be determined.\n  \t\t\t\t\t\t// `size` will be set to -1 in this case.\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n```\n\nNote: Android only.\n\n### `readdir(dirpath: string): Promise<string[]>`\n\nNode.js style version of `readDir` that returns only the names. Note the lowercase `d`.\n\n### `stat(filepath: string): Promise<StatResult>`\n\nStats an item at `filepath`. If the `filepath` is linked to a virtual file, for example Android Content URI, the `originalPath` can be used to find the pointed file path.\nThe promise resolves with an object with the following properties:\n\n```js\ntype StatResult = {\n  path:            // The same as filepath argument\n  ctime: date;     // The creation date of the file\n  mtime: date;     // The last modified date of the file\n  size: number;     // Size in bytes\n  mode: number;     // UNIX file mode\n  originalFilepath: string;    // ANDROID: In case of content uri this is the pointed file path, otherwise is the same as path\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n```\n\n### `readFile(filepath: string, encoding?: string): Promise<string>`\n\nReads the file at `path` and return contents. `encoding` can be one of `utf8` (default), `ascii`, `base64`. Use `base64` for reading binary files.\n\nNote: you will take quite a performance hit if you are reading big files\n\n### `read(filepath: string, length = 0, position = 0, encodingOrOptions?: any): Promise<string>`\n\nReads `length` bytes from the given `position` of the file at `path` and returns contents. `encoding` can be one of `utf8` (default), `ascii`, `base64`. Use `base64` for reading binary files.\n\nNote: reading big files piece by piece using this method may be useful in terms of performance.\n\n### `readFileAssets(filepath:string, encoding?: string): Promise<string>`\n\nReads the file at `path` in the Android app's assets folder and return contents. `encoding` can be one of `utf8` (default), `ascii`, `base64`. Use `base64` for reading binary files.\n\n`filepath` is the relative path to the file from the root of the `assets` folder.\n\nNote: Android only.\n\n### `readFileRes(filename:string, encoding?: string): Promise<string>`\n\nReads the file named `filename` in the Android app's `res` folder and return contents. Only the file name (not folder) needs to be specified. The file type will be detected from the extension and automatically located within `res/drawable` (for image files) or `res/raw` (for everything else). `encoding` can be one of `utf8` (default), `ascii`, `base64`. Use `base64` for reading binary files.\n\nNote: Android only.\n\n### `writeFile(filepath: string, contents: string, encoding?: string): Promise<void>`\n\nWrite the `contents` to `filepath`. `encoding` can be one of `utf8` (default), `ascii`, `base64`. `options` optionally takes an object specifying the file's properties, like mode etc.\n\n### `appendFile(filepath: string, contents: string, encoding?: string): Promise<void>`\n\nAppend the `contents` to `filepath`. `encoding` can be one of `utf8` (default), `ascii`, `base64`.\n\n### `write(filepath: string, contents: string, position?: number, encoding?: string): Promise<void>`\n\nWrite the `contents` to `filepath` at the given random access position. When `position` is `undefined` or `-1` the contents is appended to the end of the file. `encoding` can be one of `utf8` (default), `ascii`, `base64`.\n\n### `moveFile(filepath: string, destPath: string): Promise<void>`\n\nMoves the file located at `filepath` to `destPath`. This is more performant than reading and then re-writing the file data because the move is done natively and the data doesn't have to be copied or cross the bridge.\n\nNote: Overwrites existing file in Windows.\n\n### `copyFolder(srcFolderPath: string, destFolderPath: string): Promise<void>`\n\nCopies the contents located at `srcFolderPath` to `destFolderPath`.\n\nNote: Windows only. This method is recommended when directories need to be copied from one place to another.\n\n### `copyFile(filepath: string, destPath: string): Promise<void>`\n\nCopies the file located at `filepath` to `destPath`.\n\nNote: On Android and Windows copyFile will overwrite `destPath` if it already exists. On iOS an error will be thrown if the file already exists.\n\n### `copyFileAssets(filepath: string, destPath: string): Promise<void>`\n\nCopies the file at `filepath` in the Android app's assets folder and copies it to the given `destPath ` path.\n\nNote: Android only. Will overwrite destPath if it already exists.\n\n### `copyFileRes(filename: string, destPath: string): Promise<void>`\n\nCopies the file named `filename` in the Android app's res folder and copies it to the given `destPath ` path. `res/drawable` is used as the source parent folder for image files, `res/raw` for everything else.\n\nNote: Android only. Will overwrite destPath if it already exists.\n\n### (iOS only) `copyAssetsFileIOS(imageUri: string, destPath: string, width: number, height: number, scale?: number, compression?: number, resizeMode?: string): Promise<string>`\n\n*Not available on Mac Catalyst.*\n\nReads an image file from Camera Roll and writes to `destPath`. This method [assumes the image file to be JPEG file](https://github.com/itinance/react-native-fs/blob/f2f8f4a058cd9acfbcac3b8cf1e08fa1e9b09786/RNFSManager.m#L752-L753). This method will download the original from iCloud if necessary.\n\n#### Parameters\n\n##### `imageUri` string (required)\n\nURI of a file in Camera Roll. Can be [either of the following formats](https://github.com/itinance/react-native-fs/blob/f2f8f4a058cd9acfbcac3b8cf1e08fa1e9b09786/RNFSManager.m#L781-L785):\n\n- `ph://CC95F08C-88C3-4012-9D6D-64A413D254B3/L0/001`\n- `assets-library://asset/asset.JPG?id=CC95F08C-88C3-4012-9D6D-64A413D254B3&ext=JPG`\n\n##### `destPath` string (required)\n\nDestination to which the copied file will be saved, e.g. `RNFS.TemporaryDirectoryPath + 'example.jpg'`.\n\n##### `width` number (required)\n\nCopied file's image width will be resized to `width`. [If 0 is provided, width won't be resized.](https://github.com/itinance/react-native-fs/blob/f2f8f4a058cd9acfbcac3b8cf1e08fa1e9b09786/RNFSManager.m#L808)\n\n##### `height` number (required)\n\nCopied file's image height will be resized to `height`. [If 0 is provided, height won't be resized.](https://github.com/itinance/react-native-fs/blob/f2f8f4a058cd9acfbcac3b8cf1e08fa1e9b09786/RNFSManager.m#L808)\n\n##### `scale` number (optional)\n\nCopied file's image will be scaled proportional to `scale` factor from `width` x `height`. If both `width` and `height` are 0, the image won't scale. Range is [0.0, 1.0] and default is 1.0.\n\n##### `compression` number (optional)\n\nQuality of copied file's image. The value 0.0 represents the maximum compression (or lowest quality) while the value 1.0 represents the least compression (or best quality). Range is [0.0, 1.0] and default is 1.0.\n\n##### `resizeMode` string (optional)\n\nIf `resizeMode` is 'contain', copied file's image will be scaled so that its larger dimension fits `width` x `height`. If `resizeMode` is other value than 'contain', the image will be scaled so that it completely fills `width` x `height`. Default is 'contain'. Refer to [PHImageContentMode](https://developer.apple.com/documentation/photokit/phimagecontentmode).\n\n#### Return value\n\n##### `Promise<string>`\n\nCopied file's URI.\n\n#### Video-Support\n\nOne can use this method also to create a thumbNail from a video in a specific size.\nCurrently it is impossible to specify a concrete position, the OS will decide wich\nThumbnail you'll get then.\nTo copy a video from assets-library and save it as a mp4-file, refer to copyAssetsVideoIOS.\n\nFurther information: https://developer.apple.com/reference/photos/phimagemanager/1616964-requestimageforasset\nThe promise will on success return the final destination of the file, as it was defined in the destPath-parameter.\n\n### (iOS only) `copyAssetsVideoIOS(videoUri: string, destPath: string): Promise<string>`\n\n*Not available on Mac Catalyst.*\n\nCopies a video from assets-library, that is prefixed with 'assets-library://asset/asset.MOV?...' to a specific destination.\n\n### `unlink(filepath: string): Promise<void>`\n\nUnlinks the item at `filepath`. If the item does not exist, an error will be thrown.\n\nAlso recursively deletes directories (works like Linux `rm -rf`).\n\n### `exists(filepath: string): Promise<boolean>`\n\nCheck if the item exists at `filepath`. If the item does not exist, return false.\n\n### `existsAssets(filepath: string): Promise<boolean>`\n\nCheck in the Android assets folder if the item exists. `filepath` is the relative path from the root of the assets folder. If the item does not exist, return false.\n\nNote: Android only.\n\n### `existsRes(filename: string): Promise<boolean>`\n\nCheck in the Android res folder if the item named `filename` exists. `res/drawable` is used as the parent folder for image files, `res/raw` for everything else. If the item does not exist, return false.\n\nNote: Android only.\n\n### `hash(filepath: string, algorithm: string): Promise<string>`\n\nReads the file at `path` and returns its checksum as determined by `algorithm`, which can be one of `md5`, `sha1`, `sha224`, `sha256`, `sha384`, `sha512`.\n\n### `touch(filepath: string, mtime?: Date, ctime?: Date): Promise<string>`\n\nSets the modification timestamp `mtime` and creation timestamp `ctime` of the file at `filepath`. Setting `ctime` is supported on iOS and Windows, android always sets both timestamps to `mtime`.\n\n### `mkdir(filepath: string, options?: MkdirOptions): Promise<void>`\n\n```\ntype MkdirOptions = {\n  NSURLIsExcludedFromBackupKey?: boolean; // iOS only\n};\n```\n\nCreate a directory at `filepath`. Automatically creates parents and does not throw if already exists (works like Linux `mkdir -p`).\n\n(IOS only): The `NSURLIsExcludedFromBackupKey` property can be provided to set this attribute on iOS platforms. Apple will *reject* apps for storing offline cache data that does not have this attribute.\n\n### `downloadFile(options: DownloadFileOptions): { jobId: number, promise: Promise<DownloadResult> }`\n\n```js\ntype DownloadFileOptions = {\n  fromUrl: string;          // URL to download file from\n  toFile: string;           // Local filesystem path to save the file to\n  headers?: Headers;        // An object of headers to be passed to the server\n  background?: boolean;     // Continue the download in the background after the app terminates (iOS only)\n  discretionary?: boolean;  // Allow the OS to control the timing and speed of the download to improve perceived performance  (iOS only)\n  cacheable?: boolean;      // Whether the download can be stored in the shared NSURLCache (iOS only, defaults to true)\n  progressInterval?: number;\n  progressDivider?: number;\n  begin?: (res: DownloadBeginCallbackResult) => void; // Note: it is required when progress prop provided\n  progress?: (res: DownloadProgressCallbackResult) => void;\n  resumable?: () => void;    // only supported on iOS yet\n  connectionTimeout?: number // only supported on Android yet\n  readTimeout?: number       // supported on Android and iOS\n  backgroundTimeout?: number // Maximum time (in milliseconds) to download an entire resource (iOS only, useful for timing out background downloads)\n};\n```\n```js\ntype DownloadResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  bytesWritten: number;   // The number of bytes written to the file\n};\n```\n\nDownload file from `options.fromUrl` to `options.toFile`. Will overwrite any previously existing file.\n\nIf `options.begin` is provided, it will be invoked once upon download starting when headers have been received and passed a single argument with the following properties:\n\n```js\ntype DownloadBeginCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  contentLength: number;  // The total size in bytes of the download resource\n  headers: Headers;       // The HTTP response headers from the server\n};\n```\n\nIf `options.progress` is provided, it will be invoked continuously and passed a single argument with the following properties:\n\n```js\ntype DownloadProgressCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  contentLength: number;  // The total size in bytes of the download resource\n  bytesWritten: number;   // The number of bytes written to the file so far\n};\n```\n\nIf `options.progressInterval` is provided, it will return progress events in the maximum frequency of `progressDivider`.\nFor example, if `progressInterval` = 100, you will not receive callbacks more often than every 100th millisecond.\n\nIf `options.progressDivider` is provided, it will return progress events that divided by `progressDivider`.\n\nFor example, if `progressDivider` = 10, you will receive only ten callbacks for this values of progress: 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100\nUse it for performance issues.\nIf `progressDivider` = 0, you will receive all `progressCallback` calls, default value is 0.\n\n(IOS only): `options.background` (`Boolean`) - Whether to continue downloads when the app is not focused (default: `false`)\n                           This option is currently only available for iOS, see the [Background Downloads Tutorial (iOS)](#background-downloads-tutorial-ios) section.\n\n(IOS only): If `options.resumable` is provided, it will be invoked when the download has stopped and and can be resumed using `resumeDownload()`.\n\n### `stopDownload(jobId: number): void`\n\nAbort the current download job with this ID. The partial file will remain on the filesystem.\n\n### (iOS only) `resumeDownload(jobId: number): void`\n\nResume the current download job with this ID.\n\n### (iOS only) `isResumable(jobId: number): Promise<bool>`\n\nCheck if the the download job with this ID is resumable with `resumeDownload()`.\n\nExample:\n\n```js\nif (await RNFS.isResumable(jobId) {\n    RNFS.resumeDownload(jobId)\n}\n```\n\n### (iOS only) `completeHandlerIOS(jobId: number): void`\n\nFor use when using background downloads, tell iOS you are done handling a completed download.\n\nRead more about background downloads in the [Background Downloads Tutorial (iOS)](#background-downloads-tutorial-ios) section.\n\n### `uploadFiles(options: UploadFileOptions): { jobId: number, promise: Promise<UploadResult> }`\n\n`options` (`Object`) - An object containing named parameters\n\n```js\ntype UploadFileOptions = {\n  toUrl: string;            // URL to upload file to\n  binaryStreamOnly?: boolean// Allow for binary data stream for file to be uploaded without extra headers, Default is 'false'\n  files: UploadFileItem[];  // An array of objects with the file information to be uploaded.\n  headers?: Headers;        // An object of headers to be passed to the server\n  fields?: Fields;          // An object of fields to be passed to the server\n  method?: string;          // Default is 'POST', supports 'POST' and 'PUT'\n  begin?: (res: UploadBeginCallbackResult) => void;\n  progress?: (res: UploadProgressCallbackResult) => void;\n};\n\n```\n```js\ntype UploadResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  statusCode: number;   // The HTTP status code\n  headers: Headers;     // The HTTP response headers from the server\n  body: string;         // The HTTP response body\n};\n```\n\nEach file should have the following structure:\n\n```js\ntype UploadFileItem = {\n  name: string;       // Name of the file, if not defined then filename is used\n  filename: string;   // Name of file\n  filepath: string;   // Path to file\n  filetype: string;   // The mimetype of the file to be uploaded, if not defined it will get mimetype from `filepath` extension\n};\n```\n\nIf `options.begin` is provided, it will be invoked once upon upload has begun:\n\n```js\ntype UploadBeginCallbackResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n};\n```\n\nIf `options.progress` is provided, it will be invoked continuously and passed a single object with the following properties:\n\n```js\ntype UploadProgressCallbackResult = {\n  jobId: number;                      // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  totalBytesExpectedToSend: number;   // The total number of bytes that will be sent to the server\n  totalBytesSent: number;             // The number of bytes sent to the server\n};\n```\n\nPercentage can be computed easily by dividing `totalBytesSent` by `totalBytesExpectedToSend`.\n\n### (iOS only) `stopUpload(jobId: number): Promise<void>`\n\nAbort the current upload job with this ID.\n\n### `getFSInfo(): Promise<FSInfoResult>`\n\nReturns an object with the following properties:\n\n```js\ntype FSInfoResult = {\n  totalSpace: number;   // The total amount of storage space on the device (in bytes).\n  freeSpace: number;    // The amount of available storage space on the device (in bytes).\n};\n```\n\n### (Android only) `scanFile(path: string): Promise<string[]>`\n\nScan the file using [Media Scanner](https://developer.android.com/reference/android/media/MediaScannerConnection).\n\n### (Android only) `getAllExternalFilesDirs(): Promise<string[]>`\n\nReturns an array with the absolute paths to application-specific directories on all shared/external storage devices where the application can place persistent files it owns.\n\n### (iOS only) `pathForGroup(groupIdentifier: string): Promise<string>`\n\n`groupIdentifier` (`string`) Any value from the *com.apple.security.application-groups* entitlements list.\n\nReturns the absolute path to the directory shared for all applications with the same security group identifier.\nThis directory can be used to to share files between application of the same developer.\n\nInvalid group identifier will cause a rejection.\n\nFor more information read the [Adding an App to an App Group](https://developer.apple.com/library/content/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/EnablingAppSandbox.html#//apple_ref/doc/uid/TP40011195-CH4-SW19) section.\n\n## Background Downloads Tutorial (iOS)\n\nBackground downloads in iOS require a bit of a setup.\n\nFirst, in your `AppDelegate.m` file add the following:\n\n```js\n#import <RNFSManager.h>\n\n...\n\n- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler\n{\n  [RNFSManager setCompletionHandlerForIdentifier:identifier completionHandler:completionHandler];\n}\n\n```\n\nThe `handleEventsForBackgroundURLSession` method is called when a background download is done and your app is not in the foreground.\n\nWe need to pass the `completionHandler` to RNFS along with its `identifier`.\n\nThe JavaScript will continue to work as usual when the download is done but now you must call `RNFS.completeHandlerIOS(jobId)` when you're done handling the download (show a notification etc.)\n\n**BE AWARE!** iOS will give about 30 sec. to run your code after `handleEventsForBackgroundURLSession` is called and until `completionHandler`\nis triggered so don't do anything that might take a long time (like unzipping), you will be able to do it after the user re-launces the app,\notherwide iOS will terminate your app.\n\n\n## Test / Demo app\n\nTest app to demostrate the use of the module. Useful for testing and developing the module:\n\nhttps://github.com/cjdell/react-native-fs-test\n"
        },
        {
          "name": "RNFS.podspec",
          "type": "blob",
          "size": 0.6611328125,
          "content": "require 'json'\npjson = JSON.parse(File.read('package.json'))\n\nPod::Spec.new do |s|\n\n  s.name            = \"RNFS\"\n  s.version         = pjson[\"version\"]\n  s.homepage        = \"https://github.com/itinance/react-native-fs\"\n  s.summary         = pjson[\"description\"]\n  s.license         = pjson[\"license\"]\n  s.author          = { \"Johannes Lumpe\" => \"johannes@lum.pe\" }\n  \n  s.ios.deployment_target = '8.0'\n  s.tvos.deployment_target = '9.2'\n  s.osx.deployment_target = '10.10'\n\n  s.source          = { :git => \"https://github.com/itinance/react-native-fs\", :tag => \"v#{s.version}\" }\n  s.source_files    = '*.{h,m}'\n  s.preserve_paths  = \"**/*.js\"\n\n  s.dependency 'React-Core'\nend\n"
        },
        {
          "name": "RNFS.xcodeproj",
          "type": "tree",
          "content": null
        },
        {
          "name": "RNFSManager.h",
          "type": "blob",
          "size": 0.4599609375,
          "content": "//\n//  RNFSManager.h\n//  RNFSManager\n//\n//  Created by Johannes Lumpe on 08/05/15.\n//  Copyright (c) 2015 Johannes Lumpe. All rights reserved.\n//\n\n#import <React/RCTBridgeModule.h>\n#import <React/RCTEventEmitter.h>\n#import <React/RCTLog.h>\n\ntypedef void (^CompletionHandler)(void);\n\n@interface RNFSManager : RCTEventEmitter <RCTBridgeModule>\n\n+(void)setCompletionHandlerForIdentifier: (NSString *)identifier completionHandler: (CompletionHandler)completionHandler;\n\n@end\n"
        },
        {
          "name": "RNFSManager.m",
          "type": "blob",
          "size": 34.578125,
          "content": "//\n//  RNFSManager.m\n//  RNFSManager\n//\n//  Created by Johannes Lumpe on 08/05/15.\n//  Copyright (c) 2015 Johannes Lumpe. All rights reserved.\n//\n\n#import \"RNFSManager.h\"\n\n#import \"NSArray+Map.h\"\n#import \"Downloader.h\"\n#import \"Uploader.h\"\n\n#import <React/RCTEventDispatcher.h>\n#import <React/RCTUtils.h>\n\n#if __has_include(<React/RCTImageLoader.h>)\n#import <React/RCTImageLoader.h>\n#else\n#import <React/RCTImageLoaderProtocol.h>\n#endif\n\n#import <CommonCrypto/CommonDigest.h>\n#import <Photos/Photos.h>\n\n\n@interface RNFSManager()\n\n@property (retain) NSMutableDictionary* downloaders;\n@property (retain) NSMutableDictionary* uuids;\n@property (retain) NSMutableDictionary* uploaders;\n\n@end\n\n@implementation RNFSManager\n\nstatic NSMutableDictionary *completionHandlers;\n\nRCT_EXPORT_MODULE();\n\n- (dispatch_queue_t)methodQueue\n{\n  return dispatch_queue_create(\"pe.lum.rnfs\", DISPATCH_QUEUE_SERIAL);\n}\n\n+ (BOOL)requiresMainQueueSetup\n{\n  return NO;\n}\n\nRCT_EXPORT_METHOD(readDir:(NSString *)dirPath\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSFileManager *fileManager = [NSFileManager defaultManager];\n  NSError *error = nil;\n\n  NSArray *contents = [fileManager contentsOfDirectoryAtPath:dirPath error:&error];\n  NSMutableArray *tagetContents = [[NSMutableArray alloc] init];\n  for (NSString *obj in contents) {\n    NSString *path = [dirPath stringByAppendingPathComponent:obj];\n    NSDictionary *attributes = [fileManager attributesOfItemAtPath:path error:nil];\n    if(attributes != nil) {\n        [tagetContents addObject:@{\n            @\"ctime\": [self dateToTimeIntervalNumber:(NSDate *)[attributes objectForKey:NSFileCreationDate]],\n            @\"mtime\": [self dateToTimeIntervalNumber:(NSDate *)[attributes objectForKey:NSFileModificationDate]],\n            @\"name\": obj,\n            @\"path\": path,\n            @\"size\": [attributes objectForKey:NSFileSize],\n            @\"type\": [attributes objectForKey:NSFileType]\n            }];\n    }\n  }\n\n  if (error) {\n    return [self reject:reject withError:error];\n  }\n\n  resolve(tagetContents);\n}\n\nRCT_EXPORT_METHOD(exists:(NSString *)filepath\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(__unused RCTPromiseRejectBlock)reject)\n{\n  BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:filepath];\n\n  resolve([NSNumber numberWithBool:fileExists]);\n}\n\nRCT_EXPORT_METHOD(stat:(NSString *)filepath\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSError *error = nil;\n  NSDictionary *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:filepath error:&error];\n\n  if (error) {\n    return [self reject:reject withError:error];\n  }\n\n  attributes = @{\n                 @\"ctime\": [self dateToTimeIntervalNumber:(NSDate *)[attributes objectForKey:NSFileCreationDate]],\n                 @\"mtime\": [self dateToTimeIntervalNumber:(NSDate *)[attributes objectForKey:NSFileModificationDate]],\n                 @\"size\": [attributes objectForKey:NSFileSize],\n                 @\"type\": [attributes objectForKey:NSFileType],\n                 @\"mode\": @([[NSString stringWithFormat:@\"%ld\", (long)[(NSNumber *)[attributes objectForKey:NSFilePosixPermissions] integerValue]] integerValue])\n                 };\n\n  resolve(attributes);\n}\n\nRCT_EXPORT_METHOD(writeFile:(NSString *)filepath\n                  contents:(NSString *)base64Content\n                  options:(NSDictionary *)options\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSData *data = [[NSData alloc] initWithBase64EncodedString:base64Content options:NSDataBase64DecodingIgnoreUnknownCharacters];\n\n  NSMutableDictionary *attributes = [[NSMutableDictionary alloc] init];\n\n  if ([options objectForKey:@\"NSFileProtectionKey\"]) {\n    [attributes setValue:[options objectForKey:@\"NSFileProtectionKey\"] forKey:@\"NSFileProtectionKey\"];\n  }\n\n  BOOL success = [[NSFileManager defaultManager] createFileAtPath:filepath contents:data attributes:attributes];\n\n  if (!success) {\n    return reject(@\"ENOENT\", [NSString stringWithFormat:@\"ENOENT: no such file or directory, open '%@'\", filepath], nil);\n  }\n\n  return resolve(nil);\n}\n\nRCT_EXPORT_METHOD(appendFile:(NSString *)filepath\n                  contents:(NSString *)base64Content\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSData *data = [[NSData alloc] initWithBase64EncodedString:base64Content options:NSDataBase64DecodingIgnoreUnknownCharacters];\n\n  NSFileManager *fM = [NSFileManager defaultManager];\n\n  if (![fM fileExistsAtPath:filepath])\n  {\n    BOOL success = [[NSFileManager defaultManager] createFileAtPath:filepath contents:data attributes:nil];\n\n    if (!success) {\n      return reject(@\"ENOENT\", [NSString stringWithFormat:@\"ENOENT: no such file or directory, open '%@'\", filepath], nil);\n    } else {\n      return resolve(nil);\n    }\n  }\n\n  @try {\n    NSFileHandle *fH = [NSFileHandle fileHandleForUpdatingAtPath:filepath];\n\n    [fH seekToEndOfFile];\n    [fH writeData:data];\n\n    return resolve(nil);\n  } @catch (NSException *exception) {\n    NSMutableDictionary * info = [NSMutableDictionary dictionary];\n    [info setValue:exception.name forKey:@\"ExceptionName\"];\n    [info setValue:exception.reason forKey:@\"ExceptionReason\"];\n    [info setValue:exception.callStackReturnAddresses forKey:@\"ExceptionCallStackReturnAddresses\"];\n    [info setValue:exception.callStackSymbols forKey:@\"ExceptionCallStackSymbols\"];\n    [info setValue:exception.userInfo forKey:@\"ExceptionUserInfo\"];\n    NSError *err = [NSError errorWithDomain:@\"RNFS\" code:0 userInfo:info];\n    return [self reject:reject withError:err];\n  }\n}\n\nRCT_EXPORT_METHOD(write:(NSString *)filepath\n                  contents:(NSString *)base64Content\n                  position:(NSInteger)position\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSData *data = [[NSData alloc] initWithBase64EncodedString:base64Content options:NSDataBase64DecodingIgnoreUnknownCharacters];\n\n  NSFileManager *fM = [NSFileManager defaultManager];\n\n  if (![fM fileExistsAtPath:filepath])\n  {\n    BOOL success = [[NSFileManager defaultManager] createFileAtPath:filepath contents:data attributes:nil];\n\n    if (!success) {\n      return reject(@\"ENOENT\", [NSString stringWithFormat:@\"ENOENT: no such file or directory, open '%@'\", filepath], nil);\n    } else {\n      return resolve(nil);\n    }\n  }\n\n  @try {\n    NSFileHandle *fH = [NSFileHandle fileHandleForUpdatingAtPath:filepath];\n\n    if (position >= 0) {\n      [fH seekToFileOffset:position];\n    } else {\n      [fH seekToEndOfFile];\n    }\n    [fH writeData:data];\n\n    return resolve(nil);\n  } @catch (NSException *e) {\n    return reject(@\"ENOENT\", [NSString stringWithFormat:@\"ENOENT: error writing file: '%@'\", filepath], nil);\n  }\n}\n\nRCT_EXPORT_METHOD(unlink:(NSString*)filepath\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSFileManager *manager = [NSFileManager defaultManager];\n  BOOL exists = [manager fileExistsAtPath:filepath isDirectory:false];\n\n  if (!exists) {\n    return reject(@\"ENOENT\", [NSString stringWithFormat:@\"ENOENT: no such file or directory, open '%@'\", filepath], nil);\n  }\n\n  NSError *error = nil;\n  BOOL success = [manager removeItemAtPath:filepath error:&error];\n\n  if (!success) {\n    return [self reject:reject withError:error];\n  }\n\n  resolve(nil);\n}\n\nRCT_EXPORT_METHOD(mkdir:(NSString *)filepath\n                  options:(NSDictionary *)options\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSFileManager *manager = [NSFileManager defaultManager];\n\n  NSMutableDictionary *attributes = [[NSMutableDictionary alloc] init];\n\n  if ([options objectForKey:@\"NSFileProtectionKey\"]) {\n      [attributes setValue:[options objectForKey:@\"NSFileProtectionKey\"] forKey:@\"NSFileProtectionKey\"];\n  }\n\n  NSError *error = nil;\n    BOOL success = [manager createDirectoryAtPath:filepath withIntermediateDirectories:YES attributes:attributes error:&error];\n\n  if (!success) {\n    return [self reject:reject withError:error];\n  }\n\n  NSURL *url = [NSURL fileURLWithPath:filepath];\n\n  if ([[options allKeys] containsObject:@\"NSURLIsExcludedFromBackupKey\"]) {\n    NSNumber *value = options[@\"NSURLIsExcludedFromBackupKey\"];\n    success = [url setResourceValue: value forKey: NSURLIsExcludedFromBackupKey error: &error];\n\n    if (!success) {\n      return [self reject:reject withError:error];\n    }\n  }\n\n  resolve(nil);\n}\n\nRCT_EXPORT_METHOD(readFile:(NSString *)filepath\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:filepath];\n\n  if (!fileExists) {\n    return reject(@\"ENOENT\", [NSString stringWithFormat:@\"ENOENT: no such file or directory, open '%@'\", filepath], nil);\n  }\n\n  NSError *error = nil;\n\n  NSDictionary *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:filepath error:&error];\n\n  if (error) {\n    return [self reject:reject withError:error];\n  }\n\n  if ([attributes objectForKey:NSFileType] == NSFileTypeDirectory) {\n    return reject(@\"EISDIR\", @\"EISDIR: illegal operation on a directory, read\", nil);\n  }\n\n  NSData *content = [[NSFileManager defaultManager] contentsAtPath:filepath];\n  NSString *base64Content = [content base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];\n\n  resolve(base64Content);\n}\n\nRCT_EXPORT_METHOD(read:(NSString *)filepath\n                  length: (NSInteger *)length\n                  position: (NSInteger *)position\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n    BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:filepath];\n\n    if (!fileExists) {\n        return reject(@\"ENOENT\", [NSString stringWithFormat:@\"ENOENT: no such file or directory, open '%@'\", filepath], nil);\n    }\n\n    NSError *error = nil;\n\n    NSDictionary *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:filepath error:&error];\n\n    if (error) {\n        return [self reject:reject withError:error];\n    }\n\n    if ([attributes objectForKey:NSFileType] == NSFileTypeDirectory) {\n        return reject(@\"EISDIR\", @\"EISDIR: illegal operation on a directory, read\", nil);\n    }\n\n    // Open the file handler.\n    NSFileHandle *file = [NSFileHandle fileHandleForReadingAtPath:filepath];\n    if (file == nil) {\n        return reject(@\"EISDIR\", @\"EISDIR: Could not open file for reading\", nil);\n    }\n\n    // Seek to the position if there is one.\n    [file seekToFileOffset: (int)position];\n\n    NSData *content;\n    if ((int)length > 0) {\n        content = [file readDataOfLength: (int)length];\n    } else {\n        content = [file readDataToEndOfFile];\n    }\n\n    NSString *base64Content = [content base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];\n\n    resolve(base64Content);\n}\n\nRCT_EXPORT_METHOD(hash:(NSString *)filepath\n                  algorithm:(NSString *)algorithm\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:filepath];\n\n  if (!fileExists) {\n    return reject(@\"ENOENT\", [NSString stringWithFormat:@\"ENOENT: no such file or directory, open '%@'\", filepath], nil);\n  }\n\n  NSError *error = nil;\n\n  NSDictionary *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:filepath error:&error];\n\n  if (error) {\n    return [self reject:reject withError:error];\n  }\n\n  if ([attributes objectForKey:NSFileType] == NSFileTypeDirectory) {\n    return reject(@\"EISDIR\", @\"EISDIR: illegal operation on a directory, read\", nil);\n  }\n\n  NSData *content = [[NSFileManager defaultManager] contentsAtPath:filepath];\n\n  NSArray *keys = [NSArray arrayWithObjects:@\"md5\", @\"sha1\", @\"sha224\", @\"sha256\", @\"sha384\", @\"sha512\", nil];\n\n  NSArray *digestLengths = [NSArray arrayWithObjects:\n    @CC_MD5_DIGEST_LENGTH,\n    @CC_SHA1_DIGEST_LENGTH,\n    @CC_SHA224_DIGEST_LENGTH,\n    @CC_SHA256_DIGEST_LENGTH,\n    @CC_SHA384_DIGEST_LENGTH,\n    @CC_SHA512_DIGEST_LENGTH,\n    nil];\n\n  NSDictionary *keysToDigestLengths = [NSDictionary dictionaryWithObjects:digestLengths forKeys:keys];\n\n  int digestLength = [[keysToDigestLengths objectForKey:algorithm] intValue];\n\n  if (!digestLength) {\n    return reject(@\"Error\", [NSString stringWithFormat:@\"Invalid hash algorithm '%@'\", algorithm], nil);\n  }\n\n  unsigned char buffer[digestLength];\n\n  if ([algorithm isEqualToString:@\"md5\"]) {\n    CC_MD5(content.bytes, (CC_LONG)content.length, buffer);\n  } else if ([algorithm isEqualToString:@\"sha1\"]) {\n    CC_SHA1(content.bytes, (CC_LONG)content.length, buffer);\n  } else if ([algorithm isEqualToString:@\"sha224\"]) {\n    CC_SHA224(content.bytes, (CC_LONG)content.length, buffer);\n  } else if ([algorithm isEqualToString:@\"sha256\"]) {\n    CC_SHA256(content.bytes, (CC_LONG)content.length, buffer);\n  } else if ([algorithm isEqualToString:@\"sha384\"]) {\n    CC_SHA384(content.bytes, (CC_LONG)content.length, buffer);\n  } else if ([algorithm isEqualToString:@\"sha512\"]) {\n    CC_SHA512(content.bytes, (CC_LONG)content.length, buffer);\n  } else {\n    return reject(@\"Error\", [NSString stringWithFormat:@\"Invalid hash algorithm '%@'\", algorithm], nil);\n  }\n\n  NSMutableString *output = [NSMutableString stringWithCapacity:digestLength * 2];\n  for(int i = 0; i < digestLength; i++)\n    [output appendFormat:@\"%02x\",buffer[i]];\n\n  resolve(output);\n}\n\nRCT_EXPORT_METHOD(moveFile:(NSString *)filepath\n                  destPath:(NSString *)destPath\n                  options:(NSDictionary *)options\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSFileManager *manager = [NSFileManager defaultManager];\n\n  NSError *error = nil;\n  BOOL success = [manager moveItemAtPath:filepath toPath:destPath error:&error];\n\n  if (!success) {\n    return [self reject:reject withError:error];\n  }\n\n  if ([options objectForKey:@\"NSFileProtectionKey\"]) {\n    NSMutableDictionary *attributes = [[NSMutableDictionary alloc] init];\n    [attributes setValue:[options objectForKey:@\"NSFileProtectionKey\"] forKey:@\"NSFileProtectionKey\"];\n    BOOL updateSuccess = [manager setAttributes:attributes ofItemAtPath:destPath error:&error];\n\n    if (!updateSuccess) {\n      return [self reject:reject withError:error];\n    }\n  }\n\n  resolve(nil);\n}\n\nRCT_EXPORT_METHOD(copyFile:(NSString *)filepath\n                  destPath:(NSString *)destPath\n                  options:(NSDictionary *)options\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSFileManager *manager = [NSFileManager defaultManager];\n\n  NSError *error = nil;\n  BOOL success = [manager copyItemAtPath:filepath toPath:destPath error:&error];\n\n  if (!success) {\n    return [self reject:reject withError:error];\n  }\n\n  if ([options objectForKey:@\"NSFileProtectionKey\"]) {\n    NSMutableDictionary *attributes = [[NSMutableDictionary alloc] init];\n    [attributes setValue:[options objectForKey:@\"NSFileProtectionKey\"] forKey:@\"NSFileProtectionKey\"];\n    BOOL updateSuccess = [manager setAttributes:attributes ofItemAtPath:destPath error:&error];\n\n    if (!updateSuccess) {\n      return [self reject:reject withError:error];\n    }\n  }\n\n  resolve(nil);\n}\n\n- (NSArray<NSString *> *)supportedEvents\n{\n    return @[@\"UploadBegin\",@\"UploadProgress\",@\"DownloadBegin\",@\"DownloadProgress\",@\"DownloadResumable\"];\n}\n\nRCT_EXPORT_METHOD(downloadFile:(NSDictionary *)options\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  RNFSDownloadParams* params = [RNFSDownloadParams alloc];\n\n  NSNumber* jobId = options[@\"jobId\"];\n  params.fromUrl = options[@\"fromUrl\"];\n  params.toFile = options[@\"toFile\"];\n  NSDictionary* headers = options[@\"headers\"];\n  params.headers = headers;\n  NSNumber* background = options[@\"background\"];\n  params.background = [background boolValue];\n  NSNumber* discretionary = options[@\"discretionary\"];\n  params.discretionary = [discretionary boolValue];\n  NSNumber* cacheable = options[@\"cacheable\"];\n  params.cacheable = cacheable ? [cacheable boolValue] : YES;\n  NSNumber* progressInterval= options[@\"progressInterval\"];\n  params.progressInterval = progressInterval;\n  NSNumber* progressDivider = options[@\"progressDivider\"];\n  params.progressDivider = progressDivider;\n  NSNumber* readTimeout = options[@\"readTimeout\"];\n  params.readTimeout = readTimeout;\n  NSNumber* backgroundTimeout = options[@\"backgroundTimeout\"];\n  params.backgroundTimeout = backgroundTimeout;\n  bool hasBeginCallback = [options[@\"hasBeginCallback\"] boolValue];\n  bool hasProgressCallback = [options[@\"hasProgressCallback\"] boolValue];\n  bool hasResumableCallback = [options[@\"hasResumableCallback\"] boolValue];\n\n  __block BOOL callbackFired = NO;\n\n  params.completeCallback = ^(NSNumber* statusCode, NSNumber* bytesWritten) {\n    if (callbackFired) {\n      return;\n    }\n    callbackFired = YES;\n\n    NSMutableDictionary* result = [[NSMutableDictionary alloc] initWithDictionary: @{@\"jobId\": jobId}];\n    if (statusCode) {\n      [result setObject:statusCode forKey: @\"statusCode\"];\n    }\n    if (bytesWritten) {\n      [result setObject:bytesWritten forKey: @\"bytesWritten\"];\n    }\n    return resolve(result);\n  };\n\n  params.errorCallback = ^(NSError* error) {\n    if (callbackFired) {\n      return;\n    }\n    callbackFired = YES;\n    return [self reject:reject withError:error];\n  };\n\n  if (hasBeginCallback) {\n    params.beginCallback = ^(NSNumber* statusCode, NSNumber* contentLength, NSDictionary* headers) {\n        if (self.bridge != nil)\n            [self sendEventWithName:@\"DownloadBegin\" body:@{@\"jobId\": jobId,\n                                                                                            @\"statusCode\": statusCode,\n                                                                                            @\"contentLength\": contentLength,\n                                                                                            @\"headers\": headers ?: [NSNull null]}];\n    };\n  }\n\n  if (hasProgressCallback) {\n    params.progressCallback = ^(NSNumber* contentLength, NSNumber* bytesWritten) {\n        if (self.bridge != nil)\n          [self sendEventWithName:@\"DownloadProgress\"\n                                                  body:@{@\"jobId\": jobId,\n                                                          @\"contentLength\": contentLength,\n                                                          @\"bytesWritten\": bytesWritten}];\n    };\n  }\n\n  if (hasResumableCallback) {\n    params.resumableCallback = ^() {\n        if (self.bridge != nil)\n            [self sendEventWithName:@\"DownloadResumable\" body:@{@\"jobId\": jobId}];\n    };\n  }\n\n  if (!self.downloaders) self.downloaders = [[NSMutableDictionary alloc] init];\n\n  RNFSDownloader* downloader = [RNFSDownloader alloc];\n\n  NSString *uuid = [downloader downloadFile:params];\n\n  [self.downloaders setValue:downloader forKey:[jobId stringValue]];\n    if (uuid) {\n        if (!self.uuids) self.uuids = [[NSMutableDictionary alloc] init];\n        [self.uuids setValue:uuid forKey:[jobId stringValue]];\n    }\n}\n\nRCT_EXPORT_METHOD(stopDownload:(nonnull NSNumber *)jobId)\n{\n  RNFSDownloader* downloader = [self.downloaders objectForKey:[jobId stringValue]];\n\n  if (downloader != nil) {\n    [downloader stopDownload];\n  }\n}\n\nRCT_EXPORT_METHOD(resumeDownload:(nonnull NSNumber *)jobId)\n{\n    RNFSDownloader* downloader = [self.downloaders objectForKey:[jobId stringValue]];\n\n    if (downloader != nil) {\n        [downloader resumeDownload];\n    }\n}\n\nRCT_EXPORT_METHOD(isResumable:(nonnull NSNumber *)jobId\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject\n)\n{\n    RNFSDownloader* downloader = [self.downloaders objectForKey:[jobId stringValue]];\n\n    if (downloader != nil) {\n        resolve([NSNumber numberWithBool:[downloader isResumable]]);\n    } else {\n        resolve([NSNumber numberWithBool:NO]);\n    }\n}\n\nRCT_EXPORT_METHOD(completeHandlerIOS:(nonnull NSNumber *)jobId\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n    if (self.uuids) {\n        NSString *uuid = [self.uuids objectForKey:[jobId stringValue]];\n        CompletionHandler completionHandler = [completionHandlers objectForKey:uuid];\n        if (completionHandler) {\n            completionHandler();\n            [completionHandlers removeObjectForKey:uuid];\n        }\n    }\n    resolve(nil);\n}\n\nRCT_EXPORT_METHOD(uploadFiles:(NSDictionary *)options\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  RNFSUploadParams* params = [RNFSUploadParams alloc];\n\n  NSNumber* jobId = options[@\"jobId\"];\n  params.toUrl = options[@\"toUrl\"];\n  params.files = options[@\"files\"];\n  params.binaryStreamOnly = [[options objectForKey:@\"binaryStreamOnly\"] boolValue];\n  NSDictionary* headers = options[@\"headers\"];\n  NSDictionary* fields = options[@\"fields\"];\n  NSString* method = options[@\"method\"];\n  params.headers = headers;\n  params.fields = fields;\n  params.method = method;\n  bool hasBeginCallback = [options[@\"hasBeginCallback\"] boolValue];\n  bool hasProgressCallback = [options[@\"hasProgressCallback\"] boolValue];\n\n  params.completeCallback = ^(NSString* body, NSURLResponse *resp) {\n    [self.uploaders removeObjectForKey:[jobId stringValue]];\n\n    NSMutableDictionary* result = [[NSMutableDictionary alloc] initWithDictionary: @{@\"jobId\": jobId,\n                                                                                     @\"body\": body}];\n    if ([resp isKindOfClass:[NSHTTPURLResponse class]]) {\n      [result setValue:((NSHTTPURLResponse *)resp).allHeaderFields forKey:@\"headers\"];\n      [result setValue:[NSNumber numberWithUnsignedInteger:((NSHTTPURLResponse *)resp).statusCode] forKey:@\"statusCode\"];\n    }\n    return resolve(result);\n  };\n\n  params.errorCallback = ^(NSError* error) {\n    [self.uploaders removeObjectForKey:[jobId stringValue]];\n    return [self reject:reject withError:error];\n  };\n\n  if (hasBeginCallback) {\n    params.beginCallback = ^() {\n        if (self.bridge != nil)\n          [self sendEventWithName:@\"UploadBegin\"\n                                                  body:@{@\"jobId\": jobId}];\n    };\n  }\n\n  if (hasProgressCallback) {\n    params.progressCallback = ^(NSNumber* totalBytesExpectedToSend, NSNumber* totalBytesSent) {\n        if (self.bridge != nil)\n            [self sendEventWithName:@\"UploadProgress\"\n                                                  body:@{@\"jobId\": jobId,\n                                                          @\"totalBytesExpectedToSend\": totalBytesExpectedToSend,\n                                                          @\"totalBytesSent\": totalBytesSent}];\n    };\n  }\n\n  if (!self.uploaders) self.uploaders = [[NSMutableDictionary alloc] init];\n\n  RNFSUploader* uploader = [RNFSUploader alloc];\n\n  [uploader uploadFiles:params];\n\n  [self.uploaders setValue:uploader forKey:[jobId stringValue]];\n}\n\nRCT_EXPORT_METHOD(stopUpload:(nonnull NSNumber *)jobId)\n{\n  RNFSUploader* uploader = [self.uploaders objectForKey:[jobId stringValue]];\n\n  if (uploader != nil) {\n    [uploader stopUpload];\n  }\n}\n\nRCT_EXPORT_METHOD(pathForBundle:(NSString *)bundleNamed\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSString *path = [[NSBundle mainBundle].bundlePath stringByAppendingFormat:@\"/%@.bundle\", bundleNamed];\n  NSBundle *bundle = [NSBundle bundleWithPath:path];\n\n  if (!bundle) {\n    bundle = [NSBundle bundleForClass:NSClassFromString(bundleNamed)];\n    path = bundle.bundlePath;\n  }\n\n  if (!bundle.isLoaded) {\n    [bundle load];\n  }\n\n  if (path) {\n    resolve(path);\n  } else {\n    NSError *error = [NSError errorWithDomain:NSPOSIXErrorDomain\n                                         code:NSFileNoSuchFileError\n                                     userInfo:nil];\n\n    [self reject:reject withError:error];\n  }\n}\n\nRCT_EXPORT_METHOD(pathForGroup:(nonnull NSString *)groupId\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n  NSURL *groupURL = [[NSFileManager defaultManager]containerURLForSecurityApplicationGroupIdentifier: groupId];\n\n  if (!groupURL) {\n    return reject(@\"ENOENT\", [NSString stringWithFormat:@\"ENOENT: no directory for group '%@' found\", groupId], nil);\n  } else {\n    resolve([groupURL path]);\n  }\n}\n\nRCT_EXPORT_METHOD(getFSInfo:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n{\n  unsigned long long totalSpace = 0;\n  unsigned long long totalFreeSpace = 0;\n\n  __autoreleasing NSError *error = nil;\n  NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\n  NSDictionary *dictionary = [[NSFileManager defaultManager] attributesOfFileSystemForPath:[paths lastObject] error:&error];\n\n  if (dictionary) {\n    NSNumber *fileSystemSizeInBytes = [dictionary objectForKey: NSFileSystemSize];\n    NSNumber *freeFileSystemSizeInBytes = [dictionary objectForKey:NSFileSystemFreeSize];\n    totalSpace = [fileSystemSizeInBytes unsignedLongLongValue];\n    totalFreeSpace = [freeFileSystemSizeInBytes unsignedLongLongValue];\n\n    resolve(@{\n      @\"totalSpace\": [NSNumber numberWithUnsignedLongLong:totalSpace],\n      @\"freeSpace\": [NSNumber numberWithUnsignedLongLong:totalFreeSpace]\n    });\n  } else {\n    [self reject:reject withError:error];\n  }\n}\n\n\n// [PHAsset fetchAssetsWithALAssetURLs] is deprecated and not supported in Mac Catalyst\n#if !TARGET_OS_UIKITFORMAC && !TARGET_OS_OSX\n/**\n * iOS Only: copy images from the assets-library (camera-roll) to a specific path, asuming\n * JPEG-Images.\n *\n * Video-Support:\n *\n * One can use this method also to create a thumbNail from a video.\n * Currently it is impossible to specify a concrete position, the OS will decide wich\n * Thumbnail you'll get then.\n * To copy a video from assets-library and save it as a mp4-file, use the method\n * copyAssetsVideoIOS.\n *\n * It is also supported to scale the image via scale-factor (0.0-1.0) or with a specific\n * width and height. Also the resizeMode will be considered.\n */\nRCT_EXPORT_METHOD(copyAssetsFileIOS: (NSString *) imageUri\n                  toFilepath: (NSString *) destination\n                  width: (NSInteger) width\n                  height: (NSInteger) height\n                  scale: (CGFloat) scale\n                  compression: (CGFloat) compression\n                  resizeMode: (RCTResizeMode) resizeMode\n                  resolver: (RCTPromiseResolveBlock) resolve\n                  rejecter: (RCTPromiseRejectBlock) reject)\n\n{\n    CGSize size = CGSizeMake(width, height);\n\n    NSURL* url = [NSURL URLWithString:imageUri];\n    PHFetchResult *results = nil;\n    if ([url.scheme isEqualToString:@\"ph\"]) {\n        results = [PHAsset fetchAssetsWithLocalIdentifiers:@[[imageUri substringFromIndex: 5]] options:nil];\n    } else {\n        results = [PHAsset fetchAssetsWithALAssetURLs:@[url] options:nil];\n    }\n\n    if (results.count == 0) {\n        NSString *errorText = [NSString stringWithFormat:@\"Failed to fetch PHAsset with local identifier %@ with no error message.\", imageUri];\n\n        NSMutableDictionary* details = [NSMutableDictionary dictionary];\n        [details setValue:errorText forKey:NSLocalizedDescriptionKey];\n        NSError *error = [NSError errorWithDomain:@\"RNFS\" code:500 userInfo:details];\n        [self reject: reject withError:error];\n        return;\n    }\n\n    PHAsset *asset = [results firstObject];\n    PHImageRequestOptions *imageOptions = [PHImageRequestOptions new];\n\n    // Allow us to fetch images from iCloud\n    imageOptions.networkAccessAllowed = YES;\n\n\n    // Note: PhotoKit defaults to a deliveryMode of PHImageRequestOptionsDeliveryModeOpportunistic\n    // which means it may call back multiple times - we probably don't want that\n    imageOptions.deliveryMode = PHImageRequestOptionsDeliveryModeHighQualityFormat;\n\n    BOOL useMaximumSize = CGSizeEqualToSize(size, CGSizeZero);\n    CGSize targetSize;\n    if (useMaximumSize) {\n        targetSize = PHImageManagerMaximumSize;\n        imageOptions.resizeMode = PHImageRequestOptionsResizeModeNone;\n    } else {\n        targetSize = CGSizeApplyAffineTransform(size, CGAffineTransformMakeScale(scale, scale));\n        imageOptions.resizeMode = PHImageRequestOptionsResizeModeExact;\n    }\n\n    PHImageContentMode contentMode = PHImageContentModeAspectFill;\n    if (resizeMode == RCTResizeModeContain) {\n        contentMode = PHImageContentModeAspectFit;\n    }\n\n    // PHImageRequestID requestID =\n    [[PHImageManager defaultManager] requestImageForAsset:asset\n                                               targetSize:targetSize\n                                              contentMode:contentMode\n                                                  options:imageOptions\n                                            resultHandler:^(UIImage *result, NSDictionary<NSString *, id> *info) {\n        if (result) {\n\n            NSData *imageData = UIImageJPEGRepresentation(result, compression );\n            [imageData writeToFile:destination atomically:YES];\n            resolve(destination);\n\n        } else {\n            NSMutableDictionary* details = [NSMutableDictionary dictionary];\n            [details setValue:info[PHImageErrorKey] forKey:NSLocalizedDescriptionKey];\n            NSError *error = [NSError errorWithDomain:@\"RNFS\" code:501 userInfo:details];\n            [self reject: reject withError:error];\n\n        }\n    }];\n}\n#endif\n\n// [PHAsset fetchAssetsWithALAssetURLs] is deprecated and not supported in Mac Catalyst\n#if !TARGET_OS_UIKITFORMAC && !TARGET_OS_OSX\n/**\n * iOS Only: copy videos from the assets-library (camera-roll) to a specific path as mp4-file.\n *\n * To create a thumbnail from the video, refer to copyAssetsFileIOS\n */\nRCT_EXPORT_METHOD(copyAssetsVideoIOS: (NSString *) imageUri\n                  atFilepath: (NSString *) destination\n                  resolver: (RCTPromiseResolveBlock) resolve\n                  rejecter: (RCTPromiseRejectBlock) reject)\n{\n  NSURL* url = [NSURL URLWithString:imageUri];\n  //unused?\n  //__block NSURL* videoURL = [NSURL URLWithString:destination];\n  __block NSError *error = nil;\n\n  PHFetchResult *phAssetFetchResult = nil;\n  if ([url.scheme isEqualToString:@\"ph\"]) {\n      phAssetFetchResult = [PHAsset fetchAssetsWithLocalIdentifiers:@[[imageUri substringFromIndex: 5]] options:nil];\n  } else {\n      phAssetFetchResult = [PHAsset fetchAssetsWithALAssetURLs:@[url] options:nil];\n  }\n\n  PHAsset *phAsset = [phAssetFetchResult firstObject];\n\n  PHVideoRequestOptions *options = [[PHVideoRequestOptions alloc] init];\n  options.networkAccessAllowed = YES;\n  options.version = PHVideoRequestOptionsVersionOriginal;\n  options.deliveryMode = PHVideoRequestOptionsDeliveryModeAutomatic;\n\n  dispatch_group_t group = dispatch_group_create();\n  dispatch_group_enter(group);\n\n  [[PHImageManager defaultManager] requestAVAssetForVideo:phAsset options:options resultHandler:^(AVAsset *asset, AVAudioMix *audioMix, NSDictionary *info) {\n\n    if ([asset isKindOfClass:[AVURLAsset class]]) {\n      NSURL *url = [(AVURLAsset *)asset URL];\n      NSLog(@\"Final URL %@\",url);\n      BOOL writeResult = false;\n        \n      if (@available(iOS 9.0, *)) {\n          NSURL *destinationUrl = [NSURL fileURLWithPath:destination relativeToURL:nil];\n          writeResult = [[NSFileManager defaultManager] copyItemAtURL:url toURL:destinationUrl error:&error];\n      } else {\n          NSData *videoData = [NSData dataWithContentsOfURL:url];\n          writeResult = [videoData writeToFile:destination options:NSDataWritingAtomic error:&error];\n      }\n        \n      if(writeResult) {\n        NSLog(@\"video success\");\n      }\n      else {\n        NSLog(@\"video failure\");\n      }\n      dispatch_group_leave(group);\n    }\n  }];\n  dispatch_group_wait(group,  DISPATCH_TIME_FOREVER);\n\n  if (error) {\n    NSLog(@\"RNFS: %@\", error);\n    return [self reject:reject withError:error];\n  }\n\n  return resolve(destination);\n}\n#endif\n\nRCT_EXPORT_METHOD(touch:(NSString*)filepath\n                  mtime:(NSDate *)mtime\n                  ctime:(NSDate *)ctime\n                  resolver:(RCTPromiseResolveBlock)resolve\n                  rejecter:(RCTPromiseRejectBlock)reject)\n{\n    NSFileManager *manager = [NSFileManager defaultManager];\n    BOOL exists = [manager fileExistsAtPath:filepath isDirectory:false];\n\n    if (!exists) {\n        return reject(@\"ENOENT\", [NSString stringWithFormat:@\"ENOENT: no such file, open '%@'\", filepath], nil);\n    }\n\n    NSMutableDictionary *attr = [NSMutableDictionary dictionary];\n\n    if (mtime) {\n        [attr setValue:mtime forKey:NSFileModificationDate];\n    }\n    if (ctime) {\n        [attr setValue:ctime forKey:NSFileCreationDate];\n    }\n\n    NSError *error = nil;\n    BOOL success = [manager setAttributes:attr ofItemAtPath:filepath error:&error];\n\n    if (!success) {\n        return [self reject:reject withError:error];\n    }\n\n    resolve(nil);\n}\n\n\n- (NSNumber *)dateToTimeIntervalNumber:(NSDate *)date\n{\n  return @([date timeIntervalSince1970]);\n}\n\n- (void)reject:(RCTPromiseRejectBlock)reject withError:(NSError *)error\n{\n  NSString *codeWithDomain = [NSString stringWithFormat:@\"E%@%zd\", error.domain.uppercaseString, error.code];\n  reject(codeWithDomain, error.localizedDescription, error);\n}\n\n- (NSString *)getPathForDirectory:(int)directory\n{\n  NSArray *paths = NSSearchPathForDirectoriesInDomains(directory, NSUserDomainMask, YES);\n  return [paths firstObject];\n}\n\n- (NSDictionary *)constantsToExport\n{\n  return @{\n           @\"RNFSMainBundlePath\": [[NSBundle mainBundle] bundlePath],\n           @\"RNFSCachesDirectoryPath\": [self getPathForDirectory:NSCachesDirectory],\n           @\"RNFSDocumentDirectoryPath\": [self getPathForDirectory:NSDocumentDirectory],\n           @\"RNFSExternalDirectoryPath\": [NSNull null],\n           @\"RNFSExternalStorageDirectoryPath\": [NSNull null],\n           @\"RNFSTemporaryDirectoryPath\": NSTemporaryDirectory(),\n           @\"RNFSLibraryDirectoryPath\": [self getPathForDirectory:NSLibraryDirectory],\n           @\"RNFSFileTypeRegular\": NSFileTypeRegular,\n           @\"RNFSFileTypeDirectory\": NSFileTypeDirectory,\n           @\"RNFSFileProtectionComplete\": NSFileProtectionComplete,\n           @\"RNFSFileProtectionCompleteUnlessOpen\": NSFileProtectionCompleteUnlessOpen,\n           @\"RNFSFileProtectionCompleteUntilFirstUserAuthentication\": NSFileProtectionCompleteUntilFirstUserAuthentication,\n           @\"RNFSFileProtectionNone\": NSFileProtectionNone\n          };\n}\n\n+(void)setCompletionHandlerForIdentifier: (NSString *)identifier completionHandler: (CompletionHandler)completionHandler\n{\n    if (!completionHandlers) completionHandlers = [[NSMutableDictionary alloc] init];\n    [completionHandlers setValue:completionHandler forKey:identifier];\n}\n\n@end\n"
        },
        {
          "name": "Uploader.h",
          "type": "blob",
          "size": 1.0625,
          "content": "#import <Foundation/Foundation.h>\n\n#if !TARGET_OS_OSX\n#import <MobileCoreServices/MobileCoreServices.h>\n#endif\n\ntypedef void (^UploadCompleteCallback)(NSString*, NSURLResponse *);\ntypedef void (^UploadErrorCallback)(NSError*);\ntypedef void (^UploadBeginCallback)(void);\ntypedef void (^UploadProgressCallback)(NSNumber*, NSNumber*);\n\n@interface RNFSUploadParams : NSObject\n\n@property (copy) NSString* toUrl;\n@property (copy) NSArray* files;\n@property (copy) NSDictionary* headers;\n@property (copy) NSDictionary* fields;\n@property (copy) NSString* method;\n@property (assign) BOOL binaryStreamOnly;\n@property (copy) UploadCompleteCallback completeCallback;    // Upload has finished (data written)\n@property (copy) UploadErrorCallback errorCallback;         // Something gone wrong\n@property (copy) UploadBeginCallback beginCallback;         // Upload has started\n@property (copy) UploadProgressCallback progressCallback;   // Upload is progressing\n\n@end\n\n@interface RNFSUploader : NSObject <NSURLConnectionDelegate>\n\n- (void)uploadFiles:(RNFSUploadParams*)params;\n- (void)stopUpload;\n\n@end\n"
        },
        {
          "name": "Uploader.m",
          "type": "blob",
          "size": 5.671875,
          "content": "#import \"Uploader.h\"\n\n@implementation RNFSUploadParams\n\n@end\n\n@interface RNFSUploader()\n\n@property (copy) RNFSUploadParams* params;\n\n@property (retain) NSURLSessionDataTask* task;\n\n@end\n\n@implementation RNFSUploader\n\n- (void)uploadFiles:(RNFSUploadParams*)params\n{\n  _params = params;\n\n  NSString *method = _params.method;\n  NSURL *url = [NSURL URLWithString:_params.toUrl];\n  NSMutableURLRequest *req = [NSMutableURLRequest requestWithURL:url];\n  [req setHTTPMethod:method];\n  BOOL binaryStreamOnly = _params.binaryStreamOnly;\n\n  // set headers\n  NSString *formBoundaryString = [self generateBoundaryString];\n  NSString *contentType = [NSString stringWithFormat:@\"multipart/form-data; boundary=%@\", formBoundaryString];\n  [req setValue:contentType forHTTPHeaderField:@\"Content-Type\"];\n  for (NSString *key in _params.headers) {\n    id val = [_params.headers objectForKey:key];\n    if ([val respondsToSelector:@selector(stringValue)]) {\n      val = [val stringValue];\n    }\n    if (![val isKindOfClass:[NSString class]]) {\n      continue;\n    }\n    [req setValue:val forHTTPHeaderField:key];\n  }\n\n  NSData *formBoundaryData = [[NSString stringWithFormat:@\"--%@\\r\\n\", formBoundaryString] dataUsingEncoding:NSUTF8StringEncoding];\n  NSMutableData* reqBody = [NSMutableData data];\n\n  // add fields\n  for (NSString *key in _params.fields) {\n    id val = [_params.fields objectForKey:key];\n    if ([val respondsToSelector:@selector(stringValue)]) {\n      val = [val stringValue];\n    }\n    if (![val isKindOfClass:[NSString class]]) {\n      continue;\n    }\n\n    [reqBody appendData:formBoundaryData];\n    [reqBody appendData:[[NSString stringWithFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"\\r\\n\\r\\n\", key] dataUsingEncoding:NSUTF8StringEncoding]];\n    [reqBody appendData:[val dataUsingEncoding:NSUTF8StringEncoding]];\n    [reqBody appendData:[@\"\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding]];\n  }\n  NSArray *files = _params.files;\n  // add files\n  for (NSDictionary *file in files) {\n    NSString *name = file[@\"name\"];\n    NSString *filename = file[@\"filename\"];\n    NSString *filepath = file[@\"filepath\"];\n    NSString *filetype = file[@\"filetype\"];\n\n    // Check if file exists\n    NSFileManager *fileManager = [NSFileManager defaultManager];\n    if (![fileManager fileExistsAtPath:filepath]){\n      // NSError* error = [NSError errorWithDomain:@\"Uploader\" code:NSURLErrorFileDoesNotExist userInfo:@{NSLocalizedDescriptionKey: [NSString stringWithFormat: @\"Failed to open target file at path: %@\", filepath]}];\n      // return _params.errorCallback(error);\n      NSLog(@\"Failed to open target file at path: %@\", filepath);\n      continue;\n    }\n\n    NSData *fileData = [NSData dataWithContentsOfFile:filepath];\n    if (!binaryStreamOnly) {\n      [reqBody appendData:formBoundaryData];\n      [reqBody appendData:[[NSString stringWithFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\\r\\n\", name.length ? name : filename, filename] dataUsingEncoding:NSUTF8StringEncoding]];\n\n      if (filetype) {\n        [reqBody appendData:[[NSString stringWithFormat:@\"Content-Type: %@\\r\\n\", filetype] dataUsingEncoding:NSUTF8StringEncoding]];\n      } else {\n        [reqBody appendData:[[NSString stringWithFormat:@\"Content-Type: %@\\r\\n\", [self mimeTypeForPath:filename]] dataUsingEncoding:NSUTF8StringEncoding]];\n      }\n      [reqBody appendData:[[NSString stringWithFormat:@\"Content-Length: %ld\\r\\n\\r\\n\", (long)[fileData length]] dataUsingEncoding:NSUTF8StringEncoding]];\n    }\n\n    [reqBody appendData:fileData];\n    if (!binaryStreamOnly) {\n      [reqBody appendData:[@\"\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding]];\n    }\n  }\n\n  if (!binaryStreamOnly) {\n    // add end boundary\n    NSData* end = [[NSString stringWithFormat:@\"--%@--\\r\\n\", formBoundaryString] dataUsingEncoding:NSUTF8StringEncoding];\n    [reqBody appendData:end];\n  }\n\n  // send request\n  [req setHTTPBody:reqBody];\n\n  NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];\n  NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration delegate:(id)self delegateQueue:[NSOperationQueue mainQueue]];\n  _task = [session dataTaskWithRequest:req completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n      NSString * str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n      return self->_params.completeCallback(str, response);\n  }];\n  [_task resume];\n  [session finishTasksAndInvalidate];\n  if (_params.beginCallback) {\n    _params.beginCallback();\n  }\n}\n\n- (NSString *)generateBoundaryString\n{\n  NSString *uuid = [[NSUUID UUID] UUIDString];\n  return [NSString stringWithFormat:@\"----%@\", uuid];\n}\n\n- (NSString *)mimeTypeForPath:(NSString *)filepath\n{\n  NSString *fileExtension = [filepath pathExtension];\n  NSString *UTI = (__bridge_transfer NSString *)UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, (__bridge CFStringRef)fileExtension, NULL);\n  NSString *contentType = (__bridge_transfer NSString *)UTTypeCopyPreferredTagWithClass((__bridge CFStringRef)UTI, kUTTagClassMIMEType);\n\n  if (contentType) {\n    return contentType;\n  }\n  return @\"application/octet-stream\";\n}\n\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error\n{\n  if(error != nil) {\n    return _params.errorCallback(error);\n  }\n}\n\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(NSInteger)totalBytesExpectedToSend\n{\n  if (_params.progressCallback) {\n    _params.progressCallback([NSNumber numberWithLongLong:totalBytesExpectedToSend], [NSNumber numberWithLongLong:totalBytesSent]);\n  }\n}\n\n- (void)stopUpload\n{\n  [_task cancel];\n}\n\n@end\n"
        },
        {
          "name": "android",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.d.ts",
          "type": "blob",
          "size": 9.1396484375,
          "content": "type MkdirOptions = {\n\tNSURLIsExcludedFromBackupKey?: boolean // iOS only\n\tNSFileProtectionKey?: string // IOS only\n}\n\ntype FileOptions = {\n\tNSFileProtectionKey?: string // IOS only\n}\n\ntype ReadDirItem = {\n\tctime: Date | undefined // The creation date of the file (iOS only)\n\tmtime: Date | undefined // The last modified date of the file\n\tname: string // The name of the item\n\tpath: string // The absolute path to the item\n\tsize: number // Size in bytes\n\tisFile: () => boolean // Is the file just a file?\n\tisDirectory: () => boolean // Is the file a directory?\n}\n\ntype StatResult = {\n\tname: string | undefined // The name of the item TODO: why is this not documented?\n\tpath: string // The absolute path to the item\n\tsize: number // Size in bytes\n\tmode: number // UNIX file mode\n\tctime: number // Created date\n\tmtime: number // Last modified date\n\toriginalFilepath: string // In case of content uri this is the pointed file path, otherwise is the same as path\n\tisFile: () => boolean // Is the file just a file?\n\tisDirectory: () => boolean // Is the file a directory?\n}\n\ntype Headers = { [name: string]: string }\ntype Fields = { [name: string]: string }\n\ntype DownloadFileOptions = {\n\tfromUrl: string // URL to download file from\n\ttoFile: string // Local filesystem path to save the file to\n\theaders?: Headers // An object of headers to be passed to the server\n\tbackground?: boolean // Continue the download in the background after the app terminates (iOS only)\n\tdiscretionary?: boolean // Allow the OS to control the timing and speed of the download to improve perceived performance  (iOS only)\n\tcacheable?: boolean // Whether the download can be stored in the shared NSURLCache (iOS only)\n\tprogressInterval?: number\n\tprogressDivider?: number\n\tbegin?: (res: DownloadBeginCallbackResult) => void\n\tprogress?: (res: DownloadProgressCallbackResult) => void\n\tresumable?: () => void // only supported on iOS yet\n\tconnectionTimeout?: number // only supported on Android yet\n\treadTimeout?: number // supported on Android and iOS\n\tbackgroundTimeout?: number // Maximum time (in milliseconds) to download an entire resource (iOS only, useful for timing out background downloads)\n}\n\ntype DownloadBeginCallbackResult = {\n\tjobId: number // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n\tstatusCode: number // The HTTP status code\n\tcontentLength: number // The total size in bytes of the download resource\n\theaders: Headers // The HTTP response headers from the server\n}\n\ntype DownloadProgressCallbackResult = {\n\tjobId: number // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n\tcontentLength: number // The total size in bytes of the download resource\n\tbytesWritten: number // The number of bytes written to the file so far\n}\n\ntype DownloadResult = {\n\tjobId: number // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n\tstatusCode: number // The HTTP status code\n\tbytesWritten: number // The number of bytes written to the file\n}\n\ntype UploadFileOptions = {\n\ttoUrl: string // URL to upload file to\n\tbinaryStreamOnly?: boolean // Allow for binary data stream for file to be uploaded without extra headers, Default is 'false'\n\tfiles: UploadFileItem[] // An array of objects with the file information to be uploaded.\n\theaders?: Headers // An object of headers to be passed to the server\n\tfields?: Fields // An object of fields to be passed to the server\n\tmethod?: string // Default is 'POST', supports 'POST' and 'PUT'\n\tbeginCallback?: (res: UploadBeginCallbackResult) => void // deprecated\n\tprogressCallback?: (res: UploadProgressCallbackResult) => void // deprecated\n\tbegin?: (res: UploadBeginCallbackResult) => void\n\tprogress?: (res: UploadProgressCallbackResult) => void\n}\n\ntype UploadFileItem = {\n\tname: string // Name of the file, if not defined then filename is used\n\tfilename: string // Name of file\n\tfilepath: string // Path to file\n\tfiletype: string // The mimetype of the file to be uploaded, if not defined it will get mimetype from `filepath` extension\n}\n\ntype UploadBeginCallbackResult = {\n\tjobId: number // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n}\n\ntype UploadProgressCallbackResult = {\n\tjobId: number // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n\ttotalBytesExpectedToSend: number // The total number of bytes that will be sent to the server\n\ttotalBytesSent: number // The number of bytes sent to the server\n}\n\ntype UploadResult = {\n\tjobId: number // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n\tstatusCode: number // The HTTP status code\n\theaders: Headers // The HTTP response headers from the server\n\tbody: string // The HTTP response body\n}\n\ntype FSInfoResult = {\n\ttotalSpace: number // The total amount of storage space on the device (in bytes).\n\tfreeSpace: number // The amount of available storage space on the device (in bytes).\n}\n\nexport function mkdir(filepath: string, options?: MkdirOptions): Promise<void>\nexport function moveFile(\n\tfilepath: string,\n\tdestPath: string,\n\toptions?: FileOptions\n): Promise<void>\nexport function copyFile(\n\tfilepath: string,\n\tdestPath: string,\n\toptions?: FileOptions\n): Promise<void>\nexport function copyFolder(\n\tsrcPath: string,\n\tdestPath: string,\n): Promise<void>\nexport function pathForBundle(bundleNamed: string): Promise<string>\nexport function pathForGroup(groupName: string): Promise<string>\nexport function getFSInfo(): Promise<FSInfoResult>\nexport function getAllExternalFilesDirs(): Promise<string[]>\nexport function unlink(filepath: string): Promise<void>\nexport function exists(filepath: string): Promise<boolean>\n\nexport function stopDownload(jobId: number): void\n\nexport function resumeDownload(jobId: number): void\n\nexport function isResumable(jobId: number): Promise<boolean>\n\nexport function stopUpload(jobId: number): void\n\nexport function completeHandlerIOS(jobId: number): void\n\nexport function readDir(dirpath: string): Promise<ReadDirItem[]>\n\n/**\n * Android-only\n */\nexport function scanFile(path: string): Promise<string[]>\n\n/**\n * Android-only\n */\nexport function readDirAssets(dirpath: string): Promise<ReadDirItem[]>\n\n/**\n * Android-only\n */\nexport function existsAssets(filepath: string): Promise<boolean>\n\n/**\n * Android-only\n */\nexport function existsRes(filepath: string): Promise<boolean>\n\n/**\n * Node style version (lowercase d). Returns just the names\n */\nexport function readdir(dirpath: string): Promise<string[]>\n\n/**\n * Android-only\n */\nexport function setReadable(\n\tfilepath: string,\n\treadable: boolean,\n\townerOnly: boolean\n): Promise<boolean>\n\nexport function stat(filepath: string): Promise<StatResult>\n\nexport function readFile(\n\tfilepath: string,\n\tencodingOrOptions?: any\n): Promise<string>\nexport function read(\n\tfilepath: string,\n\tlength?: number,\n\tposition?: number,\n\tencodingOrOptions?: any\n): Promise<string>\n\n/**\n * Android only\n */\nexport function readFileAssets(\n\tfilepath: string,\n\tencodingOrOptions?: any\n): Promise<string>\n\n/**\n * Android only\n */\nexport function readFileRes(\n\tfilepath: string,\n\tencodingOrOptions?: any\n): Promise<string>\n\nexport function hash(filepath: string, algorithm: string): Promise<string>\n\n/**\n * Android only\n */\nexport function copyFileAssets(\n\tfilepath: string,\n\tdestPath: string\n): Promise<void>\n\n/**\n * Android only\n */\nexport function copyFileRes(\n\tfilepath: string,\n\tdestPath: string\n): Promise<void>\n\n/**\n * iOS only\n * Copies fotos from asset-library (camera-roll) to a specific location\n * with a given width or height\n * @see: https://developer.apple.com/reference/photos/phimagemanager/1616964-requestimageforasset\n */\nexport function copyAssetsFileIOS(\n\timageUri: string,\n\tdestPath: string,\n\twidth: number,\n\theight: number,\n\tscale?: number,\n\tcompression?: number,\n\tresizeMode?: string\n): Promise<string>\n\n/**\n * iOS only\n * Copies fotos from asset-library (camera-roll) to a specific location\n * with a given width or height\n * @see: https://developer.apple.com/reference/photos/phimagemanager/1616964-requestimageforasset\n */\nexport function copyAssetsVideoIOS(\n\timageUri: string,\n\tdestPath: string\n): Promise<string>\n\nexport function writeFile(\n\tfilepath: string,\n\tcontents: string,\n\tencodingOrOptions?: any\n): Promise<void>\n\nexport function appendFile(\n\tfilepath: string,\n\tcontents: string,\n\tencodingOrOptions?: string\n): Promise<void>\n\nexport function write(\n\tfilepath: string,\n\tcontents: string,\n\tposition?: number,\n\tencodingOrOptions?: any\n): Promise<void>\n\nexport function downloadFile(\n\toptions: DownloadFileOptions\n): { jobId: number; promise: Promise<DownloadResult> }\n\nexport function uploadFiles(\n\toptions: UploadFileOptions\n): { jobId: number; promise: Promise<UploadResult> }\n\nexport function touch(\n\tfilepath: string,\n\tmtime?: Date,\n\tctime?: Date,\n\tmodifyCreationTime?: boolean\n): Promise<void>\n\nexport const MainBundlePath: string\nexport const CachesDirectoryPath: string\nexport const ExternalCachesDirectoryPath: string\nexport const DownloadDirectoryPath: string\nexport const DocumentDirectoryPath: string\nexport const ExternalDirectoryPath: string\nexport const ExternalStorageDirectoryPath: string\nexport const TemporaryDirectoryPath: string\nexport const LibraryDirectoryPath: string\nexport const PicturesDirectoryPath: string\nexport const FileProtectionKeys: string\n"
        },
        {
          "name": "jsconfig.json",
          "type": "blob",
          "size": 0.0859375,
          "content": "{\n    \"compilerOptions\": {\n        \"target\": \"ES6\",\n        \"module\": \"commonjs\"\n    }\n}"
        },
        {
          "name": "package-lock.json",
          "type": "blob",
          "size": 6.28515625,
          "content": "{\n  \"name\": \"react-native-fs\",\n  \"version\": \"2.18.0\",\n  \"lockfileVersion\": 1,\n  \"requires\": true,\n  \"dependencies\": {\n    \"asap\": {\n      \"version\": \"2.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/asap/-/asap-2.0.6.tgz\",\n      \"integrity\": \"sha1-5QNHYR1+aQlDIIu9r+vLwvuGbUY=\",\n      \"dev\": true\n    },\n    \"base-64\": {\n      \"version\": \"0.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/base-64/-/base-64-0.1.0.tgz\",\n      \"integrity\": \"sha1-eAqZyE59YAJgNhURxId2E78k9rs=\"\n    },\n    \"core-js\": {\n      \"version\": \"1.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/core-js/-/core-js-1.2.7.tgz\",\n      \"integrity\": \"sha1-ZSKUwUZR2yj6k70tX/KYOk8IxjY=\",\n      \"dev\": true\n    },\n    \"create-react-class\": {\n      \"version\": \"15.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/create-react-class/-/create-react-class-15.6.3.tgz\",\n      \"integrity\": \"sha512-M+/3Q6E6DLO6Yx3OwrWjwHBnvfXXYA7W+dFjt/ZDBemHO1DDZhsalX/NUtnTYclN6GfnBDRh4qRHjcDHmlJBJg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"fbjs\": \"^0.8.9\",\n        \"loose-envify\": \"^1.3.1\",\n        \"object-assign\": \"^4.1.1\"\n      }\n    },\n    \"encoding\": {\n      \"version\": \"0.1.12\",\n      \"resolved\": \"https://registry.npmjs.org/encoding/-/encoding-0.1.12.tgz\",\n      \"integrity\": \"sha1-U4tm8+5izRq1HsMjgp0flIDHS+s=\",\n      \"dev\": true,\n      \"requires\": {\n        \"iconv-lite\": \"~0.4.13\"\n      }\n    },\n    \"fbjs\": {\n      \"version\": \"0.8.17\",\n      \"resolved\": \"https://registry.npmjs.org/fbjs/-/fbjs-0.8.17.tgz\",\n      \"integrity\": \"sha1-xNWY6taUkRJlPWWIsBpc3Nn5D90=\",\n      \"dev\": true,\n      \"requires\": {\n        \"core-js\": \"^1.0.0\",\n        \"isomorphic-fetch\": \"^2.1.1\",\n        \"loose-envify\": \"^1.0.0\",\n        \"object-assign\": \"^4.1.0\",\n        \"promise\": \"^7.1.1\",\n        \"setimmediate\": \"^1.0.5\",\n        \"ua-parser-js\": \"^0.7.18\"\n      }\n    },\n    \"flow-bin\": {\n      \"version\": \"0.109.0\",\n      \"resolved\": \"https://registry.npmjs.org/flow-bin/-/flow-bin-0.109.0.tgz\",\n      \"integrity\": \"sha512-tpcMTpAGIRivYhFV3KJq+zHI2HzcXo8MoGe9pXS4G/UZuey2Faq/e8/gdph2WF0erRlML5hmwfwiq7v9c25c7w==\",\n      \"dev\": true\n    },\n    \"iconv-lite\": {\n      \"version\": \"0.4.24\",\n      \"resolved\": \"https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz\",\n      \"integrity\": \"sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"safer-buffer\": \">= 2.1.2 < 3\"\n      }\n    },\n    \"is-stream\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-stream/-/is-stream-1.1.0.tgz\",\n      \"integrity\": \"sha1-EtSj3U5o4Lec6428hBc66A2RykQ=\",\n      \"dev\": true\n    },\n    \"isomorphic-fetch\": {\n      \"version\": \"2.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/isomorphic-fetch/-/isomorphic-fetch-2.2.1.tgz\",\n      \"integrity\": \"sha1-YRrhrPFPXoH3KVB0coGf6XM1WKk=\",\n      \"dev\": true,\n      \"requires\": {\n        \"node-fetch\": \"^1.0.1\",\n        \"whatwg-fetch\": \">=0.10.0\"\n      }\n    },\n    \"js-tokens\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz\",\n      \"integrity\": \"sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==\",\n      \"dev\": true\n    },\n    \"loose-envify\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz\",\n      \"integrity\": \"sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==\",\n      \"dev\": true,\n      \"requires\": {\n        \"js-tokens\": \"^3.0.0 || ^4.0.0\"\n      }\n    },\n    \"node-fetch\": {\n      \"version\": \"1.7.3\",\n      \"resolved\": \"https://registry.npmjs.org/node-fetch/-/node-fetch-1.7.3.tgz\",\n      \"integrity\": \"sha512-NhZ4CsKx7cYm2vSrBAr2PvFOe6sWDf0UYLRqA6svUYg7+/TSfVAu49jYC4BvQ4Sms9SZgdqGBgroqfDhJdTyKQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"encoding\": \"^0.1.11\",\n        \"is-stream\": \"^1.0.1\"\n      }\n    },\n    \"object-assign\": {\n      \"version\": \"4.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz\",\n      \"integrity\": \"sha1-IQmtx5ZYh8/AXLvUQsrIv7s2CGM=\",\n      \"dev\": true\n    },\n    \"promise\": {\n      \"version\": \"7.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/promise/-/promise-7.3.1.tgz\",\n      \"integrity\": \"sha512-nolQXZ/4L+bP/UGlkfaIujX9BKxGwmQ9OT4mOt5yvy8iK1h3wqTEJCijzGANTCCl9nWjY41juyAn2K3Q1hLLTg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"asap\": \"~2.0.3\"\n      }\n    },\n    \"prop-types\": {\n      \"version\": \"15.7.2\",\n      \"resolved\": \"https://registry.npmjs.org/prop-types/-/prop-types-15.7.2.tgz\",\n      \"integrity\": \"sha512-8QQikdH7//R2vurIJSutZ1smHYTcLpRWEOlHnzcWHmBYrOGUysKwSsrC89BCiFj3CbrfJ/nXFdJepOVrY1GCHQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"loose-envify\": \"^1.4.0\",\n        \"object-assign\": \"^4.1.1\",\n        \"react-is\": \"^16.8.1\"\n      }\n    },\n    \"react-is\": {\n      \"version\": \"16.10.2\",\n      \"resolved\": \"https://registry.npmjs.org/react-is/-/react-is-16.10.2.tgz\",\n      \"integrity\": \"sha512-INBT1QEgtcCCgvccr5/86CfD71fw9EPmDxgiJX4I2Ddr6ZsV6iFXsuby+qWJPtmNuMY0zByTsG4468P7nHuNWA==\",\n      \"dev\": true\n    },\n    \"safer-buffer\": {\n      \"version\": \"2.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz\",\n      \"integrity\": \"sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==\",\n      \"dev\": true\n    },\n    \"setimmediate\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/setimmediate/-/setimmediate-1.0.5.tgz\",\n      \"integrity\": \"sha1-KQy7Iy4waULX1+qbg3Mqt4VvgoU=\",\n      \"dev\": true\n    },\n    \"ua-parser-js\": {\n      \"version\": \"0.7.28\",\n      \"resolved\": \"https://registry.npmjs.org/ua-parser-js/-/ua-parser-js-0.7.28.tgz\",\n      \"integrity\": \"sha512-6Gurc1n//gjp9eQNXjD9O3M/sMwVtN5S8Lv9bvOYBfKfDNiIIhqiyi01vMBO45u4zkDE420w/e0se7Vs+sIg+g==\",\n      \"dev\": true\n    },\n    \"utf8\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/utf8/-/utf8-3.0.0.tgz\",\n      \"integrity\": \"sha512-E8VjFIQ/TyQgp+TZfS6l8yp/xWppSAHzidGiRrqe4bK4XP9pTRyKFgGJpO3SN7zdX4DeomTrwaseCHovfpFcqQ==\"\n    },\n    \"whatwg-fetch\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/whatwg-fetch/-/whatwg-fetch-3.0.0.tgz\",\n      \"integrity\": \"sha512-9GSJUgz1D4MfyKU7KRqwOjXCXTqWdFNvEr7eUBYchQiVc744mqK/MzXPNR2WsPkmkOa4ywfg8C2n8h+13Bey1Q==\",\n      \"dev\": true\n    }\n  }\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.009765625,
          "content": "{\n  \"name\": \"react-native-fs\",\n  \"version\": \"2.20.0\",\n  \"description\": \"Native filesystem access for react-native\",\n  \"main\": \"FS.common.js\",\n  \"typings\": \"index.d.ts\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"flow\": \"flow; test $? -eq 0 -o $? -eq 2\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git@github.com:itinance/react-native-fs.git\"\n  },\n  \"keywords\": [\n    \"react-component\",\n    \"react-native\",\n    \"ios\",\n    \"android\",\n    \"fs\",\n    \"filesystem\",\n    \"download\",\n    \"upload\",\n    \"file-transfer\"\n  ],\n  \"author\": \"Johannes Lumpe <johannes@lum.pe> (https://github.com/johanneslumpe)\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"base-64\": \"^0.1.0\",\n    \"utf8\": \"^3.0.0\"\n  },\n  \"devDependencies\": {\n    \"create-react-class\": \"15.6.3\",\n    \"flow-bin\": \"^0.109.0\",\n    \"prop-types\": \"^15.7.2\"\n  },\n  \"peerDependencies\": {\n    \"react-native\": \"*\",\n    \"react-native-windows\": \"*\"\n  },\n  \"peerDependenciesMeta\": {\n    \"react-native-windows\": {\n      \"optional\": true\n    }\n  }\n}\n"
        },
        {
          "name": "windows",
          "type": "tree",
          "content": null
        },
        {
          "name": "windows_legacy",
          "type": "tree",
          "content": null
        },
        {
          "name": "yarn.lock",
          "type": "blob",
          "size": 5.9326171875,
          "content": "# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n\nasap@~2.0.3:\n  version \"2.0.6\"\n  resolved \"https://registry.yarnpkg.com/asap/-/asap-2.0.6.tgz#e50347611d7e690943208bbdafebcbc2fb866d46\"\n  integrity sha1-5QNHYR1+aQlDIIu9r+vLwvuGbUY=\n\nbase-64@^0.1.0:\n  version \"0.1.0\"\n  resolved \"https://registry.yarnpkg.com/base-64/-/base-64-0.1.0.tgz#780a99c84e7d600260361511c4877613bf24f6bb\"\n  integrity sha1-eAqZyE59YAJgNhURxId2E78k9rs=\n\ncore-js@^1.0.0:\n  version \"1.2.7\"\n  resolved \"https://registry.yarnpkg.com/core-js/-/core-js-1.2.7.tgz#652294c14651db28fa93bd2d5ff2983a4f08c636\"\n  integrity sha1-ZSKUwUZR2yj6k70tX/KYOk8IxjY=\n\ncreate-react-class@15.6.3:\n  version \"15.6.3\"\n  resolved \"https://registry.yarnpkg.com/create-react-class/-/create-react-class-15.6.3.tgz#2d73237fb3f970ae6ebe011a9e66f46dbca80036\"\n  integrity sha512-M+/3Q6E6DLO6Yx3OwrWjwHBnvfXXYA7W+dFjt/ZDBemHO1DDZhsalX/NUtnTYclN6GfnBDRh4qRHjcDHmlJBJg==\n  dependencies:\n    fbjs \"^0.8.9\"\n    loose-envify \"^1.3.1\"\n    object-assign \"^4.1.1\"\n\nencoding@^0.1.11:\n  version \"0.1.12\"\n  resolved \"https://registry.yarnpkg.com/encoding/-/encoding-0.1.12.tgz#538b66f3ee62cd1ab51ec323829d1f9480c74beb\"\n  integrity sha1-U4tm8+5izRq1HsMjgp0flIDHS+s=\n  dependencies:\n    iconv-lite \"~0.4.13\"\n\nfbjs@^0.8.9:\n  version \"0.8.17\"\n  resolved \"https://registry.yarnpkg.com/fbjs/-/fbjs-0.8.17.tgz#c4d598ead6949112653d6588b01a5cdcd9f90fdd\"\n  integrity sha1-xNWY6taUkRJlPWWIsBpc3Nn5D90=\n  dependencies:\n    core-js \"^1.0.0\"\n    isomorphic-fetch \"^2.1.1\"\n    loose-envify \"^1.0.0\"\n    object-assign \"^4.1.0\"\n    promise \"^7.1.1\"\n    setimmediate \"^1.0.5\"\n    ua-parser-js \"^0.7.18\"\n\nflow-bin@^0.109.0:\n  version \"0.109.0\"\n  resolved \"https://registry.yarnpkg.com/flow-bin/-/flow-bin-0.109.0.tgz#dcdcb7402dd85b58200392d8716ccf14e5a8c24c\"\n  integrity sha512-tpcMTpAGIRivYhFV3KJq+zHI2HzcXo8MoGe9pXS4G/UZuey2Faq/e8/gdph2WF0erRlML5hmwfwiq7v9c25c7w==\n\niconv-lite@~0.4.13:\n  version \"0.4.24\"\n  resolved \"https://registry.yarnpkg.com/iconv-lite/-/iconv-lite-0.4.24.tgz#2022b4b25fbddc21d2f524974a474aafe733908b\"\n  integrity sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==\n  dependencies:\n    safer-buffer \">= 2.1.2 < 3\"\n\nis-stream@^1.0.1:\n  version \"1.1.0\"\n  resolved \"https://registry.yarnpkg.com/is-stream/-/is-stream-1.1.0.tgz#12d4a3dd4e68e0b79ceb8dbc84173ae80d91ca44\"\n  integrity sha1-EtSj3U5o4Lec6428hBc66A2RykQ=\n\nisomorphic-fetch@^2.1.1:\n  version \"2.2.1\"\n  resolved \"https://registry.yarnpkg.com/isomorphic-fetch/-/isomorphic-fetch-2.2.1.tgz#611ae1acf14f5e81f729507472819fe9733558a9\"\n  integrity sha1-YRrhrPFPXoH3KVB0coGf6XM1WKk=\n  dependencies:\n    node-fetch \"^1.0.1\"\n    whatwg-fetch \">=0.10.0\"\n\n\"js-tokens@^3.0.0 || ^4.0.0\":\n  version \"4.0.0\"\n  resolved \"https://registry.yarnpkg.com/js-tokens/-/js-tokens-4.0.0.tgz#19203fb59991df98e3a287050d4647cdeaf32499\"\n  integrity sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==\n\nloose-envify@^1.0.0, loose-envify@^1.3.1, loose-envify@^1.4.0:\n  version \"1.4.0\"\n  resolved \"https://registry.yarnpkg.com/loose-envify/-/loose-envify-1.4.0.tgz#71ee51fa7be4caec1a63839f7e682d8132d30caf\"\n  integrity sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==\n  dependencies:\n    js-tokens \"^3.0.0 || ^4.0.0\"\n\nnode-fetch@^1.0.1:\n  version \"1.7.3\"\n  resolved \"https://registry.yarnpkg.com/node-fetch/-/node-fetch-1.7.3.tgz#980f6f72d85211a5347c6b2bc18c5b84c3eb47ef\"\n  integrity sha512-NhZ4CsKx7cYm2vSrBAr2PvFOe6sWDf0UYLRqA6svUYg7+/TSfVAu49jYC4BvQ4Sms9SZgdqGBgroqfDhJdTyKQ==\n  dependencies:\n    encoding \"^0.1.11\"\n    is-stream \"^1.0.1\"\n\nobject-assign@^4.1.0, object-assign@^4.1.1:\n  version \"4.1.1\"\n  resolved \"https://registry.yarnpkg.com/object-assign/-/object-assign-4.1.1.tgz#2109adc7965887cfc05cbbd442cac8bfbb360863\"\n  integrity sha1-IQmtx5ZYh8/AXLvUQsrIv7s2CGM=\n\npromise@^7.1.1:\n  version \"7.3.1\"\n  resolved \"https://registry.yarnpkg.com/promise/-/promise-7.3.1.tgz#064b72602b18f90f29192b8b1bc418ffd1ebd3bf\"\n  integrity sha512-nolQXZ/4L+bP/UGlkfaIujX9BKxGwmQ9OT4mOt5yvy8iK1h3wqTEJCijzGANTCCl9nWjY41juyAn2K3Q1hLLTg==\n  dependencies:\n    asap \"~2.0.3\"\n\nprop-types@^15.7.2:\n  version \"15.7.2\"\n  resolved \"https://registry.yarnpkg.com/prop-types/-/prop-types-15.7.2.tgz#52c41e75b8c87e72b9d9360e0206b99dcbffa6c5\"\n  integrity sha512-8QQikdH7//R2vurIJSutZ1smHYTcLpRWEOlHnzcWHmBYrOGUysKwSsrC89BCiFj3CbrfJ/nXFdJepOVrY1GCHQ==\n  dependencies:\n    loose-envify \"^1.4.0\"\n    object-assign \"^4.1.1\"\n    react-is \"^16.8.1\"\n\nreact-is@^16.8.1:\n  version \"16.8.6\"\n  resolved \"https://registry.yarnpkg.com/react-is/-/react-is-16.8.6.tgz#5bbc1e2d29141c9fbdfed456343fe2bc430a6a16\"\n  integrity sha512-aUk3bHfZ2bRSVFFbbeVS4i+lNPZr3/WM5jT2J5omUVV1zzcs1nAaf3l51ctA5FFvCRbhrH0bdAsRRQddFJZPtA==\n\n\"safer-buffer@>= 2.1.2 < 3\":\n  version \"2.1.2\"\n  resolved \"https://registry.yarnpkg.com/safer-buffer/-/safer-buffer-2.1.2.tgz#44fa161b0187b9549dd84bb91802f9bd8385cd6a\"\n  integrity sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==\n\nsetimmediate@^1.0.5:\n  version \"1.0.5\"\n  resolved \"https://registry.yarnpkg.com/setimmediate/-/setimmediate-1.0.5.tgz#290cbb232e306942d7d7ea9b83732ab7856f8285\"\n  integrity sha1-KQy7Iy4waULX1+qbg3Mqt4VvgoU=\n\nua-parser-js@^0.7.18:\n  version \"0.7.28\"\n  resolved \"https://registry.yarnpkg.com/ua-parser-js/-/ua-parser-js-0.7.28.tgz#8ba04e653f35ce210239c64661685bf9121dec31\"\n  integrity sha512-6Gurc1n//gjp9eQNXjD9O3M/sMwVtN5S8Lv9bvOYBfKfDNiIIhqiyi01vMBO45u4zkDE420w/e0se7Vs+sIg+g==\n\nutf8@^3.0.0:\n  version \"3.0.0\"\n  resolved \"https://registry.yarnpkg.com/utf8/-/utf8-3.0.0.tgz#f052eed1364d696e769ef058b183df88c87f69d1\"\n  integrity sha512-E8VjFIQ/TyQgp+TZfS6l8yp/xWppSAHzidGiRrqe4bK4XP9pTRyKFgGJpO3SN7zdX4DeomTrwaseCHovfpFcqQ==\n\nwhatwg-fetch@>=0.10.0:\n  version \"3.0.0\"\n  resolved \"https://registry.yarnpkg.com/whatwg-fetch/-/whatwg-fetch-3.0.0.tgz#fc804e458cc460009b1a2b966bc8817d2578aefb\"\n  integrity sha512-9GSJUgz1D4MfyKU7KRqwOjXCXTqWdFNvEr7eUBYchQiVc744mqK/MzXPNR2WsPkmkOa4ywfg8C2n8h+13Bey1Q==\n"
        }
      ]
    }
  ]
}