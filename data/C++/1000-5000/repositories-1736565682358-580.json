{
  "metadata": {
    "timestamp": 1736565682358,
    "page": 580,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "T-vK/ESP32-BLE-Keyboard",
      "stars": 2536,
      "defaultBranch": "master",
      "files": [
        {
          "name": "BleKeyboard.cpp",
          "type": "blob",
          "size": 15.98046875,
          "content": "#include \"BleKeyboard.h\"\n\n#if defined(USE_NIMBLE)\n#include <NimBLEDevice.h>\n#include <NimBLEServer.h>\n#include <NimBLEUtils.h>\n#include <NimBLEHIDDevice.h>\n#else\n#include <BLEDevice.h>\n#include <BLEUtils.h>\n#include <BLEServer.h>\n#include \"BLE2902.h\"\n#include \"BLEHIDDevice.h\"\n#endif // USE_NIMBLE\n#include \"HIDTypes.h\"\n#include <driver/adc.h>\n#include \"sdkconfig.h\"\n\n\n#if defined(CONFIG_ARDUHAL_ESP_LOG)\n  #include \"esp32-hal-log.h\"\n  #define LOG_TAG \"\"\n#else\n  #include \"esp_log.h\"\n  static const char* LOG_TAG = \"BLEDevice\";\n#endif\n\n\n// Report IDs:\n#define KEYBOARD_ID 0x01\n#define MEDIA_KEYS_ID 0x02\n\nstatic const uint8_t _hidReportDescriptor[] = {\n  USAGE_PAGE(1),      0x01,          // USAGE_PAGE (Generic Desktop Ctrls)\n  USAGE(1),           0x06,          // USAGE (Keyboard)\n  COLLECTION(1),      0x01,          // COLLECTION (Application)\n  // ------------------------------------------------- Keyboard\n  REPORT_ID(1),       KEYBOARD_ID,   //   REPORT_ID (1)\n  USAGE_PAGE(1),      0x07,          //   USAGE_PAGE (Kbrd/Keypad)\n  USAGE_MINIMUM(1),   0xE0,          //   USAGE_MINIMUM (0xE0)\n  USAGE_MAXIMUM(1),   0xE7,          //   USAGE_MAXIMUM (0xE7)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM (0)\n  LOGICAL_MAXIMUM(1), 0x01,          //   Logical Maximum (1)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  REPORT_COUNT(1),    0x08,          //   REPORT_COUNT (8)\n  HIDINPUT(1),        0x02,          //   INPUT (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  REPORT_COUNT(1),    0x01,          //   REPORT_COUNT (1) ; 1 byte (Reserved)\n  REPORT_SIZE(1),     0x08,          //   REPORT_SIZE (8)\n  HIDINPUT(1),        0x01,          //   INPUT (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  REPORT_COUNT(1),    0x05,          //   REPORT_COUNT (5) ; 5 bits (Num lock, Caps lock, Scroll lock, Compose, Kana)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  USAGE_PAGE(1),      0x08,          //   USAGE_PAGE (LEDs)\n  USAGE_MINIMUM(1),   0x01,          //   USAGE_MINIMUM (0x01) ; Num Lock\n  USAGE_MAXIMUM(1),   0x05,          //   USAGE_MAXIMUM (0x05) ; Kana\n  HIDOUTPUT(1),       0x02,          //   OUTPUT (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)\n  REPORT_COUNT(1),    0x01,          //   REPORT_COUNT (1) ; 3 bits (Padding)\n  REPORT_SIZE(1),     0x03,          //   REPORT_SIZE (3)\n  HIDOUTPUT(1),       0x01,          //   OUTPUT (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)\n  REPORT_COUNT(1),    0x06,          //   REPORT_COUNT (6) ; 6 bytes (Keys)\n  REPORT_SIZE(1),     0x08,          //   REPORT_SIZE(8)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM(0)\n  LOGICAL_MAXIMUM(1), 0x65,          //   LOGICAL_MAXIMUM(0x65) ; 101 keys\n  USAGE_PAGE(1),      0x07,          //   USAGE_PAGE (Kbrd/Keypad)\n  USAGE_MINIMUM(1),   0x00,          //   USAGE_MINIMUM (0)\n  USAGE_MAXIMUM(1),   0x65,          //   USAGE_MAXIMUM (0x65)\n  HIDINPUT(1),        0x00,          //   INPUT (Data,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  END_COLLECTION(0),                 // END_COLLECTION\n  // ------------------------------------------------- Media Keys\n  USAGE_PAGE(1),      0x0C,          // USAGE_PAGE (Consumer)\n  USAGE(1),           0x01,          // USAGE (Consumer Control)\n  COLLECTION(1),      0x01,          // COLLECTION (Application)\n  REPORT_ID(1),       MEDIA_KEYS_ID, //   REPORT_ID (3)\n  USAGE_PAGE(1),      0x0C,          //   USAGE_PAGE (Consumer)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM (0)\n  LOGICAL_MAXIMUM(1), 0x01,          //   LOGICAL_MAXIMUM (1)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  REPORT_COUNT(1),    0x10,          //   REPORT_COUNT (16)\n  USAGE(1),           0xB5,          //   USAGE (Scan Next Track)     ; bit 0: 1\n  USAGE(1),           0xB6,          //   USAGE (Scan Previous Track) ; bit 1: 2\n  USAGE(1),           0xB7,          //   USAGE (Stop)                ; bit 2: 4\n  USAGE(1),           0xCD,          //   USAGE (Play/Pause)          ; bit 3: 8\n  USAGE(1),           0xE2,          //   USAGE (Mute)                ; bit 4: 16\n  USAGE(1),           0xE9,          //   USAGE (Volume Increment)    ; bit 5: 32\n  USAGE(1),           0xEA,          //   USAGE (Volume Decrement)    ; bit 6: 64\n  USAGE(2),           0x23, 0x02,    //   Usage (WWW Home)            ; bit 7: 128\n  USAGE(2),           0x94, 0x01,    //   Usage (My Computer) ; bit 0: 1\n  USAGE(2),           0x92, 0x01,    //   Usage (Calculator)  ; bit 1: 2\n  USAGE(2),           0x2A, 0x02,    //   Usage (WWW fav)     ; bit 2: 4\n  USAGE(2),           0x21, 0x02,    //   Usage (WWW search)  ; bit 3: 8\n  USAGE(2),           0x26, 0x02,    //   Usage (WWW stop)    ; bit 4: 16\n  USAGE(2),           0x24, 0x02,    //   Usage (WWW back)    ; bit 5: 32\n  USAGE(2),           0x83, 0x01,    //   Usage (Media sel)   ; bit 6: 64\n  USAGE(2),           0x8A, 0x01,    //   Usage (Mail)        ; bit 7: 128\n  HIDINPUT(1),        0x02,          //   INPUT (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  END_COLLECTION(0)                  // END_COLLECTION\n};\n\nBleKeyboard::BleKeyboard(std::string deviceName, std::string deviceManufacturer, uint8_t batteryLevel) \n    : hid(0)\n    , deviceName(std::string(deviceName).substr(0, 15))\n    , deviceManufacturer(std::string(deviceManufacturer).substr(0,15))\n    , batteryLevel(batteryLevel) {}\n\nvoid BleKeyboard::begin(void)\n{\n  BLEDevice::init(deviceName);\n  BLEServer* pServer = BLEDevice::createServer();\n  pServer->setCallbacks(this);\n\n  hid = new BLEHIDDevice(pServer);\n  inputKeyboard = hid->inputReport(KEYBOARD_ID);  // <-- input REPORTID from report map\n  outputKeyboard = hid->outputReport(KEYBOARD_ID);\n  inputMediaKeys = hid->inputReport(MEDIA_KEYS_ID);\n\n  outputKeyboard->setCallbacks(this);\n\n  hid->manufacturer()->setValue(deviceManufacturer);\n\n  hid->pnp(0x02, vid, pid, version);\n  hid->hidInfo(0x00, 0x01);\n\n\n#if defined(USE_NIMBLE)\n\n  BLEDevice::setSecurityAuth(true, true, true);\n\n#else\n\n  BLESecurity* pSecurity = new BLESecurity();\n  pSecurity->setAuthenticationMode(ESP_LE_AUTH_REQ_SC_MITM_BOND);\n\n#endif // USE_NIMBLE\n\n  hid->reportMap((uint8_t*)_hidReportDescriptor, sizeof(_hidReportDescriptor));\n  hid->startServices();\n\n  onStarted(pServer);\n\n  advertising = pServer->getAdvertising();\n  advertising->setAppearance(HID_KEYBOARD);\n  advertising->addServiceUUID(hid->hidService()->getUUID());\n  advertising->setScanResponse(false);\n  advertising->start();\n  hid->setBatteryLevel(batteryLevel);\n\n  ESP_LOGD(LOG_TAG, \"Advertising started!\");\n}\n\nvoid BleKeyboard::end(void)\n{\n}\n\nbool BleKeyboard::isConnected(void) {\n  return this->connected;\n}\n\nvoid BleKeyboard::setBatteryLevel(uint8_t level) {\n  this->batteryLevel = level;\n  if (hid != 0)\n    this->hid->setBatteryLevel(this->batteryLevel);\n}\n\n//must be called before begin in order to set the name\nvoid BleKeyboard::setName(std::string deviceName) {\n  this->deviceName = deviceName;\n}\n\n/**\n * @brief Sets the waiting time (in milliseconds) between multiple keystrokes in NimBLE mode.\n * \n * @param ms Time in milliseconds\n */\nvoid BleKeyboard::setDelay(uint32_t ms) {\n  this->_delay_ms = ms;\n}\n\nvoid BleKeyboard::set_vendor_id(uint16_t vid) { \n\tthis->vid = vid; \n}\n\nvoid BleKeyboard::set_product_id(uint16_t pid) { \n\tthis->pid = pid; \n}\n\nvoid BleKeyboard::set_version(uint16_t version) { \n\tthis->version = version; \n}\n\nvoid BleKeyboard::sendReport(KeyReport* keys)\n{\n  if (this->isConnected())\n  {\n    this->inputKeyboard->setValue((uint8_t*)keys, sizeof(KeyReport));\n    this->inputKeyboard->notify();\n#if defined(USE_NIMBLE)        \n    // vTaskDelay(delayTicks);\n    this->delay_ms(_delay_ms);\n#endif // USE_NIMBLE\n  }\t\n}\n\nvoid BleKeyboard::sendReport(MediaKeyReport* keys)\n{\n  if (this->isConnected())\n  {\n    this->inputMediaKeys->setValue((uint8_t*)keys, sizeof(MediaKeyReport));\n    this->inputMediaKeys->notify();\n#if defined(USE_NIMBLE)        \n    //vTaskDelay(delayTicks);\n    this->delay_ms(_delay_ms);\n#endif // USE_NIMBLE\n  }\t\n}\n\nextern\nconst uint8_t _asciimap[128] PROGMEM;\n\n#define SHIFT 0x80\nconst uint8_t _asciimap[128] =\n{\n\t0x00,             // NUL\n\t0x00,             // SOH\n\t0x00,             // STX\n\t0x00,             // ETX\n\t0x00,             // EOT\n\t0x00,             // ENQ\n\t0x00,             // ACK\n\t0x00,             // BEL\n\t0x2a,\t\t\t// BS\tBackspace\n\t0x2b,\t\t\t// TAB\tTab\n\t0x28,\t\t\t// LF\tEnter\n\t0x00,             // VT\n\t0x00,             // FF\n\t0x00,             // CR\n\t0x00,             // SO\n\t0x00,             // SI\n\t0x00,             // DEL\n\t0x00,             // DC1\n\t0x00,             // DC2\n\t0x00,             // DC3\n\t0x00,             // DC4\n\t0x00,             // NAK\n\t0x00,             // SYN\n\t0x00,             // ETB\n\t0x00,             // CAN\n\t0x00,             // EM\n\t0x00,             // SUB\n\t0x00,             // ESC\n\t0x00,             // FS\n\t0x00,             // GS\n\t0x00,             // RS\n\t0x00,             // US\n\n\t0x2c,\t\t   //  ' '\n\t0x1e|SHIFT,\t   // !\n\t0x34|SHIFT,\t   // \"\n\t0x20|SHIFT,    // #\n\t0x21|SHIFT,    // $\n\t0x22|SHIFT,    // %\n\t0x24|SHIFT,    // &\n\t0x34,          // '\n\t0x26|SHIFT,    // (\n\t0x27|SHIFT,    // )\n\t0x25|SHIFT,    // *\n\t0x2e|SHIFT,    // +\n\t0x36,          // ,\n\t0x2d,          // -\n\t0x37,          // .\n\t0x38,          // /\n\t0x27,          // 0\n\t0x1e,          // 1\n\t0x1f,          // 2\n\t0x20,          // 3\n\t0x21,          // 4\n\t0x22,          // 5\n\t0x23,          // 6\n\t0x24,          // 7\n\t0x25,          // 8\n\t0x26,          // 9\n\t0x33|SHIFT,      // :\n\t0x33,          // ;\n\t0x36|SHIFT,      // <\n\t0x2e,          // =\n\t0x37|SHIFT,      // >\n\t0x38|SHIFT,      // ?\n\t0x1f|SHIFT,      // @\n\t0x04|SHIFT,      // A\n\t0x05|SHIFT,      // B\n\t0x06|SHIFT,      // C\n\t0x07|SHIFT,      // D\n\t0x08|SHIFT,      // E\n\t0x09|SHIFT,      // F\n\t0x0a|SHIFT,      // G\n\t0x0b|SHIFT,      // H\n\t0x0c|SHIFT,      // I\n\t0x0d|SHIFT,      // J\n\t0x0e|SHIFT,      // K\n\t0x0f|SHIFT,      // L\n\t0x10|SHIFT,      // M\n\t0x11|SHIFT,      // N\n\t0x12|SHIFT,      // O\n\t0x13|SHIFT,      // P\n\t0x14|SHIFT,      // Q\n\t0x15|SHIFT,      // R\n\t0x16|SHIFT,      // S\n\t0x17|SHIFT,      // T\n\t0x18|SHIFT,      // U\n\t0x19|SHIFT,      // V\n\t0x1a|SHIFT,      // W\n\t0x1b|SHIFT,      // X\n\t0x1c|SHIFT,      // Y\n\t0x1d|SHIFT,      // Z\n\t0x2f,          // [\n\t0x31,          // bslash\n\t0x30,          // ]\n\t0x23|SHIFT,    // ^\n\t0x2d|SHIFT,    // _\n\t0x35,          // `\n\t0x04,          // a\n\t0x05,          // b\n\t0x06,          // c\n\t0x07,          // d\n\t0x08,          // e\n\t0x09,          // f\n\t0x0a,          // g\n\t0x0b,          // h\n\t0x0c,          // i\n\t0x0d,          // j\n\t0x0e,          // k\n\t0x0f,          // l\n\t0x10,          // m\n\t0x11,          // n\n\t0x12,          // o\n\t0x13,          // p\n\t0x14,          // q\n\t0x15,          // r\n\t0x16,          // s\n\t0x17,          // t\n\t0x18,          // u\n\t0x19,          // v\n\t0x1a,          // w\n\t0x1b,          // x\n\t0x1c,          // y\n\t0x1d,          // z\n\t0x2f|SHIFT,    // {\n\t0x31|SHIFT,    // |\n\t0x30|SHIFT,    // }\n\t0x35|SHIFT,    // ~\n\t0\t\t\t\t// DEL\n};\n\n\nuint8_t USBPutChar(uint8_t c);\n\n// press() adds the specified key (printing, non-printing, or modifier)\n// to the persistent key report and sends the report.  Because of the way\n// USB HID works, the host acts like the key remains pressed until we\n// call release(), releaseAll(), or otherwise clear the report and resend.\nsize_t BleKeyboard::press(uint8_t k)\n{\n\tuint8_t i;\n\tif (k >= 136) {\t\t\t// it's a non-printing key (not a modifier)\n\t\tk = k - 136;\n\t} else if (k >= 128) {\t// it's a modifier key\n\t\t_keyReport.modifiers |= (1<<(k-128));\n\t\tk = 0;\n\t} else {\t\t\t\t// it's a printing key\n\t\tk = pgm_read_byte(_asciimap + k);\n\t\tif (!k) {\n\t\t\tsetWriteError();\n\t\t\treturn 0;\n\t\t}\n\t\tif (k & 0x80) {\t\t\t\t\t\t// it's a capital letter or other character reached with shift\n\t\t\t_keyReport.modifiers |= 0x02;\t// the left shift modifier\n\t\t\tk &= 0x7F;\n\t\t}\n\t}\n\n\t// Add k to the key report only if it's not already present\n\t// and if there is an empty slot.\n\tif (_keyReport.keys[0] != k && _keyReport.keys[1] != k &&\n\t\t_keyReport.keys[2] != k && _keyReport.keys[3] != k &&\n\t\t_keyReport.keys[4] != k && _keyReport.keys[5] != k) {\n\n\t\tfor (i=0; i<6; i++) {\n\t\t\tif (_keyReport.keys[i] == 0x00) {\n\t\t\t\t_keyReport.keys[i] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 6) {\n\t\t\tsetWriteError();\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsendReport(&_keyReport);\n\treturn 1;\n}\n\nsize_t BleKeyboard::press(const MediaKeyReport k)\n{\n    uint16_t k_16 = k[1] | (k[0] << 8);\n    uint16_t mediaKeyReport_16 = _mediaKeyReport[1] | (_mediaKeyReport[0] << 8);\n\n    mediaKeyReport_16 |= k_16;\n    _mediaKeyReport[0] = (uint8_t)((mediaKeyReport_16 & 0xFF00) >> 8);\n    _mediaKeyReport[1] = (uint8_t)(mediaKeyReport_16 & 0x00FF);\n\n\tsendReport(&_mediaKeyReport);\n\treturn 1;\n}\n\n// release() takes the specified key out of the persistent key report and\n// sends the report.  This tells the OS the key is no longer pressed and that\n// it shouldn't be repeated any more.\nsize_t BleKeyboard::release(uint8_t k)\n{\n\tuint8_t i;\n\tif (k >= 136) {\t\t\t// it's a non-printing key (not a modifier)\n\t\tk = k - 136;\n\t} else if (k >= 128) {\t// it's a modifier key\n\t\t_keyReport.modifiers &= ~(1<<(k-128));\n\t\tk = 0;\n\t} else {\t\t\t\t// it's a printing key\n\t\tk = pgm_read_byte(_asciimap + k);\n\t\tif (!k) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (k & 0x80) {\t\t\t\t\t\t\t// it's a capital letter or other character reached with shift\n\t\t\t_keyReport.modifiers &= ~(0x02);\t// the left shift modifier\n\t\t\tk &= 0x7F;\n\t\t}\n\t}\n\n\t// Test the key report to see if k is present.  Clear it if it exists.\n\t// Check all positions in case the key is present more than once (which it shouldn't be)\n\tfor (i=0; i<6; i++) {\n\t\tif (0 != k && _keyReport.keys[i] == k) {\n\t\t\t_keyReport.keys[i] = 0x00;\n\t\t}\n\t}\n\n\tsendReport(&_keyReport);\n\treturn 1;\n}\n\nsize_t BleKeyboard::release(const MediaKeyReport k)\n{\n    uint16_t k_16 = k[1] | (k[0] << 8);\n    uint16_t mediaKeyReport_16 = _mediaKeyReport[1] | (_mediaKeyReport[0] << 8);\n    mediaKeyReport_16 &= ~k_16;\n    _mediaKeyReport[0] = (uint8_t)((mediaKeyReport_16 & 0xFF00) >> 8);\n    _mediaKeyReport[1] = (uint8_t)(mediaKeyReport_16 & 0x00FF);\n\n\tsendReport(&_mediaKeyReport);\n\treturn 1;\n}\n\nvoid BleKeyboard::releaseAll(void)\n{\n\t_keyReport.keys[0] = 0;\n\t_keyReport.keys[1] = 0;\n\t_keyReport.keys[2] = 0;\n\t_keyReport.keys[3] = 0;\n\t_keyReport.keys[4] = 0;\n\t_keyReport.keys[5] = 0;\n\t_keyReport.modifiers = 0;\n    _mediaKeyReport[0] = 0;\n    _mediaKeyReport[1] = 0;\n\tsendReport(&_keyReport);\n\tsendReport(&_mediaKeyReport);\n}\n\nsize_t BleKeyboard::write(uint8_t c)\n{\n\tuint8_t p = press(c);  // Keydown\n\trelease(c);            // Keyup\n\treturn p;              // just return the result of press() since release() almost always returns 1\n}\n\nsize_t BleKeyboard::write(const MediaKeyReport c)\n{\n\tuint16_t p = press(c);  // Keydown\n\trelease(c);            // Keyup\n\treturn p;              // just return the result of press() since release() almost always returns 1\n}\n\nsize_t BleKeyboard::write(const uint8_t *buffer, size_t size) {\n\tsize_t n = 0;\n\twhile (size--) {\n\t\tif (*buffer != '\\r') {\n\t\t\tif (write(*buffer)) {\n\t\t\t  n++;\n\t\t\t} else {\n\t\t\t  break;\n\t\t\t}\n\t\t}\n\t\tbuffer++;\n\t}\n\treturn n;\n}\n\nvoid BleKeyboard::onConnect(BLEServer* pServer) {\n  this->connected = true;\n\n#if !defined(USE_NIMBLE)\n\n  BLE2902* desc = (BLE2902*)this->inputKeyboard->getDescriptorByUUID(BLEUUID((uint16_t)0x2902));\n  desc->setNotifications(true);\n  desc = (BLE2902*)this->inputMediaKeys->getDescriptorByUUID(BLEUUID((uint16_t)0x2902));\n  desc->setNotifications(true);\n\n#endif // !USE_NIMBLE\n\n}\n\nvoid BleKeyboard::onDisconnect(BLEServer* pServer) {\n  this->connected = false;\n\n#if !defined(USE_NIMBLE)\n\n  BLE2902* desc = (BLE2902*)this->inputKeyboard->getDescriptorByUUID(BLEUUID((uint16_t)0x2902));\n  desc->setNotifications(false);\n  desc = (BLE2902*)this->inputMediaKeys->getDescriptorByUUID(BLEUUID((uint16_t)0x2902));\n  desc->setNotifications(false);\n\n  advertising->start();\n\n#endif // !USE_NIMBLE\n}\n\nvoid BleKeyboard::onWrite(BLECharacteristic* me) {\n  uint8_t* value = (uint8_t*)(me->getValue().c_str());\n  (void)value;\n  ESP_LOGI(LOG_TAG, \"special keys: %d\", *value);\n}\n\nvoid BleKeyboard::delay_ms(uint64_t ms) {\n  uint64_t m = esp_timer_get_time();\n  if(ms){\n    uint64_t e = (m + (ms * 1000));\n    if(m > e){ //overflow\n        while(esp_timer_get_time() > e) { }\n    }\n    while(esp_timer_get_time() < e) {}\n  }\n}\n"
        },
        {
          "name": "BleKeyboard.h",
          "type": "blob",
          "size": 5.7080078125,
          "content": "// uncomment the following line to use NimBLE library\n//#define USE_NIMBLE\n\n#ifndef ESP32_BLE_KEYBOARD_H\n#define ESP32_BLE_KEYBOARD_H\n#include \"sdkconfig.h\"\n#if defined(CONFIG_BT_ENABLED)\n\n#if defined(USE_NIMBLE)\n\n#include \"NimBLECharacteristic.h\"\n#include \"NimBLEHIDDevice.h\"\n\n#define BLEDevice                  NimBLEDevice\n#define BLEServerCallbacks         NimBLEServerCallbacks\n#define BLECharacteristicCallbacks NimBLECharacteristicCallbacks\n#define BLEHIDDevice               NimBLEHIDDevice\n#define BLECharacteristic          NimBLECharacteristic\n#define BLEAdvertising             NimBLEAdvertising\n#define BLEServer                  NimBLEServer\n\n#else\n\n#include \"BLEHIDDevice.h\"\n#include \"BLECharacteristic.h\"\n\n#endif // USE_NIMBLE\n\n#include \"Print.h\"\n\n#define BLE_KEYBOARD_VERSION \"0.0.4\"\n#define BLE_KEYBOARD_VERSION_MAJOR 0\n#define BLE_KEYBOARD_VERSION_MINOR 0\n#define BLE_KEYBOARD_VERSION_REVISION 4\n\nconst uint8_t KEY_LEFT_CTRL = 0x80;\nconst uint8_t KEY_LEFT_SHIFT = 0x81;\nconst uint8_t KEY_LEFT_ALT = 0x82;\nconst uint8_t KEY_LEFT_GUI = 0x83;\nconst uint8_t KEY_RIGHT_CTRL = 0x84;\nconst uint8_t KEY_RIGHT_SHIFT = 0x85;\nconst uint8_t KEY_RIGHT_ALT = 0x86;\nconst uint8_t KEY_RIGHT_GUI = 0x87;\n\nconst uint8_t KEY_UP_ARROW = 0xDA;\nconst uint8_t KEY_DOWN_ARROW = 0xD9;\nconst uint8_t KEY_LEFT_ARROW = 0xD8;\nconst uint8_t KEY_RIGHT_ARROW = 0xD7;\nconst uint8_t KEY_BACKSPACE = 0xB2;\nconst uint8_t KEY_TAB = 0xB3;\nconst uint8_t KEY_RETURN = 0xB0;\nconst uint8_t KEY_ESC = 0xB1;\nconst uint8_t KEY_INSERT = 0xD1;\nconst uint8_t KEY_PRTSC = 0xCE;\nconst uint8_t KEY_DELETE = 0xD4;\nconst uint8_t KEY_PAGE_UP = 0xD3;\nconst uint8_t KEY_PAGE_DOWN = 0xD6;\nconst uint8_t KEY_HOME = 0xD2;\nconst uint8_t KEY_END = 0xD5;\nconst uint8_t KEY_CAPS_LOCK = 0xC1;\nconst uint8_t KEY_F1 = 0xC2;\nconst uint8_t KEY_F2 = 0xC3;\nconst uint8_t KEY_F3 = 0xC4;\nconst uint8_t KEY_F4 = 0xC5;\nconst uint8_t KEY_F5 = 0xC6;\nconst uint8_t KEY_F6 = 0xC7;\nconst uint8_t KEY_F7 = 0xC8;\nconst uint8_t KEY_F8 = 0xC9;\nconst uint8_t KEY_F9 = 0xCA;\nconst uint8_t KEY_F10 = 0xCB;\nconst uint8_t KEY_F11 = 0xCC;\nconst uint8_t KEY_F12 = 0xCD;\nconst uint8_t KEY_F13 = 0xF0;\nconst uint8_t KEY_F14 = 0xF1;\nconst uint8_t KEY_F15 = 0xF2;\nconst uint8_t KEY_F16 = 0xF3;\nconst uint8_t KEY_F17 = 0xF4;\nconst uint8_t KEY_F18 = 0xF5;\nconst uint8_t KEY_F19 = 0xF6;\nconst uint8_t KEY_F20 = 0xF7;\nconst uint8_t KEY_F21 = 0xF8;\nconst uint8_t KEY_F22 = 0xF9;\nconst uint8_t KEY_F23 = 0xFA;\nconst uint8_t KEY_F24 = 0xFB;\n\nconst uint8_t KEY_NUM_0 = 0xEA;\nconst uint8_t KEY_NUM_1 = 0xE1;\nconst uint8_t KEY_NUM_2 = 0xE2;\nconst uint8_t KEY_NUM_3 = 0xE3;\nconst uint8_t KEY_NUM_4 = 0xE4;\nconst uint8_t KEY_NUM_5 = 0xE5;\nconst uint8_t KEY_NUM_6 = 0xE6;\nconst uint8_t KEY_NUM_7 = 0xE7;\nconst uint8_t KEY_NUM_8 = 0xE8;\nconst uint8_t KEY_NUM_9 = 0xE9;\nconst uint8_t KEY_NUM_SLASH = 0xDC;\nconst uint8_t KEY_NUM_ASTERISK = 0xDD;\nconst uint8_t KEY_NUM_MINUS = 0xDE;\nconst uint8_t KEY_NUM_PLUS = 0xDF;\nconst uint8_t KEY_NUM_ENTER = 0xE0;\nconst uint8_t KEY_NUM_PERIOD = 0xEB;\n\ntypedef uint8_t MediaKeyReport[2];\n\nconst MediaKeyReport KEY_MEDIA_NEXT_TRACK = {1, 0};\nconst MediaKeyReport KEY_MEDIA_PREVIOUS_TRACK = {2, 0};\nconst MediaKeyReport KEY_MEDIA_STOP = {4, 0};\nconst MediaKeyReport KEY_MEDIA_PLAY_PAUSE = {8, 0};\nconst MediaKeyReport KEY_MEDIA_MUTE = {16, 0};\nconst MediaKeyReport KEY_MEDIA_VOLUME_UP = {32, 0};\nconst MediaKeyReport KEY_MEDIA_VOLUME_DOWN = {64, 0};\nconst MediaKeyReport KEY_MEDIA_WWW_HOME = {128, 0};\nconst MediaKeyReport KEY_MEDIA_LOCAL_MACHINE_BROWSER = {0, 1}; // Opens \"My Computer\" on Windows\nconst MediaKeyReport KEY_MEDIA_CALCULATOR = {0, 2};\nconst MediaKeyReport KEY_MEDIA_WWW_BOOKMARKS = {0, 4};\nconst MediaKeyReport KEY_MEDIA_WWW_SEARCH = {0, 8};\nconst MediaKeyReport KEY_MEDIA_WWW_STOP = {0, 16};\nconst MediaKeyReport KEY_MEDIA_WWW_BACK = {0, 32};\nconst MediaKeyReport KEY_MEDIA_CONSUMER_CONTROL_CONFIGURATION = {0, 64}; // Media Selection\nconst MediaKeyReport KEY_MEDIA_EMAIL_READER = {0, 128};\n\n\n//  Low level key report: up to 6 keys and shift, ctrl etc at once\ntypedef struct\n{\n  uint8_t modifiers;\n  uint8_t reserved;\n  uint8_t keys[6];\n} KeyReport;\n\nclass BleKeyboard : public Print, public BLEServerCallbacks, public BLECharacteristicCallbacks\n{\nprivate:\n  BLEHIDDevice* hid;\n  BLECharacteristic* inputKeyboard;\n  BLECharacteristic* outputKeyboard;\n  BLECharacteristic* inputMediaKeys;\n  BLEAdvertising*    advertising;\n  KeyReport          _keyReport;\n  MediaKeyReport     _mediaKeyReport;\n  std::string        deviceName;\n  std::string        deviceManufacturer;\n  uint8_t            batteryLevel;\n  bool               connected = false;\n  uint32_t           _delay_ms = 7;\n  void delay_ms(uint64_t ms);\n\n  uint16_t vid       = 0x05ac;\n  uint16_t pid       = 0x820a;\n  uint16_t version   = 0x0210;\n\npublic:\n  BleKeyboard(std::string deviceName = \"ESP32 Keyboard\", std::string deviceManufacturer = \"Espressif\", uint8_t batteryLevel = 100);\n  void begin(void);\n  void end(void);\n  void sendReport(KeyReport* keys);\n  void sendReport(MediaKeyReport* keys);\n  size_t press(uint8_t k);\n  size_t press(const MediaKeyReport k);\n  size_t release(uint8_t k);\n  size_t release(const MediaKeyReport k);\n  size_t write(uint8_t c);\n  size_t write(const MediaKeyReport c);\n  size_t write(const uint8_t *buffer, size_t size);\n  void releaseAll(void);\n  bool isConnected(void);\n  void setBatteryLevel(uint8_t level);\n  void setName(std::string deviceName);  \n  void setDelay(uint32_t ms);\n\n  void set_vendor_id(uint16_t vid);\n  void set_product_id(uint16_t pid);\n  void set_version(uint16_t version);\nprotected:\n  virtual void onStarted(BLEServer *pServer) { };\n  virtual void onConnect(BLEServer* pServer) override;\n  virtual void onDisconnect(BLEServer* pServer) override;\n  virtual void onWrite(BLECharacteristic* me) override;\n\n};\n\n#endif // CONFIG_BT_ENABLED\n#endif // ESP32_BLE_KEYBOARD_H\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.810546875,
          "content": "# ESP32 BLE Keyboard library\n\nThis library allows you to make the ESP32 act as a Bluetooth Keyboard and control what it does.  \nYou might also be interested in:\n- [ESP32-BLE-Mouse](https://github.com/T-vK/ESP32-BLE-Mouse)\n- [ESP32-BLE-Gamepad](https://github.com/lemmingDev/ESP32-BLE-Gamepad)\n\n\n## Features\n\n - [x] Send key strokes\n - [x] Send text\n - [x] Press/release individual keys\n - [x] Media keys are supported\n - [ ] Read Numlock/Capslock/Scrolllock state\n - [x] Set battery level (basically works, but doesn't show up in Android's status bar)\n - [x] Compatible with Android\n - [x] Compatible with Windows\n - [x] Compatible with Linux\n - [x] Compatible with MacOS X (not stable, some people have issues, doesn't work with old devices)\n - [x] Compatible with iOS (not stable, some people have issues, doesn't work with old devices)\n\n## Installation\n- (Make sure you can use the ESP32 with the Arduino IDE. [Instructions can be found here.](https://github.com/espressif/arduino-esp32#installation-instructions))\n- [Download the latest release of this library from the release page.](https://github.com/T-vK/ESP32-BLE-Keyboard/releases)\n- In the Arduino IDE go to \"Sketch\" -> \"Include Library\" -> \"Add .ZIP Library...\" and select the file you just downloaded.\n- You can now go to \"File\" -> \"Examples\" -> \"ESP32 BLE Keyboard\" and select any of the examples to get started.\n\n## Example\n\n``` C++\n/**\n * This example turns the ESP32 into a Bluetooth LE keyboard that writes the words, presses Enter, presses a media key and then Ctrl+Alt+Delete\n */\n#include <BleKeyboard.h>\n\nBleKeyboard bleKeyboard;\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"Starting BLE work!\");\n  bleKeyboard.begin();\n}\n\nvoid loop() {\n  if(bleKeyboard.isConnected()) {\n    Serial.println(\"Sending 'Hello world'...\");\n    bleKeyboard.print(\"Hello world\");\n\n    delay(1000);\n\n    Serial.println(\"Sending Enter key...\");\n    bleKeyboard.write(KEY_RETURN);\n\n    delay(1000);\n\n    Serial.println(\"Sending Play/Pause media key...\");\n    bleKeyboard.write(KEY_MEDIA_PLAY_PAUSE);\n\n    delay(1000);\n    \n   //\n   // Below is an example of pressing multiple keyboard modifiers \n   // which by default is commented out. \n   // \n   /* Serial.println(\"Sending Ctrl+Alt+Delete...\");\n    bleKeyboard.press(KEY_LEFT_CTRL);\n    bleKeyboard.press(KEY_LEFT_ALT);\n    bleKeyboard.press(KEY_DELETE);\n    delay(100);\n    bleKeyboard.releaseAll();\n    */\n\n  }\n  Serial.println(\"Waiting 5 seconds...\");\n  delay(5000);\n}\n```\n\n## API docs\nThe BleKeyboard interface is almost identical to the Keyboard Interface, so you can use documentation right here:\nhttps://www.arduino.cc/reference/en/language/functions/usb/keyboard/\n\nJust remember that you have to use `bleKeyboard` instead of just `Keyboard` and you need these two lines at the top of your script:\n```\n#include <BleKeyboard.h>\nBleKeyboard bleKeyboard;\n```\n\nIn addition to that you can send media keys (which is not possible with the USB keyboard library). Supported are the following:\n- KEY_MEDIA_NEXT_TRACK\n- KEY_MEDIA_PREVIOUS_TRACK\n- KEY_MEDIA_STOP\n- KEY_MEDIA_PLAY_PAUSE\n- KEY_MEDIA_MUTE\n- KEY_MEDIA_VOLUME_UP\n- KEY_MEDIA_VOLUME_DOWN\n- KEY_MEDIA_WWW_HOME\n- KEY_MEDIA_LOCAL_MACHINE_BROWSER // Opens \"My Computer\" on Windows\n- KEY_MEDIA_CALCULATOR\n- KEY_MEDIA_WWW_BOOKMARKS\n- KEY_MEDIA_WWW_SEARCH\n- KEY_MEDIA_WWW_STOP\n- KEY_MEDIA_WWW_BACK\n- KEY_MEDIA_CONSUMER_CONTROL_CONFIGURATION // Media Selection\n- KEY_MEDIA_EMAIL_READER\n\nThere is also Bluetooth specific information that you can set (optional):\nInstead of `BleKeyboard bleKeyboard;` you can do `BleKeyboard bleKeyboard(\"Bluetooth Device Name\", \"Bluetooth Device Manufacturer\", 100);`. (Max lenght is 15 characters, anything beyond that will be truncated.)  \nThe third parameter is the initial battery level of your device. To adjust the battery level later on you can simply call e.g.  `bleKeyboard.setBatteryLevel(50)` (set battery level to 50%).  \nBy default the battery level will be set to 100%, the device name will be `ESP32 Bluetooth Keyboard` and the manufacturer will be `Espressif`.  \nThere is also a `setDelay` method to set a delay between each key event. E.g. `bleKeyboard.setDelay(10)` (10 milliseconds). The default is `8`.  \nThis feature is meant to compensate for some applications and devices that can't handle fast input and will skip letters if too many keys are sent in a small time frame.  \n\n## NimBLE-Mode\nThe NimBLE mode enables a significant saving of RAM and FLASH memory.\n\n### Comparison (SendKeyStrokes.ino at compile-time)\n\n**Standard**\n```\nRAM:   [=         ]   9.3% (used 30548 bytes from 327680 bytes)\nFlash: [========  ]  75.8% (used 994120 bytes from 1310720 bytes)\n```\n\n**NimBLE mode**\n```\nRAM:   [=         ]   8.3% (used 27180 bytes from 327680 bytes)\nFlash: [====      ]  44.2% (used 579158 bytes from 1310720 bytes)\n```\n\n### Comparison (SendKeyStrokes.ino at run-time)\n\n|   | Standard | NimBLE mode | difference\n|---|--:|--:|--:|\n| `ESP.getHeapSize()`   | 296.804 | 321.252 | **+ 24.448**  |\n| `ESP.getFreeHeap()`   | 143.572 | 260.764 | **+ 117.192** |\n| `ESP.getSketchSize()` | 994.224 | 579.264 | **- 414.960** |\n\n## How to activate NimBLE mode?\n\n### ArduinoIDE: \nUncomment the first line in BleKeyboard.h\n```C++\n#define USE_NIMBLE\n```\n\n### PlatformIO:\nChange your `platformio.ini` to the following settings\n```ini\nlib_deps = \n  NimBLE-Arduino\n\nbuild_flags = \n  -D USE_NIMBLE\n```\n\n## Credits\n\nCredits to [chegewara](https://github.com/chegewara) and [the authors of the USB keyboard library](https://github.com/arduino-libraries/Keyboard/) as this project is heavily based on their work!  \nAlso, credits to [duke2421](https://github.com/T-vK/ESP32-BLE-Keyboard/issues/1) who helped a lot with testing, debugging and fixing the device descriptor!\nAnd credits to [sivar2311](https://github.com/sivar2311) for adding NimBLE support, greatly reducing the memory footprint, fixing advertising issues and for adding the `setDelay` method.\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "keywords.txt",
          "type": "blob",
          "size": 0.5224609375,
          "content": "#######################################\n# Syntax Coloring Map For ESP32 BLE Keyboard\n#######################################\n# Class\n#######################################\n\nBleKeyboard\tKEYWORD1\n\n#######################################\n# Methods and Functions\n#######################################\n\nbegin\tKEYWORD2\nend\tKEYWORD2\nwrite\tKEYWORD2\npress\tKEYWORD2\nrelease\tKEYWORD2\nreleaseAll\tKEYWORD2\nsetBatteryLevel\tKEYWORD2\nisConnected\tKEYWORD2\n\n#######################################\n# Constants\n#######################################\n"
        },
        {
          "name": "library.properties",
          "type": "blob",
          "size": 0.2587890625,
          "content": "name=ESP32 BLE Keyboard\nversion=0.3.2\nauthor=T-vK\nmaintainer=T-vK\nsentence=Bluetooth LE Keyboard library for the ESP32.\nparagraph=Bluetooth LE Keyboard library for the ESP32.\ncategory=Communication\nurl=https://github.com/T-vK/ESP32-BLE-Keyboard\narchitectures=esp32\n"
        }
      ]
    }
  ]
}