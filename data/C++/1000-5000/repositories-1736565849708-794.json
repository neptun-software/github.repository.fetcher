{
  "metadata": {
    "timestamp": 1736565849708,
    "page": 794,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lvandeve/lodepng",
      "stars": 2134,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.865234375,
          "content": "Copyright (c) 2005-2018 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n    \n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.1083984375,
          "content": "# This makefile only makes the unit test, benchmark and pngdetail and showpng\n# utilities. It does not make the PNG codec itself as shared or static library.\n# That is because:\n# LodePNG itself has only 1 source file (lodepng.cpp, can be renamed to\n# lodepng.c) and is intended to be included as source file in other projects and\n# their build system directly.\n\n\nCC ?= gcc\nCXX ?= g++\n\noverride CFLAGS := -W -Wall -Wextra -ansi -pedantic -O3 -Wno-unused-function $(CFLAGS)\noverride CXXFLAGS := -W -Wall -Wextra -ansi -pedantic -O3 $(CXXFLAGS)\n\nall: unittest benchmark pngdetail showpng\n\n%.o: %.cpp\n\t@mkdir -p `dirname $@`\n\t$(CXX) -I ./ $(CXXFLAGS) -c $< -o $@\n\nunittest: lodepng.o lodepng_util.o lodepng_unittest.o\n\t$(CXX) $^ $(CXXFLAGS) -o $@\n\nbenchmark: lodepng.o lodepng_benchmark.o\n\t$(CXX) $^ $(CXXFLAGS) -lSDL2 -o $@\n\npngdetail: lodepng.o lodepng_util.o pngdetail.o\n\t$(CXX) $^ $(CXXFLAGS) -o $@\n\nshowpng: lodepng.o examples/example_sdl.o\n\t$(CXX) -I ./ $^ $(CXXFLAGS) -lSDL2 -o $@\n\nclean:\n\trm -f unittest benchmark pngdetail showpng lodepng_unittest.o lodepng_benchmark.o lodepng.o lodepng_util.o pngdetail.o examples/example_sdl.o\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.185546875,
          "content": "LodePNG\n-------\n\nPNG encoder and decoder in C and C++, without dependencies\n\nHome page: http://lodev.org/lodepng/\n\n### Documentation\n\nDetailed documentation is included in a large comment in the second half of the\nheader file `lodepng.h`.\n\nSource code examples using LodePNG can be found in the examples directory.\n\nAn FAQ can be found on http://lodev.org/lodepng/\n\n### Building\n\nOnly two files are needed to encode and decode PNGs:\n\n* `lodepng.cpp` (or renamed to `lodepng.c`)\n* `lodepng.h`\n\nAll other files are just source code examples, tests, misc utilities, etc...,\nwhich are normally not needed in projects using this.\n\nYou can include the files directly in your project's source tree and its\nmakefile, IDE project file, or other build system. No library is necessary.\n\nIn addition to C++, LodePNG also supports ANSI C (C89), with all the same\nfunctionality: C++ only adds extra convenience API.\n\nFor C, rename `lodepng.cpp` to `lodepng.c`.\n\nConsider using git submodules to include LodePNG in your project.\n\n### Compiling in C++\n\nIf you have a hypothetical `your_program.cpp` that #includes and uses `lodepng.h`,\nyou can build as follows:\n\n`g++ your_program.cpp lodepng.cpp -Wall -Wextra -pedantic -ansi -O3`\n\nor:\n\n`clang++ your_program.cpp lodepng.cpp -Wall -Wextra -pedantic -ansi -O3`\n\nThis shows compiler flags it was designed for, but normally one would use the\ncompiler or build system of their project instead of those commands, and other\nC++ compilers are supported.\n\n### Compiling in C\n\nRename `lodepng.cpp` to `lodepng.c` for this.\n\nIf you have a hypothetical your_program.c that #includes and uses lodepng.h,\nyou can build as follows:\n\n`gcc your_program.c lodepng.c -ansi -pedantic -Wall -Wextra -O3`\n\nor\n\n`clang your_program.c lodepng.c -ansi -pedantic -Wall -Wextra -O3`\n\nThis shows compiler flags it was designed for, but normally one would use the\ncompiler or build system of their project instead of those commands, and other\nC compilers are supported.\n\n### Makefile\n\nThere is a Makefile, but this is not intended for using LodePNG itself since the\nway to use that one is to include its source files in your program. The Makefile\nonly builds development and testing utilities. It can be used as follows:\n\n`make -j`\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "lodepng.cpp",
          "type": "blob",
          "size": 304.5634765625,
          "content": "/*\nLodePNG version 20241228\n\nCopyright (c) 2005-2024 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n/*\nThe manual and changelog are in the header file \"lodepng.h\"\nRename this file to lodepng.cpp to use it for C++, or to lodepng.c to use it for C.\n*/\n\n#include \"lodepng.h\"\n\n#ifdef LODEPNG_COMPILE_DISK\n#include <limits.h> /* LONG_MAX */\n#include <stdio.h> /* file handling */\n#endif /* LODEPNG_COMPILE_DISK */\n\n#ifdef LODEPNG_COMPILE_ALLOCATORS\n#include <stdlib.h> /* allocations */\n#endif /* LODEPNG_COMPILE_ALLOCATORS */\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1310) /*Visual Studio: A few warning types are not desired here.*/\n#pragma warning( disable : 4244 ) /*implicit conversions: not warned by gcc -Wall -Wextra and requires too much casts*/\n#pragma warning( disable : 4996 ) /*VS does not like fopen, but fopen_s is not standard C so unusable here*/\n#endif /*_MSC_VER */\n\nconst char* LODEPNG_VERSION_STRING = \"20241228\";\n\n/*\nThis source file is divided into the following large parts. The code sections\nwith the \"LODEPNG_COMPILE_\" #defines divide this up further in an intermixed way.\n-Tools for C and common code for PNG and Zlib\n-C Code for Zlib (huffman, deflate, ...)\n-C Code for PNG (file format chunks, adam7, PNG filters, color conversions, ...)\n-The C++ wrapper around all of the above\n*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // Tools for C, and common code for PNG and Zlib.                       // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*The malloc, realloc and free functions defined here with \"lodepng_\" in front\nof the name, so that you can easily change them to others related to your\nplatform if needed. Everything else in the code calls these. Pass\n-DLODEPNG_NO_COMPILE_ALLOCATORS to the compiler, or comment out\n#define LODEPNG_COMPILE_ALLOCATORS in the header, to disable the ones here and\ndefine them in your own project's source files without needing to change\nlodepng source code. Don't forget to remove \"static\" if you copypaste them\nfrom here.*/\n\n#ifdef LODEPNG_COMPILE_ALLOCATORS\nstatic void* lodepng_malloc(size_t size) {\n#ifdef LODEPNG_MAX_ALLOC\n  if(size > LODEPNG_MAX_ALLOC) return 0;\n#endif\n  return malloc(size);\n}\n\n/* NOTE: when realloc returns NULL, it leaves the original memory untouched */\nstatic void* lodepng_realloc(void* ptr, size_t new_size) {\n#ifdef LODEPNG_MAX_ALLOC\n  if(new_size > LODEPNG_MAX_ALLOC) return 0;\n#endif\n  return realloc(ptr, new_size);\n}\n\nstatic void lodepng_free(void* ptr) {\n  free(ptr);\n}\n#else /*LODEPNG_COMPILE_ALLOCATORS*/\n/* TODO: support giving additional void* payload to the custom allocators */\nvoid* lodepng_malloc(size_t size);\nvoid* lodepng_realloc(void* ptr, size_t new_size);\nvoid lodepng_free(void* ptr);\n#endif /*LODEPNG_COMPILE_ALLOCATORS*/\n\n/* convince the compiler to inline a function, for use when this measurably improves performance */\n/* inline is not available in C90, but use it when supported by the compiler */\n#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined(__cplusplus) && (__cplusplus >= 199711L))\n#define LODEPNG_INLINE inline\n#else\n#define LODEPNG_INLINE /* not available */\n#endif\n\n/* restrict is not available in C90, but use it when supported by the compiler */\n#if (defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))) ||\\\n    (defined(_MSC_VER) && (_MSC_VER >= 1400)) || \\\n    (defined(__WATCOMC__) && (__WATCOMC__ >= 1250) && !defined(__cplusplus))\n#define LODEPNG_RESTRICT __restrict\n#else\n#define LODEPNG_RESTRICT /* not available */\n#endif\n\n/* Replacements for C library functions such as memcpy and strlen, to support platforms\nwhere a full C library is not available. The compiler can recognize them and compile\nto something as fast. */\n\nstatic void lodepng_memcpy(void* LODEPNG_RESTRICT dst,\n                           const void* LODEPNG_RESTRICT src, size_t size) {\n  size_t i;\n  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];\n}\n\nstatic void lodepng_memset(void* LODEPNG_RESTRICT dst,\n                           int value, size_t num) {\n  size_t i;\n  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;\n}\n\n/* does not check memory out of bounds, do not use on untrusted data */\nstatic size_t lodepng_strlen(const char* a) {\n  const char* orig = a;\n  /* avoid warning about unused function in case of disabled COMPILE... macros */\n  (void)(&lodepng_strlen);\n  while(*a) a++;\n  return (size_t)(a - orig);\n}\n\n#define LODEPNG_MAX(a, b) (((a) > (b)) ? (a) : (b))\n#define LODEPNG_MIN(a, b) (((a) < (b)) ? (a) : (b))\n\n#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)\n/* Safely check if adding two integers will overflow (no undefined\nbehavior, compiler removing the code, etc...) and output result. */\nstatic int lodepng_addofl(size_t a, size_t b, size_t* result) {\n  *result = a + b; /* Unsigned addition is well defined and safe in C90 */\n  return *result < a;\n}\n#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n/* Safely check if multiplying two integers will overflow (no undefined\nbehavior, compiler removing the code, etc...) and output result. */\nstatic int lodepng_mulofl(size_t a, size_t b, size_t* result) {\n  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */\n  return (a != 0 && *result / a != b);\n}\n\n#ifdef LODEPNG_COMPILE_ZLIB\n/* Safely check if a + b > c, even if overflow could happen. */\nstatic int lodepng_gtofl(size_t a, size_t b, size_t c) {\n  size_t d;\n  if(lodepng_addofl(a, b, &d)) return 1;\n  return d > c;\n}\n#endif /*LODEPNG_COMPILE_ZLIB*/\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n\n/*\nOften in case of an error a value is assigned to a variable and then it breaks\nout of a loop (to go to the cleanup phase of a function). This macro does that.\nIt makes the error handling code shorter and more readable.\n\nExample: if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83);\n*/\n#define CERROR_BREAK(errorvar, code){\\\n  errorvar = code;\\\n  break;\\\n}\n\n/*version of CERROR_BREAK that assumes the common case where the error variable is named \"error\"*/\n#define ERROR_BREAK(code) CERROR_BREAK(error, code)\n\n/*Set error var to the error code, and return it.*/\n#define CERROR_RETURN_ERROR(errorvar, code){\\\n  errorvar = code;\\\n  return code;\\\n}\n\n/*Try the code, if it returns error, also return the error.*/\n#define CERROR_TRY_RETURN(call){\\\n  unsigned error = call;\\\n  if(error) return error;\\\n}\n\n/*Set error var to the error code, and return from the void function.*/\n#define CERROR_RETURN(errorvar, code){\\\n  errorvar = code;\\\n  return;\\\n}\n\n/*\nAbout uivector, ucvector and string:\n-All of them wrap dynamic arrays or text strings in a similar way.\n-LodePNG was originally written in C++. The vectors replace the std::vectors that were used in the C++ version.\n-The string tools are made to avoid problems with compilers that declare things like strncat as deprecated.\n-They're not used in the interface, only internally in this file as static functions.\n-As with many other structs in this file, the init and cleanup functions serve as ctor and dtor.\n*/\n\n#ifdef LODEPNG_COMPILE_ZLIB\n#ifdef LODEPNG_COMPILE_ENCODER\n/*dynamic vector of unsigned ints*/\ntypedef struct uivector {\n  unsigned* data;\n  size_t size; /*size in number of unsigned longs*/\n  size_t allocsize; /*allocated size in bytes*/\n} uivector;\n\nstatic void uivector_cleanup(void* p) {\n  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;\n  lodepng_free(((uivector*)p)->data);\n  ((uivector*)p)->data = NULL;\n}\n\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned uivector_resize(uivector* p, size_t size) {\n  size_t allocsize = size * sizeof(unsigned);\n  if(allocsize > p->allocsize) {\n    size_t newsize = allocsize + (p->allocsize >> 1u);\n    void* data = lodepng_realloc(p->data, newsize);\n    if(data) {\n      p->allocsize = newsize;\n      p->data = (unsigned*)data;\n    }\n    else return 0; /*error: not enough memory*/\n  }\n  p->size = size;\n  return 1; /*success*/\n}\n\nstatic void uivector_init(uivector* p) {\n  p->data = NULL;\n  p->size = p->allocsize = 0;\n}\n\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned uivector_push_back(uivector* p, unsigned c) {\n  if(!uivector_resize(p, p->size + 1)) return 0;\n  p->data[p->size - 1] = c;\n  return 1;\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n#endif /*LODEPNG_COMPILE_ZLIB*/\n\n/* /////////////////////////////////////////////////////////////////////////// */\n\n/*dynamic vector of unsigned chars*/\ntypedef struct ucvector {\n  unsigned char* data;\n  size_t size; /*used size*/\n  size_t allocsize; /*allocated size*/\n} ucvector;\n\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned ucvector_reserve(ucvector* p, size_t size) {\n  if(size > p->allocsize) {\n    size_t newsize = size + (p->allocsize >> 1u);\n    void* data = lodepng_realloc(p->data, newsize);\n    if(data) {\n      p->allocsize = newsize;\n      p->data = (unsigned char*)data;\n    }\n    else return 0; /*error: not enough memory*/\n  }\n  return 1; /*success*/\n}\n\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned ucvector_resize(ucvector* p, size_t size) {\n  p->size = size;\n  return ucvector_reserve(p, size);\n}\n\nstatic ucvector ucvector_init(unsigned char* buffer, size_t size) {\n  ucvector v;\n  v.data = buffer;\n  v.allocsize = v.size = size;\n  return v;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_PNG\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n\n/*free string pointer and set it to NULL*/\nstatic void string_cleanup(char** out) {\n  lodepng_free(*out);\n  *out = NULL;\n}\n\n/*also appends null termination character*/\nstatic char* alloc_string_sized(const char* in, size_t insize) {\n  char* out = (char*)lodepng_malloc(insize + 1);\n  if(out) {\n    lodepng_memcpy(out, in, insize);\n    out[insize] = 0;\n  }\n  return out;\n}\n\n/* dynamically allocates a new string with a copy of the null terminated input text */\nstatic char* alloc_string(const char* in) {\n  return alloc_string_sized(in, lodepng_strlen(in));\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n#endif /*LODEPNG_COMPILE_PNG*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)\nstatic unsigned lodepng_read32bitInt(const unsigned char* buffer) {\n  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |\n         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);\n}\n#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/\n\n#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)\n/*buffer must have at least 4 allocated bytes available*/\nstatic void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {\n  buffer[0] = (unsigned char)((value >> 24) & 0xff);\n  buffer[1] = (unsigned char)((value >> 16) & 0xff);\n  buffer[2] = (unsigned char)((value >>  8) & 0xff);\n  buffer[3] = (unsigned char)((value      ) & 0xff);\n}\n#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / File IO                                                                / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_DISK\n\n/* returns negative value on error. This should be pure C compatible, so no fstat. */\nstatic long lodepng_filesize(FILE* file) {\n  long size;\n  if(fseek(file, 0, SEEK_END) != 0) return -1;\n  size = ftell(file);\n  /* It may give LONG_MAX as directory size, this is invalid for us. */\n  if(size == LONG_MAX) return -1;\n  if(fseek(file, 0, SEEK_SET) != 0) return -1;\n  return size;\n}\n\n/* Allocates the output buffer to the file size and reads the file into it. Returns error code.*/\nstatic unsigned lodepng_load_file_(unsigned char** out, size_t* outsize, FILE* file) {\n  long size = lodepng_filesize(file);\n  if(size < 0) return 78;\n  *outsize = (size_t)size;\n  *out = (unsigned char*)lodepng_malloc((size_t)size);\n  if(!(*out) && size > 0) return 83; /*the above malloc failed*/\n  if(fread(*out, 1, *outsize, file) != *outsize) return 78;\n  return 0; /*ok*/\n}\n\nunsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {\n  unsigned error;\n  FILE* file = fopen(filename, \"rb\");\n  if(!file) return 78;\n  error = lodepng_load_file_(out, outsize, file);\n  fclose(file);\n  return error;\n}\n\n/*write given buffer to the file, overwriting the file, it doesn't append to it.*/\nunsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {\n  FILE* file = fopen(filename, \"wb\" );\n  if(!file) return 79;\n  fwrite(buffer, 1, buffersize, file);\n  fclose(file);\n  return 0;\n}\n\n#endif /*LODEPNG_COMPILE_DISK*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // End of common code and tools. Begin of Zlib related code.            // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_ZLIB\n#ifdef LODEPNG_COMPILE_ENCODER\n\ntypedef struct {\n  ucvector* data;\n  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/\n} LodePNGBitWriter;\n\nstatic void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {\n  writer->data = data;\n  writer->bp = 0;\n}\n\n/*TODO: this ignores potential out of memory errors*/\n#define WRITEBIT(writer, bit){\\\n  /* append new byte */\\\n  if(((writer->bp) & 7u) == 0) {\\\n    if(!ucvector_resize(writer->data, writer->data->size + 1)) return;\\\n    writer->data->data[writer->data->size - 1] = 0;\\\n  }\\\n  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\\\n  ++writer->bp;\\\n}\n\n/* LSB of value is written first, and LSB of bytes is used first */\nstatic void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {\n  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */\n    WRITEBIT(writer, value);\n  } else {\n    /* TODO: increase output size only once here rather than in each WRITEBIT */\n    size_t i;\n    for(i = 0; i != nbits; ++i) {\n      WRITEBIT(writer, (unsigned char)((value >> i) & 1));\n    }\n  }\n}\n\n/* This one is to use for adding huffman symbol, the value bits are written MSB first */\nstatic void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {\n  size_t i;\n  for(i = 0; i != nbits; ++i) {\n    /* TODO: increase output size only once here rather than in each WRITEBIT */\n    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));\n  }\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n\ntypedef struct {\n  const unsigned char* data;\n  size_t size; /*size of data in bytes*/\n  size_t bitsize; /*size of data in bits, end of valid bp values, should be 8*size*/\n  size_t bp;\n  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/\n} LodePNGBitReader;\n\n/* data size argument is in bytes. Returns error if size too large causing overflow */\nstatic unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {\n  size_t temp;\n  reader->data = data;\n  reader->size = size;\n  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */\n  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;\n  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and\n  trying to ensure 32 more bits*/\n  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;\n  reader->bp = 0;\n  reader->buffer = 0;\n  return 0; /*ok*/\n}\n\n/*\nensureBits functions:\nEnsures the reader can at least read nbits bits in one or more readBits calls,\nsafely even if not enough bits are available.\nThe nbits parameter is unused but is given for documentation purposes, error\nchecking for amount of bits must be done beforehand.\n*/\n\n/*See ensureBits documentation above. This one ensures up to 9 bits */\nstatic LODEPNG_INLINE void ensureBits9(LodePNGBitReader* reader, size_t nbits) {\n  size_t start = reader->bp >> 3u;\n  size_t size = reader->size;\n  if(start + 1u < size) {\n    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);\n    reader->buffer >>= (reader->bp & 7u);\n  } else {\n    reader->buffer = 0;\n    if(start + 0u < size) reader->buffer = reader->data[start + 0];\n    reader->buffer >>= (reader->bp & 7u);\n  }\n  (void)nbits;\n}\n\n/*See ensureBits documentation above. This one ensures up to 17 bits */\nstatic LODEPNG_INLINE void ensureBits17(LodePNGBitReader* reader, size_t nbits) {\n  size_t start = reader->bp >> 3u;\n  size_t size = reader->size;\n  if(start + 2u < size) {\n    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |\n                     ((unsigned)reader->data[start + 2] << 16u);\n    reader->buffer >>= (reader->bp & 7u);\n  } else {\n    reader->buffer = 0;\n    if(start + 0u < size) reader->buffer |= reader->data[start + 0];\n    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);\n    reader->buffer >>= (reader->bp & 7u);\n  }\n  (void)nbits;\n}\n\n/*See ensureBits documentation above. This one ensures up to 25 bits */\nstatic LODEPNG_INLINE void ensureBits25(LodePNGBitReader* reader, size_t nbits) {\n  size_t start = reader->bp >> 3u;\n  size_t size = reader->size;\n  if(start + 3u < size) {\n    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |\n                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);\n    reader->buffer >>= (reader->bp & 7u);\n  } else {\n    reader->buffer = 0;\n    if(start + 0u < size) reader->buffer |= reader->data[start + 0];\n    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);\n    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);\n    reader->buffer >>= (reader->bp & 7u);\n  }\n  (void)nbits;\n}\n\n/*See ensureBits documentation above. This one ensures up to 32 bits */\nstatic LODEPNG_INLINE void ensureBits32(LodePNGBitReader* reader, size_t nbits) {\n  size_t start = reader->bp >> 3u;\n  size_t size = reader->size;\n  if(start + 4u < size) {\n    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |\n                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);\n    reader->buffer >>= (reader->bp & 7u);\n    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));\n  } else {\n    reader->buffer = 0;\n    if(start + 0u < size) reader->buffer |= reader->data[start + 0];\n    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);\n    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);\n    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);\n    reader->buffer >>= (reader->bp & 7u);\n  }\n  (void)nbits;\n}\n\n/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */\nstatic LODEPNG_INLINE unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {\n  /* The shift allows nbits to be only up to 31. */\n  return reader->buffer & ((1u << nbits) - 1u);\n}\n\n/* Must have enough bits available with ensureBits */\nstatic LODEPNG_INLINE void advanceBits(LodePNGBitReader* reader, size_t nbits) {\n  reader->buffer >>= nbits;\n  reader->bp += nbits;\n}\n\n/* Must have enough bits available with ensureBits */\nstatic LODEPNG_INLINE unsigned readBits(LodePNGBitReader* reader, size_t nbits) {\n  unsigned result = peekBits(reader, nbits);\n  advanceBits(reader, nbits);\n  return result;\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n\nstatic unsigned reverseBits(unsigned bits, unsigned num) {\n  /*TODO: implement faster lookup table based version when needed*/\n  unsigned i, result = 0;\n  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;\n  return result;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Deflate - Huffman                                                      / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#define FIRST_LENGTH_CODE_INDEX 257\n#define LAST_LENGTH_CODE_INDEX 285\n/*256 literals, the end code, some length codes, and 2 unused codes*/\n#define NUM_DEFLATE_CODE_SYMBOLS 288\n/*the distance codes have their own symbols, 30 used, 2 unused*/\n#define NUM_DISTANCE_SYMBOLS 32\n/*the code length codes. 0-15: code lengths, 16: copy previous 3-6 times, 17: 3-10 zeros, 18: 11-138 zeros*/\n#define NUM_CODE_LENGTH_CODES 19\n\n/*the base lengths represented by codes 257-285*/\nstatic const unsigned LENGTHBASE[29]\n  = {3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,\n     67, 83, 99, 115, 131, 163, 195, 227, 258};\n\n/*the extra bits used by codes 257-285 (added to base length)*/\nstatic const unsigned LENGTHEXTRA[29]\n  = {0, 0, 0, 0, 0, 0, 0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,\n      4,  4,  4,   4,   5,   5,   5,   5,   0};\n\n/*the base backwards distances (the bits of distance codes appear after length codes and use their own huffman tree)*/\nstatic const unsigned DISTANCEBASE[30]\n  = {1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,\n     769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};\n\n/*the extra bits of backwards distances (added to base)*/\nstatic const unsigned DISTANCEEXTRA[30]\n  = {0, 0, 0, 0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,   6,   6,   7,   7,   8,\n       8,    9,    9,   10,   10,   11,   11,   12,    12,    13,    13};\n\n/*the order in which \"code length alphabet code lengths\" are stored as specified by deflate, out of this the huffman\ntree of the dynamic huffman tree lengths is generated*/\nstatic const unsigned CLCL_ORDER[NUM_CODE_LENGTH_CODES]\n  = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*\nHuffman tree struct, containing multiple representations of the tree\n*/\ntypedef struct HuffmanTree {\n  unsigned* codes; /*the huffman codes (bit patterns representing the symbols)*/\n  unsigned* lengths; /*the lengths of the huffman codes*/\n  unsigned maxbitlen; /*maximum number of bits a single code can get*/\n  unsigned numcodes; /*number of symbols in the alphabet = number of codes*/\n  /* for reading only */\n  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/\n  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/\n} HuffmanTree;\n\nstatic void HuffmanTree_init(HuffmanTree* tree) {\n  tree->codes = 0;\n  tree->lengths = 0;\n  tree->table_len = 0;\n  tree->table_value = 0;\n}\n\nstatic void HuffmanTree_cleanup(HuffmanTree* tree) {\n  lodepng_free(tree->codes);\n  lodepng_free(tree->lengths);\n  lodepng_free(tree->table_len);\n  lodepng_free(tree->table_value);\n}\n\n/* amount of bits for first huffman table lookup (aka root bits), see HuffmanTree_makeTable and huffmanDecodeSymbol.*/\n/* values 8u and 9u work the fastest */\n#define FIRSTBITS 9u\n\n/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,\nwhich is possible in case of only 0 or 1 present symbols. */\n#define INVALIDSYMBOL 65535u\n\n/* make table for huffman decoding */\nstatic unsigned HuffmanTree_makeTable(HuffmanTree* tree) {\n  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/\n  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;\n  size_t i, numpresent, pointer, size; /*total table size*/\n  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));\n  if(!maxlens) return 83; /*alloc fail*/\n\n  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/\n  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));\n  for(i = 0; i < tree->numcodes; i++) {\n    unsigned symbol = tree->codes[i];\n    unsigned l = tree->lengths[i];\n    unsigned index;\n    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/\n    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/\n    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);\n    maxlens[index] = LODEPNG_MAX(maxlens[index], l);\n  }\n  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */\n  size = headsize;\n  for(i = 0; i < headsize; ++i) {\n    unsigned l = maxlens[i];\n    if(l > FIRSTBITS) size += (((size_t)1) << (l - FIRSTBITS));\n  }\n  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));\n  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));\n  if(!tree->table_len || !tree->table_value) {\n    lodepng_free(maxlens);\n    /* freeing tree->table values is done at a higher scope */\n    return 83; /*alloc fail*/\n  }\n  /*initialize with an invalid length to indicate unused entries*/\n  for(i = 0; i < size; ++i) tree->table_len[i] = 16;\n\n  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/\n  pointer = headsize;\n  for(i = 0; i < headsize; ++i) {\n    unsigned l = maxlens[i];\n    if(l <= FIRSTBITS) continue;\n    tree->table_len[i] = l;\n    tree->table_value[i] = (unsigned short)pointer;\n    pointer += (((size_t)1) << (l - FIRSTBITS));\n  }\n  lodepng_free(maxlens);\n\n  /*fill in the first table for short symbols, or secondary table for long symbols*/\n  numpresent = 0;\n  for(i = 0; i < tree->numcodes; ++i) {\n    unsigned l = tree->lengths[i];\n    unsigned symbol, reverse;\n    if(l == 0) continue;\n    symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/\n    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/\n    reverse = reverseBits(symbol, l);\n    numpresent++;\n\n    if(l <= FIRSTBITS) {\n      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/\n      unsigned num = 1u << (FIRSTBITS - l);\n      unsigned j;\n      for(j = 0; j < num; ++j) {\n        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/\n        unsigned index = reverse | (j << l);\n        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/\n        tree->table_len[index] = l;\n        tree->table_value[index] = (unsigned short)i;\n      }\n    } else {\n      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/\n      /*the FIRSTBITS MSBs of the symbol are the first table index*/\n      unsigned index = reverse & mask;\n      unsigned maxlen = tree->table_len[index];\n      /*log2 of secondary table length, should be >= l - FIRSTBITS*/\n      unsigned tablelen = maxlen - FIRSTBITS;\n      unsigned start = tree->table_value[index]; /*starting index in secondary table*/\n      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/\n      unsigned j;\n      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/\n      for(j = 0; j < num; ++j) {\n        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */\n        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));\n        tree->table_len[index2] = l;\n        tree->table_value[index2] = (unsigned short)i;\n      }\n    }\n  }\n\n  if(numpresent < 2) {\n    /* In case of exactly 1 symbol, in theory the huffman symbol needs 0 bits,\n    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can\n    appear at all, but such huffman tree could still exist (e.g. if distance\n    codes are never used). In both cases, not all symbols of the table will be\n    filled in. Fill them in with an invalid symbol value so returning them from\n    huffmanDecodeSymbol will cause error. */\n    for(i = 0; i < size; ++i) {\n      if(tree->table_len[i] == 16) {\n        /* As length, use a value smaller than FIRSTBITS for the head table,\n        and a value larger than FIRSTBITS for the secondary table, to ensure\n        valid behavior for advanceBits when reading this symbol. */\n        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);\n        tree->table_value[i] = INVALIDSYMBOL;\n      }\n    }\n  } else {\n    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.\n    If that is not the case (due to too long length codes), the table will not\n    have been fully used, and this is an error (not all bit combinations can be\n    decoded): an oversubscribed huffman tree, indicated by error 55. */\n    for(i = 0; i < size; ++i) {\n      if(tree->table_len[i] == 16) return 55;\n    }\n  }\n\n  return 0;\n}\n\n/*\nSecond step for the ...makeFromLengths and ...makeFromFrequencies functions.\nnumcodes, lengths and maxbitlen must already be filled in correctly. return\nvalue is error.\n*/\nstatic unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {\n  unsigned* blcount;\n  unsigned* nextcode;\n  unsigned error = 0;\n  unsigned bits, n;\n\n  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));\n  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));\n  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));\n  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/\n\n  if(!error) {\n    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;\n    /*step 1: count number of instances of each code length*/\n    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];\n    /*step 2: generate the nextcode values*/\n    for(bits = 1; bits <= tree->maxbitlen; ++bits) {\n      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;\n    }\n    /*step 3: generate all the codes*/\n    for(n = 0; n != tree->numcodes; ++n) {\n      if(tree->lengths[n] != 0) {\n        tree->codes[n] = nextcode[tree->lengths[n]]++;\n        /*remove superfluous bits from the code*/\n        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);\n      }\n    }\n  }\n\n  lodepng_free(blcount);\n  lodepng_free(nextcode);\n\n  if(!error) error = HuffmanTree_makeTable(tree);\n  return error;\n}\n\n/*\ngiven the code lengths (as stored in the PNG file), generate the tree as defined\nby Deflate. maxbitlen is the maximum bits that a code in the tree can have.\nreturn value is error.\n*/\nstatic unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,\n                                            size_t numcodes, unsigned maxbitlen) {\n  unsigned i;\n  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));\n  if(!tree->lengths) return 83; /*alloc fail*/\n  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  tree->maxbitlen = maxbitlen;\n  return HuffmanTree_makeFromLengths2(tree);\n}\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/*BPM: Boundary Package Merge, see \"A Fast and Space-Economical Algorithm for Length-Limited Coding\",\nJyrki Katajainen, Alistair Moffat, Andrew Turpin, 1995.*/\n\n/*chain node for boundary package merge*/\ntypedef struct BPMNode {\n  int weight; /*the sum of all weights in this chain*/\n  unsigned index; /*index of this leaf node (called \"count\" in the paper)*/\n  struct BPMNode* tail; /*the next nodes in this chain (null if last)*/\n  int in_use;\n} BPMNode;\n\n/*lists of chains*/\ntypedef struct BPMLists {\n  /*memory pool*/\n  unsigned memsize;\n  BPMNode* memory;\n  unsigned numfree;\n  unsigned nextfree;\n  BPMNode** freelist;\n  /*two heads of lookahead chains per list*/\n  unsigned listsize;\n  BPMNode** chains0;\n  BPMNode** chains1;\n} BPMLists;\n\n/*creates a new chain node with the given parameters, from the memory in the lists */\nstatic BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {\n  unsigned i;\n  BPMNode* result;\n\n  /*memory full, so garbage collect*/\n  if(lists->nextfree >= lists->numfree) {\n    /*mark only those that are in use*/\n    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;\n    for(i = 0; i != lists->listsize; ++i) {\n      BPMNode* node;\n      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;\n      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;\n    }\n    /*collect those that are free*/\n    lists->numfree = 0;\n    for(i = 0; i != lists->memsize; ++i) {\n      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];\n    }\n    lists->nextfree = 0;\n  }\n\n  result = lists->freelist[lists->nextfree++];\n  result->weight = weight;\n  result->index = index;\n  result->tail = tail;\n  return result;\n}\n\n/*sort the leaves with stable mergesort*/\nstatic void bpmnode_sort(BPMNode* leaves, size_t num) {\n  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);\n  size_t width, counter = 0;\n  for(width = 1; width < num; width *= 2) {\n    BPMNode* a = (counter & 1) ? mem : leaves;\n    BPMNode* b = (counter & 1) ? leaves : mem;\n    size_t p;\n    for(p = 0; p < num; p += 2 * width) {\n      size_t q = (p + width > num) ? num : (p + width);\n      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);\n      size_t i = p, j = q, k;\n      for(k = p; k < r; k++) {\n        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];\n        else b[k] = a[j++];\n      }\n    }\n    counter++;\n  }\n  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);\n  lodepng_free(mem);\n}\n\n/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/\nstatic void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {\n  unsigned lastindex = lists->chains1[c]->index;\n\n  if(c == 0) {\n    if(lastindex >= numpresent) return;\n    lists->chains0[c] = lists->chains1[c];\n    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);\n  } else {\n    /*sum of the weights of the head nodes of the previous lookahead chains.*/\n    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;\n    lists->chains0[c] = lists->chains1[c];\n    if(lastindex < numpresent && sum > leaves[lastindex].weight) {\n      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);\n      return;\n    }\n    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);\n    /*in the end we are only interested in the chain of the last list, so no\n    need to recurse if we're at the last one (this gives measurable speedup)*/\n    if(num + 1 < (int)(2 * numpresent - 2)) {\n      boundaryPM(lists, leaves, numpresent, c - 1, num);\n      boundaryPM(lists, leaves, numpresent, c - 1, num);\n    }\n  }\n}\n\nunsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,\n                                      size_t numcodes, unsigned maxbitlen) {\n  unsigned error = 0;\n  unsigned i;\n  size_t numpresent = 0; /*number of symbols with non-zero frequency*/\n  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/\n\n  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/\n  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/\n\n  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));\n  if(!leaves) return 83; /*alloc fail*/\n\n  for(i = 0; i != numcodes; ++i) {\n    if(frequencies[i] > 0) {\n      leaves[numpresent].weight = (int)frequencies[i];\n      leaves[numpresent].index = i;\n      ++numpresent;\n    }\n  }\n\n  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));\n\n  /*ensure at least two present symbols. There should be at least one symbol\n  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To\n  make these work as well ensure there are at least two symbols. The\n  Package-Merge code below also doesn't work correctly if there's only one\n  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/\n  if(numpresent == 0) {\n    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/\n  } else if(numpresent == 1) {\n    lengths[leaves[0].index] = 1;\n    lengths[leaves[0].index == 0 ? 1 : 0] = 1;\n  } else {\n    BPMLists lists;\n    BPMNode* node;\n\n    bpmnode_sort(leaves, numpresent);\n\n    lists.listsize = maxbitlen;\n    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);\n    lists.nextfree = 0;\n    lists.numfree = lists.memsize;\n    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));\n    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));\n    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));\n    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));\n    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/\n\n    if(!error) {\n      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];\n\n      bpmnode_create(&lists, leaves[0].weight, 1, 0);\n      bpmnode_create(&lists, leaves[1].weight, 2, 0);\n\n      for(i = 0; i != lists.listsize; ++i) {\n        lists.chains0[i] = &lists.memory[0];\n        lists.chains1[i] = &lists.memory[1];\n      }\n\n      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/\n      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);\n\n      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {\n        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];\n      }\n    }\n\n    lodepng_free(lists.memory);\n    lodepng_free(lists.freelist);\n    lodepng_free(lists.chains0);\n    lodepng_free(lists.chains1);\n  }\n\n  lodepng_free(leaves);\n  return error;\n}\n\n/*Create the Huffman tree given the symbol frequencies*/\nstatic unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {\n  unsigned error = 0;\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/\n  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));\n  if(!tree->lengths) return 83; /*alloc fail*/\n  tree->maxbitlen = maxbitlen;\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/\nstatic unsigned generateFixedLitLenTree(HuffmanTree* tree) {\n  unsigned i, error = 0;\n  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));\n  if(!bitlen) return 83; /*alloc fail*/\n\n  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/\n  for(i =   0; i <= 143; ++i) bitlen[i] = 8;\n  for(i = 144; i <= 255; ++i) bitlen[i] = 9;\n  for(i = 256; i <= 279; ++i) bitlen[i] = 7;\n  for(i = 280; i <= 287; ++i) bitlen[i] = 8;\n\n  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);\n\n  lodepng_free(bitlen);\n  return error;\n}\n\n/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/\nstatic unsigned generateFixedDistanceTree(HuffmanTree* tree) {\n  unsigned i, error = 0;\n  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));\n  if(!bitlen) return 83; /*alloc fail*/\n\n  /*there are 32 distance codes, but 30-31 are unused*/\n  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;\n  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);\n\n  lodepng_free(bitlen);\n  return error;\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n\n/*\nreturns the code. The bit reader must already have been ensured at least 15 bits\n*/\nstatic unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {\n  unsigned short code = peekBits(reader, FIRSTBITS);\n  unsigned short l = codetree->table_len[code];\n  unsigned short value = codetree->table_value[code];\n  if(l <= FIRSTBITS) {\n    advanceBits(reader, l);\n    return value;\n  } else {\n    advanceBits(reader, FIRSTBITS);\n    value += peekBits(reader, l - FIRSTBITS);\n    advanceBits(reader, codetree->table_len[value] - FIRSTBITS);\n    return codetree->table_value[value];\n  }\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Inflator (Decompressor)                                                / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*get the tree of a deflated block with fixed tree, as specified in the deflate specification\nReturns error code.*/\nstatic unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {\n  unsigned error = generateFixedLitLenTree(tree_ll);\n  if(error) return error;\n  return generateFixedDistanceTree(tree_d);\n}\n\n/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/\nstatic unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,\n                                      LodePNGBitReader* reader) {\n  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/\n  unsigned error = 0;\n  unsigned n, HLIT, HDIST, HCLEN, i;\n\n  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/\n  unsigned* bitlen_ll = 0; /*lit,len code lengths*/\n  unsigned* bitlen_d = 0; /*dist code lengths*/\n  /*code length code lengths (\"clcl\"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/\n  unsigned* bitlen_cl = 0;\n  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/\n\n  if(reader->bitsize - reader->bp < 14) return 49; /*error: the bit pointer is or will go past the memory*/\n  ensureBits17(reader, 14);\n\n  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/\n  HLIT =  readBits(reader, 5) + 257;\n  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/\n  HDIST = readBits(reader, 5) + 1;\n  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/\n  HCLEN = readBits(reader, 4) + 4;\n\n  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));\n  if(!bitlen_cl) return 83 /*alloc fail*/;\n\n  HuffmanTree_init(&tree_cl);\n\n  while(!error) {\n    /*read the code length codes out of 3 * (amount of code length codes) bits*/\n    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {\n      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/\n    }\n    for(i = 0; i != HCLEN; ++i) {\n      ensureBits9(reader, 3); /*out of bounds already checked above */\n      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);\n    }\n    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {\n      bitlen_cl[CLCL_ORDER[i]] = 0;\n    }\n\n    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);\n    if(error) break;\n\n    /*now we can use this tree to read the lengths for the tree that this function will return*/\n    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));\n    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));\n    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);\n    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));\n    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));\n\n    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/\n    i = 0;\n    while(i < HLIT + HDIST) {\n      unsigned code;\n      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/\n      code = huffmanDecodeSymbol(reader, &tree_cl);\n      if(code <= 15) /*a length code*/ {\n        if(i < HLIT) bitlen_ll[i] = code;\n        else bitlen_d[i - HLIT] = code;\n        ++i;\n      } else if(code == 16) /*repeat previous*/ {\n        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/\n        unsigned value; /*set value to the previous code*/\n\n        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/\n\n        replength += readBits(reader, 2);\n\n        if(i < HLIT + 1) value = bitlen_ll[i - 1];\n        else value = bitlen_d[i - HLIT - 1];\n        /*repeat this value in the next lengths*/\n        for(n = 0; n < replength; ++n) {\n          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/\n          if(i < HLIT) bitlen_ll[i] = value;\n          else bitlen_d[i - HLIT] = value;\n          ++i;\n        }\n      } else if(code == 17) /*repeat \"0\" 3-10 times*/ {\n        unsigned replength = 3; /*read in the bits that indicate repeat length*/\n        replength += readBits(reader, 3);\n\n        /*repeat this value in the next lengths*/\n        for(n = 0; n < replength; ++n) {\n          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/\n\n          if(i < HLIT) bitlen_ll[i] = 0;\n          else bitlen_d[i - HLIT] = 0;\n          ++i;\n        }\n      } else if(code == 18) /*repeat \"0\" 11-138 times*/ {\n        unsigned replength = 11; /*read in the bits that indicate repeat length*/\n        replength += readBits(reader, 7);\n\n        /*repeat this value in the next lengths*/\n        for(n = 0; n < replength; ++n) {\n          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/\n\n          if(i < HLIT) bitlen_ll[i] = 0;\n          else bitlen_d[i - HLIT] = 0;\n          ++i;\n        }\n      } else /*if(code == INVALIDSYMBOL)*/ {\n        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/\n      }\n      /*check if any of the ensureBits above went out of bounds*/\n      if(reader->bp > reader->bitsize) {\n        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\n        (10=no endcode, 11=wrong jump outside of tree)*/\n        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */\n        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/\n      }\n    }\n    if(error) break;\n\n    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/\n\n    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/\n    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);\n    if(error) break;\n    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);\n\n    break; /*end of error-while*/\n  }\n\n  lodepng_free(bitlen_cl);\n  lodepng_free(bitlen_ll);\n  lodepng_free(bitlen_d);\n  HuffmanTree_cleanup(&tree_cl);\n\n  return error;\n}\n\n/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/\nstatic unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,\n                                    unsigned btype, size_t max_output_size) {\n  unsigned error = 0;\n  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/\n  HuffmanTree tree_d; /*the huffman tree for distance codes*/\n  const size_t reserved_size = 260; /* must be at least 258 for max length, and a few extra for adding a few extra literals */\n  int done = 0;\n\n  if(!ucvector_reserve(out, out->size + reserved_size)) return 83; /*alloc fail*/\n\n  HuffmanTree_init(&tree_ll);\n  HuffmanTree_init(&tree_d);\n\n  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);\n  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);\n\n\n  while(!error && !done) /*decode all symbols until end reached, breaks at end code*/ {\n    /*code_ll is literal, length or end code*/\n    unsigned code_ll;\n    /* ensure enough bits for 2 huffman code reads (15 bits each): if the first is a literal, a second literal is read at once. This\n    appears to be slightly faster, than ensuring 20 bits here for 1 huffman symbol and the potential 5 extra bits for the length symbol.*/\n    ensureBits32(reader, 30);\n    code_ll = huffmanDecodeSymbol(reader, &tree_ll);\n    if(code_ll <= 255) {\n      /*slightly faster code path if multiple literals in a row*/\n      out->data[out->size++] = (unsigned char)code_ll;\n      code_ll = huffmanDecodeSymbol(reader, &tree_ll);\n    }\n    if(code_ll <= 255) /*literal symbol*/ {\n      out->data[out->size++] = (unsigned char)code_ll;\n    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {\n      unsigned code_d, distance;\n      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/\n      size_t start, backward, length;\n\n      /*part 1: get length base*/\n      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];\n\n      /*part 2: get extra bits and add the value of that to length*/\n      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];\n      if(numextrabits_l != 0) {\n        /* bits already ensured above */\n        ensureBits25(reader, 5);\n        length += readBits(reader, numextrabits_l);\n      }\n\n      /*part 3: get distance code*/\n      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */\n      code_d = huffmanDecodeSymbol(reader, &tree_d);\n      if(code_d > 29) {\n        if(code_d <= 31) {\n          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/\n        } else /* if(code_d == INVALIDSYMBOL) */{\n          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/\n        }\n      }\n      distance = DISTANCEBASE[code_d];\n\n      /*part 4: get extra bits from distance*/\n      numextrabits_d = DISTANCEEXTRA[code_d];\n      if(numextrabits_d != 0) {\n        /* bits already ensured above */\n        distance += readBits(reader, numextrabits_d);\n      }\n\n      /*part 5: fill in all the out[n] values based on the length and dist*/\n      start = out->size;\n      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/\n      backward = start - distance;\n\n      out->size += length;\n      if(distance < length) {\n        size_t forward;\n        lodepng_memcpy(out->data + start, out->data + backward, distance);\n        start += distance;\n        for(forward = distance; forward < length; ++forward) {\n          out->data[start++] = out->data[backward++];\n        }\n      } else {\n        lodepng_memcpy(out->data + start, out->data + backward, length);\n      }\n    } else if(code_ll == 256) {\n      done = 1; /*end code, finish the loop*/\n    } else /*if(code_ll == INVALIDSYMBOL)*/ {\n      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/\n    }\n    if(out->allocsize - out->size < reserved_size) {\n      if(!ucvector_reserve(out, out->size + reserved_size)) ERROR_BREAK(83); /*alloc fail*/\n    }\n    /*check if any of the ensureBits above went out of bounds*/\n    if(reader->bp > reader->bitsize) {\n      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\n      (10=no endcode, 11=wrong jump outside of tree)*/\n      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */\n      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/\n    }\n    if(max_output_size && out->size > max_output_size) {\n      ERROR_BREAK(109); /*error, larger than max size*/\n    }\n  }\n\n  HuffmanTree_cleanup(&tree_ll);\n  HuffmanTree_cleanup(&tree_d);\n\n  return error;\n}\n\nstatic unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,\n                                     const LodePNGDecompressSettings* settings) {\n  size_t bytepos;\n  size_t size = reader->size;\n  unsigned LEN, NLEN, error = 0;\n\n  /*go to first boundary of byte*/\n  bytepos = (reader->bp + 7u) >> 3u;\n\n  /*read LEN (2 bytes) and NLEN (2 bytes)*/\n  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/\n  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;\n  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;\n\n  /*check if 16-bit NLEN is really the one's complement of LEN*/\n  if(!settings->ignore_nlen && LEN + NLEN != 65535) {\n    return 21; /*error: NLEN is not one's complement of LEN*/\n  }\n\n  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/\n\n  /*read the literal data: LEN bytes are now stored in the out buffer*/\n  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/\n\n  /*out->data can be NULL (when LEN is zero), and arithmetics on NULL ptr is undefined*/\n  if (LEN) {\n    lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);\n    bytepos += LEN;\n  }\n\n  reader->bp = bytepos << 3u;\n\n  return error;\n}\n\nstatic unsigned lodepng_inflatev(ucvector* out,\n                                 const unsigned char* in, size_t insize,\n                                 const LodePNGDecompressSettings* settings) {\n  unsigned BFINAL = 0;\n  LodePNGBitReader reader;\n  unsigned error = LodePNGBitReader_init(&reader, in, insize);\n\n  if(error) return error;\n\n  while(!BFINAL) {\n    unsigned BTYPE;\n    if(reader.bitsize - reader.bp < 3) return 52; /*error, bit pointer will jump past memory*/\n    ensureBits9(&reader, 3);\n    BFINAL = readBits(&reader, 1);\n    BTYPE = readBits(&reader, 2);\n\n    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/\n    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/\n    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/\n    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;\n    if(error) break;\n  }\n\n  return error;\n}\n\nunsigned lodepng_inflate(unsigned char** out, size_t* outsize,\n                         const unsigned char* in, size_t insize,\n                         const LodePNGDecompressSettings* settings) {\n  ucvector v = ucvector_init(*out, *outsize);\n  unsigned error = lodepng_inflatev(&v, in, insize, settings);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}\n\nstatic unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,\n                        const LodePNGDecompressSettings* settings) {\n  if(settings->custom_inflate) {\n    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);\n    out->allocsize = out->size;\n    if(error) {\n      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/\n      error = 110;\n      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/\n      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;\n    }\n    return error;\n  } else {\n    return lodepng_inflatev(out, in, insize, settings);\n  }\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Deflator (Compressor)                                                  / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\nstatic const unsigned MAX_SUPPORTED_DEFLATE_LENGTH = 258;\n\n/*search the index in the array, that has the largest value smaller than or equal to the given value,\ngiven array must be sorted (if no value is smaller, it returns the size of the given array)*/\nstatic size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {\n  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/\n  size_t left = 1;\n  size_t right = array_size - 1;\n\n  while(left <= right) {\n    size_t mid = (left + right) >> 1;\n    if(array[mid] >= value) right = mid - 1;\n    else left = mid + 1;\n  }\n  if(left >= array_size || array[left] > value) left--;\n  return left;\n}\n\nstatic void addLengthDistance(uivector* values, size_t length, size_t distance) {\n  /*values in encoded vector are those used by deflate:\n  0-255: literal bytes\n  256: end\n  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)\n  286-287: invalid*/\n\n  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);\n  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);\n  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);\n  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);\n\n  size_t pos = values->size;\n  /*TODO: return error when this fails (out of memory)*/\n  unsigned ok = uivector_resize(values, values->size + 4);\n  if(ok) {\n    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;\n    values->data[pos + 1] = extra_length;\n    values->data[pos + 2] = dist_code;\n    values->data[pos + 3] = extra_distance;\n  }\n}\n\n/*3 bytes of data get encoded into two bytes. The hash cannot use more than 3\nbytes as input because 3 is the minimum match length for deflate*/\nstatic const unsigned HASH_NUM_VALUES = 65536;\nstatic const unsigned HASH_BIT_MASK = 65535; /*HASH_NUM_VALUES - 1, but C90 does not like that as initializer*/\n\ntypedef struct Hash {\n  int* head; /*hash value to head circular pos - can be outdated if went around window*/\n  /*circular pos to prev circular pos*/\n  unsigned short* chain;\n  int* val; /*circular pos to hash value*/\n\n  /*TODO: do this not only for zeros but for any repeated byte. However for PNG\n  it's always going to be the zeros that dominate, so not important for PNG*/\n  int* headz; /*similar to head, but for chainz*/\n  unsigned short* chainz; /*those with same amount of zeros*/\n  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/\n} Hash;\n\nstatic unsigned hash_init(Hash* hash, unsigned windowsize) {\n  unsigned i;\n  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);\n  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);\n  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\n\n  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\n  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));\n  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\n\n  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {\n    return 83; /*alloc fail*/\n  }\n\n  /*initialize hash table*/\n  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;\n  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;\n  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/\n\n  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;\n  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/\n\n  return 0;\n}\n\nstatic void hash_cleanup(Hash* hash) {\n  lodepng_free(hash->head);\n  lodepng_free(hash->val);\n  lodepng_free(hash->chain);\n\n  lodepng_free(hash->zeros);\n  lodepng_free(hash->headz);\n  lodepng_free(hash->chainz);\n}\n\n\n\nstatic unsigned getHash(const unsigned char* data, size_t size, size_t pos) {\n  unsigned result = 0;\n  if(pos + 2 < size) {\n    /*A simple shift and xor hash is used. Since the data of PNGs is dominated\n    by zeroes due to the filters, a better hash does not have a significant\n    effect on speed in traversing the chain, and causes more time spend on\n    calculating the hash.*/\n    result ^= ((unsigned)data[pos + 0] << 0u);\n    result ^= ((unsigned)data[pos + 1] << 4u);\n    result ^= ((unsigned)data[pos + 2] << 8u);\n  } else {\n    size_t amount, i;\n    if(pos >= size) return 0;\n    amount = size - pos;\n    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));\n  }\n  return result & HASH_BIT_MASK;\n}\n\nstatic unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {\n  const unsigned char* start = data + pos;\n  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;\n  if(end > data + size) end = data + size;\n  data = start;\n  while(data != end && *data == 0) ++data;\n  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/\n  return (unsigned)(data - start);\n}\n\n/*wpos = pos & (windowsize - 1)*/\nstatic void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {\n  hash->val[wpos] = (int)hashval;\n  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];\n  hash->head[hashval] = (int)wpos;\n\n  hash->zeros[wpos] = numzeros;\n  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];\n  hash->headz[numzeros] = (int)wpos;\n}\n\n/*\nLZ77-encode the data. Return value is error code. The input are raw bytes, the output\nis in the form of unsigned integers with codes representing for example literal bytes, or\nlength/distance pairs.\nIt uses a hash table technique to let it encode faster. When doing LZ77 encoding, a\nsliding window (of windowsize) is used, and all past bytes in that window can be used as\nthe \"dictionary\". A brute force search through all possible distances would be slow, and\nthis hash technique is one out of several ways to speed this up.\n*/\nstatic unsigned encodeLZ77(uivector* out, Hash* hash,\n                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,\n                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {\n  size_t pos;\n  unsigned i, error = 0;\n  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/\n  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;\n  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;\n\n  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/\n  unsigned numzeros = 0;\n\n  unsigned offset; /*the offset represents the distance in LZ77 terminology*/\n  unsigned length;\n  unsigned lazy = 0;\n  unsigned lazylength = 0, lazyoffset = 0;\n  unsigned hashval;\n  unsigned current_offset, current_length;\n  unsigned prev_offset;\n  const unsigned char *lastptr, *foreptr, *backptr;\n  unsigned hashpos;\n\n  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/\n  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/\n\n  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;\n\n  for(pos = inpos; pos < insize; ++pos) {\n    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/\n    unsigned chainlength = 0;\n\n    hashval = getHash(in, insize, pos);\n\n    if(usezeros && hashval == 0) {\n      if(numzeros == 0) numzeros = countZeros(in, insize, pos);\n      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;\n    } else {\n      numzeros = 0;\n    }\n\n    updateHashChain(hash, wpos, hashval, numzeros);\n\n    /*the length and offset found for the current position*/\n    length = 0;\n    offset = 0;\n\n    hashpos = hash->chain[wpos];\n\n    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];\n\n    /*search for the longest string*/\n    prev_offset = 0;\n    for(;;) {\n      if(chainlength++ >= maxchainlength) break;\n      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);\n\n      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/\n      prev_offset = current_offset;\n      if(current_offset > 0) {\n        /*test the next characters*/\n        foreptr = &in[pos];\n        backptr = &in[pos - current_offset];\n\n        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/\n        if(numzeros >= 3) {\n          unsigned skip = hash->zeros[hashpos];\n          if(skip > numzeros) skip = numzeros;\n          backptr += skip;\n          foreptr += skip;\n        }\n\n        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {\n          ++backptr;\n          ++foreptr;\n        }\n        current_length = (unsigned)(foreptr - &in[pos]);\n\n        if(current_length > length) {\n          length = current_length; /*the longest length*/\n          offset = current_offset; /*the offset that is related to this longest length*/\n          /*jump out once a length of max length is found (speed gain). This also jumps\n          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/\n          if(current_length >= nicematch) break;\n        }\n      }\n\n      if(hashpos == hash->chain[hashpos]) break;\n\n      if(numzeros >= 3 && length > numzeros) {\n        hashpos = hash->chainz[hashpos];\n        if(hash->zeros[hashpos] != numzeros) break;\n      } else {\n        hashpos = hash->chain[hashpos];\n        /*outdated hash value, happens if particular value was not encountered in whole last window*/\n        if(hash->val[hashpos] != (int)hashval) break;\n      }\n    }\n\n    if(lazymatching) {\n      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {\n        lazy = 1;\n        lazylength = length;\n        lazyoffset = offset;\n        continue; /*try the next byte*/\n      }\n      if(lazy) {\n        lazy = 0;\n        if(pos == 0) ERROR_BREAK(81);\n        if(length > lazylength + 1) {\n          /*push the previous character as literal*/\n          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);\n        } else {\n          length = lazylength;\n          offset = lazyoffset;\n          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/\n          hash->headz[numzeros] = -1; /*idem*/\n          --pos;\n        }\n      }\n    }\n    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);\n\n    /*encode it as length/distance pair or literal value*/\n    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {\n      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);\n    } else if(length < minmatch || (length == 3 && offset > 4096)) {\n      /*compensate for the fact that longer offsets have more extra bits, a\n      length of only 3 may be not worth it then*/\n      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);\n    } else {\n      addLengthDistance(out, length, offset);\n      for(i = 1; i < length; ++i) {\n        ++pos;\n        wpos = pos & (windowsize - 1);\n        hashval = getHash(in, insize, pos);\n        if(usezeros && hashval == 0) {\n          if(numzeros == 0) numzeros = countZeros(in, insize, pos);\n          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;\n        } else {\n          numzeros = 0;\n        }\n        updateHashChain(hash, wpos, hashval, numzeros);\n      }\n    }\n  } /*end of the loop through each character of input*/\n\n  return error;\n}\n\n/* /////////////////////////////////////////////////////////////////////////// */\n\nstatic unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {\n  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,\n  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/\n\n  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;\n  size_t datapos = 0;\n  for(i = 0; i != numdeflateblocks; ++i) {\n    unsigned BFINAL, BTYPE, LEN, NLEN;\n    unsigned char firstbyte;\n    size_t pos = out->size;\n\n    BFINAL = (i == numdeflateblocks - 1);\n    BTYPE = 0;\n\n    LEN = 65535;\n    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - (unsigned)datapos;\n    NLEN = 65535 - LEN;\n\n    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/\n\n    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));\n    out->data[pos + 0] = firstbyte;\n    out->data[pos + 1] = (unsigned char)(LEN & 255);\n    out->data[pos + 2] = (unsigned char)(LEN >> 8u);\n    out->data[pos + 3] = (unsigned char)(NLEN & 255);\n    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);\n    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);\n    datapos += LEN;\n  }\n\n  return 0;\n}\n\n/*\nwrite the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.\ntree_ll: the tree for lit and len codes.\ntree_d: the tree for distance codes.\n*/\nstatic void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,\n                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {\n  size_t i = 0;\n  for(i = 0; i != lz77_encoded->size; ++i) {\n    unsigned val = lz77_encoded->data[i];\n    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);\n    if(val > 256) /*for a length code, 3 more things have to be added*/ {\n      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;\n      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];\n      unsigned length_extra_bits = lz77_encoded->data[++i];\n\n      unsigned distance_code = lz77_encoded->data[++i];\n\n      unsigned distance_index = distance_code;\n      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];\n      unsigned distance_extra_bits = lz77_encoded->data[++i];\n\n      writeBits(writer, length_extra_bits, n_length_extra_bits);\n      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);\n      writeBits(writer, distance_extra_bits, n_distance_extra_bits);\n    }\n  }\n}\n\n/*Deflate for a block of type \"dynamic\", that is, with freely, optimally, created huffman trees*/\nstatic unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,\n                               const unsigned char* data, size_t datapos, size_t dataend,\n                               const LodePNGCompressSettings* settings, unsigned final) {\n  unsigned error = 0;\n\n  /*\n  A block is compressed as follows: The PNG data is lz77 encoded, resulting in\n  literal bytes and length/distance pairs. This is then huffman compressed with\n  two huffman trees. One huffman tree is used for the lit and len values (\"ll\"),\n  another huffman tree is used for the dist values (\"d\"). These two trees are\n  stored using their code lengths, and to compress even more these code lengths\n  are also run-length encoded and huffman compressed. This gives a huffman tree\n  of code lengths \"cl\". The code lengths used to describe this third tree are\n  the code length code lengths (\"clcl\").\n  */\n\n  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/\n  uivector lz77_encoded;\n  HuffmanTree tree_ll; /*tree for lit,len values*/\n  HuffmanTree tree_d; /*tree for distance codes*/\n  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/\n  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/\n  unsigned* frequencies_d = 0; /*frequency of dist codes*/\n  unsigned* frequencies_cl = 0; /*frequency of code length codes*/\n  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/\n  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/\n  size_t datasize = dataend - datapos;\n\n  /*\n  If we could call \"bitlen_cl\" the the code length code lengths (\"clcl\"), that is the bit lengths of codes to represent\n  tree_cl in CLCL_ORDER, then due to the huffman compression of huffman tree representations (\"two levels\"), there are\n  some analogies:\n  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.\n  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.\n  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.\n  */\n\n  unsigned BFINAL = final;\n  size_t i;\n  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;\n  unsigned HLIT, HDIST, HCLEN;\n\n  uivector_init(&lz77_encoded);\n  HuffmanTree_init(&tree_ll);\n  HuffmanTree_init(&tree_d);\n  HuffmanTree_init(&tree_cl);\n  /* could fit on stack, but >1KB is on the larger side so allocate instead */\n  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));\n  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));\n  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));\n\n  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/\n\n  /*This while loop never loops due to a break at the end, it is here to\n  allow breaking out of it to the cleanup phase on error conditions.*/\n  while(!error) {\n    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));\n    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));\n    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));\n\n    if(settings->use_lz77) {\n      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,\n                         settings->minmatch, settings->nicematch, settings->lazymatching);\n      if(error) break;\n    } else {\n      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);\n      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/\n    }\n\n    /*Count the frequencies of lit, len and dist codes*/\n    for(i = 0; i != lz77_encoded.size; ++i) {\n      unsigned symbol = lz77_encoded.data[i];\n      ++frequencies_ll[symbol];\n      if(symbol > 256) {\n        unsigned dist = lz77_encoded.data[i + 2];\n        ++frequencies_d[dist];\n        i += 3;\n      }\n    }\n    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/\n\n    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/\n    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);\n    if(error) break;\n    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/\n    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);\n    if(error) break;\n\n    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);\n    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);\n    /*store the code lengths of both generated trees in bitlen_lld*/\n    numcodes_lld = numcodes_ll + numcodes_d;\n    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));\n    /*numcodes_lld_e never needs more size than bitlen_lld*/\n    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));\n    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/\n    numcodes_lld_e = 0;\n\n    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];\n    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];\n\n    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),\n    17 (3-10 zeroes), 18 (11-138 zeroes)*/\n    for(i = 0; i != numcodes_lld; ++i) {\n      unsigned j = 0; /*amount of repetitions*/\n      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;\n\n      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {\n        ++j; /*include the first zero*/\n        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {\n          bitlen_lld_e[numcodes_lld_e++] = 17;\n          bitlen_lld_e[numcodes_lld_e++] = j - 3;\n        } else /*repeat code 18 supports max 138 zeroes*/ {\n          if(j > 138) j = 138;\n          bitlen_lld_e[numcodes_lld_e++] = 18;\n          bitlen_lld_e[numcodes_lld_e++] = j - 11;\n        }\n        i += (j - 1);\n      } else if(j >= 3) /*repeat code for value other than zero*/ {\n        size_t k;\n        unsigned num = j / 6u, rest = j % 6u;\n        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];\n        for(k = 0; k < num; ++k) {\n          bitlen_lld_e[numcodes_lld_e++] = 16;\n          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;\n        }\n        if(rest >= 3) {\n          bitlen_lld_e[numcodes_lld_e++] = 16;\n          bitlen_lld_e[numcodes_lld_e++] = rest - 3;\n        }\n        else j -= rest;\n        i += j;\n      } else /*too short to benefit from repeat code*/ {\n        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];\n      }\n    }\n\n    /*generate tree_cl, the huffmantree of huffmantrees*/\n    for(i = 0; i != numcodes_lld_e; ++i) {\n      ++frequencies_cl[bitlen_lld_e[i]];\n      /*after a repeat code come the bits that specify the number of repetitions,\n      those don't need to be in the frequencies_cl calculation*/\n      if(bitlen_lld_e[i] >= 16) ++i;\n    }\n\n    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,\n                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);\n    if(error) break;\n\n    /*compute amount of code-length-code-lengths to output*/\n    numcodes_cl = NUM_CODE_LENGTH_CODES;\n    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/\n    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {\n      numcodes_cl--;\n    }\n\n    /*\n    Write everything into the output\n\n    After the BFINAL and BTYPE, the dynamic block consists out of the following:\n    - 5 bits HLIT, 5 bits HDIST, 4 bits HCLEN\n    - (HCLEN+4)*3 bits code lengths of code length alphabet\n    - HLIT + 257 code lengths of lit/length alphabet (encoded using the code length\n      alphabet, + possible repetition codes 16, 17, 18)\n    - HDIST + 1 code lengths of distance alphabet (encoded using the code length\n      alphabet, + possible repetition codes 16, 17, 18)\n    - compressed data\n    - 256 (end code)\n    */\n\n    /*Write block type*/\n    writeBits(writer, BFINAL, 1);\n    writeBits(writer, 0, 1); /*first bit of BTYPE \"dynamic\"*/\n    writeBits(writer, 1, 1); /*second bit of BTYPE \"dynamic\"*/\n\n    /*write the HLIT, HDIST and HCLEN values*/\n    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies\n    or in the loop for numcodes_cl above, which saves space. */\n    HLIT = (unsigned)(numcodes_ll - 257);\n    HDIST = (unsigned)(numcodes_d - 1);\n    HCLEN = (unsigned)(numcodes_cl - 4);\n    writeBits(writer, HLIT, 5);\n    writeBits(writer, HDIST, 5);\n    writeBits(writer, HCLEN, 4);\n\n    /*write the code lengths of the code length alphabet (\"bitlen_cl\")*/\n    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);\n\n    /*write the lengths of the lit/len AND the dist alphabet*/\n    for(i = 0; i != numcodes_lld_e; ++i) {\n      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);\n      /*extra bits of repeat codes*/\n      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);\n      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);\n      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);\n    }\n\n    /*write the compressed data symbols*/\n    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);\n    /*error: the length of the end code 256 must be larger than 0*/\n    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);\n\n    /*write the end code*/\n    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);\n\n    break; /*end of error-while*/\n  }\n\n  /*cleanup*/\n  uivector_cleanup(&lz77_encoded);\n  HuffmanTree_cleanup(&tree_ll);\n  HuffmanTree_cleanup(&tree_d);\n  HuffmanTree_cleanup(&tree_cl);\n  lodepng_free(frequencies_ll);\n  lodepng_free(frequencies_d);\n  lodepng_free(frequencies_cl);\n  lodepng_free(bitlen_lld);\n  lodepng_free(bitlen_lld_e);\n\n  return error;\n}\n\nstatic unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,\n                             const unsigned char* data,\n                             size_t datapos, size_t dataend,\n                             const LodePNGCompressSettings* settings, unsigned final) {\n  HuffmanTree tree_ll; /*tree for literal values and length codes*/\n  HuffmanTree tree_d; /*tree for distance codes*/\n\n  unsigned BFINAL = final;\n  unsigned error = 0;\n  size_t i;\n\n  HuffmanTree_init(&tree_ll);\n  HuffmanTree_init(&tree_d);\n\n  error = generateFixedLitLenTree(&tree_ll);\n  if(!error) error = generateFixedDistanceTree(&tree_d);\n\n  if(!error) {\n    writeBits(writer, BFINAL, 1);\n    writeBits(writer, 1, 1); /*first bit of BTYPE*/\n    writeBits(writer, 0, 1); /*second bit of BTYPE*/\n\n    if(settings->use_lz77) /*LZ77 encoded*/ {\n      uivector lz77_encoded;\n      uivector_init(&lz77_encoded);\n      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,\n                         settings->minmatch, settings->nicematch, settings->lazymatching);\n      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);\n      uivector_cleanup(&lz77_encoded);\n    } else /*no LZ77, but still will be Huffman compressed*/ {\n      for(i = datapos; i < dataend; ++i) {\n        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);\n      }\n    }\n    /*add END code*/\n    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);\n  }\n\n  /*cleanup*/\n  HuffmanTree_cleanup(&tree_ll);\n  HuffmanTree_cleanup(&tree_d);\n\n  return error;\n}\n\nstatic unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,\n                                 const LodePNGCompressSettings* settings) {\n  unsigned error = 0;\n  size_t i, blocksize, numdeflateblocks;\n  Hash hash;\n  LodePNGBitWriter writer;\n\n  LodePNGBitWriter_init(&writer, out);\n\n  if(settings->btype > 2) return 61;\n  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);\n  else if(settings->btype == 1) blocksize = insize;\n  else /*if(settings->btype == 2)*/ {\n    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/\n    blocksize = insize / 8u + 8;\n    if(blocksize < 65536) blocksize = 65536;\n    if(blocksize > 262144) blocksize = 262144;\n  }\n\n  numdeflateblocks = (insize + blocksize - 1) / blocksize;\n  if(numdeflateblocks == 0) numdeflateblocks = 1;\n\n  error = hash_init(&hash, settings->windowsize);\n\n  if(!error) {\n    for(i = 0; i != numdeflateblocks && !error; ++i) {\n      unsigned final = (i == numdeflateblocks - 1);\n      size_t start = i * blocksize;\n      size_t end = start + blocksize;\n      if(end > insize) end = insize;\n\n      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);\n      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);\n    }\n  }\n\n  hash_cleanup(&hash);\n\n  return error;\n}\n\nunsigned lodepng_deflate(unsigned char** out, size_t* outsize,\n                         const unsigned char* in, size_t insize,\n                         const LodePNGCompressSettings* settings) {\n  ucvector v = ucvector_init(*out, *outsize);\n  unsigned error = lodepng_deflatev(&v, in, insize, settings);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}\n\nstatic unsigned deflate(unsigned char** out, size_t* outsize,\n                        const unsigned char* in, size_t insize,\n                        const LodePNGCompressSettings* settings) {\n  if(settings->custom_deflate) {\n    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);\n    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/\n    return error ? 111 : 0;\n  } else {\n    return lodepng_deflate(out, outsize, in, insize, settings);\n  }\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Adler32                                                                / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\nstatic unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {\n  unsigned s1 = adler & 0xffffu;\n  unsigned s2 = (adler >> 16u) & 0xffffu;\n\n  while(len != 0u) {\n    unsigned i;\n    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/\n    unsigned amount = len > 5552u ? 5552u : len;\n    len -= amount;\n    for(i = 0; i != amount; ++i) {\n      s1 += (*data++);\n      s2 += s1;\n    }\n    s1 %= 65521u;\n    s2 %= 65521u;\n  }\n\n  return (s2 << 16u) | s1;\n}\n\n/*Return the adler32 of the bytes data[0..len-1]*/\nstatic unsigned adler32(const unsigned char* data, unsigned len) {\n  return update_adler32(1u, data, len);\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Zlib                                                                   / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_DECODER\n\nstatic unsigned lodepng_zlib_decompressv(ucvector* out,\n                                         const unsigned char* in, size_t insize,\n                                         const LodePNGDecompressSettings* settings) {\n  unsigned error = 0;\n  unsigned CM, CINFO, FDICT;\n\n  if(insize < 2) return 53; /*error, size of zlib data too small*/\n  /*read information from zlib header*/\n  if((in[0] * 256 + in[1]) % 31 != 0) {\n    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/\n    return 24;\n  }\n\n  CM = in[0] & 15;\n  CINFO = (in[0] >> 4) & 15;\n  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/\n  FDICT = (in[1] >> 5) & 1;\n  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/\n\n  if(CM != 8 || CINFO > 7) {\n    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/\n    return 25;\n  }\n  if(FDICT != 0) {\n    /*error: the specification of PNG says about the zlib stream:\n      \"The additional flags shall not specify a preset dictionary.\"*/\n    return 26;\n  }\n\n  error = inflatev(out, in + 2, insize - 2, settings);\n  if(error) return error;\n\n  if(!settings->ignore_adler32) {\n    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);\n    unsigned checksum = adler32(out->data, (unsigned)(out->size));\n    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/\n  }\n\n  return 0; /*no error*/\n}\n\n\nunsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                                 size_t insize, const LodePNGDecompressSettings* settings) {\n  ucvector v = ucvector_init(*out, *outsize);\n  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}\n\n/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */\nstatic unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,\n                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {\n  unsigned error;\n  if(settings->custom_zlib) {\n    error = settings->custom_zlib(out, outsize, in, insize, settings);\n    if(error) {\n      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/\n      error = 110;\n      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/\n      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;\n    }\n  } else {\n    ucvector v = ucvector_init(*out, *outsize);\n    if(expected_size) {\n      /*reserve the memory to avoid intermediate reallocations*/\n      ucvector_resize(&v, *outsize + expected_size);\n      v.size = *outsize;\n    }\n    error = lodepng_zlib_decompressv(&v, in, insize, settings);\n    *out = v.data;\n    *outsize = v.size;\n  }\n  return error;\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\nunsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                               size_t insize, const LodePNGCompressSettings* settings) {\n  size_t i;\n  unsigned error;\n  unsigned char* deflatedata = 0;\n  size_t deflatesize = 0;\n\n  error = deflate(&deflatedata, &deflatesize, in, insize, settings);\n\n  *out = NULL;\n  *outsize = 0;\n  if(!error) {\n    *outsize = deflatesize + 6;\n    *out = (unsigned char*)lodepng_malloc(*outsize);\n    if(!*out) error = 83; /*alloc fail*/\n  }\n\n  if(!error) {\n    unsigned ADLER32 = adler32(in, (unsigned)insize);\n    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/\n    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/\n    unsigned FLEVEL = 0;\n    unsigned FDICT = 0;\n    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;\n    unsigned FCHECK = 31 - CMFFLG % 31;\n    CMFFLG += FCHECK;\n\n    (*out)[0] = (unsigned char)(CMFFLG >> 8);\n    (*out)[1] = (unsigned char)(CMFFLG & 255);\n    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];\n    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);\n  }\n\n  lodepng_free(deflatedata);\n  return error;\n}\n\n/* compress using the default or custom zlib function */\nstatic unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                              size_t insize, const LodePNGCompressSettings* settings) {\n  if(settings->custom_zlib) {\n    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);\n    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/\n    return error ? 111 : 0;\n  } else {\n    return lodepng_zlib_compress(out, outsize, in, insize, settings);\n  }\n}\n\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#else /*no LODEPNG_COMPILE_ZLIB*/\n\n#ifdef LODEPNG_COMPILE_DECODER\nstatic unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,\n                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {\n  if(!settings->custom_zlib) return 87; /*no custom zlib function provided */\n  (void)expected_size;\n  return settings->custom_zlib(out, outsize, in, insize, settings);\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n#ifdef LODEPNG_COMPILE_ENCODER\nstatic unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                              size_t insize, const LodePNGCompressSettings* settings) {\n  if(!settings->custom_zlib) return 87; /*no custom zlib function provided */\n  return settings->custom_zlib(out, outsize, in, insize, settings);\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#endif /*LODEPNG_COMPILE_ZLIB*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/*this is a good tradeoff between speed and compression ratio*/\n#define DEFAULT_WINDOWSIZE 2048\n\nvoid lodepng_compress_settings_init(LodePNGCompressSettings* settings) {\n  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/\n  settings->btype = 2;\n  settings->use_lz77 = 1;\n  settings->windowsize = DEFAULT_WINDOWSIZE;\n  settings->minmatch = 3;\n  settings->nicematch = 128;\n  settings->lazymatching = 1;\n\n  settings->custom_zlib = 0;\n  settings->custom_deflate = 0;\n  settings->custom_context = 0;\n}\n\nconst LodePNGCompressSettings lodepng_default_compress_settings = {2, 1, DEFAULT_WINDOWSIZE, 3, 128, 1, 0, 0, 0};\n\n\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n\nvoid lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {\n  settings->ignore_adler32 = 0;\n  settings->ignore_nlen = 0;\n  settings->max_output_size = 0;\n\n  settings->custom_zlib = 0;\n  settings->custom_inflate = 0;\n  settings->custom_context = 0;\n}\n\nconst LodePNGDecompressSettings lodepng_default_decompress_settings = {0, 0, 0, 0, 0, 0};\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // End of Zlib related code. Begin of PNG related code.                 // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_PNG\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / CRC32                                                                  / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n\n#ifdef LODEPNG_COMPILE_CRC\n\nstatic const unsigned lodepng_crc32_table0[256] = {\n  0x00000000u, 0x77073096u, 0xee0e612cu, 0x990951bau, 0x076dc419u, 0x706af48fu, 0xe963a535u, 0x9e6495a3u,\n  0x0edb8832u, 0x79dcb8a4u, 0xe0d5e91eu, 0x97d2d988u, 0x09b64c2bu, 0x7eb17cbdu, 0xe7b82d07u, 0x90bf1d91u,\n  0x1db71064u, 0x6ab020f2u, 0xf3b97148u, 0x84be41deu, 0x1adad47du, 0x6ddde4ebu, 0xf4d4b551u, 0x83d385c7u,\n  0x136c9856u, 0x646ba8c0u, 0xfd62f97au, 0x8a65c9ecu, 0x14015c4fu, 0x63066cd9u, 0xfa0f3d63u, 0x8d080df5u,\n  0x3b6e20c8u, 0x4c69105eu, 0xd56041e4u, 0xa2677172u, 0x3c03e4d1u, 0x4b04d447u, 0xd20d85fdu, 0xa50ab56bu,\n  0x35b5a8fau, 0x42b2986cu, 0xdbbbc9d6u, 0xacbcf940u, 0x32d86ce3u, 0x45df5c75u, 0xdcd60dcfu, 0xabd13d59u,\n  0x26d930acu, 0x51de003au, 0xc8d75180u, 0xbfd06116u, 0x21b4f4b5u, 0x56b3c423u, 0xcfba9599u, 0xb8bda50fu,\n  0x2802b89eu, 0x5f058808u, 0xc60cd9b2u, 0xb10be924u, 0x2f6f7c87u, 0x58684c11u, 0xc1611dabu, 0xb6662d3du,\n  0x76dc4190u, 0x01db7106u, 0x98d220bcu, 0xefd5102au, 0x71b18589u, 0x06b6b51fu, 0x9fbfe4a5u, 0xe8b8d433u,\n  0x7807c9a2u, 0x0f00f934u, 0x9609a88eu, 0xe10e9818u, 0x7f6a0dbbu, 0x086d3d2du, 0x91646c97u, 0xe6635c01u,\n  0x6b6b51f4u, 0x1c6c6162u, 0x856530d8u, 0xf262004eu, 0x6c0695edu, 0x1b01a57bu, 0x8208f4c1u, 0xf50fc457u,\n  0x65b0d9c6u, 0x12b7e950u, 0x8bbeb8eau, 0xfcb9887cu, 0x62dd1ddfu, 0x15da2d49u, 0x8cd37cf3u, 0xfbd44c65u,\n  0x4db26158u, 0x3ab551ceu, 0xa3bc0074u, 0xd4bb30e2u, 0x4adfa541u, 0x3dd895d7u, 0xa4d1c46du, 0xd3d6f4fbu,\n  0x4369e96au, 0x346ed9fcu, 0xad678846u, 0xda60b8d0u, 0x44042d73u, 0x33031de5u, 0xaa0a4c5fu, 0xdd0d7cc9u,\n  0x5005713cu, 0x270241aau, 0xbe0b1010u, 0xc90c2086u, 0x5768b525u, 0x206f85b3u, 0xb966d409u, 0xce61e49fu,\n  0x5edef90eu, 0x29d9c998u, 0xb0d09822u, 0xc7d7a8b4u, 0x59b33d17u, 0x2eb40d81u, 0xb7bd5c3bu, 0xc0ba6cadu,\n  0xedb88320u, 0x9abfb3b6u, 0x03b6e20cu, 0x74b1d29au, 0xead54739u, 0x9dd277afu, 0x04db2615u, 0x73dc1683u,\n  0xe3630b12u, 0x94643b84u, 0x0d6d6a3eu, 0x7a6a5aa8u, 0xe40ecf0bu, 0x9309ff9du, 0x0a00ae27u, 0x7d079eb1u,\n  0xf00f9344u, 0x8708a3d2u, 0x1e01f268u, 0x6906c2feu, 0xf762575du, 0x806567cbu, 0x196c3671u, 0x6e6b06e7u,\n  0xfed41b76u, 0x89d32be0u, 0x10da7a5au, 0x67dd4accu, 0xf9b9df6fu, 0x8ebeeff9u, 0x17b7be43u, 0x60b08ed5u,\n  0xd6d6a3e8u, 0xa1d1937eu, 0x38d8c2c4u, 0x4fdff252u, 0xd1bb67f1u, 0xa6bc5767u, 0x3fb506ddu, 0x48b2364bu,\n  0xd80d2bdau, 0xaf0a1b4cu, 0x36034af6u, 0x41047a60u, 0xdf60efc3u, 0xa867df55u, 0x316e8eefu, 0x4669be79u,\n  0xcb61b38cu, 0xbc66831au, 0x256fd2a0u, 0x5268e236u, 0xcc0c7795u, 0xbb0b4703u, 0x220216b9u, 0x5505262fu,\n  0xc5ba3bbeu, 0xb2bd0b28u, 0x2bb45a92u, 0x5cb36a04u, 0xc2d7ffa7u, 0xb5d0cf31u, 0x2cd99e8bu, 0x5bdeae1du,\n  0x9b64c2b0u, 0xec63f226u, 0x756aa39cu, 0x026d930au, 0x9c0906a9u, 0xeb0e363fu, 0x72076785u, 0x05005713u,\n  0x95bf4a82u, 0xe2b87a14u, 0x7bb12baeu, 0x0cb61b38u, 0x92d28e9bu, 0xe5d5be0du, 0x7cdcefb7u, 0x0bdbdf21u,\n  0x86d3d2d4u, 0xf1d4e242u, 0x68ddb3f8u, 0x1fda836eu, 0x81be16cdu, 0xf6b9265bu, 0x6fb077e1u, 0x18b74777u,\n  0x88085ae6u, 0xff0f6a70u, 0x66063bcau, 0x11010b5cu, 0x8f659effu, 0xf862ae69u, 0x616bffd3u, 0x166ccf45u,\n  0xa00ae278u, 0xd70dd2eeu, 0x4e048354u, 0x3903b3c2u, 0xa7672661u, 0xd06016f7u, 0x4969474du, 0x3e6e77dbu,\n  0xaed16a4au, 0xd9d65adcu, 0x40df0b66u, 0x37d83bf0u, 0xa9bcae53u, 0xdebb9ec5u, 0x47b2cf7fu, 0x30b5ffe9u,\n  0xbdbdf21cu, 0xcabac28au, 0x53b39330u, 0x24b4a3a6u, 0xbad03605u, 0xcdd70693u, 0x54de5729u, 0x23d967bfu,\n  0xb3667a2eu, 0xc4614ab8u, 0x5d681b02u, 0x2a6f2b94u, 0xb40bbe37u, 0xc30c8ea1u, 0x5a05df1bu, 0x2d02ef8du\n};\n\nstatic const unsigned lodepng_crc32_table1[256] = {\n  0x00000000u, 0x191b3141u, 0x32366282u, 0x2b2d53c3u, 0x646cc504u, 0x7d77f445u, 0x565aa786u, 0x4f4196c7u,\n  0xc8d98a08u, 0xd1c2bb49u, 0xfaefe88au, 0xe3f4d9cbu, 0xacb54f0cu, 0xb5ae7e4du, 0x9e832d8eu, 0x87981ccfu,\n  0x4ac21251u, 0x53d92310u, 0x78f470d3u, 0x61ef4192u, 0x2eaed755u, 0x37b5e614u, 0x1c98b5d7u, 0x05838496u,\n  0x821b9859u, 0x9b00a918u, 0xb02dfadbu, 0xa936cb9au, 0xe6775d5du, 0xff6c6c1cu, 0xd4413fdfu, 0xcd5a0e9eu,\n  0x958424a2u, 0x8c9f15e3u, 0xa7b24620u, 0xbea97761u, 0xf1e8e1a6u, 0xe8f3d0e7u, 0xc3de8324u, 0xdac5b265u,\n  0x5d5daeaau, 0x44469febu, 0x6f6bcc28u, 0x7670fd69u, 0x39316baeu, 0x202a5aefu, 0x0b07092cu, 0x121c386du,\n  0xdf4636f3u, 0xc65d07b2u, 0xed705471u, 0xf46b6530u, 0xbb2af3f7u, 0xa231c2b6u, 0x891c9175u, 0x9007a034u,\n  0x179fbcfbu, 0x0e848dbau, 0x25a9de79u, 0x3cb2ef38u, 0x73f379ffu, 0x6ae848beu, 0x41c51b7du, 0x58de2a3cu,\n  0xf0794f05u, 0xe9627e44u, 0xc24f2d87u, 0xdb541cc6u, 0x94158a01u, 0x8d0ebb40u, 0xa623e883u, 0xbf38d9c2u,\n  0x38a0c50du, 0x21bbf44cu, 0x0a96a78fu, 0x138d96ceu, 0x5ccc0009u, 0x45d73148u, 0x6efa628bu, 0x77e153cau,\n  0xbabb5d54u, 0xa3a06c15u, 0x888d3fd6u, 0x91960e97u, 0xded79850u, 0xc7cca911u, 0xece1fad2u, 0xf5facb93u,\n  0x7262d75cu, 0x6b79e61du, 0x4054b5deu, 0x594f849fu, 0x160e1258u, 0x0f152319u, 0x243870dau, 0x3d23419bu,\n  0x65fd6ba7u, 0x7ce65ae6u, 0x57cb0925u, 0x4ed03864u, 0x0191aea3u, 0x188a9fe2u, 0x33a7cc21u, 0x2abcfd60u,\n  0xad24e1afu, 0xb43fd0eeu, 0x9f12832du, 0x8609b26cu, 0xc94824abu, 0xd05315eau, 0xfb7e4629u, 0xe2657768u,\n  0x2f3f79f6u, 0x362448b7u, 0x1d091b74u, 0x04122a35u, 0x4b53bcf2u, 0x52488db3u, 0x7965de70u, 0x607eef31u,\n  0xe7e6f3feu, 0xfefdc2bfu, 0xd5d0917cu, 0xcccba03du, 0x838a36fau, 0x9a9107bbu, 0xb1bc5478u, 0xa8a76539u,\n  0x3b83984bu, 0x2298a90au, 0x09b5fac9u, 0x10aecb88u, 0x5fef5d4fu, 0x46f46c0eu, 0x6dd93fcdu, 0x74c20e8cu,\n  0xf35a1243u, 0xea412302u, 0xc16c70c1u, 0xd8774180u, 0x9736d747u, 0x8e2de606u, 0xa500b5c5u, 0xbc1b8484u,\n  0x71418a1au, 0x685abb5bu, 0x4377e898u, 0x5a6cd9d9u, 0x152d4f1eu, 0x0c367e5fu, 0x271b2d9cu, 0x3e001cddu,\n  0xb9980012u, 0xa0833153u, 0x8bae6290u, 0x92b553d1u, 0xddf4c516u, 0xc4eff457u, 0xefc2a794u, 0xf6d996d5u,\n  0xae07bce9u, 0xb71c8da8u, 0x9c31de6bu, 0x852aef2au, 0xca6b79edu, 0xd37048acu, 0xf85d1b6fu, 0xe1462a2eu,\n  0x66de36e1u, 0x7fc507a0u, 0x54e85463u, 0x4df36522u, 0x02b2f3e5u, 0x1ba9c2a4u, 0x30849167u, 0x299fa026u,\n  0xe4c5aeb8u, 0xfdde9ff9u, 0xd6f3cc3au, 0xcfe8fd7bu, 0x80a96bbcu, 0x99b25afdu, 0xb29f093eu, 0xab84387fu,\n  0x2c1c24b0u, 0x350715f1u, 0x1e2a4632u, 0x07317773u, 0x4870e1b4u, 0x516bd0f5u, 0x7a468336u, 0x635db277u,\n  0xcbfad74eu, 0xd2e1e60fu, 0xf9ccb5ccu, 0xe0d7848du, 0xaf96124au, 0xb68d230bu, 0x9da070c8u, 0x84bb4189u,\n  0x03235d46u, 0x1a386c07u, 0x31153fc4u, 0x280e0e85u, 0x674f9842u, 0x7e54a903u, 0x5579fac0u, 0x4c62cb81u,\n  0x8138c51fu, 0x9823f45eu, 0xb30ea79du, 0xaa1596dcu, 0xe554001bu, 0xfc4f315au, 0xd7626299u, 0xce7953d8u,\n  0x49e14f17u, 0x50fa7e56u, 0x7bd72d95u, 0x62cc1cd4u, 0x2d8d8a13u, 0x3496bb52u, 0x1fbbe891u, 0x06a0d9d0u,\n  0x5e7ef3ecu, 0x4765c2adu, 0x6c48916eu, 0x7553a02fu, 0x3a1236e8u, 0x230907a9u, 0x0824546au, 0x113f652bu,\n  0x96a779e4u, 0x8fbc48a5u, 0xa4911b66u, 0xbd8a2a27u, 0xf2cbbce0u, 0xebd08da1u, 0xc0fdde62u, 0xd9e6ef23u,\n  0x14bce1bdu, 0x0da7d0fcu, 0x268a833fu, 0x3f91b27eu, 0x70d024b9u, 0x69cb15f8u, 0x42e6463bu, 0x5bfd777au,\n  0xdc656bb5u, 0xc57e5af4u, 0xee530937u, 0xf7483876u, 0xb809aeb1u, 0xa1129ff0u, 0x8a3fcc33u, 0x9324fd72u\n};\n\nstatic const unsigned lodepng_crc32_table2[256] = {\n  0x00000000u, 0x01c26a37u, 0x0384d46eu, 0x0246be59u, 0x0709a8dcu, 0x06cbc2ebu, 0x048d7cb2u, 0x054f1685u,\n  0x0e1351b8u, 0x0fd13b8fu, 0x0d9785d6u, 0x0c55efe1u, 0x091af964u, 0x08d89353u, 0x0a9e2d0au, 0x0b5c473du,\n  0x1c26a370u, 0x1de4c947u, 0x1fa2771eu, 0x1e601d29u, 0x1b2f0bacu, 0x1aed619bu, 0x18abdfc2u, 0x1969b5f5u,\n  0x1235f2c8u, 0x13f798ffu, 0x11b126a6u, 0x10734c91u, 0x153c5a14u, 0x14fe3023u, 0x16b88e7au, 0x177ae44du,\n  0x384d46e0u, 0x398f2cd7u, 0x3bc9928eu, 0x3a0bf8b9u, 0x3f44ee3cu, 0x3e86840bu, 0x3cc03a52u, 0x3d025065u,\n  0x365e1758u, 0x379c7d6fu, 0x35dac336u, 0x3418a901u, 0x3157bf84u, 0x3095d5b3u, 0x32d36beau, 0x331101ddu,\n  0x246be590u, 0x25a98fa7u, 0x27ef31feu, 0x262d5bc9u, 0x23624d4cu, 0x22a0277bu, 0x20e69922u, 0x2124f315u,\n  0x2a78b428u, 0x2bbade1fu, 0x29fc6046u, 0x283e0a71u, 0x2d711cf4u, 0x2cb376c3u, 0x2ef5c89au, 0x2f37a2adu,\n  0x709a8dc0u, 0x7158e7f7u, 0x731e59aeu, 0x72dc3399u, 0x7793251cu, 0x76514f2bu, 0x7417f172u, 0x75d59b45u,\n  0x7e89dc78u, 0x7f4bb64fu, 0x7d0d0816u, 0x7ccf6221u, 0x798074a4u, 0x78421e93u, 0x7a04a0cau, 0x7bc6cafdu,\n  0x6cbc2eb0u, 0x6d7e4487u, 0x6f38fadeu, 0x6efa90e9u, 0x6bb5866cu, 0x6a77ec5bu, 0x68315202u, 0x69f33835u,\n  0x62af7f08u, 0x636d153fu, 0x612bab66u, 0x60e9c151u, 0x65a6d7d4u, 0x6464bde3u, 0x662203bau, 0x67e0698du,\n  0x48d7cb20u, 0x4915a117u, 0x4b531f4eu, 0x4a917579u, 0x4fde63fcu, 0x4e1c09cbu, 0x4c5ab792u, 0x4d98dda5u,\n  0x46c49a98u, 0x4706f0afu, 0x45404ef6u, 0x448224c1u, 0x41cd3244u, 0x400f5873u, 0x4249e62au, 0x438b8c1du,\n  0x54f16850u, 0x55330267u, 0x5775bc3eu, 0x56b7d609u, 0x53f8c08cu, 0x523aaabbu, 0x507c14e2u, 0x51be7ed5u,\n  0x5ae239e8u, 0x5b2053dfu, 0x5966ed86u, 0x58a487b1u, 0x5deb9134u, 0x5c29fb03u, 0x5e6f455au, 0x5fad2f6du,\n  0xe1351b80u, 0xe0f771b7u, 0xe2b1cfeeu, 0xe373a5d9u, 0xe63cb35cu, 0xe7fed96bu, 0xe5b86732u, 0xe47a0d05u,\n  0xef264a38u, 0xeee4200fu, 0xeca29e56u, 0xed60f461u, 0xe82fe2e4u, 0xe9ed88d3u, 0xebab368au, 0xea695cbdu,\n  0xfd13b8f0u, 0xfcd1d2c7u, 0xfe976c9eu, 0xff5506a9u, 0xfa1a102cu, 0xfbd87a1bu, 0xf99ec442u, 0xf85cae75u,\n  0xf300e948u, 0xf2c2837fu, 0xf0843d26u, 0xf1465711u, 0xf4094194u, 0xf5cb2ba3u, 0xf78d95fau, 0xf64fffcdu,\n  0xd9785d60u, 0xd8ba3757u, 0xdafc890eu, 0xdb3ee339u, 0xde71f5bcu, 0xdfb39f8bu, 0xddf521d2u, 0xdc374be5u,\n  0xd76b0cd8u, 0xd6a966efu, 0xd4efd8b6u, 0xd52db281u, 0xd062a404u, 0xd1a0ce33u, 0xd3e6706au, 0xd2241a5du,\n  0xc55efe10u, 0xc49c9427u, 0xc6da2a7eu, 0xc7184049u, 0xc25756ccu, 0xc3953cfbu, 0xc1d382a2u, 0xc011e895u,\n  0xcb4dafa8u, 0xca8fc59fu, 0xc8c97bc6u, 0xc90b11f1u, 0xcc440774u, 0xcd866d43u, 0xcfc0d31au, 0xce02b92du,\n  0x91af9640u, 0x906dfc77u, 0x922b422eu, 0x93e92819u, 0x96a63e9cu, 0x976454abu, 0x9522eaf2u, 0x94e080c5u,\n  0x9fbcc7f8u, 0x9e7eadcfu, 0x9c381396u, 0x9dfa79a1u, 0x98b56f24u, 0x99770513u, 0x9b31bb4au, 0x9af3d17du,\n  0x8d893530u, 0x8c4b5f07u, 0x8e0de15eu, 0x8fcf8b69u, 0x8a809decu, 0x8b42f7dbu, 0x89044982u, 0x88c623b5u,\n  0x839a6488u, 0x82580ebfu, 0x801eb0e6u, 0x81dcdad1u, 0x8493cc54u, 0x8551a663u, 0x8717183au, 0x86d5720du,\n  0xa9e2d0a0u, 0xa820ba97u, 0xaa6604ceu, 0xaba46ef9u, 0xaeeb787cu, 0xaf29124bu, 0xad6fac12u, 0xacadc625u,\n  0xa7f18118u, 0xa633eb2fu, 0xa4755576u, 0xa5b73f41u, 0xa0f829c4u, 0xa13a43f3u, 0xa37cfdaau, 0xa2be979du,\n  0xb5c473d0u, 0xb40619e7u, 0xb640a7beu, 0xb782cd89u, 0xb2cddb0cu, 0xb30fb13bu, 0xb1490f62u, 0xb08b6555u,\n  0xbbd72268u, 0xba15485fu, 0xb853f606u, 0xb9919c31u, 0xbcde8ab4u, 0xbd1ce083u, 0xbf5a5edau, 0xbe9834edu\n};\n\nstatic const unsigned lodepng_crc32_table3[256] = {\n  0x00000000u, 0xb8bc6765u, 0xaa09c88bu, 0x12b5afeeu, 0x8f629757u, 0x37def032u, 0x256b5fdcu, 0x9dd738b9u,\n  0xc5b428efu, 0x7d084f8au, 0x6fbde064u, 0xd7018701u, 0x4ad6bfb8u, 0xf26ad8ddu, 0xe0df7733u, 0x58631056u,\n  0x5019579fu, 0xe8a530fau, 0xfa109f14u, 0x42acf871u, 0xdf7bc0c8u, 0x67c7a7adu, 0x75720843u, 0xcdce6f26u,\n  0x95ad7f70u, 0x2d111815u, 0x3fa4b7fbu, 0x8718d09eu, 0x1acfe827u, 0xa2738f42u, 0xb0c620acu, 0x087a47c9u,\n  0xa032af3eu, 0x188ec85bu, 0x0a3b67b5u, 0xb28700d0u, 0x2f503869u, 0x97ec5f0cu, 0x8559f0e2u, 0x3de59787u,\n  0x658687d1u, 0xdd3ae0b4u, 0xcf8f4f5au, 0x7733283fu, 0xeae41086u, 0x525877e3u, 0x40edd80du, 0xf851bf68u,\n  0xf02bf8a1u, 0x48979fc4u, 0x5a22302au, 0xe29e574fu, 0x7f496ff6u, 0xc7f50893u, 0xd540a77du, 0x6dfcc018u,\n  0x359fd04eu, 0x8d23b72bu, 0x9f9618c5u, 0x272a7fa0u, 0xbafd4719u, 0x0241207cu, 0x10f48f92u, 0xa848e8f7u,\n  0x9b14583du, 0x23a83f58u, 0x311d90b6u, 0x89a1f7d3u, 0x1476cf6au, 0xaccaa80fu, 0xbe7f07e1u, 0x06c36084u,\n  0x5ea070d2u, 0xe61c17b7u, 0xf4a9b859u, 0x4c15df3cu, 0xd1c2e785u, 0x697e80e0u, 0x7bcb2f0eu, 0xc377486bu,\n  0xcb0d0fa2u, 0x73b168c7u, 0x6104c729u, 0xd9b8a04cu, 0x446f98f5u, 0xfcd3ff90u, 0xee66507eu, 0x56da371bu,\n  0x0eb9274du, 0xb6054028u, 0xa4b0efc6u, 0x1c0c88a3u, 0x81dbb01au, 0x3967d77fu, 0x2bd27891u, 0x936e1ff4u,\n  0x3b26f703u, 0x839a9066u, 0x912f3f88u, 0x299358edu, 0xb4446054u, 0x0cf80731u, 0x1e4da8dfu, 0xa6f1cfbau,\n  0xfe92dfecu, 0x462eb889u, 0x549b1767u, 0xec277002u, 0x71f048bbu, 0xc94c2fdeu, 0xdbf98030u, 0x6345e755u,\n  0x6b3fa09cu, 0xd383c7f9u, 0xc1366817u, 0x798a0f72u, 0xe45d37cbu, 0x5ce150aeu, 0x4e54ff40u, 0xf6e89825u,\n  0xae8b8873u, 0x1637ef16u, 0x048240f8u, 0xbc3e279du, 0x21e91f24u, 0x99557841u, 0x8be0d7afu, 0x335cb0cau,\n  0xed59b63bu, 0x55e5d15eu, 0x47507eb0u, 0xffec19d5u, 0x623b216cu, 0xda874609u, 0xc832e9e7u, 0x708e8e82u,\n  0x28ed9ed4u, 0x9051f9b1u, 0x82e4565fu, 0x3a58313au, 0xa78f0983u, 0x1f336ee6u, 0x0d86c108u, 0xb53aa66du,\n  0xbd40e1a4u, 0x05fc86c1u, 0x1749292fu, 0xaff54e4au, 0x322276f3u, 0x8a9e1196u, 0x982bbe78u, 0x2097d91du,\n  0x78f4c94bu, 0xc048ae2eu, 0xd2fd01c0u, 0x6a4166a5u, 0xf7965e1cu, 0x4f2a3979u, 0x5d9f9697u, 0xe523f1f2u,\n  0x4d6b1905u, 0xf5d77e60u, 0xe762d18eu, 0x5fdeb6ebu, 0xc2098e52u, 0x7ab5e937u, 0x680046d9u, 0xd0bc21bcu,\n  0x88df31eau, 0x3063568fu, 0x22d6f961u, 0x9a6a9e04u, 0x07bda6bdu, 0xbf01c1d8u, 0xadb46e36u, 0x15080953u,\n  0x1d724e9au, 0xa5ce29ffu, 0xb77b8611u, 0x0fc7e174u, 0x9210d9cdu, 0x2aacbea8u, 0x38191146u, 0x80a57623u,\n  0xd8c66675u, 0x607a0110u, 0x72cfaefeu, 0xca73c99bu, 0x57a4f122u, 0xef189647u, 0xfdad39a9u, 0x45115eccu,\n  0x764dee06u, 0xcef18963u, 0xdc44268du, 0x64f841e8u, 0xf92f7951u, 0x41931e34u, 0x5326b1dau, 0xeb9ad6bfu,\n  0xb3f9c6e9u, 0x0b45a18cu, 0x19f00e62u, 0xa14c6907u, 0x3c9b51beu, 0x842736dbu, 0x96929935u, 0x2e2efe50u,\n  0x2654b999u, 0x9ee8defcu, 0x8c5d7112u, 0x34e11677u, 0xa9362eceu, 0x118a49abu, 0x033fe645u, 0xbb838120u,\n  0xe3e09176u, 0x5b5cf613u, 0x49e959fdu, 0xf1553e98u, 0x6c820621u, 0xd43e6144u, 0xc68bceaau, 0x7e37a9cfu,\n  0xd67f4138u, 0x6ec3265du, 0x7c7689b3u, 0xc4caeed6u, 0x591dd66fu, 0xe1a1b10au, 0xf3141ee4u, 0x4ba87981u,\n  0x13cb69d7u, 0xab770eb2u, 0xb9c2a15cu, 0x017ec639u, 0x9ca9fe80u, 0x241599e5u, 0x36a0360bu, 0x8e1c516eu,\n  0x866616a7u, 0x3eda71c2u, 0x2c6fde2cu, 0x94d3b949u, 0x090481f0u, 0xb1b8e695u, 0xa30d497bu, 0x1bb12e1eu,\n  0x43d23e48u, 0xfb6e592du, 0xe9dbf6c3u, 0x516791a6u, 0xccb0a91fu, 0x740cce7au, 0x66b96194u, 0xde0506f1u\n};\n\nstatic const unsigned lodepng_crc32_table4[256] = {\n  0x00000000u, 0x3d6029b0u, 0x7ac05360u, 0x47a07ad0u, 0xf580a6c0u, 0xc8e08f70u, 0x8f40f5a0u, 0xb220dc10u,\n  0x30704bc1u, 0x0d106271u, 0x4ab018a1u, 0x77d03111u, 0xc5f0ed01u, 0xf890c4b1u, 0xbf30be61u, 0x825097d1u,\n  0x60e09782u, 0x5d80be32u, 0x1a20c4e2u, 0x2740ed52u, 0x95603142u, 0xa80018f2u, 0xefa06222u, 0xd2c04b92u,\n  0x5090dc43u, 0x6df0f5f3u, 0x2a508f23u, 0x1730a693u, 0xa5107a83u, 0x98705333u, 0xdfd029e3u, 0xe2b00053u,\n  0xc1c12f04u, 0xfca106b4u, 0xbb017c64u, 0x866155d4u, 0x344189c4u, 0x0921a074u, 0x4e81daa4u, 0x73e1f314u,\n  0xf1b164c5u, 0xccd14d75u, 0x8b7137a5u, 0xb6111e15u, 0x0431c205u, 0x3951ebb5u, 0x7ef19165u, 0x4391b8d5u,\n  0xa121b886u, 0x9c419136u, 0xdbe1ebe6u, 0xe681c256u, 0x54a11e46u, 0x69c137f6u, 0x2e614d26u, 0x13016496u,\n  0x9151f347u, 0xac31daf7u, 0xeb91a027u, 0xd6f18997u, 0x64d15587u, 0x59b17c37u, 0x1e1106e7u, 0x23712f57u,\n  0x58f35849u, 0x659371f9u, 0x22330b29u, 0x1f532299u, 0xad73fe89u, 0x9013d739u, 0xd7b3ade9u, 0xead38459u,\n  0x68831388u, 0x55e33a38u, 0x124340e8u, 0x2f236958u, 0x9d03b548u, 0xa0639cf8u, 0xe7c3e628u, 0xdaa3cf98u,\n  0x3813cfcbu, 0x0573e67bu, 0x42d39cabu, 0x7fb3b51bu, 0xcd93690bu, 0xf0f340bbu, 0xb7533a6bu, 0x8a3313dbu,\n  0x0863840au, 0x3503adbau, 0x72a3d76au, 0x4fc3fedau, 0xfde322cau, 0xc0830b7au, 0x872371aau, 0xba43581au,\n  0x9932774du, 0xa4525efdu, 0xe3f2242du, 0xde920d9du, 0x6cb2d18du, 0x51d2f83du, 0x167282edu, 0x2b12ab5du,\n  0xa9423c8cu, 0x9422153cu, 0xd3826fecu, 0xeee2465cu, 0x5cc29a4cu, 0x61a2b3fcu, 0x2602c92cu, 0x1b62e09cu,\n  0xf9d2e0cfu, 0xc4b2c97fu, 0x8312b3afu, 0xbe729a1fu, 0x0c52460fu, 0x31326fbfu, 0x7692156fu, 0x4bf23cdfu,\n  0xc9a2ab0eu, 0xf4c282beu, 0xb362f86eu, 0x8e02d1deu, 0x3c220dceu, 0x0142247eu, 0x46e25eaeu, 0x7b82771eu,\n  0xb1e6b092u, 0x8c869922u, 0xcb26e3f2u, 0xf646ca42u, 0x44661652u, 0x79063fe2u, 0x3ea64532u, 0x03c66c82u,\n  0x8196fb53u, 0xbcf6d2e3u, 0xfb56a833u, 0xc6368183u, 0x74165d93u, 0x49767423u, 0x0ed60ef3u, 0x33b62743u,\n  0xd1062710u, 0xec660ea0u, 0xabc67470u, 0x96a65dc0u, 0x248681d0u, 0x19e6a860u, 0x5e46d2b0u, 0x6326fb00u,\n  0xe1766cd1u, 0xdc164561u, 0x9bb63fb1u, 0xa6d61601u, 0x14f6ca11u, 0x2996e3a1u, 0x6e369971u, 0x5356b0c1u,\n  0x70279f96u, 0x4d47b626u, 0x0ae7ccf6u, 0x3787e546u, 0x85a73956u, 0xb8c710e6u, 0xff676a36u, 0xc2074386u,\n  0x4057d457u, 0x7d37fde7u, 0x3a978737u, 0x07f7ae87u, 0xb5d77297u, 0x88b75b27u, 0xcf1721f7u, 0xf2770847u,\n  0x10c70814u, 0x2da721a4u, 0x6a075b74u, 0x576772c4u, 0xe547aed4u, 0xd8278764u, 0x9f87fdb4u, 0xa2e7d404u,\n  0x20b743d5u, 0x1dd76a65u, 0x5a7710b5u, 0x67173905u, 0xd537e515u, 0xe857cca5u, 0xaff7b675u, 0x92979fc5u,\n  0xe915e8dbu, 0xd475c16bu, 0x93d5bbbbu, 0xaeb5920bu, 0x1c954e1bu, 0x21f567abu, 0x66551d7bu, 0x5b3534cbu,\n  0xd965a31au, 0xe4058aaau, 0xa3a5f07au, 0x9ec5d9cau, 0x2ce505dau, 0x11852c6au, 0x562556bau, 0x6b457f0au,\n  0x89f57f59u, 0xb49556e9u, 0xf3352c39u, 0xce550589u, 0x7c75d999u, 0x4115f029u, 0x06b58af9u, 0x3bd5a349u,\n  0xb9853498u, 0x84e51d28u, 0xc34567f8u, 0xfe254e48u, 0x4c059258u, 0x7165bbe8u, 0x36c5c138u, 0x0ba5e888u,\n  0x28d4c7dfu, 0x15b4ee6fu, 0x521494bfu, 0x6f74bd0fu, 0xdd54611fu, 0xe03448afu, 0xa794327fu, 0x9af41bcfu,\n  0x18a48c1eu, 0x25c4a5aeu, 0x6264df7eu, 0x5f04f6ceu, 0xed242adeu, 0xd044036eu, 0x97e479beu, 0xaa84500eu,\n  0x4834505du, 0x755479edu, 0x32f4033du, 0x0f942a8du, 0xbdb4f69du, 0x80d4df2du, 0xc774a5fdu, 0xfa148c4du,\n  0x78441b9cu, 0x4524322cu, 0x028448fcu, 0x3fe4614cu, 0x8dc4bd5cu, 0xb0a494ecu, 0xf704ee3cu, 0xca64c78cu\n};\n\nstatic const unsigned lodepng_crc32_table5[256] = {\n  0x00000000u, 0xcb5cd3a5u, 0x4dc8a10bu, 0x869472aeu, 0x9b914216u, 0x50cd91b3u, 0xd659e31du, 0x1d0530b8u,\n  0xec53826du, 0x270f51c8u, 0xa19b2366u, 0x6ac7f0c3u, 0x77c2c07bu, 0xbc9e13deu, 0x3a0a6170u, 0xf156b2d5u,\n  0x03d6029bu, 0xc88ad13eu, 0x4e1ea390u, 0x85427035u, 0x9847408du, 0x531b9328u, 0xd58fe186u, 0x1ed33223u,\n  0xef8580f6u, 0x24d95353u, 0xa24d21fdu, 0x6911f258u, 0x7414c2e0u, 0xbf481145u, 0x39dc63ebu, 0xf280b04eu,\n  0x07ac0536u, 0xccf0d693u, 0x4a64a43du, 0x81387798u, 0x9c3d4720u, 0x57619485u, 0xd1f5e62bu, 0x1aa9358eu,\n  0xebff875bu, 0x20a354feu, 0xa6372650u, 0x6d6bf5f5u, 0x706ec54du, 0xbb3216e8u, 0x3da66446u, 0xf6fab7e3u,\n  0x047a07adu, 0xcf26d408u, 0x49b2a6a6u, 0x82ee7503u, 0x9feb45bbu, 0x54b7961eu, 0xd223e4b0u, 0x197f3715u,\n  0xe82985c0u, 0x23755665u, 0xa5e124cbu, 0x6ebdf76eu, 0x73b8c7d6u, 0xb8e41473u, 0x3e7066ddu, 0xf52cb578u,\n  0x0f580a6cu, 0xc404d9c9u, 0x4290ab67u, 0x89cc78c2u, 0x94c9487au, 0x5f959bdfu, 0xd901e971u, 0x125d3ad4u,\n  0xe30b8801u, 0x28575ba4u, 0xaec3290au, 0x659ffaafu, 0x789aca17u, 0xb3c619b2u, 0x35526b1cu, 0xfe0eb8b9u,\n  0x0c8e08f7u, 0xc7d2db52u, 0x4146a9fcu, 0x8a1a7a59u, 0x971f4ae1u, 0x5c439944u, 0xdad7ebeau, 0x118b384fu,\n  0xe0dd8a9au, 0x2b81593fu, 0xad152b91u, 0x6649f834u, 0x7b4cc88cu, 0xb0101b29u, 0x36846987u, 0xfdd8ba22u,\n  0x08f40f5au, 0xc3a8dcffu, 0x453cae51u, 0x8e607df4u, 0x93654d4cu, 0x58399ee9u, 0xdeadec47u, 0x15f13fe2u,\n  0xe4a78d37u, 0x2ffb5e92u, 0xa96f2c3cu, 0x6233ff99u, 0x7f36cf21u, 0xb46a1c84u, 0x32fe6e2au, 0xf9a2bd8fu,\n  0x0b220dc1u, 0xc07ede64u, 0x46eaaccau, 0x8db67f6fu, 0x90b34fd7u, 0x5bef9c72u, 0xdd7beedcu, 0x16273d79u,\n  0xe7718facu, 0x2c2d5c09u, 0xaab92ea7u, 0x61e5fd02u, 0x7ce0cdbau, 0xb7bc1e1fu, 0x31286cb1u, 0xfa74bf14u,\n  0x1eb014d8u, 0xd5ecc77du, 0x5378b5d3u, 0x98246676u, 0x852156ceu, 0x4e7d856bu, 0xc8e9f7c5u, 0x03b52460u,\n  0xf2e396b5u, 0x39bf4510u, 0xbf2b37beu, 0x7477e41bu, 0x6972d4a3u, 0xa22e0706u, 0x24ba75a8u, 0xefe6a60du,\n  0x1d661643u, 0xd63ac5e6u, 0x50aeb748u, 0x9bf264edu, 0x86f75455u, 0x4dab87f0u, 0xcb3ff55eu, 0x006326fbu,\n  0xf135942eu, 0x3a69478bu, 0xbcfd3525u, 0x77a1e680u, 0x6aa4d638u, 0xa1f8059du, 0x276c7733u, 0xec30a496u,\n  0x191c11eeu, 0xd240c24bu, 0x54d4b0e5u, 0x9f886340u, 0x828d53f8u, 0x49d1805du, 0xcf45f2f3u, 0x04192156u,\n  0xf54f9383u, 0x3e134026u, 0xb8873288u, 0x73dbe12du, 0x6eded195u, 0xa5820230u, 0x2316709eu, 0xe84aa33bu,\n  0x1aca1375u, 0xd196c0d0u, 0x5702b27eu, 0x9c5e61dbu, 0x815b5163u, 0x4a0782c6u, 0xcc93f068u, 0x07cf23cdu,\n  0xf6999118u, 0x3dc542bdu, 0xbb513013u, 0x700de3b6u, 0x6d08d30eu, 0xa65400abu, 0x20c07205u, 0xeb9ca1a0u,\n  0x11e81eb4u, 0xdab4cd11u, 0x5c20bfbfu, 0x977c6c1au, 0x8a795ca2u, 0x41258f07u, 0xc7b1fda9u, 0x0ced2e0cu,\n  0xfdbb9cd9u, 0x36e74f7cu, 0xb0733dd2u, 0x7b2fee77u, 0x662adecfu, 0xad760d6au, 0x2be27fc4u, 0xe0beac61u,\n  0x123e1c2fu, 0xd962cf8au, 0x5ff6bd24u, 0x94aa6e81u, 0x89af5e39u, 0x42f38d9cu, 0xc467ff32u, 0x0f3b2c97u,\n  0xfe6d9e42u, 0x35314de7u, 0xb3a53f49u, 0x78f9ececu, 0x65fcdc54u, 0xaea00ff1u, 0x28347d5fu, 0xe368aefau,\n  0x16441b82u, 0xdd18c827u, 0x5b8cba89u, 0x90d0692cu, 0x8dd55994u, 0x46898a31u, 0xc01df89fu, 0x0b412b3au,\n  0xfa1799efu, 0x314b4a4au, 0xb7df38e4u, 0x7c83eb41u, 0x6186dbf9u, 0xaada085cu, 0x2c4e7af2u, 0xe712a957u,\n  0x15921919u, 0xdececabcu, 0x585ab812u, 0x93066bb7u, 0x8e035b0fu, 0x455f88aau, 0xc3cbfa04u, 0x089729a1u,\n  0xf9c19b74u, 0x329d48d1u, 0xb4093a7fu, 0x7f55e9dau, 0x6250d962u, 0xa90c0ac7u, 0x2f987869u, 0xe4c4abccu\n};\n\nstatic const unsigned lodepng_crc32_table6[256] = {\n  0x00000000u, 0xa6770bb4u, 0x979f1129u, 0x31e81a9du, 0xf44f2413u, 0x52382fa7u, 0x63d0353au, 0xc5a73e8eu,\n  0x33ef4e67u, 0x959845d3u, 0xa4705f4eu, 0x020754fau, 0xc7a06a74u, 0x61d761c0u, 0x503f7b5du, 0xf64870e9u,\n  0x67de9cceu, 0xc1a9977au, 0xf0418de7u, 0x56368653u, 0x9391b8ddu, 0x35e6b369u, 0x040ea9f4u, 0xa279a240u,\n  0x5431d2a9u, 0xf246d91du, 0xc3aec380u, 0x65d9c834u, 0xa07ef6bau, 0x0609fd0eu, 0x37e1e793u, 0x9196ec27u,\n  0xcfbd399cu, 0x69ca3228u, 0x582228b5u, 0xfe552301u, 0x3bf21d8fu, 0x9d85163bu, 0xac6d0ca6u, 0x0a1a0712u,\n  0xfc5277fbu, 0x5a257c4fu, 0x6bcd66d2u, 0xcdba6d66u, 0x081d53e8u, 0xae6a585cu, 0x9f8242c1u, 0x39f54975u,\n  0xa863a552u, 0x0e14aee6u, 0x3ffcb47bu, 0x998bbfcfu, 0x5c2c8141u, 0xfa5b8af5u, 0xcbb39068u, 0x6dc49bdcu,\n  0x9b8ceb35u, 0x3dfbe081u, 0x0c13fa1cu, 0xaa64f1a8u, 0x6fc3cf26u, 0xc9b4c492u, 0xf85cde0fu, 0x5e2bd5bbu,\n  0x440b7579u, 0xe27c7ecdu, 0xd3946450u, 0x75e36fe4u, 0xb044516au, 0x16335adeu, 0x27db4043u, 0x81ac4bf7u,\n  0x77e43b1eu, 0xd19330aau, 0xe07b2a37u, 0x460c2183u, 0x83ab1f0du, 0x25dc14b9u, 0x14340e24u, 0xb2430590u,\n  0x23d5e9b7u, 0x85a2e203u, 0xb44af89eu, 0x123df32au, 0xd79acda4u, 0x71edc610u, 0x4005dc8du, 0xe672d739u,\n  0x103aa7d0u, 0xb64dac64u, 0x87a5b6f9u, 0x21d2bd4du, 0xe47583c3u, 0x42028877u, 0x73ea92eau, 0xd59d995eu,\n  0x8bb64ce5u, 0x2dc14751u, 0x1c295dccu, 0xba5e5678u, 0x7ff968f6u, 0xd98e6342u, 0xe86679dfu, 0x4e11726bu,\n  0xb8590282u, 0x1e2e0936u, 0x2fc613abu, 0x89b1181fu, 0x4c162691u, 0xea612d25u, 0xdb8937b8u, 0x7dfe3c0cu,\n  0xec68d02bu, 0x4a1fdb9fu, 0x7bf7c102u, 0xdd80cab6u, 0x1827f438u, 0xbe50ff8cu, 0x8fb8e511u, 0x29cfeea5u,\n  0xdf879e4cu, 0x79f095f8u, 0x48188f65u, 0xee6f84d1u, 0x2bc8ba5fu, 0x8dbfb1ebu, 0xbc57ab76u, 0x1a20a0c2u,\n  0x8816eaf2u, 0x2e61e146u, 0x1f89fbdbu, 0xb9fef06fu, 0x7c59cee1u, 0xda2ec555u, 0xebc6dfc8u, 0x4db1d47cu,\n  0xbbf9a495u, 0x1d8eaf21u, 0x2c66b5bcu, 0x8a11be08u, 0x4fb68086u, 0xe9c18b32u, 0xd82991afu, 0x7e5e9a1bu,\n  0xefc8763cu, 0x49bf7d88u, 0x78576715u, 0xde206ca1u, 0x1b87522fu, 0xbdf0599bu, 0x8c184306u, 0x2a6f48b2u,\n  0xdc27385bu, 0x7a5033efu, 0x4bb82972u, 0xedcf22c6u, 0x28681c48u, 0x8e1f17fcu, 0xbff70d61u, 0x198006d5u,\n  0x47abd36eu, 0xe1dcd8dau, 0xd034c247u, 0x7643c9f3u, 0xb3e4f77du, 0x1593fcc9u, 0x247be654u, 0x820cede0u,\n  0x74449d09u, 0xd23396bdu, 0xe3db8c20u, 0x45ac8794u, 0x800bb91au, 0x267cb2aeu, 0x1794a833u, 0xb1e3a387u,\n  0x20754fa0u, 0x86024414u, 0xb7ea5e89u, 0x119d553du, 0xd43a6bb3u, 0x724d6007u, 0x43a57a9au, 0xe5d2712eu,\n  0x139a01c7u, 0xb5ed0a73u, 0x840510eeu, 0x22721b5au, 0xe7d525d4u, 0x41a22e60u, 0x704a34fdu, 0xd63d3f49u,\n  0xcc1d9f8bu, 0x6a6a943fu, 0x5b828ea2u, 0xfdf58516u, 0x3852bb98u, 0x9e25b02cu, 0xafcdaab1u, 0x09baa105u,\n  0xfff2d1ecu, 0x5985da58u, 0x686dc0c5u, 0xce1acb71u, 0x0bbdf5ffu, 0xadcafe4bu, 0x9c22e4d6u, 0x3a55ef62u,\n  0xabc30345u, 0x0db408f1u, 0x3c5c126cu, 0x9a2b19d8u, 0x5f8c2756u, 0xf9fb2ce2u, 0xc813367fu, 0x6e643dcbu,\n  0x982c4d22u, 0x3e5b4696u, 0x0fb35c0bu, 0xa9c457bfu, 0x6c636931u, 0xca146285u, 0xfbfc7818u, 0x5d8b73acu,\n  0x03a0a617u, 0xa5d7ada3u, 0x943fb73eu, 0x3248bc8au, 0xf7ef8204u, 0x519889b0u, 0x6070932du, 0xc6079899u,\n  0x304fe870u, 0x9638e3c4u, 0xa7d0f959u, 0x01a7f2edu, 0xc400cc63u, 0x6277c7d7u, 0x539fdd4au, 0xf5e8d6feu,\n  0x647e3ad9u, 0xc209316du, 0xf3e12bf0u, 0x55962044u, 0x90311ecau, 0x3646157eu, 0x07ae0fe3u, 0xa1d90457u,\n  0x579174beu, 0xf1e67f0au, 0xc00e6597u, 0x66796e23u, 0xa3de50adu, 0x05a95b19u, 0x34414184u, 0x92364a30u\n};\n\nstatic const unsigned lodepng_crc32_table7[256] = {\n  0x00000000u, 0xccaa009eu, 0x4225077du, 0x8e8f07e3u, 0x844a0efau, 0x48e00e64u, 0xc66f0987u, 0x0ac50919u,\n  0xd3e51bb5u, 0x1f4f1b2bu, 0x91c01cc8u, 0x5d6a1c56u, 0x57af154fu, 0x9b0515d1u, 0x158a1232u, 0xd92012acu,\n  0x7cbb312bu, 0xb01131b5u, 0x3e9e3656u, 0xf23436c8u, 0xf8f13fd1u, 0x345b3f4fu, 0xbad438acu, 0x767e3832u,\n  0xaf5e2a9eu, 0x63f42a00u, 0xed7b2de3u, 0x21d12d7du, 0x2b142464u, 0xe7be24fau, 0x69312319u, 0xa59b2387u,\n  0xf9766256u, 0x35dc62c8u, 0xbb53652bu, 0x77f965b5u, 0x7d3c6cacu, 0xb1966c32u, 0x3f196bd1u, 0xf3b36b4fu,\n  0x2a9379e3u, 0xe639797du, 0x68b67e9eu, 0xa41c7e00u, 0xaed97719u, 0x62737787u, 0xecfc7064u, 0x205670fau,\n  0x85cd537du, 0x496753e3u, 0xc7e85400u, 0x0b42549eu, 0x01875d87u, 0xcd2d5d19u, 0x43a25afau, 0x8f085a64u,\n  0x562848c8u, 0x9a824856u, 0x140d4fb5u, 0xd8a74f2bu, 0xd2624632u, 0x1ec846acu, 0x9047414fu, 0x5ced41d1u,\n  0x299dc2edu, 0xe537c273u, 0x6bb8c590u, 0xa712c50eu, 0xadd7cc17u, 0x617dcc89u, 0xeff2cb6au, 0x2358cbf4u,\n  0xfa78d958u, 0x36d2d9c6u, 0xb85dde25u, 0x74f7debbu, 0x7e32d7a2u, 0xb298d73cu, 0x3c17d0dfu, 0xf0bdd041u,\n  0x5526f3c6u, 0x998cf358u, 0x1703f4bbu, 0xdba9f425u, 0xd16cfd3cu, 0x1dc6fda2u, 0x9349fa41u, 0x5fe3fadfu,\n  0x86c3e873u, 0x4a69e8edu, 0xc4e6ef0eu, 0x084cef90u, 0x0289e689u, 0xce23e617u, 0x40ace1f4u, 0x8c06e16au,\n  0xd0eba0bbu, 0x1c41a025u, 0x92cea7c6u, 0x5e64a758u, 0x54a1ae41u, 0x980baedfu, 0x1684a93cu, 0xda2ea9a2u,\n  0x030ebb0eu, 0xcfa4bb90u, 0x412bbc73u, 0x8d81bcedu, 0x8744b5f4u, 0x4beeb56au, 0xc561b289u, 0x09cbb217u,\n  0xac509190u, 0x60fa910eu, 0xee7596edu, 0x22df9673u, 0x281a9f6au, 0xe4b09ff4u, 0x6a3f9817u, 0xa6959889u,\n  0x7fb58a25u, 0xb31f8abbu, 0x3d908d58u, 0xf13a8dc6u, 0xfbff84dfu, 0x37558441u, 0xb9da83a2u, 0x7570833cu,\n  0x533b85dau, 0x9f918544u, 0x111e82a7u, 0xddb48239u, 0xd7718b20u, 0x1bdb8bbeu, 0x95548c5du, 0x59fe8cc3u,\n  0x80de9e6fu, 0x4c749ef1u, 0xc2fb9912u, 0x0e51998cu, 0x04949095u, 0xc83e900bu, 0x46b197e8u, 0x8a1b9776u,\n  0x2f80b4f1u, 0xe32ab46fu, 0x6da5b38cu, 0xa10fb312u, 0xabcaba0bu, 0x6760ba95u, 0xe9efbd76u, 0x2545bde8u,\n  0xfc65af44u, 0x30cfafdau, 0xbe40a839u, 0x72eaa8a7u, 0x782fa1beu, 0xb485a120u, 0x3a0aa6c3u, 0xf6a0a65du,\n  0xaa4de78cu, 0x66e7e712u, 0xe868e0f1u, 0x24c2e06fu, 0x2e07e976u, 0xe2ade9e8u, 0x6c22ee0bu, 0xa088ee95u,\n  0x79a8fc39u, 0xb502fca7u, 0x3b8dfb44u, 0xf727fbdau, 0xfde2f2c3u, 0x3148f25du, 0xbfc7f5beu, 0x736df520u,\n  0xd6f6d6a7u, 0x1a5cd639u, 0x94d3d1dau, 0x5879d144u, 0x52bcd85du, 0x9e16d8c3u, 0x1099df20u, 0xdc33dfbeu,\n  0x0513cd12u, 0xc9b9cd8cu, 0x4736ca6fu, 0x8b9ccaf1u, 0x8159c3e8u, 0x4df3c376u, 0xc37cc495u, 0x0fd6c40bu,\n  0x7aa64737u, 0xb60c47a9u, 0x3883404au, 0xf42940d4u, 0xfeec49cdu, 0x32464953u, 0xbcc94eb0u, 0x70634e2eu,\n  0xa9435c82u, 0x65e95c1cu, 0xeb665bffu, 0x27cc5b61u, 0x2d095278u, 0xe1a352e6u, 0x6f2c5505u, 0xa386559bu,\n  0x061d761cu, 0xcab77682u, 0x44387161u, 0x889271ffu, 0x825778e6u, 0x4efd7878u, 0xc0727f9bu, 0x0cd87f05u,\n  0xd5f86da9u, 0x19526d37u, 0x97dd6ad4u, 0x5b776a4au, 0x51b26353u, 0x9d1863cdu, 0x1397642eu, 0xdf3d64b0u,\n  0x83d02561u, 0x4f7a25ffu, 0xc1f5221cu, 0x0d5f2282u, 0x079a2b9bu, 0xcb302b05u, 0x45bf2ce6u, 0x89152c78u,\n  0x50353ed4u, 0x9c9f3e4au, 0x121039a9u, 0xdeba3937u, 0xd47f302eu, 0x18d530b0u, 0x965a3753u, 0x5af037cdu,\n  0xff6b144au, 0x33c114d4u, 0xbd4e1337u, 0x71e413a9u, 0x7b211ab0u, 0xb78b1a2eu, 0x39041dcdu, 0xf5ae1d53u,\n  0x2c8e0fffu, 0xe0240f61u, 0x6eab0882u, 0xa201081cu, 0xa8c40105u, 0x646e019bu, 0xeae10678u, 0x264b06e6u\n};\n\n/* Computes the cyclic redundancy check as used by PNG chunks*/\nunsigned lodepng_crc32(const unsigned char* data, size_t length) {\n  /*Using the Slicing by Eight algorithm*/\n  unsigned r = 0xffffffffu;\n  while(length >= 8) {\n    r = lodepng_crc32_table7[(data[0] ^ (r & 0xffu))] ^\n        lodepng_crc32_table6[(data[1] ^ ((r >> 8) & 0xffu))] ^\n        lodepng_crc32_table5[(data[2] ^ ((r >> 16) & 0xffu))] ^\n        lodepng_crc32_table4[(data[3] ^ ((r >> 24) & 0xffu))] ^\n        lodepng_crc32_table3[data[4]] ^\n        lodepng_crc32_table2[data[5]] ^\n        lodepng_crc32_table1[data[6]] ^\n        lodepng_crc32_table0[data[7]];\n    data += 8;\n    length -= 8;\n  }\n  while(length--) {\n    r = lodepng_crc32_table0[(r ^ *data++) & 0xffu] ^ (r >> 8);\n  }\n  return r ^ 0xffffffffu;\n}\n#else /* LODEPNG_COMPILE_CRC */\n/*in this case, the function is only declared here, and must be defined externally\nso that it will be linked in.\n\nExample implementation that uses a much smaller lookup table for memory constrained cases:\n\nunsigned lodepng_crc32(const unsigned char* data, size_t length) {\n  unsigned r = 0xffffffffu;\n  static const unsigned table[16] = {\n    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,\n    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c\n  };\n  while(length--) {\n    r = table[(r ^ *data) & 0xf] ^ (r >> 4);\n    r = table[(r ^ (*data >> 4)) & 0xf] ^ (r >> 4);\n    data++;\n  }\n  return r ^ 0xffffffffu;\n}\n*/\nunsigned lodepng_crc32(const unsigned char* data, size_t length);\n#endif /* LODEPNG_COMPILE_CRC */\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Reading and writing PNG color channel bits                             / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,\nso LodePNGBitWriter and LodePNGBitReader can't be used for those. */\n\nstatic unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {\n  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);\n  ++(*bitpointer);\n  return result;\n}\n\n/* TODO: make this faster */\nstatic unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {\n  unsigned result = 0;\n  size_t i;\n  for(i = 0 ; i < nbits; ++i) {\n    result <<= 1u;\n    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);\n  }\n  return result;\n}\n\nstatic void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {\n  /*the current bit in bitstream may be 0 or 1 for this to work*/\n  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));\n  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));\n  ++(*bitpointer);\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / PNG chunks                                                             / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\nunsigned lodepng_chunk_length(const unsigned char* chunk) {\n  return lodepng_read32bitInt(chunk);\n}\n\nvoid lodepng_chunk_type(char type[5], const unsigned char* chunk) {\n  unsigned i;\n  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];\n  type[4] = 0; /*null termination char*/\n}\n\nunsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {\n  if(lodepng_strlen(type) != 4) return 0;\n  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);\n}\n\n/* chunk type name must exist only out of alphabetic characters a-z or A-Z */\nstatic unsigned char lodepng_chunk_type_name_valid(const unsigned char* chunk) {\n  unsigned i;\n  for(i = 0; i != 4; ++i) {\n    char c = (char)chunk[4 + i];\n    if(!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))) {\n      return 0; /* not valid */\n    }\n  }\n  return 1; /* valid */\n}\n\nunsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {\n  return((chunk[4] & 32) != 0);\n}\n\nunsigned char lodepng_chunk_private(const unsigned char* chunk) {\n  return((chunk[5] & 32) != 0);\n}\n\n/* this is an error if it is reserved: the third character must be uppercase in the PNG standard,\nlowercasing this character is reserved for possible future extension by the spec*/\nstatic unsigned char lodepng_chunk_reserved(const unsigned char* chunk) {\n  return((chunk[6] & 32) != 0);\n}\n\nunsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {\n  return((chunk[7] & 32) != 0);\n}\n\nunsigned char* lodepng_chunk_data(unsigned char* chunk) {\n  return &chunk[8];\n}\n\nconst unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {\n  return &chunk[8];\n}\n\nunsigned lodepng_chunk_check_crc(const unsigned char* chunk) {\n  unsigned length = lodepng_chunk_length(chunk);\n  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);\n  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/\n  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);\n  if(CRC != checksum) return 1;\n  else return 0;\n}\n\nvoid lodepng_chunk_generate_crc(unsigned char* chunk) {\n  unsigned length = lodepng_chunk_length(chunk);\n  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);\n  lodepng_set32bitInt(chunk + 8 + length, CRC);\n}\n\nunsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {\n  size_t available_size = (size_t)(end - chunk);\n  if(chunk >= end || available_size < 12) return end; /*too small to contain a chunk*/\n  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47\n    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {\n    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */\n    return chunk + 8;\n  } else {\n    size_t total_chunk_length;\n    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;\n    if(total_chunk_length > available_size) return end; /*outside of range*/\n    return chunk + total_chunk_length;\n  }\n}\n\nconst unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {\n  size_t available_size = (size_t)(end - chunk);\n  if(chunk >= end || available_size < 12) return end; /*too small to contain a chunk*/\n  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47\n    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {\n    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */\n    return chunk + 8;\n  } else {\n    size_t total_chunk_length;\n    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;\n    if(total_chunk_length > available_size) return end; /*outside of range*/\n    return chunk + total_chunk_length;\n  }\n}\n\nunsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {\n  for(;;) {\n    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */\n    if(lodepng_chunk_type_equals(chunk, type)) return chunk;\n    chunk = lodepng_chunk_next(chunk, end);\n  }\n}\n\nconst unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {\n  for(;;) {\n    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */\n    if(lodepng_chunk_type_equals(chunk, type)) return chunk;\n    chunk = lodepng_chunk_next_const(chunk, end);\n  }\n}\n\nunsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {\n  unsigned i;\n  size_t total_chunk_length, new_length;\n  unsigned char *chunk_start, *new_buffer;\n\n  if(!lodepng_chunk_type_name_valid(chunk)) {\n    return 121; /* invalid chunk type name */\n  }\n  if(lodepng_chunk_reserved(chunk)) {\n    return 122; /* invalid third lowercase character */\n  }\n\n  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;\n  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;\n\n  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);\n  if(!new_buffer) return 83; /*alloc fail*/\n  (*out) = new_buffer;\n  (*outsize) = new_length;\n  chunk_start = &(*out)[new_length - total_chunk_length];\n\n  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];\n\n  return 0;\n}\n\n/*Sets length and name and allocates the space for data and crc but does not\nset data or crc yet. Returns the start of the chunk in chunk. The start of\nthe data is at chunk + 8. To finalize chunk, add the data, then use\nlodepng_chunk_generate_crc */\nstatic unsigned lodepng_chunk_init(unsigned char** chunk,\n                                   ucvector* out,\n                                   size_t length, const char* type) {\n  size_t new_length = out->size;\n  if(lodepng_addofl(new_length, length, &new_length)) return 77;\n  if(lodepng_addofl(new_length, 12, &new_length)) return 77;\n  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/\n  *chunk = out->data + new_length - length - 12u;\n\n  /*1: length*/\n  lodepng_set32bitInt(*chunk, (unsigned)length);\n\n  /*2: chunk name (4 letters)*/\n  lodepng_memcpy(*chunk + 4, type, 4);\n\n  return 0;\n}\n\n/* like lodepng_chunk_create but with custom allocsize */\nstatic unsigned lodepng_chunk_createv(ucvector* out,\n                                      size_t length, const char* type, const unsigned char* data) {\n  unsigned char* chunk;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));\n\n  /*3: the data*/\n  lodepng_memcpy(chunk + 8, data, length);\n\n  /*4: CRC (of the chunkname characters and the data)*/\n  lodepng_chunk_generate_crc(chunk);\n\n  return 0;\n}\n\nunsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,\n                              size_t length, const char* type, const unsigned char* data) {\n  ucvector v = ucvector_init(*out, *outsize);\n  unsigned error = lodepng_chunk_createv(&v, length, type, data);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Color types, channels, bits                                            / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.\nReturn value is a LodePNG error code.*/\nstatic unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {\n  switch(colortype) {\n    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;\n    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;\n    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;\n    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;\n    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;\n    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */\n    default: return 31; /* invalid color type */\n  }\n  return 0; /*allowed color type / bits combination*/\n}\n\nstatic unsigned getNumColorChannels(LodePNGColorType colortype) {\n  switch(colortype) {\n    case LCT_GREY: return 1;\n    case LCT_RGB: return 3;\n    case LCT_PALETTE: return 1;\n    case LCT_GREY_ALPHA: return 2;\n    case LCT_RGBA: return 4;\n    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */\n    default: return 0; /*invalid color type*/\n  }\n}\n\nstatic unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {\n  /*bits per pixel is amount of channels * bits per channel*/\n  return getNumColorChannels(colortype) * bitdepth;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\nvoid lodepng_color_mode_init(LodePNGColorMode* info) {\n  info->key_defined = 0;\n  info->key_r = info->key_g = info->key_b = 0;\n  info->colortype = LCT_RGBA;\n  info->bitdepth = 8;\n  info->palette = 0;\n  info->palettesize = 0;\n}\n\n/*allocates palette memory if needed, and initializes all colors to black*/\nstatic void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {\n  size_t i;\n  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/\n  /*the palette must have room for up to 256 colors with 4 bytes each.*/\n  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);\n  if(!info->palette) return; /*alloc fail*/\n  for(i = 0; i != 256; ++i) {\n    /*Initialize all unused colors with black, the value used for invalid palette indices.\n    This is an error according to the PNG spec, but common PNG decoders make it black instead.\n    That makes color conversion slightly faster due to no error handling needed.*/\n    info->palette[i * 4 + 0] = 0;\n    info->palette[i * 4 + 1] = 0;\n    info->palette[i * 4 + 2] = 0;\n    info->palette[i * 4 + 3] = 255;\n  }\n}\n\nvoid lodepng_color_mode_cleanup(LodePNGColorMode* info) {\n  lodepng_palette_clear(info);\n}\n\nunsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {\n  lodepng_color_mode_cleanup(dest);\n  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));\n  if(source->palette) {\n    dest->palette = (unsigned char*)lodepng_malloc(1024);\n    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/\n    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);\n  }\n  return 0;\n}\n\nLodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {\n  LodePNGColorMode result;\n  lodepng_color_mode_init(&result);\n  result.colortype = colortype;\n  result.bitdepth = bitdepth;\n  return result;\n}\n\nstatic int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {\n  size_t i;\n  if(a->colortype != b->colortype) return 0;\n  if(a->bitdepth != b->bitdepth) return 0;\n  if(a->key_defined != b->key_defined) return 0;\n  if(a->key_defined) {\n    if(a->key_r != b->key_r) return 0;\n    if(a->key_g != b->key_g) return 0;\n    if(a->key_b != b->key_b) return 0;\n  }\n  if(a->palettesize != b->palettesize) return 0;\n  for(i = 0; i != a->palettesize * 4; ++i) {\n    if(a->palette[i] != b->palette[i]) return 0;\n  }\n  return 1;\n}\n\nvoid lodepng_palette_clear(LodePNGColorMode* info) {\n  if(info->palette) lodepng_free(info->palette);\n  info->palette = 0;\n  info->palettesize = 0;\n}\n\nunsigned lodepng_palette_add(LodePNGColorMode* info,\n                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n  if(!info->palette) /*allocate palette if empty*/ {\n    lodepng_color_mode_alloc_palette(info);\n    if(!info->palette) return 83; /*alloc fail*/\n  }\n  if(info->palettesize >= 256) {\n    return 108; /*too many palette values*/\n  }\n  info->palette[4 * info->palettesize + 0] = r;\n  info->palette[4 * info->palettesize + 1] = g;\n  info->palette[4 * info->palettesize + 2] = b;\n  info->palette[4 * info->palettesize + 3] = a;\n  ++info->palettesize;\n  return 0;\n}\n\n/*calculate bits per pixel out of colortype and bitdepth*/\nunsigned lodepng_get_bpp(const LodePNGColorMode* info) {\n  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);\n}\n\nunsigned lodepng_get_channels(const LodePNGColorMode* info) {\n  return getNumColorChannels(info->colortype);\n}\n\nunsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {\n  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;\n}\n\nunsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {\n  return (info->colortype & 4) != 0; /*4 or 6*/\n}\n\nunsigned lodepng_is_palette_type(const LodePNGColorMode* info) {\n  return info->colortype == LCT_PALETTE;\n}\n\nunsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {\n  size_t i;\n  for(i = 0; i != info->palettesize; ++i) {\n    if(info->palette[i * 4 + 3] < 255) return 1;\n  }\n  return 0;\n}\n\nunsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {\n  return info->key_defined\n      || lodepng_is_alpha_type(info)\n      || lodepng_has_palette_alpha(info);\n}\n\nstatic size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {\n  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);\n  size_t n = (size_t)w * (size_t)h;\n  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;\n}\n\nsize_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {\n  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);\n}\n\n\n#ifdef LODEPNG_COMPILE_PNG\n\n/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,\nand in addition has one extra byte per line: the filter byte. So this gives a larger\nresult than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */\nstatic size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {\n  /* + 1 for the filter byte, and possibly plus padding bits per line. */\n  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */\n  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;\n  return (size_t)h * line;\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n/*Safely checks whether size_t overflow can be caused due to amount of pixels.\nThis check is overcautious rather than precise. If this check indicates no overflow,\nyou can safely compute in a size_t (but not an unsigned):\n-(size_t)w * (size_t)h * 8\n-amount of bytes in IDAT (including filter, padding and Adam7 bytes)\n-amount of bytes in raw color model\nReturns 1 if overflow possible, 0 if not.\n*/\nstatic int lodepng_pixel_overflow(unsigned w, unsigned h,\n                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {\n  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));\n  size_t numpixels, total;\n  size_t line; /* bytes per line in worst case */\n\n  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;\n  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */\n\n  /* Bytes per scanline with the expression \"(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u\" */\n  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;\n  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;\n\n  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */\n  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */\n\n  return 0; /* no overflow */\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n#endif /*LODEPNG_COMPILE_PNG*/\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n\nstatic void LodePNGUnknownChunks_init(LodePNGInfo* info) {\n  unsigned i;\n  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;\n  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;\n}\n\nstatic void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {\n  unsigned i;\n  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);\n}\n\nstatic unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {\n  unsigned i;\n\n  LodePNGUnknownChunks_cleanup(dest);\n\n  for(i = 0; i != 3; ++i) {\n    size_t j;\n    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];\n    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);\n    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/\n    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {\n      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];\n    }\n  }\n\n  return 0;\n}\n\n/******************************************************************************/\n\nstatic void LodePNGText_init(LodePNGInfo* info) {\n  info->text_num = 0;\n  info->text_keys = NULL;\n  info->text_strings = NULL;\n}\n\nstatic void LodePNGText_cleanup(LodePNGInfo* info) {\n  size_t i;\n  for(i = 0; i != info->text_num; ++i) {\n    string_cleanup(&info->text_keys[i]);\n    string_cleanup(&info->text_strings[i]);\n  }\n  lodepng_free(info->text_keys);\n  lodepng_free(info->text_strings);\n}\n\nstatic unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {\n  size_t i = 0;\n  dest->text_keys = NULL;\n  dest->text_strings = NULL;\n  dest->text_num = 0;\n  for(i = 0; i != source->text_num; ++i) {\n    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));\n  }\n  return 0;\n}\n\nstatic unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {\n  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));\n  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));\n\n  if(new_keys) info->text_keys = new_keys;\n  if(new_strings) info->text_strings = new_strings;\n\n  if(!new_keys || !new_strings) return 83; /*alloc fail*/\n\n  ++info->text_num;\n  info->text_keys[info->text_num - 1] = alloc_string(key);\n  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);\n  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/\n\n  return 0;\n}\n\nunsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {\n  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));\n}\n\nvoid lodepng_clear_text(LodePNGInfo* info) {\n  LodePNGText_cleanup(info);\n}\n\n/******************************************************************************/\n\nstatic void LodePNGIText_init(LodePNGInfo* info) {\n  info->itext_num = 0;\n  info->itext_keys = NULL;\n  info->itext_langtags = NULL;\n  info->itext_transkeys = NULL;\n  info->itext_strings = NULL;\n}\n\nstatic void LodePNGIText_cleanup(LodePNGInfo* info) {\n  size_t i;\n  for(i = 0; i != info->itext_num; ++i) {\n    string_cleanup(&info->itext_keys[i]);\n    string_cleanup(&info->itext_langtags[i]);\n    string_cleanup(&info->itext_transkeys[i]);\n    string_cleanup(&info->itext_strings[i]);\n  }\n  lodepng_free(info->itext_keys);\n  lodepng_free(info->itext_langtags);\n  lodepng_free(info->itext_transkeys);\n  lodepng_free(info->itext_strings);\n}\n\nstatic unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {\n  size_t i = 0;\n  dest->itext_keys = NULL;\n  dest->itext_langtags = NULL;\n  dest->itext_transkeys = NULL;\n  dest->itext_strings = NULL;\n  dest->itext_num = 0;\n  for(i = 0; i != source->itext_num; ++i) {\n    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],\n                                        source->itext_transkeys[i], source->itext_strings[i]));\n  }\n  return 0;\n}\n\nvoid lodepng_clear_itext(LodePNGInfo* info) {\n  LodePNGIText_cleanup(info);\n}\n\nstatic unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,\n                                        const char* transkey, const char* str, size_t size) {\n  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));\n  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));\n  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));\n  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));\n\n  if(new_keys) info->itext_keys = new_keys;\n  if(new_langtags) info->itext_langtags = new_langtags;\n  if(new_transkeys) info->itext_transkeys = new_transkeys;\n  if(new_strings) info->itext_strings = new_strings;\n\n  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/\n\n  ++info->itext_num;\n\n  info->itext_keys[info->itext_num - 1] = alloc_string(key);\n  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);\n  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);\n  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);\n\n  return 0;\n}\n\nunsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,\n                           const char* transkey, const char* str) {\n  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));\n}\n\nunsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {\n  if(info->iccp_defined) lodepng_clear_icc(info);\n\n  if(profile_size == 0) return 100; /*invalid ICC profile size*/\n\n  info->iccp_name = alloc_string(name);\n  if(!info->iccp_name) return 83; /*alloc fail*/\n\n  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);\n  if(!info->iccp_profile) {\n    lodepng_free(info->iccp_name);\n    return 83; /*alloc fail*/\n  }\n\n  lodepng_memcpy(info->iccp_profile, profile, profile_size);\n  info->iccp_profile_size = profile_size;\n  info->iccp_defined = 1;\n\n  return 0; /*ok*/\n}\n\nvoid lodepng_clear_icc(LodePNGInfo* info) {\n  string_cleanup(&info->iccp_name);\n  lodepng_free(info->iccp_profile);\n  info->iccp_profile = NULL;\n  info->iccp_profile_size = 0;\n  info->iccp_defined = 0;\n}\n\nunsigned lodepng_set_exif(LodePNGInfo* info, const unsigned char* exif, unsigned exif_size) {\n  if(info->exif_defined) lodepng_clear_exif(info);\n  info->exif = (unsigned char*)lodepng_malloc(exif_size);\n\n  if(!info->exif) return 83; /*alloc fail*/\n\n  lodepng_memcpy(info->exif, exif, exif_size);\n  info->exif_size = exif_size;\n  info->exif_defined = 1;\n\n  return 0; /*ok*/\n}\n\nvoid lodepng_clear_exif(LodePNGInfo* info) {\n  lodepng_free(info->exif);\n  info->exif = NULL;\n  info->exif_size = 0;\n  info->exif_defined = 0;\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\nvoid lodepng_info_init(LodePNGInfo* info) {\n  lodepng_color_mode_init(&info->color);\n  info->interlace_method = 0;\n  info->compression_method = 0;\n  info->filter_method = 0;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  info->background_defined = 0;\n  info->background_r = info->background_g = info->background_b = 0;\n\n  LodePNGText_init(info);\n  LodePNGIText_init(info);\n\n  info->time_defined = 0;\n  info->phys_defined = 0;\n\n  info->gama_defined = 0;\n  info->chrm_defined = 0;\n  info->srgb_defined = 0;\n  info->iccp_defined = 0;\n  info->iccp_name = NULL;\n  info->iccp_profile = NULL;\n  info->cicp_defined = 0;\n  info->cicp_color_primaries = 0;\n  info->cicp_transfer_function = 0;\n  info->cicp_matrix_coefficients = 0;\n  info->cicp_video_full_range_flag = 0;\n  info->mdcv_defined = 0;\n  info->mdcv_red_x = 0;\n  info->mdcv_red_y = 0;\n  info->mdcv_green_x = 0;\n  info->mdcv_green_y = 0;\n  info->mdcv_blue_x = 0;\n  info->mdcv_blue_y = 0;\n  info->mdcv_white_x = 0;\n  info->mdcv_white_y = 0;\n  info->mdcv_max_luminance = 0;\n  info->mdcv_min_luminance = 0;\n  info->clli_defined = 0;\n  info->clli_max_cll = 0;\n  info->clli_max_fall = 0;\n\n  info->exif_defined = 0;\n  info->exif = NULL;\n  info->exif_size = 0;\n\n  info->sbit_defined = 0;\n  info->sbit_r = info->sbit_g = info->sbit_b = info->sbit_a = 0;\n\n  LodePNGUnknownChunks_init(info);\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n}\n\nvoid lodepng_info_cleanup(LodePNGInfo* info) {\n  lodepng_color_mode_cleanup(&info->color);\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  LodePNGText_cleanup(info);\n  LodePNGIText_cleanup(info);\n\n  lodepng_clear_icc(info);\n  lodepng_clear_exif(info);\n\n  LodePNGUnknownChunks_cleanup(info);\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n}\n\nunsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {\n  lodepng_info_cleanup(dest);\n  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));\n  lodepng_color_mode_init(&dest->color);\n  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));\n  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));\n  if(source->iccp_defined) {\n    dest->iccp_defined = 0; /*the memcpy above set this to 1 while it shouldn't*/\n    CERROR_TRY_RETURN(lodepng_set_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));\n  }\n  if(source->exif_defined) {\n    dest->exif_defined = 0; /*the memcpy above set this to 1 while it shouldn't*/\n    CERROR_TRY_RETURN(lodepng_set_exif(dest, source->exif, source->exif_size));\n  }\n\n  LodePNGUnknownChunks_init(dest);\n  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  return 0;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/\nstatic void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {\n  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/\n  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/\n  unsigned p = index & m;\n  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/\n  in = in << (bits * (m - p));\n  if(p == 0) out[index * bits / 8u] = in;\n  else out[index * bits / 8u] |= in;\n}\n\ntypedef struct ColorTree ColorTree;\n\n/*\nOne node of a color tree\nThis is the data structure used to count the number of unique colors and to get a palette\nindex for a color. It's like an octree, but because the alpha channel is used too, each\nnode has 16 instead of 8 children.\n*/\nstruct ColorTree {\n  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/\n  int index; /*the payload. Only has a meaningful value if this is in the last level*/\n};\n\nstatic void color_tree_init(ColorTree* tree) {\n  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));\n  tree->index = -1;\n}\n\nstatic void color_tree_cleanup(ColorTree* tree) {\n  int i;\n  for(i = 0; i != 16; ++i) {\n    if(tree->children[i]) {\n      color_tree_cleanup(tree->children[i]);\n      lodepng_free(tree->children[i]);\n    }\n  }\n}\n\n/*returns -1 if color not present, its index otherwise*/\nstatic int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n  int bit = 0;\n  for(bit = 0; bit < 8; ++bit) {\n    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);\n    if(!tree->children[i]) return -1;\n    else tree = tree->children[i];\n  }\n  return tree ? tree->index : -1;\n}\n\n#ifdef LODEPNG_COMPILE_ENCODER\nstatic int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n  return color_tree_get(tree, r, g, b, a) >= 0;\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n/*color is not allowed to already exist.\nIndex should be >= 0 (it's signed to be compatible with using -1 for \"doesn't exist\")\nReturns error code, or 0 if ok*/\nstatic unsigned color_tree_add(ColorTree* tree,\n                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {\n  int bit;\n  for(bit = 0; bit < 8; ++bit) {\n    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);\n    if(!tree->children[i]) {\n      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));\n      if(!tree->children[i]) return 83; /*alloc fail*/\n      color_tree_init(tree->children[i]);\n    }\n    tree = tree->children[i];\n  }\n  tree->index = (int)index;\n  return 0;\n}\n\n/*put a pixel, given its RGBA color, into image of any color type*/\nstatic unsigned rgba8ToPixel(unsigned char* out, size_t i,\n                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,\n                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n  if(mode->colortype == LCT_GREY) {\n    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/\n    if(mode->bitdepth == 8) out[i] = gray;\n    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;\n    else {\n      /*take the most significant bits of gray*/\n      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);\n      addColorBits(out, i, mode->bitdepth, gray);\n    }\n  } else if(mode->colortype == LCT_RGB) {\n    if(mode->bitdepth == 8) {\n      out[i * 3 + 0] = r;\n      out[i * 3 + 1] = g;\n      out[i * 3 + 2] = b;\n    } else {\n      out[i * 6 + 0] = out[i * 6 + 1] = r;\n      out[i * 6 + 2] = out[i * 6 + 3] = g;\n      out[i * 6 + 4] = out[i * 6 + 5] = b;\n    }\n  } else if(mode->colortype == LCT_PALETTE) {\n    int index = color_tree_get(tree, r, g, b, a);\n    if(index < 0) return 82; /*color not in palette*/\n    if(mode->bitdepth == 8) out[i] = index;\n    else addColorBits(out, i, mode->bitdepth, (unsigned)index);\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/\n    if(mode->bitdepth == 8) {\n      out[i * 2 + 0] = gray;\n      out[i * 2 + 1] = a;\n    } else if(mode->bitdepth == 16) {\n      out[i * 4 + 0] = out[i * 4 + 1] = gray;\n      out[i * 4 + 2] = out[i * 4 + 3] = a;\n    }\n  } else if(mode->colortype == LCT_RGBA) {\n    if(mode->bitdepth == 8) {\n      out[i * 4 + 0] = r;\n      out[i * 4 + 1] = g;\n      out[i * 4 + 2] = b;\n      out[i * 4 + 3] = a;\n    } else {\n      out[i * 8 + 0] = out[i * 8 + 1] = r;\n      out[i * 8 + 2] = out[i * 8 + 3] = g;\n      out[i * 8 + 4] = out[i * 8 + 5] = b;\n      out[i * 8 + 6] = out[i * 8 + 7] = a;\n    }\n  }\n\n  return 0; /*no error*/\n}\n\n/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/\nstatic void rgba16ToPixel(unsigned char* out, size_t i,\n                         const LodePNGColorMode* mode,\n                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {\n  if(mode->colortype == LCT_GREY) {\n    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/\n    out[i * 2 + 0] = (gray >> 8) & 255;\n    out[i * 2 + 1] = gray & 255;\n  } else if(mode->colortype == LCT_RGB) {\n    out[i * 6 + 0] = (r >> 8) & 255;\n    out[i * 6 + 1] = r & 255;\n    out[i * 6 + 2] = (g >> 8) & 255;\n    out[i * 6 + 3] = g & 255;\n    out[i * 6 + 4] = (b >> 8) & 255;\n    out[i * 6 + 5] = b & 255;\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/\n    out[i * 4 + 0] = (gray >> 8) & 255;\n    out[i * 4 + 1] = gray & 255;\n    out[i * 4 + 2] = (a >> 8) & 255;\n    out[i * 4 + 3] = a & 255;\n  } else if(mode->colortype == LCT_RGBA) {\n    out[i * 8 + 0] = (r >> 8) & 255;\n    out[i * 8 + 1] = r & 255;\n    out[i * 8 + 2] = (g >> 8) & 255;\n    out[i * 8 + 3] = g & 255;\n    out[i * 8 + 4] = (b >> 8) & 255;\n    out[i * 8 + 5] = b & 255;\n    out[i * 8 + 6] = (a >> 8) & 255;\n    out[i * 8 + 7] = a & 255;\n  }\n}\n\n/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/\nstatic void getPixelColorRGBA8(unsigned char* r, unsigned char* g,\n                               unsigned char* b, unsigned char* a,\n                               const unsigned char* in, size_t i,\n                               const LodePNGColorMode* mode) {\n  if(mode->colortype == LCT_GREY) {\n    if(mode->bitdepth == 8) {\n      *r = *g = *b = in[i];\n      if(mode->key_defined && *r == mode->key_r) *a = 0;\n      else *a = 255;\n    } else if(mode->bitdepth == 16) {\n      *r = *g = *b = in[i * 2 + 0];\n      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\n      else *a = 255;\n    } else {\n      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/\n      size_t j = i * mode->bitdepth;\n      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);\n      *r = *g = *b = (value * 255) / highest;\n      if(mode->key_defined && value == mode->key_r) *a = 0;\n      else *a = 255;\n    }\n  } else if(mode->colortype == LCT_RGB) {\n    if(mode->bitdepth == 8) {\n      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];\n      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;\n      else *a = 255;\n    } else {\n      *r = in[i * 6 + 0];\n      *g = in[i * 6 + 2];\n      *b = in[i * 6 + 4];\n      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\n      else *a = 255;\n    }\n  } else if(mode->colortype == LCT_PALETTE) {\n    unsigned index;\n    if(mode->bitdepth == 8) index = in[i];\n    else {\n      size_t j = i * mode->bitdepth;\n      index = readBitsFromReversedStream(&j, in, mode->bitdepth);\n    }\n    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/\n    *r = mode->palette[index * 4 + 0];\n    *g = mode->palette[index * 4 + 1];\n    *b = mode->palette[index * 4 + 2];\n    *a = mode->palette[index * 4 + 3];\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    if(mode->bitdepth == 8) {\n      *r = *g = *b = in[i * 2 + 0];\n      *a = in[i * 2 + 1];\n    } else {\n      *r = *g = *b = in[i * 4 + 0];\n      *a = in[i * 4 + 2];\n    }\n  } else if(mode->colortype == LCT_RGBA) {\n    if(mode->bitdepth == 8) {\n      *r = in[i * 4 + 0];\n      *g = in[i * 4 + 1];\n      *b = in[i * 4 + 2];\n      *a = in[i * 4 + 3];\n    } else {\n      *r = in[i * 8 + 0];\n      *g = in[i * 8 + 2];\n      *b = in[i * 8 + 4];\n      *a = in[i * 8 + 6];\n    }\n  }\n}\n\n/*Similar to getPixelColorRGBA8, but with all the for loops inside of the color\nmode test cases, optimized to convert the colors much faster, when converting\nto the common case of RGBA with 8 bit per channel. buffer must be RGBA with\nenough memory.*/\nstatic void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,\n                                const unsigned char* LODEPNG_RESTRICT in,\n                                const LodePNGColorMode* mode) {\n  unsigned num_channels = 4;\n  size_t i;\n  if(mode->colortype == LCT_GREY) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i];\n        buffer[3] = 255;\n      }\n      if(mode->key_defined) {\n        buffer -= numpixels * num_channels;\n        for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n          if(buffer[0] == mode->key_r) buffer[3] = 0;\n        }\n      }\n    } else if(mode->bitdepth == 16) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2];\n        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;\n      }\n    } else {\n      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/\n      size_t j = 0;\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);\n        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;\n        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;\n      }\n    }\n  } else if(mode->colortype == LCT_RGB) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        lodepng_memcpy(buffer, &in[i * 3], 3);\n        buffer[3] = 255;\n      }\n      if(mode->key_defined) {\n        buffer -= numpixels * num_channels;\n        for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;\n        }\n      }\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = in[i * 6 + 0];\n        buffer[1] = in[i * 6 + 2];\n        buffer[2] = in[i * 6 + 4];\n        buffer[3] = mode->key_defined\n           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;\n      }\n    }\n  } else if(mode->colortype == LCT_PALETTE) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned index = in[i];\n        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/\n        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);\n      }\n    } else {\n      size_t j = 0;\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);\n        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/\n        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);\n      }\n    }\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];\n        buffer[3] = in[i * 2 + 1];\n      }\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];\n        buffer[3] = in[i * 4 + 2];\n      }\n    }\n  } else if(mode->colortype == LCT_RGBA) {\n    if(mode->bitdepth == 8) {\n      lodepng_memcpy(buffer, in, numpixels * 4);\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = in[i * 8 + 0];\n        buffer[1] = in[i * 8 + 2];\n        buffer[2] = in[i * 8 + 4];\n        buffer[3] = in[i * 8 + 6];\n      }\n    }\n  }\n}\n\n/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/\nstatic void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,\n                               const unsigned char* LODEPNG_RESTRICT in,\n                               const LodePNGColorMode* mode) {\n  const unsigned num_channels = 3;\n  size_t i;\n  if(mode->colortype == LCT_GREY) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i];\n      }\n    } else if(mode->bitdepth == 16) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2];\n      }\n    } else {\n      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/\n      size_t j = 0;\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);\n        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;\n      }\n    }\n  } else if(mode->colortype == LCT_RGB) {\n    if(mode->bitdepth == 8) {\n      lodepng_memcpy(buffer, in, numpixels * 3);\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = in[i * 6 + 0];\n        buffer[1] = in[i * 6 + 2];\n        buffer[2] = in[i * 6 + 4];\n      }\n    }\n  } else if(mode->colortype == LCT_PALETTE) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned index = in[i];\n        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/\n        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);\n      }\n    } else {\n      size_t j = 0;\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);\n        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/\n        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);\n      }\n    }\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];\n      }\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];\n      }\n    }\n  } else if(mode->colortype == LCT_RGBA) {\n    if(mode->bitdepth == 8) {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        lodepng_memcpy(buffer, &in[i * 4], 3);\n      }\n    } else {\n      for(i = 0; i != numpixels; ++i, buffer += num_channels) {\n        buffer[0] = in[i * 8 + 0];\n        buffer[1] = in[i * 8 + 2];\n        buffer[2] = in[i * 8 + 4];\n      }\n    }\n  }\n}\n\n/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with\ngiven color type, but the given color type must be 16-bit itself.*/\nstatic void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,\n                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {\n  if(mode->colortype == LCT_GREY) {\n    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];\n    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\n    else *a = 65535;\n  } else if(mode->colortype == LCT_RGB) {\n    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];\n    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];\n    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];\n    if(mode->key_defined\n       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\n    else *a = 65535;\n  } else if(mode->colortype == LCT_GREY_ALPHA) {\n    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];\n    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];\n  } else if(mode->colortype == LCT_RGBA) {\n    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];\n    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];\n    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];\n    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];\n  }\n}\n\nunsigned lodepng_convert(unsigned char* out, const unsigned char* in,\n                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,\n                         unsigned w, unsigned h) {\n  size_t i;\n  ColorTree tree;\n  size_t numpixels = (size_t)w * (size_t)h;\n  unsigned error = 0;\n\n  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {\n    return 107; /* error: must provide palette if input mode is palette */\n  }\n\n  if(lodepng_color_mode_equal(mode_out, mode_in)) {\n    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);\n    lodepng_memcpy(out, in, numbytes);\n    return 0;\n  }\n\n  if(mode_out->colortype == LCT_PALETTE) {\n    size_t palettesize = mode_out->palettesize;\n    const unsigned char* palette = mode_out->palette;\n    size_t palsize = (size_t)1u << mode_out->bitdepth;\n    /*if the user specified output palette but did not give the values, assume\n    they want the values of the input color type (assuming that one is palette).\n    Note that we never create a new palette ourselves.*/\n    if(palettesize == 0) {\n      palettesize = mode_in->palettesize;\n      palette = mode_in->palette;\n      /*if the input was also palette with same bitdepth, then the color types are also\n      equal, so copy literally. This to preserve the exact indices that were in the PNG\n      even in case there are duplicate colors in the palette.*/\n      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {\n        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);\n        lodepng_memcpy(out, in, numbytes);\n        return 0;\n      }\n    }\n    if(palettesize < palsize) palsize = palettesize;\n    color_tree_init(&tree);\n    for(i = 0; i != palsize; ++i) {\n      const unsigned char* p = &palette[i * 4];\n      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);\n      if(error) break;\n    }\n  }\n\n  if(!error) {\n    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {\n      for(i = 0; i != numpixels; ++i) {\n        unsigned short r = 0, g = 0, b = 0, a = 0;\n        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);\n        rgba16ToPixel(out, i, mode_out, r, g, b, a);\n      }\n    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {\n      getPixelColorsRGBA8(out, numpixels, in, mode_in);\n    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {\n      getPixelColorsRGB8(out, numpixels, in, mode_in);\n    } else {\n      unsigned char r = 0, g = 0, b = 0, a = 0;\n      for(i = 0; i != numpixels; ++i) {\n        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);\n        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);\n        if(error) break;\n      }\n    }\n  }\n\n  if(mode_out->colortype == LCT_PALETTE) {\n    color_tree_cleanup(&tree);\n  }\n\n  return error;\n}\n\n\n/* Converts a single rgb color without alpha from one type to another, color bits truncated to\ntheir bitdepth. In case of single channel (gray or palette), only the r channel is used. Slow\nfunction, do not use to process all pixels of an image. Alpha channel not supported on purpose:\nthis is for bKGD, supporting alpha may prevent it from finding a color in the palette, from the\nspecification it looks like bKGD should ignore the alpha values of the palette since it can use\nany palette index but doesn't have an alpha channel. Idem with ignoring color key. */\nunsigned lodepng_convert_rgb(\n    unsigned* r_out, unsigned* g_out, unsigned* b_out,\n    unsigned r_in, unsigned g_in, unsigned b_in,\n    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {\n  unsigned r = 0, g = 0, b = 0;\n  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/\n  unsigned shift = 16 - mode_out->bitdepth;\n\n  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {\n    r = g = b = r_in * mul;\n  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {\n    r = r_in * mul;\n    g = g_in * mul;\n    b = b_in * mul;\n  } else if(mode_in->colortype == LCT_PALETTE) {\n    if(r_in >= mode_in->palettesize) return 82;\n    r = mode_in->palette[r_in * 4 + 0] * 257u;\n    g = mode_in->palette[r_in * 4 + 1] * 257u;\n    b = mode_in->palette[r_in * 4 + 2] * 257u;\n  } else {\n    return 31;\n  }\n\n  /* now convert to output format */\n  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {\n    *r_out = r >> shift ;\n  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {\n    *r_out = r >> shift ;\n    *g_out = g >> shift ;\n    *b_out = b >> shift ;\n  } else if(mode_out->colortype == LCT_PALETTE) {\n    unsigned i;\n    /* a 16-bit color cannot be in the palette */\n    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;\n    for(i = 0; i < mode_out->palettesize; i++) {\n      unsigned j = i * 4;\n      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&\n          (b >> 8) == mode_out->palette[j + 2]) {\n        *r_out = i;\n        return 0;\n      }\n    }\n    return 82;\n  } else {\n    return 31;\n  }\n\n  return 0;\n}\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\nvoid lodepng_color_stats_init(LodePNGColorStats* stats) {\n  /*stats*/\n  stats->colored = 0;\n  stats->key = 0;\n  stats->key_r = stats->key_g = stats->key_b = 0;\n  stats->alpha = 0;\n  stats->numcolors = 0;\n  stats->bits = 1;\n  stats->numpixels = 0;\n  /*settings*/\n  stats->allow_palette = 1;\n  stats->allow_greyscale = 1;\n}\n\n/*function used for debug purposes with C++*/\n/*void printColorStats(LodePNGColorStats* p) {\n  std::cout << \"colored: \" << (int)p->colored << \", \";\n  std::cout << \"key: \" << (int)p->key << \", \";\n  std::cout << \"key_r: \" << (int)p->key_r << \", \";\n  std::cout << \"key_g: \" << (int)p->key_g << \", \";\n  std::cout << \"key_b: \" << (int)p->key_b << \", \";\n  std::cout << \"alpha: \" << (int)p->alpha << \", \";\n  std::cout << \"numcolors: \" << (int)p->numcolors << \", \";\n  std::cout << \"bits: \" << (int)p->bits << std::endl;\n}*/\n\n/*Returns how many bits needed to represent given value (max 8 bit)*/\nstatic unsigned getValueRequiredBits(unsigned char value) {\n  if(value == 0 || value == 255) return 1;\n  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/\n  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;\n  return 8;\n}\n\n/*stats must already have been inited. */\nunsigned lodepng_compute_color_stats(LodePNGColorStats* stats,\n                                     const unsigned char* in, unsigned w, unsigned h,\n                                     const LodePNGColorMode* mode_in) {\n  size_t i;\n  ColorTree tree;\n  size_t numpixels = (size_t)w * (size_t)h;\n  unsigned error = 0;\n\n  /* mark things as done already if it would be impossible to have a more expensive case */\n  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;\n  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;\n  unsigned numcolors_done = 0;\n  unsigned bpp = lodepng_get_bpp(mode_in);\n  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;\n  unsigned sixteen = 0; /* whether the input image is 16 bit */\n  unsigned maxnumcolors = 257;\n  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));\n\n  stats->numpixels += numpixels;\n\n  /*if palette not allowed, no need to compute numcolors*/\n  if(!stats->allow_palette) numcolors_done = 1;\n\n  color_tree_init(&tree);\n\n  /*If the stats was already filled in from previous data, fill its palette in tree\n  and mark things as done already if we know they are the most expensive case already*/\n  if(stats->alpha) alpha_done = 1;\n  if(stats->colored) colored_done = 1;\n  if(stats->bits == 16) numcolors_done = 1;\n  if(stats->bits >= bpp) bits_done = 1;\n  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;\n\n  if(!numcolors_done) {\n    for(i = 0; i < stats->numcolors; i++) {\n      const unsigned char* color = &stats->palette[i * 4];\n      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], (unsigned)i);\n      if(error) goto cleanup;\n    }\n  }\n\n  /*Check if the 16-bit input is truly 16-bit*/\n  if(mode_in->bitdepth == 16 && !sixteen) {\n    unsigned short r = 0, g = 0, b = 0, a = 0;\n    for(i = 0; i != numpixels; ++i) {\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);\n      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||\n         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {\n        stats->bits = 16;\n        sixteen = 1;\n        bits_done = 1;\n        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/\n        break;\n      }\n    }\n  }\n\n  if(sixteen) {\n    unsigned short r = 0, g = 0, b = 0, a = 0;\n\n    for(i = 0; i != numpixels; ++i) {\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);\n\n      if(!colored_done && (r != g || r != b)) {\n        stats->colored = 1;\n        colored_done = 1;\n      }\n\n      if(!alpha_done) {\n        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);\n        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n        } else if(a == 0 && !stats->alpha && !stats->key) {\n          stats->key = 1;\n          stats->key_r = r;\n          stats->key_g = g;\n          stats->key_b = b;\n        } else if(a == 65535 && stats->key && matchkey) {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n        }\n      }\n      if(alpha_done && numcolors_done && colored_done && bits_done) break;\n    }\n\n    if(stats->key && !stats->alpha) {\n      for(i = 0; i != numpixels; ++i) {\n        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);\n        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n        }\n      }\n    }\n  } else /* < 16-bit */ {\n    unsigned char r = 0, g = 0, b = 0, a = 0;\n    unsigned char pr = 0, pg = 0, pb = 0, pa = 0;\n    for(i = 0; i != numpixels; ++i) {\n      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);\n\n      /*skip if color same as before, this speeds up large non-photographic\n      images with many same colors by avoiding 'color_tree_has' below */\n      if(i != 0 && r == pr && g == pg && b == pb && a == pa) continue;\n      pr = r;\n      pg = g;\n      pb = b;\n      pa = a;\n\n      if(!bits_done && stats->bits < 8) {\n        /*only r is checked, < 8 bits is only relevant for grayscale*/\n        unsigned bits = getValueRequiredBits(r);\n        if(bits > stats->bits) stats->bits = bits;\n      }\n      bits_done = (stats->bits >= bpp);\n\n      if(!colored_done && (r != g || r != b)) {\n        stats->colored = 1;\n        colored_done = 1;\n        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/\n      }\n\n      if(!alpha_done) {\n        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);\n        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        } else if(a == 0 && !stats->alpha && !stats->key) {\n          stats->key = 1;\n          stats->key_r = r;\n          stats->key_g = g;\n          stats->key_b = b;\n        } else if(a == 255 && stats->key && matchkey) {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        }\n      }\n\n      if(!numcolors_done) {\n        if(!color_tree_has(&tree, r, g, b, a)) {\n          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);\n          if(error) goto cleanup;\n          if(stats->numcolors < 256) {\n            unsigned char* p = stats->palette;\n            unsigned n = stats->numcolors;\n            p[n * 4 + 0] = r;\n            p[n * 4 + 1] = g;\n            p[n * 4 + 2] = b;\n            p[n * 4 + 3] = a;\n          }\n          ++stats->numcolors;\n          numcolors_done = stats->numcolors >= maxnumcolors;\n        }\n      }\n\n      if(alpha_done && numcolors_done && colored_done && bits_done) break;\n    }\n\n    if(stats->key && !stats->alpha) {\n      for(i = 0; i != numpixels; ++i) {\n        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);\n        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          stats->alpha = 1;\n          stats->key = 0;\n          alpha_done = 1;\n          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        }\n      }\n    }\n\n    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/\n    stats->key_r += (stats->key_r << 8);\n    stats->key_g += (stats->key_g << 8);\n    stats->key_b += (stats->key_b << 8);\n  }\n\ncleanup:\n  color_tree_cleanup(&tree);\n  return error;\n}\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit\n(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for\nall pixels of an image but only for a few additional values. */\nstatic unsigned lodepng_color_stats_add(LodePNGColorStats* stats,\n                                        unsigned r, unsigned g, unsigned b, unsigned a) {\n  unsigned error = 0;\n  unsigned char image[8];\n  LodePNGColorMode mode;\n  lodepng_color_mode_init(&mode);\n  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;\n  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;\n  mode.bitdepth = 16;\n  mode.colortype = LCT_RGBA;\n  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);\n  lodepng_color_mode_cleanup(&mode);\n  return error;\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\n/*Computes a minimal PNG color model that can contain all colors as indicated by the stats.\nThe stats should be computed with lodepng_compute_color_stats.\nmode_in is raw color profile of the image the stats were computed on, to copy palette order from when relevant.\nMinimal PNG color model means the color type and bit depth that gives smallest amount of bits in the output image,\ne.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...\nThis is used if auto_convert is enabled (it is by default).\n*/\nstatic unsigned auto_choose_color(LodePNGColorMode* mode_out,\n                                  const LodePNGColorMode* mode_in,\n                                  const LodePNGColorStats* stats) {\n  unsigned error = 0;\n  unsigned palettebits;\n  size_t i, n;\n  size_t numpixels = stats->numpixels;\n  unsigned palette_ok, gray_ok;\n\n  unsigned alpha = stats->alpha;\n  unsigned key = stats->key;\n  unsigned bits = stats->bits;\n\n  mode_out->key_defined = 0;\n\n  if(key && numpixels <= 16) {\n    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/\n    key = 0;\n    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n  }\n\n  gray_ok = !stats->colored;\n  if(!stats->allow_greyscale) gray_ok = 0;\n  if(!gray_ok && bits < 8) bits = 8;\n\n  n = stats->numcolors;\n  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));\n  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/\n  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/\n  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/\n  if(!stats->allow_palette) palette_ok = 0;\n\n  if(palette_ok) {\n    const unsigned char* p = stats->palette;\n    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/\n    for(i = 0; i != stats->numcolors; ++i) {\n      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);\n      if(error) break;\n    }\n\n    mode_out->colortype = LCT_PALETTE;\n    mode_out->bitdepth = palettebits;\n\n    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize\n        && mode_in->bitdepth == mode_out->bitdepth) {\n      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/\n      lodepng_color_mode_cleanup(mode_out); /*clears palette, keeps the above set colortype and bitdepth fields as-is*/\n      lodepng_color_mode_copy(mode_out, mode_in);\n    }\n  } else /*8-bit or 16-bit per channel*/ {\n    mode_out->bitdepth = bits;\n    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)\n                                : (gray_ok ? LCT_GREY : LCT_RGB);\n    if(key) {\n      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/\n      mode_out->key_r = stats->key_r & mask;\n      mode_out->key_g = stats->key_g & mask;\n      mode_out->key_b = stats->key_b & mask;\n      mode_out->key_defined = 1;\n    }\n  }\n\n  return error;\n}\n\n#endif /* #ifdef LODEPNG_COMPILE_ENCODER */\n\n/*Paeth predictor, used by PNG filter type 4*/\nstatic unsigned char paethPredictor(unsigned char a, unsigned char b, unsigned char c) {\n  /* the subtractions of unsigned char cast it to a signed type.\n  With gcc, short is faster than int, with clang int is as fast (as of april 2023)*/\n  short pa = (b - c) < 0 ? -(b - c) : (b - c);\n  short pb = (a - c) < 0 ? -(a - c) : (a - c);\n  /* writing it out like this compiles to something faster than introducing a temp variable*/\n  short pc = (a + b - c - c) < 0 ? -(a + b - c - c) : (a + b - c - c);\n  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */\n  if(pb < pa) { a = b; pa = pb; }\n  return (pc < pa) ? c : a;\n}\n\n/*shared values used by multiple Adam7 related functions*/\n\nstatic const unsigned ADAM7_IX[7] = { 0, 4, 0, 2, 0, 1, 0 }; /*x start values*/\nstatic const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/\nstatic const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/\nstatic const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/\n\n/*\nOutputs various dimensions and positions in the image related to the Adam7 reduced images.\npassw: output containing the width of the 7 passes\npassh: output containing the height of the 7 passes\nfilter_passstart: output containing the index of the start and end of each\n reduced image with filter bytes\npadded_passstart output containing the index of the start and end of each\n reduced image when without filter bytes but with padded scanlines\npassstart: output containing the index of the start and end of each reduced\n image without padding between scanlines, but still padding between the images\nw, h: width and height of non-interlaced image\nbpp: bits per pixel\n\"padded\" is only relevant if bpp is less than 8 and a scanline or image does not\n end at a full byte\n*/\nstatic void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],\n                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {\n  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/\n  unsigned i;\n\n  /*calculate width and height in pixels of each pass*/\n  for(i = 0; i != 7; ++i) {\n    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];\n    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];\n    if(passw[i] == 0) passh[i] = 0;\n    if(passh[i] == 0) passw[i] = 0;\n  }\n\n  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;\n  for(i = 0; i != 7; ++i) {\n    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/\n    filter_passstart[i + 1] = filter_passstart[i]\n                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);\n    /*bits padded if needed to fill full byte at end of each scanline*/\n    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);\n    /*only padded at end of reduced image*/\n    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;\n  }\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / PNG Decoder                                                            / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*read the information from the header and store it in the LodePNGInfo. return value is error*/\nunsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,\n                         const unsigned char* in, size_t insize) {\n  unsigned width, height;\n  LodePNGInfo* info = &state->info_png;\n  if(insize == 0 || in == 0) {\n    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/\n  }\n  if(insize < 33) {\n    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/\n  }\n\n  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/\n  /* TODO: remove this. One should use a new LodePNGState for new sessions */\n  lodepng_info_cleanup(info);\n  lodepng_info_init(info);\n\n  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71\n     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {\n    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/\n  }\n  if(lodepng_chunk_length(in + 8) != 13) {\n    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/\n  }\n  if(!lodepng_chunk_type_equals(in + 8, \"IHDR\")) {\n    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/\n  }\n\n  /*read the values given in the header*/\n  width = lodepng_read32bitInt(&in[16]);\n  height = lodepng_read32bitInt(&in[20]);\n  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/\n  if(w) *w = width;\n  if(h) *h = height;\n  info->color.bitdepth = in[24];\n  info->color.colortype = (LodePNGColorType)in[25];\n  info->compression_method = in[26];\n  info->filter_method = in[27];\n  info->interlace_method = in[28];\n\n  /*errors returned only after the parsing so other values are still output*/\n\n  /*error: invalid image size*/\n  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);\n  /*error: invalid colortype or bitdepth combination*/\n  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);\n  if(state->error) return state->error;\n  /*error: only compression method 0 is allowed in the specification*/\n  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);\n  /*error: only filter method 0 is allowed in the specification*/\n  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);\n  /*error: only interlace methods 0 and 1 exist in the specification*/\n  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);\n\n  if(!state->decoder.ignore_crc) {\n    unsigned CRC = lodepng_read32bitInt(&in[29]);\n    unsigned checksum = lodepng_crc32(&in[12], 17);\n    if(CRC != checksum) {\n      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/\n    }\n  }\n\n  return state->error;\n}\n\nstatic unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,\n                                 size_t bytewidth, unsigned char filterType, size_t length) {\n  /*\n  For PNG filter method 0\n  unfilter a PNG image scanline by scanline. when the pixels are smaller than 1 byte,\n  the filter works byte per byte (bytewidth = 1)\n  precon is the previous unfiltered scanline, recon the result, scanline the current one\n  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead\n  recon and scanline MAY be the same memory address! precon must be disjoint.\n  */\n\n  size_t i;\n  switch(filterType) {\n    case 0:\n      for(i = 0; i != length; ++i) recon[i] = scanline[i];\n      break;\n    case 1: {\n      size_t j = 0;\n      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];\n      for(i = bytewidth; i != length; ++i, ++j) recon[i] = scanline[i] + recon[j];\n      break;\n    }\n    case 2:\n      if(precon) {\n        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];\n      } else {\n        for(i = 0; i != length; ++i) recon[i] = scanline[i];\n      }\n      break;\n    case 3:\n      if(precon) {\n        size_t j = 0;\n        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);\n        /* Unroll independent paths of this predictor. A 6x and 8x version is also possible but that adds\n        too much code. Whether this speeds up anything depends on compiler and settings. */\n        if(bytewidth >= 4) {\n          for(; i + 3 < length; i += 4, j += 4) {\n            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];\n            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];\n            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];\n            recon[i + 0] = s0 + ((r0 + p0) >> 1u);\n            recon[i + 1] = s1 + ((r1 + p1) >> 1u);\n            recon[i + 2] = s2 + ((r2 + p2) >> 1u);\n            recon[i + 3] = s3 + ((r3 + p3) >> 1u);\n          }\n        } else if(bytewidth >= 3) {\n          for(; i + 2 < length; i += 3, j += 3) {\n            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];\n            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];\n            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];\n            recon[i + 0] = s0 + ((r0 + p0) >> 1u);\n            recon[i + 1] = s1 + ((r1 + p1) >> 1u);\n            recon[i + 2] = s2 + ((r2 + p2) >> 1u);\n          }\n        } else if(bytewidth >= 2) {\n          for(; i + 1 < length; i += 2, j += 2) {\n            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];\n            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];\n            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];\n            recon[i + 0] = s0 + ((r0 + p0) >> 1u);\n            recon[i + 1] = s1 + ((r1 + p1) >> 1u);\n          }\n        }\n        for(; i != length; ++i, ++j) recon[i] = scanline[i] + ((recon[j] + precon[i]) >> 1u);\n      } else {\n        size_t j = 0;\n        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];\n        for(i = bytewidth; i != length; ++i, ++j) recon[i] = scanline[i] + (recon[j] >> 1u);\n      }\n      break;\n    case 4:\n      if(precon) {\n        /* Unroll independent paths of this predictor. Whether this speeds up\n        anything depends on compiler and settings. */\n        if(bytewidth == 8) {\n          unsigned char a0, b0 = 0, c0, d0 = 0, a1, b1 = 0, c1, d1 = 0;\n          unsigned char a2, b2 = 0, c2, d2 = 0, a3, b3 = 0, c3, d3 = 0;\n          unsigned char a4, b4 = 0, c4, d4 = 0, a5, b5 = 0, c5, d5 = 0;\n          unsigned char a6, b6 = 0, c6, d6 = 0, a7, b7 = 0, c7, d7 = 0;\n          for(i = 0; i + 7 < length; i += 8) {\n            c0 = b0; c1 = b1; c2 = b2; c3 = b3;\n            c4 = b4; c5 = b5; c6 = b6; c7 = b7;\n            b0 = precon[i + 0]; b1 = precon[i + 1]; b2 = precon[i + 2]; b3 = precon[i + 3];\n            b4 = precon[i + 4]; b5 = precon[i + 5]; b6 = precon[i + 6]; b7 = precon[i + 7];\n            a0 = d0; a1 = d1; a2 = d2; a3 = d3;\n            a4 = d4; a5 = d5; a6 = d6; a7 = d7;\n            d0 = scanline[i + 0] + paethPredictor(a0, b0, c0);\n            d1 = scanline[i + 1] + paethPredictor(a1, b1, c1);\n            d2 = scanline[i + 2] + paethPredictor(a2, b2, c2);\n            d3 = scanline[i + 3] + paethPredictor(a3, b3, c3);\n            d4 = scanline[i + 4] + paethPredictor(a4, b4, c4);\n            d5 = scanline[i + 5] + paethPredictor(a5, b5, c5);\n            d6 = scanline[i + 6] + paethPredictor(a6, b6, c6);\n            d7 = scanline[i + 7] + paethPredictor(a7, b7, c7);\n            recon[i + 0] = d0; recon[i + 1] = d1; recon[i + 2] = d2; recon[i + 3] = d3;\n            recon[i + 4] = d4; recon[i + 5] = d5; recon[i + 6] = d6; recon[i + 7] = d7;\n          }\n        } else if(bytewidth == 6) {\n          unsigned char a0, b0 = 0, c0, d0 = 0, a1, b1 = 0, c1, d1 = 0;\n          unsigned char a2, b2 = 0, c2, d2 = 0, a3, b3 = 0, c3, d3 = 0;\n          unsigned char a4, b4 = 0, c4, d4 = 0, a5, b5 = 0, c5, d5 = 0;\n          for(i = 0; i + 5 < length; i += 6) {\n            c0 = b0; c1 = b1; c2 = b2;\n            c3 = b3; c4 = b4; c5 = b5;\n            b0 = precon[i + 0]; b1 = precon[i + 1]; b2 = precon[i + 2];\n            b3 = precon[i + 3]; b4 = precon[i + 4]; b5 = precon[i + 5];\n            a0 = d0; a1 = d1; a2 = d2;\n            a3 = d3; a4 = d4; a5 = d5;\n            d0 = scanline[i + 0] + paethPredictor(a0, b0, c0);\n            d1 = scanline[i + 1] + paethPredictor(a1, b1, c1);\n            d2 = scanline[i + 2] + paethPredictor(a2, b2, c2);\n            d3 = scanline[i + 3] + paethPredictor(a3, b3, c3);\n            d4 = scanline[i + 4] + paethPredictor(a4, b4, c4);\n            d5 = scanline[i + 5] + paethPredictor(a5, b5, c5);\n            recon[i + 0] = d0; recon[i + 1] = d1; recon[i + 2] = d2;\n            recon[i + 3] = d3; recon[i + 4] = d4; recon[i + 5] = d5;\n          }\n        } else if(bytewidth == 4) {\n          unsigned char a0, b0 = 0, c0, d0 = 0, a1, b1 = 0, c1, d1 = 0;\n          unsigned char a2, b2 = 0, c2, d2 = 0, a3, b3 = 0, c3, d3 = 0;\n          for(i = 0; i + 3 < length; i += 4) {\n            c0 = b0; c1 = b1; c2 = b2; c3 = b3;\n            b0 = precon[i + 0]; b1 = precon[i + 1]; b2 = precon[i + 2]; b3 = precon[i + 3];\n            a0 = d0; a1 = d1; a2 = d2; a3 = d3;\n            d0 = scanline[i + 0] + paethPredictor(a0, b0, c0);\n            d1 = scanline[i + 1] + paethPredictor(a1, b1, c1);\n            d2 = scanline[i + 2] + paethPredictor(a2, b2, c2);\n            d3 = scanline[i + 3] + paethPredictor(a3, b3, c3);\n            recon[i + 0] = d0; recon[i + 1] = d1; recon[i + 2] = d2; recon[i + 3] = d3;\n          }\n        } else if(bytewidth == 3) {\n          unsigned char a0, b0 = 0, c0, d0 = 0;\n          unsigned char a1, b1 = 0, c1, d1 = 0;\n          unsigned char a2, b2 = 0, c2, d2 = 0;\n          for(i = 0; i + 2 < length; i += 3) {\n            c0 = b0; c1 = b1; c2 = b2;\n            b0 = precon[i + 0]; b1 = precon[i + 1]; b2 = precon[i + 2];\n            a0 = d0; a1 = d1; a2 = d2;\n            d0 = scanline[i + 0] + paethPredictor(a0, b0, c0);\n            d1 = scanline[i + 1] + paethPredictor(a1, b1, c1);\n            d2 = scanline[i + 2] + paethPredictor(a2, b2, c2);\n            recon[i + 0] = d0; recon[i + 1] = d1; recon[i + 2] = d2;\n          }\n        } else if(bytewidth == 2) {\n          unsigned char a0, b0 = 0, c0, d0 = 0;\n          unsigned char a1, b1 = 0, c1, d1 = 0;\n          for(i = 0; i + 1 < length; i += 2) {\n            c0 = b0; c1 = b1;\n            b0 = precon[i + 0];\n            b1 = precon[i + 1];\n            a0 = d0; a1 = d1;\n            d0 = scanline[i + 0] + paethPredictor(a0, b0, c0);\n            d1 = scanline[i + 1] + paethPredictor(a1, b1, c1);\n            recon[i + 0] = d0;\n            recon[i + 1] = d1;\n          }\n        } else if(bytewidth == 1) {\n          unsigned char a, b = 0, c, d = 0;\n          for(i = 0; i != length; ++i) {\n            c = b;\n            b = precon[i];\n            a = d;\n            d = scanline[i] + paethPredictor(a, b, c);\n            recon[i] = d;\n          }\n        } else {\n          /* Normally not a possible case, but this would handle it correctly */\n          for(i = 0; i != bytewidth; ++i) {\n            recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/\n          }\n        }\n        /* finish any remaining bytes */\n        for(; i != length; ++i) {\n          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));\n        }\n      } else {\n        size_t j = 0;\n        for(i = 0; i != bytewidth; ++i) {\n          recon[i] = scanline[i];\n        }\n        for(i = bytewidth; i != length; ++i, ++j) {\n          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/\n          recon[i] = (scanline[i] + recon[j]);\n        }\n      }\n      break;\n    default: return 36; /*error: invalid filter type given*/\n  }\n  return 0;\n}\n\nstatic unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {\n  /*\n  For PNG filter method 0\n  this function unfilters a single image (e.g. without interlacing this is called once, with Adam7 seven times)\n  out must have enough bytes allocated already, in must have the scanlines + 1 filtertype byte per scanline\n  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel\n  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)\n  */\n\n  unsigned y;\n  unsigned char* prevline = 0;\n\n  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/\n  size_t bytewidth = (bpp + 7u) / 8u;\n  /*the width of a scanline in bytes, not including the filter type*/\n  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;\n\n  for(y = 0; y < h; ++y) {\n    size_t outindex = linebytes * y;\n    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\n    unsigned char filterType = in[inindex];\n\n    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));\n\n    prevline = &out[outindex];\n  }\n\n  return 0;\n}\n\n/*\nin: Adam7 interlaced image, with no padding bits between scanlines, but between\n reduced images so that each reduced image starts at a byte.\nout: the same pixels, but re-ordered so that they're now a non-interlaced image with size w*h\nbpp: bits per pixel\nout has the following size in bits: w * h * bpp.\nin is possibly bigger due to padding bits between reduced images.\nout must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation\n(because that's likely a little bit faster)\nNOTE: comments about padding bits are only relevant if bpp < 8\n*/\nstatic void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {\n  unsigned passw[7], passh[7];\n  size_t filter_passstart[8], padded_passstart[8], passstart[8];\n  unsigned i;\n\n  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n  if(bpp >= 8) {\n    for(i = 0; i != 7; ++i) {\n      unsigned x, y, b;\n      size_t bytewidth = bpp / 8u;\n      for(y = 0; y < passh[i]; ++y)\n      for(x = 0; x < passw[i]; ++x) {\n        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;\n        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w\n                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;\n        for(b = 0; b < bytewidth; ++b) {\n          out[pixeloutstart + b] = in[pixelinstart + b];\n        }\n      }\n    }\n  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {\n    for(i = 0; i != 7; ++i) {\n      unsigned x, y, b;\n      unsigned ilinebits = bpp * passw[i];\n      unsigned olinebits = bpp * w;\n      size_t obp, ibp; /*bit pointers (for out and in buffer)*/\n      for(y = 0; y < passh[i]; ++y)\n      for(x = 0; x < passw[i]; ++x) {\n        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);\n        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;\n        for(b = 0; b < bpp; ++b) {\n          unsigned char bit = readBitFromReversedStream(&ibp, in);\n          setBitOfReversedStream(&obp, out, bit);\n        }\n      }\n    }\n  }\n}\n\nstatic void removePaddingBits(unsigned char* out, const unsigned char* in,\n                              size_t olinebits, size_t ilinebits, unsigned h) {\n  /*\n  After filtering there are still padding bits if scanlines have non multiple of 8 bit amounts. They need\n  to be removed (except at last scanline of (Adam7-reduced) image) before working with pure image buffers\n  for the Adam7 code, the color convert code and the output to the user.\n  in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must\n  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits\n  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7\n  only useful if (ilinebits - olinebits) is a value in the range 1..7\n  */\n  unsigned y;\n  size_t diff = ilinebits - olinebits;\n  size_t ibp = 0, obp = 0; /*input and output bit pointers*/\n  for(y = 0; y < h; ++y) {\n    size_t x;\n    for(x = 0; x < olinebits; ++x) {\n      unsigned char bit = readBitFromReversedStream(&ibp, in);\n      setBitOfReversedStream(&obp, out, bit);\n    }\n    ibp += diff;\n  }\n}\n\n/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from\nthe IDAT chunks (with filter index bytes and possible padding bits)\nreturn value is error*/\nstatic unsigned postProcessScanlines(unsigned char* out, unsigned char* in,\n                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {\n  /*\n  This function converts the filtered-padded-interlaced data into pure 2D image buffer with the PNG's colortype.\n  Steps:\n  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)\n  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace\n  NOTE: the in buffer will be overwritten with intermediate data!\n  */\n  unsigned bpp = lodepng_get_bpp(&info_png->color);\n  if(bpp == 0) return 31; /*error: invalid colortype*/\n\n  if(info_png->interlace_method == 0) {\n    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {\n      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));\n      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);\n    }\n    /*we can immediately filter into the out buffer, no other steps needed*/\n    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));\n  } else /*interlace_method is 1 (Adam7)*/ {\n    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];\n    unsigned i;\n\n    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n    for(i = 0; i != 7; ++i) {\n      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));\n      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,\n      move bytes instead of bits or move not at all*/\n      if(bpp < 8) {\n        /*remove padding bits in scanlines; after this there still may be padding\n        bits between the different reduced images: each reduced image still starts nicely at a byte*/\n        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,\n                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);\n      }\n    }\n\n    Adam7_deinterlace(out, in, w, h, bpp);\n  }\n\n  return 0;\n}\n\nstatic unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {\n  unsigned pos = 0, i;\n  color->palettesize = chunkLength / 3u;\n  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/\n  lodepng_color_mode_alloc_palette(color);\n  if(!color->palette && color->palettesize) {\n    color->palettesize = 0;\n    return 83; /*alloc fail*/\n  }\n\n  for(i = 0; i != color->palettesize; ++i) {\n    color->palette[4 * i + 0] = data[pos++]; /*R*/\n    color->palette[4 * i + 1] = data[pos++]; /*G*/\n    color->palette[4 * i + 2] = data[pos++]; /*B*/\n    color->palette[4 * i + 3] = 255; /*alpha*/\n  }\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {\n  unsigned i;\n  if(color->colortype == LCT_PALETTE) {\n    /*error: more alpha values given than there are palette entries*/\n    if(chunkLength > color->palettesize) return 39;\n\n    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];\n  } else if(color->colortype == LCT_GREY) {\n    /*error: this chunk must be 2 bytes for grayscale image*/\n    if(chunkLength != 2) return 30;\n\n    color->key_defined = 1;\n    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];\n  } else if(color->colortype == LCT_RGB) {\n    /*error: this chunk must be 6 bytes for RGB image*/\n    if(chunkLength != 6) return 41;\n\n    color->key_defined = 1;\n    color->key_r = 256u * data[0] + data[1];\n    color->key_g = 256u * data[2] + data[3];\n    color->key_b = 256u * data[4] + data[5];\n  }\n  else return 42; /*error: tRNS chunk not allowed for other color models*/\n\n  return 0; /* OK */\n}\n\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n/*background color chunk (bKGD)*/\nstatic unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(info->color.colortype == LCT_PALETTE) {\n    /*error: this chunk must be 1 byte for indexed color image*/\n    if(chunkLength != 1) return 43;\n\n    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/\n    if(data[0] >= info->color.palettesize) return 103;\n\n    info->background_defined = 1;\n    info->background_r = info->background_g = info->background_b = data[0];\n  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {\n    /*error: this chunk must be 2 bytes for grayscale image*/\n    if(chunkLength != 2) return 44;\n\n    /*the values are truncated to bitdepth in the PNG file*/\n    info->background_defined = 1;\n    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];\n  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {\n    /*error: this chunk must be 6 bytes for grayscale image*/\n    if(chunkLength != 6) return 45;\n\n    /*the values are truncated to bitdepth in the PNG file*/\n    info->background_defined = 1;\n    info->background_r = 256u * data[0] + data[1];\n    info->background_g = 256u * data[2] + data[3];\n    info->background_b = 256u * data[4] + data[5];\n  }\n\n  return 0; /* OK */\n}\n\n/*text chunk (tEXt)*/\nstatic unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  unsigned error = 0;\n  char *key = 0, *str = 0;\n\n  while(!error) /*not really a while loop, only used to break on error*/ {\n    unsigned length, string2_begin;\n\n    length = 0;\n    while(length < chunkLength && data[length] != 0) ++length;\n    /*even though it's not allowed by the standard, no error is thrown if\n    there's no null termination char, if the text is empty*/\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\n\n    key = (char*)lodepng_malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(key, data, length);\n    key[length] = 0;\n\n    string2_begin = length + 1; /*skip keyword null terminator*/\n\n    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);\n    str = (char*)lodepng_malloc(length + 1);\n    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(str, data + string2_begin, length);\n    str[length] = 0;\n\n    error = lodepng_add_text(info, key, str);\n\n    break;\n  }\n\n  lodepng_free(key);\n  lodepng_free(str);\n\n  return error;\n}\n\n/*compressed text chunk (zTXt)*/\nstatic unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,\n                               const unsigned char* data, size_t chunkLength) {\n  unsigned error = 0;\n\n  /*copy the object to change parameters in it*/\n  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;\n\n  unsigned length, string2_begin;\n  char *key = 0;\n  unsigned char* str = 0;\n  size_t size = 0;\n\n  while(!error) /*not really a while loop, only used to break on error*/ {\n    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;\n    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\n\n    key = (char*)lodepng_malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(key, data, length);\n    key[length] = 0;\n\n    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/\n\n    string2_begin = length + 2;\n    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/\n\n    length = (unsigned)chunkLength - string2_begin;\n    zlibsettings.max_output_size = decoder->max_text_size;\n    /*will fail if zlib error, e.g. if length is too small*/\n    error = zlib_decompress(&str, &size, 0, &data[string2_begin],\n                            length, &zlibsettings);\n    /*error: compressed text larger than  decoder->max_text_size*/\n    if(error && size > zlibsettings.max_output_size) error = 112;\n    if(error) break;\n    error = lodepng_add_text_sized(info, key, (char*)str, size);\n    break;\n  }\n\n  lodepng_free(key);\n  lodepng_free(str);\n\n  return error;\n}\n\n/*international text chunk (iTXt)*/\nstatic unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,\n                               const unsigned char* data, size_t chunkLength) {\n  unsigned error = 0;\n  unsigned i;\n\n  /*copy the object to change parameters in it*/\n  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;\n\n  unsigned length, begin, compressed;\n  char *key = 0, *langtag = 0, *transkey = 0;\n\n  while(!error) /*not really a while loop, only used to break on error*/ {\n    /*Quick check if the chunk length isn't too small. Even without check\n    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/\n    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/\n\n    /*read the key*/\n    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;\n    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\n\n    key = (char*)lodepng_malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(key, data, length);\n    key[length] = 0;\n\n    /*read the compression method*/\n    compressed = data[length + 1];\n    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/\n\n    /*even though it's not allowed by the standard, no error is thrown if\n    there's no null termination char, if the text is empty for the next 3 texts*/\n\n    /*read the langtag*/\n    begin = length + 3;\n    length = 0;\n    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;\n\n    langtag = (char*)lodepng_malloc(length + 1);\n    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(langtag, data + begin, length);\n    langtag[length] = 0;\n\n    /*read the transkey*/\n    begin += length + 1;\n    length = 0;\n    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;\n\n    transkey = (char*)lodepng_malloc(length + 1);\n    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    lodepng_memcpy(transkey, data + begin, length);\n    transkey[length] = 0;\n\n    /*read the actual text*/\n    begin += length + 1;\n\n    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;\n\n    if(compressed) {\n      unsigned char* str = 0;\n      size_t size = 0;\n      zlibsettings.max_output_size = decoder->max_text_size;\n      /*will fail if zlib error, e.g. if length is too small*/\n      error = zlib_decompress(&str, &size, 0, &data[begin],\n                              length, &zlibsettings);\n      /*error: compressed text larger than  decoder->max_text_size*/\n      if(error && size > zlibsettings.max_output_size) error = 112;\n      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);\n      lodepng_free(str);\n    } else {\n      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);\n    }\n\n    break;\n  }\n\n  lodepng_free(key);\n  lodepng_free(langtag);\n  lodepng_free(transkey);\n\n  return error;\n}\n\nstatic unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/\n\n  info->time_defined = 1;\n  info->time.year = 256u * data[0] + data[1];\n  info->time.month = data[2];\n  info->time.day = data[3];\n  info->time.hour = data[4];\n  info->time.minute = data[5];\n  info->time.second = data[6];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/\n\n  info->phys_defined = 1;\n  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];\n  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];\n  info->phys_unit = data[8];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/\n\n  info->gama_defined = 1;\n  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/\n\n  info->chrm_defined = 1;\n  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];\n  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];\n  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];\n  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];\n  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];\n  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];\n  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];\n  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/\n\n  info->srgb_defined = 1;\n  info->srgb_intent = data[0];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,\n                               const unsigned char* data, size_t chunkLength) {\n  unsigned error = 0;\n  unsigned i;\n  size_t size = 0;\n  /*copy the object to change parameters in it*/\n  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;\n\n  unsigned length, string2_begin;\n\n  if(info->iccp_defined) lodepng_clear_icc(info);\n  info->iccp_defined = 1;\n\n  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;\n  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/\n  if(length < 1 || length > 79) return 89; /*keyword too short or long*/\n\n  info->iccp_name = (char*)lodepng_malloc(length + 1);\n  if(!info->iccp_name) return 83; /*alloc fail*/\n\n  info->iccp_name[length] = 0;\n  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];\n\n  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/\n\n  string2_begin = length + 2;\n  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/\n\n  length = (unsigned)chunkLength - string2_begin;\n  zlibsettings.max_output_size = decoder->max_icc_size;\n  error = zlib_decompress(&info->iccp_profile, &size, 0,\n                          &data[string2_begin],\n                          length, &zlibsettings);\n  /*error: ICC profile larger than decoder->max_icc_size*/\n  if(error && size > zlibsettings.max_output_size) error = 113;\n  info->iccp_profile_size = (unsigned)size;\n  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/\n  return error;\n}\n\nstatic unsigned readChunk_cICP(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 4) return 117; /*invalid cICP chunk size*/\n\n  info->cicp_defined = 1;\n  /* No error checking for value ranges is done here, that is up to a CICP\n  handling library, not the PNG decoding. Just pass on the metadata. */\n  info->cicp_color_primaries = data[0];\n  info->cicp_transfer_function = data[1];\n  info->cicp_matrix_coefficients = data[2];\n  info->cicp_video_full_range_flag = data[3];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_mDCv(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 24) return 119; /*invalid mDCv chunk size*/\n\n  info->mdcv_defined = 1;\n  info->mdcv_red_x = 256u * data[0] + data[1];\n  info->mdcv_red_y = 256u * data[2] + data[3];\n  info->mdcv_green_x = 256u * data[4] + data[5];\n  info->mdcv_green_y = 256u * data[6] + data[7];\n  info->mdcv_blue_x = 256u * data[8] + data[9];\n  info->mdcv_blue_y = 256u * data[10] + data[11];\n  info->mdcv_white_x = 256u * data[12] + data[13];\n  info->mdcv_white_y = 256u * data[14] + data[15];\n  info->mdcv_max_luminance = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];\n  info->mdcv_min_luminance = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_cLLi(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  if(chunkLength != 8) return 120; /*invalid cLLi chunk size*/\n\n  info->clli_defined = 1;\n  info->clli_max_cll = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];\n  info->clli_max_fall = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_eXIf(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  return lodepng_set_exif(info, data, (unsigned)chunkLength);\n}\n\n/*significant bits chunk (sBIT)*/\nstatic unsigned readChunk_sBIT(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {\n  unsigned bitdepth = (info->color.colortype == LCT_PALETTE) ? 8 : info->color.bitdepth;\n  if(info->color.colortype == LCT_GREY) {\n    /*error: this chunk must be 1 bytes for grayscale image*/\n    if(chunkLength != 1) return 114;\n    if(data[0] == 0 || data[0] > bitdepth) return 115;\n    info->sbit_defined = 1;\n    info->sbit_r = info->sbit_g = info->sbit_b = data[0]; /*setting g and b is not required, but sensible*/\n  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_PALETTE) {\n    /*error: this chunk must be 3 bytes for RGB and palette image*/\n    if(chunkLength != 3) return 114;\n    if(data[0] == 0 || data[1] == 0 || data[2] == 0) return 115;\n    if(data[0] > bitdepth || data[1] > bitdepth || data[2] > bitdepth) return 115;\n    info->sbit_defined = 1;\n    info->sbit_r = data[0];\n    info->sbit_g = data[1];\n    info->sbit_b = data[2];\n  } else if(info->color.colortype == LCT_GREY_ALPHA) {\n    /*error: this chunk must be 2 byte for grayscale with alpha image*/\n    if(chunkLength != 2) return 114;\n    if(data[0] == 0 || data[1] == 0) return 115;\n    if(data[0] > bitdepth || data[1] > bitdepth) return 115;\n    info->sbit_defined = 1;\n    info->sbit_r = info->sbit_g = info->sbit_b = data[0]; /*setting g and b is not required, but sensible*/\n    info->sbit_a = data[1];\n  } else if(info->color.colortype == LCT_RGBA) {\n    /*error: this chunk must be 4 bytes for grayscale image*/\n    if(chunkLength != 4) return 114;\n    if(data[0] == 0 || data[1] == 0 || data[2] == 0 || data[3] == 0) return 115;\n    if(data[0] > bitdepth || data[1] > bitdepth || data[2] > bitdepth || data[3] > bitdepth) return 115;\n    info->sbit_defined = 1;\n    info->sbit_r = data[0];\n    info->sbit_g = data[1];\n    info->sbit_b = data[2];\n    info->sbit_a = data[3];\n  }\n\n  return 0; /* OK */\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\nunsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,\n                               const unsigned char* in, size_t insize) {\n  const unsigned char* chunk = in + pos;\n  unsigned chunkLength;\n  const unsigned char* data;\n  unsigned unhandled = 0;\n  unsigned error = 0;\n\n  if(pos + 4 > insize) return 30;\n  chunkLength = lodepng_chunk_length(chunk);\n  if(chunkLength > 2147483647) return 63;\n  data = lodepng_chunk_data_const(chunk);\n  if(chunkLength + 12 > insize - pos) return 30;\n\n  if(lodepng_chunk_type_equals(chunk, \"PLTE\")) {\n    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"tRNS\")) {\n    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  } else if(lodepng_chunk_type_equals(chunk, \"bKGD\")) {\n    error = readChunk_bKGD(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"tEXt\")) {\n    error = readChunk_tEXt(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"zTXt\")) {\n    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"iTXt\")) {\n    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"tIME\")) {\n    error = readChunk_tIME(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"pHYs\")) {\n    error = readChunk_pHYs(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"gAMA\")) {\n    error = readChunk_gAMA(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"cHRM\")) {\n    error = readChunk_cHRM(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"sRGB\")) {\n    error = readChunk_sRGB(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"iCCP\")) {\n    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"cICP\")) {\n    error = readChunk_cICP(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"mDCv\")) {\n    error = readChunk_mDCv(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"cLLi\")) {\n    error = readChunk_cLLi(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"eXIf\")) {\n    error = readChunk_eXIf(&state->info_png, data, chunkLength);\n  } else if(lodepng_chunk_type_equals(chunk, \"sBIT\")) {\n    error = readChunk_sBIT(&state->info_png, data, chunkLength);\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  } else {\n    /* unhandled chunk is ok (is not an error) */\n    unhandled = 1;\n  }\n\n  if(!error && !unhandled && !state->decoder.ignore_crc) {\n    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/\n  }\n\n  return error;\n}\n\n/*read a PNG, the result will be in the same color type as the PNG (hence \"generic\")*/\nstatic void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,\n                          LodePNGState* state,\n                          const unsigned char* in, size_t insize) {\n  unsigned char IEND = 0;\n  const unsigned char* chunk; /*points to beginning of next chunk*/\n  unsigned char* idat; /*the data from idat chunks, zlib compressed*/\n  size_t idatsize = 0;\n  unsigned char* scanlines = 0;\n  size_t scanlines_size = 0, expected_size = 0;\n  size_t outsize = 0;\n\n  /*for unknown chunk order*/\n  unsigned unknown = 0;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\n\n  /* safe output values in case error happens */\n  *out = 0;\n  *w = *h = 0;\n\n  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/\n  if(state->error) return;\n\n  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {\n    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/\n  }\n\n  /*the input filesize is a safe upper bound for the sum of idat chunks size*/\n  idat = (unsigned char*)lodepng_malloc(insize);\n  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/\n\n  chunk = &in[33]; /*first byte of the first chunk after the header*/\n\n  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.\n  IDAT data is put at the start of the in buffer*/\n  while(!IEND && !state->error) {\n    unsigned chunkLength;\n    const unsigned char* data; /*the data in the chunk*/\n    size_t pos = (size_t)(chunk - in);\n\n    /*error: next chunk out of bounds of the in buffer*/\n    if(chunk < in || pos + 12 > insize) {\n      if(state->decoder.ignore_end) break; /*other errors may still happen though*/\n      CERROR_BREAK(state->error, 30);\n    }\n\n    /*length of the data of the chunk, excluding the 12 bytes for length, chunk type and CRC*/\n    chunkLength = lodepng_chunk_length(chunk);\n    /*error: chunk length larger than the max PNG chunk size*/\n    if(chunkLength > 2147483647) {\n      if(state->decoder.ignore_end) break; /*other errors may still happen though*/\n      CERROR_BREAK(state->error, 63);\n    }\n\n    if(pos + (size_t)chunkLength + 12 > insize || pos + (size_t)chunkLength + 12 < pos) {\n      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk (or int overflow)*/\n    }\n\n    data = lodepng_chunk_data_const(chunk);\n\n    unknown = 0;\n\n    /*IDAT chunk, containing compressed image data*/\n    if(lodepng_chunk_type_equals(chunk, \"IDAT\")) {\n      size_t newsize;\n      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);\n      if(newsize > insize) CERROR_BREAK(state->error, 95);\n      lodepng_memcpy(idat + idatsize, data, chunkLength);\n      idatsize += chunkLength;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      critical_pos = 3;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    } else if(lodepng_chunk_type_equals(chunk, \"IEND\")) {\n      /*IEND chunk*/\n      IEND = 1;\n    } else if(lodepng_chunk_type_equals(chunk, \"PLTE\")) {\n      /*palette chunk (PLTE)*/\n      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);\n      if(state->error) break;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      critical_pos = 2;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    } else if(lodepng_chunk_type_equals(chunk, \"tRNS\")) {\n      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled\n      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that\n      affects the alpha channel of pixels. */\n      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);\n      if(state->error) break;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      /*background color chunk (bKGD)*/\n    } else if(lodepng_chunk_type_equals(chunk, \"bKGD\")) {\n      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"tEXt\")) {\n      /*text chunk (tEXt)*/\n      if(state->decoder.read_text_chunks) {\n        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);\n        if(state->error) break;\n      }\n    } else if(lodepng_chunk_type_equals(chunk, \"zTXt\")) {\n      /*compressed text chunk (zTXt)*/\n      if(state->decoder.read_text_chunks) {\n        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);\n        if(state->error) break;\n      }\n    } else if(lodepng_chunk_type_equals(chunk, \"iTXt\")) {\n      /*international text chunk (iTXt)*/\n      if(state->decoder.read_text_chunks) {\n        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);\n        if(state->error) break;\n      }\n    } else if(lodepng_chunk_type_equals(chunk, \"tIME\")) {\n      state->error = readChunk_tIME(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"pHYs\")) {\n      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"gAMA\")) {\n      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"cHRM\")) {\n      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"sRGB\")) {\n      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"iCCP\")) {\n      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"cICP\")) {\n      state->error = readChunk_cICP(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"mDCv\")) {\n      state->error = readChunk_mDCv(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"cLLi\")) {\n      state->error = readChunk_cLLi(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"eXIf\")) {\n      state->error = readChunk_eXIf(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    } else if(lodepng_chunk_type_equals(chunk, \"sBIT\")) {\n      state->error = readChunk_sBIT(&state->info_png, data, chunkLength);\n      if(state->error) break;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {\n      if(!lodepng_chunk_type_name_valid(chunk)) {\n        CERROR_BREAK(state->error, 121); /* invalid chunk type name */\n      }\n      if(lodepng_chunk_reserved(chunk)) {\n        CERROR_BREAK(state->error, 122); /* invalid third lowercase character */\n      }\n\n      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/\n      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {\n        CERROR_BREAK(state->error, 69);\n      }\n\n      unknown = 1;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      if(state->decoder.remember_unknown_chunks) {\n        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],\n                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);\n        if(state->error) break;\n      }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    }\n\n    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {\n      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/\n    }\n\n    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);\n  }\n\n  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {\n    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */\n  }\n\n  if(!state->error) {\n    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.\n    If the decompressed size does not match the prediction, the image must be corrupt.*/\n    if(state->info_png.interlace_method == 0) {\n      unsigned bpp = lodepng_get_bpp(&state->info_png.color);\n      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);\n    } else {\n      unsigned bpp = lodepng_get_bpp(&state->info_png.color);\n      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/\n      expected_size = 0;\n      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);\n      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);\n      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);\n      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);\n      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);\n      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);\n      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);\n    }\n\n    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);\n  }\n  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/\n  lodepng_free(idat);\n\n  if(!state->error) {\n    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);\n    *out = (unsigned char*)lodepng_malloc(outsize);\n    if(!*out) state->error = 83; /*alloc fail*/\n  }\n  if(!state->error) {\n    lodepng_memset(*out, 0, outsize);\n    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);\n  }\n  lodepng_free(scanlines);\n}\n\nunsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,\n                        LodePNGState* state,\n                        const unsigned char* in, size_t insize) {\n  *out = 0;\n  decodeGeneric(out, w, h, state, in, insize);\n  if(state->error) return state->error;\n  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {\n    /*same color type, no copying or converting of data needed*/\n    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype\n    the raw image has to the end user*/\n    if(!state->decoder.color_convert) {\n      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);\n      if(state->error) return state->error;\n    }\n  } else { /*color conversion needed*/\n    unsigned char* data = *out;\n    size_t outsize;\n\n    /*TODO: check if this works according to the statement in the documentation: \"The converter can convert\n    from grayscale input color type, to 8-bit grayscale or grayscale with alpha\"*/\n    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)\n       && !(state->info_raw.bitdepth == 8)) {\n      return 56; /*unsupported color mode conversion*/\n    }\n\n    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);\n    *out = (unsigned char*)lodepng_malloc(outsize);\n    if(!(*out)) {\n      state->error = 83; /*alloc fail*/\n    }\n    else state->error = lodepng_convert(*out, data, &state->info_raw,\n                                        &state->info_png.color, *w, *h);\n    lodepng_free(data);\n  }\n  return state->error;\n}\n\nunsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,\n                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned error;\n  LodePNGState state;\n  lodepng_state_init(&state);\n  state.info_raw.colortype = colortype;\n  state.info_raw.bitdepth = bitdepth;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  /*disable reading things that this function doesn't output*/\n  state.decoder.read_text_chunks = 0;\n  state.decoder.remember_unknown_chunks = 0;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  error = lodepng_decode(out, w, h, &state, in, insize);\n  lodepng_state_cleanup(&state);\n  return error;\n}\n\nunsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);\n}\n\nunsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,\n                             LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned char* buffer = 0;\n  size_t buffersize;\n  unsigned error;\n  /* safe output values in case error happens */\n  *out = 0;\n  *w = *h = 0;\n  error = lodepng_load_file(&buffer, &buffersize, filename);\n  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);\n  lodepng_free(buffer);\n  return error;\n}\n\nunsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {\n  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);\n}\n\nunsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {\n  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);\n}\n#endif /*LODEPNG_COMPILE_DISK*/\n\nvoid lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {\n  settings->color_convert = 1;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  settings->read_text_chunks = 1;\n  settings->remember_unknown_chunks = 0;\n  settings->max_text_size = 16777216;\n  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  settings->ignore_crc = 0;\n  settings->ignore_critical = 0;\n  settings->ignore_end = 0;\n  lodepng_decompress_settings_init(&settings->zlibsettings);\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)\n\nvoid lodepng_state_init(LodePNGState* state) {\n#ifdef LODEPNG_COMPILE_DECODER\n  lodepng_decoder_settings_init(&state->decoder);\n#endif /*LODEPNG_COMPILE_DECODER*/\n#ifdef LODEPNG_COMPILE_ENCODER\n  lodepng_encoder_settings_init(&state->encoder);\n#endif /*LODEPNG_COMPILE_ENCODER*/\n  lodepng_color_mode_init(&state->info_raw);\n  lodepng_info_init(&state->info_png);\n  state->error = 1;\n}\n\nvoid lodepng_state_cleanup(LodePNGState* state) {\n  lodepng_color_mode_cleanup(&state->info_raw);\n  lodepng_info_cleanup(&state->info_png);\n}\n\nvoid lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {\n  lodepng_state_cleanup(dest);\n  *dest = *source;\n  lodepng_color_mode_init(&dest->info_raw);\n  lodepng_info_init(&dest->info_png);\n  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;\n  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;\n}\n\n#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / PNG Encoder                                                            / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n\nstatic unsigned writeSignature(ucvector* out) {\n  size_t pos = out->size;\n  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};\n  /*8 bytes PNG signature, aka the magic bytes*/\n  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/\n  lodepng_memcpy(out->data + pos, signature, 8);\n  return 0;\n}\n\nstatic unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,\n                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {\n  unsigned char *chunk, *data;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, \"IHDR\"));\n  data = chunk + 8;\n\n  lodepng_set32bitInt(data + 0, w); /*width*/\n  lodepng_set32bitInt(data + 4, h); /*height*/\n  data[8] = (unsigned char)bitdepth; /*bit depth*/\n  data[9] = (unsigned char)colortype; /*color type*/\n  data[10] = 0; /*compression method*/\n  data[11] = 0; /*filter method*/\n  data[12] = interlace_method; /*interlace method*/\n\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\n/* only adds the chunk if needed (there is a key or palette with alpha) */\nstatic unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {\n  unsigned char* chunk;\n  size_t i, j = 8;\n\n  if(info->palettesize == 0 || info->palettesize > 256) {\n    return 68; /*invalid palette size, it is only allowed to be 1-256*/\n  }\n\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, \"PLTE\"));\n\n  for(i = 0; i != info->palettesize; ++i) {\n    /*add all channels except alpha channel*/\n    chunk[j++] = info->palette[i * 4 + 0];\n    chunk[j++] = info->palette[i * 4 + 1];\n    chunk[j++] = info->palette[i * 4 + 2];\n  }\n\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {\n  unsigned char* chunk = 0;\n\n  if(info->colortype == LCT_PALETTE) {\n    size_t i, amount = info->palettesize;\n    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/\n    for(i = info->palettesize; i != 0; --i) {\n      if(info->palette[4 * (i - 1) + 3] != 255) break;\n      --amount;\n    }\n    if(amount) {\n      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, \"tRNS\"));\n      /*add the alpha channel values from the palette*/\n      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];\n    }\n  } else if(info->colortype == LCT_GREY) {\n    if(info->key_defined) {\n      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, \"tRNS\"));\n      chunk[8] = (unsigned char)(info->key_r >> 8);\n      chunk[9] = (unsigned char)(info->key_r & 255);\n    }\n  } else if(info->colortype == LCT_RGB) {\n    if(info->key_defined) {\n      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, \"tRNS\"));\n      chunk[8] = (unsigned char)(info->key_r >> 8);\n      chunk[9] = (unsigned char)(info->key_r & 255);\n      chunk[10] = (unsigned char)(info->key_g >> 8);\n      chunk[11] = (unsigned char)(info->key_g & 255);\n      chunk[12] = (unsigned char)(info->key_b >> 8);\n      chunk[13] = (unsigned char)(info->key_b & 255);\n    }\n  }\n\n  if(chunk) lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,\n                              LodePNGCompressSettings* zlibsettings) {\n  unsigned error = 0;\n  unsigned char* zlib = 0;\n  size_t pos = 0;\n  size_t zlibsize = 0;\n  /* max chunk length allowed by the specification is 2147483647 bytes */\n  const size_t max_chunk_length = 2147483647u;\n\n  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);\n  while(!error) {\n    if(zlibsize - pos > max_chunk_length) {\n      error = lodepng_chunk_createv(out, max_chunk_length, \"IDAT\", zlib + pos);\n      pos += max_chunk_length;\n    } else {\n      error = lodepng_chunk_createv(out, zlibsize - pos, \"IDAT\", zlib + pos);\n      break;\n    }\n  }\n  lodepng_free(zlib);\n  return error;\n}\n\nstatic unsigned addChunk_IEND(ucvector* out) {\n  return lodepng_chunk_createv(out, 0, \"IEND\", 0);\n}\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n\nstatic unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {\n  unsigned char* chunk = 0;\n  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);\n  size_t size = keysize + 1 + textsize;\n  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, \"tEXt\"));\n  lodepng_memcpy(chunk + 8, keyword, keysize);\n  chunk[8 + keysize] = 0; /*null termination char*/\n  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,\n                              LodePNGCompressSettings* zlibsettings) {\n  unsigned error = 0;\n  unsigned char* chunk = 0;\n  unsigned char* compressed = 0;\n  size_t compressedsize = 0;\n  size_t textsize = lodepng_strlen(textstring);\n  size_t keysize = lodepng_strlen(keyword);\n  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/\n\n  error = zlib_compress(&compressed, &compressedsize,\n                        (const unsigned char*)textstring, textsize, zlibsettings);\n  if(!error) {\n    size_t size = keysize + 2 + compressedsize;\n    error = lodepng_chunk_init(&chunk, out, size, \"zTXt\");\n  }\n  if(!error) {\n    lodepng_memcpy(chunk + 8, keyword, keysize);\n    chunk[8 + keysize] = 0; /*null termination char*/\n    chunk[9 + keysize] = 0; /*compression method: 0*/\n    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);\n    lodepng_chunk_generate_crc(chunk);\n  }\n\n  lodepng_free(compressed);\n  return error;\n}\n\nstatic unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,\n                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {\n  unsigned error = 0;\n  unsigned char* chunk = 0;\n  unsigned char* compressed = 0;\n  size_t compressedsize = 0;\n  size_t textsize = lodepng_strlen(textstring);\n  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);\n\n  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/\n\n  if(compress) {\n    error = zlib_compress(&compressed, &compressedsize,\n                          (const unsigned char*)textstring, textsize, zlibsettings);\n  }\n  if(!error) {\n    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);\n    error = lodepng_chunk_init(&chunk, out, size, \"iTXt\");\n  }\n  if(!error) {\n    size_t pos = 8;\n    lodepng_memcpy(chunk + pos, keyword, keysize);\n    pos += keysize;\n    chunk[pos++] = 0; /*null termination char*/\n    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/\n    chunk[pos++] = 0; /*compression method: 0*/\n    lodepng_memcpy(chunk + pos, langtag, langsize);\n    pos += langsize;\n    chunk[pos++] = 0; /*null termination char*/\n    lodepng_memcpy(chunk + pos, transkey, transsize);\n    pos += transsize;\n    chunk[pos++] = 0; /*null termination char*/\n    if(compress) {\n      lodepng_memcpy(chunk + pos, compressed, compressedsize);\n    } else {\n      lodepng_memcpy(chunk + pos, textstring, textsize);\n    }\n    lodepng_chunk_generate_crc(chunk);\n  }\n\n  lodepng_free(compressed);\n  return error;\n}\n\nstatic unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {\n  unsigned char* chunk = 0;\n  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, \"bKGD\"));\n    chunk[8] = (unsigned char)(info->background_r >> 8);\n    chunk[9] = (unsigned char)(info->background_r & 255);\n  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, \"bKGD\"));\n    chunk[8] = (unsigned char)(info->background_r >> 8);\n    chunk[9] = (unsigned char)(info->background_r & 255);\n    chunk[10] = (unsigned char)(info->background_g >> 8);\n    chunk[11] = (unsigned char)(info->background_g & 255);\n    chunk[12] = (unsigned char)(info->background_b >> 8);\n    chunk[13] = (unsigned char)(info->background_b & 255);\n  } else if(info->color.colortype == LCT_PALETTE) {\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, \"bKGD\"));\n    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/\n  }\n  if(chunk) lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {\n  unsigned char* chunk;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, \"tIME\"));\n  chunk[8] = (unsigned char)(time->year >> 8);\n  chunk[9] = (unsigned char)(time->year & 255);\n  chunk[10] = (unsigned char)time->month;\n  chunk[11] = (unsigned char)time->day;\n  chunk[12] = (unsigned char)time->hour;\n  chunk[13] = (unsigned char)time->minute;\n  chunk[14] = (unsigned char)time->second;\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {\n  unsigned char* chunk;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, \"pHYs\"));\n  lodepng_set32bitInt(chunk + 8, info->phys_x);\n  lodepng_set32bitInt(chunk + 12, info->phys_y);\n  chunk[16] = info->phys_unit;\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {\n  unsigned char* chunk;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, \"gAMA\"));\n  lodepng_set32bitInt(chunk + 8, info->gama_gamma);\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {\n  unsigned char* chunk;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, \"cHRM\"));\n  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);\n  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);\n  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);\n  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);\n  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);\n  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);\n  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);\n  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {\n  unsigned char data = info->srgb_intent;\n  return lodepng_chunk_createv(out, 1, \"sRGB\", &data);\n}\n\nstatic unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {\n  unsigned error = 0;\n  unsigned char* chunk = 0;\n  unsigned char* compressed = 0;\n  size_t compressedsize = 0;\n  size_t keysize = lodepng_strlen(info->iccp_name);\n\n  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/\n  error = zlib_compress(&compressed, &compressedsize,\n                        info->iccp_profile, info->iccp_profile_size, zlibsettings);\n  if(!error) {\n    size_t size = keysize + 2 + compressedsize;\n    error = lodepng_chunk_init(&chunk, out, size, \"iCCP\");\n  }\n  if(!error) {\n    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);\n    chunk[8 + keysize] = 0; /*null termination char*/\n    chunk[9 + keysize] = 0; /*compression method: 0*/\n    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);\n    lodepng_chunk_generate_crc(chunk);\n  }\n\n  lodepng_free(compressed);\n  return error;\n}\n\nstatic unsigned addChunk_cICP(ucvector* out, const LodePNGInfo* info) {\n  unsigned char* chunk;\n  /* Allow up to 255 since they are bytes. The ITU-R-BT.709 spec has a more\n  restricted set of valid values for each field, but that's up to the error\n  handling of a CICP library, not the PNG encoding/decoding, to manage. */\n  if(info->cicp_color_primaries > 255) return 116;\n  if(info->cicp_transfer_function > 255) return 116;\n  if(info->cicp_matrix_coefficients > 255) return 116;\n  if(info->cicp_video_full_range_flag > 255) return 116;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, \"cICP\"));\n  chunk[8 + 0] = (unsigned char)info->cicp_color_primaries;\n  chunk[8 + 1] = (unsigned char)info->cicp_transfer_function;\n  chunk[8 + 2] = (unsigned char)info->cicp_matrix_coefficients;\n  chunk[8 + 3] = (unsigned char)info->cicp_video_full_range_flag;\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_mDCv(ucvector* out, const LodePNGInfo* info) {\n  unsigned char* chunk;\n  /* Allow up to 65535 since they are 16-bit ints. */\n  if(info->mdcv_red_x > 65535) return 118;\n  if(info->mdcv_red_y > 65535) return 118;\n  if(info->mdcv_green_x > 65535) return 118;\n  if(info->mdcv_green_y > 65535) return 118;\n  if(info->mdcv_blue_x > 65535) return 118;\n  if(info->mdcv_blue_y > 65535) return 118;\n  if(info->mdcv_white_x > 65535) return 118;\n  if(info->mdcv_white_y > 65535) return 118;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 24, \"mDCv\"));\n  chunk[8 + 0] = (unsigned char)((info->mdcv_red_x) >> 8u);\n  chunk[8 + 1] = (unsigned char)(info->mdcv_red_x);\n  chunk[8 + 2] = (unsigned char)((info->mdcv_red_y) >> 8u);\n  chunk[8 + 3] = (unsigned char)(info->mdcv_red_y);\n  chunk[8 + 4] = (unsigned char)((info->mdcv_green_x) >> 8u);\n  chunk[8 + 5] = (unsigned char)(info->mdcv_green_x);\n  chunk[8 + 6] = (unsigned char)((info->mdcv_green_y) >> 8u);\n  chunk[8 + 7] = (unsigned char)(info->mdcv_green_y);\n  chunk[8 + 8] = (unsigned char)((info->mdcv_blue_x) >> 8u);\n  chunk[8 + 9] = (unsigned char)(info->mdcv_blue_x);\n  chunk[8 + 10] = (unsigned char)((info->mdcv_blue_y) >> 8u);\n  chunk[8 + 11] = (unsigned char)(info->mdcv_blue_y);\n  chunk[8 + 12] = (unsigned char)((info->mdcv_white_x) >> 8u);\n  chunk[8 + 13] = (unsigned char)(info->mdcv_white_x);\n  chunk[8 + 14] = (unsigned char)((info->mdcv_white_y) >> 8u);\n  chunk[8 + 15] = (unsigned char)(info->mdcv_white_y);\n  lodepng_set32bitInt(chunk + 8 + 16, info->mdcv_max_luminance);\n  lodepng_set32bitInt(chunk + 8 + 20, info->mdcv_min_luminance);\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_cLLi(ucvector* out, const LodePNGInfo* info) {\n  unsigned char* chunk;\n  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 8, \"cLLi\"));\n  lodepng_set32bitInt(chunk + 8 + 0, info->clli_max_cll);\n  lodepng_set32bitInt(chunk + 8 + 4, info->clli_max_fall);\n  lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\nstatic unsigned addChunk_eXIf(ucvector* out, const LodePNGInfo* info) {\n  return lodepng_chunk_createv(out, info->exif_size, \"eXIf\", info->exif);\n}\n\nstatic unsigned addChunk_sBIT(ucvector* out, const LodePNGInfo* info) {\n  unsigned bitdepth = (info->color.colortype == LCT_PALETTE) ? 8 : info->color.bitdepth;\n  unsigned char* chunk = 0;\n  if(info->color.colortype == LCT_GREY) {\n    if(info->sbit_r == 0 || info->sbit_r > bitdepth) return 115;\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, \"sBIT\"));\n    chunk[8] = info->sbit_r;\n  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_PALETTE) {\n    if(info->sbit_r == 0 || info->sbit_g == 0 || info->sbit_b == 0) return 115;\n    if(info->sbit_r > bitdepth || info->sbit_g > bitdepth || info->sbit_b > bitdepth) return 115;\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 3, \"sBIT\"));\n    chunk[8] = info->sbit_r;\n    chunk[9] = info->sbit_g;\n    chunk[10] = info->sbit_b;\n  } else if(info->color.colortype == LCT_GREY_ALPHA) {\n    if(info->sbit_r == 0 || info->sbit_a == 0) return 115;\n    if(info->sbit_r > bitdepth || info->sbit_a > bitdepth) return 115;\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, \"sBIT\"));\n    chunk[8] = info->sbit_r;\n    chunk[9] = info->sbit_a;\n  } else if(info->color.colortype == LCT_RGBA) {\n    if(info->sbit_r == 0 || info->sbit_g == 0 || info->sbit_b == 0 || info->sbit_a == 0 ||\n       info->sbit_r > bitdepth || info->sbit_g > bitdepth ||\n       info->sbit_b > bitdepth || info->sbit_a > bitdepth) {\n      return 115;\n    }\n    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, \"sBIT\"));\n    chunk[8] = info->sbit_r;\n    chunk[9] = info->sbit_g;\n    chunk[10] = info->sbit_b;\n    chunk[11] = info->sbit_a;\n  }\n  if(chunk) lodepng_chunk_generate_crc(chunk);\n  return 0;\n}\n\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\nstatic void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,\n                           size_t length, size_t bytewidth, unsigned char filterType) {\n  size_t i;\n  switch(filterType) {\n    case 0: /*None*/\n      for(i = 0; i != length; ++i) out[i] = scanline[i];\n      break;\n    case 1: /*Sub*/\n      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];\n      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];\n      break;\n    case 2: /*Up*/\n      if(prevline) {\n        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];\n      } else {\n        for(i = 0; i != length; ++i) out[i] = scanline[i];\n      }\n      break;\n    case 3: /*Average*/\n      if(prevline) {\n        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);\n        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);\n      } else {\n        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];\n        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);\n      }\n      break;\n    case 4: /*Paeth*/\n      if(prevline) {\n        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/\n        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);\n        for(i = bytewidth; i < length; ++i) {\n          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));\n        }\n      } else {\n        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];\n        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/\n        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);\n      }\n      break;\n    default: return; /*invalid filter type given*/\n  }\n}\n\n/* integer binary logarithm, max return value is 31 */\nstatic size_t ilog2(size_t i) {\n  size_t result = 0;\n  if(i >= 65536) { result += 16; i >>= 16; }\n  if(i >= 256) { result += 8; i >>= 8; }\n  if(i >= 16) { result += 4; i >>= 4; }\n  if(i >= 4) { result += 2; i >>= 2; }\n  if(i >= 2) { result += 1; /*i >>= 1;*/ }\n  return result;\n}\n\n/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */\nstatic size_t ilog2i(size_t i) {\n  size_t l;\n  if(i == 0) return 0;\n  l = ilog2(i);\n  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)\n  linearly approximates the missing fractional part multiplied by i */\n  return i * l + ((i - (((size_t)1) << l)) << 1u);\n}\n\nstatic unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,\n                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {\n  /*\n  For PNG filter method 0\n  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are\n  the scanlines with 1 extra byte per scanline\n  */\n\n  unsigned bpp = lodepng_get_bpp(color);\n  /*the width of a scanline in bytes, not including the filter type*/\n  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;\n\n  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/\n  size_t bytewidth = (bpp + 7u) / 8u;\n  const unsigned char* prevline = 0;\n  unsigned x, y;\n  unsigned error = 0;\n  LodePNGFilterStrategy strategy = settings->filter_strategy;\n\n  if(settings->filter_palette_zero && (color->colortype == LCT_PALETTE || color->bitdepth < 8)) {\n    /*if the filter_palette_zero setting is enabled, override the filter strategy with\n    zero for all scanlines for palette and less-than-8-bitdepth images*/\n    strategy = LFS_ZERO;\n  }\n\n  if(bpp == 0) return 31; /*error: invalid color type*/\n\n  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {\n    unsigned char type = (unsigned char)strategy;\n    for(y = 0; y != h; ++y) {\n      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\n      size_t inindex = linebytes * y;\n      out[outindex] = type; /*filter type byte*/\n      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);\n      prevline = &in[inindex];\n    }\n  } else if(strategy == LFS_MINSUM) {\n    /*adaptive filtering: independently for each row, try all five filter types and select the one that produces the\n    smallest sum of absolute values per row.*/\n    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/\n    size_t smallest = 0;\n    unsigned char type, bestType = 0;\n\n    for(type = 0; type != 5; ++type) {\n      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);\n      if(!attempt[type]) error = 83; /*alloc fail*/\n    }\n\n    if(!error) {\n      for(y = 0; y != h; ++y) {\n        /*try the 5 filter types*/\n        for(type = 0; type != 5; ++type) {\n          size_t sum = 0;\n          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);\n\n          /*calculate the sum of the result*/\n          if(type == 0) {\n            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);\n          } else {\n            for(x = 0; x != linebytes; ++x) {\n              /*For differences, each byte should be treated as signed, values above 127 are negative\n              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.\n              This means filtertype 0 is almost never chosen, but that is justified.*/\n              unsigned char s = attempt[type][x];\n              sum += s < 128 ? s : (255U - s);\n            }\n          }\n\n          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/\n          if(type == 0 || sum < smallest) {\n            bestType = type;\n            smallest = sum;\n          }\n        }\n\n        prevline = &in[y * linebytes];\n\n        /*now fill the out values*/\n        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\n        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];\n      }\n    }\n\n    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);\n  } else if(strategy == LFS_ENTROPY) {\n    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/\n    size_t bestSum = 0;\n    unsigned type, bestType = 0;\n    unsigned count[256];\n\n    for(type = 0; type != 5; ++type) {\n      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);\n      if(!attempt[type]) error = 83; /*alloc fail*/\n    }\n\n    if(!error) {\n      for(y = 0; y != h; ++y) {\n        /*try the 5 filter types*/\n        for(type = 0; type != 5; ++type) {\n          size_t sum = 0;\n          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);\n          lodepng_memset(count, 0, 256 * sizeof(*count));\n          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];\n          ++count[type]; /*the filter type itself is part of the scanline*/\n          for(x = 0; x != 256; ++x) {\n            sum += ilog2i(count[x]);\n          }\n          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/\n          if(type == 0 || sum > bestSum) {\n            bestType = type;\n            bestSum = sum;\n          }\n        }\n\n        prevline = &in[y * linebytes];\n\n        /*now fill the out values*/\n        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\n        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];\n      }\n    }\n\n    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);\n  } else if(strategy == LFS_PREDEFINED) {\n    for(y = 0; y != h; ++y) {\n      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\n      size_t inindex = linebytes * y;\n      unsigned char type = settings->predefined_filters[y];\n      out[outindex] = type; /*filter type byte*/\n      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);\n      prevline = &in[inindex];\n    }\n  } else if(strategy == LFS_BRUTE_FORCE) {\n    /*brute force filter chooser.\n    deflate the scanline after every filter attempt to see which one deflates best.\n    This is very slow and gives only slightly smaller, sometimes even larger, result*/\n    size_t size[5];\n    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/\n    size_t smallest = 0;\n    unsigned type = 0, bestType = 0;\n    unsigned char* dummy;\n    LodePNGCompressSettings zlibsettings;\n    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));\n    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,\n    to simulate the true case where the tree is the same for the whole image. Sometimes it gives\n    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare\n    cases better compression. It does make this a bit less slow, so it's worth doing this.*/\n    zlibsettings.btype = 1;\n    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG\n    images only, so disable it*/\n    zlibsettings.custom_zlib = 0;\n    zlibsettings.custom_deflate = 0;\n    for(type = 0; type != 5; ++type) {\n      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);\n      if(!attempt[type]) error = 83; /*alloc fail*/\n    }\n    if(!error) {\n      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {\n        for(type = 0; type != 5; ++type) {\n          unsigned testsize = (unsigned)linebytes;\n          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/\n\n          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);\n          size[type] = 0;\n          dummy = 0;\n          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);\n          lodepng_free(dummy);\n          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/\n          if(type == 0 || size[type] < smallest) {\n            bestType = type;\n            smallest = size[type];\n          }\n        }\n        prevline = &in[y * linebytes];\n        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\n        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];\n      }\n    }\n    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);\n  }\n  else return 88; /* unknown filter strategy */\n\n  return error;\n}\n\nstatic void addPaddingBits(unsigned char* out, const unsigned char* in,\n                           size_t olinebits, size_t ilinebits, unsigned h) {\n  /*The opposite of the removePaddingBits function\n  olinebits must be >= ilinebits*/\n  unsigned y;\n  size_t diff = olinebits - ilinebits;\n  size_t obp = 0, ibp = 0; /*bit pointers*/\n  for(y = 0; y != h; ++y) {\n    size_t x;\n    for(x = 0; x < ilinebits; ++x) {\n      unsigned char bit = readBitFromReversedStream(&ibp, in);\n      setBitOfReversedStream(&obp, out, bit);\n    }\n    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid\n    \"Use of uninitialised value of size ###\" warning from valgrind*/\n    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);\n  }\n}\n\n/*\nin: non-interlaced image with size w*h\nout: the same pixels, but re-ordered according to PNG's Adam7 interlacing, with\n no padding bits between scanlines, but between reduced images so that each\n reduced image starts at a byte.\nbpp: bits per pixel\nthere are no padding bits, not between scanlines, not between reduced images\nin has the following size in bits: w * h * bpp.\nout is possibly bigger due to padding bits between reduced images\nNOTE: comments about padding bits are only relevant if bpp < 8\n*/\nstatic void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {\n  unsigned passw[7], passh[7];\n  size_t filter_passstart[8], padded_passstart[8], passstart[8];\n  unsigned i;\n\n  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n  if(bpp >= 8) {\n    for(i = 0; i != 7; ++i) {\n      unsigned x, y, b;\n      size_t bytewidth = bpp / 8u;\n      for(y = 0; y < passh[i]; ++y)\n      for(x = 0; x < passw[i]; ++x) {\n        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;\n        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;\n        for(b = 0; b < bytewidth; ++b) {\n          out[pixeloutstart + b] = in[pixelinstart + b];\n        }\n      }\n    }\n  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {\n    for(i = 0; i != 7; ++i) {\n      unsigned x, y, b;\n      unsigned ilinebits = bpp * passw[i];\n      unsigned olinebits = bpp * w;\n      size_t obp, ibp; /*bit pointers (for out and in buffer)*/\n      for(y = 0; y < passh[i]; ++y)\n      for(x = 0; x < passw[i]; ++x) {\n        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;\n        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);\n        for(b = 0; b < bpp; ++b) {\n          unsigned char bit = readBitFromReversedStream(&ibp, in);\n          setBitOfReversedStream(&obp, out, bit);\n        }\n      }\n    }\n  }\n}\n\n/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.\nreturn value is error**/\nstatic unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,\n                                    unsigned w, unsigned h,\n                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {\n  /*\n  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:\n  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter\n  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter\n  */\n  size_t bpp = lodepng_get_bpp(&info_png->color);\n  unsigned error = 0;\n  if(info_png->interlace_method == 0) {\n    /*image size plus an extra byte per scanline + possible padding bits*/\n    *outsize = (size_t)h + ((size_t)h * (((size_t)w * bpp + 7u) / 8u));\n    *out = (unsigned char*)lodepng_malloc(*outsize);\n    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/\n\n    if(!error) {\n      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/\n      if(bpp < 8 && (size_t)w * bpp != (((size_t)w * bpp + 7u) / 8u) * 8u) {\n        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));\n        if(!padded) error = 83; /*alloc fail*/\n        if(!error) {\n          addPaddingBits(padded, in, (((size_t)w * bpp + 7u) / 8u) * 8u, (size_t)w * bpp, h);\n          error = filter(*out, padded, w, h, &info_png->color, settings);\n        }\n        lodepng_free(padded);\n      } else {\n        /*we can immediately filter into the out buffer, no other steps needed*/\n        error = filter(*out, in, w, h, &info_png->color, settings);\n      }\n    }\n  } else /*interlace_method is 1 (Adam7)*/ {\n    unsigned passw[7], passh[7];\n    size_t filter_passstart[8], padded_passstart[8], passstart[8];\n    unsigned char* adam7;\n\n    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, (unsigned)bpp);\n\n    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/\n    *out = (unsigned char*)lodepng_malloc(*outsize);\n    if(!(*out)) error = 83; /*alloc fail*/\n\n    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);\n    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/\n\n    if(!error) {\n      unsigned i;\n\n      Adam7_interlace(adam7, in, w, h, (unsigned)bpp);\n      for(i = 0; i != 7; ++i) {\n        if(bpp < 8) {\n          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);\n          if(!padded) ERROR_BREAK(83); /*alloc fail*/\n          addPaddingBits(padded, &adam7[passstart[i]],\n                         (((size_t)passw[i] * bpp + 7u) / 8u) * 8u, (size_t)passw[i] * bpp, passh[i]);\n          error = filter(&(*out)[filter_passstart[i]], padded,\n                         passw[i], passh[i], &info_png->color, settings);\n          lodepng_free(padded);\n        } else {\n          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],\n                         passw[i], passh[i], &info_png->color, settings);\n        }\n\n        if(error) break;\n      }\n    }\n\n    lodepng_free(adam7);\n  }\n\n  return error;\n}\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\nstatic unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {\n  unsigned char* inchunk = data;\n  while((size_t)(inchunk - data) < datasize) {\n    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));\n    out->allocsize = out->size; /*fix the allocsize again*/\n    inchunk = lodepng_chunk_next(inchunk, data + datasize);\n  }\n  return 0;\n}\n\nstatic unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {\n  /*\n  It is a gray profile if bytes 16-19 are \"GRAY\", rgb profile if bytes 16-19\n  are \"RGB \". We do not perform any full parsing of the ICC profile here, other\n  than check those 4 bytes to grayscale profile. Other than that, validity of\n  the profile is not checked. This is needed only because the PNG specification\n  requires using a non-gray color model if there is an ICC profile with \"RGB \"\n  (sadly limiting compression opportunities if the input data is grayscale RGB\n  data), and requires using a gray color model if it is \"GRAY\".\n  */\n  if(size < 20) return 0;\n  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';\n}\n\nstatic unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {\n  /* See comment in isGrayICCProfile*/\n  if(size < 20) return 0;\n  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\nunsigned lodepng_encode(unsigned char** out, size_t* outsize,\n                        const unsigned char* image, unsigned w, unsigned h,\n                        LodePNGState* state) {\n  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/\n  size_t datasize = 0;\n  ucvector outv = ucvector_init(NULL, 0);\n  LodePNGInfo info;\n  const LodePNGInfo* info_png = &state->info_png;\n  LodePNGColorMode auto_color;\n\n  lodepng_info_init(&info);\n  lodepng_color_mode_init(&auto_color);\n\n  /*provide some proper output values if error will happen*/\n  *out = 0;\n  *outsize = 0;\n  state->error = 0;\n\n  /*check input values validity*/\n  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)\n      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {\n    /*this error is returned even if auto_convert is enabled and thus encoder could\n    generate the palette by itself: while allowing this could be possible in theory,\n    it may complicate the code or edge cases, and always requiring to give a palette\n    when setting this color type is a simpler contract*/\n    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/\n    goto cleanup;\n  }\n  if(state->encoder.zlibsettings.btype > 2) {\n    state->error = 61; /*error: invalid btype*/\n    goto cleanup;\n  }\n  if(info_png->interlace_method > 1) {\n    state->error = 71; /*error: invalid interlace mode*/\n    goto cleanup;\n  }\n  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);\n  if(state->error) goto cleanup; /*error: invalid color type given*/\n  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);\n  if(state->error) goto cleanup; /*error: invalid color type given*/\n\n  /* color convert and compute scanline filter types */\n  lodepng_info_copy(&info, &state->info_png);\n  if(state->encoder.auto_convert) {\n    LodePNGColorStats stats;\n    unsigned allow_convert = 1;\n    lodepng_color_stats_init(&stats);\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    if(info_png->iccp_defined &&\n        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {\n      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even\n      if the palette has only gray colors, so disallow it.*/\n      stats.allow_palette = 0;\n    }\n    if(info_png->iccp_defined &&\n        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {\n      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/\n      stats.allow_greyscale = 0;\n    }\n#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */\n    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);\n    if(state->error) goto cleanup;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    if(info_png->background_defined) {\n      /*the background chunk's color must be taken into account as well*/\n      unsigned r = 0, g = 0, b = 0;\n      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);\n      lodepng_convert_rgb(&r, &g, &b,\n          info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);\n      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);\n      if(state->error) goto cleanup;\n    }\n#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */\n    state->error = auto_choose_color(&auto_color, &state->info_raw, &stats);\n    if(state->error) goto cleanup;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    if(info_png->sbit_defined) {\n      /*if sbit is defined, due to strict requirements of which sbit values can be present for which color modes,\n      auto_convert can't be done in many cases. However, do support a few cases here.\n      TODO: more conversions may be possible, and it may also be possible to get a more appropriate color type out of\n            auto_choose_color if knowledge about sbit is used beforehand\n      */\n      unsigned sbit_max = LODEPNG_MAX(LODEPNG_MAX(LODEPNG_MAX(info_png->sbit_r, info_png->sbit_g),\n                           info_png->sbit_b), info_png->sbit_a);\n      unsigned equal = (!info_png->sbit_g || info_png->sbit_g == info_png->sbit_r)\n                    && (!info_png->sbit_b || info_png->sbit_b == info_png->sbit_r)\n                    && (!info_png->sbit_a || info_png->sbit_a == info_png->sbit_r);\n      allow_convert = 0;\n      if(info.color.colortype == LCT_PALETTE &&\n         auto_color.colortype == LCT_PALETTE) {\n        /* input and output are palette, and in this case it may happen that palette data is\n        expected to be copied from info_raw into the info_png */\n        allow_convert = 1;\n      }\n      /*going from 8-bit RGB to palette (or 16-bit as long as sbit_max <= 8) is possible\n      since both are 8-bit RGB for sBIT's purposes*/\n      if(info.color.colortype == LCT_RGB &&\n         auto_color.colortype == LCT_PALETTE && sbit_max <= 8) {\n        allow_convert = 1;\n      }\n      /*going from 8-bit RGBA to palette is also ok but only if sbit_a is exactly 8*/\n      if(info.color.colortype == LCT_RGBA && auto_color.colortype == LCT_PALETTE &&\n         info_png->sbit_a == 8 && sbit_max <= 8) {\n        allow_convert = 1;\n      }\n      /*going from 16-bit RGB(A) to 8-bit RGB(A) is ok if all sbit values are <= 8*/\n      if((info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA) && info.color.bitdepth == 16 &&\n         auto_color.colortype == info.color.colortype && auto_color.bitdepth == 8 &&\n         sbit_max <= 8) {\n        allow_convert = 1;\n      }\n      /*going to less channels is ok if all bit values are equal (all possible values in sbit,\n        as well as the chosen bitdepth of the result). Due to how auto_convert works,\n        we already know that auto_color.colortype has less than or equal amount of channels than\n        info.colortype. Palette is not used here. This conversion is not allowed if\n        info_png->sbit_r < auto_color.bitdepth, because specifically for alpha, non-presence of\n        an sbit value heavily implies that alpha's bit depth is equal to the PNG bit depth (rather\n        than the bit depths set in the r, g and b sbit values, by how the PNG specification describes\n        handling tRNS chunk case with sBIT), so be conservative here about ignoring user input.*/\n      if(info.color.colortype != LCT_PALETTE && auto_color.colortype != LCT_PALETTE &&\n         equal && info_png->sbit_r == auto_color.bitdepth) {\n        allow_convert = 1;\n      }\n    }\n#endif\n    if(state->encoder.force_palette) {\n      if(info.color.colortype != LCT_GREY && info.color.colortype != LCT_GREY_ALPHA &&\n         (auto_color.colortype == LCT_GREY || auto_color.colortype == LCT_GREY_ALPHA)) {\n        /*user speficially forced a PLTE palette, so cannot convert to grayscale types because\n        the PNG specification only allows writing a suggested palette in PLTE for truecolor types*/\n        allow_convert = 0;\n      }\n    }\n    if(allow_convert) {\n      lodepng_color_mode_copy(&info.color, &auto_color);\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      /*also convert the background chunk*/\n      if(info_png->background_defined) {\n        if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,\n            info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {\n          state->error = 104;\n          goto cleanup;\n        }\n      }\n#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */\n    }\n  }\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  if(info_png->iccp_defined) {\n    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);\n    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);\n    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;\n    if(!gray_icc && !rgb_icc) {\n      state->error = 100; /* Disallowed profile color type for PNG */\n      goto cleanup;\n    }\n    if(gray_icc != gray_png) {\n      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,\n      or in case of auto_convert, it wasn't possible to find appropriate model*/\n      state->error = state->encoder.auto_convert ? 102 : 101;\n      goto cleanup;\n    }\n  }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {\n    unsigned char* converted;\n    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;\n\n    converted = (unsigned char*)lodepng_malloc(size);\n    if(!converted && size) state->error = 83; /*alloc fail*/\n    if(!state->error) {\n      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);\n    }\n    if(!state->error) {\n      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);\n    }\n    lodepng_free(converted);\n    if(state->error) goto cleanup;\n  } else {\n    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);\n    if(state->error) goto cleanup;\n  }\n\n  /* output all PNG chunks */ {\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    size_t i;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    /*write signature and chunks*/\n    state->error = writeSignature(&outv);\n    if(state->error) goto cleanup;\n    /*IHDR*/\n    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);\n    if(state->error) goto cleanup;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    /*unknown chunks between IHDR and PLTE*/\n    if(info.unknown_chunks_data[0]) {\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);\n      if(state->error) goto cleanup;\n    }\n    /*color profile chunks must come before PLTE */\n    if(info.cicp_defined) {\n      state->error = addChunk_cICP(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    if(info.mdcv_defined) {\n      state->error = addChunk_mDCv(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    if(info.clli_defined) {\n      state->error = addChunk_cLLi(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    if(info.iccp_defined) {\n      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);\n      if(state->error) goto cleanup;\n    }\n    if(info.srgb_defined) {\n      state->error = addChunk_sRGB(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    if(info.gama_defined) {\n      state->error = addChunk_gAMA(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    if(info.chrm_defined) {\n      state->error = addChunk_cHRM(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    if(info_png->sbit_defined) {\n      state->error = addChunk_sBIT(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    if(info.exif_defined) {\n      state->error = addChunk_eXIf(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    /*PLTE*/\n    if(info.color.colortype == LCT_PALETTE) {\n      state->error = addChunk_PLTE(&outv, &info.color);\n      if(state->error) goto cleanup;\n    }\n    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {\n      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/\n      state->error = addChunk_PLTE(&outv, &info.color);\n      if(state->error) goto cleanup;\n    }\n    /*tRNS (this will only add if when necessary) */\n    state->error = addChunk_tRNS(&outv, &info.color);\n    if(state->error) goto cleanup;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    /*bKGD (must come between PLTE and the IDAt chunks*/\n    if(info.background_defined) {\n      state->error = addChunk_bKGD(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n    /*pHYs (must come before the IDAT chunks)*/\n    if(info.phys_defined) {\n      state->error = addChunk_pHYs(&outv, &info);\n      if(state->error) goto cleanup;\n    }\n\n    /*unknown chunks between PLTE and IDAT*/\n    if(info.unknown_chunks_data[1]) {\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);\n      if(state->error) goto cleanup;\n    }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    /*IDAT (multiple IDAT chunks must be consecutive)*/\n    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);\n    if(state->error) goto cleanup;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    /*tIME*/\n    if(info.time_defined) {\n      state->error = addChunk_tIME(&outv, &info.time);\n      if(state->error) goto cleanup;\n    }\n    /*tEXt and/or zTXt*/\n    for(i = 0; i != info.text_num; ++i) {\n      if(lodepng_strlen(info.text_keys[i]) > 79) {\n        state->error = 66; /*text chunk too large*/\n        goto cleanup;\n      }\n      if(lodepng_strlen(info.text_keys[i]) < 1) {\n        state->error = 67; /*text chunk too small*/\n        goto cleanup;\n      }\n      if(state->encoder.text_compression) {\n        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);\n        if(state->error) goto cleanup;\n      } else {\n        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);\n        if(state->error) goto cleanup;\n      }\n    }\n    /*LodePNG version id in text chunk*/\n    if(state->encoder.add_id) {\n      unsigned already_added_id_text = 0;\n      for(i = 0; i != info.text_num; ++i) {\n        const char* k = info.text_keys[i];\n        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */\n        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&\n           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\\0') {\n          already_added_id_text = 1;\n          break;\n        }\n      }\n      if(already_added_id_text == 0) {\n        state->error = addChunk_tEXt(&outv, \"LodePNG\", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/\n        if(state->error) goto cleanup;\n      }\n    }\n    /*iTXt*/\n    for(i = 0; i != info.itext_num; ++i) {\n      if(lodepng_strlen(info.itext_keys[i]) > 79) {\n        state->error = 66; /*text chunk too large*/\n        goto cleanup;\n      }\n      if(lodepng_strlen(info.itext_keys[i]) < 1) {\n        state->error = 67; /*text chunk too small*/\n        goto cleanup;\n      }\n      state->error = addChunk_iTXt(\n          &outv, state->encoder.text_compression,\n          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],\n          &state->encoder.zlibsettings);\n      if(state->error) goto cleanup;\n    }\n\n    /*unknown chunks between IDAT and IEND*/\n    if(info.unknown_chunks_data[2]) {\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);\n      if(state->error) goto cleanup;\n    }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    state->error = addChunk_IEND(&outv);\n    if(state->error) goto cleanup;\n  }\n\ncleanup:\n  lodepng_info_cleanup(&info);\n  lodepng_free(data);\n  lodepng_color_mode_cleanup(&auto_color);\n\n  /*instead of cleaning the vector up, give it to the output*/\n  *out = outv.data;\n  *outsize = outv.size;\n\n  return state->error;\n}\n\nunsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,\n                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned error;\n  LodePNGState state;\n  lodepng_state_init(&state);\n  state.info_raw.colortype = colortype;\n  state.info_raw.bitdepth = bitdepth;\n  state.info_png.color.colortype = colortype;\n  state.info_png.color.bitdepth = bitdepth;\n  lodepng_encode(out, outsize, image, w, h, &state);\n  error = state.error;\n  lodepng_state_cleanup(&state);\n  return error;\n}\n\nunsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {\n  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);\n}\n\nunsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {\n  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,\n                             LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned char* buffer;\n  size_t buffersize;\n  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);\n  if(!error) error = lodepng_save_file(buffer, buffersize, filename);\n  lodepng_free(buffer);\n  return error;\n}\n\nunsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {\n  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);\n}\n\nunsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {\n  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);\n}\n#endif /*LODEPNG_COMPILE_DISK*/\n\nvoid lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {\n  lodepng_compress_settings_init(&settings->zlibsettings);\n  settings->filter_palette_zero = 1;\n  settings->filter_strategy = LFS_MINSUM;\n  settings->auto_convert = 1;\n  settings->force_palette = 0;\n  settings->predefined_filters = 0;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  settings->add_id = 0;\n  settings->text_compression = 1;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n}\n\n#endif /*LODEPNG_COMPILE_ENCODER*/\n#endif /*LODEPNG_COMPILE_PNG*/\n\n#ifdef LODEPNG_COMPILE_ERROR_TEXT\n/*\nThis returns the description of a numerical error code in English. This is also\nthe documentation of all the error codes.\n*/\nconst char* lodepng_error_text(unsigned code) {\n  switch(code) {\n    case 0: return \"no error, everything went ok\";\n    case 1: return \"nothing done yet\"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/\n    case 10: return \"end of input memory reached without huffman end code\"; /*while huffman decoding*/\n    case 11: return \"error in code tree made it jump outside of huffman tree\"; /*while huffman decoding*/\n    case 13: return \"problem while processing dynamic deflate block\";\n    case 14: return \"problem while processing dynamic deflate block\";\n    case 15: return \"problem while processing dynamic deflate block\";\n    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/\n    case 16: return \"invalid code while processing dynamic deflate block\";\n    case 17: return \"end of out buffer memory reached while inflating\";\n    case 18: return \"invalid distance code while inflating\";\n    case 19: return \"end of out buffer memory reached while inflating\";\n    case 20: return \"invalid deflate block BTYPE encountered while decoding\";\n    case 21: return \"NLEN is not ones complement of LEN in a deflate block\";\n\n    /*end of out buffer memory reached while inflating:\n    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up\n    all the pixels of the image, given the color depth and image dimensions. Something that doesn't\n    happen in a normal, well encoded, PNG image.*/\n    case 22: return \"end of out buffer memory reached while inflating\";\n    case 23: return \"end of in buffer memory reached while inflating\";\n    case 24: return \"invalid FCHECK in zlib header\";\n    case 25: return \"invalid compression method in zlib header\";\n    case 26: return \"FDICT encountered in zlib header while it's not used for PNG\";\n    case 27: return \"PNG file is smaller than a PNG header\";\n    /*Checks the magic file header, the first 8 bytes of the PNG file*/\n    case 28: return \"incorrect PNG signature, it's no PNG or corrupted\";\n    case 29: return \"first chunk is not the header chunk\";\n    case 30: return \"chunk length too large, chunk broken off at end of file\";\n    case 31: return \"illegal PNG color type or bpp\";\n    case 32: return \"illegal PNG compression method\";\n    case 33: return \"illegal PNG filter method\";\n    case 34: return \"illegal PNG interlace method\";\n    case 35: return \"chunk length of a chunk is too large or the chunk too small\";\n    case 36: return \"illegal PNG filter type encountered\";\n    case 37: return \"illegal bit depth for this color type given\";\n    case 38: return \"the palette is too small or too big\"; /*0, or more than 256 colors*/\n    case 39: return \"tRNS chunk before PLTE or has more entries than palette size\";\n    case 40: return \"tRNS chunk has wrong size for grayscale image\";\n    case 41: return \"tRNS chunk has wrong size for RGB image\";\n    case 42: return \"tRNS chunk appeared while it was not allowed for this color type\";\n    case 43: return \"bKGD chunk has wrong size for palette image\";\n    case 44: return \"bKGD chunk has wrong size for grayscale image\";\n    case 45: return \"bKGD chunk has wrong size for RGB image\";\n    case 48: return \"empty input buffer given to decoder. Maybe caused by non-existing file?\";\n    case 49: return \"jumped past memory while generating dynamic huffman tree\";\n    case 50: return \"jumped past memory while generating dynamic huffman tree\";\n    case 51: return \"jumped past memory while inflating huffman block\";\n    case 52: return \"jumped past memory while inflating\";\n    case 53: return \"size of zlib data too small\";\n    case 54: return \"repeat symbol in tree while there was no value symbol yet\";\n    /*jumped past tree while generating huffman tree, this could be when the\n    tree will have more leaves than symbols after generating it out of the\n    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/\n    case 55: return \"jumped past tree while generating huffman tree\";\n    case 56: return \"given output image colortype or bitdepth not supported for color conversion\";\n    case 57: return \"invalid CRC encountered (checking CRC can be disabled)\";\n    case 58: return \"invalid ADLER32 encountered (checking ADLER32 can be disabled)\";\n    case 59: return \"requested color conversion not supported\";\n    case 60: return \"invalid window size given in the settings of the encoder (must be 0-32768)\";\n    case 61: return \"invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)\";\n    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/\n    case 62: return \"conversion from color to grayscale not supported\";\n    /*(2^31-1)*/\n    case 63: return \"length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk\";\n    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/\n    case 64: return \"the length of the END symbol 256 in the Huffman tree is 0\";\n    case 66: return \"the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes\";\n    case 67: return \"the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte\";\n    case 68: return \"tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors\";\n    case 69: return \"unknown chunk type with 'critical' flag encountered by the decoder\";\n    case 71: return \"invalid interlace mode given to encoder (must be 0 or 1)\";\n    case 72: return \"while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)\";\n    case 73: return \"invalid tIME chunk size\";\n    case 74: return \"invalid pHYs chunk size\";\n    /*length could be wrong, or data chopped off*/\n    case 75: return \"no null termination char found while decoding text chunk\";\n    case 76: return \"iTXt chunk too short to contain required bytes\";\n    case 77: return \"integer overflow in buffer size\";\n    case 78: return \"failed to open file for reading\"; /*file doesn't exist or couldn't be opened for reading*/\n    case 79: return \"failed to open file for writing\";\n    case 80: return \"tried creating a tree of 0 symbols\";\n    case 81: return \"lazy matching at pos 0 is impossible\";\n    case 82: return \"color conversion to palette requested while a color isn't in palette, or index out of bounds\";\n    case 83: return \"memory allocation failed\";\n    case 84: return \"given image too small to contain all pixels to be encoded\";\n    case 86: return \"impossible offset in lz77 encoding (internal bug)\";\n    case 87: return \"must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined\";\n    case 88: return \"invalid filter strategy given for LodePNGEncoderSettings.filter_strategy\";\n    case 89: return \"text chunk keyword too short or long: must have size 1-79\";\n    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/\n    case 90: return \"windowsize must be a power of two\";\n    case 91: return \"invalid decompressed idat size\";\n    case 92: return \"integer overflow due to too many pixels\";\n    case 93: return \"zero width or height is invalid\";\n    case 94: return \"header chunk must have a size of 13 bytes\";\n    case 95: return \"integer overflow with combined idat chunk size\";\n    case 96: return \"invalid gAMA chunk size\";\n    case 97: return \"invalid cHRM chunk size\";\n    case 98: return \"invalid sRGB chunk size\";\n    case 99: return \"invalid sRGB rendering intent\";\n    case 100: return \"invalid ICC profile color type, the PNG specification only allows RGB or GRAY\";\n    case 101: return \"PNG specification does not allow RGB ICC profile on gray color types and vice versa\";\n    case 102: return \"not allowed to set grayscale ICC profile with colored pixels by PNG specification\";\n    case 103: return \"invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?\";\n    case 104: return \"invalid bKGD color while encoding (e.g. palette index out of range)\";\n    case 105: return \"integer overflow of bitsize\";\n    case 106: return \"PNG file must have PLTE chunk if color type is palette\";\n    case 107: return \"color convert from palette mode requested without setting the palette data in it\";\n    case 108: return \"tried to add more than 256 values to a palette\";\n    /*this limit can be configured in LodePNGDecompressSettings*/\n    case 109: return \"tried to decompress zlib or deflate data larger than desired max_output_size\";\n    case 110: return \"custom zlib or inflate decompression failed\";\n    case 111: return \"custom zlib or deflate compression failed\";\n    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents\n    unreasonable memory consumption when decoding due to impossibly large text sizes.*/\n    case 112: return \"compressed text unreasonably large\";\n    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents\n    unreasonable memory consumption when decoding due to impossibly large ICC profile*/\n    case 113: return \"ICC profile unreasonably large\";\n    case 114: return \"sBIT chunk has wrong size for the color type of the image\";\n    case 115: return \"sBIT value out of range\";\n    case 116: return \"cICP value out of range\";\n    case 117: return \"invalid cICP chunk size\";\n    case 118: return \"mDCv value out of range\";\n    case 119: return \"invalid mDCv chunk size\";\n    case 120: return \"invalid cLLi chunk size\";\n    case 121: return \"invalid chunk type name: may only contain [a-zA-Z]\";\n    case 122: return \"invalid chunk type name: third character must be uppercase\";\n  }\n  return \"unknown error code\";\n}\n#endif /*LODEPNG_COMPILE_ERROR_TEXT*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // C++ Wrapper                                                          // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_CPP\nnamespace lodepng {\n\n#ifdef LODEPNG_COMPILE_DISK\n/* Resizes the vector to the file size and reads the file into it. Returns error code.*/\nstatic unsigned load_file_(std::vector<unsigned char>& buffer, FILE* file) {\n  long size = lodepng_filesize(file);\n  if(size < 0) return 78;\n  buffer.resize((size_t)size);\n  if(size == 0) return 0; /*ok*/\n  if(fread(&buffer[0], 1, buffer.size(), file) != buffer.size()) return 78;\n  return 0; /*ok*/\n}\n\nunsigned load_file(std::vector<unsigned char>& buffer, const std::string& filename) {\n  unsigned error;\n  FILE* file = fopen(filename.c_str(), \"rb\");\n  if(!file) return 78;\n  error = load_file_(buffer, file);\n  fclose(file);\n  return error;\n}\n\n/*write given buffer to the file, overwriting the file, it doesn't append to it.*/\nunsigned save_file(const std::vector<unsigned char>& buffer, const std::string& filename) {\n  return lodepng_save_file(buffer.empty() ? 0 : &buffer[0], buffer.size(), filename.c_str());\n}\n#endif /* LODEPNG_COMPILE_DISK */\n\n#ifdef LODEPNG_COMPILE_ZLIB\n#ifdef LODEPNG_COMPILE_DECODER\nunsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\n                    const LodePNGDecompressSettings& settings) {\n  unsigned char* buffer = 0;\n  size_t buffersize = 0;\n  unsigned error = zlib_decompress(&buffer, &buffersize, 0, in, insize, &settings);\n  if(buffer) {\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\n                    const LodePNGDecompressSettings& settings) {\n  return decompress(out, in.empty() ? 0 : &in[0], in.size(), settings);\n}\n#endif /* LODEPNG_COMPILE_DECODER */\n\n#ifdef LODEPNG_COMPILE_ENCODER\nunsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\n                  const LodePNGCompressSettings& settings) {\n  unsigned char* buffer = 0;\n  size_t buffersize = 0;\n  unsigned error = zlib_compress(&buffer, &buffersize, in, insize, &settings);\n  if(buffer) {\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\n                  const LodePNGCompressSettings& settings) {\n  return compress(out, in.empty() ? 0 : &in[0], in.size(), settings);\n}\n#endif /* LODEPNG_COMPILE_ENCODER */\n#endif /* LODEPNG_COMPILE_ZLIB */\n\n\n#ifdef LODEPNG_COMPILE_PNG\n\nState::State() {\n  lodepng_state_init(this);\n}\n\nState::State(const State& other) {\n  lodepng_state_init(this);\n  lodepng_state_copy(this, &other);\n}\n\nState::~State() {\n  lodepng_state_cleanup(this);\n}\n\nState& State::operator=(const State& other) {\n  lodepng_state_copy(this, &other);\n  return *this;\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const unsigned char* in,\n                size_t insize, LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned char* buffer = 0;\n  unsigned error = lodepng_decode_memory(&buffer, &w, &h, in, insize, colortype, bitdepth);\n  if(buffer && !error) {\n    State state;\n    state.info_raw.colortype = colortype;\n    state.info_raw.bitdepth = bitdepth;\n    size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n  }\n  lodepng_free(buffer);\n  return error;\n}\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                const std::vector<unsigned char>& in, LodePNGColorType colortype, unsigned bitdepth) {\n  return decode(out, w, h, in.empty() ? 0 : &in[0], (unsigned)in.size(), colortype, bitdepth);\n}\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                State& state,\n                const unsigned char* in, size_t insize) {\n  unsigned char* buffer = NULL;\n  unsigned error = lodepng_decode(&buffer, &w, &h, &state, in, insize);\n  if(buffer && !error) {\n    size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n  }\n  lodepng_free(buffer);\n  return error;\n}\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                State& state,\n                const std::vector<unsigned char>& in) {\n  return decode(out, w, h, state, in.empty() ? 0 : &in[0], in.size());\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const std::string& filename,\n                LodePNGColorType colortype, unsigned bitdepth) {\n  std::vector<unsigned char> buffer;\n  /* safe output values in case error happens */\n  w = h = 0;\n  unsigned error = load_file(buffer, filename);\n  if(error) return error;\n  return decode(out, w, h, buffer, colortype, bitdepth);\n}\n#endif /* LODEPNG_COMPILE_DECODER */\n#endif /* LODEPNG_COMPILE_DISK */\n\n#ifdef LODEPNG_COMPILE_ENCODER\nunsigned encode(std::vector<unsigned char>& out, const unsigned char* in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth) {\n  unsigned char* buffer;\n  size_t buffersize;\n  unsigned error = lodepng_encode_memory(&buffer, &buffersize, in, w, h, colortype, bitdepth);\n  if(buffer) {\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned encode(std::vector<unsigned char>& out,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth) {\n  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;\n  return encode(out, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);\n}\n\nunsigned encode(std::vector<unsigned char>& out,\n                const unsigned char* in, unsigned w, unsigned h,\n                State& state) {\n  unsigned char* buffer;\n  size_t buffersize;\n  unsigned error = lodepng_encode(&buffer, &buffersize, in, w, h, &state);\n  if(buffer) {\n    out.insert(out.end(), buffer, &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned encode(std::vector<unsigned char>& out,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                State& state) {\n  if(lodepng_get_raw_size(w, h, &state.info_raw) > in.size()) return 84;\n  return encode(out, in.empty() ? 0 : &in[0], w, h, state);\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned encode(const std::string& filename,\n                const unsigned char* in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth) {\n  std::vector<unsigned char> buffer;\n  unsigned error = encode(buffer, in, w, h, colortype, bitdepth);\n  if(!error) error = save_file(buffer, filename);\n  return error;\n}\n\nunsigned encode(const std::string& filename,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth) {\n  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;\n  return encode(filename, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);\n}\n#endif /* LODEPNG_COMPILE_DISK */\n#endif /* LODEPNG_COMPILE_ENCODER */\n#endif /* LODEPNG_COMPILE_PNG */\n} /* namespace lodepng */\n#endif /*LODEPNG_COMPILE_CPP*/\n"
        },
        {
          "name": "lodepng.h",
          "type": "blob",
          "size": 105.0224609375,
          "content": "/*\nLodePNG version 20241228\n\nCopyright (c) 2005-2024 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n#ifndef LODEPNG_H\n#define LODEPNG_H\n\n#include <string.h> /*for size_t*/\n\nextern const char* LODEPNG_VERSION_STRING;\n\n/*\nThe following #defines are used to create code sections. They can be disabled\nto disable code sections, which can give faster compile time and smaller binary.\nThe \"NO_COMPILE\" defines are designed to be used to pass as defines to the\ncompiler command to disable them without modifying this header, e.g.\n-DLODEPNG_NO_COMPILE_ZLIB for gcc or clang.\n*/\n/*deflate & zlib. If disabled, you must specify alternative zlib functions in\nthe custom_zlib field of the compress and decompress settings*/\n#ifndef LODEPNG_NO_COMPILE_ZLIB\n/*pass -DLODEPNG_NO_COMPILE_ZLIB to the compiler to disable this, or comment out LODEPNG_COMPILE_ZLIB below*/\n#define LODEPNG_COMPILE_ZLIB\n#endif\n\n/*png encoder and png decoder*/\n#ifndef LODEPNG_NO_COMPILE_PNG\n/*pass -DLODEPNG_NO_COMPILE_PNG to the compiler to disable this, or comment out LODEPNG_COMPILE_PNG below*/\n#define LODEPNG_COMPILE_PNG\n#endif\n\n/*deflate&zlib decoder and png decoder*/\n#ifndef LODEPNG_NO_COMPILE_DECODER\n/*pass -DLODEPNG_NO_COMPILE_DECODER to the compiler to disable this, or comment out LODEPNG_COMPILE_DECODER below*/\n#define LODEPNG_COMPILE_DECODER\n#endif\n\n/*deflate&zlib encoder and png encoder*/\n#ifndef LODEPNG_NO_COMPILE_ENCODER\n/*pass -DLODEPNG_NO_COMPILE_ENCODER to the compiler to disable this, or comment out LODEPNG_COMPILE_ENCODER below*/\n#define LODEPNG_COMPILE_ENCODER\n#endif\n\n/*the optional built in harddisk file loading and saving functions*/\n#ifndef LODEPNG_NO_COMPILE_DISK\n/*pass -DLODEPNG_NO_COMPILE_DISK to the compiler to disable this, or comment out LODEPNG_COMPILE_DISK below*/\n#define LODEPNG_COMPILE_DISK\n#endif\n\n/*support for chunks other than IHDR, IDAT, PLTE, tRNS, IEND: ancillary and unknown chunks*/\n#ifndef LODEPNG_NO_COMPILE_ANCILLARY_CHUNKS\n/*pass -DLODEPNG_NO_COMPILE_ANCILLARY_CHUNKS to the compiler to disable this,\nor comment out LODEPNG_COMPILE_ANCILLARY_CHUNKS below*/\n#define LODEPNG_COMPILE_ANCILLARY_CHUNKS\n#endif\n\n/*ability to convert error numerical codes to English text string*/\n#ifndef LODEPNG_NO_COMPILE_ERROR_TEXT\n/*pass -DLODEPNG_NO_COMPILE_ERROR_TEXT to the compiler to disable this,\nor comment out LODEPNG_COMPILE_ERROR_TEXT below*/\n#define LODEPNG_COMPILE_ERROR_TEXT\n#endif\n\n/*Compile the default allocators (C's free, malloc and realloc). If you disable this,\nyou can define the functions lodepng_free, lodepng_malloc and lodepng_realloc in your\nsource files with custom allocators.*/\n#ifndef LODEPNG_NO_COMPILE_ALLOCATORS\n/*pass -DLODEPNG_NO_COMPILE_ALLOCATORS to the compiler to disable the built-in ones,\nor comment out LODEPNG_COMPILE_ALLOCATORS below*/\n#define LODEPNG_COMPILE_ALLOCATORS\n#endif\n\n/*Disable built-in CRC function, in that case a custom implementation of\nlodepng_crc32 must be defined externally so that it can be linked in.\nThe default built-in CRC code comes with 8KB of lookup tables, so for memory constrained environment you may want it\ndisabled and provide a much smaller implementation externally as said above. You can find such an example implementation\nin a comment in the lodepng.c(pp) file in the 'else' case of the searchable LODEPNG_COMPILE_CRC section.*/\n#ifndef LODEPNG_NO_COMPILE_CRC\n/*pass -DLODEPNG_NO_COMPILE_CRC to the compiler to disable the built-in one,\nor comment out LODEPNG_COMPILE_CRC below*/\n#define LODEPNG_COMPILE_CRC\n#endif\n\n/*compile the C++ version (you can disable the C++ wrapper here even when compiling for C++)*/\n#ifdef __cplusplus\n#ifndef LODEPNG_NO_COMPILE_CPP\n/*pass -DLODEPNG_NO_COMPILE_CPP to the compiler to disable C++ (not needed if a C-only compiler),\nor comment out LODEPNG_COMPILE_CPP below*/\n#define LODEPNG_COMPILE_CPP\n#endif\n#endif\n\n#ifdef LODEPNG_COMPILE_CPP\n#include <vector>\n#include <string>\n#endif /*LODEPNG_COMPILE_CPP*/\n\n#ifdef LODEPNG_COMPILE_PNG\n/*The PNG color types (also used for raw image).*/\ntypedef enum LodePNGColorType {\n  LCT_GREY = 0, /*grayscale: 1,2,4,8,16 bit*/\n  LCT_RGB = 2, /*RGB: 8,16 bit*/\n  LCT_PALETTE = 3, /*palette: 1,2,4,8 bit*/\n  LCT_GREY_ALPHA = 4, /*grayscale with alpha: 8,16 bit*/\n  LCT_RGBA = 6, /*RGB with alpha: 8,16 bit*/\n  /*LCT_MAX_OCTET_VALUE lets the compiler allow this enum to represent any invalid\n  byte value from 0 to 255 that could be present in an invalid PNG file header. Do\n  not use, compare with or set the name LCT_MAX_OCTET_VALUE, instead either use\n  the valid color type names above, or numeric values like 1 or 7 when checking for\n  particular disallowed color type byte values, or cast to integer to print it.*/\n  LCT_MAX_OCTET_VALUE = 255\n} LodePNGColorType;\n\n#ifdef LODEPNG_COMPILE_DECODER\n/*\nConverts PNG data in memory to raw pixel data.\nout: Output parameter. Pointer to buffer that will contain the raw pixel data.\n     After decoding, its size is w * h * (bytes per pixel) bytes larger than\n     initially. Bytes per pixel depends on colortype and bitdepth.\n     Must be freed after usage with free(*out).\n     Note: for 16-bit per channel colors, uses big endian format like PNG does.\nw: Output parameter. Pointer to width of pixel data.\nh: Output parameter. Pointer to height of pixel data.\nin: Memory buffer with the PNG file.\ninsize: size of the in buffer.\ncolortype: the desired color type for the raw output image. See explanation on PNG color types.\nbitdepth: the desired bit depth for the raw output image. See explanation on PNG color types.\nReturn value: LodePNG error code (0 means no error).\n*/\nunsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h,\n                               const unsigned char* in, size_t insize,\n                               LodePNGColorType colortype, unsigned bitdepth);\n\n/*Same as lodepng_decode_memory, but always decodes to 32-bit RGBA raw image*/\nunsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h,\n                          const unsigned char* in, size_t insize);\n\n/*Same as lodepng_decode_memory, but always decodes to 24-bit RGB raw image*/\nunsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h,\n                          const unsigned char* in, size_t insize);\n\n#ifdef LODEPNG_COMPILE_DISK\n/*\nLoad PNG from disk, from file with given name.\nSame as the other decode functions, but instead takes a filename as input.\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and decode in-memory.*/\nunsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h,\n                             const char* filename,\n                             LodePNGColorType colortype, unsigned bitdepth);\n\n/*Same as lodepng_decode_file, but always decodes to 32-bit RGBA raw image.\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and decode in-memory.*/\nunsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h,\n                               const char* filename);\n\n/*Same as lodepng_decode_file, but always decodes to 24-bit RGB raw image.\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and decode in-memory.*/\nunsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h,\n                               const char* filename);\n#endif /*LODEPNG_COMPILE_DISK*/\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n\n#ifdef LODEPNG_COMPILE_ENCODER\n/*\nConverts raw pixel data into a PNG image in memory. The colortype and bitdepth\n  of the output PNG image cannot be chosen, they are automatically determined\n  by the colortype, bitdepth and content of the input pixel data.\n  Note: for 16-bit per channel colors, needs big endian format like PNG does.\nout: Output parameter. Pointer to buffer that will contain the PNG image data.\n     Must be freed after usage with free(*out).\noutsize: Output parameter. Pointer to the size in bytes of the out buffer.\nimage: The raw pixel data to encode. The size of this buffer should be\n       w * h * (bytes per pixel), bytes per pixel depends on colortype and bitdepth.\nw: width of the raw pixel data in pixels.\nh: height of the raw pixel data in pixels.\ncolortype: the color type of the raw input image. See explanation on PNG color types.\nbitdepth: the bit depth of the raw input image. See explanation on PNG color types.\nReturn value: LodePNG error code (0 means no error).\n*/\nunsigned lodepng_encode_memory(unsigned char** out, size_t* outsize,\n                               const unsigned char* image, unsigned w, unsigned h,\n                               LodePNGColorType colortype, unsigned bitdepth);\n\n/*Same as lodepng_encode_memory, but always encodes from 32-bit RGBA raw image.*/\nunsigned lodepng_encode32(unsigned char** out, size_t* outsize,\n                          const unsigned char* image, unsigned w, unsigned h);\n\n/*Same as lodepng_encode_memory, but always encodes from 24-bit RGB raw image.*/\nunsigned lodepng_encode24(unsigned char** out, size_t* outsize,\n                          const unsigned char* image, unsigned w, unsigned h);\n\n#ifdef LODEPNG_COMPILE_DISK\n/*\nConverts raw pixel data into a PNG file on disk.\nSame as the other encode functions, but instead takes a filename as output.\n\nNOTE: This overwrites existing files without warning!\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and encode in-memory.*/\nunsigned lodepng_encode_file(const char* filename,\n                             const unsigned char* image, unsigned w, unsigned h,\n                             LodePNGColorType colortype, unsigned bitdepth);\n\n/*Same as lodepng_encode_file, but always encodes from 32-bit RGBA raw image.\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and encode in-memory.*/\nunsigned lodepng_encode32_file(const char* filename,\n                               const unsigned char* image, unsigned w, unsigned h);\n\n/*Same as lodepng_encode_file, but always encodes from 24-bit RGB raw image.\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and encode in-memory.*/\nunsigned lodepng_encode24_file(const char* filename,\n                               const unsigned char* image, unsigned w, unsigned h);\n#endif /*LODEPNG_COMPILE_DISK*/\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n\n#ifdef LODEPNG_COMPILE_CPP\nnamespace lodepng {\n#ifdef LODEPNG_COMPILE_DECODER\n/*Same as lodepng_decode_memory, but decodes to an std::vector. The colortype\nis the format to output the pixels to. Default is RGBA 8-bit per channel.*/\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                const unsigned char* in, size_t insize,\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                const std::vector<unsigned char>& in,\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\n#ifdef LODEPNG_COMPILE_DISK\n/*\nConverts PNG file from disk to raw pixel data in memory.\nSame as the other decode functions, but instead takes a filename as input.\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and decode in-memory.\n*/\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                const std::string& filename,\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\n#endif /* LODEPNG_COMPILE_DISK */\n#endif /* LODEPNG_COMPILE_DECODER */\n\n#ifdef LODEPNG_COMPILE_ENCODER\n/*Same as lodepng_encode_memory, but encodes to an std::vector. colortype\nis that of the raw input data. The output PNG color type will be auto chosen.*/\nunsigned encode(std::vector<unsigned char>& out,\n                const unsigned char* in, unsigned w, unsigned h,\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\nunsigned encode(std::vector<unsigned char>& out,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\n#ifdef LODEPNG_COMPILE_DISK\n/*\nConverts 32-bit RGBA raw pixel data into a PNG file on disk.\nSame as the other encode functions, but instead takes a filename as output.\n\nNOTE: This overwrites existing files without warning!\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and decode in-memory.\n*/\nunsigned encode(const std::string& filename,\n                const unsigned char* in, unsigned w, unsigned h,\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\nunsigned encode(const std::string& filename,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);\n#endif /* LODEPNG_COMPILE_DISK */\n#endif /* LODEPNG_COMPILE_ENCODER */\n} /* namespace lodepng */\n#endif /*LODEPNG_COMPILE_CPP*/\n#endif /*LODEPNG_COMPILE_PNG*/\n\n#ifdef LODEPNG_COMPILE_ERROR_TEXT\n/*Returns an English description of the numerical error code.*/\nconst char* lodepng_error_text(unsigned code);\n#endif /*LODEPNG_COMPILE_ERROR_TEXT*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n/*Settings for zlib decompression*/\ntypedef struct LodePNGDecompressSettings LodePNGDecompressSettings;\nstruct LodePNGDecompressSettings {\n  /* Check LodePNGDecoderSettings for more ignorable errors such as ignore_crc */\n  unsigned ignore_adler32; /*if 1, continue and don't give an error message if the Adler32 checksum is corrupted*/\n  unsigned ignore_nlen; /*ignore complement of len checksum in uncompressed blocks*/\n\n  /*Maximum decompressed size, beyond this the decoder may (and is encouraged to) stop decoding,\n  return an error, output a data size > max_output_size and all the data up to that point. This is\n  not hard limit nor a guarantee, but can prevent excessive memory usage. This setting is\n  ignored by the PNG decoder, but is used by the deflate/zlib decoder and can be used by custom ones.\n  Set to 0 to impose no limit (the default).*/\n  size_t max_output_size;\n\n  /*use custom zlib decoder instead of built in one (default: null).\n  Should return 0 if success, any non-0 if error (numeric value not exposed).*/\n  unsigned (*custom_zlib)(unsigned char**, size_t*,\n                          const unsigned char*, size_t,\n                          const LodePNGDecompressSettings*);\n  /*use custom deflate decoder instead of built in one (default: null)\n  if custom_zlib is not null, custom_inflate is ignored (the zlib format uses deflate).\n  Should return 0 if success, any non-0 if error (numeric value not exposed).*/\n  unsigned (*custom_inflate)(unsigned char**, size_t*,\n                             const unsigned char*, size_t,\n                             const LodePNGDecompressSettings*);\n\n  const void* custom_context; /*optional custom settings for custom functions*/\n};\n\nextern const LodePNGDecompressSettings lodepng_default_decompress_settings;\nvoid lodepng_decompress_settings_init(LodePNGDecompressSettings* settings);\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_ENCODER\n/*\nSettings for zlib compression. Tweaking these settings tweaks the balance\nbetween speed and compression ratio.\n*/\ntypedef struct LodePNGCompressSettings LodePNGCompressSettings;\nstruct LodePNGCompressSettings /*deflate = compress*/ {\n  /*LZ77 related settings*/\n  unsigned btype; /*the block type for LZ (0, 1, 2 or 3, see zlib standard). Should be 2 for proper compression.*/\n  unsigned use_lz77; /*whether or not to use LZ77. Should be 1 for proper compression.*/\n  unsigned windowsize; /*must be a power of two <= 32768. higher compresses more but is slower. Default value: 2048.*/\n  unsigned minmatch; /*minimum lz77 length. 3 is normally best, 6 can be better for some PNGs. Default: 0*/\n  unsigned nicematch; /*stop searching if >= this length found. Set to 258 for best compression. Default: 128*/\n  unsigned lazymatching; /*use lazy matching: better compression but a bit slower. Default: true*/\n\n  /*use custom zlib encoder instead of built in one (default: null)*/\n  unsigned (*custom_zlib)(unsigned char**, size_t*,\n                          const unsigned char*, size_t,\n                          const LodePNGCompressSettings*);\n  /*use custom deflate encoder instead of built in one (default: null)\n  if custom_zlib is used, custom_deflate is ignored since only the built in\n  zlib function will call custom_deflate*/\n  unsigned (*custom_deflate)(unsigned char**, size_t*,\n                             const unsigned char*, size_t,\n                             const LodePNGCompressSettings*);\n\n  const void* custom_context; /*optional custom settings for custom functions*/\n};\n\nextern const LodePNGCompressSettings lodepng_default_compress_settings;\nvoid lodepng_compress_settings_init(LodePNGCompressSettings* settings);\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#ifdef LODEPNG_COMPILE_PNG\n/*\nColor mode of an image. Contains all information required to decode the pixel\nbits to RGBA colors. This information is the same as used in the PNG file\nformat, and is used both for PNG and raw image data in LodePNG.\n*/\ntypedef struct LodePNGColorMode {\n  /*header (IHDR)*/\n  LodePNGColorType colortype; /*color type, see PNG standard or documentation further in this header file*/\n  unsigned bitdepth;  /*bits per sample, see PNG standard or documentation further in this header file*/\n\n  /*\n  palette (PLTE and tRNS)\n\n  Dynamically allocated with the colors of the palette, including alpha.\n  This field may not be allocated directly, use lodepng_color_mode_init first,\n  then lodepng_palette_add per color to correctly initialize it (to ensure size\n  of exactly 1024 bytes).\n\n  The alpha channels must be set as well, set them to 255 for opaque images.\n\n  When decoding, with the default settings you can ignore this palette, since\n  LodePNG already fills the palette colors in the pixels of the raw RGBA output,\n  but when decoding to the original PNG color mode it is needed to reconstruct\n  the colors.\n\n  The palette is only supported for color type 3.\n  */\n  unsigned char* palette; /*palette in RGBARGBA... order. Must be either 0, or when allocated must have 1024 bytes*/\n  size_t palettesize; /*palette size in number of colors (amount of used bytes is 4 * palettesize)*/\n\n  /*\n  transparent color key (tRNS)\n\n  This color uses the same bit depth as the bitdepth value in this struct, which can be 1-bit to 16-bit.\n  For grayscale PNGs, r, g and b will all 3 be set to the same.\n\n  When decoding, by default you can ignore this information, since LodePNG sets\n  pixels with this key to transparent already in the raw RGBA output.\n\n  The color key is only supported for color types 0 and 2.\n  */\n  unsigned key_defined; /*is a transparent color key given? 0 = false, 1 = true*/\n  unsigned key_r;       /*red/grayscale component of color key*/\n  unsigned key_g;       /*green component of color key*/\n  unsigned key_b;       /*blue component of color key*/\n} LodePNGColorMode;\n\n/*init, cleanup and copy functions to use with this struct*/\nvoid lodepng_color_mode_init(LodePNGColorMode* info);\nvoid lodepng_color_mode_cleanup(LodePNGColorMode* info);\n/*return value is error code (0 means no error)*/\nunsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source);\n/* Makes a temporary LodePNGColorMode that does not need cleanup (no palette) */\nLodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth);\n\nvoid lodepng_palette_clear(LodePNGColorMode* info);\n/*add 1 color to the palette*/\nunsigned lodepng_palette_add(LodePNGColorMode* info,\n                             unsigned char r, unsigned char g, unsigned char b, unsigned char a);\n\n/*get the total amount of bits per pixel, based on colortype and bitdepth in the struct*/\nunsigned lodepng_get_bpp(const LodePNGColorMode* info);\n/*get the amount of color channels used, based on colortype in the struct.\nIf a palette is used, it counts as 1 channel.*/\nunsigned lodepng_get_channels(const LodePNGColorMode* info);\n/*is it a grayscale type? (only colortype 0 or 4)*/\nunsigned lodepng_is_greyscale_type(const LodePNGColorMode* info);\n/*has it got an alpha channel? (only colortype 2 or 6)*/\nunsigned lodepng_is_alpha_type(const LodePNGColorMode* info);\n/*has it got a palette? (only colortype 3)*/\nunsigned lodepng_is_palette_type(const LodePNGColorMode* info);\n/*only returns true if there is a palette and there is a value in the palette with alpha < 255.\nLoops through the palette to check this.*/\nunsigned lodepng_has_palette_alpha(const LodePNGColorMode* info);\n/*\nCheck if the given color info indicates the possibility of having non-opaque pixels in the PNG image.\nReturns true if the image can have translucent or invisible pixels (it still be opaque if it doesn't use such pixels).\nReturns false if the image can only have opaque pixels.\nIn detail, it returns true only if it's a color type with alpha, or has a palette with non-opaque values,\nor if \"key_defined\" is true.\n*/\nunsigned lodepng_can_have_alpha(const LodePNGColorMode* info);\n/*Returns the byte size of a raw image buffer with given width, height and color mode*/\nsize_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color);\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n/*The information of a Time chunk in PNG.*/\ntypedef struct LodePNGTime {\n  unsigned year;    /*2 bytes used (0-65535)*/\n  unsigned month;   /*1-12*/\n  unsigned day;     /*1-31*/\n  unsigned hour;    /*0-23*/\n  unsigned minute;  /*0-59*/\n  unsigned second;  /*0-60 (to allow for leap seconds)*/\n} LodePNGTime;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\n/*Information about the PNG image, except pixels, width and height.*/\ntypedef struct LodePNGInfo {\n  /*header (IHDR), palette (PLTE) and transparency (tRNS) chunks*/\n  unsigned compression_method;/*compression method of the original file. Always 0.*/\n  unsigned filter_method;     /*filter method of the original file*/\n  unsigned interlace_method;  /*interlace method of the original file: 0=none, 1=Adam7*/\n  LodePNGColorMode color;     /*color type and bits, palette and transparency of the PNG file*/\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  /*\n  Suggested background color chunk (bKGD)\n\n  This uses the same color mode and bit depth as the PNG (except no alpha channel),\n  with values truncated to the bit depth in the unsigned integer.\n\n  For grayscale and palette PNGs, the value is stored in background_r. The values\n  in background_g and background_b are then unused. The decoder will set them\n  equal to background_r, the encoder ignores them in this case.\n\n  When decoding, you may get these in a different color mode than the one you requested\n  for the raw pixels: the colortype and bitdepth defined by info_png.color, that is the\n  ones defined in the header of the PNG image, are used.\n\n  When encoding with auto_convert, you must use the color model defined in info_png.color for\n  these values. The encoder normally ignores info_png.color when auto_convert is on, but will\n  use it to interpret these values (and convert copies of them to its chosen color model).\n\n  When encoding, avoid setting this to an expensive color, such as a non-gray value\n  when the image is gray, or the compression will be worse since it will be forced to\n  write the PNG with a more expensive color mode (when auto_convert is on).\n\n  The decoder does not use this background color to edit the color of pixels. This is a\n  completely optional metadata feature.\n  */\n  unsigned background_defined; /*is a suggested background color given?*/\n  unsigned background_r;       /*red/gray/palette component of suggested background color*/\n  unsigned background_g;       /*green component of suggested background color*/\n  unsigned background_b;       /*blue component of suggested background color*/\n\n  /*\n  Non-international text chunks (tEXt and zTXt)\n\n  The char** arrays each contain num strings. The actual messages are in\n  text_strings, while text_keys are keywords that give a short description what\n  the actual text represents, e.g. Title, Author, Description, or anything else.\n\n  All the string fields below including strings, keys, names and language tags are null terminated.\n  The PNG specification uses null characters for the keys, names and tags, and forbids null\n  characters to appear in the main text which is why we can use null termination everywhere here.\n\n  A keyword is minimum 1 character and maximum 79 characters long (plus the\n  additional null terminator). It's discouraged to use a single line length\n  longer than 79 characters for texts.\n\n  Don't allocate these text buffers yourself. Use the init/cleanup functions\n  correctly and use lodepng_add_text and lodepng_clear_text.\n\n  Standard text chunk keywords and strings are encoded using Latin-1.\n  */\n  size_t text_num; /*the amount of texts in these char** buffers (there may be more texts in itext)*/\n  char** text_keys; /*the keyword of a text chunk (e.g. \"Comment\")*/\n  char** text_strings; /*the actual text*/\n\n  /*\n  International text chunks (iTXt)\n  Similar to the non-international text chunks, but with additional strings\n  \"langtags\" and \"transkeys\", and the following text encodings are used:\n  keys: Latin-1, langtags: ASCII, transkeys and strings: UTF-8.\n  keys must be 1-79 characters (plus the additional null terminator), the other\n  strings are any length.\n  */\n  size_t itext_num; /*the amount of international texts in this PNG*/\n  char** itext_keys; /*the English keyword of the text chunk (e.g. \"Comment\")*/\n  char** itext_langtags; /*language tag for this text's language, ISO/IEC 646 string, e.g. ISO 639 language tag*/\n  char** itext_transkeys; /*keyword translated to the international language - UTF-8 string*/\n  char** itext_strings; /*the actual international text - UTF-8 string*/\n\n  /*\n  Optional exif metadata in exif_size bytes.\n  Don't allocate this buffer yourself. Use the init/cleanup functions\n  correctly and use lodepng_set_exif and lodepng_clear_exif.\n  The exif data is in exif-encoded form but without JPEG markers, starting with the 'II' or 'MM' marker that indicates\n  endianness. It's up to an exif handling library to encode/decode its information.\n  */\n  unsigned exif_defined; /* Whether exif metadata is present, that is, the PNG image has an eXIf chunk */\n  unsigned char* exif; /* The bytes of the exif metadata, if present */\n  unsigned exif_size; /* The size of the exif data in bytes */\n\n\n  /*time chunk (tIME)*/\n  unsigned time_defined; /*set to 1 to make the encoder generate a tIME chunk*/\n  LodePNGTime time;\n\n  /*phys chunk (pHYs)*/\n  unsigned phys_defined; /*if 0, there is no pHYs chunk and the values below are undefined, if 1 else there is one*/\n  unsigned phys_x; /*pixels per unit in x direction*/\n  unsigned phys_y; /*pixels per unit in y direction*/\n  unsigned phys_unit; /*may be 0 (unknown unit) or 1 (metre)*/\n\n  /*\n  Color profile related chunk types: cICP, iCPP, sRGB, gAMA, cHRM, sBIT\n\n  LodePNG does not apply any color conversions on pixels in the encoder or decoder and does not interpret these color\n  profile values. It merely passes on the information. If you wish to use color profiles and convert colors, a separate\n  color management library should be used. There is also a limited library for this in lodepng_util.h.\n\n  There are 4 types of (sets of) chunks providing color information. If multiple are present, each will be decoded by\n  LodePNG, but only one should be handled by the user, with the following order of priority depending on what the user\n  supports:\n  1: cICP: Coding-independent code points (CICP)\n  2: iCCP: ICC profile\n  3: sRGB: indicates the image is in the sRGB color profile\n  4: gAMA and cHRM: indicates a gamma and chromaticity value to define the color profile\n  */\n\n  /*\n  gAMA chunk: Image gamma\n  Optional, overridden by cICP, iCCP or sRGB if those are present.\n  Together with cHRM, this is a primitive way of specifying the image color profile.\n  */\n  unsigned gama_defined; /* Whether a gAMA chunk is present (0 = not present, 1 = present). */\n  unsigned gama_gamma;   /* Gamma exponent times 100000 */\n\n  /*\n  cHRM chunk: Primary chromaticities and white point\n  Optional, overridden by cICP, iCCP or sRGB if those are present.\n  Together with gAMA, this is a primitive way of specifying the image color profile.\n  */\n  unsigned chrm_defined; /* Whether a cHRM chunk is present (0 = not present, 1 = present). */\n  unsigned chrm_white_x; /* White Point x times 100000 */\n  unsigned chrm_white_y; /* White Point y times 100000 */\n  unsigned chrm_red_x;   /* Red x times 100000 */\n  unsigned chrm_red_y;   /* Red y times 100000 */\n  unsigned chrm_green_x; /* Green x times 100000 */\n  unsigned chrm_green_y; /* Green y times 100000 */\n  unsigned chrm_blue_x;  /* Blue x times 100000 */\n  unsigned chrm_blue_y;  /* Blue y times 100000 */\n\n  /*\n  sRGB chunk: Indicates the image is in the sRGB color space.\n  Optional. Should not appear at the same time as iCCP.\n  If gAMA is also present gAMA must contain value 45455.\n  If cHRM is also present cHRM must contain respectively 31270,32900,64000,33000,30000,60000,15000,6000.\n  */\n  unsigned srgb_defined; /* Whether an sRGB chunk is present (0 = not present, 1 = present). */\n  unsigned srgb_intent;  /* Rendering intent: 0=perceptual, 1=rel. colorimetric, 2=saturation, 3=abs. colorimetric */\n\n  /*\n  iCCP chunk: Embedded ICC profile.\n  Optional. Should not appear at the same time as sRGB.\n\n  Contains ICC profile, which can use any version of the ICC.1 specification by the International Color Consortium. See\n  its specification for more details. LodePNG does not parse or use the ICC profile (except its color space header\n  field for \"RGB\" or \"GRAY\", see below), a separate library to handle the ICC data format is needed to use it for color\n  management and conversions.\n\n  For encoding, if iCCP is present, the PNG specification recommends to also add gAMA and cHRM chunks that approximate\n  the ICC profile, for compatibility with applications that don't use the ICC chunk. This is not required, and it's up\n  to the user to compute approximate values and set then in the appropriate gama_ and chrm_ fields, LodePNG does not do\n  this automatically since it does not interpret the ICC profile.\n\n  For encoding, the ICC profile is required by the PNG specification to be an \"RGB\" profile for non-gray PNG color\n  types (types 2, 3 and 6) and a \"GRAY\" profile for gray PNG color types (types 1 and 4). If you disable auto_convert,\n  you must ensure the ICC profile type matches your requested color type, else the encoder gives an error. If\n  auto_convert is enabled (the default), and the ICC profile is not a correct match for the pixel data, this will result\n  in an encoder error if the pixel data has non-gray pixels for a GRAY profile, or a silent less-optimal compression of\n  the pixel data if the pixels could be encoded as grayscale but the ICC profile is RGB.\n\n  To avoid this do not set an ICC profile in the image unless there is a good reason for it, and when doing so\n  make sure you compute it carefully to avoid the above problems.\n  */\n  unsigned iccp_defined;      /* Whether an iCCP chunk is present (0 = not present, 1 = present). */\n  char* iccp_name;            /* Null terminated string with profile name, 1-79 bytes */\n  /*\n  The ICC profile in iccp_profile_size bytes.\n  Don't allocate this buffer yourself. Use the init/cleanup functions\n  correctly and use lodepng_set_icc and lodepng_clear_icc.\n  */\n  unsigned char* iccp_profile;\n  unsigned iccp_profile_size; /* The size of iccp_profile in bytes */\n\n  /*\n  cICP chunk: Coding-independent code points for video signal type identification.\n  Optional. If present, and supported, overrides iCCP, sRGB, gAMA and cHRM.\n  The meaning of the values are as defined in the specification ITU-T-H.273. LodePNG does not\n  use these values, only passes on the metadata. The meaning of the values is they are enum\n  values representing certain color spaces, including HDR color spaces, such as Display P3,\n  PQ and HLG. The video full range flag value should typically be 1 for the use cases of PNG\n  images, but can be 0 for narrow-range images in certain video editing workflows.\n  */\n  unsigned cicp_defined; /* Whether an cICP chunk is present (0 = not present, 1 = present). */\n  unsigned cicp_color_primaries; /* Colour primaries value */\n  unsigned cicp_transfer_function; /* Transfer characteristics value */\n  unsigned cicp_matrix_coefficients; /* Matrix coefficients value */\n  unsigned cicp_video_full_range_flag; /* Video full range flag value */\n\n  /*\n  mDCv chunk: Mastering Display Color Volume.\n  Optional, typically used in conjunction with certain HDR color spaces that can\n  be represented by the cICP chunk.\n  See the PNG specification, third edition, for more information on this chunk.\n  All the red, green, blue and white x and y values are encoded as 16-bit\n  integers and therefore must be in range 0-65536. The min and max luminance\n  values are 32-bit integers.\n  */\n  unsigned mdcv_defined; /* Whether a mDCv chunk is present (0 = not present, 1 = present). */\n  /* Mastering display color primary chromaticities (CIE 1931 x,y of R,G,B) */\n  unsigned mdcv_red_x;   /* Red x times 50000 */\n  unsigned mdcv_red_y;   /* Red y times 50000 */\n  unsigned mdcv_green_x; /* Green x times 50000 */\n  unsigned mdcv_green_y; /* Green y times 50000 */\n  unsigned mdcv_blue_x;  /* Blue x times 50000 */\n  unsigned mdcv_blue_y;  /* Blue y times 50000 */\n  /* Mastering display white point chromaticity (CIE 1931 x,y) */\n  unsigned mdcv_white_x; /* White Point x times 50000 */\n  unsigned mdcv_white_y; /* White Point y times 50000 */\n  /* Mastering display luminance */\n  unsigned mdcv_max_luminance; /* Max luminance in cd/m^2 times 10000 */\n  unsigned mdcv_min_luminance; /* Min luminance in cd/m^2 times 10000 */\n\n  /*\n  cLLi chunk: Content Light Level Information.\n  Optional, typically used in conjunction with certain HDR color spaces that can\n  be represented by the cICP chunk.\n  See the PNG specification, third edition, for more information on this chunk.\n  The clli_max_cll and clli_max_fall values are 32-bit integers.\n  */\n  unsigned clli_defined; /* Whether a cLLi chunk is present (0 = not present, 1 = present). */\n  unsigned clli_max_cll; /* Maximum Content Light Level (MaxCLL) in cd/m^2 times 10000 */\n  unsigned clli_max_fall; /* Maximum Frame-Average Light Level (MaxFALL) in cd/m^2 times 10000 */\n\n  /*\n  sBIT chunk: significant bits.\n  Optional metadata, only set this if needed.\n\n  If defined, these values give the bit depth of the original data. Since PNG only stores 1, 2, 4, 8 or 16-bit\n  per channel data, the significant bits value can be used to indicate the original encoded data has another\n  sample depth, such as 10 or 12.\n\n  Encoders using this value, when storing the pixel data, should use the most significant bits\n  of the data to store the original bits, and use a good sample depth scaling method such as\n  \"left bit replication\" to fill in the least significant bits, rather than fill zeroes.\n\n  Decoders using this value, if able to work with data that's e.g. 10-bit or 12-bit, should right\n  shift the data to go back to the original bit depth, but decoders are also allowed to ignore\n  sbit and work e.g. with the 8-bit or 16-bit data from the PNG directly, since thanks\n  to the encoder contract, the values encoded in PNG are in valid range for the PNG bit depth.\n\n  For grayscale images, sbit_g and sbit_b are not used, and for images that don't use color\n  type RGBA or grayscale+alpha, sbit_a is not used (it's not used even for palette images with\n  translucent palette values, or images with color key). The values that are used must be\n  greater than zero and smaller than or equal to the PNG bit depth.\n\n  The color type from the header in the PNG image defines these used and unused fields: if\n  decoding with a color mode conversion, such as always decoding to RGBA, this metadata still\n  only uses the color type of the original PNG, and may e.g. lack the alpha channel info\n  if the PNG was RGB. When encoding with auto_convert (as well as without), also always the\n  color model defined in info_png.color determines this.\n\n  NOTE: enabling sbit can hurt compression, because the encoder can then not always use\n  auto_convert to choose a more optimal color mode for the data, because the PNG format has\n  strict requirements for the allowed sbit values in combination with color modes.\n  For example, setting these fields to 10-bit will force the encoder to keep using a 16-bit per channel\n  color mode, even if the pixel data would in fact fit in a more efficient 8-bit mode.\n  */\n  unsigned sbit_defined; /*is significant bits given? if not, the values below are unused*/\n  unsigned sbit_r;       /*red or gray component of significant bits*/\n  unsigned sbit_g;       /*green component of significant bits*/\n  unsigned sbit_b;       /*blue component of significant bits*/\n  unsigned sbit_a;       /*alpha component of significant bits*/\n\n  /* End of color profile related chunks */\n\n\n  /*\n  unknown chunks: chunks not known by LodePNG, passed on byte for byte.\n\n  There are 3 buffers, one for each position in the PNG where unknown chunks can appear.\n  Each buffer contains all unknown chunks for that position consecutively.\n  The 3 positions are:\n  0: between IHDR and PLTE, 1: between PLTE and IDAT, 2: between IDAT and IEND.\n\n  For encoding, do not store critical chunks or known chunks that are enabled with a \"_defined\" flag\n  above in here, since the encoder will blindly follow this and could then encode an invalid PNG file\n  (such as one with two IHDR chunks or the disallowed combination of sRGB with iCCP). But do use\n  this if you wish to store an ancillary chunk that is not supported by LodePNG (such as sPLT or hIST),\n  or any non-standard PNG chunk.\n\n  Do not allocate or traverse this data yourself. Use the chunk traversing functions declared\n  later, such as lodepng_chunk_next and lodepng_chunk_append, to read/write this struct.\n  */\n  unsigned char* unknown_chunks_data[3];\n  size_t unknown_chunks_size[3]; /*size in bytes of the unknown chunks, given for protection*/\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n} LodePNGInfo;\n\n/*init, cleanup and copy functions to use with this struct*/\nvoid lodepng_info_init(LodePNGInfo* info);\nvoid lodepng_info_cleanup(LodePNGInfo* info);\n/*return value is error code (0 means no error)*/\nunsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source);\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\nunsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str); /*push back both texts at once*/\nvoid lodepng_clear_text(LodePNGInfo* info); /*use this to clear the texts again after you filled them in*/\n\nunsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,\n                           const char* transkey, const char* str); /*push back the 4 texts of 1 chunk at once*/\nvoid lodepng_clear_itext(LodePNGInfo* info); /*use this to clear the itexts again after you filled them in*/\n\n/*replaces if exists*/\nunsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size);\nvoid lodepng_clear_icc(LodePNGInfo* info); /*use this to clear the profile again after you filled it in*/\n\n/*replaces if exists*/\nunsigned lodepng_set_exif(LodePNGInfo* info, const unsigned char* exif, unsigned exif_size);\nvoid lodepng_clear_exif(LodePNGInfo* info); /*use this to clear the exif metadata again after you filled it in*/\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\n/*\nConverts raw buffer from one color type to another color type, based on\nLodePNGColorMode structs to describe the input and output color type.\nSee the reference manual at the end of this header file to see which color conversions are supported.\nreturn value = LodePNG error code (0 if all went ok, an error if the conversion isn't supported)\nThe out buffer must have size (w * h * bpp + 7) / 8, where bpp is the bits per pixel\nof the output color type (lodepng_get_bpp).\nFor < 8 bpp images, there should not be padding bits at the end of scanlines.\nFor 16-bit per channel colors, uses big endian format like PNG does.\nReturn value is LodePNG error code\n*/\nunsigned lodepng_convert(unsigned char* out, const unsigned char* in,\n                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,\n                         unsigned w, unsigned h);\n\n#ifdef LODEPNG_COMPILE_DECODER\n/*\nSettings for the decoder. This contains settings for the PNG and the Zlib\ndecoder, but not the Info settings from the Info structs.\n*/\ntypedef struct LodePNGDecoderSettings {\n  LodePNGDecompressSettings zlibsettings; /*in here is the setting to ignore Adler32 checksums*/\n\n  /* Check LodePNGDecompressSettings for more ignorable errors such as ignore_adler32 */\n  unsigned ignore_crc; /*ignore CRC checksums*/\n  unsigned ignore_critical; /*ignore unknown critical chunks*/\n  unsigned ignore_end; /*ignore issues at end of file if possible (missing IEND chunk, too large chunk, ...)*/\n  /* TODO: make a system involving warnings with levels and a strict mode instead. Other potentially recoverable\n     errors: srgb rendering intent value, size of content of ancillary chunks, more than 79 characters for some\n     strings, placement/combination rules for ancillary chunks, crc of unknown chunks, allowed characters\n     in string keys, invalid characters in chunk types names, etc... */\n\n  unsigned color_convert; /*whether to convert the PNG to the color type you want. Default: yes*/\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  unsigned read_text_chunks; /*if false but remember_unknown_chunks is true, they're stored in the unknown chunks*/\n\n  /*store all bytes from unknown chunks in the LodePNGInfo (off by default, useful for a png editor)*/\n  unsigned remember_unknown_chunks;\n\n  /* maximum size for decompressed text chunks. If a text chunk's text is larger than this, an error is returned,\n  unless reading text chunks is disabled or this limit is set higher or disabled. Set to 0 to allow any size.\n  By default it is a value that prevents unreasonably large strings from hogging memory. */\n  size_t max_text_size;\n\n  /* maximum size for compressed ICC chunks. If the ICC profile is larger than this, an error will be returned. Set to\n  0 to allow any size. By default this is a value that prevents ICC profiles that would be much larger than any\n  legitimate profile could be to hog memory. */\n  size_t max_icc_size;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n} LodePNGDecoderSettings;\n\nvoid lodepng_decoder_settings_init(LodePNGDecoderSettings* settings);\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_ENCODER\n/*strategy to use to choose the PNG filter per scanline. Strategies 0-4 correspond\nto each of the 5 filter types PNG supports, the next values are adaptive strategies*/\ntypedef enum LodePNGFilterStrategy {\n  /*every filter at zero*/\n  LFS_ZERO = 0,\n  /*every filter at 1, 2, 3 or 4 (paeth), unlike LFS_ZERO not a good choice, but for testing*/\n  LFS_ONE = 1,\n  LFS_TWO = 2,\n  LFS_THREE = 3,\n  LFS_FOUR = 4,\n  /*Use the filter out of the 5 above types that gives minimum sum, by trying each one. This is the adaptive filtering\n  suggested heuristic in the PNG standard chapter 'Filter selection'.*/\n  LFS_MINSUM,\n  /*Use the filter type that gives smallest Shannon entropy for this scanline. Depending\n  on the image, this is better or worse than minsum.*/\n  LFS_ENTROPY,\n  /*\n  Brute-force-search PNG filters by compressing each filter for each scanline.\n  Experimental, very slow, and only rarely gives better compression than MINSUM.\n  */\n  LFS_BRUTE_FORCE,\n  /*use predefined_filters buffer: you specify the filter type for each scanline*/\n  LFS_PREDEFINED\n} LodePNGFilterStrategy;\n\n/*Gives characteristics about the integer RGBA colors of the image (count, alpha channel usage, bit depth, ...),\nwhich helps decide which color model to use for encoding.\nUsed internally by default if \"auto_convert\" is enabled. Public because it's useful for custom algorithms.*/\ntypedef struct LodePNGColorStats {\n  unsigned colored; /*not grayscale*/\n  unsigned key; /*image is not opaque and color key is possible instead of full alpha*/\n  unsigned short key_r; /*key values, always as 16-bit, in 8-bit case the byte is duplicated, e.g. 65535 means 255*/\n  unsigned short key_g;\n  unsigned short key_b;\n  unsigned alpha; /*image is not opaque and alpha channel or alpha palette required*/\n  unsigned numcolors; /*amount of colors, up to 257. Not valid if bits == 16 or allow_palette is disabled.*/\n  unsigned char palette[1024]; /*Remembers up to the first 256 RGBA colors, in no particular order, only valid when numcolors is valid*/\n  unsigned bits; /*bits per channel (not for palette). 1,2 or 4 for grayscale only. 16 if 16-bit per channel required.*/\n  size_t numpixels;\n\n  /*user settings for computing/using the stats*/\n  unsigned allow_palette; /*default 1. if 0, disallow choosing palette colortype in auto_choose_color, and don't count numcolors*/\n  unsigned allow_greyscale; /*default 1. if 0, choose RGB or RGBA even if the image only has gray colors*/\n} LodePNGColorStats;\n\nvoid lodepng_color_stats_init(LodePNGColorStats* stats);\n\n/*Get a LodePNGColorStats of the image. The stats must already have been inited.\nReturns error code (e.g. alloc fail) or 0 if ok.*/\nunsigned lodepng_compute_color_stats(LodePNGColorStats* stats,\n                                     const unsigned char* image, unsigned w, unsigned h,\n                                     const LodePNGColorMode* mode_in);\n\n/*Settings for the encoder.*/\ntypedef struct LodePNGEncoderSettings {\n  LodePNGCompressSettings zlibsettings; /*settings for the zlib encoder, such as window size, ...*/\n\n  /*automatically choose output PNG color type. If false, must explicitely choose the output color\n  type in state.info_png.color.colortype, info_png.color.bitdepth and optionally its palette.\n  Default: true*/\n  unsigned auto_convert;\n\n  /*If true, follows the suggestion in the PNG standard in chapter 'Filter selection': if the PNG uses\n  a palette or lower than 8 bit depth, set all filters to zero.\n  In other cases this will use the heuristic from the chosen filter_strategy. The PNG standard\n  suggests LFS_MINSUM for those cases.*/\n  unsigned filter_palette_zero;\n  /*Which filter strategy to use when not using zeroes due to filter_palette_zero.\n  Set filter_palette_zero to 0 to ensure always using your chosen strategy. Default: LFS_MINSUM*/\n  LodePNGFilterStrategy filter_strategy;\n  /*used if filter_strategy is LFS_PREDEFINED. In that case, this must point to a buffer with\n  the same length as the amount of scanlines in the image, and each value must <= 5. You\n  have to cleanup this buffer, LodePNG will never free it. Don't forget that filter_palette_zero\n  must be set to 0 to ensure this is also used on palette or low bitdepth images.*/\n  const unsigned char* predefined_filters;\n\n  /*force creating a PLTE chunk if colortype is 2 or 6 (= a suggested palette).\n  If colortype is 3, PLTE is always created. If color type is explicitely set\n  to a grayscale type (1 or 4), this is not done and is ignored. If enabling this,\n  a palette must be present in the info_png.\n  NOTE: enabling this may worsen compression if auto_convert is used to choose\n  optimal color mode, because it cannot use grayscale color modes in this case*/\n  unsigned force_palette;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  /*add LodePNG identifier and version as a text chunk, for debugging*/\n  unsigned add_id;\n  /*encode text chunks as zTXt chunks instead of tEXt chunks, and use compression in iTXt chunks*/\n  unsigned text_compression;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n} LodePNGEncoderSettings;\n\nvoid lodepng_encoder_settings_init(LodePNGEncoderSettings* settings);\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n\n#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)\n/*The settings, state and information for extended encoding and decoding.*/\ntypedef struct LodePNGState {\n#ifdef LODEPNG_COMPILE_DECODER\n  LodePNGDecoderSettings decoder; /*the decoding settings*/\n#endif /*LODEPNG_COMPILE_DECODER*/\n#ifdef LODEPNG_COMPILE_ENCODER\n  LodePNGEncoderSettings encoder; /*the encoding settings*/\n#endif /*LODEPNG_COMPILE_ENCODER*/\n  LodePNGColorMode info_raw; /*specifies the format in which you would like to get the raw pixel buffer*/\n  LodePNGInfo info_png; /*info of the PNG image obtained after decoding*/\n  unsigned error;\n} LodePNGState;\n\n/*init, cleanup and copy functions to use with this struct*/\nvoid lodepng_state_init(LodePNGState* state);\nvoid lodepng_state_cleanup(LodePNGState* state);\nvoid lodepng_state_copy(LodePNGState* dest, const LodePNGState* source);\n#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */\n\n#ifdef LODEPNG_COMPILE_DECODER\n/*\nSame as lodepng_decode_memory, but uses a LodePNGState to allow custom settings and\ngetting much more information about the PNG image and color mode.\n*/\nunsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,\n                        LodePNGState* state,\n                        const unsigned char* in, size_t insize);\n\n/*\nRead the PNG header, but not the actual data. This returns only the information\nthat is in the IHDR chunk of the PNG, such as width, height and color type. The\ninformation is placed in the info_png field of the LodePNGState.\n*/\nunsigned lodepng_inspect(unsigned* w, unsigned* h,\n                         LodePNGState* state,\n                         const unsigned char* in, size_t insize);\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n/*\nReads one metadata chunk (other than IHDR, which is handled by lodepng_inspect)\nof the PNG file and outputs what it read in the state. Returns error code on failure.\nUse lodepng_inspect first with a new state, then e.g. lodepng_chunk_find_const\nto find the desired chunk type, and if non null use lodepng_inspect_chunk (with\nchunk_pointer - start_of_file as pos).\nSupports most metadata chunks from the PNG standard (gAMA, bKGD, tEXt, ...).\nIgnores unsupported, unknown, non-metadata or IHDR chunks (without error).\nRequirements: &in[pos] must point to start of a chunk, must use regular\nlodepng_inspect first since format of most other chunks depends on IHDR, and if\nthere is a PLTE chunk, that one must be inspected before tRNS or bKGD.\n*/\nunsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,\n                               const unsigned char* in, size_t insize);\n\n#ifdef LODEPNG_COMPILE_ENCODER\n/*This function allocates the out buffer with standard malloc and stores the size in *outsize.*/\nunsigned lodepng_encode(unsigned char** out, size_t* outsize,\n                        const unsigned char* image, unsigned w, unsigned h,\n                        LodePNGState* state);\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n/*\nThe lodepng_chunk functions are normally not needed, except to traverse the\nunknown chunks stored in the LodePNGInfo struct, or add new ones to it.\nIt also allows traversing the chunks of an encoded PNG file yourself.\n\nThe chunk pointer always points to the beginning of the chunk itself, that is\nthe first byte of the 4 length bytes.\n\nIn the PNG file format, chunks have the following format:\n-4 bytes length: length of the data of the chunk in bytes (chunk itself is 12 bytes longer)\n-4 bytes chunk type (ASCII a-z,A-Z only, see below)\n-length bytes of data (may be 0 bytes if length was 0)\n-4 bytes of CRC, computed on chunk name + data\n\nThe first chunk starts at the 8th byte of the PNG file, the entire rest of the file\nexists out of concatenated chunks with the above format.\n\nPNG standard chunk ASCII naming conventions:\n-First byte: uppercase = critical, lowercase = ancillary\n-Second byte: uppercase = public, lowercase = private\n-Third byte: must be uppercase\n-Fourth byte: uppercase = unsafe to copy, lowercase = safe to copy\n*/\n\n/*\nGets the length of the data of the chunk. Total chunk length has 12 bytes more.\nThere must be at least 4 bytes to read from. If the result value is too large,\nit may be corrupt data.\n*/\nunsigned lodepng_chunk_length(const unsigned char* chunk);\n\n/*puts the 4-byte type in null terminated string*/\nvoid lodepng_chunk_type(char type[5], const unsigned char* chunk);\n\n/*check if the type is the given type*/\nunsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type);\n\n/*0: it's one of the critical chunk types, 1: it's an ancillary chunk (see PNG standard)*/\nunsigned char lodepng_chunk_ancillary(const unsigned char* chunk);\n\n/*0: public, 1: private (see PNG standard)*/\nunsigned char lodepng_chunk_private(const unsigned char* chunk);\n\n/*0: the chunk is unsafe to copy, 1: the chunk is safe to copy (see PNG standard)*/\nunsigned char lodepng_chunk_safetocopy(const unsigned char* chunk);\n\n/*get pointer to the data of the chunk, where the input points to the header of the chunk*/\nunsigned char* lodepng_chunk_data(unsigned char* chunk);\nconst unsigned char* lodepng_chunk_data_const(const unsigned char* chunk);\n\n/*returns 0 if the crc is correct, 1 if it's incorrect (0 for OK as usual!)*/\nunsigned lodepng_chunk_check_crc(const unsigned char* chunk);\n\n/*generates the correct CRC from the data and puts it in the last 4 bytes of the chunk*/\nvoid lodepng_chunk_generate_crc(unsigned char* chunk);\n\n/*\nIterate to next chunks, allows iterating through all chunks of the PNG file.\nInput must be at the beginning of a chunk (result of a previous lodepng_chunk_next call,\nor the 8th byte of a PNG file which always has the first chunk), or alternatively may\npoint to the first byte of the PNG file (which is not a chunk but the magic header, the\nfunction will then skip over it and return the first real chunk).\nWill output pointer to the start of the next chunk, or at or beyond end of the file if there\nis no more chunk after this or possibly if the chunk is corrupt.\nStart this process at the 8th byte of the PNG file.\nIn a non-corrupt PNG file, the last chunk should have name \"IEND\".\n*/\nunsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end);\nconst unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end);\n\n/*Finds the first chunk with the given type in the range [chunk, end), or returns NULL if not found.*/\nunsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]);\nconst unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]);\n\n/*\nAppends chunk to the data in out. The given chunk should already have its chunk header.\nThe out variable and outsize are updated to reflect the new reallocated buffer.\nReturns error code (0 if it went ok)\n*/\nunsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk);\n\n/*\nAppends new chunk to out. The chunk to append is given by giving its length, type\nand data separately. The type is a 4-letter string.\nThe out variable and outsize are updated to reflect the new reallocated buffer.\nReturne error code (0 if it went ok)\n*/\nunsigned lodepng_chunk_create(unsigned char** out, size_t* outsize, size_t length,\n                              const char* type, const unsigned char* data);\n\n\n/*Calculate CRC32 of buffer*/\nunsigned lodepng_crc32(const unsigned char* buf, size_t len);\n#endif /*LODEPNG_COMPILE_PNG*/\n\n\n#ifdef LODEPNG_COMPILE_ZLIB\n/*\nThis zlib part can be used independently to zlib compress and decompress a\nbuffer. It cannot be used to create gzip files however, and it only supports the\npart of zlib that is required for PNG, it does not support dictionaries.\n*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n/*Inflate a buffer. Inflate is the decompression step of deflate. Out buffer must be freed after use.*/\nunsigned lodepng_inflate(unsigned char** out, size_t* outsize,\n                         const unsigned char* in, size_t insize,\n                         const LodePNGDecompressSettings* settings);\n\n/*\nDecompresses Zlib data. Reallocates the out buffer and appends the data. The\ndata must be according to the zlib specification.\nEither, *out must be NULL and *outsize must be 0, or, *out must be a valid\nbuffer and *outsize its size in bytes. out must be freed by user after usage.\n*/\nunsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize,\n                                 const unsigned char* in, size_t insize,\n                                 const LodePNGDecompressSettings* settings);\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_ENCODER\n/*\nCompresses data with Zlib. Reallocates the out buffer and appends the data.\nZlib adds a small header and trailer around the deflate data.\nThe data is output in the format of the zlib specification.\nEither, *out must be NULL and *outsize must be 0, or, *out must be a valid\nbuffer and *outsize its size in bytes. out must be freed by user after usage.\n*/\nunsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize,\n                               const unsigned char* in, size_t insize,\n                               const LodePNGCompressSettings* settings);\n\n/*\nFind length-limited Huffman code for given frequencies. This function is in the\npublic interface only for tests, it's used internally by lodepng_deflate.\n*/\nunsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,\n                                      size_t numcodes, unsigned maxbitlen);\n\n/*Compress a buffer with deflate. See RFC 1951. Out buffer must be freed after use.*/\nunsigned lodepng_deflate(unsigned char** out, size_t* outsize,\n                         const unsigned char* in, size_t insize,\n                         const LodePNGCompressSettings* settings);\n\n#endif /*LODEPNG_COMPILE_ENCODER*/\n#endif /*LODEPNG_COMPILE_ZLIB*/\n\n#ifdef LODEPNG_COMPILE_DISK\n/*\nLoad a file from disk into buffer. The function allocates the out buffer, and\nafter usage you should free it.\nout: output parameter, contains pointer to loaded buffer.\noutsize: output parameter, size of the allocated out buffer\nfilename: the path to the file to load\nreturn value: error code (0 means ok)\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and decode in-memory.\n*/\nunsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename);\n\n/*\nSave a file from buffer to disk. Warning, if it exists, this function overwrites\nthe file without warning!\nbuffer: the buffer to write\nbuffersize: size of the buffer to write\nfilename: the path to the file to save to\nreturn value: error code (0 means ok)\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and encode in-memory\n*/\nunsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename);\n#endif /*LODEPNG_COMPILE_DISK*/\n\n#ifdef LODEPNG_COMPILE_CPP\n/* The LodePNG C++ wrapper uses std::vectors instead of manually allocated memory buffers. */\nnamespace lodepng {\n#ifdef LODEPNG_COMPILE_PNG\nclass State : public LodePNGState {\n  public:\n    State();\n    State(const State& other);\n    ~State();\n    State& operator=(const State& other);\n};\n\n#ifdef LODEPNG_COMPILE_DECODER\n/* Same as other lodepng::decode, but using a State for more settings and information. */\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                State& state,\n                const unsigned char* in, size_t insize);\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                State& state,\n                const std::vector<unsigned char>& in);\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_ENCODER\n/* Same as other lodepng::encode, but using a State for more settings and information. */\nunsigned encode(std::vector<unsigned char>& out,\n                const unsigned char* in, unsigned w, unsigned h,\n                State& state);\nunsigned encode(std::vector<unsigned char>& out,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                State& state);\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#ifdef LODEPNG_COMPILE_DISK\n/*\nLoad a file from disk into an std::vector.\nreturn value: error code (0 means ok)\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and decode in-memory\n*/\nunsigned load_file(std::vector<unsigned char>& buffer, const std::string& filename);\n\n/*\nSave the binary data in an std::vector to a file on disk. The file is overwritten\nwithout warning.\n\nNOTE: Wide-character filenames are not supported, you can use an external method\nto handle such files and encode in-memory\n*/\nunsigned save_file(const std::vector<unsigned char>& buffer, const std::string& filename);\n#endif /* LODEPNG_COMPILE_DISK */\n#endif /* LODEPNG_COMPILE_PNG */\n\n#ifdef LODEPNG_COMPILE_ZLIB\n#ifdef LODEPNG_COMPILE_DECODER\n/* Zlib-decompress an unsigned char buffer */\nunsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\n                    const LodePNGDecompressSettings& settings = lodepng_default_decompress_settings);\n\n/* Zlib-decompress an std::vector */\nunsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\n                    const LodePNGDecompressSettings& settings = lodepng_default_decompress_settings);\n#endif /* LODEPNG_COMPILE_DECODER */\n\n#ifdef LODEPNG_COMPILE_ENCODER\n/* Zlib-compress an unsigned char buffer */\nunsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\n                  const LodePNGCompressSettings& settings = lodepng_default_compress_settings);\n\n/* Zlib-compress an std::vector */\nunsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\n                  const LodePNGCompressSettings& settings = lodepng_default_compress_settings);\n#endif /* LODEPNG_COMPILE_ENCODER */\n#endif /* LODEPNG_COMPILE_ZLIB */\n} /* namespace lodepng */\n#endif /*LODEPNG_COMPILE_CPP*/\n\n/*\nTODO:\n[.] test if there are no memory leaks or security exploits - done a lot but needs to be checked often\n[.] check compatibility with various compilers  - done but needs to be redone for every newer version\n[X] converting color to 16-bit per channel types\n[X] support color profile chunk types (but never let them touch RGB values by default)\n[ ] support all second edition public PNG chunk types (almost done except sPLT and hIST)\n[X] support non-animation third edition public PNG chunk types: eXIf, cICP, mDCv, cLLi\n[ ] make sure encoder generates no chunks with size > (2^31)-1\n[ ] partial decoding (stream processing)\n[X] let the \"isFullyOpaque\" function check color keys and transparent palettes too\n[X] better name for the variables \"codes\", \"codesD\", \"codelengthcodes\", \"clcl\" and \"lldl\"\n[ ] allow treating some errors like warnings, when image is recoverable (e.g. 69, 57, 58)\n[ ] make warnings like: oob palette, checksum fail, data after iend, wrong/unknown crit chunk, no null terminator in text, ...\n[ ] error messages with line numbers (and version)\n[ ] errors in state instead of as return code?\n[ ] new errors/warnings like suspiciously big decompressed ztxt or iccp chunk\n[ ] let the C++ wrapper catch exceptions coming from the standard library and return LodePNG error codes\n[ ] allow user to provide custom color conversion functions, e.g. for premultiplied alpha, padding bits or not, ...\n[ ] allow user to give data (void*) to custom allocator\n[X] provide alternatives for C library functions not present on some platforms (memcpy, ...)\n*/\n\n#endif /*LODEPNG_H inclusion guard*/\n\n/*\nLodePNG Documentation\n---------------------\n\n0. table of contents\n--------------------\n\n  1. about\n   1.1. supported features\n   1.2. features not supported\n  2. C and C++ version\n  3. security\n  4. decoding\n  5. encoding\n  6. color conversions\n    6.1. PNG color types\n    6.2. color conversions\n    6.3. padding bits\n    6.4. A note about 16-bits per channel and endianness\n  7. error values\n  8. chunks and PNG editing\n  9. compiler support\n  10. examples\n   10.1. decoder C++ example\n   10.2. decoder C example\n  11. state settings reference\n  12. changes\n  13. contact information\n\n\n1. about\n--------\n\nPNG is a file format to store raster images losslessly with good compression,\nsupporting different color types and alpha channel.\n\nLodePNG is a PNG codec according to the Portable Network Graphics (PNG)\nSpecification (Second Edition) - W3C Recommendation 10 November 2003.\n\nThe specifications used are:\n\n*) Portable Network Graphics (PNG) Specification (Second Edition):\n     http://www.w3.org/TR/2003/REC-PNG-20031110\n*) RFC 1950 ZLIB Compressed Data Format version 3.3:\n     http://www.gzip.org/zlib/rfc-zlib.html\n*) RFC 1951 DEFLATE Compressed Data Format Specification ver 1.3:\n     http://www.gzip.org/zlib/rfc-deflate.html\n\nThe most recent version of LodePNG can currently be found at\nhttp://lodev.org/lodepng/\n\nLodePNG works both in C (ISO C90) and C++, with a C++ wrapper that adds\nextra functionality.\n\nLodePNG exists out of two files:\n-lodepng.h: the header file for both C and C++\n-lodepng.c(pp): give it the name lodepng.c or lodepng.cpp (or .cc) depending on your usage\n\nIf you want to start using LodePNG right away without reading this doc, get the\nexamples from the LodePNG website to see how to use it in code, or check the\nsmaller examples in chapter 13 here.\n\nLodePNG is simple but only supports the basic requirements. To achieve\nsimplicity, the following design choices were made: There are no dependencies\non any external library. There are functions to decode and encode a PNG with\na single function call, and extended versions of these functions taking a\nLodePNGState struct allowing to specify or get more information. By default\nthe colors of the raw image are always RGB or RGBA, no matter what color type\nthe PNG file uses. To read and write files, there are simple functions to\nconvert the files to/from buffers in memory.\n\nThis all makes LodePNG suitable for loading textures in games, demos and small\nprograms, ... It's less suitable for full fledged image editors, loading PNGs\nover network (it requires all the image data to be available before decoding can\nbegin), life-critical systems, ...\n\n1.1. supported features\n-----------------------\n\nThe following features are supported by the decoder:\n\n*) decoding of PNGs with any color type, bit depth and interlace mode, to a 24- or 32-bit color raw image,\n   or the same color type as the PNG\n*) encoding of PNGs, from any raw image to 24- or 32-bit color, or the same color type as the raw image\n*) Adam7 interlace and deinterlace for any color type\n*) loading the image from harddisk or decoding it from a buffer from other sources than harddisk\n*) support for alpha channels, including RGBA color model, translucent palettes and color keying\n*) zlib decompression (inflate)\n*) zlib compression (deflate)\n*) CRC32 and ADLER32 checksums\n*) colorimetric color profile conversions: currently experimentally available in lodepng_util.cpp only,\n   plus alternatively ability to pass on chroma/gamma/ICC profile information to other color management system.\n*) handling of unknown chunks, allowing making a PNG editor that stores custom and unknown chunks.\n*) the following chunks are supported by both encoder and decoder:\n    IHDR: header information\n    PLTE: color palette\n    IDAT: pixel data\n    IEND: the final chunk\n    tRNS: transparency for palettized images\n    tEXt: textual information\n    zTXt: compressed textual information\n    iTXt: international textual information\n    bKGD: suggested background color\n    pHYs: physical dimensions\n    tIME: modification time\n    cHRM: RGB chromaticities\n    gAMA: RGB gamma correction\n    iCCP: ICC color profile\n    sRGB: rendering intent\n    sBIT: significant bits\n\n1.2. features not supported\n---------------------------\n\nThe following features are not (yet) supported:\n\n*) some features needed to make a conformant PNG-Editor might be still missing.\n*) partial loading/stream processing. All data must be available and is processed in one call.\n*) The hIST and sPLT public chunks are not (yet) supported but treated as unknown chunks\n\n\n2. C and C++ version\n--------------------\n\nThe C version uses buffers allocated with alloc that you need to free()\nyourself. You need to use init and cleanup functions for each struct whenever\nusing a struct from the C version to avoid exploits and memory leaks.\n\nThe C++ version has extra functions with std::vectors in the interface and the\nlodepng::State class which is a LodePNGState with constructor and destructor.\n\nThese files work without modification for both C and C++ compilers because all\nthe additional C++ code is in \"#ifdef __cplusplus\" blocks that make C-compilers\nignore it, and the C code is made to compile both with strict ISO C90 and C++.\n\nTo use the C++ version, you need to rename the source file to lodepng.cpp\n(instead of lodepng.c), and compile it with a C++ compiler.\n\nTo use the C version, you need to rename the source file to lodepng.c (instead\nof lodepng.cpp), and compile it with a C compiler.\n\n\n3. Security\n-----------\n\nEven if carefully designed, it's always possible that LodePNG contains possible\nexploits. If you discover one, please let me know, and it will be fixed.\n\nWhen using LodePNG, care has to be taken with the C version of LodePNG, as well\nas the C-style structs when working with C++. The following conventions are used\nfor all C-style structs:\n\n-if a struct has a corresponding init function, always call the init function when making a new one\n-if a struct has a corresponding cleanup function, call it before the struct disappears to avoid memory leaks\n-if a struct has a corresponding copy function, use the copy function instead of \"=\".\n The destination must also be inited already.\n\n\n4. Decoding\n-----------\n\nDecoding converts a PNG compressed image to a raw pixel buffer.\n\nMost documentation on using the decoder is at its declarations in the header\nabove. For C, simple decoding can be done with functions such as\nlodepng_decode32, and more advanced decoding can be done with the struct\nLodePNGState and lodepng_decode. For C++, all decoding can be done with the\nvarious lodepng::decode functions, and lodepng::State can be used for advanced\nfeatures.\n\nWhen using the LodePNGState, it uses the following fields for decoding:\n*) LodePNGInfo info_png: it stores extra information about the PNG (the input) in here\n*) LodePNGColorMode info_raw: here you can say what color mode of the raw image (the output) you want to get\n*) LodePNGDecoderSettings decoder: you can specify a few extra settings for the decoder to use\n\nLodePNGInfo info_png\n--------------------\n\nAfter decoding, this contains extra information of the PNG image, except the actual\npixels, width and height because these are already gotten directly from the decoder\nfunctions.\n\nIt contains for example the original color type of the PNG image, text comments,\nsuggested background color, etc... More details about the LodePNGInfo struct are\nat its declaration documentation.\n\nLodePNGColorMode info_raw\n-------------------------\n\nWhen decoding, here you can specify which color type you want\nthe resulting raw image to be. If this is different from the colortype of the\nPNG, then the decoder will automatically convert the result. This conversion\nalways works, except if you want it to convert a color PNG to grayscale or to\na palette with missing colors.\n\nBy default, 32-bit color is used for the result.\n\nLodePNGDecoderSettings decoder\n------------------------------\n\nThe settings can be used to ignore the errors created by invalid CRC and Adler32\nchunks, and to disable the decoding of tEXt chunks.\n\nThere's also a setting color_convert, true by default. If false, no conversion\nis done, the resulting data will be as it was in the PNG (after decompression)\nand you'll have to puzzle the colors of the pixels together yourself using the\ncolor type information in the LodePNGInfo.\n\n\n5. Encoding\n-----------\n\nEncoding converts a raw pixel buffer to a PNG compressed image.\n\nMost documentation on using the encoder is at its declarations in the header\nabove. For C, simple encoding can be done with functions such as\nlodepng_encode32, and more advanced decoding can be done with the struct\nLodePNGState and lodepng_encode. For C++, all encoding can be done with the\nvarious lodepng::encode functions, and lodepng::State can be used for advanced\nfeatures.\n\nLike the decoder, the encoder can also give errors. However it gives less errors\nsince the encoder input is trusted, the decoder input (a PNG image that could\nbe forged by anyone) is not trusted.\n\nWhen using the LodePNGState, it uses the following fields for encoding:\n*) LodePNGInfo info_png: here you specify how you want the PNG (the output) to be.\n*) LodePNGColorMode info_raw: here you say what color type of the raw image (the input) has\n*) LodePNGEncoderSettings encoder: you can specify a few settings for the encoder to use\n\nLodePNGInfo info_png\n--------------------\n\nWhen encoding, you use this the opposite way as when decoding: for encoding,\nyou fill in the values you want the PNG to have before encoding. By default it's\nnot needed to specify a color type for the PNG since it's automatically chosen,\nbut it's possible to choose it yourself given the right settings.\n\nThe encoder will not always exactly match the LodePNGInfo struct you give,\nit tries as close as possible. Some things are ignored by the encoder. The\nencoder uses, for example, the following settings from it when applicable:\ncolortype and bitdepth, text chunks, time chunk, the color key, the palette, the\nbackground color, the interlace method, unknown chunks, ...\n\nWhen encoding to a PNG with colortype 3, the encoder will generate a PLTE chunk.\nIf the palette contains any colors for which the alpha channel is not 255 (so\nthere are translucent colors in the palette), it'll add a tRNS chunk.\n\nLodePNGColorMode info_raw\n-------------------------\n\nYou specify the color type of the raw image that you give to the input here,\nincluding a possible transparent color key and palette you happen to be using in\nyour raw image data.\n\nBy default, 32-bit color is assumed, meaning your input has to be in RGBA\nformat with 4 bytes (unsigned chars) per pixel.\n\nLodePNGEncoderSettings encoder\n------------------------------\n\nThe following settings are supported (some are in sub-structs):\n*) auto_convert: when this option is enabled, the encoder will\nautomatically choose the smallest possible color mode (including color key) that\ncan encode the colors of all pixels without information loss.\n*) btype: the block type for LZ77. 0 = uncompressed, 1 = fixed huffman tree,\n   2 = dynamic huffman tree (best compression). Should be 2 for proper\n   compression.\n*) use_lz77: whether or not to use LZ77 for compressed block types. Should be\n   true for proper compression.\n*) windowsize: the window size used by the LZ77 encoder (1 - 32768). Has value\n   2048 by default, but can be set to 32768 for better, but slow, compression.\n*) force_palette: if colortype is 2 or 6, you can make the encoder write a PLTE\n   chunk if force_palette is true. This can used as suggested palette to convert\n   to by viewers that don't support more than 256 colors (if those still exist)\n*) add_id: add text chunk \"Encoder: LodePNG <version>\" to the image.\n*) text_compression: default 1. If 1, it'll store texts as zTXt instead of tEXt chunks.\n  zTXt chunks use zlib compression on the text. This gives a smaller result on\n  large texts but a larger result on small texts (such as a single program name).\n  It's all tEXt or all zTXt though, there's no separate setting per text yet.\n\n\n6. color conversions\n--------------------\n\nAn important thing to note about LodePNG, is that the color type of the PNG, and\nthe color type of the raw image, are completely independent. By default, when\nyou decode a PNG, you get the result as a raw image in the color type you want,\nno matter whether the PNG was encoded with a palette, grayscale or RGBA color.\nAnd if you encode an image, by default LodePNG will automatically choose the PNG\ncolor type that gives good compression based on the values of colors and amount\nof colors in the image. It can be configured to let you control it instead as\nwell, though.\n\nTo be able to do this, LodePNG does conversions from one color mode to another.\nIt can convert from almost any color type to any other color type, except the\nfollowing conversions: RGB to grayscale is not supported, and converting to a\npalette when the palette doesn't have a required color is not supported. This is\nnot supported on purpose: this is information loss which requires a color\nreduction algorithm that is beyond the scope of a PNG encoder (yes, RGB to gray\nis easy, but there are multiple ways if you want to give some channels more\nweight).\n\nBy default, when decoding, you get the raw image in 32-bit RGBA or 24-bit RGB\ncolor, no matter what color type the PNG has. And by default when encoding,\nLodePNG automatically picks the best color model for the output PNG, and expects\nthe input image to be 32-bit RGBA or 24-bit RGB. So, unless you want to control\nthe color format of the images yourself, you can skip this chapter.\n\n6.1. PNG color types\n--------------------\n\nA PNG image can have many color types, ranging from 1-bit color to 64-bit color,\nas well as palettized color modes. After the zlib decompression and unfiltering\nin the PNG image is done, the raw pixel data will have that color type and thus\na certain amount of bits per pixel. If you want the output raw image after\ndecoding to have another color type, a conversion is done by LodePNG.\n\nThe PNG specification gives the following color types:\n\n0: grayscale, bit depths 1, 2, 4, 8, 16\n2: RGB, bit depths 8 and 16\n3: palette, bit depths 1, 2, 4 and 8\n4: grayscale with alpha, bit depths 8 and 16\n6: RGBA, bit depths 8 and 16\n\nBit depth is the amount of bits per pixel per color channel. So the total amount\nof bits per pixel is: amount of channels * bitdepth.\n\n6.2. color conversions\n----------------------\n\nAs explained in the sections about the encoder and decoder, you can specify\ncolor types and bit depths in info_png and info_raw to change the default\nbehaviour.\n\nIf, when decoding, you want the raw image to be something else than the default,\nyou need to set the color type and bit depth you want in the LodePNGColorMode,\nor the parameters colortype and bitdepth of the simple decoding function.\n\nIf, when encoding, you use another color type than the default in the raw input\nimage, you need to specify its color type and bit depth in the LodePNGColorMode\nof the raw image, or use the parameters colortype and bitdepth of the simple\nencoding function.\n\nIf, when encoding, you don't want LodePNG to choose the output PNG color type\nbut control it yourself, you need to set auto_convert in the encoder settings\nto false, and specify the color type you want in the LodePNGInfo of the\nencoder (including palette: it can generate a palette if auto_convert is true,\notherwise not).\n\nIf the input and output color type differ (whether user chosen or auto chosen),\nLodePNG will do a color conversion, which follows the rules below, and may\nsometimes result in an error.\n\nTo avoid some confusion:\n-the decoder converts from PNG to raw image\n-the encoder converts from raw image to PNG\n-the colortype and bitdepth in LodePNGColorMode info_raw, are those of the raw image\n-the colortype and bitdepth in the color field of LodePNGInfo info_png, are those of the PNG\n-when encoding, the color type in LodePNGInfo is ignored if auto_convert\n is enabled, it is automatically generated instead\n-when decoding, the color type in LodePNGInfo is set by the decoder to that of the original\n PNG image, but it can be ignored since the raw image has the color type you requested instead\n-if the color type of the LodePNGColorMode and PNG image aren't the same, a conversion\n between the color types is done if the color types are supported. If it is not\n supported, an error is returned. If the types are the same, no conversion is done.\n-even though some conversions aren't supported, LodePNG supports loading PNGs from any\n colortype and saving PNGs to any colortype, sometimes it just requires preparing\n the raw image correctly before encoding.\n-both encoder and decoder use the same color converter.\n\nThe function lodepng_convert does the color conversion. It is available in the\ninterface but normally isn't needed since the encoder and decoder already call\nit.\n\nNon supported color conversions:\n-color to grayscale when non-gray pixels are present: no error is thrown, but\nthe result will look ugly because only the red channel is taken (it assumes all\nthree channels are the same in this case so ignores green and blue). The reason\nno error is given is to allow converting from three-channel grayscale images to\none-channel even if there are numerical imprecisions.\n-anything to palette when the palette does not have an exact match for a from-color\nin it: in this case an error is thrown\n\nSupported color conversions:\n-anything to 8-bit RGB, 8-bit RGBA, 16-bit RGB, 16-bit RGBA\n-any gray or gray+alpha, to gray or gray+alpha\n-anything to a palette, as long as the palette has the requested colors in it\n-removing alpha channel\n-higher to smaller bitdepth, and vice versa\n\nIf you want no color conversion to be done (e.g. for speed or control):\n-In the encoder, you can make it save a PNG with any color type by giving the\nraw color mode and LodePNGInfo the same color mode, and setting auto_convert to\nfalse.\n-In the decoder, you can make it store the pixel data in the same color type\nas the PNG has, by setting the color_convert setting to false. Settings in\ninfo_raw are then ignored.\n\n6.3. padding bits\n-----------------\n\nIn the PNG file format, if a less than 8-bit per pixel color type is used and the scanlines\nhave a bit amount that isn't a multiple of 8, then padding bits are used so that each\nscanline starts at a fresh byte. But that is NOT true for the LodePNG raw input and output.\nThe raw input image you give to the encoder, and the raw output image you get from the decoder\nwill NOT have these padding bits, e.g. in the case of a 1-bit image with a width\nof 7 pixels, the first pixel of the second scanline will the 8th bit of the first byte,\nnot the first bit of a new byte.\n\n6.4. A note about 16-bits per channel and endianness\n----------------------------------------------------\n\nLodePNG uses unsigned char arrays for 16-bit per channel colors too, just like\nfor any other color format. The 16-bit values are stored in big endian (most\nsignificant byte first) in these arrays. This is the opposite order of the\nlittle endian used by x86 CPU's.\n\nLodePNG always uses big endian because the PNG file format does so internally.\nConversions to other formats than PNG uses internally are not supported by\nLodePNG on purpose, there are myriads of formats, including endianness of 16-bit\ncolors, the order in which you store R, G, B and A, and so on. Supporting and\nconverting to/from all that is outside the scope of LodePNG.\n\nThis may mean that, depending on your use case, you may want to convert the big\nendian output of LodePNG to little endian with a for loop. This is certainly not\nalways needed, many applications and libraries support big endian 16-bit colors\nanyway, but it means you cannot simply cast the unsigned char* buffer to an\nunsigned short* buffer on x86 CPUs.\n\n\n7. error values\n---------------\n\nAll functions in LodePNG that return an error code, return 0 if everything went\nOK, or a non-zero code if there was an error.\n\nThe meaning of the LodePNG error values can be retrieved with the function\nlodepng_error_text: given the numerical error code, it returns a description\nof the error in English as a string.\n\nCheck the implementation of lodepng_error_text to see the meaning of each code.\n\nIt is not recommended to use the numerical values to programmatically make\ndifferent decisions based on error types as the numbers are not guaranteed to\nstay backwards compatible. They are for human consumption only. Programmatically\nonly 0 or non-0 matter.\n\n\n8. chunks and PNG editing\n-------------------------\n\nIf you want to add extra chunks to a PNG you encode, or use LodePNG for a PNG\neditor that should follow the rules about handling of unknown chunks, or if your\nprogram is able to read other types of chunks than the ones handled by LodePNG,\nthen that's possible with the chunk functions of LodePNG.\n\nA PNG chunk has the following layout:\n\n4 bytes length\n4 bytes type name\nlength bytes data\n4 bytes CRC\n\n8.1. iterating through chunks\n-----------------------------\n\nIf you have a buffer containing the PNG image data, then the first chunk (the\nIHDR chunk) starts at byte number 8 of that buffer. The first 8 bytes are the\nsignature of the PNG and are not part of a chunk. But if you start at byte 8\nthen you have a chunk, and can check the following things of it.\n\nNOTE: none of these functions check for memory buffer boundaries. To avoid\nexploits, always make sure the buffer contains all the data of the chunks.\nWhen using lodepng_chunk_next, make sure the returned value is within the\nallocated memory.\n\nunsigned lodepng_chunk_length(const unsigned char* chunk):\n\nGet the length of the chunk's data. The total chunk length is this length + 12.\n\nvoid lodepng_chunk_type(char type[5], const unsigned char* chunk):\nunsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type):\n\nGet the type of the chunk or compare if it's a certain type\n\nunsigned char lodepng_chunk_critical(const unsigned char* chunk):\nunsigned char lodepng_chunk_private(const unsigned char* chunk):\nunsigned char lodepng_chunk_safetocopy(const unsigned char* chunk):\n\nCheck if the chunk is critical in the PNG standard (only IHDR, PLTE, IDAT and IEND are).\nCheck if the chunk is private (public chunks are part of the standard, private ones not).\nCheck if the chunk is safe to copy. If it's not, then, when modifying data in a critical\nchunk, unsafe to copy chunks of the old image may NOT be saved in the new one if your\nprogram doesn't handle that type of unknown chunk.\n\nunsigned char* lodepng_chunk_data(unsigned char* chunk):\nconst unsigned char* lodepng_chunk_data_const(const unsigned char* chunk):\n\nGet a pointer to the start of the data of the chunk.\n\nunsigned lodepng_chunk_check_crc(const unsigned char* chunk):\nvoid lodepng_chunk_generate_crc(unsigned char* chunk):\n\nCheck if the crc is correct or generate a correct one.\n\nunsigned char* lodepng_chunk_next(unsigned char* chunk):\nconst unsigned char* lodepng_chunk_next_const(const unsigned char* chunk):\n\nIterate to the next chunk. This works if you have a buffer with consecutive chunks. Note that these\nfunctions do no boundary checking of the allocated data whatsoever, so make sure there is enough\ndata available in the buffer to be able to go to the next chunk.\n\nunsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk):\nunsigned lodepng_chunk_create(unsigned char** out, size_t* outsize, unsigned length,\n                              const char* type, const unsigned char* data):\n\nThese functions are used to create new chunks that are appended to the data in *out that has\nlength *outsize. The append function appends an existing chunk to the new data. The create\nfunction creates a new chunk with the given parameters and appends it. Type is the 4-letter\nname of the chunk.\n\n8.2. chunks in info_png\n-----------------------\n\nThe LodePNGInfo struct contains fields with the unknown chunk in it. It has 3\nbuffers (each with size) to contain 3 types of unknown chunks:\nthe ones that come before the PLTE chunk, the ones that come between the PLTE\nand the IDAT chunks, and the ones that come after the IDAT chunks.\nIt's necessary to make the distinction between these 3 cases because the PNG\nstandard forces to keep the ordering of unknown chunks compared to the critical\nchunks, but does not force any other ordering rules.\n\ninfo_png.unknown_chunks_data[0] is the chunks before PLTE\ninfo_png.unknown_chunks_data[1] is the chunks after PLTE, before IDAT\ninfo_png.unknown_chunks_data[2] is the chunks after IDAT\n\nThe chunks in these 3 buffers can be iterated through and read by using the same\nway described in the previous subchapter.\n\nWhen using the decoder to decode a PNG, you can make it store all unknown chunks\nif you set the option settings.remember_unknown_chunks to 1. By default, this\noption is off (0).\n\nThe encoder will always encode unknown chunks that are stored in the info_png.\nIf you need it to add a particular chunk that isn't known by LodePNG, you can\nuse lodepng_chunk_append or lodepng_chunk_create to the chunk data in\ninfo_png.unknown_chunks_data[x].\n\nChunks that are known by LodePNG should not be added in that way. E.g. to make\nLodePNG add a bKGD chunk, set background_defined to true and add the correct\nparameters there instead.\n\n\n9. compiler support\n-------------------\n\nNo libraries other than the current standard C library are needed to compile\nLodePNG. For the C++ version, only the standard C++ library is needed on top.\nAdd the files lodepng.c(pp) and lodepng.h to your project, include\nlodepng.h where needed, and your program can read/write PNG files.\n\nIt is compatible with C90 and up, and C++03 and up.\n\nIf performance is important, use optimization when compiling! For both the\nencoder and decoder, this makes a large difference.\n\nMake sure that LodePNG is compiled with the same compiler of the same version\nand with the same settings as the rest of the program, or the interfaces with\nstd::vectors and std::strings in C++ can be incompatible.\n\nCHAR_BITS must be 8 or higher, because LodePNG uses unsigned chars for octets.\n\n*) gcc and g++\n\nLodePNG is developed in gcc so this compiler is natively supported. It gives no\nwarnings with compiler options \"-Wall -Wextra -pedantic -ansi\", with gcc and g++\nversion 4.7.1 on Linux, 32-bit and 64-bit.\n\n*) Clang\n\nFully supported and warning-free.\n\n*) Mingw\n\nThe Mingw compiler (a port of gcc for Windows) should be fully supported by\nLodePNG.\n\n*) Visual Studio and Visual C++ Express Edition\n\nLodePNG should be warning-free with warning level W4. Two warnings were disabled\nwith pragmas though: warning 4244 about implicit conversions, and warning 4996\nwhere it wants to use a non-standard function fopen_s instead of the standard C\nfopen.\n\nVisual Studio may want \"stdafx.h\" files to be included in each source file and\ngive an error \"unexpected end of file while looking for precompiled header\".\nThis is not standard C++ and will not be added to the stock LodePNG. You can\ndisable it for lodepng.cpp only by right clicking it, Properties, C/C++,\nPrecompiled Headers, and set it to Not Using Precompiled Headers there.\n\nNOTE: Modern versions of VS should be fully supported, but old versions, e.g.\nVS6, are not guaranteed to work.\n\n*) Compilers on Macintosh\n\nLodePNG has been reported to work both with gcc and LLVM for Macintosh, both for\nC and C++.\n\n*) Other Compilers\n\nIf you encounter problems on any compilers, feel free to let me know and I may\ntry to fix it if the compiler is modern and standards compliant.\n\n\n10. examples\n------------\n\nThis decoder example shows the most basic usage of LodePNG. More complex\nexamples can be found on the LodePNG website.\n\nNOTE: these examples do not support wide-character filenames, you can use an\nexternal method to handle such files and encode or decode in-memory\n\n10.1. decoder C++ example\n-------------------------\n\n#include \"lodepng.h\"\n#include <iostream>\n\nint main(int argc, char *argv[]) {\n  const char* filename = argc > 1 ? argv[1] : \"test.png\";\n\n  //load and decode\n  std::vector<unsigned char> image;\n  unsigned width, height;\n  unsigned error = lodepng::decode(image, width, height, filename);\n\n  //if there's an error, display it\n  if(error) std::cout << \"decoder error \" << error << \": \" << lodepng_error_text(error) << std::endl;\n\n  //the pixels are now in the vector \"image\", 4 bytes per pixel, ordered RGBARGBA..., use it as texture, draw it, ...\n}\n\n10.2. decoder C example\n-----------------------\n\n#include \"lodepng.h\"\n\nint main(int argc, char *argv[]) {\n  unsigned error;\n  unsigned char* image;\n  size_t width, height;\n  const char* filename = argc > 1 ? argv[1] : \"test.png\";\n\n  error = lodepng_decode32_file(&image, &width, &height, filename);\n\n  if(error) printf(\"decoder error %u: %s\\n\", error, lodepng_error_text(error));\n\n  / * use image here * /\n\n  free(image);\n  return 0;\n}\n\n11. state settings reference\n----------------------------\n\nA quick reference of some settings to set on the LodePNGState\n\nFor decoding:\n\nstate.decoder.zlibsettings.ignore_adler32: ignore ADLER32 checksums\nstate.decoder.zlibsettings.custom_...: use custom inflate function\nstate.decoder.ignore_crc: ignore CRC checksums\nstate.decoder.ignore_critical: ignore unknown critical chunks\nstate.decoder.ignore_end: ignore missing IEND chunk. May fail if this corruption causes other errors\nstate.decoder.color_convert: convert internal PNG color to chosen one\nstate.decoder.read_text_chunks: whether to read in text metadata chunks\nstate.decoder.remember_unknown_chunks: whether to read in unknown chunks\nstate.info_raw.colortype: desired color type for decoded image\nstate.info_raw.bitdepth: desired bit depth for decoded image\nstate.info_raw....: more color settings, see struct LodePNGColorMode\nstate.info_png....: no settings for decoder but ouput, see struct LodePNGInfo\n\nFor encoding:\n\nstate.encoder.zlibsettings.btype: disable compression by setting it to 0\nstate.encoder.zlibsettings.use_lz77: use LZ77 in compression\nstate.encoder.zlibsettings.windowsize: tweak LZ77 windowsize\nstate.encoder.zlibsettings.minmatch: tweak min LZ77 length to match\nstate.encoder.zlibsettings.nicematch: tweak LZ77 match where to stop searching\nstate.encoder.zlibsettings.lazymatching: try one more LZ77 matching\nstate.encoder.zlibsettings.custom_...: use custom deflate function\nstate.encoder.auto_convert: choose optimal PNG color type, if 0 uses info_png\nstate.encoder.filter_palette_zero: PNG filter strategy for palette\nstate.encoder.filter_strategy: PNG filter strategy to encode with\nstate.encoder.force_palette: add palette even if not encoding to one\nstate.encoder.add_id: add LodePNG identifier and version as a text chunk\nstate.encoder.text_compression: use compressed text chunks for metadata\nstate.info_raw.colortype: color type of raw input image you provide\nstate.info_raw.bitdepth: bit depth of raw input image you provide\nstate.info_raw: more color settings, see struct LodePNGColorMode\nstate.info_png.color.colortype: desired color type if auto_convert is false\nstate.info_png.color.bitdepth: desired bit depth if auto_convert is false\nstate.info_png.color....: more color settings, see struct LodePNGColorMode\nstate.info_png....: more PNG related settings, see struct LodePNGInfo\n\n\n12. changes\n-----------\n\nThe version number of LodePNG is the date of the change given in the format\nyyyymmdd.\n\nSome changes aren't backwards compatible. Those are indicated with a (!)\nsymbol.\n\nNot all changes are listed here, the commit history in github lists more:\nhttps://github.com/lvandeve/lodepng\n\n*) 23 dec 2024: added support for the mDCv and cLLi chunks (for png third\n   edition spec)\n*) 22 dec 2024: added support for the cICP chunk (for png third edition spec)\n*) 15 dec 2024: added support for the eXIf chunk (for png third edition spec)\n*) 10 apr 2023: faster CRC32 implementation, but with larger lookup table.\n*) 13 jun 2022: added support for the sBIT chunk.\n*) 09 jan 2022: minor decoder speed improvements.\n*) 27 jun 2021: added warnings that file reading/writing functions don't support\n   wide-character filenames (support for this is not planned, opening files is\n   not the core part of PNG decoding/decoding and is platform dependent).\n*) 17 okt 2020: prevent decoding too large text/icc chunks by default.\n*) 06 mar 2020: simplified some of the dynamic memory allocations.\n*) 12 jan 2020: (!) added 'end' argument to lodepng_chunk_next to allow correct\n   overflow checks.\n*) 14 aug 2019: around 25% faster decoding thanks to huffman lookup tables.\n*) 15 jun 2019: (!) auto_choose_color API changed (for bugfix: don't use palette\n   if gray ICC profile) and non-ICC LodePNGColorProfile renamed to\n   LodePNGColorStats.\n*) 30 dec 2018: code style changes only: removed newlines before opening braces.\n*) 10 sep 2018: added way to inspect metadata chunks without full decoding.\n*) 19 aug 2018: (!) fixed color mode bKGD is encoded with and made it use\n   palette index in case of palette.\n*) 10 aug 2018: (!) added support for gAMA, cHRM, sRGB and iCCP chunks. This\n   change is backwards compatible unless you relied on unknown_chunks for those.\n*) 11 jun 2018: less restrictive check for pixel size integer overflow\n*) 14 jan 2018: allow optionally ignoring a few more recoverable errors\n*) 17 sep 2017: fix memory leak for some encoder input error cases\n*) 27 nov 2016: grey+alpha auto color model detection bugfix\n*) 18 apr 2016: Changed qsort to custom stable sort (for platforms w/o qsort).\n*) 09 apr 2016: Fixed colorkey usage detection, and better file loading (within\n   the limits of pure C90).\n*) 08 dec 2015: Made load_file function return error if file can't be opened.\n*) 24 okt 2015: Bugfix with decoding to palette output.\n*) 18 apr 2015: Boundary PM instead of just package-merge for faster encoding.\n*) 24 aug 2014: Moved to github\n*) 23 aug 2014: Reduced needless memory usage of decoder.\n*) 28 jun 2014: Removed fix_png setting, always support palette OOB for\n    simplicity. Made ColorProfile public.\n*) 09 jun 2014: Faster encoder by fixing hash bug and more zeros optimization.\n*) 22 dec 2013: Power of two windowsize required for optimization.\n*) 15 apr 2013: Fixed bug with LAC_ALPHA and color key.\n*) 25 mar 2013: Added an optional feature to ignore some PNG errors (fix_png).\n*) 11 mar 2013: (!) Bugfix with custom free. Changed from \"my\" to \"lodepng_\"\n    prefix for the custom allocators and made it possible with a new #define to\n    use custom ones in your project without needing to change lodepng's code.\n*) 28 jan 2013: Bugfix with color key.\n*) 27 okt 2012: Tweaks in text chunk keyword length error handling.\n*) 8 okt 2012: (!) Added new filter strategy (entropy) and new auto color mode.\n    (no palette). Better deflate tree encoding. New compression tweak settings.\n    Faster color conversions while decoding. Some internal cleanups.\n*) 23 sep 2012: Reduced warnings in Visual Studio a little bit.\n*) 1 sep 2012: (!) Removed #define's for giving custom (de)compression functions\n    and made it work with function pointers instead.\n*) 23 jun 2012: Added more filter strategies. Made it easier to use custom alloc\n    and free functions and toggle #defines from compiler flags. Small fixes.\n*) 6 may 2012: (!) Made plugging in custom zlib/deflate functions more flexible.\n*) 22 apr 2012: (!) Made interface more consistent, renaming a lot. Removed\n    redundant C++ codec classes. Reduced amount of structs. Everything changed,\n    but it is cleaner now imho and functionality remains the same. Also fixed\n    several bugs and shrunk the implementation code. Made new samples.\n*) 6 nov 2011: (!) By default, the encoder now automatically chooses the best\n    PNG color model and bit depth, based on the amount and type of colors of the\n    raw image. For this, autoLeaveOutAlphaChannel replaced by auto_choose_color.\n*) 9 okt 2011: simpler hash chain implementation for the encoder.\n*) 8 sep 2011: lz77 encoder lazy matching instead of greedy matching.\n*) 23 aug 2011: tweaked the zlib compression parameters after benchmarking.\n    A bug with the PNG filtertype heuristic was fixed, so that it chooses much\n    better ones (it's quite significant). A setting to do an experimental, slow,\n    brute force search for PNG filter types is added.\n*) 17 aug 2011: (!) changed some C zlib related function names.\n*) 16 aug 2011: made the code less wide (max 120 characters per line).\n*) 17 apr 2011: code cleanup. Bugfixes. Convert low to 16-bit per sample colors.\n*) 21 feb 2011: fixed compiling for C90. Fixed compiling with sections disabled.\n*) 11 dec 2010: encoding is made faster, based on suggestion by Peter Eastman\n    to optimize long sequences of zeros.\n*) 13 nov 2010: added LodePNG_InfoColor_hasPaletteAlpha and\n    LodePNG_InfoColor_canHaveAlpha functions for convenience.\n*) 7 nov 2010: added LodePNG_error_text function to get error code description.\n*) 30 okt 2010: made decoding slightly faster\n*) 26 okt 2010: (!) changed some C function and struct names (more consistent).\n     Reorganized the documentation and the declaration order in the header.\n*) 08 aug 2010: only changed some comments and external samples.\n*) 05 jul 2010: fixed bug thanks to warnings in the new gcc version.\n*) 14 mar 2010: fixed bug where too much memory was allocated for char buffers.\n*) 02 sep 2008: fixed bug where it could create empty tree that linux apps could\n    read by ignoring the problem but windows apps couldn't.\n*) 06 jun 2008: added more error checks for out of memory cases.\n*) 26 apr 2008: added a few more checks here and there to ensure more safety.\n*) 06 mar 2008: crash with encoding of strings fixed\n*) 02 feb 2008: support for international text chunks added (iTXt)\n*) 23 jan 2008: small cleanups, and #defines to divide code in sections\n*) 20 jan 2008: support for unknown chunks allowing using LodePNG for an editor.\n*) 18 jan 2008: support for tIME and pHYs chunks added to encoder and decoder.\n*) 17 jan 2008: ability to encode and decode compressed zTXt chunks added\n    Also various fixes, such as in the deflate and the padding bits code.\n*) 13 jan 2008: Added ability to encode Adam7-interlaced images. Improved\n    filtering code of encoder.\n*) 07 jan 2008: (!) changed LodePNG to use ISO C90 instead of C++. A\n    C++ wrapper around this provides an interface almost identical to before.\n    Having LodePNG be pure ISO C90 makes it more portable. The C and C++ code\n    are together in these files but it works both for C and C++ compilers.\n*) 29 dec 2007: (!) changed most integer types to unsigned int + other tweaks\n*) 30 aug 2007: bug fixed which makes this Borland C++ compatible\n*) 09 aug 2007: some VS2005 warnings removed again\n*) 21 jul 2007: deflate code placed in new namespace separate from zlib code\n*) 08 jun 2007: fixed bug with 2- and 4-bit color, and small interlaced images\n*) 04 jun 2007: improved support for Visual Studio 2005: crash with accessing\n    invalid std::vector element [0] fixed, and level 3 and 4 warnings removed\n*) 02 jun 2007: made the encoder add a tag with version by default\n*) 27 may 2007: zlib and png code separated (but still in the same file),\n    simple encoder/decoder functions added for more simple usage cases\n*) 19 may 2007: minor fixes, some code cleaning, new error added (error 69),\n    moved some examples from here to lodepng_examples.cpp\n*) 12 may 2007: palette decoding bug fixed\n*) 24 apr 2007: changed the license from BSD to the zlib license\n*) 11 mar 2007: very simple addition: ability to encode bKGD chunks.\n*) 04 mar 2007: (!) tEXt chunk related fixes, and support for encoding\n    palettized PNG images. Plus little interface change with palette and texts.\n*) 03 mar 2007: Made it encode dynamic Huffman shorter with repeat codes.\n    Fixed a bug where the end code of a block had length 0 in the Huffman tree.\n*) 26 feb 2007: Huffman compression with dynamic trees (BTYPE 2) now implemented\n    and supported by the encoder, resulting in smaller PNGs at the output.\n*) 27 jan 2007: Made the Adler-32 test faster so that a timewaste is gone.\n*) 24 jan 2007: gave encoder an error interface. Added color conversion from any\n    greyscale type to 8-bit greyscale with or without alpha.\n*) 21 jan 2007: (!) Totally changed the interface. It allows more color types\n    to convert to and is more uniform. See the manual for how it works now.\n*) 07 jan 2007: Some cleanup & fixes, and a few changes over the last days:\n    encode/decode custom tEXt chunks, separate classes for zlib & deflate, and\n    at last made the decoder give errors for incorrect Adler32 or Crc.\n*) 01 jan 2007: Fixed bug with encoding PNGs with less than 8 bits per channel.\n*) 29 dec 2006: Added support for encoding images without alpha channel, and\n    cleaned out code as well as making certain parts faster.\n*) 28 dec 2006: Added \"Settings\" to the encoder.\n*) 26 dec 2006: The encoder now does LZ77 encoding and produces much smaller files now.\n    Removed some code duplication in the decoder. Fixed little bug in an example.\n*) 09 dec 2006: (!) Placed output parameters of public functions as first parameter.\n    Fixed a bug of the decoder with 16-bit per color.\n*) 15 okt 2006: Changed documentation structure\n*) 09 okt 2006: Encoder class added. It encodes a valid PNG image from the\n    given image buffer, however for now it's not compressed.\n*) 08 sep 2006: (!) Changed to interface with a Decoder class\n*) 30 jul 2006: (!) LodePNG_InfoPng , width and height are now retrieved in different\n    way. Renamed decodePNG to decodePNGGeneric.\n*) 29 jul 2006: (!) Changed the interface: image info is now returned as a\n    struct of type LodePNG::LodePNG_Info, instead of a vector, which was a bit clumsy.\n*) 28 jul 2006: Cleaned the code and added new error checks.\n    Corrected terminology \"deflate\" into \"inflate\".\n*) 23 jun 2006: Added SDL example in the documentation in the header, this\n    example allows easy debugging by displaying the PNG and its transparency.\n*) 22 jun 2006: (!) Changed way to obtain error value. Added\n    loadFile function for convenience. Made decodePNG32 faster.\n*) 21 jun 2006: (!) Changed type of info vector to unsigned.\n    Changed position of palette in info vector. Fixed an important bug that\n    happened on PNGs with an uncompressed block.\n*) 16 jun 2006: Internally changed unsigned into unsigned where\n    needed, and performed some optimizations.\n*) 07 jun 2006: (!) Renamed functions to decodePNG and placed them\n    in LodePNG namespace. Changed the order of the parameters. Rewrote the\n    documentation in the header. Renamed files to lodepng.cpp and lodepng.h\n*) 22 apr 2006: Optimized and improved some code\n*) 07 sep 2005: (!) Changed to std::vector interface\n*) 12 aug 2005: Initial release (C++, decoder only)\n*/\n"
        },
        {
          "name": "lodepng_benchmark.cpp",
          "type": "blob",
          "size": 13.677734375,
          "content": "/*\nLodePNG Benchmark\n\nCopyright (c) 2005-2023 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n//g++ lodepng.cpp lodepng_benchmark.cpp -Wall -Wextra -pedantic -ansi -lSDL -O3\n//g++ lodepng.cpp lodepng_benchmark.cpp -Wall -Wextra -pedantic -ansi -lSDL -O3 && ./a.out\n\n#include \"lodepng.h\"\n\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <sstream>\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <SDL2/SDL.h> //SDL is used for timing.\n\nbool apply_mods = false;\n\n#define NUM_DECODE 5 //decode multiple times to measure better. Must be at least 1.\n\nsize_t total_pixels = 0;\nsize_t total_png_orig_size = 0;\nsize_t total_raw_orig_size = 0; // This is the uncompressed data in the raw color format in the original input PNGs\n\ndouble total_dec_time = 0;\nsize_t total_png_in_size = 0;\nsize_t total_raw_in_size = 0; // This is the uncompressed data in the raw color format in the input PNGs given to the decoder (not same as orig when using the encoded ones)\nsize_t total_raw_dec_size = 0; // This is the uncompressed data in the raw color format of raw image buffers output by the decoder\n\ndouble total_enc_time = 0;\nsize_t total_raw_enc_size = 0; // This is the uncompressed data in the raw color format of the raw images given to the encoder\nsize_t total_png_out_size = 0;\nsize_t total_raw_out_size = 0; // This is the uncompressed data in the raw color format of the encoded PNGs\n\nbool verbose = false;\nbool do_decode = false;\nbool do_encode = false;\nbool decode_encoded = false; // do the decoding benchmark on the encoded images rather than the original inputs\n\nstd::string dumpdir;\n\n////////////////////////////////////////////////////////////////////////////////\n\ndouble getTime() {\n  return SDL_GetTicks() / 1000.0;\n}\n\ntemplate<typename T, typename U>\nvoid assertEquals(const T& expected, const U& actual, const std::string& message = \"\") {\n  if(expected != (T)actual) {\n    std::cout << \"Error: Not equal! Expected \" << expected << \" got \" << actual << \".\" << std::endl;\n    std::cout << \"Message: \" << message << std::endl;\n    std::exit(1);\n  }\n}\n\nvoid assertTrue(bool value, const std::string& message = \"\") {\n  if(!value) {\n    std::cout << \"Error: expected true.\" << std::endl;\n    std::cout << \"Message: \" << message << std::endl;\n    std::exit(1);\n  }\n}\n\n//Test image data\nstruct Image {\n  std::vector<unsigned char> data;\n  unsigned width;\n  unsigned height;\n  LodePNGColorType colorType;\n  unsigned bitDepth;\n  std::string name;\n};\n\n//Utility for debug messages\ntemplate<typename T>\nstd::string valtostr(const T& val) {\n  std::ostringstream sstream;\n  sstream << val;\n  return sstream.str();\n}\n\ntemplate<typename T>\nvoid printValue(const std::string& name, const T& value, const std::string& unit = \"\") {\n  std::cout << name << \": \" << value << unit << std::endl;\n}\n\ntemplate<typename T, typename U>\nvoid printValue(const std::string& name, const T& value, const std::string& s2, const U& value2, const std::string& unit = \"\") {\n  std::cout << name << \": \" << value << s2 << value2 << unit << std::endl;\n}\n\n//Test LodePNG encoding and decoding the encoded result, using the C interface\nstd::vector<unsigned char> testEncode(Image& image) {\n  unsigned char* encoded = 0;\n  size_t encoded_size = 0;\n  lodepng::State state;\n  state.info_raw.colortype = image.colorType;\n  state.info_raw.bitdepth = image.bitDepth;\n\n  // Try custom compression settings\n  if(apply_mods) {\n    //state.encoder.filter_strategy = LFS_ZERO;\n    //state.encoder.filter_strategy = LFS_ENTROPY;\n    //state.encoder.filter_strategy = LFS_FOUR;\n    //state.encoder.zlibsettings.btype = 0;\n    //state.encoder.zlibsettings.btype = 1;\n    //state.encoder.auto_convert = 0;\n    //state.encoder.zlibsettings.use_lz77 = 0;\n    state.encoder.zlibsettings.windowsize = 1;\n    //state.encoder.zlibsettings.windowsize = 32768;\n  }\n\n  double t_enc0 = getTime();\n\n  unsigned error_enc = lodepng_encode(&encoded, &encoded_size, &image.data[0],\n                                      image.width, image.height, &state);\n\n  double t_enc1 = getTime();\n\n  assertEquals(0, error_enc, \"encoder error\");\n\n  total_raw_enc_size += lodepng_get_raw_size(image.width, image.height, &state.info_raw);\n  total_png_out_size += encoded_size;\n  total_enc_time += (t_enc1 - t_enc0);\n\n  if(verbose) {\n    printValue(\"encoding time\", t_enc1 - t_enc0, \"s\");\n    std::cout << \"compression: \" << ((double)(encoded_size) / (double)(image.data.size())) * 100 << \"%\"\n              << \", ratio: \" << ((double)(image.data.size()) / (double)(encoded_size))\n              << \", size: \" << encoded_size\n              << \", bpp: \" << (8.0 * encoded_size / image.width / image.height) << std::endl;\n  }\n\n  if(!dumpdir.empty()) {\n    std::string dumpname = dumpdir;\n    if(dumpname[dumpname.size() - 1] != '/') dumpname += \"/\";\n    dumpname += image.name;\n    if(lodepng_save_file(encoded, encoded_size, dumpname.c_str())) {\n      std::cout << \"WARNING: failed to dump \" << dumpname << \". The dir must already exist.\" << std::endl;\n    } else if(verbose) {\n      std::cout << \"saved to: \" << dumpname << std::endl;\n    }\n  }\n\n  // output image stats\n  {\n    lodepng::State inspect;\n    unsigned w, h;\n    lodepng_inspect(&w, &h, &inspect, encoded, encoded_size);\n    total_raw_out_size += lodepng_get_raw_size(w, h, &inspect.info_png.color);\n  }\n\n  std::vector<unsigned char> result(encoded, encoded + encoded_size);\n  free(encoded);\n  return result;\n}\n\nvoid testDecode(const std::vector<unsigned char>& png) {\n  lodepng::State state;\n  unsigned char* decoded = 0;\n  unsigned w, h;\n\n  // Try custom decompression settings\n  if(apply_mods) {\n    state.decoder.color_convert = 0;\n    //state.decoder.ignore_crc = 1;\n  }\n\n  double t_dec0 = getTime();\n  for(int i = 0; i < NUM_DECODE; i++) {\n    unsigned error_dec = lodepng_decode(&decoded, &w, &h, &state, png.data(), png.size());\n    assertEquals(0, error_dec, \"decoder error\");\n  }\n  double t_dec1 = getTime();\n\n  total_dec_time += (t_dec1 - t_dec0);\n\n  total_raw_dec_size += lodepng_get_raw_size(w, h, &state.info_raw);\n\n  if(verbose) {\n    printValue(\"decoding time\", t_dec1 - t_dec0, \"/\", NUM_DECODE, \" s\");\n  }\n  free(decoded);\n\n  // input image stats\n  {\n    lodepng::State inspect;\n    unsigned w, h;\n    lodepng_inspect(&w, &h, &inspect, png.data(), png.size());\n    total_raw_in_size += lodepng_get_raw_size(w, h, &inspect.info_png.color);\n    total_png_in_size += png.size();\n  }\n}\n\nstd::string getFilePart(const std::string& path) {\n  if(path.empty()) return \"\";\n  int slash = path.size() - 1;\n  while(slash >= 0 && path[(size_t)slash] != '/') slash--;\n  return path.substr((size_t)(slash + 1));\n}\n\nvoid testFile(const std::string& filename) {\n  if(verbose) std::cout << \"file \" << filename << std::endl;\n\n  std::vector<unsigned char> png;\n  if(lodepng::load_file(png, filename)) {\n    std::cout << \"\\nfailed to load file \" << filename << std::endl << std::endl;\n    return;\n  }\n\n  // input image stats\n  {\n    lodepng::State inspect;\n    unsigned w, h;\n    lodepng_inspect(&w, &h, &inspect, png.data(), png.size());\n    total_pixels += (w * h);\n    total_png_orig_size += png.size();\n    size_t raw_size = lodepng_get_raw_size(w, h, &inspect.info_png.color);\n    total_raw_orig_size += raw_size;\n    if(verbose) std::cout << \"orig compressed size: \" << png.size() << \", pixels: \" << (w * h) << \", raw size: \" << raw_size << std::endl;\n  }\n\n  if(do_encode) {\n    Image image;\n    image.name = getFilePart(filename);\n    image.colorType = LCT_RGBA;\n    image.bitDepth = 8;\n    assertEquals(0, lodepng::decode(image.data, image.width, image.height, filename, image.colorType, image.bitDepth));\n\n    std::vector<unsigned char> temp = testEncode(image);\n    if(decode_encoded) png = temp;\n  }\n\n  if(do_decode) {\n    testDecode(png);\n  }\n\n  if(verbose) std::cout << std::endl;\n}\n\nvoid showHelp(int argc, char *argv[]) {\n  (void)argc;\n  std::cout << \"Usage: \" << argv[0] << \" png_filenames... [OPTIONS...] [--dumpdir directory]\" << std::endl;\n  std::cout << \"Options:\" << std::endl;\n  std::cout << \"  -h: show this help\" << std::endl;\n  std::cout << \"  -v: verbose\" << std::endl;\n  std::cout << \"  -d: decode only\" << std::endl;\n  std::cout << \"  -e: encode only\" << std::endl;\n  std::cout << \"  -o: decode on original images rather than encoded ones (always true if -d without -e)\" << std::endl;\n  std::cout << \"  -m: apply modifications to encoder and decoder settings, the modification itself must be implemented or changed in the benchmark source code (search for apply_mods in the code, for encode and for decode)\" << std::endl;\n}\n\nint main(int argc, char *argv[]) {\n  verbose = false;\n  do_decode = true;\n  do_encode = true;\n  decode_encoded = true;\n\n  std::vector<std::string> files;\n\n  for(int i = 1; i < argc; i++) {\n    std::string arg = argv[i];\n    if(arg == \"-v\") verbose = true;\n    else if(arg == \"-h\" || arg == \"--help\") { showHelp(argc, argv); return 0; }\n    else if(arg == \"-d\") do_decode ? (do_encode = false) : (do_decode = true);\n    else if(arg == \"-e\") do_encode ? (do_decode = false) : (do_encode = true);\n    else if(arg == \"-o\") decode_encoded = false;\n    else if(arg == \"-m\") apply_mods = true;\n    else if(arg == \"--dumpdir\" && i + 1 < argc) {\n      dumpdir = argv[++i];\n    }\n    else files.push_back(arg);\n  }\n\n  if(!do_encode) decode_encoded = false;\n\n  if(files.empty()) {\n    std::cout << \"must give .png filenames to benchamrk\" << std::endl;\n    showHelp(argc, argv);\n    return 1;\n  }\n\n\n\n  for(size_t i = 0; i < files.size(); i++) {\n    testFile(files[i]);\n  }\n\n  // test images stats\n  if(verbose) {\n    std::cout << \"Final Summary: \" << std::endl;\n    std::cout << \"input images: \" << files.size() << std::endl;\n    std::cout << \"total_pixels: \" << total_pixels << std::endl;\n    // file size of original PNGs that were given as command line arguments to the tool\n    std::cout << \"total_png_orig_size: \" << total_png_orig_size << \" (\" << (8.0 * total_png_orig_size / total_pixels) << \" bpp)\" << std::endl;\n    // size of the data inside the original PNGs, dependent on color encoding (bit depth used in the PNG)\n    std::cout << \"total_raw_orig_size: \" << total_raw_orig_size << \" (\" << (8.0 * total_raw_orig_size / total_pixels) << \" bpp)\" << std::endl;\n    // size of the pixel data given to the benchmark encoder, dependent on color encoding (bit depth used in the image representation in the benchmark tool, probably 32 bits)\n    if(do_encode) std::cout << \"total_raw_enc_size: \" << total_raw_enc_size << \" (\" << (8.0 * total_raw_enc_size / total_pixels) << \" bpp)\" << std::endl;\n    // file size of PNGs created by the benchmark encoder\n    if(do_encode) std::cout << \"total_png_out_size: \" << total_png_out_size << \" (\" << (8.0 * total_png_out_size / total_pixels) << \" bpp)\" << std::endl;\n    // size of the data inside the PNGs created by the benchmark encoder, dependent on color encoding (bit depth used in the PNG), may differ from total_raw_orig_size since the encoder may choose to use a different color encoding\n    if(do_encode) std::cout << \"total_raw_out_size: \" << total_raw_out_size << \" (\" << (8.0 * total_raw_out_size / total_pixels) << \" bpp)\" << std::endl;\n    // size of file size of the PNGs given to the benchmark decoder, this could either be the original ones or the ones encoded by the benchmark encoder depending on user options\n    if(do_decode) std::cout << \"total_png_in_size: \" << total_png_in_size << \" (\" << (8.0 * total_png_in_size / total_pixels) << \" bpp)\" << std::endl;\n    // size of the data inside the PNGs mentioned at total_png_in_size, dependent on color encoding (bit depth used in the image representation in the benchmark tool, probably 32 bits)\n    if(do_decode) std::cout << \"total_raw_in_size: \" << total_raw_in_size << \" (\" << (8.0 * total_raw_in_size / total_pixels) << \" bpp)\" << std::endl;\n    // size of the pixel data requested from the benchmark decoder, dependent on color encoding requested (bit depth used in the image representation in the benchmark tool, probably 32 bits)\n    if(do_decode) std::cout << \"total_raw_dec_size: \" << total_raw_dec_size << \" (\" << (8.0 * total_raw_dec_size / total_pixels) << \" bpp)\" << std::endl;\n  }\n\n  // final encoding stats\n  if(do_encode) {\n    std::cout << \"encoding time: \" << total_enc_time << \"s on \" << total_pixels << \" pixels and \" << total_raw_out_size << \" raw bytes (\"\n              << ((total_raw_enc_size/1024.0/1024.0)/(total_enc_time)) << \" MB/s, \" << ((total_pixels/1024.0/1024.0)/(total_enc_time)) << \" MP/s)\" << std::endl;\n    std::cout << \"encoded size: \" << total_png_out_size << \" (\" << (100.0 * total_png_out_size / total_raw_out_size) << \"%), bpp: \"\n              << (8.0 * total_png_out_size / total_pixels) << std::endl;\n  }\n\n  // final decoding stats\n  if(do_decode) {\n    if(verbose) std::cout << \"decoding iterations: \" << NUM_DECODE << std::endl;\n    std::cout << \"decoding time: \" << total_dec_time/NUM_DECODE << \"s on \" << total_pixels << \" pixels and \" << total_png_in_size\n              << \" compressed bytes (\" << ((total_raw_in_size/1024.0/1024.0)/(total_dec_time/NUM_DECODE)) << \" MB/s, \"\n              << ((total_pixels/1024.0/1024.0)/(total_dec_time/NUM_DECODE)) << \" MP/s)\" << std::endl;\n  }\n}\n"
        },
        {
          "name": "lodepng_fuzzer.cpp",
          "type": "blob",
          "size": 3.2548828125,
          "content": "/*\nLodePNG Fuzzer\n\nCopyright (c) 2005-2019 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n// clang++ -fsanitize=fuzzer lodepng.cpp lodepng_fuzzer.cpp -O3 && ./a.out\n\n#include \"lodepng.h\"\n\n#include <cstdint>\n\nnamespace {\n// Amount of valid colortype/bidthdepth combinations in the PNG file format.\nconst size_t num_combinations = 15;\n\nLodePNGColorType colortypes[num_combinations] = {\n  LCT_GREY, LCT_GREY, LCT_GREY, LCT_GREY, LCT_GREY, // 1, 2, 4, 8 or 16 bits\n  LCT_RGB, LCT_RGB, // 8 or 16 bits\n  LCT_PALETTE, LCT_PALETTE, LCT_PALETTE, LCT_PALETTE, // 1, 2, 4 or 8 bits\n  LCT_GREY_ALPHA, LCT_GREY_ALPHA, // 8 or 16 bits\n  LCT_RGBA, LCT_RGBA, // 8 or 16 bits\n};\n\nunsigned bitdepths[num_combinations] = {\n  1, 2, 4, 8, 16, // gray\n  8, 16, // rgb\n  1, 2, 4, 8, // palette\n  8, 16, // gray+alpha\n  8, 16, // rgb+alpha\n};\n\nunsigned testDecode(lodepng::State& state, const uint8_t* data, size_t size) {\n  unsigned w, h;\n  std::vector<unsigned char> image;\n  return lodepng::decode(image, w, h, state, (const unsigned char*)data, size);\n}\n} // end anonymous namespace\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n  if(size == 0) return 0;\n  \n  // Setting last byte of input as random_color_type\n  // Fuzzer will still be able to mutate the data accordingly as\n  // last byte of png file can be changed and file will still remain valid.\n  size_t random_color_type = data[size-1] % num_combinations;\n\n  lodepng::State state;\n\n  // Make the decoder ignore three types of checksums the PNG/zlib format have\n  // built-in, because they are less likely to be correct in the random input\n  // data, and if invalid make the decoder return an error before much gets ran.\n  state.decoder.zlibsettings.ignore_adler32 = 1;\n  state.decoder.zlibsettings.ignore_nlen = 1;\n  state.decoder.ignore_crc = 1;\n  // Also make decoder attempt to support partial files with missing ending to\n  // go further with parsing.\n  state.decoder.ignore_end = 1;\n\n  // First test without color conversion (keep color type of the PNG)\n  state.decoder.color_convert = 0;\n\n  unsigned error = testDecode(state, data, size);\n\n  // If valid PNG found, try decoding with color conversion to the most common\n  // default color type, and to the randomly chosen type.\n  if(error == 0) {\n    state.decoder.color_convert = 1;\n    testDecode(state, data, size);\n\n    state.info_raw.colortype = colortypes[random_color_type];\n    state.info_raw.bitdepth = bitdepths[random_color_type];\n    testDecode(state, data, size);\n  }\n\n  return 0;\n}\n"
        },
        {
          "name": "lodepng_unittest.cpp",
          "type": "blob",
          "size": 315.2861328125,
          "content": "/*\nLodePNG Unit Test\n\nCopyright (c) 2005-2024 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n//g++ lodepng.cpp lodepng_util.cpp lodepng_unittest.cpp -Wall -Wextra -Wsign-conversion -pedantic -ansi -O3\n\n/*\nTesting instructions:\n\n*) Ensure no tests commented out below or early return in doMain\n\n*) Compile with g++ with all warnings and run the unit test\ng++ lodepng.cpp lodepng_util.cpp lodepng_unittest.cpp -Werror -Wall -Wextra -Wsign-conversion -Wshadow -pedantic -ansi -O3 && ./a.out\n\n*) Compile with clang, which may sometimes give different warnings\nclang++ lodepng.cpp -c -Werror -Wall -Wextra -Wsign-conversion -Wshorten-64-to-32 -Wshadow -pedantic -ansi -O3\n\n*) Compile with pure ISO C90 and all warnings:\nmv lodepng.cpp lodepng.c ; gcc -I ./ lodepng.c examples/example_decode.c -ansi -pedantic -Werror -Wall -Wextra -O3 ; mv lodepng.c lodepng.cpp\n\nmv lodepng.cpp lodepng.c ; clang -I ./ lodepng.c examples/example_decode.c -ansi -pedantic -Werror -Wall -Wextra -O3 ; mv lodepng.c lodepng.cpp\n\n*) Compile with C with -pedantic but not -ansi flag so it warns about // style comments in C++-only ifdefs\nmv lodepng.cpp lodepng.c ; gcc -I ./ lodepng.c examples/example_decode.c -pedantic -Werror -Wall -Wextra -O3 ; mv lodepng.c lodepng.cpp\n\n*) test other compilers\n\n*) try lodepng_benchmark.cpp\ng++ lodepng.cpp lodepng_benchmark.cpp -Werror -Wall -Wextra -pedantic -ansi -lSDL2 -O3 && ./a.out testdata/corpus/''*\n\n*) try the fuzzer\nclang++ -fsanitize=fuzzer -DLODEPNG_MAX_ALLOC=100000000 lodepng.cpp lodepng_fuzzer.cpp -O3 -o fuzzer && ./fuzzer\n\nclang++ -fsanitize=fuzzer,address,undefined -DLODEPNG_MAX_ALLOC=100000000 lodepng.cpp lodepng_fuzzer.cpp -O3 -o fuzzer && ./fuzzer\n\n*) Check if all C++ examples compile without warnings:\ng++ -I ./ lodepng.cpp examples/''*.cpp -Werror -W -Wall -ansi -pedantic -O3 -c\n\n*) Check if all C examples compile without warnings:\nmv lodepng.cpp lodepng.c ; gcc -I ./ lodepng.c examples/''*.c -Werror -W -Wall -ansi -pedantic -O3 -c ; mv lodepng.c lodepng.cpp\n\n*) Check pngdetail.cpp:\ng++ lodepng.cpp lodepng_util.cpp pngdetail.cpp -Werror -W -Wall -ansi -pedantic -O3 -o pngdetail\n./pngdetail testdata/PngSuite/basi0g01.png\n\n*) Test compiling with some code sections with #defines disabled, for unused static function warnings etc...\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_CRC\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_ZLIB\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_PNG\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_DECODER\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_ENCODER\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_DISK\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_ANCILLARY_CHUNKS\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_ERROR_TEXT\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_CPP\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_ZLIB -DLODEPNG_NO_COMPILE_DECODER\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_ZLIB -DLODEPNG_NO_COMPILE_ENCODER\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_PNG -DLODEPNG_NO_COMPILE_DECODER\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_PNG -DLODEPNG_NO_COMPILE_ENCODER\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_DECODER -DLODEPNG_NO_COMPILE_ANCILLARY_CHUNKS -DLODEPNG_NO_COMPILE_ERROR_TEXT -DLODEPNG_NO_COMPILE_DISK\ng++ lodepng.cpp -W -Wall -ansi -pedantic -O3 -c -DLODEPNG_NO_COMPILE_ENCODER -DLODEPNG_NO_COMPILE_ANCILLARY_CHUNKS -DLODEPNG_NO_COMPILE_ERROR_TEXT -DLODEPNG_NO_COMPILE_DISK\nrm *.o\n\n*) analyze with clang:\nclang++ lodepng.cpp --analyze\n\nMore verbose:\nclang++ --analyze -Xanalyzer -analyzer-output=text lodepng.cpp\n\nOr html, look under lodepng.plist dir afterwards and find the numbered locations in the pages:\nclang++ --analyze -Xanalyzer -analyzer-output=html lodepng.cpp\n\n*) check for memory leaks and vulnerabilities with valgrind\n(DISABLE_SLOW disables a few tests that are very slow with valgrind)\ng++ -DDISABLE_SLOW lodepng.cpp lodepng_util.cpp lodepng_unittest.cpp -Wall -Wextra -pedantic -ansi -O3 -DLODEPNG_MAX_ALLOC=100000000 && valgrind --leak-check=full --track-origins=yes ./a.out\n\n*) Try with clang++ and address sanitizer (to get line numbers, make sure 'llvm' is also installed to get 'llvm-symbolizer'\nclang++ -O3 -fsanitize=address,undefined lodepng.cpp lodepng_util.cpp lodepng_unittest.cpp -Werror -Wall -Wextra -Wshadow -pedantic -ansi && ASAN_OPTIONS=allocator_may_return_null=1 ./a.out\n\nclang++ -g3 -fsanitize=address,undefined lodepng.cpp lodepng_util.cpp lodepng_unittest.cpp -Werror -Wall -Wextra -Wshadow -pedantic -ansi && ASAN_OPTIONS=allocator_may_return_null=1 ./a.out\n\n*) remove \"#include <iostream>\" from lodepng.cpp if it's still in there (some are legit)\ncat lodepng.cpp lodepng_util.cpp | grep iostream\ncat lodepng.cpp lodepng_util.cpp | grep stdio\ncat lodepng.cpp lodepng_util.cpp | grep \"#include\"\n\n*) try the Makefile\nmake clean && make -j\nrm *.o *.obj\n\n*) check that no plain free, malloc, realloc, strlen, memcpy, memset, ... used, but the lodepng_* versions instead\n\n*) check version dates in copyright message and LODEPNG_VERSION_STRING\n\n*) check year in copyright message at top of all files\n\n*) check examples/sdl.cpp with the png test suite images (the \"x\" ones are expected to show error)\ng++ -I ./ lodepng.cpp examples/example_sdl.cpp -Werror -Wall -Wextra -pedantic -ansi -O3 -lSDL2 -o showpng && ./showpng testdata/PngSuite/''*.png\n\n*) strip trailing spaces and ensure consistent newlines\n\n*) test warnings in other compilers\n\n*) check diff of lodepng.cpp and lodepng.h before submitting\ngit difftool -y\n\n*/\n\n#include \"lodepng.h\"\n#include \"lodepng_util.h\"\n\n#include <cmath>\n#include <map>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#include <stdio.h>\n#include <stdlib.h>\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid fail() {\n  throw 1; //that's how to let a unittest fail\n}\n\n//Utility for debug messages\ntemplate<typename T>\nstd::string valtostr(const T& val) {\n  std::ostringstream sstream;\n  sstream << val;\n  return sstream.str();\n}\n\n//Print char as a numeric value rather than a character\ntemplate<>\nstd::string valtostr(const unsigned char& val) {\n  std::ostringstream sstream;\n  sstream << (int)val;\n  return sstream.str();\n}\n\n//Print char pointer as pointer, not as string\ntemplate<typename T>\nstd::string valtostr(const T* val) {\n  std::ostringstream sstream;\n  sstream << (const void*)val;\n  return sstream.str();\n}\n\ntemplate<typename T>\nstd::string valtostr(const std::vector<T>& val) {\n  std::ostringstream sstream;\n  sstream << \"[vector with size \" << val.size() << \"]\";\n  return sstream.str();\n}\n\n// TODO: remove, use only ASSERT_EQUALS (it prints line number). Requires adding extra message ability to ASSERT_EQUALS\ntemplate<typename T, typename U>\nvoid assertEquals(const T& expected, const U& actual, const std::string& message = \"\") {\n  if(expected != (T)actual) {\n    std::cout << \"Error: Not equal! Expected \" << valtostr(expected)\n              << \" got \" << valtostr((T)actual) << \". \"\n              << \"Message: \" << message << std::endl;\n    fail();\n  }\n}\n\n// TODO: remove, use only ASSERT_TRUE (it prints line number). Requires adding extra message ability to ASSERT_TRUE\nvoid assertTrue(bool value, const std::string& message = \"\") {\n  if(!value) {\n    std::cout << \"Error: expected true. \" << \"Message: \" << message << std::endl;\n    fail();\n  }\n}\n\n//assert that no error\nvoid assertNoPNGError(unsigned error, const std::string& message = \"\") {\n  if(error) {\n    std::string msg = (message == \"\") ? lodepng_error_text(error)\n                                      : message + std::string(\": \") + lodepng_error_text(error);\n    assertEquals(0, error, msg);\n  }\n}\n\nvoid assertNoError(unsigned error) {\n  if(error) {\n    assertEquals(0, error, \"Expected no error\");\n  }\n}\n\n#define STR_EXPAND(s) #s\n#define STR(s) STR_EXPAND(s)\n#define ASSERT_TRUE(v) {\\\n  if(!(v)) {\\\n    std::cout << std::string(\"line \") + STR(__LINE__) + \": \" + STR(v) + \" ASSERT_TRUE failed: \";\\\n    std::cout << \"Expected true but got \" << valtostr(v) << \". \" << std::endl;\\\n    fail();\\\n  }\\\n}\n#define ASSERT_EQUALS(e, v) {\\\n  if((e) != (v)) {\\\n    std::cout << std::string(\"line \") + STR(__LINE__) + \": \" + STR(v) + \" ASSERT_EQUALS failed: \";\\\n    std::cout << \"Expected \" << valtostr(e) << \" but got \" << valtostr(v) << \". \" << std::endl;\\\n    fail();\\\n  }\\\n}\n#define ASSERT_NOT_EQUALS(e, v) {\\\n  if((e) == (v)) {\\\n    std::cout << std::string(\"line \") + STR(__LINE__) + \": \" + STR(v) + \" ASSERT_NOT_EQUALS failed: \";\\\n    std::cout << \"Expected not \" << valtostr(e) << \" but got \" << valtostr(v) << \". \" << std::endl;\\\n    fail();\\\n  }\\\n}\n\ntemplate<typename T, typename U, typename V>\nbool isNear(T e, U v, V maxdist) {\n  T dist = e > (T)v ? e - (T)v : (T)v - e;\n  return dist <= (T)maxdist;\n}\n\ntemplate<typename T, typename U>\nT diff(T e, U v) {\n  return v > e ? v - e : e - v;\n}\n\n#define ASSERT_NEAR(e, v, maxdist) {\\\n  if(!isNear(e, v, maxdist)) {\\\n    std::cout << std::string(\"line \") + STR(__LINE__) + \": \" + STR(v) + \" ASSERT_NEAR failed: \";\\\n    std::cout << \"dist too great! Expected near \" << valtostr(e) << \" but got \" << valtostr(v) << \", with max dist \" << valtostr(maxdist)\\\n              << \" but got dist \" << valtostr(diff(e, v)) << \". \" << std::endl;\\\n    fail();\\\n  }\\\n}\n\n#define ASSERT_STRING_EQUALS(e, v) ASSERT_EQUALS(std::string(e), std::string(v))\n#define ASSERT_NO_PNG_ERROR_MSG(error, message) assertNoPNGError(error, std::string(\"line \") + STR(__LINE__) + (std::string(message).empty() ? std::string(\"\") : (\": \" + std::string(message))))\n#define ASSERT_NO_PNG_ERROR(error) ASSERT_NO_PNG_ERROR_MSG(error, std::string(\"\"))\n\nstatic const std::string BASE64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n\n\n//T and U can be std::string or std::vector<unsigned char>\ntemplate<typename T, typename U>\nvoid toBase64(T& out, const U& in) {\n  for(size_t i = 0; i < in.size(); i += 3) {\n    int v = 65536 * in[i];\n    if(i + 1 < in.size()) v += 256 * in[i + 1];\n    if(i + 2 < in.size()) v += in[i + 2];\n    out.push_back(BASE64[(v >> 18) & 0x3f]);\n    out.push_back(BASE64[(v >> 12) & 0x3f]);\n    if(i + 1 < in.size()) out.push_back(BASE64[(v >> 6) & 0x3f]);\n    else out.push_back('=');\n    if(i + 2 < in.size()) out.push_back(BASE64[(v >> 0) & 0x3f]);\n    else out.push_back('=');\n  }\n}\n\nint fromBase64(int v) {\n  if(v >= 'A' && v <= 'Z') return (v - 'A');\n  if(v >= 'a' && v <= 'z') return (v - 'a' + 26);\n  if(v >= '0' && v <= '9') return (v - '0' + 52);\n  if(v == '+') return 62;\n  if(v == '/') return 63;\n  return 0; //v == '='\n}\n\n//T and U can be std::string or std::vector<unsigned char>\ntemplate<typename T, typename U>\nvoid fromBase64(T& out, const U& in) {\n  for(size_t i = 0; i + 3 < in.size(); i += 4) {\n    int v = 262144 * fromBase64(in[i]) + 4096 * fromBase64(in[i + 1]) + 64 * fromBase64(in[i + 2]) + fromBase64(in[i + 3]);\n    out.push_back((v >> 16) & 0xff);\n    if(in[i + 2] != '=') out.push_back((v >> 8) & 0xff);\n    if(in[i + 3] != '=') out.push_back((v >> 0) & 0xff);\n  }\n}\n\nunsigned getRandom() {\n  static unsigned s = 1000000000;\n  // xorshift32, good enough for testing\n  s ^= (s << 13);\n  s ^= (s >> 17);\n  s ^= (s << 5);\n  return s;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nunsigned leftrotate(unsigned x, unsigned c) {\n  return (x << c) | (x >> (32u - c));\n}\n\n// the 128-bit result is output in 4 32-bit integers a0..d0 (to make 16-byte digest: append a0|b0|c0|d0 in little endian)\nvoid md5sum(const unsigned char* in, size_t size, unsigned* a0, unsigned* b0, unsigned* c0, unsigned* d0) {\n  ASSERT_EQUALS(4, sizeof(unsigned));\n  // per-round shift amounts\n  static const unsigned s[64] = {\n    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,\n    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,\n  };\n  // precomputed table from sines\n  static const unsigned k[64] = {\n    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,\n    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,\n    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,\n    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,\n  };\n\n  *a0 = 0x67452301;\n  *b0 = 0xefcdab89;\n  *c0 = 0x98badcfe;\n  *d0 = 0x10325476;\n\n  // append bit, padding and size to input\n  std::vector<unsigned char> data(in, in + size);\n  data.resize(((size + 1 + 8 + 63) / 64) * 64, 0);\n  data[size] = 128; // append 1 bit (msb)\n  size_t bitsize = size * 8; // append the size (shifts > 31 are avoided)\n  data[data.size() - 1] = ((bitsize >> 28u) >> 28u) & 255u;\n  data[data.size() - 2] = ((bitsize >> 24u) >> 24u) & 255u;\n  data[data.size() - 3] = ((bitsize >> 20u) >> 20u) & 255u;\n  data[data.size() - 4] = ((bitsize >> 16u) >> 16u) & 255u;\n  data[data.size() - 5] = (bitsize >> 24u) & 255u;\n  data[data.size() - 6] = (bitsize >> 16u) & 255u;\n  data[data.size() - 7] = (bitsize >> 8u) & 255u;\n  data[data.size() - 8] = bitsize & 255u;\n\n  // per chunk\n  for(size_t i = 0; i < data.size(); i += 64) {\n    unsigned a = *a0;\n    unsigned b = *b0;\n    unsigned c = *c0;\n    unsigned d = *d0;\n\n    for(size_t j = 0; j < 64; j++) {\n      unsigned f, g;\n      if(j <= 15u) {\n        f = (b & c) | (~b & d);\n        g = j;\n      } else if(j <= 31u) {\n        f = (d & b) | (~d & c);\n        g = (5u * j + 1u) & 15u;\n      } else if(j <= 47u) {\n        f = b ^ c ^ d;\n        g = (3u * j + 5u) & 15u;\n      } else {\n        f = c ^ (b | ~d);\n        g = (7u * j) & 15u;\n      }\n      unsigned m = (unsigned)(data[i + g * 4 + 3] << 24u) | (unsigned)(data[i + g * 4 + 2] << 16u)\n                 | (unsigned)(data[i + g * 4 + 1] << 8u) | (unsigned)data[i + g * 4];\n      f += a + k[j] + m;\n      a = d;\n      d = c;\n      c = b;\n      b += leftrotate(f, s[j]);\n    }\n    *a0 += a;\n    *b0 += b;\n    *c0 += c;\n    *d0 += d;\n  }\n}\n\nstd::string md5sum(const unsigned char* data, size_t size) {\n  unsigned a0, b0, c0, d0;\n  md5sum(data, size, &a0, &b0, &c0, &d0);\n  char result[33];\n  //sprintf(result, \"%8.8x%8.8x%8.8x%8.8x\", a0, b0, c0, d0);\n  sprintf(result, \"%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\",\n          a0 & 255, (a0 >> 8) & 255, (a0 >> 16) & 255, (a0 >> 24) & 255,\n          b0 & 255, (b0 >> 8) & 255, (b0 >> 16) & 255, (b0 >> 24) & 255,\n          c0 & 255, (c0 >> 8) & 255, (c0 >> 16) & 255, (c0 >> 24) & 255,\n          d0 & 255, (d0 >> 8) & 255, (d0 >> 16) & 255, (d0 >> 24) & 255);\n  return std::string(result);\n}\n\nstd::string md5sum(const std::vector<unsigned char>& in) {\n  return md5sum(in.data(), in.size());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n//Test image data\nstruct Image {\n  std::vector<unsigned char> data;\n  unsigned width;\n  unsigned height;\n  LodePNGColorType colorType;\n  unsigned bitDepth;\n};\n\n//Get number of color channels for a given PNG color type\nunsigned getNumColorChannels(unsigned colorType) {\n  switch(colorType) {\n    case 0: return 1; /*gray*/\n    case 2: return 3; /*RGB*/\n    case 3: return 1; /*palette*/\n    case 4: return 2; /*gray + alpha*/\n    case 6: return 4; /*RGBA*/\n  }\n  return 0; /*unexisting color type*/\n}\n\n//Generate a test image with some data in it, the contents of the data is unspecified,\n//except the content is not just one plain color, and not true random either to be compressible.\nvoid generateTestImage(Image& image, unsigned width, unsigned height, LodePNGColorType colorType = LCT_RGBA, unsigned bitDepth = 8) {\n  image.width = width;\n  image.height = height;\n  image.colorType = colorType;\n  image.bitDepth = bitDepth;\n\n  size_t bits = bitDepth * getNumColorChannels(colorType); //bits per pixel\n  size_t size = (width * height * bits + 7) / 8; //total image size in bytes\n  image.data.resize(size);\n  unsigned char value = 128;\n  for(size_t i = 0; i < size; i++) {\n    image.data[i] = value++;\n  }\n}\n\n//Generate a 16-bit test image with minimal size that requires at minimum the given color type (bit depth, grayscaleness, ...)\n//If key is true, makes it such that exactly one color is transparent, so it can use a key. If false, adds a translucent color depending on\n//whether it's an alpha color type or not.\nvoid generateTestImageRequiringColorType16(Image& image, LodePNGColorType colorType, unsigned bitDepth, bool key) {\n  image.colorType = colorType;\n  image.bitDepth = bitDepth;\n  unsigned w = 1;\n  unsigned h = 1;\n\n  bool gray = colorType == LCT_GREY || colorType == LCT_GREY_ALPHA;\n  bool alpha = colorType == LCT_RGBA || colorType == LCT_GREY_ALPHA;\n\n  if(colorType == LCT_PALETTE) {\n    w = 1u << bitDepth;\n    h = 256; // ensure it'll really choose palette, not omit it due to small image size\n    image.data.resize(w * h * 8);\n    for(size_t y = 0; y < h; y++) {\n      for(size_t x = 0; x < w; x++) {\n        size_t i = y * w * 8 + x * 8;\n        image.data[i + 0] = image.data[i + 1] = y;\n        image.data[i + 2] = image.data[i + 3] = 255;\n        image.data[i + 4] = image.data[i + 5] = 0;\n        image.data[i + 6] = image.data[i + 7] = (key && y == 0) ? 0 : 255;\n      }\n    }\n  } else if(bitDepth == 16) {\n    // one color suffices for this model. But add one more to support key.\n    w = 2;\n    image.data.resize(w * h * 8);\n    image.data[0] = 10; image.data[1] = 20;\n    image.data[2] = 10; image.data[3] = 20;\n    image.data[4] = gray ? 10 : 110; image.data[5] = gray ? 20 : 120;\n    image.data[6] = alpha ? 128 : 255; image.data[7] = alpha ? 20 : 255;\n\n    image.data[8] = 40; image.data[9] = 50;\n    image.data[10] = 40; image.data[11] = 50;\n    image.data[12] = gray ? 40 : 140; image.data[13] = gray ? 50 : 150;\n    image.data[14] = key ? 0 : 255; image.data[15] = key ? 0 : 255;\n  } else if(gray) {\n    w = 2;\n    unsigned v = 255u / ((1u << bitDepth) - 1u); // value that forces at least this bitdepth\n    image.data.resize(w * h * 8);\n    image.data[0] = v; image.data[1] = v;\n    image.data[2] = v; image.data[3] = v;\n    image.data[4] = v; image.data[5] = v;\n    image.data[6] = alpha ? v : 255; image.data[7] = alpha ? v : 255;\n\n    image.data[8] = image.data[9] = 0;\n    image.data[10] = image.data[11] = 0;\n    image.data[12] = image.data[13] = 0;\n    image.data[14] = image.data[15] = key ? 0 : 255;\n  } else {\n    // now it's RGB or RGBA with bitdepth 8\n    w = 257; // must have at least more than 256 colors so it won't use palette\n    image.data.resize(w * h * 8);\n    for(size_t y = 0; y < h; y++) {\n      for(size_t x = 0; x < w; x++) {\n        size_t i = y * w * 8 + x * 8;\n        image.data[i + 0] = image.data[i + 1] = i / 2;\n        image.data[i + 2] = image.data[i + 3] = i / 3;\n        image.data[i + 4] = image.data[i + 5] = i / 5;\n        image.data[i + 6] = image.data[i + 7] = (key && y == 0) ? 0 : (alpha ? i : 255);\n      }\n    }\n  }\n\n  image.width = w;\n  image.height = h;\n}\n\n//Generate a 8-bit test image with minimal size that requires at minimum the given color type (bit depth, grayscaleness, ...). bitDepth max 8 here.\n//If key is true, makes it such that exactly one color is transparent, so it can use a key. If false, adds a translucent color depending on\n//whether it's an alpha color type or not.\nvoid generateTestImageRequiringColorType8(Image& image, LodePNGColorType colorType, unsigned bitDepth, bool key) {\n  image.colorType = colorType;\n  image.bitDepth = bitDepth;\n  unsigned w = 1;\n  unsigned h = 1;\n\n  bool gray = colorType == LCT_GREY || colorType == LCT_GREY_ALPHA;\n  bool alpha = colorType == LCT_RGBA || colorType == LCT_GREY_ALPHA;\n\n  if(colorType == LCT_PALETTE) {\n    w = 1u << bitDepth;\n    h = 256; // ensure it'll really choose palette, not omit it due to small image size\n    image.data.resize(w * h * 4);\n    for(size_t y = 0; y < h; y++) {\n      for(size_t x = 0; x < w; x++) {\n        size_t i = y * w * 4 + x * 4;\n        image.data[i + 0] = x;\n        image.data[i + 1] = 255;\n        image.data[i + 2] = 0;\n        image.data[i + 3] = (key && x == 0) ? 0 : 255;\n      }\n    }\n  } else if(gray) {\n    w = 2;\n    unsigned v = 255u / ((1u << bitDepth) - 1u); // value that forces at least this bitdepth\n    image.data.resize(w * h * 4);\n    image.data[0] = v;\n    image.data[1] = v;\n    image.data[2] = v;\n    image.data[3] = alpha ? v : 255;\n\n    image.data[4] = 0;\n    image.data[5] = 0;\n    image.data[6] = 0;\n    image.data[7] = key ? 0 : 255;\n  } else {\n    // now it's RGB or RGBA with bitdepth 8\n    w = 257; // must have at least more than 256 colors so it won't use palette\n    image.data.resize(w * h * 4);\n    for(size_t y = 0; y < h; y++) {\n      for(size_t x = 0; x < w; x++) {\n        size_t i = y * w * 4 + x * 4;\n        image.data[i + 0] = i / 2;\n        image.data[i + 1] = i / 3;\n        image.data[i + 2] = i / 5;\n        image.data[i + 3] = (key && x == 0) ? 0 : (alpha ? i : 255);\n      }\n    }\n  }\n\n  image.width = w;\n  image.height = h;\n}\n\n//Check that the decoded PNG pixels are the same as the pixels in the image\nvoid assertPixels(Image& image, const unsigned char* decoded, const std::string& message) {\n  for(size_t i = 0; i < image.data.size(); i++) {\n    int byte_expected = image.data[i];\n    int byte_actual = decoded[i];\n\n    //last byte is special due to possible random padding bits which need not to be equal\n    if(i == image.data.size() - 1) {\n      size_t numbits = getNumColorChannels(image.colorType) * image.bitDepth * image.width * image.height;\n      size_t padding = 8u - (numbits - 8u * (numbits / 8u));\n      if(padding != 8u) {\n        //set all padding bits of both to 0\n        for(size_t j = 0; j < padding; j++) {\n          byte_expected = (byte_expected & (~(1 << j))) % 256;\n          byte_actual = (byte_actual & (~(1 << j))) % 256;\n        }\n      }\n    }\n\n    assertEquals(byte_expected, byte_actual, message + \" \" + valtostr(i));\n  }\n}\n\n//Test LodePNG encoding and decoding the encoded result, using the C interface\nvoid doCodecTestC(Image& image) {\n  unsigned char* encoded = 0;\n  size_t encoded_size = 0;\n  unsigned char* decoded = 0;\n  unsigned decoded_w;\n  unsigned decoded_h;\n\n  struct OnExitScope {\n    unsigned char** a;\n    unsigned char** b;\n    OnExitScope(unsigned char** ca, unsigned char** cb) : a(ca), b(cb) {}\n    ~OnExitScope() { free(*a); free(*b); }\n  } onExitScope(&encoded, &decoded);\n\n  unsigned error_enc = lodepng_encode_memory(&encoded, &encoded_size, &image.data[0],\n                                             image.width, image.height, image.colorType, image.bitDepth);\n\n  if(error_enc != 0) std::cout << \"Error: \" << lodepng_error_text(error_enc) << std::endl;\n  ASSERT_NO_PNG_ERROR_MSG(error_enc, \"encoder error C\");\n\n  //if the image is large enough, compressing it should result in smaller size\n  if(image.data.size() > 512) assertTrue(encoded_size < image.data.size(), \"compressed size\");\n\n  unsigned error_dec = lodepng_decode_memory(&decoded, &decoded_w, &decoded_h,\n                                             encoded, encoded_size, image.colorType, image.bitDepth);\n\n  if(error_dec != 0) std::cout << \"Error: \" << lodepng_error_text(error_dec) << std::endl;\n  ASSERT_NO_PNG_ERROR_MSG(error_dec, \"decoder error C\");\n\n  ASSERT_EQUALS(image.width, decoded_w);\n  ASSERT_EQUALS(image.height, decoded_h);\n  assertPixels(image, decoded, \"Pixels C\");\n}\n\n//Test LodePNG encoding and decoding the encoded result, using the C++ interface\nvoid doCodecTestCPP(Image& image) {\n  std::vector<unsigned char> encoded;\n  std::vector<unsigned char> decoded;\n  unsigned decoded_w;\n  unsigned decoded_h;\n\n  unsigned error_enc = lodepng::encode(encoded, image.data, image.width, image.height,\n                                       image.colorType, image.bitDepth);\n\n  ASSERT_NO_PNG_ERROR_MSG(error_enc, \"encoder error C++\");\n\n  //if the image is large enough, compressing it should result in smaller size\n  if(image.data.size() > 512) assertTrue(encoded.size() < image.data.size(), \"compressed size\");\n\n  unsigned error_dec = lodepng::decode(decoded, decoded_w, decoded_h, encoded, image.colorType, image.bitDepth);\n\n  ASSERT_NO_PNG_ERROR_MSG(error_dec, \"decoder error C++\");\n\n  ASSERT_EQUALS(image.width, decoded_w);\n  ASSERT_EQUALS(image.height, decoded_h);\n  ASSERT_EQUALS(image.data.size(), decoded.size());\n  assertPixels(image, &decoded[0], \"Pixels C++\");\n}\n\n\nvoid doCodecTestWithEncState(Image& image, lodepng::State& state) {\n  std::vector<unsigned char> encoded;\n  std::vector<unsigned char> decoded;\n  unsigned decoded_w;\n  unsigned decoded_h;\n  state.info_raw.colortype = image.colorType;\n  state.info_raw.bitdepth = image.bitDepth;\n\n\n  unsigned error_enc = lodepng::encode(encoded, image.data, image.width, image.height, state);\n  ASSERT_NO_PNG_ERROR_MSG(error_enc, \"encoder error uncompressed\");\n\n  unsigned error_dec = lodepng::decode(decoded, decoded_w, decoded_h, encoded, image.colorType, image.bitDepth);\n\n  ASSERT_NO_PNG_ERROR_MSG(error_dec, \"decoder error uncompressed\");\n\n  ASSERT_EQUALS(image.width, decoded_w);\n  ASSERT_EQUALS(image.height, decoded_h);\n  ASSERT_EQUALS(image.data.size(), decoded.size());\n  assertPixels(image, &decoded[0], \"Pixels uncompressed\");\n}\n\n\n//Test LodePNG encoding and decoding the encoded result, using the C++ interface\nvoid doCodecTestUncompressed(Image& image) {\n  lodepng::State state;\n  state.encoder.zlibsettings.btype = 0;\n  doCodecTestWithEncState(image, state);\n}\n\nvoid doCodecTestNoLZ77(Image& image) {\n  lodepng::State state;\n  state.encoder.zlibsettings.use_lz77 = 0;\n  doCodecTestWithEncState(image, state);\n}\n\nvoid testGetFilterTypes() {\n  std::cout << \"testGetFilterTypes\" << std::endl;\n  // Test that getFilterTypes works on the special case of 1-pixel wide interlaced image\n  std::string png64 = \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAAHCAIAAAExKYBVAAAAHUlEQVR4ASXHAQoAAAjCwPX/R9tK4ZBN4EHKcPcLXCgGAQa0TV8AAAAASUVORK5CYII=\";\n  std::vector<unsigned char> png;\n  fromBase64(png, png64);\n  std::vector<unsigned char> types;\n  lodepng::getFilterTypes(types, png);\n  ASSERT_EQUALS(7, types.size());\n  ASSERT_EQUALS(1, types[0]);\n  ASSERT_EQUALS(1, types[1]);\n  ASSERT_EQUALS(1, types[2]);\n  ASSERT_EQUALS(0, types[3]);\n  ASSERT_EQUALS(1, types[4]);\n  ASSERT_EQUALS(1, types[5]);\n  ASSERT_EQUALS(1, types[6]);\n}\n\n//Test LodePNG encoding and decoding the encoded result, using the C++ interface, with interlace\nvoid doCodecTestInterlaced(Image& image) {\n  std::vector<unsigned char> encoded;\n  std::vector<unsigned char> decoded;\n  unsigned decoded_w;\n  unsigned decoded_h;\n\n  lodepng::State state;\n  state.info_png.interlace_method = 1;\n  state.info_raw.colortype = image.colorType;\n  state.info_raw.bitdepth = image.bitDepth;\n\n  unsigned error_enc = lodepng::encode(encoded, image.data, image.width, image.height, state);\n\n  ASSERT_NO_PNG_ERROR_MSG(error_enc, \"encoder error interlaced\");\n\n  //if the image is large enough, compressing it should result in smaller size\n  if(image.data.size() > 512) assertTrue(encoded.size() < image.data.size(), \"compressed size\");\n\n  state.info_raw.colortype = image.colorType;\n  state.info_raw.bitdepth = image.bitDepth;\n  unsigned error_dec = lodepng::decode(decoded, decoded_w, decoded_h, state, encoded);\n\n  ASSERT_NO_PNG_ERROR_MSG(error_dec, \"decoder error interlaced\");\n\n  ASSERT_EQUALS(image.width, decoded_w);\n  ASSERT_EQUALS(image.height, decoded_h);\n  ASSERT_EQUALS(image.data.size(), decoded.size());\n  assertPixels(image, &decoded[0], \"Pixels interlaced\");\n}\n\n//Test LodePNG encoding and decoding the encoded result\nvoid doCodecTest(Image& image) {\n  doCodecTestC(image);\n  doCodecTestCPP(image);\n  doCodecTestInterlaced(image);\n  doCodecTestUncompressed(image);\n  doCodecTestNoLZ77(image);\n}\n\n\n//Test LodePNG encoding and decoding using some image generated with the given parameters\nvoid codecTest(unsigned width, unsigned height, LodePNGColorType colorType = LCT_RGBA, unsigned bitDepth = 8) {\n  std::cout << \"codec test \" << width << \" \" << height << std::endl;\n  Image image;\n  generateTestImage(image, width, height, colorType, bitDepth);\n  doCodecTest(image);\n}\n\nstd::string removeSpaces(const std::string& s) {\n  std::string result;\n  for(size_t i = 0; i < s.size(); i++) if(s[i] != ' ') result += s[i];\n  return result;\n}\n\nvoid bitStringToBytes(std::vector<unsigned char>& bytes, const std::string& bits_) {\n  std::string bits = removeSpaces(bits_);\n  bytes.resize((bits.size()) + 7 / 8);\n  for(size_t i = 0; i < bits.size(); i++) {\n    size_t j = i / 8;\n    size_t k = i % 8;\n    char c = bits[i];\n    if(k == 0) bytes[j] = 0;\n    if(c == '1') bytes[j] |= (1 << (7 - k));\n  }\n}\n\n/*\ntest color convert on a single pixel. Testing palette and testing color keys is\nnot supported by this function. Pixel values given using bits in an std::string\nof 0's and 1's.\n*/\nvoid colorConvertTest(const std::string& bits_in, LodePNGColorType colorType_in, unsigned bitDepth_in,\n                      const std::string& bits_out, LodePNGColorType colorType_out, unsigned bitDepth_out) {\n  std::cout << \"color convert test \" << bits_in << \" - \" << bits_out << std::endl;\n\n  std::vector<unsigned char> expected, actual, image;\n  bitStringToBytes(expected, bits_out);\n  actual.resize(expected.size());\n  bitStringToBytes(image, bits_in);\n  LodePNGColorMode mode_in, mode_out;\n  lodepng_color_mode_init(&mode_in);\n  lodepng_color_mode_init(&mode_out);\n  mode_in.colortype = colorType_in;\n  mode_in.bitdepth = bitDepth_in;\n  mode_out.colortype = colorType_out;\n  mode_out.bitdepth = bitDepth_out;\n  unsigned error = lodepng_convert(&actual[0], &image[0], &mode_out, &mode_in, 1, 1);\n\n  ASSERT_NO_PNG_ERROR_MSG(error, \"convert error\");\n\n  for(size_t i = 0; i < expected.size(); i++) {\n    assertEquals((int)expected[i], (int)actual[i], \"byte \" + valtostr(i));\n  }\n\n  lodepng_color_mode_cleanup(&mode_in);\n  lodepng_color_mode_cleanup(&mode_out);\n}\n\nvoid testOtherPattern1() {\n  std::cout << \"codec other pattern 1\" << std::endl;\n\n  Image image1;\n  size_t w = 192;\n  size_t h = 192;\n  image1.width = w;\n  image1.height = h;\n  image1.colorType = LCT_RGBA;\n  image1.bitDepth = 8;\n  image1.data.resize(w * h * 4u);\n  for(size_t y = 0; y < h; y++)\n  for(size_t x = 0; x < w; x++) {\n    //pattern 1\n    image1.data[4u * w * y + 4u * x + 0u] = (unsigned char)(127 * (1 + std::sin((                    x * x +                     y * y) / (w * h / 8.0))));\n    image1.data[4u * w * y + 4u * x + 1u] = (unsigned char)(127 * (1 + std::sin(((w - x - 1) * (w - x - 1) +                     y * y) / (w * h / 8.0))));\n    image1.data[4u * w * y + 4u * x + 2u] = (unsigned char)(127 * (1 + std::sin((                    x * x + (h - y - 1) * (h - y - 1)) / (w * h / 8.0))));\n    image1.data[4u * w * y + 4u * x + 3u] = (unsigned char)(127 * (1 + std::sin(((w - x - 1) * (w - x - 1) + (h - y - 1) * (h - y - 1)) / (w * h / 8.0))));\n  }\n\n  doCodecTest(image1);\n}\n\nvoid testOtherPattern2() {\n  std::cout << \"codec other pattern 2\" << std::endl;\n\n  Image image1;\n  size_t w = 192;\n  size_t h = 192;\n  image1.width = w;\n  image1.height = h;\n  image1.colorType = LCT_RGBA;\n  image1.bitDepth = 8;\n  image1.data.resize(w * h * 4u);\n  for(size_t y = 0; y < h; y++)\n  for(size_t x = 0; x < w; x++) {\n    image1.data[4u * w * y + 4u * x + 0u] = 255 * !(x & y);\n    image1.data[4u * w * y + 4u * x + 1u] = x ^ y;\n    image1.data[4u * w * y + 4u * x + 2u] = x | y;\n    image1.data[4u * w * y + 4u * x + 3u] = 255;\n  }\n\n  doCodecTest(image1);\n}\n\nvoid testSinglePixel(int r, int g, int b, int a) {\n  std::cout << \"codec single pixel \" << r << \" \" << g << \" \" << b << \" \" << a << std::endl;\n  Image pixel;\n  pixel.width = 1;\n  pixel.height = 1;\n  pixel.colorType = LCT_RGBA;\n  pixel.bitDepth = 8;\n  pixel.data.resize(4);\n  pixel.data[0] = r;\n  pixel.data[1] = g;\n  pixel.data[2] = b;\n  pixel.data[3] = a;\n\n  doCodecTest(pixel);\n}\n\nvoid testColor(int r, int g, int b, int a) {\n  std::cout << \"codec test color \" << r << \" \" << g << \" \" << b << \" \" << a << std::endl;\n  Image image;\n  image.width = 20;\n  image.height = 20;\n  image.colorType = LCT_RGBA;\n  image.bitDepth = 8;\n  image.data.resize(20 * 20 * 4);\n  for(size_t y = 0; y < 20; y++)\n  for(size_t x = 0; x < 20; x++) {\n    image.data[20 * 4 * y + 4 * x + 0] = r;\n    image.data[20 * 4 * y + 4 * x + 0] = g;\n    image.data[20 * 4 * y + 4 * x + 0] = b;\n    image.data[20 * 4 * y + 4 * x + 0] = a;\n  }\n\n  doCodecTest(image);\n\n  Image image2 = image;\n  image2.data[3] = 0; //one fully transparent pixel\n  doCodecTest(image2);\n  image2.data[3] = 128; //one semi transparent pixel\n  doCodecTest(image2);\n\n  Image image3 = image;\n  // add 255 different colors\n  for(size_t i = 0; i < 255; i++) {\n    image.data[i * 4 + 0] = i;\n    image.data[i * 4 + 1] = i;\n    image.data[i * 4 + 2] = i;\n    image.data[i * 4 + 3] = 255;\n  }\n  doCodecTest(image3);\n  // a 256th color\n  image.data[255 * 4 + 0] = 255;\n  image.data[255 * 4 + 1] = 255;\n  image.data[255 * 4 + 2] = 255;\n  image.data[255 * 4 + 3] = 255;\n  doCodecTest(image3);\n\n  testSinglePixel(r, g, b, a);\n}\n\n// Tests combinations of various colors in different orders\nvoid testFewColors() {\n  std::cout << \"codec test few colors \" << std::endl;\n  Image image;\n  image.width = 4;\n  image.height = 4;\n  image.colorType = LCT_RGBA;\n  image.bitDepth = 8;\n  image.data.resize(image.width * image.height * 4);\n  std::vector<unsigned char> colors;\n  colors.push_back(0); colors.push_back(0); colors.push_back(0); colors.push_back(255); // black\n  colors.push_back(255); colors.push_back(255); colors.push_back(255); colors.push_back(255); // white\n  colors.push_back(128); colors.push_back(128); colors.push_back(128); colors.push_back(255); // gray\n  colors.push_back(0); colors.push_back(0); colors.push_back(255); colors.push_back(255); // blue\n  colors.push_back(255); colors.push_back(255); colors.push_back(255); colors.push_back(0); // transparent white\n  colors.push_back(255); colors.push_back(255); colors.push_back(255); colors.push_back(1); // translucent white\n  for(size_t i = 0; i < colors.size(); i += 4)\n  for(size_t j = 0; j < colors.size(); j += 4)\n  for(size_t k = 0; k < colors.size(); k += 4)\n  for(size_t l = 0; l < colors.size(); l += 4) {\n    for(unsigned y = 0; y < image.height; y++)\n    for(unsigned x = 0; x < image.width; x++) {\n      size_t a = (y * image.width + x) & 3;\n      size_t b = (a == 0) ? i : ((a == 1) ? j : ((a == 2) ? k : l));\n      for(size_t c = 0; c < 4; c++) {\n        image.data[y * image.width * 4 + x * 4 + c] = colors[b + c];\n      }\n    }\n    doCodecTest(image);\n  }\n  image.width = 20;\n  image.height = 20;\n  image.data.resize(image.width * image.height * 4);\n  for(size_t i = 0; i < colors.size(); i += 4)\n  for(size_t j = 0; j < colors.size(); j += 4)\n  for(size_t k = 0; k < colors.size(); k += 4) {\n    for(unsigned y = 0; y < image.height; y++)\n    for(unsigned x = 0; x < image.width; x++) {\n      size_t a = (y * image.width + x) % 3;\n      size_t b = (a == 0) ? i : ((a == 1) ? j : k);\n      for(size_t c = 0; c < 4; c++) {\n        image.data[y * image.width * 4 + x * 4 + c] = colors[b + c];\n      }\n    }\n    doCodecTest(image);\n  }\n}\n\nvoid testSize(unsigned w, unsigned h) {\n  std::cout << \"codec test size \" << w << \" \" << h << std::endl;\n  Image image;\n  image.width = w;\n  image.height = h;\n  image.colorType = LCT_RGBA;\n  image.bitDepth = 8;\n  image.data.resize(w * h * 4);\n  for(size_t y = 0; y < h; y++)\n  for(size_t x = 0; x < w; x++) {\n    image.data[w * 4 * y + 4 * x + 0] = x % 256;\n    image.data[w * 4 * y + 4 * x + 0] = y % 256;\n    image.data[w * 4 * y + 4 * x + 0] = 255;\n    image.data[w * 4 * y + 4 * x + 0] = 255;\n  }\n\n  doCodecTest(image);\n}\n\nvoid testPNGCodec() {\n  codecTest(1, 1);\n  codecTest(2, 2);\n  codecTest(1, 1, LCT_GREY, 1);\n  codecTest(7, 7, LCT_GREY, 1);\n#ifndef DISABLE_SLOW\n  codecTest(127, 127);\n  codecTest(127, 127, LCT_GREY, 1);\n  codecTest(320, 320);\n  codecTest(1, 10000);\n  codecTest(10000, 1);\n\n  testOtherPattern1();\n  testOtherPattern2();\n#endif // DISABLE_SLOW\n\n  testColor(255, 255, 255, 255);\n  testColor(0, 0, 0, 255);\n  testColor(1, 2, 3, 255);\n  testColor(255, 0, 0, 255);\n  testColor(0, 255, 0, 255);\n  testColor(0, 0, 255, 255);\n  testColor(0, 0, 0, 255);\n  testColor(1, 1, 1, 255);\n  testColor(1, 1, 1, 1);\n  testColor(0, 0, 0, 128);\n  testColor(255, 0, 0, 128);\n  testColor(127, 127, 127, 255);\n  testColor(128, 128, 128, 255);\n  testColor(127, 127, 127, 128);\n  testColor(128, 128, 128, 128);\n  //transparent single pixels\n  testColor(0, 0, 0, 0);\n  testColor(255, 0, 0, 0);\n  testColor(1, 2, 3, 0);\n  testColor(255, 255, 255, 0);\n  testColor(254, 254, 254, 0);\n\n  // This is mainly to test the Adam7 interlacing\n  for(unsigned h = 1; h < 12; h++)\n  for(unsigned w = 1; w < 12; w++) {\n    testSize(w, h);\n  }\n}\n\n//Tests some specific color conversions with specific color bit combinations\nvoid testColorConvert() {\n  //test color conversions to RGBA8\n  colorConvertTest(\"1\", LCT_GREY, 1, \"11111111 11111111 11111111 11111111\", LCT_RGBA, 8);\n  colorConvertTest(\"10\", LCT_GREY, 2, \"10101010 10101010 10101010 11111111\", LCT_RGBA, 8);\n  colorConvertTest(\"1001\", LCT_GREY, 4, \"10011001 10011001 10011001 11111111\", LCT_RGBA, 8);\n  colorConvertTest(\"10010101\", LCT_GREY, 8, \"10010101 10010101 10010101 11111111\", LCT_RGBA, 8);\n  colorConvertTest(\"10010101 11111110\", LCT_GREY_ALPHA, 8, \"10010101 10010101 10010101 11111110\", LCT_RGBA, 8);\n  colorConvertTest(\"10010101 00000001 11111110 00000001\", LCT_GREY_ALPHA, 16, \"10010101 10010101 10010101 11111110\", LCT_RGBA, 8);\n  colorConvertTest(\"01010101 00000000 00110011\", LCT_RGB, 8, \"01010101 00000000 00110011 11111111\", LCT_RGBA, 8);\n  colorConvertTest(\"01010101 00000000 00110011 10101010\", LCT_RGBA, 8, \"01010101 00000000 00110011 10101010\", LCT_RGBA, 8);\n  colorConvertTest(\"10101010 01010101 11111111 00000000 11001100 00110011\", LCT_RGB, 16, \"10101010 11111111 11001100 11111111\", LCT_RGBA, 8);\n  colorConvertTest(\"10101010 01010101 11111111 00000000 11001100 00110011 11100111 00011000\", LCT_RGBA, 16, \"10101010 11111111 11001100 11100111\", LCT_RGBA, 8);\n\n  //test color conversions to RGB8\n  colorConvertTest(\"1\", LCT_GREY, 1, \"11111111 11111111 11111111\", LCT_RGB, 8);\n  colorConvertTest(\"10\", LCT_GREY, 2, \"10101010 10101010 10101010\", LCT_RGB, 8);\n  colorConvertTest(\"1001\", LCT_GREY, 4, \"10011001 10011001 10011001\", LCT_RGB, 8);\n  colorConvertTest(\"10010101\", LCT_GREY, 8, \"10010101 10010101 10010101\", LCT_RGB, 8);\n  colorConvertTest(\"10010101 11111110\", LCT_GREY_ALPHA, 8, \"10010101 10010101 10010101\", LCT_RGB, 8);\n  colorConvertTest(\"10010101 00000001 11111110 00000001\", LCT_GREY_ALPHA, 16, \"10010101 10010101 10010101\", LCT_RGB, 8);\n  colorConvertTest(\"01010101 00000000 00110011\", LCT_RGB, 8, \"01010101 00000000 00110011\", LCT_RGB, 8);\n  colorConvertTest(\"01010101 00000000 00110011 10101010\", LCT_RGBA, 8, \"01010101 00000000 00110011\", LCT_RGB, 8);\n  colorConvertTest(\"10101010 01010101 11111111 00000000 11001100 00110011\", LCT_RGB, 16, \"10101010 11111111 11001100\", LCT_RGB, 8);\n  colorConvertTest(\"10101010 01010101 11111111 00000000 11001100 00110011 11100111 00011000\", LCT_RGBA, 16, \"10101010 11111111 11001100\", LCT_RGB, 8);\n\n  //test color conversions to RGBA16\n  colorConvertTest(\"1\", LCT_GREY, 1, \"11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111\", LCT_RGBA, 16);\n  colorConvertTest(\"10\", LCT_GREY, 2, \"10101010 10101010 10101010 10101010 10101010 10101010 11111111 11111111\", LCT_RGBA, 16);\n\n  //test grayscale color conversions\n  colorConvertTest(\"1\", LCT_GREY, 1, \"11111111\", LCT_GREY, 8);\n  colorConvertTest(\"1\", LCT_GREY, 1, \"1111111111111111\", LCT_GREY, 16);\n  colorConvertTest(\"0\", LCT_GREY, 1, \"00000000\", LCT_GREY, 8);\n  colorConvertTest(\"0\", LCT_GREY, 1, \"0000000000000000\", LCT_GREY, 16);\n  colorConvertTest(\"11\", LCT_GREY, 2, \"11111111\", LCT_GREY, 8);\n  colorConvertTest(\"11\", LCT_GREY, 2, \"1111111111111111\", LCT_GREY, 16);\n  colorConvertTest(\"10\", LCT_GREY, 2, \"10101010\", LCT_GREY, 8);\n  colorConvertTest(\"10\", LCT_GREY, 2, \"1010101010101010\", LCT_GREY, 16);\n  colorConvertTest(\"1000\", LCT_GREY, 4, \"10001000\", LCT_GREY, 8);\n  colorConvertTest(\"1000\", LCT_GREY, 4, \"1000100010001000\", LCT_GREY, 16);\n  colorConvertTest(\"10110101\", LCT_GREY, 8, \"1011010110110101\", LCT_GREY, 16);\n  colorConvertTest(\"1011010110110101\", LCT_GREY, 16, \"10110101\", LCT_GREY, 8);\n\n  //others\n  colorConvertTest(\"11111111 11111111 11111111 00000000 00000000 00000000\", LCT_RGB, 8, \"10\", LCT_GREY, 1);\n  colorConvertTest(\"11111111 11111111 11111111 11111111 11111111 11111111 00000000 00000000 00000000 00000000 00000000 00000000\", LCT_RGB, 16, \"10\", LCT_GREY, 1);\n}\n\n//This tests color conversions from any color model to any color model, with any bit depth\n//But it tests only with colors black and white, because that are the only colors every single model supports\nvoid testColorConvert2() {\n  std::cout << \"testColorConvert2\" << std::endl;\n  struct Combo {\n    LodePNGColorType colortype;\n    unsigned bitdepth;\n  };\n\n  Combo combos[15] = { { LCT_GREY, 1}, { LCT_GREY, 2}, { LCT_GREY, 4}, { LCT_GREY, 8}, { LCT_GREY, 16}, { LCT_RGB, 8}, { LCT_RGB, 16}, { LCT_PALETTE, 1}, { LCT_PALETTE, 2}, { LCT_PALETTE, 4}, { LCT_PALETTE, 8}, { LCT_GREY_ALPHA, 8}, { LCT_GREY_ALPHA, 16}, { LCT_RGBA, 8}, { LCT_RGBA, 16},\n  };\n\n  lodepng::State state;\n  LodePNGColorMode& mode_in = state.info_png.color;\n  LodePNGColorMode& mode_out = state.info_raw;\n  LodePNGColorMode mode_8;\n  lodepng_color_mode_init(&mode_8);\n\n  for(size_t i = 0; i < 256; i++) {\n    size_t j = i == 1 ? 255 : i;\n    lodepng_palette_add(&mode_in, j, j, j, 255);\n    lodepng_palette_add(&mode_out, j, j, j, 255);\n  }\n\n  for(size_t i = 0; i < 15; i++) {\n    mode_in.colortype = combos[i].colortype;\n    mode_in.bitdepth = combos[i].bitdepth;\n\n    for(size_t j = 0; j < 15; j++) {\n      mode_out.colortype = combos[i].colortype;\n      mode_out.bitdepth = combos[i].bitdepth;\n\n      unsigned char eight[36] = {\n          0,0,0,255, 255,255,255,255,\n          0,0,0,255, 255,255,255,255,\n          255,255,255,255, 0,0,0,255,\n          255,255,255,255, 255,255,255,255,\n          0,0,0,255 }; //input in RGBA8\n      unsigned char in[72]; //custom input color type\n      unsigned char out[72]; //custom output color type\n      unsigned char eight2[36]; //back in RGBA8 after all conversions to check correctness\n      unsigned error = 0;\n\n      error |= lodepng_convert(in, eight, &mode_in, &mode_8, 3, 3);\n      if(!error) error |= lodepng_convert(out, in, &mode_out, &mode_in, 3, 3); //Test input to output type\n      if(!error) error |= lodepng_convert(eight2, out, &mode_8, &mode_out, 3, 3);\n\n      if(!error) {\n        for(size_t k = 0; k < 36; k++) {\n          if(eight[k] != eight2[k]) {\n            error = 99999;\n            break;\n          }\n        }\n      }\n\n      if(error) {\n        std::cout << \"Error \" << error << \" i: \" << i << \" j: \" << j\n          << \" colortype i: \" << combos[i].colortype\n          << \" bitdepth i: \" << combos[i].bitdepth\n          << \" colortype j: \" << combos[j].colortype\n          << \" bitdepth j: \" << combos[j].bitdepth\n          << std::endl;\n        if(error != 99999) ASSERT_NO_PNG_ERROR(error);\n        else fail();\n      }\n    }\n  }\n}\n\n//if compressible is true, the test will also assert that the compressed string is smaller\nvoid testCompressStringZlib(const std::string& text, bool compressible) {\n  if(text.size() < 500) std::cout << \"compress test with text: \" << text << std::endl;\n  else std::cout << \"compress test with text length: \" << text.size() << std::endl;\n\n  std::vector<unsigned char> in(text.size());\n  for(size_t i = 0; i < text.size(); i++) in[i] = (unsigned char)text[i];\n  unsigned char* out = 0;\n  size_t outsize = 0;\n  unsigned error = 0;\n\n  error = lodepng_zlib_compress(&out, &outsize, in.empty() ? 0 : &in[0], in.size(), &lodepng_default_compress_settings);\n  ASSERT_NO_PNG_ERROR(error);\n  if(compressible) assertTrue(outsize < in.size());\n\n  unsigned char* out2 = 0;\n  size_t outsize2 = 0;\n\n  error = lodepng_zlib_decompress(&out2, &outsize2, out, outsize, &lodepng_default_decompress_settings);\n  ASSERT_NO_PNG_ERROR(error);\n  ASSERT_EQUALS(outsize2, in.size());\n  for(size_t i = 0; i < in.size(); i++) ASSERT_EQUALS(in[i], out2[i]);\n\n  free(out);\n  free(out2);\n}\n\nvoid testCompressZlib() {\n  testCompressStringZlib(\"\", false);\n  testCompressStringZlib(\"a\", false);\n  testCompressStringZlib(\"aa\", false);\n  testCompressStringZlib(\"ababababababababababababababababababababababababababababababababababababababababababab\", true);\n  testCompressStringZlib(\"abaaaabaabbbaabbabbababbbbabababbbaabbbaaaabbbbabbbabbbaababbbbbaaabaabbabaaaabbbbbbab\", true);\n  testCompressStringZlib(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\", true);\n  testCompressStringZlib(\"omnomnomnomnomnomnomnomnomnomnom\", true);\n  testCompressStringZlib(\"the quick brown fox jumps over the lazy dog. the quick brown fox jumps over the lazy dog.\", true);\n  testCompressStringZlib(\"abracadabra\", false);\n  testCompressStringZlib(\"hello hello hello hello hello hello hello hello hello hello hello?\", true);\n  testCompressStringZlib(\"WPgZX2D*um0H::,4/KU\\\"kt\\\"Ne\\\"#Qa.&#<aF9{jag]|{hv,IXez\\\n\\\\DKn5zYdV{XxBi=n|1J-TwakWvp[b8|-kOcZ@QkAxJSMeZ0l&<*w0BP/CXM(LFH'\", false);\n  testCompressStringZlib(\"asdfhlkhfafsduyfbasiuytfgbiasuidygiausygdifaubsydfsdf\", false);\n  testCompressStringZlib(\"418541499849814614617987416457317375467441841687487\", true);\n  testCompressStringZlib(\"3.141592653589793238462643383279502884197169399375105820974944592307816406286\", true);\n  testCompressStringZlib(\"lodepng_zlib_decompress(&out2, &outsize2, out, outsize, &lodepng_default_decompress_settings);\", true);\n}\n\nvoid testDiskCompressZlib(const std::string& filename) {\n  std::cout << \"testDiskCompressZlib: File \" << filename << std::endl;\n\n  std::vector<unsigned char> buffer;\n  lodepng::load_file(buffer, filename);\n  std::string f;\n  for(size_t i = 0; i < buffer.size(); i++) f += (char)buffer[i];\n  testCompressStringZlib(f, false);\n}\n\nvoid testDiskPNG(const std::string& filename) {\n  std::cout << \"testDiskPNG: File \" << filename << std::endl;\n\n  Image image;\n  image.colorType = LCT_RGB;\n  image.bitDepth = 8;\n  unsigned error = lodepng::decode(image.data, image.width, image.height, filename, image.colorType, image.bitDepth);\n  ASSERT_NO_PNG_ERROR(error);\n\n  doCodecTest(image);\n}\n\nstd::vector<unsigned> strtovector(const std::string& numbers) {\n  std::vector<unsigned> result;\n  std::stringstream ss(numbers);\n  unsigned i;\n  while(ss >> i) result.push_back(i);\n  return result;\n}\n\nvoid doTestHuffmanCodeLengths(const std::string& expectedstr, const std::string& counts, size_t bitlength) {\n  std::vector<unsigned> expected = strtovector(expectedstr);\n  std::vector<unsigned> count = strtovector(counts);\n  std::cout << \"doTestHuffmanCodeLengths: \" << counts << std::endl;\n  std::vector<unsigned> result(count.size());\n  unsigned error = lodepng_huffman_code_lengths(&result[0], &count[0], count.size(), bitlength);\n  ASSERT_NO_PNG_ERROR_MSG(error, \"errorcode\");\n  std::stringstream ss1, ss2;\n  for(size_t i = 0; i < count.size(); i++) {\n    ss1 << expected[i] << \" \";\n    ss2 << result[i] << \" \";\n  }\n  assertEquals(ss1.str(), ss2.str(), \"value\");\n}\n\nvoid testHuffmanCodeLengths() {\n  bool atleasttwo = true; //LodePNG generates at least two, instead of at least one, symbol\n  if(atleasttwo) {\n    doTestHuffmanCodeLengths(\"1 1\", \"0 0\", 16);\n    doTestHuffmanCodeLengths(\"1 1 0\", \"0 0 0\", 16);\n    doTestHuffmanCodeLengths(\"1 1\", \"1 0\", 16);\n    doTestHuffmanCodeLengths(\"1 1 0 0 0 0 0 0 0\", \"0 0 0 0 0 0 0 0 0\", 16);\n    doTestHuffmanCodeLengths(\"1 1 0 0 0 0 0 0 0\", \"1 0 0 0 0 0 0 0 0\", 16);\n    doTestHuffmanCodeLengths(\"1 1 0 0 0 0 0 0 0\", \"0 1 0 0 0 0 0 0 0\", 16);\n    doTestHuffmanCodeLengths(\"1 0 0 0 0 0 0 0 1\", \"0 0 0 0 0 0 0 0 1\", 16);\n    doTestHuffmanCodeLengths(\"0 0 0 0 0 0 0 1 1\", \"0 0 0 0 0 0 0 1 1\", 16);\n  } else {\n    doTestHuffmanCodeLengths(\"1 0\", \"0 0\", 16);\n    doTestHuffmanCodeLengths(\"1 0 0\", \"0 0 0\", 16);\n    doTestHuffmanCodeLengths(\"1 0\", \"1 0\", 16);\n    doTestHuffmanCodeLengths(\"1\", \"1\", 16);\n    doTestHuffmanCodeLengths(\"1\", \"0\", 16);\n  }\n  doTestHuffmanCodeLengths(\"1 1\", \"1 1\", 16);\n  doTestHuffmanCodeLengths(\"1 1\", \"1 100\", 16);\n  doTestHuffmanCodeLengths(\"2 2 1\", \"1 2 3\", 16);\n  doTestHuffmanCodeLengths(\"2 1 2\", \"2 3 1\", 16);\n  doTestHuffmanCodeLengths(\"1 2 2\", \"3 1 2\", 16);\n  doTestHuffmanCodeLengths(\"3 3 2 1\", \"1 30 31 32\", 16);\n  doTestHuffmanCodeLengths(\"2 2 2 2\", \"1 30 31 32\", 2);\n  doTestHuffmanCodeLengths(\"5 5 4 4 4 3 3 1\", \"1 2 3 4 5 6 7 500\", 16);\n}\n\n/*\nCreate a PNG image with all known chunks (except only one of tEXt or zTXt) plus\nunknown chunks, and a palette.\n*/\nvoid createComplexPNG(std::vector<unsigned char>& png) {\n  unsigned w = 16, h = 17;\n  std::vector<unsigned char> image(w * h);\n  for(size_t i = 0; i < w * h; i++) {\n    image[i] = i % 256;\n  }\n\n  lodepng::State state;\n  LodePNGInfo& info = state.info_png;\n  info.color.colortype = LCT_PALETTE;\n  info.color.bitdepth = 8;\n  state.info_raw.colortype = LCT_PALETTE;\n  state.info_raw.bitdepth = 8;\n  state.encoder.auto_convert = false;\n  state.encoder.text_compression = 1;\n  state.encoder.add_id = 1;\n  for(size_t i = 0; i < 256; i++) {\n    lodepng_palette_add(&info.color, i, i, i, i);\n    lodepng_palette_add(&state.info_raw, i, i, i, i);\n  }\n\n  info.background_defined = 1;\n  info.background_r = 127;\n\n  lodepng_add_text(&info, \"key0\", \"string0\");\n  lodepng_add_text(&info, \"key1\", \"string1\");\n\n  lodepng_add_itext(&info, \"ikey0\", \"ilangtag0\", \"itranskey0\", \"istring0\");\n  lodepng_add_itext(&info, \"ikey1\", \"ilangtag1\", \"itranskey1\", \"istring1\");\n\n  info.time_defined = 1;\n  info.time.year = 2012;\n  info.time.month = 1;\n  info.time.day = 2;\n  info.time.hour = 3;\n  info.time.minute = 4;\n  info.time.second = 5;\n\n  info.phys_defined = 1;\n  info.phys_x = 1;\n  info.phys_y = 2;\n  info.phys_unit = 1;\n\n  lodepng_chunk_create(&info.unknown_chunks_data[0], &info.unknown_chunks_size[0], 3, \"uNKa\", (unsigned char*)\"a00\");\n  lodepng_chunk_create(&info.unknown_chunks_data[0], &info.unknown_chunks_size[0], 3, \"uNKa\", (unsigned char*)\"a01\");\n  lodepng_chunk_create(&info.unknown_chunks_data[1], &info.unknown_chunks_size[1], 3, \"uNKb\", (unsigned char*)\"b00\");\n  lodepng_chunk_create(&info.unknown_chunks_data[2], &info.unknown_chunks_size[2], 3, \"uNKc\", (unsigned char*)\"c00\");\n\n  unsigned error = lodepng::encode(png, &image[0], w, h, state);\n  ASSERT_NO_PNG_ERROR(error);\n}\n\nstd::string extractChunkNames(const std::vector<unsigned char>& png) {\n  const unsigned char* chunk = &png[8];\n  const unsigned char* end = &png.back() + 1;\n  char name[5];\n  std::string result = \"\";\n  for(;;) {\n    lodepng_chunk_type(name, chunk);\n    result += (std::string(\" \") + name);\n    if(std::string(name) == \"IEND\") break;\n    chunk = lodepng_chunk_next_const(chunk, end);\n    assertTrue(chunk < &png.back(), \"jumped out of chunks\");\n  }\n  return result;\n}\n\nvoid testComplexPNG() {\n  std::cout << \"testComplexPNG\" << std::endl;\n\n  std::vector<unsigned char> png;\n  createComplexPNG(png);\n {\n    lodepng::State state;\n    LodePNGInfo& info = state.info_png;\n    unsigned w, h;\n    std::vector<unsigned char> image;\n    unsigned error = lodepng::decode(image, w, h, state, &png[0], png.size());\n    ASSERT_NO_PNG_ERROR(error);\n\n    ASSERT_EQUALS(16, w);\n    ASSERT_EQUALS(17, h);\n    ASSERT_EQUALS(1, info.background_defined);\n    ASSERT_EQUALS(127, info.background_r);\n    ASSERT_EQUALS(1, info.time_defined);\n    ASSERT_EQUALS(2012, info.time.year);\n    ASSERT_EQUALS(1, info.time.month);\n    ASSERT_EQUALS(2, info.time.day);\n    ASSERT_EQUALS(3, info.time.hour);\n    ASSERT_EQUALS(4, info.time.minute);\n    ASSERT_EQUALS(5, info.time.second);\n    ASSERT_EQUALS(1, info.phys_defined);\n    ASSERT_EQUALS(1, info.phys_x);\n    ASSERT_EQUALS(2, info.phys_y);\n    ASSERT_EQUALS(1, info.phys_unit);\n\n    std::string chunknames = extractChunkNames(png);\n    //std::string expectednames = \" IHDR uNKa uNKa PLTE tRNS bKGD pHYs uNKb IDAT tIME tEXt tEXt tEXt iTXt iTXt uNKc IEND\";\n    std::string expectednames = \" IHDR uNKa uNKa PLTE tRNS bKGD pHYs uNKb IDAT tIME zTXt zTXt tEXt iTXt iTXt uNKc IEND\";\n    ASSERT_EQUALS(expectednames, chunknames);\n\n    ASSERT_EQUALS(3, info.text_num);\n    ASSERT_STRING_EQUALS(\"key0\", info.text_keys[0]);\n    ASSERT_STRING_EQUALS(\"string0\", info.text_strings[0]);\n    ASSERT_STRING_EQUALS(\"key1\", info.text_keys[1]);\n    ASSERT_STRING_EQUALS(\"string1\", info.text_strings[1]);\n    ASSERT_STRING_EQUALS(\"LodePNG\", info.text_keys[2]);\n    ASSERT_STRING_EQUALS(LODEPNG_VERSION_STRING, info.text_strings[2]);\n\n    ASSERT_EQUALS(2, info.itext_num);\n    ASSERT_STRING_EQUALS(\"ikey0\", info.itext_keys[0]);\n    ASSERT_STRING_EQUALS(\"ilangtag0\", info.itext_langtags[0]);\n    ASSERT_STRING_EQUALS(\"itranskey0\", info.itext_transkeys[0]);\n    ASSERT_STRING_EQUALS(\"istring0\", info.itext_strings[0]);\n    ASSERT_STRING_EQUALS(\"ikey1\", info.itext_keys[1]);\n    ASSERT_STRING_EQUALS(\"ilangtag1\", info.itext_langtags[1]);\n    ASSERT_STRING_EQUALS(\"itranskey1\", info.itext_transkeys[1]);\n    ASSERT_STRING_EQUALS(\"istring1\", info.itext_strings[1]);\n\n    // TODO: test if unknown chunks listed too\n  }\n\n\n  // Test that if read_text_chunks is disabled, we do not get the texts\n  {\n    lodepng::State state;\n    state.decoder.read_text_chunks = 0;\n    unsigned w, h;\n    std::vector<unsigned char> image;\n    unsigned error = lodepng::decode(image, w, h, state, &png[0], png.size());\n    ASSERT_NO_PNG_ERROR(error);\n\n    ASSERT_EQUALS(0, state.info_png.text_num);\n    ASSERT_EQUALS(0, state.info_png.itext_num);\n\n    // But we should still get other values.\n    ASSERT_EQUALS(2012, state.info_png.time.year);\n  }\n}\n\n// Tests lodepng_inspect_chunk, and also lodepng_chunk_find to find the chunk to inspect\nvoid testInspectChunk() {\n  std::cout << \"testInspectChunk\" << std::endl;\n\n  std::vector<unsigned char> png;\n  createComplexPNG(png);\n\n  const unsigned char* chunk;\n  lodepng::State state;\n  LodePNGInfo& info = state.info_png;\n  state.decoder.read_text_chunks = 0;\n  lodepng_inspect(0, 0, &state, png.data(), png.size());\n  chunk = lodepng_chunk_find(png.data(), png.data() + png.size(), \"tIME\");\n  ASSERT_NOT_EQUALS((const unsigned char*)0, chunk); // should be non-null, since it should find it\n  ASSERT_EQUALS(0, info.time_defined);\n  lodepng_inspect_chunk(&state, (size_t)(chunk - png.data()), png.data(), png.size());\n  ASSERT_EQUALS(1, info.time_defined);\n  ASSERT_EQUALS(2012, state.info_png.time.year);\n  ASSERT_EQUALS(1, info.time.month);\n  ASSERT_EQUALS(2, info.time.day);\n  ASSERT_EQUALS(3, info.time.hour);\n  ASSERT_EQUALS(4, info.time.minute);\n  ASSERT_EQUALS(5, info.time.second);\n\n  ASSERT_EQUALS(0, info.text_num);\n  chunk = lodepng_chunk_find_const(png.data(), png.data() + png.size(), \"zTXt\");\n  lodepng_inspect_chunk(&state, (size_t)(chunk - png.data()), png.data(), png.size());\n  ASSERT_EQUALS(1, info.text_num);\n  chunk = lodepng_chunk_find_const(chunk, png.data() + png.size(), \"zTXt\");\n  lodepng_inspect_chunk(&state, (size_t)(chunk - png.data()), png.data(), png.size());\n  ASSERT_EQUALS(2, info.text_num);\n}\n\n//test that, by default, it chooses filter type zero for all scanlines if the image has a palette\nvoid testPaletteFilterTypesZero() {\n  std::cout << \"testPaletteFilterTypesZero\" << std::endl;\n\n  std::vector<unsigned char> png;\n  createComplexPNG(png);\n\n  std::vector<unsigned char> filterTypes;\n  lodepng::getFilterTypes(filterTypes, png);\n\n  ASSERT_EQUALS(17, filterTypes.size());\n  for(size_t i = 0; i < 17; i++) ASSERT_EQUALS(0, filterTypes[i]);\n}\n\n//tests that there are no crashes with auto color chooser in case of palettes with translucency etc...\nvoid testPaletteToPaletteConvert() {\n  std::cout << \"testPaletteToPaletteConvert\" << std::endl;\n  unsigned error;\n  unsigned w = 16, h = 16;\n  std::vector<unsigned char> image(w * h);\n  for(size_t i = 0; i < w * h; i++) image[i] = i % 256;\n  lodepng::State state;\n  LodePNGInfo& info = state.info_png;\n  info.color.colortype = state.info_raw.colortype = LCT_PALETTE;\n  info.color.bitdepth = state.info_raw.bitdepth = 8;\n  ASSERT_EQUALS(true, state.encoder.auto_convert);\n  for(size_t i = 0; i < 256; i++) {\n    lodepng_palette_add(&info.color, i, i, i, i);\n  }\n  std::vector<unsigned char> png;\n  for(size_t i = 0; i < 256; i++) {\n    lodepng_palette_add(&state.info_raw, i, i, i, i);\n  }\n  error = lodepng::encode(png, &image[0], w, h, state);\n  ASSERT_NO_PNG_ERROR(error);\n}\n\n//for this test, you have to choose palette colors that cause LodePNG to actually use a palette,\n//so don't use all grayscale colors for example\nvoid doRGBAToPaletteTest(unsigned char* palette, size_t size, LodePNGColorType expectedType = LCT_PALETTE) {\n  std::cout << \"testRGBToPaletteConvert \" << size << std::endl;\n  unsigned error;\n  unsigned w = size, h = 257 /*LodePNG encodes no palette if image is too small*/;\n  std::vector<unsigned char> image(w * h * 4);\n  for(size_t i = 0; i < image.size(); i++) image[i] = palette[i % (size * 4)];\n  std::vector<unsigned char> png;\n  error = lodepng::encode(png, &image[0], w, h);\n  ASSERT_NO_PNG_ERROR(error);\n  lodepng::State state;\n  std::vector<unsigned char> image2;\n  error = lodepng::decode(image2, w, h, state, png);\n  ASSERT_NO_PNG_ERROR(error);\n  ASSERT_EQUALS(image.size(), image2.size());\n  for(size_t i = 0; i < image.size(); i++) ASSERT_EQUALS(image[i], image2[i]);\n\n  ASSERT_EQUALS(expectedType, state.info_png.color.colortype);\n  if(expectedType == LCT_PALETTE) {\n\n    ASSERT_EQUALS(size, state.info_png.color.palettesize);\n    for(size_t i = 0; i < size * 4; i++) ASSERT_EQUALS(state.info_png.color.palette[i], image[i]);\n  }\n}\n\nvoid testRGBToPaletteConvert() {\n  unsigned char palette1[4] = {1,2,3,4};\n  doRGBAToPaletteTest(palette1, 1);\n  unsigned char palette2[8] = {1,2,3,4, 5,6,7,8};\n  doRGBAToPaletteTest(palette2, 2);\n  unsigned char palette3[12] = {1,1,1,255, 20,20,20,255, 20,20,21,255};\n  doRGBAToPaletteTest(palette3, 3);\n\n  std::vector<unsigned char> palette;\n  for(int i = 0; i < 256; i++) {\n    palette.push_back(i);\n    palette.push_back(5);\n    palette.push_back(6);\n    palette.push_back(128);\n  }\n  doRGBAToPaletteTest(&palette[0], 256);\n  palette.push_back(5);\n  palette.push_back(6);\n  palette.push_back(7);\n  palette.push_back(8);\n  doRGBAToPaletteTest(&palette[0], 257, LCT_RGBA);\n}\n\nvoid testColorKeyConvert() {\n  std::cout << \"testColorKeyConvert\" << std::endl;\n  unsigned error;\n  unsigned w = 32, h = 32;\n  std::vector<unsigned char> image(w * h * 4);\n  for(size_t i = 0; i < w * h; i++) {\n    image[i * 4 + 0] = i % 256;\n    image[i * 4 + 1] = i / 256;\n    image[i * 4 + 2] = 0;\n    image[i * 4 + 3] = i == 23 ? 0 : 255;\n  }\n  std::vector<unsigned char> png;\n  error = lodepng::encode(png, &image[0], w, h);\n  ASSERT_NO_PNG_ERROR(error);\n\n  lodepng::State state;\n  std::vector<unsigned char> image2;\n  error = lodepng::decode(image2, w, h, state, png);\n  ASSERT_NO_PNG_ERROR(error);\n  ASSERT_EQUALS(32, w);\n  ASSERT_EQUALS(32, h);\n  ASSERT_EQUALS(1, state.info_png.color.key_defined);\n  ASSERT_EQUALS(23, state.info_png.color.key_r);\n  ASSERT_EQUALS(0, state.info_png.color.key_g);\n  ASSERT_EQUALS(0, state.info_png.color.key_b);\n  ASSERT_EQUALS(image.size(), image2.size());\n  for(size_t i = 0; i < image.size(); i++) {\n    ASSERT_EQUALS(image[i], image2[i]);\n  }\n}\n\nvoid testNoAutoConvert() {\n  std::cout << \"testNoAutoConvert\" << std::endl;\n  unsigned error;\n  unsigned w = 32, h = 32;\n  std::vector<unsigned char> image(w * h * 4);\n  for(size_t i = 0; i < w * h; i++) {\n    image[i * 4 + 0] = (i % 2) ? 255 : 0;\n    image[i * 4 + 1] = (i % 2) ? 255 : 0;\n    image[i * 4 + 2] = (i % 2) ? 255 : 0;\n    image[i * 4 + 3] = 0;\n  }\n  std::vector<unsigned char> png;\n  lodepng::State state;\n  state.info_png.color.colortype = LCT_RGBA;\n  state.info_png.color.bitdepth = 8;\n  state.encoder.auto_convert = false;\n  error = lodepng::encode(png, &image[0], w, h, state);\n  ASSERT_NO_PNG_ERROR(error);\n\n  lodepng::State state2;\n  std::vector<unsigned char> image2;\n  error = lodepng::decode(image2, w, h, state2, png);\n  ASSERT_NO_PNG_ERROR(error);\n  ASSERT_EQUALS(32, w);\n  ASSERT_EQUALS(32, h);\n  ASSERT_EQUALS(LCT_RGBA, state2.info_png.color.colortype);\n  ASSERT_EQUALS(8, state2.info_png.color.bitdepth);\n  ASSERT_EQUALS(image.size(), image2.size());\n  for(size_t i = 0; i < image.size(); i++) {\n    ASSERT_EQUALS(image[i], image2[i]);\n  }\n}\n\nunsigned char flipBit(unsigned char c, int bitpos) {\n  return c ^ (1 << bitpos);\n}\n\n//Test various broken inputs. Returned errors are not checked, what is tested is\n//that is doesn't crash, and, when run with valgrind, no memory warnings are\n//given.\nvoid testFuzzing() {\n  std::cout << \"testFuzzing\" << std::endl;\n  std::vector<unsigned char> png;\n  createComplexPNG(png);\n  std::vector<unsigned char> broken = png;\n  std::vector<unsigned char> result;\n  std::map<unsigned, unsigned> errors;\n  unsigned w, h;\n  lodepng::State state;\n  state.decoder.ignore_crc = 1;\n  state.decoder.zlibsettings.ignore_adler32 = 1;\n  for(size_t i = 0; i < png.size(); i++) {\n    result.clear();\n    broken[i] = ~png[i];\n    errors[lodepng::decode(result, w, h, state, broken)]++;\n    broken[i] = 0;\n    errors[lodepng::decode(result, w, h, state, broken)]++;\n    for(int j = 0; j < 8; j++) {\n      broken[i] = flipBit(png[i], j);\n      errors[lodepng::decode(result, w, h, state, broken)]++;\n    }\n    broken[i] = 255;\n    errors[lodepng::decode(result, w, h, state, broken)]++;\n    broken[i] = png[i]; //fix it again for the next test\n  }\n  std::cout << \"testFuzzing shrinking\" << std::endl;\n  broken = png;\n  while(broken.size() > 0) {\n    broken.resize(broken.size() - 1);\n    errors[lodepng::decode(result, w, h, state, broken)]++;\n  }\n\n  //For fun, print the number of each error\n  std::cout << \"Fuzzing error code counts: \";\n  for(std::map<unsigned, unsigned>::iterator it = errors.begin(); it != errors.end(); ++it) {\n    std::cout << it->first << \":\" << it->second << \", \";\n  }\n  std::cout << std::endl;\n}\n\nint custom_proof = 0; // global variable for nested function to call. Of course when this test is switched to modern C++ we can use a lamba instead.\n\nvoid testCustomZlibCompress() {\n  std::cout << \"testCustomZlibCompress\" << std::endl;\n  Image image;\n  generateTestImage(image, 5, 5, LCT_RGBA, 8);\n\n  std::vector<unsigned char> encoded;\n  int customcontext = 5;\n\n  struct TestFun {\n    static unsigned custom_zlib(unsigned char**, size_t*,\n                          const unsigned char*, size_t,\n                          const LodePNGCompressSettings* settings) {\n      ASSERT_EQUALS(5, *(int*)(settings->custom_context));\n      custom_proof = 1;\n      return 5555; // return a custom error code, which will be converted to an error known to lodepng.\n    }\n  };\n\n  lodepng::State state;\n  state.encoder.zlibsettings.custom_zlib = TestFun::custom_zlib;\n  state.encoder.zlibsettings.custom_context = &customcontext;\n\n  custom_proof = 0;\n  unsigned error = lodepng::encode(encoded, image.data, image.width, image.height, state);\n  ASSERT_EQUALS(1, custom_proof); // check that the custom zlib was called\n\n  ASSERT_EQUALS(111, error); // expect a known lodepng error, not the custom 5555\n}\n\nvoid testCustomZlibCompress2() {\n  std::cout << \"testCustomZlibCompress2\" << std::endl;\n  Image image;\n  generateTestImage(image, 5, 5, LCT_RGBA, 8);\n\n  std::vector<unsigned char> encoded;\n\n  lodepng::State state;\n  state.encoder.zlibsettings.custom_zlib = lodepng_zlib_compress;\n\n  unsigned error = lodepng::encode(encoded, image.data, image.width, image.height,\n                                   state);\n  ASSERT_NO_PNG_ERROR(error);\n\n  std::vector<unsigned char> decoded;\n  unsigned w, h;\n  state.decoder.zlibsettings.ignore_adler32 = 0;\n  state.decoder.ignore_crc = 0;\n  error = lodepng::decode(decoded, w, h, state, encoded);\n  ASSERT_NO_PNG_ERROR(error);\n  ASSERT_EQUALS(5, w);\n  ASSERT_EQUALS(5, h);\n}\n\nvoid testCustomDeflate() {\n  std::cout << \"testCustomDeflate\" << std::endl;\n  Image image;\n  generateTestImage(image, 5, 5, LCT_RGBA, 8);\n\n  std::vector<unsigned char> encoded;\n  int customcontext = 5;\n\n  struct TestFun {\n    static unsigned custom_deflate(unsigned char**, size_t*,\n                                   const unsigned char*, size_t,\n                                   const LodePNGCompressSettings* settings) {\n      ASSERT_EQUALS(5, *(int*)(settings->custom_context));\n      custom_proof = 1;\n      return 5555; // return a custom error code, which will be converted to an error known to lodepng.\n    }\n  };\n\n  lodepng::State state;\n  state.encoder.zlibsettings.custom_deflate = TestFun::custom_deflate;\n  state.encoder.zlibsettings.custom_context = &customcontext;\n\n  custom_proof = 0;\n  unsigned error = lodepng::encode(encoded, image.data, image.width, image.height, state);\n  ASSERT_EQUALS(1, custom_proof); // check that the custom deflate was called\n\n  ASSERT_EQUALS(111, error); // expect a known lodepng error, not the custom 5555\n}\n\nvoid testCustomZlibDecompress() {\n  std::cout << \"testCustomZlibDecompress\" << std::endl;\n  Image image;\n  generateTestImage(image, 5, 5, LCT_RGBA, 8);\n\n  std::vector<unsigned char> encoded;\n\n  unsigned error_enc = lodepng::encode(encoded, image.data, image.width, image.height,\n                                   image.colorType, image.bitDepth);\n  ASSERT_NO_PNG_ERROR_MSG(error_enc, \"encoder error not expected\");\n\n\n  std::vector<unsigned char> decoded;\n  unsigned w, h;\n  int customcontext = 5;\n\n  struct TestFun {\n    static unsigned custom_zlib(unsigned char**, size_t*,\n                          const unsigned char*, size_t,\n                          const LodePNGDecompressSettings* settings) {\n      ASSERT_EQUALS(5, *(int*)(settings->custom_context));\n      custom_proof = 1;\n      return 5555; // return a custom error code, which will be converted to an error known to lodepng.\n    }\n  };\n\n  lodepng::State state;\n  state.decoder.zlibsettings.custom_zlib = TestFun::custom_zlib;\n  state.decoder.zlibsettings.custom_context = &customcontext;\n  state.decoder.zlibsettings.ignore_adler32 = 0;\n  state.decoder.ignore_crc = 0;\n  custom_proof = 0;\n  unsigned error = lodepng::decode(decoded, w, h, state, encoded);\n  ASSERT_EQUALS(1, custom_proof); // check that the custom zlib was called\n\n  ASSERT_EQUALS(110, error);\n}\n\nvoid testCustomInflate() {\n  std::cout << \"testCustomInflate\" << std::endl;\n  Image image;\n  generateTestImage(image, 5, 5, LCT_RGBA, 8);\n\n  std::vector<unsigned char> encoded;\n\n  unsigned error_enc = lodepng::encode(encoded, image.data, image.width, image.height,\n                                   image.colorType, image.bitDepth);\n  ASSERT_NO_PNG_ERROR_MSG(error_enc, \"encoder error not expected\");\n\n\n  std::vector<unsigned char> decoded;\n  unsigned w, h;\n  int customcontext = 5;\n\n  struct TestFun {\n    static unsigned custom_inflate(unsigned char**, size_t*,\n                                   const unsigned char*, size_t,\n                                   const LodePNGDecompressSettings* settings) {\n      ASSERT_EQUALS(5, *(int*)(settings->custom_context));\n      custom_proof = 1;\n      return 5555; // return a custom error code, which will be converted to an error known to lodepng.\n    }\n  };\n\n  lodepng::State state;\n  state.decoder.zlibsettings.custom_inflate = TestFun::custom_inflate;\n  state.decoder.zlibsettings.custom_context = &customcontext;\n  state.decoder.zlibsettings.ignore_adler32 = 0;\n  state.decoder.ignore_crc = 0;\n  custom_proof = 0;\n  unsigned error = lodepng::decode(decoded, w, h, state, encoded);\n  ASSERT_EQUALS(1, custom_proof); // check that the custom zlib was called\n\n  ASSERT_EQUALS(110, error);\n}\n\n\nvoid testChunkUtil() {\n  std::cout << \"testChunkUtil\" << std::endl;\n  std::vector<unsigned char> png;\n  createComplexPNG(png);\n\n  std::vector<std::string> names[3];\n  std::vector<std::vector<unsigned char> > chunks[3];\n\n  assertNoError(lodepng::getChunks(names, chunks, png));\n\n  std::vector<std::vector<unsigned char> > chunks2[3];\n  chunks2[0].push_back(chunks[2][2]); //zTXt\n  chunks2[1].push_back(chunks[2][3]); //tEXt\n  chunks2[2].push_back(chunks[2][4]); //iTXt\n\n  assertNoError(lodepng::insertChunks(png, chunks2));\n\n  std::string chunknames = extractChunkNames(png);\n  //                                        chunks2[0]                    chunks2[1]                                   chunks2[2]\n  //                                             v                             v                                            v\n  std::string expectednames = \" IHDR uNKa uNKa zTXt PLTE tRNS bKGD pHYs uNKb tEXt IDAT tIME zTXt zTXt tEXt iTXt iTXt uNKc iTXt IEND\";\n  ASSERT_EQUALS(expectednames, chunknames);\n\n  std::vector<unsigned char> image;\n  unsigned w, h;\n  ASSERT_NO_PNG_ERROR(lodepng::decode(image, w, h, png));\n}\n\n//Test that when decoding to 16-bit per channel, it always uses big endian consistently.\n//It should always output big endian, the convention used inside of PNG, even though x86 CPU's are little endian.\nvoid test16bitColorEndianness() {\n  std::cout << \"test16bitColorEndianness\" << std::endl;\n\n  //basn0g16.png from the PNG test suite\n  std::string base64 = \"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAAYagMeiWXwAAAF5JREFU\"\n                       \"eJzV0jEKwDAMQ1E5W+9/xtygk8AoezLVKgSj2Y8/OICnuFcTE2OgOoJgHQiZAN2C9kDKBOgW3AZC\"\n                       \"JkC3oD2QMgG6BbeBkAnQLWgPpExgP28H7E/0GTjPfwAW2EvYX64rn9cAAAAASUVORK5CYII=\";\n  std::vector<unsigned char> png;\n  fromBase64(png, base64);\n  unsigned w, h;\n  std::vector<unsigned char> image;\n  lodepng::State state;\n\n  // Decode from 16-bit gray image to 16-bit per channel RGBA\n  state.info_raw.bitdepth = 16;\n  ASSERT_NO_PNG_ERROR(lodepng::decode(image, w, h, state, png));\n  ASSERT_EQUALS(0x09, image[8]);\n  ASSERT_EQUALS(0x00, image[9]);\n\n  // Decode from 16-bit gray image to 16-bit gray raw image (no conversion)\n  image.clear();\n  state = lodepng::State();\n  state.decoder.color_convert = false;\n  ASSERT_NO_PNG_ERROR(lodepng::decode(image, w, h, state, png));\n  ASSERT_EQUALS(0x09, image[2]);\n  ASSERT_EQUALS(0x00, image[3]);\n\n  // Decode from 16-bit per channel RGB image to 16-bit per channel RGBA\n  base64 = \"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAIAAACsiDHgAAAABGdBTUEAAYagMeiWXwAAAANzQklU\"\n           \"DQ0N0DeNwQAAAH5JREFUeJztl8ENxEAIAwcJ6cpI+q8qKeNepAgelq2dCjz4AdQM1jRcf3WIDQ13\"\n           \"qUNsiBBQZ1gR0cARUFIz3pug3586wo5+rOcfIaBOsCSggSOgpcB8D4D3R9DgfUyECIhDbAhp4Ajo\"\n           \"KPD+CBq8P4IG72MiQkCdYUVEA0dAyQcwUyZpXH92ZwAAAABJRU5ErkJggg==\"; //cs3n2c16.png\n  png.clear();\n  fromBase64(png, base64);\n  image.clear();\n  state = lodepng::State();\n  state.info_raw.bitdepth = 16;\n  ASSERT_NO_PNG_ERROR(lodepng::decode(image, w, h, state, png));\n  ASSERT_EQUALS(0x1f, image[258]);\n  ASSERT_EQUALS(0xf9, image[259]);\n\n  // Decode from 16-bit per channel RGB image to 16-bit per channel RGBA raw image (no conversion)\n  image.clear();\n  state = lodepng::State();\n  state.decoder.color_convert = false;\n  ASSERT_NO_PNG_ERROR(lodepng::decode(image, w, h, state, png));\n\n  ASSERT_EQUALS(0x1f, image[194]);\n  ASSERT_EQUALS(0xf9, image[195]);\n\n  image.clear();\n  state = lodepng::State();\n\n  // Decode from palette image to 16-bit per channel RGBA\n  base64 = \"iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHAgMAAAC5PL9AAAAABGdBTUEAAYagMeiWXwAAAANzQklU\"\n           \"BAQEd/i1owAAAAxQTFRF/wB3AP93//8AAAD/G0OznAAAABpJREFUeJxj+P+H4WoMw605DDfmgEgg\"\n           \"+/8fAHF5CrkeXW0HAAAAAElFTkSuQmCC\"; //s07n3p02.png\n  png.clear();\n  fromBase64(png, base64);\n  image.clear();\n  state = lodepng::State();\n  state.info_raw.bitdepth = 16;\n  ASSERT_NO_PNG_ERROR(lodepng::decode(image, w, h, state, png));\n  ASSERT_EQUALS(0x77, image[84]);\n  ASSERT_EQUALS(0x77, image[85]);\n}\n\nvoid testPredefinedFilters() {\n  size_t w = 32, h = 32;\n  std::cout << \"testPredefinedFilters\" << std::endl;\n  Image image;\n  generateTestImage(image, w, h, LCT_RGBA, 8);\n\n  // everything to filter type '3'\n  std::vector<unsigned char> predefined(h, 3);\n  lodepng::State state;\n  state.encoder.filter_strategy = LFS_PREDEFINED;\n  state.encoder.filter_palette_zero = 0;\n  state.encoder.predefined_filters = &predefined[0];\n\n  std::vector<unsigned char> png;\n  unsigned error = lodepng::encode(png, &image.data[0], w, h, state);\n  assertNoError(error);\n\n  std::vector<unsigned char> outfilters;\n  error = lodepng::getFilterTypes(outfilters, png);\n  assertNoError(error);\n\n  ASSERT_EQUALS(outfilters.size(), h);\n  for(size_t i = 0; i < h; i++) ASSERT_EQUALS(3, outfilters[i]);\n}\n\nvoid testEncoderErrors() {\n  std::cout << \"testEncoderErrors\" << std::endl;\n\n  std::vector<unsigned char> png;\n  unsigned w = 32, h = 32;\n  Image image;\n  generateTestImage(image, w, h);\n\n  lodepng::State def;\n\n  lodepng::State state;\n\n  ASSERT_EQUALS(0, lodepng::encode(png, &image.data[0], w, h, state));\n\n  // test window sizes\n  state.encoder.zlibsettings.windowsize = 0;\n  ASSERT_EQUALS(60, lodepng::encode(png, &image.data[0], w, h, state));\n  state.encoder.zlibsettings.windowsize = 65536;\n  ASSERT_EQUALS(60, lodepng::encode(png, &image.data[0], w, h, state));\n  state.encoder.zlibsettings.windowsize = 1000; // not power of two\n  ASSERT_EQUALS(90, lodepng::encode(png, &image.data[0], w, h, state));\n  state.encoder.zlibsettings.windowsize = 256;\n  ASSERT_EQUALS(0, lodepng::encode(png, &image.data[0], w, h, state));\n\n  state = def;\n  state.info_png.color.bitdepth = 3;\n  ASSERT_EQUALS(37, lodepng::encode(png, &image.data[0], w, h, state));\n\n  state = def;\n  state.info_png.color.colortype = (LodePNGColorType)5;\n  ASSERT_EQUALS(31, lodepng::encode(png, &image.data[0], w, h, state));\n\n  state = def;\n  state.info_png.color.colortype = LCT_PALETTE;\n  ASSERT_EQUALS(68, lodepng::encode(png, &image.data[0], w, h, state));\n\n  state = def;\n  state.info_png.interlace_method = 0;\n  ASSERT_EQUALS(0, lodepng::encode(png, &image.data[0], w, h, state));\n  state.info_png.interlace_method = 1;\n  ASSERT_EQUALS(0, lodepng::encode(png, &image.data[0], w, h, state));\n  state.info_png.interlace_method = 2;\n  ASSERT_EQUALS(71, lodepng::encode(png, &image.data[0], w, h, state));\n\n  state = def;\n  state.encoder.zlibsettings.btype = 0;\n  ASSERT_EQUALS(0, lodepng::encode(png, &image.data[0], w, h, state));\n  state.encoder.zlibsettings.btype = 1;\n  ASSERT_EQUALS(0, lodepng::encode(png, &image.data[0], w, h, state));\n  state.encoder.zlibsettings.btype = 2;\n  ASSERT_EQUALS(0, lodepng::encode(png, &image.data[0], w, h, state));\n  state.encoder.zlibsettings.btype = 3;\n  ASSERT_EQUALS(61, lodepng::encode(png, &image.data[0], w, h, state));\n}\n\nvoid addColor(std::vector<unsigned char>& colors, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n  colors.push_back(r);\n  colors.push_back(g);\n  colors.push_back(b);\n  colors.push_back(a);\n}\n\nvoid addColor16(std::vector<unsigned char>& colors, unsigned short r, unsigned short g, unsigned short b, unsigned short a) {\n  colors.push_back(r & 255);\n  colors.push_back((r >> 8) & 255);\n  colors.push_back(g & 255);\n  colors.push_back((g >> 8) & 255);\n  colors.push_back(b & 255);\n  colors.push_back((b >> 8) & 255);\n  colors.push_back(a & 255);\n  colors.push_back((a >> 8) & 255);\n}\n\n// Tests auto_convert\n// colors is in RGBA, inbitdepth must be 8 or 16, the amount of bits per channel.\n// colortype and bitdepth are the expected values. insize is amount of pixels. So the amount of bytes is insize * 4 * (inbitdepth / 8)\nvoid testAutoColorModel(const std::vector<unsigned char>& colors, unsigned inbitdepth, LodePNGColorType colortype, unsigned bitdepth, bool key) {\n  std::cout << \"testAutoColorModel \" << inbitdepth << \" \" << colortype << \" \" << bitdepth << \" \" << key << std::endl;\n  size_t innum = colors.size() / 4 * inbitdepth / 8;\n  size_t num = innum < 65536 ? 65536 : innum; // Make image bigger so the convert doesn't avoid palette due to small image.\n  std::vector<unsigned char> colors2(num * 4 * (inbitdepth / 8));\n  for(size_t i = 0; i < colors2.size(); i++) colors2[i] = colors[i % colors.size()];\n\n  std::vector<unsigned char> png;\n  lodepng::encode(png, colors2, num, 1, LCT_RGBA, inbitdepth);\n\n  // now extract the color type it chose\n  unsigned w, h;\n  lodepng::State state;\n  std::vector<unsigned char> decoded;\n  lodepng::decode(decoded, w, h, state, png);\n  ASSERT_EQUALS(num, w);\n  ASSERT_EQUALS(1, h);\n  ASSERT_EQUALS(colortype, state.info_png.color.colortype);\n  ASSERT_EQUALS(bitdepth, state.info_png.color.bitdepth);\n  ASSERT_EQUALS(key, state.info_png.color.key_defined);\n  // also check that the PNG decoded correctly and has same colors as input\n  if(inbitdepth == 8) { for(size_t i = 0; i < colors.size(); i++) ASSERT_EQUALS(colors[i], decoded[i]); }\n  else { for(size_t i = 0; i < colors.size() / 2; i++) ASSERT_EQUALS(colors[i * 2], decoded[i]); }\n}\n\nvoid testAutoColorModels() {\n  // 1-bit gray\n  std::vector<unsigned char> gray1;\n  for(size_t i = 0; i < 2; i++) addColor(gray1, i * 255, i * 255, i * 255, 255);\n  testAutoColorModel(gray1, 8, LCT_GREY, 1, false);\n\n  // 2-bit gray\n  std::vector<unsigned char> gray2;\n  for(size_t i = 0; i < 4; i++) addColor(gray2, i * 85, i * 85, i * 85, 255);\n  testAutoColorModel(gray2, 8, LCT_GREY, 2, false);\n\n  // 4-bit gray\n  std::vector<unsigned char> gray4;\n  for(size_t i = 0; i < 16; i++) addColor(gray4, i * 17, i * 17, i * 17, 255);\n  testAutoColorModel(gray4, 8, LCT_GREY, 4, false);\n\n  // 8-bit gray\n  std::vector<unsigned char> gray8;\n  for(size_t i = 0; i < 256; i++) addColor(gray8, i, i, i, 255);\n  testAutoColorModel(gray8, 8, LCT_GREY, 8, false);\n\n  // 16-bit gray\n  std::vector<unsigned char> gray16;\n  for(size_t i = 0; i < 257; i++) addColor16(gray16, i, i, i, 65535);\n  testAutoColorModel(gray16, 16, LCT_GREY, 16, false);\n\n  // 8-bit gray+alpha\n  std::vector<unsigned char> gray8a;\n  for(size_t i = 0; i < 17; i++) addColor(gray8a, i, i, i, i);\n  testAutoColorModel(gray8a, 8, LCT_PALETTE, 8, false);\n  // palette not possible, becomes gray alpha\n  for(size_t i = 0; i < 256; i++) addColor(gray8a, i, i, i, i ^ 1);\n  testAutoColorModel(gray8a, 8, LCT_GREY_ALPHA, 8, false);\n\n  // 16-bit gray+alpha\n  std::vector<unsigned char> gray16a;\n  for(size_t i = 0; i < 257; i++) addColor16(gray16a, i, i, i, i);\n  testAutoColorModel(gray16a, 16, LCT_GREY_ALPHA, 16, false);\n\n\n  // various palette tests\n  std::vector<unsigned char> palette;\n  addColor(palette, 0, 0, 1, 255);\n  testAutoColorModel(palette, 8, LCT_PALETTE, 1, false);\n  addColor(palette, 0, 0, 2, 255);\n  testAutoColorModel(palette, 8, LCT_PALETTE, 1, false);\n  for(int i = 3; i <= 4; i++) addColor(palette, 0, 0, i, 255);\n  testAutoColorModel(palette, 8, LCT_PALETTE, 2, false);\n  for(int i = 5; i <= 7; i++) addColor(palette, 0, 0, i, 255);\n  testAutoColorModel(palette, 8, LCT_PALETTE, 4, false);\n  for(int i = 8; i <= 17; i++) addColor(palette, 0, 0, i, 255);\n  testAutoColorModel(palette, 8, LCT_PALETTE, 8, false);\n  addColor(palette, 0, 0, 18, 0); // transparent\n  testAutoColorModel(palette, 8, LCT_PALETTE, 8, false);\n  addColor(palette, 0, 0, 18, 1); // translucent\n  testAutoColorModel(palette, 8, LCT_PALETTE, 8, false);\n\n  // 1-bit gray + alpha not possible, becomes palette\n  std::vector<unsigned char> gray1a;\n  for(size_t i = 0; i < 2; i++) addColor(gray1a, i, i, i, 128);\n  testAutoColorModel(gray1a, 8, LCT_PALETTE, 1, false);\n\n  // 2-bit gray + alpha not possible, becomes palette\n  std::vector<unsigned char> gray2a;\n  for(size_t i = 0; i < 4; i++) addColor(gray2a, i, i, i, 128);\n  testAutoColorModel(gray2a, 8, LCT_PALETTE, 2, false);\n\n  // 4-bit gray + alpha not possible, becomes palette\n  std::vector<unsigned char> gray4a;\n  for(size_t i = 0; i < 16; i++) addColor(gray4a, i, i, i, 128);\n  testAutoColorModel(gray4a, 8, LCT_PALETTE, 4, false);\n\n  // 8-bit rgb\n  std::vector<unsigned char> rgb = gray8;\n  addColor(rgb, 255, 0, 0, 255);\n  testAutoColorModel(rgb, 8, LCT_RGB, 8, false);\n\n  // 8-bit rgb + key\n  std::vector<unsigned char> rgb_key = rgb;\n  addColor(rgb_key, 128, 0, 0, 0);\n  testAutoColorModel(rgb_key, 8, LCT_RGB, 8, true);\n\n  // 8-bit rgb, not key due to edge case: single key color, but opaque color has same RGB value\n  std::vector<unsigned char> rgb_key2 = rgb_key;\n  addColor(rgb_key2, 128, 0, 0, 255); // same color but opaque ==> no more key\n  testAutoColorModel(rgb_key2, 8, LCT_RGBA, 8, false);\n\n  // 8-bit rgb, not key due to semi translucent\n  std::vector<unsigned char> rgb_key3 = rgb_key;\n  addColor(rgb_key3, 128, 0, 0, 255); // semi-translucent ==> no more key\n  testAutoColorModel(rgb_key3, 8, LCT_RGBA, 8, false);\n\n  // 8-bit rgb, not key due to multiple transparent colors\n  std::vector<unsigned char> rgb_key4 = rgb_key;\n  addColor(rgb_key4, 128, 0, 0, 255);\n  addColor(rgb_key4, 129, 0, 0, 255); // two different transparent colors ==> no more key\n  testAutoColorModel(rgb_key4, 8, LCT_RGBA, 8, false);\n\n  // 1-bit gray with key\n  std::vector<unsigned char> gray1_key = gray1;\n  gray1_key[7] = 0;\n  testAutoColorModel(gray1_key, 8, LCT_GREY, 1, true);\n\n  // 2-bit gray with key\n  std::vector<unsigned char> gray2_key = gray2;\n  gray2_key[7] = 0;\n  testAutoColorModel(gray2_key, 8, LCT_GREY, 2, true);\n\n  // 4-bit gray with key\n  std::vector<unsigned char> gray4_key = gray4;\n  gray4_key[7] = 0;\n  testAutoColorModel(gray4_key, 8, LCT_GREY, 4, true);\n\n  // 8-bit gray with key\n  std::vector<unsigned char> gray8_key = gray8;\n  gray8_key[7] = 0;\n  testAutoColorModel(gray8_key, 8, LCT_GREY, 8, true);\n\n  // 16-bit gray with key\n  std::vector<unsigned char> gray16_key = gray16;\n  gray16_key[14] = gray16_key[15] = 0;\n  testAutoColorModel(gray16_key, 16, LCT_GREY, 16, true);\n\n  // a single 16-bit color, can't become palette due to being 16-bit\n  std::vector<unsigned char> small16;\n  addColor16(small16, 1, 0, 0, 65535);\n  testAutoColorModel(small16, 16, LCT_RGB, 16, false);\n\n  std::vector<unsigned char> small16a;\n  addColor16(small16a, 1, 0, 0, 1);\n  testAutoColorModel(small16a, 16, LCT_RGBA, 16, false);\n\n  // what we provide as 16-bit is actually representable as 8-bit, so 8-bit palette expected for single color\n  std::vector<unsigned char> not16;\n  addColor16(not16, 257, 257, 257, 0);\n  testAutoColorModel(not16, 16, LCT_PALETTE, 1, false);\n\n  // the rgb color is representable as 8-bit, but the alpha channel only as 16-bit, so ensure it uses 16-bit and not palette for this single color\n  std::vector<unsigned char> alpha16;\n  addColor16(alpha16, 257, 0, 0, 10000);\n  testAutoColorModel(alpha16, 16, LCT_RGBA, 16, false);\n\n  // 1-bit gray, with attempt to get color key but can't do it due to opaque color with same value\n  std::vector<unsigned char> gray1k;\n  addColor(gray1k, 0, 0, 0, 255);\n  addColor(gray1k, 255, 255, 255, 255);\n  addColor(gray1k, 255, 255, 255, 0);\n  testAutoColorModel(gray1k, 8, LCT_PALETTE, 2, false);\n}\n\nvoid testPaletteToPaletteDecode() {\n  std::cout << \"testPaletteToPaletteDecode\" << std::endl;\n  // It's a bit big for a 2x2 image... but this tests needs one with 256 palette entries in it.\n  std::string base64 = \"iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAMAAABFaP0WAAAAA3NCSVQICAjb4U/gAAADAFBMVEUA\"\n                       \"AAAAADMAAGYAAJkAAMwAAP8AMwAAMzMAM2YAM5kAM8wAM/8AZgAAZjMAZmYAZpkAZswAZv8AmQAA\"\n                       \"mTMAmWYAmZkAmcwAmf8AzAAAzDMAzGYAzJkAzMwAzP8A/wAA/zMA/2YA/5kA/8wA//8zAAAzADMz\"\n                       \"AGYzAJkzAMwzAP8zMwAzMzMzM2YzM5kzM8wzM/8zZgAzZjMzZmYzZpkzZswzZv8zmQAzmTMzmWYz\"\n                       \"mZkzmcwzmf8zzAAzzDMzzGYzzJkzzMwzzP8z/wAz/zMz/2Yz/5kz/8wz//9mAABmADNmAGZmAJlm\"\n                       \"AMxmAP9mMwBmMzNmM2ZmM5lmM8xmM/9mZgBmZjNmZmZmZplmZsxmZv9mmQBmmTNmmWZmmZlmmcxm\"\n                       \"mf9mzABmzDNmzGZmzJlmzMxmzP9m/wBm/zNm/2Zm/5lm/8xm//+ZAACZADOZAGaZAJmZAMyZAP+Z\"\n                       \"MwCZMzOZM2aZM5mZM8yZM/+ZZgCZZjOZZmaZZpmZZsyZZv+ZmQCZmTOZmWaZmZmZmcyZmf+ZzACZ\"\n                       \"zDOZzGaZzJmZzMyZzP+Z/wCZ/zOZ/2aZ/5mZ/8yZ///MAADMADPMAGbMAJnMAMzMAP/MMwDMMzPM\"\n                       \"M2bMM5nMM8zMM//MZgDMZjPMZmbMZpnMZszMZv/MmQDMmTPMmWbMmZnMmczMmf/MzADMzDPMzGbM\"\n                       \"zJnMzMzMzP/M/wDM/zPM/2bM/5nM/8zM////AAD/ADP/AGb/AJn/AMz/AP//MwD/MzP/M2b/M5n/\"\n                       \"M8z/M///ZgD/ZjP/Zmb/Zpn/Zsz/Zv//mQD/mTP/mWb/mZn/mcz/mf//zAD/zDP/zGb/zJn/zMz/\"\n                       \"zP///wD//zP//2b//5n//8z///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n                       \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n                       \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlenwdAAABAHRSTlP/////////////////////////\"\n                       \"////////////////////////////////////////////////////////////////////////////\"\n                       \"////////////////////////////////////////////////////////////////////////////\"\n                       \"////////////////////////////////////////////////////////////////////////////\"\n                       \"//////////////////////////////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n                       \"AAAAAAAAAAAAG8mZagAAAAlwSFlzAAAOTQAADpwB3vacVwAAAA5JREFUCJlj2CLHwHodAATjAa+k\"\n                       \"lTE5AAAAAElFTkSuQmCC\";\n  std::vector<unsigned char> png;\n  fromBase64(png, base64);\n\n  std::vector<unsigned char> image;\n  unsigned width, height;\n  unsigned error = lodepng::decode(image, width, height, png, LCT_PALETTE, 8);\n  ASSERT_EQUALS(0, error);\n  ASSERT_EQUALS(2, width);\n  ASSERT_EQUALS(2, height);\n  ASSERT_EQUALS(180, image[0]);\n  ASSERT_EQUALS(30, image[1]);\n  ASSERT_EQUALS(5, image[2]);\n  ASSERT_EQUALS(215, image[3]);\n}\n\n//2-bit palette\nvoid testPaletteToPaletteDecode2() {\n  std::cout << \"testPaletteToPaletteDecode2\" << std::endl;\n  std::string base64 = \"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAgMAAAAOFJJnAAAADFBMVEX/AAAA/wAAAP/////7AGD2AAAAE0lEQVR4AWMQhAKG3VCALDIqAgDl2WYBCQHY9gAAAABJRU5ErkJggg==\";\n  std::vector<unsigned char> png;\n  fromBase64(png, base64);\n\n  std::vector<unsigned char> image;\n  unsigned width, height;\n  unsigned error = lodepng::decode(image, width, height, png, LCT_PALETTE, 8);\n  ASSERT_EQUALS(0, error);\n  ASSERT_EQUALS(32, width);\n  ASSERT_EQUALS(32, height);\n  ASSERT_EQUALS(0, image[0]);\n  ASSERT_EQUALS(1, image[1]);\n\n  //Now add a user-specified output palette, that differs from the input palette. That should give error 82.\n  LodePNGState state;\n  lodepng_state_init(&state);\n  state.info_raw.colortype = LCT_PALETTE;\n  state.info_raw.bitdepth = 8;\n  lodepng_palette_add(&state.info_raw, 0, 0, 0, 255);\n  lodepng_palette_add(&state.info_raw, 1, 1, 1, 255);\n  lodepng_palette_add(&state.info_raw, 2, 2, 2, 255);\n  lodepng_palette_add(&state.info_raw, 3, 3, 3, 255);\n  unsigned char* image2 = 0;\n  unsigned error2 = lodepng_decode(&image2, &width, &height, &state, &png[0], png.size());\n  lodepng_state_cleanup(&state);\n  ASSERT_EQUALS(82, error2);\n  free(image2);\n}\n\nvoid assertColorProfileDataEqual(const lodepng::State& a, const lodepng::State& b) {\n  ASSERT_EQUALS(a.info_png.gama_defined, b.info_png.gama_defined);\n  if(a.info_png.gama_defined) {\n    ASSERT_EQUALS(a.info_png.gama_gamma, b.info_png.gama_gamma);\n  }\n\n  ASSERT_EQUALS(a.info_png.chrm_defined, b.info_png.chrm_defined);\n  if(a.info_png.chrm_defined) {\n    ASSERT_EQUALS(a.info_png.chrm_white_x, b.info_png.chrm_white_x);\n    ASSERT_EQUALS(a.info_png.chrm_white_y, b.info_png.chrm_white_y);\n    ASSERT_EQUALS(a.info_png.chrm_red_x, b.info_png.chrm_red_x);\n    ASSERT_EQUALS(a.info_png.chrm_red_y, b.info_png.chrm_red_y);\n    ASSERT_EQUALS(a.info_png.chrm_green_x, b.info_png.chrm_green_x);\n    ASSERT_EQUALS(a.info_png.chrm_green_y, b.info_png.chrm_green_y);\n    ASSERT_EQUALS(a.info_png.chrm_blue_x, b.info_png.chrm_blue_x);\n    ASSERT_EQUALS(a.info_png.chrm_blue_y, b.info_png.chrm_blue_y);\n  }\n\n  ASSERT_EQUALS(a.info_png.srgb_defined, b.info_png.srgb_defined);\n  if(a.info_png.srgb_defined) {\n    ASSERT_EQUALS(a.info_png.srgb_intent, b.info_png.srgb_intent);\n  }\n\n  ASSERT_EQUALS(a.info_png.cicp_defined, b.info_png.cicp_defined);\n  if(a.info_png.cicp_defined) {\n    ASSERT_EQUALS(a.info_png.cicp_color_primaries, b.info_png.cicp_color_primaries);\n    ASSERT_EQUALS(a.info_png.cicp_transfer_function, b.info_png.cicp_transfer_function);\n    ASSERT_EQUALS(a.info_png.cicp_matrix_coefficients, b.info_png.cicp_matrix_coefficients);\n    ASSERT_EQUALS(a.info_png.cicp_video_full_range_flag, b.info_png.cicp_video_full_range_flag);\n  }\n\n  ASSERT_EQUALS(a.info_png.mdcv_defined, b.info_png.mdcv_defined);\n  if(a.info_png.mdcv_defined) {\n    ASSERT_EQUALS(a.info_png.mdcv_red_x, b.info_png.mdcv_red_x);\n    ASSERT_EQUALS(a.info_png.mdcv_red_y, b.info_png.mdcv_red_y);\n    ASSERT_EQUALS(a.info_png.mdcv_green_x, b.info_png.mdcv_green_x);\n    ASSERT_EQUALS(a.info_png.mdcv_green_y, b.info_png.mdcv_green_y);\n    ASSERT_EQUALS(a.info_png.mdcv_blue_x, b.info_png.mdcv_blue_x);\n    ASSERT_EQUALS(a.info_png.mdcv_blue_y, b.info_png.mdcv_blue_y);\n    ASSERT_EQUALS(a.info_png.mdcv_white_x, b.info_png.mdcv_white_x);\n    ASSERT_EQUALS(a.info_png.mdcv_white_y, b.info_png.mdcv_white_y);\n    ASSERT_EQUALS(a.info_png.mdcv_max_luminance, b.info_png.mdcv_max_luminance);\n    ASSERT_EQUALS(a.info_png.mdcv_min_luminance, b.info_png.mdcv_min_luminance);\n  }\n\n  ASSERT_EQUALS(a.info_png.clli_defined, b.info_png.clli_defined);\n  if(a.info_png.clli_defined) {\n    ASSERT_EQUALS(a.info_png.clli_max_cll, b.info_png.clli_max_cll);\n    ASSERT_EQUALS(a.info_png.clli_max_fall, b.info_png.clli_max_fall);\n  }\n\n  ASSERT_EQUALS(a.info_png.iccp_defined, b.info_png.iccp_defined);\n  if(a.info_png.iccp_defined) {\n    //ASSERT_EQUALS(std::string(a.info_png.iccp_name), std::string(b.info_png.iccp_name));\n    ASSERT_EQUALS(a.info_png.iccp_profile_size, b.info_png.iccp_profile_size);\n    for(size_t i = 0; i < a.info_png.iccp_profile_size; ++i) {\n      ASSERT_EQUALS(a.info_png.iccp_profile[i], b.info_png.iccp_profile[i]);\n    }\n  }\n}\n\n// Tests the gAMA, cHRM, sRGB, iCCP chunks\nvoid testColorProfile() {\n  std::cout << \"testColorProfile\" << std::endl;\n  {\n    unsigned error;\n    unsigned w = 32, h = 32;\n    std::vector<unsigned char> image(w * h * 4);\n    for(size_t i = 0; i < image.size(); i++) image[i] = i & 255;\n    std::vector<unsigned char> png;\n    lodepng::State state;\n    state.info_png.gama_defined = 1;\n    state.info_png.gama_gamma = 12345;\n    state.info_png.chrm_defined = 1;\n    state.info_png.chrm_white_x = 10;\n    state.info_png.chrm_white_y = 20;\n    state.info_png.chrm_red_x = 30;\n    state.info_png.chrm_red_y = 40;\n    state.info_png.chrm_green_x = 100000;\n    state.info_png.chrm_green_y = 200000;\n    state.info_png.chrm_blue_x = 300000;\n    state.info_png.chrm_blue_y = 400000;\n    error = lodepng::encode(png, &image[0], w, h, state);\n    ASSERT_NO_PNG_ERROR(error);\n\n    lodepng::State state2;\n    std::vector<unsigned char> image2;\n    error = lodepng::decode(image2, w, h, state2, png);\n    ASSERT_NO_PNG_ERROR(error);\n    assertColorProfileDataEqual(state, state2);\n    ASSERT_EQUALS(32, w);\n    ASSERT_EQUALS(32, h);\n    ASSERT_EQUALS(image.size(), image2.size());\n    for(size_t i = 0; i < image.size(); i++) ASSERT_EQUALS(image[i], image2[i]);\n  }\n  {\n    unsigned error;\n    unsigned w = 32, h = 32;\n    std::vector<unsigned char> image(w * h * 4);\n    for(size_t i = 0; i < image.size(); i++) image[i] = i & 255;\n    std::vector<unsigned char> png;\n    lodepng::State state;\n    state.info_png.srgb_defined = 1;\n    state.info_png.srgb_intent = 2;\n    error = lodepng::encode(png, &image[0], w, h, state);\n    ASSERT_NO_PNG_ERROR(error);\n\n    lodepng::State state2;\n    std::vector<unsigned char> image2;\n    error = lodepng::decode(image2, w, h, state2, png);\n    ASSERT_NO_PNG_ERROR(error);\n    assertColorProfileDataEqual(state, state2);\n    ASSERT_EQUALS(32, w);\n    ASSERT_EQUALS(32, h);\n    ASSERT_EQUALS(image.size(), image2.size());\n    for(size_t i = 0; i < image.size(); i++) ASSERT_EQUALS(image[i], image2[i]);\n  }\n  {\n    unsigned error;\n    unsigned w = 32, h = 32;\n    std::vector<unsigned char> image(w * h * 4);\n    for(size_t i = 0; i < image.size(); i++) image[i] = i & 255;\n    std::vector<unsigned char> png;\n    lodepng::State state;\n    state.info_png.cicp_defined = 1;\n    state.info_png.cicp_color_primaries = 4;\n    state.info_png.cicp_transfer_function = 3;\n    state.info_png.cicp_matrix_coefficients = 2;\n    state.info_png.cicp_video_full_range_flag = 1;\n    error = lodepng::encode(png, &image[0], w, h, state);\n    ASSERT_NO_PNG_ERROR(error);\n\n    lodepng::State state2;\n    std::vector<unsigned char> image2;\n    error = lodepng::decode(image2, w, h, state2, png);\n    ASSERT_NO_PNG_ERROR(error);\n    assertColorProfileDataEqual(state, state2);\n    ASSERT_EQUALS(32, w);\n    ASSERT_EQUALS(32, h);\n    ASSERT_EQUALS(image.size(), image2.size());\n    for(size_t i = 0; i < image.size(); i++) ASSERT_EQUALS(image[i], image2[i]);\n  }\n  {\n    unsigned error;\n    unsigned w = 32, h = 32;\n    std::vector<unsigned char> image(w * h * 4);\n    for(size_t i = 0; i < image.size(); i++) image[i] = i & 255;\n    std::vector<unsigned char> png;\n    lodepng::State state;\n    state.info_png.mdcv_defined = 1;\n    state.info_png.mdcv_red_x = 2;\n    state.info_png.mdcv_red_y = 3;\n    state.info_png.mdcv_green_x = 4;\n    state.info_png.mdcv_green_y = 5;\n    state.info_png.mdcv_blue_x = 6;\n    state.info_png.mdcv_blue_y = 7;\n    state.info_png.mdcv_white_x = 8;\n    state.info_png.mdcv_white_y = 9;\n    state.info_png.mdcv_max_luminance = 10;\n    state.info_png.mdcv_min_luminance = 11;\n    error = lodepng::encode(png, &image[0], w, h, state);\n    ASSERT_NO_PNG_ERROR(error);\n\n    lodepng::State state2;\n    std::vector<unsigned char> image2;\n    error = lodepng::decode(image2, w, h, state2, png);\n    ASSERT_NO_PNG_ERROR(error);\n    assertColorProfileDataEqual(state, state2);\n    ASSERT_EQUALS(32, w);\n    ASSERT_EQUALS(32, h);\n    ASSERT_EQUALS(image.size(), image2.size());\n    for(size_t i = 0; i < image.size(); i++) ASSERT_EQUALS(image[i], image2[i]);\n  }\n  {\n    unsigned error;\n    unsigned w = 32, h = 32;\n    std::vector<unsigned char> image(w * h * 4);\n    for(size_t i = 0; i < image.size(); i++) image[i] = i & 255;\n    std::vector<unsigned char> png;\n    lodepng::State state;\n    state.info_png.clli_defined = 1;\n    state.info_png.clli_max_cll = 2;\n    state.info_png.clli_max_fall = 3;\n    error = lodepng::encode(png, &image[0], w, h, state);\n    ASSERT_NO_PNG_ERROR(error);\n\n    lodepng::State state2;\n    std::vector<unsigned char> image2;\n    error = lodepng::decode(image2, w, h, state2, png);\n    ASSERT_NO_PNG_ERROR(error);\n    assertColorProfileDataEqual(state, state2);\n    ASSERT_EQUALS(32, w);\n    ASSERT_EQUALS(32, h);\n    ASSERT_EQUALS(image.size(), image2.size());\n    for(size_t i = 0; i < image.size(); i++) ASSERT_EQUALS(image[i], image2[i]);\n  }\n  {\n    unsigned error;\n    unsigned w = 32, h = 32;\n    std::vector<unsigned char> image(w * h * 4);\n    for(size_t i = 0; i < image.size(); i++) image[i] = i & 255;\n    std::vector<unsigned char> png;\n    lodepng::State state;\n    std::string testprofile = \"0123456789abcdefRGB fake iccp profile for testing\";\n    testprofile[0] = testprofile[1] = 0;\n    lodepng_set_icc(&state.info_png, \"test\", (const unsigned char*)testprofile.c_str(), testprofile.size());\n    error = lodepng::encode(png, &image[0], w, h, state);\n    ASSERT_NO_PNG_ERROR(error);\n\n    lodepng::State state2;\n    std::vector<unsigned char> image2;\n    error = lodepng::decode(image2, w, h, state2, png);\n    ASSERT_NO_PNG_ERROR(error);\n    assertColorProfileDataEqual(state, state2);\n    ASSERT_EQUALS(32, w);\n    ASSERT_EQUALS(32, h);\n    ASSERT_EQUALS(image.size(), image2.size());\n    for(size_t i = 0; i < image.size(); i++) ASSERT_EQUALS(image[i], image2[i]);\n  }\n\n  // grayscale ICC profile\n  {\n    unsigned error;\n    unsigned w = 32, h = 32;\n    std::vector<unsigned char> image(w * h * 4);\n    for(size_t i = 0; i + 4 <= image.size(); i += 4) {\n      image[i] = image[i + 1] = image[i + 2] = image[i + 3] = i;\n    }\n    std::vector<unsigned char> png;\n    lodepng::State state;\n    std::string testprofile = \"0123456789abcdefGRAYfake iccp profile for testing\";\n    testprofile[0] = testprofile[1] = 0;\n    lodepng_set_icc(&state.info_png, \"test\", (const unsigned char*)testprofile.c_str(), testprofile.size());\n    error = lodepng::encode(png, &image[0], w, h, state);\n    ASSERT_NO_PNG_ERROR(error);\n\n    lodepng::State state2;\n    std::vector<unsigned char> image2;\n    error = lodepng::decode(image2, w, h, state2, png);\n    ASSERT_NO_PNG_ERROR(error);\n    assertColorProfileDataEqual(state, state2);\n    ASSERT_EQUALS(32, w);\n    ASSERT_EQUALS(32, h);\n    ASSERT_EQUALS(image.size(), image2.size());\n    for(size_t i = 0; i < image.size(); i++) ASSERT_EQUALS(image[i], image2[i]);\n  }\n\n  // grayscale ICC profile, using an input image with grayscale colors but that\n  // would normally benefit from a palette (which auto_convert would normally\n  // choose). But the PNG spec does not allow combining palette with GRAY ICC\n  // profile, so the encoder should not choose to use palette after all.\n  {\n    unsigned error;\n    unsigned w = 32, h = 32;\n    std::vector<unsigned char> image(w * h * 4);\n    int colors[3] = {0, 3, 133};\n    for(size_t i = 0; i + 4 <= image.size(); i += 4) {\n      image[i] = image[i + 1] = image[i + 2] = image[i + 3] = colors[(i / 4) % 3];\n    }\n    std::vector<unsigned char> png;\n    lodepng::State state;\n    std::string testprofile = \"0123456789abcdefGRAYfake iccp profile for testing\";\n    testprofile[0] = testprofile[1] = 0;\n    lodepng_set_icc(&state.info_png, \"test\", (const unsigned char*)testprofile.c_str(), testprofile.size());\n    error = lodepng::encode(png, &image[0], w, h, state);\n    ASSERT_NO_PNG_ERROR(error);\n\n    lodepng::State state2;\n    std::vector<unsigned char> image2;\n    error = lodepng::decode(image2, w, h, state2, png);\n    ASSERT_NO_PNG_ERROR(error);\n    assertColorProfileDataEqual(state, state2);\n    ASSERT_NOT_EQUALS(LCT_PALETTE, state2.info_png.color.colortype);\n  }\n\n  // RGB ICC profile, using an input image with grayscale colors: the encoder\n  // is forced to choose an RGB color type anyway with auto_convert\n  {\n    unsigned error;\n    unsigned w = 32, h = 32;\n    std::vector<unsigned char> image(w * h * 4);\n    for(size_t i = 0; i + 4 <= image.size(); i += 4) {\n      image[i] = image[i + 1] = image[i + 2] = (i / 4) & 255;\n      image[i + 3] = 255;\n    }\n    std::vector<unsigned char> png;\n    lodepng::State state;\n    std::string testprofile = \"0123456789abcdefRGB fake iccp profile for testing\";\n    testprofile[0] = testprofile[1] = 0;\n    lodepng_set_icc(&state.info_png, \"test\", (const unsigned char*)testprofile.c_str(), testprofile.size());\n    error = lodepng::encode(png, &image[0], w, h, state);\n    ASSERT_NO_PNG_ERROR(error);\n\n    lodepng::State state2;\n    std::vector<unsigned char> image2;\n    error = lodepng::decode(image2, w, h, state2, png);\n    ASSERT_NO_PNG_ERROR(error);\n    assertColorProfileDataEqual(state, state2);\n    // LCT_RGB or LCT_PALETTE are both ok, gray is not (it likely chooses palette in practice)\n    ASSERT_NOT_EQUALS(LCT_GREY, state2.info_png.color.colortype);\n    ASSERT_NOT_EQUALS(LCT_GREY_ALPHA, state2.info_png.color.colortype);\n  }\n\n  // Encoder must give error when forcing invalid combination of color/gray\n  // PNG with gray/color ICC Profile\n  {\n    unsigned error;\n    unsigned w = 32, h = 32;\n    std::vector<unsigned char> image(w * h * 4);\n    int colors[3] = {0, 5, 33};\n    for(size_t i = 0; i + 4 <= image.size(); i += 4) {\n      image[i] = 255;\n      image[i + 1] = image[i + 2] = image[i + 3] = colors[(i / 4) % 3];\n    }\n    std::vector<unsigned char> png;\n    lodepng::State state;\n    std::string testprofile = \"0123456789abcdefGRAYfake iccp profile for testing\";\n    testprofile[0] = testprofile[1] = 0;\n    lodepng_set_icc(&state.info_png, \"test\", (const unsigned char*)testprofile.c_str(), testprofile.size());\n    error = lodepng::encode(png, &image[0], w, h, state);\n    ASSERT_NOT_EQUALS(0, error);  // must give error due to color image input with gray profile\n  }\n}\n\nvoid assertExifDataEqual(const lodepng::State& a, const lodepng::State& b) {\n  ASSERT_EQUALS(a.info_png.exif_defined, b.info_png.exif_defined);\n  if(!a.info_png.exif_defined) return;\n\n  ASSERT_EQUALS(a.info_png.exif_size, b.info_png.exif_size);\n  for(size_t i = 0; i < a.info_png.exif_size; i++) {\n    ASSERT_EQUALS(a.info_png.exif[i], b.info_png.exif[i]);\n  }\n}\n\nvoid testExif() {\n  std::cout << \"testExif\" << std::endl;\n\n  {\n    unsigned error;\n    unsigned w = 32, h = 32;\n    std::vector<unsigned char> image(w * h * 4);\n    for(size_t i = 0; i + 4 <= image.size(); i += 4) {\n      image[i] = image[i + 1] = image[i + 2] = image[i + 3] = i;\n    }\n    std::vector<unsigned char> png;\n    lodepng::State state;\n    std::string testexif = \"MM  0123456789\";\n    lodepng_set_exif(&state.info_png, (const unsigned char*)testexif.c_str(), testexif.size());\n    error = lodepng::encode(png, &image[0], w, h, state);\n    ASSERT_NO_PNG_ERROR(error);\n\n    lodepng::State state2;\n    std::vector<unsigned char> image2;\n    error = lodepng::decode(image2, w, h, state2, png);\n    ASSERT_NO_PNG_ERROR(error);\n    assertExifDataEqual(state, state2);\n    ASSERT_EQUALS(32, w);\n    ASSERT_EQUALS(32, h);\n    ASSERT_EQUALS(image.size(), image2.size());\n  }\n\n  {\n    // exif2c08.png PngSuite image\n    std::string base64 = \"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\";\n    std::vector<unsigned char> png;\n    fromBase64(png, base64);\n    lodepng::State state;\n    std::vector<unsigned char> image;\n    unsigned w, h;\n    unsigned error = lodepng::decode(image, w, h, state, png);\n    ASSERT_NO_PNG_ERROR(error);\n    ASSERT_EQUALS(978, state.info_png.exif_size);\n    ASSERT_EQUALS(\"072f0ad39affebf437689f935fab270c\", md5sum(state.info_png.exif, state.info_png.exif_size));\n  }\n}\n\n// r, g, b is input background color to encoder, given in png color model\n// r2, g2, b2 is expected decoded background color, in color model it auto chose if auto_convert is on\n// pixels must be given in mode_raw color format\nvoid testBkgdChunk(unsigned r, unsigned g, unsigned b,\n                   unsigned r2, unsigned g2, unsigned b2,\n                   const std::vector<unsigned char>& pixels,\n                   unsigned w, unsigned h,\n                   const LodePNGColorMode& mode_raw,\n                   const LodePNGColorMode& mode_png,\n                   bool auto_convert, bool expect_encoder_error = false) {\n  unsigned error;\n\n  lodepng::State state;\n  LodePNGInfo& info = state.info_png;\n  lodepng_color_mode_copy(&info.color, &mode_png);\n  lodepng_color_mode_copy(&state.info_raw, &mode_raw);\n  state.encoder.auto_convert = auto_convert;\n\n  info.background_defined = 1;\n  info.background_r = r;\n  info.background_g = g;\n  info.background_b = b;\n\n  std::vector<unsigned char> png;\n  error = lodepng::encode(png, pixels, w, h, state);\n  if(expect_encoder_error) {\n    ASSERT_NOT_EQUALS(0, error);\n    return;\n  }\n  ASSERT_NO_PNG_ERROR(error);\n\n  lodepng::State state2;\n  LodePNGInfo& info2 = state2.info_png;\n  state2.info_raw.colortype = LCT_RGBA;\n  state2.info_raw.bitdepth = 16;\n  unsigned w2, h2;\n  std::vector<unsigned char> image2;\n  error = lodepng::decode(image2, w2, h2, state2, &png[0], png.size());\n  ASSERT_NO_PNG_ERROR(error);\n\n  ASSERT_EQUALS(w, w2);\n  ASSERT_EQUALS(h, h2);\n  ASSERT_EQUALS(1, info2.background_defined);\n  ASSERT_EQUALS(r2, info2.background_r);\n  ASSERT_EQUALS(g2, info2.background_g);\n  ASSERT_EQUALS(b2, info2.background_b);\n\n  // compare pixels in the \"raw\" color model\n  LodePNGColorMode mode_decoded; lodepng_color_mode_init(&mode_decoded); mode_decoded.bitdepth = 16; mode_decoded.colortype = LCT_RGBA;\n  std::vector<unsigned char> image3((w * h * lodepng_get_bpp(&mode_raw) + 7) / 8);\n  error = lodepng_convert(image3.data(), image2.data(), &mode_raw, &mode_decoded, w, h);\n  ASSERT_NO_PNG_ERROR(error);\n  ASSERT_EQUALS(pixels.size(), image3.size());\n  for(size_t i = 0; i < image3.size(); i++) {\n    ASSERT_EQUALS((int)image3[i], (int)pixels[i]);\n  }\n}\n\n// r, g, b is input background color to encoder, given in png color model\n// r2, g2, b2 is expected decoded background color, in color model it auto chose if auto_convert is on\nvoid testBkgdChunk(unsigned r, unsigned g, unsigned b,\n                   unsigned r2, unsigned g2, unsigned b2,\n                   LodePNGColorType type_pixels, unsigned bitdepth_pixels,\n                   LodePNGColorType type_raw, unsigned bitdepth_raw,\n                   LodePNGColorType type_png, unsigned bitdepth_png,\n                   bool auto_convert, bool expect_encoder_error = false) {\n  unsigned error;\n  Image image;\n  generateTestImageRequiringColorType16(image, type_pixels, bitdepth_pixels, false);\n\n  LodePNGColorMode mode_raw; lodepng_color_mode_init(&mode_raw); mode_raw.bitdepth = bitdepth_raw; mode_raw.colortype = type_raw;\n  LodePNGColorMode mode_test; lodepng_color_mode_init(&mode_test); mode_test.bitdepth = 16; mode_test.colortype = LCT_RGBA;\n  LodePNGColorMode mode_png; lodepng_color_mode_init(&mode_png); mode_png.bitdepth = bitdepth_png; mode_png.colortype = type_png;\n  std::vector<unsigned char> temp((image.width * image.height * lodepng_get_bpp(&mode_raw) + 7) / 8);\n  error = lodepng_convert(temp.data(), image.data.data(), &mode_raw, &mode_test, image.width, image.height);\n  ASSERT_NO_PNG_ERROR(error);\n  image.data = temp;\n\n  testBkgdChunk(r, g, b, r2, g2, b2,\n                image.data, image.width, image.height,\n                mode_raw, mode_png, auto_convert, expect_encoder_error);\n}\n\nvoid testBkgdChunk() {\n  std::cout << \"testBkgdChunk\" << std::endl;\n  // color param order is: generated, raw, png ( == bKGD)\n  // here generated means: what color values the pixels will get, so what auto_convert will make it choose\n  testBkgdChunk(255, 0, 0, 255, 0, 0, LCT_RGBA, 8, LCT_RGBA, 8, LCT_RGBA, 8, true);\n  testBkgdChunk(255, 0, 0, 255, 0, 0, LCT_RGBA, 8, LCT_RGB, 8, LCT_RGB, 8, true);\n  testBkgdChunk(255, 0, 0, 255, 0, 0, LCT_RGB, 8, LCT_RGB, 8, LCT_RGB, 8, true);\n  testBkgdChunk(255, 255, 255, 1, 1, 1, LCT_GREY, 1, LCT_RGB, 8, LCT_RGB, 8, true);\n  testBkgdChunk(255, 255, 255, 3, 3, 3, LCT_GREY, 2, LCT_RGB, 8, LCT_RGB, 8, true);\n  testBkgdChunk(255, 255, 255, 15, 15, 15, LCT_GREY, 4, LCT_RGB, 8, LCT_RGB, 8, true);\n  testBkgdChunk(255, 255, 255, 255, 255, 255, LCT_GREY, 8, LCT_RGB, 8, LCT_RGB, 8, true);\n  testBkgdChunk(255, 255, 255, 65535, 65535, 65535, LCT_GREY, 16, LCT_RGB, 16, LCT_RGB, 8, true);\n  testBkgdChunk(123, 0, 0, 123, 0, 0, LCT_GREY, 1, LCT_RGB, 8, LCT_RGB, 8, true);\n  testBkgdChunk(170, 170, 170, 2, 2, 2, LCT_GREY, 1, LCT_RGB, 8, LCT_RGB, 8, true); // 170 = value 2 in 2-bit\n\n  // without auto_convert. Note that it will still convert if different colortype is given for raw and png, it's just\n  // not automatic in that case.\n  testBkgdChunk(255, 0, 0, 255, 0, 0, LCT_RGBA, 8, LCT_RGBA, 8, LCT_RGBA, 8, false);\n  testBkgdChunk(60000, 0, 0, 60000, 0, 0, LCT_RGBA, 8, LCT_RGBA, 8, LCT_RGBA, 16, false);\n  testBkgdChunk(128, 128, 128, 128, 128, 128, LCT_GREY, 8, LCT_RGBA, 8, LCT_GREY, 8, false);\n {\n    LodePNGColorMode pal;\n    lodepng_color_mode_init(&pal);\n    for(int i = 0; i < 200; i++) lodepng_palette_add(&pal, i, i / 2, 0, 255);\n    pal.colortype = LCT_PALETTE;\n    pal.bitdepth = 8;\n    unsigned w = 200;\n    unsigned h = 200;\n    std::vector<unsigned char> img(w * h);\n    for(unsigned y = 0; y < h; y++)\n    for(unsigned x = 0; x < w; x++) {\n      img[y * w + x] = x;\n    }\n\n    testBkgdChunk(100, 0, 0, 100, 100, 100, img, w, h, pal, pal, true, false);\n    testBkgdChunk(100, 0, 0, 100, 100, 100, img, w, h, pal, pal, false, false);\n    testBkgdChunk(250, 0, 0, 250, 250, 250, img, w, h, pal, pal, true, true);\n\n    std::vector<unsigned char> fourcolor(w * h);\n    for(unsigned y = 0; y < h; y++)\n    for(unsigned x = 0; x < w; x++) {\n      fourcolor[y * w + x] = x & 3;\n    }\n    // palette index 4 expected for output bKGD: auto_convert should turn the 200-sized\n    // palette in one of size 5, 4 values for the fourcolor image above, and then a 5th for\n    // the bkgd index. The other two 4's actually shouldn't matter, it's not defined what\n    // they should be though currently lodepng sets them also to the palette index...\n    testBkgdChunk(100, 0, 0, 4, 4, 4, fourcolor, w, h, pal, pal, true, false);\n\n\n    std::vector<unsigned char> mini(4);\n    mini[0] = 1; mini[1] = 2; mini[2] = 3; mini[3] = 4;\n    // here we expect RGB color from the output image, since the image is tiny so it chooses to not add PLTE\n    testBkgdChunk(100, 0, 0, 100, 50, 0, mini, 2, 2, pal, pal, true, false);\n\n    lodepng_color_mode_cleanup(&pal);\n  }\n}\n\nvoid testBkgdChunk2() {\n  std::cout << \"testBkgdChunk2\" << std::endl;\n  Image image;\n  generateTestImageRequiringColorType8(image, LCT_GREY, 2, false);\n\n  // without background, it should choose 2-bit gray for this PNG\n  std::vector<unsigned char> png0;\n  ASSERT_NO_PNG_ERROR(lodepng::encode(png0, image.data, image.width, image.height));\n  lodepng::State state0;\n  unsigned w0, h0;\n  lodepng_inspect(&w0, &h0, &state0, png0.data(), png0.size());\n  ASSERT_EQUALS(2, state0.info_png.color.bitdepth);\n  ASSERT_EQUALS(LCT_GREY, state0.info_png.color.colortype);\n\n  // red background, with auto_convert, it is forced to choose RGB\n  lodepng::State state;\n  LodePNGInfo& info = state.info_png;\n  info.background_defined = 1;\n  info.background_r = 255;\n  info.background_g = 0;\n  info.background_b = 0;\n  std::vector<unsigned char> png1;\n  ASSERT_NO_PNG_ERROR(lodepng::encode(png1, image.data, image.width, image.height, state));\n  lodepng::State state1;\n  unsigned w1, h1;\n  lodepng_inspect(&w1, &h1, &state1, png1.data(), png1.size());\n  ASSERT_EQUALS(8, state1.info_png.color.bitdepth);\n  ASSERT_EQUALS(LCT_RGB, state1.info_png.color.colortype);\n\n  // gray output required, background color also interpreted as gray\n  state.info_raw.colortype = LCT_RGB;\n  state.info_png.color.colortype = LCT_GREY;\n  state.info_png.color.bitdepth = 1;\n  state.encoder.auto_convert = 0;\n  info.background_defined = 1;\n  info.background_r = 1;\n  info.background_g = 1;\n  info.background_b = 1;\n  std::vector<unsigned char> png2;\n  ASSERT_NO_PNG_ERROR(lodepng::encode(png2, image.data, image.width, image.height, state));\n  lodepng::State state2;\n  unsigned w2, h2;\n  lodepng_inspect(&w2, &h2, &state2, png2.data(), png2.size());\n  ASSERT_EQUALS(1, state2.info_png.color.bitdepth);\n  ASSERT_EQUALS(LCT_GREY, state2.info_png.color.colortype);\n}\n\n// r, g, b, a are the bit depths to store\nvoid testSbitChunk(unsigned r, unsigned g, unsigned b, unsigned a,\n                   const std::vector<unsigned char>& pixels,\n                   unsigned w, unsigned h,\n                   const LodePNGColorMode& mode_raw,\n                   const LodePNGColorMode& mode_png,\n                   bool auto_convert,\n                   bool expect_encoder_error = false) {\n  unsigned error;\n\n  lodepng::State state;\n  LodePNGInfo& info = state.info_png;\n  lodepng_color_mode_copy(&info.color, &mode_png);\n  lodepng_color_mode_copy(&state.info_raw, &mode_raw);\n  state.encoder.auto_convert = auto_convert;\n  if(mode_raw.colortype == LCT_PALETTE) {\n    for(size_t i = 0; i < 256; i++) {\n      // TODO: consider allowing to set only 1 of these palettes in lodepng in the case\n      // where both info_raw and info_png have the palette color type\n      lodepng_palette_add(&state.info_raw, i, i, i, 255);\n      lodepng_palette_add(&info.color, i, i, i, 255);\n    }\n  }\n\n  info.sbit_defined = 1;\n  info.sbit_r = r;\n  info.sbit_g = g;\n  info.sbit_b = b;\n  info.sbit_a = a;\n\n  std::vector<unsigned char> png;\n  error = lodepng::encode(png, pixels, w, h, state);\n  if(expect_encoder_error) {\n    ASSERT_NOT_EQUALS(0, error);\n    return;\n  }\n  ASSERT_NO_PNG_ERROR(error);\n\n  lodepng::State state2;\n  LodePNGInfo& info2 = state2.info_png;\n  unsigned w2, h2;\n  std::vector<unsigned char> image2;\n  error = lodepng::decode(image2, w2, h2, state2, &png[0], png.size());\n  ASSERT_NO_PNG_ERROR(error);\n\n  LodePNGColorType type = mode_png.colortype;\n\n  ASSERT_EQUALS(w, w2);\n  ASSERT_EQUALS(h, h2);\n  ASSERT_EQUALS(1, info2.sbit_defined);\n  ASSERT_EQUALS(r, info2.sbit_r);\n  if(type == LCT_RGB || type == LCT_RGBA || type == LCT_PALETTE) {\n    ASSERT_EQUALS(g, info2.sbit_g);\n    ASSERT_EQUALS(b, info2.sbit_b);\n  }\n  if(type == LCT_GREY_ALPHA || type == LCT_RGBA) {\n    ASSERT_EQUALS(a, info2.sbit_a);\n  }\n\n  // compare pixels in a 16-bit color model\n  LodePNGColorMode mode_compare; lodepng_color_mode_init(&mode_compare); mode_compare.bitdepth = 16; mode_compare.colortype = LCT_RGBA;\n  LodePNGColorMode mode_decoded; lodepng_color_mode_init(&mode_decoded); mode_decoded.bitdepth = 8; mode_decoded.colortype = LCT_RGBA;\n  std::vector<unsigned char> image3(w * h * 8);\n  error = lodepng_convert(image3.data(), image2.data(), &mode_compare, &mode_decoded, w, h);\n  std::vector<unsigned char> image4(w * h * 8);\n  error = lodepng_convert(image4.data(), pixels.data(), &mode_compare, &state.info_raw, w, h);\n  ASSERT_NO_PNG_ERROR(error);\n  ASSERT_EQUALS(image4.size(), image3.size());\n  for(size_t i = 0; i < image3.size(); i++) {\n    ASSERT_EQUALS((int)image4[i], (int)image3[i]);\n  }\n}\n\n\nvoid testSbitChunk(unsigned r, unsigned g, unsigned b, unsigned a,\n                   LodePNGColorType type, unsigned bitdepth,\n                   bool expect_encoder_error = false) {\n  LodePNGColorMode mode_raw;\n  lodepng_color_mode_init(&mode_raw);\n  mode_raw.bitdepth = bitdepth;\n  mode_raw.colortype = type;\n  LodePNGColorMode mode_png;\n  lodepng_color_mode_init(&mode_png);\n  mode_png.bitdepth = bitdepth;\n  mode_png.colortype = type;\n\n  std::vector<unsigned char> pixels(8, 255); // force all pixels to be white, so encoder tries to use auto_convert as much as possible\n\n  testSbitChunk(r, g, b, a, pixels, 1, 1, mode_raw, mode_png, false, expect_encoder_error);\n  testSbitChunk(r, g, b, a, pixels, 1, 1, mode_raw, mode_png, true, expect_encoder_error);\n}\n\n// type_pixels = what the pixels should require at least for auto_convert\n// type_raw = actual raw pixel type to give to the encoder\n// type_png = PNG type to request from the encoder (if not auto_convert)\n// auto_convert: 0 = no, 1 = yes, 2 = try both\nvoid testSbitChunk2(unsigned r, unsigned g, unsigned b, unsigned a,\n                   LodePNGColorType type_pixels, unsigned bitdepth_pixels,\n                   LodePNGColorType type_raw, unsigned bitdepth_raw,\n                   LodePNGColorType type_png, unsigned bitdepth_png,\n                   int auto_convert,\n                   bool expect_encoder_error = false) {\n\n  unsigned error;\n  Image image;\n  generateTestImageRequiringColorType16(image, type_pixels, bitdepth_pixels, false);\n\n  LodePNGColorMode mode_raw; lodepng_color_mode_init(&mode_raw); mode_raw.bitdepth = bitdepth_raw; mode_raw.colortype = type_raw;\n  LodePNGColorMode mode_test; lodepng_color_mode_init(&mode_test); mode_test.bitdepth = 16; mode_test.colortype = LCT_RGBA;\n  LodePNGColorMode mode_png; lodepng_color_mode_init(&mode_png); mode_png.bitdepth = bitdepth_png; mode_png.colortype = type_png;\n  std::vector<unsigned char> temp((image.width * image.height * lodepng_get_bpp(&mode_raw) + 7) / 8);\n  error = lodepng_convert(temp.data(), image.data.data(), &mode_raw, &mode_test, image.width, image.height);\n  ASSERT_NO_PNG_ERROR(error);\n  image.data = temp;\n\n  if(auto_convert == 0 || auto_convert == 2) testSbitChunk(r, g, b, a, image.data, image.width, image.height, mode_raw, mode_png, false, expect_encoder_error);\n  if(auto_convert == 1 || auto_convert == 2) testSbitChunk(r, g, b, a, image.data, image.width, image.height, mode_raw, mode_png, true, expect_encoder_error);\n}\n\n// Test the sBIT chunk for all color types, and for possible combinations of pixel colors where auto_convert conversions occur (only conversions that\n// still allow storing all the sBIT information within the PNG specification limitations may occur)\nvoid testSbitChunk() {\n  std::cout << \"testSbitChunk\" << std::endl;\n  testSbitChunk(8, 8, 8, 0, LCT_RGB, 8, false);\n  testSbitChunk(1, 2, 3, 0, LCT_RGB, 8, false);\n  testSbitChunk(0, 2, 3, 0, LCT_RGB, 8, true);\n  testSbitChunk(9, 2, 3, 0, LCT_RGB, 8, true);\n\n  testSbitChunk(8, 8, 8, 8, LCT_RGBA, 8, false);\n  testSbitChunk(1, 2, 3, 4, LCT_RGBA, 8, false);\n  testSbitChunk(0, 2, 3, 4, LCT_RGBA, 8, true);\n  testSbitChunk(9, 2, 3, 4, LCT_RGBA, 8, true);\n\n  testSbitChunk(1, 2, 3, 0, LCT_RGB, 16, false);\n  testSbitChunk(0, 2, 3, 0, LCT_RGB, 16, true);\n  testSbitChunk(9, 2, 3, 0, LCT_RGB, 16, false);\n  testSbitChunk(17, 2, 3, 0, LCT_RGB, 16, true);\n\n  testSbitChunk(1, 2, 3, 4, LCT_RGBA, 16, false);\n  testSbitChunk(0, 2, 3, 4, LCT_RGBA, 16, true);\n  testSbitChunk(9, 2, 3, 4, LCT_RGBA, 16, false);\n  testSbitChunk(17, 2, 3, 4, LCT_RGBA, 16, true);\n\n  testSbitChunk(8, 2, 3, 0, LCT_PALETTE, 8, false);\n  testSbitChunk(8, 2, 3, 0, LCT_PALETTE, 4, false); // 4-bit palette still treats the RGB as 8-bit\n  testSbitChunk(9, 2, 3, 0, LCT_PALETTE, 8, true);\n\n  testSbitChunk(8, 0, 0, 0, LCT_GREY, 8, false);\n  testSbitChunk(8, 0, 0, 0, LCT_GREY, 4, true);\n  testSbitChunk(5, 0, 0, 0, LCT_GREY, 8, false);\n  testSbitChunk(1, 0, 0, 0, LCT_GREY, 1, false);\n  testSbitChunk(3, 0, 0, 0, LCT_GREY, 1, true);\n  testSbitChunk(0, 0, 0, 0, LCT_GREY, 1, true);\n\n  testSbitChunk(16, 0, 0, 0, LCT_GREY, 16, false);\n  testSbitChunk(17, 0, 0, 0, LCT_GREY, 16, true);\n  testSbitChunk(8, 0, 0, 0, LCT_GREY, 16, false);\n  testSbitChunk(5, 0, 0, 0, LCT_GREY, 16, false);\n\n  testSbitChunk(8, 0, 0, 8, LCT_GREY_ALPHA, 8, false);\n  testSbitChunk(8, 0, 0, 0, LCT_GREY_ALPHA, 8, true);\n  testSbitChunk(8, 0, 0, 9, LCT_GREY_ALPHA, 8, true);\n  testSbitChunk(5, 0, 0, 5, LCT_GREY_ALPHA, 8, false);\n  testSbitChunk(5, 0, 0, 8, LCT_GREY_ALPHA, 8, false);\n\n  testSbitChunk(16, 0, 0, 16, LCT_GREY_ALPHA, 16, false);\n  testSbitChunk(16, 0, 0, 8, LCT_GREY_ALPHA, 16, false);\n  testSbitChunk(8, 0, 0, 8, LCT_GREY_ALPHA, 16, false);\n  testSbitChunk(16, 0, 0, 0, LCT_GREY_ALPHA, 16, true);\n  testSbitChunk(16, 0, 0, 17, LCT_GREY_ALPHA, 16, true);\n  testSbitChunk(5, 0, 0, 5, LCT_GREY_ALPHA, 16, false);\n  testSbitChunk(5, 0, 0, 8, LCT_GREY_ALPHA, 16, false);\n\n  testSbitChunk2(8, 8, 8, 0, LCT_RGB, 8, LCT_RGB, 8, LCT_RGB, 8, 2, false);\n  testSbitChunk2(8, 8, 8, 0, LCT_GREY, 8, LCT_RGB, 8, LCT_RGB, 8, 2, false);\n  testSbitChunk2(12, 12, 12, 0, LCT_GREY, 8, LCT_RGB, 16, LCT_RGB, 16, 2, false);\n  testSbitChunk2(12, 12, 12, 8, LCT_GREY, 8, LCT_RGBA, 16, LCT_RGBA, 16, 2, false);\n  testSbitChunk2(8, 8, 8, 0, LCT_GREY, 8, LCT_RGB, 16, LCT_RGB, 16, 2, false);\n  testSbitChunk2(8, 7, 8, 0, LCT_GREY, 8, LCT_RGB, 16, LCT_RGB, 16, 2, false);\n  testSbitChunk2(8, 8, 7, 0, LCT_GREY, 8, LCT_RGB, 16, LCT_RGB, 16, 2, false);\n  testSbitChunk2(8, 7, 8, 0, LCT_GREY, 8, LCT_RGB, 8, LCT_RGB, 8, 2, false);\n  testSbitChunk2(8, 8, 7, 0, LCT_GREY, 8, LCT_RGB, 8, LCT_RGB, 8, 2, false);\n  testSbitChunk2(8, 8, 8, 0, LCT_GREY, 8, LCT_RGB, 8, LCT_GREY_ALPHA, 8, 1, false);\n  testSbitChunk2(8, 8, 8, 8, LCT_GREY, 8, LCT_RGB, 8, LCT_GREY_ALPHA, 8, 0, false);\n\n\n  // test png-suite image cs3n3p08.png, which has an sBIT chunk with RGB values set to 3 bits\n  {\n    std::vector<unsigned char> png, decoded;\n    fromBase64(png, std::string(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAAYagMeiWXwAAAANzQklUAwMDo5KgQgAAAFRQTFRFkv8AAP+SAP//AP8AANv/AP9t/7YAAG3/tv8A/5IA2/8AAEn//yQA/wAAJP8ASf8AAP/bAP9JAP+2//8AAP8kALb//9sAAJL//20AACT//0kAbf8A33ArFwAAAEtJREFUeJyFyscBggAAALGzYldUsO2/pyMk73SGGE7QF3pDe2gLzdADHA7QDqIfdIUu0AocntAIbaAFdIdu0BIc1tAEvaABOkIf+AMiQDPhd/SuJgAAAABJRU5ErkJggg==\"));\n    lodepng::State state;\n    unsigned w, h;\n\n    unsigned error = lodepng::decode(decoded, w, h, state, png);\n    assertNoError(error);\n    ASSERT_EQUALS(1, state.info_png.sbit_defined);\n    ASSERT_EQUALS(3, state.info_png.sbit_r);\n    ASSERT_EQUALS(3, state.info_png.sbit_g);\n    ASSERT_EQUALS(3, state.info_png.sbit_b);\n  }\n\n  // test png-suite image basn0g02.png, which is known to not have an sBIT chunk\n  {\n    std::vector<unsigned char> png, decoded;\n    fromBase64(png, std::string(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAgAAAAAcoT2JAAAABGdBTUEAAYagMeiWXwAAAB9JREFUeJxjYAhd9R+M8TCIUMIAU4aPATMJH2OQuQcAvUl/gYsJiakAAAAASUVORK5CYII=\"));\n    lodepng::State state;\n    unsigned w, h;\n\n    unsigned error = lodepng::decode(decoded, w, h, state, png);\n    assertNoError(error);\n    ASSERT_EQUALS(0, state.info_png.sbit_defined);\n  }\n}\n\n// Test particular cHRM+gAMA conversion to srgb\n// gamma = gamma given 100000x multiplied form of PNG, or 0 to set none at all\n// wx..by = whitepoint and chromaticities, given in the 100000x multiplied form of PNG\n// r, g, b: r, g, b values to encode in the PNG's data\n// er, eg, eb: expected r, g, b values after decoding and converting to sRGB\nvoid testChrmToSrgb(unsigned gamma, unsigned wx, unsigned wy, unsigned rx, unsigned ry, unsigned gx, unsigned gy, unsigned bx, unsigned by,\n                    unsigned char r, unsigned char g, unsigned char b, unsigned char er, unsigned char eg, unsigned char eb,\n                    int max_dist = 0) {\n  std::vector<unsigned char> image(4);\n  image[0] = r;\n  image[1] = g;\n  image[2] = b;\n  image[3] = 255;\n  lodepng::State state;\n  if(gamma) {\n    state.info_png.gama_defined = 1;\n    state.info_png.gama_gamma = gamma;\n  }\n  state.info_png.chrm_defined = 1;\n  state.info_png.chrm_white_x = wx;\n  state.info_png.chrm_white_y = wy;\n  state.info_png.chrm_red_x = rx;\n  state.info_png.chrm_red_y = ry;\n  state.info_png.chrm_green_x = gx;\n  state.info_png.chrm_green_y = gy;\n  state.info_png.chrm_blue_x = bx;\n  state.info_png.chrm_blue_y = by;\n\n  std::vector<unsigned char> image2(4);\n  convertToSrgb(image2.data(), image.data(), 1, 1, &state);\n\n  if(max_dist == 0) {\n    ASSERT_EQUALS(er, image2[0]);\n    ASSERT_EQUALS(eg, image2[1]);\n    ASSERT_EQUALS(eb, image2[2]);\n  } else {\n    ASSERT_NEAR(er, image2[0], max_dist);\n    ASSERT_NEAR(eg, image2[1], max_dist);\n    ASSERT_NEAR(eb, image2[2], max_dist);\n  }\n\n  // Also test the opposite direction\n\n  std::vector<unsigned char> image3(4);\n  convertFromSrgb(image3.data(), image2.data(), 1, 1, &state);\n\n  if(max_dist == 0) {\n    ASSERT_EQUALS(r, image3[0]);\n    ASSERT_EQUALS(g, image3[1]);\n    ASSERT_EQUALS(b, image3[2]);\n  } else {\n    ASSERT_NEAR(r, image3[0], max_dist);\n    ASSERT_NEAR(g, image3[1], max_dist);\n    ASSERT_NEAR(b, image3[2], max_dist);\n  }\n}\n\nvoid testChrmToSrgb() {\n  std::cout << \"testChrmToSrgb\" << std::endl;\n  // srgb gamma approximation and chromaticities defined as standard by png (multiplied by 100000)\n  unsigned sg = 45455; // srgb gamma approximation\n  unsigned swx = 31270;\n  unsigned swy = 32900;\n  unsigned srx = 64000;\n  unsigned sry = 33000;\n  unsigned sgx = 30000;\n  unsigned sgy = 60000;\n  unsigned sbx = 15000;\n  unsigned sby = 6000;\n\n  testChrmToSrgb(sg, swx, swy, srx, sry, sgx, sgy, sbx, sby, 0, 0, 0, 0, 0, 0);\n  testChrmToSrgb(sg, swx, swy, srx, sry, sgx, sgy, sbx, sby, 255, 255, 255, 255, 255, 255);\n\n  testChrmToSrgb(0, swx, swy, srx, sry, sgx, sgy, sbx, sby, 50, 50, 50, 50, 50, 50);\n  testChrmToSrgb(0, swx, swy, srx, sry, sgx, sgy, sbx, sby, 128, 128, 128, 128, 128, 128);\n  testChrmToSrgb(0, swx, swy, srx, sry, sgx, sgy, sbx, sby, 200, 200, 200, 200, 200, 200);\n\n  testChrmToSrgb(0, swx, swy, srx, sry, sgx, sgy, sbx, sby, 255, 0, 0, 255, 0, 0);\n  testChrmToSrgb(0, swx, swy, srx, sry, sgx, sgy, sbx, sby, 0, 255, 0, 0, 255, 0);\n  testChrmToSrgb(0, swx, swy, srx, sry, sgx, sgy, sbx, sby, 0, 0, 255, 0, 0, 255);\n\n  // swap red and green chromaticities\n  testChrmToSrgb(0, swx, swy, sgx, sgy, srx, sry, sbx, sby, 255, 0, 0, 0, 255, 0);\n  testChrmToSrgb(0, swx, swy, sgx, sgy, srx, sry, sbx, sby, 0, 255, 0, 255, 0, 0);\n  testChrmToSrgb(0, swx, swy, sgx, sgy, srx, sry, sbx, sby, 0, 0, 255, 0, 0, 255);\n\n  // swap red/green/blue chromaticities\n  testChrmToSrgb(0, swx, swy, sgx, sgy, sbx, sby, srx, sry, 255, 0, 0, 0, 255, 0);\n  testChrmToSrgb(0, swx, swy, sgx, sgy, sbx, sby, srx, sry, 0, 255, 0, 0, 0, 255);\n  testChrmToSrgb(0, swx, swy, sgx, sgy, sbx, sby, srx, sry, 0, 0, 255, 255, 0, 0);\n\n  // different whitepoint does not affect white or gray, due to the relative rendering intent (adaptation)\n  testChrmToSrgb(0, 35000, 25000, srx, sry, sgx, sgy, sbx, sby, 0, 0, 0, 0, 0, 0);\n  testChrmToSrgb(0, 35000, 25000, srx, sry, sgx, sgy, sbx, sby, 50, 50, 50, 50, 50, 50);\n  testChrmToSrgb(0, 35000, 25000, srx, sry, sgx, sgy, sbx, sby, 128, 128, 128, 128, 128, 128);\n  testChrmToSrgb(0, 35000, 25000, srx, sry, sgx, sgy, sbx, sby, 200, 200, 200, 200, 200, 200);\n  testChrmToSrgb(0, 35000, 25000, srx, sry, sgx, sgy, sbx, sby, 255, 255, 255, 255, 255, 255);\n}\n\n\n\nvoid testXYZ() {\n  std::cout << \"testXYZ\" << std::endl;\n  unsigned w = 512, h = 512;\n  std::vector<unsigned char> v(w * h * 4 * 2);\n  for(size_t i = 0; i < v.size(); i++) {\n    v[i] = getRandom() & 255;\n  }\n\n  // Test sRGB -> XYZ -> sRGB roundtrip\n\n  unsigned rendering_intent = 3; // test with absolute for now\n\n  // 8-bit\n  {\n    // Default state, the conversions use 8-bit sRGB\n    lodepng::State state;\n    std::vector<float> f(w * h * 4);\n    float whitepoint[3];\n    assertNoError(lodepng::convertToXYZ(f.data(), whitepoint, v.data(), w, h, &state));\n\n    std::vector<unsigned char> v2(w * h * 4);\n    assertNoError(lodepng::convertFromXYZ(v2.data(), f.data(), w, h, &state, whitepoint, rendering_intent));\n\n    for(size_t i = 0; i < v2.size(); i++) {\n      ASSERT_EQUALS(v[i], v2[i]);\n    }\n  }\n\n  // 16-bit\n  {\n    // Default state but with 16-bit, the conversions use 16-bit sRGB\n    lodepng::State state;\n    state.info_raw.bitdepth = 16;\n    std::vector<float> f(w * h * 4);\n    float whitepoint[3];\n    assertNoError(lodepng::convertToXYZ(f.data(), whitepoint, v.data(), w, h, &state));\n\n    std::vector<unsigned char> v2(w * h * 8);\n    assertNoError(lodepng::convertFromXYZ(v2.data(), f.data(), w, h, &state, whitepoint, rendering_intent));\n\n    for(size_t i = 0; i < v2.size(); i++) {\n      ASSERT_EQUALS(v[i], v2[i]);\n    }\n  }\n\n  // Test custom RGB+gamma -> XYZ -> custom RGB+gamma roundtrip\n\n  LodePNGInfo info_custom;\n  lodepng_info_init(&info_custom);\n  info_custom.gama_defined = 1;\n  info_custom.gama_gamma =   30000; // default 45455\n  info_custom.chrm_defined = 1;\n  info_custom.chrm_white_x = 10000; // default 31270\n  info_custom.chrm_white_y = 20000; // default 32900\n  info_custom.chrm_red_x =   30000; // default 64000\n  info_custom.chrm_red_y =   50000; // default 33000\n  info_custom.chrm_green_x = 70000; // default 30000\n  info_custom.chrm_green_y = 11000; // default 60000\n  info_custom.chrm_blue_x =  13000; // default 15000\n  info_custom.chrm_blue_y =  17000; // default 6000\n\n  // 8-bit\n  {\n    lodepng::State state;\n    lodepng_info_copy(&state.info_png, &info_custom);\n    std::vector<float> f(w * h * 4);\n    float whitepoint[3];\n    assertNoError(lodepng::convertToXYZ(f.data(), whitepoint, v.data(), w, h, &state));\n\n    std::vector<unsigned char> v2(w * h * 4);\n    assertNoError(lodepng::convertFromXYZ(v2.data(), f.data(), w, h, &state, whitepoint, rendering_intent));\n\n    for(size_t i = 0; i < v2.size(); i++) {\n      // Allow near instead of exact due to numerical issues with low values,\n      // see description at the 16-bit test below.\n      unsigned maxdist = 0;\n      if(v[i] <= 2) maxdist = 3;\n      else if(v[i] <= 4) maxdist = 2;\n      else maxdist = 0;\n      ASSERT_NEAR(v[i], v2[i], maxdist);\n    }\n  }\n\n  // 16-bit\n  {\n    lodepng::State state;\n    lodepng_info_copy(&state.info_png, &info_custom);\n    state.info_raw.bitdepth = 16;\n    std::vector<float> f(w * h * 4);\n    float whitepoint[3];\n    assertNoError(lodepng::convertToXYZ(f.data(), whitepoint, v.data(), w, h, &state));\n\n    std::vector<unsigned char> v2(w * h * 8);\n    assertNoError(lodepng::convertFromXYZ(v2.data(), f.data(), w, h, &state, whitepoint, rendering_intent));\n\n    for(size_t i = 0; i < v2.size(); i += 2) {\n      unsigned a = v[i + 0] * 256u + v[i + 1];\n      unsigned a2 = v2[i + 0] * 256u + v2[i + 1];\n      // There are numerical issues with low values due to the precision of float,\n      // so allow some distance for low values (low compared to 65535).\n      // The issue seems to be: the combination of how the gamma correction affects\n      // low values and the color conversion matrix operating on single precision\n      // floating point. With the sRGB's gamma the problem seems not to happen, maybe\n      // because that linear part near 0 behaves better than power.\n      // TODO: check if it can be fixed without using double for the image and without slow double precision pow.\n      unsigned maxdist = 0;\n      if(a < 2048) maxdist = 768;\n      else if(a < 4096) maxdist = 24;\n      else if(a < 16384) maxdist = 4;\n      else maxdist = 2;\n      ASSERT_NEAR(a, a2, maxdist);\n    }\n  }\n\n  lodepng_info_cleanup(&info_custom);\n}\n\n\nvoid testICC() {\n  std::cout << \"testICC\" << std::endl;\n  // approximate srgb (gamma function not exact)\n  std::string icc_near_srgb_base64 =\n      \"AAABwHRlc3QCQAAAbW50clJHQiBYWVogB+MAAQABAAAAAAAAYWNzcFNHSSAAAAABAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAEAAPbWAAEAAAAA0y10ZXN0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAJY3BydAAAAPAAAAANZGVzYwAAAQAAAABfd3RwdAAAAWAAAAAUclhZ\"\n      \"WgAAAXQAAAAUZ1hZWgAAAYgAAAAUYlhZWgAAAZwAAAAUclRSQwAAAbAAAAAOZ1RSQwAAAbAAAAAO\"\n      \"YlRSQwAAAbAAAAAOdGV4dAAAAABDQzAgAAAAAGRlc2MAAAAAAAAABXRlc3QAZW5VUwAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAFhZWiAAAAAAAADzUQABAAAAARbMWFlaIAAAAAAAAG+gAAA49AAAA5BYWVogAAAA\"\n      \"AAAAYpYAALeHAAAY2VhZWiAAAAAAAAAkngAAD4QAALbCY3VydgAAAAAAAAABAjMAAA==\";\n  std::vector<unsigned char> icc_near_srgb;\n  fromBase64(icc_near_srgb, icc_near_srgb_base64);\n  lodepng::State state_near_srgb;\n  lodepng_set_icc(&state_near_srgb.info_png, \"near_srgb\", icc_near_srgb.data(), icc_near_srgb.size());\n\n  // a made up RGB model.\n  // it causes (when converting from this to srgb) green to become softer green, blue to become softer blue, red to become orange.\n  // this model intersects sRGB, but some parts are outside of sRGB, some parts of sRGB are outside of this one.\n  // so when converting between this and sRGB and clipping the values to 8-bit, and then converting back, the values will not be the same due to this clipping\n  std::string icc_orange_base64 =\n      \"AAABwHRlc3QCQAAAbW50clJHQiBYWVogB+MAAQABAAAAAAAAYWNzcFNHSSAAAAABAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAMAAPbWAAEAAAAA0y10ZXN0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAJY3BydAAAAPAAAAANZGVzYwAAAQAAAABfd3RwdAAAAWAAAAAUclhZ\"\n      \"WgAAAXQAAAAUZ1hZWgAAAYgAAAAUYlhZWgAAAZwAAAAUclRSQwAAAbAAAAAOZ1RSQwAAAbAAAAAO\"\n      \"YlRSQwAAAbAAAAAOdGV4dAAAAABDQzAgAAAAAGRlc2MAAAAAAAAABXRlc3QAZW5VUwAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAFhZWiAAAAAAAAE7uwABAAAAARmZWFlaIAAAAAAAANAHAACTTAAACrRYWVogAAAA\"\n      \"AAAABOMAAFd4AAAFzVhZWiAAAAAAAAAh6gAAFTsAAMKqY3VydgAAAAAAAAABAoAAAA==\";\n  std::vector<unsigned char> icc_orange;\n  fromBase64(icc_orange, icc_orange_base64);\n  lodepng::State state_orange;\n  lodepng_set_icc(&state_orange.info_png, \"orange\", icc_orange.data(), icc_orange.size());\n\n  // A made up RGB model which is a superset of sRGB, and has R/G/B shifted around (so it greatly alters colors)\n  // Since this is a superset of sRGB, converting from sRGB to this model, and then back, should be lossless, but the opposite not necessarily.\n  std::string icc_super_base64 =\n      \"AAABwHRlc3QCQAAAbW50clJHQiBYWVogB+MAAQABAAAAAAAAYWNzcFNHSSAAAAABAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAEAAPbWAAEAAAAA0y10ZXN0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAJY3BydAAAAPAAAAANZGVzYwAAAQAAAABfd3RwdAAAAWAAAAAUclhZ\"\n      \"WgAAAXQAAAAUZ1hZWgAAAYgAAAAUYlhZWgAAAZwAAAAUclRSQwAAAbAAAAAOZ1RSQwAAAbAAAAAO\"\n      \"YlRSQwAAAbAAAAAOdGV4dAAAAABDQzAgAAAAAGRlc2MAAAAAAAAABXRlc3QAZW5VUwAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAFhZWiAAAAAAAADzUQABAAAAARbMWFlaIAAAAAAAAFW+AADL3f//70ZYWVogAAAA\"\n      \"AAAAJqD////UAADsUFhZWiAAAAAAAAB6dgAANE////eXY3VydgAAAAAAAAABAjMAAA==\";\n  std::vector<unsigned char> icc_super;\n  fromBase64(icc_super, icc_super_base64);\n  lodepng::State state_super;\n  lodepng_set_icc(&state_super.info_png, \"super\", icc_super.data(), icc_super.size());\n\n  // A made up RGB model which is a subset of sRGB, and has R/G/B shifted around (so it greatly alters colors)\n  // Since this is a subset of sRGB, converting to sRGB from this model, and then back, should be lossless, but the opposite not necessarily.\n  std::string icc_sub_base64 =\n      \"AAABwHRlc3QCQAAAbW50clJHQiBYWVogB+MAAQABAAAAAAAAYWNzcFNHSSAAAAABAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAEAAPbWAAEAAAAA0y10ZXN0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAJY3BydAAAAPAAAAANZGVzYwAAAQAAAABfd3RwdAAAAWAAAAAUclhZ\"\n      \"WgAAAXQAAAAUZ1hZWgAAAYgAAAAUYlhZWgAAAZwAAAAUclRSQwAAAbAAAAAOZ1RSQwAAAbAAAAAO\"\n      \"YlRSQwAAAbAAAAAOdGV4dAAAAABDQzAgAAAAAGRlc2MAAAAAAAAABXRlc3QAZW5VUwAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAFhZWiAAAAAAAADzUQABAAAAARbMWFlaIAAAAAAAAHEEAABy1AAAr8ZYWVogAAAA\"\n      \"AAAAV5kAAEPkAAAMs1hZWiAAAAAAAAAuNwAASUcAABazY3VydgAAAAAAAAABAjMAAA==\";\n\n  std::vector<unsigned char> icc_sub;\n  fromBase64(icc_sub, icc_sub_base64);\n  lodepng::State state_sub;\n  lodepng_set_icc(&state_sub.info_png, \"sub\", icc_sub.data(), icc_sub.size());\n\n  // make 8-pixel image with following colors: white, gray, red, darkred, green, darkgreen, blue, darkblue\n  unsigned w = 4, h = 2;\n  std::vector<unsigned char> im(w * h * 4, 255);\n  im[0 * 4 + 0] = 255; im[0 * 4 + 1] = 255; im[0 * 4 + 2] = 255;\n  im[1 * 4 + 0] = 128; im[1 * 4 + 1] = 128; im[1 * 4 + 2] = 128;\n  im[2 * 4 + 0] = 255; im[2 * 4 + 1] =   0; im[2 * 4 + 2] =   0;\n  im[3 * 4 + 0] = 128; im[3 * 4 + 1] =   0; im[3 * 4 + 2] =   0;\n  im[4 * 4 + 0] =   0; im[4 * 4 + 1] = 255; im[4 * 4 + 2] =   0;\n  im[5 * 4 + 0] =   0; im[5 * 4 + 1] = 128; im[5 * 4 + 2] =   0;\n  im[6 * 4 + 0] =   0; im[6 * 4 + 1] =   0; im[6 * 4 + 2] = 255;\n  im[7 * 4 + 0] =   0; im[7 * 4 + 1] =   0; im[7 * 4 + 2] = 128;\n\n\n  {\n    std::vector<unsigned char> im2(w * h * 4, 255);\n    assertNoError(convertToSrgb(im2.data(), im.data(), w, h, &state_orange));\n\n    ASSERT_NEAR(255, im2[0 * 4 + 0], 1); ASSERT_NEAR(255, im2[0 * 4 + 1], 1); ASSERT_NEAR(255, im2[0 * 4 + 2], 1);\n    ASSERT_NEAR(117, im2[1 * 4 + 0], 1); ASSERT_NEAR(117, im2[1 * 4 + 1], 1); ASSERT_NEAR(117, im2[1 * 4 + 2], 1);\n    ASSERT_NEAR(255, im2[2 * 4 + 0], 1); ASSERT_NEAR(151, im2[2 * 4 + 1], 1); ASSERT_NEAR(  0, im2[2 * 4 + 2], 1);\n    ASSERT_NEAR(145, im2[3 * 4 + 0], 1); ASSERT_NEAR( 66, im2[3 * 4 + 1], 1); ASSERT_NEAR(  0, im2[3 * 4 + 2], 1);\n    ASSERT_NEAR(  0, im2[4 * 4 + 0], 1); ASSERT_NEAR(209, im2[4 * 4 + 1], 1); ASSERT_NEAR(  0, im2[4 * 4 + 2], 1);\n    ASSERT_NEAR(  0, im2[5 * 4 + 0], 1); ASSERT_NEAR( 95, im2[5 * 4 + 1], 1); ASSERT_NEAR(  0, im2[5 * 4 + 2], 1);\n    ASSERT_NEAR(  0, im2[6 * 4 + 0], 1); ASSERT_NEAR( 66, im2[6 * 4 + 1], 1); ASSERT_NEAR(255, im2[6 * 4 + 2], 1);\n    ASSERT_NEAR(  0, im2[7 * 4 + 0], 1); ASSERT_NEAR( 25, im2[7 * 4 + 1], 1); ASSERT_NEAR(120, im2[7 * 4 + 2], 1);\n\n    // Cannot test the inverse direction to see if same as original, because the color model here has values\n    // outside of sRGB so several values were clipped.\n  }\n\n  {\n    std::vector<unsigned char> im2(w * h * 4, 255);\n    // convert between the two in one and then the other direction\n    assertNoError(convertRGBModel(im2.data(), im.data(), w, h, &state_near_srgb, &state_sub, 3));\n    std::vector<unsigned char> im3(w * h * 4, 255);\n    assertNoError(convertRGBModel(im3.data(), im2.data(), w, h, &state_sub, &state_near_srgb, 3));\n    // im3 should be same as im (allow some numerical errors), because we converted from a subset of sRGB to sRGB\n    // and then back.\n    // If state_super was used here instead (with a superset RGB color model), the test below would faill due to\n    // the clipping of the values in the 8-bit chars (due to the superset being out of range for sRGB)\n    for(size_t i = 0; i < im.size(); i++) {\n      // due to the gamma (trc), small values are very imprecise (due to the 8-bit char step in between), so allow more distance there\n      int tolerance = im[i] < 32 ? 16 : 1;\n      ASSERT_NEAR(im[i], im3[i], tolerance);\n    }\n  }\n\n  {\n    std::vector<unsigned char> im2(w * h * 4, 255);\n    assertNoError(convertFromSrgb(im2.data(), im.data(), w, h, &state_super));\n    std::vector<unsigned char> im3(w * h * 4, 255);\n    assertNoError(convertToSrgb(im3.data(), im2.data(), w, h, &state_super));\n    for(size_t i = 0; i < im.size(); i++) {\n      int tolerance = im[i] < 32 ? 16 : 1;\n      ASSERT_NEAR(im[i], im3[i], tolerance);\n    }\n  }\n}\n\n\nvoid testICCGray() {\n  std::cout << \"testICCGray\" << std::endl;\n  // Grayscale, Gamma 2.2, sRGB whitepoint\n  std::string icc22_base64 =\n      \"AAABSHRlc3QCQAAAbW50ckdSQVlYWVogB+MAAQABAAAAAAAAYWNzcFNHSSAAAAABAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAMAAPbWAAEAAAAA0y10ZXN0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAEY3BydAAAALQAAAANZGVzYwAAAMQAAABfd3RwdAAAASQAAAAUa1RS\"\n      \"QwAAATgAAAAOdGV4dAAAAABDQzAgAAAAAGRlc2MAAAAAAAAABXRlc3QAZW5VUwAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAFhZWiAAAAAAAADzUQABAAAAARbMY3VydgAAAAAAAAABAjMAAA==\";\n  std::vector<unsigned char> icc22;\n  fromBase64(icc22, icc22_base64);\n  lodepng::State state22;\n  state22.info_raw.colortype = LCT_GREY;\n  lodepng_set_icc(&state22.info_png, \"gray22\", icc22.data(), icc22.size());\n\n  // Grayscale, Gamma 2.9, custom whitepoint\n  std::string icc29_base64 =\n      \"AAABSHRlc3QCQAAAbW50ckdSQVlYWVogB+MAAQABAAAAAAAAYWNzcFNHSSAAAAABAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAMAAPbWAAEAAAAA0y10ZXN0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAEY3BydAAAALQAAAANZGVzYwAAAMQAAABfd3RwdAAAASQAAAAUa1RS\"\n      \"QwAAATgAAAAOdGV4dAAAAABDQzAgAAAAAGRlc2MAAAAAAAAABXRlc3QAZW5VUwAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAFhZWiAAAAAAAAE7uwABAAAAARmZY3VydgAAAAAAAAABAuYAAA==\";\n  std::vector<unsigned char> icc29;\n  fromBase64(icc29, icc29_base64);\n  lodepng::State state29;\n  state29.info_raw.colortype = LCT_GREY;\n  lodepng_set_icc(&state29.info_png, \"gray29\", icc29.data(), icc29.size());\n\n  // Grayscale, Gamma 1.5, custom whitepoint\n  std::string icc15_base64 =\n      \"AAABSHRlc3QCQAAAbW50ckdSQVlYWVogB+MAAQABAAAAAAAAYWNzcFNHSSAAAAABAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAMAAPbWAAEAAAAA0y10ZXN0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAEY3BydAAAALQAAAANZGVzYwAAAMQAAABfd3RwdAAAASQAAAAUa1RS\"\n      \"QwAAATgAAAAOdGV4dAAAAABDQzAgAAAAAGRlc2MAAAAAAAAABXRlc3QAZW5VUwAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n      \"AAAAAAAAAFhZWiAAAAAAAAE7uwABAAAAARmZY3VydgAAAAAAAAABAYAAAA==\";\n  std::vector<unsigned char> icc15;\n  fromBase64(icc15, icc15_base64);\n  lodepng::State state15;\n  state15.info_raw.colortype = LCT_GREY;\n  lodepng_set_icc(&state15.info_png, \"gray15\", icc15.data(), icc15.size());\n\n\n  // make 8-pixel grayscale image with different shades of gray\n  unsigned w = 4, h = 2;\n  std::vector<unsigned char> im(w * h, 255);\n  im[0] = 0;\n  im[1] = 40;\n  im[2] = 80;\n  im[3] = 120;\n  im[4] = 160;\n  im[5] = 200;\n  im[6] = 240;\n  im[7] = 255;\n\n  {\n    std::vector<unsigned char> im2(w * h, 255);\n    assertNoError(convertToSrgb(im2.data(), im.data(), w, h, &state29));\n\n    ASSERT_NEAR(0, im2[0], 1);\n    ASSERT_NEAR(15, im2[1], 1);\n    ASSERT_NEAR(52, im2[2], 1);\n    ASSERT_NEAR(94, im2[3], 1);\n    ASSERT_NEAR(139, im2[4], 1);\n    ASSERT_NEAR(187, im2[5], 1);\n    ASSERT_NEAR(236, im2[6], 1);\n    ASSERT_NEAR(255, im2[7], 1);\n\n    std::vector<unsigned char> im3(w * h, 255);\n    assertNoError(convertFromSrgb(im3.data(), im2.data(), w, h, &state29));\n\n    for(size_t i = 0; i < 8; i++) {\n      ASSERT_NEAR(im[i], im3[i], 1);\n    }\n  }\n\n  {\n    std::vector<unsigned char> im2(w * h , 255);\n    assertNoError(convertRGBModel(im2.data(), im.data(), w, h, &state22, &state15, 3));\n    std::vector<unsigned char> im3(w * h, 255);\n    assertNoError(convertRGBModel(im3.data(), im2.data(), w, h, &state15, &state22, 3));\n    for(size_t i = 0; i < im.size(); i++) {\n      int tolerance = im[i] < 16 ? 8 : 1;\n      ASSERT_NEAR(im[i], im3[i], tolerance);\n    }\n  }\n}\n\n// input is base64-encoded png image and base64-encoded RGBA pixels (8 bit per channel)\nvoid testBase64Image(const std::string& png64, bool expect_error, unsigned expect_w, unsigned expect_h, const std::string& expect_md5) {\n  std::vector<unsigned char> png, pixels;\n  fromBase64(png, png64);\n\n  std::vector<unsigned char> decoded;\n  unsigned w, h;\n  unsigned error = lodepng::decode(decoded, w, h, png);\n  if(expect_error) {\n    ASSERT_EQUALS(true, error != 0);\n    return;\n  }\n  assertNoError(error);\n  ASSERT_EQUALS(expect_w, w);\n  ASSERT_EQUALS(expect_h, h);\n  ASSERT_EQUALS(expect_md5, md5sum(decoded));\n\n  // test decoding without alpha channel\n  {\n    size_t numpixels = w * h;\n    std::vector<unsigned char> expected_rgb(numpixels * 3);\n    for(size_t i = 0; i < numpixels; i++) {\n      expected_rgb[i * 3 + 0] = decoded[i * 4 + 0];\n      expected_rgb[i * 3 + 1] = decoded[i * 4 + 1];\n      expected_rgb[i * 3 + 2] = decoded[i * 4 + 2];\n    }\n    std::vector<unsigned char> rgb;\n    ASSERT_NO_PNG_ERROR(lodepng::decode(rgb, w, h, png, LCT_RGB));\n    ASSERT_EQUALS(expect_w, w);\n    ASSERT_EQUALS(expect_h, h);\n    ASSERT_EQUALS(expected_rgb, rgb);\n  }\n\n  // test decoding 16-bit RGBA\n  // TODO: get an additional md5sum for 16-bit pixels instead to compare with\n  {\n    size_t numpixels = w * h;\n    std::vector<unsigned char> rgba16;\n    ASSERT_NO_PNG_ERROR(lodepng::decode(rgba16, w, h, png, LCT_RGBA, 16));\n    ASSERT_EQUALS(expect_w, w);\n    ASSERT_EQUALS(expect_h, h);\n    std::vector<unsigned char> rgba8(numpixels * 4);\n    for(size_t i = 0; i < numpixels; i++) {\n      rgba8[i * 4 + 0] = rgba16[i * 8 + 0];\n      rgba8[i * 4 + 1] = rgba16[i * 8 + 2];\n      rgba8[i * 4 + 2] = rgba16[i * 8 + 4];\n      rgba8[i * 4 + 3] = rgba16[i * 8 + 6];\n    }\n    ASSERT_EQUALS(decoded, rgba8);\n  }\n\n  // test decoding 16-bit RGB\n  {\n    size_t numpixels = w * h;\n    std::vector<unsigned char> expected_rgb(numpixels * 3);\n    for(size_t i = 0; i < numpixels; i++) {\n      expected_rgb[i * 3 + 0] = decoded[i * 4 + 0];\n      expected_rgb[i * 3 + 1] = decoded[i * 4 + 1];\n      expected_rgb[i * 3 + 2] = decoded[i * 4 + 2];\n    }\n    std::vector<unsigned char> rgb16;\n    ASSERT_NO_PNG_ERROR(lodepng::decode(rgb16, w, h, png, LCT_RGB, 16));\n    ASSERT_EQUALS(expect_w, w);\n    ASSERT_EQUALS(expect_h, h);\n    std::vector<unsigned char> rgb8(numpixels * 3);\n    for(size_t i = 0; i < numpixels; i++) {\n      rgb8[i * 3 + 0] = rgb16[i * 6 + 0];\n      rgb8[i * 3 + 1] = rgb16[i * 6 + 2];\n      rgb8[i * 3 + 2] = rgb16[i * 6 + 4];\n    }\n    ASSERT_EQUALS(expected_rgb, rgb8);\n  }\n\n  // test encode/decode\n  // TODO: also test state, for text chunks, ...\n  {\n    std::vector<unsigned char> rgba16;\n    ASSERT_NO_PNG_ERROR(lodepng::decode(rgba16, w, h, png, LCT_RGBA, 16));\n\n    std::vector<unsigned char> png_b;\n    ASSERT_NO_PNG_ERROR(lodepng::encode(png_b, rgba16, w, h, LCT_RGBA, 16));\n\n    std::vector<unsigned char> rgba16_b;\n    ASSERT_NO_PNG_ERROR(lodepng::decode(rgba16_b, w, h, png_b, LCT_RGBA, 16));\n    ASSERT_EQUALS(rgba16, rgba16_b);\n  }\n}\n// input is base64-encoded png image and base64-encoded RGBA pixels (8 bit per channel)\nvoid testPngSuiteImage(const std::string& png64, const std::string& name, bool expect_error, unsigned expect_w, unsigned expect_h, const std::string& expect_md5) {\n  std::cout << \"testPngSuiteImage: \" << name << std::endl;\n\n  testBase64Image(png64, expect_error, expect_w, expect_h, expect_md5);\n}\n\n\n// Tests base64-encoded PngSuite images' pixels against expected md5 sum of their pixels\nvoid testPngSuite() {\n  std::cout << \"testPngSuite\" << std::endl;\n  /*\n  LICENSE of the PngSuite images:\n\n  PngSuite\n  --------\n\n  Permission to use, copy, modify and distribute these images for any\n  purpose and without fee is hereby granted.\n\n\n  (c) Willem van Schaik, 1996, 2011\n  */\n\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQAAAAEsBnfPAAAABGdBTUEAAYagMeiWXwAAAJBJREFUeJwtjTEOwjAMRd/GgsQVGHoApC4Zergeg7En4AxWOQATY6WA2FgsZckQNXxLeLC/v99PcBaMGeesuXCj8tHe2Wlc5b9ZY9/ZKq9Mn9kn6kSeZIffW5w255m5G98IK01L1AFP5AFLAat6F67mlNKNMootY4N6cEUeFkhwLZqf9KEdL3pRqiHloYx//QCU41EdZhgi8gAAAABJRU5ErkJggg==\",\n      \"basi0g01.png\", false, 32, 32, \"4336909be7bff35103266c9b215ab516\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAgAAAAFrpg0fAAAABGdBTUEAAYagMeiWXwAAAFFJREFUeJxjUGLoYADhcoa7YJyTw3DsGJSUlgYxNm5EZ7OuZ13PEPUh6gMDkMHKAGRE4RZDSCBkEUpIUscQuuo/GMMZGAIMMEEEA6YKwaCSOQCcUoBNhbbZfQAAAABJRU5ErkJggg==\",\n      \"basi0g02.png\", false, 32, 32, \"b16bee35e71dce6c08c2447a62ccedea\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAAHk5vi/AAAABGdBTUEAAYagMeiWXwAAAK5JREFUeJxljlERwjAQRBccFBwUHAQchDoodRDqINRBwEHBQcFBwEGRECRUA5lJmM7Nftzs7bub28OywrZFdUX7xLrBvkNzR/fGanc8I9YNsV6I9cViczilQWwuaRqbR1qJzSftoSiVro39q0PWHlkHZPXIOiJrQNZpvsMH+TJHcBaHcjq/Mf+DoihLpbSua2OsZSCtcwyk7XsG0g4DA2m9ZyDtODKQNgQG0k4TgR8ngeup000HFgAAAABJRU5ErkJggg==\",\n      \"basi0g04.png\", false, 32, 32, \"0b40ec7e4231183b51e1c23f818a955f\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAAAAAEhFhW+AAAABGdBTUEAAYagMeiWXwAAALVJREFUeJy1kF0KwjAQhJ26yBxCxHv4Q88lPoh4sKoXEQ8hS9ymviQPXSGllM7T5JvNMiwWJBFVFRVJmKpCSCKoKlYkoaqKiyTFj5mZmQgTCYmgSgDXbCwJ52zyGtyyCTk6ZVNXfaFxQKLFnnDsv6OI3/HwO4L7gr0H8F98sT+AuwetL9YMARw8WI7v8fTgO77HzoMtypJ66gBeQxtiV5Y0UwewGchF5r/Du5h2nYT577AupsAPm7n/RegfnygAAAAASUVORK5CYII=\",\n      \"basi0g08.png\", false, 32, 32, \"f6470f9f6296c5109e2bd730fe203773\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAFxhsn9AAAABGdBTUEAAYagMeiWXwAAAOJJREFUeJy1kTsOwjAQRMdJCqj4XYHD5DAcj1Okyg2okCyBRLOSC0BDERKCI7xJVmgaa/X8PFo7oESJEtkaTeLDjdjjgCMe7eTE96FGd3AL7HvZsdNEaJMVo0GNGm775bgwW6Afj/SAjAY+JsYNXIHtz2xYxTXiUoOek4AbFcCnDYEK4NMGsgXcMrGHJytkBX5HIP8FAhVANIMVIBVANMPfgUAFEM3wAVyG5cxcecY5/dup3LVFa1HXmA61LY59f6Ygp1Eg1gZGQaBRILYGdxoFYmtAGgXx9YmCfPD+RMHwuuAFVpjuiRT///4AAAAASUVORK5CYII=\",\n      \"basi0g16.png\", false, 32, 32, \"a14e204bbf905586d3763f3cc5dcb2f3\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAGLH901AAAABGdBTUEAAYagMeiWXwAAAPJJREFUeJzVk0GqBCEMRKvAe3gTPVnTczO9iddoaLVm0Qz0Z1r4WWQxoRZifFaIkZKA4xIlfdagpM8aAQCO4xKl88acN+b8w/R+Z3agf4va9bQP7tLTPgJeL/T+LUpj4aFtkRgLc22LxFhUxW2VGGP0p+C2bc8JqQDz/6KUjUCR5TyobASKZDkPZitQSpmWYM7ZBhgrmgGovgClZASm7eGCsSI7QCXjLE3jQwRjRXaAyTqtpsmbc4Zaqy/AlJINkBogP13f4ZcNKEVngybP+6/v/NMGVPRtEZvkeT+Cc4f8DRidW8TWmjwj1Fp/24AxRleDN99NCjEh/D0zAAAAAElFTkSuQmCC\",\n      \"basi2c08.png\", false, 32, 32, \"512c3874e30061e623739e2f9adc4eba\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAIAAAHbjwF2AAAABGdBTUEAAYagMeiWXwAAAgpJREFUeJzVliFz4zAQhT/PGDjMYaGBgYWlPlZ4f6E/oTCFLjtYeLSwsDCBuX9wMAcLU+awV6CokSu7kWO58Qns7LxZvX3PK0VJJAnWbwDrHdg8tUl9ZUVq644QQJE7OywEUEyTbdWpx+LG67G48XpY6NBD2lbwbw+fYuUhe2ujobdvbJ6Z6GlqKnLixPseTUUukuyWUrgHSG0Stmab4A2zjZEUsMGWHjdUYaVfdmgqhcNnrW9oL/U6nCo1MZF2S3i7B9jdw8l8GVDzkWdFx7mFLHPC8hJgWkZqUCcFyDOAaci56E76uUHrOTqX1Mn9YxSDFCCfHB00NOhH6tY4DeKR1vJqJcHrtQR/XyTYXEnw8izB00KCxycJyrkEd78luJ1J8PNRgiKX4OqXBPNMgryUACRI7eUYZuVlau9dfGo4XLTYDmpTjOugTm3ySA6aqE3e20E7tcl7ODhFbfLU/sLHpwaYPnR00IX66CCoQXdqgwc4OJc6wEE/6i8dxKBucRCP2nMQm9rkiVStYL+Geqw85Ex8FYmnEc+Kgd+bIZZ52W0c7D2Lu+qiASYm34x4Au2iAbLS4CObQJhoFx/BBLqLdvELTaCfaBf/xgnEE+3iZ/0furRogMkPgOzPABMYXrSLR7oD3yvare8xgcuJdvGOExiHaBcPmMD4RLt4ywTGLdrFnQn8P6Jd/B2kFN6z3xNE9wAAAABJRU5ErkJggg==\",\n      \"basi2c16.png\", false, 32, 32, \"a3774d09367dd147a3539d2d2f6ca133\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAAE+s9ghAAAABGdBTUEAAYagMeiWXwAAAAZQTFRF7v8iImb/bBrSJgAAAClJREFUeJxjYICCD1C4CgpD0bCxMcOZM9hJCININj8QQIgPQAAhKBADAAm6Qi12qcOeAAAAAElFTkSuQmCC\",\n      \"basi3p01.png\", false, 32, 32, \"1ba59f527ff2cfdc68bb0c3487862e91\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAgMAAAF5E6LxAAAABGdBTUEAAYagMeiWXwAAAANzQklUAQEBfC53ggAAAAxQTFRFAP8A/wAA//8AAAD/ZT8rugAAAFFJREFUeJxjeMewmwGEXRgEwdjMjCE5GUreuAFi9Pais78u+LqAgT+KP4oByPjKAGTw4xZDSCBkEUpIUvc/dBUYIxiYQqugLAQDKvEfwaCSOQC0Wn3pH3XhAwAAAABJRU5ErkJggg==\",\n      \"basi3p02.png\", false, 32, 32, \"0528e9ac365252a8c0e2d9ced8a2cc6b\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAAH2U1dRAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAC1QTFRFIgD/AP//iAD/Iv8AAJn//2YA3QD/d/8A/wAAAP+Z3f8A/wC7/7sAAET/AP9E0rBJvQAAALZJREFUeJxj6KljOP6QoU6W4eElhihLhsVTGCwdGKawMcQst5vIAMS+DEDMxADE2Qytp4pfQiSADBGILJBxAaIEyFCDqOsIPbOq3PjdTAYoLcgApV0YoPRdBhjNAKWVGKB0GgOU3o0wB9NATJMxrcC0C9NSTNsxnYFwT0do6Jkzq1aVlxsbv3s3cyamACpXUBBTAJXr4oIpgMq9exdTAI3LgCmAylVSwhRA5aalYQqgcnfvxhAAALN26mgMdNBfAAAAAElFTkSuQmCC\",\n      \"basi3p04.png\", false, 32, 32, \"a339593b0d82103e30ed7b00afd68816\");\n  testPngSuiteImage(\"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\",\n      \"basi3p08.png\", false, 32, 32, \"d36bdbefc126ef50bd57d51eb38f2ac4\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAAGudILpAAAABGdBTUEAAYagMeiWXwAAAI1JREFUeJztj80KgzAMx3+BHvTWvUH7KPbB9yhzT7Dt5LUeHBWiEkFWhpgQGtL/RyIZOhLJ3Zli2UgOJAvzgECcs/ygoZsDyb7wA5Hoek2pMpAXeDw3VaVbMHTUADx/biG5Wbt+Lve2LD4W4FKoZnFYQQZovtmqd8+kNR2sMG8wBU6wwQlOuDb4hw2OCozsTz0JHVlVXQAAAABJRU5ErkJggg==\",\n      \"basi4a08.png\", false, 32, 32, \"e2212ec5fa026a41826136e983bf92b2\");\n  testPngSuiteImage(\"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\",\n      \"basi4a16.png\", false, 32, 32, \"f1423ebc08979252299ca238656ab0ba\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAAEEfUpiAAAABGdBTUEAAYagMeiWXwAAASBJREFUeJzFlUFOwzAQRZ+lQbi7smZBuAabhh6LTRLBwRLBRSpxCipl2EDVlJBB/EgeyYrifH8/jSfj5GSAR2AP7A0fOQ+74mM6MeKTieTk6nv9vz2aa4AKuJ8b1rVTz8uwZ56WBWPXLgqSk7cze5+YjMZ/Xw4YbSDoCAQvHJcFThMJ2kDQLX4n+S4DbL/GTfD8MRemIQobatGgDfIcGrzyoBlExxAbDLVooAGQnJz545nPPY2dRmCodUBdmmDQALBeLeVeJXgLelJo4GIhGOI5mqsGOoFYCEYvGrhokPwuA+SLsQne19Js5L9ZDbkbrABQdH/sUBXOgNoOVwAoG+Uz8M5tWQC1m8sA6m0gAxTPgB+qsgDqdSgDqNepDFA6A5+CSlP0aU5zQgAAAABJRU5ErkJggg==\",\n      \"basi6a08.png\", false, 32, 32, \"e80a60aecf13ebd863b61167ba95960b\");\n  testPngSuiteImage(\"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\",\n      \"basi6a16.png\", false, 32, 32, \"4d9d6473bb7403d7f85e3e7537c34e9d\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQAAAABbAUdZAAAABGdBTUEAAYagMeiWXwAAAFtJREFUeJwtzLEJAzAMBdHr0gSySiALejRvkBU8gsGNCmFFB1Hx4IovqurSpIRszqklUwbnUzRXEuIRsiG/SyY9G0JzJSVei9qynm9qyjBpLp0pYW7pbzBl8L8fEIdJL9AvFMkAAAAASUVORK5CYII=\",\n      \"basn0g01.png\", false, 32, 32, \"4336909be7bff35103266c9b215ab516\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAgAAAAAcoT2JAAAABGdBTUEAAYagMeiWXwAAAB9JREFUeJxjYAhd9R+M8TCIUMIAU4aPATMJH2OQuQcAvUl/gYsJiakAAAAASUVORK5CYII=\",\n      \"basn0g02.png\", false, 32, 32, \"b16bee35e71dce6c08c2447a62ccedea\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAAEhJREFUeJxjYGAQFFRSMjZ2cQkNTUsrL2cgQwCV29FBjgAqd+ZMcgRQuatWkSOAyt29mxwBVO6ZM+QIoHLv3iVHAJX77h0ZAgAfFO4B6v9B+gAAAABJRU5ErkJggg==\",\n      \"basn0g04.png\", false, 32, 32, \"0b40ec7e4231183b51e1c23f818a955f\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAAAAABWESUoAAAABGdBTUEAAYagMeiWXwAAAEFJREFUeJxjZGAkABQIyLMMBQWMDwgp+PcfP2B5MBwUMMoRkGdkonlcDAYFjI/wyv7/z/iH5nExGBQwyuCVZWQEAFDl/nE14thZAAAAAElFTkSuQmCC\",\n      \"basn0g08.png\", false, 32, 32, \"f6470f9f6296c5109e2bd730fe203773\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAAYagMeiWXwAAAF5JREFUeJzV0jEKwDAMQ1E5W+9/xtygk8AoezLVKgSj2Y8/OICnuFcTE2OgOoJgHQiZAN2C9kDKBOgW3AZCJkC3oD2QMgG6BbeBkAnQLWgPpExgP28H7E/0GTjPfwAW2EvYX64rn9cAAAAASUVORK5CYII=\",\n      \"basn0g16.png\", false, 32, 32, \"a14e204bbf905586d3763f3cc5dcb2f3\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAABGdBTUEAAYagMeiWXwAAAEhJREFUeJzt1cEJADAMAkCF7JH9t3ITO0Qr9KH4zuErtA0EO4AKFPgcoO3kfUx4QIECD0qHH8KEBxQo8KB0OCOpQIG7cHejwAGCsfleD0DPSwAAAABJRU5ErkJggg==\",\n      \"basn2c08.png\", false, 32, 32, \"512c3874e30061e623739e2f9adc4eba\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAIAAACsiDHgAAAABGdBTUEAAYagMeiWXwAAAOVJREFUeJzVlsEKgzAQRKfgQX/Lfrf9rfaWHgYDkoYmZpPMehiGReQ91qCPEEIAPi/gmu9kcnN+GD0nM1/O4vNad7cC6850KHCiM5fz7fJwXdEBYPOygV/o7PICeXSmsMA/dKbkGShD51xsAzXo7DIC9ehMAYG76MypZ6ANnfNJG7BAZx8uYIfOHChgjR4F+MfuDx0AtmfnDfREZ+8m0B+9m8Ao9Chg9x0Yi877jTYwA529WWAeerPAbPQoUH8GNNA5r9yAEjp7sYAeerGAKnoUyJ8BbXTOMxvwgM6eCPhBTwS8oTO/5kL+Xge7xOwAAAAASUVORK5CYII=\",\n      \"basn2c16.png\", false, 32, 32, \"a3774d09367dd147a3539d2d2f6ca133\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAABGdBTUEAAYagMeiWXwAAAAZQTFRF7v8iImb/bBrSJgAAABVJREFUeJxj4AcCBjTiAxCgEwOkDgC7Hz/Bk4JmWQAAAABJRU5ErkJggg==\",\n      \"basn3p01.png\", false, 32, 32, \"1ba59f527ff2cfdc68bb0c3487862e91\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAgMAAAAOFJJnAAAABGdBTUEAAYagMeiWXwAAAANzQklUAQEBfC53ggAAAAxQTFRFAP8A/wAA//8AAAD/ZT8rugAAACJJREFUeJxj+B+6igGEGfAw8MnBGKugLHwMqNL/+BiDzD0AvUl/geqJjhsAAAAASUVORK5CYII=\",\n      \"basn3p02.png\", false, 32, 32, \"0528e9ac365252a8c0e2d9ced8a2cc6b\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAC1QTFRFIgD/AP//iAD/Iv8AAJn//2YA3QD/d/8A/wAAAP+Z3f8A/wC7/7sAAET/AP9E0rBJvQAAAEdJREFUeJxj6OgIDT1zZtWq8nJj43fvZs5kIEMAlSsoSI4AKtfFhRwBVO7du+QIoHEZyBFA5SopkSOAyk1LI0cAlbt7NxkCAODE6tEPggV9AAAAAElFTkSuQmCC\",\n      \"basn3p04.png\", false, 32, 32, \"a339593b0d82103e30ed7b00afd68816\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAAYagMeiWXwAAAwBQTFRFIkQA9f/td/93y///EQoAOncAIiL//xH/EQAAIiIA/6xVZv9m/2Zm/wH/IhIA3P//zP+ZRET/AFVVIgAAy8v/REQAVf9Vy8sAMxoA/+zc7f//5P/L/9zcRP9EZmb/MwAARCIA7e3/ZmYA/6RE//+q7e0AAMvL/v///f/+//8BM/8zVSoAAQH/iIj/AKqqAQEARAAAiIgA/+TLulsAIv8iZjIA//+Zqqr/VQAAqqoAy2MAEf8R1P+qdzoA/0RE3GsAZgAAAf8BiEIA7P/ca9wA/9y6ADMzAO0A7XMA//+ImUoAEf//dwAA/4MB/7q6/nsA//7/AMsA/5mZIv//iAAA//93AIiI/9z/GjMAAACqM///AJkAmQAAAAABMmYA/7r/RP///6r/AHcAAP7+qgAASpkA//9m/yIiAACZi/8RVf///wEB/4j/AFUAABER///+//3+pP9EZv///2b/ADMA//9V/3d3AACI/0T/ABEAd///AGZm///tAAEA//XtERH///9E/yL//+3tEREAiP//AAB3k/8iANzcMzP//gD+urr/mf//MzMAY8sAuroArP9V///c//8ze/4A7QDtVVX/qv//3Nz/VVUAAABm3NwA3ADcg/8Bd3f//v7////L/1VVd3cA/v4AywDLAAD+AQIAAQAAEiIA//8iAEREm/8z/9SqAABVmZn/mZkAugC6KlUA/8vLtP9m/5sz//+6qgCqQogAU6oA/6qqAADtALq6//8RAP4AAABEAJmZmQCZ/8yZugAAiACIANwA/5MiAADc/v/+qlMAdwB3AgEAywAAAAAz/+3/ALoA/zMz7f/t/8SIvP93AKoAZgBmACIi3AAA/8v/3P/c/4sRAADLAAEBVQBVAIgAAAAiAf//y//L7QAA/4iIRABEW7oA/7x3/5n/AGYAuv+6AHd3c+0A/gAAMwAzAAC6/3f/AEQAqv+q//7+AAARIgAixP+IAO3tmf+Z/1X/ACIA/7RmEQARChEA/xER3P+6uv//iP+IAQAB/zP/uY7TYgAAAbFJREFUeJwNwQcACAQQAMBHqIxIZCs7Mwlla1hlZ+8VitCw9yoqNGiYDatsyt6jjIadlVkysve+u5jC9xTmV/qyl6bcJR7kAQZzg568xXmuE2lIyUNM5So7OMAFIhvp+YgGvEtFNnOKeJonSEvwP9NZzhHiOfLzBXPoxKP8yD6iPMXITjP+oTdfsp14lTJMJjGtOMFQfiFe4wWK8BP7qUd31hBNqMos2tKYFbRnJdGGjTzPz2yjEA1ZSKymKCM5ylaWcJrZxCZK8jgfU4vc/MW3xE7K8RUvsZb3Wc/XxCEqk4v/qMQlFvMZcZIafMOnLKM13zGceJNqPMU4KnCQAqQgbrKHpXSgFK/Qn6REO9YxjWE8Sx2SMJD4jfl8wgzy0YgPuEeUJQcD6EoWWpCaHsQkHuY9RpGON/icK0RyrvE680jG22TlHaIbx6jLnySkF+M5QxzmD6pwkTsMoSAdidqsojipuMyHzOQ4sYgfyElpzjKGErQkqvMyC7jFv9xmBM2JuTzDRDLxN4l4jF1EZjIwmhfZzSOMpT4xiH70IQG/k5En2UKcowudycsG8jCBmtwHgRv+EIeWyOAAAAAASUVORK5CYII=\",\n      \"basn3p08.png\", false, 32, 32, \"d36bdbefc126ef50bd57d51eb38f2ac4\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAAYagMeiWXwAAADVJREFUeJxj/M/AwAGFnGg0MSKcLN8ZKAMsP4a+AaNhMBoGVDFgNBBHw4AqBowG4mgYUMMAAN8qIH3E64XIAAAAAElFTkSuQmCC\",\n      \"basn4a08.png\", false, 32, 32, \"e2212ec5fa026a41826136e983bf92b2\");\n  testPngSuiteImage(\"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\",\n      \"basn4a16.png\", false, 32, 32, \"f1423ebc08979252299ca238656ab0ba\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAAYagMeiWXwAAAG9JREFUeJzt1jEKgDAMRuEnZGhPofc/VQSPIcTdxUV4HVLoUCj8H00o2YoBMF57fpz/ujODHXUFRwPKBqj5DVigB041HiJ9gFyCVOMbsEIPXNwuAHkgiJL/4qABNqB7QAeUPBAE2QAZUDZAfwEb8ABSIBqcFg+4TAAAAABJRU5ErkJggg==\",\n      \"basn6a08.png\", false, 32, 32, \"e80a60aecf13ebd863b61167ba95960b\");\n  testPngSuiteImage(\"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\",\n      \"basn6a16.png\", false, 32, 32, \"4d9d6473bb7403d7f85e3e7537c34e9d\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAAGudILpAAAABGdBTUEAAYagMeiWXwAAAI1JREFUeJztj80KgzAMx3+BHvTWvUH7KPbB9yhzT7Dt5LUeHBWiEkFWhpgQGtL/RyIZOhLJ3Zli2UgOJAvzgECcs/ygoZsDyb7wA5Hoek2pMpAXeDw3VaVbMHTUADx/biG5Wbt+Lve2LD4W4FKoZnFYQQZovtmqd8+kNR2sMG8wBU6wwQlOuDb4hw2OCozsTz0JHVlVXQAAAABJRU5ErkJggg==\",\n      \"bgai4a08.png\", false, 32, 32, \"e2212ec5fa026a41826136e983bf92b2\");\n  testPngSuiteImage(\"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\",\n      \"bgai4a16.png\", false, 32, 32, \"f1423ebc08979252299ca238656ab0ba\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAAYagMeiWXwAAAG9JREFUeJzt1jEKgDAMRuEnZGhPofc/VQSPIcTdxUV4HVLoUCj8H00o2YoBMF57fpz/ujODHXUFRwPKBqj5DVigB041HiJ9gFyCVOMbsEIPXNwuAHkgiJL/4qABNqB7QAeUPBAE2QAZUDZAfwEb8ABSIBqcFg+4TAAAAABJRU5ErkJggg==\",\n      \"bgan6a08.png\", false, 32, 32, \"e80a60aecf13ebd863b61167ba95960b\");\n  testPngSuiteImage(\"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\",\n      \"bgan6a16.png\", false, 32, 32, \"4d9d6473bb7403d7f85e3e7537c34e9d\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAAYagMeiWXwAAAAJiS0dEAACqjSMyAAAANUlEQVR4nGP8z8DAAYWcaDQxIpws3xkoAyw/hr4Bo2EwGgZUMWA0EEfDgCoGjAbiaBhQwwAA3yogfcTrhcgAAAAASUVORK5CYII=\",\n      \"bgbn4a08.png\", false, 32, 32, \"e2212ec5fa026a41826136e983bf92b2\");\n  testPngSuiteImage(\"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\",\n      \"bggn4a16.png\", false, 32, 32, \"f1423ebc08979252299ca238656ab0ba\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAAYagMeiWXwAAAAZiS0dEAP8A/wD/oL2nkwAAAG9JREFUeJzt1jEKgDAMRuEnZGhPofc/VQSPIcTdxUV4HVLoUCj8H00o2YoBMF57fpz/ujODHXUFRwPKBqj5DVigB041HiJ9gFyCVOMbsEIPXNwuAHkgiJL/4qABNqB7QAeUPBAE2QAZUDZAfwEb8ABSIBqcFg+4TAAAAABJRU5ErkJggg==\",\n      \"bgwn6a08.png\", false, 32, 32, \"e80a60aecf13ebd863b61167ba95960b\");\n  testPngSuiteImage(\"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\",\n      \"bgyn6a16.png\", false, 32, 32, \"4d9d6473bb7403d7f85e3e7537c34e9d\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAABGdBTUEAAYagMeiWXwAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAFdUlEQVR4nLXWT6gdZxnH8e/7vjNn5sycc2ZuYpPm1nKxpdrSQmnrRlMwi5i0NpEiha6s2KZ3owZBpN3ZRTdx4aYuRBQRcRMQKcHWUltQqFAIETGNpN4QcvPn3OT+Of/m/5l5Hxcn12tKksZIXl5mM/D7PM/Dy8yrRIQ7ufQdTQecG734C//8uX37I/3xw+x4nj1f4ysGcxuAuu6IjvD2jzjqUhlyy7Dm8sPM/YwjT7D7fwWuM6IjvPcab4UEIUGHsEvYIbzAuUX2/5bXBft/dXCCS0/yRhsbYj2mDoUwqlkxXLqb1e1kezn4Er/y6NxmB6/yro8f0p6V36Mz2zFBTBARfMwffsPTFaPbAY6x9AF9n3ZAENLuEnYJe3R7dCM6EWFEJyIYcuIdDtSMbwW45hS9zoc+7TYqQIVIiPVwNFLT8ejE5DGmi+6hCk78jWe+yPsK91aB46yeZDyH76MCdAc6WJ+WQdWkPp2YsofpoSOIETixwvO7OHqTs34N8AtOe/geuo1uo0NUBxvQOKiaXkA3Zhqhe6gZMAc+f7TN97X56acDY6a/49ImYNpbTTQupiEP6UU0ESbaBLZBrxa9/kvUZ9jx2qcAx+iXmADXx/ibTXRQXayHayk69GIkQvdgDtmGRI2YdWEV1o6QzvO5xZsB7zFwaXvo2W6jA0yA6oJPC8ouUQQRKkbmkLjBrAtrwrowEM4c5rGCxw/fEHifSYt2C+2hfLSPaaMDdAcV0iimPaIYFcEcEjdiNoQ1YUMYCiNhJLz5Cu3P89BT1wH+QbaK3k7bRbvoFtpH+ZgAHaJ7iKHpEUfoGImtOIPNwmfpQ2EsDIU3XpDv/V49tPuTwJ9JXQIX3UK10K0tQweYHsqFiDxCbaZzNX1oGVrGlrFlYhmlzSvP8uN3nAcfvwY4iRg6DspBuagZ46H9q+dVh5geZWRxR1wdy9AymkUL480pjcQZZeW3nlFHPzAL920BH2Gc/wJmz5nkoQN0jNeV2p3MCrcMLUNhNqgN2FBsaIYOwxZjz5vk8tQ3ePctPjsPOBZO4Xv4BuWAQc8kB642JCq0uKkw1Iwcxj7jkHGPyRzZhCJhOsEmqAST4iS0MnU+5evf4U+/ZlvPOQdF7QeiDBjBEeUIZnNrq1SJHloSmBgSjyQggcpBPHSA28Hr0k6pU5oUmyApNuH0QJ57VR37ibM8RY+VQRmLBi1oixalLNQ0CXoVJkLSkFSkBUlOkpGmpBlZRlqQl2RTsoZcKDSFQ+ULiiDmbN+5WKLHSgvaKi0oCw1isVOqAU4fM0GShsSS1qRT0pK0JCvIcrKcPCPPyTPKnCJvpmm1s2UWDzqHntYLOwFnPUcNFRaxyCy6pikp1nAv4I5RKTZtJGlU1pBNyWuyirwiKylKioIyK6fjIRvy1S+Ei/s6B3YrZ+t64KgS2YAGLNLQVEwL8svsOI8/RGeoDEkbsobMkjcUU4op5VTKMpsOr9iLG7uq+MU984cOthd2XedT4ZSwjm2wNU1FlZKtcNcywQCToXNULpJZmzemaChtU5VJvd63Z86aJW/f/fctfvOxA3u0c8MbjXOXwq5ha+qCMiHrs/0c3QHOLL1ASmuLuqyySXP+opxc4u+D+eSBF/d+6dAP4oV7bpS7BdzrY69Q5xRj3D7xMvEAN0OXqFKmdbHSLF+R4+f48Kw5tXPf/V9++YVHD+41zs3+YtcAj+4gHpOfx/SJLjA3xMmbop70bf8CSzmnLnK8mh88+e393335hzsX7r3F3P8sJSJv/pWXDuOeqe7ONrr1spbTIv+yLDVm+Yl9Dzy7+NyeA/tvveTrAECWy8pKhUxXVy+PRutKKqgeeeTBXffM317uJ4E7t/4N+Ky7RKwdiSgAAAAASUVORK5CYII=\",\n      \"ccwn2c08.png\", false, 32, 32, \"5189ed8d023b977fa90833e90e4a830a\");\n  testPngSuiteImage(\"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\",\n      \"ccwn3p08.png\", false, 32, 32, \"1a63f18f17006d850d1c041e49a7721f\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAgAAAAgCAIAAACgkq6HAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAlwSFlzAAAAAQAAAAQAMlIwkwAAASdJREFUeJxV0mFx7DAMBOCvmRAQBVMIhVAIhaNwFPogvFI4CA2FQGggVBDcH3acNpMZja1daVfWWwWClWRvZ3OPGwGSA6YOjw5QepxgcX+lg2ZYKc7BXNip1G9f1bP6X9WqvqtMregBTk691NTCcbUYCXX19d0qbuqyVvVTDZNwdjWFJS+/c/PEw/5QZNnTGa1HIsNHeAUlEc0gztheyguRLlWN8XRs2Vv0Hm12xRGt5j2rS/qY753w6+oPI+OefuPNA/KyHuISZZYCJf+VyKVrlINR8nyw3I95MRy2XeCMwSiwK0FGSwxGODk4yyV8lgpP0o612UlTU3EtjXL5nNozrQTLr8RbxZMix9Z9cDQfxz1B2kK0WY0dabc5EtlRf0B1/Ku63McfFzN1pnMg8LcAAAAASUVORK5CYII=\",\n      \"cdfn2c08.png\", false, 8, 32, \"dbfdad37268883ddeeecc745da77130c\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAICAIAAAAX52r4AAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAlwSFlzAAAABAAAAAEAH+hVZQAAAOtJREFUeJx9kmuxwyAUhL/M1MBawEIsxEIsxEIs3FiohVjAAhaOhSMh9wePQtt0hwEG5rx2d7r4QADVxbg3eN3zxbr7iEc5BTOssJaHFtIHeleo9RDao8EBCawvIFgglN5dRIjwLLNsuHBh3RRy5AQgwSn8D2aYA+TlEEuZB+sr0EpeHJE/zl1PtshGrMPICAdz3GFNzIJoJANr8+foE6xRdAeBMJGQqhSGnE6kOzjAdPUULfjyRtECAQfXIEJmCYMY8D1T5HDU1JWi6WqdhkFkH63xZhCNIr8oPsAGkacvNu2d8YOH3ql+a9N/CM1cqmi++6QAAAAASUVORK5CYII=\",\n      \"cdhn2c08.png\", false, 32, 8, \"650268c7196860898cbe701005cf2407\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAIAAABLbSncAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAlwSFlzAAAAAQAAAAEATyXE1gAAAHtJREFUeJxFzlENwkAURNFTgoFnYS3UQisBC1gACSCBSsDCVgIroSuhlbB8NIX5mUwyubldQzCQ2KjMcBZ8zKFiP0zcaRd53Stb3n2LNWvJSVIwX/PoNvbbNlQkJ0dqRI0Qxz5Qg+VlffxQXQuyEsphFxNP3V93hxQKfAEqsC/QF17WrgAAAABJRU5ErkJggg==\",\n      \"cdsn2c08.png\", false, 8, 8, \"9e580d6237f77bfa8e49cfef19236bcb\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAlwSFlzAAAD6AAAA+gBtXtSawAAAmdJREFUeJyVluGR3CAMhb/bcQNqgRZowVeCr4RLCZsSsiXcteASQglxC7RACckPEEbYeDeandkZDHpP0hPi7S/PzIPoL1uCCBHS08O8DQEczI3TkW0Q/hdAYAb3nF2xBAHiiwAOlpddtzYIxQLM8Hl+PPNLh3L0GI8LAAdfMJvPNfqunA48+M5Zgo8+jqn8S+8aWGE7ZaoiCrB0xfKQzLFb+beCSfA99v5km3U1FfpWM48+mR6cJj93wVbTtsLvYxyaqFvBbMxKzsGnyjYTE/DwWdWWYO2K5PcgpuKkibopkoM/ZXVTWNESAyzwUU8ZebuSu6lLTuNdSjojPApDqUw93NF2D8DWJX8E0CTHg5DgJ6zMSroIdwXJTeNrPWIrXHU7tRW3endQzt7hXjwncIn5HWLUxlO2sesMgWQBkvkoGUBKLN/6PQKeOda8qIv+bhVI3AZdr6spB9L1cnTG5Rhgb7SRSa2usRcGQdl0G+zVVcnk25tEyPmhVtIGYm3SQjX7y5kEgoeVFaToKBdZr4drgFQBGm670nMFPXhCZAOPCBKr9yL7A1wPYMXV3CJb+fALZlJoejAnzNdtZc0AaENN3ajzppnXwjO7q8LfCYUK4LsU7QAN10xk2a/SBD9gAbF+K/fQhmRsBICOKo0j3/nucF3vnXEyxcNeyak4sRj3/bKqfM5fDXIcapi9OjJDv2sBacfKmTndZswOh2boC3z10dZB0PKvE+FEl+/9CLXPFn9KaT+ert9jAdZ+7fDwkiuMKwvnr4TB23Q+inJs0cjmNQD2iXkVTS7R5fNmDFCtNsDx+f6C/QMQQNfOLmy7EgAAAABJRU5ErkJggg==\",\n      \"cdun2c08.png\", false, 32, 32, \"fbe519db5608cf411e933ccbd1f92f87\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAC1QTFRFIgD/AP//iAD/Iv8AAJn//2YA3QD/d/8A/wAAAP+Z3f8A/wC7/7sAAET/AP9E0rBJvQAAAB5oSVNUAEAAcAAwAGAAYAAgACAAUAAQAIAAQAAQADAAUABwSJlZQQAAAEdJREFUeJxj6OgIDT1zZtWq8nJj43fvZs5kIEMAlSsoSI4AKtfFhRwBVO7du+QIoHEZyBFA5SopkSOAyk1LI0cAlbt7NxkCAODE6tEPggV9AAAAAElFTkSuQmCC\",\n      \"ch1n3p04.png\", false, 32, 32, \"a339593b0d82103e30ed7b00afd68816\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAAYagMeiWXwAAAwBQTFRFIkQA9f/td/93y///EQoAOncAIiL//xH/EQAAIiIA/6xVZv9m/2Zm/wH/IhIA3P//zP+ZRET/AFVVIgAAy8v/REQAVf9Vy8sAMxoA/+zc7f//5P/L/9zcRP9EZmb/MwAARCIA7e3/ZmYA/6RE//+q7e0AAMvL/v///f/+//8BM/8zVSoAAQH/iIj/AKqqAQEARAAAiIgA/+TLulsAIv8iZjIA//+Zqqr/VQAAqqoAy2MAEf8R1P+qdzoA/0RE3GsAZgAAAf8BiEIA7P/ca9wA/9y6ADMzAO0A7XMA//+ImUoAEf//dwAA/4MB/7q6/nsA//7/AMsA/5mZIv//iAAA//93AIiI/9z/GjMAAACqM///AJkAmQAAAAABMmYA/7r/RP///6r/AHcAAP7+qgAASpkA//9m/yIiAACZi/8RVf///wEB/4j/AFUAABER///+//3+pP9EZv///2b/ADMA//9V/3d3AACI/0T/ABEAd///AGZm///tAAEA//XtERH///9E/yL//+3tEREAiP//AAB3k/8iANzcMzP//gD+urr/mf//MzMAY8sAuroArP9V///c//8ze/4A7QDtVVX/qv//3Nz/VVUAAABm3NwA3ADcg/8Bd3f//v7////L/1VVd3cA/v4AywDLAAD+AQIAAQAAEiIA//8iAEREm/8z/9SqAABVmZn/mZkAugC6KlUA/8vLtP9m/5sz//+6qgCqQogAU6oA/6qqAADtALq6//8RAP4AAABEAJmZmQCZ/8yZugAAiACIANwA/5MiAADc/v/+qlMAdwB3AgEAywAAAAAz/+3/ALoA/zMz7f/t/8SIvP93AKoAZgBmACIi3AAA/8v/3P/c/4sRAADLAAEBVQBVAIgAAAAiAf//y//L7QAA/4iIRABEW7oA/7x3/5n/AGYAuv+6AHd3c+0A/gAAMwAzAAC6/3f/AEQAqv+q//7+AAARIgAixP+IAO3tmf+Z/1X/ACIA/7RmEQARChEA/xER3P+6uv//iP+IAQAB/zP/uY7TYgAAAgBoSVNUAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAARNzPXjAAABsUlEQVR4nA3BBwAIBBAAwEeojEhkKzszCWVrWGVn7xWK0LD3Kio0aJgNq2zK3qOMhp2VWTKy9767mML3FOZX+rKXptwlHuQBBnODnrzFea4TaUjJQ0zlKjs4wAUiG+n5iAa8S0U2c4p4midIS/A/01nOEeI58vMFc+jEo/zIPqI8xchOM/6hN1+ynXiVMkwmMa04wVB+IV7jBYrwE/upR3fWEE2oyiza0pgVtGcl0YaNPM/PbKMQDVlIrKYoIznKVpZwmtnEJkryOB9Ti9z8xbfETsrxFS+xlvdZz9fEISqTi/+oxCUW8xlxkhp8w6csozXfMZx4k2o8xTgqcJACpCBusoeldKAUr9CfpEQ71jGNYTxLHZIwkPiN+XzCDPLRiA+4R5QlBwPoShZakJoexCQe5j1GkY43+JwrRHKu8TrzSMbbZOUdohvHqMufJKQX4zlDHOYPqnCROwyhIB2J2qyiOKm4zIfM5DixiB/ISWnOMoYStCSq8zILuMW/3GYEzYm5PMNEMvE3iXiMXURmMjCaF9nNI4ylPjGIfvQhAb+TkSfZQpyjC53JywbyMIGa3AeBG/4Qh5bI4AAAAABJRU5ErkJggg==\",\n      \"ch2n3p08.png\", false, 32, 32, \"d36bdbefc126ef50bd57d51eb38f2ac4\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAAAd0SU1FB9ABAQwiON2c/4AAAADISURBVHicXdHBDcIwDAVQHypACPAIHaEjsAojVOLIBTEBGzACbFBGYAPYoEY9lQKfxElR4hwq58V17ZRgFiVxa4ENSJ7xmoip8bSAbQL3f80I/LXg358J0Y09LBS4ZuxPSwrnB6DQdI7AKMjvBeSS1x6m7UYLO+hQuoCvvnt4cOddAzmHLwdwjyokKOwq6Xns1YOg1/4e2unn6ED3Q7wgEglj1HEWnotO21UjhCkxMbcujYEVchDk8GYDF+QwsIHkZ2gopYF0/QAe2cJF+P+JawAAAABJRU5ErkJggg==\",\n      \"cm0n0g04.png\", false, 32, 32, \"cf2f1ab4f34d0c70f15f636ef584d53a\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAAAd0SU1FB7IBAQAAAB4KVgsAAADISURBVHicXdHBDcIwDAVQHypACPAIHaEjsAojVOLIBTEBGzACbFBGYAPYoEY9lQKfxElR4hwq58V17ZRgFiVxa4ENSJ7xmoip8bSAbQL3f80I/LXg358J0Y09LBS4ZuxPSwrnB6DQdI7AKMjvBeSS1x6m7UYLO+hQuoCvvnt4cOddAzmHLwdwjyokKOwq6Xns1YOg1/4e2unn6ED3Q7wgEglj1HEWnotO21UjhCkxMbcujYEVchDk8GYDF+QwsIHkZ2gopYF0/QAe2cJF+P+JawAAAABJRU5ErkJggg==\",\n      \"cm7n0g04.png\", false, 32, 32, \"cf2f1ab4f34d0c70f15f636ef584d53a\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAAAd0SU1FB88MHxc7O3UwH+AAAADISURBVHicXdHBDcIwDAVQHypACPAIHaEjsAojVOLIBTEBGzACbFBGYAPYoEY9lQKfxElR4hwq58V17ZRgFiVxa4ENSJ7xmoip8bSAbQL3f80I/LXg358J0Y09LBS4ZuxPSwrnB6DQdI7AKMjvBeSS1x6m7UYLO+hQuoCvvnt4cOddAzmHLwdwjyokKOwq6Xns1YOg1/4e2unn6ED3Q7wgEglj1HEWnotO21UjhCkxMbcujYEVchDk8GYDF+QwsIHkZ2gopYF0/QAe2cJF+P+JawAAAABJRU5ErkJggg==\",\n      \"cm9n0g04.png\", false, 32, 32, \"cf2f1ab4f34d0c70f15f636ef584d53a\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAIAAACsiDHgAAAABGdBTUEAAYagMeiWXwAAAANzQklUDQ0N0DeNwQAAAH5JREFUeJztl8ENxEAIAwcJ6cpI+q8qKeNepAgelq2dCjz4AdQM1jRcf3WIDQ13qUNsiBBQZ1gR0cARUFIz3pug3586wo5+rOcfIaBOsCSggSOgpcB8D4D3R9DgfUyECIhDbAhp4AjoKPD+CBq8P4IG72MiQkCdYUVEA0dAyQcwUyZpXH92ZwAAAABJRU5ErkJggg==\",\n      \"cs3n2c16.png\", false, 32, 32, \"023541189afc3aa4ae617158b59fe635\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAAYagMeiWXwAAAANzQklUAwMDo5KgQgAAAFRQTFRFkv8AAP+SAP//AP8AANv/AP9t/7YAAG3/tv8A/5IA2/8AAEn//yQA/wAAJP8ASf8AAP/bAP9JAP+2//8AAP8kALb//9sAAJL//20AACT//0kAbf8A33ArFwAAAEtJREFUeJyFyscBggAAALGzYldUsO2/pyMk73SGGE7QF3pDe2gLzdADHA7QDqIfdIUu0AocntAIbaAFdIdu0BIc1tAEvaABOkIf+AMiQDPhd/SuJgAAAABJRU5ErkJggg==\",\n      \"cs3n3p08.png\", false, 32, 32, \"6b15613bf70a37c37de24edfb8f6d1df\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAABGdBTUEAAYagMeiWXwAAAANzQklUBQUFGCbeQwAAAGJJREFUeJztlbERgEAMw5Q7L0EH+w/Fd4zxbEAqUUUDROfCcW1cwmELLltw2gI9wQgaastFyOPeJ7ctWLZATzCCjsLuAfIgBPlXBHkQ/kgwgm8KeRCCPAhB/hVh2QI9wQgaXuXOFG8QELloAAAAAElFTkSuQmCC\",\n      \"cs5n2c08.png\", false, 32, 32, \"3211fb3ede03caf163fe33b4cf6d78f6\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAAYagMeiWXwAAAANzQklUBQUFGCbeQwAAAGBQTFRF/xkAQv8Axf8AAP97AP+9AP//AP8AAMX/AKX//94Apf8AAGP//5wAACH//1oAAP86/zoAY/8A5v8A/wAAAP9aIf8AAP+cAP/eAOb///8AAIT//70AAEL//3sAhP8AAP8ZRy+F9QAAAEtJREFUeJyFwQUBwAAAgDDu7u79Wz4CG5NA9YJW8AhqwSUoBIdgFISCUvAKBkEgWASp4BN0glkQCVZBLNgEiWAXZIJccAoqwS1oxA/GcT4B7dbxuwAAAABJRU5ErkJggg==\",\n      \"cs5n3p08.png\", false, 32, 32, \"3211fb3ede03caf163fe33b4cf6d78f6\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAABGdBTUEAAYagMeiWXwAAAExJREFUeJzt1UENADAMQlGa4GPzr2pT0olo/mkgoO9EqRYba9HADhBgmGq4CL7sffkECDBNie6B4EGw4F8R4AOgBA+CBQ+CdQIEGOYB69wUb0ah5KoAAAAASUVORK5CYII=\",\n      \"cs8n2c08.png\", false, 32, 32, \"023541189afc3aa4ae617158b59fe635\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAAYagMeiWXwAAAGBQTFRFIP8A/x8AAP8fAP/foP8AAP8/AP//AP8AgP8AAP9fAP9/YP8A/wAA4P8AAP+fAOD/QP8A//8AAMD//98AAKD//78AAID/wP8AAP+//58AAGD//38AAED//18AACD//z8As4GzYwAAAEtJREFUeJyFwQUBwAAAgDDu7u79Wz4CG7UgEHyCR3AJDsEimASDoBFsgliQCypBL1CZIBQkgkJQClrBLogEqaATjIJZsApOwS14xQ8p4j4B+PNT2QAAAABJRU5ErkJggg==\",\n      \"cs8n3p08.png\", false, 32, 32, \"023541189afc3aa4ae617158b59fe635\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAAMhJREFUeJxd0cENwjAMBVAfKkAI8AgdoSOwCiNU4sgFMQEbMAJsUEZgA9igRj2VAp/ESVHiHCrnxXXtlGAWJXFrgQ1InvGaiKnxtIBtAvd/zQj8teDfnwnRjT0sFLhm7E9LCucHoNB0jsAoyO8F5JLXHqbtRgs76FC6gK++e3hw510DOYcvB3CPKiQo7CrpeezVg6DX/h7a6efoQPdDvCASCWPUcRaei07bVSOEKTExty6NgRVyEOTwZgMX5DCwgeRnaCilgXT9AB7ZwkX4/4lrAAAAAElFTkSuQmCC\",\n      \"ct0n0g04.png\", false, 32, 32, \"cf2f1ab4f34d0c70f15f636ef584d53a\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAAA50RVh0VGl0bGUAUG5nU3VpdGVPVc9MAAAAMXRFWHRBdXRob3IAV2lsbGVtIEEuSi4gdmFuIFNjaGFpawood2lsbGVtQHNjaGFpay5jb20pjsxHHwAAADh0RVh0Q29weXJpZ2h0AENvcHlyaWdodCBXaWxsZW0gdmFuIFNjaGFpaywgU2luZ2Fwb3JlIDE5OTUtOTaEUAQ4AAAA+3RFWHREZXNjcmlwdGlvbgBBIGNvbXBpbGF0aW9uIG9mIGEgc2V0IG9mIGltYWdlcyBjcmVhdGVkIHRvIHRlc3QgdGhlCnZhcmlvdXMgY29sb3ItdHlwZXMgb2YgdGhlIFBORyBmb3JtYXQuIEluY2x1ZGVkIGFyZQpibGFjayZ3aGl0ZSwgY29sb3IsIHBhbGV0dGVkLCB3aXRoIGFscGhhIGNoYW5uZWwsIHdpdGgKdHJhbnNwYXJlbmN5IGZvcm1hdHMuIEFsbCBiaXQtZGVwdGhzIGFsbG93ZWQgYWNjb3JkaW5nCnRvIHRoZSBzcGVjIGFyZSBwcmVzZW50Lk0JDWsAAAA5dEVYdFNvZnR3YXJlAENyZWF0ZWQgb24gYSBOZVhUc3RhdGlvbiBjb2xvciB1c2luZyAicG5tdG9wbmciLmoSZHkAAAAUdEVYdERpc2NsYWltZXIARnJlZXdhcmUuX4AsSgAAAMhJREFUeJxd0cENwjAMBVAfKkAI8AgdoSOwCiNU4sgFMQEbMAJsUEZgA9igRj2VAp/ESVHiHCrnxXXtlGAWJXFrgQ1InvGaiKnxtIBtAvd/zQj8teDfnwnRjT0sFLhm7E9LCucHoNB0jsAoyO8F5JLXHqbtRgs76FC6gK++e3hw510DOYcvB3CPKiQo7CrpeezVg6DX/h7a6efoQPdDvCASCWPUcRaei07bVSOEKTExty6NgRVyEOTwZgMX5DCwgeRnaCilgXT9AB7ZwkX4/4lrAAAAAElFTkSuQmCC\",\n      \"ct1n0g04.png\", false, 32, 32, \"cf2f1ab4f34d0c70f15f636ef584d53a\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAABlpVFh0VGl0bGUAAABlbgBUaXRsZQBQbmdTdWl0ZdWsxR4AAAA4aVRYdEF1dGhvcgAAAGVuAEF1dGhvcgBXaWxsZW0gdmFuIFNjaGFpayAod2lsbGVtQHNjaGFpay5jb20pRVcgpAAAAEFpVFh0Q29weXJpZ2h0AAAAZW4AQ29weXJpZ2h0AENvcHlyaWdodCBXaWxsZW0gdmFuIFNjaGFpaywgQ2FuYWRhIDIwMTHS6zPBAAABDGlUWHREZXNjcmlwdGlvbgAAAGVuAERlc2NyaXB0aW9uAEEgY29tcGlsYXRpb24gb2YgYSBzZXQgb2YgaW1hZ2VzIGNyZWF0ZWQgdG8gdGVzdCB0aGUgdmFyaW91cyBjb2xvci10eXBlcyBvZiB0aGUgUE5HIGZvcm1hdC4gSW5jbHVkZWQgYXJlIGJsYWNrJndoaXRlLCBjb2xvciwgcGFsZXR0ZWQsIHdpdGggYWxwaGEgY2hhbm5lbCwgd2l0aCB0cmFuc3BhcmVuY3kgZm9ybWF0cy4gQWxsIGJpdC1kZXB0aHMgYWxsb3dlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWMgYXJlIHByZXNlbnQufjUNRAAAAEdpVFh0U29mdHdhcmUAAABlbgBTb2Z0d2FyZQBDcmVhdGVkIG9uIGEgTmVYVHN0YXRpb24gY29sb3IgdXNpbmcgInBubXRvcG5nIi7EGQUHAAAAJGlUWHREaXNjbGFpbWVyAAAAZW4ARGlzY2xhaW1lcgBGcmVld2FyZS7TvjIJAAAATElEQVQokWP4DwbGxi4uoaFpaeXlDGQJKCkhuB0d5An8/4/gzpxJngDcSRBAlgAIQAxctYo8AYSTwFyyBBDc3bvPnCFPAMGFeo50AQDds/NRVdY0lwAAAABJRU5ErkJggg==\",\n      \"cten0g04.png\", false, 32, 32, \"ac076245d12023e111ec36acb36dcff1\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAABtpVFh0VGl0bGUAAABmaQBPdHNpa2tvAFBuZ1N1aXRl8x/ISQAAADlpVFh0QXV0aG9yAAAAZmkAVGVraWrDpABXaWxsZW0gdmFuIFNjaGFpayAod2lsbGVtQHNjaGFpay5jb20pTbKY1QAAAEhpVFh0Q29weXJpZ2h0AAAAZmkAVGVraWrDpG5vaWtldWRldABDb3B5cmlnaHQgV2lsbGVtIHZhbiBTY2hhaWssIEthbmFkYSAyMDExGP2/hwAAAOtpVFh0RGVzY3JpcHRpb24AAABmaQBLdXZhdXMAa29rb2VsbWEgam91a29uIGt1dmlhIGx1b3R1IHRlc3RhdGEgZXJpIHbDpHJpLXR5eXBwaXNpw6QgUE5HLW11b2Rvc3NhLiBNdWthbmEgb24gbXVzdGF2YWxrb2luZW4sIHbDpHJpLCBwYWxldHRlZCwgYWxwaGEta2FuYXZhLCBhdm9pbXV1ZGVuIG11b2Rvc3NhLiBLYWlra2kgYml0LXN5dnl5ZGVzc8OkIG11a2FhbiBzYWxsaXR0dWEgc3BlYyBvbiDigIvigItsw6RzbsOkLsc2cVkAAAA/aVRYdFNvZnR3YXJlAAAAZmkAT2hqZWxtaXN0b3QATHVvdHUgTmVYVHN0YXRpb24gdsOkcmnDpCAicG5tdG9wbmciLlFtpV0AAAAtaVRYdERpc2NsYWltZXIAAABmaQBWYXN0dXV2YXBhdXNsYXVzZWtlAEZyZWV3YXJlLvx3Hi8AAABISURBVCiRY/gPBsbGLi6hoWlp5eUMZAkoKSG4HR3kCfz/j+DOnEmeAAqXgTwBBHfVKvIE0LhkCSC4u3efOUOeAILLAAGkCwAA+XLyQRLQxL0AAAAASUVORK5CYII=\",\n      \"ctfn0g04.png\", false, 32, 32, \"0428cabaa4c89cb12cd5cf0f269a0ff1\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAACBpVFh0VGl0bGUAAABlbADOpM6vz4TOu86/z4IAUG5nU3VpdGUgh0C5AAAARmlUWHRBdXRob3IAAABlbADOo8+FzrPOs8+BzrHPhs6tzrHPggBXaWxsZW0gdmFuIFNjaGFpayAod2lsbGVtQHNjaGFpay5jb20p1io2ZgAAAIlpVFh0Q29weXJpZ2h0AAAAZWwAzqDOvc61z4XOvM6xz4TOuc66zqwgzrTOuc66zrHOuc+OzrzOsc+EzrEAzqDOvc61z4XOvM6xz4TOuc66zqwgzrTOuc66zrHOuc+OzrzOsc+EzrEgU2NoYWlrIHZhbiBXaWxsZW0sIM6azrHOvc6xzrTOrM+CIDIwMTHXI+R2AAAB9WlUWHREZXNjcmlwdGlvbgAAAGVsAM6gzrXPgc65zrPPgc6xz4bOrgDOnM65zrEgz4PPhc67zrvOv86zzq4gzrHPgM+MIM6tzr3OsSDPg8+Nzr3Ov867zr8gzrXOuc66z4zOvc+Jzr0gz4DOv8+FIM60zrfOvM65zr/Phc+BzrPOrs64zrfOus6xzr0gzrPOuc6xIM+EzrcgzrTOv866zrnOvM6uIM+Ez4nOvSDOtM65zrHPhs+Mz4HPic69IM+Hz4HPic68zqzPhM+Jzr0tz4TPjc+Az4nOvSDPhM6/z4UgzrzOv8+Bz4bOriBQTkcuIM6gzrXPgc65zrvOsc68zrLOrM69zr/Ovc+EzrHOuSDOv865IM6xz4PPgM+Bz4zOvM6xz4XPgc61z4IsIM+Hz4HPjs68zrEsIHBhbGV0dGVkLCDOvM61IM6szrvPhs6xIM66zrHOvc6szrvOuSwgzrzOtSDOvM6/z4HPhs6tz4Igz4TOt8+CIM60zrnOsc+GzqzOvc61zrnOsc+CLiDOjM67zr/OuSDOu86vzrPOvy3Oss6szrjOtyDOtc+AzrnPhM+Bzq3PgM61z4TOsc65IM+Dz43OvM+Gz4nOvc6xIM68zrUgz4TOvyBzcGVjIM61zq/Ovc6xzrkgz4DOsc+Bz4zOvc+EzrXPgi6miCkYAAAAiWlUWHRTb2Z0d2FyZQAAAGVsAM6bzr/Os865z4POvM65zrrPjADOlM63zrzOuc6/z4XPgc6zzq7OuM63zrrOtSDPg861IM6tzr3OsSDPh8+Bz47OvM6xIE5lWFRzdGF0aW9uIM+Hz4HOt8+DzrnOvM6/z4DOv865z47Ovc+EzrHPgiAicG5tdG9wbmciLkN4y+sAAABDaVRYdERpc2NsYWltZXIAAABlbADOkc+Azr/PgM6/zq/Ot8+DzrcAzpTPic+BzrXOrM69IM67zr/Os865z4POvM65zrrPjC4snq9sAAAAXUlEQVQokZ3OQREAIQxD0WjBAhawgAUsYKEWsFALWEALFrLTnd3pPcf/DpkAIEuptbXex5gTAkSSf5ppkINma2nQGvl9hLsCkeR7KRIK5CX3vTXIBM7RIAcj7xXgAUU58kEPspNFAAAAAElFTkSuQmCC\",\n      \"ctgn0g04.png\", false, 32, 32, \"32546f7ef2cce19fcbaa6b8849592c38\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAACZpVFh0VGl0bGUAAABoaQDgpLbgpYDgpLDgpY3gpLfgpJUAUG5nU3VpdGVT/Uu3AAAAPmlUWHRBdXRob3IAAABoaQDgpLLgpYfgpJbgpJUAV2lsbGVtIHZhbiBTY2hhaWsgKHdpbGxlbUBzY2hhaWsuY29tKc9NfecAAABoaVRYdENvcHlyaWdodAAAAGhpAOCkleClieCkquClgOCksOCkvuCkh+CknwDgpJXgpYngpKrgpYDgpLDgpL7gpIfgpJ8gV2lsbGVtIHZhbiBTY2hhaWssIDIwMTEg4KSV4KSo4KS+4KSh4KS+3xTVhQAAAmVpVFh0RGVzY3JpcHRpb24AAABoaQDgpLXgpL/gpLXgpLDgpKMA4KSV4KSw4KSo4KWHIOCkleClhyDgpLLgpL/gpI8gUE5HIOCkquCljeCksOCkvuCksOClguCkqiDgpJXgpYcg4KS14KS/4KSt4KS/4KSo4KWN4KSoIOCksOCkguCklyDgpKrgpY3gpLDgpJXgpL7gpLAg4KSq4KSw4KWA4KSV4KWN4KS34KSjIOCkrOCkqOCkvuCkr+CkviDgpJvgpLXgpL/gpK/gpYvgpIIg4KSV4KS+IOCkj+CklSDgpLjgpYfgpJ8g4KSV4KS+IOCkj+CklSDgpLjgpILgpJXgpLLgpKguIOCktuCkvuCkruCkv+CksiDgpJXgpL7gpLLgpYcg4KSU4KSwIOCkuOCkq+Clh+Ckpiwg4KSw4KSC4KSXLCDgpKrgpYjgpLLgpYfgpJ/gpYfgpKEg4KS54KWI4KSCLCDgpIXgpLLgpY3gpKvgpL4g4KSa4KWI4KSo4KSyIOCkleClhyDgpLjgpL7gpKUg4KSq4KS+4KSw4KSm4KSw4KWN4KS24KS/4KSk4KS+IOCkuOCljeCkteCksOClguCkquCli+CkgiDgpJXgpYcg4KS44KS+4KSlLiDgpLjgpK3gpYAg4KSs4KS/4KSfIOCkl+CkueCksOCkvuCkiCDgpJXgpLLgpY3gpKrgpKjgpL4g4KSV4KWHIOCkheCkqOClgeCkuOCkvuCksCDgpJXgpYAg4KSF4KSo4KWB4KSu4KSk4KS/IOCkpuClgCDgpK7gpYzgpJzgpYLgpKYg4KS54KWI4KSCLvrUkQYAAACRaVRYdFNvZnR3YXJlAAAAaGkA4KS44KWJ4KSr4KWN4KSf4KS14KWH4KSv4KSwAOCkj+CklSBOZVhUc3RhdGlvbiAicG5tdG9wbmcgJ+CkleCkviDgpIngpKrgpK/gpYvgpJcg4KSV4KSwIOCksOCkguCklyDgpKrgpLAg4KSs4KSo4KS+4KSv4KS+IOCkl+Ckr+Ckvi4VxVHXAAAAQmlUWHREaXNjbGFpbWVyAAAAaGkA4KSF4KS44KWN4KS14KWA4KSV4KSw4KSjAOCkq+CljeCksOClgOCkteClh+Ckr+CksC4tT0C7AAAAYElEQVQokWP4/19Q8P9/Y2MXl9DQtLTycgayBJSU/v+HcTs6yBMAARh35kzyBFxc/v8HO4kByGUgTyA09P9/sJMYVq0iTwDJSRBAhgCMCzLwzBnyBGDc3bsZGO7eJUsAAEBI89kMzfvBAAAAAElFTkSuQmCC\",\n      \"cthn0g04.png\", false, 32, 32, \"c570e7393458556ecef30b71824e0d6e\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAACBpVFh0VGl0bGUAAABqYQDjgr/jgqTjg4jjg6sAUG5nU3VpdGUPGlwCAAAAOGlUWHRBdXRob3IAAABqYQDokZfogIUAV2lsbGVtIHZhbiBTY2hhaWsgKHdpbGxlbUBzY2hhaWsuY29tKeXxzKEAAABTaVRYdENvcHlyaWdodAAAAGphAOacrOaWh+OBuADokZfkvZzmqKnjgqbjgqPjg6zjg6Djg7TjgqHjg7Pjgrfjg6PjgqTjgq/jgIHjgqvjg4rjg4AyMDExhF9tvgAAAXdpVFh0RGVzY3JpcHRpb24AAABqYQDmpoLopoEAUE5H5b2i5byP44Gu5qeY44CF44Gq6Imy44Gu56iu6aGe44KS44OG44K544OI44GZ44KL44Gf44KB44Gr5L2c5oiQ44GV44KM44Gf44Kk44Oh44O844K444Gu44K744OD44OI44Gu44Kz44Oz44OR44Kk44Or44CC5ZCr44G+44KM44Gm44GE44KL44Gu44Gv6YCP5piO5bqm44Gu44OV44Kp44O844Oe44OD44OI44Gn44CB44Ki44Or44OV44Kh44OB44Oj44ON44Or44KS5oyB44Gk44CB55m96buS44CB44Kr44Op44O844CB44OR44Os44OD44OI44Gn44GZ44CC44GZ44G544Gm44Gu44OT44OD44OI5rex5bqm44GM5a2Y5Zyo44GX44Gm44GE44KL5LuV5qeY44Gr5b6T44Gj44Gf44GT44Go44GM44Gn44GN44G+44GX44Gf44CCwwUNtAAAAGNpVFh0U29mdHdhcmUAAABqYQDjgr3jg5Xjg4jjgqbjgqfjgqIAInBubXRvcG5nIuOCkuS9v+eUqOOBl+OBpk5lWFRzdGF0aW9u6Imy5LiK44Gr5L2c5oiQ44GV44KM44G+44GZ44CCwoP4MAAAADJpVFh0RGlzY2xhaW1lcgAAAGphAOWFjeiyrOS6i+mghQDjg5Xjg6rjg7zjgqbjgqfjgqLjgIJ28EPmAAAAZUlEQVQokWNgYPgPBMbGLi6hoWlp5eUMZAgICiop/f8P43Z0kCOgpGRs/P8/jDtzJjkCIAP//4cayLBqFTkCaFwGcgSQnMSwe/eZM+QIwLggA8+cuXuXHAEYd/duoKMY3r0jQwAATn/xuQxIlj4AAAAASUVORK5CYII=\",\n      \"ctjn0g04.png\", false, 32, 32, \"81fd25285e6b46f3996cfd02b1f16071\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAAA50RVh0VGl0bGUAUG5nU3VpdGVPVc9MAAAAMXRFWHRBdXRob3IAV2lsbGVtIEEuSi4gdmFuIFNjaGFpawood2lsbGVtQHNjaGFpay5jb20pjsxHHwAAAEF6VFh0Q29weXJpZ2h0AAB4nHPOL6gsykzPKFEIz8zJSc1VKEvMUwhOzkjMzNZRCM7MS08syC9KVTC0tDTVtTQDAIthD6RSWpQSAAAAu3pUWHREZXNjcmlwdGlvbgAAeJwtjrEOwjAMRPd+xU1Mpf/AhFgQv2BcQyLcOEoMVf8eV7BZvnt3dwLbUrOSZyuwBwhdfD/yQk/p4CbkMsMNLt3hSYYPtWzv0EytHX2r4QsiJNyuZzysLeQTLoX1PQdLTYa7Er8Oa8ou4w8cUUnFI3zEmj2BtCYCJypF9PcbvFHpNQIKb//gPuGkinv24yzVUw9Qbd17mK3NuTyHfW2s6VV4b0dt0qX49AUf8lYE8mJ6iAAAAEB6VFh0U29mdHdhcmUAAHiccy5KTSxJTVHIz1NIVPBLjQgpLkksyQTykvNz8osUSosz89IVlAryckvyC/LSlfQApuwRQp5RqK4AAAAdelRYdERpc2NsYWltZXIAAHiccytKTS1PLErVAwARVQNg1K617wAAAMhJREFUeJxd0cENwjAMBVAfKkAI8AgdoSOwCiNU4sgFMQEbMAJsUEZgA9igRj2VAp/ESVHiHCrnxXXtlGAWJXFrgQ1InvGaiKnxtIBtAvd/zQj8teDfnwnRjT0sFLhm7E9LCucHoNB0jsAoyO8F5JLXHqbtRgs76FC6gK++e3hw510DOYcvB3CPKiQo7CrpeezVg6DX/h7a6efoQPdDvCASCWPUcRaei07bVSOEKTExty6NgRVyEOTwZgMX5DCwgeRnaCilgXT9AB7ZwkX4/4lrAAAAAElFTkSuQmCC\",\n      \"ctzn0g04.png\", false, 32, 32, \"cf2f1ab4f34d0c70f15f636ef584d53a\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAD0mVYSWZNTQAqAAAACAAHARIAAwAAAAEAAQAAARoABQAAAAEAAABiARsABQAAAAEAAABqASgAAwAAAAEAAgAAAhMAAwAAAAEAAQAAgpgAAgAAABcAAAByh2kABAAAAAEAAACKAAAA3AAAAEgAAAABAAAASAAAAAEyMDE3IFdpbGxlbSB2YW4gU2NoYWlrAAAABZAAAAcAAAAEMDIyMJEBAAcAAAAEAQIDAJKGAAcAAAAQAAAAzKAAAAcAAAAEMDEwMKABAAMAAAAB//8AAAAAAABBU0NJSQAAAFBuZ1N1aXRlAAYBAwADAAAAAQAGAAABGgAFAAAAAQAAASoBGwAFAAAAAQAAATIBKAADAAAAAQACAAACAQAEAAAAAQAAAToCAgAEAAAAAQAAApcAAAAAAAAASAAAAAEAAABIAAAAAf/Y/+AAEEpGSUYAAQEAAAEAAQAA/9sAQwADAgIDAgIDAwMDBAMDBAUIBQUEBAUKBwcGCAwKDAwLCgsLDQ4SEA0OEQ4LCxAWEBETFBUVFQwPFxgWFBgSFBUU/9sAQwEDBAQFBAUJBQUJFA0LDRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU/8AAEQgACAAIAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+7EGoxTRqz3ySM6AuwITn7+fbkf04ooor+Y6k27M66VCLWrb+Z//2QC6iKqDAAAC5UlEQVRIib2W3W8SQRDA+a/HEBONGqPGRNP4YNQ3EyUYTUqQKjbVBx5IpbRQwCscl+OA40NCkQbK5+HM7ma5u3K5WsBkc5ndvZnf7uzuzAQWC9hqC/wnwMUFGAaUy6INhzRomqKraVCpQLsN4zFYFk1Np9Dp0CBOVauk7gMYjUih1QJddwPw22wSHm2hPJnAbEYCdnGw0aAv6l7XRdyoHcBlNFqrkdHLS+j1aB1IRRhO4Z64sDEAbhSFfl+4y/8MvpkAKUdLtqA3JuHxsXCRZkAwBXfS5MxI2f0/IlfaOfztDcDxJ1mST1Vab6JE8luVVn0VgBu9CSBcJPlnm+RYTSigHNX+BYDO3TOok2hBZwiKATkV+szvSZ3GQxrJzwskd8ckt7uQ1yBUEFpFwwFIMPfyNp0zQESlie+a4y6iglEnvz/IQH8Ct1LwNCfODVXwdobzpHWgipstAWnnlQ3M5xBjK/3yS1jHe8KvB8o7JzTF/bNrLNXwoXFHfVVoWd2uN8BrgrcfDZq6naZvoeeYuqp1E0B9II4reASj2XoAe5MvyFrAfeall4qb7QWwt5nlB8D2nvl639wa4A17DRFjbYD9/kqdiSVOWN5RX4DdjuV7yMU/y+XYwRu7RdEqTT1kQemwswXAs7wIKfh9p20UgM/4lIWQR8dQ1ukd3Duhw+dJAuNzrEKz8bNlzoizBx9XHHl09SFP5mRoj4WzEAsGOxmS9T6NKyrkNPjI8FEFsiUCyJi2X3Lk0dXXFH2Chl4z1ys9Uv7MlA9MGg/n3P8jAPPoJ4XkFAvpMo96Auom3E1DME27QUCGhfRXZ54AdNqHwrVDBQKyzOKLnCgpyhrjHYFeWw2Q4GRTFCg8j3oWXvaiiNcQmI3lIXOLGKV5NcW7XBgMliWWP4Bfj5Xj5+d0mLKOcpUa/Le1ALghLGRkJegqljYAQJnKGU10eR7lLwD/kXl0LQA6BMtT2eUFK0/sMo9uvbr+CztK5Y3mPSskAAAAAElFTkSuQmCC\",\n      \"exif2c08.png\", false, 32, 32, \"7acea6df2b0e2a7613981decc569b2fb\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAAAAABWESUoAAABBklEQVR4nIXSL0xCURTH8a/gGHNjBjc3AoFioFhIr7z0molmsxFpVCONSLPRbCYSiWKxWAwWN4ObG5ubcwzk6f3jds71hXPr/eye3/3dy/VkOruZ394tlqv7h8en55fXt/f1x+fXZrv73pflD2NDMDIEQ0NwZQguDcHAEFwYgkILwkoEuRJQFWQi3Jafkgr6IiDmAJWDcxEQkroTVFJ6IsAn9SHUXTgTgX+5kFLdlq4I8DlwZ6g+6IgANwV/W9UYbRHh9DBFdcqpCL8f+1CtcyLC7Sd9BMGxCEj6iIKWCKIg9vEnOEpFWPr1aVZF8j9oJCLLi38/iENDUDcENUNwYAgsgSWwxC/EfcpYUKbOtgAAAABJRU5ErkJggg==\",\n      \"f00n0g08.png\", false, 32, 32, \"f34b8a71205dc26cd37d58fb19179172\");\n  testPngSuiteImage(\"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\",\n      \"f00n2c08.png\", false, 32, 32, \"d70ea8925988413a9fe9de1633a31033\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAAAAABWESUoAAABCElEQVR4nIXSIUvEQRAF8Pd2dnb2BDEIgsFgMVgsJovJZhIMNsFgFC4IpuOSYDi4IlwQDIJBMIjB5Cew+I0MHvff2bC7+ce+meFxki2bmaWUVFWjShQRCSGQJMjbUUfcWFvwOnfEpXXEhXXEmXXEaWoLnpgT5/j2gsepFFfAl/+DR1qIMYAPn8LDNIgpALz5OXigKzEHZmO8+Em5ryuxwCTf4cnvwr04iGyjKR79ttxVJx4w8/fgTnRijnt/MW5HJxaoGsQtceIZVYO4KU68omoQN6IT76gaxPXgxCeqBnFNBvGD/1emMIdB/C5BmcIUClHedCkYQ1tQ2BYMbAuSbUF0BNERREf8AZVRLIMTf6sKAAAAAElFTkSuQmCC\",\n      \"f01n0g08.png\", false, 32, 32, \"38446c18ff7e0ca3951b7ad5fa5e81c0\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAEY0lEQVR4nK2WP+wlVRmGn/f8/c6cM+fsCDQEIhRYidlCY4GRBBIrsdCQmFCwncZGCk0oLGhIKCgsjDGxojBWkoCxNdBSkKWl2cJCowkNJSzXYu7cndn97Yagk6d4zzfJfZtv7nN0wrCM2ZliV+ev9qqYPnk8L07kTLYzZlfnr/RKt76bR2AJImWS3SHb/+Womy+kkTQiSxYxE+1Asv9xovdvxJEZppFZigi2IxMKwYi7fN95Jtg2v5P111+GXjQKY9IoLFV425Hx5ZDDfeZrCHYne8MX/ek3oU/0SaMymkZlmYWzHRlXHpT9fp5xts/6w+thbvRKnzUao2vMLEPIdmRUvnTOyC5Zb77pW2Oe6V29MwZjaAyWRWB3IX0AnE4/uvfV/dArr/naqI0607paZx70oXkwFgm78Jg+BoB/nX4A5rb5lRlMa/7pr51VlcbUKDO1a+rUQRuqg3mRwxz2Pf2b7fnw9P11+GXQc79wuZIr1siNMss6pVOGpkEZ1EU39Bm7593Tdzx2PwJlf9T1lxWrYiVVUiM18qzcyZ08ZIPfPvn5+rtvnB55Vf8Bfnd6OmB74vEYKJesJ15UmPBVsRIqoREbcVbsxE4aevf658CNU4zYH/Up8KvTUxFbSVu4i0RZgx76oVzBT7gqX/EV3/ANPyt0fCcMhYEfxEXv6TPgx6fHE7aSt3DVpCRM9rxUUMFNqKKKq1LDNTTjOq7LDdxAg3987TbwrdPDGcvbv3zeYZTj0cQzyKBAgQkqVFShQYMZOuowYHD7SYB2epAKyvEovp3IkokiiphEFdWpiuZoYnZ0qTuGu339n0A4ff3BKii7o/hmxUR2mKM4Fc/kqJ7qqJ7maZ7Zqwe6/+LZjwD3yTNawtEAZwmUe5wgvtFJDvNkj3mKVwlMnhrOtEgLzFE9fvHC3wF36yeMqCXf44FopHKciCcGKZA85snrEkeVwBSpkZqokZZomTmdXnobcDd/xjBG1lLsKBA7eyBesnj02rkgBSySIxYpUSUxJWqmJqrRMs1OP38LcO+/yiiMiVG0VDsKZOXiCvHINaInRVIgRSyS1yXOlMyUqcbv3+GqR7f+zKhaZjsKxHbSENc6MRAjaSVhiZyxTDGKMRlv/eXqgpt/Y3TGrGXYUSAXIYh5xntiJEZSOmNGXr+bQilME7VSq2qlNTaBsAmEMbQs99qggLCCD3hPiMRITMS1xs6XJStYoUyUSqlMlZ1A2ATCPDQW2wsEikOEhPe4rcNHYiKsNUbM5/3OBZvIlVKxyk4gbAKhDs3LXUIQLuAc8viA8/iIj4SET8R0voOc97uQJ1LlKBA2gTANylBd9n4QchseF3AeF/ERn84Ew2fiut+FOBErR4GwCQQb5KGyXMwgVi4d2joU8QmXcGl/zyEUwoSvHAXCJhDSIA7ysppB676dO9g65FFEEZfQWmMo49cVPwuEo0DYBMImEEvngq2DrYOAPEQUUYKE0vHOcxAIR4FwEYhf/gtC7nstgnuX5wAAAABJRU5ErkJggg==\",\n      \"f01n2c08.png\", false, 32, 32, \"a9081889af0c30f206d793919792a0b6\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAAAAABWESUoAAABKklEQVR4nIXRL0uDURgF8MP5OBaLIIggCIJBDAODTdgHGCxYh0kwDFYEwwsLA8Ng4U2CYBLBYrEYLIJBEARB9H3uX8Om97nvwr35x+Wc83BwOjyvJtP66ub2/uHx6fnl9e394/PruzHW+RAifxppRESMMdZa66x33nsfQogxRkRKQbApCEpBUAqCUhA0BUHR4mB/d3tzPRM0SnQBAMgEbRJ9oJpM61zQJAEMRURqQOWgTQKYJwVUUtokesfzLoDqQqfEogug2tIuiS6g9qBriz5QqcXoWuJk0eVP0OdiBAyy1ekzMQZ6+V3otJgBR63LMShxDXTat6VP4g7A7HJ8MTpTgiEJ/D/1B0MSK6trG1s7e51DnYNBieXVRRgLgrEgGAuCsSCIgiAK4hfp5Je/v8zr/QAAAABJRU5ErkJggg==\",\n      \"f02n0g08.png\", false, 32, 32, \"9af1c44cbb489e5385f422d047612dfc\");\n  testPngSuiteImage(\"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\",\n      \"f02n2c08.png\", false, 32, 32, \"14658e750fd12c4777c46a949bb3399c\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAAAAABWESUoAAABTElEQVR4nH3SsUtCURTH8e/phERREBENIUWCUBQ0BC4OQcsDB6EhCIoiECEDg6JIzOfaXxBCBUHQIDg0tTgINTQEDUHgH+C/8RrU53nKe3e5HPhw77n3d9R1Mtndvf3Do5Nc/vSseH5xeXV9UyqXbysV1626VU2JIIDQ24ZK3fKihW5KtNANooWuEi00SbTQBNFCl8QXhUb99eX56aF2nx8IjeOLJv2VG5yhi/ii+6d1+DC36IIMhCAcwLvtQ+cJiALUA53qHFaU4DH4Fp3FiDvgrZG1QmfM8/nGdZoEhE7bD0qlPRkSOoUViCdOk4yJe5IR0cIxcU8wIj7ZMXHHxBetdje5L7ZN3DHPFx3aCaAGaRP3uPgi3qH99/sDRZO+KgEBcGznQ8ewYnklubYemCAVrAgmJ4D2yzDRBRFCe0MWKvogVPggTAxAiPgHY2dcQrz+CzkAAAAASUVORK5CYII=\",\n      \"f03n0g08.png\", false, 32, 32, \"bab714eea8df8ab97f4095442247c9e1\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAE0klEQVR4nH2WXYhUZRjHf8+8Z2fnzNcZv1r7kCyyD7Gy1CiN2kK3kAXDQjJCKk2FCr0QDAp6D3hjflB30lV30k1Xe9FtIMEiXlh2YRBi5UWCre7sfO6cfbo45505M7O7w2GY4Rze3/v/P8/7/I9RcjZXsMWKray2q9fa+x+y69bbRx6zG560GzfZpzfb57babS/al162r4zb13faiTft7km75y279x2771373vv2wAf24CF75Kj95FN77Lg9ccKe/Nx+8aX9ytpTp8yxdcYvRQRQhjKUoARFKEIBCpCHPPiQc9+jkHXfIzACHnhgwEAGMiAgAOboU55W8IOIgARTSmG6jEIKk0thYka2n2F6DPPh84ZANMBfkWKUHaCL6erIp3R0pSytw+zfnqGsVNBA/ZUDDKUozi6lIMnqvpITp0PJClkYUUbAEzzwFAMZIYN5+9UMJaEMFdEAf3WaIZSUklCEglBQ8kIB8oKv+EIORsUxJPFqRPDE6RAzuStDkT7GmiUYRcfIgy8pHcKoMuoYiY6EYSbeyCQmlIWSY4wty4i9WkZHimHGd0vSJHFJy0qABuqv7cQMCf4Kz/8bnr8VnrsZnvszPHs9PPt7eOZqeOZK+PW0Pb2l11qj/a01Ah5m4/ZMA+pQgzmkCrMwi9xVmn40C9+ELZb+fGafbUArdc3DPLRhHiIw67dJA6lDHeaglmLMKHU/+sgWDtrgkF31sR07bB88Yh/+LrwVr35N99WhAQ1oQtMx2g4zD+a+zdJ0D9USHTgGM6o1v3PP/a3CTvktXv0n3VWDeGdpRhtppxgm2EiLAYY4hszCjFL1o5hxWP6OV7+g2+bchgYATWghsY42mNzj0oYm0oKG29EwY9aPzko1Xv2EbqjCHMy555fRYcyjya8mEt9zNZdaijG1otMt7C/hf5fC2w/bVV0Raa8GdBhdJ/NOTiu516t5tx7VCwqsV2/M5u+EbeBqeHuFXTmXtEbXK+nXgek8QAQd11ttaKEttIk20DpaQ2to5jiZk8zqwozfzttcO+wAN8LbozaooXW0jjaggTbRJtpCW9BCDWNZ8Nz5y7rxGA+BvJvUBaEEZQjQSuSX8nasHd4ByvaJ4QCRVIAYVuYQA158+CQ5jjmXL11GHBFlCFQrHT/Q8Cbg263pAJGhADFUfNQgnjvdMSM7zBCKbo4HaKCnrwFZ+9pAgEh/gBhKOfBQk9IRD/hYiq92mql/ZOIZx4h1VPTbaSBj9wyFVFFSdhnyfpJAgzqSYnD5BsDUHzLxQpexsPlc3LIL9gCDQdjnlSGXA0mCrl9Hcu3YxOXrAFNX+fGKXpzW7y/Fq8uNi6pBx1+zKCMuuyGbdQEaM7yUji5jC5d/HZij8vMPUIIKGkT+2DAjDhDDSBaVfkbslZeSMsqOHYyPy8SETE7K3r2yfz+9egRoEPlrF2UYMgYVFpQFkiuCSOlIcvwGDnqjN0zSg1fvaqfp96ZufNWSFwxQQRWFKMWIhHnoOEDbjfzuUIynRGq4R3Wf9HCvYpIXMAWEBUWX1tFyjGUDJKr1MUyvaup0DHjV1bGoV4syqj2GcdvvZ6S96iiR9AGGvRpidGYThulrvZjUZSyvo5myq+6kpBl3fe4NAAYYw14t2lfNVM0HdMz4/wOljpe9l86W/gAAAABJRU5ErkJggg==\",\n      \"f03n2c08.png\", false, 32, 32, \"eef71a6ef947497fe0c45ea2ba65c5dd\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAAAAABWESUoAAAA1ElEQVR4nIXRwW3CMBSA4d/2s81MnaFiBqQOwA0pp26A1EsnqJQtWAtCIebAAdsP2zlEetGn/9mKfG/iJsYYQwjeey/eiXPOWWuNMQYjZ1qPBUySpQmeQi5tgAV6BbAjgB0BrFz7QBW2nCqgCtUH+S/GLw3qwl+1syxMUN+qWsFRgVs2/OhAXTioX5MXZlhg4re5gt0FoKjIPZ+W7P0WzABMHFsrytITrC/x4UMMcWYfs1PIHdUoD7mixFKDUnwGDfSWDKSBkERfSKIvJNEXwkAIA/EAFiZMByGZYIEAAAAASUVORK5CYII=\",\n      \"f04n0g08.png\", false, 32, 32, \"2bb4337fabd31e8786cbb3aec25315b1\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAADoElEQVR4nK2WzY4bRRSFv1tV/ed225SigSgiCx6AF+AJ2CTvAXv27Fmxy1vwAKyyZ8kqQooQUQQsBjwzjstjuy+Lqm6XPWPLIFpH1q3qdp+qW+ee206pqSvqOqGpH4//262mdn89V2/WVOxRn4jzYQEFOLBgSJdCD1vYwgYMCG7xDJx6t6bkANVlw0jj0uv2NDvYgsEtPlZKoVBfrdO6cpQXz4y7OaRxiydKpdRCpb4JaTkJmoIii0/Oa4otGEU00ribudIIjTIRGvVtwHIO7uK78QxuOpgoE6FVpkKrvgsY/gXsubvutoEWWqUTpspM6NTPA8L/AndXKRU0MIEpdMpcmKv3K9AMgIq8BlRfHs0/iEfZqnt3Rxv3gE6RKXToDOnQuQ/5asbrDwKDXuL8wxgQMOB+X2qNxA00aItMBrIW7XwY8/mFvIkE7wmXH5D7c0mFjkXaQA3NkLMGbf3KonbY+A/6+TvSzKM4Upm7XmqBFPsi1QqpiKxSQ4U2Pnwrt5HgV8JBqYz1cAp/f8ChFin2TyfKAi2REoph+V/r1VvC+bo+mne3qyhlNUi2NbWIA4s65KfPtpHgF8J5x3o445arJACDDoGMQ5N55fNr+4ZVheaoj4dH5qsuBM0lmPSeDfoXKXi/2AHi77ZyB3yqT2u2NbsMfU3fHA4d61IROaw/xUjSscA1YF9/wsKAUQz8BgSuLmkgjlDEN8Z8SHIWq8llbCTQm6vBzFwkWPFUKTNUmiU/DpXScW/Zv8sqVpIljkqLifr5KI9L+XEJT/Sr8+3CcS+HbuuUQpK44x/OXYFnj6l/XxiRYJDPAUdSnXzzJW3NtGJa09Uyq/sX3wPm7XfMm0B7tj9YxybaXn7I8QzGTVRQSbKPRpkkqS0+gqnSrnynmCMwBI5NDybz2JHDZCdRKKUkkTTpwcUMpjBTuuDnpxqCYxfbc4QeGjp56oa8VfLqFV3HTWogMFfmwftHD8mx2aaX74ZvjQ1sYA1rCLCCD7CEBo0eOzQQpgPFDO1Yzb0KewAGx3ZHvofxs+ke7iFAGCzmyNAnENvtJJFpS+j8cU+m72FITw8WduCGfThYZ/quBrITDUQbQutzHTm0pwcBBZPlysI2+xIp2MtqrJAy4xvtrSI0fiwJhyrapzOPmzBDrmympoNazCgfY9WCVeW1QAtc0oz2jPUQaQR2g92ZIcgpzYOqcgcrCIWnTFbzgIPsNw+OyjEP8qUMCwrW/wPZ2mq+jvKj/AAAAABJRU5ErkJggg==\",\n      \"f04n2c08.png\", false, 32, 32, \"82a6745345706f5c5a662a94fdd0ea29\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAABcUlEQVR4nHVRsU4CQRDd5Y5kj2oXtDi7u1IbNFRWiom1iYk/IMYfMIpfQPwCPf0CobAzAQmxMkaOxMLCgl3srNzdCtaCrLNgMEGdu8zt7cy8eW/GQ3PmT7xXpsj2n2e3C3snYAeb7oxdfDdmkKFEF3IycLEVRwwsH5dcFGDKS2EYBAFCJvvmQMt5xjCUIBvJe5dzmDTaaa+fdlvJcRFAF/fjmDKIKCvE000GrTIG/wxezFgBQEvLYY5ARmCIRurB9xiUOTaIKipZEfnVqzaX0lopebdZ28DZo7Vo2lYrJXkzM+VPvx2w8NbDfECAJjLQWXF/fh4oe9pIBWAC6kfaOt/5DWqt1giUIefh7OGVkGFMjEF2ZN5lzx8rJ9yhaXgUzGz7rJFy4Mp52rqo/CVfKqu00nbyGYB8W8gR+kkMtB2KWzfTTkQpU473oD8lu11NLuv166RW+W9R446QQgzEZLmeqxm+kpGSL48/2x/fzdR/AW8Fs1uE53SkAAAAAElFTkSuQmCC\",\n      \"f99n0g04.png\", false, 32, 32, \"207c771481d8e0786644d1d3ccdc1253\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAAIi4vcVJsAAAARBJREFUeJy11U0KwjAQBeBXrFpFUCjFXcFTNJfwtF4itxBcCCKCpeJfbXUhQTMTE0N0FoEZ6Os3pbTR/Q6tokjvpdT7otD7uGn0wXwOa9EbsIAsswdQMQsYjwMFo1GgYDgMFAwGnoLbTR/0+4GCJAkU9HqBAtcKTkG36ynwXeH/AlcAE9T1jwVxrPdt6ymgr/Ll4hDQACqgAU4BDaDFBNerX8DXgtkMWC7VVAj1eWUCumOnAwB5vlqpExBCSnUygXmF9fq9k9IiOJ9NAgCYTjcbtYBFQFdQzyBNdzsYiglOJ5NgMgHSFNjvhZDyfQUmOB5NAVWl+udlrx8cExwOpoDPxQRl6RfABNttoGCxCBM8AHUVjIYrRN23AAAAAElFTkSuQmCC\",\n      \"g03n0g16.png\", false, 32, 32, \"33bca103ab06d5288fc5a40d52b46648\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAABGdBTUEAAIi4vcVJsAAAASlJREFUeJzllk2KwkAQRqsx/kQEERR3LrzEeAiP6yH6FC4EFzKCGGRGZ0bjwojJJI/kw7iyVpVKpV+/LgLtYisOZ/DGu+L6R3E5OANgPi+uL6DfgIuA0YhWggBhBPT7IoAM/qC/1xMBqkG3KwLUGYShCFANOh0RoM6g3RYBqoEMUA1aLRFABrUBVINmUwS8n0EQiAAy+IV+NLhAXTUIyeAH6qoBHhEByID6Xz4DGfCMwXTqzGy5zK4xMzMzf38kg1LAZOJWqzidJKv7bEIGJwA0GkmyXsf5ovnKBgT4N4Px2G02qU1WNzgC4LFZs+HQbbd0Q7sHGXyXAQYDd2OY2W4XJ1vOHxEZfJUBoij7qc8ltyCDAwBq+w/20J+eQaUgg8+6AGRAt+W6DK5anlkjB1vfagAAAABJRU5ErkJggg==\",\n      \"g03n2c08.png\", false, 32, 32, \"5ab30d7747a459c1051650a1351a4519\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAABGdBTUEAAIi4vcVJsAAAAB5QTFRFAAAAAP///wD/AMjIra0A3d0A//////8A/93//63/MbogiAAAAGNJREFUeJxjKAcCJSAwBgJBIGBAFmAAAfqoCAWCmUAAV4EsQEcVLkDQAQRwFcgClKlg6DA2YEZS0dDBYcxsgGIGB1wFCKSlJaTBVUAE2MACCBUJDGzMQC1IKtLS4O5AFiBTBQBS03C95h21qwAAAABJRU5ErkJggg==\",\n      \"g03n3p04.png\", false, 32, 32, \"cab490ee86d478d165f2a516345d0ff0\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAAK/INwWK6QAAASJJREFUeJytlDkOwjAQRSciLAEkmjQpUtJwAE6AT+0bcAAaCgoKmhQgZWEJCUVkhZkxGVnGhaX5Up6fvxQHbQtoBQGetcbzbofnsK5xsN3C4KIHMEAcDwOocfh+42C18jRYLh0NKGCxcDR4vXAwn3saRJGjAQXMZp4G06mjAe1AAjADV4DYwWTiaSABxA6cDZ7PPxuMx3huGkcD+i/c74IBBVADChANKIAu0SAMhwHM4PGwG2w2AIeDSZUyzyszsAPW6+PR7ABKaW120aC7wun0PX0/7cyAttx3kKbnc59351sMqsoOSJLLhX9uMShLHHQdxDFAkgBkmVJaK9XXyAyKwmZwvZpZa6GDPLdf4ddiBrcbDkajYQAzyDJPg/3eDUANPik0iSilDmOAAAAAAElFTkSuQmCC\",\n      \"g04n0g16.png\", false, 32, 32, \"e38a1551172886575b1d91af694ecfde\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAABGdBTUEAAK/INwWK6QAAATBJREFUeJzVlj1uwkAQRr+VzJ+MRAMFBS0FB+AG8aF9hByAgoKGgoJIKFIifpLIFBiwg1+cT3GTKaz1eHfevJ3GIVN1BMGXNFTnn6rT0ScA5vPq/DPsF3ARMBxSJQgQRsBgYAJcg37fBLgGcWwCXINezwS4BjaADD5gf7drAlwDG+DOoNMxAWRAV9RumwB3Bv/fwAa4Bq2WCSCDE+xHgy/IuwYxGRDANcArOkCeDGwABRkcmwL8xWA2C5IWi3KNRJKUXl9dgyjKF9NpWC6z4iKvnpYXZEAzuwFWq+wxeW/8FmRAgG8zmEzCev3QZFIgkcEeAPdmpfE4bDY/Vhcb1AJGo3BhSNpus7xucmWobgbvdYDdrnw0LTyLQQZvdYDfBhm8NgUgg5emAGRAf8tNGZwBkU1XhkiDotcAAAAASUVORK5CYII=\",\n      \"g04n2c08.png\", false, 32, 32, \"daa8561d65a6598e69d6ddb060d802b7\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAABGdBTUEAAK/INwWK6QAAAB5QTFRFAAAAAP///9T/1NQA/wD/ALq6//////8A/5v/m5sAIugsggAAAGhJREFUeJy9zsEJgDAQRNEhsLnbgaQFW7CAXOae07ZgC7Zgt04IhPWq4D8Oj2VxqF1RLQpxQO8fsalTTRGHH8WlipoiDt8ECqsFsZZEq48biaxD9NybkzbEGLILBNGQDYjCff4Rh5fiBou1fg11pxGVAAAAAElFTkSuQmCC\",\n      \"g04n3p04.png\", false, 32, 32, \"0f81d4307736954402890d7203244bd0\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAANbY1E9YMgAAAQpJREFUeJyt1b0KgzAQB/AI0X4gSMcOzu3SxTdpHvQexdk+QRdBCqK2VewgQXOnCUeaQS8B//nlQA3GURgjCMw5gDm/3825/H7NhctFWAfeQPa9uXA62QOwmAiShCnAAXHsKTgemQLcA1eAU3A4MAWfDy/AKdjvmQJuABHgI+x2ngJXwP8F3ACnIIo8BThgGJgC/DK1rUPwftsFOIAIXAF4OAVhaA9gCLIsz3WtlP68EkHXrQtut7lWCkBfiWAroCiuV10DWAS4y8sm6toqwAHLJq41lAiaBi3I6X4+C5Gmz6dSAMsjEAEO0LuW5XSfHpt/cERQ19tHWBtE8HrxAoigqtCCZAoeDz/BD+1fhGYCQbPgAAAAAElFTkSuQmCC\",\n      \"g05n0g16.png\", false, 32, 32, \"5f67c34aadb2f3a602fea6d4ad14fa6d\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAABGdBTUEAANbY1E9YMgAAARVJREFUeJzlljkOwjAQRcdS2EJEQUdDiWiochI4aG5Cj7gADaJA7ItCwSJC8iR/cMdUzvjHL8+xorjcqssZzGSuuj+ubkdnAAwG1f055A24COh2aSUoEI4ukO90RIBqkCQigAwI0G6LANUgjkWAatBqiQDVQAaoBs2mCCCDE+QbDRHwfwYyQDWo10UAGQTbomAGV+iTwRHyCQH20A9mQADVoFaDCSoyIECwU3SA/IdBmrrptLjGxMzMsuflLwajkfvo2OS59Gvwi8Fslg+HruCUeRvQoSi/5ELH3+BLQLnIYOcB6PWcmfX7brHIH49c3iIy2HoAlsu3u7PS4F5ksPEAeBUZrCEfRSKADFaQD2ZAf8uhvkU3ajlNmZwVLFcAAAAASUVORK5CYII=\",\n      \"g05n2c08.png\", false, 32, 32, \"30cda048c618598b39f96c40141851fa\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAABGdBTUEAANbY1E9YMgAAAB5QTFRFAAAAAP//zMwA/8z/AK6u/wD/i4sA//////8A/4v/c+IkkgAAAFtJREFUeJxj6ACCUCBwAQJBIGBAFmAAAfqoUAKCmUAAV4EsQEcVaUBgDARwFcgClKkwMHZxYEFWwWDswuKAQwUIlJcXlMNVIAsgqWBgZwFqQVJRXg53B7IAmSoA1Ah4O0rtoFUAAAAASUVORK5CYII=\",\n      \"g05n3p04.png\", false, 32, 32, \"2be19a2ad1bdba9734899e453a27625b\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAARFwiTtYVgAAAPhJREFUeJzNlbsNhDAMhg1C4SVomYABqFiASchcmYkxEC2Ip4S4AuVEbCAXpbm/SUzx+cMC2TkOUOI4ai2EWte1Wnvbpj7IMngNbkAAafoOwMYEkCSWBnFsaRBFlgY6gNYgDC0NdACtQRAYGqyrGeAPDUwBWgPftzTQAYwN9t3QAP/O02RpgAHEYFneATjEwBSADdwFhX1TVYwxBgDA+dVAzaNBWd7baGdw9gRomqKQ92vIDOb5HoDvnJ8bghj8BuBcIrCBO6HIEeY5QJ4zxjmAEELIHXWgePhDkV3b9jzlapMnmcE4Pr/CXcgMhsEMQAz63tKg6+wMPgLFodTQLHMsAAAAAElFTkSuQmCC\",\n      \"g07n0g16.png\", false, 32, 32, \"cdd82be241cbfadbceffc98d967dfe30\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAABGdBTUEAARFwiTtYVgAAAQtJREFUeJzVlkEKgzAQRSciiaK49QS5gCsv4EnqsXImryHdlhZtKdhFK1U6HzM0YDvMIowhz+dXUE3ElyJwxSl+fuDH8Q0AypKfH8F+AlwIKAohAAhDQJ6jk0BJDbJMCJAaiAFSgzQVAqQGYgAyuIYC7GaAAEkiBCAD9IjEgJ8zMEYIkL5F/28AAXcwlxoUUgAyGMF+aHAB890yQAZaCwHAIBqJ2DZm1U2jnotXtZwB114Gda22nVAGgweg66aqUhsAlAECfIbMxN4SuXn9jQE/adcMYBANRGxr/W5rFRFZq7Sez3XzuUsDrmP03Szvt+8X/o74NcrAB+BVKINzKAAyOIUCIAP0MxvK4AEWgFoVP+GhCgAAAABJRU5ErkJggg==\",\n      \"g07n2c08.png\", false, 32, 32, \"0dcc8b7a828dd05df802b636673ed0ab\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAABGdBTUEAARFwiTtYVgAAAB5QTFRFAAAAAP//AJycv78A/3b/dnYA/wD///////8A/7//TpdUbAAAAFxJREFUeJxj6ACCNCBQAgJBIGBAFmAAAfqoMAYCFyCAq0AWoKOKUCCYCQRwFcgClKmYMFOJCUUFA1gAuwoQKC8vKFdiYoKogAswMCCrYGBnUkJRUV4OdweyAJkqACOga73pcj3PAAAAAElFTkSuQmCC\",\n      \"g07n3p04.png\", false, 32, 32, \"8f1a3f91ca328ca507273e80324087e9\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAAYagMeiWXwAAAL1JREFUeJztlTEOhCAQRT8bCyw9hlzD0tIDIQfyCF7D0ktYSGLBFoTFmUQC2WRjsv4CZqaYefwQEM6BSAiaa03zcaR5ZS0tSImk+IDiBpy42ndaqOtfEzwe3MGDrwlKTfxHD46jkKBp0g2KPdi2QoI73YNhmKYQGxOe12wP+j7Gxmgd1myCee66sx/G+J0TvCyT/Ajwa2QAAMeUNDHG8XvhBKJtaSEYpxQALItS/vyhSfbPtK7n2dcEz6sMvAHqCJi/5fyWiAAAAABJRU5ErkJggg==\",\n      \"g10n0g16.png\", false, 32, 32, \"75b64641f0a3c0899ae3b466fcb97c06\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAABGdBTUEAAYagMeiWXwAAANRJREFUeJztljEKhDAURP8HC+32HpYewdbS+/zNfbyCx7D1FAu7xUK2cA0aM0j4ARWcKhlNJsNTkS2FxQSuCIf9Z9jO3iAgz8P+B9xPIDdDC6IDQOHoAKhUDaBQA8SgKCIDDmtwM3C6GezqsAbJIF+HwRf4sQ0eKOAF/GQMUMB1GCApG7Qtd916D0NERDJPNQ2ahv1IM2/tBpqvad/buuYAdrMY6xn4znR2l6F/inxH1lNNg7JkIqoqHgb7P7hsIGsYjONitWwGk87+HuzrdA1S/VX8ANStTVTe34+eAAAAAElFTkSuQmCC\",\n      \"g10n2c08.png\", false, 32, 32, \"69926b0e52c1371c81ca49d7cd0cf2b1\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAABGdBTUEAAYagMeiWXwAAAB5QTFRFAAAAqakAAP///6r/VFQA/wD/AH9///////8A/1X/7g7bWgAAAGNJREFUeJxj6ACCUCBIAwIlIGBAFmAAAfqoEASCmUAAV4EsQEcVLkBgDARwFcgClKkwME5LYENWwWCcxpaApoKNAaICBMrLC8rTGKAq4AJALUgqGNjZgIYiqSgvh7sDWYBMFQBG4oXJmToRDgAAAABJRU5ErkJggg==\",\n      \"g10n3p04.png\", false, 32, 32, \"832e5401524ab7238a6eccd5d852b8ef\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAA9CQ+FSITwAAATZJREFUeJyllMsNwjAMQN0SQHwixGeNbsSBAToHXQDuHLoCi5A1CgjxhxY4RFGxLRJZ+FDXVvLy6laN3m9AEUW4ThJcbza4VkUBoqAHqO1WBqDGarfznxA02O9lAGYgBTCDw+FPAwqIY6HB8YgbjYbQQApgBqfTnwbnM2koocHlghvNptDgepUBmAEFtFpCg9sNN9ptocH97geUZcCAAgYDXNPXzAweD9zodPwAZvB8+gE0mAEFdLt+ADOgQ+r1bF6tAGYze29M/WtlBlWFG/0+AMBikabuGjCgAK1dzrK6qoMaxBUJrbXWGiDL5vNvgDHOAId6vTDRfQfL5XdljJsEmwF9Jrslz6dTgDy325KkHiSbAW0Mhzav1za7+bscNHCAXxE0GI38AGZAF4zHQgO6YDKRGXwAuz+aGCA4FKQAAAAASUVORK5CYII=\",\n      \"g25n0g16.png\", false, 32, 32, \"698f892bb4453fdd325ae414dc82b34f\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAABGdBTUEAA9CQ+FSITwAAAUxJREFUeJytlcttAjEQQMeLgSAQ4SPK2I44UAB1oC1gC+BACVQSykB8hIgSSIJzwFq8xE/KSB75MIxn5+lpLGGcxMMI3OQmXn+Ll+0WAOoArt2lAoCw3acCkMGB+uED2hkaHFMByIAAWRav3whABiclAIMMkgHI4Az9jYYSQAYEsFYJIIP3VAAySAYggw/ob7WUADIgQLOpBJDBJ/S320oAGVy0gB+okwEBXl/ggl4FGXxBf6ejBJDBVQugIINv6O92lQAy+A9guTQiMpsFMzYief0DrUGv55OyNPO5C5N4kAG9ugpwz4vCPBWfAwyym0j09Pv+iEhRmMXCififj9jUDWLH0l9gOKss3d+in14tg3ZAgMHAJ6uVm07NPXlMzOvThXdAW6sAIrJeB13h4wlzMiDAcAgXFGRA/aOREkAG1D8eKwFag8lECQCDX4gtYR8yuXeNAAAAAElFTkSuQmCC\",\n      \"g25n2c08.png\", false, 32, 32, \"a64f63bacd6a0edec500179d538ede01\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAABGdBTUEAA9CQ+FSITwAAAB5QTFRFAAAAAC0tAP//EBAA/1z//xD//wD/XFwA//////8AUlHX5QAAAGRJREFUeJy9zrENgDAMRFFbSpHWK7ACC7jICqzACrSUXoFtc1EkczVI+eX5FZYHncjQhoQHGa0RFzpQCh4Wih01lIKHf0KaKQtvZQyvcC8pRnHXaqpTzCEqziRCQo0Fyj94+Cg6NXRmxzu0UNgAAAAASUVORK5CYII=\",\n      \"g25n3p04.png\", false, 32, 32, \"c2b4d9eb0587bc254212b05beb972578\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAAYagMeiWXwAAAF5JREFUeJzV0jEKwDAMQ1E5W+9/xtygk8AoezLVKgSj2Y8/OICnuFcTE2OgOoJgHQiZAN2C9kDKBOgW3AZCJkC3oD2QMgG6BbeBkAnQLWgPpExgP28H7E/0GTjPfwAW2EvYX64rn9cAAAAASUVORK5CYII=\",\n      \"oi1n0g16.png\", false, 32, 32, \"a14e204bbf905586d3763f3cc5dcb2f3\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAIAAACsiDHgAAAABGdBTUEAAYagMeiWXwAAAOVJREFUeJzVlsEKgzAQRKfgQX/Lfrf9rfaWHgYDkoYmZpPMehiGReQ91qCPEEIAPi/gmu9kcnN+GD0nM1/O4vNad7cC6850KHCiM5fz7fJwXdEBYPOygV/o7PICeXSmsMA/dKbkGShD51xsAzXo7DIC9ehMAYG76MypZ6ANnfNJG7BAZx8uYIfOHChgjR4F+MfuDx0AtmfnDfREZ+8m0B+9m8Ao9Chg9x0Yi877jTYwA529WWAeerPAbPQoUH8GNNA5r9yAEjp7sYAeerGAKnoUyJ8BbXTOMxvwgM6eCPhBTwS8oTO/5kL+Xge7xOwAAAAASUVORK5CYII=\",\n      \"oi1n2c16.png\", false, 32, 32, \"a3774d09367dd147a3539d2d2f6ca133\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAAYagMeiWXwAAAEBJREFUeJzV0jEKwDAMQ1E5W+9/xtygk8AoezLVKgSj2Y8/OICnuFcTE2OgOoJgHQiZAN2C9kDKBOgW3AZCJkC3oD2QMjqwwDMAAAAeSURBVAG6BbeBkAnQLWgPpExgP28H7E/0GTjPfwAW2EvYX7J6X30AAAAASUVORK5CYII=\",\n      \"oi2n0g16.png\", false, 32, 32, \"a14e204bbf905586d3763f3cc5dcb2f3\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAIAAACsiDHgAAAABGdBTUEAAYagMeiWXwAAAIBJREFUeJzVlsEKgzAQRKfgQX/Lfrf9rfaWHgYDkoYmZpPMehiGReQ91qCPEEIAPi/gmu9kcnN+GD0nM1/O4vNad7cC6850KHCiM5fz7fJwXdEBYPOygV/o7PICeXSmsMA/dKbkGShD51xsAzXo7DIC9ehMAYG76MypZ6ANnfNJG7BAZx+ZiKBzAAAAZUlEQVQuYIfOHChgjR4F+MfuDx0AtmfnDfREZ+8m0B+9m8Ao9Chg9x0Yi877jTYwA529WWAeerPAbPQoUH8GNNA5r9yAEjp7sYAeerGAKnoUyJ8BbXTOMxvwgM6eCPhBTwS8oTO/5kL+Xk13nmIAAAAASUVORK5CYII=\",\n      \"oi2n2c16.png\", false, 32, 32, \"a3774d09367dd147a3539d2d2f6ca133\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAAYagMeiWXwAAAB9JREFUeJzV0jEKwDAMQ1E5W+9/xtygk8AoezLVKgSj2Y8/OIdtk98AAAAfSURBVICnuFcTE2OgOoJgHQiZAN2C9kDKBOgW3AZCJkC3oD3Oo8vsAAAAAklEQVSQMsVtZiAAAAAeSURBVAG6BbeBkAnQLWgPpExgP28H7E/0GTjPfwAW2EvYX7J6X30AAAAASUVORK5CYII=\",\n      \"oi4n0g16.png\", false, 32, 32, \"a14e204bbf905586d3763f3cc5dcb2f3\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAIAAACsiDHgAAAABGdBTUEAAYagMeiWXwAAAGNJREFUeJzVlsEKgzAQRKfgQX/Lfrf9rfaWHgYDkoYmZpPMehiGReQ91qCPEEIAPi/gmu9kcnN+GD0nM1/O4vNad7cC6850KHCiM5fz7fJwXdEBYPOygV/o7PICeXSmsMA/dKbkGShDblRaWAAAAB1JREFU51xsAzXo7DIC9ehMAYG76MypZ6ANnfNJG7BAZx9l6MXmAAAAY0lEQVQuYIfOHChgjR4F+MfuDx0AtmfnDfREZ+8m0B+9m8Ao9Chg9x0Yi877jTYwA529WWAeerPAbPQoUH8GNNA5r9yAEjp7sYAeerGAKnoUyJ8BbXTOMxvwgM6eCPhBTwS8oTO/5kIg4uIpAAAAAklEQVT+XnoXDXoAAAAASUVORK5CYII=\",\n      \"oi4n2c16.png\", false, 32, 32, \"a3774d09367dd147a3539d2d2f6ca133\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAAYagMeiWXwAAAAFJREFUeHbmhOYAAAABSURBVJzRgaKHAAAAAUlEQVTV3oFbswAAAAFJREFU0kDlzhAAAAABSURBVDF55n3SAAAAAUlEQVQKyO2U9gAAAAFJREFUwLNcv1gAAAABSURBVDAO4U1EAAAAAUlEQVQMIY4xwwAAAAFJREFUQ8ftbcIAAAABSURBVFE0VByKAAAAAUlEQVQ5dz314AAAAAFJREFUW9SB9ZQAAAABSURBVO8YjYIBAAAAAUlEQVR/6IIRRQAAAAFJREFUxlo/Gm0AAAABSURBVNynXeMXAAAAAUlEQVSg/u7eAAAAAAFJREFUk0E+vxYAAAABSURBVMCzXL9YAAAAAUlEQVQoHY3VEgAAAAFJREFUe+/v1VwAAAABSURBVDLg7yxoAAAAAUlEQVTV3oFbswAAAAFJREFUKvODtD4AAAABSURBVAQvVbnxAAAAAUlEQVSjZ+ePugAAAAFJREFU2dc3F5gAAAABSURBVI9VP+NZAAAAAUlEQVQ/nl5Q1QAAAAFJREFUOAA6xXYAAAABSURBVIDFgP7IAAAAAUlEQVSnYIpLowAAAAFJREFUuO2CRlYAAAABSURBVFfdN7m/AAAAAUlEQVQTrIY8NgAAAAFJREFUE6yGPDYAAAABSURBVGP8g00KAAAAAUlEQVSg/u7eAAAAAAFJREFUOu40pFoAAAABSURBVIIrjp/kAAAAAUlEQVRgZYocsAAAAAFJREFUHUs+ETEAAAABSURBVAgm4/XaAAAAAUlEQVSZoetWCAAAAAFJREFUACg4fegAAAABSURBVN3QWtOBAAAAAUlEQVSCK46f5AAAAAFJREFU9nzmKsEAAAABSURBVEBe5Dx4AAAAAUlEQVTKU4lWRgAAAAFJREFUBC9VufEAAAABSURBVOiG6ReiAAAAAUlEQVQW3OzIuQAAAAFJREFU3Kdd4xcAAAABSURBVAbBW9jdAAAAAUlEQVRCsOpdVAAAAAFJREFUJvo1+BUAAAABSURBVEBe5Dx4AAAAAUlEQVS3fT1bxwAAAAFJREFUoP7u3gAAAAABSURBVD1wUDH5AAAAAUlEQVSQ2DfurAAAAAFJREFUMuDvLGgAAAABSURBVAFfP01+AAAAAUlEQVS6A4wnegAAAAFJREFUBVhSiWcAAAABSURBVLd9PVvHAAAAAUlEQVSBsofOXgAAAAFJREFUkNg37qwAAAABSURBVAlR5MVMAAAAAUlEQVTQruuvPAAAAAFJREFULW3nIZ0AAAABSURBVGhrUZSCAAAAAUlEQVQPuIdgeQAAAAFJREFUpPmDGhkAAAABSURBVExXUnBTAAAAAUlEQVRgZYocsAAAAAFJREFUP55eUNUAAAABSURBVG/1NQEhAAAAAUlEQVQHtlzoSwAAAAFJREFU7IGE07sAAAABSURBVE/OWyHpAAAAAUlEQVT0kuhL7QAAAAFJREFUGUxT1SgAAAABSURBVDgAOsV2AAAAAUlEQVTPI+OiyQAAAAFJREFUf+iCEUUAAAABSURBVAAoOH3oAAAAAUlEQVQW3OzIuQAAAAFJREFU2KAwJw4AAAABSURBVEvJNuXwAAAAAUlEQVTYoDAnDgAAAAFJREFUX9PsMY0AAAAASUVORK5CYII=\",\n      \"oi9n0g16.png\", false, 32, 32, \"a14e204bbf905586d3763f3cc5dcb2f3\");\n  testPngSuiteImage(\"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\",\n      \"oi9n2c16.png\", false, 32, 32, \"a3774d09367dd147a3539d2d2f6ca133\");\n  testPngSuiteImage(\"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QOEDCAASABQ+gAAgAUDhAwgAEgAUPoAAIAFA4QMIABIAFD6AACABQOEDCAASABQ+gAAgAUDhAwgAEgAUPoAAIAFA4QMIABIAFD6AACABQOEDCAASABQ+gAAgAUDhAwgAEgAUPoAAIAFA4QMIABIAFD6AACABQOEDCAASABQ+gAAgAUDhAwgAEgAUPoAAIAFA4QMIABIAFD6AACABQOEDCAASABQ+gAAgAUDhAwgAEgAUPoAAIAFA4QMIABIAFD6AACABQOEDCAASABQ+gAAgAUDhAwgAEgAUPoAAIAFA4QMIABIAFD6AACABQOEDCAASABQ+gAAgAUDhAwgAEgAUPoAAIAFA4QMIABIAFD6AACABQOEDCAASABQ+gAAgAUDhAwgAEgAUPoAAIAFA4QMIABIAFD6AACABQOEDCAASABQ+gAAgAUDhAwgAEgAUPoAAIAFA4QMIABIAFD6AACABQOEDCAASABQ+gAAgAUDhAwgAEgAUPoAAIAFA4QMIABIAFD6AACABQOEDCAASABQ+gAAgAUDhAwgAEgAUPoAAIAFA4QMIABIAFD6AACABQOEDrNu2zb4Gs2n9C98FlZObRxMyAAAAAElFTkSuQmCC\",\n      \"PngSuite.png\", false, 256, 256, \"183c2504778cb2b6384dbbad46fa2a2a\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAIAAACsiDHgAAAABGdBTUEAAYagMeiWXwAAAohQTFRFAAAAAAAzAABmAACZAADMAAD/ADMAADMzADNmADOZADPMADP/AGYAAGYzAGZmAGaZAGbMAGb/AJkAAJkzAJlmAJmZAJnMAJn/AMwAAMwzAMxmAMyZAMzMAMz/AP8AAP8zAP9mAP+ZAP/MAP//MwAAMwAzMwBmMwCZMwDMMwD/MzMAMzMzMzNmMzOZMzPMMzP/M2YAM2YzM2ZmM2aZM2bMM2b/M5kAM5kzM5lmM5mZM5nMM5n/M8wAM8wzM8xmM8yZM8zMM8z/M/8AM/8zM/9mM/+ZM//MM///ZgAAZgAzZgBmZgCZZgDMZgD/ZjMAZjMzZjNmZjOZZjPMZjP/ZmYAZmYzZmZmZmaZZmbMZmb/ZpkAZpkzZplmZpmZZpnMZpn/ZswAZswzZsxmZsyZZszMZsz/Zv8AZv8zZv9mZv+ZZv/MZv//mQAAmQAzmQBmmQCZmQDMmQD/mTMAmTMzmTNmmTOZmTPMmTP/mWYAmWYzmWZmmWaZmWbMmWb/mZkAmZkzmZlmmZmZmZnMmZn/mcwAmcwzmcxmmcyZmczMmcz/mf8Amf8zmf9mmf+Zmf/Mmf//zAAAzAAzzABmzACZzADMzAD/zDMAzDMzzDNmzDOZzDPMzDP/zGYAzGYzzGZmzGaZzGbMzGb/zJkAzJkzzJlmzJmZzJnMzJn/zMwAzMwzzMxmzMyZzMzMzMz/zP8AzP8zzP9mzP+ZzP/MzP///wAA/wAz/wBm/wCZ/wDM/wD//zMA/zMz/zNm/zOZ/zPM/zP//2YA/2Yz/2Zm/2aZ/2bM/2b//5kA/5kz/5lm/5mZ/5nM/5n//8wA/8wz/8xm/8yZ/8zM/8z///8A//8z//9m//+Z///M////Y7C7UQAAAOVJREFUeJzVlsEKgzAQRKfgQX/Lfrf9rfaWHgYDkoYmZpPMehiGReQ91qCPEEIAPi/gmu9kcnN+GD0nM1/O4vNad7cC6850KHCiM5fz7fJwXdEBYPOygV/o7PICeXSmsMA/dKbkGShD51xsAzXo7DIC9ehMAYG76MypZ6ANnfNJG7BAZx8uYIfOHChgjR4F+MfuDx0AtmfnDfREZ+8m0B+9m8Ao9Chg9x0Yi877jTYwA529WWAeerPAbPQoUH8GNNA5r9yAEjp7sYAeerGAKnoUyJ8BbXTOMxvwgM6eCPhBTwS8oTO/5kL+Xge7xOwAAAAASUVORK5CYII=\",\n      \"pp0n2c16.png\", false, 32, 32, \"a3774d09367dd147a3539d2d2f6ca133\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAAYagMeiWXwAAAohQTFRFAAAAAAAzAABmAACZAADMAAD/ADMAADMzADNmADOZADPMADP/AGYAAGYzAGZmAGaZAGbMAGb/AJkAAJkzAJlmAJmZAJnMAJn/AMwAAMwzAMxmAMyZAMzMAMz/AP8AAP8zAP9mAP+ZAP/MAP//MwAAMwAzMwBmMwCZMwDMMwD/MzMAMzMzMzNmMzOZMzPMMzP/M2YAM2YzM2ZmM2aZM2bMM2b/M5kAM5kzM5lmM5mZM5nMM5n/M8wAM8wzM8xmM8yZM8zMM8z/M/8AM/8zM/9mM/+ZM//MM///ZgAAZgAzZgBmZgCZZgDMZgD/ZjMAZjMzZjNmZjOZZjPMZjP/ZmYAZmYzZmZmZmaZZmbMZmb/ZpkAZpkzZplmZpmZZpnMZpn/ZswAZswzZsxmZsyZZszMZsz/Zv8AZv8zZv9mZv+ZZv/MZv//mQAAmQAzmQBmmQCZmQDMmQD/mTMAmTMzmTNmmTOZmTPMmTP/mWYAmWYzmWZmmWaZmWbMmWb/mZkAmZkzmZlmmZmZmZnMmZn/mcwAmcwzmcxmmcyZmczMmcz/mf8Amf8zmf9mmf+Zmf/Mmf//zAAAzAAzzABmzACZzADMzAD/zDMAzDMzzDNmzDOZzDPMzDP/zGYAzGYzzGZmzGaZzGbMzGb/zJkAzJkzzJlmzJmZzJnMzJn/zMwAzMwzzMxmzMyZzMzMzMz/zP8AzP8zzP9mzP+ZzP/MzP///wAA/wAz/wBm/wCZ/wDM/wD//zMA/zMz/zNm/zOZ/zPM/zP//2YA/2Yz/2Zm/2aZ/2bM/2b//5kA/5kz/5lm/5mZ/5nM/5n//8wA/8wz/8xm/8yZ/8zM/8z///8A//8z//9m//+Z///M////Y7C7UQAAAFVJREFUeJzt0DEKwDAMQ1EVPCT3v6BvogzO1KVLQcsfNBgMeuixLcnrlf1x//WzS2pJjgUAAAADyPWrwgMAAABgAMF+VXgAAAAAXIAdS3U3AAAAooADG8P2VRMVDwMAAAAASUVORK5CYII=\",\n      \"pp0n6a08.png\", false, 32, 32, \"de9a6b2025046b20b3a408990a2b7e71\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAAAAABWESUoAAAABGdBTUEAAYagMeiWXwAABRpzUExUc2l4LWN1YmUACAAAAP8AAAAAM/8AAAAAZv8AAAAAmf8AAAAAzP8AAAAA//8AAAAzAP8AAAAzM/8AAAAzZv8AAAAzmf8AAAAzzP8AAAAz//8AAABmAP8AAABmM/8AAABmZv8AAABmmf8AAABmzP8AAABm//8AAACZAP8AAACZM/8AAACZZv8AAACZmf8AAACZzP8AAACZ//8AAADMAP8AAADMM/8AAADMZv8AAADMmf8AAADMzP8AAADM//8AAAD/AP8AAAD/M/8AAAD/Zv8AAAD/mf8AAAD/zP8AAAD///8AADMAAP8AADMAM/8AADMAZv8AADMAmf8AADMAzP8AADMA//8AADMzAP8AADMzM/8AADMzZv8AADMzmf8AADMzzP8AADMz//8AADNmAP8AADNmM/8AADNmZv8AADNmmf8AADNmzP8AADNm//8AADOZAP8AADOZM/8AADOZZv8AADOZmf8AADOZzP8AADOZ//8AADPMAP8AADPMM/8AADPMZv8AADPMmf8AADPMzP8AADPM//8AADP/AP8AADP/M/8AADP/Zv8AADP/mf8AADP/zP8AADP///8AAGYAAP8AAGYAM/8AAGYAZv8AAGYAmf8AAGYAzP8AAGYA//8AAGYzAP8AAGYzM/8AAGYzZv8AAGYzmf8AAGYzzP8AAGYz//8AAGZmAP8AAGZmM/8AAGZmZv8AAGZmmf8AAGZmzP8AAGZm//8AAGaZAP8AAGaZM/8AAGaZZv8AAGaZmf8AAGaZzP8AAGaZ//8AAGbMAP8AAGbMM/8AAGbMZv8AAGbMmf8AAGbMzP8AAGbM//8AAGb/AP8AAGb/M/8AAGb/Zv8AAGb/mf8AAGb/zP8AAGb///8AAJkAAP8AAJkAM/8AAJkAZv8AAJkAmf8AAJkAzP8AAJkA//8AAJkzAP8AAJkzM/8AAJkzZv8AAJkzmf8AAJkzzP8AAJkz//8AAJlmAP8AAJlmM/8AAJlmZv8AAJlmmf8AAJlmzP8AAJlm//8AAJmZAP8AAJmZM/8AAJmZZv8AAJmZmf8AAJmZzP8AAJmZ//8AAJnMAP8AAJnMM/8AAJnMZv8AAJnMmf8AAJnMzP8AAJnM//8AAJn/AP8AAJn/M/8AAJn/Zv8AAJn/mf8AAJn/zP8AAJn///8AAMwAAP8AAMwAM/8AAMwAZv8AAMwAmf8AAMwAzP8AAMwA//8AAMwzAP8AAMwzM/8AAMwzZv8AAMwzmf8AAMwzzP8AAMwz//8AAMxmAP8AAMxmM/8AAMxmZv8AAMxmmf8AAMxmzP8AAMxm//8AAMyZAP8AAMyZM/8AAMyZZv8AAMyZmf8AAMyZzP8AAMyZ//8AAMzMAP8AAMzMM/8AAMzMZv8AAMzMmf8AAMzMzP8AAMzM//8AAMz/AP8AAMz/M/8AAMz/Zv8AAMz/mf8AAMz/zP8AAMz///8AAP8AAP8AAP8AM/8AAP8AZv8AAP8Amf8AAP8AzP8AAP8A//8AAP8zAP8AAP8zM/8AAP8zZv8AAP8zmf8AAP8zzP8AAP8z//8AAP9mAP8AAP9mM/8AAP9mZv8AAP9mmf8AAP9mzP8AAP9m//8AAP+ZAP8AAP+ZM/8AAP+ZZv8AAP+Zmf8AAP+ZzP8AAP+Z//8AAP/MAP8AAP/MM/8AAP/MZv8AAP/Mmf8AAP/MzP8AAP/M//8AAP//AP8AAP//M/8AAP//Zv8AAP//mf8AAP//zP8AAP////8AACL/aC4AAABBSURBVHicY2RgJAAUCMizDAUFjA8IKfj3Hz9geTAcFDDKEZBnZKJ5XAwGBYyP8Mr+/8/4h+ZxMRgUMMrglWVkBABQ5f5xNeLYWQAAAABJRU5ErkJggg==\",\n      \"ps1n0g08.png\", false, 32, 32, \"f6470f9f6296c5109e2bd730fe203773\");\n  testPngSuiteImage(\"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\",\n      \"ps1n2c16.png\", false, 32, 32, \"a3774d09367dd147a3539d2d2f6ca133\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAAAAABWESUoAAAABGdBTUEAAYagMeiWXwAACHpzUExUc2l4LWN1YmUAEAAAAAAAAAD/AAAAAAAAADMA/wAAAAAAAABmAP8AAAAAAAAAmQD/AAAAAAAAAMwA/wAAAAAAAAD/AP8AAAAAADMAAAD/AAAAAAAzADMA/wAAAAAAMwBmAP8AAAAAADMAmQD/AAAAAAAzAMwA/wAAAAAAMwD/AP8AAAAAAGYAAAD/AAAAAABmADMA/wAAAAAAZgBmAP8AAAAAAGYAmQD/AAAAAABmAMwA/wAAAAAAZgD/AP8AAAAAAJkAAAD/AAAAAACZADMA/wAAAAAAmQBmAP8AAAAAAJkAmQD/AAAAAACZAMwA/wAAAAAAmQD/AP8AAAAAAMwAAAD/AAAAAADMADMA/wAAAAAAzABmAP8AAAAAAMwAmQD/AAAAAADMAMwA/wAAAAAAzAD/AP8AAAAAAP8AAAD/AAAAAAD/ADMA/wAAAAAA/wBmAP8AAAAAAP8AmQD/AAAAAAD/AMwA/wAAAAAA/wD/AP8AAAAzAAAAAAD/AAAAMwAAADMA/wAAADMAAABmAP8AAAAzAAAAmQD/AAAAMwAAAMwA/wAAADMAAAD/AP8AAAAzADMAAAD/AAAAMwAzADMA/wAAADMAMwBmAP8AAAAzADMAmQD/AAAAMwAzAMwA/wAAADMAMwD/AP8AAAAzAGYAAAD/AAAAMwBmADMA/wAAADMAZgBmAP8AAAAzAGYAmQD/AAAAMwBmAMwA/wAAADMAZgD/AP8AAAAzAJkAAAD/AAAAMwCZADMA/wAAADMAmQBmAP8AAAAzAJkAmQD/AAAAMwCZAMwA/wAAADMAmQD/AP8AAAAzAMwAAAD/AAAAMwDMADMA/wAAADMAzABmAP8AAAAzAMwAmQD/AAAAMwDMAMwA/wAAADMAzAD/AP8AAAAzAP8AAAD/AAAAMwD/ADMA/wAAADMA/wBmAP8AAAAzAP8AmQD/AAAAMwD/AMwA/wAAADMA/wD/AP8AAABmAAAAAAD/AAAAZgAAADMA/wAAAGYAAABmAP8AAABmAAAAmQD/AAAAZgAAAMwA/wAAAGYAAAD/AP8AAABmADMAAAD/AAAAZgAzADMA/wAAAGYAMwBmAP8AAABmADMAmQD/AAAAZgAzAMwA/wAAAGYAMwD/AP8AAABmAGYAAAD/AAAAZgBmADMA/wAAAGYAZgBmAP8AAABmAGYAmQD/AAAAZgBmAMwA/wAAAGYAZgD/AP8AAABmAJkAAAD/AAAAZgCZADMA/wAAAGYAmQBmAP8AAABmAJkAmQD/AAAAZgCZAMwA/wAAAGYAmQD/AP8AAABmAMwAAAD/AAAAZgDMADMA/wAAAGYAzABmAP8AAABmAMwAmQD/AAAAZgDMAMwA/wAAAGYAzAD/AP8AAABmAP8AAAD/AAAAZgD/ADMA/wAAAGYA/wBmAP8AAABmAP8AmQD/AAAAZgD/AMwA/wAAAGYA/wD/AP8AAACZAAAAAAD/AAAAmQAAADMA/wAAAJkAAABmAP8AAACZAAAAmQD/AAAAmQAAAMwA/wAAAJkAAAD/AP8AAACZADMAAAD/AAAAmQAzADMA/wAAAJkAMwBmAP8AAACZADMAmQD/AAAAmQAzAMwA/wAAAJkAMwD/AP8AAACZAGYAAAD/AAAAmQBmADMA/wAAAJkAZgBmAP8AAACZAGYAmQD/AAAAmQBmAMwA/wAAAJkAZgD/AP8AAACZAJkAAAD/AAAAmQCZADMA/wAAAJkAmQBmAP8AAACZAJkAmQD/AAAAmQCZAMwA/wAAAJkAmQD/AP8AAACZAMwAAAD/AAAAmQDMADMA/wAAAJkAzABmAP8AAACZAMwAmQD/AAAAmQDMAMwA/wAAAJkAzAD/AP8AAACZAP8AAAD/AAAAmQD/ADMA/wAAAJkA/wBmAP8AAACZAP8AmQD/AAAAmQD/AMwA/wAAAJkA/wD/AP8AAADMAAAAAAD/AAAAzAAAADMA/wAAAMwAAABmAP8AAADMAAAAmQD/AAAAzAAAAMwA/wAAAMwAAAD/AP8AAADMADMAAAD/AAAAzAAzADMA/wAAAMwAMwBmAP8AAADMADMAmQD/AAAAzAAzAMwA/wAAAMwAMwD/AP8AAADMAGYAAAD/AAAAzABmADMA/wAAAMwAZgBmAP8AAADMAGYAmQD/AAAAzABmAMwA/wAAAMwAZgD/AP8AAADMAJkAAAD/AAAAzACZADMA/wAAAMwAmQBmAP8AAADMAJkAmQD/AAAAzACZAMwA/wAAAMwAmQD/AP8AAADMAMwAAAD/AAAAzADMADMA/wAAAMwAzABmAP8AAADMAMwAmQD/AAAAzADMAMwA/wAAAMwAzAD/AP8AAADMAP8AAAD/AAAAzAD/ADMA/wAAAMwA/wBmAP8AAADMAP8AmQD/AAAAzAD/AMwA/wAAAMwA/wD/AP8AAAD/AAAAAAD/AAAA/wAAADMA/wAAAP8AAABmAP8AAAD/AAAAmQD/AAAA/wAAAMwA/wAAAP8AAAD/AP8AAAD/ADMAAAD/AAAA/wAzADMA/wAAAP8AMwBmAP8AAAD/ADMAmQD/AAAA/wAzAMwA/wAAAP8AMwD/AP8AAAD/AGYAAAD/AAAA/wBmADMA/wAAAP8AZgBmAP8AAAD/AGYAmQD/AAAA/wBmAMwA/wAAAP8AZgD/AP8AAAD/AJkAAAD/AAAA/wCZADMA/wAAAP8AmQBmAP8AAAD/AJkAmQD/AAAA/wCZAMwA/wAAAP8AmQD/AP8AAAD/AMwAAAD/AAAA/wDMADMA/wAAAP8AzABmAP8AAAD/AMwAmQD/AAAA/wDMAMwA/wAAAP8AzAD/AP8AAAD/AP8AAAD/AAAA/wD/ADMA/wAAAP8A/wBmAP8AAAD/AP8AmQD/AAAA/wD/AMwA/wAAAP8A/wD/AP8AAJbQi4YAAABBSURBVHicY2RgJAAUCMizDAUFjA8IKfj3Hz9geTAcFDDKEZBnZKJ5XAwGBYyP8Mr+/8/4h+ZxMRgUMMrglWVkBABQ5f5xNeLYWQAAAABJRU5ErkJggg==\",\n      \"ps2n0g08.png\", false, 32, 32, \"f6470f9f6296c5109e2bd730fe203773\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAIAAACsiDHgAAAABGdBTUEAAYagMeiWXwAACHpzUExUc2l4LWN1YmUAEAAAAAAAAAD/AAAAAAAAADMA/wAAAAAAAABmAP8AAAAAAAAAmQD/AAAAAAAAAMwA/wAAAAAAAAD/AP8AAAAAADMAAAD/AAAAAAAzADMA/wAAAAAAMwBmAP8AAAAAADMAmQD/AAAAAAAzAMwA/wAAAAAAMwD/AP8AAAAAAGYAAAD/AAAAAABmADMA/wAAAAAAZgBmAP8AAAAAAGYAmQD/AAAAAABmAMwA/wAAAAAAZgD/AP8AAAAAAJkAAAD/AAAAAACZADMA/wAAAAAAmQBmAP8AAAAAAJkAmQD/AAAAAACZAMwA/wAAAAAAmQD/AP8AAAAAAMwAAAD/AAAAAADMADMA/wAAAAAAzABmAP8AAAAAAMwAmQD/AAAAAADMAMwA/wAAAAAAzAD/AP8AAAAAAP8AAAD/AAAAAAD/ADMA/wAAAAAA/wBmAP8AAAAAAP8AmQD/AAAAAAD/AMwA/wAAAAAA/wD/AP8AAAAzAAAAAAD/AAAAMwAAADMA/wAAADMAAABmAP8AAAAzAAAAmQD/AAAAMwAAAMwA/wAAADMAAAD/AP8AAAAzADMAAAD/AAAAMwAzADMA/wAAADMAMwBmAP8AAAAzADMAmQD/AAAAMwAzAMwA/wAAADMAMwD/AP8AAAAzAGYAAAD/AAAAMwBmADMA/wAAADMAZgBmAP8AAAAzAGYAmQD/AAAAMwBmAMwA/wAAADMAZgD/AP8AAAAzAJkAAAD/AAAAMwCZADMA/wAAADMAmQBmAP8AAAAzAJkAmQD/AAAAMwCZAMwA/wAAADMAmQD/AP8AAAAzAMwAAAD/AAAAMwDMADMA/wAAADMAzABmAP8AAAAzAMwAmQD/AAAAMwDMAMwA/wAAADMAzAD/AP8AAAAzAP8AAAD/AAAAMwD/ADMA/wAAADMA/wBmAP8AAAAzAP8AmQD/AAAAMwD/AMwA/wAAADMA/wD/AP8AAABmAAAAAAD/AAAAZgAAADMA/wAAAGYAAABmAP8AAABmAAAAmQD/AAAAZgAAAMwA/wAAAGYAAAD/AP8AAABmADMAAAD/AAAAZgAzADMA/wAAAGYAMwBmAP8AAABmADMAmQD/AAAAZgAzAMwA/wAAAGYAMwD/AP8AAABmAGYAAAD/AAAAZgBmADMA/wAAAGYAZgBmAP8AAABmAGYAmQD/AAAAZgBmAMwA/wAAAGYAZgD/AP8AAABmAJkAAAD/AAAAZgCZADMA/wAAAGYAmQBmAP8AAABmAJkAmQD/AAAAZgCZAMwA/wAAAGYAmQD/AP8AAABmAMwAAAD/AAAAZgDMADMA/wAAAGYAzABmAP8AAABmAMwAmQD/AAAAZgDMAMwA/wAAAGYAzAD/AP8AAABmAP8AAAD/AAAAZgD/ADMA/wAAAGYA/wBmAP8AAABmAP8AmQD/AAAAZgD/AMwA/wAAAGYA/wD/AP8AAACZAAAAAAD/AAAAmQAAADMA/wAAAJkAAABmAP8AAACZAAAAmQD/AAAAmQAAAMwA/wAAAJkAAAD/AP8AAACZADMAAAD/AAAAmQAzADMA/wAAAJkAMwBmAP8AAACZADMAmQD/AAAAmQAzAMwA/wAAAJkAMwD/AP8AAACZAGYAAAD/AAAAmQBmADMA/wAAAJkAZgBmAP8AAACZAGYAmQD/AAAAmQBmAMwA/wAAAJkAZgD/AP8AAACZAJkAAAD/AAAAmQCZADMA/wAAAJkAmQBmAP8AAACZAJkAmQD/AAAAmQCZAMwA/wAAAJkAmQD/AP8AAACZAMwAAAD/AAAAmQDMADMA/wAAAJkAzABmAP8AAACZAMwAmQD/AAAAmQDMAMwA/wAAAJkAzAD/AP8AAACZAP8AAAD/AAAAmQD/ADMA/wAAAJkA/wBmAP8AAACZAP8AmQD/AAAAmQD/AMwA/wAAAJkA/wD/AP8AAADMAAAAAAD/AAAAzAAAADMA/wAAAMwAAABmAP8AAADMAAAAmQD/AAAAzAAAAMwA/wAAAMwAAAD/AP8AAADMADMAAAD/AAAAzAAzADMA/wAAAMwAMwBmAP8AAADMADMAmQD/AAAAzAAzAMwA/wAAAMwAMwD/AP8AAADMAGYAAAD/AAAAzABmADMA/wAAAMwAZgBmAP8AAADMAGYAmQD/AAAAzABmAMwA/wAAAMwAZgD/AP8AAADMAJkAAAD/AAAAzACZADMA/wAAAMwAmQBmAP8AAADMAJkAmQD/AAAAzACZAMwA/wAAAMwAmQD/AP8AAADMAMwAAAD/AAAAzADMADMA/wAAAMwAzABmAP8AAADMAMwAmQD/AAAAzADMAMwA/wAAAMwAzAD/AP8AAADMAP8AAAD/AAAAzAD/ADMA/wAAAMwA/wBmAP8AAADMAP8AmQD/AAAAzAD/AMwA/wAAAMwA/wD/AP8AAAD/AAAAAAD/AAAA/wAAADMA/wAAAP8AAABmAP8AAAD/AAAAmQD/AAAA/wAAAMwA/wAAAP8AAAD/AP8AAAD/ADMAAAD/AAAA/wAzADMA/wAAAP8AMwBmAP8AAAD/ADMAmQD/AAAA/wAzAMwA/wAAAP8AMwD/AP8AAAD/AGYAAAD/AAAA/wBmADMA/wAAAP8AZgBmAP8AAAD/AGYAmQD/AAAA/wBmAMwA/wAAAP8AZgD/AP8AAAD/AJkAAAD/AAAA/wCZADMA/wAAAP8AmQBmAP8AAAD/AJkAmQD/AAAA/wCZAMwA/wAAAP8AmQD/AP8AAAD/AMwAAAD/AAAA/wDMADMA/wAAAP8AzABmAP8AAAD/AMwAmQD/AAAA/wDMAMwA/wAAAP8AzAD/AP8AAAD/AP8AAAD/AAAA/wD/ADMA/wAAAP8A/wBmAP8AAAD/AP8AmQD/AAAA/wD/AMwA/wAAAP8A/wD/AP8AAJbQi4YAAADlSURBVHic1ZbBCoMwEESn4EF/y363/a32lh4GA5KGJmaTzHoYhkXkPdagjxBCAD4v4JrvZHJzfhg9JzNfzuLzWne3AuvOdChwojOX8+3ycF3RAWDzsoFf6OzyAnl0prDAP3Sm5BkoQ+dcbAM16OwyAvXoTAGBu+jMqWegDZ3zSRuwQGcfLmCHzhwoYI0eBfjH7g8dALZn5w30RGfvJtAfvZvAKPQoYPcdGIvO+402MAOdvVlgHnqzwGz0KFB/BjTQOa/cgBI6e7GAHnqxgCp6FMifAW10zjMb8IDOngj4QU8EvKEzv+ZC/l4Hu8TsAAAAAElFTkSuQmCC\",\n      \"ps2n2c16.png\", false, 32, 32, \"a3774d09367dd147a3539d2d2f6ca133\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAFS3GZcAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAANQTFRFAAD/injSVwAAAApJREFUeJxjYAAAAAIAAUivpHEAAAAASUVORK5CYII=\",\n      \"s01i3p01.png\", false, 1, 1, \"c987217b78dd44056a9da58cf06b8c7a\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAANQTFRFAAD/injSVwAAAApJREFUeJxjYAAAAAIAAUivpHEAAAAASUVORK5CYII=\",\n      \"s01n3p01.png\", false, 1, 1, \"c987217b78dd44056a9da58cf06b8c7a\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAIAAAACAQMAAAE/f6/xAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAANQTFRFAP//GVwvJQAAAAtJREFUeJxjYAABAAAGAAH+jGfIAAAAAElFTkSuQmCC\",\n      \"s02i3p01.png\", false, 2, 2, \"e1b1f768e50f5269db92782b4ad62247\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAIAAAACAQMAAABIeJ9nAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAANQTFRFAP//GVwvJQAAAAxJREFUeJxjYGBgAAAABAAB9hc4VQAAAABJRU5ErkJggg==\",\n      \"s02n3p01.png\", false, 2, 2, \"e1b1f768e50f5269db92782b4ad62247\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAMAAAADAQMAAAEb4RdqAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAZQTFRFAP8A/3cAseWlnwAAAAxJREFUeJxjYIADBwAATABB2snmHAAAAABJRU5ErkJggg==\",\n      \"s03i3p01.png\", false, 3, 3, \"b05c579eb095ddac5d3b30e0329c33f4\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAMAAAADAQMAAABs5if8AAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAZQTFRFAP8A/3cAseWlnwAAAA5JREFUeJxjYGBwYGAAAADGAEE5MQxLAAAAAElFTkSuQmCC\",\n      \"s03n3p01.png\", false, 3, 3, \"b05c579eb095ddac5d3b30e0329c33f4\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAQAAAAEAQMAAAHkODyrAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAZQTFRF/wB3//8AmvdDuQAAABRJREFUeJxjaGAAwQMMDgwTGD4AABmuBAG53zf2AAAAAElFTkSuQmCC\",\n      \"s04i3p01.png\", false, 4, 4, \"c268bd54d984c22857d450e233766115\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAQAAAAEAQMAAACTPww9AAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAZQTFRF/wB3//8AmvdDuQAAAA9JREFUeJxj+MAwAQg/AAAMCAMBgre2CgAAAABJRU5ErkJggg==\",\n      \"s04n3p01.png\", false, 4, 4, \"c268bd54d984c22857d450e233766115\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFAgMAAAGHBv7gAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAlQTFRFAP//dwD//wAAQaSqcwAAABlJREFUeJxjaGBoYFjAACI7gHQAEE9tACIATYMG43AkRkUAAAAASUVORK5CYII=\",\n      \"s05i3p02.png\", false, 5, 5, \"fceb20e261cb29ebb6349bc6c2265beb\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFAgMAAADwAc52AAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAlQTFRFAP//dwD//wAAQaSqcwAAABRJREFUeJxjWNXAMLWBYSKYXNUAACoHBZCujPRKAAAAAElFTkSuQmCC\",\n      \"s05n3p02.png\", false, 5, 5, \"fceb20e261cb29ebb6349bc6c2265beb\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGAgMAAAHqpTdNAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAlQTFRFAP8AAHf//wD/o0UOaAAAACJJREFUeJxjaGBoYJgAxA4MLQwrGDwYIhimJjBMSGBYtQAAWccHTMhl7SQAAAAASUVORK5CYII=\",\n      \"s06i3p02.png\", false, 6, 6, \"b5c9900082b8119515e3b00634a379c5\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGAgMAAACdogfbAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAlQTFRFAP8AAHf//wD/o0UOaAAAABZJREFUeJxjWLWAYWoCwwQwAjJWLQAAOc8GXylw/coAAAAASUVORK5CYII=\",\n      \"s06n3p02.png\", false, 6, 6, \"b5c9900082b8119515e3b00634a379c5\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHAgMAAAHOO4/WAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAxQTFRF/wB3AP93//8AAAD/G0OznAAAACVJREFUeJxjOMBwgOEBwweGDQyvGf4z/GFIAcI/DFdjGG7MAZIAweMMgVWC+YkAAAAASUVORK5CYII=\",\n      \"s07i3p02.png\", false, 7, 7, \"cefe38d2a35e41b73b6270a398c283e8\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHAgMAAAC5PL9AAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAxQTFRF/wB3AP93//8AAAD/G0OznAAAABpJREFUeJxj+P+H4WoMw605DDfmgEgg+/8fAHF5CrkeXW0HAAAAAElFTkSuQmCC\",\n      \"s07n3p02.png\", false, 7, 7, \"cefe38d2a35e41b73b6270a398c283e8\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAgMAAAHOZmaOAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAxQTFRFAP//dwD/d/8A/wAAqrpZHAAAACVJREFUeJxjYAACASB+wGDHoAWk9zDMYVjBoLWCQbeCQf8HUAAAUNcF93DTSq8AAAAASUVORK5CYII=\",\n      \"s08i3p02.png\", false, 8, 8, \"3f0fc2c825d2fad899359508e7f645e1\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAgMAAAC5YVYYAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAxQTFRFAP//dwD/d/8A/wAAqrpZHAAAABtJREFUeJxjYGBg0FrBoP+DQbcChIAMIJeBAQA9VgU9+UwQEwAAAABJRU5ErkJggg==\",\n      \"s08n3p02.png\", false, 8, 8, \"3f0fc2c825d2fad899359508e7f645e1\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAgMAAAHq+N4VAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAxQTFRFAP8AAHf//wD//3cA/1YAZAAAACNJREFUeJxjYEACC4BYC4wYGF4zXAdiBgb7/wwMltEQDGQDAHX/B0YWjJcDAAAAAElFTkSuQmCC\",\n      \"s09i3p02.png\", false, 9, 9, \"5c55b2480d623eae3a3aaac444eb9542\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAgMAAACd/+6DAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAAAxQTFRFAP8AAHf//wD//3cA/1YAZAAAAB9JREFUeJxjYAAC+/8MDFarGRgso4FYGkKD+CBxIAAAaWUFw2pDfyMAAAAASUVORK5CYII=\",\n      \"s09n3p02.png\", false, 9, 9, \"5c55b2480d623eae3a3aaac444eb9542\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAAH2U1dRAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAANhJREFUeJx9kL0OgjAURj9FfuJTuBjXhqkkDvBGujo1casOLOyEgZmpM4kk8Fi29FYpMTbNl8O59+Y2AByC48nw5Ehe4Pr25orpfEeQ6LhPNgLgdmpQm2iWsdVxqA3V9lOyWKajTCEwWpDpx8TO6Oz3zMIoHYgtlWDORlWFqqDKgiAk6OBM6XoqgsgBPj0mC4QWcgUHJZW+QD1F56Yighx0ro82Ow5z4tEyDJ6ocfQFMuz8ER1/BaLs4HforcN6hMRF18KlMIyluP4QbCX0qz0hsN6yWjv/iTeEUtKElO3EIwAAAABJRU5ErkJggg==\",\n      \"s32i3p04.png\", false, 32, 32, \"bbe63d9433641df3fcd2c745fed89a93\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAAHxJREFUeJyV0b0NgCAQBeBXAIlxCRt6WrbyNqB3CSsnYTAPTYzvSIhSXMhHcn8A7ch25FiviA40wDEkVAZ4hh2RQXMa6JLmxZaNPwEdBJO0aB9u3NhzraJvBKuCfwNmXQVBW9YQ5AskC1xW2n4ZMDEU2FlCNrOYae+Pt3ACA2HDSOt6Ji4AAAAASUVORK5CYII=\",\n      \"s32n3p04.png\", false, 32, 32, \"bbe63d9433641df3fcd2c745fed89a93\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACEAAAAhBAMAAAHSze/KAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAAPZJREFUeJxdjzFywjAQRT/JMCjEBdzAkxN4RhdIwQHcuKeiplNLqZKWzrUr+jQ+gA6Vv6sVlnkey5K+Vm8NxBvmNMP7DpHzxLmL/HCHG+Cy8xI6l+M0y2GGYBw1lN0kq5gTOaThawlM434SRrT4UVqEsAvCFSNKmjNejpCz3RWTAUs/WsldVOM0Wug/vfISsPcmaWtFxBqrAkqVAesJ+jOkKQ0E/bMYXalhl1bUWRUbykVooPwtPHG5nPkunPG441Fzx8BnOyz0OBEdjF8ciQ7GAfjm9WsX5W+uWqMMK3r0tUZE5qo8m0OtEd48qlq5vtRXm8Td/wMULdZI1p9klQAAAABJRU5ErkJggg==\",\n      \"s33i3p04.png\", false, 33, 33, \"20708bc9a6ffa8d8ca6e004e1e9aa3ae\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACEAAAAhBAMAAAClyt9cAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAAL5JREFUeJxdzy0SwyAQhuGv0+n0V6Q36HCCzHCBih4gBh8VXVeLjIyNi0bV13CAHKrLDi27vAwrEMADpMaS5wN8Sm+EEHAKpQXD0NMu9bAWWytqMU+YZRMMXWxENzhaO1fqsK5rTONXxIPikbvjRfHIPXGleOQaNlWuM1GUa6H/VC46qV26ForEKRLnVB06SaJwiZKUUNn1D/vsEqZNI0mjP3h4SUrR60G3aBOzalcL5TqyTbmMqVzJqV0R5PoCM2LWk+YxJesAAAAASUVORK5CYII=\",\n      \"s33n3p04.png\", false, 33, 33, \"20708bc9a6ffa8d8ca6e004e1e9aa3ae\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACIAAAAiBAMAAAG/biZnAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAANJJREFUeJx9jr0KgzAURr9q/elbdJGu4mTAQR+pa6eAW+yQxV06ODs5CxX0sWrURHstDcnH4eTe3ABxBz6d5+74b8S7zcck72D7KvMx4XPaHfC4vVCpeP0OS0W1hAg9EQ0imqZhWElEm/OMm28tTdwQQkPzOrVl1pYpWplpcjQ1ME6aulKTawhbXUnI0dRsZG5hyJVHUr9bX5Hp8tl7UbOgXxJFHaL/NhUCYsBwJl0soO9QA5ddSc00vD90/TOgprpQA9rFXWpQMxAzLzIdh/+g/wDxGv/uWt+IKQAAAABJRU5ErkJggg==\",\n      \"s34i3p04.png\", false, 34, 34, \"0912e0f97224057b298f163739d1365f\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACIAAAAiBAMAAADIaRbxAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAAG1JREFUeJyVz7ENgCAQBdBfIIlb2NDbMpYb0LMEFZMwGKcWJv9HwSsu5CX8uwPOOnKNod0dKtbhSHY0EiwkBYHEglk0OW4yPfwXqHhOTraPG234vCcFYykqKwtUeFZS8Sx2NUjqhFz1LVl+vUgHrMXtiDoroU4AAAAASUVORK5CYII=\",\n      \"s34n3p04.png\", false, 34, 34, \"0912e0f97224057b298f163739d1365f\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACMAAAAjBAMAAAGb8J78AAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAAQRJREFUeJxlkD2uglAUhMf4A1GL93ZAWIHJ2YCFC7Cxt7Kmo7WktLWjprJ/DQu4i3pzzuUAF4fwk5k7+SYAzRN96CFyQsPvEIC80ZcIDf04iYZ5HmOeZaQOYzoxDRY05og7MCePDtQ5Al2770woUEahrrPahBaeluWUqiqmMWqBMS2GtEYGHR4XdK2flLVI3OO0AqE/hrjXuRWb3sVIEfHuRLMifxEGbsauFdl/Dk1NvTsthXeDdytUMP3N9MHjcec90x3vF96JXrjx2t5muuJC2cN1xi9lD9cPcCBjQeSGJXEpEhMYdU1hm5E4wlZGTGAHFj9IYTsd8A1MiVujzokXHXH+B9CK7qGbaRQOAAAAAElFTkSuQmCC\",\n      \"s35i3p04.png\", false, 35, 35, \"b46d9ba87963f526624a6d485ff6465e\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACMAAAAjBAMAAADs965qAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAAMdJREFUeJxl0SEOg0AQheHXtJSmmPYGhBOQcIEKDoDBo9C42spKLA6Nqq/hAHuoPqZhM7P7E0asmOyXBbbeqpec4Kv6YFkWXBfVjL7v+Ks6VBWOla7ENGIyjSi4vdDlaPklraqBc27dhm9FzWTsPfBkMvYG3JmMvZv4QmNGlTXOvFdo5FFkDCoD4N8YRqPhsSbgsdXyTt7oeak3et5BjIZ3EaPhZVwv76h4kuWdN3JMjIwjImMOa0zEaY3Ocb021tsVrJE+pMMPA+LuR86i5UgAAAAASUVORK5CYII=\",\n      \"s35n3p04.png\", false, 35, 35, \"b46d9ba87963f526624a6d485ff6465e\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACQAAAAkBAMAAAFkKbU9AAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAANlJREFUeJyNkb0KgzAURj/b+tO36CJdxUnBob5Ru3YKuGkHF3dxcHZyDlTQx2piTaJJC4bk43juvUEUiCgIO6/V8d6IVptMSUZx9HhmU0IwJwWe1+aOes7mV9ZzHr6JJfPAzcORbRCMC+Whcq5044bIgQoKXEGhcDn4svoqZRt9mQqyBXWQrpR9lSBHElRf9ZdgLdRVkCSqnaraqnozifXN61G0sT8siaINMGiqhq8rxDjpg7Fv3GUoOPFF72LvoF+/etipav4DtgosYSptELsHdXX2qaZa/jk/GoQXLvsYf8IAAAAASUVORK5CYII=\",\n      \"s36i3p04.png\", false, 36, 36, \"65e57e33b4763a3b0c3f0fa92295406d\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACQAAAAkBAMAAAATLoWrAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAAHdJREFUeJxjYACBwu5llqpHoCQDFiEgxcCCLmTAcARdiIEVXWgBgyq6ENB0DCEsxlsqYDpClSwhBixCbBjGNwDdhe4ILE5F4lBXCBToqEILgEKMqEIMnKoHGNCEgCQWoULCQgYYNjJgsZGBWBvJE8L0EBZvgwMHAABJBMjTkay+AAAAAElFTkSuQmCC\",\n      \"s36n3p04.png\", false, 36, 36, \"65e57e33b4763a3b0c3f0fa92295406d\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACUAAAAlBAMAAAFAtw2mAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAAP5JREFUeJxlkDsSgjAQhv8RHfFR6A0cTsBMLmDhAWjsrajpaFNS0tqlprK3yQFyKDcb8jD5GJLMssu3G2CS0EZDiBYTnY0Bat59DHxuBYG6nihgLBAcmSywm+Sclr9qjkvOKSOIESmxqOPCKNzQOG4Yx/3IDFAICU2TJDAglhUVEzYhYaA/2JFco4tacyEq4YhWGH02brigp0pfG0QQntiQu5S11vUNdzk8dmgx1FaxV1+rTWza19bWS3xTPuj7F70pL7xnvP+Z8aRn90zp8CB4CdxxJXgJXIATiXIvtVJ4C8hb0OVK5ppzyUa1FE5rLb04FN4OuZdG367zplJ6fx0nFJojsT+zAAAAAElFTkSuQmCC\",\n      \"s37i3p04.png\", false, 37, 37, \"f21eff5c07a755577fea69c01459c65f\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACUAAAAlBAMAAAA3sD0wAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAAMVJREFUeJxl0S0Og0AQhuEvoU36J+AGDSfYhAsgegAMHoWuq62sxOJWr6rHcAAO1dkppbMzD9kRmxB4M0D0kp58hUl6I4SAU5A8+r6jI3WoKmRVwmEcMKYGlPSJMnFFS8++lRosyzLH8TfjRnhsajwIj80dBeGxybnV9J4pUPV6+j/TS3e2V3M69ttrUK/RpKmiV6QylcoKLVerXXMnjd4NGrxqjbW212W2F0fbC9vbwPbOF91Lq96t+xXw26+MjUfFHuh8APqFElFWDb0cAAAAAElFTkSuQmCC\",\n      \"s37n3p04.png\", false, 37, 37, \"f21eff5c07a755577fea69c01459c65f\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACYAAAAmBAMAAAEtFMQLAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAANpJREFUeJylkT8LgkAchp/+WEFfokVapamDhvxGtTYduGmDi7s0NDc1Cwn6sTpF7w7PQEju9/L48N6pCMcCqeZuzeYjOfZT0I6sT1HNYtNkVHcpi5aB2/5xIW/z8TtzKzsDcbCOD5VaEknVY3yw7NrYaoABGucVxmJbmL2zUK0X7zTU6Gl8YWxqupnGlUGsbjYNUzR6ZzSGjFisbjjWbQrtdU2ewi/7JHkGlEOX4zsOwdLZK3z3PNexEjunp17FeYZ995dr/uR24JpvYoIb3euVlyl7x3pCnZd8AfUFRB95/EUWAAAAAElFTkSuQmCC\",\n      \"s38i3p04.png\", false, 38, 38, \"f6237240a70b5844def0406dc8f63bbd\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACYAAAAmBAMAAABaE/SdAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAAGpJREFUeJxjYACBwu5llqpHYCQDNjEgzcCCIWbAcARDjIEVQ2wBgyqGGNAKTDFsdlgqYHGLKrliDNjE2DDtaAC6D8Mt2NyMzBs4MaDL0MUMgGLcaGLAuClgQBcDkmSLYTEPm72DyS3gsAIA8mkrg86sROEAAAAASUVORK5CYII=\",\n      \"s38n3p04.png\", false, 38, 38, \"f6237240a70b5844def0406dc8f63bbd\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACcAAAAnBAMAAAEJinyQAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAARlJREFUeJxtkDFygzAQRZ/HkwSTFM4NGE7AjC6QIgdw457KtTtaSpVu3VFTuafhADpUVhISCOUxwPC1u/8voHtmM6NUg9ZgDBSimUSbaZRAUWgRjAXlFPmWavdaavypdopKlb6wStM4xTX1PeNQjh4q6gW67qPzMBAL6npTEGA5HcYhFFQ1a8E9FIyU2O20Dy0NSyPqqDzNmqHCzF8uuqwf49ylP06AdYKKE2LGym8eJsQ4OusvR8KEoyJMkCzE/s1ChAnoTYIBx5Tw4nZr5U5oeT547nhwlevtmnDhV3CPlR++BfdYOcOnuGXukih3zxH3nMvOeOOeOh/OmfE0Zc7tuzXfuT9O1nzv7n/lf+b7tQ8uQOpurXn9AQyWNfYM/uLgAAAAAElFTkSuQmCC\",\n      \"s39i3p04.png\", false, 39, 39, \"ceb3b33633c181e13ecee80b153fb602\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACcAAAAnBAMAAAB+jUwGAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAANVJREFUeJxt0iEOg0AQheFHSJuUGnqDhhOQcIEKDoDBo9A4LBKJxaFX4TEcgEN1ZklDZ2Z/YMQa+DIA3Cga/Bk20QrnHBInWtC2DT2iBkWBuJDlmCfMqgkZvSeTvVHTdatFFY7j2Hn8taOk/Lj6oKf8uOrwovy4Sr3b2p9k1faFvtPa6TBgN+UGftptZLdViv1nL0P2PmSX7ihV7JEXPhj2ttGxYidMV+7mznRlz2OmK/v0YDo0m25o+/kXGjfoDtED9g565dFv7WLlni/tDMeq7AxPli8bpjUVK/+f5gAAAABJRU5ErkJggg==\",\n      \"s39n3p04.png\", false, 39, 39, \"ceb3b33633c181e13ecee80b153fb602\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACgAAAAoBAMAAAEJ15XIAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAANpJREFUeJytjrEKgzAURa/FWmv7EV2kq2RS6FD/qK5OATd1cHEXB2cn50IL+lnVUBMxr4VCQ97N4ZC8POT+HcexclEQp/3g8GVBnHy4JANgT5kM66zjcx1jIxKLrFfpTFndROLN6aZPmdjgTKLjSUwXyL6gt+MSexCWAei2YVeKjXaBpUQotAoKAWPGTtmu/B1hzViEoPCqEK1EQ2GocGyWNXCfUdYEi0RW7QmJQJfcIiSaALqcltaTuvlJEiP9VZ7GAa21nCYBIUFIHHQJg3huUj3NiGvSHb9pXgoWak5w83t4AAAAAElFTkSuQmCC\",\n      \"s40i3p04.png\", false, 40, 40, \"140f0d2eb778dad4a1871c17767e2d48\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACgAAAAoBAMAAAB+0KVeAAAABGdBTUEAAYagMeiWXwAAAANzQklUBAQEd/i1owAAACdQTFRFAAAA/wB3AP//AP8AdwD/AHf/d/8A/wD//wAAAP93//8A/3cAAAD/9b8GOwAAAHVJREFUeJzN0LENgDAMRNFDiiwhlqBhiGxFNkifJagyBwWDEagQ/kXoSOHiyVZOp1K1HKnU+Jhi3BBHQCFGjxnRAGVRHms3Xq8LC51/Qurz99iacDg3tDcqpCyHbRLipgBXQk0ed8FHGggpUuCcuOnDYyF3dSfnZ1dwSF0UKQAAAABJRU5ErkJggg==\",\n      \"s40n3p04.png\", false, 40, 40, \"140f0d2eb778dad4a1871c17767e2d48\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAAAJ0Uk5TAA/mLNCpAAAAAmJLR0QAAKqNIzIAAAFISURBVCiRddExT8JAFMBxPoJHWUxcriQuJiaFqpNLWxkdLOVCHJjunSau9GByohwTk8Il+hkcHd0kLrIymLCaOLBq0epdbRRIeNv9pnfvn/temdw6eJktQXJPK7cL8BbRklmsjzNInsJquWRjc/8mhc9B6JZt13aLe6z9rGDEm2W7VvU8d5vzcwUTEXqMcxocMd48VfAqBM8mDI4VvENr2M3eXkMDE1Km4iO7r+BDgxaKkXGnAURv0JZd6uON/FRBDK1eBHIQOAgX9GJzOBO8psA0nIN0UyBdTuS1j228qeELKh0NJ9hCWxoSCCKmwMljtJv+FgJOiLwqGRg1foEyDVbBQv0UIspqRHawgnEKMQBoMNBOdsJHBb0ORvlxBkkERDQtdPh35FiDU5j9ZxgRQf3LxS5DQetL5eaCPiynnFystE2m6+r/AOOSVs9bKk33AAAAAElFTkSuQmCC\",\n      \"tbbn0g04.png\", false, 32, 32, \"d9b53613bd731e66dcfd5be93186c100\");\n  testPngSuiteImage(\"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\",\n      \"tbbn2c16.png\", false, 32, 32, \"75954a76132c3971509841e973f029cd\");\n  testPngSuiteImage(\"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\",\n      \"tbbn3p08.png\", false, 32, 32, \"d1f6636d81c74f163bfff1405bf406cf\");\n  testPngSuiteImage(\"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\",\n      \"tbgn2c16.png\", false, 32, 32, \"75954a76132c3971509841e973f029cd\");\n  testPngSuiteImage(\"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\",\n      \"tbgn3p08.png\", false, 32, 32, \"d1f6636d81c74f163bfff1405bf406cf\");\n  testPngSuiteImage(\"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\",\n      \"tbrn2c08.png\", false, 32, 32, \"75954a76132c3971509841e973f029cd\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgEAAAAAAGgflrAAAABGdBTUEAAYagMeiWXwAAAAJ0Uk5T///Itd/HAAAAAmJLR0T//xSrMc0AAAS8SURBVEiJY/hPIWCgqQGPH588+fEjWQa8eLF1a11damrUTjf9hB8LBR8JEG3Au3f793d2pqcnTvDZZSaiFaD+Unmr+hy9VwGeE72vbP/zB48Bnz4dOTJ1alFRzrzgSbYLdLP0t2s3q2VqLbc5rnRIglFqq/pLA46ctAULzp//8QPNgO/fT52aNausrLg4bZXHY0NO/SyjbSYXbALsZM1bDAOtZ7tWGFerbdNl1noZ1Z6XV1xcVjZ79pEj797BDThzpr6+rKwUCPzEzc3NmM3m2sSE2qTIBag5zne+6L7dNdAxy07O/IKaWc68UijIypo1C27AnTutrR0dLS3V1ckcLp7u8omvyqLLwaCINeFw2N4gEb9Yb1HfVUk3IaIFBTExQUF798INePWqpaWxsd2zr6+zs76+Ei8oK0tODgkJCPDxefYMbsCPH02FGe5JVypsJtyYPLm/v7m5GgNUAUFlZVZWeDhIs6dnZCRKLHR1ZV4pmdXXPEF20qSpU6dPnzKlvb0GDRQWRnMb3RQpkSjTXeO2p6kJxYBJkzLX5fv2b+zPnThxypTp02fOnD175szu7vr6OiCorS0vT0oKuaR6XbxY4ASPEPd1fek1a1AMmDIl/WMWQ6t4/8YJ8ZMnTy6skqxPnf5r3rw5c/r66uqysqKiwtfrPJOeLpTCc4H9Obe6CvO1aygGLFmSbpoiW3oc6IbCSZNaGPK2JbflGc2dO3/+ggVVVVFRkZF2grIBYod4FaVieUVFCmz//v6NYsC2bWn88empD7tS+ionzKpTL4uLksr7M2fOvHnz55eUREYGfVWYLT2dv8vyioeHlIz+/6IitKR8/HhKXYZNMGf16n6pqkulHaWGkc0FlbNnz507b15eXmSklYxsgLCotrzLEiUuIXdBs7n6aAbcuJEckWHjkZ8T3fsmOr0kqmRWxJv8R7NmgYxITw+fpBwDtP+2+XqxY0KafI5i9sePoxnw6lXi8dSHfsGx9o19SREZnEXXIkILFGbMmDVrzpzERE9X2QBRF8Vz0p/5lHl8eXyVjn/5gmbAnz8JZ5PbwvdHHCxcUcIc9rtwRcjZkhZQdM6aFRVlKSLjzp9hHCS9j1eD10LwUmAwluyc9yhhSsKUUNPMipobgbcLqoLnFzeDktS0aeHh2q8lW7m/OizQ1hY3EpnM49v+HIsBPT3x8ulLA5dlPCr7GvEmb1tQUeHryZOnTu3vDwtTihd14Utxdzd1F5ovxCMkd/QoFgN+/Vqckfw8WTW9KbMnrSLnU+Dt0uqJEydP7uwMDZUxFuIRnGVxVjReJFL++7a0//+xGAACFy7k5qampj3OuJytF7CuVKm/f+LExsbQUEV1fl2eBgEBgdWqnec5///HacD//2/etLWlVaXzZWYGiBcr9Pb291dVhYToN/KJcNdzJxqeeDDh/3+8BoDiY9WqdNP0pX4vi2d3d/f2lpQEB9vaSisLO/lYvNNAV42jWL9yuKg14mD9jY6O7u7c3KAgf39z8/LyX7+wqcVRL7x/v2BBc3NbW0dHenpgYEDAggV//2JXibNm+vfvwIHW1ra2xMSgoO3bcakiULXduzdhQmrqmTP41BCoXL9+ffwYvwqKa2cA4MyW1TM3HhMAAAAASUVORK5CYII=\",\n      \"tbwn0g16.png\", false, 32, 32, \"56ea136a6e299452015ac02a7837e365\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAAYagMeiWXwAAAt9QTFRF////gFZWtbW4qEJCn5+fsSAgixUVnZ2dGxtZm5ubAACEmZmZj6ePl5eXlZWVk5OTKSlWkZGRAACbj4+Pi5WLLi6njY2NgAAAi4uLuQAAiYmJDAzVeHV1h4eHAACyhYWFpQAA3gAAgYGBf39/AACefX19AADJe3t7eXl5NzdWd3d3dXV1c3NzSKlIjgAAAgJkAABiVolWKCh8U4tTiYmPZ2dnZWVlXW1dE+UThiYmby0tRJFEYWFhO507RIlEPZM9AACkAPMAAPEAWVlZV1dXVVVVU1NTNIU0UVFRJJckT09POjpBEBC6sg8PAMcAAMUA/Pz8AMMABASXAMEALXct+vr6AL8AAABoAL0A2tTUEBB7Ca0J+Pj4ALkAALcAnJyh9vb2DKEMALMAALEAEJEQAKsA8vLyAKkAAKcA7u7u7OzsAJcA6urqAABrAI0AAIsAAIkAAIcAMTExGRkqBwdAEhKuCQnu09bTzMzMkwAAoyoqxsbGxMTEzAAA0woKgWtreD4+AwNtAACfCgpWRkZIQUFNc11dUQcHqKio7e3voKCgnp6enJycAAC5mpqasgAAmJiY6wAAlpaWngAAlJSUExMckpKSkJCQjo6OAACRioqKiIiIdqJ2hYiFhoaGhISEeA8PgoKCfoJ+fn5+fHx8enp6SsBKdnZ2dHR0cnJycHBwmAAAbm5uanBqemZmampqhAAARKJES5ZLYWRhYmJiAPQAOJg4XFxcWlpaAOYAAgJdQnhCVlZWAADwLpQuR2hHMTFgANgAUlJSUFBQAM4AIZghFBRtAMgATExM/f39AMYAAACdb2tr6g4OSEhIALwANGY0AgL1U1NgALAAAK4AtwAAAKQA7+/vAKIAj09PlTQ0AJgAAJYAAJIA5+fnAIwA4+PjAIAAkgYGAQFvZFZZAABkTk5rz8/P3d3gAAB7ycnJFhZBISFZV1dZRER4v7+/693dLS1UCgpgAAD/v319DyW3rQAAAAF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAACiklEQVQ4jWNgoDJ48CoNj+w9psVmTyyZv3zAKpv5Xsq0rYFNb4P4htVVXyIDUGXTavhWnmmwrJxcKb7Aqr29fcOjdV3PY2CyMa/6luu0WT6arNBfWyupwGa5QHy13pM1Oss5azLBCiqUl2tr35Lsv+p76yarouLEiYq1kuJntIFgfR9YwQv52fPVGX1Zb8poaWnVM9edPVtXxQhkrtp+6D1YQc58pbkzpJQ1UMHyLa6HT9yDuGGR5zVbEX7h+eowsHSpxnqXwyfOOUNdOSvplOOyaXy8U2SXQMHK7UZBUQItC6EKpkVHbLUQnMLLzcktobx4sarWlks+ajPDwwU6oAqmJCbt3DqHX2SjLk93z4zF63e8ld7btKvEgKMcqqDjaOrxrcum6Z5P38fO0rV0h7PoZ7VdxVObNWHBybTvxpWdTiIbj9/e1tPNssL52cW9jd7nXgushAVltXty3hHHTbZ+t+052bvXAA1weNMa1TQzHqYgcnfyw1inFNtT2fZ9nOymb8v2Nh4IUnn5qRqmIGf3lcLEgxmegXfsJ/T12Lz73Mvx+mVuLkcCTEHA/vQ7IcH+d4PvbuLl7tshepHrY7H+Y6FniNhee+3a/sSD+WF5m/h4J7mU7g1vLToml2uCUCB24/IFu+PZ5+9b8/MJ7/Hp1W854HC6uRqhIJTHfbNZ9JXYfGNBfinX0tOfDgTJcTChJKnna8z2JcUVGAoLKrlGcelzzTz2HC1JZs0zv5xUYCwmvNT1Y+NTA6MXDOggoOPo5UJDCbEVbt7FJe86MeSBoHxbyKLZEmsOeRVphWKTZ2C43jV/3mxTj8NdJ7HLA8F7+Xk2h5hwSgPBi+lmFfjkGRgSHuCXxwQADa7/kZ2V28AAAAAASUVORK5CYII=\",\n      \"tbwn3p08.png\", false, 32, 32, \"d1f6636d81c74f163bfff1405bf406cf\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAAYagMeiWXwAAAuJQTFRF////gFZWtbW4qEJCn5+fsSAgixUVnZ2dGxtZm5ubAACEmZmZj6ePl5eXlZWVk5OTKSlWkZGRAACbj4+Pi5WLLi6njY2NgAAAi4uLuQAAiYmJDAzVeHV1h4eHAACyhYWFpQAA3gAAgYGBf39/AACefX19AADJe3t7eXl5NzdWd3d3dXV1c3NzSKlIjgAAAgJkAABiVolWKCh8U4tTiYmPZ2dnZWVlXW1dE+UThiYmby0tRJFEYWFhO507RIlEPZM9AACkAPMAAPEAWVlZV1dXVVVVU1NTNIU0UVFRJJckT09POjpBEBC6sg8PAMcAAMUA/Pz8AMMABASXAMEALXct+vr6AL8AAABoAL0A2tTUEBB7Ca0J+Pj4ALkAALcAnJyh9vb2DKEMALMAALEAEJEQAKsA8vLyAKkAAKcA7u7u7OzsAJcA6urqAABrAI0AAIsAAIkAAIcAMTExGRkqBwdAEhKuCQnu09bTzMzMkwAAoyoqxsbGxMTEzAAA0woKgWtreD4+AwNtAACfCgpWRkZIQUFNc11dUQcHqKio7e3voKCgnp6enJycAAC5mpqasgAAmJiY6wAAlpaWngAAlJSUExMckpKSkJCQjo6OAACRioqKiIiIdqJ2hYiFhoaGhISEeA8PgoKCfoJ+fn5+fHx8enp6SsBKdnZ2dHR0cnJycHBwmAAAbm5uanBqemZmampqhAAARKJES5ZLYWRhYmJiAPQAOJg4XFxcWlpaAOYAAgJdQnhCVlZWAADwLpQuR2hHMTFgANgAUlJSUFBQAM4AIZghFBRtAMgATExM/f39AMYAAACdb2tr6g4OSEhIALwANGY0AgL1U1NgALAAAK4AtwAAAKQA7+/vAKIAj09PlTQ0AJgAAJYAAJIA5+fnAIwA4+PjAIAAkgYGAQFvZFZZAABkTk5rz8/P3d3gAAB7ycnJFhZBISFZV1dZRER4v7+/693dLS1UCgpgAAD/v319//8A490yiQAAAAF0Uk5TAEDm2GYAAAABYktHRPVF0hvbAAACiklEQVQ4jWNgoDJ48CoNj+w9psVmTyyZv3zAKpv5Xsq0rYFNb4P4htVVXyIDUGXTavhWnmmwrJxcKb7Aqr29fcOjdV3PY2CyMa/6luu0WT6arNBfWyupwGa5QHy13pM1Oss5azLBCiqUl2tr35Lsv+p76yarouLEiYq1kuJntIFgfR9YwQv52fPVGX1Zb8poaWnVM9edPVtXxQhkrtp+6D1YQc58pbkzpJQ1UMHyLa6HT9yDuGGR5zVbEX7h+eowsHSpxnqXwyfOOUNdOSvplOOyaXy8U2SXQMHK7UZBUQItC6EKpkVHbLUQnMLLzcktobx4sarWlks+ajPDwwU6oAqmJCbt3DqHX2SjLk93z4zF63e8ld7btKvEgKMcqqDjaOrxrcum6Z5P38fO0rV0h7PoZ7VdxVObNWHBybTvxpWdTiIbj9/e1tPNssL52cW9jd7nXgushAVltXty3hHHTbZ+t+052bvXAA1weNMa1TQzHqYgcnfyw1inFNtT2fZ9nOymb8v2Nh4IUnn5qRqmIGf3lcLEgxmegXfsJ/T12Lz73Mvx+mVuLkcCTEHA/vQ7IcH+d4PvbuLl7tshepHrY7H+Y6FniNhee+3a/sSD+WF5m/h4J7mU7g1vLToml2uCUCB24/IFu+PZ5+9b8/MJ7/Hp1W854HC6uRqhIJTHfbNZ9JXYfGNBfinX0tOfDgTJcTChJKnna8z2JcUVGAoLKrlGcelzzTz2HC1JZs0zv5xUYCwmvNT1Y+NTA6MXDOggoOPo5UJDCbEVbt7FJe86MeSBoHxbyKLZEmsOeRVphWKTZ2C43jV/3mxTj8NdJ7HLA8F7+Xk2h5hwSgPBi+lmFfjkGRgSHuCXxwQADa7/kZ2V28AAAAAASUVORK5CYII=\",\n      \"tbyn3p08.png\", false, 32, 32, \"d1f6636d81c74f163bfff1405bf406cf\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAgMAAAAOFJJnAAAADFBMVEUAAP8AAP8AAP8AAP+1n0POAAAAA3RSTlMAVaoLuSc5AAAAFElEQVR4XmNkAIJQIB4sjFWDiwEAKxcVYRYzLkEAAAAASUVORK5CYII=\",\n      \"tm3n3p02.png\", false, 32, 32, \"82e044043a1f2c91533b2fea5e271daa\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAAAAABWESUoAAAABGdBTUEAAYagMeiWXwAAAoZJREFUOI1jqCcAGEhU8PjkRzwKXmytS41yS1z4EKuCd/s70xN9zbQ0VDT0AyZe+YOq4NORqUU5wXZ6Bjrq2rbKEtIaBjkLzv+AKfh+alZZcZqnoYGxqY2dhaGNq7G6rnZUXnHZ7CPvwArO1JeVlvqZm5nbhKYEOLl4uDrZWajllAJB1iywgjutHS3VyS7uSWXl5eVFieFBft5+yUBmQUzQXrCCVy2N7X2d9ZWooCw5JMDnGVjBj6aMpIoJk/ubq2GgqqoyKzzAxzMS6ouuzJK+/klTp09pr4GCwmhjEQldtyaogkmZ+f39E6dMnzl7Znd9XV1teVKIqrggD4/+GqiCKemZLf0TJk+uqp8+b05fXVZUuK60EC8Ht8o1qIIl6Sml/f2TmvOS8+bOX1AVFWknK8YrxSti9xuqYFtafGpX34S6sqi8OfPml0QGK0jzW3lIGRTBgvp4SkZwdV9VaWlkwey58/IirWSFtV2UhATnwhTcSM7wyOmNLimJyJ81e256uLK0gLm4EJ/YcZiCV4mpfrGNSRlFEQUzZs1J9JQVVZLh4+FR/gJT8CchOTyisDi8MKRk+sxZUZYy/MYyvLxCgYjozktICM2sCSwILp46fVq4jiSPg7a4CE87QkFPfHpgRllEXlDh5Kn9YUqifO6mQkJCRxEKfi1OTk7PTMsJLJ04uTNURkjQUlREYRtKkruQm5qWkR1Q2j+xMVSRn0dAQPUcWpp805aWnhlQ3NtfFaLPx81t+AAj0f5ZlZ7uX9zdWxJsKy3s8xZbsr9SFFHf0Z0b5G9e/gt7vni/oLmtIz0wYMFfbPkCBP4daG1LDNqOLISe9e5NSD1Tj09B/dfH9fgVYAAA90bMUdlj1V0AAAAASUVORK5CYII=\",\n      \"tp0n0g08.png\", false, 32, 32, \"38deadbdfb7b0ff5a2b4cad35e866b39\");\n  testPngSuiteImage(\"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\",\n      \"tp0n2c08.png\", false, 32, 32, \"c37c05b6929096c1736f91dccbe93d15\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAAYagMeiWXwAAAt9QTFRFFBRtgFZWtbW4qEJCn5+fsSAgixUVnZ2dGxtZm5ubAACEmZmZj6ePl5eXlZWVk5OTKSlWkZGRAACbj4+Pi5WLLi6njY2NgAAAi4uLuQAAiYmJDAzVeHV1h4eHAACyhYWFpQAA3gAAgYGBf39/AACefX19AADJe3t7eXl5NzdWd3d3dXV1c3NzSKlIjgAAAgJkAABiVolWKCh8U4tTiYmPZ2dnZWVlXW1dE+UThiYmby0tRJFEYWFhO507RIlEPZM9AACkAPMAAPEAWVlZV1dXVVVVU1NTNIU0UVFRJJckT09POjpBEBC6sg8PAMcAAMUA/Pz8AMMABASXAMEALXct+vr6AL8AAABoAL0A2tTUEBB7Ca0J+Pj4ALkAALcAnJyh9vb2DKEMALMAALEAEJEQAKsA8vLyAKkAAKcA7u7u7OzsAJcA6urqAABrAI0AAIsAAIkAAIcAMTExGRkqBwdAEhKuCQnu09bTzMzMkwAAoyoqxsbGxMTEzAAA0woKgWtreD4+AwNtAACfCgpWRkZIQUFNc11dUQcHqKio7e3voKCgnp6enJycAAC5mpqasgAAmJiY6wAAlpaWngAAlJSUExMckpKSkJCQjo6OAACRioqKiIiIdqJ2hYiFhoaGhISEeA8PgoKCfoJ+fn5+fHx8enp6SsBKdnZ2dHR0cnJycHBwmAAAbm5uanBqemZmampqhAAARKJES5ZLYWRhYmJiAPQAOJg4XFxcWlpaAOYAAgJdQnhCVlZWAADwLpQuR2hHMTFgANgAUlJSUFBQAM4AIZgh////AMgATExM/f39AMYAAACdb2tr6g4OSEhIALwANGY0AgL1U1NgALAAAK4AtwAAAKQA7+/vAKIAj09PlTQ0AJgAAJYAAJIA5+fnAIwA4+PjAIAAkgYGAQFvZFZZAABkTk5rz8/P3d3gAAB7ycnJFhZBISFZV1dZRER4v7+/693dLS1UCgpgAAD/v319RGIGqgAAApBJREFUOI1jUCYAGEhU8OBVGh4F95gWmz2xZP7yAauCzPdSpm0NbHobxDesrvoSGYCqIK2Gb+WZBsvKyZXiC6za29s3PFrX9TwGpiDmVd9ynTbLR5MV+mtrJRXYLBeIr9Z7skZnOWdNJlhBhfJybe1bkv1XfW/dZFVUnDhRsVZS/Iw2EKzvAyt4IT97vjqjL+tNGS0trXrmurNn66oYgcxV2w+9ByvIma80d4aUsgYqWL7F9fCJexA3LPK8ZivCLzxfHQaWLtVY73L4xDlnqC9mJZ1yXDaNj3eK7BIoWLndKChKoGUhVMG06IitFoJTeLk5uSWUFy9W1dpyyUdtZni4QAdUwZTEpJ1b5/CLbNTl6e6ZsXj9jrfSe5t2lRhwlEMVdBxNPb512TTd8+n72Fm6lu5wFv2stqt4arNmAFQB074bV3Y6iWw8fntbTzfLCudnF/c2ep97LbASFtTV7sl5Rxw32frdtudk714DNMDhTWtU08x4mILI3ckPY51SbE9l2/dxspu+LdvbeCBI5eWnapiCnN1XChMPZngG3rGf0Ndj8+5zL8frl7m5HAkwBQH70++EBPvfDb67iZe7b4foRa6PxfqPhZ4honvttWv7Ew/mh+Vt4uOd5FK6N7y1iEEu1wShQOzG5Qt2x7PP37fm5xPe49Or33LA4XRzNUJBKI/7ZrPoK7H5xoL8Uq6lpz8dCJLjYEJJcs/XmO1LiiswFBZUco3i0ueayfAcLU1mzTO/nFRgLCa81PVj41MDoxcYiTag4+jlQkMJsRVu3sUl7zqxJfvybSGLZkusOeRVpBWKPV9c75o/b7apx+Guk9jyBQgcey8/z+YQE7IQetZ7Md2sQhmfAuWEB8r4FWAAANxEPMkO1rmYAAAAAElFTkSuQmCC\",\n      \"tp0n3p08.png\", false, 32, 32, \"985ccf415de9754ff21296de6cf69a38\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAAYagMeiWXwAAAt9QTFRF////gFZWtbW4qEJCn5+fsSAgixUVnZ2dGxtZm5ubAACEmZmZj6ePl5eXlZWVk5OTKSlWkZGRAACbj4+Pi5WLLi6njY2NgAAAi4uLuQAAiYmJDAzVeHV1h4eHAACyhYWFpQAA3gAAgYGBf39/AACefX19AADJe3t7eXl5NzdWd3d3dXV1c3NzSKlIjgAAAgJkAABiVolWKCh8U4tTiYmPZ2dnZWVlXW1dE+UThiYmby0tRJFEYWFhO507RIlEPZM9AACkAPMAAPEAWVlZV1dXVVVVU1NTNIU0UVFRJJckT09POjpBEBC6sg8PAMcAAMUA/Pz8AMMABASXAMEALXct+vr6AL8AAABoAL0A2tTUEBB7Ca0J+Pj4ALkAALcAnJyh9vb2DKEMALMAALEAEJEQAKsA8vLyAKkAAKcA7u7u7OzsAJcA6urqAABrAI0AAIsAAIkAAIcAMTExGRkqBwdAEhKuCQnu09bTzMzMkwAAoyoqxsbGxMTEzAAA0woKgWtreD4+AwNtAACfCgpWRkZIQUFNc11dUQcHqKio7e3voKCgnp6enJycAAC5mpqasgAAmJiY6wAAlpaWngAAlJSUExMckpKSkJCQjo6OAACRioqKiIiIdqJ2hYiFhoaGhISEeA8PgoKCfoJ+fn5+fHx8enp6SsBKdnZ2dHR0cnJycHBwmAAAbm5uanBqemZmampqhAAARKJES5ZLYWRhYmJiAPQAOJg4XFxcWlpaAOYAAgJdQnhCVlZWAADwLpQuR2hHMTFgANgAUlJSUFBQAM4AIZghFBRtAMgATExM/f39AMYAAACdb2tr6g4OSEhIALwANGY0AgL1U1NgALAAAK4AtwAAAKQA7+/vAKIAj09PlTQ0AJgAAJYAAJIA5+fnAIwA4+PjAIAAkgYGAQFvZFZZAABkTk5rz8/P3d3gAAB7ycnJFhZBISFZV1dZRER4v7+/693dLS1UCgpgAAD/v319DyW3rQAAAAF0Uk5TAEDm2GYAAAKKSURBVDiNY2CgMnjwKg2P7D2mxWZPLJm/fMAqm/leyrStgU1vg/iG1VVfIgNQZdNq+FaeabCsnFwpvsCqvb19w6N1Xc9jYLIxr/qW67RZPpqs0F9bK6nAZrlAfLXekzU6yzlrMsEKKpSXa2vfkuy/6nvrJqui4sSJirWS4me0gWB9H1jBC/nZ89UZfVlvymhpadUz1509W1fFCGSu2n7oPVhBznyluTOklDVQwfItrodP3IO4YZHnNVsRfuH56jCwdKnGepfDJ845Q105K+mU47JpfLxTZJdAwcrtRkFRAi0LoQqmRUdstRCcwsvNyS2hvHixqtaWSz5qM8PDBTqgCqYkJu3cOodfZKMuT3fPjMXrd7yV3tu0q8SAoxyqoONo6vGty6bpnk/fx87StXSHs+hntV3FU5s1YcHJtO/GlZ1OIhuP397W082ywvnZxb2N3udeC6yEBWW1e3LeEcdNtn637TnZu9cADXB40xrVNDMepiByd/LDWKcU21PZ9n2c7KZvy/Y2HghSefmpGqYgZ/eVwsSDGZ6Bd+wn9PXYvPvcy/H6ZW4uRwJMQcD+9Dshwf53g+9u4uXu2yF6ketjsf5joWeI2F577dr+xIP5YXmb+HgnuZTuDW8tOiaXa4JQIHbj8gW749nn71vz8wnv8enVbzngcLq5GqEglMd9s1n0ldh8Y0F+KdfS058OBMlxMKEkqedrzPYlxRUYCgsquUZx6XPNPPYcLUlmzTO/nFRgLCa81PVj41MDoxcM6CCg4+jlQkMJsRVu3sUl7zox5IGgfFvIotkSaw55FWmFYpNnYLjeNX/ebFOPw10nscsDwXv5eTaHmHBKA8GL6WYV+OQZGBIe4JfHBAANrv+RnZXbwAAAAABJRU5ErkJggg==\",\n      \"tp1n3p08.png\", false, 32, 32, \"d1f6636d81c74f163bfff1405bf406cf\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAEAAADurUJNAAAABGdBTUEAAYagMeiWXwAAAEFJREFUeJxjZGAkABQIyLMMBQWMDwgp+PcfP2B5MBwUMMoRkGdkonlcDAYFjI/wyv7/z/iH5nExGBQwyuCVZWQEAFDl/nE14thZAAAAAElFTkSuQmCC\",\n      \"xc1n0g08.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAkAAAArGWqiAAAABGdBTUEAAYagMeiWXwAAAEhJREFUeJzt1cEJADAMAkCF7JH9t3ITO0Qr9KH4zuErtA0EO4AKFPgcoO3kfUx4QIECD0qHH8KEBxQo8KB0OCOpQIG7cHejwAGCsfleD0DPSwAAAABJRU5ErkJggg==\",\n      \"xc9n2c08.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBORw0NGg0AAAANSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAAEhJREFUeJxjYGAQFFRSMjZ2cQkNTUsrL2cgQwCV29FBjgAqd+ZMcgRQuatWkSOAyt29mxwBVO6ZM+QIoHLv3iVHAJX77h0ZAgAfFO4B6v9B+gAAAABJRU5ErkJggg==\",\n      \"xcrn0g04.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQAAAABbAUdZAAAABGdBTUEAAYagMeiWXwAAAFtJREFUeJwtzLEJAzAMBdHr0gSySiALejRvkBU8gsGNCmFFB1Hx4IovqurSpIRszqklUwbnUzRXEuIRsiG/SyY9G0JzJSVei9qynm9qyjBpLp0pYW7pbzBl8L8fEIdJL0NTVU0AAAAASUVORK5CYII=\",\n      \"xcsn0g01.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAAIAAADMaKZiAAAABGdBTUEAAYagMeiWXwAAAEhJREFUeJzt1cEJADAMAkCF7JH9t3ITO0Qr9KH4zuErtA0EO4AKFPgcoO3kfUx4QIECD0qHH8KEBxQo8KB0OCOpQIG7cHejwAGCsfleD0DPSwAAAABJRU5ErkJggg==\",\n      \"xd0n2c08.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAwIAAACLyNyyAAAABGdBTUEAAYagMeiWXwAAAEhJREFUeJzt1cEJADAMAkCF7JH9t3ITO0Qr9KH4zuErtA0EO4AKFPgcoO3kfUx4QIECD0qHH8KEBxQo8KB0OCOpQIG7cHejwAGCsfleD0DPSwAAAABJRU5ErkJggg==\",\n      \"xd3n2c08.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgYwIAAAAS+qv/AAAABGdBTUEAAYagMeiWXwAAAEhJREFUeJzt1cEJADAMAkCF7JH9t3ITO0Qr9KH4zuErtA0EO4AKFPgcoO3kfUx4QIECD0qHH8KEBxQo8KB0OCOpQIG7cHejwAGCsfleD0DPSwAAAABJRU5ErkJggg==\",\n      \"xd9n2c08.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQAAAABbAUdZAAAABGdBTUEAAYagMeiWXwAAAABJRU5ErkJggg==\",\n      \"xdtn0g01.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAAAAABDU1VNAAAABGdBTUEAAYagMeiWXwAAAEFJREFUeJxjZGAkABQIyLMMBQWMDwgp+PcfP2B5MBwUMMoRkGdkonlcDAYFjI/wyv7/z/iH5nExGBQwyuCVZWQEAFDl/nE14thZAAAAAElFTkSuQmCC\",\n      \"xhdn0g08.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBORwoKGgoAAAAKSUhEUgAAACAAAAAgBAAAAACT4cgpAAAABGdBTUEAAYagMeiWXwAAAEhJREFUeJxjYGAQFFRSMjZ2cQkKTUsrL2cgQwCV29FBjgAqd+ZMcgRQuatWkSOAyt29mxwBVO6ZM+QIoHLv3iVHAJX77h0ZAgAfFO4B6v9B+gAAAABJRU5ErkJggg==\",\n      \"xlfn0g04.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"CVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQAAAABbAUdZAAAABGdBTUEAAYagMeiWXwAAAFtJREFUeJwtzLEJAzAMBdHr0gSySiALejRvkBU8gsGNCmFFB1Hx4IovqurSpIRszqklUwbnUzRXEuIRsiG/SyY9G0JzJSVei9qynm9qyjBpLp0pYW7pbzBl8L8fEIdJL9AvFMkAAAAASUVORK5CYII=\",\n      \"xs1n0g01.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVFORw0KGgoAAAANSUhEUgAAACAAAAAgAQAAAABbAUdZAAAABGdBTUEAAYagMeiWXwAAAFtJREFUeJwtzLEJAzAMBdHr0gSySiALejRvkBU8gsGNCmFFB1Hx4IovqurSpIRszqklUwbnUzRXEuIRsiG/SyY9G0JzJSVei9qynm9qyjBpLp0pYW7pbzBl8L8fEIdJL9AvFMkAAAAASUVORK5CYII=\",\n      \"xs2n0g01.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBOZw0KGgoAAAANSUhEUgAAACAAAAAgAQAAAABbAUdZAAAABGdBTUEAAYagMeiWXwAAAFtJREFUeJwtzLEJAzAMBdHr0gSySiALejRvkBU8gsGNCmFFB1Hx4IovqurSpIRszqklUwbnUzRXEuIRsiG/SyY9G0JzJSVei9qynm9qyjBpLp0pYW7pbzBl8L8fEIdJL9AvFMkAAAAASUVORK5CYII=\",\n      \"xs4n0g01.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBORw0KIAoAAAANSUhEUgAAACAAAAAgAQAAAABbAUdZAAAABGdBTUEAAYagMeiWXwAAAFtJREFUeJwtzLEJAzAMBdHr0gSySiALejRvkBU8gsGNCmFFB1Hx4IovqurSpIRszqklUwbnUzRXEuIRsiG/SyY9G0JzJSVei9qynm9qyjBpLp0pYW7pbzBl8L8fEIdJL9AvFMkAAAAASUVORK5CYII=\",\n      \"xs7n0g01.png\", true, 32, 32, \"d41d8cd98f00b204e9800998ecf8427e\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAMK0lEQVR42gEgDN/zAf//APgAAPgAAPcAAPgAAPgAAPgAAPcAAPgAAPgAAPgAAPgAAPcAAPgAAPgAAPgAAPcAAPgAAPgAAPgAAPcAAPgAAPgAAPgAAPgAAPcAAPgAAPgAAPgAAPcAAPgAAPgAAAQA+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgEAPgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIBAD3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAACQQA+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAkAAAgEAPgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIAAAJAAAIAAAIBAD4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAACQAACAAACAAACAQA9wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAkAAAgAAAgAAAgAAAkEAPgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIBAD4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAACQAACAAACAAACAAACQAACAAACAQA+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgEAPgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAIBAD3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACAAACQQA+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAgAAAkAAAgEAPgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAIAAAJAAAIAAAIBAD4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACAAACQAACAAACAAACAQA9wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAkEAPgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIBAD4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACAAACQAACAAACAAACAAACQAACAAACAQA+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgEAPcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAJBAD4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACQAACAQA+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgEAPgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIBAD4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACAQA9wAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAgAAAkEAPgAAAAAAAAAAAAAAAAAAAAAAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAIAAAJAAAIBAD4AAAAAAAAAAAAAAAAAAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACAAACQAACAAACAQA+AAAAAAAAAAAAAAAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAgAAAkAAAgAAAgAAAgEAPcAAAAAAAAAAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAIAAAJAAAIAAAIAAAIAAAJBAD4AAAAAAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACQAACAAACAAACAAACAAACQAACAAACAAACAAACQAACAQA+AAAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAgAAAkAAAgAAAgAAAgAAAkAAAgAAAhVk05uHxPwlQAAAABJRU5ErkJggg==\",\n      \"z00n2c08.png\", false, 32, 32, \"6284c288d49534c897da4e50a9d05002\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAr0lEQVR4XrXR3Q5AMAwF4Epc8P4Py91sIgxb15/TRUSC76Q9U0q0U7m28/5/Zl7Vv/Q+mwsZeJbQgIUoB+Q5Q07RidagCS79nADfwaNHBLx0eAdfHdtBQweuqK2jAro6JIDT/SUPdGfJY92zIpFuDpDqtg4UuqEDna5dkVpXBVh0eQdGXdiBXZesyKUPA7w6HwDQmZIxeq9kmN5cEVL/B4D1Twd4ve4gRL9XFKXngANVk05u39tDGQAAAABJRU5ErkJggg==\",\n      \"z03n2c08.png\", false, 32, 32, \"6284c288d49534c897da4e50a9d05002\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAp0lEQVR4nLXRSw6AIBAD0JqwwPsfFna4MX4QYT4dVySS19BuraECFSg4D9158ktyLaEi8suhARnICSVQB/agF5x6UEW3HhHw0ukb9Dp3g4FOrGisswJ+dUrATPePvNCdI691T0Ui3Rwg1W0bKHTDBjpdW5FaVwVYdPkGRl24gV2XVOTSlwFefR5A0Ccjc/S/kWn6sCKm/g0g690GfP25QYh+VRSlA/kAVZNObjFSwSwAAAAASUVORK5CYII=\",\n      \"z06n2c08.png\", false, 32, 32, \"6284c288d49534c897da4e50a9d05002\");\n  testPngSuiteImage(\"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAp0lEQVR42rXRSw6AIBAD0JqwwPsfFna4MX4QYT4dVySS19BuraECFSg4D9158ktyLaEi8suhARnICSVQB/agF5x6UEW3HhHw0ukb9Dp3g4FOrGisswJ+dUrATPePvNCdI691T0Ui3Rwg1W0bKHTDBjpdW5FaVwVYdPkGRl24gV2XVOTSlwFefR5A0Ccjc/S/kWn6sCKm/g0g690GfP25QYh+VRSlA/kAVZNObtYRvvUAAAAASUVORK5CYII=\",\n      \"z09n2c08.png\", false, 32, 32, \"6284c288d49534c897da4e50a9d05002\");\n}\n\n\nvoid testErrorImages() {\n  std::cout << \"testErrorImages\" << std::endl;\n  // Image with color type palette but missing PLTE chunk\n  testBase64Image(\"iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAgMAAAAhHED1AAAAU0lEQVR4Ae3MwQAAAAxFoXnM3/NDvGsBdB8JBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEEQDHGPAW1eyhK0AAAAASUVORK5CYII=\", true, 256, 256, \"\");\n}\n\nvoid doMain() {\n  //PNG\n  testPngSuite();\n  testErrorImages();\n  testPNGCodec();\n  testPaletteFilterTypesZero();\n  testComplexPNG();\n  testInspectChunk();\n  testPredefinedFilters();\n  testFuzzing();\n  testEncoderErrors();\n  testPaletteToPaletteDecode();\n  testPaletteToPaletteDecode2();\n  testColorProfile();\n  testExif();\n  testBkgdChunk();\n  testBkgdChunk2();\n  testSbitChunk();\n\n  //Colors\n#ifndef DISABLE_SLOW\n  testFewColors();\n#endif // DISABLE_SLOW\n  testColorKeyConvert();\n  testColorConvert();\n  testColorConvert2();\n  testPaletteToPaletteConvert();\n  testRGBToPaletteConvert();\n  test16bitColorEndianness();\n  testAutoColorModels();\n  testNoAutoConvert();\n  testChrmToSrgb();\n  testXYZ();\n  testICC();\n  testICCGray();\n\n  //Zlib\n  testCompressZlib();\n  testHuffmanCodeLengths();\n  testCustomZlibCompress();\n  testCustomZlibCompress2();\n  testCustomDeflate();\n  testCustomZlibDecompress();\n  testCustomInflate();\n  // TODO: add test for huffman code with exactly 0 and 1 symbols present\n\n  //lodepng_util\n  testChunkUtil();\n  testGetFilterTypes();\n\n  std::cout << \"\\ntest successful\" << std::endl;\n}\n\nint main() {\n  try {\n    doMain();\n  }\n  catch(...) {\n    std::cout << std::endl;\n    std::cout << \"caught error!\" << std::endl;\n    std::cout << \"*** TEST FAILED ***\" << std::endl;\n  }\n\n  return 0;\n}\n"
        },
        {
          "name": "lodepng_util.cpp",
          "type": "blob",
          "size": 55.30859375,
          "content": "/*\nLodePNG Utils\n\nCopyright (c) 2005-2024 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n#include \"lodepng_util.h\"\n#include <stdlib.h> /* allocations */\n\nnamespace lodepng {\n\nLodePNGInfo getPNGHeaderInfo(const std::vector<unsigned char>& png) {\n  unsigned w, h;\n  lodepng::State state;\n  lodepng_inspect(&w, &h, &state, png.empty() ? NULL : &png[0], png.size());\n  return state.info_png;\n}\n\nunsigned getChunkInfo(std::vector<std::string>& names, std::vector<size_t>& sizes,\n                      const std::vector<unsigned char>& png) {\n  // Listing chunks is based on the original file, not the decoded png info.\n  const unsigned char *chunk, *end;\n  end = &png.back() + 1;\n  chunk = &png.front() + 8;\n\n  while(chunk < end && end - chunk >= 8) {\n    char type[5];\n    lodepng_chunk_type(type, chunk);\n    if(std::string(type).size() != 4) return 1;\n\n    unsigned length = lodepng_chunk_length(chunk);\n    names.push_back(type);\n    sizes.push_back(length);\n    chunk = lodepng_chunk_next_const(chunk, end);\n  }\n  return 0;\n}\n\nunsigned getChunks(std::vector<std::string> names[3],\n                   std::vector<std::vector<unsigned char> > chunks[3],\n                   const std::vector<unsigned char>& png) {\n  const unsigned char *chunk, *next, *end;\n  end = &png.back() + 1;\n  chunk = &png.front() + 8;\n\n  int location = 0;\n\n  while(chunk < end && end - chunk >= 8) {\n    char type[5];\n    lodepng_chunk_type(type, chunk);\n    std::string name(type);\n    if(name.size() != 4) return 1;\n\n    next = lodepng_chunk_next_const(chunk, end);\n\n    if(name == \"IHDR\") {\n      location = 0;\n    } else if(name == \"PLTE\") {\n      location = 1;\n    } else if(name == \"IDAT\") {\n      location = 2;\n    } else if(name == \"IEND\") {\n      break; // anything after IEND is not part of the PNG or the 3 groups here.\n    } else {\n      if(next >= end) return 1; // invalid chunk, content too far\n      names[location].push_back(name);\n      chunks[location].push_back(std::vector<unsigned char>(chunk, next));\n    }\n\n    chunk = next;\n  }\n  return 0;\n}\n\n\nunsigned insertChunks(std::vector<unsigned char>& png,\n                      const std::vector<std::vector<unsigned char> > chunks[3]) {\n  const unsigned char *chunk, *begin, *end;\n  end = &png.back() + 1;\n  begin = chunk = &png.front() + 8;\n\n  long l0 = 0; //location 0: IHDR-l0-PLTE (or IHDR-l0-l1-IDAT)\n  long l1 = 0; //location 1: PLTE-l1-IDAT (or IHDR-l0-l1-IDAT)\n  long l2 = 0; //location 2: IDAT-l2-IEND\n\n  while(chunk < end && end - chunk >= 8) {\n    char type[5];\n    lodepng_chunk_type(type, chunk);\n    std::string name(type);\n    if(name.size() != 4) return 1;\n\n    if(name == \"PLTE\") {\n      if(l0 == 0) l0 = chunk - begin + 8;\n    } else if(name == \"IDAT\") {\n      if(l0 == 0) l0 = chunk - begin + 8;\n      if(l1 == 0) l1 = chunk - begin + 8;\n    } else if(name == \"IEND\") {\n      if(l2 == 0) l2 = chunk - begin + 8;\n    }\n\n    chunk = lodepng_chunk_next_const(chunk, end);\n  }\n\n  std::vector<unsigned char> result;\n  result.insert(result.end(), png.begin(), png.begin() + l0);\n  for(size_t i = 0; i < chunks[0].size(); i++) result.insert(result.end(), chunks[0][i].begin(), chunks[0][i].end());\n  result.insert(result.end(), png.begin() + l0, png.begin() + l1);\n  for(size_t i = 0; i < chunks[1].size(); i++) result.insert(result.end(), chunks[1][i].begin(), chunks[1][i].end());\n  result.insert(result.end(), png.begin() + l1, png.begin() + l2);\n  for(size_t i = 0; i < chunks[2].size(); i++) result.insert(result.end(), chunks[2][i].begin(), chunks[2][i].end());\n  result.insert(result.end(), png.begin() + l2, png.end());\n\n  png = result;\n  return 0;\n}\n\nunsigned getFilterTypesInterlaced(std::vector<std::vector<unsigned char> >& filterTypes,\n                                  const std::vector<unsigned char>& png) {\n  //Get color type and interlace type\n  lodepng::State state;\n  unsigned w, h;\n  unsigned error;\n  error = lodepng_inspect(&w, &h, &state, png.empty() ? NULL : &png[0], png.size());\n\n  if(error) return 1;\n\n  //Read literal data from all IDAT chunks\n  const unsigned char *chunk, *begin, *end;\n  end = &png.back() + 1;\n  begin = chunk = &png.front() + 8;\n\n  std::vector<unsigned char> zdata;\n\n  while(chunk < end && end - chunk >= 8) {\n    char type[5];\n    lodepng_chunk_type(type, chunk);\n    if(std::string(type).size() != 4) return 1; //Probably not a PNG file\n\n    if(std::string(type) == \"IDAT\") {\n      const unsigned char* cdata = lodepng_chunk_data_const(chunk);\n      unsigned clength = lodepng_chunk_length(chunk);\n      if(chunk + clength + 12 > end || clength > png.size() || chunk + clength + 12 < begin) {\n        return 1; // corrupt chunk length\n      }\n      zdata.insert(zdata.end(), cdata, cdata + clength);\n    }\n\n    chunk = lodepng_chunk_next_const(chunk, end);\n  }\n\n  //Decompress all IDAT data\n  std::vector<unsigned char> data;\n  error = lodepng::decompress(data, zdata.empty() ? NULL : &zdata[0], zdata.size());\n\n  if(error) return 1;\n\n  if(state.info_png.interlace_method == 0) {\n    filterTypes.resize(1);\n\n    //A line is 1 filter byte + all pixels\n    size_t linebytes = 1 + lodepng_get_raw_size(w, 1, &state.info_png.color);\n\n    for(size_t i = 0; i < data.size(); i += linebytes) {\n      filterTypes[0].push_back(data[i]);\n    }\n  } else {\n    //Interlaced\n    filterTypes.resize(7);\n    static const unsigned ADAM7_IX[7] = { 0, 4, 0, 2, 0, 1, 0 }; /*x start values*/\n    static const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/\n    static const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/\n    static const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/\n    size_t pos = 0;\n    for(size_t j = 0; j < 7; j++) {\n      unsigned w2 = (w - ADAM7_IX[j] + ADAM7_DX[j] - 1) / ADAM7_DX[j];\n      unsigned h2 = (h - ADAM7_IY[j] + ADAM7_DY[j] - 1) / ADAM7_DY[j];\n      if(ADAM7_IX[j] >= w || ADAM7_IY[j] >= h) continue;\n      size_t linebytes = 1 + lodepng_get_raw_size(w2, 1, &state.info_png.color);\n      for(size_t i = 0; i < h2; i++) {\n        filterTypes[j].push_back(data[pos]);\n        pos += linebytes;\n      }\n    }\n  }\n  return 0; /* OK */\n}\n\n\nunsigned getFilterTypes(std::vector<unsigned char>& filterTypes, const std::vector<unsigned char>& png) {\n  std::vector<std::vector<unsigned char> > passes;\n  unsigned error = getFilterTypesInterlaced(passes, png);\n  if(error) return error;\n\n  if(passes.size() == 1) {\n    filterTypes.swap(passes[0]);\n  } else {\n    // Simplify interlaced filter types to get a single filter value per scanline:\n    // put pass 6 and 7 alternating in the one vector, these filters\n    // correspond to the closest to what it would be for non-interlaced\n    // image. If the image is only 1 pixel wide, pass 6 doesn't exist so the\n    // alternative values column0 are used. The shift values are to match\n    // the y position in the interlaced sub-images.\n    // NOTE: the values 0-6 match Adam7's passes 1-7.\n    const unsigned column0[8] = {0, 6, 4, 6, 2, 6, 4, 6};\n    const unsigned column1[8] = {5, 6, 5, 6, 5, 6, 5, 6};\n    const unsigned shift0[8] = {3, 1, 2, 1, 3, 1, 2, 1};\n    const unsigned shift1[8] = {1, 1, 1, 1, 1, 1, 1, 1};\n    lodepng::State state;\n    unsigned w, h;\n    lodepng_inspect(&w, &h, &state, png.empty() ? NULL : &png[0], png.size());\n    const unsigned* column = w > 1 ? column1 : column0;\n    const unsigned* shift = w > 1 ? shift1 : shift0;\n    for(size_t i = 0; i < h; i++) {\n      filterTypes.push_back(passes[column[i & 7u]][i >> shift[i & 7u]]);\n    }\n  }\n  return 0; /* OK */\n}\n\nint getPaletteValue(const unsigned char* data, size_t i, int bits) {\n  if(bits == 8) return data[i];\n  else if(bits == 4) return (data[i / 2] >> ((i % 2) * 4)) & 15;\n  else if(bits == 2) return (data[i / 4] >> ((i % 4) * 2)) & 3;\n  else if(bits == 1) return (data[i / 8] >> (i % 8)) & 1;\n  else return 0;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n\n\n// Only temporarily here until this is integrated into lodepng.c(pp)\n#define LODEPNG_MAX(a, b) (((a) > (b)) ? (a) : (b))\n#define LODEPNG_MIN(a, b) (((a) < (b)) ? (a) : (b))\n/* Safely check if multiplying two integers will overflow (no undefined\nbehavior, compiler removing the code, etc...) and output result. */\nstatic int lodepng_mulofl(size_t a, size_t b, size_t* result) {\n  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */\n  return (a != 0 && *result / a != b);\n}\n\n// Only temporarily here until this is integrated into lodepng.c(pp)\n#ifdef LODEPNG_COMPILE_ALLOCATORS\nstatic void* lodepng_malloc(size_t size) {\n  return malloc(size);\n}\nstatic void lodepng_free(void* ptr) {\n  free(ptr);\n}\n#else /*LODEPNG_COMPILE_ALLOCATORS*/\nvoid* lodepng_malloc(size_t size);\nvoid lodepng_free(void* ptr);\n#endif /*LODEPNG_COMPILE_ALLOCATORS*/\n\n/* define infinity and NaN in a way compatible with ANSI C90 (no INFINITY or NAN macros) yet also with visual studio */\n/* visual studio doesn't allow division through a zero literal, but allows it through public non-const variable set to zero */\nfloat lodepng_flt_zero_ = 0.0f;\nstatic const float lodepng_flt_inf = 1.0f / lodepng_flt_zero_; /* infinity */\nstatic const float lodepng_flt_nan = 0.0f / lodepng_flt_zero_; /* not a number */\nstatic const float lodepng_flt_max = 3.40282346638528859811704183484516925e38f; /* avoid needing <float.h> for FLT_MAX. This assumes IEEE 32-bit float. */\n\n/* powf polyfill, 5-6 digits accurate, 33-80% slower than powf, assumes IEEE\n32-bit float, but other than that multiplatform and no math lib needed\n(note: powf also isn't in ISO C90, and pow is slower). */\nstatic float lodepng_powf(float x, float y) {\n  float j, t0, t1, l;\n  int i = 0;\n  /* handle all the special floating point rules */\n  if(x == 1 || y == 0) return 1; /*these cases return 1 even if the other value is NaN, as specified*/\n  if(y == 1) return x; /* preserves negative-0 */\n  if(!(x > 0 && x <= lodepng_flt_max && y >= -lodepng_flt_max && y <= lodepng_flt_max)) { /*all special cases*/\n    if(x != x || y != y) return x + y; /* nan */\n    if(x > 0) {\n      if(x > lodepng_flt_max) return y <= 0 ? (y == 0 ? 1 : 0) : x; /* x = +infinity */\n    } else {\n      if(!(y < -1073741824.0f || y > 1073741824.0f)) { /* large y always even integer, but cast would overflow */\n        i = (int)y; /* not using floor: not using math lib */\n        if(i != y) {\n          return (x < -lodepng_flt_max) ? (y < 0 ? 0 : lodepng_flt_inf) :\n              (x == 0 ? (y < 0 ? lodepng_flt_inf : 0) : lodepng_flt_nan);\n        }\n        if(i & 1) return x == 0 ? (y < 0 ? (1 / x) : x) : -lodepng_powf(-x, y);\n      }\n      if(x == 0) return y <= 0 ? lodepng_flt_inf : 0;\n      if(x < -lodepng_flt_max) { /* x == -infinity */\n        return y <= 0 ? (y == 0 ? 1 : 0) : ((i & 1) ?\n            -lodepng_flt_inf : lodepng_flt_inf);\n      }\n      x = -x;\n      if(x == 1) return 1; /* under the C++ rules, pow(-1, +/- infinity) also returns 1 */\n    }\n    if(y < -lodepng_flt_max || y > lodepng_flt_max) return ((x < 1) != (y > 0)) ? (y < 0 ? -y : y) : 0;\n  }\n\n  l = x;\n  j = 0;\n  while(l < (1.0f / 65536)) { j -= 16; l *= 65536.0f; }\n  while(l > 65536) { j += 16; l *= (1.0f / 65536); }\n  while(l < 1) { j--; l *= 2.0f; }\n  while(l > 2) { j++; l *= 0.5f; }\n  /* polynomial to approximate log2(x) with x in range 1..2 */\n  t0 = -0.393118410458557f + l * (-0.0883639468229365f + l * (0.466142650227994f + l * 0.0153397331014276f));\n  t1 = 0.0907447971403586f + l * (0.388892024755479f + l * 0.137228280305862f);\n  l = t0 / t1 + j;\n\n  l *= y; /* using the formula exp2(y * log2(x)) */\n\n  /* prevent int shift overflow, 0 or inf result are ok to return since exp will be taken, 127 is max float exponent */\n  if(l <= -128.0f || l >= 128.0f) return ((x > 1) == (y > 0)) ? lodepng_flt_inf : 0;\n  i = (int)l;\n  l -= i;\n  /* polynomial to approximate exp2(x) with x in range -1..1 */\n  t0 = 1.0f + l * (0.41777833582744256f + l * (0.0728482595347711f + l * 0.005635023478609625f));\n  t1 = 1.0f + l * (-0.27537016151408167f + l * 0.023501446055084033f);\n  while(i <= -31) { t0 *= (1.0f / 2147483648.0f); i += 31; }\n  while(i >= 31) { t0 *= 2147483648.0f; i -= 31; }\n  return (i < 0) ? (t0 / (t1 * (1 << -i))) : ((t0 * (1 << i)) / t1);\n}\n\n/* Parameters of a tone reproduction curve, either with a power law formula or with a lookup table. */\ntypedef struct {\n  unsigned type; /* 0=linear, 1=lut, 2 = simple gamma, 3-6 = parametric (matches ICC parametric types 1-4) */\n  float* lut; /* for type 1 */\n  size_t lut_size;\n  float gamma; /* for type 2 and more */\n  float a, b, c, d, e, f; /* parameters for type 3-6 */\n} LodePNGICCCurve;\n\nvoid lodepng_icc_curve_init(LodePNGICCCurve* curve) {\n  curve->lut = 0;\n  curve->lut_size = 0;\n}\n\nvoid lodepng_icc_curve_cleanup(LodePNGICCCurve* curve) {\n  lodepng_free(curve->lut);\n}\n\n/* Values parsed from ICC profile, see parseICC for more information about this subset.*/\ntypedef struct {\n  /* 0 = color model not supported by PNG (CMYK, Lab, ...), 1 = gray, 2 = RGB */\n  int inputspace;\n  int version_major;\n  int version_minor;\n  int version_bugfix;\n\n  /* The whitepoint of the profile connection space (PCS). Should always be D50, but parsed and used anyway.\n  (to be clear, whitepoint and illuminant are synonyms in practice, but here field \"illuminant\" is ICC's\n  \"global\" whitepoint that is always D50, and the field \"white\" below allows deriving the whitepoint of\n  the particular RGB space represented here) */\n  float illuminant[3];\n\n  /* if true, has chromatic adaptation matrix that must be used. If false, you must compute a chromatic adaptation\n  matrix yourself from \"illuminant\" and \"white\". */\n  unsigned has_chad;\n  float chad[9]; /* chromatic adaptation matrix, if given */\n\n  /* The whitepoint of the RGB color space as stored in the ICC file. If has_chad, must be adapted with the\n  chad matrix to become the one we need to go to absolute XYZ (in fact ICC implies it should then be\n  exactly D50 in the file, redundantly, before this transformation with chad), else use as-is (then its\n  values can actually be something else than D50, and are the ones we need). */\n  unsigned has_whitepoint;\n  float white[3];\n  /* Chromaticities of the RGB space in XYZ color space, but given such that you must still\n  whitepoint adapt them from D50 to the RGB space whitepoint to go to absolute XYZ (if has_chad,\n  with chad, else with bradford adaptation matrix from illuminant to white). */\n  unsigned has_chromaticity;\n  float red[3];\n  float green[3];\n  float blue[3];\n\n  unsigned has_trc; /* TRC = tone reproduction curve (aka \"gamma correction\") */\n\n  /* TRC's for the three channels (only first one used if grayscale) */\n  LodePNGICCCurve trc[3];\n} LodePNGICC;\n\nvoid lodepng_icc_init(LodePNGICC* icc) {\n  lodepng_icc_curve_init(&icc->trc[0]);\n  lodepng_icc_curve_init(&icc->trc[1]);\n  lodepng_icc_curve_init(&icc->trc[2]);\n}\n\nvoid lodepng_icc_cleanup(LodePNGICC* icc) {\n  lodepng_icc_curve_cleanup(&icc->trc[0]);\n  lodepng_icc_curve_cleanup(&icc->trc[1]);\n  lodepng_icc_curve_cleanup(&icc->trc[2]);\n}\n\n/* ICC tone response curve, nonlinear (encoded) to linear.\nInput and output in range 0-1. If color was integer 0-255, multiply with (1.0f/255)\nto get the correct floating point behavior.\nOutside of range 0-1, will not clip but either return x itself, or in cases\nwhere it makes sense, a value defined by the same function.\nNOTE: ICC requires clipping, but we do that only later when converting float to integer.*/\nstatic float iccForwardTRC(const LodePNGICCCurve* curve, float x) {\n  if(curve->type == 0) {\n    return x;\n  }\n  if(curve->type == 1) { /* Lookup table */\n    float v0, v1, fraction;\n    size_t index;\n    if(!curve->lut) return 0; /* error */\n    if(x < 0) return x;\n    index = (size_t)(x * (curve->lut_size - 1));\n    if(index >= curve->lut_size) return x;\n\n    /* LERP */\n    v0 = curve->lut[index];\n    v1 = (index + 1 < curve->lut_size) ? curve->lut[index + 1] : 1.0f;\n    fraction = (x * (curve->lut_size - 1)) - index;\n    return v0 * (1 - fraction) + v1 * fraction;\n  }\n  if(curve->type == 2) {\n    /* Gamma expansion */\n    return (x > 0) ? lodepng_powf(x, curve->gamma) : x;\n  }\n  /* TODO: all the ones below are untested */\n  if(curve->type == 3) {\n    if(x < 0) return x;\n    return x >= (-curve->b / curve->a) ? (lodepng_powf(curve->a * x + curve->b, curve->gamma) + curve->c) : 0;\n  }\n  if(curve->type == 4) {\n    if(x < 0) return x;\n    return x >= (-curve->b / curve->a) ? (lodepng_powf(curve->a * x + curve->b, curve->gamma) + curve->c) : curve->c;\n  }\n  if(curve->type == 5) {\n    return x >= curve->d ? (lodepng_powf(curve->a * x + curve->b, curve->gamma)) : (curve->c * x);\n  }\n  if(curve->type == 6) {\n    return x >= curve->d ? (lodepng_powf(curve->a * x + curve->b, curve->gamma) + curve->c) : (curve->c * x + curve->f);\n  }\n  return 0;\n}\n\n/* ICC tone response curve, linear to nonlinear (encoded).\nInput and output in range 0-1. Outside of that range, will not clip but either\nreturn x itself, or in cases where it makes sense, a value defined by the same function.\nNOTE: ICC requires clipping, but we do that only later when converting float to integer.*/\nstatic float iccBackwardTRC(const LodePNGICCCurve* curve, float x) {\n  if(curve->type == 0) {\n    return x;\n  }\n  if(curve->type == 1) {\n    size_t a, b, m;\n    float v;\n    if(x <= 0) return x;\n    if(x >= 1) return x;\n    /* binary search in the table */\n    /* TODO: use faster way of inverting the lookup table */\n    a = 0;\n    b = curve->lut_size;\n    for(;;) {\n      if(a == b) return curve->lut[a];\n      if(a + 1 == b) {\n        /* LERP */\n        float v0 = curve->lut[a];\n        float v1 = curve->lut[b];\n        float fraction;\n        if(v0 == v1) return v0;\n        fraction = (x - v0) / (v1 - v0);\n        return v0 * (1 - fraction) + v1 * fraction;\n      }\n      m = (a + b) / 2u;\n      v = curve->lut[m];\n      if(v > x) {\n        b = m;\n      } else {\n        a = m;\n      }\n    }\n  }\n  if(curve->type == 2) {\n    /* Gamma compression */\n    return (x > 0) ? lodepng_powf(x, 1.0f / curve->gamma) : x;\n  }\n  /* TODO: all the ones below are untested  */\n  if(curve->type == 3) {\n    if(x < 0) return x;\n    return x > 0 ? ((lodepng_powf(x, 1.0f / curve->gamma) - curve->b) / curve->a) : (-curve->b / curve->a);\n  }\n  if(curve->type == 4) {\n    if(x < 0) return x;\n    return x > curve->c ?\n        ((lodepng_powf(x - curve->c, 1.0f / curve->gamma) - curve->b) / curve->a) :\n        (-curve->b / curve->a);\n  }\n  if(curve->type == 5) {\n    return x > (curve->c * curve->d) ?\n        ((lodepng_powf(x, 1.0f / curve->gamma) - curve->b) / curve->a) :\n        (x / curve->c);\n  }\n  if(curve->type == 6) {\n    return x > (curve->c * curve->d + curve->f) ?\n        ((lodepng_powf(x - curve->c, 1.0f / curve->gamma) - curve->b) / curve->a) :\n        ((x - curve->f) / curve->c);\n  }\n  return 0;\n}\n\nstatic unsigned decodeICCUint16(const unsigned char* data, size_t size, size_t* pos) {\n  *pos += 2;\n  if (*pos > size) return 0;\n  return (unsigned)((data[*pos - 2] << 8) | (data[*pos - 1]));\n}\n\nstatic unsigned decodeICCUint32(const unsigned char* data, size_t size, size_t* pos) {\n  *pos += 4;\n  if (*pos > size) return 0;\n  return (unsigned)((data[*pos - 4] << 24) | (data[*pos - 3] << 16) | (data[*pos - 2] << 8) | (data[*pos - 1] << 0));\n}\n\nstatic int decodeICCInt32(const unsigned char* data, size_t size, size_t* pos) {\n  *pos += 4;\n  if (*pos > size) return 0;\n  /*TODO: this is incorrect if sizeof(int) != 4*/\n  return (data[*pos - 4] << 24) | (data[*pos - 3] << 16) | (data[*pos - 2] << 8) | (data[*pos - 1] << 0);\n}\n\nstatic float decodeICC15Fixed16(const unsigned char* data, size_t size, size_t* pos) {\n  return decodeICCInt32(data, size, pos) / 65536.0f;\n}\n\nstatic unsigned isICCword(const unsigned char* data, size_t size, size_t pos, const char* word) {\n  if(pos + 4 > size) return 0;\n  return data[pos + 0] == (unsigned char)word[0] &&\n         data[pos + 1] == (unsigned char)word[1] &&\n         data[pos + 2] == (unsigned char)word[2] &&\n         data[pos + 3] == (unsigned char)word[3];\n}\n\n/* Parses a subset of the ICC profile, supporting the necessary mix of ICC v2\nand ICC v4 required to correctly convert the RGB color space to XYZ.\nDoes not parse values not related to this specific PNG-related purpose, and\ndoes not support non-RGB profiles or lookup-table based chroma (but it\nsupports lookup tables for TRC aka \"gamma\"). */\nstatic unsigned parseICC(LodePNGICC* icc, const unsigned char* data, size_t size) {\n  size_t i, j;\n  size_t pos = 0;\n  unsigned version;\n  unsigned inputspace;\n  size_t numtags;\n\n  if(size < 132) return 1; /* Too small to be a valid icc profile. */\n\n  icc->has_chromaticity = 0;\n  icc->has_whitepoint = 0;\n  icc->has_trc = 0;\n  icc->has_chad = 0;\n\n  icc->trc[0].type = icc->trc[1].type = icc->trc[2].type = 0;\n  icc->white[0] = icc->white[1] = icc->white[2] = 0;\n  icc->red[0] = icc->red[1] = icc->red[2] = 0;\n  icc->green[0] = icc->green[1] = icc->green[2] = 0;\n  icc->blue[0] = icc->blue[1] = icc->blue[2] = 0;\n\n  pos = 8;\n  version = decodeICCUint32(data, size, &pos);\n  if(pos >= size) return 1;\n  icc->version_major = (int)((version >> 24) & 255);\n  icc->version_minor = (int)((version >> 20) & 15);\n  icc->version_bugfix = (int)((version >> 16) & 15);\n\n  pos = 16;\n  inputspace = decodeICCUint32(data, size, &pos);\n  if(pos >= size) return 1;\n  if(inputspace == 0x47524159) {\n    /* The string  \"GRAY\" as unsigned 32-bit int. */\n    icc->inputspace = 1;\n  } else if(inputspace == 0x52474220) {\n    /* The string  \"RGB \" as unsigned 32-bit int. */\n    icc->inputspace = 2;\n  } else {\n    /* unsupported by PNG (CMYK, YCbCr, Lab, HSV, ...) */\n    icc->inputspace = 0;\n  }\n\n  /* Should always be 0.9642, 1.0, 0.8249 */\n  pos = 68;\n  icc->illuminant[0] = decodeICC15Fixed16(data, size, &pos);\n  icc->illuminant[1] = decodeICC15Fixed16(data, size, &pos);\n  icc->illuminant[2] = decodeICC15Fixed16(data, size, &pos);\n\n  pos = 128;\n  numtags = decodeICCUint32(data, size, &pos);\n  if(pos >= size) return 1;\n  /* scan for tags we want to handle */\n  for(i = 0; i < numtags; i++) {\n    size_t offset;\n    unsigned tagsize;\n    size_t namepos = pos;\n    pos += 4;\n    offset = decodeICCUint32(data, size, &pos);\n    tagsize = decodeICCUint32(data, size, &pos);\n    if(pos >= size || offset >= size) return 1;\n    if(offset + tagsize > size) return 1;\n    if(tagsize < 8) return 1;\n\n    if(isICCword(data, size, namepos, \"wtpt\")) {\n      offset += 8; /* skip tag and reserved */\n      icc->white[0] = decodeICC15Fixed16(data, size, &offset);\n      icc->white[1] = decodeICC15Fixed16(data, size, &offset);\n      icc->white[2] = decodeICC15Fixed16(data, size, &offset);\n      icc->has_whitepoint = 1;\n    } else if(isICCword(data, size, namepos, \"rXYZ\")) {\n      offset += 8; /* skip tag and reserved */\n      icc->red[0] = decodeICC15Fixed16(data, size, &offset);\n      icc->red[1] = decodeICC15Fixed16(data, size, &offset);\n      icc->red[2] = decodeICC15Fixed16(data, size, &offset);\n      icc->has_chromaticity = 1;\n    } else if(isICCword(data, size, namepos, \"gXYZ\")) {\n      offset += 8; /* skip tag and reserved */\n      icc->green[0] = decodeICC15Fixed16(data, size, &offset);\n      icc->green[1] = decodeICC15Fixed16(data, size, &offset);\n      icc->green[2] = decodeICC15Fixed16(data, size, &offset);\n      icc->has_chromaticity = 1;\n    } else if(isICCword(data, size, namepos, \"bXYZ\")) {\n      offset += 8; /* skip tag and reserved */\n      icc->blue[0] = decodeICC15Fixed16(data, size, &offset);\n      icc->blue[1] = decodeICC15Fixed16(data, size, &offset);\n      icc->blue[2] = decodeICC15Fixed16(data, size, &offset);\n      icc->has_chromaticity = 1;\n    } else if(isICCword(data, size, namepos, \"chad\")) {\n      offset += 8; /* skip datatype keyword \"sf32\" and reserved */\n      for(j = 0; j < 9; j++) {\n        icc->chad[j] = decodeICC15Fixed16(data, size, &offset);\n      }\n      icc->has_chad = 1;\n    } else if(isICCword(data, size, namepos, \"rTRC\") ||\n              isICCword(data, size, namepos, \"gTRC\") ||\n              isICCword(data, size, namepos, \"bTRC\") ||\n              isICCword(data, size, namepos, \"kTRC\")) {\n      char c = (char)data[namepos];\n      /* both 'k' and 'r' are stored in channel 0 */\n      int channel = (c == 'b') ? 2 : (c == 'g' ? 1 : 0);\n      /* \"curv\": linear, gamma power or LUT */\n      if(isICCword(data, size, offset, \"curv\")) {\n        size_t count;\n        LodePNGICCCurve* trc = &icc->trc[channel];\n        icc->has_trc = 1;\n        offset += 8; /* skip tag \"curv\" and reserved */\n        count = decodeICCUint32(data, size, &offset);\n        if(count == 0) {\n          trc->type = 0; /* linear */\n        } else if(count == 1) {\n          trc->type = 2; /* gamma */\n          trc->gamma = decodeICCUint16(data, size, &offset) / 256.0f;\n        } else {\n          trc->type = 1; /* LUT */\n          if(offset + count * 2 > size || count > 16777216) return 1; /* also avoid crazy count */\n          trc->lut_size = count;\n          trc->lut = (float*)lodepng_malloc(count * sizeof(float));\n          for(j = 0; j < count; j++) {\n            trc->lut[j] = decodeICCUint16(data, size, &offset) * (1.0f / 65535.0f);\n          }\n        }\n      }\n      /* \"para\": parametric formula with gamma power, multipliers, biases and comparison point */\n      /* TODO: test this on a realistic sample */\n      if(isICCword(data, size, offset, \"para\")) {\n        unsigned type;\n        LodePNGICCCurve* trc = &icc->trc[channel];\n        icc->has_trc = 1;\n        offset += 8; /* skip tag \"para\" and reserved */\n        type = decodeICCUint16(data, size, &offset);\n        offset += 2;\n        if(type > 4) return 1; /* unknown parametric curve type */\n        trc->type = type + 2;\n        trc->gamma = decodeICC15Fixed16(data, size, &offset);\n        if(type >= 1) {\n          trc->a = decodeICC15Fixed16(data, size, &offset);\n          trc->b = decodeICC15Fixed16(data, size, &offset);\n        }\n        if(type >= 2) {\n          trc->c = decodeICC15Fixed16(data, size, &offset);\n        }\n        if(type >= 3) {\n          trc->d = decodeICC15Fixed16(data, size, &offset);\n        }\n        if(type == 4) {\n          trc->e = decodeICC15Fixed16(data, size, &offset);\n          trc->f = decodeICC15Fixed16(data, size, &offset);\n        }\n      }\n      /* TODO: verify: does the \"chrm\" tag participate in computation so should be parsed? */\n    }\n    /* Return error if any parse went beyond the filesize. Note that the\n    parsing itself was always safe since it bound-checks inside. */\n    if(offset > size) return 1;\n  }\n\n  return 0;\n}\n\n/* Multiplies 3 vector values with 3x3 matrix */\nstatic void mulMatrix(float* x2, float* y2, float* z2, const float* m, double x, double y, double z) {\n  /* double used as inputs even though in general the images are float, so the sums happen in\n  double precision, because float can give numerical problems for nearby values */\n  *x2 = (float)(x * m[0] + y * m[1] + z * m[2]);\n  *y2 = (float)(x * m[3] + y * m[4] + z * m[5]);\n  *z2 = (float)(x * m[6] + y * m[7] + z * m[8]);\n}\n\nstatic void mulMatrixMatrix(float* result, const float* a, const float* b) {\n  int i;\n  float temp[9]; /* temp is to allow result and a or b to be the same */\n  mulMatrix(&temp[0], &temp[3], &temp[6], a, b[0], b[3], b[6]);\n  mulMatrix(&temp[1], &temp[4], &temp[7], a, b[1], b[4], b[7]);\n  mulMatrix(&temp[2], &temp[5], &temp[8], a, b[2], b[5], b[8]);\n  for(i = 0; i < 9; i++) result[i] = temp[i];\n}\n\n/* Inverts 3x3 matrix in place */\nstatic unsigned invMatrix(float* m) {\n  int i;\n  /* double used instead of float for intermediate computations to avoid\n  intermediate numerical precision issues */\n  double e0 = (double)m[4] * m[8] - (double)m[5] * m[7];\n  double e3 = (double)m[5] * m[6] - (double)m[3] * m[8];\n  double e6 = (double)m[3] * m[7] - (double)m[4] * m[6];\n  /* inverse determinant */\n  double d = 1.0 / (m[0] * e0 + m[1] * e3 + m[2] * e6);\n  double result[9];\n  if((d > 0 ? d : -d) > 1e15) return 1; /* error, likely not invertible */\n  result[0] = e0 * d;\n  result[1] = ((double)m[2] * m[7] - (double)m[1] * m[8]) * d;\n  result[2] = ((double)m[1] * m[5] - (double)m[2] * m[4]) * d;\n  result[3] = e3 * d;\n  result[4] = ((double)m[0] * m[8] - (double)m[2] * m[6]) * d;\n  result[5] = ((double)m[3] * m[2] - (double)m[0] * m[5]) * d;\n  result[6] = e6 * d;\n  result[7] = ((double)m[6] * m[1] - (double)m[0] * m[7]) * d;\n  result[8] = ((double)m[0] * m[4] - (double)m[3] * m[1]) * d;\n  for(i = 0; i < 9; i++) m[i] = (float)result[i];\n  return 0; /* ok */\n}\n\n/* Get the matrix to go from linear RGB to XYZ given the RGB whitepoint and chromaticities in XYZ colorspace */\nstatic unsigned getChrmMatrixXYZ(float* m,\n                                 float wX, float wY, float wZ,\n                                 float rX, float rY, float rZ,\n                                 float gX, float gY, float gZ,\n                                 float bX, float bY, float bZ) {\n  float t[9];\n  float rs, gs, bs;\n  t[0] = rX; t[1] = gX; t[2] = bX;\n  t[3] = rY; t[4] = gY; t[5] = bY;\n  t[6] = rZ; t[7] = gZ; t[8] = bZ;\n  if(invMatrix(t)) return 1; /* error, not invertible */\n  mulMatrix(&rs, &gs, &bs, t, wX, wY, wZ);\n  m[0] = rs * rX; m[1] = gs * gX; m[2] = bs * bX;\n  m[3] = rs * rY; m[4] = gs * gY; m[5] = bs * bY;\n  m[6] = rs * rZ; m[7] = gs * gZ; m[8] = bs * bZ;\n  return 0;\n}\n\n/* Get the matrix to go from linear RGB to XYZ given the RGB whitepoint and chromaticities in xy colorspace */\nstatic unsigned getChrmMatrixXY(float* m,\n                                float wx, float wy,\n                                float rx, float ry,\n                                float gx, float gy,\n                                float bx, float by) {\n  if(wy == 0 || ry == 0 || gy == 0 || by == 0) {\n    return 1; /* error, division through zero */\n  } else {\n    float wX = wx / wy, wY = 1, wZ = (1 - wx - wy) / wy;\n    float rX = rx / ry, rY = 1, rZ = (1 - rx - ry) / ry;\n    float gX = gx / gy, gY = 1, gZ = (1 - gx - gy) / gy;\n    float bX = bx / by, bY = 1, bZ = (1 - bx - by) / by;\n    return getChrmMatrixXYZ(m, wX, wY, wZ, rX, rY, rZ, gX, gY, gZ, bX, bY, bZ);\n  }\n}\n\n/* Returns matrix that adapts from source whitepoint 0 to destination whitepoint 1.\nTypes: 0=XYZ scaling, 1=Bradford, 2=Vonkries */\nstatic unsigned getAdaptationMatrix(float* m, int type,\n                                    float wx0, float wy0, float wz0,\n                                    float wx1, float wy1, float wz1) {\n  int i;\n  static const float bradford[9] = {\n    0.8951f, 0.2664f, -0.1614f,\n    -0.7502f, 1.7135f, 0.0367f,\n    0.0389f, -0.0685f, 1.0296f\n  };\n  static const float bradfordinv[9] = {\n    0.9869929f, -0.1470543f, 0.1599627f,\n    0.4323053f, 0.5183603f, 0.0492912f,\n   -0.0085287f, 0.0400428f, 0.9684867f\n  };\n  static const float vonkries[9] = {\n    0.40024f, 0.70760f, -0.08081f,\n    -0.22630f, 1.16532f, 0.04570f,\n    0.00000f, 0.00000f, 0.91822f,\n  };\n  static const float vonkriesinv[9] = {\n    1.8599364f, -1.1293816f, 0.2198974f,\n    0.3611914f, 0.6388125f, -0.0000064f,\n   0.0000000f, 0.0000000f, 1.0890636f\n  };\n  if(type == 0) {\n    for(i = 0; i < 9; i++) m[i] = 0;\n    m[0] = wx1 / wx0;\n    m[4] = wy1 / wy0;\n    m[8] = wz1 / wz0;\n  } else {\n    const float* cat = (type == 1) ? bradford : vonkries;\n    const float* inv = (type == 1) ? bradfordinv : vonkriesinv;\n    float rho0, gam0, bet0, rho1, gam1, bet1, rho2, gam2, bet2;\n    mulMatrix(&rho0, &gam0, &bet0, cat, wx0, wy0, wz0);\n    mulMatrix(&rho1, &gam1, &bet1, cat, wx1, wy1, wz1);\n    rho2 = rho1 / rho0;\n    gam2 = gam1 / gam0;\n    bet2 = bet1 / bet0;\n    /* Multiply diagonal matrix with cat */\n    for(i = 0; i < 3; i++) {\n      m[i + 0] = rho2 * cat[i + 0];\n      m[i + 3] = gam2 * cat[i + 3];\n      m[i + 6] = bet2 * cat[i + 6];\n    }\n    mulMatrixMatrix(m, inv, m);\n  }\n  return 0; /* ok */\n}\n\n/* validate whether the ICC profile is supported here for PNG */\nstatic unsigned validateICC(const LodePNGICC* icc) {\n  /* disable for unsupported things in the icc profile */\n  if(icc->inputspace == 0) return 0;\n  /* if we didn't recognize both chrm and trc, then maybe the ICC uses data\n  types not supported here yet, so fall back to not using it. */\n  if(icc->inputspace == 2) {\n    /* RGB profile should have chromaticities */\n    if(!icc->has_chromaticity) return 0;\n  }\n  /* An ICC profile without whitepoint is invalid for the kind of profiles used here. */\n  if(!icc->has_whitepoint) return 0;\n  if(!icc->has_trc) return 0;\n  return 1; /* ok */\n}\n\n/* Returns chromaticity matrix for given ICC profile, adapted from ICC's\nglobal illuminant as necessary.\nAlso returns the profile's whitepoint.\nIn case of a gray profile (icc->inputspace == 1), the identity matrix will be returned\nso in that case you could skip the transform. */\nstatic unsigned getICCChrm(float m[9], float whitepoint[3], const LodePNGICC* icc) {\n  size_t i;\n  if(icc->inputspace == 2) { /* RGB profile */\n    float red[3], green[3], blue[3];\n    float white[3]; /* the whitepoint of the RGB color space (absolute) */\n    /* Adaptation matrix a.\n    This is an adaptation needed for ICC's file format (due to it using\n    an internal global illuminant unrelated to the actual images) */\n    float a[9] = {1,0,0, 0,1,0, 0,0,1};\n    /* If the profile has chromatic adaptation matrix \"chad\", use that one,\n    else compute it from the illuminant and whitepoint. */\n    if(icc->has_chad) {\n      for(i = 0; i < 9; i++) a[i] = icc->chad[i];\n      invMatrix(a);\n    } else {\n      if(getAdaptationMatrix(a, 1, icc->illuminant[0], icc->illuminant[1], icc->illuminant[2],\n                             icc->white[0], icc->white[1], icc->white[2])) {\n        return 1; /* error computing matrix */\n      }\n    }\n    /* If the profile has a chad, then also the RGB's whitepoint must also be adapted from it (and the one\n    given is normally D50). If it did not have a chad, then the whitepoint given is already the adapted one. */\n    if(icc->has_chad) {\n      mulMatrix(&white[0], &white[1], &white[2], a, icc->white[0], icc->white[1], icc->white[2]);\n    } else {\n      for(i = 0; i < 3; i++) white[i] = icc->white[i];\n    }\n\n    mulMatrix(&red[0], &red[1], &red[2], a, icc->red[0], icc->red[1], icc->red[2]);\n    mulMatrix(&green[0], &green[1], &green[2], a, icc->green[0], icc->green[1], icc->green[2]);\n    mulMatrix(&blue[0], &blue[1], &blue[2], a, icc->blue[0], icc->blue[1], icc->blue[2]);\n\n    if(getChrmMatrixXYZ(m, white[0], white[1], white[2], red[0], red[1], red[2],\n                        green[0], green[1], green[2], blue[0], blue[1], blue[2])) {\n      return 1; /* error computing matrix */\n    }\n    /* output absolute whitepoint of the original RGB model */\n    whitepoint[0] = white[0];\n    whitepoint[1] = white[1];\n    whitepoint[2] = white[2];\n  } else {\n    /* output the unity matrix, for doing no transform */\n    m[0] = m[4] = m[8] = 1;\n    m[1] = m[2] = m[3] = m[5] = m[6] = m[7] = 0;\n    /* grayscale, don't do anything. That means we are implicitely using equal energy whitepoint \"E\", indicate\n    this to the output. */\n    whitepoint[0] = whitepoint[1] = whitepoint[2] = 1;\n  }\n  return 0; /* success */\n}\n\n/* Outputs whitepoint and matrix to go from the icc or info profile (depending on what was in the PNG) to XYZ,\nwithout applying any (rendering intent related) whitepoint adaptation */\nstatic unsigned getChrm(float m[9], float whitepoint[3], unsigned use_icc,\n                        const LodePNGICC* icc, const LodePNGInfo* info) {\n  size_t i;\n  if(use_icc) {\n    if(getICCChrm(m, whitepoint, icc)) return 1;  /* error in the matrix computations */\n  } else if(info->chrm_defined && !info->srgb_defined) {\n    float wx = info->chrm_white_x / 100000.0f, wy = info->chrm_white_y / 100000.0f;\n    float rx = info->chrm_red_x / 100000.0f, ry = info->chrm_red_y / 100000.0f;\n    float gx = info->chrm_green_x / 100000.0f, gy = info->chrm_green_y / 100000.0f;\n    float bx = info->chrm_blue_x / 100000.0f, by = info->chrm_blue_y / 100000.0f;\n    if(getChrmMatrixXY(m, wx, wy, rx, ry, gx, gy, bx, by)) return 1; /* returns if error */\n    /* Output whitepoint, xyY to XYZ: */\n    whitepoint[0] = wx / wy;\n    whitepoint[1] = 1;\n    whitepoint[2] = (1 - wx - wy) / wy;\n  } else {\n    /* the standard linear sRGB to XYZ matrix */\n    static const float srgb[9] = {\n        0.4124564f, 0.3575761f, 0.1804375f,\n        0.2126729f, 0.7151522f, 0.0721750f,\n        0.0193339f, 0.1191920f, 0.9503041f\n    };\n    for(i = 0; i < 9; i++) m[i] = srgb[i];\n    /* sRGB's whitepoint xyY \"0.3127,0.3290,1\" in XYZ: */\n    whitepoint[0] = 0.9504559270516716f;\n    whitepoint[1] = 1;\n    whitepoint[2] = 1.0890577507598784f;\n  }\n  return 0;\n}\n\n/* Returns whether the color chunks in info represent the default PNG sRGB,\nwhich is when either no colorometry fields are present at all, or an srgb\nfield or chrm/gama field with default values are present.\nICC chunks representing sRGB are currently considered not the same. */\nstatic unsigned isSRGB(const LodePNGInfo* info) {\n  if(!info) return 1; /* the default is considered sRGB. */\n\n  /* TODO: support some ICC profiles that represent sRGB too. Tricky due to\n  possible slight deviations and many ways of representing its gamma function. */\n  if(info->iccp_defined) return 0;\n\n  if(info->srgb_defined) return 1;\n\n  /* The gamma chunk is unable to represent sRGB's two-part gamma, so cannot\n  be sRGB, even if it's the default 45455. */\n  if(info->gama_defined) return 0;\n\n  if(info->chrm_defined) {\n    if(info->chrm_white_x != 31270 || info->chrm_white_y != 32900) return 0;\n    if(info->chrm_red_x != 64000 || info->chrm_red_y != 33000) return 0;\n    if(info->chrm_green_x != 30000 || info->chrm_green_y != 60000) return 0;\n    if(info->chrm_blue_x != 15000 || info->chrm_blue_y != 6000) return 0;\n  }\n\n  return 1;\n}\n\n/* Checks whether the RGB models are equal (chromaticities, ...). The raw byte\nformat is allowed to be different. Input pointers are allowed to be null,\nthey then represent the default PNG sRGB (same as having no color model\nchunks at all or an srgb chunk in the PNG) */\nstatic unsigned modelsEqual(const LodePNGState* state_a,\n                            const LodePNGState* state_b) {\n  size_t i;\n  const LodePNGInfo* a = state_a ? &state_a->info_png : 0;\n  const LodePNGInfo* b = state_b ? &state_b->info_png : 0;\n  unsigned a_srgb = isSRGB(a);\n  unsigned b_srgb = isSRGB(b);\n  if(a_srgb != b_srgb) return 0;\n  if(a_srgb && b_srgb) return 1;\n  /* now a and b are both non-sRGB, and both guaranteed to be non-NULL: only\n  non-NULL can represent a different color model than sRGB. */\n  if(a->iccp_defined != b->iccp_defined) return 0;\n  if(a->iccp_defined) {\n    if(a->iccp_profile_size != b->iccp_profile_size) return 0;\n    /* TODO: return equal in more cases, such as when two ICC profiles that are\n    not byte-for-byte equal, but represent the same color model. */\n    for(i = 0; i < a->iccp_profile_size; i++) {\n      if(a->iccp_profile[i] != b->iccp_profile[i]) return 0;\n    }\n    /* since the ICC model overrides gamma and chrm, those can be ignored. */\n    /* TODO: this doesn't cover the case where the ICC profile is invalid */\n    return 1;\n  }\n\n  if(a->srgb_defined != b->srgb_defined) return 0;\n  if(a->srgb_defined) {\n    /* since the sRGB model overrides gamma and chrm, those can be ignored.\n    srgb_intent not checked since the conversion ignores it */\n    return 1;\n  }\n\n  if(a->gama_defined != b->gama_defined) return 0;\n  if(a->gama_defined) {\n    if(a->gama_gamma != b->gama_gamma) return 0;\n  }\n\n  if(a->chrm_defined != b->chrm_defined) return 0;\n  if(a->chrm_defined) {\n    if(a->chrm_white_x != b->chrm_white_x) return 0;\n    if(a->chrm_white_y != b->chrm_white_y) return 0;\n    if(a->chrm_red_x != b->chrm_red_x) return 0;\n    if(a->chrm_red_y != b->chrm_red_y) return 0;\n    if(a->chrm_green_x != b->chrm_green_x) return 0;\n    if(a->chrm_green_y != b->chrm_green_y) return 0;\n    if(a->chrm_blue_x != b->chrm_blue_x) return 0;\n    if(a->chrm_blue_y != b->chrm_blue_y) return 0;\n  }\n\n  return 1;\n}\n\n/* Converts in-place. Does not clamp. Do not use for integer input, make table instead there. */\nstatic unsigned convertToXYZ_gamma(float* out, const float* in, unsigned w, unsigned h,\n                                  const LodePNGInfo* info, unsigned use_icc, const LodePNGICC* icc) {\n  size_t i, c, n;\n  if(lodepng_mulofl((size_t)w, (size_t)h, &n)) return 92;\n  for(i = 0; i < n * 4; i++) {\n    out[i] = in[i];\n  }\n  if(use_icc) {\n    for(i = 0; i < n; i++) {\n      for(c = 0; c < 3; c++) {\n        /* TODO: this is likely very slow */\n        out[i * 4 + c] = iccForwardTRC(&icc->trc[c], in[i * 4 + c]);\n      }\n    }\n  } else if(info->gama_defined && !info->srgb_defined) {\n    /* nothing to do if gamma is 1 */\n    if(info->gama_gamma != 100000) {\n      float gamma = 100000.0f / info->gama_gamma;\n      for(i = 0; i < n; i++) {\n        for(c = 0; c < 3; c++) {\n          float v = in[i * 4 + c];\n          out[i * 4 + c] = (v <= 0) ? v : lodepng_powf(v, gamma);\n        }\n      }\n    }\n  } else {\n    for(i = 0; i < n; i++) {\n      for(c = 0; c < 3; c++) {\n        /* sRGB gamma expand */\n        float v = in[i * 4 + c];\n        out[i * 4 + c] = (v < 0.04045f) ? (v / 12.92f) : lodepng_powf((v + 0.055f) / 1.055f, 2.4f);\n      }\n    }\n  }\n  return 0; /* no error */\n}\n\n/* Same as convertToXYZ_gamma, but creates a lookup table rather than operating on an image */\nstatic void convertToXYZ_gamma_table(float* out, size_t n, size_t c,\n                                     const LodePNGInfo* info, unsigned use_icc, const LodePNGICC* icc) {\n  size_t i;\n  float mul = 1.0f / (n - 1);\n  if(use_icc) {\n    for(i = 0; i < n; i++) {\n      float v = i * mul;\n      out[i] = iccForwardTRC(&icc->trc[c], v);\n    }\n  } else if(info->gama_defined && !info->srgb_defined) {\n    /* no power needed if gamma is 1 */\n    if(info->gama_gamma == 100000) {\n      for(i = 0; i < n; i++) {\n        out[i] = i * mul;\n      }\n    } else {\n      float gamma = 100000.0f / info->gama_gamma;\n      for(i = 0; i < n; i++) {\n        float v = i * mul;\n        out[i] = lodepng_powf(v, gamma);\n      }\n    }\n  } else {\n    for(i = 0; i < n; i++) {\n      /* sRGB gamma expand */\n      float v = i * mul;\n      out[i] = (v < 0.04045f) ? (v / 12.92f) : lodepng_powf((v + 0.055f) / 1.055f, 2.4f);\n    }\n  }\n}\n\n/* In-place */\nstatic unsigned convertToXYZ_chrm(float* im, unsigned w, unsigned h,\n                                  const LodePNGInfo* info, unsigned use_icc, const LodePNGICC* icc,\n                                  float whitepoint[3]) {\n  unsigned error = 0;\n  size_t i, n;\n  float m[9]; /* XYZ to linear RGB matrix */\n  if(lodepng_mulofl((size_t)w, (size_t)h, &n)) return 92;\n\n  /* Must be called even for grayscale, to get the correct whitepoint to output */\n  error = getChrm(m, whitepoint, use_icc, icc, info);\n  if(error) return error;\n\n  /* Note: no whitepoint adaptation done to m here, because we only do the\n  adaptation in convertFromXYZ (we only whitepoint adapt when going to the\n  target RGB space, but here we're going from the source RGB space to XYZ) */\n\n  /* Apply the above computed linear-RGB-to-XYZ matrix to the pixels.\n  Skip the transform if it's the unit matrix (which is the case if grayscale profile) */\n  if(!use_icc || icc->inputspace == 2) {\n    for(i = 0; i < n; i++) {\n      size_t j = i * 4;\n      mulMatrix(&im[j + 0], &im[j + 1], &im[j + 2], m, im[j + 0], im[j + 1], im[j + 2]);\n    }\n  }\n\n  return 0;\n}\n\nunsigned convertToXYZ(float* out, float whitepoint[3], const unsigned char* in,\n                      unsigned w, unsigned h, const LodePNGState* state) {\n  unsigned error = 0;\n  size_t i, n, bytes;\n  const LodePNGColorMode* mode_in = &state->info_raw;\n  const LodePNGInfo* info = &state->info_png;\n  unsigned char* data = 0;\n  float* gammatable = 0;\n  int bit16 = mode_in->bitdepth > 8;\n  size_t num = bit16 ? 65536 : 256;\n  LodePNGColorMode tempmode = lodepng_color_mode_make(LCT_RGBA, bit16 ? 16 : 8);\n\n  unsigned use_icc = 0;\n  LodePNGICC icc;\n  lodepng_icc_init(&icc);\n  if(info->iccp_defined) {\n    error = parseICC(&icc, info->iccp_profile, info->iccp_profile_size);\n    if(error) goto cleanup; /* corrupted ICC profile */\n    use_icc = validateICC(&icc);\n  }\n\n  if(lodepng_mulofl((size_t)w, (size_t)h, &n)) error = 92;\n  if(error) goto cleanup;\n  if(lodepng_mulofl(n, bit16 ? 8 : 4, &bytes)) error = 92;\n  if(error) goto cleanup;\n\n  data = (unsigned char*)lodepng_malloc(bytes);\n  error = lodepng_convert(data, in, &tempmode, mode_in, w, h);\n  if(error) goto cleanup;\n\n  /* Handle transfer function */\n  {\n    float* gammatable_r;\n    float* gammatable_g;\n    float* gammatable_b;\n\n    /* RGB ICC, can have three different transfer functions */\n    if(use_icc && icc.inputspace == 2) {\n      gammatable = (float*)lodepng_malloc(num * 3 * sizeof(float));\n      gammatable_r = &gammatable[num * 0];\n      gammatable_g = &gammatable[num * 1];\n      gammatable_b = &gammatable[num * 2];\n      convertToXYZ_gamma_table(gammatable_r, num, 0, info, use_icc, &icc);\n      convertToXYZ_gamma_table(gammatable_g, num, 1, info, use_icc, &icc);\n      convertToXYZ_gamma_table(gammatable_b, num, 2, info, use_icc, &icc);\n    } else {\n      gammatable = (float*)lodepng_malloc(num * sizeof(float));\n      gammatable_r = gammatable_g = gammatable_b = gammatable;\n      convertToXYZ_gamma_table(gammatable, num, 0, info, use_icc, &icc);\n    }\n\n    if(bit16) {\n      for(i = 0; i < n; i++) {\n        out[i * 4 + 0] = gammatable_r[data[i * 8 + 0] * 256u + data[i * 8 + 1]];\n        out[i * 4 + 1] = gammatable_g[data[i * 8 + 2] * 256u + data[i * 8 + 3]];\n        out[i * 4 + 2] = gammatable_b[data[i * 8 + 4] * 256u + data[i * 8 + 5]];\n        out[i * 4 + 3] = (data[i * 8 + 6] * 256 + data[i * 8 + 7]) * (1 / 65535.0f);\n      }\n    } else {\n      for(i = 0; i < n; i++) {\n        out[i * 4 + 0] = gammatable_r[data[i * 4 + 0]];\n        out[i * 4 + 1] = gammatable_g[data[i * 4 + 1]];\n        out[i * 4 + 2] = gammatable_b[data[i * 4 + 2]];\n        out[i * 4 + 3] = data[i * 4 + 3] * (1 / 255.0f);\n      }\n    }\n  }\n\n  error = convertToXYZ_chrm(out, w, h, info, use_icc, &icc, whitepoint);\n  if(error) goto cleanup;\n\ncleanup:\n  lodepng_icc_cleanup(&icc);\n  lodepng_free(data);\n  lodepng_free(gammatable);\n  return error;\n}\n\nunsigned convertToXYZFloat(float* out, float whitepoint[3], const float* in,\n                           unsigned w, unsigned h, const LodePNGState* state) {\n  unsigned error = 0;\n  const LodePNGInfo* info = &state->info_png;\n\n  unsigned use_icc = 0;\n  LodePNGICC icc;\n  lodepng_icc_init(&icc);\n  if(info->iccp_defined) {\n    error = parseICC(&icc, info->iccp_profile, info->iccp_profile_size);\n    if(error) goto cleanup; /* corrupted ICC profile */\n    use_icc = validateICC(&icc);\n  }\n  /* Input is floating point, so lookup table cannot be used, but it's ensured to\n  use float pow, not the slower double pow. */\n  error = convertToXYZ_gamma(out, in, w, h, info, use_icc, &icc);\n  if(error) goto cleanup;\n  error = convertToXYZ_chrm(out, w, h, info, use_icc, &icc, whitepoint);\n  if(error) goto cleanup;\n\ncleanup:\n  lodepng_icc_cleanup(&icc);\n  return error;\n}\n\nstatic unsigned convertFromXYZ_chrm(float* out, const float* in, unsigned w, unsigned h,\n                                    const LodePNGInfo* info, unsigned use_icc, const LodePNGICC* icc,\n                                    const float whitepoint[3], unsigned rendering_intent) {\n  size_t i, n;\n\n  float m[9]; /* XYZ to linear RGB matrix */\n  float white[3]; /* The whitepoint (absolute) of the target RGB space */\n\n  if(lodepng_mulofl((size_t)w, (size_t)h, &n)) return 92;\n\n  if(getChrm(m, white, use_icc, icc, info)) return 1;\n  if(invMatrix(m)) return 1; /* error, not invertible */\n\n  /* for relative rendering intent (any except absolute \"3\"), must whitepoint adapt to the original whitepoint.\n  this also ensures grayscale stays grayscale (with absolute, grayscale could become e.g. blue or sepia) */\n  if(rendering_intent != 3) {\n    float a[9] = {1,0,0, 0,1,0, 0,0,1};\n    /* \"white\" = absolute whitepoint of the new target RGB space, read from the target color profile.\n    \"whitepoint\" is original absolute whitepoint (input as parameter of this function) of an\n    RGB space the XYZ data once had before it was converted to XYZ, in other words the whitepoint that\n    we want to adapt our current data to to make sure values that had equal R==G==B in the old space have\n    the same property now (white stays white and gray stays gray).\n    Note: \"absolute\" whitepoint above means, can be used as-is, not needing further adaptation itself like icc.white does.*/\n    if(getAdaptationMatrix(a, 1, whitepoint[0], whitepoint[1], whitepoint[2], white[0], white[1], white[2])) {\n      return 1;\n    }\n    /* multiply the from xyz matrix with the adaptation matrix: in total,\n    the resulting matrix first adapts in XYZ space, then converts to RGB*/\n    mulMatrixMatrix(m, m, a);\n  }\n\n  /* Apply the above computed XYZ-to-linear-RGB matrix to the pixels.\n  This transformation also includes the whitepoint adaptation. The transform\n  can be skipped only if it's the unit matrix (only if grayscale profile and no\n  whitepoint adaptation, such as with rendering intent 3)*/\n  if(!use_icc || icc->inputspace == 2 || rendering_intent != 3) {\n    for(i = 0; i < n; i++) {\n      size_t j = i * 4;\n      mulMatrix(&out[j + 0], &out[j + 1], &out[j + 2], m, in[j + 0], in[j + 1], in[j + 2]);\n      out[j + 3] = in[j + 3];\n    }\n  } else {\n    for(i = 0; i < n * 4; i++) {\n      out[i] = in[i];\n    }\n  }\n\n  return 0;\n}\n\n/* Converts in-place. Does not clamp. */\nstatic unsigned convertFromXYZ_gamma(float* im, unsigned w, unsigned h,\n                                     const LodePNGInfo* info, unsigned use_icc, const LodePNGICC* icc) {\n  size_t i, c, n;\n  if(lodepng_mulofl((size_t)w, (size_t)h, &n)) return 92;\n  if(use_icc) {\n    for(i = 0; i < n; i++) {\n      for(c = 0; c < 3; c++) {\n        /* TODO: this is likely very slow */\n        im[i * 4 + c] = iccBackwardTRC(&icc->trc[c], im[i * 4 + c]);\n      }\n    }\n  } else if(info->gama_defined && !info->srgb_defined) {\n    /* nothing to do if gamma is 1 */\n    if(info->gama_gamma != 100000) {\n      float gamma = info->gama_gamma / 100000.0f;\n      for(i = 0; i < n; i++) {\n        for(c = 0; c < 3; c++) {\n          if(im[i * 4 + c] > 0) im[i * 4 + c] = lodepng_powf(im[i * 4 + c], gamma);\n        }\n      }\n    }\n  } else {\n    for(i = 0; i < n; i++) {\n      for(c = 0; c < 3; c++) {\n        /* sRGB gamma compress */\n        float* v = &im[i * 4 + c];\n        *v = (*v < 0.0031308f) ? (*v * 12.92f) : (1.055f * lodepng_powf(*v, 1 / 2.4f) - 0.055f);\n      }\n    }\n  }\n  return 0; /* no error */\n}\n\nunsigned convertFromXYZ(unsigned char* out, const float* in, unsigned w, unsigned h,\n                        const LodePNGState* state,\n                        const float whitepoint[3], unsigned rendering_intent) {\n  unsigned error = 0;\n  size_t i, c, n, bytes_im, bytes_data;\n  const LodePNGColorMode* mode_out = &state->info_raw;\n  const LodePNGInfo* info = &state->info_png;\n  int bit16 = mode_out->bitdepth > 8;\n  float* im = 0;\n  unsigned char* data = 0;\n\n  /* parse ICC if present */\n  unsigned use_icc = 0;\n  LodePNGICC icc;\n  lodepng_icc_init(&icc);\n  if(info->iccp_defined) {\n    error = parseICC(&icc, info->iccp_profile, info->iccp_profile_size);\n    if(error) goto cleanup; /* corrupted ICC profile */\n    use_icc = validateICC(&icc);\n  }\n\n  if(lodepng_mulofl((size_t)w, (size_t)h, &n)) error = 92;\n  if(error) goto cleanup;\n  if(lodepng_mulofl(n, 4 * sizeof(float), &bytes_im)) error = 92;\n  if(error) goto cleanup;\n  if(lodepng_mulofl(n, bit16 ? 8 : 4, &bytes_data)) error = 92;\n  if(error) goto cleanup;\n\n  /* Handle gamut */\n  im = (float*)lodepng_malloc(bytes_im);\n  error = convertFromXYZ_chrm(im, in, w, h, info, use_icc, &icc, whitepoint, rendering_intent);\n  if(error) goto cleanup;\n\n  /* Handle transfer function */\n  /* Input is floating point, so lookup table cannot be used, but it's ensured to use float pow, not the slower double pow. */\n  error = convertFromXYZ_gamma(im, w, h, info, use_icc, &icc);\n  if(error) goto cleanup;\n\n  /* Convert to integer output */\n  data = (unsigned char*)lodepng_malloc(bytes_data);\n  /* TODO: check if also 1/2/4 bit case needed: rounding is at different fine-grainedness for 8 and 16 bits below. */\n  if(bit16) {\n    LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGBA, 16);\n    for(i = 0; i < n; i++) {\n      for(c = 0; c < 4; c++) {\n        size_t j = i * 8 + c * 2;\n        int i16 = (int)(0.5f + 65535.0f * LODEPNG_MIN(LODEPNG_MAX(0.0f, im[i * 4 + c]), 1.0f));\n        data[j + 0] = (unsigned char)(i16 >> 8);\n        data[j + 1] = (unsigned char)(i16 & 255);\n      }\n    }\n    error = lodepng_convert(out, data, mode_out, &mode16, w, h);\n    if(error) goto cleanup;\n  } else {\n    LodePNGColorMode mode8 = lodepng_color_mode_make(LCT_RGBA, 8);\n    for(i = 0; i < n; i++) {\n      for(c = 0; c < 4; c++) {\n        data[i * 4 + c] = (unsigned char)(0.5f + 255.0f * LODEPNG_MIN(LODEPNG_MAX(0.0f, im[i * 4 + c]), 1.0f));\n      }\n    }\n    error = lodepng_convert(out, data, mode_out, &mode8, w, h);\n    if(error) goto cleanup;\n  }\n\ncleanup:\n  lodepng_icc_cleanup(&icc);\n  lodepng_free(im);\n  lodepng_free(data);\n  return error;\n}\n\nunsigned convertFromXYZFloat(float* out, const float* in, unsigned w, unsigned h,\n                             const LodePNGState* state,\n                             const float whitepoint[3], unsigned rendering_intent) {\n  unsigned error = 0;\n  const LodePNGInfo* info = &state->info_png;\n\n  /* parse ICC if present */\n  unsigned use_icc = 0;\n  LodePNGICC icc;\n  lodepng_icc_init(&icc);\n  if(info->iccp_defined) {\n    error = parseICC(&icc, info->iccp_profile, info->iccp_profile_size);\n    if(error) goto cleanup; /* corrupted ICC profile */\n    use_icc = validateICC(&icc);\n  }\n\n  /* Handle gamut */\n  error = convertFromXYZ_chrm(out, in, w, h, info, use_icc, &icc, whitepoint, rendering_intent);\n  if(error) goto cleanup;\n\n  /* Handle transfer function */\n  error = convertFromXYZ_gamma(out, w, h, info, use_icc, &icc);\n  if(error) goto cleanup;\n\ncleanup:\n  lodepng_icc_cleanup(&icc);\n  return error;\n}\n\nunsigned convertRGBModel(unsigned char* out, const unsigned char* in,\n                         unsigned w, unsigned h,\n                         const LodePNGState* state_out,\n                         const LodePNGState* state_in,\n                         unsigned rendering_intent) {\n  if(modelsEqual(state_in, state_out)) {\n    return lodepng_convert(out, in, &state_out->info_raw, &state_in->info_raw, w, h);\n  } else {\n    unsigned error = 0;\n    size_t n, bytes;\n    if(lodepng_mulofl((size_t)w, (size_t)h, &n)) return 92;\n    if(lodepng_mulofl(n, 4 * sizeof(float), &bytes)) return 92;\n    float* xyz = (float*)lodepng_malloc(bytes);\n    float whitepoint[3];\n    error = convertToXYZ(xyz, whitepoint, in, w, h, state_in);\n    if (!error) error = convertFromXYZ(out, xyz, w, h, state_out, whitepoint, rendering_intent);\n    lodepng_free(xyz);\n    return error;\n  }\n}\n\nunsigned convertToSrgb(unsigned char* out, const unsigned char* in,\n                       unsigned w, unsigned h,\n                       const LodePNGState* state_in) {\n  LodePNGState srgb;\n  lodepng_state_init(&srgb);\n  lodepng_color_mode_copy(&srgb.info_raw, &state_in->info_raw);\n  return convertRGBModel(out, in, w, h, &srgb, state_in, 1);\n}\n\nunsigned convertFromSrgb(unsigned char* out, const unsigned char* in,\n                         unsigned w, unsigned h,\n                         const LodePNGState* state_out) {\n  LodePNGState srgb;\n  lodepng_state_init(&srgb);\n  lodepng_color_mode_copy(&srgb.info_raw, &state_out->info_raw);\n  return convertRGBModel(out, in, w, h, state_out, &srgb, 1);\n}\n\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\n} // namespace lodepng\n"
        },
        {
          "name": "lodepng_util.h",
          "type": "blob",
          "size": 11.861328125,
          "content": "/*\nLodePNG Utils\n\nCopyright (c) 2005-2024 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n/*\nExtra C++ utilities for LodePNG, for convenience.\nNot part of the stable API of lodepng, more loose separate utils.\n*/\n\n#ifndef LODEPNG_UTIL_H\n#define LODEPNG_UTIL_H\n\n#include <string>\n#include <vector>\n#include \"lodepng.h\"\n\nnamespace lodepng {\n\n/*\nReturns info from the header of the PNG by value, purely for convenience.\nDoes NOT check for errors. Returns bogus info if the PNG has an error.\nDoes not require cleanup of allocated memory because no palette or text chunk\ninfo is in the LodePNGInfo object after checking only the header of the PNG.\n*/\nLodePNGInfo getPNGHeaderInfo(const std::vector<unsigned char>& png);\n\n/*\nGet the names and sizes of all chunks in the PNG file.\nReturns 0 if ok, non-0 if error happened.\n*/\nunsigned getChunkInfo(std::vector<std::string>& names, std::vector<size_t>& sizes,\n                      const std::vector<unsigned char>& png);\n\n/*\nReturns the names and full chunks (including the name and everything else that\nmakes up the chunk) for all chunks except IHDR, PLTE, IDAT and IEND.\nIt separates the chunks into 3 separate lists, representing the chunks between\ncertain critical chunks: 0: IHDR-PLTE, 1: PLTE-IDAT, 2: IDAT-IEND\nReturns 0 if ok, non-0 if error happened.\n*/\nunsigned getChunks(std::vector<std::string> names[3],\n                   std::vector<std::vector<unsigned char> > chunks[3],\n                   const std::vector<unsigned char>& png);\n\n/*\nInserts chunks into the given png file. The chunks must be fully encoded,\nincluding length, type, content and CRC.\nThe array index determines where it goes:\n0: between IHDR and PLTE, 1: between PLTE and IDAT, 2: between IDAT and IEND.\nThey're appended at the end of those locations within the PNG.\nReturns 0 if ok, non-0 if error happened.\n*/\nunsigned insertChunks(std::vector<unsigned char>& png,\n                      const std::vector<std::vector<unsigned char> > chunks[3]);\n\n/*\nGet the filtertypes of each scanline in this PNG file.\nReturns 0 if ok, 1 if PNG decoding error happened.\n\nFor a non-interlaced PNG, it returns one filtertype per scanline, in order.\n\nFor interlaced PNGs, it returns a result as if it's not interlaced. It returns\none filtertype per scanline, in order. The values match pass 6 and 7 of the\nAdam7 interlacing, alternating between the two, so that the values correspond\nthe most to their scanlines.\n*/\nunsigned getFilterTypes(std::vector<unsigned char>& filterTypes, const std::vector<unsigned char>& png);\n\n/*\nGet the filtertypes of each scanline in every interlace pass this PNG file.\nReturns 0 if ok, 1 if PNG decoding error happened.\n\nFor a non-interlaced PNG, it returns one filtertype per scanline, in order, in\na single std::vector in filterTypes.\n\nFor an interlaced PNG, it returns 7 std::vectors in filterTypes, one for each\nAdam7 pass. The amount of values per pass can be calculated as follows, where\nw and h are the size of the image and all divisions are integer divisions:\npass 1: (h + 7) / 8\npass 2: w <= 4 ? 0 : (h + 7) / 8\npass 3: h <= 4 ? 0 : (h + 7) / 8\npass 4: w <= 2 ? 0 : (h + 3) / 4\npass 5: h <= 2 ? 0 : (h + 3) / 4\npass 6: w <= 1 ? 0 : (h + 1) / 2\npass 7: h <= 1 ? 0 : (h + 1) / 2\n*/\nunsigned getFilterTypesInterlaced(std::vector<std::vector<unsigned char> >& filterTypes,\n                                  const std::vector<unsigned char>& png);\n\n/*\nReturns the value of the i-th pixel in an image with 1, 2, 4 or 8-bit color.\nE.g. if bits is 4 and i is 5, it returns the 5th nibble (4-bit group), which\nis the second half of the 3th byte, in big endian (PNG's endian order).\n*/\nint getPaletteValue(const unsigned char* data, size_t i, int bits);\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n\n/* Similar to convertRGBModel, but the 'to' model is sRGB. The pixel format\nof in and out must be the same and is given by state_in->info_raw. An\nerror may occur if the pixel format cannot contain the new colors (e.g. palette) */\nunsigned convertToSrgb(unsigned char* out, const unsigned char* in,\n                       unsigned w, unsigned h,\n                       const LodePNGState* state_in);\n\n/* Similar to convertRGBModel, but the 'from' model is sRGB. The pixel format\nof in and out must be the same and is given by state_out->info_raw. An\nerror may occur if the pixel format cannot contain the new colors (e.g. palette) */\nunsigned convertFromSrgb(unsigned char* out, const unsigned char* in,\n                         unsigned w, unsigned h,\n                         const LodePNGState* state_out);\n\n/*\nConverts from one RGB model to another RGB model.\nSimilar to calling convertToXYZ followed by convertFromXYZ, but may be\nmore efficient and more precise (e.g. no computation needed when both models\nare the same). See their documentation for more info.\n\nParameters:\n\n*) out: output pixel data\n*) in: input pixel data\n*) w, h: image size\n*) state_out: output RGB color model in state_out->info_png and byte format in state_out->info_raw.\n*) state_in: output RGB color model in state_in->info_png and byte format in state_in->info_raw\n*) return value: 0 if ok, positive value if error\n*) rendering_intent: 1 for relative, 3 for absolute, should be relative for standard behavior.\n   See description at convertFromXYZ.\n*/\nunsigned convertRGBModel(unsigned char* out, const unsigned char* in,\n                         unsigned w, unsigned h,\n                         const LodePNGState* state_out,\n                         const LodePNGState* state_in,\n                         unsigned rendering_intent);\n\n/*\nConverts the RGB color to the absolute XYZ color space given the RGB color profile\nchunks in the PNG info.\n\nColor space here refers to the different possible RGB spaces with different\npossible chromaticities or whitepoint and XYZ color from colorimetry, not the\nLodePNGColorType that describes the byte based encoding.\n\nYou need this function only if the PNG could contain data in an arbitrary RGB\ncolor space and you wish to output to a display or format that does not provide\ncolor management for you (so you need to convert rather than pass on the profile\nto it) but expects a certain RGB format (e.g. sRGB). See the background info below.\n\nSupports the gAMA, cHRM, sRGB and iCCP colorimetry chunks. If no colometry chunks are present\n(that is, in state->info_png, the fields gama_defined, chrm_defined, srgb_defined and\niccp_defined are all 0), it assumes the format is sRGB.\nFor more information, see the chunk specifications in the PNG specification.\n\nSome background:\n\nA PNG image contains RGB data inside, but this data may use a specific RGB model (by default sRGB but\ndifferent if colorimetry chunks are given).\nThe computer display and/or operating system can have another RGB model (typically sRGB, or wider gamut\nor HDR formats).\n\nThe PNG chunks describe what format the data inside has, not the format of the display. To correctly\ndisplay a PNG image on a display, a conversion is needed from the PNG model to the display model if their\nmodels differ. Some options to achieve that are:\n*) If your use case already supports color management on its own, you can give it the RGB values straight from\n   the PNG image and give it the information from the cHRM, gAMA, sRGB and iCCP chunks (which you can find\n   in the LodePNGInfo), and the color management should then handle it correctly for you. You don't need\n   this function here in that case.\n*) If your use case does not support color management, you may instead want to give it the RGB values in a\n   consistent color model, such as sRGB, but the PNG does not necessarily have it in this desired model.\n   In that case, use the function below (or a similar one from a CMS library if you prefer) to convert it to\n   the absolute color space XYZ, and then you can convert it to the target RGB with the counterpart convertFromXYZ\n   further below.\n\nParameters:\n\n*) out: 4 floats per pixel, X,Y,Z,alpha color format, in range 0-1 (normally, not clipped if beyond), must\n   be allocated to have 4 * w * h floats available.\n*) whitepoint: output argument, the whitepoint the original RGB data used, given in absolute XYZ. Needed for\n   relative rendering intents: give these values to counterpart function convertFromXYZ.\n*) in: input RGB color, in byte format given by state->info_raw and RGB color profile given by info->info_png\n*) w, h: image size\n*) state (when using a LodePNG decode function that takes a LodePNGState parameter, can directly use that one):\n   state->info_png: PNG info with possibly an RGB color model in cHRM,gAMA and/or sRGB chunks\n   state->info_raw: byte format of in (amount of channels, bit depth)\n*) return value: 0 if ok, positive value if error\n*/\nunsigned convertToXYZ(float* out, float whitepoint[3],\n                      const unsigned char* in, unsigned w, unsigned h,\n                      const LodePNGState* state);\n\n/*\nSame as convertToXYZ but takes floating point input. Slower.\nThe main black..white range is 0..1. Does not clip values that are outside that range.\n*/\nunsigned convertToXYZFloat(float* out, float whitepoint[3], const float* in,\n                           unsigned w, unsigned h, const LodePNGState* state);\n\n/*\nConverts XYZ to RGB in the RGB color model given by info and byte format by mode_out.\nIf info has no coloremtry chunks, converts to sRGB.\nParameters:\n*) out: output color in byte format given by state->info_raw and RGB color profile given\n   by info->info_png. Must have enough bytes allocated to contain pixels in the given byte format.\n*) in: 4 floats per pixel, X,Y,Z,alpha color format, in range 0-1 (normally).\n*) whitepoint: input argument, the original whitepoint in absolute XYZ that the pixel data\n   in \"in\" had back when it was in a previous RGB space. Needed to preserve the whitepoint\n   in the new target RGB space for relative rendering intent.\n*) rendering_intent: the desired rendering intent, with numeric meaning matching the\n   values used by ICC: 0=perceptual, 1=relative, 2=saturation, 3=absolute.\n   Should be 1 for normal use cases, it adapts white to match that of different RGB\n   models which is the best practice. Using 3 may change the color of white and may\n   turn grayscale into colors of a certain tone. Using 0 and 2 will have the same\n   effect as 1 because using those requires more data than the matrix-based RGB profiles\n   supporetd here have.\n*) w, h: image size\n*) state:\n   state->info_png: PNG info with possibly an RGB color profile in cHRM,gAMA and/or sRGB chunks\n   state->info_raw: byte format of out (amount of channels, bit depth)\n*) return value: 0 if ok, positive value if error\n*/\nunsigned convertFromXYZ(unsigned char* out, const float* in, unsigned w, unsigned h,\n                        const LodePNGState* state,\n                        const float whitepoint[3], unsigned rendering_intent);\n\n/*\nSame as convertFromXYZ but outputs the RGB colors in floating point.\nThe main black..white range is 0..1. Does not clip values that are outside that range.\n*/\nunsigned convertFromXYZFloat(float* out, const float* in, unsigned w, unsigned h,\n                             const LodePNGState* state,\n                             const float whitepoint[3], unsigned rendering_intent);\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\n} // namespace lodepng\n\n#endif /*LODEPNG_UTIL_H inclusion guard*/\n"
        },
        {
          "name": "pngdetail.cpp",
          "type": "blob",
          "size": 59.21875,
          "content": "/*\nLodePNG pngdetail\n\nCopyright (c) 2005-2024 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n//g++ pngdetail.cpp lodepng_util.cpp lodepng.cpp -ansi -pedantic -Wall -Wextra -o pngdetail -O3\n\n\n/*\nUtility program that shows a lot of information in the console about a PNG file,\nincluding color type, text chunks, the names and sizes of all chunks in the\nimage, exif, and ICC profile, etc...\n*/\n\n#include \"lodepng.h\"\n#include \"lodepng_util.h\"\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <cmath>\n#include <sstream>\n#include <algorithm>\n#include <stdio.h>\n#include <inttypes.h>\n\nvoid showHelp() {\n  std::cout << \"pngdetail by Lode Vandevenne\" << std::endl;\n  std::cout << \"version: \" << LODEPNG_VERSION_STRING << std::endl;\n  std::cout << \"Shows detailed information about a PNG image, its compression and possible corruptions.\\n\"\n               \"Usage: pngdetail [filename] [options]...\\n\"\n               \"Without options shows a default set of stats. With options, shows only selected options.\\n\"\n               \"E.g. 'pngdetail image.png -plc' to show png info, palette info and chunks\\n\"\n               \"Options:\\n\"\n               \"-o: show header summary on one line\\n\"\n               \"-H: show header info\\n\"\n               \"-p: show PNG file info\\n\"\n               \"-a: analyze errors or warnings\\n\"\n               \"-e: show exif metadata (if the PNG has an eXIf chunk)\\n\"\n               \"-E: show exif metadata hex bytes\\n\"\n               \"-i: show ICC profile details (if any)\\n\"\n               \"-I: show ICC profile hex bytes\\n\"\n               \"--format=<format>: display mode for -I:\\n\"\n               \"    hex: print bytes in hex\\n\"\n               \"    mix: print printable bytes as ASCII characters, hex for others\\n\"\n               \"    bin: dump as binary in terminal\\n\"\n               \"-l: show palette (if any)\\n\"\n               \"-s: show color statistics\\n\"\n               \"-r: render the PNG image in terminal (with --mode and --size)\\n\"\n               \"--size=<width>: render width for -r\\n\"\n               \"--mode=<mode>: render mode for -r:\\n\"\n               \"    ascii:   Letters ROYLGTCABVMF indicate hue (L=lime, T=turquoise, A=azure, F=fuchsia, ...).\\n\"\n               \"    hex:     CSS hex notation for every pixel.\\n\"\n               \"    hex16:   Like hex but shows 16 bits values per channel.\\n\"\n               \"    palette: Shows palette index of each pixel, only for palette images.\\n\"\n               \"--size=<width>: render width (not used by hex, hex16 or palette):\\n\"\n               \"-c: show PNG chunks\\n\"\n               \"-C: show PNG chunks (alternate format)\\n\"\n               \"-f: show PNG filters\\n\"\n               \"-z: show Zlib info\\n\"\n               \"-v: be more verbose\\n\"\n               \"-t: expand long texts\\n\"\n               \"-x: print most integer numbers in hexadecimal (includes e.g. year, num unique colors, ...)\\n\"\n               \"-?, --help, -h: show this help\" << std::endl;\n}\n\nenum RenderMode {\n  RM_ASCII,\n  RM_HEX, // CSS\n  RM_HEX16,\n  RM_PAL // palette indices (only rendered if image is palette based)\n};\n\n// for displaying ICC profile\nenum HexFormat {\n  HF_HEX,\n  HF_MIX, // hex and ascii\n  HF_BIN // bytes as binary data dump\n};\n\nstruct Options {\n  bool verbose;\n  bool expand_long_texts;\n  bool show_one_line_summary; //show filesize, pixels and color type on single line\n  bool show_header; // show only info from the IHDR chunk\n  bool show_errors;\n  bool show_icc_details; // show ICC color profile details\n  bool show_icc_hex; // show ICC color profile in full\n  bool show_exif;\n  bool show_exif_hex;\n  bool show_color_stats;\n  bool show_png_info; //show things like filesize, width, height, palette size, ...\n  bool show_palette; //show all palette values\n  bool show_palette_pixels; //show palette indices of pixels\n\n  HexFormat hexformat;\n\n  bool show_render;\n  RenderMode rendermode;\n  int rendersize;\n\n  bool show_chunks; //show the PNG chunk names and their lengths\n  bool show_chunks2; //alternate form to print chunks\n  bool show_filters; //show the PNG filter of each scanline (not supported for interlaced PNGs currently)\n  bool show_zlib_info; //show basic zlib info\n  bool use_hex; //show some sizes or positions in hexadecimal\n\n  Options() : verbose(false), expand_long_texts(false),\n              show_one_line_summary(false), show_header(false), show_errors(false),\n              show_icc_details(false), show_icc_hex(false), show_exif(false), show_exif_hex(false),\n              show_color_stats(false), show_png_info(false),\n              show_palette(false), show_palette_pixels(false),\n              hexformat(HF_MIX), show_render(false), rendermode(RM_ASCII), rendersize(80),\n              show_chunks(false), show_chunks2(false), show_filters(false),\n              show_zlib_info(false), use_hex(false) {\n  }\n};\n\nunsigned inspect_chunk_by_name(const unsigned char* data, const unsigned char* end,\n                               lodepng::State& state, const char type[5]) {\n  const unsigned char* p = lodepng_chunk_find_const(data, end, type);\n  if(!p) return 0; // not found, but this is not considered an error\n  return lodepng_inspect_chunk(&state, p - data, data, end - data);\n}\n\n// Lazy loads the raw file, inspected header or entire image as needed\nstruct Data {\n  std::string filename;\n  std::vector<unsigned char> buffer;\n  std::vector<unsigned char> pixels; // 16-bit\n  unsigned w;\n  unsigned h;\n  lodepng::State state;\n  unsigned error;\n  bool inspected;\n  bool is_png; // not is_icc or is_exif\n  bool is_icc; // the file is a raw icc file, not a PNG, only options -i and -I are useful\n  bool is_exif; // the file is a raw exif file, not a PNG, only option -e is useful\n\n  Data(const std::string& filename) : filename(filename), error(0), inspected(false), is_png(false), is_icc(false), is_exif(false) {}\n\n  // Load the file if not already loaded\n  void loadFile() {\n    if(buffer.empty()) {\n      error = lodepng::load_file(buffer, filename); //load the image file with given filename\n    } else {\n      error = 0; // for reloadpixels, reset error if file was already successfully loaded\n    }\n  }\n\n  // is PNG according to the file signature\n  bool isPng() {\n    if(buffer.size() < 8) return false;\n    return buffer[0] == 137 && buffer[1] == 80 && buffer[2] == 78 && buffer[3] == 71\n        && buffer[4] == 13 && buffer[5] == 10 && buffer[6] == 26 && buffer[7] == 10;\n  }\n\n  // is probably an ICC profile instead of a PNG image\n  bool isIcc() {\n    if(isPng()) return false;\n    if(buffer.size() < 128) return false;\n    size_t size = (buffer[0] << 24) + (buffer[1] << 16) + (buffer[2] << 8) + buffer[3];\n    if(size != buffer.size()) return false;\n    if(buffer[36] != 'a') return false;\n    if(buffer[37] != 'c') return false;\n    if(buffer[38] != 's') return false;\n    if(buffer[39] != 'p') return false;\n    return true;\n  }\n  // is probably an EXIF file instead of a PNG image\n  bool isExif() {\n    if(buffer.size() < 8) return false;\n    if(buffer[0] == 'M' && buffer[1] == 'M' && buffer[2] == 0 && buffer[3] == 42) return true;\n    if(buffer[0] == 'I' && buffer[1] == 'I' && buffer[2] == 42 && buffer[3] == 0) return true;\n    return false;\n  }\n\n  // Load header info (plus a few more nearby light chunks) if not already loaded, and the file if needed\n  void loadInspect() {\n    if(inspected) return;\n    inspected = true;\n    loadFile();\n    if(error) return;\n    is_png = is_icc = is_exif = false;\n    if(isIcc()) {\n      lodepng_set_icc(&state.info_png, \"<none>\", &buffer[0], buffer.size());\n      is_icc = true;\n    } else if(isExif()) {\n      lodepng_set_exif(&state.info_png, &buffer[0], buffer.size());\n      is_exif = true;\n    } else {\n      is_png = true;\n      const unsigned char* data = &buffer[0];\n      error = lodepng_inspect(&w, &h, &state, data, buffer.size());\n      if(error) return;\n      // end before first IDAT chunk: do not parse more than first part of file for all this.\n      const unsigned char* end = lodepng_chunk_find_const(data, data + buffer.size(), \"IDAT\");\n      if(!end) end = data + buffer.size(); // no IDAT, invalid PNG but extract info anyway\n      error = inspect_chunk_by_name(data, end, state, \"PLTE\");\n      if(error) return;\n      error = inspect_chunk_by_name(data, end, state, \"tRNS\");\n      if(error) return;\n      error = inspect_chunk_by_name(data, end, state, \"cHRM\");\n      if(error) return;\n      error = inspect_chunk_by_name(data, end, state, \"gAMA\");\n      if(error) return;\n      error = inspect_chunk_by_name(data, end, state, \"sBIT\");\n      if(error) return;\n      error = inspect_chunk_by_name(data, end, state, \"bKGD\");\n      if(error) return;\n      error = inspect_chunk_by_name(data, end, state, \"hIST\");\n      if(error) return;\n      error = inspect_chunk_by_name(data, end, state, \"pHYs\");\n      if(error) return;\n      error = inspect_chunk_by_name(data, end, state, \"iCCP\");\n      if(error) return;\n      error = inspect_chunk_by_name(data, end, state, \"eXIf\");\n      if(error) return;\n    }\n  }\n\n  // Load the pixels if not already loaded, and the file if needed\n  void loadPixels() {\n    if(pixels.empty()) reloadPixels();\n  }\n\n  void reloadPixels() {\n    loadFile();\n    if(error) return;\n    inspected = true;\n    state.info_raw.colortype = LCT_RGBA;\n    state.info_raw.bitdepth = 16;\n    pixels.clear();\n    error = lodepng::decode(pixels, w, h, state, buffer);\n  }\n};\n\nstd::string colorTypeString(LodePNGColorType type) {\n  std::string name;\n  switch(type) {\n    case LCT_GREY: name = \"grey\"; break;\n    case LCT_RGB: name = \"RGB\"; break;\n    case LCT_PALETTE: name = \"palette\"; break;\n    case LCT_GREY_ALPHA: name = \"grey+alpha\"; break;\n    case LCT_RGBA: name = \"RGBA\"; break;\n    default: name = \"invalid\"; break;\n  }\n  std::stringstream ss;\n  ss << type << \" (\" << name << \")\";\n  return ss.str();\n}\n\ntemplate<typename T>\nT strtoval(const std::string& s) {\n  std::istringstream sstream(s);\n  T val;\n  sstream >> val;\n  return val;\n}\n\n\n/*\nDisplay the names and sizes of all chunks in the PNG file.\n*/\nvoid displayChunkNames(Data& data, const Options& options) {\n  if(!data.is_png) return;\n  data.loadFile();\n  if(data.error) return;\n  std::cout << (options.use_hex ? std::hex: std::dec);\n  const std::vector<unsigned char>& buffer = data.buffer;\n  std::vector<std::string> names;\n  std::vector<size_t> sizes;\n  unsigned error = lodepng::getChunkInfo(names, sizes, buffer);\n  if(error) {\n    if(!names.empty() && names.back() == \"IEND\" && sizes.back() == 0) {\n      std::cout << \"Corruption or superfluous data detected after the IEND chunk\" << std::endl;\n    } else {\n      std::cout << \"Error while identifying chunks. Listing identified chunks anyway.\" << std::endl;\n    }\n  }\n\n  if(options.show_chunks2) {\n    std::cout << \"Chunk types: \";\n    for(size_t i = 0; i < names.size(); i++) std::cout << names[i] << \" \";\n    std::cout << std::endl;\n    std::cout << \"Chunk sizes: \";\n    for(size_t i = 0; i < sizes.size(); i++) std::cout << sizes[i] << \" \";\n    std::cout << std::endl;\n  } else {\n    std::cout << \"Chunks (type: lengths):\";\n    std::string last_type;\n    for(size_t i = 0; i < names.size(); i++) {\n      if(last_type != names[i]) {\n        std::cout << std::endl;\n        std::cout << \" \" << names[i] << \": \";\n      }\n      last_type = names[i];\n\n      std::cout << sizes[i] << \" \";\n    }\n    std::cout << std::endl;\n  }\n\n  std::map<std::string, bool> typedict;\n  for(size_t i = 0; i < names.size(); i++) {\n    typedict[names[i]] = true;\n  }\n\n  if(!error) {\n    if(!typedict[\"IHDR\"]) std::cout << \"Error: no IHDR chunk\" << std::endl;\n    if(!typedict[\"IDAT\"]) std::cout << \"Error: no IDAT chunk\" << std::endl;\n    if(!typedict[\"IEND\"]) std::cout << \"Error: no IEND chunk\" << std::endl;\n  }\n}\n\nvoid RGBtoHSL(unsigned char r, unsigned char g, unsigned char b, unsigned char* h, unsigned char* s, unsigned char* l) {\n  int cmax = std::max<int>(r, std::max<int>(g, b));\n  int cmin = std::min<int>(r, std::min<int>(g, b));\n  if(cmin == cmax) {\n    *h = *s = 0;\n    *l = r;\n  } else {\n    int sum = cmin + cmax;\n    int diff = cmax - cmin;\n    *l = sum / 2;\n    *s = 255 * diff / ((*l < 128) ? sum : (512 - sum));\n    int hi = (r == cmax) ? (255 * (g - b) / diff) : ((g == cmax) ? (512 + 255 * (b - r) / diff) : (1024 + 255 * (r - g) / diff));\n    *h = ((hi / 6) & 255);\n  }\n}\n\n/*\nHCT: Hue, Chroma, Tone: returns a linear combination between a pure hue and a greyscale value.\n*) Chroma: The linear combination factor: 255 for pure hue, 0 for pure greyscale\n*) Tone: greyscale to mix with: 0 = black (shade), 255 = white (tint), in between = grey (tone)\n*/\nvoid RGBtoHCT(unsigned char r, unsigned char g, unsigned char b, unsigned char* h, unsigned char* c, unsigned char* t) {\n  int cmax = std::max<int>(r, std::max<int>(g, b));\n  int cmin = std::min<int>(r, std::min<int>(g, b));\n  RGBtoHSL(r, g, b, h, c, t);\n  *c = cmax - cmin;\n  *t = *c == 255 ? 0 : 255 * cmin / (255 + cmin - cmax);\n}\n\n// add 32 to get small letter instead of capital\nchar HueToLetter(int h) {\n  char hl = 'R';\n  // 12 unique hue letters for 30 degree increment hues.\n  if(h < 11 || h >= 244) hl = 'R';  // red\n  else if(h >= 11 && h < 32) hl = 'O';  // orange\n  else if(h >= 32 && h < 53) hl = 'Y';  // yellow\n  else if(h >= 53 && h < 74) hl = 'L';  // lime (officialy \"chartreuse\" but c is for cyan)\n  else if(h >= 74 && h < 96) hl = 'G';  // green\n  else if(h >= 96 && h < 117) hl = 'T';  // turquoise (officially \"spring green\" but that name overlaps green)\n  else if(h >= 117 && h < 138) hl = 'C';  // cyan\n  else if(h >= 138 && h < 159) hl = 'A';  // azure\n  else if(h >= 159 && h < 181) hl = 'B';  // blue\n  else if(h >= 181 && h < 202) hl = 'V';  // violet\n  else if(h >= 202 && h < 223) hl = 'M';  // magenta\n  else if(h >= 223 && h < 244) hl = 'F';  // fuchsia (officially \"rose\" but r is for red)\n  return hl;\n}\n\nchar lightnessToLetter(int l) {\n  int c = ' ';\n  if(l < 16) c = ' ';\n  else if(l < 48) c = '.';\n  else if(l < 80) c = ':';\n  else if(l < 112) c = '-';\n  else if(l < 144) c = '!';\n  else if(l < 176) c = '*';\n  else if(l < 208) c = '+'; // The + looks denser than the * in a terminal...\n  else if(l < 240) c = '=';\n  else c = '#';\n  return c;\n}\n\n// Both v and result are assumed in range 0-255\n// range is the size of an individual bucket. A value in roughly range [-range/2, range/2) can get added to v.\n// E.g. if there are 12 hue letters, give 255/12 = 21 as range\nstatic inline int applyDither(int v, int range, int x, int y, bool wrap) {\n  // ordered dithering pattern; ranges from 0-15, so multiply with 17 to have 0-255\n  static const int pattern[16] = {0,8,2,10,\n                                  12,4,14,6,\n                                  3,11,1,9,\n                                  15,7,13,5};\n  int d = pattern[(x & 3) + 4 * (y & 3)] * 17 - 128; // range: -128 to 127\n  if(wrap) return (v + d * range / 256) & 255;\n  else return std::max(0, std::min(255, v + d * range / 256));\n}\n\n// x and y are to use for dithering\n// inverted inverts black and white, for in case black text on white background is used (by default it assumes white text on black background)\nchar RGBtoLetter(unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned x, unsigned y, bool dither = true, bool inverted = false) {\n  if(a < 255) {\n    r = a * r / 255;\n    g = a * g / 255;\n    b = a * b / 255;\n  }\n\n  if(dither) {\n    unsigned char h, c, t;\n    RGBtoHCT(r, g, b, &h, &c, &t);\n    int l = (std::max(std::max(r, g), b) + std::min(std::min(r, g), b)) / 2;\n    if(inverted) {\n      l = 255 - l;\n      t = 255 - t;\n    }\n    if(applyDither(c, 254, x, y, false) >= 128) {\n      char letter = HueToLetter(applyDither(h, 21, x, y, true));\n      bool smallcaps = applyDither(l, 64, x+2, y+2, false) < 80;\n      return letter + (smallcaps ? 32 : 0);\n    }\n    else return lightnessToLetter(applyDither(l, 31, x, y, false));\n  } else {\n    unsigned char h, s, l;\n    RGBtoHSL(r, g, b, &h, &s, &l);\n    if(inverted) l = 255 - l;\n\n    char hl = HueToLetter(h);\n    char c = ' ';\n    if(l < 24 || l > 232 || s < 64) {\n      c = lightnessToLetter(l);\n    } else {\n      if(l < 128) c = hl + 32;\n      else c = hl;\n    }\n    return c;\n  }\n}\n\nstd::vector<unsigned char> rescale(const std::vector<unsigned char>& in,\n                                   int w0, int h0, int w1, int h1, bool smooth) {\n  int numchannels = in.size() / (w0 * h0);\n  std::vector<unsigned char> out(w1 * h1 * numchannels);\n  if(smooth) {\n    // box filter.\n    std::vector<unsigned char> temp(w1 * h0 * numchannels);\n    for (int c = 0; c < numchannels; c++) {\n      for (int x = 0; x < w1; x++) {\n        float xaf = x * 1.0 * w0 / w1;\n        float xbf = (x + 1.0) * w0 / w1;\n        int xa = (int)xaf;\n        int xb = (int)xbf;\n        double norm = 1.0 / (xbf - xaf);\n        xaf -= std::floor(xaf);\n        xbf -= std::floor(xbf);\n        for (int y = 0; y < h0; y++) {\n          int index1 = x * numchannels + y * w1 * numchannels;\n          double val = 0;\n          for(int x0 = xa; x0 <= xb; x0++) {\n            int index0 = x0 * numchannels + y * w0 * numchannels;\n            double v = 1;\n            if(x0 == xa) v -= xaf;\n            if(x0 == xb) v -= (1 - xbf);\n            val += v * in[index0 + c];\n          }\n          temp[index1 + c] = val * norm;\n        }\n      }\n      for (int y = 0; y < h1; y++) {\n        float yaf = y * 1.0 * h0 / h1;\n        float ybf = (y + 1.0) * h0 / h1;\n        int ya = (int)yaf;\n        int yb = (int)ybf;\n        double norm = 1.0 / (ybf - yaf);\n        yaf -= std::floor(yaf);\n        ybf -= std::floor(ybf);\n        for (int x = 0; x < w1; x++) {\n          int index1 = x * numchannels + y * w1 * numchannels;\n          double val = 0;\n          for(int y0 = ya; y0 <= yb; y0++) {\n            int index0 = x * numchannels + y0 * w1 * numchannels;\n            double v = 1;\n            if(y0 == ya) v -= yaf;\n            if(y0 == yb) v -= (1 - ybf);\n            val += v * temp[index0 + c];\n          }\n          out[index1 + c] = val * norm;\n        }\n      }\n    }\n  } else {\n    for(int y = 0; y < h1; y++) {\n      int y0 = (int)((y + 0.5) * h0 / h1 - 0.5);\n      for (int x = 0; x < w1; x++) {\n        int x0 = (int)((x + 0.5) * w0 / w1 - 0.5);\n        int index0 = x0 * numchannels + y0 * w0 * numchannels;\n        int index1 = x * numchannels + y * w1 * numchannels;\n        for (int c = 0; c < numchannels; c++) {\n          out[index1 + c] = in[index0 + c];\n        }\n      }\n    }\n  }\n  return out;\n}\n\n/*\nShow ASCII art preview of the image\nimage is given in 16-bit big endian\n*/\nvoid displayAsciiArt(const std::vector<unsigned char>& image, unsigned w, unsigned h, unsigned asciiw) {\n  const std::vector<unsigned char>* imagep = &image;\n  std::vector<unsigned char> image2;\n  if(asciiw < w) {\n    unsigned w2 = asciiw;\n    unsigned h2 = h * w2 / w;\n    image2 = rescale(image, w, h, w2, h2, true);\n    imagep = &image2;\n    w = w2;\n    h = h2;\n  }\n  if(w > 0 && h > 0) {\n    std::cout << \"ASCII Art Preview: \" << std::endl;\n    unsigned h2 = 1 + ((h - 1) * 4) / 7; //compensate for non-square characters in terminal\n    std::cout << '+';\n    for(unsigned x = 0; x < w; x++) std::cout << '-';\n    std::cout << '+' << std::endl;\n    for(unsigned y = 0; y < h2; y++) {\n      std::cout << \"|\";\n      unsigned y2 = y * h / h2;\n      for(unsigned x = 0; x < w; x++) {\n        int r = (*imagep)[y2 * w * 8 + x * 8 + 0];\n        int g = (*imagep)[y2 * w * 8 + x * 8 + 2];\n        int b = (*imagep)[y2 * w * 8 + x * 8 + 4];\n        int a = (*imagep)[y2 * w * 8 + x * 8 + 6];\n        char symbol = RGBtoLetter(r, g, b, a, x, y, true, false);\n        std::cout << (char)symbol;\n      }\n      std::cout << \"|\";\n      std::cout << std::endl;\n    }\n    std::cout << '+';\n    for(unsigned x = 0; x < w; x++) std::cout << '-';\n    std::cout << '+' << std::endl;\n  }\n}\n\n//sixteen: print 16 bits per pixel\n//alpha: print alpha channel\n//input image ALWAYS given in 16-bit per channel RGBA\nvoid displayColorsHex(const std::vector<unsigned char>& image, unsigned w, unsigned h, bool sixteen) {\n  std::ios_base::fmtflags flags = std::cout.flags();\n\n  if(w > 0 && h > 0) {\n    std::cout << \"Colors (CSS RGBA hex format):\" << std::endl;\n\n    for(unsigned y = 0; y < h; y++) {\n      std::cout.flags(flags); //print line numbers in hex or dec whatever it originally was\n      std::cout << y << \":\";\n      for(unsigned x = 0; x < w; x++) {\n        size_t index = y * w * 8 + x * 8;\n        if (sixteen) {\n          int r = image[index + 0] * 256 + image[index + 1];\n          int g = image[index + 2] * 256 + image[index + 3];\n          int b = image[index + 4] * 256 + image[index + 5];\n          int a = image[index + 6] * 256 + image[index + 7];\n          std::cout << std::hex << std::setfill('0') << \" #\" << std::setw(4) << r << std::setw(4) << g << std::setw(4) << b << std::setw(4) << a;\n        } else {\n          int r = image[index + 0];\n          int g = image[index + 2];\n          int b = image[index + 4];\n          int a = image[index + 6];\n          std::cout << std::hex << std::setfill('0') << \" #\" << std::setw(2) << r << std::setw(2) << g << std::setw(2) << b << std::setw(2) << a;\n        }\n      }\n      std::cout << std::endl;\n    }\n  }\n\n  std::cout.flags(flags);\n}\n\n\n/*\nShow the filtertypes of each scanline in this PNG image.\n*/\nvoid displayFilterTypes(Data& data, const Options& options) {\n  std::cout << (options.use_hex ? std::hex: std::dec);\n  data.loadFile();\n  if(data.error) return;\n  const std::vector<unsigned char>& buffer = data.buffer;\n  std::vector<std::vector<unsigned char> > types;\n  unsigned error = lodepng::getFilterTypesInterlaced(types, buffer);\n  if(error) {\n    std::cout << \"Error getting filter types\" << std::endl;\n    return;\n  }\n\n  if(types.size() == 7) {\n    std::cout << \"Filter types (Adam7 interlaced):\" << std::endl;\n    for(int j = 0; j < 7; j++) {\n      std::cout << \" Pass \" << (j + 1) << \": \";\n      for(size_t i = 0; i < types[j].size(); i++) {\n        std::cout << (int)(types[j][i]);\n      }\n      std::cout << std::endl;\n    }\n  } else {\n    std::cout << \"Filter types: \";\n    for(size_t i = 0; i < types[0].size(); i++) {\n      std::cout << (int)(types[0][i]);\n    }\n    std::cout << std::endl;\n  }\n}\n\n//image type MUST be palette\nvoid displayPalette(Data& data, const Options& options) {\n  data.loadInspect();\n  if(data.error) return;\n  std::cout << (options.use_hex ? std::hex: std::dec);\n\n  const LodePNGInfo& info = data.state.info_png;\n  const LodePNGColorMode& color = info.color;\n\n  std::cout << \"Palette size: \" << color.palettesize << std::endl;\n  std::cout << \"Palette colors: \";\n  std::ios_base::fmtflags flags = std::cout.flags();\n  std::cout << std::hex << std::setfill('0');\n  for(size_t i = 0; i < color.palettesize; i++) {\n    unsigned char* p = &color.palette[i * 4];\n    std::cout << \"#\" << std::setw(2) << (int)p[0] << std::setw(2) << (int)p[1] << std::setw(2) << (int)p[2] << std::setw(2) << (int)p[3] << \" \";\n  }\n  std::cout.flags(flags);\n  std::cout << std::endl;\n}\n\n//image type MUST be palette\nvoid displayPalettePixels(const std::vector<unsigned char>& buffer, const Options& options) {\n  unsigned w, h;\n  lodepng::State state;\n  std::vector<unsigned char> out;\n  std::cout << (options.use_hex ? std::hex: std::dec);\n\n  state.decoder.color_convert = 0;\n\n  lodepng::decode(out, w, h, state, buffer);\n\n  if(state.info_png.color.colortype == LCT_PALETTE) {\n    if (options.show_color_stats) {\n      std::vector<size_t> count(256, 0);\n      size_t outofbounds = 0;\n\n      for(size_t i = 0; i < w * h; i++) {\n        int value = lodepng::getPaletteValue(&out[0], i, state.info_raw.bitdepth);\n        count[value]++;\n        if(value >= (int)state.info_raw.palettesize) outofbounds++;\n      }\n\n      std::cout << \"Palette count: \";\n      for(size_t i = 0; i < state.info_raw.palettesize; i++) {\n        std::cout << count[i] << \" \";\n      }\n      std::cout << std::endl;\n\n      if(outofbounds > 0) std::cout << \"Out of bounds palette values: \" << outofbounds << std::endl;\n    }\n\n    std::cout << \"Pixel palette indices:\" << std::endl;\n    for(size_t i = 0; i < w * h; i++) {\n      int value = lodepng::getPaletteValue(&out[0], i, state.info_raw.bitdepth);\n      std::cout << value << \", \";\n      if(i % w == w - 1) std::cout << std::endl;\n    }\n  } else {\n    std::cout << \"Pixel palette indices: not shown, not a palette image\\n\" << std::endl;\n  }\n}\n\nvoid printZlibInfo(Data& data) {\n  data.loadFile();\n  if(data.error || !data.isPng()) return;\n  const std::vector<unsigned char>& png = data.buffer;\n\n  //Read literal data from all IDAT chunks\n  const unsigned char *chunk, *begin, *end;\n  end = &png.back() + 1;\n  begin = chunk = &png.front() + 8;\n\n  std::vector<unsigned char> compressed;\n\n  while(chunk < end && end - chunk >= 8) {\n    char type[5];\n    lodepng_chunk_type(type, chunk);\n    if(std::string(type).size() != 4) {\n      std::cout << \"invalid png\" << std::endl;\n      return;\n    }\n\n    if(std::string(type) == \"IDAT\") {\n      const unsigned char* cdata = lodepng_chunk_data_const(chunk);\n      unsigned clength = lodepng_chunk_length(chunk);\n      if(chunk + clength + 12 > end || clength > png.size() || chunk + clength + 12 < begin) {\n        std::cout << \"corrupt chunk length\" << std::endl;\n        return;\n      }\n      compressed.insert(compressed.end(), cdata, cdata + clength);\n    }\n\n    chunk = lodepng_chunk_next_const(chunk, end);\n  }\n\n  if(compressed.size() >= 3) {\n    int bfinal = compressed[2] & 1;\n    int btype = (compressed[2] & 6) >> 1;\n    if(bfinal) {\n      std::cout << \"zlib data stored in a single block, btype: \" << btype << std::endl;\n    } else {\n      std::cout << \"zlib data spread over multiple blocks. First block btype: \" << btype << std::endl;\n    }\n  }\n\n  std::cout << \"zlib compressed size: \" << compressed.size() << std::endl;\n\n  //Decompress all IDAT data (if the while loop ended early, this might fail)\n  std::vector<unsigned char> uncompressed;\n  data.error = lodepng::decompress(uncompressed, compressed.empty() ? NULL : &compressed[0], compressed.size());\n  if(data.error) return;\n\n  std::cout << \"zlib uncompressed size: \" << uncompressed.size() << std::endl;\n}\n\n// returns number of unique RGBA colors in the image\n// also fills unique r, g, b, a counts in the output parameters\n// the input image is in 16-bit per channel color, so 8 chars per pixel\nsize_t countColors(std::vector<unsigned char> image, unsigned w, unsigned h,\n    size_t* ro, size_t* go, size_t* bo, size_t* ao) {\n  typedef std::pair<std::pair<unsigned short, unsigned short>, std::pair<unsigned short, unsigned short> > RGBA;\n  std::map<RGBA, size_t> rgbam;\n  //std::map<uint64_t, size_t> rgbam;\n  std::vector<unsigned char> rm(65536, 0);\n  std::vector<unsigned char> gm(65536, 0);\n  std::vector<unsigned char> bm(65536, 0);\n  std::vector<unsigned char> am(65536, 0);\n  for(unsigned y = 0; y < h; y++) {\n    for(unsigned x = 0; x < w; x++) {\n      unsigned short r = 256 * image[y * 8 * w + x * 8 + 0] + image[y * 8 * w + x * 8 + 1];\n      unsigned short g = 256 * image[y * 8 * w + x * 8 + 2] + image[y * 8 * w + x * 8 + 3];\n      unsigned short b = 256 * image[y * 8 * w + x * 8 + 4] + image[y * 8 * w + x * 8 + 5];\n      unsigned short a = 256 * image[y * 8 * w + x * 8 + 6] + image[y * 8 * w + x * 8 + 7];\n      RGBA rgba(std::make_pair(r, g), std::make_pair(b, a));\n      //uint64_t rgba = (uint64_t)r + ((uint64_t)g << 16) + ((uint64_t)b << 32) + ((uint64_t)a << 48);\n      rgbam[rgba]++;\n      rm[r] = 1;\n      gm[g] = 1;\n      bm[b] = 1;\n      am[a] = 1;\n    }\n  }\n  *ro = *go = *bo = *ao = 0;\n  for(size_t i = 0; i < rm.size(); i++) {\n    *ro += rm[i];\n    *go += gm[i];\n    *bo += bm[i];\n    *ao += am[i];\n  }\n\n  return rgbam.size();\n}\n\n\nvoid showError(Data& data, const Options& options) {\n  std::cout << (options.use_hex ? std::hex: std::dec);\n  std::string prefix = (options.use_hex ? \"0x\": \"\");\n  if(!data.error) {\n    std::cout << \"No error\" << std::endl;\n  }\n  std::cout << \"Decoding error \" << prefix << data.error << \": \" << lodepng_error_text(data.error) << std::endl;\n}\n\nvoid loadWithErrorRecovery(Data& data, const Options& options, bool show_errors_mode) {\n  (void)options;\n  unsigned& error = data.error;\n  lodepng::State& state = data.state;\n\n  data.loadPixels();\n\n  if(show_errors_mode) {\n    if(!error) std::cout << \"No errors or warnings\" << std::endl;\n    return;\n  }\n\n  // In case of checksum errors and some other ignorable errors, report it but ignore it and retry\n  while(error) {\n    // Not showing regular error here, is shown at end of program.\n    unsigned error2 = error;\n    if(error == 57) {\n      showError(data, options);\n      if(!show_errors_mode) std::cerr << \"Ignoring the error: enabling ignore_crc\" << std::endl;\n      state.decoder.ignore_crc = 1;\n      data.reloadPixels();\n    } else if(error == 58) {\n      showError(data, options);\n      if(!show_errors_mode) std::cerr << \"Ignoring the error: enabling ignore_adler32\" << std::endl;\n      state.decoder.zlibsettings.ignore_adler32 = 1;\n      data.reloadPixels();\n    } else if(error == 69) {\n      showError(data, options);\n      if(!show_errors_mode) std::cerr << \"Ignoring the error: enabling ignore_critical\" << std::endl;\n      state.decoder.ignore_critical = 1;\n      data.reloadPixels();\n    } else if(error == 30 || error == 63) {\n      showError(data, options);\n      if(!show_errors_mode) std::cerr << \"Ignoring the error: enabling ignore_end\" << std::endl;\n      state.decoder.ignore_end = 1;\n      data.reloadPixels();\n    } else {\n      showError(data, options);\n      if(!show_errors_mode) std::cerr << \"This error is unrecoverable\" << std::endl;\n      break;  // other error that we cannot ignore\n    }\n    if(!show_errors_mode) if(error == 0) std::cerr << \"Successfully ignored the error\" << std::endl;\n    if(error == error2) {\n      if(!show_errors_mode) std::cerr << \"Failed to ignore the error\" << std::endl;\n      break; // avoid infinite loop if ignoring did not fix the error code\n    }\n  }\n\n  if(show_errors_mode) {\n    if(!error) std::cout << \"The error is recoverable\" << std::endl;\n    else std::cout << \"The error is not recoverable\" << std::endl;\n  }\n}\n\nvoid showSingleLineSummary(Data& data, const Options& options) {\n  data.loadInspect();\n  if(data.error && data.error != 57) return; // CRC error (57) ignored here for parsing of header only\n  std::cout << (options.use_hex ? std::hex: std::dec);\n  std::cout << \"Filesize: \" << data.buffer.size() << \" (\" << data.buffer.size() / 1024 << \"K)\";\n  if(data.is_icc) {\n    std::cout << \", not a PNG but an ICC profile, use -i to expand ICC profile info.\" << std::endl;\n    return;\n  }\n  if(data.is_exif) {\n    std::cout << \", not a PNG but an EXIF file, use -e to expand EXIF file info.\" << std::endl;\n    return;\n  }\n\n  std::cout << \", \" << data.w << \"x\" << data.h << \", \";\n  std::cout << \"Color: \" << colorTypeString(data.state.info_png.color.colortype) << \", \" << data.state.info_png.color.bitdepth << \" bit\" << std::endl;\n}\n\nstatic unsigned getICCUint16(const unsigned char* icc, size_t size, size_t pos) {\n  if (pos + 2 > size) return 0;\n  return (unsigned)((icc[pos] << 8) | (icc[pos + 1]));\n}\n\nstatic unsigned getICCUint32(const unsigned char* icc, size_t size, size_t pos) {\n  if (pos + 4 > size) return 0;\n  return (unsigned)((icc[pos] << 24) | (icc[pos + 1] << 16) | (icc[pos + 2] << 8) | (icc[pos + 3] << 0));\n}\n\nstatic int getICCInt32(const unsigned char* icc, size_t size, size_t pos) {\n  if (pos + 4 > size) return 0;\n  return (int)((icc[pos] << 24) | (icc[pos + 1] << 16) | (icc[pos + 2] << 8) | (icc[pos + 3] << 0));\n}\n\n// Signed\nstatic float getICC15Fixed16(const unsigned char* icc, size_t size, size_t pos) {\n  return getICCInt32(icc, size, pos) / 65536.0;\n}\n\n// Unsigned\nstatic float getICC16Fixed16(const unsigned char* icc, size_t size, size_t pos) {\n  return getICCUint32(icc, size, pos) / 65536.0;\n}\n\nstatic std::string printableICCWord(const unsigned char* icc, size_t size, size_t pos) {\n  if (pos + 4 > size) {\n    return \"out of range\";\n  }\n  std::string result;\n  for (int i = 0; i < 4; i++) {\n    char c = icc[pos + i];\n    result += ((c >= 32 && c < 127) ? c : '?');\n  }\n  return result;\n}\n\nvoid printICCDetails(const unsigned char* icc, size_t size, const std::string& indent) {\n  // 128 for header, 4 for num tags\n  if(size < 132) {\n    std::cout << indent << \"Invalid ICC: too small to contain header\" << std::endl;\n    return;\n  }\n  if(printableICCWord(icc, size, 36) != \"acsp\") {\n    std::cout << indent << \"Invalid ICC: does not contain signature \\\"acsp\\\"\" << std::endl;\n    return;\n  }\n\n  std::cout << indent << \"profile size: \" << getICCUint32(icc, size, 0) << std::endl;\n  std::cout << indent << \"CMM type: \" << printableICCWord(icc, size, 4) << std::endl;\n\n  uint32_t version = getICCUint32(icc, size, 8);\n  uint16_t version_major = (version >> 24) & 255;\n  uint16_t version_minor = (version >> 20) & 15;\n  uint16_t version_bugfix = (version >> 16) & 15;\n  std::cout << indent << \"version: \" << version_major << \".\" << version_minor\n            << \".\" << version_bugfix << std::endl;\n\n  std::cout << indent << \"device class: \" << printableICCWord(icc, size, 12) << std::endl;\n  std::cout << indent << \"input space: \\\"\" << printableICCWord(icc, size, 16) << \"\\\", \";\n  std::cout << \"output space: \\\"\" << printableICCWord(icc, size, 20) << \"\\\"\" << std::endl;\n  std::cout << indent;\n  printf(\"date: %02d-%02d-%02dT%02d:%02d:%02d\\n\",\n         getICCUint16(icc, size, 24), getICCUint16(icc, size, 26), getICCUint16(icc, size, 28),\n         getICCUint16(icc, size, 30), getICCUint16(icc, size, 32), getICCUint16(icc, size, 34));\n  std::cout << indent << \"signature: \" << printableICCWord(icc, size, 36) << std::endl;\n  std::cout << indent << \"platform: \" << printableICCWord(icc, size, 40) << std::endl;\n  std::cout << indent << \"flags: \" << getICCUint32(icc, size, 44) << std::endl;\n  std::cout << indent << \"device manufacturer: \" << printableICCWord(icc, size, 48) << \", \";\n  std::cout << \"device model: \" << printableICCWord(icc, size, 52) << \", \";\n  std::cout << \"device attributes: \" << getICCUint32(icc, size, 56) << \" \"\n            << getICCUint32(icc, size, 60) << std::endl;\n  std::cout << indent << \"rendering intent: \" << getICCUint32(icc, size, 64) << std::endl;\n\n  float pcsx = getICC15Fixed16(icc, size, 68);\n  float pcsy = getICC15Fixed16(icc, size, 72);\n  float pcsz = getICC15Fixed16(icc, size, 76);\n  float pcsxyz = pcsx + pcsy + pcsz;\n  std::cout << indent << \"xyz illuminant: X:\" << pcsx << \", Y:\" << pcsy << \", Z:\" << pcsz\n            << \", xy:\" << (pcsx / pcsxyz) << \",\" << (pcsy / pcsxyz) << std::endl;\n\n  std::cout << indent << \"creator: \" << printableICCWord(icc, size, 80) << std::endl;\n\n  // The md5 is present in v2.4 and above profiles, but it's always shown anyway. Those\n  // bytes are normally all zero for older versions.\n  std::cout << indent;\n  printf(\"md5: %08x%08x%08x%08x\\n\", getICCUint32(icc, size, 84), getICCUint32(icc, size, 88),\n                                    getICCUint32(icc, size, 92), getICCUint32(icc, size, 96));\n\n  size_t numtags = getICCUint32(icc, size, 128);\n  std::cout << indent << \"num icc tags: \" << numtags << std::endl;\n  if(size < 128 + 4 + numtags * 12) {\n    std::cout << indent << \"Invalid ICC: too small to contain tag descriptions\" << std::endl;\n    return;\n  }\n  for(size_t i = 0; i < numtags; i++) {\n    size_t pos = 132 + i * 12;\n    std::cout << indent << \"icc tag: \\\"\" << printableICCWord(icc, size, pos) << \"\\\"\";\n    size_t offset = getICCUint32(icc, size, pos + 4);\n    size_t tagsize = getICCUint32(icc, size, pos + 8);\n    std::cout << \", offset: \" << offset << \", size: \" << tagsize;\n    if(offset + tagsize > size || tagsize < 4) {\n      std::cout << std::endl << indent << \"Invalid ICC: tag out of range\" << std::endl;\n      return;\n    }\n    std::string datatype = printableICCWord(icc, size, offset);\n    std::cout << \", datatype: \\\"\" << datatype << \"\\\"\";\n    if(datatype == \"XYZ \") {\n      float x = getICC15Fixed16(icc, size, offset + 8);\n      float y = getICC15Fixed16(icc, size, offset + 12);\n      float z = getICC15Fixed16(icc, size, offset + 16);\n      float xyz = x + y + z;\n      std::cout << \", X:\" << x << \", Y:\" << y << \", Z:\" << z;\n      if(xyz) std::cout << \", xy:\" << (x / xyz) << \",\" << (y / xyz);\n    }\n    if(datatype == \"curv\") {\n      size_t lutsize = getICCUint32(icc, size, offset + 8);\n      std::cout << \", lookup table size: \" << lutsize;\n      if(lutsize == 1 && offset + 14 <= size) {\n        std::cout << \" (gamma: \" << (getICCUint16(icc, size, offset + 12) / 256.0) << \")\";\n      }\n      if(lutsize == 0) std::cout << \" (linear)\";\n    }\n    if(datatype == \"para\") {\n      unsigned type = getICCUint16(icc, size, offset + 8);\n      float gamma = getICC15Fixed16(icc, size, offset + 12);\n      int numparams = (type == 4) ? 7 : ((type >= 1 && type <= 3) ? (type + 1) : 0);\n      std::cout << \" type: \" << type << \", gamma: \" <<  gamma;\n      if(numparams > 0) {\n        std::cout << \", params: \";\n        for(int j = 0; j < numparams; j++) {\n          if(j > 0) std::cout << \", \";\n          std::cout << getICC15Fixed16(icc, size, offset + 16 + j * 4);\n        }\n      }\n    }\n    if(datatype == \"sf32\") {\n      std::cout << \":\";\n      for(size_t j = 8; j < tagsize; j += 4) {\n        float v = getICC15Fixed16(icc, size, offset + j);\n        std::cout << \" \" << v;\n      }\n    }\n    if(datatype == \"chrm\") {\n      size_t numchannels = getICCUint16(icc, size, offset + 8);\n      std::cout << \": n:\" << numchannels\n                << \" phosphor:\" << getICCUint16(icc, size, offset + 10);\n      for(size_t j = 0; j < numchannels; j++) {\n        std::cout << \" xy:\" << getICC16Fixed16(icc, size, offset + 12 + j * 8)\n                  << \",\" << getICC16Fixed16(icc, size, offset + 12 + j * 8 + 4);\n      }\n    }\n    if(datatype == \"text\" || datatype == \"mluc\" || datatype == \"desc\") {\n      // TODO: this is a bit of a simplification of the parse for now, e.g.\n      // ignoring UTF-16, instead implicitely skipping non-ASCII bytes, and\n      // potentially printing things multiple times in a row if multiple\n      // variants are in desc or mluc.\n      std::cout << \": \";\n      for(size_t j = (datatype == \"mluc\" ? 28 : 8); j < tagsize; j++) {\n        char c = icc[offset + j];\n        if(c >= 32 && c < 127) std::cout << c;\n      }\n    }\n    std::cout << std::endl;\n  }\n}\n\nvoid showHex(const unsigned char* data, size_t size, const Options& options) {\n  for(size_t i = 0; i < size; i++) {\n    unsigned char c = data[i];\n    if(options.hexformat == HF_BIN) {\n      printf(\"%c\", c);\n    } else {\n      if(c > 32 && c < 127 && options.hexformat == HF_MIX) printf(\" %c \", c);\n      else printf(\"%02x \", c);\n      if(i % 32 == 31 && i + 1 != size) std::cout << std::endl;\n    }\n  }\n  if(options.hexformat != HF_BIN) std::cout << std::endl;\n}\n\nvoid showHeaderInfo(Data& data, const Options& options) {\n  data.loadInspect();\n  if(data.error) return;\n  std::cout << (options.use_hex ? std::hex: std::dec);\n\n  const LodePNGInfo& info = data.state.info_png;\n  const LodePNGColorMode& color = info.color;\n  if(options.show_header) {\n    std::cout << \"Filesize: \" << data.buffer.size() << \" (\" << data.buffer.size() / 1024 << \"K)\" << std::endl;\n    if(data.is_icc) {\n      std::cout << \"Not a PNG but an ICC profile, use -i or -I for more info.\" << std::endl;\n    } else if(data.is_exif) {\n      std::cout << \"Not a PNG but an EXIF file, use -e for more info.\" << std::endl;\n    } else {\n      std::cout << \"Width: \" << data.w << std::endl;\n      std::cout << \"Height: \" << data.h << std::endl;\n      if(options.verbose) {\n        double bpp = data.buffer.size() / (double)(data.w * data.h);\n        std::cout << \"Compressed bpp: \" << bpp << std::endl;\n      }\n      std::cout << \"Interlace method: \" << info.interlace_method << std::endl;\n      if(options.verbose) {\n        std::cout << \"Compression method: \" << info.compression_method << std::endl;\n        std::cout << \"Filter method: \" << info.filter_method << std::endl;\n      }\n      std::cout << \"Color type: \" << colorTypeString(color.colortype) << std::endl;\n      std::cout << \"Bit depth: \" << color.bitdepth << std::endl;\n      if(options.verbose) {\n        std::cout << \"Bits per pixel: \" << lodepng_get_bpp(&color) << std::endl;\n        std::cout << \"Channels per pixel: \" << lodepng_get_channels(&color) << std::endl;\n        std::cout << \"Is greyscale type: \" << lodepng_is_greyscale_type(&color) << std::endl;\n        std::cout << \"Can have alpha: \" << lodepng_can_have_alpha(&color) << std::endl;\n        std::cout << \"Has color key: \" << color.key_defined << std::endl;\n      }\n    }\n  }\n  if(options.show_png_info && data.is_png) {\n    if (color.colortype == LCT_PALETTE) {\n      std::cout << \"Palette size: \" << color.palettesize << std::endl;\n    }\n    if(color.key_defined) {\n      std::cout << \"Color key rgb: \" << color.key_r\n                << \", \" << color.key_g\n                << \", \" << color.key_b << std::endl;\n    }\n    if(info.background_defined) {\n      if(color.colortype == LCT_PALETTE) {\n        std::cout << \"Background index: \" << info.background_r << std::endl;\n      } else {\n        std::cout << \"Background rgb: \" << info.background_r\n                  << \", \" << info.background_g\n                  << \", \" << info.background_b << std::endl;\n      }\n    }\n    if(info.gama_defined) {\n      std::cout << \"gAMA defined: \" << info.gama_gamma << \" (\" << (info.gama_gamma / 100000.0)\n                << \", \" << (100000.0 / info.gama_gamma) << \")\" << std::endl;\n    }\n    if(info.chrm_defined) {\n      std::cout << \"cHRM defined: w: \" << (info.chrm_white_x / 100000.0) << \" \" << (info.chrm_white_y / 100000.0)\n                << \", r: \" << (info.chrm_red_x / 100000.0) << \" \" << (info.chrm_red_y / 100000.0)\n                << \", g: \" << (info.chrm_green_x / 100000.0) << \" \" << (info.chrm_green_y / 100000.0)\n                << \", b: \" << (info.chrm_blue_x / 100000.0) << \" \" << (info.chrm_blue_y / 100000.0)\n                << std::endl;\n    }\n    if(info.srgb_defined) {\n      std::cout << \"sRGB defined: rendering intent: \" << info.srgb_intent << std::endl;\n    }\n    if(info.iccp_defined) {\n      std::cout << \"ICC profile defined (\" << info.iccp_profile_size << \" bytes): name: \" << info.iccp_name << std::endl;\n      if(options.verbose && !options.show_icc_details && !options.show_icc_hex) {\n        std::cout << \"Use -i or -I to show ICC profile details or hex\" << std::endl;\n      }\n    }\n    if(info.exif_defined) {\n      std::cout << \"EXIF metadata defined (\" << info.exif_size << \" bytes)\" << std::endl;\n      if(options.verbose && !options.show_exif && !options.show_exif_hex) {\n        std::cout << \"Use -e or -E to show EXIF details or hex\" << std::endl;\n      }\n    }\n  }\n  if(info.iccp_defined && options.show_icc_details) {\n    if(!options.show_header) {\n      std::cout << \"ICC profile details (\" << info.iccp_profile_size << \" bytes), PNG name: \" << info.iccp_name << std::endl;\n    }\n    printICCDetails(info.iccp_profile, info.iccp_profile_size, \"  \");\n    std::cout << \"end of ICC profile\" << std::endl;\n  }\n  if(info.iccp_defined && options.show_icc_hex) {\n    showHex(info.iccp_profile, info.iccp_profile_size, options);\n  }\n  if(info.exif_defined && options.show_exif_hex) {\n    showHex(info.exif, info.exif_size, options);\n  }\n\n  if(options.show_png_info && data.is_png) {\n    if(options.verbose) std::cout << \"Physics defined: \" << info.phys_defined << std::endl;\n    if(info.phys_defined) {\n      std::cout << \"Physics: X: \" << info.phys_x << \", Y: \" << info.phys_y << \", unit: \" << info.phys_unit << std::endl;\n    }\n  }\n}\n\n// shortens the text unless options.expand_long_texts is true\nstd::string shortenText(const std::string& text, const Options& options) {\n  if(options.expand_long_texts) return text;\n  size_t maxlen = 512;\n  size_t maxnl = options.verbose ? 5 : 1;\n  size_t numnl = 0; // amount of newlines\n  for(size_t i = 0; i < text.size(); i++) {\n    if(text[i] == 10) numnl++;\n    if(numnl >= maxnl) {\n      maxlen = i;\n      break;\n    }\n  }\n\n  if(text.size() < maxlen) return text;\n\n  return text.substr(0, maxlen) + (numnl > 1 ? \"\\n\" : \"\") + \"... [TEXT SNIPPED! use -t to expand long text]\";\n}\n\n// A bit more PNG info, which is from chunks that can come after IDAT. showHeaderInfo shows most other stuff.\nvoid showPNGInfo(Data& data, const Options& options) {\n  if(!data.is_png) return;\n  loadWithErrorRecovery(data, options, false);\n  if(data.error) return;\n  std::cout << (options.use_hex ? std::hex: std::dec);\n\n  const LodePNGInfo& info = data.state.info_png;\n\n  if(options.verbose) std::cout << \"Texts: \" << info.text_num << std::endl;\n  for(size_t i = 0; i < info.text_num; i++) {\n    std::cout << \"Text (\" << (strlen(info.text_strings[i])) << \" bytes): \"\n              << info.text_keys[i] << \": \" << shortenText(info.text_strings[i], options) << std::endl;\n  }\n  if(options.verbose) std::cout << \"International texts: \" << info.itext_num << std::endl;\n  for(size_t i = 0; i < info.itext_num; i++) {\n    std::cout << \"Text (\" << (strlen(info.itext_strings[i])) << \" bytes): \"\n              << info.itext_keys[i] << \", \"\n              << info.itext_langtags[i] << \", \"\n              << info.itext_transkeys[i] << \": \"\n              << shortenText(info.itext_strings[i], options) << std::endl;\n  }\n  if(options.verbose) std::cout << \"Time defined: \" << info.time_defined << std::endl;\n  if(info.time_defined) {\n    const LodePNGTime& time = info.time;\n    printf(\"time: %02d-%02d-%02dT%02d:%02d:%02d\\n\",\n           time.year, time.month, time.day, time.hour, time.minute, time.second);\n\n  }\n}\n\nvoid showColorStats(Data& data, const Options& options) {\n  if(!data.is_png) return;\n  std::cout << (options.use_hex ? std::hex: std::dec);\n  std::vector<unsigned char>& image = data.pixels;\n  unsigned& w = data.w;\n  unsigned& h = data.h;\n\n  data.loadPixels();\n  if(data.error) return;\n  // TODO: move to show color stats function\n  if(options.verbose) std::cout << \"Num pixels: \" << w * h << std::endl;\n  size_t rc, gc, bc, ac;\n  std::cout << \"Num unique colors: \" << countColors(image, w, h, &rc, &gc, &bc, &ac);\n  std::cout << \" (r: \" << rc << \", g: \" << gc << \", b: \" << bc << \", a: \" << ac << \")\";\n  std::cout << std::endl;\n  if(w > 0 && h > 0) {\n    double avg[4] = {0, 0, 0, 0};\n    double min[4] = {999999, 999999, 999999, 999999};\n    double max[4] = {0, 0, 0, 0};\n    for(unsigned y = 0; y < h; y++) {\n      for(unsigned x = 0; x < w; x++) {\n        for(int c = 0; c < 4; c++) {\n          double v = 256 * image[y * 8 * w + x * 8 + c * 2] + image[y * 8 * w + x * 8 + c * 2 + 1];\n          avg[c] += v;\n          min[c] = std::min(min[c], v);\n          max[c] = std::max(max[c], v);\n        }\n      }\n    }\n    for(int c = 0; c < 4; c++) {\n      avg[c] /= (w * h * 257.0);\n      min[c] /= 257.0;\n      max[c] /= 257.0;\n    }\n    if(options.verbose) std::cout << \"Ranges shown as 0.0-255.0, even for 16-bit data:\" << std::endl;\n    std::cout << \"Average color: \" << avg[0] << \", \" << avg[1] << \", \" << avg[2] << \", \" << avg[3] << std::endl;\n    std::cout << \"Color ranges: \" << min[0] << \"-\" << max[0] << \", \" << min[1] << \"-\" << max[1] << \", \" << min[2] << \"-\" << max[2] << \", \" << min[3] << \"-\" << max[3] << std::endl;\n  }\n}\n\nvoid showErrors(Data& data, const Options& options) {\n  std::cout << \"Error report: \" << std::endl;\n  Data data2(data.filename);\n  loadWithErrorRecovery(data2, options, true);\n}\n\nuint32_t readExifUint32(const unsigned char* exif, size_t size, size_t pos, bool big_endian) {\n  if(pos + 4 > size) return 0;\n  if(big_endian) {\n    return ((uint32_t)exif[pos + 0] << 24u) | ((uint32_t)exif[pos + 1] << 16u) | ((uint32_t)exif[pos + 2] << 8u) | (uint32_t)exif[pos + 3];\n  } else {\n    return ((uint32_t)exif[pos + 3] << 24u) | ((uint32_t)exif[pos + 2] << 16u) | ((uint32_t)exif[pos + 1] << 8u) | (uint32_t)exif[pos + 0];\n  }\n}\n\nuint32_t readExifUint16(const unsigned char* exif, size_t size, size_t pos, bool big_endian) {\n  if(pos + 2 > size) return 0;\n  if(big_endian) {\n    return ((uint32_t)exif[pos + 0] << 8u) | (uint32_t)exif[pos + 1];\n  } else {\n    return ((uint32_t)exif[pos + 1] << 8u) | (uint32_t)exif[pos + 0];\n  }\n}\n\n\n// shows all the information from 1 IFD from the exif file. If more IFDs are linked, recursively shows those too.\nvoid showExifIFD(const unsigned char* exif, size_t size, size_t ifd_pos, bool big_endian, bool is_thumbnail, bool is_sub) {\n  size_t pos = ifd_pos;\n  size_t sub_ifd = 0;\n  if(pos + 2 > size) {\n    std::cout << \"EXIF IFD out of range: \" << pos << std::endl;\n    return;\n  }\n  size_t num_entries = readExifUint16(exif, size, pos, big_endian);\n  if(is_sub) {\n    std::cout << \"EXIF Sub-IFD at \" << pos << \", num entries: \" << num_entries << std::endl;\n  } else if(is_thumbnail) {\n    std::cout << \"EXIF Thumbnail IFD at \" << pos << \", num entries: \" << num_entries << std::endl;\n  } else {\n    std::cout << \"EXIF IFD at \" << pos << \", num entries: \" << num_entries << std::endl;\n  }\n  pos += 2;\n  for(size_t i = 0; i < num_entries; i++) {\n    if(pos + 12 > size) {\n      std::cout << \"EXIF IFD entry out of range: \" << pos << std::endl;\n      return;\n    }\n    uint32_t tag_number = readExifUint16(exif, size, pos, big_endian);\n    uint32_t format = readExifUint16(exif, size, pos + 2, big_endian);\n    uint32_t num = readExifUint32(exif, size, pos + 4, big_endian);\n    uint32_t offset = readExifUint32(exif, size, pos + 8, big_endian);\n    uint32_t component_size = 1;\n    if(format == 3 || format == 8) component_size = 2;\n    else if(format == 4 || format == 9 || format == 11) component_size = 4;\n    else if(format == 5 || format == 10 || format == 12) component_size = 8;\n    size_t len = num * component_size;\n    if(len <= 4) offset = pos + 8; // small value is stored in the offset itself\n    pos += 12;\n\n    if(format < 1 || format > 12) {\n      std::cout << \"EXIF unknown entry format\" << std::endl;\n      return;\n    }\n    if(is_thumbnail) std::cout << \"EXIF tag (thumbnail): \";\n    else std::cout << \"EXIF tag: \";\n    // Only show some common tags by full name\n    if(tag_number == 256) std::cout << \"Umage Width\";\n    else if(tag_number == 257) std::cout << \"Image Height\";\n    else if(tag_number == 259) std::cout << \"Compression\";\n    else if(tag_number == 269) std::cout << \"Document Name\";\n    else if(tag_number == 270) std::cout << \"Image Description\";\n    else if(tag_number == 274) std::cout << \"Orientation\";\n    else if(tag_number == 282) std::cout << \"X Resolution\";\n    else if(tag_number == 283) std::cout << \"Y Resolution\";\n    else if(tag_number == 296) std::cout << \"Resolution Unit\";\n    else if(tag_number == 513) std::cout << \"Thumbnail Offset\";\n    else if(tag_number == 514) std::cout << \"Thumbnail Size\";\n    else if(tag_number == 33434) std::cout << \"Exposure Time\";\n    else if(tag_number == 33432) std::cout << \"Copyright\";\n    else if(tag_number == 36864) std::cout << \"Exif Version\";\n    else if(tag_number == 37510) std::cout << \"User Comment\";\n    else std::cout << \"#\" << tag_number; // tag for which we don't show a name here\n    std::cout << \": \";\n\n    if(offset + len > size) {\n      std::cout << \"EXIF data out of range\" << std::endl;\n      return;\n    }\n    if(len == 0) {\n      std::cout << \"[empty]\" << std::endl;\n      continue;\n    }\n\n    if(format == 1) {\n      std::cout << (uint32_t)exif[offset];\n    } else if(format == 2) {\n      for(size_t j = 0; j < len; j++) {\n        if(!exif[offset + j]) break; // NULL terminator\n        std::cout << exif[offset + j];\n      }\n    } else if(format == 3) {\n      std::cout << readExifUint16(exif, size, offset, big_endian);\n    } else if(format == 4) {\n      if(tag_number == 34665) sub_ifd = readExifUint32(exif, size, offset, big_endian);\n      else std::cout << readExifUint32(exif, size, offset, big_endian);\n    } else if(format == 5) {\n      double n = readExifUint32(exif, size, offset, big_endian);\n      double d = readExifUint32(exif, size, offset + 4, big_endian);\n      std::cout << (n / d);\n    } else if(format == 7 && len > 8 && exif[offset + 0] == 'A' && exif[offset + 1] == 'S' &&\n              exif[offset + 2] == 'C' && exif[offset + 3] == 'I' && exif[offset + 4] == 'I') {\n      for(size_t j = 8; j < len; j++) std::cout << exif[offset + j];\n    } else if(format == 7 && len == 4 && tag_number == 36864) {\n      for(size_t j = 0; j < len; j++) std::cout << exif[offset + j];\n    } else if(format == 8) {\n      std::cout << (int32_t)readExifUint16(exif, size, offset, big_endian);\n    } else if(format == 9) {\n      std::cout << (int16_t)readExifUint32(exif, size, offset, big_endian);\n    } else if(format == 10) {\n      double n = (int32_t)readExifUint32(exif, size, offset, big_endian);\n      double d = (int32_t)readExifUint32(exif, size, offset + 4, big_endian);\n      std::cout << (n / d);\n    } else {\n      // Formats like double not handled here\n      std::cout << \"[format \" << format << \", len \" << len << \"]\";\n    }\n    std::cout << std::endl;\n  }\n  if(pos + 4 > size) {\n    std::cout << \"EXIF IFD footer out of range\" << std::endl;\n    return;\n  }\n  size_t next_ifd = readExifUint32(exif, size, pos, big_endian);\n\n  // The > checks are to guarantee progress rather than infinity recursion, though it does mean\n  // that an odd EXIF that places later parts earlier in the file won't be supported correctly\n  if(sub_ifd && sub_ifd > ifd_pos && sub_ifd != next_ifd) {\n    showExifIFD(exif, size, sub_ifd, big_endian, is_thumbnail, true);\n  }\n  if(next_ifd && next_ifd > ifd_pos) {\n    showExifIFD(exif, size, sub_ifd, big_endian, true, is_sub);\n  }\n}\n\n// Shows information from the EXIF chunk in the PNG, this only shows the basics\n// and some primitive values of the EXIF, it's not a complete EXIF parser but\n// shows the most common tags by name to verify the EXIF chunk handling is working.\nvoid showExif(Data& data) {\n  data.loadInspect();\n  if(data.error) return;\n  if(!data.state.info_png.exif_defined) {\n    std::cout << \"No EXIF data present in this PNG image\" << std::endl;\n    return;\n  }\n  const unsigned char* exif = data.state.info_png.exif;\n  size_t size = data.state.info_png.exif_size;\n  if(size < 8) {\n    std::cout << \"EXIF size too small: \" << size << std::endl;\n    return;\n  }\n  std::cout << \"EXIF size: \" << size << std::endl;\n  bool big_endian = exif[0] == 'M' && exif[1] == 'M' && exif[2] == 0 && exif[3] == 42;\n  bool little_endian = exif[0] == 'I' && exif[1] == 'I' && exif[2] == 42 && exif[3] == 0;\n  if(big_endian) {\n    std::cout << \"EXIF encoded using big endian (MM)\" << std::endl;\n  } else if(little_endian) {\n    std::cout << \"EXIF encoded using little endian (II)\" << std::endl;\n  } else {\n    std::cout << \"EXIF has invalid header, must start with MM or II\" << std::endl;\n    return;\n  }\n  size_t ifd = readExifUint32(exif, size, 4, big_endian);\n  showExifIFD(exif, size, ifd, big_endian, false, false);\n}\n\nvoid showRender(Data& data, const Options& options) {\n  data.loadPixels();\n  if(data.error) return;\n  if(options.rendermode == RM_ASCII) {\n    displayAsciiArt(data.pixels, data.w, data.h, options.rendersize);\n  }\n\n  if(options.rendermode == RM_HEX) {\n    displayColorsHex(data.pixels, data.w, data.h, false);\n  }\n\n  if(options.rendermode == RM_HEX16) {\n    displayColorsHex(data.pixels, data.w, data.h, true);\n  }\n\n  if(options.rendermode == RM_PAL) {\n    displayPalettePixels(data.buffer, options);\n  }\n}\n\n\nvoid showInfos(Data& data, const Options& options) {\n  if(options.show_one_line_summary) showSingleLineSummary(data, options);\n  if(options.show_errors) showErrors(data, options);\n  if(options.show_exif) showExif(data);\n  if(options.show_header || options.show_icc_details || options.show_icc_hex || options.show_exif_hex) showHeaderInfo(data, options);\n  if(options.show_color_stats) showColorStats(data, options);\n  if(options.show_png_info) showPNGInfo(data, options);\n  if(options.show_palette) displayPalette(data, options);\n  if(options.show_chunks || options.show_chunks2) displayChunkNames(data, options);\n  if(options.show_filters) displayFilterTypes(data, options);\n  if(options.show_zlib_info) printZlibInfo(data);\n  if(options.show_render) showRender(data, options);\n\n  if(data.error) showError(data, options);\n}\n\nint main(int argc, char *argv[]) {\n  Options options;\n  bool options_chosen = false;\n\n  std::vector<std::string> filenames;\n  for (int i = 1; i < argc; i++) {\n    std::string s = argv[i];\n    if(s.size() > 1 && s[0] == '-' && s[1] != '-') {\n      // anything that chooses actual set disables the defaults\n      if(s != \"-x\" && s != \"-v\" && s != \"-t\") options_chosen = true;\n      for(size_t j = 1; j < s.size(); j++) {\n        char c = s[j];\n        if(c == 'o') options.show_one_line_summary = true;\n        else if(c == 'H') options.show_header = true;\n        else if(c == 'i') options.show_icc_details = true;\n        else if(c == 'I') options.show_icc_hex = true;\n        else if(c == 'e') options.show_exif = true;\n        else if(c == 'E') options.show_exif_hex = true;\n        else if(c == 'v') options.verbose = true;\n        else if(c == 't') options.expand_long_texts = true;\n        else if(c == 's') options.show_color_stats = true;\n        else if(c == 'a') options.show_errors = true;\n        else if(c == 'p') options.show_header = options.show_png_info = true;\n        else if(c == 'r') options.show_render = true;\n        else if(c == 'l') options.show_palette = true;\n        else if(c == 'L') options.show_palette_pixels = true;\n        else if(c == 'c') options.show_chunks = true;\n        else if(c == 'C') options.show_chunks2 = true;\n        else if(c == 'f') options.show_filters = true;\n        else if(c == 'z') options.show_zlib_info = true;\n        else if(c == 'x') {\n          options.use_hex = true;\n          std::cout << std::hex;\n        } else {\n          if(s != \"--help\" && c != 'h' && c != '?') std::cout << \"Unknown flag: \" << c << \". Use -h for help\" << std::endl;\n          showHelp();\n          return 0;\n        }\n\n      }\n    } else if(s.size() > 1 && s[0] == '-' && s[1] == '-') {\n      size_t eqpos = 2;\n      while(eqpos < s.size() && s[eqpos] != '=') eqpos++;\n      std::string key = s.substr(2, eqpos - 2);\n      std::string value = (eqpos + 1) < s.size() ? s.substr(eqpos + 1) : \"\";\n      if(key == \"help\") {\n        showHelp();\n        return 0;\n      }\n      if(key == \"mode\") {\n        if(value == \"ascii\") options.rendermode = RM_ASCII;\n        else if(value == \"hex\") options.rendermode = RM_HEX;\n        else if(value == \"hex16\") options.rendermode = RM_HEX16;\n        else if(value == \"palette\") options.rendermode = RM_PAL;\n      }\n      if(key == \"size\") {\n        int size = strtoval<int>(value);\n        if(options.rendersize >= 1 && options.rendersize <= 4096) options.rendersize = size;\n      }\n      if(key == \"format\") {\n        if(value == \"mix\") options.hexformat = HF_MIX;\n        else if(value == \"hex\") options.hexformat = HF_HEX;\n        else if(value == \"bin\") options.hexformat = HF_BIN;\n      }\n    }\n    else filenames.push_back(s);\n  }\n\n  if(filenames.empty()) {\n    std::cout << \"Please provide a filename to preview\" << std::endl;\n    showHelp();\n    return 0;\n  }\n\n  if(!options_chosen) {\n    //fill in defaults\n    options.show_header = true;\n    options.show_png_info = true;\n    options.show_chunks2 = true;\n    // verbose lets individual sections show more, and in addition adds more default unlocked sections if no specific one chosen\n    if(options.verbose) {\n      options.show_chunks2 = false;\n      options.show_chunks = true;\n    }\n  }\n\n  for(size_t i = 0; i < filenames.size(); i++) {\n    if(filenames.size() > 1) {\n      if(i > 0 && !options.show_one_line_summary) std::cout << std::endl;\n      std::cout << filenames[i] << \":\";\n      if(!options.show_one_line_summary) std::cout << std::endl; else std::cout << \" \";\n    }\n    Data data(filenames[i]);\n    showInfos(data, options);\n  }\n}\n\n"
        }
      ]
    }
  ]
}