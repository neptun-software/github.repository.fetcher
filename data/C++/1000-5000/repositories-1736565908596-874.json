{
  "metadata": {
    "timestamp": 1736565908596,
    "page": 874,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zeromq/cppzmq",
      "stars": 2007,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 1.384765625,
          "content": "BasedOnStyle: LLVM\nIndentWidth: 4\nUseTab: Never\nBreakBeforeBraces: Custom\nBraceWrapping:\n    AfterClass: true\n    AfterControlStatement: false\n    AfterEnum: true\n    AfterFunction: true\n    AfterNamespace: true\n    AfterObjCDeclaration: true\n    AfterStruct: true\n    AfterUnion: true\n    BeforeCatch: true\n    BeforeElse: false\n    IndentBraces: false\n\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAllowShortIfStatementsOnASingleLine: false\nIndentCaseLabels: true\nBinPackArguments: true\nBinPackParameters: false\nAlignTrailingComments: true\nAllowShortBlocksOnASingleLine: false\nAllowAllParametersOfDeclarationOnNextLine: true\nAllowShortFunctionsOnASingleLine: InlineOnly\nAlwaysBreakTemplateDeclarations: false\nColumnLimit: 85\nMaxEmptyLinesToKeep: 2\nKeepEmptyLinesAtTheStartOfBlocks: false\nContinuationIndentWidth: 2\nPointerAlignment: Right\nReflowComments: false\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeParens: ControlStatements\nSpaceInEmptyParentheses: false\nSpacesInAngles: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard: Cpp11\n\nSortIncludes: false\n\nFixNamespaceComments: false\nBreakBeforeBinaryOperators: NonAssignment\nSpaceAfterTemplateKeyword: false\nAlignAfterOpenBracket: Align\nAlignOperands: true\nBreakConstructorInitializers: AfterColon\nConstructorInitializerAllOnOneLineOrOnePerLine: true\nSpaceAfterCStyleCast: true\nBreakBeforeTernaryOperators: true\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0478515625,
          "content": "# Vim tmp files\n*.swp\n\n# Build directory\n*build/\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 3.939453125,
          "content": "cmake_minimum_required(VERSION 3.11)\n\nlist (APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\n\ninclude (DetectCPPZMQVersion)\n\nproject(cppzmq VERSION ${DETECTED_CPPZMQ_VERSION})\n\nif (NOT TARGET libzmq AND NOT TARGET libzmq-static)\n  find_package(ZeroMQ QUIET)\n\n  # libzmq autotools install: fallback to pkg-config\n  if(NOT ZeroMQ_FOUND)\n    message(STATUS \"CMake libzmq package not found, trying again with pkg-config (normal install of zeromq)\")\n    list (APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR}/libzmq-pkg-config)\n    find_package(ZeroMQ REQUIRED)\n  endif()\n\n  # TODO \"REQUIRED\" above should already cause a fatal failure if not found, but this doesn't seem to work\n  if(NOT ZeroMQ_FOUND)\n    message(FATAL_ERROR \"ZeroMQ was not found, neither as a CMake package nor via pkg-config\")\n  endif()\n\n  if (ZeroMQ_FOUND AND NOT (TARGET libzmq OR TARGET libzmq-static))\n    message(FATAL_ERROR \"ZeroMQ version not supported!\")\n  endif()\nendif()\n\nmessage(STATUS \"cppzmq v${cppzmq_VERSION}\")\n\nset(CPPZMQ_HEADERS\n    zmq.hpp\n    zmq_addon.hpp\n)\n\nforeach (target cppzmq cppzmq-static)\n  add_library(${target} INTERFACE)\n  target_include_directories(${target} INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n                                                 $<INSTALL_INTERFACE:include>)\nendforeach()\n\ntarget_link_libraries(cppzmq INTERFACE libzmq)\ntarget_link_libraries(cppzmq-static INTERFACE libzmq-static)\n\ninclude(GNUInstallDirs)\ninclude(CMakePackageConfigHelpers)\n\ninstall(TARGETS cppzmq cppzmq-static\n        EXPORT ${PROJECT_NAME}-targets)\n\ninstall(FILES ${CPPZMQ_HEADERS}\n        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\n# GNUInstallDirs \"DATADIR\" wrong here; CMake search path wants \"share\".\nset(CPPZMQ_CMAKECONFIG_INSTALL_DIR \"share/cmake/${PROJECT_NAME}\" CACHE STRING \"install path for cppzmqConfig.cmake\")\n\nconfigure_file(libzmq-pkg-config/FindZeroMQ.cmake\n               libzmq-pkg-config/FindZeroMQ.cmake\n               COPYONLY)\n\nexport(EXPORT ${PROJECT_NAME}-targets\n     FILE \"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Targets.cmake\")\nconfigure_package_config_file(${PROJECT_NAME}Config.cmake.in\n                              \"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake\"\n                              INSTALL_DESTINATION ${CPPZMQ_CMAKECONFIG_INSTALL_DIR})\n# Workaround until ARCH_INDEPENDENT flag can be used with cmake 3.14.\n# The ConigVersion.cmake file contains checks for the architecture is was\n# generated on, which can cause problems for header only libraries\n# used with e.g. the Conan package manager. Since it is header only we\n# can/should omit those checks.\nset(CPPZMQ_SIZEOF_VOID_P ${CMAKE_SIZEOF_VOID_P})\nset(CMAKE_SIZEOF_VOID_P \"\") # a simple unset is not sufficient\nwrite_basic_package_version_file(${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake\n                                 VERSION ${CPPZMQ_VERSION}\n                                 COMPATIBILITY AnyNewerVersion)\nset(CMAKE_SIZEOF_VOID_P ${CPPZMQ_SIZEOF_VOID_P})\n\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/cppzmq.pc.in\n               ${CMAKE_CURRENT_BINARY_DIR}/cppzmq.pc @ONLY)\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/cppzmq.pc\n              DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\n\ninstall(EXPORT ${PROJECT_NAME}-targets\n        FILE ${PROJECT_NAME}Targets.cmake\n        DESTINATION ${CPPZMQ_CMAKECONFIG_INSTALL_DIR})\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake\n              ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake\n              DESTINATION ${CPPZMQ_CMAKECONFIG_INSTALL_DIR})\ninstall(FILES ${CMAKE_CURRENT_SOURCE_DIR}/libzmq-pkg-config/FindZeroMQ.cmake\n              DESTINATION ${CPPZMQ_CMAKECONFIG_INSTALL_DIR}/libzmq-pkg-config)\n\noption(CPPZMQ_BUILD_TESTS \"Whether or not to build the tests\" ON)\n\nif (CPPZMQ_BUILD_TESTS)\n    enable_testing()\n    add_subdirectory(tests)\n    if (CMAKE_CXX_STANDARD AND NOT CMAKE_CXX_STANDARD EQUAL 98 AND CMAKE_CXX_STANDARD GREATER_EQUAL 11)\n        add_subdirectory(examples)\n    endif()\nendif()\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0576171875,
          "content": "    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to\n    deal in the Software without restriction, including without limitation the\n    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n    sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n    IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.2421875,
          "content": "[![CI](https://github.com/zeromq/cppzmq/actions/workflows/ci.yml/badge.svg)](https://github.com/zeromq/cppzmq/actions)\n[![Coverage Status](https://coveralls.io/repos/github/zeromq/cppzmq/badge.svg?branch=master)](https://coveralls.io/github/zeromq/cppzmq?branch=master)\n[![License](https://img.shields.io/github/license/zeromq/cppzmq.svg)](https://github.com/zeromq/cppzmq/blob/master/LICENSE)\n\nIntroduction & Design Goals\n===========================\n\ncppzmq is a C++ binding for libzmq. It has the following design goals:\n - cppzmq maps the libzmq C API to C++ concepts. In particular:\n   - it is type-safe (the libzmq C API exposes various class-like concepts as void*)\n   - it provides exception-based error handling (the libzmq C API provides errno-based error handling)\n   - it provides RAII-style classes that automate resource management (the libzmq C API requires the user to take care to free resources explicitly)\n - cppzmq is a light-weight, header-only binding. You only need to include the header file zmq.hpp (and maybe zmq_addon.hpp) to use it.\n - zmq.hpp is meant to contain direct mappings of the abstractions provided by the libzmq C API, while zmq_addon.hpp provides additional higher-level abstractions.\n\nThere are other C++ bindings for ZeroMQ with different design goals. In particular, none of the following bindings are header-only:\n - [zmqpp](https://github.com/zeromq/zmqpp) is a high-level binding to libzmq.\n - [czmqpp](https://github.com/zeromq/czmqpp) is a binding based on the high-level czmq API.\n - [fbzmq](https://github.com/facebook/fbzmq) is a binding that integrates with Apache Thrift and provides higher-level abstractions in addition. It requires C++14.\n\nSupported platforms\n===================\n\n - Only a subset of the platforms that are supported by libzmq itself are supported. Some features already require a compiler supporting C++11. In the future, probably all features will require C++11. To build and run the tests, CMake and Catch are required.\n - Any libzmq 4.x version is expected to work. DRAFT features may only work for the most recent tested version. Currently explicitly tested libzmq versions are\n   - 4.2.0 (without DRAFT API)\n   - 4.3.4 (with and without DRAFT API)\n - Platforms with full support (i.e. CI executing build and tests)\n   - Ubuntu 18.04 x64 (with gcc 4.8.5, 5.5.0, 7.5.0)\n   - Ubuntu 20.04 x64 (with gcc 9.3.0, 10.3.0 and clang 12)\n   - Visual Studio 2017 x64\n   - Visual Studio 2019 x64\n   - macOS 10.15 (with clang 12, without DRAFT API)\n - Additional platforms that are known to work:\n   - We have no current reports on additional platforms that are known to work yet. Please add your platform here. If CI can be provided for them with a cloud-based CI service working with GitHub, you are invited to add CI, and make it possible to be included in the list above.\n - Additional platforms that probably work:\n   - Any platform supported by libzmq that provides a sufficiently recent gcc (4.8.1 or newer) or clang (3.4.1 or newer)\n   - Visual Studio 2012+ x86/x64\n\nExamples\n========\nThese examples require at least C++11.\n```c++\n#include <zmq.hpp>\n\nint main()\n{\n    zmq::context_t ctx;\n    zmq::socket_t sock(ctx, zmq::socket_type::push);\n    sock.bind(\"inproc://test\");\n    sock.send(zmq::str_buffer(\"Hello, world\"), zmq::send_flags::dontwait);\n}\n```\nThis a more complex example where we send and receive multi-part messages over TCP with a wildcard port.\n```c++\n#include <iostream>\n#include <zmq_addon.hpp>\n\nint main()\n{\n    zmq::context_t ctx;\n    zmq::socket_t sock1(ctx, zmq::socket_type::push);\n    zmq::socket_t sock2(ctx, zmq::socket_type::pull);\n    sock1.bind(\"tcp://127.0.0.1:*\");\n    const std::string last_endpoint =\n        sock1.get(zmq::sockopt::last_endpoint);\n    std::cout << \"Connecting to \"\n              << last_endpoint << std::endl;\n    sock2.connect(last_endpoint);\n\n    std::array<zmq::const_buffer, 2> send_msgs = {\n        zmq::str_buffer(\"foo\"),\n        zmq::str_buffer(\"bar!\")\n    };\n    if (!zmq::send_multipart(sock1, send_msgs))\n        return 1;\n\n    std::vector<zmq::message_t> recv_msgs;\n    const auto ret = zmq::recv_multipart(\n        sock2, std::back_inserter(recv_msgs));\n    if (!ret)\n        return 1;\n    std::cout << \"Got \" << *ret\n              << \" messages\" << std::endl;\n    return 0;\n}\n```\n\nSee the `examples` directory for more examples. When the project is compiled with tests enabled, each example gets compiled to an executable.\n\n\nAPI Overview\n============\n\nFor an extensive overview of the `zmq.hpp` API in use, see this [Tour of CPPZMQ by @brettviren](https://brettviren.github.io/cppzmq-tour/index.html).\n\nBindings for libzmq in `zmq.hpp`:\n\nTypes:\n* class `zmq::context_t`\n* enum `zmq::ctxopt`\n* class `zmq::socket_t`\n* class `zmq::socket_ref`\n* enum `zmq::socket_type`\n* enum `zmq::sockopt`\n* enum `zmq::send_flags`\n* enum `zmq::recv_flags`\n* class `zmq::message_t`\n* class `zmq::const_buffer`\n* class `zmq::mutable_buffer`\n* struct `zmq::recv_buffer_size`\n* alias `zmq::send_result_t`\n* alias `zmq::recv_result_t`\n* alias `zmq::recv_buffer_result_t`\n* class `zmq::error_t`\n* class `zmq::monitor_t`\n* struct `zmq_event_t`,\n* alias `zmq::free_fn`,\n* alias `zmq::pollitem_t`,\n* alias `zmq::fd_t`\n* class `zmq::poller_t` DRAFT\n* enum `zmq::event_flags` DRAFT\n* enum `zmq::poller_event` DRAFT\n\nFunctions:\n* `zmq::version`\n* `zmq::poll`\n* `zmq::proxy`\n* `zmq::proxy_steerable`\n* `zmq::buffer`\n* `zmq::str_buffer`\n\nExtra high-level types and functions `zmq_addon.hpp`:\n\nTypes:\n* class `zmq::multipart_t`\n* class `zmq::active_poller_t` DRAFT\n\nFunctions:\n* `zmq::recv_multipart`\n* `zmq::send_multipart`\n* `zmq::send_multipart_n`\n* `zmq::encode`\n* `zmq::decode`\n\nCompatibility Guidelines\n========================\n\nThe users of cppzmq are expected to follow the guidelines below to ensure not to break when upgrading cppzmq to newer versions (non-exhaustive list):\n\n* Do not depend on any macros defined in cppzmq unless explicitly declared public here.\n\nThe following macros may be used by consumers of cppzmq: `CPPZMQ_VERSION`, `CPPZMQ_VERSION_MAJOR`, `CPPZMQ_VERSION_MINOR`, `CPPZMQ_VERSION_PATCH`.\n\nContribution policy\n===================\n\nThe contribution policy is at: http://rfc.zeromq.org/spec:22\n\nBuild instructions\n==================\n\nBuild steps:\n\n1. Build [libzmq](https://github.com/zeromq/libzmq) via cmake. This does an out of source build and installs the build files\n   - download and unzip the lib, cd to directory\n   - mkdir build\n   - cd build\n   - cmake ..\n   - sudo make -j4 install\n\n2. Build cppzmq via cmake. This does an out of source build and installs the build files\n   - download and unzip the lib, cd to directory\n   - mkdir build\n   - cd build\n   - cmake ..\n   - sudo make -j4 install\n\n3. Build cppzmq via [vcpkg](https://github.com/Microsoft/vcpkg/). This does an out of source build and installs the build files\n   - git clone https://github.com/Microsoft/vcpkg.git\n   - cd vcpkg\n   - ./bootstrap-vcpkg.sh # bootstrap-vcpkg.bat for Powershell\n   - ./vcpkg integrate install\n   - ./vcpkg install cppzmq\n\nUsing this:\n\nA cmake find package scripts is provided for you to easily include this library.\nAdd these lines in your CMakeLists.txt to include the headers and library files of\ncpp zmq (which will also include libzmq for you).\n\n```\n#find cppzmq wrapper, installed by make of cppzmq\nfind_package(cppzmq)\ntarget_link_libraries(*Your Project Name* cppzmq)\n```\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "cppzmq.pc.in",
          "type": "blob",
          "size": 0.2578125,
          "content": "prefix=\"@CMAKE_INSTALL_PREFIX@\"\nincludedir=\"@CMAKE_INSTALL_FULL_INCLUDEDIR@\"\n\nName: @PROJECT_NAME@\nDescription: C++ binding for libzmq\nURL: https://github.com/zeromq/cppzmq\nVersion: @PROJECT_VERSION@\nRequires: libzmq\nCflags: -I\"${includedir}\" @pkg_config_defines@\n"
        },
        {
          "name": "cppzmqConfig.cmake.in",
          "type": "blob",
          "size": 0.9345703125,
          "content": "# cppzmq cmake module\n#\n# The following import targets are created\n#\n# ::\n#\n#   cppzmq-static\n#   cppzmq\n#\n# This module sets the following variables in your project::\n#\n# cppzmq_FOUND - true if cppzmq found on the system\n# cppzmq_INCLUDE_DIR - the directory containing cppzmq headers\n# cppzmq_LIBRARY - the ZeroMQ library for dynamic linking\n# cppzmq_STATIC_LIBRARY - the ZeroMQ library for static linking\n\n@PACKAGE_INIT@\n\ninclude(CMakeFindDependencyMacro)\nfind_package(ZeroMQ QUIET)\n\n# libzmq autotools install: fallback to pkg-config\nif(NOT ZeroMQ_FOUND)\n    list (APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR}/libzmq-pkg-config)\n    find_package(ZeroMQ REQUIRED)\nendif()\n\nif(NOT ZeroMQ_FOUND)\n    message(FATAL_ERROR \"ZeroMQ was NOT found!\")\nendif()\n\nif(NOT TARGET @PROJECT_NAME@)\n    include(\"${CMAKE_CURRENT_LIST_DIR}/@PROJECT_NAME@Targets.cmake\")\n    get_target_property(@PROJECT_NAME@_INCLUDE_DIR cppzmq INTERFACE_INCLUDE_DIRECTORIES)\nendif()\n\n"
        },
        {
          "name": "demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "libzmq-pkg-config",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.sh",
          "type": "blob",
          "size": 0.7041015625,
          "content": "#!/bin/sh\n#\n# This script extracts the 0MQ version from zmq.hpp, which is the master\n# location for this information.\n#\nif [ ! -f zmq.hpp ]; then\n    echo \"version.sh: error: zmq.hpp does not exist\" 1>&2\n    exit 1\nfi\nMAJOR=$(grep '^#define CPPZMQ_VERSION_MAJOR \\+[0-9]\\+' zmq.hpp)\nMINOR=$(grep '^#define CPPZMQ_VERSION_MINOR \\+[0-9]\\+' zmq.hpp)\nPATCH=$(grep '^#define CPPZMQ_VERSION_PATCH \\+[0-9]\\+' zmq.hpp)\nif [ -z \"$MAJOR\" -o -z \"$MINOR\" -o -z \"$PATCH\" ]; then\n    echo \"version.sh: error: could not extract version from zmq.hpp\" 1>&2\n    exit 1\nfi\nMAJOR=$(echo $MAJOR | awk '{ print $3 }')\nMINOR=$(echo $MINOR | awk '{ print $3 }')\nPATCH=$(echo $PATCH | awk '{ print $3 }')\necho $MAJOR.$MINOR.$PATCH | tr -d '\\n\\r'\n\n"
        },
        {
          "name": "zmq.hpp",
          "type": "blob",
          "size": 79.173828125,
          "content": "/*\n    Copyright (c) 2016-2017 ZeroMQ community\n    Copyright (c) 2009-2011 250bpm s.r.o.\n    Copyright (c) 2011 Botond Ballo\n    Copyright (c) 2007-2009 iMatix Corporation\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to\n    deal in the Software without restriction, including without limitation the\n    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n    sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n    IN THE SOFTWARE.\n*/\n\n#ifndef __ZMQ_HPP_INCLUDED__\n#define __ZMQ_HPP_INCLUDED__\n\n#ifdef _WIN32\n#ifndef NOMINMAX\n#define NOMINMAX\n#endif\n#endif\n\n// included here for _HAS_CXX* macros\n#include <zmq.h>\n\n#if defined(_MSVC_LANG)\n#define CPPZMQ_LANG _MSVC_LANG\n#else\n#define CPPZMQ_LANG __cplusplus\n#endif\n// overwrite if specific language macros indicate higher version\n#if defined(_HAS_CXX14) && _HAS_CXX14 && CPPZMQ_LANG < 201402L\n#undef CPPZMQ_LANG\n#define CPPZMQ_LANG 201402L\n#endif\n#if defined(_HAS_CXX17) && _HAS_CXX17 && CPPZMQ_LANG < 201703L\n#undef CPPZMQ_LANG\n#define CPPZMQ_LANG 201703L\n#endif\n\n// macros defined if has a specific standard or greater\n#if CPPZMQ_LANG >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1900)\n#define ZMQ_CPP11\n#endif\n#if CPPZMQ_LANG >= 201402L\n#define ZMQ_CPP14\n#endif\n#if CPPZMQ_LANG >= 201703L\n#define ZMQ_CPP17\n#endif\n\n#if defined(ZMQ_CPP14) && !defined(_MSC_VER)\n#define ZMQ_DEPRECATED(msg) [[deprecated(msg)]]\n#elif defined(_MSC_VER)\n#define ZMQ_DEPRECATED(msg) __declspec(deprecated(msg))\n#elif defined(__GNUC__)\n#define ZMQ_DEPRECATED(msg) __attribute__((deprecated(msg)))\n#else\n#define ZMQ_DEPRECATED(msg)\n#endif\n\n#if defined(ZMQ_CPP17)\n#define ZMQ_NODISCARD [[nodiscard]]\n#else\n#define ZMQ_NODISCARD\n#endif\n\n#if defined(ZMQ_CPP11)\n#define ZMQ_NOTHROW noexcept\n#define ZMQ_EXPLICIT explicit\n#define ZMQ_OVERRIDE override\n#define ZMQ_NULLPTR nullptr\n#define ZMQ_CONSTEXPR_FN constexpr\n#define ZMQ_CONSTEXPR_VAR constexpr\n#define ZMQ_CPP11_DEPRECATED(msg) ZMQ_DEPRECATED(msg)\n#else\n#define ZMQ_NOTHROW throw()\n#define ZMQ_EXPLICIT\n#define ZMQ_OVERRIDE\n#define ZMQ_NULLPTR 0\n#define ZMQ_CONSTEXPR_FN\n#define ZMQ_CONSTEXPR_VAR const\n#define ZMQ_CPP11_DEPRECATED(msg)\n#endif\n#if defined(ZMQ_CPP14) && (!defined(_MSC_VER) || _MSC_VER > 1900) && (!defined(__GNUC__) || __GNUC__ > 5 || (__GNUC__ == 5 && __GNUC_MINOR__ > 3))\n#define ZMQ_EXTENDED_CONSTEXPR\n#endif\n#if defined(ZMQ_CPP17)\n#define ZMQ_INLINE_VAR inline\n#define ZMQ_CONSTEXPR_IF constexpr\n#else\n#define ZMQ_INLINE_VAR\n#define ZMQ_CONSTEXPR_IF\n#endif\n\n#include <cassert>\n#include <cstring>\n\n#include <type_traits>\n#include <algorithm>\n#include <exception>\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <vector>\n#ifdef ZMQ_CPP11\n#include <array>\n#include <chrono>\n#include <tuple>\n#include <memory>\n#endif\n\n#if defined(__has_include) && defined(ZMQ_CPP17)\n#define CPPZMQ_HAS_INCLUDE_CPP17(X) __has_include(X)\n#else\n#define CPPZMQ_HAS_INCLUDE_CPP17(X) 0\n#endif\n\n#if CPPZMQ_HAS_INCLUDE_CPP17(<optional>) && !defined(CPPZMQ_HAS_OPTIONAL)\n#define CPPZMQ_HAS_OPTIONAL 1\n#endif\n#ifndef CPPZMQ_HAS_OPTIONAL\n#define CPPZMQ_HAS_OPTIONAL 0\n#elif CPPZMQ_HAS_OPTIONAL\n#include <optional>\n#endif\n\n#if CPPZMQ_HAS_INCLUDE_CPP17(<string_view>) && !defined(CPPZMQ_HAS_STRING_VIEW)\n#define CPPZMQ_HAS_STRING_VIEW 1\n#endif\n#ifndef CPPZMQ_HAS_STRING_VIEW\n#define CPPZMQ_HAS_STRING_VIEW 0\n#elif CPPZMQ_HAS_STRING_VIEW\n#include <string_view>\n#endif\n\n/*  Version macros for compile-time API version detection                     */\n#define CPPZMQ_VERSION_MAJOR 4\n#define CPPZMQ_VERSION_MINOR 10\n#define CPPZMQ_VERSION_PATCH 0\n\n#define CPPZMQ_VERSION                                                              \\\n    ZMQ_MAKE_VERSION(CPPZMQ_VERSION_MAJOR, CPPZMQ_VERSION_MINOR,                    \\\n                     CPPZMQ_VERSION_PATCH)\n\n//  Detect whether the compiler supports C++11 rvalue references.\n#if (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 2))   \\\n     && defined(__GXX_EXPERIMENTAL_CXX0X__))\n#define ZMQ_HAS_RVALUE_REFS\n#define ZMQ_DELETED_FUNCTION = delete\n#elif defined(__clang__)\n#if __has_feature(cxx_rvalue_references)\n#define ZMQ_HAS_RVALUE_REFS\n#endif\n\n#if __has_feature(cxx_deleted_functions)\n#define ZMQ_DELETED_FUNCTION = delete\n#else\n#define ZMQ_DELETED_FUNCTION\n#endif\n#elif defined(_MSC_VER) && (_MSC_VER >= 1900)\n#define ZMQ_HAS_RVALUE_REFS\n#define ZMQ_DELETED_FUNCTION = delete\n#elif defined(_MSC_VER) && (_MSC_VER >= 1600)\n#define ZMQ_HAS_RVALUE_REFS\n#define ZMQ_DELETED_FUNCTION\n#else\n#define ZMQ_DELETED_FUNCTION\n#endif\n\n#if defined(ZMQ_CPP11) && !defined(__llvm__) && !defined(__INTEL_COMPILER)          \\\n  && defined(__GNUC__) && __GNUC__ < 5\n#define ZMQ_CPP11_PARTIAL\n#elif defined(__GLIBCXX__) && __GLIBCXX__ < 20160805\n//the date here is the last date of gcc 4.9.4, which\n// effectively means libstdc++ from gcc 5.5 and higher won't trigger this branch\n#define ZMQ_CPP11_PARTIAL\n#endif\n\n#ifdef ZMQ_CPP11\n#ifdef ZMQ_CPP11_PARTIAL\n#define ZMQ_IS_TRIVIALLY_COPYABLE(T) __has_trivial_copy(T)\n#else\n#include <type_traits>\n#define ZMQ_IS_TRIVIALLY_COPYABLE(T) std::is_trivially_copyable<T>::value\n#endif\n#endif\n\n#if ZMQ_VERSION >= ZMQ_MAKE_VERSION(3, 3, 0)\n#define ZMQ_NEW_MONITOR_EVENT_LAYOUT\n#endif\n\n#if ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 1, 0)\n#define ZMQ_HAS_PROXY_STEERABLE\n/*  Socket event data  */\ntypedef struct\n{\n    uint16_t event; // id of the event as bitfield\n    int32_t value;  // value is either error code, fd or reconnect interval\n} zmq_event_t;\n#endif\n\n// Avoid using deprecated message receive function when possible\n#if ZMQ_VERSION < ZMQ_MAKE_VERSION(3, 2, 0)\n#define zmq_msg_recv(msg, socket, flags) zmq_recvmsg(socket, msg, flags)\n#endif\n\n\n// In order to prevent unused variable warnings when building in non-debug\n// mode use this macro to make assertions.\n#ifndef NDEBUG\n#define ZMQ_ASSERT(expression) assert(expression)\n#else\n#define ZMQ_ASSERT(expression) (void) (expression)\n#endif\n\nnamespace zmq\n{\n#ifdef ZMQ_CPP11\nnamespace detail\n{\nnamespace ranges\n{\nusing std::begin;\nusing std::end;\ntemplate<class T> auto begin(T &&r) -> decltype(begin(std::forward<T>(r)))\n{\n    return begin(std::forward<T>(r));\n}\ntemplate<class T> auto end(T &&r) -> decltype(end(std::forward<T>(r)))\n{\n    return end(std::forward<T>(r));\n}\n} // namespace ranges\n\ntemplate<class T> using void_t = void;\n\ntemplate<class Iter>\nusing iter_value_t = typename std::iterator_traits<Iter>::value_type;\n\ntemplate<class Range>\nusing range_iter_t = decltype(\n  ranges::begin(std::declval<typename std::remove_reference<Range>::type &>()));\n\ntemplate<class Range> using range_value_t = iter_value_t<range_iter_t<Range>>;\n\ntemplate<class T, class = void> struct is_range : std::false_type\n{\n};\n\ntemplate<class T>\nstruct is_range<\n  T,\n  void_t<decltype(\n    ranges::begin(std::declval<typename std::remove_reference<T>::type &>())\n    == ranges::end(std::declval<typename std::remove_reference<T>::type &>()))>>\n    : std::true_type\n{\n};\n\n} // namespace detail\n#endif\n\ntypedef zmq_free_fn free_fn;\ntypedef zmq_pollitem_t pollitem_t;\n\n// duplicate definition from libzmq 4.3.3\n#if defined _WIN32\n#if defined _WIN64\ntypedef unsigned __int64 fd_t;\n#else\ntypedef unsigned int fd_t;\n#endif\n#else\ntypedef int fd_t;\n#endif\n\nclass error_t : public std::exception\n{\n  public:\n    error_t() ZMQ_NOTHROW : errnum(zmq_errno()) {}\n    explicit error_t(int err) ZMQ_NOTHROW : errnum(err) {}\n    virtual const char *what() const ZMQ_NOTHROW ZMQ_OVERRIDE\n    {\n        return zmq_strerror(errnum);\n    }\n    int num() const ZMQ_NOTHROW { return errnum; }\n\n  private:\n    int errnum;\n};\n\nnamespace detail {\ninline int poll(zmq_pollitem_t *items_, size_t nitems_, long timeout_)\n{\n    int rc = zmq_poll(items_, static_cast<int>(nitems_), timeout_);\n    if (rc < 0)\n        throw error_t();\n    return rc;\n}\n}\n\n#ifdef ZMQ_CPP11\nZMQ_DEPRECATED(\"from 4.8.0, use poll taking std::chrono::duration instead of long\")\ninline int poll(zmq_pollitem_t *items_, size_t nitems_, long timeout_)\n#else\ninline int poll(zmq_pollitem_t *items_, size_t nitems_, long timeout_ = -1)\n#endif\n{\n    return detail::poll(items_, nitems_, timeout_);\n}\n\nZMQ_DEPRECATED(\"from 4.3.1, use poll taking non-const items\")\ninline int poll(zmq_pollitem_t const *items_, size_t nitems_, long timeout_ = -1)\n{\n    return detail::poll(const_cast<zmq_pollitem_t *>(items_), nitems_, timeout_);\n}\n\n#ifdef ZMQ_CPP11\nZMQ_DEPRECATED(\"from 4.3.1, use poll taking non-const items\")\ninline int\npoll(zmq_pollitem_t const *items, size_t nitems, std::chrono::milliseconds timeout)\n{\n    return detail::poll(const_cast<zmq_pollitem_t *>(items), nitems,\n                static_cast<long>(timeout.count()));\n}\n\nZMQ_DEPRECATED(\"from 4.3.1, use poll taking non-const items\")\ninline int poll(std::vector<zmq_pollitem_t> const &items,\n                std::chrono::milliseconds timeout)\n{\n    return detail::poll(const_cast<zmq_pollitem_t *>(items.data()), items.size(),\n                static_cast<long>(timeout.count()));\n}\n\nZMQ_DEPRECATED(\"from 4.3.1, use poll taking non-const items\")\ninline int poll(std::vector<zmq_pollitem_t> const &items, long timeout_ = -1)\n{\n    return detail::poll(const_cast<zmq_pollitem_t *>(items.data()), items.size(), timeout_);\n}\n\ninline int\npoll(zmq_pollitem_t *items, size_t nitems, std::chrono::milliseconds timeout = std::chrono::milliseconds{-1})\n{\n    return detail::poll(items, nitems, static_cast<long>(timeout.count()));\n}\n\ninline int poll(std::vector<zmq_pollitem_t> &items,\n                std::chrono::milliseconds timeout = std::chrono::milliseconds{-1})\n{\n    return detail::poll(items.data(), items.size(), static_cast<long>(timeout.count()));\n}\n\nZMQ_DEPRECATED(\"from 4.3.1, use poll taking std::chrono::duration instead of long\")\ninline int poll(std::vector<zmq_pollitem_t> &items, long timeout_)\n{\n    return detail::poll(items.data(), items.size(), timeout_);\n}\n\ntemplate<std::size_t SIZE>\ninline int poll(std::array<zmq_pollitem_t, SIZE> &items,\n                std::chrono::milliseconds timeout = std::chrono::milliseconds{-1})\n{\n    return detail::poll(items.data(), items.size(), static_cast<long>(timeout.count()));\n}\n#endif\n\n\ninline void version(int *major_, int *minor_, int *patch_)\n{\n    zmq_version(major_, minor_, patch_);\n}\n\n#ifdef ZMQ_CPP11\ninline std::tuple<int, int, int> version()\n{\n    std::tuple<int, int, int> v;\n    zmq_version(&std::get<0>(v), &std::get<1>(v), &std::get<2>(v));\n    return v;\n}\n\n#if !defined(ZMQ_CPP11_PARTIAL)\nnamespace detail\n{\ntemplate<class T> struct is_char_type\n{\n    // true if character type for string literals in C++11\n    static constexpr bool value =\n      std::is_same<T, char>::value || std::is_same<T, wchar_t>::value\n      || std::is_same<T, char16_t>::value || std::is_same<T, char32_t>::value;\n};\n}\n#endif\n\n#endif\n\nclass message_t\n{\n  public:\n    message_t() ZMQ_NOTHROW\n    {\n        int rc = zmq_msg_init(&msg);\n        ZMQ_ASSERT(rc == 0);\n    }\n\n    explicit message_t(size_t size_)\n    {\n        int rc = zmq_msg_init_size(&msg, size_);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    template<class ForwardIter> message_t(ForwardIter first, ForwardIter last)\n    {\n        typedef typename std::iterator_traits<ForwardIter>::value_type value_t;\n\n        assert(std::distance(first, last) >= 0);\n        size_t const size_ =\n          static_cast<size_t>(std::distance(first, last)) * sizeof(value_t);\n        int const rc = zmq_msg_init_size(&msg, size_);\n        if (rc != 0)\n            throw error_t();\n        std::copy(first, last, data<value_t>());\n    }\n\n    message_t(const void *data_, size_t size_)\n    {\n        int rc = zmq_msg_init_size(&msg, size_);\n        if (rc != 0)\n            throw error_t();\n        if (size_) {\n            // this constructor allows (nullptr, 0),\n            // memcpy with a null pointer is UB\n            memcpy(data(), data_, size_);\n        }\n    }\n\n    message_t(void *data_, size_t size_, free_fn *ffn_, void *hint_ = ZMQ_NULLPTR)\n    {\n        int rc = zmq_msg_init_data(&msg, data_, size_, ffn_, hint_);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    // overload set of string-like types and generic containers\n#if defined(ZMQ_CPP11) && !defined(ZMQ_CPP11_PARTIAL)\n    // NOTE this constructor will include the null terminator\n    // when called with a string literal.\n    // An overload taking const char* can not be added because\n    // it would be preferred over this function and break compatiblity.\n    template<\n      class Char,\n      size_t N,\n      typename = typename std::enable_if<detail::is_char_type<Char>::value>::type>\n    ZMQ_DEPRECATED(\"from 4.7.0, use constructors taking iterators, (pointer, size) \"\n                   \"or strings instead\")\n    explicit message_t(const Char (&data)[N]) :\n        message_t(detail::ranges::begin(data), detail::ranges::end(data))\n    {\n    }\n\n    template<class Range,\n             typename = typename std::enable_if<\n               detail::is_range<Range>::value\n               && ZMQ_IS_TRIVIALLY_COPYABLE(detail::range_value_t<Range>)\n               && !detail::is_char_type<detail::range_value_t<Range>>::value\n               && !std::is_same<Range, message_t>::value>::type>\n    explicit message_t(const Range &rng) :\n        message_t(detail::ranges::begin(rng), detail::ranges::end(rng))\n    {\n    }\n\n    explicit message_t(const std::string &str) : message_t(str.data(), str.size()) {}\n\n#if CPPZMQ_HAS_STRING_VIEW\n    explicit message_t(std::string_view str) : message_t(str.data(), str.size()) {}\n#endif\n\n#endif\n\n#ifdef ZMQ_HAS_RVALUE_REFS\n    message_t(message_t &&rhs) ZMQ_NOTHROW : msg(rhs.msg)\n    {\n        int rc = zmq_msg_init(&rhs.msg);\n        ZMQ_ASSERT(rc == 0);\n    }\n\n    message_t &operator=(message_t &&rhs) ZMQ_NOTHROW\n    {\n        std::swap(msg, rhs.msg);\n        return *this;\n    }\n#endif\n\n    ~message_t() ZMQ_NOTHROW\n    {\n        int rc = zmq_msg_close(&msg);\n        ZMQ_ASSERT(rc == 0);\n    }\n\n    void rebuild()\n    {\n        int rc = zmq_msg_close(&msg);\n        if (rc != 0)\n            throw error_t();\n        rc = zmq_msg_init(&msg);\n        ZMQ_ASSERT(rc == 0);\n    }\n\n    void rebuild(size_t size_)\n    {\n        int rc = zmq_msg_close(&msg);\n        if (rc != 0)\n            throw error_t();\n        rc = zmq_msg_init_size(&msg, size_);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    void rebuild(const void *data_, size_t size_)\n    {\n        int rc = zmq_msg_close(&msg);\n        if (rc != 0)\n            throw error_t();\n        rc = zmq_msg_init_size(&msg, size_);\n        if (rc != 0)\n            throw error_t();\n        memcpy(data(), data_, size_);\n    }\n    \n    void rebuild(const std::string &str)\n    {\n        rebuild(str.data(), str.size());\n    }\n\n    void rebuild(void *data_, size_t size_, free_fn *ffn_, void *hint_ = ZMQ_NULLPTR)\n    {\n        int rc = zmq_msg_close(&msg);\n        if (rc != 0)\n            throw error_t();\n        rc = zmq_msg_init_data(&msg, data_, size_, ffn_, hint_);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    ZMQ_DEPRECATED(\"from 4.3.1, use move taking non-const reference instead\")\n    void move(message_t const *msg_)\n    {\n        int rc = zmq_msg_move(&msg, const_cast<zmq_msg_t *>(msg_->handle()));\n        if (rc != 0)\n            throw error_t();\n    }\n\n    void move(message_t &msg_)\n    {\n        int rc = zmq_msg_move(&msg, msg_.handle());\n        if (rc != 0)\n            throw error_t();\n    }\n\n    ZMQ_DEPRECATED(\"from 4.3.1, use copy taking non-const reference instead\")\n    void copy(message_t const *msg_)\n    {\n        int rc = zmq_msg_copy(&msg, const_cast<zmq_msg_t *>(msg_->handle()));\n        if (rc != 0)\n            throw error_t();\n    }\n\n    void copy(message_t &msg_)\n    {\n        int rc = zmq_msg_copy(&msg, msg_.handle());\n        if (rc != 0)\n            throw error_t();\n    }\n\n    bool more() const ZMQ_NOTHROW\n    {\n        int rc = zmq_msg_more(const_cast<zmq_msg_t *>(&msg));\n        return rc != 0;\n    }\n\n    void *data() ZMQ_NOTHROW { return zmq_msg_data(&msg); }\n\n    const void *data() const ZMQ_NOTHROW\n    {\n        return zmq_msg_data(const_cast<zmq_msg_t *>(&msg));\n    }\n\n    size_t size() const ZMQ_NOTHROW\n    {\n        return zmq_msg_size(const_cast<zmq_msg_t *>(&msg));\n    }\n\n    ZMQ_NODISCARD bool empty() const ZMQ_NOTHROW { return size() == 0u; }\n\n    template<typename T> T *data() ZMQ_NOTHROW { return static_cast<T *>(data()); }\n\n    template<typename T> T const *data() const ZMQ_NOTHROW\n    {\n        return static_cast<T const *>(data());\n    }\n\n    ZMQ_DEPRECATED(\"from 4.3.0, use operator== instead\")\n    bool equal(const message_t *other) const ZMQ_NOTHROW { return *this == *other; }\n\n    bool operator==(const message_t &other) const ZMQ_NOTHROW\n    {\n        const size_t my_size = size();\n        return my_size == other.size() && 0 == memcmp(data(), other.data(), my_size);\n    }\n\n    bool operator!=(const message_t &other) const ZMQ_NOTHROW\n    {\n        return !(*this == other);\n    }\n\n#if ZMQ_VERSION >= ZMQ_MAKE_VERSION(3, 2, 0)\n    int get(int property_)\n    {\n        int value = zmq_msg_get(&msg, property_);\n        if (value == -1)\n            throw error_t();\n        return value;\n    }\n#endif\n\n#if ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 1, 0)\n    const char *gets(const char *property_)\n    {\n        const char *value = zmq_msg_gets(&msg, property_);\n        if (value == ZMQ_NULLPTR)\n            throw error_t();\n        return value;\n    }\n#endif\n\n#if defined(ZMQ_BUILD_DRAFT_API) && ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 2, 0)\n    uint32_t routing_id() const\n    {\n        return zmq_msg_routing_id(const_cast<zmq_msg_t *>(&msg));\n    }\n\n    void set_routing_id(uint32_t routing_id)\n    {\n        int rc = zmq_msg_set_routing_id(&msg, routing_id);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    const char *group() const\n    {\n        return zmq_msg_group(const_cast<zmq_msg_t *>(&msg));\n    }\n\n    void set_group(const char *group)\n    {\n        int rc = zmq_msg_set_group(&msg, group);\n        if (rc != 0)\n            throw error_t();\n    }\n#endif\n\n    // interpret message content as a string\n    std::string to_string() const\n    {\n        return std::string(static_cast<const char *>(data()), size());\n    }\n#if CPPZMQ_HAS_STRING_VIEW\n    // interpret message content as a string\n    std::string_view to_string_view() const noexcept\n    {\n        return std::string_view(static_cast<const char *>(data()), size());\n    }\n#endif\n\n    /** Dump content to string for debugging.\n    *   Ascii chars are readable, the rest is printed as hex.\n    *   Probably ridiculously slow.\n    *   Use to_string() or to_string_view() for\n    *   interpreting the message as a string.\n    */\n    std::string str() const\n    {\n        // Partly mutuated from the same method in zmq::multipart_t\n        std::stringstream os;\n\n        const unsigned char *msg_data = this->data<unsigned char>();\n        unsigned char byte;\n        size_t size = this->size();\n        int is_ascii[2] = {0, 0};\n\n        os << \"zmq::message_t [size \" << std::dec << std::setw(3)\n           << std::setfill('0') << size << \"] (\";\n        // Totally arbitrary\n        if (size >= 1000) {\n            os << \"... too big to print)\";\n        } else {\n            while (size--) {\n                byte = *msg_data++;\n\n                is_ascii[1] = (byte >= 32 && byte < 127);\n                if (is_ascii[1] != is_ascii[0])\n                    os << \" \"; // Separate text/non text\n\n                if (is_ascii[1]) {\n                    os << byte;\n                } else {\n                    os << std::hex << std::uppercase << std::setw(2)\n                       << std::setfill('0') << static_cast<short>(byte);\n                }\n                is_ascii[0] = is_ascii[1];\n            }\n            os << \")\";\n        }\n        return os.str();\n    }\n\n    void swap(message_t &other) ZMQ_NOTHROW\n    {\n        // this assumes zmq::msg_t from libzmq is trivially relocatable\n        std::swap(msg, other.msg);\n    }\n\n    ZMQ_NODISCARD zmq_msg_t *handle() ZMQ_NOTHROW { return &msg; }\n    ZMQ_NODISCARD const zmq_msg_t *handle() const ZMQ_NOTHROW { return &msg; }\n\n  private:\n    //  The underlying message\n    zmq_msg_t msg;\n\n    //  Disable implicit message copying, so that users won't use shared\n    //  messages (less efficient) without being aware of the fact.\n    message_t(const message_t &) ZMQ_DELETED_FUNCTION;\n    void operator=(const message_t &) ZMQ_DELETED_FUNCTION;\n};\n\ninline void swap(message_t &a, message_t &b) ZMQ_NOTHROW\n{\n    a.swap(b);\n}\n\n#ifdef ZMQ_CPP11\nenum class ctxopt\n{\n#ifdef ZMQ_BLOCKY\n    blocky = ZMQ_BLOCKY,\n#endif\n#ifdef ZMQ_IO_THREADS\n    io_threads = ZMQ_IO_THREADS,\n#endif\n#ifdef ZMQ_THREAD_SCHED_POLICY\n    thread_sched_policy = ZMQ_THREAD_SCHED_POLICY,\n#endif\n#ifdef ZMQ_THREAD_PRIORITY\n    thread_priority = ZMQ_THREAD_PRIORITY,\n#endif\n#ifdef ZMQ_THREAD_AFFINITY_CPU_ADD\n    thread_affinity_cpu_add = ZMQ_THREAD_AFFINITY_CPU_ADD,\n#endif\n#ifdef ZMQ_THREAD_AFFINITY_CPU_REMOVE\n    thread_affinity_cpu_remove = ZMQ_THREAD_AFFINITY_CPU_REMOVE,\n#endif\n#ifdef ZMQ_THREAD_NAME_PREFIX\n    thread_name_prefix = ZMQ_THREAD_NAME_PREFIX,\n#endif\n#ifdef ZMQ_MAX_MSGSZ\n    max_msgsz = ZMQ_MAX_MSGSZ,\n#endif\n#ifdef ZMQ_ZERO_COPY_RECV\n    zero_copy_recv = ZMQ_ZERO_COPY_RECV,\n#endif\n#ifdef ZMQ_MAX_SOCKETS\n    max_sockets = ZMQ_MAX_SOCKETS,\n#endif\n#ifdef ZMQ_SOCKET_LIMIT\n    socket_limit = ZMQ_SOCKET_LIMIT,\n#endif\n#ifdef ZMQ_IPV6\n    ipv6 = ZMQ_IPV6,\n#endif\n#ifdef ZMQ_MSG_T_SIZE\n    msg_t_size = ZMQ_MSG_T_SIZE\n#endif\n};\n#endif\n\nclass context_t\n{\n  public:\n    context_t()\n    {\n        ptr = zmq_ctx_new();\n        if (ptr == ZMQ_NULLPTR)\n            throw error_t();\n    }\n\n\n    explicit context_t(int io_threads_, int max_sockets_ = ZMQ_MAX_SOCKETS_DFLT)\n    {\n        ptr = zmq_ctx_new();\n        if (ptr == ZMQ_NULLPTR)\n            throw error_t();\n\n        int rc = zmq_ctx_set(ptr, ZMQ_IO_THREADS, io_threads_);\n        ZMQ_ASSERT(rc == 0);\n\n        rc = zmq_ctx_set(ptr, ZMQ_MAX_SOCKETS, max_sockets_);\n        ZMQ_ASSERT(rc == 0);\n    }\n\n#ifdef ZMQ_HAS_RVALUE_REFS\n    context_t(context_t &&rhs) ZMQ_NOTHROW : ptr(rhs.ptr) { rhs.ptr = ZMQ_NULLPTR; }\n    context_t &operator=(context_t &&rhs) ZMQ_NOTHROW\n    {\n        close();\n        std::swap(ptr, rhs.ptr);\n        return *this;\n    }\n#endif\n\n    ~context_t() ZMQ_NOTHROW { close(); }\n\n    ZMQ_CPP11_DEPRECATED(\"from 4.7.0, use set taking zmq::ctxopt instead\")\n    int setctxopt(int option_, int optval_)\n    {\n        int rc = zmq_ctx_set(ptr, option_, optval_);\n        ZMQ_ASSERT(rc == 0);\n        return rc;\n    }\n\n    ZMQ_CPP11_DEPRECATED(\"from 4.7.0, use get taking zmq::ctxopt instead\")\n    int getctxopt(int option_) { return zmq_ctx_get(ptr, option_); }\n\n#ifdef ZMQ_CPP11\n    void set(ctxopt option, int optval)\n    {\n        int rc = zmq_ctx_set(ptr, static_cast<int>(option), optval);\n        if (rc == -1)\n            throw error_t();\n    }\n\n    ZMQ_NODISCARD int get(ctxopt option)\n    {\n        int rc = zmq_ctx_get(ptr, static_cast<int>(option));\n        // some options have a default value of -1\n        // which is unfortunate, and may result in errors\n        // that don't make sense\n        if (rc == -1)\n            throw error_t();\n        return rc;\n    }\n#endif\n\n    // Terminates context (see also shutdown()).\n    void close() ZMQ_NOTHROW\n    {\n        if (ptr == ZMQ_NULLPTR)\n            return;\n\n        int rc;\n        do {\n            rc = zmq_ctx_term(ptr);\n        } while (rc == -1 && errno == EINTR);\n\n        ZMQ_ASSERT(rc == 0);\n        ptr = ZMQ_NULLPTR;\n    }\n\n    // Shutdown context in preparation for termination (close()).\n    // Causes all blocking socket operations and any further\n    // socket operations to return with ETERM.\n    void shutdown() ZMQ_NOTHROW\n    {\n        if (ptr == ZMQ_NULLPTR)\n            return;\n        int rc = zmq_ctx_shutdown(ptr);\n        ZMQ_ASSERT(rc == 0);\n    }\n\n    //  Be careful with this, it's probably only useful for\n    //  using the C api together with an existing C++ api.\n    //  Normally you should never need to use this.\n    ZMQ_EXPLICIT operator void *() ZMQ_NOTHROW { return ptr; }\n\n    ZMQ_EXPLICIT operator void const *() const ZMQ_NOTHROW { return ptr; }\n\n    ZMQ_NODISCARD void *handle() ZMQ_NOTHROW { return ptr; }\n\n    ZMQ_DEPRECATED(\"from 4.7.0, use handle() != nullptr instead\")\n    operator bool() const ZMQ_NOTHROW { return ptr != ZMQ_NULLPTR; }\n\n    void swap(context_t &other) ZMQ_NOTHROW { std::swap(ptr, other.ptr); }\n\n  private:\n    void *ptr;\n\n    context_t(const context_t &) ZMQ_DELETED_FUNCTION;\n    void operator=(const context_t &) ZMQ_DELETED_FUNCTION;\n};\n\ninline void swap(context_t &a, context_t &b) ZMQ_NOTHROW\n{\n    a.swap(b);\n}\n\n#ifdef ZMQ_CPP11\n\nstruct recv_buffer_size\n{\n    size_t size;             // number of bytes written to buffer\n    size_t untruncated_size; // untruncated message size in bytes\n\n    ZMQ_NODISCARD bool truncated() const noexcept\n    {\n        return size != untruncated_size;\n    }\n};\n\n#if CPPZMQ_HAS_OPTIONAL\n\nusing send_result_t = std::optional<size_t>;\nusing recv_result_t = std::optional<size_t>;\nusing recv_buffer_result_t = std::optional<recv_buffer_size>;\n\n#else\n\nnamespace detail\n{\n// A C++11 type emulating the most basic\n// operations of std::optional for trivial types\ntemplate<class T> class trivial_optional\n{\n  public:\n    static_assert(std::is_trivial<T>::value, \"T must be trivial\");\n    using value_type = T;\n\n    trivial_optional() = default;\n    trivial_optional(T value) noexcept : _value(value), _has_value(true) {}\n\n    const T *operator->() const noexcept\n    {\n        assert(_has_value);\n        return &_value;\n    }\n    T *operator->() noexcept\n    {\n        assert(_has_value);\n        return &_value;\n    }\n\n    const T &operator*() const noexcept\n    {\n        assert(_has_value);\n        return _value;\n    }\n    T &operator*() noexcept\n    {\n        assert(_has_value);\n        return _value;\n    }\n\n    T &value()\n    {\n        if (!_has_value)\n            throw std::exception();\n        return _value;\n    }\n    const T &value() const\n    {\n        if (!_has_value)\n            throw std::exception();\n        return _value;\n    }\n\n    explicit operator bool() const noexcept { return _has_value; }\n    bool has_value() const noexcept { return _has_value; }\n\n  private:\n    T _value{};\n    bool _has_value{false};\n};\n} // namespace detail\n\nusing send_result_t = detail::trivial_optional<size_t>;\nusing recv_result_t = detail::trivial_optional<size_t>;\nusing recv_buffer_result_t = detail::trivial_optional<recv_buffer_size>;\n\n#endif\n\nnamespace detail\n{\ntemplate<class T> constexpr T enum_bit_or(T a, T b) noexcept\n{\n    static_assert(std::is_enum<T>::value, \"must be enum\");\n    using U = typename std::underlying_type<T>::type;\n    return static_cast<T>(static_cast<U>(a) | static_cast<U>(b));\n}\ntemplate<class T> constexpr T enum_bit_and(T a, T b) noexcept\n{\n    static_assert(std::is_enum<T>::value, \"must be enum\");\n    using U = typename std::underlying_type<T>::type;\n    return static_cast<T>(static_cast<U>(a) & static_cast<U>(b));\n}\ntemplate<class T> constexpr T enum_bit_xor(T a, T b) noexcept\n{\n    static_assert(std::is_enum<T>::value, \"must be enum\");\n    using U = typename std::underlying_type<T>::type;\n    return static_cast<T>(static_cast<U>(a) ^ static_cast<U>(b));\n}\ntemplate<class T> constexpr T enum_bit_not(T a) noexcept\n{\n    static_assert(std::is_enum<T>::value, \"must be enum\");\n    using U = typename std::underlying_type<T>::type;\n    return static_cast<T>(~static_cast<U>(a));\n}\n} // namespace detail\n\n// partially satisfies named requirement BitmaskType\nenum class send_flags : int\n{\n    none = 0,\n    dontwait = ZMQ_DONTWAIT,\n    sndmore = ZMQ_SNDMORE\n};\n\nconstexpr send_flags operator|(send_flags a, send_flags b) noexcept\n{\n    return detail::enum_bit_or(a, b);\n}\nconstexpr send_flags operator&(send_flags a, send_flags b) noexcept\n{\n    return detail::enum_bit_and(a, b);\n}\nconstexpr send_flags operator^(send_flags a, send_flags b) noexcept\n{\n    return detail::enum_bit_xor(a, b);\n}\nconstexpr send_flags operator~(send_flags a) noexcept\n{\n    return detail::enum_bit_not(a);\n}\n\n// partially satisfies named requirement BitmaskType\nenum class recv_flags : int\n{\n    none = 0,\n    dontwait = ZMQ_DONTWAIT\n};\n\nconstexpr recv_flags operator|(recv_flags a, recv_flags b) noexcept\n{\n    return detail::enum_bit_or(a, b);\n}\nconstexpr recv_flags operator&(recv_flags a, recv_flags b) noexcept\n{\n    return detail::enum_bit_and(a, b);\n}\nconstexpr recv_flags operator^(recv_flags a, recv_flags b) noexcept\n{\n    return detail::enum_bit_xor(a, b);\n}\nconstexpr recv_flags operator~(recv_flags a) noexcept\n{\n    return detail::enum_bit_not(a);\n}\n\n\n// mutable_buffer, const_buffer and buffer are based on\n// the Networking TS specification, draft:\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4771.pdf\n\nclass mutable_buffer\n{\n  public:\n    constexpr mutable_buffer() noexcept : _data(nullptr), _size(0) {}\n    constexpr mutable_buffer(void *p, size_t n) noexcept : _data(p), _size(n)\n    {\n#ifdef ZMQ_EXTENDED_CONSTEXPR\n        assert(p != nullptr || n == 0);\n#endif\n    }\n\n    constexpr void *data() const noexcept { return _data; }\n    constexpr size_t size() const noexcept { return _size; }\n    mutable_buffer &operator+=(size_t n) noexcept\n    {\n        // (std::min) is a workaround for when a min macro is defined\n        const auto shift = (std::min)(n, _size);\n        _data = static_cast<char *>(_data) + shift;\n        _size -= shift;\n        return *this;\n    }\n\n  private:\n    void *_data;\n    size_t _size;\n};\n\ninline mutable_buffer operator+(const mutable_buffer &mb, size_t n) noexcept\n{\n    return mutable_buffer(static_cast<char *>(mb.data()) + (std::min)(n, mb.size()),\n                          mb.size() - (std::min)(n, mb.size()));\n}\ninline mutable_buffer operator+(size_t n, const mutable_buffer &mb) noexcept\n{\n    return mb + n;\n}\n\nclass const_buffer\n{\n  public:\n    constexpr const_buffer() noexcept : _data(nullptr), _size(0) {}\n    constexpr const_buffer(const void *p, size_t n) noexcept : _data(p), _size(n)\n    {\n#ifdef ZMQ_EXTENDED_CONSTEXPR\n        assert(p != nullptr || n == 0);\n#endif\n    }\n    constexpr const_buffer(const mutable_buffer &mb) noexcept :\n        _data(mb.data()), _size(mb.size())\n    {\n    }\n\n    constexpr const void *data() const noexcept { return _data; }\n    constexpr size_t size() const noexcept { return _size; }\n    const_buffer &operator+=(size_t n) noexcept\n    {\n        const auto shift = (std::min)(n, _size);\n        _data = static_cast<const char *>(_data) + shift;\n        _size -= shift;\n        return *this;\n    }\n\n  private:\n    const void *_data;\n    size_t _size;\n};\n\ninline const_buffer operator+(const const_buffer &cb, size_t n) noexcept\n{\n    return const_buffer(static_cast<const char *>(cb.data())\n                          + (std::min)(n, cb.size()),\n                        cb.size() - (std::min)(n, cb.size()));\n}\ninline const_buffer operator+(size_t n, const const_buffer &cb) noexcept\n{\n    return cb + n;\n}\n\n// buffer creation\n\nconstexpr mutable_buffer buffer(void *p, size_t n) noexcept\n{\n    return mutable_buffer(p, n);\n}\nconstexpr const_buffer buffer(const void *p, size_t n) noexcept\n{\n    return const_buffer(p, n);\n}\nconstexpr mutable_buffer buffer(const mutable_buffer &mb) noexcept\n{\n    return mb;\n}\ninline mutable_buffer buffer(const mutable_buffer &mb, size_t n) noexcept\n{\n    return mutable_buffer(mb.data(), (std::min)(mb.size(), n));\n}\nconstexpr const_buffer buffer(const const_buffer &cb) noexcept\n{\n    return cb;\n}\ninline const_buffer buffer(const const_buffer &cb, size_t n) noexcept\n{\n    return const_buffer(cb.data(), (std::min)(cb.size(), n));\n}\n\nnamespace detail\n{\ntemplate<class T> struct is_buffer\n{\n    static constexpr bool value =\n      std::is_same<T, const_buffer>::value || std::is_same<T, mutable_buffer>::value;\n};\n\ntemplate<class T> struct is_pod_like\n{\n    // NOTE: The networking draft N4771 section 16.11 requires\n    // T in the buffer functions below to be\n    // trivially copyable OR standard layout.\n    // Here we decide to be conservative and require both.\n    static constexpr bool value =\n      ZMQ_IS_TRIVIALLY_COPYABLE(T) && std::is_standard_layout<T>::value;\n};\n\ntemplate<class C> constexpr auto seq_size(const C &c) noexcept -> decltype(c.size())\n{\n    return c.size();\n}\ntemplate<class T, size_t N>\nconstexpr size_t seq_size(const T (&/*array*/)[N]) noexcept\n{\n    return N;\n}\n\ntemplate<class Seq>\nauto buffer_contiguous_sequence(Seq &&seq) noexcept\n  -> decltype(buffer(std::addressof(*std::begin(seq)), size_t{}))\n{\n    using T = typename std::remove_cv<\n      typename std::remove_reference<decltype(*std::begin(seq))>::type>::type;\n    static_assert(detail::is_pod_like<T>::value, \"T must be POD\");\n\n    const auto size = seq_size(seq);\n    return buffer(size != 0u ? std::addressof(*std::begin(seq)) : nullptr,\n                  size * sizeof(T));\n}\ntemplate<class Seq>\nauto buffer_contiguous_sequence(Seq &&seq, size_t n_bytes) noexcept\n  -> decltype(buffer_contiguous_sequence(seq))\n{\n    using T = typename std::remove_cv<\n      typename std::remove_reference<decltype(*std::begin(seq))>::type>::type;\n    static_assert(detail::is_pod_like<T>::value, \"T must be POD\");\n\n    const auto size = seq_size(seq);\n    return buffer(size != 0u ? std::addressof(*std::begin(seq)) : nullptr,\n                  (std::min)(size * sizeof(T), n_bytes));\n}\n\n} // namespace detail\n\n// C array\ntemplate<class T, size_t N> mutable_buffer buffer(T (&data)[N]) noexcept\n{\n    return detail::buffer_contiguous_sequence(data);\n}\ntemplate<class T, size_t N>\nmutable_buffer buffer(T (&data)[N], size_t n_bytes) noexcept\n{\n    return detail::buffer_contiguous_sequence(data, n_bytes);\n}\ntemplate<class T, size_t N> const_buffer buffer(const T (&data)[N]) noexcept\n{\n    return detail::buffer_contiguous_sequence(data);\n}\ntemplate<class T, size_t N>\nconst_buffer buffer(const T (&data)[N], size_t n_bytes) noexcept\n{\n    return detail::buffer_contiguous_sequence(data, n_bytes);\n}\n// std::array\ntemplate<class T, size_t N> mutable_buffer buffer(std::array<T, N> &data) noexcept\n{\n    return detail::buffer_contiguous_sequence(data);\n}\ntemplate<class T, size_t N>\nmutable_buffer buffer(std::array<T, N> &data, size_t n_bytes) noexcept\n{\n    return detail::buffer_contiguous_sequence(data, n_bytes);\n}\ntemplate<class T, size_t N>\nconst_buffer buffer(std::array<const T, N> &data) noexcept\n{\n    return detail::buffer_contiguous_sequence(data);\n}\ntemplate<class T, size_t N>\nconst_buffer buffer(std::array<const T, N> &data, size_t n_bytes) noexcept\n{\n    return detail::buffer_contiguous_sequence(data, n_bytes);\n}\ntemplate<class T, size_t N>\nconst_buffer buffer(const std::array<T, N> &data) noexcept\n{\n    return detail::buffer_contiguous_sequence(data);\n}\ntemplate<class T, size_t N>\nconst_buffer buffer(const std::array<T, N> &data, size_t n_bytes) noexcept\n{\n    return detail::buffer_contiguous_sequence(data, n_bytes);\n}\n// std::vector\ntemplate<class T, class Allocator>\nmutable_buffer buffer(std::vector<T, Allocator> &data) noexcept\n{\n    return detail::buffer_contiguous_sequence(data);\n}\ntemplate<class T, class Allocator>\nmutable_buffer buffer(std::vector<T, Allocator> &data, size_t n_bytes) noexcept\n{\n    return detail::buffer_contiguous_sequence(data, n_bytes);\n}\ntemplate<class T, class Allocator>\nconst_buffer buffer(const std::vector<T, Allocator> &data) noexcept\n{\n    return detail::buffer_contiguous_sequence(data);\n}\ntemplate<class T, class Allocator>\nconst_buffer buffer(const std::vector<T, Allocator> &data, size_t n_bytes) noexcept\n{\n    return detail::buffer_contiguous_sequence(data, n_bytes);\n}\n// std::basic_string\ntemplate<class T, class Traits, class Allocator>\nmutable_buffer buffer(std::basic_string<T, Traits, Allocator> &data) noexcept\n{\n    return detail::buffer_contiguous_sequence(data);\n}\ntemplate<class T, class Traits, class Allocator>\nmutable_buffer buffer(std::basic_string<T, Traits, Allocator> &data,\n                      size_t n_bytes) noexcept\n{\n    return detail::buffer_contiguous_sequence(data, n_bytes);\n}\ntemplate<class T, class Traits, class Allocator>\nconst_buffer buffer(const std::basic_string<T, Traits, Allocator> &data) noexcept\n{\n    return detail::buffer_contiguous_sequence(data);\n}\ntemplate<class T, class Traits, class Allocator>\nconst_buffer buffer(const std::basic_string<T, Traits, Allocator> &data,\n                    size_t n_bytes) noexcept\n{\n    return detail::buffer_contiguous_sequence(data, n_bytes);\n}\n\n#if CPPZMQ_HAS_STRING_VIEW\n// std::basic_string_view\ntemplate<class T, class Traits>\nconst_buffer buffer(std::basic_string_view<T, Traits> data) noexcept\n{\n    return detail::buffer_contiguous_sequence(data);\n}\ntemplate<class T, class Traits>\nconst_buffer buffer(std::basic_string_view<T, Traits> data, size_t n_bytes) noexcept\n{\n    return detail::buffer_contiguous_sequence(data, n_bytes);\n}\n#endif\n\n// Buffer for a string literal (null terminated)\n// where the buffer size excludes the terminating character.\n// Equivalent to zmq::buffer(std::string_view(\"...\")).\ntemplate<class Char, size_t N>\nconstexpr const_buffer str_buffer(const Char (&data)[N]) noexcept\n{\n    static_assert(detail::is_pod_like<Char>::value, \"Char must be POD\");\n#ifdef ZMQ_EXTENDED_CONSTEXPR\n    assert(data[N - 1] == Char{0});\n#endif\n    return const_buffer(static_cast<const Char *>(data), (N - 1) * sizeof(Char));\n}\n\nnamespace literals\n{\nconstexpr const_buffer operator\"\" _zbuf(const char *str, size_t len) noexcept\n{\n    return const_buffer(str, len * sizeof(char));\n}\nconstexpr const_buffer operator\"\" _zbuf(const wchar_t *str, size_t len) noexcept\n{\n    return const_buffer(str, len * sizeof(wchar_t));\n}\nconstexpr const_buffer operator\"\" _zbuf(const char16_t *str, size_t len) noexcept\n{\n    return const_buffer(str, len * sizeof(char16_t));\n}\nconstexpr const_buffer operator\"\" _zbuf(const char32_t *str, size_t len) noexcept\n{\n    return const_buffer(str, len * sizeof(char32_t));\n}\n}\n\n#ifdef ZMQ_CPP11\nenum class socket_type : int\n{\n    req = ZMQ_REQ,\n    rep = ZMQ_REP,\n    dealer = ZMQ_DEALER,\n    router = ZMQ_ROUTER,\n    pub = ZMQ_PUB,\n    sub = ZMQ_SUB,\n    xpub = ZMQ_XPUB,\n    xsub = ZMQ_XSUB,\n    push = ZMQ_PUSH,\n    pull = ZMQ_PULL,\n#if defined(ZMQ_BUILD_DRAFT_API) && ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 2, 0)\n    server = ZMQ_SERVER,\n    client = ZMQ_CLIENT,\n    radio = ZMQ_RADIO,\n    dish = ZMQ_DISH,\n    gather = ZMQ_GATHER,\n    scatter = ZMQ_SCATTER,\n    dgram = ZMQ_DGRAM,\n#endif\n#if defined(ZMQ_BUILD_DRAFT_API) && ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 3, 3)\n    peer = ZMQ_PEER,\n    channel = ZMQ_CHANNEL,\n#endif\n#if ZMQ_VERSION_MAJOR >= 4\n    stream = ZMQ_STREAM,\n#endif\n    pair = ZMQ_PAIR\n};\n#endif\n\nnamespace sockopt\n{\n// There are two types of options,\n// integral type with known compiler time size (int, bool, int64_t, uint64_t)\n// and arrays with dynamic size (strings, binary data).\n\n// BoolUnit: if true accepts values of type bool (but passed as T into libzmq)\ntemplate<int Opt, class T, bool BoolUnit = false> struct integral_option\n{\n};\n\n// NullTerm:\n// 0: binary data\n// 1: null-terminated string (`getsockopt` size includes null)\n// 2: binary (size 32) or Z85 encoder string of size 41 (null included)\ntemplate<int Opt, int NullTerm = 1> struct array_option\n{\n};\n\n#define ZMQ_DEFINE_INTEGRAL_OPT(OPT, NAME, TYPE)                                    \\\n    using NAME##_t = integral_option<OPT, TYPE, false>;                             \\\n    ZMQ_INLINE_VAR ZMQ_CONSTEXPR_VAR NAME##_t NAME {}\n#define ZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(OPT, NAME, TYPE)                          \\\n    using NAME##_t = integral_option<OPT, TYPE, true>;                              \\\n    ZMQ_INLINE_VAR ZMQ_CONSTEXPR_VAR NAME##_t NAME {}\n#define ZMQ_DEFINE_ARRAY_OPT(OPT, NAME)                                             \\\n    using NAME##_t = array_option<OPT>;                                             \\\n    ZMQ_INLINE_VAR ZMQ_CONSTEXPR_VAR NAME##_t NAME {}\n#define ZMQ_DEFINE_ARRAY_OPT_BINARY(OPT, NAME)                                      \\\n    using NAME##_t = array_option<OPT, 0>;                                          \\\n    ZMQ_INLINE_VAR ZMQ_CONSTEXPR_VAR NAME##_t NAME {}\n#define ZMQ_DEFINE_ARRAY_OPT_BIN_OR_Z85(OPT, NAME)                                  \\\n    using NAME##_t = array_option<OPT, 2>;                                          \\\n    ZMQ_INLINE_VAR ZMQ_CONSTEXPR_VAR NAME##_t NAME {}\n\n// deprecated, use zmq::fd_t\nusing cppzmq_fd_t = ::zmq::fd_t;\n\n#ifdef ZMQ_AFFINITY\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_AFFINITY, affinity, uint64_t);\n#endif\n#ifdef ZMQ_BACKLOG\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_BACKLOG, backlog, int);\n#endif\n#ifdef ZMQ_BINDTODEVICE\nZMQ_DEFINE_ARRAY_OPT_BINARY(ZMQ_BINDTODEVICE, bindtodevice);\n#endif\n#ifdef ZMQ_CONFLATE\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_CONFLATE, conflate, int);\n#endif\n#ifdef ZMQ_CONNECT_ROUTING_ID\nZMQ_DEFINE_ARRAY_OPT(ZMQ_CONNECT_ROUTING_ID, connect_routing_id);\n#endif\n#ifdef ZMQ_CONNECT_TIMEOUT\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_CONNECT_TIMEOUT, connect_timeout, int);\n#endif\n#ifdef ZMQ_CURVE_PUBLICKEY\nZMQ_DEFINE_ARRAY_OPT_BIN_OR_Z85(ZMQ_CURVE_PUBLICKEY, curve_publickey);\n#endif\n#ifdef ZMQ_CURVE_SECRETKEY\nZMQ_DEFINE_ARRAY_OPT_BIN_OR_Z85(ZMQ_CURVE_SECRETKEY, curve_secretkey);\n#endif\n#ifdef ZMQ_CURVE_SERVER\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_CURVE_SERVER, curve_server, int);\n#endif\n#ifdef ZMQ_CURVE_SERVERKEY\nZMQ_DEFINE_ARRAY_OPT_BIN_OR_Z85(ZMQ_CURVE_SERVERKEY, curve_serverkey);\n#endif\n#ifdef ZMQ_DISCONNECT_MSG\nZMQ_DEFINE_ARRAY_OPT_BINARY(ZMQ_DISCONNECT_MSG, disconnect_msg);\n#endif\n#ifdef ZMQ_EVENTS\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_EVENTS, events, int);\n#endif\n#ifdef ZMQ_FD\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_FD, fd, ::zmq::fd_t);\n#endif\n#ifdef ZMQ_GSSAPI_PLAINTEXT\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_GSSAPI_PLAINTEXT, gssapi_plaintext, int);\n#endif\n#ifdef ZMQ_GSSAPI_SERVER\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_GSSAPI_SERVER, gssapi_server, int);\n#endif\n#ifdef ZMQ_GSSAPI_SERVICE_PRINCIPAL\nZMQ_DEFINE_ARRAY_OPT(ZMQ_GSSAPI_SERVICE_PRINCIPAL, gssapi_service_principal);\n#endif\n#ifdef ZMQ_GSSAPI_SERVICE_PRINCIPAL_NAMETYPE\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_GSSAPI_SERVICE_PRINCIPAL_NAMETYPE,\n                        gssapi_service_principal_nametype,\n                        int);\n#endif\n#ifdef ZMQ_GSSAPI_PRINCIPAL\nZMQ_DEFINE_ARRAY_OPT(ZMQ_GSSAPI_PRINCIPAL, gssapi_principal);\n#endif\n#ifdef ZMQ_GSSAPI_PRINCIPAL_NAMETYPE\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_GSSAPI_PRINCIPAL_NAMETYPE,\n                        gssapi_principal_nametype,\n                        int);\n#endif\n#ifdef ZMQ_HANDSHAKE_IVL\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_HANDSHAKE_IVL, handshake_ivl, int);\n#endif\n#ifdef ZMQ_HEARTBEAT_IVL\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_HEARTBEAT_IVL, heartbeat_ivl, int);\n#endif\n#ifdef ZMQ_HEARTBEAT_TIMEOUT\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_HEARTBEAT_TIMEOUT, heartbeat_timeout, int);\n#endif\n#ifdef ZMQ_HEARTBEAT_TTL\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_HEARTBEAT_TTL, heartbeat_ttl, int);\n#endif\n#ifdef ZMQ_HELLO_MSG\nZMQ_DEFINE_ARRAY_OPT_BINARY(ZMQ_HELLO_MSG, hello_msg);\n#endif\n#ifdef ZMQ_IMMEDIATE\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_IMMEDIATE, immediate, int);\n#endif\n#ifdef ZMQ_INVERT_MATCHING\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_INVERT_MATCHING, invert_matching, int);\n#endif\n#ifdef ZMQ_IPV6\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_IPV6, ipv6, int);\n#endif\n#ifdef ZMQ_LAST_ENDPOINT\nZMQ_DEFINE_ARRAY_OPT(ZMQ_LAST_ENDPOINT, last_endpoint);\n#endif\n#ifdef ZMQ_LINGER\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_LINGER, linger, int);\n#endif\n#ifdef ZMQ_MAXMSGSIZE\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_MAXMSGSIZE, maxmsgsize, int64_t);\n#endif\n#ifdef ZMQ_MECHANISM\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_MECHANISM, mechanism, int);\n#endif\n#ifdef ZMQ_METADATA\nZMQ_DEFINE_ARRAY_OPT(ZMQ_METADATA, metadata);\n#endif\n#ifdef ZMQ_MULTICAST_HOPS\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_MULTICAST_HOPS, multicast_hops, int);\n#endif\n#ifdef ZMQ_MULTICAST_LOOP\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_MULTICAST_LOOP, multicast_loop, int);\n#endif\n#ifdef ZMQ_MULTICAST_MAXTPDU\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_MULTICAST_MAXTPDU, multicast_maxtpdu, int);\n#endif\n#ifdef ZMQ_ONLY_FIRST_SUBSCRIBE\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_ONLY_FIRST_SUBSCRIBE, only_first_subscribe, int);\n#endif\n#ifdef ZMQ_PLAIN_SERVER\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_PLAIN_SERVER, plain_server, int);\n#endif\n#ifdef ZMQ_PLAIN_PASSWORD\nZMQ_DEFINE_ARRAY_OPT(ZMQ_PLAIN_PASSWORD, plain_password);\n#endif\n#ifdef ZMQ_PLAIN_USERNAME\nZMQ_DEFINE_ARRAY_OPT(ZMQ_PLAIN_USERNAME, plain_username);\n#endif\n#ifdef ZMQ_PRIORITY\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_PRIORITY, priority, int);\n#endif\n#ifdef ZMQ_USE_FD\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_USE_FD, use_fd, int);\n#endif\n#ifdef ZMQ_PROBE_ROUTER\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_PROBE_ROUTER, probe_router, int);\n#endif\n#ifdef ZMQ_RATE\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_RATE, rate, int);\n#endif\n#ifdef ZMQ_RCVBUF\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_RCVBUF, rcvbuf, int);\n#endif\n#ifdef ZMQ_RCVHWM\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_RCVHWM, rcvhwm, int);\n#endif\n#ifdef ZMQ_RCVMORE\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_RCVMORE, rcvmore, int);\n#endif\n#ifdef ZMQ_RCVTIMEO\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_RCVTIMEO, rcvtimeo, int);\n#endif\n#ifdef ZMQ_RECONNECT_IVL\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_RECONNECT_IVL, reconnect_ivl, int);\n#endif\n#ifdef ZMQ_RECONNECT_IVL_MAX\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_RECONNECT_IVL_MAX, reconnect_ivl_max, int);\n#endif\n#ifdef ZMQ_RECONNECT_STOP\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_RECONNECT_STOP, reconnect_stop, int);\n#endif\n#ifdef ZMQ_RECOVERY_IVL\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_RECOVERY_IVL, recovery_ivl, int);\n#endif\n#ifdef ZMQ_REQ_CORRELATE\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_REQ_CORRELATE, req_correlate, int);\n#endif\n#ifdef ZMQ_REQ_RELAXED\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_REQ_RELAXED, req_relaxed, int);\n#endif\n#ifdef ZMQ_ROUTER_HANDOVER\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_ROUTER_HANDOVER, router_handover, int);\n#endif\n#ifdef ZMQ_ROUTER_MANDATORY\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_ROUTER_MANDATORY, router_mandatory, int);\n#endif\n#ifdef ZMQ_ROUTER_NOTIFY\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_ROUTER_NOTIFY, router_notify, int);\n#endif\n#ifdef ZMQ_ROUTER_RAW\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_ROUTER_RAW, router_raw, int);\n#endif\n#ifdef ZMQ_ROUTING_ID\nZMQ_DEFINE_ARRAY_OPT_BINARY(ZMQ_ROUTING_ID, routing_id);\n#endif\n#ifdef ZMQ_SNDBUF\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_SNDBUF, sndbuf, int);\n#endif\n#ifdef ZMQ_SNDHWM\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_SNDHWM, sndhwm, int);\n#endif\n#ifdef ZMQ_SNDTIMEO\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_SNDTIMEO, sndtimeo, int);\n#endif\n#ifdef ZMQ_SOCKS_PASSWORD\nZMQ_DEFINE_ARRAY_OPT(ZMQ_SOCKS_PASSWORD, socks_password);\n#endif\n#ifdef ZMQ_SOCKS_PROXY\nZMQ_DEFINE_ARRAY_OPT(ZMQ_SOCKS_PROXY, socks_proxy);\n#endif\n#ifdef ZMQ_SOCKS_USERNAME\nZMQ_DEFINE_ARRAY_OPT(ZMQ_SOCKS_USERNAME, socks_username);\n#endif\n#ifdef ZMQ_STREAM_NOTIFY\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_STREAM_NOTIFY, stream_notify, int);\n#endif\n#ifdef ZMQ_SUBSCRIBE\nZMQ_DEFINE_ARRAY_OPT(ZMQ_SUBSCRIBE, subscribe);\n#endif\n#ifdef ZMQ_TCP_KEEPALIVE\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_TCP_KEEPALIVE, tcp_keepalive, int);\n#endif\n#ifdef ZMQ_TCP_KEEPALIVE_CNT\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_TCP_KEEPALIVE_CNT, tcp_keepalive_cnt, int);\n#endif\n#ifdef ZMQ_TCP_KEEPALIVE_IDLE\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_TCP_KEEPALIVE_IDLE, tcp_keepalive_idle, int);\n#endif\n#ifdef ZMQ_TCP_KEEPALIVE_INTVL\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_TCP_KEEPALIVE_INTVL, tcp_keepalive_intvl, int);\n#endif\n#ifdef ZMQ_TCP_MAXRT\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_TCP_MAXRT, tcp_maxrt, int);\n#endif\n#ifdef ZMQ_THREAD_SAFE\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_THREAD_SAFE, thread_safe, int);\n#endif\n#ifdef ZMQ_TOS\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_TOS, tos, int);\n#endif\n#ifdef ZMQ_TYPE\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_TYPE, type, int);\n#ifdef ZMQ_CPP11\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_TYPE, socket_type, socket_type);\n#endif // ZMQ_CPP11\n#endif // ZMQ_TYPE\n#ifdef ZMQ_UNSUBSCRIBE\nZMQ_DEFINE_ARRAY_OPT(ZMQ_UNSUBSCRIBE, unsubscribe);\n#endif\n#ifdef ZMQ_VMCI_BUFFER_SIZE\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_VMCI_BUFFER_SIZE, vmci_buffer_size, uint64_t);\n#endif\n#ifdef ZMQ_VMCI_BUFFER_MIN_SIZE\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_VMCI_BUFFER_MIN_SIZE, vmci_buffer_min_size, uint64_t);\n#endif\n#ifdef ZMQ_VMCI_BUFFER_MAX_SIZE\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_VMCI_BUFFER_MAX_SIZE, vmci_buffer_max_size, uint64_t);\n#endif\n#ifdef ZMQ_VMCI_CONNECT_TIMEOUT\nZMQ_DEFINE_INTEGRAL_OPT(ZMQ_VMCI_CONNECT_TIMEOUT, vmci_connect_timeout, int);\n#endif\n#ifdef ZMQ_XPUB_VERBOSE\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_XPUB_VERBOSE, xpub_verbose, int);\n#endif\n#ifdef ZMQ_XPUB_VERBOSER\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_XPUB_VERBOSER, xpub_verboser, int);\n#endif\n#ifdef ZMQ_XPUB_MANUAL\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_XPUB_MANUAL, xpub_manual, int);\n#endif\n#ifdef ZMQ_XPUB_MANUAL_LAST_VALUE\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_XPUB_MANUAL_LAST_VALUE, xpub_manual_last_value, int);\n#endif\n#ifdef ZMQ_XPUB_NODROP\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_XPUB_NODROP, xpub_nodrop, int);\n#endif\n#ifdef ZMQ_XPUB_WELCOME_MSG\nZMQ_DEFINE_ARRAY_OPT(ZMQ_XPUB_WELCOME_MSG, xpub_welcome_msg);\n#endif\n#ifdef ZMQ_ZAP_ENFORCE_DOMAIN\nZMQ_DEFINE_INTEGRAL_BOOL_UNIT_OPT(ZMQ_ZAP_ENFORCE_DOMAIN, zap_enforce_domain, int);\n#endif\n#ifdef ZMQ_ZAP_DOMAIN\nZMQ_DEFINE_ARRAY_OPT(ZMQ_ZAP_DOMAIN, zap_domain);\n#endif\n\n} // namespace sockopt\n#endif // ZMQ_CPP11\n\n\nnamespace detail\n{\nclass socket_base\n{\n  public:\n    socket_base() ZMQ_NOTHROW : _handle(ZMQ_NULLPTR) {}\n    ZMQ_EXPLICIT socket_base(void *handle) ZMQ_NOTHROW : _handle(handle) {}\n\n    template<typename T>\n    ZMQ_CPP11_DEPRECATED(\"from 4.7.0, use `set` taking option from zmq::sockopt\")\n    void setsockopt(int option_, T const &optval)\n    {\n        setsockopt(option_, &optval, sizeof(T));\n    }\n\n    ZMQ_CPP11_DEPRECATED(\"from 4.7.0, use `set` taking option from zmq::sockopt\")\n    void setsockopt(int option_, const void *optval_, size_t optvallen_)\n    {\n        int rc = zmq_setsockopt(_handle, option_, optval_, optvallen_);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    ZMQ_CPP11_DEPRECATED(\"from 4.7.0, use `get` taking option from zmq::sockopt\")\n    void getsockopt(int option_, void *optval_, size_t *optvallen_) const\n    {\n        int rc = zmq_getsockopt(_handle, option_, optval_, optvallen_);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    template<typename T>\n    ZMQ_CPP11_DEPRECATED(\"from 4.7.0, use `get` taking option from zmq::sockopt\")\n    T getsockopt(int option_) const\n    {\n        T optval;\n        size_t optlen = sizeof(T);\n        getsockopt(option_, &optval, &optlen);\n        return optval;\n    }\n\n#ifdef ZMQ_CPP11\n    // Set integral socket option, e.g.\n    // `socket.set(zmq::sockopt::linger, 0)`\n    template<int Opt, class T, bool BoolUnit>\n    void set(sockopt::integral_option<Opt, T, BoolUnit>, const T &val)\n    {\n        static_assert(std::is_integral<T>::value, \"T must be integral\");\n        set_option(Opt, &val, sizeof val);\n    }\n\n    // Set integral socket option from boolean, e.g.\n    // `socket.set(zmq::sockopt::immediate, false)`\n    template<int Opt, class T>\n    void set(sockopt::integral_option<Opt, T, true>, bool val)\n    {\n        static_assert(std::is_integral<T>::value, \"T must be integral\");\n        T rep_val = val;\n        set_option(Opt, &rep_val, sizeof rep_val);\n    }\n\n    // Set array socket option, e.g.\n    // `socket.set(zmq::sockopt::plain_username, \"foo123\")`\n    template<int Opt, int NullTerm>\n    void set(sockopt::array_option<Opt, NullTerm>, const char *buf)\n    {\n        set_option(Opt, buf, std::strlen(buf));\n    }\n\n    // Set array socket option, e.g.\n    // `socket.set(zmq::sockopt::routing_id, zmq::buffer(id))`\n    template<int Opt, int NullTerm>\n    void set(sockopt::array_option<Opt, NullTerm>, const_buffer buf)\n    {\n        set_option(Opt, buf.data(), buf.size());\n    }\n\n    // Set array socket option, e.g.\n    // `socket.set(zmq::sockopt::routing_id, id_str)`\n    template<int Opt, int NullTerm>\n    void set(sockopt::array_option<Opt, NullTerm>, const std::string &buf)\n    {\n        set_option(Opt, buf.data(), buf.size());\n    }\n\n#if CPPZMQ_HAS_STRING_VIEW\n    // Set array socket option, e.g.\n    // `socket.set(zmq::sockopt::routing_id, id_str)`\n    template<int Opt, int NullTerm>\n    void set(sockopt::array_option<Opt, NullTerm>, std::string_view buf)\n    {\n        set_option(Opt, buf.data(), buf.size());\n    }\n#endif\n\n    // Get scalar socket option, e.g.\n    // `auto opt = socket.get(zmq::sockopt::linger)`\n    template<int Opt, class T, bool BoolUnit>\n    ZMQ_NODISCARD T get(sockopt::integral_option<Opt, T, BoolUnit>) const\n    {\n        static_assert(std::is_scalar<T>::value, \"T must be scalar\");\n        T val;\n        size_t size = sizeof val;\n        get_option(Opt, &val, &size);\n        assert(size == sizeof val);\n        return val;\n    }\n\n    // Get array socket option, writes to buf, returns option size in bytes, e.g.\n    // `size_t optsize = socket.get(zmq::sockopt::routing_id, zmq::buffer(id))`\n    template<int Opt, int NullTerm>\n    ZMQ_NODISCARD size_t get(sockopt::array_option<Opt, NullTerm>,\n                             mutable_buffer buf) const\n    {\n        size_t size = buf.size();\n        get_option(Opt, buf.data(), &size);\n        return size;\n    }\n\n    // Get array socket option as string (initializes the string buffer size to init_size) e.g.\n    // `auto s = socket.get(zmq::sockopt::routing_id)`\n    // Note: removes the null character from null-terminated string options,\n    // i.e. the string size excludes the null character.\n    template<int Opt, int NullTerm>\n    ZMQ_NODISCARD std::string get(sockopt::array_option<Opt, NullTerm>,\n                                  size_t init_size = 1024) const\n    {\n        if ZMQ_CONSTEXPR_IF (NullTerm == 2) {\n            if (init_size == 1024) {\n                init_size = 41; // get as Z85 string\n            }\n        }\n        std::string str(init_size, '\\0');\n        size_t size = get(sockopt::array_option<Opt>{}, buffer(str));\n        if ZMQ_CONSTEXPR_IF (NullTerm == 1) {\n            if (size > 0) {\n                assert(str[size - 1] == '\\0');\n                --size;\n            }\n        } else if ZMQ_CONSTEXPR_IF (NullTerm == 2) {\n            assert(size == 32 || size == 41);\n            if (size == 41) {\n                assert(str[size - 1] == '\\0');\n                --size;\n            }\n        }\n        str.resize(size);\n        return str;\n    }\n#endif\n\n    void bind(std::string const &addr) { bind(addr.c_str()); }\n\n    void bind(const char *addr_)\n    {\n        int rc = zmq_bind(_handle, addr_);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    void unbind(std::string const &addr) { unbind(addr.c_str()); }\n\n    void unbind(const char *addr_)\n    {\n        int rc = zmq_unbind(_handle, addr_);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    void connect(std::string const &addr) { connect(addr.c_str()); }\n\n    void connect(const char *addr_)\n    {\n        int rc = zmq_connect(_handle, addr_);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    void disconnect(std::string const &addr) { disconnect(addr.c_str()); }\n\n    void disconnect(const char *addr_)\n    {\n        int rc = zmq_disconnect(_handle, addr_);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    ZMQ_DEPRECATED(\"from 4.7.1, use handle() != nullptr or operator bool\")\n    bool connected() const ZMQ_NOTHROW { return (_handle != ZMQ_NULLPTR); }\n\n    ZMQ_CPP11_DEPRECATED(\"from 4.3.1, use send taking a const_buffer and send_flags\")\n    size_t send(const void *buf_, size_t len_, int flags_ = 0)\n    {\n        int nbytes = zmq_send(_handle, buf_, len_, flags_);\n        if (nbytes >= 0)\n            return static_cast<size_t>(nbytes);\n        if (zmq_errno() == EAGAIN)\n            return 0;\n        throw error_t();\n    }\n\n    ZMQ_CPP11_DEPRECATED(\"from 4.3.1, use send taking message_t and send_flags\")\n    bool send(message_t &msg_,\n              int flags_ = 0) // default until removed\n    {\n        int nbytes = zmq_msg_send(msg_.handle(), _handle, flags_);\n        if (nbytes >= 0)\n            return true;\n        if (zmq_errno() == EAGAIN)\n            return false;\n        throw error_t();\n    }\n\n    template<typename T>\n    ZMQ_CPP11_DEPRECATED(\n      \"from 4.4.1, use send taking message_t or buffer (for contiguous \"\n      \"ranges), and send_flags\")\n    bool send(T first, T last, int flags_ = 0)\n    {\n        zmq::message_t msg(first, last);\n        int nbytes = zmq_msg_send(msg.handle(), _handle, flags_);\n        if (nbytes >= 0)\n            return true;\n        if (zmq_errno() == EAGAIN)\n            return false;\n        throw error_t();\n    }\n\n#ifdef ZMQ_HAS_RVALUE_REFS\n    ZMQ_CPP11_DEPRECATED(\"from 4.3.1, use send taking message_t and send_flags\")\n    bool send(message_t &&msg_,\n              int flags_ = 0) // default until removed\n    {\n#ifdef ZMQ_CPP11\n        return send(msg_, static_cast<send_flags>(flags_)).has_value();\n#else\n        return send(msg_, flags_);\n#endif\n    }\n#endif\n\n#ifdef ZMQ_CPP11\n    send_result_t send(const_buffer buf, send_flags flags = send_flags::none)\n    {\n        const int nbytes =\n          zmq_send(_handle, buf.data(), buf.size(), static_cast<int>(flags));\n        if (nbytes >= 0)\n            return static_cast<size_t>(nbytes);\n        if (zmq_errno() == EAGAIN)\n            return {};\n        throw error_t();\n    }\n\n    send_result_t send(message_t &msg, send_flags flags)\n    {\n        int nbytes = zmq_msg_send(msg.handle(), _handle, static_cast<int>(flags));\n        if (nbytes >= 0)\n            return static_cast<size_t>(nbytes);\n        if (zmq_errno() == EAGAIN)\n            return {};\n        throw error_t();\n    }\n\n    send_result_t send(message_t &&msg, send_flags flags)\n    {\n        return send(msg, flags);\n    }\n#endif\n\n    ZMQ_CPP11_DEPRECATED(\n      \"from 4.3.1, use recv taking a mutable_buffer and recv_flags\")\n    size_t recv(void *buf_, size_t len_, int flags_ = 0)\n    {\n        int nbytes = zmq_recv(_handle, buf_, len_, flags_);\n        if (nbytes >= 0)\n            return static_cast<size_t>(nbytes);\n        if (zmq_errno() == EAGAIN)\n            return 0;\n        throw error_t();\n    }\n\n    ZMQ_CPP11_DEPRECATED(\n      \"from 4.3.1, use recv taking a reference to message_t and recv_flags\")\n    bool recv(message_t *msg_, int flags_ = 0)\n    {\n        int nbytes = zmq_msg_recv(msg_->handle(), _handle, flags_);\n        if (nbytes >= 0)\n            return true;\n        if (zmq_errno() == EAGAIN)\n            return false;\n        throw error_t();\n    }\n\n#ifdef ZMQ_CPP11\n    ZMQ_NODISCARD\n    recv_buffer_result_t recv(mutable_buffer buf,\n                              recv_flags flags = recv_flags::none)\n    {\n        const int nbytes =\n          zmq_recv(_handle, buf.data(), buf.size(), static_cast<int>(flags));\n        if (nbytes >= 0) {\n            return recv_buffer_size{\n              (std::min)(static_cast<size_t>(nbytes), buf.size()),\n              static_cast<size_t>(nbytes)};\n        }\n        if (zmq_errno() == EAGAIN)\n            return {};\n        throw error_t();\n    }\n\n    ZMQ_NODISCARD\n    recv_result_t recv(message_t &msg, recv_flags flags = recv_flags::none)\n    {\n        const int nbytes =\n          zmq_msg_recv(msg.handle(), _handle, static_cast<int>(flags));\n        if (nbytes >= 0) {\n            assert(msg.size() == static_cast<size_t>(nbytes));\n            return static_cast<size_t>(nbytes);\n        }\n        if (zmq_errno() == EAGAIN)\n            return {};\n        throw error_t();\n    }\n#endif\n\n#if defined(ZMQ_BUILD_DRAFT_API) && ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 2, 0)\n    void join(const char *group)\n    {\n        int rc = zmq_join(_handle, group);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    void leave(const char *group)\n    {\n        int rc = zmq_leave(_handle, group);\n        if (rc != 0)\n            throw error_t();\n    }\n#endif\n\n    ZMQ_NODISCARD void *handle() ZMQ_NOTHROW { return _handle; }\n    ZMQ_NODISCARD const void *handle() const ZMQ_NOTHROW { return _handle; }\n\n    ZMQ_EXPLICIT operator bool() const ZMQ_NOTHROW { return _handle != ZMQ_NULLPTR; }\n    // note: non-const operator bool can be removed once\n    // operator void* is removed from socket_t\n    ZMQ_EXPLICIT operator bool() ZMQ_NOTHROW { return _handle != ZMQ_NULLPTR; }\n\n  protected:\n    void *_handle;\n\n  private:\n    void set_option(int option_, const void *optval_, size_t optvallen_)\n    {\n        int rc = zmq_setsockopt(_handle, option_, optval_, optvallen_);\n        if (rc != 0)\n            throw error_t();\n    }\n\n    void get_option(int option_, void *optval_, size_t *optvallen_) const\n    {\n        int rc = zmq_getsockopt(_handle, option_, optval_, optvallen_);\n        if (rc != 0)\n            throw error_t();\n    }\n};\n} // namespace detail\n\nstruct from_handle_t\n{\n    struct _private\n    {\n    }; // disabling use other than with from_handle\n    ZMQ_CONSTEXPR_FN ZMQ_EXPLICIT from_handle_t(_private /*p*/) ZMQ_NOTHROW {}\n};\n\nZMQ_CONSTEXPR_VAR from_handle_t from_handle =\n  from_handle_t(from_handle_t::_private());\n\n// A non-owning nullable reference to a socket.\n// The reference is invalidated on socket close or destruction.\nclass socket_ref : public detail::socket_base\n{\n  public:\n    socket_ref() ZMQ_NOTHROW : detail::socket_base() {}\n#ifdef ZMQ_CPP11\n    socket_ref(std::nullptr_t) ZMQ_NOTHROW : detail::socket_base() {}\n#endif\n    socket_ref(from_handle_t /*fh*/, void *handle) ZMQ_NOTHROW\n        : detail::socket_base(handle)\n    {\n    }\n};\n\n#ifdef ZMQ_CPP11\ninline bool operator==(socket_ref sr, std::nullptr_t /*p*/) ZMQ_NOTHROW\n{\n    return sr.handle() == nullptr;\n}\ninline bool operator==(std::nullptr_t /*p*/, socket_ref sr) ZMQ_NOTHROW\n{\n    return sr.handle() == nullptr;\n}\ninline bool operator!=(socket_ref sr, std::nullptr_t /*p*/) ZMQ_NOTHROW\n{\n    return !(sr == nullptr);\n}\ninline bool operator!=(std::nullptr_t /*p*/, socket_ref sr) ZMQ_NOTHROW\n{\n    return !(sr == nullptr);\n}\n#endif\n\ninline bool operator==(const detail::socket_base& a, const detail::socket_base& b) ZMQ_NOTHROW\n{\n    return std::equal_to<const void *>()(a.handle(), b.handle());\n}\ninline bool operator!=(const detail::socket_base& a, const detail::socket_base& b) ZMQ_NOTHROW\n{\n    return !(a == b);\n}\ninline bool operator<(const detail::socket_base& a, const detail::socket_base& b) ZMQ_NOTHROW\n{\n    return std::less<const void *>()(a.handle(), b.handle());\n}\ninline bool operator>(const detail::socket_base& a, const detail::socket_base& b) ZMQ_NOTHROW\n{\n    return b < a;\n}\ninline bool operator<=(const detail::socket_base& a, const detail::socket_base& b) ZMQ_NOTHROW\n{\n    return !(a > b);\n}\ninline bool operator>=(const detail::socket_base& a, const detail::socket_base& b) ZMQ_NOTHROW\n{\n    return !(a < b);\n}\n\n} // namespace zmq\n\n#ifdef ZMQ_CPP11\nnamespace std\n{\ntemplate<> struct hash<zmq::socket_ref>\n{\n    size_t operator()(zmq::socket_ref sr) const ZMQ_NOTHROW\n    {\n        return hash<void *>()(sr.handle());\n    }\n};\n} // namespace std\n#endif\n\nnamespace zmq\n{\nclass socket_t : public detail::socket_base\n{\n    friend class monitor_t;\n\n  public:\n    socket_t() ZMQ_NOTHROW : detail::socket_base(ZMQ_NULLPTR), ctxptr(ZMQ_NULLPTR) {}\n\n    socket_t(context_t &context_, int type_) :\n        detail::socket_base(zmq_socket(context_.handle(), type_)),\n        ctxptr(context_.handle())\n    {\n        if (_handle == ZMQ_NULLPTR)\n            throw error_t();\n    }\n\n#ifdef ZMQ_CPP11\n    socket_t(context_t &context_, socket_type type_) :\n        socket_t(context_, static_cast<int>(type_))\n    {\n    }\n#endif\n\n#ifdef ZMQ_HAS_RVALUE_REFS\n    socket_t(socket_t &&rhs) ZMQ_NOTHROW : detail::socket_base(rhs._handle),\n                                           ctxptr(rhs.ctxptr)\n    {\n        rhs._handle = ZMQ_NULLPTR;\n        rhs.ctxptr = ZMQ_NULLPTR;\n    }\n    socket_t &operator=(socket_t &&rhs) ZMQ_NOTHROW\n    {\n        close();\n        std::swap(_handle, rhs._handle);\n        std::swap(ctxptr, rhs.ctxptr);\n        return *this;\n    }\n#endif\n\n    ~socket_t() ZMQ_NOTHROW { close(); }\n\n    operator void *() ZMQ_NOTHROW { return _handle; }\n\n    operator void const *() const ZMQ_NOTHROW { return _handle; }\n\n    void close() ZMQ_NOTHROW\n    {\n        if (_handle == ZMQ_NULLPTR)\n            // already closed\n            return;\n        int rc = zmq_close(_handle);\n        ZMQ_ASSERT(rc == 0);\n        _handle = ZMQ_NULLPTR;\n        ctxptr = ZMQ_NULLPTR;\n    }\n\n    void swap(socket_t &other) ZMQ_NOTHROW\n    {\n        std::swap(_handle, other._handle);\n        std::swap(ctxptr, other.ctxptr);\n    }\n\n    operator socket_ref() ZMQ_NOTHROW { return socket_ref(from_handle, _handle); }\n\n  private:\n    void *ctxptr;\n\n    socket_t(const socket_t &) ZMQ_DELETED_FUNCTION;\n    void operator=(const socket_t &) ZMQ_DELETED_FUNCTION;\n\n    // used by monitor_t\n    socket_t(void *context_, int type_) :\n        detail::socket_base(zmq_socket(context_, type_)), ctxptr(context_)\n    {\n        if (_handle == ZMQ_NULLPTR)\n            throw error_t();\n        if (ctxptr == ZMQ_NULLPTR)\n            throw error_t();\n    }\n};\n\ninline void swap(socket_t &a, socket_t &b) ZMQ_NOTHROW\n{\n    a.swap(b);\n}\n\nZMQ_DEPRECATED(\"from 4.3.1, use proxy taking socket_t objects\")\ninline void proxy(void *frontend, void *backend, void *capture)\n{\n    int rc = zmq_proxy(frontend, backend, capture);\n    if (rc != 0)\n        throw error_t();\n}\n\ninline void\nproxy(socket_ref frontend, socket_ref backend, socket_ref capture = socket_ref())\n{\n    int rc = zmq_proxy(frontend.handle(), backend.handle(), capture.handle());\n    if (rc != 0)\n        throw error_t();\n}\n\n#ifdef ZMQ_HAS_PROXY_STEERABLE\nZMQ_DEPRECATED(\"from 4.3.1, use proxy_steerable taking socket_t objects\")\ninline void\nproxy_steerable(void *frontend, void *backend, void *capture, void *control)\n{\n    int rc = zmq_proxy_steerable(frontend, backend, capture, control);\n    if (rc != 0)\n        throw error_t();\n}\n\ninline void proxy_steerable(socket_ref frontend,\n                            socket_ref backend,\n                            socket_ref capture,\n                            socket_ref control)\n{\n    int rc = zmq_proxy_steerable(frontend.handle(), backend.handle(),\n                                 capture.handle(), control.handle());\n    if (rc != 0)\n        throw error_t();\n}\n#endif\n\nclass monitor_t\n{\n  public:\n    monitor_t() : _socket(), _monitor_socket() {}\n\n    virtual ~monitor_t() { close(); }\n\n#ifdef ZMQ_HAS_RVALUE_REFS\n    monitor_t(monitor_t &&rhs) ZMQ_NOTHROW : _socket(), _monitor_socket()\n    {\n        std::swap(_socket, rhs._socket);\n        std::swap(_monitor_socket, rhs._monitor_socket);\n    }\n\n    monitor_t &operator=(monitor_t &&rhs) ZMQ_NOTHROW\n    {\n        close();\n        _socket = socket_ref();\n        std::swap(_socket, rhs._socket);\n        std::swap(_monitor_socket, rhs._monitor_socket);\n        return *this;\n    }\n#endif\n\n\n    void\n    monitor(socket_t &socket, std::string const &addr, int events = ZMQ_EVENT_ALL)\n    {\n        monitor(socket, addr.c_str(), events);\n    }\n\n    void monitor(socket_t &socket, const char *addr_, int events = ZMQ_EVENT_ALL)\n    {\n        init(socket, addr_, events);\n        while (true) {\n            check_event(-1);\n        }\n    }\n\n    void init(socket_t &socket, std::string const &addr, int events = ZMQ_EVENT_ALL)\n    {\n        init(socket, addr.c_str(), events);\n    }\n\n    void init(socket_t &socket, const char *addr_, int events = ZMQ_EVENT_ALL)\n    {\n        int rc = zmq_socket_monitor(socket.handle(), addr_, events);\n        if (rc != 0)\n            throw error_t();\n\n        _socket = socket;\n        _monitor_socket = socket_t(socket.ctxptr, ZMQ_PAIR);\n        _monitor_socket.connect(addr_);\n\n        on_monitor_started();\n    }\n\n    bool check_event(int timeout = 0)\n    {\n        assert(_monitor_socket);\n\n        zmq::pollitem_t items[] = {\n          {_monitor_socket.handle(), 0, ZMQ_POLLIN, 0},\n        };\n\n        #ifdef ZMQ_CPP11\n        zmq::poll(&items[0], 1, std::chrono::milliseconds(timeout));\n        #else\n        zmq::poll(&items[0], 1, timeout);\n        #endif\n\n        return process_event(items[0].revents);\n    }\n\n#ifdef ZMQ_EVENT_MONITOR_STOPPED\n    void abort()\n    {\n        if (_socket)\n            zmq_socket_monitor(_socket.handle(), ZMQ_NULLPTR, 0);\n\n        _socket = socket_ref();\n    }\n\n    virtual void on_monitor_stopped() {}\n#endif\n    virtual void on_monitor_started() {}\n    virtual void on_event_connected(const zmq_event_t &event_, const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_connect_delayed(const zmq_event_t &event_,\n                                          const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_connect_retried(const zmq_event_t &event_,\n                                          const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_listening(const zmq_event_t &event_, const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_bind_failed(const zmq_event_t &event_, const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_accepted(const zmq_event_t &event_, const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_accept_failed(const zmq_event_t &event_, const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_closed(const zmq_event_t &event_, const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_close_failed(const zmq_event_t &event_, const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_disconnected(const zmq_event_t &event_, const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n#if ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 2, 3)\n    virtual void on_event_handshake_failed_no_detail(const zmq_event_t &event_,\n                                                     const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_handshake_failed_protocol(const zmq_event_t &event_,\n                                                    const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_handshake_failed_auth(const zmq_event_t &event_,\n                                                const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_handshake_succeeded(const zmq_event_t &event_,\n                                              const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n#elif ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 2, 1)\n    virtual void on_event_handshake_failed(const zmq_event_t &event_,\n                                           const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n    virtual void on_event_handshake_succeed(const zmq_event_t &event_,\n                                            const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n#endif\n    virtual void on_event_unknown(const zmq_event_t &event_, const char *addr_)\n    {\n        (void) event_;\n        (void) addr_;\n    }\n\n  protected:    \n    bool process_event(short events)\n    {\n        zmq::message_t eventMsg;\n\n        if (events & ZMQ_POLLIN) {\n            int rc = zmq_msg_recv(eventMsg.handle(), _monitor_socket.handle(), 0);\n            if (rc == -1 && zmq_errno() == ETERM)\n                return false;\n            assert(rc != -1);\n\n        } else {\n            return false;\n        }\n\n#if ZMQ_VERSION_MAJOR >= 4\n        const char *data = static_cast<const char *>(eventMsg.data());\n        zmq_event_t msgEvent;\n        memcpy(&msgEvent.event, data, sizeof(uint16_t));\n        data += sizeof(uint16_t);\n        memcpy(&msgEvent.value, data, sizeof(int32_t));\n        zmq_event_t *event = &msgEvent;\n#else\n        zmq_event_t *event = static_cast<zmq_event_t *>(eventMsg.data());\n#endif\n\n#ifdef ZMQ_NEW_MONITOR_EVENT_LAYOUT\n        zmq::message_t addrMsg;\n        int rc = zmq_msg_recv(addrMsg.handle(), _monitor_socket.handle(), 0);\n        if (rc == -1 && zmq_errno() == ETERM) {\n            return false;\n        }\n\n        assert(rc != -1);\n        std::string address = addrMsg.to_string();\n#else\n        // Bit of a hack, but all events in the zmq_event_t union have the same layout so this will work for all event types.\n        std::string address = event->data.connected.addr;\n#endif\n\n#ifdef ZMQ_EVENT_MONITOR_STOPPED\n        if (event->event == ZMQ_EVENT_MONITOR_STOPPED) {\n            on_monitor_stopped();\n            return false;\n        }\n\n#endif\n\n        switch (event->event) {\n            case ZMQ_EVENT_CONNECTED:\n                on_event_connected(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_CONNECT_DELAYED:\n                on_event_connect_delayed(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_CONNECT_RETRIED:\n                on_event_connect_retried(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_LISTENING:\n                on_event_listening(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_BIND_FAILED:\n                on_event_bind_failed(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_ACCEPTED:\n                on_event_accepted(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_ACCEPT_FAILED:\n                on_event_accept_failed(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_CLOSED:\n                on_event_closed(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_CLOSE_FAILED:\n                on_event_close_failed(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_DISCONNECTED:\n                on_event_disconnected(*event, address.c_str());\n                break;\n#if ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 3, 0) || (defined(ZMQ_BUILD_DRAFT_API) && ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 2, 3))\n            case ZMQ_EVENT_HANDSHAKE_FAILED_NO_DETAIL:\n                on_event_handshake_failed_no_detail(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_HANDSHAKE_FAILED_PROTOCOL:\n                on_event_handshake_failed_protocol(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_HANDSHAKE_FAILED_AUTH:\n                on_event_handshake_failed_auth(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_HANDSHAKE_SUCCEEDED:\n                on_event_handshake_succeeded(*event, address.c_str());\n                break;\n#elif defined(ZMQ_BUILD_DRAFT_API) && ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 2, 1)\n            case ZMQ_EVENT_HANDSHAKE_FAILED:\n                on_event_handshake_failed(*event, address.c_str());\n                break;\n            case ZMQ_EVENT_HANDSHAKE_SUCCEED:\n                on_event_handshake_succeed(*event, address.c_str());\n                break;\n#endif\n            default:\n                on_event_unknown(*event, address.c_str());\n                break;\n        }\n\n        return true;\n    }\n\n    socket_ref monitor_socket() {return _monitor_socket;}\n\n  private:\n    monitor_t(const monitor_t &) ZMQ_DELETED_FUNCTION;\n    void operator=(const monitor_t &) ZMQ_DELETED_FUNCTION;\n\n    socket_ref _socket;\n    socket_t _monitor_socket;\n\n    void close() ZMQ_NOTHROW\n    {\n        if (_socket)\n            zmq_socket_monitor(_socket.handle(), ZMQ_NULLPTR, 0);\n        _monitor_socket.close();\n    }\n};\n\n#if defined(ZMQ_BUILD_DRAFT_API) && defined(ZMQ_CPP11) && defined(ZMQ_HAVE_POLLER)\n\n// polling events\nenum class event_flags : short\n{\n    none = 0,\n    pollin = ZMQ_POLLIN,\n    pollout = ZMQ_POLLOUT,\n    pollerr = ZMQ_POLLERR,\n    pollpri = ZMQ_POLLPRI\n};\n\nconstexpr event_flags operator|(event_flags a, event_flags b) noexcept\n{\n    return detail::enum_bit_or(a, b);\n}\nconstexpr event_flags operator&(event_flags a, event_flags b) noexcept\n{\n    return detail::enum_bit_and(a, b);\n}\nconstexpr event_flags operator^(event_flags a, event_flags b) noexcept\n{\n    return detail::enum_bit_xor(a, b);\n}\nconstexpr event_flags operator~(event_flags a) noexcept\n{\n    return detail::enum_bit_not(a);\n}\n\nstruct no_user_data;\n\n// layout compatible with zmq_poller_event_t\ntemplate<class T = no_user_data> struct poller_event\n{\n    socket_ref socket;\n    ::zmq::fd_t fd;\n    T *user_data;\n    event_flags events;\n};\n\ntemplate<typename T = no_user_data> class poller_t\n{\n  public:\n    using event_type = poller_event<T>;\n\n    poller_t() : poller_ptr(zmq_poller_new())\n    {\n        if (!poller_ptr)\n            throw error_t();\n    }\n\n    template<\n      typename Dummy = void,\n      typename =\n        typename std::enable_if<!std::is_same<T, no_user_data>::value, Dummy>::type>\n    void add(zmq::socket_ref socket, event_flags events, T *user_data)\n    {\n        add_impl(socket, events, user_data);\n    }\n\n    void add(zmq::socket_ref socket, event_flags events)\n    {\n        add_impl(socket, events, nullptr);\n    }\n\n    template<\n      typename Dummy = void,\n      typename =\n        typename std::enable_if<!std::is_same<T, no_user_data>::value, Dummy>::type>\n    void add(fd_t fd, event_flags events, T *user_data)\n    {\n        add_impl(fd, events, user_data);\n    }\n\n    void add(fd_t fd, event_flags events) { add_impl(fd, events, nullptr); }\n\n    void remove(zmq::socket_ref socket)\n    {\n        if (0 != zmq_poller_remove(poller_ptr.get(), socket.handle())) {\n            throw error_t();\n        }\n    }\n\n    void remove(fd_t fd)\n    {\n        if (0 != zmq_poller_remove_fd(poller_ptr.get(), fd)) {\n            throw error_t();\n        }\n    }\n\n    void modify(zmq::socket_ref socket, event_flags events)\n    {\n        if (0\n            != zmq_poller_modify(poller_ptr.get(), socket.handle(),\n                                 static_cast<short>(events))) {\n            throw error_t();\n        }\n    }\n\n    void modify(fd_t fd, event_flags events)\n    {\n        if (0\n            != zmq_poller_modify_fd(poller_ptr.get(), fd,\n                                 static_cast<short>(events))) {\n            throw error_t();\n        }\n    }\n\n    template <typename Sequence>\n    size_t wait_all(Sequence &poller_events,\n                    const std::chrono::milliseconds timeout)\n    {\n        static_assert(std::is_same<typename Sequence::value_type, event_type>::value,\n                      \"Sequence::value_type must be of poller_t::event_type\");\n        int rc = zmq_poller_wait_all(\n          poller_ptr.get(),\n          reinterpret_cast<zmq_poller_event_t *>(poller_events.data()),\n          static_cast<int>(poller_events.size()),\n          static_cast<long>(timeout.count()));\n        if (rc > 0)\n            return static_cast<size_t>(rc);\n\n#if ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 2, 3)\n        if (zmq_errno() == EAGAIN)\n#else\n        if (zmq_errno() == ETIMEDOUT)\n#endif\n            return 0;\n\n        throw error_t();\n    }\n\n#if ZMQ_VERSION >= ZMQ_MAKE_VERSION(4, 3, 3)\n    size_t size() const noexcept\n    {\n        int rc = zmq_poller_size(const_cast<void *>(poller_ptr.get()));\n        ZMQ_ASSERT(rc >= 0);\n        return static_cast<size_t>(std::max(rc, 0));\n    }\n#endif\n\n  private:\n    struct destroy_poller_t\n    {\n        void operator()(void *ptr) noexcept\n        {\n            int rc = zmq_poller_destroy(&ptr);\n            ZMQ_ASSERT(rc == 0);\n        }\n    };\n\n    std::unique_ptr<void, destroy_poller_t> poller_ptr;\n\n    void add_impl(zmq::socket_ref socket, event_flags events, T *user_data)\n    {\n        if (0\n            != zmq_poller_add(poller_ptr.get(), socket.handle(), user_data,\n                              static_cast<short>(events))) {\n            throw error_t();\n        }\n    }\n\n    void add_impl(fd_t fd, event_flags events, T *user_data)\n    {\n        if (0\n            != zmq_poller_add_fd(poller_ptr.get(), fd, user_data,\n                                 static_cast<short>(events))) {\n            throw error_t();\n        }\n    }\n};\n#endif //  defined(ZMQ_BUILD_DRAFT_API) && defined(ZMQ_CPP11) && defined(ZMQ_HAVE_POLLER)\n\ninline std::ostream &operator<<(std::ostream &os, const message_t &msg)\n{\n    return os << msg.str();\n}\n\n} // namespace zmq\n\n#endif // __ZMQ_HPP_INCLUDED__\n"
        },
        {
          "name": "zmq_addon.hpp",
          "type": "blob",
          "size": 25.626953125,
          "content": "/*\n    Copyright (c) 2016-2017 ZeroMQ community\n    Copyright (c) 2016 VOCA AS / Harald Nøkland\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to\n    deal in the Software without restriction, including without limitation the\n    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n    sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n    IN THE SOFTWARE.\n*/\n\n#ifndef __ZMQ_ADDON_HPP_INCLUDED__\n#define __ZMQ_ADDON_HPP_INCLUDED__\n\n#include \"zmq.hpp\"\n\n#include <deque>\n#include <iomanip>\n#include <sstream>\n#include <stdexcept>\n#ifdef ZMQ_CPP11\n#include <limits>\n#include <functional>\n#include <unordered_map>\n\nnamespace zmq\n{\n\t// socket ref or native file descriptor for poller\n\tclass poller_ref_t\n\t{\n\tpublic:\n\t\tenum RefType\n\t\t{\n\t\t\tRT_SOCKET,\n\t\t\tRT_FD\n\t\t};\n\n\t\tpoller_ref_t() : poller_ref_t(socket_ref{})\n\t\t{}\n\n\t\tpoller_ref_t(const zmq::socket_ref& socket) : data{RT_SOCKET, socket, {}}\n\t\t{}\n\n\t\tpoller_ref_t(zmq::fd_t fd) : data{RT_FD, {}, fd}\n\t\t{}\n\n\t\tsize_t hash() const ZMQ_NOTHROW\t\n\t\t{\n\t\t\tstd::size_t h = 0;\n\t\t\thash_combine(h, std::get<0>(data));\n        \thash_combine(h, std::get<1>(data));\n        \thash_combine(h, std::get<2>(data));\n\t\t\treturn h;\n\t\t}\n\n\t\tbool operator == (const poller_ref_t& o) const ZMQ_NOTHROW\n\t\t{\n\t\t\treturn data == o.data;\n\t\t}\n\n\tprivate:\n\t\ttemplate <class T>\n\t\tstatic void hash_combine(std::size_t& seed, const T& v) ZMQ_NOTHROW\n\t\t{\n    \t\tstd::hash<T> hasher;\n    \t\tseed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t\t}\n\n\t\tstd::tuple<int, zmq::socket_ref, zmq::fd_t> data;\n\n\t}; // class poller_ref_t\n\n} // namespace zmq\n\n// std::hash<> specialization for std::unordered_map\ntemplate <> struct std::hash<zmq::poller_ref_t>\n{\n\tsize_t operator()(const zmq::poller_ref_t& ref) const ZMQ_NOTHROW\n\t{\n\t\treturn ref.hash();\n\t}\n};\n#endif //  ZMQ_CPP11\n\nnamespace zmq\n{\n#ifdef ZMQ_CPP11\n\nnamespace detail\n{\ntemplate<bool CheckN, class OutputIt>\nrecv_result_t\nrecv_multipart_n(socket_ref s, OutputIt out, size_t n, recv_flags flags)\n{\n    size_t msg_count = 0;\n    message_t msg;\n    while (true) {\n        if ZMQ_CONSTEXPR_IF (CheckN) {\n            if (msg_count >= n)\n                throw std::runtime_error(\n                  \"Too many message parts in recv_multipart_n\");\n        }\n        if (!s.recv(msg, flags)) {\n            // zmq ensures atomic delivery of messages\n            assert(msg_count == 0);\n            return {};\n        }\n        ++msg_count;\n        const bool more = msg.more();\n        *out++ = std::move(msg);\n        if (!more)\n            break;\n    }\n    return msg_count;\n}\n\ninline bool is_little_endian()\n{\n    const uint16_t i = 0x01;\n    return *reinterpret_cast<const uint8_t *>(&i) == 0x01;\n}\n\ninline void write_network_order(unsigned char *buf, const uint32_t value)\n{\n    if (is_little_endian()) {\n        ZMQ_CONSTEXPR_VAR uint32_t mask = (std::numeric_limits<std::uint8_t>::max)();\n        *buf++ = static_cast<unsigned char>((value >> 24) & mask);\n        *buf++ = static_cast<unsigned char>((value >> 16) & mask);\n        *buf++ = static_cast<unsigned char>((value >> 8) & mask);\n        *buf++ = static_cast<unsigned char>(value & mask);\n    } else {\n        std::memcpy(buf, &value, sizeof(value));\n    }\n}\n\ninline uint32_t read_u32_network_order(const unsigned char *buf)\n{\n    if (is_little_endian()) {\n        return (static_cast<uint32_t>(buf[0]) << 24)\n               + (static_cast<uint32_t>(buf[1]) << 16)\n               + (static_cast<uint32_t>(buf[2]) << 8)\n               + static_cast<uint32_t>(buf[3]);\n    } else {\n        uint32_t value;\n        std::memcpy(&value, buf, sizeof(value));\n        return value;\n    }\n}\n} // namespace detail\n\n/*  Receive a multipart message.\n    \n    Writes the zmq::message_t objects to OutputIterator out.\n    The out iterator must handle an unspecified number of writes,\n    e.g. by using std::back_inserter.\n    \n    Returns: the number of messages received or nullopt (on EAGAIN).\n    Throws: if recv throws. Any exceptions thrown\n    by the out iterator will be propagated and the message\n    may have been only partially received with pending\n    message parts. It is adviced to close this socket in that event.\n*/\ntemplate<class OutputIt>\nZMQ_NODISCARD recv_result_t recv_multipart(socket_ref s,\n                                           OutputIt out,\n                                           recv_flags flags = recv_flags::none)\n{\n    return detail::recv_multipart_n<false>(s, std::move(out), 0, flags);\n}\n\n/*  Receive a multipart message.\n    \n    Writes at most n zmq::message_t objects to OutputIterator out.\n    If the number of message parts of the incoming message exceeds n\n    then an exception will be thrown.\n    \n    Returns: the number of messages received or nullopt (on EAGAIN).\n    Throws: if recv throws. Throws std::runtime_error if the number\n    of message parts exceeds n (exactly n messages will have been written\n    to out). Any exceptions thrown\n    by the out iterator will be propagated and the message\n    may have been only partially received with pending\n    message parts. It is adviced to close this socket in that event.\n*/\ntemplate<class OutputIt>\nZMQ_NODISCARD recv_result_t recv_multipart_n(socket_ref s,\n                                             OutputIt out,\n                                             size_t n,\n                                             recv_flags flags = recv_flags::none)\n{\n    return detail::recv_multipart_n<true>(s, std::move(out), n, flags);\n}\n\n/*  Send a multipart message.\n    \n    The range must be a ForwardRange of zmq::message_t,\n    zmq::const_buffer or zmq::mutable_buffer.\n    The flags may be zmq::send_flags::sndmore if there are \n    more message parts to be sent after the call to this function.\n    \n    Returns: the number of messages sent (exactly msgs.size()) or nullopt (on EAGAIN).\n    Throws: if send throws. Any exceptions thrown\n    by the msgs range will be propagated and the message\n    may have been only partially sent. It is adviced to close this socket in that event.\n*/\ntemplate<class Range\n#ifndef ZMQ_CPP11_PARTIAL\n         ,\n         typename = typename std::enable_if<\n           detail::is_range<Range>::value\n           && (std::is_same<detail::range_value_t<Range>, message_t>::value\n               || detail::is_buffer<detail::range_value_t<Range>>::value)>::type\n#endif\n         >\nsend_result_t\nsend_multipart(socket_ref s, Range &&msgs, send_flags flags = send_flags::none)\n{\n    using std::begin;\n    using std::end;\n    auto it = begin(msgs);\n    const auto end_it = end(msgs);\n    size_t msg_count = 0;\n    while (it != end_it) {\n        const auto next = std::next(it);\n        const auto msg_flags =\n          flags | (next == end_it ? send_flags::none : send_flags::sndmore);\n        if (!s.send(*it, msg_flags)) {\n            // zmq ensures atomic delivery of messages\n            assert(it == begin(msgs));\n            return {};\n        }\n        ++msg_count;\n        it = next;\n    }\n    return msg_count;\n}\n\n/* Encode a multipart message.\n\n   The range must be a ForwardRange of zmq::message_t.  A\n   zmq::multipart_t or STL container may be passed for encoding.\n\n   Returns: a zmq::message_t holding the encoded multipart data.\n\n   Throws: std::range_error is thrown if the size of any single part\n   can not fit in an unsigned 32 bit integer.\n\n   The encoding is compatible with that used by the CZMQ function\n   zmsg_encode(), see https://rfc.zeromq.org/spec/50/.\n   Each part consists of a size followed by the data.\n   These are placed contiguously into the output message.  A part of\n   size less than 255 bytes will have a single byte size value.\n   Larger parts will have a five byte size value with the first byte\n   set to 0xFF and the remaining four bytes holding the size of the\n   part's data.\n*/\ntemplate<class Range\n#ifndef ZMQ_CPP11_PARTIAL\n         ,\n         typename = typename std::enable_if<\n           detail::is_range<Range>::value\n           && (std::is_same<detail::range_value_t<Range>, message_t>::value\n               || detail::is_buffer<detail::range_value_t<Range>>::value)>::type\n#endif\n         >\nmessage_t encode(const Range &parts)\n{\n    size_t mmsg_size = 0;\n\n    // First pass check sizes\n    for (const auto &part : parts) {\n        const size_t part_size = part.size();\n        if (part_size > (std::numeric_limits<std::uint32_t>::max)()) {\n            // Size value must fit into uint32_t.\n            throw std::range_error(\"Invalid size, message part too large\");\n        }\n        const size_t count_size =\n          part_size < (std::numeric_limits<std::uint8_t>::max)() ? 1 : 5;\n        mmsg_size += part_size + count_size;\n    }\n\n    message_t encoded(mmsg_size);\n    unsigned char *buf = encoded.data<unsigned char>();\n    for (const auto &part : parts) {\n        const uint32_t part_size = static_cast<uint32_t>(part.size());\n        const unsigned char *part_data =\n          static_cast<const unsigned char *>(part.data());\n\n        if (part_size < (std::numeric_limits<std::uint8_t>::max)()) {\n            // small part\n            *buf++ = (unsigned char) part_size;\n        } else {\n            // big part\n            *buf++ = (std::numeric_limits<uint8_t>::max)();\n            detail::write_network_order(buf, part_size);\n            buf += sizeof(part_size);\n        }\n        std::memcpy(buf, part_data, part_size);\n        buf += part_size;\n    }\n\n    assert(static_cast<size_t>(buf - encoded.data<unsigned char>()) == mmsg_size);\n    return encoded;\n}\n\n/*  Decode an encoded message to multiple parts.\n\n    The given output iterator must be a ForwardIterator to a container\n    holding zmq::message_t such as a zmq::multipart_t or various STL\n    containers.\n\n    Returns the ForwardIterator advanced once past the last decoded\n    part.\n\n    Throws: a std::out_of_range is thrown if the encoded part sizes\n    lead to exceeding the message data bounds.\n\n    The decoding assumes the message is encoded in the manner\n    performed by zmq::encode(), see https://rfc.zeromq.org/spec/50/.\n */\ntemplate<class OutputIt> OutputIt decode(const message_t &encoded, OutputIt out)\n{\n    const unsigned char *source = encoded.data<unsigned char>();\n    const unsigned char *const limit = source + encoded.size();\n\n    while (source < limit) {\n        size_t part_size = *source++;\n        if (part_size == (std::numeric_limits<std::uint8_t>::max)()) {\n            if (static_cast<size_t>(limit - source) < sizeof(uint32_t)) {\n                throw std::out_of_range(\n                  \"Malformed encoding, overflow in reading size\");\n            }\n            part_size = detail::read_u32_network_order(source);\n            // the part size is allowed to be less than 0xFF\n            source += sizeof(uint32_t);\n        }\n\n        if (static_cast<size_t>(limit - source) < part_size) {\n            throw std::out_of_range(\"Malformed encoding, overflow in reading part\");\n        }\n        *out = message_t(source, part_size);\n        ++out;\n        source += part_size;\n    }\n\n    assert(source == limit);\n    return out;\n}\n\n#endif\n\n\n#ifdef ZMQ_HAS_RVALUE_REFS\n\n/*\n    This class handles multipart messaging. It is the C++ equivalent of zmsg.h,\n    which is part of CZMQ (the high-level C binding). Furthermore, it is a major\n    improvement compared to zmsg.hpp, which is part of the examples in the ØMQ\n    Guide. Unnecessary copying is avoided by using move semantics to efficiently\n    add/remove parts.\n*/\nclass multipart_t\n{\n  private:\n    std::deque<message_t> m_parts;\n\n  public:\n    typedef std::deque<message_t>::value_type value_type;\n\n    typedef std::deque<message_t>::iterator iterator;\n    typedef std::deque<message_t>::const_iterator const_iterator;\n\n    typedef std::deque<message_t>::reverse_iterator reverse_iterator;\n    typedef std::deque<message_t>::const_reverse_iterator const_reverse_iterator;\n\n    // Default constructor\n    multipart_t() {}\n\n    // Construct from socket receive\n    multipart_t(socket_ref socket) { recv(socket); }\n\n    // Construct from memory block\n    multipart_t(const void *src, size_t size) { addmem(src, size); }\n\n    // Construct from string\n    multipart_t(const std::string &string) { addstr(string); }\n\n    // Construct from message part\n    multipart_t(message_t &&message) { add(std::move(message)); }\n\n    // Move constructor\n    multipart_t(multipart_t &&other) ZMQ_NOTHROW { m_parts = std::move(other.m_parts); }\n\n    // Move assignment operator\n    multipart_t &operator=(multipart_t &&other) ZMQ_NOTHROW\n    {\n        m_parts = std::move(other.m_parts);\n        return *this;\n    }\n\n    // Destructor\n    virtual ~multipart_t() { clear(); }\n\n    message_t &operator[](size_t n) { return m_parts[n]; }\n\n    const message_t &operator[](size_t n) const { return m_parts[n]; }\n\n    message_t &at(size_t n) { return m_parts.at(n); }\n\n    const message_t &at(size_t n) const { return m_parts.at(n); }\n\n    iterator begin() { return m_parts.begin(); }\n\n    const_iterator begin() const { return m_parts.begin(); }\n\n    const_iterator cbegin() const { return m_parts.cbegin(); }\n\n    reverse_iterator rbegin() { return m_parts.rbegin(); }\n\n    const_reverse_iterator rbegin() const { return m_parts.rbegin(); }\n\n    iterator end() { return m_parts.end(); }\n\n    const_iterator end() const { return m_parts.end(); }\n\n    const_iterator cend() const { return m_parts.cend(); }\n\n    reverse_iterator rend() { return m_parts.rend(); }\n\n    const_reverse_iterator rend() const { return m_parts.rend(); }\n\n    // Delete all parts\n    void clear() { m_parts.clear(); }\n\n    // Get number of parts\n    size_t size() const { return m_parts.size(); }\n\n    // Check if number of parts is zero\n    bool empty() const { return m_parts.empty(); }\n\n    // Receive multipart message from socket\n    bool recv(socket_ref socket, int flags = 0)\n    {\n        clear();\n        bool more = true;\n        while (more) {\n            message_t message;\n#ifdef ZMQ_CPP11\n            if (!socket.recv(message, static_cast<recv_flags>(flags)))\n                return false;\n#else\n            if (!socket.recv(&message, flags))\n                return false;\n#endif\n            more = message.more();\n            add(std::move(message));\n        }\n        return true;\n    }\n\n    // Send multipart message to socket\n    bool send(socket_ref socket, int flags = 0)\n    {\n        flags &= ~(ZMQ_SNDMORE);\n        bool more = size() > 0;\n        while (more) {\n            message_t message = pop();\n            more = size() > 0;\n#ifdef ZMQ_CPP11\n            if (!socket.send(message, static_cast<send_flags>(\n                                        (more ? ZMQ_SNDMORE : 0) | flags)))\n                return false;\n#else\n            if (!socket.send(message, (more ? ZMQ_SNDMORE : 0) | flags))\n                return false;\n#endif\n        }\n        clear();\n        return true;\n    }\n\n    // Concatenate other multipart to front\n    void prepend(multipart_t &&other)\n    {\n        while (!other.empty())\n            push(other.remove());\n    }\n\n    // Concatenate other multipart to back\n    void append(multipart_t &&other)\n    {\n        while (!other.empty())\n            add(other.pop());\n    }\n\n    // Push memory block to front\n    void pushmem(const void *src, size_t size)\n    {\n        m_parts.push_front(message_t(src, size));\n    }\n\n    // Push memory block to back\n    void addmem(const void *src, size_t size)\n    {\n        m_parts.push_back(message_t(src, size));\n    }\n\n    // Push string to front\n    void pushstr(const std::string &string)\n    {\n        m_parts.push_front(message_t(string.data(), string.size()));\n    }\n\n    // Push string to back\n    void addstr(const std::string &string)\n    {\n        m_parts.push_back(message_t(string.data(), string.size()));\n    }\n\n    // Push type (fixed-size) to front\n    template<typename T> void pushtyp(const T &type)\n    {\n        static_assert(!std::is_same<T, std::string>::value,\n                      \"Use pushstr() instead of pushtyp<std::string>()\");\n        m_parts.push_front(message_t(&type, sizeof(type)));\n    }\n\n    // Push type (fixed-size) to back\n    template<typename T> void addtyp(const T &type)\n    {\n        static_assert(!std::is_same<T, std::string>::value,\n                      \"Use addstr() instead of addtyp<std::string>()\");\n        m_parts.push_back(message_t(&type, sizeof(type)));\n    }\n\n    // Push message part to front\n    void push(message_t &&message) { m_parts.push_front(std::move(message)); }\n\n    // Push message part to back\n    void add(message_t &&message) { m_parts.push_back(std::move(message)); }\n\n    // Alias to allow std::back_inserter()\n    void push_back(message_t &&message) { m_parts.push_back(std::move(message)); }\n\n    // Pop string from front\n    std::string popstr()\n    {\n        std::string string(m_parts.front().data<char>(), m_parts.front().size());\n        m_parts.pop_front();\n        return string;\n    }\n\n    // Pop type (fixed-size) from front\n    template<typename T> T poptyp()\n    {\n        static_assert(!std::is_same<T, std::string>::value,\n                      \"Use popstr() instead of poptyp<std::string>()\");\n        if (sizeof(T) != m_parts.front().size())\n            throw std::runtime_error(\n              \"Invalid type, size does not match the message size\");\n        T type = *m_parts.front().data<T>();\n        m_parts.pop_front();\n        return type;\n    }\n\n    // Pop message part from front\n    message_t pop()\n    {\n        message_t message = std::move(m_parts.front());\n        m_parts.pop_front();\n        return message;\n    }\n\n    // Pop message part from back\n    message_t remove()\n    {\n        message_t message = std::move(m_parts.back());\n        m_parts.pop_back();\n        return message;\n    }\n\n    // get message part from front\n    const message_t &front() { return m_parts.front(); }\n\n    // get message part from back\n    const message_t &back() { return m_parts.back(); }\n\n    // Get pointer to a specific message part\n    const message_t *peek(size_t index) const { return &m_parts[index]; }\n\n    // Get a string copy of a specific message part\n    std::string peekstr(size_t index) const\n    {\n        std::string string(m_parts[index].data<char>(), m_parts[index].size());\n        return string;\n    }\n\n    // Peek type (fixed-size) from front\n    template<typename T> T peektyp(size_t index) const\n    {\n        static_assert(!std::is_same<T, std::string>::value,\n                      \"Use peekstr() instead of peektyp<std::string>()\");\n        if (sizeof(T) != m_parts[index].size())\n            throw std::runtime_error(\n              \"Invalid type, size does not match the message size\");\n        T type = *m_parts[index].data<T>();\n        return type;\n    }\n\n    // Create multipart from type (fixed-size)\n    template<typename T> static multipart_t create(const T &type)\n    {\n        multipart_t multipart;\n        multipart.addtyp(type);\n        return multipart;\n    }\n\n    // Copy multipart\n    multipart_t clone() const\n    {\n        multipart_t multipart;\n        for (size_t i = 0; i < size(); i++)\n            multipart.addmem(m_parts[i].data(), m_parts[i].size());\n        return multipart;\n    }\n\n    // Dump content to string\n    std::string str() const\n    {\n        std::stringstream ss;\n        for (size_t i = 0; i < m_parts.size(); i++) {\n            const unsigned char *data = m_parts[i].data<unsigned char>();\n            size_t size = m_parts[i].size();\n\n            // Dump the message as text or binary\n            bool isText = true;\n            for (size_t j = 0; j < size; j++) {\n                if (data[j] < 32 || data[j] > 127) {\n                    isText = false;\n                    break;\n                }\n            }\n            ss << \"\\n[\" << std::dec << std::setw(3) << std::setfill('0') << size\n               << \"] \";\n            if (size >= 1000) {\n                ss << \"... (too big to print)\";\n                continue;\n            }\n            for (size_t j = 0; j < size; j++) {\n                if (isText)\n                    ss << static_cast<char>(data[j]);\n                else\n                    ss << std::hex << std::setw(2) << std::setfill('0')\n                       << static_cast<short>(data[j]);\n            }\n        }\n        return ss.str();\n    }\n\n    // Check if equal to other multipart\n    bool equal(const multipart_t *other) const ZMQ_NOTHROW\n    {\n        return *this == *other;\n    }\n\n    bool operator==(const multipart_t &other) const ZMQ_NOTHROW\n    {\n        if (size() != other.size())\n            return false;\n        for (size_t i = 0; i < size(); i++)\n            if (at(i) != other.at(i))\n                return false;\n        return true;\n    }\n\n    bool operator!=(const multipart_t &other) const ZMQ_NOTHROW\n    {\n        return !(*this == other);\n    }\n\n#ifdef ZMQ_CPP11\n\n    // Return single part message_t encoded from this multipart_t.\n    message_t encode() const { return zmq::encode(*this); }\n\n    // Decode encoded message into multiple parts and append to self.\n    void decode_append(const message_t &encoded)\n    {\n        zmq::decode(encoded, std::back_inserter(*this));\n    }\n\n    // Return a new multipart_t containing the decoded message_t.\n    static multipart_t decode(const message_t &encoded)\n    {\n        multipart_t tmp;\n        zmq::decode(encoded, std::back_inserter(tmp));\n        return tmp;\n    }\n\n#endif\n\n  private:\n    // Disable implicit copying (moving is more efficient)\n    multipart_t(const multipart_t &other) ZMQ_DELETED_FUNCTION;\n    void operator=(const multipart_t &other) ZMQ_DELETED_FUNCTION;\n}; // class multipart_t\n\ninline std::ostream &operator<<(std::ostream &os, const multipart_t &msg)\n{\n    return os << msg.str();\n}\n\n#endif // ZMQ_HAS_RVALUE_REFS\n\n#if defined(ZMQ_BUILD_DRAFT_API) && defined(ZMQ_CPP11) && defined(ZMQ_HAVE_POLLER)\nclass active_poller_t\n{\n  public:\n    active_poller_t() = default;\n    ~active_poller_t() = default;\n\n    active_poller_t(const active_poller_t &) = delete;\n    active_poller_t &operator=(const active_poller_t &) = delete;\n\n    active_poller_t(active_poller_t &&src) = default;\n    active_poller_t &operator=(active_poller_t &&src) = default;\n\n    using handler_type = std::function<void(event_flags)>;\n\n    void add(zmq::socket_ref socket, event_flags events, handler_type handler)\n    {\n        const poller_ref_t ref{socket};\n\n        if (!handler)\n            throw std::invalid_argument(\"null handler in active_poller_t::add (socket)\");\n        auto ret = handlers.emplace(\n          ref, std::make_shared<handler_type>(std::move(handler)));\n        if (!ret.second)\n            throw error_t(EINVAL); // already added\n        try {\n            base_poller.add(socket, events, ret.first->second.get());\n            need_rebuild = true;\n        }\n        catch (...) {\n            // rollback\n            handlers.erase(ref);\n            throw;\n        }\n    }\n\n    void add(fd_t fd, event_flags events, handler_type handler)\n    {\n        const poller_ref_t ref{fd};\n\n        if (!handler)\n            throw std::invalid_argument(\"null handler in active_poller_t::add (fd)\");\n        auto ret = handlers.emplace(\n          ref, std::make_shared<handler_type>(std::move(handler)));\n        if (!ret.second)\n            throw error_t(EINVAL); // already added\n        try {\n            base_poller.add(fd, events, ret.first->second.get());\n            need_rebuild = true;\n        }\n        catch (...) {\n            // rollback\n            handlers.erase(ref);\n            throw;\n        }\n    }\n\n    void remove(zmq::socket_ref socket)\n    {\n        base_poller.remove(socket);\n        handlers.erase(socket);\n        need_rebuild = true;\n    }\n\n    void remove(fd_t fd)\n    {\n        base_poller.remove(fd);\n        handlers.erase(fd);\n        need_rebuild = true;\n    }\n\n    void modify(zmq::socket_ref socket, event_flags events)\n    {\n        base_poller.modify(socket, events);\n    }\n\n    void modify(fd_t fd, event_flags events)\n    {\n        base_poller.modify(fd, events);\n    }\n\n    size_t wait(std::chrono::milliseconds timeout)\n    {\n        if (need_rebuild) {\n            poller_events.resize(handlers.size());\n            poller_handlers.clear();\n            poller_handlers.reserve(handlers.size());\n            for (const auto &handler : handlers) {\n                poller_handlers.push_back(handler.second);\n            }\n            need_rebuild = false;\n        }\n        const auto count = base_poller.wait_all(poller_events, timeout);\n        std::for_each(poller_events.begin(),\n                      poller_events.begin() + static_cast<ptrdiff_t>(count),\n                      [](decltype(base_poller)::event_type &event) {\n                          assert(event.user_data != nullptr);\n                          (*event.user_data)(event.events);\n                      });\n        return count;\n    }\n\n    ZMQ_NODISCARD bool empty() const noexcept { return handlers.empty(); }\n\n    size_t size() const noexcept { return handlers.size(); }\n\n  private:\n    bool need_rebuild{false};\n\n    poller_t<handler_type> base_poller{};\n\n    std::unordered_map<zmq::poller_ref_t, std::shared_ptr<handler_type>> handlers{};\n\n    std::vector<decltype(base_poller)::event_type> poller_events{};\n    std::vector<std::shared_ptr<handler_type>> poller_handlers{};\n};     // class active_poller_t\n#endif //  defined(ZMQ_BUILD_DRAFT_API) && defined(ZMQ_CPP11) && defined(ZMQ_HAVE_POLLER)\n\n\n} // namespace zmq\n\n#endif // __ZMQ_ADDON_HPP_INCLUDED__\n"
        }
      ]
    }
  ]
}