{
  "metadata": {
    "timestamp": 1736565464448,
    "page": 318,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "microsoft/GW-BASIC",
      "stars": 3238,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 5.861328125,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.rsuser\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Mono auto generated files\nmono_crash.*\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\n[Aa][Rr][Mm]/\n[Aa][Rr][Mm]64/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n[Ll]ogs/\n\n# Visual Studio 2015/2017 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# Visual Studio 2017 auto generated files\nGenerated\\ Files/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUnit\n*.VisualState.xml\nTestResult.xml\nnunit-*.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts/\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n\n# StyleCop\nStyleCopReport.xml\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_h.h\n*.ilk\n*.meta\n*.obj\n*.iobj\n*.pch\n*.pdb\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*_wpftmp.csproj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover/*\n!.axoCover/settings.json\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# NuGet Symbol Packages\n*.snupkg\n# The packages folder can be ignored because of Package Restore\n**/[Pp]ackages/*\n# except build/, which is used as an MSBuild target.\n!**/[Pp]ackages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/[Pp]ackages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n*.appxbundle\n*.appxupload\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!?*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Including strong name files can present a security risk\n# (https://github.com/github/gitignore/pull/2483#issue-259490424)\n#*.snk\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\nServiceFabricBackup/\n*.rptproj.bak\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n*.rptproj.rsuser\n*- [Bb]ackup.rdl\n*- [Bb]ackup ([0-9]).rdl\n*- [Bb]ackup ([0-9][0-9]).rdl\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# CodeRush personal settings\n.cr/personal\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover/\n\n# Azure Stream Analytics local run output\nASALocalRun/\n\n# MSBuild Binary and Structured Log\n*.binlog\n\n# NVidia Nsight GPU debugger configuration file\n*.nvuser\n\n# MFractors (Xamarin productivity tool) working folder\n.mfractor/\n\n# Local History for Visual Studio\n.localhistory/\n\n# BeatPulse healthcheck temp database\nhealthchecksdb\n\n# Backup folder for Package Reference Convert tool in Visual Studio 2017\nMigrationBackup/\n\n# Ionide (cross platform F# VS Code tools) working folder\n.ionide/\n"
        },
        {
          "name": "ADVGRP.ASM",
          "type": "blob",
          "size": 33.375,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   ADVGRP - ADVANCED GENERALIZED GRAPHICS STUFF\r\n\r\n\t.RADIX\t10\r\n\r\n\t\t\t\t;Number of graphics planes.  Used to\r\n\t\t\t\t;calculate the array size in PUT/GET.\r\nPWR2PX=(MELCO OR TETRA OR MCI OR SIRIUS)-1\r\n\t\t\t\t;TRUE IF BITS/PIXEL IS ALWAYS POWER\r\n\t\t\t\t;OF TWO. SAVES MULTIPLICATION.\r\n\r\nTETRA=0\r\nZENITH=0\r\nMCI=0\r\nMELCO=0\t\t\t\t;Mitsubishi Electronics Co.\r\nSIRIUS=0\r\nHAL=0\r\nHALL3=0\r\nHALL4=0\r\nALPCPM=0\r\nPC8A=0\r\nMODEL3=0\r\nTSHIBA=0\r\nKANJSW=PC8A OR (TSHIBA AND (TRUROM-1))\r\n\t\t\t\t;PUT @(x,y),KANJI(c) function,on,off\r\n\r\n;\r\n; MACHINE DEPENDENT SWITCHES\r\n;\r\nTILE=0\r\nWINDOW=0\r\nLINEST=0\r\nVIEW=0\r\n\r\n\tVIEW=MODEL3 OR PC8A OR TRSER2\t; SWITCH FOR GRAPHICS VIEW\r\n\tTILE=MODEL3 OR PC8A OR TRSER2 OR HALL4\r\n\tWINDOW=PC8A\r\n\tQUEUE=MODEL3 OR PC8A OR TRSER2 OR GW\r\n\tLINEST=MODEL3 OR PC8A OR TRSER2\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tQUELEN:WORD,PSNLEN:WORD,QUEINP:WORD,QUEOUT:WORD\r\nDSEG\tENDS\r\n\r\n; MACHINE DEPENDENT GRAPHICS ROUTINES:\r\n\r\n\tEXTRN\tSETATR:NEAR,SETC:NEAR\r\n\tEXTRN\tMAPXYC:NEAR,SCALXY:NEAR,FETCHC:NEAR,STOREC:NEAR,UPC:NEAR\r\n\tEXTRN\tDOWNC:NEAR,LEFTC:NEAR\r\n\tEXTRN\tPGINIT:NEAR,PIXSIZ:NEAR,SCANL:NEAR,SCANR:NEAR,PNTINI:NEAR\r\n\tEXTRN\tTUPC:NEAR\r\n\tEXTRN\tTDOWNC:NEAR,NREAD:NEAR,NWRITE:NEAR,GTASPC:NEAR\r\n\r\n\r\n; STUFF IN GENGRP.MAC:\r\n\r\n\tEXTRN\tDOGRPH:NEAR,ATRSCN:NEAR,SCAN1:NEAR,SCAND:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tGRPACX:WORD,GRPACY:WORD,GXPOS:WORD,GYPOS:WORD,ATRBYT:WORD\r\nDSEG\tENDS\r\n\r\n; OTHER STUFF:\r\n\r\n\tEXTRN\tCHRGTR:NEAR,GETBYT:NEAR,GETIN2:NEAR,GETYPR:NEAR\r\n\tEXTRN\tSYNCHR:NEAR\r\n\tEXTRN\tUMULT:NEAR,MINUTK:NEAR,FDIV:NEAR\r\n\tEXTRN\tFCERR:NEAR\r\n\r\n\tEXTRN\tMAKINT:NEAR\r\n\tEXTRN\tPOLKEY:NEAR\r\n\tCKCNTC\tEQU\tPOLKEY\r\n\tMKINTC\tEQU\tMAKINT\r\n\tEXTRN\tDCOMPR:NEAR\r\n\r\n;\r\n; MACRO DEFINITIONS\r\n;\r\n\r\nMOVRI\tMACRO\tB,C,D,E\r\n\tINS86\t271\t\t;;MOVI CX,\r\n\tDB\tOFFSET C\r\n\tDB\tOFFSET B\r\n\tINS86\t272\t\t;;MOVI DX,\r\n\tDB\tOFFSET E\r\n\tDB\tOFFSET D\r\nENDM \r\nHLFDE\tMACRO\t\r\n\tINS86\t321,352\t\t;;SHR DX,1\r\nENDM \r\nHLFHL\tMACRO\t\r\n\tINS86\t321,353\t\t;;SHR BX,1\r\nENDM \r\nNEGDE\tMACRO\t\r\n\tINS86\t367,332\r\nENDM \r\nNEGHL\tMACRO\t\r\n\tINS86\t367,333\r\nENDM \r\n\r\n\tSUBTTL PAINT - Fill an area with color\r\n;\r\n;       PAINT - FILL AN AREA WITH COLOR\r\n;\r\n; SYNTAX: PAINT (X,Y), FILLC, BORDC]]\r\n;\r\n\tPUBLIC\tPAINT\r\n\tEXTRN\tPNTINI:NEAR,SCANL:NEAR,SCANR:NEAR,TUPC:NEAR,TDOWNC:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tPDIREC:WORD,CSAVEA:WORD,CSAVEM:WORD,MOVCNT:WORD,SKPCNT:WORD\r\n\tEXTRN\tLFPROG:WORD,RTPROG:WORD\r\nDSEG\tENDS\r\n\r\nPAINT:\t\t\t\t;GET (X,Y) OF START\r\n\tCALL\tINTQUE\t\t;INIT QUE\r\n\tCALL\tSCAN1\r\n\tPUSH\tCX\t\t;SAVE COORDS OF START\r\n\tPUSH\tDX\r\n\tCALL\tATRSCN\t\t;SET FILL ATTRIBUTE AS CURRENT\r\n\tMOV\tAL,BYTE PTR ATRBYT\t;DEFAULT BORDER COLOR IS SAME AS FILL\r\n\tMOV\tDL,AL\t\t;DEFAULT ATTRIBUTE TO [E] LIKE GETBYT\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\r\n\tJZ\tSHORT GOTBRD\t;NOTHING THERE - USE DEFAULT\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;MAKE SURE OF COMMA\r\n\tCALL\tGETBYT\t\t;GET BORDER COLOR ARGUMENT\r\nGOTBRD:\tMOV\tAL,DL\t\t;BORDER ATTRIBUTE TO A\r\n\tCALL\tPNTINI\t\t;INIT PAINT STUFF & CHECK BORDER ATTRIB\r\n\tJAE\tSHORT ??L000\r\n\tJMP\tFCERR\r\n??L000:\r\n\r\n\tPOP\tDX\t\t;GET BACK START COORDS\r\n\tPOP\tCX\r\n\tPUSH\tBX\t\t;SAVE TXTPTR UNTIL DONE\r\n\tCALL\tCHKRNG\t\t;MAKE SURE POINT IS ON SCREEN\r\n\tCALL\tMAPXYC\r\n\r\n\tMOV\tDX,1\t\t;ENTRY COUNT IS ONE (SKIP NO BORDER)\r\n\tCALL\tSCANR1\t\t;SCAN RIGHT FROM INITIAL POSITION\r\n\tJZ\tSHORT POPTRT\t;STARTED ON BORDER - GET TXTPTR & QUIT\r\n\tPUSH\tBX\t\t;SAVE NO. OF POINTED PAINTED TO RIGHT\r\n\tCALL\tSCANL1\t\t;NOW SCAN LEFT FROM INITIAL POS.\r\n\tPOP\tDX\t\t;GET RIGHT SCAN COUNT.\r\n\tADD\tBX,DX\t\t;ADD TO LEFT SCAN COUNT\r\n\tXCHG\tBX,DX\t\t;COUNT TO [DE]\r\n\r\n\tMOV\tAL,LOW 64\t;MAKE ENTRY FOR GOING DOWN\r\n\tCALL\tENTST1\r\n\r\n\tMOV\tCH,LOW 192\t;CAUSE PAINTING UP\r\n\tJMP\tSHORT STPAIN\t;START PAINTING UPWARD\r\n\r\nPOPTRT:\tPOP\tBX\t\t;GET BACK TEXTPTR\r\n\tRET\t\r\n;\r\n; MAIN PAINT LOOP\r\n;\r\nPNTLOP:\r\n\tCALL\tCKCNTC\t\t;CHECK FOR CTRL-C ABORT\r\nPNTLP1:\tCALL\tGETQ\t\t;GET ONE ENTRY FROM QUEUE\r\n\tMOV\tAL,CL\t\t;NOW GO SET UP CURRENT LOCATION\r\n\tCALL\tSTOREC\r\nSTPAIN:\tMOV\tAL,CH\t\t;GET DIRECTION\r\n\tMOV\tBYTE PTR PDIREC,AL\r\n\tADD\tAL,AL\t\t;SEE WHETHER TO GO UP, DOWN, OR QUIT\r\n\tJZ\tSHORT POPTRT\t;IF ZERO, ALL DONE.\r\n\tPUSH\tDX\t\t;SAVE SKPCNT IN CASE TUP&TDOWN DON'T\r\n\tJAE\tSHORT PDOWN\t;IF POSITIVE, GO DOWN FIRST\r\n\tCALL\tTUPC\t\t;MOVE UP BEFORE SCANNING\r\n\tJMP\tSHORT PDOWN2\r\n\r\nPDOWN:\tCALL\tTDOWNC\t\t;SEE IF AT BOTTOM & MOVE DOWN IF NOT\r\nPDOWN2:\tPOP\tDX\t\t;GET SKPCNT BACK\r\n\tJB\tSHORT PNTLP1\t;OFF SCREEN - GET NEXT ENTRY\r\nPNTLP2:\t\t\t\t;SCAN RIGHT & SKIP UP TO SKPCNT BORDER\r\n\tCALL\tSCANR1\r\n\tJNZ\tSHORT ??L001\r\n\tJMP\tPNTLP1\t\t;IF NO POINTS PAINTED, GET NEXT ENTRY\r\n??L001:\r\n\tCALL\tSCANL1\t\t;NOW SCAN LEFT FROM START POINT\r\n\tMOV\tDL,BL\t\t;[DE] = LEFT MOVCNT\r\n\tMOV\tDH,BH\r\n\tOR\tAL,AL\t\t;SEE IF LINE WAS ALREADY PAINTED\r\n\tJZ\tSHORT PNTLP3\t;IT WAS - DON'T MAKE OVERHANG ENTRY\r\n\tDEC\tBX\t\t;IF LMVCNT.GT.1, NEED TO MAKE ENTRY\r\n\tDEC\tBX\t\t;IN OPPOSITE DIRECTION FOR OVERHANG.\r\n\tMOV\tAL,BH\r\n\tADD\tAL,AL\t\t;SEE IF [HL] WAS .GT. 1\r\n\tJB\tSHORT PNTLP3\r\n\r\n\r\n\tMOV\tAL,BYTE PTR PDIREC\r\n\tNOT\tAL\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\r\n\tCALL\tFETCHC\t\t;GET CURRENT POINT ADDRESS\r\n\tMOV\tCL,AL\t\t;C=CMASK\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;GET BACK DIRECTION AND INDEX\r\n\tMOV\tCH,AL\r\n\tCALL\tPUTQ\r\nPNTLP3:\tMOV\tBX,MOVCNT\t;GET COUNT PAINTED DURING RIGHT SCAN\r\n\tADD\tBX,DX\t\t;ADD TO LEFT MOVCNT\r\n\tXCHG\tBX,DX\t\t;ENTRY COUNT TO [DE]\r\n\tCALL\tENTSLR\t\t;GO MAKE ENTRY.\r\n\r\n\tMOV\tBX,CSAVEA\t;SET CURRENT LOCATION BACK TO END\r\n\tMOV\tAL,BYTE PTR CSAVEM\t;OF RIGHT SCAN.\r\n\tCALL\tSTOREC\r\n\r\nPNTLP4:\tMOV\tBX,SKPCNT\t;CALC SKPCNT - MOVCNT TO SEE IF\r\n\tMOV\tDX,MOVCNT\t;ANY MORE BORDER TO SKIP\r\n\tSUB\tBX,DX\r\n\tJZ\tSHORT GOPLOP\t;NO MORE - END OF THIS SCAN\r\n\tJB\tSHORT PNTLP6\t;RIGHT OVERHANG - SEE IF ENTRY NEEDED\r\n\r\n\tXCHG\tBX,DX\t\t;SKIP COUNT TO [DE] FOR SCANR\r\n\tCALL\tSCANR1\t\t;HERE IF NEED TO CONTINUE RIGHT SCAN\r\n\tJZ\tSHORT GOPLOP\t;NO MORE POINTS.\r\n\tOR\tAL,AL\t\t;SEE IF LINE ALREADY PAINTED\r\n\tJZ\tSHORT PNTLP4\t;YES, DON'T ENTER ANYTHING\r\n\tXCHG\tBX,DX\t\t;ENTRY COUNT TO [DE]\r\n\tMOV\tBX,CSAVEA\t;MAKE ENTRY AT LOCATION SAVED BY SCANR\r\n\tMOV\tAL,BYTE PTR CSAVEM\t;SO WE CAN ENTER A POSITIVE SKPCNT\r\n\tMOV\tCL,AL\r\n\tMOV\tAL,BYTE PTR PDIREC\r\n\tMOV\tCH,AL\r\n\tCALL\tENTSTK\t\t;MAKE ENTRY\r\n\tJMP\tSHORT PNTLP4\t;CONTINUE UNTIL SKPCNT .LE. 0\r\n\r\nPNTLP6:\tNEGHL\t\t\t;MAKE NEW SKPCNT POSITIVE\r\n\tDEC\tBX\t\t;IF SKPCNT-MOVCNT .LT. -1\r\n\tDEC\tBX\t\t;THEN RIGHT OVERHANG ENTRY IS NEEDED.\r\n\tMOV\tAL,BH\t\t;SEE IF POSITIVE.\r\n\tADD\tAL,AL\r\n\tJB\tSHORT GOPLOP\t;OVERHANG TOO SMALL FOR NEW ENTRY\r\n\r\n\r\nRTOVH0:\tINC\tBX\t\t;NOW MOVE LEFT TO BEGINNING OF SCAN\r\n\tPUSH\tBX\t\t;SO WE CAN ENTER A POSITIVE SKPCNT\r\n\tXCHG\tBX,DX\r\nRTOVH1:\tCALL\tLEFTC\t\t;START IS -(SKPCNT-MOVCNT)-1 TO LEFT\r\n\tDEC\tDX\r\n\tOR\tDX,DX\r\n\tJNZ\tSHORT RTOVH1\r\n\r\nRTOVH2:\tPOP\tDX\t\t;GET BACK ENTRY SKPCNT INTO [DE]\r\n\tMOV\tAL,BYTE PTR PDIREC\t;MAKE ENTRY IN OPPOSITE DIRECTION\r\n\tNOT\tAL\r\n\tCALL\tENTST1\t\t;MAKE ENTRY\r\nGOPLOP:\tJMP\tPNTLOP\t\t;GO PROCESS NEXT ENTRY\r\n\r\nENTSLR:\r\n\tMOV\tAL,BYTE PTR LFPROG\t;DON'T STACK IF SCANNED LINE\r\n\tMOV\tCL,AL\t\t;WAS ALREADY PAINTED\r\n\tMOV\tAL,BYTE PTR RTPROG\r\n\tOR\tAL,CL\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;Z IF SCAN LINE ALREADY PAINTED\r\n\r\nENTST0:\tMOV\tAL,BYTE PTR PDIREC\r\nENTST1:\tMOV\tCH,AL\t\t;DIRECTION IN [B]\r\n\tCALL\tFETCHC\t\t;LOAD REGS WITH CURRENT \"C\"\r\n\tMOV\tCL,AL\t\t;BIT MASK IN [C]\r\nENTSTK:\r\nENTST9:\tJMP\tPUTQ\r\n\r\nSCANR1:\tCALL\tSCANR\t\t;PERFORM LOW LEVEL RIGHT SCAN\r\n\tMOV\tSKPCNT,DX\t;SAVE UPDATED SKPCNT\r\n\tMOV\tMOVCNT,BX\t;SAVE MOVCNT\r\n\tOR\tBX,BX\t\t;SET CC'S ON MOVCNT\r\n\tMOV\tAL,CL\t\t;GET ALREADY-PAINTED FLAG FROM [C]\r\n\tMOV\tBYTE PTR RTPROG,AL\r\n\tRET\t\r\n\r\nSCANL1:\tCALL\tFETCHC\t\t;GET CURRENT LOCATION\r\n\tPUSH\tBX\t\t;AND SWAP WITH CSV\r\n\tPUSH\tAX\r\n\tMOV\tBX,CSAVEA\r\n\tMOV\tAL,BYTE PTR CSAVEM\r\n\tCALL\tSTOREC\t\t;REPOS AT BEGINNING OF SCAN\r\n\tPOP\tAX\t\t;REGET PLACE WHERE RT SCN STOPPED\r\n\tPOP\tBX\r\n\tMOV\tCSAVEA,BX\t;AND SAVE IT IN TEMP LOCATION\r\n\tMOV\tBYTE PTR CSAVEM,AL\r\n\tCALL\tSCANL\t\t;NOW DO LOW LEVEL LEFT SCAN\r\n\tMOV\tAL,CL\t\t;GET ALREADY-PAINTED FLAG FROM [C]\r\n\tMOV\tBYTE PTR LFPROG,AL\t;WHETHER IT WAS ALREADY PAINTED\r\n\tRET\t\r\n\r\n;ROUTINE FOR INITIALISING QUEUE PARAMS\r\n;QUELEN:CONTAINS QUEUE LENGTH\r\n;PSNLEN:CONTAINS PRESENT QUEUE LENGTH\r\n;QUEINP:        QUEINPUT POINTER\r\n;QUEOUT:        QUEOUTPUT POINTER\r\nINTQUE:\tPUSH\tBX\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSTREND:WORD\r\nDSEG\tENDS\r\n\tMOV\tBX,STREND\t;GET BEGINNING OF FREE SPACE\r\n\tXCHG\tBX,DX\t\t;\r\n\tPUSH\tDX\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFRETOP:WORD\r\nDSEG\tENDS\r\n\tMOV\tBX,FRETOP\t;GET END OF FREE SPACE\r\n\tSUB\tBX,DX\t\t;HL=FREE SPACE\r\n\tMOV\tDX,1000D\t;\r\n\tCMP\tBX,DX\t\t;IS IT LESSTHAN  1000 BYTES\r\n\tJNAE\tSHORT ??L002\r\n\tJMP\tINTQU2\r\n??L002:\r\nEXTRN\tGARBA2:NEAR\r\n\tCALL\tGARBA2\t\t;CALL GARBAGE COLLECTION\r\nINTQU2:\tPOP\tDX\t\t;GET BACK FREE START\r\n\r\n\tMOV\tBX,FRETOP\r\n\r\n\tSUB\tBX,DX\r\n\tMOV\tDX,12D\r\n\tCMP\tBX,DX\r\n\tJAE\tSHORT ??L003\r\nEXTRN\tOMERR:NEAR\r\n\tJMP\tOMERR\t\t;IF LESS THAN 12 BYTES GIVE MEMORY OVERFLOW\r\n??L003:\r\n\tMOV\tQUELEN,BX\t;SET LENGTH OF QUEUE\r\n\tMOV\tBX,0\r\n\tMOV\tPSNLEN,BX\t;SET PRESENT LENGTH\r\n\tMOV\tBX,STREND\t;HL=BEGINNING OF FREE SPACE\r\n\tMOV\tQUEINP,BX\t;\r\n\tMOV\tQUEOUT,BX\t;INIT QUEUE POINTERS\r\n\tPOP\tBX\t\t;GET BACK CALLERS HL\r\n\tRET\t\r\nPUTQ:\tPUSH\tDX\r\n\tPUSH\tBX\r\n\tMOV\tBX,PSNLEN\t;GET QUEUE      PRESENT LENGTH\r\n\tMOV\tDX,6\t\t;IS ENOUGH SPACE LEFT OUT\r\n\tLAHF\r\n\tADD\tBX,DX\r\n\tRCR\tSI,1\r\n\tSAHF\r\n\tRCL\tSI,1\r\n\tMOV\tPSNLEN,BX\t;UPDATE PRESENT LENGTH\r\n\tMOV\tDX,QUELEN\t;\r\n\tCMP\tBX,DX\t\t;\r\n\tJNAE\tSHORT ??L004\r\n\tJMP\tOMERR\t\t;IF THE PRESENT LENGTH IS EQUAL TO MAX OR GREATER THEN GIVE ERROR\r\n??L004:\r\n\tMOV\tBX,QUEINP\r\n\tCALL\tWRAP\t\t;CHECK FOR WRAP AROUND CASE\r\n\tPOP\tDX\r\n\tMOV\tBYTE PTR [BX],DL\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tBYTE PTR [BX],DH\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tBYTE PTR [BX],CL\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tBYTE PTR [BX],CH\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tPOP\tDX\r\n\tMOV\tBYTE PTR [BX],DL\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tBYTE PTR [BX],DH\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tQUEINP,BX\r\n\tRET\t\r\nGETQ:\tMOV\tBX,PSNLEN\r\n\tMOV\tAL,BH\r\n\tOR\tAL,BL\t\t;ANY ENTRYS ON STACK\r\n\tMOV\tCH,LOW 0\t;FOR NO ENTRIES SET B TO ZERO\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tMOV\tDX,6\t\t;DECREMENT QUEUE LENGTH BY 6\r\n\tSUB\tBX,DX\r\n\tMOV\tPSNLEN,BX\r\n\tMOV\tBX,QUEOUT\t;HL=DEQUE POINTER\r\n\tCALL\tWRAP\t\t;CHECK FOR WRAP AROUND\r\n\tMOV\tDL,BYTE PTR [BX]\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tDH,BYTE PTR [BX]\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tPUSH\tDX\r\n\tMOV\tCL,BYTE PTR [BX]\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tDL,BYTE PTR [BX]\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tDH,BYTE PTR [BX]\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tQUEOUT,BX\r\n\tPOP\tBX\r\n\tRET\t\r\nWRAP:\tPUSH\tBX\t\t;\r\n\tMOV\tDX,6\r\n\tLAHF\r\n\tADD\tBX,DX\r\n\tRCR\tSI,1\r\n\tSAHF\r\n\tRCL\tSI,1\r\n\tMOV\tDX,FRETOP\r\n\tCMP\tBX,DX\t\t;ARE WE GOING OUT OF QUEUE END\r\n\tPOP\tBX\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;NO\r\n\tMOV\tBX,STREND\t;SET TO BEGINNING OF QUEUE\r\n\tRET\t\r\n\r\n\tSUBTTL CIRCLE - Draw a circle\r\n;\r\n;       CIRCLE - DRAW A CIRCLE\r\n;\r\n; SYNTAX: CIRCLE @(X,Y),RADIUS[,ATRB[,+/-STARTANG[,+/-ENDANG[,ASPECT]]]]\r\n;\r\n\tEXTRN\tGTASPC:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tEXTRN\tASPECT:WORD,CSTCNT:WORD,CENCNT:WORD,CRCSUM:WORD,CPLOTF:WORD\r\n\tEXTRN\tCLINEF:WORD\r\n\tEXTRN\tCNPNTS:WORD,CPCNT:WORD,CPCNT8:WORD,VALTYP:WORD,CXOFF:WORD\r\n\tEXTRN\tCYOFF:WORD,CSCLXY:WORD\r\nDSEG\tENDS\r\n\r\nPUBLIC\tCIRCLE\r\nCIRCLE:\tCALL\tSCAN1\t\t;GET (X,Y) OF CENTER INTO GRPACX,Y\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;EAT COMMA\r\n\tCALL\tGETIN2\t\t;GET THE RADIUS\r\n\tPUSH\tBX\t\t;SAVE TXTPTR\r\n\tXCHG\tBX,DX\r\n\tMOV\tGXPOS,BX\t;SAVE HERE TILL START OF MAIN LOOP\r\n\tCALL\tMKINTC\t\t;PUT INTEGER INTO FAC\r\nEXTRN\tFRCSNG:NEAR\r\n\tCALL\tFRCSNG\t\t;CONVERT TO SINGLE PRECISION\r\n\tMOVRI\t200O,65O,4O,363O\t;LOAD REGS WITH SQR(2)/2\r\nEXTRN\tFMULT:NEAR\r\n\tCALL\tFMULT\t\t;DO FLOATING PT MULTIPLY\r\nEXTRN\tFRCINT:NEAR\r\n\tCALL\tFRCINT\t\t;CONVERT TO INTEGER & GET INTO [HL]\r\n\tMOV\tCNPNTS,BX\t;CNPNTS=RADIUS*SQR(2)/2=# PTS TO PLOT\r\n\tXOR\tAL,AL\t\t;ZERO OUT CLINEF - NO LINES TO CENTER\r\n\tMOV\tBYTE PTR CLINEF,AL\r\n\tMOV\tBYTE PTR CSCLXY,AL\t;INITIALLY SCALING Y\r\n\tPOP\tBX\t\t;REGET TXTPTR\r\n\tCALL\tATRSCN\t\t;SCAN POSSIBLE ATTRIBUTE\r\n\tMOV\tCL,LOW 1\t;SET LO BIT IN CLINEF FOR LINE TO CNTR\r\n\tMOV\tDX,0\t\t;DEFAULT START COUNT = 0\r\n\tCALL\tCGTCNT\r\n\tPUSH\tDX\t\t;SAVE COUNT FOR LATER COMPARISON\r\n\tMOV\tCL,LOW 128D\t;SET HI BIT IN CLINEF FOR LINE TO CNTR\r\n\tMOV\tDX,OFFSET 0-1\t;DEFAULT END COUNT = INFINITY\r\n\tCALL\tCGTCNT\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;GET START COUNT, PUSH TXTPTR TILL DONE\r\n\tXOR\tAL,AL\r\n\tXCHG\tBX,DX\t\t;REVERSE REGS TO TEST FOR .LT.\r\n\tCMP\tBX,DX\t\t;SEE IF END .GE. START\r\n\tMOV\tAL,LOW 0\r\n\tJAE\tSHORT CSTPLT\t;YES, PLOT POINTS BETWEEN STRT & END\r\n\tDEC\tAL\t\t;PLOT POINTS ABOVE & BELOW\r\n\tXCHG\tBX,DX\t\t;SWAP START AND END SO START .LT. END\r\n\tPUSH\tAX\t\t;Swap sense of center line flags\r\n\tMOV\tAL,BYTE PTR CLINEF\r\n\tMOV\tCL,AL\r\n\tROL\tAL,1\r\n\tROL\tAL,1\r\n\tOR\tAL,CL\r\n\tROR\tAL,1\r\n\tMOV\tBYTE PTR CLINEF,AL\t;Store swapped flags\r\n\tPOP\tAX\r\nCSTPLT:\tMOV\tBYTE PTR CPLOTF,AL\t;SET UP PLOT POLARITY FLAG\r\n\tMOV\tCSTCNT,DX\t;STORE START COUNT\r\n\tMOV\tCENCNT,BX\t;AND END COUNT\r\n\tPOP\tBX\t\t;GET TXTPTR\r\n\tDEC\tBX\t\t;NOW SEE IF LAST CHAR WAS A COMMA\r\n\tCALL\tCHRGTR\r\n\tJNZ\tSHORT CIRC1\t;SOMETHING THERE\r\n\tPUSH\tBX\t\t;SAVE TXTPTR\r\n\tCALL\tGTASPC\t\t;GET DEFAULT ASPECT RATIO INTO [HL]\r\n\tMOV\tAL,BH\r\n\tOR\tAL,AL\t\t;IS ASPECT RATIO GREATER THAN ONE?\r\n\tJZ\tSHORT CIRC2\t;BRIF GOOD ASPECT RATIO\r\n\tMOV\tAL,LOW 1\r\n\tMOV\tBYTE PTR CSCLXY,AL\r\n\tXCHG\tBX,DX\t\t;ASPECT RATIO IS GREATER THAN ONE, USE INVERSE\r\n\tJMP\tSHORT CIRC2\t;NOW GO CONVERT TO FRACTION OF 256\r\n\r\nCIRC1:\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;EAT COMMA\r\nEXTRN\tFRMEVL:NEAR\r\n\tCALL\tFRMEVL\r\n\tPUSH\tBX\t\t;SAVE TXTPTR\r\n\tCALL\tFRCSNG\t\t;MAKE IT FLOATING POINT\r\n\tCALL\tCMPONE\t\t;SEE IF GREATER THAN ONE\r\n\tJNZ\tSHORT CIRC11\t;LESS THAN ONE - SCALING Y\r\n\tINC\tAL\t\t;MAKE [A] NZ\r\n\tMOV\tBYTE PTR CSCLXY,AL\t;FLAG SCALING X\r\n\tCALL\tFDIV\t\t;RATIO = 1/RATIO\r\n\t\t\t\t;MAKE NUMBER FRACTION OF 256\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFAC:WORD\r\nDSEG\tENDS\r\n\r\nCIRC11:\tMOV\tBX,OFFSET FAC\t;BY MULTIPLYING BY 2^8 (256)\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tADD\tAL,LOW 8\t;ADD 8 TO EXPONENT\r\n\tMOV\tBYTE PTR [BX],AL\r\n\tCALL\tFRCINT\t\t;MAKE IT AN INTEGER IN [HL]\r\nCIRC2:\tMOV\tASPECT,BX\t;STORE ASPECT RATIO\r\n;\r\n;       CIRCLE ALGORITHM\r\n;\r\n;       [HL]=X=RADIUS * 2 (ONE BIT FRACTION FOR ROUNDING)\r\n;       [DE]=Y=0\r\n;       SUM =0\r\n; LOOP: IF Y IS EVEN THEN\r\n;             REFLECT((X+1)/2,(Y+1)/2) (I.E., PLOT POINTS)\r\n;             IF X.LT.Y THEN EXIT\r\n;       SUM=SUM+2*Y+1\r\n;       Y=Y+1\r\n;       IF SUM.GGWGRP.RNO\r\n;             SUM=SUM-2*X+1\r\n;             X=X-1\r\n;       ENDIF\r\n;       GOTO LOOP\r\n;\r\n\tMOV\tDX,0\t\t;INIT Y = 0\r\n\tMOV\tCRCSUM,DX\t;SUM = 0\r\n\tMOV\tBX,GXPOS\t;X = RADIUS*2\r\n\tADD\tBX,BX\r\n\r\nCIRCLP:\r\n\tMOV\tAL,DL\t\t;TEST EVENNESS OF Y\r\n\tRCR\tAL,1\t\t;TO SEE IF WE NEED TO PLOT\r\n\tJB\tSHORT CRCLP2\t;Y IS ODD - DON'T TEST OR PLOT\r\n\tPUSH\tDX\t\t;SAVE Y AND X\r\n\tPUSH\tBX\r\n\tINC\tBX\t\t;ACTUAL COORDS ARE (X+1)/2,(Y+1)/2\r\n\tHLFHL\t\t\t;(PLUS ONE BEFORE DIVIDE TO ROUND UP)\r\n\tINC\tDX\r\n\tHLFDE\t\r\n\tCALL\tCPLOT8\r\n\tPOP\tDX\t\t;RESTORE X AND Y\r\n\tPOP\tBX\t\t;INTO [DE] AND [HL] (BACKWARDS FOR CMP)\r\n\tCMP\tBX,DX\t\t;QUIT IF Y .GE. X\r\n\tJNAE\tSHORT ??L005\r\n\tJMP\tPOPTRT\t\t;GO POP TXTPTR AND QUIT\r\n??L005:\r\n\tXCHG\tBX,DX\t\t;GET OFFSETS INTO PROPER REGISTERS\r\nCRCLP2:\tMOV\tCX,BX\t\t;[BC]=X\r\n\tMOV\tBX,CRCSUM\r\n\tINC\tBX\t\t;SUM = SUM+2*Y+1\r\n\tADD\tBX,DX\r\n\tADD\tBX,DX\r\n\tMOV\tAL,BH\t\t;NOW CHECK SIGN OF RESULT\r\n\tADD\tAL,AL\r\n\tJB\tSHORT CNODEX\t;DON'T ADJUST X IF WAS NEGATIVE\r\n\tPUSH\tDX\t\t;SAVE Y\r\n\tXCHG\tBX,DX\t\t;[DE]=SUM\r\n\tMOV\tBX,CX\t\t;[HL]=X\r\n\tADD\tBX,BX\t\t;[HL]=2*X-1\r\n\tDEC\tBX\r\n\tXCHG\tBX,DX\t\t;PREPARE TO SUBTRACT\r\n\tSUB\tBX,DX\t\t;CALC SUM-2*X+1\r\n\tDEC\tCX\t\t;X=X-1\r\n\tPOP\tDX\t\t;GET Y BACK\r\nCNODEX:\tMOV\tCRCSUM,BX\t;UPDATE CIRCLE SUM\r\n\tMOV\tBX,CX\t\t;GET X BACK TO [HL]\r\n\tINC\tDX\t\t;Y=Y+1\r\n\tJMP\tSHORT CIRCLP\r\n\r\nCPLSCX:\tPUSH\tDX\r\n\tCALL\tSCALEY\r\n\tPOP\tBX\t\t;GET UNSCALED INTO [HL]\r\n\tMOV\tAL,BYTE PTR CSCLXY\t;SEE WHETHER ASPECT WAS .GT. 1\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;DON'T SWAP IF ZERO\r\n\tXCHG\tBX,DX\r\n\tRET\t\r\n;\r\n; REFLECT THE POINTS AROUND CENTER\r\n; [HL]=X OFFSET FROM CENTER, [DE]=Y OFFSET FROM CENTER\r\n;\r\nCPLOT8:\tMOV\tCPCNT,DX\t;POINT COUNT IS ALWAYS = Y\r\n\tPUSH\tBX\t\t;SAVE X\r\n\tMOV\tBX,0\t\t;START CPCNT8 OUT AT 0\r\n\tMOV\tCPCNT8,BX\r\n\tCALL\tCPLSCX\t\t;SCALE Y AS APPROPRIATE\r\n\tMOV\tCXOFF,BX\t;SAVE CXOFF\r\n\tPOP\tBX\t\t;GET BACK X\r\n\tXCHG\tBX,DX\r\n\tPUSH\tBX\t\t;SAVE INITIAL [DE]\r\n\tCALL\tCPLSCX\t\t;SCALE X AS APPROPRIATE\r\n\tMOV\tCYOFF,DX\r\n\tPOP\tDX\t\t;GET BACK INITIAL [DE]\r\n\tNEGDE\t\t\t;START: [DE]=-Y,[HL]=X,CXOFF=Y,CY=X\r\n\r\n\tCALL\tCPLOT4\t\t;PLOT +X,-SY -Y,-SX -X,+SY +Y,-SX\r\n\r\n\tPUSH\tBX\r\n\tPUSH\tDX\r\n\tMOV\tBX,CNPNTS\t;GET # PNTS PER OCTANT\r\n\tMOV\tCPCNT8,BX\t;AND SET FOR DOING ODD OCTANTS\r\n\tMOV\tDX,CPCNT\t;GET POINT COUNT\r\n\tSUB\tBX,DX\t\t;ODD OCTANTS ARE BACKWARDS SO\r\n\tMOV\tCPCNT,BX\t;PNTCNT = PNTS/OCT - PNTCNT\r\n\tMOV\tBX,CXOFF\t;NEED TO NEGATE CXOFF TO START OUT RIGHT\r\n\tNEGHL\t\r\n\tMOV\tCXOFF,BX\r\n\tPOP\tDX\r\n\tPOP\tBX\r\n\tNEGDE\t\t\t;ALSO NEED TO MAKE [DE]=-SX=-[DE]\r\n\t\t\t\t;PLOT +Y,-SX -X,-SY -Y,+SX +X,+SY\r\n\t\t\t\t;(FALL THRU TO CPLOT4)\r\nCPLOT4:\tMOV\tAL,LOW 4\t;LOOP FOUR TIMES\r\n\r\nCPLOT:\tPUSH\tAX\t\t;SAVE LOOP COUNT\r\n\tPUSH\tBX\t\t;SAVE BOTH X & Y OFFSETS\r\n\tPUSH\tDX\r\n\tPUSH\tBX\t\t;SAVE TWICE\r\n\tPUSH\tDX\r\n\tMOV\tDX,CPCNT8\t;GET NP*OCTANT*8\r\n\tMOV\tBX,CNPNTS\t;ADD SQR(2)*RADIUS FOR NEXT OCTANT\r\n\tADD\tBX,BX\r\n\tADD\tBX,DX\r\n\tMOV\tCPCNT8,BX\t;UPDATE FOR NEXT TIME\r\n\tMOV\tBX,CPCNT\t;CALC THIS POINT'S POINT COUNT\r\n\tADD\tBX,DX\t\t;ADD IN PNTCNT*OCTANT*NP\r\n\tXCHG\tBX,DX\t\t;SAVE THIS POINT'S COUNT IN [DE]\r\n\tMOV\tBX,CSTCNT\t;GET START COUNT\r\n\tCMP\tBX,DX\r\n\tJZ\tSHORT CLINSC\t;SEE IF LINE TO CENTER REQUIRED\r\n\tJAE\tSHORT CNBTWN\t;IF SC .GT. PC, THEN NOT BETWEEN\r\n\tMOV\tBX,CENCNT\t;GET END COUNT\r\n\tCMP\tBX,DX\r\n\tJZ\tSHORT CLINEC\t;GO SEE IF LINE FROM CENTER NEEDED\r\n\tJAE\tSHORT CBTWEN\t;IF EC .GT. PC, THEN BETWEEN\r\n\r\nCNBTWN:\tMOV\tAL,BYTE PTR CPLOTF\t;SEE WHETHER TO PLOT OR NOT\r\n\tOR\tAL,AL\t\t;IF NZ, PLOT POINTS NOT IN BETWEEN\r\n\tJNZ\tSHORT CPLTIT\t;NEED TO PLOT NOT-BETWEEN POINTS\r\n\tJMP\tSHORT GCPLFN\t;DON'T PLOT - FIX UP STACK & RETURN\r\n\r\nCLINEC:\tMOV\tAL,BYTE PTR CLINEF\t;GET CENTER LINE FLAG BYTE\r\n\tADD\tAL,AL\t\t;BIT 7=1 MEANS DRAW LINE FROM CENTER\r\n\tJAE\tSHORT CPLTIT\t;NO LINE REQUIRED - JUST PLOT POINT\r\n\tJMP\tSHORT CLINE\t;LINE REQUIRED.\r\n\r\nCLINSC:\tMOV\tAL,BYTE PTR CLINEF\t;GET CENTER LINE FLAG BYTE\r\n\tRCR\tAL,1\t\t;BIT 0=1 MEANS LINE FROM CENTER NEEDED.\r\n\tJAE\tSHORT CPLTIT\t;NO LINE REQUIRED - JUST PLOT POINT\r\n\r\nCLINE:\tPOP\tDX\t\t;GET X & Y OFFSETS\r\n\tPOP\tBX\r\n\tCALL\tGTABSC\t\t;GO CALC TRUE COORDINATE OF POINT\r\n\tCALL\tCLINE2\t\t;DRAW LINE FROM [BC],[DE] TO CENTER\r\n\tJMP\tSHORT CPLFIN\r\n\r\nCBTWEN:\tMOV\tAL,BYTE PTR CPLOTF\t;SEE WHETHER PLOTTING BETWEENS OR NOT\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT CPLTIT\t;IF Z, THEN DOING BETWEENS\r\nGCPLFN:\tPOP\tDX\t\t;CLEAN UP STACK\r\n\tPOP\tBX\r\n\tJMP\tSHORT CPLFIN\r\n\r\nCPLTIT:\tPOP\tDX\t\t;GET X & Y OFFSETS\r\n\tPOP\tBX\r\n\tCALL\tGTABSC\t\t;CALC TRUE COORDINATE OF POINT\r\n\tCALL\tSCALXY\t\t;SEE IF POINT OFF SCREEN\r\n\tJAE\tSHORT CPLFIN\t;NC IF POINT OFF SCREEN - NO PLOT\r\n\tCALL\tMAPXYC\r\n\tCALL\tSETC\t\t;PLOT THE POINT\r\n\r\nCPLFIN:\tPOP\tDX\t\t;GET BACK OFFSETS\r\n\tPOP\tBX\r\n\tPOP\tAX\t\t;GET BACK LOOP COUNT\r\n\tDEC\tAL\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;QUIT IF DONE.\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\r\n\tPUSH\tDX\t\t;SAVE X OFFSET\r\n\tMOV\tDX,CXOFF\t;SWAP [HL] AND CXOFF\r\n\tNEGDE\t\t\t;NEGATE NEW [HL]\r\n\tMOV\tCXOFF,BX\r\n\tXCHG\tBX,DX\r\n\tPOP\tDX\r\n\tPUSH\tBX\r\n\tMOV\tBX,CYOFF\t;SWAP [DE] AND CYOFF\r\n\tXCHG\tBX,DX\t\t;NEGATE NEW [DE]\r\n\tMOV\tCYOFF,BX\r\n\tNEGDE\t\r\n\tPOP\tBX\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\r\n\tJMP\tCPLOT\t\t;PLOT NEXT POINT\r\n\r\nCLINE2:\tMOV\tBX,GRPACX\t;DRAW LINE FROM [BC],[DE]\r\n\tMOV\tGXPOS,BX\t;TO GRPACX,Y\r\n\tMOV\tBX,GRPACY\r\n\tMOV\tGYPOS,BX\r\n\tJMP\tDOGRPH\t\t;GO DRAW THE LINE\r\n;\r\n; GTABSC - GET ABSOLUTE COORDS\r\n; ([BC],[DE])=(GRPACX+[HL],GRPACY+[DE])\r\n;\r\nGTABSC:\tPUSH\tDX\t\t;SAVE Y OFFSET FROM CENTER\r\n\tMOV\tDX,GRPACX\t;GET CENTER POS\r\n\tADD\tBX,DX\t\t;ADD TO DX\r\n\tMOV\tCX,BX\t\t;[BC]=X CENTER + [HL]\r\n\tPOP\tDX\r\n\tMOV\tBX,GRPACY\t;GET CENTER Y\r\n\tADD\tBX,DX\r\n\tXCHG\tBX,DX\t\t;[DE]=Y CENTER + [DE]\r\n\tRET\t\r\n\r\nSCALEY:\tMOV\tBX,ASPECT\t;SCALE [DE] BY ASPECT RATIO\r\n\r\nSCALE:\tMOV\tAL,BL\t\t;CHECK FOR *0 AND *1 CASES\r\nSCALE2:\tOR\tAL,AL\t\t;ENTRY TO DO [A]*[DE] ([A] NON-Z)\r\n\tJNZ\tSHORT SCAL2\t;NON-ZERO\r\n\tOR\tAL,BH\t\t;TEST HI BYTE\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;IF NZ, THEN WAS *1 CASE\r\n\tXCHG\tBX,DX\t\t;WAS *0 CASE - PUT 0 IN [DE]\r\n\tRET\t\r\n\r\nSCAL2:\tINS86\t62,344\t\t;XORB AH,AH\r\n\tINS86\t367,342\t\t;MUL  DX\r\n\tINS86\t212,362\t\t;MOVB DH,DL\r\n\tINS86\t5\t\t;ADDI AX,128  - ROUND UP\r\n\tDB\t128D\r\n\tDB\t0\r\n\tINS86\t163,2\t\t;JNB NOCARY\r\n\tINS86\t376,306\t\t;INCB DH\r\nNOCARY:\tINS86\t212,324\t\t;MOVB DL,AH\r\n\tRET\t\r\n;\r\n; PARSE THE BEGIN AND END ANGLES\r\n;  SETTING APPROPRIATE BITS IN CLINEF IF NEG.\r\n;\r\nCGTCNT:\tDEC\tBX\r\n\tCALL\tCHRGTR\t\t;GET CURRENT CHAR\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF NOTHING, RETURN DFLT IN [DE]\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;EAT THE COMMA\r\n\tCMP\tAL,LOW 44\t;USE DEFAULT IF NO ARGUMENT.\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tPUSH\tCX\t\t;SAVE FLAG BYTE IN [C]\r\n\tCALL\tFRMEVL\t\t;EVALUATE THE THING\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;POP FLAG BYTE, PUSH TXTPTR\r\n\tPUSH\tBX\t\t;RESAVE FLAG BYTE\r\n\tCALL\tFRCSNG\t\t;MAKE IT A SINGLE PRECISION VALUE\r\n\tPOP\tCX\t\t;GET BACK FLAG BYTE\r\n\tMOV\tBX,OFFSET FAC\t;NOW SEE WHETHER POSITIVE OR NOT\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET EXPONENT BYTE\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT CGTC2\r\n\tLAHF\r\n\tDEC\tBX\t\t;SET TO HIGH MANTISSA BYTE\r\n\tSAHF\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tOR\tAL,AL\r\n\tJS\tSHORT ??L006\r\n\tJMP\tCGTC2\r\n??L006:\r\n\tAND\tAL,LOW 127D\t;MAKE IT POSITIVE\r\n\tMOV\tBYTE PTR [BX],AL\r\n\tMOV\tBX,OFFSET CLINEF\t;SET BIT IN [C] IN CLINEF\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tOR\tAL,CL\r\n\tMOV\tBYTE PTR [BX],AL\r\nCGTC2:\tMOVRI\t176O,42O,371O,203O\t;LOAD REGS WITH 1/2*PI\r\n\tCALL\tFMULT\t\t;MULTIPLY BY 1/(2*PI) TO GET FRACTION\r\n\tCALL\tCMPONE\t\t;SEE IF RESULT IS GREATER THAN ONE\r\n\tJNZ\tSHORT ??L007\r\n\tJMP\tFCERR\t\t;FC ERROR IF SO\r\n??L007:\r\nEXTRN\tPUSHF:NEAR\r\n\tCALL\tPUSHF\t\t;SAVE FAC ON STAC\r\n\tMOV\tBX,CNPNTS\t;GET NO. OF POINTS PER OCTANT\r\n\tADD\tBX,BX\t\t;TIMES 8 FOR TRUE CIRCUMFERENCE\r\n\tADD\tBX,BX\r\n\tADD\tBX,BX\r\n\tCALL\tMKINTC\t\t;STICK IT IN FAC\r\n\tCALL\tFRCSNG\t\t;AND MAKE IT SINGLE PRECISION\r\n\tPOPR\t\t\t;GET BACK ANG/2*PI IN REGS\r\n\tCALL\tFMULT\t\t;DO THE MULTIPLY\r\n\tCALL\tFRCINT\t\t;CONVERT TO INTEGER IN [HL]\r\n\tPOP\tDX\t\t;GET BACK TXTPTR\r\n\tXCHG\tBX,DX\r\n\tRET\t\r\n\r\nCMPONE:\tMOVRI\t201O,0,0,0\t;MAKE SURE FAC IS LESS THAN ONE\r\nEXTRN\tFCOMP:NEAR\r\n\tCALL\tFCOMP\r\n\tDEC\tAL\r\n\tRET\t\r\n\r\n\tSUBTTL GET and PUT - read and write graphics bit array\r\n\r\n\r\n;\r\n;       GET & PUT - READ & WRITE GRAPHICS BIT ARRAY\r\n;\r\n; SYNTAX:\r\n;       GET @(X,Y),ARRAYVAR\r\n;       PUT @(X,Y),ARRAYVAR[,FUNCTION]\r\n;\r\n;       FUNCTION = OR/AND/PRESET/PSET/XOR\r\n;\r\n\tEXTRN\tPGINIT:NEAR,PIXSIZ:NEAR,NREAD:NEAR,NWRITE:NEAR,XDELT:NEAR\r\n\tEXTRN\t$AND:NEAR,$OR:NEAR,$PRESET:NEAR,$PSET:NEAR,$XOR:NEAR\r\n\tEXTRN\tYDELT:NEAR,XCHGX:NEAR,XCHGY:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tPUTFLG:WORD,MINDEL:WORD,MAXDEL:WORD\r\nDSEG\tENDS\r\n\r\n\r\nPUBLIC\tGPUTG\r\nGPUTG:\tMOV\tBYTE PTR PUTFLG,AL\t;IFE PC8A&RSTLES-1STORE WHETHER PUTTING OR NOT\r\n\r\n\tPUSH\tAX\t\t;SAVE THIS FLAG A SEC\r\n\tPUSH\tBX\t\t;Save text pointer\r\n\tCALL\tPIXSIZ\t\t;Test for graphics mode\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT ??L008\r\n\tJMP\tFCERR\t\t;Not a graphics mode\r\n??L008:\r\n\tPOP\tBX\r\n\tCALL\tSCAN1\t\t;GET FIRST COORD\r\n\tCALL\tCHKRNG\r\n\tPOP\tAX\t\t;REGET PUT FLAG\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT ??L009\r\n\tJMP\tPUT1\r\n??L009:\r\n\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET MINUTK\t;EAT \"-\"\r\n\tPUSH\tCX\t\t;SAVE X1\r\n\tPUSH\tDX\t\t;SAVE Y1\r\n\tCALL\tSCAND\t\t;GET SECOND COORD FOR 'GET' ONLY\r\n\tCALL\tCHKRNG\r\n\tPOP\tDX\t\t;GET Y1 BACK\r\n\tPOP\tCX\t\t;AND X1\r\n\tPUSH\tBX\t\t;SAVE TXTPTR\r\n\tCALL\tYDELT\t\t;CALC DELTA Y\r\n\tJNB\tSHORT ??L010\r\n\tCALL\tXCHGY\t\t;MAKE DE=MIN(GXPOS,DE)\r\n??L010:\r\n\tINC\tBX\t\t;MAKE DELTA A COUNT\r\n\tMOV\tMINDEL,BX\t;SAVE DELTA Y IN MIDEL\r\n\tCALL\tXDELT\r\n\tJNB\tSHORT ??L011\r\n\tCALL\tXCHGX\t\t;BC = MIN(GXPOS,DE)\r\n??L011:\r\n\tINC\tBX\t\t;MAKE DELTA A COUNT\r\n\tMOV\tMAXDEL,BX\t;SAVE DX IN MAXDEL\r\n\tCALL\tMAPXYC\r\n\tPOP\tBX\t\t;GET BACK TXTPTR\r\n\tCALL\tGTARRY\t\t;SCAN ARRAY NAME\r\n\tPUSH\tBX\t\t;SAVE TXTPTR UNTIL DONE\r\n\tPUSH\tDX\t\t;SAVE BEG. OF ARRAY DATA PTR\r\n\tPUSH\tCX\t\t;SAVE END OF ARRAY DATA PTR\r\n\tPUSH\tDX\t\t;SAVE BEG. PTR AGAIN FOR COMPAR\r\n\tCALL\tPIXSIZ\t\t;GET # BITS PER PIXEL INTO [A]\r\n\tMOV\tDX,MAXDEL\r\n\tMOV\tBX,0\r\nMULBLP:\tADD\tBX,DX\t\t;CALC DX * BITS/PIX\r\n\tDEC\tAL\r\n\tJNZ\tSHORT MULBLP\t;KEEP LOOPING\r\n\tMOV\tCX,BX\t\t;SAVE THIS IS [BC]\r\n\tMOV\tDX,OFFSET (0+7)\t;Round to byte boundry.\r\n\tADD\tBX,DX\r\n\tXCHG\tBX,DX\t\t;RESULT TO [DE]\r\n\tHLFDE\t\t\t;NOW CALC NO. OF BYTES PER SCAN LINE\r\n\tHLFDE\t\r\n\tHLFDE\t\r\n\tMOV\tBX,MINDEL\t;GET DELTA Y\r\n\tPUSH\tCX\t\t;SAVE DX*BITS/PIX\r\n\tMOV\tCX,BX\t\t;INTO [BC] FOR UMULT\r\n\tCALL\tUMULT\t\t;[DE]=DX*DY*BITS/PIX\r\n\tPOP\tCX\t\t;GET BACK DX*BITS/PIX\r\n\tMOV\tBX,4\t\t;ADD 4 BYTES FOR DX,DY STORAGE\r\n\tADD\tBX,DX\t\t;[HL] HAS NO. OF BYTES TO BE USED\r\n\tPOP\tDX\t\t;BEG OF ARRAY DATA TO [HL]\r\n\tADD\tBX,DX\t\t;ADD NO. OF BYTES TO BE USED\r\n\tXCHG\tBX,DX\t\t;[DE] = CALCULATED END OF DATA\r\n\tPOP\tBX\t\t;END OF ARRAY DATA TO [HL]\r\n\tCMP\tBX,DX\r\n\tJAE\tSHORT ??L012\r\n\tJMP\tFCERR\t\t;ERROR IF TOO BIG\r\n??L012:\r\n\t\t\t\t;BEG OF DATA PTR IS ON STK HERE\r\n\tPOP\tBX\t\t;GET POINTER TO ARRAY DATA\r\n\tCMP\tBX,DX\r\n\tJNAE\tSHORT ??L013\r\n\tJMP\tFCERR\t\t;ARRAY START+LENGTH .GT. 64K\r\n??L013:\r\n\tMOV\tBYTE PTR [BX],CL\t;SAVE DX*BITS/PIX IN 1ST 2 BYTES OF ARY\r\n\tINC\tBX\r\n\tMOV\tBYTE PTR [BX],CH\t;PASS NO. OF BITS DESIRED IN [BC]\r\n\tINC\tBX\r\n\tMOV\tDX,MINDEL\t;GET LINE (Y) COUNT\r\n\tMOV\t[BX],DX\r\n\tINC\tBX\r\n\tINC\tBX\t\t;SAVE DY IN 2ND 2 BYTES\r\n\tOR\tAL,AL\t\t;CLEAR CARRY FOR GET INIT.\r\n\tJMP\tGOPGIN\t\t;GIVE LOW LEVEL ADDR OF ARRAY & GO\r\n\r\nPUT1:\tPUSH\tBX\t\t;SAVE TXTPTR\r\n\tCALL\tMAPXYC\t\t;MAP THE POINT\r\n\tPOP\tBX\r\n\tCALL\tGTARRY\t\t;SCAN ARRAY NAME & GET PTR TO IT\r\n\tPUSH\tDX\t\t;SAVE PTR TO DELTAS IN ARRAY\r\n\tDEC\tBX\t\t;NOW SCAN POSSIBLE PUT OPTION\r\n\tCALL\tCHRGTR\r\n\tMOV\tCH,LOW 5\t;DEFAULT OPTION IS XOR\r\n\tJZ\tSHORT PUT2\t;IF NO CHAR, USE DEFAULT\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;MUST BE A COMMA\r\n\tXCHG\tBX,DX\t\t;PUT TXTPTR IN [DE]\r\n\tMOV\tBX,OFFSET GFUNTB+4\t;TABLE OF POSSIBLE OPTIONS\r\nPFUNLP:\r\n\tINS86\t56\t\t;CS OVERRIDE\r\n\tCMP\tAL,BYTE PTR [BX]\t;IS THIS AN OPTION?\r\n\tJZ\tSHORT PUT20\t;YES, HAND IT TO PGINIT.\r\n\tDEC\tBX\t\t;POINT TO NEXT\r\n\tDEC\tCH\r\n\tJNZ\tSHORT PFUNLP\r\n\tXCHG\tBX,DX\t\t;GET TXTPTR BACK TO [HL]\r\n\tPOP\tDX\t\t;CLEAN UP STACK\r\n\tRET\t\t\t;LET NEWSTT GIVE SYNTAX ERROR\r\nPUT20:\tXCHG\tBX,DX\t\t;GET TXTPTR BACK TO [HL]\r\n\tCALL\tCHRGTR\t\t;EAT THE TOKEN\r\nPUT2:\r\n\tDEC\tCH\t\t;1..5 -TO 0..4\r\n\tMOV\tAL,CH\t\t;INTO [A] FOR PGINIT\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;POP ARRAY PTR, PUSH TXTPTR\r\n\tPUSH\tAX\t\t;SAVE PUT ACTION MODE\r\n\tMOV\tDX,[BX]\t\t;[DE]=NO. OF BITS IN X\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tPUSH\tDX\t\t;SAVE BIT COUNT\r\n\tPUSH\tBX\t\t;SAVE ARRAY POINTER\r\n\tXCHG\tBX,DX\t\t;INTO [HL] FOR IDIV\r\n\tCALL\tPIXSIZ\t\t;GET BITS/PIXEL INTO [DE]\r\n\tMOV\tDL,AL\t\t;INTO [E] FOR COUNTING\r\nIF\tPWR2PX  \r\nDIVBLP:\tDEC\tDL\t\t;DIVIDE BY [E] (POWER-OF-2 CASE)\r\n\tJNZ\tSHORT ??L014\r\n\tJMP\tDIVBTX\r\n??L014:\r\n\tHLFHL\t\t\t;DIVIDE BY TWO [E]-1 TIMES\r\n\tJMP\tSHORT DIVBLP\r\nDIVBTX:\r\nENDIF \r\nIFE\tPWR2PX  \r\n\tEXTRN\tIDIV:NEAR\r\n\tMOV\tDH,LOW 0\r\n\tXCHG\tBX,DX\t\t;IDIV divides DE by HL\r\n\tCALL\tIDIV\t\t;CALC NO. OF POINTS\r\nENDIF \r\n\tDEC\tBX\t\t;DECREMENT DX SINCE IT'S A COUNTER\r\n\tMOV\tDX,GXPOS\t;NOW CALC TRUE X\r\n\tADD\tBX,DX\r\n\tJB\tSHORT PRNGER\t;ERROR IF CARRY\r\n\tMOV\tCX,BX\t\t;TO [BC] FOR SCALXY\r\n\tPOP\tBX\t\t;GET BACK ARRAY POINTER\r\n\tMOV\tDX,[BX]\t\t;[DE] = DELTA Y ([HL] POINTS TO DATA)\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tPUSH\tDX\t\t;SAVE DELTA Y ON STACK\r\n\tPUSH\tBX\t\t;SAVE PTR ON STACK AGAIN\r\n\tMOV\tBX,GYPOS\r\n\tDEC\tDX\t\t;DECREMENT DY SINCE IT'S A COUNTER\r\n\tADD\tBX,DX\r\nPRNGER:\tJAE\tSHORT ??L015\r\n\tJMP\tFCERR\t\t;ERROR IF CARRY\r\n??L015:\r\n\tXCHG\tBX,DX\t\t;[DE]=Y + DELTA Y\r\n\tPOP\tBX\t\t;GET BACK ARRAY POINTER\r\n\tCALL\tCHKRNG\t\t;MAKE SURE [BC],[HL] ARE ON THE SCREEN\r\n\tPOP\tDX\t\t;POP DY\r\n\tPOP\tCX\t\t;POP DX*BITS/PIX\r\n\tPOP\tAX\t\t;GET BACK ACTION MODE\r\n\tSTC\t\t\t;SET CARRY TO FLAG PUT INIT\r\n\r\nGOPGIN:\tPUSH\tDX\t\t;RESAVE DY\r\n\tCALL\tPGINIT\t\t;[BC]=BIT COUNT,[HL]=ARRAY ADDR\r\n\tPOP\tDX\t\t;GET Y COUNT\r\n\r\nPGLOOP:\tPUSH\tDX\t\t;SAVE LINE COUNT\r\n\tMOV\tAL,BYTE PTR PUTFLG\t;SEE IF PUTTING OR GETTING\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT PGLOO2\r\n\tCALL\tNREAD\r\n\tJMP\tSHORT PGLOO3\r\nPGLOO2:\tCALL\tNWRITE\r\nPGLOO3:\r\n\tCALL\tDOWNC\t\t;NOW MOVE DOWN A LINE\r\n\tPOP\tDX\r\n\tDEC\tDX\r\n\tOR\tDX,DX\r\n\tJNZ\tSHORT PGLOOP\t;CONTINUE IF NOT ZERO\r\n\tPOP\tBX\t\t;GET BACK TXTPTR\r\n\tRET\t\t\t;AND RETURN\r\n\r\nGTARRY:\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;EAT COMMA\r\n\tMOV\tAL,LOW 1\t;SEARCH ARRAYS ONLY\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSUBFLG:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR SUBFLG,AL\r\nEXTRN\tPTRGET:NEAR\r\n\tCALL\tPTRGET\t\t;GET PTR TO ARRAY\r\n\tJZ\tSHORT ??L016\r\n\tJMP\tFCERR\t\t;NOT THERE - ERROR\r\n??L016:\r\n\tMOV\tBYTE PTR SUBFLG,AL\t;CLEAR THIS\r\n\tPUSH\tBX\t\t;SAVE TXTPTR\r\n\tMOV\tBX,CX\t\t;HL = PTR TO ARRAY\r\n\tXCHG\tBX,DX\t\t;HL = LENGTH\r\n\tADD\tBX,DX\t\t;HL = LAST BYTE OF ARRAY\r\n\tPUSH\tBX\t\t;SAVE\r\n\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\t\t;GET NO. OF DIMS\r\n\tADD\tAL,AL\t\t;DOUBLE SINCE 2 BYTE ENTRIES\r\n\tMOV\tBL,AL\r\n\tMOV\tBH,LOW 0\r\n\tINC\tCX\t\t;SKIP NO. OF DIMS\r\n\tADD\tBX,CX\r\n\tXCHG\tBX,DX\t\t;DE = PTR TO FIRST BYTE OF DATA\r\n\tPOP\tCX\t\t;BC = PTR TO LAST BYTE OF DATA\r\n\tPOP\tBX\t\t;GET TXTPTR\r\n\tRET\t\r\n\r\nGFUNTB:\r\n\tDB\tOFFSET $OR\t;LIST OF VALID PUT OPTIONS\r\n\tDB\tOFFSET $AND\r\n\tDB\tOFFSET $PRESET\r\n\tDB\tOFFSET $PSET\r\n\tDB\tOFFSET $XOR\r\n\tPAGE\t\r\n\tSUBTTL GRAPHICS MACRO LANGUAGE SUPPORT\r\n;\r\n; GRAPHICS MACRO LANGUAGE SUPPORT\r\n;\r\n\tEXTRN\tVALSCN:NEAR,DECFET:NEAR,MACLNG:NEAR,MCLXEQ:NEAR,FETCHZ:NEAR\r\n\tEXTRN\tNEGD:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDRWFLG:WORD,DRWSCL:WORD,DRWANG:WORD\r\nDSEG\tENDS\r\nPUBLIC\tDRAW\r\nDRAW:\tPUSH\tBX\t\t;Save text pointer\r\n\tCALL\tPIXSIZ\t\t;Get bits/pixel\r\n\tOR\tAL,AL\t\t;Test for 0 (text only mode)\r\n\tJNZ\tSHORT ??L017\r\n\tJMP\tFCERR\t\t;DRAW not allowed in text mode\r\n??L017:\r\n\tPOP\tBX\t\t;Restore text pointer\r\n\tMOV\tDX,OFFSET DRWTAB\t;DISPATCH TABLE FOR GML\r\n\tXOR\tAL,AL\t\t;CLEAR OUT DRAW FLAGS\r\n\tMOV\tBYTE PTR DRWFLG,AL\r\n\tJMP\tMACLNG\t\t;GO DO IT.\r\n\r\nDRWTAB:\tDB\t\"U\"+128D\t;UP\r\n\tADR\tDRUP\t\t; ASM86 doesn't like DUP, 9-Jul-82/NGT\r\n\tDB\t\"D\"+128D\t;DOWN\r\n\tADR\tDRDOWN\r\n\tDB\t\"L\"+128D\t;LEFT\r\n\tADR\tDRLEFT\r\n\tDB\t\"R\"+128D\t;RIGHT\r\n\tADR\tDRIGHT\r\n\tDB\t\"M\"\t\t;MOVE\r\n\tADR\tDMOVE\r\n\tDB\t\"E\"+128D\t;-,-\r\n\tADR\tDRWEEE\r\n\tDB\t\"F\"+128D\t;+,-\r\n\tADR\tDRWFFF\r\n\tDB\t\"G\"+128D\t;+,+\r\n\tADR\tDRWGGG\r\n\tDB\t\"H\"+128D\t;-,+\r\n\tADR\tDRWHHH\r\n\tDB\t\"A\"+128D\t;ANGLE COMMAND\r\n\tADR\tDANGLE\r\n\tDB\t\"B\"\t\t;MOVE WITHOUT PLOTTING\r\n\tADR\tDNOPLT\r\n\tDB\t\"N\"\t\t;DON'T CHANGE CURRENT COORDS\r\n\tADR\tDNOMOV\r\n\tDB\t\"X\"\t\t;EXECUTE STRING\r\n\tADR\tMCLXEQ\r\n\tDB\t\"C\"+128D\t;COLOR\r\n\tADR\tDCOLR\r\n\tDB\t\"S\"+128D\t;SCALE\r\n\tADR\tDSCALE\r\n\tDB\t00\t\t;END OF TABLE\r\n\r\nDRUP:\tNEGDE\t\t\t;MOVE +0,-Y\r\nDRDOWN:\t\t\t\t;MOVE +0,+Y\r\n\tMOV\tCX,0\t\t;DX=0\r\n\tJMP\tSHORT DOMOVR\t;TREAT AS RELATIVE MOVE\r\n\r\nDRLEFT:\tNEGDE\t\t\t;MOVE -X,+0\r\nDRIGHT:\t\t\t\t;MOVE +X,+0\r\n\tMOV\tCX,DX\t\t;[BC]=VALUE\r\n\tMOV\tDX,0\t\t;DY=0\r\n\tJMP\tSHORT DOMOVR\t;TREAT AS RELATIVE MOVE\r\n\r\nDRWHHH:\tNEGDE\t\t\t;MOVE -X,-Y\r\nDRWFFF:\tMOV\tCX,DX\t\t;MOVE +X,+Y\r\n\tJMP\tSHORT DOMOVR\r\n\r\nDRWEEE:\tMOV\tCX,DX\t\t;MOVE +X,-Y\r\nDRWHHC:\tNEGDE\t\r\n\tJMP\tSHORT DOMOVR\r\n\r\nDRWGGG:\tNEGDE\t\t\t;MOVE -X,+Y\r\n\tMOV\tCX,DX\r\n\tJMP\tSHORT DRWHHC\t;MAKE DY POSITIVE & GO\r\n\r\nDMOVE:\tCALL\tFETCHZ\t\t;GET NEXT CHAR AFTER COMMA\r\n\tMOV\tCH,LOW 0\t;ASSUME RELATIVE\r\n\tCMP\tAL,LOW \"+\"\t;IF \"+\" OR \"-\" THEN RELATIVE\r\n\tJZ\tSHORT MOVREL\r\n\tCMP\tAL,LOW \"-\"\r\n\tJZ\tSHORT MOVREL\r\n\tINC\tCH\t\t;NON-Z TO FLAG ABSOLUTE\r\nMOVREL:\tMOV\tAL,CH\r\n\tPUSH\tAX\t\t;SAVE ABS/REL FLAG ON STACK\r\n\tCALL\tDECFET\t\t;BACK UP SO VALSCN WILL SEE \"-\"\r\n\tCALL\tVALSCN\t\t;GET X VALUE\r\n\tPUSH\tDX\t\t;SAVE IT\r\n\tCALL\tFETCHZ\t\t;NOW CHECK FOR COMMA\r\n\tCMP\tAL,LOW 44\t;COMMA?\r\n\tJZ\tSHORT ??L018\r\n\tJMP\tFCERR\r\n??L018:\r\n\tCALL\tVALSCN\t\t;GET Y VALUE IN D\r\n\tPOP\tCX\t\t;GET BACK X VALUE\r\n\r\n\tPOP\tAX\t\t;GET ABS/REL FLAG\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT DRWABS\t;NZ - ABSOLUTE\r\n\r\nDOMOVR:\tCALL\tDSCLDE\t\t;ADJUST Y OFFSET BY SCALE\r\n\tPUSH\tDX\t\t;SAVE Y OFFSET\r\n\tMOV\tDX,CX\t\t;GET X INTO [DE]\r\n\tCALL\tDSCLDE\t\t;GO SCALE IT.\r\n\tXCHG\tBX,DX\t\t;GET ADJUSTED X INTO [HL]\r\n\tPOP\tDX\t\t;GET ADJUSTED Y INTO [DE]\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR CSCLXY,AL\r\n\tMOV\tAL,BYTE PTR DRWANG\t;GET ANGLE BYTE\r\n\tRCR\tAL,1\t\t;LOW BIT TO CARRY\r\n\tJAE\tSHORT ANGEVN\t;ANGLE IS EVEN - DON'T SWAP X AND Y\r\n\tPUSH\tAX\t\t;SAVE THIS BYTE\r\n\tPUSH\tDX\t\t;SAVE DY\r\n\tPUSH\tBX\t\t;SAVE DX\r\n\tCALL\tGTASPC\t\t;GO GET SCREEN ASPECT RATIO\r\n;NOTE: TOSHIBA GTASPC routine does this logic(i.e. it sets CSCLXY if aspect\r\n;                   ratio is greater than one).\r\n\tMOV\tAL,BH\r\n\tOR\tAL,AL\t\t;IS ASPECT RATIO GREATER THAN ONE?\r\n\tJZ\tSHORT ASPLS0\t;BRIF GOOD ASPECT RATIO\r\n\tMOV\tAL,LOW 1\r\n\tMOV\tBYTE PTR CSCLXY,AL\r\n\tXCHG\tBX,DX\r\nASPLS0:\r\n\tMOV\tCL,BL\t\t;GET ASPECT RATIO INTO [C] FOR GOSCAL\r\n\tPOP\tBX\t\t;GET BACK DX\r\n\tMOV\tAL,BYTE PTR CSCLXY\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT ASPLS1\t;branch if aspect ratio less 1.0\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;[HL]=DY, save DX\r\nASPLS1:\r\n\tXCHG\tBX,DX\t\t;1/ASPECT TO [HL]\r\n\tPUSH\tBX\t\t;SAVE 1/ASPECT\r\n\tCALL\tGOSCAL\t\t;SCALE DELTA X BY ASPECT RATIO\r\n\tPOP\tCX\t\t;GET BACK 1/ASPECT RATIO\r\n\tPOP\tBX\t\t;GET DY\r\n\tPUSH\tDX\t\t;SAVE SCALED DX\r\n\tXCHG\tBX,DX\t\t;DY TO [DE] FOR GOSCAL\r\n\tMOV\tBX,0\r\nDMULP:\tADD\tBX,DX\t\t;MULTIPLY [DE] BY HI BYTE OF 1/ASPECT\r\n\tDEC\tCH\r\n\tJNZ\tSHORT DMULP\r\n\tPUSH\tBX\t\t;SAVE PARTIAL RESULT\r\n\tCALL\tGOSCAL\t\t;MULTIPLY [DE] BY LOW BYTE\r\n\tPOP\tBX\t\t;GET BACK PARTIAL RESULT\r\n\tADD\tBX,DX\t\t;[HL]=Y * 1/ASPECT\r\n\tPOP\tDX\t\t;GET BACK SCALED Y\r\n\tMOV\tAL,BYTE PTR CSCLXY\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT ASLSS1\t;branch if aspect ratio less than 1\r\n\tXCHG\tBX,DX\r\nASLSS1:\r\n\tNEGDE\t\t\t;ALWAYS NEGATE NEW DY\r\n\tPOP\tAX\t\t;GET BACK SHIFTED ANGLE\r\nANGEVN:\tRCR\tAL,1\t\t;TEST SECOND BIT\r\n\tJAE\tSHORT ANGPOS\t;DON'T NEGATE COORDS IF NOT SET\r\n\tNEGHL\t\r\n\tNEGDE\t\t\t;NEGATE BOTH DELTAS\r\nANGPOS:\tCALL\tGTABSC\t\t;GO CALC TRUE COORDINATES\r\n\r\nDRWABS:\tMOV\tAL,BYTE PTR DRWFLG\t;SEE WHETHER WE PLOT OR NOT\r\n\tADD\tAL,AL\t\t;CHECK HI BIT\r\n\tJB\tSHORT DSTPOS\t;JUST SET POSITION.\r\n\tPUSH\tAX\t\t;SAVE THIS FLAG\r\n\tPUSH\tCX\t\t;SAVE X,Y COORDS\r\n\tPUSH\tDX\t\t;BEFORE SCALE SO REFLECT DISTANCE OFF\r\n\tCALL\tSCALXY\t\t;SCALE IN CASE COORDS OFF SCREEN\r\n\tCALL\tCLINE2\r\n\tPOP\tDX\r\n\tPOP\tCX\t\t;GET THEM BACK\r\n\tPOP\tAX\t\t;GET BACK FLAG\r\nDSTPOS:\tADD\tAL,AL\t\t;SEE WHETHER TO STORE COORDS\r\n\tJB\tSHORT DNSTOR\t;DON'T UPDATE IF B6=1\r\n\tMOV\tGRPACY,DX\t;UPDATE GRAPHICS AC\r\n\tMOV\tBX,CX\r\n\tMOV\tGRPACX,BX\r\nDNSTOR:\tXOR\tAL,AL\t\t;CLEAR SPECIAL FUNCTION FLAGS\r\n\tMOV\tBYTE PTR DRWFLG,AL\r\n\tRET\t\r\n\r\nDNOMOV:\tMOV\tAL,LOW 64D\t;SET BIT SIX IN FLAG BYTE\r\n\tJMP\tSHORT DSTFLG\r\n\r\nDNOPLT:\tMOV\tAL,LOW 128D\t;SET BIT 7\r\nDSTFLG:\tMOV\tBX,OFFSET DRWFLG\r\n\tOR\tAL,BYTE PTR [BX]\r\n\tMOV\tBYTE PTR [BX],AL\t;STORE UPDATED BYTE\r\n\tRET\t\r\n\r\nDANGLE:\tJAE\tSHORT NCFCER\t;ERROR IF NO ARG\r\n\tMOV\tAL,DL\t\t;MAKE SURE LESS THAN 4\r\n\tCMP\tAL,LOW 4\r\n\tJAE\tSHORT NCFCER\t;ERROR IF NOT\r\n\tMOV\tBYTE PTR DRWANG,AL\r\n\tRET\t\r\n\r\nNCFCER:\r\nDSCALE:\tJNAE\tSHORT ??L019\r\n\tJMP\tFCERR\t\t;FC ERROR IF NO ARG\r\n??L019:\r\n\tMOV\tAL,DH\t\t;MAKE SURE LESS THAN 256\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT ??L020\r\n\tJMP\tFCERR\r\n??L020:\r\n\tMOV\tAL,DL\r\n\tMOV\tBYTE PTR DRWSCL,AL\t;STORE SCALE FACTOR\r\n\tRET\t\r\n\r\nDSCLDE:\tMOV\tAL,BYTE PTR DRWSCL\t;GET SCALE FACTOR\r\n\tOR\tAL,AL\t\t;ZERO MEANS NO SCALING\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tMOV\tBX,0\r\nDSCLP:\tADD\tBX,DX\t\t;ADD IN [DE] SCALE TIMES\r\n\tDEC\tAL\r\n\tJNZ\tSHORT DSCLP\r\n\tXCHG\tBX,DX\t\t;PUT IT BACK IN [DE]\r\n\tMOV\tAL,DH\t\t;SEE IF VALUE IS NEGATIVE\r\n\tADD\tAL,AL\r\n\tPUSHF\t\t\t;SAVE RESULTS OF TEST\r\n\tJAE\tSHORT DSCPOS\r\n\tDEC\tDX\t\t;MAKE IT TRUNCATE DOWN\r\nDSCPOS:\tHLFDE\t\t\t;DIVIDE BY FOUR\r\n\tHLFDE\t\r\n\tPOPF\t\t\t;SEE IF WAS NEGATIVE\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;ALL DONE IF WAS POSITIVE\r\n\tMOV\tAL,DH\t\t;OR IN HIGH 2 BITS TO MAKE NEGATIVE\r\n\tOR\tAL,LOW 192D\r\n\tMOV\tDH,AL\r\n\tINC\tDX\t\t;ADJUST SO TRUNCATING TO LOWER VALUE\r\n\tRET\t\r\n\r\nGOSCAL:\tMOV\tAL,DH\t\t;SEE IF NEGATIVE\r\n\tADD\tAL,AL\r\n\tJAE\tSHORT GOSC2\t;NO, MULTIPLY AS-IS\r\n\tMOV\tBX,OFFSET NEGD\t;NEGATE BEFORE RETURNING\r\n\tPUSH\tBX\r\n\tNEGDE\t\t\t;MAKE POSITIVE FOR MULTIPLY\r\nGOSC2:\tMOV\tAL,CL\t\t;GET SCALE FACTOR\r\n\tJMP\tSCALE2\t\t;DO THE SCALE\r\n\r\nDCOLR:\tJAE\tSHORT NCFCER\t;FC ERROR IF NO ARG\r\n\tMOV\tAL,DL\t\t;GO SET ATTRIBUTE\r\n\tCALL\tSETATR\r\n\tJAE\tSHORT ??L021\r\n\tJMP\tFCERR\t\t;ERROR IF ILLEGAL ATTRIBUTE\r\n??L021:\r\n\tMOV\tBYTE PTR ATRBYT,AL\t;Save as default\r\n\tRET\t\r\n\r\nCHKRNG:\tPUSH\tBX\t\t;SAVE TXTPTR\r\n\tCALL\tSCALXY\r\n\tJNAE\tSHORT ??L022\r\n\tJMP\tFCERR\t\t;OUT OF BOUNDS - ERROR\r\n??L022:\r\nCHKPHR:\tPOP\tBX\t\t;REGET TXTPTR\r\n\tRET\t\r\n\r\n\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "BIBOOT.ASM",
          "type": "blob",
          "size": 2.125,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   BIBOOT - Initialization File for ASM86 BASICs\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- --------- -----------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT CORPORATION\r\n--------- --- ---- -- --------- -----------\r\n\r\n        by Niklas Traub\r\n        *\r\n\tINCLUDE\tGIO86U\r\n\t.SALL\r\n\r\nCPM86=0\r\n\r\n\tINCLUDE\tMSDOSU\r\n\r\n\tPAGE\t\r\n\tSUBTTL  ASM86 Version\r\n;\r\n;  There is a problem with running the ASM86 sources for BASIC as they\r\n; stand.  MSDOS puts a 100 hex byte control block at the beginning of the\r\n; EXE file and sets up the ES register to point to it.  BASIC, however,\r\n; expects this block to be at 0 in the code segment. The quick and dirty\r\n; solution is to copy the block into the code segment before doing anything\r\n; else.  This module is included in the linker file list AFTER all others,\r\n; but is executed first since it is defined as the entry point.\r\n;  A 100H bytes are copied from ES:0 to CS:0 and then jump is done to\r\n; the START label.  To accomodate the block, BINTRP should have an ORG 100H\r\n; before any code.\r\n;\r\n; NOTE: Never convert the EXE file to a COM file.  COM files have the CS\r\n;       register pointing to the control block on entry, so all offsets\r\n;       for immediate values will be off by 100H.\r\n;\r\n\tEXTRN\tSTART:NEAR\r\n\r\n;BIBOOT - ASM86 Version Specific Initialization\r\n;Entry  - ES:0 pointing to start of control block.\r\n;         DS:0 pointing to start of control block.\r\n;\r\nBIBOOT:\r\n\tMOV\tCX,CS\t\t; Get BASIC's segment\r\n\tMOV\tES,CX\t\t; Make it the destination segment\r\n\tXOR\tSI,SI\t\t; Start at ES:0\r\n\tXOR\tDI,DI\t\t; Destination is CS:0\r\n\tMOV\tCX,200O\t\t; There are 100H bytes to move\r\n\tCLD\t\r\n REP\tMOVSW\r\n\tMOV\tCX,DS\t\t; Restore segment registers\r\n\tMOV\tES,CX\r\n\tJMP\tSTART\r\nCSEG    ENDS\r\n;\r\n; Last label in data segment.  Is used by BASIC to initialize TXTTAB, etc.\r\n;\r\nDSEG    SEGMENT PUBLIC 'DATASG'\r\n        ASSUME  DS:DSEG\r\n        PUBLIC  LSTVAR\r\nLSTVAR  LABEL   WORD\r\nDSEG    ENDS\r\nCSEG    SEGMENT PUBLIC 'CODESG'\r\n        ASSUME  CS:CSEG\r\nCSEG\tENDS\r\n\tEND\tBIBOOT\t\t; BIBOOT is the entry point.\r\n;\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "BIMISC.ASM",
          "type": "blob",
          "size": 23.625,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   BIMISC  BASIC Interpreter miscellaneous routines/WHG/PGA etc.\r\n\r\n\r\n\t.RADIX\t10\r\nPC8A=0\r\n\tLABEL=PC8A\r\nTRSHHC=0\r\nNECPPC=0\r\nNNECBS=0\r\nALPS=0\r\nALPCPM=0\r\nOKI=0\r\nHAL=0\r\nTSHIBA=0\r\nCAN8=0\r\n\tLTRACE=ALPCPM\t\t;trace output selectable\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t; Data Segment\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tARYTAB:WORD,CURLIN:WORD,DATPTR:WORD,FRETOP:WORD,MEMSIZ:WORD\r\n\tEXTRN\tOLDLIN:WORD,OLDTXT:WORD,STREND:WORD\r\n\tEXTRN\tSUBFLG:WORD,SAVTXT:WORD,TEMPPT:WORD,TEMPST:WORD,TXTTAB:WORD\r\n\tEXTRN\tVALTYP:WORD,VARTAB:WORD,TEMP:WORD\r\n\tEXTRN\tTOPMEM:WORD\r\n\tEXTRN\tPRMLEN:WORD,PRMLN2:WORD,PRMSTK:WORD,FUNACT:WORD,NOFUNS:WORD\r\nDSEG\tENDS\t\t\t; End of data segment externals\r\n\r\n\t\t\t\t; Code Segment ( terminated by END at bottom of file )\r\n\r\n\tEXTRN\tBRKTXT:NEAR,CRDO:NEAR,CRDONZ:NEAR,ERROR:NEAR,FADDS:NEAR\r\n\tEXTRN\tFCERR:NEAR,FCOMP:NEAR,FNDFOR:NEAR,FNDLIN:NEAR,FRMEVL:NEAR\r\n\tEXTRN\tINLIN:NEAR,LINGET:NEAR\r\n\tEXTRN\tMOVFM:NEAR,MOVMF:NEAR,MOVRM:NEAR,NEWSTT:NEAR,OVERR:NEAR\r\n\tEXTRN\tPTRGET:NEAR\r\n\tEXTRN\tSNERR:NEAR,OUTDO:NEAR,CHRCON:NEAR\r\n\tEXTRN\tTMERR:NEAR,USERR:NEAR\r\n\tEXTRN\tERRCN:NEAR,ERRFIN:NEAR,ERROM:NEAR,GETBYT:NEAR,STPRDY:NEAR\r\n\tEXTRN\tNFERR:NEAR,INTID2:NEAR,NXTCON:NEAR\r\n\r\n\r\n\tEXTRN\tCHRGTR:NEAR\r\n\tEXTRN\tGETYPR:NEAR\r\n\tEXTRN\tVMOVE:NEAR,FRQINT:NEAR,IADD:NEAR,ICOMP:NEAR\r\n\tEXTRN\tFRMQNT:NEAR,FRESTR:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDEFTBL:WORD\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tOPTFLG:WORD,OPTVAL:WORD\r\nDSEG\tENDS\r\n\tPUBLIC\tSTOPRG\r\n\tPUBLIC\tTON,TOFF\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tTRCFLG:WORD\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tONEFLG:WORD,ONELIN:WORD,SAVSTK:WORD\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tNXTFLG:WORD\r\nDSEG\tENDS\r\n\r\n\tPUBLIC\tCLEARC,STOP,ISLET,ISLET2,STKINI,GETSTK\r\n\tPUBLIC\tSCRATH,SCRTCH\r\n\tPUBLIC\tSTPEND,CONT,ENDST,GTMPRT,RUNC,STPEND,ENDCON,RESTORE\r\n\tPUBLIC\tSTOP,RESFIN,STKERR,REASON,OMERR,OMERRR\r\n\r\n\tEXTRN\tLINKER:NEAR\r\n\r\n\tPAGE\t\r\n;\r\n; THIS ROUTINE IS USED TO MAKE SURE A CERTAIN NUMBER\r\n; OF LOCATIONS REMAIN AVAILABLE FOR THE\r\n; STACK. THE CALL IS :\r\n;       MVI     C,NUMBER OF 2 BYTE ENTRIES NECESSARY\r\n;       CALL    GETSTK\r\n;\r\n; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS\r\n; AN ARBITRARY AMOUNT OF STUFF ON THE STACK\r\n; (I.E. ANY RECURSIVE ROUTINE LIKE FRMEVL)\r\n; IT IS ALSO CALLED BY ROUTINES SUCH AS \"GOSUB\" AND \"FOR\"\r\n; WHICH MAKE PERMANENT ENTRIES ON THE STACK\r\n; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED\r\n; NUMLEV STACK LOCATIONS NEED NOT CALL THIS\r\n;\r\nGETSTK:\tPUSH\tBX\t\t;SAVE [H,L]\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSTKLOW:WORD\r\nDSEG\tENDS\r\n\tMOV\tBX,STKLOW\t;in GIO86, stack can grow down to STKLOW\r\n\tMOV\tCH,LOW 0\r\n\tADD\tBX,CX\r\n\tADD\tBX,CX\t\t;SEE IF WE CAN HAVE THIS MANY\r\n;\r\n; [H,L]= SOME ADDRESS\r\n; [H,L] IS EXAMINED TO MAKE SURE AT LEAST NUMLEV\r\n; LOCATIONS REMAIN BETWEEN IT AND THE TOP OF THE STACK\r\n;\r\n\tCONS1=256-(2*NUMLEV)\r\n\tMOV\tAL,LOW OFFSET CONS1\t;SET [H,L]=-[H,L]-2*NUMLEV\r\n\tSUB\tAL,BL\r\n\tMOV\tBL,AL\r\n\tMOV\tAL,LOW 255\r\n\tSBB\tAL,BH\r\n\tMOV\tBH,AL\r\n\tJB\tSHORT OMERR\t;IN CASE [H,L] WAS TOO BIG(MBM 3/18**)\r\n\t\t\t\t;NOW SEE IF SP IS LARGER\r\n\tADD\tBX,SP\t\t;IF SO, CARRY WILL BE SET\r\n\tPOP\tBX\t\t;GET BACK ORIGINAL [H,L]\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;WAS OK?\r\n\r\n;OMERR fixes program links (starting at TXTTAB), resets SAVSTK to TOPMEM-2\r\n; and issues an Out-of-Memory error message\r\n;\r\nOMERR:\r\n\tCALL\tLINKER\t\t;Fix links incase OMERR was called after\r\n\t\t\t\t;deleting a program line because user\r\n\t\t\t\t;was attempting to replace it.\r\n\t\t\t\t;ONLY IMPORTANT IN VERSIONS WHERE\r\n\t\t\t\t;STACK CONTEXT SURVIVES OTHER ERRORS\r\n\tMOV\tBX,TOPMEM\r\n\t\t\t\t;ELIMINATE ALL STACK CONTEXT TO FREE\r\n\tDEC\tBX\t\t; UP SOME MEMORY SPACE\r\n\tDEC\tBX\t\t;MAKE SURE THE FNDFOR STOPPER IS SAVED\r\n\tMOV\tSAVSTK,BX\t;PLACE STACK IS RESTORED FROM\r\nOMERRR:\r\n\tMOV\tDX,OFFSET ERROM\t;\"OUT OF MEMORY\"\r\n\tJMP\tERROR\r\n\tEXTRN\tGARBA2:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCHNFLG:WORD\r\nDSEG\tENDS\r\nREASON:\r\n\tINS86\t71,36,FRETOP\t;CMP FRETOP,BX\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;YES\r\n\tMOV\tAL,BYTE PTR CHNFLG\r\n\tOR\tAL,AL\t\t;can't garbage collect if CHAINING\r\n\tJNZ\tSHORT OMERR\r\n\tPUSH\tCX\t\t;SAVE ALL REGS\r\n\tPUSH\tDX\r\n\tPUSH\tBX\r\n\tCALL\tGARBA2\t\t;DO A GARBAGE COLLECTION\r\n\tPOP\tBX\t\t;RESTORE ALL REGS\r\n\tPOP\tDX\r\n\tPOP\tCX\r\n\tINS86\t71,36,FRETOP\t;CMP FRETOP,BX\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;YES\r\n\tJMP\tSHORT OMERR\t;NO, GIVE \"OUT OF MEMORY BUT DONT TOUCH STACK\r\n;\r\n;PAGE\r\n\r\n\tSUBTTL NODSKS, SCRATCH (NEW), RUNC, CLEARC, STKINI, QINLIN\r\n\r\n\tPUBLIC\tNODSKS\r\nNODSKS:\r\n\r\n\tXOR\tAL,AL\r\n;\r\n; THE \"NEW\" COMMAND CLEARS THE PROGRAM TEXT AS WELL\r\n; AS VARIABLE SPACE\r\n;\r\nSCRATH:\tJZ\tSHORT $+3\r\n\tRET\t\t\t;MAKE SURE THERE IS A TERMINATOR\r\nSCRTCH:\r\n\tMOV\tBX,TXTTAB\t;GET POINTER TO START OF TEXT\r\n\tCALL\tTOFF\t\t;TURN OFF TRACE. SET [A]=0.\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tPROFLG:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR PROFLG,AL\t;NO LONGER A PROTECTED FILE\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tAUTFLG:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR AUTFLG,AL\t;CLEAR AUTO MODE\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tPTRFLG:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR PTRFLG,AL\t;SAY NO POINTERS EXIST\r\n\tMOV\tBYTE PTR [BX],AL\t;SAVE AT END OFF TEXT\r\n\tINC\tBX\t\t;BUMP POINTER\r\n\tMOV\tBYTE PTR [BX],AL\t;SAVE ZERO\r\n\tINC\tBX\t\t;BUMP POINTER\r\n\tMOV\tVARTAB,BX\t;NEW START OF VARIABLES\r\nRUNC:\r\n\tMOV\tBX,TXTTAB\t;POINT AT THE START OF TEXT\r\n\tDEC\tBX\r\n;\r\n; CLEARC IS A SUBROUTINE WHICH INITIALIZES THE VARIABLE AND\r\n; ARRAY SPACE BY RESETING ARYTAB [THE END OF SIMPLE VARIABLE SPACE]\r\n; AND STREND [THE END OF ARRAY STORAGE]. IT FALLS INTO STKINI\r\n; WHICH RESETS THE STACK. [H,L] IS PRESERVED.\r\n;\r\nCLEARC:\r\n\tMOV\tTEMP,BX\t\t;SAVE [H,L] IN TEMP\r\n\tCALL\tINITRP\t\t;INIT TRAP TABLE\r\n\tEXTRN\tGRPRST:NEAR\r\n\tCALL\tGRPRST\t\t;Reset graphics\r\n\tCALL\tINITRP\t\t;Initialize trapping\r\n\tEXTRN\tSNDINI:NEAR\r\n\tCALL\tSNDINI\t\t;Initialize SOUND & PLAY\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tMRGFLG:WORD\r\nDSEG\tENDS\r\n\tMOV\tAL,BYTE PTR MRGFLG\t;DOING A CHAIN MERGE?\r\n\tOR\tAL,AL\t\t;TEST\r\n\tJNZ\tSHORT LEVDTB\t;LEAVE DEFAULT TABLE ALONE\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR OPTFLG,AL\t;INDICATE NO \"OPTION\" HAS BEEN SEEN\r\n\tMOV\tBYTE PTR OPTVAL,AL\t;DEFAULT TO \"OPTION BASE 0\"\r\n\tMOV\tCH,LOW 26\t;INITIALIZE THE DEFAULT VALTYPE TABLE\r\n\tMOV\tBX,OFFSET DEFTBL\t;POINT AT THE FIRST ENTRY\r\nLOPDFT:\r\n\tMOV\tBYTE PTR [BX],LOW 4\t;LOOP 26 TIMES STORING A DEFAULT VALTYP\r\n\tINC\tBX\t\t;FOR SINGLE PRECISION\r\n\t\t\t\t;COUNT OFF THE LETTERS\r\n\tDEC\tCH\r\n\tJNZ\tSHORT LOPDFT\t;LOOP BACK, AND SETUP THE REST OF THE TABLE\r\nLEVDTB:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tRNDCOP:WORD,RNDX:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tMOVE:NEAR\r\n\tMOV\tDX,OFFSET RNDCOP\t;RESET THE RANDOM NUMBER GENERATOR\r\n\tMOV\tBX,OFFSET RNDX\t;SEED IN RNDX\r\n\tCALL\tMOVE\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR ONEFLG,AL\t;RESET ON ERROR FLAG FOR RUNS\r\n\tMOV\tBL,AL\t\t;RESET ERROR LINE NUMBER\r\n\tMOV\tBH,AL\t\t;BY SETTING ONELIN=0.\r\n\tMOV\tONELIN,BX\r\n\tMOV\tOLDTXT,BX\t;MAKE CONTINUING IMPOSSIBLE\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tERRLIN:WORD\r\nDSEG\tENDS\r\n\tMOV\tERRLIN,BX\t;Clear error line number\r\n\tMOV\tBX,MEMSIZ\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCHNFLG:WORD\r\nDSEG\tENDS\r\n\tMOV\tAL,BYTE PTR CHNFLG\t;ARE WE CHAINING?\r\n\tOR\tAL,AL\t\t;TEST\r\n\tJNZ\tSHORT GODFRE\t;FRETOP IS GOOD, LEAVE IT ALONE\r\n\tMOV\tFRETOP,BX\t;FREE UP STRING SPACE\r\nGODFRE:\tXOR\tAL,AL\t\t;MAKE SURE [A] IS ZERO, CC'S SET\r\n\tCALL\tRESTORE\t\t;RESTORE DATA\r\n\tMOV\tBX,VARTAB\t;GET START OF VARIABLE SPACE\r\n\tMOV\tARYTAB,BX\t;SAVE IN START OF ARRAY SPACE\r\n\tMOV\tSTREND,BX\t;AND END OF VARIABLE STORAGE\r\n\tEXTRN\tCLSALL:NEAR\r\n\tMOV\tAL,BYTE PTR MRGFLG\t;DOING CHAIN MERGE?\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT ??L000\r\n\tCALL\tCLSALL\t\t;IF SO, DONT CLOSE FILES...\r\n??L000:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tNLONLY:WORD\r\nDSEG\tENDS\r\n\tMOV\tAL,BYTE PTR NLONLY\t;GET LOAD FLAGS\r\n\tAND\tAL,LOW 1\t;CURRENTLY LOADING?\r\n\tJNZ\tSHORT CLRDS1\t;YES, LEAVE OTHERS OPEN\r\n\tMOV\tBYTE PTR NLONLY,AL\t;ENABLE CLOSE ALL\r\nCLRDS1:\r\n;\r\n; STKINI RESETS THE STACK POINTER ELIMINATING\r\n; GOSUB & FOR CONTEXT.  STRING TEMPORARIES ARE FREED\r\n; UP, SUBFLG IS RESET, CONTINUING IS DISALLOWED,\r\n; AND A DUMMY ENTRY IS PUT ON THE STACK. THIS IS SO\r\n; FNDFOR WILL ALWAYS FIND A NON-\"FOR\" ENTRY AT THE BOTTOM\r\n; OF THE STACK. [A]=0 AND [D,E] IS PRESERVED.\r\n;\r\nSTKINI:\tPOP\tCX\t\t;GET RETURN ADDRESS HERE\r\n\tMOV\tBX,TOPMEM\r\n\tDEC\tBX\t\t;TAKE INTO ACCOUNT FNDFOR STOPPER\r\n\tDEC\tBX\r\n\tMOV\tSAVSTK,BX\t;MAKE SURE SAVSTK OK JUST IN CASE.\r\n\tINC\tBX\t\t;INCREMENT BACK FOR SPHL\r\n\tINC\tBX\r\nSTKERR:\r\n\tMOV\tSP,BX\t\t;INITIALIZE STACK\r\n\tMOV\tBX,OFFSET TEMPST\r\n\tMOV\tTEMPPT,BX\t;INITIALIZE STRING TEMPORARIES\r\n\tEXTRN\tCLROVC:NEAR\r\n\tCALL\tCLROVC\t\t;BACK TO NORMAL OVERFLOW PRINT MODE\r\n\tEXTRN\tFINPRT:NEAR\r\n\tCALL\tFINPRT\t\t;CLEAR PTRFIL, OTHER I/O FLAGS\r\n\tXOR\tAL,AL\t\t;ZERO OUT A\r\n\tMOV\tBH,AL\t\t;ZERO OUT H\r\n\tMOV\tBL,AL\t\t;ZERO OUT L\r\n\tMOV\tPRMLEN,BX\t;FLAG NO ACTIVE PARAMETERS\r\n\tMOV\tBYTE PTR NOFUNS,AL\t;INDICATE NO USER FUNCTIONS ACTIVE\r\n\tMOV\tPRMLN2,BX\t;NO PARAMETERS BEING BUILT\r\n\tMOV\tFUNACT,BX\t;SET NUMBER OF FUNCTIONS ACTIVE TO 0\r\n\tMOV\tPRMSTK,BX\t;AND NO PARAMETER BLOCKS ON THE STACK\r\n\tMOV\tBYTE PTR SUBFLG,AL\t;ALLOW SUBSCRIPTS\r\n\tPUSH\tBX\t\t;PUT ZERO (NON $FOR,$GOSUB)\r\n\t\t\t\t;ON THE STACK\r\n\tPUSH\tCX\t\t;PUT RETURN ADDRESS BACK ON\r\nGTMPRT:\tMOV\tBX,TEMP\t\t;GET SAVED [H,L]\r\n\tRET\t\r\n\r\n;PAGE\r\n\r\n\tSUBTTL DCOMPR, SYNCHR - REPLACEMENTS FOR COMPAR & SYNCHK IN RSTLES VERSION\r\n\tPUBLIC\tDCOMPR\r\nDCOMPR:\r\n\tCMP\tBX,DX\r\n\tRET\t\r\n\r\n\tPUBLIC\tSYNCHR\r\nSYNCHR:\r\n\tINS86\t136\t\t;POP SI\r\n\tINS86\t213,373\t\t;MOV DI,BX\r\n\tINS86\t374\t\t;CLD\r\n\tINS86\t56\t\t;BYTE COMPARED TO IS IN CODE SEGMENT\r\n\tINS86\t246\t\t;CMPC-IS CHAR THE RIGHT ONE?\r\n\tINS86\t126\t\t;PUSH SI\r\n\tINS86\t213,337\t\t;MOV BX,DI\r\n\tJNZ\tSHORT SYNERR\t;GIVE ERROR IF CHARS DONT MATCH\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET IT\r\n\tCMP\tAL,LOW \":\"\t;IS IT END OF STATMENT OR BIGGER\r\n\tJB\tSHORT SYNCON\t;GO TO CHRCON\r\n\tRET\t\t\t;DONE\r\nSYNCON:\tJMP\tCHRCON\t\t;REST OF CHRGET\r\nSYNERR:\tJMP\tSNERR\t\t;IFE CYB\r\n\r\n\tSUBTTL TRAP ROUTINES - ON, OFF, STOP, INIT, REQUEST, FREE, RESET\r\n;\r\n;Trap flag bit definitions(Routines shift bits - don't change)\r\n;\r\nPUBLIC\tT_ON\r\n\tT_ON=1\t\t\t;Trap on\r\nPUBLIC\tT_STOP\r\n\tT_STOP=2\t\t;Trap stop\r\nPUBLIC\tT_REQ\r\n\tT_REQ=4\t\t\t;Trap request\r\n\r\n;TURN TRAP ON\r\n;\r\nPUBLIC\tONTRP\r\nONTRP:\tCLI\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tAND\tAL,LOW OFFSET T_REQ\t;LEAVE REQUEST BIT\r\n\tOR\tAL,LOW OFFSET T_ON\t;ADD ON BIT\r\n\tCMP\tAL,BYTE PTR [BX]\r\n\tMOV\tBYTE PTR [BX],AL\r\n\tJZ\tSHORT ONTRP0\t;NO CHANGE IN STATUS\r\n\tAND\tAL,LOW OFFSET T_REQ\r\n\tJNZ\tSHORT SETTP2\t;DELAYED TRAP REQUEST\r\nONTRP0:\tSTI\r\n\tRET\t\r\n\r\n;TURN TRAP OFF\r\n;\r\nPUBLIC\tOFFTRP\r\nOFFTRP:\tCLI\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tMOV\tBYTE PTR [BX],LOW 0\r\n\tJMP\tSHORT FRECHK\t;FREE OUTSTANDING REQUEST\r\n\r\n;STOP TRAP\r\n;\r\nPUBLIC\tSTPTRP\r\nSTPTRP:\tCLI\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\r\n\tOR\tAL,LOW OFFSET T_STOP\r\n\tMOV\tBYTE PTR [BX],AL\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\r\nFRECHK:\tXOR\tAL,LOW OFFSET T_ON+T_REQ\t;STOP OR OFF ACTIVE REQUEST?\r\n\tJZ\tSHORT FRETP2\t;YES, FREE ACTIVE REQUEST COUNT\r\n\tSTI\r\n\tRET\t\r\n\r\n;RESET STOP ON TRAP\r\n;\r\nPUBLIC\tRSTTRP\r\nRSTTRP:\tCLI\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tAND\tAL,LOW OFFSET T_ON+T_REQ\r\n\tCMP\tAL,BYTE PTR [BX]\r\n\tMOV\tBYTE PTR [BX],AL\r\n\tJNZ\tSHORT SETCHK\t;IF NEW STATUS, CHECK FOR SETTRP\r\n\tSTI\r\n\tRET\t\r\n;\r\n;REQUEST TRAP\r\n;\r\nPUBLIC\tREQTRP\r\nREQTRP:\tCLI\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tAND\tAL,LOW OFFSET T_ON\r\n\tJZ\tSHORT REQTPX\t;TRAP NOT ON\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tOR\tAL,LOW OFFSET T_REQ\r\n\tCMP\tAL,BYTE PTR [BX]\r\n\tJZ\tSHORT REQTPX\t;NO CHANGE\r\n\tMOV\tBYTE PTR [BX],AL\r\nSETCHK:\tXOR\tAL,LOW OFFSET T_ON+T_REQ\r\n\tJZ\tSHORT SETTP2\t;GO SET TRAP GLOBAL FLAG\r\nREQTPX:\tSTI\r\n\tRET\t\r\n\r\n;SET TRAP GLOBAL FLAG\r\n;\r\nPUBLIC\tSETTRP\r\nSETTRP:\tCLI\r\nSETTP2:\tMOV\tAL,BYTE PTR ONGSBF\r\n\tINC\tAL\r\n\tMOV\tBYTE PTR ONGSBF,AL\r\n\tSTI\r\n\tRET\t\r\n\r\n;FREE TRAP\r\n;\r\nPUBLIC\tFRETRP\r\nFRETRP:\tCLI\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tAND\tAL,LOW OFFSET T_ON+T_STOP\r\n\tCMP\tAL,BYTE PTR [BX]\r\n\tMOV\tBYTE PTR [BX],AL\r\n\tJNZ\tSHORT FRETP2\t;DECR GLOBAL FLAG ALSO\r\nFRETP1:\tSTI\r\n\tRET\t\r\nFRETP2:\tMOV\tAL,BYTE PTR ONGSBF\r\n\tSUB\tAL,LOW 1\r\n\tJB\tSHORT FRETP1\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tONGSBF:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR ONGSBF,AL\r\n\tSTI\r\n\tRET\t\r\n\r\n;INITIALIZE TRAP TABLE\r\n;\r\nPUBLIC\tINITRP\r\nINITRP:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tTRPTBL:WORD\r\nDSEG\tENDS\r\n\tMOV\tBX,OFFSET TRPTBL\t;HL=TRAP TABLE ADDRESS\r\n\tMOV\tCH,LOW OFFSET NUMTRP\t;B=NUMBER OF TRAPS\r\n\tXOR\tAL,AL\r\nINITP0:\tMOV\tBYTE PTR [BX],AL\t;TRAP OFF\r\n\tINC\tBX\r\n\tMOV\tBYTE PTR [BX],AL\r\n\tINC\tBX\r\n\tMOV\tBYTE PTR [BX],AL\t;CLEAR GOSUB ADDR TOO!\r\n\tINC\tBX\r\n\tDEC\tCH\r\n\tJNZ\tSHORT INITP0\r\n\tMOV\tBYTE PTR ONGSBF,AL\r\n\tRET\t\r\n\r\n;GO TO TRAP IF ANY ENABLED AND REQUESTED\r\n;\r\nPUBLIC\tGOTRP\r\nGOTRP:\r\n\tMOV\tAL,BYTE PTR ONEFLG\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;CAN'T TRAP FROM ERROR TRAP\r\n\tPUSH\tBX\t\t;SAVE TES\bXT POINTER\r\n\tMOV\tBX,CURLIN\r\n\tMOV\tAL,BH\r\n\tAND\tAL,BL\r\n\tINC\tAL\r\n\tJZ\tSHORT GOTRPX\t;CAN'T TRAP FROM DIRECT STATEMENT\r\n\r\n;CHECK FOR ENABLED REQUESTS\r\n\tMOV\tBX,OFFSET TRPTBL\r\n\tMOV\tCH,LOW OFFSET NUMTRP\t;HL=TRAP TABLE ADDRESS, B= # OF TRAPS\r\nGOTRPL:\tMOV\tAL,BYTE PTR [BX]\r\n\tCMP\tAL,LOW OFFSET T_ON+T_REQ\r\n\tJZ\tSHORT GOTRP2\t;ENABLED AND REQUESTED\r\nGOTRP1:\tLAHF\r\n\tINC\tBX\t\t;NEXT ENTRY\r\n\tSAHF\r\n\tLAHF\r\n\tINC\tBX\t\t;\r\n\tSAHF\r\n\tLAHF\r\n\tINC\tBX\t\t;\r\n\tSAHF\r\n\tDEC\tCH\r\n\tJNZ\tSHORT GOTRPL\r\nGOTRPX:\tPOP\tBX\t\t;RESTORE TEXT POINTER\r\n\tRET\t\r\n;\r\n;TRAP REQUEST FOUND\r\n;\r\nGOTRP2:\r\n\tPUSH\tCX\t\t;SAVE STATE IN CASE ADDR IS ZERO\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tDL,BYTE PTR [BX]\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tDH,BYTE PTR [BX]\t;DE=TRAP GOSUB ADDR\r\n\tLAHF\r\n\tDEC\tBX\r\n\tSAHF\r\n\tLAHF\r\n\tDEC\tBX\t\t;HL:=TRAP FLAG\r\n\tSAHF\r\n\tMOV\tAL,DH\r\n\tOR\tAL,DL\r\n\tPOP\tCX\t\t;RESTORE COUNTER\r\n\tJZ\tSHORT GOTRP1\t;GOSUB ADDR NOT SPECIFIED,TRY NEXT R\bTRAP\r\n\tPUSH\tDX\t\t;PUT GOSUB ADDR ON STACK\r\n\tPUSH\tBX\t\t;PUT FLAG ADDR ON STACK\r\n\tCALL\tFRETRP\t\t;FREE TRAP REQUEST\r\n\tCALL\tSTPTRP\t\t;PUT STOP ON TRAP\r\n\tMOV\tCL,LOW 3\r\n\tCALL\tGETSTK\t\t;MAKE SURE ROOM IN STACK\r\n\tPOP\tCX\t\t;BC=TRAP FLAG ADDRESS\r\n\tPOP\tDX\t\t;DE=GOU\bSUB ROUTINE ADDR\r\n\tPOP\tBX\t\t;REMOVE RETURN AND HL=TEXT POINTER\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\r\n\tPOP\tBX\r\nEXTRN\tGOSUB2:NEAR\r\n\tJMP\tGOSUB2\t\t;GOSUB TO ADDR IN DE, FLAG ADDR IN BC\r\n\t\t\t\t; AND TEXT PTR IN HL\r\n\r\n\tSUBTTL RESTORE, STOP, END\r\nRESTORE:\tXCHG\tBX,DX\t;SAVE [H,L] IN [D,E]\r\n\tMOV\tBX,TXTTAB\r\n\tJZ\tSHORT BGNRST\t;RESTORE DATA POINTER TO BEGINNING OF PROGRAM\r\n\tXCHG\tBX,DX\t\t;TEXT POINTER BACK TO [H,L]\r\n\tCALL\tLINGET\t\t;GET THE FOLLOWING LINE NUMBER\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\tFNDLIN\t\t;FIND THE LINE NUMBER\r\n\tMOV\tBX,CX\t\t;GET POINTER TO LINE IN [H,L]\r\n\tPOP\tDX\t\t;TEXT POINTER BACK TO [D,E]\r\n\tJNAE\tSHORT ??L001\r\n\tJMP\tUSERR\t\t;SHOULD HAVE FOUND LINE\r\n??L001:\r\nBGNRST:\r\n\tDEC\tBX\t\t;INITIALIZE DATPTR TO [TXTTAB]-1\r\nRESFIN:\tMOV\tDATPTR,BX\t;READ FINISHES COME TO RESFIN\r\n\tXCHG\tBX,DX\t\t;GET THE TEXT POINTER BACK\r\n\tRET\t\r\n\r\n\r\nSTOP:\tJZ\tSHORT $+3\r\n\tRET\t\t\t;RETURN IF NOT CONTROL-C AND MAKE\r\n\t\t\t\t;SURE \"STOP\" STATEMENTS HAVE A TERMINATOR\r\nSTOPRG:\r\n\tHLPEDT=PC8A\r\n\tINC\tAL\r\n\tJMP\tSHORT CONSTP\r\nENDST:\tJZ\tSHORT $+3\r\n\tRET\t\t\t;MAKE SURE \"END\" STATEMENTS HAVE A TERMINATOR\r\n\tXOR\tAL,AL\t\t;clear ONEFLG to indicate that we aren't\r\n\tMOV\tBYTE PTR ONEFLG,AL\t;within an error-trapping routine\r\nENDS1:\r\n\tPUSHF\t\t\t;PRESERVE CONDITION CODES OVER CALL TO CLSALL\r\n\tJNZ\tSHORT ??L002\r\n\tCALL\tCLSALL\r\n??L002:\r\n\tPOPF\t\t\t;RESTORE CONDITION CODES\r\nCONSTP:\r\n\tMOV\tSAVTXT,BX\t;SAVE FOR \"CONTINUE\"\r\n\tMOV\tBX,OFFSET TEMPST\t;RESET STRING TEMP POINTER\r\n\tMOV\tTEMPPT,BX\t;SAVE IN CASE ^C PRINT USING\r\n\tDB\t273O\t; SKIP\t;\"LXI H,\" OVER NEXT TWO\r\nSTPEND:\tOR\tAL,LOW 377O\t;SET NON-ZERO TO FORCE PRINTING OF BREAK MESSAGE\r\n\tPOP\tCX\t\t;POP OFF NEWSTT ADDRESS\r\nENDCON:\tMOV\tBX,CURLIN\t;SAVE CURLIN\r\n\tPUSH\tBX\t\t;SAVE LINE TO PRINT\r\n\tPUSHF\t\t\t;SAVE THE MESSAGE FLAG\r\n\t\t\t\t;ZERO MEANS DON'T PRINT \"BREAK\"\r\n\tMOV\tAL,BL\r\n\tAND\tAL,BH\t\t;SEE IF IT WAS DIRECT\r\n\tINC\tAL\r\n\tJZ\tSHORT DIRIS\t;IF NOT SET UP FOR CONTINUE\r\n\tMOV\tOLDLIN,BX\t;SAVE OLD LINE #\r\n\tMOV\tBX,SAVTXT\t;GET POINTER TO START OF STATEMENT\r\n\tMOV\tOLDTXT,BX\t;SAVE IT\r\nDIRIS:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCNTOFL:WORD\r\nDSEG\tENDS\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR CNTOFL,AL\t;FORCE OUTPUT\r\n\tEXTRN\tFINLPT:NEAR\r\n\tCALL\tFINLPT\r\n\tCALL\tCRDONZ\t\t;PRINT CR IF TTYPOS .NE. 0\r\n\tPOPF\t\t\t;GET BACK ^C FLAG\r\n\tMOV\tBX,OFFSET BRKTXT\t;\"BREAK\"\r\n\tJZ\tSHORT ??L003\r\n\tJMP\tERRFIN\t\t;CALL STROUT AND FALL INTO READY\r\n??L003:\r\n\tJMP\tSTPRDY\t\t;POP OFF LINE NUMBER & FALL INTO READY\r\n;PAGE\r\n\r\n\tSUBTTL CTRLPT, DDT, CONT, NULL, TRON, TROFF\r\n\r\nPUBLIC\tCTROPT\r\nCTROPT:\tMOV\tAL,LOW OFFSET CONTO\t;PRINT AN ^O.\r\nPUBLIC\tCTRLPT\r\nCTRLPT:\tPUSH\tAX\t\t;SAVE CURRENT CHAR\r\n\tSUB\tAL,LOW 3\t;CONTROL-C?\r\n\tJNZ\tSHORT NTCTCT\t;NO\r\n\tMOV\tBYTE PTR CNTOFL,AL\t;RESET ^O FLAG\r\nNTCTCT:\r\n\tMOV\tAL,LOW \"^\"\t;PRINT UP-ARROW.\r\n\tCALL\tOUTDO\t\t;SEND IT\r\n\tPOP\tAX\t\t;GET BACK CONTROL CHAR.\r\n\tADD\tAL,LOW 100O\t;MAKE PRINTABLE\r\n\tCALL\tOUTDO\t\t;SEND IT\r\n\tMOV\tAL,LOW 377O\t;MARK LINE AS NOT FOR INPUT\r\n\tCALL\tOUTDO\r\n\tJMP\tCRDO\t\t;AND THEN SEND CRLF.\r\n\r\n\r\n\r\nCONT:\tMOV\tBX,OLDTXT\t;A STORED TEXT POINTER OF\r\n\t\t\t\t;ZERO IS SETUP BY STKINI\r\n\t\t\t\t;AND INDICATES THERE IS NOTHING\r\n\t\t\t\t;TO CONTINUE\r\n\tOR\tBX,BX\t\t;\"STOP\",\"END\",TYPING CRLF\r\n\t\t\t\t;TO \"INPUT\" AND ^C SETUP OLDTXT\r\nRESERR:\tMOV\tDX,OFFSET ERRCN\t;\"CAN'T CONTINUE\"\r\n\tJNZ\tSHORT ??L004\r\n\tJMP\tERROR\r\n??L004:\r\n\tMOV\tDX,OLDLIN\r\n\tMOV\tCURLIN,DX\t;SET UP OLD LINE # AS CURRENT LINE #\r\n\tRET\t\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tNULCNT:WORD\r\nDSEG\tENDS\r\n\tPUBLIC\tNULL\r\nNULL:\tCALL\tGETBYT\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;MAKE SURE THERE IS A TERMINATOR\r\n\tINC\tAL\t\t;CODE AT CRDO EXPECTS AT LEAST 1\r\n\tMOV\tBYTE PTR NULCNT,AL\t;CHANGE NUMBER OF NULLS\r\n\tRET\t\r\n\r\nTON:\tDB\t270O\t; SKIP\t;\"MVI A,\" NON-ZERO QUANTITY\r\nTOFF:\tXOR\tAL,AL\t\t;MAKE [A]=0 FOR NO TRACE\r\n\tMOV\tBYTE PTR TRCFLG,AL\t;UPDATE THE TRACE FLAG\r\n\tRET\t\r\n;PAGE\r\n\r\n\tSUBTTL SWAP, ERASE\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSWPTMP:WORD\r\nDSEG\tENDS\r\n\tPUBLIC\tSWAP\r\nSWAP:\tCALL\tPTRGET\t\t;[D,E]=POINTER AT VALUE #1\r\n\tPUSH\tDX\t\t;SAVE THE POINTER AT VALUE #1\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tMOV\tBX,OFFSET SWPTMP\t;TEMPORARY STORE LOCATION\r\n\tCALL\tVMOVE\t\t;SWPTMP=VALUE #1\r\n\tMOV\tBX,ARYTAB\t;GET ARYTAB SO CHANGE CAN BE NOTED\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;GET THE TEXT POINTER BACK\r\n\t\t\t\t;AND SAVE CURRENT [ARYTAB]\r\n\tCALL\tGETYPR\r\n\tPUSH\tAX\t\t;SAVE THE TYPE OF VALUE #1\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;MAKE SURE THE VARIABLES ARE\r\n\t\t\t\t;DELIMITED BY A COMMA\r\n\tCALL\tPTRGET\t\t;[D,E]=POINTER AT VALUE #2\r\n\tPOP\tAX\r\n\tMOV\tCH,AL\t\t;[B]=TYPE OF VALUE #1\r\n\tCALL\tGETYPR\t\t;[A]=TYPE OF VALUE #2\r\n\tCMP\tAL,CH\t\t;MAKE SURE THEY ARE THE SAME\r\n\tJZ\tSHORT ??L005\r\n\tJMP\tTMERR\t\t;IF NOT, \"TYPE MISMATCH\" ERROR\r\n??L005:\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;[H,L]=OLD [ARYTAB] SAVE THE TEXT POINTER\r\n\tXCHG\tBX,DX\t\t;[D,E]=OLD [ARYTAB]\r\n\tPUSH\tBX\t\t;SAVE THE POINTER AT VALUE #2\r\n\tMOV\tBX,ARYTAB\t;GET NEW [ARYTAB]\r\n\tCMP\tBX,DX\r\n\tJNZ\tSHORT GFCERR\t;IF ITS CHANGED, ERROR\r\n\tPOP\tDX\t\t;[D,E]=POINTER AT VALUE #2\r\n\tPOP\tBX\t\t;[H,L]=TEXT POINTER\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE THE TEXT POINTER ON THE STACK\r\n\t\t\t\t;[H,L]=POINTER AT VALUE #1\r\n\tPUSH\tDX\t\t;SAVE THE POINTER AT VALUE #2\r\n\tCALL\tVMOVE\t\t;TRANSFER VALUE #2 INTO VALUE #1'S OLD\r\n\t\t\t\t;POSITION\r\n\tPOP\tBX\t\t;[H,L]=POINTER AT VALUE #2\r\n\tMOV\tDX,OFFSET SWPTMP\t;LOCATION OF VALUE #1\r\n\tCALL\tVMOVE\t\t;TRANSFER SWPTMP=VALUE #1 INTO VALUE #2'S\r\n\t\t\t\t;OLD POSITION\r\n\tPOP\tBX\t\t;GET THE TEXT POINTER BACK\r\n\tRET\t\r\n\r\nGFCERR:\tJMP\tFCERR\t\t;GIVE A FUNCTION CALL ERROR\r\n\r\n\tPUBLIC\tERASE\r\nERASE:\r\n\tMOV\tAL,LOW 1\r\n\tMOV\tBYTE PTR SUBFLG,AL\t;THAT THIS IS \"ERASE\" CALLING PTRGET\r\n\tCALL\tPTRGET\t\t;GO FIND OUT WHERE TO ERASE\r\n\tJNZ\tSHORT GFCERR\t;PTRGET DID NOT FIND VARIABLE!\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tMOV\tBYTE PTR SUBFLG,AL\t;ZERO OUT SUBFLG TO RESET \"ERASE\" FLAG\r\n\tMOV\tBH,CH\t\t;[B,C]=START OF ARRAY TO ERASE\r\n\tMOV\tBL,CL\r\n\tDEC\tCX\t\t;BACK UP TO THE FRONT\r\n\tDEC\tCX\t\t;NO VALUE TYPE WITHOUT LENGTH=2\r\n\tDEC\tCX\t\t;BACK UP ONE MORE\r\nLPBKNM:\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\t\t;GET A CHARACTER. ONLY THE COUNT HAS HIGH BIT=0\r\n\tDEC\tCX\t\t;SO LOOP UNTIL WE SKIP OVER THE COUNT\r\n\tOR\tAL,AL\t\t;SKIP ALL THE EXTRA CHARACTERS\r\n\tJNS\tSHORT ??L006\r\n\tJMP\tLPBKNM\r\n??L006:\r\n\tDEC\tCX\r\n\tDEC\tCX\r\n\tADD\tBX,DX\t\t;[H,L]=THE END OF THIS ARRAY ENTRY\r\n\tXCHG\tBX,DX\t\t;[D,E]=END OF THIS ARRAY\r\n\tMOV\tBX,STREND\t;[H,L]=LAST LOCATION TO MOVE UP\r\nERSLOP:\tCMP\tBX,DX\t\t;SEE IF THE LAST LOCATION IS GOING TO BE MOVED\r\n\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;DO THE MOVE\r\n\tMOV\tDI,CX\r\n\tSTOSB\r\n\tLAHF\r\n\tINC\tDX\t\t;UPDATE THE POINTERS\r\n\tSAHF\r\n\tLAHF\r\n\tINC\tCX\r\n\tSAHF\r\n\tJNZ\tSHORT ERSLOP\t;MOVE THE REST\r\n\tDEC\tCX\r\n\tMOV\tBX,CX\t\t;SETUP THE NEW STORAGE END POINTER\r\n\tMOV\tSTREND,BX\r\n\tPOP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;SEE IF MORE ERASURES NEEDED\r\n\tCMP\tAL,LOW 54O\t;ADDITIONAL VARIABLES DELIMITED BY COMMA\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;ALL DONE IF NOT\r\n\tCALL\tCHRGTR\r\n\tJMP\tSHORT ERASE\r\n\r\n\r\nCASDON:\r\n\tPUBLIC\tPOPAHT\r\nPOPAHT:\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\r\n\tPOP\tBX\t\t;GET THE TEXT POINTER\r\n\tRET\t\r\n\tPAGE\t\r\n;\r\n;TEST FOR A LETTER / CARRY ON=NOT A LETTER\r\n;                    CARRY OFF=A LETTER\r\n;\r\nISLET:\tMOV\tAL,BYTE PTR [BX]\r\nISLET2:\tCMP\tAL,LOW \"A\"\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;IF LESS THAN \"A\", RETURN EARLY\r\n\tCMP\tAL,LOW OFFSET \"Z\"+1\r\n\tCMC\t\r\n\tRET\t\r\n\r\n;PAGE\r\n\r\n\tSUBTTL CLEAR\r\n\tPUBLIC\tCLEAR\r\n\r\nGCLERC:\tJMP\tCLEARC\t\t;IFE LABEL  GO TO CLEARC\r\n\r\n;Syntax: CLEAR [[a][,b [,c]]]\r\n;\r\n; a is a relic of pre-fiveo memory management and is ignored\r\n; b is the highest memory location available to BASIC-80\r\n; b is the the number of bytes in the data segment for BASIC-86\r\n; c is the number of bytes to be used as stack space by BASIC\r\n;\r\nCLEAR:\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\r\n\tXOR\tAL,AL\t\t;Since FILTAB is reset below,\r\n\tMOV\tBYTE PTR NLONLY,AL\t; close all files - even file 0,\r\n\tCALL\tCLSALL\t\t; because of DYNAMIC FDB's\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\r\n\tJZ\tSHORT GCLERC\t;IF NO FORMULA JUST CLEAR\r\n\tCMP\tAL,LOW 54O\t;ALLOW NO STRING SPACE\r\n\tJZ\tSHORT CSKPCM\r\n\tCALL\tINTID2\t\t;Get Dummy Integer Parameter into [D,E]\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\t\t;SEE IF ITS THE END\r\n\tJZ\tSHORT GCLERC\r\nCSKPCM:\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\r\n\tJZ\tSHORT GCLERC\r\n\tMOV\tDX,TOPMEM\t;Use current top of memory as default\r\n\tCMP\tAL,LOW 54O\r\n\tJZ\tSHORT CLEARS\t;SHOULD FINISH THERE\r\n\tCALL\tGETMPM\t\t;GET MEMORY SIZE PARAMETER\r\n\tPUSH\tBX\t\t;save text pointer\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tMAXMEM:WORD\r\nDSEG\tENDS\r\n\tMOV\tBX,MAXMEM\t;[HL]=highest byte available to BASIC\r\n\tCMP\tBX,DX\r\n\tJAE\tSHORT ??L007\r\n\tJMP\tFCERR\t\t;branch if user tried to get more\r\n??L007:\r\n\tPOP\tBX\t\t;restore text pointer\r\nCLEARS:\tDEC\tBX\t\t;BACK UP\r\n\tCALL\tCHRGTR\t\t;GET CHAR\r\n\tPUSH\tDX\t\t;SAVE NEW HIGH MEM\r\n\tJZ\tSHORT CDFSTK\t;USE SAME STACK SIZE\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\r\n\tJZ\tSHORT CDFSTK\r\n\tCALL\tGETMPM\t\t;GET STACK SIZE PARAMETER\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\r\n\tJZ\tSHORT ??L008\r\n\tJMP\tSNERR\r\n??L008:\r\nCLEART:\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE TEXT POINTER\r\n\tPUSH\tBX\t\t;SAVE CANDIDATE FOR TOPMEM\r\n\tMOV\tBX,OFFSET (2*NUMLEV)+20\t;CHECK STACK SIZE IS REASONABLE\r\n\tCMP\tBX,DX\r\n\tJAE\tSHORT GOMERR\r\n\tPOP\tBX\t\t;[HL]=candidate for TOPMEM\r\n\tCALL\tSUBDE\t\t;DE=HL-DE=High Ram - Stack Size=new stack bottom\r\n\tJB\tSHORT GOMERR\t;WANTED MORE THAN TOTAL!\r\n\tPUSH\tBX\t\t;SAVE STACK BOTTOM\r\n\tMOV\tBX,VARTAB\t;TOP LOCATION IN USE\r\n\tMOV\tCX,20\t\t;LEAVE BREATHING ROOM\r\n\tADD\tBX,CX\r\n\tCMP\tBX,DX\t\t;ROOM?\r\n\tJAE\tSHORT GOMERR\t;NO, DON'T EVEN CLEAR\r\n\tXCHG\tBX,DX\t\t;NEW STACK BASE IN [H,L]\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFILTAB:WORD,STKLOW:WORD\r\nDSEG\tENDS\r\n\tMOV\tSTKLOW,BX\t;set bottom of stack limit\r\n\tMOV\tFILTAB,BX\t;set FDB chain base (No files are open)\r\n\tDEC\tBX\r\n\tMOV\tBYTE PTR [BX],LOW 0\t;set string terminator so VAL$ will always work\r\n\tDEC\tBX\r\n\tMOV\tMEMSIZ,BX\t;SET UP NEW STACK BOTTOM\r\n\tPOP\tBX\t\t;HL=Highest Ram available to BASIC\r\n\tMOV\tTOPMEM,BX\t;SAVE IT, IT MUST BE OK\r\n\tPOP\tBX\t\t;REGAIN THE TEXT POINTER\r\n\tJMP\tGCLERC\t\t;GO CLEAR\r\n\r\nGETMPM:\tCALL\tFRMQNT\t\t;EVALUATE FORMULA\r\n\tOR\tDX,DX\t\t;Memory size =0?\r\n\tJNZ\tSHORT ??L009\r\n\tJMP\tFCERR\t\t;Yes, error\r\n??L009:\r\n\tRET\t\r\n\r\nGOMERR:\tJMP\tOMERR\t\t;GIVE OM ERROR\r\n\r\n;CLEAR Default Stack Size to current stack size\r\n;\r\nCDFSTK:\r\n\tMOV\tDX,TOPMEM\t;FIGURE OUT CURRENT STACK SIZE\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSTKLOW:WORD\r\nDSEG\tENDS\r\n\tINS86\t53,26,STKLOW\t;SUB DX,STKLOW\r\n\tJMP\tSHORT CLEART\r\n\r\n\tPAGE\t\r\n; [D,E]=[H,L]-[D,E]\r\n\tPUBLIC\tSUBDE\r\nSUBDE:\r\n\tINS86\t213,303\t\t;MOV AX,BX\r\n\tINS86\t53,302\t\t;SUB AX,DX\r\n\tINS86\t213,320\t\t;MOV DX,AX\r\n\tRET\t\r\n;PAGE\r\n\r\n\r\n\tPAGE\t\r\n\r\n\tPUBLIC\tISFLIO\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tPTRFIL:WORD\r\nDSEG\tENDS\r\nISFLIO:\r\n\tPUSH\tBX\t\t;SAVE [H,L]\r\n\tMOV\tBX,PTRFIL\t;GET FILE POINTER\r\n\tOR\tBX,BX\t\t;NO ZERO?\r\n\tPOP\tBX\t\t;RESTORE [H,L]\r\n\tRET\t\r\n\r\n;EXTERNAL DECLARATIONS REQUIRED FOR LABELSTUFF\r\n; INTERNAL DECLARATIONS REQUIRED\r\n;\r\n;ALL THIS STUFF HAS BEEN ADDED FOR LABELS\r\n;IF LABELS ARE REQUIRED  LABEL SWITCH SHLOULD BE ON\r\n;;;\r\n;\r\n;\r\n;CHKLBL ROUTINE CHECKS WHETHER THE LABEL IS ALREADY PRESENT IN THE SYMBOL TABLE\r\n;HL=POINTER TO LABEL\r\n;B=LABEL LENGTH\r\n;DE IS SET TO THE WORD WHICH CONTAINS THE POINTER TO THE STMNT IN CASE THERE IS MATCH\r\n;Z IS SET INCASE MATCH\r\n;HL AND B ARE PRESERVED\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "BINTRP.H",
          "type": "blob",
          "size": 2.5146484375,
          "content": ";\n;               Include file for BINTRP.ASM\n;\n\nINCLUDE OEM.H                   ; General definitions\n\nMOVRI   MACRO   B,C,D,E\n        DB      271O            ; \"LXI  B\"\n        DB      C\n        DB      B\n        DB      272O            ; \"LXI  D\"\n        DB      E\n        DB      D\nENDM \n\n;\n; Reserve word table generating Macros\n;\nun_def  MACRO   RESWRD\n        %OUT +++ Undefined reserved word - &RESWRD\nENDM\n\nT       MACRO   RESWRD\n        QQ=QQ+1\n        $&RESWRD=QQ\nENDM\n\nQ       MACRO   RESWRD\n IFDEF  $&RESWRD\n        $F=0\n  IRPC  XX,<RESWRD>\n   IF   $F\n        $Q=\"&XX&\"\n        DB      \"&XX&\"\n   ENDIF        \n   IFE  $F-1\n        .XLIST\n   ENDIF\n        $F=$F+1\n  ENDM\n        .LIST\n        ORG     $-1\n        DB      $Q+128D\n        DB      $&RESWRD\n ELSE\n        un_def  RESWRD\n ENDIF\nENDM\n\nQF      MACRO   RESWRD\n IFDEF  $&RESWRD\n        $F=0\n  IRPC  XX,<RESWRD>\n   IF   $F\n        $Q=\"&XX&\"\n        DB      \"&XX&\"\n   ENDIF        \n   IFE  $F-1\n        .XLIST\n   ENDIF\n        $F=$F+1\n  ENDM\n        .LIST\n        ORG     $-1\n        DB      $Q+128D\n        DB      $&RESWRD-128D\n ELSE\n        un_def  RESWRD\n ENDIF\nENDM\n\nDERMAK  MACRO   X\n        PUBLIC  DER&X\nDER&X:  MOV     DL,OFFSET ERR&X\n        DB      271O                    ; LXI B over next error\nENDM\n;\n; Dispatch table generating Macros.  We have to play games with the\n; external declarations as ASM86 won't allow something to be declared\n; external during pass 2.  Instead we build a chain of dummy macros\n; that could generate the declaration for all potentially external \n; reserve word dispatch addresses.\n;\n\n;\n; play games with a possible external.  Create a new\n; macro for the symbol and text, and string it together\n; with a central invoker\n;\nIF1\n    ?i=0\nENDIF\n\n?z0 macro               ; Bottom of the chain\nendm\n\n;\n; add an external declaration to S with type NEAR if it is not defined\n;\nadd_ext macro   s\n    IFNDEF   ?&s\n        ?i = ?i + 1\n        def_mac     ?z&%?i,?z&%(?i-1),s\n    ENDIF\nendm\n\n;\n; define a macro called that possibly externals S:NEAR and then calls macro n\n;\ndef_mac macro   m,n,s\nm   macro\n    ifndef s\n        extrn s:NEAR\n    endif\n    purge m\n    n\nendm\n?&s macro\n&endm\nendm\n\n;\n; call the macro chain\n;\ndo_ext  macro\n    expand_mac  ?z%?i\nendm\n\nexpand_mac macro m\n    m\nendm\n;\nR       MACRO   RESWRD\n IFNDEF RESWRD\n        add_ext RESWRD\n ENDIF\n        DW      RESWRD\n        QQ=QQ+1\n        $&RESWRD=QQ\nENDM\n\nR2      MACRO   RESWRD,RESDSP\n IFNDEF RESDSP\n        add_ext RESDSP\n ENDIF\n        DW      RESDSP\n        QQ=QQ+1\n        $&RESWRD=QQ\nENDM\n;\nPAGE\n\u001a"
        },
        {
          "name": "BIPRTU.ASM",
          "type": "blob",
          "size": 15.75,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   BIPRTU  BASIC Interpreter PRINT USING Driver/WHG\r\n\r\n\t.RADIX\t10\r\n\r\nTRSHHC=0\r\nNECPPC=0\r\n\r\n\tSUBTTL  PRINT USING DRIVER\r\n;\r\n; COME HERE AFTER THE \"USING\" CLAUSE IN A PRINT STATEMENT\r\n; IS RECOGNIZED. THE IDEA IS TO SCAN THE USING STRING UNTIL\r\n; THE VALUE LIST IS EXHAUSTED, FINDING STRING AND NUMERIC\r\n; FIELDS TO PRINT VALUES OUT OF THE LIST IN,\r\n; AND JUST OUTPUTING ANY CHARACTERS THAT AREN'T PART OF\r\n; A PRINT FIELD.\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t; Data segment externs\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tFACLO:WORD\r\n\r\n\tEXTRN\tUSFLG:WORD\r\nDSEG\tENDS\r\n\r\n\t\t\t\t; Code segment ( terminated by END at bottom of file )\r\n\r\n\tEXTRN\tCHRGTR:NEAR,SYNCHR:NEAR\r\n\tEXTRN\tCHKSTR:NEAR,CRDO:NEAR,FCERR:NEAR,FRETM2:NEAR,FRMCHK:NEAR\r\n\tEXTRN\tFRMEVL:NEAR\r\n\tEXTRN\tOUTDO:NEAR,PUFOUT:NEAR,SNERR:NEAR,STROUT:NEAR,STRPRT:NEAR\r\n\tEXTRN\tLEFTUS:NEAR\r\n\tPUBLIC\tPRINUS\r\n\tCSTRNG=134O\r\n\tCURNCY=44O\t\t;USE DOLLAR SIGN AS DEFAULT\r\n\r\nPRINUS:\tCALL\tFRMCHK\t\t;EVALUATE THE \"USING\" STRING\r\n\tCALL\tCHKSTR\t\t;MAKE SURE IT IS A STRING\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 73O\t;MUST BE DELIMITED BY A SEMI-COLON\r\n\tXCHG\tBX,DX\t\t;[D,E]=TEXT POINTER\r\n\tMOV\tBX,FACLO\t;GET POINTER TO \"USING\" STRING DESCRIPTOR\r\n\tJMP\tSHORT INIUS\t;DONT POP OFF OR LOOK AT USFLG\r\nREUSST:\tMOV\tAL,BYTE PTR USFLG\t;DID WE PRINT OUT A VALUE LAST SCAN?\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJZ\tSHORT FCERR3\t;NO, GIVE ERROR\r\n\tPOP\tDX\t\t;[D,E]=POINTER TO \"USING\" STRING DESCRIPTOR\r\n\tXCHG\tBX,DX\t\t;[D,E]=TEXT POINTER\r\nINIUS:\tPUSH\tBX\t\t;SAVE THE POINTER TO \"USING\" STRING DESCRIPTOR\r\n\tXOR\tAL,AL\t\t;INITIALLY INDICATE THERE ARE MORE\r\n\t\t\t\t;VALUES IN THE VALUE LIST\r\n\tMOV\tBYTE PTR USFLG,AL\t;RESET THE FLAG THAT SAYS VALUES PRINTED\r\n\tINC\tAL\t\t;TURN THE ZERO FLAG OFF\r\n\t\t\t\t;TO INDICATE THE VALUE LIST HASN'T ENDED\r\n\tPUSHF\t\t\t;SAVE FLAG INDICATING WHETHER THE VALUE\r\n\t\t\t\t;LIST HAS ENDED\r\n\tPUSH\tDX\t\t;SAVE THE TEXT POINTER INTO THE VALUE LIST\r\n\tMOV\tCH,BYTE PTR [BX]\t;[B]=LENGTH OF THE \"USING\" STRING\r\n\tINC\tCH\t\t;Is the using string null?\r\n\tDEC\tCH\r\nFCERR3:\tJNZ\tSHORT ??L000\r\n\tJMP\tFCERR\t\t;IF SO, \"ILLEGAL FUNCTION CALL\"\r\n??L000:\r\n\tINC\tBX\t\t;[H,L]=POINTER AT THE \"USING\" STRING'S\r\n\tMOV\tBX,[BX]\t\t;DATA\r\n\tJMP\tSHORT PRCCHR\t;GO INTO THE LOOP TO SCAN\r\n\t\t\t\t;THE \"USING\" STRING\r\n\t\t\t\t;NECPPC does not have string formatter\r\n\t\t\t\t; because of ROM space\r\nBGSTRF:\tMOV\tDL,CH\t\t;SAVE THE \"USING\" STRING CHARACTER COUNT\r\n\tPUSH\tBX\t\t;SAVE THE POINTER INTO THE \"USING\" STRING\r\n\tMOV\tCL,LOW 2\t;THE \\\\ STRING FIELD HAS 2 PLUS\r\n\t\t\t\t;NUMBER OF ENCLOSED SPACES WIDTH\r\nLPSTRF:\tMOV\tAL,BYTE PTR [BX]\t;GET THE NEXT CHARACTER\r\n\tINC\tBX\t\t;ADVANCE THE POINTER AT THE \"USING\" STRING\r\n\t\t\t\t;DATA\r\n\tCMP\tAL,LOW OFFSET CSTRNG\t;THE FIELD TERMINATOR?\r\n\tJNZ\tSHORT ??L001\r\n\tJMP\tISSTRF\t\t;GO EVALUATE A STRING AND PRINT\r\n??L001:\r\n\tCMP\tAL,LOW \" \"\t;A FIELD EXTENDER?\r\n\tJNZ\tSHORT NOSTRF\t;IF NOT, ITS NOT A STRING FIELD\r\n\tINC\tCL\t\t;INCREMENT THE FIELD WIDTH\r\n\t\t\t\t;SEE IF THERE ARE MORE CHARACTERS\r\n\tDEC\tCH\r\n\tJNZ\tSHORT LPSTRF\t;KEEP SCANNING FOR THE FIELD TERMINATOR\r\n;\r\n; SINCE  STRING FIELD WASN'T FOUND, THE \"USING\" STRING \r\n; CHARACTER COUNT AND THE POINTER INTO IT'S DATA MUST\r\n; BE RESTORED AND THE \"\\\" PRINTED\r\n;\r\nNOSTRF:\tPOP\tBX\t\t;RESTORE THE POINTER INTO \"USING\" STRING'S DATA\r\n\tMOV\tCH,DL\t\t;RESTORE THE \"USING\" STRING CHARACTER COUNT\r\n\tMOV\tAL,LOW OFFSET CSTRNG\t;RESTORE THE CHARACTER\r\n;\r\n; HERE TO PRINT THE CHARACTER IN [A] SINCE IT WASN'T PART OF ANY FIELD\r\n;\r\nNEWUCH:\tCALL\tPLSPRT\t\t;IF A \"+\" CAME BEFORE THIS CHARACTER\r\n\t\t\t\t;MAKE SURE IT GETS PRINTED\r\n\tCALL\tOUTDO\t\t;PRINT THE CHARACTER THAT WASN'T\r\n\t\t\t\t;PART OF A FIELD\r\n\r\n\r\n\r\nPRCCHR:\tXOR\tAL,AL\t\t;SET [D,E]=0 SO IF WE DISPATCH\r\n\tMOV\tDL,AL\t\t;SOME FLAGS ARE ALREADY ZEROED\r\n\tMOV\tDH,AL\t\t;DON'T PRINT \"+\" TWICE\r\nPLSFIN:\tCALL\tPLSPRT\t\t;ALLOW FOR MULTIPLE PLUSES\r\n\t\t\t\t;IN A ROW\r\n\tMOV\tDH,AL\t\t;SET \"+\" FLAG\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET A NEW CHARACTER\r\n\tINC\tBX\r\n\tCMP\tAL,LOW \"!\"\t;CHECK FOR A SINGLE CHARACTER\r\n\tJNZ\tSHORT ??L002\r\n\tJMP\tSMSTRF\t\t;STRING FIELD\r\n??L002:\r\n\tCMP\tAL,LOW \"#\"\t;CHECK FOR THE START OF A NUMERIC FIELD \r\n\tJZ\tSHORT NUMNUM\t;GO SCAN IT\r\n\tCMP\tAL,LOW \"&\"\t;SEE IF ITS A VARIABLE LENGTH STRING FIELD\r\n\tJNZ\tSHORT ??L003\r\n\tJMP\tVARSTR\t\t;GO PRINT ENTIRE STRING\r\n??L003:\r\n\tDEC\tCH\t\t;ALL THE OTHER POSSIBILITIES\r\n\t\t\t\t;REQUIRE AT LEAST 2 CHARACTERS\r\n\tJNZ\tSHORT ??L004\r\n\tJMP\tREUSIN\t\t;IF THE VALUE LIST IS NOT EXHAUSTED\r\n??L004:\r\n\t\t\t\t;GO REUSE \"USING\" STRING\r\n\tCMP\tAL,LOW \"+\"\t;A LEADING \"+\" ?\r\n\tMOV\tAL,LOW 8\t;SETUP [D] WITH THE PLUS-FLAG ON IN\r\n\tJZ\tSHORT PLSFIN\t;CASE A NUMERIC FIELD STARTS\r\n\tDEC\tBX\t\t;POINTER HAS ALREADY BEEN INCREMENTED\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET BACK THE CURRENT CHARACTER\r\n\tINC\tBX\t\t;REINCREMENT THE POINTER\r\n\tCMP\tAL,LOW \".\"\t;NUMERIC FIELD WITH TRAILING DIGITS\r\n\tJZ\tSHORT DOTNUM\t;IF SO GO SCAN WITH [E]=\r\n\t\t\t\t;NUMBER OF DIGITS BEFORE THE \".\"=0\r\n\tCMP\tAL,LOW \"_\"\t;CHECK FOR LITERAL CHARACTER DECLARATION\r\n\tJNZ\tSHORT ??L005\r\n\tJMP\tLITCHR\r\n??L005:\r\n\tCMP\tAL,LOW OFFSET CSTRNG\t;CHECK FOR A BIG STRING FIELD STARTER\r\n\tJZ\tSHORT BGSTRF\t;GO SEE IF IT REALLY IS A STRING FIELD\r\n\tCMP\tAL,BYTE PTR [BX]\t;SEE IF THE NEXT CHARACTER MATCHES THE\r\n\t\t\t\t;CURRENT ONE\r\n\tJNZ\tSHORT NEWUCH\t;IF NOT, CAN'T HAVE $$ OR ** SO ALL THE\r\n\t\t\t\t;POSSIBILITIES ARE EXHAUSTED\r\n\tCMP\tAL,LOW OFFSET CURNCY\t;IS IT $$ ?\r\n\tJZ\tSHORT DOLRNM\t;GO SET UP THE FLAG BIT\r\n\tCMP\tAL,LOW \"*\"\t;IS IT ** ?\r\n\tJNZ\tSHORT NEWUCH\t;IF NOT, ITS NOT PART\r\n\t\t\t\t;OF A FIELD SINCE ALL THE POSSIBILITIES\r\n\t\t\t\t;HAVE BEEN TRIED\r\n\tINC\tBX\t\t;CHECK FOR $\r\n\tMOV\tAL,CH\t\t;SEE IF THE \"USING\" STRING IS LONG\r\n\tCMP\tAL,LOW 2\t;ENOUGH FOR THE SPECIAL CASE OF\r\n\tJB\tSHORT NOTSPC\t; **$\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tCMP\tAL,LOW OFFSET CURNCY\t;IS THE NEXT CHARACTER $ ?\r\nNOTSPC:\tMOV\tAL,LOW 32\t;SET THE ASTERISK BIT\r\n\tJNZ\tSHORT SPCNUM\t;IF IT NOT THE SPECIAL CASE, DON'T\r\n\t\t\t\t;SET THE DOLLAR SIGN FLAG\r\n\tDEC\tCH\t\t;DECREMENT THE \"USING\" STRING CHARACTER COUNT\r\n\t\t\t\t;TO TAKE THE $ INTO CONSIDERATION\r\n\tINC\tDL\t\t;INCREMENT THE FIELD WIDTH FOR THE\r\n\t\t\t\t;FLOATING DOLLAR SIGN\r\n\tDB\t276O\t; SKIP\t;\"CPI\" OVER THE NEXT BYTE\r\n\t\t\t\t;MVI SI,  IN 8086\r\nDOLRNM:\tXOR\tAL,AL\t\t;CLEAR [A]\r\n\tADD\tAL,LOW 16\t;SET BIT FOR FLOATING DOLLAR SIGN FLAG\r\n\tINC\tBX\t\t;POINT BEYOND THE SPECIAL CHARACTERS\r\nSPCNUM:\tINC\tDL\t\t;SINCE TWO CHARACTERS SPECIFY\r\n\t\t\t\t;THE FIELD SIZE, INITIALIZE [E]=1\r\n\tADD\tAL,DH\t\t;PUT NEW FLAG BITS IN [A]\r\n\tMOV\tDH,AL\t\t;INTO [D]. THE PLUS FLAG MAY HAVE\r\n\t\t\t\t;ALREADY BEEN SET\r\nNUMNUM:\tINC\tDL\t\t;INCREMENT THE NUMBER OF DIGITS BEFORE\r\n\t\t\t\t;THE DECIMAL POINT\r\n\tMOV\tCL,LOW 0\t;SET THE NUMBER OF DIGITS AFTER\r\n\t\t\t\t;THE DECIMAL POINT = 0\r\n\tDEC\tCH\t\t;SEE IF THERE ARE MORE CHARACTERS\r\n\tJZ\tSHORT ENDNUS\t;IF NOT, WE ARE DONE SCANNING THIS\r\n\t\t\t\t;NUMERIC FIELD\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE NEW CHARACTER\r\n\tINC\tBX\t\t;ADVANCE THE POINTER AT THE \"USING\" STRING DATA\r\n\tCMP\tAL,LOW \".\"\t;DO WE HAVE TRAILING DIGITS?\r\n\tJZ\tSHORT AFTDOT\t;IF SO, USE SPECIAL SCAN LOOP\r\n\tCMP\tAL,LOW \"#\"\t;MORE LEADING DIGITS ?\r\n\tJZ\tSHORT NUMNUM\t;INCREMENT THE COUNT AND KEEP SCANNING\r\n\tCMP\tAL,LOW 54O\t;DOES HE WANT A COMMA\r\n\t\t\t\t;EVERY THREE DIGITS?\r\n\tJNZ\tSHORT FINNUM\t;NO MORE LEADING DIGITS, CHECK FOR ^^^\r\n\tMOV\tAL,DH\t\t;TURN ON THE COMMA BIT\r\n\tOR\tAL,LOW 64\r\n\tMOV\tDH,AL\r\n\tJMP\tSHORT NUMNUM\t;GO SCAN SOME MORE\r\n;\r\n; HERE WHEN A \".\" IS SEEN IN THE \"USING\" STRING\r\n; IT STARTS A NUMERIC FIELD IF AND ONLY IF\r\n; IT IS FOLLOWED BY A \"#\"\r\n;\r\nDOTNUM:\tMOV\tAL,BYTE PTR [BX]\t;GET THE CHARACTER THAT FOLLOWS\r\n\tCMP\tAL,LOW \"#\"\t;IS THIS A NUMERIC FIELD?\r\n\tMOV\tAL,LOW \".\"\t;IF NOT, GO BACK AND PRINT \".\"\r\n\tJZ\tSHORT ??L006\r\n\tJMP\tNEWUCH\r\n??L006:\r\n\tMOV\tCL,LOW 1\t;INITIALIZE THE NUMBER OF\r\n\t\t\t\t;DIGITS AFTER THE DECIMAL POINT\r\n\tINC\tBX\r\nAFTDOT:\tINC\tCL\t\t;INCREMENT THE NUMBER OF DIGITS\r\n\t\t\t\t;AFTER THE DECIMAL POINT\r\n\tDEC\tCH\t\t;SEE IF THE \"USING\" STRING HAS MORE\r\n\tJZ\tSHORT ENDNUS\t;CHARACTERS, AND IF NOT, STOP SCANNING\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE NEXT CHARACTER\r\n\tINC\tBX\r\n\tCMP\tAL,LOW \"#\"\t;MORE DIGITS AFTER THE DECIMAL POINT?\r\n\tJZ\tSHORT AFTDOT\t;IF SO, INCREMENT THE COUNT AND KEEP\r\n\t\t\t\t;SCANNING\r\n;\r\n; CHECK FOR THE \"^^^^\" THAT INDICATES SCIENTIFIC NOTATION\r\n;\r\nFINNUM:\tPUSH\tDX\t\t;SAVE [D]=FLAGS AND [E]=LEADING DIGITS\r\n\tMOV\tDX,OFFSET NOTSCI\t;PLACE TO GO IF ITS NOT SCIENTIFIC\r\n\tPUSH\tDX\t\t;NOTATION\r\n\tMOV\tDH,BH\t\t;REMEMBER [H,L] IN CASE\r\n\tMOV\tDL,BL\t\t;ITS NOT SCIENTIFIC NOTATION\r\n\tCMP\tAL,LOW \"^\"\t;IS THE FIRST CHARACTER \"^\" ?\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tCMP\tAL,BYTE PTR [BX]\t;IS THE SECOND CHARACTER \"^\" ?\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tINC\tBX\r\n\tCMP\tAL,BYTE PTR [BX]\t;IS THE THIRD CHARACTER \"^\" ?\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tINC\tBX\r\n\tCMP\tAL,BYTE PTR [BX]\t;IS THE FOURTH CHARACTER \"^\" ?\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tINC\tBX\r\n\tMOV\tAL,CH\t\t;WERE THERE ENOUGH CHARACTERS FOR \"^^^^\"\r\n\tSUB\tAL,LOW 4\t;IT TAKES FOUR\r\n\tJNB\tSHORT $+3\r\n\tRET\r\n\tPOP\tDX\t\t;POP OFF THE NOTSCI RETURN ADDRESS\r\n\tPOP\tDX\t\t;GET BACK [D]=FLAGS [E]=LEADING DIGITS\r\n\tMOV\tCH,AL\t\t;MAKE [B]=NEW CHARACTER COUNT\r\n\tINC\tDH\t\t;TURN ON THE SCIENTIFIC NOTATION FLAG\r\n\tINC\tBX\r\n\tJMP\tSHORT ENDNUS\r\nNOTSCI:\tXCHG\tBX,DX\t\t;RESTORE THE OLD [H,L]\r\n\tPOP\tDX\t\t;GET BACK [D]=FLAGS [E]=LEADING DIGITS\r\nENDNUS:\tMOV\tAL,DH\t\t;IF THE LEADING PLUS FLAG IS ON\r\n\tDEC\tBX\r\n\tINC\tDL\t\t;INCLUDE LEADING \"+\" IN NUMBER OF DIGITS\r\n\tAND\tAL,LOW 8\t;DON'T CHECK FOR A TRAILING SIGN\r\n\tJNZ\tSHORT ENDNUM\t;ALL DONE WITH THE FIELD IF SO\r\n\t\t\t\t;IF THERE IS A LEADING PLUS\r\n\tDEC\tDL\t\t;NO LEADING PLUS SO DON'T INCREMENT THE\r\n\t\t\t\t;NUMBER OF DIGITS BEFORE THE DECIMAL POINT\r\n\tMOV\tAL,CH\r\n\tOR\tAL,AL\t\t;SEE IF THERE ARE MORE CHARACTERS\r\n\tJZ\tSHORT ENDNUM\t;IF NOT, STOP SCANNING\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE CURRENT CHARACTER\r\n\tSUB\tAL,LOW \"-\"\t;TRAIL MINUS?\r\n\tJZ\tSHORT SGNTRL\t;SET THE TRAILING SIGN FLAG\r\n\tCMP\tAL,LOW OFFSET \"+\"-\"-\"\t;A TRAILING PLUS?\r\n\tJNZ\tSHORT ENDNUM\t;IF NOT, WE ARE DONE SCANNING\r\n\tMOV\tAL,LOW 8\t;TURN ON THE POSITIVE=\"+\" FLAG\r\nSGNTRL:\tADD\tAL,LOW 4\t;TURN ON THE TRAILING SIGN FLAG\r\n\tADD\tAL,DH\t\t;INCLUDE WITH OLD FLAGS\r\n\tMOV\tDH,AL\r\n\tDEC\tCH\t\t;DECREMENT THE \"USING\" STRING CHARACTER\r\n\t\t\t\t;COUNT TO ACCOUNT FOR THE TRAILING SIGN\r\nENDNUM:\tPOP\tBX\t\t;[H,L]=THE OLD TEXT POINTER\r\n\tPOPF\t\t\t;POP OFF FLAG THAT SAYS WHETHER THERE\r\n\t\t\t\t;ARE MORE VALUES IN THE VALUE LIST\r\n\tJZ\tSHORT FLDFIN\t;IF NOT, WE ARE DONE WITH THE \"PRINT\"\r\n\tPUSH\tCX\t\t;SAVE [B]=# OF CHARACTERS REMAINING IN\r\n\t\t\t\t;\"USING\" STRING AND [C]=TRAILING DIGITS\r\n\tPUSH\tDX\t\t;SAVE [D]=FLAGS AND [E]=LEADING DIGITS\r\n\tCALL\tFRMEVL\t\t;READ A VALUE FROM THE VALUE LIST\r\n\tPOP\tDX\t\t;[D]=FLAGS & [E]=# OF LEADING DIGITS\r\n\tPOP\tCX\t\t;[B]=# CHARACTER LEFT IN \"USING\" STRING\r\n\t\t\t\t;[C]=NUMBER OF TRAILING DIGITS\r\n\tPUSH\tCX\t\t;SAVE [B] FOR ENTERING SCAN AGAIN\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tMOV\tCH,DL\t\t;[B]=# OF LEADING DIGITS\r\n\tMOV\tAL,CH\t\t;MAKE SURE THE TOTAL NUMBER OF DIGITS\r\n\tADD\tAL,CL\t\t;DOES NOT EXCEED TWENTY-FOUR\r\n\tCMP\tAL,LOW 25\r\n\tJNAE\tSHORT ??L007\r\n\tJMP\tFCERR\t\t;IF SO, \"ILLEGAL FUNCTION CALL\"\r\n??L007:\r\n\tMOV\tAL,DH\t\t;[A]=FLAG BITS\r\n\tOR\tAL,LOW 128\t;TURN ON THE \"USING\" BIT\r\n\tCALL\tPUFOUT\t\t;PRINT THE VALUE\r\n\tEXTRN\tDSOUT:NEAR\r\n\tCALL\tDSOUT\t\t;PRINT FROM THE DATA SEGMENT\r\nFNSTRF:\tPOP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tDEC\tBX\t\t;SEE WHAT THE TERMINATOR WAS\r\n\tCALL\tCHRGTR\r\n\tSTC\t\t\t;SET FLAG THAT CRLF IS DESIRED\r\n\tJZ\tSHORT CRDNUS\t;IF IT WAS A END-OF-STATEMENT\r\n\t\t\t\t;FLAG THAT THE VALUE LIST ENDED\r\n\t\t\t\t;AND THAT  CRLF SHOULD BE PRINTED\r\n\tMOV\tBYTE PTR USFLG,AL\t;FLAG THAT VALUE HAS BEEN PRINTED.\r\n\t\t\t\t;DOESNT MATTER IF ZERO SET, [A]\r\n\t\t\t\t;MUST BE NON-ZERO OTHERWISE\r\n\tCMP\tAL,LOW 73O\t;A SEMI-COLON?\r\n\tJZ\tSHORT SEMUSN\t;A LEGAL DELIMITER\r\n\tCMP\tAL,LOW 54O\t;A COMMA ?\r\n\tJZ\tSHORT ??L008\r\n\tJMP\tSNERR\t\t;THE DELIMETER WAS ILLEGAL\r\n??L008:\r\nSEMUSN:\tCALL\tCHRGTR\t\t;IS THERE ANOTHER VALUE?\r\nCRDNUS:\tPOP\tCX\t\t;[B]=CHARACTERS REMAINING IN \"USING\" STRING\r\n\tXCHG\tBX,DX\t\t;[D,E]=TEXT POINTER\r\n\tPOP\tBX\t\t;[H,L]=POINT AT THE \"USING\" STRING\r\n\tPUSH\tBX\t\t;DESCRIPTOR. RESAVE IT.\r\n\tPUSHF\t\t\t;SAVE THE FLAG THAT INDICATES\r\n\t\t\t\t;WHETHER OR NOT THE VALUE LIST TERMINATED\r\n\tPUSH\tDX\t\t;SAVE THE TEXT POINTER\r\n;\r\n; SINCE FRMEVL MAY HAVE FORCED GARBAGE COLLECTION\r\n; WE HAVE TO USE THE NUMBER OF CHARACTERS ALREADY SCANNED\r\n; AS AN OFFSET TO THE POINTER TO THE \"USING\" STRING'S DATA\r\n; TO GET A NEW POINTER TO THE REST OF THE CHARACTERS TO\r\n; BE SCANNED\r\n;\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE \"USING\" STRING'S LENGTH\r\n\tSUB\tAL,CH\t\t;SUBTRACT THE NUMBER OF CHARACTERS\r\n\t\t\t\t;ALREADY SCANNED\r\n\tINC\tBX\t\t;[H,L]=POINTER AT\r\n\tMOV\tDH,LOW 0\t;SETUP [D,E] AS A DOUBLE BYTE OFFSET\r\n\tMOV\tDL,AL\r\n\tMOV\tBX,[BX]\t\t;THE \"USING\" STRING'S STRING DATA\r\n\tADD\tBX,DX\t\t;ADD ON THE OFFSET TO GET\r\n\t\t\t\t;THE NEW POINTER\r\nCHKUSI:\tMOV\tAL,CH\t\t;[A]=THE NUMBER OF CHARACTERS LEFT TO SCAN\r\n\tOR\tAL,AL\t\t;SEE IF THERE ARE ANY LEFT\r\n\tJZ\tSHORT ??L009\r\n\tJMP\tPRCCHR\t\t;IF SO, KEEP SCANNING\r\n??L009:\r\n\tJMP\tSHORT FINUSI\t;SEE IF THERE ARE MORE VALUES\r\nREUSIN:\tCALL\tPLSPRT\t\t;PRINT A \"+\" IF NECESSARY\r\n\tCALL\tOUTDO\t\t;PRINT THE FINAL CHARACTER\r\nFINUSI:\tPOP\tBX\t\t;POP OFF THE TEXT POINTER\r\n\tPOPF\t\t\t;POP OFF THE INDICATOR OF WHETHER OR NOT\r\n\t\t\t\t;THE VALUE LIST HAS ENDED\r\n\tJZ\tSHORT ??L010\r\n\tJMP\tREUSST\t\t;IF NOT, REUSE THE \"USING\" STRING\r\n??L010:\r\nFLDFIN:\tJNB\tSHORT ??L011\r\n\tCALL\tCRDO\t\t;IF NOT COMMA OR SEMI-COLON\r\n??L011:\r\n\t\t\t\t;ENDED THE VALUE LIST\r\n\t\t\t\t;PRINT A CRLF\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE THE TEXT POINTER\r\n\t\t\t\t;[H,L]=POINT AT THE \"USING\" STRING'S\r\n\t\t\t\t;DESCRIPTOR\r\n\tCALL\tFRETM2\t\t;FINALLY FREE IT UP\r\n\tPOP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tEXTRN\tFINPRT:NEAR\r\n\tJMP\tFINPRT\t\t;ZERO [PTRFIL]\r\n;\r\n; HERE TO HANDLE A LITERAL CHARACTER IN THE USING STRING PRECEDED\r\n; BY \"_\"\r\n;\r\nLITCHR:\tCALL\tPLSPRT\t\t;PRINT PREVIOUS \"+\" IF ANY\r\n\tDEC\tCH\t\t;DECREMENT COUNT FOR ACTUAL CHARACTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;FETCH LITERAL CHARACTER\r\n\tINC\tBX\r\n\tCALL\tOUTDO\r\n\tJMP\tSHORT CHKUSI\t;GO SEE IF USING STRING ENDED\r\n\r\n;\r\n; HERE TO HANDLE VARIABLE LENGTH STRING FIELD SPECIFIED WITH \"&\"\r\n;\r\nVARSTR:\tMOV\tCL,LOW 0\t;SET LENGTH TO 0 TO FLAG VARIABLE LENGTH\r\n\tJMP\tSHORT ISSTR1\r\n\t\t\t\t;NECPPC does not have string formatter\r\n\t\t\t\t; because of ROM space\r\n;\r\n; HERE WHEN THE \"!\" INDICATING A SINGLE CHARACTER\r\n; STRING FIELD HAS BEEN SCANNED\r\n;\r\nSMSTRF:\tMOV\tCL,LOW 1\t;SET THE FIELD WIDTH TO 1\r\n\tJMP\tSHORT ISSTR1\r\nISSTRF:\tPOP\tAX\t\t;GET RID OF THE [H,L] THAT WAS BEING\r\n\t\t\t\t;SAVED IN CASE THIS WASN'T A STRING FIELD\r\nISSTR1:\tDEC\tCH\t\t;DECREMENT THE \"USING\" STRING CHARACTER COUNT\r\n\tCALL\tPLSPRT\t\t;PRINT A \"+\" IF ONE CAME BEFORE THE FIELD\r\n\tPOP\tBX\t\t;TAKE OFF THE TEXT POINTER\r\n\tPOPF\t\t\t;TAKE OF THE FLAG WHICH SAYS\r\n\t\t\t\t;WHETHER THERE ARE MORE VALUES IN THE\r\n\t\t\t\t;VALUE LIST\r\n\tJZ\tSHORT FLDFIN\t;IF THERE ARE NO MORE VALUES\r\n\t\t\t\t;THEN WE ARE DONE\r\n\tPUSH\tCX\t\t;SAVE [B]=NUMBER OF CHARACTERS YET TO\r\n\t\t\t\t;BE SCANNED IN \"USING\" STRING\r\n\tCALL\tFRMEVL\t\t;READ A VALUE\r\n\tCALL\tCHKSTR\t\t;MAKE SURE ITS A STRING\r\n\tPOP\tCX\t\t;[C]=FIELD WIDTH\r\n\tPUSH\tCX\t\t;RESAVE [B]\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tMOV\tBX,FACLO\t;GET A POINTER TO THE DESCRIPTOR\r\n\tMOV\tCH,CL\t\t;[B]=FIELD WIDTH\r\n\tMOV\tCL,LOW 0\t;SET UP FOR \"LEFT$\"\r\n\tMOV\tAL,CH\t\t;GET FIELD WITH IN [A]\r\n\tPUSH\tAX\t\t;SAVE THE FIELD WIDTH FOR SPACE PADDING\r\n\tMOV\tAL,CH\t\t;SEE IF VARIABLE LENGTH FIELD\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT ??L012\r\n\tCALL\tLEFTUS\r\n??L012:\r\n\tCALL\tSTRPRT\t\t;PRINT THE STRING\r\n\tMOV\tBX,FACLO\t;SEE IF IT NEEDS TO BE PADDED\r\n\tPOP\tAX\t\t;[A]=FIELD WIDTH\r\n\tOR\tAL,AL\t\t;IF FIELD LENGTH IS 0 MUST BE \"&\" SO\r\n\tJNZ\tSHORT ??L013\r\n\tJMP\tFNSTRF\t\t;DONT PRINT ANY TRAILING SPACES\r\n??L013:\r\n\tSUB\tAL,BYTE PTR [BX]\t;[A]=AMOUNT OF PADDING NEEDED\r\n\tMOV\tCH,AL\r\n\tMOV\tAL,LOW \" \"\t;SETUP THE PRINT CHARACTER\r\n\tINC\tCH\t\t;DUMMY INCREMENT OF NUMBER OF SPACES\r\nUPRTSP:\tDEC\tCH\t\t;SEE IF MORE SPACES\r\n\tJNZ\tSHORT ??L014\r\n\tJMP\tFNSTRF\t\t;NO, GO SEE IF THE VALUE LIST ENDED AND\r\n??L014:\r\n\t\t\t\t;RESUME SCANNING\r\n\tCALL\tOUTDO\t\t;PRINT A SPACE\r\n\tJMP\tSHORT UPRTSP\t;AND LOOP PRINTING THEM\r\n;\r\n; WHEN A \"+\" IS DETECTED IN THE \"USING\" STRING\r\n; IF A NUMERIC FIELD FOLLOWS A BIT IN [D] SHOULD\r\n; BE SET, OTHERWISE \"+\" SHOULD BE PRINTED.\r\n; SINCE DECIDING WHETHER A NUMERIC FIELD FOLLOWS IS VERY\r\n; DIFFICULT, THE BIT IS ALWAYS SET IN [D].\r\n; AT THE POINT IT IS DECIDED A CHARACTER IS NOT PART\r\n; OF A NUMERIC FIELD, THIS ROUTINE IS CALLED TO SEE\r\n; IF THE BIT IN [D] IS SET, WHICH MEANS\r\n; A PLUS PRECEDED THE CHARACTER AND SHOULD BE\r\n; PRINTED.\r\n;\r\nPLSPRT:\tPUSH\tAX\t\t;SAVE THE CURRENT CHARACTER\r\n\tMOV\tAL,DH\t\t;CHECK THE PLUS BIT\r\n\tOR\tAL,AL\t\t;SINCE IT IS THE ONLY THING THAT COULD\r\n\t\t\t\t;BE TURNED ON\r\n\tMOV\tAL,LOW \"+\"\t;SETUP TO PRINT THE PLUS\r\n\tJZ\tSHORT ??L015\r\n\tCALL\tOUTDO\t\t;PRINT IT IF THE BIT WAS SET\r\n??L015:\r\n\tPOP\tAX\t\t;GET BACK THE CURRENT CHARACTER\r\n\tRET\t\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000"
        },
        {
          "name": "BIPTRG.ASM",
          "type": "blob",
          "size": 20.875,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   BIPTRG  BASIC Interpreter pointer get routines/WHG/PGA\r\n\r\n\t.RADIX\t10\r\n\r\nPC8A=0\r\nTRSHHC=0\r\nNECPPC=0\r\nOLVPPC=0\r\n\r\n\tSUBTTL  DIMENSION & VARIABLE SEARCHING - PTRGET\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t; Data Segment\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tARYTA2:WORD,ARYTAB:WORD,DIMFLG:WORD,STREND:WORD\r\n\tEXTRN\tSUBFLG:WORD,TEMP2:WORD,TEMP3:WORD,VALTYP:WORD,VARTAB:WORD\r\n\tEXTRN\tDSEGZ:WORD\r\n\tEXTRN\tNAMBUF:WORD,NAMCNT:WORD,NAMTMP:WORD\r\n\tEXTRN\tOPTVAL:WORD\r\n\tEXTRN\tPARM1:WORD,PRMFLG:WORD,PRMLEN:WORD,DEFTBL:WORD,NOFUNS:WORD\r\n\tEXTRN\tFAC:WORD,FACLO:WORD\r\nDSEG\tENDS\t\t\t; End of data degment externals\r\n\r\n\t\t\t\t; Code Segment ( terminated by END at bottom of file )\r\n\r\n\r\n\tEXTRN\tBLTU:NEAR,ERRBS:NEAR,ERROR:NEAR,FCERR:NEAR\r\n\tEXTRN\tGETSTK:NEAR,INTIDX:NEAR,ISLET:NEAR,ISLET2:NEAR,OMERR:NEAR\r\n\tEXTRN\tREASON:NEAR,SNERR:NEAR\r\n\tEXTRN\tREDDY:NEAR,POPHRT:NEAR,ERRDD:NEAR,RETVAR:NEAR,UMULT:NEAR\r\n\r\n\tEXTRN\tCHRGTR:NEAR,DCOMPR:NEAR,SYNCHR:NEAR\r\n\tEXTRN\tGETYPR:NEAR\r\n\tEXTRN\tLOPFD1:NEAR,LOPFND:NEAR\r\n\tPUBLIC\tNOTFDD,NOTFNS\r\n\r\n\tPUBLIC\tPTRGET,BSERR,PTRGT2,DIM,NOARYS\r\n\tPAGE\t\r\nDIMCON:\tDEC\tBX\t\t;SEE IF COMMA ENDED THIS VARIABLE\r\n\tCALL\tCHRGTR\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF TERMINATOR, GOOD BYE\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;MUST BE COMMA\r\n;\r\n; THE \"DIM\" CODE SETS DIMFLG AND THEN FALLS INTO THE VARIABLE\r\n; SEARCH ROUTINE. THE VARIABLE SEARCH ROUTINE LOOKS AT\r\n; DIMFLG AT THREE DIFFERENT POINTS:\r\n;\r\n;       1) IF AN ENTRY IS FOUND, DIMFLG BEING ON INDICATES\r\n;               A \"DOUBLY DIMENSIONED\" VARIABLE\r\n;       2) WHEN A NEW ENTRY IS BEING BUILT DIMFLG'S BEING ON\r\n;               INDICATES THE INDICES SHOULD BE USED FOR\r\n;               THE SIZE OF EACH INDICE. OTHERWISE THE DEFAULT\r\n;               OF TEN IS USED.\r\n;       3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF DIMFLG IS\r\n;               OFF WILL INDEXING BE DONE\r\n;\r\nDIM:\tMOV\tCX,OFFSET DIMCON\t;PLACE TO COME BACK TO\r\n\tPUSH\tCX\r\n\tMOV\tAL,LOW 200\r\n\tJMP\tSHORT PTRGT1\r\n\t\t\t\t;MUST TURN THE MSB ON\r\n;\r\n; ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION\r\n; AND PUT A POINTER TO ITS VALUE IN [D,E]. [H,L] IS UPDATED\r\n; TO POINT TO THE CHARACTER AFTER THE VARIABLE NAME.\r\n; VALTYP IS SETUP. NOTE THAT EVALUATING SUBSCRIPTS IN\r\n; A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO PTRGET SO AT\r\n; THAT POINT ALL VALUES MUST BE STORED ON THE STACK.\r\n; ON RETURN, [A] DOES NOT REFLECT THE VALUE OF THE TERMINATING CHARACTER\r\n;\r\nPTRGET:\tXOR\tAL,AL\t\t;MAKE [A]=0\r\nPTRGT1:\r\n\tMOV\tBYTE PTR DIMFLG,AL\t;FLAG IT AS SUCH\r\n\tMOV\tCL,BYTE PTR [BX]\t;GET FIRST CHARACTER IN [C]\r\nPTRGT2:\r\n\tCALL\tISLET\t\t;CHECK FOR LETTER\r\n\tJAE\tSHORT ??L000\r\n\tJMP\tSNERR\t\t;MUST HAVE A LETTER\r\n??L000:\r\n\tXOR\tAL,AL\r\n\tMOV\tCH,AL\t\t;ASSUME NO SECOND CHARACTER\r\n\tMOV\tBYTE PTR NAMCNT,AL\t;ZERO NAMCNT\r\n\tINC\tBX\t\t;INCRMENT TEXT POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR\r\n\tCMP\tAL,LOW \".\"\t;IS IT A DOT?\r\n\tJB\tSHORT NOSEC\t;TOO SMALL FOR ANYTHING REASONABLE\r\n\tJZ\tSHORT ISSEC\t;\".\" IS VALID VAR CHAR\r\n\tCMP\tAL,LOW OFFSET \"9\"+1\t;TOO BIG FOR NUMERIC?\r\n\tJAE\tSHORT PTRGT3\t;YES\r\n\tCMP\tAL,LOW \"0\"\t;IN RIGHT RANGE?\r\n\tJAE\tSHORT ISSEC\t;YES, WAS NUMERIC\r\nPTRGT3:\tCALL\tISLET2\t\t;SET CARRY IF NOT ALPHABETIC\r\n\tJB\tSHORT NOSEC\t;ALLOW ALPHABETICS\r\nISSEC:\tMOV\tCH,AL\t\t;IT IS A NUMBER--SAVE IN B\r\n\tPUSH\tCX\t\t;SAVE [B,C]\r\n\tMOV\tCH,LOW 255\t;[B] COUNTS THE CHARACTERS PAST #2\r\n\tMOV\tDX,OFFSET NAMBUF-1\t;THE PLACE TO PUT THE CHARACTERS\r\nVMORCH:\tOR\tAL,LOW 128D\t;EXTRA CHARACTERS MUST HAVE THE HIGH BIT ON\r\n\t\t\t\t;SO ERASE CAN SCAN BACKWARDS OVER THEM\r\n\tINC\tCH\t\t;INCREASE THE CHACRACTER COUNT\r\n\tMOV\tDI,DX\r\n\tSTOSB\t\t\t;AND STORE INTO THE BUFFER\r\n\tINC\tDX\t\t;AND UPDATE THE BUFFER POINTER\r\n\tINC\tBX\t\t;INCREMENT TEXT POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR\r\n\tCMP\tAL,LOW OFFSET \"9\"+1\t;TOO BIG?\r\n\tJAE\tSHORT VMORC1\t;YES\r\n\tCMP\tAL,LOW \"0\"\t;IN RANGE FOR DIGIT\r\n\tJAE\tSHORT VMORCH\t;YES, VALID CHAR\r\nVMORC1:\tCALL\tISLET2\t\t;AS ARE ALPHABETICS\r\n\tJAE\tSHORT VMORCH\r\n\tCMP\tAL,LOW \".\"\t;DOTS ALSO OK\r\n\tJZ\tSHORT VMORCH\t;SO EAT IT\r\n\tMOV\tAL,CH\t\t;CHECK FOR MAXIMUM COUNT\r\n\tCMP\tAL,LOW OFFSET NAMLEN-1\t;LIMITED TO SIZE OF NAMBUF ONLY\r\n\tJNAE\tSHORT ??L001\r\n\tJMP\tSNERR\t\t;MUST BE BAD SYNTAX\r\n??L001:\r\n\tPOP\tCX\t\t;GET BACK THE STORED [B,C]\r\n\tMOV\tBYTE PTR NAMCNT,AL\t;ALWAYS SET UP COUNT OF EXTRAS\r\n\tMOV\tAL,BYTE PTR [BX]\t;RESTORE TERMINATING CHAR\r\nNOSEC:\r\n\tCMP\tAL,LOW OFFSET \"%\"+1\t;NOT A TYPE INDICATOR\r\n\tJAE\tSHORT TABTYP\t;THEN DONT CHECK THEM\r\n\tMOV\tDX,OFFSET HAVTYP\t;SAVE JUMPS BY USING RETURN ADDRESS\r\n\tPUSH\tDX\r\n\tMOV\tDH,LOW 2\t;CHECK FOR INTEGER\r\n\tCMP\tAL,LOW \"%\"\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tINC\tDH\t\t;CHECK FOR STRING\r\n\tCMP\tAL,LOW \"$\"\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tINC\tDH\t\t;CHECK FOR SINGLE PRECISION\r\n\tCMP\tAL,LOW \"!\"\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tMOV\tDH,LOW 8\t;ASSUME ITS DOUBLE PRECISION\r\n\tCMP\tAL,LOW \"#\"\t;CHECK THE CHARACTER\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;WHEN WE MATCH, SETUP VALTYP\r\n\tPOP\tAX\t\t;POP OFF NON-USED HAVTYP ADDRESS\r\nTABTYP:\tMOV\tAL,CL\t\t;GET THE STARTING CHARACTER\r\n\tAND\tAL,LOW 127\t;GET RID OF THE USER-DEFINED\r\n\t\t\t\t;FUNCTION BIT IN [C]\r\n\tMOV\tDL,AL\t\t;BUILD A TWO BYTE OFFSET\r\n\tMOV\tDH,LOW 0\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tMOV\tBX,OFFSET DEFTBL-\"A\"\t;SEE WHAT THE DEFAULT IS\r\n\tADD\tBX,DX\r\n\tMOV\tDH,BYTE PTR [BX]\t;GET THE TYPE OUT OF THE TABLE\r\n\tPOP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tDEC\tBX\t\t;NO MARKING CHARACTER\r\nHAVTYP:\tMOV\tAL,DH\t\t;SETUP VALTYP\r\n\tMOV\tBYTE PTR VALTYP,AL\r\n\tCALL\tCHRGTR\t\t;READ PAST TYPE MARKER\r\n\tMOV\tAL,BYTE PTR SUBFLG\t;GET FLAG WHETHER TO ALLOW ARRAYS\r\n\tDEC\tAL\t\t;IF SUBFLG=1, \"ERASE\" HAS CALLED\r\n\tJNZ\tSHORT ??L002\r\n\tJMP\tERSFIN\t\t;PTRGET, AND SPECIAL HANDLING MUST BE DONE\r\n??L002:\r\n\tJS\tSHORT ??L003\r\n\tJMP\tNOARYS\t\t;NO ARRAYS ALLOWED\r\n??L003:\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR BACK\r\n\tSUB\tAL,LOW \"(\"\t;ARRAY PERHAPS (IF SUBFLG SET NEVER WILL MATCH)\r\n\tJNZ\tSHORT ??L004\r\n\tJMP\tISARY\t\t;IT IS!\r\n??L004:\r\n\tSUB\tAL,LOW OFFSET \"[\"-\")\"+1\t;SEE IF LEFT BRACKET\r\n\tJNZ\tSHORT ??L005\r\n\tJMP\tISARY\t\t;IF SO, OK SUBSCRIPT\r\n??L005:\r\nNOARYS:\tXOR\tAL,AL\t\t;ALLOW PARENS AGAIN\r\n\tMOV\tBYTE PTR SUBFLG,AL\t;SAVE IN FLAG LOCATION\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tMOV\tAL,BYTE PTR NOFUNS\t;ARE FUNCTIONS ACTIVE?\r\n\tOR\tAL,AL\r\n\tMOV\tBYTE PTR PRMFLG,AL\t;INDICATE IF PARM1 NEEDS SEARCHING\r\n\tJZ\tSHORT SNFUNS\t;NO FUNCTIONS SO NO SPECIAL SEARCH\r\n\tMOV\tBX,PRMLEN\t;GET THE SIZE TO SEARCH\r\n\tMOV\tDX,OFFSET PARM1\t;GET THE BASE OF THE SEARCH\r\n\tADD\tBX,DX\t\t;[H,L]= PLACE TO STOP SEARCHING\r\n\tMOV\tARYTA2,BX\t;SET UP STOPPING POINT\r\n\tXCHG\tBX,DX\t\t;[H,L]=START [D,E]=END\r\n\tJMP\tLOPFND\r\nNOTFNS:\tMOV\tAL,BYTE PTR PRMFLG\t;HAS PARM1 BEEN SEARCHED\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT SMKVAR\t;IF SO, CREATE VARIABLE\r\n\tXOR\tAL,AL\t\t;FLAG PARM1 AS SEARCHED\r\n\tMOV\tBYTE PTR PRMFLG,AL\r\nSNFUNS:\tMOV\tBX,ARYTAB\t;STOPPING POINT IS [ARYTA2]\r\n\tMOV\tARYTA2,BX\r\n\tMOV\tBX,VARTAB\t;SET UP STARTING POINT\r\n\tJMP\tLOPFND\r\n\r\n; THIS ENTRY POINT IS FOR THOSE CALLERS WHO WANT TO RETURN\r\n; FROM PTRGET WITHOUT CREATING A SYMBOL TABLE ENTRY IF THE\r\n; VARIABLE IS NOT FOUND IN THE SYMBOL TABLE. PTRGET THEN RETURNS\r\n; THROUGH VARNOT AND RETURNS WITH [D,E]=0 AND [A]=0\r\n\tPUBLIC\tPTRGTN,PTRGTR\r\nPTRGTN:\tCALL\tPTRGET\t\t;CALL PTRGET\r\nPTRGTR:\tRET\t\t\t;DONT CHANGE THIS SEQUENCE AS RETURN\r\n\t\t\t\t;ADDRESS IS CHECKED FOR\r\n\r\n; THIS IS EXIT FOR VARPTR AND OTHERS\r\nVARNOT:\r\n\tXOR\tAL,AL\t\t;MAKE SURE [AL]=0\r\n\tMOV\tDH,AL\t\t;ZERO [D,E]\r\n\tMOV\tDL,AL\r\n\tPOP\tCX\t\t;GET RID OF PUSHED [D,E]\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT RETURN ADDRESS BACK ON STACK\r\n\tRET\t\t\t;RETURN FROM PTRGET\r\n\r\nSMKVAR:\tPOP\tBX\t\t;[H,L]= TEXT POINTER\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;[H,L]= RETURN ADDRESS\r\n\tPUSH\tDX\t\t;SAVE CURRENT VARIABLE TABLE POSITION\r\n\tMOV\tDX,OFFSET PTRGTR\t;ARE WE RETURNING TO PTRGTN?\r\n\tCMP\tBX,DX\t\t;COMPARE\r\n\tJZ\tSHORT VARNOT\t;YES.\r\n\tMOV\tDX,OFFSET RETVAR\t;DID EVAL CALL US?\r\n\tCMP\tBX,DX\t\t;IF SO, DON'T MAKE A NEW VARIABLE\r\n\tPOP\tDX\t\t;RESTORE THE POSITION\r\n\tJZ\tSHORT FINZER\t;MAKE FAC ZERO (ALL TYPES) AND SKIP RETURN\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT RETURN ADDRESS BACK\r\n\tPUSH\tBX\t\t;PUT THE TEXT POINTER BACK\r\n\tPUSH\tCX\t\t;SAVE THE LOOKS\r\n\tMOV\tAL,BYTE PTR VALTYP\t;GET LENGTH OF SYMBOL TABLE ENTRY\r\n\tMOV\tCH,AL\t\t;[B]=VALTYP\r\n\tMOV\tAL,BYTE PTR NAMCNT\t;INCLUDE EXTRA CHARACTERS IN SIZE\r\n\tADD\tAL,CH\r\n\tINC\tAL\t\t;AS WELL AS THE EXTRA CHARACTER COUNT\r\n\tMOV\tCL,AL\t\t;[B,C]=LENGTH OF THIS VARIABLE\r\n\tPUSH\tCX\t\t;SAVE THE VALTYP ON THE STACK\r\n\tMOV\tCH,LOW 0\t;[B]=0\r\n\tINC\tCX\t\t;MAKE THE LENGTH INCLUDE\r\n\t\t\t\t;THE LOOKS TOO\r\n\tINC\tCX\r\n\tINC\tCX\r\n\tMOV\tBX,STREND\t;THE CURRENT END OF STORAGE\r\n\tPUSH\tBX\t\t;SAVE THIS #\r\n\tADD\tBX,CX\t\t;ADD ON THE AMOUNT OF SPACE\r\n\t\t\t\t;EXTRA NOW BEING USED\r\n\tPOP\tCX\t\t;POP OFF HIGH ADDRESS TO MOVE\r\n\tPUSH\tBX\t\t;SAVE NEW CANDIDATE FOR STREND\r\n\tCALL\tBLTU\t\t;BLOCK TRANSFER AND MAKE SURE\r\n\t\t\t\t;WE ARE NOT OVERFLOWING THE\r\n\t\t\t\t;STACK SPACE\r\n\tPOP\tBX\t\t;[H,L]=NEW STREND\r\n\tMOV\tSTREND,BX\t;STORE SINCE WAS OK\r\n\t\t\t\t;THERE WAS ROOM, AND BLOCK TRANSFER\r\n\t\t\t\t;WAS DONE, SO UPDATE POINTERS\r\n\tMOV\tBX,CX\t\t;GET BACK [H,L] POINTING AT THE END\r\n\t\t\t\t;OF THE NEW VARIABLE\r\n\tMOV\tARYTAB,BX\t;UPDATE THE ARRAY TABLE POINTER\r\nZEROER:\tDEC\tBX\t\t;[H,L] IS RETURNED POINTING TO THE\r\n\tMOV\tBYTE PTR [BX],LOW 0\t;END OF THE VARIABLE SO WE\r\n\tCMP\tBX,DX\t\t;ZERO BACKWARDS TO [D,E] WHICH\r\n\tJNZ\tSHORT ZEROER\t;POINTS TO THE START OF THE VARIABLE\r\n\tPOP\tDX\t\t;[E]=VALTYP\r\n\tMOV\tBYTE PTR [BX],DH\t;VALTYP IS IN HIGH ORDER\r\n\tINC\tBX\r\n\tPOP\tDX\r\n\tMOV\t[BX],DX\r\n\tINC\tBX\t\t;PUT DESCRIPTION OF THIS VARIABLE\r\n\t\t\t\t;INTO MEMORY\r\n\tCALL\tNPUTSB\t\t;SAVE THE EXTRA CHARACTERS IN THE NAME\r\n\tXCHG\tBX,DX\t\t;POINTER AT VARIABLE INTO [D,E]\r\n\tINC\tDX\t\t;POINT AT THE VALUE\r\n\tPOP\tBX\t\t;RESTORE THE TEXT POINTER\r\n\tRET\t\r\n;\r\n; MAKE ALL TYPES ZERO AND SKIP RETURN\r\n;\r\nFINZER:\r\n\tEXTRN\t$DZERO:NEAR\r\n\tCALL\t$DZERO\t\t;Really clear the entire FAC since\r\n\t\t\t\t;the 8086 math package doesn't\r\n\t\t\t\t;treat a number as zero just because\r\n\t\t\t\t;its exponent is zero like to 8080\r\n\t\t\t\t;math package does.\r\n\tCALL\tGETYPR\t\t;SEE IF ITS A STRING\r\n\tJNZ\tSHORT POPHR2\t;IF NOT, DONE\r\n\tMOV\tBX,OFFSET DSEGZ\t;ZERO IN THE DATA SEGMENT\r\n\tMOV\tFACLO,BX\t;POINTING AT A ZERO\r\nPOPHR2:\tPOP\tBX\t\t;GET THE TEXT POINTER\r\n\tRET\t\t\t;RETURN FROM EVAL\r\n\r\n\r\n\tPAGE\t\r\n\tSUBTTL  MULTIPLE DIMENSION CODE\r\n\r\n;\r\n; FORMAT OF ARRAYS IN CORE\r\n;\r\n; DESCRIPTOR \r\n;       LOW BYTE = SECOND CHARCTER (200 BIT IS STRING FLAG)\r\n;       HIGH BYTE = FIRST CHARACTER\r\n; LENGTH OF ARRAY IN CORE IN BYTES (DOES NOT INCLUDE DESCRIPTOR)\r\n; NUMBER OF DIMENSIONS 1 BYTE\r\n; FOR EACH DIMENSION STARTING WITH THE FIRST A LIST\r\n; (2 BYTES EACH) OF THE MAX INDICE+1\r\n; THE VALUES\r\n;\r\nISARY:\tPUSH\tBX\t\t;SAVE DIMFLG AND VALTYP FOR RECURSION\r\n\tMOV\tBX,DIMFLG\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;TEXT POINTER BACK INTO [H,L]\r\n\tMOV\tDH,AL\t\t;SET # DIMENSIONS =0\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSARYFL:WORD\r\nDSEG\tENDS\r\n\tDEC\tAL\t\t;SARYFL=^O377 - tells CALL that array element\r\n\tMOV\tBYTE PTR SARYFL,AL\t;has been scanned.\r\nINDLOP:\tPUSH\tDX\t\t;SAVE NUMBER OF DIMENSIONS\r\n\tPUSH\tCX\t\t;SAVE LOOKS\r\n\tMOV\tDX,OFFSET NAMCNT\t;POINT AT THE AREA TO SAVE\r\n\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;GET LENGTH\r\n\tOR\tAL,AL\t\t;IS IT ZERO?\r\n\tJZ\tSHORT SHTNAM\t;YES, SHORT NAME\r\n\tXCHG\tBX,DX\t\t;SAVE THE TEXT POINTER IN [D,E]\r\n\tADD\tAL,LOW 2\t;WE WANT SMALLEST INT .GE.(NAMCNT+1)/2\r\n\tRCR\tAL,1\r\n\tMOV\tCL,AL\t\t;SEE IF THERE IS ROOM TO SAVE THIS STUFF\r\n\tCALL\tGETSTK\r\n\tMOV\tAL,CL\t\t;RESTORE COUNT OF PUSHES\r\nLPPSNM:\tMOV\tCL,BYTE PTR [BX]\t;GET VALUES TO PUSH\r\n\tINC\tBX\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tINC\tBX\r\n\tPUSH\tCX\t\t;AND DO THE SAVE\r\n\tDEC\tAL\t\t;[A] TIMES\r\n\tJNZ\tSHORT LPPSNM\r\n\tPUSH\tBX\t\t;SAVE THE ADDRESS TO STORE TO\r\n\tMOV\tAL,BYTE PTR NAMCNT\t;SAVE THE NUMBER OF BYTES FOR A COUNT\r\n\tPUSH\tAX\r\n\tXCHG\tBX,DX\t\t;RESTORE THE TEXT POINTER\r\n\tCALL\tINTIDX\t\t;EVALUATE INDICE INTO [D,E]\r\n\tPOP\tAX\t\t;COUNT TELLING HOW MUCH TO RESTORE\r\n\tMOV\tNAMTMP,BX\t;SAVE THE TEXT POINTER\r\n\tPOP\tBX\t\t;THE PLACE TO RESTORE TO\r\n\tADD\tAL,LOW 2\t;CALCULATE BYTE POPS AGAIN\r\n\tRCR\tAL,1\r\nLPLNAM:\tPOP\tCX\r\n\tDEC\tBX\r\n\tMOV\tBYTE PTR [BX],CH\r\n\tDEC\tBX\r\n\tMOV\tBYTE PTR [BX],CL\r\n\tDEC\tAL\t\t;LOOP [A] TIMES POPING NAME BACK INTO NAMBUF\r\n\tJNZ\tSHORT LPLNAM\r\n\tMOV\tBX,NAMTMP\r\n\tJMP\tSHORT LNGNAM\t;WAS LONG ONE\r\nSHTNAM:\tCALL\tINTIDX\t\t;EVALUATE IT\r\n\tXOR\tAL,AL\t\t;MAKE SURE NAMCNT=0\r\n\tMOV\tBYTE PTR NAMCNT,AL\r\nLNGNAM:\r\n\tMOV\tAL,BYTE PTR OPTVAL\t;SEE WHAT THE OPTION BASE IS\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT OPTB0\t;IF BASE 0 DO NOTHING\r\n\tOR\tDX,DX\t\t;CHECK FOR 0 SUBSCRIPT\r\n\t\t\t\t;WHICH IS ILLEGAL IN BASE 1\r\n\tJNZ\tSHORT ??L006\r\n\tJMP\tBSERR\r\n??L006:\r\n\tDEC\tDX\t\t;ADJUST SUBSCRIPT\r\nOPTB0:\r\n\tPOP\tCX\t\t;POP OFF THE LOOKS\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;[A] = NUMBER OF DIMENSIONS SO FAR\r\n\tXCHG\tBX,DX\t\t;[D,E]=TEXT POINTER\r\n\t\t\t\t;[H,L]=INDICE\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT THE INDICE ON THE STACK\r\n\t\t\t\t;[H,L]=VALTYP & DIMFLG\r\n\tPUSH\tBX\t\t;RESAVE VALTYP AND DIMFLG\r\n\tXCHG\tBX,DX\t\t;[H,L]=TEXT POINTER\r\n\tINC\tAL\t\t;INCREMENT # OF DIMENSIONS\r\n\tMOV\tDH,AL\t\t;[D]=NUMBER OF DIMENSIONS\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET TERMINATING CHARACTER\r\n\tCMP\tAL,LOW 44\t;A COMMA SO MORE INDICES FOLLOW?\r\n\tJNZ\tSHORT ??L007\r\n\tJMP\tINDLOP\t\t;IF SO, READ MORE\r\n??L007:\r\n\tCMP\tAL,LOW \")\"\t;EXPECTED TERMINATOR?\r\n\tJZ\tSHORT DOCHRT\t;DO CHRGET FOR NEXT ONE\r\n\tCMP\tAL,LOW \"]\"\t;BRACKET?\r\n\tJZ\tSHORT ??L008\r\n\tJMP\tSNERR\t\t;NO, GIVE ERROR\r\n??L008:\r\nDOCHRT:\tCALL\tCHRGTR\r\nSUBSOK:\tMOV\tTEMP2,BX\t;SAVE THE TEXT POINTER\r\n\tPOP\tBX\t\t;[H,L]= VALTYP & DIMFLG\r\n\tMOV\tDIMFLG,BX\t;SAVE VALTYP AND DIMFLG\r\n\tMOV\tDL,LOW 0\t;WHEN [D,E] IS POPED INTO PSW, WE\r\n\t\t\t\t;DON'T WANT THE ZERO FLAG TO BE SET, SO\r\n\t\t\t\t;\"ERASE\" WILL HAVE A UNIQUE CONDITION\r\n\tPUSH\tDX\t\t;SAVE NUMBER OF DIMENSIONS\r\n\tPUBLIC\tERSFIN\r\n\tJMP\tSHORT LOPFD0\r\nERSFIN:\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\t\t;SAVE A DUMMY NUMBER OF DIMENSIONS\r\n\t\t\t\t;WITH THE ZERO FLAG SET\r\nLOPFD0:\r\n;\r\n; AT THIS POINT [B,C]=LOOKS. THE TEXT POINTER IS IN TEMP2.\r\n; THE INDICES ARE ALL ON THE STACK, FOLLOWED BY THE NUMBER OF DIMENSIONS.\r\n;\r\n\tMOV\tBX,ARYTAB\t;[H,L]=PLACE TO START THE SEARCH\r\n\tJMP\tLOPFD1\r\n\tPUBLIC\tARYEXT\r\nARYEXT:\r\n\t\t\t\t;AND TRY AGAIN\r\n\tMOV\tAL,BYTE PTR DIMFLG\t;SEE IF CALLED BY \"DIM\"\r\n\tOR\tAL,AL\t\t;ZERO MEANS NO\r\n\tEXTRN\tDDERR:NEAR\r\n\tJZ\tSHORT ??L009\r\n\tJMP\tDDERR\t\t;PRESERVE [D,E], AND DISPATCH TO\r\n??L009:\r\n\t\t\t\t;\"REDIMENSIONED VARIABLE\" ERROR\r\n\t\t\t\t;IF ITS \"DIM\" CALLING PTRGET\r\n;\r\n; TEMP2=THE TEXT POINTER\r\n; WE HAVE LOCATED THE VARIABLE WE WERE LOOKING FOR\r\n; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS\r\n; THE INDICES ARE ON THE STACK FOLLOWED BY THE NUMBER OF DIMENSIONS\r\n;\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;[A]=NUMBER OF DIMENSIONS\r\n\tMOV\tCX,BX\t\t;SET [B,C] TO POINT AT NUMBER OF DIMENSIONS\r\n\tJNZ\tSHORT ??L010\r\n\tJMP\tPOPHRT\t\t;\"ERASE\" IS DONE AT THIS POINT, SO RETURN\r\n??L010:\r\n\t\t\t\t;TO DO THE ACTUAL ERASURE\r\n\tSUB\tAL,BYTE PTR [BX]\t;MAKE SURE THE NUMBER GIVEN NOW AND\r\n\t\t\t\t;AND WHEN THE ARRAY WAS SET UP ARE THE\r\n\t\t\t\t;SAME\r\n\tJNZ\tSHORT ??L011\r\n\tJMP\tGETDEF\t\t;JUMP OFF AND READ\r\n??L011:\r\n\t\t\t\t;THE INDICES....\r\n\r\nBSERR:\tMOV\tDX,OFFSET ERRBS\t;\"SUBSCRIPT OUT OF RANGE\"\r\n\tJMP\tERROR\r\n;\r\n; HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE\r\n;\r\n; BUILDING AN ENTRY:\r\n; \r\n;       PUT DOWN THE DESCRIPTOR \r\n;       SETUP NUMER OF DIMENSIONS\r\n;       MAKE SURE THERE IS ROOM FOR THE NEW ENTRY\r\n;       REMEMBER VARPTR\r\n;       TALLY=4 (VALTYP FOR THE EXTENDED)\r\n;       SKIP 2 LOCS FOR LATER FILL IN -- THE SIZE\r\n; LOOP: GET AN INDICE\r\n;       PUT NUMBER +1 DOWN AT VARPTR AND INCREMENT VARPTR\r\n;       TALLY= TALLY * NUMBER+1\r\n;       DECREMENT NUMBER-DIMS\r\n;       JNZ     LOOP\r\n;       CALL REASON WITH [H,L] REFLECTING LAST LOC OF VARIABLE\r\n;       UPDATE STREND\r\n;       ZERO BACKWARDS\r\n;       MAKE TALLY INCLUDE MAXDIMS\r\n;       PUT DOWN TALLY\r\n;       IF CALLED BY DIMENSION, RETURN\r\n;       OTHERWISE INDEX INTO THE VARIABLE AS IF IT\r\n;       WERE FOUND ON THE INITIAL SEARCH\r\n;\r\nNOTFDD:\r\n\tMOV\tAL,BYTE PTR VALTYP\t;GET VALTYP OF NEW VAR\r\n\tMOV\tBYTE PTR [BX],AL\t;PUT DOWN THE VARIABLE TYPE\r\n\tINC\tBX\r\n\tMOV\tDL,AL\r\n\tMOV\tDH,LOW 0\t;[D,E]=SIZE OF ONE VALUE (VALTYP)\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;[A]=NUMBER OF DIMENSIONS\r\n\tJNZ\tSHORT ??L012\r\n\tJMP\tPTRRNZ\t\t;CALLED BY CHAIN, JUST RETURN NON-ZERO\r\n??L012:\r\n\tMOV\tBYTE PTR [BX],CL\t;PUT DOWN THE DESCRIPTOR\r\n\tINC\tBX\r\n\tMOV\tBYTE PTR [BX],CH\r\n\tCALL\tNPUTSB\t\t;STORE THE EXTRA CHARACTERS IN THE TABLE\r\n\tINC\tBX\r\n\tMOV\tCL,AL\t\t;[C]=NUMBER OF TWO BYTE ENTRIES NEEDED\r\n\t\t\t\t;TO STORE THE SIZE OF EACH DIMENSION\r\n\tCALL\tGETSTK\t\t;GET SPACE FOR DIMENSION ENTRIES\r\n\tINC\tBX\t\t;SKIP OVER THE SIZE LOCATIONS\r\n\tINC\tBX\r\n\tMOV\tTEMP3,BX\t;SAVE THE LOCATION TO PUT THE SIZE\r\n\t\t\t\t;IN -- POINTS AT THE NUMBER OF DIMENSIONS\r\n\tMOV\tBYTE PTR [BX],CL\t;STORE THE NUMBER OF DIMENSIONS\r\n\tINC\tBX\r\n\tMOV\tAL,BYTE PTR DIMFLG\t;CALLED BY DIMENSION?\r\n\tRCL\tAL,1\t\t;SET CARRY IF SO\r\n\tMOV\tAL,CL\t\t;[A]=NUMBER OF DIMENSIONS\r\nLOPPTA:\r\n\tJB\tSHORT POPDIM\r\n\tLAHF\r\n\tPUSH\tAX\r\n\tMOV\tAL,BYTE PTR OPTVAL\t;GET THE OPTION BASE\r\n\tXOR\tAL,LOW 11\t;MAP 0 TO 11 AND 1 TO 10\r\n\tMOV\tCL,AL\t\t;[B,C]=DEFAULT DIMENSION\r\n\tMOV\tCH,LOW 0\r\n\tPOP\tAX\r\n\tSAHF\r\n\tJAE\tSHORT NOTDIM\t;DEFAULT DIMENSIONS TO TEN\r\nPOPDIM:\tPOP\tCX\t\t;POP OFF AN INDICE INTO [B,C]\r\n\tLAHF\r\n\tINC\tCX\t\t;ADD ONE TO IT FOR THE ZERO ENTRY\r\n\tSAHF\r\nNOTDIM:\tMOV\tBYTE PTR [BX],CL\t;PUT THE MAXIMUM DOWN\r\n\tLAHF\r\n\tPUSH\tAX\t\t;SAVE THE NUMBER OF DIMENSIONS AND\r\n\t\t\t\t;DIMFLG (CARRY)\r\n\tINC\tBX\r\n\tMOV\tBYTE PTR [BX],CH\r\n\tINC\tBX\r\n\tCALL\tUMULT\t\t;MULTIPLY [B,C]=NEWMAX BY CURTOL=[D,E]\r\n\tPOP\tAX\r\n\tSAHF\t\t\t;GET THE NUMBER OF DIMENSIONS AND\r\n\t\t\t\t;DIMFLG (CARRY) BACK\r\n\tDEC\tAL\t\t;DECREMENT THE NUMBER OF DIMENSIONS LEFT\r\n\tJNZ\tSHORT LOPPTA\t;HANDLE THE OTHER INDICES\r\n\tLAHF\r\n\tPUSH\tAX\t\t;SAVE DIMFLG (CARRY)\r\n\tMOV\tCH,DH\t\t;[B,C]=SIZE\r\n\tMOV\tCL,DL\r\n\tXCHG\tBX,DX\t\t;[D,E]=START OF VALUES\r\n\tADD\tBX,DX\t\t;[H,L]=END OF VALUES\r\n\tJAE\tSHORT ??L013\r\n\tJMP\tOMERR\t\t;OUT OF MEMORY POINTER BEING GENERATED?\r\n??L013:\r\n\tCALL\tREASON\t\t;SEE IF THERE IS ROOM FOR THE VALUES\r\n\tMOV\tSTREND,BX\t;UPDATE THE END OF STORAGE\r\nZERITA:\tDEC\tBX\t\t;ZERO THE NEW ARRAY\r\n\tMOV\tBYTE PTR [BX],LOW 0\r\n\tCMP\tBX,DX\t\t;BACK AT THE BEGINNING?\r\n\tJNZ\tSHORT ZERITA\t;NO, ZERO MORE\r\n\tXOR\tAL,AL\t\t;MAKE SURE [AL]=0\r\n\tINC\tCX\t\t;ADD ONE TO THE SIZE TO INCLUDE\r\n\t\t\t\t;THE BYTE FOR THE NUMBER OF DIMENSIONS\r\n\tMOV\tDH,AL\t\t;[D]=ZERO\r\n\tMOV\tBX,TEMP3\t;GET A POINTER AT THE NUMBER OF DIMENSIONS\r\n\tMOV\tDL,BYTE PTR [BX]\t;[E]=NUMBER OF DIMENSIONS\r\n\tXCHG\tBX,DX\t\t;[H,L]=NUMBER OF DIMENSIONS\r\n\tADD\tBX,BX\t\t;[H,L]=NUMBER OF DIMENSIONS TIMES TWO\r\n\tADD\tBX,CX\t\t;ADD ON THE SIZE\r\n\t\t\t\t;TO GET THE TOTAL NUMBER OF BYTES USED\r\n\tXCHG\tBX,DX\t\t;[D,E]=TOTAL SIZE\r\n\tDEC\tBX\t\t;BACK UP TO POINT TO LOCATION TO PUT\r\n\tDEC\tBX\t\t;THE SIZE OF THE ARRAY IN BYTES IN.\r\n\tMOV\t[BX],DX\r\n\tINC\tBX\r\n\tINC\tBX\t\t;PUT DOWN THE SIZE\r\n\tPOP\tAX\r\n\tSAHF\t\t\t;GET BACK DIMFLG (CARRY) AND SET [A]=0\r\n\tJB\tSHORT FINNOW\r\n;\r\n; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS\r\n; STRATEGY:\r\n;       NUMDIM=NUMBER OF DIMENSIONS\r\n;       CURTOL=0\r\n; INLPNM:GET A NEW INDICE\r\n;       POP NEW MAX INTO CURMAX\r\n;       MAKE SURE INDICE IS NOT TOO BIG\r\n;       MUTLIPLY CURTOL BY CURMAX\r\n;       ADD INDICE TO CURTOL\r\n;       NUMDIM=NUMDIM-1\r\n;       JNZ     INLPNM\r\n;       USE CURTOL*4 (VALTYP FOR EXTENDED) AS OFFSET\r\n;\r\nGETDEF:\tMOV\tCH,AL\t\t;[B,C]=CURTOL=ZERO\r\n\tMOV\tCL,AL\r\n\tMOV\tAL,BYTE PTR [BX]\t;[A]=NUMBER OF DIMENSIONS\r\n\tINC\tBX\t\t;POINT PAST THE NUMBER OF DIMENSIONS\r\n\tDB\t266O\t; SKIP\t;\"MVI D,\" AROUND THE NEXT BYTE\r\nINLPNM:\tPOP\tBX\t\t;[H,L]= POINTER INTO VARIABLE ENTRY\r\n\tMOV\tDX,[BX]\t\t;[D,E]=MAXIMUM FOR THE CURRENT INDICE\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;[H,L]=CURRENT INDICE\r\n\t\t\t\t;POINTER INTO THE VARIABLE GOES ON THE STACK\r\n\tPUSH\tAX\t\t;SAVE THE NUMBER OF DIMENSIONS\r\n\tCMP\tBX,DX\t\t;SEE IF THE CURRENT INDICE IS TOO BIG\r\n\tJNAE\tSHORT ??L014\r\n\tJMP\tBSERR\t\t;IF SO \"BAD SUBSCRIPT\" ERROR\r\n??L014:\r\n\tCALL\tUMULT\t\t;CURTOL=CURTOL*CURRENT MAXIMUM\r\n\tADD\tBX,DX\t\t;ADD THE INDICE TO CURTOL\r\n\tPOP\tAX\t\t;GET THE NUMBER OF DIMENSIONS IN [A]\r\n\tDEC\tAL\t\t;SEE IF ALL THE INDICES HAVE BEEN PROCESSED\r\n\tMOV\tCX,BX\t\t;[B,C]=CURTOL IN CASE WE LOOP BACK\r\n\tJNZ\tSHORT INLPNM\t;PROCESS THE REST OF THE INDICES\r\n\tMOV\tAL,BYTE PTR VALTYP\t;SEE HOW BIG THE VALUES ARE\r\n\t\t\t\t;AND MULTIPLY BY THAT SIZE\r\n\tMOV\tCX,BX\t\t;SAVE THE ORIGINAL VALUE FOR MULTIPLYING\r\n\t\t\t\t;BY THREE\r\n\tADD\tBX,BX\t\t;MULTIPLY BY TWO AT LEAST\r\n\tSUB\tAL,LOW 4\t;FOR INTEGERS AND STRINGS\r\n\t\t\t\t;NO MORE MULTIPLYING BY TWO\r\n\tJB\tSHORT SMLVAL\r\n\tADD\tBX,BX\t\t;NOW MULTIPLIED BY FOUR\r\n\tOR\tAL,AL\t\t;RE-GEN CONDITION CODES\r\n\tJZ\tSHORT DONMUL\t;IF SINGLE ALL DONE\r\n\tADD\tBX,BX\t\t;BY EIGHT FOR DOUBLES\r\nSMLVAL:\r\n\tOR\tAL,AL\t\t;FIX CC'S FOR Z-80\r\n\tJP\tSHORT ??L015\r\n\tJMP\tDONMUL\t\t;FOR STRINGS\r\n??L015:\r\n\tADD\tBX,CX\t\t;ADD IN THE ORIGINAL\r\nDONMUL:\r\n\tPOP\tCX\t\t;POP OFF THE ADDRESS OF WHERE THE VALUES\r\n\t\t\t\t;BEGIN\r\n\tADD\tBX,CX\t\t;ADD IT ONTO CURTOL TO GET THE\r\n\t\t\t\t;PLACE THE VALUE IS STORED\r\n\tXCHG\tBX,DX\t\t;RETURN THE POINTER IN [D,E]\r\nFINNOW:\tMOV\tBX,TEMP2\t;REGET THE TEXT POINTER\r\n\tRET\t\r\nPTRRNZ:\tSTC\t\t\t;RETURN WITH NON-ZERO IN [A]\r\n\tSBB\tAL,AL\t\t;AND CONDITION CODES SET\r\n\tPOP\tBX\t\t;RESTORE TEST POINTER\r\n\tRET\t\r\n\r\n;\r\n; LONG VARIABLE NAME SUBROUTINES. AFTER THE NORMAL 2 CHARACTER NAME\r\n; THE COUNT OF ADDITIONAL CHARACTERS IS STORED. FOLLOWING THIS\r\n; COMES THE CHARACTFRS IN ORDER WITH THE HIGH BIT TURNED ON SO A BACKWARD\r\n; SCAN IS POSSIBLE\r\n;\r\n\tPUBLIC\tIADAHL\r\nIADAHL:\tMOV\tAL,BYTE PTR [BX]\t;GET THE CHARACTER COUNT\r\n\tINC\tBX\r\nADDAHL:\tPUSH\tCX\t\t;ADD [A] TO [H,L]\r\n\tMOV\tCH,LOW 0\r\n\tMOV\tCL,AL\r\n\tADD\tBX,CX\r\n\tPOP\tCX\t\t;RESTORE THE SAVED [B,C]\r\n\tRET\t\r\nNPUTSB:\tPUSH\tCX\t\t;THIS ROUTINE STORE THE \"LONG\" NAME AT [H,L]\r\n\tPUSH\tDX\r\n\tLAHF\r\n\tPUSH\tAX\r\n\tMOV\tDX,OFFSET NAMCNT\t;POINT AT DATA TO SAVE\r\n\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;GET THE COUNT\r\n\tMOV\tCH,AL\r\n\tINC\tCH\t\t;[B]= NUMBER OF BYTES TO SAVE\r\nSLPLNG:\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;FETCH STORE VALUE\r\n\tINC\tDX\r\n\tINC\tBX\t\t;MOVE UP TO STORE NAME INTO TABLE\r\n\tMOV\tBYTE PTR [BX],AL\t;DO THE STORE\r\n\tDEC\tCH\t\t;AND REPEAT [B] TIMES\r\n\tJNZ\tSHORT SLPLNG\t;FOR THE COUNT AND DATA\r\n\tPOP\tAX\r\n\tSAHF\r\n\tPOP\tDX\r\n\tPOP\tCX\r\n\tRET\t\r\n\r\n\tPAGE\t\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "BISTRS.ASM",
          "type": "blob",
          "size": 33.75,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   BISTRS  BASIC Interpreter String  routines/WHG/PGA etc.\r\n\r\n\t.RADIX\t10\r\n\r\nTSHIBA=0\r\nPC8A=0\r\nZENITH=0\r\nALPCPM=0\r\nCAN8=0\r\nTRSHHC=0\r\nNECPPC=0\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t; Data Segment\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tARYTAB:WORD,DSCTMP:WORD,FRETOP:WORD,MEMSIZ:WORD\r\n\tEXTRN\tSTREND:WORD,TEMPPT:WORD,TEMPST:WORD,VALTYP:WORD,VARTAB:WORD\r\n\tEXTRN\tTEMP8:WORD,ARYTA2:WORD\r\n\tEXTRN\tTEMP9:WORD,PRMPRV:WORD\r\n\tEXTRN\tFACLO:WORD\r\nDSEG\tENDS\t\t\t; End of data segment externals\r\n\r\n\t\t\t\t; Code Segment ( terminated by END at bottom of file )\r\n\r\n\tEXTRN\tMOVRM:NEAR\r\n\tEXTRN\tBLTUC:NEAR,CONINT:NEAR,CRFIN:NEAR,ERRLS:NEAR,ERROR:NEAR\r\n\tEXTRN\tERRSO:NEAR,ERRST:NEAR\r\n\tEXTRN\tEVAL:NEAR,FCERR:NEAR,FOUT:NEAR,FRMEQL:NEAR,FRMEVL:NEAR\r\n\tEXTRN\tFRMPRN:NEAR\r\n\tEXTRN\tGETBYT:NEAR,OUTDO:NEAR,POPHRT:NEAR,PTRGET:NEAR,SIGNS:NEAR\r\n\tEXTRN\tSNERR:NEAR\r\n\tEXTRN\tTSTOP:NEAR,SNGFLT:NEAR,GIVDBL:NEAR,FIN:NEAR,CHKSTR:NEAR\r\n\r\n\tEXTRN\tIADAHL:NEAR\r\n\tEXTRN\tFINDBL:NEAR,GETBCD:NEAR,VMOVE:NEAR\r\n\tEXTRN\tGETYPR:NEAR\r\n\tEXTRN\tCHRGTR:NEAR,DCOMPR:NEAR,SYNCHR:NEAR\r\n\r\n\tPUBLIC\tSTRPRT,STROUI,LEN,FRESTR,STRCMP,VAL,STRLTI\r\n\tPUBLIC\tFRETMS,FRETMP,RIGHT$,LEFT$,GARBA2,STR$\r\n\tPUBLIC\tFRE,STRLIT,STRCPY,CAT,STRLT3,MID$\r\n\tPUBLIC\tSTRINI,STRIN1,STRAD1,PUTDEI,INCSTR\r\n\r\n\tPUBLIC\tLHSMID\r\n\r\n;\r\n; THE FOLLOWING ROUTINE COMPARES TWO STRINGS\r\n; ONE WITH DESC IN [D,E] OTHER WITH DESC. IN [FACLO, FACLO+1]\r\n; A=0 IF STRINGS EQUAL\r\n; A=377 IF B,C,D,E .GT. FACLO\r\n; A=1 IF B,C,D,E .LT. FACLO\r\n;\r\nSTRCMP:\tCALL\tFRESTR\t\t;FREE UP THE FAC STRING, AND GET THE\r\n\t\t\t\t;POINTER TO THE FAC DESCRIPTOR IN [H,L]\r\n\tMOV\tAL,BYTE PTR [BX]\t;SAVE THE LENGTH OF THE FAC STRING IN [A]\r\n\tINC\tBX\r\n\tMOV\tCL,BYTE PTR [BX]\t;SAVE THE POINTER AT THE FAC STRING\r\n\t\t\t\t;DATA IN [B,C]\r\n\tINC\tBX\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tPOP\tDX\t\t;GET THE STACK STRING POINTER\r\n\tPUSH\tCX\t\t;SAVE THE POINTER AT THE FAC STRING DATA\r\n\tPUSH\tAX\t\t;SAVE THE FAC STRING LENGTH\r\n\tCALL\tFRETMP\t\t;FREE UP THE STACK STRING AND RETURN\r\n\t\t\t\t;THE POINTER TO THE STACK STRING DESCRIPTOR\r\n\t\t\t\t;IN [H,L]\r\n\tPOP\tAX\t\t;GET BACK LENGTH OF STRING\r\n\tMOV\tDH,AL\t\t;[D]=LENGTH OF FAC STRING\r\n\tMOV\tDL,BYTE PTR [BX]\t;[E]=LENGTH OF STACK STRING\r\n\tINC\tBX\r\n\tMOV\tCL,BYTE PTR [BX]\t;[B,C]=POINTER AT STACK STRING\r\n\tINC\tBX\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tPOP\tBX\t\t;GET BACK 2ND CHARACTER POINTER\r\nCSLOOP:\tMOV\tAL,DL\t\t;BOTH STRINGS ENDED\r\n\tOR\tAL,DH\t\t;TEST BY OR'ING THE LENGTHS TOGETHER\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF SO, RETURN WITH A ZERO\r\n\tMOV\tAL,DH\t\t;GET FACLO STRING LENGTH\r\n\tSUB\tAL,LOW 1\t;SET CARRY AND MAKE [A]=255 IF [D]=0\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;RETURN IF THAT STRING ENDED\r\n\tXOR\tAL,AL\t\t;MUST NOT HAVE BEEN ZERO, TEST CASE\r\n\tCMP\tAL,DL\t\t;OF B,C,D,E STRING HAVING ENDED FIRST\r\n\tINC\tAL\t\t;RETURN WITH A=1\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;TEST THE CONDITION\r\n;HERE WHEN NEITHER STRING ENDED\r\n\tDEC\tDH\t\t;DECREMENT BOTH CHARACTER COUNTS\r\n\tDEC\tDL\r\n\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\t\t;GET CHARACTER FROM B,C,D,E STRING\r\n\tINC\tCX\r\n\tCMP\tAL,BYTE PTR [BX]\t;COMPARE WITH FACLO STRING\r\n\tLAHF\r\n\tINC\tBX\t\t;BUMP POINTERS (INX DOESNT CLOBBER CC'S)\r\n\tSAHF\r\n\tJZ\tSHORT CSLOOP\t;IF BOTH THE SAME, MUST BE MORE TO STRINGS\r\n\tCMC\t\t\t;HERE WHEN STRINGS DIFFER\r\n\tJMP\tSIGNS\t\t;SET [A] ACCORDING TO CARRY\r\n\tSUBTTL  STRING FUNCTIONS\r\n\tEXTRN\tFOUTO:NEAR,FOUTH:NEAR\r\n\tPUBLIC\tSTRO$,STRH$\r\n; THE STRO$ FUNCTION TAKES A NUMBER AND GIVES\r\n; A STRING WITH THE CHARACTERS THE NUMBER WOULD GIVE IF\r\n; OUTPUT IN OCTAL\r\n;\r\nSTRO$:\tCALL\tFOUTO\t\t;PUT OCTAL NUMBER IN FBUFFR\r\n\tJMP\tSHORT STR$1\t;JUMP INTO STR$ CODE\r\n\r\n; STRH$ SAME AS STRO$ EXCEPT USES HEX INSTEAD OF OCTAL\r\nSTRH$:\tCALL\tFOUTH\t\t;PUT HEX NUMBER IN FBUFFR\r\n\tJMP\tSHORT STR$1\t;JUMP INTO STR$ CODE\r\n;\r\n; THE STR$ FUNCTION TAKES A NUMBER AND GIVES\r\n; A STRING WITH THE CHARACTERS THE OUTPUT OF THE NUMBER\r\n; WOULD HAVE GIVEN\r\n;\r\nSTR$:\r\n\t\t\t\t;IS A NUMERIC\r\n\tCALL\tFOUT\t\t;DO ITS OUTPUT\r\nSTR$1:\tCALL\tSTRLIT\t\t;SCAN IT AND TURN IT INTO A STRING\r\n\tCALL\tFREFAC\t\t;FREE UP THE TEMP\r\n\tMOV\tCX,OFFSET FINBCK\r\n\tPUSH\tCX\t\t;SET UP ANSWER IN NEW TEMP\r\n;\r\n; STRCPY CREATES A COPY OF THE STRING\r\n; WHOSE DESCRIPTOR IS POINTED TO BY [H,L].\r\n; ON RETURN [D,E] POINTS TO DSCTMP\r\n; WHICH HAS THE STRING INFO (LENGTH,WHERE COPIED TO)\r\n;\r\nSTRCPY:\tMOV\tAL,BYTE PTR [BX]\t;GET LENGTH\r\n\tINC\tBX\t\t;MOVE UP TO THE POINTER\r\n\tPUSH\tBX\t\t;GET POINTER TO POINTER OF ARG\r\n\tCALL\tGETSPA\t\t;GET THE SPACE\r\n\tPOP\tBX\t\t;FIND OUT WHERE STRING TO COPY\r\n\tMOV\tCL,BYTE PTR [BX]\r\n\tINC\tBX\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tCALL\tSTRAD2\t\t;SETUP DSCTMP\r\n\tPUSH\tBX\t\t;SAVE POINTER TO DSCTMP\r\n\tMOV\tBL,AL\t\t;GET CHARACTER COUNT INTO [L]\r\n\tCALL\tMOVSTR\t\t;MOVE THE CHARS IN\r\n\tPOP\tDX\t\t;RESTORE POINTER TO DSCTMP\r\n\tRET\t\t\t;RETURN\r\n\r\nSTRIN1:\tMOV\tAL,LOW 1\t;MAKE ONE CHAR STRING (CHR$, INKEY$)\r\nSTRINI:\tCALL\tGETSPA\t\t;GET SOME STRING SPACE ([A] CHARS)\r\nSTRAD2:\tMOV\tBX,OFFSET DSCTMP\t;GET DESC. TEMP\r\nSTRAD1:\tPUSH\tBX\t\t;SAVE DESC. POINTER\r\n\tMOV\tBYTE PTR [BX],AL\t;SAVE CHARACTER COUNT\r\nPUTDEI:\tINC\tBX\t\t;STORE [D,E]=POINTER TO FREE SPACE\r\n\tMOV\t[BX],DX\r\n\tPOP\tBX\t\t;AND RESTORE [H,L] AS THE DESCRIPTOR POINTER\r\n\tRET\t\r\n;\r\n; STRLT2 TAKES THE STRING LITERAL WHOSE FIRST CHARACTER\r\n; IS POINTED BY [H,L]+1 AND BUILDS A DESCRIPTOR FOR IT.\r\n; THE DESCRIPTOR IS INITIALLY BUILT IN DSCTMP, BUT PUTNEW\r\n; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER\r\n; AT THE TEMPORARY IN FACLO. THE CHARACTERS OTHER THAN\r\n; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN [B]\r\n; AND [D]. IT THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED\r\n; OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE CALL. ON RETURN\r\n; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO\r\n; BY [H,L] AND IS IN [A], BUT THE CONDITION CODES ARE\r\n; NOT SET UP.\r\n;\r\n\tPUBLIC\tSTRLT2\r\nSTRLIT:\tDEC\tBX\r\nSTRLTI:\tMOV\tCH,LOW 34\t;ASSUME STR ENDS ON QUOTE\r\nSTRLT3:\tMOV\tDH,CH\r\nSTRLT2:\tPUSH\tBX\t\t;SAVE POINTER TO START OF LITERAL\r\n\tMOV\tCL,LOW 255\t;INITIALIZE CHARACTER COUNT\r\nSTRGET:\tINC\tBX\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR\r\n\tINC\tCL\t\t;BUMP CHARACTER COUNT\r\n\tOR\tAL,AL\t\t;IF 0, (END OF LINE) DONE\r\n\tJZ\tSHORT STRFIN\t;TEST\r\n\tCMP\tAL,DH\r\n\tJZ\tSHORT STRFIN\r\n\tCMP\tAL,CH\t\t;CLOSING QUOTE\r\n\tJNZ\tSHORT STRGET\t;NO, GO BACK FOR MORE\r\nSTRFIN:\tCMP\tAL,LOW 34\t;IF QUOTE TERMINATES THE STRING\r\n\tJNZ\tSHORT ??L000\r\n\tCALL\tCHRGTR\t\t;SKIP OVER THE QUOTE\r\n??L000:\r\n\tPUSH\tBX\t\t;SAVE POINTER AT END OF STRING\r\n\tMOV\tAL,CH\t\t;WERE WE SCANNING AN UNQUOTED STRING?\r\n\tCMP\tAL,LOW 44\r\n\tJNZ\tSHORT NTTRLS\t;IF NOT, DON'T SUPPRESS TRAILING SPACES\r\n\tINC\tCL\t\t;FIX [C] WHICH IS THE CHARACTER COUNT\r\nLPTRLS:\tDEC\tCL\t\t;DECREMENT UNTIL WE FIND A NON-SPACE CHARACTER\r\n\tJZ\tSHORT NTTRLS\t;DON'T GO PAST START (ALL SPACES)\r\n\tDEC\tBX\t\t;LOOK AT PREVIOUS CHARACTER\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tCMP\tAL,LOW \" \"\r\n\tJZ\tSHORT LPTRLS\t;IF SO CONTINUE LOOKING\r\nNTTRLS:\tPOP\tBX\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\r\n\tINC\tBX\r\n\tXCHG\tBX,DX\t\t;GET POINTER TO TEMP\r\n\tMOV\tAL,CL\t\t;GET CHARACTER COUNT IN A\r\n\tCALL\tSTRAD2\t\t;SAVE STR INFO\r\n;\r\n; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP\r\n; WE WANT TO SETUP A TEMP DESCRIPTOR WITH DCSTMP IN IT\r\n; PUT A POINTER TO THE DESCRIPTOR IN FACLO AND FLAG THE \r\n; RESULT AS TYPE STRING\r\n;\r\n\tPUBLIC\tPUTNEW\r\nPUTNEW:\tMOV\tDX,OFFSET DSCTMP\t;[D,E] POINT AT RESULT DESCRIPTOR\r\n\tPUBLIC\tPUTTMP\r\n\tDB\t260O\t; SKIP\t;SKIP THE NEXT BYTE (\"MVI AL,\")\r\nPUTTMP:\tPUSH\tDX\t\t;SAVE A POINTER TO THE START OF THE STRING\r\n\tMOV\tBX,TEMPPT\t;[H,L]=POINTER TO FIRST FREE TEMP\r\n\tMOV\tFACLO,BX\t;POINTER AT WHERE RESULT DESCRIPTOR WILL BE\r\n\tMOV\tAL,LOW 3\r\n\tMOV\tBYTE PTR VALTYP,AL\t;FLAG THIS AS A STRING\r\n\tCALL\tVMOVE\t\t;AND MOVE THE VALUE INTO A TEMPORARY\r\n\tMOV\tDX,OFFSET DSCTMP+3\t;IF THE CALL IS TO PUTTMP, [D,E]\r\n\t\t\t\t;WILL NOT EQUAL DSCTMP +3\r\n\tCMP\tBX,DX\t\t;DSCTMP IS JUST BEYOND THE TEMPS\r\n\t\t\t\t;AND IF TEMPPT POINTS AT IT THERE\r\n\t\t\t\t;ARE NO FREE TEMPS\r\n\tMOV\tTEMPPT,BX\t;SAVE NEW TEMPORARY POINTER\r\n\tPOP\tBX\t\t;GET THE TEXT POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CURRENT CHARACTER INTO [A]\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tMOV\tDX,OFFSET ERRST\t;\"STRING TEMPORARY\" ERROR\r\n\tJMP\tERROR\t\t;GO TELL HIM\r\n;\r\n; PRINT THE STRING POINTED TO BY [H,L] WHICH ENDS WITH A ZERO\r\n; IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE\r\n;\r\nSTROUI:\tINC\tBX\t\t;POINT AT NEXT CHARACTER\r\n\tPUBLIC\tDSOUT\r\nDSOUT:\t\t\t\t;PRINT FROM THE DATA SEGMENT\r\n\tCALL\tSTRLIT\t\t;GET A STRING LITERAL\r\n;\r\n; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACLO.\r\n;\r\nSTRPRT:\tCALL\tFREFAC\t\t;RETURN TEMP POINTER BY FACLO\r\n\tCALL\tGETBCD\t\t;[D]=LENGTH [B,C]=POINTER AT DATA\r\n\tINC\tDH\t\t;INCREMENT AND DECREMENT EARLY\r\n\t\t\t\t;TO CHECK FOR NULL STRING\r\nSTRPR2:\tDEC\tDH\t\t;DECREMENT THE LENGTH\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;ALL DONE\r\n\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\t\t;GET CHARACTER TO PRINT\r\n\tCALL\tOUTDO\r\n\tCMP\tAL,LOW 13\r\n\tJNZ\tSHORT ??L001\r\n\tCALL\tCRFIN\r\n??L001:\r\n\tINC\tCX\t\t;POINT TO THE NEXT CHARACTER\r\n\tJMP\tSHORT STRPR2\t;AND PRINT IT...\r\n\tPAGE\t\r\n\tSUBTTL  STRING GARBAGE COLLECTION - GETSPA, GARBAG\r\n;\r\n; GETSPA - GET SPACE FOR CHARACTER STRING\r\n; MAY FORCE GARBAGE COLLECTION.\r\n;\r\n; # OF CHARS (BYTES) IN [A]\r\n; RETURNS WITH POINTER IN [D,E] OTHERWISE IF CANT GET SPACE\r\n; BLOWS OFF TO \"OUT OF STRING SPACE\" TYPE ERROR.\r\n;\r\n\tPUBLIC\tGETSPA\r\nGETSPA:\tOR\tAL,AL\t\t;MUST BE NON ZERO. SIGNAL NO GARBAG YET\r\n\tJMP\tSHORT TRYGI3\r\nTRYGI2:\tPOP\tAX\r\n\tSAHF\t\t\t;IN CASE COLLECTED WHAT WAS LENGTH?\r\nTRYGI3:\r\n\tLAHF\r\n\tPUSH\tAX\t\t;SAVE IT BACK\r\n\tMOV\tBX,STREND\r\n\tXCHG\tBX,DX\t\t;IN [D,E]\r\n\tMOV\tBX,FRETOP\t;GET TOP OF FREE SPACE IN [H,L]\r\n\tNOT\tAL\t\t;-# OF CHARS\r\n\tMOV\tCL,AL\t\t;IN [B,C]\r\n\tMOV\tCH,LOW 255\r\n\tADD\tBX,CX\t\t;SUBTRACT FROM TOP OF FREE\r\n\tINC\tBX\r\n\tCMP\tBX,DX\t\t;COMPARE THE TWO\r\n\tJB\tSHORT GARBAG\t;NOT ENOUGH ROOM FOR STRING, OFFAL TIME\r\n\tMOV\tFRETOP,BX\t;SAVE NEW BOTTOM OF MEMORY\r\n\tINC\tBX\t\t;MOVE BACK TO POINT TO STRING\r\n\tXCHG\tBX,DX\t\t;RETURN WITH POINTER IN [D,E]\r\n\tPOP\tAX\r\n\tSAHF\r\n\tRET\t\r\n\tPUBLIC\tPPSWRT\r\nPPSWRT:\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;GET CHARACTER COUNT\r\n\tRET\t\t\t;RETURN FROM GETSPA\r\n\r\nGARBAG:\r\n\tPOP\tAX\r\n\tSAHF\t\t\t;HAVE WE COLLECTED BEFORE?\r\n\tMOV\tDX,OFFSET ERRSO\t;GET READY FOR OUT OF STRING SPACE ERROR\r\n\tJNZ\tSHORT ??L002\r\n\tJMP\tERROR\t\t;GO TELL USER HE LOST\r\n??L002:\r\n\tCMP\tAL,AL\t\t;SET ZERO FLAG TO SAY WEVE GARBAGED\r\n\tLAHF\r\n\tPUSH\tAX\t\t;SAVE FLAG BACK ON STACK\r\n\tMOV\tCX,OFFSET TRYGI2\t;PLACE FOR GARBAG TO RETURN TO.\r\n\tPUSH\tCX\t\t;SAVE ON STACK\r\nGARBA2:\r\n\tMOV\tBX,MEMSIZ\t;START FROM TOP DOWN\r\nFNDVAR:\tMOV\tFRETOP,BX\t;LIKE SO\r\n\tMOV\tBX,0\t\t;GET DOUBLE ZERO\r\n\tPUSH\tBX\t\t;SAY DIDNT SEE VARS THIS PASS\r\n\tMOV\tBX,STREND\t;FORCE DVARS TO IGNORE STRINGS\r\n\t\t\t\t;IN THE PROGRAM TEXT (LITERALS, DATA)\r\n\tPUSH\tBX\t\t;FORCE FIND HIGH ADDRESS\r\n\tMOV\tBX,OFFSET TEMPST\t;GET START OF STRING TEMPS\r\nTVAR:\tMOV\tDX,TEMPPT\t;SEE IF DONE\r\n\tCMP\tBX,DX\t\t;TEST\r\n\tMOV\tCX,OFFSET TVAR\t;FORCE JUMP TO TVAR\r\n\tJZ\tSHORT ??L003\r\n\tJMP\tDVAR2\t\t;DO TEMP VAR GARBAGE COLLECT\r\n??L003:\r\n\r\n\tMOV\tBX,OFFSET PRMPRV\t;SETUP ITERATION FOR PARAMETER BLOCKS\r\n\tMOV\tTEMP9,BX\r\n\tMOV\tBX,ARYTAB\t;GET STOPPING POINT IN [H,L]\r\n\tMOV\tARYTA2,BX\t;STORE IN STOP LOCATION\r\n\tMOV\tBX,VARTAB\t;GET STARTING POINT IN [H,L]\r\nSVAR:\tMOV\tDX,ARYTA2\t;GET STOPPING LOCATION\r\n\tCMP\tBX,DX\t\t;SEE IF AT END OF SIMPS\r\n\tJZ\tSHORT ARYVAR\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET VALTYP\r\n\tINC\tBX\t\t;BUMP POINTER TWICE\r\n\tINC\tBX\t\t;\r\n\tINC\tBX\t\t;POINT AT THE VALUE\r\n\tPUSH\tAX\t\t;SAVE VALTYP\r\n\tCALL\tIADAHL\t\t;AND SKIP OVER EXTRA CHARACTERS AND COUNT\r\n\tPOP\tAX\r\n\tCMP\tAL,LOW 3\t;SEE IF ITS A STRING\r\n\tJNZ\tSHORT SKPVAR\t;IF NOT, JUST SKIP AROUND IT\r\n\tCALL\tDVARS\t\t;COLLECT IT\r\n\tXOR\tAL,AL\t\t;AND DON'T SKIP ANYTHING MORE\r\nSKPVAR:\tMOV\tDL,AL\r\n\tMOV\tDH,LOW 0\t;[D,E]=AMOUNT TO SKIP\r\n\tADD\tBX,DX\r\n\tJMP\tSHORT SVAR\t;GET NEXT ONE\r\nARYVAR:\tMOV\tBX,TEMP9\t;GET LINK IN PARAMETER BLOCK CHAIN\r\n\tMOV\tDX,[BX]\t\t;GO BACK ONE LEVEL\r\n\tOR\tDX,DX\t\t;WAS THAT THE END?\r\n\tMOV\tBX,ARYTAB\t;SETUP TO START ARRAYS\r\n\tJZ\tSHORT ARYVA4\t;OTHERWISE GARBAGE COLLECT ARRAYS\r\n\tXCHG\tBX,DX\r\n\tMOV\tTEMP9,BX\t;SETUP NEXT LINK IN CHAIN FOR ITERATION\r\n\tINC\tBX\t\t;SKIP CHAIN POINTER\r\n\tINC\tBX\r\n\tMOV\tDX,[BX]\t\t;PICK UP THE LENGTH\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tXCHG\tBX,DX\t\t;SET [D,E]= ACTUAL END ADDRESS BY\r\n\tADD\tBX,DX\t\t;ADDING BASE TO LENGTH\r\n\tMOV\tARYTA2,BX\t;SET UP STOP LOCATION\r\n\tXCHG\tBX,DX\r\n\tJMP\tSHORT SVAR\r\n\r\nARYVA2:\tPOP\tCX\t\t;GET RID OF STACK GARBAGE\r\nARYVA4:\tMOV\tDX,STREND\t;GET END OF ARRAYS\r\n\tCMP\tBX,DX\t\t;SEE IF DONE WITH ARRAYS\r\n\tJNZ\tSHORT ??L004\r\n\tJMP\tGRBPAS\t\t;YES, SEE IF DONE COLLECTING\r\n??L004:\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE VALUE TYPE INTO [A]\r\n\tINC\tBX\r\n\tPUSH\tAX\t\t;SAVE THE VALTYP\r\n\tINC\tBX\t\t;SKIP THE NAME CHARACTERS\r\n\tINC\tBX\r\n\tCALL\tIADAHL\t\t;SKIP THE EXTRA CHARACTERS\r\n\tMOV\tCL,BYTE PTR [BX]\t;PICK UP THE LENGTH\r\n\tINC\tBX\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tINC\tBX\r\n\tPOP\tAX\t\t;RESTORE THE VALTYP\r\n\tPUSH\tBX\t\t;SAVE POINTER TO DIMS\r\n\tADD\tBX,CX\t\t;ADD TO CURRENT POINTER POSITION\r\n\tCMP\tAL,LOW 3\t;SEE IF ITS A STRING\r\n\tJNZ\tSHORT ARYVA2\t;IF NOT JUST SKIP IT\r\n\tMOV\tTEMP8,BX\t;SAVE END OF ARRAY\r\n\tPOP\tBX\t\t;GET BACK CURRENT POSITION\r\n\tMOV\tCL,BYTE PTR [BX]\t;PICK UP NUMBER OF DIMS\r\n\tMOV\tCH,LOW 0\t;MAKE DOUBLE WITH HIGH ZERO\r\n\tADD\tBX,CX\t\t;GO PAST DIMS\r\n\tADD\tBX,CX\t\t;BY ADDING ON TWICE #DIMS (2 BYTE GUYS)\r\n\tINC\tBX\t\t;ONE MORE TO ACCOUNT FOR #DIMS.\r\nARYSTR:\tXCHG\tBX,DX\t\t;SAVE CURRENT POSIT IN [D,E]\r\n\tMOV\tBX,TEMP8\t;GET END OF ARRAY\r\n\tXCHG\tBX,DX\t\t;FIX [H,L] BACK TO CURRENT\r\n\tCMP\tBX,DX\t\t;SEE IF AT END OF ARRAY\r\n\tJZ\tSHORT ARYVA4\t;END OF ARRAY, TRY NEXT ARRAY\r\n\tMOV\tCX,OFFSET ARYSTR\t;ADDR OF WHERE TO RETURN TO\r\nDVAR2:\tPUSH\tCX\t\t;GOES ON STACK\r\nDVAR:\r\nDVARS:\tXOR\tAL,AL\r\n\tOR\tAL,BYTE PTR [BX]\t;SEE IF ITS THE NULL STRING\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tDL,BYTE PTR [BX]\r\n\tLAHF\r\n\tINC\tBX\r\n\tSAHF\r\n\tMOV\tDH,BYTE PTR [BX]\r\n\tLAHF\r\n\tINC\tBX\t\t;[D,E]=POINTER AT THE VALUE\r\n\tSAHF\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;NULL STRING, RETURN\r\n\tMOV\tCX,BX\t\t;MOVE [H,L] TO [B,C]\r\n\tMOV\tBX,FRETOP\t;GET POINTER TO TOP OF STRING FREE SPACE\r\n\tCMP\tBX,DX\t\t;IS THIS STRINGS POINTER .LT. FRETOP\r\n\tMOV\tBX,CX\t\t;MOVE [B,C] BACK TO [H,L]\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;IF NOT, NO NEED TO MESS WITH IT FURTHUR\r\n\tPOP\tBX\t\t;GET RETURN ADDRESS OFF STACK\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;GET MAX SEEN SO FAR & SAVE RETURN ADDRESS\r\n\tCMP\tBX,DX\t\t;LETS SEE\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE MAX SEEN & GET RETURN ADDRESS OFF STACK\r\n\tPUSH\tBX\t\t;SAVE RETURN ADDRESS BACK\r\n\tMOV\tBX,CX\t\t;MOVE [B,C] BACK TO [H,L]\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;IF NOT, LETS LOOK AT NEXT VAR\r\n\tPOP\tCX\t\t;GET RETURN ADDR OFF STACK\r\n\tPOP\tAX\t\t;POP OFF MAX SEEN\r\n\tPOP\tAX\t\t;AND VARIABLE POINTER\r\n\tPUSH\tBX\t\t;SAVE NEW VARIABLE POINTER\r\n\tPUSH\tDX\t\t;AND NEW MAX POINTER\r\n\tPUSH\tCX\t\t;SAVE RETURN ADDRESS BACK\r\n\tRET\t\t\t;AND RETURN\r\n;\r\n; HERE WHEN MADE ONE COMPLETE PASS THRU STRING VARS\r\n;\r\nGRBPAS:\tPOP\tDX\t\t;POP OFF MAX POINTER\r\n\tPOP\tBX\t\t;AND GET VARIABLE POINTER\r\n\tOR\tBX,BX\t\t;SEE IF ZERO POINTER\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF END OF COLLECTION,\r\n\t\t\t\t;THEN MAYBE RETURN TO GETSPA\r\n\tDEC\tBX\t\t;CURRENTLY JUST PAST THE DESCRIPTOR\r\n\tMOV\tCH,BYTE PTR [BX]\t;[B]=HIGH BYTE OF DATA POINTER\r\n\tDEC\tBX\r\n\tMOV\tCL,BYTE PTR [BX]\t;[B,C]=POINTER AT STRING DATA\r\n\tPUSH\tBX\t\t;SAVE THIS LOCATION SO THE POINTER\r\n\t\t\t\t;CAN BE UPDATED AFTER THE STRING IS\r\n\t\t\t\t;MOVED\r\n\tDEC\tBX\r\n\tMOV\tBL,BYTE PTR [BX]\t;[L]=STRING LENGTH\r\n\tMOV\tBH,LOW 0\t;[H,L] GET CHARACTER COUNT\r\n\tADD\tBX,CX\t\t;[H,L]=POINTER BEYOND STRING\r\n\tMOV\tDH,CH\r\n\tMOV\tDL,CL\t\t;[D,E]=ORIGINAL POINTER\r\n\tDEC\tBX\t\t;DON'T MOVE ONE BEYOND STRING\r\n\tMOV\tCX,BX\t\t;GET TOP OF STRING IN [B,C]\r\n\tMOV\tBX,FRETOP\t;GET TOP OF FREE SPACE\r\n\tCALL\tBLTUC\t\t;MOVE STRING\r\n\tPOP\tBX\t\t;GET BACK POINTER TO DESC.\r\n\tMOV\tBYTE PTR [BX],CL\t;SAVE FIXED ADDR\r\n\tINC\tBX\t\t;MOVE POINTER\r\n\tMOV\tBYTE PTR [BX],CH\t;HIGH PART\r\n\tMOV\tBX,CX\t\t;[H,L]=NEW POINTER\r\n\tDEC\tBX\t\t;FIX UP FRETOP\r\n\tJMP\tFNDVAR\t\t;AND TRY TO FIND HIGH AGAIN\r\n\r\n\tPAGE\t\r\n\tSUBTTL  STRING CONCATENATION\r\n;\r\n; THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS\r\n; THE FACLO CONTAINS THE FIRST ONE AT THIS POINT,\r\n; [H,L] POINTS BEYOND THE + SIGN AFTER IT\r\n;\r\nCAT:\tPUSH\tCX\t\t;PUT OLD PRECEDENCE BACK ON\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tMOV\tBX,FACLO\t;GET POINTER TO STRING DESC.\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE ON STACK & GET TEXT POINTER BACK\r\n\tCALL\tEVAL\t\t;EVALUATE REST OF FORMULA\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE TEXT POINTER, GET BACK DESC.\r\n\tCALL\tCHKSTR\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tPUSH\tBX\t\t;SAVE DESC. POINTER.\r\n\tMOV\tBX,FACLO\t;GET POINTER TO 2ND DESC.\r\n\tPUSH\tBX\t\t;SAVE IT\r\n\tADD\tAL,BYTE PTR [BX]\t;ADD TWO LENGTHS TOGETHER\r\n\tMOV\tDX,OFFSET ERRLS\t;SEE IF RESULT .LT. 256\r\n\tJAE\tSHORT ??L005\r\n\tJMP\tERROR\t\t;ERROR \"LONG STRING\"\r\n??L005:\r\n\tCALL\tSTRINI\t\t;GET INITIAL STRING\r\n\tPOP\tDX\t\t;GET 2ND DESC.\r\n\tCALL\tFRETMP\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE POINTER TO IT\r\n\tCALL\tFRETM2\t\t;FREE UP 1ST TEMP\r\n\tPUSH\tBX\t\t;SAVE DESC. POINTER (FIRST)\r\n\tINCSTR=2\r\n\tINCSTR=1\r\n\tMOV\tBX,DSCTMP+INCSTR\t;GET POINTER TO FIRST\r\n\tXCHG\tBX,DX\t\t;IN [D,E]\r\n\tCALL\tMOVINS\t\t;MOVE IN THE FIRST STRING\r\n\tCALL\tMOVINS\t\t;AND THE SECOND\r\n\tMOV\tBX,OFFSET TSTOP\t;CAT REENTERS FORMULA EVALUATION AT TSTOP\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\r\n\tPUSH\tBX\t\t;TEXT POINTER OFF FIRST\r\n\tJMP\tPUTNEW\t\t;THEN RETURN ADDRESS OF TSTOP\r\n\r\n\r\nMOVINS:\tPOP\tBX\t\t;GET RETURN ADDR\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT BACK, BUT GET DESC.\r\n\tMOV\tAL,BYTE PTR [BX]\t;[A]=STRING LENGTH\r\n\tINC\tBX\r\n\tMOV\tCL,BYTE PTR [BX]\t;[B,C]=POINTER AT STRING DATA\r\n\tINC\tBX\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tMOV\tBL,AL\t\t;[L]=STRING LENGTH\r\nMOVSTR:\tINC\tBL\r\nMOVLP:\tDEC\tBL\t\t;SET CC'S\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;0, NO BYTE TO MOVE\r\n\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\t\t;GET CHAR\r\n\tMOV\tDI,DX\r\n\tSTOSB\t\t\t;SAVE IT\r\n\tINC\tCX\t\t;MOVE POINTERS\r\n\tINC\tDX\r\n\tJMP\tSHORT MOVLP\t;KEEP DOING IT\r\n\tPAGE\t\r\n\tSUBTTL  FREE UP STRING TEMPORARY - FRESTR, FREFAC, FRETMP, FRETMS\r\n;\r\n; FRETMP IS PASSED A POINTER TO A STRING DESCRIPTOR IN [D,E]\r\n; THIS VALUE IS RETURNED IN [H,L]. ALL THE OTHER REGISTERS ARE MODIFIED.\r\n; A CHECK TO IS MADE TO SEE IF THE STRING DESCRIPTOR [D,E] POINTS\r\n; TO IS THE LAST TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.\r\n; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF TEMPPT.\r\n; IF A TEMPORARY IS FREED UP, A FURTHER CHECK IS MADE TO SEE IF THE\r\n; STRING DATA THAT THAT STRING TEMPORARY POINTED TO IS THE\r\n; THE LOWEST PART OF STRING SPACE IN USE.\r\n; IF SO, FRETMP IS UPDATED TO REFLECT THE FACT THAT THAT SPACE IS NO\r\n; LONGER IN USE.\r\n;\r\n\tPUBLIC\tFREFAC\r\nFRESTR:\tCALL\tCHKSTR\t\t;MAKE SURE ITS A STRING\r\nFREFAC:\tMOV\tBX,FACLO\r\n\tPUBLIC\tFRETM2\r\nFRETM2:\tXCHG\tBX,DX\t\t;FREE UP THE TEMP IN THE FACLO\r\nFRETMP:\tCALL\tFRETMS\t\t;FREE UP THE TEMPORARY\r\n\tXCHG\tBX,DX\t\t;PUT THE STRING POINTER INTO [H,L]\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tPUSH\tDX\t\t;SAVE [D,E] TO RETURN IN [H,L]\r\n\tMOV\tDH,CH\t\t;[D,E]=POINTER AT STRING\r\n\tMOV\tDL,CL\r\n\tDEC\tDX\t\t;SUBTRACT ONE\r\n\tMOV\tCL,BYTE PTR [BX]\t;[C]=LENGTH OF THE STRING FREED UP\r\n\tMOV\tBX,FRETOP\t;SEE IF ITS THE FIRST \r\n\t\t\t\t;ONE IN STRING SPACE\r\n\tCMP\tBX,DX\r\n\tJNZ\tSHORT NOTLST\t;NO SO DON'T ADD\r\n\tXOR\tAL,AL\t\t;MUST EXPLICITLY ZERO A\r\n\tMOV\tCH,AL\t\t;MAKE [B]=0\r\n\tADD\tBX,CX\t\t;ADD\r\n\tMOV\tFRETOP,BX\t;AND UPDATE FRETOP\r\nNOTLST:\tPOP\tBX\t\t;GET POINTER AT CURRENT DESCRIPTOR\r\n\tRET\t\r\nFRETMS:\r\n\tMOV\tBX,TEMPPT\t;GET TEMP POINTER\r\n\tDEC\tBX\t\t;LOOK AT WHAT IS IN THE LAST TEMP\r\n\tMOV\tCH,BYTE PTR [BX]\t;[B,C]=POINTER AT STRING\r\n\tDEC\tBX\t\t;DECREMENT TEMPPT BY STRSIZ\r\n\tMOV\tCL,BYTE PTR [BX]\r\n\tDEC\tBX\r\n\tCMP\tBX,DX\t\t;SEE IF [D,E] POINT AT THE LAST \r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;RETURN NOW IF NOW FREEING DONE\r\n\tMOV\tTEMPPT,BX\t;UPDATE THE TEMP POINTER SINCE\r\n\t\t\t\t;ITS BEEN DECREMENTED BY 4\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL STRING FUNCTIONS - LEN, ASC, CHR$\r\n;\r\n; THE FUNCTION LEN($) RETURNS THE LENGTH OF THE\r\n; STRING PASSED AS AN ARGUMENT\r\n;\r\nLEN:\tMOV\tCX,OFFSET SNGFLT\t;CALL SNGFLT WHEN DONE\r\n\tPUSH\tCX\t\t;LIKE SO\r\nLEN1:\tCALL\tFRESTR\t\t;FREE UP TEMP POINTED TO BY FACLO\r\n\tXOR\tAL,AL\t\t;FORCE NUMERIC FLAG\r\n\tMOV\tDH,AL\t\t;SET HIGH OF [D,E] TO ZERO FOR VAL\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tOR\tAL,AL\t\t;SET CONDITION CODES ON LENGTH\r\n\tRET\t\t\t;RETURN\r\n\r\n; THE FOLLOWING IS THE ASC($) FUNCTION. IT RETURNS AN INTEGER\r\n; WHICH IS THE DECIMAL ASCII EQUIVALENT\r\n;\r\n\tPUBLIC\tASC,ASC2\r\nASC:\r\n\tMOV\tCX,OFFSET SNGFLT\t;WHERE TO GO WHEN DONE\r\n\tPUSH\tCX\t\t;SAVE RETURN ADDR ON STACK\r\nASC2:\tCALL\tLEN1\t\t;SET UP ORIGINAL STR\r\n\tJNZ\tSHORT ??L006\r\n\tJMP\tFCERR\t\t;NULL STR, BAD ARG.\r\n??L006:\r\n\tINC\tBX\t\t;BUMP POINTER\r\n\tMOV\tDX,[BX]\t\t;[D,E]=POINTER AT STRING DATA\r\n\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;[A]=FIRST CHARACTER\r\n\tRET\t\r\n;\r\n; CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY\r\n; CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARG (#)\r\n; WHICH MUST BE .LE. 255.\r\n;\r\n\tPUBLIC\tCHR$\r\nCHR$:\tCALL\tSTRIN1\t\t;GET STRING IN DSCTMP\r\n\tCALL\tCONINT\t\t;GET INTEGER IN RANGE\r\n\tINCSTR=2\r\n\tINCSTR=1\r\n\tPUBLIC\tSETSTR,FINBCK\r\nSETSTR:\tMOV\tBX,DSCTMP+INCSTR\t;GET ADDR OF STR\r\n\tMOV\tBYTE PTR [BX],DL\t;SAVE ASCII BYTE\r\nFINBCK:\tPOP\tCX\t\t;RETURN TO HIGHER LEVEL &\r\n\t\t\t\t;SKIP THE CHKNUM CALL.\r\n\tJMP\tPUTNEW\t\t;GO CALL PUTNEW\r\n\r\n\tPUBLIC\tSTRNG$\r\nSTRNG$:\tCALL\tCHRGTR\t\t;GET NEXT CHAR FOLLOWING \"STRING$\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"(\"\t;MAKE SURE LEFT PAREN\r\n\tCALL\tGETBYT\t\t;EVALUATE FIRST ARG (LENGTH)\r\n\tPUSH\tDX\t\t;SAVE IT\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;COMMA\r\n\tCALL\tFRMEVL\t\t;GET FORMULA ARG 2\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\t;EXPECT RIGHT PAREN\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE TEXT POINTER ON STACK, GET REP FACTOR\r\n\tPUSH\tBX\t\t;SAVE BACK REP FACTOR\r\n\tCALL\tGETYPR\t\t;GET TYPE OF ARG\r\n\tJZ\tSHORT STRSTR\t;WAS A STRING\r\n\tCALL\tCONINT\t\t;GET ASCII VALUE OF CHAR\r\n\tJMP\tSHORT CALSPA\t;NOW CALL SPACE CODE\r\nSTRSTR:\tCALL\tASC2\t\t;GET VALUE OF CHAR IN [A]\r\nCALSPA:\tPOP\tDX\t\t;GET REP FACTOR IN [E]\r\n\tCALL\tSPACE2\t\t;INTO SPACE CODE, PUT DUMMY ENTRY\r\n\t\t\t\t;ON STACK POPPED OFF BY FINBCK\r\n\r\n\tPUBLIC\tSPACE$\r\nSPACE$:\tCALL\tCONINT\t\t;GET NUMBER OF CHARS IN [E]\r\n\tMOV\tAL,LOW 32\t;GET SPACE CHAR\r\nSPACE2:\tPUSH\tAX\t\t;SAVE CHAR\r\n\tMOV\tAL,DL\t\t;GET NUMBER OF CHARS IN [A]\r\n\tCALL\tSTRINI\t\t;GET A STRING THAT LONG\r\n\tMOV\tCH,AL\t\t;COUNT OF CHARS BACK IN [B]\r\n\tPOP\tAX\t\t;GET BACK CHAR TO PUT IN STRING\r\n\tINC\tCH\t\t;TEST FOR NULL STRING\r\n\tDEC\tCH\r\n\tJZ\tSHORT FINBCK\t;YES, ALL DONE\r\n\tMOV\tBX,DSCTMP+INCSTR\t;GET DESC. POINTER\r\nSPLP$:\tMOV\tBYTE PTR [BX],AL\t;SAVE CHAR\r\n\tINC\tBX\t\t;BUMP PTR\r\n\t\t\t\t;DECR COUNT\r\n\tDEC\tCH\r\n\tJNZ\tSHORT SPLP$\t;KEEP STORING CHAR\r\n\tJMP\tSHORT FINBCK\t;PUT TEMP DESC WHEN DONE\r\n\tPAGE\t\r\n\tSUBTTL STRING FUNCTIONS - LEFT$, RIGHT$, MID$\r\n;\r\n; THE FOLLOWING IS THE LEFT$($,#) FUNCTION.\r\n; IT TAKES THE LEFTMOST # CHARS OF THE STR.\r\n; IF # IS .GT. THAN THE LEN OF THE STR, IT RETURNS THE WHOLE STR.\r\n;\r\nLEFT$:\tCALL\tPREAM\t\t;TEST THE PARAMETERS\r\n\tXOR\tAL,AL\t\t;LEFT NEVER CHANGES STRING POINTER\r\nLEFT3:\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE TEXT POINTER\r\n\tMOV\tCL,AL\t\t;OFFSET NOW IN [C]\r\n\tDB\t260O\t; SKIP\t;SKIP THE NEXT BYTE WITH \"MVI A,\"\r\n;\r\n; THIS IS PRINT USINGS ENTRY POINT INTO LEFT$\r\n;\r\n\tPUBLIC\tLEFTUS\r\nLEFTUS:\tPUSH\tBX\t\t;THIS IS A DUMMY PUSH TO OFFSET\r\n\t\t\t\t;THE EXTRA POP IN PUTNEW\r\nLEFT2:\tPUSH\tBX\t\t;SAVE DESC. FOR  FRETMP\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET STRING LENGTH\r\n\tCMP\tAL,CH\t\t;ENTIRE STRING WANTED?\r\n\tJB\tSHORT ALLSTR\t;IF #CHARS ASKED FOR.GE.LENGTH,YES\r\n\tMOV\tAL,CH\t\t;GET TRUNCATED LENGTH OF STRING\r\n\tDB\t272O\t; SKIP\t;SKIP OVER MVI USING \"LXI D,\"\r\nALLSTR:\tMOV\tCL,LOW 0\t;MAKE OFFSET ZERO\r\n\tPUSH\tCX\t\t;SAVE OFFSET ON STACK\r\n\tCALL\tGETSPA\t\t;GET SPACE FOR NEW STRING\r\n\tPOP\tCX\t\t;GET BACK OFFSET\r\n\tPOP\tBX\t\t;GET BACK DESC POINTER.\r\n\tPUSH\tBX\t\t;BUT KEEP ON STACK\r\n\tINC\tBX\t\t;MOVE TO STRING POINTER FIELD\r\n\tMOV\tCH,BYTE PTR [BX]\t;GET POINTER LOW\r\n\tINC\tBX\t\t;\r\n\tMOV\tBH,BYTE PTR [BX]\t;POINTER HIGH\r\n\tMOV\tBL,CH\t\t;GET LOW IN  L\r\n\tMOV\tCH,LOW 0\t;GET READY TO ADD OFFSET TO POINTER\r\n\tADD\tBX,CX\t\t;ADD  IT\r\n\tMOV\tCX,BX\t\t;GET OFFSET POINTER IN [B,C]\r\n\tCALL\tSTRAD2\t\t;SAVE INFO IN DSCTMP\r\n\tMOV\tBL,AL\t\t;GET#  OF CHARS TO  MOVE IN L\r\n\tCALL\tMOVSTR\t\t;MOVE THEM IN\r\n\tPOP\tDX\t\t;GET BACK DESC. POINTER\r\n\tCALL\tFRETMP\t\t;FREE IT UP.\r\n\tJMP\tPUTNEW\t\t;PUT TEMP IN TEMP LIST\r\n\r\nRIGHT$:\tCALL\tPREAM\t\t;CHECK ARG\r\n\tPOP\tDX\t\t;GET DESC. POINTER\r\n\tPUSH\tDX\t\t;SAVE BACK FOR LEFT\r\n\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;GET PRESENT LEN OF STR\r\n\tSUB\tAL,CH\t\t;SUBTRACT 2ND PARM\r\n\tJMP\tSHORT LEFT3\t;CONTINUE WITH LEFT CODE\r\n;\r\n; MID ($,#) RETURNS STR WITH CHARS FROM # POSITION\r\n; ONWARD. IF # IS GT LEN($) THEN RETURN NULL STRING.\r\n; MID ($,#,#) RETURNS STR WITH CHARS FROM # POSITION\r\n; FOR #2 CHARS. IF #2 GOES PAST END OF STRING, RETURN\r\n; AS MUCH AS POSSIBLE.\r\n;\r\nMID$:\tXCHG\tBX,DX\t\t;PUT THE TEXT POINTER IN [H,L]\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE FIRST CHARACTER\r\n\tCALL\tPREAM2\t\t;GET OFFSET OFF STACK AND MAKE\r\n\tINC\tCH\r\n\tDEC\tCH\t\t;SEE IF EQUAL TO ZERO\r\n\tJNZ\tSHORT ??L007\r\n\tJMP\tFCERR\t\t;IT MUST NOT BE 0\r\n??L007:\r\n\tPUSH\tCX\t\t;PUT OFFSET ON TO THE STACK\r\n\tCALL\tMIDRST\t\t;DUPLICATE OF CODE CONDITIONED OUT\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;GET OFFSET BACK IN A\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE TEXT POINTER, GET DESC.\r\n\tMOV\tCX,OFFSET LEFT2\t;WHERE TO RETURN TO.\r\n\tPUSH\tCX\t\t;GOES ON STACK\r\n\tDEC\tAL\t\t;SUB ONE FROM OFFSET\r\n\tCMP\tAL,BYTE PTR [BX]\t;POINTER PAST END OF STR?\r\n\tMOV\tCH,LOW 0\t;ASSUME NULL LENGTH STR\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;YES, JUST USE NULL STR\r\n\tMOV\tCL,AL\t\t;SAVE OFFSET OF CHARACTER POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET PRESENT LEN OF STR\r\n\tSUB\tAL,CL\t\t;SUBTRACT INDEX (2ND ARG)\r\n\tCMP\tAL,DL\t\t;IS IT TRUNCATION\r\n\tMOV\tCH,AL\t\t;GET CALCED LENGTH IN B\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;IF NOT USE PARTIAL STR\r\n\tMOV\tCH,DL\t\t;USE TRUNCATED LENGTH\r\n\tRET\t\t\t;RETURN TO LEFT2\r\n;\r\n; THE VAL FUNCTION TAKES A STRING AND TURN IT INTO\r\n; A NUMBER BY INTERPRETING THE ASCII DIGITS. ETC..\r\n; EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED\r\n; BY REPLACING THE CHARACTER BEYOND THE STRING, VAL\r\n; IS MERELY A CALL TO FLOATING INPUT (FIN).\r\n;\r\nVAL:\tCALL\tLEN1\t\t;DO SETUP, SET RESULT=REAL\r\n\tJNZ\tSHORT ??L008\r\n\tJMP\tSNGFLT\r\n??L008:\t\t\t\t;MAKE SURE TYPE SET UP OK IN EXTENDED\r\n\tMOV\tDL,AL\t\t;GET LENGTH OF STR\r\n\tINC\tBX\t\t;TO HANDLE THE FACT THE IF\r\n\tMOV\tBX,[BX]\t\t;TWO STRINGS \"1\" AND \"2\" ARE STORED\r\n\t\t\t\t;NEXT TO EACH OTHER\r\n\tPUSH\tBX\t\t;AND FIN IS CALLED POINTING TO\r\n\tADD\tBX,DX\t\t;THE FIRST TWELVE WILL BE RETURNED\r\n\tMOV\tCH,BYTE PTR [BX]\t;THE IDEA IS TO STORE 0 IN THE\r\n\tMOV\tBYTE PTR [BX],DH\t;STRING BEYOND THE ONE VAL\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;IS BEING CALLED ON\r\n\tPUSH\tCX\t\t;THE FIRST CHARACTER OF THE NEXT STRING\r\n\tDEC\tBX\t\t;***CALL CHRGET TO MAKE SURE\r\n\tCALL\tCHRGTR\t\t;VAL(\" -3\")=-3\r\n\tCALL\tFINDBL\t\t;IN EXTENDED, GET ALL THE PRECISION WE CAN\r\n\tPOP\tCX\t\t;GET THE MODIFIED CHARACTER OF THE NEXT\r\n\t\t\t\t;STRING INTO [B]\r\n\tPOP\tBX\t\t;GET THE POINTER TO THE MODIFIED CHARACTER\r\n\tMOV\tBYTE PTR [BX],CH\t;RESTORE THE CHARACTER\r\n\t\t\t\t;IF STRING IS HIGHEST IN STRING SPACE\r\n\t\t\t\t;WE ARE MODIFYING [MEMSIZ] AND\r\n\t\t\t\t;THIS IS WHY [MEMSIZ] CAN'T BE USED TO STORE\r\n\t\t\t\t;STRING DATA BECAUSE WHAT IF THE\r\n\t\t\t\t;USER TOOK VAL OFF THAT HIGH STRING\r\n\tRET\t\r\n;USED BY RIGHT$ AND LEFT$ FOR PARAMETER CHECKING AND SETUP\r\nPREAM:\tXCHG\tBX,DX\t\t;PUT THE TEXT POINTER IN [H,L]\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\t;PARAM LIST SHOULD END\r\n;USED BY MID$ FOR PARAMETER CHECKING AND SETUP\r\nPREAM2:\tPOP\tCX\t\t;GET RETURN ADDR OFF STACK\r\n\tPOP\tDX\t\t;GET LENGTH OF ARG OFF STACK\r\n\tPUSH\tCX\t\t;SAVE RETURN ADDR BACK ON\r\n\tMOV\tCH,DL\t\t;SAVE INIT LENGTH\r\n\tRET\t\r\n\r\n\tPAGE\t\r\n\tSUBTTL STRING FUNCTIONS - INSTR\r\n\r\n; THIS IS THE INSTR FUCNTION. IT TAKES ONE OF TWO\r\n; FORMS: INSTR(I%,S1$,S2$) OR INSTR(S1$,S2$)\r\n; IN THE FIRST FORM THE STRING S1$ IS SEARCHED FOR THE\r\n; CHARACTER S2$ STARTING AT CHARACTER POSITION I%.\r\n; THE SECOND FORM IS IDENTICAL, EXCEPT THAT THE SEARCH\r\n; STARTS AT POSITION 1. INSTR RETURNS THE CHARACTER\r\n; POSITION OF THE FIRST OCCURANCE OF S2$ IN S1$.\r\n; IF S1$ IS NULL, 0 IS RETURNED. IF S2$ IS NULL, THEN\r\n; I% IS RETURNED, UNLESS I% .GT. LEN(S1$) IN WHICH\r\n; CASE 0 IS RETURNED.\r\n\r\n\tPUBLIC\tINSTR\r\nINSTR:\tCALL\tCHRGTR\t\t;EAT FIRST CHAR\r\n\tCALL\tFRMPRN\t\t;EVALUATE FIRST ARG\r\n\tCALL\tGETYPR\t\t;SET ZERO IF ARG A STRING.\r\n\tMOV\tAL,LOW 1\t;IF SO, ASSUME, SEARCH STARTS AT FIRST CHAR\r\n\tPUSH\tAX\t\t;SAVE OFFSET IN CASE STRING\r\n\tJZ\tSHORT WUZSTR\t;WAS A STRING\r\n\tPOP\tAX\t\t;GET RID OF SAVED OFFSET\r\n\tCALL\tCONINT\t\t;FORCE ARG1 (I%) TO BE INTEGER\r\n\tOR\tAL,AL\t\t;DONT ALLOW ZERO OFFSET\r\n\tJNZ\tSHORT ??L009\r\n\tJMP\tFCERR\t\t;KILL HIM.\r\n??L009:\r\n\tPUSH\tAX\t\t;SAVE FOR LATER\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;EAT THE COMMA\r\n\tCALL\tFRMEVL\t\t;EAT FIRST STRING ARG\r\n\tCALL\tCHKSTR\t\t;BLOW UP IF NOT STRING\r\nWUZSTR:\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;EAT COMMA AFTER ARG\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tMOV\tBX,FACLO\t;GET DESCRIPTOR POINTER\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT ON STACK & GET BACK TEXT PNT.\r\n\tCALL\tFRMEVL\t\t;GET LAST ARG\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\t;EAT RIGHT PAREN\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\tFRESTR\t\t;FREE UP TEMP & CHECK STRING\r\n\tXCHG\tBX,DX\t\t;SAVE 2ND DESC. POINTER IN [D,E]\r\n\tPOP\tCX\t\t;GET TEXT POINTER IN B\r\n\tPOP\tBX\t\t;DESC. POINTER FOR S1$\r\n\tPOP\tAX\t\t;OFFSET\r\n\tPUSH\tCX\t\t;PUT TEXT POINTER ON BOTTOM\r\n\tMOV\tCX,OFFSET POPHRT\t;PUT ADDRESS OF POP H, RET ON\r\n\tPUSH\tCX\t\t;PUSH IT\r\n\tMOV\tCX,OFFSET SNGFLT\t;NOW ADDRESS OF [A] RETURNER\r\n\tPUSH\tCX\t\t;ONTO STACK\r\n\tPUSH\tAX\t\t;SAVE OFFSET BACK\r\n\tPUSH\tDX\t\t;SAVE DESC. OF S2\r\n\tCALL\tFRETM2\t\t;FREE UP S1 DESC.\r\n\tPOP\tDX\t\t;RESTORE DESC. S2\r\n\tPOP\tAX\t\t;GET BACK OFFSET\r\n\tMOV\tCH,AL\t\t;SAVE UNMODIFIED OFFSET\r\n\tDEC\tAL\t\t;MAKE OFFSET OK\r\n\tMOV\tCL,AL\t\t;SAVE IN C\r\n\tCMP\tAL,BYTE PTR [BX]\t;IS IT BEYOND LENGTH OF S1?\r\n\tMOV\tAL,LOW 0\t;IF SO, RETURN ZERO. (ERROR)\r\n\tJNAE\tSHORT $+3\r\n\tRET\r\n\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;GET LENGTH OF S2$\r\n\tOR\tAL,AL\t\t;NULL??\r\n\tMOV\tAL,CH\t\t;GET OFFSET BACK\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;ALL IF S2 NULL, RETURN OFFSET\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET LENGTH OF S1$\r\n\tINC\tBX\t\t;BUMP POINTER\r\n\tMOV\tCH,BYTE PTR [BX]\t;GET 1ST BYTE OF ADDRESS\r\n\tINC\tBX\t\t;BUMP POINTER\r\n\tMOV\tBH,BYTE PTR [BX]\t;GET 2ND BYTE\r\n\tMOV\tBL,CH\t\t;GET 1ST BYTE SET UP\r\n\tMOV\tCH,LOW 0\t;GET READY FOR DAD\r\n\tADD\tBX,CX\t\t;NOW INDEXING INTO STRING\r\n\tSUB\tAL,CL\t\t;MAKE LENGTH OF STRING S1$ RIGHT\r\n\tMOV\tCH,AL\t\t;SAVE LENGTH OF 1ST STRING IN [B]\r\n\tPUSH\tCX\t\t;SAVE COUNTER, OFFSET\r\n\tPUSH\tDX\t\t;PUT 2ND DESC (S2$) ON STACK\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;GET 2ND DESC. POINTER\r\n\tMOV\tCL,BYTE PTR [BX]\t;SET UP LENGTH\r\n\tINC\tBX\t\t;BUMP POINTER\r\n\tMOV\tDX,[BX]\t\t;GET FIRST BYTE OF ADDRESS\r\n\tPOP\tBX\t\t;RESTORE POINTER FOR 1ST STRING\r\n\r\nCHK1:\tPUSH\tBX\t\t;SAVE POSITION IN SEARCH STRING\r\n\tPUSH\tDX\t\t;SAVE START OF SUBSTRING\r\n\tPUSH\tCX\t\t;SAVE WHERE WE STARTED SEARCH\r\nCHK:\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;GET CHAR FROM SUBSTRING\r\n\tCMP\tAL,BYTE PTR [BX]\t; = CHAR POINTER TO BY [H,L]\r\n\tJNZ\tSHORT OHWELL\t;NO\r\n\tINC\tDX\t\t;BUMP COMPARE POINTER\r\n\tDEC\tCL\t\t;END OF SEARCH STRING?\r\n\tJZ\tSHORT GOTSTR\t;WE FOUND IT!\r\n\tINC\tBX\t\t;BUMP POINTER INTO STRING BEING SEARCHED\r\n\t\t\t\t;DECREMENT LENGTH OF SEARCH STRING\r\n\tDEC\tCH\r\n\tJNZ\tSHORT CHK\t;END OF STRING, YOU LOSE\r\nRETZER:\tPOP\tDX\t\t;GET RID OF POINTERS\r\n\tPOP\tDX\t\t;GET RID OF GARB\r\n\tPOP\tCX\t\t;LIKE SO\r\nRETZR1:\tPOP\tDX\r\n\tXOR\tAL,AL\t\t;GO TO SNGFLT.\r\n\tRET\t\t\t;RETURN\r\n\r\nGOTSTR:\tPOP\tBX\r\n\tPOP\tDX\t\t;GET RID OF GARB\r\n\tPOP\tDX\t\t;GET RID OF EXCESS STACK\r\n\tPOP\tCX\t\t;GET COUNTER, OFFSET\r\n\tMOV\tAL,CH\t\t;GET ORIGINAL SOURCE COUNTER\r\n\tSUB\tAL,BH\t\t;SUBTRACT FINAL COUNTER\r\n\tADD\tAL,CL\t\t;ADD ORIGINAL OFFSET (N1%)\r\n\tINC\tAL\t\t;MAKE OFFSET OF ZERO = POSIT 1\r\n\tRET\t\t\t;DONE\r\n\r\n\r\nOHWELL:\tPOP\tCX\r\n\tPOP\tDX\t\t;POINT TO START OF SUBSTRING\r\n\tPOP\tBX\t\t;GET BACK WHERE WE STARTED TO COMPARE\r\n\tINC\tBX\t\t;AND POINT TO NEXT CHAR\r\n\t\t\t\t;DECR. # CHAR LEFT IN SOURCE STRING\r\n\tDEC\tCH\r\n\tJNZ\tSHORT CHK1\t;TRY SEARCHING SOME MORE\r\n\tJMP\tSHORT RETZR1\t;END OF STRING, RETURN 0\r\n\r\n\tPAGE\t\r\n\tSUBTTL STRING FUNCTIONS - LEFT HAND SIDE MID$\r\nLHSMID:\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"(\"\t;MUST HAVE ( \r\n\tCALL\tPTRGET\t\t;GET A STRING VAR\r\n\tCALL\tCHKSTR\t\t;MAKE SURE IT WAS A STRING\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tPUSH\tDX\t\t;SAVE DESC. POINTER\r\n\tXCHG\tBX,DX\t\t;PUT DESC. POINTER IN [H,L]\r\n\tINC\tBX\t\t;MOVE TO ADDRESS FIELD\r\n\tMOV\tDX,[BX]\t\t;GET ADDRESS OF LHS IN [D,E]\r\n\tMOV\tBX,STREND\t;SEE IF LHS STRING IS IN STRING SPACE\r\n\tCMP\tBX,DX\t\t;BY COMPARING IT WITH STKTOP\r\n\tJB\tSHORT NCPMID\t;IF ALREADY IN STRING SPACE\r\n\t\t\t\t;DONT COPY.\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tTXTTAB:WORD\r\nDSEG\tENDS\r\n\tMOV\tBX,TXTTAB\r\n\tCMP\tBX,DX\t\t;Is this a fielded string?\r\n\tJAE\tSHORT NCPMID\t;Yes, Don't copy!!\r\nNCP1:\tPOP\tBX\t\t;GET BACK DESC. POINTER\r\n\tPUSH\tBX\t\t;SAVE BACK ON STACK\r\n\tCALL\tSTRCPY\t\t;COPY THE STRING LITERAL INTO STRING SPACE\r\n\tPOP\tBX\t\t;GET BACK DESC. POINTER\r\n\tPUSH\tBX\t\t;BACK ON STACK AGAIN\r\n\tCALL\tVMOVE\t\t;MOVE NEW DESC. INTO OLD SLOT.\r\nNCPMID:\tPOP\tBX\t\t;GET DESC. POINTER\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;GET TEXT POINTER TO [H,L] DESC. TO STACK\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;MUST HAVE COMMA\r\n\tCALL\tGETBYT\t\t;GET ARG#2 (OFFSET INTO STRING)\r\n\tOR\tAL,AL\t\t;MAKE SURE NOT ZERO\r\n\tJNZ\tSHORT ??L010\r\n\tJMP\tFCERR\t\t;BLOW HIM UP IF ZERO\r\n??L010:\r\n\tPUSH\tAX\t\t;SAVE ARG#2 ON STACK\r\n\tMOV\tAL,BYTE PTR [BX]\t;RESTORE CURRENT CHAR\r\n\tCALL\tMIDRST\t\t;USE MID$ CODE TO EVALUATE POSIBLE THIRD ARG.\r\n\tPUSH\tDX\t\t;SAVE THIRD ARG ([E]) ON STACK\r\n\t\t\t\t;MUST HAVE = SIGN\r\n\tCALL\tFRMEQL\t\t;EVALUATE RHS OF THING.\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER.\r\n\tCALL\tFRESTR\t\t;FREE UP TEMP RHS IF ANY.\r\n\tXCHG\tBX,DX\t\t;PUT RHS DESC. POINTER IN [D,E]\r\n\tPOP\tBX\t\t;TEXT POINTER TO [H,L]\r\n\tPOP\tCX\t\t;ARG #3 TO C.\r\n\tPOP\tAX\t\t;ARG #2 TO A.\r\n\tMOV\tCH,AL\t\t;AND [B]\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;GET LHS DESC. POINTER TO [H,L]\r\n\t\t\t\t;TEXT POINTER TO STACK\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tMOV\tBX,OFFSET POPHRT\t;GET ADDR TO RETURN TO\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE ON STACK & GET BACK TXT PTR.\r\n\tMOV\tAL,CL\t\t;GET ARG #3\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF ZERO, DO NOTHING\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET LENGTH OF LHS\r\n\tSUB\tAL,CH\t\t;SEE HOW MANY CHARS IN EMAINDER OF STRING\r\n\tJAE\tSHORT ??L011\r\n\tJMP\tFCERR\t\t;CANT ASSIGN PAST LEN(LHS)!\r\n??L011:\r\n\tINC\tAL\t\t;MAKE PROPER COUNT\r\n\tCMP\tAL,CL\t\t;SEE IF # OF CHARS IS .GT. THIRD ARG\r\n\tJB\tSHORT BIGLEN\t;IF SO, DONT TRUNCATE\r\n\tMOV\tAL,CL\t\t;TRUNCATE BY USING 3RD ARG.\r\nBIGLEN:\tMOV\tCL,CH\t\t;GET OFFSET OF STRING IN [C]\r\n\tDEC\tCL\t\t;MAKE PROPER OFFSET\r\n\tMOV\tCH,LOW 0\t;SET UP [B,C] FOR LATER DAD B.\r\n\tPUSH\tDX\t\t;SAVE [D,E]\r\n\tINC\tBX\t\t;POINTER TO ADDRESS FIELD.\r\n\tMOV\tDL,BYTE PTR [BX]\t;GET LOW BYTE IN [E]\r\n\tINC\tBX\t\t;BUMP POINTER\r\n\tMOV\tBH,BYTE PTR [BX]\t;GET HIGH BYTE IN [H]\r\n\tMOV\tBL,DL\t\t;NOW COPY LOW BYTE BACK TO [L]\r\n\tADD\tBX,CX\t\t;ADD OFFSET\r\n\tMOV\tCH,AL\t\t;SET COUNT OF LHS IN [B]\r\n\tPOP\tDX\t\t;RESTORE [D,E]\r\n\tXCHG\tBX,DX\t\t;MOVE RHS. DESC. POINTER TO [H,L]\r\n\tMOV\tCL,BYTE PTR [BX]\t;GET LEN(RHS) IN [C]\r\n\tINC\tBX\t\t;MOVE POINTER\r\n\tMOV\tBX,[BX]\t\t;GET LOW BYTE OF ADDRESS IN [A]\r\n\tXCHG\tBX,DX\t\t;ADDRESS OF RHS NOW IN [D,E]\r\n\tMOV\tAL,CL\t\t;IS RHS NULL?\r\n\tOR\tAL,AL\t\t;TEST\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;THEN ALL DONE.\r\n; NOW ALL SET UP FOR ASSIGNMENT.\r\n; [H,L] = LHS POINTER\r\n; [D,E] = RHS POINTER\r\n; C = LEN(RHS)\r\n; B = LEN(LHS)\r\n\r\nMID$LP:\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;GET BYTE FROM RHS.\r\n\tMOV\tBYTE PTR [BX],AL\t;STORE IN LHS\r\n\tINC\tDX\t\t;BUMP RHS POINTER\r\n\tINC\tBX\t\t;BUMP LHS POINTER.\r\n\tDEC\tCL\t\t;BUMP DOWN COUNT OF RHS.\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF ZERO, ALL DONE.\r\n\t\t\t\t;IF LHS ENDED, ALSO DONE.\r\n\tDEC\tCH\r\n\tJNZ\tSHORT MID$LP\t;IF NOT DONE, MORE COPYING.\r\n\tRET\t\t\t;BACK TO NEWSTT\r\n\r\nMIDRST:\tMOV\tDL,LOW 255\t;IF TWO ARG GUY, TRUNCATE.\r\n\tCMP\tAL,LOW \")\"\r\n\tJZ\tSHORT MID2\t;[E] SAYS USE ALL CHARS\r\n\t\t\t\t;IF ONE ARGUMENT THIS IS CORRECT\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;COMMA? MUST DELINEATE 3RD ARG.\r\n\tCALL\tGETBYT\t\t;GET ARGUMENT  IN  [E]\r\nMID2:\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\t;MUST BE FOLLOWED BY )\r\n\tRET\t\t\t;ALL DONE.\r\n\r\n\tSUBTTL FRE  FUNCTION AND INTEGER TO FLOATING  ROUTINES\r\nFRE:\r\n\tCALL\tGETYPR\r\n\tJZ\tSHORT ??L012\r\n\tJMP\tCLCDIF\r\n??L012:\r\n\tCALL\tFREFAC\t\t;FREE UP ARGUMENT AND SETUP\r\n\t\t\t\t;TO GIVE FREE STRING SPACE\r\n\tCALL\tGARBA2\t\t;DO GARBAGE COLLECTION\r\nCLCDIF:\tMOV\tDX,STREND\r\n\tMOV\tBX,FRETOP\t;TOP OF FREE AREA\r\n\tJMP\tGIVDBL\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "CALL86.ASM",
          "type": "blob",
          "size": 3.125,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   CALL86  8086 CALL Statement\r\n\t.SALL\r\n\t.RADIX\t8\r\n\r\n\r\n\tEXTRN\tVMOVFM:NEAR,FRQINT:NEAR,PTRGET:NEAR,GETSTK:NEAR\r\n\tEXTRN\tCHRGTR:NEAR,SYNCHR:NEAR,CHRGT2:NEAR,FCERR:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tSUBFLG:WORD,SARYFL:WORD,TEMP:WORD,TEMPA:WORD,SAVSEG:WORD\r\n\tEXTRN\tARYTAB:WORD\r\nDSEG\tENDS\r\n\r\n; This is the CALL <simple var>[(<simple var>[,<simple var>]..)]\r\n; Stragegy:\r\n;\r\n; 1.) Make sure suboutine name is simple var, get value & save it\r\n;\r\n; 2.) Evaluate params & stuff pointers on stack\r\n;\r\n; 3.) CALL suboutine with return address on stack\r\n;\r\n; The CALLS statement is the same as CALL, except for each parameter\r\n; it pushes Segment and Offset, not just Offset.\r\n\r\n\tPUBLIC\tCALLS,CALLSL\r\n\r\nCALLSL:\tCLC\t\t\t;Clear-carry, (PUSH Segment adr of parms)\r\n\tJMP\tSHORT CALLS1\r\nCALLS:\tSTC\t\t\t;Set-carry, (don't PUSH Segment adr of parms)\r\nCALLS1:\tPUSHF\t\r\n\tEXTRN\tPRODIR:NEAR\t;Don't allow CALL as direct statement in\r\n\tCALL\tPRODIR\t\t;protected environment\r\n\tMOV\tBYTE PTR SUBFLG,LOW 200O\t;say we want to scan only a simple\r\n\tCALL\tPTRGET\t\t;scan var and search symbol table\r\n\tMOV\tBYTE PTR SARYFL,LOW 0\t;clear Scanned-Array-Element-Flag\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tMOV\tBX,DX\t\t;get pointer to var in BX\r\n\tCALL\tVMOVFM\t\t;load variable into FAC\r\n\tCALL\tFRQINT\t\t;make it an integer\r\n\tMOV\tWORD PTR TEMPA,BX\t;save text pointer\r\n\tMOV\tCL,LOW 32D\t;get max # of parameters\r\n\tCALL\tGETSTK\t\t;see if there is that much stack space\r\n\tPOP\tBX\t\t;get back text pointer\r\n\tCALL\tCHRGT2\t\t;eat character after var name\r\n\tJZ\tCALLST\t\t;end of statement, no parameter list\r\n\tCALL\tSYNCHR\t\t;check for open paren\r\n\tDB\t50O\t\t; (\r\nGETPAR:\tPUSH\tWORD PTR ARYTAB\t;save pointer to start of array var data\r\n\tCALL\tPTRGET\t\t;scan parameter variable\r\n\tPOP\tCX\t\t;[CX]=old value of ARYTAB\r\n\tCMP\tCX,WORD PTR ARYTAB\t;if = old, no undefined simples were referenced\r\n\tJE\tNONEWS\t\t;Branch if New Simple Var not encountered\r\n\tCMP\tBYTE PTR SARYFL,LOW 0\t;Z-FLAG if no Array elements have been parsed\r\n\t\t\t\t; by PTRGET\r\n\tJZ\tNONEWS\r\n\tJMP\tFCERR\t\t;Undefined scalers can't be passed after array\r\n\t\t\t\t;elements since the addr of the array element\r\n\t\t\t\t;changes when the new scaler is added.\r\nNONEWS:\tPOPF\t\t\t;restore Carry=CALL/CALLS flag\r\n\tJB\tSHTPRM\t\t;Branch if CALL (not CALLS)\r\n\tPUSH\tDS\t\t;save Segment of Parameter on stack\r\nSHTPRM:\tPUSH\tDX\t\t;save Offset of parameter on stack\r\n\tPUSHF\t\t\t;re-save CALL/CALLS flag\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;get terminator\r\n\tCMP\tAL,LOW \",\"\t;comma?\r\n\tJNZ\tENDPAR\t\t;no, must be end of the param list\r\n\tCALL\tCHRGTR\t\t;scan next char\r\n\tJMP\tSHORT GETPAR\t;scan next parm\r\nENDPAR:\tCALL\tSYNCHR\t\t;check for terminating right paren\r\n\tDB\t51O\t\t; )\r\nCALLST:\tMOV\tWORD PTR TEMP,BX\t;save text pointer\r\n\tPOPF\t\t\t;discard CALL/CALLS flag\r\n\tPUSH\tCS\t\t;save BASIC code segment\r\n\tMOV\tAX,OFFSET CALLRT\t;where to return to\r\n\tPUSH\tAX\r\n\tPUSH\tWORD PTR SAVSEG\t;save subroutine segment\r\n\tPUSH\tWORD PTR TEMPA\t;save subroutine address\r\n\tDB\t313O\t\t; Do a long return to call the subroutine\r\n;\r\nCALLRT:\tMOV\tBX,WORD PTR TEMP\t;get back text pointer\r\n\tRET\t\t\t;return to newstt\r\n;\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.4423828125,
          "content": "# Microsoft Open Source Code of Conduct\r\n\r\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).\r\n\r\nResources:\r\n\r\n- [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/)\r\n- [Microsoft Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/)\r\n- Contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with questions or concerns\r\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.259765625,
          "content": "# Microsoft GW-BASIC Interpreter Contributor Guidance\n\nThe files in this repo are for historical reference only and will remain read-only and unmodified in their original state.\n\nPlease **do not** send Pull Requests suggesting any modifications to the source files.\n"
        },
        {
          "name": "DSKCOM.ASM",
          "type": "blob",
          "size": 24.6142578125,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   DSKCOM - - COMMON ROUTINES FOR DISK BASICS\r\n\r\nALPCPM=0\r\nMELCO=0\r\nMODEL3=0\r\n\r\n\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t; Data Segment\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tCURLIN:WORD,DSCTMP:WORD,PTRFIL:WORD,FRETOP:WORD\r\n\tEXTRN\tSAVSTK:WORD,TXTTAB:WORD,VALTYP:WORD,VARTAB:WORD\r\n\tEXTRN\tBUF:WORD\r\n\tEXTRN\tDIRTMP:WORD\r\nDSEG\tENDS\t\t\t;End of data segment externals\r\n\r\n\t\t\t\t; Code Segment ( terminated by END at bottom of file )\r\n\r\n\tEXTRN\tCLSFIL:NEAR,CONINT:NEAR,DERBFN:NEAR,DERRPE:NEAR,ERROR:NEAR\r\n\tEXTRN\tFILOU3:NEAR,CHRGTR:NEAR\r\n\tEXTRN\tINDSKC:NEAR,PRGFIL:NEAR,SCRTCH:NEAR,SNERR:NEAR\r\n\tEXTRN\tSTRLT3:NEAR,DERFOV:NEAR,DERBFM:NEAR,DOCNVF:NEAR,FCERR:NEAR\r\n\tEXTRN\tFINBCK:NEAR,FINPRT:NEAR,FRCSTR:NEAR,FRESTR:NEAR\r\n\tEXTRN\tFRMEVL:NEAR,GETBYT:NEAR,GETSPA:NEAR,GTBYTC:NEAR,GTMPRT:NEAR\r\n\tEXTRN\tINCHRI:NEAR\r\n\tEXTRN\tLINKER:NEAR,LIST:NEAR,MAIN:NEAR,NEWSTT:NEAR,OMERR:NEAR\r\n\tEXTRN\tPTRGET:NEAR,PUTNEW:NEAR,READY:NEAR,RUNC:NEAR\r\n\tEXTRN\tVMOVFM:NEAR,VMOVMF:NEAR,STRINI:NEAR\r\n\r\n\tEXTRN\tFRMEQL:NEAR\r\n\tEXTRN\tENDCON:NEAR,GONE:NEAR\r\n\tEXTRN\tDOASIG:NEAR,ERRFDR:NEAR,FIN:NEAR\r\n\tEXTRN\tSCCPTR:NEAR\r\n\r\n\tEXTRN\tGETYPR:NEAR,SYNCHR:NEAR,DCOMPR:NEAR\r\n\tPUBLIC\tFIELD,PRGFLI\r\n\tPUBLIC\tFILIND\r\n\tPUBLIC\tMKI$,MKS$,MKD$,CVI,CVS,CVD\r\n\tPUBLIC\tDLINE,PRGFL2,LRUN,LOAD,PRGFIN,MERGE,SAVE\r\n\tPUBLIC\tOKGETM\r\n\tPUBLIC\tRSET,LSET\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tPROFLG:WORD\r\nDSEG\tENDS\r\n\r\n\tINCLUDE\tGIO86U\r\nCPM86=0\r\n\tINCLUDE\tMSDOSU\r\n\tNMLOFS=F_BREM\r\n\r\n\t.RADIX\t10\r\nCOMMENT\t% REVISION HISTORY\r\n4/23/78 PGA     ALLOW # ON CLOSE\r\n\r\n8/6/79  PGA     IF ^C ON MBASIC FOO, DONT RETURN TO SYSTEM. SEE 'NOTINI'\r\n6/27/80 PGA     FIX INPUT#1,D# SO IT USES FINDBL INSTEAD OF FIN\r\n\t\t\t\tAND THUS AVOIDS LOSING SIGNIFICANCE.\r\n\r\n%\r\n\r\n\tSUBTTL FILINP AND FILGET -- SCAN A FILE NUMBER AND SETUP PTRFIL\r\n\r\n\tEXTRN\tFILINP:NEAR,FILSCN:NEAR,FILSET:NEAR\r\n\r\n\r\n\tSUBTTL FILSCN, FILFRM, AND FILIDX\r\n\r\n\tSUBTTL  Conversion Routines\r\nMKI$:\tMOV\tAL,LOW 2\t;VALUE TYPE FOR INTEGER AND NUMBER\r\n\t\t\t\t;OF CHARACTERS RESULT WILL NEED\r\n\tDB\t271O\t; SKIP\t;SKIP NEXT TWO BYTES WITH \"LXI  B,\"\r\nMKS$:\tMOV\tAL,LOW 4\t;VALUE TYPE OF SINGLE PRECISION\r\n\tDB\t271O\t; SKIP\t;SKIP NEXT TWO BYTES\r\nMKD$:\tMOV\tAL,LOW 8\t;VALUE TYPE OF DOUBLE-PRECISION\r\n\tPUSH\tAX\t\t;SAVE THE NUMBER OF BYTES OF\r\n\t\t\t\t;STRING SPACE WE NEED\r\n\tCALL\tDOCNVF\t\t;CONVERT FAC TO PROPER TYPE\r\n\tPOP\tAX\t\t;GET THE NUMBER OF BYTES NEEDED\r\n\tCALL\tSTRINI\t\t;GET A PLACE FOR THE STRING DATA\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDSCPTR:WORD\r\nDSEG\tENDS\r\n\tMOV\tBX,DSCPTR\t;POINT TO THE PLACE TO STORE THE DATA\r\n\tCALL\tVMOVMF\t\t;MOVE THE FAC VALUE INTO THE STRING CREATION\r\n\tJMP\tFINBCK\r\n\r\nCVI:\tMOV\tAL,LOW 1\t;SET [A] TO BE VALTYP-1\r\n\tDB\t271O\t; SKIP\t;SKIP THE NEXT TWO BYTES WITH \"LXI B,\"\r\nCVS:\tMOV\tAL,LOW 3\t;ALSO SET [A] TO NUMBER OF CHARACTERS REQUIRED -1\r\n\tDB\t271O\t; SKIP\t;SKIP THE NEXT TWO BYTES\r\nCVD:\tMOV\tAL,LOW 7\t;DOUBLE PRECISION VALUE TYPE -1\r\n\tPUSH\tAX\t\t;SAVE THE VALTYP\r\n\tCALL\tFRESTR\t\t;MAKE SURE THE ARGUMENT IS A STRING\r\n\t\t\t\t;AND GET A POINTER TO THE DESCRIPTOR\r\n\tPOP\tAX\t\t;GET BACK NUMBER OF CHARACTERS REQUIRED-1\r\n\tCMP\tAL,BYTE PTR [BX]\t;MAKE SURE THE STRING IS LONGER THAN THAT\r\n\tJNAE\tSHORT ??L000\r\n\tJMP\tFCERR\t\t;IF NOT, \"ILLEGAL FUNCTION CALL\"\r\n??L000:\r\n\tINC\tAL\t\t;[A]=TRUE VALUE TYPE\r\n\tMOV\tBYTE PTR VALTYP,AL\t;SETUP VALUE TYPE FOR MOVE\r\n\tINC\tBX\r\n\tMOV\tBX,[BX]\t\t;[H,L]=POINTER AT STRING DATA\r\n\t\t\t\t;AND FOR IDENTIFICATION\r\n\tJMP\tVMOVFM\r\n\r\n\r\n\tSUBTTL  Read Items From A Sequential File\r\n\r\nFILIND:\r\n\tCALL\tGETYPR\t\t;SEE IF INPUT IS STRING OR NUMBER\r\n\tMOV\tCX,OFFSET DOASIG\t;RETURN ADDRESS TO SETUP [FAC]\r\n\tCON1=0+(44*256)+32\r\n\tMOV\tDX,OFFSET CON1\t;SETUP TERMINATORS SPACE AND COMMA\r\n\tJNZ\tSHORT INPDOR\t;IF NUMERIC, GO READ THE FILE\r\n\tMOV\tDL,DH\t\t;MAKE BOTH TERMINATORS COMMA\r\n\tJMP\tSHORT INPDOR\t;GO READ THE FILE\r\n;\r\n; Entry for line input and read code for item fetching from\r\n; sequential input files\r\n;\r\n\r\nDLINE:\r\n\tCALL\tFILINP\t\t;GET FILE NUMBER SET UP\r\n\tCALL\tPTRGET\t\t;READ STRING TO STORE INTO\r\n\tCALL\tFRCSTR\t\t;MAKE SURE IT WAS A STRING\r\n\tMOV\tCX,OFFSET FINPRT\t;RESET TO CONSOLE WHEN DONE READING\r\n\tPUSH\tCX\t\t;SAVE ON STACK\r\n\tPUSH\tDX\t\t;SAVE POINTER AT VARIABLE\r\n\tEXTRN\tLETCON:NEAR\r\n\tMOV\tCX,OFFSET LETCON\t;GOOD RETURN ADDRESS FOR ASSIGNMENT\r\n\tXOR\tAL,AL\t\t;SET A=0 FOR STRING VALUE TYPE\r\n\tMOV\tDH,AL\t\t;ZERO OUT BOTH TERMINATORS\r\n\tMOV\tDL,AL\r\nINPDOR:\tPUSH\tAX\t\t;SAVE VALUE TYPE\r\n\tPUSH\tCX\t\t;SAVE RETURN ADDRESS\r\n\tPUSH\tBX\t\t;SAVE POINTER AT DATA COMING IN\r\n\t\t\t\t;A DUMMY POINTER AT BUFMIN\r\nNOTNWT:\r\nEXTRN\tINCHR:NEAR\r\n\tCALL\tINCHR\t\t;Read a character from file PTRFIL\r\n\tCMP\tAL,LOW \" \"\t;SKIP LEADING SPACES\r\n\tJNZ\tSHORT NOTSPC\t;EXCEPT FOR LINE INPUT\r\n\tINC\tDH\t\t;CHECK FOR LINEINPUT\r\n\tDEC\tDH\r\n\tJNZ\tSHORT NOTNWT\t;SKIP ANY NUMBER\r\nNOTSPC:\tCMP\tAL,LOW 34\t;QUOTED STRING COMING IN?\r\n\tJNZ\tSHORT NOTQTE\r\n\tMOV\tAL,DL\t\t;MUST BE INPUT OF A STRING\r\n\tCMP\tAL,LOW 44D\t;WHICH HAS [E]=44 (\",\")\r\n\tMOV\tAL,LOW 42O\t;QUOTE BACK INTO [A]\r\n\tJNZ\tSHORT NOTQTE\r\n\tMOV\tDH,AL\t\t;TERMINATORS ARE QUOTES ONLY\r\n\tMOV\tDL,AL\r\n\tCALL\tINDSKC\t\t;READ PAST QUOTATION\r\n\tJB\tSHORT QUITSI\t;IF EOF, ALL DONE\r\nNOTQTE:\r\n\tMOV\tBX,OFFSET BUF\t;BUFFER FOR DATA\r\n\tMOV\tCH,LOW 255\t;MAXIMUM NUMBER OF CHARACTERS (255)\r\nLOPCRS:\tMOV\tCL,AL\t\t;SAVE CHARACTER IN [C]\r\n\tMOV\tAL,DH\t\t;CHECK FOR QUOTED STRING\r\n\tCMP\tAL,LOW 42O\r\n\tMOV\tAL,CL\t\t;RESTORE CHARACTER\r\n\tJZ\tSHORT NOTQTL\t;DON'T IGNORE CR OR STOP ON LF\r\n\tCMP\tAL,LOW 13\t;CR?\r\n\tPUSH\tBX\t\t;SAVE DEST PTR. ON STACK\r\n\tJZ\tSHORT ICASLF\t;EAT LINE FEED IF ONE\r\n\tPOP\tBX\t\t;RESTORE DEST. PTR.\r\n\tCMP\tAL,LOW 10\t;LF?\r\n\tJNZ\tSHORT NOTQTL\t;NO, TEST OTHER TERMINATORS\r\nLPISLF:\t\t\t\t;** 5/14/82 BUG FIX(MULTIPLE LF FOR UNQUOTED STRING)\r\n\tMOV\tCL,AL\t\t;SAVE CURRENT CHAR\r\n\tMOV\tAL,DL\t\t;GET TERMINATOR 2\r\n\tCMP\tAL,LOW 54O\t;CHECK FOR COMMA (UNQUOTED STRING)\r\n\tMOV\tAL,CL\t\t;RESTORE CHARACTER\r\n\tJZ\tSHORT ??L001\r\n\tCALL\tSTRCHR\t\t;IF NOT, STORE LF (?)\r\n??L001:\r\n\tCALL\tINDSKC\t\t;GET NEXT CHAR\r\n\tJB\tSHORT QUITSI\t;IF EOF, ALL DONE.\r\n\tCMP\tAL,LOW 10\t;** 5/14/82 BUG FIX(MULTIPLE LF FOR UNQUOTED STRING)\r\n\tJZ\tSHORT LPISLF\t;** 5/14/82 BUG FIX(MULTIPLE LF FOR UNQUOTED STRING)\r\n\tCMP\tAL,LOW 13\t;IS IT A CR?\r\n\tJNZ\tSHORT NOTQTL\t;IF NOT SEE IF STORE NORMALLY\r\n\tMOV\tAL,DL\t\t;GET TERMINATOR\r\n\tCMP\tAL,LOW \" \"\t;IS IT NUMERIC INPUT?\r\n\tJZ\tSHORT LPCRGT\t;IF SO, IGNORE CR, DONT PUT IN BUFFER\r\n\tCMP\tAL,LOW 44\t;IS IT NON-QUOTED STRING (TERM=,)\r\n\tMOV\tAL,LOW 13\t;GET BACK CR.\r\n\tJZ\tSHORT LPCRGT\t;IF SO, IGNORE CR.\r\nNOTQTL:\tOR\tAL,AL\t\t;IS CHAR ZERO\r\n\tJZ\tSHORT LPCRGT\t;ALWAYS IGNORE, AS IT IS TERMINATOR\r\n\t\t\t\t;FOR STRLIT (SEE QUIT2B)\r\n\tCMP\tAL,DH\t\t;TERMINATOR ONE?\r\n\tJZ\tSHORT QUITSI\t;STOP THEN\r\n\tCMP\tAL,DL\t\t;TERMINATOR TWO?\r\n\tJZ\tSHORT QUITSI\r\n\tCALL\tSTRCHR\t\t;SAVE THE CHAR\r\nLPCRGT:\tCALL\tINDSKC\t\t;READ ANOTHER CHARACTER\r\n\tJAE\tSHORT LOPCRS\t;IF NOT, CHECK AS TERMINATOR\r\nQUITSI:\tPUSH\tBX\t\t;SAVE PLACE TO STUFF ZERO\r\n\tCMP\tAL,LOW 34\t;STOPPED ON QUOTE?\r\n\tJZ\tSHORT MORSPC\t;DON'T SKIP SPACES THEN\r\n\t\t\t\t;BUT DO SKIP FOLLOWING COMMA OR\r\n\t\t\t\t;CRLF THOUGH\r\n\tCMP\tAL,LOW \" \"\t;STOPPED ON SPACE?\r\n\tJNZ\tSHORT NOSKCR\t;NO, DON'T SKIP SPACES\r\n\t\t\t\t;OR ANY FOLLOWING COMMAS OR CRLFS EITHER\r\nMORSPC:\tCALL\tINDSKC\t\t;READ SPACES\r\n\tJB\tSHORT NOSKCR\t;EOF, ALL DONE.\r\n\tCMP\tAL,LOW \" \"\r\n\tJZ\tSHORT MORSPC\r\n\tCMP\tAL,LOW 44\t;COMMA?\r\n\tJNZ\tSHORT ??L002\r\n\tJMP\tNOSKCR\t\t;OK, SKIP IT\r\n??L002:\r\n\tCMP\tAL,LOW 13\t;CARRIAGE RETURN?\r\n\tJNZ\tSHORT BAKUPT\t;BACK UP PAST THIS CHARACTER\r\nICASLF:\r\n\tCALL\tINDSKC\t\t;READ ANOTHER\r\n\tJB\tSHORT NOSKCR\t;EOF, ALL DONE.\r\n\tCMP\tAL,LOW 10\t;LINE FEED?\r\n\tJZ\tSHORT NOSKCR\t;OK, SKIP IT TOO\r\nBAKUPT:\r\n\tEXTRN\tBAKCHR:NEAR\r\n\tCALL\tBAKCHR\t\t;backup file PTRFIL\r\nNOSKCR:\tPOP\tBX\t\t;GET BACK PLACE TO STORE TERMINATOR\r\nQUIT2B:\tMOV\tBYTE PTR [BX],LOW 0\t;STORE THE TERMINATOR\r\n\tMOV\tBX,OFFSET BUF-1\t;ITEM IS NOW STORED AT THIS POINT +1\r\n\tMOV\tAL,DL\t\t;WAS IT A NUMERIC INPUT?\r\n\tSUB\tAL,LOW \" \"\t;IF SO, [E]=\" \"\r\n\tJZ\tSHORT NUMIMK\t;USE FIN TO SCAN IT\r\n\tEXTRN\tSTRLT2:NEAR\r\n\tMOV\tCH,DH\t\t;SET [B]=44 IF SCANNING UNQUOTED STRING\r\n\tMOV\tDH,LOW 0\r\n\tCALL\tSTRLT2\r\n\tPOP\tBX\t\t;GET BACK [H,L]\r\n\tRET\t\t\t;DO ASSIGNMENT\r\n\r\nNUMIMK:\r\n\tCALL\tGETYPR\t\t;GET TYPE OF NUMERIC VARIABLE BEING READ\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\t\t;SAVE IT\r\n\tCALL\tCHRGTR\t\t;READ FIRST CHARACTER\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;RESTORE TYPE OF VARIABLE\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\t\t;SAVE BACK\r\n\tJNB\tSHORT ??L003\r\n\tCALL\tFIN\t\t;SINGLE PRECISION INPUT\r\n??L003:\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;GET BACK TYPE OF VAR\r\n\tEXTRN\tFINDBL:NEAR\r\n\tJNAE\tSHORT ??L004\r\n\tCALL\tFINDBL\r\n??L004:\t\t\t\t;DOUBLE PRECISION INPUT\r\n\tPOP\tBX\t\t;GET [H,L]\r\n\tRET\t\t\t;DO THE ASSIGNMENT\r\n\r\nSTRCHR:\tOR\tAL,AL\t\t;TRYING TO STORE NULL BYTE\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;RETURN, DONT STORE IT\r\n\tMOV\tBYTE PTR [BX],AL\t;STORE THE CHARACTER\r\n\tINC\tBX\r\n\tDEC\tCH\t\t;128 YET?\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;MORE SPACE IN BUFFER, RETURN\r\n\tPOP\tCX\t\t;GET RID OF SUPERFLUOUS STACK ENTRY\r\n\tJMP\tSHORT QUIT2B\t;SPECIAL QUIT\r\n\r\n\tSUBTTL  LOAD and RUN routines\r\n\r\nPRGFLI:\tMOV\tDH,LOW OFFSET MD_SQI\t;SEQUENTIAL INPUT MODE\r\nPRGFL2:\tXOR\tAL,AL\t\t;INTERNAL FILE NUMBER IS ALWAYS ZERO\r\n\tJMP\tPRGFIL\t\t;SCAN FILE NAME AND DISK NUMMER\r\n\t\t\t\t;AND DO THE RIGHT THING USING MD.KIL\r\n\t\t\t\t;AS A FLAG\r\n\r\nLRUN:\r\nLRUN2:\tMOV\tAL,LOW 1\r\n\tJMP\tLRUN3\t\t;1 INDICATES, CLOSE FILES, RUN\r\nLOAD:\tXOR\tAL,AL\t\t;FLAG ZERO FOR \"LOAD\"\r\nLRUN3:\t\t\t\t;A=1 INDICATES CLOSE FILES, RUN\r\n\t\t\t\t;A=0 INDICATES CLOSE FILES, NO RUN\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\t\t;SAVE \"RUN\"/\"LOAD\" FLAG\r\n\tCALL\tPRGFLI\t\t;FIND THAT FILE AND SETUP FOR\r\n\t\t\t\t;USING INDSKC SUBROUTINE\r\n\tDEC\tBX\t\t;SEE IF NO RUN OPTION\r\n\tCALL\tCHRGTR\r\n\tJZ\tSHORT NOTRNL\t;NO, JUST LOAD\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;GOTTA HAVE A COMMA\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"R\"\t;ONLY OPTION IS RUN\r\n\tJZ\tSHORT ??L005\r\n\tJMP\tSNERR\t\t;AND THAT BETTER BE THE END\r\n??L005:\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;GET RID OF \"RUN\"/\"LOAD\" FLAG\r\n; RUN fn closes all files, loads program, and executes program\r\n; RUN fn,R loads program, and executes program\r\n; LOAD fn closes all files, loads program\r\n; LOAD fn,R loads program, and executes program\r\n; MERGE fn merges an ASCII program\r\n; CHAIN fn loads/merges a program, and executes program (leaving files opened)\r\n;\r\n\tPUBLIC\tCHNENT\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tRUNFLG:WORD\r\nDSEG\tENDS\r\nCHNENT:\r\n\tMOV\tAL,LOW 201O\t;A=LEAVE FILES OPEN, RUN\r\n\tJMP\tSHORT NOTRN1\r\nNOTRNL:\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;restore [A]=1 for RUN, 0 for LOAD\r\nNOTRN1:\r\n\t\t\t\t;Variable  \",R\"    CHAIN   LOAD   RUN\r\n\tMOV\tBYTE PTR RUNFLG,AL\t;RUNFLG=  ^O201    ^O201      0     1\r\n\tOR\tAL,LOW 1\t;\r\n\tMOV\tBYTE PTR NLONLY,AL\t;NLONLY=  ^O201    ^O201      1     1\r\n\t\t\t\t;If NLONLY and 200 <> 0, don't close any files\r\n\t\t\t\t;If NLONLY and 001 <> 0, don't close file 0\r\n\tCALL\tSCRTCH\t\t;Clear variables, close files\r\n; BELOW IS FIX (TO LABEL NOTINI) SO THAT IF ^C DURING MBASIC FOO, WONT EXIT TO SYSTEM\r\n\tMOV\tBX,CURLIN\t;GET LINE NUMBER\r\n\tLAHF\r\n\tINC\tBX\t\t;SEE IF IN INITIALIZATION\r\n\tSAHF\r\n\tMOV\tAL,BH\r\n\tAND\tAL,BL\r\n\tINC\tAL\r\n\tJNZ\tSHORT NOTINI\t;NO\r\n\tMOV\tCURLIN,BX\t;SAVE DIRECT LINE NUMBER\r\nNOTINI:\r\n\tCALL\tINDSKC\t\t;READ THE FIRST CHARACTER\r\n\tJAE\tSHORT ??L006\r\n\tJMP\tMAIN\t\t;ALL DONE IF NOTHING IN FILE\r\n??L006:\r\n\tCMP\tAL,LOW 254\t;IS THIS A PROTECTED FILE?\r\n\tJNZ\tSHORT NTPROL\t;NO\r\n\tMOV\tBYTE PTR PROFLG,AL\t;SET PROTECTED FILE\r\n\tJMP\tSHORT BINLOD\t;DO BINARY LOAD\r\nNTPROL:\r\n\tINC\tAL\t\t;IS IT A BINARY FILE?\r\n\tJZ\tSHORT ??L007\r\n\tJMP\tMAINGO\t\t;NO, SINCE PTRFIL IS NON-ZERO\r\n??L007:\r\n\t\t\t\t;INCHR WILL USE INDSKC INSTEAD OF POLLING\r\n\t\t\t\t;THE TERMINAL\r\n\t\t\t\t;WHEN EOF IS HIT PTRFIL WILL BE RESTORED\r\n\t\t\t\t;AND LSTFRE WILL BE USED AS A FLAG\r\n\t\t\t\t;TO INDICATE WHETHER TO RUN THE\r\n\t\t\t\t;LOADED PROGRAM\r\n;\r\n; TIME FOR A BINARY LOAD.\r\n; AFTER THE LOAD, THE FILE IS LINKED TOGETHER\r\n; LSTFRE IS USED AS A FLAG WHETHER TO RUN OR NOT\r\n;\r\nBINLOD:\tMOV\tBX,TXTTAB\t;GET PLACE TO START STORING INTO\r\n\r\nEXTRN\tFSTLOD:NEAR\r\n\tCALL\tFSTLOD\t\t;USE FAST LOAD CODE IN DCPM.MAC\r\n\tEXTRN\tPROLOD:NEAR\r\n\tMOV\tVARTAB,BX\t;SAVE END TEMP FOR DECODING\r\n\tMOV\tAL,BYTE PTR PROFLG\t;IS THIS A PROTECTED FILE?\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJZ\tSHORT ??L008\r\n\tCALL\tPROLOD\r\n??L008:\t\t\t\t;TRANSLATE TO GOOD STUFF\r\n\tCALL\tLINKER\t\t;FIX THE LINKS\r\n\tINC\tBX\t\t;WHEN LINKER RETURNS, [H,L]\r\n\tINC\tBX\t\t;POINTS TO DOUBLE ZERO\r\n\tMOV\tVARTAB,BX\t;UPDATE [VARTAB]\r\n\tCALL\tRUNC\t\t;SETUP ARYTAB, STREND\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCHNFLG:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tCHNRET:NEAR\r\n\tMOV\tAL,BYTE PTR CHNFLG\t;CHAIN IN PROGRESS\r\n\tOR\tAL,AL\t\t;TEST\r\n\tJZ\tSHORT ??L009\r\n\tJMP\tCHNRET\t\t;YES, GO BACK TO CHAIN CODE\r\n??L009:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tNLONLY:WORD\r\nDSEG\tENDS\r\n\tXOR\tAL,AL\t\t;\r\n\tMOV\tBYTE PTR NLONLY,AL\t;allow all files to be closed\r\n\tCALL\tFINPRT\t\t;reset PTRFIL to 0 and close file 0\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tRUNFLG:WORD\r\nDSEG\tENDS\r\n\tMOV\tAL,BYTE PTR RUNFLG\t;RUN OR NOT?\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT ??L010\r\n\tJMP\tREADY\r\n??L010:\r\n\tJMP\tNEWSTT\r\n\r\nPRGFIN:\tCALL\tFINPRT\t\t;ZERO PTRFIL\r\n\tCALL\tCLSFIL\t\t;CLOSE FILE ZERO\r\n\tJMP\tGTMPRT\t\t;REFETCH TEXT POINTER\r\nPUBLIC\tOUTLOD\r\nOUTLOD:\tCALL\tSCRTCH\r\n\tJMP\tOMERR\r\n\r\n;MERGE filespec  Statement\r\n; (OKGETM is called by CHAIN MERGE ... in FIVEO)\r\n;\r\nMERGE:\tPOP\tCX\t\t;ELIMINATE NEWSTT RETURN\r\n\tCALL\tPRGFLI\t\t;READ THE NAME AND DISK\r\n\tDEC\tBX\t\t;MUST END THERE\r\n\tCALL\tCHRGTR\r\n\tJZ\tSHORT OKGETM\t;READ THE FILE\r\n\tCALL\tPRGFIN\t\t;CLOSE OUT TIME\r\n\tJMP\tSNERR\t\t;AND \"SYNTAX ERROR\"\r\nOKGETM:\tXOR\tAL,AL\t\t;NO RUN OPTION WITH \"MERGE\"\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tRUNFLG:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR RUNFLG,AL\t;SET UP THE RUN FLAG\r\n\tINC\tAL\r\n\tMOV\tBYTE PTR NLONLY,AL\t;NLONLY=1, don't close file 0\r\nPUBLIC\tOKGET2\r\nOKGET2:\r\n\tCALL\tINDSKC\t\t;READ FROM [PTRFIL] FILE\r\n\tJAE\tSHORT ??L011\r\n\tJMP\tMAIN\t\t;GO BACK IF EOF\r\n??L011:\r\n\tINC\tAL\t\t;IS IT A BINARY FILE??\r\n\tJNZ\tSHORT ??L012\r\n\tJMP\tDERBFM\t\t;BINARY IS WRONG FILE MODE\r\n??L012:\r\n\tINC\tAL\t\t;OR PROTECTED BINARY FILE??\r\n\tJNZ\tSHORT ??L013\r\n\tJMP\tDERBFM\t\t;ALSO GIVE BAD FILE MODE\r\n??L013:\r\n\tDEC\tAL\t\t;adjust [A] for 1st INR A above\r\n\t\t\t\t;so we can put it back (backup input file)\r\nMAINGO:\r\n\tDEC\tAL\t\t;[A]=character which was just read from file\r\n\tCALL\tBAKCHR\t\t;backup file PTRFIL\r\nEXTRN\tSCDASC:NEAR\r\n\tCALL\tSCDASC\t\t;set File Code to ASCII overridding user setting)\r\n\tJMP\tMAIN\r\n\r\n\r\n\tSUBTTL DISPATCH FOR DIRECT STATEMENT\r\n;\r\n; MAKE SURE WE'RE NOT READING A FILE IN\r\n;\r\n\r\n\tSUBTTL  SAVE COMMAND -- ASCII OR BINARY\r\n\r\nSAVE:\r\n\tPUSH\tBX\t\t;save text pointer for rescan of filename\r\n\tCALL\tFRMEVL\t\t;skip filename\r\n\tPUSH\tBX\r\n\tCALL\tFRESTR\t\t;release string temporary\r\n\tPOP\tBX\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\r\n\tJNZ\tSHORT ??L014\r\n\tJMP\tENDOFS\t\t;branch if end-of-statement\r\n??L014:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;eat comma\r\n\tCMP\tAL,LOW \"A\"\r\n\tJNZ\tSHORT ??L015\r\n\tJMP\tGOODSV\t\t;branch if got \"A\"\r\n??L015:\r\n\tCMP\tAL,LOW \"P\"\r\n\tJZ\tSHORT ??L016\r\n\tJMP\tSNERR\t\t;branch if not \"A\" or \"P\"\r\n??L016:\r\nGOODSV:\tPUSH\tBX\t\t;save text pointer\r\n\tPUSH\tAX\t\t;save \"A\" or \"P\"\r\n\tCALL\tCHRGTR\t\t;check for end-of-statement\r\n\tJZ\tSHORT ??L017\r\n\tJMP\tSNERR\t\t;error if not end-of-statement\r\n??L017:\r\n\tPOP\tAX\r\n\tPOP\tBX\t\t;leave text pointer pointing at \"A\" or \"P\"\r\nENDOFS:\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;save End-Of-Statement text pointer\r\n\t\t\t\t;HL = text pointer to filename\r\n\tPUSH\tAX\t\t;save \"A\", \"P\" or null option\r\n\tMOV\tDH,LOW OFFSET MD_SQO\t;ELIMINATE EARLIER VERSION OF FILE\r\n\t\t\t\t;AND CREATE EMPTY FILE\r\n\tCALL\tPRGFL2\t\t;parse file name and open it\r\n\tPOP\tAX\t\t;[A]=\"A\", \"P\" or null option\r\n\tPOP\tBX\t\t;restore End-Of-Statement text pointer\r\n\tEXTRN\tPROSAV:NEAR\r\n\tCMP\tAL,LOW \"P\"\t;PROTECTED SAVE?\r\n\tJNZ\tSHORT ??L018\r\n\tJMP\tPROSAV\t\t;DO IT\r\n??L018:\r\n\tCMP\tAL,LOW \"A\"\t;Ascii save?\r\n\tJZ\tSHORT ??L019\r\n\tJMP\tBINSAV\t\t;if not, must be Binary Save\r\n??L019:\r\n\tCALL\tCHRGTR\t\t;skip \"A\"\r\n\tCALL\tSCDASC\t\t;set File Code to ASCII (overridding user setting)\r\n\tJMP\tLIST\t\t;USE THE LIST CODE TO DO THE OUTPUT\r\n\t\t\t\t;CONTROL-CS ARE NOT ALLOWED\r\n\t\t\t\t;AND AT THE END PTRFIL IS ZEROED\r\n\tEXTRN\tBINSAV:NEAR\r\n\r\n\r\n\tSUBTTL  DRIVER CODE FOR CLOSE\r\n\r\n\r\n\tSUBTTL \"FIELD\" STATEMENT FOR SETTING UP I/O STRINGS\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tTEMPA:WORD,TEMPB:WORD\r\nDSEG\tENDS\r\nFIELD:\r\n\tCALL\tFILSCN\t\t;GET DATA BLOCK POINTER IN [B,C]\r\n\tEXTRN\tDERFNO:NEAR\r\n\tJNZ\tSHORT ??L020\r\n\tJMP\tDERFNO\t\t;error if File Not Opened\r\n??L020:\r\n\tSUB\tAL,LOW OFFSET MD_RND\t;MAKE SURE ITS A RANDOM FILE\r\n\tJZ\tSHORT ??L021\r\n\tJMP\tDERBFM\t\t;IF NOT, \"BAD FILE MODE\"\r\n??L021:\r\n\tXCHG\tBX,DX\t\t;SAVE TEXT POINTER\r\n\tMOV\tBX,OFFSET FD_SIZ\t;POINT TO RECORD SIZE\r\n\tADD\tBX,CX\r\n\tMOV\tBX,[BX]\t\t;GET IT\r\n\tMOV\tTEMPA,BX\t;STORE MAX ALLOWED\r\n\tMOV\tBX,0\t\t;ZERO MAX # OF CHARS\r\n\tMOV\tTEMPB,BX\r\n\tMOV\tAL,BH\t\t;MAKE [A]=0\r\n\tXCHG\tBX,DX\t\t;GET BACK TEXT POINTER\r\n\tMOV\tDX,OFFSET FD_DAT\t;POINT TO 5.0 FIELD BUFFER\r\nLOPFLD:\tXCHG\tBX,DX\t\t;SAVE TEXT POINTER IN [D,E]\r\n\tADD\tBX,CX\t\t;ADD ON DATA POINTER SO [H,L] NOW POINTS\r\n\t\t\t\t;AT THE START OF THE DATA\r\n\tMOV\tCH,AL\t\t;SETUP COUNT OF CHARACTERS PAST BY\r\n\t\t\t\t;IN DATA AREA, SO TOTAL IS NEVER GREATER THAN 128\r\n\tXCHG\tBX,DX\t\t;TEXT POINTER BACK INTO [H,L]\r\n\t\t\t\t;[D,E]=POINTER INTO DATA AREA\r\n\tMOV\tAL,BYTE PTR [BX]\t;MORE \"AS\"S TO SCAN?\r\n\tCMP\tAL,LOW 44\t;COMMA STARTS THE CLAUSE\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;BACK TO NEWSTT IF NOT\r\n\tPUSH\tDX\t\t;SAVE THE POINTER INTO THE DATA BLOCK\r\n\tPUSH\tCX\t\t;SAVE [B]=NUMBER OF CHARACTERS ALLOCATED\r\n\tCALL\tGTBYTC\t\t;READ NUMBER INTO [A] FROM TEXT\r\n\tPUSH\tAX\t\t;SAVE THIS NUMBER\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"A\"\t;SCAN THE \"AS\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"S\"\r\n\tCALL\tPTRGET\t\t;GET A POINTER AT THE STRING DESCRIPTOR\r\n\tCALL\tFRCSTR\t\t;INTO [D,E]\r\n\tPOP\tAX\t\t;GET THE NUMBER OF CHARACTERS\r\n\tPOP\tCX\t\t;GET THE NUMBER ALREADY USED\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE THE TEXT POINTER AND\r\n\t\t\t\t;[H,L]=POINTER INTO DATA BLOCK\r\n\tMOV\tCL,AL\t\t;SAVE # OF CHARACTERS IN [C]\r\n\tPUSH\tDX\t\t;SAVE [D,E]\r\n\tPUSH\tBX\t\t;SAVE [H,L]\r\n\tMOV\tBX,TEMPB\t;GET TOTAL SO FAR\r\n\tMOV\tCH,LOW 0\t;ACCUMULATE COUNT\r\n\tADD\tBX,CX\t\t;Add in current field size\r\n\tMOV\tTEMPB,BX\t;SAVE TOTAL AGAIN\r\n\tXCHG\tBX,DX\t\t;TOTAL TO [D,E]\r\n\tMOV\tBX,TEMPA\t;GET MAX ALLOWED\r\n\tCMP\tBX,DX\t\t;IN RANGE?\r\n\tJAE\tSHORT ??L022\r\n\tJMP\tDERFOV\t\t;NO, GIVE ERROR\r\n??L022:\r\n\tPOP\tBX\t\t;RESTORE [H,L]\r\n\tPOP\tDX\t\t;RESTORE [D,E]\r\n\tXCHG\tBX,DX\t\t;[H,L] POINT AT STRING DESCRIPTOR\r\n\tMOV\tBYTE PTR [BX],CL\t;STORE THE LENGTH\r\n\tINC\tBX\r\n\tMOV\t[BX],DX\t\t;STORE THE POINTER INTO THE DATA BLOCK\r\n\tPOP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tJMP\tSHORT LOPFLD\t;CONTINUE SCANNING \"AS\" CLAUSES IF MORE\r\n\r\n\tSUBTTL  Random Non-I/O -- LSET/RSET/FIELD\r\n\r\n;LSET/RSET stringvar = stringexp\r\n;\r\n; If stringvar points to an I/O buffer, use the string size to\r\n;justify string. If stringvar is a literal, make new var with length\r\n;of literal. If stringvar points to string space, use it. If the\r\n;length of the variable is zero, return the null string. If a copy\r\n;must be created, and stringexp is a temporary, use this space over\r\n;unless length stringvar greater than stringexp.\r\n\r\nRSET:\tOR\tAL,LOW 0\t;clear carry\r\n\tJMP\tSHORT LSETA\r\nLSET:\tSTC\t\t\t;Set carry if lset\r\nLSETA:\r\n\tPUSHF\t\t\t;Save LSET/RSET flag\r\n\tCALL\tPTRGET\t\t;Get pointer to stringvar\r\n\tCALL\tFRCSTR\t\t;Must be a string variable\r\n\tPUSH\tDX\t\t;Save pointer to descriptor\r\n\tCALL\tFRMEQL\t\t;EAT \"=\" AND EVALUATE STRINGEXP\r\n\tPOP\tCX\t\t; [B,C] = ptr to descr.\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;Text ptr on bottom of stack\r\n\tPUSH\tBX\t\t;LSET/RSET flag next\r\n\tPUSH\tCX\t\t;Put descr. ptr back on\r\n\tCALL\tFRESTR\t\t;Error if not string, free temp.\r\n\tMOV\tCH,BYTE PTR [BX]\t;Get length of stringexp\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t; [H,L] = descr. of var,save othr\r\n\tMOV\tAL,BYTE PTR [BX]\t;Get length of stringvar\r\n\tMOV\tCL,AL\t\t;Save in [C]\r\n\tPUSH\tCX\t\t;Save lengths of both\r\n\tPUSH\tBX\t\t;Save descriptor pointer\r\n\tPUSHF\t\t\t;PSW zero if was temp.\r\n\tINC\tBX\r\n\tMOV\tDX,[BX]\t\t;get point to stringvar text\r\n\tOR\tAL,AL\t\t;stringvar null?\r\n\tJZ\tSHORT RETCUR\t;Yes, don't change\r\n\tMOV\tBX,TXTTAB\r\n\tCMP\tBX,DX\t\t;Stringvar in disk buffer?\r\n\tJAE\tSHORT OLDSTR\t;Yes, use it\r\n\tMOV\tBX,VARTAB\r\n\tCMP\tBX,DX\t\t;stringvar in program(literal)?\r\n\tJB\tSHORT OLDSTR\t;No, in string space so use it\r\n;Need to make new string for result since stringvar points to a literal.\r\n;If stringexp was a temporary, it has been freed. If the length of\r\n;stringexp is greater than or equal to the length of stringvar, GETSPA\r\n;can be called and no garbage collection can occur so temp. can be reused.\r\n;If stringvar is greater, must get a temp. to point to stringexp if it\r\n;was a temp. , then call GETSPA which in this case can garbage collect.\r\n\tMOV\tDL,CL\r\n\tMOV\tDH,LOW 0\t;# BYTES TO ALLOCATE FOR RESULT\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSTREND:WORD\r\nDSEG\tENDS\r\n\tMOV\tBX,STREND\r\n\tADD\tBX,DX\r\n\tXCHG\tBX,DX\r\n\tMOV\tBX,FRETOP\r\n\tCMP\tBX,DX\t\t;will GETSPA garbage collect?\r\n\tJB\tSHORT MAKDSC\t;Yes, better have stringexp temp.\r\n\tPOPF\t\t\t;get rid of temp indicator\r\nMADESC:\tMOV\tAL,CL\t\t;Get length of stringvar\r\n\tCALL\tGETSPA\t\t;Get space for result\r\n\tPOP\tBX\t\t;Get stringvar descr.\r\n\tPOP\tCX\t\t;Get lengths off stack\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;Get what we wanted, stringexp descr.\r\n\tPUSH\tDX\r\n\tPUSH\tCX\r\n\tCALL\tFRESTR\t\t;Free temp if any\r\n\tPOP\tCX\r\n\tPOP\tDX\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\r\n\tPUSH\tCX\t\t;Restore stack to previous state\r\n\tPUSH\tBX\r\n\tINC\tBX\r\n\tPUSHF\r\n\tMOV\t[BX],DX\t\t;set pointer to stringvar copy\r\nOLDSTR:\tPOPF\r\n\tPOP\tBX\t\t;Get stringvar descr.\r\n\tINC\tBX\r\n\tMOV\tDX,[BX]\t\t;Get pointer to text area\r\n\tPOP\tCX\t\t;Get lengths off stack\r\n\tPOP\tBX\t\t;Get pointer to stringexp descr.\r\n\tINC\tBX\t\t;point to address part\r\n\tMOV\tBX,[BX]\t\t;Get ptr to stringexp text\r\n\tMOV\tAL,CL\t\t;Get length of field(stringvar)\r\n\tCMP\tAL,CH\r\n\tJAE\tSHORT FILDOK\t;Jump if field large enough for result\r\n\tMOV\tCH,AL\t\t;Save # of bytes to copy\r\nFILDOK:\tSUB\tAL,CH\r\n\tMOV\tCL,AL\t\t;[C] = # blanks to fill\r\n\tPOPF\t\t\t;Get LSET/RSET flag\r\n\tJNAE\tSHORT ??L023\r\n\tCALL\tBLKFIL\t\t;Fill leading if RSET\r\n??L023:\r\n\tINC\tCH\t\t;In case zero\r\nCOPLOP:\tDEC\tCH\t\t;Decr. # to copy\r\n\tJZ\tSHORT LRSTDN\t;Done when all copied\r\n\tMOV\tAL,BYTE PTR [BX]\t;Get byte from stringexp\r\n\tMOV\tDI,DX\r\n\tSTOSB\t\t\t;Copy to stringvar\r\n\tINC\tBX\r\n\tINC\tDX\r\n\tJMP\tSHORT COPLOP\r\n\r\nRETCUR:\tPOP\tCX\r\n\tPOP\tCX\r\n\tPOP\tCX\r\n\tPOP\tCX\r\n\tPOP\tCX\t\t;Get garb off stack\r\nLRSTDN:\tJNB\tSHORT ??L024\r\n\tCALL\tBLKFIL\t\t;Fill trailing if LSET\r\n??L024:\r\n\tPOP\tBX\t\t;Restore text pointer\r\n\tRET\t\r\n\r\nBLKFIL:\tMOV\tAL,LOW \" \"\t;Fill with spaces\r\n\tINC\tCL\t\t;In case zero\r\nBLKFL1:\tDEC\tCL\t\t;Decr. # to fill\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;Return when done\r\n\tMOV\tDI,DX\r\n\tSTOSB\t\t\t;Store space\r\n\tINC\tDX\r\n\tJMP\tSHORT BLKFL1\r\n\r\n; If stringexp was a temporary, create a new temporary to point to\r\n; stringexp since old one was freed. This must be done since GETSPA\r\n; will be called and garbage collection might occur. If stringexp is\r\n; not a temporary, return.\r\n\r\nMAKDSC:\tPOPF\t\t\t;Get temp flag\r\n\tPOP\tBX\r\n\tPOP\tCX\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;Dig down to stringexp descr.\r\n\tXCHG\tBX,DX\t\t;FRETMS wants [D,E]\r\n\tJNZ\tSHORT MAKDS1\t;Not a temp, don't reallocate\r\n\tPUSH\tCX\r\n\tMOV\tAL,CH\r\n\tCALL\tSTRINI\t\t;Make a temp point to stringexp\r\n\tCALL\tPUTNEW\t\t;Get a temp to point to it\r\n\tPOP\tCX\r\nMAKDS1:\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\r\n\tPUSH\tCX\r\n\tPUSH\tBX\t\t;Restore stack to previous state\r\n\tJMP\tMADESC\r\n\r\n\tSUBTTL  Program I/O -- Fixed Length INPUT\r\n\r\n; Format:\r\n;               stringvar = INPUT$(#bytes[,[#] file#])\r\n;If no file # is given, characters will be read from the user's\r\n; terminal. No echoing will be done and no editing will be allowed\r\n; (i.e. rubout,@,_,^U are just input as characters).\r\n\r\n\tPUBLIC\tFIXINP\r\nFIXINP:\tCALL\tCHRGTR\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"$\"\t;STRING FUNCTION\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"(\"\r\n\tPUSH\tBX\t\t;Preserve PTRFIL across INPUT$ so\r\n\tMOV\tBX,PTRFIL\t;cases like PRINT #2,INPUT$(3,#1)\r\n\tMOV\tDX,0\t\t;will work properly.\r\n\tMOV\tPTRFIL,DX\t;(Clear PTRFIL in case no file number\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;is specified.)\r\n\tCALL\tGETBYT\t\t;Get # of bytes to read\r\n\tPUSH\tDX\t\t;Save # of bytes to read\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tCMP\tAL,LOW 54O\t;Read from disk file?\r\n\tJNZ\tSHORT REDTTY\t;No, from user's terminal\r\n\tCALL\tCHRGTR\r\n\tCALL\tFILSCN\t\t;Set up file #\r\n\tEXTRN\tDERFNO:NEAR\r\n\tJNZ\tSHORT ??L025\r\n\tJMP\tDERFNO\t\t;error if File Not Open\r\n??L025:\r\n\tCMP\tAL,LOW OFFSET MD_SQO\t;SEQUENTIAL OUTPUT FILE?\r\n\tJNZ\tSHORT ??L026\r\n\tJMP\tDERBFM\r\n??L026:\t\t\t\t;THEN BAD FILE MODE\r\n\tCALL\tFILSET\t\t;SET UP PTRFIL\r\n\tXOR\tAL,AL\t\t;SET ZERO FOR FLAG\r\nREDTTY:\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\t\t;NON ZERO SET IF TERMINAL I/O\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\t;Must have paren\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;Get flag off stack\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;Save text ptr, [L]=# to read\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\t\t;Save flag\r\n\tMOV\tAL,BL\r\n\tOR\tAL,AL\t\t;Read no characters?\r\n\tJNZ\tSHORT ??L027\r\n\tJMP\tFCERR\t\t;Yes, error\r\n??L027:\r\n\tPUSH\tBX\t\t;Save #\r\n\tCALL\tSTRINI\t\t;Get space for string\r\n\tXCHG\tBX,DX\r\n\tPOP\tCX\t\t;[C] = # to read\r\nFIXLOP:\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\t\t;NON-ZERO set if should read from TTY\r\n\tJZ\tSHORT DSKCHR\t;Read from disk file\r\n\tCALL\tINCHRI\t\t;Read a char from terminal\r\nCHARCW:\r\n;Note : will check flag on interrupt ^c\r\nPUTCHR:\tMOV\tBYTE PTR [BX],AL\t;Put char into string\r\n\tINC\tBX\r\n\tDEC\tCL\t\t;Read enough yet?\r\n\tJNZ\tSHORT FIXLOP\t;No, read more\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSAVKEY:WORD\t;Second half of two-byte key\r\nDSEG\tENDS\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR SAVKEY,AL\t;Clear saved second byte\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;Get flag off stack\r\n\tPOP\tCX\t\t;B:=text pointer.\r\n\tPOP\tBX\t\t;Restore PTRFIL.\r\n\tMOV\tPTRFIL,BX\r\n\tPUSH\tCX\t\t;Restack the text pointer.\r\n\tJMP\tPUTNEW\t\t;Return string as result\r\n\r\nDSKCHR:\tCALL\tINDSKC\t\t;Get char from file\r\n\tJAE\tSHORT ??L028\r\n\tJMP\tDERRPE\t\t;If carry, read past EOF\r\n??L028:\r\n\tJMP\tSHORT PUTCHR\t;Put char in string\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "FIVEO.ASM",
          "type": "blob",
          "size": 23.5,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE FIVEO 5.0 Features -WHILE/WEND, CALL, CHAIN, WRITE /P. Allen\r\n\r\n\t.SALL\r\n\t.RADIX\t10\r\n\r\nTSHIBA=0\r\nPC8A=0\r\n\tLABEL=PC8A\r\nOKI=0\r\n\tINCLUDE\tGIO86U\r\n\tINCLUDE\tMSDOSU\r\nIF\tCPM86  \r\n\tINCLUDE\tCPM86U\r\nENDIF \r\n\r\n\tEXTRN\tRESTORE:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tSUBFLG:WORD,TEMP:WORD\r\nDSEG\tENDS\r\n\r\n\t\t\t\t; Code Segment ( terminated by END at bottom of file )\r\n\r\n\tEXTRN\tCHRGTR:NEAR,SYNCHR:NEAR,DCOMPR:NEAR\r\n\tEXTRN\tGETYPR:NEAR\r\n\tEXTRN\tSNERR:NEAR,GETSTK:NEAR,PTRGET:NEAR,CRDO:NEAR\r\n\tEXTRN\tVMOVFM:NEAR\r\n\tEXTRN\tFRQINT:NEAR\r\n\r\n\tSUBTTL  WHILE , WEND\r\n\tPUBLIC\tWHILE,WEND\r\n\tEXTRN\tERROR:NEAR,FRMCHK:NEAR,$FOR:NEAR,$WHILE:NEAR,WNDSCN:NEAR\r\n\tEXTRN\tFRMEVL:NEAR\r\n\tEXTRN\tNEWSTT:NEAR,FORSZC:NEAR,ERRWE:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSAVSTK:WORD,NXTLIN:WORD,CURLIN:WORD,ENDFOR:WORD\r\nDSEG\tENDS\r\n;\r\n; THIS CODE HANDLES THE STATEMENTS WHILE/WEND\r\n; THE 8080 STACK IS USED TO PUT AN ENTRY ON FOR EACH ACTIVE WHILE\r\n; THE SAME WAY ACTIVE GOSUB AND FOR ENTRIES ARE MADE.\r\n; THE FORMAT IS AS FOLLOWS:\r\n;       $WHILE - THE TOKEN IDENTIFYING THE ENTRY (1 BYTE)\r\n;       A TEXT POINTER AT THE CHARACTER AFTER THE WEND OF THE WHILE BODY (2 BYTES)\r\n;       A TEXT POINTER AT THE CHARACTER AFTER THE WHILE OF THE WHILE BODY (2 BYTES)\r\n;       THE LINE NUMBER OF THE LINE THAT THE WHILE IS ON (2 BYTES)\r\n;\r\n;       TOTAL   7 BYTES\r\n;\r\nWHILE:\t\t\t\t;KEEP THE WHILE TEXT POINTER HERE\r\n\tMOV\tENDFOR,BX\t;SAVE TEXT ADDRESS\r\n\tCALL\tWNDSCN\t\t;SCAN FOR THE MATCHING WEND\r\n\t\t\t\t;CAUSE AN ERRWH IF NO WEND TO MATCH\r\n\tCALL\tCHRGTR\t\t;POINT AT CHARACTWER AFTER WEND\r\n\tXCHG\tBX,DX\t\t;POSITION OF MATCHING WEND\r\n\tCALL\tFNDWND\t\t;SEE IF THERE IS A STACK ENTRY FOR THIS WHILE\r\n\tLAHF\r\n\tINC\tSP\t\t;GET RID OF THE NEWSTT ADDRESS ON THE STACK\r\n\tSAHF\r\n\tLAHF\r\n\tINC\tSP\r\n\tSAHF\r\n\tJNZ\tSHORT WNOTOL\t;IF NO MATCH NO NEED TO TRUNCATE THE STACK\r\n\tADD\tBX,CX\t\t;ELIMINATE EVERYTHING UP TO AND INCLUDING\r\n\t\t\t\t;THE MATCHING WHILE ENTRY\r\n\tMOV\tSP,BX\r\n\tMOV\tSAVSTK,BX\r\nWNOTOL:\tMOV\tBX,CURLIN\t;MAKE THE STACK ENTRY\r\n\tPUSH\tBX\r\n\tMOV\tBX,ENDFOR\t;GET TEXT POINTER FOR WHILE BACK\r\n\tPUSH\tBX\r\n\tPUSH\tDX\t\t;SAVE THE WEND TEXT POINTER\r\n\tJMP\tSHORT FNWEND\t;FINISH USING WEND CODE\r\n\r\nWEND:\tJZ\tSHORT ??L000\r\n\tJMP\tSNERR\t\t;STATEMENT HAS NO ARGUMENTS\r\n??L000:\r\n\tXCHG\tBX,DX\t\t;FIND MATCHING WHILE ENTRY ON STACK\r\n\tCALL\tFNDWND\r\n\tJNZ\tSHORT WEERR\t;MUST MATCH OR ELSE ERROR\r\n\tMOV\tSP,BX\t\t;TRUNCATE STACK AT MATCH POINT\r\n\tMOV\tSAVSTK,BX\t;[H,L] POINTING INTO STACK ENTRY\r\n\tMOV\tDX,CURLIN\t;REMEMBER WEND LINE #\r\n\tMOV\tNXTLIN,DX\t;IN NXTLIN\r\n\tINC\tBX\t\t;INDEX INTO STACK ENTRY TO GET VALUES\r\n\tINC\tBX\t\t;SKIP OVER TEXT POINTER OF WEND\r\n\tMOV\tDX,[BX]\t\t;SET [D,E]=TEXT POINTER OF WHILE\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tMOV\tBX,[BX]\t\t;[H,L]=LINE NUMBER OF WHILE\r\n\tMOV\tCURLIN,BX\t;IN CASE OF ERROR OR CONTINUATION FIX CURLIN\r\n\tXCHG\tBX,DX\t\t;GET TEXT POINTER OF WHILE FORMULA INTO [H,L]\r\nFNWEND:\tCALL\tFRMEVL\t\t;EVALUATE FORMULA\r\n\tEXTRN\tVSIGN:NEAR\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\tVSIGN\t\t;GET IF TRUE OR FALSE\r\n\tPOP\tBX\t\t;GET BACK WHILE TEXT POINTER\r\n\tJZ\tSHORT FLSWHL\t;GO BACK AT WEND IF FALSE\r\n\tMOV\tCX,OFFSET $WHILE\t;COMPLETE WHILE ENTRY\r\n\tMOV\tCH,CL\t\t;NEED IT IN THE HIGH BYTE\r\n\tPUSH\tCX\r\n\tJMP\tNEWSTT\r\n\r\nFLSWHL:\tMOV\tBX,NXTLIN\t;SETUP CURLIN FOR WEND\r\n\tMOV\tCURLIN,BX\r\n\tPOP\tBX\t\t;TAKE OFF TEXT OF WEND AS NEW TEXT POINTER\r\n\tPOP\tCX\t\t;GET RID OF TEXT POINTER OF WHILE\r\n\tPOP\tCX\t\t;TAKE OFF LINE NUMBER OF WHILE\r\n\tJMP\tNEWSTT\r\n;\r\n; THIS SUBROUTINE SEARCHES THE STACK FOR AN WHILE ENTRY\r\n; WHOSE WEND TEXT POINTER MATCHES [D,E]. IT RETURNS WITH ZERO TRUE\r\n; IF A MATCH IS FOUND AND ZERO FALSE OTHERWISE. FOR ENTRIES\r\n; ARE SKIPPED OVER, BUT GOSUB ENTRIES ARE NOT.\r\n;\r\n\tWHLSIZ=7\r\n\r\n\r\n;\r\n; Note - 8086 versions force stack entries to be an even length\r\n; so stack accesses won't cross word boundaries.  This is done\r\n; for speed.  To accomplish this, an extra byte is pushed on\r\n; top of the WHILE token.  This extra byte is NOT reflected in\r\n; the value of WHLSIZ but is taken care of by the code.\r\n;\r\n\r\nFNDWND:\tMOV\tBX,4\t\t;SKIP OVER RETURN ADDRESS AND NEWSTT\r\n\tADD\tBX,SP\r\nFNDWN2:\r\n\tINC\tBX\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE ENTRY TYPE\r\n\tINC\tBX\r\n\tMOV\tCX,OFFSET $FOR\r\n\tCMP\tAL,CL\t\t;SEE IF ITS $FOR\r\n\tJNZ\tSHORT FNDWN3\r\n\tMOV\tCX,OFFSET FORSZC-1\t;Yes, so skip over it.  Note that\r\n\tADD\tBX,CX\t\t;the pointer has already been\r\n\tJMP\tSHORT FNDWN2\t;incremented once.\r\n\r\nFNDWN3:\tMOV\tCX,OFFSET $WHILE\r\n\tCMP\tAL,CL\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tINS86\t71,27\t\t;CMP [BX],DX-SAME WEND?\r\n\tMOV\tCX,OFFSET WHLSIZ-1\t;Note that the pointer has\r\n\t\t\t\t;already been incremented once.\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;RETURN IF ENTRY MATCHES\r\n\tADD\tBX,CX\r\n\tJMP\tSHORT FNDWN2\r\n\r\nWEERR:\tMOV\tDX,OFFSET ERRWE\r\n\tJMP\tERROR\r\n\r\n\r\n\tSUBTTL  CHAIN\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tTXTTAB:WORD,VALTYP:WORD\r\nDSEG\tENDS\r\n\tEXTRN\t$COMMON:NEAR,$MERGE:NEAR,FRMEVL:NEAR,OMERR:NEAR,SCRTCH:NEAR\r\n\tEXTRN\tLINGET:NEAR\r\n\tEXTRN\t$DELETE:NEAR\r\n\tPUBLIC\tCHAIN,COMMON\r\n\tEXTRN\tPTRGTN:NEAR,PTRGTR:NEAR\r\n\tEXTRN\tMOVE1:NEAR,NEWSTT:NEAR,PTRGET:NEAR,STRCPY:NEAR\r\n\tEXTRN\tGARBA2:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFRETOP:WORD\r\nDSEG\tENDS\r\n;\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSAVFRE:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tIADAHL:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tEXTRN\tTEMP3:WORD,TEMP9:WORD,VARTAB:WORD,ARYTAB:WORD,CHNFLG:WORD\r\n\tEXTRN\tSTREND:WORD\r\n\tEXTRN\tCURLIN:WORD,SAVSTK:WORD,ENDBUF:WORD,MRGFLG:WORD,MDLFLG:WORD\r\n\tEXTRN\tCHNLIN:WORD,CMEPTR:WORD,CMSPTR:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tBLTUC:NEAR,DATA:NEAR\r\n\tEXTRN\tFNDLIN:NEAR,USERR:NEAR,ERSFIN:NEAR,FCERR:NEAR,NOARYS:NEAR\r\n\tEXTRN\tDEL:NEAR,LINKER:NEAR,SCNLIN:NEAR,FRQINT:NEAR\r\n; This is the code for the CHAIN statement\r\n; The syntax is:\r\n; CHAIN [MERGE]<file name>[,[<line number>][,ALL][,DELETE <range>]]\r\n; The steps required to execute a CHAIN are:\r\n;\r\n; 1.) Scan arguments\r\n;\r\n; 2.) Scan program for all COMMON statements and\r\n;       mark specified variables.\r\n;\r\n; 3.) Squeeze unmarked entries from symbol table.\r\n;\r\n; 4.) Copy string literals to string space\r\n;\r\n; 5.) Move all simple variables and arrays into the\r\n;       bottom of string space.\r\n;\r\n; 6.) Load new program\r\n;\r\n; 7.) Move variables back down positioned after program.\r\n;\r\n; 8.) Run program\r\nCHAIN:\r\n\tXOR\tAL,AL\t\t;Assume no MERGE\r\n\tMOV\tBYTE PTR MRGFLG,AL\r\n\tMOV\tBYTE PTR MDLFLG,AL\t;Also no MERGE w/ DELETE option\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tOPTFLG:WORD,TOPTFG:WORD,OPTVAL:WORD,TOPTVL:WORD\r\nDSEG\tENDS\r\n\tMOV\tAL,BYTE PTR OPTFLG\r\n\tMOV\tBYTE PTR TOPTFG,AL\t;SAVE OPTION BASE VALUE\r\n\tMOV\tAL,BYTE PTR OPTVAL\t;SAVE OPTION VALUE FOR ARRAY BASE\r\n\tMOV\tBYTE PTR TOPTVL,AL\r\n\tMOV\tAL,BYTE PTR [BX]\t;Get current char\r\n\tMOV\tDX,OFFSET $MERGE\t;Is it MERGE?\r\n\tCMP\tAL,DL\t\t;Test\r\n\tJNZ\tSHORT NTCHNM\t;NO\r\n\tMOV\tBYTE PTR MRGFLG,AL\t;Set MERGE flag\r\n\tINC\tBX\r\nNTCHNM:\tDEC\tBX\t\t;Rescan file name\r\n\tCALL\tCHRGTR\r\n\tEXTRN\tPRGFLI:NEAR\r\n\tCALL\tPRGFLI\t\t;Evaluate file name and OPEN it\r\n\tPUSH\tBX\t\t;Save text pointer\r\n\tMOV\tBX,0\t\t;Get zero\r\n\tMOV\tCHNLIN,BX\t;Assume no CHAIN line #\r\n\tPOP\tBX\t\t;Restore text pointer\r\n\tDEC\tBX\t\t;Back up pointer\r\n\tCALL\tCHRGTR\t\t;Scan char\r\n\tJNZ\tSHORT ??L001\r\n\tJMP\tNTCHAL\t\t;No line number etc.\r\n??L001:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;Must be comma\r\n\tCMP\tAL,LOW 54O\t;Ommit line # (Use ALL for instance)\r\n\tJZ\tSHORT NTLINF\t;YES\r\n\tCALL\tFRMEVL\t\t;Evaluate line # formula\r\n\tPUSH\tBX\t\t;Save text poiner\r\n\tCALL\tFRQINT\t\t;Force to int in [H,L]\r\n\tMOV\tCHNLIN,BX\t;Save it for later\r\n\tPOP\tBX\t\t;Restore text poiner\r\n\tDEC\tBX\t\t;Rescan last char\r\n\tCALL\tCHRGTR\r\n\tJZ\tSHORT NTCHAL\t;No ALL i.e. preserve all vars across CHAIN\r\nNTLINF:\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;Should be comma here\r\n\tMOV\tDX,OFFSET $DELETE\t;Test for DELETE option\r\n\tCMP\tAL,DL\t\t;Is it?\r\n\tJZ\tSHORT CHMWDL\t;Yes\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"A\"\t;Check for \"ALL\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"L\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"L\"\r\n\tJNZ\tSHORT ??L002\r\n\tJMP\tDNCMDA\t\t;Goto step 3\r\n??L002:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;Force comma to appear\r\n\tCMP\tAL,DL\t\t;Must be DELETE\r\n\tJZ\tSHORT ??L003\r\n\tJMP\tSNERR\t\t;No, give error\r\n??L003:\r\n\tOR\tAL,AL\t\t;Flag to goto DNCMDA\r\nCHMWDL:\tPUSHF\t\t\t;Save ALL flag\r\n\tMOV\tBYTE PTR MDLFLG,AL\t;Set MERGE w/ DELETE\r\n\tCALL\tCHRGTR\t\t;Get char after comma\r\n\tCALL\tSCNLIN\t\t;Scan line range\r\n\tEXTRN\tDEPTR:NEAR\r\n\tPUSH\tCX\r\n\tCALL\tDEPTR\t\t;Change pointers back to numbers\r\n\tPOP\tCX\r\n\tPOP\tDX\t\t;Pop max line off stack\r\n\tPUSH\tCX\t\t;Save pointer to start of 1st line\r\n\tMOV\tBX,CX\t\t;Save pointer to start line\r\n\tMOV\tCMSPTR,BX\r\n\tCALL\tFNDLIN\t\t;Find the last line\r\n\tJAE\tSHORT FCERRG\t;Must have exact match on end of range\r\n\tMOV\tDH,BH\t\t;[D,E] =  pointer at the start of the line\r\n\tMOV\tDL,BL\t\t;beyond the last line in the range\r\n\tMOV\tCMEPTR,BX\t;Save pointer to end line\r\n\tPOP\tBX\t\t;Get back pointer to start of range\r\n\tCMP\tBX,DX\t\t;Make sure the start comes before the end\r\nFCERRG:\tJNAE\tSHORT ??L004\r\n\tJMP\tFCERR\t\t;If not, \"Illegal function call\"\r\n??L004:\r\n\tPOPF\t\t\t;Flag that says whether to go to DNCMDA\r\n\tJZ\tSHORT ??L005\r\n\tJMP\tDNCMDA\t\t;\"ALL\" option was present\r\n??L005:\r\nNTCHAL:\tMOV\tBX,CURLIN\t;Save current line number on stack\r\n\tPUSH\tBX\r\n\tMOV\tBX,TXTTAB\t;Start searching for COMMONs at program start\r\n\tDEC\tBX\t\t;Compensate for next instr\r\nCLPSC1:\tINC\tBX\t\t;Look at first char of next line\r\nCLPSCN:\tMOV\tAL,BYTE PTR [BX]\t;Get char from program\r\n\tINC\tBX\r\n\tOR\tAL,BYTE PTR [BX]\t;Are we pointing to program end?\r\n\tJNZ\tSHORT ??L006\r\n\tJMP\tCLPFIN\t\t;Yes\r\n??L006:\r\n\tINC\tBX\r\n\tMOV\tDX,[BX]\t\t;Get line # in [D,E]\r\n\tINC\tBX\r\n\tMOV\tCURLIN,DX\t;Save current line # in CURLIN for errors\r\nCSTSCN:\tCALL\tCHRGTR\t\t;Get statment type\r\nAFTCOM:\tOR\tAL,AL\r\n\tJZ\tSHORT CLPSC1\t;EOL Scan next one\r\n\tCMP\tAL,LOW \":\"\t;Are we looking at colon\r\n\tJZ\tSHORT CSTSCN\t;Yes, get next statement\r\n\tCMP\tAL,LOW 254D\t;COMMONs prceeded by 254\r\n\tJNZ\tSHORT NOCOMM\t;not one\r\n\tINC\tBX\t\t;move ahead\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tMOV\tDX,OFFSET $COMMON\t;Test for COMMON, avoid byte externals\r\n\tCMP\tAL,DL\t\t;Is it a COMMON?\r\n\tJZ\tSHORT DOCOMM\t;Yes, handle it\r\n\tDEC\tBX\t\t;Back up the pointer.\r\nNOCOMM:\tCALL\tCHRGTR\t\t;Get first char of statement\r\n\tCALL\tDATA\t\t;Skip over statement\r\n\tDEC\tBX\t\t;Back up to rescan terminator\r\n\tJMP\tSHORT CSTSCN\t;Scan next one\r\nDOCOMM:\tCALL\tCHRGTR\t\t;Get thing after COMMON\r\n\tJZ\tSHORT AFTCOM\t;Get next thing\r\nNXTCOM:\tPUSH\tBX\t\t;Save text pointer\r\n\tMOV\tAL,LOW 1\t;Call PTRGET to search for array\r\n\tMOV\tBYTE PTR SUBFLG,AL\r\n\tCALL\tPTRGTN\t\t;This subroutine in F3 scans variables\r\n\tJZ\tSHORT FNDAAY\t;Found array\r\n\tMOV\tAL,CH\t\t;Try finding array with COMMON bit set\r\n\tOR\tAL,LOW 128D\r\n\tMOV\tCH,AL\r\n\tXOR\tAL,AL\t\t;Set zero CC\r\n\tCALL\tERSFIN\t\t;Search array table\r\n\tMOV\tAL,LOW 0\t;Clear SUBFLG in all cases\r\n\tMOV\tBYTE PTR SUBFLG,AL\r\n\tJNZ\tSHORT NTFN2T\t;Not found, try simple\r\n\tMOV\tAL,BYTE PTR [BX]\t;Get terminator, should be \"(\"\r\n\tCMP\tAL,LOW \"(\"\t;Test\r\n\tJNZ\tSHORT SCNSMP\t;Must be simple then\r\n\tPOPF\t\t\t;Get rid of saved text pointer\r\n\tJMP\tSHORT COMADY\t;Already was COMMON, ignore it\r\nNTFN2T:\tMOV\tAL,BYTE PTR [BX]\t;Get terminator\r\n\tCMP\tAL,LOW \"(\"\t;Array specifier?\r\n\tPOP\tDX\t\t;(DE:=saved text pointer.)\r\n\tJZ\tSHORT SKPCOM\t;Yes, undefined array - just skip it.\r\n\tPUSH\tDX\t\t;No, resave pointer to start of variable\r\nSCNSMP:\tPOP\tBX\t\t;Rescan variable name for start\r\n\tCALL\tPTRGTN\t\t;Evaluate as simple\r\n\tOR\tDX,DX\t\t;If var not found, [D,E]=0\r\n\tJNZ\tSHORT COMFNS\t;Found it\r\n\tMOV\tAL,CH\t\t;Try to find in COMMON\r\n\tOR\tAL,LOW 128D\t;Set COMMON bit\r\n\tMOV\tCH,AL\r\n\tMOV\tDX,OFFSET COMPT2\t;push on return address\r\n\tPUSH\tDX\r\n\tMOV\tDX,OFFSET PTRGTR\t;address to common return point\r\n\tPUSH\tDX\r\n\tMOV\tAL,BYTE PTR VALTYP\t;Must have VALTYP in [D]\r\n\tMOV\tDH,AL\r\n\tJMP\tNOARYS\t\t;Search symbol table\r\nCOMPT2:\tOR\tDX,DX\t\t;Found?\r\n\tJZ\tSHORT SKPCOM\t;No, just skip over this variable.\r\nCOMFNS:\tPUSH\tBX\t\t;Save text pointer\r\n\tMOV\tCH,DH\t\t;Get pointer to var in [B,C]\r\n\tMOV\tCL,DL\r\n\tMOV\tBX,OFFSET BCKUCM\t;Loop back here\r\n\tPUSH\tBX\r\nCBAKBL:\tDEC\tCX\t\t;Point at first char of rest\r\nLPBKNC:\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\t\t;Back up until plus byte\r\n\tDEC\tCX\r\n\tOR\tAL,AL\r\n\tJNS\tSHORT ??L007\r\n\tJMP\tLPBKNC\r\n??L007:\r\n\t\t\t\t;Now point to 2nd char of var name\r\n\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\t\t;set COMMON bit\r\n\tOR\tAL,LOW 128D\r\n\tMOV\tDI,CX\r\n\tSTOSB\r\n\tRET\t\t\t;done\r\nFNDAAY:\tMOV\tBYTE PTR SUBFLG,AL\t;Array found, clear SUBFLG\r\n\tMOV\tAL,BYTE PTR [BX]\t;Make sure really array spec\r\n\tCMP\tAL,LOW \"(\"\t;Really an array?\r\n\tJNZ\tSHORT SCNSMP\t;No, scan as simp\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;Save text pointer, get rid of saved text pointer\r\nBAKCOM:\tDEC\tCX\t\t;Point at last char of name extension\r\n\tDEC\tCX\r\n\tCALL\tCBAKBL\t\t;Back up before variable and mark as COMMON\r\nBCKUCM:\tPOP\tBX\t\t;Restore text pointer\r\nSKPCOM:\tDEC\tBX\t\t;Rescan terminator\r\n\tCALL\tCHRGTR\r\n\tJNZ\tSHORT ??L008\r\n\tJMP\tAFTCOM\t\t;End of COMMON statement\r\n??L008:\r\n\tCMP\tAL,LOW \"(\"\t;End of COMMON array spec?\r\n\tJNZ\tSHORT CHKCST\t;No, should be comma\r\nCOMADY:\tPUSH\tBX\r\n\tCALL\tCHRGTR\t\t;Fetch char after paren\r\n\tCMP\tAL,LOW \")\"\r\n\tJZ\tSHORT COMRPN\t;Only right paren follows\r\n\tPOP\tBX\r\n\tEXTRN\tEVAL:NEAR\r\n\tCALL\tEVAL\t\t;Possible number of dimensions(compiler compatible)\r\n\tCALL\tGETYPR\r\n\tJNZ\tSHORT ??L009\r\n\tJMP\tFCERR\t\t;Dimensions argument cannot be string\r\n??L009:\r\n\tJMP\tSHORT COMRP1\r\nCOMRPN:\tPOP\tDX\r\nCOMRP1:\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\t;Right paren should follow\r\n\tJNZ\tSHORT ??L010\r\n\tJMP\tAFTCOM\t\t;End of COMMON\r\n??L010:\r\nCHKCST:\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;Force comma to appear here\r\n\tJMP\tNXTCOM\t\t;Get next COMMON variable\r\n; Step 3 - Squeeze..\r\nCLPFIN:\tPOP\tBX\t\t;Restore previous CURLIN\r\n\tMOV\tCURLIN,BX\r\n\tMOV\tDX,ARYTAB\t;End of simple var squeeze to [D,E]\r\n\tMOV\tBX,VARTAB\t;Start of simps\r\nCLPSLP:\tCMP\tBX,DX\t\t;Are we done?\r\n\tJZ\tSHORT DNCMDS\t;Yes done, with simps\r\n\tPUSH\tBX\t\t;Save where this simp is\r\n\tMOV\tCL,BYTE PTR [BX]\t;Get VALTYP\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tMOV\tAL,BYTE PTR [BX]\t;Get COMMON bit\r\n\tOR\tAL,AL\t\t;Set minus if COMMON\r\n\tPUSHF\t\t\t;Save indicator\r\n\tAND\tAL,LOW 177O\t;Clear COMMON bit\r\n\tMOV\tBYTE PTR [BX],AL\t;Save back\r\n\tINC\tBX\r\n\tCALL\tIADAHL\t\t;Skip over rest of var name\r\n\tMOV\tCH,LOW 0\t;Skip VALTYP bytes\r\n\tADD\tBX,CX\r\n\tPOPF\t\t\t;Get indicator whether to delete\r\n\tPOP\tCX\t\t;Pointer to where var started\r\n\tJNS\tSHORT ??L011\r\n\tJMP\tCLPSLP\r\n??L011:\r\n\tPUSH\tCX\t\t;This is where we will resume scanning vars later\r\n\tCALL\tVARDLS\t\t;Delete variable\r\n\tMOV\tBX,ARYTAB\t;Now correct ARYTAB by # of bytes deleted\r\n\tADD\tBX,DX\t\t;Add negative difference between old and new\r\n\tMOV\tARYTAB,BX\t;Save new ARYTAB\r\n\tXCHG\tBX,DX\t\t;To [D,E]\r\n\tPOP\tBX\t\t;Get current place back in [H,L]\r\n\tJMP\tSHORT CLPSLP\r\nVARDLS:\tXCHG\tBX,DX\t\t;Point to where var ends\r\nVARDL1:\tMOV\tBX,STREND\t;One beyond last byte to move\r\nDLSVLP:\tCMP\tBX,DX\t\t;Done?\r\n\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;Grab byte\r\n\tMOV\tDI,CX\r\n\tSTOSB\t\t\t;Move down\r\n\tLAHF\r\n\tINC\tDX\t\t;Increment pointers\r\n\tSAHF\r\n\tLAHF\r\n\tINC\tCX\r\n\tSAHF\r\n\tJNZ\tSHORT DLSVLP\r\n\tMOV\tAL,CL\t\t;Get difference between old and new\r\n\tSUB\tAL,BL\t\t;Into [D,E] ([D,E]=[B,C]-[H,L])\r\n\tMOV\tDL,AL\r\n\tMOV\tAL,CH\r\n\tSBB\tAL,BH\r\n\tMOV\tDH,AL\r\n\tDEC\tDX\t\t;Correct # of bytes\r\n\tDEC\tCX\t\t;Moved one too far\r\n\tMOV\tBX,CX\t\t;Get new STREND [H,L]\r\n\tMOV\tSTREND,BX\t;Store it\r\n\tRET\t\r\nDNCMDS:\tMOV\tDX,STREND\t;Limit of array search\r\nCLPAKP:\tCMP\tBX,DX\t\t;Done?\r\n\tJZ\tSHORT DNCMDA\t;Yes\r\n\tPUSH\tBX\t\t;Save pointer to VALTYP\r\n\tINC\tBX\t\t;Move down to COMMON bit\r\n\tINC\tBX\r\n\tMOV\tAL,BYTE PTR [BX]\t;Get it\r\n\tOR\tAL,AL\t\t;Set CC's\r\n\tPUSHF\t\t\t;Save COMMON indicator\r\n\tAND\tAL,LOW 177O\t;Clear COMMON bit\r\n\tMOV\tBYTE PTR [BX],AL\t;Save back\r\n\tINC\tBX\t\t;Point to length of array\r\n\tCALL\tIADAHL\t\t;Add length of var name\r\n\tMOV\tCL,BYTE PTR [BX]\t;Get length of array in [B,C]\r\n\tINC\tBX\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tINC\tBX\r\n\tADD\tBX,CX\t\t;[H,L] now points after array\r\n\tPOPF\t\t\t;Get back COMMON indicator\r\n\tPOP\tCX\t\t;Get pointer to start of array\r\n\tJNS\tSHORT ??L012\r\n\tJMP\tCLPAKP\t\t;COMMON, dont delete!\r\n??L012:\r\n\tPUSH\tCX\t\t;Save so we can resume\r\n\tCALL\tVARDLS\t\t;Delete the array\r\n\tXCHG\tBX,DX\t\t;Returns with STREND in HL, so put in DE\r\n\tPOP\tBX\t\t;Get back pointer to the next array\r\n\tJMP\tSHORT CLPAKP\t;Check next array\r\n; Step 4 - Copy literals into string space\r\n; This code is very similar to the string garbage collect code\r\n; If BIGSTR is on, we also have to fix up the string back pointers.\r\nDNCMDA:\r\n\tMOV\tBX,VARTAB\t;Look at simple strings\r\nCSVAR:\tMOV\tDX,ARYTAB\t;Limit of search to [D,E]\r\n\tCMP\tBX,DX\t\t;Done?\r\n\tJZ\tSHORT CAYVAR\t;Yes\r\n\tCALL\tSKPNAM\t\t;Skip name, returns Z if was a string\r\n\tJNZ\tSHORT CSKPVA\t;Skip this var, not string\r\n\tCALL\tCDVARS\t\t;Copy this guy into string space if nesc\r\n\tXOR\tAL,AL\t\t;CDVARS has already incremented [H,L]\r\nCSKPVA:\r\n\tMOV\tDL,AL\r\n\tMOV\tDH,LOW 0\t;Add length of VALTYP\r\n\tADD\tBX,DX\r\n\tJMP\tSHORT CSVAR\r\nCAYVA2:\tPOP\tCX\t\t;Adjust stack\r\nCAYVAR:\tMOV\tDX,STREND\t;New limit of search\r\n\tCMP\tBX,DX\t\t;Done?\r\n\tJZ\tSHORT DNCCLS\t;Yes\r\n\tCALL\tSKPNAM\t\t;Skip over name\r\n\tPUSH\tAX\t\t;Save VALTYP\r\n\tMOV\tCL,BYTE PTR [BX]\t;Get length of array\r\n\tINC\tBX\r\n\tMOV\tCH,BYTE PTR [BX]\t;Into [B,C]\r\n\tINC\tBX\r\n\tPOP\tAX\t\t;Get back VALTYP\r\n\tPUSH\tBX\t\t;Save pointer to array element\r\n\tADD\tBX,CX\t\t;Point after array\r\n\tCMP\tAL,LOW 3\t;String array?\r\n\tJNZ\tSHORT CAYVA2\t;No, look at next one\r\n\tMOV\tTEMP3,BX\t;Save pointer to end of array\r\n\tPOP\tBX\t\t;Get back pointer to array start\r\n\tMOV\tCL,BYTE PTR [BX]\t;Pick up number of DIMs\r\n\tMOV\tCH,LOW 0\t;Make double with high zero\r\n\tADD\tBX,CX\t\t;Go past DIMS\r\n\tADD\tBX,CX\r\n\tINC\tBX\t\t;One more to account for # of DIMs\r\nCAYSTR:\tMOV\tDX,TEMP3\t;Get end of array\r\n\tCMP\tBX,DX\t\t;See if at end of array\r\n\tJZ\tSHORT CAYVAR\t;Get next array\r\n\tMOV\tCX,OFFSET CAYSTR\t;Do next str in array\r\n\tPUSH\tCX\t\t;Save branch address on stack\r\nCDVARS:\r\n\tMOV\tAL,BYTE PTR [BX]\t;Get length of array entry\r\n\tINC\tBX\t\t;Also pick up pointer into [D,E]\r\n\tMOV\tDX,[BX]\t\t;Get data pointer\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tOR\tAL,AL\t\t;Set CC's on length\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;Ignore null strings\r\n\tPUSH\tBX\t\t;Save where we are\r\n\tMOV\tBX,VARTAB\t;Is string in program text or disk buffers?\r\n\tCMP\tBX,DX\t\t;Compare\r\n\tPOP\tBX\t\t;Restore where we are\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;No, must be in string space\r\n\tPUSH\tBX\t\t;save where we are again.\r\n\tMOV\tBX,TXTTAB\t;is it in buffers?\r\n\tCMP\tBX,DX\t\t;test\r\n\tPOP\tBX\t\t;Restore where we are\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;in buffers, do nothing\r\n\tPUSH\tBX\t\t;Save where we are for nth time\r\n\tDEC\tBX\t\t;Point to start of descriptor\r\n\tDEC\tBX\r\n\tDEC\tBX\r\n\tPUSH\tBX\t\t;Save pointer to start\r\n\tCALL\tSTRCPY\t\t;Copy string into DSCTMP\r\n\tPOP\tBX\t\t;Destination in [H,L], source in [D,E]\r\n\tMOV\tCH,LOW 3\t;# of bytes to move\r\n\tCALL\tMOVE1\t\t;Move em\r\n\tPOP\tBX\t\t;Where we are\r\n\tRET\t\r\n; Step 5 - Move stuff up into string space!\r\nDNCCLS:\r\n\tCALL\tGARBA2\t\t;Get rid of unused strings\r\n\tMOV\tBX,STREND\t;Load end of vars\r\n\tMOV\tCX,BX\t\t;Into [B,C]\r\n\tMOV\tDX,VARTAB\t;Start of simps into [D,E]\r\n\tMOV\tBX,ARYTAB\r\n\tSUB\tBX,DX\t\t;Get length of simps in [H,L]\r\n\tMOV\tTEMP9,BX\t;Save here\r\n\tMOV\tBX,FRETOP\t;Destination of high byte\r\n\tMOV\tSAVFRE,BX\t;Save FRETOP to restore later\r\n\tCALL\tBLTUC\t\t;Move stuff up\r\n\tMOV\tBX,CX\t\t;Now adjust top of memory below saved vars\r\n\tDEC\tBX\t\t;One lower to be sure\r\n\tMOV\tFRETOP,BX\t;Update FRETOP to reflect new value\r\n\tMOV\tAL,BYTE PTR MDLFLG\t;MERGE w/ DELETE?\r\n\tOR\tAL,AL\t\t;Test\r\n\tJZ\tSHORT NTMDLT\t;No\r\n\tMOV\tBX,CMSPTR\t;Start of lines to delete\r\n\tMOV\tCX,BX\t\t;Into [B,C]\r\n\tMOV\tBX,CMEPTR\t;End of lines to delete\r\n\tCALL\tDEL\t\t;Delete the lines\r\n\tMOV\tARYTAB,BX\t;***also set up ARYTAB and STREND\r\n\tMOV\tSTREND,BX\t;in case we get error in CHAIN\r\n\t\t\t\t;because of file lookup and then have to\r\n\t\t\t\t;look at variables later (shouldnt be any)\r\n\t\t\t\t;***PGA 7/7/81\r\n\tCALL\tLINKER\t\t;Re-link lines just in case\r\n; Step 6 - load new program\r\nNTMDLT:\tMOV\tAL,LOW 1\t;Set CHAIN flag\r\n\tMOV\tBYTE PTR CHNFLG,AL\r\n\tEXTRN\tCHNENT:NEAR,OKGETM:NEAR\r\n\tMOV\tAL,BYTE PTR MRGFLG\t;MERGEing?\r\n\tOR\tAL,AL\t\t;Set cc'S\r\n\tJZ\tSHORT ??L013\r\n\tJMP\tOKGETM\t\t;Do MERGE\r\n??L013:\r\n\tJMP\tCHNENT\t\t;Jump to LOAD code\r\n; Step 7 - Move stuff back down\r\n\tPUBLIC\tCHNRET\r\nCHNRET:\r\n\tMOV\tAL,BYTE PTR TOPTVL\r\n\tMOV\tBYTE PTR OPTVAL,AL\t;RESTORE IOTION BASE VALUE\r\n\tMOV\tAL,BYTE PTR TOPTFG\r\n\tMOV\tBYTE PTR OPTFLG,AL\t;LRESTORE OPTION FLG\r\n\tXOR\tAL,AL\t\t;Clear CHAIN, MERGE flags\r\n\tMOV\tBYTE PTR CHNFLG,AL\r\n\tMOV\tBYTE PTR MRGFLG,AL\r\n\tMOV\tBX,VARTAB\t;Get current VARTAB\r\n\tMOV\tCX,BX\t\t;Into [B,C]\r\n\tMOV\tBX,TEMP9\t;Get length of simps\r\n\tADD\tBX,CX\t\t;Add to present VARTAB to get new ARYTAB\r\n\tMOV\tARYTAB,BX\r\n\tMOV\tBX,FRETOP\t;Where to start moving\r\n\tINC\tBX\t\t;One higher\r\n\tXCHG\tBX,DX\t\t;Into [D,E]\r\n\tMOV\tBX,SAVFRE\t;Last byte to move\r\n\tMOV\tFRETOP,BX\t;Restore FRETOP from this\r\nMVBKVR:\tCMP\tBX,DX\t\t;Done?\r\n\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;Move byte down\r\n\tMOV\tDI,CX\r\n\tSTOSB\r\n\tLAHF\r\n\tINC\tDX\t\t;Increment pointers\r\n\tSAHF\r\n\tLAHF\r\n\tINC\tCX\r\n\tSAHF\r\n\tJNZ\tSHORT MVBKVR\r\n\tDEC\tCX\t\t;Point to last var byte\r\n\tMOV\tBX,CX\t\t;[H,L]=last var byte\r\n\tMOV\tSTREND,BX\t;This is new end\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tNLONLY:WORD\r\nDSEG\tENDS\r\n\tXOR\tAL,AL\t\t;\r\n\tMOV\tBYTE PTR NLONLY,AL\t;allow all files to be closed\r\nEXTRN\tFINPRT:NEAR\r\n\tCALL\tFINPRT\t\t;close file zero and reset PTRFIL to 0\r\n\tXOR\tAL,AL\r\n\tCALL\tRESTORE\t\t;Make sure DATA is valid by doing RESTORE\r\n\tMOV\tDX,CHNLIN\t;Get CHAIN line # in [D,E]\r\n\tMOV\tBX,TXTTAB\t;Get prog start in [H,L]\r\n\tDEC\tBX\t\t;Point at zero before program\r\n\r\n\tOR\tDX,DX\t\t;line number zero?\r\n\tJNZ\tSHORT ??L014\r\n\tJMP\tNEWSTT\t\t;line #=0, go...\r\n??L014:\r\n\tCALL\tFNDLIN\t\t;Try to find destination line\r\n\tJNAE\tSHORT ??L015\r\n\tJMP\tUSERR\t\t;Not there...\r\n??L015:\r\n\tDEC\tCX\t\t;Point to zero on previous line\r\n\tMOV\tBX,CX\t\t;Make text pointer for NEWSTT\r\n\tJMP\tNEWSTT\t\t;Bye...\r\n;\r\n; Convenience routine to skip a variable's name pointed to by HL.\r\n; Returns VALTYP in A with the zero flag set if it is a string.\r\n;\r\n\tPUBLIC\tSKPNAM\r\nSKPNAM:\r\n\tMOV\tAL,BYTE PTR [BX]\t;Get VALTYP\r\n\tINC\tBX\t\t;Point to length of long var name\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tPUSH\tAX\t\t;Save VALTYP\r\n\tCALL\tIADAHL\t\t;Move past long variable name\r\n\tPOP\tAX\t\t;Get back VALTYP\r\n\tCMP\tAL,LOW 3\t;String?\r\n\tRET\t\r\n;\r\n;\r\nCOMMON:\r\n\tJMP\tDATA\r\n\r\n\tSUBTTL  WRITE\r\n\tEXTRN\tFINPRT:NEAR\r\n\tEXTRN\tFOUT:NEAR,STRLIT:NEAR,STRPRT:NEAR,OUTDO:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFACLO:WORD\r\nDSEG\tENDS\r\n\tPUBLIC\tWRITE\r\nWRITE:\r\n\tEXTRN\tFILGET:NEAR\r\n\tMOV\tCL,LOW OFFSET MD_SQO\t;Setup output file\r\n\tCALL\tFILGET\r\nWRTCHR:\tDEC\tBX\r\n\tCALL\tCHRGTR\t\t;Get another character\r\n\tJZ\tSHORT WRTFIN\t;Done with WRITE\r\nWRTMLP:\tCALL\tFRMEVL\t\t;Evaluate formula\r\n\tPUSH\tBX\t\t;Save the text pointer\r\n\tCALL\tGETYPR\t\t;See if we have a string\r\n\tJZ\tSHORT WRTSTR\t;We do\r\n\tCALL\tFOUT\t\t;Convert to a string\r\n\tCALL\tSTRLIT\t\t;Literalize string\r\n\tMOV\tBX,FACLO\t;Get pointer to string\r\n\tINC\tBX\t\t;Point to address field\r\n\tMOV\tDX,[BX]\r\n\tINC\tBX\r\n\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;Is number positive?\r\n\tCMP\tAL,LOW \" \"\t;Test\r\n\tJNZ\tSHORT WRTNEG\t;No, must be negative\r\n\tINC\tDX\r\n\tMOV\tBYTE PTR [BX],DH\r\n\tDEC\tBX\r\n\tMOV\tBYTE PTR [BX],DL\r\n\tDEC\tBX\r\n\tDEC\tBYTE PTR [BX]\t;Adjust length of string (length.LT.255 so OK)\r\nWRTNEG:\tCALL\tSTRPRT\t\t;Print the number\r\nNXTWRV:\tPOP\tBX\t\t;Get back text pointer\r\n\tDEC\tBX\t\t;Back up pointer\r\n\tCALL\tCHRGTR\t\t;Get next char\r\n\tJZ\tSHORT WRTFIN\t;end\r\n\tCMP\tAL,LOW 59\t;Semicolon?\r\n\tJZ\tSHORT WASEMI\t;Was one\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;Only possib left is comma\r\n\tDEC\tBX\t\t;to compensate for later CHRGET\r\nWASEMI:\tCALL\tCHRGTR\t\t;Fetch next char\r\n\tMOV\tAL,LOW 54O\t;put out comma\r\n\tCALL\tOUTDO\r\n\tJMP\tSHORT WRTMLP\t;Back for more\r\nWRTSTR:\tMOV\tAL,LOW 34\t;put out double quote\r\n\tCALL\tOUTDO\t\t;Send it\r\n\tCALL\tSTRPRT\t\t;print the string\r\n\tMOV\tAL,LOW 34\t;Put out another double quote\r\n\tCALL\tOUTDO\t\t;Send it\r\n\tJMP\tSHORT NXTWRV\t;Get next value\r\nWRTFIN:\r\n\tEXTRN\tCMPFBC:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tPTRFIL:WORD\r\nDSEG\tENDS\r\n\tPUSH\tBX\t\t;Save text pointer\r\n\tMOV\tBX,PTRFIL\t;See if disk file\r\n\tMOV\tAL,BH\r\n\tOR\tAL,BL\r\n\tJZ\tSHORT NTRNDW\t;No\r\n\tPUSH\tBX\t\t;Save FDB pointer\r\n\tMOV\tCX,OFFSET F_DEV\r\n\tADD\tBX,CX\t\t;HL points to Device Entry in FDB\r\n\tMOV\tAL,BYTE PTR [BX]\t;[A]=device id\r\n\tOR\tAL,AL\t\t;if disk [A] will be 0..n\r\n\tPOP\tBX\r\n\tJNS\tSHORT ??L016\r\n\tJMP\tNTRNDW\t\t;branch if special device ([A] is negative)\r\n??L016:\r\n\tPUSH\tBX\r\n\tMOV\tCX,OFFSET F_MODE\r\n\tADD\tBX,CX\t\t;HL points to File Mode Byte in FDB\r\n\tMOV\tAL,BYTE PTR [BX]\t;[A]=file mode\r\n\tPOP\tBX\t\t;Restore FDB pointer\r\n\tCMP\tAL,LOW OFFSET MD_RND\t;Random?\r\n\tJNZ\tSHORT NTRNDW\t;NO\r\n\tCALL\tCMPFBC\t\t;See how many bytes left\r\n\tMOV\tAL,BL\t\t;do subtract\r\n\tSUB\tAL,DL\r\n\tMOV\tBL,AL\r\n\tMOV\tAL,BH\r\n\tSBB\tAL,DH\r\n\tMOV\tBH,AL\r\n\tCRLFSQ=2\t\t;Number of bytes in CR/LF sequence\r\n\tMOV\tDX,OFFSET 0-CRLFSQ\t;Subtract bytes in <cr>\r\n\tLAHF\r\n\tADD\tBX,DX\r\n\tRCR\tSI,1\r\n\tSAHF\r\n\tRCL\tSI,1\r\n\tJAE\tSHORT NTRNDW\t;Not enough, give error eventually\r\nNXTWSP:\tMOV\tAL,LOW \" \"\t;Put out spaces\r\n\tCALL\tOUTDO\t\t;Send space\r\n\tDEC\tBX\t\t;Count down\r\n\tMOV\tAL,BH\t\t;Count down\r\n\tOR\tAL,BL\r\n\tJNZ\tSHORT NXTWSP\r\nNTRNDW:\tPOP\tBX\t\t;Restore [H,L]\r\n\tCALL\tCRDO\t\t;Do crlf\r\n\tJMP\tFINPRT\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GENGRP.ASM",
          "type": "blob",
          "size": 15.25,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GENGRP  GENERALIZED GRAPHICS    /WHG\r\n\r\n\t.RADIX\t10\r\n\r\nCLIPPL=0\r\nWINDOW=0\r\nVIEW=0\r\nTILE=0\r\nHAL=0\r\nPC8A=0\r\nMODEL3=0\r\nTSHIBA=0\r\nALPCPM=0\r\nHALL4=0\r\n\tCLIPPL=PC8A OR TRSER2 OR MODEL3\r\n\tWINDOW=PC8A\r\n\tVIEW=PC8A OR TRSER2 OR MODEL3\r\n\tLINEST=0\t\t;LINE STYLE SWITCH\r\n\tLINEST=PC8A OR TRSER2 OR MODEL3\r\n;\r\n;       SYSTEM DEPENDENT SWITCHES:\r\n;\r\n\r\nCOMMENT\t*\r\n\r\nTHESE ARE THE GENERAL GRAPHICS ROUTINES THAT ASSUME THE \"MACHINE\r\nINDEPENDENT\" GRAPHICS INTERFACE. THEY DEAL WITHIN A  16-BIT\r\nGRAPHICS COORDINATE SYSTEM FOR BOTH X AND Y. ATTRIBUTES RANGE FROM\r\n0 TO 255.\r\n\r\n*\r\n;\r\n; THESE ARE THE RAM LOCATIONS REQUIRED TO SUPPORT THIS PACKAGE\r\n; NOTE THAT ALL OF THESE ARE LOCAL TO THIS CODE EXCEPT\r\n; FORCLR AND BAKCLR WHICH NEED TO BE SET UP BY THE MACHINE DEPENDENT\r\n; CODE EITHER AS CONSTANTS OR THROUGH A COLOR TYPE COMMAND\r\n; NOTE THAT MAXUPD AND MINUPD ARE 3 BYTE CELLS WITH A JMP IN THE\r\n; FIRST BYTE TO BE SET UP BY GRFINI OR INITIALIZED AT STARTUP\r\n;\r\n\t\t\t\t;In GW versions, GETFBC is the OEM interface\r\n\tEXTRN\tGETFBC:NEAR\t;for FORCLR and BAKCLR (OEM vars)\r\n\tEXTRN\tPIXSIZ:NEAR\t;Get bits/pixel (0=no graphics available)\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tGXPOS:WORD,GYPOS:WORD\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tGRPACX:WORD,GRPACY:WORD\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tMAXDEL:WORD,MINDEL:WORD,MINUPD:WORD,MAXUPD:WORD\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tATRBYT:WORD\t;External form of the current attribute\r\nDSEG\tENDS\r\n\t\t\t\t; used by PAINT for default\r\n;\r\n; THESE ARE THE ROUTINES CALLED INSIDE THE BASIC INTERPRETER\r\n; AND THE SYNTAX TOKEN DEFINITIONS REFERENCED\r\n;\r\n\tEXTRN\tGETIN2:NEAR,GETBYT:NEAR,CHRGTR:NEAR,$STEP:NEAR,FCERR:NEAR\r\n\tEXTRN\tCHRGT2:NEAR\r\n\tEXTRN\tMINUTK:NEAR\r\n\tEXTRN\tSYNCHR:NEAR\r\n;\r\n\tPUBLIC\tHLFDE,SCAND,ATRSCN,SCAN1,DOGRPH,XCHGX,XCHGY,XDELT,YDELT\r\n; THESE ARE THE ENTRY POINTS INTO THE MACHINE DEPENDENT GRAPHICS\r\n; ROUTINES. THEY FOLLOW STANDARD CONVENTIONS TO AVOID MODIFICATIONS\r\n; TO CODE IN THIS PACKAGE FOR SPECIFIC IMPLEMENTATIONS\r\n;\r\n\tEXTRN\tSCALXY:NEAR,MAPXYC:NEAR,UPC:NEAR,DOWNC:NEAR,LEFTC:NEAR\r\n\tEXTRN\tRIGHTC:NEAR\r\n\tEXTRN\tREADC:NEAR,SETATR:NEAR,NSETCX:NEAR\r\n\tEXTRN\tFETCHC:NEAR,STOREC:NEAR,SETC:NEAR\r\n\r\n\tPAGE\t\r\n\tSUBTTL  SCAN A COORDINATE - SCAN1 AND SCAND\r\n\r\n;\r\n; ALLOW A COORDINATE OF THE FORM (X,Y) OR STEP(X,Y)\r\n; THE LATTER IS RELATIVE TO THE GRAPHICS AC.\r\n; THE GRAPHICS AC IS UPDATED WITH THE NEW VALUE\r\n; RESULT IS RETURNED WITH [B,C]=X AND [D,E]=Y\r\n; CALL SCAN1 TO GET FIRST IN A SET OF TWO PAIRS SINCE IT ALLOWS\r\n; A NULL ARGUMENT TO IMPLY THE CURRENT AC VALUE AND\r\n; IT WILL SKIP A \"@\" IF ONE IS PRESENT\r\n;\r\nSCAN1:\tMOV\tAL,BYTE PTR [BX]\t;GET THE CURRENT CHARACTER\r\n\tCMP\tAL,LOW \"@\"\t;ALLOW MEANINGLESS \"@\"\r\n\tJNZ\tSHORT ??L000\r\n\tCALL\tCHRGTR\t\t;BY SKIPPING OVER IT\r\n??L000:\r\n\tMOV\tCX,0\t\t;ASSUME NO COODINATES AT ALL (-SECOND)\r\n\tMOV\tDH,CH\r\n\tMOV\tDL,CL\r\n\tCMP\tAL,LOW OFFSET MINUTK\t;SEE IF ITS SAME AS PREVIOUS\r\n\tJZ\tSHORT SCANN\t;USE GRAPHICS ACCUMULATOR\r\n;\r\n; THE STANDARD ENTRY POINT\r\n;\r\nSCAND:\tMOV\tAL,BYTE PTR [BX]\t;GET THE CURRENT CHARACTER\r\n\tCMP\tAL,LOW OFFSET $STEP\t;IS IT RELATIVE?\r\n\tPUSHF\t\t\t;REMEMBER\r\n\tJNZ\tSHORT ??L001\r\n\tCALL\tCHRGTR\t\t;SKIP OVER $STEP TOKEN\r\n??L001:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"(\"\t;SKIP OVER OPEN PAREN\r\n\tCALL\tGETIN2\t\t;SCAN X INTO [D,E]\r\n\tPUSH\tDX\t\t;SAVE WHILE SCANNING Y\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44D\t;SCAN COMMA\r\n\tCALL\tGETIN2\t\t;GET Y INTO [D,E]\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\r\n\tPOP\tCX\t\t;GET BACK X INTO [B,C]\r\n\tPOPF\t\t\t;RECALL IF RELATIVE OR NOT\r\nSCANN:\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tMOV\tBX,GRPACX\t;GET OLD POSITION\r\n\tJZ\tSHORT SCXREL\t;IF ZERO,RELATIVE SO USE OLD BASE\r\n\tMOV\tBX,0\t\t;IN ABSOLUTE CASE, JUST Y USE ARGEUMENT\r\nSCXREL:\tLAHF\r\n\tADD\tBX,CX\t\t;ADD NEW VALUE\r\n\tRCR\tSI,1\r\n\tSAHF\r\n\tRCL\tSI,1\r\n\tMOV\tGRPACX,BX\t;UPDATE GRAPHICS ACCUMLATOR\r\n\tMOV\tGXPOS,BX\t;STORE SECOND COORDINTE FOR CALLER\r\n\tMOV\tCX,BX\t\t;RETURN X IN BC\r\n\tMOV\tBX,GRPACY\t;GET OLDY POSITION\r\n\tJZ\tSHORT SCYREL\t;IF ZERO, RELATIVE SO USE OLD BASE\r\n\tMOV\tBX,0\t\t;ABSOLUTE SO OFFSET BY 0\r\nSCYREL:\tADD\tBX,DX\r\n\tMOV\tGRPACY,BX\t;UPDATE Y PART OF ACCUMULATOR\r\n\tMOV\tGYPOS,BX\t;STORE Y FOR CALLER\r\n\tXCHG\tBX,DX\t\t;RETURN Y IN [D,E]\r\n\tPOP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  PSET,PRESET,POINT\r\n;\r\n; THESE ARE THE STATEMENT AND FUNCTION ENTRY POINTS DEFINED BY THIS\r\n; PACKAGE. THE APPROPRIATE ENTRIES MUST BE SELECTED IN THE\r\n; RESERVED WORD TABLES TO GET BASIC TO DISPATCH TO THESE ROUTINES\r\n;\r\n\tPUBLIC\tPSET,PRESET,POINT\r\n\r\n;\r\n; PSET (X,Y)[,ATTRIBUTE] DEFAULT ATTRIBUTE TO FORCLR\r\n; PRESET (X,Y)[,ATTRIBUTE] DEFAULT ATTIBUTE TO BAKCLR\r\n;\r\nPRESET:\tPUSH\tBX\t\t;Push text pointer\r\n\tSTC\t\t\t;Flag to get graphics colors\r\n\tCALL\tGETFBC\t\t;Get forground/background colors\r\n\tMOV\tAL,BL\t\t;Get background color\r\n\tJMP\tPPRSET\r\n\r\nPSET:\tPUSH\tBX\t\t;Push text pointer\r\n\tSTC\t\t\t;Flag to get graphics colors\r\n\tCALL\tGETFBC\t\t;Get forground/background colors\r\nPPRSET:\tPOP\tBX\t\t;Retrieve text pointer\r\nPSETC:\tPUSH\tAX\t\t;SAVE DEFAULT ATTRIBUTE\r\n\tCALL\tSCAND\t\t;SCAN A SINGLE COORDINATE\r\n\tPOP\tAX\t\t;GET BACK DEFAULT ATTRIBUTE\r\n\tCALL\tATRENT\t\t;SCAN POSSIBLE ATTRIBUTE\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\tSCALXY\t\t;SCALE INTO BOUNDS\r\n\tJAE\tSHORT PSTNOT\t;NO PSET IF NOT IN BOUNDS\r\n\tCALL\tMAPXYC\t\t;MAP INTO A \"C\"\r\n\tCALL\tSETC\t\t;ACTUALLY DO THE SET\r\nPSTNOT:\tPOP\tBX\r\n\tRET\t\r\n\r\n;\r\n; POINT (X,Y) RETURNS THE ATTRIBUTE STORED AT THAT POINT\r\n; IT RETURNS -1 IF THE POINT IS OUT OF BOUNDS\r\n;\r\nPOINT:\r\n\tCALL\tCHRGTR\t\t;POINT IS RECOGNIZED IN EVAL\r\n\t\t\t\t;SO NEED TO SKIP ONE MORE CHAR\r\n\tPUSH\tBX\t\t;Save the text pointer.\r\n\tCALL\tFETCHC\t\t;Preserve the graphics cursor, GXPOS,\r\n\tPOP\tDX\t\t;and GYPOS across the POINT function\r\n\tPUSH\tBX\t\t;so cases like\r\n\tPUSH\tAX\t\t;LINE (x1,y1)-(x2,y2),POINT(x3,y3) will\r\n\tMOV\tBX,GYPOS\t;work correctly.\r\n\tPUSH\tBX\r\n\tMOV\tBX,GXPOS\r\n\tPUSH\tBX\r\n\tMOV\tBX,GRPACY\r\n\tPUSH\tBX\r\n\tMOV\tBX,GRPACX\r\n\tPUSH\tBX\r\n\tXCHG\tBX,DX\t\t;Put the text pointer back in HL.\r\n\tCALL\tSCAND\t\t;READ THE SPECIFICATION OF THE POINT\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tCALL\tSCALXY\t\t;SCALE THE POINT\r\n\tMOV\tBX,OFFSET 0-1\t;ASSUME ILLEGAL POINT\r\n\tJAE\tSHORT PNTNOT\t;NOT LEGAL - RETURN -1\r\n\tCALL\tMAPXYC\r\n\tCALL\tREADC\t\t;READ OUT THE ATTRIBUTE\r\n\tMOV\tBL,AL\r\n\tMOV\tBH,LOW 0\r\n\tEXTRN\tMAKINT:NEAR\r\nPNTNOT:\tCALL\tMAKINT\r\n\tPOP\tDX\t\t;Restore text pointer\r\n\tPOP\tBX\r\n\tMOV\tGRPACX,BX\r\n\tPOP\tBX\r\n\tMOV\tGRPACY,BX\r\n\tPOP\tBX\t\t;Restore GXPOS, GYPOS, and the graphics\r\n\tMOV\tGXPOS,BX\t;cursor.\r\n\tPOP\tBX\r\n\tMOV\tGYPOS,BX\r\n\tPOP\tAX\r\n\tPOP\tBX\r\n\tPUSH\tDX\r\n\tCALL\tSTOREC\r\n\tPOP\tBX\t\t;Retrieve the text pointer and return.\r\n\tRET\t\r\n;\r\n; ATTRIBUTE SCAN\r\n; LOOK AT THE CURRENT POSITION AND IF THERE IS AN ARGUMENT READ IT AS\r\n; THE 8-BIT ATTRIBUTE VALUE TO SEND TO SETATR. IF STATEMENT HAS ENDED\r\n; OR THERE IS A NULL ARGUMENT, SEND FORCLR  TO SETATR\r\n;\r\nATRSCN:\tPUSH\tBX\t\t;Save text pointer\r\n\tSTC\t\t\t;Flag to get graphics colors\r\n\tCALL\tGETFBC\t\t;Get forground/background colors\r\n\tPOP\tBX\t\t;Retrieve text pointer\r\nATRENT:\tPUSH\tCX\t\t;SAVE THE CURRENT POINT\r\n\tPUSH\tDX\r\n\tMOV\tDL,AL\t\t;SAVE DEFAULT ATTRIBUTE IN [E]\r\n\tDEC\tBX\t\t;SEE IF STATEMENT ENDED\r\n\tCALL\tCHRGTR\r\n\tJZ\tSHORT ATRFIN\t;USE DEFAULT\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44D\t;INSIST ON COMMA\r\n\tCMP\tAL,LOW 44D\t;ANOTHER COMMA FOLLOWS?\r\n\tJZ\tSHORT ATRFIN\t;IF SO, NULL ARGUMENT SO USE DEFAULT\r\n\tCALL\tGETBYT\t\t;GET THE BYTE\r\nATRFIN:\tMOV\tAL,DL\t\t;GET ATTRIBUTE INTO [A]\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\nATRFI2:\r\n\tPUSH\tAX\t\t;Save the attribute\r\n\tCALL\tPIXSIZ\t\t;Test for graphics capability\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT ??L002\r\n\tJMP\tFCERR\t\t;Graphics not available\r\n??L002:\r\n\tPOP\tAX\t\t;Restore the attributeA\r\n\tCALL\tSETATR\t\t;SET THE ATTRIBUTE AS THE CURRENT ONE\r\n\tJAE\tSHORT ??L003\r\n\tJMP\tFCERR\t\t;ILLEGAL ATTRIBUTES GIVE FUNCTION CALL\r\n??L003:\r\n\tMOV\tBYTE PTR ATRBYT,AL\t;Store legal atribute\r\n\tPOP\tBX\r\n\tPOP\tDX\t\t;GET BACK CURRENT POINT\r\n\tPOP\tCX\r\n\tJMP\tCHRGT2\r\n\r\n\tPAGE\t\r\n\tSUBTTL  UTILITY ROUTINES FOR LINE CODE\r\n\r\n;\r\n; XDELT SETS [H,L]=ABS(GXPOS-[B,C]) AND SETS CARRY IF [B,C].GT.GXPOS\r\n; ALL REGISTERS EXCEPT [H,L] AND [A,PSW] ARE PRESERVED\r\n; NOTE: [H,L] WILL BE A DELTA BETWEEN GXPOS AND [B,C] - ADD 1 FOR AN X \"COUNT\"\r\n;\r\nXDELT:\tMOV\tBX,GXPOS\t;GET ACCUMULATOR POSITION\r\n\tMOV\tAL,BL\r\n\tSUB\tAL,CL\r\n\tMOV\tBL,AL\t\t;DO SUBTRACT INTO [H,L]\r\n\tMOV\tAL,BH\r\n\tSBB\tAL,CH\r\n\tMOV\tBH,AL\r\nCNEGHL:\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;IF NO CARRY, NO NEED TO NEGATE COUNT\r\nPUBLIC\tNEGHL\r\nNEGHL:\tXOR\tAL,AL\t\t;STANDARD [H,L] NEGATE\r\n\tSUB\tAL,BL\r\n\tMOV\tBL,AL\r\n\tSBB\tAL,BH\r\n\tSUB\tAL,BL\r\n\tMOV\tBH,AL\r\n\tSTC\t\t\t;FLAG THAT NEGATE TOOK PLACE\r\n\tRET\t\r\n;\r\n; YDELT SETS [H,L]=ABS(GYPOS-[D,E]) AND SETS CARRY IF [D,E].GT.GYPOS\r\n; ALL REGISTERS EXCEPT [H,L] AND [A,PSW] ARE PRESERVED\r\n;\r\nYDELT:\tMOV\tBX,GYPOS\r\n\tMOV\tAL,BL\r\n\tSUB\tAL,DL\r\n\tMOV\tBL,AL\r\n\tMOV\tAL,BH\r\n\tSBB\tAL,DH\r\n\tMOV\tBH,AL\r\n\tJMP\tSHORT CNEGHL\r\n;\r\n; XCHGX EXCHANGES [B,C] WITH GXPOS\r\n; XCHGY EXCHANGES [D,E] WITH GYPOS\r\n; XCHGAC PERFORMS BOTH OF THE ABOVE\r\n; NONE OF THE OTHER REGISTERS IS AFFECTED\r\n;\r\nXCHGY:\tPUSH\tBX\r\n\tMOV\tBX,GYPOS\r\n\tXCHG\tBX,DX\r\n\tMOV\tGYPOS,BX\r\n\tPOP\tBX\r\n\tRET\t\r\nXCHGAC:\tCALL\tXCHGY\r\nXCHGX:\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tMOV\tBX,GXPOS\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\r\n\tMOV\tGXPOS,BX\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  LINE COMMAND\r\n;\r\n; LINE [(X1,Y1)]-(X2,Y2) [,ATTRIBUTE[,B[F]]]\r\n; DRAW A LINE FROM (X1,Y1) TO (X2,Y2) EITHER\r\n; 1. STANDARD FORM -- JUST A LINE CONNECTING THE 2 POINTS\r\n; 2. ,B=BOXLINE -- RECTANGLE TREATING (X1,Y1) AND (X2,Y2) AS OPPOSITE CORNERS\r\n; 3. ,BF= BOXFILL --  FILLED RECTANGLE WITH (X1,Y1) AND (X2,Y2) AS OPPOSITE CORNERS\r\n;\r\nPUBLIC\tGLINE\r\nGLINE:\r\n\tCALL\tSCAN1\t\t;SCAN THE FIRST COORDINATE\r\n\tPUSH\tCX\t\t;SAVE THE POINT\r\n\tPUSH\tDX\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET MINUTK\t;MAKE SURE ITS PROPERLY SEPERATED\r\n\tCALL\tSCAND\t\t;SCAN THE SECOND SET\r\n\tCALL\tATRSCN\t\t;SCAN THE ATTRIBUTE\r\n\tPOP\tDX\t\t;GET BACK THE FIRST POINT\r\n\tPOP\tCX\r\n\tJZ\tSHORT DOLINE\t;IF STATEMENT ENDED ITS A NORMAL LINE\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44D\t;OTHERWISE MUST HAVE A COMMA\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"B\"\t;AND A \"B\"\r\n\tJNZ\tSHORT ??L004\r\n\tJMP\tBOXLIN\t\t;IF JUST \"B\" THE NON-FILLED BOX\r\n??L004:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"F\"\t;MUST BE FILLED BOX\r\nDOBOXF:\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tCALL\tSCALXY\t\t;SCALE FIRST POINT\r\n\tCALL\tXCHGAC\t\t;SWITCH POINTS\r\n\tCALL\tSCALXY\t\t;SCALE SECOND POINT\r\n\tCALL\tYDELT\t\t;SEE HOW MANY LINES AND SET CARRY\r\n\tJNB\tSHORT ??L005\r\n\tCALL\tXCHGY\t\t;MAKE [D,E] THE SMALLEST Y\r\n??L005:\r\n\tINC\tBX\t\t;MAKE [H,L] INTO A COUNT\r\n\tPUSH\tBX\t\t;SAVE COUNT OF LINES\r\n\tCALL\tXDELT\t\t;GET WIDTH AND SMALLEST X\r\n\tJNB\tSHORT ??L006\r\n\tCALL\tXCHGX\t\t;MAKE [B,C] THE SMALLEST X\r\n??L006:\r\n\tINC\tBX\t\t;MAKE [H,L] INTO A WIDTH COUNT\r\n\tPUSH\tBX\t\t;SAVE WIDTH COUNT\r\n\tCALL\tMAPXYC\t\t;MAP INTO A \"C\"\r\n\tPOP\tDX\t\t;GET WIDTH COUNT\r\n\tPOP\tCX\t\t;GET LINE COUNT\r\nBOXLOP:\tPUSH\tDX\t\t;SAVE WIDTH\r\n\tPUSH\tCX\t\t;SAVE NUMBER OF LINES\r\n\tCALL\tFETCHC\t\t;LOOK AT CURRENT C\r\n\tPUSH\tAX\t\t;SAVE BIT MASK OF CURRENT \"C\"\r\n\tPUSH\tBX\t\t;SAVE ADDRESS\r\n\tXCHG\tBX,DX\t\t;SET UP FOR NSETCX WITH COUNT\r\n\tCALL\tNSETCX\t\t;IN [H,L] OF POINTS TO SETC\r\n\tPOP\tBX\t\t;GET BACK STARTING C\r\n\tPOP\tAX\t\t;ADDRESS AND BIT MASK\r\n\tCALL\tSTOREC\t\t;SET UP AS CURRENT \"C\"\r\n\tCALL\tDOWNC\t\t;MOVE TO NEXT LINE DOWN IN Y\r\n\tPOP\tCX\t\t;GET BACK NUMBER OF LINES\r\n\tPOP\tDX\t\t;GET BACK WIDTH\r\n\tDEC\tCX\t\t;COUNT DOWN LINES\r\n\tMOV\tAL,CH\r\n\tOR\tAL,CL\t\t;SEE IF ANY LEFT\r\n\tJNZ\tSHORT BOXLOP\t;KEEP DRAWING MORE LINES\r\n\tPOP\tBX\r\n\tRET\t\r\nDOLINE:\tPUSH\tCX\t\t;SAVE COORDINATES\r\n\tPUSH\tDX\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\tDOGRPH\r\n\tMOV\tBX,GRPACX\t;RESTORE ORIGINAL SECOND COORDINATE\r\n\tMOV\tGXPOS,BX\r\n\tMOV\tBX,GRPACY\t;FOR BOXLIN CODE\r\n\tMOV\tGYPOS,BX\r\n\tPOP\tBX\t\t;RESTORE TEXT POINTER\r\n\tPOP\tDX\r\n\tPOP\tCX\r\n\tRET\t\r\nBOXLIN:\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tMOV\tBX,GYPOS\r\n\tPUSH\tBX\t\t;SAVE Y2\r\n\tPUSH\tDX\t\t;SAVE Y1\r\n\tXCHG\tBX,DX\t\t;MOVE Y2 TO Y1\r\n\tCALL\tDOLINE\t\t;DO TOP LINE\r\n\tPOP\tBX\t\t;MOVE Y1 TO Y2\r\n\tMOV\tGYPOS,BX\r\n\tXCHG\tBX,DX\t\t;RESTORE Y1 TO [D,E]\r\n\tCALL\tDOLINE\r\n\tPOP\tBX\t\t;GET BACK Y2\r\n\tMOV\tGYPOS,BX\t;AND RESTORE\r\n\tMOV\tBX,GXPOS\t;GET X2\r\n\tPUSH\tCX\t\t;SAVE X1\r\n\tMOV\tCX,BX\t\t;SET X1=X2\r\n\tCALL\tDOLINE\r\n\tPOP\tBX\r\n\tMOV\tGXPOS,BX\t;SET X2=X1\r\n\tMOV\tCX,BX\t\t;RESTORE X1 TO [B,C]\r\n\tCALL\tDOLINE\r\n\tPOP\tBX\t\t;RESTORE THE TEXT POINTER\r\n\tRET\t\r\n;\r\n; DOGRPH DRAWS A LINE FROM ([B,C],[D,E]) TO (GXPOS,GYPOS)\r\n;\r\nDOGRPH:\r\n\tCALL\tSCALXY\t\t;CHEATY SCALING - JUST TRUNCATE FOR NOW\r\n\tCALL\tXCHGAC\r\n\tCALL\tSCALXY\r\nDOGRP2:\tCALL\tYDELT\t\t;GET COUNT DIFFERENCE IN [H,L]\r\n\tJNB\tSHORT ??L007\r\n\tCALL\tXCHGAC\t\t;IF CURRENT Y IS SMALLER NO EXCHANGE\r\n??L007:\r\n\tPUSH\tDX\t\t;SAVE Y1 COORDINATE\r\n\tPUSH\tBX\t\t;SAVE DELTA Y\r\n\tCALL\tXDELT\r\n\tXCHG\tBX,DX\t\t;PUT DELTA X INTO [D,E]\r\n\tMOV\tBX,OFFSET RIGHTC\t;ASSUME X WILL GO RIGHT\r\n\tJAE\tSHORT LINCN2\r\n\tMOV\tBX,OFFSET LEFTC\r\nLINCN2:\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT ROUTINE ADDRESS ON STACK AND GET DELTA Y\r\n\tCMP\tBX,DX\t\t;SEE WHICH DELTA IS BIGGER\r\n\tJAE\tSHORT YDLTBG\t;YDELTA IS BIGGER OR EQUAL\r\n\r\n\tMOV\tMINDEL,BX\t;SAVE MINOR AXIS DELTA (Y)\r\n\tPOP\tBX\t\t;GET X ACTION ROUTINE\r\n\tMOV\tMAXUPD+1,BX\t;SAVE IN MAJOR ACTION ADDRESS\r\n\tMOV\tBX,OFFSET DOWNC\t;ALWAYS INCREMENT Y\r\n\tMOV\tMINUPD+1,BX\t;WHICH IS THE MINOR AXIS\r\n\tXCHG\tBX,DX\t\t;[H,L]=DELTA X=MAJOR DELTA\r\n\tJMP\tSHORT LINCN3\t;MERGE WITH YDLTBG CASE AND DO DRAW\r\n\r\nYDLTBG:\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;ACTION ROUTINE FOR X INTO [H,L]\r\n\t\t\t\t;SAVE DELTA Y ON THE STACK\r\n\tMOV\tMINUPD+1,BX\t;SAVE ADDRESS OF MINOR AXIS UPDATE\r\n\tMOV\tBX,OFFSET DOWNC\t;Y IS ALWAYS INCREMENT MODE\r\n\tMOV\tMAXUPD+1,BX\t;SAVE AS MAJOR AXIS UPDATE\r\n\tXCHG\tBX,DX\t\t;[H,L]=DELTA X\r\n\tMOV\tMINDEL,BX\t;SAVE MINOR DELTA\r\n\tPOP\tBX\t\t;[H,L]=DELTA Y=MAJOR DELTA\r\n\r\nLINCN3:\tPOP\tDX\t\t;GET BACK Y1\r\n\r\n; MAJOR AXIS IS ONE WITH THE LARGEST DELTA\r\n; MINOR IS THE OTHER\r\n; READY TO DRAW NOW\r\n; MINUPD+1=ADDRESS TO GO TO UPDATE MINOR AXIS COORDINATE\r\n; MAXUPD+1=ADDRESS TO GO TO UPDATE MAJOR AXIS COORDINATE\r\n; [H,L]=MAJOR AXIS DELTA=# OF POINTS-1\r\n; MINDEL=DELTA ON MINOR AXIS\r\n;\r\n; IDEA IS\r\n;  SET SUM=MAJOR DELTA/2\r\n;  [B,C]=# OF POINTS\r\n;  MAXDEL=-MAJOR DELTA (CONVENIENT FOR ADDING)\r\n; LINE LOOP (LINLP3):\r\n;       DRAW AT CURRENT POSITION\r\n;       UPDATE MAJOR AXIS\r\n;       SUM=SUM+MINOR DELTA\r\n;       IF SUM.GT.MAJOR DELTA THEN UPDATE MINOR AND SUM=SUM-MAJOR DELTA\r\n;       DECREMENT [B,C] AND TEST FOR 0 -- LOOP IF NOT\r\n; END LOOP\r\n\r\n\tPUSH\tBX\t\t;SAVE FOR SETTING UP COUNT\r\n\tMOV\tMAXDEL,BX\t;SAVE MAJOR DELTA FOR SUMMING\r\n\tCALL\tMAPXYC\t\t;GET POSITION INTO BITMSK AND [H,L]\r\n\tPOP\tDX\r\n\tPUSH\tDX\t\t;START SUM AT MAXDEL/2\r\n\tCALL\tHLFDE\r\n\tPOP\tCX\t\t;GET COUNT IN [B,C]\r\n\tINC\tCX\t\t;NUMBER OF POINTS IS DELTA PLUS ONE\r\n\tEXTRN\tLINLP3:NEAR\r\n\tJMP\tLINLP3\r\n\r\n\r\nHLFDE:\tMOV\tAL,DH\r\n\tOR\tAL,AL\t\t;CLEAR CARRY\r\n\tRCR\tAL,1\t\t;SCALE MEANS SHIFTING RIGHT ONE\r\n\tMOV\tDH,AL\r\n\tMOV\tAL,DL\r\n\tRCR\tAL,1\r\n\tMOV\tDL,AL\r\n\tRET\t\r\n\r\n\tPAGE\t\r\n\tPAGE\t\r\n\tSUBTTL  Graphics Initialization\r\n\r\n\tPUBLIC\tGRPINI,GRPRST\t;Graphics Initialization routine\r\n\r\n\tEXTRN\tGRPSIZ:NEAR\t;Get screen pixel dimension routine (OEM)\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDRWSCL:WORD,DRWANG:WORD\r\nDSEG\tENDS\r\n\r\n;GRPRST resets graphics.  It is called at CLEARC and during INIT\r\n;Entry - none\r\n;Exit  - all registers preserved\r\n;\r\nGRPRST:\tPUSH\tAX\r\n\tPUSH\tCX\r\n\tPUSH\tBX\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR DRWSCL,AL\t;Draw scale init\r\n\tMOV\tBYTE PTR DRWANG,AL\t;Draw angle init\r\n\tCALL\tGRPINI\t\t;Center the graphics cursor\r\n\tSTC\t\r\n\tCALL\tGETFBC\t\t;Get foreground/background colors\r\n\tCALL\tSETATR\t\t;Set the default DRAW color\r\n\tPOP\tBX\r\n\tPOP\tCX\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n;GRPINI - center the graphics cursor.  This routine has been documented to\r\n;OEMs for versions of GW BASIC which are translated to ASM86.\r\n;Entry - none\r\n;Exit  - none\r\n;\r\nGRPINI:\tCALL\tGRPSIZ\t\t;Get screen pixel dimensions\r\n\tPUSH\tCX\t\t;B,C has X dimension\r\n\tPOP\tBX\t\t;Move X dimension to H\r\n\tINC\tBX\t\t;Adjust for zero relative\r\n\tINS86\t321,353\t\t;;SHR BX,1\r\n\tMOV\tGRPACX,BX\t;Store as previous position\r\n\tPUSH\tDX\t\t;D,E has Y dimension\r\n\tPOP\tBX\t\t;Move Y dimension to H\r\n\tINC\tBX\r\n\tINS86\t321,353\t\t;;SHR BX,1\r\n\tMOV\tGRPACY,BX\t;Store as previous position\r\n\tRET\t\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GIO86.ASM",
          "type": "blob",
          "size": 65.625,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GIO86   - BASIC-86 Interpreter Device Independent I/O Module\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- ---------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT\r\n--------- --- ---- -- ---------\r\n\r\n        T. Corbett      Microsoft Inc.\r\n\r\n        *\r\n\tINCLUDE\tGIO86U\r\n\t.SALL\r\n\r\n\r\nCPM86=0\r\nIBMCSR=IBMLIK\t\t\t;IBM Compatible Cursor Handling\r\n\r\n\tINCLUDE\tMSDOSU\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tDEVPTR:WORD,DEVTBL:WORD,DEVINI:WORD,DEVTRM:WORD\r\n\tEXTRN\tNLONLY:WORD,RUNFLG:WORD\r\n\tEXTRN\tFILMOD:WORD,FILDEV:WORD,FILNM:WORD,FILEXT:WORD\r\n\tEXTRN\tPTRFIL:WORD,FILTAB:WORD,STKLOW:WORD\r\nDSEG\tENDS\r\n\r\n\tEXTRN\tSNERR:NEAR,FCERR:NEAR\r\n\tEXTRN\tFRESTR:NEAR,GETYPR:NEAR\r\n\tEXTRN\t$_KYBD:NEAR,$_LPT1:NEAR,$_NDEV:NEAR\r\n\tEXTRN\tDERBFM:NEAR,DERBFN:NEAR,DERFAO:NEAR,DERFNO:NEAR,DERIFN:NEAR\r\n\tEXTRN\tDERDNA:NEAR,DERFDR:NEAR\r\n\r\nDOSIO\tMACRO\tDFUN\r\n\tMOV\tAH,LOW OFFSET DFUN\r\n\tINT\t33D\t\t;MS-DOS system call\r\nENDM \r\n\r\n\r\n\r\n\tSUBTTL OPEN statement\r\n\r\n\tPUBLIC\tOPEN\r\n\tEXTRN\t$LEN:NEAR,EQULTK:NEAR,$FOR:NEAR,$INPUT:NEAR,GETBYT:NEAR\r\n\tEXTRN\tGWWID:NEAR\r\n\r\n; OPEN Statement\r\n; Syntax:\r\n;  OPEN filespec FOR mode AS fnum [LEN=random-record-length]\r\n;  OPEN mode,fnum,filespec[,random-record-length]\r\n;\r\nOPEN:\tCALL\tFRMEVL\t\t;read the file mode or filename\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;get terminator\r\n\tCMP\tAL,LOW 54O\t;followed by comma? (then\r\n\t\t\t\t; non-spcdsk open...)\r\n\tJNZ\tNOTNSO\t\t;nope, must be SPCDSK form\r\n\tPUSH\tBX\t\t;save the text pointer\r\n\tCALL\tFRESTR\t\t;free string temp & check string\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;make sure its not a null string\r\n\tOR\tAL,AL\r\n\tJZ\tERBFM0\t\t;if so, \"bad file mode\"\r\n\tINC\tBX\r\n\tMOV\tBX,WORD PTR 0[BX]\t;[BX] points at mode character\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;[A]=mode character\r\n\tAND\tAL,LOW OFFSET -1-\" \"\t;force to upper case\r\n\tMOV\tDH,LOW OFFSET MD_SQO\t;assume its \"O\"\r\n\tCMP\tAL,LOW \"O\"\t;is it?\r\n\tJZ\tHAVMOD\t\t;[D] has correct mode\r\n\tMOV\tDH,LOW OFFSET MD_SQI\t;assume sequential\r\n\tCMP\tAL,LOW \"I\"\t;is it?\r\n\tJZ\tHAVMOD\t\t;[D] says sequential input\r\n\tMOV\tDH,LOW OFFSET MD_APP\t;append?\r\n\tCMP\tAL,LOW \"A\"\t;test\r\n\tJZ\tHAVMOD\t\t;allow it\r\n\tMOV\tDH,LOW OFFSET MD_RND\t;must be random\r\n\tCMP\tAL,LOW \"R\"\r\n\tJNZ\tERBFM0\t\t;if not, no match so \"bad file mode\"\r\nHAVMOD:\tMOV\tBYTE PTR FILMOD,DH\t;set file mode\r\n\tPOP\tBX\t\t;get back the text pointer\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;skip comma before file number\r\nHAVMD1:\tCALL\tPOFNUM\t\t;[AL]=the file number\r\n\tPUSH\tAX\t\t;save file number\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;skip comma before name\r\n\tCALL\tNAMSCN\t\t;parse filename setting FILDEV, FILNM, FILEXT\r\n\tCALL\tPORLEN\t\t;parse reclen parm\r\n\tJMP\tSHORT OPEN1\t;branch to common code (with Fnum on stack)\r\n\r\nERBFM0:\tJMP\tDERBFM\t\t;bad file mode error\r\n\r\nNOTNSO:\tCALL\tNAMSC1\t\t;parse filename setting FILDEV, FILNM, FILEXT\r\n\tMOV\tDH,LOW OFFSET MD_RND\t;Assume there is no FOR, in which\r\n\t\t\t\t;case the default mode is random.\r\n\tMOV\tAL,BYTE PTR 0[BX]\r\n\tCMP\tAL,LOW OFFSET $FOR\t;Is there a 'FOR'?\r\n\tJNZ\tGOTMOD\t\t;No, better see 'AS'\r\n\tCALL\tCHRGTR\r\n\tCMP\tAL,LOW OFFSET $INPUT\t;Input mode?\r\n\tMOV\tDH,LOW OFFSET MD_SQI\t;Assume it is\r\n\tJZ\tGOTMD1\t\t;Yes, have file mode\r\n\tCMP\tAL,LOW \"A\"\t;test\r\n\tJNE\tNTAPP\t\t;branch if not append (might be OUTPUT)\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"A\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"P\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"P\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"E\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"N\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"D\"\r\n\tMOV\tDH,LOW OFFSET MD_APP\t;append file mode\r\n\tJMP\tSHORT GOTMOD\t;allow it\r\nNTAPP:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"O\"\t;it must be OUTPUT\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"U\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"T\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"P\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"U\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"T\"\r\n\tMOV\tDH,LOW OFFSET MD_SQO\r\n\tJMP\tSHORT GOTMOD\r\n\r\nGOTMD1:\tCALL\tCHRGTR\r\nGOTMOD:\tMOV\tBYTE PTR FILMOD,DH\t;set file mode\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"A\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"S\"\t;Must have 'AS'\r\n\tCALL\tPOFNUM\t\t;[AL]=file #\r\n\tPUSH\tAX\t\t;save file#\r\n\tCALL\tPNRLEN\t\t;parse new reclen parameter\r\nOPEN1:\tDEC\tBX\r\n\tCALL\tCHRGTR\r\n\tJNZ\tSNERR1\t\t;error if not end-of-statement\r\n\tPOP\tAX\t\t;[AL]=file number\r\n\tCALL\tOPNFIL\t\t;branch to general file-open code\r\n\tJMP\tFINPRT\t\t;reset PTRFIL to 0 (keyboard/crt)\r\n\r\n;PORLEN - parse old variable record length field\r\n; Entry - [FILMOD]=file mode\r\n; Exit  - [CX]=reclen if reclen parm included, else 0\r\n;\r\nPORLEN:\tCALL\tPRLENC\r\n\tJZ\tPRLENX\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\r\n\tJMP\tSHORT VARECS\r\n\r\n;PNRLEN - parse new variable record length field\r\n; Entry - [FILMOD]=file mode\r\n; Exit  - [CX]=reclen if reclen parm included, else 0\r\n;\r\nPNRLEN:\tCALL\tPRLENC\r\n\tJZ\tPRLENX\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 377O\t;else parse \"LEN=record-length\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET $LEN\t;LEN is a 2-byte token\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET EQULTK\r\n\tEXTRN\tINTID2:NEAR\r\nVARECS:\tCALL\tINTID2\t\t;[DX]=record size (0..32767)\r\n\tMOV\tCX,DX\t\t;return it in CX\r\n\tOR\tCX,CX\r\n\tJZ\tFCERR1\t\t;0 is illegal value\r\nPRLENX:\tRET\t\r\n\r\n;PRLENC - see if reclen parm is expected\r\n;\r\nPRLENC:\r\n\tMOV\tCX,0\t\t;indicates reclen parm not included\r\n\tMOV\tAL,BYTE PTR FILMOD\t;[AL]=requested file mode\r\n\tCMP\tAL,LOW OFFSET MD_RND\r\n\tJNZ\tNOLEN\t\t;branch if file mode is not RANDOM\r\n\tDEC\tBX\t\t;decrement text pointer\r\n\tCALL\tCHRGTR\t\t;re-get last character parsed\r\n\tJZ\tNOLEN\t\t;branch if end-of-statement\r\n\tMOV\tCL,LOW 1\t;indicates reclen parm included\r\nNOLEN:\tOR\tCX,CX\t\t;set NZ if reclen parm included\r\n\tRET\t\r\n\r\nFCERR1:\tJMP\tFCERR\t\t;function call error\r\n\r\nSNERR1:\tJMP\tSNERR\t\t;syntax error\r\n\r\n\tSUBTTL CLOSE, WIDTH Statements\r\n\r\n\tPUBLIC\tCLOSE\r\n\r\n; CLOSE Statement\r\n;  Syntax: CLOSE [[#]n [,[#]n ...]]\r\n;\r\nCLOSE:\tJNZ\tCLOS1\t\t;branch if statement has parm\r\n\tJMP\tCLSALL\t\t;close all files if no parm given\r\nCLOS1:\tCMP\tAL,LOW \"#\"\r\n\tJNZ\tNOLBS\t\t;branch if no #\r\n\tCALL\tCHRGTR\t\t;skip #\r\nNOLBS:\r\n\tCALL\tGETBYT\t\t;[AL]=file#\r\n\tCALL\tCLSFIL\t\t;close file [AL] and return\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\r\n\tCMP\tAL,LOW 54O\t;check for comma\r\n\tJNZ\tRET6\t\t;branch if end of file list\r\n\tCALL\tCHRGTR\t\t;skip comma\r\n\tJMP\tSHORT CLOS1\t;close next file in list\r\n\r\n\tPUBLIC\tWIDTHS\r\n\r\n; WIDTH Y[,X]/[#fnum,]/[device,]   Statement\r\n; Entry - (BX) = text pointer\r\n;\r\nWIDTHS:\tCMP\tAL,LOW \"#\"\r\n\tJZ\tFILWID\t\t;Is files WIDTH specification\r\n\tCMP\tAL,LOW 54O\r\n\tJZ\tCRTWD1\t\t;branch if Comma\r\n\tEXTRN\t$LPRINT:NEAR,$_LPT1:NEAR\r\n\tCMP\tAL,LOW OFFSET $LPRINT\r\n\tJNZ\tNOTLPR\t\t;branch if not WIDTH LPRINT\r\n\tCALL\tCHRGTR\t\t;skip LPRINT\r\n\tMOV\tAL,LOW OFFSET $_LPT1\r\n\tJMP\tSHORT ITSWLP\r\nNOTLPR:\r\n\tPUSH\tBX\t\t;save Text Pointer in case CRT width\r\n\tCALL\tFRMEVL\t\t;evaluate string or number\r\n\tCALL\tGETYPR\r\n\tJNZ\tCRTWD\t\t;brif not string argument. CRT width\r\n\tPOP\tSI\t\t;discard old text pointer\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tCALL\tFRESTR\t\t;release temporary string descriptor\r\n\t\t\t\t;[BX] points to string descriptor\r\n\tMOV\tCL,BYTE PTR 0[BX]\r\n\tMOV\tCH,LOW 0\t;[CX]=length of string\r\n\tMOV\tSI,WORD PTR 1[BX]\t;SI points to start of string\r\n\tCALL\tPARDEV\t\t;AL=-(device number)\r\n\tPOP\tBX\t\t;restore text pointer\r\n\tPUSH\tAX\t\t;save device id\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\r\n\tPOP\tAX\t\t;[AL]=device id\r\nITSWLP:\r\n\tPUSH\tAX\t\t;save device id\r\n\tCALL\tGETWDT\t\t;[DL]=width\r\n\tPOP\tAX\t\t;[AL]=device id\r\n\tCALL\tCDEVID\t\t;[DI]=device dispatch table offset\r\n\tJZ\tERIFN0\t\t;illegal file name if device=disk\r\n\tMOV\tAH,LOW OFFSET G_SWD\t;select set-width function\r\n\tJMP\tTBLDSP\t\t;dispatch function [AH] for device [DI]\r\n\r\nFILWID:\tCALL\tPRFNUM\t\t;[AL]=file number\r\n\tCALL\tFDBPTR\t\t;[SI] points to file-data-block\r\n\tJZ\tERFNO1\t\t;branch if file not opened\r\n\tPUSH\tSI\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\r\n\tCALL\tGETWDT\t\t;[AL]=width (1..255)\r\n\tPOP\tSI\t\t;SI points to file data block\r\n\tMOV\tBYTE PTR F_WID[SI],AL\t;save width in FDB\r\nRET6:\tRET\t\r\n\r\nGETWDT:\tCALL\tGETBYT\r\n\tOR\tAL,AL\r\n\tJZ\tFCERR2\t\t;width of 0 is illegal\r\n\tRET\t\t\t;return if width is between 1 and 255\r\n\r\nCRTWD:\tPOP\tBX\t\t;restore text pointer\r\nCRTWD1:\tJMP\tGWWID\r\n\r\nFCERR2:\tJMP\tFCERR\r\nERIFN0:\tJMP\tDERIFN\t\t;illegal file name error\r\nERFNO1:\tJMP\tDERFNO\t\t;file not open error\r\nERDNA1:\tJMP\tDERDNA\t\t;Device not available\r\n\r\n\tSUBTTL BSAVE, BLOAD Statements\r\n\r\n\r\n\tPUBLIC\tBLOAD,BSAVE\r\n\tEXTRN\tGETBYT:NEAR,SYNCHR:NEAR,MAKINT:NEAR,CHRGTR:NEAR,SNERR:NEAR\r\n\tEXTRN\tPRODIR:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSAVLEN:WORD,SAVSEG:WORD\r\nDSEG\tENDS\r\n\r\n; BSAVE Statement - Save memory image to file\r\n; Syntax: BSAVE name, start-adr, byte-count\r\n;\r\nBSAVE:\tCALL\tBPARMS\t\t;parse parms\r\n\tINC\tAL\r\n\tJNZ\tSNERR2\t\t;Error if 1 or no parms.\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tPUSH\tCX\t\t;SAVE start-adr\r\n\tMOV\tAL,LOW OFFSET MD_SQO\t;open file 0 for output\r\n\tCALL\tNULOPM\r\n\tCALL\tSCDBIN\t\t;set file-code to binary\r\n\tMOV\tAL,LOW OFFSET BSVFID\t;output binary file ID\r\n\tCALL\tOUTDO\t\t;output to file\r\n\tMOV\tAX,WORD PTR SAVSEG\t;DX=Segment from DEF SEG statement\r\n\tCALL\tOUT16\t\t;write segment adr to file\r\n\tPOP\tAX\t\t;[AX]=start-adr\r\n\tPUSH\tAX\r\n\tCALL\tOUT16\t\t;output start adr\r\n\tMOV\tAX,WORD PTR SAVLEN\t;[DX]=number of bytes\r\n\tMOV\tCX,AX\t\t;[CX]=length\r\n\tCALL\tOUT16\t\t;output end adr + 1\r\n\tPOP\tBX\t\t;[BX]=start-adr\r\n\tMOV\tDX,WORD PTR SAVSEG\t;DX=Segment adr\r\n\tCALL\tOUTBLK\t\t;output binary\r\n\tJMP\tLODEND\t\t;exit\r\n\r\nSNERR2:\tJMP\tSNERR\r\n\r\n; BLOAD Statement - load memory image from disk\r\n; Syntax: BLOAD name[, start-adr]\r\n;\r\nBLOAD:\r\n\tCALL\tBPARMS\t\t;Get Parms if any.\r\n\tOR\tAL,AL\r\n\tJZ\tBLODP\t\t;Will set -1 if start-adr only given.\r\n\tINC\tAL\r\n\tJZ\tSNERR2\t\t;error if 2 parms given\r\nBLODP:\tDEC\tAL\t\t;AL=1: no start-adr parm, -1: start-adr parm\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tPUSH\tAX\t\t;save Parm Switch\r\n\tPUSH\tCX\t\t;save start-adr parm\r\n\tMOV\tAL,LOW OFFSET MD_SQI\r\n\tCALL\tNULOPM\t\t;Open File 0 for INPUT\r\n\tCALL\tSCDBIN\t\t;set file code to binary\r\n\tCALL\tINCHR\t\t;[A]=1st byte from file\r\n\tCMP\tAL,LOW OFFSET BSVFID\t;make sure this was created by BSAVE\r\n\tJNZ\tERBFM2\t\t;else BAD FILE MODE\r\n\tPOP\tCX\t\t;[CX]=start-adr parm\r\n\tCALL\tINP16\t\t;[AX]=next 16 bits from file\r\n\tMOV\tDX,AX\t\t;[DX]=default segment\r\n\tCALL\tINP16\t\t;[AX]=next 16 bits from file\r\n\tMOV\tBX,AX\t\t;[BX]=default start-adr\r\n\tPOP\tAX\t\t;AL=1: no start-adr parm, -1: start-adr parm\r\n\tDEC\tAL\r\n\tJZ\tDEFSAD\t\t;branch if no start-adr parm given\r\n\tMOV\tDX,WORD PTR SAVSEG\t;[DX]=segment parm\r\n\tMOV\tBX,CX\t\t;[BX]=start-adr parm\r\nDEFSAD:\tCALL\tINP16\t\t;[AX]=file length\r\n\tMOV\tCX,AX\t\t;[CX]=file length\r\n\tCALL\tINPBLK\t\t;do the load\r\nLODEND:\r\n\tPOP\tBX\t\t;restore text pointer\r\n\tJMP\tFINPRT\t\t;close file 0, reset PTRFIL\r\n\r\nERBFM2:\tJMP\tDERBFM\t\t;bad file mode error\r\n\r\n;BPARMS - Parse parms for BLOAD and BSAVE\r\n; Exit  - [AL]=(1,0,-1) if 0,1,2 parameters parsed.\r\n;         [BX] is preserved (text pointer)\r\n;         [CX] = start-adr\r\n;         [SAVLEN] = file size (if BSAVE)\r\n;\r\nBPARMS:\r\n\tCALL\tPRODIR\t\t;Don't allow in direct mode if protected\r\n\tCALL\tNAMSCN\t\t;scan file name and disk number\r\n\t\t\t\t;setting FILDEV, FILNM, FILEXT\r\n\tJB\tBNAMOK\t\t;Extension supplied by user\r\n\tCALL\tNAMBAS\t\t;Supply \".BAS\" default extension\r\nBNAMOK:\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\t\t;See if any parms\r\n\tJNZ\tBPARM2\t\t;Brif parms follow\r\n\tMOV\tAL,LOW 1\t;No Parms, use file header if BLOAD.\r\n\tRET\t\t\t; else exit.\r\nBPARM2:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \",\"\t;Must see comma first\r\n\tCALL\tADRGET\t\t;get start-adr (0..65535)\r\n\tPUSH\tDX\t\t;save it\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\r\n\tJNZ\tBPARM3\t\t;Brif 2nd Parm given.\r\n\tPOP\tCX\t\t;[CX]=start adr\r\n\tXOR\tAL,AL\t\t;Set 0 if 1 parm only given.\r\n\tRET\t\r\nBPARM3:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \",\"\r\n\tCALL\tADRGET\t\t;[DX]=number of bytes for bsave (0..65535)\r\n\tXCHG\tBX,DX\r\n\tMOV\tWORD PTR SAVLEN,BX\t;Save end ADDRESS+1(start+count)\r\n\tXCHG\tBX,DX\t\t;[BX]=text pointer\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\r\n\tJNZ\tSNERR3\t\t;must be end of statement\r\n\tPOP\tCX\t\t;[CX]=start-adr\r\n\tMOV\tAL,LOW 377O\t;Set -1 if 2 parms given.\r\n\tRET\t\r\n\r\nSNERR3:\tJMP\tSNERR\r\n\r\n\tSUBTTL LPRINT, PRINT Statements\r\n\r\n\tPUBLIC\tLPRINT,PRINT\r\n\tEXTRN\tPRINUS:NEAR,IMOD:NEAR,FOUT:NEAR,STRLIT:NEAR,STRPRT:NEAR\r\n\tEXTRN\tUSINTK:NEAR,TABTK:NEAR,SPCTK:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFACLO:WORD\r\nDSEG\tENDS\r\n\r\nJPRINU:\tJMP\tPRINUS\t\t;Print Using\r\n\r\nPRINTX:\tCALL\tCRDO\t\t;output terminating CR\r\nPRNTX1:\tPOP\tCX\t\t;discard line width, last comma column\r\n\tJMP\tFINPRT\t\t;close file#0, reset PTRFIL to keyboard\r\n\r\nLPRINT:\tMOV\tWORD PTR PTRFIL,-1\t;future output will go to Line Printer\r\n\tJMP\tSHORT PRINT1\r\nPRINT:\r\n\tMOV\tCL,LOW OFFSET MD_SQO\t;setup output file\r\n\tCALL\tFILGET\r\nPRINT1:\tCALL\tPTRWDC\t\t;[CH]=width, [CL]=last comma column\r\n\tPUSH\tCX\t\t;save on stack\r\nNEWCHR:\tDEC\tBX\r\n\tCALL\tCHRGTR\t\t;get another character\r\n\tJZ\tPRINTX\t\t;print CR if end without punctuation\r\nPRINTC:\tJZ\tPRNTX1\t\t;branch if end of statement\r\n\tPOP\tCX\t\t;refresh [CH]=width, [CL]=last comma column\r\n\tCMP\tAL,LOW OFFSET USINTK\t;is it \"print using\" ?\r\n\tJZ\tJPRINU\t\t;IF SO, USE A SPECIAL HANDLER\r\n\tPUSH\tCX\t\t;save [CH]=width, [CL]=last comma column\r\n\tCMP\tAL,LOW OFFSET TABTK\r\n\tJZ\tTABERJ\t\t;the TAB function?\r\n\tCMP\tAL,LOW OFFSET SPCTK\r\n\tJZ\tTABERJ\t\t;the SPC function?\r\n\tPUSH\tBX\t\t;save the text pointer\r\n\tCMP\tAL,LOW 44D\r\n\tJZ\tCOMPRT\t\t;Print Comma\r\n\tCMP\tAL,LOW 59D\t;is it a \";\"\r\n\tJNZ\tPRTS\r\n\tJMP\tNOTABR\r\nTABERJ:\tJMP\tTABER\r\nPRTS:\tPOP\tDX\t\t;get rid of old text pointer\r\n\tCALL\tFRMEVL\t\t;evaluate the formula\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tCALL\tGETYPR\t\t;see if we have a string\r\n\tJZ\tSTRDON\t\t;if so, print special\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\t\t;[BX]=addr of number terminator(non-blank)\r\n\tCMP\tBYTE PTR 0[BX],LOW 54O\r\n\tPUSHF\t\t\t;remember if value was comma terminated\r\n\tCALL\tFOUT\t\t;make a number into a string\r\n\tCALL\tSTRLIT\t\t;make it a string\r\n\tMOV\tBYTE PTR 0[BX],LOW \" \"\t;put a space at the end\r\n\tPOPF\t\r\n\tPOP\tBX\r\n\tPOP\tCX\t\t;restore [CH]=width, [CL]=last comma column\r\n\tPUSH\tCX\r\n\tPUSH\tBX\r\n\tMOV\tBX,WORD PTR FACLO\t;[BX]=address of string descriptor\r\n\tJNZ\tINCLEN\t\t;BRIF not comma terminated(print the space too)\r\n\tCALL\tPTRGPS\t\t;[AL]=file's current position\r\n\tADD\tAL,BYTE PTR 0[BX]\t;add length of string we will output\r\n;At this point we have [AL]=posn after number is printed(without space),\r\n;  [CH]=device width, [CL]=last comma posn, [BX]=addr of string descriptor.\r\n;IF number output stops at comma column minus one\r\n;THEN don't append blank(This insures that another number will appear at the\r\n;next comma column, instead of the second column posn after this string)\r\n\tCMP\tCH,LOW 255D\t;infinite width?\r\n\tJZ\tMODCOM\t\t;do modulus to determine next comma column\r\n\tCMP\tAL,CL\t\t;compare with last comma column\r\n\tJNB\tINCLEN\t\t;Will do CR after do output,\r\n\t\t\t\t; make string include blank\r\n;Determine if posn in [AL] is one less than a comma column\r\nMODCOM:\tINC\tAL\r\nMODCM1:\tSUB\tAL,LOW OFFSET CLMWID\t;[AL]=modulus CLMWID\r\n\tJA\tMODCM1\r\n\tJZ\tSTRDON\t\t;BRIF at comma column, exclude trailing space\r\nINCLEN:\tINC\tWORD PTR 0[BX]\t;increment the length to include the space\r\n\t\t\t\t;NOTE:number is less than 255(can do INC)\r\nSTRDON:\tPOP\tBX\r\n\tPOP\tCX\r\n\tPUSH\tCX\t\t;refresh [CH]=width, [CL]=last comma column\r\n\tPUSH\tBX\r\n\tMOV\tBX,WORD PTR FACLO\t;BX points to string descriptor\r\n\tINC\tCH\r\n\tJZ\tLINCH2\t\t;branch if infinite (255) line width\r\n\tDEC\tCH\t\t;restore [CH]=device width\r\n\tCALL\tPTRGPS\t\t;[AL]=file's current column pos\r\n\tOR\tAL,AL\t\t;don't CR if string longer than line\r\n\tJZ\tLINCH2\t\t;  length if position is 0\r\n\tADD\tAL,BYTE PTR 0[BX]\t;[AL]=column + string size\r\n\tCMC\t\t\t;set nc if overflow on check\r\n\tJAE\tLINCHK\t\t;start on a new line if overflow\r\n\tDEC\tAL\r\n\tCMP\tAL,CH\t\t;check for overlap\r\nLINCHK:\tJB\tLINCH2\t\t;branch if still on current line\r\n\tCALL\tCRDO\t\t;else output CR\r\nLINCH2:\tCALL\tSTRPRT\t\t;PRINT THE string/number\r\n\tPOP\tBX\t\t;restore text pointer\r\n\tJMP\tNEWCHR\t\t;print some more\r\n\r\n;PRINT comma (text pointer stacked)\r\n;\r\nCOMPRT:\tCALL\tPTRGPS\t\t;[AL]=file's current column position\r\n\tCMP\tCH,LOW 255D\t;infinite width?\r\n\tJZ\tMORCOM\t\t;do modulus\r\n\tCMP\tAL,CL\t\t;compare current with last comma column\r\nCHKCOM:\tJB\tMORCOM\t\t;branch if not beyond last comma col\r\n\tCALL\tCRDO\t\t;start new line\r\n\tJMP\tSHORT NOTABR\t;AND QUIT IF BEYOND LAST COMMA FIELD\r\nMORCOM:\tSUB\tAL,LOW OFFSET CLMWID\t;[AL]=MODULUS CLMWID\r\n\tJAE\tMORCOM\r\n\tNEG\tAL\r\n\tDEC\tAL\t\t;fill the print position out\r\n\t\t\t\t;to an even CLMWID, so\r\n\t\t\t\t;we print CLMWID-[AL] MOD CLMWID spaces\r\n\tJMP\tSHORT ASPA2\t;go print [AL]+1 spaces\r\n\r\n;PRINT TAB(N) & SPC(N)\r\n;\r\nTABER:\tPUSH\tAX\t\t;remember IF [A]=SPCTK or TABTK\r\n\tCALL\tCHRGTR\r\n\tCALL\tADRGET\t\t;[DX]=parameter (0..65535)\r\n\tPOP\tAX\t\t;see if its SPC or TAB\r\n\tPUSH\tAX\r\n\tOR\tDX,DX\r\n\tJG\tTBNONG\t\t;branch if greater than 0\r\n\tMOV\tDX,0\t\t;map negative parms to 0\r\n\tJMP\tSHORT SPCNDC\r\nTBNONG:\tCMP\tAL,LOW OFFSET SPCTK\t;if space leave alone\r\n\tJZ\tSPCNDC\r\n\tDEC\tDX\t\t;offset TAB by 1\r\nSPCNDC:\tPUSH\tBX\t\t;save the text pointer\r\n\tMOV\tBL,CH\t\t;[BL]=file width\r\n\tMOV\tAL,CH\t\t;[AL]=file width\r\n\tINC\tAL\t\t;test for width of 255 (no folding)\r\n\tJZ\tLNOMOD\t\t;if so, don't mod\r\n\tMOV\tBH,LOW 0\t;MOD out by line length\r\n\tCALL\tIMOD\t\t;[BX]=[DX] MOD filewidth\r\n\tXCHG\tDX,BX\t\t;set [DL] = position to go to\r\nLNOMOD:\tPOP\tBX\t\t;get back the text pointer\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\r\n\tDEC\tBX\r\n\tPOP\tAX\t\t;get back SPCTK or TABTK\r\n\tSUB\tAL,LOW OFFSET SPCTK\t;was it SPCTK?\r\n\tPUSH\tBX\t\t;save the text pointer\r\n\tJZ\tDOSIZT\t\t;value in [AL]\r\n\tCALL\tPTRGPS\t\t;[AL]=file position\r\nDOSIZT:\tNEG\tAL\t\t;print [E]-[A] spaces\r\n\tDEC\tAL\r\n\tADD\tAL,DL\r\n\tJB\tASPA2\t\t;print if past current\r\n\tINC\tAL\r\n\tJZ\tNOTABR\t\t;do nothing if at current\r\n\tCALL\tCRDO\t\t;go to a new line\r\n\tMOV\tAL,DL\t\t;get the position to go to\r\n\tDEC\tAL\r\n\tJS\tNOTABR\r\nASPA2:\tINC\tAL\r\nASPAC:\tMOV\tDL,AL\t\t;[B]=number of spaces to print\r\n\tMOV\tAL,LOW \" \"\t;[A]=space\r\nREPOUT:\tCALL\tOUTDO\t\t;PRINT [AL]\r\n\tDEC\tDL\t\t;decrement the count\r\n\tJNZ\tREPOUT\r\nNOTABR:\tPOP\tBX\t\t;pick up text pointer\r\n\tCALL\tCHRGTR\t\t;and the next character\r\n\tJMP\tPRINTC\t\t;and since we just printed\r\n\t\t\t\t;spaces, don't call crdo\r\n\t\t\t\t;if it's the end of the line\r\n\r\n\tSUBTTL EOF, LOC, LOF  Functions\r\n\r\n\tPUBLIC\tEOF,LOC,LOF\r\n\tEXTRN\tCONINT:NEAR\r\n\r\n; EOF(n) Function - returns -1 if eof, else 0\r\n; Entry - [FAC] = file number\r\n; Exit  - [FAC] = -1 if EOF, else 0.\r\n;\r\nEOF:\tCALL\tFACFPT\t\t;[SI] points to FDB for file [FAC]\r\n\tJZ\tERFNO4\t\t;error if file not opened\r\n\tXOR\tBX,BX\t\t;BX=0 (assume not at eof)\r\n\tTEST\tBYTE PTR F_FLGS[SI],LOW OFFSET FL_BKC\r\n\tJNZ\tGFUNX\t\t;if character backed up, no eof\r\n\tDEC\tBX\t\t;[BX]=-1 (EOF true)\r\n\tCMP\tBYTE PTR F_ORCT[SI],LOW 0\r\n\tJE\tGFUNX\t\t;branch if FDB EOF flag set\r\n\tMOV\tAH,LOW OFFSET G_EOF\t;End of file function\r\n\tCALL\tSIDSP\r\n\tJMP\tSHORT GFUNX\t;return result in FAC\r\n\r\nERFNO4:\tJMP\tDERFNO\t\t;file not open error\r\n\r\n; LOC(n) Function\r\n; Entry - [FAC] = file number\r\n; Exit  - [FAC] = current record number\r\n;\r\nLOC:\tMOV\tAH,LOW OFFSET G_LOC\t;LOC function\r\nGENFUN:\tCALL\tFACDSP\t\t;[BX]=EOF(file [FAC])\r\nGFUNX:\tJMP\tMAKINT\t\t;return result in FAC\r\n\r\n; LOF(n) Function\r\n; Entry - [FAC] = file number\r\n; Exit  - [FAC] = length of file in bytes\r\n;\r\nLOF:\tMOV\tAH,LOW OFFSET G_LOF\t;LOF Function\r\n\tJMP\tFACDSP\t\t;[FAC]=LOF(file [FAC])\r\n\r\n\tSUBTTL GET/PUT - Random disk I/O Statements\r\n\r\n\tPUBLIC\tDPUTG\r\n\r\n;Syntax - GET fn [,recnum]   (if no recnum next relative record assumed)\r\n;         PUT fn [,recnum]\r\n; Entry - [BX] = text pointer\r\n;         [CX] = 0 for GET, 1 for PUT\r\n;\r\nDPUTG:\r\n\tPUSH\tCX\t\t;save GET/PUT Flag\r\n\tCALL\tPOFNUM\t\t;[AL]=file number\r\n\tCALL\tFDBPTR\t\t;[SI] points to File Data Block of file [AL]\r\n\tJZ\tERFNO3\t\t;branch if file not open\r\n\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_RND\r\n\tJNE\tERBFM1\t\t;Not random - bad file mode\r\n\tPUSH\tSI\t\t;save FDB pointer\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\t\t;reget next character\r\n\tJZ\tRELRND\t\t;branch if end-of-statement (relative record)\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;parse required comma\r\n\tCALL\tADRGET\t\t;[DX]=record number (0..65535)\r\n\tPOP\tSI\t\t;restore FDB pointer\r\n\tPOP\tAX\t\t;restore GET/PUT flag\r\n\tADD\tAX,2\t\t;[AX]=2 for GET [DX], 3 for PUT [DX]\r\n\tJMP\tSHORT RELRN1\r\nRELRND:\tPOP\tSI\t\t;restore FDB pointer\r\n\tPOP\tAX\r\nRELRN1:\tPUSH\tBX\t\t;save text pointer\r\n\t\t\t\t;[AL]=0,1,2,3 for GET PUT GETrel PUTrel\r\n\tMOV\tAH,LOW OFFSET G_RND\t;select Random I/O function code\r\n\tCALL\tSIDSP\t\t;dispatch to routine for FDB SI\r\n\tPOP\tBX\t\t;restore text pointer\r\n\tRET\t\r\n\r\nERBFM1:\tJMP\tDERBFM\r\n\r\n\tSUBTTL Misc. Parsing Routines\r\n\r\n;POFNUM - Parse optional file number \"[#]n\"\r\n; Entry - [BX] = text pointer\r\n; Exit  - [BX] = updated text pointer, [AL]=file number\r\n;         All other registers preserved\r\n;\r\nPOFNUM:\tCMP\tBYTE PTR 0[BX],LOW \"#\"\t;[AL]=current character\r\n\tJNZ\tGETNZB\t\t;branch if optional # not included\r\n\r\n;PRFNUM - Parse required file number \"#n\"\r\n; Entry - [BX] = text pointer\r\n; Exit  - [BX] = updated text pointer, [AL]=file number\r\n;         All other registers preserved\r\n;\r\nPRFNUM:\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"#\"\r\n\r\n;GETNZB - Parse byte (1..255) expression, returning result in [AL]\r\n; Entry - [BX] = text pointer\r\n; Exit  - [BX] = updated text pointer, [AL]=byte parsed\r\n;         All other registers preserved\r\n;\r\nGETNZB:\tPUSH\tDX\r\n\tPUSH\tCX\r\n\tCALL\tGETBYT\t\t;[AL]=file number\r\n\tOR\tAL,AL\r\n\tJZ\tERBFN1\t\t;bad file number if 0\r\n\tPOP\tCX\r\n\tPOP\tDX\r\nRET9:\tRET\t\r\n\r\nERBFN1:\tJMP\tDERBFN\t\t;bad file number\r\n\r\n\tPUBLIC\tFILINP,FILGET,GETPTR,FILSET,FILSCN\r\nFILINP:\tMOV\tCL,LOW OFFSET MD_SQI\t;MUST BE SEQUENTIAL INPUT\r\nFILGET:\tCMP\tAL,LOW \"#\"\t;NUMBER SIGN THERE?\r\n\tJNZ\tRET9\t\t;NO, NOT FILE INPUT\r\n\tPUSH\tCX\t\t;SAVE EXPECTED MODE\r\n\tCALL\tFILSCN\t\t;READ AND GET POINTER\r\n\tJZ\tERFNO3\t\t;ERROR IF FILE NOT OPEN\r\n\tPOP\tDX\t\t;[DL]=FILE MODE\r\n\tCMP\tAL,DL\t\t;IS IT RIGHT?\r\n\tJZ\tGDFILM\t\t;GOOD FILE MODE\r\n\tCMP\tAL,LOW OFFSET MD_RND\t;ALLOW STUFF WITH RANDOM FILES\r\n\tJNZ\tERBFM3\t\t;IF NOT, \"BAD FILE MODE\"\r\nGDFILM:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;GO PAST THE COMMA\r\nFILSET:\tMOV\tDX,CX\t\t;SETUP PTRFIL\r\n\tMOV\tWORD PTR PTRFIL,CX\r\n\tRET\t\r\n\r\nERBFM3:\tJMP\tDERBFM\r\nERFNO3:\tJMP\tDERFNO\r\n\r\n\r\n;FILSCN - parse file number\r\n; Entry - [BX]=text pointer\r\n; Exit  - [DL]=file number, [SI], [CX] point to file data block for file [DL]\r\n;         [AL]=file mode, FLAGS.Z is set if file is not open.\r\n;         note - if file is not open, no FDB exists\r\n;\r\nFILSCN:\tCALL\tPOFNUM\t\t;[AL]=file number\r\n\r\nFILIDX:\tMOV\tDL,AL\t\t;return file number in [DL]\r\nFILID2:\tCALL\tFDBPTR\t\t;SI points to FDB for file [AL]\r\n\tJZ\tNTOPEN\t\t;branch if file is not open\r\n\tMOV\tCX,SI\t\t;CX  points to FDB\r\n\tMOV\tAL,BYTE PTR F_MODE[SI]\t;[AL]=file mode\r\n\tOR\tAL,AL\t\t;set non-zero (file is opened)\r\nNTOPEN:\tRET\t\r\n\r\n;GETPTR IS CALLED FROM VARPTR(#<EXPRESSION>)\r\n; Entry - [AL]=file number\r\n; Exit  - [DX] points to random file buffer, or sector buffer of file\r\n;\r\nGETPTR:\tCALL\tFDBPTR\t\t;SI points to File Data Block\r\n\tJZ\tERFNO3\t\t;error if file not open\r\n\tMOV\tDX,OFFSET F_MODE\t;Return pointer to MODE\r\n\tADD\tDX,SI\t\t;Return result in [DX]\r\n\tRET\t\r\n\r\n;DIRDO is called to make sure direct statement is not found when loading file\r\n; If device is keyboard, control transfers to GONE with AX used.\r\n;\r\n\tPUBLIC\tDIRDO\r\nDIRDO:\tMOV\tAX,WORD PTR PTRFIL\r\n\tOR\tAX,AX\r\n\tJNZ\tERFDR\t\t;if device not keyboard then\r\n\t\t\t\t;   error(direct statement in file)\r\nEXTRN\tGONE:NEAR\r\n\tJMP\tGONE\t\t;else OK\r\n\r\nERFDR:\tJMP\tDERFDR\r\n\r\n;ADRGET - parse 16 bit expression\r\n; Entry - [BX]=text pointer\r\n; Exit  - [DX]=result (0..65535)\r\n;         [BX]=updated text pointer\r\n;         AX used, other registers preserved.\r\n;\r\n\tPUBLIC\tADRGET\r\nADRGET:\tPUSH\tCX\r\nEXTRN\tFRMEVL:NEAR\r\n\tCALL\tFRMEVL\r\n\tPUSH\tBX\r\nEXTRN\tFRQINT:NEAR\r\n\tCALL\tFRQINT\t\t;Make Unsigned 16 bits\r\n\tPOP\tDX\r\n\tXCHG\tBX,DX\t\t;Offset in [DX], text pointer in [BX]\r\n\tPOP\tCX\r\n\tRET\t\r\n\r\n\tSUBTTL Major I/O Routines\r\n\r\n;PRGFIL is called to open file #0 (SAVE/LOAD/MERGE etc.)\r\n; Entry - [BX]=text pointer, pointing at filename\r\n;         [DH]=file mode\r\n; Exit  - [PTRFIL] points to files FDB (directing all future I/O to file)\r\n;         [BX]=[TEMP]=updated text pointer\r\n;         SI may be destroyed.\r\n;\r\n\tPUBLIC\tPRGFIL\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tTEMP:WORD\r\nDSEG\tENDS\r\nPRGFIL:\tMOV\tBYTE PTR FILMOD,DH\t;save file mode (MD.SQI / MD.SQO)\r\n\tCALL\tNAMSCN\t\t;scan filename\r\n\tMOV\tWORD PTR TEMP,BX\t;PRGFIN restores text pointer when done\r\n\tJB\tPRGFIX\t\t;Exit - \".\" found in name\r\n\tCALL\tNAMBAS\t\t;Add \".BAS\" extension to disk file names\r\nPRGFIX:\tJMP\tSHORT NULOPN\t;open file #0\r\n\r\n;NAMBAS is called to add the \".BAS\" extension to disk file names\r\n;Entry - FILDEV points to device id\r\n;Exit  - SI destroyed\r\n;\r\nNAMBAS:\tMOV\tSI,OFFSET FILDEV\t;SI points to device id\r\n\tTEST\tBYTE PTR 0[SI],LOW 377O\r\n\tJS\tNAMBAX\t\t;Exit if device is not DISK\r\n\tADD\tSI,9D\t\t;SI points to Extention\r\n\tCMP\tBYTE PTR 0[SI],LOW \" \"\t;if blank extention, default to \".BAS\"\r\n\tJNE\tNAMBAX\t\t;Exit if device is not DISK\r\n\tMOV\tWORD PTR 0[SI],OFFSET (400O*\"A\")+\"B\"\r\n\tMOV\tBYTE PTR 2[SI],LOW \"S\"\r\nNAMBAX:\tRET\t\r\n\r\n;NULOPN opens File 0 with mode [AL].\r\n; Exit  - [PTRFIL] points to files FDB (directing all future I/O to file)\r\n;\r\n\tPUBLIC\tNULOPM\r\nNULOPM:\tMOV\tBYTE PTR FILMOD,AL\t;FILMOD=file mode\r\nNULOPN:\tXOR\tAL,AL\t\t;[AL]=file number\r\n\tXOR\tCX,CX\t\t;random record length = 0\r\n\t\t\t\t;fall into OPNFIL\r\n\r\n;OPNFIL - general file-open routine\r\n; Entry - [AL]=file number (0..n)\r\n;         [CX]=record length (0=default)\r\n;         [FILMOD]=mode (MD.SQI / MD.SQO / MD.RND / MD.APP)\r\n;         [FILDEV]=device id\r\n;         [FILNM]=filename\r\n;         [FILEXT]=1..3 byte filename extension\r\n; Exit  - [PTRFIL] points to files FDB (directing all future I/O to file)\r\n;         all registers preserved\r\n;\r\nOPNFIL:\tPUSHF\t\r\n\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tPUSH\tSI\r\n\tPUSH\tDI\r\n\tMOV\tBL,AL\r\n\tMOV\tBH,LOW 0\t;[BX]=file number\r\n\tCALL\tFDBPTR\t\t;see if file is already open\r\n\tJNZ\tERFAO1\t\t;error if already open\r\n\tMOV\tAL,BYTE PTR FILDEV\t;[AL]=device id\r\n\tCALL\tCDEVID\t\t;[DI]=device dispatch table offset (AL)\r\n\tMOV\tAH,LOW OFFSET G_OPN\t;open function code (AL is still DEVICE ID)\r\n\tCALL\tTBLDSP\t\t;call device-dependent open routine\r\n\tPOP\tDI\r\n\tPOP\tSI\r\n\tPOP\tDX\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tPOP\tAX\r\n\tPOPF\t\r\n\tRET\t\r\n\r\nFCERR3:\tJMP\tFCERR\r\nERFAO1:\tJMP\tDERFAO\t\t;file already opened error\r\n\r\n;CLSALL - close all opened files\r\n; Entry - none\r\n; Exit  - All registers preserved\r\n;\r\n\tPUBLIC\tCLSALL\r\nCLSALL:\tPUSH\tAX\r\n\tPUSH\tSI\r\n\tMOV\tSI,WORD PTR FILTAB\t;Get address of next file block\r\nCLSAL1:\tCMP\tSI,WORD PTR STKLOW\r\n\tJZ\tCLSALX\t\t;Branch if finished\r\n\tPUSH\tWORD PTR F_NEXT[SI]\t;save pointer to next entry in chain\r\n\tMOV\tAL,BYTE PTR F_NUM[SI]\t;[AL]=file number\r\n\tCALL\tCLSFIL\t\t;Close file [AL]\r\n\tPOP\tSI\t\t;SI points to next FDB in chain\r\n\tJMP\tSHORT CLSAL1\t;Keep looping till all files closed\r\nCLSALX:\tPOP\tSI\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n;CLSFIL - close file [AL]\r\n; Exit  - Flags, AX, SI used, all other registers are preserved\r\n;\r\n\tPUBLIC\tCLSFIL\r\nCLSFIL:\tMOV\tAH,BYTE PTR NLONLY\r\n\tTEST\tAH,LOW 200O\t;see if Chain All / Load, R in progress\r\n\tJNZ\tRET22\t\t;branch if Dont-Close-Any-Files flag set\r\n\tTEST\tAH,LOW 1\t;see if Load/Merge/Chain is in progress\r\n\tJZ\tCLSFL1\t\t;branch if Dont-Close-File-0 flag not set\r\n\tOR\tAL,AL\r\n\tJZ\tRET22\t\t;branch if trying to close file 0\r\nCLSFL1:\tCALL\tFDBPTR\t\t;[SI] points to FDB [AL]\r\n\tJZ\tRET22\t\t;branch if file already closed\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tMOV\tWORD PTR FREFDB,SI\t;So FINPRT will force close file if low-level\r\n\t\t\t\t;close routine gets I/O error\r\n\tMOV\tAH,LOW OFFSET G_CLS\r\n\tCALL\tSIDSP\t\t;close FDB pointed to by [SI]\r\n\tMOV\tWORD PTR FREFDB,0\r\n\tCALL\tFFREE\t\t;Deallocate FDB and remove from FDB Chain\r\n\tPOP\tDX\r\n\tPOP\tCX\r\n\tPOP\tBX\r\nRET22:\tRET\t\r\n\r\n;INCHR - get next byte from file PTRFIL\r\n; Exit  - [AL]=byte, [FLAGS], [AH] destroyed.\r\n;         All other regs preserved\r\n;         if END-OF-FILE then\r\n;            if program load was in progress, file 0 closed etc.\r\n;            else Read-Past-End error is generated\r\n;\r\n\tPUBLIC\tINCHR\r\n\tEXTRN\tPRGFIN:NEAR,KYBSIN:NEAR\r\nINCHR:\r\n\tPUSH\tSI\r\n\tCALL\tINCHRE\t\t;[AL]=next byte from PTRFIL, carry if EOF\r\n\tJAE\tINCHRX\t\t;branch if not EOF\r\n\tCMP\tBYTE PTR F_NUM[SI],LOW 0\t;EOF on ASCII file #0 = end of Load/Chain/Merge\r\n\tJE\tFL0EOF\t\t;branch if EOF reached for file #0\r\nEXTRN\tDERRPE:NEAR\r\n\tJMP\tDERRPE\t\t;Input past end error\r\nFL0EOF:\tCMP\tBYTE PTR F_CODE[SI],LOW OFFSET FC_BIN\r\n\tJNE\tLDREOF\t\t;branch if not binary file (must be ascii LOAD)\r\n\tSTC\t\t\t;else must be BLOAD/binary LOAD\r\n\tRET\t\t\t;return EOF indication to caller\r\nLDREOF:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCHNFLG:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tCHNRET:NEAR\r\n\tCMP\tBYTE PTR CHNFLG,LOW 0\t;chain in progress?\r\n\tJE\tNOTCHN\t\t;branch if not chaining\r\n\tJMP\tCHNRET\t\t;perform variable block transfer, etc.\r\n\t\t\t\t; close all files\r\nNOTCHN:\r\n\tPUSH\tBX\t\t;save all registers\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tMOV\tAL,BYTE PTR NLONLY\t;get load flags\r\n\tAND\tAL,LOW 200O\t;leave others open, null gets closed\r\n\tMOV\tBYTE PTR NLONLY,AL\t;allow other files to be closed\r\n\tCALL\tPRGFIN\t\t;close the file\r\n\tPOP\tDX\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tMOV\tAL,BYTE PTR RUNFLG\t;run it or not?\r\n\tOR\tAL,AL\r\n\tJZ\tNORUNC\t\t;dont run program\r\n\tEXTRN\tRUNC:NEAR\r\n\tCALL\tRUNC\t\t;run it\r\n\tEXTRN\tNEWSTT:NEAR\r\n\tJMP\tNEWSTT\r\nNORUNC:\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tEXTRN\tREDDY:NEAR,STROUT:NEAR\r\n\tMOV\tBX,OFFSET REDDY\t;print prompt \"ok\"\r\n\tCALL\tSTROUT\r\n\tPOP\tDX\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tMOV\tAL,LOW 13D\r\nINCHRX:\tPOP\tSI\r\n\tRET\t\r\n\r\n;INCHRE - get next byte from file PTRFIL.\r\n; Exit  - Carry set if EOF, else [AL]=byte.\r\n;         SI points to FDB\r\n;         All other regs preserved\r\n;\r\n\tPUBLIC\tINDSKC\t\t;Referenced by DSKCOM\r\nINDSKC:\r\nINCHRE:\tMOV\tSI,WORD PTR PTRFIL\t;SI points to current FDB\r\n\t\t\t\t;fall into INCHSI\r\n\r\n;INCHSI - get next byte from file SI (CTL Z = end-of-file)\r\n; Exit  - Carry set if EOF, else [AL]=byte.\r\n;         All other regs preserved\r\n;\r\n\tPUBLIC\tINCHSI\r\nINCHSI:\tINC\tSI\r\n\tJZ\tERBFM6\t\t;branch if Line Printer (can't input)\r\n\tDEC\tSI\r\n\tJNZ\tINGFDB\t\t;branch if not Keyboard (got FDB)\r\n\tEXTRN\tINCHRI:NEAR\r\n\tJMP\tINCHRI\r\nINGFDB:\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_SQO\r\n\tJZ\tERBFM6\r\n\tCMP\tBYTE PTR F_ORCT[SI],LOW 0\r\n\tJZ\tINCEOF\t\t;branch if EOF already reached\r\n\tTEST\tBYTE PTR F_FLGS[SI],LOW OFFSET FL_BKC\r\n\tJNZ\tGETBKC\t\t;branch if char backed up\r\n\tMOV\tAH,LOW OFFSET G_SIN\r\n\tCALL\tSIDSP\t\t;[AL]=next input from file\r\n\tJB\tINCEOF\t\t;branch if device detected EOF\r\n\tRET\t\r\n\r\nINCEOF:\tMOV\tBYTE PTR F_ORCT[SI],LOW 0\t;indicates EOF on future calls\r\n\tMOV\tBYTE PTR F_BREM[SI],LOW 0\r\n\tSTC\t\t\t;tells caller EOF reached\r\n\tRET\t\r\n\r\nGETBKC:\tAND\tBYTE PTR F_FLGS[SI],LOW OFFSET 255D-FL_BKC\t;clear Backup Present flag\r\n\tMOV\tAL,BYTE PTR F_BAKC[SI]\t;return Backed-up character\r\n\tRET\t\t\t;with no carry (no-eof)\r\n\r\nERBFM6:\tJMP\tDERBFM\t\t;bad file mode error\r\n\r\n\tPUBLIC\tCRFIN,CRDONZ,FININL,CRDO\r\nCRFIN:\tXOR\tAL,AL\t\t;all references should be eliminated\r\n\tRET\t\r\n\r\n;CRDONZ - output carriage return if file PTRFIL is not at left margin\r\n;\r\nCRDONZ:\tCALL\tPTRGPS\t\t;[AH]=0-relative column for PTRFIL\r\n\tOR\tAH,AH\r\n\tJNZ\tCRDO\t\t;if not at column 0, output CRLF\r\n\tRET\t\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tBUFMIN:WORD\r\nDSEG\tENDS\r\nFININL:\tMOV\tBYTE PTR 0[BX],LOW 0\r\n\tMOV\tBX,OFFSET BUFMIN\r\n\r\n;CRDO - output ascii carriage return to current file\r\n;\r\nCRDO:\tMOV\tAL,LOW OFFSET ASCCR\r\n\tCALL\tOUTDO\t\t;output Carriage Return\r\n\tMOV\tAL,LOW OFFSET ASCLF\t;output Line Feed\r\n\tCALL\tOUTDO\r\n\tXOR\tAL,AL\t\t;must return with [AL]=0 and FLAGS.Z true\r\n\tRET\t\r\n\r\n;OUTDO - output [AL] to current file (force CR if end-of-line)\r\n; Exit - All registers preserved (including FLAGS)\r\n;\r\n\tPUBLIC\tOUTDO,FILOU3\r\nFILOU3:\r\nOUTDO:\r\n\tPUSHF\t\r\n\tPUSH\tAX\r\n\tMOV\tAH,LOW OFFSET G_SOT\r\n\tCALL\tPTRDSP\t\t;dispatch to function [DL] for PTRFIL\r\n\tPOP\tAX\r\n\tPOPF\t\r\n\tRET\t\r\n\r\n;OUT16 - output data [AX] to current file\r\n;\r\nOUT16:\tPUSH\tAX\r\n\tCALL\tOUTDO\t\t;output low-byte first\r\n\tXCHG\tAH,AL\r\n\tCALL\tOUTDO\t\t;then output high-byte\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n;INP16 reads the next 16 bits from file PTRFIL\r\n; Exit  - [AX]=result. Carry set if EOF.\r\n;         All other registers are preserved.\r\n;\r\nINP16:\tPUSH\tBX\r\n\tCALL\tINCHR\t\t;get low-byte first\r\n\tMOV\tBL,AL\r\n\tCALL\tINCHR\t\t;then get high-byte\r\n\tMOV\tBH,AL\r\n\tMOV\tAX,BX\r\nINP16X:\tPOP\tBX\r\n\tRET\t\r\n\r\n;BAKCHR - backup sequential input file\r\n; Entry - [AL] = char to be backed up\r\n;         [PTRFIL] points to FDB of file to be backed up\r\n;\r\n\tPUBLIC\tBAKCHR,BCHRSI\r\nBAKCHR:\tPUSH\tSI\r\n\tMOV\tSI,WORD PTR PTRFIL\r\n\tCALL\tBCHRSI\r\n\tPOP\tSI\r\n\tRET\t\r\n\r\n;BCHRSI - backup sequential input file\r\n; Entry - [AL] = char to be backed up\r\n;         [SI] points to FDB of file to be backed up\r\n;\r\nBCHRSI:\tMOV\tBYTE PTR F_BAKC[SI],AL\r\n\tOR\tBYTE PTR F_FLGS[SI],LOW OFFSET FL_BKC\t;set flag indicating char backed up\r\n\tRET\t\r\n\r\n;BINSAV - Binary SAVE support.\r\n;\r\n\tPUBLIC\tBINSAV,BINPSV\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tTXTTAB:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tPROCHK:NEAR,SCCPTR:NEAR\r\nBINSAV:\tCALL\tSCCPTR\t\t;GET RID OF POINTERS BEFORE SAVING\r\n\tCALL\tPROCHK\t\t;DONT ALLOW BINARY SAVES OF PROTECTED PROGRAMS\r\n\tCALL\tSCDBIN\t\t;Set attribute CODE to BINARY (not ASCII)\r\n\tMOV\tAL,LOW 255D\t;ALWAYS START WITH 255\r\nBINPSV:\tCALL\tFILOU3\t\t;SEND TO FILE\r\n\tMOV\tCX,WORD PTR VARTAB\t;GET STOP POINT\r\n\tMOV\tBX,WORD PTR TXTTAB\t;GET START POINT\r\n\tSUB\tCX,BX\t\t;Calculate bytes to SAVE\r\n\tJBE\tBINSVX\t\t;Nothing to SAVE\r\n\tMOV\tDX,DS\t\t;Get Segment for SAVE\r\n\tCALL\tOUTBLK\t\t;Write the block\r\nBINSVX:\tJMP\tPRGFIN\t\t;REGET TEXT POINTER AND CLOSE FILE 0\r\n\r\n;DEVBIN - General device block input routine.  This routine is called by\r\n;         device code for devices which have no block I/O capability.\r\n; Entry - [BX] = Start adr\r\n;         [CX] = number of bytes to read\r\n;         [DX] = Segment adr\r\n;         [SI] = address of FDB\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - [BX] = End+1\r\n;         Carry set if reached end of data before CX bytes read\r\n;         SI, CX, AX used.\r\n;\r\n\tPUBLIC\tDEVBIN\r\nDEVBIN:\tOR\tCX,CX\r\n\tJZ\tRET27\t\t;Until end.\r\n\tMOV\tAH,LOW OFFSET G_SIN\t;sequential input function\r\n\tCALL\tPTRDSP\t\t;[AL]=next byte from file PTRFIL\r\n\tJB\tRET27\t\t;branch if tried to read past end-of-file\r\n\tPUSH\tDS\r\n\tPUSH\tDX\r\n\tPOP\tDS\t\t;[DS]=[DX]\r\n\tMOV\tBYTE PTR 0[BX],AL\t;Store Byte\r\n\tPOP\tDS\r\n\tINC\tBX\t\t;bump destination pointer\r\n\tDEC\tCX\t\t;decrement byte count\r\n\tJMP\tSHORT DEVBIN\r\n\r\n;DEVBOT - General device block output routine.  This routine is called by\r\n;         device code for devices which have no block I/O capability.\r\n; Entry - [BX] = Start adr\r\n;         [CX] = number of bytes to write\r\n;         [DX] = segment adr\r\n;         [SI] = address of FDB\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - [BX] = End + 1\r\n;\r\n\tPUBLIC\tDEVBOT\r\nDEVBOT:\tOR\tCX,CX\r\n\tJZ\tRET27\t\t;Until Len=0.\r\n\tPUSH\tDS\t\t;save BASIC's Data Segment\r\n\tPUSH\tDX\r\n\tPOP\tDS\t\t;DS=DX\r\n\tMOV\tAL,BYTE PTR 0[BX]\r\n\tPOP\tDS\t\t;restore BASIC's Data Segment\r\n\tCALL\tOUTDO\t\t;Write Byte from Memory.\r\n\tINC\tBX\r\n\tDEC\tCX\r\n\tJMP\tSHORT DEVBOT\r\nRET27:\tRET\t\r\n\r\n;OUTBLK - Write Block of memory to current file\r\n; Entry - [BX] = Start adr\r\n;         [CX] = number of bytes to write\r\n;         [DX] = segment adr\r\n; Exit  - [BX] = End + 1\r\n;\r\nOUTBLK:\tMOV\tSI,WORD PTR PTRFIL\r\n\tMOV\tAH,LOW OFFSET G_BOT\t;Block output function\r\n\tCALL\tPTRDSP\r\n\tRET\t\r\n\r\n; INPBLK - Read block of memory from current file\r\n; Entry - [BX] = Start adr\r\n;         [CX] = number of bytes to read\r\n;         [DX] = Segment adr\r\n; Exit  - [BX] = End+1\r\n;         Carry set if reached end of data before CX bytes read\r\n;         SI, CX, AX used.\r\n;\r\n\tEXTRN\tDFSTLD:NEAR\r\nINPBLK:\tMOV\tSI,WORD PTR PTRFIL\r\n\tMOV\tAH,LOW OFFSET G_BIN\t;block input function\r\n\tCALL\tPTRDSP\t\t;[AL]=next byte from file PTRFIL\r\n\tRET\t\r\n\r\n;FSTLOD - load Binary BASIC program (Called from DSKCOM after LOAD statement)\r\n; Entry - BX points to destination of program\r\n;         [FRETOP] - [BX] - ^D86 = maximum legal size of program\r\n;         [PTRFIL] points to FDB of file to be loaded\r\n;         (note: 1st byte of file has already been read and was ^D254)\r\n;\r\n\tPUBLIC\tFSTLOD\r\n\tEXTRN\tOUTLOD:NEAR\r\nFSTLOD:\r\n\tMOV\tCX,WORD PTR FRETOP\t;Bottom of string space\r\n\tSUB\tCX,86D\t\t;leave a little breathing room\r\n\tSUB\tCX,BX\t\t;[CX]=maximum legal size of program\r\n\tCALL\tSCDBIN\t\t;set CODE attribute to Binary\r\n\tPUSH\tDS\r\n\tPOP\tDX\t\t;[DX]=segment to be used\r\n\tCALL\tINPBLK\t\t;read block from device to disk\r\n\tJB\tRET27\t\t;branch if file fits in memory\r\n\tJMP\tOUTLOD\t\t;ERROR AND WIPE OUT PARTIAL GARBAGE\r\n\r\n;PTRGPS - get column position for file PTRFIL\r\n;\r\n; Exit  - [AH] = [AL] = column position\r\n;         FLAGS.Z is true if at column 0\r\n;         All other registers are preserved\r\n;\r\n\tPUBLIC\tPTRGPS\r\nPTRGPS:\tMOV\tAH,LOW OFFSET G_GPS\t;Get column position request-code\r\n\tCALL\tPTRDSP\t\t;[AH]=position\r\n\tMOV\tAL,AH\t\t;[AL]=position\r\n\tOR\tAL,AL\r\n\tRET\t\r\n\r\n;PTRWDC - get line width and last comma column for file PTRFIL\r\n; Exit  - [CH] = line width\r\n;         [AH] = [CL] = last comma column\r\n;         All other registers are preserved\r\n;\r\nPTRWDC:\tCALL\tPTRWID\t\t;[AH]=file PTRFIL's line width\r\n\tMOV\tCH,AH\t\t;[CH]=file width\r\nPTRWDL:\tSUB\tAH,LOW 14D\t;T.B.S. eventually, use G.GCW\r\n\tJAE\tPTRWDL\r\n\tADD\tAH,LOW 28D\r\n\tNEG\tAH\r\n\tADD\tAH,CH\r\n\tMOV\tCL,AH\t\t;[CL]=last comma column\r\n\tRET\t\r\n\r\n;PTRWID - get line width for file PTRFIL\r\n; Exit  - [AH] = line width\r\n;         All other registers are preserved\r\n;\r\n\tPUBLIC\tPTRWID\r\nPTRWID:\tPUSH\tSI\t\t;save caller's SI\r\n\tMOV\tSI,WORD PTR PTRFIL\r\n\tINC\tSI\r\n\tJZ\tPTRWD1\t\t;if LPT Pseudo FDB, use Device width\r\n\tDEC\tSI\r\n\tJZ\tPTRWD1\t\t;if KYBD Pseudo FDB, use Device width\r\n\tMOV\tAH,BYTE PTR F_WID[SI]\t;else use FDB width\r\n\tPOP\tSI\t\t;restore caller's SI\r\n\tRET\t\r\nPTRWD1:\tPOP\tSI\t\t;restore caller's SI\r\n\tMOV\tAH,LOW OFFSET G_GWD\t;Get file width function code\r\n\tJMP\tPTRDSP\t\t;return with [AH]=device width\r\n\r\n\r\n\tSUBTTL General routines useful to low-level device drivers\r\n\r\n\tPUBLIC\tXTABCR,EXPTAB,CRIFEL,UPDPOS\r\n;XTABCR is called by Device Driver Output routines to Expand Tabs to Spaces\r\n;         and Force a carriage return if end-of-line.\r\n; Entry - [AL]=char to be output\r\n;         [DH]=current column position\r\n;         [DL]=line width\r\n;         BX points to raw-output routine\r\n; Exit  - [DH] is new column position\r\n;         FLAGS are used, All other registers are preserved.\r\n;\r\nXTABCR:\tPUSH\tCX\r\n\tMOV\tCX,OFFSET CRIFEL\t;EXPTAB will call CRIFEL which will\r\n\tCALL\tEXPTAB\t\t;call raw-output routine [BX]\r\n\tPOP\tCX\r\n\tRET\t\r\n\r\n;EXPTAB is called by Device Driver Output routines to Expand Tabs to Spaces\r\n; Entry - [AL]=char to be output\r\n;         [DH]=current column position\r\n;         CX points to raw-output routine\r\n; Exit  - [DH] is new column position\r\n;         FLAGS are used, All other registers are preserved.\r\n;\r\nEXPTAB:\r\n\tCMP\tAL,LOW OFFSET ASCTAB\r\n\tJNE\tNOTTAB\t\t;branch if not tab\r\n\tCMP\tDL,LOW 9D\r\n\tJB\tEXTABX\t\t;branch if width is less than 9\r\n\tMOV\tAL,LOW OFFSET ASCSPC\t;output spaces till next tab stop\r\nEXTABL:\tCALL\tCX\t\t;output space (update position)\r\n\tTEST\tDH,LOW 7\r\n\tJNZ\tEXTABL\t\t;branch if not at MOD 8 column position\r\n\tMOV\tAL,LOW OFFSET ASCTAB\t;restore AL\r\nEXTABX:\tRET\t\r\n\r\nNOTTAB:\tJMP\tCX\t\t;output char and update position\r\n\r\n;CRIFEL - Force a carriage return if end-of-line (Called by device out routines)\r\n; Entry - [AL]=char to be output\r\n;         [DH]=current column position\r\n;         [DL]=line width\r\n;         BX points to raw-output routine\r\n; Exit  - [DH] is new column position\r\n;         FLAGS are used, All other registers are preserved.\r\n;\r\nCRIFEL:\tCMP\tAL,LOW 32D\r\n\tJB\tNOCR\t\t;branch if non-printable\r\n\tCMP\tDL,LOW 255D\r\n\tJZ\tNOCR\t\t;branch if infinite width (255)\r\n\tCMP\tDH,DL\t\t;compare Column with Width\r\n\tJB\tNOCR\t\t;branch if still room on current line\r\n\tPUSH\tAX\r\n\tMOV\tAL,LOW OFFSET ASCCR\r\n\tCALL\tBX\t\t;output Carriage Return\r\n\tMOV\tAL,LOW OFFSET ASCLF\t;output Line Feed\r\n\tCALL\tBX\r\n\tPOP\tAX\t\t;restore char to be output\r\nNOCR:\tJMP\tBX\t\t;output char, update position\r\n\r\n;UPDPOS - update column position (called by device out routines)\r\n; Entry - [DH] = current 0-relative column position\r\n;         [AL] = byte to be output\r\n; Exit  - [DH] = new column position.  All other registers preserved\r\n;\r\nUPDPOS:\tCMP\tAL,LOW 32D\r\n\tJB\tNPRINT\t\t;branch if not printable (CTL CHR)\r\n\tINC\tDH\t\t;bump column position\r\n\tRET\t\r\nNPRINT:\tCMP\tAL,LOW OFFSET ASCCR\r\n\tJNE\tNOTCR\t\t;branch if not carriage return\r\nZERPOS:\tMOV\tDH,LOW 0\t;reset to left margin\r\n\tRET\t\r\nNOTCR:\tCMP\tAL,LOW OFFSET ASCBS\r\n\tJNE\tUPPOSX\t\t;branch if not backspace\r\n\tOR\tDH,DH\r\n\tJE\tUPPOSX\t\t;don't decrement below 0\r\n\tDEC\tDH\t\t;decrement position\r\nUPPOSX:\tRET\t\r\n\r\n\tSUBTTL File Dispatch Routines\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tIOJUMP:WORD\r\nDSEG\tENDS\r\n\r\nERBFN2:\tJMP\tDERBFN\t\t;bad file number error\r\n\r\n;FACDSP - Dispatch to I/O routine for file number [FAC]\r\n; Entry - [AH]=function code (G.OPN, G.CLS, etc.)\r\n;         [FAC]=file number (note: file must be opened) (0 is illegal)\r\n; Exit  - DX, AL are used.\r\n;         All other registers preserved except those changed by device driver\r\n;\r\nFACDSP:\tCALL\tCONINT\t\t;[DX]=integer equivalent of FAC (file#)\r\n\tOR\tDX,DX\r\n\tJZ\tERBFN2\t\t;file #0 is unavailable to user (bad file num.)\r\n\r\n;FILDSP - Dispatch to I/O routine for file number [DH]\r\n; Entry - [AH]=function code (G.OPN, G.CLS, etc.)\r\n;         [DX]=file number (note: file must be opened)\r\n; Exit  - All registers preserved except those changed by device driver\r\n;\r\nFILDSP:\tPUSH\tSI\r\n\tPUSH\tAX\r\n\tOR\tDH,DH\r\n\tJNZ\tFCERR9\t\t;error if file# greater than 255\r\n\tMOV\tAL,DL\t\t;[AL]=file number\r\n\tCALL\tFDBPTR\t\t;(SI) = file data block pointer\r\n\tJZ\tERFNO2\t\t;Error - bad file number\r\n\tPOP\tAX\t\t;restore caller's [AX]\r\n\tCALL\tSIDSP\r\n\tPOP\tSI\r\n\tRET\t\r\n\r\nFCERR9:\tJMP\tFCERR\t\t;Function Call Error\r\n\r\n;PTRDSP - Dispatch to I/O routine for file with FDB=[PTRFIL]\r\n; Entry - [AH]=function code (G.OPN, G.CLS, etc.)\r\n;         [PTRFIL]=points to file's FDB\r\n; Exit  - All registers preserved except those changed by device driver\r\n;\r\n\tPUBLIC\tPTRDSP\r\nPTRDSP:\tPUSH\tSI\r\n\tMOV\tSI,WORD PTR PTRFIL\r\n\tCALL\tSIDSP\r\n\tPOP\tSI\r\n\tRET\t\r\n\r\n;SIDSP - Dispatch to I/O routine for file with FDB=[SI]\r\n; Entry - [AH]=function code (G.OPN, G.CLS, etc.)\r\n;         [SI]=points to file's FDB\r\n; Exit  - All registers preserved except those changed by device driver\r\n;\r\nSIDSP:\tPUSH\tDI\r\n\tPUSH\tSI\r\n\tPUSH\tAX\r\n\tPUSHF\t\r\n\tINC\tSI\r\n\tJZ\tLPDSP\t\t;branch if Line Printer Pseudo FDB\r\n\tDEC\tSI\r\n\tJNZ\tSIDSP1\t\t;branch if not Keyboard/CRT Pseudo FDB\r\n;        MOVI    DI,$CODE+2*<^O400-$.KYBD>\r\n\tMOV\tDI,OFFSET $_KYBD\r\n\tNEG\tDI\t\t; Change neg. dev. # to 0 based offset\r\n\tAND\tDI,377O\r\n\tSHL\tDI,1\t\t; ASM86 cann't multiply externals by 2\r\n\tJMP\tSHORT SIDSP2\r\nLPDSP:\r\n;        MOVI    DI,$CODE+2*<^O400-$.LPT1>   ;SI=0\r\n\tMOV\tDI,OFFSET $_LPT1\r\n\tNEG\tDI\t\t; Change neg. dev. # to 0 based offset\r\n\tAND\tDI,377O\r\n\tSHL\tDI,1\t\t; ASM86 cann't multiply externals by 2\r\n\tJMP\tSHORT SIDSP2\r\nSIDSP1:\tMOV\tAL,BYTE PTR F_DEV[SI]\t;(AL) = device number\r\n\tCALL\tCDEVID\t\t;[DI]=device dispatch table offset\r\nSIDSP2:\tPOPF\t\r\n\tPOP\tAX\t\t;restore caller's [AX]\r\n\tCALL\tTBLDSP\t\t;function [AH] on device [DI]\r\n\tPOP\tSI\r\n\tPOP\tDI\r\n\tRET\t\r\n\r\n;TBLDSP - Dispatch to I/O routine for device-table [DI]\r\n; Entry - [AH]=function code (G.OPN, G.CLS, etc.)\r\n;         DI = -2 * device id (0=disk, 2=keyboard etc.)\r\n; Exit  - All registers preserved except those changed by device driver\r\n;\r\nTBLDSP:\tPUSH\tDI\r\n\tPUSHF\t\r\n\tPUSH\tAX\r\n\tMOV\tAX,WORD PTR DEVPTR\t;AX points to 1st entry in dispatch table\r\n\tADD\tDI,AX\t\t;DI points to dispatch table pointer for device\r\n\tMOV\tDI,WORD PTR CS:0[DI]\t;DI points to dispatch table for device\r\n\tOR\tDI,DI\t\t;If entry is 0, then\r\n\tJZ\tERDNA2\t\t;  Error - device not available\r\n\tPOP\tAX\t\t;restore function code\r\n\tPUSH\tAX\r\n\tXCHG\tAH,AL\r\n\tCBW\t\t\t;[AX]=function code\r\n\tADD\tDI,AX\t\t;Add function code offset to dispatch\r\n\tMOV\tAX,WORD PTR CS:0[DI]\t;Get address of routine\r\n\tMOV\tWORD PTR IOJUMP,AX\r\n\tPOP\tAX\r\n\tPOPF\t\r\n\tPOP\tDI\r\n\tJMP\t WORD PTR IOJUMP\t;jump to routine at address [IOJUMP]\r\n\r\n;CDEVID - convert device id to dispatch table address\r\n; Entry - [AL]=device id (0..n for disk, -1..-n for non-disk devices)\r\n; Exit  - [DI]=DEVPTR offset for device (0 for disk, 2 for KYBD, etc.)\r\n;         FLAGS.Z is true if device=disk\r\n;         All other registers are preserved.\r\n;\r\nCDEVID:\tPUSH\tAX\r\n\tOR\tAL,AL\r\n\tJS\tCDEV1\t\t;must be a special device\r\n\tXOR\tAL,AL\t\t;(AL) = 0 for disks\r\n\tJMP\tSHORT CDEV2\r\nCDEV1:\tNEG\tAL\t\t;(AL) = - device number for special\r\nCDEV2:\tPUSHF\t\t\t;save Z=disk\r\n\tCBW\t\t\t;[AX]=device number\r\n\tADD\tAX,AX\t\t; * 2\r\n\tMOV\tDI,AX\r\n\tPOPF\t\t\t;restore Z=disk\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\nERFNO2:\tJMP\tDERFNO\t\t;file not opened error\r\n\r\nERDNA2:\tJMP\tDERDNA\t\t;device not available error\r\n\r\n\tSUBTTL NAMSCN, PARDEV - Device/Filename scanning routines\r\n\r\n\tEXTRN\tFOPTSZ:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFILOPT:WORD\r\nDSEG\tENDS\r\n\r\n;T.B.S. - FOPTSZ should eventually be used instead of CMPI CX,^D64, but\r\n; the DEC-Macros don't permit this.\r\n\r\n;NAMSCN - parse file-specification [dev:]filename[.extension]\r\n; Entry - [BX] = text pointer\r\n; Exit  - [FILDEV] = 0 if default device,\r\n;                    (1..n) if device=(A:, B:, ...)\r\n;                    (-1..-n) for DEVTBL entry (1..n)\r\n;         [FILNM] = filename\r\n;         [FILEXT] = extention\r\n;         [BX] = updated text pointer\r\n;         [AL]=next character\r\n;         FLAGS.CARRY is set if \".\" scanned\r\n;         DX is used.\r\n;         All other registers preserved\r\n;\r\n\tPUBLIC\tNAMSCN\r\nNAMSCN:\tCALL\tFRMEVL\r\n\r\nNAMSC1:\tPUSH\tBX\t\t;save text pointer\r\n\tCALL\tFRESTR\t\t;release string descriptor\r\n\t\t\t\t;[BX] points to string descriptor\r\n\tMOV\tCL,BYTE PTR 0[BX]\r\n\tMOV\tCH,LOW 0\t;[CX]=length of string\r\n\tMOV\tSI,WORD PTR 1[BX]\t;SI points to start of string\r\n\tCALL\tPARDEV\t\t;(AL) = device #\r\n\tMOV\tBYTE PTR FILDEV,AL\t;Save device #\r\n\tOR\tAL,AL\r\n\tJS\tNOTDSK\t\t;branch if special device\r\n\tXOR\tAL,AL\t\t;(AL) = 0 for disks\r\nNOTDSK:\tPUSH\tAX\r\n\tPUSH\tDX\r\n\tPUSH\tDI\r\n\tOR\tAL,AL\r\n\tPUSHF\t\t\t;save NC - indicates \".\" not scanned\r\n\tMOV\tDI,OFFSET FILNM\r\n\tMOV\tDX,OFFSET FNAML\t;filename length\r\n\tJNS\tSCAN1\t\t;If disk device, put name in FILNM\r\n\r\n; This code copies Device Dependent Options to FILOPT which is a\r\n; buffer scanned by device drivers at device open time.\r\n;\r\n\tMOV\tDI,OFFSET FILOPT\r\n\tJCXZ\tSCOM1\t\t;Will copy 1 to\r\n\tCMP\tCX,64D\t\t;compare with option buffer size\r\n\tJAE\tERIFN1\t\t;\"Bad File Name\" if too long\r\n\tCLD\t\t\t;set Post-Increment mode\r\n                             ;Copy string to FILNM\r\n REP\tMOVSB\r\nSCOM1:\r\n\tMOV\tBYTE PTR 0[DI],CL\t;Terminate option string with 0\r\n\tJMP\tSHORT SCNAM3\r\n\r\nSCAN1:\tJCXZ\tFILSPC\t\t;End of string\r\n\tDEC\tCX\r\n\tCLD\t\t\t;set Post-Increment mode\r\n\tLODSB\t\t\t;Get filename character\r\n\tCMP\tAL,LOW \"*\"\t;filename can't have wildcard chars\r\n\tJE\tERIFN1\r\n\tCMP\tAL,LOW \"?\"\r\n\tJE\tERIFN1\r\n\tCMP\tAL,LOW \" \"\r\n\tJAE\tSCNAM2\r\n\r\nERIFN1:\tJMP\tDERIFN\t\t;Illegal file name error\r\n\r\nSCNAM2:\tCMP\tAL,LOW \".\"\r\n\tJE\tFILLNM\r\n\tCLD\t\t\t;set Post-Increment mode\r\n\tSTOSB\t\t\t;Store character\r\n\tDEC\tDX\r\n\tJNZ\tSCAN1\t\t;Keep looking for characters\r\n\r\nSCNAM3:\tPOPF\t\r\n\tPOP\tDI\r\n\tPOP\tDX\r\n\tPOP\tAX\r\n\tPOP\tBX\t\t;restore updated text pointer\r\n\tRET\t\r\n\r\nFILLNM:\tPOPF\t\r\n\tSTC\t\t\t;set carry indicating \".\" scanned\r\n\tPUSHF\t\r\nFILNM0:\tCMP\tDX,OFFSET FNAML\t;file name length\r\n\tJE\tERIFN1\t\t;Error - extension only !\r\n\tCMP\tDX,3\r\n\tJB\tERIFN1\t\t;Error - 2nd dot\r\n\tJE\tSCAN1\t\t;Scan extension like filename\r\n\tMOV\tAL,LOW \" \"\r\n\tCLD\t\t\t;set Post-Increment mode\r\n\tSTOSB\t\t\t;Fill with blank\r\n\tDEC\tDX\r\n\tJMP\tSHORT FILNM0\t;Keep filling\r\n\r\nFILSPC:\tMOV\tAL,LOW \" \"\t;Fill short name with spaces\r\n\tCLD\t\t\t;set Post-Increment mode\r\n\tSTOSB\r\n\tDEC\tDX\r\n\tJNZ\tFILSPC\t\t;Keep filling\r\n\tJMP\tSHORT SCNAM3\t;Done with name\r\n\r\n;PARDEV - Parse device name from string\r\n; Entry - (CX) = length of string\r\n;         (SI) = string address\r\n; EXIT  - (AL) = device # (0 = default , - = special)\r\n;         (CX) = remaining count\r\n;         (SI) = address of remaining string\r\n\r\nPARDEV:\r\n\tPUSH\tDX\r\n\tPUSH\tDI\r\n\tPUSH\tSI\r\n\tMOV\tDX,CX\t\t;(DX) = original length\r\n\tOR\tDX,DX\t\t;test for zero length\r\n\tJZ\tNODVNM\t\t;If length = 0 , no device name\r\nDEVSCN:\tCLD\t\t\t;set Post-Increment mode\r\n\tLODSB\t\t\t;Get character\r\n\tCMP\tAL,LOW \":\"\r\n\tJE\tDEVNM\t\t;Found possible name\r\n\tLOOP\tDEVSCN\r\n\r\nNODVNM:\tMOV\tCX,DX\t\t;No device name - restore everything\r\n\tPOP\tSI\r\n\tPOP\tDI\r\n\tPOP\tDX\r\n\tXOR\tAL,AL\t\t;Default device to 0\r\n\tRET\t\r\n\r\nDEVNM:\tPOP\tDI\t\t;Restore old string pointer\r\n\tXCHG\tSI,DI\r\n\tPUSH\tDI\t\t;Save new string pointer\r\n\tSUB\tDX,CX\t\t;(DX) = device name length\r\n\tJZ\tERIFN2\t\t;Length = 0 - illegal file name\r\n\tDEC\tCX\t\t;Count off :\r\n\tCMP\tDX,1\r\n\tJE\tDSKNAM\t\t;Length = 1 - must be disk name\r\n\r\n\tMOV\tDI,WORD PTR DEVTBL\r\n\tDEC\tDI\r\nDEVSRC:\tPUSH\tSI\r\n\tPUSH\tDX\r\n\r\nDEVLOP:\tINC\tDI\r\n\tCLD\t\t\t;set Post-Increment mode\r\n\tLODSB\r\n\tCALL\tUPCASE\t\t;Convert to upper case\r\n\tTEST\tBYTE PTR CS:0[DI],LOW 200O\t;Check to see if at device (long name)\r\n\tJNZ\tNMTCH2\r\n\tCMP\tBYTE PTR CS:0[DI],AL\r\n\tJNE\tNOMTCH\r\n\tDEC\tDX\r\n\tJNZ\tDEVLOP\r\n\r\nFNDDEV:\tINC\tDI\r\n\tMOV\tAL,BYTE PTR CS:0[DI]\t;Get device #\r\n\tOR\tAL,AL\r\n\tJNS\tNOMTCH\t\t;Not a device #\r\n\r\n\tPOP\tSI\r\n\tPOP\tSI\r\nDEVRET:\tPOP\tSI\t\t;(SI) = pointer after :\r\n\tPOP\tDI\r\n\tPOP\tDX\r\n\tRET\t\t\t;(CX) = chars left , (AL) = device #\r\n\r\nNMTCH1:\tINC\tDI\r\nNOMTCH:\r\n\tTEST\tBYTE PTR CS:0[DI],LOW 200O\t;Check for device #\r\n\tJZ\tNMTCH1\t\t;  No\r\nNMTCH2:\tPOP\tDX\r\n\tPOP\tSI\r\n\tCMP\tBYTE PTR CS:1[DI],LOW 0\t;End of table?\r\n\tJNE\tDEVSRC\t\t;  No - check next entry\r\n\r\nERIFN2:\tJMP\tDERIFN\t\t;Error - bad filename (device name)\r\n\r\nDSKNAM:\r\n\tCLD\t\t\t;set Post-Increment mode\r\n\tLODSB\t\t\t;Refetch character\r\n\tCALL\tUPCASE\r\n\tSUB\tAL,LOW OFFSET \"A\"-1\t;Convert letter to 1-26 (let @ be 0)\r\n\tJB\tERIFN2\t\t;  Less than @\r\n\tCMP\tAL,LOW OFFSET \"Z\" AND 37O\r\n\tJAE\tERIFN2\t\t;  Greater than Z\r\n\tJMP\tSHORT DEVRET\r\n\r\nUPCASE:\tCMP\tAL,LOW \"a\"\t;Convert (AL) to upper case\r\n\tJB\tUPRET\r\n\tCMP\tAL,LOW \"z\"\r\n\tJA\tUPRET\r\n\tAND\tAL,LOW OFFSET 255D-\" \"\r\nUPRET:\tRET\t\r\n\r\n\tSUBTTL File Data Block Management Routines\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tVARTAB:WORD,ARYTAB:WORD,MEMSIZ:WORD,FRETOP:WORD,SAVFRE:WORD\r\n\tEXTRN\tFILTAB:WORD,STREND:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tERROM:NEAR,ERROR:NEAR\r\n\tEXTRN\tSKPNAM:NEAR,GARBA2:NEAR\r\n;INIFDB - Special device open common routine\r\n; Allocates, initializes and links new FDB into FDB Chain.\r\n; Entry - (AL) = file device\r\n;         (AH) = valid file modes\r\n;         (CX) = buffer size (not including basic FDB size)\r\n;         (DL) = file width\r\n;         (DH) = initial file position\r\n;         (BX) = file number\r\n; Exit -  SI points to new File Data Block\r\n;         [PTRFIL] points to new FDB\r\n;         All other registers preserved.\r\n;\r\n\tPUBLIC\tINIFDB\r\nINIFDB:\tPUSH\tCX\r\n\tPUSH\tDI\r\n\tTEST\tBYTE PTR FILMOD,AH\t;Check for valid file mode\r\n\tJZ\tERBFM4\t\t;  Bad file mode\r\n\tADD\tCX,OFFSET FDBSIZ\t;(CX) = size of block to allocate\r\n\tCALL\tFALLOC\t\t;SI points to Allocated block\r\n\tMOV\tWORD PTR PTRFIL,SI\r\n\tMOV\tBYTE PTR F_NUM[SI],BL\t;Set file number\r\n\tMOV\tBYTE PTR F_DEV[SI],AL\t;Set file device\r\n\tMOV\tBYTE PTR F_FLGS[SI],LOW 0\r\n\tMOV\tBYTE PTR F_CODE[SI],LOW OFFSET FC_ASC\t;default file-code to ASCII\r\n\tMOV\tCL,BYTE PTR FILMOD\r\n\tMOV\tBYTE PTR F_MODE[SI],CL\t;Set file mode\r\n\tMOV\tBYTE PTR F_WID[SI],DL\t;Set file width\r\n\tMOV\tBYTE PTR F_POS[SI],DH\t;Set file position\r\n\tMOV\tBYTE PTR F_ORCT[SI],LOW 1\t;indicates not at EOF\r\n\tPOP\tDI\r\n\tPOP\tCX\r\n\tRET\t\r\n\r\nERBFM4:\tJMP\tDERBFM\t\t;Bad file mode\r\n\r\n;SCDASC - Set file-attribute CODE for file PTRFIL to ASCII\r\n; Exit  - all registers preserved.\r\n;\r\n\tPUBLIC\tSCDASC\r\nSCDASC:\tPUSH\tSI\r\n\tMOV\tSI,WORD PTR PTRFIL\r\n\tMOV\tBYTE PTR F_CODE[SI],LOW OFFSET FC_ASC\r\n\tPOP\tSI\r\n\tRET\t\r\n\r\n;SCDBIN - Set file-attribute CODE for file PTRFIL to binary\r\n; Exit  - all registers preserved.\r\n;\r\n\tPUBLIC\tSCDBIN\r\nSCDBIN:\tPUSH\tSI\r\n\tMOV\tSI,WORD PTR PTRFIL\r\n\tMOV\tBYTE PTR F_CODE[SI],LOW OFFSET FC_BIN\r\n\tPOP\tSI\r\n\tRET\t\r\n\r\n;FDBPTR - Transform file number into File-Data-Block pointer\r\n; Entry - [FAC] = file number (0..n)\r\n; Exit  - if File-Data-Block is allocated,\r\n;            SI points to 1st byte of File-Data-Block\r\n;         else FLAGS.Z is true\r\n;         DX, AX are used\r\n;\r\nFACFPT:\tCALL\tCONINT\t\t;[AL] = file number\r\n\t\t\t\t;fall into FDBPTR\r\n\r\n;FDBPTR - Transform file number into File-Data-Block pointer\r\n; Entry - [AL] = file number (0..n)\r\n; Exit  - if File-Data-Block is allocated,\r\n;            SI points to 1st byte of File-Data-Block\r\n;         else FLAGS.Z is true\r\n;         All other registers are preserved\r\n;\r\nFDBPTR:\tMOV\tSI,WORD PTR FILTAB\t;[SI] points to 1st file-data-block\r\nGPTRL:\tCMP\tSI,WORD PTR STKLOW\t;compare with nil FDB pointer\r\n\tJZ\tGPTRX\t\t;branch if at end of FDB chain\r\n\tCMP\tAL,BYTE PTR F_NUM[SI]\r\n\tJZ\tGPTRF\t\t;branch if found FDB\r\n\tMOV\tSI,WORD PTR F_NEXT[SI]\t;advance to next FDB in chain\r\n\tJMP\tSHORT GPTRL\r\nGPTRF:\tOR\tSI,SI\t\t;set NZ - indicates FDB found\r\nGPTRX:\tRET\t\r\n\r\n;FALLOC(nbytes) {allocate file-data-block and link into chain}\r\n; Entry - CX=size of FDB\r\n; Exit  - SI points to new FDB (which is already linked into FDB chain)\r\n;         SI, DI used.\r\n;\r\n;  if FRETOP-STREND .LEQ. nbytes then\r\n;    perform major string garbage collection\r\n;    if FRETOP-STREND is still .LEQ. nbytes then deverr(Out-of-memory)\r\n;  temp = FILTAB;\r\n;  xfrstr(FILTAB,-nbytes); {move string space down nbytes}\r\n;  FILTAB.F.NEXT := temp; {link new FDB into chain}\r\n;  return FILTAB;\r\n;\r\nFALLOC:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tPUSHF\t\r\n\tMOV\tAX,CX\t\t;[AX]=size of new FDB\r\n\tMOV\tDL,LOW 1\t;Indicates 1st attempt to find space\r\nFALC1:\tMOV\tBX,WORD PTR FRETOP\t;BX points to top of free string space\r\n\tSUB\tBX,WORD PTR STREND\t;BX=number of bytes free - 1\r\n\tCMP\tAX,BX\t\t;compare with requested amount\r\n\tJB\tFALCOK\t\t;branch if its available\r\n\tDEC\tDL\r\n\tJZ\tFAPAS1\t\t;branch if 1st attempt\r\n\tMOV\tDL,LOW OFFSET ERROM\t;else give Out of Memory error\r\n\tJMP\tERROR\r\nFAPAS1:\tPUSH\tAX\r\n\tPUSH\tDX\r\n\tCALL\tGARBA2\t\t;perform major garbage collection\r\n\tPOP\tDX\r\n\tPOP\tAX\r\n\tJMP\tSHORT FALC1\t;now that its compressed, try again\r\n\r\nFALCOK:\tNEG\tAX\t\t;indicates moving strings down\r\n\tMOV\tSI,WORD PTR FILTAB\t;SI points to lowest FDB in chain\r\n\tPUSH\tSI\t\t;save for link\r\n\tCALL\tXFRSTR\t\t;move string space\r\n\tPOP\tBX\r\n\tMOV\tSI,WORD PTR FILTAB\t;SI points to new FDB\r\n\tMOV\tWORD PTR F_NEXT[SI],BX\t;link FDB into chain\r\n\r\n\tPUBLIC\tPDCBAX,PCBAX,PBAX\t;generally useful routines\r\nPFDCBA:\tPOPF\t\r\nPDCBAX:\tPOP\tDX\r\nPCBAX:\tPOP\tCX\r\nPBAX:\tPOP\tBX\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n\r\n;FFREE(fdbptr) {free file data block}\r\n;              {ffree is called by clsfil only}\r\n; Entry - SI points to FDB to be freed\r\n; Exit  - SI, DI Used\r\n;\r\n;  fdbptr points to low byte of freed file-data-block\r\n;  remove fdbptr from chain of file-data-blocks (FILTAB)\r\n;  nbytes := size of freed file-data-block.\r\n;  xfrstr(fdbptr, nbytes); {move string space and lower-FDB's up nbytes}\r\n;\r\nFFREE:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tPUSHF\t\r\n\tMOV\tAX,WORD PTR F_NEXT[SI]\t;AX points to next FDB in chain\r\n\tSUB\tAX,SI\t\t;AX = size of FDB being freed\r\n\tMOV\tBX,WORD PTR FILTAB\t;BX points to 1st FDB in chain\r\nFFNDL:\tCMP\tBX,SI\t\t;see if this is the one being freed\r\n\tJE\tFFOUND\t\t;branch if it is\r\n\tJB\tSTILOK\t\t;branch if still less than expected\r\nBADFDB:\tJMP\tSHORT BADFDB\t;better to halt than destroy other data\r\nSTILOK:\r\n\tMOV\tCX,WORD PTR F_NEXT[BX]\t;CX points to next FDB in chain\r\n\tADD\tWORD PTR F_NEXT[BX],AX\t;update next-ptr to reflect block move\r\n\tMOV\tBX,CX\r\n\tJMP\tSHORT FFNDL\t;continue quest\r\n\r\nFFOUND:\r\n\tCALL\tXFRSTR\t\t;move strings and lower FDB's up\r\n\tJMP\tSHORT PFDCBA\t;restore registers and exit\r\n\r\n;XFRSTR(top, nbytes) {transfer string space}\r\n; Entry - SI points 1 byte above block to be moved\r\n;         AX = direction and number of bytes to be moved {nbytes}\r\n;              (if AX .GT. 0 then strings are moved to a higher adr (UP))\r\n;         FRETOP points 1 byte below bottom of block to be moved\r\n; Exit  - FLAGS, AX, BX, CX, DX used (Others preserved)\r\n;\r\n;  if moving string space down, nbytes .LS. 0, top=FILTAB\r\n;  if moving string space up, top=pointer to FDB being released,\r\n;  perform block move\r\n;  for each string descriptor in VARTAB, ARYTAB, temporaries do\r\n;    if str.adr .LSS. top then\r\n;      str.adr := str.adr + nbytes {update string descriptor}\r\n;    else if str.adr .LSS. top+nbytes then\r\n;      str.len := 0 {reset field variables in released FDB}\r\n;    end; {for each string...}\r\n;  FILTAB := FILTAB + nbytes;\r\n;  MEMSIZ := MEMSIZ + nbytes;\r\n;  FRETOP := FRETOP + nbytes;\r\n;  SAVFRE := SAVFRE + nbytes; (so CHAIN will work)\r\n;  PTRFIL := PTRFIL + nbytes; (if it was pointing to a moved FDB)\r\n;\r\nXFRSTR:\tPUSH\tSI\r\n\tPUSH\tDI\r\n\tDEC\tSI\t\t;SI points to top of block to be moved\r\n\tMOV\tDI,SI\t\t;DI points to top of block to be moved\r\n\tMOV\tDX,AX\t\t;DX=byte-count adjustment for block move\r\n\tADD\tDI,AX\t\t;DI points to top of dest of block move\r\n\tMOV\tCX,SI\r\n\tSUB\tCX,WORD PTR FRETOP\t;CX = number of bytes to transfer\r\n\tJZ\tXFRSTX\t\t;return if string space is empty\r\n\tPUSH\tSI\r\n\tPUSH\tDI\r\n\tSTD\t\t\t;set Post-Decrement mode\r\n\tOR\tAX,AX\r\n\tJNS\tXFRSUP\t\t;brif moving strings up in memory\r\n\tCLD\t\t\t;set Post-Increment mode\r\n\tSUB\tSI,CX\r\n\tSUB\tDI,CX\t\t;start transfer from bottom\r\n\tINC\tSI\t\t;SI points to bottom of SRC block\r\n\tINC\tDI\t\t;DI points to bottom of DST block\r\nXFRSUP:\r\n REP\tMOVSB\t\t\t;execute block move\r\n\tPOP\tDI\t\t;restore DI points to TOP of DST block\r\n\tPOP\tSI\t\t;restore SI points to TOP of SRC block\r\n\r\n;Update all string descriptors in VARTAB\r\n; SI points to top of source of block move\r\n; DI points to top of destination of block move\r\n; DX = byte count adjustment for block move\r\n;\r\n\tMOV\tBX,WORD PTR VARTAB\t;Look at simple strings\r\nCSVAR:\tCMP\tBX,WORD PTR ARYTAB\t;Done if we have reached array table\r\n\tJZ\tCAYVAR\t\t;Yes\r\n\tCALL\tSKPNAM\t\t;Skip name, returns Z if was a string\r\n\tJNZ\tCSKPVA\t\t;Skip this var, not string\r\n\tCALL\tUPDSTD\t\t;Update this string descriptor\r\n\tXOR\tAL,AL\t\t;UPDSTD has already incremented [BX]\r\nCSKPVA:\r\n\tMOV\tAH,LOW 0\r\n\tADD\tBX,AX\t\t;Add length of VALTYP\r\n\tJMP\tSHORT CSVAR\r\n\r\n;Update all string descriptors in ARYTAB\r\n;\r\nCAYVA2:\tMOV\tBX,AX\t\t;BX points to next string descriptor\r\nCAYVAR:\tCMP\tBX,WORD PTR STREND\t;New limit of search\r\n\tJZ\tXFRSTX\t\t;branch if done searching arrays\r\n\tCALL\tSKPNAM\t\t;Skip over name\r\n\tPUSHF\t\t\t;save string-name indicator\r\n\tMOV\tAX,WORD PTR 0[BX]\t;Get length of array\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tADD\tAX,BX\t\t;AX points to next entry in ARYTAB\r\n\tPOPF\t\t\t;String array?\r\n\tJNZ\tCAYVA2\t\t;No, look at next one\r\n\tPUSH\tAX\t\t;save pointer to end of array\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;Pick up number of DIMs\r\n\tMOV\tAH,LOW 0\t;Make double with high zero\r\n\tADD\tBX,AX\t\t;Go past DIMS\r\n\tADD\tBX,AX\r\n\tINC\tBX\t\t;One more to account for # of DIMs\r\nCAYSTR:\tPOP\tAX\t\t;AX points to end of array\r\n\tCMP\tBX,AX\t\t;Are we done with this array?\r\n\tJZ\tCAYVAR\t\t;Get next array\r\n\tPUSH\tAX\r\n\tCALL\tUPDSTD\t\t;Update string descriptor\r\n\tJMP\tSHORT CAYSTR\r\n\r\nXFRSTX:\tMOV\tCX,WORD PTR PTRFIL\r\n\tCMP\tCX,WORD PTR FRETOP\r\n\tJB\tXFSTX1\t\t;brif PTRFIL pointed below moved block\r\n\tCMP\tCX,SI\r\n\tJAE\tXFSTX1\t\t;brif PTRFIL pointed above moved block\r\n\tADD\tWORD PTR PTRFIL,DX\t;Adjust PTRFIL for block move\r\nXFSTX1:\tADD\tWORD PTR FRETOP,DX\t;Adjust FRETOP for block move\r\n\tADD\tWORD PTR SAVFRE,DX\t;Adjust SAVFRE for block move\r\n\tADD\tWORD PTR FILTAB,DX\t;Adjust FILTAB for block move\r\n\tADD\tWORD PTR MEMSIZ,DX\t;Adjust MEMSIZ for block move\r\n\tPOP\tDI\r\n\tPOP\tSI\r\n\tRET\t\r\n\r\n\r\n;Update String Descriptor pointed to by BX.\r\n; Entry - BX points to string descriptor\r\n;         SI points to top of source for block move\r\n;         DI points to top of destination for block move\r\n;         DX = size and direction of block move\r\n; Exit  - BX points 1 byte beyond string descriptor\r\n;         if string descriptor pointed inside buffer being released, len=0\r\n;         if descriptor points within block-move, its pointer is adjusted.\r\n;         CX used.  All other registers preserved.\r\n;\r\nUPDSTD:\r\n\tMOV\tCX,WORD PTR 1[BX]\t;CX points to string data\r\n\tCMP\tCX,WORD PTR FRETOP\r\n\tJBE\tUPDSTX\t\t;brif string data is below string space\r\n\tCMP\tCX,SI\r\n\tJBE\tUPDSTU\t\t;brif string data was block moved\r\n\tCMP\tCX,DI\r\n\tJA\tUPDSTX\t\t;brif string not in buffer being freed\r\n\tMOV\tBYTE PTR 0[BX],LOW 0\t;set string len to 0 (reset field buf)\r\nUPDSTU:\r\n\tADD\tWORD PTR 1[BX],DX\t;adjust pointer for block move\r\nUPDSTX:\r\n\tADD\tBX,3\t\t;BX points 1 byte beyond string desc\r\n\tRET\t\r\n\r\n\tSUBTTL General Queue support routines\r\n\r\n\tPUBLIC\tINITQ,PUTQ,GETQ,NUMQ,LFTQ\r\n\r\n;These routines are all called with SI pointing to an 8-byte queue descriptor\r\n; which is organized (invisibly to the caller) as follows:\r\n;\r\n\tQ_PUT=0\t\t\t;points to the next empty byte in the queue\r\n\tQ_GET=2\t\t\t;points to the next byte to be fetched (oldest data)\r\n\tQ_BUF=4\t\t\t;points to the 1st byte of the physical buffer\r\n\tQ_END=6\t\t\t;points 1 byte beyond the end of the physical buffer\r\n\r\n;   Note: if Q.PUT(SI)=Q.GET(.SI), the queue is empty\r\n;         Size of queue buffer is Q.END - Q.BUF\r\n;         Maximum data in queue at any time is Q.END - Q.BUF - 1\r\n\r\n\r\n;INITQ - initialize queue descriptor for empty queue\r\n; Entry - SI points to 8 byte queue descriptor\r\n;         BX points to 1st byte of queue buffer\r\n;         [AX] = size of queue buffer\r\n; Exit  - AX is used\r\n;\r\nINITQ:\tMOV\tWORD PTR Q_PUT[SI],BX\r\n\tMOV\tWORD PTR Q_GET[SI],BX\r\n\tMOV\tWORD PTR Q_BUF[SI],BX\r\n\tADD\tAX,BX\r\n\tMOV\tWORD PTR Q_END[SI],AX\r\n\tRET\t\r\n\r\n;PUTQ - append data to back of queue\r\n; Entry - SI points to 8 byte queue descriptor\r\n;         [AL]=data to be put in queue\r\n; Exit  - FLAGS.Z is true if queue is full\r\n;\r\nPUTQ:\tMOV\tBX,WORD PTR Q_PUT[SI]\r\n\tMOV\tBYTE PTR 0[BX],AL\r\n\tCALL\tBUMPQP\t\t;advance PUT-POINTER BX\r\n\tCMP\tBX,WORD PTR Q_GET[SI]\r\n\tJE\tPQFULL\t\t;brif queue is full (ignore new data)\r\n\tMOV\tWORD PTR Q_PUT[SI],BX\t;save new PUT-POINTER\r\nPQFULL:\tRET\t\r\n\r\n;GETQ - get next byte from front of queue\r\n; Entry - SI points to 8 byte queue descriptor\r\n; Exit  - FLAGS.Z is true if queue is empty\r\n;         otherwise, [AL]=data to be put in queue\r\n;         AX is used\r\n;\r\nGETQ:\tMOV\tBX,WORD PTR Q_GET[SI]\r\n\tCMP\tBX,WORD PTR Q_PUT[SI]\r\n\tJE\tGQEMTY\t\t;branch if queue is empty\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;get next byte from queue\r\n\tCALL\tBUMPQP\t\t;advance queue pointer BX\r\n\tMOV\tWORD PTR Q_GET[SI],BX\t;save new GET-POINTER\r\n\tOR\tBX,BX\t\t;set NZ so caller knows AL has data\r\nGQEMTY:\tRET\t\r\n\r\nBUMPQP:\tINC\tBX\r\n\tCMP\tBX,WORD PTR Q_END[SI]\r\n\tJB\tBUMPQX\t\t;branch if no need to Wrap-Around\r\n\tMOV\tBX,WORD PTR Q_BUF[SI]\t;reset pointer to start of buf\r\nBUMPQX:\tRET\t\r\n\r\n;LFTQ - How many times can PUTQ be successfully called for queue SI\r\n; Entry - SI points to 8 byte queue descriptor\r\n; Exit  - [AX] = number of bytes free in queue (0..QueueSize - 1)\r\n;\r\nLFTQ:\tMOV\tAX,WORD PTR Q_GET[SI]\r\n\tDEC\tAX\r\n\tSUB\tAX,WORD PTR Q_PUT[SI]\r\n\tJMP\tSHORT NUMQ1\r\n\r\n;NUMQ - How many times can GETQ be successfully called for queue SI\r\n; Entry - SI points to 8 byte queue descriptor\r\n; Exit  - [AX] = number of bytes of data in queue (0..QueueSize - 1)\r\n;\r\nNUMQ:\tMOV\tAX,WORD PTR Q_PUT[SI]\r\n\tSUB\tAX,WORD PTR Q_GET[SI]\r\nNUMQ1:\tJAE\tNUMQX\t\t;brif PUT-POINTER exceeds GET-POINTER\r\n\tADD\tAX,WORD PTR Q_END[SI]\r\n\tSUB\tAX,WORD PTR Q_BUF[SI]\r\nNUMQX:\tRET\t\r\n\r\n\tSUBTTL I/O Initialization Called by INIT\r\n\r\n\tPUBLIC\tGIOINI,GIOTRM\r\n\r\nGIOINI:\r\n\tCALL\tMSISET\t\t;Init MSDOS interrupts &H23 & &H24\r\n\tXOR\tAX,AX\r\n\tMOV\tWORD PTR STKLOW,AX\r\n\tMOV\tWORD PTR FILTAB,0\t;so FDBPTR will work during initialization\r\n\tMOV\tBYTE PTR NLONLY,AL\r\n\tMOV\tBX,WORD PTR DEVINI\t;DI points to array of init routines\r\n\tCALL\tDOALDV\r\n\tJMP\tSHORT FINPRT\t;reset PTRFIL to Keyboard\r\n\r\nGIOTRM:\tMOV\tBX,WORD PTR DEVTRM\t;DI points to array of terminate routines\r\n\tCALL\tDOALDV\r\n\tCALL\tMSIRST\t\t;Replace MSDOS int vectors &H23 & &H24\r\n\tRET\t\r\n\r\nDOALDV:\tMOV\tAL,LOW OFFSET $_NDEV\r\n\tCBW\t\t\t;[CX]=number of devices in system\r\n\tADD\tAX,AX\r\n\tJZ\tDOALLX\t\t;branch if no non-disk devices\r\n\tMOV\tDI,AX\t\t;[DI]=2*number of non-disk devices\r\nDOALLP:\tPUSH\tBX\r\n\tPUSH\tDI\r\n\tCALL\t WORD PTR CS:-2[BX+DI]\t;Call initialization/termination routine\r\n\tPOP\tDI\r\n\tPOP\tBX\r\n\tDEC\tDI\r\n\tDEC\tDI\r\n\tJNZ\tDOALLP\t\t;Loop until Device ID = 0 (disk)\r\nDOALLX:\r\n\tRET\t\r\n\r\n;FINLPT forces a carriage return on LPT1 if it is not already at left margin.\r\n; It then falls into FINPRT.\r\n; Exit  - AX, SI, DI, FLAGS used, all other registers preserved.\r\n;\r\nFINLPT:\tPUSH\tAX\r\n\tMOV\tAH,LOW OFFSET G_GPS\t;Get column position request-code\r\n;        MOVI    DI,$CODE+2*<^O400-$.LPT1>\r\n\tMOV\tDI,OFFSET $_LPT1\r\n\tNEG\tDI\t\t; Change neg. dev. # to 0 based offset\r\n\tAND\tDI,377O\r\n\tSHL\tDI,1\t\t; ASM86 cann't multiply externals by 2\r\n\tPUSH\tDI\t\t;save Device Code\r\n\tCALL\tTBLDSP\t\t;function [AH] on device [DI] (LPT1)\r\n\tPOP\tDI\r\n\tOR\tAH,AH\t\t;test LPT1 current column position\r\n\tJZ\tFINLPX\t\t;branch if at column 0\r\n\tMOV\tAX,OFFSET (400O*G_SOT)+13D\r\n\tPUSH\tDI\t\t;save Device Code\r\n\tXOR\tSI,SI\t\t;SI=pseudo LPT FDB\r\n\tCALL\tTBLDSP\t\t;Send CR to LPT\r\n\tPOP\tDI\r\n\tMOV\tAX,OFFSET (400O*G_SOT)+10D\r\n\tXOR\tSI,SI\t\t;SI=pseudo LPT FDB\r\n\tCALL\tTBLDSP\t\t;Send LF to LPT\r\nFINLPX:\tPOP\tAX\r\n\t\t\t\t;Fall into FINPRT\r\n\r\n;FINPRT is called at the end of every BASIC statement and after ERROR.\r\n; It resets the current file to be Keyboard/Crt.\r\n; It also frees the File-Data-Block pointed to by FREFDB if it is non-zero.\r\n; This is useful for Device-Open routines (xxxOPN).  After calling\r\n; INIFDB to allocate an FDB, they can set FREFDB to point to allocated FDB.\r\n; When the file gets completely opened, they can reset FREFDB to 0.\r\n; Then if some error occurs in between, FINPRT will release the FDB.\r\n; Exit  - AX, SI, DI, FLAGS used, all other registers preserved.\r\n;\r\n\tPUBLIC\tFINPRT,FINLPT\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFREFDB:WORD\r\nDSEG\tENDS\r\nFINPRT:\r\n\tEXTRN\tSETCSR:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCSRY:WORD,CSRX:WORD,CSRTYP:WORD\r\nDSEG\tENDS\r\n\tPUSH\tDX\r\n\tMOV\tDL,BYTE PTR CSRY\r\n\tMOV\tDH,BYTE PTR CSRX\t;DX=current posn\r\n\tMOV\tBYTE PTR CSRTYP,LOW 3D\t;Set to user cursor\r\n\tCALL\tSETCSR\t\t;Display the cursor\r\n\tPOP\tDX\r\n\tMOV\tSI,WORD PTR FREFDB\r\n\tOR\tSI,SI\r\n\tJZ\tNFRFDB\t\t;branch if no FDB needs to be released\r\n\tCALL\tFFREE\r\nNFRFDB:\tXOR\tAX,AX\r\n\tMOV\tWORD PTR FREFDB,AX\t;reset FREE-FDB flag\r\n\tCALL\tCLSFIL\t\t;close file #0 (if NLONLY=0)\r\n\tXOR\tAX,AX\r\n\tTEST\tBYTE PTR NLONLY,LOW 1\r\n\tJNZ\tRET45\t\t;don't clear PTRFIL if loading program\r\n\tMOV\tWORD PTR PTRFIL,AX\t;future I/O will use Keyboard/CRT\r\nRET45:\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  MSDOS   Abort/Initialization/Termination Processing\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDINTAD:WORD,CTLCAD:WORD\t;MSDOS Ctl-C and disk error vector\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tMSDCCF:WORD\t;MSDOS control C flag\r\nDSEG\tENDS\r\n\r\n\tEXTRN\tERROR:NEAR\r\n\tEXTRN\tERRDWP:NEAR,ERRDNR:NEAR,ERRDME:NEAR\t;I/O Error numbers\r\n\r\n\tPUBLIC\tSAVVEC,SETVEC\r\n\r\n;DSKERR - Processing for MSDOS interrupt &H23\r\n;         Exit is made through ERROR.  No IRET is executed.\r\n;\r\nDSKERR:\tSTI\t\r\n\tMOV\tAX,DI\t\t;[AX]= Error code\r\n\tADD\tSP,20D\t\t;Adjust stack\r\n\tPOP\tDS\t\t;Get BASIC data segment\r\n\tPOP\tES\t\t;Get BASIC extra segment\r\n\tMOV\tDL,LOW OFFSET ERRDWP\r\n\tOR\tAL,AL\t\t;Test for \"Disk write protect\"\r\n\tJZ\tDSKERX\t\t;Disk write protect\r\n\tMOV\tDL,LOW OFFSET ERRDNR\r\n\tCMP\tAL,LOW 2D\t;Test for \"Disk not ready\"\r\n\tJZ\tDSKERX\t\t;Disk not ready\r\n\tMOV\tDL,LOW OFFSET ERRDME\t;Else \"Disk media error\r\nDSKERX:\tJMP\tERROR\t\t;Go report the error and return\r\n\t\t\t\t;Extra stuff on stack is removed by ERROR\r\n\r\n;MSCTLC - Processing for MSDOS interrupt &H23\r\n;\r\nMSCTLC:\tMOV\tBYTE PTR MSDCCF,LOW 377O\t;Record control-C event for POLKEY\r\n\tIRET\t\r\n\r\n;MSISET - Set MSDOS termination and Ctl-C processing addresses.\r\n;         The current addresses are saved for restoration upon termination\r\n;         All registers preserved.\r\n;\r\n\r\n\r\nMSISET:\tPUSH\tAX\r\n\tPUSH\tDX\r\n\tPUSH\tES\r\n\tMOV\tAX,36D\t\t;MSDOS fatal error interrupt\r\n\tMOV\tBX,OFFSET DINTAD\t;Get save location for fatal error\r\n\tCALL\tSAVVEC\r\n\tDEC\tAX\t\t;MSDOS Ctl-C interrupt\r\n\tMOV\tBX,OFFSET CTLCAD\t;Get save location\r\n\tCALL\tSAVVEC\r\n\tPUSH\tCS\r\n\tPOP\tES\t\t;BASIC code segment to ES\r\n\tMOV\tDX,OFFSET MSCTLC\t;BASIC Ctl-C handler address\r\n\tCALL\tSETVEC\t\t;BASIC Ctl-C handler vector set\r\n\tINC\tAX\t\t;MSDOS fatal error interrupt\r\n\tMOV\tDX,OFFSET DSKERR\r\n\tCALL\tSETVEC\t\t;BASIC fatal error handler vector set\r\n\tPOP\tES\r\n\tPOP\tDX\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\nMSIRST:\tPUSH\tAX\r\n\tPUSH\tES\r\n\tMOV\tAX,36D\t\t;MSDOS fatal error interrupt\r\n\tLES\tDX,DWORD PTR DINTAD\t;Get MSDOS fatal error handler add/par\r\n\tCALL\tSETVEC\r\n\tDEC\tAX\t\t;MSDOS Ctl-C interrupt\r\n\tLES\tDX,DWORD PTR CTLCAD\t;Get MSDOS Ctl-C handler add/par\r\n\tCALL\tSETVEC\r\n\tPOP\tES\r\n\tPOP\tAX\r\n\tRET\t\r\n;SAVVEC - Get and store an interrupt vector\r\n;ENTRY  - AX = interrupt\r\n;         BX = CS relative address of vector storage area\r\n;EXIT   - all registers preserved\r\n;\r\nSAVVEC:\tPUSH\tDX\r\n\tPUSH\tES\r\n\tCALL\tGETVEC\r\n\tMOV\tWORD PTR 0[BX],DX\t;Save address portion\r\n\tMOV\tDX,ES\r\n\tMOV\tWORD PTR 2[BX],DX\t;Save paragraph portion\r\n\tPOP\tES\r\n\tPOP\tDX\r\n\tRET\t\r\n\r\n;SETVEC - Set an interrupt vector\r\n;ENTRY  - AX    = interrupt number\r\n;         ES:DX = new interrupt vector\r\n;EXIT   - All registers preserved\r\n;\r\nSETVEC:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tCALL\tXCESDS\t\t;Swap ES and DS\r\n\tDOSIO\t37D\t\t;Set interrupt\r\n\tCALL\tXCESDS\t\t;Swap ES and ES back\r\n\tJMP\tPDCBAX\t\t;POP DX,CX,BX,AX and RET\r\n\r\nXCESDS:\tPUSH\tES\r\n\tPUSH\tDS\r\n\tPOP\tES\r\n\tPOP\tDS\r\n\tRET\t\r\n\r\n;GETVEC - Get current interrupt vector\r\n;ENTRY  - AX    = interrupt number\r\n;EXIT   - ES:DX = interrupt vector\r\n;         All other registers preserved\r\n;\r\nGETVEC:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tDS\r\n\tSHL\tAX,1\r\n\tSHL\tAX,1\t\t;Calculate interrupt address\r\n\tMOV\tBX,AX\r\n\tXOR\tAX,AX\r\n\tMOV\tDS,AX\t\t;Get interrupt paragraph\r\n\tLES\tDX,DWORD PTR 0[BX]\t;Get interrupt vector\r\n\tPOP\tDS\r\n\tPOP\tBX\r\n\tPOP\tAX\r\n\tRET\t\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GIO86U",
          "type": "blob",
          "size": 1.57421875,
          "content": "; [ This translation created 12-Jan-83 by Version 4.3 ]\n\n\tSUBTTL GIO86U - Device Independent I/O Constants and Macros\n\nCOMMENT\t*\n\n--------- --- ---- -- ---------\nCOPYRIGHT (C) 1982 BY MICROSOFT\n--------- --- ---- -- ---------\n\n        Programmer: Tom Corbett,  Microsoft Inc.\n\n        *\n\nROFFST\tMACRO\tNAME,SIZE\t;define record macro\n\tNAME=_OFFST\n\t_OFFST=_OFFST+SIZE\nENDM \n\n\n;ASCII character definitions\n;\n\tASCCTC=3D\t\t;CTL-C\n\tASCBS=8D\t\t;backspace\n\tASCTAB=9D\t\t;Tab\n\tASCLF=10D\t\t;Line Feed\n\tASCCR=13D\t\t;Carriage Return\n\tASCCTS=19D\t\t;CTL-S\n\tASCCTZ=26D\t\t;Control Z (End-of-file for some devices)\n\tASCESC=27D\t\t;Escape\n\tASCSPC=32D\t\t;Space\n\n;Special File ID's (identified by 1st byte of file)\n;\n\tBINFID=255D\t\t;files created by SAVE \"fn\"\n\tPROFID=254D\t\t;files created by SAVE \"fn\",P\n\tBSVFID=253D\t\t;files created by BSAVE \"fn\"\n\n;Generalized I/O Function Codes:\n;\n\t_OFFST=0\t\t;initialize count\n\tROFFST\tG_EOF,2\t\t;test EOF for file opened to this device\n\tROFFST\tG_LOC,2\t\t;LOC\n\tROFFST\tG_LOF,2\t\t;LOF\n\tROFFST\tG_CLS,2\t\t;perform special CLOSE functions for this device\n\tROFFST\tG_SWD,2\t\t;set device width\n\tROFFST\tG_RND,2\t\t;GET/PUT random record from/to this device\n\tROFFST\tG_OPN,2\t\t;perform special OPEN functions for this device\n\tROFFST\tG_SIN,2\t\t;input 1 byte from file opened on this device\n\tROFFST\tG_SOT,2\t\t;output 1 byte to file opened on this device\n\tROFFST\tG_GPS,2\t\t;POS\n\tROFFST\tG_GWD,2\t\t;get device width\n\tROFFST\tG_SCW,2\t\t;set device column width\n\tROFFST\tG_GCW,2\t\t;get device column width\n\tROFFST\tG_BIN,2\t\t;block input from file opened on this device\n\tROFFST\tG_BOT,2\t\t;block output to file opened on this device\n\n\n        PAGE\n\u001a"
        },
        {
          "name": "GIOCAS.ASM",
          "type": "blob",
          "size": 0.625,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GIOCAS - Cassette Machine Independent Device Driver Code\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- ---------\r\nCOPYRIGHT (C) 1981 BY MICROSOFT\r\n--------- --- ---- -- ---------\r\n\r\nWritten by:     Len Oorthuys\r\n\r\n        *\r\n\tINCLUDE\tGIO86U\r\n\tINCLUDE\tMSDOSU\r\n\t.SALL\r\n\r\n\r\n\tEXTRN\tDERDNA:NEAR\r\nPUBLIC\tMOTOR\r\nMOTOR:\tJMP\tDERDNA\t\t;Device unavailable error\r\n\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\r\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GIOCOM.ASM",
          "type": "blob",
          "size": 28.875,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GIOCOM - Communications Machine Independent Device Driver Code\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- --------- -----------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT CORPORATION\r\n--------- --- ---- -- --------- -----------\r\n\r\n        by Tom Corbett  Microsoft Corp.\r\n        *\r\n\r\n\tINCLUDE\tGIO86U\r\n\t.SALL\r\n\r\nCPM86=0\r\nCOMPAQ=0\t\t\t;Include IBM 1.0/1.1 Bugs for compatibility\r\n\r\n\r\n\tINCLUDE\tMSDOSU\r\n\r\n\r\n\tPUBLIC\tCOMDSP,COMINI,COMTRM\r\n\tEXTRN\tDERBFM:NEAR,INIFDB:NEAR,UPDPOS:NEAR,$_COM1:NEAR,BCHRSI:NEAR\r\n\tEXTRN\tMAKINT:NEAR\r\n\tEXTRN\tDEVBIN:NEAR,DEVBOT:NEAR\r\n\r\n;Communications Dispatch Table\r\n;\r\nCOMDSP:\r\n\tDW\t(COMEOF)\t;test EOF for file opened to this device\r\n\tDW\t(COMLOC)\t;LOC\r\n\tDW\t(COMLOF)\t;LOF\r\n\tDW\t(COMCLS)\t;perform special CLOSE functions for this device\r\n\tDW\t(COMSWD)\t;set device width\r\n\tDW\t(COMRND)\t;GET/PUT random record from/to this device\r\n\tDW\t(COMOPN)\t;perform special OPEN functions for this device\r\n\tDW\t(COMSIN)\t;input 1 byte from file opened on this device\r\n\tDW\t(COMSOT)\t;output 1 byte to file opened on this device\r\n\tDW\t(COMGPS)\t;POS\r\n\tDW\t(COMGWD)\t;get device width\r\n\tDW\t(COMSCW)\t;set device comma width\r\n\tDW\t(COMGCW)\t;get device comma Width\r\n\tDW\t(DEVBIN)\t;block input from file opened on this device\r\n\tDW\t(DEVBOT)\t;block output to file opened on this device\r\n\tPAGE\t\r\n\tSUBTTL Communications Generalized I/O Routines\r\n\r\n; RS232 Device Control Block Definition:\r\n;\r\n;   mneumonic offset    use\r\n;   --------- ------    ---------------------------------------\r\n\t_DEVID=0D\t\t;RS232 Channel ID (0..n)\r\n\t_BAUDR=1D\t\t;baud rate (least significant byte 1st)\r\n\t\t\t\t;(0=disable device, 9600=9600 baud etc.)\r\n\t_BYTSZ=3D\t\t;bits per byte (4..8)\r\n\t_PARIT=4D\t\t;parity (0..4)=...(NONE, ODD, EVEN, MARK, SPACE)\r\n\t_STOPB=5D\t\t;(0..2)= (1, 1.5, 2) stop bits\r\n\t_RLSTO=6D\t\t;RLSD (rec. line signal detect) timeout\r\n\t_CTSTO=8D\t\t;CTS (clear to send) timeout\r\n\t_DSRTO=10D\t\t;DSR (data set ready) timeout\r\n\t\t\t\t;All timeout values are in milliseconds.\r\n\t\t\t\t;0=infinite, LSB is always 1st.\r\n\t\t\t\t;Support of Timeout Flags by BIOS is\r\n\t\t\t\t;optional.\r\n\t_CMFLG=12D\t\t;Boolean attributes mask for this device\r\n\t_CMBIN=1O\t\t;(0/1)=ASCII/BINARY (ASC option not in filename)\r\n\t_CMRTS=2O\t\t;non-zero=Suppress Request-To-Send (RS option)\r\n\t_CMCOD=20O\t\t;non-zero=user specified ASC or BIN in filename\r\n\t_CMCTS=40O\t\t;non-zero=CTS parm not defaulted\r\n\t_CMCLF=100O\t\t;non-zero=Send line feed after CR\r\n\t_CMCRF=200O\t\t;non-zero=last char sent was Carriage Return\r\n\r\n;If COM filename contains \"ASC\", .CMBIN=0, .CMCOD=1\r\n;If COM filename contains \"BIN\", .CMBIN=1, .CMCOD=1\r\n;If COM filename contains neither \"ASC\" nor \"BIN\", .CMBIN=1, .CMCOD=0\r\n;If COM filename contains both \"ASC\" and \"BIN\", Illegal Filename occurs\r\n\r\n;COM DCB Entries which are only of interest to BASIC (Not OEM routines)\r\n;\r\n\t\t\t\t;*********************************************\r\n\t\t\t\t;*** .CMPOS must immediately follow .CMWID ***\r\n\t\t\t\t;*********************************************\r\n\t_CMWID=13D\t\t;device width (columns per line)\r\n\t_CMPOS=14D\t\t;current column device is in **must follow .CMWID**\r\n\t_CMFDB=15D\t\t;points to FDB for file (0=not opened)\r\n\r\n\tCDCBSZ=24D\t\t;bytes per COM Device Control Block (room for growth)\r\n\r\n\tEXTRN\tINICOM:NEAR,RECCOM:NEAR,SNDCOM:NEAR,STACOM:NEAR,TRMCOM:NEAR\t;OEM routines\r\n\tEXTRN\tPOLKEY:NEAR,DERIFN:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tCM1DCB:WORD\r\nDSEG\tENDS\r\n\r\n;COMINI - called during BASIC initialization\r\n; Entry - DI = -2*device id\r\n;\r\n\tPUBLIC\tCOMINI,COMTRM\r\nCOMINI:\tPUSH\tDI\r\n\tCALL\tGCMDCB\t\t;DI points to device control block\r\n\tMOV\tBYTE PTR _CMWID[DI],LOW 255D\t;default is infinite width\r\n\tMOV\tWORD PTR _CMFDB[DI],0\t;mark this device as available for open\r\n\tPOP\tDI\r\nCOMTRM:\t\t\t\t;Com Termination Routine (End-of-BASIC)\r\n\tRET\t\t\t; No action required\r\n\r\n\r\n;POLCOM is called by CHKINT at beginning of every BASIC statement (NEWSTT).\r\n; For each COM device which is opened to a device, it calls COMTRP if that\r\n; device has input data waiting.\r\n; Exit - AX, BX, CX, DX can be used (restored by CHKINT).\r\n;        All other registers are preserved.\r\n;\r\n\tPUBLIC\tPOLCOM\r\n\tEXTRN\tCOMTRP:NEAR\r\n\r\nPOLCOM:\tPUSH\tDI\r\n\tPUSH\tSI\r\n\tMOV\tDI,OFFSET CM1DCB\t;DI points to device control block 1\r\n\tMOV\tDX,OFFSET NMCOMT\t;[DH]=COM unit#, [DL]=number of COM units\r\nPOLCML:\tCALL\tPOLCM1\t\t;test unit 1 for trap\r\n\tADD\tDI,OFFSET CDCBSZ\t;DI points to next device control block\r\n\tINC\tDH\t\t;Bump unit id\r\n\tDEC\tDL\t\t;Decrement unit counter\r\n\tJNZ\tPOLCML\t\t;branch if any more to test\r\n\tPOP\tSI\r\n\tPOP\tDI\r\n\tRET\t\r\n\r\n;POLCM1 checks 1 COM device to see if input is waiting, if so, it calls COMTRP\r\n;\r\nPOLCM1:\tMOV\tSI,WORD PTR _CMFDB[DI]\t;SI points to FDB (if device is opened)\r\n\tOR\tSI,SI\r\n\tJZ\tPLCM1X\t\t;return if device not opened\r\n\tTEST\tBYTE PTR F_FLGS[SI],LOW OFFSET FL_BKC\r\n\tJNE\tPOLTRP\t\t;branch if backup-char present\r\n\tMOV\tAH,DH\t\t;[AH]=Unit#\r\n\tPUSH\tDX\t\t;save Unit#\r\n\tCALL\tGCOMSZ\t\t;[DX]=number of bytes queued\r\n\tOR\tDX,DX\t\t;test it\r\n\tPOP\tDX\t\t;restore Unit#\r\nPOLTRP:\tMOV\tAL,DH\t\t;[AL]=trap id (0..n)\r\n\tJE\tPLCM1X\t\t;branch if no com data queued\r\n\tCALL\tCOMTRP\t\t;so ON-COM service routine will be called\r\nPLCM1X:\tRET\t\r\n\r\n;Get COM bytes in queue\r\n;       On entry: AH = unit number\r\n;       On return: DX=bytes in queue\r\n;                  CX=free bytes in queue\r\n;                   Does error processing if gets error from COM channel\r\nGCOMSZ:\tPUSH\tAX\r\n\tCALL\tSTACOM\r\n\tOR\tAH,AH\t\t;Check status here even though\r\n\t\t\t\t;CKCMER does for speed.\r\n\tJNZ\tCKCMER\t\t;branch if got error from COM\r\n\tPOP\tAX\r\nRET14:\tRET\t\r\n\r\n; Check for COM I/O error and output COM Error Message if error occured.\r\n; Entry - [AH] = non-zero if error occured\r\n;\r\n\tEXTRN\tSTROUT:NEAR,OUTDO:NEAR,ERROR:NEAR\r\n\tEXTRN\tERRCBO:NEAR,ERRDPE:NEAR,ERRDTO:NEAR,ERRDIO:NEAR\r\nCKCMER:\r\n\tOR\tAH,AH\r\n\tJE\tRET14\t\t;branch if no COM I/O error detected\r\n\tMOV\tAL,AH\r\n\tXOR\tAH,AH\t\t;[AX]=error code 1..n\r\n\tDEC\tAX\t\t;[AX]=error code 0..n\r\n\tMOV\tDI,OFFSET CMERRT\r\n\tADD\tDI,AX\t\t;[DI] points to BASIC Error code\r\n\tMOV\tDL,BYTE PTR CS:0[DI]\r\n\tCMP\tAL,LOW 5\r\n\tJB\tERROR1\t\t;branch if legal error code\r\n\tMOV\tDL,LOW OFFSET ERRDIO\t;map all other error codes to I/O error\r\nERROR1:\tJMP\tERROR\r\n\r\nCMERRT:\tDB\tOFFSET ERRCBO\t;buffer overflow error\r\n\tDB\tOFFSET ERRDPE\t;parity error\r\n\tDB\tOFFSET ERRDTO\t;device timeout\r\n\tDB\tOFFSET ERRDTO\t;device timeout\r\n\tDB\tOFFSET ERRDTO\t;device timeout\r\n\tPAGE\t\r\n\tSUBTTL  COM OPEN\r\n;\r\n;    Syntax:   OPEN \"COMn: [speed] [,parity] [,data] [,stop]\r\n;              [,RS]  [,CS[n]]  [,DS[n]]  [,CD[n]] [,LF] [,BIN] [,ASC]\" AS\r\n;              [#]filenum\r\n;\r\n;                   SPEED     baud rate in bits per second\r\n;                   PARITY    N, E, O (none, even, odd)\r\n;                   DATA      5,6,7,8 bits per byte\r\n;                   STOP      1, 1.5, 2 stop bits.\r\n;                             Default for baud greater than 110 is 1.\r\n;                             Default for 110 baud or lower & 5 data bits is 1.5\r\n;                             Default for 110 baud or lower & 6-8 data bits is 2\r\n;                   RS        Suppress RTS (Request To Send).\r\n;                   CS[n]     Controls CTS (Clear To Send).\r\n;                   DS[n]     Controls DSR (Data Set Ready).\r\n;                   CD[n]     Controls CD (Carrier Detect).\r\n;                             This is also referred to as RLSD\r\n;                             (Received Line Signal Detect).\r\n;                   LF        Send a Line-Feed character (X'0A')\r\n;                             following a Carriage Return (X'0D').\r\n;                   BIN       Open COM file in BINARY mode\r\n;                   ASC       Open COM file in ASCII mode\r\n;\r\n;              The RTS (Request To Send)  line  is turned on\r\n;              when you execute  an  OPEN  \"COM... statement\r\n;              unless you include the RS option.\r\n;\r\n;              If CD is omitted, it defaults to CS0.\r\n;              If DS is omitted, it defaults to DS1000.\r\n;              If CS is omitted, it defaults to CS1000.\r\n;              If RS is specified and CS is omitted, then\r\n;              CS defaults to 0.\r\n;\r\n;              Normally I/O  statements  to  a communication\r\n;              file will fail if the CTS (Clear To Send)  or\r\n;              DSR (Data Set Ready) lines  are  not  cabled.\r\n;              The CS and DS options allow you to avoid this\r\n;              problem by ignoring these  lines.  If the [n]\r\n;              argument is included, it specifies the number\r\n;              of milliseconds to wait for the signal before\r\n;              returning a \"Device Timeout\"  error.\r\n;\r\n;              If the argument [n] in the CS, DS, and CD options\r\n;              is omitted, or equal to 0, then that line's status\r\n;              is not checked at all.\r\n;\r\n;              Note:   The  speed,  parity,  data, and  stop\r\n;              parameters  are  positional, but RS, CS,  DS,\r\n;              and CD may appear in any order after STOP.\r\n;\r\n;              The LF parameter is intended for  those using\r\n;              communication files as a means of printing to\r\n;              a serial line  printer.  When included in the\r\n;              parameter list, LF will  cause  a  Line  Feed\r\n;              character to be sent after a  Carriage return\r\n;              character.\r\n\r\n;COMOPN - perform any device dependent open functions.\r\n; Entry - [AL]=  device id\r\n;                0 if default device,\r\n;                1..n for Disk A:, B:, ...\r\n;                -1..-n for non-disk devices\r\n;         [BX] = file number (0..n)\r\n;         [CX] = random record size if [FILMOD] = random\r\n;                (if [CX] = 0, use default record size)\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n;         [FILMOD] = file mode\r\n;                    MD.SQI = 1 ;sequential input\r\n;                    MD.SQO = 2 ;sequential output\r\n;                    MD.RND = 3 ;random\r\n;                    MD.APP = 4 ;append\r\n;         [FILNAM] = filename\r\n;         [FILEXT] = 1..3 byte filename extension\r\n; Exit  - [SI] points to new FDB\r\n;         FDB is linked into FDB chain with all standard\r\n;         fields initialized.\r\n;         All registers are used.\r\n;\r\n\r\n\tEXTRN\tDERFAO:NEAR\r\n\r\nCOMOPN:\tMOV\tAH,BL\t\t;[AH]=file number\r\n\tPUSH\tAX\t\t;save file number, device id\r\n\tPUSH\tCX\t\t;save variable record len (if random)\r\n\tCALL\tGCMDCB\t\t;AX = 0, 1, ... for COM1, COM2, ...\r\n\t\t\t\t;DI points to Device Control Block\r\n\tCMP\tWORD PTR _CMFDB[DI],0\t;see if device is opened to another file\r\n\tJE\tSTUNIT\t\t;not opened to another file\r\nERFAO1:\tJMP\tDERFAO\t\t;File Already Opened\r\nSTUNIT:\tMOV\tBYTE PTR _DEVID[DI],AL\t;set unit field of Device Control Block\r\n\tCALL\tPCOMOP\t\t;parse options (fill in DCB fields)\r\n\tTEST\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMRTS\r\n\tJE\tNORTSO\t\t;branch if RS option not specified\r\n\tTEST\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMCTS\r\n\tJNE\tNORTSO\t\t;branch if CTS parm specified\r\n\tMOV\tWORD PTR _CTSTO[DI],0\t;else default CTS to 0 seconds\r\nNORTSO:\r\n\tCMP\tBYTE PTR _STOPB[DI],LOW 255D\r\n\tJNE\tSTPNDF\t\t;brif stop not defaulted\r\n\tINC\tBYTE PTR _STOPB[DI]\t;.STOPB=0 (1 stop bit)\r\n\tCMP\tWORD PTR _BAUDR[DI],110D\r\n\tJA\tSTPNDF\t\t;brif baud rate exceeds 110 (1 stop)\r\n\tINC\tBYTE PTR _STOPB[DI]\t;.STOPB=1 (1.5 stop bit)\r\n\tCMP\tBYTE PTR _BYTSZ[DI],LOW 5\r\n\tJBE\tSTPNDF\t\t;brif 4 or 5 bits per byte (1.5 stop)\r\n\tINC\tBYTE PTR _STOPB[DI]\t;110 baud & 6,7,8 data bits=2 stop bits\r\nSTPNDF:\tMOV\tBYTE PTR _CMPOS[DI],LOW 0\t;reset column to 0\r\n\tMOV\tBX,DI\t\t;BX points to DCB\r\n\tCALL\tINICOM\t\t;call machine dependent OPEN routine\r\n\t\t\t\t;destroys FLAGS, AX..DX\r\n\tINC\tAH\r\n\tJE\tERIFN1\t\t;branch if Illegal Filename\r\n\tDEC\tAH\r\n\tCALL\tCKCMER\t\t;see if INICOM didn't like options\r\n\tPOP\tCX\t\t;[CX]=record length\r\n\tCMP\tBYTE PTR FILMOD,LOW OFFSET MD_RND\r\n\tJNZ\tNOTRND\t\t;branch if not OPEN RANDOM\r\n\tOR\tCX,CX\r\n\tJNZ\tNOTDEF\t\t;branch if user requested Record-Size\r\n\tMOV\tCX,OFFSET DATPSC\t;default to 128 (same as disk)\r\nNOTDEF:\tADD\tCX,OFFSET FD_DAT-FDBSIZ\t;add standard Disk FDB requirements\r\nNOTRND:\tPOP\tAX\t\t;[AL]=device id\r\n\tMOV\tDX,WORD PTR _CMWID[DI]\t;[DL]=width, [DH]=init position\r\n\t\t\t\t;from Device Control Block\r\n\tMOV\tBL,AH\r\n\tMOV\tBH,LOW 0\t;[BX]=file number\r\n\tMOV\tAH,LOW 255D\t;allow all file modes\r\n\tPUSH\tCX\t\t;save Random Record Size\r\n\tCALL\tINIFDB\t\t;Initialize FDB\r\n\tPOP\tCX\r\n\tOR\tCX,CX\r\n\tJZ\tNTRND\t\t;branch if mode is not random\r\n\tSUB\tCX,OFFSET FD_DAT-FDBSIZ\t;CX=record size requested by user\r\n\tMOV\tWORD PTR FD_SIZ[SI],CX\t;save in FDB\r\nNTRND:\tMOV\tWORD PTR _CMFDB[DI],SI\t;save FDB pointer in DCB\r\n\tTEST\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMBIN\r\n\tJZ\tCMOPNX\t\t;branch if user wants ASCII mode\r\nEXTRN\tSCDBIN:NEAR\r\n\tCALL\tSCDBIN\t\t;set CODE atr for file PTRFIL to BINARY\r\nCMOPNX:\r\nRET21:\tRET\t\r\n\r\nERIFN1:\tJMP\tDERIFN\t\t;Illegal File Name\r\n\r\n;Parse COM Open Options \"baud, data, parity, stop\"\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFILOPT:WORD\r\nDSEG\tENDS\r\nPCOMOP:\tMOV\tWORD PTR _BAUDR[DI],300D\t;default baud rate = 300\r\n\tMOV\tBYTE PTR _STOPB[DI],LOW 255D\t;mark STOP bits as Default\r\n\tMOV\tBYTE PTR _BYTSZ[DI],LOW 7D\t;default physical byte size = 7\r\n\tMOV\tBYTE PTR _PARIT[DI],LOW 2\t;default parity = Even\r\n\tMOV\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMBIN\t;default BINARY, CRLF = off\r\n\tMOV\tWORD PTR _RLSTO[DI],0\t;default Carrier Detect timeout=0\r\n\tMOV\tWORD PTR _CTSTO[DI],1000D\t;default Clear-To-Send timeout=1 sec\r\n\tMOV\tWORD PTR _DSRTO[DI],1000D\t;default Data Set Ready timeout=1 sec\r\n\tMOV\tSI,OFFSET FILOPT\t;SI points to options string\r\n\tCALL\tGETPR0\t\t;Get 1st char in Filename\r\n\tJZ\tRET21\t\t;Brif EOS\r\n\tJB\tCOMOP3\t\t;Brif default Baud (Saw \",\")\r\n\tDEC\tSI\t\t;Adjust for GETPRM\r\n\tCALL\tVALGET\t\t;Get Rate in [DX]\r\n\tMOV\tWORD PTR _BAUDR[DI],DX\t;save baud rate code\r\n\tCALL\tGETPRM\r\n\tJZ\tRET21\t\t;branch if EOS\r\nCOMOP3:\r\n\tCALL\tSYNPRM\t\t;\",\" must follow or Illegal File Name\r\n\tMOV\tCH,LOW 2\t;Default parity=Even(2)\r\n\tJB\tDFTPTY\t\t;Brif Default (saw \",\")\r\n\tXOR\tCH,CH\t\t;Map parity parameter to internal code\r\n\tCMP\tAL,LOW \"N\"\r\n\tJZ\tGOTPTY\t\t;Map NONE to 0\r\n\tINC\tCH\r\n\tCMP\tAL,LOW \"O\"\r\n\tJZ\tGOTPTY\t\t;Map ODD to 1\r\n\tINC\tCH\r\n\tCMP\tAL,LOW \"E\"\r\n\tJZ\tGOTPTY\t\t;Map EVEN to 2\r\n\tINC\tCH\r\n\tCMP\tAL,LOW \"M\"\r\n\tJZ\tGOTPTY\t\t;Map MARK to 3\r\n\tINC\tCH\r\n\tCMP\tAL,LOW \"S\"\r\n\tJZ\tGOTPTY\t\t;Map SPACE to 4\r\nERIFN2:\r\n\tJMP\tDERIFN\t\t;Complain (\"Illegal File Name\")\r\nDFTPTY:\r\n\tDEC\tSI\t\t;Adjust for GETPRM\r\nGOTPTY:\r\n\tMOV\tBYTE PTR _PARIT[DI],CH\t;save parity in DCB\r\n\tCALL\tGETPRM\t\t;Scan off end of Parity field\r\n\tJZ\tCOMOP5\t\t;Brif EOS, Default Data/Stop bits\r\n\tCALL\tSYNPRM\t\t; else Data bits must follow\r\n\tJB\tCOMOP4\t\t;Brif saw \",\" try for Stop bits\r\n\tSUB\tAL,LOW \"0\"\t;map (\"4\"..\"8\") to (4..8)\r\n\tCMP\tAL,LOW 4\r\n\tJB\tERIFN2\t\t; Error if less than \"4\"\r\n\tCMP\tAL,LOW 9D\r\n\tJNB\tERIFN2\t\t; or greater than \"8\"\r\n\tMOV\tBYTE PTR _BYTSZ[DI],AL\t;save Data bits\r\n\tCALL\tGETPRM\t\t; Look for no. of stop bits or EOS\r\n\tJZ\tCOMOP5\t\t;Brif EOS\r\nCOMOP4:\r\n\tCALL\tSYNPRM\t\t;Stop bits must follow\r\n\tJB\tCOMOP5\t\t;Brif saw \",\" Default Stop bits\r\n\tSUB\tAL,LOW \"1\"\t;Strip ASCII bias (\"1\", \"2\")=(0,1)\r\n\tCMP\tAL,LOW 2\t;Must be \"1\" or \"2\"\r\n\tJNB\tERIFN2\t\t; else error\r\n\tADD\tAL,AL\t\t;map (\"1\",\"2\") to (0,2)\r\n\tMOV\tBYTE PTR _STOPB[DI],AL\t;set STOP bits field in DCB\r\n\tJNZ\tLPARM\t\t;branch if \"2\"\r\n\tCALL\tGETPRM\t\t;[AL]=EOS, \",\" or \".\"\r\n\tJZ\tRET24\t\t;return if End-Of-String\r\n\tCMP\tAL,LOW \".\"\r\n\tJNZ\tLPARM2\t\t;it had better be a comma\r\n\tCALL\tGETPRM\r\n\tCMP\tAL,LOW \"5\"\r\n\tJNZ\tERIFN2\t\t;illegal filename error if not 1.5\r\n\tINC\tBYTE PTR _STOPB[DI]\t;map (\"1\", \"1.5\", \"2\") to (0,1,2)\r\n\tINC\tSI\r\nCOMOP5:\r\n\tDEC\tSI\t\t;adjust for GETPRM\r\n\r\n;This routine parses the position independent parameters RTS, DSR, ...\r\n;\r\nLPARM:\r\n\tCALL\tGETPRM\t\t;Get parm, EOS, or \",\"\r\n\tJZ\tRET24\t\t;Brif no more parms\r\nLPARM2:\r\n\tCALL\tSYNPRM\t\t;Check \",\" then get parm\r\n\tCMP\tAL,LOW \"R\"\t;RS?\r\n\tJNZ\tLPARDS\t\t;no, try DS/CS/CD/LF/BIN\r\n\tCALL\tLPTRYS\t\t; S?\r\n\tJNZ\tPARIFN\t\t;no, error\r\n\tOR\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMRTS\t;set RTS bit\r\n\tJMP\tSHORT LPARM\t;get next parm\r\nLPARDS:\r\n\tCMP\tAL,LOW \"D\"\t;DS?\r\n\tJNZ\tLPARCD\t\t;No, try CS/CD/LF/BIN\r\n\tCALL\tLPTRYS\t\t; S?\r\n\tJNZ\tPARIFN\t\t;no, error\r\n\tCALL\tVALGET\t\t;[DX] = Timeout\r\n\tMOV\tWORD PTR _DSRTO[DI],DX\t;set DSR timeout\r\n\tJMP\tSHORT LPARM\t;get next parm\r\n\r\nLPARCD:\r\n\tCMP\tAL,LOW \"C\"\t;CS/CD?\r\n\tJNZ\tLPARLF\t\t;no, try LF/BIN\r\n\tCALL\tLPTRYS\t\t; S?\r\n\tJZ\tLPARCS\t\t;Brif CS\r\n\tCMP\tAL,LOW \"D\"\t; D?\r\n\tJNZ\tPARIFN\t\t;no, error\r\n\tCALL\tVALGET\t\t;[DX] = Timeout\r\n\tMOV\tWORD PTR _RLSTO[DI],DX\t;set RLSD timeout\r\n\tJMP\tSHORT LPARM\t;get next parm\r\nLPARLF:\r\n\tCMP\tAL,LOW \"L\"\t;LF?\r\n\tJNZ\tLPRBIN\t\t;no, try BINary\r\n\tCALL\tLPTRYS\r\n\tCMP\tAL,LOW \"F\"\t;\"F\" must follow\r\n\tJNZ\tPARIFN\t\t;no, error\r\n\tOR\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMCLF\t;set send LF after CR flag\r\n\tJMP\tSHORT LPARM\t;get next parm\r\nLPARCS:\r\n\tCALL\tVALGET\t\t;[DX] = Timeout\r\n\tMOV\tWORD PTR _CTSTO[DI],DX\t;set CTS timeout\r\n\tOR\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMCTS\t;indicates CTS not defaulted\r\n\tJMP\tSHORT LPARM\t;get next parm\r\nPARIFN:\r\n\tJMP\tDERIFN\t\t;Illegal File Name error\r\n\r\nLPTRYS:\r\n\tCALL\tGETPRM\r\n\tCMP\tAL,LOW \"S\"\t;set cond codes for S (Frequent letter)\r\nRET24:\tRET\t\r\n\r\nLPRBIN:\tCMP\tAL,LOW \"B\"\t;BIN?\r\n\tJNZ\tLPRASC\t\t;Branch if not\r\n\tCALL\tLPTRYS\r\n\tCMP\tAL,LOW \"I\"\t; I?\r\n\tJNZ\tPARIFN\t\t;no, error\r\n\tCALL\tLPTRYS\r\n\tCMP\tAL,LOW \"N\"\t; N?\r\n\tJNZ\tPARIFN\t\t;no, error\r\n;;; Binary mode is the default mode, next line for Documentation Purposes\r\n;;;     ORBI    .CMFLG(.DI),.CMBIN      ;set binary mode\r\n\tJMP\tSHORT TSTCOD\t;get next parameter\r\n\r\nLPRASC:\tCMP\tAL,LOW \"A\"\t;ASC?\r\n\tJNZ\tPARIFN\t\t;Illegal filename if not\r\n\tCALL\tLPTRYS\r\n\tCMP\tAL,LOW \"S\"\t; S?\r\n\tJNZ\tPARIFN\t\t;no, error\r\n\tCALL\tLPTRYS\r\n\tCMP\tAL,LOW \"C\"\t; C?\r\n\tJNZ\tPARIFN\t\t;no, error\r\n\tAND\tBYTE PTR _CMFLG[DI],LOW OFFSET 255D-_CMBIN\t;reset binary mode\r\nTSTCOD:\tTEST\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMCOD\r\n\tJNE\tPARIFN\t\t;bad filename if ASC and BIN specified\r\n\tOR\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMCOD\r\n\tJMP\tLPARM\t\t;get next parameter\r\n\r\nSYNPRM:\r\n\tCMP\tBYTE PTR 0[SI],LOW \",\"\r\n\tJZ\tGETPRM\t\t;Brif found \",\"\r\n\tJMP\tSHORT PARIFN\t; else \"Bad File Name\" if no comma\r\nCHKPRM:\r\n\tDEC\tSI\r\n\r\nGETPRM:\r\n\tCMP\tBYTE PTR 0[SI],LOW 0\r\n\tJZ\tGETPRX\t\t;Brif EOS\r\n\r\n;Get Next Option Char skipping blanks and forcing upper case\r\n; Exit - Carry = comma, Z = end-of-statement, else [AL]=byte\r\n;\r\nGETPRI:\r\n\tINC\tSI\r\nGETPR0:\r\n\tMOV\tAL,BYTE PTR 0[SI]\t;Get next char\r\n\tCMP\tAL,LOW \" \"\r\n\tJZ\tGETPRM\t\t;Ignore Blanks\r\n\tCMP\tAL,LOW \",\"\r\n\tJNZ\tGETPR1\t\t;Brif not \",\"\r\n\tOR\tAL,AL\t\t;set NZ (not end-of-statement)\r\n\tSTC\t\t\t;set carry\r\n\tRET\t\t\t;Comma returns: NZ and TC\r\nGETPR1:\r\n\tCMP\tAL,LOW \"a\"\t;Case convert?\r\n\tJB\tGETPR2\t\t;Brif not\r\n\tXOR\tAL,LOW 40O\t;Convert to Uppercase\r\nGETPR2:\r\n\tOR\tAL,AL\t\t;Chars return NZ and NC\r\nGETPRX:\r\n\tRET\t\t\t;EOS returns TZ and NC\r\n\r\n;Parse decimal number returning result in [DX]\r\n;\r\nVALGET:\r\n\tPUSH\tBX\r\n\tXOR\tDX,DX\t\t;INITIAL VALUE OF ZERO\r\n\tMOV\tAH,LOW 6\t;MAXIMUM 5 DIGITS.\r\nVALLOP:\r\n\tCALL\tGETPRI\t\t;Get next char in [AL]\r\n\tCMP\tAL,LOW OFFSET \"9\"+1\t;NOW SEE IF ITS A DIGIT\r\n\tJNB\tVALXIT\t\t;IF NOT, RETURN\r\n\tCMP\tAL,LOW \"0\"\r\n\tJB\tVALXIT\r\n\tMOV\tBX,DX\t\t;ARG=ARG*10+DIGIT\r\n\tADD\tBX,BX\t\t;*5\r\n\tADD\tBX,BX\r\n\tADD\tBX,DX\r\n\tADD\tBX,BX\t\t;*2\r\n\tSUB\tAL,LOW \"0\"\t;ADD IN THE DIGIT\r\n\tMOV\tDL,AL\r\n\tXOR\tDH,DH\t\t;[DX]=new digit\r\n\tADD\tBX,DX\r\n\tXCHG\tDX,BX\t\t;VALUE SHOULD BE IN [DX]\r\n\tDEC\tAH\t\t;Max digits -1\r\n\tJNZ\tVALLOP\t\t;WILL FALL THRU IF MORE THAN 5 DIGITS\r\n\tJMP\tDERIFN\t\t;TOO MANY DIGITS. Illegal File Name\r\nVALXIT:\r\n\tDEC\tSI\t\t;Adjust for GETPRM\r\n\tPOP\tBX\r\n\tRET\t\r\n\r\n;COMEOF - test for End-Of-File on device.\r\n; Entry - SI points to File-Data-Block.\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - [BX] = -1 if EOF, 0 if not EOF\r\n;\r\n\tEXTRN\tINCHSI:NEAR\r\nCOMEOF:\r\n\tCMP\tBYTE PTR F_CODE[SI],LOW OFFSET FC_BIN\r\n\tJE\tBINEOF\t\t;Branch if not ASCII file mode\r\n\r\n;The following code is removed so we won't say EOF is false and then\r\n; give user Input-Past-End error when CTL-Z finally comes through.\r\n; This also means EOF function will hang waiting for input, but\r\n; presumably, user wants device to look like sequential file, not\r\n; a dynamic COM-I/O device if he is using EOF function.\r\n;\r\n\tXOR\tBX,BX\t\t;assume no EOF\r\n\tCALL\tINCHSI\t\t;[AL]=next byte from COM device\r\n\tJB\tYCMEOF\t\t;branch if next char = EOF\r\n\tCALL\tBCHRSI\t\t;put this back in queue\r\nCMEOFX:\tRET\t\t\t;BX=0,  end-of-file is false\r\n\r\n;   In BINARY mode, GW-BASIC EOF is compatible with IBM-PC Basic\r\n;   That is, EOF is true when no data is in input queue.\r\n;\r\nBINEOF:\r\n\tCALL\tCOMLOC\t\t;[BX]=number of bytes in input queue\r\n\tOR\tBX,BX\r\n\tJE\tYCMEOF\t\t;branch if input queue is empty\r\n\tMOV\tBX,1\t\t;return with [BX]=0 (false)\r\nYCMEOF:\tDEC\tBX\t\t;BX=-1 if end-of-file is true\r\n\tRET\t\r\n\r\n;COMLOC - Number of Bytes in input buffer for device.\r\n; Entry - SI points to File-Data-Block.\r\n;         DI = device offset\r\n; Exit  - [BX] = result.\r\n;\r\nCOMLOC:\tCALL\tGCMUID\t\t;AL=Unit ID\r\n\tMOV\tAH,AL\r\n\tCALL\tGCOMSZ\t\t;[DX]=number of bytes in input buffer\r\n\tMOV\tBX,DX\t\t;return result in BX\r\n\tTEST\tBYTE PTR F_FLGS[SI],LOW OFFSET FL_BKC\r\n\tJZ\tCMLOCX\t\t;branch if char not backed up\r\n\tINC\tBX\r\nCMLOCX:\tRET\t\r\n\r\n;COMLOF - number of bytes free in input buffer.\r\n; Entry - SI points to File-Data-Block.\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - [Floating-Point-Accumulator] = result.\r\n;\r\nCOMLOF:\tCALL\tCOMLOC\r\n\tMOV\tBX,CX\t\t;Prep to move free bytes to FAC\r\n\tJMP\tMAKINT\t\t;return result in FAC\r\n\r\n;COMCLS - perform any device dependent close functions.\r\n; Entry - SI points to File-Data-Block.\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - All registers preserved.\r\n;         This routine is called before BASIC releases the\r\n;         file-data-block associated with this file.\r\n;\r\nCOMCLS:\tCALL\tGCMDCB\t\t;DI points to device control block\r\n\tMOV\tWORD PTR _CMFDB[DI],0\t;mark device as not-in-use\r\n\tCMP\tBYTE PTR F_CODE[SI],LOW OFFSET FC_BIN\r\n\tJE\tCOMCLX\t\t;Branch if BINARY file mode\r\n\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_SQI\r\n\tJE\tCOMCLX\t\t;don't send EOF if input mode\r\n\tMOV\tAL,LOW OFFSET ASCCTZ\t;else send CTL-Z indicating EOF\r\n\tMOV\tAH,BYTE PTR _DEVID[DI]\t;[AH]=device ID\r\n\tCALL\tSNDCOM\t\t;output CTL-Z to COM channel\r\n\t\t\t\t;ignoring error conditions\r\nCOMCLX:\tMOV\tAH,BYTE PTR _DEVID[DI]\t;[AH]=device ID\r\n\tCALL\tTRMCOM\t\t;terminate COM channel\r\n\tJMP\tCKCMER\t\t;Check for COM I/O Error\r\n\r\n;COMSWD - set device width\r\n; Entry - SI points to File-Data-Block.\r\n;         [DX] = new device width\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - All registers preserved\r\n;\r\nCOMSWD:\tCALL\tGCMDCB\t\t;DI points to device control block\r\n\tMOV\tBYTE PTR _CMWID[DI],DL\t;set device width\r\nRET12:\tRET\t\r\n\r\n;COMRND - perform random I/O.\r\n; Entry - [AL] = function to be performed:\r\n;                0: get next record\r\n;                1: put next record\r\n;                2: get record [DX] (1-relative)\r\n;                3: put record [DX] (1-relative)\r\n;         [SI] points to File-Data-Block\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - All registers are used.\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFILMOD:WORD\r\nDSEG\tENDS\r\nCOMRND:\tCMP\tAL,LOW 2\r\n\tJAE\tCMRND1\t\t;branch if user specified byte count\r\n\tMOV\tDX,WORD PTR FD_SIZ[SI]\t;default to record-size\r\nCMRND1:\tLEA\tBX,DWORD PTR FD_DAT[SI]\t;BX points to random record buffer\r\n\tMOV\tCX,DX\t\t;CX=byte count\r\n\tTEST\tAL,LOW 1\r\n\tJNZ\tPUTRND\t\t;branch if PUT requested\r\nGETLOP:\tPUSH\tDI\t\t;[AL]=next byte from com port\r\n\tCALL\tCOMSIN\t\t;[AL]=next byte from com port\r\n\tPOP\tDI\r\n\tMOV\tBYTE PTR 0[BX],AL\t;save byte in buffer\r\n\tINC\tBX\t\t;bump buffer pointer\r\n\tLOOP\tGETLOP\r\n\tRET\t\r\nPUTRND:\tCALL\tGCMDCB\t\t;DI points to COMx DCB\r\nPUTLOP:\tMOV\tAL,BYTE PTR 0[BX]\t;[AL]=next byte from buffer\r\n\tCALL\tCMROUT\t\t;output to com port\r\n\tINC\tBX\t\t;bump buffer pointer\r\n\tLOOP\tPUTLOP\r\n\tRET\t\r\n\r\n;COMSIN - Sequential Input.\r\n; Entry - SI points to File-Data-Block.\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - [AL] = next byte from file,\r\n;         carry set if EOF.\r\n;         All other registers preserved\r\n;\r\nCOMSIN:\r\nCSWAIT:\tCALL\tGCMUID\t\t;[AL]=Com Unit ID(DI)\r\n\tMOV\tAH,AL\t\t;[AH]=Com Unit ID(DI)\r\n\tCALL\tRECCOM\t\t;[AL]=input byte (if data is ready)\r\n\tPUSHF\t\r\n\tCALL\tCKCMER\t\t;Check for COM I/O Error\r\n\tPOPF\t\r\n\tJNZ\tCSGOT1\t\t;wait if none ready to be read\r\n\tCALL\tPOLKEY\t\t;allow CTL-Z to break in\r\n\tJMP\tSHORT CSWAIT\r\nCSGOT1:\r\n\tCMP\tAL,LOW OFFSET ASCCTZ\t;check for CTL-Z\r\n\tJNE\tCMNEOF\t\t;branch if not\r\n\tCMP\tBYTE PTR F_CODE[SI],LOW OFFSET FC_BIN\r\n\tJE\tCMNEOF\t\t;CTL-Z is not EOF for Binary files\r\n\tSTC\t\t\t;CTL-z is EOF for ASCII files\r\n\tJMP\tSHORT CMSINX\t;restore registers and exit\r\nCMNEOF:\tOR\tAL,AL\t\t;clear carry (no eof)\r\nCMSINX:\tRET\t\r\n\r\n;COMSOT - Sequential Output.\r\n; Expand tab to spaces, force carriage return before outputting char\r\n; if char is printable (greater than 20h) and column exceeds width.\r\n; Since CRONLY is false in GW versions, COMSOT always gets CR-LF for\r\n; end-of-line.  To be as close to IBM Basic as possible, the following\r\n; algorithm is used:\r\n;   Eat LF if last-char-was-CR\r\n;   clear last-char-was-CR flag\r\n;   if char is CR\r\n;       set last-char-was-CR flag\r\n;       if LF-option was set in filename,\r\n;           output a LF\r\n;   The only known case where this is different from IBM is if the file\r\n;   is opened without the LF option and the user executes\r\n;   PRINT CHR$(13);CHR$(10);.  On IBM, 13-10 would be output.\r\n;   On GW, 13 would be output.  The ultimate solution would be for GW\r\n;   to be compiled with CRONLY=1 and change disk code to insert LF after\r\n;   CR.\r\n; Entry - SI points to File-Data-Block.\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n;         [AL] = byte to be output.\r\n; Exit  - SI, DI can be changed.\r\n;         All other registers preserved\r\n;         This routine keeps track of column position,\r\n;         expands tabs, and forces a carriage return when line width\r\n;         is exceeded.\r\n;\r\nCOMSOT:\tPUSH\tAX\r\n\tCALL\tGCMDCB\t\t;DI points to COMx DCB\r\n\tPOP\tAX\t\t;restore [AL]=byte to output\r\n\tTEST\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMCOD\r\n\tJE\tNOTBIN\t\t;brif user didn't explicitly specify BIN\r\n\tCMP\tBYTE PTR F_CODE[SI],LOW OFFSET FC_BIN\r\n\tJE\tCMROUT\t\t;if BIN, branch to Raw-Output routine\r\nNOTBIN:\tPUSH\tBX\r\n\tPUSH\tDX\r\n\tMOV\tBX,OFFSET CMOUT1\t;BX points to Raw Output Routine\r\n\tMOV\tDL,BYTE PTR F_WID[SI]\t;[DL]=device width (from FDB)\r\n\tMOV\tDH,BYTE PTR _CMPOS[DI]\t;[DH]=current column (from DCB)\r\n\tEXTRN\tCRIFEL:NEAR\r\n\tCALL\tCRIFEL\t\t;force CR if End-Of-Line, output char\r\n\r\n\tMOV\tBYTE PTR _CMPOS[DI],DH\t;save new column position\r\n\tPOP\tDX\r\n\tPOP\tBX\r\nRET11:\tRET\t\r\n\r\n;Low-Level RS232 Output (updates column position)\r\n; If LF option was not set in COMOPN (OPEN \"COM1:,,,,LF), eat all LineFeeds\r\n;    which follow CarriageReturns with following algorithm:\r\n; if (Char <> LF) or (LastWasCR = 0) then output (Char)\r\n; if (Char = CR) then LastWasCR = 1 else LastWasCR = 0\r\n; if (LastWasCR) and COMOPN.LF then output(LF)\r\n;\r\n; The best way this could have been done was by setting CRONLY=1 in the\r\n; switch files and letting the device drivers append Line-Feeds if necessary.\r\n; It was considered too late to make a change this drastic\r\n;\r\n;\r\nCMOUT1:\tCALL\tUPDPOS\t\t;[DH]=new column position(AL, DH)\r\n\tPUSH\tAX\t\t;save character to be output\r\n\tCMP\tAL,LOW OFFSET ASCLF\r\n\tJNE\tCMOUT2\t\t;branch if not attempting to output LF\r\n\tTEST\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMCRF\r\n\tJNE\tCMOUT3\t\t;brif last byte out was CR\r\nCMOUT2:\r\n\tCALL\tCMROUT\t\t;output the character\r\nCMOUT3:\r\n\tPOP\tAX\t\t;restore [AL]=char which was output\r\n\tAND\tBYTE PTR _CMFLG[DI],LOW OFFSET 255D-_CMCRF\t;reset last byte out was CR flag\r\n\tCMP\tAL,LOW OFFSET ASCCR\r\n\tJNE\tCMOUTX\t\t;return if wasn't carriage return\r\n\tOR\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMCRF\t;set last byte out was CR flag\r\n\tTEST\tBYTE PTR _CMFLG[DI],LOW OFFSET _CMCLF\r\n\tJE\tCMOUTX\t\t;brif CR is not to be mapped to CR-LF\r\n\tPUSH\tAX\r\n\tMOV\tAL,LOW OFFSET ASCLF\r\n\tCALL\tCMROUT\r\n\tPOP\tAX\r\nCMOUTX:\r\n\tRET\t\r\n\r\n;Output byte [AL] to device with COM DCB pointed to by [DI].\r\n;If error occurs, jump to ERROR\r\n;\r\nCMROUT:\tMOV\tAH,BYTE PTR _DEVID[DI]\t;[AH]=device ID\r\n\tPUSH\tAX\r\n\tCALL\tSNDCOM\t\t;output [AL] to COM and return\r\n\tCALL\tCKCMER\t\t;Check for I/O errors and return\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n;COMGPS - return current file position.\r\n; Entry - SI points to File-Data-Block.\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - [AH] = current file column. (0-relative)\r\n;         All other registers preserved\r\n;\r\nCOMGPS:\tCALL\tGCMDCB\t\t;DI points to Device Control Block\r\n\tMOV\tAH,BYTE PTR _CMPOS[DI]\r\n\tRET\t\r\n\r\n;COMGWD - get device width\r\n; Entry - SI points to File-Data-Block.\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - [AH] = device width as set by xxxSWD\r\n;         All other registers preserved\r\n;\r\nCOMGWD:\tCALL\tGCMDCB\t\t;DI points to Device Control Block\r\n\tMOV\tAH,BYTE PTR _CMWID[DI]\t;get width\r\n\tRET\t\r\n\r\n;COMSCW - set device comma width\r\n; Entry - [BX] = new device comma width\r\n;         SI points to File-Data-Block.\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - SI, DI can be changed.\r\n;         All other registers preserved\r\n;\r\nCOMSCW:\tRET\t\r\n\r\n;COMGCW - get device comma width\r\n; Entry - SI points to File-Data-Block.\r\n;         [DI] = device offset (2=COMD, 4=SCRN, etc.)\r\n; Exit  - [BX] = device comma width as set by xxxSCW\r\n;         All other registers preserved\r\n;\r\nCOMGCW:\tRET\t\r\n\r\n;GCMDCB - get pointer to COM Device Control Block\r\n; Entry - [DI] = -2*device id (2,4,..n)\r\n; Exit  - DI points to the device control block for device DI.\r\n;         [AX] = 0..n for COM1, COM2, ...\r\n;\r\nGCMDCB:\tCALL\tGCMUID\t\t;[AX]=unit id (0..n)\r\n\tPUSH\tAX\t\t;save unit id\r\n\tMOV\tAH,LOW OFFSET CDCBSZ\t;AX = bytes per COM DCB\r\n\tMUL\tAH\t\t;AX = unit ID * CDCBSZ\r\n\tADD\tAX,OFFSET CM1DCB\r\n\tMOV\tDI,AX\t\t;DI points to COMx device ctl block\r\n\tPOP\tAX\t\t;[AX]=unit id\r\n\tRET\t\r\n\r\n;GCMUID - get COM Unit Id\r\n; Entry - [DI] = -2*device id (2,4,..n)\r\n; Exit  - [AX] = 0..n for COM1, COM2, ...\r\n;\r\nGCMUID:\tMOV\tAX,DI\r\n;       ADDI    AX,$CODE+2*<$.COM1-^O400>   ;[DI]=0, 2, ... for COM1, COM2, ...\r\n\tSHR\tAX,1\r\n\tADD\tAX,OFFSET ($_COM1-400O)\t;[AX]=0, 1, ... for COM1, COM2, ...\r\n\tRET\t\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GIOCON.ASM",
          "type": "blob",
          "size": 3.125,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GIOCON - Machine Independent CONS: Device Support\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- ---------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT\r\n--------- --- ---- -- ---------\r\n\r\n        *\r\n\tINCLUDE\tGIO86U\r\n\t.SALL\r\n\r\nCPM86=0\t\t\t\t;CPM86\r\n\r\n;This module becomes NULL if CONSSW is 0\r\n;\r\n\tINCLUDE\tMSDOSU\t\t;MSDOS Constant Definitions\r\n\r\n\r\n\r\n\tPUBLIC\tCONDSP,_RET,CONSOT\r\n\r\n\tEXTRN\tDERBFM:NEAR,PDCBAX:NEAR\r\n\tEXTRN\tDEVBOT:NEAR,DEVBIN:NEAR\r\n\r\n\tPAGE\t\r\n\tSUBTTL  CONS (Raw-CRT output Dispatch Table and Routines)\r\n\r\n;Console Dispatch Table\r\n;\r\nCONDSP:\r\n\tDW\t(DERBFM)\t;test EOF for file opened to this device\r\n\tDW\t(DERBFM)\t;LOC\r\n\tDW\t(DERBFM)\t;LOF\r\n\tDW\t(_RET)\t\t;perform special CLOSE functions for this device\r\n\tDW\t(DERBFM)\t;set device width\r\n\tDW\t(DERBFM)\t;GET/PUT random record from/to this device\r\n\tDW\t(CONOPN)\t;perform special OPEN functions for this device\r\n\tDW\t(DERBFM)\t;input 1 byte from file opened on this device\r\n\tDW\t(CONSOT)\t;output 1 byte to file opened on this device\r\n\tDW\t(CONGPS)\t;POS\r\n\tDW\t(CONGWD)\t;get device width\r\n\tDW\t(_RET)\t\t;set device comma width\r\n\tDW\t(_RET)\t\t;get device comma width\r\n\tDW\t(DEVBIN)\t;block input from file opened on this device\r\n\tDW\t(DEVBOT)\t;block output to file opened on this device\r\n\r\n;CONOPN - perform any device dependent open functions.\r\n; Entry - [AL]=  device id\r\n;                0 if default device,\r\n;                1..n for Disk A:, B:, ...\r\n;                -1..-n for non-disk devices\r\n;         [BX] = file number (0..n)\r\n;         [CX] = random record size if [FILMOD] = random\r\n;                (if [CX] = 0, use default record size)\r\n;         [DI] = device offset (2=SCND, 4=SCRN, etc.)\r\n;         [FILMOD] = file mode\r\n;                    MD.SQI = 1 ;sequential input\r\n;                    MD.SQO = 2 ;sequential output\r\n;                    MD.RND = 3 ;random\r\n;                    MD.APP = 4 ;append\r\n;         [FILNAM] = filename\r\n;         [FILEXT] = 1..3 byte filename extension\r\n; Exit  - [SI] points to new FDB\r\n;         FDB is linked into FDB chain with all standard\r\n;         fields initialized.\r\n;         All other registers are preserved.\r\n;\r\n\r\n\tEXTRN\tINIFDB:NEAR\r\n\r\nCONOPN:\r\n\tMOV\tAH,LOW OFFSET MD_SQO\t;allow open for output only\r\n\tMOV\tDX,255D\t\t;initial file column position=0\r\n\t\t\t\t;initial file width=255\r\n\tJMP\tINIFDB\r\n\r\n;CONGPS - return current file position.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [AH] = current file column. (0-relative)\r\n;         All other registers preserved\r\n;\r\nCONGPS:\tMOV\tAH,LOW 0\r\n_RET:\tRET\t\r\n\r\n;CONGWD - get device width\r\n; Exit  - [AH] = device width as set by xxxSWD\r\n;         All other registers preserved\r\n;\r\nCONGWD:\r\n\tMOV\tAH,LOW 255D\t;infinite width\r\n\tRET\t\r\n\r\n;CONSOT - Write one byte to the console.\r\n;\r\n;ENTRY  - AL = Character to output\r\n;EXIT   - All registers except SI and DI are preserved.\r\n;\r\nCONSOT:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tCMP\tAL,LOW 255D\r\n\tJZ\tCONSOX\t\t;Don't allow outputing FFH\r\n\tMOV\tDL,AL\r\n\tCALLOS\tC_DCIO\t\t;Direct Console I/O\r\nCONSOX:\tJMP\tPDCBAX\t\t;Pop DX,CX,BX,AX and RET\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GIODSK.ASM",
          "type": "blob",
          "size": 34.625,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tSUBTTL  GLOBAL TEMPS and DEFS\r\n\tTITLE   GIODSK - BASIC-86 Generalized I/O Disk Driver\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- ---------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT\r\n--------- --- ---- -- ---------\r\n\r\n        T. Corbett      Microsoft   for BASIC-86 Generalized I/O\r\n                        Based on code written for BASCOM-86\r\n        *\r\n\tINCLUDE\tGIO86U\r\n\r\nCPM86=0\r\n\r\n\tINCLUDE\tMSDOSU\r\n\r\n\t.SALL\r\n\t.RADIX\t10\r\n\r\n\r\n\tEXTRN\tCHRGTR:NEAR,SYNCHR:NEAR,OUTDO:NEAR\r\n\tEXTRN\tDERNMF:NEAR,DERBFM:NEAR,DERBRN:NEAR,DERFAO:NEAR,FCERR:NEAR\r\n\tEXTRN\tDERTMF:NEAR\r\n\tEXTRN\tDERFAE:NEAR,DERFNF:NEAR,DERIOE:NEAR,DERDFL:NEAR,DERFOV:NEAR\r\n\tEXTRN\tCONIA:NEAR,MAKINT:NEAR,MOVE1:NEAR,$NORMD:NEAR\r\n\tEXTRN\tDEVBOT:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tDFACLO:WORD,FAC:WORD,VALTYP:WORD\r\n\tEXTRN\tRECRD:WORD,LBUFF:WORD,PBUFF:WORD\r\n\tEXTRN\tFILNAM:WORD,FILNA2:WORD\r\nDSEG\tENDS\r\n\r\n\tASCCR=13D\t\t;Ascii carriage return\r\n\tASCCTZ=26D\t\t;END OF FILE CHARACTER\r\n\r\n;Disk Dispatch Table\r\n;\r\n\tPUBLIC\tDSKDSP\r\nDSKDSP:\r\n\tDW\t(DSKEOF)\t;test EOF for file opened to this device\r\n\tDW\t(DSKLOC)\t;LOC - sequential records / last random record\r\n\tDW\t(DSKLOF)\t;LOF - file size\r\n\tDW\t(DSKCLS)\t;perform special CLOSE functions for this device\r\n\tDW\t(FCERR)\t\t;set device width\r\n\tDW\t(DSKRND)\t;GET/PUT random record from/to this device\r\n\tDW\t(DSKOPN)\t;perform special OPEN functions for this device\r\n\tDW\t(DSKSIN)\t;input 1 byte from file opened on this device\r\n\tDW\t(DSKSOT)\t;output 1 byte to file opened on this device\r\n\tDW\t(DSKGPS)\t;POS\r\n\tDW\t(DSKGWD)\t;get device width\r\n\tDW\t(DSKSCW)\t;set device comma width\r\n\tDW\t(DSKGCW)\t;get device comma width\r\n\tDW\t(DFSTLD)\t;block input from file opened on this device\r\n\tDW\t(DEVBOT)\t;block output to file opened on this device\r\n\r\n\tSUBTTL  Misc. Disk Routines\r\n\r\n;DSKEOF - test for End-Of-File on device.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [BX] = -1 if EOF, 0 if not EOF\r\n;\r\nDSKEOF:\r\n\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_SQO\t;EOF( ) is Illegal\r\n\tJE\tER_BFM\t\t; for Sequential Output\r\nORNCHK:\r\n\tXOR\tAL,AL\r\n\tCMP\tBYTE PTR F_ORCT[SI],AL\t;zero if End of File\r\n\tJE\tWASEOF\t\t;Brif EOF\r\n\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_RND\t;If mode is Random\r\n\tJZ\tNOTEOF\t\t; then don't return true EOF\r\n\tCMP\tBYTE PTR F_BREM[SI],AL\t;Any bytes left in buffer?\r\n\tJNZ\tCHKCTZ\t\t;Yes, look for Control-Z\r\n\tCALL\t$READS\t\t;Fill the Buffer\r\n\tJMP\tSHORT ORNCHK\t; and try again...\r\nCHKCTZ:\r\n\tMOV\tBX,OFFSET DATPSC\r\n\tSUB\tBL,BYTE PTR F_BREM[SI]\t;[BX] = char offset\r\n\tCMP\tBYTE PTR DATOFS[BX+SI],LOW OFFSET ASCCTZ\t;check for EOF\r\n\tJNZ\tNOTEOF\t\t;Brif next char not EOF\r\nWASEOF:\r\n\tMOV\tBX,-1\t\t; -1 if EOF\r\n\tRET\t\r\nNOTEOF:\r\n\tXOR\tBX,BX\t\t;0 = not EOF\r\n\tRET\t\r\n\r\nER_BFM:\tJMP\tDERBFM\t\t;\"Bad File mode\"\r\n\r\n;DSKLOC - Number of Bytes in input buffer.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [BX] = result.\r\n;\r\nDSKLOC:\r\n\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_RND\r\n\tMOV\tBX,WORD PTR F_CLOC[SI]\t;Use current for Sequential\r\n\tJNE\tLOC1\r\n\tMOV\tBX,WORD PTR FD_LOG[SI]\t;Use logical for Random\r\nLOC1:\tRET\t\r\n\r\n;DSKLOF - return file size in bytes.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [Floating-Point-Accumulator] = result.\r\n;\r\nDSKLOF:\r\n\tLEA\tDX,DWORD PTR FCB_FS[SI]\t;[DX] points to file size\r\n\tMOV\tBX,OFFSET DFACLO-1\t;[BX] Target\r\n\tMOV\tBYTE PTR 0[BX],LOW 0\t;zero overflow byte\r\n\tINC\tBX\r\n\tMOV\tCH,LOW 4\r\n\tCALL\tMOVE1\t\t;Move file length to FAC\r\n\tMOV\tBYTE PTR FAC+1,CH\t;zero sign\r\n\tMOV\tWORD PTR 0[BX],CX\t;zero high bytes of FAC\r\n\tMOV\tWORD PTR 2[BX],OFFSET ((128+56)*256)\t;Initialize Exponent\r\n\tMOV\tBYTE PTR VALTYP,LOW 8\t;Dbl prec value\r\n\tJMP\t$NORMD\t\t;Normalize value\r\n;DSKGPS - return current file position.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [AH] = current file column. (0-relative)\r\n;         All other registers preserved\r\n;\r\nDSKGPS:\tMOV\tAH,BYTE PTR F_POS[SI]\t;[AH]=current column\r\n\tRET\t\r\n\r\n;DSKGWD - get device width\r\n; Exit  - [AH] = device width as set by xxxSWD\r\n;         All other registers preserved\r\n;\r\nDSKGWD:\tMOV\tAH,LOW 255D\t;disk files always have infinite width\r\n\tRET\t\r\n\r\n;DSKSCW - set device comma width\r\n; Entry - [BX] = new device comma width\r\n; Exit  - SI, DI can be changed.\r\n;         All other registers preserved\r\n;\r\nDSKSCW:\r\n\r\n;DSKGCW - get device comma width\r\n; Exit  - [BX] = device comma width as set by xxxSCW\r\n;         All other registers preserved\r\n;\r\nDSKGCW:\tRET\t\r\n\r\n\tSUBTTL  OPEN hook for Disk and all Directory handling\r\n\r\n\tEXTRN\tINIFDB:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFILMOD:WORD,FREFDB:WORD\r\nDSEG\tENDS\r\n\r\n\r\n;DSKOPN - perform any device dependent open functions.\r\n; Entry - [AL] = FILDEV = device id\r\n;                0 if default device,\r\n;                1..n for Disk A:, B:, ...\r\n;                -1..-n for non-disk devices\r\n;         [BX] = file number (0..n)\r\n;         [CX] = random record size if [FILMOD] = random\r\n;                (if [CX] = 0, use default record size)\r\n;         [DI] = device offset (2=DSKD, 4=SCRN, etc.)\r\n;         [FILMOD] = file mode\r\n;                    MD.SQI = 1 ;sequential input\r\n;                    MD.SQO = 2 ;sequential output\r\n;                    MD.RND = 3 ;random\r\n;                    MD.APP = 4 ;append\r\n;         [FILNAM] = filename\r\n;         [FILEXT] = 1..3 byte filename extension\r\n; Exit  - [SI] points to new FDB\r\n;         FDB is linked into FDB chain with all standard\r\n;         fields initialized.\r\n;         All other registers are preserved.\r\n;\r\nDSKOPN:\t\t\t\t;note: save [AL]=device ID till INIFDB\r\n\tCMP\tBYTE PTR FILMOD,LOW OFFSET MD_RND\r\n\tJNZ\tDSKOP2\t\t;branch if not OPEN RANDOM\r\n\tOR\tCX,CX\r\n\tJNZ\tDSKOP2\t\t;branch if user requested Record-Size\r\n\tMOV\tCX,OFFSET DATPSC\t;default to Bytes per Sector\r\nDSKOP2:\tPUSH\tCX\t\t;save user requested Random-Record-Size\r\n\tADD\tCX,OFFSET FD_DAT-FDBSIZ\t;add standard Disk FDB requirements\r\n\tMOV\tAH,LOW 255D\t;all file-modes are legal for Disk\r\n\tMOV\tDX,255D\t\t;[DH]=initial file column position\r\n\t\t\t\t;[DL]=initial file width\r\n\tCALL\tINIFDB\t\t;SI points to new file's FDB\r\n\tMOV\tWORD PTR FREFDB,SI\t;save pointer to FDB so FINPRT will\r\n\t\t\t\t;release it if error occurs before file\r\n\t\t\t\t;gets completely opened.\r\n\tPUSH\tSI\t\t;save FDB pointer\r\n\tLEA\tDI,DWORD PTR FCB_DV[SI]\t;DI points to filename field within FDB\r\n\tMOV\tSI,OFFSET FILNAM\r\n\tMOV\tCX,OFFSET FNAML+1\t;Moving drive,name,ext\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n REP\tMOVSB\t\t\t; to FDB's FCB\r\n\tMOV\tBYTE PTR 0[DI],CL\t;Make sure ext field is zero\r\n\tADD\tDI,OFFSET FCB_NR-FCB_EX\t;Advance to NR field\r\n\tMOV\tAX,CX\t\t;[AX]=0\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n\tSTOSW\r\n\tSTOSW\r\n\tSTOSB\t\t\t;zero random record fields\r\n\tPOP\tSI\t\t;SI points to new FDB\r\n\tPOP\tAX\t\t;[AX]=random record size\r\n\tMOV\tWORD PTR FD_SIZ[SI],AX\t;save in FDB\r\n\tCALL\tSETBUF\t\t;Set Buffer addr\r\n\tMOV\tAL,BYTE PTR FILMOD\t;[AL]=file mode\r\n\tCMP\tAL,LOW OFFSET MD_APP\r\n\tJNZ\tNTOAPP\t\t;Brif not open append\r\n\tCALL\tCHKFOP\t\t;check for file already open\r\nNTOAPP:\r\n\tLEA\tDX,DWORD PTR F_FCB[SI]\t;[DX] = FCB for DOS calls\r\n\tCMP\tAL,LOW OFFSET MD_SQO\r\n\tJNZ\tOPNFIL\t\t;Brif not sequential output\r\n\tCALL\tCHKFOP\t\t;must be unique\r\n\tCALLOS\tC_DELE\t\t;Delete file if exists\r\nMAKFIL:\r\n\tCALLOS\tC_MAKE\t\t;Create file\r\n\tINC\tAL\t\t;Too many files?\r\n\tJNZ\tOPNSET\t\t;No, continue\r\n\tJMP\tDERTMF\t\t;\"Too many files\"\r\nOPNFIL:\r\n\tCALLOS\tC_OPEN\t\t;Try OPEN\r\n\tINC\tAL\r\n\tJNZ\tOPNSET\t\t;Brif found\r\n\tMOV\tAL,BYTE PTR FILMOD\t;Mode\r\n\tCMP\tAL,LOW OFFSET MD_APP\r\n\tJNZ\tNTAPNF\t\t;Brif not append\r\n\tMOV\tAL,LOW OFFSET MD_SQO\t; else change to seq output\r\n\tJMP\tSHORT MAKFIL\r\nNTAPNF:\r\n\tCMP\tAL,LOW OFFSET MD_RND\t;If not Random\r\n\tJNZ\tER_FNF\t\t; then File not found error\r\n\tJMP\tSHORT MAKFIL\t;and create new\r\nER_FNF:\r\n\tJMP\tDERFNF\t\t;\"File not found\"\r\nOPNSET:\r\n\tMOV\tWORD PTR FCB_RC[SI],128\t;Record len = 128\r\n\tXOR\tCX,CX\r\n\tMOV\tWORD PTR F_CLOC[SI],CX\t;Clear curloc\r\n\tMOV\tWORD PTR F_CLOC+2[SI],CX\t;Clear numloc\r\n\tMOV\tAL,BYTE PTR FILMOD\r\n\tCMP\tAL,LOW OFFSET MD_RND\r\n\tJZ\tRNDFIN\t\t;Brif finish random open\r\n\tCMP\tAL,LOW OFFSET MD_APP\r\n\tJZ\tAPPFIN\t\t;Brif finish append open\r\n\tCMP\tAL,LOW OFFSET MD_SQI\r\n\tJNZ\tOPNFIN\t\t;If not input get text pointer/exit\r\n\tCALL\t$READS\t\t;Read 1st data block into buffer\r\nOPNFIN:\tMOV\tWORD PTR FREFDB,0\t;file is completely open.\r\n\t\t\t\t;FINPRT won't release FDB.\r\n\tRET\t\r\nRNDFIN:\r\n\tLEA\tDI,DWORD PTR FD_PHY[SI]\t;zero FD.PHY, FD.LOG, FD.OPS, sector buffer\r\n\tMOV\tCX,OFFSET (FD_DAT-FD_PHY)\t;number of bytes to be cleared\r\n\tXOR\tAX,AX\t\t;zeros\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n REP\tSTOSB\t\t\t;zero data buffer and variable cells\r\n\tJMP\tSHORT OPNFIN\r\n\r\n; Append - Seek to eof, read a sector, find byte eof,\r\n;          correct no. of bytes remaining, finish up\r\n;          by changing file mode to sequential output.\r\nAPPFIN:\r\n\tCMP\tWORD PTR FCB_FS[SI],CX\t;Test for empty file\r\n\tJNZ\tNTZRF1\t\t;Brif file not empty\r\n\tCMP\tWORD PTR FCB_FS+2[SI],CX\r\n\tJNZ\tNTZRF1\r\n\tMOV\tBYTE PTR F_MODE[SI],LOW OFFSET MD_SQO\t;Change mode to Seq output\r\n\tJMP\tSHORT OPNFIN\t; and exit\r\nNTZRF1:\r\n\tLEA\tDI,DWORD PTR FCB_RN[SI]\t;DI points to random record# field\r\n\tPUSH\tSI\t\t;Save FDB pointer\r\n\tADD\tSI,OFFSET FCB_FS\t;Move to File Size\r\n\tTEST\tBYTE PTR 0[SI],LOW 127D\t;See if multiple of 128\r\n\tCLD\t\t\t;Set Post-Inc mode for next 10 lines\r\n\tPUSHF\t\t\t;and remember\r\n\tLODSB\t\t\t;Get low order of size\r\n\tADD\tAL,AL\t\t;Rotate hi bit into carry\r\n\tLODSW\t\t\t;Get middle word\r\n\tADC\tAX,AX\t\t;carry in, hi bit out\r\n\tSTOSW\t\t\t;Save low word of rec no.\r\n\tLODSB\t\t\t;Get high byte\r\n\tMOV\tAH,LOW 0\t;Clear hi byte of rec no.\r\n\tADC\tAX,AX\t\t;consider carry\r\n\tSTOSW\t\t\t;Store hi word of rec no.\r\n\tPOPF\t\t\t;get record flag\r\n\tPOP\tSI\r\n\tJNZ\tNOMTRC\t\t;Brif record not empty\r\n\tCALL\tBAKURN\t\t; else backup so can align\r\nNOMTRC:\r\n\tCALL\t$READS\t\t;read a sector\r\n\tCALL\tBAKURN\t\t;back up 1 record\r\n\tXOR\tDX,DX\t\t;clear count of chars in buff\r\nREDEOF:\r\n\tCALL\tDSKINP\t\t;read until EOF\r\n\tJB\tSETSQM\t\t;Brif physical EOF\r\n\tCMP\tAL,LOW OFFSET ASCCTZ\t;check for logical eof (ctl Z)\r\n\tJZ\tSETSQO\t\t;Brif found eof\r\n\tINC\tDX\r\n\tJMP\tSHORT REDEOF\r\nSETSQM:\r\n\tXOR\tDX,DX\t\t;zero count since next sector\r\n\tCALL\tBAKURN\t\t;backup since read to far\r\nSETSQO:\r\n\tMOV\tBYTE PTR F_MODE[SI],LOW OFFSET MD_SQO\t;now we're Seq output\r\n\tLEA\tDI,DWORD PTR F_CLOC[SI]\r\n\tXOR\tAX,AX\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n\tSTOSW\t\t\t;zero curloc since empty\r\n\tMOV\tBYTE PTR 0[DI],DL\t;store no. of bytes left\r\n\tMOV\tBYTE PTR F_POS[SI],AL\t;zero print position\r\n\tJMP\tSHORT OPNFIN\r\nBAKURN:\r\n\tSUB\tWORD PTR FCB_RN[SI],1\t;Random rec no. -1\r\n\tJAE\tBAKRET\t\t;Brif no underflow\r\n\tDEC\tWORD PTR FCB_RN+2[SI]\t;hi word -1\r\nBAKRET:\tRET\t\r\n\r\n\tSUBTTL  CLOSE (CLSFIL) hook for Disk files\r\n\r\n;DSKCLS - perform any device dependent close functions.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - All registers used.\r\n;         This routine is called before BASIC releases the\r\n;         file-data-block associated with this file.\r\n;\r\nDSKCLS:\r\n\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_SQO\r\n\tJNE\tNOFORC\t\t;Don't dump buffer unless Seq Output\r\n\tMOV\tAL,LOW OFFSET ASCCTZ\r\n\tCALL\tFILOU4\t\t;Write EOF char\r\n\tCMP\tBYTE PTR F_ORCT[SI],LOW 0\r\n\tJE\tNOFORC\t\t;Brif buffer flushed\r\n\tCALL\t$WRITS\t\t;Flush the buffer\r\nNOFORC:\r\n\tCALL\tSETBUF\t\t;Set DMA addr\r\n\tLEA\tDX,DWORD PTR F_FCB[SI]\t;[DX] = FCB\r\n\tCALLOS\tC_CLOS\t\t;Close the file\r\n\tRET\t\r\n\r\n\tSUBTTL Disk Sequential Input\r\n\r\n;DSKSIN - Sequential Input.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [AL] = next byte from file,\r\n;         carry set if EOF.\r\n;         All other registers preserved\r\n;\r\nDSKSIN:\tCALL\tDSKINP\t\t;get next byte from file\r\n\tJB\tDSYEOF\t\t;branch if End-Of-File\r\n\tCMP\tAL,LOW OFFSET ASCCTZ\t;check for CTL-Z\r\n\tJNE\tDSNEOF\t\t;branch if not\r\n\tCMP\tBYTE PTR F_CODE[SI],LOW OFFSET FC_BIN\r\n\tJE\tDSNEOF\t\t;CTL-Z is not EOF for Binary files\r\nDSYEOF:\tSTC\t\t\t;set carry indicating EOF\r\n\tRET\t\r\nDSNEOF:\tOR\tAL,AL\t\t;clear carry (no eof)\r\n\tRET\t\r\n\r\n;DSKINP - get next byte from file [SI]\r\n; Exit  - Carry set if EOF, else [AL]=next byte from file\r\n;         All other registers preserved\r\n;\r\nDSKINP:\r\n\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_RND\r\n\tJNE\tSINP1\t\t;Brif not Random\r\n\tJMP\tSHORT SINP50\t;Do Serial input from random\r\nSINP1:\r\n\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_SQO\t;If trying input on output file\r\n\tJE\tFILLS1\t\t; then give \"Input past end\"\r\n\tCMP\tBYTE PTR F_BREM[SI],LOW 0\r\n\tJE\tFILLSQ\t\t;If buffer empty, get another\r\n\tPUSH\tBX\r\n\tXOR\tBX,BX\r\n\tMOV\tBL,BYTE PTR F_ORCT[SI]\r\n\tSUB\tBL,BYTE PTR F_BREM[SI]\r\n\tDEC\tBYTE PTR F_BREM[SI]\t;number left -1\r\n\tMOV\tAL,BYTE PTR DATOFS[BX+SI]\t;Get the character\r\n\tPOP\tBX\r\n\tOR\tAL,AL\t\t;Clear carry\r\n\tRET\t\r\nFILLSQ:\r\n\tCMP\tBYTE PTR F_ORCT[SI],LOW 0\r\n\tJE\tFILLS1\t\t;Brif EOF\r\n\tCALL\t$READS\t\t;read next sector\r\n\tJNE\tSINP1\t\t;If not EOF try again\r\nFILLS1:\r\n\tSTC\t\t\t;Return with carry\r\n\tMOV\tAL,LOW OFFSET ASCCTZ\t; and EOF character\r\n\tRET\t\r\n\r\nSINP50:\t\t\t\t;Serial Input from Random File\r\n\tPUSH\tBX\r\n\tCALL\tFOVCHK\t\t;Field overflow check\r\n\tMOV\tAL,BYTE PTR FD_DAT-1[BX+SI]\t;Get character\r\n\tCLC\t\r\n\tPOP\tBX\r\n\tRET\t\r\nFOVCHK:\r\n\tMOV\tBX,WORD PTR FD_OPS[SI]\t;Get current posn\r\n\tCMP\tBX,WORD PTR FD_SIZ[SI]\t;check for end of field\r\n\tJE\tER_FOV\t\t;Brif field overflow\r\n\tINC\tBX\t\t;posn +1\r\n\tMOV\tWORD PTR FD_OPS[SI],BX\t;store new posn\r\n\tRET\t\r\nER_FOV:\r\n\tJMP\tDERFOV\t\t;\"Field Overflow\"\r\n\r\n\tSUBTTL Disk Sequential Output\r\n\r\n;DSKSOT - Sequential Output.\r\n; Entry - SI points to File-Data-Block.\r\n;         [AL] = byte to be output.\r\n; Exit  - All registers preserved.\r\n;\r\nDSKSOT:\r\n\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_SQI\t;If input then must be echoing\r\n\tJZ\tFILOUX\t\t; or \"Extra ignored\", so toss it\r\n\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_RND\r\n\tJNZ\tFILOU4\t\t;branch if sequential access\r\n\tPUSH\tBX\t\t;Do Serial output to random\r\n\tCALL\tFOVCHK\t\t;check for FIELD overflow\r\n\tMOV\tBYTE PTR FD_DAT-1[BX+SI],AL\t;store character\r\n\tPOP\tBX\r\n\tJMP\tSHORT SOUTPS\t;Update posn and exit\r\nFILOU4:\r\n\tCMP\tBYTE PTR F_ORCT[SI],LOW OFFSET DATPSC\r\n\tJNE\tSOUT2\t\t;Brif not at end of sector\r\n\tCALL\t$WRITS\t\t;Write previous sector\r\nSOUT2:\r\n\tPUSH\tBX\r\n\tXOR\tBX,BX\r\n\tMOV\tBL,BYTE PTR F_ORCT[SI]\t;[BX] = Buffer offset\r\n\tMOV\tBYTE PTR DATOFS[BX+SI],AL\t;store char\r\n\tPOP\tBX\r\n\tINC\tBYTE PTR F_ORCT[SI]\r\nSOUTPS:\r\n\tCMP\tAL,LOW OFFSET ASCCR\r\n\tJNE\tSOUT3\r\n\tMOV\tBYTE PTR F_POS[SI],LOW 0\t;reset posn on CR\r\nFILOUX:\r\n\tRET\t\r\n\r\nSOUT3:\r\n\tCMP\tAL,LOW \" \"\r\n\tCMC\t\r\n\tADC\tBYTE PTR F_POS[SI],LOW 0\t;posn +1  if printable char\r\n\tRET\t\r\n\r\n\r\n\tSUBTTL GET and PUT for Disk Files\r\n\r\n\tPGFLAG=1\t\t;On = PUT, Off = GET\r\n\tRELFLG=2\t\t;On = Relative, Off = Sequential\r\n\tDIRFLG=4\t\t;On = Write, Off = Read\r\n\r\nER_BRN:\tJMP\tDERBRN\t\t;bad record number error\r\nER_FC:\tJMP\tFCERR\t\t;function call error\r\n\r\n;DSKRND - perform random I/O.\r\n; Entry  - [AL] = function to be performed:\r\n;                 0: get next record\r\n;                 1: put next record\r\n;                 2: get record [DX] (1-relative)\r\n;                 3: put record [DX] (1-relative)\r\n;          [SI] points to File-Data-Block\r\n; Exit   - All registers are used.\r\n;\r\nDSKRND:\r\n\tTEST\tAL,LOW OFFSET RELFLG\r\n\tJNZ\tRAND1\t\t;Brif not relative I/O\r\n\tMOV\tDX,WORD PTR FD_LOG[SI]\t;[DX] = current logical record\r\n\tINC\tDX\t\t;Logical +1\r\n\tJMP\tSHORT RAND2\r\nRAND1:\r\n\tOR\tDX,DX\t\t;See if ok\r\n\tJLE\tER_BRN\t\t;Error if record number .LEQ. 0\r\nRAND2:\r\n\tMOV\tWORD PTR FD_LOG[SI],DX\t;Store next logical\r\n\tDEC\tDX\t\t;[DX] = current logical\r\n\tMOV\tWORD PTR FD_OPS[SI],0\t;Clear output posn\r\n\tMOV\tBX,WORD PTR FD_SIZ[SI]\t;[BX] = logical record length\r\n\tPUSH\tBX\r\n\tCMP\tBX,OFFSET DATPSC\t;Logical = Physical?\r\n\tJE\tRAND3\t\t;Brif so\r\n\tXCHG\tAX,BX\t\t;Save flags\r\n\tMUL\tDX\t\t;Logical * physical (byte off)\r\n\tXCHG\tAX,BX\t\t;[DX,BX] = result\r\n\tADD\tBX,BX\t\t;Offset *2 (for /128)\r\n\tADC\tDX,DX\t\t;consider overflow\r\n\tOR\tDH,DH\r\n\tJNZ\tER_FC\t\t;Brif too big\r\n\tMOV\tDH,DL\r\n\tMOV\tDL,BH\t\t;[DX] = physical record no.\r\n\tSHR\tBL,1\r\n\tXOR\tBH,BH\t\t;[BX] = offset into physical rec\r\n\tJMP\tSHORT RAND4\r\nRAND3:\r\n\tXOR\tBX,BX\t\t;[BX] (offset = 0)\r\n\r\n; [DX] = physical record number\r\n; [BX] = offset into physical record\r\nRAND4:\r\n\tMOV\tWORD PTR RECRD,DX\t;Save record no.\r\n\tLEA\tCX,DWORD PTR FD_DAT[SI]\t;[CX] = Field buffer addr\r\n\tMOV\tWORD PTR LBUFF,CX\t;Save Logical buffer addr\r\n\tPOP\tDX\t\t;Get record length\r\n\r\n; [DX] = bytes left to transfer (initially record length)\r\n; [BX] = offset into current record\r\nNXTOPD:\r\n\tLEA\tCX,DWORD PTR DATOFS[SI]\t;[CX] = Physical buffer addr\r\n\tADD\tCX,BX\t\t;       + offset\r\n\tMOV\tWORD PTR PBUFF,CX\t;Save physical offset\r\n\tMOV\tCX,OFFSET DATPSC\r\n\tSUB\tCX,BX\t\t;[CX] = bytes left in buffer\r\n\tCMP\tCX,DX\t\t;want smaller of bufl, recl\r\n\tJB\tDATMOF\t\t;[CX] = left in buffer\r\n\tMOV\tCX,DX\t\t;[CX] = left in record\r\nDATMOF:\r\n\tTEST\tAL,LOW OFFSET PGFLAG\r\n\tJZ\tFIVDRD\t\t;Brif read (GET)\r\n\tCMP\tCX,OFFSET DATPSC\r\n\tJAE\tNOFVRD\t\t;Brif writing entire sector\r\n\tCALL\tGETSUB\t\t; else read current sector\r\nNOFVRD:\r\n\tPUSH\tSI\r\n\tPUSH\tCX\r\n\tMOV\tSI,WORD PTR LBUFF\r\n\tMOV\tDI,WORD PTR PBUFF\r\n\tSHR\tCX,1\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n REP\tMOVSW\r\n\tJNB\tEVENLP\r\n\tMOVSB\r\nEVENLP:\r\n\tPOP\tCX\r\n\tPOP\tSI\r\n\tCALL\tPUTSUB\t\t;Write thru to current sector\r\n\tJMP\tSHORT NXFVBF\r\n\r\nFIVDRD:\r\n\tCALL\tGETSUB\t\t;Read current record\r\n\tPUSH\tSI\r\n\tPUSH\tCX\r\n\tMOV\tSI,WORD PTR PBUFF\r\n\tMOV\tDI,WORD PTR LBUFF\r\n\tSHR\tCX,1\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n REP\tMOVSW\r\n\tJNB\tEVENPL\r\n\tMOVSB\r\nEVENPL:\r\n\tPOP\tCX\r\n\tPOP\tSI\r\nNXFVBF:\r\n\tINC\tWORD PTR RECRD\t;current record +1\r\n\tADD\tWORD PTR LBUFF,CX\t;logical offset +length\r\n\tSUB\tDX,CX\t\t;offset - bytes transfered\r\n\tXOR\tBX,BX\t\t;zero buffer offset\r\n\tOR\tDX,DX\t\t;More to transfer?\r\n\tJNZ\tNXTOPD\t\t; then continue\r\n\tRET\t\r\n\r\n; Sector I/O routines for Random\r\n\r\nPUTSUB:\r\n\tOR\tAL,LOW OFFSET DIRFLG\t;Set write flag\r\n\tJMP\tSHORT PGSUB1\r\nGETSUB:\r\n\tAND\tAL,LOW OFFSET 255-DIRFLG\t;Clear write flag (read)\r\nPGSUB1:\r\n\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tMOV\tBX,WORD PTR RECRD\t;Get record no.\r\n\tINC\tBX\r\n\tCMP\tBX,WORD PTR FD_PHY[SI]\t;current record in buffer?\r\n\tJNE\tNTREDS\t\t;Brif not\r\n\tTEST\tAL,LOW OFFSET DIRFLG\t;Was it read?\r\n\tJZ\tPGRET\t\t; then got it\r\nNTREDS:\r\n\tDEC\tBX\r\n\tMOV\tWORD PTR F_CLOC[SI],BX\t;Set CURLOC to physical rec.\r\n\tMOV\tBYTE PTR F_ORCT[SI],LOW OFFSET DATPSC\r\n\tMOV\tBYTE PTR F_BREM[SI],LOW OFFSET DATPSC\r\n\tMOV\tWORD PTR FCB_RN[SI],BX\t;Set record number\r\n\tMOV\tWORD PTR FCB_RN+2[SI],0\r\n\tTEST\tAL,LOW OFFSET DIRFLG\r\n\tJZ\tGET1\t\t;Brif read\r\n\tCALL\t$WRITS\t\t; else Write it\r\n\tJMP\tSHORT PGRET\r\nGET1:\r\n\tCALL\t$READS\t\t;Read it\r\nPGRET:\tPOP\tDX\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n\tSUBTTL Primitive Disk sector I/O routines\r\n\r\n;$READS - Read sector from file\r\n; Entry - SI points to FDB\r\n; Exit  - [AL] = 0 if no error.  FLAGS used.\r\n;         All other registers are preserved\r\n;\r\n$READS:\r\n\tPUSH\tCX\r\n\tPUSH\tDI\r\n\tINC\tWORD PTR F_CLOC[SI]\t;Logical record +1\r\n\tMOV\tCX,OFFSET DATPSC/2\r\n\tXOR\tAX,AX\r\n\tLEA\tDI,DWORD PTR DATOFS[SI]\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n REP\tSTOSW\t\t\t;zero physical buffer\r\n\tCALL\tSETBUF\t\t;Set DMA\r\n\tMOV\tAH,LOW OFFSET C_RNDR\r\n\tCALL\tACCFIL\t\t;Read random\r\n\tOR\tAL,AL\r\n\tMOV\tAL,LOW 0\t;Len = 0 for EOF\r\n\tJNZ\tREAD1\r\n\tMOV\tAL,LOW OFFSET DATPSC\t; else len = sector size\r\nREAD1:\r\n\tMOV\tBYTE PTR F_ORCT[SI],AL\t;Clear offset into buffer\r\n\tMOV\tBYTE PTR F_BREM[SI],AL\t;Set number of bytes left\r\n\tOR\tAL,AL\t\t;zero if EOF\r\n\tPOP\tDI\r\n\tPOP\tCX\r\n\tRET\t\r\n\r\n;$WRITS - Write sector to file\r\n; Entry - SI points to FDB\r\n; Exit  - All registers preserved\r\n;\r\n$WRITS:\r\n\tPUSH\tAX\r\n\tMOV\tBYTE PTR F_ORCT[SI],LOW 0\t;Clear buffer offset\r\n\tCALL\tSETBUF\t\t;Set DMA\r\n\tMOV\tAH,LOW OFFSET C_RNDW\r\n\tCALL\tACCFIL\t\t;Write Random\r\n\tCMP\tAL,LOW 255D\r\n\tJZ\tER_TMF\t\t;Brif \"Too many Files\"\r\n\tDEC\tAL\r\n\tJZ\tER_IOE\t\t;Brif error extending file\r\n\tDEC\tAL\r\n\tJNZ\tWRITE1\r\n\tMOV\tBYTE PTR F_MODE[SI],LOW OFFSET MD_SQI\t;So CLOSE won't give same error\r\n\t\t\t\t;when it tries to output CTL-Z EOF\r\n\tJMP\tDERDFL\t\t;\"Disk Full\"\r\nWRITE1:\r\n\tINC\tWORD PTR F_CLOC[SI]\t;Logical record +1\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\nER_TMF:\tJMP\tDERTMF\t\t;\"Too many Files\"\r\nER_IOE:\tJMP\tDERIOE\t\t;\"Device I/O error\"\r\n\r\n;Set OS I/O buffer address to DATOFS(.SI)\r\n;\r\nSETBUF:\r\n\tPUSH\tDX\r\n\tLEA\tDX,DWORD PTR DATOFS[SI]\t;[DX] = Data buffer addr\r\n\tCALLOS\tC_BUFF\r\n\tPOP\tDX\r\n\tRET\t\r\n\r\nACCFIL:\r\n\tPUSH\tDX\r\n\tLEA\tDX,DWORD PTR F_FCB[SI]\t;[DX] = FCB\r\n\tCALLOS\t\t\t;Do OS I/O Op\r\n\tINC\tWORD PTR FCB_RN[SI]\t;Record no. +1\r\n\tJNZ\tACCFL1\r\n\tINC\tWORD PTR FCB_RN+2[SI]\t;High order +1\r\nACCFL1:\r\n\tCMP\tAH,LOW OFFSET C_RNDW\t;Was it Random Write?\r\n\tJNE\tACCFL2\t\t;Brif not\r\n\tOR\tAL,AL\t\t; else map into 1.4 errors\r\n\tJZ\tACCRET\t\t;Brif no errors\r\n\tCMP\tAL,LOW 5\r\n\tJE\tER_TMF\t\t;5 - Too many files\r\n\tCMP\tAL,LOW 3\r\n\tMOV\tAL,LOW 1\t;Map 5 to 1\r\n\tJE\tACCRET\r\n\tINC\tAL\t\t; else Disk full\r\n\tJMP\tSHORT ACCRET\r\nACCFL2:\r\n\tCMP\tAL,LOW 3\t;Partial sector read?\r\n\tJNE\tACCRET\t\t;Brif not\r\n\tXOR\tAL,AL\t\t;Map 3 to 0 (no error)\r\nACCRET:\r\n\tPOP\tDX\r\n\tRET\t\r\n\r\n\tSUBTTL CHKFOP - Check for file already OPEN\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFILTAB:WORD,STKLOW:WORD\r\nDSEG\tENDS\r\n\r\n; Entry: SI points to FDB in question\r\n; Exit:  Control returns to DERFAO if file is open\r\n; Uses:  CX,DI\r\n;\r\nCHKFOP:\r\n\tPUSH\tAX\r\n\tCMP\tBYTE PTR FCB_DV[SI],LOW 0\t;Default Drive?\r\n\tJNE\tNTCRDV\r\n\tCALLOS\tC_GDRV\r\n\tINC\tAL\t\t;Convert A: to 1.. etc.\r\n\tMOV\tBYTE PTR FCB_DV[SI],AL\t;Store real drive no.\r\nNTCRDV:\r\n\tMOV\tDI,WORD PTR FILTAB\t;Start with first FDB in chain\r\nCHKNFL:\r\n\tCMP\tDI,WORD PTR STKLOW\r\n\tJE\tCHKFLX\t\t;branch if at end of FDB chain\r\n\tCMP\tSI,DI\r\n\tJE\tIGNTFL\t\t;branch if same as FDB in question\r\n\tPUSH\tSI\r\n\tPUSH\tDI\r\n\tADD\tSI,OFFSET F_FCB\r\n\tADD\tDI,OFFSET F_FCB\r\n\tMOV\tCX,OFFSET FNAML+1\r\n;compare filenames, mapping lower case to upper case\r\nCMPLOP:\r\n\tMOV\tAL,BYTE PTR 0[SI]\t;get char from filename1\r\n\tCALL\tMAKUPC\t\t;[AL]=uppercase([AL])\r\n\tMOV\tAH,AL\r\n\tMOV\tAL,BYTE PTR 0[DI]\t;get char from filename2\r\n\tCALL\tMAKUPC\t\t;[AL]=uppercase([AL])\r\n\tCMP\tAL,AH\r\n\tJNE\tNTSAME\t\t;branch if not the same filename\r\n\tINC\tSI\t\t;bump filename1 pointer\r\n\tINC\tDI\t\t;bump filename2 pointer\r\n\tLOOP\tCMPLOP\t\t;compare all characters in filenames\r\n\tJMP\tDERFAO\t\t;error, file already open\r\nNTSAME:\tPOP\tDI\r\n\tPOP\tSI\r\nIGNTFL:\r\n\tMOV\tDI,WORD PTR F_NEXT[DI]\t;get next FDB in chain\r\n\tJMP\tSHORT CHKNFL\r\nCHKFLX:\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\nMAKUPC:\r\n\tCMP\tAL,LOW \"a\"\r\n\tJB\tNOTLC\t\t;branch if not a..z\r\n\tCMP\tAL,LOW OFFSET \"z\"+1\r\n\tJNB\tNOTLC\t\t;branch if not a..z\r\n\tAND\tAL,LOW 337O\t;map a..z to A..Z\r\nNOTLC:\r\n\tRET\t\r\n\r\n\tSUBTTL  DFSTLD - Fast Binary Program Load (from DISK)\r\n\r\n\tPUBLIC\tDFSTLD\r\n\tEXTRN\tOUTLOD:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFRETOP:WORD,PTRFIL:WORD\r\nDSEG\tENDS\r\n\r\n;DFSTLD - read block of memory from Disk\r\n; Entry - [BX] = offset of destination\r\n;         [CX] = maximum number of bytes to read\r\n;         [DX] = data segment of destinanation\r\n;         PTRFIL points to FDB of file to be loaded\r\n; Exit  - BX points 1 byte beyond last byte read\r\n;         Carry set reached end-of-file before CX bytes were read\r\n;\r\nDFSTLD:\r\n\tPUSH\tBX\t\t;save start adr\r\n\tPUSH\tCX\t\t;save max byte count\r\n\tPUSH\tDS\t\t;save BASIC's Data Segment adr\r\n\tPUSH\tBX\t\t;save start adr\r\n\tPUSH\tDX\t\t;save block read Data Segment adr\r\n\tMOV\tSI,WORD PTR PTRFIL\t;SI points to current FDB\r\n\tMOV\tAL,BYTE PTR F_ORCT[SI]\r\n\tSUB\tAL,BYTE PTR F_BREM[SI]\t;[AL]=# bytes read so far\r\n\tMOV\tBYTE PTR FCB_RN[SI],AL\t;set next rec #\r\n\tMOV\tWORD PTR FCB_RC[SI],1\t;Set File logical record size = 1 byte\r\n\tPOP\tDS\t\t;[DS]=segment adr of block read\r\n\tPOP\tDX\t\t;[DX]=start adr\r\n\tCALLOS\tC_BUFF\t\t;Set DMA to TXTTAB\r\n\tPOP\tDS\t\t;restore BASIC's data segment adr\r\n\tLEA\tDX,DWORD PTR F_FCB[SI]\t;FCB\r\n\tPOP\tCX\t\t;[CX]=max number of bytes to read\r\n\tCALLOS\tC_RBR\t\t;Load the Program!\r\n\tPOP\tBX\t\t;BX points to start of load\r\n\tADD\tBX,CX\t\t;BX points 1 byte beyond last byte read\r\n\tCMP\tAL,LOW 1\r\n\tCMC\t\t\t;set carry if [AL] exceeds 1 (EOF)\r\n\tRET\t\r\n\r\n\tSUBTTL  PROSAV - Protected SAVE\r\n\tPUBLIC\tPROSAV,CMPFBC\r\n\tEXTRN\tSCCPTR:NEAR,GTMPRT:NEAR,BINPSV:NEAR,$EXPCN:NEAR,$LOGP:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tTXTTAB:WORD,VARTAB:WORD,CURLIN:WORD,PROFLG:WORD,TEMP:WORD\r\nDSEG\tENDS\r\n\r\nPROSAV:\tCALL\tCHRGTR\t\t;skip \"P\"\r\n\tMOV\tWORD PTR TEMP,BX\t;Save text pointer\r\n\tCALL\tSCCPTR\t\t;Get rid of GOTO pointers\r\n\tCALL\tPENCOD\t\t;Encode binary\r\n\tMOV\tAL,LOW 254D\t;ID byte for Protected files\r\n\tCALL\tBINPSV\t\t;Do the SAVE\r\n\tCALL\tPDECOD\t\t;Decode binary\r\n\tJMP\tGTMPRT\t\t;return to NEWSTT\r\n\r\nGETFSZ:\tMOV\tBX,OFFSET FD_SIZ\t;Point to record size\r\n\tJMP\tSHORT GETFP1\t;Continue\r\nGETFPS:\tMOV\tBX,OFFSET FD_OPS\t;Point to output position\r\nGETFP1:\tADD\tBX,CX\t\t;Add offset into buffer\r\n\tMOV\tDX,WORD PTR 0[BX]\t;Get value\r\n\tRET\t\r\n\r\nCMPFBC:\tMOV\tCX,BX\t\t;Copy file data block into [CX]\r\nCMPFPS:\tCALL\tGETFPS\t\t;Get present posit\r\n\tPUSH\tDX\t\t;Save it\r\n\tCALL\tGETFSZ\t\t;Get file size\r\n\tMOV\tBX,DX\t\t;into [BX]\r\n\tPOP\tDX\t\t;Get back posit\r\n\tCMP\tBX,DX\t\t;See if were at end\r\nRET12:\tRET\t\r\n\r\n\tN1=11D\t\t\t;Number of bytes to use from ATNCON\r\n\tN2=13D\t\t\t;Number of bytes to use from SINCON\r\n\r\n\tPUBLIC\tPENCOD\r\nPENCOD:\tMOV\tCX,OFFSET N1+N2*256D\t;Initialize both counters\r\n\tMOV\tBX,WORD PTR TXTTAB\t;Starting point\r\n\tMOV\tDX,BX\t\t;Into [DX]\r\nENCDBL:\tMOV\tBX,WORD PTR VARTAB\t;At end?\r\n\tCMP\tBX,DX\t\t;Test\r\n\tJZ\tRET12\t\t;Yes\r\n\tMOV\tBX,OFFSET $EXPCN\r\n\tMOV\tAL,CL\t\t;Use [CL] to index into it\r\n\tCBW\t\r\n\tADD\tBX,AX\r\n\tMOV\tSI,DX\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n\tLODSB\t\t\t;[AL]=byte from program\r\n\tSUB\tAL,CH\t\t;Subtract counter for no reason\r\n\tXOR\tAL,BYTE PTR CS:0[BX]\t;XOR entry\r\n\tPUSH\tAX\t\t;Save result\r\n\tMOV\tBX,OFFSET $LOGP\r\n\tMOV\tAL,CH\r\n\tCBW\t\r\n\tADD\tBX,AX\r\n\tPOP\tAX\t\t;Get back current byte\r\n\tXOR\tAL,BYTE PTR CS:0[BX]\t;XOR on this one too\r\n\tADD\tAL,CL\t\t;Add counter for randomness\r\n\tMOV\tDI,DX\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n\tSTOSB\t\t\t;store back in program\r\n\tINC\tDX\t\t;Incrment pointer\r\n\tDEC\tCL\t\t;decrment first table index\r\n\tJNZ\tCNTZER\t\t;Still non-Zero\r\n\tMOV\tCL,LOW OFFSET N1\t;Re-initialize counter 1\r\nCNTZER:\tDEC\tCH\t\t;dedecrement counter-2\r\n\tJNZ\tENCDBL\t\t;Still non-zero, go for more\r\n\tMOV\tCH,LOW OFFSET N2\t;Re-initialize counter 2\r\n\tJMP\tSHORT ENCDBL\t;Keep going until done\r\n\tPUBLIC\tPROLOD\r\nPROLOD:\r\nPDECOD:\tMOV\tCX,OFFSET N1+N2*256\t;Initialize both counters\r\n\tMOV\tBX,WORD PTR TXTTAB\t;Starting point\r\n\tMOV\tDX,BX\t\t;Into [D,E]\r\nDECDBL:\tMOV\tBX,WORD PTR VARTAB\t;At end?\r\n\tCMP\tBX,DX\t\t;Test\r\n\tJZ\tRET12\t\t;Yes\r\n\tMOV\tBX,OFFSET $LOGP\r\n\tMOV\tAL,CH\r\n\tCBW\t\r\n\tADD\tBX,AX\r\n\tMOV\tSI,DX\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n\tLODSB\t\t\t;[AL]=byte from program\r\n\tSUB\tAL,CL\t\t;Subtract counter for randomness\r\n\tXOR\tAL,BYTE PTR CS:0[BX]\t;XOR on this one too\r\n\tPUSH\tAX\t\t;Save result\r\n\tMOV\tBX,OFFSET $EXPCN\r\n\tMOV\tAL,CL\t\t;Use [CL] to index into it\r\n\tCBW\t\r\n\tADD\tBX,AX\r\n\tPOP\tAX\t\t;Get back current byte\r\n\tXOR\tAL,BYTE PTR CS:0[BX]\t;XOR entry\r\n\tADD\tAL,CH\t\t;Add counter for no reason\r\n\tMOV\tDI,DX\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n\tSTOSB\t\t\t;store [AL] back in program\r\n\tINC\tDX\t\t;Increment pointer\r\n\tDEC\tCL\t\t;decrment first table index\r\n\tJNZ\tCNTZR2\t\t;Still non-Zero\r\n\tMOV\tCL,LOW OFFSET N1\t;Re-initialize counter 1\r\nCNTZR2:\tDEC\tCH\r\n\tJNZ\tDECDBL\t\t;Decrement counter-2, Still non-zero, go for more\r\n\tMOV\tCH,LOW OFFSET N2\t;Re-initialize counter 2\r\n\tJMP\tSHORT DECDBL\t;Keep going until done\r\n\r\n\tPUBLIC\tPROCHK,PRODIR\r\nPRODIR:\tPUSH\tBX\t\t;Save [H,L]\r\n\tMOV\tBX,WORD PTR CURLIN\t;Get current line #\r\n\tINC\tBX\t\t;Direct? (if BX=0, direct)\r\n\tPOP\tBX\t\t;Restore [H,L]\r\n\tJZ\tPROCHK\r\n\tRET\t\r\n\r\nPROCHK:\tPUSHF\t\t\t;Save flags\r\n\tMOV\tAL,BYTE PTR PROFLG\t;Is this a protected file?\r\n\tOR\tAL,AL\t\t;Set CC's\r\n\tJNZ\tFCERRA\t\t;Yes, give error\r\n\tPOPF\t\t\t;Restore flags\r\n\tRET\t\r\n\r\nFCERRA:\tJMP\tFCERR\r\n\tPAGE\t\r\n\tSUBTTL  KILL, FILES, NAME commands\r\n\r\n\tPUBLIC\tFILES,KILL,NAME\r\n\tEXTRN\tFRMEVL:NEAR,FRESTR:NEAR,CRDO:NEAR,POLKEY:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tLINLEN:WORD,BUF:WORD\r\nDSEG\tENDS\r\n\r\n;Assumptions:\r\n; FILNAM and FILNA2 are 33 byte buffers (for temp FCBs)\r\n\r\n;FILES [ filename ]\r\n; FILES command [List the Directory]\r\n; If filename is omitted, all files on the logged\r\n; disk are listed.\r\n; If supplied, all files matching filename or wildcards\r\n; are listed.\r\n;\r\nFILES:\r\n\tJE\tNOARG\t\t;Brif no filename argument given\r\n\tCALL\tNAMFIL\t\t;[SI] points to 1st byte of filename\r\n\t\t\t\t;[CX] = number of bytes in filename\r\n\tCMP\tCL,LOW 2\r\n\tJNE\tGOTNAM\t\t;branch if not \"<drive>:\"\r\n\tMOV\tAX,WORD PTR 0[SI]\t;[AX]=filename\r\n\tCMP\tAH,LOW \":\"\r\n\tJNE\tGOTNAM\t\t;branch if not \"<drive>:\"\r\n\tMOV\tSI,OFFSET FILNA2+2\t;[SI] points to buffer for building filename\r\n\tMOV\tWORD PTR FILNA2,AX\t;Store <drive>: in filename buffer\r\n\tJMP\tSHORT ALFILS\t;append \"*.*\" to name\r\nNOARG:\r\n\tMOV\tSI,OFFSET FILNA2\t;[SI] points to buffer for building filename\r\n\tXOR\tCX,CX\r\nALFILS:\r\n\tMOV\tWORD PTR 0[SI],OFFSET (400O*\".\")+\"*\"\r\n\tMOV\tWORD PTR 2[SI],\"*\"\r\n\tADD\tCX,3\t\t;[CX] = number of bytes in filename\r\n\tMOV\tSI,OFFSET FILNA2\t;[SI] points to filename\r\nGOTNAM:\r\n\tCALL\tFILFCB\t\t;FILNAM=un-opened FCB for filename\r\n\tMOV\tDX,OFFSET FILNA2\t;tells OS to put FCB for matching directory\r\n\tCALLOS\tC_BUFF\t\t; entries in FILNA2\r\n\tMOV\tDX,DI\t\t;[DX] = search FCB (FILNAM)\r\n\tCALLOS\tC_SEAR\t\t;Search 1st\r\n\tINC\tAL\r\n\tJNZ\tFILNXT\t\t;Brif found\r\n\tJMP\tDERFNF\t\t; else complain\r\nFILNXT:\r\n\tCALL\tPOLKEY\t\t;Allow CTL-C, CTL-S between every filename\r\n\tMOV\tSI,OFFSET FILNA2+1\t;Point at name\r\n\tMOV\tCX,OFFSET FNAML\t;Characters in name\r\nMORNAM:\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n\tLODSB\t\t\t;Get character\r\n\tCALL\tOUTDO\t\t;Output it\r\n\tCMP\tCX,4\r\n\tJNE\tNOTEXT\t\t;Not at extension break\r\n\tMOV\tAL,BYTE PTR 0[SI]\t;Get 1st char of extension\r\n\tCMP\tAL,LOW \" \"\r\n\tJE\tPRISPA\t\t;Blank extension - print space\r\n\tMOV\tAL,LOW \".\"\t;Print .\r\nPRISPA:\r\n\tCALL\tOUTDO\t\t;Print blank or dot\r\nNOTEXT:\r\n\tLOOP\tMORNAM\t\t;Loop until 11 characters\r\nEXTRN\tPTRWID:NEAR\r\n\tCALL\tPTRWID\t\t;[AH]=line width\r\n\tMOV\tCH,AH\t\t;[CH]=line width\r\nEXTRN\tPTRGPS:NEAR\r\n\tCALL\tPTRGPS\t\t;[AL]=current column\r\n\tADD\tAL,LOW 14D\t;Position after next file name\r\n\tCMP\tAL,CH\r\n\tJAE\tNWFILN\t\t;Force CR/LF\r\n\tMOV\tAL,LOW \" \"\r\n\tCALL\tOUTDO\r\n\tJMP\tSHORT NEXTFL\r\nNWFILN:\r\n\tCALL\tCRDO\t\t;Type CR/LF\r\nNEXTFL:\r\n\tMOV\tDX,OFFSET FILNAM\t;[DX] points to search template\r\n\tXOR\tAL,AL\r\n\tCALLOS\tC_SEAR+1\t;Search next\r\n\tCMP\tAL,LOW 255D\r\n\tJNE\tFILNXT\t\t;branch if still more\r\nEXTRN\tCRDONZ:NEAR\r\n\tJMP\tCRDONZ\t\t;carriage return if not in column 0\r\n\r\n;KILL filename\r\n; Entry - [BX] = text pointer\r\n; Exit -  [BX] = text pointer\r\n;\r\nKILL:\r\n\tCALL\tNAMFIL\t\t;[SI] points to 1st byte of filename\r\n\t\t\t\t;[CX] = number of bytes in filename\r\n\tCALL\tFILFCB\t\t;FILNAM=un-opened FCB for filename\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tMOV\tDX,OFFSET FILNAM\r\n\tPUSH\tDX\t\t;Save FCB pointer\r\n\tCALLOS\tC_OPEN\t\t;Open file\r\n\tINC\tAL\r\n\tJNZ\tKILL2\t\t;Brif file found\r\n\tJMP\tDERFNF\t\t;File not found\r\nKILL2:\tPOP\tDX\t\t;DX points to FCB\r\n\tPUSH\tDX\r\n\tCALLOS\tC_CLOS\t\t;Close file\r\n\tMOV\tSI,OFFSET FILNAM-F_FCB\t;Pretend we are FDB\r\n\tCALL\tCHKFOP\t\t;Check for conflict with open files\r\n\t\t\t\t;jumps to error if file is now opened\r\n\tPOP\tDX\t\t;DX points to FCB\r\n\tCALLOS\tC_DELE\t\t;Delete file\r\n\tPOP\tBX\t\t;text pointer\r\n\tRET\t\r\n\r\n;NAME oldname AS newname\r\n; Entry - [BX] = text pointer\r\n; Exit  - [BX] = text pointer\r\n;\r\nNAME:\r\n\tCALL\tNAMFIL\t\t;[SI] points to 1st byte of old filename\r\n\t\t\t\t;[CX] = number of bytes in filename\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tCALL\tFILFCB\t\t;FILNAM=un-opened FCB for old filename\r\n\tMOV\tDX,OFFSET FILNA2\t;tells OS to put FCB for matching directory\r\n\tCALLOS\tC_BUFF\t\t; entries in FILNA2\r\n\tMOV\tDX,DI\t\t;[DX] = search FCB (FILNAM)\r\n\tCALLOS\tC_SEAR\t\t;Search 1st\r\n\tINC\tAL\r\n\tJZ\tNA_FNF\t\t;File not found\r\n\tMOV\tSI,OFFSET FILNAM-F_FCB\t;Pretend we are FDB\r\n\tCALL\tCHKFOP\t\t;Check for conflict with open files\r\n\t\t\t\t;jumps to error if file is now opened\r\n\tMOV\tSI,OFFSET FILNAM\t;save old filename in FILNA2\r\n\tMOV\tDI,OFFSET FILNA2\r\n\tMOV\tCX,OFFSET FNAML+1\t;+1 for drive\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n REP\tMOVSB\t\t\t;Move drive,name,ext from FILNAM to FILNA2\r\n\tPOP\tBX\t\t;text pointer\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"A\"\t; must see \"AS\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"S\"\r\n\tCALL\tNAMFIL\t\t;[SI] points to 1st byte of newfilename\r\n\t\t\t\t;[CX] = number of bytes in filename\r\n\tPUSH\tBX\t\t;text pointer\r\n\tCALL\tFILFCB\t\t;FILNAM=un-opened FCB for new filename\r\n\tMOV\tAL,BYTE PTR FILNAM\t;[AL]=drive for New filename\r\n\tOR\tAL,AL\t\t;test drive id of New filename\r\n\tJZ\tSAMDRV\t\t;branch if default drive\r\n\tCMP\tAL,BYTE PTR FILNA2\t;Compare with drive of original name\r\n\tJZ\tSAMDRV\t\t;branch if both drives are the same\r\nEXTRN\tDERRAD:NEAR\r\n\tJMP\tDERRAD\t\t;Rename Across Disks Error\r\nSAMDRV:\r\n\tMOV\tSI,OFFSET FILNAM+1\t;move new filename,ext to FILNA2+17\r\n\tMOV\tDI,OFFSET FILNA2+17D\t;[DI] = dest for new file name\r\n\tMOV\tCX,OFFSET FNAML\t;No drive code\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n REP\tMOVSB\t\t\t;Move name\r\n\tMOV\tDX,OFFSET FILNA2\t;Point to FCB which contains both filenames\r\n\tCALLOS\tC_RENA\t\t;Rename file\r\n\tINC\tAL\t\t;error if attempted to create file which\r\n\tJE\tNA_FAE\t\t; already existed\r\n\tPOP\tBX\t\t;text pointer\r\n\tRET\t\r\n\r\nNA_FNF:\tJMP\tDERFNF\t\t;file not found\r\nNA_FAE:\tJMP\tDERFAE\t\t;file already exists\r\n\r\n;NAMFIL - Scan a file name for NAME, KILL, or FILES command\r\n; Entry - [BX] = text pointer\r\n; Exit  - [BX] = text pointer\r\n;         [SI] points to 1st byte of filename\r\n;         [CX] = number of bytes in filename string\r\n; Uses  - [AX]\r\n;\r\nNAMFIL:\r\n\tCALL\tFRMEVL\t\t;Evaluate string\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tCALL\tFRESTR\t\t;Free the temp\r\n\tMOV\tCL,BYTE PTR 0[BX]\r\n\tXOR\tCH,CH\t\t;[CX] = String len\r\n\tJCXZ\tER_NMF\t\t;If null then bad name\r\n\tMOV\tSI,WORD PTR 1[BX]\t;[SI] = Filename string\r\n\tPOP\tBX\r\n\tRET\t\r\n\r\nER_NMF:\tJMP\tDERNMF\t\t;\"Bad file name\"\r\n\r\n;FILFCB - Given filename \"d:name:ext\", create an un-opened FCB\r\n; Entry - [SI] = points 1st byte of filename\r\n;         [CX] = number of bytes in filename string\r\n; Exit  - FILNAM is un-opened FCB equivalent for filename\r\n;         [DI] points to 1st byte of FCB FILNAM\r\n;         [AL] = FF if illegal drive or filename,\r\n;                 1 if filename contained any \"?\" or \"*\" characters\r\n;                 0 otherwise\r\n; Uses  - BUF\r\n;\r\nFILFCB:\r\n\tMOV\tDI,OFFSET BUF\t;move filename to BUF buffer\r\n\tCLD\t\t\t;Set Post-Increment mode\r\n\r\nSTRTNM:\tXOR\tAH,AH\t\t;Count of chars in name portion:=0.\r\nNAMORE:\tOR\tCX,CX\t\t;Anything left?\r\n\tJE\tTRMSTR\t\t;No, go terminate the string in BUF.\r\n\tMOV\tAL,BYTE PTR 0[SI]\t;Yes, AL:=get next char of string.\r\n\tMOVSB\t\t\t;Copy it to BUF.\r\n\tDEC\tCX\t\t;Decrement the length.\r\n\tCMP\tAL,LOW \":\"\t;Colon indicating we were looking at a\r\n\t\t\t\t;device name?\r\n\tJE\tSTRTNM\t\t;Yes, restart the count since we are now\r\n\t\t\t\t;looking at the filename.\r\n\tCMP\tAL,LOW \".\"\t;No, dot indicating start of extension?\r\n\tJE\tFINNAM\t\t;Yes, end of name.\r\n\tCMP\tAL,LOW \"*\"\t;The asterisk wild card also terminates the\r\n\tJE\tFINNAM\t\t;name for our purposes.\r\n\tCMP\tAH,LOW 8D\t;Have we already seen 8 name characters?\r\n\tJAE\tLNGNAM\t\t;Yes, the excess chars become the extension.\r\n\tINC\tAH\t\t;No, increment the name character count.\r\n\tJMP\tSHORT NAMORE\t;Go look at the next char.\r\n\r\nLNGNAM:\tMOV\tBYTE PTR -1[DI],LOW \".\"\t;Put in the dot so the extra chars look\r\n\tMOV\tBYTE PTR 0[DI],AL\t;like an extension.\r\n\tINC\tDI\r\nFINNAM:\tOR\tCX,CX\t\t;Anything left?\r\n\tJE\tTRMSTR\t\t;No, terminate the string.  (Avoid REP with\r\n                     ;a zero count.)\r\n REP\tMOVSB\t\t\t;Copy the remainder of the string to BUF.\r\nTRMSTR:\tMOV\tBYTE PTR 0[DI],LOW 0\t;store string terminator\r\n\tMOV\tSI,OFFSET BUF\t;parse 0 terminated filename in BUF\r\n\tMOV\tDI,OFFSET FILNAM\t; filling FDB FILNAM\r\n\tXOR\tAL,AL\t\t; don't skip any separators\r\n\tCALLOS\tC_PARS\r\n\tOR\tAL,AL\t\t;test for legal filename\r\n\tJNE\tFLFCBX\t\t;branch if error or non-empty filename\r\n\tCMP\tBYTE PTR FILNAM+1,LOW \" \"\t;test 1st byte of filename\r\n\tJNE\tFLFCBX\t\t;branch if non-empty filename\r\n\tDEC\tAL\t\t;[AL] = FF (illegal filename)\r\nFLFCBX:\r\n\tRET\t\r\n\r\n\tSUBTTL  RESET and SYSTEM statements\r\n;\r\n; Entry/exit:   [BX] = text pointer\r\n\r\n\tPUBLIC\tRESET\r\n\tEXTRN\tCLSALL:NEAR,TKEYOF:NEAR\r\n\r\nRESET:\r\n\tJNZ\tRESETX\t\t;if wasn't EOS\r\n\tPUSH\tBX\t\t;text pointer\r\n\tCALL\tCLSALL\t\t;Close all files\r\n\tCALLOS\tC_GDRV\t\t;Get drive number\r\n\tPUSH\tAX\r\n\tCALLOS\tC_REST\t\t;Restore\r\n\tPOP\tAX\r\n\tMOV\tDL,AL\r\n\tCALLOS\tC_SDRV\t\t;Set drive number\r\n\tPOP\tBX\t\t;text pointer\r\nRESETX:\r\n\tRET\t\r\n\r\n\r\n; SYSTEM - Exit BASIC\r\n\r\n\tPUBLIC\tSYSTEM,SYSTME\r\n\r\n\tEXTRN\tGWTERM:NEAR\r\n\r\nSYSTEM:\r\n\tJNZ\tRESETX\t\t;If wasn't EOS\r\n\tCALL\tCLSALL\t\t;Close all files\r\nSYSTME:\r\nEXTRN\tGIOTRM:NEAR\r\n\tCALL\tGIOTRM\t\t;call device termination routines\r\n\tCALL\tGWTERM\t\t;Do OEM specific termination processing\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCPMEXT:WORD\t;MSDOS exit jump vector.\r\nDSEG\tENDS\r\n;translator can't handle JMPI ,adr yet\r\n\tPUSH\tWORD PTR CPMEXT+2\t;put segment adr on stack\r\n\tPUSH\tWORD PTR CPMEXT\t;put offset on stack\r\ndumy  PROC    FAR\r\n\tRET\t\t\t;intra-segment return\r\ndumy  ENDP\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GIOKYB.ASM",
          "type": "blob",
          "size": 28.375,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GIOKYB - Machine Independent Keyboard Device Driver Code\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- ---------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT\r\n--------- --- ---- -- ---------\r\n\r\n\t*\r\n\tINCLUDE\tGIO86U\r\n\t.SALL\r\n\r\n;Generic Switches\r\n;\r\nCPM86=0\r\nIBMCSR=IBMLIK\t\t\t;IBM compatible cursor interface\r\n\r\n;OEM Switches\r\n;\r\nMELCO=0\r\nCOMPAQ=0\r\n\r\n;Local switches\r\nINTHND=SCP AND GW\r\n\r\n\r\n\tINCLUDE\tMSDOSU\r\n\r\n\tPUBLIC\tKYBDSP,KYBINI,KYBTRM\r\n\tEXTRN\tSCNSWD:NEAR,SCNGWD:NEAR,SCNSOT:NEAR,SCNGPS:NEAR,SCNGCW:NEAR\r\n\tEXTRN\tSCNSCW:NEAR\r\n\tEXTRN\tMAKINT:NEAR,INIFDB:NEAR,DERBFM:NEAR\r\n\tEXTRN\tINITQ:NEAR,GETQ:NEAR,PUTQ:NEAR\r\n\tEXTRN\tDEVBIN:NEAR,DEVBOT:NEAR\r\n\tEXTRN\tSCNBRK:NEAR,EDTBRK:NEAR\r\n\tCTLBRK=65283D\t\t;&HFF03 is Ctl-Break\r\n\tCTLPAS=65299D\t\t;&HFF13 is Ctl-Pause\r\n\r\n; Keyboard Data-Flow/Control-Structure for GIO86:\r\n;\r\n;    PLAY, LIST, NEWSTT                                            INCHRI\r\n;    --------+---------                                      (fixed length input)\r\n;            !                                   INLIN               !\r\n;            !                              (Screen Editor)     KYBSIN/CHGET\r\n;         CHKINT                                   !        (Device Indep. input)\r\n;     +-------------+                              !                 !\r\n;     !             !                              +-----------------+\r\n;     !             !                                       !\r\n;     !             !                  INKEY$             KEYIN\r\n;     !           POLKEY                 !                  !\r\n;     !             !                    +--------------+---+\r\n;     !        +----+--------+-------+                  !\r\n;     !        !    !        !       !                CHSNS (get 1 KEY {may be 2 bytes}\r\n;     !        !  CNTCCN  KEYTRP  PKEYQ                 !    function key expansion)\r\n;     !        !    !                !      ------+     !\r\n;     !        +----+              PUTQ --> ! ! ! !--> CONIN (get 1 byte from queue)\r\n;     !             !                       ------+\r\n;  POLLEV         KEYINP(OEM supplied)      (queue)\r\n;(OEM supp.)      (maps to MS Univ keyboard)\r\n;(test for trapable event)\r\n\r\n;Keyboard Dispatch Table\r\n;\r\nKYBDSP:\r\n\tDW\t(KYBEOF)\t;test EOF for file opened to this device\r\n\tDW\t(KYBLOC)\t;LOC\r\n\tDW\t(KYBLOF)\t;LOF\r\n\tDW\t(KYBCLS)\t;perform special CLOSE functions for this device\r\n\tDW\t(SCNSWD)\t;set device width\r\n\tDW\t(DERBFM)\t;GET/PUT random record from/to this device\r\n\tDW\t(KYBOPN)\t;perform special OPEN functions for this device\r\n\tDW\t(KYBSIN)\t;input 1 byte from file opened on this device\r\n\tDW\t(SCNSOT)\t;output 1 byte to file opened on this device\r\n\tDW\t(SCNGPS)\t;POS\r\n\tDW\t(SCNGWD)\t;get device width\r\n\tDW\t(SCNSCW)\t;set device comma width\r\n\tDW\t(SCNGCW)\t;get device comma Width\r\n\tDW\t(DEVBIN)\t;block input from file opened on this device\r\n\tDW\t(DEVBOT)\t;block output to file opened on this device\r\n\r\n\tSUBTTL Keyboard Primitive I/O Routines\r\n\r\n\tEXTRN\tBCHRSI:NEAR\r\n\r\n;KYBINI puts the keyboard device server in an initial state.\r\n; It is called at initialization time and after CTL-C.\r\n; On exit, all registers are preserved.\r\n;\r\n\tEXTRN\tFINPRT:NEAR,PDCBAX:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tKYBQDS:WORD,KYBQUE:WORD,KYBQSZ:WORD\r\nDSEG\tENDS\r\nKYBINI:\r\n\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tPUSHF\t\r\n\tPUSH\tSI\r\n\tXOR\tAX,AX\r\n\tMOV\tWORD PTR CMDOFF,AX\t;[CMDOFF]=0 (no soft key)\r\n\tMOV\tSI,OFFSET KYBQDS\t;SI = keyboard queue descriptor\r\n\tMOV\tBX,OFFSET KYBQUE\t;BX points to 1st byte of queue buff\r\n\tMOV\tAX,OFFSET KYBQSZ\t;AX = size of keyboard queue\r\n\tCALL\tINITQ\t\t;Initialize keyboard queue\r\n\tCALL\tFINPRT\t\t;reset PTRFIL to Keyboard/CRT\r\n\tPOP\tSI\r\n\tPOPF\t\r\n\tJMP\tPDCBAX\t\t;POP DX, CX, BX, AX and return\r\n\r\n\tPUBLIC\tKYBCLR\r\n;KYBCLR - Clear the keyboard buffer\r\n;This routine has been documented to OEMs.  The routine is intended to support\r\n;the IBM poke which clears the keyboard buffer.\r\n;Entry - none\r\n;Exit  - none\r\n;        Segment registers and stack preserved.\r\n;\r\nKYBCLR:\tCALL\tKYBINI\t\t;Initialize the keyboard buffer\r\n\tRET\t\r\n\tPAGE\t\r\n;KYBEOF - test for End-Of-File on device.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [BX] = -1 if EOF, 0 if not EOF\r\n;\r\n\tEXTRN\tINCHSI:NEAR\r\n\r\nKYBEOF:\tXOR\tBX,BX\t\t;0 means not at eof\r\n\tOR\tSI,SI\r\n\tJZ\tKBEOFX\t\t;branch if not pseudo keyboard FDB\r\n\tCALL\tINCHSI\t\t;[AL]=next byte from keyboard\r\n\tJB\tYKYEOF\t\t;branch if next key = CTL-Z\r\n\tCALL\tBCHRSI\t\t;put this back in queue\r\nKBEOFX:\tRET\t\r\nYKYEOF:\tDEC\tBX\t\t;BX=-1, end-of-file is true\r\nKYBTRM:\tRET\t\r\n\r\n;KYBLOC - Number of Bytes in input buffer for KEYBOARD device.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [BX] = result.\r\n;\r\nKYBLOC:\tPUSH\tSI\t\t;save FDB pointer\r\n\tMOV\tSI,OFFSET KYBQDS\t;SI points to KYB queue descriptor\r\nEXTRN\tNUMQ:NEAR\r\n\tCALL\tNUMQ\t\t;[AX]=number of bytes queued in KYB Q\r\n\tPOP\tSI\r\n\tMOV\tBX,AX\t\t;return result in BX\r\n\tTEST\tBYTE PTR F_FLGS[SI],LOW OFFSET FL_BKC\r\n\tJZ\tKYLOCX\t\t;branch if char not backed up\r\n\tINC\tBX\r\nKYLOCX:\tRET\t\r\n\r\n;KYBLOF - number of bytes free in KEYBOARD input buffer.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [Floating-Point-Accumulator] = result.\r\n;\r\nKYBLOF:\tMOV\tSI,OFFSET KYBQDS\t;SI points to KYB queue descriptor\r\nEXTRN\tLFTQ:NEAR\r\n\tCALL\tLFTQ\t\t;[AX]=number of bytes free in KYB Q\r\n\tMOV\tBX,AX\r\n\tJMP\tMAKINT\t\t;return result in FAC\r\n\r\n;KYBCLS - perform any device dependent close functions.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - All registers preserved.\r\n;         This routine is called before BASIC releases the\r\n;         file-data-block associated with this file.\r\n;\r\nKYBCLS:\r\nRET11:\tRET\t\r\n\r\n;KYBOPN - perform any device dependent open functions.\r\n; Entry - [AL]=  device id\r\n;                0 if default device,\r\n;                1..n for Disk A:, B:, ...\r\n;                -1..-n for non-disk devices\r\n;         [BX] = file number (0..n)\r\n;         [CX] = random record size if [FILMOD] = random\r\n;                (if [CX] = 0, use default record size)\r\n;         [DI] = device offset (2=KYBD, 4=SCRN, etc.)\r\n;         [FILMOD] = file mode\r\n;                    MD.SQI = 1 ;sequential input\r\n;                    MD.SQO = 2 ;sequential output\r\n;                    MD.RND = 3 ;random\r\n;                    MD.APP = 4 ;append\r\n;         [FILNAM] = filename\r\n;         [FILEXT] = 1..3 byte filename extension\r\n; Exit  - [SI] points to new FDB\r\n;         FDB is linked into FDB chain with all standard\r\n;         fields initialized.\r\n;         All other registers are preserved.\r\n;\r\nKYBOPN:\r\n\tMOV\tAH,LOW OFFSET MD_SQI\t;allow input only\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFILMOD:WORD\r\nDSEG\tENDS\r\n\tCMP\tBYTE PTR FILMOD,LOW OFFSET MD_RND\r\n\tJNZ\tKYBOPX\t\t;Leave the mode as it is\r\n\tMOV\tBYTE PTR FILMOD,AH\t;Force the mode to INPUT\r\nKYBOPX:\r\n\tJMP\tINIFDB\r\n\r\n;KYBSIN - Sequential Input.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [AL] = next byte from Keyboard File\r\n;         carry set if EOF (CTL-Z read) (only if SI points to FDB (non 0))\r\n;         (Note: SI must be preserved for KYBEOF to work)\r\n;         All other registers preserved\r\n;\r\n\r\n\tPUBLIC\tKYBSIN,INCHRI,CHGET\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSAVKEY:WORD,SAVKYF:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tSCNPOS:NEAR\r\n\r\nINCHRI:\r\n\tEXTRN\tINFMAP:NEAR\r\n\tMOV\tAL,BYTE PTR SAVKEY\r\n\tCMP\tBYTE PTR SAVKYF,LOW 0D\r\n\tMOV\tBYTE PTR SAVKYF,LOW 0D\r\n\tJNZ\tKBSINX\t\t;Send second bytes through unfiltered\r\nKEYGET:\r\n\tSTC\t\r\n\tCALL\tSTCTYP\t\t;Set new cursor type to user mode (PSW.C set)\r\n\tCALL\tKEYSIN\t\t;Read a key from the OS (could be a null fkey)\r\n\tCALL\tINFMAP\t\t;OEM fixed length input map routine\r\n\tJZ\tKEYGET\t\t;OEM filtered out the key - get the next\r\n\tJMP\tSHORT KYBSI2\t;Process as other keys\r\nCHGET:\r\nKYBSIN:\tMOV\tAL,BYTE PTR SAVKEY\r\n\tCMP\tBYTE PTR SAVKYF,LOW 0D\r\n\tMOV\tBYTE PTR SAVKYF,LOW 0\t;clear 2nd-byte of 2-byte sequence flag\r\n\tJNZ\tKBSINX\t\t;branch if 2nd-key of 2-byte sequence\r\n\tCALL\tSTCTYP\t\t;Set to insert or overwrite cursor (PSW.C reset)\r\n\tCALL\tKEYIN\t\t;[AX]=next character from keyboard\r\nKYBSI2:\r\n\tJB\tKBSIN2\t\t;branch if got 2-byte sequence (f-key/KANJI)\r\n\tPUSHF\t\r\n\tOR\tSI,SI\r\n\tJZ\tKB1X\t\t;branch if no FDB\r\n\tCMP\tAL,LOW OFFSET ASCCTZ\t;CTL-Z=eof for keyboard\r\n\tJNE\tKB1X\t\t;branch if not EOF\r\n\tPOPF\t\r\n\tSTC\t\t\t;return EOF indication\r\n\tJMP\tSHORT KBSINX\r\nKB1X:\tPOPF\t\r\n\tJMP\tSHORT KBSINX\r\nKBSIN2:\r\n\tMOV\tBYTE PTR SAVKEY,AL\t;save 2nd byte of 2-byte sequence\r\n\tMOV\tBYTE PTR SAVKYF,LOW 255D\t;Set saved key flag\r\n\tXCHG\tAH,AL\t\t;return 1st byte to user\r\n\tCLC\t\t\t;clear carry (not EOF)\r\nKBSINX:\tRET\t\r\n\r\n;KEYIN turns cursor on if no key is available.\r\n; It then waits for key from keyboard (if one wasn't already there).\r\n; Exit - if Z is true, no key was ready, else [AX]=key\r\n;        if C is true, returns 16 bit character\r\n;        Soft keys are expanded if not being trapped, and not null.\r\n;        if NZ AND NC AND [AL] = FF then a two byte character is returned\r\n;               in DX.  The character is an OEM specific special character.\r\n;        All other registers are preserved.\r\n;\r\n\tPUBLIC\tKEYIN\r\nKEYIN:\r\nIGNNFK:\tCALL\tKEYSIN\t\t;Get a key (possibly a null function key)\r\n\tPUSHF\t\r\n\tJAE\tNOTNFK\t\t;branch if not 2-byte key code\r\n\tCMP\tAH,LOW 200O\r\n\tJNE\tNOTNFK\t\t;branch if definitely not a null Function key\r\n\tCMP\tAL,LOW 40O\r\n\tJB\tNOTNFK\t\t;branch if definitely not a null Function key\r\n\tCMP\tAL,LOW 101O\r\n\tJAE\tNOTNFK\t\t;branch if definitely not a null Function key\r\n\tPOPF\t\r\n\tJMP\tSHORT IGNNFK\t;ignore null Function key\r\n\r\nNOTNFK:\tPOPF\t\r\n\tRET\t\r\n\r\n;KEYSIN - Get a key.  This routine will return null function keys.\r\n;Entry - none\r\n;Exit  - PSW.C set indicates a two byte key code\r\n;\r\nKEYSIN:\tCALL\tCHSNS\t\t;try to get next key\r\n\tJNE\tKEYINX\t\t;Return with key if there is one.\r\n\tPUSH\tDX\r\n\tCALL\tSCNPOS\t\t;[DH]=1 relative column (cursor position)\r\n\t\t\t\t;[DL]=1 relative line\r\n\tCALL\tSETCSR\t\t;Set the cursor\r\n\tPOP\tDX\r\nCHWAIT:\tCALL\tCHSNS\t\t;Has a key been typed?\r\n\tJE\tCHWAIT\t\t;No, wait\r\nKEYINX:\tPUSHF\t\r\n\tPUSH\tAX\r\n\tMOV\tBYTE PTR CSRTYP,LOW 3D\t;Indicate user cursor\r\n\tCALL\tSETCSR\t\t;Set the cursor\r\n\tPOP\tAX\r\n\tPOPF\t\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  Keyboard Interrupt/Trap Checking in an Operating System Environment\r\n\r\n;POLKEY is called from several places in BASIC to \"poll\" the keyboard.\r\n; Exit - DI is used.  All other registers are preserved.\r\n;        If CTL C was typed, Control does not return to caller.\r\n;\r\n; Function:\r\n;       get key from operating system\r\n;       while keyboard data is ready to be read begin\r\n;         get key\r\n;         if key is CTL-C, reset soft-key pointer, key-queue, AUTFLG, SEMFLG\r\n;            call SNDRST to reset background sound,\r\n;            and exit to CNTCCN (resets stack and jumps to STOP)\r\n;         if key is CTL-S, pause until non-CTL-S key is pressed\r\n;         if key is 1st byte of Function Key, continue getting keys\r\n;            until it definitely is or is not a function key.\r\n;         if it was a function key then begin\r\n;            if trapping is enabled then\r\n;               trap it\r\n;            else\r\n;               queue function key code for CHSNS\r\n;            end {it was a function key}\r\n;         else {it was not a function key}\r\n;           queue key for CHSNS\r\n;       end {while keyboard data ready}\r\n;\r\n\tPUBLIC\tPOLKEY\r\n\tEXTRN\tKEYTRP:NEAR,KEYINP:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tAUTFLG:WORD,SEMFLG:WORD,SAVSTK:WORD,SAVTXT:WORD\r\nDSEG\tENDS\r\n\r\nPOLKEY:\tPUSH\tDI\r\n\tPUSHF\t\r\n\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\nGETKLP:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tMSDCCF:WORD\t;MSDOS Ctl-C Interrupt flag\r\nDSEG\tENDS\r\n\tTEST\tBYTE PTR MSDCCF,LOW 255D\r\n\tJNZ\tITSCTC\t\t;Branch if Ctl-C interrupt detected\r\n\tCALL\tKEYINP\t\t;[AX]=next key from keyboard if one exists\r\n\tJE\tPOLKXI\t\t;branch if no key present\r\n\tJAE\tNOTTWO\t\t;branch if not 2-byte key sequence\r\n\tCMP\tAH,LOW 255D\t;Test for control function range\r\n\tJNZ\tNTCTLFN\t\t;Not a control function\r\n\tCALL\tTRPCHK\t\t;Check for trapping in this range\r\n\tJNZ\tGETKLP\t\t;Trap set - get next key\r\nNTCTLFN:\r\n\tCMP\tAH,LOW 128D\r\n\tJNE\tNOTFUN\t\t;branch if not function key\r\n\tPUSH\tAX\t\t;save key-code\r\n\tSUB\tAL,LOW 32D\t;[AL]=0 for 1st function key\r\n\tCMP\tAL,LOW OFFSET NMKEYT\t;see if its a trapable function key\r\n\tJAE\tNOFUN1\t\t;branch if not\r\n\tCALL\tKEYTRP\t\t;Trap key if event is ON\r\n\tPOP\tAX\t\t;restore key code\r\n\tJNZ\tGETKLP\t\t;branch if Key was trapped (don't queue)\r\n\tJMP\tSHORT NOTFUN\t;Not trapped function key (queue key)\r\nPOLKXI:\tJMP\tPOLKYX\r\n\r\nNOFUN1:\tPOP\tAX\t\t;Restore key code\r\nNOTFUN:\r\n\tCMP\tAX,OFFSET CTLBRK\t;check for Ctl-Break\r\n\tJE\tITSCTC\t\t;branch if CTL C\r\n\tCMP\tAX,OFFSET CTLPAS\r\n\tJE\tITSINT\t\t;branch if CTL S\r\nNOTRAP:\r\n\tPUSH\tAX\r\n\tCALL\tLFTQ\t\t;[AX]=number of bytes free in KYB Q\r\n\tCMP\tAX,3D\t\t;Test for space in keyboard queue\r\n\tPOP\tAX\t\t;Restore key code\r\n\tJB\tGETKLP\t\t;Loop for next key (interrupt?)\r\n\tXCHG\tAH,AL\r\n\tCALL\tPKQUE\t\t;append 1st byte of sequence to key queue\r\n\tXCHG\tAH,AL\r\n\tJMP\tSHORT QUEKEY\t;append 2nd byte of sequence to key queue\r\nNOTTWO:\r\n\tCMP\tAL,LOW 254D\t;Test for three byte char (IBM \"scan codes\")\r\n\tJNZ\tQONEBT\t\t;Queue a one byte character\r\n\tPUSH\tAX\r\n\tCALL\tLFTQ\t\t;[AX]=number of bytes free in KYB Q\r\n\tCMP\tAX,4D\t\t;Test for space in keyboard queue\r\n\tPOP\tAX\t\t;Restore key code\r\n\tJB\tGETKLP\t\t;Loop for next key (interrupt?)\r\n\tCALL\tPKQUE\t\t;Queue the first byte\r\n\tMOV\tAX,DX\t\t;Get second and third bytes\r\n\tJMP\tSHORT NOTRAP\t;Go queue the second and third bytes\r\nQONEBT:\r\n\tJMP\tSHORT QUEKEY\t;else queue the key for CHSNS\r\nITSCTC:\r\n\tCALL\tKYBINI\t\t;clear keyboard queue, reset PTRFIL\r\n\tMOV\tBYTE PTR MSDCCF,LOW 0D\t;Reset Ctl-Break interrupt flag\r\n\tEXTRN\tSNDRST:NEAR\r\n\tCALL\tSNDRST\t\t;reset background music\r\n\tMOV\tSP,WORD PTR SAVSTK\t;[SP]=SP of interrupted statement\r\n\tMOV\tBX,WORD PTR SAVTXT\t;[BX]=text pointer of interrupted stmt\r\n\tMOV\tAX,OFFSET CTLBRK\t;[AX]=Key Code for BREAK (CTL-C)\r\nITSINT:\tCALL\tCNTCCN\t\t;process CTL C or S\r\n\tJMP\tGETKLP\t\t;dont queue CTL-S or CTL-C\r\n\r\nQUEKEY:\tCALL\tPKQUE\t\t;queue key [AL] for CHSNS\r\n\tJMP\tGETKLP\t\t;get next key\r\n\r\n;At this point, Keyboard input queue from OS is flushed.\r\n;\r\nPOLKYX:\tPOP\tDX\t\t;restore caller's registers\r\n\tPOP\tCX\r\n\tPOP\tBX\r\nPOLKXX:\tPOP\tAX\r\n\tPOPF\t\r\n\tPOP\tDI\r\nRET8:\tRET\t\r\n\r\n;TRPCHK - Check for key trapping\r\n;Entry - AX = key code\r\n;Exit  - PSW.Z set indicates key was not trapped\r\n;\r\nTRPCHK:\tPUSH\tAX\t\t;Save key code\r\n\tMOV\tBX,OFFSET TRPKTB-1\t;BX points before 1st byte of key trap table\r\nCHKTRP:\tINC\tBX\r\n\tMOV\tAH,BYTE PTR CS:0[BX]\r\n\tINC\tBX\t\t;BX points to Trap Key ID for key [AH]\r\n\tOR\tAH,AH\t\t;test for end-of-table\r\n\tJE\tNTRAP\t\t;branch if not a trappable key\r\n\tCMP\tAH,AL\r\n\tJNE\tCHKTRP\t\t;branch if they don't match (continue search)\r\n\tMOV\tAL,BYTE PTR CS:0[BX]\t;[AL]=key-trap id\r\n\tCALL\tKEYTRP\t\t;Trap key if event is ON\r\nNTRAP:\tPOP\tAX\t\t;Restore key code\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  CHKKYB - OEM Version of POLKEY\r\n;CHKKYB - This is the OEM version of POLKEY.  It is documented to the OEM as\r\n;the way to check for keyboard interrupts.\r\n;Entry - All segment registers must be set\r\n;        to the BASIC configuration\r\n;Exit  - All registers and PSW preserved\r\n;\r\n\tPUBLIC\tCHKKYB\r\nCHKKYB:\tPUSH\tSI\r\n\tPUSH\tBP\t\t;For safety\r\n\tCALL\tPOLKEY\r\n\tPOP\tBP\r\n\tPOP\tSI\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  CNTCCN, PKQUE, TRPKTB\r\n;CNTCCN performs special action upon receipt of CTL-S or CTL-C\r\n;\r\n\tEXTRN\tCTRLPT:NEAR,STOP:NEAR\r\nCNTCCN:\r\n\tCMP\tAX,OFFSET CTLPAS\t;check for PAUSE\r\n\tJNZ\tNOTCTS\t\t;branch if not\r\nGOTCTS:\tCALL\tKEYINP\r\n\tJZ\tGOTCTS\t\t;wait for resume key (anything but CTL S)\r\n\tCMP\tAX,OFFSET CTLPAS\t;check for PAUSE\r\n\tJE\tGOTCTS\t\t;branch if got another CTL-S\r\nNOTCTS:\r\n\tCMP\tAX,OFFSET CTLBRK\t;check for Ctl-Break\r\n\tJNE\tRET8\t\t;return if not CTL-C\r\n\tCALL\tEDTBRK\t\t;Clear editor flags and position cursor\r\n\tCALL\tSCNBRK\t\t;Clear flags associated with screen driver\r\n\tPUSH\tAX\r\n\tCALL\tFINPRT\t\t;Reset I/O\r\n\tPOP\tAX\r\n\tMOV\tAX,WORD PTR CURLIN\t;Print \"BREAK\" message in program mode only\r\n\tAND\tAL,AH\t\t;AL=^D255 if direct mode\r\n\tXOR\tAH,AH\t\t;Set PSW.Z so STOP won't give Syntax Error\r\n\tJMP\tSTOP\r\n\r\n;PKQUE appends [AL] to the keyboard circular queue\r\n;\r\nPKQUE:\tPUSH\tSI\r\n\tMOV\tSI,OFFSET KYBQDS\t;SI = keyboard queue descriptor\r\n\tCALL\tPUTQ\t\t;append [AL] to keyboard queue (read by CHSNS)\r\n\tPOP\tSI\r\n\tRET\t\r\n\r\n;Keyboard Trap Table (for KEY TRAPPING of non-soft keys)\r\n; Referenced by POLKEY\r\n;\r\nTRPKTB:\r\n\tDB\t30D,OFFSET NMKEYF+0\t;ON KEY (Cursor Up)\r\n\tDB\t29D,OFFSET NMKEYF+1\t;ON KEY (Cursor Left)\r\n\tDB\t28D,OFFSET NMKEYF+2\t;ON KEY (Cursor Right)\r\n\tDB\t31D,OFFSET NMKEYF+3\t;ON KEY (Cursor Down)\r\n\tDB\t0\t\t;end-of-table\r\n\tPAGE\t\r\n\tSUBTTL  Machine independent Keyboard input routines CHSNS, INKEY$\r\n\tPUBLIC\tCHSNS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCMDOFF:WORD,STRTAB:WORD\r\nDSEG\tENDS\r\n\r\n;Get key from keyboard if one is ready.\r\n;Exit  - if Z is true, no key was ready, else [AX]=key\r\n;        if C is true, returns 16 bit character\r\n;        Soft keys are expanded if not being trapped, and not null.\r\n;        if NZ AND NC AND [AL] = FF then a two byte character is returned\r\n;               in DX.  The character is an OEM specific special character.\r\n;        All other registers are preserved.\r\n;\r\nCHSNS:\tPUSH\tBX\t\t;save caller's registers\r\n\tPUSH\tCX\r\n\tPUSH\tSI\r\n\tPUSH\tDI\r\nCHSNSI:\tXOR\tDL,DL\t\t;clear high byte of 2-byte sequence\r\nCHSNS0:\tCALL\tCONIN\t\t;check for SOFTKEY\r\n\tJNZ\tCHSNSS\t\t;BRIF key found\r\n\tOR\tDL,DL\r\n\tJZ\tCHSNSX\t\t;BRIF no key sensed and not 2nd of 2 bytes\r\n\tJMP\tSHORT CHSNS0\t;BRIF need 2nd byte of 2 byte character\r\n\r\nCHSNSS:\tOR\tDL,DL\r\n\tJNZ\tCHSNS2\t\t;BRIF 2nd byte of 2 byte character\r\n\tCALL\tCKDBLK\t\t;see if this is the 1st byte of 2-byte seq\r\n\tJAE\tCHSNG1\t\t;branch not\r\n\tMOV\tDL,AL\t\t;Put first byte in [DL]\r\n\tJMP\tSHORT CHSNS0\t;Go get 2nd byte\r\nCHSNS2:\tMOV\tAH,DL\t\t;Put 1st byte in [AH]\r\n\tCMP\tAH,LOW 200O\t;Check for 8080 code which represents single 80\r\n\tJNZ\tCHSN2A\r\n\tCMP\tAH,AL\r\n\tJZ\tCHSNG1\t\t;Return 80 for 8080 char code\r\nCHSN2A:\tCALL\tCHKFKY\t\t;see if AX is a non-null function key\r\n\tJZ\tCHSNS3\t\t;BRIF not a string key that needs expansion\r\n\tJB\tCHSNG1\t\t;BRIF is super shift key(return first byte now)\r\n\tMOV\tBYTE PTR F_SUPR,LOW 0\r\n\tJMP\tSHORT CHSNSI\t;Is string key, get first expansion and return\r\nCHSNS3:\r\n\tOR\tAH,AH\t\t;else NZ, C Indicates 2 byte character\r\n\tSTC\t\r\n\tJMP\tSHORT CHSNSX\r\nCHSNG1:\tOR\tAL,AL\t\t;set NZ, no-carry (got 1 byte)\r\n\tMOV\tAH,LOW 0\t;high-byte = 0 for single byte characters\r\n;Check for 3 byte sequence case\r\n\tPUSHF\t\r\n\tCMP\tAL,LOW 254D\t;Test for three byte sequence\r\n\tJNZ\tCHSNG2\t\t;Not a three byte sequence\r\n\tPUSH\tAX\t\t;Save first byte\r\n\tCALL\tCONIN\t\t;Get second byte\r\n\tMOV\tDH,AL\r\n\tCALL\tCONIN\t\t;Get third byte\r\n\tMOV\tDL,AL\r\n\tPOP\tAX\t\t;Restore third byte\r\nCHSNG2:\tPOPF\t\r\nCHSNSX:\tPOP\tDI\r\n\tPOP\tSI\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tRET\t\r\n\r\n\r\nCKDBLK:\r\n;Check for function key (80,nn)\r\n\tCMP\tAL,LOW 200O\t;First check for 80,nn key\r\n\tSTC\t\r\n\tJE\tCKDBLX\t\t;branch if 1st of 2-byte sequence\r\n\tCMP\tAL,LOW 255D\r\n\tSTC\t\r\n\tJE\tCKDBLX\t\t;BRIF 1st byte of two byte control function\r\n\tCLC\t\r\nCKDBLX:\tRET\t\r\n\r\n;CONIN gets the next key from the soft-key being expanded (if any).\r\n; If no soft-key is active, it calls POLKEY to get and queue key from OS,\r\n; afterwhich it trys to get a key from the keyboard queue.\r\n; On exit, Flags.Z is set if no key is ready, else [AL]=key\r\n;\r\nCONIN:\tPUSH\tBX\r\n\tCALL\tGETFKY\t\t;expand soft-key if active\r\n\tJNZ\tCONINX\t\t;branch if expanding soft-key\r\n\tPUSH\tSI\r\n\tCALL\tPOLKEY\t\t;try to get and queue key from OS\r\n\tMOV\tSI,OFFSET KYBQDS\r\n\tCALL\tGETQ\t\t;[AL]=next key from keyboard queue\r\n\tPOP\tSI\r\nCONINX:\tPOP\tBX\r\n\tRET\t\r\n\r\n;Returns with FLAGS.NZ if AX is Universal key code for non-null Soft-key\r\n;Also sets FLAGS.NC for softkey and FLAGS.C for super shift key\r\n;       (note that for super shift the first character is in AL and must\r\n;           be returned)\r\n;\r\nCHKFKY:\tCMP\tAH,LOW 200O\r\n\tJNE\tNTFKYX\t\t;branch if not soft-key\r\n\tPUSH\tAX\r\n\tSUB\tAL,LOW 32D\r\n\tJB\tNTFKY1\t\t;branch if not soft-key\r\n\tCMP\tAL,LOW OFFSET NMKEYF\r\n\tJAE\tNTFKY1\t\t;branch if not soft-key\r\n\tMOV\tBL,LOW 16D\t;else, tell CHSNS to expand soft-key\r\n\tMUL\tBL\t\t;[AX]=16 * function-key id\r\n\tADD\tAX,OFFSET STRTAB\t;Get soft-key address\r\n\tMOV\tWORD PTR CMDOFF,AX\t;save soft-key pointer for soft-key expansion\r\n\tMOV\tBX,AX\r\n\tPOP\tAX\r\n\tCMP\tBYTE PTR 0[BX],LOW 0\t;set FLAGS.Z if null soft-key (and FLAGS.NC\r\n\tRET\t\t\t; not super shift)\r\nNTFKY1:\r\n\tJB\tNTFKY9\t\t;BRIF not super shift key\r\n\tPOP\tAX\r\n\tPUSH\tAX\r\n\tCMP\tAL,LOW \"A\"\r\n\tJB\tNTFKY9\t\t;BRIF not super shift key\r\n\tCMP\tAL,LOW OFFSET \"Z\"+1\r\n\tJB\tSUPRKY\t\t;BRIF is super shift key\r\nNTFKY9:\r\n\tPOP\tAX\r\nNTFKYX:\tXOR\tBL,BL\t\t;set FLAGS.Z - not soft-key(and FLAGS.NC not\r\n\tRET\t\t\t;super shift)\r\n\r\n\tEXTRN\tMAPSUP:NEAR,$FN:NEAR,$USR:NEAR,ALPTAB:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tF_SUPR:WORD\r\nDSEG\tENDS\r\nSUPRKY:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCURLIN:WORD\r\nDSEG\tENDS\r\n\tCMP\tWORD PTR CURLIN,65535D\t;Test for direct mode\r\n\tJNZ\tNTFKY9\t\t;Not direct mode - don't expand Supershift key\r\n\tPUSH\tCX\r\n\tCALL\tMAPSUP\t\t;Map super shift key to letter in AL and count\r\n\tXOR\tCL,CL\t\t;Interface doc says CH contains count\r\n\tJCXZ\tSUPKY9\t\t;Request to inhibit SKey expansion\r\n\tSUB\tAL,LOW \"A\"\t; in CH\r\n;Scan for CHth reserved word in table that includes words starting with letter\r\n;in AL\r\n;Set up for CONIN to return the reserved word letters one at a time and return\r\n;AL now.\r\n\tMOV\tBH,LOW 0\r\n\tMOV\tBL,AL\r\n\tADD\tBL,AL\r\n\tPUSH\tBX\t\t;Save ALPTAB offset\r\n\tADD\tBX,OFFSET ALPTAB\r\nSUPKY0:\r\n\tMOV\tBX,WORD PTR CS:0[BX]\t;Get start of reserved words for this letter\r\nSUPKY1:\r\n\tTEST\tBYTE PTR CS:0[BX],LOW 377O\r\n\tJZ\tSUPKYZ\t\t;BRIF did not find super key definition(abort)\r\n\tDEC\tCH\r\n\tJZ\tSUPKYX\t\t;BRIF found the reserved word\r\n\tDEC\tBX\r\nSUPKY2:\tINC\tBX\r\n\tTEST\tBYTE PTR CS:0[BX],LOW 377O\r\n\tJNS\tSUPKY2\t\t;BRIF not at the end of this reserved word\r\n\tINC\tBX\t\t;Skip end of string\r\n\tINC\tBX\t\t;Skip token value\r\n\tJMP\tSHORT SUPKY1\t;Check next reserved word\r\n;Found the reserved word\r\nSUPKYX:\tMOV\tWORD PTR CMDOFF,BX\t;Set up for string key input\r\n\tDEC\tCH\r\n\tMOV\tBYTE PTR F_SUPR,CH\t;Set super shift key flag\r\n\tPOP\tBX\r\nSUPKY9:\tPOP\tCX\r\n\tPOP\tAX\r\n\tOR\tAX,AX\t\t;Set FLAGS.NZ\r\n\tSTC\t\t\t;Else return AL=first char, FLAGS.NZ and\r\n\tRET\t\t\t;FLAGS.C When key not found then single char\r\n\t\t\t\t; returned as first expansion character.  No\r\n\t\t\t\t;expansion takes place since expansion table\r\n\t\t\t\t;not initialized.\r\n;Did not find reserved word in ALPTAB, perhaps its in ALPTAX\r\n\tEXTRN\tALPTAX:NEAR\r\nSUPKYZ:\tPOP\tBX\r\n\tOR\tBH,BH\r\n\tJNZ\tSUPKY9\t\t;BRIF already checked ALPTAX, exit\r\n\tPUSH\tCX\t\t;Put non-zero high byte on stack(so above\r\n\t\t\t\t; branch is taken)\r\n\tADD\tBX,OFFSET ALPTAX\r\n\tJMP\tSHORT SUPKY0\t;Continue scan of reserved words\r\n\r\n\r\n;GETFKY: Called to retrieve a character from the SOFTKEY buffer.\r\n;Supershift key strings are expanded to end in a space unless the last character\r\n; is a \"(\" or if the token is $FN or $USR.\r\n;\r\n; Entry - CMDOFF is the index into the buffer\r\n;         F.SUPR = ^O0   - not a supershift softkey\r\n;                  ^O377 - Supershift (CMDOFF points to character)\r\n;                  Other - Supershift (F.SUPR is the next character)\r\n; Exit  - flags.Z set   - no key available\r\n;                 reset - AL contains character\r\n;         BX is used.\r\n;\r\nGETFKY:\tCMP\tWORD PTR CMDOFF,0D\t;Softkey available?\r\n\tJZ\tGETFKX\t\t;No special key available\r\n\tCALL\tGTSFKY\t\t;Get a softkey\r\n\tCALL\tEOKTST\t\t;Test for end of softkey\r\nGETFKX:\tRET\t\r\n\r\nGTSFKY:\tMOV\tBX,WORD PTR CMDOFF\t;Get char. offset\r\n\tMOV\tAL,BYTE PTR F_SUPR\t;Get super-shift flag\r\n\tTEST\tAL,LOW 377O\t;Super-shift key in progress?\r\n\tJZ\tNOTSUP\t\t;Not a super-shift key\r\n\tCMP\tAL,LOW 377O\t;F.SUPR is ^O377 or current character\r\n\tJNZ\tGTSFKX\t\t;Got the key\r\n\t\t\t\t;Super-shifts are in the CS:\r\n\tDB\t2EH\t\t; Code segment override\r\nNOTSUP:\tMOV\tAL,BYTE PTR 0[BX]\t;Get next character\r\n\tXOR\tAH,AH\t\t;Clear high byte\r\n\tINC\tBX\t\t;Index to next key\r\nGTSFKX:\tRET\t\r\n\r\nEOKTST:\r\n\tTEST\tBYTE PTR F_SUPR,LOW 377O\t;Super-shift key expansion?\r\n\tJZ\tEFKTST\t\t;No - testing end of function key\r\n\tOR\tAL,AL\t\t;Test highbit (indicates end of key word)\r\n\tJNS\tNOHGBT\t\t;Not highbit terminated\r\n\tAND\tAL,LOW 177O\t;Map out high bit\r\n\tCMP\tAL,LOW \"(\"\t;Supershift key ending in \"(\"?\r\n\tJZ\tEOKTRU\t\t;Yes, don't end in space\r\n\tCMP\tBYTE PTR CS:0[BX],LOW OFFSET $USR\t;$USR token?\r\n\tJZ\tEOKTRU\t\t;Yes, don't end in space\r\n\tCMP\tBYTE PTR CS:0[BX],LOW OFFSET $FN\t;$FN token?\r\n\tJZ\tEOKTRU\t\t;Yes, don't end in space\r\n\tMOV\tBL,LOW \" \"\t;End in a space\r\n\tJMP\tSHORT EOKSSX\t; and exit\r\n\r\nNOHGBT:\tINC\tBYTE PTR F_SUPR\t;Test for last char. in F.SUPR\r\n\tDEC\tBYTE PTR F_SUPR\t;(Depends on 128 chars in keyword char. set)\r\n\tJS\tEOKTSX\t\t;Last char NOT from F.SUPR (F.SUPR was 377)\r\n\tJMP\tSHORT EOKTRU\t;Last char from F.SUPR - end of supershift\r\n\t\t\t\t;Test must always leave FLAGS.Z reset\r\nEFKTST:\tOR\tAL,AL\t\t;Test for null function key\r\n\tJZ\tEOKTRU\t\t;Null F key incountered\r\n\tTEST\tBYTE PTR 0[BX],LOW 377O\t;Test for end of function key\r\n\tJNZ\tEOKTSX\t\t;Not end of function key\r\n\tOR\tSP,SP\t\t;There is always a character at this point\r\nEOKTRU:\tMOV\tBX,0D\t\t;Prepare to turn off CMDOFF\r\nEOKSSX:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tF_SUPR:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR F_SUPR,BL\t;Turn off current supershift key expansion\r\nEOKTSX:\tMOV\tWORD PTR CMDOFF,BX\t;Store new softkey expansion index\r\n\tRET\t\r\n\r\n\r\n;SFTOFF - Turn off softkey expansion for the current softkey.  This routine\r\n;         has been documented to OEMs for use in implementing PEEK/POKE\r\n;         filters for addresses documented to IBM BASIC users.\r\n;\r\n\tPUBLIC\tSFTOFF\r\nSFTOFF:\tMOV\tWORD PTR CMDOFF,0D\t;Stop soft key expansion\r\n\tMOV\tBYTE PTR F_SUPR,LOW 0D\t;Turn off super shift flag\r\n\tRET\t\r\n\r\n;KYBSNS - Detect whether keys are available in the keyboard buffer.\r\n;         This routine has been documented to OEMs for use in implementation\r\n;         of PEEK/POKE filters for addresses documented to IBM BASIC users.\r\n;Entry - none\r\n;Exit  - PSW.Z set indicates that the keyboard buffer is empty.\r\n;        all registers preserved\r\n;\r\n\tPUBLIC\tKYBSNS\r\n\tEXTRN\tNUMQ:NEAR\r\nKYBSNS:\tPUSH\tAX\r\n\tPUSH\tSI\r\n\tMOV\tSI,OFFSET KYBQDS\t;SI = keyboard queue descriptor\r\n\tCALL\tNUMQ\t\t;Get the number of keys available\r\n\tOR\tAX,AX\t\t;Set flags\r\n\tPOP\tSI\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n;FKYSNS - Sense the availability of a softkey.  This routine is documented to\r\n;         IBMLIK OEMs for support of a PEEK/POKE address documented by IBM.\r\n;Entry - none\r\n;Exit  - PSW.C set indicates softkey expansion is in progress\r\n;        PSW.Z set indicates that the next softkey is not the last key\r\n;              of a supershift key.\r\n;        All registers preserved\r\n;\r\n\tPUBLIC\tFKYSNS\r\nFKYSNS:\tCMP\tBYTE PTR CMDOFF,LOW 0D\t;Test for expansion in progress\r\n\tJZ\tFKYSNX\t\t;Expansion not in progress\r\n\tCMP\tBYTE PTR F_SUPR,LOW 255D\t;Test for super-shift expansion\r\n\tJZ\tFKYSNW\t\t;SS key but not last key\r\n\tCMP\tBYTE PTR F_SUPR,LOW 0D\t;Test for super-shift expansion\r\n\tJZ\tFKYSNW\t\t;Function key expansion in progress\r\nFKYSNW:\r\n\tSTC\t\r\nFKYSNX:\tRET\t\r\n\tPAGE\t\r\n;INKEY$ - get key from key-queue if one exists, else return null string.\r\n; Returns 2-byte string for DBLCHR.  For function keys, returns next char\r\n; of function key if key is not null.  If F-key is null, it returns\r\n; 2-byte string which identifies function key.\r\n;\r\n\tPUBLIC\tINKEY\r\n\tEXTRN\tINKMAP:NEAR,INFMAP:NEAR\r\n\tEXTRN\tSTRINI:NEAR,STRIN1:NEAR,SETSTR:NEAR,PUTNEW:NEAR,CHRGTR:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDSCPTR:WORD,VALTYP:WORD,FACLO:WORD\r\nDSEG\tENDS\r\n\r\nINKEY:\tCALL\tCHRGTR\r\n\tPUSH\tBX\t\t;save text pointer\r\nINKGET:\tCALL\tCHSNS\t\t;get next key from queue\r\n\tJZ\tNULRT\t\t;branch if no key is queued\r\n\tCALL\tINKMAP\t\t;OEM map routine for INKEY$\r\n\tJZ\tINKGET\t\t;OEM has no associated character\r\n\tJAE\tINKEY1\t\t;branch if not 2-byte sequence\r\n\tPUSH\tAX\t\t;save char code\r\n\tMOV\tAL,LOW 2\r\n\tCALL\tSTRINI\t\t;initialize 2-byte string\r\n\tMOV\tBX,WORD PTR DSCPTR\r\n\tPOP\tDX\t\t;restore char code\r\n\tXCHG\tDH,DL\t\t;return high-byte in left end of string\r\n\tMOV\tWORD PTR 0[BX],DX\r\n\tJMP\tPUTNEW\r\nINKEY1:\tPUSH\tAX\r\n\tCALL\tSTRIN1\t\t;MAKE ONE CHAR STRING\r\n\tPOP\tAX\r\n\tMOV\tDL,AL\r\n\tXCHG\tAH,AL\t\t;put bytes in correct order\r\n\tCALL\tSETSTR\t\t;STUFF IN DESCRIPTOR AND GOTO PUTNEW\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDSEGZ:WORD\r\nDSEG\tENDS\r\nNULRT:\tMOV\tBX,OFFSET DSEGZ\t;GUARANTEED ZERO IN DATA SEGMENT\r\n\tMOV\tWORD PTR FACLO,BX\r\n\tMOV\tBYTE PTR VALTYP,LOW 3\r\n\tPOP\tBX\t\t;restore text pointer\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  Cursor Support\r\n\r\n;STCTYP Set the new cursor type\r\n;       This routine determines the next cursor type.\r\n;Entry - PSW.C set indicates the cursor must be the user cursor\r\n;        PSW.C reset indicates the cursor must be the insert mode\r\n;              cursor or the overstrike cursor.\r\n;EXIT  - All registers preserved\r\n;\r\n\tPUBLIC\tSTCTYP\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCSRTYP:WORD,F_INST:WORD\r\nDSEG\tENDS\r\nSTCTYP:\tPUSH\tAX\r\n\tMOV\tAL,LOW 3D\t;Assume user cursor\r\n\tJB\tCSRSET\t\t;Assumption correct\r\n\tDEC\tAL\t\t;Assume overwrite mode cursor\r\n\tTEST\tBYTE PTR F_INST,LOW 255D\t;Test for insert mode\r\n\tJZ\tCSRSET\t\t;Ovewrite mode discovered\r\n\tDEC\tAL\t\t;Set for insert mode\r\nCSRSET:\tMOV\tBYTE PTR CSRTYP,AL\t;Save the type\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n;SETCSR - Set the cursor to the new cursor type.\r\n;         This routine ensures that the cursor is set to the new cursor type.\r\n;Entry - none\r\n;Exit  - all registers preserved\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCSRTYP:WORD,CSRFLG:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tCSRDSP:NEAR\r\n\tPUBLIC\tSETCSR\r\nSETCSR:\tPUSH\tAX\r\n\tMOV\tAL,BYTE PTR CSRTYP\t;Get cursor type\r\n\tCMP\tBYTE PTR CSRFLG,AL\t;Test for cursor change\r\n\tMOV\tBYTE PTR CSRFLG,AL\t;Remember the new cursor type\r\n\tJZ\tCSROK\t\t;Cursor already set properly\r\n\tCALL\tCSRDSP\t\t;Display the cursor\r\nCSROK:\tPOP\tAX\r\n\tRET\t\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GIOLPT.ASM",
          "type": "blob",
          "size": 10.875,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GIOLPT - Line Printer Machine Independent Device Driver Code\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- ---------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT\r\n--------- --- ---- -- ---------\r\n\r\n\t*\r\n\tINCLUDE\tGIO86U\r\n\t.SALL\r\n\r\nMELCO=0\r\nTETRA=0\r\nZENITH=0\r\nCPM86=0\r\n\tINCLUDE\tMSDOSU\r\n\r\n;OEM Switches\r\n;\r\n\r\n\tPUBLIC\tLPTDSP,LPTINI,LPTTRM\r\n\tEXTRN\tDERBFM:NEAR,INIFDB:NEAR,UPDPOS:NEAR,$_LPT1:NEAR\r\n\tEXTRN\tDEVBOT:NEAR,DEVBIN:NEAR\r\n\r\n;Line Printer Dispatch Table\r\n;\r\nLPTDSP:\r\n\tDW\t(DERBFM)\t;test EOF for file opened to this device\r\n\tDW\t(DERBFM)\t;LOC\r\n\tDW\t(DERBFM)\t;LOF\r\n\tDW\t(LPTCLS)\t;perform special CLOSE functions for this device\r\n\tDW\t(LPTSWD)\t;set device width\r\n\tDW\t(DERBFM)\t;GET/PUT random record from/to this device\r\n\tDW\t(LPTOPN)\t;perform special OPEN functions for this device\r\n\tDW\t(DERBFM)\t;input 1 byte from file opened on this device\r\n\tDW\t(LPTSOT)\t;output 1 byte to file opened on this device\r\n\tDW\t(LPTGPS)\t;POS\r\n\tDW\t(LPTGWD)\t;get device width\r\n\tDW\t(LPTSCW)\t;set device comma width\r\n\tDW\t(LPTGCW)\t;get device comma width\r\n\tDW\t(DEVBIN)\t;block input from file opened on this device\r\n\tDW\t(DEVBOT)\t;block output to file opened on this device\r\n\r\nLPTTRM:\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL Line Printer Primitive I/O Routines\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tLP1DCB:WORD\r\nDSEG\tENDS\r\n\r\n;LPT Device Control Block field definitions:\r\n;\r\n\t_LPWID=0\t\t;device width (columns per line)\r\n\t_LPPOS=1\t\t;current column device is in\r\n\t_LPFLG=2\t\t;Boolean attributes mask for this device\r\n\t_LPCRF=1\t\t;non-zero=last char sent was Carriage Return\r\n\r\n;LPTINI - called during BASIC initialization\r\n; Entry - DI = -2*device id\r\n;\r\nLPTINI:\tPUSH\tDI\r\n\tCALL\tGLPDCB\t\t;DI points to device control block\r\n\tMOV\tBYTE PTR _LPWID[DI],LOW 80D\t;default width = 80 chars / line\r\n\tMOV\tBYTE PTR _LPPOS[DI],LOW 0\t;initial position = 0\r\n\tMOV\tBYTE PTR _LPFLG[DI],LOW 0\t;reset device Flags\r\n\tPOP\tDI\r\n\tRET\t\r\n\r\n;LPTCLS - perform any device dependent close functions.\r\n; Entry - SI points to File-Data-Block.\r\n;         DI = -2*device id\r\n; Exit  - All registers preserved.\r\n;         This routine is called before BASIC releases the\r\n;         file-data-block associated with this file.\r\n;\r\nLPTCLS:\tRET\t\r\n\r\n;LPTSWD - set device width\r\n; Entry - [DX] = new device width\r\n;         DI = -2*device id\r\n;\r\nLPTSWD:\r\n\tCALL\tGLPDCB\t\t;DI points to device control block\r\n\tMOV\tBYTE PTR _LPWID[DI],DL\r\n\tRET\t\r\n\r\n\tEXTRN\tDERIFN:NEAR,SCDBIN:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFILOPT:WORD\r\nDSEG\tENDS\r\n\r\n;LPTOPN - perform any device dependent open functions.\r\n; Entry - [AL]=  device id\r\n;                0 if default device,\r\n;                1..n for Disk A:, B:, ...\r\n;                -1..-n for non-disk devices\r\n;         [BX] = file number (0..n)\r\n;         [CX] = random record size if [FILMOD] = random\r\n;                (if [CX] = 0, use default record size)\r\n;         [DI] = device offset (2=LPTD, 4=SCRN, etc.)\r\n;         [FILMOD] = file mode (one of the following)\r\n;                    MD.SQI     ;sequential input\r\n;                    MD.SQO     ;sequential output\r\n;                    MD.RND     ;random\r\n;                    MD.APP     ;append\r\n;         [FILNAM] = filename\r\n;         [FILEXT] = 1..3 byte filename extension\r\n; Exit  - [SI] points to new FDB\r\n;         FDB is linked into FDB chain with all standard\r\n;         fields initialized.\r\n;         All other registers are preserved.\r\n;\r\nLPTOPN:\tPUSH\tAX\t\t;save device id for INIFDB\r\n\tCALL\tGLPDCB\t\t;DI points to device control block\r\n\tMOV\tSI,OFFSET FILOPT\t;SI points to options string\r\n\tMOV\tAH,LOW 337O\t;0DFH - Mask for mapping lower to upper case\r\n\tCLD\t\t\t;use Post-Increment addressing\r\n\tLODSB\t\t\t;[AL]=1st byte of option string\r\n\tAND\tAL,AH\t\t;Map Lower to Upper Case (turn off b6)\r\n\tPUSHF\t\t\t;remember if BIN option was selected\r\n\tJE\tNOOPT\t\t;branch if no option specified\r\n\tCMP\tAL,LOW \"B\"\r\n\tJNE\tIFNERR\t\t;Bad File Name error if option not BIN\r\n\tLODSB\t\t\t;[AL]=next byte of option string\r\n\tAND\tAL,AH\t\t;Map Lower Case to Upper Case\r\n\tCMP\tAL,LOW \"I\"\r\n\tJNE\tIFNERR\t\t;Bad File Name error if option not BIN\r\n\tLODSB\t\t\t;[AL]=next byte of option string\r\n\tAND\tAL,AH\t\t;Map Lower Case to Upper Case\r\n\tCMP\tAL,LOW \"N\"\r\n\tJNE\tIFNERR\t\t;Bad File Name error if option not BIN\r\n\tLODSB\t\t\t;[AL]=next byte of option string\r\n\tOR\tAL,AL\r\n\tJNE\tIFNERR\t\t;Error if not end of options\r\nNOOPT:\r\n\tMOV\tDH,BYTE PTR _LPPOS[DI]\t;initial file column position\r\n\tMOV\tDL,BYTE PTR _LPWID[DI]\t;initial file width\r\n\tPOPF\t\r\n\tPOP\tAX\t\t;[AL]=device id\r\n\tPUSHF\t\t\t;remember if BIN option was selected\r\n\tMOV\tAH,LOW OFFSET MD_SQO OR MD_RND\t;allow open for output/random\r\n\tCALL\tINIFDB\r\n\tPOPF\t\r\n\tJE\tNOBIN\t\t;branch if BIN option was not selected\r\n\tCALL\tSCDBIN\t\t;set BINARY file mode\r\nNOBIN:\r\n\tRET\t\r\n\r\nIFNERR:\tJMP\tDERIFN\t\t;\"illegal filename\" error\r\n\r\n;LPTSOT - Sequential Output.\r\n; Entry - SI points to File-Data-Block.  0 if Pseudo FDB (for LLIST/LPRINT)\r\n;         DI = -2*device id\r\n;         [AL] = byte to be output.\r\n; Exit  - SI, DI can be changed.\r\n;         All other registers preserved\r\n;         This routine keeps track of column position,\r\n;         expands tabs, and forces a carriage return when line width\r\n;         is exceeded.\r\n;\r\nLPTSOT:\tPUSH\tBX\t\t;save caller's BX\r\n\tPUSH\tAX\t\t;save char to be output\r\n\tCALL\tGLPDCB\t\t;DI points to line printer DCB\r\n\tMOV\tBL,AL\t\t;[BL] = device id\r\n\tPOP\tAX\t\t;[AL] = byte to be output\r\n\tMOV\tAH,BL\t\t;[AH] = device id\r\n\tPOP\tBX\t\t;restore caller's BX\r\n\tOR\tSI,SI\r\n\tJZ\tNOTBIN\t\t;branch if not binary mode\r\n\tCMP\tBYTE PTR F_CODE[SI],LOW OFFSET FC_BIN\r\n\tJE\tLPROUT\t\t;if binary, branch to Raw-Output routine\r\nNOTBIN:\tPUSH\tBX\r\n\tPUSH\tDX\r\n\tMOV\tDX,WORD PTR _LPWID[DI]\t;[DL]=device width, [DH]=current column\r\n\tMOV\tBX,OFFSET LPOUT1\t;BX points to Raw Output Routine\r\n\tJZ\tPSDFDB\t\t;branch if Pseudo FDB (LLIST/LPRINT)\r\n\t\t\t\t;*** CAREFUL *** FLAGS must be preserved\r\n\t\t\t\t; from OR SI,SI Above.\r\n\tMOV\tDL,BYTE PTR F_WID[SI]\t;Get width from FDB\r\nPSDFDB:\r\n\tEXTRN\tCRIFEL:NEAR\r\n\tCALL\tCRIFEL\t\t;force CR if End-Of-Line\r\n\tMOV\tBYTE PTR _LPPOS[DI],DH\t;save new column position\r\n\tPOP\tDX\r\n\tPOP\tBX\r\n\tRET\t\r\n\r\n;Low-Level Line Printer Output (updates column position)\r\n;For IBM Compatibility, the following filter performs the following translations\r\n;    x x x CR x x x    === x x x CR LF x x x\r\n;    x x x CR LF x x x === x x x CR LF x x x\r\n;If LPT was opened for RANDOM mode, and WIDTH=255, then suppress LF which\r\n;   follow carriage returns for IBM compatibility.\r\n;\r\n; Eat all LineFeeds which follow CarriageReturns with following algorithm:\r\n; if (Char <> LF) or (LastWasCR = 0) then output (Char)\r\n; if (Char = CR) then\r\n;    Begin\r\n;    LastWasCR = 1\r\n;    if FDB.MODE<>RANDOM or FDB.WIDTH<>255 then\r\n;       output(LF)\r\n;    End\r\n; else\r\n;    LastWasCR = 0\r\n;\r\n; The only case where this is not compatible with IBM is when the user executes:\r\n; PRINT CHR$(13);CHR$(10);...\r\n;\r\n; The best way this could have been done was by setting CRONLY=1 in the\r\n; switch files and letting the device drivers append Line-Feeds if necessary.\r\n; It was considered too late to make a change this drastic\r\n;\r\nLPOUT1:\tCALL\tUPDPOS\t\t;[DH]=new column position(AL, DH)\r\n\tPUSH\tAX\t\t;save character to be output\r\n\tCMP\tAL,LOW OFFSET ASCLF\r\n\tJNE\tLPOUT2\t\t;branch if not attempting to output LF\r\n\tTEST\tBYTE PTR _LPFLG[DI],LOW OFFSET _LPCRF\r\n\tJNE\tLPOUT3\t\t;brif last byte out was CR (eat LF)\r\nLPOUT2:\r\n\tCALL\tLPROUT\t\t;output the character\r\nLPOUT3:\r\n\tPOP\tAX\t\t;restore [AL]=char which was output\r\n\tAND\tBYTE PTR _LPFLG[DI],LOW OFFSET 255D-_LPCRF\t;reset last byte out was CR flag\r\n\tCMP\tAL,LOW OFFSET ASCCR\r\n\tJNE\tLPOUTX\t\t;return if wasn't carriage return\r\n\tOR\tBYTE PTR _LPFLG[DI],LOW OFFSET _LPCRF\t;set last byte out was CR flag\r\n\tOR\tSI,SI\r\n\tJZ\tOUTLF\t\t;branch if Pseudo FDB (LLIST/LPRINT)\r\n\tCMP\tBYTE PTR F_WID[SI],LOW 255D\r\n\tJNE\tOUTLF\t\t;output LF if width is not 255\r\n\tCMP\tBYTE PTR F_MODE[SI],LOW OFFSET MD_RND\r\n\tJE\tLPOUTX\t\t;suppress LF following CRs\r\nOUTLF:\r\n\tPUSH\tAX\r\n\tMOV\tAL,LOW OFFSET ASCLF\r\n\tCALL\tLPROUT\r\n\tPOP\tAX\r\nLPOUTX:\r\n\tRET\t\r\n\r\n;Raw Line Printer Output routine\r\n; Entry - [AL]=byte to be sent to current line printer\r\n;         [AH]=device id (0..n)\r\n; Exit  - Flags used, All other registers preserved.\r\n;\r\n\tEXTRN\tSNDLPT:NEAR,ERROR:NEAR,ERRDNA:NEAR,ERRDTO:NEAR,ERROTP:NEAR\r\n\tEXTRN\tERRDIO:NEAR\r\nLPROUT:\r\n\tPUSH\tAX\r\n\tCALL\tSNDLPT\t\t;Call OEM routine to output to printer\r\n\tOR\tAH,AH\r\n\tJNE\tLPERR\t\t;branch if OEM routine detected error\r\n\tPOP\tAX\r\n\tRET\t\r\nLPERR:\r\n\tMOV\tAL,AH\r\n\tXOR\tAH,AH\t\t;[AX]=error code 1..n\r\n\tDEC\tAX\t\t;[AX]=error code 0..n\r\n\tMOV\tDI,OFFSET LPERRT\r\n\tADD\tDI,AX\t\t;[DI] points to BASIC Error code\r\n\tMOV\tDL,BYTE PTR CS:0[DI]\r\n\tCMP\tAL,LOW 3\r\n\tJB\tERROR1\t\t;branch if legal error code\r\n\tMOV\tDL,LOW OFFSET ERRDIO\t;map all other error codes to I/O error\r\nERROR1:\tJMP\tERROR\r\n\r\nLPERRT:\tDB\tOFFSET ERRDNA\r\n\tDB\tOFFSET ERRDTO\r\n\tDB\tOFFSET ERROTP\r\n\r\n;LPOS(X) function\r\n;\r\n\tPUBLIC\tLPOS\r\n\tEXTRN\tSNGFLT:NEAR,CONINT:NEAR\r\nLPOS:\tPUSH\tBX\r\n\tCALL\tCONINT\t\t;Force FAC to byte integer in AL\r\n\tCBW\t\r\n\tOR\tAX,AX\t\t;Test for LPT number 0 to map to 1\r\n\tJZ\tLPTN0\t\t;n = 0, so map to 1\r\n\tDEC\tAX\r\n\tSHR\tAX,1\t\t;Offset to correct DCB\r\nLPTN0:\tMOV\tBX,OFFSET LP1DCB+_LPPOS\t;Get address of LPOS in first LPT DCB\r\n\tADD\tBX,AX\t\t;Get address of LPOS in current LPT DCB\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;[AL]=current 0 relative position\r\n\tINC\tAL\t\t;return 1 relative number\r\n\tPOP\tBX\r\n\tJMP\tSNGFLT\t\t;return result to user\r\n\r\n;LPTGPS - return current file position.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [AH] = current file column. (0-relative)\r\n;         All other registers preserved\r\n;\r\nLPTGPS:\tCALL\tGLPDCB\t\t;DI points to device control block\r\n\tMOV\tAH,BYTE PTR _LPPOS[DI]\r\n\tRET\t\r\n\r\n;LPTGWD - get device width\r\n; Entry - DI = -2*device id\r\n; Exit  - [AH] = device width as set by xxxSWD\r\n;         All other registers preserved\r\n;\r\nLPTGWD:\tCALL\tGLPDCB\t\t;DI points to device control block\r\n\tMOV\tAH,BYTE PTR _LPWID[DI]\r\n\tRET\t\r\n\r\n;LPTSCW - set device comma width\r\n; Entry - [BX] = new device comma width\r\n;         DI = -2*device id\r\n; Exit  - SI, DI can be changed.\r\n;         All other registers preserved\r\n;\r\nLPTSCW:\tRET\t\r\n\r\n;LPTGCW - get device comma width\r\n; Entry - DI = -2*device id\r\n; Exit  - [BX] = device comma width as set by xxxSCW\r\n;         All other registers preserved\r\n;\r\nLPTGCW:\tRET\t\r\n\r\n;GLPDCB - get pointer to line printer device control block\r\n; Entry - [DI] = -2*device id (2,4,..n)\r\n; Exit  - DI points to the device control block for device DI.\r\n;         [AX] = 0..n for LPT1, LPT2, ...\r\n;\r\n;************************************************************************\r\n;* Note: IF LPT DCB size changes from 4, this routine should be changed *\r\n;************************************************************************\r\n;\r\nGLPDCB:\r\n\tMOV\tAX,OFFSET ($_LPT1-400O)\t;[AX]=-device id for LPT1\r\n\tSHL\tAX,1\t\t;[AX]=-2*device id for LPT1\r\n\tADD\tAX,DI\t\t;[AX]=0, 2, ... for LPT1, LPT2, ...\r\n\tMOV\tDI,AX\t\t;[DI]=0, 2, ... for LPT1, LPT2, ...\r\n\tSHL\tDI,1\t\t;[DI]=0, 4, ... for LPT1, LPT2, ...\r\n\tSHR\tAX,1\t\t;[AX]=0, 1, ... for LPT1, LPT2, ...\r\n\tADD\tDI,OFFSET LP1DCB\t;[DI] points to LPTx device ctl block\r\n\tRET\t\r\n;\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GIOSCN.ASM",
          "type": "blob",
          "size": 9,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GIOSCN - Screen Machine Independent Device Driver Code\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- ---------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT\r\n--------- --- ---- -- ---------\r\n\r\n\t*\r\n\tINCLUDE\tGIO86U\r\n\t.SALL\r\n\r\nCPM86=0\t\t\t\t;CPM86 Operating System\r\nIBMCSR=IBMLIK\t\t\t;IBM compatibile cursor control interface\r\n\r\n;Definition of scroll types\r\n; Choice of scroll type is by switch SCROLT.\r\n; Switches defined here are used to implement a specific SCROLT type.\r\n; If other scroll types are needed then additional SCROLT types should be\r\n;   defined here.\r\n\tINVLIN=SCROLT\t\t;Invisible (function key) Line\r\n\tFKFSRL=(SCROLT-1) AND 1\t;Clear fkeys/full scroll/rewrite fkeys\r\n\r\n\tINCLUDE\tMSDOSU\t\t;Operating System Constants\r\n\r\n\tPUBLIC\tSCNDSP,SCNINI,SCNTRM\r\n\tEXTRN\tDERBFM:NEAR,INIFDB:NEAR\r\n\tEXTRN\tDEVBIN:NEAR,DEVBOT:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tTWOBYT:WORD\r\nDSEG\tENDS\r\n\r\n;Screen Dispatch Table\r\n;\r\nSCNDSP:\r\n\tDW\t(DERBFM)\t;test EOF for file opened to this device\r\n\tDW\t(DERBFM)\t;LOC\r\n\tDW\t(DERBFM)\t;LOF\r\n\tDW\t(SCNCLS)\t;perform special CLOSE functions for this device\r\n\tDW\t(SCNSWD)\t;set device width\r\n\tDW\t(DERBFM)\t;GET/PUT random record from/to this device\r\n\tDW\t(SCNOPN)\t;perform special OPEN functions for this device\r\n\tDW\t(DERBFM)\t;input 1 byte from file opened on this device\r\n\tDW\t(SCNSOT)\t;output 1 byte to file opened on this device\r\n\tDW\t(SCNGPS)\t;POS\r\n\tDW\t(SCNGWD)\t;get device width\r\n\tDW\t(SCNSCW)\t;set device comma width\r\n\tDW\t(SCNGCW)\t;get device comma width\r\n\tDW\t(DEVBIN)\t;block input from file opened on this device\r\n\tDW\t(DEVBOT)\t;block output to file opened on this device\r\n\tPUBLIC\tSCNSWD,SCNSOT,SCNGPS,SCNGWD,SCNSCW,SCNGCW\r\n\tPAGE\t\r\n\tSUBTTL CRT Primitive I/O Routines\r\n\r\n;SCNINI is called to initialize Screen when BASIC comes up\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tWDTFLG:WORD\r\nDSEG\tENDS\r\nSCNINI:\r\n\tMOV\tAL,BYTE PTR LINLEN\t; Get CRT logical line length\r\n\tMOV\tBYTE PTR WDTFLG,AL\t; Default width of device SCRN:\r\n\tRET\t\r\n\r\n;SCNTRM is called to Clean-up Screen when BASIC terminates\r\n;\r\n\tEXTRN\tTKEYOF:NEAR\r\nSCNTRM:\tCALL\tTKEYOF\t\t;Turn off KEY display\r\n\tEXTRN\tSCNPOS:NEAR\r\n\tCALL\tSCNPOS\t\t;[DX]=current cursor location\r\n\tRET\t\r\n\r\n;SCNCLS - perform any device dependent close functions.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - All registers preserved.\r\n;         This routine is called before BASIC releases the\r\n;         file-data-block associated with this file.\r\n;\r\nSCNCLS:\tRET\t\r\n\r\n;SCNSWD - set device width\r\n; Entry - [DX] = new device width\r\n; Exit  - All registers preserved\r\n;\r\nSCNSWD:\r\n\tEXTRN\tSWIDTH:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tLINCNT:WORD,WDTFLG:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR WDTFLG,DL\t;Set/Reset infinite length flag\r\n\tCMP\tDL,LOW 255D\r\n\tJNZ\tSCNWD1\t\t;BRIF not infinite length\r\n\tRET\t\r\nSCNWD1:\tPUSH\tCX\r\n\tPUSH\tAX\r\n\tMOV\tAL,DL\t\t;pass Width in AL\r\n\tMOV\tCL,BYTE PTR LINCNT\t;pass Height in CL\r\n\tCALL\tSWIDTH\t\t;Let screen editor set width\r\n\tPOP\tAX\r\n\tPOP\tCX\r\n\tRET\t\r\n\r\n;SCNOPN - perform any device dependent open functions.\r\n; Entry - [AL]=  device id\r\n;                0 if default device,\r\n;                1..n for Disk A:, B:, ...\r\n;                -1..-n for non-disk devices\r\n;         [BX] = file number (0..n)\r\n;         [CX] = random record size if [FILMOD] = random\r\n;                (if [CX] = 0, use default record size)\r\n;         [DI] = device offset (2=SCND, 4=SCRN, etc.)\r\n;         [FILMOD] = file mode\r\n;                    MD.SQI = 1 ;sequential input\r\n;                    MD.SQO = 2 ;sequential output\r\n;                    MD.RND = 3 ;random\r\n;                    MD.APP = 4 ;append\r\n;         [FILNAM] = filename\r\n;         [FILEXT] = 1..3 byte filename extension\r\n; Exit  - [SI] points to new FDB\r\n;         FDB is linked into FDB chain with all standard\r\n;         fields initialized.\r\n;         All other registers are preserved.\r\n;\r\nSCNOPN:\r\n\tCALL\tSCNGPS\t\t;[AH]=current column position\r\n\tMOV\tDH,AH\t\t;[DH]=current column position\r\n\tMOV\tAH,LOW OFFSET MD_SQO\t;allow open for output only\r\n\tMOV\tDL,BYTE PTR WDTFLG\t;initial file logical width\r\n\tJMP\tINIFDB\r\n\r\n\tPUBLIC\tCALTTY,$CATTY\r\n\r\n;CALTTY IS A SPECIAL ROUTINE TO OUTPUT ERROR MESSAGE TO TTY, REGARDLESS\r\n;   OF CURRENT FILE I/O.\r\n; Entry - [AL] = byte to be output\r\n; Exit  - All registers preserved\r\n;\r\n\tEXTRN\tOUTDO:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tPTRFIL:WORD\r\nDSEG\tENDS\r\n$CATTY:\r\nCALTTY:\tPUSH\tWORD PTR PTRFIL\r\n\tMOV\tWORD PTR PTRFIL,0\t;Make sure we go to the \"TTY\"\r\n\tCALL\tOUTDO\r\n\tPOP\tWORD PTR PTRFIL\r\n\tRET\t\r\n\r\n;SCNSOT - Sequential Output.\r\n; Entry - SI points to File-Data-Block.\r\n;         [AL] = byte to be output.\r\n; Exit  - SI, DI can be changed.\r\n;         All other registers preserved\r\n;         This routine expands tabs if appropriate.\r\n;         It need not force a carriage return when width\r\n;         exceeded as this is handled at a lower level.\r\n;\r\nSCNSOT:\r\n\tEXTRN\tSCNOUT:NEAR\r\n\tPUSHF\t\r\n\tPUSH\tAX\r\n\r\n;If last char SCNSOT was called with was the 1st byte of a 2-byte char,\r\n; SCNSOT saved it in TWOBYT so they be both output as one 16-bit character.\r\n;\r\n\tMOV\tAH,BYTE PTR TWOBYT\t;If two byte, put first in [AH]\r\n\tOR\tAH,AH\r\n\tJZ\tSCNSO1\t\t;BRIF not second of two bytes\r\n\tMOV\tBYTE PTR TWOBYT,LOW 0\t;Clear TWOBYT flag\r\n\tJMP\tSHORT SCNSO3\t;Output both bytes at once\r\nSCNSO1:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tF_EDIT:WORD\r\nDSEG\tENDS\r\n\tTEST\tBYTE PTR F_EDIT,LOW 377O\r\n\tJZ\tSCNS1A\t\t;BRIF not in editor, don't collect FF codes\r\n\tCMP\tAL,LOW 255D\r\n\tJZ\tSCNS1B\t\t;BRIF is first of two bytes\r\nSCNS1A:\r\n\tJMP\tSHORT SCNSO2\t;branch if not 1st of 2-bytes\r\nSCNS1B:\r\n\tMOV\tBYTE PTR TWOBYT,AL\t;save char for next time\r\n\tJMP\tSHORT SCNSOX\t;Set two byte flag and return\r\nSCNSO2:\r\n\tXOR\tAH,AH\t\t;clear high-byte (not 2-byte char)\r\nSCNSO3:\tCALL\tSCNOL1\r\nSCNSOX:\tPOP\tAX\r\n\tPOPF\t\r\n\tRET\t\r\n\r\n;SCNSOT level 1\r\n; Outputs AX, destroys AX\r\n;\r\nSCNOL1:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tLSTCHR:WORD\r\nDSEG\tENDS\r\n;For IBM Compatibility, the following filter performs the following translations\r\n;    x x x CR x x x    === x x x CR LF x x x\r\n;    x x x CR LF x x x === x x x CR LF x x x\r\n;\r\n;    If (Char = CR) then\r\n;       output CR : output LF\r\n;    else if (char <> LF) or (LSTCHR <> CR) then\r\n;       output char\r\n;    else\r\n;       {eat the LF which follows a CR}\r\n;    LSTCHR = CHR\r\n;\r\n\tCMP\tBYTE PTR LSTCHR,LOW OFFSET ASCCR\r\n\tMOV\tBYTE PTR LSTCHR,AL\t;save this char for comparison with next\r\n\tJNE\tNTCRLF\t\t;branch if not LF after CR\r\n\tCMP\tAL,LOW OFFSET ASCLF\r\n\tJE\tRET22\t\t;eat LF if it follows CR\r\nNTCRLF:\r\n\tPUSH\tAX\r\n\tCALL\tSCNOL2\t\t;output this char\r\n\tPOP\tAX\r\n\tCMP\tAL,LOW OFFSET ASCCR\r\n\tJNE\tRET22\t\t;if not CR, just output char\r\n\tMOV\tAX,OFFSET ASCLF\t;else map CR to CR LF\r\n\tCALL\tSCNOL2\r\nRET22:\tRET\t\r\n\r\n;SCNSOT level 2\r\n; Output [AX], destroys AX\r\n;\r\nSCNOL2:\r\n\tOR\tSI,SI\r\n\tJZ\tSCNSO8\t\t;BRIF is not file I/O\r\n\tCMP\tAL,LOW OFFSET ASCCR\r\n\tJZ\tSCNSO8\t\t;BRIF CR, don't do wrap\r\n\tPUSH\tAX\t\t;save char to be output\r\n\tMOV\tAL,BYTE PTR CSRX\r\n\tOR\tAH,AH\t\t;see if 2-byte char\r\n\tJZ\tSCNSO4\t\t;BRIF not DBLCHR\r\n\tINC\tAL\t\t;Need two char posns for DBLCHR\r\nSCNSO4:\r\n\tCMP\tAL,BYTE PTR F_WID[SI]\t;Compare posn with file width\r\n\tJA\tSCNSCR\t\t;Beyond max, force CR\r\n\tCMP\tAL,BYTE PTR LINLEN\r\n\tJBE\tSCNSO7\t\t;Within line, go ahead and output\r\n\tDEC\tAL\r\n\tMOV\tBYTE PTR CSRX,AL\t;Make sure there's room before end of line\r\nSCNSO7:\tPOP\tAX\t\t;restore char to be output\r\nSCNSO8:\r\n\tJMP\tSCNOUT\t\t;Output the char in [AX] and return\r\n\r\n\r\nSCNSCR:\tCMP\tAL,BYTE PTR LINLEN\r\n\tJZ\tSCNSO7\t\t;BRIF file width .EQ. device width, use wrap code\r\n\tMOV\tAX,OFFSET ASCCR\r\n\tCALL\tSCNOUT\t\t;Force new line\r\n\tMOV\tAX,OFFSET ASCLF\r\n\tCALL\tSCNOUT\r\n\tJMP\tSHORT SCNSO7\t;Output the character\r\n\r\n\r\n;POS(X) function\r\n;\r\n\tPUBLIC\tPOS\r\n\tEXTRN\tSNGFLT:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tLINLEN:WORD\r\nDSEG\tENDS\r\nPOS:\tMOV\tAL,BYTE PTR CSRX\t;[AL]=current 1 relative position\r\n\tCMP\tAL,BYTE PTR LINLEN\r\n\tJBE\tPOS0\t\t;BRIF not beyond end of line\r\n\tMOV\tAL,LOW 1\t;Else next char will go in first column\r\nPOS0:\tJMP\tSNGFLT\t\t;return result to user\r\n\r\n;SCNGPS - return current file position.\r\n; Entry - SI points to File-Data-Block.\r\n; Exit  - [AH] = current file column. (0-relative)\r\n;         All other registers preserved\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCSRX:WORD\r\nDSEG\tENDS\r\nSCNGPS:\tMOV\tAH,BYTE PTR CSRX\r\n\tPUSHF\t\r\n\tCMP\tAH,BYTE PTR LINLEN\r\n\tJBE\tSCNGP1\t\t;BRIF not beyond edge of screen\r\n\tMOV\tAH,BYTE PTR LINLEN\t;Force posn within screen\r\nSCNGP1:\tPOPF\t\r\n\tDEC\tAH\t\t;Make it 0 relative\r\n\tRET\t\r\n\r\n;SCNGWD - get device width\r\n; Exit  - [AH] = device width as set by xxxSWD\r\n;         All other registers preserved\r\n;\r\nSCNGWD:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tLINLEN:WORD\r\nDSEG\tENDS\r\n\tMOV\tAH,BYTE PTR LINLEN\r\n\tOR\tSI,SI\r\n\tJZ\tSCNGWX\t\t;BRIF not file I/O, use device width\r\n\tMOV\tAH,BYTE PTR F_WID[SI]\t;Is file I/O, use FDB width\r\nSCNGWX:\tRET\t\r\n\r\n;SCNSCW - set device comma width\r\n; Entry - [BX] = new device comma width\r\n; Exit  - SI, DI can be changed.\r\n;         All other registers preserved\r\n;\r\nSCNSCW:\tRET\t\r\n\r\n;SCNGCW - get device comma width\r\n; Exit  - [BX] = device comma width as set by xxxSCW\r\n;         All other registers preserved\r\n;\r\nSCNGCW:\tRET\t\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GIOTBL.ASM",
          "type": "blob",
          "size": 3,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GIOTBL - Device Name Table, Dispatch Table Address Tables\r\n;                Initialization and Termination Dispatch Tables\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- ---------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT\r\n--------- --- ---- -- ---------\r\n\r\n        *\r\n\tINCLUDE\tGIO86U\r\n\t.SALL\r\n\r\n\tINCLUDE\tMSDOSU\t\t;MSDOS Constant Definitions\r\nIF\tCPM86  \r\n\tINCLUDE\tCPM86U\t\t;CPM86 Constant Definitions\r\nENDIF \r\n\r\n\t.RADIX\t10\r\n\r\nCPM86=0\t\t\t\t;CPM86\r\n\r\n;Device Switches\r\n\r\n\r\n\tPUBLIC\t_DVTBL,_DVPTR,_DVINI,_DVTRM,$_NDEV\r\n\r\n\tEXTRN\tDSKDSP:NEAR\r\n\tEXTRN\tKYBDSP:NEAR,KYBINI:NEAR,KYBTRM:NEAR\r\n\tEXTRN\tSCNDSP:NEAR,SCNINI:NEAR,SCNTRM:NEAR\r\n\tEXTRN\tLPTDSP:NEAR,LPTINI:NEAR,LPTTRM:NEAR\r\n\tEXTRN\tCOMDSP:NEAR,COMINI:NEAR,COMTRM:NEAR\r\n\tEXTRN\tCONDSP:NEAR,_RET:NEAR\r\n\tPAGE\t\r\n\tSUBTTL  Device name table\r\n\r\n;*****************************************************************\r\n;***                                                            ***\r\n;***  Note:                                                     ***\r\n;***    When adding additional devices, be sure to update       ***\r\n;***    OEMRAM to add device control blocks if necessary.       ***\r\n;***    Change $1STSD and $LSTSD if necessary.  Change NMCOMT   ***\r\n;***    in switch file if adding COM device.                    ***\r\n;***                                                            ***\r\n;******************************************************************\r\n\r\nNDEV\tMACRO\tNAM,DSPADR,INIADR,TRMADR,N\r\n\tDEV\tNAM&N,DSPADR,INIADR,TRMADR\r\nENDM \r\n\r\nNAMES\tMACRO\t\r\n\tDEV\tKYBD,KYBDSP,KYBINI,KYBTRM\t;Keyboard\r\n\tDEV\tSCRN,SCNDSP,SCNINI,SCNTRM\t;Crt\r\n\tDEV\tCONS,CONDSP,_RET,_RET\t;Raw-I/O Crt (Esc Sequences)\r\n\tNLPT=0\r\nREPT\tNMLPT\r\n\tNLPT=NLPT+1\r\n\tNDEV\tLPT,LPTDSP,LPTINI,LPTTRM,%NLPT\t;Line printer\r\nENDM \r\n\tNCAS=0\r\nREPT\tGWCASS\r\n\tNCAS=NCAS+1\r\n\tNDEV\tCAS,CASDSP,CASINI,CASTRM,%NCAS\t;Line printer\r\nENDM \r\n\tNCOM=0\r\nREPT\tNMCOMT\r\n\tNCOM=NCOM+1\r\n\tNDEV\tCOM,COMDSP,COMINI,COMTRM,%NCOM\t;COM channel NCOM\r\nENDM \r\nENDM \r\n\r\n\r\n;Generate DEVTBL ( text followed by device # )\r\n;\r\n\tNUM=377O\r\nDEV\tMACRO\tNAM,DSPADR,INIADR,TRMADR\r\n\tPUBLIC\t$_&NAM\r\n\t$_&NAM=NUM\r\n        DB      \"&NAM&\"\r\n\tDB\tOFFSET NUM\r\n\tNUM=NUM-1\r\nENDM \r\n_DVTBL:\r\n\tNAMES\t\r\n\tDB\t0\t\t;0 ends table\r\n\r\n\t$_NDEV=377O-NUM\t\t;number of non-disk Devices\r\n\r\n;Generate DEVPTR ( Addresses of dispatch tables )\r\n;\r\nDEV\tMACRO\tNAM,DSPADR,INIADR,TRMADR\r\n\tDW\tOFFSET DSPADR\r\nENDM \r\n_DVPTR:\r\n\tDW\t(DSKDSP)\t;1st entry in dispatch table is Disk Dispatch table\r\n\tNAMES\t\t\t;then 1 entry for each device\r\n\r\n;Generate Initialization Dispatch table\r\n;\r\nDEV\tMACRO\tNAM,DSPADR,INIADR,TRMADR\r\n\tDW\tOFFSET INIADR\r\nENDM \r\n_DVINI:\r\n\tNAMES\t\t\t;address of initialization routine for each device\r\n\r\n;Generate Termination Dispatch table\r\n;\r\nDEV\tMACRO\tNAM,DSPADR,INIADR,TRMADR\r\n\tDW\tOFFSET TRMADR\r\nENDM \r\n_DVTRM:\r\n\tNAMES\t\t\t;address of termination routine for each device\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\r\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GWDATA.ASM",
          "type": "blob",
          "size": 36.75,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tBINTRP.H \r\n\r\n\tTITLE   GWDATA copied from BINTRP.MAC\r\n\r\n\t.RADIX\t10\r\n\r\n\t.XLIST\r\n\r\nSLASHI=0\t\t\t;Runtime Switch to include IBM Compat.-Features\r\nFETOK=0\t\t\t\t;For FE extended tokens\r\nFDTOK=0\t\t\t\t;For FD tokens too.  (Must have\r\n\t\t\t\t;FETOK==1.)\r\n\t\t\t\t;tokens.\r\nINTDEX=0\t\t\t;For Intelledex version.\r\nNMPAGE=1\t\t\t;Number of text pages (for GW\r\n\t\t\t\t;Multi-page)\r\n\t\t\t\t;KPOS, etc.\r\nLNREAD=0\t\t\t;For LINE READ statement\r\nMELCO=0\t\t\t\t;Mitsubishi Electronics Co.\r\nSIRIUS=0\r\nMCI=0\r\nZENITH=0\t\t\t;ZENITH 8086\r\nTETRA=0\r\nCPM86=0\r\nHAL=0\r\nGENFLS=0\r\nPANDBL=0\r\nTSHIBA=0\r\nSGS=0\r\nALPS=0\r\nALPCPM=0\r\nGENWID=0\r\nNNECBS=0\r\nCAN8=0\r\nPC8A=0\r\n\r\n\tFN2SW=0\t\t\t;IBMTOK versions dispatch from IBMRES.MAC\r\n\tLABEL=PC8A\r\n\tHLPEDT=PC8A\r\n\r\nOKI=0\r\nBUBL=0\r\n\tNORNF=0\r\nIEESLV=0\r\nTRSHHC=0\r\nOLVPPC=0\r\nNECPPC=0\r\nUSA=0\t\t\t\t;For HHC-USA version\r\nEUROPE=0\t\t\t;For HHC-EUROPE version\r\n\t.LIST\r\n\r\n;Local Switches\r\n;\r\n\tLTRACE=ALPCPM\t\t;trace output selectable\r\n\tLABEL=PC8A\r\n\tHLPEDT=PC8A\r\n\tUCEMSG=NNECBS\t\t;Upper case error messages.\r\n\tOLD86=MELCO AND CPM86\t;For \"old\" 8086 error messages (prior\r\n\t\t\t\t;to alignment for IBM compatibility).\r\n\r\n\tOLDBLD=ALPCPM OR ALPS OR OKI OR HAL OR PC8A OR BUBL OR GW OR TSHIBA\r\n\r\n\tINCLUDE\tGIO86U\r\n\tINCLUDE\tMSDOSU\t\t;MSDOS constants\r\n\r\n\tEXTRN\t_DVTBL:NEAR,_DVPTR:NEAR,_DVINI:NEAR,_DVTRM:NEAR\r\n\tEXTRN\tINIT:NEAR,INTDIV:NEAR,CONCON:NEAR,CONCN2:NEAR\r\n\r\n\r\n\r\n\tBUFOFS=0\r\n\r\n\tBUFOFS=2\t\t;MUST CRUNCH INTO ERALIER PLACE FOR\r\n\t\t\t\t; SINGLE QUOTE\r\n\r\n\tKBFLEN=BUFLEN+(BUFLEN/4)\t;MAKE KRUNCH BUFFER SOMEWHAT\r\n\t\t\t\t; LARGER THAN SOURCE BUFFER (BUF)\r\n\r\n\tEXTRN\tNAME:NEAR\r\n\r\n\tEXTRN\tINLIN:NEAR,CRDO:NEAR,CRDONZ:NEAR,STRCMP:NEAR,FININL:NEAR\r\n\tEXTRN\tPPSWRT:NEAR\r\n\r\n\tEXTRN\tOUTDO:NEAR\r\n\r\n\tEXTRN\tBLTU:NEAR,BLTUC:NEAR,CLEAR:NEAR,CLEARC:NEAR,GTMPRT:NEAR\r\n\tEXTRN\tISLET:NEAR,ISLET2:NEAR,PTRGET:NEAR\r\n\tEXTRN\tQINLIN:NEAR,SCRTCH:NEAR,STKINI:NEAR,RUNC:NEAR,RESFIN:NEAR\r\n\tEXTRN\tPTRGT2:NEAR,STPEND:NEAR,DIM:NEAR\r\n\r\n\tEXTRN\tDCOMPR:NEAR,SYNCHR:NEAR\r\n\r\n\tEXTRN\tSIGN:NEAR\r\n\r\n\tEXTRN\tOPEN:NEAR,CLOSE:NEAR,PRGFIN:NEAR,FILIND:NEAR\r\n\r\n\tEXTRN\tFILINP:NEAR,CLSALL:NEAR,INDSKC:NEAR\r\n\r\n\r\n\tEXTRN\tLRUN:NEAR\r\n\r\n\tEXTRN\tFILGET:NEAR\r\n\r\n\r\n\tEXTRN\tINXHRT:NEAR\r\n\tEXTRN\tSGN:NEAR,ABSFN:NEAR,SQR:NEAR,FDIV:NEAR,FSUB:NEAR\r\n\tEXTRN\tFMULT:NEAR,RND:NEAR\t;MATHPK INTERNALS\r\n\tEXTRN\tZERO:NEAR,MOVE:NEAR,FOUT:NEAR,FIN:NEAR,FCOMP:NEAR\r\n\tEXTRN\tFADD:NEAR,PUSHF:NEAR,INT:NEAR\r\n\tEXTRN\tENDST:NEAR,NEXT:NEAR,RESTORE:NEAR,SCRATH:NEAR,CONT:NEAR\r\n\tEXTRN\tFRE:NEAR\r\n\tEXTRN\tMOVFR:NEAR,MOVRF:NEAR,MOVRM:NEAR,INPRT:NEAR,LINPRT:NEAR\r\n\tEXTRN\tFDIVT:NEAR\r\n\tEXTRN\tMOVFM:NEAR,MOVMF:NEAR,FADDS:NEAR\r\n\tEXTRN\tINRART:NEAR,NEG:NEAR\r\n\tEXTRN\tBSERR:NEAR\r\n\tEXTRN\tCAT:NEAR,FREFAC:NEAR,FRESTR:NEAR,FRETMP:NEAR,FRETMS:NEAR\r\n\tEXTRN\tSTRCPY:NEAR,GETSTK:NEAR\r\n\tEXTRN\tSTRLIT:NEAR,STRLT2:NEAR,STRLT3:NEAR,STRLTI:NEAR,STROUT:NEAR\r\n\tEXTRN\tSTRPRT:NEAR,STROUI:NEAR\r\n\tEXTRN\tGETSPA:NEAR,PUTNEW:NEAR,STOP:NEAR,OMERR:NEAR,REASON:NEAR\r\n\r\n\tEXTRN\tGARBA2:NEAR\t;We have our own G. C.\r\n\r\n\r\n\tEXTRN\tINSTR:NEAR\r\n\r\n\tEXTRN\tPRINUS:NEAR,PUTTMP:NEAR\r\n\r\n\tEXTRN\tFOUTH:NEAR,FOUTO:NEAR,STRO$:NEAR,STRH$:NEAR\r\n\r\n\tEXTRN\tSTR$:NEAR,LEN:NEAR,ASC:NEAR,CHR$:NEAR,LEFT$:NEAR\r\n\tEXTRN\tRIGHT$:NEAR,MID$:NEAR,VAL:NEAR\r\n\r\n\r\n\tEXTRN\tSTRNG$:NEAR\r\n\tEXTRN\tTON:NEAR,TOFF:NEAR\r\n\tEXTRN\tSPACE$:NEAR\r\n\r\n\tEXTRN\tSIGNS:NEAR\r\n\r\n\r\n\r\n\r\n\tEXTRN\tUMULT:NEAR\r\n\r\n\tEXTRN\tSIGNC:NEAR,POPHRT:NEAR\r\n\r\n\tEXTRN\tFINLPT:NEAR\r\n\r\n\tEXTRN\tCONSIH:NEAR,VMOVFA:NEAR,VMOVAF:NEAR,ISIGN:NEAR,CONIA:NEAR\r\n\tEXTRN\tVSIGN:NEAR,VDFACS:NEAR\r\n\tEXTRN\tVMOVMF:NEAR,VMOVFM:NEAR,FRCINT:NEAR,FRCSNG:NEAR,FRCDBL:NEAR\r\n\tEXTRN\tVNEG:NEAR,PUFOUT:NEAR,DCXBRT:NEAR,IADD:NEAR\r\n\tEXTRN\tISUB:NEAR,IMULT:NEAR,ICOMP:NEAR,INEG:NEAR,DADD:NEAR\r\n\tEXTRN\tDSUB:NEAR,DMULT:NEAR,DDIV:NEAR,DCOMP:NEAR,VINT:NEAR\r\n\tEXTRN\tFINDBL:NEAR,INEG2:NEAR\r\n\tEXTRN\tIDIV:NEAR,IMOD:NEAR\r\n\tEXTRN\tVMOVE:NEAR,VALINT:NEAR,VALSNG:NEAR,FRCSTR:NEAR,CHKSTR:NEAR\r\n\tEXTRN\tMAKINT:NEAR\r\n\tEXTRN\tMOVE1:NEAR\r\n\r\n\r\n\tEXTRN\tSCNSEM:NEAR\r\n\tEXTRN\tWHILE:NEAR,WEND:NEAR\r\n\tEXTRN\tCALLS:NEAR\r\n\tEXTRN\tPROCHK:NEAR\r\n\tEXTRN\tWRITE:NEAR\r\n\tEXTRN\tCHAIN:NEAR,COMMON:NEAR\r\n\r\n\r\n\r\n\r\n;\r\n; This label must be the first one in the code segment as it is\r\n; where the SYSTEM command will jump to\r\n;\r\nPUBLIC\tBEGCSG\r\nBEGCSG:\r\nPUBLIC\tCPMWRM\r\nCPMWRM:\r\n\tORG\t5O\r\nPUBLIC\tCPMENT\r\nCPMENT:\r\n\r\n\tORG\t400O\t\t; Leave room in the CS for OS control block\r\n\r\nPUBLIC\t$START\r\n$START:\r\nPUBLIC\tSTART\r\nSTART:\r\n\r\n\r\n\r\n\r\n\r\nJMPINI:\tJMP\tINIT\t\t;INIT IS THE INTIALIZATION ROUTINE\r\n\t\t\t\t;IT SETS UP CERTAIN\r\n\t\t\t\t;LOCATIONS DELETES FUNCTIONS IF\r\n\t\t\t\t;DESIRED AND\r\n\t\t\t\t;CHANGES THIS TO JMP READY\r\n\r\n\r\n\r\n\r\n\r\n\r\n;IFE    <I8086-1>!<LENGTH-2>,<> ;Seems to be a relic, screws up\r\n\t\t\t\t;conditional nesting. 16-Feb-82/NGT\r\n\r\n\r\n\tSUBTTL ROM VERSION INITALIZATION, AND CONSTANTS\r\n\r\n\r\n\r\n;\r\n; The reserved word tables are in another module.  Consequently\r\n; many things must be declared external.  All of these things\r\n; are in the code segement or are absolutes (like tokens).\r\n; I.e., they are not in the data segment.\r\n;\r\n\r\n\tEXTRN\tALPTAB:NEAR,ATNTK:NEAR\r\n\tEXTRN\tCLINTK:NEAR\r\n\tEXTRN\tEQULTK:NEAR,ERCTK:NEAR,ERLTK:NEAR\r\n\tEXTRN\tFNTK:NEAR,FUNDSP:NEAR,STMDSP:NEAR\r\n\tEXTRN\tGREATK:NEAR\r\n\tEXTRN\tINSRTK:NEAR\r\n\tEXTRN\tLESSTK:NEAR,LSTOPK:NEAR\r\n\tEXTRN\tMIDTK:NEAR,MINUTK:NEAR\r\n\tEXTRN\tNMREL:NEAR,NOTTK:NEAR,NUMCMD:NEAR\r\n\tEXTRN\tONEFUN:NEAR\r\n\tEXTRN\tPOS:NEAR,PLUSTK:NEAR,PRINT:NEAR\r\n\tEXTRN\tRESLST:NEAR\r\n\tEXTRN\tSNGQTK:NEAR,SPCTAB:NEAR,SQRTK:NEAR,STEPTK:NEAR\r\n\tEXTRN\tTHENTK:NEAR\r\n\tEXTRN\tUSRTK:NEAR\r\n\tEXTRN\t$AUTO:NEAR\r\n\tEXTRN\t$DATA:NEAR,$DATCO:NEAR,$DELETE:NEAR\r\n\tEXTRN\t$EDIT:NEAR,$ELSE:NEAR,$END:NEAR,$ERL:NEAR,$ERROR:NEAR\r\n\tEXTRN\t$FN:NEAR,$FOR:NEAR\r\n\tEXTRN\t$GOSUB:NEAR,$GOTO:NEAR\r\n\tEXTRN\t$IF:NEAR,$INKEY$:NEAR,$INPUT:NEAR\r\n\tEXTRN\t$LIST:NEAR,$LLIST:NEAR\r\n\tEXTRN\t$NEXT:NEAR\r\n\tEXTRN\t$POINT:NEAR,$PRINT:NEAR\r\n\tEXTRN\t$REM:NEAR,$REMCO:NEAR,$RENUM:NEAR,$RESTORE:NEAR,$RESUME:NEAR\r\n\tEXTRN\t$RETURN:NEAR,$RND:NEAR,$RUN:NEAR\r\n\tEXTRN\t$SCREEN:NEAR,$STOP:NEAR,$STRING$:NEAR\r\n\tEXTRN\t$THEN:NEAR,$TO:NEAR\r\n\tEXTRN\t$USR:NEAR\r\n\tEXTRN\t$VARPTR:NEAR\r\n\tEXTRN\t$WEND:NEAR,$WHILE:NEAR\r\nADRP\tMACRO\tX\r\nENDM \r\n\r\n\r\nPUBLIC\tOPTAB\r\nOPTAB:\tDB\t121\t\t;OPERATOR TABLE CONTAINS\r\n\t\t\t\t;PRECEDENCE FOLLOWED BY\r\n\t\t\t\t;THE ROUTINE ADDRESS\r\n\tADRP\tFADDT\r\n\tDB\t121\r\n\tADRP\tFSUBT\r\n\tDB\t124\r\n\tADRP\tFMULTT\r\n\tDB\t124\r\n\tADRP\tFDIVT\r\n\tDB\t127\r\n\tADRP\tFPWRT\r\n\tDB\t80\r\n\tADRP\tANDO\r\n\tDB\t70\r\n\tADRP\tORO\r\n\tDB\t60\t\t;PRECEDENCE OF \"XOR\"\r\n\tDB\t50\t\t;PRECEDENCE OF \"EQV\"\r\n\tDB\t40\t\t;PRECEDENCE OF \"IMP\"\r\n\tDB\t122\t\t;PRECEDENCE OF \"MOD\"\r\n\tDB\t123\t\t;PRECEDENCE OF \"IDIV\"\r\n\r\n;\r\n; USED BY ASSIGNMENT CODE TO FORCE THE RIGHT HAND VALUE\r\n; TO CORRESPOND TO THE VALUE TYPE OF THE VARIABLE BEING\r\n; ASSIGNED TO.\r\n;\r\nPUBLIC\tFRCTBL\r\nFRCTBL:\tADR\tFRCDBL\r\n\tDB\t2 DUP(?)\r\n\tADR\tFRCINT\r\n\tADR\tCHKSTR\r\n\tADR\tFRCSNG\r\n;\r\n; THESE TABLES ARE USED AFTER THE DECISION HAS BEEN MADE\r\n; TO APPLY AN OPERATOR AND ALL THE NECESSARY CONVERSION HAS\r\n; BEEN DONE TO MATCH THE TWO ARGUMENT TYPES (APPLOP)\r\n;\r\nPUBLIC\tDBLDSP\r\nDBLDSP:\tADR\tDADD\t\t;DOUBLE PRECISION ROUTINES\r\n\tADR\tDSUB\r\n\tADR\tDMULT\r\n\tADR\tDDIV\r\n\tADR\tDCOMP\r\nPUBLIC\tOPCNT\r\n\tOPCNT=(($-DBLDSP)/2)-1\r\nPUBLIC\tSNGDSP\r\nSNGDSP:\tADR\tFADD\t\t;SINGLE PRECISION ROUTINES\r\n\tADR\tFSUB\r\n\tADR\tFMULT\r\n\tADR\tFDIV\r\n\tADR\tFCOMP\r\nPUBLIC\tINTDSP\r\nINTDSP:\tADR\tIADD\t\t;INTEGER ROUTINES\r\n\tADR\tISUB\r\n\tADR\tIMULT\r\n\tADR\tINTDIV\r\n\tADR\tICOMP\r\n\r\n\tPAGE\t\r\n\tSUBTTL  ERROR MESSAGE TABLE\r\n\r\nDCUL\tMACRO\tX\r\n\tDC\tX\r\nENDM \r\n\r\n\r\n\tQQ=QQ-2\r\n\r\nPUBLIC\tERRTAB\r\nERRTAB:\r\n\tDB\t0\r\n\tQQ=0\r\nDCE\tMACRO\tX\r\nENDM \r\nDCL\tMACRO\tX\r\n\tQQ=QQ+1\r\n\tDCUL\tX\r\n\tDB\t0\r\nENDM \r\n\tDCE\t\"NF\"\r\n\tDCL\t\"NEXT without FOR\"\r\nPUBLIC\tERRNF\r\n\tERRNF=QQ\r\n\tDCE\t\"SN\"\r\n\tDCL\t\"Syntax error\"\r\nPUBLIC\tERRSN\r\n\tERRSN=QQ\r\n\tDCE\t\"RG\"\r\n\tDCL\t\"RETURN without GOSUB\"\r\nPUBLIC\tERRRG\r\n\tERRRG=QQ\r\n\tDCE\t\"OD\"\r\n\tDCL\t\"Out of DATA\"\r\nPUBLIC\tERROD\r\n\tERROD=QQ\r\n\tDCE\t\"FC\"\r\n\tDCL\t\"Illegal function call\"\r\nPUBLIC\tERRFC\r\n\tERRFC=QQ\r\nPUBLIC\t$OVMSG\r\n$OVMSG:\r\nPUBLIC\tOVRMSG\r\nOVRMSG:\r\n\tDCE\t\"OV\"\r\n\tDCL\t\"Overflow\"\r\nPUBLIC\tERROV\r\n\tERROV=QQ\r\n\tDCE\t\"OM\"\r\n\tDCL\t\"Out of memory\"\r\nPUBLIC\tERROM\r\n\tERROM=QQ\r\n\tDCE\t\"UL\"\r\n\tDCL\t\"Undefined line number\"\r\nPUBLIC\tERRUS\r\n\tERRUS=QQ\r\n\tDCE\t\"BS\"\r\n\tDCL\t\"Subscript out of range\"\r\nPUBLIC\tERRBS\r\n\tERRBS=QQ\r\n\tDCE\t\"DD\"\r\n\tDCL\t\"Duplicate Definition\"\r\nPUBLIC\tERRDD\r\n\tERRDD=QQ\r\nPUBLIC\t$DIV0M\r\n$DIV0M:\r\nPUBLIC\tDIVMSG\r\nDIVMSG:\r\n\tDCE\t\"/0\"\r\n\tDCL\t\"Division by zero\"\r\nPUBLIC\tERRDV0\r\n\tERRDV0=QQ\r\n\tDCE\t\"ID\"\r\n\tDCL\t\"Illegal direct\"\r\nPUBLIC\tERRID\r\n\tERRID=QQ\r\n\tDCE\t\"TM\"\r\n\tDCL\t\"Type mismatch\"\r\nPUBLIC\tERRTM\r\n\tERRTM=QQ\r\n\tDCE\t\"OS\"\r\n\tDCL\t\"Out of string space\"\r\nPUBLIC\tERRSO\r\n\tERRSO=QQ\r\n\tDCE\t\"LS\"\r\n\tDCL\t\"String too long\"\r\nPUBLIC\tERRLS\r\n\tERRLS=QQ\r\n\tDCE\t\"ST\"\r\n\tDCL\t\"String formula too complex\"\r\nPUBLIC\tERRST\r\n\tERRST=QQ\r\n\tDCE\t\"CN\"\r\n\tDCL\t\"Can't continue\"\r\nPUBLIC\tERRCN\r\n\tERRCN=QQ\r\n\tDCE\t\"UF\"\r\n\tDCL\t\"Undefined user function\"\r\nPUBLIC\tERRUF\r\n\tERRUF=QQ\r\n\tDCE\t\"NR\"\r\n\tDCL\t\"No RESUME\"\r\nPUBLIC\tERRNR\r\n\tERRNR=QQ\r\n\tDCE\t\"RW\"\r\n\tDCL\t\"RESUME without error\"\r\nPUBLIC\tERRRE\r\n\tERRRE=QQ\r\n\tDCE\t\"UE\"\r\n\tDCL\t\"Unprintable error\"\r\nPUBLIC\tERRUE\r\n\tERRUE=QQ\r\n\tDCE\t\"MO\"\r\n\tDCL\t\"Missing operand\"\r\nPUBLIC\tERRMO\r\n\tERRMO=QQ\r\n\tDCE\t\"BO\"\r\n\tDCL\t\"Line buffer overflow\"\r\nPUBLIC\tERRLBO\r\n\tERRLBO=QQ\r\n\tDCE\t\"DT\"\r\n\tDCL\t\"Device Timeout\"\r\nPUBLIC\tERRDTO\r\n\tERRDTO=QQ\r\n\tDCE\t\"DF\"\r\n\tDCL\t\"Device Fault\"\r\nPUBLIC\tERRDVF\r\n\tERRDVF=QQ\r\n\tDCE\t\"FN\"\r\n\tDCL\t\"FOR Without NEXT\"\r\nPUBLIC\tERRFN\r\n\tERRFN=QQ\r\n\tDCE\t\"OP\"\r\n\tDCL\t\"Out of Paper\"\r\nPUBLIC\tERROTP\r\n\tERROTP=QQ\r\n\tDCE\t\"??\"\r\n\tDCL\t\"?\"\r\n\tDCE\t\"WH\"\r\n\tDCL\t\"WHILE without WEND\"\r\nPUBLIC\tERRWH\r\n\tERRWH=QQ\r\n\tDCE\t\"WE\"\r\n\tDCL\t\"WEND without WHILE\"\r\nPUBLIC\tERRWE\r\n\tERRWE=QQ\r\nPUBLIC\tNONDSK\r\n\tNONDSK=QQ\t\t;LAST NON DISK ERROR.\r\n;\r\n;       Following are DISK errors\r\n;\r\n\tQQ=49D\t\t\t;DISK ERRORS START AT 50.\r\nPUBLIC\tDSKERR\r\n\tDSKERR=QQ\t\t;FIRST DISK ERROR\r\nPUBLIC\tERRUE1\r\n\tERRUE1=ERRUE+DSKERR-NONDSK\r\nPUBLIC\tDSKER1\r\n\tDSKER1=DSKERR-NONDSK\r\n\r\n\tDCE\t\"FO\"\r\n\tDCL\t\"FIELD overflow\"\r\nPUBLIC\tERRFOV\r\n\tERRFOV=QQ\r\n\tDCE\t\"IE\"\r\n\tDCL\t\"Internal error\"\r\nPUBLIC\tERRIER\r\n\tERRIER=QQ\r\n\tDCE\t\"BN\"\r\n\tDCL\t\"Bad file number\"\r\nPUBLIC\tERRBFN\r\n\tERRBFN=QQ\r\nPUBLIC\tERRBFN\r\n\tERRBFN=QQ\r\n\tDCE\t\"FF\"\r\n\tDCL\t\"File not found\"\r\nPUBLIC\tERRFNF\r\n\tERRFNF=QQ\r\n\tDCE\t\"BM\"\r\n\tDCL\t\"Bad file mode\"\r\nPUBLIC\tERRBFM\r\n\tERRBFM=QQ\r\nPUBLIC\tERRFNO\r\n\tERRFNO=QQ\t\t;Map \"File Not Open\" to \"Bad file mode\".\r\n\tDCE\t\"AO\"\r\n\tDCL\t\"File already open\"\r\nPUBLIC\tERRFAO\r\n\tERRFAO=QQ\r\n\tDCE\t\"??\"\r\n\tDCL\t\"?\"\r\nPUBLIC\tDSKLOC\r\n\tDSKLOC=$+6\r\n\tDCE\t\"IO\"\r\n\tDCL\t\"Device I/O Error\"\r\nPUBLIC\tERRDIO\r\n\tERRDIO=QQ\r\nPUBLIC\tERRDPE\r\n\tERRDPE=QQ\t\t;Map \"Device Parity Error\" to\r\n\t\t\t\t;\"Device I/O Error\".\r\nPUBLIC\tERRIOE\r\n\tERRIOE=QQ\r\n\tDCE\t\"FE\"\r\n\tDCL\t\"File already exists\"\r\nPUBLIC\tERRFAE\r\n\tERRFAE=QQ\r\n\tDCE\t\"??\"\r\n\tDCL\t\"?\"\r\n\tDCE\t\"??\"\r\n\tDCL\t\"?\"\r\n\tDCE\t\"DF\"\r\n\tDCL\t\"Disk full\"\r\nPUBLIC\tERRDFL\r\n\tERRDFL=QQ\r\n\tDCE\t\"EF\"\r\n\tDCL\t\"Input past end\"\r\nPUBLIC\tERRRPE\r\n\tERRRPE=QQ\r\n\tDCE\t\"RN\"\r\n\tDCL\t\"Bad record number\"\r\nPUBLIC\tERRBRN\r\n\tERRBRN=QQ\r\n\tDCE\t\"NM\"\r\n\tDCL\t\"Bad file name\"\r\nPUBLIC\tERRIFN\r\n\tERRIFN=QQ\t\t;Map \"Illegal filename\" to \"Bad file\r\n\t\t\t\t;name\".\r\nPUBLIC\tERRNMF\r\n\tERRNMF=QQ\r\n\tDCE\t\"??\"\r\n\tDCL\t\"?\"\r\nPUBLIC\tERRMMM\r\n\tERRMMM=QQ\r\n\tDCE\t\"DS\"\r\n\tDCL\t\"Direct statement in file\"\r\nPUBLIC\tERRFDR\r\n\tERRFDR=QQ\r\n\tDCE\t\"FL\"\r\n\tDCL\t\"Too many files\"\r\nPUBLIC\tERRTMF\r\n\tERRTMF=QQ\r\n\tDCL\t\"Device Unavailable\"\r\nPUBLIC\tERRDNA\r\n\tERRDNA=QQ\r\n\tDCL\t\"Communication buffer overflow\"\r\nPUBLIC\tERRCBO\r\n\tERRCBO=QQ\r\n\tDCL\t\"Disk write protected\"\r\nPUBLIC\tERRDWP\r\n\tERRDWP=QQ\r\n\tDCL\t\"Disk not Ready\"\r\nPUBLIC\tERRDNR\r\n\tERRDNR=QQ\r\n\tDCL\t\"Disk media error\"\r\nPUBLIC\tERRDME\r\n\tERRDME=QQ\r\n\tDCL\t\"Advanced Feature\"\r\nPUBLIC\tERRADV\r\n\tERRADV=QQ\r\n\tDCL\t\"Rename across disks\"\r\nPUBLIC\tERRRAD\r\n\tERRRAD=QQ\r\n\r\nPUBLIC\tLSTERR\r\n\tLSTERR=QQ+1\t\t;LAST ERROR USED FOR RANGE CHECKS IN LEN2\r\n\tPAGE\t\r\n\r\n\tSUBTTL CONSTANTS FOR ROM BASIC I/O, RNDX, FDIV, USRGO\r\n\r\n\r\n;********************************************************************\r\n;\r\n;       NOTE!!!         THIS RAM CODE IS REPRODUCED LATER IN THIS\r\n;                       LISTING WITHOUT LABELS AND TARGETED\r\n;                       FOR ROM. THIS ALLOWS THE CODE TO BE COPIED\r\n;                       INTO RAM FOR EXECUTION. IF THERE IS A CHANGE \r\n;                       TO BE MADE TO THE RAM CODE MAKE THE SIMULAR\r\n;                       CHANGE TO THE ROM AREA CODE WITHOUT LABELS.\r\n;                       THE ROM CODE IS BRACKETED BY AN IFN CONVRT\r\n;                       AND A COMMENT INDICATING THE CODE IS FOR\r\n;                       TARGET MACHINE COMPILATIONS.\r\n;\r\n;******************************************************************\r\n\r\n\tPUBLIC\tCONSTR,RAMLOW\r\nPUBLIC\tCNSLEN\r\n\tCNSLEN=ENDCNS-CONSTR\r\n\r\n\t\t\t\t;FOR ON-MACHINE COMPILATIONS\r\nPUBLIC\tCONSTR\r\n\tCONSTR=$\r\n;************************************************************\r\n;****** BEGDSG: is the begining of the data segment.  *******\r\n;****** It MUST be the first label in DSEG, as it is  *******\r\n;****** used by GWINIT to insert the OS control block *******\r\n;************************************************************\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tASSUME DS:DSEG\r\nPUBLIC\tBEGDSG\r\nBEGDSG\tLABEL WORD\r\n\tORG\t2D\r\nPUBLIC\tCPMMEM\r\nCPMMEM\tLABEL WORD\r\nDSEG\tENDS\r\n; ======== Code Phase ========\r\n\tRAMLOW=$\t\t;WHERE CONSTANTS GET DEPOSITED\r\n\tINS86\t352\t\t;INTER-SEGMENT DIRECT JUMP\r\n\tDB\t4 DUP(?)\r\n;\r\n;THE FOLLOWING IS THE LAST RANDOM NUMBER GENERATED BY RND\r\n;IT MUST NOT BE ZERO, IT MUST BE BETWEEN 0 AND 1.\r\n;\r\n\r\n\t.RADIX\t8\r\n\r\n\tDB\t0\r\n; RNDCNT:\r\n\tDB\t0\r\n\tDB\t0\r\n\tRET\t\t\t;THIS IS A KLUDGE TO MAKE CHRGET WORK\r\nPUBLIC\tNUMCON\r\n; NUMCON:\r\n\tDB\tOFFSET CONCON\t;THESE FAKE TOKENS FORCE CHRGET\r\n\tDB\tOFFSET CONCN2\t;TO EFFECTIVELY RE-SCAN THE EMBEDED CONSTANT\r\nPUBLIC\tDSEGZ\r\n; DSEGZ:\r\n\tDB\t0\t\t;DATA SEGMENT-LOCATED ZERO\r\nPUBLIC\tRNDCOP\r\n; RNDCOP:\r\n\tDB\t122\t\t;COPY OF THE RANDOM NUMBER SEED\r\n\tDB\t307\t\t;BETWEEN 0 AND 1\r\n\tDB\t117\r\n\tDB\t200\r\nPUBLIC\t$RNDX\r\n; $RNDX:\r\nPUBLIC\tRNDX\r\n; RNDX:\r\n\tDB\t122\t\t;LAST RANDOM NUMBER GENERATED\r\n\tDB\t307\t\t;BETWEEN 0 AND 1\r\n\tDB\t117\r\n\tDB\t200\r\n\t.RADIX\t10\r\n; STAINP:\r\n\tIN\tAL,0\r\n\tINS86\t313\t\t;\"LONG\" RETURN\r\nPUBLIC\tENDPRG\r\n; ENDPRG:\r\n\tDB\t\":\"\r\n\tDB\t0,0,0,0\t\t;FAKE END OF PROGRAM FOR RESUME NEXT\r\n\tPAGE\t\r\n\r\n\tSUBTTL LOW SEGMENT -- RAM-- IE THIS STUFF IS NOT CONSTANT\r\n;\r\n; THIS IS THE \"VOLATILE\" STORAGE AREA AND NONE OF IT\r\n; CAN BE KEPT IN ROM. ANY CONSTANTS IN THIS AREA CANNOT\r\n; BE KEPT IN A ROM, BUT MUST BE LOADED IN BY THE \r\n; PROGRAM INSTRUCTIONS IN ROM.\r\n;\r\n\r\nPUBLIC\tUSRTAB\r\n; USRTAB:\r\nREPT\t10\r\n\tDW\t65535D\r\nENDM \r\nPUBLIC\tNULCNT\r\n; NULCNT:\r\n\tDB\t1\t\t;STORE HERE THE NUMBER OF NULLS\r\n\t\t\t\t;TO PRINT AFTER CRLF\r\nPUBLIC\tMSDCCF\r\n; MSDCCF:\r\n\tDB\t0\t\t;Ctl-C flag set by Ctl-C int handler\r\nPUBLIC\tCTLCAD\r\n; CTLCAD:\r\n\tDB\t4 DUP(?)\t;Store pre-BASIC CTL-C int vector\r\nPUBLIC\tDINTAD\r\n; DINTAD:\r\n\tDB\t4 DUP(?)\t;Store BASIC Disk error int vector\r\nPUBLIC\tLSTCHR\r\n; LSTCHR:\r\n\tDB\t0\t\t;used by SCNSOT to remember last chr out\r\nPUBLIC\tERRFLG\r\n; ERRFLG:\r\n\tDB\t0\t\t;USED TO SAVE THE ERROR NUMBER\r\n\t\t\t\t; SO EDIT CAN BE CALLED ON \"SN\" ERR.\r\nPUBLIC\tLPTLST\r\n; LPTLST:\r\n\tDB\t0\t\t;LAST LINE PRINTER OPERATION. ZERO\r\n\t\t\t\t;MEANS LINEFEED. NON-ZERO MEANS PRINT\r\n\t\t\t\t;COMMAND (OKIA ONLY)\r\nPUBLIC\tLPTPOS\r\n; LPTPOS:\r\n\tDB\t0\t\t;POSITION OF LPT PRINT HEAD -initially 0\r\nPUBLIC\tPRTFLG\r\n; PRTFLG:\r\n\tDB\t0\t\t;WHETHER OUTPUT GOES TO LPT\r\n\tLNCMPS=(((LPTLEN/CLMWID)-1)*CLMWID)\t;LAST COMMA FIELD POSIT\r\nPUBLIC\tNLPPOS\r\n; NLPPOS:\r\n\tDB\tOFFSET LNCMPS\t;LAST COL # BEYOND WHICH NO MORE COMMA FIELDS\r\nPUBLIC\tLPTSIZ\r\n; LPTSIZ:\r\n\tDB\tOFFSET LPTLEN\t;DEFAULT LINE PRINTER WIDTH\r\nPUBLIC\tDAYSPM\r\n; DAYSPM:\r\n\tDB\t31D,28D,31D,30D,31D,30D\r\n\tDB\t31D,31D,30D,31D,30D,31D\r\n\tNCMPOS=(((LINLN/CLMWID)-1)*CLMWID)\t;POSITION BEYOND WHICH THERE ARE\r\n\t\t\t\t;NO MORE COMMA FIELDS   \r\n; CLMLST:\r\n\tDB\tOFFSET NCMPOS\t;POSITION OF LAST COMMA COLUMN\r\nPUBLIC\tRUBSW\r\n; RUBSW:\r\n\tDB\t0\t\t;RUBOUT SWITCH =1 INSIDE\r\n\t\t\t\t;THE PROCESSING OF A RUBOUT (INLIN)\r\nPUBLIC\tCNTOFL\r\n; CNTOFL:\r\n\tDB\t0\t\t;SUPRESS OUTPUT FLAG\r\n\t\t\t\t;NON-ZERO MEANS SUPRESS\r\n\t\t\t\t;RESET BY \"INPUT\",READY AND ERRORS\r\n\t\t\t\t;COMPLEMENTED BY INPUT OF ^O\r\nPUBLIC\tPTRFIL\r\n; PTRFIL:\r\n\tDW\t0\r\n\t\t\t\t;POINTER TO DATA BLOCK OF CURRENT FILE\r\n\t\t\t\t;USED BY DISK AND NCR CASSETTE CODE\r\nPUBLIC\tTOPMEM\r\n; TOPMEM:\r\n\tADR\tTSTACK+100\t;TOP LOCATION TO USE FOR THE STACK\r\n\t\t\t\t;INITIALLY SET UP BY INIT\r\n\t\t\t\t;ACCORDING TO MEMORY SIZE\r\n\t\t\t\t;TO ALLOW FOR 50 BYTES OF STRING SPACE.\r\n\t\t\t\t;CHANGED BY A CLEAR COMMAND WITH\r\n\t\t\t\t;AN ARGUMENT.\r\nPUBLIC\tCURLIN\r\n; CURLIN:\r\n\tADR\t0+65534D\t;CURRENT LINE #\r\n\t\t\t\t;SET TO 65534 IN PURE VERSION DURING INIT EXECUTION\r\n\t\t\t\t;SET TO 65535 WHEN DIRECT STATEMENTS EXECUTE\r\nPUBLIC\tTXTTAB\r\n; TXTTAB:\r\n\tADR\tTSTACK+1\t;POINTER TO BEGINNING OF TEXT\r\n\t\t\t\t;DOESN'T CHANGE AFTER BEING\r\n\t\t\t\t;SETUP BY INIT.\r\nPUBLIC\tOVERRI\r\n; OVERRI:\r\n\tADR\tOVRMSG\t\t;ADDRESS OF MESSAGE TO PRINT (OVERFLOW)\r\nPUBLIC\tCSRTYP\r\n; CSRTYP:\r\n\tDB\t0\t\t;Type of next cursor\r\nPUBLIC\tCSRFLG\r\n; CSRFLG:\r\n\tDB\t0\t\t;Type of current cursor\r\n;\r\n;Generalized I/O initialized data definitions\r\n;\r\n; EXTERN        .DVTBL, .DVPTR, .DVINI, .DVTRM\r\n; INTERNs and EXTERNs moved out of the PHASE block for ASM86 translator.\r\n; 9/2/82/NGT\r\n\r\nPUBLIC\tDEVTBL\r\n; DEVTBL:\r\n\tADR\t_DVTBL\t\t;points to array of device names\r\nPUBLIC\tDEVPTR\r\n; DEVPTR:\r\n\tADR\t_DVPTR\t\t;points to array of device dispatch tables\r\nPUBLIC\tDEVINI\r\n; DEVINI:\r\n\tADR\t_DVINI\t\t;points to array of device initalize routines\r\nPUBLIC\tDEVTRM\r\n; DEVTRM:\r\n\tADR\t_DVTRM\t\t;points to array of device termination routines\r\nPUBLIC\tSAVKEY\r\n; SAVKEY:\r\n\tDB\t0\t\t;for saving 2nd byte of 2-byte seq.\r\nPUBLIC\tSAVKYF\r\n; SAVKYF:\r\n\tDB\t0\t\t;Flag nonzero when SAVKEY is active (SAVKEY may be 0)\r\nPUBLIC\tFREFDB\r\n; FREFDB:\r\n\tDW\t0\t\t;Used by Device Open Routines to release FDB\r\n\t\t\t\t;if error occurs after FDB is allocated but\r\n\t\t\t\t;before File actually becomes OPEN.\r\n\t\t\t\t;FDB is Freed by routine FINPRT.\r\n\tDATSTR=$\r\n;\r\n; ======== Data Phase ========\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tORG\t0+400O\r\n\tRAMLOW=$\t\t;WHERE CONSTANTS GET DEPOSITED\r\n\tINS86\t352\t\t;INTER-SEGMENT DIRECT JUMP\r\n\tDB\t4 DUP(?)\r\n;\r\n;THE FOLLOWING IS THE LAST RANDOM NUMBER GENERATED BY RND\r\n;IT MUST NOT BE ZERO, IT MUST BE BETWEEN 0 AND 1.\r\n;\r\n\r\n\t.RADIX\t8\r\n\r\n\tDB\t1 DUP (?)\r\nRNDCNT\tLABEL WORD\r\n\tDB\t1 DUP (?)\r\n\tDB\t1 DUP (?)\r\n\tRET\t\t\t;THIS IS A KLUDGE TO MAKE CHRGET WORK\r\nPUBLIC\tNUMCON\r\nNUMCON\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;THESE FAKE TOKENS FORCE CHRGET\r\n\tDB\t1 DUP (?)\t;TO EFFECTIVELY RE-SCAN THE EMBEDED CONSTANT\r\nPUBLIC\tDSEGZ\r\nDSEGZ\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;DATA SEGMENT-LOCATED ZERO\r\nPUBLIC\tRNDCOP\r\nRNDCOP\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;COPY OF THE RANDOM NUMBER SEED\r\n\tDB\t1 DUP (?)\t;BETWEEN 0 AND 1\r\n\tDB\t1 DUP (?)\r\n\tDB\t1 DUP (?)\r\nPUBLIC\t$RNDX\r\n$RNDX\tLABEL WORD\r\nPUBLIC\tRNDX\r\nRNDX\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;LAST RANDOM NUMBER GENERATED\r\n\tDB\t1 DUP (?)\t;BETWEEN 0 AND 1\r\n\tDB\t1 DUP (?)\r\n\tDB\t1 DUP (?)\r\n\t.RADIX\t10\r\nSTAINP\tLABEL WORD\r\n\tIN\tAL,0\r\n\tINS86\t313\t\t;\"LONG\" RETURN\r\nPUBLIC\tENDPRG\r\nENDPRG\tLABEL WORD\r\n\tDB\t1 DUP (?)\r\n\tDB\t4 DUP (?)\t;FAKE END OF PROGRAM FOR RESUME NEXT\r\n\tPAGE\t\r\n\r\n\tSUBTTL LOW SEGMENT -- RAM-- IE THIS STUFF IS NOT CONSTANT\r\n;\r\n; THIS IS THE \"VOLATILE\" STORAGE AREA AND NONE OF IT\r\n; CAN BE KEPT IN ROM. ANY CONSTANTS IN THIS AREA CANNOT\r\n; BE KEPT IN A ROM, BUT MUST BE LOADED IN BY THE \r\n; PROGRAM INSTRUCTIONS IN ROM.\r\n;\r\n\r\nPUBLIC\tUSRTAB\r\nUSRTAB\tLABEL WORD\r\nREPT\t10\r\n\tDW\t1 DUP (?)\r\nENDM \r\nPUBLIC\tNULCNT\r\nNULCNT\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;STORE HERE THE NUMBER OF NULLS\r\n\t\t\t\t;TO PRINT AFTER CRLF\r\nPUBLIC\tMSDCCF\r\nMSDCCF\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;Ctl-C flag set by Ctl-C int handler\r\nPUBLIC\tCTLCAD\r\nCTLCAD\tLABEL WORD\r\n\tDB\t4 DUP(?)\t;Store pre-BASIC CTL-C int vector\r\nPUBLIC\tDINTAD\r\nDINTAD\tLABEL WORD\r\n\tDB\t4 DUP(?)\t;Store BASIC Disk error int vector\r\nPUBLIC\tLSTCHR\r\nLSTCHR\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;used by SCNSOT to remember last chr out\r\nPUBLIC\tERRFLG\r\nERRFLG\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;USED TO SAVE THE ERROR NUMBER\r\n\t\t\t\t; SO EDIT CAN BE CALLED ON \"SN\" ERR.\r\nPUBLIC\tLPTLST\r\nLPTLST\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;LAST LINE PRINTER OPERATION. ZERO\r\n\t\t\t\t;MEANS LINEFEED. NON-ZERO MEANS PRINT\r\n\t\t\t\t;COMMAND (OKIA ONLY)\r\nPUBLIC\tLPTPOS\r\nLPTPOS\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;POSITION OF LPT PRINT HEAD -initially 0\r\nPUBLIC\tPRTFLG\r\nPRTFLG\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;WHETHER OUTPUT GOES TO LPT\r\n\tLNCMPS=(((LPTLEN/CLMWID)-1)*CLMWID)\t;LAST COMMA FIELD POSIT\r\nPUBLIC\tNLPPOS\r\nNLPPOS\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;LAST COL # BEYOND WHICH NO MORE COMMA FIELDS\r\nPUBLIC\tLPTSIZ\r\nLPTSIZ\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;DEFAULT LINE PRINTER WIDTH\r\nPUBLIC\tDAYSPM\r\nDAYSPM\tLABEL WORD\r\n\tDB\t6 DUP (?)\r\n\tDB\t6 DUP (?)\r\n\tNCMPOS=(((LINLN/CLMWID)-1)*CLMWID)\t;POSITION BEYOND WHICH THERE ARE\r\n\t\t\t\t;NO MORE COMMA FIELDS   \r\nCLMLST\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;POSITION OF LAST COMMA COLUMN\r\nPUBLIC\tRUBSW\r\nRUBSW\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;RUBOUT SWITCH =1 INSIDE\r\n\t\t\t\t;THE PROCESSING OF A RUBOUT (INLIN)\r\nPUBLIC\tCNTOFL\r\nCNTOFL\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;SUPRESS OUTPUT FLAG\r\n\t\t\t\t;NON-ZERO MEANS SUPRESS\r\n\t\t\t\t;RESET BY \"INPUT\",READY AND ERRORS\r\n\t\t\t\t;COMPLEMENTED BY INPUT OF ^O\r\nPUBLIC\tPTRFIL\r\nPTRFIL\tLABEL WORD\r\n\tDW\t1 DUP (?)\r\n\t\t\t\t;POINTER TO DATA BLOCK OF CURRENT FILE\r\n\t\t\t\t;USED BY DISK AND NCR CASSETTE CODE\r\nPUBLIC\tTOPMEM\r\nTOPMEM\tLABEL WORD\r\n\tADR\tTSTACK+100\t;TOP LOCATION TO USE FOR THE STACK\r\n\t\t\t\t;INITIALLY SET UP BY INIT\r\n\t\t\t\t;ACCORDING TO MEMORY SIZE\r\n\t\t\t\t;TO ALLOW FOR 50 BYTES OF STRING SPACE.\r\n\t\t\t\t;CHANGED BY A CLEAR COMMAND WITH\r\n\t\t\t\t;AN ARGUMENT.\r\nPUBLIC\tCURLIN\r\nCURLIN\tLABEL WORD\r\n\tADR\t0+65534D\t;CURRENT LINE #\r\n\t\t\t\t;SET TO 65534 IN PURE VERSION DURING INIT EXECUTION\r\n\t\t\t\t;SET TO 65535 WHEN DIRECT STATEMENTS EXECUTE\r\nPUBLIC\tTXTTAB\r\nTXTTAB\tLABEL WORD\r\n\tADR\tTSTACK+1\t;POINTER TO BEGINNING OF TEXT\r\n\t\t\t\t;DOESN'T CHANGE AFTER BEING\r\n\t\t\t\t;SETUP BY INIT.\r\nPUBLIC\tOVERRI\r\nOVERRI\tLABEL WORD\r\n\tADR\tOVRMSG\t\t;ADDRESS OF MESSAGE TO PRINT (OVERFLOW)\r\nPUBLIC\tCSRTYP\r\nCSRTYP\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;Type of next cursor\r\nPUBLIC\tCSRFLG\r\nCSRFLG\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;Type of current cursor\r\n;\r\n;Generalized I/O initialized data definitions\r\n;\r\n; EXTERN        .DVTBL, .DVPTR, .DVINI, .DVTRM\r\n; INTERNs and EXTERNs moved out of the PHASE block for ASM86 translator.\r\n; 9/2/82/NGT\r\n\r\nPUBLIC\tDEVTBL\r\nDEVTBL\tLABEL WORD\r\n\tADR\t_DVTBL\t\t;points to array of device names\r\nPUBLIC\tDEVPTR\r\nDEVPTR\tLABEL WORD\r\n\tADR\t_DVPTR\t\t;points to array of device dispatch tables\r\nPUBLIC\tDEVINI\r\nDEVINI\tLABEL WORD\r\n\tADR\t_DVINI\t\t;points to array of device initalize routines\r\nPUBLIC\tDEVTRM\r\nDEVTRM\tLABEL WORD\r\n\tADR\t_DVTRM\t\t;points to array of device termination routines\r\nPUBLIC\tSAVKEY\r\nSAVKEY\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;for saving 2nd byte of 2-byte seq.\r\nPUBLIC\tSAVKYF\r\nSAVKYF\tLABEL WORD\r\n\tDB\t1 DUP (?)\t;Flag nonzero when SAVKEY is active (SAVKEY may be 0)\r\nPUBLIC\tFREFDB\r\nFREFDB\tLABEL WORD\r\n\tDW\t1 DUP (?)\t;Used by Device Open Routines to release FDB\r\n\t\t\t\t;if error occurs after FDB is allocated but\r\n\t\t\t\t;before File actually becomes OPEN.\r\n\t\t\t\t;FDB is Freed by routine FINPRT.\r\n\tDATSTR=$\r\nDSEG\tENDS\r\n;\r\n;========== End of Phase ==========\r\n;\r\n\tENDCNS=$\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t;Start the data segment\r\n;\r\n;\r\n;GIO86 uninitialized data definitions:\r\n;\r\nPUBLIC\tFILDEV\r\n\tFILDEV=FILNAM\r\nPUBLIC\tFILNM\r\n\tFILNM=FILNAM+1\r\nPUBLIC\tFILEXT\r\n\tFILEXT=FILNM+FNAML-3\r\nPUBLIC\tIOJUMP\r\nIOJUMP\tLABEL WORD\r\n\tDB\t2 DUP(?)\r\nPUBLIC\tFILTAB\r\nFILTAB\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;points to 1st FDB (=STKLOW if no FDB's)\r\nPUBLIC\tSTKLOW\r\nSTKLOW\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;lowest legal value of [SP]\r\nPUBLIC\tFILMOD\r\nFILMOD\tLABEL WORD\r\n\tDB\t1 DUP(?)\r\nPUBLIC\tNLONLY\r\nNLONLY\tLABEL WORD\r\n\tDB\t1 DUP(?)\r\nPUBLIC\tRUNFLG\r\nRUNFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\r\n\r\nF_PCOM\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;Flags comma terminator for number print\r\nPUBLIC\tDATIME\r\nDATIME\tLABEL WORD\r\n\tDB\t5 DUP(?)\t;days(2), hours(1), minutes(1), secs(1)\r\nPUBLIC\tCPMEXT\r\nCPMEXT\tLABEL WORD\r\n\tDB\t4 DUP(?)\t;Exit jump vector.  Set to DS:0 at INIT.\r\n\t\t\t\t;MSDOS 2.0 exit must be made through the \r\n\t\t\t\t;initialization segment prefix - not at CS:0\r\n\t\t\t\t;for .EXE files.\r\nPUBLIC\tNAMCNT\r\nNAMCNT\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;THE NUMBER OF CHARACTER BEYOND #2 IN A VAR NAME\r\nPUBLIC\tNAMBUF\r\nNAMBUF\tLABEL WORD\r\n\tDB\tNAMLEN-2 DUP(?)\t;STORAGE FOR CHARS BEYOND #2. USED IN PTRGET\r\nPUBLIC\tNAMTMP\r\nNAMTMP\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;TEMP STORAGE DURING NAME SAVE AT INDLOP\r\nPUBLIC\tDIRTMP\r\n\tDIRTMP=CPMWRM+128\t;USE CPM DEFAULT BUFFER IN LOW MEMORY\r\nPUBLIC\tFILNA2\r\nFILNA2\tLABEL WORD\r\n\tDB\t16 DUP(?)\t;USED BY NAME CODE\r\n\tDB\t17 DUP(?)\t;this is used for FILES in SCP version\r\nPUBLIC\tFILNAM\r\nFILNAM\tLABEL WORD\r\n\tDB\t33 DUP(?)\t;BECAUSE CPM MUST HAVE BUFFER FOR DIRECTORY READS\r\n;\r\n;       CP/M 1.4 and 2.x Support\r\n;\r\n\r\nPUBLIC\tCPMVRN\r\nCPMVRN\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;CP/M Version Number (#0 is 2.x)\r\nPUBLIC\tCPMREA\r\nCPMREA\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;CP/M Read Call\r\nPUBLIC\tCPMWRI\r\nCPMWRI\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;CP/M Write Call\r\n\tDB\t\":\"\t\t;a colon for restarting input\r\nPUBLIC\tKBUF\r\nKBUF\tLABEL WORD\r\n\tDB\tKBFLEN DUP(?)\t;THIS IS THE KRUNCH BUFFER\r\nPUBLIC\tBUFMIN\r\nBUFMIN\tLABEL WORD\r\n\tDB\t44\t\t;A COMMA (PRELOAD OR ROM)\r\n\t\t\t\t;USED BY INPUT STATEMENT SINCE THE\r\n\t\t\t\t;DATA POINTER ALWAYS STARTS ON A\r\n\t\t\t\t;COMMA OR TERMINATOR\r\nPUBLIC\tBUF\r\nBUF\tLABEL WORD\r\n\tDB\tBUFLEN+1 DUP(?)\t;TYPE IN STORED HERE\r\n\t\t\t\t;DIRECT STATEMENTS EXECUTE OUT OF\r\n\t\t\t\t;HERE. REMEMBER \"INPUT\" SMASHES BUF.\r\n\t\t\t\t;MUST BE AT A LOWER ADDRESS\r\n\t\t\t\t;THAN DSCTMP OR ASSIGNMENT OF STRING\r\n\t\t\t\t;VALUES IN DIRECT STATEMENTS WON'T COPY\r\n\t\t\t\t;INTO STRING SPACE -- WHICH IT MUST\r\n\tDB\t2 DUP(?)\t;ALLOW FOR SINGLE QUOTE IN BIG LINE\r\nPUBLIC\tENDBUF\r\nENDBUF\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;PLACE TO STOP BIG LINES\r\n\r\nPUBLIC\tTTYPOS\r\nTTYPOS\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;STORE TERMINAL POSITION HERE\r\nPUBLIC\tDIMFLG\r\nDIMFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;IN GETTING A POINTER TO A VARIABLE\r\n\t\t\t\t;IT IS IMPORTANT TO REMEMBER WHETHER IT\r\n\t\t\t\t;IS BEING DONE FOR \"DIM\" OR NOT\r\n\t\t\t\t;DIMFLG AND VALTYP MUST BE\r\n\t\t\t\t;CONSECUTIVE LOCATIONS\r\nPUBLIC\t$VALTP\r\n$VALTP\tLABEL WORD\r\nPUBLIC\tVALTYP\r\nVALTYP\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;THE TYPE INDICATOR\r\n\t\t\t\t;IN THE 8K 0=NUMERIC 1=STRING\r\nPUBLIC\tOPRTYP\r\nOPRTYP\tLABEL WORD\t\t;USED TO STORE OPERATOR NUMBER\r\n\t\t\t\t;IN THE EXTENDED MOMENTARILY BEFORE\r\n\t\t\t\t;OPERATOR APPLICATION (APPLOP)\r\nPUBLIC\tDORES\r\nDORES\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;WHETHER CAN OR CAN'T CRUNCH RES'D WORDS\r\n\t\t\t\t;TURNED ON IN THE 8K WHEN \"DATA\"\r\n\t\t\t\t;BEING SCANNED BY CRUNCH SO UNQUOTED\r\n\t\t\t\t;STRINGS WON'T BE CRUNCHED.\r\nPUBLIC\tDONUM\r\nDONUM\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;FLAG FOR CRUNCH =0 MEANS\r\n\t\t\t\t;NUMBERS ALLOWED, (FLOATING,INT, DBL)\r\n\t\t\t\t;1 MEANS NUMBERS ALLOWED, KRUNCH BY CALLING LINGET\r\n\t\t\t\t;-1 (377) MEANS NUMBERS DISALLOWED \r\n\t\t\t\t;(SCANNING VARIABLE NAME)\r\nPUBLIC\tCONTXT\r\nCONTXT\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;SAVED TEXT POINTER USED BY CHRGET\r\n\t\t\t\t;TO SAVE THE TEXT POINTER AFTER CONSTANT\r\n\t\t\t\t;HAS BEEN SCANNED.\r\nPUBLIC\tCONSAV\r\nCONSAV\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;THE SAVED TOKEN FOR A CONSTANT\r\n\t\t\t\t;AFTER CHRGET HAS BEEN CALLED\r\nPUBLIC\tCONTYP\r\nCONTYP\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;SAVED CONSTANT VALTYPE\r\nPUBLIC\tCONLO\r\nCONLO\tLABEL WORD\r\n\tDB\t4 DUP(?)\t;SAVED CONSTANT VALUE\r\n\tDB\t4 DUP(?)\t;EXTRA 4 BYTES FOR DBL PRECISION\r\n\r\n\r\nPUBLIC\tMAXMEM\r\nMAXMEM\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;Maximum size of BASIC's Data Segment\r\nPUBLIC\tMEMSIZ\r\nMEMSIZ\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;HIGHEST LOCATION IN MEMORY\r\nPUBLIC\tTEMPPT\r\nTEMPPT\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;POINTER AT FIRST FREE TEMP DESCRIPTOR\r\n\t\t\t\t;INITIALIZED TO POINT TO TEMPST\r\nPUBLIC\tTEMPST\r\nTEMPST\tLABEL WORD\r\n\tDB\tSTRSIZ*NUMTMP DUP(?)\t;STORAGE FOR NUMTMP TEMP DESCRIPTORS\r\nPUBLIC\tDSCTMP\r\nDSCTMP\tLABEL WORD\r\n\tDB\tSTRSIZ DUP(?)\t;STRING FUNCTIONS BUILD ANSWER DESCRIPTOR HERE\r\n\t\t\t\t;MUST BE AFTER TEMPST AND BEFORE PARM1\r\nPUBLIC\tDSCPTR\r\n\tDSCPTR=$-2\t\t;WHERE STRING ADDRESS IS STORE IN DSCTMP\r\nPUBLIC\tFRETOP\r\nFRETOP\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;TOP OF STRING FREE SPACE\r\nPUBLIC\tTEMP3\r\nTEMP3\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;USED TO STORE THE ADDRESS OF THE END OF\r\n\t\t\t\t;STRING ARRAYS IN GARBAGE COLLECTION\r\n\t\t\t\t;AND USED MOMENTARILY BY FRMEVL\r\n\t\t\t\t;USED IN EXTENDED BY FOUT AND\r\n\t\t\t\t;USER DEFINED FUNCTIONS\r\n\t\t\t\t;ARRAY VARIABLE HANDLING TEMPORARY\r\nPUBLIC\tTEMP8\r\nTEMP8\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;7/3/79 Now used by garbage collection\r\n\t\t\t\t;not TEMP3 due to conflict\r\nPUBLIC\tENDFOR\r\nENDFOR\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;SAVED TEXT POINTER AT END OF \"FOR\" STATEMENT\r\nPUBLIC\tDATLIN\r\nDATLIN\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;DATA LINE # -- REMEMBER FOR ERRORS\r\nPUBLIC\tSUBFLG\r\nSUBFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;FLAG WHETHER SUBSCRIPTED VARIABLE ALLOWED\r\n\t\t\t\t;\"FOR\" AND USER-DEFINED FUNCTION\r\n\t\t\t\t;POINTER FETCHING TURN\r\n\t\t\t\t;THIS ON BEFORE CALLING PTRGET\r\n\t\t\t\t;SO ARRAYS WON'T BE DETECTED.\r\n\t\t\t\t;STKINI AND PTRGET CLEAR IT.\r\nPUBLIC\tSARYFL\r\nSARYFL\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;SCANED-ARRAY-FLAG: SET BY PTRGET WHEN\r\n\t\t\t\t;IT SCANS AN ARRAY ELEMENT.  TESTED BY\r\n\t\t\t\t;CALL86 SO UNDEFINED SCALERS WON'T\r\n\t\t\t\t;BE PERMITED AFTER ARRAY REFERENCES\r\n\t\t\t\t;IN CALL PARAMETER LIST.\r\nPUBLIC\tUSFLG\r\nUSFLG\tLABEL WORD\r\nPUBLIC\tFLGINP\r\nFLGINP\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;FLAGS WHETHER WE ARE DOING \"INPUT\"\r\n\t\t\t\t;OR A READ\r\nPUBLIC\tTEMP\r\nTEMP\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;TEMPORARY FOR STATEMENT CODE\r\n\t\t\t\t;NEWSTT SAVES [H,L] HERE FOR INPUT AND ^C\r\n\t\t\t\t;\"LET\" SAVES VARIABLE\r\n\t\t\t\t;POINTERS HERE FOR \"FOR\"\r\n\t\t\t\t;\"NEXT\" SAVES ITS TEXT POINTER HERE\r\n\t\t\t\t;CLEARC SAVES [H,L] HERE\r\nPUBLIC\tPTRFLG\r\nPTRFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;=0 IF NO LINE NUMBERS CONVERTED\r\n\t\t\t\t;TO POINTERS, NON ZERO IF POINTERS EXIST\r\nPUBLIC\tAUTFLG\r\nAUTFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;FLAG TO INICATE AUTO COMMAND IN\r\n\t\t\t\t;PROGRESS =0 IF NOT, NON-ZERO IF SO.\r\nPUBLIC\tAUTLIN\r\nAUTLIN\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;CURRENT LINE BEING INSERTED BY AUTO\r\nPUBLIC\tAUTINC\r\nAUTINC\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;THE AUTO INCREMENT\r\nPUBLIC\tSAVTXT\r\nSAVTXT\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;PLACE WHERE NEWSTT SAVES TEXT POINTER\r\n\t\t\t\t;FOR \"RESUME\" STATEMENT\r\nPUBLIC\tSAVSTK\r\nSAVSTK\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;NEWSTT SAVES STACK HERE BEFORE\r\n\t\t\t\t;SO THAT ERROR RECOVERY CAN\r\n\t\t\t\t;RESTORE THE STACK WHEN AN\r\n\t\t\t\t;ERROR OCCURS\r\nPUBLIC\tERRLIN\r\nERRLIN\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;LINE NUMBER WHERE LAST ERROR OCCURED.\r\n\r\nPUBLIC\tDOT\r\nDOT\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;KEEPS CURRENT LINE FOR EDIT & LIST\r\nPUBLIC\tERRTXT\r\nERRTXT\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;TEXT POINTER FOR USE BY \"RESUME\"\r\nPUBLIC\tONELIN\r\nONELIN\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;THE LINE TO GOTO WHEN AN ERROR\r\n\t\t\t\t;OCCURS\r\nPUBLIC\tONEFLG\r\nONEFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;ONEFLG=1 IF WERE ARE EXECUTING\r\n\t\t\t\t;AN ERROR TRAP ROUTINE, OTHERWISE 0\r\nPUBLIC\tSAVSEG\r\nSAVSEG\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;SEGMENT Number Save Area.\r\nPUBLIC\t$DPADR\r\n$DPADR\tLABEL WORD\r\nPUBLIC\tTEMP2\r\nTEMP2\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;FORMULA EVALUATOR TEMP\r\n\t\t\t\t;MUST BE PRESERVED BY OPERATORS\r\n\t\t\t\t;USED IN EXTENDED BY FOUT AND\r\n\t\t\t\t;USER-DEFINED FUNCTIONS\r\n\t\t\t\t;ARRAY VARIABLE HANDLER TEMPORARY\r\nPUBLIC\tOLDLIN\r\nOLDLIN\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;OLD LINE NUMBER (SETUP BY ^C,\"STOP\"\r\n\t\t\t\t;OR \"END\" IN A PROGRAM)\r\nPUBLIC\tOLDTXT\r\nOLDTXT\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;OLD TEXT POINTER\r\n\t\t\t\t;POINTS AT STATEMENT TO BE EXECUTED NEXT\r\nPUBLIC\tVARTAB\r\nVARTAB\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;POINTER TO START OF SIMPLE\r\n\t\t\t\t;VARIABLE SPACE\r\n\t\t\t\t;UPDATED WHENEVER THE SIZE OF THE\r\n\t\t\t\t;PROGRAM CHANGES, SET TO [TXTTAB]+2\r\n\t\t\t\t;BY SCRATCH (\"NEW\").\r\nPUBLIC\tARYTAB\r\nARYTAB\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;POINTER TO BEGINNING OF ARRAY\r\n\t\t\t\t;TABLE\r\n\t\t\t\t;INCREMENTED BY 6 WHENEVER\r\n\t\t\t\t;A NEW SIMPLE VARIABLE IS FOUND, AND\r\n\t\t\t\t;SET TO [VARTAB] BY CLEARC.\r\nPUBLIC\tSTREND\r\nSTREND\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;END OF STORAGE IN USE\r\n\t\t\t\t;INCREASED WHENEVER A NEW ARRAY\r\n\t\t\t\t;OR SIMPLE VARIABLE IS ENCOUNTERED\r\n\t\t\t\t;SET TO [VARTAB] BY CLEARC.\r\nPUBLIC\tDATPTR\r\nDATPTR\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;POINTER TO DATA. INITIALIZED TO POINT\r\n\t\t\t\t;AT THE ZERO IN FRONT OF [TXTTAB]\r\n\t\t\t\t;BY \"RESTORE\" WHICH IS CALLED BY CLEARC\r\n\t\t\t\t;UPDATED BY EXECUTION OF A \"READ\"\r\nPUBLIC\tDEFTBL\r\nDEFTBL\tLABEL WORD\r\n\tDB\t26 DUP(?)\t;THIS GIVES THE DEFAULT VALTYP FOR EACH\r\n\t\t\t\t;LETTER OF THE ALPHABET\r\n\t\t\t\t;IT IS SET UP BY \"CLEAR\" AND CHANGED BY\r\n\t\t\t\t;\"DEFSTR\" \"DEFINT\" \"DEFSNG\" \"DEFDBL\" AND USED\r\n\t\t\t\t;BY PTRGET WHEN ! # % OR $ DON'T FOLLOW\r\n\t\t\t\t;A VARAIBLE NAME\r\n;\r\n; RAM STORAGE FOR USER DEFINED FUNCTION PARAMETER INFORMATION\r\n;\r\n\tPUBLIC\tPRMLEN,PRMLN2,PRMFLG,NOFUNS,PARM1,TEMP9,FUNACT\r\nPUBLIC\tPRMSIZ\r\n\tPRMSIZ=100D\t\t;NUMBER OF BYTES FOR DEFINITION BLOCK\r\nPRMSTK\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;PREVIOUS DEFINITION BLOCK ON STACK\r\n\t\t\t\t;BLOCK (FOR GARBAGE COLLECTION)\r\nPRMLEN\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;THE NUMBER OF BYTES IN THE ACTIVE TABLE\r\nPARM1\tLABEL WORD\r\n\tDB\tPRMSIZ DUP(?)\t;THE ACTIVE PARAMETER DEFINITION TABLE\r\n\tPUBLIC\tPRMPRV,PRMSTK\t;ALLOW INIT TO INITIALIZE THIS CONSTANT\r\nPRMPRV\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;INIIALLY PRMSTK,THE POINTER AT THE PREVIOUS PARAMETER\r\n\t\t\t\t;BLOCK (FOR GARBAGE COLLECTION)\r\nPRMLN2\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;SIZE OF PARAMETER BLOCK BEING BUILT\r\nPUBLIC\tPARM2\r\nPARM2\tLABEL WORD\r\n\tDB\tPRMSIZ DUP(?)\t;PLACE TO KEEP PARAMETERS BEING MADE\r\nPRMFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;USED BY PTRGET TO FLAG IF PARM1 HAS BEEN SEARCHED\r\nPUBLIC\tARYTA2\r\nARYTA2\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;STOPPING POINT FOR SIMPLE SEARCH\r\n\t\t\t\t;(EITHER [ARYTAB] OR PARM1+[PRMLEN])\r\nNOFUNS\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;ZERO IF NO FUNCTIONS ACTIVE. SAVES TIME IN SIMPLE SEARCH\r\nTEMP9\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;GARBAGE COLLECTION TEMP TO CHAIN THROUGH PARAMETER BLOCKS\r\nFUNACT\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;COUNT OF ACTIVE FUNCTIONS\r\nPUBLIC\tINPPAS\r\nINPPAS\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;FLAG TELLING WHETHER INPUT IS SCANNING FIRST OR\r\n\t\t\t\t;SECOND TIME. ZERO IF FIRST.\r\nPUBLIC\tNXTTXT\r\nNXTTXT\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;USED TO SAVE TEXT POINTER AT START OF NEXT\r\nPUBLIC\tNXTFLG\r\nNXTFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;ZERO IF \"FOR\" IS USING NEXT CODE\r\n\t\t\t\t;TO CHECK FOR EMPTY LOOP\r\nPUBLIC\tFVALSV\r\nFVALSV\tLABEL WORD\r\n\tDB\t4 DUP(?)\t;USE TO STORE THE START VALUE OF THE LOOP VARIABLE\r\n\t\t\t\t;SINCE ANSI SAYS START AND END ARE EVALUATED\r\n\t\t\t\t;BEFORE ASSIGNMENT TAKES PLACE.\r\nPUBLIC\tNXTLIN\r\nNXTLIN\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;THE LINE NUMBER DURING SCAN FOR \"NEXT\"\r\nPUBLIC\tOPTVAL\r\nOPTVAL\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;ZERO FOR OPTION BASE 0 ONE FOR OPTION BASE 1\r\nPUBLIC\tOPTFLG\r\nOPTFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;NON-ZERO IF \"OPTION BASE\" HAS BEEN SCANNED\r\nPUBLIC\tTOPTVL\r\nTOPTVL\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;temp- holds OPTVAL during Chain\r\nPUBLIC\tTOPTFG\r\nTOPTFG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;temp- holds OPTFLG during Chain\r\nPUBLIC\tTEMPA\r\nTEMPA\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;MISC TEMP USED BY CALL AND LIST\r\nPUBLIC\tSAVFRE\r\nSAVFRE\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;FRETOP SAVED HERE BY CHAIN\r\nPUBLIC\tPROFLG\r\nPROFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;NON-ZERO IF WE HAVE LOADED A PROTECTED FILE W/O PASSWRD\r\nPUBLIC\tMRGFLG\r\nMRGFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;NON-ZERO IF CHAIN W/ MERGE IN PROGRESS\r\nPUBLIC\tMDLFLG\r\nMDLFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;NON-ZERO I CHAIN W/ MERGE AND DELETE IN PROGRESS\r\nPUBLIC\tCMEPTR\r\nCMEPTR\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;POINTER TO END LINE TO DELETE\r\nPUBLIC\tCMSPTR\r\nCMSPTR\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;POINTER TO START LINE TO DELETE\r\nPUBLIC\tCHNFLG\r\nCHNFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;NON-ZERO IF CHAIN IN PROGRESS\r\nPUBLIC\tCHNLIN\r\nCHNLIN\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;DESTINATION LINE IN NEW PROGRAM\r\nPUBLIC\tSWPTMP\r\nSWPTMP\tLABEL WORD\r\n\tDB\t4 DUP(?)\t;VALUE OF FIRST \"SWAP\" VARIABLE STORED HERE\r\n\tDB\t4 DUP(?)\t;ENOUGH ROOM FOR DBL PRECISION\r\nPUBLIC\tTRCFLG\r\nTRCFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;ZERO MEANS NO TRACE IN PROGRESS\r\n\r\n;-------------------------------------------------------------\r\n; THIS IS THE RAM TEMPORARY AREA FOR THE MATH PACKAGE ROUTINES\r\n;-------------------------------------------------------------\r\nPUBLIC\tEXPAF\r\nEXPAF\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;Exponent adjustment factor\r\n\t\t\t\t;used during E format to adjust exp\r\n\t\t\t\t;if field overflow occurs\r\nPUBLIC\tEXPTMP\r\nEXPTMP\tLABEL WORD\r\n\tDB\t8 DUP(?)\t;Temp FAC save area used while\r\n\t\t\t\t;testing FAC for field overflow\r\n\t\t\t\t;of E formated output\r\nPUBLIC\tTEMPB\r\nTEMPB\tLABEL WORD\t\t;Used by FIELD\r\nPUBLIC\tRECRD\r\nRECRD\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;Record #\r\nPUBLIC\tLBUFF\r\nLBUFF\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;Logical buffer address\r\nPUBLIC\tPBUFF\r\nPBUFF\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;Physical buffer address\r\nPUBLIC\tPGTFLG\r\nPGTFLG\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;PUT/GET flag (Non zero=PUT)\r\n\tDB\t1 DUP(?)\t;DOUBLE PRECISION BUFFER\r\nPUBLIC\t$DBUFF\r\n$DBUFF\tLABEL WORD\r\n\tDB\t9 DUP(?)\r\nPUBLIC\t$FMTCX\r\n$FMTCX\tLABEL WORD\r\n\tDB\t2 DUP(?)\r\nPUBLIC\t$FMTAX\r\n$FMTAX\tLABEL WORD\r\nPUBLIC\t$FMTAL\r\n$FMTAL\tLABEL WORD\r\n\tDB\t2 DUP(?)\r\n\tDB\t1 DUP(?)\r\nPUBLIC\t$ZLO\r\n$ZLO\tLABEL WORD\r\n\tDB\t0\r\n\tDB\t6 DUP(?)\r\nPUBLIC\t$ZX\r\n$ZX\tLABEL WORD\r\n\tDB\t0\r\nPUBLIC\t$Z1LO\r\n$Z1LO\tLABEL WORD\r\n\tDB\t7 DUP(?)\r\nPUBLIC\t$Z1\r\n$Z1\tLABEL WORD\r\n\tDB\t0\r\n\t.RADIX\t10\r\n;\r\n;THE FLOATING ACCUMULATOR\r\n;\r\n\tDB\t1 DUP(?)\t;[TEMPORARY LEAST SIGNIFICANT BYTE]\r\n\tDB\t8 DUP(?)\t;EXTRA STORAGE FOR D.P. MULTIPLY\r\nPUBLIC\t$DFACL\r\n$DFACL\tLABEL WORD\r\nPUBLIC\tDFACLO\r\nDFACLO\tLABEL WORD\r\n\tDB\t4 DUP(?)\t;FOUR LOWEST ORDERS FOR DOUBLE PRECISION\r\nPUBLIC\t$FACLO\r\n$FACLO\tLABEL WORD\r\nPUBLIC\tFACLO\r\nFACLO\tLABEL WORD\r\n\tDB\t2 DUP(?)\r\nPUBLIC\t$FACM1\r\n$FACM1\tLABEL WORD\r\n\tDB\t1 DUP(?)\r\n\t\t\t\t;[MIDDLE ORDER OF MANTISSA]\r\n\t\t\t\t;[HIGH ORDER OF MANTISSA]\r\nPUBLIC\t$FAC\r\n$FAC\tLABEL WORD\r\nPUBLIC\tFAC\r\nFAC\tLABEL WORD\r\n\tDB\t2 DUP(?)\t;[EXPONENT]\r\n\t\t\t\t;[TEMPORARY COMPLEMENT OF SIGN IN MSB]\r\nPUBLIC\t$FLGOV\r\n$FLGOV\tLABEL WORD\r\nPUBLIC\tFLGOVC\r\nFLGOVC\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;OVERFLOW PRINT FLAG,=0,1 PRINT\r\n\t\t\t\t;FURTHER =1 CHANGE TO 2\r\nPUBLIC\tOVCSTR\r\nOVCSTR\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;PLACE TO STORE OVERFLOW FLAG AFTER FIN\r\nPUBLIC\tFLGSCN\r\nFLGSCN\tLABEL WORD\r\n\tDB\t1 DUP(?)\t;FLAGS INPUT CODE EXECUTING FOR SCNVAL\r\n\tDB\t1 DUP(?)\t;[TEMPORARY LEAST SIGNIFICANT BYTE]\r\nPUBLIC\t$ARGLO\r\n$ARGLO\tLABEL WORD\r\nPUBLIC\tARGLO\r\nARGLO\tLABEL WORD\r\n\tDB\t7 DUP(?)\t;[LOCATION OF SECOND ARGUMENT FOR DOUBLE\r\n\t\t\t\t; PRECISION]\r\nPUBLIC\t$ARG\r\n$ARG\tLABEL WORD\r\nPUBLIC\tARG\r\nARG\tLABEL WORD\r\n\tDB\t1 DUP(?)\r\nPUBLIC\t$FBUFF\r\n$FBUFF\tLABEL WORD\r\nPUBLIC\tFBUFFR\r\nFBUFFR\tLABEL WORD\r\n\tDB\t13 DUP(?)\t;BUFFER FOR FOUT\r\n\tDB\t43-13 DUP(?)\t;THE LAST 3 LOCATIONS ARE TEMP FOR ROM FMULT\r\nPUBLIC\tFMLTT1\r\n\tFMLTT1=FBUFFR+40\r\nPUBLIC\tFMLTT2\r\n\tFMLTT2=FBUFFR+41\r\n\r\n\r\n\tPUBLIC\tTSTACK\r\nTSTACK\tLABEL WORD\r\n\r\nDSEG\tENDS\t\t\t; End of the data segment\r\n\r\n\t__RET=0\t\t\t;SO WE DON'T GET PHASE ERRORS IN 8086 VERSION\r\n\r\n\r\n\tSUBTTL TEXT CONSTANTS FOR PRINT OUT\r\n;\r\n; NEEDED FOR MESSAGES IN ALL VERSIONS\r\n;\r\n\r\nPUBLIC\tINTXT\r\nINTXT:\tDB\" in \"\r\n\tDB\t0\r\n\r\nPUBLIC\tREDDY\r\nREDDY:\r\n\tDB\"Ok\"\r\n\tDB\t377O\t\t;FLAG AS NOT BEING USER INPUT\r\n\tACRLF\t\r\n\tDB\t0\r\n\r\nPUBLIC\tBRKTXT\r\nBRKTXT:\tDB\"Break\"\r\n\tDB\t0\r\n\r\n\r\n;\r\n; The reserve word tables have dispatch address the could be external.\r\n; ASM86 can only output external declarations during pass 1, so we\r\n; have to construct a chain of possible externals and check each one.\r\n; The following macro runs through the chain and declares any undefined\r\n; addresses as external :NEAR.  For more information, see the file\r\n; PS1:<BASIC.ASM86>BINTRP.H\r\n;\r\n\tDO_EXT\t\r\n;\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GWEVAL.ASM",
          "type": "blob",
          "size": 49.125,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tBINTRP.H \r\n\r\n\tTITLE   GWEVAL Copied from BINTRP.MAC\r\n\r\n\t.RADIX\t10\r\n\r\n\t.XLIST\r\n\r\nFETOK=0\t\t\t\t;For FE extended tokens\r\nFDTOK=0\t\t\t\t;For FD tokens too.  (Must have\r\n\t\t\t\t;FETOK==1.)\r\n\t\t\t\t;tokens.\r\nINTDEX=0\t\t\t;For Intelledex version.\r\nNMPAGE=1\t\t\t;Number of text pages (for GW\r\n\t\t\t\t;Multi-page)\r\n\t\t\t\t;KPOS, etc.\r\nLNREAD=0\t\t\t;For LINE READ statement\r\nMELCO=0\t\t\t\t;Mitsubishi Electronics Co.\r\nSIRIUS=0\r\nMCI=0\r\nZENITH=0\t\t\t;ZENITH 8086\r\nTETRA=0\r\nCPM86=0\r\nHAL=0\r\nGENFLS=0\r\nPANDBL=0\r\nTSHIBA=0\r\nSGS=0\r\nALPS=0\r\nALPCPM=0\r\nGENWID=0\r\nNNECBS=0\r\nCAN8=0\r\nPC8A=0\r\n\r\n\tFN2SW=0\t\t\t;IBMTOK versions dispatch from IBMRES.MAC\r\n\tLABEL=PC8A\r\n\tHLPEDT=PC8A\r\n\r\nOKI=0\r\nBUBL=0\r\n\tNORNF=0\r\nIEESLV=0\r\nTRSHHC=0\r\nOLVPPC=0\r\nNECPPC=0\r\nUSA=0\t\t\t\t;For HHC-USA version\r\nEUROPE=0\t\t\t;For HHC-EUROPE version\r\n\t.LIST\r\n\r\n;Local Switches\r\n;\r\n\tLTRACE=ALPCPM\t\t;trace output selectable\r\n\tLABEL=PC8A\r\n\tHLPEDT=PC8A\r\n\tUCEMSG=NNECBS\t\t;Upper case error messages.\r\n\tOLD86=MELCO AND CPM86\t;For \"old\" 8086 error messages (prior\r\n\t\t\t\t;to alignment for IBM compatibility).\r\n\r\n\tOLDBLD=ALPCPM OR ALPS OR OKI OR HAL OR PC8A OR BUBL OR GW OR TSHIBA\r\n\r\n\tINCLUDE\tGIO86U\r\n\tINCLUDE\tMSDOSU\t\t;MSDOS constants\r\n\r\n\r\n\r\n\r\n\tEXTRN\tINIT:NEAR\r\n\r\n\r\n\r\n\r\n\tEXTRN\tSETGSB:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tONGSBF:WORD\r\nDSEG\tENDS\r\n\r\n\r\n\tBUFOFS=0\r\n\r\n\tBUFOFS=2\t\t;MUST CRUNCH INTO ERALIER PLACE FOR\r\n\t\t\t\t; SINGLE QUOTE\r\n\r\n\tKBFLEN=BUFLEN+(BUFLEN/4)\t;MAKE KRUNCH BUFFER SOMEWHAT\r\n\t\t\t\t; LARGER THAN SOURCE BUFFER (BUF)\r\n\r\n\r\n\r\n\r\n\tEXTRN\tNAME:NEAR\r\n\tEXTRN\tINLIN:NEAR,CRDO:NEAR,CRDONZ:NEAR,STRCMP:NEAR,FININL:NEAR\r\n\tEXTRN\tPPSWRT:NEAR\r\n\r\n\tEXTRN\tOUTDO:NEAR\r\n\r\n\tEXTRN\tBLTU:NEAR,CLEARC:NEAR,GTMPRT:NEAR,ISLET:NEAR,ISLET2:NEAR\r\n\tEXTRN\tPTRGET:NEAR\r\n\tEXTRN\tQINLIN:NEAR,SCRTCH:NEAR,STKINI:NEAR,RUNC:NEAR,RESFIN:NEAR\r\n\tEXTRN\tPTRGT2:NEAR,STPEND:NEAR,DIM:NEAR\r\n\r\n\tEXTRN\tDCOMPR:NEAR,SYNCHR:NEAR\r\n\r\n\tEXTRN\tSIGN:NEAR\r\n\r\n\tEXTRN\tPRGFIN:NEAR,FILIND:NEAR\r\n\r\n\tEXTRN\tFILINP:NEAR,CLSALL:NEAR,INDSKC:NEAR\r\n\r\n\r\n\tEXTRN\tLRUN:NEAR\r\n\r\n\tEXTRN\tFILGET:NEAR\r\n\r\n\r\n\tEXTRN\tINXHRT:NEAR\r\n\tEXTRN\tSGN:NEAR,ABSFN:NEAR,SQR:NEAR,FDIV:NEAR,FSUB:NEAR\r\n\tEXTRN\tFMULT:NEAR,RND:NEAR\t;MATHPK INTERNALS\r\n\tEXTRN\tZERO:NEAR,MOVE:NEAR,FOUT:NEAR,FIN:NEAR,FCOMP:NEAR\r\n\tEXTRN\tFADD:NEAR,PUSHF:NEAR,INT:NEAR\r\n\tEXTRN\tMOVFR:NEAR,MOVRF:NEAR,MOVRM:NEAR,INPRT:NEAR,LINPRT:NEAR\r\n\tEXTRN\tFDIVT:NEAR\r\n\tEXTRN\tMOVFM:NEAR,MOVMF:NEAR,FADDS:NEAR\r\n\tEXTRN\tINRART:NEAR,NEG:NEAR\r\n\tEXTRN\tBSERR:NEAR\r\n\tEXTRN\tCAT:NEAR,FREFAC:NEAR,FRESTR:NEAR,FRETMP:NEAR,FRETMS:NEAR\r\n\tEXTRN\tSTRCPY:NEAR,GETSTK:NEAR\r\n\tEXTRN\tSTRLIT:NEAR,STRLT2:NEAR,STRLT3:NEAR,STRLTI:NEAR,STROUT:NEAR\r\n\tEXTRN\tSTRPRT:NEAR,STROUI:NEAR\r\n\tEXTRN\tGETSPA:NEAR,PUTNEW:NEAR,STOP:NEAR,OMERR:NEAR,REASON:NEAR\r\n\r\n\tEXTRN\tGARBA2:NEAR\t;We have our own G. C.\r\n\r\n\r\n\tEXTRN\tINSTR:NEAR\r\n\r\n\tEXTRN\tPRINUS:NEAR,PUTTMP:NEAR\r\n\r\n\tEXTRN\tFOUTH:NEAR,FOUTO:NEAR,STRO$:NEAR,STRH$:NEAR\r\n\r\n\r\n\tEXTRN\tSTRNG$:NEAR\r\n\tEXTRN\tTON:NEAR,TOFF:NEAR\r\n\tEXTRN\tSPACE$:NEAR\r\n\r\n\tEXTRN\tSIGNS:NEAR\r\n\r\n\r\n\r\n\r\n\tEXTRN\tUMULT:NEAR\r\n\r\n\tEXTRN\tSIGNC:NEAR,POPHRT:NEAR\r\n\r\n\tEXTRN\tFINLPT:NEAR\r\n\r\n\tEXTRN\tCONSIH:NEAR,VMOVFA:NEAR,VMOVAF:NEAR,ISIGN:NEAR,CONIA:NEAR\r\n\tEXTRN\tVSIGN:NEAR,VDFACS:NEAR\r\n\tEXTRN\tVMOVMF:NEAR,VMOVFM:NEAR,FRCINT:NEAR,FRCSNG:NEAR,FRCDBL:NEAR\r\n\tEXTRN\tVNEG:NEAR,PUFOUT:NEAR,DCXBRT:NEAR,IADD:NEAR\r\n\tEXTRN\tISUB:NEAR,IMULT:NEAR,ICOMP:NEAR,INEG:NEAR,DADD:NEAR\r\n\tEXTRN\tDSUB:NEAR,DMULT:NEAR,DDIV:NEAR,DCOMP:NEAR,VINT:NEAR\r\n\tEXTRN\tFINDBL:NEAR,INEG2:NEAR\r\n\tEXTRN\tIDIV:NEAR,IMOD:NEAR\r\n\tEXTRN\tVMOVE:NEAR,VALINT:NEAR,VALSNG:NEAR,FRCSTR:NEAR,CHKSTR:NEAR\r\n\tEXTRN\tMAKINT:NEAR\r\n\tEXTRN\tMOVE1:NEAR\r\n\r\n\tEXTRN\tSCNSEM:NEAR\r\n\tEXTRN\tWHILE:NEAR,WEND:NEAR\r\n\tEXTRN\tCALLS:NEAR\r\n\tEXTRN\tPROCHK:NEAR\r\n;The following block of externals was added on Dec 19, 1982 when BINTRP was\r\n; Split up after the freeze of GW-BASIC Version 1.0\r\n; This Split-up was not reflected in the PS1:<BASIC>BINTRP.MAC source.\r\n; See Tom Corbett if you have any questions.\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tEXTRN\tMEMSIZ:WORD,FRETOP:WORD,VARTAB:WORD,STREND:WORD,TXTTAB:WORD\r\n\tEXTRN\tARYTAB:WORD\r\n\tEXTRN\tCURLIN:WORD,DOT:WORD,DATLIN:WORD,NLONLY:WORD,ERRLIN:WORD\r\n\tEXTRN\tERRTXT:WORD\r\n\tEXTRN\tMRGFLG:WORD,CHNFLG:WORD\r\n\tEXTRN\tSAVSTK:WORD,SAVTXT:WORD,OLDLIN:WORD,NXTLIN:WORD,OLDTXT:WORD\r\n\tEXTRN\tONELIN:WORD,ONEFLG:WORD\r\n\tEXTRN\tCNTOFL:WORD,TRCFLG:WORD,CONSAV:WORD,CONTXT:WORD,CONTYP:WORD\r\n\tEXTRN\tNUMCON:WORD,CONLO:WORD\r\n\tEXTRN\tAUTFLG:WORD,AUTLIN:WORD,AUTINC:WORD\r\n\tEXTRN\tKBUF:WORD,BUFMIN:WORD,BUF:WORD\r\n\tEXTRN\tPTRFIL:WORD,PTRFLG:WORD,DORES:WORD,VALTYP:WORD,FACLO:WORD\r\n\tEXTRN\tDFACLO:WORD,FAC:WORD\r\n\tEXTRN\tTEMP:WORD,TEMP2:WORD,TEMP3:WORD,TEMPA:WORD\r\n\tEXTRN\tDSCTMP:WORD,TEMPST:WORD\r\n\tEXTRN\tOPRTYP:WORD\r\n\tEXTRN\tSUBFLG:WORD,FVALSV:WORD,DEFTBL:WORD,FLGINP:WORD,FLGSCN:WORD\r\n\tEXTRN\tOVCSTR:WORD,INPPAS:WORD\r\n\tEXTRN\tUSRTAB:WORD,DONUM:WORD,ENDPRG:WORD,ENDFOR:WORD,DATPTR:WORD\r\n\tEXTRN\tFLGOVC:WORD\r\n\tEXTRN\tERRFLG:WORD,SAVSEG:WORD,PRMLN2:WORD,PARM2:WORD,PRMLEN:WORD\r\n\tEXTRN\tPRMSTK:WORD,PARM1:WORD\r\n\tEXTRN\tFUNACT:WORD,NOFUNS:WORD,OPTVAL:WORD,OPTFLG:WORD,RNDX:WORD\r\nDSEG\tENDS\r\n\r\n\tEXTRN\tOPTAB:NEAR,OPCNT:NEAR,INTDSP:NEAR,SNGDSP:NEAR,DBLDSP:NEAR\r\n\tEXTRN\tFRCTBL:NEAR,PRMSIZ:NEAR\r\n\tEXTRN\t$OVMSG:NEAR,ERRTAB:NEAR,LSTERR:NEAR,DSKERR:NEAR,NONDSK:NEAR\r\n\tEXTRN\tREDDY:NEAR\r\n\tEXTRN\tERRSN:NEAR,ERRDV0:NEAR,ERRRE:NEAR,ERROV:NEAR,ERRMO:NEAR\r\n\tEXTRN\tERRTM:NEAR,ERRNF:NEAR\r\n\tEXTRN\tERRNR:NEAR,ERRLBO:NEAR,ERRDD:NEAR,ERRUF:NEAR,ERRUE:NEAR\r\n\tEXTRN\tERRFC:NEAR\r\n\tEXTRN\tERRIFN:NEAR,ERRFNO:NEAR,ERRDNA:NEAR,ERRFDR:NEAR,ERRRAD:NEAR\r\n\tEXTRN\tERRDFL:NEAR\r\n\tEXTRN\tERRIOE:NEAR,ERRBFM:NEAR,ERRFNF:NEAR,ERRBFN:NEAR,ERRIER:NEAR\r\n\tEXTRN\tERRRPE:NEAR\r\n\tEXTRN\tERRFAO:NEAR,ERRNMF:NEAR,ERRWH:NEAR,ERRBRN:NEAR,ERRFOV:NEAR\r\n\tEXTRN\tERRTMF:NEAR\r\n\tEXTRN\tERRFAE:NEAR,ERRUS:NEAR,ERRRG:NEAR,ERROD:NEAR,ERRID:NEAR\r\n\tEXTRN\tERRFN:NEAR\r\n\tEXTRN\tERRUE1:NEAR\t;ERRUE+DSKERR-NONDSK\r\n\tEXTRN\tDSKER1:NEAR\t;DSKERR-NONDSK\r\n\r\n;The following externs are defined in GWMAIN.MAC\r\n;\r\n\tEXTRN\tTMERR:NEAR,SNERR:NEAR,CHRGTR:NEAR,MOERR:NEAR,OVERR:NEAR\r\n\tEXTRN\tFCERR:NEAR,ERROR:NEAR\r\n\tEXTRN\tCONFAC:NEAR,FRMQNT:NEAR,DATA:NEAR,LETCN4:NEAR,$STPRN:NEAR\r\n\tEXTRN\tONECON:NEAR,DBLCON:NEAR\r\n\tEXTRN\tFRQINT:NEAR,LINGET:NEAR,UFERR:NEAR\r\n\r\n\r\n\r\n\r\n;\r\n; The reserved word tables are in another module.  Consequently\r\n; many things must be declared external.  All of these things\r\n; are in the code segement or are absolutes (like tokens).\r\n; I.e., they are not in the data segment.\r\n;\r\n\r\n\tEXTRN\tCLINTK:NEAR\r\n\tEXTRN\tEQULTK:NEAR,ERCTK:NEAR,ERLTK:NEAR\r\n\tEXTRN\tFNTK:NEAR,FUNDSP:NEAR\r\n\tEXTRN\tGREATK:NEAR\r\n\tEXTRN\tINSRTK:NEAR\r\n\tEXTRN\tLESSTK:NEAR,LSTOPK:NEAR\r\n\tEXTRN\tMIDTK:NEAR,MINUTK:NEAR\r\n\tEXTRN\tNMREL:NEAR,NOTTK:NEAR\r\n\tEXTRN\tONEFUN:NEAR\r\n\tEXTRN\tPLUSTK:NEAR\r\n\tEXTRN\tUSRTK:NEAR\r\n\tEXTRN\t$INKEY$:NEAR,$INPUT:NEAR\r\n\tEXTRN\t$POINT:NEAR\r\n\tEXTRN\t$SCREEN:NEAR,$STRING$:NEAR\r\n\tEXTRN\t$VARPTR:NEAR\r\n;\r\n; Since the dispatch table is also no longer in BINTRP many\r\n; addresses need to be declared internal.\r\n;\r\n\tPUBLIC\tDEF\r\n\tPUBLIC\tFNINP,FNOUT,FNWAIT\r\n\tPUBLIC\tLABBCK\r\n\r\n\tSUBTTL FORMULA EVALUATION CODE\r\n\r\n;\r\n; THE FORMULA EVALUATOR STARTS WITH\r\n; [H,L] POINTING TO THE FIRST CHARACTER OF THE FORMULA.\r\n; AT THE END [H,L] POINTS TO THE TERMINATOR.\r\n; THE RESULT IS LEFT IN THE FAC.\r\n; ON RETURN [A] DOES NOT REFLECT THE TERMINATING CHARACTER\r\n;\r\n; THE FORMULA EVALUATOR USES THE OPERATOR TABLE (OPTAB)\r\n; TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR\r\n; EACH OPERATOR.\r\n; A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT\r\n;\r\n; THE ADDRESS OF 'RETAOP' -- THE PLACE TO RETURN ON COMPLETION\r\n; OF OPERATOR APPLICATION\r\n;\r\n; THE FLOATING POINT TEMPORARY RESULT\r\n;\r\n; THE ADDRESS OF THE OPERATOR ROUNTINE\r\n;\r\n; THE PRECEDENCE OF THE OPERATOR\r\n;\r\n; TOTAL 10 BYTES\r\n;\r\nPUBLIC\tFRMEQL\r\nFRMEQL:\tCALL\tSYNCHR\r\n\tDB\tOFFSET EQULTK\t;CHECK FOR EQUAL SIGN\r\n\tJMP\tFRMEVL\r\nPUBLIC\tFRMPRN\r\nFRMPRN:\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"(\"\t;GET PAREN BEFORE FORMULA\r\nPUBLIC\tFRMEVL\r\nFRMEVL:\tDEC\tBX\t\t;BACK UP CHARACTER POINTER\r\nPUBLIC\tFRMCHK\r\nFRMCHK:\tMOV\tDH,LOW 0\t;INITIAL DUMMY PRECEDENCE IS 0\r\nLPOPER:\tPUSH\tDX\t\t;SAVE PRECEDENCE\r\n\tMOV\tCL,LOW 1\t;EXTRA SPACE NEEDED FOR RETURN ADDRESS\r\n\tCALL\tGETSTK\t\t;MAKE SURE THERE IS ROOM FOR RECURSIVE CALLS\r\n\tCALL\tEVAL\t\t;EVALUATE SOMETHING\r\n\t\t\t\t;RESET OVERFLOW PRINTING BACK TO NORMAL\r\n\tXOR\tAL,AL\t\t;(SET TO 1 AT FUNDSP TO SUPPRESS\r\n\tMOV\tBYTE PTR FLGOVC,AL\t;MULTIPLE OVERFLOW MESSAGES)\r\nPUBLIC\tTSTOP\r\nTSTOP:\tMOV\tTEMP2,BX\t;SAVE TEXT POINTER\r\nRETAOP:\tMOV\tBX,TEMP2\t;RESTORE TEXT PTR\r\n\tPOP\tCX\t\t;POP OFF THE PRECEDENCE OF OLDOP\r\nNOTSTV:\tMOV\tAL,BYTE PTR [BX]\t;GET NEXT CHARACTER\r\n\tMOV\tTEMP3,BX\t;SAVE UPDATED CHARACTER POINTER\r\n\tCMP\tAL,LOW OFFSET GREATK\t;IS IT AN OPERATOR?\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;NO, ALL DONE (THIS CAN RESULT IN OPERATOR\r\n\t\t\t\t;APPLICATION OR ACTUAL RETURN)\r\n\tCMP\tAL,LOW OFFSET LESSTK+1\t;SOME KIND OF RELATIONAL?\r\n\tJB\tSHORT DORELS\t;YES, DO IT\r\n\tSUB\tAL,LOW OFFSET PLUSTK\t;SUBTRACT OFFSET FOR FIRST ARITHMETIC\r\n\tMOV\tDL,AL\t\t;MUST MULTIPLY BY 3 SINCE\r\n\t\t\t\t;OPTAB ENTRIES ARE 3 LONG\r\n\tJNZ\tSHORT NTPLUS\t;NOT ADDITION OP\r\n\tMOV\tAL,BYTE PTR VALTYP\t;SEE IF LEFT PART IS STRING\r\n\tCMP\tAL,LOW 3\t;SEE IF ITS A STRING\r\n\tMOV\tAL,DL\t\t;REFETCH OP-VALUE\r\n\tJNZ\tSHORT ??L000\r\n\tJMP\tCAT\t\t;MUST BE CAT\r\n??L000:\r\nNTPLUS:\r\n\tCMP\tAL,LOW OFFSET LSTOPK\t;HIGHER THAN THE LAST OP?\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;YES, MUST BE TERMINATOR\r\n\tMOV\tBX,OFFSET OPTAB\t;CREATE INDEX INTO OPTAB\r\n\tMOV\tDH,LOW 0\t;MAKE HIGH BYTE OF OFFSET=0\r\n\tADD\tBX,DX\t\t;ADD IN CALCULATED OFFSET\r\n\tMOV\tAL,CH\t\t;[A] GETS OLD PRECEDENCE\r\n\tINS86\t56\t\t;CODE SEGMENT FETCH\r\n\tMOV\tDH,BYTE PTR [BX]\t;REMEMBER NEW PRECEDENCE\r\n\tCMP\tAL,DH\t\t;OLD-NEW\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;MUST APPLY OLD OP\r\n\t\t\t\t;IF HAS GREATER OR = PRECEDENCE\r\n\t\t\t\t;NEW OPERATOR\r\n\r\n\tPUSH\tCX\t\t;SAVE THE OLD PRECEDENCE\r\n\tMOV\tCX,OFFSET RETAOP\t;PUT ON THE ADDRESS OF THE\r\n\tPUSH\tCX\t\t;PLACE TO RETURN TO AFTER OPERATOR APPLICATION\r\n\tMOV\tAL,DH\t\t;SEE IF THE OPERATOR IS EXPONENTIATION\r\n\tCMP\tAL,LOW 127\t;WHICH HAS PRECEDENCE 127\r\n\tJZ\tSHORT EXPSTK\t;IF SO, \"FRCSNG\" AND MAKE A SPECIAL STACK ENTRY\r\n\tCMP\tAL,LOW 81\t;SEE IF THE OPERATOR IS \"AND\" OR \"OR\"\r\n\tJB\tSHORT ANDORD\t;AND IF SO \"FRCINT\" AND\r\n\t\t\t\t;MAKE A SPECIAL STACK ENTRY\r\n\tAND\tAL,LOW 254\t;MAKE 123 AND 122 BOTH MAP TO 122\r\n\tCMP\tAL,LOW 122\t;MAKE A SPECIAL CHECK FOR \"MOD\" AND \"IDIV\"\r\n\tJZ\tSHORT ANDORD\t;IF SO, COERCE ARGUMENTS TO INTEGER\r\n; THIS CODE PUSHES THE CURRENT VALUE IN THE FAC\r\n; ONTO THE STACK, EXCEPT IN THE CASE OF STRINGS IN WHICH IT CALLS\r\n; TYPE MISMATCH ERROR. [D] AND [E] ARE PRESERVED.\r\n;\r\nNUMREL:\r\n\tMOV\tAL,BYTE PTR VALTYP\t;FIND OUT WHAT TYPE OF VALUE WE ARE SAVING\r\n\tSUB\tAL,LOW 3\t;SETUP THE CONDITION CODES\r\n\t\t\t\t;SET ZERO FOR STRINGS\r\n\tJNZ\tSHORT ??L001\r\n\tJMP\tTMERR\r\n??L001:\r\n\tINS86\t377,66,FACLO\t;PUSH FACLO\r\n\tJNS\tSHORT ??L002\r\n\tJMP\tVPUSHD\t\t;ALL DONE IF THE DATA WAS AN INTEGER\r\n??L002:\r\n\tINS86\t377,66,FACLO+2\t;PUSH FAC-1,0 ON THE STACK\r\n\tJP\tSHORT ??L003\r\n\tJMP\tVPUSHD\t\t;ALL DONE IF WE HAD A SNG\r\n??L003:\r\n\tINS86\t377,66,DFACLO\t;PUSH ON LOW BYTES OF DP FAC\r\n\tINS86\t377,66,DFACLO+2\t;PUSH ON NEXT TWO BYES OF DP FAC\r\nVPUSHD:\r\n\tADD\tAL,LOW 3\t;FIX [A] TO BE THE VALTYP OF THE NUMBER\r\n\t\t\t\t;JUST PUSHED ON THE STACK\r\n\tMOV\tCL,DL\t\t;[C]=OPERATOR NUMBER\r\n\tMOV\tCH,AL\t\t;[B]=TYPE OF VALUE ON THE STACK\r\n\tPUSH\tCX\t\t;SAVE THESE THINGS FOR APPLOP\r\n\tMOV\tCX,OFFSET APPLOP\t;GENERAL OPERATOR APPLICATION\r\n\t\t\t\t;ROUTINE -- DOES TYPE CONVERSIONS\r\nFINTMP:\tPUSH\tCX\t\t;SAVE PLACE TO GO\r\n\tMOV\tBX,TEMP3\t;REGET THE TEXT POINTER\r\n\tJMP\tLPOPER\r\nDORELS:\tMOV\tDH,LOW 0\t;ASSUME NO RELATION OPS\r\n\t\t\t\t;ALSO SETUP THE HIGH ORDER OF THE INDEX INTO OPTAB\r\nLOPREL:\tSUB\tAL,LOW OFFSET GREATK\t;IS THIS ONE RELATION?\r\n\tJB\tSHORT FINREL\t;RELATIONS ALL THROUGH\r\n\tCMP\tAL,LOW OFFSET NMREL\t;IS IT REALLY RELATIONAL?\r\n\tJAE\tSHORT FINREL\t;NO JUST BIG\r\n\tCMP\tAL,LOW 1\t;SET UP BITS BY MAPPING\r\n\tRCL\tAL,1\t\t;0 TO 1 1 TO 2 AND 2 TO 4\r\n\tXOR\tAL,DH\t\t;BRING IN THE OLD BITS\r\n\tCMP\tAL,DH\t\t;MAKE SURE RESULT IS BIGGER\r\n\tMOV\tDH,AL\t\t;SAVE THE MASK\r\n\tJAE\tSHORT ??L004\r\n\tJMP\tSNERR\t\t;DON'T ALLOW TWO OF THE SAME\r\n??L004:\r\n\tMOV\tTEMP3,BX\t;SAVE CHARACTER POINTER\r\n\tCALL\tCHRGTR\t\t;GET THE NEXT CANDIDATE\r\n\tJMP\tSHORT LOPREL\r\n;\r\n; FOR EXPONENTIATION WE WANT TO FORCE THE CURRENT VALUE IN THE FAC\r\n; TO BE SINGLE PRECISION. WHEN APPLICATION TIME COMES WE FORCE\r\n; THE RIGHT HAND OPERAND TO SINGLE PRECISION AS WELL\r\n;\r\n\tEXTRN\tFPWRQ:NEAR\r\nEXPSTK:\tCALL\tFRCSNG\t\t;COERCE LEFT HAND OPERAND\r\n\tCALL\tPUSHF\t\t;PUT IT ON THE STACK\r\n\tMOV\tCX,OFFSET FPWRQ\t;PLACE TO COERCE RIGHT HAND\r\n\t\t\t\t;OPERAND AND DO EXPONENTIATION\r\n\tMOV\tDH,LOW 127\t;RESTORE THE PRECEDENCE\r\n\tJMP\tSHORT FINTMP\t;FINISH ENTRY AND EVALUATE MORE FORMULA\r\n;\r\n; FOR \"AND\" AND \"OR\" AND \"\\\" AND \"MOD\" WE WANT TO FORCE THE CURRENT VALUE\r\n; IN THE FAC TO BE AN INTEGER, AND AT APPLICATION TIME FORCE THE RIGHT\r\n; HAND OPERAND TO BE AN INTEGER\r\n;\r\nANDORD:\tPUSH\tDX\t\t;SAVE THE PRECEDENCE\r\n\tCALL\tFRCINT\r\n\tPOP\tDX\t\t;[D]=PRECEDENCE\r\n\tPUSH\tBX\t\t;PUSH THE LEFT HAND OPERAND\r\n\tMOV\tCX,OFFSET DANDOR\t;\"AND\" AND \"OR\" DOER\r\n\tJMP\tSHORT FINTMP\t;PUSH ON THIS ADDRESS,PRECEDENCE\r\n\t\t\t\t;AND CONTINUE EVALUATION\r\n;\r\n; HERE TO BUILD AN ENTRY FOR A RELATIONAL OPERATOR\r\n; STRINGS ARE TREATED SPECIALLY. NUMERIC COMPARES ARE DIFFERENT\r\n; FROM MOST OPERATOR ENTRIES ONLY IN THE FACT THAT AT THE\r\n; BOTTOM INSTEAD OF HAVING RETAOP, DOCMP AND THE RELATIONAL\r\n; BITS ARE STORED. STRINGS HAVE STRCMP,THE POINTER AT THE STRING DESCRIPTOR,\r\n; DOCMP AND THE RELATIONAL BITS.\r\n;\r\nFINREL:\tMOV\tAL,CH\t\t;[A]=OLD PRECEDENCE\r\n\tCMP\tAL,LOW 100\t;RELATIONALS HAVE PRECEDENCE 100\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;APPLY EARLIER OPERATOR IF IT HAS\r\n\t\t\t\t;HIGHER PRECEDENCE\r\n\tPUSH\tCX\t\t;SAVE THE OLD PRECEDENCE\r\n\tPUSH\tDX\t\t;SAVE [D]=RELATIONAL BITS\r\n\tMOV\tDX,OFFSET 256*100+OPCNT\t;[D]=PRECEDENCE=100\r\n\t\t\t\t;[E]=DISPATCH OFFSET FOR\r\n\t\t\t\t;COMPARES IN APPLOP=4\r\n\t\t\t\t;IN CASE THIS IS A NUMERIC COMPARE\r\n\tMOV\tBX,OFFSET DOCMP\t;ROUTINE TO TAKE COMPARE ROUTINE RESULT\r\n\t\t\t\t;AND RELATIONAL BITS AND RETURN THE ANSWER\r\n\tPUSH\tBX\t\t;DOES A JMP TO RETAOP WHEN DONE\r\n\tCALL\tGETYPR\t\t;SEE IF WE HAVE A NUMERIC COMPARE\r\n\tJZ\tSHORT ??L005\r\n\tJMP\tNUMREL\t\t;YES, BUILD AN APPLOP ENTRY\r\n??L005:\r\n\tMOV\tBX,FACLO\t;GET THE POINTER AT THE STRING DESCRIPTOR\r\n\tPUSH\tBX\t\t;SAVE IT FOR STRCMP\r\n\tMOV\tCX,OFFSET STRCMP\t;STRING COMPARE ROUTINE\r\n\tJMP\tSHORT FINTMP\t;PUSH THE ADDRESS, REGET THE TEXT POINTER\r\n\t\t\t\t;SAVE THE PRECEDENCE AND SCAN\r\n\t\t\t\t;MORE OF THE FORMULA\r\n;\r\n; APPLOP IS RETURNED TO WHEN IT IS TIME TO APPLY AN ARITHMETIC\r\n; OR NUMERIC COMPARISON OPERATION.\r\n; THE STACK HAS A DOUBLE BYTE ENTRY WITH THE OPERATOR\r\n; NUMBER AND THE VALTYP OF THE VALUE ON THE STACK.\r\n; APPLOP DECIDES WHAT VALUE LEVEL THE OPERATION\r\n; WILL OCCUR AT, AND CONVERTS THE ARGUMENTS. APPLOP\r\n; USES DIFFERENT CALLING CONVENTIONS FOR EACH VALUE TYPE.\r\n; INTEGERS: LEFT IN [D,E] RIGHT IN [H,L]\r\n; SINGLES:  LEFT IN [B,C,D,E] RIGHT IN THE FAC\r\n; DOUBLES:  LEFT IN FAC   RIGHT IN ARG\r\n;\r\nAPPLOP:\tPOP\tCX\t\t;[B]=STACK OPERAND VALUE TYPE\r\n\t\t\t\t;[C]=OPERATOR OFFSET\r\n\tMOV\tAL,CL\t\t;SAVE IN MEMORY SINCE THE STACK WILL BE BUSY\r\n\tMOV\tBYTE PTR OPRTYP,AL\t;A RAM LOCATION\r\n\tMOV\tAL,BYTE PTR VALTYP\t;GET VALTYP OF FAC\r\n\tCMP\tAL,CH\t\t;ARE VALTYPES THE SAME?\r\n\tJNZ\tSHORT VALNSM\t;NO\r\n\tCMP\tAL,LOW 2\t;INTEGER?\r\n\tJZ\tSHORT INTDPC\t;YES, DISPATCH!!\r\n\tCMP\tAL,LOW 4\t;SINGLE?\r\n\tJNZ\tSHORT ??L006\r\n\tJMP\tSNGDPC\t\t;YES, DISPATCH!!\r\n??L006:\r\n\tJAE\tSHORT DBLDPC\t;MUST BE DOUBLE, DISPATCH!!\r\nVALNSM:\tMOV\tDH,AL\t\t;SAVE IN [D]\r\n\tMOV\tAL,CH\t\t;CHECK FOR DOUBLE\r\n\tCMP\tAL,LOW 8\t;PRECISION ENTRY ON THE STACK\r\n\tJZ\tSHORT STKDBL\t;FORCE FAC TO DOUBLE\r\n\tMOV\tAL,DH\t\t;GET VALTYPE OF FAC\r\n\tCMP\tAL,LOW 8\t;AND IF SO, CONVERT THE STACK OPERAND\r\n\tJZ\tSHORT FACDBL\t;TO DOUBLE PRECISION\r\n\tMOV\tAL,CH\t\t;SEE IF THE STACK ENTRY IS SINGLE\r\n\tCMP\tAL,LOW 4\t;PRECISION AND IF SO, CONVERT\r\n\tJZ\tSHORT STKSNG\t;THE FAC TO SINGLE PRECISION\r\n\tMOV\tAL,DH\t\t;SEE IF THE FAC IS SINGLE PRECISION\r\n\tCMP\tAL,LOW 3\t;AND IF SO CONVERT THE STACK TO SINGLE\r\n\tJNZ\tSHORT ??L007\r\n\tJMP\tTMERR\t\t;BLOW UP ON RIGHT HAND STRING OPERAND\r\n??L007:\r\n\tJAE\tSHORT FACSNG\t;PRECISION\r\n\t\t\t\t;NOTE: THE STACK MUST BE INTEGER AT THIS POINT\r\nINTDPC:\tMOV\tBX,OFFSET INTDSP\t;INTEGER INTEGER CASE\r\n\tMOV\tCH,LOW 0\t;SPECIAL DISPATCH FOR SPEED\r\n\tADD\tBX,CX\t\t;[H,L] POINTS TO THE ADDRESS TO GO TO \r\n\tADD\tBX,CX\r\n\tINS86\t56\t\t;FETCH FROM CODE SEGMENT\r\n\tMOV\tCL,BYTE PTR [BX]\t;[B,C]=ROUTINE ADDRESS\r\n\tINC\tBX\r\n\tINS86\t56\t\t;FETCH FROM CODE SEGMENT\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tPOP\tDX\t\t;[D,E]=LEFT HAND OPERAND\r\n\tMOV\tBX,FACLO\t;[H,L]=RIGHT HAND OPERAND\r\n\tPUSH\tCX\t\t;DISPATCH\r\n\tRET\t\r\n;\r\n; THE STACK OPERAND IS DOUBLE PRECISION, SO\r\n; THE FAC MUST BE FORCED TO DOUBLE PRECISION, MOVED INTO ARG\r\n; AND THE STACK VALUE POPED INTO THE FAC\r\n;\r\nSTKDBL:\tCALL\tFRCDBL\t\t;MAKE THE FAC DOUBLE PRECISION\r\nDBLDPC:\tCALL\tVMOVAF\t\t;MOVE THE FAC INTO ARG\r\n\tPOP\tBX\t\t;POP OFF THE STACK OPERAND INTO THE FAC\r\n\tMOV\tDFACLO+2,BX\r\n\tPOP\tBX\r\n\tMOV\tDFACLO,BX\t;STORE LOW BYTES AWAY\r\nSNGDBL:\tPOPR\t\t\t;POP OFF A FOUR BYTE VALUE\r\n\tCALL\tMOVFR\t\t;INTO THE FAC\r\nSETDBL:\tCALL\tFRCDBL\t\t;MAKE SURE THE LEFT OPERAND IS\r\n\t\t\t\t;DOUBLE PRECISION\r\n\tMOV\tBX,OFFSET DBLDSP\t;DISPATCH TO A DOUBLE PRECISION ROUTINE\r\nDODSP:\tMOV\tAL,BYTE PTR OPRTYP\t;RECALL WHICH OPERAND IT WAS\r\n\tROL\tAL,1\t\t;CREATE A DISPATCH OFFSET, SINCE\r\n\t\t\t\t;TABLE ADDRESSES ARE TWO BYTES\r\n\tADD\tAL,BL\t\t;ADD LOW BYTE OF ADDRESS\r\n\tMOV\tBL,AL\t\t;SAVE BACK\r\n\tADC\tAL,BH\t\t;ADD HIGH BYTE\r\n\tSUB\tAL,BL\t\t;SUBTRACT LOW\r\n\tMOV\tBH,AL\t\t;RESULT BACK\r\n\tINS86\t56\t\t;FETCH FROM CODE SEGMENT\r\n\tMOV\tBX,[BX]\t\t;FETCH THE ADDRESS\r\n\tJMP\tBX\t\t;AND PERFORM THE OPERATION, RETURNING\r\n\t\t\t\t;TO RETAOP, EXCEPT FOR COMPARES WHICH\r\n\t\t\t\t;RETURN TO DOCMP\r\n;\r\n; THE FAC IS DOUBLE PRECISION AND THE STACK IS EITHER\r\n; INTEGER OR SINGLE PRECISION AND MUST BE CONVERTED\r\n; \r\nFACDBL:\tMOV\tAL,CH\t\t;GET THE VALUE TYPE INTO [A]\r\n\tPUSH\tAX\t\t;SAVE THE STACK VALUE TYPE\r\n\tCALL\tVMOVAF\t\t;MOVE THE FAC INTO ARG\r\n\tPOP\tAX\t\t;POP THE STACK VALUE TYPE INTO [A]\r\n\tMOV\tBYTE PTR VALTYP,AL\t;PUT IT IN VALTYP FOR THE FORCE\r\n\t\t\t\t;ROUTINE\r\n\tCMP\tAL,LOW 4\t;SEE IF ITS SINGLE, SO WE KNOW\r\n\t\t\t\t;HOW TO POP THE VALUE OFF\r\n\tJZ\tSHORT SNGDBL\t;IT'S SINGLE PRECISION\r\n\t\t\t\t;SO DO A POPR / CALL MOVFR\r\n\tPOP\tBX\t\t;POP OFF THE INTEGER VALUE\r\n\tMOV\tFACLO,BX\t;SAVE IT FOR CONVERSION\r\n\tJMP\tSHORT SETDBL\t;SET IT UP\r\n;\r\n; THIS IS THE CASE WHERE THE STACK IS SINGLE PRECISION\r\n; AND THE FAC IS EITHER SINGLE PRECISION OR INTEGER\r\n;\r\nSTKSNG:\tCALL\tFRCSNG\t\t;CONVERT THE FAC IF NECESSARY\r\nSNGDPC:\tPOPR\t\t\t;PUT THE LEFT HAND OPERAND IN THE REGISTERS\r\nSNGDO:\tMOV\tBX,OFFSET SNGDSP\t;SETUP THE DISPATCH ADDRESS\r\n\t\t\t\t;FOR THE SINGLE PRECISION OPERATOR ROUTINES\r\n\tJMP\tSHORT DODSP\t;DISPATCH\r\n;\r\n; THIS IS THE CASE WHERE THE FAC IS SINGLE PRECISION AND THE STACK\r\n; IS AN INTEGER. \r\n;\r\nFACSNG:\tPOP\tBX\t\t;POP OFF THE INTEGER ON THE STACK\r\n\tCALL\tPUSHF\t\t;SAVE THE FAC ON THE STACK\r\n\tCALL\tCONSIH\t\t;CONVERT [H,L] TO A SINGLE PRECISION\r\n\t\t\t\t;NUMBER IN THE FAC\r\n\tCALL\tMOVRF\t\t;PUT THE LEFT HAND OPERAND IN THE REGISTERS\r\n\tPOP\tBX\t\t;RESTORE THE FAC\r\n\tMOV\tFAC-1,BX\t;FROM THE STACK\r\n\tPOP\tBX\r\n\tMOV\tFACLO,BX\r\n\tJMP\tSHORT SNGDO\t;PERFORM THE OPERATION\r\n;\r\n; HERE TO DO INTEGER DIVISION. SINCE WE WANT 1/3 TO BE\r\n; .333333 AND NOT ZERO WE HAVE TO FORCE BOTH ARGUMENTS\r\n; TO BE SINGLE-PRECISION FLOATING POINT NUMBERS\r\n; AND USE FDIV\r\n;\r\nPUBLIC\tINTDIV\r\nINTDIV:\tPUSH\tBX\t\t;SAVE THE RIGHT HAND ARGUMENT\r\n\tXCHG\tBX,DX\t\t;[H,L]=LEFT HAND ARGUMENT\r\n\tCALL\tCONSIH\t\t;CONVERT [H,L] TO A SINGLE-PRECISION\r\n\t\t\t\t;NUMBER IN THE FAC\r\n\tPOP\tBX\t\t;GET BACK THE RIGHT HAND ARGUMENT\r\n\tCALL\tPUSHF\t\t;PUSH THE CONVERTED LEFT HAND ARGUMENT\r\n\t\t\t\t;ONTO THE STACK\r\n\tCALL\tCONSIH\t\t;CONVERT THE RIGHT HAND ARGUMENT TO A\r\n\t\t\t\t;SINGLE PRECISION NUMBER IN THE FAC\r\n\tJMP\tFDIVT\r\n\t\t\t\t;REGISTERS THE LEFT HAND ARGUMENT\r\n\r\n\tPAGE\t\r\n\r\n\tSUBTTL EVAL - EVALUATE VARIABLE, CONSTANT, FUNCTION CALL\r\nPUBLIC\tEVAL\r\nEVAL:\r\n\tCALL\tCHRGTR\r\n\tJNZ\tSHORT ??L008\r\n\tJMP\tMOERR\t\t;TEST FOR MISSING OPERAND - IF NONE GIVE ERROR\r\n??L008:\r\n\tJAE\tSHORT ??L009\r\n\tJMP\tFIN\t\t;IF NUMERIC, INTERPRET CONSTANT\r\n??L009:\r\n\tCALL\tISLET2\t\t;VARIABLE NAME?\r\n\tJNAE\tSHORT ??L010\r\n\tJMP\tISVAR\t\t;AN ALPHABETIC CHARACTER MEANS YES\r\n??L010:\r\n\tCMP\tAL,LOW OFFSET DBLCON+1\t;IS IT AN EMBEDED CONSTANT\r\n\tJAE\tSHORT ??L011\r\n\tJMP\tCONFAC\t\t;RESCAN THE TOKEN & RESTORE OLD TEXT PTR\r\n??L011:\r\n\tEXTRN\tEVALX:NEAR\r\n\tCALL\tEVALX\t\t;Handle extended functions.\r\n\tINC\tAL\t\t;IS IT A FUNCTION CALL (PRECEDED BY 377)\r\n\tJNZ\tSHORT ??L012\r\n\tJMP\tISFUN\t\t;YES, DO IT\r\n??L012:\r\n\tDEC\tAL\t\t;FIX A BACK\r\n\tCMP\tAL,LOW OFFSET PLUSTK\t;IGNORE \"+\"\r\n\tJZ\tSHORT EVAL\r\n\tCMP\tAL,LOW OFFSET MINUTK\t;NEGATION?\r\n\tJNZ\tSHORT ??L013\r\n\tJMP\tDOMIN\r\n??L013:\r\n\tCMP\tAL,LOW 34\t;STRING CONSTANT?\r\n\tJNZ\tSHORT ??L014\r\n\tJMP\tSTRLTI\t\t;IF SO BUILD A DESCRIPTOR IN A TEMPORARY\r\n??L014:\r\n\t\t\t\t;DESCRIPTOR LOCATION AND PUT A POINTER TO THE\r\n\t\t\t\t;DESCRIPTOR IN FACLO.\r\n\tCMP\tAL,LOW OFFSET NOTTK\t;CHECK FOR \"NOT\" OPERATOR\r\n\tJNZ\tSHORT ??L015\r\n\tJMP\tNOTER\r\n??L015:\r\n\tCMP\tAL,LOW \"&\"\t;OCTAL CONSTANT?\r\n\tJNZ\tSHORT ??L016\r\n\tJMP\tOCTCNS\r\n??L016:\r\n\tCMP\tAL,LOW OFFSET ERCTK\r\n\tJNZ\tSHORT NTERC\t;NO, TRY OTHER POSSIBILITIES\r\n\tCALL\tCHRGTR\t\t;GRAB FOLLOWING CHAR\r\n\tMOV\tAL,BYTE PTR ERRFLG\t;GET THE ERROR CODE.\r\nNTDERC:\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\tSNGFLT\t\t;RETURN THE VALUE\r\n\tPOP\tBX\t\t;RESTORE TEXT POINTER\r\n\tRET\t\t\t;ALL DONE.\r\n\r\nNTERC:\tCMP\tAL,LOW OFFSET ERLTK\t;ERROR LINE NUMBER VARIABLE.\r\n\tJNZ\tSHORT NTERL\t;NO, TRY MORE THINGS.\r\n\tCALL\tCHRGTR\t\t;GET FOLLOWING CHARACTER\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tMOV\tBX,ERRLIN\t;GET THE OFFENDING LINE #\r\n\tCALL\tINEG2\t\t;FLOAT 2 BYTE UNSINGED INT\r\n\tPOP\tBX\t\t;RESTORE TEXT POINTER\r\n\tRET\t\t\t;RETURN\r\nNTERL:\r\n\tCMP\tAL,LOW OFFSET $VARPTR\t;VARPTR CALL?\r\n\tJNZ\tSHORT NTVARP\t;NO\r\n\tCALL\tCHRGTR\t\t;EAT CHAR AFTER\r\n\tEXTRN\tVARPT2:NEAR\r\n\tCMP\tAL,LOW \"$\"\r\n\tJNZ\tSHORT ??L017\r\n\tJMP\tVARPT2\t\t;branch if VARPTR$(x)\r\n??L017:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"(\"\t;EAT LEFT PAREN\r\n\tEXTRN\tGETPTR:NEAR\r\n\tCMP\tAL,LOW \"#\"\t;WANT POINTER TO FILE?\r\n\tJNZ\tSHORT NVRFIL\t;NO, MUST BE VARIABLE\r\n\tCALL\tGTBYTC\t\t;READ FILE #\r\n\tPUSH\tBX\t\t;SAVE TEXT PTR\r\n\tCALL\tGETPTR\t\t;GET PTR TO FILE\r\n\tPOP\tBX\t\t;RESTORE TEXT PTR\r\n\tJMP\tVARRET\r\nNVRFIL:\r\n\tEXTRN\tPTRGTN:NEAR\r\n\tCALL\tPTRGTN\t\t;GET ADDRESS OF VARIABLE\r\nVARRET:\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\t;EAT RIGHT PAREN\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tXCHG\tBX,DX\t\t;GET VALUE TO RETURN IN [H,L]\r\n\tOR\tBX,BX\t\t;MAKE SURE NOT UNDEFINED VAR\r\n\t\t\t\t;SET CC'S. ZERO IF UNDEF\r\n\tJNZ\tSHORT ??L018\r\n\tJMP\tFCERR\t\t;ALL OVER IF UNDEF (DONT WANT\r\n??L018:\r\n\t\t\t\t;USER POKING INTO ZERO IF HE'S\r\n\t\t\t\t;TOO LAZY TO CHECK\r\n\tCALL\tMAKINT\t\t;MAKE IT AN INT\r\n\tPOP\tBX\t\t;RESTORE TEXT POINTER\r\n\tRET\t\r\nNTVARP:\r\n\tCMP\tAL,LOW OFFSET USRTK\t;USER ASSEMBLY LANGUAGE ROUTINE??\r\n\tJNZ\tSHORT ??L019\r\n\tJMP\tUSRFN\t\t;GO HANDLE IT\r\n??L019:\r\n\tCMP\tAL,LOW OFFSET INSRTK\t;IS IT THE INSTR FUNCTION??\r\n\tJNZ\tSHORT ??L020\r\n\tJMP\tINSTR\t\t;DISPATCH\r\n??L020:\r\n\tCMP\tAL,LOW OFFSET $SCREEN\r\n\tJNZ\tSHORT ??L021\r\nEXTRN\tSCRENF:NEAR\r\n\tJMP\tSCRENF\r\n??L021:\r\n\tCMP\tAL,LOW OFFSET $POINT\r\n\tJNZ\tSHORT ??L022\r\nEXTRN\tPOINT:NEAR\r\n\tJMP\tPOINT\r\n??L022:\r\n\tEXTRN\tINKEY:NEAR\r\n\tCMP\tAL,LOW OFFSET $INKEY$\t;INKEY$ FUNCTION?\r\n\tJNZ\tSHORT ??L023\r\n\tJMP\tINKEY\r\n??L023:\r\n\tCMP\tAL,LOW OFFSET $STRING$\t;STRING FUNCTION?\r\n\tJNZ\tSHORT ??L024\r\n\tJMP\tSTRNG$\t\t;YES, GO DO IT\r\n??L024:\r\n\tEXTRN\tFIXINP:NEAR\r\n\tCMP\tAL,LOW OFFSET $INPUT\t;FIXED LENGTH INPUT?\r\n\tJNZ\tSHORT ??L025\r\n\tJMP\tFIXINP\t\t;YES\r\n??L025:\r\n\tCMP\tAL,LOW OFFSET CLINTK\t;WANT TO KNOW CURRENT LINE ON SCREEN?\r\n\tJNZ\tSHORT ??L026\r\nEXTRN\tGETLIN:NEAR\r\n\tJMP\tGETLIN\t\t;YES\r\n??L026:\r\n\tCMP\tAL,LOW OFFSET FNTK\t;USER-DEFINED FUNCTION?\r\n\tJNZ\tSHORT ??L027\r\n\tJMP\tFNDOER\r\n??L027:\r\n;\r\n; ONLY POSSIBILITY LEFT IS A FORMULA IN PARENTHESES\r\n;\r\nPUBLIC\tPARCHK\r\nPARCHK:\tCALL\tFRMPRN\t\t;RECURSIVELY EVALUATE THE FORMULA\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\r\n\tRET\t\r\nDOMIN:\r\n\tMOV\tDH,LOW 125\t;A PRECEDENCE BELOW ^\r\n\t\t\t\t;BUT ABOVE ALL ELSE\r\n\tCALL\tLPOPER\t\t;SO ^ GREATER THAN UNARY MINUS\r\n\tMOV\tBX,TEMP2\t;GET TEXT POINTER\r\n\tPUSH\tBX\r\n\tCALL\tVNEG\r\nLABBCK:\t\t\t\t;FUNCTIONS THAT DON'T RETURN\r\n\t\t\t\t;STRING VALUES COME BACK HERE\r\n\tPOP\tBX\r\n\tRET\t\r\nPUBLIC\tISVAR\r\nISVAR:\tCALL\tPTRGET\t\t;GET A POINTER TO THE\r\n\t\t\t\t;VARIABLE IN [D,E]\r\nPUBLIC\tRETVAR\r\nRETVAR:\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tXCHG\tBX,DX\t\t;PUT THE POINTER TO THE VARIABLE VALUE\r\n\t\t\t\t;INTO [H,L]. IN THE CASE OF A STRING\r\n\t\t\t\t;THIS IS A POINTER TO A DESCRIPTOR AND NOT\r\n\t\t\t\t;AN ACTUAL VALUE\r\n\tMOV\tFACLO,BX\t;IN CASE IT'S STRING STORE THE POINTER\r\n\t\t\t\t;TO THE DESCRIPTOR IN FACLO.\r\n\tCALL\tGETYPR\t\t;FOR STRINGS WE JUST LEAVE\r\n\tJZ\tSHORT ??L028\r\n\tCALL\tVMOVFM\t\t;A POINTER IN THE FAC\r\n??L028:\r\n\t\t\t\t;THE FAC USING [H,L] AS THE POINTER.\r\n\tPOP\tBX\t\t;RESTORE THE TEXT POINTER\r\n\tRET\t\r\nPUBLIC\tMAKUPL\r\nMAKUPL:\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR FROM MEMORY\r\nPUBLIC\tMAKUPS\r\nMAKUPS:\tCMP\tAL,LOW OFFSET \"A\"+40O\t;IS IT LOWER CASE RANGE\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;LESS\r\n\tCMP\tAL,LOW OFFSET \"Z\"+41O\t;GREATER\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;TEST\r\n\tAND\tAL,LOW 137O\t;MAKE UPPER CASE\r\n\tRET\t\t\t;DONE\r\nPUBLIC\tCNSGET\r\nCNSGET:\r\n\tCMP\tAL,LOW \"&\"\t;OCTAL PERHAPS?\r\n\tJZ\tSHORT ??L029\r\n\tJMP\tLINGET\r\n??L029:\r\nPUBLIC\t$OHCNS\r\n$OHCNS:\r\nPUBLIC\tOCTCNS\r\nOCTCNS:\tMOV\tDX,0\t\t;INITIALIZE TO ZERO AND IGNORE OVERFLOW\r\n\tCALL\tCHRGTR\t\t;GET FIRST CHAR\r\n\tCALL\tMAKUPS\t\t;MAKE UPPER IF NESC.\r\n\tCMP\tAL,LOW \"O\"\t;OCTAL?\r\n\tJZ\tSHORT LOPOCT\t;IF SO, DO IT\r\n\tCMP\tAL,LOW \"H\"\t;HEX?\r\n\tJNZ\tSHORT LOPOC2\t;THEN DO IT\r\n\tMOV\tCH,LOW 5\t;INIT DIGIT COUNT\r\nLOPHEX:\tINC\tBX\t\t;BUMP POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR\r\n\tCALL\tMAKUPS\t\t;MAKE UPPER CASE\r\n\tCALL\tISLET2\t\t;FETCH CHAR, SEE IF ALPHA\r\n\tXCHG\tBX,DX\t\t;SAVE [H,L]\r\n\tJAE\tSHORT ALPTST\t;YES, MAKE SURE LEGAL HEC\r\n\tCMP\tAL,LOW OFFSET \"9\"+1\t;IS IT BIGGER THAN LARGEST DIGIT?\r\n\tJAE\tSHORT OCTFIN\t;YES, BE FORGIVING & RETURN\r\n\tSUB\tAL,LOW \"0\"\t;CONVERT DIGIT, MAKE BINARY\r\n\tJB\tSHORT OCTFIN\t;BE FORGIVING IF NOT HEX DIGIT\r\n\tJMP\tSHORT NXTHEX\t;ADD IN OFFSET\r\nALPTST:\tCMP\tAL,LOW OFFSET \"F\"+1\t;IS IT LEGAL HEX?\r\n\tJAE\tSHORT HEXFIN\t;YES, TERMINATE\r\n\tSUB\tAL,LOW OFFSET \"A\"-10\t;MAKE BINARY VALUE\r\nNXTHEX:\tADD\tBX,BX\t\t;SHIFT RIGHT FOUR BITS\r\n\tADD\tBX,BX\r\n\tADD\tBX,BX\r\n\tADD\tBX,BX\r\n\tOR\tAL,BL\t\t;OR ON NEW DIGIT\r\n\tMOV\tBL,AL\t\t;SAVE BACK\r\n\tXCHG\tBX,DX\t\t;GET TEXT POINTER BACK IN [H,L]\r\n\tDEC\tCH\r\n\tJNZ\tSHORT LOPHEX\t;KEEP EATING IF NOT TOO MANY DIGITS\r\n;IF NOT INPUT STATEMENT GOTO OVFLW ERROR FROM HERE, ELSE PASS BACK ERROR\r\nCKOVER:\tMOV\tAL,BYTE PTR FLGSCN\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT ??L030\r\n\tJMP\tOVERR\t\t;IF NOT INPUT STATEMENT, THIS IS ERROR\r\n??L030:\r\n\tPUSH\tBX\r\n\tMOV\tBX,OFFSET $OVMSG\r\n\tCALL\t$STPRN\t\t;PRINT OVERFLOW MESSAGE\r\n\tCALL\tCRDO\r\n\tPOP\tBX\r\nCONER2:\tMOV\tAL,BYTE PTR FLGOVC\r\n\tINC\tAL\r\n\tMOV\tBYTE PTR FLGOVC,AL\t;TELL INPUT CODE THAT ERROR OCCURED\r\n\tRET\t\r\nCONERR:\tMOV\tAL,BYTE PTR FLGSCN\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT ??L031\r\n\tJMP\tCONER2\t\t;IF INPUT CODE ERROR, RETURN ERROR CODE\r\n??L031:\r\n\tJMP\tSNERR\t\t;ELSE GOTO ERROR FROM HERE\r\nLOPOC2:\tDEC\tBX\t\t;REGET LAST CHARACTER\r\nLOPOCT:\tCALL\tCHRGTR\t\t;READ A DIGIT\r\n\tXCHG\tBX,DX\t\t;RESULT INTO [H,L]\r\n\tJAE\tSHORT OCTFIN\t;OUT OF DIGITS MEANS DONE\r\n\tCMP\tAL,LOW \"8\"\t;IS THIS AN OCTAL DIGIT\r\n\tJNAE\tSHORT ??L032\r\n\tJMP\tCONERR\t\t;NO, TOO BAD YOU WILL LOSE\r\n??L032:\r\n\tMOV\tCX,OFFSET CKOVER\t;WHERE TO GO ON OVERFLOW ERROR\r\n\tPUSH\tCX\t\t;SAVE ADDR ON STACK\r\n\tADD\tBX,BX\t\t;MULTIPLY BY EIGHT\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;OVERFLOW ERROR\r\n\tADD\tBX,BX\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;OVERFLOW ERROR\r\n\tADD\tBX,BX\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;OVERFLOW ERROR\r\n\tPOP\tCX\t\t;GET RID OF OVERR ADDR\r\n\tMOV\tCH,LOW 0\t;SETUP TO ADD [B,C]\r\n\tSUB\tAL,LOW \"0\"\r\n\tMOV\tCL,AL\r\n\tADD\tBX,CX\t\t;ADD IN THE DIGIT\r\n\tXCHG\tBX,DX\t\t;PUT TEXT POINTER BACK IN [H,L]\r\n\tJMP\tSHORT LOPOCT\t;SCAN MORE DIGITS\r\nHEXFIN:\r\nOCTFIN:\r\n\r\nPUBLIC\tHOCFIN\r\nHOCFIN:\r\n\tCALL\tMAKINT\t\t;SAVE AS AN INTEGER\r\n\tXCHG\tBX,DX\t\t;[H,L]-TEXT POINTER\r\n\tRET\t\r\nISFUN:\r\n\tINC\tBX\t\t;BUMP SOURCE TEXT POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE ACTUAL TOKEN FOR FN\r\n\tSUB\tAL,LOW OFFSET ONEFUN\t;MAKE INTO OFFSET\r\n\tEXTRN\tRNDMON:NEAR\r\n\tEXTRN\t$RNDFN:NEAR\r\n\tCMP\tAL,LOW OFFSET $RNDFN\t;IS IT RND?\r\n\tJNZ\tSHORT NTMRND\t;IF NOT NO NEED TO CHECK MONADIC\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\tCHRGTR\t\t;SEE IF NEXT CHAR IS \"(\"\r\n\tCMP\tAL,LOW \"(\"\r\n\tPOP\tBX\t\t;GET BACK THE OLD TEXT POINTER\r\n\tJZ\tSHORT ??L033\r\n\tJMP\tRNDMON\t\t;HANDLE MONADIC CASE\r\n??L033:\r\n\tMOV\tAL,LOW OFFSET $RNDFN\r\nNTMRND:\r\n\tMOV\tCH,LOW 0\r\n\tROL\tAL,1\t\t;MULTIPLY BY 2\r\n\tMOV\tCL,AL\r\n\tPUSH\tCX\t\t;SAVE THE FUNCTION # ON THE STACK\r\n\tCALL\tCHRGTR\r\n\tMOV\tAL,CL\t\t;LOOK AT FUNCTION #\r\n\tEXTRN\tNUMGFN:NEAR\r\n\tCMP\tAL,LOW OFFSET NUMGFN\t;IS IT PAST LASNUM?\r\n\tJAE\tSHORT OKNORM\t;NO, MUST BE A NORMAL FUNCTION\r\n;\r\n; MOST FUNCTIONS TAKE A SINGLE ARGUMENT.\r\n; THE RETURN ADDRESS OF THESE FUNCTIONS IS A SMALL ROUTINE\r\n; THAT CHECKS TO MAKE SURE VALTYP IS 0 (NUMERIC) AND POPS OFF\r\n; THE TEXT POINTER. SO NORMAL FUNCTIONS THAT RETURN STRING RESULTS (I.E. CHR$)\r\n; MUST POP OFF THE RETURN ADDRESS OF LABBCK, AND POP OFF THE\r\n; TEXT POINTER AND THEN RETURN TO FRMEVL.\r\n;\r\n; THE SO CALLED \"FUNNY\" FUNCTIONS CAN TAKE MORE THAN ONE ARGUMENT.\r\n; THE FIRST OF WHICH MUST BE STRING AND THE SECOND OF WHICH\r\n; MUST BE A NUMBER BETWEEN 0 AND 256. THE TEXT POINTER IS\r\n; PASSED TO THESE FUNCTIONS SO ADDITIONAL ARGUMENTS\r\n; CAN BE READ. THE TEXT POINTER IS PASSED IN [D,E].\r\n; THE CLOSE PARENTHESIS MUST BE CHECKED AND RETURN IS DIRECTLY\r\n; TO FRMEVL WITH [H,L] SETUP AS THE TEXT POINTER POINTING BEYOND THE \")\".\r\n; THE POINTER TO THE DESCRIPTOR OF THE STRING ARGUMENT\r\n; IS STORED ON THE STACK UNDERNEATH THE VALUE OF THE INTEGER\r\n; ARGUMENT (2 BYTES)\r\n;\r\n; FIRST ARGUMENT ALWAYS STRING -- SECOND INTEGER\r\n;\r\n\tCALL\tFRMPRN\t\t;EAT OPEN PAREN AND FIRST ARG\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;TWO ARGS SO COMMA MUST DELIMIT\r\n\tCALL\tCHKSTR\t\t;MAKE SURE THE FIRST ONE WAS STRING\r\n\tXCHG\tBX,DX\t\t;[D,E]=TXTPTR\r\n\tMOV\tBX,FACLO\t;GET PTR AT STRING DESCRIPTOR\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;GET FUNCTION #\r\n\t\t\t\t;SAVE THE STRING PTR\r\n\tPUSH\tBX\t\t;PUT THE FUNCTION # ON\r\n\tXCHG\tBX,DX\t\t;[H,L]=TXTPTR\r\n\tCALL\tGETBYT\t\t;[E]=VALUE OF FORMULA\r\n\tXCHG\tBX,DX\t\t;TEXT POINTER INTO [D,E]\r\n\t\t\t\t;[H,L]=INT VALUE OF SECOND ARGUMENT\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE INT VALUE OF SECOND ARG\r\n\t\t\t\t;[H,L]=FUNCTION NUMBER\r\n\tJMP\tSHORT FINGO\t;DISPATCH TO FUNCTION\r\nOKNORM:\r\n\tCALL\tPARCHK\t\t;CHECK OUT THE ARGUMENT\r\n\t\t\t\t;AND MAKE SURE ITS FOLLOWED BY \")\"\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;[H,L]=FUNCTION # AND SAVE TEXT POINTER\r\n;\r\n; CHECK IF SPECIAL COERCION MUST BE DONE FOR ONE OF THE TRANSCENDENTAL\r\n; FUNCTIONS (RND, SQR, COS, SIN, TAN, ATN, LOG, AND EXP)\r\n; THESE FUNCTIONS DO NOT LOOK AT VALTYP, BUT RATHER ASSUME THE\r\n; ARGUMENT PASSED IN THE FAC IS SINGLE PRECISION, SO FRCSNG\r\n; MUST BE CALLED BEFORE DISPATCHING TO THEM.\r\n;\r\n\tMOV\tAL,BL\t\t;[A]=FUNCTION NUMBER\r\n\tEXTRN\tBOTCON:NEAR,TOPCON:NEAR\r\n\tCMP\tAL,LOW OFFSET BOTCON\t;LESS THAN SQUARE ROOT?\r\n\tJB\tSHORT NOTFRF\t;DON'T FORCE THE ARGUMENT\r\n\tCMP\tAL,LOW OFFSET TOPCON\t;BIGGER THAN ARC-TANGENT?\r\n\tPUSH\tBX\t\t;SAVE THE FUNCTION NUMBER\r\n\tJNB\tSHORT ??L034\r\n\tCALL\tFRCSNG\t\t;IF NOT, FORCE FAC TO SINGLE-PRECISION\r\n??L034:\r\n\tPOP\tBX\t\t;RESTORE THE FUNCTION NUMBER\r\nNOTFRF:\r\n\tMOV\tDX,OFFSET LABBCK\t;RETURN ADDRESS\r\n\tPUSH\tDX\t\t;MAKE THEM REALLY COME BACK\r\n\tMOV\tAL,LOW 1\t;FUNCTION SHOULD ONLY PRINT OVERFLOW ONCE\r\n\tMOV\tBYTE PTR FLGOVC,AL\r\nFINGO:\r\n\tMOV\tCX,OFFSET FUNDSP\t;FUNCTION DISPATCH TABLE\r\nDISPAT:\tADD\tBX,CX\t\t;ADD ON THE OFFSET\r\n\r\n\tINS86\t56\t\t;FETCH FROM CODE SEGMENT\r\n\tINS86\t377,047\t\t;JMPI   0(.BX)\r\n; THE FOLOWING ROUTINE IS CALLED FROM FIN IN F4\r\n; TO SCAN LEADING SIGNS FOR NUMBERS. IT WAS MOVED\r\n; TO F3 TO ELIMINATE BYTE EXTERNALS\r\nPUBLIC\tMINPLS\r\nMINPLS:\r\n\tDEC\tDH\t\t;SET SIGN OF EXPONENT FLAG\r\n\tCMP\tAL,LOW OFFSET MINUTK\t;NEGATIVE EXPONENT?\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tCMP\tAL,LOW \"-\"\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tINC\tDH\t\t;NO, RESET FLAG\r\n\tCMP\tAL,LOW \"+\"\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tCMP\tAL,LOW OFFSET PLUSTK\t;IGNORE \"+\"\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tLAHF\r\n\tDEC\tBX\t\t;CHECK IF LAST CHARACTER WAS A DIGIT\r\n\tSAHF\r\n\tRET\t\t\t;RETURN WITH NON-ZERO SET\r\n\tPAGE\t\r\n\r\n\tSUBTTL MORE FORMULA EVALUATION - LOGICAL, RELATIONAL OPS\r\nDOCMP:\tINC\tAL\t\t;SETUP BITS\r\n\tADC\tAL,AL\t\t;4=LESS 2=EQUAL 1=GREATER\r\n\tPOP\tCX\t\t;WHAT DID HE WANT?\r\n\tAND\tAL,CH\t\t;ANY BITS MATCH?\r\n\tADD\tAL,LOW 255\t;MAP 0 TO 0\r\n\tSBB\tAL,AL\t\t;AND ALL OTHERS TO 377\r\n\tCALL\tCONIA\t\t;CONVERT [A] TO AN INTEGER SIGNED\r\n\tJMP\tSHORT RETAPG\t;RETURN FROM OPERATOR APPLICATION\r\nNOTER:\tMOV\tDH,LOW 90\t;\"NOT\" HAS PRECEDENCE 90, SO\r\n\tCALL\tLPOPER\t\t;FORMULA EVALUATION IS ENTERED WITH A DUMMY\r\n\t\t\t\t;ENTRY OF 90 ON THE STACK\r\n\tCALL\tFRCINT\t\t;COERCE THE ARGUMENT TO INTEGER\r\n\tINS86\t367,323\t\t;NOT [H,L]\r\n\tMOV\tFACLO,BX\t;UPDATE THE FAC\r\n\tPOP\tCX\t\t;FRMEVL, AFTER SEEING THE PRECEDENCE\r\n\t\t\t\t;OF 90 THINKS IT IS APPLYING AN OPERATOR\r\n\t\t\t\t;SO IT HAS THE TEXT POINTER IN TEMP2 SO\r\n\r\nRETAPG:\tJMP\tRETAOP\t\t;RETURN TO REFETCH IT\r\nPUBLIC\tGETYPR\r\nGETYPR:\tMOV\tAL,BYTE PTR VALTYP\t;REPLACEMENT FOR \"GETYPE\" RST\r\n\tCMP\tAL,LOW 8\r\n;\r\n; CONTINUATION OF GETYPE RST\r\n;\r\nCGETYP:\tDEC\tAL\t\t;SET THE OTHER CONDITION CODES CORRECTLY\r\n\tDEC\tAL\t\t; WITHOUT AFFECTING CARRY\r\n\tDEC\tAL\r\n\tRET\t\r\n\r\n\r\n;\r\n; DANDOR APPLIES THE \"AND\" AND \"OR\" OPERATORS\r\n; AND SHOULD BE USED TO IMPLEMENT ALL LOGICAL OPERATORS.\r\n; WHENEVER AN OPERATOR IS APPLIED, ITS PRECEDENCE IS IN [B].\r\n; THIS FACT IS USED TO DISTINGUISH BETWEEN \"AND\" AND \"OR\".\r\n; THE RIGHT HAND ARGUMENT IS COERCED TO INTEGER, JUST AS\r\n; THE LEFT HAND ONE WAS WHEN IT WAS PUSHED ON THE STACK.\r\n;\r\nDANDOR:\r\n\tMOV\tAL,CH\t\t;GET THE PRECEDENCE\r\n\tPUSH\tAX\t\t;SAVE THE PRECEDENCE \"OR\"=70\r\n\tCALL\tFRCINT\t\t;COERCE RIGHT HAND ARGUMENT TO INTEGER\r\n\tPOP\tAX\t\t;GET BACK THE PRECEDENCE TO DISTINGUISH\r\n\t\t\t\t;\"AND\" AND \"OR\"\r\n\tPOP\tDX\t\t;POP OFF THE LEFT HAND ARGUMENT\r\n\tCMP\tAL,LOW 122\t;IS THE OPERATOR \"MOD\"?\r\n\tJNZ\tSHORT ??L035\r\n\tJMP\tIMOD\t\t;IF SO, USE MONTE'S SPECIAL ROUTINE\r\n??L035:\r\n\tCMP\tAL,LOW 123\t;IS THE OPERATOR \"IDIV\"?\r\n\tJNZ\tSHORT ??L036\r\n\tJMP\tIDIV\t\t;LET MONTE HANDLE IT\r\n??L036:\r\n\tMOV\tCX,OFFSET MAKINT\t;PLACE TO RETURN WHEN DONE\r\n\tPUSH\tCX\t\t;SAVE ON STACK\r\n\tCMP\tAL,LOW 70\t;SET ZERO FOR \"OR\"\r\n\tJNZ\tSHORT NOTOR\r\n\tINS86\t13,332\t\t;OR BX,BX\r\n\tRET\t\t\t;RETURN THE INTEGER [A,L]\r\nNOTOR:\r\n\tCMP\tAL,LOW 80\t;AND?\r\n\tJNZ\tSHORT NOTAND\r\n\tINS86\t43,332\t\t;AND BX,DX\r\n\tRET\t\t\t;RETURN THE INTEGER [A,L]\r\n\r\nNOTAND:\tCMP\tAL,LOW 60\t;XOR?\r\n\tJNZ\tSHORT NOTXOR\t;NO\r\n\tINS86\t63,332\t\t;XOR BX,DX\r\n\tRET\t\r\n\r\nNOTXOR:\tCMP\tAL,LOW 50\t;EQV?\r\n\tJNZ\tSHORT NOTEQV\t;NO\r\n\tINS86\t63,332\t\t;XOR BX,DX\r\n\tINS86\t367,323\t\t;NOT BX\r\n\tRET\t\r\n;FOR \"IMP\" USE A IMP B = NOT(A AND NOT(B))\r\nNOTEQV:\r\n\tINS86\t367,323\t\t;NOT BX\r\n\tINS86\t43,332\t\t;AND BX,DX\r\n\tINS86\t367,323\t\t;NOT BX\r\n\tRET\t\r\n\tPAGE\t\r\n;\r\n; THIS ROUTINE SUBTRACTS [D,E] FROM [H,L]\r\n; AND FLOATS THE RESULT LEAVING IT IN FAC.\r\n;\r\nPUBLIC\tGIVDBL\r\nGIVDBL:\tSUB\tBX,DX\t\t;[H,L]=[H,L]-[D,E]\r\n\tJMP\tINEG2\t\t;FLOAT 2 BYTE UNSIGNED INT\r\nPUBLIC\tSNGFLT\r\nSNGFLT:\tMOV\tBL,AL\t\t;MAKE [A] AN UNSIGNED INTEGER\r\n\tXOR\tAL,AL\r\nPUBLIC\tGIVINT\r\nGIVINT:\tMOV\tBH,AL\r\n\tJMP\tMAKINT\r\n\tPAGE\t\r\n\r\n\tSUBTTL USER DEFINED (USR) ASSEMBLY LANGUAGE FUNCTION CODE\r\n\r\nUSRFN:\r\n\tEXTRN\tPRODIR:NEAR\r\n\tCALL\tPRODIR\t\t;Don't allow in direct mode in\r\n\t\t\t\t; protected environment\r\n\tCALL\tSCNUSR\t\t;SCAN THE USR#\r\n\tPUSH\tDX\t\t;SAVE POINTER\r\n\tCALL\tPARCHK\t\t;EAT LEFT PAREN AND FORMULA\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE TEXT POINTER & GET INDEX INTO USRTAB\r\n\tMOV\tDX,[BX]\t\t;GET DISPATCH ADDRESS\r\n\tINS86\t203,372\t\t;CMPI DX,\r\n\tDB\t377O\t\t; 0FFFFH\r\n\tJNZ\tSHORT ??L037\r\n\tJMP\tFCERR\t\t;GIVE HIM AN ERROR IF HE CALLS A SUBROUTINE\r\n??L037:\r\n\t\t\t\t;AT FFFF, SINCE CANT INITIALIZE TABLE\r\n\t\t\t\t;TO \"FCERR\" SINCE IT MAY NOT EXIST IN\r\n\t\t\t\t;THE DESTINATION SEGMENT\r\n\tINS86\t16\t\t;PUSH CS - PUSH BASIC'S CODE SEGMENT\r\n\tMOV\tBX,OFFSET POPHRT\t;GET ADDRESS OF POP H RET\r\n\tPUSH\tBX\t\t;PUSH IT ON\r\n\tINS86\t377,66,SAVSEG\t;PUSH ON SEGMENT ADDRESS OF SUBROUTINE\r\n\tPUSH\tDX\t\t;SAVE ADDRESS OF USR ROUTINE\r\n\tMOV\tAL,BYTE PTR VALTYP\t;GET ARGUMENT TYPE IN [A]\r\n\tPUSH\tAX\t\t;SAVE VALTYP\r\n\tCMP\tAL,LOW 3\t;STRING??\r\n\tJNZ\tSHORT ??L038\r\n\tCALL\tFREFAC\t\t;FREE IT UP\r\n??L038:\r\n\tPOP\tAX\t\t;GET BACK VALTYP\r\n\tXCHG\tBX,DX\t\t;MOVE POSSIBLE DESC. POINTER TO [D,E]\r\n\tMOV\tBX,OFFSET FACLO\t;POINTER TO FAC IN [H,L]\r\n\tINS86\t313\t\t;INTER SEGMENT RETURN\r\nSCNUSR:\tCALL\tCHRGTR\t\t;GET A CHAR\r\n\tMOV\tCX,0\t\t;ASSUME USR0\r\n\tCMP\tAL,LOW OFFSET ONECON+10\t;SINGLE BYTE INT EXPECTED\r\n\tJAE\tSHORT NOARGU\t;NO, MUST BE DEFAULTING TO USR0\r\n\tCMP\tAL,LOW OFFSET ONECON\t;IS IT SMALLER THAN ONECON\r\n\tJB\tSHORT NOARGU\t;YES, ASSUME TRYING TO DEFAULT TO USR0\r\nUSERCN:\tCALL\tCHRGTR\t\t;SCAN PAST NEXT CHAR\r\n\tMOV\tAL,BYTE PTR CONLO\t;GET VALUE OF 1 BYTER\r\n\tOR\tAL,AL\t\t;MAKE SURE CARRY IS OFF\r\n\tRCL\tAL,1\t\t;MULTIPLY BY 2\r\n\tMOV\tCL,AL\t\t;SAVE OFFSET IN [C]\r\nNOARGU:\tXCHG\tBX,DX\t\t;SAVE TEXT POINTER IN [D,E]\r\n\tMOV\tBX,OFFSET USRTAB\t;GET START OF TABLE\r\n\tADD\tBX,CX\t\t;ADD ON OFFSET\r\n\tXCHG\tBX,DX\t\t;RESTORE TEXT POINTER, ADDRESS TO [D,E]\r\n\tRET\t\t\t;RETURN FROM SCAN ROUTINE\r\n\r\nDEFUSR:\tCALL\tSCNUSR\t\t;SCAN THE USR NAME\r\n\tPUSH\tDX\t\t;SAVE POINTER TO USRTAB ENTRY\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET EQULTK\t;MUST HAVE EQUAL SIGN\r\n\tCALL\tFRMQNT\t\t;GET THE ADDRESS\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;TEXT POINTER TO STACK, GET ADDRESS\r\n\tMOV\t[BX],DX\t\t;SAVE USR CALL ADDRESS\r\n\tPOP\tBX\t\t;RESTORE TEXT POINTER\r\n\tRET\t\t\t;RETURN TO NEWSTT\r\n\r\n\tPAGE\t\r\n\r\n\tSUBTTL SIMPLE-USER-DEFINED-FUNCTION CODE\r\n;\r\n; IN THE 8K VERSION (SEE LATER COMMENT FOR EXTENDED)\r\n; NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS\r\n; AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:\r\n; DEF FNA(X)=X^2+X-2\r\n; NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS\r\n;\r\n; IDEA: CREATE A FUNNY SIMPLE VARIABLE ENTRY\r\n; WHOSE FIRST CHARACTER (SECOND WORD IN MEMORY)\r\n; HAS THE 200 BIT SET.\r\n; THE VALUE WILL BE:\r\n;\r\n;       A TXTPTR TO THE FORMULA\r\n;       THE NAME OF THE PARAMETER VARIABLE\r\n;\r\n; FUNCTION NAMES CAN BE LIKE \"FNA4\"\r\n;\r\n\r\nDEF:\r\n\tCMP\tAL,LOW OFFSET USRTK\t;DEFINING THE CALL ADDRESS OF USR ROUTINE?\r\n\tJZ\tSHORT DEFUSR\t;YES, DO IT\r\n\tCMP\tAL,LOW OFFSET FNTK\t; \"FN\"?\r\n\tJZ\tSHORT DEFNC3\t;THEN GO DO FUNCTION NAME\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"S\"\t;Else must be \"SEG\" or error.\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"E\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"G\"\r\n\tINS86\t214,332\t\t; MOV DX,DS\r\n\tJZ\tSHORT DEFNC2\t;NO ASSIGNMENT, USE CURRENT [DS].\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET EQULTK\t; ELSE MUST HAVE EQUAL SIGN\r\n\tCALL\tFRMQNT\t\t;GET SEGMENT IN DX\r\nDEFNC2:\tMOV\tSAVSEG,DX\t;STORE FOR PEEK/POKE/CALL/BLOAD/BSAVE\r\n\tRET\t\t\t;RETURN TO NEWSTT\r\nDEFNC3:\r\n\tCALL\tGETFNM\t\t;GET A POINTER TO THE FUNCTION NAME\r\n\tCALL\tERRDIR\t\t;DEF IS \"ILLEGAL DIRECT\"\r\n\tXCHG\tBX,DX\t\t;[D,E] = THE TEXT POINTER AFTER THE FUNCTION\r\n\t\t\t\t;NAME AND [H,L] = POINTER AT PLACE TO STORE\r\n\t\t\t\t;VALUE OF THE FUNCTION VARIABLE\r\n\tMOV\t[BX],DX\t\t;SAVE THE TEXT POINTER AS THE VALUE\r\n\tXCHG\tBX,DX\t\t;RESTORE THE TEXT POINTER TO [H,L]\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET NEXT CHAR\r\n\tCMP\tAL,LOW \"(\"\t;DOES THIS FUNCTION HAVE ARGS?\r\n\tJZ\tSHORT ??L039\r\n\tJMP\tDATA\t\t;NO\r\n??L039:\r\n\tCALL\tCHRGTR\r\nSCNLIS:\tCALL\tPTRGET\t\t;GET POINTER TO DUMMY VAR(CREATE VAR)\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET TERMINATOR\r\n\tCMP\tAL,LOW \")\"\t;END OF ARG LIST?\r\n\tJNZ\tSHORT ??L040\r\n\tJMP\tDATA\t\t;YES\r\n??L040:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;\",\" MUST FOLLOW THEN\r\n\tJMP\tSHORT SCNLIS\r\n\r\nFNDOER:\tCALL\tGETFNM\t\t;GET A POINTER TO\r\n\tMOV\tAL,BYTE PTR VALTYP\t;FIND OUT WHAT KIND OF FUNCTION IT IS\r\n\tOR\tAL,AL\t\t;PUSH THIS [A] ON WITH A PSW WITH CARRY OFF\r\n\t\t\t\t;SO THAT WHEN VALUES ARE BEING POPPED OFF\r\n\t\t\t\t;AND RESTORED TO PARAMETERS WE WILL KNOW\r\n\t\t\t\t;WHEN TO STOP\r\n\t\t\t\t;WHEN A VALTYP IS POPPED OFF WITH\r\n\t\t\t\t;CARRY OFF\r\n\tPUSH\tAX\t\t;SAVE SO THAT THE FINAL RESULT WILL\r\n\t\t\t\t;BE COERCED TO THE FUNCTION TYPE\r\n\tMOV\tTEMP2,BX\t;SAVE THE TEXT POINTER THAT POINTS PAST\r\n\t\t\t\t;THE FUNCTION NAME IN THE CALL\r\n\tXCHG\tBX,DX\t\t;[H,L]=A POINTER TO THE VALUE OF FUNCTION\r\n\tMOV\tBX,[BX]\t\t;[H,L]=VALUE OF THE FUNCTION\r\n\t\t\t\t;WHICH IS A TEXT POINTER AT THE FORMAL\r\n\t\t\t\t;PARAMETER LIST IN THE DEFINITION\r\n\tOR\tBX,BX\t\t;A ZERO TEXT POINTER MEANS THE FUNCTION\r\n\t\t\t\t;WAS NEVER DEFINED\r\n\tJNZ\tSHORT ??L041\r\n\tJMP\tUFERR\t\t;IF SO, GIVEN AN \"UNDEFINED FUNCTION\" ERROR\r\n??L041:\r\n\tMOV\tAL,BYTE PTR [BX]\t;SEE IF THERE ARE ANY PARAMETERS\r\n\tCMP\tAL,LOW \"(\"\t;PARAMETER LIST STARTS WITH \"(\"\"\r\n\tJZ\tSHORT ??L042\r\n\tJMP\tFINVLS\t\t;SKIP OVER PARAMETER SETUP\r\n??L042:\r\n\tCALL\tCHRGTR\t\t;GO PAST THE \"(\"\r\n\tMOV\tTEMP3,BX\t;SAVE THE TEXT POINTER TO THE START OF THE\r\n\tXCHG\tBX,DX\t\t;PARAMETER LIST.\r\n\tMOV\tBX,TEMP2\t;NOW GET THE TEXT-POINTER FROM THE CALL\r\n\t\t\t\t;WHICH IS POINTING JUST PAST THE\r\n\t\t\t\t;FUNCTION NAME AT THE ARGUMENT LIST\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"(\"\t;MAKE SURE THE ARGUMENT LIST IS THERE\r\n\tXOR\tAL,AL\t\t;INDICATE END OF VALUES TO ASSIGN\r\n\tPUSH\tAX\r\n\tPUSH\tBX\t\t;SAVE THE CALLERS TEXT POINTER\r\n\tXCHG\tBX,DX\t\t;GET THE POINTER TO THE BEGINNING OF THE\r\n\t\t\t\t;PARAMETER LIST\r\nASGMOR:\tMOV\tAL,LOW 128\t;OUTLAW ARRAYS WHEN SCANNING\r\n\tMOV\tBYTE PTR SUBFLG,AL\t;PARAMETERS\r\n\tCALL\tPTRGET\t\t;READ A PARAMETER\r\n\tXCHG\tBX,DX\t\t;[D,E]=PARAMETER LIST TEXT,[H,L]=VARIABLE POINTER\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE THE VARIABLES POSITION AND\r\n\t\t\t\t;GET THE POINTER AT THE ARG LIST\r\n\tMOV\tAL,BYTE PTR VALTYP\t;AND ITS TYPE (FOR COERCION)\r\n\tPUSH\tAX\r\n\tPUSH\tDX\t\t;SAVE THE TEXT POINTER INTO THE PARAMETER\r\n\tCALL\tFRMEVL\t\t;EVALUATE THE ARGUMENT\r\n\tMOV\tTEMP2,BX\t;SAVE THE ARGUMENT LIST POINTER\r\n\tPOP\tBX\t\t;AND THE PARAMETER LIST POINTER\r\n\tMOV\tTEMP3,BX\r\n\tPOP\tAX\t\t;GET THE VALUE TYPE\r\n\tCALL\tDOCNVF\t\t;COERCE THE ARGUMENT\r\n\tMOV\tCL,LOW 4\t;MAKE SURE THERE IS ROOM FOR THE VALUE\r\n\tCALL\tGETSTK\r\n\tMOV\tBX,OFFSET 0-8\t;SAVE EIGHT PLACES\r\n\tADD\tBX,SP\r\n\tMOV\tSP,BX\r\n\tCALL\tVMOVMF\t\t;PUT VALUE INTO RESERVED PLACE IN STACK\r\n\tMOV\tAL,BYTE PTR VALTYP\t;SAVE TYPE FOR ASSIGNMENT\r\n\tPUSH\tAX\r\n\tMOV\tBX,TEMP2\t;REGET THE ARGUMENT LIST POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;SEE WHAT COMES AFTER THE ARGUMENT FORMULA\r\n\tCMP\tAL,LOW \")\"\t;IS THE ARGUMENT LIST ENDING?\r\n\tJZ\tSHORT POPASG\t;MAKE SURE THE ARGUMENT LIST ALSO ENDED\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;SKIP OVER ARGUMENT COMMA\r\n\tPUSH\tBX\t\t;SAVE THE ARGUMENT LIST TEXT POINTER\r\n\tMOV\tBX,TEMP3\t;GET THE TEXT POINTER INTO THE DEFINTION'S\r\n\t\t\t\t;PARAMETER LIST\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;SKIP OVER THE PARAMETER LIST COMMA\r\n\tJMP\tSHORT ASGMOR\t;AND BIND THE REST OF THE PARAMETERS\r\nPOPAS2:\tPOP\tAX\t\t;IF ASSIGNMENT IS SUCESSFUL UPDATE PRMLN2\r\n\tMOV\tBYTE PTR PRMLN2,AL\t;INDICATE NEW VARIABLE IS IN PLACE\r\nPOPASG:\tPOP\tAX\t\t;GET THE VALUE TYPE\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT FINASG\t;ZERO MEANS NO MORE LEFT TO POP AND ASSIGN\r\n\tMOV\tBYTE PTR VALTYP,AL\r\n\tMOV\tBX,0\t\t;POINT INTO STACK\r\n\tADD\tBX,SP\t\t;TO GET SAVED VALUE\r\n\tCALL\tVMOVFM\t\t;PUT VALUE INTO FAC\r\n\tMOV\tBX,8\t\t;FREE UP STACK AREA\r\n\tADD\tBX,SP\r\n\tMOV\tSP,BX\r\n\tPOP\tDX\t\t;GET PLACE TO STORE TO\r\n\tMOV\tBL,LOW 3\t;CALCULATE THE SIZE OF THE LOOKS (NAME)\r\nLPSIZL:\tINC\tBL\t\t;INCREMENT SIZE\r\n\tDEC\tDX\t\t;POINT AT PREVIOUS CHARACTER\r\n\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\t\t;SEE IF IT IS THE LENGTH OR ANOTHER CHARACTER\r\n\tOR\tAL,AL\r\n\tJNS\tSHORT ??L043\r\n\tJMP\tLPSIZL\t\t;HIGH BIT INDICATES STILL PART OF NAME\r\n??L043:\r\n\tDEC\tDX\t\t;BACK UP OVER LOOKS\r\n\tDEC\tDX\r\n\tDEC\tDX\r\n\tMOV\tAL,BYTE PTR VALTYP\t;GET SIZE OF VALUE\r\n\tADD\tAL,BL\t\t;ADD ON SIZE OF NAME\r\n\tMOV\tCH,AL\t\t;SAVE TOTAL LENGTH IN [B]\r\n\tMOV\tAL,BYTE PTR PRMLN2\t;GET CURRENT SIZE OF BLOCK\r\n\tMOV\tCL,AL\t\t;SAVE IN [C]\r\n\tADD\tAL,CH\t\t;GET POTENTIAL NEW SIZE\r\n\tCMP\tAL,LOW OFFSET PRMSIZ\t;CAN'T EXCEED ALLOCATED STORAGE\r\n\tJNAE\tSHORT ??L044\r\n\tJMP\tFCERR\r\n??L044:\r\n\tPUSH\tAX\t\t;SAVE NEW SIZE\r\n\tMOV\tAL,BL\t\t;[A]=SIZE OF NAME\r\n\tMOV\tCH,LOW 0\t;[B,C]=SIZE OF PARM2\r\n\tMOV\tBX,OFFSET PARM2\t;BASE OF PLACE TO STORE INTO\r\n\tADD\tBX,CX\t\t;[H,L]=PLACE TO START THE NEW VARIABLE\r\n\tMOV\tCL,AL\t\t;[B,C]=LENGTH OF NAME OF VARIABLE\r\n\tCALL\tBCTRAN\t\t;PUT IN THE NEW NAME\r\n\tMOV\tCX,OFFSET POPAS2\t;PLACE TO RETURN AFTER ASSIGNMENT\r\n\tPUSH\tCX\r\n\tPUSH\tCX\t\t;SAVE EXTRA ENTRY ON STACK\r\n\tJMP\tLETCN4\t\t;PERFORM ASSIGNMENT ON [H,L] (EXTRA POP D)\r\nFINASG:\tMOV\tBX,TEMP2\t;GET ARGUMENT LIST POINTER\r\n\tCALL\tCHRGTR\t\t;SKIP OVER THE CLOSING PARENTHESIS\r\n\tPUSH\tBX\t\t;SAVE THE ARGUMENT TEXT POINTER\r\n\tMOV\tBX,TEMP3\t;GET THE PARAMETER LIST TEXT POINTER\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\t;MAKE SURE THE PARAMETER LIST\r\n\t\t\t\t;ENDED AT THE SAME TIME\r\n\tDB\t260O\t; SKIP\t;SKIP THE NEXT BYTE WITH \"MVI AL,\"\r\nFINVLS:\tPUSH\tDX\t\t;HERE WHEN THERE WERE NO ARGUMENTS\r\n\t\t\t\t;OR PARAMETERS\r\n\t\t\t\t;SAVE THE TEXT POINTER OF THE CALLER\r\n\tMOV\tTEMP3,BX\t;SAVE THE TEXT POINTER OF THE FUNCTION\r\n\tMOV\tAL,BYTE PTR PRMLEN\t;PUSH PARM1 STUFF ONTO THE STACK\r\n\tADD\tAL,LOW 4\t;WITH PRMLEN AND PRMSTK (4 BYTES EXTRA)\r\n\tPUSH\tAX\t\t;SAVE THE NUMBER OF BYTES\r\n\tROR\tAL,1\t\t;NUMBER OF TWO BYTE ENTRIES IN [A]\r\n\tMOV\tCL,AL\r\n\tCALL\tGETSTK\t\t;IS THERE ROOM ON THE STACK?\r\n\tPOP\tAX\t\t;[A]=AMOUNT TO PUT ONTO STACK\r\n\tMOV\tCL,AL\r\n\tNOT\tAL\t\t;COMPLEMENT [A]\r\n\tINC\tAL\r\n\tMOV\tBL,AL\r\n\tMOV\tBH,LOW 255\r\n\tADD\tBX,SP\r\n\tMOV\tSP,BX\t\t;SET UP NEW STACK\r\n\tPUSH\tBX\t\t;SAVE THE NEW VALUE FOR PRMSTK\r\n\tMOV\tDX,OFFSET PRMSTK\t;FETCH DATA FROM HERE\r\n\tCALL\tBCTRAN\r\n\tPOP\tBX\r\n\tMOV\tPRMSTK,BX\t;LINK PARAMETER BLOCK FOR GARBAGE COLLECTION\r\n\tMOV\tBX,PRMLN2\t;NOW PUT PARM2 INTO PARM1\r\n\tMOV\tPRMLEN,BX\t;SET UP LENGTH\r\n\tMOV\tCX,BX\t\t;[B,C]=TRANSFER COUNT\r\n\tMOV\tBX,OFFSET PARM1\r\n\tMOV\tDX,OFFSET PARM2\r\n\tCALL\tBCTRAN\r\n\tMOV\tBH,AL\t\t;CLEAR OUT PARM2\r\n\tMOV\tBL,AL\r\n\tMOV\tPRMLN2,BX\r\n\tMOV\tBX,FUNACT\t;INCREMENT FUNCTION COUNT\r\n\tINC\tBX\r\n\tMOV\tFUNACT,BX\r\n\tMOV\tAL,BH\r\n\tOR\tAL,BL\t\t;SET UP ACTIVE FLAG NON-ZERO\r\n\tMOV\tBYTE PTR NOFUNS,AL\r\n\tMOV\tBX,TEMP3\t;GET BACK THE FUNCTION DEFINITION TEXT POINTER\r\n;       DCX     H               ;DETECT A MULTI-LINE FUNCTION\r\n;       CHRGET                  ;IF THE DEFINITION ENDS NOW\r\n;       JZ      MULFUN          ;IF ENDS, ITS A MULTI-LINE FUNCTION\r\n\t\t\t\t;SKIP OVER THE \"=\" IN THE DEFINITION\r\n\tCALL\tFRMEQL\t\t;AND EVALUATE THE DEFINITION FORMULA\r\n\t\t\t\t;CAN HAVE RECURSION AT THIS POINT\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\t\t;SEE IF THE STATEMENT ENDED RIGHT\r\n\tJZ\tSHORT ??L045\r\n\tJMP\tSNERR\t\t;THIS IS A CHEAT, SINCE THE LINE\r\n??L045:\r\n\t\t\t\t;NUMBER OF THE ERROR WILL BE THE CALLERS\r\n\t\t\t\t;LINE # INSTEAD OF THE DEFINITIONS LINE #\r\n\tCALL\tGETYPR\t\t;SEE IT THE RESULT IS A STRING\r\n\tJNZ\tSHORT NOCPRS\t;WHOSE DESCRIPTOR IS ABOUT TO BE WIPED OUT\r\n\t\t\t\t;BECAUSE IT IS SITTING IN PARM1 (THIS\r\n\t\t\t\t; HAPPENS IT THE FUNCTION IS A PROJECTION\r\n\t\t\t\t; FUNCTION ON A STRING ARGUMENT)\r\n\tMOV\tDX,OFFSET DSCTMP\t;DSCTMP IS PAST ALL THE TEMP AREA\r\n\tMOV\tBX,FACLO\t;GET THE ADDRESS OF THE DESCRIPTOR\r\n\tCMP\tBX,DX\r\n\tJB\tSHORT NOCPRS\t;RESULT IS A TEMP - NO COPY NESC\r\n\tCALL\tSTRCPY\t\t;MAKE A COPY IN DSCTMP\r\n\tCALL\tPUTTMP\t\t;PUT RESULT IN A TEMP AND MAKE FACLO POINT AT IT\r\nNOCPRS:\tMOV\tBX,PRMSTK\t;GET PLACE TO RESTORE PARM1 FROM STACK\r\n\tMOV\tDH,BH\r\n\tMOV\tDL,BL\r\n\tINC\tBX\t\t;POINT AT LENGTH\r\n\tINC\tBX\r\n\tMOV\tCL,BYTE PTR [BX]\t;[B,C]=LENGTH\r\n\tINC\tBX\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tINC\tCX\t\t;INCLUDE EXTRA BYTES\r\n\tINC\tCX\r\n\tINC\tCX\r\n\tINC\tCX\r\n\tMOV\tBX,OFFSET PRMSTK\t;PLACE TO STORE INTO\r\n\tCALL\tBCTRAN\r\n\tXCHG\tBX,DX\t\t;[D,E]=PLACE TO RESTORE STACK TO\r\n\tMOV\tSP,BX\r\n\tMOV\tBX,FUNACT\t;DECREASE ACTIVE FUNCTION COUNT\r\n\tDEC\tBX\r\n\tMOV\tFUNACT,BX\r\n\tMOV\tAL,BH\r\n\tOR\tAL,BL\t\t;SET UP FUNCTION FLAG\r\n\tMOV\tBYTE PTR NOFUNS,AL\r\n\tPOP\tBX\t\t;GET BACK THE CALLERS TEXT POINTER\r\n\tPOP\tAX\t\t;GET BACK THE TYPE OF THE FUNCTION\r\nPUBLIC\tDOCNVF\r\nDOCNVF:\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tAND\tAL,LOW 7\t;SETUP DISPATCH TO FORCE\r\n\t\t\t\t;FORMULA TYPE TO CONFORM\r\n\t\t\t\t;TO THE VARIABLE ITS BEING ASSIGNED TO\r\n\tMOV\tBX,OFFSET FRCTBL\t;TABLE OF FORCE ROUTINES\r\n\tMOV\tCL,AL\t\t;[B,C]=TWO BYTE OFFSET\r\n\tMOV\tCH,LOW 0\r\n\tADD\tBX,CX\r\n\tCALL\tDISPAT\t\t;DISPATCH\r\n\tPOP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tRET\t\r\n;\r\n; BLOCK TRANSFER ROUTINE WITH SOURCE IN [D,E] DESTINATION IN [H,L]\r\n; AND COUNT IN [B,C]. TRANSFER IS FORWARD.\r\n;\r\nBCTRAL:\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\r\n\tMOV\tBYTE PTR [BX],AL\r\n\tINC\tBX\r\n\tINC\tDX\r\n\tDEC\tCX\r\nBCTRAN:\tMOV\tAL,CH\r\n\tOR\tAL,CL\r\n\tJNZ\tSHORT BCTRAL\r\n\tRET\t\r\n;\r\n; SUBROUTINE TO SEE IF WE ARE IN DIRECT MODE AND\r\n; COMPLAIN IF SO\r\n;\r\nERRDIR:\tPUSH\tBX\t\t;SAVE THEIR [H,L]\r\n\tMOV\tBX,CURLIN\t;SEE WHAT THE CURRENT LINE IS\r\n\tINC\tBX\t\t;DIRECT IS 65,535 SO NOW 0\r\n\tOR\tBX,BX\t\t;IS IT ZERO NOW?\r\n\tPOP\tBX\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;RETURN IF NOT\r\n\tMOV\tDL,LOW OFFSET ERRID\t;\"ILLEGAL DIRECT\" ERROR\r\n\tJMP\tERROR\r\n;\r\n;\r\n; SUBROUTINE TO GET A POINTER TO A FUNCTION NAME\r\n;\r\nGETFNM:\tCALL\tSYNCHR\r\n\tDB\tOFFSET FNTK\t;MUST START WITH \"FN\"\r\n\tMOV\tAL,LOW 128\t;DONT ALLOW AN ARRAY\r\n\tMOV\tBYTE PTR SUBFLG,AL\t;DON'T RECOGNIZE THE \"(\" AS\r\n\t\t\t\t;THE START OF AN ARRAY REFEREENCE\r\n\tOR\tAL,BYTE PTR [BX]\t;PUT FUNCTION BIT ON\r\n\tMOV\tCL,AL\t\t;GET FIRST CHARACTER INTO [C]\r\n\tJMP\tPTRGT2\r\n\tPAGE\t\r\n\r\n\tSUBTTL STRING FUNCTIONS - LEFT HAND SIDE MID$\r\n\r\nPUBLIC\tISMID$\r\nISMID$:\tCMP\tAL,LOW 126D\t;FUNCTION? (FF - $END)\r\n\tJZ\tSHORT ??L046\r\n\tJMP\tSNERR\t\t;NO, ERROR.\r\n??L046:\r\n\tINC\tBX\t\t;POINT TO NEXT CHAR\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET FN DESCRIPTOR\r\n\tINC\tBX\t\t;POINT TO CHAR AFTER\r\n\tCMP\tAL,LOW OFFSET MIDTK\t;IS IT MID?\r\n\tEXTRN\tLHSMID:NEAR\t;CODE IS IN BISTRS.MAC\r\n\tJNZ\tSHORT ??L047\r\n\tJMP\tLHSMID\r\n??L047:\r\n\tJMP\tSNERR\r\n\r\n\tPAGE\t\r\n\r\n\tSUBTTL INP, OUT, WAIT, CONSOLE, WIDTH\r\n;\r\n; THE FOLLOWING FUNCTIONS ALLOW THE \r\n; USER FULL ACCESS TO THE 8080/Z80  I/O PORTS\r\n; INP(CHANNEL#) RETURNS AN INTEGER WHICH IS THE STATUS\r\n; OF THE CHANNEL. OUT CHANNEL#,VALUE PUTS OUT THE INTEGER\r\n; VALUE ON CHANNEL #. IT IS A STATEMENT, NOT A FUNCTION.\r\n;\r\nFNINP:\r\n\tCALL\tFRQINT\t\t;MAKE ARGUMENT AN INTEGER CHANNEL NUMBER\r\n\tXCHG\tBX,DX\r\n\tINS86\t354\t\t;READ BYTE INTO AL FROM DX=[D,E] FOR 8086\r\n\tJMP\tSNGFLT\r\nSETIO:\r\n\tCALL\tFRMQNT\t\t;READ A 16-BIT PORT FOR Z80 AND 8086\r\n\tPUSH\tDX\t\t;SAVE FOR USE BY WAIT AND FNOUT\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44D\r\n\tCALL\tGETBYT\t\t;READ THE DATA BYTE TO [A] AND [E]\r\n\tPOP\tDX\t\t;RETURN PORT IN [D,E]=DX FOR 8086\r\n\tRET\t\r\nFNOUT:\tCALL\tSETIO\t\t;GET PORT IN [B,C] AND DATA IN [A] & [E]\r\n\tINS86\t356\t\t;OUTPUT TO PORT DX=[D,E] FROM [A]\r\n\tRET\t\r\n;\r\n; THE WAIT CHANNEL#,MASK,MASK2 WAITS UNTIL THE STATUS\r\n; RETURNED BY CHANNEL# IS NON ZERO WHEN XORED WITH MASK2\r\n; AND THEN ANDED WITH MASK. IF MASK2 IS NOT PRESENT IT IS ASSUMED\r\n; TO BE ZERO.\r\n;\r\nFNWAIT:\tCALL\tSETIO\t\t;SET UP FOR WAIT\r\n\tPUSH\tDX\t\t;SAVE THE I/O PORT\r\n\tPUSH\tAX\t\t;SAVE THE MASK\r\n\tMOV\tDL,LOW 0\t;DEFAULT MASK2 TO ZERO\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\t\t;SEE IF THE STATEMENT ENDED\r\n\tJZ\tSHORT NOTTHR\t;IF NO THIRD ARGUMENT SKIP THIS\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;MAKE SURE THERE IS A \",\"\r\n\tCALL\tGETBYT\r\nNOTTHR:\tPOP\tAX\t\t;REGET THE \"AND\" MASK\r\n\tMOV\tDH,AL\t\t;KEEP AND MASK IN [D]\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;GET BACK THE PORT NUMBER FOR 8086\r\nLOPINP:\r\nEXTRN\tPOLKEY:NEAR\r\n\tCALL\tPOLKEY\t\t;Exit if User CTRL-C'd.\r\n\tXCHG\tBX,DX\t\t;GET READY TO READ PORT IN [D,E]\r\n\tINS86\t354\t\t;READ BYTE INTO [A]\r\n\tXCHG\tBX,DX\r\n\tXOR\tAL,DL\t\t;XOR WITH MASK2\r\n\tAND\tAL,DH\t\t;AND WITH MASK\r\n\tJZ\tSHORT LOPINP\t;LOOP UNTIL RESULT IS NON-ZERO\r\n\t\t\t\t;NOTE: THIS LOOP CANNOT BE CONTROL-C'ED\r\nLOPINX:\tPOP\tBX\t\t;Restore the Text pointer.\r\n\tRET\t\r\nCONSOL:\tJMP\tSNERR\r\n\tEXTRN\tWIDTHS:NEAR\r\nPUBLIC\tGETINT\r\nGETINT:\tCALL\tCHRGTR\r\nPUBLIC\tGETIN2\r\nGETIN2:\tCALL\tFRMEVL\t\t;EVALUATE A FORMULA\r\nPUBLIC\tINTFR2\r\nINTFR2:\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tCALL\tFRCINT\t\t;CONVERT THE FORMULA TO AN INTEGER IN [H,L]\r\n\tXCHG\tBX,DX\t\t;PUT THE INTEGER INTO [D,E]\r\n\tPOP\tBX\t\t;RESTORE THE TEXT POINTER\r\n\tMOV\tAL,DH\t\t;SET THE CONDITION CODES ON THE HIGH ORDER\r\n\tOR\tAL,AL\r\n\tRET\t\r\nPUBLIC\tGTBYTC\r\nGTBYTC:\tCALL\tCHRGTR\r\nPUBLIC\tGETBYT\r\nGETBYT:\tCALL\tFRMEVL\t\t;EVALUATE A FORMULA\r\nPUBLIC\tCONINT\r\nCONINT:\tCALL\tINTFR2\t\t;CONVERT THE FAC TO AN INTEGER IN [D,E]\r\n\t\t\t\t;AND SET THE CONDITION CODES BASED\r\n\t\t\t\t;ON THE HIGH ORDER\r\n\tJZ\tSHORT ??L048\r\n\tJMP\tFCERR\t\t;WASN'T ERROR\r\n??L048:\r\n\tDEC\tBX\t\t;ACTUALLY FUNCTIONS CAN GET HERE\r\n\t\t\t\t;WITH BAD [H,L] BUT NOT SERIOUS\r\n\t\t\t\t;SET CONDITION CODES ON TERMINATOR\r\n\tCALL\tCHRGTR\r\n\tMOV\tAL,DL\t\t;RETURN THE RESULT IN [A] AND [E]\r\n\tRET\t\r\n\r\n\tPAGE\t\r\n\r\n\tSUBTTL EXECUTE BASIC PROGRAM ON PROM\r\n\r\n\r\n\r\n;\r\n; The reserve word tables have dispatch address the could be external.\r\n; ASM86 can only output external declarations during pass 1, so we\r\n; have to construct a chain of possible externals and check each one.\r\n; The following macro runs through the chain and declares any undefined\r\n; addresses as external :NEAR.  For more information, see the file\r\n; PS1:<BASIC.ASM86>BINTRP.H\r\n;\r\n\tDO_EXT\t\r\n;\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GWINIT.ASM",
          "type": "blob",
          "size": 14.375,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GWINIT GW-BASIC-86 Initialization\r\n\r\n;Assumes LEN2, FIVMEM, FIVEO, I8086, PURE\r\n\r\n\r\nTRACEF=0\t\t\t;for Debugging when DEBUG can't be used\r\nCPM86=0\r\nDYNBUF=0\r\nBSEGSZ=0\t\t\t;Size of Buffer segment for Misc. Buffers\r\n\r\n\t.RADIX\t10\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tLSTVAR:WORD\t;Last variable in RAM\r\n\tEXTRN\tFILTAB:WORD,STKLOW:WORD,MAXMEM:WORD\r\n\tEXTRN\tTSTACK:WORD,ERRFLG:WORD\r\n\tEXTRN\tMEMSIZ:WORD,TOPMEM:WORD,SAVSTK:WORD,FRETOP:WORD,TXTTAB:WORD\r\n\tEXTRN\tPROFLG:WORD,CHNFLG:WORD,MRGFLG:WORD,ERRFLG:WORD\r\n\tEXTRN\tCHNFLG:WORD,MRGFLG:WORD,ERRFLG:WORD\r\n\tEXTRN\tPRMSTK:WORD,PRMPRV:WORD\r\nDSEG\tENDS\r\n\r\n\tEXTRN\tFCERR:NEAR,SNERR:NEAR\r\n\r\n;\r\n\tSWTCHR=57O\t\t;DEFAULT SWITCH CHARACTER IS SLASH\r\n\tEXTRN\tMAKUPL:NEAR\r\n\tEXTRN\tCNSGET:NEAR\r\n\tEXTRN\tCHRGTR:NEAR\r\n\tEXTRN\tOUTDO:NEAR,LINPRT:NEAR,CRDO:NEAR,OMERRR:NEAR\r\n\tEXTRN\tREASON:NEAR\r\n\tEXTRN\tREADY:NEAR,STKINI:NEAR\r\n\tEXTRN\tDCOMPR:NEAR\r\n\tEXTRN\tSYNCHR:NEAR\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tBUF:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tSNERR:NEAR,FCERR:NEAR,ATN:NEAR,COS:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tMSWFLG:WORD,MSWSIZ:WORD,CSWFLG:WORD,CSWSIZ:WORD,NEWDS:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tMAPCLC:NEAR,MAPINI:NEAR\r\n\tEXTRN\tINITSA:NEAR\r\n\tPAGE\t\r\n\tSUBTTL  INIT - System Initialization Code\r\n\r\n\tPUBLIC\tINIT\r\n\tEXTRN\tSTROUT:NEAR,HEDING:NEAR,WORDS:NEAR\r\n\tEXTRN\tGWINI:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tBUF:WORD,KBUF:WORD\r\nDSEG\tENDS\r\n\r\nINIT:\r\n; For safety, a label has been defined in BINTRP.MAC that contains the\r\n; start of the data segment.  That is where the O.S. control block will\r\n; be copied to, so it MUST be first in the DSEG.\r\n; BEGDSG is declared as a code segment external here even though it\r\n; really is in the data segment.  This makes it easier to get the offset\r\n; of the beginning of the data segment from the beginning of the code\r\n; segment.  The beginning of DATASG MUST be within 64K of the beginning\r\n; of CODESG for this to work.  No error will be generated, so be careful.\r\n;\r\n\tEXTRN\tBEGDSG:NEAR\t;Beg. of the data segment, offset from CS\r\n\tINS86\t272,,BEGDSG\t;MOVI DX,BEGDSP\r\n\tINS86\t261,4\t\t;MOVI CL,4   Divide by 16 to ...\r\n\tINS86\t323,352\t\t;SHR  DX,CL  get paragraph address\r\n\tINS86\t214,311\t\t;MOV  CX,CS  add in code segment\r\n\tINS86\t3,321\t\t;ADD  DX,CS\r\n\tINS86\t264,46\t\t;MOVBI AH,38 SPECIAL FUNCTION TO CALC END\r\n\t\t\t\t;            OF CS AND RETURN START OF DS\r\n\tINS86\t315,41\t\t;INT  33     CALL SCP DOS\r\n\tINS86\t214,330\t\t;MOV  AX,DS  SAVE DS FOR EXIT VECTOR\r\n\tINS86\t216,332\t\t;MOV  DS,DX  SET UP SEG REGS\r\n\tINS86\t216,302\t\t;MOV  ES,DX\r\n;Initialize the jump vector for exit to MSDOS.  MSDOS 2.0 requires that\r\n; exit is made through the segment prefix table which is located at DS:0.\r\n; For .EXE files, DS is not the same as CS at program initiation time (NOW).\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCPMEXT:WORD\r\nDSEG\tENDS\r\n\tINS86\t307,6,CPMEXT\t;MOVI CPMEXT,^D0\r\n\tINS86\t0,0\t\t;            INS86 has 4 params\r\n\t\t\t\t;            & some may not be words\r\n\tINS86\t220,243,CPMEXT+2\t;NOP         NOP - pad to item 3 of INS86\r\n\t\t\t\t;MOV  CPMEXT+2,AX\r\n\tCLI\t\t\t;Setting the stack segment and stack\r\n\t\t\t\t;pointer must be an indivisable\r\n\t\t\t\t;operation.\r\n\tINS86\t216,322\t\t;MOV SS,DX\r\n\tMOV\tBX,OFFSET BUF+128D\t;Use BUF for a temporary stack.\r\n\tMOV\tMEMSIZ,BX\r\n\tMOV\tSP,BX\r\n\tXOR\tAL,AL\t\t;INITIALIZE PROTECT FLAG\r\n\tMOV\tBYTE PTR PROFLG,AL\r\n\tMOV\tBYTE PTR MSWFLG,AL\t;Init /M: flag\r\n\tMOV\tBYTE PTR CSWFLG,AL\t;Init /C: flag\r\n\tEXTRN\tCNSLEN:NEAR,CONSTR:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tENDBUF:WORD,RAMLOW:WORD\r\nDSEG\tENDS\r\n\tMOV\tCH,LOW OFFSET CNSLEN+3\t;Get number of bytes to move\r\n\tMOV\tBX,OFFSET RAMLOW\t;WHERE THE CONSTANTS ARE STORE IN RAM\r\n\tMOV\tDX,OFFSET CONSTR\t;WHERE THE CONSTANTS ARE HELD IN ROM\r\nMORMOV:\t\t\t\t;MOVE ROM INITIALIZATION VALUES TO RAM\r\n\tINS86\t213,362,56,254\t;CODE SEGMENT FETCH\r\n\tMOV\tBYTE PTR [BX],AL\t;STORE IT AWAY IN RAM\r\n\tINC\tBX\r\n\tINC\tDX\r\n\tDEC\tCH\r\n\tJNZ\tSHORT MORMOV\t;IF NOT, KEEP SHOVELING THEM DOWN\r\n\tSTI\r\n\tEXTRN\tSCNIPL:NEAR\r\n\tCALL\tSCNIPL\t\t;Screen editor initialization\r\n\tCALL\tGWINI\t\t;OEM specific initialization\r\n\tEXTRN\tSNDRST:NEAR\r\n\tCALL\tSNDRST\t\t;reset sound queue, disable speaker\r\n\tEXTRN\tGIOINI:NEAR\r\n\tCALL\tGIOINI\r\n\tMOV\tBX,MEMSIZ\r\n\tMOV\tTOPMEM,BX\r\n\tMOV\tBX,OFFSET KBUF-1\t;INITIALIZE KBUF-1 WITH A COLON\r\n\tMOV\tBYTE PTR [BX],LOW \":\"\t;DIRECT INPUTS RESTART OK.\r\n\tCALL\tSTKINI\t\t;REALLY SET UP INIT'S TEMPORARY STACK\r\n;\r\n;       Check CP/M Version Number\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCPMREA:WORD\r\nDSEG\tENDS\r\n\r\n\tMOV\tBX,OFFSET 34*256+33+0\t;2.x Read / Write\r\nCPMVR1:\tMOV\tCPMREA,BX\t;Save Read/Write Codes\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCNTOFL:WORD\r\nDSEG\tENDS\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR CNTOFL,AL\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tENDBUF:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR ENDBUF,AL\t;MAKE SURE OVERRUNS STOP\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDSEGZ:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR DSEGZ,AL\t;(DS) LOCATED ZERO\r\n\tMOV\tBYTE PTR CHNFLG,AL\t;MAKE SURE CHAINS AND MERGES\r\n\tMOV\tBYTE PTR MRGFLG,AL\t;DONT TRY TO HAPPEN\r\n\tMOV\tBYTE PTR ERRFLG,AL\t;DON'T ALLOW EDIT TO BE CALLED ON ERRORS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tTEMPST:WORD,TEMPPT:WORD\r\nDSEG\tENDS\r\n\tMOV\tBX,OFFSET TEMPST\r\n\tMOV\tTEMPPT,BX\r\n\tMOV\tBX,OFFSET PRMSTK\t;INITIALIZE PARAMETER BLOCK CHAIN\r\n\tMOV\tPRMPRV,BX\r\n\r\n\r\n\tSUBTTL Read Operating System Parameters (memsiz etc.)\r\n\r\n\r\n; THE FOLLOWING CODE SCANS A CP/M COMMAND LINE FOR BASIC.\r\n\r\n; THE FOLLOWING SWITCHES ARE RECOGNIZED:\r\n;\r\n;       /M:<TOPMEM>\r\n;       /F:<FILES>\r\n;       /S:<MAX RECORD SIZE>\r\n;       /C:<COM INPUT QUEUE SIZE>\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCPMMEM:WORD\r\nDSEG\tENDS\r\n\tMOV\tBX,CPMMEM\t;Load bytes free within segment\r\n;For DYNCOM, CPMMEM holds the last segment addr of the system(i.e. CPMMEM=2)\r\n\tEXTRN\tSEGOFF:NEAR\r\n\tCALL\tSEGOFF\t\t;Return byte offset of segment from current DS\r\n\tMOV\tMEMSIZ,BX\t;USE AS DEFAULT\r\n\tMOV\tMAXMEM,BX\t;set MAX DS size for CLEAR statement\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDSEGZ:WORD\r\nDSEG\tENDS\r\n\tMOV\tBX,OFFSET DSEGZ\t;IN THE DATA SEGMENT\r\n\tMOV\tTEMP8,BX\t;SO IF RE-INITAILIZE OK\r\n\tEXTRN\tCPMWRM:NEAR\r\n\tTBUFF\tEQU\tCPMWRM+128D\t;WHERE CP/M COMMAND BUFFER IS LOCATED\r\n\r\n\tMOV\tBX,OFFSET TBUFF\t;POINT TO FIRST CHAR OF COMMAND BUFFER\r\n\tMOV\tAL,BYTE PTR [BX]\t;WHICH CONTAINS # OF CHARS IN COMMAND\r\n\tOR\tAL,AL\t\t;IS THERE A COMMAND?\r\n\tMOV\tTEMP8,BX\t;SAVE POINTER TO THIS ZERO\r\n\tJNZ\tSHORT ??L000\r\n\tJMP\tDONCMD\t\t;NOTHING IN COMMAND BUFFER\r\n??L000:\r\n\tMOV\tCH,BYTE PTR [BX]\t;AND [B]\r\n\tINC\tBX\t\t;POINT TO FIRST CHAR IN BUFFER\r\nTBFLP:\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR FROM BUFFER\r\n\tDEC\tBX\t\t;BACK UP POINTER\r\n\tMOV\tBYTE PTR [BX],AL\t;STORE CHAR BACK\r\n\tINC\tBX\t\t;NOW ADVANCE CHAR TO ONE PLACE\r\n\tINC\tBX\t\t;AFTER PREVIOUS POSIT.\r\n\tDEC\tCH\r\n\tJNZ\tSHORT TBFLP\t;KEEP MOVING CHARS\r\n\tDEC\tBX\t\t;BACK UP POINTER\r\nENDCMD:\tMOV\tBYTE PTR [BX],LOW 0\t;STORE TERMINATOR FOR CHRGET (0)\r\n\tMOV\tTEMP8,BX\t;SAVE POINTER TO NEW ZERO (OLD DESTROYED)\r\n\tMOV\tBX,OFFSET TBUFF-1\t;POINT TO CHAR BEFORE BUFFER\r\n\tCALL\tCHRGTR\t\t;IGNORE LEADING SPACES\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT ??L001\r\n\tJMP\tDONCMD\t\t;END OF COMMAND\r\n??L001:\r\n\tCMP\tAL,LOW OFFSET SWTCHR\t;IS IT A SLASH\r\n\tJZ\tSHORT FNDSLH\t;YES\r\n\tDEC\tBX\t\t;BACK UP POINTER\r\n\tMOV\tBYTE PTR [BX],LOW 34\t;STORE DOUBLE QUOTE\r\n\tMOV\tTEMP8,BX\t;SAVE POINTER TO START OF FILE NAME\r\n\tINC\tBX\t\t;BUMP POINTER\r\nISSLH:\tCMP\tAL,LOW OFFSET SWTCHR\t;OPTION?\r\n\tJZ\tSHORT FNDSLH\t;YES\r\n\tCALL\tCHRGTR\t\t;SKIP OVER CHAR IN FILE NAME\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJNZ\tSHORT ISSLH\t;KEEP LOOKING FOR OPTION\r\n\tJMP\tDONCMD\t\t;THATS IT\r\nFNDSLH:\tMOV\tBYTE PTR [BX],LOW 0\t;STORE TERMINATOR OVER \"/\"\r\nSCANSW:\r\n\tCALL\tCHRGTR\t\t;GET CHAR AFTER SLASH\r\nSCANS1:\r\n\tCALL\tMAKUPL\t\t;CONVERT SWITCH TO UPPER CASE\r\n\tCMP\tAL,LOW \"S\"\t;IS IT /S: ? (SET MAX RECORD SIZE)\r\n\tJZ\tSHORT WASS\r\n\tCMP\tAL,LOW \"C\"\t;COM buffer size option\r\n\tJZ\tSHORT WASC\r\n\tCMP\tAL,LOW \"F\"\t;FILES OPTION\r\n\tJZ\tSHORT WASF\r\n\tCMP\tAL,LOW \"M\"\t;MEMORY OPTION\r\n\tJZ\tSHORT ??L002\r\n\tJMP\tSNERR\t\t;Branch if couldn't recognize option\r\n??L002:\r\n\tCALL\tGETVAL\t\t;[DX]=requested MEMSIZ\r\n\tMOV\tMSWSIZ,DX\t;Record memory request\r\n\tMOV\tAL,LOW 377O\r\n\tMOV\tBYTE PTR MSWFLG,AL\t;Set /M: option flag\r\nFOK:\tDEC\tBX\t\t;RESCAN LAST CHAR\r\n\tCALL\tCHRGTR\t\t;BY CALLING CHRGET\r\n\tJZ\tSHORT DONCMD\t;END OF COMMAND\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET SWTCHR\t;SLASH SHOULD FOLLOW\r\n\tJMP\tSHORT SCANS1\t;SCAN NEXT SWITCH\r\n\r\nWASC:\tMOV\tAL,LOW 377O\r\n\tMOV\tBYTE PTR CSWFLG,AL\t;Set /C: option flag\r\n\tCALL\tGETVAL\t\t;Get COM request to D,E\r\n\tMOV\tCSWSIZ,DX\t;Record for future memory map calc.\r\n\tJMP\tSHORT FOK\r\nWASS:\t\t\t\t;GIO has dynamic record size\r\nWASF:\t\t\t\t;GIO has dynamic number of files\r\n\tCALL\tGETVAL\t\t;Get value\r\n\tJMP\tSHORT FOK\t;Any value OK (and ignored)\r\n\r\nGETVAL:\tCALL\tCHRGTR\t\t;skip M,F or S\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \":\"\t;MAKE SURE COLON FOLLOWS\r\n\tJMP\tCNSGET\t\t;[DE]=VALUE FOLLOWING COLON\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tTEMP8:WORD\t;POINTER TO BASIC LOAD FILE\r\nDSEG\tENDS\r\nERRCMD:\r\nDONCMD:\r\n\tCALL\tMAPCLC\t\t;Calc. (but don't set) the new mem. map\r\n\r\n;Now copy the command line file name (if there is one) to BUF\r\n;Move required since DS: segment header will be overwritten when the\r\n;DS: is coppied to the new DS: location.\r\n\r\n\tMOV\tBX,TEMP8\t;Load address of command line file name\r\n\tMOV\tDX,OFFSET BUF\t;Destination address\r\n\tMOV\tTEMP8,DX\t;New command line buffer address\r\nNXTBYT:\tMOV\tAL,BYTE PTR [BX]\t;File name character\r\n\tXCHG\tBX,DX\r\n\tMOV\tBYTE PTR [BX],AL\t;Store at BUF\r\n\tINC\tBX\r\n\tXCHG\tBX,DX\r\n\tINC\tBX\r\n\tOR\tAL,AL\t\t;Test for zero byte terminator\r\n\tJNZ\tSHORT NXTBYT\t;Get next file name character\r\n\r\n\tSUBTTL Allocate Space for Disk Buffers\r\n\r\n; Disk Initialization Routine\r\n\r\n; setup  file info blocks\r\n; the number of each and information for\r\n; getting to pointers to each is stored. no locations are\r\n; initialized, this is done by nodsks, first closing all files.\r\n; the number of files is the file pointer table\r\n;\r\n\tMOV\tBX,MEMSIZ\t;get size of memory\r\n\tDEC\tBX\t\t;always leave top byte unused because\r\n\t\t\t\t;val(string) makes byte in memory\r\n\t\t\t\t;beyond last char of string=0\r\n\tMOV\tMEMSIZ,BX\t;save in real memory size\r\n\tDEC\tBX\t\t;one lower is stktop\r\n\tPUSH\tBX\t\t;save it on stack\r\n\r\n\r\n\tSUBTTL INIT TXTAB, STKTOP, VARTAB, MEMSIZ, FRETOP, STREND\r\n\r\n; Memory map for GW-BASIC:\r\n;\r\n;               [MAXMEM]--}     highest byte of physical memory in system\r\n;                               user managed memory\r\n;               [TOPMEM]--}     highest byte available to BASIC\r\n;                               basic stack\r\n;               [STKLOW]--}     lowest byte available for STACK\r\n;                           +--}FDB---}[STKEND] {end of chain}\r\n;                           +---FDB{--+\r\n;               [FILTAB]-------}FDB---+ (FILTAB points to lowest byte of lowest FDB)\r\n;                               0 (1 byte string space terminator for VAL)\r\n;               [MEMSIZ]--}     highest byte of IN-USE string space\r\n;               [FRETOP]--}     highest byte of FREE string space\r\n;               [STREND]--}     lowest  byte of FREE string space\r\n;               [ARYTAB]--}     lowest  byte of Array Table\r\n;               [VARTAB]--}     lowest  byte of Variable Table\r\n;               [TXTTAB]--}     lowest  byte of BASIC Program Text\r\n;\r\n; note:  when [FILTAB] = [STKLOW], no FDB's are allocated.\r\n;        when [FRETOP] = [MEMSIZ], IN-USE string space is empty.\r\n;        when [SP] = [STKLOW], STACK is full.\r\n\r\n; At this point, MEMSIZ-1 is on stack, [HL]=TXTTAB-1\r\n;\r\n\tMOV\tBX,OFFSET LSTVAR\t;LSTVAR resides in last linked module with DS:\r\n\tMOV\tTXTTAB,BX\t;save bottom of memory\r\n\tPOP\tDX\t\t;GET CURRENT MEMSIZ\r\n\tMOV\tAL,DL\t\t;WANT AN EVEN STACK PTR. FOR 8086\r\n\tAND\tAL,LOW 254D\t;SO WE'LL CLEAR LOW BIT\r\n\tMOV\tDL,AL\t\t;OF THE STACK PTR.\r\n\tMOV\tAL,DL\t\t;CALC TOTAL FREE/8\r\n\tSUB\tAL,BL\r\n\tMOV\tBL,AL\r\n\tMOV\tAL,DH\r\n\tSBB\tAL,BH\r\n\tMOV\tBH,AL\r\n\tJAE\tSHORT ??L003\r\n\tJMP\tOMERRR\r\n??L003:\r\n\tMOV\tCL,LOW 3\t;SHIFT RIGHT THREE BITS (DIVIDE BY 8)\r\n\tINS86\t323,353\t\t;SHR BX,CL\r\n\tMOV\tAL,BH\t\t;SEE HOW MUCH\r\n\tCMP\tAL,LOW 2\t;IF LESS THAN 512 USE 1 EIGHTH\r\n\tJB\tSHORT SMLSTK\r\n\tMOV\tBX,512D\r\nSMLSTK:\tMOV\tAL,DL\t\t;SUBTRACT STACK SIZE FROM TOP MEM\r\n\tSUB\tAL,BL\r\n\tMOV\tBL,AL\r\n\tMOV\tAL,DH\r\n\tSBB\tAL,BH\r\n\tMOV\tBH,AL\r\n\tJAE\tSHORT ??L004\r\n\tJMP\tOMERRR\r\n??L004:\r\n\r\n\tMOV\tSTKLOW,BX\t;Save lowest legal value for [SP]\r\n\tMOV\tFILTAB,BX\t;Initially there are no FDB's\r\n\tDEC\tBX\r\n\tMOV\tBYTE PTR [BX],LOW 0\t;String space should be terminated by 0 for VAL\r\n\tDEC\tBX\r\n\tMOV\tMEMSIZ,BX\t;Save highest byte to be used by strings\r\n\tXCHG\tBX,DX\r\n\tMOV\tTOPMEM,BX\r\n\tMOV\tFRETOP,BX\t;REASON USES THIS...\r\n\tMOV\tSP,BX\t\t;SET UP NEW STACK\r\n\tMOV\tSAVSTK,BX\r\n\tMOV\tBX,TXTTAB\r\n\tXCHG\tBX,DX\r\n\tCALL\tREASON\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFREFLG:WORD\t;Print free bytes flag\r\nDSEG\tENDS\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR FREFLG,AL\t;Clear to print free bytes message\r\n\tEXTRN\tGETHED:NEAR\t;OEM heading retrieval routine\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tKEYSW:WORD\t;Function key on flag\r\nDSEG\tENDS\r\n\tMOV\tAL,LOW 255D\t;if heading is printed, display Fn keys also\r\n\tMOV\tBYTE PTR KEYSW,AL\r\n\tCALL\tGETHED\t\t;Get OEM specific portion of the heading\r\n\tJNZ\tSHORT PRNTIT\t;Always print the heading option\r\n\tPUSH\tBX\t\t;Print heading if no program option\r\n\tMOV\tBX,TEMP8\t;Get pointer to file or 0\r\n\tMOV\tAL,BYTE PTR [BX]\t;Test for file on command line\r\n\tPOP\tBX\t\t;Retrieve OEM heading pointer\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT PRNTIT\t;No program - go print heading\r\n\tMOV\tBYTE PTR FREFLG,AL\t;Set to inhibit free bytes message\r\n\tXOR\tAL,AL\t\t;Turn keys off if there is a program\r\n\tMOV\tBYTE PTR KEYSW,AL\t; otherwise allow OEM default\r\n\tJMP\tSHORT PRNTND\t;Skip heading\r\n\r\nPRNTIT:\tCALL\tSTROUT\t\t;Print it\r\n\tMOV\tBX,OFFSET HEDING\t;GET HEADING (\"BASIC VERSION...\")\r\n\tCALL\tSTROUT\t\t;PRINT IT\r\nPRNTND:\r\n\tEXTRN\tSKEYON:NEAR\r\n\tMOV\tAL,BYTE PTR KEYSW\t;Get function key display switch\r\n\tOR\tAL,AL\t\t;Keys need to be turned on?\r\n\tJNZ\tSHORT ??L005\r\n\tJMP\tKEYSOF\t\t;Leave keys off\r\n??L005:\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR KEYSW,AL\t;Show current status of keys\r\n\tCALL\tSKEYON\t\t;Set function key display on\r\nKEYSOF:\tMOV\tAL,LOW 377O\r\n\tMOV\tBYTE PTR INITFG,AL\t;Set the initialization complete flag\r\n\t\t\t\t;indicating errors no longer result in an exit\r\n\t\t\t\t;to the OS\r\n\tJMP\tINITSA\r\n\tPAGE\t\r\n;CMDERR This routine is called when an error is detected before the\r\n;       completion of initialization (before INITFG is set to non-zero).\r\n;       CMDERR performs the following:\r\n;               1. Write the heading\r\n;               2. Write an error message implicating the command line.\r\n;               3. Exit to the operating system through SYSTME\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tINITFG:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tSYSTME:NEAR,CERMSG:NEAR\r\n\tPUBLIC\tCMDERR\r\n\r\nCMDERR:\tMOV\tBX,OFFSET HEDING\t;Get heading (\"BASIC VERSION...\")\r\n\tCALL\tSTROUT\t\t;Print it\r\n\tMOV\tBX,OFFSET CERMSG\t;Get command error message\r\n\tCALL\tSTROUT\t\t;Print it\r\n\tJMP\tSYSTME\t\t;Exit to the OS\r\n\r\nPUBLIC\t$LAST\r\n\t$LAST=$\r\nPUBLIC\tLASTWR\r\n\tLASTWR=$\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GWLIST.ASM",
          "type": "blob",
          "size": 22.375,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tBINTRP.H \r\n\r\n\tTITLE   GWLIST Copied from BINTRP.MAC\r\n\r\n\t.RADIX\t10\r\n\r\n\t.XLIST\r\n\r\nFETOK=0\t\t\t\t;For FE extended tokens\r\nFDTOK=0\t\t\t\t;For FD tokens too.  (Must have\r\n\t\t\t\t;FETOK==1.)\r\n\t\t\t\t;tokens.\r\nINTDEX=0\t\t\t;For Intelledex version.\r\nNMPAGE=1\t\t\t;Number of text pages (for GW\r\n\t\t\t\t;Multi-page)\r\n\t\t\t\t;KPOS, etc.\r\nLNREAD=0\t\t\t;For LINE READ statement\r\nMELCO=0\t\t\t\t;Mitsubishi Electronics Co.\r\nSIRIUS=0\r\nMCI=0\r\nZENITH=0\t\t\t;ZENITH 8086\r\nTETRA=0\r\nCPM86=0\r\nHAL=0\r\nGENFLS=0\r\nPANDBL=0\r\nTSHIBA=0\r\nSGS=0\r\nALPS=0\r\nALPCPM=0\r\nGENWID=0\r\nNNECBS=0\r\nCAN8=0\r\nPC8A=0\r\n\r\n\tFN2SW=0\t\t\t;IBMTOK versions dispatch from IBMRES.MAC\r\n\tLABEL=PC8A\r\n\tHLPEDT=PC8A\r\n\r\nOKI=0\r\nBUBL=0\r\n\tNORNF=0\r\nIEESLV=0\r\nTRSHHC=0\r\nOLVPPC=0\r\nNECPPC=0\r\nUSA=0\t\t\t\t;For HHC-USA version\r\nEUROPE=0\t\t\t;For HHC-EUROPE version\r\n\r\n\t.LIST\r\n\r\n;Local Switches\r\n;\r\n\tLTRACE=ALPCPM\t\t;trace output selectable\r\n\tLABEL=PC8A\r\n\tHLPEDT=PC8A\r\n\tUCEMSG=NNECBS\t\t;Upper case error messages.\r\n\tOLD86=MELCO AND CPM86\t;For \"old\" 8086 error messages (prior\r\n\t\t\t\t;to alignment for IBM compatibility).\r\n\r\n\tOLDBLD=ALPCPM OR ALPS OR OKI OR HAL OR PC8A OR BUBL OR GW OR TSHIBA\r\n\r\n\tINCLUDE\tGIO86U\r\n\tINCLUDE\tMSDOSU\t\t;MSDOS constants\r\n\r\n\r\n\r\n\r\n\tEXTRN\tINIT:NEAR\r\n\r\n\r\n\r\n\tEXTRN\tSETGSB:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tONGSBF:WORD\r\nDSEG\tENDS\r\n\r\n\r\n\tBUFOFS=0\r\n\r\n\tBUFOFS=2\t\t;MUST CRUNCH INTO ERALIER PLACE FOR\r\n\t\t\t\t; SINGLE QUOTE\r\n\r\n\tKBFLEN=BUFLEN+(BUFLEN/4)\t;MAKE KRUNCH BUFFER SOMEWHAT\r\n\t\t\t\t; LARGER THAN SOURCE BUFFER (BUF)\r\n\r\n\r\n\r\n\r\n\tEXTRN\tNAME:NEAR\r\n\tEXTRN\tINLIN:NEAR,CRDO:NEAR,CRDONZ:NEAR,STRCMP:NEAR,PPSWRT:NEAR\r\n\r\n\tEXTRN\tOUTDO:NEAR\r\n\r\n\tEXTRN\tBLTU:NEAR,CLEARC:NEAR,GTMPRT:NEAR,ISLET:NEAR,ISLET2:NEAR\r\n\tEXTRN\tPTRGET:NEAR\r\n\tEXTRN\tQINLIN:NEAR,SCRTCH:NEAR,STKINI:NEAR,RUNC:NEAR,RESFIN:NEAR\r\n\tEXTRN\tPTRGT2:NEAR,STPEND:NEAR\r\n\r\n\tEXTRN\tSYNCHR:NEAR\r\n\r\n\tEXTRN\tSIGN:NEAR\r\n\r\n\tEXTRN\tPRGFIN:NEAR,FILIND:NEAR\r\n\r\n\tEXTRN\tFILINP:NEAR,INDSKC:NEAR\r\n\r\n\r\n\tEXTRN\tLRUN:NEAR\r\n\r\n\r\n\tEXTRN\tINXHRT:NEAR\r\n\tEXTRN\tZERO:NEAR,MOVE:NEAR,FOUT:NEAR,FIN:NEAR,PUSHF:NEAR\r\n\tEXTRN\tMOVFR:NEAR,MOVRF:NEAR,MOVRM:NEAR,INPRT:NEAR,LINPRT:NEAR\r\n\tEXTRN\tMOVFM:NEAR,MOVMF:NEAR\r\n\tEXTRN\tINRART:NEAR,NEG:NEAR\r\n\tEXTRN\tFREFAC:NEAR,FRETMS:NEAR,STRCPY:NEAR,GETSTK:NEAR\r\n\tEXTRN\tSTRLIT:NEAR,STRLT2:NEAR,STRLT3:NEAR,STRLTI:NEAR,STROUT:NEAR\r\n\tEXTRN\tSTRPRT:NEAR,STROUI:NEAR\r\n\tEXTRN\tGETSPA:NEAR,PUTNEW:NEAR,STOP:NEAR,OMERR:NEAR,REASON:NEAR\r\n\r\n\r\n\tEXTRN\tINSTR:NEAR\r\n\r\n\tEXTRN\tPRINUS:NEAR,PUTTMP:NEAR\r\n\r\n\tEXTRN\tFOUTH:NEAR,FOUTO:NEAR,STRO$:NEAR,STRH$:NEAR\r\n\r\n\r\n\tEXTRN\tSTRNG$:NEAR\r\n\tEXTRN\tTON:NEAR,TOFF:NEAR\r\n\tEXTRN\tSPACE$:NEAR\r\n\r\n\tEXTRN\tSIGNS:NEAR\r\n\r\n\r\n\r\n\r\n\tEXTRN\tUMULT:NEAR\r\n\r\n\tEXTRN\tSIGNC:NEAR,POPHRT:NEAR\r\n\r\n\tEXTRN\tFINLPT:NEAR\r\n\r\n\tEXTRN\tVMOVFA:NEAR,VMOVAF:NEAR,ISIGN:NEAR,VSIGN:NEAR,VDFACS:NEAR\r\n\tEXTRN\tVMOVMF:NEAR,VMOVFM:NEAR,FRCINT:NEAR,FRCDBL:NEAR,FRCSNG:NEAR\r\n\tEXTRN\tVNEG:NEAR,PUFOUT:NEAR,DCXBRT:NEAR,IADD:NEAR\r\n\tEXTRN\tFINDBL:NEAR\r\n\tEXTRN\tVMOVE:NEAR,VALINT:NEAR,VALSNG:NEAR,FRCSTR:NEAR,CHKSTR:NEAR\r\n\tEXTRN\tMAKINT:NEAR\r\n\tEXTRN\tMOVE1:NEAR\r\n\r\n\tEXTRN\tSCNSEM:NEAR\r\n\tEXTRN\tWHILE:NEAR,WEND:NEAR\r\n\tEXTRN\tCALLS:NEAR\r\n\tEXTRN\tPROCHK:NEAR\r\n\tEXTRN\tWRITE:NEAR\r\n;The following block of externals was added on Dec 19, 1982 when BINTRP was\r\n; Split up after the freeze of GW-BASIC Version 1.0\r\n; This Split-up was not reflected in the PS1:<BASIC>BINTRP.MAC source.\r\n; See Tom Corbett if you have any questions.\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tEXTRN\tMEMSIZ:WORD,FRETOP:WORD,VARTAB:WORD,STREND:WORD,TXTTAB:WORD\r\n\tEXTRN\tARYTAB:WORD\r\n\tEXTRN\tCURLIN:WORD,DOT:WORD,DATLIN:WORD,NLONLY:WORD,ERRLIN:WORD\r\n\tEXTRN\tERRTXT:WORD\r\n\tEXTRN\tMRGFLG:WORD,CHNFLG:WORD\r\n\tEXTRN\tSAVSTK:WORD,SAVTXT:WORD,OLDLIN:WORD,NXTLIN:WORD,OLDTXT:WORD\r\n\tEXTRN\tONELIN:WORD,ONEFLG:WORD\r\n\tEXTRN\tCNTOFL:WORD,TRCFLG:WORD,CONSAV:WORD,CONTXT:WORD,CONTYP:WORD\r\n\tEXTRN\tNUMCON:WORD,CONLO:WORD\r\n\tEXTRN\tAUTFLG:WORD,AUTLIN:WORD,AUTINC:WORD\r\n\tEXTRN\tKBUF:WORD,BUFMIN:WORD,BUF:WORD\r\n\tEXTRN\tPTRFIL:WORD,PTRFLG:WORD,DORES:WORD,VALTYP:WORD,FACLO:WORD\r\n\tEXTRN\tDFACLO:WORD,FAC:WORD\r\n\tEXTRN\tTEMP:WORD,TEMP2:WORD,TEMP3:WORD,TEMPA:WORD\r\n\tEXTRN\tDSCTMP:WORD,TEMPST:WORD\r\n\tEXTRN\tOPRTYP:WORD\r\n\tEXTRN\tSUBFLG:WORD,FVALSV:WORD,DEFTBL:WORD,FLGINP:WORD,FLGSCN:WORD\r\n\tEXTRN\tOVCSTR:WORD,INPPAS:WORD\r\n\tEXTRN\tUSRTAB:WORD,DONUM:WORD,ENDPRG:WORD,ENDFOR:WORD,DATPTR:WORD\r\n\tEXTRN\tFLGOVC:WORD\r\n\tEXTRN\tERRFLG:WORD,SAVSEG:WORD,PRMLN2:WORD,PRMSIZ:WORD,PARM2:WORD\r\n\tEXTRN\tPRMLEN:WORD,PRMSTK:WORD,PARM1:WORD\r\n\tEXTRN\tFUNACT:WORD,NOFUNS:WORD,OPTVAL:WORD,OPTFLG:WORD,RNDX:WORD\r\nDSEG\tENDS\r\n\r\n\tEXTRN\tINEG2:NEAR,FADD:NEAR\r\n\tEXTRN\t$OVMSG:NEAR,ERRTAB:NEAR,LSTERR:NEAR,DSKERR:NEAR,NONDSK:NEAR\r\n\tEXTRN\tREDDY:NEAR\r\n\tEXTRN\tERRSN:NEAR,ERRDV0:NEAR,ERRRE:NEAR,ERROV:NEAR,ERRMO:NEAR\r\n\tEXTRN\tERRTM:NEAR,ERRNF:NEAR\r\n\tEXTRN\tERRNR:NEAR,ERRLBO:NEAR,ERRDD:NEAR,ERRUF:NEAR,ERRFC:NEAR\r\n\tEXTRN\tERRIFN:NEAR,ERRFNO:NEAR,ERRDNA:NEAR,ERRFDR:NEAR,ERRRAD:NEAR\r\n\tEXTRN\tERRDFL:NEAR\r\n\tEXTRN\tERRIOE:NEAR,ERRBFM:NEAR,ERRFNF:NEAR,ERRBFN:NEAR,ERRIER:NEAR\r\n\tEXTRN\tERRRPE:NEAR\r\n\tEXTRN\tERRFAO:NEAR,ERRNMF:NEAR,ERRWH:NEAR,ERRBRN:NEAR,ERRFOV:NEAR\r\n\tEXTRN\tERRTMF:NEAR\r\n\tEXTRN\tERRFAE:NEAR,ERRUS:NEAR,ERRRG:NEAR,ERROD:NEAR,ERRFN:NEAR\r\n\tEXTRN\tERRUE1:NEAR\t;ERRUE+DSKERR-NONDSK\r\n\tEXTRN\tDSKER1:NEAR\t;DSKERR-NONDSK\r\n\r\n;The following externs are defined in GWMAIN.MAC\r\n;\r\n\tEXTRN\tCHRGTR:NEAR,READY:NEAR,STPRDY:NEAR,ISFLIO:NEAR,CONFC1:NEAR\r\n\tEXTRN\tDEPTR:NEAR\r\n\tEXTRN\tFINI:NEAR,FCERR:NEAR,FNDLIN:NEAR,SCNLIN:NEAR\r\n\tEXTRN\tOCTCON:NEAR,HEXCON:NEAR,DBLCON:NEAR,DBLCN1:NEAR\r\n\r\n;The following externs are defined in GWEVAL.MAC\r\n;\r\n\tEXTRN\tMAKUPL:NEAR,MAKUPS:NEAR,GETYPR:NEAR,OCTCNS:NEAR,DOCNVF:NEAR\r\n\tEXTRN\tISMID$:NEAR\r\n\tEXTRN\tFRMEVL:NEAR,FRMCHK:NEAR,GETINT:NEAR,GETBYT:NEAR,GETIN2:NEAR\r\n\tEXTRN\tSNGFLT:NEAR\r\n\r\n\r\n\r\n\tSUBTTL ROM VERSION INITALIZATION, AND CONSTANTS\r\n\r\n\r\n\r\n;\r\n; The reserved word tables are in another module.  Consequently\r\n; many things must be declared external.  All of these things\r\n; are in the code segement or are absolutes (like tokens).\r\n; I.e., they are not in the data segment.\r\n;\r\n\r\n\tEXTRN\tALPTAB:NEAR\r\n\tEXTRN\tEQULTK:NEAR\r\n\tEXTRN\tSTMDSP:NEAR\r\n\tEXTRN\tGREATK:NEAR\r\n\tEXTRN\tINSRTK:NEAR\r\n\tEXTRN\tLESSTK:NEAR,LSTOPK:NEAR\r\n\tEXTRN\tMIDTK:NEAR,MINUTK:NEAR\r\n\tEXTRN\tNMREL:NEAR,NOTTK:NEAR,NUMCMD:NEAR\r\n\tEXTRN\tONEFUN:NEAR\r\n\tEXTRN\tPOS:NEAR,PLUSTK:NEAR,PRINT:NEAR\r\n\tEXTRN\tRESLST:NEAR\r\n\tEXTRN\tSNGQTK:NEAR,SPCTAB:NEAR,SQRTK:NEAR,STEPTK:NEAR\r\n\tEXTRN\tTHENTK:NEAR\r\n\tEXTRN\tUSRTK:NEAR\r\n\tEXTRN\t$DATA:NEAR,$DATCO:NEAR,$DELETE:NEAR\r\n\tEXTRN\t$EDIT:NEAR,$ELSE:NEAR,$END:NEAR,$ERL:NEAR,$ERROR:NEAR\r\n\tEXTRN\t$FN:NEAR,$FOR:NEAR\r\n\tEXTRN\t$GOSUB:NEAR,$GOTO:NEAR\r\n\tEXTRN\t$IF:NEAR,$INKEY$:NEAR,$INPUT:NEAR\r\n\tEXTRN\t$LIST:NEAR,$LLIST:NEAR\r\n\tEXTRN\t$NEXT:NEAR\r\n\tEXTRN\t$POINT:NEAR,$PRINT:NEAR\r\n\tEXTRN\t$REM:NEAR,$REMCO:NEAR,$RENUM:NEAR,$RESTORE:NEAR,$RESUME:NEAR\r\n\tEXTRN\t$RETURN:NEAR,$RND:NEAR,$RUN:NEAR\r\n\tEXTRN\t$SCREEN:NEAR,$STOP:NEAR,$STRING$:NEAR\r\n\tEXTRN\t$THEN:NEAR,$TO:NEAR\r\n\tEXTRN\t$USR:NEAR\r\n\tEXTRN\t$VARPTR:NEAR\r\n\tEXTRN\t$WEND:NEAR,$WHILE:NEAR\r\n\r\n\tSUBTTL EXTENDED LIST, DELETE, LLIST\r\n\r\nPUBLIC\tLLIST\r\nLLIST:\r\n\tPUSH\tBX\r\n\tMOV\tBX,OFFSET 0-1\r\n\tMOV\tPTRFIL,BX\t;FDB pointer = LPT Pseudo FDB\r\n\tPOP\tBX\r\nPUBLIC\tLIST\r\nLIST:\r\n\r\n\tPOP\tCX\t\t;GET RID OF NEWSTT RETURN ADDR\r\n\tCALL\tSCNLIN\t\t;SCAN LINE RANGE\r\n\tPUSH\tCX\t\t;SAVE POINTER TO 1ST LINE\r\n\tCALL\tPROCHK\t\t;DONT EVEN LIST LINE #\r\n\tMOV\tBX,TEMP\t\t;Get Text pointer\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\r\n\tJZ\tSHORT LIST4\t;Brif LIST to CRT.\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44D\t; else must be ,\"dev:\"\r\n\tCALL\tNAMSCN\t\t;Crack File spec.\r\n\tEXTRN\tNAMSCN:NEAR,NULOPM:NEAR\r\n\tMOV\tAL,LOW OFFSET MD_SQO\t;OPEN FILE 0 FOR OUTPUT\r\n\tCALL\tNULOPM\r\nLIST4:\tMOV\tBX,65535\t;DONT ALLOW ^C TO CHANGE\r\n\tMOV\tCURLIN,BX\t;CONTINUE PARAMETERS\r\n\tPOP\tBX\t\t;GET POINTER TO LINE\r\n\tPOP\tDX\t\t;GET MAX LINE # OFF STACK\r\n\tMOV\tCL,BYTE PTR [BX]\t;[B,C]=THE LINK POINTING TO THE NEXT LINE\r\n\tINC\tBX\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tINC\tBX\r\n\tMOV\tAL,CH\t\t;SEE IF END OF CHAIN\r\n\tOR\tAL,CL\r\n\tJNZ\tSHORT ??L000\r\n\tJMP\tREADY\t\t;LAST LINE, STOP.  \r\n??L000:\r\nEXTRN\tPOLKEY:NEAR\r\n\tCALL\tPOLKEY\t\t;check CTL C, queue typeahead\r\n\tPUSH\tCX\t\t;SAVE LINK\r\n\tMOV\tCL,BYTE PTR [BX]\t;PUSH THE LINE #\r\n\tINC\tBX\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tINC\tBX\r\n\tPUSH\tCX\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;GET LINE # INTO [H,L]\r\n\tXCHG\tBX,DX\t\t;GET MAX LINE IN [H,L]\r\n\tCMP\tBX,DX\t\t;PAST LAST LINE IN RANGE?\r\n\tPOP\tCX\t\t;TEXT POINTER TO [B,C]\r\n\tJAE\tSHORT ??L001\r\n\tJMP\tSTPRDY\t\t;IF PAST, THEN DONE LISTING.\r\n??L001:\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE MAX ON BOTTOM OF STACK\r\n\tPUSH\tBX\t\t;SAVE LINK ON TOP\r\n\tPUSH\tCX\t\t;SAVE TEXT POINTER BACK\r\n\tXCHG\tBX,DX\t\t;GET LINE # IN [H,L]\r\n\tMOV\tDOT,BX\t\t;SAVE FOR LATER EDIT OR LIST\r\n\t\t\t\t;AND WE WANT [H,L] ON THE STACK\r\n\tCALL\tLINPRT\t\t;PRINT AS INTEGER WITHOUT LEADING SPACE\r\n\tPOP\tBX\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET BYTE FROM LINE\r\n\tCMP\tAL,LOW 9\t;IS IT A TAB?\r\n\tJZ\tSHORT NOSPAL\t;THEN DONT PRINT SPACE\r\n\tMOV\tAL,LOW \" \"\r\n\tCALL\tOUTDO\t\t;PRINT A SPACE AFTER THE LINE #\r\nNOSPAL:\tCALL\tBUFLIN\t\t;UNPACK THE LINE INTO BUF\r\n\tMOV\tBX,OFFSET BUF\t;POINT AT THE START OF THE UNPACKED CHARACTERS\r\n\tCALL\tLISPRT\t\t;PRINT THE LINE\r\n\tCALL\tCRDO\t\t;PRINT CRLF\r\n\tJMP\tSHORT LIST4\t;GO BACK FOR NEXT LINE\r\n\r\nPUBLIC\tLISPRT\r\nLISPRT:\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tCMP\tAL,LOW 10D\r\n\tJNZ\tSHORT ??L002\r\n\tCALL\tLISEOL\t\t;erase to end-of-line after LF and 0\r\n??L002:\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT ??L003\r\n\tCALL\tLISEOL\r\n??L003:\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF =0 THEN END OF LINE\r\n\tEXTRN\tOUTCH1:NEAR\r\n\tCALL\tOUTCH1\t\t;OUTPUT CHAR AND CHECK FOR LF\r\n\tINC\tBX\t\t;INCR POINTER\r\n\tJMP\tSHORT LISPRT\t;PRINT NEXT CHAR\r\n\r\n;Routine to output sequence to Clear to end of line if current device\r\n; is Standard Output (CRT)\r\n; Exit - All registers preserved.\r\n;\r\nLISEOL:\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\r\n\tCALL\tISFLIO\r\n\tJZ\tSHORT ??L004\r\n\tJMP\tLISELX\t\t;return if listing to a file\r\n??L004:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tF_EDIT:WORD\r\nDSEG\tENDS\r\n\tMOV\tAL,BYTE PTR F_EDIT\t;Save current edit mode\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\r\n\tMOV\tAL,LOW 5\t;05=erase to end-of-line for non-IBMLIK\r\n\tMOV\tBYTE PTR F_EDIT,AL\t;Enter edit mode(05 is control function)\r\n\tCALL\tOUTDO\t\t;output 05 to current device\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\r\n\tMOV\tBYTE PTR F_EDIT,AL\t;Restore edit mode\r\nLISELX:\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\r\n\tRET\t\r\n\r\nPUBLIC\tBUFLIN\r\nBUFLIN:\tMOV\tCX,OFFSET BUF\t;GET START OF TEXT BUFFER\r\n\tMOV\tDH,LOW OFFSET BUFLEN\t;GET ITS LENGTH INTO [D]\r\n\tXOR\tAL,AL\t\t;SET MODE OF DECRUNCH\r\n\tMOV\tBYTE PTR DORES,AL\t;BIT0 IS QUOTE BIT1 IS DATA BIT2 IS REM\r\n\tXOR\tAL,AL\t\t;SET ON SPECIAL CHAR FOR SPACE INSERTION\r\n\tMOV\tBYTE PTR TEMPA,AL\r\n\tCALL\tPROCHK\t\t;ONLY PROCEED IF OK\r\n\tJMP\tSHORT PLOOP2\t;START HERE\r\n\r\nPLOOP:\tINC\tCX\t\t;INCREMENT DEPOSIT PTR.\r\n\tINC\tBX\t\t;ADVANCE TEXT PTR\r\n\tDEC\tDH\t\t;BUMP DOWN COUNT\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF BUFFER FULL, RETURN\r\nPUBLIC\tPLOOP2\r\nPLOOP2:\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR FROM BUF\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tMOV\tDI,CX\r\n\tSTOSB\t\t\t;SAVE THIS CHAR\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF END OF SOURCE BUFFER, ALL DONE.\r\n\tCMP\tAL,LOW OFFSET OCTCON\t;IS IT SMALLER THAN SMALLEST EMBEDDED CONSTANT?\r\n\tJB\tSHORT NTEMBL\t;YES, DONT TREAT AS ONE\r\n\tCMP\tAL,LOW OFFSET DBLCN1\t;IS IT EMBEDED CONSTANT?\r\n\tMOV\tDL,AL\t\t;SAVE CHAR IN [E]\r\n\tJB\tSHORT PRTVAR\t;PRINT LEADING SPACE IF NESC.\r\n\tCMP\tAL,LOW 34D\t;IS IT A QUOTATION\r\n\tJNZ\tSHORT BFCHKC\t;IF NOT CHECK FOR COLON\r\n\tMOV\tAL,BYTE PTR DORES\t;COMPLEMENT THE QUOTE BIT\r\n\tXOR\tAL,LOW 1\r\n\tMOV\tBYTE PTR DORES,AL\r\n\tMOV\tAL,LOW 34D\t;RESTORE THE CHARACTER\r\nBFCHKC:\tCMP\tAL,LOW \":\"\t;IS IT A COLON ENDING DATA?\r\n\tJNZ\tSHORT NTEMBL\r\n\tMOV\tAL,BYTE PTR DORES\t;DON'T END IF IN QUOTE\r\n\tRCR\tAL,1\r\n\tJB\tSHORT QTCOLN\r\n\tRCL\tAL,1\r\n\tAND\tAL,LOW 253D\t;TURN OFF BIT1 (DATA BIT)\r\n\tMOV\tBYTE PTR DORES,AL\r\nQTCOLN:\tMOV\tAL,LOW \":\"\r\nNTEMBL:\tOR\tAL,AL\t\t;SET CC'S\r\n\tJNS\tSHORT ??L005\r\n\tJMP\tPLOOPR\t\t;RESERVED WORD OF SOME KIND\r\n??L005:\r\n\tMOV\tDL,AL\t\t;SAVE CHAR IN [E]\r\n\tCMP\tAL,LOW \".\"\t;DOT IS PART OF VAR NAME\r\n\tJZ\tSHORT PRTVAR\r\n\tCALL\tTSTANM\t\t;IS CHAR ALPHANUMERIC\r\n\tJAE\tSHORT PRTVAR\t;ALPHANUMERIC\r\n\tXOR\tAL,AL\t\t;MAKE SPECIAL\r\n\tJMP\tSHORT PLOOPH\r\nPRTVAR:\tMOV\tAL,BYTE PTR TEMPA\t;WHAT DID WE DO LAST?\r\n\tOR\tAL,AL\t\t;SET CONDITION CODES\r\n\tJZ\tSHORT PLOOPG\t;SPECIAL, NEVER INSERT SPACE\r\n\tINC\tAL\t\t;IN RESERVED WORD?\r\n\tJNZ\tSHORT PLOOPG\t;NO\r\n\tMOV\tAL,LOW \" \"\t;PUT OUT SPACE BEFORE RESWORD\r\n\tMOV\tDI,CX\r\n\tSTOSB\t\t\t;STORE IN BUFFER\r\n\tINC\tCX\t\t;INCRMENT POINTER INTO BUFFER\r\n\tDEC\tDH\t\t;SPACE LEFT?\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;NO, DONE\r\nPLOOPG:\tMOV\tAL,LOW 1\t;STORE FLAG SAYING IN VAR\r\nPLOOPH:\tMOV\tBYTE PTR TEMPA,AL\r\n\tMOV\tAL,DL\t\t;GET BACK CHAR WE HAD\r\n\tCMP\tAL,LOW OFFSET OCTCON\t;IS IT SMALLER THAN SMALLEST EMBEDDED CONSTANT?\r\n\tJB\tSHORT PLOOPZ\t;YES, DONT TREAT AS ONE\r\n\tCMP\tAL,LOW OFFSET DBLCN1\t;IS IT EMBEDED CONSTANT?\r\n\tJAE\tSHORT ??L006\r\n\tJMP\tNUMLIN\t\t;YES, UNPACK IT\r\n??L006:\r\nPLOOPZ:\tMOV\tDI,CX\r\n\tSTOSB\t\t\t;MAKE SURE BYTE STORED AFTER SPACE\r\n\tJMP\tPLOOP\t\t;STORE IN BUFFER\r\nPLOOPR:\r\n\tMOV\tAL,BYTE PTR DORES\t;SEEWHAT OUR UNCRUNCH MODE IS\r\n\tRCR\tAL,1\t\t;THE LSB IS THE QUOTE BIT\r\n\tJB\tSHORT GPLOOP\r\n\tRCR\tAL,1\t\t;GET THE REM BIT\r\n\tRCR\tAL,1\t\t;AND SEE IF SET\r\n\tJAE\tSHORT CHKDRS\t;IF NOT JUST CHECK DATA BIT\r\n\tMOV\tAL,BYTE PTR [BX]\t;MUST SEE IF ITS SNGQTK\r\n\tCMP\tAL,LOW OFFSET SNGQTK\t;AND PRECEDED BY \":REM\"\r\n\tPUSH\tBX\r\n\tPUSH\tCX\t\t;SAVE BUFFER POINTER\r\n\tMOV\tBX,OFFSET NOSNGQ\t;PLACE TO RETURN ON FAILURE\r\n\tPUSH\tBX\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tDEC\tCX\r\n\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\r\n\tCMP\tAL,LOW \"M\"\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tDEC\tCX\r\n\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\r\n\tCMP\tAL,LOW \"E\"\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tDEC\tCX\r\n\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\r\n\tCMP\tAL,LOW \"R\"\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tDEC\tCX\r\n\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\r\n\tCMP\tAL,LOW \":\"\r\n\tJZ\tSHORT $+3\r\n\tRET\r\n\tPOP\tAX\t\t;GET RID OF RETURN ON FAIL ADDRESS\r\n\tPOP\tAX\t\t;GET RID OF BAD BUFFER POINTER\r\n\tPOP\tBX\t\t;GET BACK POINTER INTO LINE\r\n\tINC\tDH\t\t;UPDATE CHAR COUNT\r\n\tINC\tDH\r\n\tINC\tDH\r\n\tINC\tDH\r\n\tJMP\tSHORT RESEXP\r\n\r\nNOSNGQ:\tPOP\tCX\t\t;GET BACK THE BUFFERPOINTER\r\n\tPOP\tBX\t\t;GET BACK SOURCE LINE POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET BACK THE CHARACTER\r\nGPLOOP:\tJMP\tPLOOP\r\n\r\nDATSET:\tMOV\tAL,BYTE PTR DORES\t;BIT INDICATING INSIDE DATA\r\n\tOR\tAL,LOW 2\t;IS BIT1\r\nSETDRS:\tMOV\tBYTE PTR DORES,AL\r\n\tXOR\tAL,AL\r\n\tRET\t\r\n\r\nREMSET:\tMOV\tAL,BYTE PTR DORES\r\n\tOR\tAL,LOW 4\r\n\tJMP\tSHORT SETDRS\r\n\r\nCHKDRS:\tRCL\tAL,1\t\t;GET DATA BIT INTO CARRY\r\n\tJB\tSHORT GPLOOP\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET BACK THE CHARACTER\r\n\tCMP\tAL,LOW OFFSET $DATA\t;NEED TO SET A BIT\r\n\tJNZ\tSHORT ??L007\r\n\tCALL\tDATSET\r\n??L007:\r\n\tCMP\tAL,LOW OFFSET $REM\r\n\tJNZ\tSHORT ??L008\r\n\tCALL\tREMSET\r\n??L008:\r\nRESEXP:\tMOV\tAL,BYTE PTR [BX]\r\n\r\n\tINC\tAL\t\t;SET ZERO IF FN TOKEN\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR BACK\r\n\tJNZ\tSHORT NTFNTK\t;NOT FUNCTION JUST TREAT NORMALLY\r\n\tINC\tBX\t\t;BUMP POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR\r\n\tAND\tAL,LOW 177O\t;TURN OFF HIGH BIT\r\nNTFNTK:\tINC\tBX\t\t;ADVANCE TO POINT AFTER\r\nNTQTTK:\tCMP\tAL,LOW OFFSET $ELSE\t;ELSE?\r\n\tJNZ\tSHORT NOTELS\r\n\tDEC\tCX\r\n\tINC\tDH\r\nNOTELS:\r\n\tCMP\tAL,LOW OFFSET $WHILE\t;MIGHT HAVE AN EXTRA \"+\" IN WHILE FORMULA\r\n\tJNZ\tSHORT BFNTWH\t;SO SKIP OVER IT IF ITS THERE\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHARACTER TO SEE IF ITS PLUSTK\r\n\tINC\tBX\t\t;ASSUME IS PLUSTK\r\n\tCMP\tAL,LOW OFFSET PLUSTK\t;MIGHT NOT BE PLUS IF BINARY SAVED IN\r\n\tMOV\tAL,LOW OFFSET $WHILE\t;RESTORE TOKEN VALUE\r\n\tJZ\tSHORT BFNTWH\t;VERSION OF BASIC BEFORE CRUNCH CHANGED\r\n\tDEC\tBX\t\t;MOVE POINTER BACK\r\nBFNTWH:\r\n\r\n\tPUSH\tBX\t\t;SAVE TEXT PTR.\r\n\tPUSH\tCX\t\t;SAVE DEPOSIT PTR.\r\n\tPUSH\tDX\t\t;SAVE CHAR COUNT.\r\n\tEXTRN\tLISTX:NEAR\r\n\tCALL\tLISTX\t\t;Handle extended reserved words.\r\n\tMOV\tBX,OFFSET RESLST-1\t;GET PTR TO START OF RESERVED WORD LIST\r\n\tMOV\tCH,AL\t\t;SAVE THIS CHAR IN [B]\r\n\tMOV\tCL,LOW OFFSET \"A\"-1\t;INIT LEADING CHAR VALUE\r\nRESSR3:\tINC\tCL\t\t;BUMP LEADING CHAR VALUE.\r\nRESSR1:\tINC\tBX\t\t;BUMP POINTER INTO RESLST\r\nRESSRC:\tMOV\tDH,BH\t\t;SAVE PTR TO START OF THIS RESWRD\r\n\tMOV\tDL,BL\r\nRESSR2:\r\n\tINS86\t56\t\t;FETCH FROM CODE SEGMENT\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR FROM RESLST\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJZ\tSHORT RESSR3\t;IF END OF THIS CHARS TABLE, GO BACK & BUMP C\r\n\tLAHF\r\n\tINC\tBX\t\t;BUMP SOURCE PTR\r\n\tSAHF\r\n\tJS\tSHORT ??L009\r\n\tJMP\tRESSR2\t\t;IF NOT END OF THIS RESWRD, THEN KEEP LOOKING\r\n??L009:\r\n\tINS86\t56\t\t;FETCH FROM CODE SEGMENT\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET PTR TO RESERVED WORD VALUE\r\n\tCMP\tAL,CH\t\t;SAME AS THE ONE WE SEARCH FOR?\r\n\tJNZ\tSHORT RESSR1\t;NO, KEEP LOOKING.\r\n\tXCHG\tBX,DX\t\t;SAVE FOUND PTR IN [H,L]\r\n\tCMP\tAL,LOW OFFSET $USR\t;USR FUNCTION TOKEN?\r\n\tJZ\tSHORT NOISPA\t;DONT INSERT SPACE\r\n\tCMP\tAL,LOW OFFSET $FN\t;IS IT FUNCTION TOKEN?\r\nNOISPA:\r\n\tMOV\tAL,CL\t\t;GET LEADING CHAR\r\n\tPOP\tDX\t\t;RESTORE LINE CHAR COUNT\r\n\tPOP\tCX\t\t;RESTORE DEPOSIT PTR\r\n\tMOV\tDL,AL\t\t;SAVE LEADING CHAR\r\n\tJNZ\tSHORT NTFNEX\t;NOT \"FN\" EXPANSION\r\n\tMOV\tAL,BYTE PTR TEMPA\t;SET CC'S ON TEMPA\r\n\tOR\tAL,AL\r\n\tMOV\tAL,LOW 0\t;CLEAR RESWRD FLAG - MARK AS SPECIAL\r\n\tMOV\tBYTE PTR TEMPA,AL\t;SET FLAG\r\n\tJMP\tSHORT MORLNZ\t;DO EXPANSION\r\nNTFNEX:\r\n\tCMP\tAL,LOW OFFSET \"Z\"+1\t;WAS IT A SPECIAL CHAR?\r\n\tJNZ\tSHORT NTSPCH\t;NON-SPECIAL CHAR\r\n\tXOR\tAL,AL\t\t;SET NON-SPECIAL\r\n\tMOV\tBYTE PTR TEMPA,AL\r\n\tJMP\tSHORT MORPUR\t;PRINT IT\r\nNTSPCH:\tMOV\tAL,BYTE PTR TEMPA\t;WHAT DID WE DO LAST?\r\n\tOR\tAL,AL\t\t;SPECIAL?\r\n\tMOV\tAL,LOW 255\t;FLAG IN RESERVED WORD\r\n\tMOV\tBYTE PTR TEMPA,AL\t;CLEAR FLAG\r\nMORLNZ:\tJZ\tSHORT MORLN0\t;GET CHAR AND PROCEED\r\n\tMOV\tAL,LOW \" \"\t;PUT SPACE IN BUFFER\r\n\tMOV\tDI,CX\r\n\tSTOSB\r\n\tINC\tCX\r\n\tDEC\tDH\t\t;ANY SPACE LEFT IN BUFFER\r\n\tJNZ\tSHORT ??L010\r\n\tJMP\tPPSWRT\t\t;NO, RETURN\r\n??L010:\r\nMORLN0:\tMOV\tAL,DL\r\n\tJMP\tSHORT MORLN1\t;CONTINUE\r\nMORPUR:\r\n\tINS86\t56\t\t;FETCH FROM CODE SEGMENT\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET BYTE FROM RESWRD\r\n\tINC\tBX\t\t;BUMP POINTER\r\nMORLNP:\tMOV\tDL,AL\t\t;SAVE CHAR\r\nMORLN1:\tAND\tAL,LOW 177O\t;AND OFF HIGH ORDER BIT FOR DISK & EDIT\r\n\tMOV\tDI,CX\r\n\tSTOSB\t\t\t;STORE THIS CHAR\r\n\tINC\tCX\t\t;BUMP PTR\r\n\tDEC\tDH\t\t;BUMP DOWN REMAINING CHAR COUNT\r\n\tJNZ\tSHORT ??L011\r\n\tJMP\tPPSWRT\t\t;IF END OF LINE, JUST RETURN\r\n??L011:\r\n\tOR\tAL,DL\t\t;SET CC'S\r\n\tJS\tSHORT ??L012\r\n\tJMP\tMORPUR\t\t;END OF RESWRD?\r\n??L012:\r\n\tCMP\tAL,LOW OFFSET \"(\"+128\t;SPC( OR TAB( ?\r\n\tJNZ\tSHORT NTSPCT\t;NO\r\n\tXOR\tAL,AL\t\t;CLEAR FLAG\r\n\tMOV\tBYTE PTR TEMPA,AL\t;TO INSERT SPACE AFTERWARDS\r\nNTSPCT:\r\n\tPOP\tBX\t\t;RESTORE SOURCE PTR.\r\n\tJMP\tPLOOP2\t\t;GET NEXT CHAR FROM LINE\r\nPUBLIC\tTSTANM\r\nTSTANM:\tCALL\tISLET2\t\t;LETTER?\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;YES\r\n\tCMP\tAL,LOW \"0\"\t;DIGIT?\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;TOO SMALL\r\n\tCMP\tAL,LOW OFFSET \"9\"+1\t;LAST DIGIT\r\n\tCMC\t\t\t;MAKE CARRY RIGHT\r\n\tRET\t\t\t;NO CARRY=DIGIT\r\nNUMLIN:\tDEC\tBX\t\t;MOVE POINTER BACK AS CHRGET INX'S\r\n\tCALL\tCHRGTR\t\t;SCAN THE CONSTANT\r\n\tPUSH\tDX\t\t;SAVE CHAR COUNT\r\n\tPUSH\tCX\t\t;SAVE DEPOSIT PTR\r\n\tPUSH\tAX\t\t;SAVE CONSTANT TYPE.\r\n\tCALL\tCONFC1\t\t;MOVE CONSTANT INTO FAC\r\n\tPOP\tAX\t\t;RESTORE CONSTANT TYPE\r\n\tMOV\tCX,OFFSET CONLIN\t;PUT RETURN ADDR ON STACK\r\n\tPUSH\tCX\t\t;SAVE IT\r\n\tCMP\tAL,LOW OFFSET OCTCON\t;OCTAL CONSTANT?\r\n\tJNZ\tSHORT ??L013\r\n\tJMP\tFOUTO\t\t;PRINT IT\r\n??L013:\r\n\tCMP\tAL,LOW OFFSET HEXCON\t;HEX CONSTANT?\r\n\tJNZ\tSHORT ??L014\r\n\tJMP\tFOUTH\t\t;PRINT IN HEX\r\n??L014:\r\n\tMOV\tBX,CONLO\t;GET LINE # VALUE IF ONE.\r\n\tJMP\tFOUT\t\t;PRINT REMAINING POSSIBILITIES.\r\nCONLIN:\tPOP\tCX\t\t;RESTORE DEPOSIT PTR.\r\n\tPOP\tDX\t\t;RESTORE CHAR COUNT\r\n\tMOV\tAL,BYTE PTR CONSAV\t;GET SAVED CONSTANT TOKEN\r\n\tMOV\tDL,LOW \"O\"\t;ASSUME OCTAL CONSTANT\r\n\tCMP\tAL,LOW OFFSET OCTCON\t;OCTAL CONSTANT?\r\n\tJZ\tSHORT SAVBAS\t;YES, PRINT IT\r\n\tCMP\tAL,LOW OFFSET HEXCON\t;HEX CONSTANT?\r\n\tMOV\tDL,LOW \"H\"\t;ASSUME SO.\r\n\tJNZ\tSHORT NUMSLN\t;NOT BASE CONSTANT\r\nSAVBAS:\r\n\tMOV\tAL,LOW \"&\"\t;PRINT LEADING BASE INDICATOR\r\n\tMOV\tDI,CX\r\n\tSTOSB\t\t\t;SAVE IT\r\n\tINC\tCX\t\t;BUMP PTR\r\n\tDEC\tDH\t\t;BUMP DOWN CHAR COUNT\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;RETURN IF END OF BUFFER\r\n\tMOV\tAL,DL\t\t;GET BASE CHAR\r\n\tMOV\tDI,CX\r\n\tSTOSB\t\t\t;SAVE IT\r\n\tINC\tCX\t\t;BUMP PTR\r\n\tDEC\tDH\t\t;BUMP DOWN BASE COUNT\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;END OF BUFFER, DONE\r\nNUMSLN:\r\n\tMOV\tAL,BYTE PTR CONTYP\t;GET TYPE OF CONSTANT WE ARE\r\n\tCMP\tAL,LOW 4\t;IS IT SINGLE OR DOUBLE PREC?\r\n\tMOV\tDL,LOW 0\t;NO, NEVER PRINT TRAILING TYPE INDICATOR\r\n\tJB\tSHORT TYPSET\r\n\tMOV\tDL,LOW \"!\"\t;ASSUME SINGLE PREC.\r\n\tJZ\tSHORT TYPSET\t;IS CONTYP=4, WAS SINGLE\r\n\tMOV\tDL,LOW \"#\"\t;DOUBLE PREC INDICATOR\r\nTYPSET:\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET LEADING CHAR\r\n\tCMP\tAL,LOW \" \"\t;LEADING SPACE\r\n\tJNZ\tSHORT ??L015\r\n\tCALL\tINXHRT\t\t;GO BY IT\r\n??L015:\r\nNUMSL2:\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR FROM NUMBER BUFFER\r\n\tINC\tBX\t\t;BUMP POINTER\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJZ\tSHORT NUMDN\t;IF ZERO, ALL DONE.\r\n\tMOV\tDI,CX\r\n\tSTOSB\t\t\t;SAVE CHAR IN BUF.\r\n\tINC\tCX\t\t;BUMP PTR\r\n\tDEC\tDH\t\t;SEE IF END OF BUFFER\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF END OF BUFFER, RETURN\r\n\tMOV\tAL,BYTE PTR CONTYP\t;GET TYPE OF CONSTANT TO BE PRINTED\r\n\tCMP\tAL,LOW 4\t;TEST FOR SINGLE OR DOUBLE PRECISION\r\n\tJB\tSHORT NUMSL2\t;NO, WAS INTEGER\r\n\tLAHF\r\n\tDEC\tCX\t\t;PICK UP SAVED CHAR\r\n\tSAHF\r\n\tMOV\tSI,CX\r\n\tMOV\tAL,[SI]\t\t;EASIER THAN PUSHING ON STACK\r\n\tLAHF\r\n\tINC\tCX\t\t;RESTORE TO POINT WHERE IT SHOULD\r\n\tSAHF\r\n\tJNZ\tSHORT DBLSCN\t;IF DOUBLE, DONT TEST FOR EMBEDED \".\"\r\n\tCMP\tAL,LOW \".\"\t;TEST FOR FRACTION\r\n\tJZ\tSHORT ZERE\t;IF SINGLE & EMBEDED ., THEN DONT PRINT !\r\nDBLSCN:\tCMP\tAL,LOW \"D\"\t;DOUBLE PREC. EXPONENT?\r\n\tJZ\tSHORT ZERE\t;YES, MARK NO VALUE TYPE INDICATOR NESC.\r\n\tCMP\tAL,LOW \"E\"\t;SINGLE PREC. EXPONENT?\r\n\tJNZ\tSHORT NUMSL2\t;NO, PROCEED\r\nZERE:\tMOV\tDL,LOW 0\t;MARK NO PRINTING OF TYPE INDICATOR\r\n\tJMP\tSHORT NUMSL2\t;KEEP MOVING NUMBER CHARS INTO BUF\r\n\r\nNUMDN:\r\n\tMOV\tAL,DL\t\t;GET FLAG TO INDICATE WHETHER TO INSERT\r\n\tOR\tAL,AL\t\t;A \"D\" AFTER DOUBLE PREC. #\r\n\tJZ\tSHORT NOD\t;NO, DONT INSERT IT\r\n\tMOV\tDI,CX\r\n\tSTOSB\t\t\t;SAVE IN BUFFER\r\n\tINC\tCX\t\t;BUMP POINTER\r\n\tDEC\tDH\t\t;DECRMENT COUNT OF CHARS LEFT IN BUFFER\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;=0, MUST TRUNCATE LIST OF THIS LINE.\r\nNOD:\r\n\tMOV\tBX,CONTXT\t;GET BACK TEXT POINTER AFTER CONSTANT\r\n\tJMP\tPLOOP2\t\t;GET NEXT CHAR\r\n\r\n\r\n;\r\n; THE FOLLOWING CODE IS FOR THE DELETE RANGE\r\n; COMMAND. BEFORE THE LINES ARE DELETED, 'OK'\r\n; IS TYPED.\r\n;\r\nPUBLIC\tDELETE\r\nDELETE:\r\n\tCALL\tSCNLIN\t\t;SCAN LINE RANGE\r\n\tPUSH\tCX\r\n\tCALL\tDEPTR\t\t;CHANGE POINTERS BACK TO NUMBERS\r\n\tPOP\tCX\r\n\tPOP\tDX\t\t;POP MAX LINE OFF STACK\r\n\tPUSH\tCX\t\t;SAVE POINTER TO START OF DELETION\r\n\t\t\t\t;FOR USE BY CHEAD AFTER FINI\r\n\tPUSH\tCX\t\t;SAVE POINTER TO START OF 1ST LINE\r\n\tCALL\tFNDLIN\t\t;FIND THE LAST LINE\r\n\tJAE\tSHORT FCERRG\t;MUST HAVE A MATCH ON THE UPPER BOUND\r\n\tMOV\tDH,BH\t\t;[D,E]=POINTER AT THE START OF THE LINE\r\n\tMOV\tDL,BL\t\t;BEYOND THE LAST LINE IN THE RANGE\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE THE POINTER TO THE NEXT LINE\r\n\tPUSH\tBX\t\t;SAVE THE POINTER TO THE START OF\r\n\t\t\t\t;THE FIRST LINE IN THE RANGE\r\n\tCMP\tBX,DX\t\t;MAKE SURE THE START COMES BEFORE THE END\r\nFCERRG:\tJNAE\tSHORT ??L016\r\n\tJMP\tFCERR\t\t;IF NOT, \"ILLEGAL FUNCTION CALL\"\r\n??L016:\r\n\t\t\t\t;DELETE must now be at EOL\r\n\tEXTRN\tEOSCHK:NEAR\r\n\tMOV\tBX,TEMP\t\t;Get text pointer\r\n\tCALL\tEOSCHK\t\t;Check for end of statement\r\n\tMOV\tBX,OFFSET REDDY\t;PRINT \"OK\" PREMATURELY\r\n\tCALL\tSTROUT\r\n\tPOP\tCX\t\t;GET POINTER TO FIRST IN [B,C]\r\n\tMOV\tBX,OFFSET FINI\t;GO BACK TO FINI WHEN DONE\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;[H,L]=POINTER TO THE NEXT LINE\r\n; ERASE A LINE FROM MEMORY\r\n; [B,C]=START OF LINE BEING DELETED\r\n; [H,L]=START OF NEXT LINE\r\n;\r\nPUBLIC\tDEL\r\nDEL:\tXCHG\tBX,DX\t\t;[D,E] NOW HAVE THE POINTER TO THE LINE\r\n\t\t\t\t;BEYOND THIS ONE\r\n\tMOV\tBX,VARTAB\t;COMPACTIFYING TO VARTAB\r\nMLOOP:\tMOV\tSI,DX\r\n\tMOV\tAL,[SI]\r\n\tMOV\tDI,CX\r\n\tSTOSB\t\t\t;SHOVING DOWN TO ELIMINATE A LINE\r\n\tINC\tCX\r\n\tINC\tDX\r\n\tCMP\tBX,DX\t\t;DONE COMPACTIFYING?\r\n\tJNZ\tSHORT MLOOP\t;NO\r\n\tMOV\tBX,CX\r\n;Clear SCALARS and ARRAYS incase we are replacing line which may force\r\n; garbage collection in BLTU\r\n\tMOV\tVARTAB,BX\r\n\tMOV\tARYTAB,BX\r\n\tMOV\tSTREND,BX\r\n\tRET\t\r\n\tPAGE\t\r\n\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GWMAIN.ASM",
          "type": "blob",
          "size": 106.25,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX\t8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG'\r\n\tASSUME\tCS:CSEG\r\n\r\nINCLUDE BINTRP.H\r\n\r\n\tTITLE\tGWMAIN Copied from BINTRP.MAC\r\n\r\n\t.RADIX\t10\r\n\r\nCOMMENT *\r\n\r\n--------- ---- -- ---- ----- --- ---- -----\r\nCOPYRIGHT 1975 BY BILL GATES AND PAUL ALLEN\r\n--------- ---- -- ---- ----- --- ---- -----\r\n\r\nORIGINALLY WRITTEN ON THE PDP-10 FROM\r\nFEBRUARY 9 TO  APRIL 9 1975\r\n\r\nBILL GATES WROTE A LOT OF STUFF.\r\nPAUL ALLEN WROTE A LOT OF OTHER STUFF AND FAST CODE.\r\nMONTE DAVIDOFF WROTE THE MATH PACKAGE (F4I.MAC).\r\n\r\n*\r\n\r\n\t.XLIST\r\n\r\nFETOK=0\t\t\t;For FE extended tokens\r\nFDTOK=0\t\t\t;For FD tokens too.  (Must have\r\n\t\t\t\t;FETOK==1.)\r\n\t\t\t\t;tokens.\r\nINTDEX=0\t\t\t;For Intelledex version.\r\nNMPAGE=1\t\t\t;Number of text pages (for GW\r\n\t\t\t\t;Multi-page)\r\n\t\t\t\t;KPOS, etc.\r\nLNREAD=0\t\t\t;For LINE READ statement\r\nMELCO=0\t\t\t;Mitsubishi Electronics Co.\r\nSIRIUS=0\r\nMCI=0\r\nZENITH=0\t\t\t;ZENITH 8086\r\nTETRA=0\r\nCPM86=0\r\nHAL=0\r\nGENFLS=0\r\nPANDBL=0\r\nTSHIBA=0\r\nSGS=0\r\nALPS=0\r\nALPCPM=0\r\nGENWID=0\r\nNNECBS=0\r\nCAN8=0\r\nPC8A=0\r\n\r\n\tFN2SW=0\t\t;IBMTOK versions dispatch from IBMRES.MAC\r\n\tLABEL=PC8A\r\n\tHLPEDT=PC8A\r\n\r\nOKI=0\r\nBUBL=0\r\n\tNORNF=0\r\nIEESLV=0\r\nTRSHHC=0\r\nOLVPPC=0\r\nNECPPC=0\r\nUSA=0\t\t\t\t;For HHC-USA version\r\nEUROPE=0\t\t\t;For HHC-EUROPE version\r\n\r\n\t.LIST\r\n\r\n;Local Switches\r\n;\r\n\tLTRACE=ALPCPM\t\t;trace output selectable\r\n\tLABEL=PC8A\r\n\tHLPEDT=PC8A\r\n\tUCEMSG=NNECBS\t\t;Upper case error messages.\r\n\tOLD86=MELCO AND CPM86\t;For \"old\" 8086 error messages (prior\r\n\t\t\t\t;to alignment for IBM compatibility).\r\n\r\n\tOLDBLD=ALPCPM OR ALPS OR OKI OR HAL OR PC8A OR BUBL OR GW OR TSHIBA\r\n\r\n\tINCLUDE GIO86U\r\n\tINCLUDE MSDOSU\t\t;MSDOS constants\r\n\r\n\r\n\r\n\r\n\tEXTRN\tINIT:NEAR\r\n\r\n\r\n\r\n\tEXTRN\tSETGSB:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tONGSBF:WORD\r\nDSEG\tENDS\r\n\r\n\r\n\tBUFOFS=0\r\n\r\n\tBUFOFS=2\t\t;MUST CRUNCH INTO ERALIER PLACE FOR\r\n\t\t\t\t; SINGLE QUOTE\r\n\r\n\tKBFLEN=BUFLEN+(BUFLEN/4)\t;MAKE KRUNCH BUFFER SOMEWHAT\r\n\t\t\t\t; LARGER THAN SOURCE BUFFER (BUF)\r\n\r\n\r\n\r\n\r\n\tEXTRN\tNAME:NEAR\r\n\tEXTRN\tINLIN:NEAR,CRDO:NEAR,CRDONZ:NEAR,STRCMP:NEAR,PPSWRT:NEAR\r\n\r\n\tEXTRN\tOUTDO:NEAR\r\n\r\n\tEXTRN\tBLTU:NEAR,CLEARC:NEAR,GTMPRT:NEAR,ISLET:NEAR,ISLET2:NEAR\r\n\tEXTRN\tPTRGET:NEAR\r\n\tEXTRN\tQINLIN:NEAR,SCRTCH:NEAR,STKINI:NEAR,RUNC:NEAR,RESFIN:NEAR\r\n\tEXTRN\tPTRGT2:NEAR,STPEND:NEAR\r\n\r\n\tEXTRN\tSYNCHR:NEAR\r\n\r\n\tEXTRN\tSIGN:NEAR\r\n\r\n\tEXTRN\tPRGFIN:NEAR,FILIND:NEAR\r\n\r\n\tEXTRN\tFILINP:NEAR,INDSKC:NEAR\r\n\r\n\r\n\tEXTRN\tLRUN:NEAR\r\n\r\n\r\n\tEXTRN\tINXHRT:NEAR\r\n\tEXTRN\tZERO:NEAR,MOVE:NEAR,FOUT:NEAR,FIN:NEAR,PUSHF:NEAR\r\n\tEXTRN\tMOVFR:NEAR,MOVRF:NEAR,MOVRM:NEAR,INPRT:NEAR,LINPRT:NEAR\r\n\tEXTRN\tMOVFM:NEAR,MOVMF:NEAR\r\n\tEXTRN\tINRART:NEAR,NEG:NEAR\r\n\tEXTRN\tFREFAC:NEAR,FRETMS:NEAR,STRCPY:NEAR,GETSTK:NEAR\r\n\tEXTRN\tSTRLIT:NEAR,STRLT2:NEAR,STRLT3:NEAR,STRLTI:NEAR,STROUT:NEAR\r\n\tEXTRN\tSTRPRT:NEAR,STROUI:NEAR\r\n\tEXTRN\tGETSPA:NEAR,PUTNEW:NEAR,STOP:NEAR,OMERR:NEAR,REASON:NEAR\r\n\r\n\r\n\tEXTRN\tINSTR:NEAR\r\n\r\n\tEXTRN\tPRINUS:NEAR,PUTTMP:NEAR\r\n\r\n\tEXTRN\tFOUTH:NEAR,FOUTO:NEAR,STRO$:NEAR,STRH$:NEAR\r\n\r\n\r\n\tEXTRN\tSTRNG$:NEAR\r\n\tEXTRN\tTON:NEAR,TOFF:NEAR\r\n\tEXTRN\tSPACE$:NEAR\r\n\r\n\tEXTRN\tSIGNS:NEAR\r\n\r\n\r\n\r\n\r\n\tEXTRN\tUMULT:NEAR\r\n\r\n\tEXTRN\tSIGNC:NEAR,POPHRT:NEAR\r\n\r\n\tEXTRN\tFINLPT:NEAR\r\n\r\n\tEXTRN\tVMOVFA:NEAR,VMOVAF:NEAR,ISIGN:NEAR,VSIGN:NEAR,VDFACS:NEAR\r\n\tEXTRN\tVMOVMF:NEAR,VMOVFM:NEAR,FRCINT:NEAR,FRCDBL:NEAR,FRCSNG:NEAR\r\n\tEXTRN\tVNEG:NEAR,PUFOUT:NEAR,DCXBRT:NEAR,IADD:NEAR\r\n\tEXTRN\tFINDBL:NEAR\r\n\tEXTRN\tVMOVE:NEAR,VALINT:NEAR,VALSNG:NEAR,FRCSTR:NEAR,CHKSTR:NEAR\r\n\tEXTRN\tMAKINT:NEAR\r\n\tEXTRN\tMOVE1:NEAR\r\n\r\n\tEXTRN\tSCNSEM:NEAR\r\n\tEXTRN\tWHILE:NEAR,WEND:NEAR\r\n\tEXTRN\tCALLS:NEAR\r\n\tEXTRN\tPROCHK:NEAR\r\n\tEXTRN\tWRITE:NEAR\r\n;The following block of externals was added on Dec 19, 1982 when BINTRP was\r\n; Split up after the freeze of GW-BASIC Version 1.0\r\n; This Split-up was not reflected in the PS1:<BASIC>BINTRP.MAC source.\r\n; See Tom Corbett if you have any questions.\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tMEMSIZ:WORD,FRETOP:WORD,VARTAB:WORD,STREND:WORD,TXTTAB:WORD\r\n\tEXTRN\tARYTAB:WORD\r\n\tEXTRN\tCURLIN:WORD,DOT:WORD,DATLIN:WORD,NLONLY:WORD,ERRLIN:WORD\r\n\tEXTRN\tERRTXT:WORD\r\n\tEXTRN\tMRGFLG:WORD,CHNFLG:WORD\r\n\tEXTRN\tSAVSTK:WORD,SAVTXT:WORD,OLDLIN:WORD,NXTLIN:WORD,OLDTXT:WORD\r\n\tEXTRN\tONELIN:WORD,ONEFLG:WORD\r\n\tEXTRN\tCNTOFL:WORD,TRCFLG:WORD,CONSAV:WORD,CONTXT:WORD,CONTYP:WORD\r\n\tEXTRN\tNUMCON:WORD,CONLO:WORD\r\n\tEXTRN\tAUTFLG:WORD,AUTLIN:WORD,AUTINC:WORD\r\n\tEXTRN\tKBUF:WORD,BUFMIN:WORD,BUF:WORD\r\n\tEXTRN\tPTRFIL:WORD,PTRFLG:WORD,DORES:WORD,VALTYP:WORD,FACLO:WORD\r\n\tEXTRN\tDFACLO:WORD,FAC:WORD\r\n\tEXTRN\tTEMP:WORD,TEMP2:WORD,TEMP3:WORD,TEMPA:WORD\r\n\tEXTRN\tDSCTMP:WORD,TEMPST:WORD\r\n\tEXTRN\tOPRTYP:WORD\r\n\tEXTRN\tSUBFLG:WORD,FVALSV:WORD,DEFTBL:WORD,FLGINP:WORD,FLGSCN:WORD\r\n\tEXTRN\tOVCSTR:WORD,INPPAS:WORD\r\n\tEXTRN\tUSRTAB:WORD,DONUM:WORD,ENDPRG:WORD,ENDFOR:WORD,DATPTR:WORD\r\n\tEXTRN\tFLGOVC:WORD\r\n\tEXTRN\tERRFLG:WORD,SAVSEG:WORD,PRMLN2:WORD,PRMSIZ:WORD,PARM2:WORD\r\n\tEXTRN\tPRMLEN:WORD,PRMSTK:WORD,PARM1:WORD\r\n\tEXTRN\tFUNACT:WORD,NOFUNS:WORD,OPTVAL:WORD,OPTFLG:WORD,RNDX:WORD\r\nDSEG\tENDS\r\n\r\n\tEXTRN\tINEG2:NEAR,FADD:NEAR\r\n\tEXTRN\t$OVMSG:NEAR,ERRTAB:NEAR,LSTERR:NEAR,DSKERR:NEAR,NONDSK:NEAR\r\n\tEXTRN\tREDDY:NEAR\r\n\tEXTRN\tERRSN:NEAR,ERRDV0:NEAR,ERRRE:NEAR,ERROV:NEAR,ERRMO:NEAR\r\n\tEXTRN\tERRTM:NEAR,ERRNF:NEAR\r\n\tEXTRN\tERRNR:NEAR,ERRLBO:NEAR,ERRDD:NEAR,ERRUF:NEAR,ERRFC:NEAR\r\n\tEXTRN\tERRIFN:NEAR,ERRFNO:NEAR,ERRDNA:NEAR,ERRFDR:NEAR,ERRRAD:NEAR\r\n\tEXTRN\tERRDFL:NEAR\r\n\tEXTRN\tERRIOE:NEAR,ERRBFM:NEAR,ERRFNF:NEAR,ERRBFN:NEAR,ERRIER:NEAR\r\n\tEXTRN\tERRRPE:NEAR\r\n\tEXTRN\tERRFAO:NEAR,ERRNMF:NEAR,ERRWH:NEAR,ERRBRN:NEAR,ERRFOV:NEAR\r\n\tEXTRN\tERRTMF:NEAR\r\n\tEXTRN\tERRFAE:NEAR,ERRUS:NEAR,ERRRG:NEAR,ERROD:NEAR,ERRFN:NEAR\r\n\tEXTRN\tERRUE1:NEAR\t;ERRUE+DSKERR-NONDSK\r\n\tEXTRN\tDSKER1:NEAR\t;DSKERR-NONDSK\r\n\r\n;The following externs are defined in GWEVAL.MAC\r\n;\r\n\tEXTRN\tMAKUPL:NEAR,MAKUPS:NEAR,GETYPR:NEAR,OCTCNS:NEAR,DOCNVF:NEAR\r\n\tEXTRN\tISMID$:NEAR\r\n\tEXTRN\tFRMEVL:NEAR,FRMCHK:NEAR,GETINT:NEAR,GETBYT:NEAR,GETIN2:NEAR\r\n\tEXTRN\tSNGFLT:NEAR\r\n\r\n;The following externs are defined in GWLIST.MAC\r\n;\r\n\tEXTRN\tDELETE:NEAR,DEL:NEAR,TSTANM:NEAR,PLOOP2:NEAR\r\n\r\n\r\n\r\n\tSUBTTL ROM VERSION INITALIZATION, AND CONSTANTS\r\n\r\n\r\n\r\n;\r\n; The reserved word tables are in another module.  Consequently\r\n; many things must be declared external.  All of these things\r\n; are in the code segement or are absolutes (like tokens).\r\n; I.e., they are not in the data segment.\r\n;\r\n\r\n\tEXTRN\tALPTAB:NEAR\r\n\tEXTRN\tEQULTK:NEAR\r\n\tEXTRN\tSTMDSP:NEAR\r\n\tEXTRN\tGREATK:NEAR\r\n\tEXTRN\tINSRTK:NEAR\r\n\tEXTRN\tLESSTK:NEAR,LSTOPK:NEAR\r\n\tEXTRN\tMIDTK:NEAR,MINUTK:NEAR\r\n\tEXTRN\tNMREL:NEAR,NOTTK:NEAR,NUMCMD:NEAR\r\n\tEXTRN\tONEFUN:NEAR\r\n\tEXTRN\tPOS:NEAR,PLUSTK:NEAR,PRINT:NEAR\r\n\tEXTRN\tRESLST:NEAR\r\n\tEXTRN\tSNGQTK:NEAR,SPCTAB:NEAR,SQRTK:NEAR,STEPTK:NEAR\r\n\tEXTRN\tTHENTK:NEAR\r\n\tEXTRN\tUSRTK:NEAR\r\n\tEXTRN\t$AUTO:NEAR\r\n\tEXTRN\t$DATA:NEAR,$DATCO:NEAR,$DELETE:NEAR\r\n\tEXTRN\t$EDIT:NEAR,$ELSE:NEAR,$END:NEAR,$ERL:NEAR,$ERROR:NEAR\r\n\tEXTRN\t$FN:NEAR,$FOR:NEAR\r\n\tEXTRN\t$GOSUB:NEAR,$GOTO:NEAR\r\n\tEXTRN\t$IF:NEAR,$INKEY$:NEAR,$INPUT:NEAR\r\n\tEXTRN\t$LIST:NEAR,$LLIST:NEAR\r\n\tEXTRN\t$NEXT:NEAR\r\n\tEXTRN\t$POINT:NEAR,$PRINT:NEAR\r\n\tEXTRN\t$REM:NEAR,$REMCO:NEAR,$RENUM:NEAR,$RESTORE:NEAR,$RESUME:NEAR\r\n\tEXTRN\t$RETURN:NEAR,$RND:NEAR,$RUN:NEAR\r\n\tEXTRN\t$SCREEN:NEAR,$STOP:NEAR,$STRING$:NEAR\r\n\tEXTRN\t$THEN:NEAR,$TO:NEAR\r\n\tEXTRN\t$USR:NEAR\r\n\tEXTRN\t$VARPTR:NEAR\r\n\tEXTRN\t$WEND:NEAR,$WHILE:NEAR\r\n\r\n;\r\n; Since the dispatch table is also no longer in BINTRP many\r\n; addresses need to be declared internal.\r\n;\r\n\r\n\tPUBLIC\tAUTO\r\n\tPUBLIC\tDATAS,DEFDBL,DEFINT,DEFREA,DEFSTR\r\n\tPUBLIC\tELSES,ERRORS\r\n\tPUBLIC\tFOR\r\n\tPUBLIC\tGOSUB,GOTO\r\n\tPUBLIC\tIFS,INPUT\r\n\tPUBLIC\tLET,LINE\r\n\tPUBLIC\tONGOTO,OPTION\r\n\tPUBLIC\tPEEK,POKE\r\n\tPUBLIC\tRANDOM,READ,REM,RESEQ,RESUME,RETURN,RUN\r\n\r\n\r\n\tSUBTTL\t      GENERAL STORAGE MANAGEMENT ROUTINES - FNDFOR, BLTU, GETSTK\r\n;\r\n; FIND A \"FOR\" ENTRY ON THE STACK WITH THE VARIABLE POINTER\r\n; PASSED IN [D,E].\r\n;\r\nPUBLIC\tFNDFOR\r\nFNDFOR: MOV\tBX,OFFSET 4+0\t;IGNORING EVERYONES \"NEWSTT\"\r\n\t\t\t\t;AND THE RETURN ADDRESS OF THIS\r\n\tADD\tBX,SP\t\t;SUBROUTINE, SET [H,L]=SP\r\nLOOPER:\r\n\r\n\tINC\tBX\t\t;8086 USES TWO BYTE ENTRIES\r\n\r\n\tMOV\tAL,BYTE PTR [BX]\t;SEE WHAT TYPE OF THING IS ON THE STACK\r\n\tINC\tBX\r\n\r\n\tWHLSIZ=6\r\n\tCMP\tAL,LOW OFFSET $WHILE\r\n\tJNZ\tSHORT STKSRC\r\n\tMOV\tCX,OFFSET WHLSIZ\r\n\tADD\tBX,CX\r\n\tJMP\tSHORT LOOPER\r\nSTKSRC:\r\n\r\n\tCMP\tAL,LOW OFFSET $FOR\t;IS THIS STACK ENTRY A \"FOR\"?\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;NO SO OK\r\n\tMOV\tCL,BYTE PTR [BX]\r\n\tINC\tBX\t\t;DO EQUIVALENT OF PUSHM / XTHL\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tINC\tBX\r\n\tPUSH\tBX\t\t;PUT H  ON\r\n\tMOV\tBX,CX\r\n\r\n\tOR\tDX,DX\t\t;\"NEXT\" STATMENT WITHOUT AN ARGUMENT ?\r\n\t\t\t\t;WE MATCH ON ANYTHING\r\n\tXCHG\tBX,DX\t\t;MAKE SURE WE RETURN [D,E]\r\n\tJZ\tSHORT POPGOF\t;POINTING TO THE VARIABLE\r\n\tXCHG\tBX,DX\r\n\r\n\tCMP\tBX,DX\r\n\tFORSIZ=16\r\n\r\n\tFORSIZ=17\r\n\tFORSIZ=FORSIZ+2\t;For text pointer into NEXT.\r\n\r\n;\r\n; Note - 8086 versions force stack entries to be an even length\r\n; so stack accesses won't cross word boundaries.  This is done\r\n; for speed.  To accomplish this, an extra byte is pushed on\r\n; top of the FOR token.  This extra byte is NOT reflected in\r\n; the value of FORSIZ but is taken care of by the code.\r\n;\r\n\r\nPUBLIC\tFORSZC\r\n\tFORSZC=0+FORSIZ\r\nPOPGOF: MOV\tCX,OFFSET FORSZC-3\t;TO WIPE OUT A \"FOR\" ENTRY\r\n\t\t\t\t;Note that the pointer has already\r\n\t\t\t\t;been incremented three times.\r\n\tPOP\tBX\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF VARIABLE IN THIS ENTRY MATCHES\r\n\t\t\t\t;RETURN WITH [H,L] POINTING THE BOTTOM\r\n\t\t\t\t;OF THE ENTRY\r\n\tADD\tBX,CX\r\n\tJMP\tSHORT LOOPER\t;NOW POINTING TO THE START OF THE NEXT\r\n\t\t\t\t;ENTRY. SEE IF ITS A \"FOR\" ENTRY\r\n\t\t\t\t;AND IF THE VARIABLE MATCHES\r\n\r\n\r\n\r\n\r\n\tSUBTTL ERROR HANDLING\r\n\r\n\r\n\r\n;\r\n; THIS ROUTINE IS CALLED TO RESET THE STACK IF BASIC IS\r\n; EXTERNALLY STOPPED AND THEN RESTARTED.\r\n;\r\nPUBLIC\tREADYR\r\nREADYR: MOV\tCX,OFFSET STPRDY\t;ADDRESS GO TO, ALSO POP OFF GARBAGE STACK ENTRY.\r\n\tJMP\tERESET\t\t;RESET STACK, GOTO READY.\r\n\r\nPRGEND:\r\n\tMOV\tBX,CURLIN\t;GET CURRENT LINE #\r\n\tMOV\tAL,BH\t\t;SEE IF DIRECT\r\n\tAND\tAL,BL\t\t;AND TOGETHER\r\n\tINC\tAL\t\t;SET CC'S\r\n\tJZ\tSHORT ENDCNJ\t;IF DIRECT DONE, ALLOW FOR DEBUGGING PURPOSES\r\n\tMOV\tAL,BYTE PTR ONEFLG\t;SEE IF IN ON ERROR\r\n\tOR\tAL,AL\t\t;SET CC\r\n\tMOV\tDL,LOW OFFSET ERRNR\t;\"NO RESUME\" ERROR\r\n\tJNZ\tSHORT ERROR\t;YES, FORGOT RESUME\r\n\tEXTRN\tENDCON:NEAR\r\nENDCNJ: JMP\tENDCON\t\t;NO, LET IT END\r\n\r\n\tDERMAK\tIFN\t\t;\"Illegal File Name\"\r\n\tDERMAK\tFNO\t\t;\"File Not Open\"\r\n\tDERMAK\tDNA\t\t;\"Device not available\"\r\n\tDERMAK\tFDR\t\t;\"Direct statement in file\"\r\n\tDERMAK\tRAD\t\t;\"Rename across disk\"\r\n\tDERMAK\tDFL\t\t;\"DISK FULL\"\r\n\tDERMAK\tIOE\t\t;\"DISK I/O ERROR\"\r\n\tDERMAK\tBFM\t\t;\"BAD FILE MODE\"\r\n\tDERMAK\tFNF\t\t;\"FILE NOT FOUND\"\r\n\tDERMAK\tBFN\t\t;\"BAD FILE NUMBER\"\r\n\tDERMAK\tIER\t\t;\"INTERNAL ERROR\"\r\n\tDERMAK\tRPE\t\t;\"READ PAST END\"\r\n\tDERMAK\tFAO\t\t;\"FILE ALREADY OPEN\"\r\n\tDERMAK\tNMF\t\t;\"BAD FILE NAME\"\r\n\tDERMAK\tBRN\t\t;\"BAD RECORD NUMBER\"\r\n\tDERMAK\tFOV\t\t;\"FIELD OVERFLOW\"\r\n\tDERMAK\tTMF\t\t;\"TOO MANY FILES\"\r\n\tDERMAK\tFAE\t\t;\"FILE ALREADY EXISTS\"\r\n\tORG\t$-1\r\n\r\n\tJMP\tSHORT ERROR\r\n\r\nDATSNE: MOV\tBX,DATLIN\t;GET DATA LINE\r\n\tMOV\tCURLIN,BX\t;MAKE IT CURRENT LINE\r\n\r\nPUBLIC\t$SNERR\r\n$SNERR:\r\n\r\nPUBLIC\tSNERR\r\nSNERR:\tMOV\tDL,LOW OFFSET ERRSN\t;\"SYNTAX ERROR\"\r\n\tDB\t271O\t; SKIP  ;\"LXI B,\" OVER THE NEXT 2\r\nPUBLIC\tDV0ERR\r\nDV0ERR: MOV\tDL,LOW OFFSET ERRDV0\t;DIVISION BY ZERO\r\n\tDB\t271O\t; SKIP  ;\"LXI B,\" OVER THE NEXT 2\r\nPUBLIC\tNFERR\r\nNFERR:\tMOV\tDL,LOW OFFSET ERRNF\t;\"NEXT WITHOUT FOR\" ERROR\r\n\tDB\t271O\t; SKIP  ;\"LXI B,\" OVER THE NEXT TWO BYTES\r\nPUBLIC\tDDERR\r\nDDERR:\tMOV\tDL,LOW OFFSET ERRDD\t;\"REDIMENSIONED VARIABLE\"\r\n\tDB\t271O\t; SKIP  ;\"LXI B,\" OVER THE NEXT 2 BYTES\r\nPUBLIC\tUFERR\r\nUFERR:\tMOV\tDL,LOW OFFSET ERRUF\t;\"UNDEFINED FUNCTION\" ERROR\r\n\tDB\t271O\t; SKIP  ;\"LXI B,\" OVER THE NEXT TWO\r\nREERR:\tMOV\tDL,LOW OFFSET ERRRE\t;\"RESUME WITHOUT ERROR\"\r\n\tDB\t271O\t; SKIP  ;\"LXI B,\" OVER THE NEXT TWO\r\nPUBLIC\t$OVERR\r\n$OVERR:\r\nPUBLIC\tOVERR\r\nOVERR:\tMOV\tDL,LOW OFFSET ERROV\t;SET OVERFLOW ERROR CODE\r\n\tDB\t271O\t; SKIP  ;\"LXI B,\" OVER NEXT TWO\r\nPUBLIC\tMOERR\r\nMOERR:\tMOV\tDL,LOW OFFSET ERRMO\t;MISSING OPERAND ERROR\r\n\tDB\t271O\t; SKIP  ;\"LXI   B,\" OVER THE NEXT TWO\r\nPUBLIC\t$TMERR\r\n$TMERR:\r\nPUBLIC\tTMERR\r\nTMERR:\tMOV\tDL,LOW OFFSET ERRTM\t;TYPE MISMATCH ERROR\r\nPUBLIC\tERROR\r\nERROR:\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR NLONLY,AL\t;Clear Don't close files flag\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tINITFG:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tCMDERR:NEAR\r\n\tMOV\tAL,BYTE PTR INITFG\r\n\tOR\tAL,AL\t\t;0 implies initialization is incomplete\r\n\tJZ\tSHORT ??L000\r\n\tJMP\tINITOK\t\t;Initialization has completed\r\n??L000:\r\n\tJMP\tCMDERR\t\t;Execute command line error routine\r\n\t\t\t\t;which returns to the OS\r\nINITOK:\r\n\tHLPEDT=PC8A\r\n\tMOV\tBX,CURLIN\t;GET CURRENT LINE NUMBER\r\n\tMOV\tERRLIN,BX\t;SAVE IT FOR ERL VARIABLE\r\n\tXOR\tAL,AL\t\t;CLEAR CHAIN FLAG IN CASE OF ERROR\r\n\tMOV\tBYTE PTR MRGFLG,AL\t;ALSO MERGE FLAG\r\n\tMOV\tBYTE PTR CHNFLG,AL\t;SO IT DOESNT TRY TO CHAIN\r\n\tMOV\tAL,BH\t\t;ONLY SET UP DOT IF IT ISNT DIRECT\r\n\tAND\tAL,BL\r\n\tINC\tAL\r\n\tJZ\tSHORT ERRESM\r\n\tMOV\tDOT,BX\t\t;SAVE IT FOR EDIT OR LIST\r\nERRESM: MOV\tCX,OFFSET ERRMOR\t;GET RETURN ADDRESS IN [B,C]\r\n\tEXTRN\tSTKERR:NEAR\r\nPUBLIC\tERESET\r\nERESET: MOV\tBX,SAVSTK\t;GET A GOOD STACK BACK\r\n\tJMP\tSTKERR\t\t;JUMP INTO STKINI\r\nERRMOR: POP\tCX\t\t;POP OFF FNDFOR STOPPER\r\n\tMOV\tAL,DL\t\t;[A]=ERROR NUMBER\r\n\tMOV\tCL,DL\t\t;ALSO SAVE IT FOR LATER RESTORE\r\n\tMOV\tBYTE PTR ERRFLG,AL\t;SAVE IT SO WE KNOW WHETHER TO CALL \"EDIT\"\r\n\tMOV\tBX,SAVTXT\t;GET SAVED TEXT POINTER\r\n\tMOV\tERRTXT,BX\t;SAVE FOR RESUME.\r\n\tXCHG\tBX,DX\t\t;SAVE SAVTXT PTR\r\n\tMOV\tBX,ERRLIN\t;GET ERROR LINE #\r\n\tMOV\tAL,BH\t\t;TEST IF DIRECT LINE\r\n\tAND\tAL,BL\t\t;SET CC'S\r\n\tINC\tAL\t\t;SETS ZERO IF DIRECT LINE (65535)\r\n\tJZ\tSHORT NTMDCN\t;IF DIRECT, DONT MODIFY OLDTXT & OLDLIN\r\n\tMOV\tOLDLIN,BX\t;SET OLDLIN=ERRLIN.\r\n\tXCHG\tBX,DX\t\t;GET BACK SAVTXT\r\n\tMOV\tOLDTXT,BX\t;SAVE IN OLDTXT.\r\nNTMDCN: MOV\tBX,ONELIN\t;SEE IF WE ARE TRAPPING ERRORS.\r\n\tOR\tBX,BX\t\t;BY CHECKING FOR LINE ZERO.\r\n\tXCHG\tBX,DX\t\t;PUT LINE TO GO TO IN [D,E]\r\n\tMOV\tBX,OFFSET ONEFLG\t;POINT TO ERROR FLAG\r\n\tJZ\tSHORT NOTRAP\t;SORRY, NO TRAPPING...\r\n\tAND\tAL,BYTE PTR [BX]\t;A IS NON-ZERO, SETZERO IF ONEFLG ZERO\r\n\tJNZ\tSHORT NOTRAP\t;IF FLAG ALREADY SET, FORCE ERROR\r\n\tDEC\tBYTE PTR [BX]\t;IF ALREADY IN ERROR ROUTINE, FORCE ERROR\r\n\tXCHG\tBX,DX\t\t;GET LINE POINTER IN [H,L]\r\n\tJMP\tGONE4\t\t;GO DIRECTLY TO NEWSTT CODE\r\nNOTRAP: XOR\tAL,AL\t\t;A MUST BE ZERO FOR CONTRO\r\n\tMOV\tBYTE PTR [BX],AL\t;RESET ONEFLG\r\n\tMOV\tDL,CL\t\t;GET BACK ERROR CODE\r\n\tMOV\tBYTE PTR CNTOFL,AL\t;FORCE OUTPUT\r\n\tCALL\tCRDONZ\t\t;CRLF\r\n\tMOV\tBX,OFFSET ERRTAB\t;GET START OF ERROR TABLE\r\n\tMOV\tAL,DL\t\t;GET ERROR CODE\r\n\tCMP\tAL,LOW OFFSET LSTERR\t;IS IT PAST LAST ERROR?\r\n\tJAE\tSHORT UPERR\t;YES, TOO BIG TO PRINT\r\n\tCMP\tAL,LOW OFFSET DSKERR+1\t;DISK ERROR?\r\n\tJAE\tSHORT NTDER2\t;YES\r\n\tCMP\tAL,LOW OFFSET NONDSK+1\t;IS IT BETWEEN LAST NORMAL & FIRST DISK?\r\n\tJB\tSHORT NTDERR\t;YES, OK TO PRINT IT\r\nUPERR:\tMOV\tAL,LOW OFFSET ERRUE1\t;PRINT \"UNPRINTABLE ERROR\"\r\nNTDER2: SUB\tAL,LOW OFFSET DSKER1\t;FIX OFFSET INTO TABLE OF MESSAGES\r\n\tMOV\tDL,AL\t\t;SAVE BACK ERROR CODE\r\nNTDERR:\r\n\t\t\t\t;ON \"SYNTAX ERROR\"S\r\nLEPSKP: INS86\t56\t\t;CODE SEGMENT FETCH\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tINC\tBX\t\t;POINT TO NEXT CHARACTER\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT ??L001\r\n\tJMP\tLEPSKP\r\n??L001:\r\n\tDEC\tBX\r\n\tINC\tBX\t\t;SKIP OVER THIS ERROR MESSAGE\r\n\tDEC\tDL\t\t;DECREMENT ERROR COUNT\r\n\tJNZ\tSHORT LEPSKP\t;SKIP SOME MORE\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tMOV\tBX,ERRLIN\t;GET ERROR LINE NUMBER\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;GET BACK ERROR TEXT POINTER\r\nPUBLIC\tERRFIN\r\nERRFIN:\r\n\tINS86\t56\t\t;CODE SEGMENT OVERRIDE FOR 8086 BASIC\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET 1ST CHAR OF ERROR\r\n\tCMP\tAL,LOW \"?\"      ;PADDED ERROR?\r\n\tJNZ\tSHORT ERRFN1\t;NO,PRINT\r\n\tPOP\tBX\t\t;GET LINE # OFF STACK\r\n\tMOV\tBX,OFFSET ERRTAB\r\n\tJMP\tSHORT UPERR\t;MAKE UNPRINTABLE ERROR\r\n\r\nERRFN1:\r\n\tCALL\tSTROUT\t\t;PRINT MESSAGE\r\n\tPOP\tBX\t\t;RESTORE LINE NUMBER\r\n\tMOV\tDX,65534\t;IS INIT EXECUTING?\r\n\tCMP\tBX,DX\r\n\tJNZ\tSHORT ??L002\r\n\tCALL\tCRDO\t\t;DO CRLF\r\n??L002:\r\n\tEXTRN\tSYSTME:NEAR\r\n\tJNZ\tSHORT ??L003\r\n\tJMP\tSYSTME\t\t;SYSTEM error exit\r\n??L003:\r\n\tMOV\tAL,BH\t\t;SEE IF IN DIRECT MODE\r\n\tAND\tAL,BL\r\n\tINC\tAL\t\t;ZERO SAYS DIRECT MODE\r\n\tJZ\tSHORT ??L004\r\n\tCALL\tINPRT\t\t;PRINT LINE NUMBER IN [H,L]\r\n??L004:\r\n\tMOV\tAL,LOW 377O\r\n\tCALL\tOUTDO\t\t;FLAG AS NOT USER INPUT\r\n; NOW FALL INTO MAIN INTERPRETER LOOP\r\n\tPAGE\r\n\r\n\tSUBTTL STPRDY, READY, MAIN, CHEAD\r\n;\r\n; FOR \"LIST\" COMMAND STOPPING\r\n; AND FOR RETURNING FROM A FAILED \"CVER\"\r\n; AND TO CORRECT A DIRECT GOSUB WHICH DOES INPUT\r\n;\r\n\tDB\t260O\t; SKIP  ;SKIP THE NEXT BYTE WITH \"MVI A,0\"\r\nPUBLIC\tSTPRDY\r\nSTPRDY: POP\tCX\r\nPUBLIC\tREADY\r\nREADY:\r\n\tCALL\tFINLPT\t\t;PRINT ANY LEFT OVERS\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR CNTOFL,AL\t;FORCE OUTPUT\r\n\tCALL\tPRGFIN\t\t;FINISH OUTPUT OF A FILE\r\n\tCALL\tCRDONZ\t\t;IF NOT ALREADY AT LEFT, SEND CRLF\r\n\tMOV\tBX,OFFSET REDDY ;\"OK\" CRLF\r\nREPINI:\r\n\tCALL\tSTROUT\r\n\tMOV\tAL,BYTE PTR ERRFLG\t;SEE IF IT WAS A \"SYNTAX ERROR\"\r\n\tSUB\tAL,LOW OFFSET ERRSN\r\n\tEXTRN\tERREDT:NEAR\r\n\tJNZ\tSHORT ??L005\r\n\tCALL\tERREDT\t\t;\"EDIT\" THE BAD LINE\r\n??L005:\r\nPUBLIC\tMAIN\r\nMAIN:\r\n\tMOV\tBX,65535\r\n\tMOV\tCURLIN,BX\t;SETUP CURLIN FOR DIRECT MODE\r\n\tMOV\tBX,OFFSET ENDPRG\r\n\tMOV\tSAVTXT,BX\t;SAVTXT POINTS AT FAKE END OF PROGRAM\r\n\tMOV\tAL,BYTE PTR AUTFLG\t;IN AN AUTO COMMAND?\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJZ\tSHORT NTAUTO\t;NO, REUGLAR MODE\r\n\tMOV\tBX,AUTLIN\t;GET CURRENT AUTO LINE\r\n\tPUSH\tBX\t\t;SAVE AWAY FOR LATER USE\r\n\tCALL\tLINPRT\t\t;PRINT THE LINE #\r\n\tPOP\tDX\t\t;GET IT BACK\r\n\tPUSH\tDX\t\t;SAVE BACK AGAIN\r\n\tCALL\tFNDLIN\t\t;SEE IF IT EXISTS\r\n\tMOV\tAL,LOW \"*\"      ;CHAR TO PRINT IF LINE ALREADY EXISTS\r\n\tJB\tSHORT AUTELN\t;DOESNT EXIST\r\n\tMOV\tAL,LOW \" \"      ;PRINT SPACE\r\nAUTELN: CALL\tOUTDO\t\t;PRINT CHAR\r\n\tMOV\tBYTE PTR AUTFLG,AL\t;SAVE WHETHER HAVE ASTERISK OR NOT\r\nNTAUTO:\r\n\tEXTRN\tPINLIN:NEAR\r\n\tCALL\tPINLIN\t\t;GET PROGRAM LINE INPUT\r\n\tJAE\tSHORT NTSTOP\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR AUTFLG,AL\t;IN CASE OF AUTO, CLEAR IT\r\n\tJMP\tMAIN\r\nNTSTOP:\r\n\tCALL\tCHRGTR\t\t;GET THE FIRST\r\n\tINC\tAL\t\t;SEE IF 0 SAVING THE CARRY FLAG\r\n\tDEC\tAL\r\n\tJZ\tSHORT MAIN\t;IF SO, A BLANK LINE WAS INPUT\r\n\tPUSHF\t\t\t;SAVE STATUS INDICATOR FOR 1ST CHARACTER\r\n\tCALL\tLINGET\t\t;READ IN A LINE #\r\n\tJAE\tSHORT MAINBX\t;ANOTHER DIGIT AFTER LINE#?\r\n\tCALL\tISFLIO\t\t;AND COMING FROM TERMINAL?\r\n\tJNZ\tSHORT ??L006\r\n\tJMP\tSNERR\t\t;IF SO, BAD INPUT\r\n??L006:\r\nMAINBX:\r\n\tCALL\tBAKSP\t\t;BACK UP THE POINTER\r\n\tMOV\tAL,BYTE PTR AUTFLG\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT NTASTC\t;NOT AUTO, DON'T CHECK FOR ASTERISK\r\n\tCMP\tAL,LOW \"*\"\r\n\tJNZ\tSHORT NTASTC\t;AUTO DID NOT APPEND ASTERISK\r\n\tCMP\tAL,BYTE PTR [BX]\t;DO WE HAVE ASTERISK?\r\n\tJNZ\tSHORT ??L007\r\n\tCALL\tINXHRT\t\t;YES, SKIP IT\r\n??L007:\r\nNTASTC:\r\n\tOR\tDX,DX\r\n\tJNZ\tSHORT ??L008\r\n\tJMP\tEDENT\t\t;BRIF no line number, don't skip space\r\n??L008:\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE CHAR\r\n\tCMP\tAL,LOW \" \"      ;CHARACTER A SPACE?\r\n\tJNZ\tSHORT ??L009\r\n\tCALL\tINXHRT\t\t;THEN EAT PAST IT\r\n??L009:\r\n\t\t\t\t;ONE SPACE ALWAYS PRINTED AFTER LINE #\r\nPUBLIC\tEDENT\r\nEDENT:\r\n\tPUSH\tDX\t\t;SAVE LINE #\r\n\tCALL\tCRUNCH\t\t;CRUNCH THE LINE DOWN\r\n\tPOP\tDX\t\t;RESTORE LINE #\r\n\tPOPF\t\t\t;WAS THERE A LINE #?\r\n\tMOV\tSAVTXT,BX\t;FOR RESUMING A DIRECT STMT\r\n\tEXTRN\tDIRDO:NEAR\r\n\tJNAE\tSHORT ??L010\r\n\tJMP\tDIRDO\t\t;MAKE SURE WE'RE NOT READING A FILE\r\n??L010:\r\n\tPUSH\tDX\r\n\tPUSH\tCX\t\t;SAVE LINE # AND CHARACTER COUNT\r\n\tCALL\tPROCHK\t\t;DONT ALLOW ANY FUNNY BUSINESS WITH EXISTING PGM\r\n\tCALL\tCHRGTR\t\t;REMEMBER IF THIS LINE IS\r\n\tOR\tAL,AL\t\t;SET THE ZERO FLAG ON ZERO\r\n\t\t\t\t;LINES THAT START WITH \":\" SHOULD NOT BE\r\n\t\t\t\t;IGNORED\r\n\tPUSHF\t\t\t;BLANK SO WE DON'T INSERT IT\r\n\tMOV\tDOT,DX\t\t;SAVE THIS LINE # IN DOT\r\n\tMOV\tBX,AUTINC\t;GET INCREMENT\r\n\tADD\tBX,DX\t\t;ADD INCREMENT TO THIS LINE\r\n\tJB\tSHORT AUTRES\t;CHECK FOR PATHETIC CASE\r\n\tPUSH\tDX\t\t;SAVE LINE NUMBER #\r\n\tMOV\tDX,65530D\t;CHECK FOR LINE # TOO BIG\r\n\tCMP\tBX,DX\r\n\tPOP\tDX\t\t;GET BACK LINE #\r\n\tJAE\tSHORT AUTRES\t;IF TOO BIG, QUIT\r\n\tMOV\tAUTLIN,BX\t;SAVE IN NEXT LINE\r\n\tJMP\tSHORT AUTGOD\r\nAUTRES: XOR\tAL,AL\r\n\tMOV\tBYTE PTR AUTFLG,AL\t;LINE NUMBER TOO BIG, QUIT\r\nAUTGOD:\r\n\tCALL\tFNDLIN\t\t;GET A POINTER TO THE LINE\r\n\tJB\tSHORT LEXIST\t;LINE EXISTS, DELETE IT\r\n\tPOPF\t\t\t;GET FLAG SAYS WHETHER LINE BLANK\r\n\tPUSHF\t\t\t;SAVE BACK\r\n\tJZ\tSHORT ??L011\r\n\tJMP\tLXISTS\t\t;Line exists - OK\r\n??L011:\r\n\tMOV\tAL,BYTE PTR AUTFLG\r\n\tOR\tAL,AL\t\t;If not AUTO mode then error.\r\n\tJNZ\tSHORT ??L012\r\n\tJMP\tUSERR\t\t;TRYING TO DELETE NON-EXISTANT LINE, ERROR\r\n??L012:\r\n\tPUSH\tCX\t\t;Prepare to leave\r\n\tJMP\tFINI\r\nLXISTS: OR\tAL,AL\t\t;CLEAR FLAG THAT SAYS LINE EXISTS\r\n\tJMP\tSHORT INONLY\r\nLEXIST:\t\t\t;SAVE THE POINTER\r\n\tPOPF\t\t\t;Don't erase line on null input when\r\n\tPUSHF\t\t\t; in AUTO mode.\r\n\tJZ\tSHORT ??L013\r\n\tJMP\tERAINS\t\t;Line not null - go erase/insert\r\n??L013:\r\n\tMOV\tAL,BYTE PTR AUTFLG\r\n\tOR\tAL,AL\t\t;AUTO mode?\r\n\tJNZ\tSHORT ??L014\r\n\tJMP\tERAINS\t\t;No - go erase/insert\r\n??L014:\r\n\tPUSH\tCX\t\t;Prepare to exit\r\n\tJMP\tFINI\r\nERAINS: STC\r\nINONLY:\r\n\tPUSH\tCX\r\n\tPUSHF\t\t\t;SAVE REGISTERS\r\n\tPUSH\tBX\t\t;SAVE [H,L]\r\n\tCALL\tDEPTR\t\t;GET RID OF PTRS IN PGM\r\n\tPOP\tBX\t\t;GET BACK POINTER TO NEXT LINE\r\n\tPOPF\t\t\t;GET BACK PSW\r\n\tPOP\tCX\t\t;RESTORE POINTER TO THIS LINE\r\n\tPUSH\tCX\t\t;SAVE BACK AGAIN\r\n\tJNB\tSHORT ??L015\r\n\tCALL\tDEL\r\n??L015:\r\nNODEL:\tPOP\tDX\t\t;POP POINTER AT PLACE TO INSERT\r\n\tPOPF\t\t\t;SEE IF THIS LINE HAD\r\n\t\t\t\t;ANYTHING ON IT\r\n\tPUSH\tDX\t\t;SAVE PLACE TO START FIXING LINKS\r\n\tJZ\tSHORT FINI\t;IF NOT DON'T INSERT\r\n\tPOP\tDX\t\t;GET RID OF START OF LINK FIX\r\n\tMOV\tAL,BYTE PTR CHNFLG\t;ONLY CHANGET FRETOP IF NOT CHAINING\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT LEVFRE\t;LEAVE FRETOP ALONE\r\n\tMOV\tBX,MEMSIZ\t;DELETE ALL STRINGS\r\n\tMOV\tFRETOP,BX\t;SO REASON DOESNT USE THEM\r\nLEVFRE:\r\n\tMOV\tBX,0\t\t;Clear error trap before inserting\r\n\tMOV\tONELIN,BX\t; to prevent OM error from being trapped\r\n\tMOV\tBX,VARTAB\t;CURRENT END\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;[H,L]=CHARACTER COUNT. VARTAB\r\n\t\t\t\t;ONTO THE STACK\r\n\tPOP\tCX\t\t;[B,C]=OLD VARTAB\r\n\tPUSH\tBX\t\t;Save count of chars to move\r\n\tADD\tBX,CX\r\n\tPUSH\tBX\t\t;SAVE NEW VARTAB\r\n\tCALL\tBLTU\r\n\tPOP\tBX\t\t;POP OFF VARTAB\r\n\tMOV\tVARTAB,BX\t;UPDATE VARTAB\r\n\tXCHG\tBX,DX\r\n\tMOV\tBYTE PTR [BX],BH\t;FOOL CHEAD WITH NON-ZERO LINK\r\n\tPOP\tCX\t\t;Restore count of chars to move\r\n\tPOP\tDX\t\t;GET LINE # OFF STACK\r\n\tPUSH\tBX\t\t;SAVE START OF PLACE TO FIX LINKS\r\n\tINC\tBX\t\t;SO IT DOESN'T THINK\r\n\t\t\t\t;THIS LINK IS THE\r\n\t\t\t\t;END OF THE PROGRAM\r\n\tINC\tBX\r\n\tMOV\t[BX],DX\r\n\tINC\tBX\r\n\tINC\tBX\t\t;PUT DOWN LINE #\r\n\tMOV\tDX,OFFSET KBUF\t;MOVE LINE FRM KBUF TO PROGRAM AREA\r\n\tDEC\tCX\t\t;FIX UP COUNT OF CHARS TO MOVE\r\n\tDEC\tCX\t\t;(DONT INCLUDE LINE # & LINK)\r\n\tDEC\tCX\t\t;\r\n\tDEC\tCX\r\nMLOOPR: MOV\tSI,DX\r\n\tMOV\tAL,[SI]\t;NOW TRANSFERING LINE\r\n\t\t\t\t;IN FROM BUF\r\n\tMOV\tBYTE PTR [BX],AL\r\n\tINC\tBX\r\n\tINC\tDX\r\n\tDEC\tCX\t\t;DECREMENT CHAR COUNT BY 1\r\n\tMOV\tAL,CL\t\t;TEST FOR COUNT EXHAUSTED\r\n\tOR\tAL,CH\t\t;BY SEEING IF [B,C]=0\r\n\tJNZ\tSHORT MLOOPR\r\nPUBLIC\tFINI\r\nFINI:\r\nEDTXIT: POP\tDX\t\t;GET START OF LINK FIXING AREA\r\n\tCALL\tCHEAD\t\t;FIX LINKS\r\n\tCALL\tRUNC\t\t;DO CLEAR & SET UP STACK \r\n\tJMP\tMAIN\t\t;GO TO MAIN CODE\r\nPUBLIC\tLINKER\r\nLINKER:\r\n\tMOV\tBX,TXTTAB\r\n\tXCHG\tBX,DX\r\n;\r\n; CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES\r\n; UP ALL THE LINKS. THE END OF EACH\r\n; LINE IS FOUND BY SEARCHING FOR THE ZERO AT THE END.\r\n; THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM\r\n;\r\nPUBLIC\tCHEAD\r\nCHEAD:\tMOV\tBH,DH\t\t;[H,L]=[D,E]\r\n\tMOV\tBL,DL\r\n\tMOV\tAL,BYTE PTR [BX]\t;SEE IF END OF CHAIN\r\n\tINC\tBX\t\t;BUMP POINTER\r\n\tOR\tAL,BYTE PTR [BX]\t;2ND BYTE\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tINC\tBX\t\t;FIX H TO START OF TEXT\r\n\tINC\tBX\r\nCZLOOP: INC\tBX\t\t;BUMP POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET BYTE\r\nCZLOO2: OR\tAL,AL\t\t;SET CC'S\r\n\tJZ\tSHORT CZLIN\t;END OF LINE, DONE.\r\n\tCMP\tAL,LOW OFFSET DBLCON+1\t;EMBEDDED CONSTANT?\r\n\tJAE\tSHORT CZLOOP\t;NO, GET NEXT\r\n\tCMP\tAL,LOW 11\t;IS IT LINEFEED OR BELOW?\r\n\tJB\tSHORT CZLOOP\t;THEN SKIP PAST\r\n\tCALL\tCHRGT2\t\t;GET CONSTANT\r\n\tCALL\tCHRGTR\t\t;GET OVER IT\r\n\tJMP\tSHORT CZLOO2\t;GO BACK FOR MORE\r\nCZLIN:\tINC\tBX\t\t;MAKE [H,L] POINT AFTER TEXT\r\n\tXCHG\tBX,DX\t\t;SWITCH TEMP\r\n\tMOV\t[BX],DX\t;STORE FIXUP\r\n\tJMP\tSHORT CHEAD\t;KEEP CHAINING TIL DONE\r\n\tPAGE\r\n\r\n\tSUBTTL SCNLIN, FNDLIN - SCAN LINE RANGE AND FIND LINE # IN PROGRAM\r\n;\r\n; SCNLIN SCANS A LINE RANGE OF\r\n; THE FORM  #-# OR # OR #- OR -# OR BLANK\r\n; AND THEN FINDS THE FIRST LINE IN THE RANGE\r\n;\r\nPUBLIC\tSCNLIN\r\nSCNLIN: MOV\tDX,0\t\t;ASSUME START LIST AT ZERO\r\n\tPUSH\tDX\t\t;SAVE INITIAL ASSUMPTION\r\n\tJZ\tSHORT ALLLST\t;IF FINISHED, LIST IT ALL\r\n\tCMP\tAL,LOW 44D\t;COMMA IS OK\r\n\tJZ\tSHORT ALLLST\t;Maybe list all to Gen Device.\r\n\tPOP\tDX\t\t;WE ARE GOING TO GRAB A #\r\n\tCALL\tLINSPC\t\t;GET A LINE #. IF NONE, RETURNS ZERO\r\n\tPUSH\tDX\t\t;SAVE FIRST\r\n\tJZ\tSHORT SNGLIN\t;IF ONLY # THEN DONE.\r\n\tCMP\tAL,LOW 44D\t;COMMA IS OK\r\n\tJZ\tSHORT SNGLIN\t;Maybe only one to Gen Device.\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET MINUTK\t;MUST BE A DASH.\r\n\tJZ\tSHORT ALLLST\t;Brif EOS.\r\n\tCMP\tAL,LOW 44D\t; else must be comma or number.\r\nALLLST: MOV\tDX,65530\t;ASSUME MAX END OF RANGE\r\n\tJZ\tSHORT ??L016\r\n\tCALL\tLINSPC\t\t;GET THE END OF RANGE\r\n??L016:\r\n\tJZ\tSHORT SNGLIN\t;Brif EOS.\r\n\tCMP\tAL,LOW 44D\r\n\tJZ\tSHORT ??L017\r\n\tJMP\tSNERR\t\t;MUST BE TERMINATOR\r\n??L017:\r\nSNGLIN:\r\n\tMOV\tTEMP,BX\t; save Text pointer.\r\n\tXCHG\tBX,DX\t\t;[H,L] = FINAL\r\n\tPOP\tDX\t\t;GET INITIAL IN [D,E]\r\nFNDLN1: POP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT MAX ON STACK, RETURN ADDR TO [H,L]\r\n\tPUSH\tBX\t\t;SAVE RETURN ADDRESS BACK\r\n;\r\n; FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE\r\n; WHOSE LINE # IS PASSED IN [D,E]. [D,E] IS PRESERVED.\r\n; THERE ARE THREE POSSIBLE RETURNS:\r\n;\r\n;       1) ZERO FLAG SET. CARRY NOT SET.  LINE NOT FOUND.\r\n;          NO LINE IN PROGRAM GREATER THAN ONE SOUGHT.\r\n;          [B,C] POINTS TO TWO ZERO BYTES AT END OF PROGRAM.\r\n;          [H,L]=[B,C]\r\n;\r\n;       2) ZERO, CARRY SET. \r\n;          [B,C] POINTS TO THE LINK FIELD IN THE LINE\r\n;          WHICH IS THE LINE SEARCHED FOR.\r\n;          [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.\r\n;\r\n;       3) NON-ZERO, CARRY NOT SET.\r\n;          LINE NOT FOUND, [B,C]  POINTS TO LINE IN PROGRAM\r\n;          GREATER THAN ONE SEARCHED FOR.\r\n;          [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.\r\n;\r\nPUBLIC\tFNDLIN\r\nFNDLIN:\r\n\tMOV\tBX,TXTTAB\t;GET POINTER TO START OF TEXT\r\nLOOP:\r\n\tMOV\tCX,BX\t\t;IF EXITING BECAUSE OF END OF PROGRAM,\r\n\t\t\t\t;SET [B,C] TO POINT TO DOUBLE ZEROES.\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET WORD POINTER TO\r\n\tINC\tBX\t\t;BUMP  POINTER\r\n\tOR\tAL,BYTE PTR [BX]\t;GET 2ND BYTE\r\n\tLAHF\r\n\tDEC\tBX\t\t;GO BACK\r\n\tSAHF\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF ZERO THEN DONE\r\n\tINC\tBX\t\t;SKIP PAST AND GET THE LINE #\r\n\tINC\tBX\r\n\tMOV\tBX,[BX]\t;INTO [H,L] FOR COMPARISON WITH\r\n\t\t\t\t;THE LINE # BEING SEARCHED FOR\r\n\t\t\t\t;WHICH IS IN [D,E]\r\n\tCMP\tBX,DX\t\t;SEE IF IT MATCHES OR IF WE'VE GONE TOO FAR\r\n\tMOV\tBX,CX\t\t;MAKE [H,L] POINT TO THE START OF THE\r\n\t\t\t\t;LINE BEYOND THIS ONE, BY PICKING\r\n\tMOV\tBX,[BX]\t;UP THE LINK THAT [B,C] POINTS AT\r\n\tCMC\t\t\t;TURN CARRY ON\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;EQUAL RETURN\r\n\tCMC\t\t\t;MAKE CARRY ZERO\r\n\tJNAE\tSHORT $+3\r\n\tRET\t\t\t;NO MATCH RETURN (GREATER)\r\n\tJMP\tSHORT LOOP\t;KEEP LOOPING\r\n\tPAGE\r\n\r\n\tSUBTTL PRE FAST CRUNCH - COMPACTIFICATION\r\n\tPAGE\r\n\tPAGE\r\n\r\n\tSUBTTL FAST CRUNCH - COMPACTIFICATION\r\n\r\n;\r\n; ALL \"RESERVED\" WORDS ARE TRANSLATED INTO SINGLE\r\n; ONE OR TWO (IF TWO, FIRST IS ALWAYS 377 OCTAL)\r\n; BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME\r\n; BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.\r\n; THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE\r\n; RESERVED WORD LIST IN THE SAME\r\n; ORDER THEY APPEAR IN IN STMDSP.\r\n;\r\n; NUMERIC CONSTANTS ARE ALSO CONVERTED TO THEIR INTERNAL\r\n; BINARY REPRESENTATION TO IMPROVE EXECUTION SPEED\r\n; LINE NUMBERS ARE ALSO PRECEEDED BY A SPECIAL TOKEN\r\n; SO THAT LINE NUMBERS CAN BE CONVERTED TO POINTERS AT EXECUTION\r\n; TIME.\r\n;\r\nPUBLIC\tCRUNCH\r\nCRUNCH:\r\n\tXOR\tAL,AL\t\t;SAY EXPECTING FLOATING NUMBERS\r\n\tMOV\tBYTE PTR DONUM,AL\t;SET FLAG ACORDINGLY\r\n\tMOV\tBYTE PTR DORES,AL\t;ALLOW CRUNCHING\r\n\tMOV\tCX,OFFSET KBFLEN-3\t;GET LENGTH OF KRUNCH BUFFER\r\n\t\t\t\t;MINUS THREE BECAUSE OF ZEROS AT END\r\n\tMOV\tDX,OFFSET KBUF\t;SETUP DESTINATION POINTER\r\nKLOOP:\tMOV\tAL,BYTE PTR [BX]\t;GET CHARACTER FROM BUF\r\n\tOR\tAL,AL\t\t;END OF LINE?\r\n\tJNZ\tSHORT NCRDON\t;NO, CONTINUE\r\nCRDONE:\r\n\tMOV\tBX,OFFSET KBFLEN+2\t;GET OFFSET\r\n\tMOV\tAL,BL\t\t;GET COUNT TO SUBTRACT FROM\r\n\tSUB\tAL,CL\t\t;SUBTRACT\r\n\tMOV\tCL,AL\r\n\tMOV\tAL,BH\r\n\tSBB\tAL,CH\r\n\tMOV\tCH,AL\t\t;BC:=# OF CHARS CRUNCHED\r\n\tMOV\tBX,OFFSET KBUF-1\t;GET POINTER TO CHAR BEFORE KBUF\r\n\t\t\t\t;AS \"GONE\" DOES A CHRGET\r\n\tXOR\tAL,AL\t\t;GET A ZERO\r\n\tMOV\tDI,DX\r\n\tSTOSB\t\t\t;NEED THREE 0'S ON THE END\r\n\tINC\tDX\t\t;ONE FOR END-OF-LINE\r\n\tMOV\tDI,DX\r\n\tSTOSB\t\t\t;AND 2 FOR A ZERO LINK\r\n\tINC\tDX\t\t;SINCE IF THIS IS A DIRECT STATEMENT\r\n\tMOV\tDI,DX\r\n\tSTOSB\t\t\t;ITS END MUST LOOK LIKE THE END OF A PROGRAM\r\n\tRET\t\t\t;END OF CRUNCHING\r\n;\r\n\tPAGE\r\nNCRDON: CMP\tAL,LOW 34\t;QUOTE SIGN? \r\n\tJNZ\tSHORT ??L018\r\n\tJMP\tSTRNG\t\t;YES, GO TO SPECIAL STRING HANDLING\r\n??L018:\r\n\tCMP\tAL,LOW \" \"      ;SPACE?\r\n\tJZ\tSHORT STUFFH\t;JUST STUFF AWAY\r\n\tMOV\tAL,BYTE PTR DORES\t;IN DATA STATEMENT AND NO CRUNCH?\r\n\tOR\tAL,AL\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE CHARACTER AGAIN\r\n\tJZ\tSHORT NTDATA\t;IF NO CRUNCHING JUST STORE\r\n\t\t\t\t;THE CHARACTER\r\nSTUFFH: INC\tBX\t\t;ENTRY TO BUMP [H,L]\r\n\tPUSH\tAX\t\t;SAVE CHAR AS KRNSAV CLOBBERS\r\n\tCALL\tKRNSAV\t\t;SAVE CHAR IN KRUNCH BUFFER\r\n\tPOP\tAX\t\t;RESTORE CHAR\r\n\tSUB\tAL,LOW \":\"      ;SEE IF IT IS A COLON\r\n\tJZ\tSHORT COLIS\t;IF SO ALLOW CRUNCHING AGAIN\r\n\tCMP\tAL,LOW OFFSET $DATCO\r\n\tJNZ\tSHORT NODATT\t;SEE IF IT IS A DATA TOKEN\r\n\tMOV\tAL,LOW 1\t;SET LINE NUMBER ALLOWED FLAG\r\n\t\t\t\t;KLUDGE AS HAS TO BE NON-ZERO.\r\nCOLIS:\tMOV\tBYTE PTR DORES,AL\t;SETUP FLAG\r\n\tMOV\tBYTE PTR DONUM,AL\t;SET NUMBER ALLOWED FLAG\r\nNODATT: SUB\tAL,LOW OFFSET $REMCO\r\n\tJNZ\tSHORT KLOOP\t;KEEP LOOPING\r\n\tPUSH\tAX\t\t;SAVE TERMINATOR ON STACK\r\nSTR1:\tMOV\tAL,BYTE PTR [BX]\t;GET A CHAR\r\n\tOR\tAL,AL\t\t;SET CONDITION CODES\r\n\tPOP\tAX\t\t;GET AL BACK WITHOUT AFFECTING PSW\r\n\tJZ\tSHORT CRDONE\t;IF END OF LINE THEN DONE\r\n\tCMP\tAL,BYTE PTR [BX]\t;COMPARE CHAR WITH THIS TERMINATOR\r\n\tJZ\tSHORT STUFFH\t;IF YES, DONE WITH STRING\r\nSTRNG:\r\n\tPUSH\tAX\t\t;SAVE TERMINATOR\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET BACK LINE CHAR\r\nSTRNG2: INC\tBX\t\t;INCREMENT TEXT POINTER\r\n\tCALL\tKRNSAV\t\t;SAVE CHAR IN KRUNCH BUFFER\r\n\tJMP\tSHORT STR1\t;KEEP LOOPING\r\n\tPAGE\r\n; NOW CHECK HGHBIT CHARS, ? FOR PRINT\r\nNTDATA:\r\n\tINC\tBX\t\t;IF SO SKIP IT\r\n\tOR\tAL,AL\t\t;IS THIS A KANA CHARACTER IN A BAD PLACE?\r\n\tJNS\tSHORT ??L019\r\n\tJMP\tKLOOP\t\t;MOVE TO THE NEXT CHARACTER\r\n??L019:\r\n\tDEC\tBX\t\t;RESTORE THE TEXT POINTER\r\n\tCMP\tAL,LOW \"?\"      ;A QMARK?\r\n\tMOV\tAL,LOW OFFSET $PRINT\r\n\tPUSH\tDX\t\t;SAVE STORE POINTER\r\n\tPUSH\tCX\t\t;SAVE CHAR COUNT\r\n\tJNZ\tSHORT ??L020\r\n\tJMP\tNOTFN2\t\t;THEN USE A \"PRINT\" TOKEN\r\n??L020:\r\n\t\t\t\t;***5.11 DONT ALLOW FOLLOWING LINE #***\r\n\tMOV\tDX,OFFSET SPCTAB\t;ASSUME WE'LL SEARCH SPECIAL CHAR TABLE\r\n\tCALL\tMAKUPL\t\t;TRANSLATE THIS CHAR TO UPPER CASE\r\n\tCALL\tISLET2\t\t;LETTER?\r\n\tJAE\tSHORT ??L021\r\n\tJMP\tTSTNUM\t\t;NOT A LETTER, TEST FOR NUMBER\r\n??L021:\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tPAGE\r\n; ANSI SAYS YOU CAN USE \"GO TO\" AND \"GO SUB\" WITH ANY NUMBER OF SPACES\r\n\tMOV\tDX,OFFSET GOSTEX\t;CHECK FOR \"GO \"\r\n\tCALL\tCHKRES\t\t;THAT IT?\r\n\tJNZ\tSHORT NOTGOS\t;NOPE\r\n\tCALL\tCHRGTR\t\t;SKIP ANY NUMBER OF SPACES\r\n\tMOV\tDX,OFFSET TOTEX ;IS IT TO?\r\n\tCALL\tCHKRES\t\t;CHECK\r\n\tMOV\tAL,LOW OFFSET $GOTO\t;ASSUME SO\r\n\tJNZ\tSHORT ??L022\r\n\tJMP\tGPUTRS\t\t;USE IT\r\n??L022:\r\n\tMOV\tDX,OFFSET SUBTEX\t;\"GO SUB\"\r\n\tCALL\tCHKRES\r\n\tJNZ\tSHORT NOTGOS\t;NO\r\n\tMOV\tAL,LOW OFFSET $GOSUB\r\nGPUTRS: POP\tCX\t\t;POP OFF THE OLD TEXT POINTER\r\n\tJMP\tNOTFN2\t\t;STORE THE RESERVED WORD\r\n; CHECK MEMORY POINTED TO BY TEXT POINTER WITH\r\n; A SPECIFIED PARTIAL RESRWORD\r\nCHKRES:\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tOR\tAL,AL\t\t;END OF MATCHED PARTIAL RESWORD?\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;YES, DONE\r\n\tMOV\tCL,AL\t\t;SAVE CHAR\r\n\tCALL\tMAKUPL\t\t;GET CHAR FROM TEXT\r\n\tCMP\tAL,CL\t\t;CHARS THE SAME?\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;DONE\r\n\tINC\tBX\t\t;BUMP POINTER INTO TEXT\r\n\tINC\tDX\t\t;AND RESWORD TEXT\r\n\tJMP\tSHORT CHKRES\t;LOOP TILL DONE\r\n\r\nGOSTEX: DB\"GO \"\r\n\tDB\t0\r\n\r\nTOTEX:\tDB\"TO\"\r\n\tDB\t0\r\n\r\nSUBTEX: DB\"UB\"\r\n\tDB\t0\r\n\r\nNOTGOS: POP\tBX\r\n\tCALL\tMAKUPL\t\t;GET BACK THE CHARACTER\r\n\tPUSH\tBX\t\t;RESAVE THE TEXT POINTER\r\n\tPAGE\r\n; NOW SEARCH ALPHA CHARACTER TABLES\r\n; TAKE THE FIRST CHARACTER AND USE IT AS AN INDEX INTO THE\r\n; TWENTY-SIX TABLES THAT CONTAIN THE RESERVED WORDS FOR EACH\r\n; LETTER\r\n;\r\n\tMOV\tBX,OFFSET ALPTAB\t;GET POINTER TO ALPHA DISPATCH TABLE\r\n\tSUB\tAL,LOW \"A\"      ;SUBTRACT ALPHA OFFSET\r\n\tADD\tAL,AL\t\t;MULTIPLY BY TWO\r\n\tMOV\tCL,AL\t\t;SAVE OFFSET IN [C] FOR DAD.\r\n\tMOV\tCH,LOW 0\t;MAKE HIGH PART OF OFFSET ZERO\r\n\tADD\tBX,CX\t\t;ADD TO TABLE ADDRESS\r\n\tINS86\t56\r\n\tMOV\tDX,[BX]\t;GET POINTER IN [D,E]\r\n\tPOP\tBX\t\t;GET BACK SOURCE POINTER\r\n\tINC\tBX\t\t;POINT TO CHAR AFTER FIRST ALPHA\r\nTRYAGA: PUSH\tBX\t\t;SAVE TXTPTR TO START OF SEARCH AREA\r\nLOPPSI:\r\n\tCALL\tMAKUPL\t\t;TRANSLATE THIS CHAR TO UPPER CASE\r\n\tMOV\tCL,AL\t\t;SAVE CHAR IN [C]\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tAND\tAL,LOW 127\t;GET RID OF HIGH BIT\r\n\tJNZ\tSHORT ??L023\r\n\tJMP\tNOTRES\t\t;IF=0 THEN END OF THIS CHARS RESLT\r\n??L023:\r\n\tINC\tBX\t\t;BUMP SOURCE POINTER\r\n\tCMP\tAL,CL\t\t;COMPARE TO CHAR FROM SOURCE LINE\r\n\tJNZ\tSHORT LOPSKP\t;IF NO MATCH, SEARCH FOR NEXT RESWRD\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tINC\tDX\t\t;BUMP RESLST POINTER\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJS\tSHORT ??L024\r\n\tJMP\tLOPPSI\t\t;SEE IF REST OF CHARS MATCH\r\n??L024:\r\n\tMOV\tAL,CL\t\t;GET LAST CHAR OF RESWRD\r\n\tCMP\tAL,LOW \"(\"      ;IF TAB( OR SPC(, SPACE NEED NOT FOLLOW\r\n\tJZ\tSHORT ISRESW\t;IS A RESWORD\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tCMP\tAL,LOW OFFSET $FN\t;FUNCTION?\r\n\tJZ\tSHORT ISRESW\t;THEN NO SPACE NEED AFTERWARD\r\n\tCMP\tAL,LOW OFFSET $USR\t;OR USR DEFINITION?\r\n\tJZ\tSHORT ISRESW\r\n\tCALL\tMAKUPL\t\t;GET NEXT CHAR IN LINE (MC 6/22/80)\r\n\tCMP\tAL,LOW \".\"      ;IS IT A DOT\r\n\tJZ\tSHORT ISVARS\t;YES\r\n\tCALL\tTSTANM\t\t;IS IT A LETTER IMMEDIATELY FOLLOWING RESWRD\r\nISVARS: MOV\tAL,LOW 0\t;SET DONUM TO -1\r\n\tJNAE\tSHORT ??L025\r\n\tJMP\tNOTRES\t\t;IF ALPHA, CANT BE RESERVED WORD\r\n??L025:\r\nISRESW:\r\n\tPOP\tAX\t\t;GET RID OF SAVED [H,L]\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJNS\tSHORT ??L026\r\n\tJMP\tNOTFNT\t\t;IF MINUS, WASNT FUNCTION TOKEN\r\n??L026:\r\n\tPOP\tCX\t\t;GET CHAR COUNT OFF STACK\r\n\tPOP\tDX\t\t;GET DEPOSIT POINTER OFF STACK\r\n\tOR\tAL,LOW 200O\t;MAKE HIGH ORDER BIT ONE\r\n\tPUSH\tAX\t\t;SAVE FN CHAR\r\n\tMOV\tAL,LOW 377O\t;GET BYTE WHICH PRECEEDS FNS\r\nPUBLIC\tRENCRN\r\nRENCRN:\r\n\tCALL\tKRNSAV\t\t;SAVE IN KRUNCH BUFFER\r\n\tXOR\tAL,AL\t\t;MAKE A ZERO\r\n\tMOV\tBYTE PTR DONUM,AL\t;TO RESET DONUM (FLOATINGS ALLOWED)\r\n\tPOP\tAX\t\t;GET FUNCTION TOKEN\r\n\tCALL\tKRNSAV\t\t;STORE IT\r\n\tJMP\tKLOOP\t\t;KEEP KRUNCHING\r\n\r\nLOPSKP: POP\tBX\t\t;RESTORE UNDEFILED TEXT POINTER\r\nLOPSK2:\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tINC\tDX\t\t;BUMP RESLST POINTER\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJS\tSHORT ??L027\r\n\tJMP\tLOPSK2\t\t;NOT END OF RESWRD, KEEP SKIPPING\r\n??L027:\r\n\tINC\tDX\t\t;POINT AFTER TOKEN\r\n\tJMP\tTRYAGA\t\t;TRY ANOTHER RESWRD\r\n\r\n\tPAGE\r\n; CHECK TO SEE IF RESERVED WORD MATCHES A LIST OF\r\n; RESERVED WORDS THAT HAVE LINE NUMBERS FOLLOWING THEM INSTEAD\r\n; OF FLOATING POINT NUMBERS. IF A MATCH IS FOUND, SET DONUM TO\r\n; INDICATE THAT IF A NUMBER OCCURS, IT IS CRUNCHED AS A LINE NUMBER.\r\n;\r\nNOTFNT: DEC\tBX\t\t;FIX TEXT POINTER\r\nNOTFN2: PUSH\tAX\t\t;SAVE CHAR TO BE SAVED IN KRUNCH BUFFER\r\n\tMOV\tDX,OFFSET LINRES\t;POINT TO RESERVED WORDS THAT HAVE LINE ARGS\r\n\tMOV\tCL,AL\t\t;SAVE CHARACTER TO MATCH IN [C]\r\nNOTFN3:\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tOR\tAL,AL\t\t;END OF LIST?\r\n\tJZ\tSHORT NOTFN4\t;YES, DONE\r\n\tINC\tDX\t\t;POINT TO NEXT RESWORD\r\n\tCMP\tAL,CL\t\t;SAME AS ONE WERE LOOKING AT?\r\n\tJNZ\tSHORT NOTFN3\t;KEEP LOOKING\r\n\tJMP\tSHORT NOTRS2\t;DOESNT HAVE LINE # ARG\r\n\r\nLINRES: DB\tOFFSET $RESTORE ;RESTORE CAN HAVE FOLLOWING LINE NUMBER\r\n\tDB\tOFFSET $AUTO\t;AUTO COMMAND\r\n\tDB\tOFFSET $RENUM\t;RENUMBER?\r\n\tDB\tOFFSET $DELETE\t;DELETE?\r\n\tDB\tOFFSET $EDIT\t;EDIT?\r\n\tDB\tOFFSET $RESUME\t;RESUME?\r\n\tDB\tOFFSET $ERL\t;ERROR LINE\r\n\t\t\t\t;SO THAT IF \"ERL=...THEN\"\r\n\t\t\t\t;WILL RESEQUENCE PROPERLY\r\n\t\t\t\t;THIS CAN MAKE STATEMENTS LIKE \r\n\t\t\t\t;\"PRINT ERL,1E20\" DO STRANGE THINGS\r\n\tDB\tOFFSET $ELSE\t;IF ELSE CRUNCH FOLLOWING LINE #\r\n\tDB\tOFFSET $RUN\t;RUN?\r\n\tDB\tOFFSET $LIST\t;LIST?\r\n\tDB\tOFFSET $LLIST\t;LPT LIST?\r\n\tDB\tOFFSET $GOTO\t;IF GOTO, CRUNCH LINE #\r\n\tDB\tOFFSET $RETURN\t;NON LOCAL RETURN ALLOWS LINE # AFTER RETURN\r\n\tDB\tOFFSET $THEN\t;CRUNCH LINE #'S AFTER 'THEN'\r\n\tDB\tOFFSET $GOSUB\t;IF GOSUB, CRUNCH LINE #'S\r\n\tDB\t0\r\n\r\nNOTFN4: XOR\tAL,AL\t\t;GET A ZERO (EXPECT USUALL\b NUMBERS)\r\n\tJMP\tSHORT NOTRS6\r\nNOTRS2: MOV\tAL,LOW 1\t;SAY LINE #'S ALLOWED.\r\nNOTRS6: MOV\tBYTE PTR DONUM,AL\t;SAVE IN FLAG\r\n\tPOP\tAX\t\t;RESTORE CHARACTER TO SAVE IN KRUNCH BUFFER\r\n\tPOP\tCX\t\t;GET BACK THE CHARACTER COUNT\r\n\tPOP\tDX\t\t;GET STUFF POINTER BACK\r\n\tCMP\tAL,LOW OFFSET $ELSE\t;HAVE TO PUT A HIDDEN\r\n\t\t\t\t;COLON IN FRONT OF \"ELSE\"S\r\n\tPUSH\tAX\t\t;SAVE CURRENT CHAR ($ELSE)\r\n\tJNZ\tSHORT ??L028\r\n\tCALL\tKRNSVC\t\t;SAVE \":\" IN CRUNCH BUFFER\r\n??L028:\r\n\tPOP\tAX\t\t;GET BACK TOKEN\r\n\tCMP\tAL,LOW OFFSET $WHILE\t;SEE IF WHILE TO IN A PLUS TO AVOID\r\n\tJNZ\tSHORT CKSNGQ\t;Brif not\r\n\tCALL\tKRNSAV\t\t;Emit WHILE Token, then Plus (+)\r\n\tMOV\tAL,LOW OFFSET PLUSTK\t;PLUS SIGN IS OK AND AVOIDS CONSTANT\r\nCKSNGQ: CMP\tAL,LOW OFFSET SNGQTK\t;SINGLE QUOATATION MARK?\r\n\tJZ\tSHORT ??L029\r\n\tJMP\tNTSNGT\r\n??L029:\r\n\tPUSH\tAX\t\t;SAVE SNGQTK\r\n\tCALL\tKRNSVC\t\t;SAVE \":\" IN CRUNCH BUFFER\r\n\tMOV\tAL,LOW OFFSET $REM\t;STORE \":$REM\" IN FRONT FOR EXECUTION\r\n\tCALL\tKRNSAV\t\t;SAVE IT\r\n\tPOP\tAX\t\t;GET SNGQTK BACK\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tMOV\tBX,0\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;Save terminator (0), restore Txt Ptr\r\n\tJMP\tSTRNG2\t\t;STUFF THE REST OF THE LINE WITHOUT CRUNCHING\r\nTSTNUM: MOV\tAL,BYTE PTR [BX]\t;GET CHAR\r\n\tCMP\tAL,LOW \".\"      ;TEST FOR START OF FLOATING #\r\n\tJZ\tSHORT NUMTRY\t;TRY INPUTTING IT AS CONSTANT\r\n\tCMP\tAL,LOW OFFSET \"9\"+1     ;IS IT A DIGIT?\r\n\tJNAE\tSHORT ??L030\r\n\tJMP\tSRCSPC\t\t;NO, TRY OTHER THINGS\r\n??L030:\r\n\tCMP\tAL,LOW \"0\"      ;TRY LOWER END\r\n\tJAE\tSHORT ??L031\r\n\tJMP\tSRCSPC\t\t;NO TRY OTHER POSSIBILITIES\r\n??L031:\r\nNUMTRY: MOV\tAL,BYTE PTR DONUM\t;TEST FOR NUMBERS ALLOWED\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR IF GOING TO STUFFH\r\n\tPOP\tCX\t\t;RESTORE CHAR COUNT\r\n\tPOP\tDX\t\t;RESTORE DEP. POINTER\r\n\tJNS\tSHORT ??L032\r\n\tJMP\tSTUFFH\t\t;NO, JUST STUFF IT (!)\r\n??L032:\r\n\tJZ\tSHORT FLTGET\t;IF DONUM=0 THEN FLOATING #'S ALLOWED\r\n\tCMP\tAL,LOW \".\"      ;IS IT DOT?\r\n\tJNZ\tSHORT ??L033\r\n\tJMP\tSTUFFH\t\t;YES, STUFF IT FOR HEAVENS SAKE! (EDIT .)\r\n??L033:\r\n\tMOV\tAL,LOW OFFSET LINCON\t;GET LINE # TOKEN\r\n\tCALL\tKRNSAV\t\t;SAVE IT\r\n\tPUSH\tDX\t\t;SAVE DEPOSIT POINTER\r\n\tCALL\tLINGET\t\t;GET THE LINE #.\r\n\tCALL\tBAKSP\t\t;BACK UP POINTER TO AFTER LAST DIGIT\r\nSAVINT: POP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;EXCHANGE CURRENT [H,L] WITH SAVED [D,E]\r\n\tXCHG\tBX,DX\t\t;GET SAVED [D,E] IN [D,E]\r\nSAVI:\tMOV\tAL,BL\t\t;GET LOW BYTE OF VALUE RETURNED BY LINGET\r\n\tCALL\tKRNSAV\t\t;SAVE THE LOW BYTE OF LINE #\r\n\tMOV\tAL,BH\t\t;GET HIGH BYTE\r\nPOPSTF: POP\tBX\t\t;RESTORE [H,L]\r\n\tCALL\tKRNSAV\t\t;SAVE IT TOO\r\n\tJMP\tKLOOP\t\t;EAT SOME MORE\r\n\r\nFLTGET: PUSH\tDX\t\t;SAVE DEPOSIT POINTER\r\n\tPUSH\tCX\t\t;SAVE CHAR COUNT\r\n\tMOV\tAL,BYTE PTR [BX]\t;FIN ASSUMES CHAR IN [A]\r\n\tCALL\tFIN\t\t;READ THE #\r\n\tCALL\tBAKSP\t\t;BACK UP POINTER TO AFTER LAST DIGIT\r\n\tPOP\tCX\t\t;RESTORE CHAR COUNT\r\n\tPOP\tDX\t\t;RESTORE DEPOSIT POINTER\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tMOV\tAL,BYTE PTR VALTYP\t;GET VALUE TYPE\r\n\tCMP\tAL,LOW 2\t;INTEGER?\r\n\tJNZ\tSHORT NTINTG\t;NO\r\n\tMOV\tBX,FACLO\t;GET IT\r\n\tMOV\tAL,BH\t\t;GET HIGH PART\r\n\tOR\tAL,AL\t\t;IS IT ZERO?\r\n\tMOV\tAL,LOW 2\t;RESTORE INT VALTYP\r\n\tJNZ\tSHORT NTINTG\t;THEN ISNT SINGLE BYTE INT\r\n\tMOV\tAL,BL\t\t;GET LOW BYTE\r\n\tMOV\tBH,BL\t\t;GET LOW BYTE IN HIGH BYTE TO STORE\r\n\tMOV\tBL,LOW OFFSET IN2CON\t;GET CONSTANT FOR 1 BYTE INTS\r\n\tCMP\tAL,LOW 10\t;IS IT TOO BIG FOR A SINGLE BYTE CONSTANT?\r\n\tJAE\tSHORT SAVI\t;TOO BIG, USE SINGLE BYTE INT\r\n\tADD\tAL,LOW OFFSET ONECON\t;MAKE SINGLE BYTE CONSTANT\r\n\tJMP\tSHORT POPSTF\t;POP H & STUFF AWAY CHAR\r\nNTINTG: PUSH\tAX\t\t;SAVE FOR LATER\r\n\tROR\tAL,1\t\t;DIVIDE BY TWO\r\n\tADD\tAL,LOW OFFSET INTCON-1\t;ADD OFFSET TO GET TOKEN\r\n\tCALL\tKRNSAV\t\t;SAVE THE TOKEN\r\n\tMOV\tBX,OFFSET FACLO ;GET START POINTER\r\n\tCALL\tGETYPR\t\t;SET CC'S ON VALTYPE\r\n\tJB\tSHORT NTDBL\t;IF NOT DOUBLE, START MOVING AT FACLO\r\n\tMOV\tBX,OFFSET DFACLO\t;DOUBLE, START MOVING AT DFACLO\r\nNTDBL:\tPOP\tAX\r\nMOVCON: PUSH\tAX\t\t;SAVE BYTE MOVE COUNT\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET A BYTE\r\n\tCALL\tKRNSAV\t\t;SAVE IT IN KRUNCH BUFFER\r\n\tPOP\tAX\t\t;GET BACK COUNT\r\n\tINC\tBX\t\t;BUMP POINTER INTO FAC\r\n\tDEC\tAL\t\t;MOVE IT DOWN\r\n\tJNZ\tSHORT MOVCON\t;KEEP MOVING IT\r\n\tPOP\tBX\t\t;GET BACK SAVED TEXT POINTER\r\n\tJMP\tKLOOP\t\t;KEEP LOOPING\r\n\r\nSRCSPC: MOV\tDX,OFFSET SPCTAB-1\t;GET POINTER TO SPECIAL CHARACTER TABLE\r\nSRCSP2: INC\tDX\t\t;MOVE POINTER AHEAD\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tAND\tAL,LOW 177O\t;MASK OFF HIGH BIT\r\n\tJNZ\tSHORT ??L034\r\n\tJMP\tNOTRS5\t\t;IF END OF TABLE, STUFF AWAY, DONT CHANGE DONUM\r\n??L034:\r\n\tINC\tDX\t\t;BUMP POINTER\r\n\tCMP\tAL,BYTE PTR [BX]\t;IS THIS SPECIAL CHAR SAME AS CURRENT TEXT CHAR?\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tJNZ\tSHORT SRCSP2\t;IF NO MATCH, KEEP LOOKING\r\n\tJMP\tNOTRS1\t\t;FOUND, SAVE AWAY AND SET DONUM=1.\r\n\r\nNTSNGT:\r\n\tCMP\tAL,LOW \"&\"      ;OCTAL CONSTANT?\r\n\tJZ\tSHORT ??L035\r\n\tJMP\tSTUFFH\t\t;JUST STUFF IT AWAY\r\n??L035:\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\tCHRGTR\t\t;GET NEXT CHAR\r\n\tPOP\tBX\t\t;RESTORE TEXT POINTER\r\n\tCALL\tMAKUPS\t\t;MAKE CHAR UPPER CASE\r\n\tCMP\tAL,LOW \"H\"      ;HEX CONSTANT?\r\n\tMOV\tAL,LOW OFFSET OCTCON\t;ASSUME OCTAL CONSTANT\r\n\tJNZ\tSHORT WUZOCT\t;YES, IT WAS\r\n\tMOV\tAL,LOW OFFSET HEXCON\t;NO, WAS HEX\r\nWUZOCT: CALL\tKRNSAV\t\t;SAVE IT\r\n\tPUSH\tDX\t\t;SAVE CURRENT DEPOSIT POINTER\r\n\tPUSH\tCX\t\t;SAVE COUNT\r\n\tCALL\tOCTCNS\t\t;GET THE VALUE\r\n\tPOP\tCX\t\t;RESTORE [B,C]\r\n\tJMP\tSAVINT\t\t;SAVE THE INTEGER IN THE KRUNCH BUFFER\r\n\r\nKRNSVC: MOV\tAL,LOW \":\"      ;GET COLON\r\nKRNSAV:\r\n\tMOV\tDI,DX\r\n\tSTOSB\t\t\t;SAVE BYTE IN KRUNCH BUFFER\r\n\tINC\tDX\t\t;BUMP POINTER\r\n\tDEC\tCX\t\t;DECREMENT COUNT OF BYTES LEFT IN BUFFER\r\n\tMOV\tAL,CL\t\t;TEST IF IT WENT TO ZERO\r\n\tOR\tAL,CH\t\t;BY SEEING IF DOUBLE BYTE ZERO.\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;ALL DONE IF STILL SPACE LEFT\r\nPUBLIC\tLBOERR\r\nLBOERR: MOV\tDL,LOW OFFSET ERRLBO\t;GET ERROR CODE\r\n\tJMP\tERROR\t\t;JUMP TO ERROR ROUTINE\r\n\r\nNOTRES:\r\n\tEXTRN\tCRUNCX:NEAR\r\n\tJMP\tCRUNCX\t\t;Go to extended CRUNCH code.\r\nPUBLIC\tNOTRFN\r\nNOTRFN:\r\n\tPOP\tBX\t\t;GET BACK POINTER TO ORIGINAL CHAR\r\n\tDEC\tBX\t\t;NOW POINT TO FIRST ALPHA CHAR\r\n\tDEC\tAL\t\t;SET A TO MINUS ONE\r\n\tMOV\tBYTE PTR DONUM,AL\t;FLAG WERE IN VARIABLE NAME\r\n\tPOP\tCX\t\t;GET BACK CHAR COUNT\r\n\tPOP\tDX\t\t;GET BACK DEPOSIT POINTER\r\n\tCALL\tMAKUPL\t\t;GET CHAR FROM LINE, MAKE UPPER CASE\r\nKRNVAR: CALL\tKRNSAV\t\t;SAVE CHAR\r\n\tINC\tBX\t\t;INCRMENT SOURCE POINTER\r\n\tCALL\tMAKUPL\t\t;MAKE UPPER CASE (?)\r\n\tCALL\tISLET2\t\t;IS IT A LETTER?\r\n\tJAE\tSHORT KRNVAR\t;YES, EAT\r\n\tCMP\tAL,LOW OFFSET \"9\"+1     ;DIGIT?\r\n\tJAE\tSHORT JKLOOP\t;NO, TOO LARGE\r\n\tCMP\tAL,LOW \"0\"\r\n\tJAE\tSHORT KRNVAR\t;YES, EAT\r\n\tCMP\tAL,LOW \".\"      ;IS IT DOT\r\n\tJZ\tSHORT KRNVAR\t;YES, DOTS OK IN VAR NAMES\r\nJKLOOP: JMP\tKLOOP\t\t;DONE LOOKING AT VARIABLE NAME\r\nNOTRS5: MOV\tAL,BYTE PTR [BX]\t;GET CHAR FROM LINE\r\n\tCMP\tAL,LOW 32\t;SPACE OR HIGHER ?\r\n\tJAE\tSHORT NOTRS1\t;YES = SAVE IT\r\n\tCMP\tAL,LOW 9\t;TAB ?\r\n\tJZ\tSHORT NOTRS1\t;YES = THAT'S OK\r\n\tCMP\tAL,LOW 10\t;ALSO ALLOW...\r\n\tJZ\tSHORT NOTRS1\t;...LINE FEEDS\r\n\tMOV\tAL,LOW 32\t;FORCE REST TO SPACES\r\nNOTRS1: PUSH\tAX\t\t;SAVE THIS CHAR\r\n\tMOV\tAL,BYTE PTR DONUM\t;GET NUMBER OK FLAG\r\n\tINC\tAL\t\t;SEE IF IN A VARIABLE NAME.\r\n\tJZ\tSHORT JNTRS6\t;IF SO & SPECIAL CHAR SEEN, RESET DONUM\r\n\tDEC\tAL\t\t;OTHERWISE LEAVE DONUM UNCHANGED.\r\nJNTRS6: JMP\tNOTRS6\r\n\r\n; ROUTINE TO BACK UP POINTER AFTER # EATEN\r\nBAKSP:\tDEC\tBX\t\t;POINT TO PREVIOUS CHAR\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE CHAR\r\n\tCMP\tAL,LOW \" \"      ;A SPACE?\r\n\tJZ\tSHORT BAKSP\t;YES, KEEP BACKING UP\r\n\tCMP\tAL,LOW 9\t;TAB?\r\n\tJZ\tSHORT BAKSP\t;YES, BACK UP\r\n\tCMP\tAL,LOW 10\t;LF?\r\n\tJZ\tSHORT BAKSP\r\n\tINC\tBX\t\t;POINT TO CHAR AFTER LAST NON-SPACE\r\n\tRET\t\t\t;ALL DONE.\r\n\r\n\tSUBTTL THE NON-EXTENDED \"LIST\" COMMAND\r\n\r\n\r\n\r\n\tPAGE\r\n\r\n\tSUBTTL \"FOR\" STATEMENT\r\n;\r\n; A \"FOR\" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:\r\n;\r\n; LOW ADDRESS\r\n;       TOKEN ($FOR IN HIGH BYTE)  1 BYTE\r\n;       A POINTER TO THE LOOP VARIABLE  2 BYTES\r\n;       A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE\r\n;       THE STEP 4 BYTES\r\n;       THE UPPER VALUE 4 BYTES\r\n;       THE LINE # OF THE \"FOR\" STATEMENT 2 BYTES\r\n;       A TEXT POINTER INTO THE \"FOR\" STATEMENT 2 BYTES\r\n; HIGH ADDRESS\r\n;\r\n; TOTAL 16 BYTES\r\n;\r\nFOR:\tMOV\tAL,LOW 100\r\n\tMOV\tBYTE PTR SUBFLG,AL\t;DONT RECOGNIZE SUBSCRIPTED VARIABLES\r\n\tCALL\tPTRGET\t\t;GET POINTER TO LOOP VARIABLE\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET EQULTK\t;SKIP OVER ASSIGNMENT \"=\"\r\n\tPUSH\tDX\t\t;SAVE THE VARIABLE POINTER ON STACK\r\n\t\t\t\t;AND IN TEMP\r\n\tMOV\tTEMP,DX\t;FOR USE LATER ON\r\n\tMOV\tAL,BYTE PTR VALTYP\t;REMEMBER THE LOOP VARIABLE TYPE\r\n\tPUSH\tAX\r\n\tCALL\tFRMEVL\t\t;GET THE START VALUE\r\n\tPOP\tAX\t\t;REGET THE LOOP TYPE\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tCALL\tDOCNVF\t\t;FORCE CONVERSION TO LOOP TYPE\r\n\tMOV\tBX,OFFSET FVALSV\t;PLACE TO SAVE THE VALUE\r\n\tCALL\tMOVMF\t\t;STORE FOR USE IN \"NEXT\"\r\n\tPOP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tPOP\tDX\t\t;GET BACK THE VARIABLE POINTER\r\n\tPOP\tCX\t\t;GET RID OF THE NEWSTT RETURN\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tCALL\tDATA\t\t;SET [H,L]=END OF STATEMENT\r\n\tMOV\tENDFOR,BX\t;SAVE FOR COMPARISON\r\n\tMOV\tBX,2\t\t;SET UP POINTER INTO STACK\r\n\tADD\tBX,SP\r\nLPFORM: CALL\tLOOPER\t\t;MUST HAVE VARIABLE POINTER IN [D,E]\r\n\tJNZ\tSHORT NOTOL\t;IF NO MATCHING ENTRY, DON'T\r\n\t\t\t\t;ELIMINATE ANYTHING\r\n\tADD\tBX,CX\t\t;IN THE CASE OF \"FOR\"\r\n\t\t\t\t;WE ELIMINATE THE MATCHING ENTRY\r\n\t\t\t\t;AS WELL AS EVERYTHING AFTER IT\r\n\tPUSH\tDX\t\t;SAVE THE VARIABLE POINTER\r\n\tDEC\tBX\t\t;SEE IF END TEXT POINTER OF MATCHING ENTRY\r\n\tMOV\tDH,BYTE PTR [BX]\t;MATCHES THE FOR WE ARE HANDLING\r\n\tDEC\tBX\t\t;PICK UP THE END OF THE \"FOR\" TEXT POINTER\r\n\tMOV\tDL,BYTE PTR [BX]\t;FOR THE ENTRY ON THE STACK\r\n\tINC\tBX\t\t;WITHOUT CHANGING [H,L]\r\n\tINC\tBX\r\n\tPUSH\tBX\t\t;SAVE THE STACK POINTER FOR THE COMPARISON\r\n\tMOV\tBX,ENDFOR\t;GET ENDING TEXT POINTER FOR THIS \"FOR\"\r\n\tCMP\tBX,DX\t\t;SEE IF THEY MATCH\r\n\tPOP\tBX\t\t;GET BACK THE STACK POINTER\r\n\tPOP\tDX\t\t;GET BACK THE VARIABLE POINTER\r\n\tJNZ\tSHORT LPFORM\t;KEEP SEARCHING IF NO MATCH\r\n\tPOP\tDX\t\t;GET BACK THE TEXT POINTER\r\n\tMOV\tSP,BX\t\t;DO THE ELIMINATION\r\n\tMOV\tSAVSTK,BX\t;UPDATE SAVED STACK\r\n\t\t\t\t;SINCE A MATCHING ENTRY WAS FOUND\r\n\tDB\t261O\t; SKIP  ;MVI C,(POP D)\r\nNOTOL:\tPOP\tDX\r\n\tXCHG\tBX,DX\t\t;[H,L]=TEXT POINTER\r\n\tMOV\tCL,LOW 8\t;MAKE SURE 16 BYTES ARE AVAILABLE\r\n\t\t\t\t;OFF OF THE STACK\r\n\tCALL\tGETSTK\r\n\tPUSH\tBX\t\t;REALLY SAVE THE TEXT POINTER\r\n\tMOV\tBX,ENDFOR\t;PICK UP POINTER AT END OF \"FOR\"\r\n\t\t\t\t;JUST BEYOND THE TERMINATOR\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT [H,L] POINTER TO TERMINATOR ON THE STACK\r\n\t\t\t\t;AND RESTORE [H,L] AS TEXT POINTER AT\r\n\t\t\t\t;VARIABLE NAME\r\n\tPUSH\tBX\t\t;PUSH THE TEXT POINTER ONTO THE STACK\r\n\tMOV\tBX,CURLIN\t;[H,L] GET THE CURRENT LINE #\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;NOW THE CURRENT LINE # IS ON THE STACK AND\r\n\t\t\t\t;[H,L] IS THE TEXT POINTER\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET $TO\t;\"TO\" IS NECESSARY\r\n\tCALL\tGETYPR\t\t;SEE WHAT TYPE THIS VALUE HAS\r\n\tJNZ\tSHORT ??L036\r\n\tJMP\tTMERR\t\t;GIVE STRINGS A \"TYPE MISMATCH\"\r\n??L036:\r\n\tJNAE\tSHORT ??L037\r\n\tJMP\tTMERR\t\t;AS WELL AS DOUBLE-PRECISION\r\n??L037:\r\n\tPUSHF\t\t\t;SAVE THE INTEGER/FLOATING FLAG\r\n\tCALL\tFRMEVL\t\t;EVALUATE THE TARGET VALUE FORMULA\r\n\tPOPF\t\t\t;POP OFF THE FLAG\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tJS\tSHORT ??L038\r\n\tJMP\tSNGFOR\t\t;POSITIVE MEANS SINGLE PRECISION \"FOR\"-LOOP\r\n??L038:\r\n\tCALL\tFRCINT\t\t;COERCE THE FINAL VALUE\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE IT ON THE STACK AND REGET THE\r\n\t\t\t\t;TEXT POINTER\r\n\tMOV\tDX,1\t\t;DEFAULT THE STEP TO BE 1\r\n\tMOV\tAL,BYTE PTR [BX]\t;SEE WHAT CHARACTER IS NEXT\r\n\tCMP\tAL,LOW OFFSET STEPTK\t;IS THERE A \"STEP\" CLAUSE?\r\n\tJNZ\tSHORT ??L039\r\n\tCALL\tGETINT\t\t;IF SO, READ THE STEP INTO [D,E]\r\n??L039:\r\n\tPUSH\tDX\t\t;PUT THE STEP ONTO THE STACK\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tXCHG\tBX,DX\t\t;STEP INTO [H,L]\r\n\tCALL\tISIGN\t\t;THE SIGN OF THE STEP INTO [A]\r\n\tJMP\tSHORT STPSGN\t;FINISH UP THE ENTRY\r\n\t\t\t\t;BY PUTTING THE SIGN OF THE STEP\r\n\t\t\t\t;AND THE DUMMY ENTRIES ON THE STACK\r\nSNGFOR: CALL\tFRCSNG\r\n\tCALL\tMOVRF\t\t;GET THE STUFF\r\n\tPOP\tBX\t\t;REGAIN TEXT POINTER\r\n\tPUSH\tCX\t\t;OPPOSITE OF PUSHR\r\n\tPUSH\tDX\t\t;SAVE THE SIGN OF THE INCREMENT\r\n\tMOV\tCX,OFFSET 201O*256\r\n\tMOV\tDH,CL\r\n\tMOV\tDL,DH\t\t;GET 1.0 IN THE REGISTERS\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET TERMINATING CHARACTER\r\n\tCMP\tAL,LOW OFFSET STEPTK\t;DO WE HAVE \"STEP\" ?\r\n\tMOV\tAL,LOW 1\t;SETUP DEFAULT SIGN\r\n\tJNZ\tSHORT ONEON\t;PUSH SOME CONSTANTS ON IF NOT\r\n\tCALL\tFRMCHK\t\t;DON'T NEED TO CHECK THE TYPE\r\n\tPUSH\tBX\r\n\tCALL\tFRCSNG\r\n\tCALL\tMOVRF\t\t;SET UP THE REGISTERS\r\n\tCALL\tSIGN\t\t;GET THE SIGN OF THE INCREMENT\r\nSTPSGN: POP\tBX\t\t;POP OFF THE TEXT POINTER\r\nONEON:\tPUSH\tCX\t\t;PUT VALUE ON BACKWARDS\r\n\tPUSH\tDX\t\t;OPPOSITE OF PUSHR\r\n;\r\n; If a step of zero is specified, change the sign of the step from\r\n; 0 to 2.  This will ensure an infinite loop which is what ANSI\r\n; requires.  This works because the test NEXT uses for loop\r\n; termination is SGN(current value-target value)-SGN(step)=0, which\r\n; could never be true for SGN(step)=2.\r\n; Prior to installation of this code, a FOR loop whose initial and\r\n; target values were equal, and whose step was zero was not executed\r\n; even once since the above test was met when NEXT was called to\r\n; scan for the matching NEXT.\r\n;\r\n\r\n\tOR\tAL,AL\t\t;Is the sign of the step zero?\r\n\tJNZ\tSHORT NT0STP\t;No, then the step is not zero.\r\n\tMOV\tAL,LOW 2\t;Yes, force an infinite loop by making\r\n\t\t\t\t;the sign of step a value such that\r\n\t\t\t\t;the loop termination test can never\r\n\t\t\t\t;be met.\r\nNT0STP:\r\n\tMOV\tCL,AL\t\t;[C]=SIGN OF STEP\r\n\tCALL\tGETYPR\t\t;MUST PUT ON INTEGER/SINGLE-PRECISION FLAG\r\n\t\t\t\t;MINUS IS SET FOR INTEGER CASE\r\n\tMOV\tCH,AL\t\t;HIGH BYTE = INTEGER/SINGLE PRECISION FLAG\r\n\tPUSH\tCX\t\t;SAVE FLAG AND SIGN OF STEP BOTH\r\n\tDEC\tBX\t\t;MAKE SURE THE \"FOR\" ENDED PROPERLY\r\n\tCALL\tCHRGTR\r\n\tJZ\tSHORT ??L040\r\n\tJMP\tSNERR\r\n??L040:\r\n\tCALL\tNXTSCN\t\t;SCAN UNTIL THE MATCHING \"NEXT\" IS FOUND\r\n\tCALL\tCHRGTR\t\t;FETCH FIRST CHARACTER OF \"NEXT\"\r\n\tPUSH\tBX\t\t;MAKE THE NEXT TXTPTR PART OF THE ENTRY\r\n\tPUSH\tBX\r\n\tMOV\tBX,NXTLIN\t;GET THE LINE NUMBER OF NEXT\r\n\tMOV\tCURLIN,BX\t;MAKE IT THE CURRENT LINE\r\n\tMOV\tBX,TEMP\t;GET THE POINTER TO THE VARIABLE BACK\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT THE POINTER TO THE VARIABLE\r\n\t\t\t\t;ONTO THE STACK AND RESTORE THE TEXT POINTER\r\n\tMOV\tCH,LOW OFFSET $FOR\t;FINISH UP \"FOR\"\r\n\tPUSH\tCX\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\t\t;SAVE THE CHARACTER\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\t\t;MAKE A STACK ENTRY TO SUBSTITUTE FOR \"NEWSTT\"\r\n\tEXTRN\tNEXTS:NEAR\r\n\tJMP\tNEXTS\t\t;GO EXECUTE \"NEXT\" WITH NXTFLG ZERO\r\nPUBLIC\tNXTCON\r\nNXTCON: MOV\tCH,LOW OFFSET $FOR\t;PUT A 'FOR' TOKEN ONTO THE STACK\r\n\tPUSH\tCX\r\n;       JMP     NEWSTT          ;ALL DONE\r\n\tPAGE\r\n\r\n\tSUBTTL NEW STATEMENT FETCHER\r\n;\r\n; BACK HERE FOR NEW STATEMENT. CHARACTER POINTED TO BY [H,L]\r\n; \":\" OR END-OF-LINE. THE ADDRESS OF THIS LOCATION IS\r\n; LEFT ON THE STACK WHEN A STATEMENT IS EXECUTED SO\r\n; IT CAN MERELY DO A RETURN WHEN IT IS DONE.\r\n;\r\n\tJMP\tSHORT NEWSTT\t;GO TO NEWSTT\r\nGOPRGD: JMP\tPRGEND\t\t;FIX SYNTAX ERROR IN UNENDED ERROR ROUTINE\r\nGOSNER: JMP\tSNERR\t\t;GIVE SYNTAX ERROR\r\nGORET:\tRET\t\t\t;SO PEOPLE CAN BRANCH HERE\r\nGONCHR: CALL\tCHRCON\t\t;REST OF CHRGET\r\n\tJMP\tSHORT GONE0\r\nGISMD$:\r\n\tEXTRN\tNEWSTX:NEAR\r\n\tCALL\tNEWSTX\t\t;Call extended statement dispatcher.\r\n\tJMP\tISMID$\t\t;TRY FOR LHS MID$ STATEMENT\r\n\r\nGONLET: JMP\tLET\t\t;GOTO LET CODE\r\n\r\nGONZER: OR\tAL,AL\r\n\tJNZ\tSHORT GOSNER\t;MUST BE A ZERO\r\n\tINC\tBX\r\nGONE4:\tMOV\tAL,BYTE PTR [BX]\t;CHECK POINTER TO SEE IF\r\n\t\t\t\t;IT IS ZERO, IF SO WE ARE AT THE\r\n\t\t\t\t;END OF THE PROGRAM\r\n\tINC\tBX\r\n\tOR\tAL,BYTE PTR [BX]\t;OR IN HIGH PART\r\n\tJZ\tSHORT GOPRGD\t;FIX SYNTAX ERROR IN UNENDED ERROR ROUTINE\r\n\tINC\tBX\r\n\tMOV\tDX,[BX]\r\n\tINC\tBX\r\n\tINS86\t211,26,CURLIN\t;MOV CURLIN,DX\r\n\t\t\t\t;SETUP CURLIN WITH THE CURRENT LINE #\r\n\tINS86\t366,6,TRCFLG\t;TRACING?\r\n\tDB\t377O\t\t;TESTBI TRCFLG,^O377\r\n\tJZ\tSHORT GONE\t;SKIP THIS PRINTING\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tMOV\tAL,LOW \"[\"      ;FORMAT THE LINE NUMBER\r\n\tCALL\tOUTDO\t\t;OUTPUT IT\r\n\tXCHG\tBX,DX\t\t;PUT LINE NUMBER TO PRINT IN [H,L]\r\n\tCALL\tLINPRT\t\t;PRINT THE LINE # IN [H,L]\r\n\tMOV\tAL,LOW \"]\"      ;SOME MORE FORMATING\r\n\tCALL\tOUTDO\r\n\tPOP\tBX\t\t;[D,E]=TEXT POINTER\r\n\tJMP\tSHORT GONE\t;CONTINUE EXECUTION\r\nPUBLIC\tNEWSTT\r\nNEWSTT:\r\n\tMOV\tAL,BYTE PTR ONGSBF\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT ??L041\r\nEXTRN\tGOTRP:NEAR\r\n\tCALL\tGOTRP\t\t;POSSIBLE ON GOSUB\r\n??L041:\r\nNWSTRT:\t\t\t;ENTRY FOR \"device ON\" STATEMENT\r\nNEWST1:\r\n\tINS86\t211,46,SAVSTK\t;MOV SAVSTK,SP\r\n\tMOV\tSAVTXT,BX\t;SAVE TEXT POINTER\r\n\tEXTRN\tCHKINT:NEAR\r\n\tCALL\tCHKINT\t\t;get key from keyboard & check for CTL C\r\n\t\t\t\t;if CTL-C, control doesn't return here\r\nGONGET: MOV\tAL,BYTE PTR [BX]\t;GET CURRENT CHARACTER\r\n\t\t\t\t;WHICH TERMINATED THE LAST STATEMENT\r\n\tCMP\tAL,LOW \":\"      ;IS IT A COLON?\r\n\tJNZ\tSHORT GONZER\t;SHOULD BE ZERO AT EOL\r\nPUBLIC\tGONE\r\nGONE:\tINC\tBX\t\t;DO PART OF CHRGETS WORK\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET BYTE\r\n\tCMP\tAL,LOW \":\"      ;COLON?\r\n\tJB\tSHORT GONCHR\t;DO REST OF CHRGET\r\nGONE0:\tMOV\tDX,OFFSET NEWSTT\t;PUSH ON A RETURN ADDRESS OF NEWSTT\r\n\tPUSH\tDX\t\t;STATEMENT\r\nGONE3:\tJZ\tSHORT GORET\t;IF A TERMINATOR TRY AGAIN\r\n\t\t\t\t;\"IF\" COMES HERE\r\nGONE2:\r\n\tSUB\tAL,LOW OFFSET $END\t;\"ON ... GOTO\" AND \"ON ... GOSUB\" COME HERE\r\n\tJB\tSHORT GONLET\t;MUST BE A LET\r\n\tCMP\tAL,LOW OFFSET NUMCMD\r\n\tJAE\tSHORT GISMD$\t;SEE IF LHS MID$ CASE\r\n\tINS86\t62,344\t\t;XOR AH,AH\r\n\tADD\tAL,AL\t\t;TURN BYTE INTO OFFSET\r\n\tINS86\t213,360\t;MOV SI,AX - GET OFFSET INTO [SI]\r\n\tINS86\t56\t\t;CODE SEGMENT OVERRIDE\r\n\tINS86\t377,264,STMDSP\t;PUSH STMDSP(SI) - PUSH ADDRESS\r\n\t\t\t\t;STATEMENT ON STACK\r\n;\r\n; NEWSTT FALLS INTO CHRGET. THIS FETCHES THE FIRST CHAR AFTER\r\n; THE STATEMENT TOKEN AND THE CHRGET'S \"RET\" DISPATCHES TO STATEMENT\r\n\tPAGE\r\n\r\n\tSUBTTL CHRGET - THE NEXT CHARACTER SCAN ROUTINE\r\nPUBLIC\tCHRGTR\r\nCHRGTR: INC\tBX\t\t;DUPLICATION OF CHRGET RST FOR SPEED\r\nPUBLIC\tCHRGT2\r\nCHRGT2: MOV\tAL,BYTE PTR [BX]\t;SEE CHRGET RST FOR EXPLANATION\r\n\tCMP\tAL,LOW \":\"\r\n\tJB\tSHORT CHRCON\r\n\tRET\r\n;\r\n; CHRCON IS THE CONTINUATION OF THE CHRGET RST\r\n;\r\n; IN EXTENDED, CHECK FOR INLINE CONSTANT AND IF ONE\r\n; MOVE IT INTO THE FAC & SET VALTYP APPROPRIATELY\r\n;\r\nPUBLIC\tOCTCON\r\n\tOCTCON=11\t\t;EMBEDED OCTAL CONSTANT\r\nPUBLIC\tHEXCON\r\n\tHEXCON=12\t\t;EMBEDED HEXA CONSTANT\r\n\tPTRCON=13\t\t;A LINE REFERENCE CONSTANT\r\n\tLINCON=14\t\t;A LINE NUMBER UNCONVERTED TO POINTER\r\n\tIN2CON=15\t\t;SINGLE BYTE (TWO BYTE WITH TOKEN) INTEGER\r\nPUBLIC\tCONCN2\r\n\tCONCN2=16\t\t;TOKEN RETURNED SECOND TYPE CONSTANT IS SCANNED.\r\nPUBLIC\tONECON\r\n\tONECON=17\t\t;FIRST OF 10 (0-9) INTEGER SPECIAL TOKENS\r\n\tINTCON=28\t\t;REGULAR 16 BIT TWO'S COMPLEMENT INT\r\n\tSNGCON=29\t\t;SINGLE PREC (4 BYTE) CONSTANT\r\nPUBLIC\tCONCON\r\n\tCONCON=30\t\t;TOKEN RETURNED BY CHRGET AFTER CONSTANT SCANNED\r\nPUBLIC\tDBLCON\r\n\tDBLCON=31\t\t;DOUBLE PREC (8 BYTE) CONSTANT\r\nPUBLIC\tDBLCN1\r\n\tDBLCN1=DBLCON+1\r\nPUBLIC\tCHRCON\r\nCHRCON: CMP\tAL,LOW \" \"      ;MUST SKIP SPACES\r\n\tJZ\tSHORT CHRGTR\t;GET ANOTHER CHARACTER\r\n\tJB\tSHORT LOWCHR\t;SOME FUNNY THING\r\n\tCMP\tAL,LOW \"0\"      ;ALL CHARACTERS GREATER THAN\r\n\t\t\t\t;\"9\" HAVE RETURNED, SO SEE IF NUMERIC\r\n\tCMC\t\t\t;MAKE NUMERICS HAVE CARRY ON\r\n\tINC\tAL\t\t;SET ZERO IF [A]=0\r\n\tDEC\tAL\r\n\tRET\r\nLOWCHR:\r\n\tOR\tAL,AL\t\t;NULL AT EOL?\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;YES, ALL DONE\r\n\tCMP\tAL,LOW OFFSET OCTCON\t;IS IT INLINE CONSTANT\r\n\tJB\tSHORT NOTCON\t;NO, SHOULD BE TAB OR LF\r\n\tCMP\tAL,LOW OFFSET CONCON\t;ARE WE TRYING TO RE-SCAN A CONSTANT?\r\n\tJNZ\tSHORT NTRSCC\t;NO.\r\n\tMOV\tAL,BYTE PTR CONSAV\t;GET THE SAVED CONSTANT TOKEN\r\n\tOR\tAL,AL\t\t;SET NON-ZERO, NON CARRY CC'S\r\n\tRET\t\t\t;ALL DONE\r\n\r\nNTRSCC: CMP\tAL,LOW OFFSET CONCN2\t;GOING TO SCAN PAST EMBEDDED CONSTANT?\r\n\tJZ\tSHORT CONSCN\t;YES SCAN AND GO ON\r\nNTRSC2: PUSH\tAX\t\t;SAVE TOKEN TO RETURN\r\n\tINC\tBX\t\t;POINT TO NUMBER\r\n\tMOV\tBYTE PTR CONSAV,AL\t;SAVE CURRENT TOKEN\r\n\tSUB\tAL,LOW OFFSET INTCON\t;IS IT LESS THAN INTEGER CONSTANT?\r\n\tJAE\tSHORT MAKTKN\t;NO, NOT LINE NUMBER CONSTANT\r\n\tSUB\tAL,LOW 365O\t;<ONECON-INTCON>&^O377\r\n\t\t\t\t;LESS THAN EMBEDDED 1 BYTER\r\n\tJAE\tSHORT ONEI\t;WAS ONE BYTER\r\n\tCMP\tAL,LOW OFFSET IN2CON-ONECON\t;IS IT TWO BYTER?\r\n\tJNZ\tSHORT FRCINC\t;NOPE, NORMAL INT\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET EMBEDED INT\r\n\tINC\tBX\t\t;POINT AFTER CONSTANT\r\nONEI:\tMOV\tCONTXT,BX\t;SAVE TEXT POINTER\r\n\tMOV\tBH,LOW 0\t;GET UPPER BYTE OF ZERO\r\nONEI2:\tMOV\tBL,AL\t\t;GET VALUE\r\n\tMOV\tCONLO,BX\t;SAVE CONSTANT VALUE\r\n\tMOV\tAL,LOW 2\t;GET VALTYPE\r\n\tMOV\tBYTE PTR CONTYP,AL\t;SET IT UP IN SAVE PLACE\r\n\tMOV\tBX,OFFSET NUMCON\t;POINT TO NUMBER RE-SCANNER\r\n\tPOP\tAX\t\t;GET BACK TOKEN\r\n\tOR\tAL,AL\t\t;MAKE SURE NUMBER FLAG RE-SET\r\n\tRET\t\t\t;RETURN TO CALLER\r\n\r\nFRCINC: MOV\tAL,BYTE PTR [BX]\t;GET LOW BYTE OF CONSTANT\r\n\tINC\tBX\t\t;POINT PAST IT\r\n\tINC\tBX\t\t;TO NEXT THING\r\n\tMOV\tCONTXT,BX\t;SAVE POINTER PAST\r\n\tDEC\tBX\t\t;BACK TO HIGH BYTE\r\n\tMOV\tBH,BYTE PTR [BX]\t;GET HIGH BYTE\r\n\tJMP\tSHORT ONEI2\t;FINISH SCANNING\r\n\r\nPUBLIC\tCONFAC\r\nCONFAC: CALL\tCONFC1\t\t;SCAN FLOATING CONSTANT\r\nCONSCN: MOV\tBX,CONTXT\t;GET SAVED TEXT POINTER\r\n\tJMP\tSHORT CHRGT2\t;AND SCAN THING AFTER CONSTANT\r\n\r\nMAKTKN: INC\tAL\t\t;CALCULATE VALTYPE\r\n\tROL\tAL,1\t\t;*2 TO GET VALTYPE 0=2, 1=4, 3=8\r\n\tMOV\tBYTE PTR CONTYP,AL\t;CONTYPE NOW SETUP\r\n\tPUSH\tDX\t\t;SAVE SOME RGS\r\n\tPUSH\tCX\r\n\tMOV\tDX,OFFSET CONLO ;PLACE TO STORE SAVED CONSTANT\r\n\tXCHG\tBX,DX\t\t;GET TEXT POINTER IN [D,E]\r\n\tMOV\tCH,AL\t\t;SETUP COUNTER IN [B]\r\n\tCALL\tMOVE1\t\t;MOVE DATA IN\r\n\tXCHG\tBX,DX\t\t;GET TEXT POINTER BACK\r\n\tPOP\tCX\t\t;RESTORE [B,C]\r\n\tPOP\tDX\r\nFININ1: MOV\tCONTXT,BX\t;SAVE THE GOOD TEXT POINTER\r\n\tPOP\tAX\t\t;RESTORE TOKEN\r\n\tMOV\tBX,OFFSET NUMCON\t;GET POINTER TO FAKE TEXT\r\n\tOR\tAL,AL\t\t;CLEAR CARRY SO OTHERS DONT THINK ITS A NUMBER\r\n\t\t\t\t;AND SET NON-ZERO SO NOT TERMINATOR\r\n\tRET\t\t\t;ALL DONE\r\nNOTCON:\r\n\tCMP\tAL,LOW 9\t;LINE FEED OR TAB?\r\n\tJNAE\tSHORT ??L042\r\n\tJMP\tCHRGTR\t\t;YES, EAT.\r\n??L042:\r\nNOTLFT: CMP\tAL,LOW \"0\"      ;ALL CHARACTERS GREATER THAN\r\n\t\t\t\t;\"9\" HAVE RETURNED, SO SEE IF NUMERIC\r\n\tCMC\t\t\t;MAKE NUMERICS HAVE CARRY ON\r\n\tINC\tAL\t\t;SET ZERO IF [A]=0\r\n\tDEC\tAL\r\n\tRET\r\n\r\n\r\n; THIS ROUTINE MOVES THE SAVED CONSTANT INTO THE FAC\r\nPUBLIC\tCONFC1\r\nCONFC1:\r\n\tMOV\tAL,BYTE PTR CONSAV\t;GET CONSTANT TOKEN\r\n\tCMP\tAL,LOW OFFSET LINCON+1\t;LINE# CONSTANT? (ERL=#)\r\n\tJAE\tSHORT NTLINE\t;NO\r\n\tCMP\tAL,LOW OFFSET PTRCON\t;LINE POINTER CONSTANT?\r\n\tJB\tSHORT NTLINE\t;NO\r\n\tMOV\tBX,CONLO\t;GET VALUE\r\n\tJNZ\tSHORT FLTLIN\t;MUST BE LINE NUMBER, NOT POINTER\r\n\tINC\tBX\t\t;POINT TO LINE #\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tMOV\tDL,BYTE PTR [BX]\t;GET LINE # IN [D,E]\r\n\tINC\tBX\r\n\tMOV\tDH,BYTE PTR [BX]\t;GET HIGH PART\r\n\tXCHG\tBX,DX\t\t;VALUE TO [H,L]\r\nFLTLIN: JMP\tINEG2\t\t;FLOAT IT\r\nNTLINE:\r\n\tMOV\tAL,BYTE PTR CONTYP\t;GET SAVED CONSTANT VALTYP\r\n\tMOV\tBYTE PTR VALTYP,AL\t;SAVE IN REAL VALTYP\r\n\tCMP\tAL,LOW 8\t;DOUBLE PRECISION\r\n\tJZ\tSHORT CONFDB\t;YES\r\n\tMOV\tBX,CONLO\t;GET LOW TWO BYTES OF FAC\r\n\tMOV\tFACLO,BX\t;SAVE THEM\r\n\tMOV\tBX,CONLO+2\t;GET NEXT TWO BYTES\r\n\tMOV\tFACLO+2,BX\t;SAVE THEM\r\n\tRET\r\n\r\nCONFDB: MOV\tBX,OFFSET CONLO ;GET POINTER TO SAVED CONSTANT AREA\r\n\tJMP\tVMOVFM\t\t;MOVE INTO FAC\r\n\tPAGE\r\n\r\n\tSUBTTL DEFSTR, DEFINT, DEFSNG, DEFDBL, INTIDX\r\nDEFSTR: MOV\tDL,LOW 3\t;DEFAULT SOME LETTERS TO STRING\r\n\tDB\t271O\t; SKIP  ;\"LXI B,\" OVER THE NEXT 2 BYTES\r\nDEFINT: MOV\tDL,LOW 2\t;DEFAULT SOME LETTERS TO INTEGER\r\n\tDB\t271O\t; SKIP  ;\"LXI B,\" OVER THE NEXT 2 BYTES\r\nDEFREA: MOV\tDL,LOW 4\t;DEFAULT SOME LETTERS TO SINGLE PRECISION\r\n\tDB\t271O\t; SKIP  ;\"LXI B,\" OVER THE NEXT 2 BYTES\r\nDEFDBL: MOV\tDL,LOW 8\t;DEFAULT SOME LETTERS TO DOUBLE PRECISION\r\nDEFCON: CALL\tISLET\t\t;MAKE SURE THE ARGUMENT IS A LETTER\r\n\tMOV\tCX,OFFSET SNERR ;PREPARE \"SYNTAX ERROR\" RETURN\r\n\tPUSH\tCX\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;RETURN IF THERES NO LETTER\r\n\tSUB\tAL,LOW \"A\"      ;MAKE AN OFFSET INTO DEFTBL\r\n\tMOV\tCL,AL\t\t;SAVE THE INITIAL OFFSET\r\n\tMOV\tCH,AL\t\t;ASSUME IT WILL BE THE FINAL OFFSET\r\n\tCALL\tCHRGTR\t\t;GET THE POSSIBLE DASH\r\n\tCMP\tAL,LOW OFFSET MINUTK\t;A RANGE ARGUMENT?\r\n\tJNZ\tSHORT NOTRNG\t;IF NOT, JUST ONE LETTER\r\n\tCALL\tCHRGTR\t\t;GET THE FINAL POSITION\r\n\tCALL\tISLET\t\t;CHECK FOR A LETTER\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;GIVE A SYNTAX ERROR IF IMPROPER\r\n\tSUB\tAL,LOW \"A\"      ;MAKE IT AN OFFSET\r\n\tMOV\tCH,AL\t\t;PUT THE FINAL IN [B]\r\n\tCALL\tCHRGTR\t\t;GET THE TERMINATOR\r\nNOTRNG: MOV\tAL,CH\t\t;GET THE FINAL CHARACTER\r\n\tSUB\tAL,CL\t\t;SUBTRACT THE START\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;IF IT'S LESS THATS NONSENSE\r\n\tINC\tAL\t\t;SETUP THE COUNT RIGHT\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE THE TEXT POINTER AND GET RID\r\n\t\t\t\t;OF THE \"SYNTAX ERROR\" RETURN\r\n\tMOV\tBX,OFFSET DEFTBL\t;POINT TO THE TABLE OF DEFAULTS\r\n\tMOV\tCH,LOW 0\t;SETUP A TWO-BYTE STARTING OFFSET\r\n\tADD\tBX,CX\t\t;MAKE [H,L] POINT TO THE FIRST ENTRY\r\n\t\t\t\t;TO BE MODIFIED\r\nLPDCHG: MOV\tBYTE PTR [BX],DL\t;MODIFY THE DEFAULT TABLE\r\n\tINC\tBX\r\n\tDEC\tAL\t\t;COUNT DOUNT THE NUMBER OF CHANGES TO MAKE\r\n\tJNZ\tSHORT LPDCHG\r\n\tPOP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET LAST CHARACTER\r\n\tCMP\tAL,LOW 44\t;IS IT A COMMA?\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;IF NOT STATEMENT SHOULD HAVE ENDED\r\n\tCALL\tCHRGTR\t\t;OTHERWISE SET UP TO SCAN NEW RANGE\r\n\tJMP\tSHORT DEFCON\r\n;\r\n; INTIDX READS A FORMULA FROM THE CURRENT POSITION AND\r\n; TURNS IT INTO A POSITIVE INTEGER\r\n; LEAVING THE RESULT IN [D,E].  NEGATIVE ARGUMENTS\r\n; ARE NOT ALLOWED. [H,L] POINTS TO THE TERMINATING\r\n; CHARACTER OF THE FORMULA ON RETURN.\r\n;\r\nPUBLIC\tINTIDX\r\nINTIDX: CALL\tCHRGTR\r\nPUBLIC\tINTID2\r\nINTID2: CALL\tGETIN2\t\t;READ A FORMULA AND GET THE\r\n\t\t\t\t;RESULT AS AN INTEGER IN [D,E]\r\n\t\t\t\t;ALSO SET THE CONDITION CODES BASED ON\r\n\t\t\t\t;THE HIGH ORDER OF THE RESULT\r\n\tJS\tSHORT $+3\r\n\tRET\t\t\t;DON'T ALLOW NEGATIVE NUMBERS\r\nPUBLIC\t$FCERR\r\n$FCERR:\r\nPUBLIC\tFCERR\r\nFCERR:\tMOV\tDL,LOW OFFSET ERRFC\t;TOO BIG. FUNCTION CALL ERROR\r\n\tJMP\tERROR\r\n\tPAGE\r\n\r\n\tSUBTTL LINSPC, LINGET\r\n;\r\n; LINSPC IS THE SAME AS LINGET EXCEPT IN ALLOWS THE\r\n; CURRENT LINE (.) SPECIFIER\r\n;\r\nPUBLIC\tLINSPC\r\nLINSPC: MOV\tAL,BYTE PTR [BX]\t;GET CHAR FROM MEMORY\r\n\tCMP\tAL,LOW \".\"      ;IS IT CURRENT LINE SPECIFIER\r\n\tMOV\tDX,DOT\t\t;GET CURRENT LINE #\r\n\tJNZ\tSHORT ??L043\r\n\tJMP\tCHRGTR\t\t;ALL DONE.\r\n??L043:\r\n;\r\n; LINGET READS A LINE # FROM THE CURRENT TEXT POSITION\r\n;\r\n; LINE NUMBERS RANGE FROM 0 TO 65529\r\n;\r\n; THE ANSWER IS RETURNED IN [D,E].\r\n; [H,L] IS UPDATED TO POINT TO THE TERMINATING CHARACTER\r\n; AND [A] CONTAINS THE TERMINATING CHARACTER WITH CONDITION\r\n; CODES SET UP TO REFLECT ITS VALUE.\r\n;\r\nPUBLIC\tLINGET\r\nLINGET: DEC\tBX\t\t;BACKSPACE PTR\r\nLINGT2: CALL\tCHRGTR\t\t;FETCH CHAR (GOBBLE LINE CONSTANTS)\r\n\tCMP\tAL,LOW OFFSET LINCON\t;EMBEDDED LINE CONSTANT?\r\n\tJZ\tSHORT LINGT3\t;YES, RETURN DOUBLE BYTE VALUE\r\n\tCMP\tAL,LOW OFFSET PTRCON\t;ALSO CHECK FOR POINTER\r\nLINGT3: MOV\tDX,CONLO\t;GET EMBEDDED LINE #\r\n\tJNZ\tSHORT ??L044\r\n\tJMP\tCHRGTR\t\t;EAT FOLLOWING CHAR\r\n??L044:\r\n\tXOR\tAL,AL\t\t;SET FLAG THAT NO CONSTANT WAS SEEN SO\r\n\tMOV\tBYTE PTR CONSAV,AL\t;GOTO2 DOESN'T CHANGE LINCON TO PTRCON\r\n\tMOV\tDX,0\t\t;ZERO ACCUMULATED LINE #\r\n\tDEC\tBX\t\t;BACK UP POINTER\r\nMORLIN:\r\n\tCALL\tCHRGTR\r\n\tJNAE\tSHORT $+3\r\n\tRET\r\n\tPUSH\tBX\r\n\tLAHF\r\n\tPUSH\tAX\r\n\tMOV\tBX,6552\t;SEE IF THE LINE # IS TOO BIG\r\n\tCMP\tBX,DX\r\n\tJB\tSHORT POPHSR\t;YES, DON'T SCAN ANY MORE DIGITS IF SO\r\n\t\t\t\t;FORCE CALLER TO SEE DIGIT AND GIVE SYNTAX ERROR\r\n\t\t\t\t;CAN'T JUST GO TO SYNTAX ERROR BECAUSE OF NON-FAST\r\n\t\t\t\t;RENUM WHICH CAN'T TERMINATE\r\n\tMOV\tBH,DH\t\t;SAVE [D,E]\r\n\tMOV\tBL,DL\r\n\tADD\tBX,DX\r\n\tADD\tBX,BX\r\n\tADD\tBX,DX\r\n\tADD\tBX,BX\t\t;PUTTING [D,E]*10 INTO [H,L]\r\n\tPOP\tAX\r\n\tSAHF\r\n\tSUB\tAL,LOW \"0\"\r\n\tMOV\tDL,AL\r\n\tMOV\tDH,LOW 0\r\n\tADD\tBX,DX\t\t;ADD THE NEW DIGIT\r\n\tXCHG\tBX,DX\r\n\tPOP\tBX\t\t;GET BACK TEXT POINTER\r\n\tJMP\tSHORT MORLIN\r\n\r\nPOPHSR: POP\tAX\r\n\tSAHF\t\t\t;GET OFF TERMINATING DIGIT\r\n\tPOP\tBX\t\t;GET BACK OLD TEXT POINTER\r\n\tRET\r\n\r\n\tPAGE\r\n\r\n\tSUBTTL RUN, GOTO, GOSUB, RETURN, DATA, REM\r\n\r\nRUN:\tJNZ\tSHORT ??L045\r\n\tJMP\tRUNC\t\t;NO LINE # ARGUMENT\r\n??L045:\r\n\tCMP\tAL,LOW OFFSET LINCON\t;LINE NUMBER CONSTANT?\r\n\tJZ\tSHORT CONRUN\t;YES\r\n\tCMP\tAL,LOW OFFSET PTRCON\t;LINE POINTER (RATHER UNLIKELY)\r\n\tJZ\tSHORT ??L046\r\n\tJMP\tLRUN\r\n??L046:\r\nCONRUN:\r\n\t\t\t\t;CLEAN UP,SET [H,L]=[TXTTAB]-1 AND\r\n\t\t\t\t;RETURN TO NEWSTT\r\n\tCALL\tCLEARC\t\t;CLEAN UP -- RESET THE STACK\r\n\t\t\t\t;DATPTR,VARIABLES ...\r\n\t\t\t\t;[H,L] IS THE ONLY THING PRESERVED\r\n\tMOV\tCX,OFFSET NEWSTT\r\n\tJMP\tSHORT RUNC2\t;PUT \"NEWSTT\" ON AND FALL INTO \"GOTO\"\r\n;\r\n; A \"GOSUB\" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT\r\n;\r\n; LOW ADDRESS\r\n;\r\n;       A TOKEN EQUAL TO $GOSUB 1 BYTE (1 word on 8086/8)\r\n;       Pointer to event flag if On Event Gosub - else 0000H\r\n;       THE LINE # OF THE THE \"GOSUB\" STATEMENT 2 BYTES\r\n;       A POINTER INTO THE TEXT OF THE \"GOSUB\" 2 BYTES\r\n;\r\n; HIGH ADDRESS\r\n;\r\n; TOTAL 5 BYTES\r\n;\r\nGOSUB:\tMOV\tCL,LOW 3\t;\"GOSUB\" ENTRIES ARE 5 BYTES LONG\r\n\tCALL\tGETSTK\t\t;MAKE SURE THERE IS ROOM\r\n\r\n\tCALL\tLINGET\t\t;MUST SCAN LINE NUMBER NOW\r\n\tPOP\tCX\t\t;POP OFF RETURN ADDRESS OF \"NEWSTT\"\r\n\tPUSH\tBX\t\t;REALLY PUSH THE TEXT POINTER\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tMOV\tBX,CURLIN\t;GET THE CURRENT LINE #\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT CURLIN ON THE STACK AND [H,L]=TEXT PTR\r\n\r\n\tMOV\tCX,0\t\t;so we know its not pointing to an\r\n\tPUSH\tCX\t\t; event flag (on event gosub ...)\r\n\tMOV\tCX,OFFSET NEWSTT\t;RESTORE [B,C] CORRECT VALUE\r\n\tMOV\tAL,LOW OFFSET $GOSUB\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\t\t;PUT GOSUB TOKEN ON THE STACK\r\n\tPUSH\tCX\t\t;SAVE NEWSTT ON STACK\r\n\tJMP\tSHORT GOTO2\t;HAVE NOW GRAB LINE # PROPERLY\r\n;ENTRY POINT FOR GOSUB WITH DE=LINE POINTER(NOT LINE NUMBER)\r\nPUBLIC\tGOSUB2\r\nGOSUB2:\r\n\tPUSH\tBX\t\t;PUT CURRENT TEXT POSN ON STACK\r\n\tPUSH\tBX\r\n\tMOV\tBX,CURLIN\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT CURLIN ON STACK\r\n\tPUSH\tCX\t\t;SAVE ADDRESS OF RETRUN MODIFY ADDRESS\r\n\tMOV\tAL,LOW OFFSET $GOSUB\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\t\t;PUT GOSUB ON STACK(FINAL GOSUB ENTRY)\r\n\tXCHG\tBX,DX\t\t;HL POINTS TO SUBROUTINE TEXT\r\n\tDEC\tBX\t\t;NEWSTT does INX H after loading SAVTXT\r\n\tMOV\tSAVTXT,BX\t;SAVE TXT PTR HERE, CURLIN LATER\r\n\tINC\tBX\r\n\tJMP\tGONE4\t\t;CONTINUE WITH SUBROUTINE\r\nRUNC2:\tPUSH\tCX\t\t;RESTORE RETURN ADDRESS\r\n\t\t\t\t;OF \"NEWSTT\"\r\n; AND SEARCH. IN THE 8K WE START WHERE WE\r\n; ARE IF WE ARE  GOING TO A FORWARD LOCATION.\r\n;\r\nGOTO:\tCALL\tLINGET\t\t;PICK UP THE LINE #\r\n\t\t\t\t;AND PUT IT IN [D,E]\r\nGOTO2:\r\n\tMOV\tAL,BYTE PTR CONSAV\t;GET TOKEN FOR LINE # BACK\r\n\tCMP\tAL,LOW OFFSET PTRCON\t;WAS IT A POINTER\r\n\tXCHG\tBX,DX\t\t;ASSUME SO\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF IT WAS, GO BACK TO NEWSTT\r\n\t\t\t\t;WITH [H,L] AS TEXT PTR\r\n\tCMP\tAL,LOW OFFSET LINCON\t;MAKE SURE IT IS A LINE NUMBER CONSTANT\r\n\tJZ\tSHORT ??L047\r\n\tJMP\tSNERR\t\t;IF NOT, BAD ARGUEM\b\bMENT PRESENT\r\n??L047:\r\n\tXCHG\tBX,DX\t\t;FLIP BACK IF NOT\r\n\tPUSH\tBX\t\t;SAVE CURRENT TEXT PTR ON STACK\r\n\tMOV\tBX,CONTXT\t;GET POINTER TO RIGHT AFTER CONSTANT\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE ON STACK, RESTORE CURRENT TEXT PTR\r\n\tCALL\tREM\t\t;SKIP TO THE END OF THIS LINE\r\n\tINC\tBX\t\t;POINT AT THE LINK BEYOND IT\r\n\tPUSH\tBX\t\t;SAVE THE POINTER\r\n\tMOV\tBX,CURLIN\t;GET THE CURRENT LINE #\r\n\tCMP\tBX,DX\t\t;[D,E] CONTAINS WHERE WE ARE GOING\r\n\t\t\t\t;[H,L] CONTAINS THE CURRENT LINE #\r\n\t\t\t\t;SO COMPARING THEM TELLS US WHETHER TO\r\n\t\t\t\t;START SEARCHING FROM WHERE WE ARE OR\r\n\t\t\t\t;TO START SEARCHING FROM THE BEGINNING\r\n\t\t\t\t;OF TXTTAB\r\n\tPOP\tBX\t\t;[H,L]=CURRENT POINTER\r\n\tJNB\tSHORT ??L048\r\n\tCALL\tLOOP\t\t;SEARCH FROM THIS POINT\r\n??L048:\r\n\tJNAE\tSHORT ??L049\r\n\tCALL\tFNDLIN\t\t;SEARCH FROM THE BEGINNING -- ACTUALLY\r\n??L049:\r\n\t\t\t\t;SEARCH AGAIN IF ABOVE SEARCH FAILED\r\n\tJAE\tSHORT USERR\t;LINE NOT FOUND, DEATH\r\n\tDEC\tCX\t\t;POINT TO ZERO AT END OF PREVIOUS LINE\r\n\tMOV\tAL,LOW OFFSET PTRCON\t;POINTER CONSTANT\r\n\tMOV\tBYTE PTR PTRFLG,AL\t;SET PTRFLG\r\n\tPOP\tBX\t\t;GET SAVED POINTER TO RIGHT AFTER CONSTANT\r\n\tCALL\tCONCH2\t\t;CHANGE LINE # TO PTR\r\n\tMOV\tBX,CX\t\t;[H,L]= POINTER TO THE START OF THE \r\n\t\t\t\t;MATCHED LINE\r\n\t\t\t\t;NOW POINTING AT THE FIRST BYTE OF THE POINTER\r\n\t\t\t\t;TO THE START OF THE NEXT LINE\r\n\tRET\t\t\t;GO TO NEWSTT\r\nPUBLIC\tUSERR\r\nUSERR:\tMOV\tDL,LOW OFFSET ERRUS\r\n\tJMP\tERROR\t\t;C=MATCH, SO IF NO MATCH WE\r\n\t\t\t\t;GIVE A \"US\" ERROR\r\n;\r\n; SEE \"GOSUB\" FOR THE FORMAT OF THE STACK ENTRY\r\n; \"RETURN\" RESTORES THE LINE NUMBER AND TEXT POINTER ON THE STACK\r\n; AFTER ELIMINATING ALL THE \"FOR\" ENTRIES IN FRONT OF THE \"GOSUB\"\r\n; ENTRY\r\n;\r\nRETURN:\r\n\tMOV\tTEMP,BX\t;SAVE TEXT POINTER TO SEE IF LINE #\r\n\tMOV\tDH,LOW 255\t;MAKE SURE THIS VARIABLE POINTER\r\n\t\t\t\t;IN [D,E] NEVER GETS MATCHED\r\n\tCALL\tFNDFOR\t\t;GO PAST ALL THE \"FOR\" ENTRIES\r\n\tCMP\tAL,LOW OFFSET $GOSUB\t;see if matching GOSUB found\r\n\tJZ\tSHORT RTRNOK\t;branch if so\r\n\tDEC\tBX\t\t;else error, reset stack pointer\r\n\tDEC\tBX\r\nRTRNOK:\r\n\tMOV\tSP,BX\t\t;UPDATE THE STACK\r\n\tMOV\tSAVSTK,BX\t;UPDATE SAVED STACK\r\n\tCMP\tAL,LOW OFFSET $GOSUB\r\n\tMOV\tDL,LOW OFFSET ERRRG\t;ERROR ERRRG IS \"RETURN WITHOUT GOSUB\"\r\n\tJZ\tSHORT ??L050\r\n\tJMP\tERROR\r\n??L050:\r\n\tF_TRPO=1\t\t;AFTER A GOSUB WHICH WAS A TR \bAP WE AUTOMATICALLY\r\n\tF_TRPS=2\t\t;STOP A REPEAT - THE RETURN RE\b\bCLEARS THE STOP BIT\r\n\tPOP\tBX\t\t;GET TRAP BITS REENABLE ADDRESS IF GOSUB\r\n\tOR\tBX,BX\t\t;see if [HL] is 0\r\n\tJZ\tSHORT NOTEVT\t;branch if not On Event Gosub\r\n\tMOV\tAL,BYTE PTR [BX]\t;WAS A TRAP ELSE JUST FAC ADDRESS\r\n\tAND\tAL,LOW OFFSET F_TRPO\t;IS TRAP ON?\r\n\tJZ\tSHORT ??L051\r\nEXTRN\tRSTTRP:NEAR\r\n\tCALL\tRSTTRP\t\t;IF YES, RESET STOP\r\n??L051:\r\nNOTEVT:\r\n\tPOP\tCX\t\t;GET LINE NUMBER OF GOSUB\r\n\tMOV\tBX,OFFSET NEWSTT\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT RETURN ADDRESS OF \"NEWSTT\"\r\n\t\t\t\t;BACK ONTO THE STACK. GET TEXT POINTER\r\n\t\t\t\t;FROM \"GOSUB\"\r\n\tXCHG\tBX,DX\r\n\tMOV\tBX,TEMP\t;GO BACK TO START\r\n\tLAHF\r\n\tDEC\tBX\r\n\tSAHF\r\n\tCALL\tCHRGTR\r\n\tJZ\tSHORT ??L052\r\n\tJMP\tGOTO\t\t;GO PROCESS RETURN [LINE #] \b\r\n??L052:\r\n\tMOV\tBH,CH\t\t;SET CURLIN FOR GOSUB\r\n\tMOV\tBL,CL\r\n\tMOV\tCURLIN,BX\r\n\tXCHG\tBX,DX\r\n\t\t\t\t;SKIP OVER SOME CHARACTERS\r\n\t\t\t\t;SINCE WHEN \"GOSUB\" STUCK THE TEXT POINTER\r\n\t\t\t\t;ONTO THE STACK THE LINE # ARGUMENT HADN'T\r\n\t\t\t\t;BEEN READ IN YET.\r\n\r\n\tDB\t260O\t; SKIP  ;\"MVI A,\" AROUND POP H.\r\nDATAH:\tPOP\tBX\t\t;GET TEXT POINTER OFF STACK\r\nPUBLIC\tDATA\r\nDATA:\r\n\tDB\t261O\t; SKIP  ;\"LXI B,\" TO PICK UP \":\" INTO C AND SKIP\r\n\tDB\t\":\"\t      ;\"DATA\" TERMINATES ON \":\"\r\n\t\t\t\t;AND 0. \":\" ONLY APPLIES IF\r\n\t\t\t\t;QUOTES HAVE MATCHED UP\r\n; ON 8086, USE JMPR TO GO TO REMZER BECAUSE NOP IS NOT ZERO OPCODE\r\n\tJMP\tSHORT REMZER\r\nELSES:\t\t\t\t;EXECUTED \"ELSE\"S ARE SKIPPED\r\n;\r\n; NOTE: REM MUST PRESERVE [D,E] BECAUSE OF \"GO TO\" AND ERROR\r\n;\r\nREM:\tDB\t261O\t; SKIP  ;\"MVI C,\"   THE ONLY TERMINATOR IS ZERO\r\n\tDB\t0\t; SKIP  ;NO-OPERATION\r\n\t\t\t\t;\"DATA\" ACTUALLY EXECUTES THIS 0\r\nREMZER: MOV\tCH,LOW 0\t;INSIDE QUOTES THE ONLY TERMINATOR IS ZERO\r\nEXCHQT: MOV\tAL,CL\t\t;WHEN A QUOTE IS SEEN THE SECOND\r\n\tMOV\tCL,CH\t\t;TERMINATOR IS TRADED, SO IN \"DATA\"\r\n\tMOV\tCH,AL\t\t;COLONS INSIDE QUOTATIONS WILL HAVE NO EFFECT\r\nREMER:\r\n\tDEC\tBX\t\t;NOP THE INX H IN CHRGET\r\nREMER1: CALL\tCHRGTR\t\t;GET A CHAR\r\n\tOR\tAL,AL\t\t;ZERO IS ALWAYS A TERMINATOR\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tCMP\tAL,CH\t\t;TEST FOR THE OTHER TERMINATOR\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tINC\tBX\r\n\tCMP\tAL,LOW 34\t;IS IT A QUOTE?\r\n\tJZ\tSHORT EXCHQT\t;IF SO TIME TO TRADE\r\n;\r\n; WHEN AN \"IF\" TAKES A FALSE BRANCH IT MUST FIND THE APPROPRIATE \"ELSE\"\r\n; TO START EXECUTION AT. \"DATA\" COUNTS THE NUMBER OF \"IF\"S\r\n; IT SEES SO THAT THE \"ELSE\" CODE CAN MATCH \"ELSE\"S WITH\r\n; \"IF\"S. THE COUNT IS KEPT IN [D]\r\n\t\t\t\t;BECAUSE THEN S HAVE TNO COLON\r\n\t\t\t\t;MULTIPLE IFS CAN BE FOUND IN A SINGLE\r\n\t\t\t\t;STATEMENT SCAN\r\n\t\t\t\t;THIS CAUSES A PROBLEM FOR 8-BIT DATA\r\n\t\t\t\t;IN UNQUOTED STRING DATA BECAUSE $IF MIGHT\r\n\t\t\t\t;BE MATCHED. FIX IS TO HAVE FALSIF IGNORE CHANGES\r\n\t\t\t\t;IN [D] IF ITS A DATA STATEMENT\r\n;\r\n\tINC\tAL\t\t;FUNCTION TOKEN?\r\n\tJZ\tSHORT REMER1\t;THEN IGNORE FOLLOWING FN NUMBER\r\n\tSUB\tAL,LOW OFFSET $IF+1\t;IS IT AN \"IF\"\r\n\tJNZ\tSHORT REMER\t;IF NOT, CONTINUE ON\r\n\tCMP\tAL,CH\t\t;SINCE \"REM\" CAN'T SMASH\r\n\t\t\t\t;[D,E] WE HAVE TO BE CAREFUL\r\n\t\t\t\t;SO ONLY IF B DOESN'T EQUAL\r\n\t\t\t\t;ZERO WE INCREMENT D. (THE \"IF\" COUNT)\r\n\tADC\tAL,DH\t\t;CARRY ON IF [B] NOT ZERO\r\n\tMOV\tDH,AL\t\t;UPDATE [D]\r\n\tJMP\tSHORT REMER\r\n\tPAGE\r\n\r\n\tSUBTTL \"LET\"\r\n\r\n; LETCON IS LET ENTRY POINT WITH VALTYP-3 IN [A]\r\n; BECAUSE GETYPR HAS BEEN CALLED\r\nPUBLIC\tLETCON\r\nLETCON: POP\tAX\t\t;GET VALTYPE OFF STACK\r\n\tADD\tAL,LOW 3\t;MAKE VALTYPE CORRECT\r\n\tJMP\tSHORT LETCN2\t;CONTINUE\r\nLET:\tCALL\tPTRGET\t\t;GET THE POINTER TO THE VARIABLE\r\n\t\t\t\t;NAMED IN TEXT AND PUT\r\n\t\t\t\t;IT INTO [D,E]\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET EQULTK\t;CHECK FOR \"=\"\r\n\t\t\t\t;MUST SET UP TEMP FOR \"FOR\"\r\n\tMOV\tTEMP,DX\t;UP HERE SO WHEN USER-FUNCTIONS\r\nREDINP: PUSH\tDX\r\n\tMOV\tAL,BYTE PTR VALTYP\r\n\tPUSH\tAX\r\n\tCALL\tFRMEVL\t\t;GET THE VALUE OF THE FORMULA\r\n\tPOP\tAX\t\t;GET THE VALTYP OF THE\r\n\t\t\t\t;VARIABLE INTO [A]\r\n\t\t\t\t;INTO FAC\r\nLETCN2: POP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;[H,L]=POINTER TO VARIABLE\r\n\t\t\t\t;TEXT POINTER TO ON TOP OF STACK\r\nINPCOM: MOV\tCH,AL\t\t;SAVE VALTYP\r\n\tMOV\tAL,BYTE PTR VALTYP\t;GET PRESENT VALTYPE\r\n\tCMP\tAL,CH\t\t;COMPARE THE TWO\r\n\tMOV\tAL,CH\t\t;GET BACK CURRENT\r\n\tJZ\tSHORT LETCN5\t;VALTYPE ALREADY SET UP, GO!\r\n\tCALL\tDOCNVF\t\t;FORCE VALTPES TO BE [A]'S\r\nPUBLIC\tLETCN4\r\nLETCN4: MOV\tAL,BYTE PTR VALTYP\t;GET VALTYPE\r\nLETCN5: MOV\tDX,OFFSET FACLO ;ASSUME THIS IS WHERE TO START MOVEING\r\n\tCMP\tAL,LOW 5\t;IS IT?\r\n\tJB\tSHORT LETCN6\t;YES\r\n\tMOV\tDX,OFFSET DFACLO\t;NO, USE D.P. FAC\r\nLETCN6: PUSH\tBX\t\t;SAVE THE POINTER AT THE VALUE POSITION\r\n\tCMP\tAL,LOW 3\t;STRING?\r\n\tJNZ\tSHORT COPNUM\t;NUMERIC, SO FORCE IT AND COPY\r\n; The following code makes a new copy of the string iff:\r\n; - the string data resides in keyboard or File buffers (since data\r\n;    in these buffers is temporary).\r\n; - the string data resides in string space (each string var must have\r\n;   its own copy of its string data)\r\n; - the source string descriptor is not a temporary descriptor.\r\n;\r\n\tMOV\tBX,FACLO\t;GET POINTER TO THE DESCRIPTOR OF THE RESULT\r\n\tPUSH\tBX\t\t;SAVE THE POINTER AT THE DESCRIPTOR\r\n\tINC\tBX\r\n\tMOV\tDX,[BX]\r\n\tMOV\tBX,TXTTAB\t;IF THE DATA IS IN BUF, OR IN DISK\r\n\tCMP\tBX,DX\t\t;SINCE BUF CHANGES ALL THE TIME\r\n\tJAE\tSHORT INBUFC\t;GO COPY, IF DATA REALLY IS IN BUF\r\n\tMOV\tBX,STREND\t;SEE IF IT POINTS INTO STRING SPACE\r\n\tCMP\tBX,DX\t\t;IF NOT DON'T COPY\r\n\tPOP\tDX\t\t;GET BACK THE POINTER AT THE DESCRIPTOR\r\n\tJAE\tSHORT DNTCPY\t;DON'T COPY LITERALS\r\n\tMOV\tBX,OFFSET DSCTMP-1\r\n\tCMP\tBX,DX\t\t;IS THE DESCRIPTOR A TEMP?\r\n\tJB\tSHORT INBFC0\t;NO, MUST POINT TO VARIABLE(COPY IT!)\r\n\tMOV\tBX,OFFSET TEMPST-1\r\n\tCMP\tBX,DX\r\n\tJB\tSHORT DNTCPY\t;YES, DON'T COPY\r\nINBFC0:\r\n\tDB\t260O\t; SKIP  ;SKIP THE NEXT BYTE WITH A \"MVI A,\"\r\nINBUFC: POP\tDX\t\t;GET THE POINTER TO THE DESCRIPTOR\r\n\t\t\t\t;IN [D,E]\r\n\tCALL\tFRETMS\t\t;FREE UP A TEMORARY POINTING INTO BUF\r\n\tXCHG\tBX,DX\t\t;STRCPY COPIES [H,L]\r\n\tCALL\tSTRCPY\t\t;COPY VARIABLES IN STRING SPACE OR\r\n\t\t\t\t;STRINGS WITH DATA IN BUF\r\nDNTCPY: CALL\tFRETMS\t\t;FREE UP THE TEMPORARY WITHOUT\r\n\t\t\t\t;FREEING UP ANY STRING SPACE\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;[H,L]=PLACE TO STORE THE DESCRIPTOR\r\n\t\t\t\t;LEAVE A NONSENSE ENTRY ON THE STACK,\r\n\t\t\t\t;SINCE THE \"POP D\" DOESN'T EVER\r\n\t\t\t\t;MATTER IN THIS CASE\r\nCOPNUM: CALL\tVMOVE\t\t;COPY A DESCRIPTOR OR A VALUE\r\n\tPOP\tDX\t\t;FOR \"FOR\" POP OFF A POINTER\r\n\t\t\t\t;AT THE LOOP VARIABLE INTO [D,E]\r\n\tPOP\tBX\t\t;GET THE TEXT POINTER BACK\r\n\tRET\r\n\tPAGE\r\n\r\n\tSUBTTL ON..GOTO, ON ERROR GOTO CODE\r\n\r\nONGOTO:\r\n\tCMP\tAL,LOW OFFSET $ERROR\t;\"ON...ERROR\"?\r\n\tJNZ\tSHORT NTOERR\t;NO.\r\n\tCALL\tCHRGTR\t\t;GET NEXT THING\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET $GOTO\t;MUST HAVE ...GOTO\r\n\tCALL\tLINGET\t\t;GET FOLLOWING LINE #\r\n\tOR\tDX,DX\t\t;IS LINE NUMBER ZERO?\r\n\tJZ\tSHORT RESTRP\t;IF ON ERROR GOTO 0, RESET TRAP\r\n\tCALL\tFNDLN1\t\t;SEE IF LINE EXISTS (SAVE [H,L] ON STACK)\r\n\tMOV\tDH,CH\t\t;GET POINTER TO LINE IN [D,E]\r\n\tMOV\tDL,CL\t\t;(LINK FIELD OF LINE)\r\n\tPOP\tBX\t\t;RESTORE [H,L]\r\n\tJNAE\tSHORT ??L053\r\n\tJMP\tUSERR\t\t;ERROR IF LINE NOT FOUND\r\n??L053:\r\nRESTRP: MOV\tONELIN,DX\t;SAVE POINTER TO LINE OR ZERO IF 0.\r\n\tJNB\tSHORT $+3\r\n\tRET\t\t\t;YOU WOULDN'T BELIEVE IT IF I TOLD YOU\r\n\tMOV\tAL,BYTE PTR ONEFLG\t;ARE WE IN AN \"ON...ERROR\" ROUTINE?\r\n\tOR\tAL,AL\t\t;SET CONDITION CODES\r\n\tMOV\tAL,DL\t\t;WANT AN EVEN STACK PTR. FOR 8086\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF NOT, HAVE ALREADY DISABLED TRAPPING.\r\n\tMOV\tAL,BYTE PTR ERRFLG\t;GET ERROR CODE\r\n\tMOV\tDL,AL\t\t;INTO E.\r\n\tJMP\tERRESM\t\t;FORCE THE ERROR TO HAPPEN\r\nNTOERR:\r\n\tEXTRN\tONGOTP:NEAR\r\n\tCALL\tONGOTP\t\t;CHECK FOR \"ON event GOSUB ...\"\r\n\tJB\tSHORT NTONGS\t;NOT AN event TRAP\r\n\tPUSH\tCX\t\t;SAVE START TRAP NUM FOR event(IN B)\r\n\t\t\t\t;AND NUMBER OF EVENTS POSSIBLE(IN C)\r\n\tCALL\tCHRGTR\t\t;SKIP OVER EVENT TOKEN\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET $GOSUB\t;Is ON event GOSUB nn,nn, ...\r\n\tXOR\tAL,AL\t\t;A = LINE NUMBER COUNT\r\nONGSB0: POP\tCX\r\n\tPUSH\tCX\r\n\tCMP\tAL,CL\t\t;WITHIN RANGE OF ALLOWBLE TRAPS?\r\n\tJNAE\tSHORT ??L054\r\n\tJMP\tSNERR\r\n??L054:\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\r\n\tCALL\tLINGET\r\n\tMOV\tAL,DH\r\n\tOR\tAL,DL\t\t;LINE 0?\r\n\tJZ\tSHORT RSTRAP\t;YES, JUST RESET PORT TRAP\r\n\tCALL\tFNDLN1\t\t;LINE NUMBER EXIST?(SAVE HL ON STACK)\r\n\tMOV\tDH,CH\r\n\tMOV\tDL,CL\r\n\tPOP\tBX\t\t;RESTORE TEXT POINTER\r\n\tJNAE\tSHORT ??L055\r\n\tJMP\tUSERR\t\t;ERROR IF LINE NOT FOUND\r\n??L055:\r\nRSTRAP: POP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\t\t;A = PORT NUMBER\r\n\tPOP\tCX\r\n\tLAHF\t\t\t; PUSH PSW\r\n\tXCHG\tAL,AH\r\n\tPUSH\tAX\r\n\tXCHG\tAL,AH\r\n\tADD\tAL,CH\r\n\tPUSH\tCX\r\n\tCALL\tSETGSB\t\t;SET GOSUB ADDR FOR THIS AREA IN A\r\n\tLAHF\r\n\tDEC\tBX\r\n\tSAHF\r\n\tCALL\tCHRGTR\r\n\tPOP\tCX\r\n\tPOP\tDX\r\n\tJNZ\tSHORT $+3\r\n\tRET\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\r\n\tPOP\tAX\t\t; POP PSW\r\n\tXCHG\tAL,AH\r\n\tSAHF\r\n\tINC\tAL\t\t;NEXT AREA\r\n\tJMP\tSHORT ONGSB0\t;DO NEXT GOSUB ADDR\r\nNTONGS:\r\n\r\n\tCALL\tGETBYT\t\t;GET VALUE INTO [E]\r\nPUBLIC\tNTONG1\r\nNTONG1:\t\t\t;jumped to by MENU statement\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE TERMINATOR BACK\r\n\tMOV\tCH,AL\t\t;SAVE THIS CHARACTER FOR LATER\r\n\tCMP\tAL,LOW OFFSET $GOSUB\t;AN \"ON ... GOSUB\" PERHAPS?\r\n\tJZ\tSHORT ISGOSU\t;YES, SOME FEATURE USE\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET $GOTO\t;OTHERWISE MUST BE \"GOTO\"\r\n\tDEC\tBX\t\t;BACK UP CHARACTER POINTER\r\nISGOSU: MOV\tCL,DL\t\t;GET COUNT INTO  [C]\r\nLOOPON: DEC\tCL\t\t;SEE IF ENOUGH SKIPS\r\n\tMOV\tAL,CH\t\t;PUT DISPATCH CHARACTER IN PLACE\r\n\tJNZ\tSHORT ??L056\r\n\tJMP\tGONE2\t\t;IF DONE, GO OFF\r\n??L056:\r\n\tCALL\tLINGT2\t\t;SKIP OVER A LINE #\r\n\tCMP\tAL,LOW 44\t;A COMMA\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;IF A COMMA DOESN'T DELIMIT THE END OF\r\n\t\t\t\t;THE CURRENT LINE # WE MUST BE THE END OF THE LINE\r\n\tJMP\tSHORT LOOPON\t;CONTINUE GOBBLING LINE #S\r\n\r\n\tPAGE\r\n\r\n\tSUBTTL RESUME, ERROR STATEMENT CODE\r\nRESUME:\r\n\tMOV\tAL,BYTE PTR ONEFLG\t;Get flag\r\n\tOR\tAL,AL\t\t;Were we called by an ON ERROR?\r\n\tJNZ\tSHORT ??L057\r\n\tJMP\tREERR\t\t;Not in an ON ERROR routine\r\n??L057:\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR ERRFLG,AL\t;CLEAR ERROR FLAG SO ^C DOESN'T GIVE ERROR\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CURRENT CHAR BACK\r\n\tCMP\tAL,LOW OFFSET $NEXT\t;RESUME NEXT?\r\n\tJZ\tSHORT RESNXT\t;YUP.\r\n\tCALL\tLINGET\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;SHOULD TERMINATE\r\n\tOR\tDX,DX\t\t;IS LINE NUMBER ZERO?\r\n\tJZ\tSHORT RES0\t;Yep, go set non-zero CC's\r\n\tCALL\tGOTO2\t\t;Go find line\r\n\tXOR\tAL,AL\t\t;Now zero flag (otherwise RESUME non-\r\n\t\t\t\t; existent line number would be trapped\r\n\t\t\t\t; by the ON ERROR routine and we would\r\n\t\t\t\t; loop infinitely).\r\n\tMOV\tBYTE PTR ONEFLG,AL\r\n\tRET\r\n;\r\nRESNXT: CALL\tCHRGTR\t\t;MUST TERMINATE\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;BLOW HIM UP\r\n\tJMP\tSHORT RESTXT\r\n;\r\nRES0:\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR ONEFLG,AL\t;clear RESUME-TRAP flag\r\n\tINC\tAL\t\t;Set nonzero CC's\r\nRESTXT: MOV\tBX,ERRTXT\t;GET POINTER INTO LINE.\r\n\tXCHG\tBX,DX\t\t;SAVE ERRTXT IN [D,E]\r\n\tMOV\tBX,ERRLIN\t;GET LINE #\r\n\tMOV\tCURLIN,BX\t;SAVE IN CURRENT LINE #\r\n\tXCHG\tBX,DX\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;GO TO NEWSTT IF JUST \"RESUME\"\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET \":\" OR LINE HEADER\r\n\tOR\tAL,AL\t\t;SET CC\r\n\tJNZ\tSHORT NOTBGL\t;#0 MEANS MUST BE \":\"\r\n\tINC\tBX\t\t;SKIP HEADER\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tINC\tBX\r\nNOTBGL: INC\tBX\t\t;POINT TO START OF THIS STATEMENT\r\n\tXOR\tAL,AL\t\t;Now zero flag (otherwise RESUME non-\r\n\t\t\t\t; existent line number would be trapped\r\n\t\t\t\t; by the ON ERROR routine and we would\r\n\t\t\t\t; loop infinitely).\r\n\tMOV\tBYTE PTR ONEFLG,AL\r\n\tJMP\tDATA\t\t;GET NEXT STMT\r\n\r\n; THIS IS THE ERROR <CODE> STATEMENT WHICH FORCES\r\n; AN ERROR OF TYPE <CODE> TO OCCUR\r\n; <CODE> MUST BE .GE. 0 AND .LE. 255\r\nERRORS: CALL\tGETBYT\t\t;GET THE PARAM\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;SHOULD HAVE TERMINATED\r\n\tOR\tAL,AL\t\t;ERROR CODE 0?\r\n\tJNZ\tSHORT ??L058\r\n\tJMP\tFCERR\t\t;YES, ERROR IN ITSELF\r\n??L058:\r\nGOERR:\tJMP\tERROR\t\t;FORCE AN ERROR\r\n\tPAGE\r\n\r\n\tSUBTTL AUTO COMMAND\r\n; THE AUTO [BEGGINNING LINE[,[INCREMENT]]]\r\n; COMMAND IS USED TO AUTOMATICALLY GENERATE LINE NUMBERS\r\n; FOR LINES TO BE INSERTED. BEGINNING LINE IS\r\n; USED TO SPECIFY THE INITAL LINE (10 IS ASSUMED IF OMMITED)\r\n; AND THE INCREMENT IS USED TO SPECIFY THE INCREMENT USED\r\n; TO GENERATE THE NEXT LINE #. IF ONLY A COMMA IS USED AFTER THE\r\n; BEGGINING LINE, THE OLD INCREMENT IS USED.\r\nAUTO:\tMOV\tDX,10\t\t;ASSUME INITIAL LINE # OF 10\r\n\tPUSH\tDX\t\t;SAVE IT\r\n\tJZ\tSHORT SNGAUT\t;IF END OF COMMAND USE 10,10\r\n\tCALL\tLINSPC\t\t;GET LINE #, ALLOW USE OF . FOR CURRENT LINE\r\n\tXCHG\tBX,DX\t\t;GET TXT PTR IN [D,E]\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT INIT ON STACK, GET 10 IN [H,L]\r\n\tJZ\tSHORT SNGAU1\t;IF TERMINATOR, USE INC OF 10\r\n\tXCHG\tBX,DX\t\t;GET TEXT PTR BACK IN [H,L]\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;COMMA MUST FOLLOW\r\n\tMOV\tDX,AUTINC\t;GET PREVIOUS INC\r\n\tJZ\tSHORT SNGAUT\t;USE PREVIOUS INC IF TERMINATOR\r\n\tCALL\tLINGET\t\t;GET INC\r\n\tJZ\tSHORT ??L059\r\n\tJMP\tSNERR\t\t;SHOULD HAVE FINISHED.\r\n??L059:\r\nSNGAUT: XCHG\tBX,DX\t\t;GET INC IN [H,L]\r\nSNGAU1: MOV\tAL,BH\t\t;SEE IF ZERO\r\n\tOR\tAL,BL\r\n\tJNZ\tSHORT ??L060\r\n\tJMP\tFCERR\t\t;ZERO INC GIVES FCERR\r\n??L060:\r\n\tMOV\tAUTINC,BX\t;SAVE INCREMENT\r\n\tMOV\tBYTE PTR AUTFLG,AL\t;SET FLAG TO USE AUTO IN MAIN CODE.\r\n\tPOP\tBX\t\t;GET INITIAL LINE #\r\n\tMOV\tAUTLIN,BX\t;SAVE IN INTIAL LINE\r\n\tPOP\tCX\t\t;GET RID OF NEWSTT ADDR\r\n\tJMP\tMAIN\t\t;JUMP INTO MAIN CODE (FOR REST SEE AFTER MAIN:)\r\n\tPAGE\r\n\r\n\tSUBTTL IF ... THEN CODE\r\nIFS:\tCALL\tFRMEVL\t\t;EVALUATE A FORMULA\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET TERMINATING CHARACTER OF FORMULA\r\n\tCMP\tAL,LOW 44\r\n\tJNZ\tSHORT ??L061\r\n\tCALL\tCHRGTR\t\t;IF SO SKIP IT\r\n??L061:\r\n\tCMP\tAL,LOW OFFSET $GOTO\t;ALLOW \"GOTO\" AS WELL\r\n\tJZ\tSHORT OKGOTO\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET THENTK\t;MUST HAVE A THEN\r\n\tDEC\tBX\r\nOKGOTO:\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tCALL\tVSIGN\r\n\tPOP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tJZ\tSHORT FALSIF\t;HANDLE POSSIBLE \"ELSE\"\r\nDOCOND: CALL\tCHRGTR\t\t;PICK UP THE FIRST LINE # CHARACTER\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;RETURN FOR \"THEN :\" OR \"ELSE :\"\r\n\tCMP\tAL,LOW OFFSET LINCON\t;LINE NUMBER CONSTANT?\r\n\tJNZ\tSHORT ??L062\r\n\tJMP\tGOTO\t\t;DO A \"GOTO\"\r\n??L062:\r\n\tCMP\tAL,LOW OFFSET PTRCON\t;POINTER CONSTANT\r\n\tJZ\tSHORT ??L063\r\n\tJMP\tGONE2\t\t;EXECUTE STATEMENT, NOT GOTO\r\n??L063:\r\n\tMOV\tBX,CONLO\t;GET TEXT POINTER\r\n\tRET\t\t\t;FETCH NEW STATMENT\r\n;\r\n; \"ELSE\" HANDLER. HERE ON FALSE \"IF\" CONDITION\r\n;\r\nFALSIF: MOV\tDH,LOW 1\t;NUMBER OF \"ELSE\"S THAT MUST\r\n\t\t\t\t;BE SEEN. \"DATA\" INCREMENTS THIS\r\n\t\t\t\t;COUNT EVERY TIME AN \"IF\" IS SEEN\r\nSKPMRF: CALL\tDATA\t\t;SKIP A STATEMENT\r\n\t\t\t\t;\":\" IS STUCK IN FRONT OF \"ELSE\"S\r\n\t\t\t\t;SO THAT \"DATA\" WILL STOP BEFORE \"ELSE\" CLAUSES\r\n\tOR\tAL,AL\t\t;END OF LINE?\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;IF SO, NO \"ELSE\" CLAUSE\r\n\tCALL\tCHRGTR\t\t;SEE IF WE HIT AN \"ELSE\"\r\n\tCMP\tAL,LOW OFFSET $ELSE\r\n\tJNZ\tSHORT SKPMRF\t;NO, STILL IN THE \"THEN\" CLAUSE\r\n\tDEC\tDH\t\t;DECREMENT THE NUMBER OF \"ELSE\"S THAT\r\n\t\t\t\t;MUST BE SEEN\r\n\tJNZ\tSHORT SKPMRF\t;SKIP MORE IF HAVEN'T SEEN\r\n\t\t\t\t;ENOUGH\r\n\tJMP\tSHORT DOCOND\t;FOUND THE RIGHT \"ELSE\" -- GO EXECUTE\r\n\r\n\tPAGE\r\n\r\n\tSUBTTL PRINT CODE\r\n\r\n\tEXTRN\tLPRINT:NEAR,LPRINT:NEAR,FINPRT:NEAR\r\n\r\n\tSUBTTL LINE INPUT, INPUT AND READ CODE\r\nLINE:\r\n\tEXTRN\tGLINE:NEAR\r\n\tCMP\tAL,LOW OFFSET $INPUT\r\n\tJZ\tSHORT ??L064\r\n\tJMP\tGLINE\t\t;MUST BE GRAPHICS TYPE LINE\r\n??L064:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET $INPUT\r\n\tCMP\tAL,LOW \"#\"      ;SEE IF THERE IS A FILE NUMBER\r\n\tEXTRN\tDLINE:NEAR\r\n\tJNZ\tSHORT ??L065\r\n\tJMP\tDLINE\t\t;DO DISK INPUT LINE\r\n??L065:\r\n\tCALL\tSCNSEM\t\t;SCAN SEMICOLON FOR NO-CR\r\n\tCALL\tQTINP\t\t;PRINT QUOTED STRING IF ONE\r\n\tCALL\tPTRGET\t\t;READ STRING TO STORE INTO\r\n\tCALL\tCHKSTR\t\t;MAKE SURE ITS A STRING\r\n\tPUSH\tDX\t\t;SAVE POINTER AT VARIABLE\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tEXTRN\tSINLIN:NEAR\r\n\tCALL\tSINLIN\t\t;READ A LINE OF INPUT\r\n\tPOP\tDX\t\t;GET TEXT POINTER\r\n\tPOP\tCX\t\t;GET POINTER AT VARIABLE\r\n\tJAE\tSHORT ??L066\r\n\tJMP\tSTPEND\t\t;IF CONTROL-C, STOP\r\n??L066:\r\nRELINE: PUSH\tCX\t\t;SAVE BACK VARIABLE POINTER\r\n\tPUSH\tDX\t\t;SAVE TEXT POINTER\r\n\tMOV\tCH,LOW 0\t;SETUP ZERO AS ONLY TERMINATOR\r\n\tCALL\tSTRLT3\t\t;LITERALIZE THE INPUT\r\n\tPOP\tBX\t\t;RESTORE [H,L]=TEXT POINTER\r\n\tMOV\tAL,LOW 3\t;SET THREE FOR STRING\r\n\tJMP\tLETCN2\t\t;DO THE ASSIGNMENT\r\n\r\nTRYAGN:\r\n\tDB\"?Redo from start\"\r\n\tACRLF\r\n\tDB\t0\r\n;\r\n; HERE WHEN PASSING OVER STRING LITERAL IN SUBSCRIPT OF VARIABLE IN INPUT LIST\r\n; ON THE FIRST PASS OF INPUT CHECKING FOR TYPE MATCH AND NUMBER\r\n;\r\nSCNSTR: INC\tBX\t\t;LOOK AT THE NEXT CHARACTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;FETCH IT\r\n\tOR\tAL,AL\t\t;END OF LINE?\r\n\tJNZ\tSHORT ??L067\r\n\tJMP\tSNERR\t\t;ENDING IN STRING IN SUBSCRIPT IS BAD SYNTAX\r\n??L067:\r\n\tCMP\tAL,LOW 34\t;ONLY OTHER TERMINATOR IS QUOTE\r\n\tJNZ\tSHORT SCNSTR\t;CONTINUE UNTIL QUOTE OR 0 IS FOUND\r\n\tJMP\tSCNCON\t\t;CONTINUE MATCHING PARENS SINCE STRING ENDED\r\n\r\nINPBAK: POP\tBX\t\t;GET RID OF PASS1 DATA POINTER\r\n\tPOP\tBX\t\t;GET RID OF PASS2 DATA POINTER\r\n\tJMP\tSHORT RDOIN2\t;GET RID OF PASS2 VARLST POINTER AND RETRY\r\n;\r\n; HERE WHEN THE DATA THAT WAS TYPED IN OR IN \"DATA\" STATEMENTS\r\n; IS IMPROPERLY FORMATTED. FOR \"INPUT\" WE START AGAIN.\r\n; FOR \"READ\" WE GIVE A SYNTAX ERROR AT THE DATA LINE\r\n;\r\nTRMNOK:\r\n\tMOV\tAL,BYTE PTR FLGINP\t;WAS IT READ OR INPUT?\r\n\tOR\tAL,AL\t\t;ZERO=INPUT\r\n\tJZ\tSHORT ??L068\r\n\tJMP\tDATSNE\t\t;GIVE ERROR AT DATA LINE\r\n??L068:\r\nRDOIN2: POP\tCX\t\t;GET RID OF THE POINTER INTO THE VARIABLE LIST\r\nRDOINP:\r\n\tMOV\tBX,OFFSET TRYAGN\r\n\tCALL\tSTROUT\t\t;PRINT \"?REDO FROM START\"\r\n\tMOV\tBX,SAVTXT\t;GET SAVED TEXT POINTER\r\n\tRET\t\t\t;GO BACK TO NEWSTT\r\n\t\t\t\t;OF THE \"INPUT\" STATEMENT\r\nFILSTI: CALL\tFILINP\r\n\tPUSH\tBX\t\t;PUT THE TEXT POINTER ON THE STACK\r\n\tMOV\tBX,OFFSET BUFMIN\t;POINT AT A COMMA\r\n\tJMP\tINPCN3\r\nINPUT:\r\n\r\n\tCMP\tAL,LOW \"#\"\r\n\tJZ\tSHORT FILSTI\r\n\tCALL\tSCNSEM\t\t;SCAN SEMICOLON FOR NO-CR\r\n\tMOV\tCX,OFFSET NOTQTI\t;WHERE TO GO\r\n\tPUSH\tCX\t\t;WHEN DONE WITH QUOTED STRING\r\nQTINP:\tCMP\tAL,LOW 34\t;IS IT A QUOTE?\r\n\tMOV\tAL,LOW 0\t;BE TALKATIVE\r\n\tMOV\tBYTE PTR CNTOFL,AL\t;FORCE OUTPUT\r\n\tMOV\tAL,LOW 255\t;MAKE NON-ZERO VALUE\r\n\tMOV\tBYTE PTR TEMPA+1,AL\t;FLAG TO DO \"? \"\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;JUST RETURN\r\n\tCALL\tSTRLTI\t\t;MAKE THE MESSAGE A STRING\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR\r\n\tCMP\tAL,LOW 54O\t;COMMA?\r\n\tJNZ\tSHORT NTICMA\t;NO\r\n\tXOR\tAL,AL\t\t;FLAG NOT TO DO IT\r\n\tMOV\tBYTE PTR TEMPA+1,AL\r\n\tCALL\tCHRGTR\t\t;FETCH NEXT CHAR\r\n\tJMP\tSHORT INPCMA\t;CONTINUE\r\nNTICMA:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 59\t;MUST END WITH SEMI-COLON\r\nINPCMA:\r\n\tPUSH\tBX\t\t;REMEMBER WHERE IT ENDED\r\n\tCALL\tSTRPRT\t\t;PRINT IT OUT\r\n\tPOP\tBX\t\t;GET BACK SAVED TEXT PTR\r\n\tRET\t\t\t;ALL DONE\r\nNOTQTI:\r\n\tPUSH\tBX\r\nGETAGN:\r\n\tMOV\tAL,BYTE PTR TEMPA+1\t;DO \"? \"\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT SUPPRS\t;THEN SUPPRESS \"?\"\r\n\tMOV\tAL,LOW \"?\"      ;TYPE \"?\" AND INPUT A LINE OF TEXT\r\n\tCALL\tOUTDO\r\n\tMOV\tAL,LOW \" \"\r\n\tCALL\tOUTDO\r\nSUPPRS:\r\n\tCALL\tSINLIN\r\n\tPOP\tCX\t\t;TAKE OFF SINCE MAYBE LEAVING\r\n\tJAE\tSHORT ??L069\r\n\tJMP\tSTPEND\t\t;IF EMPTY LEAVE\r\n??L069:\r\n\tPUSH\tCX\t\t;PUT BACK  SINCE DIDN'T LEAVE\r\n;\r\n; THIS IS THE FIRST PASS DICTATED BY ANSI REQUIRMENT THAN NO VALUES BE ASSIGNED \r\n; BEFORE CHECKING TYPE AND NUMBER. THE VARIABLE LIST IS SCANNED WITHOUT EVALUATING\r\n; SUBSCRIPTS AND THE INPUT IS SCANNED TO GET ITS TYPE. NO ASSIGNMENT\r\n; IS DONE\r\n;\r\n\tXOR\tAL,AL\t\t;FLAG AS INPUT SO SCNVAL WILL WORK\r\n\tMOV\tBYTE PTR FLGINP,AL\t;WHEN SCANNING STRINGS WITH \":\"\r\n\tMOV\tBYTE PTR [BX],LOW 44\t;PUT A COMMA IN FRONT OF BUF\r\n\tXCHG\tBX,DX\t\t;SAVE DATA POINTER IN [D,E]\r\n\tPOP\tBX\t\t;GET THE VARLST POINTER INTO [H,L]\r\n\tPUSH\tBX\t\t;RESAVE THE VARLST POINTER\r\n\tPUSH\tDX\t\t;SAVE A COPY OF THE DATA POINTER FOR PASS2\r\n\tPUSH\tDX\t\t;SAVE THE DATA POINTER FOR PASS1\r\n\tDEC\tBX\t\t;READ THE FIRST VARIABLE NAME\r\nVARLOP: MOV\tAL,LOW 128\t;DON'T ALLOW SUBSCRIPTS -- RETURN POINTING TO \"(\"\r\n\tMOV\tBYTE PTR SUBFLG,AL\r\n\tCALL\tCHRGTR\t\t;ADVANCE TEXT POINTER\r\n\tEXTRN\tPTRGTN:NEAR\r\n\tCALL\tPTRGTN\t\t;SCAN NAME AND RETURN POINTER IN [D,E]\r\n\tMOV\tAL,BYTE PTR [BX]\t;SEE IF IT ENDED ON \"(\"\r\n\tDEC\tBX\t\t;RESCAN THE TERMINATOR\r\n\tCMP\tAL,LOW \"[\"      ;allow brackets also\r\n\tJZ\tSHORT SCNBKT\r\n\tCMP\tAL,LOW \"(\"      ;ARRAY OR NOT?\r\n\tJNZ\tSHORT ENDSCN\t;IF NOT, VARIABLE NAME IS DONE\r\nSCNBKT: INC\tBX\t\t;NOW SCAN THE SUBSCRIPT EXPRESSION\r\n\tMOV\tCH,LOW 0\t;INITIALIZE THE PAREN COUNT\r\nSCNOPN: INC\tCH\t\t;UP THE COUNT FOR EVERY \"(\"\r\nSCNCON: CALL\tCHRGTR\t\t;GET THE NEXT CHARACTER\r\n\tJNZ\tSHORT ??L070\r\n\tJMP\tSNERR\t\t;SHOULDN'T END STATEMENT IN EXPRESSION\r\n??L070:\r\n\tCMP\tAL,LOW 34\t;IS THERE A QUOTED STRING CONSTANT\r\n\tJNZ\tSHORT ??L071\r\n\tJMP\tSCNSTR\t\t;GO SCAN THE ENDTIRE CONSTANT (MAY CONTAIN PARENS)\r\n??L071:\r\n\tCMP\tAL,LOW \"(\"      ;ANOTHER LEVEL OF NESTING?\r\n\tJZ\tSHORT SCNOPN\t;INCREMENT COUTN AND KEEP SCANNING\r\n\tCMP\tAL,LOW \"[\"      ;left bracket?\r\n\tJZ\tSHORT SCNCON\t;yes, ok\r\n\tCMP\tAL,LOW \"]\"      ;left bracket?\r\n\tJZ\tSHORT LEFPRN\t;yes\r\n\tCMP\tAL,LOW \")\"      ;ONE LESS LEVEL OF PARENS?\r\n\tJNZ\tSHORT SCNCON\t;NO, KEEP SCANNING\r\n\t\t\t\t;DECREMENT PAREN COUNT. OUT OF SUBSCRIPT?\r\nLEFPRN: DEC\tCH\r\n\tJNZ\tSHORT SCNCON\t;IF NOT AT ZERO LEVEL, KEEP SCANNING\r\nENDSCN: CALL\tCHRGTR\t\t;GET TERMINATING CHARACTER\r\n\tJZ\tSHORT OKVLST\t;LAST VARIABLE IN INPUT LIST\r\n\tCMP\tAL,LOW 44\t;OTHERWISE IT MUST BE A COMMA\r\n\tJZ\tSHORT ??L072\r\n\tJMP\tSNERR\t\t;BADLY FORMED INPUT -- SYNTAX ERROR\r\n??L072:\r\nOKVLST: POP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE THE VARLST POINTER \r\n\t\t\t\t;GET THE DATA POINTER INTO [H,L]\r\n\tMOV\tAL,BYTE PTR [BX]\t;DATA SHOULD ALWAYS HAVE A LEADING COMMA\r\n\tCMP\tAL,LOW 44\t;IS IT PROPERLY FORMED?\r\n\tJZ\tSHORT ??L073\r\n\tJMP\tINPBAK\t\t;NO, ASK FOR COMPLETE REINPUT\r\n??L073:\r\n\tMOV\tAL,LOW 1\t;SET OVCSTR=1\r\n\tMOV\tBYTE PTR OVCSTR,AL\r\n\tMOV\tBYTE PTR FLGSCN,AL\t;Flag to SCNVAL that call is from INPUT\r\n\tCALL\tSCNVAL\t\t;GO INTO PASS2 CODE AND SCAN A VALUE\r\n\tMOV\tAL,BYTE PTR FLGSCN\r\n\tDEC\tAL\t\t;Restore flag\r\n\tMOV\tBYTE PTR FLGSCN,AL\r\n\tMOV\tAL,BYTE PTR OVCSTR\t;SEE IF IT WAS TOO BIG\r\n\tDEC\tAL\r\n\tJZ\tSHORT ??L074\r\n\tJMP\tINPBAK\r\n??L074:\r\n\tPUSH\tBX\t\t;SAVE THE RETURNED DATA POINTER\r\n\tCALL\tGETYPR\t\t;RELEASE STRING\r\n\tJNZ\tSHORT ??L075\r\n\tCALL\tFREFAC\r\n??L075:\r\n\tPOP\tBX\r\n\tDEC\tBX\t\t;SKIP OVER SPACES LEFT AFTER VALUE SCAN\r\n\tCALL\tCHRGTR\r\n;\r\n; NOTE CHECK FOR OVERFLOW OF INPUT VALUE HERE\r\n;\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE THE DATA POINTER\r\n\t\t\t\t;[H,L]=DATA LIST POINTER\r\n\tMOV\tAL,BYTE PTR [BX]\t;DID VARIABLE LIST CONTINUE?\r\n\tCMP\tAL,LOW 44\t;MUST HAVE HAD A COMMA\r\n\tJNZ\tSHORT ??L076\r\n\tJMP\tVARLOP\t\t;GO CHECK ANOTHER\r\n??L076:\r\n\tPOP\tBX\t\t;GET FINAL DATA POINTER\r\n\tDEC\tBX\t\t;SKIP OVER ANY TRAILING SPACES\r\n\tCALL\tCHRGTR\r\n\tOR\tAL,AL\t\t;IS IT A TRUE END?\r\n\tPOP\tBX\t\t;GET THE START OF DATA POINTER FOR PASS2\r\n\tJZ\tSHORT ??L077\r\n\tJMP\tRDOIN2\t\t;IF DATA ENDED BADLY ASK FOR REINPUT\r\n??L077:\r\nINPCN3:\r\n\tMOV\tBYTE PTR [BX],LOW 44\t;SETUP COMMA AT BUFMIN\r\n\tJMP\tSHORT INPCON\r\nREAD:\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tMOV\tBX,DATPTR\t;GET LAST DATA LOCATION\r\n\tDB\t15O\t; SKIP  ;\"ORI\" TO SET [A] NON-ZERO\r\nINPCON: XOR\tAL,AL\t\t;SET FLAG THAT THIS IS AN INPUT\r\n\tMOV\tBYTE PTR FLGINP,AL\t;STORE THE FLAG\r\n;\r\n; IN THE PROCESSING OF DATA AND READ STATEMENTS:\r\n; ONE POINTER POINTS TO THE DATA (IE THE NUMBERS BEING FETCHED)\r\n; AND ANOTHER POINTS TO THE LIST OF VARIABLES\r\n;\r\n; THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A\r\n; TERMINATOR -- A , : OR END-OF-LINE\r\n;\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;[H,L]=VARIABLE LIST POINTER\r\n\t\t\t\t;DATA POINTER GOES ON THE STACK\r\n\tJMP\tSHORT LOPDAT\r\nLOPDT2: CALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;MAKE SURE THERE IS A \",\"\r\nLOPDAT: CALL\tPTRGET\t\t;READ THE VARIABLE LIST\r\n\t\t\t\t;AND GET THE POINTER TO A VARIABLE INTO [D,E]\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT THE VARIABLE LIST POINTER ONTO THE\r\n\t\t\t\t;STACK AND TAKE THE\r\n\t\t\t\t;DATA LIST POINTER OFF\r\n;\r\n; NOTE AT THIS POINT WE HAVE A VARIABLE WHICH WANTS DATA\r\n; AND SO WE MUST GET DATA OR COMPLAIN\r\n;\r\n\tPUSH\tDX\t\t;SAVE THE POINTER TO THE VARIABLE WE\r\n\t\t\t\t;ARE ABOUT TO SET UP WITH A VALUE\r\n\tMOV\tAL,BYTE PTR [BX]\t;SINCE THE DATA LIST POINTER ALWAYS POINTS\r\n\t\t\t\t;AT A TERMINATOR LETS READ THE\r\n\t\t\t\t;TERMINATOR INTO [A] AND SEE WHAT\r\n\t\t\t\t;IT IS\r\n\tCMP\tAL,LOW 44\r\n\tJZ\tSHORT DATBK\t;A COMMA SO A VALUE MUST FOLLOW\r\n\tMOV\tAL,BYTE PTR FLGINP\t;SEE WHAT TYPE OF STATEMENT THIS WAS\r\n\tOR\tAL,AL\r\n\t\t\t\t;SEARCH FOR ANOTHER DATA STATEMENT\r\n\tJZ\tSHORT ??L078\r\n\tJMP\tDATLOP\r\n??L078:\r\nDATBK:\r\n\tDB\t15O\t; SKIP  ;SET A NON-ZERO\r\nSCNVAL: XOR\tAL,AL\t\t;SET ZERO FLAG IN [A]\r\n\tMOV\tBYTE PTR INPPAS,AL\t;STORE SO EARLY RETURN CHECK WORKS\r\nEXTRN\tISFLIO:NEAR\r\n\tCALL\tISFLIO\t\t;SEE IF A FILE READ\r\n\tJZ\tSHORT ??L079\r\n\tJMP\tFILIND\t\t;IF SO, SPECIAL HANDLING\r\n??L079:\r\n\tCALL\tGETYPR\t\t;IS IT A STRING?\r\n\tPUSH\tAX\t\t;SAVE THE TYPE INFORMATION\r\n\tJNZ\tSHORT NUMINS\t;IF NUMERIC, USE FIN TO GET IT\r\n\t\t\t\t;ONLY THE VARAIBLE TYPE IS\r\n\t\t\t\t;CHECKED SO AN UNQUOTED STRING\r\n\t\t\t\t;CAN BE ALL DIGITS\r\n\tCALL\tCHRGTR\r\n\tMOV\tDH,AL\t\t;ASSUME QUOTED STRING\r\n\tMOV\tCH,AL\t\t;SETUP TERMINATORS\r\n\tCMP\tAL,LOW 34\t;QUOTE ?\r\n\tJZ\tSHORT NOWGET\t;TERMINATORS OK\r\n\tMOV\tAL,BYTE PTR FLGINP\t;INPUT SHOULDN'T TERMINATE ON \":\"\r\n\tOR\tAL,AL\t\t;SEE IF READ OR INPUT\r\n\tMOV\tDH,AL\t\t;SET D TO ZERO FOR INPUT\r\n\tJZ\tSHORT NCOLST\r\n\tMOV\tDH,LOW \":\"      ;UNQUOTED STRING TERMINATORS\r\nNCOLST: MOV\tCH,LOW 44\t;ARE COLON AND COMMA\r\n\t\t\t\t;NOTE: ANSI USES [B]=44 AS A FLAG TO \r\n\t\t\t\t;TRIGGER TRAILING SPACE SUPPRESSION\r\n\tDEC\tBX\t\t;BACKUP SINCE START CHARACTER MUST BE INCLUDED\r\n\t\t\t\t;IN THE QUOTED STRING CASE WE DON'T WANT TO\r\n\t\t\t\t;INCLUDE THE STARTING OR ENDING QUOTE\r\nNOWGET: CALL\tSTRLT2\t\t;MAKE A STRING DESCRIPTOR FOR THE VALUE\r\n\t\t\t\t;AND COPY IF NECESSARY\r\nPUBLIC\tDOASIG\r\nDOASIG: POP\tAX\t\t;POP OFF THE TYPE INFORMATION\r\n\tADD\tAL,LOW 3\t;MAKE VALTYPE CORRECT\r\n\tMOV\tCL,AL\t\t;SAVE VALUE TYPE IN [C]\r\n\tMOV\tAL,BYTE PTR INPPAS\t;SEE IF SCANNING VALUES FOR PASS1\r\n\tOR\tAL,AL\t\t;ZERO FOR PASS1\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;GO BACK TO PASS1\r\n\tMOV\tAL,CL\t\t;RECOVER VALTYP\r\n\tXCHG\tBX,DX\t\t;[D,E]=TEXT POINTER\r\n\tMOV\tBX,OFFSET STRDN2\t;RETURN LOC\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;[H,L]=PLACE TO STORE VARIABLE VALUE\r\n\tPUSH\tDX\t\t;TEXT POINTER GOES ON\r\n\tJMP\tINPCOM\t\t;DO ASSIGNMENT\r\nNUMINS: CALL\tCHRGTR\r\n\tPOP\tAX\t\t;GET BACK VALTYPE OF SOURCE\r\n\tPUSH\tAX\t\t;SAVE BACK\r\n\tCMP\tAL,LOW 5\t;REGEN CC'S\r\n\tMOV\tCX,OFFSET DOASIG\t;ASSIGNMENT IS COMPLICATED\r\n\t\t\t\t;EVEN FOR NUMERICS SO USE THE \"LET\" CODE\r\n\tPUSH\tCX\t\t;SAVE ON STACK\r\n\tJAE\tSHORT ??L080\r\n\tJMP\tFIN\t\t;IF NOT DOUBLE, CALL USUAL # INPUTTER\r\n??L080:\r\n\tJMP\tFINDBL\t\t;ELSE CALL SPECIAL ROUTINE WHICH EXPECTS DOUBLES\r\nSTRDN2:\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\r\n\tJZ\tSHORT TRMOK\r\n\tCMP\tAL,LOW 44\r\n\tJZ\tSHORT ??L081\r\n\tJMP\tTRMNOK\t\t;ENDED PROPERLY?\r\n??L081:\r\nTRMOK:\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\r\n\tDEC\tBX\t\t;LOOK AT TERMINATOR\r\n\tCALL\tCHRGTR\t\t;AND SET UP CONDITION CODES\r\n\tJZ\tSHORT ??L082\r\n\tJMP\tLOPDT2\t\t;NOT ENDING, CHECK FOR COMMA\r\n??L082:\r\n\t\t\t\t;AND GET ANOTHER VARIABLE\r\n\t\t\t\t;TO FILL WITH DATA\r\n\r\n\tPOP\tDX\t\t;POP OFF THE POINTER INTO DATA\r\n\tMOV\tAL,BYTE PTR FLGINP\t;FETCH THE STATEMENT TYPE FLAG\r\n\tOR\tAL,AL\t\t;IF ZERO, INPUT STATEMENT\r\n\tXCHG\tBX,DX\r\n\tJZ\tSHORT ??L083\r\n\tJMP\tRESFIN\t\t;UPDATE DATPTR\r\n??L083:\r\n\tPUSH\tDX\t\t;SAVE THE TEXT POINTER\r\nFINPRG: POP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tJMP\tFINPRT\r\n;\r\n; THE SEARCH FOR DATA STATMENTS IS MADE BY USING THE EXECUTION CODE\r\n; FOR DATA TO SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT\r\n; IS COMPARED WITH $DATA. EACH NEW LINE NUMBER\r\n; IS STORED IN DATLIN SO THAT IF AN ERROR OCCURS WHILE READING\r\n; DATA THE ERROR MESSAGE WILL GIVE THE LINE NUMBER OF THE \r\n; ILL-FORMATTED DATA\r\n;\r\nDATLOP: CALL\tDATA\r\nDATFND: OR\tAL,AL\r\n\tJNZ\tSHORT NOWLIN\r\n\tINC\tBX\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tINC\tBX\r\n\tOR\tAL,BYTE PTR [BX]\t;IFE XERPAG\r\n\tMOV\tDL,LOW OFFSET ERROD\t;NO DATA IS ERROR ERROD\r\n\tJNZ\tSHORT ??L084\r\n\tJMP\tERROR\t\t;IF SO COMPLAIN\r\n??L084:\r\n\tINC\tBX\t\t;SKIP PAST LINE #\r\n\tMOV\tDX,[BX]\t;GET DATA LINE #\r\n\tINC\tBX\r\n\tMOV\tDATLIN,DX\t;SAVE DATA LINE NUMBER\r\nNOWLIN: CALL\tCHRGTR\t\t;GET THE STATEMENT TYPE\r\n\tCMP\tAL,LOW OFFSET $DATA\t;IS IS \"DATA\"?\r\n\tJNZ\tSHORT DATLOP\t;NOT DATA SO LOOK SOME MORE\r\n\tJMP\tDATBK\t\t;CONTINUE READING\r\n\r\n\tPAGE\r\n\r\n\tSUBTTL PEEK AND POKE\r\n;\r\n; NOTE: IN THE 8K PEEK ONLY ACCEPTS POSITIVE NUMBERS UP TO 32767\r\n; POKE WILL ONLY TAKE AN ADDRESS UP TO 32767 , NO\r\n; FUDGING ALLOWED. THE VALUE IS UNSIGNED.\r\n; IN THE EXTENDED VERSION NEGATIVE NUMBERS CAN BE\r\n; USED TO REFER TO LOCATIONS HIGHER THAN 32767.\r\n; THE CORRESPONDENCE IS GIVEN BY SUBTRACTING 65536 FROM LOCATIONS\r\n; HIGHER THAN 32767 OR BY SPECIFYING A POSITIVE NUMBER UP TO 65535.\r\n;\r\nPEEK:\tCALL\tFRQINT\t\t;GET AN INTEGER IN [H,L]\r\n\tEXTRN\tPRODIR:NEAR\r\n\tCALL\tPRODIR\t\t;DONT ALLOW DIRECT IF PROTECTED FILE\r\n\tEXTRN\tPEKFLT:NEAR\t;PEEK filter\r\n\tINS86\t6\t\t;PUSH   ES\r\n\tINS86\t216,6,SAVSEG\t;MOV    ES,SAVSEG\r\n\tCALL\tPEKFLT\t\t;Filter the PEEK\r\n\tJNZ\tSHORT ??L085\r\n\tJMP\tPEKVAL\t\t;Filter returned the appropriate value\r\n??L085:\r\n\tINS86\t46\t\t;$ES\r\n\tMOV\tAL,BYTE PTR [BX]\t;Fetch the PEEK value\r\nPEKVAL: INS86\t7\t\t;POP    ES\r\n\tJMP\tSNGFLT\t\t;AND FLOAT IT\r\nPOKE:\tCALL\tFRMQNT\t\t;READ INTEGER FORMULA INTO [D,E]\r\n\tPUSH\tDX\t\t;SAVE VALUE FOR LATER\r\n\tCALL\tPRODIR\t\t;DONT ALLOW DIRECT IF PROTECTED FILE\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;CHECK FOR A COMMA\r\n\tCALL\tGETBYT\r\n\tPOP\tDX\t\t;GET THE ADDRESS BACK\r\n\tINS86\t6\t\t;PUSH ES\r\n\tINS86\t216,6,SAVSEG\t;MOV  ES,SAVSEG\r\n\tEXTRN\tPOKFLT:NEAR\r\n\tCALL\tPOKFLT\t\t;Filter POKEs for \"special\" addresses\r\n\tJNZ\tSHORT ??L086\r\n\tJMP\tPOKEX\t\t;Do not perform the POKE\r\n??L086:\r\n\tMOV\tDI,DX\r\n\tSTOSB\t\t\t;STORE IT AWAY\r\nPOKEX:\r\n\tINS86\t7\t\t;POP  ES\r\n\tRET\t\t\t;SCANNED EVERYTHING\r\nPUBLIC\tFRMQNT\r\nFRMQNT: CALL\tFRMEVL\t\t;READ FORMULA\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\tFRQINT\t\t;GET VALUE IN RANGE -32769-65535\r\n\tXCHG\tBX,DX\t\t;VALUE TO [D,E]\r\n\tPOP\tBX\t\t;RESTORE TEXT POINTER\r\n\tRET\r\n\r\nPUBLIC\tFRQINT\r\nFRQINT: MOV\tCX,OFFSET FRCINT\t;RETURN HERE\r\n\tPUSH\tCX\t\t;SAVE ADDR\r\n\tCALL\tGETYPR\t\t;SET THE CC'S ON VALTYPE\r\n\tJNS\tSHORT $+3\r\n\tRET\t\t\t;RETURN IF ALREADY INTEGER.\r\n\tMOV\tAL,BYTE PTR FAC ;GET EXPONENT\r\n\tCMP\tAL,LOW 220O\t;IS MAGNITUDE .GT. 32767\r\n\tJZ\tSHORT $+3\r\n\tRET\t\t\t;NO, FORCE INTEGER\r\n\tCALL\tSIGN\t\t;GET SIGN OF NUMBER\r\n\t\t\t\t;IS IT NEGATIVE, ONLY ALLOWABLE # IS -32768\r\n\tJNS\tSHORT $+3\r\n\tRET\t\t\t;ASSUME THATS WHAT IT IS, ELSE GIVE OVERFLOW\r\n\tCALL\tFRCSNG\t\t;MAKE NUMBER A SINGLE\r\n\tMOVRI\t221O,200O,0,0\t;GET -65536.\r\n\tJMP\tFADD\t\t;SUBTRACT IT, AND THEN FORCE INTEGER\r\n\r\n;PAGE\r\n\tSUBTTL RENUMBER\r\n; THE RESEQ(UENCE) COMMAND TAKE UP TO THREE ARGUMENTS\r\n; RESEQ [NN[,MM[,INC]]]\r\n; WHERE NN IS THE FIRST DESTINATION LINE OF THE\r\n; LINES BEING RESEQUENCED, LINES LESS THAN MM ARE\r\n; NOT RESEQUENCED, AND INC IS THE INCREMENT.\r\nRESEQ:\r\n\tMOV\tCX,10\t\t;ASSUME INC=10\r\n\tPUSH\tCX\t\t;SAVE ON STACK\r\n\tMOV\tDH,CH\t\t;RESEQ ALL LINES BY SETTING [D,E]=0\r\n\tMOV\tDL,CH\r\n\tJZ\tSHORT RESNN\t;IF JUST 'RESEQ' RESEQ 10 BY 10\r\n\tCMP\tAL,LOW 54O\t;COMMA\r\n\tJZ\tSHORT EATCOM\t;DONT USE STARTING # OF ZERO\r\n\tPUSH\tDX\t\t;SAVE [D,E]\r\n\tCALL\tLINSPC\t\t;GET NEW NN\r\n\tMOV\tCH,DH\t\t;GET IN IN [B,C] WHERE IT BELONGS\r\n\tMOV\tCL,DL\r\n\tPOP\tDX\t\t;GET BACK [D,E]\r\n\tJZ\tSHORT RESNN\t;IF EOS, DONE\r\nEATCOM: CALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;EXPECT COMMA\r\n\tCALL\tLINSPC\t\t;GET NEW MM\r\n\tJZ\tSHORT RESNN\t;IF EOS, DONE\r\n\tPOP\tAX\t\t;GET RID OF OLD INC\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 54O\t;EXPECT COMMA\r\n\tPUSH\tDX\t\t;SAVE MM\r\n\tCALL\tLINGET\t\t;GET NEW INC\r\n\tJZ\tSHORT ??L087\r\n\tJMP\tSNERR\t\t;SHOULD HAVE TERMINATED.\r\n??L087:\r\n\tOR\tDX,DX\t\t;SEE IF INC=0 (ILLEGAL)\r\n\tJNZ\tSHORT ??L088\r\n\tJMP\tFCERR\t\t;YES, BLOW HIM UP NOW\r\n??L088:\r\n\tXCHG\tBX,DX\t\t;FLIP NEW INC & [H,L]\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;NEW INC ONTO STACK\r\n\tXCHG\tBX,DX\t\t;GET [H,L] BACK, ORIG [D,E] BACK\r\nRESNN:\tPUSH\tCX\t\t;SAVE NN ON STACK\r\n\tCALL\tFNDLIN\t\t;FIND MM LINE\r\n\tPOP\tDX\t\t;GET NN OFF STACK\r\n\tPUSH\tDX\t\t;SAVE NN BACK\r\n\tPUSH\tCX\t\t;SAVE POINTER TO MM LINE\r\n\tCALL\tFNDLIN\t\t;FIND FIRST LINE TO RESEQ.\r\n\tMOV\tBX,CX\t\t;GET PTR TO THIS LINE IN [H,L]\r\n\tPOP\tDX\t\t;GET LINE PTD TO BY MM\r\n\tCMP\tBX,DX\t\t;COMPARE TO FIRST LINE RESEQED\r\n\tXCHG\tBX,DX\t\t;GET PTR TO MM LINE IN [H,L]\r\n\tJAE\tSHORT ??L089\r\n\tJMP\tFCERR\t\t;CANT ALLOW PROGRAM TO BE RESEQUED\r\n??L089:\r\n\t\t\t\t;ON TOP OF ITSELF\r\n\tPOP\tDX\t\t;GET NN BACK\r\n\tPOP\tCX\t\t;GET INC IN [B,C]\r\n\tPOP\tAX\t\t;GET RID OF NEWSTT\r\n\tPUSH\tBX\t\t;SAVE PTR TO FIRST LINE TO RESEQ.\r\n\tPUSH\tDX\t\t;SAVE NN ON STACK\r\n\tJMP\tSHORT NXTRSL\r\nNXTRSC: ADD\tBX,CX\t\t;ADD INCREMENT INTO\r\n\tJAE\tSHORT ??L090\r\n\tJMP\tFCERR\t\t;UH OH, HIS INC WAS TOO LARGE.\r\n??L090:\r\n\tXCHG\tBX,DX\t\t;FLIP LINK FIELD, ACCUM.\r\n\tPUSH\tBX\t\t;SAVE LINK FIELD\r\n\tMOV\tBX,65529\t;TEST FOR TOO LARGE LINE\r\n\tCMP\tBX,DX\t\t;COMPARE TO CURRENT #\r\n\tPOP\tBX\t\t;RESTORE LINK FIELD\r\n\tJAE\tSHORT ??L091\r\n\tJMP\tFCERR\t\t;UH OH, HIS INC WAS TOO LARGE.\r\n??L091:\r\nNXTRSL: PUSH\tDX\t\t;SAVE CURRENT LINE ACCUM\r\n\tMOV\tDX,[BX]\t;GET LINK FIELD INTO [D,E]\r\n\tOR\tDX,DX\t\t;SET CC'S ON LINK FIELD\r\n\tXCHG\tBX,DX\t\t;SEE IF NEXT LINK ZERO\r\n\tPOP\tDX\t\t;GET BACK ACCUM LINE #\r\n\tJZ\tSHORT RESSD1\t;ZERO, DONE\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET FIRST BYTE OF LINK\r\n\tINC\tBX\t\t;INC POINTER\r\n\tOR\tAL,BYTE PTR [BX]\t;SET CC'S\r\n\tLAHF\r\n\tDEC\tBX\t\t;MOVE POINTER BACK\r\n\tSAHF\r\n\tXCHG\tBX,DX\t\t;BACK IN [D,E]\r\n\tJNZ\tSHORT NXTRSC\t;INC COUNT\r\n\r\nRESSD1: PUSH\tCX\t\t;SAVE INC\r\n\tCALL\tSCCLIN\t\t;SCAN PROGRAM CONVERTING LINES TO PTRS.\r\n\tPOP\tCX\t\t;GET BACK INC\r\n\tPOP\tDX\t\t;GET NN\r\n\tPOP\tBX\t\t;GET PTR TO FIRST LINE TO RESEQ\r\n\r\nRESNX1: PUSH\tDX\t\t;SAVE CURRENT LINE\r\n\tMOV\tDX,[BX]\t;PREPARE FOR ZERO LINK FIELD TEST\r\n\tINC\tBX\r\n\tOR\tDX,DX\t\t;END?\r\n\tJZ\tSHORT SCCALL\t;STOP RESEQING WHEN SEE END OF PGM\r\n\tXCHG\tBX,DX\t\t;FLIP LINE PTR, LINK FIELD\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;PUT LINK ON STACK, GET NEW LINE # OFF\r\n\tXCHG\tBX,DX\t\t;PUT NEW LINE # IN [D,E], THIS LINE\r\n\t\t\t\t;PTR IN [H,L]\r\n\tINC\tBX\t\t;POINT TO LINE # FIELD.\r\n\tMOV\t[BX],DX\t;CHANGE TO NEW LINE #\r\n\tXCHG\tBX,DX\t\t;GET THIS LINE # IN [H,L]\r\n\tADD\tBX,CX\t\t;ADD INC\r\n\tXCHG\tBX,DX\t\t;GET NEW LINE # BACK IN [D,E]\r\n\tPOP\tBX\t\t;GET PTR TO NEXT LINE\r\n\tJMP\tSHORT RESNX1\t;KEEP RESEQING\r\nSCCALL: MOV\tCX,OFFSET STPRDY\t;WHERE TO GO WHEN DONE\r\n\tPUSH\tCX\t\t;SAVE ON STACK\r\n\tDB\t74O\t; SKIP  ;\"CPI AL,\" CALL SCCPTR\r\n; THE SUBROUTINES SCCLIN AND SCCPTR CONVERT ALL\r\n; LINE #'S TO POINTERS AND VICE-VERSA.\r\n; THE ONLY SPECIAL CASE IS \"ON ERROR GOTO 0\" WHERE THE \"0\"\r\n; IS LEFT AS A LINE NUMBER TOKEN SO IT WONT BE CHANGED BY RESEQUENCE.\r\nSCCLIN: DB\t15O\t; SKIP  ;\"ORI AX,\" OVER NEXT BYTE\r\nPUBLIC\tSCCPTR\r\nSCCPTR: XOR\tAL,AL\t\t;SET A=0\r\n\tMOV\tBYTE PTR PTRFLG,AL\t;SET TO SAY WHETER LINES OR PTRS EXTANT\r\nSCNPGM: MOV\tBX,TXTTAB\t;GET PTR TO START OF PGM\r\n\tDEC\tBX\t\t;NOP NEXT INX.\r\nSCNPLN: INC\tBX\t\t;POINT TO BYTE AFTER ZERO AT END OF LINE\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET LINK FIELD INTO [D,E]\r\n\tINC\tBX\t\t;BUMP PTR\r\n\tOR\tAL,BYTE PTR [BX]\t;SET CC'S\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;RETURN IF ALL DONE.\r\n\tINC\tBX\t\t;POINT PAST LINE #\r\n\tMOV\tDX,[BX]\t;GET LOW BYTE OF LINE #\r\n\tINC\tBX\r\nPUBLIC\tSCNEXT\r\nSCNEXT: CALL\tCHRGTR\t\t;GET NEXT CHAR FROM LINE\r\nSCNEX2: OR\tAL,AL\t\t;END OF LINE\r\n\tJZ\tSHORT SCNPLN\t;SCAN NEXT LINE\r\n\tMOV\tCL,AL\t\t;SAVE [A]\r\n\tMOV\tAL,BYTE PTR PTRFLG\t;CHANGE LINE TOKENS WHICH WAY?\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tMOV\tAL,CL\t\t;GET BACK CURRENT CHAR\r\n\tJZ\tSHORT SCNPT2\t;CHANGING POINTERS TO #'S\r\n\tCMP\tAL,LOW OFFSET $ERROR\t;IS IT ERROR TOKEN?\r\n\tJNZ\tSHORT NTERRG\t;NO.\r\n\tCALL\tCHRGTR\t\t;SCAN NEXT CHAR\r\n\tCMP\tAL,LOW OFFSET $GOTO\t;ERROR GOTO?\r\n\tJNZ\tSHORT SCNEX2\t;GET NEXT ONE\r\n\tCALL\tCHRGTR\t\t;GET NEXT CHAR\r\n\tCMP\tAL,LOW OFFSET LINCON\t;LINE # CONSTANT?\r\n\tJNZ\tSHORT SCNEX2\t;NO, IGNORE.\r\n\tPUSH\tDX\t\t;SAVE [D,E]\r\n\tCALL\tLINGT3\t\t;GET IT\r\n\tOR\tDX,DX\t\t;IS IT LINE # ZERO?\r\n\tJNZ\tSHORT CHGPTR\t;CHANGE IT TO A POINTER\r\n\tJMP\tSHORT SCNEX3\t;YES, DONT CHANGE IT\r\nNTERRG: CMP\tAL,LOW OFFSET LINCON\t;LINE # CONSTANT?\r\n\tJNZ\tSHORT SCNEXT\t;NOT, KEEP SCANNING\r\n\tPUSH\tDX\t\t;SAVE CURRENT LINE # FOR POSSIBLE ERROR MSG\r\n\tCALL\tLINGT3\t\t;GET LINE # OF LINE CONSTANT INTO [D,E]\r\nCHGPTR:\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER JUST AT END OF LINCON 3 BYTES\r\n\tCALL\tFNDLIN\t\t;TRY TO FIND LINE IN PGM.\r\n\tLAHF\r\n\tDEC\tCX\t\t;POINT TO ZERO AT END OF PREVIOUS LINE\r\n\tSAHF\r\n\tMOV\tAL,LOW OFFSET PTRCON\t;CHANGE LINE # TO PTR\r\n\tJB\tSHORT MAKPTR\t;IF LINE FOUND CHANGE # TO PTR\r\n\tCALL\tCRDONZ\t\t;PRINT CRLF IF REQUIRED\r\n\tMOV\tBX,OFFSET LINM\t;PRINT \"UNDEFINED LINE\" MESSAGE\r\n\tPUSH\tDX\t\t;SAVE LINE #\r\n\tCALL\tSTROUT\t\t;PRINT IT\r\n\tPOP\tBX\t\t;GET LINE # IN [H,L]\r\n\tCALL\tLINPRT\t\t;PRINT IT\r\n\tPOP\tCX\t\t;GET TEXT PTR OFF STACK\r\n\tPOP\tBX\t\t;GET CURRENT LINE #\r\n\tPUSH\tBX\t\t;SAVE BACK\r\n\tPUSH\tCX\t\t;SAVE BACK TEXT PTR\r\n\tCALL\tINPRT\t\t;PRINT IT\r\nSCNPOP: POP\tBX\t\t;POP OFF CURRENT TEXT POINTER\r\nSCNEX3: POP\tDX\t\t;GET BACK CURRENT LINE #\r\n\tDEC\tBX\t\t;BACKUP POINTER\r\nJSCNXT: JMP\tSHORT SCNEXT\t;KEEP SCANNING\r\n\r\nLINM:\tDB\"Undefined line \"\r\n\tDB\t0\r\n\r\nSCNPT2: CMP\tAL,LOW OFFSET PTRCON\t;POINTER\r\n\tJNZ\tSHORT JSCNXT\t;NO, KEEP SCANNING\r\n\tPUSH\tDX\t\t;SAVE CURRENT LINE #\r\n\tCALL\tLINGT3\t\t;GET #\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tXCHG\tBX,DX\t\t;FLIP CURRENT TEXT PTR & PTR\r\n\tINC\tBX\t\t;BUMP POINTER\r\n\tINC\tBX\t\t;POINT TO LINE # FIELD\r\n\tINC\tBX\r\n\tMOV\tCL,BYTE PTR [BX]\t;PICK UP LINE #\r\n\tINC\tBX\t\t;POINT TO HIGH PART\r\n\tMOV\tCH,BYTE PTR [BX]\r\n\tMOV\tAL,LOW OFFSET LINCON\t;CHANGE TO LINE CONSTANT\r\nMAKPTR: MOV\tBX,OFFSET SCNPOP\t;PLACE TO RETURN TO AFTER CHANGING CONSTANT\r\n\tPUSH\tBX\t\t;SAVE ON STACK\r\nCONCHG: MOV\tBX,CONTXT\t;GET TXT PTR AFTER CONSTANT IN [H,L]\r\nCONCH2: PUSH\tBX\t\t;SAVE PTR TO END OF CONSTANT\r\n\tDEC\tBX\r\n\tMOV\tBYTE PTR [BX],CH\r\n\tDEC\tBX\r\n\tMOV\tBYTE PTR [BX],CL\t;CHANGE TO VALUE IN [B,C]\r\n\tDEC\tBX\t\t;POINT TO CONSTANT TOKEN\r\n\tMOV\tBYTE PTR [BX],AL\t;CHANGE TO VALUE IN [A]\r\n\tPOP\tBX\t\t;RESTORE POINTER TO AFTER CONSTANT\r\n\tRET\r\n\r\nPUBLIC\tDEPTR\r\nDEPTR:\tMOV\tAL,BYTE PTR PTRFLG\t;DO LINE POINTERS EXIST IN PGM?\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;NO, JUST RETURN\r\n\tJMP\tSCCPTR\t\t;CONVERT THEN TO LINE #'S\r\n\r\n\r\n\r\n\r\n\tSUBTTL ANSI - THE ROUTINES TO HANDLE ANSI FEATURES\r\n\tDATAS=DATA\r\nOPTION: CALL\tSYNCHR\r\n\tDB\tOFFSET \"B\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"A\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"S\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"E\"\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE BASE NUMBER\r\n\tSUB\tAL,LOW \"0\"\r\n\tJAE\tSHORT ??L092\r\n\tJMP\tSNERR\r\n??L092:\r\n\tCMP\tAL,LOW 2\t;ONLY 0 AND 1 ARE LEGAL\r\n\tJNAE\tSHORT ??L093\r\n\tJMP\tSNERR\r\n??L093:\r\n\tMOV\tCH,AL\r\n\tMOV\tAL,BYTE PTR OPTVAL\r\n\tCMP\tAL,CH\r\n\tJZ\tSHORT OLDOPT\t;BRIF OLD OPTION BASE VALUE\r\n\tMOV\tAL,BYTE PTR OPTFLG\r\n\tOR\tAL,AL\t\t;HAVE WE SEEN OPTION BASE BEFORE\r\n\tJZ\tSHORT ??L094\r\n\tJMP\tDDERR\t\t;IF SO \"DOUBLE DIMENSION ERROR\"\r\n??L094:\r\n\tPUSH\tBX\t\t;SAVE THE TEXT POINTER\r\n\tMOV\tBX,ARYTAB\t;SEE IF WE HAVE ANY ARRAYS YET\r\n\tXCHG\tBX,DX\r\n\tMOV\tBX,STREND\r\n\tCMP\tBX,DX\t\t;IF THESE ARE EQUAL WE HAVE NOT\r\n\tJZ\tSHORT ??L095\r\n\tJMP\tDDERR\r\n??L095:\r\n\tPOP\tBX\r\n\tMOV\tAL,CH\r\n\tMOV\tBYTE PTR OPTVAL,AL\t;SAVE IF FOR DIM AND PTRGET\r\n\tINC\tAL\t\t;MAKE SURE [A] IS NON ZERO\r\n\tMOV\tBYTE PTR OPTFLG,AL\t;FLAG THAT WE HAVE SEEN \"OPTION BASE\"\r\nOLDOPT: CALL\tCHRGTR\t\t;FETCH THE TERMINATOR\r\n\tRET\r\n\r\n; THIS ROUTINE IS CALLED BY THE MATH PACKAGE\r\n; TO PRINT ERROR MESSAGES WITHOUT DISTURBING PTRFIL, ETC.\r\nPUBLIC\t$STPRN\r\n$STPRN:\r\nSTRPRN:\r\n\tINS86\t56\t\t;FETCH FROM CODE SEGMENT\r\nSTRPN1: MOV\tAL,BYTE PTR [BX]\t;GET BYTE FROM MESSAGE\r\n\tOR\tAL,AL\t\t;END OF MESSAGE\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;YES, DONE\r\n\tCALL\tCALTTY\t\t;PRINT CHAR\r\n\tINC\tBX\t\t;INCREMENT POINTER\r\n\tJMP\tSTRPRN\t\t;PRINT NEXT CHAR\r\n\tEXTRN\tCALTTY:NEAR,$CATTY:NEAR\r\nRANDOM: JZ\tSHORT INPRG\t;IF NO ARGUMENT ASK FROM TERMINAL\r\n\tCALL\tFRMEVL\t\t;FETCH THE FORMULA ARGUMENT\r\n\tPUSH\tBX\r\n\tCALL\tFRCINT\t\t;ALLOW NORMAL INTEGERS\r\n\tJMP\tSHORT STRNDS\t;STORE THE NEW RANDOM SEED\r\nINPRG:\tPUSH\tBX\r\nINPRAG:\r\n\tMOV\tBX,OFFSET RANMES\t;ASK FOR SOME RANDOM INPUT\r\n\tCALL\tSTROUT\r\n\tCALL\tQINLIN\r\n\tPOP\tDX\t\t;get back text pointer\r\n\tJAE\tSHORT ??L096\r\n\tJMP\tSTPEND\t\t;go away if control c\r\n??L096:\r\n\tPUSH\tDX\t\t;resave text pointer\r\n\tINC\tBX\t\t;MOVE PAST BUFMIN TO BUF\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET FIRST CHAR OF TYPEIN (FIN EXPECTS IT)\r\n\tCALL\tFIN\t\t;READ A NUMBER\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET THE TERMINATOR\r\n\tOR\tAL,AL\r\n\tJNZ\tSHORT INPRAG\t;DON'T ALLOW BAD FORMAT\r\n\tCALL\tFRCINT\t\t;ALLOW NORMAL INTEGERS\r\nSTRNDS:\r\n\tMOV\tRNDX+1,BX\r\n\tEXTRN\tRNDMN2:NEAR\r\n\tCALL\tRNDMN2\r\n\tPOP\tBX\t\t;GET BACK THE TEXT POINTER\r\n\tRET\r\nRANMES: DB\"Random number seed (-32768 to 32767)\"\r\n\tDB\t0\r\n\r\n;\r\n; THIS CODE SCANS AHEAD TO FIND THE \"NEXT\" THAT MATCHES A \"FOR\"\r\n; IN ORDER TO 1) HANDLE EMPTY LOOPS AND 2) MAKE SURE LOOPS\r\n; MATCH UP PROPERLY.\r\n;\r\nPUBLIC\tWNDSCN\r\nWNDSCN: MOV\tCL,LOW OFFSET ERRWH\t;SCAN FOR MATCHING WEND THIS IS ERROR IF FAIL\r\n\tJMP\tSHORT SCNCNT\r\nNXTSCN: MOV\tCL,LOW OFFSET ERRFN\r\nSCNCNT:\r\n\tMOV\tCH,LOW 0\t;SET UP THE COUNT OF \"FOR\"S SEEN\r\n\tXCHG\tBX,DX\t\t;INITIALIZE NXTLIN FOR NEXT ON SAME LINE\r\n\tMOV\tBX,CURLIN\r\n\tMOV\tNXTLIN,BX\r\n\tXCHG\tBX,DX\t\t;RESTORE THE TEXT POINTER TO [H,L]\r\nFORINC: INC\tCH\t\t;INCREMENT THE COUNT WHENEVER \"FOR\" IS SEEN\r\nFNLOP:\tDEC\tBX\t\t;** FIX HERE FOR 5.03 CAN'T CALL DATA\r\nSCANWF: CALL\tCHRGTR\t\t;TO SKIP TO STATEMENT BECAUSE COULD\r\n\tJZ\tSHORT FORTRM\t;HAVE STATEMENT AFTER \"THEN\"\r\n\tCMP\tAL,LOW 34D\t;CHECK FOR QUOTE WHICH MAY HAVE\r\n\tJNZ\tSHORT NTQTSC\t;EIGHT BIT LITERAL DATA SAME AS $THEN\r\n\t\t\t\t;OR $WHILE OR $WEND OR $FOR OR $NEXT\r\nQTLOPF: CALL\tCHRGTR\t\t;IN IT. SCAN THROUGH STRING.\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT FORTRM\t;TERMINATE ONLY ON ZERO NOT COLON\r\n\tCMP\tAL,LOW 34D\r\n\tJNZ\tSHORT QTLOPF\r\nNTQTSC:\r\n\tCMP\tAL,LOW OFFSET $ELSE\t;ELSE STATMENT\r\n\tJZ\tSHORT FNNWST\t;THEN ALLOW NEXT OR WEND AFTER IT\r\n\tCMP\tAL,LOW OFFSET $THEN\t;SO SCAN USING CHRGET WAITING FOR END\r\n\tJNZ\tSHORT SCANWF\t;OF STATEMENT OR $THEN\r\nFORTRM: OR\tAL,AL\t\t;SEE HOW IT ENDED\r\n\tJNZ\tSHORT FNNWST\t;JUST NEW STATEMENT -- EXAMINE IT\r\n\t\t\t\t;OR COULD BE COLON IN STRING BUT NO HARM\r\n\t\t\t\t;IN NON KANABS (HGHBIT) VERSION SINCE NO RESERVED\r\n\t\t\t\t;WORDS WILL MATCH THE NEXT CHARACTER\r\n\tINC\tBX\r\n\tMOV\tAL,BYTE PTR [BX]\t;SCAN THE LINK AT THE START OF THE NEXT LINE\r\n\tINC\tBX\r\n\tOR\tAL,BYTE PTR [BX]\t;TO SEE IF ITS ZERO (END OF PROGRAM)\r\n\tMOV\tDL,CL\t\t;SET UP ERROR NUMBER\r\n\tJNZ\tSHORT ??L097\r\n\tJMP\tERROR\r\n??L097:\r\n\tINC\tBX\t\t;PICK UP THE NEW LINE NUMBER\r\n\tMOV\tDX,[BX]\r\n\tINC\tBX\r\n\tMOV\tNXTLIN,DX\t;SAVE AS \"NEXT\" LINE NUMBER\r\nFNNWST: CALL\tCHRGTR\t\t;GET THE TYPE OF THE NEXT STATEMENT\r\n\tCMP\tAL,LOW OFFSET $REM\t;REM STATEMENTS SINCE THEY HAVE COLONS\r\n\tJNZ\tSHORT NTREMR\t;IN THE MIDDLE WHICH MAY BE VIEWED AS\r\n\tPUSH\tCX\r\n\tCALL\tREM\t\t;STATEMENT TERMINATORS AND THE NEXT CHAR\r\n\tPOP\tCX\r\n\tJMP\tSHORT FORTRM\t;MIGHT BE AN EIGTH BIT LITERAL THAT\r\nNTREMR: CMP\tAL,LOW OFFSET $DATA\t;ACCIDENTALLY MATCHES THE SEARCH\r\n\tJNZ\tSHORT NTDATR\t;SO WE CALL REM AND DATA TO DO THE SKIPPING\r\n\tPUSH\tCX\r\n\tCALL\tDATA\r\n\tPOP\tCX\r\n\tJMP\tSHORT FORTRM\r\nNTDATR:\r\n\tMOV\tAL,CL\t\t;GET THE ERROR NUMBER TO SEE WHAT WE ARE\r\n\tCMP\tAL,LOW OFFSET ERRFN\t;SCANNING FOR\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET BACK THE CHARACTER\r\n\tJZ\tSHORT NXTLOK\t;FOR/NEXT SEARCHING\r\n\tCMP\tAL,LOW OFFSET $WHILE\t;ANOTHER WHILE/WEND NEST?\r\n\tJZ\tSHORT FORINC\r\n\tCMP\tAL,LOW OFFSET $WEND\r\n\tJNZ\tSHORT FNLOP\r\n\tDEC\tCH\r\n\tJNZ\tSHORT FNLOP\r\n\tRET\r\nNXTLOK:\r\n\tCMP\tAL,LOW OFFSET $FOR\t;ANOTHER \"FOR\"?\r\n\tJZ\tSHORT FORINC\t;INCREMENT THE FOR COUNT\r\n\tCMP\tAL,LOW OFFSET $NEXT\t;END WITH NEXT?\r\n\tJNZ\tSHORT FNLOP\t;SKIP OVER THIS STATEMENT\r\nDECNXT: DEC\tCH\t\t;DECREMENT THE LOOP COUNT\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;RETURN WITH [H,L] ABOUT TO GET FIRST CHARACTER OF \"NEXT\" VARIABLE\r\n\r\n;\r\n; SCAN  THE VARIABLES LISTED IN A \"NEXT\" STATEMENT\r\n;\r\n\tCALL\tCHRGTR\t\t;SEE IF THERE IS A NAME\r\n\tJZ\tSHORT FORTRM\t;ONLY ONE SO SCAN MORE STATEMENTS\r\n\tXCHG\tBX,DX\t\t;SAVE TEXT POINTER IN [D,E]\r\n\tMOV\tBX,CURLIN\t;SAVE THE CURRENT LINE NUMBER\r\n\tPUSH\tBX\r\n\tMOV\tBX,NXTLIN\t;MAKE ERROR COME FROM \"NEXT\"\r\n\tMOV\tCURLIN,BX\r\n\tXCHG\tBX,DX\t\t;[H,L]= TEXT POINTER\r\n\tPUSH\tCX\t\t;SAVE THE \"FOR\" COUNT\r\n\tCALL\tPTRGET\t\t;SKIP OVER THE VARIABLE NAME\r\n\tPOP\tCX\t\t;GET BACK THE \"FOR\" COUNT\r\n\tDEC\tBX\t\t;CHECK TERMINATOR\r\n\tCALL\tCHRGTR\r\n\tMOV\tDX,OFFSET FORTRM\t;PLACE TO GO TO\r\n\tJZ\tSHORT TRMNXT\t;END OF \"NEXT\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET 44\t;SHOULD HAVE COMMAS IN BETWEEN\r\n\tDEC\tBX\t\t;RESCAN FIRST CHARACTER\r\n\tMOV\tDX,OFFSET DECNXT\t;PLACE TO GO BACK TO\r\nTRMNXT: POP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;SAVE THE TEXT POINTER ON THE STACK\r\n\tMOV\tCURLIN,BX\r\n\tPOP\tBX\r\n\tPUSH\tDX\t\t;GO OFF TO ADDRESS IN [B,C]\r\n\tRET\r\n;\r\n; THIS ROUTINE CLEARS FLGOVC TO RESET TO NORMAL OVERFLOW MODE.\r\n; IN NORMAL MODE, OVERR ALWAYS PRINTS OVERFLOW BECAUSE FLGOVC=0\r\n; FUNCTION DISPATCH, FIN (&FINDBL), AND EXPONENTIATION SET UP AN OVERFLOW\r\n; MODE WHERE FLGOVC=1 AND AFTER ONE OVERFLOW FLGOVC=2 AND NO MORE\r\n; OVERFLOW MESSAGES ARE PRINTED. FIN (&FINDBL) ALSO STORE FLGOVC IN OVCSTR\r\n; BEFORE RESETTING FLGOVC SO A CALLER CAN DETECT OVERFLOW OCCURANCE.\r\n;\r\nPUBLIC\t$FLGOC\r\n$FLGOC:\r\nPUBLIC\tFINOVC\r\nFINOVC: LAHF\r\n\tPUSH\tAX\r\n\tMOV\tAL,BYTE PTR FLGOVC\t;STORE OVERFLOW FLAG TO INDICATE\r\n\tMOV\tBYTE PTR OVCSTR,AL\t;WHETHER AN OVERFLOW OCCURED\r\n\tPOP\tAX\r\n\tSAHF\r\nPUBLIC\t$CLROV\r\n$CLROV:\r\nPUBLIC\tCLROVC\r\nCLROVC: LAHF\r\n\tPUSH\tAX\t\t;SAVE EVERYTHING\r\n\tXOR\tAL,AL\t\t;NORMAL OVERFLOW MODE\r\n\tMOV\tBYTE PTR FLGOVC,AL\r\n\tPOP\tAX\r\n\tSAHF\r\n\tRET\r\n\r\n\r\n;\r\n; The reserve word tables have dispatch address the could be external.\r\n; ASM86 can only output external declarations during pass 1, so we\r\n; have to construct a chain of possible externals and check each one.\r\n; The following macro runs through the chain and declares any undefined\r\n; addresses as external :NEAR.  For more information, see the file\r\n; PS1:<BASIC.ASM86>BINTRP.H\r\n;\r\n\tDO_EXT\r\n;\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\r\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GWRAM.ASM",
          "type": "blob",
          "size": 12.375,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GWRAM - GW BASIC OEM Independent RAM Declarations\r\n\r\nCOMMENT\t*\r\n        --------- --- ---- -- ---------\r\n        COPYRIGHT (C) 1981 BY MICROSOFT\r\n        --------- --- ---- -- ---------\r\n        *\r\n\r\n\tINCLUDE\tGIO86U\r\n\t.SALL\r\n\r\n\t.RADIX\t10\r\n\r\nMUSIC=PLAYSW OR BEEPSW\r\nGRPMCL=1\r\nNMPAGE=1\r\n\r\n\tPUBLIC\tHEDING,$DATE,CERMSG\r\n\r\n\tQUOTE=42O\r\n\tCR=15O\r\n;\r\n\r\n\tPAGE\t\r\n\tSUBTTL Sign on message and other data to be discarded after INIT\r\n\r\nHEDING:\tACRLF\t\r\n\tDB\t\"(C) Copyright Microsoft 1982\"\r\n$DATE:\tDB\t\"         \"\t;$DATE\r\n\tACRLF\t\r\n\tDB\t00O\t\t;Terminate previous string.\r\n\r\nCERMSG:\tACRLF\t\t\t;Command line error message\r\n\tDB\t\"Error detected in command line\"\r\n\tACRLF\t\r\n\tDB\t00O\r\n\r\nCSEG\tENDS\t\t\t; End of code segment constants\r\n\tPAGE\t\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t; Start of data segment GW variables\r\n\tASSUME DS:DSEG\r\n\r\n;\r\n; ASM86 version don't need to fool around with offsets into OEMBAS,\r\n; as the linker can preload segments with data.  Thus, the R macros\r\n; need only define the label and a size if the variable is not intitalized.\r\n;\r\nR1\tMACRO\tNAME,SIZE\r\n\tQ=Q+SIZE\r\n\tQDS=QDS+SIZE\r\n\tPUBLIC\tNAME\r\n\tORG\t$-1\r\nNAME\tLABEL WORD\r\n\tORG\t$+1\r\nIF\tSIZE  \r\n\tDB\tSIZE DUP(?)\r\nENDIF \r\nENDM \r\n\r\nR\tMACRO\tNAME,SIZE\r\n\tQ=Q+SIZE\r\n\tQDS=QDS+SIZE\r\n\tPUBLIC\tNAME\r\nNAME\tLABEL WORD\r\nIF\tSIZE  \r\n\tDB\tSIZE DUP(?)\r\nENDIF \r\nENDM \r\n\r\nRINIT\tMACRO\tNAME,SIZE\r\n\tPUBLIC\tNAME\r\nNAME\tLABEL WORD\r\n\tQQ=NAME-MOVDAT-Q\r\nIF\tQQ  \r\n\t%OUT  *FATAL RINIT ERROR*\r\nENDIF \r\n\tQ=Q+SIZE\r\n\tQDS=QDS+SIZE\r\nENDM \r\n\r\nACRLF\tMACRO\t\r\n\tDB\t13D\r\n\tDB\t10D\r\nENDM \r\n\r\n\r\n\tQ=0\r\n\tQDS=0\r\n\tRINIT\tMOVDAT,0\r\n\tRINIT\tFREFLG,1\t;Flag to print BYTES FREE message\r\n\tDB\t0D\r\n\tRINIT\tINITFG,1\t;Initialization complete flag\r\n\tDB\t0D\t\t;INITFG\r\n\tRINIT\tESCFLG,1\t;Escape seq. in progress flag\r\n\tDB\t0D\r\n\tRINIT\tTWOBYT,1\t;Save location for collecting two byte chars\r\n\tDB\t0D\r\n\r\n;\r\n; Keyboard Support Variables\r\n;\r\n\tRINIT\tSTRTAB,16D*NMKEYF\t;SOFTKEY table\r\n;\r\n;** The following line is used by a source maint. tool - do not remove\r\n;** (OEM FUNCTION KEY DEFINITIONS) **************\r\n;\r\n\tDB\t\"LIST\"\t\t;FUNCTION 1\r\n\tDB\t0D\r\n\tDB\t11D DUP(?)\r\n\tDB\t\"RUN\"\t\t;FUNCTION 2\r\n\tDB\tOFFSET CR,0\r\n\tDB\t11D DUP(?)\r\n\tDB\t\"LOAD\"\t\t;FUNCTION 3\r\n\tDB\tOFFSET QUOTE,0\r\n\tDB\t10D DUP(?)\r\n\tDB\t\"SAVE\"\t\t;FUNCTION 4\r\n\tDB\tOFFSET QUOTE,0\r\n\tDB\t10D DUP(?)\r\n\tDB\t\"CONT\"\t\t;FUNCTION 5\r\n\tDB\tOFFSET CR,0\r\n\tDB\t10D DUP(?)\r\n\tDB\t\",\"\t\t;FUNCTION 6\r\n\tDB\tOFFSET QUOTE\r\n\tDB\t\"LPT1:\"\r\n\tDB\tOFFSET QUOTE,0\r\n\tDB\t7D DUP(?)\r\n\tDB\t\"TRON\"\t\t;FUNCTION 7\r\n\tDB\tOFFSET CR,0\r\n\tDB\t10D DUP(?)\r\n\tDB\t\"TROFF\"\t\t;FUNCTION 8\r\n\tDB\tOFFSET CR,0\r\n\tDB\t9D DUP(?)\r\n\tDB\t\"KEY\"\t\t;FUNCTION 9\r\n\tDB\t0D\r\n\tDB\t12D DUP(?)\r\n\tDB\t\"SCREEN 0,0,0\"\t;FUNCTION :\r\n\tDB\tOFFSET CR,0\r\n\tDB\t2D DUP(?)\r\n;**(END OF DEFINITIONS) *************************\r\n;The preceding line is used by a source maint. tool - do not remove.\r\n;\r\n\tRINIT\tENDTAB,0\r\n\tDIST=ENDTAB-STRTAB-(16D*NMKEYF)\r\nIF\tDIST  \r\n\t%OUT/++++BAD SOFTKEY PADDING+++++/\r\nENDIF \r\n\r\n\r\n\tRINIT\tCMDOFF,2\t;Index into ESCBUFF or STRTAB\r\n\tDW\t0D\r\n\tRINIT\tFKCNUM,1\t;Number of chars. per fun. key to display\r\n\tDB\t6D\t\t; on the last line\r\n\tRINIT\tACTPAG,1\t;Active page\r\n\tDB\t1 DUP(?)\r\n\tRINIT\tF_EDPG,1\t; Flag - =^O377 indicates program statement edit\r\n\tDB\t0\r\n\tRINIT\tSEMFLG,1\t; Flag - non-zero indicates INPUT; statement(no\r\n\tDB\t0\t\t;        CRLF at end of input)\r\n\tRINIT\tF_CRET,1\t;Zero indicates last character output was CR\r\n\tDB\t377O\r\n\tRINIT\tF_INST,1\t; Flag - =^O377 indicates insert mode\r\n\tDB\t0\r\n\tRINIT\tF_EDIT,1\t; Flag - non-zero indicates INLIN active\r\n\tDB\t0\r\n;\r\n;MACLNG variables for DRAW\r\n;\r\n\tRINIT\tDRWSCL,1\t;DRAW: SCALE\r\n\tDB\t00O\t\t;DRAW POS,2 ling factor\r\n\tRINIT\tDRWFLG,1\t;OPTION FLAGS\r\n\tDB\t00O\t\t;DRAW flag\r\n\tRINIT\tDRWANG,1\t;DRAW \"ANGLE\" (0..3)\r\n\tDB\t00O\t\t;DRAW translation angle\r\n\tRINIT\tMCLPTR,2\t;MAC LANG PTR\r\n\tDB\t2 DUP(?)\t;Other DRAW vars. not initialized\r\n\tRINIT\tMCLLEN,1\t;STRING LENGTH\r\n\tDB\t1 DUP(?)\r\n\tRINIT\tMCLTAB,2\t;PTR TO COMMAND TABLE\r\n\tDB\t2 DUP(?)\r\n;OEM Independent Music Locations\r\n\tRINIT\tOCTAVE,1\t;PLAY: OCTAVE\r\n\tDB\t4D\t\t;OCTAVE\r\n\tRINIT\tBEATS,1\t\t;BEATS\r\n\tDB\t120D\t\t;BEATS (default = 120 L4 notes per minute)\r\n\tRINIT\tNOTELN,1\t;NOTE LENGTH\r\n\tDB\t4D\t\t;NOTELN\r\n\tRINIT\tNOTE1L,1\t;One (current) Note Length\r\n\tDB\t4D\t\t;NOTE1L\r\n\tRINIT\tMSCALE,1\t;Note Length Scale Factor (ML,MN,MS)\r\n\tDB\t3D\t\t;MSCALE (default = 7/8 time)\r\n\tRINIT\tMMODE,1\t\t;Music Mode (Foreground/Background)\r\n\tDB\t0D\t\t;MMODE (default = forground)\r\n\tRINIT\tSNDTIC,1\t;Sound/Clock tick modulo counter\r\n\tDB\t1 DUP(?)\r\n\tRINIT\tSNDBAS,2\t;Base addr of Sound Queue Cells\r\n\tDB\t2 DUP(?)\r\n\tRINIT\tSNDOUT,2\t;Base addr of Sound Queue Buffer\r\n\tDB\t2 DUP(?)\r\n\tPAGE\t\r\n\tSUBTTL  Page Dependent OEM Independent Variables\r\n\r\n; Page Dependent variables arranged as follows:\r\n; Variables which are initialized by block move are declared using the RINIT\r\n; macro.  These declarations are made within the definition of macro PDIRAM\r\n; (page dependent initialized RAM).\r\n; Variables which are not initialized by block move are declared using the R\r\n; macro.  These declarations are made within the definition of macro PDURAM\r\n; (page dependent uninitialized RAM).\r\n; The memory map for multi page page dependent variables is as follows:\r\n;--------------------------------------------------------------------------\r\n;\r\n; CS: resident initialization values are copied to DS: by the same copy\r\n;     as usual.\r\n;\r\n;--------------------------------------------------------------------------\r\n;\r\n; DS:PDIDS1:              ;Beginning of ini value block copied from CS:\r\n;                         ; This block is used to initialize pages at\r\n;                         ; various times during execution.\r\n;\r\n;           (initialization values set by CS: to DS: block move)\r\n;\r\n; DS:FPDVAR:              ;First page dependent variable\r\n;\r\n;           (first come vars initializable by block move from PDIDS1.\r\n;            Then come all other vars. which are page dependent.)\r\n;\r\n; DS:LPDVAR:              ;Address of end of variables for active page\r\n;                         ; The variables between FPDVAR and LPDVAL are the\r\n;                         ; ones that are labeled as per RINIT and R macros.\r\n;\r\n; (Lastly comes (LPDVAR-FPDVAR)*NMPAGE RAM locations used to store the state\r\n;   of each page while it is not active.)\r\n;\r\n;In systems where only one page is available label FPDVAL is made to\r\n; coincide with label PDIDS1 and there are no locations reserved to store\r\n; the state of the page while it is not active.\r\n;\r\n\r\n\tPUBLIC\tPDIDS1\t\t;Start of DS: init block.\r\n\tPUBLIC\tFPDVAR,LPDVAR\t;Addresses of first and last active page vars in DS:\r\n\r\nPDIRAM\tMACRO\t\r\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n;       Start of declaration of page dependent variables\r\n;       which are initialized by block move either by\r\n;       GWINIT (for one page systems) or\r\n;       PDVINI (Page Dependent Var INI for multi-page systems\r\n;\r\n;CAUTION!!!\r\n;\r\n; The PDIRAM module is invoked several times.  CS: space should be\r\n; reserved only once.  To solve this problem pseudos which declare\r\n; CS: values must be accessed through a macro which can either be\r\n; defined as calls to the appropriate pseudo or as NOPs.\r\n; Currently, DB, DW, and DT are the only macros supported in this manner.\r\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n\r\n;\r\n;Screen Editor Support Variables\r\n;\r\n\r\n\tRINIT\tKEYSW,1\t\t;Flag for softkey display\r\n\tDB\t0\t\t;Flag: 0=do not display softkeys.\r\nENDM \r\n\r\nPDURAM\tMACRO\t\r\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n;       Start of declaration of page dependent variables\r\n;\r\n; The PDRAM module is invoked several times.  CS: space should\r\n; not be reserved.  DS: lables must be declared only once.\r\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\r\n\r\n;The following is page dependent data unique to the SCNDRV module\r\n;\r\n\tR\tLINLEN,1\t; Number of characters in a line\r\n\tR\tLINCNT,1\t; Number of lines\r\n\tR\tCRTWID,1\t; Characters per line\r\n\tR\tWDOTOP,1\t; Top line in window(1-[LINCNT])\r\n\tR\tWDOBOT,1\t; Bottom line in window([WDOTOP]-[LINCNT])\r\n\tR\tWDOLFT,1\t; Leftmost column in window(1-[CRTWID])\r\n\tR\tWDORGT,1\t; Rightmost column plus one([WDOLFT]-[LINCNT])\r\n\tR\tWDTFLG,1\t; Default width of SCRN:\r\n\tR\tLINTTB,2*(NMLINE+1)\t; Line Terminator table\r\n\tR\tTRMCUR,2\t; Address of current terminator entry (2 bytes)\r\n\tR\tFSTLIN,1\t; Line number saved by SCNSTM call\r\n\tR\tFSTCOL,1\t; Column saved as above and decreases to WDOLFT\r\n\tR\tLSTLIN,1\t; Line number saved by SCNSTM and grows as the\r\n\tR\tLSTCOL,1\t; Column saved as above which grows as the\r\n\t\t\t\t;   col on LSTLIN).\r\n\r\n;NOTE: Some Routines expect CSRX to immediately follow CSRY\r\n\tR\tCSRY,1\t\t; Current line(1-[LINCNT])\r\n\tR\tCSRX,1\t\t; Current column(1-[CRTWID])\r\nENDM \r\n\r\n\r\nRINIT\tMACRO\tNAME,SIZE\r\n\tQDS=QDS+SIZE\r\nENDM \r\n\r\n\tQDS=Q\r\n\r\n\tR\tPDIDS1,0\t;Page Dependent DS: init. value block start\r\n\tPDIRAM\t\t\t;Insert Ini values\r\n\tFPDVAR=PDIDS1\t\t;INI area and First Page Dependent VARiable\r\n\t\t\t\t; are overlaid in this case\r\nRINIT\tMACRO\tNAME,SIZE\r\n\tPUBLIC\tNAME\r\nNAME\tLABEL WORD\r\n\tQQ=NAME-MOVDAT-QDS\r\nIF\tQQ  \r\n\t%OUT  *FATAL RINIT ERROR*\r\nENDIF \r\n\tQ=Q+SIZE\r\n\tQDS=QDS+SIZE\r\nENDM \r\n\r\n;Although RINIT is used subsequently there are no more CS: RAM locations\r\n; to declare.   The RINIT will be used for DS: declaration only\r\n;\r\n;\r\n; Now declare the labeled DS: for 1 page systems.  This area is the\r\n;       labeled active page for multi-page systmes\r\n;\r\n\tPDIRAM\t\t\t;Declare Active Page Inited RAM\r\n;\r\n\tPDURAM\t\t\t;Declare Active Page Uninit RAM\r\n\tR\tLPDVAR,0\t;End of active page vars in DS:\r\n\r\nRINIT\tMACRO\tNAME,SIZE\r\nIF\tSIZE  \r\n\tDB\tSIZE DUP(?)\r\n\tQDS=QDS+SIZE\r\nENDIF \r\nENDM \r\nR\tMACRO\tNAME,SIZE\r\nIF\tSIZE  \r\n\tDB\tSIZE DUP(?)\r\n\tQDS=QDS+SIZE\r\nENDIF \r\nENDM \r\n;\r\n;Now put back the R macro for use by Page Independent Uninitialized RAM\r\n; declarations.\r\n;\r\n;P.I.U. RAM MUST be declared after all P.D.U. RAM, P.D.I. RAM,\r\n; and P.I.I. RAM.\r\n;\r\n\r\nR\tMACRO\tNAME,SIZE\r\n\tPUBLIC\tNAME\r\nNAME\tLABEL WORD\r\nIF\tSIZE  \r\n\tDB\tSIZE DUP(?)\r\nENDIF \r\n\tQQ=NAME-MOVDAT-QDS\r\nIF\tQQ  \r\n\t%OUT  *FATAL RINIT ERROR*\r\nENDIF \r\n\tQ=Q+SIZE\r\n\tQDS=QDS+SIZE\r\nENDM \r\n\tPAGE\t\r\n\tSUBTTL  Page Independent Uninitialized RAM Location Definitions\r\n\r\n;OEM Independent Graphics Locations\r\n;\r\n\tR\tGRPACX,2\t; Previous X Coordinate\r\n\tR\tGRPACY,2\t; Previous Y Coordinate\r\n\tR\tATRBYT,1\t;Attribute Byte to Store\r\n\tR\tGXPOS,2\t\t;X Position of Second Coordinate\r\n\tR\tGYPOS,2\t\t;Y Position of Second Coordinate\r\n\tR1\tMAXUPD,2\t;Address of Major Axis Move Update\r\n\tR1\tMINUPD,2\t;Address of Minor Axis Move Update\r\n\tR\tMAXDEL,2\t;Largest Delta for Line\r\n\tR\tMINDEL,2\t;Smaller of 2 Deltas for Line\r\n\tR\tASPECT,2\t;ASPECT RATIO\r\n\tR\tCENCNT,2\t;END CIRCLE POINT COUNT\r\n\tR\tCLINEF,1\t;LINE-TO-CENTER FLAG\r\n\tR\tCNPNTS,2\t;1/8 NO. OF PTS IN CIRCLE\r\n\tR\tCPLOTF,1\t;PLOT FLAG\r\n\tR\tCPCNT,2\t\t;1/8 NO. OF PTS IN CIRCLE\r\n\tR\tCPCNT8,2\t;NO. OF PTS IN CIRCLE\r\n\tR\tCRCSUM,2\t;CIRCLE SUM\r\n\tR\tCSTCNT,2\t;START COUNT\r\n\tR\tCSCLXY,1\t;FLAG WHETHER ASPECT WAS .GT. 1\r\n\tR\tCSAVEA,2\t;ADVGRP C save area\r\n\tR\tCSAVEM,1\t;ADVGRP C save area\r\n\tR\tCXOFF,2\t\t;X OFFSET FROM CENTER SAVE LOC\r\n\tR\tCYOFF,2\t\t;Y OFFSET SAVE LOCATION\r\n\tR\tLOHMSK,1\t;RAM SAVE AREA FOR LEFT OVERHANG\r\n\tR\tLOHDIR,1\t;*** LOHMSK & LOHDIR MUST BE CONTIG !\r\n\tR\tLOHADR,2\r\n\tR\tLOHCNT,2\r\n\tR\tLFPROG,1\t;PAINT: SCAN LINE ALREADY PAINTED FLAGS\r\n\tR\tRTPROG,1\r\n\tR\tSKPCNT,2\t;SKIP COUNT\r\n\tR\tMOVCNT,2\t;MOVE COUNT\r\n\tR\tPDIREC,1\t;PAINT DIRECTION\r\n\tR\tPUTFLG,1\t;WHETHER DOING PUT() OR GET()\r\n\tR\tQUEINP,2\r\n\tR\tQUEOUT,2\r\n\tR\tPSNLEN,2\t;Queue present length\r\n\tR\tQUELEN,2\t;Maximum queue length\r\n\r\n\tR\tSAVLEN,2\t;used by BLOAD, BSAVE\r\n\r\n;\r\n;Device Variables\r\n;\r\n\r\n\tPUBLIC\tFOPTSZ\r\n\tFOPTSZ=64D\t\t;size of file open options buffer\r\n\r\n\tR\tFILOPT,FOPTSZ\t;buffer for Special-Device Open Options\r\n\r\n;\r\n;Line Printer variables\r\n;\r\n;       note: If size of LPT Device Control Block changes,\r\n;             routine GLPDCB in GIOLPT must be changed.\r\n;\r\n\tR\tLP1DCB,4*NMLPT\t;LPT1 device control block\r\n\t\t\t\t;2 bytes (width, position)\r\n;\r\n;Keyboard variables\r\n;\r\n\tPUBLIC\tKYBQSZ\r\n\tKYBQSZ=32D\r\n\tR\tKYBQDS,8\t;queue descriptor (for format see GIO86)\r\n\tR\tKYBQUE,KYBQSZ\t;buffer circular key queue\r\n\r\n;\r\n;RS232C variables\r\n;\r\n\tR\tMSWSIZ,2D\t;/M: value\r\n\tR\tMSWFLG,1D\t;/M: exists flag\r\n\tR\tCSWSIZ,2D\t;/C: value\r\n\tR\tCSWFLG,1D\t;/C: exists flag\r\n\tR\tNEWDS,2D\t;New DS:\r\n\tR\tCOMDSC,18D\t;buffer used to communicate RS232 requests to OS\r\n\tR\tCM1DCB,24D*NMCOMT\t;COM1 device control block (24 bytes per device)\r\n\tR\tLSTIOB,1\t;Contains Last RS232 unit accessed (0..15)\r\n\t\t\t\t;2 bytes (width, position)\r\n\t\t\t\t;2 bytes (width, position)\r\n;\r\n; RAM USED FOR EVENT TRAPPING\r\n;\r\n\tR\tTRPTBL,3*NUMTRP\t;trap table - see GWSTS\r\n\tR\tONGSBF,1\t;see NEWSTT\r\n\tR\tSOFTKY,1\t;used by key trapping in GWSTS\r\n\tR\tF_SUPR,1\t; Flag - non-zero =  super shift expansion\r\n\r\nDSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "GWSTS.ASM",
          "type": "blob",
          "size": 61.75,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   GWSTS - GW-BASIC Common Statement Support\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- ---------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT\r\n--------- --- ---- -- ---------\r\n\r\n        *\r\n\r\n;General Feature Switches (Not OEM Switches)\r\n;\r\nKANADT=0\t\t\t;Japanese date format(\"[yy]yy/mm/dd\")\r\nSTKEYF=1D\t\t\t;Start number of string function keys\r\nIBMCSR=IBMLIK\t\t\t;IBM comp. cursor interface\r\nFKEYCR=74O\t\t\t;CR character for F-KEY display line\r\nGWLEV2=0\t\t\t;Version 2.0 of GW BASIC-86\r\n\r\n;OEM Switches (ONLY INCLUDE IF ABSOLUTELY NECESSARY)\r\n;\r\nMCI=0\r\nTETRA=0\r\nMELCO=0\r\nZENITH=0\r\n\r\n;Definition of scroll types\r\n; Choice of scroll type is by switch SCROLT.\r\n; Switches defined here are used to implement a specific SCROLT type.\r\n; If other scroll types are needed then additional SCROLT types should be\r\n;   defined here.\r\n\tINVLIN=SCROLT\t\t;Invisible (function key) Line\r\n\tFKFSRL=(SCROLT-1) AND 1\t;Clear fkeys/full scroll/rewrite fkeys\r\n\r\n;Local Switches\r\n;\r\n\tKEYFSW=0\t\t;No KEY Function\r\n\tINTHND=SCP\t\t;MSDOS Ctl-C interrupt handler\r\n\tCLRFMT=(MELCO-1) AND (ZENITH-1)\t;New COLOR parameter format\r\n\tFKEYCR=27D\t\t;IBM CR FKey display line graphic\r\n\t.SALL\r\n\t.RADIX\t10\r\n\r\n\tEXTRN\tCHRGTR:NEAR,SYNCHR:NEAR,SNERR:NEAR,FCERR:NEAR,GETBYT:NEAR\r\n\tEXTRN\tUSERR:NEAR\r\n\r\n\r\nIF\tCPM86  \r\nCPMXIO\tMACRO\tDFUN\r\n\tMOV\tCL,LOW OFFSET DFUN\r\n\tINT\t340O\t\t;CPM86 system call\r\nENDM \r\nENDIF \r\n\r\nDOSIO\tMACRO\tDFUN\r\n\tMOV\tAH,LOW OFFSET DFUN\r\n\tINT\t33\t\t;MS-DOS system call\r\nENDM \r\n\tGDAT=42D\t\t;MS-DOS Get Date Function\r\n\tSDAT=43D\t\t;MS-DOS Set Date Function\r\n\tGTIM=44D\t\t;MS-DOS Get Time Function\r\n\tSTIM=45D\t\t;MS-DOS Set Time Function\r\n\tPUBLIC\tPATCHG\r\nPATCHG:\tDB\t500D DUP(?)\t;GW patch space\r\n\tPAGE\t\r\n\tSUBTTL CLS,LOCATE,WIDTH (of screen),LCOPY\r\n\r\n\tPUBLIC\tCLS,LOCATE,GWWID,LCOPYS,COLOR,GETLIN,SCRENF,SCREEN\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tLINCNT:WORD,LINLEN:WORD,CSRY:WORD,CSRX:WORD,BUF:WORD\r\nDSEG\tENDS\r\n\r\n\tEXTRN\tGETFBC:NEAR\r\n\tEXTRN\tSCRSTT:NEAR,SCRATR:NEAR\r\n\tEXTRN\tSETCLR:NEAR,SWIDTH:NEAR\r\n\tEXTRN\tLCPY:NEAR\r\n\r\n\tCOMMA=\",\"\r\n\tOPAREN=\"(\"\r\n\tCPAREN=\")\"\r\n\tQUOTE=34D\r\n\tBKSPC=8D\r\n\tCR=13D\r\n\tLF=10D\r\n\tPAGE\t\r\n;CLS: CLear Screen issues an escape sequence to clear\r\n;     the CRT.  Sequences are ANSII standard whereas the machine\r\n;     default is not.  CLS resets the graphics cursor position.\r\n;ENTRY - none\r\n;EXIT  - none\r\n;USES  - none\r\n;\r\n\tEXTRN\tCLRSCN:NEAR\r\nCLS:\tCALL\tSCNINT\t\t;Test for optional parameter\r\n\tCMC\t\r\n\tPUSHF\t\r\n\tPUSH\tAX\r\n\tCALL\tEOSCHK\t\t;Test for end of statement\r\n\tPOP\tAX\r\n\tPOPF\t\r\n\tPUSH\tBX\r\n\tCALL\tCLRSCN\r\n\tPOP\tBX\r\n\tRET\t\r\n\tPAGE\t\r\n;LOCATE: Parse the following syntax:\r\n;       LOCATE [Y] [, [X] [, [CURSOR] [, [START] [, [STOP] ]]]\r\n;\r\n\tEXTRN\tSCNPOS:NEAR\r\nLOCATE:\tCALL\tSCNINT\t\t;Get optional Y parameter\r\n\tJNB\tYLCPRM\t\t;Parameter present\r\n\tCALL\tGTLINE\t\t;Get the current screen position\r\nYLCPRM:\tMOV\tDL,AL\r\n\tOR\tAL,AL\t\t;Test for LOCATE 0\r\n\tJZ\tGOFCER\r\n\tSUB\tDL,BYTE PTR KEYSW\t;Increment if PF-keys are displayed\r\n\tCMP\tDL,BYTE PTR LINCNT\t;Check for parameter range\r\n\tJA\tGOFCER\r\n\tPUSH\tAX\t\t;Save new Y location\r\n\tCALL\tSCNINT\t\t;Get optional X parameter\r\n\tJNB\tXLCPRM\t\t;Parameter present\r\n\tCALL\tSCNPOS\t\t;Get the current screen position\r\n\tMOV\tAL,DH\t\t;Default to current cursor position\r\nXLCPRM:\tMOV\tDL,AL\r\n\tDEC\tDL\t\t;Dissallow LOCATE ,0\r\n\tCMP\tDL,BYTE PTR LINLEN\t;Check for parameter range\r\n\tJAE\tGOFCER\r\n\tPUSH\tAX\t\t;Save new X\r\n\tCALL\tSCNINT\t\t;Cursor on/off - 0=off else on\r\n\tEXTRN\tCSRATR:NEAR\r\n\tMOV\tAH,LOW 377O\t;Ensure non-zero\r\n\tJNB\tLOCPR1\t\t;Parameter 1 found\r\n\tXOR\tAH,AH\t\t;Flag as a default\r\nLOCPR1:\tPUSH\tAX\t\t;Push first parameter and flag\r\n\tCALL\tSCNINT\t\t;Get next parameter\r\n\tMOV\tAH,LOW 377O\t;Ensure non-zero flag\r\n\tJNB\tLOCPR2\t\t;Parameter 2 found\r\n\tXOR\tAH,AH\t\t;Flag as a default\r\nLOCPR2:\tPUSH\tAX\t\t;Push second parameter and flag\r\n\tCALL\tSCNINT\t\t;Get next parameter\r\n\tMOV\tAH,LOW 377O\t;Ensure non-zero flag\r\n\tJNB\tLOCPR3\t\t;Parameter 3 found\r\n\tXOR\tAH,AH\t\t;Flag as a default\r\nLOCPR3:\tPUSH\tAX\t\t;Push third parameter\r\n\tCALL\tEOSCHK\t\t;Check for end of statement\r\n\tMOV\tDX,BX\t\t;Save text pointer\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tPOP\tAX\t\t;Recover three parameters\r\n\tPUSH\tDX\t\t;Save text pointer\r\n\tCALL\tCSRATR\t\t;Set Cursor Attribute (OEM routine)\r\n\tJB\tGFCERR\t\t;Declare error from CSRATR\r\n\tPOP\tBX\t\t;Text pointer\r\nSETLOC:\tMOV\tAX,BX\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tPUSH\tAX\r\n\tMOV\tBH,CL\r\n\tEXTRN\tSCNLOC:NEAR\r\n\tMOV\tAX,BX\r\n\tCALL\tSCNLOC\t\t;position cursor at line [AL], col [AH]\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCSRTYP:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tCSRDSP:NEAR\r\n\tMOV\tDX,AX\t\t;Load cursor position\r\n\tMOV\tAL,LOW 3D\t;Signal for user cursor\r\n\tCALL\tCSRDSP\t\t;Set cursor\r\n\tPOP\tBX\t\t;Restore text pointer\r\n\tRET\t\r\n\r\n\r\nGOFCER:\tJMP\tFCERR\r\n\tPAGE\t\r\n;GWWID: Parsing for WIDTH [X] [, [Y]]\r\n;ENTRY - WIDTH LPRINT is not a possibility at this point.\r\n;EXIT  - AL = X param\r\n;        BX = text pointer\r\n;\r\nGWWID:\tCALL\tSCNINT\t\t;Get X dimension\r\n\tJNB\tXPRAM\t\t;X param found\r\n\tMOV\tAL,BYTE PTR LINLEN\t;Use current as default\r\nXPRAM:\tPUSH\tAX\t\t;Save for RET to WIDTH\r\n\tPUSH\tAX\t\t;Save for GWWID use\r\n\tCALL\tSCNINT\t\t;Get Y dimension\r\n\tJNB\tYPRAM\t\t;Y param found\r\n\tMOV\tAL,BYTE PTR LINCNT\t;Use current as default\r\nYPRAM:\tPUSH\tAX\r\n\tCALL\tEOSCHK\t\t;Must be at end of statement\r\n\tPOP\tAX\r\n\tCMP\tAL,BYTE PTR LINCNT\t;Set CC's for Y dimension change\r\n\tLAHF\t\r\n\tMOV\tCX,AX\r\n\tPOP\tAX\r\n\tCMP\tAL,BYTE PTR LINLEN\t;Set CC's for X dimension change\r\n\tLAHF\t\r\n\tAND\tAH,CH\t\t;Set CC's for X OR Y change\r\n\tSAHF\t\r\n\tJZ\tGWWIDX\t\t;No change - done\r\n\tPUSH\tBX\t\t;Save text pointer\r\n\tPUSH\tAX\t\t;save Width\r\n\tPUSH\tCX\t\t;save Height\r\n\tCALL\tSWIDTH\t\t;Machine dependent set logic\r\n\tPOP\tCX\r\n\tPOP\tAX\r\n\tJB\tGFCERR\t\t;Error detected within SWIDTH\r\n\tPOP\tBX\t\t;Restore text pointer\r\nGWWIDX:\tPOP\tAX\t\t;Return X dimension for WIDTH\r\n\tRET\t\r\n\r\nGFCERR:\tJMP\tFCERR\r\n\r\n\tPAGE\t\r\n;LCOPY: Copy the screen to the line printer.\r\n;ENTRY - BX = text pointer\r\n;EXIT  - BX = text pointer\r\nLCOPYS:\tMOV\tDL,LOW 0\t;default parm is 0\r\n\tJZ\tNOPARM\t\t;branch if end-of-statement\r\n\tCALL\tGETBYT\t\t;[DL]=parm\r\nNOPARM:\tCALL\tEOSCHK\t\t;Check for unwanted parameters\r\n\tPUSH\tBX\t\t;Save text pointer\r\n\tCALL\tLCPY\r\n\tJB\tGFCERR\t\t;Error detected in low level routine\r\n\tPOP\tBX\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  COLOR,GETLIN,SCREEN (function and statement)\r\n;COLOR: Set the foreground, background, and boarder attributes.\r\n;       SYNTAX - COLOR [FOR] [,BACK [,BOARD]]\r\n;       Where - FOR   = Foreground attribute\r\n;               BACK  = Background attribute\r\n;               BOARD = Boarder attribute\r\n;\r\nCOLOR:\tCALL\tGTPRMS\t\t;Get arbitrary number of int. parms.\r\nCOLOR1:\tPUSH\tBX\t\t;Save text pointer\r\n\tMOV\tBX,DI\t\t;Get parameter buffer pointer\r\n\tCALL\tSETCLR\t\t;Check colors for validity\r\n\tJB\tGFCERR\t\t;Error detected by low level routine\r\n\tPOP\tBX\r\n\tRET\t\r\n\tPAGE\t\r\n;GETLIN: Obtain the current cursor line number.\r\n;EXIT - FAC = cursor line number\r\n;       BX preserved\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tLINLEN:WORD,LINCNT:WORD,KEYSW:WORD\r\nDSEG\tENDS\r\nGETLIN:\tCALL\tGTLINE\r\n\tPUSH\tBX\r\n\tXOR\tBX,BX\r\n\tMOV\tBL,AL\r\n\tCALL\tMAKINT\r\n\tPOP\tBX\r\n\tCALL\tCHRGTR\r\n\tRET\t\r\n\r\n;GTLINE: Get the line number of the character position to which the next\r\n;character would be written.\r\n;Entry - none\r\n;Exit  - [AL] = line number\r\n;Uses  - AH\r\n;\r\nGTLINE:\tMOV\tAL,BYTE PTR CSRY\t;BX = cursor line number\r\n\tMOV\tAH,BYTE PTR CSRX\r\n\tCMP\tAH,BYTE PTR LINLEN\r\n\tJBE\tGETLN0\t\t;BRIF will not wrap before next char is output\r\n\tMOV\tAH,BYTE PTR LINCNT\t;AL=last valid line number\r\n\tDEC\tAH\t\t;Scroll always occurs on line [LINCNT]-1\r\n\tCMP\tAL,AH\r\n\tJAE\tGETLN0\t\t;BRIF wrap will cause scroll\r\n\tINC\tAL\t\t;Else wrap will cause line number increment\r\nGETLN0:\tRET\t\r\n\tPAGE\t\r\n;SCRENF: Obtain character from screen.\r\nSCRENF:\r\n\tCALL\tCHRGTR\t\t;Eat the SCREEN token since SCREEN is\r\n\t\t\t\t;defined as a statement and the function\r\n\t\t\t\t;is dispatched to by EVAL.\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET OPAREN\t;Check for \"(\"\r\n\tCALL\tSCNINT\t\t;Get Y parameter\r\n\tJB\tFCERGO\t\t;Parameter not present\r\n\tDEC\tAL\r\n\tCMP\tAL,BYTE PTR LINCNT\t;Check range [1,LINCNT]\r\n\tJAE\tFCERGO\t\t;Out of range\r\n\tINC\tAL\r\n\tPUSH\tAX\t\t;Y param.\r\n\tCALL\tSCNINT\t\t;Check for X param\r\n\tJB\tFCERGO\t\t;Error - no X param\r\n\tDEC\tAL\r\n\tCMP\tAL,BYTE PTR LINLEN\t;Check range [1,LINLEN]\r\n\tJAE\tFCERGO\t\t;Out of range\r\n\tINC\tAL\r\n\tPUSH\tAX\t\t;X param.\r\n\tCMP\tAH,LOW OFFSET CPAREN\t;Check terminator\r\n\tJE\tSCRCHR\t\t;End of params - go get char.\r\n\tCALL\tSCNINT\r\n\tJB\tFCERGO\t\t;Error - no CPAREN and no Z param.\r\n\tCMP\tAH,LOW OFFSET CPAREN\t;Must now have CPAREN\r\n\tJNE\tFCERGO\r\n\tCMP\tAL,LOW 00O\t;Is Z zero?\r\n\tJE\tSCRCHR\t\t;Yes - go get screen character\r\n\tPOP\tAX\t\t;Retrieve X param\r\n\tPOP\tCX\t\t;Retrieve Y param\r\n\tPUSH\tBX\t\t;Save text pointer\r\n\tMOV\tBX,CX\t\t;Call SCRATR with AX=X,BX=Y\r\n\tCALL\tSCRATR\t\t;Get screen attributes\r\n\tJMP\tSHORT SCRENX\r\n\r\nFCERGO:\tJMP\tFCERR\r\n\r\nSCRCHR:\tPOP\tAX\t\t;Retrieve col number\r\n\tPOP\tCX\t\t;Retrieve row number\r\n\tPUSH\tBX\t\t;Save the text pointer\r\n\tEXTRN\tSCRINP:NEAR\r\n\tPUSH\tDX\r\n\tMOV\tDL,CL\r\n\tMOV\tDH,AL\r\n\tSTC\t\t\t;Indicate call is from SCREEN function\r\n\tCALL\tSCRINP\t\t;[AX]=Read char at (DH,DL)\r\n\tMOV\tBX,AX\t\t;return result in BX\r\n\tPOP\tDX\r\nSCRENX:\tCALL\tMAKINT\t\t;Set FAC\r\n\tPOP\tBX\t\t;Retrieve text pointer\r\n\tDEC\tBX\r\n\tCALL\tCHRGTR\r\n\tRET\t\r\n\tPAGE\t\r\n;SCREEN: This statement has no standard syntax.  It is handled\r\n;        by parsing single byte integers until end of statement.\r\n;        Parameters may be null (appearance of a comma before an\r\n;        expression is encountered).\r\n;       SCRSTT (machine dependent) is called to process parameters\r\n;       which are in a list which is headed by a one word parameter\r\n;        count.  The remaining list entries are two bytes long.\r\n;        The first byte is 0 if the SCREEN parameter was null.\r\n;        The second byte is the parameter value if it is nonnull\r\n;        or meaningless (if the parameter was null).\r\n\r\nSCREEN:\tCALL\tGTPRMS\t\t;Get single byte integer parms\r\n\tPUSH\tBX\r\n\tMOV\tBX,DI\r\n\tCALL\tSCRSTT\t\t;Process params\r\n\tJB\tFCERGO\t\t;Error detected in low level routine\r\n\tPOP\tBX\t\t;Restore text pointer\r\n\tRET\t\r\n\r\n\r\nGTPRMS:\tMOV\tDI,OFFSET BUF\t;Parameters stored in BUF\r\n\tXOR\tCX,CX\t\t;Initialize parameter count\r\n\tINC\tDI\t\t;Reserve parameter count location\r\nSCRLOP:\tINC\tCX\t\t;Count the param\r\n\tPUSH\tCX\r\n\tPUSH\tDI\r\n\tCALL\tSCNINT\t\t;Look for a parameter\r\n\tPOP\tDI\r\n\tPOP\tCX\r\n\tJZ\tSTTEND\t\t;End of statement encountered\r\n\tJNB\tPRMFND\t\t;Parameter found (AH = separator)\r\n\tXOR\tAX,AX\t\t;Indicate a null parameter\r\nPRMFND:\tXCHG\tAH,AL\r\n\tMOV\tWORD PTR 0[DI],AX\t;Load parameter to list\r\n\tINC\tDI\t\t;Next list entry\r\n\tINC\tDI\r\n\tJMP\tSHORT SCRLOP\t;Go get next param\r\n\r\n\r\nSTTEND:\tJB\tNOPRM\r\n\tMOV\tBYTE PTR 0[DI],LOW 255D\t;Set param. exists flag\r\n\tMOV\tBYTE PTR 1[DI],AL\r\n\tINC\tCX\r\nNOPRM:\tDEC\tCX\r\n\tMOV\tDI,OFFSET BUF\t;Reset list index\r\n\tMOV\tBYTE PTR 0[DI],CL\t;Head list with param count\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  PUT & GET (Distinguish Disk from Graphics)\r\n\r\n\tPUBLIC\tPUT,GET\r\n\r\n\tEXTRN\tDPUTG:NEAR,GPUTG:NEAR\r\n\r\n;PUT: This code parses enough of the PUT/GET statement to\r\n;GET: distinguish between the graphics and disk versions of\r\n;     these commands.\r\n;       The accepted technique is to search for a \"(\".  This\r\n;       does not always allow for file number expressions which begin\r\n;       with  \"(\".\r\n;ENTRY: [BX] points to the character following the token.\r\n;EXIT  - Exit is made by jumping to the appropriate PUT/GET\r\n;        code.\r\n;        [BX] - restored to entry value before call of PUT/GET code.\r\n\r\nPUT:\tMOV\tCX,1\t\t;Set PUT flag\r\n\tJMP\tPARSE\r\nGET:\tXOR\tCX,CX\t\t;Set GET flag\r\nPARSE:\tPUSH\tCX\t\t;Save indication of PUT or GET\r\n\tPUSH\tBX\t\t;Save text pointer\r\n\tCMP\tAL,LOW \"(\"\t;Test for \"(\"\r\n\tJE\tGRPVER\t\t;branch if graphics version\r\n\tCMP\tAL,LOW \"@\"\t;test for relative GET/PUT\r\n\tJNE\tDSKVER\t\t;Disk code may have no \"(\" or \"@\"\r\nGRPVER:\tPOP\tBX\t\t;Restore text pointer\r\n\tPOP\tAX\r\n\tJMP\tGPUTG\t\t;Go to graphics PUT/GET\r\n\r\nDSKVER:\tPOP\tBX\t\t;Restore text pointer\r\n\tPOP\tAX\t\t;Get PUT/GET flag\r\n\tJMP\tDPUTG\r\n\r\n\tPAGE\t\r\n\tSUBTTL  Parsing Routines for GWSTS\r\n\tPUBLIC\tSCNINT,EOSCHK\r\n\r\n;SCNINT: Test for an optional integer parameter.\r\n;       If a comma or EOL is discovered assume parameter is missing.\r\n;       Otherwise evaluate the parameter.\r\n;EXIT - [AL] = parameter value\r\n;       C set - no parameter found\r\n;       C reset - parameter found\r\n;USES - ALL\r\nSCNINT:\tDEC\tBX\r\n\tCALL\tCHRGTR\r\n\tJZ\tNOMORE\t\t;EOL - Param null\r\n\tCMP\tAL,LOW OFFSET COMMA\r\n\tJZ\tOMITD\t\t;Comma found. Param null.\r\n\tCALL\tGETBYT\t\t;Evaluate parameter\r\n\tPUSH\tAX\t\t;Save parameter\r\n\tDEC\tBX\t\t;Prepare to test expression terminator\r\n\tCALL\tCHRGTR\r\n\tJZ\tTRMOK\t\t;EOL caused termination - OK\r\n\tCMP\tAL,LOW OFFSET COMMA\r\n\tJZ\tTRMCOM\t\t;Comma caused termination - OK\r\n\tCMP\tAL,LOW OFFSET CPAREN\t;CPAREN caused termination - OK\r\n\tJZ\tTRMCOM\r\n\tPOP\tAX\t\t;Retrieve param.\r\n\tJMP\tFCERR\t\t;All other terminators not OK\r\n\r\nTRMCOM:\tINC\tBX\t\t;Move over comma\r\nTRMOK:\tMOV\tCL,AL\t\t;Save terminator\r\n\tPOP\tAX\t\t;Retrieve parameter value\r\n\tMOV\tAH,CL\t\t;Return with AH = terminator\r\n\tCLC\t\t\t;Flag param. found\r\n\tRET\t\r\n\r\nOMITD:\tINC\tBX\r\nNOMORE:\tMOV\tAH,AL\t\t;Save terminator\r\n\tMOV\tAL,LOW 0D\t;Set param value to 0, save flags\r\n\tSTC\t\t\t;Flag param. not found\r\n\tRET\t\r\n\tPAGE\t\r\n;EOSCHK: Detect garbage beyond end of statement\r\n;ENTRY - BX = text pointer\r\n;EXIT  - AL = 0 & all other registers preserved or\r\n;      - Exit on error through FCERR\r\n;\r\nEOSCHK:\r\n\tDEC\tBX\t\t;Back up text pointer\r\nEOSCH1:\r\n\tCALL\tCHRGTR\t\t;Get next character (skipping blanks)\r\n\tJZ\tEOSCKX\t\t;End of statement\r\n\tJMP\tSNERR\t\t;Not EOS - error\r\nEOSCKX:\tRET\t\r\n\r\n\tPAGE\t\r\n\tSUBTTL  Graphics Support Specific to the 8086\r\n\r\n\tPUBLIC\tLINLP3\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tMINDEL:WORD,MAXDEL:WORD,MINUPD:WORD,MAXUPD:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tSETC:NEAR\r\n\r\n;LINLP3: Inner loop of line code.\r\n\r\nLINLP3:\tCALL\tSETC\t\t;SET CURRENT POINT\r\n\tADD\tDX,WORD PTR MINDEL\t;ADD SMALL DELTA TO SUM\r\n\tCMP\tDX,WORD PTR MAXDEL\t;TIME TO UPDATE MINOR?\r\n\tJB\tLINLOP\t\t;NO, UPDATE MAJOR AND CONTINUE\r\n\tSUB\tDX,WORD PTR MAXDEL\t;UPDATE SUM FOR NEXT POINT\r\n\tCALL\t WORD PTR MINUPD+1\t;ADVANCE MINOR AXIS\r\nLINLOP:\tCALL\t WORD PTR MAXUPD+1\t;UPDATE MAJOR AXIS\r\n\tLOOP\tLINLP3\t\t;CONTINUE UNTIL COUNT EXHAUSTED\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  VARPT2 - VARPTR$ Function\r\n\r\n\tPUBLIC\tVARPT2\r\n\tEXTRN\tPTRGTN:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tVALTYP:WORD,DSCPTR:WORD\r\nDSEG\tENDS\r\n\r\n;VARPTR$(x)\r\n; Called after VARPTR sees next char is \"$\"\r\n; Returns 3 byte string as follows:\r\n;  byte 0: type of x\r\n;  byte 1: low-adr of varptr(x)\r\n;  byte 2: high-adr of varptr(x)\r\n; Primary use is so BASCOM can handle DRAW \"X\"+VARPTR$(A$)\r\n;\r\nVARPT2:\r\n\tCALL\tCHRGTR\t\t;get byte after \"$\"\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"(\"\t;EAT LEFT PAREN\r\n\tCALL\tPTRGTN\t\t;GET ADDRESS OF VARIABLE\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\t;EAT RIGHT PAREN\r\n\tOR\tDX,DX\t\t;MAKE SURE NOT UNDEFINED VAR\r\n\tJNZ\tVARRT2\t\t;SET CC'S. ZERO IF UNDEF\r\n\tJMP\tFCERR\t\t;ALL OVER IF UNDEF (DONT WANT\r\n\t\t\t\t;USER POKING INTO ZERO IF HE'S\r\n\t\t\t\t;TOO LAZY TO CHECK\r\nVARRT2:\r\n\tPUSH\tBX\t\t;Save text pntr\r\n\tPUSH\tDX\t\t;Save Var addr\r\n\tMOV\tAL,BYTE PTR VALTYP\r\n\tPUSH\tAX\t\t;Save type\r\n\tMOV\tAL,LOW 3\r\n\tCALL\tSTRINI\t\t;Get a 3 byte string\r\n\tMOV\tBX,WORD PTR DSCPTR\t;Descriptor in [BX]\r\n\tPOP\tWORD PTR 0[BX]\t;Store Type in Byte 1\r\n\tINC\tBX\r\n\tPOP\tWORD PTR 0[BX]\t;Store addr in Bytes 2-3.\r\n\tJMP\tPUTNEW\t\t;Desc in FAC & ret. ([BX] on stack).\r\n\r\n\tPAGE\t\r\n\tSUBTTL  PLAY/SOUND statements\r\n\r\n;\r\n; PLAY - MUSIC MACRO LANGUAGE\r\n;\r\n\tPUBLIC\tPLAYS\r\n\tEXTRN\tDONOTE:NEAR\r\n\tEXTRN\tMACLNG:NEAR,MCLXEQ:NEAR,FETCHR:NEAR,DECFET:NEAR,VALSC2:NEAR\r\n\tEXTRN\tFETCHZ:NEAR\r\n\r\n;Low-Level routine required:\r\n; DONOTE(AL: voice (0=forground, 1=back), CX:frequency, DX:duration (1=18.7ms))\r\n; queues note for execution, saves all regs.\r\n;\r\nPLAYS:\tMOV\tDX,OFFSET PLYTAB\t;POINT TO PLAY COMMAND TABLE\r\n\tJMP\tMACLNG\r\n\r\nPLYTAB:\tDB\t\"A\"\t\t;THE NOTES A-G\r\n\tDW\tOFFSET PLYNOT\r\n\tDB\t\"B\"\r\n\tDW\tOFFSET PLYNOT\r\n\tDB\t\"C\"\r\n\tDW\tOFFSET PLYNOT\r\n\tDB\t\"D\"\r\n\tDW\tOFFSET PLYNOT\r\n\tDB\t\"E\"\r\n\tDW\tOFFSET PLYNOT\r\n\tDB\t\"F\"\r\n\tDW\tOFFSET PLYNOT\r\n\tDB\t\"G\"\r\n\tDW\tOFFSET PLYNOT\r\n\r\n\tDB\t\"M\"\t\t;Music Meta Command\r\n\tDW\tOFFSET PLYMET\r\n\r\n\tDB\tOFFSET \"N\"+128D\t;PLAY NUMERIC NOTE\r\n\tDW\tOFFSET PLYNUM\r\n\tDB\tOFFSET \"O\"+128D\t;OCTAVE\r\n\tDW\tOFFSET POCTAV\r\n\tDB\tOFFSET \"P\"+128D\t;PAUSE\r\n\tDW\tOFFSET PPAUSE\r\n\tDB\tOFFSET \"T\"+128D\t;TEMPO\r\n\tDW\tOFFSET PTEMPO\r\n\tDB\tOFFSET \"L\"+128D\t;LENGTH\r\n\tDW\tOFFSET PLYLEN\r\n\tDB\t\"X\"\t\t;EXECUTE STRING\r\n\tDW\tOFFSET MCLXEQ\r\n\tDB\t00\t\t;END OF TABLE\r\n\r\n; TABLE OF INDEXES INTO NOTTAB FOR EACH NOTE\r\n; VALUE OF 255 MEANS NOTE NOT ALLOWED.\r\n\r\nNOTXLT:\tDB\tOFFSET 9D*2\t;A- (G#)\r\n\tDB\tOFFSET 10D*2\t;A\r\n\tDB\tOFFSET 11D*2\t;A#\r\n\tDB\tOFFSET 12D*2\t;B\r\n\tDB\t255D\t\t;NO C- OR B#\r\n\tDB\tOFFSET 1D*2\t;C\r\n\tDB\tOFFSET 2D*2\t;C#\r\n\tDB\tOFFSET 3D*2\t;D\r\n\tDB\tOFFSET 4D*2\t;D#\r\n\tDB\tOFFSET 5D*2\t;E\r\n\tDB\t255D\t\t;NO E# OR F-\r\n\tDB\tOFFSET 6D*2\t;F\r\n\tDB\tOFFSET 7D*2\t;F#\r\n\tDB\tOFFSET 8D*2\t;G\r\n\tDB\tOFFSET 9D*2\t;G#\r\n\r\n; TABLE OF NOTE FREQUENCIES\r\n; THESE ARE THE FREQUENCIES IN HERTZ OF THE TOP OCTAVE (6)\r\n; DIVIDED DOWN BY POWERS OF TWO TO GET ALL OTHER OCTAVES\r\n;\r\nNOTTAB:\tDW\t4186D\t\t;C\r\n\tDW\t4435D\t\t;C#\r\n\tDW\t4699D\t\t;D\r\n\tDW\t4978D\t\t;D#\r\n\tDW\t5274D\t\t;E\r\n\tDW\t5588D\t\t;F\r\n\tDW\t5920D\t\t;F#\r\n\tDW\t6272D\t\t;G\r\n\tDW\t6645D\t\t;G#\r\n\tDW\t7040D\t\t;A\r\n\tDW\t7459D\t\t;A#\r\n\tDW\t7902D\t\t;B\r\n\r\nPLYLEN:\tJNB\tPLGOFC\t\t;ERROR IF NO ARG\r\n\tCMP\tDL,LOW 65D\t;ALLOW ONLY UP TO 64\r\n\tJNB\tPLGOFC\t\t;FC ERROR IF TOO BIG\r\n\tOR\tDL,DL\t\t;DON'T ALLOW ZERO\r\n\tJZ\tPLGOFC\t\t;FC ERROR IF ZERO\r\n\tMOV\tBYTE PTR NOTELN,DL\t;STORE NOTE LENGTH\r\n\tRET\t\r\n\r\nPTEMPO:\tCMP\tDL,LOW 32D\t;ALLOW ONLY 32 - 255\r\n\tJB\tPLGOFC\t\t;FC ERROR IF TOO SMALL\r\n\tMOV\tBYTE PTR BEATS,DL\t;Store Beats per minute\r\n\tRET\t\r\n\r\nNCFCER:\r\nPPAUSE:\tJNB\tPLGOFC\t\t;ERROR IF NO ARG\r\n\tXOR\tCX,CX\t\t;PASS FREQ OF 0\r\n\tCMP\tDL,LOW 65D\t;ALLOW ONLY 1-64\r\n\tJNB\tPLGOFC\t\t;FC ERROR IF TOO BIG\r\n\tOR\tDL,DL\t\t;SEE IF ZERO\r\n\tJZ\tPLYRET\t\t;RETURN IF SO - NO PAUSE\r\n\tJMP\tPPAUS2\t\t;[DX]=PAUSE LENGTH\r\n\r\nPOCTAV:\tJNB\tPLGOFC\t\t;ERROR IF NO ARG\r\n\tCMP\tDL,LOW 7\t;ALLOW ONLY OCTAVES 0..6\r\n\tJNB\tPLGOFC\t\t;FC ERROR IF TO BIG\r\n\tMOV\tBYTE PTR OCTAVE,DL\r\nPLYRET:\tRET\t\r\n\r\nPLYNUM:\tJNB\tPLGOFC\t\t;ERROR IF NO ARG\r\n\tMOV\tAL,DL\t\t;GET NOTE NUMBER INTO [AL]\r\n\tOR\tAL,AL\t\t;SEE IF ZERO (PAUSE)\r\n\tJZ\tPLYNO3\t\t;DO THE PAUSE\r\n\tCMP\tAL,LOW 85D\t;ALLOW ONLY 0..84\r\n\tJNB\tPLGOFC\t\t;FC ERROR IF TOO BIG\r\n\tCBW\t\t\t;CLEAR HI BYTE FOR DIVIDE\r\n\tDEC\tAX\t\t;MAP TO 0..83\r\n\tMOV\tDL,LOW 12D\t;DIVIDE BY 12\r\n\tDIV\tDL\r\n\tMOV\tDH,AL\t\t;OCTAVE TO [DH]\r\n\tMOV\tAL,AH\t\t;NOTE NUMBER IS REMAINDER\r\n\tINC\tAL\t\t;ADD ONE\r\n\tADD\tAL,AL\t\t;DOUBLE TO MAKE INDEX\r\n\tJMP\tSHORT PLYNU3\t;PLAY NOTE [AL], OCTAVE [DH]\r\n\r\nPLGOFC:\tJMP\tFCERR\t\t;GIVE FUNCTION CALL ERROR\r\n\r\nPLYNOT:\tSUB\tCL,LOW OFFSET \"A\"-1\t;MAP TO 1..7\r\n\tADD\tCL,CL\t\t;MAP TO 2..14 (THIS ASSUMES SHARP)\r\n\tCALL\tFETCHR\t\t;GET NEXT CHARACTER\r\n\tJZ\tPLYNO2\t\t;END OF STRING - NO SHARP OR FLAT\r\n\tCMP\tAL,LOW \"#\"\t;CHECK FOR POSSIBLE SHARP\r\n\tJZ\tPLYSHP\t\t;SHARP IT THEN\r\n\tCMP\tAL,LOW \"+\"\t;\"+\" ALSO MEANS SHARP\r\n\tJZ\tPLYSHP\r\n\tCMP\tAL,LOW \"-\"\t;\"-\" MEANS FLAT\r\n\tJZ\tPLYFLT\r\n\tCALL\tDECFET\t\t;PUT CHAR BACK IN STRING.\r\n\tJMP\tSHORT PLYNO2\t;TREAT AS UNMODIFIED NOTE.\r\nPLYFLT:\tDEC\tCL\t\t;DECREMENT TWICE TO FLAT IT\r\nPLYNO2:\tDEC\tCL\t\t;MAP BACK TO UNSHARPED\r\nPLYSHP:\tMOV\tAL,CL\t\t;INTO [AL] FOR XLAT\r\n\tMOV\tBX,OFFSET NOTXLT\t;POINT TO TRANSLATE TABLE\r\n?CSLAB:\t\t\t\t; Code segment dummy label\r\n\tXLAT\tBYTE PTR ?CSLAB\t;TRANSLATE INTO NOTE TABLE INDEX\r\n\tOR\tAL,AL\t\t;SEE IF LEGAL NOTE\r\n\tJS\tPLGOFC\t\t;NOTE'S OK IF NOT .GT. 127\r\n;\r\n; ENTER HERE WITH NOTE TO PLAY IN [AL]\r\n; NOTE 0 IS PAUSE, 2,4,6,8..10,12 ARE A-G AND FRIENDS.\r\n;\r\nPLYNO3:\r\n\tMOV\tDH,BYTE PTR OCTAVE\t;GET OCTAVE INTO [DH] FOR LATER MATH\r\nPLYNU3:\r\n\tPUSH\tAX\t\t;Save Note\r\n\tPUSH\tDX\t\t;Save Octave\r\n\tMOV\tAL,BYTE PTR NOTELN\r\n\tMOV\tBYTE PTR NOTE1L,AL\t;One note duration = Note length\r\n\tCALL\tFETCHR\r\n\tJZ\tPLYNU4\t\t;Brif end of string\r\n\tCALL\tVALSC2\t\t;See if possible number\r\n\tCMP\tDL,LOW 65D\t;If was .gt. 64\r\n\tJNB\tPLGOFC\t\t; then error\r\n\tOR\tDL,DL\t\t;Any Length?\r\n\tJZ\tPLYNU4\t\t;Brif not, just do note\r\n\tMOV\tBYTE PTR NOTE1L,DL\t;Store duration for this note\r\nPLYNU4:\r\n\tPOP\tDX\t\t;Get Octave\r\n\tPOP\tAX\t\t;Restore Note\r\n\tCBW\t\t\t;FILL [AH] WITH ZEROS\r\n\tMOV\tBX,AX\t\t;TRANSFER TO BX FOR INDEXING\r\n\tOR\tBX,BX\t\t;SEE IF PAUSE (NOTE # 0)\r\n\tJZ\tPLYNO4\t\t;IF PAUSE, PASS [BX]=0\r\n\tMOV\tBX,WORD PTR NOTTAB-2[BX]\t;FETCH FREQUENCY\r\n\tMOV\tCL,LOW 6\t;CALCULATE 6-OCTAVE\r\n\tSUB\tCL,DH\t\t;FOR # OF TIMES TO SHIFT FREQ.\r\n\tSHR\tBX,CL\t\t;DIVIDE BY 2^(6-OCTAVE)\r\n\tADC\tBX,0\t\t;ADD IN CARRY TO ROUND UP\r\nPLYNO4:\r\n\tMOV\tCX,BX\t\t;FREQUENCY INTO [CX] FOR DONOTE\r\n\tMOV\tDL,BYTE PTR NOTE1L\t;Get this note's length\r\nPPAUS2:\r\n\tMOV\tAL,BYTE PTR BEATS\t;GET BEATS PER UNIT TIME\r\n\tMUL\tDL\t\t;CALC NOTE LENGTH * BEATS\r\n\tPUSH\tCX\t\t;SAVE [CX] WHILE WE DIVIDE\r\n\tMOV\tCX,AX\t\t;CALC TIME CONST/(BEATS * NOTE LENGTH)\r\n\tMOV\tDX,1\t\t;[DX:AX]=96000 (4*60*400.0) and will\r\n\tMOV\tAX,73400O\t; cause DONOTE [DX]=1 to play 2.5 milliseconds\r\n\tDIV\tCX\t\t; (in other words [DX]=400 will play 1 second)\r\n\tPOP\tCX\t\t;RESTORE FREQUENCY\r\n\tOR\tAX,AX\t\t;IF DURATION IS ZERO, GET OUT.\r\n\tJZ\tPLYNO8\r\n\tPUSH\tCX\t\t;Save Freq\r\nPLYDOT:\r\n\tPUSH\tAX\t\t;Save duration\r\n\tCALL\tFETCHR\r\n\tJZ\tPLYDOX\t\t;Brif EOS\r\n\tCMP\tAL,LOW \".\"\t;Note duration extender?\r\n\tJNZ\tPLYDO2\t\t;Brif not\r\n\tPOP\tAX\t\t;Get duration\r\n\tMOV\tCX,3\r\n\tMUL\tCX\r\n\tSHR\tAX,1\t\t;Duration = Duration * 1.5\r\n\tSHR\tDX,1\t\t;Ovf/2\r\n\tOR\tDX,DX\t\t;Still too big?\r\n\tJZ\tPLYDOT\t\t;Itterate if not\r\n\tJMP\tFCERR\t\t; else complain..\r\nPLYDO2:\r\n\tCALL\tDECFET\t\t;Put char back\r\nPLYDOX:\r\n\tPOP\tAX\t\t;Duration\r\n\tPOP\tCX\t\t;Get freq\r\n\tOR\tCX,CX\r\n\tJZ\tPLYNO9\t\t;Brif Pause\r\n\tCMP\tBYTE PTR MSCALE,LOW 1\r\n\tJZ\tPLYNO9\t\t;Brif Legatto\r\n\tPUSH\tAX\t\t;Save Duration\r\n\tPUSH\tCX\t\t;Save Frequency\r\n\tMOV\tCL,BYTE PTR MSCALE\t;Using scale for shift count\r\n\tMOV\tBX,3\t\t;Stecatto multiplier\r\n\tCMP\tCL,LOW 2\r\n\tJZ\tPLYNO6\t\t;Brif Stecatto\r\n\tMOV\tBX,7\t\t; else Normal\r\nPLYNO6:\r\n\tMUL\tBX\t\t;Duration * 7/8 or 3/4\r\n\tSHR\tAX,CL\r\n\tOR\tAX,AX\r\n\tJNZ\tPLYNO7\t\t;If zero\r\n\tINC\tAX\t\t; then make 1\r\nPLYNO7:\r\n\tPOP\tCX\t\t;Get Freq\r\n\tCALL\tPLYNO9\t\t;Send note\r\n\tPOP\tAX\t\t;Original duration\r\n\tMOV\tCL,BYTE PTR MSCALE\r\n\tSHR\tAX,CL\t\t;pause after note is 1/8 or 1/4\r\n\tXOR\tCX,CX\t\t;Freq = 0 for pause\r\n\tOR\tAX,AX\t\t;Pause = 0?\r\n\tJNZ\tPLYNO9\t\t;Brif not\r\nPLYNO8:\r\n\tRET\t\t\t; else do nothing\r\nPLYNO9:\r\n\tMOV\tDX,AX\t\t;DONOTE wants [CX]=freq, [DX]=duration.\r\n\tJMP\tSHORT DOSND\t;Play freq [CX] for time [DX]\r\n\r\nPLYMER:\r\n\tJMP\tFCERR\r\n\r\n; PLYMET -      Process Music Meta Commands.\r\n\r\nPLYMET:\r\n\tCALL\tFETCHZ\t\t;Get Meta action or error\r\n\tMOV\tCL,LOW 1\t;Factor for Legatto (1/1): MSCALE=1\r\n\tCMP\tAL,LOW \"L\"\r\n\tJZ\tPLYDUR\t\t;Brif Legatto (Full note)\r\n\tINC\tCL\t\t;Factor for Stecatto (3/4): MSCALE=2\r\n\tCMP\tAL,LOW \"S\"\r\n\tJZ\tPLYDUR\t\t;Brif Stecatto (3/4)\r\n\tINC\tCL\t\t;Factor for Normal (7/8): MSCALE=3\r\n\tCMP\tAL,LOW \"N\"\r\n\tJZ\tPLYDUR\t\t;Brif Normal (7/8)\r\n\tXOR\tCL,CL\t\t;MMODE=0 for Forground\r\n\tCMP\tAL,LOW \"F\"\r\n\tJZ\tPLYMOD\t\t;Brif Foreground Music\r\n\tINC\tCL\t\t;MMODE=1 for Background\r\n\tCMP\tAL,LOW \"B\"\r\n\tJNZ\tPLYMER\t\t;Brif not Background Music\r\nPLYMOD:\r\n\tMOV\tBYTE PTR MMODE,CL\t;Store Music Mode (0=FG, 1=BG)\r\n\tRET\t\r\nPLYDUR:\r\n\tMOV\tBYTE PTR MSCALE,CL\t;Store Duration Scaling factor\r\n\tRET\t\r\n\r\n;SNDINI is called to set OCTAVE, BEATS, NOTELN, NOTE1L, MSCALE, and MMODE\r\n;to appropriate initial settings.  SNDINI is called at CLEARC and during\r\n;initialization.\r\n;Entry - none\r\n;Exit  - all registers preserved\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tNOTELN:WORD,NOTE1L:WORD,BEATS:WORD,OCTAVE:WORD,MSCALE:WORD\r\n\tEXTRN\tMMODE:WORD\r\nDSEG\tENDS\r\nPUBLIC\tSNDINI\r\nSNDINI:\tMOV\tBYTE PTR BEATS,LOW 120D\r\n\tMOV\tBYTE PTR MSCALE,LOW 3D\r\n\tMOV\tBYTE PTR MMODE,LOW 0D\r\n\tMOV\tBYTE PTR NOTELN,LOW 4D\r\n\tMOV\tBYTE PTR NOTE1L,LOW 4D\r\n\tMOV\tBYTE PTR OCTAVE,LOW 4D\r\n\tCALL\tSNDRST\t\t;Turn off sound\r\n\tRET\t\r\n\r\n;SNDRST is called to reset background music.  It is called during\r\n; initialization from INIT and during the processing of CTL-C\r\n; from POLKEY\r\n; Entry - none\r\n; Exit  - All registers preserved\r\n;\r\nPUBLIC\tSNDRST\r\nSNDRST:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tPUSHF\t\r\n\tMOV\tAL,LOW 255D\r\n\tCALL\tDONOTE\t\t;Disable background music, init music queue\r\n\tPOPF\t\r\n\tPOP\tDX\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n\tPUBLIC\tBEEPS,BEEP,SOUNDS\r\n\tEXTRN\tDONOTE:NEAR,FRQINT:NEAR,FRCSNG:NEAR,GETIN2:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFAC:WORD\r\nDSEG\tENDS\r\n\r\nBEEP:\r\nBEEPS:\tMOV\tCX,800D\t\t; 800 Hz\r\n\tMOV\tDX,100D\t\t; .. for 1/4 second.\r\n\tXOR\tAL,AL\t\t;[AL]=Music Mode (0=Forground)\r\n\tJMP\tSHORT JDNOTE\r\n\r\nDOSND:\tMOV\tAL,BYTE PTR MMODE\t;[AL]=Music Mode (0=Forground, 1=background)\r\nJDNOTE:\tCALL\tDONOTE\t\t;start new sound.\r\n\tJNB\tDNOTOK\t\t;No errors detected by DONOTE\r\n\tJMP\tFCERR\t\t;Function call error detected\r\nDNOTOK:\r\n\tJMP\tPOLKEY\t\t;Allow CTL-C to interrupt and return\r\n; SOUND  -      Make SOUNDs with the speaker.\r\n;\r\n;       Syntax: SOUND x,y\r\n;\r\n;       Where:  x is the Frequency in Hertz.\r\n;               y is the Duration in Clock ticks. (currently 18.2/sec).\r\n;\r\n;               Frequency must be at least 37 Hz.\r\n;               If Duration is 0, then just turn off current sound...\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\t$FACLO:WORD,$FACM1:WORD\r\nDSEG\tENDS\r\n\tEXTRN\t$FMULS:NEAR\r\nSOUNDS:\r\n\tCALL\tGETIN2\t\t;Get frequency.\r\n\tCMP\tDX,37D\r\n\tJB\tSNDFCE\t\t;Must be at least 37 Hz..\r\n\tPUSH\tDX\t\t;Save frequency\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \",\"\r\n\tCALL\tFRMEVL\t\t;Get duration.\r\n\tCALL\tEOSCHK\t\t;Syntax Error if not end-of-statement\r\n\tPUSH\tBX\t\t;Text pointer\r\n\tCALL\tFRCSNG\t\t;Make Single Precision\r\n\tMOV\tBX,OFFSET FAC\t;Point at Exponent\r\n\tCMP\tBYTE PTR 0[BX],LOW 0\t;Will turn sound off if 0.\r\n\tJNZ\tSOUNL4\t\t; Brif not, start new sound.\r\n\tPOP\tBX\t\t;Text pointer\r\n\tPOP\tDX\t\t;Frequency (not used)\r\n\tJMP\tSHORT SNDRST\t;Turn off sound, initialize the queue\r\n\r\nSOUNL4:\r\n\tCMP\tBYTE PTR 0[BX],LOW 221O\t;Duration .gt. 65535?\r\n\tJNB\tSNDFCE\t\t;Brif so, too big for *32\r\n\tPUSH\tBX\t\t;Save FAC address\r\n\tPUSH\tWORD PTR $FACM1\t;Push FAC on the stack\r\n\tPUSH\tWORD PTR $FACLO\r\n\tMOV\tBX,22D\t\t;Mult by ^D22\r\n\tCALL\tMAKINT\r\n\tCALL\tFRCSNG\t\t;Get s.p. ^D22\r\n\tPOP\tDX\t\t;Get low mantissa bits\r\n\tPOP\tBX\t\t;Exp sign and high mantissa bits\r\n\tCALL\t$FMULS\t\t;MULTIPLY\r\n\tPOP\tBX\t\t;FAC address\r\n\tCMP\tBYTE PTR 0[BX],LOW 221O\t;Overflow?\r\n\tJB\tSOUNL5\t\t;Brif not\r\n\tMOV\tWORD PTR -1[BX],110177O\t; else\r\n\tMOV\tWORD PTR -3[BX],177400O\t; force to 65535\r\nSOUNL5:\r\n\tCALL\tFRQINT\t\t;Convert back to Integer\r\n\tMOV\tDX,BX\t\t; in [DX]\r\n\tPOP\tBX\t\t;Text pointer\r\n\tPOP\tCX\t\t;[CX]=Frequency, [DX]=Duration\r\n\tJMP\tSHORT DOSND\t;play the note\r\nSNDFCE:\r\n\tJMP\tFCERR\t\t; Complain\r\n\r\n\r\n\tPAGE\t\r\n\tSUBTTL General Event Trapping Code\r\n\r\n\tPUBLIC\tONGOTP,SETGSB\r\n\tEXTRN\tSTPTRP:NEAR,ONTRP:NEAR,OFFTRP:NEAR,REQTRP:NEAR,FRETRP:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\t$ON:WORD,$OFF:WORD,$STOP:WORD\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tTRPTBL:WORD\r\nDSEG\tENDS\r\n\r\n;Event flags can have one or more of the following bits set:\r\n; They are defined in BIMISC.MAC\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tT_ON:WORD\t;1 event trapping on\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tT_STOP:WORD\t;2 event trapping stopped (remembers but doesn't report)\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tT_REQ:WORD\t;4 event trap requested (this event has happend)\r\nDSEG\tENDS\r\n\r\n;To support EVENT TRAPPING, The following switches should be defined\r\n; in the machine dependant Switch File:\r\n;\r\n;       NMKEYT = number of soft keys\r\n;       NMCOMT = number of COMmunications ports\r\n;       NMPENT = number of light pens (0 or 1)\r\n;       NMSTRT = number of joysticks\r\n;       NUMTRP = total of all of the above\r\n;       ONGOSB should be 1\r\n;\r\n\r\n;To support EVENT TRAPPING, The following variables should be defined\r\n; in the machine dependant RAM module:\r\n;\r\n;       ONGSBF: BLOCK   1       ;some-event happend flag (see NEWSTT)\r\n;       TRPTBL: BLOCK   3*NUMTRP\r\n;                               ;event flags and GOSUB line ptrs\r\n;\r\n\r\n\tPENOFF=0\t\t;offset for PEN event id's\r\n\tKEYOFF=PENOFF+NMPENT\t;offset for KEY event id's\r\n\tCOMOFF=KEYOFF+NMKEYT\t;offset for COM event id's\r\n\tSTROFF=COMOFF+NMCOMT\t;offset for STRIG event id's\r\n\r\n\tPUBLIC\tCHKINT\r\n\tEXTRN\tPOLKEY:NEAR,POLLEV:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tAUTFLG:WORD,SEMFLG:WORD,SAVTXT:WORD,SAVSTK:WORD,CURLIN:WORD\r\nDSEG\tENDS\r\n\r\n;CHKINT is called from BASIC's NEWSTT loop to see if any trappable\r\n; condition has occured.  It traps active function keys, COM input,\r\n; light pen interrupts, joystick triggers, CTL-C, CTL-S, and\r\n; it queues vanilla keys for CHSNS.  For efficiency, it calls POLLEV\r\n; which looks at flag which gets set by BIOS when some interrupt occurs.\r\n; This routine would not be necessary in a stand-alone environment since\r\n; BASIC would manage its own interrupts.\r\n;\r\nCHKINT:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tMSDCCF:WORD\t;MSDOS Ctl-C flag\r\nDSEG\tENDS\r\n\tTEST\tBYTE PTR MSDCCF,LOW 255D\t;Test for MSDOS-received Ctl-C\r\n\tJNZ\tCHKIN1\r\n\tCALL\tPOLLEV\t\t;Test for occurance of trapable events\r\n\tJZ\tCHKINX\t\t;Exit - no trapable event\r\nCHKIN1:\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tCALL\tPOLKEY\t\t;trap Function keys, CTL-C, CTL-S\r\n\tEXTRN\tPOLCOM:NEAR\r\n\tCALL\tPOLCOM\t\t;trap COM interrupts\r\nNOACOM:\r\n\tCALL\tPOLPEN\t\t;trap PEN interrupts\r\n\tCALL\tPOLSTR\t\t;trap STRIG interrupts\r\n\tPOP\tDX\r\n\tPOP\tCX\r\n\tPOP\tBX\r\nCHKINX:\tRET\t\r\n\r\n;SEVSTT - Set Event Status\r\n; Common code for parsing event-id ON/OFF/STOP\r\n; Entry - [CL]=number of legal events for device\r\n;         [CH]=event-id offset for device\r\n;\r\nSEVSTT:\tPUSH\tCX\t\t;save maximum and offset for class\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"(\"\r\n\tCALL\tGETBYT\t\t;[AL]=class-relative event-id\r\n\tPUSH\tAX\t\t;save it\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\r\n\tPUSH\tAX\t\t;save [AL]=$ON, $OFF, or $STOP\r\n\tCALL\tEOSCH1\t\t;skip past $ON, $OFF, or $STOP\r\n\t\t\t\t;error if not end of statement\r\n\tPOP\tDX\t\t;restore $ON, $OFF, or $STOP\r\n\tPOP\tAX\t\t;[AL]=class-relative event-id\r\n\tPOP\tCX\t\t;restore maximum, offset for class\r\n\tCMP\tCH,LOW OFFSET STROFF\t;Special check for STRIG(x)\r\n\tJNZ\tSEVST1\t\t;Brif not\r\n\tROR\tAL,1\t\t;Divide by 2 so get 0,1,2 or 3\r\n\tJMP\tSHORT SEVST2\r\nSEVST1:\r\n\tOR\tAL,AL\r\n\tJZ\tSEVALL\t\t;branch if parm was 0\r\n\tDEC\tAL\t\t;make parm 0-relative\r\nSEVST2:\r\n\tPUSH\tDX\t\t;save $ON, $OFF, or $STOP\r\n\tCMP\tAL,CL\t\t;compare with maximum\r\n\tJGE\tFCERR1\t\t;branch if not in range\r\n\tADD\tAL,CH\t\t;add in offset to get event id\r\n\tCALL\tEVADR\t\t;[DX]=adr of event flag\r\n\tPOP\tAX\t\t;[AL]=ON, OFF, or STOP\r\n\t\t\t\t;fall into SET1EV\r\n\r\n;SET1EV - Set One Event\r\n; Entry - [DX]=adr of event flag\r\n;         [AL]=$ON, $OFF, or $STOP\r\n;\r\nSET1EV:\tCALL\tEVSET\t\t;set event flags to ON, OFF, or STOP\r\n\tRET\t\r\n\r\nFCERR1:\tJMP\tFCERR\r\nSNERR1:\tJMP\tSNERR\r\n\r\n;Set status for all events of a class\r\n; Entry - [DL]=$ON, $OFF, or $STOP token\r\n;         [CH]=class event-id offset\r\n;         [CL]=number of events in class\r\n;\r\nSEVALL:\tPUSH\tDX\t\t;save $ON, $OFF, or $STOP\r\n\tMOV\tAL,CH\t\t;[AL]=class offset\r\n\tXOR\tCH,CH\t\t;[CX]=number of entries in class\r\n\tCALL\tEVADR\t\t;[DX] points to 1st event flag\r\n\tPOP\tAX\t\t;[AL]=ON, OFF, or STOP\r\nSEVAL1:\tCALL\tEVSET\t\t;set event for key 9-[B]\r\n\tADD\tDX,3\t\t;[DX] points to next entry\r\n\tLOOPNE\tSEVAL1\r\n\tRET\t\r\n\r\n;EVSET changes the status of 1 event.\r\n; Entry - [AL]=$ON, $OFF, or $STOP\r\n;         [DX] points to event flag\r\n; Exit -  All registers preserved.\r\n;\r\nEVSET:\tPUSH\tDX\t\t;save caller's registers\r\n\tPUSH\tCX\r\n\tPUSH\tBX\r\n\tPUSH\tAX\r\n\tMOV\tBX,DX\t\t;[BX]=adr of event flag\r\n\tCMP\tAL,LOW OFFSET $ON\r\n\tJZ\tEVON\r\n\tCMP\tAL,LOW OFFSET $OFF\r\n\tJZ\tEVOFF\r\n\tCMP\tAL,LOW OFFSET $STOP\r\n\tJNZ\tSNERR1\r\n\r\nEVSTP:\tCALL\tSTPTRP\t\t;stop event pointed to by [BX]\r\n\tJMP\tSHORT EVONX\r\nEVON:\tCALL\tONTRP\t\t;enable event pointed to by [BX]\r\n\tJMP\tSHORT EVONX\r\nEVOFF:\tCALL\tOFFTRP\t\t;disable event pointed to by [BX]\r\nEVONX:\tPOP\tAX\t\t;restore all caller's registers\r\n\tPOP\tBX\r\n\tPOP\tCX\r\n\tPOP\tDX\r\n\tRET\t\r\n\r\n;EVADR transforms event-id to event-flag-pointer.\r\n; Entry - [AL] = event id\r\n; Exit  - [DX]=adr of event flag, [AX] is used, all other regs preserved\r\n;\r\nEVADR:\tXOR\tAH,AH\t\t;[AX] = event id\r\n\tMOV\tDX,AX\r\n\tADD\tAX,AX\r\n\tADD\tAX,DX\t\t;[AX] = 3*event id\r\n\tADD\tAX,OFFSET TRPTBL\r\n\tMOV\tDX,AX\r\n\tRET\t\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\t$KEY2B:WORD,$PEN2B:WORD,$STR2B:WORD,$COM2B:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tDERDNA:NEAR\r\n\r\n;ONGOTP routine is called from ON GOTO code within BINTRP\r\n;       Do syntax checks for event traps and return.\r\n;       Carry set indicates it was not a trap gosub definition.\r\n;       else carry is clear\r\n;\r\n; Syntax:       ON [Event] GOSUB line no.\r\n;\r\n;       WHERE:  Event is one of following:\r\n;               COM(x)\r\n;               PEN\r\n;               STRIG(x) x = 0 for Trigger A, or 2 for Trigger B.\r\n;               KEY(x)   x = 1..NMKEYT-1\r\n;\r\n;       If one of the Event verbs does not follow the ON\r\n;       keyword, then go back to Level 1 \"ONGOTO\" to\r\n;       process ON ### GOSUB... or GOTO.\r\n;\r\nONGOTP:\tPUSH\tBX\t\t;Text pointer in case not us.\r\n\tXOR\tCH,CH\t\t;Assume one byte token\r\n\tCMP\tAL,LOW 375O\t;check for 2-byte token\r\n\tJB\tNT2BTK\t\t;branch if not FF, FE or FD\r\n\tMOV\tCH,AL\t\t;[CH] = 1st byte\r\n\tCALL\tCHRGTR\t\t;[AL] = 2nd byte of 2-byte token\r\n\tMOV\tAH,CH\t\t;[AH] = 1st byte\r\nNT2BTK:\r\n\tCMP\tAX,OFFSET $KEY2B\r\n\tMOV\tCX,OFFSET (400O*KEYOFF)+NMKEYT\r\n\tJZ\tONFUN\t\t;Brif ON KEY...\r\n\tCMP\tAX,OFFSET $COM2B\r\n\tMOV\tCX,OFFSET (400O*COMOFF)+NMCOMT\r\n\tJZ\tONFUN\t\t;Brif ON COM...\r\n\tCMP\tAX,OFFSET $PEN2B\r\n\tMOV\tCX,OFFSET 400O*PENOFF\r\n\tJNZ\tNTONPN\t\t;BRIF not ON PEN...\r\n\tCALL\tCHRGTR\t\t;get next token\r\n\tJMP\tSHORT ONSTM\t;Brif ON PEN...\r\nNTONPN:\r\n\tCMP\tAX,OFFSET $STR2B\r\n\tMOV\tCX,OFFSET (400O*STROFF)+NMSTRT\r\n\tJZ\tONFUN\r\n\tSTC\t\t\t;set carry - indicates not event\r\n\tPOP\tBX\t\t;Restore Entry Text pointer\r\n\tJMP\tSHORT ONGOTX\r\n\r\nFCERR2:\tJMP\tFCERR\r\n\r\nJERDNA:\tJMP\tDERDNA\t\t;Device unavailable error if PEN\r\n\r\nONFUN:\r\n\tCALL\tGETSUB\t\t;Get Event no. in (x).\r\n\tDEC\tAL\t\t;Want base 0. (If not STRIG(x))\r\n\tCMP\tCH,LOW OFFSET STROFF\t;Special check for STRIG(x)\r\n\tJNZ\tONFUN1\t\t;Brif not\r\n\tINC\tAL\t\t;Restore STRIG #\r\n\tROR\tAL,1\t\t;Divide by 2 so get 0,1,2 or 3\r\nONFUN1:\r\n\tCMP\tAL,CL\t\t;Value [AL] .gt. MAX [CL]?\r\n\tJNB\tFCERR2\t\t;If so, then Ill fun error.\r\n\tMOV\tCL,AL\t\t;Save Event index in [CL]\r\nONSTM:\r\n\tADD\tCH,CL\t\t;[CH]=event-id\r\n\tMOV\tCL,LOW 1\t;[CL]=maximum number of line#'s in gosub\r\n\tPOP\tDX\t\t;discard saved text pointer\r\n\tDEC\tBX\t\t;backup for CHRGET\r\n\tOR\tAL,AL\t\t;clear carry - indicates it was event\r\nONGOTX:\tMOV\tAL,BYTE PTR 0[BX]\t;Restore Token\r\n\tRET\t\r\n\r\nGETSUB:\tPUSH\tCX\r\n\tCALL\tCHRGTR\t\t;skip current token\r\nGETSU2:\tCALL\tSYNCHR\r\n\tDB\tOFFSET \"(\"\r\n\tCALL\tGETBYT\t\t;get event-class index\r\n\tPUSH\tAX\t\t;save it\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \")\"\r\n\tPOP\tAX\r\n\tPOP\tCX\r\n\tRET\t\r\n\r\n;Set gosub entry\r\n; Entry - [AL]=trap id, [DX]=line pointer\r\n; Exit  - [AX], [FLAGS] used, All other registers preserved.\r\n;\r\nSETGSB:\tPUSH\tSI\r\n\tPUSH\tDX\t\t;save gosub line pointer\r\n\tCALL\tEVADR\t\t;[DX] points to event flag\r\n\tMOV\tSI,DX\t\t;[SI] points to event flags\r\n\tPOP\tDX\t\t;restore GOSUB line pointer\r\n\tINC\tSI\t\t;[SI] points to gosub line ptr entry\r\n\tMOV\tWORD PTR 0[SI],DX\t;put trap adr in table for this entry\r\n\tPOP\tSI\r\n\tRET\t\r\n\r\n;EVTRP is called to signal that an event has occured.\r\n; Entry - [AL] = event id\r\n; Exit  - If NZ, the event is not being trapped (not ON)\r\n;         AX is used.  All other registers are preserved.\r\n;\r\nEVTRP:\tPUSH\tDX\r\n\tPUSH\tCX\r\n\tPUSH\tBX\r\n\tMOV\tBX,WORD PTR CURLIN\r\n\tINC\tBX\r\n\tJZ\tNOT_ON\t\t;branch if in direct mode (no event trapping)\r\n\tCALL\tEVADR\t\t;[DX] points to event flag\r\n\tMOV\tBX,DX\t\t;[BX] points to event flag\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;[AL]=event flag\r\n\tAND\tAL,LOW OFFSET T_ON\t;NZ if trapping enabled for key\r\n\tJZ\tNOT_ON\t\t;branch if event is not on\r\n\tPUSHF\t\r\n\tCALL\tREQTRP\t\t;Trap enabled, Issue Request\r\n\tPOPF\t\r\nNOT_ON:\tPOP\tBX\r\n\tPOP\tCX\r\n\tPOP\tDX\r\n\tRET\t\r\n\r\n;EVCLR is called to reset an event\r\n; Entry - [AL] = event id\r\n; Exit  - Flags, AX are used.  All other registers are preserved.\r\n;\r\nEVCLR:\tPUSH\tDX\r\n\tPUSH\tCX\r\n\tPUSH\tBX\r\n\tCALL\tEVADR\t\t;[DX] points to event flag\r\n\tMOV\tBX,DX\t\t;[BX] points to event flag\r\n\tCALL\tFRETRP\t\t;Reset Trap Request\r\n\tJMP\tSHORT NOT_ON\r\n\r\n;TSTCEV is called to Test-and-Clear an event.\r\n; Entry - [AL] = 0-relative event index\r\n; Exit  - [BX] = -1 if event had occured\r\n;              =  0 if event had not occured\r\n;         bit T.REQ of TRPTBL+3*index is cleared\r\n;\r\nTSTCEV:\r\n\tCALL\tEVADR\t\t;[DX] [points to event flag\r\n\tMOV\tBX,DX\t\t;[BX] points to event flag\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;[AL] = current event state\r\n\tPUSH\tAX\r\n\tCALL\tFRETRP\t\t;Reset Trap Request (clear T.REQ)\r\n\tPOP\tAX\r\n\tXOR\tBX,BX\t\t;prepare to return negative result\r\n\tAND\tAL,LOW OFFSET T_REQ\r\n\tJE\tTSTEVX\r\n\tDEC\tBX\t\t;[BX]=-1 (indicates event has occured)\r\nTSTEVX:\tRET\t\r\n\r\n\tPAGE\t\r\n\tSUBTTL COM Statement and Event Trapping\r\n\r\n\tPUBLIC\tCOMS\r\n\tPUBLIC\tCOMTRP\r\n\r\n;COM statement\r\n;\r\nCOMS:\tMOV\tCX,OFFSET (400O*COMOFF)+NMCOMT\r\n\tJMP\tSEVSTT\t\t;branch to common code\r\n\r\n;COMTRP is called by COM interrupt service routine to signal trapping.\r\n; Entry - [AL]=0-relative com channel id.\r\n; Exit  - NZ is true if key trapping is enabled.\r\n;         All other regs preserved.\r\n;\r\nCOMTRP:\tPUSH\tAX\r\n\tADD\tAL,LOW OFFSET COMOFF\t;[AL]=event id\r\n\tCALL\tEVTRP\t\t;Signal the occurance of a COM EVENT\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n\tPAGE\t\r\n\tSUBTTL SOFT KEY Statement and Event Trapping\r\n\r\n\tPUBLIC\tKEYS\r\n\tEXTRN\tLINPRT:NEAR,OUTDO:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\t$ON:WORD,$OFF:WORD,$LIST:WORD\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tSTRTAB:WORD,KEYSW:WORD,FKCNUM:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tSCROUT:NEAR,CLREOL:NEAR\r\n\tPUBLIC\tKEYTRP\r\n\tEXTRN\tMAKINT:NEAR\r\n\r\n;SET KEY STATUS - KEY(n) (status)\r\n;\r\nKEYSTT:\tMOV\tCX,OFFSET (400O*KEYOFF)+NMKEYT\r\n\tJMP\tSEVSTT\t\t;branch to common code\r\n\r\n\r\n\r\n;KEYTRP is called whenever CHGET receives a SOFTKEY from the keyboard.\r\n; Entry - [AL] = Soft key id (0..NMKEYT-1)\r\n; Exit  - If NZ, key was trapped and should not be expanded.\r\n;         Otherwise, CHGET should expand key.\r\n;         All other registers are preserved.\r\n;\r\nKEYTRP:\tPUSH\tAX\r\n\tADD\tAL,LOW OFFSET KEYOFF\t;[AL] = 0-relative event id\r\n\tCALL\tEVTRP\t\t;Signal the occurance of a KEY EVENT\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n\tEXTRN\tFKYADV:NEAR\r\n\r\n;KEY Statement\r\n;\r\nKEYS:\r\n\tCMP\tAL,LOW \"(\"\r\n\tJZ\tKEYSTT\t\t;set key status\r\n\tCMP\tAL,LOW OFFSET $ON\r\n\tJZ\tKEYON\t\t;Brif Enable Soft Key Display Line.\r\n\tCMP\tAL,LOW OFFSET $OFF\r\n\tJZ\tKEYOF\t\t;Brif Disable Soft Key Display line.\r\n\tCMP\tAL,LOW OFFSET $LIST\r\n\tJZ\tKEYLSI\t\t;Brif LIST Soft Keys.\r\n\tCALL\tGETBYT\t\t; else Key defn, get key number.\r\n\tOR\tAL,AL\r\n\tJZ\tKEYFCE\r\n\tSUB\tAL,LOW OFFSET STKEYF\t;Get zero relative key number\r\n\tCMP\tAL,LOW OFFSET NMKEYF\r\n\tJNB\tKEYFCE\t\t;Must be STKEYF - NMKEYF+STKEYF, else error.\r\n\tMOV\tDX,16D\r\n\tMUL\tDL\t\t; (16 * Key number).\r\n\tMOV\tDX,AX\r\n\tADD\tDX,OFFSET STRTAB\t;Index into Soft Key table\r\n\tPUSH\tDX\t\t;Save addr\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET \",\"\r\n\tCALL\tFRMEVL\r\n\tPUSH\tBX\t\t;Save Text pntr.\r\n\tCALL\tFRESTR\t\t;Get String Descriptor\r\n\tMOV\tCL,BYTE PTR 0[BX]\r\n\tCMP\tCL,LOW 15D\r\n\tJB\tKEY1\r\n\tMOV\tCL,LOW 15D\t;String may be 0 to 15 chars.\r\nKEY1:\r\n\tINC\tBX\r\n\tMOV\tSI,WORD PTR 0[BX]\t;Get addr of string\r\n\tPOP\tBX\t\t;Text pntr\r\n\tPOP\tDI\t\t;STRTAB addr\r\n\tPUSH\tBX\r\n\tMOV\tCH,LOW 0\r\n\tCLD\t\r\n                     ;Move new softkey\r\n REP\tMOVSB\t\t\t;to Softkey table\r\n\tMOV\tBYTE PTR 0[DI],CH\t;Terminate entry with 0.\r\n\tMOV\tAL,BYTE PTR KEYSW\t;Are the key definitions being\r\n\tOR\tAL,AL\t\t;displayed?\r\n\tJZ\tNODSPK\t\t;No, don't call DSPKEY since it would\r\n\t\t\t\t;erase the bottom line of the screen.\r\n\tCALL\tKEYDSP\t\t;Yes, update the display.\r\nNODSPK:\tPOP\tBX\t\t;Text pntr\r\n\tRET\t\r\nKEYFCE:\r\n\tJMP\tFCERR\t\t;complain..\r\nKEYLSI:\tJMP\tSHORT KEYLST\r\n\r\nKEYON:\tCALL\tSKEYON\r\n\tJMP\tSHORT KEYOXX\t;non-zero = ON\r\n\r\nKEYOF:\tMOV\tAH,LOW 1D\t;Prepare to inc scroll limit\r\n\tMOV\tAL,LOW 0\t;zero = OFF\r\n\tCALL\tKEYOX\r\nKEYOXX:\tCALL\tCHRGTR\t\t;over ON/OFF token.\r\n\tRET\t\r\n\r\nPUBLIC\tSKEYON\r\nSKEYON:\tMOV\tAH,LOW -1D\t;Prepare to dec scroll limit\r\n\tMOV\tAL,LOW 377O\r\nKEYOX:\t\t\t\t;AH=scroll limit diff., AL=new KEYSW\r\n\tCMP\tAL,BYTE PTR KEYSW\t;State change?\r\n\tMOV\tBYTE PTR KEYSW,AL\r\n\tJZ\tKEYXX\t\t;Brif same, do nothing\r\n\tCMP\tBYTE PTR KEYSW,LOW 255D\t;Test if change to ON\r\n\tJNZ\tKEYOX1\t\t;Change is to OFF - do not call FKYADV\r\n\tCALL\tFKYADV\r\nKEYOX1:\r\n\tCALL\tKEYDSP\t\t;On, Display on 25th line.\r\nKEYXX:\tRET\t\r\n\r\n;List Function Keys\r\n;\r\nKEYLST:\r\n\tPUSH\tBX\r\n\tMOV\tSI,OFFSET STRTAB\t;List 10 Special Function\r\n\tMOV\tCX,OFFSET NMKEYF+(STKEYF*400O)\r\nKEYLS0:\r\n\tPUSH\tSI\r\n\tMOV\tAL,LOW \"F\"\r\n\tCALL\tOUTDO\r\n\tPUSH\tCX\r\n\tMOV\tBL,CH\r\n\tMOV\tBH,LOW 0\r\n\tCALL\tLINPRT\t\t;Display the Key number.\r\n\tMOV\tAL,LOW \" \"\r\n\tCALL\tOUTDO\r\n\tPOP\tCX\r\n\tPOP\tSI\r\n\tPUSH\tSI\r\n\tPUSH\tCX\r\nKEYLS1:\r\n\tCLD\t\r\n\tLODSB\r\n\tOR\tAL,AL\r\n\tJZ\tKEYLS2\t\t;Brif end of String.\r\n\tCALL\tKEYLSP\r\n\tJMP\tSHORT KEYLS1\r\nKEYLS2:\r\n\tMOV\tAL,LOW 13D\t;Output carriage return\r\n\tCALL\tOUTDO\r\n\tMOV\tAL,LOW 10D\t;Output a line feed\r\n\tCALL\tOUTDO\r\n\tPOP\tCX\r\n\tPOP\tSI\r\n\tADD\tSI,16D\t\t;Next key address\r\n\tINC\tCH\t\t;Next key number\r\n\tDEC\tCL\r\n\tJNZ\tKEYLS0\r\n\tPOP\tBX\r\n\tJMP\tKEYOXX\r\n\r\nKEYLSP:\r\n\tPUSH\tSI\r\n\tCMP\tAL,LOW 13D\t;check for Carriage-Return\r\n\tJNZ\tKEYLSQ\r\n\tMOV\tAL,LOW 33O\r\nKEYLSQ:\tCALL\tOUTDO\r\n\tPOP\tSI\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  KEYON,  KEYOFF, and KEYDSP\r\n\r\n\tPUBLIC\tKEYDSP,TKEYOF\r\n\tEXTRN\tFKYFMT:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFKCNUM:WORD\r\nDSEG\tENDS\r\n\r\n;TKEYOF is called to turn function key display off\r\n;\r\nTKEYOF:\tMOV\tBYTE PTR KEYSW,LOW 0\t;turn function key display switch off\r\n\r\n; KEYDSP -      Display Softkeys on last line of Screen.\r\n\r\n\tREVNMS=1\t\t;Key Numbers are normal video, contents are rev-video\r\nKEYDSP:\tPUSH\tDX\r\n\tMOV\tDH,LOW 1D\t;Set for col = 1\r\n\tMOV\tDL,BYTE PTR LINCNT\t;Set for last line\r\n\tMOV\tAL,BYTE PTR KEYSW\r\n\tOR\tAL,AL\t\t;Key on or off?\r\n\tJNZ\tKEYDS0\t\t;Softkey display switch on\r\n\tCALL\tCLREOL\t\t;Clear from (DH,DL) to EOL\r\n\tPOP\tDX\r\n\tRET\t\r\n\r\n\r\nKEYDS0:\r\n\tEXTRN\tSETCSR:NEAR\r\n\tMOV\tBYTE PTR CSRTYP,LOW 0D\t;Set off mode cursor\r\n\tCALL\tSETCSR\t\t;Turn the cursor off\r\n\tPUSH\tBX\r\nKEYDS1:\tCALL\tGETFMT\t\t;Get function key display format\r\nKNXTST:\tPUSH\tAX\t\t;Save Key disp no.\r\n\tCMP\tAH,LOW \"0\"\t;Single digit case?\r\n\tJZ\tSINDIG\t\t;Print only one digit\r\n\tXCHG\tAH,AL\r\n\tCALL\tKEYDCH\t\t;Display first digit\r\n\tXCHG\tAH,AL\r\nSINDIG:\tCALL\tKEYDCH\t\t;Display last digit\r\n\tPUSH\tSI\r\n\tMOV\tCL,BYTE PTR FKCNUM\t;Count of chars per fun. key (set by GETFMT\r\n\tCALL\tXFGBG\t\t;Swap Forground & background colors\r\nKNXTCH:\t\t\t\t;Write the next key character\r\n\tPUSH\tCX\r\n\tCLD\t\r\n\tLODSB\r\n\tOR\tAL,AL\t\t;End of string?\r\n\tPUSHF\t\r\n\tPUSH\tSI\r\n\tJNZ\tKEYDS4\t\t;No, Display char\r\n\tXOR\tAL,AL\t\t;else blank\r\nKEYDS4:\r\n\tCALL\tKEYDCH\t\t;Display char, adv cursor\r\n\tPOP\tSI\r\n\tPOPF\t\r\n\tJNZ\tKEYDS5\t\t;Brif not EOS\r\n\tDEC\tSI\r\nKEYDS5:\r\n\tPOP\tCX\r\n\tDEC\tCL\r\n\tJNZ\tKNXTCH\t\t;Loop for next character\r\n\tCALL\tXFGBG\t\t;Swap Forground & background colors\r\n\tCALL\tKEYDB\t\t;Follow with blank\r\n\tPOP\tSI\r\n\tPOP\tAX\r\n\tCALL\tKEYADV\t\t;Advance to next key\r\n\tDEC\tCH\r\n\tJNZ\tKNXTST\t\t;Loop for next key string\r\nKEYDSX:\tPOP\tBX\t\t;Retrieve cursor position\r\n\tPOP\tDX\r\n\tMOV\tBYTE PTR CSRTYP,LOW 3D\t;Set user mode cursor\r\n\tCALL\tSETCSR\t\t;Turn on cursor\r\n\tRET\t\r\n\r\nKEYDB:\tXOR\tAL,AL\t\t;For Blank at end of Key field\r\nKEYDCH:\r\n\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tOR\tAL,AL\t\t;Separating keys?\r\n\tJNZ\tKEYDC1\t\t;Brif not.\r\n\tMOV\tAL,LOW \" \"\t;else write space\r\nKEYDC1:\tCMP\tAL,LOW OFFSET CR\t;CR?\r\n\tJNZ\tKEYNCR\t\t;Not CR.\r\n\tMOV\tAL,LOW OFFSET FKEYCR\t;Subs Greater-Than-Sign\r\nKEYNCR:\tCMP\tAL,LOW OFFSET LF\t;Line feed?\r\n\tJNZ\tKEYNLF\t\t;Not line feed\r\n\tMOV\tAL,LOW 74O\t;Substitute Greater-Than-Sign\r\nKEYNLF:\tPUSH\tCX\r\n\tMOV\tAH,LOW 0\r\n\tCALL\tSCROUT\t\t;Write the character at (DH,DL)\r\n\tINC\tDH\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tPOP\tAX\t\t;Restore key number\r\n\tRET\t\r\n\tPAGE\t\r\n;Get function key display format\r\n;\r\nGETFMT:\tPUSH\tBX\r\n\tCALL\tFKYFMT\t\t;OEM routine\r\n\tMOV\tCX,WORD PTR 0[BX]\t;CH=key count, CL=Chrs/key\r\n\tPUSH\tCX\r\n\tMOV\tBYTE PTR FKCNUM,CL\r\n\tMOV\tSI,OFFSET STRTAB\t;SI=address of first fkey in table\r\n\tMOV\tAL,BYTE PTR 2[BX]\r\n\tCBW\t\r\n\tPUSH\tAX\t\t;Save number of first function key\r\n\tDEC\tAL\t\t;Set to zero relative\r\n\tMOV\tCL,LOW 4D\t;Multiply by 16 (bytes/key)\r\n\tSHL\tAX,CL\t\t;AX = index of first display key\r\n\tADD\tSI,AX\r\n\tPOP\tAX\r\n\tCALL\tINTOCH\t\t;Get key number to character code\r\n\tCMP\tAH,LOW \"0\"\r\n\tJZ\tONEDIG\t\t;Only one digit\r\n\tDEC\tBYTE PTR FKCNUM\t;Adjust function key format for two digits\r\nONEDIG:\tCALL\tKADNRM\t\t;Normalize key address\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tRET\t\r\n;INTOCH: Translate integer AL to characters in AX.\r\n;        Integers must be in the range (100,0].\r\n;        Radix is 10.\r\n;USES -  none\r\n;\r\nINTOCH:\tPUSH\tCX\r\n\tXOR\tAH,AH\r\n\tMOV\tCL,LOW 10D\t;Load radix\r\n\tDIV\tCL\r\n\tADD\tAX,30060O\t;3030H forms character codes\r\n\tXCHG\tAH,AL\t\t;AH represents significant digit\r\n\tPOP\tCX\r\n\tRET\t\r\n;KEYADV - Advance to next key\r\n;Entry - AX = key number characters\r\n;        SI = index into STRTAB (key code table)\r\n;\r\nKEYADV:\tADD\tSI,16D\t\t;Move to next key table entry\r\n\tINC\tAL\r\n\tCMP\tAL,LOW \"9\"\r\n\tJLE\tKADNRM\r\n\tMOV\tAL,LOW \"0\"\r\nKADNRM:\r\n\tCMP\tSI,OFFSET STRTAB+NMKEYF*16D\r\n\tJB\tKADNMX\r\n\tMOV\tSI,OFFSET STRTAB\t;Wrap around to the first function key\r\n\t\t\t\t;Print function key 10 number as 0\r\n\t\t\t\t; except when it is the first key\r\n\tCMP\tAH,LOW \"1\"\t;Only true if 1st function key is key 10\r\n\tJNZ\tKADNMX\t\t; all other wraps are for 1 digit only\r\n\tMOV\tAH,LOW \"0\"\r\n\tMOV\tAL,LOW \"1\"\r\n\tINC\tBYTE PTR FKCNUM\t;Re-adjust format\r\nKADNMX:\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  Swap Forground & Background Colors\r\n\r\n;Swap Forground & Background Colors (Toggle Reverse Video Mode)\r\n;\r\n\tEXTRN\tGETFBC:NEAR,SETFBC:NEAR\t;Get and set forground/background attributes\r\n\r\nXFGBG:\tCLC\t\t\t;Signal text attributes\r\n\tCALL\tGETFBC\t\t;Get forground/background attributes\r\n\tXCHG\tAX,BX\r\n\tCALL\tSETFBC\t\t;Set forground/background attributes\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL PEN Statement and Event Trapping\r\n\r\n\tPUBLIC\tPENS,PENF\r\n\tEXTRN\tMAKINT:NEAR\r\n\r\n; Dispatch PEN statement depending upon following clauses:\r\n;\r\n; PEN   ON      Enable  PEN Trapping.\r\n; PEN   OFF     Disable PEN Trapping.\r\n; PEN   STOP    Suspend PEN Trapping.\r\n;\r\n;               Attempts to read Light pen when off\r\n;               result in \"Illegal Function Call\" Error.\r\n;\r\nPENS:\r\n\tJZ\tSNERR2\t\t;Syntax error if end-of-statement\r\n\tPUSH\tAX\t\t;save $ON/$OFF/$STOP\r\n\tCALL\tEOSCH1\t\t;Syntax Error if not End-Of-Statement\r\n\tMOV\tDX,OFFSET TRPTBL+(3*PENOFF)\t;[DX]=adr of event flag\r\n\tPOP\tAX\t\t;[AL]=$ON, $OFF, or $STOP\r\n\tCMP\tAL,LOW OFFSET $STOP\r\n\tJE\tNTONOF\t\t;branch if not ON/OFF\r\n\tPUSH\tAX\r\n\tSUB\tAL,LOW OFFSET $ON\r\n\tJE\tPENS1\t\t;branch if \"PEN ON\"\r\n\tMOV\tAL,LOW 1\t;better be OFF\r\nPENS1:\tSUB\tAL,LOW 2\t;Map (ON, OFF) to (254, 255)\r\n\tPUSH\tBX\t\t;preserve text pointer (destroyed by RDPEN)\r\n\tCALL\tRDPEN\t\t;enable/disable light pen interrupts\r\n\tPOP\tBX\r\n\tPOP\tAX\t\t;restore [AL] = $ON/$OFF\r\nNTONOF:\r\n\tJMP\tSET1EV\t\t;Set Event Flag\r\n\r\nSNERR2:\tJMP\tSNERR\r\nFCERR3:\tJMP\tFCERR\r\n\r\n;PEN Function:\r\n; Syntax: x=PEN(n)\r\n;         n=0: Return -1 if pen was down since last poll, else 0.\r\n;         n=1: Return X Graphics Coordinate where pen was last activated.\r\n;         n=2: Return Y Graphics Coordinate where pen was last activated.\r\n;         n=3: Return -1 if pen is currently down, 0 if currently up.\r\n;         n=4: Return last known valid X Graphics Coordinate.\r\n;         n=5: Return last known valid Y Graphics Coordinate.\r\n;         n=6: Return character row where pen was last activated.\r\n;         n=7: Return character column where pen was last activated.\r\n;         n=8: Return last known character row.\r\n;         n=9: Return last known character column.\r\n;\r\n\tEXTRN\tRDPEN:NEAR\r\nPENF:\r\n\tCALL\tONESUB\t\t;[AL] = pen function\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tCMP\tAL,LOW 10\r\n\tJB\tPENOK\r\n\tJMP\tFCERR3\t\t;Error if Parm exceeds 9\r\nPENOK:\r\n\tOR\tAL,AL\r\n\tJNE\tNPEN0\t\t;branch if not PEN(0)\r\n\r\n;Whenever a PEN interrupt occurs, it is detected by POLPEN (called by CHKINT).\r\n; PEN(0) tells whether a PEN event has occured since the last PEN(0).\r\n; It determines this by testing-and-clearing the bit set by POLPEN.\r\n; NOTE: PEN(0) always returns false when event trapping has been enabled\r\n;       (by PEN ON statement)\r\n;\r\n\tMOV\tAL,LOW OFFSET PENOFF\r\n\tCALL\tTSTCEV\t\t;test and clear event [AL]\r\n\tJMP\tSHORT PENRET\t;return -1 in BX if event has occured\r\nNPEN0:\r\n\tCALL\tRDPEN\r\nPENRET:\tCALL\tMAKINT\t\t;Return [BX] as signed integer\r\n\tPOP\tBX\t\t;restore text pointer\r\n\tRET\t\r\n\r\n;POLPEN is called by CHKINT at beginning of every BASIC statement (NEWSTT).\r\n; If a PEN interrupt has occured, it sets the appropriate bit in TRPTBL\r\n; which will cause the BASIC program's pen service routine (ON PEN GOSUB)\r\n; to be invoked.\r\n; Exit - AX, BX, CX, DX can be used (restored by CHKINT).\r\n;        All other registers are preserved.\r\n;\r\nPOLPEN:\r\n\tXOR\tAL,AL\t\t;See if lightpen has interrupted\r\n\tCALL\tRDPEN\r\n\tOR\tBX,BX\r\n\tJE\tNOPENI\t\t;branch if no lightpen interrupt\r\n\tMOV\tAL,LOW OFFSET PENOFF\r\n\tCALL\tEVTRP\t\t;Signal the occurance of a PEN EVENT\r\nNOPENI:\tRET\t\r\n;Parse \"(n)\" and return n in [AL]\r\nONESUB:\r\n;In non-IBMTOK versions, EVAL doesn't parse the argument\r\n\tEXTRN\tINTFR2:NEAR\r\n\tPUSH\tDX\r\n\tCALL\tINTFR2\t\t;[DX] = function to be performed (argument)\r\n\tJNE\tFCERRI\t\t;branch if [DX] is not [0..255]\r\n\tMOV\tAL,DL\t\t;return argument in [AL]\r\n\tPOP\tDX\t\t;restore caller's [DX]\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL STRIG Statement and Event Trapping\r\n\r\n\tPUBLIC\tSTRIGS,STRIGF,STICKF\r\n\tEXTRN\tRDSTIK:NEAR,RDTRIG:NEAR\r\n\r\n;STRIG statement\r\n;\r\n; Syntax:\r\n;\r\n;   In IBM BASIC, STRIG ON enables trigger trapping while STRIG OFF\r\n;     disables trigger event trapping.\r\n;   It is parsed in GW-BASIC for syntax compatibility only.\r\n;\r\n;   STRIG(n)      ON      Enable  STRIG(n) Trapping.\r\n;   STRIG(n)      OFF     Disable STRIG(n) Trapping.\r\n;   STRIG(n)      STOP    Suspend STRIG(n) Trapping.\r\n;\r\n;       WHERE:\r\n;               (n) is Trigger 0 for joystick trigger #1,\r\n;                              2 for joystick trigger #2,\r\n;                              4 for joystick trigger #3, etc.\r\n;\r\nSTRIGS:\r\n\tCMP\tAL,LOW \"(\"\r\n\tJNE\tSTRIG1\t\t;branch if STRIG ON or STRIG OFF\r\n\tMOV\tCX,OFFSET (400O*STROFF)+NMSTRT\r\n\tJMP\tSEVSTT\t\t;branch to common code\r\nSTRIG1:\r\n\tCMP\tAL,LOW OFFSET $ON\r\n\tJE\tSTROK\r\n\tCMP\tAL,LOW OFFSET $OFF\r\n\tJE\tSTROK\r\n\tJMP\tSNERR\t\t;SYNTAX ERROR if not $ON or $OFF or (n)\r\nSTROK:\tJMP\tEOSCH1\t\t;SYNTAX ERROR if not end-of-statement\r\n\r\n;STRIG Function:\r\n;\r\n; Syntax:\r\n;\r\n;  x=STRIG(n)\r\n;    n=0: return -1 if button 1 was pressed since last STRIG(0), else 0.\r\n;    n=1: return -1 if button 1 is currently pressed, else 0.\r\n;    n=2: return -1 if button 2 was pressed since last STRIG(0), else 0.\r\n;    n=3: return -1 if button 2 is currently pressed, else 0.\r\n;         etc.\r\n;\r\nSTRIGF:\r\n\tCALL\tONESUB\t\t;Parse \"(n)\", [AL] = n\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tMOV\tAH,AL\t\t;Map AL to AH: (0,1,2,...) to (1,0,1,...)\r\n\tINC\tAH\r\n\tAND\tAH,LOW 1\t;[AH] = 1 for latched, 0 for current\r\n\tSHR\tAL,1\t\t;[AL] = 0 relative joystick trigger id\r\n\tCMP\tAL,LOW OFFSET NMSTRT\r\n\tJB\tSTRGOK\r\nFCERRI:\tJMP\tFCERR\t\t;branch if illegal trigger id\r\nSTRGOK:\r\n\tOR\tAH,AH\r\n\tJE\tNSTR0\t\t;brif current (not latched) was requested\r\n\tPUSH\tAX\r\n\tADD\tAL,LOW OFFSET STROFF\t;see if STRIG(n) ON has been executed\r\n\tCALL\tEVADR\t\t;if not, POLSTR will not call RDTRIG for\r\n\tMOV\tBX,DX\t\t; this trigger, so we must call it directly\r\n\tTEST\tBYTE PTR 0[BX],LOW OFFSET T_ON\r\n\tPOP\tAX\r\n\tJE\tNSTR0\t\t;branch if event is not enabled\r\n\r\n;Whenever a STRIG interrupt occurs, it is detected by POLSTR (called by CHKINT).\r\n; STRIG(0) tells whether a STRIG event has occured since the last STRIG(0).\r\n; It determines this by testing-and-clearing the bit set by POLSTR.\r\n; NOTE: STRIG(0) always returns false when event trapping has been enabled\r\n;       (by STRIG(n) ON statement)\r\n;\r\n\tADD\tAL,LOW OFFSET STROFF\t;[AL]=0 relative event index\r\n\tCALL\tTSTCEV\t\t;test and clear event [AL]\r\n\tJMP\tSHORT STRRET\t;return -1 in BX if event has occured\r\nNSTR0:\tCALL\tRDTRIG\t\t;[AL] = 0/1 for not-pressed/pressed\r\n\tCBW\t\t\t;[AX] = 0/1 for not-pressed/pressed\r\n\tNEG\tAX\t\t;[AX] = 0/-1 for not-pressed/pressed\r\n\tMOV\tBX,AX\r\nSTRRET:\tCALL\tMAKINT\t\t;return [BX] as signed integer\r\n\tPOP\tBX\t\t;restore text pointer\r\n\tRET\t\r\n\r\n;STICK Function:\r\n;\r\n; Syntax:\r\n;\r\n;  x=STICK(n)\r\n;    n=0:    return x coordinate for joystick 1.\r\n;    n=1:    return y coordinate for joystick 1.\r\n;    n=2:    return x coordinate for joystick 2.\r\n;    n=3:    return y coordinate for joystick 2.\r\n;            etc.\r\n;\r\nSTICKF:\r\n\tCALL\tONESUB\t\t;AL=stick id\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tCALL\tRDSTIK\t\t;[BX] = stick coordinate\r\n\tJAE\tSTKOK\r\n\tJMP\tFCERR\t\t;branch if bad parameter\r\nSTKOK:\r\n\tCALL\tMAKINT\t\t;return [BX] as signed integer\r\n\tPOP\tBX\t\t;restore text pointer\r\n\tRET\t\r\n\r\n;POLSTR is called by CHKINT at beginning of every BASIC statement (NEWSTT).\r\n; If a STRIG interrupt has occured, it sets the appropriate bit in TRPTBL\r\n; which will cause the BASIC program's pen service routine (ON STRIG(N) GOSUB)\r\n; to be invoked.\r\n; Exit - AX, BX, CX, DX can be used (restored by CHKINT).\r\n;        All other registers are preserved.\r\n;\r\nPOLSTR:\r\n\tXOR\tAX,AX\t\t;[AL] = joystick trigger #0 (for RDTRIG)\r\n\tINC\tAH\t\t;[AH] = latched (not current) flag\r\nSTRILP:\r\n\tPUSH\tAX\t\t;save current trigger id\r\n\tADD\tAL,LOW OFFSET STROFF\r\n\tCALL\tEVADR\t\t;[DX] points to event mask\r\n\tMOV\tBX,DX\t\t;[BX] points to event mask\r\n\tTEST\tBYTE PTR 0[BX],LOW OFFSET T_ON\t;see if STRIG(n) ON has been done\r\n\tPOP\tAX\r\n\tPUSH\tAX\r\n\tJE\tSTRI1\t\t;don't call RDTRIG if event not enabled\r\n\tCALL\tRDTRIG\t\t;[AL]=0/1 if trig is not-pressed/pressed\r\n\tOR\tAL,AL\r\n\tJE\tSTRI1\t\t;brif this trigger has not interrupted\r\n\tPOP\tAX\t\t;restore [AL] = joystick trigger id\r\n\tPUSH\tAX\r\n\tADD\tAL,LOW OFFSET STROFF\t;[AL] = global event id\r\n\tCALL\tEVTRP\t\t;Signal the occurance of a TRIGGER EVENT\r\nSTRI1:\tPOP\tAX\r\n\tINC\tAL\r\n\tCMP\tAL,LOW OFFSET NMSTRT\r\n\tJB\tSTRILP\t\t;brif there are more triggers to poll\r\n\tRET\t\r\n\r\n\tSUBTTL DATE - Get/Set Date.\r\n\r\n\tPUBLIC\tDATES,DATEF\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDAYSPM:WORD\r\nDSEG\tENDS\r\n\r\n;DATE$=\"[M]M/[D]D/[YY]YY\" or \"[M]M-[D]D-[YY]YY\"USA Date format\r\n;\r\nDATES:\tCALL\tPRSDAT\t\t;CX=year, DH=month, DL=day\r\n\tJMP\tSETDAT\t\t;set system date\r\n\r\n;X$=DATE$ returns \"YYYY-MM-DD\" if KANABS&KANADT else \"MM-DD-YYYY\"\r\n;\r\nDATEF:\r\n\tCALL\tCHRGTR\t\t;skip DATE$\r\n\tPUSH\tBX\t\t;Save Text pointer\r\n\tMOV\tAL,LOW 10D\r\n\tCALL\tSTRINI\t\t;Get space for 10 char string\r\n\tPUSH\tDX\t\t;save adr of string\r\n\tCALL\tGETDAT\t\t;CX=year, DH=month, DL=day\r\n\tPOP\tBX\t\t;[BX]=adr of string\r\n\tSUB\tCX,1900D\t;Reduce year by two digits\r\n\tCMP\tCL,LOW 100D\t;See if in 20th century\r\n\tMOV\tCH,LOW 19D\t;Setup 20th century in case\r\n\tJB\tDATEF2\t\t;Brif so.\r\n\tSUB\tCL,LOW 100D\t;subtract into next century\r\n\tINC\tCH\t\t;21st century\r\nDATEF2:\r\n\tMOV\tAL,DH\r\n\tCALL\tPUTCHR\t\t;Store ascii month\r\n\tMOV\tAL,LOW \"-\"\r\n\tCALL\tPUTCH2\t\t;put separater\r\n\tMOV\tAL,DL\r\n\tCALL\tPUTCHR\t\t;Store ascii day\r\n\tMOV\tAL,LOW \"-\"\r\n\tCALL\tPUTCH2\t\t;put separater\r\n\tMOV\tAL,CH\r\n\tCALL\tPUTCHR\t\t;Store ascii century\r\n\tMOV\tAL,CL\r\n\tCALL\tPUTCHR\t\t;Store ascii year.\r\n\tJMP\tPUTNEW\t\t;Put result and ret (Txt ptr on stack).\r\n\r\nPUTCHR:\r\n\tAAM\t\t\t;Convert to unpacked BCD\r\n\tXCHG\tAL,AH\r\n\tOR\tAX,30060O\t;Add \"0\" bias to both digits.\r\n\tCALL\tPUTCH2\r\n\tMOV\tAL,AH\r\nPUTCH2:\r\n\tMOV\tBYTE PTR 0[BX],AL\t;store char in string\r\n\tINC\tBX\r\n\tRET\t\r\n\r\n\r\n;PRSDAT parses a string containing\r\n;   \"[YY]YY/MM/DD\" if KANABS&KANADT else \"MM/DD/[YY]YY\"\r\n; Exit - CX=year, DH=month, DL=day,\r\n;         [BX]=new text pointer.  All other regs preserved.\r\n;\r\nPRSDAT:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET EQULTK\t;Must be DATE$ = string\r\n\tCALL\tFRMEVL\r\n\tPUSH\tBX\t\t;Save Text pointer\r\n\tCALL\tFRESTR\r\n\tMOV\tCL,BYTE PTR 0[BX]\t;Save string len in [CL]\r\n\tCMP\tCL,LOW 1\t;String must not be null\r\n\tJB\tDATERR\t\t;Brif null str\r\n\tMOV\tSI,WORD PTR 1[BX]\t;[SI] has addr of string.\r\n\tMOV\tBL,CL\t\t;Working reg for string len.\r\n\tCALL\tGNUM8\t\t;[AX]=month\r\n\tMOV\tDH,AL\t\t;[DH] = month\r\n\tCALL\tDATSEP\t\t;skip / or -\r\n\tCALL\tGNUM8\t\t;[AL]=day of month\r\n\tMOV\tDL,AL\t\t;[DL] = day\r\n\tCALL\tDATSEP\t\t;skip / or -\r\n\tCALL\tGNUM16\t\t;[AX]=year (16 BITS)\r\n\tCMP\tAX,1978D\r\n\tJNB\tDATE2\t\t;branch if .GE. 1978\r\n\tCMP\tAX,100D\r\n\tJNB\tDATERR\t\t;error if between 100 and 1977\r\n\tCMP\tAX,78D\r\n\tJNB\tDATE1\t\t;add 1900 if .GE. 78\r\n\tADD\tAX,100D\t\t;add 2000 if .LE. 77\r\nDATE1:\tADD\tAX,1900D\r\nDATE2:\r\n\tCMP\tAX,2100D\r\n\tJNB\tDATERR\t\t;branch if year too large\r\n\tMOV\tCX,AX\t\t;CX=year\r\n\tPOP\tBX\t\t;Text pointer\r\n\tRET\t\t\t;Exit.\r\n\r\n;DATSEP checks for a date separator (- or /) and returns if found.\r\n;\r\nDATSEP:\r\n\tOR\tBL,BL\r\n\tJZ\tDATERR\t\t;Error if string empty.\r\n\tMOV\tAL,BYTE PTR 0[SI]\r\n\tCMP\tAL,LOW \"/\"\r\n\tJZ\tDIGITX\r\n\tCMP\tAL,LOW \"-\"\r\n\tJZ\tDIGITX\t\t;branch if found\r\n\tJMP\tSHORT DATERR\r\n\r\nGNUM8:\tCALL\tGNUM16\t\t;[AX]=16-bit number\r\n\tOR\tAH,AH\r\n\tJNZ\tDATERR\t\t;error if larger than 255\r\n\tRET\t\r\n\r\nGNUM16:\tPUSH\tCX\t\t;save caller's [CX], [DX]\r\n\tPUSH\tDX\r\n\tMOV\tAX,0\t\t;initialize accumulator\r\nGNUML:\tCALL\tDIGIT\t\t;[CX]=0..9\r\n\tJB\tGNUMX\t\t;branch if not legal digit\r\n\tMOV\tDX,10D\r\n\tMUL\tDX\t\t;[AX]=[AX]*10\r\n\tJO\tDATERR\t\t;branch if overflow\r\n\tADD\tAX,CX\t\t;add in new digit\r\n\tJMP\tSHORT GNUML\r\nGNUMX:\tPOP\tDX\r\n\tPOP\tCX\r\nRET2:\tRET\t\r\n\r\nDIGIT:\tCMP\tBL,LOW 1\t;End-of-string?\r\n\tJB\tRET2\t\t;Brif END-OF-STRING\r\n\tMOV\tCL,BYTE PTR 0[SI]\r\n\tSUB\tCL,LOW \"0\"\r\n\tJB\tRET2\t\t;branch if illegal digit\r\n\tCMP\tCL,LOW 10D\r\n\tCMC\t\r\n\tJB\tRET2\t\t;branch if illegal digit\r\n\tMOV\tCH,LOW 0\t;[CX]=digit\r\nDIGITX:\tDEC\tBL\t\t;Length -1\r\n\tINC\tSI\t\t;[SI] points to next byte in string\r\n\tRET\t\r\n\r\nDATERR:\tJMP\tFCERR\r\n\r\nIFE\tIBMTOK OR CPM86  \r\n;DYOFYR converts YEAR, MONTH, DAY to binary DAY-OF-YEAR\r\n; Entry - [CX]=binary year (19xx/20xx)\r\n;         [DH]=binary month (1..12)\r\n;         [DL]=binary day-of-month (1..31)\r\n; Exit  - [BX]=binary day of year (0..364/365)\r\n;         [CX] is preserved, all other registers are destroyed.\r\n;\r\nDYOFYR:\tSUB\tCX,1978D\t;[CX]=year - 1978\r\n\tDEC\tDL\t\t;[DL]=day of month - 1\r\n\tDEC\tDH\t\t;[DH]=month - 1\r\n\tMOV\tBL,DL\r\n\tXOR\tBH,BH\t\t;[BX]=day accumulator=day-of-month - 1\r\n\tMOV\tAH,BH\r\n\tMOV\tAL,DH\t\t;[AX]=month - 1\r\n\tMOV\tSI,AX\t\t;[SI]=month - 1\r\n\tCALL\tSETFEB\t\t;DAYSPM(2)=28 or 29\r\n\tCMP\tDH,LOW 12D\r\n\tJNB\tDATERR\t\t;error if month is too large\r\n\tCMP\tDL,BYTE PTR DAYSPM[SI]\r\n\tJNB\tDATERR\t\t;error if day-of-month too large\r\n\tOR\tSI,SI\r\nMONTHL:\tJNZ\tMONTHS\r\n\tRET\t\r\nMONTHS:\tMOV\tAL,BYTE PTR DAYSPM-1[SI]\r\n\tADD\tBX,AX\t\t;days=days+DAYSPM(month)\r\n\tDEC\tSI\r\n\tJMP\tSHORT MONTHL\r\n\r\n;SETFEB sets DAYSPM(2) to 28 or 29 depending on year\r\n;\r\nSETFEB:\tCALL\tCKLEAP\t\t;[AX]=1 if [CX]=leap-year\r\n\tADD\tAL,LOW 28D\t;[AL]=29 if leap, 28 if not\r\n\tMOV\tBYTE PTR DAYSPM+1,AL\t;DAYSPM(2)=28 or 29\r\n\tRET\t\r\n\r\n;CKLEAP returns with [AX]=1 if [CX]+1978 is a leap year, else [AX]=0.\r\n;\r\nCKLEAP:\tMOV\tAH,LOW 0\r\n\tMOV\tAL,CL\r\n\tAND\tAL,LOW 3\r\n\tSUB\tAL,LOW 2\t;[AX]=0 if leap year\r\n\tJZ\tCKLEA1\t\t;branch if it is leap-year\r\n\tMOV\tAL,LOW 377O\r\nCKLEA1:\tINC\tAL\r\n\tRET\t\r\nENDIF \r\n\r\nIF\tCPM86  \r\n;SETDAT sets the system clock's date.\r\n; Entry - [CX]=year (19xx/20xx)\r\n;         [DH]=month (1..12)\r\n;         [DL]=binary day-of-month (1..31)\r\n; Exit  - [BX] preserved.  All other registers destroyed.\r\n;\r\nSETDAT:\tPUSH\tBX\t\t;save BX\r\n\tCALL\tGDTIME\t\t;get current date/time into DATIME\r\n\tCALL\tDYOFYR\t\t;[BX]=day of year (0..364/365)\r\n\t\t\t\t;[CX]=year - 1978\r\n\tOR\tCX,CX\t\t;test year\r\n\tJZ\tYEARSX\t\t;branch if 1978\r\n\tJMP\tSHORT YEARS1\r\nYEARSL:\tCALL\tCKLEAP\t\t;[AX]=1 if CX is leap-year\r\n\tADD\tBX,AX\t\t;days=days+1 if leap-lear\r\nYEARS1:\tADD\tBX,365D\t\t;days=days+365\r\n\tLOOPNZ\tYEARSL\r\nYEARSX:\tMOV\tWORD PTR DATIME,BX\t;DATIME=count of days since 1/1/1978\r\n\tCALL\tSDTIME\t\t;set current date/time from DATIME\r\n\tPOP\tBX\t\t;restore text pointer\r\n\tRET\t\r\n\r\n;GETDAT returns with [CX]=year, DH=month, DL=day-of-month.\r\n; Exit - BX, AX are used.\r\n;\r\nGETDAT:\tCALL\tGDTIME\t\t;get current date/time into DATIME\r\n\tMOV\tDX,WORD PTR DATIME\t;[DX]=no of days since JAN 1,1978\r\n\tMOV\tCX,0\t\t;years=0\r\nFNDYR:\tCALL\tCKLEAP\t\t;[AX]=1 if leap-year\r\n\tADD\tAX,365D\t\t;[AX]=366 if leap-year\r\n\tCMP\tDX,AX\r\n\tJB\tGOTYR\t\t;branch if CX=year\r\n\tSUB\tDX,AX\t\t;days=days-365 or 366\r\n\tINC\tCX\t\t;year=year+1\r\n\tJMP\tSHORT FNDYR\r\n\r\nGOTYR:\tCALL\tSETFEB\t\t;set DAYSPM(2)=28 or 29\r\n\tMOV\tBX,0\r\n\tMOV\tAH,BH\r\nFNDMON:\tMOV\tAL,BYTE PTR DAYSPM[BX]\t;[AX]=days in month BX\r\n\tINC\tBX\r\n\tCMP\tDX,AX\r\n\tJB\tGOTMON\t\t;branch if BX is month\r\n\tSUB\tDX,AX\r\n\tJMP\tSHORT FNDMON\r\n\r\nGOTMON:\tMOV\tDH,BL\t\t;[DH]=month (1..12)\r\n\tINC\tDL\t\t;[DL]=day of month (1..31)\r\n\tADD\tCX,1978D\t;[CX]=year\r\n\tRET\t\r\nENDIF \r\nSETDAT:\tPUSH\tBX\r\n\tDOSIO\tSDAT\t\t;Give Date to MS-DOS.\r\n\tOR\tAL,AL\t\t;Date OK?\r\n\tJNZ\tDATERR\t\t;Brif not.\r\n\tPOP\tBX\r\n\tRET\t\r\n\r\n;GETDAT returns with [CX]=year, DH=month, DL=day-of-month.\r\n; Exit - BX, AX are used.\r\n;\r\nGETDAT:\tDOSIO\tGDAT\t\t;Get Date from MS-DOS\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL TIME - Get/Set Time.\r\n\r\n\tPUBLIC\tTIMES,TIMEF\r\n\tEXTRN\tSTRINI:NEAR,PUTNEW:NEAR,FCERR:NEAR\r\n\tEXTRN\tCHRGTR:NEAR,SYNCHR:NEAR,GETYPR:NEAR,FRMEVL:NEAR,FRESTR:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDATIME:WORD,EQULTK:WORD\r\nDSEG\tENDS\r\n\r\n; TIME$=[H]H[:[M]M[:[S]S[:[T]T]]]\r\n;\r\nTIMES:\tCALL\tPRSTIM\t\t;CH=hour, CL=min, DH=sec, DL=.01sec\r\n\tJMP\tSETTIM\t\t;set system time\r\n\r\n;X$=TIME$ returns \"HH:MM:SS\"\r\n;\r\nTIMEF:\r\n\tCALL\tCHRGTR\t\t;skip TIME$ (it was CPI'ed in FRMEVL)\r\n\tPUSH\tBX\t\t;Save Text pointer\r\n\tMOV\tAL,LOW 8D\r\n\tCALL\tSTRINI\t\t;Get space for 8 char string\r\n\tPUSH\tDX\t\t;Save addr of string\r\n\tCALL\tGETTIM\t\t;CH=hour, CL=min, DH=sec\r\n\tPOP\tBX\t\t;Restore addr of String\r\n\tMOV\tAL,CH\r\n\tCALL\tPUTCHR\t\t;Store ascii hours\r\n\tMOV\tAL,LOW \":\"\r\n\tCALL\tPUTCH2\r\n\tMOV\tAL,CL\r\n\tCALL\tPUTCHR\t\t;Store ascii minutes\r\n\tMOV\tAL,LOW \":\"\r\n\tCALL\tPUTCH2\r\n\tMOV\tAL,DH\r\n\tCALL\tPUTCHR\t\t;Store ascii seconds.\r\n\tJMP\tPUTNEW\t\t;Put result and ret (Txt ptr on stack).\r\n\r\n\tEXTRN\tFMULT:NEAR,CONIA:NEAR,FRCSNG:NEAR,FADD:NEAR,PUSHF:NEAR\r\n\r\n\r\n;PRSTIM parses a string containing \"HH[:MM[:SS[.TT]]]\r\n; Exit - CH=hours, CL=minutes, DH=seconds, DL=.01 secs,\r\n;         [BX]=new text pointer.  All other regs preserved.\r\n;\r\nPRSTIM:\r\n\tCALL\tSYNCHR\r\n\tDB\tOFFSET EQULTK\t;Must be TIME$ = string\r\n\tCALL\tFRMEVL\r\n\tPUSH\tBX\t\t;Save Text pointer\r\n\tCALL\tFRESTR\r\n\tMOV\tCL,BYTE PTR 0[BX]\t;Save string len in [CL]\r\n\tCMP\tCL,LOW 1\t;String must not be null\r\n\tJB\tTIMERR\t\t;Brif null str\r\n\tMOV\tSI,WORD PTR 1[BX]\t;[SI] has addr of string.\r\n\tMOV\tBL,CL\t\t;Working reg for string len.\r\n\tCALL\tGNUM8\t\t;[AX]=hours\r\n\tCMP\tAL,LOW 24D\r\n\tJNB\tTIMERR\r\n\tMOV\tCH,AL\t\t;[CH] = hours\r\n\tCALL\tTIMSEP\r\n\tCALL\tGNUM8\r\n\tCMP\tAL,LOW 60D\r\n\tJNB\tTIMERR\r\n\tMOV\tCL,AL\t\t;[CL] = minutes\r\n\tCALL\tTIMSEP\r\n\tCALL\tGNUM8\r\n\tCMP\tAL,LOW 60D\r\n\tJNB\tTIMERR\r\n\tMOV\tDH,AL\t\t;[DH] = seconds.\r\n\tCALL\tTIMSEP\r\n\tCALL\tGNUM8\r\n\tCMP\tAL,LOW 100D\r\n\tJNB\tTIMERR\r\n\tMOV\tDL,AH\t\t;[DL] = 100ths.\r\n\tPOP\tBX\t\t;Text pointer\r\n\tRET\t\t\t;Exit.\r\n\r\nTIMSEP:\r\n\tOR\tBL,BL\r\n\tJZ\tTIMSXX\r\n\tDEC\tBL\r\n\tCLD\t\t\t;Set to increment\r\n\tLODSB\r\n\tCMP\tAL,LOW \":\"\r\n\tJZ\tTIMSXX\r\n\tCMP\tAL,LOW \".\"\r\n\tJNZ\tTIMERR\r\nTIMSXX:\r\n\tRET\t\r\n\r\nTIMERR:\tJMP\tFCERR\r\n\r\n\r\nIF\tCPM86  \r\nSETTIM:\tCALL\tGDTIME\t\t;get current date/time into DATIME\r\n\tPUSH\tBX\t\t;save text pointer\r\n\tMOV\tBX,OFFSET DATIME+2\t;BX points to hours digit of buffer\r\n\tMOV\tAL,CH\r\n\tCALL\tBINBCD\t\t;DT.HRS=BINBCD(CH)\r\n\tMOV\tAL,CL\r\n\tCALL\tBINBCD\t\t;DT.MIN=BINBCD(CL)\r\n\tMOV\tAL,DH\r\n\tCALL\tBINBCD\t\t;DT.SEC=BINBCD(DH)\r\n\tCALL\tSDTIME\t\t;set current date/time from DATIME\r\n\tPOP\tBX\t\t;restore text pointer\r\n\tRET\t\r\n\r\n;BINBCD converts [AL] to 2-digit BCD and stores the result at [BX]\r\n; Exit  - BX is incremented\r\n;\r\nBINBCD:\r\n\tPUSH\tDX\t\t;save caller's [DX]\r\n\tMOV\tAH,LOW 0\r\n\tMOV\tDL,LOW 10D\r\n\tDIV\tDL\t\t;[AL]=[AX]/10, [AH]=remainder\r\n\tADD\tAL,AL\t\t;[AL]=1st digit * 2\r\n\tADD\tAL,AL\t\t; * 4\r\n\tADD\tAL,AL\t\t; * 8\r\n\tADD\tAL,AL\t\t; * 16\r\n\tADD\tAL,AH\t\t; + second digit\r\n\tPOP\tDX\t\t;restore caller's [DX]\r\n\tJMP\tPUTCH2\r\n\r\nGETTIM:\tCALL\tGDTIME\t\t;get current date/time into DATIME\r\n\tMOV\tBX,OFFSET DATIME+2\t;BX points to hours digit of buffer\r\n\tCALL\tBCDBIN\r\n\tMOV\tCH,AL\t\t;[CH]=BCDBIN(DT.HRS)\r\n\tCALL\tBCDBIN\r\n\tMOV\tCL,AL\t\t;[CL]=BCDBIN(DT.MIN)\r\n\tCALL\tBCDBIN\r\n\tMOV\tDH,AL\t\t;[DH]=BCDBIN(DT.SEC)\r\n\tRET\t\r\n\r\n;GDTIME sets DATIME to the current date-time.\r\n; Exit - All registers preserved.\r\n;\r\nGDTIME:\tPUSH\tES\r\n\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tCLD\t\t\t;Because of Melco BIOS Bug\r\n\tMOV\tDX,OFFSET DATIME\r\n\tCPMXIO\t155D\t\t;CPM86 system call\r\n\tJMP\tSHORT SDTIMX\r\n\r\n;SDTIME sets the system clock to DATIME\r\n; Exit - All registers preserved.\r\n;\r\nSDTIME:\tPUSH\tES\r\n\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tMOV\tDX,OFFSET DATIME\r\n\tCPMXIO\t104D\t\t;CPM86 system call\r\nSDTIMX:\tPOP\tDX\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tPOP\tAX\r\n\tPOP\tES\r\n\tRET\t\r\n\r\n;BCDBIN converts [[BX]] from 2-digit BCD to binary and\r\n; returns it in [AL]\r\n; Exit  - BX is incremented, AH, DL are destroyed.\r\n;\r\nBCDBIN:\tMOV\tAL,BYTE PTR 0[BX]\r\n\tINC\tBX\r\n\tMOV\tAH,AL\t\t;[AH]=copy of input parameter\r\n\tAND\tAL,LOW 360O\t;[AL]=D1*16 (most significant digit)\r\n\tROR\tAL,1\t\t;[AL]=D1*8\r\n\tMOV\tDL,AL\t\t;[DL]=D1*8\r\n\tROR\tAL,1\t\t;[AL]=D1*4\r\n\tROR\tAL,1\t\t;[AL]=D1*2\r\n\tADD\tAL,DL\t\t;[AL]=D1*10\r\n\tAND\tAH,LOW 17O\t;[AH]=D2\r\n\tADD\tAL,AH\t\t;[AL]=10*D1+D2=binary result\r\n\tRET\t\r\nENDIF \r\nSETTIM:\tPUSH\tBX\r\n\tDOSIO\tSTIM\t\t;Give Time to MS-DOS.\r\n\tOR\tAL,AL\t\t;Date OK?\r\n\tJNZ\tTIMERR\t\t;Brif not.\r\n\tPOP\tBX\r\n\tRET\t\r\n\r\nGETTIM:\tDOSIO\tGTIM\t\t;Get Time from MS-DOS\r\n\tRET\t\r\n\r\n\tSUBTTL  Error Handlers for Features not supported in a version\r\n\r\n\tEXTRN\tDERDNA:NEAR\r\n\tJMP\tDERDNA\t\t;Device unavailable error\r\n\r\nPUBLIC\tPALETE\r\nPALETE:\r\n\tJMP\tSNERR\r\n\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tERRADV:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tERROR:NEAR\r\n\r\nPUBLIC\tTIMER\r\nTIMER:\r\nPUBLIC\tERDEV\r\nERDEV:\r\nPUBLIC\tIOCTL\r\nIOCTL:\r\nPUBLIC\tCHDIR\r\nCHDIR:\r\nPUBLIC\tMKDIR\r\nMKDIR:\r\nPUBLIC\tRMDIR\r\nRMDIR:\r\nPUBLIC\tSHELL\r\nSHELL:\r\nPUBLIC\tENVIRON\r\nENVIRON:\r\nPUBLIC\tVIEW\r\nVIEW:\r\nPUBLIC\tWINDOW\r\nWINDOW:\r\nPUBLIC\tPMAP\r\nPMAP:\r\nADVERR:\r\n\tMOV\tDL,LOW OFFSET ERRADV\r\n\tJMP\tERROR\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\r\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "IBMRES.ASM",
          "type": "blob",
          "size": 15.875,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tIBMRES.H \r\n\r\n\tSUBTTL  Equates and External Declarations\r\n\tTITLE   IBMRES - IBM compatible reserved words / MLC\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- ---------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT\r\n--------- --- ---- -- ---------\r\n\r\nThis module is used to create GW-BASICs with IBM PC compatible\r\nreserved word tokens.  The reserved word tables were created by\r\ncleaning up a copy of the tables from BINTRP.  The code and tables\r\nto handle the extended reserved words was taken from L2RESS.MAC and\r\nmodified as necessary.\r\n\t*\r\n\r\nGWLEV2=0\t\t\t;GW BASIC version 2.0 features\r\n\r\n\t.SALL\r\n\t.RADIX\t10\r\n\r\n\r\n\tPUBLIC\t$KEY2B,$COM2B,$PEN2B,$STR2B\r\n\tEXTRN\tCHRGTR:NEAR\r\n\tEXTRN\tDATEF:NEAR\r\n\tEXTRN\tLABBCK:NEAR\r\n\tEXTRN\tMAKUPL:NEAR\r\n\tEXTRN\tNOTRFN:NEAR\r\n\tEXTRN\tPARCHK:NEAR,PENS:NEAR,PLOOP2:NEAR,PPSWRT:NEAR\r\n\tEXTRN\tRENCRN:NEAR\r\n\tEXTRN\tSTRIGS:NEAR\r\n\tEXTRN\tTIMEF:NEAR,TSTANM:NEAR\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tFLGOVC:WORD,TEMPA:WORD\r\nDSEG\tENDS\r\n\r\n\r\n\r\n;\r\n; THESE MACRO CALLS DEFINE THE RESWRD VALUES\r\n; AND THE TABLE DISPATCH FOR STATEMENTS AND FUNCTIONS\r\n;\r\n; STATEMENTS:\r\n;\r\n\r\nPUBLIC\tSTMDSP\r\nSTMDSP:\t\t\t\t;MARKS START OF STATEMENT LIST\r\n\tQQ=128\r\n\tR2\tEND,ENDST\r\n\tR\tFOR\r\n\tR\tNEXT\r\n\tR2\tDATA,DATAS\r\n\tR\tINPUT\r\n\tR\tDIM\r\n\tR\tREAD\r\n\tR\tLET\r\n\tR\tGOTO\r\n\tR\tRUN\r\n\tR2\tIF,IFS\r\n\tR\tRESTORE\r\n\tR\tGOSUB\r\n\tR\tRETURN\r\n\tR\tREM\r\n\tR\tSTOP\r\n\tR\tPRINT\r\n\tR\tCLEAR\r\n\tR\tLIST\r\n\tR2\tNEW,SCRATH\r\n\tR2\tON,ONGOTO\r\n\tR2\tWAIT,FNWAIT\r\n\tR\tDEF\r\n\tR\tPOKE\r\n\tR\tCONT\r\n\tR2\tDUMMY,SNERR\t;padding\r\n\tR2\tDUMMY,SNERR\t;padding\r\n\tR2\tOUT,FNOUT\r\n\tR\tLPRINT\r\n\tR\tLLIST\r\n\tR2\tDUMMY,SNERR\t;padding\r\n\tR2\tWIDTH,WIDTHS\r\n\tR2\tELSE,ELSES\r\n\tR2\tTRON,TON\r\n\tR2\tTROFF,TOFF\r\n\tR\tSWAP\r\n\tR\tERASE\r\n\tR\tEDIT\r\n\tR2\tERROR,ERRORS\r\n\tR\tRESUME\r\n\tR\tDELETE\r\n\tR\tAUTO\r\n\tR2\tRENUM,RESEQ\r\n\tR\tDEFSTR\r\n\tR\tDEFINT\r\n\tR2\tDEFSNG,DEFREA\r\n\tR\tDEFDBL\r\n\tR\tLINE\r\n\tR\tWHILE\r\n\tR\tWEND\r\n\tR2\tCALL,CALLS\r\n\tR2\tDUMMY,SNERR\t;padding\r\n\tR2\tDUMMY,SNERR\t;padding\r\n\tR2\tDUMMY,SNERR\t;padding\r\n\tR\tWRITE\r\n\tR\tOPTION\r\n\tR2\tRANDOMIZE,RANDOM\r\n\tR\tOPEN\r\n\tR\tCLOSE\r\n\tR\tLOAD\r\n\tR\tMERGE\r\n\tR\tSAVE\r\n\tR\tCOLOR\r\n\tR\tCLS\r\n\tR\tMOTOR\r\n\tR\tBSAVE\r\n\tR\tBLOAD\r\n\tR2\tSOUND,SOUNDS\r\n\tR2\tBEEP,BEEPS\r\n\tR\tPSET\r\n\tR\tPRESET\r\n\tR\tSCREEN\r\n\tR2\tKEY,KEYS\r\n\t$KEY2B=0+QQ\t\t;value of KEY 2-byte token\r\n\tR\tLOCATE\r\n\r\nPUBLIC\tNUMCMD\r\n\tNUMCMD=QQ-$END+1\r\n\r\n;\r\n; TOKENS\r\n;\r\n\r\n;\r\n;QQ MUST BE SET SO TOKENS START AT RIGHT PLACE\r\n;\r\n\r\n\tQQ=QQ+1\r\n\r\n\tT\tTO\r\n\tT\tTHEN\r\nPUBLIC\tTHENTK\r\n\tTHENTK=QQ\r\n\tT\tTAB\r\nPUBLIC\tTABTK\r\n\tTABTK=QQ\r\n\tT\tSTEP\r\nPUBLIC\tSTEPTK\r\n\tSTEPTK=QQ\r\n\tT\tUSR\r\nPUBLIC\tUSRTK\r\n\tUSRTK=QQ\r\n\tT\tFN\r\nPUBLIC\tFNTK\r\n\tFNTK=QQ\r\n\tT\tSPC\r\nPUBLIC\tSPCTK\r\n\tSPCTK=QQ\r\n\tT\tNOT\r\nPUBLIC\tNOTTK\r\n\tNOTTK=QQ\r\n\tT\tERL\r\nPUBLIC\tERLTK\r\n\tERLTK=QQ\r\n\tT\tERR\r\nPUBLIC\tERCTK\r\n\tERCTK=QQ\r\n\tT\tSTRING$\r\n\tT\tUSING\r\nPUBLIC\tUSINTK\r\n\tUSINTK=QQ\r\n\tT\tINSTR\r\nPUBLIC\tINSRTK\r\n\tINSRTK=QQ\r\n\tT\tDUMMY\r\nPUBLIC\tSNGQTK\r\n\tSNGQTK=QQ\r\n\tT\tVARPTR\r\n\tT\tCSRLIN\r\nPUBLIC\tCLINTK\r\n\tCLINTK=QQ\r\n\tT\tPOINT\r\n\tT\tOFF\r\n\tT\tINKEY$\r\n\r\n;\r\n; OPERATORS\r\n;\r\n\r\n\tQQ=QQ+7\r\n\r\n\tT\tDUMMY\r\nPUBLIC\tGREATK\r\n\tGREATK=QQ\r\n\tT\tDUMMY\r\nPUBLIC\tEQULTK\r\n\tEQULTK=QQ\r\n\tT\tDUMMY\r\nPUBLIC\tLESSTK\r\n\tLESSTK=QQ\r\n\tT\tDUMMY\r\nPUBLIC\tPLUSTK\r\n\tPLUSTK=QQ\r\n\tT\tDUMMY\r\nPUBLIC\tMINUTK\r\n\tMINUTK=QQ\r\n\tT\tDUMMY\r\nPUBLIC\tMULTK\r\n\tMULTK=QQ\r\n\tT\tDUMMY\r\nPUBLIC\tDIVTK\r\n\tDIVTK=QQ\r\n\tT\tDUMMY\r\nPUBLIC\tEXPTK\r\n\tEXPTK=QQ\r\n\tT\tAND\r\n\tT\tOR\r\n\tT\tXOR\r\n\tT\tEQV\r\n\tT\tIMP\r\n\tT\tMOD\r\n\tT\tDUMMY\r\nPUBLIC\tIDIVTK\r\n\tIDIVTK=QQ\r\nPUBLIC\tLSTOPK\r\n\tLSTOPK=QQ+1-PLUSTK\r\n\r\n;\r\n; FUNCTIONS - 2 byte tokens, the 1st byte is FF\r\n;\r\n\r\n\tQQ=128\r\nPUBLIC\tFUNDSP\r\nFUNDSP:\r\n\tR\tLEFT$\r\nPUBLIC\tONEFUN\r\n\tONEFUN=QQ\r\n\tR\tRIGHT$\r\n\tR\tMID$\r\nPUBLIC\tMIDTK\r\n\tMIDTK=QQ\r\n\tR\tSGN\r\n\tR2\tINT,VINT\r\n\tR2\tABS,ABSFN\r\n\tR\tSQR\r\nPUBLIC\tSQRTK\r\n\tSQRTK=QQ\r\n\tR\tRND\r\n\tR\tSIN\r\n\tR\tLOG\r\n\tR\tEXP\r\n\tR\tCOS\r\n\tR\tTAN\r\n\tR\tATN\r\nPUBLIC\tATNTK\r\n\tATNTK=QQ\r\n\tR\tFRE\r\n\tR2\tINP,FNINP\r\n\tR\tPOS\r\n\tR\tLEN\r\n\tR\tSTR$\r\n\tR\tVAL\r\n\tR\tASC\r\n\tR\tCHR$\r\n\tR\tPEEK\r\n\tR\tSPACE$\r\n\tR2\tOCT$,STRO$\r\n\tR2\tHEX$,STRH$\r\n\tR\tLPOS\r\nPUBLIC\tLASNUM\r\n\tLASNUM=QQ\r\n\tR2\tCINT,FRCINT\r\n\tR2\tCSNG,FRCSNG\r\n\tR2\tCDBL,FRCDBL\r\n\tR2\tDUMMY,FIXER\r\nPUBLIC\t$FIX\r\n\t$FIX=QQ\r\n\tR2\tPEN,PENF\r\n\t$PEN2B=0+(400O*377O)+QQ\t;value of PEN 2-byte token\r\n\tR2\tSTICK,STICKF\r\n\tR2\tSTRIG,STRIGF\r\n\t$STR2B=0+(400O*377O)+QQ\t;value of STRIG 2-byte token\r\n\tR\tEOF\r\n\tR\tLOC\r\n\tR\tLOF\r\n\r\n;\r\n; THE FOLLOWING TABLES ARE THE ALPHABETIC DISPATCH TABLE\r\n; FOLLOWED BY THE RESERVED WORD TABLE ITSELF\r\n;\r\nPUBLIC\tALPTAB\r\nALPTAB:\r\n\r\n\tDW\tOFFSET ATAB\r\n\tDW\tOFFSET BTAB\r\n\tDW\tOFFSET CTAB\r\n\tDW\tOFFSET DTAB\r\n\tDW\tOFFSET ETAB\r\n\tDW\tOFFSET FTAB\r\n\tDW\tOFFSET GTAB\r\n\tDW\tOFFSET HTAB\r\n\tDW\tOFFSET ITAB\r\n\tDW\tOFFSET JTAB\r\n\tDW\tOFFSET KTAB\r\n\tDW\tOFFSET LTAB\r\n\tDW\tOFFSET MTAB\r\n\tDW\tOFFSET NTAB\r\n\tDW\tOFFSET OTAB\r\n\tDW\tOFFSET PTAB\r\n\tDW\tOFFSET QTAB\r\n\tDW\tOFFSET RTAB\r\n\tDW\tOFFSET STAB\r\n\tDW\tOFFSET TTAB\r\n\tDW\tOFFSET UTAB\r\n\tDW\tOFFSET VTAB\r\n\tDW\tOFFSET WTAB\r\n\tDW\tOFFSET XTAB\r\n\tDW\tOFFSET YTAB\r\n\tDW\tOFFSET ZTAB\r\n\r\n\r\nPUBLIC\tRESLST\r\nRESLST:\r\n\r\nATAB:\r\n\tQ\tAUTO\r\n\tQ\tAND\r\n\tQF\tABS\r\n\tQF\tATN\r\n\tQF\tASC\r\n\tDB\t0\r\nBTAB:\r\n\tQ\tBSAVE\r\n\tQ\tBLOAD\r\n\tQ\tBEEP\r\n\tDB\t0\r\nCTAB:\r\n\tQ\tCOLOR\r\n\tQ\tCLOSE\r\n\tQ\tCONT\r\n\tQ\tCLEAR\r\n\tQ\tCSRLIN\r\n\tQF\tCINT\r\n\tQF\tCSNG\r\n\tQF\tCDBL\r\n\tQF\tCOS\r\n\tQF\tCHR$\r\n\tQ\tCALL\r\n\tQ\tCLS\r\n\tDB\t0\r\nDTAB:\r\n\tQ\tDELETE\r\n\tQ\tDATA\r\n\tQ\tDIM\r\n\tQ\tDEFSTR\r\n\tQ\tDEFINT\r\n\tQ\tDEFSNG\r\n\tQ\tDEFDBL\r\n\tQ\tDEF\r\n\tDB\t0\r\nETAB:\r\n\tQ\tELSE\r\n\tQ\tEND\r\n\tQ\tERASE\r\n\tQ\tEDIT\r\n\tQ\tERROR\r\n\tQ\tERL\r\n\tQ\tERR\r\n\tQF\tEXP\r\n\tQF\tEOF\r\n\tQ\tEQV\r\n\tDB\t0\r\nFTAB:\r\n\tQ\tFOR\r\n\tQ\tFN\r\n\tQF\tFRE\r\n\tQF\tFIX\r\n\tDB\t0\r\nGTAB:\r\n\tQ\tGOTO\r\n\tDB\t\"O\"\r\n\tDB\t\" \"\r\n\tDB\t\"T\"\r\n\tDB\t\"O\"+128D\r\n\tDB\tOFFSET $GOTO\r\n\tQ\tGOSUB\r\n\tDB\t0\r\nHTAB:\r\n\tQF\tHEX$\r\n\tDB\t0\r\nITAB:\r\n\tQ\tINPUT\r\n\tQ\tIF\r\n\tQ\tINSTR\r\n\tQF\tINT\r\n\tQF\tINP\r\n\tQ\tIMP\r\n\tQ\tINKEY$\r\n\tDB\t0\r\nJTAB:\r\n\tDB\t0\r\nKTAB:\r\n\tQ\tKEY\r\n\tDB\t0\r\nLTAB:\r\n\tQ\tLOCATE\r\n\tQ\tLPRINT\r\n\tQ\tLLIST\r\n\tQF\tLPOS\r\n\tQ\tLET\r\n\tQ\tLINE\r\n\tQ\tLOAD\r\n\tQ\tLIST\r\n\tQF\tLOG\r\n\tQF\tLOC\r\n\tQF\tLEN\r\n\tQF\tLEFT$\r\n\tQF\tLOF\r\n\tDB\t0\r\nMTAB:\r\n\tQ\tMOTOR\r\n\tQ\tMERGE\r\n\tQ\tMOD\r\n\tQF\tMID$\r\n\tDB\t0\r\nNTAB:\r\n\tQ\tNEXT\r\n\tQ\tNEW\r\n\tQ\tNOT\r\n\tDB\t0\r\nOTAB:\r\n\tQ\tOPEN\r\n\tQ\tOUT\r\n\tQ\tON\r\n\tQ\tOR\r\n\tQF\tOCT$\r\n\tQ\tOPTION\r\n\tQ\tOFF\r\n\tDB\t0\r\nPTAB:\r\n\tQ\tPRINT\r\n\tQ\tPOKE\r\n\tQF\tPOS\r\n\tQF\tPEEK\r\n\tQ\tPSET\r\n\tQ\tPRESET\r\n\tQ\tPOINT\r\n\tQF\tPEN\r\n\tDB\t0\r\nQTAB:\r\n\tDB\t0\r\nRTAB:\r\n\tQ\tRUN\r\n\tQ\tRETURN\r\n\tQ\tREAD\r\n\tQ\tRESTORE\r\n\tQ\tREM\r\n\tQ\tRESUME\r\n\tQF\tRIGHT$\r\n\tQF\tRND\r\n\tQ\tRENUM\r\n\tQ\tRANDOMIZE\r\n\tDB\t0\r\nSTAB:\r\n\tQ\tSCREEN\r\n\tQ\tSTOP\r\n\tQ\tSWAP\r\n\tQ\tSAVE\r\n\tDB\t\"P\"\r\n\tDB\t\"C\"\r\n\tDB\t\"(\"+128D\r\n\tDB\tOFFSET SPCTK\r\n\tQ\tSTEP\r\n\tQF\tSGN\r\n\tQF\tSQR\r\n\tQF\tSIN\r\n\tQF\tSTR$\r\n\tQ\tSTRING$\r\n\tQF\tSPACE$\r\n\tQ\tSOUND\r\n\tQF\tSTICK\r\n\tQF\tSTRIG\r\n\tDB\t0\r\nTTAB:\r\n\tQ\tTHEN\r\n\tQ\tTRON\r\n\tQ\tTROFF\r\n\tDB\t\"A\"\r\n\tDB\t\"B\"\r\n\tDB\t\"(\"+128D\r\n\tDB\tOFFSET TABTK\r\n\tQ\tTO\r\n\tQF\tTAN\r\n\tDB\t0\r\nUTAB:\r\n\tQ\tUSING\r\n\tQ\tUSR\r\n\tDB\t0\r\nVTAB:\r\n\tQF\tVAL\r\n\tQ\tVARPTR\r\n\tDB\t0\r\nWTAB:\r\n\tQ\tWIDTH\r\n\tQ\tWAIT\r\n\tQ\tWHILE\r\n\tQ\tWEND\r\n\tQ\tWRITE\r\n\tDB\t0\r\nXTAB:\r\n\tQ\tXOR\r\n\tDB\t0\r\nYTAB:\r\n\tDB\t0\r\nZTAB:\r\n\tDB\t0\r\n\r\nPUBLIC\tSPCTAB\r\nSPCTAB:\r\n\tDB\t\"+\"+128D\r\n\tDB\tOFFSET PLUSTK\r\n\tDB\t\"-\"+128D\r\n\tDB\tOFFSET MINUTK\r\n\tDB\t\"*\"+128D\r\n\tDB\tOFFSET MULTK\r\n\tDB\t\"/\"+128D\r\n\tDB\tOFFSET DIVTK\r\n\tDB\t\"^\"+128D\r\n\tDB\tOFFSET EXPTK\r\n\tDB\t\"\\\"+128D\r\n\tDB\tOFFSET IDIVTK\r\n\tDB\t\"'\"+128D\r\n\tDB\tOFFSET SNGQTK\r\n\tDB\t62+128D\r\n\tDB\tOFFSET GREATK\r\n\tDB\t\"=\"+128D\r\n\tDB\tOFFSET EQULTK\r\n\tDB\t60+128D\r\n\tDB\tOFFSET LESSTK\r\n\tDB\t0\r\n\r\n\tSUBTTL  Extended reserved words\r\n;The following are 2 byte tokens, the 1st byte is FE\r\n\r\n\tQQ=128D\r\nSTMDSX:\r\n\tR\tFILES\r\n\tR\tFIELD\r\n\tR\tSYSTEM\r\n\tR\tNAME\r\n\tR\tLSET\r\n\tR\tRSET\r\n\tR\tKILL\r\n\tR\tPUT\r\n\tR\tGET\r\n\tR\tRESET\r\n\tR\tCOMMON\r\n\tR\tCHAIN\r\n\tR2\tDATE$,DATES\r\n\tR2\tTIME$,TIMES\r\n\tR\tPAINT\r\n\tR2\tCOM,COMS\r\n\t$COM2B=0+(400O*376O)+QQ\t;value of COM 2-byte token\r\n\tR\tCIRCLE\r\n\tR\tDRAW\r\n\tR2\tPLAY,PLAYS\r\n\tR\tTIMER\r\n\tR\tERDEV\r\n\tR\tIOCTL\r\n\tR\tCHDIR\r\n\tR\tMKDIR\r\n\tR\tRMDIR\r\n\tR\tSHELL\r\n\tR\tENVIRON\r\n\tR\tVIEW\r\n\tR\tWINDOW\r\n\tR\tPMAP\r\n\tR2\tPALETTE,PALETE\r\n\tR2\tLCOPY,LCOPYS\r\n\tR2\tCALLS,CALLSL\r\n;*************************************************************************\r\n;*** The DEBUG entry should be the last entry in the FE Dispatch table ***\r\n;*************************************************************************\r\n\r\n\r\n\tPAGE\t\r\n;The following are 2 byte tokens, the 1st byte is FD\r\n\r\n\tQQ=128D\r\nFUNDSX:\r\n\tR\tCVI\r\n\tR\tCVS\r\n\tR\tCVD\r\n\tR\tMKI$\r\n\tR\tMKS$\r\n\tR\tMKD$\r\n\tR2\tKTN,KTNFN\r\n\tR2\tJIS,JISFN\r\n\tR2\tKPOS,KPOSFN\r\n\tR2\tKLEN,KLENFN\r\n\r\n\tPAGE\t\r\nPUBLIC\tALPTAX\r\nALPTAX:\r\n\tADR\tATABX\r\n\tADR\tBTABX\r\n\tADR\tCTABX\r\n\tADR\tDTABX\r\n\tADR\tETABX\r\n\tADR\tFTABX\r\n\tADR\tGTABX\r\n\tADR\tHTABX\r\n\tADR\tITABX\r\n\tADR\tJTABX\r\n\tADR\tKTABX\r\n\tADR\tLTABX\r\n\tADR\tMTABX\r\n\tADR\tNTABX\r\n\tADR\tOTABX\r\n\tADR\tPTABX\r\n\tADR\tQTABX\r\n\tADR\tRTABX\r\n\tADR\tSTABX\r\n\tADR\tTTABX\r\n\tADR\tUTABX\r\n\tADR\tVTABX\r\n\tADR\tWTABX\r\n\tADR\tXTABX\r\n\tADR\tYTABX\r\n\tADR\tZTABX\r\n\r\n\tPAGE\t\r\nRESLSX:\r\n\r\nATABX:\r\n\tDB\t0\r\nBTABX:\r\n\tDB\t0\r\nCTABX:\r\n\tQ\tCHAIN\r\n\tQF\tCVI\r\n\tQF\tCVS\r\n\tQF\tCVD\r\n\tQ\tCOMMON\r\n\tQ\tCOM\r\n\tQ\tCIRCLE\r\n\tQ\tCALLS\r\n\tDB\t0\r\nDTABX:\r\n\tQ\tDATE$\r\n\tQ\tDRAW\r\n\tDB\t0\r\nETABX:\r\n\tDB\t0\r\nFTABX:\r\n\tQ\tFIELD\r\n\tQ\tFILES\r\n\tDB\t0\r\nGTABX:\r\n\tQ\tGET\r\n\tDB\t0\r\nHTABX:\r\n\tDB\t0\r\nITABX:\r\n\tQ\tIOCTL\r\n\tDB\t0\r\nJTABX:\r\n\tDB\t0\r\nKTABX:\r\n\tQ\tKILL\r\n\tDB\t0\r\nLTABX:\r\n\tQ\tLSET\r\n\tQ\tLCOPY\r\n\tDB\t0\r\nMTABX:\r\n\tQF\tMKI$\r\n\tQF\tMKS$\r\n\tQF\tMKD$\r\n\tDB\t0\r\nNTABX:\r\n\tQ\tNAME\r\n\tDB\t0\r\nOTABX:\r\n\tDB\t0\r\nPTABX:\r\n\tQ\tPUT\r\n\tQ\tPAINT\r\n\tQ\tPLAY\r\n\tDB\t0\r\nQTABX:\r\n\tDB\t0\r\nRTABX:\r\n\tQ\tRSET\r\n\tQ\tRESET\r\n\tDB\t0\r\nSTABX:\r\n\tQ\tSYSTEM\r\n\tDB\t0\r\nTTABX:\r\n\tQ\tTIME$\r\n\tDB\t0\r\nUTABX:\r\n\tDB\t0\r\nVTABX:\r\n\tDB\t0\r\nWTABX:\r\n\tDB\t0\r\nXTABX:\r\n\tDB\t0\r\nYTABX:\r\n\tDB\t0\r\nZTABX:\r\n\tDB\t0\r\n\r\n\tPUBLIC\tNUMGFN,BOTCON,TOPCON,$RNDFN,$DATCO,$REMCO,NMREL\r\n\tPUBLIC\t$CHRFN,$CSNGF,$CDBLF\r\n\tNUMGFN=(2*MIDTK)-(2*ONEFUN)+1\r\n\tBOTCON=(SQRTK-ONEFUN)*2\r\n\tTOPCON=(ATNTK-ONEFUN)*2+1\r\n\t$RNDFN=$RND-ONEFUN\r\n\t$DATCO=$DATA-\":\"\r\n\t$REMCO=$REM-\":\"\r\n\tNMREL=LESSTK-GREATK+1\r\n\t$CHRFN=$CHR$-ONEFUN\r\n\t$CSNGF=$CSNG-ONEFUN\r\n\t$CDBLF=$CDBL-ONEFUN\r\n\r\n\r\n\tSUBTTL  CRUNCH code to handle extended reserved words\r\n\r\nPUBLIC\tCRUNCX\r\nCRUNCX:\tPOP\tBX\t\t;GET BACK SOURCE POINTER\r\n\tPUSH\tBX\t\t;TO TRY AGAIN\r\n\tDEC\tBX\t\t;POINT AT CHARACTER\r\n\tCALL\tMAKUPL\t\t;CONVERT TO UPPER CASE\r\n\tMOV\tBX,OFFSET ALPTAX\t;GET POINTER TO ALPHA DISPATCH TABLE\r\n\tSUB\tAL,LOW \"A\"\t;SUBTRACT ALPHA OFFSET\r\n\tADD\tAL,AL\t\t;MULTIPLY BY TWO\r\n\tMOV\tCL,AL\t\t;SAVE OFFSET IN [C] FOR DAD.\r\n\tMOV\tCH,LOW 0\t;MAKE HIGH PART OF OFFSET ZERO\r\n\tADD\tBX,CX\t\t;ADD TO TABLE ADDRESS\r\n\tINS86\t56\r\n\tMOV\tDX,[BX]\t\t;GET POINTER IN [D,E]\r\n\tPOP\tBX\t\t;GET BACK SOURCE POINTER\r\nTRYAGA:\tPUSH\tBX\t\t;SAVE TXTPTR TO START OF SEARCH AREA\r\nLOPPSI:\r\n\tCALL\tMAKUPL\t\t;TRANSLATE THIS CHAR TO UPPER CASE\r\n\tMOV\tCL,AL\t\t;SAVE CHAR IN [C]\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tAND\tAL,LOW 127\t;GET RID OF HIGH BIT\r\n\tJNZ\tSHORT ??L000\r\n\tJMP\tNOTRFN\t\t;IF=0 THEN END OF THIS CHARS RESLT\r\n??L000:\r\n\tINC\tBX\t\t;BUMP SOURCE POINTER\r\n\tCMP\tAL,CL\t\t;COMPARE TO CHAR FROM SOURCE LINE\r\n\tJNZ\tSHORT LOPSKP\t;IF NO MATCH, SEARCH FOR NEXT RESWRD\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tINC\tDX\t\t;BUMP RESLST POINTER\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJS\tSHORT ??L001\r\n\tJMP\tLOPPSI\t\t;SEE IF REST OF CHARS MATCH\r\n??L001:\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tCALL\tMAKUPL\t\t;GET NEXT CHAR IN LINE (MC 6/22/80)\r\n\tCMP\tAL,LOW \".\"\t;IS IT A DOT\r\n\tJZ\tSHORT ISVARS\t;YES\r\n\tCALL\tTSTANM\t\t;IS IT A LETTER IMMEDIATELY\r\n\t\t\t\t;FOLLOWING RESWRD\r\nISVARS:\tMOV\tAL,LOW 0\t;SET DONUM TO -1\r\n\tJNAE\tSHORT ??L002\r\n\tJMP\tNOTRFN\t\t;IF ALPHA, CANT BE RESERVED WORD\r\n??L002:\r\n\tPOP\tAX\t\t;GET RID OF SAVED [H,L]\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tPOP\tCX\t\t;GET CHAR COUNT OFF STACK\r\n\tPOP\tDX\t\t;GET DEPOSIT POINTER OFF STACK\r\n\tJNS\tSHORT ??L003\r\n\tJMP\tNOTFNT\t\t;IF MINUS, WASNT FUNCTION TOKEN\r\n??L003:\r\n\tOR\tAL,LOW 200O\t;MAKE HIGH ORDER BIT ONE\r\n\tSTC\t\t\t;AND FORCE LEADER BYTE TO BE 375\r\nNOTFNT:\tPUSH\tAX\t\t;SAVE FN CHAR\r\n\tMOV\tAL,LOW 376O\t;GET BYTE WHICH PRECEEDS FNS\r\n\tSBB\tAL,LOW 0\t;MAKE FUNCTION LEADER 375\r\n\tJMP\tRENCRN\t\t;REENTER CRUNCH WITH NEW RESERVED WORD\r\n\r\nLOPSKP:\tPOP\tBX\t\t;RESTORE UNDEFILED TEXT POINTER\r\nLOPSK2:\r\n\tINS86\t213,362,56,254\t;FETCH FROM CODE SEGMENT\r\n\tINC\tDX\t\t;BUMP RESLST POINTER\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJS\tSHORT ??L004\r\n\tJMP\tLOPSK2\t\t;NOT END OF RESWRD, KEEP SKIPPING\r\n??L004:\r\n\tINC\tDX\t\t;POINT AFTER TOKEN\r\n\tJMP\tTRYAGA\t\t;TRY ANOTHER RESWRD\r\n\r\n\tSUBTTL  LIST code for extended reserved words\r\n\r\nBUFRET:\tRET\t\r\n\r\nNEWFUN:\tMOV\tAL,BYTE PTR [BX]\t;GET FUNCTION NUMBER\r\n\tAND\tAL,LOW 177O\t;TAKE OFF HIGH BIT\r\n\tJMP\tSHORT BUFCON\r\n\r\nPUBLIC\tLISTX\r\nLISTX:\tCMP\tAL,LOW 375O\t;IS IT A NEW FUNCTION\r\n\tJZ\tSHORT NEWFUN\r\n\tCMP\tAL,LOW 376O\t;IS IT A NEW STATEMENT\r\n\tJNZ\tSHORT BUFRET\t;NO, JUST CONTINUE NORMAL PATH\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET NUMBER OF STATEMENT\r\nBUFCON:\tPOP\tBX\t\t;Get rid of the return address.\r\n\tMOV\tBX,OFFSET RESLSX-1\t;GET PTR TO START OF RESERVED WORD LIST\r\n\tMOV\tCH,AL\t\t;SAVE THIS CHAR IN [B]\r\n\tMOV\tCL,LOW OFFSET \"A\"-1\t;INIT LEADING CHAR VALUE\r\nRESSR3:\tINC\tCL\t\t;BUMP LEADING CHAR VALUE.\r\nRESSR1:\tINC\tBX\t\t;BUMP POINTER INTO RESLST\r\nRESSRC:\tMOV\tDH,BH\t\t;SAVE PTR TO START OF THIS RESWRD\r\n\tMOV\tDL,BL\r\nRESSR2:\r\n\tINS86\t56\t\t;FETCH FROM CODE SEGMENT\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR FROM RESLST\r\n\tOR\tAL,AL\t\t;SET CC'S\r\n\tJZ\tSHORT RESSR3\t;IF END OF THIS CHARS TABLE,\r\n\t\t\t\t;GO BACK & BUMP C\r\n\tLAHF\r\n\tINC\tBX\t\t;BUMP SOURCE PTR\r\n\tSAHF\r\n\tJS\tSHORT ??L005\r\n\tJMP\tRESSR2\t\t;IF NOT END OF THIS RESWRD,\r\n??L005:\r\n\t\t\t\t;THEN KEEP LOOKING\r\n\tINS86\t56\t\t;FETCH FROM CODE SEGMENT\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET PTR TO RESERVED WORD VALUE\r\n\tCMP\tAL,CH\t\t;SAME AS THE ONE WE SEARCH FOR?\r\n\tJNZ\tSHORT RESSR1\t;NO, KEEP LOOKING.\r\n\tXCHG\tBX,DX\t\t;SAVE FOUND PTR IN [H,L]\r\n\tMOV\tAL,CL\t\t;GET LEADING CHAR\r\n\tPOP\tDX\t\t;RESTORE LINE CHAR COUNT\r\n\tPOP\tCX\t\t;RESTORE DEPOSIT PTR\r\n\tMOV\tDL,AL\t\t;SAVE LEADING CHAR IN [E]\r\n;\r\n; CODE BELOW NOT NEEDED SINCE NO SPECIAL REVERVED WORDS IN HOOK TABLE\r\n;\r\n;       CPI     \"Z\"+1           ;WAS IT A SPECIAL CHAR?\r\n;       JRNZ    NTSPCH          ;NON-SPECIAL CHAR\r\n;       XRA     A               ;SET NON-SPECIAL\r\n;       STA     TEMPA\r\n;       JMPR    MORPUR          ;PRINT IT\r\nNTSPCH:\tMOV\tAL,BYTE PTR TEMPA\t;WHAT DID WE DO LAST?\r\n\tOR\tAL,AL\t\t;SPECIAL?\r\n\tMOV\tAL,LOW 255\t;FLAG IN RESERVED WORD\r\n\tMOV\tBYTE PTR TEMPA,AL\t;CLEAR FLAG\r\nMORLNZ:\tJZ\tSHORT MORLN0\t;GET CHAR AND PROCEED\r\n\tMOV\tAL,LOW \" \"\t;PUT SPACE IN BUFFER\r\n\tMOV\tDI,CX\r\n\tSTOSB\r\n\tINC\tCX\r\n\tDEC\tDH\t\t;ANY SPACE LEFT IN BUFFER\r\n\tJNZ\tSHORT ??L006\r\n\tJMP\tPPSWRT\t\t;NO, RETURN\r\n??L006:\r\nMORLN0:\tMOV\tAL,DL\r\n\tJMP\tSHORT MORLN1\t;CONTINUE\r\nMORPUR:\r\n\tINS86\t56\t\t;FETCH FROM CODE SEGMENT\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET BYTE FROM RESWRD\r\n\tINC\tBX\t\t;BUMP POINTER\r\nMORLNP:\tMOV\tDL,AL\t\t;SAVE CHAR\r\nMORLN1:\tAND\tAL,LOW 177O\t;AND OFF HIGH ORDER BIT FOR DISK & EDIT\r\n\tMOV\tDI,CX\r\n\tSTOSB\t\t\t;STORE THIS CHAR\r\n\tINC\tCX\t\t;BUMP PTR\r\n\tDEC\tDH\t\t;BUMP DOWN REMAINING CHAR COUNT\r\n\tJNZ\tSHORT ??L007\r\n\tJMP\tPPSWRT\t\t;IF END OF LINE, JUST RETURN\r\n??L007:\r\n\tOR\tAL,DL\t\t;SET CC'S\r\n\tJS\tSHORT ??L008\r\n\tJMP\tMORPUR\t\t;END OF RESWRD?\r\n??L008:\r\n\tPOP\tBX\t\t;RESTORE SOURCE PTR.\r\n\tINC\tBX\t\t;SKIP OVER RESERVED WORD\r\n\tJMP\tPLOOP2\t\t;GET NEXT CHAR FROM LINE\r\n\r\n\tSUBTTL  Extended Statement Dispatching\r\n\r\nSNERRS:\tJMP\tSNERR\r\n\r\nPUBLIC\tNEWSTX\r\nNEWSTX:\tCMP\tAL,LOW OFFSET 376O-201O\t;CHECK FOR NEW STATEMENT PREFIX\r\n\tJZ\tSHORT GONE4\t;IF SO, DISPATCH\r\n\tCMP\tAL,LOW OFFSET 377O-201O\t;FUNCTION?\r\n\tJNZ\tSHORT GIIRET\r\n\tPOP\tCX\t\t;Put return address into B.\r\n\tINC\tBX\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tCMP\tAL,LOW OFFSET $PEN\t; PEN as stmt?\r\n\tJNZ\tSHORT ??L009\r\n\tJMP\tPENV\t\t; Brif so.\r\n??L009:\r\n\tCMP\tAL,LOW OFFSET $STRIG\t;STRIG as stmt?\r\n\tJNZ\tSHORT ??L010\r\n\tJMP\tSTRIGV\t\t; Brif so.\r\n??L010:\r\n\tDEC\tBX\r\n\tMOV\tAL,LOW OFFSET 377O-201O\r\n\tPUSH\tCX\t\t;Put the return address back on.\r\nGIIRET:\tRET\t\t\t;MID$ OR SYNTAX ERROR\r\n\r\nPENV:\tCALL\tCHRGTR\r\n\tJMP\tPENS\r\nSTRIGV:\tCALL\tCHRGTR\r\n\tJMP\tSTRIGS\r\n\r\n\r\nGONE4:\tPOP\tCX\t\t;Get rid of the return address.\r\n\tINC\tBX\t\t;LOOK AT NEXT CHAR\r\n\tMOV\tAL,BYTE PTR [BX]\t;FETCH IT\r\n\tSUB\tAL,LOW 201O\t;GET RELATIVE POSITION IN STMDSX\r\n\tJB\tSHORT SNERRS\t;IF TOO SMALL, SYNTAX ERROR\r\n\tADD\tAL,AL\t\t;TURN BYTE INTO OFFSET\r\n\tINS86\t62,344\t\t;XOR AH,AH\r\n\tINS86\t213,360\t\t;MOV SI,AX - GET OFFSET INTO [SI]\r\n\tINS86\t56\t\t;CODE SEGMENT OVERRIDE\r\n\tINS86\t377,264,STMDSX\t;PUSH STMDSP(SI) - PUSH ADDRESS\r\n\tJMP\tCHRGTR\t\t;START STATEMENT\r\n\r\n\tSUBTTL  EVAL code for extended functions\r\n\r\nPUBLIC\tEVALX\r\nEVALX:\tCMP\tAL,LOW 376O\r\n\tJZ\tSHORT EVALNS\t;Brif possible stmt as function\r\n\tCMP\tAL,LOW 375O\r\n\tJZ\tSHORT EVALNF\t;NEW FUNCTION IF 375 IN FRONT\r\n\tRET\t\r\n\r\nEVALNS:\tINC\tBX\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tCMP\tAL,LOW OFFSET $DATE$\r\n\tJZ\tSHORT DATEV\t;Brif DATE$\r\n\tCMP\tAL,LOW OFFSET $TIME$\r\n\tJZ\tSHORT TIMEV\t;Brif TIME$\r\n\tDEC\tBX\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tRET\t\r\n\r\nDATEV:\tPOP\tCX\t\t;Get rid of the hook return address.\r\n\tJMP\tDATEF\t\t;Do DATE function.\r\n\r\nTIMEV:\tPOP\tCX\t\t;Get rid of the hook return address.\r\n\tJMP\tTIMEF\t\t;Do TIME$ function.\r\n\r\nEVALNF:\tPOP\tCX\t\t;Get rid of the return address.\r\n\tINC\tBX\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tSUB\tAL,LOW 201O\r\n\tMOV\tCH,LOW 0\r\n\tROL\tAL,1\r\n\tMOV\tCL,AL\r\n\tPUSH\tCX\r\n\tCALL\tCHRGTR\r\n\tCALL\tPARCHK\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\r\n\tMOV\tDX,OFFSET LABBCK\r\n\tPUSH\tDX\r\n\tMOV\tAL,LOW 1\r\n\tMOV\tBYTE PTR FLGOVC,AL\r\n\tINS86\t213,363\t\t;MOV SI,BX (GET FUNCTION OFFSET IN SI)\r\n\tINS86\t56\r\n\tINS86\t377,264,FUNDSX\r\n\tRET\t\r\n\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "IBMRES.H",
          "type": "blob",
          "size": 1.232421875,
          "content": "; Include file for IBMRES.ASM\n;\nINCLUDE OEM.H                        ; General definitions\n\n;\n; Reserve word table generating Macros\n;\nun_def  MACRO   RESWRD\n        %OUT +++ Undefined reserved word - &RESWRD\nENDM\n\nT       MACRO   RESWRD\n        QQ=QQ+1\n        PUBLIC  $&RESWRD\n        $&RESWRD=QQ\nENDM\n\nQ       MACRO   RESWRD\n IFDEF  $&RESWRD\n        $F=0\n  IRPC  XX,<RESWRD>\n   IF   $F\n        $Q=\"&XX&\"\n        DB      \"&XX&\"\n   ENDIF        \n   IFE  $F-1\n        .XLIST\n   ENDIF\n        $F=$F+1\n  ENDM\n        .LIST\n        ORG     $-1\n        DB      $Q+128D\n        DB      $&RESWRD\n ELSE\n        un_def  RESWRD\n ENDIF\nENDM\n\nQF      MACRO   RESWRD\n IFDEF  $&RESWRD\n        $F=0\n  IRPC  XX,<RESWRD>\n   IF   $F\n        $Q=\"&XX&\"\n        DB      \"&XX&\"\n   ENDIF        \n   IFE  $F-1\n        .XLIST\n   ENDIF\n        $F=$F+1\n  ENDM\n        .LIST\n        ORG     $-1\n        DB      $Q+128D\n        DB      $&RESWRD-128D\n ELSE\n        un_def  RESWRD\n ENDIF\nENDM\n\n;\nR       MACRO   RESWRD\n        extrn   RESWRD:NEAR\n        DW      RESWRD\n        QQ=QQ+1\n        PUBLIC  $&RESWRD\n        $&RESWRD=QQ\nENDM\n\nR2      MACRO   RESWRD,RESDSP\n        extrn   RESDSP:NEAR\n        DW      RESDSP\n        QQ=QQ+1\n        PUBLIC  $&RESWRD\n        $&RESWRD=QQ\nENDM\n;\nPAGE\n\u001a"
        },
        {
          "name": "ITSA86.ASM",
          "type": "blob",
          "size": 8.5,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   ITSA86 - Resident Initialization for I8086\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- --------- -----------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT CORPORATION\r\n--------- --- ---- -- --------- -----------\r\n\r\n        by Len Oorthuys Microsoft Corp.\r\n        *\r\n\r\n;************************************************************************\r\n;*                                                                      *\r\n;*  NOTE: Any code linked after this module is discarded after          *\r\n;*        Initialization of BASIC.                                      *\r\n;*                                                                      *\r\n;************************************************************************\r\n\r\n\tINCLUDE\tGIO86U\r\n\t.SALL\r\n\r\nCPM86=0\r\nTETRA=0\t\t\t\t;Save DS in DATSEG(defined in CS and\r\n\t\t\t\t;   used by interrupt routine).\r\n\r\n\tINCLUDE\tMSDOSU\r\n\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tTEMP8:WORD,TXTTAB:WORD\r\nDSEG\tENDS\r\n\r\n\tEXTRN\tNODSKS:NEAR,LRUN:NEAR,READY:NEAR\r\n\r\n\tPUBLIC\tWORDS\r\nWORDS:\tDB\t\" Bytes free\"\t;WORDS\r\n\tDB\t0\r\n\r\n\tPAGE\t\r\n\tSUBTTL  INITSA\r\n\tPUBLIC\tINITSA\r\nINITSA:\r\n\tCALL\tNODSKS\r\n\tCALL\tMAPINI\t\t;Init the new memory map\r\n\tMOV\tBX,WORD PTR TXTTAB\r\n\tDEC\tBX\r\n\tMOV\tWORD PTR 0[BX],0D\r\n\tMOV\tBX,WORD PTR TEMP8\t;POINT TO START OF COMMAND LINE\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;GET BYTE POINTED TO\r\n\tOR\tAL,AL\t\t;IF ZERO, NO FILE SEEN\r\n\tJZ\tGREADY\r\n\tJMP\tLRUN\t\t;TRY TO RUN FILE\r\nGREADY:\tJMP\tREADY\r\n\tPAGE\t\r\n;BASVAR - Retrieve or Modify BASIC Internal Data Locations\r\n;This routine provides a method to retrieve or modify certain BASIC internal\r\n;data locations.  This routine is provided as support for PEEK and\r\n;POKE filsters.  These data items have been documented to IBM GW BASIC users\r\n;in the IBM Technical Reference Manual.\r\n;\r\n;Entry - AX = Value to set (if PSW.C set)\r\n;        BX = 0 for current program line number\r\n;             1 for last program line containing an error\r\n;             2 for address of user program text\r\n;             3 for address of user variable table\r\n;        PSW.C set indicates to write the variable\r\n;        PSW.C reset indicates to read the variable\r\n;Exit  - AX = value of appropriate variable\r\n;        BX modified\r\n;\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCURLIN:WORD,ERRLIN:WORD,TXTTAB:WORD,VARTAB:WORD\r\nDSEG\tENDS\r\n\tPUBLIC\tBASVAR\r\nBVTAB:\tDW\tOFFSET CURLIN\r\n\tDW\tOFFSET ERRLIN\r\n\tDW\tOFFSET TXTTAB\r\n\tDW\tOFFSET VARTAB\r\n\r\nBASVAR:\r\n\tPUSHF\t\r\n\tSHL\tBX,1\t\t;make word offset\r\n\tPOPF\t\t\t;preserve PSW.C (input parameter)\r\n\tMOV\tBX,WORD PTR BVTAB[BX]\t;Get address of appropriate variable\r\n\tJNB\tBASVRD\t\t;Performing read function\r\n\tMOV\tWORD PTR 0[BX],AX\t;Perform write function\r\nBASVRD:\tMOV\tAX,WORD PTR 0[BX]\t;Perform read function\r\n\tRET\t\r\n\tPAGE\t\r\n\tSUBTTL  Initialization Support Routines\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tEXTRN\tCSWFLG:WORD,CSWSIZ:WORD,MSWFLG:WORD,MSWSIZ:WORD,NEWDS:WORD\r\n\tEXTRN\tSTKLOW:WORD,MEMSIZ:WORD,TOPMEM:WORD,SAVSEG:WORD,MAXMEM:WORD\r\n\tEXTRN\tFILTAB:WORD\r\n\tEXTRN\tFREFLG:WORD\t;BYTES FREE message flag\r\nDSEG\tENDS\r\n\r\n\tEXTRN\tCLEARC:NEAR,OMERR:NEAR\r\n\tEXTRN\tSETCBF:NEAR\t;OEM Set COM Buf (size & location)\r\n\tEXTRN\tLINPRT:NEAR,STROUT:NEAR,CRDO:NEAR\t;COM\r\n\tEXTRN\tCPMMEM:NEAR\r\n\r\n\r\n\tPUBLIC\tMAPCLC,MAPINI\r\n\r\n;MAPINI - Set up the final memory map.\r\n;Entry  - NEWDS  = final DS:\r\n;         MSWSIZ = final MAXMEM\r\n;Exit   - DS: and stack moved.\r\n;\r\nMAPINI:\r\n;Move the stack to the end of the new memory map\r\n\tPOP\tBX\t\t;Return address\r\n\tCLI\t\t\t;disable external interrupts\r\n\t\t\t\t; while changing memory map\r\n\tMOV\tAX,WORD PTR NEWDS\r\n\tMOV\tSS,AX\r\n\tMOV\tSP,WORD PTR MSWSIZ\t;\r\n\tPUSH\tBX\t\t;Return address\r\n\r\n;Move the data segment\r\n\tMOV\tES,AX\t\t;NEWDS\r\n\tXOR\tSI,SI\r\n\tMOV\tCX,WORD PTR TXTTAB\t;Amount of memory to move\r\n\tSHR\tCX,1\t\t;In words\r\n\tCLD\t\r\n\tMOV\tBX,DS\r\n\tCMP\tAX,BX\t\t;Test for direction of copy\r\n\tJB\tBLKCPY\t\t;brif destination is below source\r\n\tSTD\t\t\t;Copy up\r\n\tMOV\tSI,WORD PTR TXTTAB\t;starting from top\r\nBLKCPY:\r\n\tMOV\tDI,SI\r\n REP\tMOVSW\r\n\r\n;Set new data segment\r\n\tMOV\tDS,AX\t\t;NEWDS\r\n\tEXTRN\tSEGINI:NEAR\r\n\tCALL\tSEGINI\r\n\tMOV\tAX,DS\r\n\tMOV\tWORD PTR SAVSEG,AX\t;For PEEK/POKE\r\n\tSTI\t\t\t;enable external interrupts\r\n\r\n;Insure zeros at TXTTAB\r\n\tMOV\tBX,WORD PTR TXTTAB\r\n\tMOV\tWORD PTR 0[BX],0D\r\n\tMOV\tBYTE PTR 2[BX],LOW 0D\t;Three zeros necessary\r\n\r\n;Call CLEARC to set up stack and finalize the memory map\r\n\tMOV\tAX,WORD PTR MSWSIZ\r\n;Make sure that [TXTTAB]+<stack size>+32 does not overflow memory\r\n\tMOV\tBX,WORD PTR TOPMEM\r\n\tSUB\tBX,WORD PTR STKLOW\t;BX=stack size\r\n\tJBE\tGOMERR\t\t;BRIF illegal stack(0 or less bytes)\r\n\tNEG\tBX\r\n\tADD\tBX,AX\t\t;BX=new stack bottom\r\n\tJNB\tGOMERR\t\t;BRIF MSWSIZ is less than stack size\r\n\tSUB\tBX,32D\t\t;Leave a little room for a program\r\n\tJB\tGOMERR\t\t;BRIF no room left\r\n\tCMP\tBX,WORD PTR TXTTAB\t;Is new MAXMEM big enough?\r\n\tJBE\tGOMERR\t\t;BRIF new MAXMEM smaller than data area\r\nMAXRQ1:\tMOV\tBX,AX\r\n\tSUB\tBX,WORD PTR MAXMEM\t;Calc. seg. size difference\r\n\tMOV\tWORD PTR MAXMEM,AX\t;Memory request\r\n\tADD\tWORD PTR TOPMEM,BX\r\n\tADD\tWORD PTR STKLOW,BX\r\n\tADD\tWORD PTR FILTAB,BX\r\n\tADD\tWORD PTR MEMSIZ,BX\r\n\tPOP\tBX\t\t;Return address (BX saved by CLEARC)\r\n\tCALL\tCLEARC\r\n\tPUSH\tBX\t\t;Return address (BX saved by CLEARC)\r\n\r\n;Set up program segment prefix\r\n\tMOV\tDX,DS\r\n\tMOV\tAH,LOW 38D\t;Function ^H26\r\n\tINT\t33D\t\t;MSDOS function request\r\n\r\n;Print free bytes message\r\n\tTEST\tBYTE PTR FREFLG,LOW 255D\t;BYTES FREE message flag\r\n\tJNZ\tMAPINX\t\t;Exit - message not to be printed\r\n\tMOV\tBX,WORD PTR MEMSIZ\r\n\tSUB\tBX,WORD PTR TXTTAB\r\n\tDEC\tBX\r\n\tDEC\tBX\r\n\tCALL\tLINPRT\t\t;PRINT # OF BYTES FREE\r\n\tMOV\tBX,OFFSET WORDS\t;TYPE THE HEADING\r\n\tCALL\tSTROUT\t\t;\"BYTES FREE\"\r\n\tCALL\tCRDO\t\t;PRINT CARRIAGE RETURN\r\nMAPINX:\tRET\t\r\n\r\nGOMERR:\tJMP\tOMERR\r\n\tPAGE\t\r\n\tSUBTTL  End of the New CS:\r\n\r\n;All code loaded after this label is resident only until routine MAPINI\r\n;initializes the new memory map.\r\n\r\nCSEND:\r\n\r\n;MAPCLC - Calculate the final memory map limits.\r\n;Entry  - CSWFLG = Flag nonzero when /C: option exists\r\n;         CSWSIZ = /C: option size\r\n;         MSWFLG = Flag nonzero when /M: option exists\r\n;         MSWSIZ = /C: option size\r\n;Exit   - NEWDS  = Final DS: address\r\n;         MSWSIZ = Highest memory address (future MAXMEM)\r\n;\r\nMAPCLC:\r\n;Validate/get COM buffer size\r\n\tMOV\tDX,OFFSET CSEND\t;Location of COM buffer (New end of CS:)\r\n\tADD\tDX,15D\t\t;Round to next higher paragraph\r\n\tMOV\tCL,LOW 4D\r\n\tSHR\tDX,CL\r\n\tMOV\tCX,CS\r\n\tADD\tCX,DX\t\t;Segment offset of COM buffer\r\n\tMOV\tDX,WORD PTR CSWSIZ\t;Segment size request\r\n\tTEST\tBYTE PTR CSWFLG,LOW 255D\t;Was there a /C: opt - PSW.Z for SETCBF\r\n\tCALL\tSETCBF\t\t;Report buffer size/loc\r\n\tJB\tGOMERR\t\t; & validate size\r\n\tMOV\tWORD PTR CSWSIZ,DX\t;COM buffer size\r\n\r\n;Calculate NEWDS (New DS:)\r\n; DX  - COM buffer size\r\n; NEWDS = (D+15/16) + DS:\r\n\tADD\tDX,15D\t\t;Round off to paragraph\r\n\tSHR\tDX,1\r\n\tSHR\tDX,1\r\n\tSHR\tDX,1\r\n\tSHR\tDX,1\r\n\tADD\tDX,CX\t\t;Skip COM buffer\r\n\tJO\tGOMERR\r\n\tMOV\tWORD PTR NEWDS,DX\r\n\r\n;Validate the /M option or calculate the maximum possible MAXMEM\r\n;1. Calcualte maximum MAXMEM based on the NEWDS\r\n;2. If there was no /M option then goto 4\r\n;3. Compare /M to the maximum and declare an error if /M is larger\r\n;4. Save the new memory size as MSWSIZ\r\n\tPUSH\tBX\t\t;Save text pointer\r\n\tMOV\tBX,WORD PTR CPMMEM\r\n\tSUB\tBX,DX\t\t;Avail paragraphs\r\n\tJB\tGOMERR\r\n\tMOV\tDX,OFFSET 65535D/16D\t;Max usable paragraphs\r\n\tCMP\tBX,DX\r\n\tJB\tMAXREQ\t\t;More than enough\r\n\tMOV\tBX,DX\r\nMAXREQ:\tMOV\tCL,LOW 4D\r\n\tSHL\tBX,CL\t\t;DX has valid maximum bytes\r\n\tTEST\tBYTE PTR MSWFLG,LOW 255D\r\n\tJZ\tNOMOPT\t\t;No memory option\r\n\tMOV\tDX,WORD PTR MSWSIZ\t;Get /M: size\r\n\tCMP\tBX,DX\r\n\tJB\tGOMERR\t\t;Not enough for request\r\n\tMOV\tBX,DX\r\nNOMOPT:\tMOV\tWORD PTR MSWSIZ,BX\t;New MAXMEM\r\n;       ADDI    BX,^D256\r\n;       JB      MAXRQ1                  ;BRIF very large MAXMEM, value OK\r\n;       CMP     BX,TXTTAB               ;Is new MAXMEM big enough?\r\n;       JBE     GOMERR                  ;BRIF new MAXMEM smaller than data area\r\n\tPOP\tBX\r\n\tRET\t\r\n\r\n;SEGOFF     Convert end of memory segment to offset from current DS\r\n;\r\n;   On entry:   BX=last segment in memory\r\n;               DS=current data segment\r\n;\r\n;   On exit:    BX=offset from current segment to paragraph specified by BX\r\n;               Other registers unchanged, flags modified\r\n;\r\n\tPUBLIC\tSEGOFF\r\n\tEXTRN\tOMERR:NEAR\r\n\r\nSEGOFF:\tPUSH\tCX\r\n\tMOV\tCX,DS\r\n\tSUB\tBX,CX\t\t;[BX]=number of paragraphs free for DSEG\r\n\tJBE\tSGOFER\t\t;BRIF last segment is less than current\r\n\tMOV\tCX,7777O\t;[CX]=max num of paragraphs BASIC could use\r\n\tCMP\tBX,CX\r\n\tJBE\tLESS64\t\t;Brif less than 64k bytes available\r\n\tMOV\tBX,CX\t\t;don't need more than 64k bytes\r\nLESS64:\r\n\tMOV\tCL,LOW 4\r\n\tSHL\tBX,CL\t\t;convert paragraphs to bytes\r\n\tPOP\tCX\t\t;restore caller's CX\r\n\tRET\t\r\nSGOFER:\tJMP\tOMERR\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "KANJ86.ASM",
          "type": "blob",
          "size": 0.75,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   KANJ86 - KANJI String Function Support for Basic-86\r\n\r\nCOMMENT\t*\r\n\r\n--------- --- ---- -- ---------\r\nCOPYRIGHT (C) 1982 BY MICROSOFT\r\n--------- --- ---- -- ---------\r\n\r\n        Author: Tom Corbett - Microsoft Inc.  -  April 28, 1982\r\n\r\n        *\r\n\tINCLUDE\tGIO86U\t\t;contains DB definition\r\n\t.SALL\r\n\r\n\tINCLUDE\tMSDOSU\r\nIF\tCPM86  \r\n\tINCLUDE\tCPM86U\r\nENDIF \r\n\r\n\r\nPUBLIC\tKTNFN\r\nKTNFN:\r\nPUBLIC\tJISFN\r\nJISFN:\r\nPUBLIC\tKLENFN\r\nKLENFN:\r\nPUBLIC\tKPOSFN\r\nKPOSFN:\r\n\tEXTRN\tSNERR:NEAR\r\n\tJMP\tSNERR\r\n\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.134765625,
          "content": "    MIT License\r\n\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission is hereby granted, free of charge, to any person obtaining a copy\r\n    of this software and associated documentation files (the \"Software\"), to deal\r\n    in the Software without restriction, including without limitation the rights\r\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n    copies of the Software, and to permit persons to whom the Software is\r\n    furnished to do so, subject to the following conditions:\r\n\r\n    The above copyright notice and this permission notice shall be included in all\r\n    copies or substantial portions of the Software.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n    SOFTWARE\r\n"
        },
        {
          "name": "MACLNG.ASM",
          "type": "blob",
          "size": 6.375,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   MACLNG - MACRO LANGUAGE DRIVER\r\n;\r\n; MICROSOFT GRAPHICS AND SOUND MACRO LANGUAGES\r\n;\r\nTSHIBA=0\r\nALPCPM=0\r\n\r\n\r\n\r\n\tPUBLIC\tFETCHR,FETCHZ,DECFET\r\n\tPUBLIC\tVALSCN,VALSC2,VARGET,NEGD\r\n\r\n\tEXTRN\tFCERR:NEAR,FRESTR:NEAR,FRCINT:NEAR,FRMEVL:NEAR,ISVAR:NEAR\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tMCLLEN:WORD,MCLPTR:WORD,BUF:WORD,MCLTAB:WORD\r\nDSEG\tENDS\r\n\r\n\tPUBLIC\tMACLNG,MCLXEQ\r\n\tEXTRN\tGETBCD:NEAR\r\n\r\nMACLNG:\tMOV\tMCLTAB,DX\t;SAVE POINTER TO COMMAND TABLE\r\n\tCALL\tFRMEVL\t\t;EVALUATE STRING ARGUMENT\r\n\tPUSH\tBX\t\t;SAVE TXTPTR TILL DONE\r\n\tMOV\tDX,0\t\t;PUSH DUMMY ENTRY TO MARK END OF STK\r\n\tPUSH\tDX\t\t;DUMMY ADDR\r\n\tPUSH\tAX\t\t;DUMMY LENGTH\r\n\r\nMCLNEW:\tCALL\tFRESTR\r\n\tCALL\tGETBCD\t\t;GET LENGTH & POINTER\r\n\tMOV\tAL,CH\r\n\tOR\tAL,CL\r\n\tJZ\tSHORT MCLOOP\t;Don't Push if addr is 0\r\n\tMOV\tAL,DH\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT MCLOOP\t; or if Len is 0...\r\n\tPUSH\tCX\t\t;PUSH ADDR OF STRING\r\n\tMOV\tAL,DH\t\t;PUT IN [AL]\r\n\tPUSH\tAX\r\n\r\nMCLOOP:\tPOP\tAX\t\t;GET LENGTH OFF STACK\r\n\tMOV\tBYTE PTR MCLLEN,AL\r\n\tPOP\tBX\t\t;GET ADDR\r\n\tOR\tBX,BX\t\t;SEE IF LAST ENTRY\r\n\tJNZ\tSHORT ??L000\r\n\tJMP\tPOPTRT\r\n??L000:\t\t\t\t;ALL FINISHED IF ZERO\r\n\tMOV\tMCLPTR,BX\t;SET UP POINTER\r\n\r\nMCLSCN:\tCALL\tFETCHR\t\t;GET A CHAR FROM STRING\r\n\tJZ\tSHORT MCLOOP\t;END OF STRING - SEE IF MORE ON STK\r\n\tADD\tAL,AL\t\t;PUT CHAR * 2 INTO [C]\r\n\tMOV\tCL,AL\r\n\tMOV\tBX,MCLTAB\t;POINT TO COMMAND TABLE\r\nMSCNLP:\r\n\tINS86\t56\t\t;CS OVERRIDE\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHAR FROM COMMAND TABLE\r\n\tADD\tAL,AL\t\t;CHAR = CHAR * 2 (CLR HI BIT FOR CMP)\r\nGOFCER:\tJNZ\tSHORT ??L001\r\n\tCALL\tFCERR\t\t;END OF TABLE.\r\n??L001:\r\n\tCMP\tAL,CL\t\t;HAVE WE GOT IT?\r\n\tJZ\tSHORT MISCMD\t;YES.\r\n\tINC\tBX\t\t;MOVE TO NEXT ENTRY\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tJMP\tSHORT MSCNLP\r\n\r\nMISCMD:\r\n\tMOV\tCX,OFFSET MCLSCN\t;RETURN TO TOP OF LOOP WHEN DONE\r\n\tPUSH\tCX\r\n\tINS86\t56\t\t;CS OVERRIDE\r\n\tMOV\tAL,BYTE PTR [BX]\t;SEE IF A VALUE NEEDED\r\n\tMOV\tCL,AL\t\t;PASS GOTTEN CHAR IN [C]\r\n\tADD\tAL,AL\r\n\tJAE\tSHORT MNOARG\t;COMMAND DOESN'T REQUIRE ARGUMENT\r\n\tOR\tAL,AL\t\t;CLEAR CARRY\r\n\tRCR\tAL,1\t\t;MAKE IT A CHAR AGAIN\r\n\tMOV\tCL,AL\t\t;PUT IN [C]\r\n\tPUSH\tCX\r\n\tPUSH\tBX\t\t;SAVE PTR INTO CMD TABLE\r\n\tCALL\tFETCHR\t\t;GET A CHAR\r\n\tMOV\tDX,1\t\t;DEFAULT ARG=1\r\n\tJNZ\tSHORT ??L002\r\n\tJMP\tVSNAR0\t\t;NO ARG IF END OF STRING\r\n??L002:\r\n\tCALL\tISLET2\t\t;SEE IF POSSIBLE LETTER\r\n\tJNAE\tSHORT ??L003\r\n\tJMP\tVSNARG\r\n??L003:\r\n\tCALL\tVALSC3\t\t;GET THE VALUE\r\n\tSTC\t\t\t;SET CARRY TO FLAG USING NON-DEFAULT\r\n\tJMP\tSHORT ISCMD3\r\nVSNARG:\tCALL\tDECFET\t\t;PUT CHAR BACK INTO STRING\r\nVSNAR0:\tOR\tAL,AL\t\t;CLEAR CARRY\r\nISCMD3:\tPOP\tBX\r\n\tPOP\tCX\t\t;GET BACK COMMAND CHAR\r\nMNOARG:\tINC\tBX\t\t;POINT TO DISPATCH ADDR\r\n\tINS86\t56\t\t;CS OVERRIDE\r\n\tMOV\tBX,[BX]\t\t;GET ADDRESS INTO HL\r\n\tJMP\tBX\t\t;DISPATCH\r\n\r\nFETCHZ:\tCALL\tFETCHR\t\t;GET A CHAR FROM STRING\r\n\tJZ\tSHORT GOFCER\t;GIVE ERROR IF END OF LINE\r\n\tRET\t\r\n\r\nFETCHR:\tPUSH\tBX\r\nFETCH2:\tMOV\tBX,OFFSET MCLLEN\t;POINT TO STRING LENGTH\r\n\tMOV\tAL,BYTE PTR [BX]\r\n\tOR\tAL,AL\r\n\tJZ\tSHORT POPTRT\t;RETURN Z=0 IF END OF STRING\r\n\tDEC\tBYTE PTR [BX]\t;UPDATE COUNT FOR NEXT TIME\r\n\tMOV\tBX,MCLPTR\t;GET PTR TO STRING\r\n\tMOV\tAL,BYTE PTR [BX]\t;GET CHARACTER FROM STRING\r\n\tINC\tBX\t\t;UPDATE PTR FOR NEXT TIME\r\n\tMOV\tMCLPTR,BX\r\n\tCMP\tAL,LOW \" \"\t;SKIP SPACES\r\n\tJZ\tSHORT FETCH2\r\n\tCMP\tAL,LOW 96D\t;CONVERT LOWER CASE TO UPPER\r\n\tJB\tSHORT POPTRT\r\n\tSUB\tAL,LOW 32D\t;DO CONVERSION\r\nPOPTRT:\tPOP\tBX\r\n\tRET\t\r\n\r\nDECFET:\tPUSH\tBX\r\n\tMOV\tBX,OFFSET MCLLEN\t;INCREMENT LENGTH\r\n\tINC\tBYTE PTR [BX]\r\n\tMOV\tBX,MCLPTR\t;BACK UP POINTER\r\n\tDEC\tBX\r\n\tMOV\tMCLPTR,BX\r\n\tPOP\tBX\r\n\tRET\t\r\n\r\nVALSCN:\tCALL\tFETCHZ\t\t;GET FIRST CHAR OF ARGUMENT\r\nVALSC3:\tCMP\tAL,LOW \"=\"\t;NUMERIC?\r\n\tJNZ\tSHORT ??L004\r\n\tJMP\tVARGET\r\n??L004:\r\n\tCMP\tAL,LOW \"+\"\t;PLUS SIGN?\r\n\tJZ\tSHORT VALSCN\t;THEN SKIP IT\r\n\tCMP\tAL,LOW \"-\"\t;NEGATIVE VALUE?\r\n\tJNZ\tSHORT VALSC2\r\n\tMOV\tDX,OFFSET NEGD\t;IF SO, NEGATE BEFORE RETURNING\r\n\tPUSH\tDX\r\n\tJMP\tSHORT VALSCN\t;EAT THE \"-\"\r\nVALSC2:\r\n\tMOV\tDX,0\t\t;INITIAL VALUE OF ZERO\r\nNUMLOP:\r\n\tCMP\tAL,LOW 54O\t;COMMA\r\n\tJZ\tSHORT DECFET\t;YES, BACK UP AND RETURN\r\n\tCMP\tAL,LOW 73O\t;SEMICOLON?\r\n\tJNZ\tSHORT $+3\r\n\tRET\t\t\t;YES, JUST RETURN\r\n\tCMP\tAL,LOW OFFSET \"9\"+1\t;NOW SEE IF ITS A DIGIT\r\n\tJAE\tSHORT DECFET\t;IF NOT, BACK UP AND RETURN\r\n\tCMP\tAL,LOW \"0\"\r\n\tJB\tSHORT DECFET\r\n\tMOV\tBX,0\t\t;[HL] is accumulator\r\n\tMOV\tCH,LOW 10D\t;[HL]=[DE]*10\r\nNUML01:\tADD\tBX,DX\r\n\tJB\tSHORT SCNFC\t;overflow - JMP Function Call Error\r\n\tDEC\tCH\r\n\tJNZ\tSHORT NUML01\r\n\tSUB\tAL,LOW \"0\"\t;ADD IN THE DIGIT\r\n\tMOV\tDL,AL\r\n\tMOV\tDH,LOW 0\r\n\tADD\tBX,DX\r\n\tJB\tSHORT SCNFC\t;overflow - JMP Function Call Error\r\n\tXCHG\tBX,DX\t\t;VALUE SHOULD BE IN [DE]\r\n\tCALL\tFETCHR\t\t;GET NEXT CHAR\r\n\tJNZ\tSHORT NUMLOP\t;branch if not end of string\r\n\tRET\t\r\n\r\n\r\nSCNVAR:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tVALTYP:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tRETVAR:NEAR\r\n;Allow VARPTR$(variable) for BASCOM compatibility\r\n;\r\n\tMOV\tBX,MCLPTR\t;Get string pntr\r\n\tMOV\tAL,BYTE PTR [BX]\t;possible VALTYP if string created by VARPTR$\r\n\tCMP\tAL,LOW 9D\t;If .gt. 8 then not VARPTR$ string\r\n\tJAE\tSHORT SCNVR2\t;Brif not VARPTR$ candidate\r\n\tMOV\tAL,BYTE PTR MCLLEN\t;Get str len\r\n\tSUB\tAL,LOW 3D\t;at least 3 bytes if it was created by VARPTR$\r\n\tJB\tSHORT SCNVR2\t;else let SCNVAR generate FCERR for bad var name\r\n\tMOV\tBYTE PTR MCLLEN,AL\t;len -3\r\n\tMOV\tAL,BYTE PTR [BX]\t;assume Byte 1 is Type\r\n\tMOV\tBYTE PTR VALTYP,AL\t;so store in FAC\r\n\tINC\tBX\r\n\tMOV\tDL,BYTE PTR [BX]\r\n\tINC\tBX\r\n\tMOV\tDH,BYTE PTR [BX]\t;[DE] = Var address.\r\n\tINC\tBX\r\n\tMOV\tMCLPTR,BX\t;New pntr\r\n\tJMP\tRETVAR\t\t;Go return value in FAC\r\nSCNVR2:\r\n\tCALL\tFETCHZ\t\t;MAKE SURE FIRST CHAR IS LETTER\r\n\tMOV\tDX,OFFSET BUF\t;PLACE TO COPY NAME FOR PTRGET\r\n\tPUSH\tDX\t\t;SAVE ADDR OF BUF FOR \"ISVAR\"\r\n\tMOV\tCH,LOW 40D\t;COPY MAX OF 40 CHARACTERS\r\n\tCALL\tISLET2\t\t;MAKE SURE IT'S A LETTER\r\n\tJB\tSHORT SCNFC\t;FC ERROR IF NOT LETTER\r\n\r\nSCNVLP:\tMOV\tDI,DX\r\n\tSTOSB\t\t\t;STORE CHAR IN BUF\r\n\tINC\tDX\r\n\tCMP\tAL,LOW 73O\t;A SEMICOLON?\r\n\tJZ\tSHORT SCNV2\t;YES - END OF VARIABLE NAME\r\n\tCALL\tFETCHZ\t\t;GET NEXT CHAR\r\n\tDEC\tCH\r\n\tJNZ\tSHORT SCNVLP\r\n\r\nSCNFC:\tCALL\tFCERR\t\t;ERROR - VARIABLE TOO LONG\r\nSCNV2:\tPOP\tBX\t\t;GET PTR TO BUF\r\n\tJMP\tISVAR\t\t;GO GET ITS VALUE\r\n\r\nVARGET:\tCALL\tSCNVAR\t\t;SCAN & EVALUATE VARIABLE\r\n\tCALL\tFRCINT\t\t;MAKE IT AN INTEGER\r\n\tXCHG\tBX,DX\t\t;IN [DE]\r\n\tRET\t\r\n\r\n\tEXTRN\tGETSTK:NEAR\r\nMCLXEQ:\tCALL\tSCNVAR\t\t;SCAN VARIABLE NAME\r\n\tMOV\tAL,BYTE PTR MCLLEN\t;SAVE CURRENT STRING POS & LENGTH\r\n\tMOV\tBX,MCLPTR\r\n\tPOP\tSI\t\t;XTHL\r\n\tXCHG\tSI,BX\r\n\tPUSH\tSI\t\t;POP OFF RET ADDR, PUSH MCLPTR\r\n\tPUSH\tAX\r\n\tMOV\tCL,LOW 2\t;MAKE SURE OF ROOM ON STACK\r\n\tCALL\tGETSTK\r\n\tJMP\tMCLNEW\r\n\r\nNEGD:\r\n\tINS86\t367,332\t\t;NEG DX,DX\r\n\tRET\t\r\n\r\nISLET2:\tCMP\tAL,LOW \"A\"\r\n\tJB\tSHORT ISLETX\t;TOO SMALL FOR LETTER\r\n\tCMP\tAL,LOW OFFSET \"Z\"+1\r\n\tCMC\t\t\t;SET CARRY IF NOT LETTER\r\nISLETX:\tRET\t\r\n\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "MATH1.ASM",
          "type": "blob",
          "size": 115.125,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX\t8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG'\r\n\tASSUME\tCS:CSEG\r\n\r\nINCLUDE OEM.H\r\n\r\n\tTITLE MATH86 8086 MATH PACK\r\n\r\n\t.SALL\r\n\t.RADIX\t8\r\n\r\nSIXDIG=0\t\t\t;Floating pnt output 6 bit S.P. numbers\r\n\r\n\tPUBLIC\tABSFN,ATN,COS,DADD\r\n\tPUBLIC\tDDIV,DMULT,EXP,FINDBL,FIN,FOUT,FRCDBL\r\n\tPUBLIC\tFRCINT,FRCSNG,INEG,INEG2,INT,LOG,LOPFND,NEG\r\n\tPUBLIC\tPUFOUT,RND,SIGN,SIN,SQR,TAN\r\n\tPUBLIC\tVALINT,VINT,VNEG,ZERO,$CDS,$CSD,$CSI\r\n\tPUBLIC\t$DCMPA,$DIV0S,$DZERO,$EXPCN,$FADDS,$FCOMP,$FDIVS\r\n\tPUBLIC\t$FI,$FLT,$FMULS,$FOUTH,$FOUTO,$FOUT2,$FPWR\r\n\tPUBLIC\t$FSUBD,$FSUBS,$FS,$GETYP,$LOGP,$MOVFA,$MOVFM\r\n\tPUBLIC\t$MOVFR,$MOVMF,$MOVRF,$NEG,$NORMD,$NORMS,$POPA\r\n\tPUBLIC\t$SIGNS,$VINT,$VPSHF\r\n\r\n\tPUBLIC\tSIGNS,DCXBRT,FADD,VSIGN,MOVFR,ISIGN,INEG2\r\n\tPUBLIC\tIMOD,GETBCD,ISUB,FPWRQ,INRART,MOVRF,DCOMP\r\n\tPUBLIC\tVDFACS,MOVFM,FDIVT,ICOMP,VMOVAF,UMULT,FOUTH,FSUB\r\n\tPUBLIC\tICMPA,VMOVFA,IDIV,VMOVFM,IMULT,RNDMN2,BLTU,FMULT\r\n\tPUBLIC\tFRCSTR,POPHRT,MOVE,MOVMF,CONIA,VMOVE,RNDMON,CHKSTR\r\n\tPUBLIC\tLOPFD1,INPRT,MAKINT,FDIV,SGN,SIGNC,FCOMP,INXHRT\r\n\tPUBLIC\tIADD,FOUTO,DSUB,VALSNG,BLTUC,FIXER,MOVRM\r\n\tPUBLIC\tFADDS,LINPRT,MOVE1,CONSIH,PUSHF,VMOVMF\r\n\r\n\tPUBLIC\tSTROUT\r\n\tEXTRN\tCRFIN:NEAR,OUTDO:NEAR\r\n\r\n\r\n\tEXTRN\tARYEXT:NEAR,BSERR:NEAR,CHRGTR:NEAR,DV0ERR:NEAR,FRQINT:NEAR\r\n\tEXTRN\tINTXT:NEAR,NOTFDD:NEAR,NOTFNS:NEAR,OVERR:NEAR\r\n\tEXTRN\tREASON:NEAR,STROUI:NEAR,TMERR:NEAR\r\n\tEXTRN\t$CATTY:NEAR,$CLROV:NEAR,$DIV0M:NEAR,$FLGOC:NEAR\r\n\tEXTRN\t$OHCNS:NEAR,$OVERR:NEAR,$OVMSG:NEAR,$FCERR:NEAR\r\n\tEXTRN\t$SNERR:NEAR,$STPRN:NEAR,$TMERR:NEAR\r\n\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tARYTA2:WORD,NAMBUF:WORD,NAMCNT:WORD,ONELIN:WORD\r\n\tEXTRN\tSTREND:WORD,TEMP3:WORD,VALTYP:WORD\r\n\tEXTRN\t$ARG:WORD,$ARGLO:WORD,$DBUFF:WORD,$DFACL:WORD\r\n\tEXTRN\t$DPADR:WORD,$FAC:WORD,$FACLO:WORD,$FACM1:WORD,$FBUFF:WORD\r\n\tEXTRN\t$FLGOV:WORD,$FMTAL:WORD,$FMTAX:WORD,$FMTCX:WORD,$RNDX:WORD\r\n\tEXTRN\t$VALTP:WORD,$ZLO:WORD,$Z1LO:WORD,$Z1:WORD\r\nDSEG\tENDS\r\n\r\n\r\n\tSUBTTL\t $FOTCI  CONVERT INTEGER IN (FACLO) TO ASCII DIGITS\r\n;*************************************************************\r\n;\r\n;       $FOTCI  CONVERT THE INTEGER IN (FACLO)-TWO BYTES TO\r\n;               ASCII DIGITS.\r\n;       CALLING SEQUENCE:       CALL    $FOTCI\r\n;               WITH DECIMAL POINT AND COMMA COUNTS IN (CX)\r\n;       $FOUTO  CONVERT INTEGER IN $FACLO:FACLO+1 TO OCTAL\r\n;       $FOUTH  CONVERT INTEGER IN $FACLO:FACLO+1 TO HEXIDECIMAL\r\n;       CALLING SEQUENCE:       CALL    $FOUTO/$FOUTH\r\n;               WITH $FACLO:FACLO+1 CONTAINING INTEGER TO BE\r\n;               PRINTED. RETURNS WITH (BX) POINTING TO $FBUFF\r\n;\r\n;**************************************************************\r\n\tPUBLIC\t$FOTCI\r\n$FOTCI: MOV\tAH,LOW 5\t;MAX DIGITS TO CONVERT\r\n\tMOV\tBP,OFFSET $FOITB\r\n$FCI4:\t\t\t\t;ENTRY FOR FOTCV SO WE WILL ONLY CONVERT 4 DIGITS\r\nFCI10:\tCALL\t$FOTED\t\t;CHECK FOR NEEDED D.P. OR \",\"\r\n\t\t\t\t;TABLE IN CODE SEGMENT\r\n\tMOV\tDX,WORD PTR CS:0[BP]\t;FETCH POWER OF TEN TO DX\r\n\tINC\tBP\t\t;POINT (BP) TO NEXT PWR 10\r\n\tINC\tBP\r\n\tMOV\tSI,WORD PTR $FACLO\t;FETCH INTEGER TO BE CONVERTED\r\n\tMOV\tAL,LOW OFFSET \"0\"-1     ;WILL BUILD DIGIT IN (AL)\r\nFCI20:\tINC\tAL\r\n\tSUB\tSI,DX\t\t;SUBTRACT OUT POWER OF TEN\r\n\tJNB\tFCI20\t\t;CONTINUE UNTIL DIGIT FORMED\r\n\tADD\tSI,DX\t\t;SUBTRACTED OUT ONE TOO MANY\r\n\tMOV\tBYTE PTR 0[BX],AL\t;MOVE DIGIT TO BUFFER\r\n\tINC\tBX\t\t;POINT (BX) TO NEXT BUFF POS.\r\n\tMOV\tWORD PTR $FACLO,SI\t;SAVE UPDATED INTEGER\r\n\tDEC\tAH\t\t;LOOP TILL DIGITS FORMED\r\n\tJNZ\tFCI10\r\n\tCALL\t$FOTED\t\t;SEE IF DECIMAL POINT NEEDED\r\n\tMOV\tBYTE PTR 0[BX],LOW 0\t;AND PUT BINARY\r\n\tRET\t\t\t;ZERO AFTER.\r\n$FOUTO:\t\t\t;OCTAL OUTPUT OF INTEGER IN $FACLO:FACLO+1\r\n\tMOV\tCX,OFFSET 3*400+1\t;WILL PROCESS 3 BITS AT A TIME\r\n\tMOV\tSI,6\t\t;OCTAL DIGITS\r\n\tJMP\tSHORT FTH10\r\n$FOUTH:\t\t\t;HEXIDECIMAL OUTPUT OF INTEGER IN FACLO:FACLO+1\r\n\tMOV\tCX,OFFSET 4*400+4\t;WILL PROCESS 4 BITS AT A TIME\r\n\tMOV\tSI,4\t\t;HEX DIGITS\r\nFTH10:\tMOV\tDI,OFFSET $FBUFF\t;POINT DI TO OUTPUT LOCATION\r\n\tCLD\t\t\t;SO SUBSEQUENT STOC WILL INC\r\n\tMOV\tBX,OFFSET $NUMB\r\n\tMOV\tDX,WORD PTR $FACLO\t;FETCH INTEGER\r\n\tPUSH\tSI\t\t;SAVE FOR ZERO SUPPRESS CODE\r\nFTH20:\tMOV\tAL,DH\t\t;GET INTEGER\r\n\tXOR\tAH,AH\t\t;CLEAR UPPER AX\r\n\tSHL\tAX,CL\t\t;SHIFT HIGH ORDER BITS INTO AH\r\n\tXCHG\tAH,AL\t\t;NOW IN AL\r\n\t\t\t\t;LOOK FROM CODE SEGMENT\r\n?CSLAB:\t\t\t; Code segment dummy label\r\n\tXLAT\tBYTE PTR ?CSLAB ;LOOK-UP ASCII\r\n\tSTOSB\r\n\tSHL\tDX,CL\t\t;SHIFT NUMBER\r\n\tMOV\tCL,CH\t\t;GET NO. BITS TO SHIFT\r\n\tDEC\tSI\t\t;DECREMENT NO. OF DIGITS\r\n\tJNZ\tFTH20\r\n\tMOV\tBYTE PTR 0[DI],LOW 0\t;DENOTE END OF NO.\r\n\tMOV\tBX,OFFSET $FBUFF\r\n\tPOP\tCX\t\t;RECALL FOR ZERO SUPPRESS\r\n\tDEC\tCL\t\t;CAN'T DELETE ALL THE ZEROS\r\nFTH40:\tCMP\tBYTE PTR 0[BX],LOW \"0\"  ;DO ZERO SUPPRESS\r\n\tJNZ\tFTH50\t\t;NO MORE SUPPRESS\r\n\tINC\tBX\r\n\tLOOP\tFTH40\r\nFTH50:\tRET\r\n\r\n\tSUBTTL\t $PUFXE  PRINT USING FIX-UP CODE\r\n;****************************************************************\r\n;\r\n;       $PUFXE  THIS CODE IS CALLED ONCE PRINT-USING ROUTINES\r\n;               HAVE BUILT THE NUMBER IN THE OUTPUT BUFFER (FBUFF)\r\n;               ITS JOB IS TO ASSURE THE NUMBER MEETS OUTPUT\r\n;               SPECIFICATIONS. IF THE NUMBER TRULY OVERFLOWS THE\r\n;               OUTPUT BUFFER A \"%\" SIGN WILL BE INSERTED AS THE\r\n;               LEADING CHARACTER.\r\n;       CALLING SEQUENCE:       CALL    $PUFXE\r\n;               WITH $FBUFF CONTAINING THE FORMATTED NUMBER\r\n;\r\n;*****************************************************************\r\n\r\n\tCURNCY=\"$\"\t      ;Default floating currency is dollars.\r\n$PUFXE: PUSH\tBX\t\t;SAVE END OF BUFFER POINTER\r\n\tCALL\t$FOTZS\t\t;DO ZERO SUPPRESSION\r\n\t\t\t\t;$FOTZS WILL LEAVE ZF=0 IF THERE IS\r\n\t\t\t\t;TO BE A TRAILING SIGN AND THE SIGN\r\n\t\t\t\t;WILL BE LEFT IN (CH)\r\n\tPOP\tBX\t\t;RECALL END-OF-BUFFER POINTER\r\n\tJZ\tPFX10\t\t;IF NO TRAILING SIGN PROCEED\r\n\tMOV\tBYTE PTR 0[BX],CH\t;PUT IN TRAILING SIGN\r\n\tINC\tBX\t\t;MUST NOW PUT IN BINARY ZERO\r\nPFX10:\tMOV\tBYTE PTR 0[BX],LOW 0\t;TO SIGNIFY END OF PRINT\r\n\tMOV\tBX,OFFSET $FBUFF\t;FETCH START OF BUFFER ADDRESS\r\nPFX20:\tINC\tBX\t\t;INCREMENT (BX) TO NEXT BUFFER POSITION\r\nPFX30:\tMOV\tDI,WORD PTR $DPADR\t;GET DECIMAL POINT ADDRESS\r\n\tMOV\tDX,WORD PTR $FMTCX\t;FETCH DECIMAL POINT INFO.\r\n\tMOV\tAL,BYTE PTR $FMTCX+1\t;FETCH NO. DIGITS TO LEFT OF D.P.\r\n\tXOR\tAH,AH\t\t;(AX) = DIGITS LEFT OF DECIMAL POINT\r\n\tSUB\tDI,BX\t\t;WILL FORM THE SUBTRACTION:\r\n\tSUB\tDI,AX\t\t;D.P. ADDR.-BUFF PTR-DIGITS LEFT OF D.P\r\n\tJZ\tPFX90\t\t;RETURN IF ALL IS OK.\r\n;********************************************************************\r\n;FIELD IS CURRENTLY TOO LARGE. WE CAN SHORTEN THE FIELD BY ELIMINATING\r\n;LEADING \" \" AND \"*\" CHARACTERS AND A LEADING \"0\" IF THE CHARACTER\r\n;FOLLOWING THE DECIMAL POINT IS A NUMERIC DIGIT. DOING THIS ANALYSIS\r\n;WILL BE WHAT THE FOLLOWING SONG & DANCE IS ALL ABOUT\r\n;THE INCREMENT OF (BX) AT PFX20 IN EFFECT SHORTENS THE FIELD BECAUSE\r\n;(BX) WILL POINT TO THE STARTING LOCATION FOR PRINTOUT UPON RETURN\r\n;FROM THIS ROUTINE.\r\n;******************************************************************\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;FETCH NEXT CHARACTER IN BUFFER\r\n\tCMP\tAL,LOW \" \"      ;SPACE?\r\n\tJZ\tPFX20\t\t;IF SO ELIMINATE AND SEE IF NOW OK\r\n\tCMP\tAL,LOW \"*\"      ;IF ASTERISK FILL THEN ASTERISK?\r\n\tJZ\tPFX20\r\n\tMOV\tAH,LOW 1\t;TO SIGNAL END OF CHARACTERS IN\r\n\t\t\t\t;THE FOLLOWING CODE\r\n\tDEC\tBX\t\t;BECAUSE $CHRGT WILL DO INC BX FIRST\r\n\tPUSH\tBX\t\t;SAVE THIS LOCATION FOR POSSIBLE \"%\"\r\nPFX40:\tPUSH\tAX\r\n\tCALL\t$CHRGT\t\t;GET NEXT CHARACTER( NOTE THAT THIS\r\n\t\t\t\t;RE-FETCHES THE PREVIOUS FAILING\r\n\t\t\t\t;CHARACTER THE FIRST TIME THROUGH)\r\n\tXOR\tAH,AH\t\t;CLEAR (AH)\r\n\tCMP\tAL,LOW \"-\"      ;IF EQUAL NEED TO SAVE THIS GUY\r\n\tJZ\tPFX40\t\t;GO SAVE AND GET NEXT CHAR.\r\n\tCMP\tAL,LOW \"+\"\r\n\tJZ\tPFX40\t\t;GO SAVE THIS GUY IF EQUAL\r\n\tCMP\tAL,LOW OFFSET CURNCY\r\n\tJZ\tPFX40\t\t;GO SAVE IF EQUAL\r\n\tCMP\tAL,LOW \"0\"      ;IF EQUAL POSSIBLE TO ELIMINATE\r\n\tJNZ\tPFX70\t\t;MUST GIVE UP AND PUT LEADING \"%\"\r\n;**************************************************************\r\n;AT THIS POINT WE HAVE A LEADING ZERO. IT CAN BE ELIMINATED\r\n;ONLY IF THERE ARE DIGITS BEYOND THE DECIMAL POINT. IF THIS\r\n;IS THE CASE WE HAVE POSITIONED TO THE CORRECT PLACE AND\r\n;HAVE CHARACTERS TO MOVE DOWN IN THE STACK AND CAN ELIMINATE\r\n;THE ZERO BY NOT PUSHING IT ON THE STACK SINCE ALL\r\n;CHARACTERS TO BE RE-INSERTED WILL COME FROM THE STACK.\r\n;***************************************************************\r\n\tINC\tBX\t\t;THIS WILL CAUSE ELIMINATION OF \"0\"\r\n\tCALL\t$CHRGT\t\t;GET CHARACTER AFTER DECIMAL POINT\r\n\tJNB\tPFX70\t\t;NO HOPE GIVE UP AND PUT IN \"%\"\r\n\tDEC\tBX\t\t;(BX) NOW POINTS TO DECIMAL POINT\r\n\tJMP\tSHORT PFX60\r\nPFX50:\tDEC\tBX\t\t;NEXT CHARACTER POSITION TO MOVE INTO\r\n\tMOV\tBYTE PTR 0[BX],AL\t;MOVE IT IN\r\nPFX60:\tPOP\tAX\t\t;FETCH CHARACTER OFF THE STACK\r\n\tOR\tAH,AH\t\t;ONCE (AH)=1 IS REACHED CHARS.\r\n\t\t\t\t;HAVE BEEN RE-ENSTATED\r\n\tJZ\tPFX50\t\t;KEEP GOING IF (AH)=0\r\n\tADD\tSP,2\t\t;GET OLD START OF BUFFER ADDRESS OFF\r\n\t\t\t\t;THE STACK\r\n\tJMP\tSHORT PFX30\t;AND SEE IF WE NOW FIT INTO THE\r\n\t\t\t\t;REQUIRED SPACE\r\nPFX70:\r\n;******************************************************************\r\n;WE COULD NOT FIT THE NUMBER INTO THE BUFFER DESPITE OUR VALIENT\r\n;EFFORTS WE MUST POP ALL THE CHARACTERS BACK OFF THE STACK AND\r\n;POP OFF THE BEGINNING BUFFER PRINT LOCATION AND INPUT A \"%\" SIGN\r\n;THERE\r\n;******************************************************************\r\n\tPOP\tAX\t\t;GET CHARACTER OFF THE STACK\r\n\tOR\tAH,AH\t\t;IF ZF=1 AFTER THIS-MORE CHARS.\r\n\tJZ\tPFX70\r\n\tPOP\tBX\t\t;GET BEGINNING BUFFER POINTER\r\n\tMOV\tBYTE PTR 0[BX],LOW \"%\"  ;INSERT OVERFLOW FLAG\r\nPFX90:\tRET\r\n\r\n\tSUBTTL\t $FOTZS  ZERO SUPRESSION UPON OUTPUT ROUTINE\r\n;*************************************************************\r\n;\r\n;       $FOTZS  THIS ROUTINE WILL LOOK AT THE OUTPUT GENERATED\r\n;               BY THE REST OF THE PUFOT ROUTINES AND SUPRESS\r\n;               LEADING ZEROES.\r\n;       CALLING SEQUENCE:       CALL    $FOTZS\r\n;               ONLY PREREQUISITE IS THAT OTHER PUFOT ROUTINES\r\n;               HAVE EXECUTED TO PROVIDE FOTZS WITH $FBUFF\r\n;               CONTAINING OUTPUT TEXT.\r\n;\r\n;       $FOTZ   THIS ROUTINE PUTS IN (AL) LEADING ZEROS\r\n;       CALLING SEQUENCE:       CALL    $FOTZ\r\n;               WITH (AL) SET TO NO. OF LEADING ZEROS DESIRED\r\n;       $FOTZC  THIS ROUTINE PUTS IN (AL) LEADING ZEROS AND\r\n;               PAYS ATTENTION TO DECIMAL POINT AND COMMA COUNTS\r\n;               AND FURTHER PUTS IN COMMAS AND A D.P. AS NECESSARY\r\n;       CALLING SEQUENCE:       CALL    $FOTZC\r\n;               WITH (CX) SET TO NO. PLACES TO LEFT/RIGHT OF D.P.\r\n;               AND (AL) TO NO. LEADING ZEROS\r\n;*************************************************************\r\n\r\n\r\n\tCURNCY=\"$\"\t      ;Default floating currency is dollars.\r\n\r\n$FOTZS: MOV\tBX,OFFSET $FBUFF+1\t;ADDRESS OF SIGN(IF LEADING)\r\n\tMOV\tCH,BYTE PTR 0[BX]\t;FETCH LEADING CHARACTER\r\n\tMOV\tCL,LOW \" \"      ;SPACE TO CL\r\n\tMOV\tAH,BYTE PTR $FMTAL\t;FETCH FORMAT SPECIFICATIONS\r\n\t\t\t\t;BIT    76543210        OF AH\r\n\t\t\t\t;       ABCDEFGH        WHERE\r\n\t\t\t\t;A=FREE FORMAT FLAG\r\n\t\t\t\t;B=GROUP INTEGER DIGITS IN 3'S AND\r\n\t\t\t\t;  SEPARATE WITH COMMAS\r\n\t\t\t\t;C=FILL LEADING SPACES WITH \"*\"\r\n\t\t\t\t;D=OUTPUT WITH FLOATING \"$\"\r\n\t\t\t\t;E=PRINT SIGN WITH \"+\" INSTEAD OF\" \"\r\n\t\t\t\t;F=PRINT SIGN AS TRAILING\r\n\t\t\t\t;G=UNUSED\r\n\t\t\t\t;H=USE SCIENTIFIC NOTATION\r\n\tTEST\tAH,LOW 40\t;WILL TEST FOR LEADING \"*\" FIRST\r\n\tJZ\tFZ10\t\t;LEADING ASTERISKS NOT DESIRED IF JMP\r\n\tCMP\tCH,CL\t\t;SPACE?\r\n\tMOV\tCL,LOW \"*\"      ;SINCE IT'S ASTERISK FILL DESIRED\r\n\tJNZ\tFZ10\t\t;JUMP IF NOT SPACE\r\n\tTEST\tAH,LOW 4\t;WILL NOW CHECK FOR TRAILING SIGN\r\n\tJNZ\tFZ10\r\n\tMOV\tCH,CL\r\nFZ10:\tMOV\tBYTE PTR 0[BX],CL\t;REPLACE SIGN AS NECESSARY\r\n\tCALL\t$CHRGT\t\t;GET NEXT CHARACTER AND SET CONDITION\r\n\tJZ\tFZ50\t\t;CODES. JUMP IF END OF NUMBER\r\n\tMOV\tBP,OFFSET $FINCH+11\r\nFZ20:\r\n\tCMP\tAL,BYTE PTR CS:0[BP]\t;SEE IF SPECIAL CHARACTER\r\n\tJZ\tFZ30\t\t;\r\n\tCMP\tBP,OFFSET $FINCH\t;SEE IF         SEARCHED ALL TABLE\r\n\tJZ\tFZ60\t\t;IF SO GO CHECK FOR FLOATING \"$\"\r\n\tDEC\tBP\t\t;POINT TO NEXT SPECIAL CHARACTER\r\n\tJMP\tSHORT FZ20\t;AND CONTINUE   SEARCH\r\nFZ30:\tSUB\tBP,OFFSET $FINCH\t;CALCULATE TABLE OFFSET\r\n\tSHL\tBP,1\t\t;TO ACCOUNT FOR 2 BYTE TABLE ENTRY\r\n\t\t\t\t;ADD BASE ADDRESS (BP) NOW HAS ADDR.\r\nFZ40:\r\n\t\t\t\t;CODE SEGMENT OVERRIDE\r\n\tJMP\t WORD PTR CS:FZ45[BP]\r\nFZ45  LABEL WORD\r\n\tDW\tOFFSET FZ50\t;\".\"\r\n\tDW\tOFFSET FZ50\t;\"E\"\r\n\tDW\tOFFSET FZ60\t;\"E\"+40\r\n\tDW\tOFFSET FZ60\t;\"%\"\r\n\tDW\tOFFSET FZ60\t;\"#\"\r\n\tDW\tOFFSET FZ60\t;\"!\"\r\n\tDW\tOFFSET FZ50\t;\"D\"\r\n\tDW\tOFFSET FZ60\t;\"D\"+40\r\n\tDW\tOFFSET FZ10\t;\",\"\r\n\tDW\tOFFSET FZ10\t;\"0\"\r\nFZ50:\tDEC\tBX\t\t;NEED TO PUT IN LEADING \"0\"\r\n\tMOV\tBYTE PTR 0[BX],LOW \"0\"\r\nFZ60:\tMOV\tAH,BYTE PTR $FMTAL\t;GET FORMAT SPECS AGAIN\r\n\tTEST\tAH,LOW 20\t;TEST FOR FLOATING \"$\"\r\n\t\t\t\t;FLOATING \"$\" DESIRED?\r\n\tJZ\tFZ70\t\t;IF NOT PROCEED\r\n\tDEC\tBX\t\t;\r\n\tMOV\tBYTE PTR 0[BX],LOW OFFSET CURNCY\t;PUT IN FLOATING \"$\"\r\nFZ70:\tTEST\tAH,LOW 4\t;RECALL FORMAT SPECS\r\n\t\t\t\t;SEE IF TRAILING SIGN\r\n\tJNZ\tFZ90\t\t;IF SO RETURN\r\n\tDEC\tBX\r\n\tMOV\tBYTE PTR 0[BX],CH\t;PUT IN SIGN\r\n\tXOR\tCH,CH\t\t;MUST RETURN ZF=1 IF NOT TRAILING\r\n\t\t\t\t;SIGN.\r\nFZ90:\tRET\r\n$FOTZ:\t\t\t\t;PUT (AL) LEADING ZEROS IN BUFFER POINTED TO BY (BX)\r\n\tOR\tAL,AL\t\t;SEE IF FURTHER WORK TO DO\r\n\tJMP\tSHORT FTZ15\r\nFTZ10:\tMOV\tBYTE PTR 0[BX],LOW \"0\"  ;PUT IN LEADING ZERO\r\n\tINC\tBX\t\t;NEXT BUFFER POSITION\r\n\tDEC\tAL\r\nFTZ15:\tJNZ\tFTZ10\r\n\tRET\r\n\r\nFTZC10: CALL\t$FOTED\t\t;PUT IN COMMA AND DECIMAL POINT AS\r\n\t\t\t\t;NECESSARY\r\n$FOTZC: MOV\tBYTE PTR 0[BX],LOW \"0\"  ;PUT IN LEADING ZERO\r\n\tINC\tBX\t\t;NEXT BUFFER POSITION\r\n\tDEC\tAL\t\t;\r\n\tJNZ\tFTZC10\r\n\tRET\r\n\r\n\r\n\tSUBTTL\t $PUFE\t PRINT USING FLOATING IN \"E\" TYPE FORMAT\r\n;************************************************************\r\n;\r\n;       $PUFE   THIS ROUTINE IS CALLED TO FORMAT A SINGLE\r\n;               OR DOUBLE PRECISION NUMBER WITH A DESIRED\r\n;               \"E\" TYPE OUTPUT FORMAT. FURTHER SPECIFICATIONS\r\n;               CAN BE THE NUMBER DESIRED PRINT POSITIONS\r\n;               TO THE LEFT AND RIGHT OF THE DECIMAL POINT.\r\n;       CALLING SEQUENCE:       CALL    $PUFE\r\n;               WITH (BX) POINTING TO THE CURRENT OUTPUT POSITION\r\n;               AND ZF=1 IF THE OUTPUT NUMBER IS SINGLE\r\n;               PRECISION, ZF=0 IF DOUBLE PRECISION.\r\n;\r\n;*************************************************************\r\n\r\n$PUFE:\tCALL\t$GETYP\t\t;SET CONDITION CODES ACCORDING TO TYPE\r\n\r\n\r\n\tMOV\tAH,LOW 7\t;7 print positions if single precision\r\n\r\n\tJB\tPFE10\t\t;AND JUMP IF SINGLE PRECISION\r\n\tMOV\tAH,LOW 20\t;IT'S DOUBLE\r\nPFE10:\tCALL\t$SIGNS\t\t;SET COND CODES ACCORDING TO NO.\r\n\tPOP\tBX\t\t;GET BUFFER PTR IN CASE NO. IS ZERO\r\n\tSTC\t\t\t;CF WILL BE OUR FLAG TO REMEMBER\r\n\tJZ\tPFE20\t\t;IF THE NO. WAS ZERO SINCE $FOTNV\r\n\t\t\t\t;WILL RETURN WITH CF=0\r\n\tPUSH\tBX\t\t;SAVE BUFFER PTR\r\n\tPUSH\tAX\t\t;SAVE NO. DIGITS IN NUMBER\r\n\tCALL\t$FOTNV\t\t;BRACKET NO. SO DIGITS TO PRINT ARE\r\n\t\t\t\t;IN THE INTEGER PART\r\n\tPOP\tDX\t\t;$FOTNV ALSO RETURNS WITH EXPONENT\r\n\t\t\t\t;IN (AL)\r\n\tPOP\tBX\t\t;CF=0\r\n\tMOV\tAH,DH\t\t;(AH)=NO DIGITS RETURNED FROM $FOTNV\r\nPFE20:\tPUSHF\t\t\t;SAVE CF FLAG IN CASE NO. IS ZERO\r\n\tPUSH\tAX\t\t;SAVE EXP. AND NO. SIG. DIGITS\r\n\tMOV\tDX,WORD PTR $FMTCX\t;DIG LEFT/RT.OF D.P.\r\n\tOR\tDH,DH\t\t;WILL NEED TO KNOW IF SIGN DESIRED\r\n\tPUSHF\r\n\tOR\tDL,DL\t\t;SEE IF DECIMAL POINT DESIRED.\r\n\tJZ\tPFE30\t\t;IF NOT PROCEED\r\n\tDEC\tDL\t\t;\r\nPFE30:\tADD\tDH,DL\t\t;NO. DIGITS DESIRED\r\n\tPOPF\t\t\t;SEE IF SIGN DESIRED\r\n\tJZ\tPFE40\t\t;JUMP IF NOT DESIRED\r\n\tTEST\tBYTE PTR $FMTAX,LOW 4\t;SEE IF TRAILING SIGN DESIRED\r\n\tJNZ\tPFE40\t\t;IF SO PROCEED\r\n\tDEC\tDH\t\t;MUST USE ONE PRINT POSITION FOR SIGN\r\nPFE40:\tSUB\tDH,AH\t\t;MUST SEE IF HAVE EXCESS DIGITS AVAIL.\r\n\tMOV\tAH,DH\t\t;IF TO MANY WE MUST DIVIDE NO BY\r\n\t\t\t\t;10 UNTIL CORRECT DIGITS .\r\n\tPUSH\tAX\t\t;SAVE COMPAREISON OF DESIRED-AVAILABLE\r\n\t\t\t\t;DIGITS. AH IS GREATER THAN 0 IF\r\n\t\t\t\t;TRAILING ZEROS.\r\n\tJS\tPFE45\r\n\tJMP\tPFE65\t\t;IF NO INTERNAL ROUNDING PROCEED\r\n;*********************************************************************\r\n;WHAT IS HAPPENING HERE IS THAT IF WE HAVE MORE DIGITS THAN REQUIRED\r\n;WE MUST DIVIDE OUT THE EXCESS DIGITS SO THAT WE CAN ROUND AT THE\r\n;CORRECT PRINT POSITION. ONCE WE HAVE PERFORMED THIS DIVISION WE\r\n;WILL NEED TO CALCULATE THE CORRECT DECIMAL POINT POSITION BY ADDING\r\n;THE DESIRED PRINT POSITIONS TO THE LEFT TO THE NUMBER OF POSITIONS\r\n;WE SHIFTED OUT. THE REASON FOR THIS IS THAT REGARDLESS OF THE SIZE\r\n;OF THE NUMBER WE GO TO $FOTCV WITH , A FIXED NUMBER OF DIGITS\r\n;WILL BE PLACED IN THE OUTPUT BUFFER. FOR EXAMPLE, SAY WE REQUESTED\r\n;A PRINT LIKE ##.###^^^^  FOR A SINGLE PRECISION NUMBER. $FOTNV WILL\r\n;PRODUCE AN INTEGER OF 7 DIGITS SAY AXXXXXX WHERE A IS NON-ZERO\r\n;USING THE LEADING POSITION FOR THE SIGN WE NEED ONLY FOUR DIGITS\r\n;PRINTED SO WE NEED IT ROUNDED AT THE FOURTH POSITION. TO DO THIS WE\r\n;DIVIDE THE AXXXXXX BY 10 THREE TIMES TO GET AXXX.XXX  ,  WHEN\r\n;WE GO TO $FOTCV , HE WILL ROUND THIS NUMBER AND PRODUCE AN OUTPUT\r\n; OF   000AXXX  IN THE OUTPUT BUFFER. THE CORRECT PRINT POSITION\r\n;FOR THE DECIMAL POINT IS BETWEEN \"A\" AND \"X\". THIS IS CALCULATED\r\n;AS  PRINT POSITION= POSITIONS TO LEFT+SIGN+NO. POSITIONS DIVIDED\r\n;OFF.\r\n;*****************************************************************\r\nPFE45:\tPUSH\tBX\t\t;SAVE BUFFER PTR.\r\n\tPUSH\tAX\t\t;SAVE NO TIMES TO DIVIDE\r\nPFE50:\tPUSH\tAX\t\t;SAVE DIVIDE COUNT\r\n\tCALL\t$DIV10\t\t;SHIFT NO TO GET CORRECT ROUNDING\r\n\tPOP\tAX\t\t;RECALL DIVIDE COUNT\r\n\tINC\tAH\t\t;INCREMENT TO REFLECT DIVIDE\r\n\tJNZ\tPFE50\t\t;CONTINUE UNTIL GET CORRECT NO.\r\n\tCALL\t$VADDH\t\t;ROUND UP AT THE CORRECT POSITION\r\n\tCALL\t$VINT\t\t;AND MAKE INTEGER\r\n\tPOP\tAX\t\t;RECALL NO. DIVIDES\r\n\tPUSH\tAX\t\t;SAVE # DIVIDES\r\n\tMOV\tCX,3\t\t;WILL SHIFT AH 3 BITS LEFT\r\n\tSHL\tAH,CL\t\t;BECAUSE DP TABLE IS 8 BYTES/ENTRY\r\n\tCALL\t$GETYP\t\t;DETERMINE TYPE\r\n\tJB\tPFE55\t\t;JUMP IF SINGLE PRECISION\r\n\tMOV\tAL,AH\t\t;WILL CONVERT AH TO WORD IN AX\r\n\tCBW\r\n\tMOV\tBX,OFFSET $DP16 ;ADDRESS OF 10^16\r\n\tADD\tBX,AX\t\t;FAC SHOULD BE LESS THAN NO. POINTED\r\n\tCALL\t$MOVBF\t\t;MOVE CODE SEG NO. TO DBUFF\r\n\tCALL\t$DCMPM\t\t;TO BY BX\r\n\tJMP\tSHORT PFE57\r\nPFE55:\r\n\r\n\r\n\tMOV\tBX,OFFSET $DP07+4\t;address of 10^7\r\n\r\n\tMOV\tAL,AH\t\t;WILL CONVERT AH TO WORD IN AX\r\n\tCBW\r\n\tADD\tBX,AX\t\t;FAC SHOULD BE LESS THAN THIS NO\r\n\tCALL\t$MOVBS\t\t;MOVE CODE SEG NO. TO DBUFF\r\n\tCALL\t$COMPM\t\t;UNLESS ROUND UP HAS OCCURRED\r\nPFE57:\tPOP\tAX\t\t;RECALL NO. DIVIDES. WE MAY NEED\r\n\tPOP\tBX\t\t;GET BUFFER PTR BACK\r\n\tJS\tPFE66\t\t;ROUND-UP DID NOT OCCUR\r\n\tPOP\tAX\t\t;MUST GET TO ORIGINAL COPY\r\n\tPOP\tCX\t\t;EXPONENT NOW IN CL\r\n\tINC\tCL\t\t;MUST INCREMENT EXPONENT\r\n\tPUSH\tCX\t\t;SAVE EXP ON STACK\r\n\tPUSH\tAX\t\t;SAVE FOR POSSIBLE TRAILING ZEROS\r\n\tPUSH\tBX\t\t;SAVE BUFFER PTR\r\n\tPUSH\tAX\t\t;SAVE DIVIDED OUT DIGITS & EXPONENT\r\n\tCALL\t$DIV10\t\t;SO CORRECT DIGITS TO RIGHT OF\r\n\tPOP\tAX\r\n\tPOP\tBX\t\t;DECIMAL POINT ARE PRINTED\r\n\tJMP\tSHORT PFE66\r\nPFE65:\tXOR\tAH,AH\t\t;NO DIVIDES\r\nPFE66:\tNEG\tAH\t\t;IF PREVIOUSLY NEGATIVE MAKE POSITIVE\r\n\tMOV\tAL,BYTE PTR $FMTCX+1\t;GET DESIRED PLACES TO LEFT OF DEC. PT.\r\n\tADD\tAH,AL\t\t;NEW TOTAL\r\n\tINC\tAH\t\t;BECAUSE FOTED DECREMENTS AT FIRST\r\n\tOR\tAL,AL\t\t;SEE IF PLACES LEFT DESIRED\r\n\tJZ\tPFE70\r\n\tTEST\tBYTE PTR $FMTAX,LOW 4\t;SEE IF TRAILING SIGN\r\n\tJNZ\tPFE70\t\t;IF TRAILING SIGN PROCEED\r\n\tDEC\tAH\t\t;ALLOW PRINT POSITION FOR SIGN\r\nPFE70:\tMOV\tCH,AH\t\t;SET DECIMAL POINT POSITION\r\n\tXOR\tCL,CL\t\t;NO COMMAS FOR EXPONENTIAL PRINTOUT\r\n\tPOP\tAX\t\t;RECALL SIG. DIGIT COMPARISON\r\n\tPUSH\tWORD PTR $FMTCX ;SAVE FORMAT SPECS\r\n\tPUSH\tAX\t\t;SAVE SIG. DIGIT COMPARISON\r\n\tMOV\tBYTE PTR $FMTCX+1,CH\t;UPDATE DIGITS TO LEFT\r\n\tCALL\t$FOTCV\t\t;CONVERT TO ASCII DIGITS\r\n\tPOP\tAX\t\t;RECALL SIG. DIGIT COMPARISON\r\n\tOR\tAH,AH\t\t;WILL SET SF=0 IF TRAILING ZEROS\r\n\tJLE\tPFE80\t\t;IF TRAILING ZEROS NOT REQ. JUMP\r\n\tMOV\tAL,AH\t\t;NO. TRAILING ZEROS TO AL\r\n\tCALL\t$FOTZC\t\t;put in trailing zeros\r\n\tCALL\t$FOTED\t\t;put in decimal point (if necessary)\r\nPFE80:\tPOP\tAX\t\t;FETCH DIGITS TO LEFT/RT. OF D.P.\r\n\tMOV\tWORD PTR $FMTCX,AX\t;KEEP COPY FORMAT SPECS\r\n\tOR\tAL,AL\t\t;SEE IF DECIMAL POINT DESIRED\r\n\tJNZ\tPFE100\t\t;IF SO PROCEED\r\n\tDEC\tBX\t\t;NOT DESIRED SEE IF CAN ELIMINATE\r\n\tMOV\tAL,BYTE PTR 0[BX]\t;FETCH LAST PRINT POSITION\r\n\tCMP\tAL,LOW \".\"      ;DECIMAL POINT?\r\n\tJZ\tPFE90\t\t;IF SO THIS JUMP WILL ELIMINATE\r\n\tINC\tBX\t\t;MUST RETAIN AS IS\r\nPFE90:\tMOV\tWORD PTR $DPADR,BX\t;SAVE ADDRESS OF DECIMAL POINT\r\nPFE100: POP\tAX\t\t;RECALL EXPONENT\r\n\tPOPF\t\t\t;RECALL CF (=1 IF NO. IS ZERO)\r\n\tJB\tPFE110\t\t;JUMP IF NO. IS ZERO\r\n\tADD\tAL,AH\t\t;ADD EXP. AND NO SIG. DIGITS\r\n\tMOV\tAH,BYTE PTR $FMTCX+1\t;SUBTRACT OUT DIGITS TO LEFT OF D.P.\r\n\tSUB\tAL,AH\t\t;SUBTRACT DIGITS TO LEFT\r\n\tOR\tAH,AH\t\t;IF NONE THEN NO SIGN\r\n\tJZ\tPFE110\r\n\tTEST\tBYTE PTR $FMTAX,LOW 4\t;IF SO WILL NEED TO INCREMENT AL\r\n\tJNZ\tPFE110\r\n\tINC\tAL\t\t;MUST ACCOUNT FOR SIGN POSITION\r\nPFE110: OR\tAL,AL\r\n\tCALL\t$PUEXP\t\t;PUT EXPONENT IN BUFFER\r\n\t\t\t\t;$PUEXP IS LOCATED IN THE FILE WITH\r\n\t\t\t\t;$FOFMT. WHEN HE FINISHES BUILDING\r\n\t\t\t\t;THE EXPONENT IN $FBUFF HE LEAVES\r\n\t\t\t\t;THE END-OF-BUFFER POINTER IN CX\r\n\t\t\t\t;AND START OF BUFFER IN BX.\r\n\tMOV\tBX,CX\t\t;MUST GO TO PUFXE WITH END OF\r\n\t\t\t\t;BUFFER PTR. IN BX\r\n\tJMP\t$PUFXE\t\t;DO FIX-UP\r\n\r\n\tSUBTTL\t CON86\t 8086 BASIC CONSTANTS\r\n;*****************************************************************\r\n;\r\n;       THIS FILE CONTAINS 8086 CONSTANT TABLES\r\n;\r\n;*****************************************************************\r\n$FOTB:\r\n\t.RADIX\t10\r\n\tDB\t38,38,38,38,38,38,38,38\r\n\tDB\t38,38,38,38,38,38,38,38\r\n\tDB\t38,38,38,38,38,38,38,38\r\n\tDB\t38,37,37,37,36,36,36,35\r\n\tDB\t35,35,34,34,34,34,33,33\r\n\tDB\t33,32,32,32,31,31,31,31\r\n\tDB\t30,30,30,29,29,29,29,28\r\n\tDB\t28,28,27,27,27,26,26,26\r\n\tDB\t25,25,25,25,24,24,24,23\r\n\tDB\t23,23,23,22,22,22,22,21\r\n\tDB\t21,21,20,20,20,19,19,19\r\n\tDB\t19,18,18,18,17,17,17,16\r\n\tDB\t16,16,16,15,15,15,14,14\r\n\tDB\t14,13,13,13,13,12,12,12\r\n\tDB\t11,11,11,10,10,10,10,09\r\n\tDB\t09,09,08,08,08,07,07,07\r\n\tDB\t06,06,06,06,05,05,05,04\r\n\tDB\t04,04,03,03,03,03,02,02\r\n\tDB\t02,01,01,01,00,00,00,00\r\n\tDB\t-01,-01,-01,-02,-02,-02,-03,-03\r\n\tDB\t-03,-03,-04,-04,-04,-05,-05,-05\r\n\tDB\t-06,-06,-06,-06,-07,-07,-07,-08\r\n\tDB\t-08,-08,-09,-09,-09,-09,-10,-10\r\n\tDB\t-10,-11,-11,-11,-12,-12,-12,-12\r\n\tDB\t-13,-13,-13,-14,-14,-14,-15,-15\r\n\tDB\t-15,-15,-16,-16,-16,-17,-17,-17\r\n\tDB\t-18,-18,-18,-18,-19,-19,-19,-20\r\n\tDB\t-20,-20,-21,-21,-21,-21,-22,-22\r\n\tDB\t-22,-23,-23,-23,-24,-24,-24,-25\r\n\tDB\t-25,-25,-25,-26,-26,-26,-27,-27\r\n\tDB\t-27,-28,-28,-28,-28,-29,-29,-29\r\n\tDB\t-30,-30,-30,-31,-31,-31,-31,-32\r\n;****************************************************************\r\n;\r\n;TABLE DXX CONTAINS DOUBLE PRECISION POWERS OF TEN\r\n;FROM -38 TO +38\r\n;\r\n; 20-May-82 / MLC - Most of the negative powers of ten have been\r\n; removed.  Routines which used to multiply by these negative powers of\r\n; ten have been changed to divide by the corresponding positive power\r\n; of ten.  ($FINE and $FOTNV)\r\n;\r\n;*************************************************************\r\n\t.RADIX\t8\r\n$DPM01: DB\t315,314,314,314,314,314,114,175 ;10^-01\r\n$DP00:\tDB\t000,000,000,000,000,000,000,201 ;10^00\r\n$DP01:\tDB\t000,000,000,000,000,000,040,204 ;10^01\r\n\tDB\t000,000,000,000,000,000,110,207 ;10^02\r\n\tDB\t000,000,000,000,000,000,172,212 ;10^03\r\n\tDB\t000,000,000,000,000,100,034,216 ;10^04\r\n\tDB\t000,000,000,000,000,120,103,221 ;10^05\r\n$DP06:\tDB\t000,000,000,000,000,044,164,224 ;10^06\r\n$DP07:\tDB\t000,000,000,000,200,226,030,230 ;10^07\r\n\tDB\t000,000,000,000,040,274,076,233 ;10^08\r\n$DP09:\tDB\t000,000,000,000,050,153,156,236 ;10^09\r\n\tDB\t000,000,000,000,371,002,025,242 ;10^10\r\n\tDB\t000,000,000,100,267,103,072,245 ;10^11\r\n\tDB\t000,000,000,020,245,324,150,250 ;10^12\r\n\tDB\t000,000,000,052,347,204,021,254 ;10^13\r\n\tDB\t000,000,200,364,040,346,065,257 ;10^14\r\n\tDB\t000,000,240,061,251,137,143,262 ;10^15\r\n$DP16:\tDB\t000,000,004,277,311,033,016,266 ;10^16\r\n\tDB\t000,000,305,056,274,242,061,271 ;10^17\r\n\tDB\t000,100,166,072,153,013,136,274 ;10^18\r\n\tDB\t000,350,211,004,043,307,012,300 ;10^19\r\n\tDB\t000,142,254,305,353,170,055,303 ;10^20\r\n\tDB\t200,172,027,267,046,327,130,306 ;10^21\r\n\tDB\t220,254,156,062,170,206,007,312 ;10^22\r\n\tDB\t264,127,012,077,026,150,051,315 ;10^23\r\n\tDB\t241,355,314,316,033,302,123,320 ;10^24\r\n\tDB\t205,024,100,141,121,131,004,324 ;10^25\r\n\tDB\t246,031,220,271,245,157,045,327 ;10^26\r\n\tDB\t017,040,364,047,217,313,116,332 ;10^27\r\n\tDB\t012,224,370,170,071,077,001,336 ;10^28\r\n\tDB\t014,271,066,327,007,217,041,341 ;10^29\r\n\tDB\t117,147,004,315,311,362,111,344 ;10^30\r\n\tDB\t043,201,105,100,174,157,174,347 ;10^31\r\n\tDB\t266,160,053,250,255,305,035,353 ;10^32\r\n\tDB\t343,114,066,022,031,067,105,356 ;10^33\r\n\tDB\t034,340,303,126,337,204,166,361 ;10^34\r\n\tDB\t021,154,072,226,013,023,032,365 ;10^35\r\n\tDB\t026,007,311,173,316,227,100,370 ;10^36\r\n\tDB\t333,110,273,032,302,275,160,373 ;10^37\r\n\tDB\t211,015,265,120,231,166,026,377 ;10^38\r\n$DHALF:\t\t\t;DOUBLE PRECISION .5D00\r\n\tDB\t000\t\t;.5D00\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t000\r\n$SHALF:\t\t\t;SINGLE PRECISION .5E00\r\n\tDB\t000\t\t;.5E00\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t200\r\n$SQRH:\tDB\t361\t\t;SQR(.5)\r\n\tDB\t004\r\n\tDB\t065\r\n\tDB\t200\r\n;**********************************************************\r\n;FOR LOG CALCULATIONS HART ALGORITHM 2524 WILL BE USED\r\n;IN THIS ALGORITHM WE WILL CALCULATE BASE 2 LOG AS FOLLOWS\r\n;LOG(X)=P(X)/Q(X)\r\n;***************************************************************\r\n$LOGP:\tDB\t4\r\n\tDB\t232\t\t;4.8114746\r\n\tDB\t367\r\n\tDB\t031\r\n\tDB\t203\r\n\tDB\t044\t\t;6.105852\r\n\tDB\t143\r\n\tDB\t103\r\n\tDB\t203\r\n\tDB\t165\t\t;-8.86266\r\n\tDB\t315\r\n\tDB\t215\r\n\tDB\t204\r\n\tDB\t251\t\t;-2.054667\r\n\tDB\t177\r\n\tDB\t203\r\n\tDB\t202\r\n$LOGQ:\tDB\t4\r\n\tDB\t000\t\t;1.\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t201\r\n\tDB\t342\t\t;6.427842\r\n\tDB\t260\r\n\tDB\t115\r\n\tDB\t203\r\n\tDB\t012\t\t;4.545171\r\n\tDB\t162\r\n\tDB\t021\r\n\tDB\t203\r\n\tDB\t364\t\t;.3535534\r\n\tDB\t004\r\n\tDB\t065\r\n\tDB\t177\r\n;LOG BASE E OF 2.0\r\n$LN2:\tDB\t030\r\n\tDB\t162\r\n\tDB\t061\r\n\tDB\t200\r\n$FINCH:\t\t\t;SPECIAL CHARACTERS FOR INPUT/OUTPUT\r\n\tDB\t\".\"\r\n\tDB\tOFFSET \"E\"+40   ;LOWER CASE \"E\"\r\n\tDB\t\"E\"\r\n\tDB\t\"%\"\r\n\tDB\t\"#\"\r\n\tDB\t\"!\"\r\n\tDB\t\"D\"\r\n\tDB\tOFFSET \"D\"+40   ;LOWER CASE \"D\"\r\n\tDB\t54\t\t;COMMA\r\n\tDB\t\"0\"\r\n$FODTB: DB\t000\t\t; 1D15\r\n\tDB\t200\r\n\tDB\t306\r\n\tDB\t244\r\n\tDB\t176\r\n\tDB\t215\r\n\tDB\t003\r\n\tDB\t000\t\t; 1D14\r\n\tDB\t100\r\n\tDB\t172\r\n\tDB\t020\r\n\tDB\t363\r\n\tDB\t132\r\n\tDB\t000\r\n\tDB\t000\t\t; 1D13\r\n\tDB\t240\r\n\tDB\t162\r\n\tDB\t116\r\n\tDB\t030\r\n\tDB\t011\r\n\tDB\t000\r\n\tDB\t000\t\t; 1D12\r\n\tDB\t020\r\n\tDB\t245\r\n\tDB\t324\r\n\tDB\t350\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t000\t\t; 1D11\r\n\tDB\t350\r\n\tDB\t166\r\n\tDB\t110\r\n\tDB\t027\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t000\t\t; 1D10\r\n\tDB\t344\r\n\tDB\t013\r\n\tDB\t124\r\n\tDB\t002\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t000\t\t; 1D9\r\n\tDB\t312\r\n\tDB\t232\r\n\tDB\t073\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t000\t\t; 1D8\r\n\tDB\t341\r\n\tDB\t365\r\n\tDB\t005\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t200\t\t; 1D7\r\n\tDB\t226\r\n\tDB\t230\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t100\t\t; 1D6\r\n\tDB\t102\r\n\tDB\t017\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t000\r\n;SINGLE PRECISION POWER OF TEN TABLE\r\n$FOSTB: DB\t100\t\t;1,000,000\r\n\tDB\t102\r\n\tDB\t017\r\n\tDB\t240\t\t; 1E5\r\n\tDB\t206\r\n\tDB\t001\r\n\tDB\t020\t\t; 1E4\r\n\tDB\t047\r\n\tDB\t000\r\n;INTEGER POWER OF TEN TABLE\r\n$FOITB: DB\t020\t\t; 10000\r\n\tDB\t047\r\n\tDB\t350\t\t; 1000\r\n\tDB\t003\r\n\tDB\t144\t\t; 100\r\n\tDB\t000\r\n\tDB\t012\t\t; 10\r\n\tDB\t000\r\n\tDB\t001\t\t; 1\r\n\tDB\t000\r\n$S32KM: DB\t000\t\t;SINGLE PRECISION -32768\r\n\tDB\t000\r\n\tDB\t200\r\n\tDB\t220\r\n$INFPD: DB\t377\t\t;DOUBLE PRECISION +INFINITY\r\n\tDB\t377\r\n\tDB\t377\r\n\tDB\t377\r\n\tDB\t377\t\t;SINGLE PREC. +INFINITY\r\n\tDB\t377\r\n\tDB\t177\r\n\tDB\t377\r\n\r\n$INFMD: DB\t377\t\t;DOUBLE PRECISION -INFINITY\r\n\tDB\t377\r\n\tDB\t377\r\n\tDB\t377\r\n\tDB\t377\t\t;SINGLE PREC. -INFINITY\r\n\tDB\t377\r\n\tDB\t377\r\n\tDB\t377\r\n$LG2E:\tDB\t073\t\t;LOG BASE 2 OF E\r\n\tDB\t252\r\n\tDB\t070\r\n\tDB\t201\r\n;*********************************************************\r\n;$EXPCN CONTAINS THE COEFFICIENTS FOR POLYNOMIAL EVALUATION\r\n;OF LOG BASE 2 OF X WHERE .5.LE.X.LE.1\r\n;THE COEFFICIENTS ARE FROM HART #1302\r\n;***********************************************************\r\n$EXPCN: DB\t7\t\t;DEGREE + 1\r\n\tDB\t174\t\t;.00020745577403-\r\n\tDB\t210\r\n\tDB\t131\r\n\tDB\t164\r\n\tDB\t340\t\t;.00127100574569-\r\n\tDB\t227\r\n\tDB\t046\r\n\tDB\t167\r\n\tDB\t304\t\t;.00965065093202+\r\n\tDB\t035\r\n\tDB\t036\r\n\tDB\t172\r\n\tDB\t136\t\t;.05549656508324+\r\n\tDB\t120\r\n\tDB\t143\r\n\tDB\t174\r\n\tDB\t032\t\t;.24022713817633-\r\n\tDB\t376\r\n\tDB\t165\r\n\tDB\t176\r\n\tDB\t030\t\t;.69314717213716+\r\n\tDB\t162\r\n\tDB\t061\r\n\tDB\t200\r\n\tDB\t000\t\t;1.0\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t201\r\n$SINCN:\r\n;       COEFFICIENTS FOR SINE FUNCTION\r\n;       SEE HART'S #3341\r\n;       RELATIVE ERROR 8.27\r\n\r\n\tDB\t5\t\t;NUMBER OF CONSTANTS\r\n\tDB\t373\t\t;39.71091766+\r\n\tDB\t327\r\n\tDB\t036\r\n\tDB\t206\r\n\tDB\t145\t\t;-76.57498378-\r\n\tDB\t046\r\n\tDB\t231\r\n\tDB\t207\r\n\tDB\t130\t\t;81.60223119+\r\n\tDB\t064\r\n\tDB\t043\r\n\tDB\t207\r\n\tDB\t341\t\t;-41.34167747+\r\n\tDB\t135\r\n\tDB\t245\r\n\tDB\t206\r\n\tDB\t333\t\t;6.283185272+\r\n\tDB\t017\r\n\tDB\t111\r\n\tDB\t203\r\n$ATNC1:\t\t\t;CONSTANTS FOR ARCTANGENT RANGE REDUCTION\r\n\tDB\t2\r\n\tDB\t327\t\t;SQR(3)\r\n\tDB\t263\r\n\tDB\t135\r\n\tDB\t201\r\n\tDB\t000\t\t;-1.0\r\n\tDB\t000\r\n\tDB\t200\r\n\tDB\t201\r\n$ATNC2:\t\t\t;HART ALGORITHM 4940 COEFFICIENTS\r\n\tDB\t4\r\n\tDB\t142\t\t;-.1281333\r\n\tDB\t065\r\n\tDB\t203\r\n\tDB\t176\r\n\tDB\t120\t\t;.1993573\r\n\tDB\t044\r\n\tDB\t114\r\n\tDB\t176\r\n\tDB\t171\t\t;-.3333324\r\n\tDB\t251\r\n\tDB\t252\r\n\tDB\t177\r\n\tDB\t000\t\t;1.0\r\n\tDB\t000\r\n\tDB\t000\r\n\tDB\t201\r\n;************************************************************\r\n;THE FOLLOWING CONSTANT LABELED $IN2PI IS USED FOR RANGE\r\n;REDUCTION IN SIN,COS, & TAN. THE LOW ORDER BYTES ARE PURPOSELY\r\n;ZERO TO PROVIDE A MORE ACCURATE REDUCTION OF SINGLE PRECISION\r\n;NUMBERS. THIS CONSTANT SHOULD NOT BE USED WITH ORDINARY DOUBLE\r\n;PRECISION NUMBERS.\r\n;************************************************************\r\n$IN2PI: DB\t013\t\t;1/(2*PI)\r\n\tDB\t104\r\n\tDB\t116\r\n\tDB\t156\r\n\tDB\t203\r\n\tDB\t371\r\n\tDB\t042\r\n\tDB\t176\r\n;***********************************************************\r\n;CONSTANTS FOR THE RANDOM NUMBER GENERATOR FOLLOW\r\n;DO NOT CHANGE THESE WITHOUT CONSULTING KNUTH VOL 2\r\n;CHAPTER 3 FIRST\r\n;************************************************************\r\n$RNDA:\tDB\t375\t\t;214013\r\n\tDB\t103\r\n\tDB\t003\r\n$RNDC:\tDB\t303\t\t;2531011\r\n\tDB\t236\r\n\tDB\t046\r\n$RND0:\tDB\t001\r\n\tDB\t000\t\t;1\r\n\tDB\t000\r\n$NUMB:\tDB\t\"0\"\t      ;TABLE FOR OCTAL/HEX OUTPUT\r\n\tDB\t\"1\"\r\n\tDB\t\"2\"\r\n\tDB\t\"3\"\r\n\tDB\t\"4\"\r\n\tDB\t\"5\"\r\n\tDB\t\"6\"\r\n\tDB\t\"7\"\r\n\tDB\t\"8\"\r\n\tDB\t\"9\"\r\n\tDB\t\"A\"\r\n\tDB\t\"B\"\r\n\tDB\t\"C\"\r\n\tDB\t\"D\"\r\n\tDB\t\"E\"\r\n\tDB\t\"F\"\r\n\r\n\tSUBTTL\t $SIN\t SINGLE PRECISION SINE/COSINE/TANGENT/ARCTANGENT\r\n;****************************************************************\r\n;\r\n;       $SIN,$COS,$TAN  CALCULATE THE SINE/COSINE/TAN OF NO.\r\n;                       IN THE $FAC.USES HART POLYNOMIAL EVALUATION\r\n;                       WITH COEFFICIENTS FROM #3341\r\n;       CALLING SEQUENCE:       CALL    $SIN\r\n;                       OR      CALL    $COS\r\n;                       OR      CALL    $TAN\r\n;                       WITH ARGUMENT IN THE $FAC\r\n;\r\n;       $ATAN           CALCULATE THE ARCTANGENT OF THE VALUE IN THE\r\n;                       FAC. USES COEFFICIENTS FROM HART 4940\r\n;       CALLING SEQUENCE:       CALL    $ATAN\r\n;                       WITH THE ARGUMENT IN THE FAC\r\n;\r\n;       Changed COS to double precision range reduction 24-JUN-82/NGT\r\n;\r\n;******************************************************************\r\n\r\n\r\nCOS:\r\n$COS:\r\n\tAND\tBYTE PTR $FACM1,LOW 177O\t;clear sign bit ( cos(-x) = cos(x) )\r\n\tCALL\tRR\t\t; Do range reduction, FAC=REM(FAC/2pi)\r\n\tCALL\tONEARG\t\t; Zero the accumulator\r\n\tMOV\tBYTE PTR $ARG,LOW 177O\t; ARG = DP 1/4\r\n\tCALL\t$FADDD\t\t; FAC = reduced angle + PI/2\r\n\tCALL\tRR1\t\t; Make sure we are still in 0 - 2*PI\r\n\tJMP\tSHORT SIN30\r\n\r\nSIN:\r\n$SIN:\t\t\t\t;Will now take advantage of identity SIN(-X)=-SIN(X)\r\n\tMOV\tAX,WORD PTR $FAC-1\t;FETCH SIGN BYTE\r\n\tCMP\tAH,LOW 167O\t;IF EXP SMALLER THEN RETURN X\r\n\tJNB\tSIN10\r\n\tRET\r\nSIN10:\r\n\tOR\tAL,AL\r\n\tJNS\tSIN20\r\n;(FAC) is negative will make positive and push neg on stack\r\n\tAND\tAL,LOW 177O\t;CLEAR SIGN BYTE\r\n\tMOV\tBYTE PTR $FAC-1,AL\r\n\tMOV\tAX,OFFSET $NEG\t;FETCH ADDRESS OF NEG\r\n\tPUSH\tAX\t\t;AND PUSH ON STACK\r\nSIN20:\r\n\tCALL\tRR\t\t; Do DP range reduction\r\n;\r\n; At this point the FAC has the remainder of the angle / 2*PI\r\n;\r\nSIN30:\r\n\tMOV\tAL,LOW OFFSET $FAC\r\n\tOR\tAL,AL\r\n\tJZ\tSIN31\r\n\tADD\tBYTE PTR $FAC,LOW 2\t; FAC = FAC*4 = Reduce angle / PI/2\r\nSIN31:\r\n\tCALL\tRR3\t\t;ARG= INT(FAC)\r\n;\r\n; Now we have the reduced angle mod PI/2, so that we can find what quadrant\r\n; it's in.  The FAC should have a value in the range 0-3 corresponding to\r\n; the quadrant.  If the value is 2 or 3, corresponding to the interval\r\n; PI - 2*PI, we must return a negative value for the Sine.  If the value is\r\n; in quadrants 1 or 3, we must subtract the reduced angle from 1 (PI/2).\r\n; Algorithm:\r\n;       FAC = (angle / (2*PI))*4      ; Yields number in 0.LE.FAC.LT.4\r\n;       Save FAC\r\n;       ARG = INT( FAC )            ; ARG = quadrant 0-3\r\n;       Restore FAC\r\n;       FAC = (FAC - ARG)/4         ; FAC = angle in range 0 - PI/2\r\n;       IF quadrant = 1 or 3 THEN\r\n;           FAC = 1 - FAC           ; FAC = PI/2 - angle\r\n;       Calculate polynomial\r\n;       IF quadrant = 2 or 3 THEN\r\n;           Negate result           ; Negative for PI - 2*PI\r\n;\r\n;         LOW              HIGH (octal bytes)\r\n; D.P. 0 = 0,0,0,0,0,0,000,000\r\n; D.P. 1 = 0,0,0,0,0,0,000,201\r\n; D.P. 2 = 0,0,0,0,0,0,000,202      ; Which implies that FAC = 202 for 2 and 3\r\n; D.P. 3 = 0,0,0,0,0,0,100,202\r\n;\r\n\tMOV\tAX,WORD PTR $ARG-1\r\n\tCMP\tAH,LOW 202O\t; ARG now has quadrant information\r\n\tPUSHF\t\t\t; Z set if we need to negate when done\r\n\tTEST\tAH,LOW 1\t; Now set NZ if in quadrant 1\r\n\tJNZ\tSIN40\r\n\tTEST\tAL,LOW 100O\t; Set NZ if in quadrant 3\r\nSIN40:\r\n\tPUSHF\t\t\t; NZ if we must subtract from 1\r\n\tCALL\tRR2\t\t; FAC = X-INT(X) = angle MOD PI/2\r\n\tPOPF\r\n\tJZ\tSIN50\t\t; Nothing more to do, calculate the SIN\r\n\tMOV\tBX,OFFSET $DP00 ; Point to a D.P. 1 (10^0)\r\n\tCALL\t$MOVAC\t\t; ARG = 1\r\n\tCALL\t$FSUBD\t\t; FAC = 1 - FAC = PI/2 - angle MOD PI/2\r\nSIN50:\r\n\tSUB\tBYTE PTR $FAC,LOW 2\t; FAC = FAC/4 = ( angle / 2*PI )\r\n\tJNB\tSIN51\r\n\tCALL\t$DZERO\t\t;Return 0 if Underflow\r\nSIN51:\r\n\tCALL\t$CSD\t\t; Convert DP reduced angle back to SP\r\n\tMOV\tAL,BYTE PTR $FAC\t;WILL SEE IF SMALL ENOUGH\r\n\t\t\t\t;SUCH THAT X=SIN(X)\r\n\tCMP\tAL,LOW 164O\t;IF FAC SMALLER THAN THIS JUST\r\n\tJNB\tSIN60\r\n\tMOV\tDX,7733O\t;2*PI\r\n\tMOV\tBX,101511O\r\n\tCALL\t$FMULS\r\n\tJMP\tSHORT SIN65\t; Go set sign properly\r\nSIN60:\r\n\tMOV\tBX,OFFSET $SINCN\t;POINT TO HART 3341 COEFFS.\r\n\tCALL\t$POLYX\t\t;EVALUATE THE POLYNOMIAL\r\nSIN65:\r\n\tPOPF\t\t\t;RECALL SIGN\r\n\tJNZ\tSIN70\r\n\tXOR\tBYTE PTR $FAC-1,LOW 200O\t;FLIP SIGN\r\nSIN70:\r\n\tRET\r\n;\r\n; Converts FAC to double precision and reduces the result to a\r\n; value in the range 0 - 2*PI.\r\n; The RR1 entry point can be used to extract the fractional part of the FAC.\r\n;DOUBLE PRECISION REDUCTION OF RANGE BY 2*PI\r\n;\r\nRR:\r\n\tMOV\tBX,OFFSET $IN2PI\t;POINT TO 1/(2*PI)\r\n\tCALL\t$MOVAC\t\t;MOVE TO ARG\r\n\tCALL\t$CDS\t\t;CONVERT TO DOUBLE\r\n\tCALL\t$FMULD\t\t;X\r\nRR1:\r\n\tCALL\tRR3\r\nRR2:\r\n\tCALL\t$FSUBD\t\t;INT(X)-X\r\n\tJMP\t$NEG\t\t;X-INT(X)\r\nRR3:\r\n\tCALL\t$VPSHF\t\t;SAVE X\r\n\tCALL\t$DINT\t\t;($FAC)=INT(X)\r\n\tCALL\t$MOVAF\t\t;SAVE IN ARG\r\n\tCALL\t$VPOPF\t\t;FETCH X\r\n\tRET\r\nONEARG:\r\n\tMOV\tBX,OFFSET $DP00\r\n\tJMP\t$MOVAC\r\n\r\n\r\n\r\n;\r\n; Tangent Code\r\n;\r\nTAN:\r\n$TAN:\tPUSH\tWORD PTR $FACM1 ;SAVE ARG\r\n\tPUSH\tWORD PTR $FACLO\r\n\tCALL\t$SIN\t\t;CALCULATE SINE\r\n\tPOP\tDX\t\t;RECALL ARGUMENT\r\n\tPOP\tBX\r\n\tPUSH\tWORD PTR $FACLO ;SAVE SIN(X)\r\n\tPUSH\tWORD PTR $FACM1\r\n\tCALL\t$MOVFR\t\t;MOVE ORIGINAL ARG TO FAC\r\n\tCALL\t$COS\t\t;CALCULATE COSINE\r\n\tPOP\tBX\t\t;RECALL SIN(X)\r\n\tPOP\tDX\r\n\tJMP\t$FDIVS\t\t;GO DIVIDE TO EFFECT TANGENT\r\nATN:\r\n$ATAN:\t\t\t\t;(FAC)=ARCTANGENT(FAC)\r\n\tMOV\tAX,WORD PTR $FAC-1\t;WANT ONLY POSITIVE X\r\n\tOR\tAL,AL\r\n\tJNS\tATN10\r\n\tMOV\tDI,OFFSET $NEG\t;TAKE ADVANTAGE OF IDENTITY\r\n\tPUSH\tDI\t\t;ATAN(X)=-ATAN(-X)\r\n\tAND\tAL,LOW 177\t;CLEAR SIGN\r\n\tMOV\tBYTE PTR $FAC-1,AL\r\nATN10:\tCMP\tAH,LOW 201\t;SEE IF X .GT. TAN(PI/4)\r\n\tJB\tATN20\t\t;IF NOT PROCEED\r\n\tMOV\tDI,OFFSET ATN100\t;WILL WANT TO FORM\r\n\tPUSH\tDI\t\t;PI/2-(FAC) AT THE END\r\n\tXOR\tDX,DX\t\t;WILL SET (BXDX)=1.0\r\n\tMOV\tBX,100400\r\n\tCALL\t$FDIVS\t\t;THIS PUTS 1/X IN FAC\r\nATN20:\tMOV\tDX,30242\t;FETCH TAN(PI/12)\r\n\tMOV\tBX,77411\r\n\tCALL\t$FCOMP\t\t;SEE IF LARGER\r\n\tJS\tATN30\t\t;IF NOT PROCEED\r\n\tMOV\tDI,OFFSET ATN200\t;WILL WANT (FAC)=(FAC)+PI/6\r\n\tPUSH\tDI\t\t;AT THE END\r\n\tPUSH\tWORD PTR $FACLO ;SAVE X\r\n\tPUSH\tWORD PTR $FACM1\r\n\tMOV\tDX,131727\t;FETCH SQR(3)\r\n\tMOV\tBX,100535\r\n\tCALL\t$FADDS\t\t;(FAC)=X+SQR(3)\r\n\tPOP\tBX\r\n\tPOP\tDX\t\t;FETCH X BACK\r\n\tPUSH\tWORD PTR $FACLO ;SAVE X+SQR(3)\r\n\tPUSH\tWORD PTR $FACM1\r\n\tCALL\t$MOVFR\t\t;X TO FAC\r\n\tMOV\tBX,OFFSET $ATNC1\r\n\tCALL\t$POLY\t\t;FORM X*SQR(3)-1\r\n\tPOP\tBX\r\n\tPOP\tDX\t\t;RECALL X+SQR(3)\r\n\tPUSH\tWORD PTR $FACLO ;PUSH X*SQR(3)-1 ON STACK\r\n\tPUSH\tWORD PTR $FACM1\r\n\tCALL\t$MOVFR\t\t;X+SQR(3) TO FAC\r\n\tPOP\tBX\r\n\tPOP\tDX\t\t;RECALL X*SQR(3)-1\r\n\tCALL\t$FDIVS\t\t;FORM (X+SQR(3)-1)/(X+SQR(3))\r\nATN30:\tMOV\tBX,OFFSET $ATNC2\t;PREPARE FOR HART 4940\r\n\tJMP\t$POLYX\r\nATN100: MOV\tDX,7733\t;FETCH PI/2\r\n\tMOV\tBX,100511\r\n\tJMP\t$FSUBS\t\t;(FAC)=PI/2-(FAC)\r\n\r\nATN200: MOV\tDX,5222\t;FETCH PI/6\r\n\tMOV\tBX,100006\r\n\tJMP\t$FADDS\t\t;ADD PI/6 TO FAC\r\n\r\n\tSUBTTL\t $FINE\t ROUTINE TO ADJUST INPUT NUMBER FOR EXPONENT\r\n;****************************************************************\r\n;\r\n;       $FINE   THIS ROUTINE MODIFIES THE CURRENT FAC WHICH HAS\r\n;               THE INPUT SIGNIFICANT DIGITS SO THAT THE EXPONENT\r\n;               IS REFLECTED IN THE NUMBER. FOR EXAMPLE, IF THE\r\n;               NUMBER INPUT IS 1.9876E-17 THEN THE FAC CURRENTLY\r\n;               HAS THE NUMBER 19876. IT MUST BE MULTIPLIED BY\r\n;               10^-21 TO CORRECTLY REFLECT THE INPUT NUMBER.\r\n;               IT IS THE JOB OF THIS ROUTINE TO DETERMINE THE\r\n;               CORRECT MULTIPLIER AND PERFORM THE MULTIPLICATION\r\n;       CALLING SEQUENCE        CALL    $FINE\r\n;               WITH (SI) CONTAINING 0 IF POSITIVE EXPONENT\r\n;               ALL BITS SET IF NEGATIVE EXPONENT. (DX) CONTAINS\r\n;               THE INPUT EXPONENT(FOR THE EXAMPLE ABOVE =17)\r\n;               AND (DI) CONTAINS THE NUMBER PLACES TO THE RIGHT\r\n;               OF THE DECIMAL POINT.\r\n;\r\n;*****************************************************************\r\n\r\n$FINE:\tOR\tSI,SI\t\t;SEE IF DX SHOULD BE NEGATED\r\n\tJNS\tFIN05\t\t;IF NOT PROCEED\r\n\tNEG\tDX\t\t;NEGATE\r\nFIN05:\tSUB\tDX,DI\t\t;SUBTRACT OUT DIGITS TO RIGHT OF DP.\r\n\tJO\tFIN80\t\t;UNDERFLOW IF OVERFLOW FLAG SET\r\n\tJZ\tFIN55\t\t;NUMBER COMPLETE AS IS\r\n;***************************************************************\r\n;HERE WE HAVE THE EXPONENT IN DX. WE HAVE MULTIPLIERS RANGING\r\n;FROM (10^-38,10^38) TO USE IN DETERMINING THE CORRECT FAC. WE\r\n;MAY NEED TO DO SEVERAL MULTIPLIES TO CORRECTLY FORM THE NUMBER.\r\n;FOR EXAMPLE IF THE NUMBER INPUT WAS 1234567.E-40 DX WOULD\r\n;HAVE -40. IF THIS WERE THE CASE WE NEED TO DO A MULTIPLY BY 10^-38\r\n;THEN A MULTIPLY BY 10^-2 TO GET THE RIGHT NUMBER.\r\n;  All calculations are done in double precision and then converted\r\n;back to the original type.  Integers are converted to single precision.\r\n;****************************************************************\r\nMDPTEN:\r\n\tPUSH\tBX\t\t; Preserve text pointer\r\n\tCALL\t$GETYP\t\t; Get the current type,\r\n\tPUSHF\t\t\t; And save, so that we can convert back\r\n\tJNB\tFIN20\t\t; If already D.P., no conversion necessary\r\n\tCALL\tFRCDBL\t\t; Force result to be double precision\r\nFIN20:\tOR\tDX,DX\t\t; Test sign of exponent\r\n\tJS\tFIN30\t\t;IF NEGATIVE EXPONENT JUMP\r\n;********************************************************************\r\n;POSITIVE EXPONENT . IF GREATER THAN D^38 THEN WE HAVE OVERFLOW\r\n; Unless the number is zero, in which case just return zero.\r\n;********************************************************************\r\n\tTEST\tBYTE PTR $FAC,LOW 377O\t;Is the number zero?\r\n\tJZ\tFIN80\t\t;Yes, just return zero then.\r\n\tCMP\tDX,39D\r\n\tJB\tFIN40\t\t;OK PROCEED\r\n\tPOPF\t\t\t; Get back type flags\r\n\tJNB\tFIN25\t\t; Already D.P., nothing to convert\r\n\tCALL\t$CSD\t\t; Convert double to single\r\nFIN25:\tPOP\tBX\t\t; Restore text pointer\r\n\tJMP\t$OVFLS\t\t;OVERFLOW\r\n;\r\n; Negative exponent.\r\n; Might require two divisions since highest table entry is 10^38.\r\n;\r\nFIN30:\tCMP\tDX,-38D\t;Will one pass be enough?\r\n\tJGE\tFIN40\t\t;Yes.\r\n\tADD\tDX,38D\t\t;No, will two divisions get it?\r\n\tCMP\tDX,-38D\r\n\tJL\tFIN80\t\t;No, underflow - return zero.\r\n\tCALL\tMDP10\t\t;Yes, do the first one\r\n\tMOV\tDX,-38D\t;Then divide by 10^38.\r\nFIN40:\tCALL\tMDP10\t\t; Do the division\r\nFIN45:\tPOPF\t\t\t; Get back type flags\r\n\tJNB\tFIN50\t\t; Already D.P., nothing to convert\r\n\tCALL\t$CSD\t\t; Convert double to single\r\n\r\n; At this point the number is restored to its original type, with the\r\n; exception of integers being converted to single precision.\r\n\r\nFIN50:\tPOP\tBX\t\t; Restore text pointer\r\nFIN55:\tRET\r\n\r\nFIN80:\tCALL\t$ZERO\t\t;UNDERFLOW!\r\n\tJMP\tSHORT FIN45\t; Restore proper type\r\n\r\n;\r\n; Multiply or divide by double precision power of ten.\r\n; On entry DX contains the exponent.\r\n; If the exponent is postive, multiply.\r\n; If exponent is negaive, divide.\r\n;\r\n\r\nMDP10:\r\n\tOR\tDX,DX\t\t;Is the exponent negative?\r\n\tPUSHF\t\t\t;Remember whether to multiply or\r\n\t\t\t\t;divide.\r\n\tJNS\tPOSEXP\t\t;Positive exponent.\r\n\tNEG\tDX\t\t;Negative exponent, make it positive.\r\nPOSEXP: MOV\tCX,3\t\t;DX:=DX*8 to get offset into powers\r\n\tSHL\tDX,CL\t\t;of ten table.\r\n\tADD\tDX,OFFSET $DP00 ;DX:=pointer to power of ten.\r\n\tXCHG\tBX,DX\t\t;Move it to BX.\r\n\tCALL\t$MOVAC\t\t;MOVE D.P. NO. TO ARG\r\n\tPOPF\t\t\t;Divide?\r\n\tJS\tDBLDIV\t\t;Yes.\r\n\tJMP\t$FMULD\t\t;No, multiply and return to caller\r\nDBLDIV: JMP\tDDIVFA\t\t;Double precision divide; FAC=FAC/ARG,\r\n\t\t\t\t; Return to caller.\r\n\r\n\r\n\tSUBTTL\t $OVFLS  OVERFLOW CODE\r\n;***********************************************************\r\n;\r\n;       $OVFLS  PLACES CORRECT INFINITY IN THE FAC AND PRINTS\r\n;               OVERFLOW MESSAGE\r\n;\r\n;       $DIV0S  PLACES CORRECT INFINITY IN THE FAC AND PRINTS\r\n;               DIVIDE-BY-ZERO MESSAGE\r\n;\r\n;***********************************************************\r\n\r\n$OVFLS: PUSH\tBX\r\n\tCALL\tOVFLS\t\t;DO THE OVERFLOW CODE\r\n\tPOP\tBX\t\t;RESTORE TEXT POINTER\r\n\tRET\r\nOVFLS:\tCALL\tDOINF\t\t;PUT IN APPROPRIATE INFINITY\r\n\tMOV\tAX,OFFSET OVERR ;Error trapping routine adr\r\n\tMOV\tBX,OFFSET $OVMSG\t;ADDRESS APPROPRIATE ERROR MESSAGE\r\n\tJMP\tSHORT DV010\t;GO PRINT MESSAGE\r\n$DIV0S: PUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\tDIV0S\t\t;DO THE DIVIDE OVERFLOW CODE\r\n\tPOP\tBX\r\n\tRET\t\t\t;RETURN WITH TEXT POINTER SAVED\r\nDIV0S:\tCALL\tDOINF\t\t;PUT IN APPROPRIATE INFINITY\r\n\tMOV\tAX,OFFSET DV0ERR\t;Error trapping routine adr\r\n\tMOV\tBX,OFFSET $DIV0M\t;AND ERROR MESSAGE\r\nDV010:\tCALL\tTRAPER\t\t;Trap error if error trapping enabled\r\n\tCMP\tBYTE PTR $FLGOV,LOW 1\t;IF 0,1 PRINT, IF 1 MAKE 2\r\n\tJS\tDV015\t\t;PRINT IF 0\r\n\tJNZ\tDV020\t\t;DON'T PRINT IF 2\r\n\tMOV\tBYTE PTR $FLGOV,LOW 2\t;MAKE 2 IF 1\r\nDV015:\tCALL\t$STPRN\r\n\tMOV\tAL,LOW 15\t;CARRIAGE RETURN\r\n\tCALL\t$CATTY\t\t;SEND IT\r\n\tMOV\tAL,LOW 12\t;LINE FEED\r\n\tCALL\t$CATTY\t\t;SEND IT\r\nDV020:\tRET\r\n\r\nDOINF:\t\t\t\t;PUT CORRECT INFINITY IN THE FAC\r\n\tCLD\t\t\t;CLEAR THE DIRECTION FLAG \"DF\"\r\n\tOR\tBH,BH\t\t;SEE IF ZERO TO A NEG POWER\r\n\tMOV\tSI,OFFSET $INFPD\t;ASSUME POSITIVE\r\n\tJZ\tINF10\t\t;POSITIVE INFINITY FOR ZERO^-X\r\n\tTEST\tBYTE PTR $FAC+1,LOW 200 ;NEGATIVE?\r\n\tJNS\tINF10\t\t;IF NOT PROCEED\r\n\tMOV\tSI,OFFSET $INFMD\t;NEGATIVE INFINITY\r\nINF10:\tCALL\t$GETYP\t\t;SET CODES ACCORDING TO TYPE\r\n\tJB\tINF20\r\n;***********************************************************\r\n;IT'S DOUBLE PRECISION\r\n;***********************************************************\r\n\tMOV\tDI,OFFSET $DFACL\t;RECEIPIENT\r\n\tMOV\tCX,4\t\t;4 WORDS FOR DOUBLE PRECISION\r\n\tJMP\tSHORT INF30\r\nINF20:\t\t\t\t;SINGLE PRECISION\r\n\tADD\tSI,4\t\t;SO WE POINT TO SINGLE PRECISION NO.\r\n\tMOV\tDI,OFFSET $FACLO\r\n\tMOV\tCX,2\t\t;2 WORDS FOR SINGLE\r\nINF30:\t\t\t\t;MUST FETCH FROM CODE SEGMENT\r\n\tMOVS\t?CSLAB,WORD PTR ?CSLAB\t;TO FAC\r\n\tLOOP\tINF30\r\n\tRET\r\n\r\nTRAPER: PUSH\tAX\t\t;save Error trapping routine adr\r\n\tMOV\tAX,WORD PTR ONELIN\r\n\tOR\tAX,AX\t\t;see if we are trapping errors\r\n\tJNZ\tTRAPIT\t\t;branch if errors are being trapped\r\n\tPOP\tAX\t\t;discard Error trapping routine adr\r\nTRAPIT: RET\t\t\t;return to caller or Error trap routine\r\n\r\n\tSUBTTL\t $FOFMT  FLOATING FORMAT OF NUMBER IN THE FAC\r\n;**************************************************************\r\n;\r\n;       $FOFMT  FORMAT THE NUMBER IN THE FAC. IF THE NUMBER CAN BE\r\n;               AS ACCURATELY REPRESENTED IN FIXED FORMAT AS\r\n;               SCIENTIFIC THEN USE FIXED OUTPUT.\r\n;       CALLING SEQUENCE:       CALL    $FOFMT\r\n;               WITH (BX) POINTING TO CURRENT OUTPUT POSITION\r\n;               IN THE OUTPUT BUFFER $FBUFF AND CONDITION CODES\r\n;               SET AS IF $GETYP WAS JUST CALLED\r\n;\r\n;*****************************************************************\r\n\r\n$FOFMT: PUSH\tBX\t\t;SAVE BUFFER POINTER\r\n\r\n\r\n\tMOV\tAL,LOW 8D\t;assume single precision - print 7 digits\r\n\r\n\tJB\tFFM10\t\t;JUMP IF SINGLE PRECISION\r\n\tMOV\tAL,LOW 17D\t;DOUBLE PRECISION POSSIBLE DIGITS\r\nFFM10:\tMOV\tCH,AL\t\t;WILL SAVE A SECOND COPY FOR LATER\r\n\tMOV\tCL,AL\r\n\tPUSH\tCX\t\t;SAVE FOR LATER\r\n\tPUSHF\t\t\t;SAVE TYPE\r\n\tCALL\t$FOTNV\t\t;BRACKET THE NUMBER SO THAT SIGNIFICANT\r\n\t\t\t\t;DIGITS ARE IN THE INTEGER PART AND\r\n\t\t\t\t;THE NECESSARY EXPONENT IS IN (AL)\r\n\tOR\tAL,AL\t\t;IF POSITIVE DON'T CALL SIGD\r\n\tJZ\tFFM11\r\n\tJNS\tFFM15\r\nFFM11:\tPOPF\t\t\t;RECALL TYPE FOR TEST TO SEE IF SIGD\r\n\t\t\t\t;CALLED. IF S.P. AND (AL) SMALLER THAN\r\n\t\t\t\t;-7 MUST CALL SIG, IF D.P. AND (AL)\r\n\t\t\t\t;SMALLER THAN -16 THEN MUST CALL SIGD.\r\n\t\t\t\t;IF (AL) POSITIVE SIGD WILL NOT BE\r\n\t\t\t\t;CALLED. PURPOSE OF SIGD IS TO\r\n\t\t\t\t;DETERMINE WHETHER WE CAN PRINT NO. IN\r\n\t\t\t\t;FIXED FORMAT W/O LOSING SIGNIFICANT\r\n\t\t\t\t;DIGITS.\r\n\tPOP\tCX\t\t;RECALL POSIBLE SIGNIFICANT SIGITS\r\n\tPUSH\tAX\t\t;SAVE EXP.\r\n\tJPO\tFFM16\t\t;SINGLE PREC.\r\n\tADD\tAL,LOW 16D\t;THIS MUST MAKE POSITIVE TO NOT CALL\r\n\tPOP\tAX\r\n\tJNS\tFFM18\t\t;POP AX AND DO FIXED OUTPUT\r\n\tJMP\tSHORT FFM17\t;MUST CALL SIGD\r\nFFM15:\r\n\tPOPF\t\t\t;RECALL TYPE FLAG\r\n\tPOP\tCX\t\t;RECALL CX\r\n\tJMP\tSHORT FFM20\r\nFFM16:\r\n\tADD\tAL,LOW 7\r\n\tPOP\tAX\r\n\tJNS\tFFM18\r\nFFM17:\r\n\tPUSH\tAX\t\t;SAVE NECESSARY EXPONENT IN (AL)\r\n\tCALL\t$SIGD\t\t;INCREMENT (CL) FOR EACH ZERO DIGIT\r\n\t\t\t\t;BEGINNING FROM THE RIGHT\r\n\tPOP\tAX\t\t;RECALL NECESSARY EXPONENT\r\n\tMOV\tAH,AL\t\t;WILL PERFORM FIRST TEST ON AH\r\n\tADD\tAH,CL\t\t;IF SF=1 AFTER THIS THEN USE \"E\" FORMAT\r\n\tJLE\tFFM20\t\t;JUMP IF TOO SMALL\r\n\tADD\tCH,AL\r\n\tJMP\tSHORT FFM19\r\nFFM18:\tADD\tAL,CH\r\n\tINC\tCH\r\n\tCMP\tCH,AL\r\n\tMOV\tCH,LOW 3\t;TO FLAG \"E\" FORMAT IF NECESSARY\r\n\tJB\tFFM30\r\n\tMOV\tCH,AL\r\nFFM19:\tINC\tCH\t\t;(CH)= NUMBER DIGITS+2\r\n\tMOV\tAL,LOW 2\t;THIS WILL CAUSE ZF=1 IN LATER CALC\r\n\t\t\t\t;AND WILL SIGNAL FIXED OUTPUT\r\n\tJMP\tSHORT FFM30\r\nFFM20:\tADD\tAL,CH\r\n\tMOV\tCH,LOW 3\t;SIGNALS \"E\" TYPE FORMAT\r\nFFM30:\tDEC\tAL\t\t;(AL) 2 TOO LARGE\r\n\tDEC\tAL\r\n\tPOP\tBX\t\t;RECALL BUFFER POINTER\r\n\tPUSH\tAX\t\t;SAVE EXPONENT\r\n\tPUSHF\t\t\t;SAVE CONDITION CODES\r\n\tXOR\tCL,CL\t\t;(CL)=0  (NO COMMAS AFTER EACH 3 DIGITS\r\n\tCALL\t$FOTAN\t\t;PUT IN DECIMAL POINT AND LEADING\r\n\t\t\t\t;ZEROS AS NECESSARY\r\n\tMOV\tBYTE PTR 0[BX],LOW \"0\"  ;ZF=1 IF THIS \"0\" NECESSARY\r\n\tJNZ\tFFM40\r\n\tINC\tBX\r\nFFM40:\tCALL\t$FOTCV\t\t;CONVERT THE FAC TO DECIMAL DIGITS\r\n\t\t\t\t;AND PUT IN DECIMAL POINT AS NECESSARY\r\nFFM50:\tDEC\tBX\t\t;WILL NOW SEE IF THERE ARE TRAILING\r\n\tCMP\tBYTE PTR 0[BX],LOW \"0\"  ;ZEROS TO SUPPRESS. WE KNOW ZEROS WE\r\n\tJZ\tFFM50\t\t;FIND HERE ARE TRAILING BECAUSE $FOTCV\r\n\tCMP\tBYTE PTR 0[BX],LOW \".\"  ;PUTS IN DECIMAL POINT\r\n\tJZ\tFFM60\t\t;CAN WE DELETE THE DECIMAL POINT ALSO?\r\n\tINC\tBX\t\t;\r\nFFM60:\tPOPF\t\t\t;LET'S HAVE A LOOK AT THE POSSIBLE\r\n\t\t\t\t;EXPONENT\r\n\tPOP\tAX\r\n\tJZ\tFFM100\t\t;IF NO EXPONENT JUST CLEAN-UP AND RET\r\n$PUEXP: PUSHF\t\t\t;SAVE SF( IF =1 NEGATIVE EXPONENT)\r\n\tPUSH\tAX\t\t;SAVE EXPONENT\r\n\tCALL\t$GETYP\t\t;SET COND. CODES FOR TYPE NUMBER\r\n\tMOV\tAH,LOW \"E\"      ;ASSUME SINGLE PRECISION\r\n\tJPO\tFFM70\t\t;IF S.P. PROCEED\r\n\tMOV\tAH,LOW \"D\"      ;IT'S DOUBLE PRECISION\r\nFFM70:\tMOV\tBYTE PTR 0[BX],AH\t;PUT IN EXPONENT DESIGNATOR\r\n\tINC\tBX\t\t;POINT TO NEXT BUFFER POSITION\r\n\tPOP\tAX\t\t;RECALL EXPONENT\r\n\tPOPF\t\t\t;NOW TO SEE IF POSITIVE OR NEGATIVE\r\n\tMOV\tBYTE PTR 0[BX],LOW \"+\"  ;ASSUME POSITIVE EXPONENT\r\n\tJNS\tFFM80\t\t;AND JUMP IF SO\r\n\tMOV\tBYTE PTR 0[BX],LOW \"-\"\r\n\tNEG\tAL\t\t;MUST MAKE EXPONENT POSITIVE\r\nFFM80:\tMOV\tAH,LOW OFFSET \"0\"-1     ;WILL BUILD DIGIT IN (AL)\r\nFFM90:\tINC\tAH\t\t;INCREMENT TO NEXT DIGIT\r\n\tSUB\tAL,LOW 10D\t;\r\n\tJNB\tFFM90\r\n\tADD\tAL,LOW OFFSET \"0\"+10D   ;ADD TO DETERMINE SECOND DIGIT\r\n\tINC\tBX\t\t;POINT TO NEXT BUFFER POSITION\r\n\tXCHG\tAL,AH\t\t;PREPARE FOR WORD STORE\r\n\tMOV\tWORD PTR 0[BX],AX\t;STORE 2 DIGITS OF EXPONENT\r\n\tINC\tBX\t\t;INCREMENT TO NEXT BUFFER POSITION\r\n\tINC\tBX\r\nFFM100: MOV\tBYTE PTR 0[BX],LOW 0\t;SIGNAL END OF BUFFER DATA\r\n\tXCHG\tBX,CX\t\t;END-OF-BUFFER PTR. IN (CX)\r\n\tMOV\tBX,OFFSET $FBUFF+1\t;START IN (BX)\r\n\tRET\r\n\r\n\tSUBTTL\t UTILS\t   UTILITY ROUTINES\r\n\r\n\r\n\r\n;string printer must fetch from code segment\r\nSTOULP: CALL\tOUTDO\t\t;send char\r\n\tCMP\tAL,LOW 13D\t;carriage return?\r\n\tJNZ\tSTROUT\t\t;no\r\n\tCALL\tCRFIN\t\t;force carriage back to left\r\nSTROUT:\t\t\t;fetch from code segment\r\n\tMOV\tAL,BYTE PTR CS:0[BX]\t;get char\r\n\tINC\tBX\t\t;point at next one\r\n\tOR\tAL,AL\t\t;end of string?\r\n\tJNZ\tSTOULP\t\t;no print char until done\r\n\tRET\r\n$DZERO:\t\t\t;DOUBLE PRECISION ZERO\r\n\tMOV\tDI,OFFSET $DFACL\r\n\tMOV\tCX,4\r\n\tMOV\tAX,0\r\n\tCLD\r\n REP\tSTOSW\r\n\tRET\r\n\r\nZERO:\r\n$ZERO:\t\t\t\t;ZERO THE FAC\r\n\tMOV\tAX,0\r\n\tMOV\tWORD PTR $FACLO,AX\t;ZERO LOWER 2 BYTES\r\n\tMOV\tWORD PTR $FAC-1,AX\t;ZERO UPPER TWO BYTES\r\n\tRET\r\n\r\nSIGN:\r\n$SIGNS:\t\t\t;DETERMINE SIGN OF FAC\r\n\t\t\t\t;ZF=1 IF ($FAC)=0, SF=1 IF ($FAC) .LT.0, NEITHER OF\r\n\t\t\t\t;THESE FLAGS SET IF ($FAC).GT.0\r\n\tCALL\t$GETYP\t\t;IF NOT INTEGER CAN LOOK AT FAC:FAC-1\r\n\tJNE\tSIS01\r\n\tJMP\tTMERR\t\t;Strings illegal 9-Mar-82/ngt\r\nSIS01:\r\n\tJNS\tSIS05\t\t;NOT INTEGER PROCEED\r\n\tMOV\tAX,WORD PTR $FACLO\t;FETCH INTEGER\r\n\tOR\tAX,AX\t\t;DETERMINE SIGN\r\n\tJZ\tSIS10\r\n\tMOV\tAL,LOW 1\r\n\tJNS\tSIS10\r\n\tNEG\tAL\r\n\tRET\r\nSIS05:\r\n\tMOV\tAL,BYTE PTR $FAC\t;FIRST CHECK FOR ZERO\r\n\tOR\tAL,AL\r\n\tJZ\tSIS10\t\t;IF ZERO JUST RETURN\r\n\tMOV\tAL,BYTE PTR $FAC-1\t;FETCH SIGN BYTE\r\nSIGNAL: OR\tAL,AL\t\t;SIGNSET NOW\r\n\tJZ\tSIS07\t\t;MUST MAKE AL=1 AND ZF=0\r\n\tMOV\tAL,LOW 1\r\n\tJNS\tSIS10\r\n\tNEG\tAL\r\n\tRET\r\nSIS07:\tOR\tAL,LOW 1\t;KNOW POSITIVE NON-ZERO\r\nSIS10:\tRET\r\n\r\n;\r\n; Set cond. codes according to type value.\r\n;   S, C = Integer\r\n;   Z, C = String\r\n;      C = Single Precision\r\n;   None = Double Precision\r\n;\r\n$GETYP:\r\n\tMOV\tAL,BYTE PTR $VALTP\t;FETCH TYPE VARIABLE\r\n\tCMP\tAL,LOW 10\t;CF=1 EXCEPT FOR DOUBLE PREC.\r\n\tDEC\tAL\t\t;WILL SUBTRACT 3 WITH DECBREMENTS\r\n\tDEC\tAL\r\n\tDEC\tAL\r\n\tRET\t\t\t;ZF=1 IF STRING,SF=1 IF INTEGER\r\n\t\t\t\t;PO=1 IF SINGLE PREC\r\n\r\n$VADDH:\t\t\t;ADD .5 ACCORDING TO TYPE\r\n\tCALL\t$GETYP\t\t;SET CODES ACCORDING TO TYPE\r\n\tJB\t$FADDH\r\n$DADDH:\t\t\t;DOUBLE PRECISION ADD .5\r\n\tPUSH\tBX\r\n\tMOV\tBX,OFFSET $DHALF\r\n\tCALL\t$MOVAC\t\t;MOVE TO ARG\r\n\tCALL\t$FADDD\t\t;ADD TO FAC\r\n\tPOP\tBX\r\n\tRET\r\n$FADDH:\t\t\t;SINGLE PRECISION ADD .5\r\n\tXOR\tDX,DX\t\t;WILL SET (BXDX)=.5\r\n\tMOV\tBX,100000\r\n\tCALL\t$FADDS\t\t;ADD .5 TO FAC\r\n\tRET\r\n$DIV10:\t\t\t;DIVIDE FAC BY 10\r\n\tCALL\t$GETYP\r\n\tMOV\tBX,OFFSET $DPM01\t;ADDRESS .1\r\n\tJB\tML10\r\n\tJMP\tSHORT ML05\t;MULTIPLY\r\n\r\n$MUL10:\t\t\t;MULTIPLY THE FAC BY 10\r\n\tCALL\t$GETYP\t\t;SEE IF SINGLE OR DOUBLE PREC\r\n\tMOV\tBX,OFFSET $DP01 ;ADDRESS OF DOUBLE PREC 10.\r\n\tJB\tML10\t\t;JUMP IF SINGLE\r\nML05:\tCALL\t$MOVAC\t\t;MOVE 10. TO ARG\r\n\tCALL\t$FMULD\t\t;MULTIPLY\r\n\tRET\r\nML10:\t\t\t\t;MULTIPLY SINGLE PREC. FAC BY NO. POINTED TO BY BX\r\n$MLSP:\r\n\tPUSH\tWORD PTR $FACM1 ;PUSH FAC ON THE STACK\r\n\tPUSH\tWORD PTR $FACLO\r\n\tMOV\tBYTE PTR $VALTP,LOW 10\t;SET UP D.P.\r\n\tCALL\t$MOVFC\t\t;MOVE DOUBLE PREC. 10 TO FAC\r\n\tCALL\t$CSD\t\t;CONVERT TO SINGLE PRECISION\r\n\tPOP\tDX\t\t;GET LOW MANTISSA BITS\r\n\tPOP\tBX\t\t;EXP SIGN AND HIGH MATISSA BITS\r\n\tCALL\t$FMULS\t\t;MULTIPLY\r\n\tRET\r\n\r\n\r\n$RDL:\tMOV\tCX,4\t\t;WILL SHIFT 4 WORDS LEFT\r\nRDL120: RCL\tWORD PTR 0[BX],1\t;SHIFT  LEFT 1 BIT SHIFTING IN CF\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tLOOP\tRDL120\r\n\tRET\r\n$SHDR:\tMOV\tCX,4\t\t;DO DOUBLE PRECISION RIGHT SHIFT\r\n$SHRM:\t\t\t\t;SHIFT NO. POINTED TO BY (BX) , (CX) WDS RT.\r\n\tRCR\tWORD PTR 0[BX],1\t;SHIFT 1 WD. RT. THRU CF\r\n\tDEC\tBX\r\n\tDEC\tBX\t\t;TO NEXT WD.\r\n\tLOOP\t$SHRM\t\t;DO THIS (CX) TIMES\r\n\tRET\r\nSHST:\tOR\tBYTE PTR 2[BX],LOW 40\t;\"OR\" IN ST BIT\r\n\tLOOP\t$SHRA\r\n\tRET\r\n$SHRA:\t\t\t\t;SHIFT $ARG RIGHT (CX) BITS\r\n\tMOV\tBX,OFFSET $ARG-2\r\n\tCMP\tCL,LOW 10\t;CAN I DO A BYTE MOVE\r\n\tJB\tSHRA30\t\t;IF NOT PROCEED AS NORMAL\r\n;*************************************************************\r\n;FOR SPEED PURPOSES WE WILL DO A BYTE MOVE TO THE RIGHT\r\n;*************************************************************\r\n\tPUSH\tCX\t\t;SAVE BITS TO SHIFT\r\n\tMOV\tCX,7\t\t;7 BYTE MOVE\r\n\tMOV\tBX,OFFSET $ARGLO-1\r\n\tMOV\tAH,BYTE PTR 0[BX]\t;FETCH OVERFLOW BYTE\r\nSHRA11: MOV\tAL,BYTE PTR 1[BX]\r\n\tMOV\tBYTE PTR 0[BX],AL\r\n\tINC\tBX\r\n\tLOOP\tSHRA11\r\n\tXOR\tAL,AL\r\n\tMOV\tBYTE PTR 0[BX],AL\r\n\tPOP\tCX\t\t;RECALL BIT COUNT\r\n\tSUB\tCL,LOW 10\r\n\tAND\tAH,LOW 40\t;WILL NEED TO RE-ESTABLISH ST\r\n\tJZ\t$SHRA\t\t;NO-ST JUST PROCEED\r\n\tOR\tBYTE PTR $ARGLO-1,AH\r\n\tJMP\t$SHRA\r\nSHRA30:\r\n\tOR\tCL,CL\r\n\tJZ\tSHRA40\t\t;JUMP IF DONE\r\n\tPUSH\tCX\t\t;SAVE NO. BITS TO SHIFT\r\n\tCLC\t\t\t;DON'T WANT THE CARRY SHIFTED IN\r\n\tCALL\t$SHDR\r\n\tPOP\tCX\r\n\tTEST\tBYTE PTR 2[BX],LOW 20\t;SEE IF SHIFTED THRU \"ST\"\r\n\tJNZ\tSHST\t\t;MUST \"OR\" ST BIT IN IF NON-ZERO\r\n\tLOOP\t$SHRA\r\nSHRA40: RET\r\n\r\n\r\n$XCGAF: MOV\tSI,OFFSET $DFACL\t;WILL EXCHANGE FAC AND ARG (D.P.)\r\n\tMOV\tDI,OFFSET $ARGLO\r\n\tCLD\t\t\t;SO MOVW WILL INCREMENT INDICES\r\n\tMOV\tCX,4\t\t;WILL MOVE 4 WORDS (8 BYTES)\r\nXCG10:\tMOV\tAX,WORD PTR 0[DI]\t;FETCH DESTINATION WORD\r\n\tMOVSW\t\t\t;MOVE FAC TO ARG & INCREMENT INDICES\r\n\tMOV\tWORD PTR -2[SI],AX\t;ARG TO FAC\r\n\tLOOP\tXCG10\t\t;CONTINUE\r\n\tRET\r\n\r\n;*********************************************************************\r\n;       SPECIAL MOVE ROUTINES FOR HANDLING CONSTANTS FROM THE CODE\r\n;       SEGMENT\r\n;*********************************************************************\r\n$MOVBS:\t\t\t;THIS ROUTINE IS USED TO MOVE A SINGLE PRECISION NO. FROM THE\r\n\t\t\t\t;CODE SEGMENT TO $DBUFF. THE NO. IS POINTED TO BY (BX)\r\n\tMOV\tDI,OFFSET $DBUFF+4\r\n\tMOV\tCX,2\r\n\tJMP\tSHORT MBF10\r\n$MOVBF:\t\t\t;THIS ROUTINE IS USED TO MOVE A DOUBLE PRECISION NO. FROM THE\r\n\t\t\t\t;CODE SEGMENT TO $DBUFF. THE NO. IS POINTED TO BY (BX)\r\n\tMOV\tDI,OFFSET $DBUFF\r\nMBF05:\tMOV\tCX,4\r\nMBF10:\tCLD\r\n\tMOV\tSI,BX\t\t;SO WE CAN USE A LODW\r\nMBF20:\r\n\tLODS\tWORD PTR ?CSLAB ;FETCH FROM CS\r\n\tSTOSW\t\t\t;STORE IN DBUFF\r\n\tLOOP\tMBF20\t\t;CONTINUE WITH MOVE\r\n\tMOV\tBX,DI\t\t;UPDATE (BX)\r\n\tSUB\tBX,2\t\t;GET POINTER CORRECT\r\n\tRET\r\n\r\n$MOVAC:\t\t\t;ROUTINE TO MOVE A DOUBLE PRECISION NO. POINTED TO BY (BX)\r\n\t\t\t\t;FROM THE CODE SEGMENT TO ARG\r\n\tMOV\tDI,OFFSET $ARGLO\r\n\tJMP\tSHORT MBF05\r\n\r\n$MOVFC:\t\t\t;ROUTINE USED TO MOVE A DOUBLE PRECISION NO. FROM THE CODE\r\n\t\t\t\t;SEGMENT TO THE FAC. NO. IS POINTED TO BY (BX)\r\n\tMOV\tDI,OFFSET $DFACL\r\n\tJMP\tSHORT MBF05\r\n\r\nMOVAM:\t\t\t\t;MOVE NO. POINTED TO BY BX TO ARG\r\n\tMOV\tDI,OFFSET $ARGLO\t;LOW ADDRESS OF ARG\r\n\tMOV\tCX,4\t\t;MOVE DOUBLE PREC NO. POINTED TO\r\n\t\t\t\t;BY (BX) TO DOUBLE PREC NO. POINTED TO\r\n\t\t\t\t;BY (DI)\r\nMOVEM:\t\t\t\t;MOVE NO. POINTED TO BY (BX) TO NO. POINTED TO BY (DI)\r\n\t\t\t\t;FOR (CX) WORDS\r\n\tXCHG\tBX,SI\t\t;SO MOVW CAN BE USED\r\n\tCLD\t\t\t;SO MOVW WILL INC\r\n\t\t     ;DO MOVE (CX) TIMES\r\n REP\tMOVSW\t\t\t;MOVE \"FROM\" TO \"TO\"\r\n\tXCHG\tBX,SI\t\t;GET REGISTERS STRAIGHT\r\n\tRET\r\n\r\n$MOVAF:\t\t\t;MOVE THE $FAC TO $ARG\r\n\tPUSH\tCX\t\t;SAVE CX,BX,DI\r\n\tPUSH\tBX\r\n\tPUSH\tDI\r\n\tMOV\tBX,OFFSET $DFACL\t;\"FROM\" ADDRESS\r\n\tMOV\tDI,OFFSET $ARGLO\t;\"TO\" ADDRESS\r\nMAF05:\tMOV\tCX,4\t\t;4 16-BIT QUANTITIES TO MOVE\r\n\tCALL\tMOVEM\t\t;DO THE MOVE\r\n\tPOP\tDI\r\n\tPOP\tBX\r\n\tPOP\tCX\t\t;REGISTERS RESTORED\r\n\tRET\r\n\r\n\r\n\r\n$MOVFA:\t\t\t;MOVE THE $ARG TO THE FAC\r\n\tPUSH\tCX\r\n\tPUSH\tBX\r\n\tPUSH\tDI\t\t;SAVE REGISTERS\r\n\tMOV\tBX,OFFSET $ARGLO\t;\"FROM\" ADDRESS\r\n\tMOV\tDI,OFFSET $DFACL\t;\"TO\" ADDRESS\r\n\tJMP\tSHORT MAF05\t;GO MOVE\r\n;**************************************************************\r\n;SINGLE PRECISION MOVE ROUTINES\r\n;***************************************************************\r\n$MOVFR:\t\t\t;MOVE (BXDX) TO FAC\r\n\tMOV\tWORD PTR $FACLO,DX\r\n\tMOV\tWORD PTR $FAC-1,BX\r\n\tRET\r\n\r\n$MOVRF:\t\t\t;MOVE THE FAC INTO REGISTERS (BXDX)\r\n\tMOV\tDX,WORD PTR $FACLO\r\n\tMOV\tBX,WORD PTR $FAC-1\r\n\tRET\r\n\tPAGE\r\n;\r\n; ZCMPCK is called by the comparison routines to handle the\r\n; cases where the exponent of either or both of the numbers\r\n; is zero.  These must be treated as special cases because\r\n; a number whose exponent is zero is zero regardless of the\r\n; garbage that might be in the mantissa.\r\n;\r\n; On entry -    BH=exponent of comperand\r\n;               Bit 7 of BL=sign of comperand\r\n;\r\n; On exit -     Carry clear - caller must continue comparison.\r\n;\r\n;               Carry set - comparison is finished.\r\n;               A=1, Z=0, S=0 for FAC .GT. comperand\r\n;               A=0, Z=1 for FAC .EQ. comperand\r\n;               A=377 octal, Z=0, S=1 for FAC .LT. comperand\r\n;\r\n\r\nZCMPCK: OR\tBH,BH\t\t;Is the comperand zero?\r\n\tJNZ\tNZCOMP\t\t;No.\r\n\tCALL\tSIS05\t\t;Yes, result is the sign of the FAC.\r\n\tSTC\t\t\t;Set carry to say comparison is done\r\n\tRET\t\t\t;and return.\r\n\r\nNZCOMP: MOV\tAL,BYTE PTR $FAC\t;Is the FAC zero?\r\n\tOR\tAL,AL\t\t;(Also clear carry.)\r\n\tJNZ\tZCMPRT\t\t;No, return with carry clear to tell\r\n\t\t\t\t;the caller he must continue.\r\n\tMOV\tAL,BL\t\t;Yes, the result is the opposite\r\n\tNOT\tAL\t\t;of the sign of the comperand.\r\n\tCALL\tSIGNAL\r\n\tSTC\t\t\t;Set carry to say comparison is\r\nZCMPRT: RET\t\t\t;finished and return.\r\n\r\n;\r\n; ZCMPBX performs the special zero check for the case where\r\n; BX points to the comperand.\r\n;\r\n\r\nZCMPBX: PUSH\tBX\t\t;Preserve the comperand pointer.\r\n\tMOV\tBX,WORD PTR 0[BX]\t;BH:=exponent, BL bit 7:=sign for\r\n\t\t\t\t;ZCMPCK.\r\n\tCALL\tZCMPCK\t\t;Check for the zero cases.\r\n\tPOP\tBX\t\t;Retrieve the comperand pointer\r\n\tRET\t\t\t;and return.\r\n\tPAGE\r\n\r\n$VCOMP:\t\t\t;DETERMINE IF SINGLE OR DOUBLE PRECISION AND COMPARE ACCORDINGLY\r\n\tCALL\t$GETYP\t\t;SET CODES ACCORDING TO TYPE\r\n\tJB\t$COMPM\t\t;DO S.P. COMPARE\r\n\tJMP\t$DCMPM\t\t;GO DO D.P. COMPARE\r\n\r\n$FCOMP:\t\t\t;SINGLE PRECISION COMPARE OF ($FAC) AND (BXDX)\r\n\t\t\t\t;(AL)=1 AND ZF=0,SF=0,CF=0 IF ($FAC).GT.(BXDX)\r\n\t\t\t\t;(AL)=0 AND ZF=1 IF ($FAC)=(BXDX)\r\n\t\t\t\t;(AL)=377 AND ZF=0,SF=1,CF=1 IF ($FAC).LT.(BXDX)\r\n\r\n\tCALL\tZCMPCK\t\t;Check for zero exponent cases.\r\n\tJB\tZEREXP\t\t;All done if carry set.\r\n\tPUSH\tBX\r\n\tPUSH\tDI\t\t;\r\n\tMOV\tAL,BL\t\t;SIGN OF (BXDX) TO (AL)\r\n\tXOR\tAL,BYTE PTR $FAC-1\t;SET CODES FOR SIGNS\r\n\tJS\tCPM05\r\n\tOR\tBL,BL\r\n\tJS\tUFC10\t\t;NEGATIVE NOS.\r\n\tMOV\tAX,WORD PTR $FAC-1\t;SIGNS SAME MUST COMPARE\r\n\tSUB\tAX,BX\t\t;SUBTRACT HIGH WORD\r\n\tJB\tCPM10\t\t;($FAC) SMALLER\r\n\tJNZ\tCPM06\t\t;($FAC) LARGER\r\n\tMOV\tAX,WORD PTR $FACLO\t;MUST COMPARE LOW WORD\r\n\tSUB\tAX,DX\t\t;\r\n\tJMP\tSHORT TSTFLG\t;return comparison result based on flags\r\nUFC10:\tMOV\tAX,BX\t\t;SINCE NEGATIVE LARGER MAGNITUDE IS\r\n\tSUB\tAX,WORD PTR $FAC-1\t;SMALLER NO.\r\n\tJB\tCPM10\r\n\tJNZ\tCPM06\t\t;(BXDX) SMALLER\r\n\tMOV\tAX,DX\t\t;MUST COMPARE LOW WORD\r\n\tSUB\tAX,WORD PTR $FACLO\r\nTSTFLG: JB\tCPM10\t\t;branch if FAC is smaller than comperand\r\n\tJNZ\tCPM06\t\t;branch if FAC is larger than comperand\r\n\tXOR\tAL,AL\t\t;FAC is equal to comperand\r\n\tJMP\tSHORT CPM80\r\n\r\n;One of the exponents was zero (meaning the number=0).\r\n; Set Carry flag if [AL]=377 (if FAC is less than comperand)\r\n;\r\nZEREXP: INC\tAL\t\t;Map AL from (377, 0, 1) to (0, 1, 2)\r\n\tSUB\tAL,LOW 1\t;Map it back, setting Flags appropriately\r\n\tRET\r\n\r\n$COMPM:\t\t\t;COMPARE FAC TO NUMBER POINTED TO BY (BX)\r\n;       (BX) MUST BE POINTING TO SIGN BYTE OF NO.\r\n\t\t\t\t;SET (AL)=1,ZF=0,SF=0,CF=0 IF (FAC).GT.[BX]\r\n\t\t\t\t;    (AL)=0,ZF=1 IF (FAC)=[BX]\r\n\t\t\t\t;    (AL)=377,ZF=0,SF=1,CF=1 IF (FAC).LT.[BX]\r\n\r\n\tCALL\tZCMPBX\t\t;Check for zero exponent cases.\r\n\tJB\tZEREXP\t\t;All done if carry set.\r\n\tPUSH\tBX\t\t;SAVE INITIAL ADDRESS\r\n\tPUSH\tDI\t\t;SAVE DI\r\n\tMOV\tDI,OFFSET $FAC-1\r\n\tMOV\tAX,WORD PTR 0[BX]\t;FETCH SIGN BYTE INTO AL\r\n\tXOR\tAL,BYTE PTR $FAC-1\t;SF=1 IF SIGNS DIFFERENT\r\n\tJNS\tCPM20\r\n;*****************************************************************\r\n;SIGNS ARE DIFFERENT , THE ONE WITH POS. SIGN IS BIGGER\r\n;******************************************************************\r\nCPM05:\tMOV\tAH,BYTE PTR $FAC-1\t;FETCH FAC SIGN\r\n\tOR\tAH,AH\r\n\tJS\tCPM10\t\t;FAC IS SMALLER MUST SET (AL)=377\r\nCPM06:\tMOV\tAL,LOW 1\r\n\tOR\tAL,AL\t\t;MIGHT HAVE GOTTEN A ZF=1 ON LAST \"OR\"\r\n\tJMP\tSHORT CPM80\r\nCPM10:\tMOV\tAL,LOW 377\t;KNOW SF=1\r\n\tSTC\t\t\t;WANT CF=1 IF FAC SMALLER\r\n\tJMP\tSHORT CPM80\r\nCPM20:\r\n;******************************************************************\r\n;SIGNS ARE THE SAME MUST DO ACTUAL COMPARE\r\n;******************************************************************\r\n\tPUSH\tCX\t\t;WILL USE (CX) FOR LOOP CONTROL\r\n\tMOV\tCX,2\r\nCPM22:\tXCHG\tBX,SI\t\t;SO CMPW CAN BE USED\r\n\tMOV\tAL,BYTE PTR $FAC-1\t;IF NEGATIVE NO. NEED TO REVERSE CMP\r\n\tOR\tAL,AL\r\n\tJNS\tCPM25\r\n\tXCHG\tSI,DI\t\t;WILL CAUSE CORRECT COMPARE FOR NEG.\r\nCPM25:\r\n\tSTD\t\t\t;SO CMPW WILL DECREMENT\r\nCPM30:\tCMPSW\t\t\t;FORM CODES FOR (.SI)-(.DI)\r\n\tJNZ\tCPM50\r\n\tLOOP\tCPM30\t\t;CONTINUE THRU VALUES\r\n\tMOV\tAL,LOW 0\t;ZF=1 ALREADY SET\r\n\tJMP\tSHORT CPM70\r\nCPM50:\tJNB\tCPM60\t\t;MEMORY VALUE LARGER\r\n\tMOV\tAL,LOW 1\t;FAC LARGER SF=0,ZF=0\r\n\tOR\tAL,AL\r\n\tJMP\tSHORT CPM70\r\nCPM60:\t\t\t\t;MEMORY IS LARGER MUST SET SF=1 AND (AL)=377\r\n\tMOV\tAL,LOW 377\r\n\tOR\tAL,AL\r\n\tSTC\t\t\t;WANT CF=1 IF MEMORY VALUE LARGER\r\nCPM70:\tPOP\tCX\t\t;RESTORE CX REGISTER\r\nCPM80:\r\n\tPOP\tDI\r\n\tPOP\tBX\r\n\tRET\r\n\r\n$DCMPA:\t\t\t;DOUBLE PRECISION COMPARE OF ($FAC) AND ($ARG)\r\n\tMOV\tBX,OFFSET $ARG-1\r\n\r\n$DCMPM:\t\t\t;DOUBLE PRECISION COMPARE OF ($FAC) AND ((BX))\r\n\t\t\t\t;(AL)=1 AND ZF=0,SF=0,CF=0 IF ($FAC).GT.((BX))\r\n\t\t\t\t;(AL)=0 AND ZF=1 IF ($FAC)=((BX))\r\n\t\t\t\t;(AL)=377 AND ZF=0,SF=1,CF=1 IF ($FAC).LT.((BX))\r\n\r\n\tCALL\tZCMPBX\t\t;Check for zero exponent cases.\r\n\tJB\tZEREXP\t\t;All done if carry set.\r\n\tPUSH\tBX\r\n\tPUSH\tDI\t\t;SAVE REGISTERS\r\n\tMOV\tDI,OFFSET $FAC-1\t;D.P. HIGH FAC WORD\r\n\tMOV\tAL,BYTE PTR 0[DI]\t;WILL FIRST SEE IF SIGNS DIFFERENT\r\n\tXOR\tAL,BYTE PTR 0[BX]\r\n\tJNS\tDC10\t\t;PROCEED IF NOT DIFFERENT\r\n\tJMP\tSHORT CPM05\t;SIGNS DIFFERENT SET CODES ACCORDINGLY\r\nDC10:\tPUSH\tCX\r\n\tMOV\tCX,4\t\t;FOUR WORDS TO COMPARE\r\n\tJMP\tSHORT CPM22\t;GO COMPARE\r\n\r\n\r\n$CONI2:\t\t\t;CHECK FAC FOR -32768 SINGLE PRECISION AND IF\r\n\t\t\t\t;EQUAL CONVERT TO INTEGER\r\n\tMOV\tBX,OFFSET $S32KM\t;ADDRESS OF S.P. -32768\r\n\tCALL\t$MOVBS\t\t;MOVE IT OUT TO DBUFF FOR COMPARISON\r\n\tCALL\t$COMPM\t\t;ONLY INTERESTED IN ZF\r\n\tJNZ\tCON10\t\t;IF NOT EQUAL JUST RETURN\r\n\tMOV\tBYTE PTR $VALTP,LOW 2\t;TO INDICATE INTEGER\r\n\tMOV\tWORD PTR $FACLO,OFFSET 200*400\t;-32768\r\nCON10:\tRET\r\n\r\n\r\n$RSUBM:\t\t\t;SUBTRACT NO POINTED TO BY (BP) FROM (BLDX)\r\n\t\t\t\t;NUMBER POINTED TO BY (BP) IS PRESUMED TO BE IN\r\n\t\t\t\t;THE CODE SEGMENT\r\n\tSUB\tDX,WORD PTR CS:0[BP]\t;FIRST 16 BITS\r\n\tSBB\tBL,BYTE PTR CS:2[BP]\r\n\tRET\t\t\t;COND. FLAGS ALL SET\r\n\r\n;*********************************************************\r\n;THE \"V\" UTILITIES FOLLOW. THESE UTILITIES HAVE ONE THING IN\r\n;COMMON: THEY MUST FIRST ASCERTAIN WHAT TYPE OF VARIABLE\r\n;THEY ARE TO WORK ON BEFORE PERFORMING THEIR TASK.\r\n;************************************************************\r\nABSFN:\r\n$VABS:\t\t\t\t;ABSOLUTE VALUE ROUTINE\r\n\tCALL\t$GETYP\t\t;SEE WHAT TYPE VARIABLE\r\n\tJS\t$IABS\t\t;IF INTEGER PROCEED\r\n\tMOV\tAL,BYTE PTR $FAC-1\r\n\tOR\tAL,AL\t\t;SEE IF CURRENTLY NEGATIVE\r\n\tJS\t$NEG\t\t;AND IF SO NEGATE\r\n\tRET\r\n$IABS:\tMOV\tAX,WORD PTR $FACLO\t;FETCH INTEGER\r\n\tOR\tAX,AX\t\t;AND SEE IF ALREADY POS.\r\n\tJS\tVN15\r\n\tRET\t\t\t;RETURN IF POSITIVE\r\n\r\nVNEG:\r\n$VNEG:\t\t\t\t;NEGATE THE VALUE IN THE FAC\r\n\tCALL\t$GETYP\t\t;SET COND. CODES ACCORDING TO TYPE\r\n\tJS\t$INEG\t\t;IT'S INTEGER MUST COMPLEMENT\r\n;************************************************************\r\n;IT'S SINGLE OR DOUBLE PRECISION MUST FLIP THE SIGN BIT\r\n;************************************************************\r\nNEG:\r\n$NEG:\r\n\tXOR\tBYTE PTR $FAC-1,LOW 200 ;FLIP SIGN OF FAC\r\n\tRET\r\nINEG:\r\n$INEG:\tMOV\tAX,WORD PTR $FACLO\t;WILL CHECK FOR -32768\r\nVN15:\tCMP\tAX,100000\t;SEE IF -32768\r\n\tJNZ\tVN20\t\t;IF NOT JUST NEGATE\r\n\tPUSH\tBX\t\t;PRESERVE BX\r\n\tCALL\t$CSI\t\t;CONVERT TO SINGLE PRECISION\r\n\tPOP\tBX\t\t;RECALL BX\r\n\tJMP\t$NEG\t\t;GO NEGATE\r\nVN20:\tNEG\tWORD PTR $FACLO ;NEGATE\r\n\tRET\r\n\r\n$SETDB:\t\t\t;MOVE FAC TO DBUFF FOR MULT. AND ZERO FAC\r\n\tMOV\tBX,OFFSET $DBUFF+1\t;\r\n\tCALL\t$VMVMF\t\t;MOVE FAC TO DBUFF\r\n\tMOV\tDI,OFFSET $DFACL-10\t;WILL NOW ZERO 16 BYTES OF FAC\r\n\tMOV\tCX,10\r\n\tMOV\tAX,0\r\n\tCLD\r\n REP\tSTOSW\t\t\t;STORES (AX) INTO LOCATIONS\r\n\tMOV\tBYTE PTR $DBUFF,AL\t;ZERO OVERFLOW BYTE\r\n\tMOV\tBYTE PTR $ARGLO-1,AL\t;ZERO OVERFLOW BYTE OF ARG\r\n\tRET\r\n\r\n$VMVAM:\t\t\t;MOVE THE VALUE POINTED TO BY (BX) TO (BXDX) IF SINGLE\r\n\t\t\t\t;PRECISION, TO $ARG IF DOUBLE PRECISION\r\n\tCALL\t$GETYP\t\t;SET CODES ACCORDING TO TYPE\r\n\tJB\tVM10\t\t;JUMP IF SINGLE PRECISION\r\n\tJMP\tMOVAM\t\t;MOVE THE VALUE TO THE ARG\r\nVM10:\tMOV\tDX,WORD PTR 0[BX]\t;FETCH LOW MANTISSA BITS\r\n\tMOV\tBX,WORD PTR 2[BX]\t;FETCH HIGH MANTISSA AND EXPONENT\r\n\tRET\r\n\r\n\r\n$VMOVM:\t\t\t;MOVE THE VARIABLE POINTED TO BY (BX) TO THE ONE POINTED\r\n\t\t\t\t;TO BY (DI)\r\n\tMOV\tCX,4\t\t;ASSUME DOUBLE PRECISION\r\n\tCALL\t$GETYP\r\n\tJB\tVMM10\t\t;IT'S SINGLE PREC JUMP\r\n\tJMP\tMOVEM\t\t;GO DO MOVE\r\nVMM10:\tMOV\tCX,2\r\n\tJMP\tMOVEM\t\t;GO DO MOVE\r\n\r\n$VMVMF:\t\t\t;MOVE THE FAC TO THE NO. POINTED TO BY (BX)\r\n\tMOV\tCX,4\t\t;ASSUME DOUBLE PREC.\r\n\tXCHG\tDI,BX\t\t;(DI)=DESTINATION,(BX)=ORIGIN\r\n\tMOV\tBX,OFFSET $DFACL\r\n\tCALL\t$GETYP\t\t;SET COND. CODES ACCORDING TO $VALTP\r\n\tJB\tVMVM1\t\t;JUMP IF S.P.\r\n\tJMP\tMOVEM\t\t;GO DO MOVE\r\nVMVM1:\tXCHG\tBX,DI\r\n$MOVMF: MOV\tCX,2\r\n\tMOV\tDI,OFFSET $FACLO\r\n\tXCHG\tDI,BX\r\n\tJMP\tMOVEM\t\t;GO DO MOVE\r\n\r\n$VMVFM:\t\t\t;MOVE TO FAC THE NO POINTED TO BY (BX)\r\n\tMOV\tCX,4\t\t;ASSUME DOUBLE PREC\r\n\tMOV\tDI,OFFSET $DFACL\r\n\tCALL\t$GETYP\r\n\tJB\t$MOVFM\r\n\tJMP\tMOVEM\r\n$MOVFM: MOV\tCX,2\r\n\tMOV\tDI,OFFSET $FACLO\r\n\tJMP\tMOVEM\t\t;GO DO MOVE\r\n\r\n$VCMPM:\t\t\t;COMPARE FAC TO NO. POINTED TO BY (BX)\r\n\tCALL\t$GETYP\r\n\tJB\tVCMP10\r\n\tJMP\t$DCMPM\t\t;DO DOUBLE PREC COMPARE\r\nVCMP10: JMP\t$COMPM\t\t;SINGLE PREC COMPARE\r\n\r\n$VPSHF:\t\t\t;PUSH THE FAC ON THE STACK ACCORDING TO TYPE\r\n\tCALL\t$GETYP\t\t;SET COND CODES ACCORDING TO $VALTP\r\n\tMOV\tCX,4\t\t;FOR DOUBLE PRECISION\r\n\tJNB\tVPS10\t\t;IF DOUBLE PREC PROCEED\r\n$PUSHF:\t\t\t;PUSH SINGLE PRECISION FAC ON THE STACK\r\n\tMOV\tCX,2\r\nVPS10:\tPOP\tBP\t\t;GET RETURN ADDRESS OFF STACK\r\n\tMOV\tDI,OFFSET $FAC-1\r\nVPS20:\tPUSH\tWORD PTR 0[DI]\r\n\tDEC\tDI\r\n\tDEC\tDI\r\n\tLOOP\tVPS20\r\n\tPUSH\tBP\t\t;GET RETURN ADDRESS RIGHT\r\n\tRET\t\t\t;AND RETURN\r\n$POPA:\t\t\t\t;POP STACK INTO ARG\r\n\tMOV\tDI,OFFSET $ARGLO\r\n\tMOV\tCX,4\r\n\tJMP\tSHORT VPO17\r\n$VPOPF:\t\t\t;POP EITHER 4 OR 8 BYTES OFF THE STACK\r\n\tCALL\t$GETYP\t\t;SET CODES ACCORDING TO $VALTP\r\n\tMOV\tDI,OFFSET $DFACL\r\n\tMOV\tCX,4\r\n\tJNB\tVPO17\t\t;JUMP IF DOUBLE PRECISION\r\n\tMOV\tDI,OFFSET $FACLO\r\n\tMOV\tCX,2\r\nVPO17:\tPOP\tAX\t\t;GET RETURN ADDRESS OFF STACK\r\nVPO20:\tPOP\tWORD PTR 0[DI]\r\n\tINC\tDI\r\n\tINC\tDI\r\n\tLOOP\tVPO20\r\n\tPUSH\tAX\t\t;PUSH RETURN ADDRESS ON STACK\r\n\tRET\r\nVINT:\r\n$VINT:\t\t\t\t;DO INT ACCORDING TO TYPE (SINGLE OR DOUBLE PRECISION)\r\n\tCALL\t$GETYP\t\t;SET CODES ACCORDING TO TYPE\r\n\tJNS\tVIN05\r\n\tRET\t\t\t;RETURN IF INTEGER ALREADY\r\nVIN05:\r\n\tJB\tVIN10\t\t;JUMP IF SINGLE PRECISION\r\n\tJMP\t$DINT\t\t;GO DO DOUBLE PRECISION\r\nVIN10:\tJMP\t$INT\r\n\r\n\tSUBTTL\t $FIN\t NUMERIC INPUT ROUTINE\r\n;****************************************************************\r\n;\r\n;       $FIN    GIVEN A TEXT POINTER, $FIN WILL BUILD AN INPUT\r\n;               NUMBER IN THE FAC. AS NECESSARY (OR IF FORCED)\r\n;               $FIN WILL GO TO NEXT HIERARCHY OF NUMBERS\r\n;               I.E. TRANSITIONS FROM INTEGER-SINGLE PRECISION-\r\n;               DOUBLE PRECISION CAN EITHER BE FORCED OR DICTATED\r\n;               BY THE INPUT NUMBERS.\r\n;       CALLING         SEQUENCE:       CALL    $FIN\r\n;               WITH (BX) POINTING TO TEXT CONTAINING THE NUMBER\r\n;               TO BE CONVERTED FROM ASCII.\r\n;\r\n;******************************************************************\r\n\r\n\r\n\r\nFIN:\r\n$FIN:\tXOR\tAL,AL\t\t;LET INPUT NUMBER DETERMINE TYPE\r\n\tJMP\tSHORT FN20\r\nFINDBL:\r\n$FINDB:\t\t\t;FORCE DOUBLE PRECISION ENTRY POINT\r\n\tMOV\tAL,LOW 1\t;FLAG TO INDICATE D.P.\r\n\tMOV\tBYTE PTR $VALTP,LOW 10\t;SET TO DOUBLE PRECISION\r\nFN20:\r\n\tMOV\tBYTE PTR $FLGOV,LOW 1\t;SET ONCE-ONLY OVERFLOW MODE\r\n\tMOV\tSI,OFFSET $FLGOC\t;ADDRESS OF INPUT OVERFLOW CODE\r\n\tPUSH\tSI\t\t;PUSH ON STACK SO RETURN IS HERE\r\n\tXOR\tDI,DI\t\t;DIGITS PAST DECIMAL POINT\r\n\tMOV\tCX,DI\t\t;DECIMAL POINT FLAG\r\n\tMOV\tSI,DI\t\t;(SI) WILL FLAG POS/NEG EXPONENT\r\n\tNOT\tCX\t\t;SET ALL BITS\r\n\tPUSH\tAX\r\n\tCALL\t$ZERO\t\t;(FAC)=0\r\n\tPOP\tAX\r\n\tOR\tAL,AL\t\t;MUST SEE IF $VALTP SHOULD START AT\r\n\tJNZ\tFN30\t\t;INTEGER OR NOT.\r\n\tMOV\tBYTE PTR $VALTP,LOW 2\t;SET TO INTEGER\r\nFN30:\tMOV\tAL,BYTE PTR 0[BX]\t;FETCH 1ST CHARACTER FROM TEXT\r\n\tCMP\tAL,LOW \"&\"      ;SIGNIFIES SPECIAL INPUT NO.\r\n\tJNZ\tFN40\t\t;IF NOT, PROCEED\r\n\tJMP\t$OHCNS\t\t;OTHERWISE GO PROCESS OCT. OR HEX\r\nFN40:\tCMP\tAL,LOW \"-\"      ;NEGATIVE NUMBER?\r\n\tPUSHF\t\t\t;WILL SAVE ZF FOR POSSIBLE NEGATION\r\n\tJZ\tFN50\t\t;ONCE NUMBER IS FORMED POSITIVE\r\n\tCMP\tAL,LOW \"+\"      ;NEED TO ADVANCE TEXT POINTER FOR\r\n\tJZ\tFN50\t\t;LEADING SIGN\r\n\tDEC\tBX\t\t;\r\nFN50:\tCALL\t$CHRGT\t\t;GET NEXT CHARACTER OF NUMBER\r\n\tJNB\tFN60\t\t;IF NOT DIGIT GO EXAMINE FURTHER\r\nFN55:\tCALL\t$FIDIG\t\t;MUL FAC BY TEN AND ADD IN THE DIGIT\r\n\tJMP\tSHORT FN50\r\nFN60:\r\n\tMOV\tBP,OFFSET $FINCH+7\r\n\tXOR\tDX,DX\t\t;MUST SET EXPONENT TO ZERO\r\n\tMOV\tSI,DX\t\t;FOR SUBSEQUENT CALL TO FINE\r\nFN70:\r\n\tCMP\tAL,BYTE PTR CS:0[BP]\t;CODE SEGMENT\r\n\tJZ\tFN80\t\t;FOUND SPEC CH (.,D,D+40,!,#,%,E,E+40)\r\n\tCMP\tBP,OFFSET $FINCH\t;IF EQUAL NONE OF THE SPECIAL CHARS.\r\n\tJZ\tFN96\t\t;GO FNISH UP NUMBER NON-RECOG. CHAR.\r\n\tDEC\tBP\t\t;PROCEED TO NEXT CHARACTER\r\n\tJMP\tSHORT FN70\t;IF NOT FNISHED LOOK AT NEXT CHAR.\r\nFN80:\tSUB\tBP,OFFSET $FINCH\t;\r\n\tSHL\tBP,1\t\t; BRANCH TABLE ENTRIES 2 BYTES EA\r\nFN90:\r\n\t\t\t\t;CODE SEGMENT OVERRIDE PREFIX\r\n\tJMP\t WORD PTR CS:FN95[BP]\r\nFN95  LABEL WORD\r\n\tDW\tOFFSET FN100\r\n\tDW\tOFFSET FN200\r\n\tDW\tOFFSET FN200\r\n\tDW\tOFFSET FN400\r\n\tDW\tOFFSET FN500\r\n\tDW\tOFFSET FN600\r\n\tDW\tOFFSET FN92\r\n\tDW\tOFFSET FN92\r\nFN92:\t\t\t\t;IT WAS A \"D\"\r\n\tXOR\tAL,AL\t\t;SET CONDITION CODES CORRECTLY\r\nFN94:\tCALL\t$FINEX\t\t;CALCULATE EXPONENT\r\nFN96:\tCALL\t$FINE\t\t;MODIFY NUMBER TO REFLECT EXPONENT\r\n\tJMP\tSHORT FINF\t;CLEAN UP, NEGATE AS NECESSARY\r\nFN100:\t\t\t\t;IT WAS A \".\"\r\n\tINC\tCX\t\t;TO DENOTE DECIMAL POINT DETECTED\r\n\tJNZ\tFN96\t\t;GO FINISH UP NO.-2ED DECIMAL PT. SEEN!\r\n\tCALL\t$GETYP\t\t;IF SNG OR DOUBLE JUST RETURN\r\n\tJNS\tFN50\r\n\tPUSH\tCX\r\n\tPUSH\tBX\r\n\tPUSH\tDI\r\n\tCALL\t$CSI\t\t;CONVERT TO SINGLE PRECISION\r\n\tPOP\tDI\r\n\tPOP\tBX\r\n\tPOP\tCX\r\n\tJMP\tFN50\t\t;GO PROCESS NEXT CHAR.\r\nFN200:\t\t\t\t;IT WAS AN \"E\" OR  \"E\"+40 (LOWER CASE E)\r\n\tCALL\t$CHKEL\t\t;MAKE SURE WE DON'T HAVE AN \"ELSE\"\r\n\tJZ\tFN96\t\t;IT WAS AN \"ELSE\" OR \"EQV\"\r\n\tJMP\tSHORT FN94\t;GO DETERMINE EXPONENT\r\nFN400:\t\t\t\t;IT WAS A \"%\" (INTEGER)\r\n\tINC\tBX\t\t;Eat the percent sign.\r\n\tJMP\tSHORT FN96\t;Call $FINE since could be working\r\n\t\t\t\t;on a floating point.\r\n\r\nFN500:\t\t\t\t;IT WAS A \"#\" (DOUBLE PRECISION)\r\n\tCALL\t$FIND\r\n\tJMP\tSHORT FINF\t;GO FINISH UP\r\nFN600:\t\t\t\t;IT WAS A \"!\"    (SINGLE PRECISION)\r\n\tXOR\tAL,AL\t\t;FLAG AS SINGLE\r\n\tCALL\t$FINS\t\t;FORCE TO SINGLE PRECISION\r\nFINF:\tPOPF\t\t\t;RECALL SIGN FLAG\r\n\tJNZ\tFN990\t\t;RETURN IF NOT NEGATIVE NO.\r\n\tCALL\t$VNEG\t\t;NEGATE NUMBER\r\n\tCALL\t$GETYP\t\t;SET CONDITION CODES ACCORDING TO TYPE\r\n\tJPE\tFN990\t\t;IF NOT SINGLE PRECISION RETURN\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\t$CONI2\t\t;CHECK FOR -32768 AND CONVERT TO INT.\r\n\tPOP\tBX\t\t;RECALL TEXT POINTER\r\n\t\t\t\t;IF FOUND\r\nFN990:\tRET\r\n\r\n\tSUBTTL\t $FPWR/$SQR\t INVOLUTION/SQUARE RT. OF SINGLE PRECISION NOS.\r\n;***********************************************************\r\n;\r\n;       $FPWR   CALCULATES X^Y BY X^Y=EXP(Y*LOG(X))\r\n;\r\n;       CALLING SEQUENCE:       CALL    $FPWR\r\n;               WITH Y IN THE $FAC, X IN (BXDX)\r\n;       $SQR    ENTRY POINT TO PROVIDE SQUARE ROOT FUNCTION\r\n;       CALLING SEQUENCE:       CALL    $SQR\r\n;               WITH ARGUMENT IN $FAC\r\n;\r\n;************************************************************\r\n\r\n;SQUARE ROOT FUNCTION (FAC)=SQR(FAC)\r\nSQR:\r\n$SQR:\r\n\tMOV\tDX,WORD PTR $FAC-2\r\n\tOR\tDH,DH\t\t;Test sign bit\r\n\tJS\tNEGNUM\r\n\tMOV\tAL,BYTE PTR $FAC\t;Get exponent\r\n\tOR\tAL,AL\r\n\tJZ\tDONE\t\t;SQR(0)=0\r\n\tMOV\tBH,BYTE PTR $FAC-3\r\n\tMOV\tBL,LOW 0\r\n\tOR\tDH,LOW 128D\t;Set implied bit\r\n\tSHR\tAL,1\t\t;Divide exponent by two\r\n\tJNB\tEVENEX\t\t;\r\n\tSHR\tDX,1\t\t;HALF MANTISSA IF EXP ODD\r\n\tRCR\tBX,1\r\n\tSTC\t\t\t;RESTORE CARRY FOR ROUND UP\r\nEVENEX:\r\n\tADC\tAL,LOW 100O\t;ADD BACK 1/2 OF BIAS\r\n\tMOV\tBYTE PTR $FAC,AL\t;SAVE FINAL EXPONENT\r\n\tMOV\tCX,25D\t\t;24 BITS PLUS 1 FOR ROUNDING\r\n\tXOR\tBP,BP\t\t;CLEAR SOME REGISTERS\r\n\tMOV\tSI,BP\r\n\tMOV\tDI,BP\r\n\tMOV\tAX,BP\r\nRTLP:\r\n\tSHL\tBX,1\t\t;64 BIT LEFT SHIFT OF INPUT\r\n\tRCL\tDX,1\r\n\tRCL\tDI,1\r\n\tRCL\tBP,1\r\n\tSHL\tBX,1\t\t;SHIFT IT TWICE\r\n\tRCL\tDX,1\r\n\tRCL\tDI,1\r\n\tRCL\tBP,1\r\n\tSTC\t\t\t;ROTATE IN TEST BIT\r\n\tRCL\tSI,1\t\t;32-BIT SHIFT OF PARTIAL RESULT\r\n\tRCL\tAX,1\r\n\tSUB\tDI,SI\t\t;TRY TEST BIT\r\n\tSBB\tBP,AX\r\n\tJNB\tROOTBT\t\t;JUMP OUT IF IT FIT\r\n\tADD\tDI,SI\t\t;RESTORE IF IT DIDN'T\r\n\tADC\tBP,AX\r\n\tDEC\tSI\r\n\tLOOP\tRTLP\r\n\tJMP\tSHORT FPWRND\r\nROOTBT:\r\n\tINC\tSI\t\t;HERE IF TEST BIT FIT\r\n\tLOOP\tRTLP\t\t;SET REAL RESULT BIT AND CONTINUE\r\nFPWRND:\r\n\tSHR\tAX,1\t\t;HALF TO A 25-BIT RESULT\r\n\tRCR\tSI,1\r\n\tSHR\tAX,1\t\t;TO A 24-BIT RESULT\r\n\tRCR\tSI,1\r\n\tADC\tSI,0\t\t;ROUND IF A 1 SHIFTED OUT\r\n\tADC\tAX,0\t\t;AND PROPAGATE CARRY\r\n\tMOV\tWORD PTR $FAC-3,SI\t;STORE RESULT\r\n\tAND\tAL,LOW 177O\t;CLEAR SIGN BIT\r\n\tMOV\tBYTE PTR $FAC-1,AL\t;AND STORE\r\nDONE:\tRET\r\n\r\nNEGNUM: JMP\t$FCERR\r\n\r\n$FPWR:\t\t\t\t;INVOLUTION ($FAC):=(BXDX)^($FAC)\r\n\t\t\t\t;OR         (FAC)=X^Y\r\n\tMOV\tDI,OFFSET $CLROV\r\n\tPUSH\tDI\r\n\tMOV\tDI,OFFSET $FLGOV\r\n\tMOV\tBYTE PTR 0[DI],LOW 1\t;ONCE-ONLY OVERFLOW MODE\r\n\tCALL\t$SIGNS\t\t;SEE IF Y IS ZERO\r\n\tJNZ\tFP10\r\n\tJMP\t$EXP\t\t;ANS IS 1 IF Y=0\r\nFP10:\tJNS\tFP20\t\t;IF NEGATIVE POTENTIAL OVERFLOW\r\n\tOR\tBH,BH\t\t;IF X IS ZERO\r\n\tJNZ\tFP25\r\n\tJMP\t$DIV0S\t\t;DIVIDE-BY-ZERO CODE\r\nFP20:\tOR\tBH,BH\t\t;SEE IF ZERO TO POWER\r\n\tJNZ\tFP25\r\n\tJMP\t$ZERO\t\t;ANS IS ZERO\r\nFP25:\t\t\t\t;WE KNOW AT THIS POINT THAT X IS NON-ZERO. IF X IS NEGATIVE\r\n\t\t\t\t;THEN Y MUST BE AN INTEGRAL POWER OR WE HAVE A FUNCTION\r\n\t\t\t\t;CALL ERROR\r\n\tOR\tBL,BL\t\t;IS X NEGATIVE?\r\n\tJNS\tFP30\t\t;IF NOT PROCEED\r\n\tCMP\tBYTE PTR $FAC,LOW 231\t;SEE IF Y TOO LARGE TO DETERMINE SIGN\r\n\t\t\t\t;OF INVOLUTION RESULT\r\n\tJB\tFP27\t\t;JUMP IF OK TO COMPUTE\r\n\tJMP\t$FCERR\r\nFP27:\r\n\tPUSH\tDX\t\t;SAVE X ON THE STACK\r\n\tPUSH\tBX\r\n\tPUSH\tWORD PTR $FACLO ;PUSH Y ON THE STACK\r\n\tPUSH\tWORD PTR $FACM1\r\n\tCALL\t$INT\t\t;MAKE Y AN INTEGER\r\n\tPOP\tBX\t\t;Y TO THE REGISTERS\r\n\tPOP\tDX\r\n\tCALL\t$FCOMP\t\t;SEE IF Y IS AN INTEGER\r\n\tCALL\t$MOVFR\t\t;MOVE ORIGINAL Y BACK TO FAC\r\n\tPOP\tBX\t\t;RECALL X\r\n\tPOP\tDX\r\n\tJZ\tFP30\t\t;PROCEED IF Y IS AN INTEGER\r\n\tJMP\t$FCERR\t\t;OTHERWISE WE HAVE FCN CALL ERROR\r\nFP30:\tMOV\tAL,BYTE PTR $FAC-1\t;NEED TO KNOW IF Y IS NEGATIVE\r\n\tOR\tAL,AL\r\n\tJNS\tFP30A\t\t;Y POSITIVE\r\n\tAND\tAL,LOW 177\t;Y is negative - will invert when\r\n\tMOV\tBYTE PTR $FAC-1,AL\t;finished.  Clear the sign bit of Y.\r\n\tPUSH\tBX\t\t;Save the sign of X.\r\n\tPUSH\tWORD PTR $FACM1 ;Save Y.\r\n\tPUSH\tWORD PTR $FACLO\r\n\tCALL\tFP30A\t\t;FAC:=X^positive Y.\r\n\tTEST\tBYTE PTR $FAC,LOW 377O\t;Did it underflow?\r\n\tJNZ\tINVERT\t\t;No, go invert it.\r\n\tPOP\tWORD PTR $FACLO ;Yes, pop Y into the FAC.\r\n\tPOP\tWORD PTR $FACM1\r\n\tCALL\t$QINT\t\t;Get least significant byte of Y\r\n\t\t\t\t;into DL.\r\n\tPOP\tBX\t\t;Get sign of X into BL bit 7.\r\n\tROR\tDL,1\t\t;Set sign bit of FAC if X is negative\r\n\tAND\tBL,DL\t\t;and Y is odd.\r\n\tMOV\tBYTE PTR $FAC+1,BL\r\n\tMOV\tBH,LOW 377O\t;Make BH nonzero for DOINF routine\r\n\t\t\t\t;(which is called by $OVFLS) so it uses\r\n\t\t\t\t;$FAC+1 to determine the sign of the\r\n\t\t\t\t;inifinity to use.\r\n\tJMP\t$OVFLS\t\t;Give Overflow error with and return\r\n\t\t\t\t;appropriate (negative or positive)\r\n\t\t\t\t;inifinity based on the sign just\r\n\t\t\t\t;put into the FAC.\r\n\r\nINVERT: ADD\tSP,6\t\t;Pop off the garbage.\r\n\tMOV\tDX,0\t\t;BXDX:=1.0.\r\n\tMOV\tBX,100400\r\n\tJMP\t$FDIVS\t\t;Invert the result and return.\r\n\r\nFP30A:\r\n\tPUSH\tBX\t\t;SAVE X ON THE STACK\r\n\tPUSH\tDX\r\n\tOR\tBL,LOW 177\t;SET CODES TO REFLECT SIGNS OF X\r\n\tPUSHF\t\t\t;SAVE X POS/NEG INFORMATION\r\n\tPUSH\tWORD PTR $FACM1 ;PUSH Y ON THE STACK\r\n\tPUSH\tWORD PTR $FACLO\r\n\tCALL\t$INT\t\t;MUST DETERMINE IF Y IS AN INTEGER\r\n\tPOP\tDX\t\t;RECALL ORIGINAL Y\r\n\tPOP\tBX\r\n\tCALL\t$FCOMP\t\t;ZF=1 IF Y IS AN INTEGER\r\n\tJNZ\tFP34\t\t;IF NOT INTEGER PROCEED AS NORMAL\r\n\tPUSH\tDX\t\t;SAVE Y\r\n\tPUSH\tBX\r\n\tMOV\tDX,0\t\t;WILL MAKE (BXDX) 32768.\r\n\tMOV\tBX,110000\r\n\tCALL\t$FCOMP\t\t;SEE IF TOO LARGE\r\n\tPOP\tBX\t\t;RECALL Y\r\n\tPOP\tDX\r\n\tJNS\tFP34\t\t;AND IF SO COMPUTE WITH LOG & EXP\r\n\tPOPF\t\t\t;GET X POS/NEG INFO OFF STACK\r\n\tPOP\tDX\t\t;GET X TO REGISTERS\r\n\tPOP\tBX\r\n\tJMP\tXTON\t\t;AND COMPUTE X^N\r\n\r\nFP34:\tPOPF\t\t\t;GET X POS/NEG INFORMATION\r\n\tJNS\tFP40\t\t;NO PROBS IF X IS POSITIVE\r\n\tPUSH\tBX\t\t;SAVE Y ON THE STACK\r\n\tPUSH\tDX\r\n\tCALL\t$QINT\t\t;NEED EVEN-ODD INFORMATION\r\n\tMOV\tAL,DL\t\t;GET LOW BYTE OF INTEGER\r\n\tCALL\t$NORMS\t\t;($FAC)=INT(Y)\r\n\tPOP\tDX\t\t;RECALL Y\r\n\tPOP\tBX\r\n\tRCR\tAL,1\t\t;CF=1 IF ODD\r\nFP40:\tPOP\tWORD PTR $FACLO ;GET X TO FAC\r\n\tPOP\tWORD PTR $FACLO+2\r\n\tLAHF\t\t\t;SAVE EVEN/ODD INFO\r\n\tAND\tBYTE PTR $FACM1,LOW 177 ;CLEAR ANY SIGN BIT\r\n\tSAHF\t\t\t;GET EVEN/ODD INFO\r\n\tJNB\tFP60\r\n\tMOV\tDI,OFFSET $NEG\r\n\tPUSH\tDI\t\t;WILL NEGATE AT THE END IF CF=1\r\nFP60:\tPUSH\tBX\t\t;SAVE Y AGAIN\r\n\tPUSH\tDX\r\n\tCALL\t$LOG\t\t;LOG(X)\r\n\tPOP\tDX\t\t;RECALL Y\r\n\tPOP\tBX\r\n\tCALL\t$FMULS\t\t;($FAC)=Y*LOG(X)\r\n\tJMP\t$EXP\t\t;COMPLETE CALCULATION\r\n;**************************************************************\r\n;       ($FAC)=($FAC)^(BXDX)\r\n;WHERE (BXDX) IS AN INTEGER SUCH THAT 0.LT.(BXDX).LE.32767\r\n;\r\n;OR AS IN KNUTH X**N IS AS FOLLOWS\r\n;THE ALGORITHM IS TAKEN FROM KNUTH VOL2 P400\r\n;A1.Y=1, Z=X\r\n;A2.HALVE N AND DETERMINE IF N WAS EVEN OR ODD. IF N WAS EVEN\r\n;   THEN JUMP TO A4.\r\n;A3.Y=Y*Z\r\n;A4.IF N = 0 FINISHED WITH Y THE ANSWER\r\n;A5.Z=Z*Z AND RETURN TO A2\r\n;***************************************************************\r\nXTON:\t\t\t\t;($FAC):=(BXDX)^($FAC)\r\n\tPUSH\tBX\t\t;SAVE X ON STACK\r\n\tPUSH\tDX\r\n\tCALL\t$QINT\t\t;CONVERT TO INTEGER\r\n\tMOV\tWORD PTR $ARG,DX\t;N TO $ARG\r\n\tMOV\tWORD PTR $FACLO,0\t;WILL MOVE 1.0 TO FAC\r\n\tMOV\tWORD PTR $FACM1,100400\t;\r\nXTON10: SHR\tWORD PTR $ARG,1 ;SHIFT RIGHT 1 BIT\r\n\tJNB\tXTON20\t\t;IF NO MULTIPLY THEN Z=Z**2\r\n\tPOP\tDX\t\t;FETCH Z\r\n\tPOP\tBX\r\n\tPUSH\tBX\t\t;AND PUT IT BACK ON STACK\r\n\tPUSH\tDX\r\n\tCALL\t$FMULS\t\t;Y=Y*Z\r\nXTON20: TEST\tWORD PTR $ARG,177777\t;SEE IF N HAS GONE TO ZERO\r\n\tJZ\tXTON30\t\t;GET OUT IF FINISHED\r\n\tPOP\tDX\t\t;FETCH Z TO REGISTERS\r\n\tPOP\tBX\r\n\tCALL\t$PUSHF\t\t;Y TO STACK\r\n\tCALL\t$MOVFR\t\t;Z TO FAC\r\n\tCALL\t$FMULS\t\t;Z=Z*Z\r\n\tPOP\tDX\t\t;FETCH Y\r\n\tPOP\tBX\r\n\tCALL\t$PUSHF\t\t;NEW Z TO STACK\r\n\tCALL\t$MOVFR\t\t;Y TO FAC\r\n\tJMP\tSHORT XTON10\t;TRY AGAIN\r\nXTON30: POP\tDX\t\t;GET STACK CLEAR OF Z\r\n\tPOP\tBX\r\n\tRET\r\n\r\n\tSUBTTL\t F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK\r\n\r\n\r\n\r\n$CHRGT: JMP\tCHRGTR\r\nDSUB:\r\n\tXOR\tBYTE PTR $FAC-1,LOW 200 ;WILL FLIP SIGNS OF EACH ARGUMENT\r\n\tXOR\tBYTE PTR $ARG-1,LOW 200\r\n\tJMP\t$FSUBD\r\nFADD:\r\n\tXCHG\tBX,CX\r\n\tJMP\t$FADDS\r\nFSUB:\r\n\tXCHG\tBX,CX\r\n\tJMP\t$FSUBS\r\nFDIV:\tXCHG\tBX,CX\r\n\tJMP\t$FDIVS\r\nCONSIH:\r\n\tMOV\tWORD PTR $FACLO,BX\r\n\tJMP\t$CSI\r\nFLOAT:\r\n\tPUSH\tDX\r\n\tCBW\r\n\tMOV\tDX,AX\r\n\tCALL\t$FLT\r\n\tPOP\tDX\r\n\tRET\r\nFMULT:\r\n\tXCHG\tBX,CX\r\n\tJMP\t$FMULS\r\nFPWR:\r\n\tXCHG\tBX,CX\r\n\tJMP\t$FPWR\r\n\r\n;*************************************************************\r\n;INTEGER ARITHMETIC FOLLOWS\r\n;*************************************************************\r\nISUB:\t\t\t\t;(BX)=(DX)-(BX)\r\n\tCMP\tBX,100000\t;CHECK FOR -32768\r\n\tJNZ\tIS10\t\t;PROCEED IF NOT\r\n\tCALL\t$FLT\t\t;FLOAT DX\r\n\tXOR\tDX,DX\t\t;WILL SET (BXDX)=-32768.0\r\n\tMOV\tBX,110200\r\n\tCALL\t$FSUBS\t\t;DO SUBTRACT\r\n\tCALL\t$NEG\t\t;NEGATE\r\n\tJMP\t$FI\r\nIS10:\r\n\tNEG\tBX\t\t;NEGATE AND FALL INTO ADD\r\n\r\nIADD:\t\t\t\t;(BX)=(DX)+(BX)\r\n\tPUSH\tBX\t\t;SAVE 1ST ARG\r\n\tADD\tBX,DX\r\n\tJO\tIAD10\t\t;IF OVERFLOW JUMP\r\n\tPOP\tAX\t\t;CLEAR STACK\r\n\tJMP\tMAKINT\r\nIAD10:\r\n\tCALL\t$FLT\t\t;FLOAT 2ED ARG\r\n\tPOP\tDX\t\t;RECALL FIRST ARG\r\n\tPUSH\tWORD PTR $FACLO\r\n\tPUSH\tWORD PTR $FAC-1 ;FAC PUSHED ON THE STACK\r\n\tCALL\t$FLT\t\t;FLOAT 2ED ARG\r\n\tPOP\tBX\r\n\tPOP\tDX\t\t;GET 2ED ARG TO (BXDX)\r\n\tJMP\t$FADDS\t\t;GO ADD FLOATING\r\n\r\nIMULT:\t\t\t\t;(BX)=(BX)*(DX)\r\n\tMOV\tAX,BX\r\n\tPUSH\tDX\t\t;SAVE 2ED ARG\r\n\tIMUL\tDX\t\t;PERFORM MULTIPLICATION\r\n\tPOP\tDX\t\t;RECALL 2ED ARG\r\n\tJB\tIM10\t\t;MUST FLOAT ARGS IF CF=1\r\n\tMOV\tBX,AX\r\n\tJMP\tMAKINT\r\nIM10:\r\n\tPUSH\tBX\t\t;SAVE FIRST ARG\r\n\tCALL\t$FLT\t\t;FLOAT 2ED ARG\r\n\tPOP\tDX\t\t;RECALL 1ST ARG\r\n\tPUSH\tWORD PTR $FACLO\r\n\tPUSH\tWORD PTR $FAC-1\r\n\tCALL\t$FLT\t\t;FLOAT 1ST ARG\r\n\tPOP\tBX\r\n\tPOP\tDX\t\t;GET 2ED ARG TO (BXDX)\r\n\tJMP\t$FMULS\t\t;GO MULTIPLY FLOATING\r\n\r\nIDIV:\t\t\t\t;(BX)=(DX)/(BX)\r\n\tOR\tBX,BX\t\t;MAKE SURE ITS NON-ZERO\r\n\tJNZ\tIDIV10\r\n\tMOV\tBYTE PTR $FAC+1,DH\t;FOR CORRECT SIGN\r\n\tINC\tBH\t\t; Hack for DOINF to work\r\n\tMOV\tBYTE PTR $VALTP,LOW 4\r\n\tJMP\t$DIV0S\r\nIDIV10:\r\n\tCMP\tDX,100000\t;CHECK FOR -32768\r\n\tJNZ\tIDIV15\t\t;PROCEED IF NOT\r\n\tCMP\tBX,177777\t;Check for special case of -32768\\-1\r\n\tJNE\tIDIV11\r\n\tCALL\t$FLT\t\t;FLOAT DX\r\n\tCALL\t$NEG\r\n\tRET\r\nIDIV11:\r\n\tCMP\tBX,1\t\t;Other special case\r\n\tJNE\tIDIV15\r\n\tMOV\tBX,DX\t\t;Put -32768\\1 = -32768 in BX so we can ...\r\n\tJMP\tMAKINT\t\t;Return it as an Int. (IDIV doesn't work)\r\nIDIV15:\r\n\tMOV\tWORD PTR $FACLO,BX\t;WILL PERFORM (DX:AX)/(FAC)\r\n\tMOV\tAX,0\r\n\tMOV\tWORD PTR $FACM1,AX\r\n\tXCHG\tAX,DX\t\t;GET NO RT. ADJUSTED IN AX\r\n\tOR\tAX,AX\r\n\tJNS\tIDV20\r\n\tMOV\tDX,177777\t;SIGN EXTEND INTO DX\r\nIDV20:\tOR\tBX,BX\t\t;SEE IF DENOMINATOR NEEDS SIGN EXT\r\n\tJNS\tIDV30\r\n\tMOV\tWORD PTR $FACM1,177777\r\nIDV30:\tIDIV\tWORD PTR $FACLO ;16 BIT DIVIDE\r\n\tMOV\tBX,AX\r\n\tJMP\tMAKINT\r\n\r\nMOVFR:\tXCHG\tBX,CX\r\n\tCALL\t$MOVFR\t\t;MOVE TO FAC\r\n\tXCHG\tBX,CX\t\t;GET REGISTERS RIGHT\r\n\tRET\r\nMOVFM:\tPUSH\tBX\r\n\tCALL\t$MOVFM\r\n\tPOP\tBX\r\n\tADD\tBX,4\r\n\tRET\r\nMOVRF:\tMOV\tDX,WORD PTR $FACLO\r\n\tMOV\tCX,WORD PTR $FAC-1\r\n\tRET\r\nMOVMF:\tPUSHF\r\n\tPUSH\tBX\r\n\tCALL\t$MOVMF\r\n\tPOP\tBX\r\n\tADD\tBX,4\r\n\tPOPF\r\n\tRET\r\nFOUTO:\tCALL\tFRQINT\r\n\tMOV\tWORD PTR $FACLO,BX\r\n\tJMP\t$FOUTO\r\nFOUTH:\tCALL\tFRQINT\r\n\tMOV\tWORD PTR $FACLO,BX\r\n\tJMP\t$FOUTH\r\nFADDS:\t\t\t\t;ADD NO. POINTED TO BY (BX) TO (FAC)\r\n\tMOV\tDX,WORD PTR 0[BX]\r\n\tMOV\tBX,WORD PTR 2[BX]\r\n\tJMP\t$FADDS\r\nPUSHF:\tPOP\tSI\t\t;GET OUR RETURN ADDRESS OFF STACK\r\n\tPUSH\tWORD PTR $FACLO\r\n\tPUSH\tWORD PTR $FAC-1\r\n\tJMP\tSI\r\nFCOMP:\r\n\tXCHG\tBX,CX\r\n\tCALL\t$FCOMP\r\n\tXCHG\tBX,CX\r\n\tRET\r\nFRCSTR:\r\nCHKSTR: CALL\t$GETYP\t\t;WANT TO ASSURE STRING\r\n\tJZ\tCH10\r\n\tJMP\tTMERR\r\nCH10:\tRET\r\nINEG2:\tXCHG\tBX,DX\r\n\tCALL\tVALSNG\r\n\tXOR\tAL,AL\r\nINEGAD: MOV\tCH,LOW 230\r\nFLOATR:\r\n\tMOV\tBX,OFFSET $FAC\r\n\tMOV\tCL,AL\r\n\tMOV\tBYTE PTR 0[BX],CH\r\n\tMOV\tCH,LOW 0\t;ZERO OVERFLOW BYTE\r\n\tINC\tBX\r\n\tMOV\tBYTE PTR 0[BX],CH\r\n\tRCL\tAL,1\r\nFADFLT:\r\n\tJNB\tFL10\r\n\tCALL\tNEGR\r\nFL10:\tMOV\tAH,CH\t\t;OVERFLOW BYTE TO AH\r\n\tMOV\tBL,CL\t\t;BL IS HIGH MANTISSA BIT\r\n\tJMP\t$NORMS\r\nRNDMON: CALL\t$CHRGT\r\nRNDMN2: PUSH\tBX\r\n\tXOR\tBX,BX\t\t;WILL SET FAC TO 1.0\r\n\tMOV\tWORD PTR $FACLO,BX\r\n\tMOV\tBH,LOW 201\r\n\tMOV\tWORD PTR $FACM1,BX\r\n\tMOV\tBYTE PTR $VALTP,LOW 4\t;SET CORRECT TYPE\r\n\tCALL\t$RND\r\n\tPOP\tBX\r\n\tMOV\tBYTE PTR $VALTP,LOW 4\r\n\tRET\r\nUMULT:\tMOV\tAX,CX\t\t;WILL FORM (DX)=(CX)*(DX)\r\n\tMUL\tDX\r\n\tXCHG\tAX,DX\r\n\tJNB\tUM10\r\n\tJMP\tBSERR\r\nUM10:\tRET\r\nVMOVFA: MOV\tBX,OFFSET $ARGLO\r\nVMOVFM: MOV\tDX,OFFSET MOVVFM\r\n\tJMP\tVMVVFM\r\nVMOVAF: MOV\tBX,OFFSET $ARGLO\r\nVMOVMF: MOV\tDX,OFFSET VMOVE\r\nVMVVFM: PUSH\tDX\r\nVDFACS: MOV\tDX,OFFSET $FACLO\r\n\tCALL\t$GETYP\r\n\tJB\tVD15\r\nVD10:\tMOV\tDX,OFFSET $DFACL\r\nVD15:\tRET\r\nMOVE1:\tMOV\tCL,CH\r\n\tXOR\tCH,CH\r\n\tJMP\tSHORT F4VM10\t;MOVE FOR BASIC INTERPRETER\r\nMOVVFM: XCHG\tBX,DX\r\nVMOVE:\tMOV\tAL,BYTE PTR $VALTP\r\n\tCBW\r\n\tMOV\tCX,AX\r\nF4VM10: CLD\t\t\t;SO WE WILL INCREMENT\r\n\tMOV\tSI,DX\r\n\tMOV\tDI,BX\r\n REP\tMOVSB\r\n\tMOV\tDX,SI\r\n\tMOV\tBX,DI\r\n\tRET\r\n\r\n;\r\n; THIS IS THE BLOCK TRANSFER ROUTINE\r\n; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD\r\n;\r\n; BX = DESTINATION OF HIGH ADDRESS\r\n; DX = LOW ADDRESS TO BE TRANSFERRED\r\n; CX = HIGH ADDRESS TO BE TRANSFERRED\r\n;\r\n; A CHECK IS MADE TO MAKE SURE A REASONABLE AMOUNT\r\n; OF SPACE REMAINS BETWEEN THE TOP OF THE STACK AND\r\n; THE HIGHEST LOCATION TRANSFERRED INTO\r\n;\r\n; ON EXIT BX=DX=LOW CX=LOCATION LOW WAS MOVED INTO\r\n;\r\nBLTU:\tCALL\tREASON\t\t;CHECK DESTINATION TO MAKE SURE\r\n\t\t\t\t;STRING SPACE WONT BE OVERWRITTEN\r\nBLTUC:\tMOV\tSI,CX\t\t;SET UP HIGH ADDRESS\r\n\tMOV\tDI,BX\t\t;SET UP DESTINATION OF HIGH ADDRESS\r\n\tSTD\t\t\t;MOVE DOWN\r\n\tSUB\tCX,DX\t\t;GET COUNT OF BYTES TO TRANSFER\r\n\tINC\tCX\t\t;ALWAYS MOVE ONE BYTE\r\n REP\tMOVSB\t\t\t;MOVE BYTES\r\n\tMOV\tBX,DX\t\t;BX=LOW\r\n\tMOV\tCX,DI\t\t;CX=DESTINATION OF LOW\r\n\tINC\tCX\t\t;CORRECT AS DECREMENTED ONE TOO MANY\r\n\tCLD\t\t\t;SET DIRECTION BIT TO UP\r\n\tRET\r\n\r\nDCXBRT: PUSHF\r\n\tDEC\tCX\r\n\tPOPF\r\n\tRET\r\nVSIGN:\tCALL\t$GETYP\t\t;DETERMINE TYPE\r\n\tJNZ\tVS10\t\t;IF NOT STRING PROCEED\r\n\tJMP\tTMERR\r\nVS10:\r\n\tJS\tISI10\r\n\tJMP\t$SIGNS\t\t;SINGLE OR DOUBLE PRECISION\r\nISI10:\tMOV\tAX,WORD PTR $FACLO\t;GET THE INTEGER\r\n\tOR\tAX,AX\t\t;SET SIGNS CORRECTLY\r\n\tJZ\tISIGN1\r\nISI15:\tMOV\tAL,LOW 1\r\n\tJNS\tISIGN1\r\n\tMOV\tAL,LOW 377\r\nISIGN1: RET\r\nISIGN:\tXOR\tAX,AX\t\t;IN CASE (BX) IS ZERO\r\n\tOR\tBX,BX\t\t;NEED SIGN OF (BX)\r\n\tJNZ\tISI15\r\n\tRET\r\nPOPHRT: POP\tBX\r\n\tRET\r\nCONIA:\t\t\t\t;CONVERT NO. IN A TO AN INTEGER\r\n\tCBW\r\n\tMOV\tBX,AX\r\nMAKINT: MOV\tBYTE PTR $VALTP,LOW 2\t;MAKE INTEGER\r\n\tMOV\tWORD PTR $FACLO,BX\t;STORE INTEGER IN $FAC\r\n\tRET\r\nVALSNG: MOV\tBYTE PTR $VALTP,LOW 4\r\n\tRET\r\nSGN:\tCALL\tVSIGN\r\n\tJMP\tCONIA\r\nFDIVT:\r\n\tPOP\tBX\r\n\tPOP\tDX\r\n\tJMP\t$FDIVS\r\nFPWRQ:\tCALL\t$FS\t\t;FORCE FAC TO SP\r\nFPWRT:\tPOP\tBX\r\n\tPOP\tDX\r\n\tJMP\t$FPWR\r\nMOVE:\tMOV\tCX,4\r\n\tJMP\tF4VM10\r\nMOVRM:\tPUSHF\r\n\tMOV\tDL,BYTE PTR 0[BX]\r\n\tINC\tBX\r\n\tPOPF\r\nGETBCD: PUSHF\r\n\tMOV\tDH,BYTE PTR 0[BX]\r\n\tINC\tBX\r\n\tMOV\tCX,WORD PTR 0[BX]\r\n\tINC\tBX\r\n\tPOPF\r\nINXHRT: PUSHF\r\n\tINC\tBX\r\n\tPOPF\r\n\tRET\r\nINPRT:\tPUSH\tBX\r\n\tMOV\tBX,OFFSET INTXT\r\n\tCALL\tSTROUT\r\n\tPOP\tBX\r\nLINPRT: MOV\tCX,OFFSET STROUI\r\n\tPUSH\tCX\r\nLINOUT: CALL\tMAKINT\r\n\tXOR\tAL,AL\r\nFOUINI:\r\n\tMOV\tBYTE PTR TEMP3,AL\r\n\tMOV\tBX,OFFSET $FBUFF+1\r\n\tMOV\tBYTE PTR 0[BX],LOW \" \"\r\n\tOR\tAL,BYTE PTR 0[BX]\r\n\tINC\tBX\r\n\tMOV\tBYTE PTR 0[BX],LOW \"0\"\r\n\tJMP\t$FOUT2\r\nSIGNC:\r\n\tMOV\tAL,BYTE PTR $FAC-1\r\n\tJMP\tSHORT ICOMPS\r\nDCOMP:\r\n\tCALL\t$DCMPA\r\n\tJZ\tSG15\r\n\tNOT\tAL\r\nICOMPS: SAL\tAL,1\r\nSIGNS:\tSBB\tAL,AL\r\n\tJZ\tINRART\r\nSG15:\tRET\r\nNEGR:\r\n\tXOR\tBYTE PTR $FAC+1,LOW 200 ;FLIP SIGN\r\n\tXOR\tBX,BX\t\t;WILL NEED THIS ZERO REGISTER\r\n\tNEG\tCH\r\n\tMOV\tAX,BX\r\n\tSBB\tAX,DX\t\t;DO MIDDLE BYTES\r\n\tMOV\tDX,AX\t\t;AND REPLACE\r\n\tMOV\tAL,BL\r\n\tSBB\tAL,CL\r\n\tMOV\tCL,AL\r\nNG10:\tRET\r\nFIXER:\r\n\tCALL\t$GETYP\r\n\tJS\tNG10\r\n\tCALL\t$SIGNS\r\n\tJS\tF4FX20\r\n\tJMP\t$VINT\r\nF4FX20: CALL\t$NEG\r\n\tCALL\t$VINT\r\n\tJMP\t$NEG\r\nICOMP:\t\t\t\t;COMPARE (DX) AND (BX)\r\n\t\t\t\t;(AL)=1 IF (DX) .LT. (BX)\r\n\t\t\t\t;(AL)=0 IF (DX) = (BX)\r\n\t\t\t\t;(AL)=-1 IF (DX) .GT. (BX)\r\n\tMOV\tAX,BX\t\t;SO WE CAN HAVE SEPARATE ENTRY FOR AX\r\nICMPA:\tSUB\tAX,DX\t\t;COMPARISONS\r\n\tJZ\tIC40\t\t;ALL OK , JUST EXIT\r\n\tJO\tIC20\t\t;IF SF=1 ADDITIONALLY THEN AX LARGER\r\n\tJS\tIC30\t\t;DX DEFINITELY LARGER\r\nIC10:\tXOR\tAL,AL\t\t;(AX) LARGER\r\nINRART: INC\tAL\t\t;(AL)=1\r\nIC15:\tRET\r\nIC20:\tJS\tIC10\r\nIC30:\tSTC\r\n\tSBB\tAL,AL\t\t;(AL)=377\r\nIC40:\tRET\r\nIMOD:\tCMP\tBX,DX\t\t;IF EQUAL RETURN ZERO\r\n\tJNZ\tIMD10\r\nIMD05:\tXOR\tBX,BX\r\n\tJMP\tIMD40\r\nIMD10:\t\t\t\t;(BX)= (DX) MOD (BX)\r\n\tCMP\tDX,100000\t;CHECK FOR -32768\r\n\tJNZ\tIMD15\t\t;PROCEED IF NOT\r\n\tCMP\tBX,177777\t;Check for special case of -32768 MOD -1\r\n\tJE\tIMD05\r\n\tCMP\tBX,1\t\t;Also for -32768 MOD 1\r\n\tJE\tIMD05\r\nIMD15:\r\n\tMOV\tAX,DX\r\n\tMOV\tWORD PTR $FACLO,BX\r\n\tOR\tBX,BX\r\n\tJNZ\tIMD17\t\t; Trying to divide by zero?\r\n\tMOV\tBYTE PTR $FAC+1,DH\t; Yep, set up correct sign\r\n\tINC\tBH\t\t; Hack for DOINF to work\r\n\tMOV\tBYTE PTR $VALTP,LOW 4\r\n\tJMP\t$DIV0S\r\nIMD17:\r\n\tMOV\tWORD PTR $FAC-1,0\r\n\tJNS\tIMD20\r\n\tMOV\tWORD PTR $FAC-1,177777\r\nIMD20:\tOR\tAX,AX\r\n\tMOV\tDX,0\r\n\tJNS\tIMD30\r\n\tMOV\tDX,177777\r\nIMD30:\tIDIV\tWORD PTR $FACLO\r\n\tMOV\tBX,DX\t\t;MOVE MOD TO BX\r\nIMD40:\tMOV\tWORD PTR $FACLO,BX\r\n\tRET\r\n\r\n\r\n; THIS IS THE INNER LOOP OF SYMBOL TABLE SEARCHING FOR NON-SUBSCRIPTED\r\n; VARIABLES.\r\n;\r\n; Note 9-Aug-82/MLC - Entry is made at LOPFND, which does a CLD.\r\n; Want this code to be fast so don't only do this one CLD for the\r\n; entire piece of code.\r\n;\r\n\r\nLOPTOP: LODSW\t\t\t;GET VALTYP IN [AL], 1ST CHAR IN [AH]\r\n\tCMP\tAH,CL\t\t;SAME 2ND CHAR?\r\n\tJZ\tISIT\t\t;YES MAY BE VAR WERE LOOKING FOR\r\nNOTIT1: INC\tSI\t\t;POINT AT LENGTH OF REST OF VAR CHARS\r\n\tADD\tAL,BYTE PTR 0[SI]\t;ADD FURTHUR OFFSET\r\n\tINC\tAL\t\t;PLUS ONE\r\nNOTIT0: CBW\t\t\t;SIGN EXTEND IT\r\n\tADD\tSI,AX\t\t;MOVE TO NEXT VARIABLE\r\nNOTIT2: CMP\tSI,BP\t\t;DONE WITH SYMBOL TABLE SEARCH?\r\n\tJNZ\tLOPTOP\t\t;NO, KEEP LOOKING\r\n\tMOV\tDX,SI\t\t;POINT AFTER VAR\r\n\tJMP\tNOTFNS\t\t;SEE IF SEARCHED ALL TABLES\r\n\r\nISIT:\tCMP\tAL,BYTE PTR VALTYP\t;VALTYP'S THE SAME?\r\n\tJNZ\tNOTIT1\t\t;NO, LOOK AT NEXT VAR\r\n\tCMP\tCH,BYTE PTR 0[SI]\t;2ND CHAR OF VAR THE SAME?\r\n\tJNZ\tNOTIT1\t\t;NO, KEEP LOOKING\r\n\tINC\tSI\t\t;POINT TO VALTYP\r\n\tMOV\tDL,AL\t\t;GET IN IN [DL]\r\n\tLODSB\t\t\t;GET VALTYP IN [AL]\r\n\tCMP\tAL,BYTE PTR NAMCNT\t;SAME AS VAR WERE LOOKING FOR?\r\n\tJZ\tLENMAT\t\t;LENGTHS MATCH!\r\n\tADD\tAL,DL\t\t;ADD SAVED VALTYP AND LENGTH OF VAR\r\n\tJMP\tSHORT NOTIT0\t;GO TO NEXT VAR\r\n\r\nLENMAT: OR\tAL,AL\t\t;LENGTH ZERO?\r\n\tJZ\tFNDITV\t\t;YES, FOUND IT!\r\n\tCBW\t\t\t;MAKE LENGTH A WORD\r\n\tXCHG\tCX,AX\t\t;SAVE 2 CHARS OF VAR, PUT LENGTH IN CX\r\n\tMOV\tDI,OFFSET NAMBUF\t;POINT TO NAME BUFFER\r\n\t\t     ;COMPARE TWO VAR NAMES\r\n REP\tCMPSB\t\t\t;WITH SPECIAL INSTR\r\n\tXCHG\tAX,CX\t\t;FLIP BACK\r\n\tJZ\tFNDITV\t\t;FOUND IT\r\n\tADD\tSI,AX\t\t;ADD CHARS LEFT, CC'S SHOULD BE NON-ZERO\r\n\tMOV\tAL,DL\t\t;GET BACK SAVED VALTYP\r\n\tJMP\tSHORT NOTIT0\t;PROCEED WITH FAILED SEARCH\r\nFNDITV: MOV\tDX,SI\t\t;GET POINTER TO VAR IN [DX]\r\n\tPOP\tBX\t\t;RESTORE TEXT POINTER\r\n\tRET\t\t\t;ALL DONE!!!\r\n\r\nLOPFND: MOV\tSI,BX\t\t;START SEARCHING HERE\r\n\tMOV\tBP,WORD PTR ARYTA2\t;LIMIT OF VARIABLE SEARCH\r\n\tCLD\t\t\t;INCREMENT\r\n\tJMP\tSHORT NOTIT2\t;START LOOKING\r\n\r\n\r\n; THIS IS THE CORRESPONDING CODE FOR ARRAY SEARCHES\r\n; Note 9-Aug-82/MLC - This code is supposed to be fast so only a\r\n; single CLD is done here for the entire piece of code.\r\n;\r\n\r\nLOPFD1: MOV\tSI,BX\t\t;INITIALIZE POINTER TO SYMBOL TABLE\r\n\tMOV\tBP,WORD PTR STREND\t;GET LIMIT OF SEARCH\r\n\tCLD\t\t\t;SET DIRECTION RIGHT\r\n\tJMP\tLOPFDI\t\t;START SEARCHING\r\nLOPFD0: LODSW\t\t\t;GET VALTYP AND 1ST CHAR OF VAR\r\n\tCMP\tAH,CL\t\t;ARE FIRST CHARS THE SAME?\r\n\tJZ\tISARY\t\t;YES, COULD BE RIGHT ONE\r\nNMARY1: INC\tSI\t\t;POINT TO LENGTH OF VAR\r\nNMARY2: LODSB\t\t\t;GET LENGTH OF IT\r\nNMARY3: CBW\t\t\t;EXTEND SIGN\r\n\tADD\tSI,AX\t\t;ADD OFFSET\r\nNMARY4: LODSW\t\t\t;GET OFFSET TO ARRAY\r\n\tADD\tSI,AX\t\t;POINT TO NEXT ARRAY\r\nLOPFDI: CMP\tBP,SI\t\t;AT END OF ARRAYS?\r\n\tJNZ\tLOPFD0\t\t;NO, KEEP GOING\r\n\tMOV\tBX,SI\t\t;AT END\r\n\tJMP\tNOTFDD\t\t;RETURN TO MAIN-LINE CODE IN BIPTRG.MAC\r\n\r\nISARY:\tCMP\tAL,BYTE PTR VALTYP\t;TYPE OF VARS THE SAME?\r\n\tJNZ\tNMARY1\t\t;NO, LOOK AT NEXT ONE\r\n\tCMP\tCH,BYTE PTR 0[SI]\t;2ND CHARS THE SAME?\r\n\tJNZ\tNMARY1\t\t;NO\r\n\tINC\tSI\t\t;POINT AT EXTRA CHARS\r\n\tLODSB\t\t\t;FETCH NUMBER OF THEM\r\n\tCMP\tAL,BYTE PTR NAMCNT\t;SAME AS WHAT WE WANT?\r\n\tJNZ\tNMARY3\t\t;NO, LOOK AT NEXT VAR\r\n\tOR\tAL,AL\t\t;NO CHARS LEFT?\r\n\tJZ\tCNOMAT\t\t;YES, MATCH, ALL DONE\r\n\tCBW\t\t\t;MAKE WORD\r\n\tXCHG\tAX,CX\t\t;PUT CHAR COUNT IN CX, SAVE FIRST TWO VAR CHARS\r\n\tMOV\tDI,OFFSET NAMBUF\t;POINT AT VAR BUFFER\r\n\t\t     ;COMPARE TWO VAR NAMES\r\n REP\tCMPSB\r\n\tXCHG\tAX,CX\t\t;GET BACK 2 CHARS TO MATCH IN [CX]\r\n\t\t\t\t;REMAINING CHARS IN NAME IN [AX]\r\n\tJZ\tCNOMAT\t\t;VARS MATCHED\r\n\tADD\tSI,AX\t\t;ADD REST OF CHARS TO WHERE WE ARE\r\n\tJMP\tSHORT NMARY4\t;LOOK AT NEXT VAR\r\n\r\nCNOMAT: LODSW\t\t\t;GET OFFSET TO END OF ARRAY\r\n\tMOV\tDX,AX\t\t;PROBOBALLY NOT USED\r\n\tMOV\tBX,SI\t\t;POINT TO NUMBER OF DIMENSIONS\r\n\tJMP\tARYEXT\t\t;GO BACK\r\n\r\n\r\n\tSUBTTL\t $AEXPS  SINGLE AND DOUBLE PRECISION ADD/SUBTRACT OF EXPONENTS\r\n;*************************************************************\r\n;\r\n;       $AEXPS,$SEXPS   WILL PERFORM THE ADDITION/SUBTRACTION\r\n;               OF SINGLE OR DOUBLE PRECISION EXPONENTS.\r\n;       CALLING SEQUENCE:       CALL    $AEXPS\r\n;               OR              CALL    $SEXPS\r\n;               WITH THE SINGLE PRECISION NUMERATOR(MULTIPLIER)\r\n;               IN (BXDX) OR THE DOUBLE PRECISION NUMERATOR\r\n;               (MULTIPLIER) IN ($ARG) AND THE DENOMINATOR\r\n;               (MULTIPLICAND) IN THE ($FAC)\r\n;               FOR DOUBLE PRECISION OPERATIONS THE $ARG  EXPONENT\r\n;               AND HIGH MANTISSA BYTE MUST BE IN BH:BL PRIOR\r\n;               TO A $SEXPS,$AEXPS CALL\r\n;\r\n;**************************************************************\r\n\r\n\r\n$AEXPS: STC\t\t\t;CF=1\r\n\tJMP\tSHORT SES00\r\n$SEXPS: CLC\t\t\t;CF=0\r\nSES00:\tMOV\tSI,BX\t\t;WILL NEED FOR LATER\r\n\tPUSHF\t\t\t;SAVE MULTIPLY/DIVIDE FLAG\r\n\tMOV\tCX,WORD PTR $FAC-1\t;(CH)=$FAC:(CL)=$FAC-1\r\n\tMOV\tAL,BL\t\t;FETCH (BXDX) SIGN BYTE\r\n\tXOR\tAL,CL\t\t;CORRECT SIGN IN AL\r\n\tMOV\tBYTE PTR $FAC+1,AL\t;MOVE TO $FAC+1\r\n\tMOV\tAL,BH\t\t;GET (BXDX) EXPONENT\r\n\tXOR\tAH,AH\t\t;WILL USE 16-BIT ARITHEMETIC\r\n\tMOV\tBL,CH\t\t;TO CALCULATE EXPONENTS\r\n\tXOR\tBH,BH\r\n\tPOPF\t\t\t;SEE IF ADD OR SUBTRACT OF EXPONENTS\r\n\tJNB\tSES05\t\t;JUMP IF SUBTRACT\r\n\tADD\tAX,BX\t\t;HAVE IN TWO BIASES\r\n\tSUB\tAX,401\t\t;NOW HAVE RAW SUM LESS 1\r\n\tJMP\tSHORT SES07\t;GO CHECK FOR OVERFLOW/UNDERFLOW\r\nSES05:\tSUB\tAX,BX\t\t;BIASES CANCEL OUT\r\nSES07:\tOR\tAH,AH\t\t;\r\n\tJS\tSES10\t\t;MUST GO CHECK FOR UNDERFLOW\r\n\tCMP\tAX,200\t\t;CF=0 IF OVERFLOW\r\n\tJB\tSES20\t\t;PROCEED IF OK\r\n\tMOV\tBX,SI\t\t;GET (BX) OFF STACK\r\n\tADD\tSP,2\t\t;GET $SEXPS RETURN ADDRESS OFF STACK\r\n\tJMP\t$OVFLS\t\t;GO DO OVERFLOW CODE\r\nSES10:\t\t\t\t;POTENTIAL UNDERFLOW\r\n\tADD\tAX,200\t\t;BIAS MUST BRING IT IN POSITIVE\r\n\tJNS\tSES30\t\t;IF IT IS POSITIVE PROCEED\r\n\tMOV\tBX,SI\t\t;BET (BX) OFF STACK\r\n\tADD\tSP,2\t\t;GET $SEXPS RETURN ADDRESS OFF STACK\r\n\tJMP\t$ZERO\t\t;GO ZERO THE FAC AND RETURN\r\nSES20:\tADD\tAX,200\t\t;ADD IN THE BIAS\r\nSES30:\tMOV\tBYTE PTR $FAC,AL\t;PUT CORRECT EXPONENT IN $FAC\r\n\tMOV\tBX,OFFSET $FAC-1\t;ADDRESS OF HIGH MANTISSA BITS\r\n\tOR\tBYTE PTR 0[BX],LOW 200\t;OR IN THE HIDDEN \"1\"\r\n\tMOV\tBX,SI\t\t;GET (BXDX) HIGH MANTISSA BITS\r\n\tXOR\tBH,BH\t\t;CLEAR SUPERFLUOUS BITS\r\n\tOR\tBL,LOW 200\t;RESTORE HIDDEN \"1\"\r\n\tRET\r\n\r\n\tSUBTTL\t $CHKEL  SUBROUTINE TO $FIN FOR CHECKING \"ELSE\" AND \"EQV\"\r\n;*****************************************************************\r\n;\r\n;       $CHKEL  CHECKS AN INPUT STREAM FOR POSSIBLE \"ELSE\" OR \"EQV\"\r\n;               CONSTRUCTS ONCE AN \"E\" HAS BEEN DETECTED. IF ONE OF\r\n;               THESE CONSTRUCTS IS DETECTED ZF=1 WILL BE RETURNED\r\n;               OTHERWISE ZF=0 WILL BE RETURNED.\r\n;       CALLING SEQUENCE:       CALL    $CHKEL\r\n;               WITH (BX) POINTING TO THE CURRENT POSITION IN THE\r\n;               INPUT CHARACTER STREAM.\r\n;\r\n;******************************************************************\r\n$CHKEL: PUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\t$CHRGT\t\t;GET NEXT CHARACTER INTO (AL)\r\n\tCMP\tAL,LOW OFFSET \"L\"+40    ;LOWER CASE \"L\"?\r\n\tJZ\tCK10\t\t;RETURN WITH ZF=1\r\n\tCMP\tAL,LOW \"L\"      ;UPPER CASE \"L\"?\r\n\tJZ\tCK10\t\t;RETURN WITH ZF=1\r\n\tCMP\tAL,LOW OFFSET \"Q\"+40    ;LOWER CASE \"Q\"?\r\n\tJZ\tCK10\t\t;RETURN WITH ZF=1\r\n\tCMP\tAL,LOW \"Q\"      ;UPPER CASE \"Q\"?\r\n;****************************************************************\r\n;THAT LAST CMPBI WILL SET ZF APPROPRIATELY SO WE'LL EXIT NOW\r\n;****************************************************************\r\nCK10:\tPOP\tBX\t\t;GET TEXT POINTER BACK\r\n\tRET\r\n\r\n\tSUBTTL\t $EXP\t SINGLE PRECISION EXPONENTIAL FUNCTION\r\n;*************************************************************\r\n;\r\n;THE FUNCTION EXP(X) CALCULATES e^X WHERE e=2.718282\r\n;       THE TECHNIQUE USED IS TO EMPLOY A COUPLE\r\n;       OF FUNDAMENTAL IDENTITIES THAT ALLOWS US TO\r\n;       USE THE BASE 2 THROUGH THE DIFFICULT PORTIONS OF\r\n;       THE CALCULATION:\r\n;\r\n;               (1)e^X=2^y  WHERE y=X*LOG2(e) [LOG2(e) IS\r\n;                                               LOG BASE 2\r\n;                                               OF e ]\r\n;\r\n;               (2) 2^y=2^[ INT(y)+(y-INT(y)]\r\n;               (3) IF Ny=INT(y) THEN\r\n;                   2^(Ny+y-Ny)=[2^Ny]*[2^(y-Ny)]\r\n;\r\n;       NOW, SINCE 2^Ny IS EASY TO COMPUTE (AN EXPONENT\r\n;       CALCULATION WITH MANTISSA BITS OF ZERO) THE DIFFICULT\r\n;       PORTION IS TO COMPUTE 2^(Y-Ny) WHERE 0.LE.(Y-Ny).LT.1\r\n;       THIS IS ACCOMPLISHED WITH A POLYNOMIAL APPROXIMATION\r\n;       TO 2^Z WHERE 0.LE.Z.LT.1  . ONCE THIS IS COMPUTED WE\r\n;       HAVE TO EFFECT THE MULTIPLY BY 2^Ny .\r\n;\r\n;**************************************************************\r\n;***********************************************************\r\n;THIS IS EXPONENTIAL EVALUATION BY HART POLYNOMIAL EVALUATION\r\n;USING COEFFICIENTS FROM #1302\r\n;************************************************************\r\nEXP:\r\n$EXP:\tMOV\tDX,125073\t;LOG2(e)\r\n\tMOV\tBX,100470\r\n\tCALL\t$FMULS\t\t;y=FAC*LOG2(e)\r\n\tMOV\tAL,BYTE PTR $FAC\t;MUST SEE IF TOO LARGE\r\n\tCMP\tAL,LOW 210\t;ABS.GT.128?\r\n\tJNB\tEXP110\t\t;Yes, too big.  Go decide between\r\n\t\t\t\t;overflow and underflow.\r\n\tCMP\tAL,LOW 150\t;SEE IF TOO SMALL(ANS. OF 1.)\r\n\tJB\tEXP200\r\n\tPUSH\tWORD PTR $FACLO ;SAVE y\r\n\tPUSH\tWORD PTR $FACLO+2\r\n\tCALL\t$QINT\t\t;Determine integer power of 2.\r\n\tMOV\tAH,DL\r\n\tADD\tAH,LOW 201\t;THIS WILL CALCULATE THE EXPONENT\r\n\t\t\t\t;FOR INTEGER POWER OF 2 FLOATING\r\n\t\t\t\t;POINT . WE USE 201 BECAUSE WE HAVE\r\n\t\t\t\t;A BIAS OF 200 AND THE UNDERSTOOD\r\n\t\t\t\t;1 OF FLOATING POINT NUMBERS IS TO\r\n\t\t\t\t;THE RIGHT OF THE BINARY POINT\r\n\tJZ\tEXP100\t\t;JUMP IF OVERFLOW\r\n\tPUSH\tAX\r\n\tTEST\tBYTE PTR $FAC+1,LOW 200O\t;Set SF if negative.  ($QINT saved\r\n\t\t\t\t;the sign in $FAC+1.)\r\n\tCALL\tNGBLDX\t\t;Negate if necessary.\r\n\tXOR\tAH,AH\t\t;Clear overflow for $NORMS.\r\n\tCALL\t$NORMS\t\t;This will make the FAC INT(y).\r\n\tPOP\tAX\r\n\tPOP\tBX\r\n\tPOP\tDX\t\t;RECALL y\r\n\tPUSH\tAX\t\t;SAVE EXPONENT\r\n\tCALL\t$FSUBS\t\t;WANT THE FRACTIONAL PART SO WE\r\n\t\t\t\t;CAN USE HART #1302 TO CALCULATE\r\n\t\t\t\t;2^y OF IT .(WE ALREADY\r\n\t\t\t\t;KNOW 2^Ny OF THE INTEGER PART\r\n\t\t\t\t;FROM THE ABOVE)\r\n\tMOV\tBX,OFFSET $EXPCN\t;POINT TO COEFFICIENTS\r\n\tCALL\t$POLY\t\t;DO THE CALCULATION\r\n\tPOP\tBX\t\t;RECALL EXPONENT OF INTEGER 2^y\r\n\tXOR\tDX,DX\t\t;\r\n\tMOV\tBL,DL\t\t;WE NOW HAVE 2^Ny OF INTEGER\r\n\t\t\t\t;PART IN (BXDX) AND FRACTIONAL PART\r\n\t\t\t\t;IN THE $FAC. TO CALCULATE THE ANSWER\r\n\t\t\t\t;NEED ONLY TO MULTIPLY THESE VALUES\r\n\tJMP\t$FMULS\r\nEXP100:\t\t\t;OVERFLOW WITH VALUES ON THE STACK\r\n\tADD\tSP,4\r\nEXP110: AND\tBYTE PTR $FAC-1,LOW 200O\t;Is it positively too big?\r\n\tJZ\tEXP115\t\t;Yes, overflow.\r\n\tJMP\t$ZERO\t\t;No, underflow for negative.\r\n\r\nEXP115: XOR\tAH,AH\t\t;OVERFLOW WITH STACK CLEAR\r\n\tMOV\tBYTE PTR $FAC+1,AH\t;MAKE SURE SIGN IS POSITIVE\r\n\t\t\t\t;to get postive infinity.\r\n\tJMP\t$OVFLS\t\t;GO DO OVERFLOW CODE\r\n\r\nEXP200:\t\t\t;WE HAVE DETERMINED THAT THE EXPONENT IS SO SMALL\r\n\t\t\t\t;THAT WE SHOULD RETURN 1. AS AN ANSWER\r\n\tMOV\tDI,OFFSET $FACLO\r\n\tXOR\tAX,AX\t\t;.0\r\n\tCLD\t\t\t;SO STOW WILL INCREMENT DI\r\n\tSTOSW\t\t\t;\r\n\tMOV\tWORD PTR 0[DI],100400\t;1.0\r\n\tRET\r\n\r\n\tSUBTTL\t $FADDD  DOUBLE PRECISION FLOATING POINT ADDITION\r\n;************************************************************\r\n;\r\n;       $FADDD  THIS ROUTINE PERFORMS DOUBLE PRECISION FLOATING\r\n;               POINT ADDITION/SUBTRACTION,I.E.\r\n;               (FAC)=(FAC)+-(ARG)\r\n;               THE LARGER NO. WILL BE PLACED IN THE FAC, THE SMALLER\r\n;               NO. IN THE ARG WILL BE SHIFTED RIGHT UNTIL THEIR\r\n;               BINARY POINTS ALIGN AND THE TWO WILL BE ADDED/\r\n;               SUBTRACTED. IF IT TURNS OUT THAT THE EXPONENTS WERE\r\n;               EQUAL AND THE OPERATION WAS A SUBTRACTION THEN\r\n;               A CARRY OUT OF THE HIGH BYTE  CAN OCCUR.\r\n;               IF THIS IS THE CASE, OUR CHOICE AS TO WHICH WAS THE\r\n;               LARGER NO. WAS INCORRECT AND WE HAVE TO NEGATE\r\n;               OUR MANTISSA AND COMPLEMENT THE SIGN OF THE RESULT.\r\n;\r\n;       CALLING SEQUENCE        CALL    $FADDD\r\n;               WITH THE NOS. TO BE ADDED/SUBTRACTED IN THE DOUBLE\r\n;               PRECISION FAC AND ARG\r\n;THE FORMAT OF DOUBLE PRECISION NUMBERS IS AS FOLLOWS\r\n;;\r\n;BIT:\r\n;66665555 55555544 44444444 33333333 33222222 22221111 11111100 00000000\r\n;32109876 54321098 76543210 98765432 10987654 32109876 54321098 76543210\r\n;AAAAAAAA BCCCCCCC CCCCCCCC CCCCCCCC CCCCCCCC CCCCCCCC CCCCCCCC CCCCCCCC\r\n;[$FAC  ] [$FAC-1] [$FAC-2] [$FACLO] [$DFACL  [$DFACL  [$DFACL  [$DFACL]\r\n;                                       +3  ]    +2  ]    +1  ]\r\n;\r\n;WHERE A=EXPONENT BIASED 128\r\n;      B=SIGN(1=NEGATIVE,0=POSITIVE) OF NUMBER\r\n;      C=BITS 2-56 OF MANTISSA (BIT 1 IS UNDERSTOOD 1)\r\n;        (ALSO BIT 54 IS HIGH ORDER BIT)\r\n;NOTE:THE BINARY POINT IS TO THE LEFT OF THE UNDERSTOOD 1\r\n;\r\n;****************************************************************\r\n\r\nFADDX1: CALL\t$MOVFA\t\t;MOVE DOUBLE PREC ARG TO FAC\r\nFADDX2: RET\r\n$FSUBD:\t\t\t;($FAC):=($ARG)-($FAC)\r\n\tMOV\tAX,WORD PTR $FAC-1\r\n\tOR\tAH,AH\t\t;IF ZF=1 ARG IS ANSWER\r\n\tJZ\tFADDX1\r\n\tXOR\tBYTE PTR $FAC-1,LOW 200 ;FLIP SIGN OF FAC\r\nDADD:\r\n$FADDD:\t\t\t;($FAC):=($ARG)+($FAC)\r\n\tMOV\tAL,LOW 0\t;WANT TO ZERO OVERFLOW BYTES\r\n\tMOV\tBYTE PTR $DFACL-1,AL\r\n\tMOV\tBYTE PTR $ARGLO-1,AL\r\n\tMOV\tAL,BYTE PTR $ARG\t;IF ($ARG)=0 THEN JUST RET\r\n\tOR\tAL,AL\t\t;\r\n\tJZ\tFADDX2\t\t;RETURN\r\n\tMOV\tAX,WORD PTR $FAC-1\t;\r\n\tOR\tAH,AH\t\t;IF EXPONENT=0, NO. IS ZERO\r\n\tJZ\tFADDX1\t\t;ARG IS THE ANSWER\r\n\tMOV\tBX,WORD PTR $ARG-1\t;FETCH SIGN AND EXPONENT\r\n\tOR\tBYTE PTR $FAC-1,LOW 200 ;RESTORE HIDDEN 1 MANTISSA BIT\r\n\tOR\tBYTE PTR $ARG-1,LOW 200\r\n\tMOV\tCL,AH\t\t;WILL FORM SHIFT COUNT IN (CL)\r\n\tSUB\tCL,BH\t\t;\r\n\tMOV\tBYTE PTR $FAC+1,AL\t;ASSUME SIGN OF FAC\r\n\tJZ\tFDD25\t\t;PROCEED IF EXPONENTS EQUAL\r\n\tJNB\tFDD20\t\t;IF FAC LARGER (OR EQUAL) JUMP\r\n;********************************************************************\r\n; $ARG HAS THE LARGER EXPONENT SO WE MUST EXCHANGE FAC AND ARG AND\r\n;USE SIGN OF THE ARG\r\n;********************************************************************\r\n\tXCHG\tAL,BL\t\t;HIGH MANTISSA BYTE EXCHANGE\r\n\tNEG\tCL\t\t;NED POS. SHIFT COUNT\r\n\tMOV\tBYTE PTR $FAC+1,AL\t;ADAPT ARG SIGN\r\n\tMOV\tBYTE PTR $FAC,BH\t;ADAPT ARG EXPONENT\r\n\tPUSH\tAX\t\t;SAVE ARG MANTISSA BITS\r\n\tPUSH\tCX\t\t;WILL NEED AS COUNT FOR LOOP\r\n\tCALL\t$XCGAF\t\t;EXCHANGE ARG AND FAC\r\n\tPOP\tCX\t\t;RECALL OLD CX\r\n\tPOP\tAX\t\t;GET MANTISSA BYTES BACK\r\nFDD20:\t\t\t\t;WE NOW HAVE THE SUSPECTED LARGER NO IN THE FAC, WE NEED\r\n\t\t\t\t;TO KNOW IF WE ARE TO SUBTRACT (SIGNS ARE DIFFERENT) AND\r\n\t\t\t\t;WE NEED TO RESTORE THE HIDDEN MANTISSA BIT\r\n\t\t\t\t;FURTHER, IF THERE IS TO BE MORE THAN 56 BITS SHIFTED\r\n\t\t\t\t;TO ALIGN THE BINARY POINTS THEN THE LESSOR NO. IS\r\n\t\t\t\t;INSIGNIFICANT IN COMPARISON TO THE LARGER NO. SO WE\r\n\t\t\t\t;CAN JUST RETURN AND CALL THE LARGER NO. THE ANSWER.\r\n\tCMP\tCL,LOW 57D\t;THIS MUST SET CF TO CONTINUE\r\n\tJNB\tFDD95\t\t;RETURN IF CF=0\r\n\tPUSH\tBX\t\t;SAVE MANTISSA BITS\r\n\tCLC\t\t\t;SO WE DON'T GET CF IN THERE\r\n\tCALL\t$SHRA\t\t;SHIFT ARG RIGHT (CL) BITS\r\n\tMOV\tAL,BYTE PTR $FAC+1\t;RECALL SIGN (AL DESTROYED\r\n\t\t\t\t;BY $SHRA)\r\n\tPOP\tBX\r\nFDD25:\tXOR\tAL,BL\t\t;WILL NOW DETERMINE IF ADD/SUB\r\n\tMOV\tBX,OFFSET $DFACL-1\r\n\tMOV\tSI,OFFSET $ARGLO-1\r\n\tMOV\tCX,4\t\t;4 SIXTEEN BIT OPERATIONS\r\n\tCLC\t\t\t;CF=0\r\n;****************************************************************\r\n;WE ARE NOW STAGED TO DO THE ADD/SUBTRACT. IT WILL BE DONE AS 4\r\n;SIXTEEN BIT OPERATIONS.\r\n;****************************************************************\r\n\tCLD\t\t\t;SO LODW WILL INCB\r\n\t\t\t\t;Note 9-Aug-82/MLC - This CLD is\r\n\t\t\t\t;for the LODWs at both FDD30 and\r\n\t\t\t\t;FDD50.\r\n\tJS\tFDD50\t\t;IF SF=1 GO SUBTRACT\r\nFDD30:\tLODSW\t\t\t;FETCH NEXT BYTE ARG\r\n\t\t\t\t;Note 9-Aug-82/MLC - CLD is outside\r\n\t\t\t\t;loop above.\r\n\tADC\tWORD PTR 0[BX],AX\t;ADD IT TO FAC\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tLOOP\tFDD30\r\n\tJNB\tFDD40\t\t;GO ROUND IF CF=0\r\n;*************************************************************\r\n;WE HAD OVERFLOW OUT OF THE HIGH MANTISSA BIT. WE MUST INCREMENT\r\n;THE EXPONENT AND SHIFT THE OVERFLOW BIT BACK INTO THE FAC BY\r\n;SHIFTING THE FAC RIGHT 1 BIT.\r\n;*************************************************************\r\nFDD35:\tMOV\tBX,OFFSET $FAC\t;FETCH ADDRESS OF EXPONENT\r\n\tINC\tBYTE PTR 0[BX]\t;INCREMENT THE EXPONENT\r\n\tJZ\tFDD90\t\t;IF ZF=1 - OVERFLOW\r\n\tDEC\tBX\r\n\tDEC\tBX\t\t;BX POINTS TO $FAC-2\r\n\tMOV\tCX,4\t\t;4 SIXTEEN BIT SHIFTS\r\n;**************************************************************\r\n;WE ARE NOW SET TO SHIFT THE FAC RIGHT 1 BIT. RECALL WE GOT HERE\r\n;WITH CF=1. THE INSTRUCTIONS SINCE WE GOT HERE HAVEN'T AFFECTED\r\n;CF SO WHEN WE SHIFT RIGHT WE WILL SHIFT CF INTO THE HIGH MANTISSA\r\n;BIT.\r\n;*************************************************************\r\nFDD37:\tRCR\tWORD PTR 0[BX],1\r\n\tDEC\tBX\r\n\tDEC\tBX\r\n\tLOOP\tFDD37\r\nFDD40:\tJMP\t$ROUND\t\t;GO ROUND THE RESULT\r\nFDD50:\r\n;**************************************************************\r\n;TO GET HERE THE SIGNS OF THE FAC AND ARG WERE DIFFERENT THUS\r\n;IMPLYING A DESIRED SUBTRACT.\r\n;**************************************************************\r\n\tLODSW\t\t\t;FETCH NEXT WORD OF ARG\r\n\t\t\t\t;Note 9-Aug-82/MLC - The CLD is\r\n\t\t\t\t;just above FDD30.\r\n\tSBB\tWORD PTR 0[BX],AX\t;SUBTRACT FROM FAC\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tLOOP\tFDD50\r\n\tJNB\tFDD80\t\t;GO NORMALIZE AND ROUND\r\n;************************************************************\r\n;TO GET HERE FAC TURNED OUT SMALLER THAN THE ARG. TO CORRECT\r\n;THE ANSWER IN THE FAC WE MUST NEGATE THE MANTISSA BITS\r\n;AND THE SIGN IN $FAC+1\r\n;***********************************************************\r\n\tNOT\tBYTE PTR 1[BX]\t;COMPLEMENT SIGN\r\n\tMOV\tCX,4\t\t;4 SIXTEEN BIT COMPLEMENTS\r\nFDD60:\tDEC\tBX\r\n\tDEC\tBX\r\n\tNOT\tWORD PTR 0[BX]\t;COMPLEMENT FAC\r\n\tLOOP\tFDD60\r\n;***********************************************************\r\n;MUST NOW ADD 1 FOR 2'S COMPLEMENT ARITH.\r\n;***********************************************************\r\n\tMOV\tCX,4\r\nFDD70:\tINC\tWORD PTR 0[BX]\t;IF ZF=1 THEN CARRY\r\n\tJNZ\tFDD80\t\t;SINCE THEY DON'T SET CF\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tLOOP\tFDD70\r\n\tJZ\tFDD35\t\t;IF ZF=1 MUST INCREMENT EXP\r\nFDD80:\tJMP\t$NORMD\t\t;GO NORMALIZE\r\nFDD90:\tJMP\t$OVFLS\t\t;OVERFLOW!\r\nFDD95:\tJMP\t$ROUNX\t\t;PUT IN THE SIGN AND DONE\r\n\r\n\tSUBTTL\t $FADDS  SINGLE PRECISION FLOATING POINT ADD/SUB\r\n;*********************************************************\r\n;\r\n;       $FADDS  FLOATING POINT ADDITION FOR SINGLE PRECISION\r\n;               $FADDS FORMS THE SUM OF (BXDX) AND ($FAC) AND\r\n;               LEAVES THE RESULT IN THE ($FAC).\r\n;\r\n;       CALLING SEQUENCE:       CALL    $FADDS\r\n;       $FSUBS  FLOATING POINT SUBTRACTION FOR SINGLE PRECISION\r\n;               $FSUBS FORMS THE DIFFERENCE (BXDX)-(FAC) AND\r\n;               LEAVES THE RESULT IN THE (FAC).\r\n;       CALLING SEQUENCE:       CALL    $FSUBS\r\n;\r\n;**********************************************************\r\n\r\nFEXIT1: MOV\tWORD PTR $FAC-1,BX\t;MOV (BXDX) TO $FAC\r\n\tMOV\tWORD PTR $FACLO,DX\r\nEXIT2:\tRET\r\n$FSUBS: MOV\tAX,WORD PTR $FAC-1\t;FETCH FAC\r\n\tOR\tAH,AH\t\t;IF ZF=1 (BXDX) IS ANSWER\r\n\tJZ\tFEXIT1\t\t;(BXDX) IS THE ANSWER\r\n\tXOR\tBYTE PTR $FAC-1,LOW 200 ;FLIP SIGN\r\n$FADDS:\t\t\t;($FAC)=(BXDX)+($FAC)\r\n\tOR\tBH,BH\t\t;WILL FIRST CHECK EXPONENT OF (BXDX)\r\n\tJZ\tEXIT2\t\t;ANS ALREADY IN $FAC\r\n\tMOV\tAX,WORD PTR $FAC-1\t;WILL NOW CHECK $FAC AND IF ZERO\r\n\tOR\tAH,AH\t\t;ANSWER IN (BXDX) AND MUST MOVE\r\n\tJZ\tFEXIT1\t\t;MOVE (BXDX) TO FAC\r\n\t\t\t\t;****************************************************\r\n\t\t\t\t;KNOW AT THIS POINT THAT NEITHER (BXDX) NOR THE\r\n\t\t\t\t;$FAC ARE ZERO. THE SUM WILL BE PERFORMED BY EXAMINATION\r\n\t\t\t\t;OF THE EXPONENTS, PLACING THE NUMBER WITH THE LARGER\r\n\t\t\t\t;EXPONENT IN THE $FAC,AND SHIFTING THE SMALLER NUMBER RIGHT\r\n\t\t\t\t;UNTIL BINARY POINTS ALIGN, THEN ADDING THE MANTISSAS\r\n\t\t\t\t;IF THE SIGNS ARE THE SAME OR SUBTRACTING THE MANTISSAS\r\n\t\t\t\t;IF THE SIGNS ARE DIFFERENT. THE EXPONENT OF THE ANSWER\r\n\t\t\t\t;IS THE EXPONENT OF THE LARGER NUMBER. THE FORMAT OF\r\n\t\t\t\t;FLOATING POINT NUMBERS IS AS FOLLOWS:\r\n\t\t\t\t;\r\n\t\t\t\t;BIT    33222222 22221111 11111100 00000000\r\n\t\t\t\t;       10987654 32109876 54321098 76543210\r\n\t\t\t\t;       AAAAAAAA BCCCCCCC CCCCCCCC CCCCCCCC\r\n\t\t\t\t;BYTE   [ $FAC ] [$FAC-1] [$FAC-2] [$FAC-3]\r\n\t\t\t\t;                                  [$FACLO]\r\n\t\t\t\t;\r\n\t\t\t\t;WHERE  A=BITS OF EXPONENT BIASED BY 128\r\n\t\t\t\t;       B=0 IF NUMBER IS POSITIVE,1 IF NEGATIVE\r\n\t\t\t\t;       C=BITS 2-24 OF MANTISSA(BIT 1 IS UNDERSTOOD 1)\r\n\t\t\t\t;NOTE:THE BINARY POINT IS TO THE LEFT OF THE UNDERSTOOD 1\r\n\t\t\t\t;\r\n\t\t\t\t;******************************************************\r\n\r\n\tXOR\tCX,CX\t\t;(CX)=0\r\n\tMOV\tSI,WORD PTR $FACLO\t;(SI)=($FAC-2,$FACLO)\r\n\tMOV\tBYTE PTR $FAC+1,AL\t;ASSUME SIGN OF $FAC\r\n\tMOV\tCL,AH\t\t;SINCE ASSUME $FAC LARGER\r\n\tSUB\tCL,BH\t\t;CL WILL HOLD SHIFT COUNT\r\n\tJNB\tFA20\t\t;JUMP IF $FAC EXP EQUAL OR LARGER\r\n\tNEG\tCL\t\t;NEED POS. SHIFT COUNT\r\n\tXCHG\tBL,BH\r\n\tMOV\tWORD PTR $FAC,BX\t;SINCE (BXDX) LARGER MAGNITUDE\r\n\tXCHG\tBL,BH\t\t;GET EXP/SGN CORRECT AGAIN\r\n\tXCHG\tBX,AX\t\t;WILL EXCHANGE (BXDX) AND (AXSI)\r\n\tXCHG\tDX,SI\t\t;\r\nFA20:\t\t\t\t;********************************************************\r\n\t\t\t\t;AT THIS POINT SUSPECTED LARGER NUMBER IS IN (AXSI) WITH\r\n\t\t\t\t;SMALLER IN (BXDX). THIS WILL BE THE CASE UNLESS THE EXPONENTS\r\n\t\t\t\t;WERE EQUAL. IF THE EXPONENTS WERE EQUAL AND THIS IS\r\n\t\t\t\t;TO BE A SUBTRACTION A NEGATIVE MANTISSA COULD RESULT. IF THIS\r\n\t\t\t\t;HAPPENS, WE MUST COMPLEMENT THE MANTISSA AND THE SIGN OF THE\r\n\t\t\t\t;RESULT.\r\n\t\t\t\t;********************************************************\r\n\tMOV\tAH,AL\t\t;WILL NOW DETERMINE IF ADD OR\r\n\tXOR\tAH,BL\t\t;SUBTRACT\r\n\tPUSHF\t\t\t;SF=1 IF SUBTRACT\r\n\tMOV\tAH,LOW 200\t;WILL REPLACE UNDERSTOOD 1\r\n\tOR\tAL,AH\r\n\tOR\tBL,AH\r\n\tXOR\tAH,AH\t\t;(AH) WILL BE OVERFLOW BYTE\r\n\tMOV\tBH,AH\t\t;(AH)=(BH)=0\r\nFA22:\tOR\tCX,CX\t\t;ZF=1 IF EXPONENTS THE SAME\r\n\tJZ\tFA40\t\t;IF EXPONENTS SAME JUMP\r\n\tCMP\tCX,31\t\t;MUST SEE IF WITHIN 24 BITS\r\n\tJB\tFA23\t\t;IF SO PROCEED\r\n;*************************************************************\r\n;THE NUMBERS WE ARE TRYING TO ADD/SUBTRACT ARE OF SUCH DIFFERENCE\r\n;IN MAGNITUDE THAT THE SMALLER IS NEGLIGIBLE WITH RESPECT TO THE\r\n;LARGER. OUR ANSWER THEREFORE IS THE NUMBER WITH THE ABSOLUTE\r\n;LARGER MAGNITUDE. THE MANTISSA OF THIS NO. IS IN (AL:SI)\r\n;**************************************************************\r\n\tPOPF\t\t\t;CLEAR SUBTRACT/ADD FLAG\r\n\tMOV\tWORD PTR $FACLO,SI\t;RESTORE LOWER MANTISSA BITS\r\n\tMOV\tAH,BYTE PTR $FAC+1\t;FETCH SIGN\r\n\tAND\tAX,100177\t;CLEAR SIGN IN AH, ALL BUT SIGN IN AL\r\n\tOR\tAL,AH\t\t;RESTORE SIGN\r\n\tMOV\tBYTE PTR $FAC-1,AL\t;$FAC NOW CORRECTLY BUILT\r\n\tRET\r\nFA23:\r\n\t\t\t\t;WILL TRY FOR BYTE MOVES\r\n\tCMP\tCL,LOW 10\t;NEED AT LEAST 8 BITS\r\n\tJB\tFA27\t\t;IF NOT PROCEED AS NORMAL\r\n\tMOV\tDI,AX\t\t;WILL WANT TO CHECK THIS FOR ST\r\n\tMOV\tAH,DL\t\t;SHIFT OVERFLOW BITS\r\n\tTEST\tDI,177400O\t;DID WE SHIFT THROUGH ST?\r\n\tJZ\tFA24\r\n\tOR\tAH,LOW 40\t;PUT ST BACK IN\r\nFA24:\r\n\tMOV\tDL,DH\r\n\tMOV\tDH,BL\r\n\tXOR\tBL,BL\t\t;CLEAR UPPER BITS\r\n\tSUB\tCL,LOW 10\r\n\tTEST\tAH,LOW 37\t;SHIFT THRU ST\r\n\tJZ\tFA22\t\t;IF NOT TRY AGAIN\r\n\tOR\tAH,LOW 40\r\n\tJMP\tSHORT FA22\r\nFA25:\tOR\tAH,LOW 40\t;\"OR\" IN ST BIT\r\n\tLOOP\tFA30\t\t;CONTINUE LOOP\r\n\tJMP\tSHORT FA40\t;IF FINISHED JUMP\r\nFA27:\tCLC\t\t\t;MAKE SURE CARRY CLEAR BEFORE SHIFT\r\nFA30:\tRCR\tBL,1\r\n\tRCR\tDX,1\r\n\tRCR\tAH,1\t\t;SHIFT (BLDXAH)RIGHT ONE BIT\r\n\tTEST\tAH,LOW 20\t;SEE IF ST SET\r\n\tJNZ\tFA25\r\n\t\t\t\t;CARRY INTO HIGH BIT\r\n\tLOOP\tFA30\t\t;LOOP UNTIL (CX)=0\r\nFA40:\tPOPF\t\t\t;IF SF=1 WE MUST SUBTRACT MANTISSAS\r\n\tJNS\tFA50\t\t;IF SF=0 GO ADD MANTISSAS\r\n\tSUB\tCL,AH\t\t;SUBTRACT UNDERFLOW BYTE\r\n\tMOV\tAH,CL\t\t;MUST GO TO NORMS WITH MANT. IN (BLDXCL)\r\n\tSBB\tSI,DX\r\n\tMOV\tDX,SI\r\n\tSBB\tAL,BL\t\t;IF CARRY (CF) NOT SET THEN\r\n\tMOV\tBL,AL\r\n\tJNB\tFA90\t\t;ASSUMPTION OF $FAC LARGER VALID\r\n\tNOT\tBYTE PTR $FAC+1 ;MUST USE OTHER SIGN $FAC WASN'T\r\n\tNOT\tAH\t\t;LARGER\r\n\tNOT\tDX\r\n\tNOT\tBL\r\n\tINC\tAH\t\t;INCREMENT BY ONE AND SET CARRY\r\n\tJNZ\tFA90\t\t;IF ZF=0 GO NORMALIZE\r\n\tINC\tDX\t\t;INCREMENT BY ONE\r\n\tJNZ\tFA90\t\t;IF ZF=0 GO NORMALIZE\r\n\tINC\tBL\t\t;INCREMENT BY ONE\r\n\tJNZ\tFA90\t\t;IF ZF=0 GO NORMALIZE\r\n\tJMP\tSHORT FA60\r\nFA50:\r\n;************************************************************\r\n;SIGNS OF THE NUMBERS WERE THE SAME SO WE ADD MANTISSAS HERE\r\n;*************************************************************\r\n\tADD\tDX,SI\t\t;ADDITION OF LOW BITS\r\n\tADC\tBL,AL\t\t;ADDITION OF HIGH BITS\r\n\tJNB\tFA70\r\nFA60:\t\t\t\t;HERE WHEN WE HAVE OVERFLOWED THE HIGH MANTISSA BYTE\r\n\t\t\t\t;AND MUST INCREMENT THE EXPONENT\r\n\tINC\tBYTE PTR $FAC\t;INCREMENT THE EXPONENT\r\n\tJZ\tFA80\t\t;OVERFLOW!\r\n\tRCR\tBL,1\t\t;MUST SHIFT RIGHT ONE BIT\r\n\tRCR\tDX,1\r\n\tRCR\tAH,1\r\nFA70:\tJMP\t$ROUNS\r\nFA80:\tJMP\t$OVFLS\t\t;DO OVERFLOW CODE\r\nFA90:\tJMP\t$NORMS\t\t;GO NORMALIZE\r\n\r\n\tSUBTTL\t DDIV\t DOUBLE PRECISION DIVIDE (FAC)=(ARG)/(FAC)\r\n;*****************************************************************\r\n;\r\n;       $FDIVD  THIS ROUTINE DIVIDES THE ARG BY THE FAC LEAVING THE\r\n;               QUOTIENT IN THE FAC\r\n;       CALLING SEQUENCE:       CALL    $FDIVD\r\n;\r\n;*******************************************************************\r\n\r\nEXIT1:\tJMP\t$DZERO\t\t;ZERO THE FAC\r\nDOVCKJ: JNS\tEXIT1\r\n\tJMP\t$OVFLS\r\nDDIV:\r\nDDIVFA: MOV\tSI,OFFSET $DFACL\r\n\tMOV\tDI,OFFSET $ARGLO\r\n\tJMP\tSHORT $DDIV\r\n$FDIVD:\r\n\tMOV\tSI,OFFSET $ARGLO\r\n\tMOV\tDI,OFFSET $DFACL\r\n$DDIV:\r\n\tMOV\tAX,WORD PTR 6[SI]\t;High half of numerator\r\n\tMOV\tCX,WORD PTR 6[DI]\t;High half of denominator\r\n\tXOR\tAL,CL\t\t;Compute sign\r\n\tMOV\tBYTE PTR $FAC+1,AL\t;and store in $FAC\r\n\tOR\tCH,CH\t\t;Denominator zero?\r\n\tJZ\tDDIV0\r\n\tOR\tAH,AH\t\t;Numerator zero?\r\n\tJZ\tEXIT1\r\n\tSUB\tAH,LOW 128D\t;Remove bias from exponents\r\n\tSUB\tCH,LOW 128D\r\n\tSUB\tAH,CH\t\t;Compute result exponent\r\n\tJO\tDOVCKJ\r\n\r\n;AH has the (tentative) true exponent of the result. It is correct if the\r\n;result needs normalizing one bit. If not, 1 will be added to it. A true\r\n;exponent of -128, not normally allowed except to represent zero, is OK\r\n;here because of this possible future incrementing.\r\n\r\n\tCLD\t\t\t;9-Aug-82/MLC - Good for the LODC,\r\n\t\t\t\t;LODW, LODW, and LODW which follow.\r\n\tADD\tAH,LOW 128D\t;Put bias back\r\n\tPUSH\tAX\t\t;SAVE sign and exponent\r\n\tLODSB\t\t\t;Load up dividend\r\n\tMOV\tCH,AL\r\n\tXOR\tCL,CL\r\n\tLODSW\r\n\tXCHG\tAX,BX\r\n\tLODSW\r\n\tXCHG\tAX,DX\r\n\tLODSW\r\n\tOR\tAH,LOW 200O\t;Set implied bit\r\n\tXCHG\tAX,DX\t\t;Divisor in DX:AX:BX:CX\r\n\r\n;Move divisor to FAC so we can get at it easily. More importantly, get it in\r\n;the necessary form - extended to 64 bits with zeros, implied bit set.\r\n;The form we want it in will have the mantissa MSB where the exponent usually\r\n;is, so by moving high to low we will not destroy the divisor even if it is\r\n;already in the FAC.\r\n\r\n\tMOV\tSI,DI\r\n\tADD\tSI,5\t\t;Point to high end of divisor\r\n\tMOV\tDI,OFFSET $FAC-1\r\n\tSTD\t\t\t;Direction DOWN\r\n\tMOVSW\t\t\t;Move divisor to FAC\r\n\tMOVSW\r\n\tMOVSW\r\n\tINC\tSI\r\n\tINC\tDI\r\n\tMOVSB\r\n\tCLD\t\t\t;DRESTR direction\r\n\tMOV\tBYTE PTR 0[DI],LOW 0\t;Extend to 64 bits with a zero\r\n\tOR\tBYTE PTR $FAC,LOW 200O\t;Set implied bit\r\n\r\n;Now we're all set:\r\n;       DX:AX:BX:CX has dividend\r\n;       FAC has divisor (not in normal format)\r\n;Both are extended to 64 bits with zeros and have implied bit set.\r\n;Top of stack has sign and tentative exponent.\r\n\r\n\tSHR\tDX,1\t\t;Make sure dividend is smaller than divisor\r\n\tRCR\tAX,1\t\t;   by dividing it by two\r\n\tRCR\tBX,1\r\n\tRCR\tCX,1\r\n\tCALL\tDDIV16\t\t;Get a quotient digit\r\n\tPUSH\tDI\r\n\tCALL\tDDIV16\r\n\tPUSH\tDI\r\n\tCALL\tDDIV16\r\n\tPUSH\tDI\r\n\tCALL\tDDIV16\r\n\tOR\tAX,BX\t\t;Remainder zero?\r\n\tOR\tAX,CX\r\n\tOR\tAX,DX\r\n\tMOV\tDX,DI\t\t;Get lowest word in position\r\n\tJZ\tDNSTK1\r\n\tOR\tDL,LOW 1\t;Set sticky bit if not\r\nDNSTK1:\r\n\tPOP\tCX\t\t;Recover quotient digits\r\n\tPOP\tBX\r\n\tPOP\tDI\r\n\tJMP\tDNRMCHK\r\n\r\nDDIV0:\tMOV\tBYTE PTR $FAC+1,AL\r\n\tJMP\t$DIV0S\r\n\r\nDDIV16:\r\n\tMOV\tSI,WORD PTR $DFACL+6\t;Get high word of divisor\r\n\tXOR\tDI,DI\t\t;Initialize quotient digit to zero\r\n\tCMP\tDX,SI\t\t;Will we overflow?\r\n\tJAE\tDMXQUO\t\t;If so, go handle special\r\n\tOR\tDX,DX\t\t;Is dividend small?\r\n\tJNZ\tDODIV\r\n\tCMP\tSI,AX\t\t;Will divisor fit at all?\r\n\tJA\tZERQUO\t\t;No - quotient is zero\r\nDODIV:\r\n\tDIV\tSI\t\t;AX is our digit \"guess\"\r\n\tPUSH\tDX\t\t;SAVE remainder\r\n\tXCHG\tAX,DI\t\t;Quotient digit in DI\r\n\tXOR\tBP,BP\t\t;Initialize quotient * divisor\r\n\tMOV\tSI,BP\r\n\tMOV\tAX,WORD PTR $DFACL\r\n\tOR\tAX,AX\t\t;If zero, SAVE multiply time\r\n\tJZ\tREM2\r\n\tMUL\tDI\t\t;Begin computing quotient * divisor\r\n\tMOV\tSI,DX\r\nREM2:\r\n\tPUSH\tAX\t\t;SAVE lowest word of quotient * divisor\r\n\tMOV\tAX,WORD PTR $DFACL+2\r\n\tOR\tAX,AX\r\n\tJZ\tREM3\r\n\tMUL\tDI\r\n\tADD\tSI,AX\r\n\tADC\tBP,DX\r\nREM3:\r\n\tMOV\tAX,WORD PTR $DFACL+4\r\n\tOR\tAX,AX\r\n\tJZ\tREM4\r\n\tMUL\tDI\r\n\tADD\tBP,AX\r\n\tADC\tDX,0\r\n\tXCHG\tAX,DX\r\nREM4:\t\t\t\t;Quotient * divisor in AX:BP:SI:[SP]\r\n\tPOP\tDX\t\t;Recover lowest word of quotient * divisor\r\n\tNEG\tDX\t\t;Subtract from dividend\r\n\tSBB\tCX,SI\r\n\tSBB\tBX,BP\r\n\tPOP\tBP\t\t;Remainder from DIV\r\n\tSBB\tBP,AX\r\n\tXCHG\tAX,BP\r\nZERQUO:\t\t\t;Remainder in AX:BX:CX:DX\r\n\tXCHG\tAX,DX\r\n\tXCHG\tAX,CX\r\n\tXCHG\tAX,BX\r\n\tJNB\tRETRES\t\t;Remainder in DX:AX:BX:CX\r\nDRESTR:\r\n\tDEC\tDI\t\t;Drop quotient since it didn't fit\r\n\tADD\tCX,WORD PTR $DFACL\t;Add divisor back in until remainder goes +\r\n\tADC\tBX,WORD PTR $DFACL+2\r\n\tADC\tAX,WORD PTR $DFACL+4\r\n\tADC\tDX,WORD PTR $DFACL+6\r\n\tJNB\tDRESTR\r\nRETRES: RET\r\n\r\nDMXQUO:\r\n\tDEC\tDI\t\t;DI=FFFF=2**16-1\r\n\tSUB\tCX,WORD PTR $DFACL\r\n\tSBB\tBX,WORD PTR $DFACL+2\r\n\tSBB\tAX,WORD PTR $DFACL+4\r\n\tADD\tCX,WORD PTR $DFACL+2\r\n\tADC\tBX,WORD PTR $DFACL+4\r\n\tADC\tAX,DX\r\n\tMOV\tDX,WORD PTR $DFACL\r\n\tCMC\r\n\tJMP\tSHORT ZERQUO\r\nDNRMCHK:\r\n\tPOP\tAX\t\t;Get exp. and sign back\r\n\tOR\tDI,DI\t\t;See if normalized\r\n\tJS\tDINCEX\t\t;Yes - increment exponent\r\n\tSHL\tDX,1\t\t;Normalize\r\n\tRCL\tCX,1\r\n\tRCL\tBX,1\r\n\tRCL\tDI,1\r\n\tOR\tAH,AH\r\n\tJNZ\tDDRND\r\n\tJMP\t$DZERO\r\nDINCEX:\r\n\tINC\tAH\r\n\tJZ\tDDOVFL\r\n$DROUND:\r\nDDRND:\r\n\tCMP\tDL,LOW 200O\t;Check extended bits\r\n\tJA\tFPRNDUP\r\n\tJB\tDDSV\r\n;Extended bits equal exactly one-half LSB, so round even\r\n\tTEST\tDH,LOW 1\t;Already even?\r\n\tJZ\tDDSV\r\nFPRNDUP:\r\n\tADD\tDH,LOW 1\r\n\tADC\tCX,0\r\n\tADC\tBX,0\t\t;Propagate carry\r\n\tADC\tDI,0\r\n\tJNB\tDDSV\t\t;Overflow?\r\n;If we overflowed, DI:BX:CX:DH must now be zero, so we can leave it that way.\r\n\tINC\tAH\t\t;Increment exponent\r\n\tJNZ\tDDSV\r\nDDOVFL: JMP\t$OVFLS\r\nDDSV:\r\n\tAND\tAL,LOW 200O\t;Strip to sign bit\r\n\tXCHG\tBX,DI\r\n\tAND\tBH,LOW 177O\t;Mask off implied bit\r\n\tOR\tAL,BH\t\t;Combine sign with mantissa\r\n\tMOV\tWORD PTR $DFACL+6,AX\r\n\tMOV\tBYTE PTR $FAC-2,BL\r\n\tMOV\tBX,DI\r\n\tMOV\tDI,OFFSET $DFACL\r\n\tMOV\tAL,DH\r\n\tCLD\r\n\tSTOSB\r\n\tXCHG\tAX,CX\r\n\tSTOSW\r\n\tXCHG\tAX,BX\r\n\tSTOSW\r\n\tRET\r\n\r\n\tSUBTTL\t SDIV\t SINGLE PRECISION FLOATING POINT DIVIDE\r\n;****************************************************************\r\n;\r\n;       $FDIVS  THIS ROUTINE FORMS THE QUOTIENT (BXDX)/(FAC)\r\n;               AND RETURNS IT TO THE FAC\r\n;\r\n;******************************************************************\r\n\r\n;$DIV0S IS THE DIVIDE BY ZERO ENTRY INTO OVERFLOW CODE\r\n;$SIGNS WILL SET THE CONDITION CODES ACCORDING TO THE VALUE OF THE\r\n;       FAC,I.E. ZF=1 IF (FAC)=0, SF=1 IF FAC NEGATIVE, AND NEITHER\r\n;       OF THESE IF (FAC) GREATER THAN 0\r\n;$ZERO CLEARS THE 4 BYTES OF THE FAC\r\n$FDIVS: CALL\t$SIGNS\t\t;MUST BE SURE (FAC) NOT ZERO\r\n\tJNZ\tFDS00\r\n\tMOV\tBYTE PTR $FAC+1,BL\t;PUT IN FOR CORRECT OVERFLOW SIGN\r\n\tJMP\t$DIV0S\t\t;IF SO OVERFLOW!\r\nFDS00:\r\n\tOR\tBH,BH\t\t;IF (BXDX)=0 ANSWER IS ZERO\r\n\tJNZ\tFDS10\t\t;PROCEED IF (BXDX) NON-ZERO\r\nFDS05:\tJMP\t$ZERO\r\nFDS10:\r\n\tMOV\tWORD PTR $DFACL,DX\t;WILL PUT NUMERATOR IN $DFAC\r\n\tMOV\tWORD PTR $DFACL+2,BX\r\n\tMOV\tSI,OFFSET $DFACL\r\n\tMOV\tDI,OFFSET $FACLO\r\n;***  $SDIV - Single precision divide\r\n;\r\n; Inputs:\r\n;       SI = Address of Dividend (Numerator)\r\n;       DI = Address of Divisor (Denominator)\r\n; Function:\r\n;       FAC = 0(.SI) / 0(.DI)\r\n; Outputs:\r\n;       Result in FAC.\r\n; Registers:\r\n;       All except BP destroyed.\r\n\r\n$SDIV:\r\n\tMOV\tCX,WORD PTR 2[DI]\t;Exponent and sign of denominator\r\n\tMOV\tAX,WORD PTR 2[SI]\t;Exponent and sign of numerator\r\n\tXOR\tAL,CL\t\t;Compute sign\r\n\tMOV\tBYTE PTR $FAC+1,AL\t;Save sign in case OVERFLOW\r\n\tSUB\tAH,LOW 128D\t;Remove bias from exponents\r\n\tSUB\tCH,LOW 128D\r\n\tSUB\tAH,CH\t\t;Compute result exponent\r\n\tJO\tOVCHKJ\r\n\r\n;AH has the (tentative) true exponent of the result. It is correct if the\r\n;result needs normalizing one bit. If not, 1 will be added to it. A true\r\n;exponent of -128, not normally allowed except to represent zero, is OK\r\n;here because of this possible future incrementing.\r\n\r\n\tADD\tAH,LOW 128D\t;Put bias back\r\n\tPUSH\tAX\t\t;Save sign and exponent\r\n\tOR\tCL,LOW 200O\t;Set implied bit\r\n\tMOV\tDX,WORD PTR 1[SI]\t;Most significant part of numerator mantissa\r\n\tMOV\tAH,BYTE PTR 0[SI]\t;Least significant part\r\n\tXOR\tAL,AL\t\t;Extend with zero\r\n\tOR\tDH,LOW 200O\t;And set implied bit\r\n\tMOV\tBX,WORD PTR 1[DI]\t;Load denominator into BX:CX\r\n\tMOV\tCH,BYTE PTR 0[DI]\r\n\tXOR\tCL,CL\r\n\tOR\tBH,LOW 200O\r\n\r\n;Now we have the following configuration:\r\n;       Numerator in DX:AX\r\n;       Denominator in BX:CX\r\n; Both are extended to 32 bits with trailing zeros and have implied bit set\r\n;       Result will go in BX:DX\r\n;\r\n;The algorithm used here is similar to Algorithm D, p.237, Knuth vol. 2.\r\n;It is basically just ordinary long division, except the base is 2^16. This\r\n;means we are dividing two 2-digit numbers, where each \"digit\" takes a whole\r\n;word. We \"guess\" at a quotient digit, multiply it by the divisor, and subtract\r\n;from the current dividend to get a remainder. This remainder could be\r\n;negative, so we try a quotient digit one smaller.\r\n;\r\n;The \"guess\" at the quotient digit simply uses the 8086 DIV instruction.\r\n;Computing the remainder takes advantage of the remainder from this divide. If\r\n;the remainder comes out negative, new quotient digits are tried by repeated\r\n;addition, rather than another multiply. Theorem B on p.237 of Knuth vol. 2\r\n;guarantees that this repeated addition will happen no more than twice.\r\n\r\n\tSHR\tDX,1\r\n\tRCR\tAX,1\t\t;Ensure DX<BX so divide won't OVERFLOW\r\n\tCALL\tDIV16\t\t;Get first 16 bits of quotient\r\n\tPUSH\tSI\t\t;Save high half of quotient on stack\r\n\tCALL\tCDIV16\t\t;Get second 16 bits of quotient\r\n\tOR\tAX,DX\t\t;Remainder 0?\r\n\tMOV\tDX,SI\t\t;Want low half of result in DX\r\n\tJZ\tNSTK1\r\n\tOR\tDL,LOW 1\t;Set sticky bit if remainder not zero\r\nNSTK1:\r\n\tPOP\tBX\t\t;Recover high half of result\r\n\tJMP\tNORMCHK\r\n\r\nOVCHKJ:\r\n\tJNS\tFDS05\t\t;ZERO THE FAC\r\nSDIVOVFL:\r\n\tJMP\t$OVFLS\t\t;OVERFLOW\r\nDIV0:\tJMP\t$DIV0S\r\n\r\nCDIV16:\r\n\tCMP\tDX,BX\t\t;Will we OVERFLOW on divide?\r\n\tJAE\tMAXQUO\t\t;Special code for maximum quotient\r\nDIV16:\r\n\tDIV\tBX\t\t;32 by 16 bit division\r\n\tXCHG\tAX,SI\t\t;Put 16-bit quotient in SI\r\n\tXOR\tAX,AX\t\t;DX:AX has remainder\r\n\tJCXZ\tRETJ\t\t;Is this complete result?\r\n\tMOV\tDI,DX\t\t;Save remainder while we multiply\r\n\tMOV\tAX,SI\r\n\tMUL\tCX\t\t;Low half of divisor times quotient\r\n\tNEG\tAX\t\t;Subtract from remainder, whose low half is 0\r\n\tSBB\tDI,DX\r\n\tMOV\tDX,DI\t\t;Remainder again in DX:AX\r\n\tJNB\tRETJ\t\t;If not negative, divide was good\r\nRESTORE:\r\n\tDEC\tSI\t\t;Quotient is too big\r\n\tADD\tAX,CX\t\t;And remainder too small (negative)\r\n\tADC\tDX,BX\t\t;So add divisor back in till positive\r\n\tJNB\tRESTORE\r\nRETJ:\tRET\r\nNORMCHK:\r\n\tPOP\tAX\t\t;Get exp. and sign back\r\n\tOR\tBH,BH\t\t;See if normalized\r\n\tJS\tINCEXP\t\t;Yes-increment exponent\r\n\tSHL\tDX,1\t\t;Normalize\r\n\tRCL\tBX,1\r\n\tOR\tAH,AH\t\t;test exponent\r\n\tJNZ\tROUND\t\t;brif exponent not zero\r\n\tJMP\t$ZERO\t\t;underflow if exponent zero\r\n\r\nINCEXP:\r\n\tINC\tAH\r\n\tJZ\tSDIVOVFL\r\n$SRND:\r\n;Round single precision and store in $FACLO\r\n\r\nROUND:\r\n\tCMP\tDL,LOW 200O\t;Check extended bits\r\n\tJA\tROUNDUP\r\n\tJB\tSAVE\r\n;Extended bits equal exactly one-half LSB, so round even\r\n\tTEST\tDH,LOW 1\t;Already even?\r\n\tJZ\tSAVE\r\nROUNDUP:\r\n\tADD\tDH,LOW 1\r\n\tADC\tBX,0\t\t;Propagate carry\r\n\tJNB\tSAVE\t\t;OVERFLOW?\r\n;If we OVERFLOWed, BX:DH must now be zero, so we can leave it that way.\r\n\tINC\tAH\t\t;Increment exponent\r\n\tJZ\tSDIVOVFL\r\nSAVE:\r\n\tAND\tAL,LOW 200O\t;Strip to sign bit\r\n\tAND\tBH,LOW 177O\t;Mask off implied bit\r\n\tOR\tAL,BH\t\t;Combine sign with mantissa\r\n\tMOV\tWORD PTR $FACLO+2,AX\r\n\tMOV\tAH,BL\r\n\tMOV\tAL,DH\r\n\tMOV\tWORD PTR $FACLO,AX\t;Save lower part of mantissa\r\n\tRET\r\nMAXQUO:\r\n;Come here if divide instruction would OVERFLOW. This must mean that DX=BX,\r\n;i.e., the high half of the divisor and dividend are equal. Assume a result\r\n;of (2^16)-1, which will give us a remainder equal to divisor plus (low half\r\n;of dividend minus low half of divisor, times 2^16).\r\n\r\n\tMOV\tSI,-1\t\t;Quotient of (2^16)-1\r\n\tSUB\tAX,CX\t\t;Dividend - divisor (always negative)\r\n\tADD\tDX,AX\t\t;Add to high half of divisor\r\n\tMOV\tAX,CX\r\n\tJNB\tRESTORE\t;Carry means it's not negative any more\r\n\tRET\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\r\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "MATH2.ASM",
          "type": "blob",
          "size": 69.75,
          "content": "\tSUBTTL\t $FIDIG  ADD TEXT DIGIT TO CURRENT ACCUMULATED NUMBER\r\n;***************************************************************\r\n;\r\n;       $FIDIG  CONVERTS DIGIT POINTED TO BY (BX) TO BINARY\r\n;               VALUE AND ADDS TO NUMBER ACCUMULATED. AT THE\r\n;               APPROPRIATE TIMES CONVERSION WILL TAKE\r\n;               PLACE TO THE NEXT HIERARCHY OF NUMBERS,I.E.\r\n;               INTEGER-SINGLE PRECISION-DOUBLE PRECISION.\r\n;       CALLING SEQUENCE:       CALL    $FIDIG\r\n;               WITH (BX) POINTING TO NUMBER IN THE\r\n;               TEXT BUFFER. NUMBER IS ACCUMULATED IN THE FAC.\r\n;\r\n;****************************************************************\r\n\r\n;******************************************************************\r\n;AS $FIDIG IS ENTERED CF=1 AND (DI) WILL HOLD PLACES TO THE RIGHT OF\r\n;DECIMAL POINT (IF DECIMAL POINT HAS OCCURRED).(CX) WILL BE EITHER\r\n;ALL BITS SET OR ALL BITS CLEARED. ALL BITS SET INDICATES A DECIMAL\r\n;POINT HAS NOT BEEN SEEN YET AND (CX)=0 INDICATES D. P. SEEN\r\n;******************************************************************\r\n$FIDIG: ADC\tDI,CX\t\t;(DI) INCREMENTED ONLY IF D.P. SEEN\r\n\tPUSH\tBX\t\t;MUST NOW SAVE ALL NECESSARY REGS.\r\n\tPUSH\tDI\r\n\tPUSH\tCX\r\n\tSUB\tAL,LOW \"0\"      ;SUBTRACT OUT ASCII BIAS\r\n\tPUSH\tAX\t\t;SAVE ON STACK\r\n\tCALL\t$GETYP\t\t;SET CONDITION CODES\r\n\tPOP\tAX\t\t;RECALL DIGIT\r\n\tCBW\t\t\t;ZERO AH\r\n\tJNS\tFI05\t\t;MUST BE S.P. OR D.P. ALREADY\r\n\tMOV\tBX,WORD PTR $FACLO\t;FETCH THE INTEGER ALREADY ACCUM.\r\n\tCMP\tBX,3277D\t;IS IT ALREADY TOO BIG TO ADD\r\n\t\t\t\t;ANOTHER DIGIT TO?\r\n\tJNB\tFFI10\t\t;IF SO GO MAKE S.P. FIRST\r\n\tMOV\tCX,BX\t\t;SAVE ORIGINAL (BX)\r\n\tSHL\tBX,1\t\t;(BX)=(BX)*2\r\n\tSHL\tBX,1\t\t;(BX)=(BX)*4\r\n\tADD\tBX,CX\t\t;(BX)=(BX)*5\r\n\tSHL\tBX,1\t\t;(BX)=(BX)*10\r\n\tADD\tBX,AX\t\t;ADD IN THE DIGIT\r\n\tJS\tFFI10\t\t;IF SF=1 WE HAVE 32768 OR 32769\r\n\tMOV\tWORD PTR $FACLO,BX\t;STORE IN $FAC\r\n\tJMP\tSHORT FI50\r\nFI05:\t\t\t\t;TO GET HERE NUMBER WAS ALREADY S.P. OR D.P.\r\n\tPUSH\tAX\t\t;SAVE THE NUMBER\r\n\tJB\tFFFI20\t\t;IT'S CURRENTLY SINGLE PRECISION\r\n\tJMP\tSHORT FI40\t;DOUBLE PRECISION\r\nFFI10:\t\t\t\t;TO GET HERE NUMBER WAS PREVIOUSLY AN INTEGER BUT HAS\r\n\t\t\t\t;GROWN TOO LARGE - MUST MAKE IT SINGLE PRECISION\r\n\tPUSH\tAX\t\t;SAVE THE NUMBER\r\n\tCALL\t$CSI\t\t;CONVERT INTEGER TO S.P.\r\n\tJMP\tSHORT FI30\t;MUL BY 10 AND ADD IN DIGIT\r\nFFFI20:\t\t\t;TO GET HERE NUMBER WAS ALREADY SINGLE PRECISION\r\n\t\t\t\t;MUST CHECK TO SEE IF ACCURACY MIGHT BE LOST IF WE\r\n\t\t\t\t;MULTIPLY OUR FAC BY 10,I.E. FAC MUST BE SMALLER\r\n\t\t\t\t;THAN 1000000.\r\n\tMOV\tWORD PTR $DBUFF+4,22000\r\n\tMOV\tWORD PTR $DBUFF+6,112164\r\n\tMOV\tBX,OFFSET $DBUFF+6\r\n\tCALL\t$COMPM\t\t;COMPARE TO $FAC\r\n\tJNS\tFI35\t\t;GO DO D.P. IF TOO LARGE FOR S.P.\r\nFI30:\tCALL\t$MUL10\t\t;MULTIPLY $FAC BY 10\r\n\tPOP\tDX\t\t;RECALL DIGIT\r\n\tPUSH\tWORD PTR $FACLO\r\n\tPUSH\tWORD PTR $FAC-1 ;FAC PUSHED ON STACK\r\n\tCALL\t$FLT\t\t;CONVERT INTEGER TO S.P.\r\n\tPOP\tBX\t\t;RECALL FAC\r\n\tPOP\tDX\r\n\tCALL\t$FADDS\t\t;ADD IN THE NEW DIGIT\r\n\tJMP\tSHORT FI50\t;GET STACK RIGHT AND RETURN\r\nFI35:\t\t\t\t;TO GET HERE WE ALREADY HAVE 7 DIGITS AND WOULD\r\n\t\t\t\t;HAVE A LOSS OF ACCURACY IF WE CONTINUED IN S.P. SO WE\r\n\t\t\t\t;NEED TO CONVERT TO D.P. MULTIPLY BY 10 AND ADD IN THE DIG.\r\n\tCALL\t$CDS\t\t;CONVERT THE SINGLE TO D.P.\r\nFI40:\tCALL\t$MUL10\t\t;MULTIPLY BY 10\r\n\tCALL\t$MOVAF\t\t;MOVE $FAC TO $ARG\r\n\tPOP\tDX\t\t;RECALL DIGIT\r\n\tCALL\t$FLT\t\t;CONVERT TO S.P.\r\n\tCALL\t$CDS\t\t;CONVERT TO D.P.\r\n\tCALL\t$FADDD\t\t;ADD IN THE OLD ACCUMULATED VALUE\r\nFI50:\tPOP\tCX\t\t;GET DECIMAL POINT FLAG BACK\r\n\tPOP\tDI\t\t;GET NO. DIGITS TO RIGHT OF DECIMAL PT.\r\n\tPOP\tBX\t\t;GET TEXT POINTER BACK\r\n\tRET\t\t\t;COMPLETE\r\n\r\n\tSUBTTL\t $FINEX  EXPONENT INPUT ROUTINE\r\n;*************************************************************\r\n;\r\n;       $FINEX  THE PURPOSE OF THIS ROUTINE IS TO DETERMINE\r\n;               THE INPUT EXPONENT BASE 10 AND LEAVE IN (DX).\r\n;               ADDITIONALLY IF A MINUS \"-\" SIGN IS ENCOUNTERED\r\n;               $FINEX WILL SET ALL BITS OF (SI). OTHERWISE ALL\r\n;               BITS OF (SI) WILL BE CLEARED.\r\n;       CALLING SEQUENCE:       CALL    $FINEX\r\n;               WITH THE SIGNIFICANT DIGITS OF THE NUMBER IN\r\n;               THE FAC.\r\n;\r\n;***************************************************************\r\n\r\n$FINEX: LAHF\t\t\t;SAVE STATUS\r\n\tCMP\tBYTE PTR $VALTP,LOW 10\t;SEE IF ALREADY D.P.\r\n\tJNZ\tEXA\r\n\tSAHF\t\t\t;GET STACK RIGHT\r\n\tJMP\tEXB\r\nEXA:\tSAHF\t\t\t;RESTORE CODES\r\n\tPUSH\tBX\t\t;SAVE IMPORTANT REGISTERS\r\n\tPUSH\tDI\t\t;PRECISION ACCORDING TO ZF. IF\r\n\tCALL\t$FINFC\t\t;ZF=1 S.P.:ZF=0 THEN D.P.\r\n\tPOP\tDI\t\t;RECALL DIGITS TO RIGHT OF D.P.\r\n\tPOP\tBX\t\t;RECALL TEXT POINTER\r\nEXB:\tXOR\tSI,SI\t\t;IN CASE EXPONENT IS POSITIVE\r\n\tMOV\tDX,SI\t\t;WILL BUILD EXPONENT IN DX\r\n\tCALL\t$CHRGT\t\t;GET FIRST CHARACTER OF EXPONENT\r\n\tJB\tFX20\t\t;NO SIGN SO DEFAULT POS.\r\n\tCMP\tAL,LOW \"-\"      ;NEGATIVE EXPONENT\r\n\tJNZ\tFX00\t\t;IF NOT MUST BE POSITIVE\r\n\tNOT\tSI\t\t;NEGATIVE EXPONENT\r\n\tJMP\tSHORT FX10\t;GO GET NEXT CHARACTER\r\nFX00:\tCMP\tAL,LOW \"+\"\r\n\tJZ\tFX10\r\n\t\t\t\t;ILLEGAL CHARACTER MUST LEAVE\r\n\tRET\t\t\t;(BX) POINTING HERE\r\nFX10:\tCALL\t$CHRGT\t\t;GET NEXT CHARACTER\r\n\tJB\tFX20\t\t;IF DIGIT PROCESS AS EXPONENT\r\n\tRET\t\t\t;OTHERWISE RETURN\r\nFX20:\tCMP\tDX,3276D\t;OVERFLOW IF THIS DOESN'T GET CF=1\r\n\tJB\tFX30\t\t;NO-USE THIS DIGIT\r\n\tMOV\tDX,32767D\t;TO ASSURE OVERFLOW\r\n\tJMP\tSHORT FX10\r\nFX30:\tPUSH\tAX\t\t;SAVE NEW DIGIT\r\n\tMOV\tAX,10D\t\t;MUST MULTIPLY DX BY 10\r\n\tMUL\tDX\t\t;ANSWER NOW IN AX\r\n\tPOP\tDX\t\t;RECALL DIGIT TO DX\r\n\tSUB\tDL,LOW 60\t;SUBTRACT OUT ASCII BIAS\r\n\tXOR\tDH,DH\t\t;TO BE SURE AX HAS CORRECT NO.\r\n\tADD\tDX,AX\t\t;ADD TO DX\r\n\tJMP\tSHORT FX10\r\n\r\n\tSUBTTL\t FINFC\t INPUT FORCE ROUTINES FOR \"#\",\"%\",\"!\"\r\n;*********************************************************\r\n;\r\n;       FINFC   THIS MODULE CONTAINS THE ROUTINES $FINI,\r\n;               $FIND, AND $FINS FOR FORCING THE INPUT TO\r\n;               INTEGER, DOUBLE PRECISION OR SINGLE PRECISION\r\n;               RESPECTIVELY IN RESPONSE TO AN INPUT \"$\",\"#\", OR\r\n;               \"!\". ADDITIONALLY THIS MODULE CONTAINS\r\n;               THE UTILITY ROUTINES $FI,$FS,$FD,$CSI,$CSD,$CDS\r\n;               FOR FORCING INTEGER,SINGLE,DOUBLE,CONVERTING\r\n;               INTEGER TO SINGLE,CONVERTING DOUBLE TO SINGLE, AND\r\n;               CONVERTING SINGLE TO DOUBLE, RESPECTIVELY\r\n;       CALLING SEQUENCE:       CALL    $FINI\r\n;               OR              CALL    $FIND\r\n;               OR              CALL    $FINS\r\n;               OR              CALL    $FS\r\n;               OR              CALL    $FD\r\n;               OR              CALL    $FI\r\n;               OR              CALL    $CSI\r\n;               OR              CALL    $CSD\r\n;               OR              CALL    $CDS\r\n;               WITH THE FAC CONTAINING THE CURRENT ACCUMULATED\r\n;               NUMBER.\r\n;\r\n;***********************************************************\r\n\r\n$FIND:\t\t\t\t;FORCE INPUT TO DOUBLE PRECISION\r\n\tOR\tAL,LOW 1\t;TO SIGNAL DOUBLE PRECISION\r\n$FINS:\t\t\t\t;FORCE INPUT TO SINGLE PRECISION (caller has set Z flag)\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tPUSH\tDI\t\t;SAVE NO DIGITS AFTER DECIMAL POINT\r\n\tJNZ\tFC10\t\t;Force to double for $FIND callers.\r\n\tCALL\t$FS\t\t;Force to single for $FINS callers.\r\n\tJMP\tSHORT FC20\t;Skip over $FD call.\r\n\r\nFC10:\tCALL\t$FD\t\t;FORCE FAC TO DOUBLE PREC.\r\nFC20:\tPOP\tDI\t\t;RECALL NO DIGITS TO RT. OF DEC PT\r\n\tPOP\tBX\t\t;RECALL TEXT POINTER\r\n\tXOR\tSI,SI\t\t;SINCE THIS IS A FORCED\r\n\tMOV\tDX,SI\t\t;NO. EXPONENT IS ZERO\r\n\tCALL\t$FINE\t\t;DO IMPLIED EXPONENT FIX-UP\r\nFC30:\tINC\tBX\t\t;Point past the force character and\r\n\tRET\t\t\t;return.\r\n\r\n$FINI:\tCALL\t$GETYP\t\t;SET COND CODES ACCORDING TO TYPE\r\n\tJS\tFC30\r\n\tJMP\t$SNERR\t\t;CAN'T MAKE INTEGER IF NOT ALREADY\r\n$FINFC: JZ\t$FD\t\t;IF ZF=1 THEN DOUBLE PRECISION\r\nFRCSNG:\r\n$FS:\t\t\t\t;FORCE SINGLE PRECISION\r\n\tCALL\t$GETYP\t\t;SET COND CODES ACC. TO TYPE\r\n\tJPO\tFC200\t\t;IF ALREADY S.P. RETURN\r\n\tJNZ\tFS10\r\n\tJMP\t$TMERR\t\t;CAN'T FORCE A STRING\r\nFS10:\r\n\tJNS\t$CSD\t\t;IF NOT INTEGER FORCE DOUBLE TO S.P.\r\n\tCALL\t$CSI\t\t;FORCE INTEGER TO SINGLE\r\n\tJMP\tSHORT FC200\r\n$CSD:\t\t\t\t;CONVERT DOUBLE TO SINGLE PRECISION\r\n\tMOV\tAL,LOW 4\t;SINGLE PREC DESIGNATION\r\n\tMOV\tBYTE PTR $VALTP,AL\r\n\tMOV\tBL,BYTE PTR $FAC-1\t;FETCH HIGH MANTISSA BITS\r\n\tMOV\tBYTE PTR $FAC+1,BL\t;MOVE SIGN TO $FAC+1\r\n\tMOV\tDX,WORD PTR $FAC-3\t;FETCH REST OF MANTISSA\r\n\tMOV\tAH,BYTE PTR $FAC-4\t;FETCH OVERFLOW BITS\r\n\tOR\tAH,LOW 100\t;WANT ROUND-UP IF HIGH BIT SET\r\n\tOR\tBL,LOW 200\t;PUT IN UNDERSTOOD 1\r\n\tJMP\t$ROUNM\t\t;GO ROUND THE NUMBER\r\nFRCDBL:\r\n$FD:\t\t\t\t;FORCE TO DOUBLE PRECISION\r\n\tCALL\t$GETYP\t\t;DETERMINE CURRENT TYPE\r\n\tJNB\tFC200\t\t;IF ALREADY DOUBLE EXIT\r\n\tJNZ\tFD10\r\n\r\n\tJMP\t$TMERR\r\nFD10:\r\n\tJNS\t$CDS\t\t;IF NOT INTEGER PROCEED\r\n\tCALL\t$CSI\t\t;CONVERT INTEGER TO SINGLE PREC.\r\n$CDS:\tMOV\tAL,LOW 10\t;DOUBLE PREC. INDICATOR\r\n\tMOV\tBYTE PTR $VALTP,AL\t;SET TYPE TO D.P.\r\n\tXOR\tAX,AX\t\t;MUST ZERO OVERFLOW BYTES\r\n\tMOV\tWORD PTR $DFACL,AX\r\n\tMOV\tWORD PTR $DFACL+2,AX\r\n\tRET\r\n$CSI:\tPUSH\tDX\t\t;SAVE (DX)\r\n\tPUSH\tSI\t\t;SAVE (SI)\r\n\tMOV\tDX,WORD PTR $FACLO\t;FETCH THE INTEGER\r\n\tCALL\t$FLT\t\t;FLOAT THE INTEGER AND STORE IN FAC\r\n\tPOP\tSI\t\t;GET REGISTERS RIGHT\r\n\tPOP\tDX\r\nFC200:\tRET\r\nFRCINT:\r\n$FI:\t\t\t\t;FORCE INTEGER\r\n\tCALL\t$GETYP\t\t;SEE WHAT WE'RE IN FOR\r\n\tJNS\tFI10\t\t;IF NOT INTEGER ALREADY - JUMP\r\n\tMOV\tBX,WORD PTR $FACLO\r\n\tRET\r\nFI10:\r\n\tJNZ\tFFI20\r\n\tJMP\t$TMERR\t\t;IF STRING - ERROR\r\nFFI20:\r\n$CINC:\t\t\t\t;Single precision, operand in FAC\r\n$CIND:\t\t\t\t;Double precision uses same routine\r\n\tPUSH\tAX\r\n\tPUSH\tCX\r\n\tMOV\tAX,WORD PTR $FACM1\t;Get exponent\r\n\tMOV\tCX,WORD PTR $FACLO\t;Get mantissa\r\nCINT:\r\n\tXOR\tBX,BX\t\t;Set up zero result\r\n\tSUB\tAH,LOW 200O\t;Take bias out of exponent\r\n\tJB\tCXRET\t\t;Return zero if no integer part\r\n\tMOV\tBH,AL\t\t;Highest byte of mantissa\r\n\tMOV\tBL,CH\r\n\tXCHG\tAX,CX\r\n\tMOV\tCL,LOW 16D\r\n\tSUB\tCL,CH\t\t;Number of bits to shift mantissa right\r\n\tMOV\tAH,BH\t\t;Save sign\r\n\tJB\tOVERFLOW\t;If negative shift, it won't fit in 16 bits\r\n\tJZ\tOVCHK\t\t;Only -32768 has 16 bits - go check for it\r\n\tOR\tBH,LOW 200O\t;Set implied bit\r\n\tSHR\tBX,CL\t\t;Position the integer\r\n\tADC\tBX,0\t\t;Perform rounding\r\n\tJO\tPOSBOVER\r\n\tOR\tAH,AH\t\t;Check sign now\r\n\tJNS\tCXRET\r\n\tNEG\tBX\r\nCXRET:\r\n\tPOP\tCX\r\n\tPOP\tAX\r\n\tMOV\tWORD PTR $FACLO,BX\t;Result in both FAC and BX\r\n\r\nVALINT:\r\n$VALNT: MOV\tBYTE PTR $VALTP,LOW 2\r\n\tRET\r\nPOSBOVER:\t\t\t;Here for either -32768 or overflow\r\n\tOR\tAH,AH\t\t;If signed then -32768\r\n\tJS\tCXRET\r\n\tJMP\tSHORT OVERFLOW\r\nOVCHK:\r\n;Come here if no shift is needed on the number, i.e., it requires a full\r\n;16 bits. Only -32768 (8000H) is allowed.\r\n\tCMP\tBX,100000O\t;The 1 is sign bit (negative), not implied bit\r\n\tJNZ\tOVERFLOW\r\n\tTEST\tAL,LOW 200O\t;Should we be rounding up?\r\n\tJZ\tCXRET\t\t;If so, that causes overflow\r\nOVERFLOW:\r\n\tJMP\t$OVERR\r\n\r\n\tSUBTTL\t $FLT\t CONVERT INTEGER IN (DX) TO REAL AND STORE IN FAC\r\n;****************************************************************\r\n;       $FLT    CONVERTS THE SIGNED INTEGER IN (DX) TO A REAL\r\n;               (FLOATING POINT ) NUMBER AND STORES IT IN THE FAC\r\n;               AND SETS $VALTP=4\r\n;*****************************************************************\r\n$FLT:\tXOR\tBX,BX\t\t;CLEAR HIGH MANTISSA BYTE (BL)\r\n\tXOR\tAH,AH\t\t;CLEAR OVERFLOW BYTE\r\n\tMOV\tSI,OFFSET $FAC+1\t;FETCH $FAC ADDRESS TO (SI)\r\n\tMOV\tBYTE PTR -1[SI],LOW 220 ;SET EXPONENT TO 16\r\n\tMOV\tBYTE PTR 0[SI],LOW 0\t;SET SIGN POSITIVE\r\n\tOR\tDX,DX\t\t;SETS SF=1 IF NEGATIVE NO.\r\n\tJNS\tFLT10\t\t;IF POSITIVE PROCEED\r\n\tNEG\tDX\t\t;NEED POSTIVE MAGNITUDE\r\n\tMOV\tBYTE PTR 0[SI],LOW 200\t;SET SIGN TO NEGATIVE\r\nFLT10:\tMOV\tBL,DH\t\t;WILL MOVE (DX) TO (BLDH)\r\n\tMOV\tDH,DL\t\t;\r\n\tMOV\tDL,BH\t\t;SET (DL)=0\r\n\tMOV\tBYTE PTR $VALTP,LOW 4\t;SET TYPE TO S.P.\r\n\tJMP\t$NORMS\t\t;GO NORMALIZE\r\n\r\n\tSUBTTL\t $FMULD  DOUBLE PRECISION MULTIPLICATION\r\n;**************************************************************\r\n;\r\n;       $FMULD  THIS ROUTINE FORMS THE DOUBLE PRECISION PRODUCT\r\n;               ($FAC):=($FAC)*($ARG)\r\n;               THE TECHNIQUE USED IS DESCRIBED IN KNUTH, VOL II\r\n;               P.233 AND IS CALLED ALGORITHM \"M\"\r\n;       CALLING SEQUENCE:       CALL    $FMULD\r\n;               WITH THE MULTIPLIER AND MULTIPLICAND IN THE\r\n;               $FAC AND $ARG\r\n;\r\n;**************************************************************\r\n\r\nDMULT:\r\n$FMULD:\t\t\t;DOUBLE PRECISION MULT., (FAC)=(FAC)*(ARG)\r\n\tMOV\tAL,BYTE PTR $FAC\t;WILL FIRST SEE IF FAC IS ZERO\r\n\tOR\tAL,AL\t\t;AND IF SO JUST RETURN\r\n\tJZ\tFMD10\r\n\tMOV\tAL,BYTE PTR $ARG\t;WILL NOW SEE IF ARG IS ZERO AND\r\n\tOR\tAL,AL\t\t;IF SO SET FAC TO ZERO AND RETURN\r\n\tJNZ\tFMD20\t\t;IF NOT ZERO PROCEED TO MULTIPLY\r\n\tJMP\t$DZERO\t\t;ZERO THE FAC\r\nFMD10:\tRET\r\nFMD20:\r\n\tMOV\tBX,WORD PTR $ARG-1\t;FETCH SIGN AND EXP. TO BX\r\n\tCALL\t$AEXPS\t\t;ADD THE EXPONENTS\r\n\tPUSH\tWORD PTR $FAC\t;EXPONENT,SIGN\r\n\tMOV\tWORD PTR $ARG-1,BX\t;REPLACE UNPACKED MANTISSA\r\n\t\t\t\t;PUT THE SIGN OF THE PRODUCT IN\r\n\t\t\t\t;FAC+1\r\n\tCALL\t$SETDB\t\t;MOVE THE FAC TO $DBUFF SO PRODUCT\r\n\t\t\t\t;CAN BE FORMED IN THE FAC, AND ZERO\r\n\t\t\t\t;THE FAC AND RETURNS WITH (AX)=0\r\n\tMOV\tSI,AX\t\t;J\r\n\tMOV\tWORD PTR $FAC,AX\r\n\tMOV\tBX,OFFSET $DBUFF\t;\r\n\tMOV\tWORD PTR $ARG,AX\r\n\tMOV\tBP,OFFSET $ARGLO\t;POINT TO MULTIPLICAND BASE\r\nM1:\tMOV\tAX,WORD PTR 0[BX+SI]\t;FETCH MULTIPLIER V(J)\r\n\tOR\tAX,AX\t\t;SEE IF ZERO\r\n\tJZ\tM4D\t\t;IF ZERO W(J)=0\r\n\tMOV\tDI,0\t\t;I\r\n\tMOV\tCX,DI\t\t;K\r\nM4:\tMOV\tAX,WORD PTR 0[BX+SI]\t;FETCH MULTIPLIER V(J)\r\n\tMUL\tWORD PTR 0[BP+DI]\t;FORM PRODUCT V(J)*U(J) IN (DXAX)\r\n\tPUSH\tBX\t\t;SAVE PTR. TO MULTIPLIER BASE\r\n\tMOV\tBX,SI\t\t;\r\n\tADD\tBX,DI\t\t;I+J\r\n\tADD\tBX,OFFSET $DFACL-10\t;W(I+J) ADDRESS IN BX\r\n\tADD\tAX,WORD PTR 0[BX]\t;(DXAX)=U(I)*V(J)+W(I+J)\r\n\tJNB\tM4A\r\n\tINC\tDX\r\nM4A:\tADD\tAX,CX\t\t;T=U(I)*V(J)+W(I+J)+K\r\n\tJNB\tM4B\r\n\tINC\tDX\r\nM4B:\tMOV\tWORD PTR 0[BX],AX\t;W(I+J)= T MOD 2^16\r\n\tMOV\tCX,DX\t\t;K=INT(T/2^16)\r\n\tPOP\tBX\t\t;RECALL PTR TO MULTIPLIER BASE\r\n\tCMP\tDI,6\t\t;FINISHED INNER LOOP?\r\n\tJZ\tM4C\t\t;IF SO JUMP AND SET W(J)\r\n\tINC\tDI\r\n\tINC\tDI\r\n\tJMP\tSHORT M4\r\nM4C:\tMOV\tAX,CX\t\t;(AX)=K\r\nM4D:\tPUSH\tBX\t\t;SAVE PTR TO MULTIPLIER BASE\r\n\tMOV\tBX,OFFSET $DFACL\r\n\tMOV\tWORD PTR 0[BX+SI],AX\t;W(J)=K OR 0 (0 IF V(J) WERE 0)\r\n\tPOP\tBX\t\t;RECALL PTR TO MULTIPLIER BASE\r\n\tCMP\tSI,6\t\t;FINISHED OUTER LOOP?\r\n\tJZ\tM5\r\n\tINC\tSI\r\n\tINC\tSI\r\n\tJMP\tSHORT M1\r\nM5:\t\t\t\t;MULTIPLICATION COMPLETE AND IN FAC\r\n\tMOV\tSI,OFFSET $DFACL-2\t;WILL NOW SET ST\r\n\tSTD\t\t\t;WANT NON-ZERO BYTE ASAP SO PROB.\r\n\t\t\t\t;SEEMS HIGHER OF GETTING ONE IF\r\n\t\t\t\t;(SI) IS DECREMENTED\r\n\tMOV\tCX,7\t\t;7-BYTE CHECK\r\nM5AA:\tLODSB\t\t\t;FETCH NEXT BYTE\r\n\tOR\tAL,AL\r\n\tLOOPZ\tM5AA\r\n\tJZ\tM5AB\t\t;DON'T NEED TO SET ST\r\n\tOR\tBYTE PTR $DFACL-1,LOW 40\t;\"OR\" IN ST BIT\r\nM5AB:\r\n\tMOV\tAL,BYTE PTR $FAC-1\t;SEE IF WE NEED TO INC EXPONENT\r\n\tOR\tAL,AL\r\n\tPOP\tWORD PTR $FAC\t;RESTORE EXPONENT,SIGN\r\n\tJS\tM6\r\n\tMOV\tBX,OFFSET $DFACL-1\t;MUST SHIFT 1 BIT LEFT\r\n\tMOV\tCX,4\r\nM5A:\tRCL\tWORD PTR 0[BX],1\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tLOOP\tM5A\r\nM5B:\tJMP\t$ROUND\t\t;NOW ROUND\r\nM6:\tINC\tBYTE PTR $FAC\t;INCREMENT EXPONENT\r\n\tJNZ\tM5B\r\n\tJMP\t$OVFLS\t\t;OVERFLOW!\r\n\r\n\tSUBTTL\t $FMULS  SINGLE PRECISION 8086 MULTIPLICATION\r\n;**********************************************************\r\n;       $FMULS  FMULS MULTIPLIES THE SINGLE PRECISION\r\n;               FLOATING POINT QUANTITIES (BXDX) AND (FAC)\r\n;               AND RETURNS THE PRODUCT IN THE (FAC). ONLY\r\n;               SEGMENT REGISTERS ARE PRESERVED.\r\n;***********************************************************\r\n\r\n$FMULS:\t\t\t;(FAC)=(BXDX)*(FAC)\r\n\tCALL\t$SIGNS\t\t;ZF=1 WILL BE SET IF (FAC)=0\r\n\tJZ\tFMS00\t\t;JUST RETURN IF (FAC)=0\r\n\tOR\tBH,BH\t\t;IF EXPONENT OF (BXDX) IS ZERO\r\n\tJNZ\tFMS05\t\t;PROCEED IF NON-ZERO\r\nFMS00:\tJMP\t$ZERO\t\t;THE NUMBER IS ZERO.\r\nFMS05:\r\n\tCALL\t$AEXPS\t\t;ADD THE S.P. EXPONENTS\r\n;***************************************************************\r\n;WILL NOW PROCEED TO MULTIPLY THE MANTISSAS. THE MULTIPLICATION\r\n;WILL UTILIZE THE 16 BIT MUL INSTRUCTION AND THUS WILL TAKE\r\n;PLACE AS PARTIAL PRODUCTS SINCE WE HAVE 24 BIT MANTISSAS TO\r\n;MULTIPLY.\r\n;***************************************************************\r\n\tMOV\tCX,WORD PTR $FAC-1\t;(CH)=($FAC):(CL)=($FAC-1)\r\n\tXOR\tCH,CH\t\t;(CX) CONTAINS HIGH MANTISSA BITS\r\n\tMOV\tAX,WORD PTR $FAC-3\t;(AX) CONTAINS LOW MANTISSA BITS OF FAC\r\n\tMOV\tBH,CH\t\t;SET (BH)=0 AS WELL\r\n;*************************************************************\r\n;AT THIS POINT WE HAVE THE FAC MANTISSA IN (CLAX) AND THE\r\n;(BXDX) MANTISSA IN (BLDX). THE UNDERSTOOD LEADING MANTISSA\r\n;BIT WAS INSTALLED BY $AEXPS AND THE SIGN OF THE PRODUCT\r\n;WAS STORED IN FAC+1\r\n;THE PRODUCT WILL BE FORMED IN (BXCX) BY PARTIAL PRODUCTS.\r\n;FIRST THE NECESSARY ELEMENTS WILL BE PUSHED ON THE STACK\r\n;THEN UTILIZED IN REVERSE ORDER(THAT'S THE BEST WAY TO\r\n;GET THE THEM OFF THE LIFO STACK -TURKEY!)\r\n;************************************************************\r\n\tMOV\tSI,BX\r\n\tMOV\tDI,CX\r\n\tMOV\tBP,DX\r\n\tPUSH\tCX\t\t;HIGH FAC MANTISSA BITS\r\n\tPUSH\tAX\t\t;LOW FAC MANTISSA BITS\r\n\tMUL\tDX\t\t;32 BIT PRODUCT FORMED(ONLY NEED\r\n\tMOV\tCX,DX\t\t;MOST 16 SIGNIFICANT BITS)\r\n\tPOP\tAX\t\t;LOW FAC MANTISSA BITS\r\n\tMUL\tBX\t\t;TIMES HIGH MANTISSA BITS OF (BLDX)\r\n\tADD\tCX,AX\t\t;ADD TO PREVIOUS CALCULATION\r\n\tJNB\tFMS10\t\t;IF CARRY NOT PRODUCED PROCEED\r\n\tINC\tDX\r\nFMS10:\tMOV\tBX,DX\t\t;PROBABLY ONLY 8 BITS HERE\r\n\tPOP\tDX\t\t;HIGH FAC MANTISSA BITS\r\n\tMOV\tAX,BP\t\t;LOW 16 MANTISSA BITS OF (BLDX)\r\n\tMUL\tDX\t\t;\r\n\tADD\tCX,AX\t\t;ADD IN LOW ORDER BITS\r\n\tJNB\tFMS20\t\t;JUMP IF CARRY NOT PRODUCED\r\n\tINC\tDX\t\t;\r\nFMS20:\tADD\tBX,DX\t\t;CAN'T PRODUCE CARRY HERE\r\n\tMOV\tDX,DI\t\t;HIGH FAC MANTISSA BITS\r\n\tMOV\tAX,SI\t\t;HIGH FAC MANTISSA BITS\r\n\tMUL\tDL\t\t;(AX) HAS ENTIRE PRODUCT\r\n\tADD\tBX,AX\t\t;ADD IT IN\r\n\tJNB\tFMS30\t\t;IF NO CARRY PROCEED\r\n\tRCR\tBX,1\t\t;MOVE EVERYTHING RIGHT\r\n\tRCR\tCX,1\t\t;\r\n\tINC\tBYTE PTR $FAC\t;MUST NOW CHECK FOR OVERFLOW\r\n\tJNZ\tFMS30\t\t;PROCEED IF NON-ZERO\r\n\tJMP\t$OVFLS\r\nFMS30:\t\t\t\t;PRODUCT FORMED, MUST NOW GET MANTISSA IN (BLDXAH) FOR ROUNS\r\n\t\t\t\t;PRODUCT IS CURRENTLY IN (BXCX)\r\n\tOR\tBH,BH\t\t;MUST BE SURE PRODUCT LEFT JUSTIFIED\r\n\tJNS\tFMS35\t\t;IN (BXCX)\r\n\tINC\tBYTE PTR $FAC\t;NEED TO INCREMENT EXP.\r\n\tJNZ\tFMS37\t\t;IF NOT OVERFLOW PROCEED\r\n\tJMP\t$OVFLS\t\t;OVERFLOW JUMP\r\nFMS35:\r\n\tRCL\tCX,1\r\n\tRCL\tBX,1\r\nFMS37:\r\n\tMOV\tDL,CH\r\n\tMOV\tDH,BL\r\n\tMOV\tBL,BH\r\n\tMOV\tAH,CL\t\t;OVERFLOW BYTE\r\n\tJMP\t$ROUNS\t\t;GO ROUND\r\n\tRET\r\n\r\n\tSUBTTL\t $FOTAN  ROUTINE TO PUT IN DECIMAL POINT AND LEADING ZEROS\r\n;*****************************************************************\r\n;\r\n;       $FOTAN  THIS ROUTINE IS CALLED BY THE FREE FORMAT OUTPUT\r\n;               CODE TO OUTPUT DECIMAL POINT AND LEADING ZEROS.\r\n;       $FOTED  THIS ROUTINE IS CALLED BY BOTH THE FREE FORMAT\r\n;               OUTPUT ROUTINE AND THE PRINT USING CODE TO OUTPUT\r\n;               THE DECIMAL POINT WHEN NECESSARY AND TO PUT IN\r\n;               COMMAS \",\" AFTER EACH THREE DIGITS IF THIS OPTION\r\n;               IS INVOKED.\r\n;       CALLING SEQUENCE:       CALL    $FOTAN\r\n;                               CALL    $FOTED\r\n;               WITH $FMTCX CONTAINING NUMBER PLACES PRIOR TO\r\n;               DECIMAL POINT(NEGATIVELY) IN UPPER BYTE AND\r\n;               NO PLACES BEFORE NEXT COMMA IN LOW BYTE\r\n;\r\n;*******************************************************************\r\n\r\n$FOTAN:\r\n\tDEC\tCH\t\t;IF NEGATIVE THEN LEADING ZEROS\r\n\tJNS\tFTD05\t\t;\r\n\tMOV\tWORD PTR $DPADR,BX\t;SAVE DECIMAL POINT COUNT\r\n\tMOV\tBYTE PTR 0[BX],LOW \".\"  ;MOVE IN DECIMAL POINT\r\nFTN10:\tINC\tBX\t\t;POINT TO NEXT OUTPUT POSITION\r\n\tMOV\tBYTE PTR 0[BX],LOW \"0\"  ;PUT IN LEADING ZERO\r\n\tINC\tCH\t\t;WILL INCREMENT CH UNTIL ZERO\r\n\tJNZ\tFTN10\t\t;PUT IN LEADING ZEROS UNTIL CH ZERO\r\n\tINC\tBX\t\t;POINT TO NEXT BUFFER POSITION\r\n\tXOR\tCX,CX\t\t;ZERO OUT DECIMAL POINT AND COMMA CTS.\r\n\tJMP\tSHORT FTD20\t;GET STACK RIGHT AND RETURN\r\n$FOTED:\r\n\tDEC\tCH\t\t;SEE IF TIME FOR D.P.\r\nFTD05:\tJNZ\tFTD10\t\t;IF NOT D.P. TIME SEE IF COMMA TIME\r\n\tMOV\tBYTE PTR 0[BX],LOW \".\"  ;PUT IN D.P.\r\n\tMOV\tWORD PTR $DPADR,BX\t;SAVE ADDR OF DECIMAL POINT\r\n\tINC\tBX\t\t;INCREMENT PAST D.P.\r\n\tXOR\tCX,CX\t\t;ZERO COUNTS & SET ZF=1\r\n\tJMP\tSHORT FTD20\t;GET STACK RIGHT AND RETURN\r\nFTD10:\tDEC\tCL\t\t;IF ZERO TIME FOR COMMA\r\n\tJNZ\tFTD20\r\n\tMOV\tBYTE PTR 0[BX],LOW 54O\t;COMMA\r\n\tINC\tBX\t\t;POINT TO NEXT BUFFER POSITION\r\n\tMOV\tCL,LOW 3\t;\r\nFTD20:\tMOV\tWORD PTR $FMTCX,CX\t;UPDATE D.P.&COMMA COUNTS\r\n\tRET\r\n\r\n\tSUBTTL\t $FOTCV  CONVERT FAC TO ASCII DIGITS\r\n;************************************************************\r\n;\r\n;       $FOTCV  CONVERSION OF SINGLE OR DOUBLE PRECISION\r\n;               NUMBER TO ASCII DIGITS.IF DOUBLE PRECISION\r\n;               10 DIGITS WILL BE CONVERTED WITH DOUBLE\r\n;               PRECISION POWER OF TEN INTEGERS, 3 DIGITS\r\n;               WITH SINGLE PRECISION POWER OF TEN INTEGERS\r\n;               AND 3 DIGITS WITH INTEGER POWERS OF TEN\r\n;       CALLING SEQUENCE:       CALL    $FOTCV\r\n;               WITH THE NUMBER TO BE CONVERTED HAVING PREVIOUSLY\r\n;               BEEN OPERATED ON BY $FOTNV TO BRACKET THE\r\n;               NUMBER AND HAVE ALL DIGITS IN THE INTEGER PORTION\r\n;               OF THE FAC. AND THE CORRESPONDING EXPONENT WILL\r\n;               BE SAVED ON THE STACK AND CONVERTED LATER.\r\n;\r\n;**************************************************************\r\n\r\n$FOTCV: CALL\t$GETYP\t\t;SET CONDITION CODES FOR VALTYP\r\n\tJPO\tFCV40\t\t;IF SINGLE PRECISION GO PROCESS\r\n\tPUSH\tCX\t\t;SAVE DIGIT AND COMMA COUNT\r\n\tPUSH\tBX\t\t;SAVE BUFFR PTR.\r\n\tMOV\tSI,OFFSET $DFACL\t;WILL MOVE FAC TO ARG\r\n\tMOV\tDI,OFFSET $ARGLO\r\n\tMOV\tCX,4\r\n\tCLD\r\n REP\tMOVSW\r\n\tCALL\t$DINT\t\t;WILL SEE IF FAC ALREADY INTEGER\r\n\tPUSH\tBX\t\t;NEED TO CALL VCOMP WITH BX=ARG-1\r\n\tMOV\tBX,OFFSET $ARG-1\r\n\tCALL\t$VCOMP\t\t;DO COMPARE\r\n\tPOP\tBX\t\t;GET BUFFER POINTER BACK\r\n\tMOV\tSI,OFFSET $ARGLO\t;WILL MOVIE ARG TO FAC\r\n\tMOV\tDI,OFFSET $DFACL\r\n\tMOV\tCX,4\r\n\tCLD\r\n REP\tMOVSW\r\n\tJZ\tFCV05\t\t;DON'T ADD .5 IF NO DIFF.\r\n\tCALL\t$DADDH\t\t;ADD .5 TO NUMBER\r\nFCV05:\tMOV\tCL,BYTE PTR $FAC\t;SHIFT COUNT IN (CL)\r\n\tSUB\tCL,LOW 270\r\n\tNEG\tCL\t\t;MAKE SHIFT COUNT POSITIVE\r\n\tCLC\t\t\t;TO TELL DINT NOT TO NORMALIZE\r\n\tCALL\t$FTDNT\t\t;MAKE SURE ITS STILL INTEGER\r\n\tPOP\tBX\t\t;RECALL BUFFER PTR.\r\n\tPOP\tCX\t\t;RECALL DIGIT AND COMMA COUNT\r\n\tMOV\tSI,OFFSET $FODTB\t;DOUBLE PRECISION OUTPUT INTEGERS\r\n\tMOV\tAL,LOW 9D\t;9 DIGITS TO BE CONVERTED WITH D.P.\r\nFCV10:\tCALL\t$FOTED\t\t;SEE IF DECIMAL POINT NEEDED\r\n\tPUSH\tAX\t\t;SAVE DIGIT COUNT\r\n\tMOV\tAL,LOW OFFSET \"0\"-1     ;WILL FORM DIGIT IN (AL)\r\n\tPUSH\tAX\r\nFCV20:\tPOP\tAX\t\t;RECALL DIGIT\r\n\tINC\tAL\t\t;INCREMENT TO NEXT DIGIT\r\n\tPUSH\tAX\t\t;SAVE DIGIT\r\n\tCALL\tDSUBI\t\t;SUBTRACT POWER OF TEN\r\n\tJNB\tFCV20\r\n\tCALL\tDADDI\t\t;ADD POWER 10 BACK IN\r\n\t\t\t\t;AND ADVANCE SI TO NEXT POWER 10\r\n\tPOP\tAX\t\t;GET DIGIT BACK\r\n\tMOV\tBYTE PTR 0[BX],AL\t;PUT IN ASCII DIGIT\r\n\tINC\tBX\t\t;POINT TO NEXT BUFFER POSITION\r\n\tPOP\tAX\t\t;GET DIGIT COUNT\r\n\tDEC\tAL\t\t;SEE IF 10 DIGITS FORMED\r\n\tJNZ\tFCV10\t\t;IF NOT CONTINUE THE ALGORITHM\r\n\tPUSH\tCX\t\t;SAVE DECIMAL POINT COUNT\r\n\tMOV\tSI,OFFSET $DFACL\t;WILL MOVE INTO FAC\r\n\tMOV\tDI,OFFSET $FACLO\r\n\tMOV\tCX,2\r\n\tCLD\r\n REP\tMOVSW\r\n\tPOP\tCX\t\t;RECALL DECIMAL POINT COUNT\r\n\tJMP\tSHORT FCV50\t;GO DO THE REST OF THE DIGITS\r\nFCV40:\r\n;**************************************************************\r\n;CODE BELOW WORKS WITH SINGLE PRECISION NUMBERS\r\n;***************************************************************\r\n\tPUSH\tBX\t\t;SAVE BUFFER PTR\r\n\tPUSH\tCX\t\t;SAVE DIGIT AND COMMA COUNTS\r\n\tCALL\t$PUSHF\t\t;SAVE $FAC ON STACK\r\n\tCALL\t$INT\t\t;WILL SEE IF INTEGER CURRENTLY\r\n\tPOP\tDX\t\t;RECALL FAC\r\n\tPOP\tBX\r\n\tCALL\t$FCOMP\t\t;COMPARE IF EQUAL DON'T ADD .5\r\n\tJZ\tFCV45\r\n\tMOV\tWORD PTR $FAC-1,BX\t;MOVE BACK TO FAC\r\n\tMOV\tWORD PTR $FACLO,DX\r\n\tCALL\t$FADDH\t\t;ADD .5 TO NUMBER\r\nFCV45:\tMOV\tAL,LOW 1\t;FLAG TO QINT WE HAVE A POS. NO.\r\n\tCALL\t$QINT\t\t;GET INTEGER INTO (BLDX)\r\n\tMOV\tWORD PTR $FAC-1,BX\r\n\tMOV\tWORD PTR $FACLO,DX\t;MOVE TO FAC\r\n\tPOP\tCX\t\t;RECALL DIGIT AND COMMA COUNTS\r\n\tPOP\tBX\t\t;RECALL BUFFER PTR\r\n\r\n\r\nFCV50:\r\n\tMOV\tAL,LOW 3\t;WILL CONVERT 3 DIGITS IN THIS CODE\r\n\tMOV\tDX,OFFSET $FOSTB\t;Print S.P. numbers with 7 digits\r\nFCV60:\tCALL\t$FOTED\t\t;SEE IF NEED A DECIMAL POINT OR COMMA\r\n\tPUSH\tAX\t\t;SAVE DIGIT COUNT\r\n\tPUSH\tBX\t\t;SAVE BUFFER POINTER\r\n\tPUSH\tDX\t\t;SAVE POWER OF TEN POINTER\r\n\tCALL\t$MOVRF\t\t;FETCH INTEGER\r\n\tPOP\tBP\t\t;FETCH POWER TEN POINTER\r\n\tMOV\tAL,LOW OFFSET \"0\"-1     ;WILL BUILD DIGIT IN (AL)\r\n\tPUSH\tAX\t\t;SAVE DIGIT\r\nFCV70:\tPOP\tAX\t\t;RECALL DIGIT\r\n\tINC\tAL\t\t;GO TO NEXT DIGIT\r\n\tPUSH\tAX\r\n\tCALL\t$RSUBM\t\t;SUBTRACT NO. POINTED TO BY (BP)\r\n\t\t\t\t;FROM (BLDX)\r\n\tJNB\tFCV70\t\t;CONTINUE UNTIL CF=1\r\n\t\t\t\t;POWER TEN TABLE IN CODE SEGMENT\r\n\tADD\tDX,WORD PTR CS:0[BP]\t;ADD WORD PORTION\r\n\tADC\tBL,BYTE PTR CS:2[BP]\r\n\t\t\t\t;SINCE WE SUBTRACTED ONE TOO MANY\r\n\tINC\tBP\t\t;INCREMENT TO NEXT POWER OF TEN\r\n\tINC\tBP\r\n\tINC\tBP\r\n\tCALL\t$MOVFR\t\t;SAVE (BLDX) IN FAC\r\n\tPOP\tAX\t\t;RECALL DIGIT\r\n\tXCHG\tDX,BP\t\t;SAVE POWER TEN PTR. IN DX\r\n\tPOP\tBX\t\t;RECALL BUFFER POINTER\r\n\tMOV\tBYTE PTR 0[BX],AL\t;SEND OUT DIGIT\r\n\tINC\tBX\t\t;INCREMENT TO NEXT BUFFER POSITION\r\n\tPOP\tAX\t\t;RECALL DIGIT COUNT\r\n\tDEC\tAL\t\t;SEE IF FINISHED\r\n\tJNZ\tFCV60\t\t;IF NOT CONTINUE\r\n\tINC\tDX\t\t;NEED TO INCREMENT PAST 1ST\r\n\tINC\tDX\t\t;INTEGER SO THAT FOTCI WILL\r\n\tMOV\tBP,DX\t\t;FOTCI IS EXPECTING POINTER IN BP\r\n\tMOV\tAH,LOW 4\t;CONVERT ONLY 4 DIGITS\r\n\tJMP\t$FCI4\r\n\t\t\t\t;INTEGER ARITHMETIC\r\nDSUBI:\t\t\t\t;SUBTRACT 7 BYTE INTEGER POINTED TO BY (SI) FROM $DFACL\r\n\tPUSH\tCX\t\t;FIRST SAVE CX,SI,DI\r\n\tPUSH\tSI\r\n\tMOV\tCX,7\t\t;7 BYTES\r\n\tMOV\tDI,OFFSET $DFACL\r\n\tCLC\t\t\t;CF=0\r\n\tCLD\t\t\t;SO LODC WILL INCREMENT\r\nDSUBI1:\t\t\t;NEED NO. FROM CODE SEGMENT\r\n\tLODS\tBYTE PTR ?CSLAB ;FETCH BYTE TO AL\r\n\tSBB\tBYTE PTR 0[DI],AL\t;SUBTRACT\r\n\tINC\tDI\r\n\tLOOP\tDSUBI1\r\n\tPOP\tSI\r\n\tPOP\tCX\r\n\tRET\r\nDADDI:\t\t\t\t;ADD 7 BYTE INTEGER POINTED TO BY (SI) FROM $DFACL\r\n\tPUSH\tCX\t\t;SAVE CX,SI,DI\r\n\tMOV\tCX,7\r\n\tMOV\tDI,OFFSET $DFACL\r\n\tCLC\r\n\tCLD\t\t\t;SO LODC WILL INCREMENT SI\r\nDADDI1:\t\t\t;WANT NO. FETCHED FROM CODE SEGMENT\r\n\tLODS\tBYTE PTR ?CSLAB ;FETCH NEXT BYTE TO ADD\r\n\tADC\tBYTE PTR 0[DI],AL\t;ADD IT IN\r\n\tINC\tDI\r\n\tLOOP\tDADDI1\r\n\tPOP\tCX\r\n\tRET\r\n\r\n\tSUBTTL\t $FOTNV  BRACKET FAC SO PRINTABLE DIGITS IN INTEGER PART\r\n;****************************************************************\r\n;\r\n;       $FOTNV  THIS ROUTINE MULTIPLIES THE FAC BY APPROPRIATE\r\n;               VALUES SO THAT THE PRINTABLE DIGITS (7 FOR SINGLE\r\n;               PRECISION, 16 FOR DOUBLE PRECISION) ARE IN THE\r\n;               INTEGER PART OF THE FAC . IT RETURNS THE COMPLEMENT-\r\n;               ING EXPONENT IN (AL).\r\n;       CALLING SEQUENCE:       CALL    $FOTNV\r\n;               WITH THE FAC CONTAINING THE DESIRED VALUE TO PRINT\r\n;               REGISTERS (BX) AND (CX) WILL RETAIN THEIR VALUES\r\n;\r\n;*****************************************************************\r\n\r\n$FOTNV:\r\n\tPUSH\tBX\t\t;WON'T ALTER (BX) OR (CX)\r\n\tPUSH\tCX\r\n\tXOR\tDI,DI\t\t;INITIALIZE EXPONENT\r\n\tPUSH\tDI\t\t;SAVE EXPONENT\r\nFNV10:\tMOV\tBX,OFFSET $FOTB ;ADDRESS OF BRACKET CONTROL TABLE\r\n\tMOV\tAL,BYTE PTR $FAC\t;FETCH THE EXPONENT\r\n\t\t\t\t;MUST FETCH FROM CODE SEGMENT\r\n\tXLAT\tBYTE PTR ?CSLAB ;GET MULTIPLIER\r\n\tOR\tAL,AL\t\t;IF ZERO - DONE\r\n\tJZ\tFNV20\r\n\tPOP\tDI\t\t;RECALL EXPONENT\r\n\tCBW\t\t\t;CONVERT AL TO WORD\r\n\tSUB\tDI,AX\t\t;GET EXPONENT CORRECT\r\n\tPUSH\tDI\t\t;SAVE EXPONENT\r\n\tMOV\tDX,AX\t\t;DX:=exponent for MDPTEN.\r\n\tCALL\tMDPTEN\t\t;Multiply or divide by power of ten.\r\n\tJMP\tSHORT FNV10\t;See if need to do it again.\r\n\r\nFNV20:\tMOV\tBX,OFFSET $DP06+4\t;LOWER BOUND\r\n\tCALL\t$MOVBS\t\t;MOVE OUT TO \"DS\" AREA\r\n\tCALL\t$COMPM\t\t;ONE MORE MULT. POSSIBLE\r\n\t\t\t\t;$COMPM WILL SET CF=1 IF $DP06\r\n\t\t\t\t;IS LARGER, CF=0 FOR EQ OR GT\r\n\tJNB\tFNV30\t\t;JUMP IF NOT NEEDED\r\n\tCALL\t$MUL10\t\t;MULTIPLY BY TEN\r\n\tPOP\tDI\t\t;RECALL EXPONENT\r\n\tDEC\tDI\t\t;ACCOUNT FOR MULTIPLY BY 10.\r\n\tPUSH\tDI\r\nFNV30:\tCALL\t$GETYP\t\t;SET CONDITION CODES FOR TYPE\r\n\r\n\r\n\tJB\tFNV40\t\t;done if single precision\r\n\r\n\tMOV\tBX,OFFSET $DP09 ;MUST MULTIPLY BY 10^9\r\n\tCALL\t$MOVAC\t\t;MOVE 10^9 TO $ARG\r\n\tCALL\t$FMULD\t\t;PERFORM MULTIPLICATION\r\n\tPOP\tAX\t\t;RECALL EXPONENT\r\n\tSUB\tAL,LOW 11\t;SUBTRACT 9\r\n\tPUSH\tAX\t\t;Resave the exponent.\r\n\tMOV\tBX,OFFSET HIDBL ;Is the number too big?  (Will it\r\n\tCALL\t$MOVBF\t\t;overflow when $FOTCV adds .5 to it?)\r\n\tCALL\t$DCMPM\r\n\tJNA\tFNV40\t\t;No.\r\nFNV44:\tCALL\t$DIV10\t\t;Yes, divide by ten and fix up the\r\n\t\t\t\t;the decimal exponent.\r\n\tPOP\tAX\t\t;restore the exponent\r\n\tINC\tAL\t\t;adjust for $DIV10\r\n\tPUSH\tAX\r\nFNV40:\tPOP\tAX\t\t;recall exponent\r\nFNV50:\tPOP\tCX\t\t;restore registers\r\n\tPOP\tBX\r\n\tOR\tAL,AL\t\t;SET CONDITION CODES ACCORDING TO EXP\r\n\tRET\r\n\r\n;\r\n; The largest double precision value that .5 can be added to without\r\n; overflow occuring.\r\n;\r\n\r\nHIDBL:\tDB\t375,377,3,277,311,33,16,266\t;9999999999999999.\r\n\r\n\r\n\r\n\tSUBTTL\t $FOUT\t CONTROL OUTPUT CONVERSION\r\n;***************************************************************\r\n;\r\n;       $FOUT   THIS ROUTINE PROVIDES TOP-LEVEL CONTROL OF THE\r\n;               FREE FORMAT OUTPUT FUNCTION.\r\n;       CALLING SEQUENCE:       CALL    $FOUT\r\n;\r\n;****************************************************************\r\n\r\nS:\tMOV\tBX,OFFSET $FBUFF+1\t;FETCH BUFFER POINTER\r\n\tMOV\tBYTE PTR 0[BX],LOW \" \"  ;MOVE IN SPACE FOR POSSIBLE SIGN\r\n\tPUSH\tBX\t\t;SAVE BUFFER POINTER\r\n\tCALL\t$SIGNS\t\t;DETERMINE SIGN OF NUMBER\r\n\tPOP\tBX\t\t;RECALL BUFFER POINTER\r\n\tPUSHF\t\t\t;SAVE FLAGS FOR LATER\r\n\tJNS\tFO20\t\t;JUMP IF POSITIVE\r\n\tMOV\tBYTE PTR 0[BX],LOW \"-\"  ;PUT IN MINUS SGN\r\n\tPUSH\tBX\t\t;SAVE TEXT POINTER\r\n\tCALL\t$VNEG\t\t;NEGATE NO. SO WE WORK ONLY WITH\r\n\tPOP\tBX\t\t;RECALL TEXT POINTER\r\n\tOR\tAL,LOW 1\t;POS. NOS. AND SET ZF=0\r\nFO20:\tINC\tBX\t\t;POINT TO NEXT BUFFER POSITION\r\n\tMOV\tBYTE PTR 0[BX],LOW \"0\"  ;PUT IN ZERO IN CASE NO IS ZERO\r\n\tPOPF\t\t\t;RECALL FLAGS\r\n\tRET\r\nFOUT:\r\n$FOUT:\t\t\t\t;FREE-FORMAT ENTRY POINT\r\n\tCALL\tS\t\t;DO SIGN FIX-UP\r\n\tJNZ\t$FOUT2\t\t;IF NON-ZERO PROCEED\r\n\tINC\tBX\t\t;POINT TO NEXT OUTPUT BUFFER POS.\r\n\tMOV\tBYTE PTR 0[BX],LOW 0\t;INDICATE END OF NUMBER\r\n\tMOV\tBX,OFFSET $FBUFF+1\t;POINT (BX) TO START POSITION\r\n\tRET\r\n$FOUT2: CALL\t$GETYP\t\t;GET TYPE NO.\r\n\tJNS\tFO50\t\t;GO FORMAT SINGLE OR DOUBLE PREC.\r\n\tMOV\tCX,OFFSET 7*400 ;default 7 digits prior to dp.\r\n\tXOR\tAX,AX\t\t;CLEAR COMMA COUNT\r\n\tMOV\tWORD PTR $FMTAX,AX\r\n\tMOV\tWORD PTR $FMTCX,CX\r\n\tCALL\t$FOTCI\t\t;CONVERT INTEGER TO ASCII\r\n\tJMP\t$FOTZS\t\t;DO LEADING ZERO SUPPRESSION\r\nFO50:\tJMP\t$FOFMT\t\t;SINGLE OR DOUBLE PREC. OUTPUT\r\n\r\n\tSUBTTL\t $INT\t CONVERT PRESENT NO. TO INTEGER BY TRUNCATION\r\n;***********************************************************\r\n;\r\n;       $INT    SINGLE PRECISION INT ROUTINE\r\n;       $DINT   DOUBLE PRECISION INT ROUTINE\r\n;       $QINT   CONVERT TO INT AND LEAVE IN (BLDX)\r\n;       $FTDNT  FOUT ENTRY TO CONVERT TO INT AND LEAVE RT.ADJUSTED\r\n;       $SHRD   SHIFT DOUBLE PRECISION MANTISSA RIGHT\r\n;\r\n;**********************************************************\r\n;**********************************************************\r\n;THE INT TECHNIQUE IS PRETTY STRAIGHT FORWARD EXCEPT\r\n;FOR NEGATIVE NON-INTEGERS. THE RUB WITH THESE NOS. IS THAT\r\n;IF THEY HAVE ANY FRACTIONAL BITS THE ANSWER IS TO\r\n;BE THE NEXT LOWER VALUE INTEGER. FOR EXAMPLE : INT(-1.1) SHOULD\r\n;RETURN -2 WHEREAS INT(1.1) SHOULD RETURN 1. THE TRICK USED TO\r\n;EFFECT THIS IS TO SUBTRACT 1 FROM NEGATIVE NON-INTEGER MANTISSAS\r\n;PRIOR TO SHIFTING OUT FRACTIONAL BITS THEN ADD 1 BACK TO THE\r\n;MANTISSA ONCE FRACTIONAL BITS HAVE BEEN SHIFTED OUT. WITH THE\r\n;FOLLOWING EXAMPLE (IN BINARY) WATCH HOW THIS TECHNIQUE WORKS:\r\n;FIND INT(10011.011)\r\n;       (1)     SINCE THIS IS A POSITIVE NO WE JUST SHIFT OUT\r\n;               THE FRACTIONAL BITS AND NORMALIZE\r\n;FIND INT(-10011.011)\r\n;       (1)     SUBTRACT ONE FROM THE MANTISSA YIELDING -10011.010\r\n;       (2)     SHIFT OUT THE FRACTIONAL BITS YIELDING -10011.\r\n;       (3)     ADD 1 TO MANTISSA YIELDING -10100 THE CORRECT VALUE\r\n;FIND INT(-10011.000)\r\n;       (1)     SUBTRACT ONE FROM MANTISSA YIELDING -10010.111\r\n;       (2)     SHIFT OUT THE FRACTIONAL BITS YIELDING -10010.\r\n;       (3)     ADD 1 TO MANTISSA YIELDING -10011. THE CORRECT VALUE\r\n;******************************************************************\r\n$DINT:\t\t\t\t;DOUBLE PRECISION INT FUNCTION\r\n\tMOV\tCL,BYTE PTR $FAC\t;CL:=exponent.\r\n\tSUB\tCL,LOW 270\t;Is there a fractional part?\r\n\tJNB\tDNT20\t\t;RETURN IF NO FRACTIONAL BITS\r\n\tNEG\tCL\t\t;CL NOW POSITIVE\r\n$FTDNT: PUSHF\t\t\t;FOUT ENTRY POINT. THIS IS SEPARATE\r\n\t\t\t\t;ENTRY POINT BECAUSE FOUT WISHES\r\n\t\t\t\t;TO HAVE INTEGER RIGHT ADJUSTED\r\n\t\t\t\t;IN THE MANTISSA BITS. WE WILL DO\r\n\t\t\t\t;THE NECESSARY SHIFTS AND RETURN\r\n\t\t\t\t;PRIOR TO NORMALIZATION IF CALLED\r\n\t\t\t\t;BY FOUT (SIGNIFIED BY CF=0)\r\n\tTEST\tBYTE PTR $FAC,LOW 377O\t;Is the exponent zero?\r\n\tJNE\tDINTNZ\t\t;No, proceed.\r\n\tPOPF\t\t\t;Yes, if the exponent is zero the\r\n\tRET\t\t\t;number is zero.  Don't operate on\r\n\t\t\t\t;the possible garbage in the mantissa.\r\nDINTNZ: MOV\tBX,OFFSET $FAC-2\r\n\tMOV\tAL,BYTE PTR 1[BX]\t;FETCH SIGN BYTE\r\n\tMOV\tBYTE PTR 3[BX],AL\t;AND PUT IN $FAC+1  FOR $NORMD\r\n\tOR\tAL,AL\t\t;SEE IF NEGATIVE\r\n\tPUSHF\r\n\tOR\tAL,LOW 200\t;RESTORE HIDDEN 1\r\n\tMOV\tBYTE PTR 1[BX],AL\t;AND REPLACE\r\n\tMOV\tBYTE PTR 2[BX],LOW 270\t;SET EXPONENT FOR POST SHIFT VALUE\r\n\tPOPF\t\t\t;RECALL SF\r\n\tPUSHF\r\n\tJNS\tDNT10\t\t;IF POSITIVE PROCEED\r\n;*****************************************************************\r\n;NEGATIVE NO. MUST DO THE FANCY FOOTWORK DESCRIBED ABOVE\r\n;*****************************************************************\r\n\tCALL\tDINTA\t\t;SUBTRACT 1 FROM MANTISSA BITS\r\nDNT10:\tXOR\tCH,CH\t\t;(CX)=SHIFT COUNT\r\n\tCALL\t$SHRD\t\t;DOUBLE PRECISION SHIFT RIGHT\r\n\tPOPF\t\t\t;RECALL SF\r\n\tJNS\tDNT15\t\t;IF POSITIVE PROCEED\r\n\tCALL\tADD1D\t\t;ADD 1 TO MANTISSA BITS\r\nDNT15:\tMOV\tBYTE PTR $DFACL-1,LOW 0 ;ZERO THE OVERFLOW BYTE\r\n\tPOPF\t\t\t;SEE IF CALLED BY FOUT (CF=0)\r\n\tJNB\tDNT20\t\t;IF SO JUST RETURN\r\n\tJMP\t$NORMD\t\t;OTHERWISE NORMALIZE\r\nDNT20:\tRET\r\n\r\n$SHRD:\t\t\t\t;SHIFT RIGHT DOUBLE PRECISION\r\n\r\nSHRD10: PUSH\tCX\t\t;SAVE OUTER LOOP VARIABLE (BITS TO\r\n\t\t\t\t;BE SHIFTED RIGHT)\r\n\tPUSH\tBX\t\t;SAVE POINTER TO HIGH BYTE TO SHIFT\r\n\tCLC\t\t\t;CF=0\r\n\tCALL\t$SHDR\t\t;SHIFT 1 BIT RIGHT\r\n\tPOP\tBX\r\n\tPOP\tCX\t\t;GET OUTER LOOP VARIABLE\r\n\tLOOP\tSHRD10\r\n\tRET\r\n\r\nDINTA:\tPUSH\tBX\r\n\tMOV\tBX,OFFSET $DFACL\t;BEGINNING ADDRESS FOR SUBTRACT\r\nDINA10: SUB\tWORD PTR 0[BX],1\t;NEED CF SO CAN'T USE DEC\r\n\tJNB\tDINA20\r\n\tINC\tBX\r\n\tINC\tBX\t\t;CAN DO WORD SUBTRACTS SINCE HIGH BIT\r\n\t\t\t\t;OF MANTISSA IS SET (THUS PROTECTING\r\n\t\t\t\t;THE EXPONENT FROM THE SUBTRACT)\r\n\tJMP\tSHORT DINA10\r\nDINA20: POP\tBX\r\n\tRET\r\n\r\nADD1D:\t\t\t\t;ADD 1 TO DOUBLE PRECISION MANTISSA BITS\r\n\tPUSH\tBX\t\t;\r\n\tMOV\tBX,OFFSET $DFACL\r\nADD10:\tINC\tBYTE PTR 0[BX]\r\n\tJNZ\tADD20\r\n\tINC\tBX\t\t;POINT TO NEXT BYTE THERE WAS A CARRY\r\n\tJMP\tSHORT ADD10\r\nADD20:\tPOP\tBX\r\n\tRET\r\n\r\nINT:\r\n$INT:\t\t\t\t;SINGLE PRECISION INT FUNCTION\r\n\tMOV\tCL,BYTE PTR $FAC\t;FETCH EXPONENT\r\n\tSUB\tCL,LOW 230\t;CALCULATE SHIFT COUNT\r\n\tJNB\tINT20\t\t;ALREADY INTEGER PROCEED\r\n\tNEG\tCL\t\t;GET POSITIVE SHIFT COUNT\r\n;\r\n; Note - At this point the carry is set.  This will be used\r\n; to indicate that this is not a QINT call.  Also note that\r\n; if the exponent is zero the above subtraction did set the\r\n; carry so the check for the zero exponent case below is\r\n; guaranteed to be executed.\r\n;\r\nQINTX:\t\t\t\t; $QINTX'S ENTRY POINT\r\n\tMOV\tDX,WORD PTR $FACLO\t;FETCH LOW MANTISSA BITS\r\n\tMOV\tBX,WORD PTR $FAC-1\t;FETCH EXP,SIGN,HIGH MANTISSA BITS\r\n\tINC\tBH\t\t;Is the exponent zero?  (Test for zero\r\n\tDEC\tBH\t\t;without affecting the carry.)\r\n\tJNE\tQINTNZ\t\t;No, proceed.\r\n\tXOR\tBL,BL\t\t;Yes, put zero into BL,DX for QINT\r\n\tXOR\tDX,DX\t\t;rather than work with the possible\r\n\tRET\t\t\t;garbage in the mantissa (an exponent\r\n\t\t\t\t;of zero means the number is zero).\r\nQINTNZ: PUSHF\t\t\t;Save carry which if clear indicates\r\n\t\t\t\t;this is a QINT call.\r\n\tOR\tBL,BL\t\t;SEE IF NEGATIVE\r\n\tPUSHF\t\t\t;SAVE\r\n\tMOV\tBYTE PTR $FAC+1,BL\t;SAVE SIGN FOR NORMS\r\n\tMOV\tBYTE PTR $FAC,LOW 230\t;SET EXP FOR POST SHIFT\r\n\tOR\tBL,LOW 200\t;RESTORE HIDDEN 1\r\n\tPOPF\r\n\tPUSHF\t\t\t;SAVE SIGN\r\n\tJNS\tINT10\t\t;\r\n\tSUB\tDX,1\t\t;CAN'T DO A 'DEC' BECAUSE NEED CF\r\n\tSBB\tBL,LOW 0\t;DO APPROPRIATE SUBTRACT TO HIGH BYTE\r\nINT10:\tXOR\tCH,CH\t\t;CX HAS LOOP COUNT\r\n\tOR\tCL,CL\t\t;IF SHIFT COUNT ZERO MUST JUMP OVER\r\n\tJZ\tINT12\t\t;RIGHT SHIFTS\r\nINT11:\tSHR\tBL,1\t\t;SHIFT RIGHT INTO CF\r\n\tRCR\tDX,1\t\t;ROTATE RIGHT\r\n\tLOOP\tINT11\t\t;WILL DO (CX) RIGHT SHIFTS\r\nINT12:\tPOPF\t\t\t;RECALL SIGN OF NO.\r\n\tLAHF\t\t\t;STORE FLAGS TEMPORARILY\r\n\tJNS\tINT15\t\t;PROCEED IF POSITIVE\r\n\tINC\tDX\r\n\tJNZ\tINT15\r\n\tINC\tBL\r\nINT15:\r\n\tPOPF\t\t\t;CF=0 IF CALLED BY QINT\r\n\tJNB\tINT20\t\t;JUST RETURN IF QINT CALL\r\n\tXOR\tAH,AH\t\t;CLEAR OVERFLOW BYTE\r\n\tJMP\t$NORMS\t\t;NORMALIZE AND RETURN\r\nINT20:\tSAHF\t\t\t;MUST SEE IF NEGATIVE\r\nNGBLDX: JNS\tINT30\t\t;IF NOT PROCEED AS NORMAL\r\n\tNOT\tDX\t\t;COMPLEMENT DX\r\n\tNOT\tBL\t\t;AND BL\r\n\tADD\tDX,1\t\t;NEED CF SET IF DX OVERFLOWS\r\n\tADC\tBL,LOW 0\t;2's COMPLEMENT NOW FORMED\r\nINT30:\tRET\r\nQINT:\r\n$QINT:\t\t\t\t;DO INT(FAC) AND LEAVE IN (BLDX)\r\n\tMOV\tCL,LOW 230\r\n\tSUB\tCL,BYTE PTR $FAC\t;GET SHIFT COUNT TO CL\r\n\tCLC\t\t\t;CF=0\r\n\tJMP\tSHORT QINTX\t;LEAVE RIGHT ADJUSTED\r\n\r\n\tSUBTTL\t $LOG\t SINGLE PRECISION NATURAL LOG FUNCTION\r\n;**********************************************************\r\n;\r\n;       $LOG    COMPUTE THE NATURAL LOG OF THE VALUE IN THE FAC\r\n;       CALLING SEQUENCE:       CALL    $LOG\r\n;               WITH INPUT ARGUMENT IN THE FAC\r\n;       MLLN2   IF THIS ENTRY POINT IS USED THE FAC WILL BE\r\n;               MULTIPLIED BY LN(2)\r\n;\r\n;************************************************************\r\n\r\nLOG:\r\n$LOG:\tCALL\t$SIGNS\t\t;ERROR IF ($FAC).LE..0\r\n\tJLE\tLG100\r\n;****************************************************************\r\n;       WILL NOW PERFORM SPECIAL TEST FOR ARGUMENT OF 1.0 AND IF\r\n;       FOUND EQUAL ANSWER IS 0\r\n;*****************************************************************\r\n\tMOV\tDX,0\t\t;FETCH 1.0 TO (BXDX)\r\n\tMOV\tBX,100400\r\n\tCALL\t$FCOMP\r\n\tJNZ\tLOG10\t\t;PROCEED IF NOT 1.0\r\n\tMOV\tWORD PTR $FACLO,DX\t;WILL ZERO $FAC AND RETURN\r\n\tMOV\tWORD PTR $FACM1,DX\r\n\tRET\r\nLOG10:\r\n\tMOV\tAL,BYTE PTR $FAC\t;FETCH EXPONENT\r\n\tSUB\tAL,LOW 200\t;TAKE OUT BIAS\r\n\tCBW\t\t\t;CONVERT BYTE TO WORD\r\n\tPUSH\tAX\t\t;AND SAVE\r\n\tMOV\tBYTE PTR $FAC,LOW 200\t;ZERO THE EXPONENT\r\n\tCALL\t$PUSHF\t\t;SAVE ARG FOR Q(X) CALCULATION\r\n\tMOV\tBX,OFFSET $LOGP ;NOW TO USE HART APPROX FOR P(X)\r\n\tCALL\t$POLY\r\n\tPOP\tDX\t\t;GET X OFF THE STACK\r\n\tPOP\tBX\r\n\tCALL\t$PUSHF\t\t;SAVE P(X)\r\n\tCALL\t$MOVFR\t\t;MOVE X TO FAC\r\n\tMOV\tBX,OFFSET $LOGQ\r\n\tCALL\t$POLY\t\t;CALCULATE Q(X)\r\n\tPOP\tDX\t\t;RECALL P(X)\r\n\tPOP\tBX\r\n\tCALL\t$FDIVS\t\t;CALCULATE P(X)/Q(X)\r\n\tPOP\tDX\t\t;FETCH RAW EXPONENT\r\n\tCALL\t$PUSHF\t\t;SAVE FAC ON THE STACK\r\n\tCALL\t$FLT\t\t;FLOAT THE VALUE INTO THE $FAC\r\n\tPOP\tDX\t\t;RECALL LOG2 VALUE\r\n\tPOP\tBX\r\n\tCALL\t$FADDS\t\t;ADD\r\nMLLN2:\tMOV\tBX,100061\t;FETCH LN(2) TO (BXDX)\r\n\tMOV\tDX,71030\r\n\tJMP\t$FMULS\t\t;MULTIPLY TO COMPLETE\r\nLG100:\tJMP\t$FCERR\r\n\r\n\tSUBTTL\t $NORMD  DOUBLE PRECISION NORMALIZATION ROUTINE\r\n;******************************************************************\r\n;\r\n;       $NORMD  NORMALIZES THE NUMBER IN $FAC+1 THRU $DFACL-1\r\n;               AND JUMPS TO $ROUND\r\n;       CALLING SEQUENCE:       CALL    $NORMD\r\n;               OR              JMP     $NORMD\r\n;               WILL RESULT IN NORMALIZATION FOLLOWED BY ROUNDING\r\n;               AND PACKING THE $FAC.\r\n;\r\n;*******************************************************************\r\n\r\n$NORMD: MOV\tDL,LOW 71\t;MAX BITS TO SHIFT LEFT\r\n\tMOV\tBX,OFFSET $DFACL-1\r\nNORD5:\tMOV\tDI,OFFSET $FAC-1\r\n\tMOV\tSI,OFFSET $FAC\r\n\tJMP\tSHORT NORD30\r\nNORD10:\r\n\tMOV\tCX,4\r\n\tCLC\t\t\t;CF=0\r\nNORD20: RCL\tWORD PTR 0[BX],1\r\n\tINC\tBX\r\n\tINC\tBX\t\t;POINT TO NEXT WORD\r\n\tLOOP\tNORD20\r\n\tMOV\tBX,OFFSET $DFACL-1\t;POINT BACK TO END OF NUMBER\r\nNORD25:\r\n\tDEC\tBYTE PTR 0[SI]\t;DECREMENT EXPONENT\r\n\tJZ\tNORD40\t\t;DO CLEAN-UP IF UNDERFLOW\r\n\tDEC\tDL\t\t;SEE IF MAX BITS SHIFTED\r\n\tJZ\tNORD40\t\t;IF SO TERMINATE SHIFTS\r\nNORD30: TEST\tBYTE PTR 0[DI],LOW 377\t;SF=1 IF NOW NORMALIZED\r\n\tJS\tNORD40\t\t;NORMALIZED\r\n\r\n\tJNZ\tNORD10\t\t;MUST SHIFT BIT AT A TIME\r\n;***************************************************************\r\n;CAN DO AT 1 BYTE MOVE LEFT\r\n;***************************************************************\r\n\tSUB\tBYTE PTR 0[SI],LOW 10\t;SUBTRACT 8\r\n\tJBE\tNORD40\t\t;UNDERFLOW\r\n\tSUB\tDL,LOW 10\t;SEE IF MAX BITS SHIFTED\r\n\tJBE\tNORD40\t\t;AND IF SO QUIT\r\n\tMOV\tSI,OFFSET $FAC-2\r\n\tMOV\tCX,7\t\t;7 BYTES TO MOVE\r\n\tSTD\t\t\t;SO FOLLOWING MOVB WILL DECREMENT\r\n\t\t     ;REPEAT CX TIMES (THE MOVB)\r\n REP\tMOVSB\t\t\t;MOVE\r\n\tMOV\tBYTE PTR $DFACL-1,LOW 0 ;ZERO OVERFLOW\r\n\tJMP\tSHORT NORD5\t;SEE IF MORE CASES\r\nNORD40: JBE\tNORD50\t\t;UNDERFLOW JUMP\r\n\tJMP\t$ROUND\r\nNORD50:\r\n\tJMP\t$DZERO\r\n\r\n\tSUBTTL\t $NORMS  SINGLE PRECISION NORMALIZATION ROUTINE\r\n;************************************************************\r\n;\r\n;       $NORMS  SINGLE PRECISION NORMALIZATION ROUTINE\r\n;               $NORMS SHIFTS (BLDXAH) LEFT UNTIL THE SIGN\r\n;               BIT OF (BL)IS 1. FOR EACH LEFT SHIFT\r\n;               $NORMS WILL DECREMENT THE FAC\r\n;               ONCE THIS PROCESS IS COMPLETE, $NORMS WILL\r\n;               JUMP TO $ROUNS TO ROUND THE NUMBER AND\r\n;               PACK IT INTO THE FAC BYTES.\r\n;\r\n;*************************************************************\r\n\r\n$NORMS:\r\n\tMOV\tBH,BYTE PTR $FAC\t;EXPONENT TO BH\r\n\tMOV\tCX,4\r\nNOR10:\tOR\tBL,BL\t\t;SEE IF SIGN BIT SET\r\n\tJS\tNOR20\t\t;IF SO NORMALIZATION COMPLETE\r\n\tJNZ\tNOR15\t\t;UPPER BYTE NON-ZERO\r\n\tSUB\tBH,LOW 10\t;CAN WE SUBTRACT 8 W/O UNDERFLOW?\r\n\tJBE\tNOR17\r\n\tMOV\tBL,DH\r\n\tMOV\tDH,DL\r\n\tMOV\tDL,AH\r\n\tXOR\tAH,AH\t\t;CLEAR OVERFLOW BYTE\r\n\tLOOP\tNOR10\r\n\tJZ\tNOR17\t\t;UNDERFLOW!\r\nNOR15:\r\n\tCLC\t\t\t;CLEAR CARRY FLAG [CF]\r\n\tRCL\tAH,1\t\t;SHIFT OVERFLOW BYTE LEFT.\r\n\tRCL\tDX,1\t\t;SHIFT LOWER MANTISSA WORD LEFT\r\n\tRCL\tBL,1\t\t;SHIFT HIGH MANTISSA BYTE LEFT\r\nNOR16:\tDEC\tBH\t\t;DECREMENT EXPONENT\r\n\tJNZ\tNOR10\t\t;CONTINUE UNLESS UNDERFLOW\r\nNOR17:\tJMP\t$ZERO\t\t;ZERO THE FAC AND RETURN\r\nNOR20:\tMOV\tBYTE PTR $FAC,BH\t;UPDATE EXPONENT\r\n\tJMP\t$ROUNS\r\n\r\n\tSUBTTL $POLY\t SINGLE PRECISION POLYNOMIAL EVALUATOR\r\n;*********************************************************\r\n;\r\n;       $POLY   EVALUATES THE POLYNOMIAL:\r\n;                       P(X)=C0+C1X+C2X2+...+CNXN\r\n;               THE EVALUATION IS ACCOMPLISHED VIA HORNER'S\r\n;               RULE (SEE \"THE ART OF COMPUTER PROGRAMMING\"\r\n;               VOL.2 PP423, BY KNUTH)\r\n;       $POLYX  PERFORMS THE EVALUATION X(P(X**2)) ON THE\r\n;               POLYNOMIAL MENTIONED ABOVE\r\n;       CALLING SEQUENCE:       CALL $POLY\r\n;               OR              CALL    $POLYX\r\n;               WITH X STORED IN THE $FAC AND (BX)\r\n;               POINTING TO THE FOLLOWING:\r\n;                                       N+1\r\n;                                       CN\r\n;                                       CN-1\r\n;                                       .\r\n;                                       .\r\n;                                       .\r\n;                                       C0\r\n;\r\n;***********************************************************\r\n\r\n$POLYX:\r\n\tMOV\tDX,WORD PTR $FACLO\t;FETCH LOW BYTES\r\n\tMOV\tBP,WORD PTR $FACM1\t;AND HIGH BYTES\r\n\tPUSH\tDX\t\t;SAVE X ON THE STACK\r\n\tPUSH\tBP\t\t;\r\n\tPUSH\tBX\t\t;SAVE COEFFICIENT POINTER\r\n\tMOV\tBX,BP\t\t;(BXDX)=X\r\n\tCALL\t$FMULS\t\t;FORM X**2\r\n\tPOP\tBX\t\t;RECALL COEFFICIENT POINTER\r\n\tCALL\t$POLY\t\t;FORM P(X**2)\r\n\tPOP\tBX\t\t;FETCH X TO REGISTERS\r\n\tPOP\tDX\r\n\tJMP\t$FMULS\r\n\r\n$POLY:\tCLD\t\t\t;9-Aug-82/MLC - Good for LODC, MOVW,\r\n\t\t\t\t;and MOVW down to POL10.\r\n\tMOV\tSI,BX\t\t;SO WE CAN USE STRING MOVES\r\n\t\t\t\t;MUST FETCH FROM THE CODE SEG\r\n\tLODS\tBYTE PTR ?CSLAB ;FETCH NUMBER OF COEFFICIENTS\r\n\tCBW\t\t\t;(AH)=0\r\n\tPUSH\tAX\t\t;PUSH NUMBER ELEMENTS ON STACK\r\n\tPUSH\tWORD PTR $FACM1 ;SAVE THE FAC ON THE STACK\r\n\tPUSH\tWORD PTR $FACLO\r\n\tMOV\tDI,OFFSET $FACLO\r\n\t\t\t\t;WANT TO FETCH COEFF FROM\r\n\tMOVS\t?CSLAB,WORD PTR ?CSLAB\r\n\t\t\t\t;FETCH FROM CODE SEGMENT\r\n\tMOVS\t?CSLAB,WORD PTR ?CSLAB\r\nPOL10:\r\n\tPOP\tDX\t\t;FETCH LOW X\r\n\tPOP\tBX\t\t;FETCH HIGH X\r\n\tPOP\tAX\t\t;RECALL COEFFICIENT COUNTER\r\n\tDEC\tAX\t\t;DECREMENT\r\n\tJZ\tPOL30\t\t;JUMP WHEN COMPLETE\r\n\tPUSH\tAX\t\t;SAVE COUNTER\r\n\tPUSH\tBX\t\t;SAVE X ON THE STACK\r\n\tPUSH\tDX\r\n\tPUSH\tSI\t\t;SAVE POINTER TO COEFFICIENTS\r\n\tCALL\t$FMULS\t\t;MULTIPLY BY X\r\n\tPOP\tSI\t\t;FETCH COEFFICIENT POINTER\r\n\tCLD\t\t\t;9-Aug-82/MLC - Good for next two\r\n\t\t\t\t;LODWs.\r\n\t\t\t\t;MUST FETCH FROM CODE SEGMENT\r\n\tLODS\tWORD PTR ?CSLAB ;FETCH LOW WORD\r\n\tXCHG\tAX,DX\r\n\t\t\t\t;MUST FETCH FROM CODE SEGMENT\r\n\tLODS\tWORD PTR ?CSLAB ;FETCH HIGH WORD\r\n\tXCHG\tAX,BX\r\n\tPUSH\tSI\t\t;SAVE COEFFICIENT POINTER\r\n\tCALL\t$FADDS\t\t;ADD IT IN\r\n\tPOP\tSI\t\t;GET POINTER BACK\r\n\tJMP\tSHORT POL10\r\nPOL30:\t\t\t\t;CLEAR THE STACK\r\n\tRET\r\n\r\n\tSUBTTL\t $PUF\t PRINT-USING FOR FLOATING POINT NUMBERS\r\n;**************************************************************\r\n;\r\n;       $PUF    THIS ROUTINE ACCEPTS EITHER SINGLE OR DOUBLE\r\n;               PRECISION FLOATING VALUES AND FORMATS THEM\r\n;               ACCORDING TO INPUT FORMATS. BOTH FIXED AND\r\n;               \"E\" TYPE FORMATS ARE PRODUCED BY THIS CODE\r\n;       CALLING SEQUENCE:       CALL    $PUF\r\n;               WITH FLOATING POINT VALUE IN THE FAC, (BX) POINTING\r\n;               TO THE NEXT PRINT POSITION IN THE OUTPUT BUFFER\r\n;               AND FORMAT SPECIFICATIONS IN AX, AND CX.\r\n;               $FMTAX LOADED INTO (AX) WILL CONTAIN COMMA COUNT\r\n;               IN (AH) AND THE FOLLOWING FORMAT IN (AL):\r\n;               BIT     7       =0 FREE FORMAT OUTPUT, NUMBER DICTATES\r\n;                               OUTPUT FORMAT\r\n;                               =1 PRINT USING OUTPUT. THE REMAINDER OF\r\n;                               (AL) AND (CX) DICTATE HOW THE NUMBER IS\r\n;                               TO BE PRINTED\r\n;                       6       IF =1 GROUP THE DIGITS IN THE INTEGER\r\n;                               PART IN GROUPS OF THREE AND SEPARATE\r\n;                               WITH COMMAS.\r\n;                       5       IF =1 FILL THE LEADING SPACES IN THE\r\n;                               FIELD WITH ASTERISKS \"*\"\r\n;                       4       IF =1 OUTPUT THE NUMBER WITH A FLOATING\r\n;                               DOLLAR SIGN \"$\"\r\n;                       3       IF =1 PRINT THE SIGN OF THE NUMBER WITH\r\n;                               A PLUS \"+\" IF POSITIVE INSTEAD OF A SPC\r\n;                       2       IF =1 PRINT THE SIGN AFTER THE NUMBER\r\n;                       1       UNUSED\r\n;                       0       IF =1 PRINT THE NUMBER IN SCIENTIFIC\r\n;                               NOTATION AND IGNORE BIT 6.\r\n;                               IF =0 USE FIXED POINT NOTATION.\r\n;               $FMTCX WILL HAVE THE FOLLOWING FORMAT LOADED IN (CX)\r\n;               (CH)    NUMBER PLACES IN FIELD TO LEFT OF DECIMAL POINT\r\n;                       (DOES NOT INCLUDE THE DECIMAL POINT)\r\n;               (CL)    NUMBER PLACES IN THE FIELD TO THE RIGHT OF THE\r\n;                       DECIMAL POINT (INCLUDES DECIMAL POINT)\r\n;\r\n;****************************************************************\r\n\r\n$PUF:\r\n\tPUSH\tBX\t\t;SAVE OUTPUT BUFFER POINTER\r\n\tSHR\tAL,1\t\t;CF=1 IF \"E\" FORMAT DESIRED\r\n\tJNB\tPUF10\t\t;IF FIXED PROCEED\r\n\tJMP\t$PUFE\t\t;GO DO IT\r\nPUF10:\r\n;******************************************************************\r\n;KNOW THAT A FIXED FORMAT IS DESIRED. THE FOLLOWING ANALYSIS WILL\r\n;BE PERFORMED:  (1) SEE IF NO. IS .GE. 10^16 , AND IF SO\r\n;GO PRINT WITH $FOUT AND INSERT A LEADING \"%\". (2) BRACKET THE\r\n;PRINTABLE DIGITS IN THE INTEGER PART OF THE NUMBER WITH $FOTNV\r\n;(3) SEE IF LEADING ZEROS ARE REQUIRED(THE POSITIONS SPECIFIED\r\n;TO THE LEFT OF THE DECIMAL POINT ARE MORE THAN THE AVAILABLE\r\n;DIGITS TO LEFT OF DECIMAL POINT). (4) SEE IF THE SUM OF THE DIGITS\r\n;ON THE LEFT PLUS THOSE ON THE RIGHT ARE LESS THAN THE AVAILABLE\r\n;DIGITS,I.E. WE HAVE MORE PRINTABLE DIGITS THAN REQUIRED. IF THIS\r\n;IS THE CASE WE MUST SHIFT THE NUMBER RIGHT SO THAT WE CAN ROUND IT\r\n;AT THE CORRECT POSITION. (5) PUT IN THE PRINTABLE DIGITS. (6) SEE\r\n;IF TRAILING ZEROS ARE REQUIRED(SPECIFIED DIGITS TO THE RIGHT\r\n;WERE IN EXCESS OF DIGITS AVAILABLE)\r\n;********************************************************************\r\n\tMOV\tBX,OFFSET $DP16 ;WILL FIRST SEE IF NO. TOO LARGE\r\n\tCALL\t$MOVBF\t\t;NO. MOVED TO DBUFF FOR COMPARISON\r\n\t\t\t\t;(IT WAS PREVIOUSLY IN CODE SEGMENT)\r\n\tCALL\t$VCOMP\t\t;(FAC)-10^16(CF=1 IF OK)\r\n\tJB\tPUF30\t\t;JUMP IF SMALL ENOUGH TO PROCESS\r\n;******************************************************************\r\n;NO. WAS TOO LARGE TO PRINT WITH FIXED FORMAT. MUST PRINT IN FREE-\r\n;FORMAT WITH $FOUT AND INSERT A LEADING \"%\" TO INDICATE IT OVERFLOWED\r\n;THE SPECIFIED PRINT FIELD\r\n;*******************************************************************\r\n\tPOP\tBX\t\t;RECALL PRINT BUFFER POINTER\r\n\tCALL\t$FOUT\t\t;PRINT IN FREE-FORMAT\r\n\tDEC\tBX\t\t;POINT TO POSITION 1\r\n\tMOV\tBYTE PTR 0[BX],LOW \"%\"  ;PUT IN OVERFLOW INDICATOR\r\n\tRET\t\t\t;DONE\r\nPUF30:\r\n;********************************************************************\r\n;ALL WE KNOW AT THIS POINT IS THAT IT IS POSSIBLE TO PRINT THE\r\n;NUMBER WITH A FIXED FORMAT, DO NOT KNOW THE SPECIFIED FIXED FORMAT\r\n;IS SUFFICIENT. WHAT WE WILL DO IS FORMAT THE NUMBER IN FIXED FORMAT\r\n;AND THEN JUMP TO $PUFXE AND LET HIM DETERMINE IF THE NUMBER WAS\r\n;WITHIN THE SPECIFIED FORMAT.\r\n;********************************************************************\r\n\tCALL\t$GETYP\t\t;DETERMINE TYPE\r\n\tMOV\tCH,LOW 20\t;ASSUME DOUBLE PREC. (16 PRINTABLE POS)\r\n\tJNB\tPUF40\r\n\r\n\r\n\tMOV\tCH,LOW 7\t;7 print positions if single precision\r\n\r\nPUF40:\tCALL\t$SIGNS\t\t;SEE IF NO. IS ZERO\r\n\tJZ\tPUF50\t\t;IF SO DON'T CALL $FOTNV\r\n\tCALL\t$FOTNV\t\t;BRACKET NO. SO ALL PRINTABLE DIGITS\r\n\t\t\t\t;IN THE INTEGER PART OF THE NUMBER AND\r\n\t\t\t\t;RETURN COMPLEMENTING EXPONENT IN (AL)\r\n\t\t\t\t;AND SF=1 IF THIS EXPONENT IS NEG.\r\n\t\t\t\t;(THERE ARE DIGITS TO RIGHT OF D.P)\r\nPUF50:\tPOP\tBX\t\t;GET OUTPUT BUFFER POINTER BACK\r\n\tJS\tPUF80\t\t;GO PRINT NO. WITH DIGITS TO RIGHT\r\n\t\t\t\t;OF DECIMAL POINT\r\n;*********************************************************************\r\n;KNOW AT THIS POINT WE HAVE A NUMBER LESS THAN 10^16 THAT HAS NO\r\n;PRINTABLE DIGITS TO RIGHT OF THE DECIMAL POINT. THEREFORE WE HAVE\r\n;TO PUT IN LEADING ZEROS IF THE SPECIFIED PRINT POSITIONS TO THE LEFT\r\n;OF THE DECIMAL POINT ARE MORE THAN THE PRINTABLE POSITIONS (CH)\r\n;AND THE POSITIVE EXPONENT IN (AL)\r\n;********************************************************************\r\n\tMOV\tDL,AL\t\t;SAVE THIS POSITIVE EXP. FOR LATER\r\n\tADD\tAL,CH\t\t;THIS IS NECESSARY PRINT POSITIONS\r\n\t\t\t\t;TO ACCOMODATE THIS NUMBER.\r\n\tSUB\tAL,BYTE PTR $FMTCX+1\t;SUBTRACT DIGITS TO LEFT\r\n\tJNS\tPUF60\t\t;NO LEADING ZEROS REQUIRED\r\n\tNEG\tAL\t\t;MUST MAKE (AL) POSITIVE FOR $FOTZ\r\n\tCALL\t$FOTZ\t\t;PUT IN (AL) LEADING ZEROS\r\nPUF60:\tXOR\tCL,CL\t\t;ZERO CREATED ZEROS\r\n\tCALL\tDPCOM\t\t;SET-UP DECIMAL POINT AND COMMA CT.\r\n\tPUSH\tWORD PTR $FMTCX ;SAVE DECIMAL POINT INFO.\r\n\tPUSH\tDX\t\t;SAVE EXPONENT\r\n\tCALL\t$FOTCV\t\t;CONVERT THE BINARY NO. TO ASCII DIGITS\r\n\t\t\t\t;NOTE THAT $FOTCV WILL ONLY CONVERT\r\n\t\t\t\t;THE PRINTABLE DIGITS. IF THERE WAS A\r\n\t\t\t\t;NON-ZERO EXPONENT AS WELL WE MUST\r\n\t\t\t\t;INSERT SOME ZEROS PRIOR TO THE DECIMAL\r\n\t\t\t\t;POINT. FURTHER WE MUST PAY ATTENTION\r\n\t\t\t\t;TO OUR COMMA COUNT WHILE INSERTING\r\n\t\t\t\t;THESE ZEROS.\r\n\tPOP\tDX\t\t;RECALL EXPONENT\r\n\tPOP\tWORD PTR $FMTCX ;RECALL DECIMAL POINT INFO.\r\n\tPUSH\tWORD PTR $FMTCX ;SAVE DESIRED POSITIONS LEFT/RT.\r\n\tXOR\tAL,AL\t\t;WANT DL IN AL WITH APPROPRIATE SIGNS\r\n\tOR\tAL,DL\t\t;DL=EXPONENT\r\n\tJZ\tPUF70\t\t;IF NO ZEROS PRIOR TO D.P. JUMP\r\n\tCALL\t$FOTZC\t\t;PUT IN ZEROS AND PAY ATTENTION TO\r\n\t\t\t\t;COMMA COUNT.\r\n\tCALL\t$FOTED\t\t;PUT IN DECIMAL POINT\r\nPUF70:\tPOP\tWORD PTR $FMTCX ;RECALL DESIRED POSITIONS LEFT/RT.\r\n\tPUSH\tWORD PTR $FMTCX ;AND SAVE AGAIN\r\n\tMOV\tAL,BYTE PTR $FMTCX\t;FETCH NO. POSITIONS TO RT. OF D.P.\r\n\tJMP\t$PUIZ\t\t;GO PUT IN ANY REQUIRED TRAILING ZEROS\r\n\t\t\t\t;AND CHECK TO ASSURE FIELD SPECS. MET\r\nPUF80:\r\n;********************************************************************\r\n;AT THIS POINT WE KNOW WE HAVE PRINTABLE DIGITS TO THE RIGHT OF THE\r\n;DECIMAL POINT . WE KNOW THIS BECAUSE $FOTNV WAS CALLED TO BRACKET\r\n;THE NO. SUCH THAT THE PRINTABLE DIGITS WERE IN THE INTEGER PART\r\n;OF THE NUMBER AND THE COMPLEMENTING EXPONENT WAS IN (AL). FURTHER\r\n;SF=1 WAS SET TO INDICATE (AL) WAS NEGATIVE.\r\n;WE FURTHER NEED TO DETERMINE IF WE NEED TO ROUND SOMEWHERE\r\n;WITHIN THE PRINTABLE DIGITS. THIS WILL BE THE CASE IF THE\r\n;DIGITS TO BE PRINTED TO THE RIGHT IS LESS THAN THOSE AVAILABLE\r\n;TO THE RIGHT. (AL) HAS THOSE AVAILABLE TO THE RIGHT, $FMTCX HAS\r\n;THOSE DESIRED.\r\n;***************************************************************\r\n\tMOV\tDL,AL\t\t;SAVE THE COMPLEMENTING EXPONENT\r\n\tMOV\tAL,BYTE PTR $FMTCX\t;FETCH DIGITS DESIRED TO RIGHT\r\n\tOR\tAL,AL\t\t;IF NON-ZERO MUST SUBTRACT 1\r\n\t\t\t\t;BECAUSE DECIMAL POINT INCLUDED\r\n\tJZ\tPUF90\t\t;PROCEED IF NO DIG. TO RT. DESIRED\r\n\tDEC\tAL\t\t;TAKE OUT FOR DECIMAL POINT COUNT\r\nPUF90:\tMOV\tDH,AL\t\t;SAVE DESIRED DIGITS TO RIGHT COUNT\r\n\tADD\tAL,DL\t\t;SUBTRACT DIGITS AVAILABLE TO RT.\r\n\t\t\t\t;(THIS IS A SUBTRACT BECAUSE (DL) IS\r\n\t\t\t\t;THE NEGATIVE TO DIGITS TO RT.)\r\n\tMOV\tCL,AL\t\t;WILL NEED THIS FOR LATER. IT\r\n\t\t\t\t;IS THE NEGATIVE OF THE NUMBER\r\n\t\t\t\t;OF DIGITS WE ARE ABOUT TO SHIFT\r\n\t\t\t\t;OFF TO THE RIGHT\r\n\tJS\tPUF100\t\t;JUMP IF INTERNAL ROUNDING NECESSARY\r\n\tXOR\tAL,AL\t\t;WILL NEED ALL PRINTABLE DIGITS\r\n\tMOV\tCL,AL\t\t;NO DIGITS SHIFTED OFF\r\n\tJMP\tSHORT PUF110\t;DO NOT NEED TO DIVIDE IF POSITIVE\r\nPUF100: PUSH\tAX\r\n\tPUSH\tCX\t\t;SAVE GENERATED LEADING ZEROS\r\n\tPUSH\tDX\t\t;\r\n\tPUSH\tBX\r\n\tCALL\t$DIV10\t\t;NEED TO ELIMINATE EXCESS PRINTABLE\r\n\tPOP\tBX\r\n\tPOP\tDX\r\n\tPOP\tCX\t\t;RECALL GENERATED LEADING ZEROS\r\n\tPOP\tAX\t\t;RECALL EXCESS DIGITS\r\n\tINC\tAL\t\t;BECAUSE AL WAS ORIGINALLY NEGATIVE\r\n\tJS\tPUF100\t\t;CONTINUE FOR INTERNAL ROUNDING\r\n\tMOV\tAH,CL\t\t;WILL NEED CREATED LEADING ZEROS\r\n\t\t\t\t;LATER\r\nPUF110:\r\n\tMOV\tAL,DL\t\t;GET NEGATIVE EXPONENT\r\n\tSUB\tAL,CL\t\t;ADD CREATED ZEROS\r\n\tADD\tAL,CH\t\t;IF SF=1 THEN NO DIGITS TO LEFT\r\n\tJNS\tPUF120\t\t;JUMP IF DIGITS TO LEFT OF DECIMAL PT\r\n;******************************************************************\r\n;WE KNOW HERE THAT THE ENTIRE PRINTABLE DIGITS GO TO THE RIGHT OF\r\n;THE DECIMAL POINT. IF DIGITS WERE REQUESTED TO THE LEFT THEN WE\r\n;NEED TO INSERT LEADING ZEROS\r\n;********************************************************************\r\n\tMOV\tAL,BYTE PTR $FMTCX+1\t;DESIRED LEADING DIGITS\r\n\tCALL\t$FOTZ\t\t;INSERT (AL) LEADING ZEROS\r\n\tMOV\tBYTE PTR 0[BX],LOW \".\"  ;PUT IN DECIMAL POINT\r\n\tMOV\tWORD PTR $DPADR,BX\t;*** Save DP position for $FOTED, etc. ***\r\n\tINC\tBX\t\t;NEXT BUFFER POSITION\r\n\tXOR\tCL,CL\t\t;COMMA COUNT TO ZERO\r\n;**********************************************************\r\n;OK WE'VE PUT IN THE REQUIRED LEADING ZEROS PRIOR\r\n;TO THE DECIMAL POINT. WE MAY FURTHER NEED TO PUT IN A FEW\r\n;AFTER THE DECIMAL POINT. WE KNOW THAT THE EXPONENT IS\r\n;GREATER IN ABSOLUTE VALUE THAN THE NO. OF PRINTABLE DIGITS.\r\n;THE NUMBER OF LEADING ZEROS REQUIRE HERE THEN IS ABS.\r\n;VALUE OF THE EXPONENT LESS PRINTABLE DIGITS\r\n;**********************************************************\r\n\tMOV\tAL,DH\t\t;Get number of digits after decimal point\r\n\tSUB\tAL,CH\t\t;Subtract number that will be printed by $FOTCV\r\n\tCALL\t$FOTZ\t\t;PUT IN (AL) LEADING ZEROS\r\n\tXOR\tCX,CX\t\t;*** No longer need comma & decimal info ***\r\n\tPUSH\tDX\t\t;*** 8-Mar-82/ngt Fix                    ***\r\n\tPUSH\tWORD PTR $FMTCX ;*** Balance number of PUSHes and POPs   ***\r\n\tJMP\tSHORT PUF140\t;GO PUT IN THE DIGITS\r\nPUF120:\r\n;*******************************************************************\r\n;WE KNOW HERE THAT THERE ARE DIGITS TO THE LEFT OF THE DEC.PT.\r\n;WE NEED TO DETERMINE IF LEADING ZEROS ARE REQUIRED. THEY WILL BE\r\n;REQUIRED IF THE SPECIFIED DIGITS TO THE LEFT IS GREATER THAN\r\n;THE NUMBER OF PRINTABLE DIGITS LESS THOSE TO THE RIGHT. RECALL THAT\r\n;EARLIER WE PUT THE NUMBER OF PRINTABLE DIGITS IN (CH). DUE TO THE\r\n;ABOVE CODE WE MAY HAVE INCREASED THE NUMBER OF DIGITS AVAILABLE TO\r\n;THE LEFT BECAUSE WE SHIFTED THE NUMBER RIGHT BRINGING IN LEADING\r\n;ZEROS. FOR EXAMPLE: IF WE GOT HERE WITH THE NUMBER 12.78575 $FOTNV\r\n;WOULD HAVE 1278575. IN THE FAC AND -5 IN (AL), IF FURTHER THE INPUT\r\n;FORMAT HAD BEEN ########.## WE WOULD HAVE SHIFTED THE NUMBER 3 DIGITS\r\n;RIGHT FOR ROUNDING PURPOSES LEAVING 1278.575 IN THE FAC AND -3 IN\r\n;(CL). ONCE WE GO TO $FOTCV , HE SHALL PRODUCE THE DIGITS\r\n;00012.79 SO THE FORMULA FOR LEADING ZEROS IS:\r\n;LEADING ZEROS=DESIRED DIGITS-[(CH)+(DL)-(CL)]\r\n;               =DESIRED DIGITS-(CH)-(DL)+(CL)\r\n;OR AS IN THIS EXAMPLE,LEADING ZEROS=8-[7+(-5)-(-3)]=3\r\n;*********************************************************************\r\n\tMOV\tAL,BYTE PTR $FMTCX+1\t;FETCH DESIRED DIGITS\r\n\tPUSH\tDX\t\t;SAVE DIGITS TO RIGHT\r\n\tPUSH\tWORD PTR $FMTCX ;SAVE DIGITS TO LEFT/RIGHT\r\n\tSUB\tAL,CH\t\t;SUBTRACT PRINTABLE DIGITS\r\n\tSUB\tAL,DL\t\t;ADD DIGITS TO RIGHT\r\n\tADD\tAL,CL\t\t;SUBTRACT CREATED LEADING ZEROS\r\n\tJS\tPUF130\t\t;IF NO LEADING ZEROS REQUIRED JUMP\r\n\tCALL\t$FOTZ\t\t;PUT IN REQUIRED LEADING ZEROS\r\nPUF130: CALL\tDPCOM\t\t;SET UP DECIMAL POINT AND COMMA CTS.\r\nPUF140: PUSH\tWORD PTR $FMTCX ;SAVE DECIMAL POINT INFO.\r\n\tCALL\t$FOTCV\t\t;CONVERT FAC TO ASCII DIGITS AND\r\n\t\t\t\t;INSERT INTO OUTPUT BUFFER. DECIMAL\r\n\t\t\t\t;POINT AND COMMA COUNTS ARE IN\r\n\t\t\t\t;(CH)&(CL) RESPECTIVELY\r\n\tPOP\tWORD PTR $FMTCX ;Retrieve the right and left counts.\r\n\t\t\t\t;($FMTCX:=digits to right of decimal\r\n\t\t\t\t;point plus one for the decimal point,\r\n\t\t\t\t;$FMTCX+1:=digits to left of decimal\r\n\t\t\t\t;point.)\r\n\tPOP\tAX\t\t;RECALL DIGITS TO LEFT\r\n\tPOP\tDX\t\t;RECALL DIGITS TO RIGHT\r\n\tTEST\tBYTE PTR $FMTCX,LOW 377O\t;Is the right side count zero?\r\n\t\t\t\t;(This count includes the point\r\n\t\t\t\t;point itself.)\r\n\tJNZ\tPUF150\t\t;No, retain the decimal point.\r\n\t\t\t\t;Go see if trailing zeroes are needed.\r\n\tMOV\tBX,WORD PTR $DPADR\t;Yes, get rid of the decimal point\r\n\t\t\t\t;by backing up the pointer so the\r\n\tJMP\t$PUFXE\t\t;GO DO FIX-UP\r\nPUF150:\r\n;*****************************************************************\r\n;WE NEED TO NOW DETERMINE IF TRAILING ZEROS ARE TO BE PRINTED\r\n;THIS WILL BE THE CASE IF NO. DIGITS TO THE RIGHT (DL) IS LESS\r\n;THAN THOSE REQUESTED (AL).\r\n;****************************************************************\r\n\tADD\tAL,DL\t\t;SUBTRACT DIGITS TO THE RIGHT\r\n\tDEC\tAL\t\t;BECAUSE DECIMAL POINT WAS INCLUDED\r\n\tJS\tPUF160\t\t;GO DO FIX-UP\r\n\tCALL\t$FOTZ\t\t;PUT IN TRAILING ZEROS\r\nPUF160: JMP\t$PUFXE\t\t;GO DO FIX-UP\r\n\r\n\r\n\r\nDPCOM:\t\t\t\t;ROUTINE TO SET UP DECIMAL POINT AND COMMA COUNTS\r\n\tMOV\tAL,CH\t\t;FETCH PRINTABLE DIGITS\r\n\tADD\tAL,DL\t\t;SUBTRACT DIGITS TO RIGHT\r\n\tSUB\tAL,CL\t\t;ADD CREATED ZEROS\r\n\tINC\tAL\t\t;FOR SIGN\r\n\tMOV\tCH,AL\r\nDPC10:\tSUB\tAL,LOW 3\t;SUBTRACT OUT AL MULTIPLES OF 3\r\n\tJG\tDPC10\r\n\tADD\tAL,LOW 3\r\n\tMOV\tCL,AL\t\t;COMMA COUNT NOW SET\r\n\tMOV\tAL,BYTE PTR $FMTAX\t;FETCH FORMAT FLAGS\r\n\tAND\tAL,LOW 100\t;SEE IF COMMAS DESIRED\r\n\tJNZ\tDPC20\r\n\tMOV\tCL,AL\t\t;ZERO COMMA COUNT\r\nDPC20:\tRET\r\n\r\n\tSUBTTL\t $PUFOT  PRINT USING OUTPUT ROUTINE\r\n;***************************************************************\r\n;\r\n;       $PUFOT  THIS ROUTINE PROVIDES TOP-LEVEL CONTROL OF THE\r\n;               PRINT USING OUTPUT FUNCTION.\r\n;       CALLING SEQUENCE:       CALL    $PUFOT\r\n;               WITH NUMBER TO BE OUTPUT IN THE FAC AND FORMAT\r\n;               SPECIFICATIONS IN (AL), AND (CX).(AL) IS SET AS\r\n;               FOLLOWS:\r\n;               BIT     7       =0 FREE FORMAT OUTPUT, NUMBER DICTATES\r\n;                               OUTPUT FORMAT\r\n;                               =1 PRINT USING OUTPUT. THE REMAINDER OF\r\n;                               (AL) AND (CX) DICTATE HOW THE NUMBER IS\r\n;                               TO BE PRINTED\r\n;                       6       IF =1 GROUP THE DIGITS IN THE INTEGER\r\n;                               PART IN GROUPS OF THREE AND SEPARATE\r\n;                               WITH COMMAS.\r\n;                       5       IF =1 FILL THE LEADING SPACES IN THE\r\n;                               FIELD WITH ASTERISKS \"*\"\r\n;                       4       IF =1 OUTPUT THE NUMBER WITH A FLOATING\r\n;                               DOLLAR SIGN \"$\"\r\n;                       3       IF =1 PRINT THE SIGN OF THE NUMBER WITH\r\n;                               A PLUS \"+\" IF POSITIVE INSTEAD OF A SPC\r\n;                       2       IF =1 PRINT THE SIGN AFTER THE NUMBER\r\n;                       1       UNUSED\r\n;                       0       IF =1 PRINT THE NUMBER IN SCIENTIFIC\r\n;                               NOTATION AND IGNORE BIT 6.\r\n;                               IF =0 USE FIXED POINT NOTATION.\r\n;               (CH)    NUMBER PLACES IN FIELD TO LEFT OF DECIMAL POINT\r\n;                       (DOES NOT INCLUDE THE DECIMAL POINT)\r\n;               (CL)    NUMBER PLACES IN THE FIELD TO THE RIGHT OF THE\r\n;                       DECIMAL POINT (INCLUDES DECIMAL POINT)\r\n;\r\n;****************************************************************\r\n\r\nPUFOUT:\r\n$PUFOT:\r\n\tMOV\tAH,AL\t\t;FETCH FORMAT SPECS.\r\n\tTEST\tAH,LOW 100\t;ZF=0 IF COMMAS DESIRED\r\n\tMOV\tAH,LOW 3\t;IF COMMAS DESIRED\r\n\tJNZ\tPFO05\t\t;JUMP IF COMMAS DESIRED\r\n\tXOR\tAH,AH\t\t;COMMAS NOT DESIRED\r\nPFO05:\tMOV\tWORD PTR $FMTAX,AX\t;SAVE COMMA COUNT AND PFORMAT SPECS\r\n\tMOV\tWORD PTR $FMTCX,CX\t;SAVE POSITIONS TO RT./LEFT\r\n\t\t\t\t;OF DECIMAL POINT\r\n\tMOV\tAH,AL\t\t;FOR TESTING\r\n\tMOV\tBX,OFFSET $FBUFF+1\t;FETCH BUFFER POINTER\r\n\tMOV\tBYTE PTR 0[BX],LOW \" \"  ;MOVE IN SPACE FOR POSSIBLE SIGN\r\n\tTEST\tAH,LOW 10\t;SEE IF \"+\" DESIRED\r\n\tJZ\tPFO10\t\t;JUMP IF NOT\r\n\tMOV\tBYTE PTR 0[BX],LOW \"+\"  ;MOVE IN PLUS\r\nPFO10:\tPUSH\tBX\t\t;SAVE BUFFER POINTER\r\n\tCALL\t$SIGNS\t\t;DETERMINE SIGN OF NUMBER\r\n\tPOP\tBX\t\t;RECALL BUFFER POINTER\r\n\tJNS\tPFO20\t\t;JUMP IF POSITIVE\r\n\tMOV\tBYTE PTR 0[BX],LOW \"-\"  ;PUT IN MINUS SGN\r\n\tPUSH\tBX\t\t;SAVE BUFFER PTR.\r\n\tCALL\t$VNEG\t\t;NEGATE NO. SO WE WORK ONLY WITH\r\n\tPOP\tBX\t\t;RECALL BUFFER PTR.\r\nPFO20:\tINC\tBX\t\t;POINT TO NEXT BUFFER POSITION\r\n\tMOV\tBYTE PTR 0[BX],LOW \"0\"  ;PUT IN ZERO IN CASE NO IS ZERO\r\n\tCALL\t$GETYP\t\t;SET COND CODES ACCORDING TO TYPE\r\n\tMOV\tAX,WORD PTR $FMTAX\t;FETCH FORMAT SPECS\r\n\tMOV\tCX,WORD PTR $FMTCX\r\n\tJS\tPFO40\t\t;IF INTEGER JUMP\r\n\tJMP\t$PUF\t\t;DO FLOATING POINT FORMATTING\r\nPFO40:\tJMP\t$PUI\t\t;PROCESS INTEGER\r\n\r\n\tSUBTTL\t $PUI\t PRINT USING FOR INTEGERS\r\n;************************************************************\r\n;\r\n;       $PUI    PRINT THE INTEGER ACCORDING TO THE FORMATS IN\r\n;               $FMTCX (NO PLACES TO LEFT/RIGHT OF DECIMAL POINT)\r\n;               $FMTAX (AH)=0 OR 3 FOR COMMA INSERTION AND (AL)\r\n;               HAS THE FOLLOWING MEANING:\r\n;               BIT     7       =0 FREE FORMAT OUTPUT, NUMBER DICTATES\r\n;                               OUTPUT FORMAT\r\n;                               =1 PRINT USING OUTPUT. THE REMAINDER OF\r\n;                               (AL) AND (CX) DICTATE HOW THE NUMBER IS\r\n;                               TO BE PRINTED\r\n;                       6       IF =1 GROUP THE DIGITS IN THE INTEGER\r\n;                               PART IN GROUPS OF THREE AND SEPARATE\r\n;                               WITH COMMAS.\r\n;                       5       IF =1 FILL THE LEADING SPACES IN THE\r\n;                               FIELD WITH ASTERISKS \"*\"\r\n;                       4       IF =1 OUTPUT THE NUMBER WITH A FLOATING\r\n;                               DOLLAR SIGN \"$\"\r\n;                       3       IF =1 PRINT THE SIGN OF THE NUMBER WITH\r\n;                               A PLUS \"+\" IF POSITIVE INSTEAD OF A SPC\r\n;                       2       IF =1 PRINT THE SIGN AFTER THE NUMBER\r\n;                       1       UNUSED\r\n;                       0       IF =1 PRINT THE NUMBER IN SCIENTIFIC\r\n;                               NOTATION AND IGNORE BIT 6.\r\n;                               IF =0 USE FIXED POINT NOTATION.\r\n;       CALLING SEQUENCE:       CALL    $PUI\r\n;               WITH THE AFOREMENTIONED INFORMATION AVAILABLE\r\n;\r\n;******************************************************************\r\n\r\n$PUI:\tMOV\tAX,WORD PTR $FMTAX\t;FETCH PRINT DESCRIPTION DATA\r\n\tMOV\tCL,AH\t\t;$FOTCI WILL NEED COMMA INFO\r\n\t\t\t\t;IN (CL)\r\n\tMOV\tCH,LOW 6\t;AT MOST 6 PLACES PRIOR TO DECIMAL PT\r\n\tSHR\tAL,1\t\t;SETS CF=1 IF \"E\" TYPE PRINT DESIRED\r\n\tMOV\tDX,WORD PTR $FMTCX\t;FETCH PLACES TO LEFT/RIGHT OF DEC. PT\r\n\tJNB\tPI10\t\t;IF NOT \"E\" FORMAT JUMP\r\n\tPUSH\tBX\t\t;SAVE BUFFER POINTER\r\n\tPUSH\tDX\t\t;SAVE PLACES TO LEFT/RIGHT OF DEC. PT\r\n\tCALL\t$CSI\t\t;CONVERT THE INTEGER TO S.P.\r\n\tXOR\tAL,AL\t\t;MUST SET ZF=1 FOR $PUFE\r\n\tPOP\tDX\t\t;FETCH PLACES TO LEFT /RIGHT OF D.P.\r\n\tJMP\t$PUFE\t\t;GO FORMAT THE SINGLE PRECISION NO.\r\nPI10:\tMOV\tAL,DH\t\t;FETCH PLACES TO LEFT OF D.P.\r\n\tSUB\tAL,LOW 5\t;LET'S SEE IF LEADING ZEROS NEEDED\r\n;*******************************************************************\r\n;AT MOST 5 PRINT POSITIONS NEEDED FOR INTEGER (-32768,32767) SO IF\r\n;DESIRED NO. PLACES ON LEFT IS MORE THAN 5 WE NEED TO FILL THESE\r\n;POSITIONS WITH ASCII SPACES.\r\n;******************************************************************\r\n\tJS\tPI20\t\t;JUMP IF LESS THAN 5\r\n\tCALL\t$FOTZ\t\t;ZERO FILL (AL) POSITIONS\r\nPI20:\tPUSH\tDX\t\t;SAVE POSITIONS TO LEFT/RIGHT OF D.P.\r\n\tCALL\t$FOTCI\t\t;CONVERT THE INTEGER TO ASCII DIGITS\r\n\t\t\t\t;AND INSERT DECIMAL POINT AND COMMAS\r\n\t\t\t\t;AS DESIRED\r\n\tPOP\tAX\t\t;RECALL NO. PLACESTO LEFT/RIGHT OF D.P.\r\n\tPUSH\tAX\t\t;AND SAVE AGAIN\r\n$PUIZ:\tOR\tAL,AL\t\t;IF 0 THEN NO DECIMAL POINT DESIRED\r\n\tJNZ\tPI30\t\t;IF DESIRED PROCEED\r\n\tDEC\tBX\t\t;THIS WILL ELIMINATE DECIMAL POINT\r\nPI30:\tDEC\tAL\t\t;MAY NEED TO INSERT ZEROS TO RIGHT\r\n\t\t\t\t;OF DECIMAL POINT.\r\n\tJS\tPI40\t\t;JUMP IF NOT DESIRED\r\n\tCALL\t$FOTZ\t\t;PUT (AL) ASCII ZEROS IN BUFFER\r\n\tMOV\tBYTE PTR 0[BX],LOW 0\t;RE-ESTABLISH END-OF-PRINT\r\nPI40:\tPOP\tWORD PTR $FMTCX ;MAINTAIN DIGITS LEFT/RT. OF DP.\r\n\tJMP\t$PUFXE\t\t;BE SURE FORMAT SPECS MET\r\n\r\n\tSUBTTL\t $RND\t PSEUDO-RANDOM NUMBER GENERATOR\r\n;******************************************************************\r\n;\r\n;       $RND    GENERATE THE NEXT RANDOM NUMBER IN THE\r\n;               SEQUENCE.\r\n;\r\n;       CALLING SEQUENCE:       CALL    $RND\r\n;               WITH THE PREVIOUS RANDOM NUMBER IN $RNDX\r\n;               AND DATA ITEMS $RNDA AND $RNDC SET PROPERLY\r\n;       METHOD: LINEAR CONGRUENTIAL FROM VOL. 2 CHAPTER 3 OF\r\n;               KNUTH - THE ART OF COMPUTER PROGRAMMING.\r\n;               M=16,777,216 OR 2^24; [ A MOD 8 ]=5 AND\r\n;               [ C MOD 8 ]=3\r\n;               RND(N+1)=(RND(N)*A+C)MOD M\r\n;\r\n;               THE DATA ITEMS A AND C CORRESPOND TO $RNDA\r\n;               AND $RNDC RESPECTIVELY AND WERE CAREFULLY\r\n;               CHOSEN TO MEET THE RECIPE IN KNUTH.\r\n;\r\n;**************************************************************\r\n\r\nRND:\r\n$RND:\tCALL\t$SIGNS\t\t;FIND WHICH MODE REQUESTED\r\n\tJZ\tOLDRN\t\t;RETURN PREVIOUS NO.?\r\n\tJNS\tRND10\t\t;GO DO NEW SEED\r\n\tMOV\tAX,WORD PTR $FACLO\t;FETCH NUMBER\r\n\tMOV\tWORD PTR $RNDX,AX\t;AND INITIALIZE LAST RANDOM #\r\n\tMOV\tAL,BYTE PTR $FAC-1\r\n\tMOV\tBYTE PTR $RNDX+2,AL\t;SO SEQUENCE STARTS AGAIN\r\nRND10:\tMOV\tAX,WORD PTR $RNDX\t;FETCH LOW 16 BITS OF RNDX\r\n\tMUL\tWORD PTR $RNDA\t;MULTIPLY BY LOW BITS OF A\r\n\tMOV\tDI,AX\t\t;SAVE LOW 16 BITS\r\n\tMOV\tCL,DL\t\t;SAVE UPPER 8 BITS\r\n\tMOV\tAL,BYTE PTR $RNDA+2\t;FETCH UPPER 8 BITS OF A\r\n\tXOR\tAH,AH\t\t;CLEAR UPPER AX\r\n\tMUL\tWORD PTR $RNDX\t;MULTIPLY BY LOW RNDX\r\n\tADD\tCL,AL\t\t;ADD TO UPPER 8 BITS\r\n\tXOR\tAH,AH\t\t;CLEAR UPPER AX\r\n\tMOV\tAL,BYTE PTR $RNDX+2\t;FETCH HIGH 8 BITS OF RNDX\r\n\tMUL\tWORD PTR $RNDA\t;MULTIPLY BY LOW 16 OF A\r\n\tADD\tCL,AL\t\t;ADD IN TO UPPER 8\r\n\tXOR\tAH,AH\t\t;CLEAR OVERFLOW BYTE FOR NORM\r\n\tMOV\tDX,WORD PTR $RNDC\t;FETCH LOW 16 OF C\r\n\tADD\tDX,DI\t\t;ADD IN LOW OF RND(N)*A\r\n\tMOV\tBL,BYTE PTR $RNDC+2\t;FETCH HIGH OF C\r\n\tADC\tBL,CL\t\t;ADD WITH CARRY HIGH RND(N)*A\r\n\tMOV\tBYTE PTR $FAC+1,AH\t;SIGN IS POSITIVE\r\n\tMOV\tAL,LOW 200\t;SO NORM WILL PRODUCE NO.\r\n\t\t\t\t;LESS THAN 1\r\n\tMOV\tBYTE PTR $FAC,AL\r\n\tMOV\tWORD PTR $RNDX,DX\t;SAVE NEW RND(N+1)\r\n\tMOV\tBYTE PTR $RNDX+2,BL\r\n\tMOV\tAL,LOW 4\t;MUST SET VALTP TO SINGLE PREC.\r\n\tMOV\tBYTE PTR $VALTP,AL\r\n\tJMP\t$NORMS\r\nNEWSD:\t\t\t\t;DETERMINE NEW RANDOM NO. SEED\r\n\tMOV\tBX,OFFSET $FBUFF\t;WILL SUM THE FIRST 32 WDS OF\r\n\tMOV\tCX,40\t\t;RAM\r\nNEW10:\tADD\tAX,WORD PTR 0[BX]\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tLOOP\tNEW10\r\n\tAND\tAL,LOW 376\t;BE SURE BIT 0=0 SO AS TO NOT\r\n\t\t\t\t;MATCH RND0\r\n\tMOV\tWORD PTR $RNDX,AX\r\n\tJMP\tSHORT RND10\t;GO PROCEED AS USUAL\r\nOLDRN:\t\t\t\t;RETURN THE PREVIOUS RANDOM NO.\r\n\tMOV\tDX,WORD PTR $RNDX\t;FETCH LOW 16 BITS\r\n\tMOV\tBL,BYTE PTR $RNDX+2\t;FETCH HIGH 8 BITS\r\n\tXOR\tAX,AX\t\t;CLEAR OVERFLOW BYTE (AH)\r\n\tMOV\tAL,LOW 200\t;EXPONENT OF 0\r\n\tMOV\tBYTE PTR $FAC,AL\r\n\tMOV\tBYTE PTR $FAC+1,AH\t;POSITIVE SIGN\r\n\tJMP\t$NORMS\t\t;GO NORMALIZE\r\n\r\n\tSUBTTL\t $ROUND  DOUBLE PRECISION ROUND ROUTINE\r\n;*****************************************************************\r\n;\r\n;       $ROUND  ROUND THE DOUBLE PRECISION FLOATING POINT NUMBER IN\r\n;               $FAC+1 THRU $DFACL-1.\r\n;       CALLING SEQUENCE:       CALL    $ROUND\r\n;               WITH NUMBER IN $FAC TO BE ROUNDED\r\n;\r\n;******************************************************************\r\n\r\n$ROUND:\t\t\t;DOUBLE PRECISION ROUND AND PACK\r\n\tMOV\tBX,OFFSET $DFACL-1\r\n\tADD\tWORD PTR 0[BX],200\t;ADD TO HIGH BIT OV OVERFLOW BYTE\r\n\tMOV\tCX,3\t\t;3 MORE BYTES TO LOOK AT POTENTIALLY\r\n\tJNB\tRDD20\t\t;IF CF=0 WE ARE DONE\r\nRDD10:\tINC\tBX\r\n\tINC\tBX\r\n\tINC\tWORD PTR 0[BX]\t;IF THIS GETS ZF=1 THEN CARRY\r\n\tJNZ\tRDD20\t\t;FINISHED WHEN ZF=0\r\n\tLOOP\tRDD10\r\n\tINC\tBYTE PTR $FAC\t;MUST INCREMENT EXPONENT\r\n\tRCR\tWORD PTR 0[BX],1\t;SET HIGH BYTE TO 200\r\nRDD20:\r\n\tJZ\tRDD30\t\t;OVERFLOW HOOK\r\n\tTEST\tBYTE PTR $DFACL-1,LOW 377\t;SEE IF OVERFLOW BYTE ZERO\r\n\tJNZ\t$ROUNX\r\n\tAND\tBYTE PTR $DFACL,LOW 376 ;MAKE ANSWER EVEN\r\n$ROUNX:\r\n\tAND\tBYTE PTR $FAC-1,LOW 177 ;CLEAR SIGN BIT\r\n\tMOV\tAL,BYTE PTR $FAC+1\t;FETCH SIGN BYTE\r\n\tAND\tAL,LOW 200\t;CLEAR ALL BUT SIGN\r\n\tOR\tBYTE PTR $FAC-1,AL\t;AND SET SIGN APPROPRIATELY\r\n\tRET\r\nRDD30:\tJMP\t$OVFLS\r\n\r\n\tSUBTTL\t $ROUNS  INTEL 8086 ROUNDING SUBROUTINE\r\n;***********************************************************\r\n;\r\n;       $ROUNS  SINGLE PRECISION ROUNDING SUBROUTINE\r\n;       CALLING SEQUENCE:       CALL    $ROUNS\r\n;       ASSUMPTIONS:    (BLDXAH)WILL BE ROUNDED BY ADDING\r\n;                       128 TO (AH) . IF CF (CARRY) IS SET\r\n;                       AND (AH) IS NON-ZERO AFTER THIS\r\n;                       ADDITION (BLDX) WILL BE INCREMENTED\r\n;                       ONCE ROUNDING IS COMPLETE, LOGIC WILL\r\n;                       CONTINUE INTO PAKSP FOR PACKING THE MANTISSA\r\n;                       AND SIGN INTO THE FAC.\r\n;\r\n;**************************************************************\r\n\r\n$ROUNS: AND\tAH,LOW 340\t;CLEAR SUPERFLUOUS BITS\r\n$ROUNM: ADD\tAH,LOW 200\t;ADD TO MOST SIG. BIT OF AH\r\n\tJNB\tPAKSP\t\t;IF NO CARRY RETURN\r\n\tPUSHF\t\t\t;IF ZF=1 WANT TO ROUND TO EVEN\r\n\tINC\tDX\t\t;IF ZF=1 MUST INCREMENT BL\r\n\tJNZ\tTSTEVN\r\n\tPOPF\t\t\t;KNOW RESULT WILL BE EVEN\r\n\tINC\tBL\t\t;IF ZF=1 MUST INCREMENT EXPONENT\r\n\tJNZ\tPAKSP\r\n\tSTC\t\t\t;CF=1\r\n\tRCR\tBL,1\t\t;THIS WILL SET HIGH BIT OF BL\r\n\tINC\tBYTE PTR $FAC\t;IF THIS CAUSES ($FAC)=0 WE HAVE\r\n\t\t\t\t;OVERFLOW IN ROUNDING\r\n\tJNZ\tPAKSP\r\n\tJMP\t$OVFLS\r\nTSTEVN: POPF\t\t\t;IF ZF=1 MUST CLEAR LOW BIT OF DL\r\n\tJNZ\tPAKSP\t\t;GO PACK THE FAC\r\n\tAND\tDL,LOW 376\t;CLEAR LOW BIT\r\nPAKSP:\t\t\t\t;PAK SINGLE PRECISION FAC. EXPONENT IS IN FAC,SIGN IN FAC+1\r\n\t\t\t\t;THE MANTISSA IS IN (BLDX)\r\n\tMOV\tSI,OFFSET $FAC-3\t;LOAD ADDRESS OF $FAC IN SI\r\n\tMOV\tWORD PTR 0[SI],DX\t;MOVE LOWER MANTISSA WORD IN\r\n\tINC\tSI\t\t;INCREMENT TO HIGH MANTISSA BYTE\r\n\tINC\tSI\t\t;\r\n\tMOV\tBH,BYTE PTR $FAC+1\t;FETCH SIGN\r\n\tAND\tBX,100177\t;CLEAR ALL BUT SIGN IN BH SIGN IN BL\r\n\tOR\tBL,BH\t\t;(BL) NOW IN CORRECT FORMAT\r\n\tMOV\tBYTE PTR 0[SI],BL\t;PUT INTO FAC-1\r\n\tRET\r\n\r\n\tSUBTTL\t $SIGD\t CALCULATE SIGNIFICANT DIGITS FOR $FOUT\r\n;**************************************************************\r\n;\r\n;       $SIGD   WHEN $FOUT IS DETERMINING WHETHER TO PRINT\r\n;               A NUMBER IN SCIENTIFIC NOTATION OR FIXED POINT\r\n;               IT NEEDS TO KNOW THE NUMBER OF SIGNIFICANT DIGITS\r\n;               IF THE NUMBER IS LESS THAN .01 .\r\n;               PRIOR TO CALLING $SIGD, $FOUT HAS BRACKETED THE\r\n;               SIGNIFICANT DIGITS VIA $FOUNV. THE NUMBER IN THE\r\n;               FAC WILL BE AXXXXXX OR AXXXXXXXXXXXXXXX WHERE A IS\r\n;               NON-ZERO. $SIGD'S JOB IS TO DETERMINE HOW MANY OF\r\n;               THESE X'S STARTING FROM THE RIGHT ARE ZERO\r\n;               PRIOR TO A NON-ZERO X. FOR EACH ZERO X, $SIGD WILL\r\n;               INCREMENT (CL).\r\n;       CALLING SEQUENCE:       CALL    $SIGD\r\n;\r\n;*******************************************************************\r\n\r\n$SIGD:\t\t\t\t;(CL)=(CL)+1 FOR EACH ZERO DIGIT STARTING FROM\r\n\t\t\t\t;THE RIGHT . ASSUMES $FOUNV HAS PREVIOUSLY OPERATED.\r\n\tMOV\tSI,CX\t\t;SAVE CX\r\n\tCALL\t$VPSHF\t\t;PUSH EITHER 4 OR 8 BYTES OF $FAC\r\n\t\t\t\t;ON THE STACK ACCORDING TO $VALTP\r\n\tMOV\tCX,SI\t\t;MUSU MAINTAIN (CL)\r\n\tPUSH\tCX\r\n;**************************************************************\r\n;FIRST THING WE'LL DO IS ROUND THE FAC AND MAKE SURE WE\r\n;STILL HAVE AN INTEGER.\r\n;***************************************************************\r\n;*****************************************************************\r\n;IF WE ALREADY HAVE AN EXACT INTEGER DON'T WANT TO ADD .5 HERE\r\n;*****************************************************************\r\n\tCALL\t$GETYP\r\n\tJB\tSI31\t\t;JUMP IF SINGLE PREC\r\n\tCMP\tBYTE PTR $FAC,LOW 270\t;IF EQUAL OR SF=0 THEN INTEGER ALREADY\r\n\tJNS\tSI20\t\t;DON'T ADD .5\r\n\tJMP\tSHORT SI32\t;PROCESS FAC NORMALLY\r\nSI31:\tCMP\tBYTE PTR $FAC,LOW 230\t;IF SF=0 THEN INTEGER ALREADY\r\n\tJNS\tSI20\r\nSI32:\tCALL\t$VADDH\t\t;ADD .5 TO FAC\r\n\tCALL\t$VINT\t\t;MAKE SURE WE STILL HAVE AN INTEGER\r\nSI20:\r\n\tMOV\tBX,OFFSET $ZLO\t;FETCH ADDRESS OF Z INTO (BX)\r\n\tCALL\t$VMVMF\t\t;MOVE FAC TO Z , Z=INT(FAC+.5)\r\n\tPOP\tCX\t\t;GET (CL) BACK\r\nSI30:\tPUSH\tCX\t\t;SAVE CX FOR LATER\r\n\tMOV\tDI,OFFSET $Z1LO ;GET ADDRESS OF Z1\r\n\tMOV\tBX,OFFSET $ZLO\t;GET ADDRESS OF Z\r\n\tCALL\t$VMOVM\t\t;Z1=Z\r\n\tMOV\tBX,OFFSET $ZLO\t;FETCH ADDRESS OF Z\r\n\tCALL\t$VMVFM\t\t;MOVE Z TO FAC\r\n\tCALL\t$DIV10\t\t;FAC=Z/10\r\n\tCALL\t$VINT\t\t;FAC=INT(Z/10)\r\n\tMOV\tBX,OFFSET $ZLO\r\n\tCALL\t$VMVMF\t\t;Z=INT(Z/10)\r\n\tCALL\t$MUL10\t\t;FAC=INT(Z/10)*10\r\n\tMOV\tBX,OFFSET $Z1-1 ;ADDRESS OF Z1-1\r\n\tCALL\t$GETYP\t\t;NEED TO DECREMENT BX IF S.P.\r\n\tJNB\tSI35\r\n\tSUB\tBX,4\t\t;NOW (BX) POINTS TO S.P.\r\nSI35:\r\n\tCALL\t$VCMPM\t\t;COMPARE TO FAC\r\n\tPOP\tCX\t\t;GET SIGNIFICANT DIGIT COUNT BACK\r\n\tJNZ\tSI40\t\t;THROUGH WHEN NON-ZERO\r\n\tINC\tCL\t\t;(CL)=(CL)+1\r\n\tJMP\tSHORT SI30\t;LET'S GO SEE IF WE CAN FIND ANOTHER\r\nSI40:\tMOV\tBP,CX\t\t;SAVE CX\r\n\tCALL\t$VPOPF\t\t;RESTORE ORIGINAL FAC\r\n\tMOV\tCX,BP\t\t;RESTORE CX\r\n\r\n\r\n\tRET\r\nCSEG\tENDS\r\n\tEND\t\t\t;END MATH86.MAC\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "MSDOSU",
          "type": "blob",
          "size": 3.2705078125,
          "content": "; [ This translation created 12-Jan-83 by Version 4.3 ]\n\n\tSUBTTL    MSDOSU - MS-DOS Constants and Data-Structure Definitions\n\nCOMMENT\t*\n\n--------- --- ---- -- ---------\nCOPYRIGHT (C) 1982 BY MICROSOFT\n--------- --- ---- -- ---------\n\n\tProgrammer: Tom Corbett,  Microsoft Inc.\n\n\t*\n\nCALLOS\tMACRO\tFUNC\nIFNB\t<FUNC>  \n\tMOV\tAH,LOW OFFSET FUNC\nENDIF \n\tINT\t33D\t\t;MSDOS system call\nENDM \n\nROFFST\tMACRO\tNAME,SIZE\t;define record macro\n\tNAME=_OFFST\n\t_OFFST=_OFFST+SIZE\nENDM \n\n\n; MSDOS System Call codes\n;\n\tC_PRTO=5D\t\t;Printer output\n\tC_DCIO=6D\t\t;Direct console I/O\n\tC_REST=13D\t\t;INITIALIZE BDOS\n\tC_SDRV=14D\t\t;SET CURRENTLY SELECTED DRIVE\n\tC_OPEN=15D\n\tC_CLOS=16D\n\tC_SEAR=17D\t\t;SEARCH FOR FILE\n\tC_DELE=19D\n\tC_READ=20D\n\tC_MAKE=22D\n\tC_RENA=23D\n\tC_GDRV=25D\t\t;GET CURRENTLY SELECTED DRIVE\n\tC_BUFF=26D\t\t;SET DMA ADDRESS\n\tC_RNDR=33D\t\t;Random read\n\tC_RNDW=34D\t\t;Random write\n\tC_RBR=39D\t\t;Random Block Read\n\tC_PARS=41D\t\t;Parse Filename\n\n\tFNAML=11D\t\t;number of bytes in Filename with extension\n\tDATPSC=128D\t\t;bytes per sector\n\tFCBSIZ=38D\t\t;File Control Block size\n\n;MS-DOS FILE-DATA-BLOCK Record Definition\n;\n\t_OFFST=0\t\t;initialize count\n\tROFFST\tF_NUL1,1\t;not used by basic interpreter\n\tROFFST\tF_NUM,1\t\t;file number 0..255\n\tROFFST\tF_NUL2,2\t;not used by basic interpreter\n\tROFFST\tF_NEXT,2\t;thread for linked list, [MEMSIZ]=end\n\tROFFST\tF_MODE,1\t;file mode:\n\tMD_SQI=1D\t\t;sequential input\n\tMD_SQO=2D\t\t;sequential output\n\tMD_RND=4D\t\t;random\n\tMD_APP=8D\t\t;append\n\tROFFST\tF_FCB,FCBSIZ\t;File Control Block: used to communicate with OS\n\tROFFST\tF_CLOC,2\t;for seq files: num sectors read/written   (LOCOFS)\n\t\t\t\t;for rnd files: last record number + 1\n\tROFFST\tF_ORCT,1\t;\"Original Byte Count\"                     (ORNOFS)\n\t\t\t\t;for seq input: #bytes in sector when read\n\t\t\t\t;for seq output: #bytes in output sector\n\t\t\t\t;for random files: bytes per sector\n\tROFFST\tF_BREM,1\t;number of bytes till end-of-buffer        (NMLOFS)\n\tROFFST\tF_CODE,1\t;file encoding:\n\tFC_ASC=0\t\t;Ascii SAVE, Data files\n\tFC_BIN=1\t\t;binary file (BSAVE, binary SAVE)\n\tROFFST\tF_BAKC,1\t;holds next sequential input when F.FLBS.FL.BKC is true\n\tROFFST\tF_NUL3,1\t;not used by basic interpreter\n\tROFFST\tF_DEV,1\t\t;Device number                             (FL.DSK)\n\tROFFST\tF_WID,1\t\t;File width\n\tROFFST\tF_NUL4,1\t;not used by basic interpreter\n\tROFFST\tF_FLGS,1\t;flags\n\tFL_BKC=200O\t\t;when true, F.BAKC contains next sequential input\n\tROFFST\tF_POS,1\t\t;Current column position                   (FL.OPS)\n\tROFFST\tFDBSIZ,0\t;size of device independent part of FDB\n\t\t\t\t;device dependant FDB entries start here\n\n\tROFFST\tDATOFS,DATPSC\t;Operating System interface buffer\n\tROFFST\tFD_SIZ,2\t;variable record length for random files\n\tROFFST\tFD_PHY,2\t;current physical record number\n\tROFFST\tFD_LOG,2\t;current logical record number\n\tROFFST\tF_NUL5,1\t;Future use\n\tROFFST\tFD_OPS,2\t;current output position for sequential I/O\n\tROFFST\tFD_DAT,0\t;field buffer of random file\n\n; OFFSETS INTO MSDOS FCB\n;\n\tFCB_DV=F_FCB+0D\t\t;DRIVE (0=default, 1=A:, 2=B:, ...)\n\tFCB_FN=F_FCB+1D\t\t;FILE NAME\n\tFCB_FT=F_FCB+9D\t\t;EXTENSION\n\tFCB_EX=F_FCB+12D\t;FILE EXTENT (identifies block of 128 logical records)\n\tFCB_RC=F_FCB+14D\t;RECORD SIZE\n\tFCB_FS=F_FCB+16D\t;FILE SIZE IN BYTES\n\tFCB_DT=F_FCB+20D\t;Date of last write to file\n\tFCB_DT=F_FCB+22D\t;Time of last write to file\n\tFCB_NR=F_FCB+32D\t;NEXT RECORD NUMBER\n\tFCB_RN=F_FCB+33D\t;CP/M 2.x Random Record Number\n\n        PAGE\n\u001a"
        },
        {
          "name": "NEXT86.ASM",
          "type": "blob",
          "size": 4.375,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE NEXT86 CODE\r\n\t.SALL\r\n\t.RADIX\t8\r\n;****************************************************************\r\n;\r\n; A \"FOR\" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:\r\n;\r\n; LOW ADDRESS\r\n;       TOKEN ($FOR IN HIGH BYTE)  1 BYTES\r\n;       A POINTER TO THE LOOP VARIABLE  2 BYTES\r\n;       UNDER ANSI & LENGTH=2, TWO BYTES GIVING TEXT POINTER OF  \r\n;       MATCHING \"NEXT\"\r\n;       A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE\r\n;       UNDER LENGTH=2, A BYTE MINUS FOR INTEGER AND \r\n;       POSITIVE FOR FLOATING \"FOR'S\"\r\n;       THE STEP 4 BYTES\r\n;       THE UPPER VALUE 4 BYTES\r\n;       THE LINE # OF THE \"FOR\" STATEMENT 2 BYTES\r\n;       A TEXT POINTER INTO THE \"FOR\" STATEMENT 2 BYTES\r\n; HIGH ADDRESS\r\n;\r\n; TOTAL 16-19 BYTES\r\n;\r\n;*****************************************************************\r\n\r\n\tEXTRN\tCHRGTR:NEAR,DCOMPR:NEAR,FADDS:NEAR,FCOMP:NEAR,FNDFOR:NEAR\r\n\tEXTRN\tIADD:NEAR\r\n\tEXTRN\tICMPA:NEAR,MOVFM:NEAR,MOVMF:NEAR,MOVRM:NEAR,NEWSTT:NEAR\r\n\tEXTRN\tNFERR:NEAR,NXTCON:NEAR,OVERR:NEAR\r\n\tEXTRN\tPTRGET:NEAR\r\n\tPUBLIC\tNEXT\r\n\tPUBLIC\tNEXTS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tNXTFLG:WORD,FVALSV:WORD,NXTTXT:WORD\r\nDSEG\tENDS\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tFACLO:WORD,SAVSTK:WORD,TEMP:WORD,VALTYP:WORD,CURLIN:WORD\r\nDSEG\tENDS\r\n\r\nNF1:\tJMP\tNFERR\r\nNEXT:\r\n\tLAHF\t\t\t;FLAGS TO AH\r\n\tXCHG\tAH,AL\r\n\tPUSH\tAX\r\n\tMOV\tAL,LOW 1\r\n\tJMP\tSHORT NEXTS1\r\nNEXTS:\tXOR\tAL,AL\t\t;FLAG THAT \"FOR IS USING \"NEXT\r\nNEXTS1:\tMOV\tBYTE PTR NXTFLG,AL\r\n\tPOP\tAX\r\n\tXCHG\tAL,AH\r\n\tSAHF\t\r\n\tMOV\tDX,0\r\nNEXTC:\r\n\tMOV\tWORD PTR NXTTXT,BX\t;SAVE STARTING TEXT POINTER\r\n\tJZ\tNEXTC1\r\n\tCALL\tPTRGET\r\nNEXTC1:\tMOV\tWORD PTR TEMP,BX\t;SAVE PTR TO LOOP VARIABLE\r\n\tCALL\tFNDFOR\t\t;TRY TO FING A \"FOR ENTRY\r\n\tJNZ\tNF1\t\t;NEXT W/O FOR ERROR\r\n\tMOV\tSP,BX\t\t;SETUP STACK BY  CHOPPING HERE\r\n\tMOV\tSI,WORD PTR NXTTXT\r\n\tCMP\tWORD PTR 0[BX],SI\t;COMPARE TEXT POINTERS AT THE START\r\n\tJNZ\tNF1\t\t;OF THIS \"NEXT WITH THIS NEXT\r\n\tPUSH\tDX\t\t;PUSH STEP ONTO THE STACK\r\n\tMOV\tAH,BYTE PTR 2[BX]\t;\r\n\tPUSH\tAX\r\n\tPUSH\tDX\t\t;PTR. TO LOOP VAR. ON STACK\r\n\tADD\tBX,4\r\n\tTEST\tBYTE PTR -1[BX],LOW 200O\t;SEE IF INTEGER FOR\r\n\tJS\tINTNXT\t\t;IF INTEGER HANDLE SEPARATELY\r\n\tMOV\tCX,2\t\t;\r\n\tCLD\t\t\t;DF=0 SO MOVW WILL INCREMENT\r\n\tMOV\tSI,BX\r\n\tMOV\tDI,OFFSET FACLO\r\n REP\tMOVSW\t\t\t;GET LOOP VARIABLE\r\n\tPOP\tBX\t\t;PTR TO FOR ENTRY\r\n\tPUSH\tSI\t\t;\r\n\tPUSH\tBX\r\n\tTEST\tBYTE PTR NXTFLG,LOW 377O\r\n\tJNZ\tNXTDO\r\n\tMOV\tSI,OFFSET FVALSV\t;FETCH INITIAL VALUE\r\n\tSUB\tDI,4\t\t;POINT DI BACK TO FACLO\r\n\tMOV\tCX,2\t\t;TWO WORD MOVE\r\n REP\tMOVSW\r\n\tXOR\tAL,AL\t\t;CONTINUE \"NEXT\" WITH INITIAL VALUE\r\n\tJZ\tNXTDOA\t\t;\r\nNXTDO:\tCALL\tFADDS\r\nNXTDOA:\tPOP\tDI\t\t;POP PTR TO LOOP VARIABLE\r\n\tMOV\tSI,OFFSET FACLO\t;WILL MOVE FAC TO THERE\r\n\tMOV\tCX,2\r\n\tCLD\t\r\n REP\tMOVSW\r\n\tPOP\tSI\t\t;GET ENTRY PTR.\r\n\tMOV\tDX,WORD PTR 0[SI]\r\n\tMOV\tCX,WORD PTR 2[SI]\r\n\tADD\tSI,4\r\n\tPUSH\tSI\t\t;SAVE ENTRY PTR.\r\n\tCALL\tFCOMP\t\t;COMPARE THE NOS. RETURNING\r\n\t\t\t\t;377 IF FAC LESS THAN REGS,0 IF =\r\n\t\t\t\t;AND 1 IF GREATER \r\n\tJMP\tSHORT FINNXT\t;SKIP INTEGER CODE\r\nINTNXT:\tADD\tBX,4\t\t;SKIP 4 DUMMY BYTES\r\n\tMOV\tCX,WORD PTR 0[BX]\t;FETCH STEP TO CX\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tPOP\tSI\t\t;PTR TO LOOP VARIABLE\r\n\tMOV\tDX,WORD PTR 0[SI]\r\n\tTEST\tBYTE PTR NXTFLG,LOW 377O\t;SEE IF \"FOR IS USING \"NEXT CODE\r\n\tJNZ\tINXTDO\t\t;NO , JUST CONTINUE\r\n\tMOV\tDX,WORD PTR FVALSV\t;GET THE INITIAL VALUE\r\n\tJMP\tSHORT IFORIN\t;CONTINUE FIRST ITERATION CHECK\r\nINXTDO:\tADD\tDX,CX\r\n\tJO\tOV1\r\nIFORIN:\r\n\tMOV\tWORD PTR 0[SI],DX\r\n\tPUSH\tDX\t\t;SAVE THE VALUE OF THE LOOP VAR.\r\n\tMOV\tDX,WORD PTR 0[BX]\t;\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tPOP\tAX\r\n\tPUSH\tBX\r\n\tCALL\tICMPA\t\t;COMPARE (AX) WITH (DX)\r\nFINNXT:\r\n\tPOP\tBX\t\t;POP \"FOR ENTRY PTR\r\n\tPOP\tCX\t\t;GET SGN OF INCREMENT\r\n\tSUB\tAL,CH\t\t;SUBTRACT THE INCREMENTS SIGN FROM\r\n\t\t\t\t;THAT OF (CURRENT VAL-FINAL VAL)\r\n\tCALL\tMOVRM\t\t;GET LINE # OF \"FOR INTO DX AND\r\n\t\t\t\t;TEXT PTR OF \"FOR INTO CX\r\n\tJZ\tLOOPDN\t\t;JUMP IF DONE\r\n\tMOV\tWORD PTR CURLIN,DX\t;STORE LINE NO.\r\n\tMOV\tDX,CX\t\t;SETUP THE TEXT PTR\r\n\tXCHG\tDX,BX\r\n\tJMP\tNXTCON\r\nLOOPDN:\tMOV\tSP,BX\t\t;ELIMINATE FOR ENTRY & SAVE UPDATED\r\n\tMOV\tWORD PTR SAVSTK,BX\t;STACK\r\n\tMOV\tBX,WORD PTR TEMP\t;RESTORE TEXT PTR\r\n\tCMP\tBYTE PTR 0[BX],LOW 54O\t;COMMA?\r\n\tJNZ\tNS1\t\t;\"NEXT\r\nLOOPD1:\tMOV\tBYTE PTR NXTFLG,LOW 377O\t;Set NXTFLG non-zero since NEXT couldn't\r\n\t\t\t\t;have been called by FOR in this case\r\n\tCALL\tCHRGTR\t\t;Skip comma\r\n\tMOV\tDX,SP\t\t;[DX]=[SP] which will never match\r\n\t\t\t\t;any VARPTR (see FNDFOR)\r\n\tCALL\tNEXTC\t\t;Process Next NEXT\r\nOV1:\tJMP\tOVERR\r\nNS1:\tJMP\tNEWSTT\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "OEM.H",
          "type": "blob",
          "size": 8.0830078125,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\n\n\tSUBTTL  Common file to produce 2-segment 8086 GW-CPM BASIC\n\n\t.SALL\n\n\t.RADIX\t10\n\tOEMRAM=0D\n;Pascal program HFILE searches for the following line - DO NOT MODIFY\n;** (VERSION SPECIFIC VALUES) ************************************************\n\tNMLINE=25\t\t;Max screen display text lines\n\tNBANKS=1\t\t;Number of graphic planes\n\tPALSIZ=0\t\t;Size of OEM color palette\n\tDBLCHR=0\t\t;Editor support for KANJI chars\n\tKANABS=0\t\t;Kana BASIC (Japanese JIS codes)\n\tKANJFN=0\t\t;KANJI String Functions KPOS, KLEN ..\n\tJISKTN=0\t\t;&K, &J constants (KANJI)\n\tSUPRSH=1\t\t;1=super shift key feature\n\tNMKEYF=10\t\t;number of function keys\n\tNMKEYT=14\t\t;number of function key traps\n\tFKEYON=1\t\t;yes=display function keys\n\tSCROLT=1\t\t;Line 25 allocated for status only\n\tPLAYSW=1\t\t;for PLAY statement\n\tBEEPSW=1\t\t;for SOUND, BEEP statements\n\tNMLPT=3\t\t\t;number of line printers\n\tCONSSW=1\t\t;Device CONS:\n\tNMCOMT=2\t\t;number of COMmunications ports\n\tNMPENT=1\t\t;number of light pens\n\tNMSTRT=4\t\t;number of joysticks\n\tGWCASS=0\t\t;Cassette switch (CSAVE,CLOAD,MOTOR)\n\tIBMLIK=1\t\t;IBM compatibility package      \n\tIBMTOK=1\t\t;IBM token compatibility        \n\tDYNCOM=1\t\t;Dynamic communication buffers  \n;** (END OF VERSION SPECIFIC VALUES) *****************************************\n;Pascal program HFILE searches for the previous line - DO NOT MODIFY\n;\n\tNUMTRP=NMKEYT+NMCOMT+NMPENT+NMSTRT\n\tGW=1\t\t\t;GW BASIC\n\tESCCTL=0\t\t;Escape Sequence processing in SCROUT\n\tGWDBUG=0\t\t;DEBUG statement (TEST VERSIONS ONLY)\n\t\t\t\t; Support is in BINTRP.MAC and GWSTS.MAC\n\tSIXDIG=0\t\t;# of digits of accuracy assumed when formatting\n\t\t\t\t;single precision numbers for output.\n\t\t\t\t; 0 := 7 digits\n\t\t\t\t; 1 := 6 digits\n\tCASSW=0\t\t\t;CASSETTE SWITCH\n\tLABKEY=1\t\t;^T (LABEL) key capability\n\tHGHBIT=1\t\t;8-bit characters (ASCII & Graphics)\n\tQUEUE=1\t\t\t;Queued painting algorithm (vs. stack)\n\tGIO86=1\t\t\t;BASIC-86 Generalized I/O\n\tSCRNIO=1\t\t;Screen editor\n\tSCRN86=1\t\t;8086 Screen editor\n\tI8086=1\t\t\t;CROSS ASSEMBLING FOR 8086\n\tMULSEG=1\t\t;MULTI-SEGMENT 8086 BASIC\n\tSHORT=0\t\t\t;\"SMALL\" VERSION OF 8086 BASIC IF SET\n\tTRUROM=1\n\tSBC86=0\t\t\t;SBC 86/02 BOARD?\n\tSHORTJ=1\t\t;USE INTRA-SEGMENT SHORT JUMPS\n\t\t\t\t;IN 8086 CODE\n\tLNGVAR=1\t\t;LONG VARIABLE NAME SUPPORT (EXTENDED ONLY)\n\tSHTERR=0\t\t;SHORT (2 CHAR) ERROR MESSAGES\n\tSHTINS=0\t\t;INSTR IN NON-FAST LEN2 VERSIONS\n\tSHTLHM=0\t\t;LEFT HAND SIDE MID IN NON FAST LEN2 VERSIONS\n\tSHTCHN=0\t\t;ALLOW CHAIN IN NON-5.0\n\tSHTPRO=0\t\t;ALLOW PROTECTED FILES IN NON-FIVDSK\n\tSHTLIN=0\t\t;ALLOW LINE INPUT IN NON-EXTENDED NON-FAST\n\tSHTREN=0\t\t;ALLOW RENUM IN NON-FST VERSIONS\n\tINKEYF=1\t\t;ADDS INKEY$ FUNCTION\n\tNOIOS=0\t\t\t;NO I/O STATMENTS (INP,OUT, WAIT)\n\tNOPEKS=0\t\t;NO PEEK, POKE\n\tNOUSR=0\t\t\t;NO USR\n\tNOCTLA=0\t\t;NO CONTROL-A IN EXTENDED\n\tNORUBT=0\t\t;NO RUBOUT\n\tNOROMP=0\t\t;NO ROM PROGRAM FEATURE\n\tNOATDL=0\t\t;NO AUTO DELETE IN NON-FAST EXTENDED\n\tNODOT=0\t\t\t;NO DOT IN LEN2\n\tNOEDIT=0\t\t;NO EDIT COMMAND\n\tCRONLY=0\t\t;ONLY PUT OUT CR, NOT CRLF TO TERMINAL\n\t\t\t\t;AND FILES\n\tNONULL=0\t\t;NO NULL COMMAND, PUT OUT NULLS IN CRDO & OUTCH1\n\tNOVARP=0\t\t;NO VARPTR FUNCTION\n\tFIVEO=1\t\t\t;GENERATE VERSION WITH RELEASE 5.0 FEATURES\n\tFIVMEM=1\n\tANSI=1\n\tFIVDSK=1\t\t;5.0 NEW DSK CODE\n\tFIVLPT=1\t\t;WIDTH LPRINT AND 255 FEATURE\n\tHEXOCT=1\t\t;&H..., HEX$, &O..., OCT$\n\tBINCSW=0\t\t;&B..., BIN$\n\tBLODSW=1\t\t;BLOAD, BSAVE COMMANDS\n\tMEMIMG=1\t\t;MEMORY IMAGE FILES\n\tGENBIN=1\n\n\tTRUANS=0\t\t;TRUE ANSI VERSION (STATIC SCAN, ON ERROR)\n\tCOMMNT=0\t\t;DONT WANT BIG COMMENT\n\tINTEL=0\t\t\t;INTEL PROPRIETARY\n\tINTFSW=0\t\t;INTEL FLOATING POINT\n\tINTFHW=0\n\tRMX=0\t\t\t;INTEL RMX VERSION\n\tEDIT80=0\t\t;FOR EDIT80 I/O ROUTINES\n\tRSHACK=0\n\tINTLEC=0\n\tLENGTH=2\t\t;  1 MEANS 8K, 2 MEANS 12K\n\tBASDEB=0\t\t;WHETHER DBG WILL BE LOADED WITH BASIC\n\tRSTLES=1\t\t;WHETHER BASIC WILL USE RST LOCATIONS\n\t\t\t\t;TO MAKE ITSELF SMALLER & QUICKER\n\tREALIO=1\t\t;WHETHER SIMULATE (=0) OR ON MACHINE (=1)\n\tGENIO=1\t\t\t;USE G/P ROUTINES\n\tCHSEAT=1\t\t;CHSNS eats chars\n\tGENDSK=0\t\t;USE G/P DSK CODE\n\tLONGI=0\t\t\t;WHETHER WE ASK \"TERMINAL WIDTH?\"\n\t\t\t\t;AND WANT SIN-TAN-COS-ATN?\n\tINSTSW=0\t\t;FOR INSTR INSTRUCTION\n\tSWAPSW=1\t\t;FOR SWAP STATEMENT\n\tMDS=0\t\t\t;FOR INTEL MDS SYSTEMS\n\tSBC=0\t\t\t;FOR INTEL SINGLE BOARD COMPUTER\n\t\t\t\t;1=SBC 80/10, 2=SBC 80/20\n\tPURE=1\t\t\t;ON FOR PURE CODE\n\tKILLER=0\t\t;FOR ROM VERSION THAT WONT RUN IN RAM\n\tINTROM=0\n\tLPTSW=1\n\tNCRLPT=1\n\tNCRCAS=0\n\tISC=0\t\t\t;FOR ISC VERSION\n\tLPT3=0\t\t\t;THREE LPT DRIVER VERSION(QUME,OKIA,CENT)\n\tTSLPT=0\n\n\tDOS=0\t\t\t;ON TO GEN ROUTINES FOR DOS\n\tDISK=1\t\t\t;FILE I/O FEATURES\n\tTIMSHR=0\t\t;NO TIME-SHARING DISK\n\tTSDISK=0\t\t;NO TIME-SHARING DISK FOR US\n\tSPCDSK=0\t\t;MAY HAVE MM'S DISK CODE\n\tSPCNDS=0\n\tFAST=1\t\t\t;CONSTANT COMPRESSION, RENUM & FRIENDS\n\tKEYSTA=0\n\tISIS=0\t\t\t;FOR VERSION TO RUN UNDER INTEL'S ISIS II DOS\n\tMDSISS=0\t\t;FOR MDS VERSION THAT RUNS UNDER ISIS-II\n\tCPM=1\t\t\t;FOR CPM compatible operating systems\n\tCPM2=1\t\t\t;VERSION 2. CPM\n\tCPM86=0\t\t\t;FOR CP/M-86 operating system\n\tSCP=1\t\t\t;MS-DOS operating system\n\tCPMCON=0\n\tCPMSER=0\t\t;CHECK CPM SERIAL #'S\n\tCPMADD=0\t\t;FOR VERSION TO RUN ON ADDS CPM\n\tCPMA75=0\t\t;FOR VERSION TO RUN ON ADDS SYSTEM 75\n\t\t\t\t;CP/M\n\tCPMRSH=0\t\t;FOR RADIO SHACK CPM/M\n\tCPM110=0\t\t;FOR CP/M @1100 HEX (INTERALIA)\n\tCPMSBC=0\t\t;FOR VERSION TO RUN ON SBC CP/M AT 4100H\n\tCPMPER=0\t\t;FOR PERTEC VERSION OF CPM\n\tCPMLIF=0\t\t;LIFEBOAT CP/M AT 4200H\n\tCPMMDS=0\t\t;MOHAWK DATA SYSTEMS CP/M\n\tCPMCON=0\n\tZ80=0\n\tDISK=1\n\tNCRLPT=1\n\tRSTLES=1\n\tDRVPOS=CPMADD\n\tTRNCHR=CPMADD\n\tINLADD=CPMADD\n\tLISTEN=1\t\t;ON MEANS LISTEN FOR ^C\n\tLISTEN=1\n\tLEN2=0\n\tLEN2=1\n\tHEXOCT=1\n\tLENGTH=2\n\tRSTLES=1\n\tFIVLPT=1\n\tI8251=0\t\t\t;THIS SWITCH IS USED FOR ROSEMOUNT VERSION\n\tCONTRO=1\t\t;ALLOW ^O\n\tLEN3=LEN2 OR CASSW\n\n\n\n\tSTRING=1\n\tNCRLPT=1\n\n; *** OEM Switches which need to be defaulted to 0\n;\n\tCMPUTN=0\n\tDUPONT=0\n\tEXIDY=0\n\tGESBC=0\n\tHEATH=0\n\tLOKHED=0\n\tMOSTEK=0\n\tTEK=0\n\tTRSER2=0\n\tNASCOM=0\n\tNATROM=0\n\tNCRBAS=0\n\tNCRDEB=0\n\tNCRDEB=0\n\tNCRELS=0\n\tONTEL=0\n\tPCS=0\n\tSGSATS=0\n\tALTAIR=0\n\tDMC=0\n\tPANBAS=0\n\tXTNSYS=0\n\tNECBAS=0\n;*******************************************************************\n; Z80 related macros\n;*******************************************************************\n\tZ80=1\t\t\t;FOR VERSION THAT RUNS ON BOTH\n\t\t\t\t;8080'S AND ZILOG Z-80'S\n\tZ80MAC=1\t\t;USE 8080 MACROS INSTEAD OF Z80 INSTRUCTIONS\n\tZ80=0\n\tZ80=1\nLDIR\tMACRO\t\n\tMOV\tWORD PTR A,WORD PTR M\n\tSTAX\tD\n\tINXF\tH\n\tINXF\tD\n\tDCXF\tB\n\tMOV\tWORD PTR A,WORD PTR B\n\tORA\tC\n\tJNZ\t_-8D\nENDM \nLDDR\tMACRO\t\n\tMOV\tWORD PTR A,WORD PTR M\n\tSTAX\tD\n\tDCXF\tH\n\tDCXF\tD\n\tDCXF\tB\n\tMOV\tWORD PTR A,WORD PTR B\n\tORA\tC\n\tJNZ\t_-8D\nENDM \nDJNZ\tMACRO\t    DEST\n\tDCR\tB\n\tJNZ\tDEST\nENDM \n;*******************************************************************\n; Define reset routines.\n;*******************************************************************\nFSIGN\tMACRO\t\n\tCALL\tSIGN\nENDM \nPUSHM\tMACRO\t\n\tMOV\tWORD PTR C,WORD PTR M\n\tINX\tH\n\tMOV\tWORD PTR B,WORD PTR M\n\tINX\tH\n\tPUSH\tWORD PTR B\nENDM \nSYNCHK\tMACRO\tX\n\tCALL\tSYNCHR\n\tDB\tOFFSET X\nENDM \nOUTCHR\tMACRO\t\n\tCALL\tOUTDO\nENDM \nCHRGET\tMACRO\t\n\tCALL\tCHRGTR\nENDM \nCOMPAR\tMACRO\t\n\tCALL\tDCOMPR\nENDM \nGETYPE\tMACRO\t\n\tCALL\tGETYPR\nENDM \nCOMPAR\tMACRO\t\n\tDB\t73O\n\tDB\t332O\n ENDM \nACRLF\tMACRO\t\n\tDB\t13D\n\tDB\t10D\nENDM \nPUSHR\tMACRO\t\n\tPUSH\tWORD PTR D\n\tPUSH\tWORD PTR B\nENDM \nPOPR\tMACRO\t\n\tPOP\tWORD PTR B\n\tPOP\tWORD PTR D\nENDM \nMOVRI\tMACRO\tB,C,D,E\n\tDB\t1O\t\t; \"LXI  B\"\n\tDB\tOFFSET C\n\tDB\tOFFSET B\n\tDB\t21O\t\t; \"LXI  D\"\n\tDB\tOFFSET E\n\tDB\tOFFSET D\nENDM \nINST\tMACRO\tX\n\tDB\tOX\nENDM \n\n\n\tCONTO=15\t\t;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)\n\tDBLTRN=0\t\t;FOR DOUBLE PRECISION TRANSCENDENTALS\n\n\tCLMWID=14D\t\t;MAKE COMMA COLUMNS FOURTEEN CHARACTERS\n\tDATPSC=128D\t\t;NUMBER OF DATA BYTES IN DISK SECTOR\n\tLINLN=80D\t\t;TERMINAL LINE LENGTH\n\tLPTLEN=132D\n\tBUFLEN=255\t\t;LONG LINES\n\tNAMLEN=40D\t\t;MAXIMUM LENGTH NAME -- 3 TO 127\n\n\tNUMLEV=110D\t\t;NUMBER OF STACK LEVELS RESERVED\n\t\t\t\t;BY AN EXPLICIT CALL TO GETSTK\n\tSTRSIZ=4\n\tSTRSIZ=3\n\tNUMTMP=3\t\t;NUMBER OF STRING TEMPORARIES\n\tNUMTMP=10\n\n\t.RADIX\t8\n;\n; Useful macros\n;\n\nACRLF   MACRO\n        DB      13D\n        DB      10D\nENDM\n\nINS86   MACRO   A,B,C,D\n        DB      A&O\nIFNB    <B>\n        DB      B&O\nENDIF\nIFNB    <D>\n        DB      C&O\n        DB      D&O\nENDIF\nIFB     <D>\n IFNB   <C>\n        DW      C\n  ENDIF\n ENDIF\nENDM\n\nCALLOS  MACRO\n        CALL    CPMENT\nENDM\n\nPOPR    MACRO\n        POP     CX\n        POP     DX\nENDM\n\nADR     MACRO   X\n        DW      X\nENDM\n\nDC      MACRO   ARG\n        IRPC    ZZ,<ARG>\n            IFDIF       <ZZ>,<\">\n                DB      \"&ZZ&\"\n                _A=\"&ZZ&\"\n            ENDIF\n        ENDM\nENDM\n;\n        PAGE\n\u001a"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.6279296875,
          "content": "# Microsoft GW-BASIC Interpreter Source Code\r\n\r\nThis repo contains the original source-code for Microsoft's GW-BASIC interpreter, as of 1983.\r\n\r\n## Announcement blog\r\nhttps://devblogs.microsoft.com/commandline/microsoft-open-sources-gw-basic/\r\n\r\n## Information\r\n\r\nThis repo:\r\n\r\n1. Is being released for historical reference/interest purposes, and reflects the state of the GW-BASIC interpreter source code as it was in 1983\r\n1. Will not be modified - please do not submit PR's or request changes\r\n1. Contains no build scripts, makefiles, or tools required to generate executable binaries, nor does it contain any pre-built binaries / executables\r\n\r\n## License\r\n\r\nAll files within this repo are released under the [MIT (OSI) License]( https://en.wikipedia.org/wiki/MIT_License) as per the [LICENSE file](https://github.com/Microsoft/GW-BASIC/blob/master/LICENSE) stored in the root of this repo.\r\n\r\n## Contributing\r\n\r\nThe source files in this repo are for historical reference and will remain read-only and unmodified in their original state. Please  **do not** send Pull Requests suggesting any modifications to the source files.  \r\n\r\nFurther contribution guidance can be found in the [Contributor's Guide](https://github.com/Microsoft/GW-BASIC/blob/master/CONTRIBUTING.md) stored in the root of this repo.\r\n\r\n## Code of Conduct\r\n\r\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).  For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.\r\n"
        },
        {
          "name": "SCNDRV.ASM",
          "type": "blob",
          "size": 75.25,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   SCNDRV  This is the OS independent Screen Driver for GW BASIC\r\n\tSUBTTL  DATA DEFINITIONS - Miscellaneous\r\n\r\nCOMMENT\t*\r\n\t--------- --- ---- -- ---------\r\n\tCOPYRIGHT (C) 1982 BY MICROSOFT\r\n\t--------- --- ---- -- ---------\r\n\r\n\tPROGRAMMER: MARC WILSON\r\n\r\n\t*\r\n\tINCLUDE\tGIO86U\r\n\t.SALL\r\n\t.RADIX\t8\r\n\r\n;OEM IFNDEFs\r\nMELCO=0\r\nCANON=0\r\n\r\n;GENERIC IFNDEF'S:\r\nTERMSW=0\r\nHLPEDT=0\r\nNMPAGE=1\t\t\t;Number of pages\r\nNEWCHP=1\t\t\t;New change page routine\r\nIBMEOL=IBMLIK\t\t\t;Clear to EOL for COMPATIBILITY\r\nIBMCSR=IBMLIK\t\t\t;IBM COMPATIBILITY for cursor\r\n\r\n;Definition of scroll types\r\n; Choice of scroll type is by switch SCROLT.\r\n; Switches defined here are used to implement a specific SCROLT type.\r\n; If other scroll types are needed then additional SCROLT types should be\r\n;   defined here.\r\n\tINVLIN=SCROLT\t\t;Invisible (function key) Line\r\n\tFKFSRL=(SCROLT-1) AND 1\t;Clear fkeys/full scroll/rewrite fkeys\r\n\r\n\r\n;OTHER GENERIC SWITCHES(OEM SPECIFIC)\r\n\tTXTWDO=0\t\t;list of OEM's which have window setting capability\r\n\r\n\tSUBTTL  DATA DEFINITIONS - Internal routines(with usage description)\r\n\r\n\r\n;Entry points\r\n\tPUBLIC\tSCNSWI\t\t; Set CRT physical line width\r\n\t\t\t\t;on entry:  AL=width, CL=height\r\n\r\n\tPUBLIC\tSCNCLR\t\t; Clear CRT, Refresh Function Key Display,\r\n\t\t\t\t; Home Graphics and Text Cursors\r\n\t\t\t\t;on entry:  none\r\n\r\n\tPUBLIC\tSCNLOC\t\t; Locate cursor on physical screen(1,1 = HOME)\r\n\t\t\t\t;on entry:  AH=column(x), AL=line(y)\r\n\r\n\tPUBLIC\tSCNOUT\t\t; Character output at current position\r\n\t\t\t\t;on entry:  AX=character\r\n\r\n\tPUBLIC\tSCNRDL\t\t; Read a physical line at current position\r\n\t\t\t\t;on entry:  DI=address of where to put string, CX=max count\r\n\t\t\t\t;on exit:   CX=CX-number of characters read\r\n\t\t\t\t;           DI=DI+number of characters read\r\n\r\n\r\n\tPUBLIC\tSCNPOS\t\t; Return current cursor location\r\n\t\t\t\t;on exit:   DL=cursor line, DH=cursor column\r\n\r\n\tPUBLIC\tSCNRDT\t\t; Read terminator for physical line\r\n\t\t\t\t;on entry:  DL=line number\r\n\t\t\t\t;on exit:   AH= terminator column, AL=terminator value\r\n\t\t\t\t;           Flags indicate terminator value:\r\n\t\t\t\t;           CF=EOL, ZF=Linefeed\r\n\r\n\tPUBLIC\tSCNGWI\t\t; Read logical width of lines\r\n\t\t\t\t;on exit:   AH=logical width of lines\r\n\r\n\tPUBLIC\tSCNMRK\t\t; Mark position as current FSTPOS, LSTPOS\r\n\t\t\t\t;on entry:  ZF set indicates use WDOLFT as column\r\n\t\t\t\t;           ZF clear indicates use CSRX as column\r\n\r\n\tPUBLIC\tSCNIPL\t\t; Initialize - called during IPL\r\n\r\n\tPUBLIC\tSCNBRK\t\t; Initialize - called when BREAK received by POLKEY\r\n\tSUBTTL  DATA DEFINITIONS - External routines and data\r\n\r\n\r\n\r\n;EXTERNAL ROUTINES\r\n\tEXTRN\tSCROLL:NEAR\t; OEM supplied SCROLL routine\r\n\tEXTRN\tSCROUT:NEAR\t; OEM supplied character output\r\n\tEXTRN\tSCRINP:NEAR\t; OEM supplied screen input(read character)\r\n\tEXTRN\tCLREOL:NEAR\t; OEM supplied screen clear to end of line\r\n\r\n;THE FOLLOWING IS DATA UNIQUE TO THE SCNDRV MODULE\r\n;       ALL DATA IS ONE BYTE LONG UNLESS STATED OTHERWISE\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tLINCNT:WORD\t; Number of lines\r\n\tEXTRN\tCRTWID:WORD\t; Characters per line\r\n\tEXTRN\tWDOTOP:WORD\t; Top line in window(1-[LINCNT])\r\n\tEXTRN\tWDOBOT:WORD\t; Bottom line in window([WDOTOP]-[LINCNT])\r\n\tEXTRN\tWDOLFT:WORD\t; Leftmost column in window(1-[CRTWID])\r\n\tEXTRN\tWDORGT:WORD\t; Rightmost column plus one([WDOLFT]-[LINCNT])\r\n\tEXTRN\tLINLEN:WORD\t; Line max width(1 to CRTWID)\r\n\tEXTRN\tLINTTB:WORD\t; Line terminator table((# lines * 2) bytes long)\r\n\t\t\t\t; Two items per entry:\r\n\t\t\t\t;   Terminator, last column\r\n\tEXTRN\tTRMCUR:WORD\t; Address of current terminator entry(2 bytes)\r\n\tEXTRN\tFSTLIN:WORD\t; Line number saved by SCNSTM call\r\n\tEXTRN\tFSTCOL:WORD\t; Column saved as above and decreases to WDOLFT\r\n\tEXTRN\tLSTLIN:WORD\t; Line number saved by SCNSTM and grows as the\r\n\t\t\t\t;   logical line grows.\r\n\tEXTRN\tLSTCOL:WORD\t; Column saved as above which grows as the logical\r\n\t\t\t\t;   line grows(always reflects last col on LSTLIN).\r\n\tEXTRN\tF_CRET:WORD\t; Zero indicates last character output was CR\r\n\tEXTRN\tCSRY:WORD\t; Current line(1-[LINCNT])\r\n\tEXTRN\tCSRX:WORD\t; Current column(1-[CRTWID])\r\n\tEXTRN\tKEYSW:WORD\t; ^O377=Function Keys displayed on bottom line\r\n\r\n;THE FOLLOWING DATA IS ACCESSED BY SCNDRV BUT SET ELSEWHERE\r\n\tEXTRN\tF_EDIT:WORD\t; Set to non-zero by INLIN when editing\r\n\tEXTRN\tF_INST:WORD\t; Set to non-zero by INLIN for insert mode\r\nDSEG\tENDS\r\n\tSUBTTL  DATA DEFINITIONS - Literals\r\n\r\n\r\n\r\n;CHARACTER DEFINITIONS\r\n;\r\n\tCHREDT=1\t\t; EDiT\r\n\tCHRBKW=2\t\t; BacK Word\r\n\tCHRCAN=3\t\t; CANcel\r\n\tCHRHCN=4\t\t; Hard CaNcel\r\n\tCHRCLE=5\t\t; CLear to End of line\r\n\tCHRFDW=6\t\t; ForwarD Word\r\n\tCHRBEL=7\t\t; BELl\r\n\tCHRBAK=8D\t\t; BAcKspace\r\n\tCHRTAB=9D\t\t; TAB\r\n\tCHRLNF=10D\t\t; LiNeFeed\r\n\tCHRHOM=11D\t\t; HOMe\r\n\tCHRERA=12D\t\t; ERAse\r\n\tCHRRET=13D\t\t; RETurn\r\n\tCHRAPP=14D\t\t; APPend\r\n\tCHRINS=18D\t\t; INSert\r\n\tCHRFKD=20D\t\t; Function Key Display key\r\n\tCHRLDL=21D\t\t; Line DeLete\r\n\tCHRADV=28D\t\t; cursor RiGhT\r\n\tCHRREG=29D\t\t; cursor LeFT\r\n\tCHRUP=30D\t\t; cursor UP\r\n\tCHRDWN=31D\t\t; cursor DoWN\r\n\tCHRDEL=127D\t\t; DELete\r\n\r\n;TERMINATOR TABLE LITERALS\r\nPUBLIC\tTRMLNF\r\n\tTRMLNF=10D\t\t; LINEFEED terminator\r\nPUBLIC\tTRMEOL\r\n\tTRMEOL=177O\t\t; EOL terminator\r\nPUBLIC\tTRMWRP\r\n\tTRMWRP=0\t\t; WRAP terminator\r\nPUBLIC\tTRMNWP\r\n\tTRMNWP=1\t\t; NULL WRAP terminator\r\nPUBLIC\tTRMNUL\r\n\tTRMNUL=200O\t\t; Sign bit indicates initialize line\r\n\r\n;DEFAULT SCREEN SIZE\r\nPUBLIC\tSCNSIZ\r\n\tSCNSIZ=20D+(40D*400O)\t; Height = 20, Width = 40\r\n\r\n\tSUBTTL  SCNIPL, SCNSWI AND SCNWDO   The parameter setting routines\r\n\r\n\r\n\r\n;SUBROUTINE SCNIPL():           ; Initialize\r\n;**\r\nSCNIPL:\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tESCFLG:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR ESCFLG,LOW 0\r\n\tRET\t\r\n;** END SUBROUTINE SCNIPL\r\n\r\n;BREAK - reset flags etc. when ^C typed.\r\n;\r\nSCNBRK:\tMOV\tBYTE PTR FSTLIN,LOW 0\r\n\tMOV\tBYTE PTR LSTLIN,LOW 377O\t; Set FSTPOS, LSTPOS to impossible values\r\n\tMOV\tBYTE PTR F_CRET,LOW 377O\t; Clear \"last char was CR\" flag\r\n\tRET\t\r\n\r\n;SUBROUTINE SCNSWI(WIDTH,HEIGHT):       ; Set screen width(logical/physical) and height\r\n;**                     on entry:   AL=width, CL=height\r\n;**\r\nSCNSWI:\tMOV\tBYTE PTR CRTWID,AL\t; Save physical width\r\n\tMOV\tBYTE PTR LINLEN,AL\t; Set logical line length\r\n\tMOV\tBYTE PTR LINCNT,CL\t; Save physical height\r\n\tMOV\tBYTE PTR WDOTOP,LOW 1\t; Init window top\r\n\tPUSH\tCX\r\n\tDEC\tCL\t\t; Reserve status line\r\n\tMOV\tBYTE PTR WDOBOT,CL\t; Set window bottom\r\n\tPOP\tCX\r\n\tMOV\tBYTE PTR WDOLFT,LOW 1\t; Set window left\r\n\tMOV\tBYTE PTR WDORGT,AL\t; Set window right\r\n\tRET\t\r\n;** *** END\r\n;** END SUBROUTINE SCNSWI\r\n\r\n\r\n;SUBROUTINE SCNWDO(POSN,COUNT): ; Set text window\r\n;**\r\n;**                             on entry:   AH=column posn, AL=line posn\r\n;**                                         CH=width, CL=height\r\n;**                             on exit:    AX,CX=values actually set\r\n;**                                         CF indicates posn outside screen\r\n;**\r\n;**                             NOTE: This routine truncates width and height.\r\n;**\r\n;** IF POSN IS CONTAINED WITHIN PHYSICAL SCREEN BEGIN\r\n\tSUBTTL CURSOR READ/WRITE\r\n\r\n\r\n\r\n;SUBROUTINE SCNLOC(X,Y):        ; Locate cursor on physical screen\r\n;**                         on entry:   AH=column, AL=line(1,1 is home)\r\n;**\r\nSCNLOC:\tMOV\tBYTE PTR CSRX,AH\r\n\tMOV\tBYTE PTR CSRY,AL\r\n\tRET\t\r\n;** END SUBROUTINE SCNLOC\r\n\r\n;SUBROUTINE SCNCLR(X,Y):        ; Clear Screen, Home Text & Graphics Cursor,\r\n;                               ; Refresh Function Key Display\r\n;**                         on entry:\r\n;\r\n\tEXTRN\tKEYDSP:NEAR,GRPINI:NEAR\r\nSCNCLR:\r\n\tCALL\tTTBINI\t\t;Clear the terminator table\r\n\tCALL\tGRPINI\t\t;Home the graphics cursor\r\n\tCALL\tWHOME\t\t;DX=cursor home\r\n\tMOV\tAX,DX\r\n\tCALL\tSCNLOC\t\t;set cursor position\r\n\tJMP\tKEYDSP\t\t;Conditionally display softkeys and return\r\n;** END SUBROUTINE SCNCLR\r\n\r\n;SUBROUTINE SCNPOS              ; Read current cursor location\r\nSCNPOS:\tMOV\tDH,BYTE PTR CSRX\r\n\tMOV\tDL,BYTE PTR CSRY\r\n\tPUSHF\t\r\n\tCMP\tDH,BYTE PTR LINLEN\r\n\tJBE\tSCNPS1\t\t;BRIF not beyond edge of screen\r\n\tMOV\tDH,BYTE PTR LINLEN\t;Force posn within screen\r\nSCNPS1:\tPOPF\t\r\n\tRET\t\r\n;** END SUBROUTINE SCNPOS\r\n\r\n;SUBROUTINE SCNGWI              ; Read current logical width\r\n;**                         on exit:    AH=width\r\n;**\r\nSCNGWI:\tMOV\tAH,BYTE PTR LINLEN\r\n\tRET\t\r\n;** END SUBROUTINE SCNGWI\r\n\tSUBTTL  TERMINATOR TABLE READ/WRITE/INITIALIZE\r\n\r\n\r\n;SUBROUTINE SCNRDT(Y):          ; Read terminator value and column\r\n;**                         on entry:   DL=line number\r\n;**                         on exit:    AH=terminator posn, AL=terminator value\r\n;**                                     If CF=1; EOL\r\n;**                                     If CF=0 and ZF=1; LF terminated\r\n;**\r\nSCNRDT:\tPUSH\tBX\r\n\tMOV\tBL,DL\t\t; BX = Displacement into table\r\n\tADD\tBL,BL\r\n\tMOV\tBH,LOW 0\r\n\tMOV\tWORD PTR TRMCUR,BX\t; Save address of terminator reading(for set term)\r\n\tMOV\tAH,BYTE PTR LINTTB-2[BX]\t; Get terminator posn\r\n\tMOV\tAL,BYTE PTR LINTTB-1[BX]\t; Get terminator value\r\n\tAND\tAL,LOW OFFSET 377O-TRMNUL\t; Get rid of initialize line status bit\r\n\tCMP\tAL,LOW OFFSET TRMEOL\r\n\tSTC\t\r\n\tJZ\tSCNRTX\t\t; BRIF EOL terminator(CF=1)\r\n\tCMP\tAL,LOW OFFSET TRMLNF\t; CF=0, set ZF if linefeed terminated\r\n\tJNB\tSCNRTX\t\t; BRIF carry not set\r\n\tCMC\t\t\t; clear carry\r\nSCNRTX:\tPOP\tBX\r\n\tRET\t\r\n;** END SUBROUTINE SCNRDT\r\n\r\n\r\n;SUBROUTINE SCNWTT(TERM)        ; Set new value for terminator last read\r\n;**                     on entry:   AH=column where physical line ends\r\n;**                                 AL=terminator type(one of: TRMEOL, TRMLNF\r\n;**                                     TRMWRP, TRMNWP)\r\n;**\r\nSCNWTT:\tPUSH\tBX\r\n\tMOV\tBX,WORD PTR TRMCUR\t; Get address of terminator last read\r\n\tMOV\tBYTE PTR LINTTB-2[BX],AH\r\n\tAND\tBYTE PTR LINTTB-1[BX],LOW OFFSET TRMNUL\r\n\tOR\tBYTE PTR LINTTB-1[BX],AL\t; Write new terminator, leaving NULL bit\r\n\tPOP\tBX\r\n\tRET\t\r\n;** END SUBROUTINE SCNWTT\r\n\r\n;TERMINATOR TABLE INIT\r\n;\r\nTTBINI:\tMOV\tCX,OFFSET NMLINE+1\t; CX=count of line term table entries\r\n\tMOV\tBX,OFFSET LINTTB\t; BX=addr of line term table\r\nTTBIN0:\tMOV\tBYTE PTR 0[BX],LOW 0\t; Clear column number\r\n\tMOV\tBYTE PTR 1[BX],LOW OFFSET TRMEOL\t; Set terminator to <CR>\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tLOOP\tTTBIN0\t\t; Init entire line terminator table\r\n\tRET\t\r\n\tSUBTTL  CHARACTER OUTPUT\r\n\r\n\r\n\r\n;SUBROUTINE SCNOUT(CHAR):       ; Output character\r\n;**                         on entry:   AX= character\r\n;**\r\n\r\nSCNOUT:\tPUSH\tDX\r\n\tPUSH\tCX\r\n\tPUSH\tBX\r\n\tCALL\tCTLDSP\t\t; If control char or ESC sequence, do operation\r\n\tJB\tSCNOTX\t\t; No char to output\r\n\tCALL\tCHWRAP\t\t; Do wrap for char in AX, return DX=posn for output\r\n\tEXTRN\tSETCSR:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCSRTYP:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR CSRTYP,LOW 0D\t; Set next cursor type to off\r\n\tCALL\tSETCSR\t\t; Insure that the cursor is off\r\n\r\n\tCALL\tSCROUT\t\t; Send char in AX to BIOS at DX posn\r\n\tMOV\tBYTE PTR F_CRET,LOW 377O\t; Clear last char was Carriage return flag\r\nSCNOTX:\tPOP\tBX\r\n\tPOP\tCX\r\n\tPOP\tDX\r\n\tRET\t\r\n;** END SUBROUTINE SCNOUT\r\n\r\n;SUBROUTINE MKRMCI              ; Open up sapce for char if insert mode\r\n;\r\nMKRMCI:\tPUSHF\t\r\n\tTEST\tBYTE PTR F_INST,LOW 377O\r\n\tJZ\tMKRCIX\t\t; BRIF not insert mode(do nothing)\r\n\tPOPF\t\r\n\tMOV\tCH,AL\r\n\tINC\tCH\t\t; CH=space needed\r\n\tCALL\tMKRMCH\t\t; Open up space at (DH,DL) for count of CH\r\n\tCALL\tSCNRDX\t\t; Put terminator table values in CX\r\n\tRET\t\r\nMKRCIX:\tPOPF\t\r\n\tRET\t\r\n\r\nSCNRDX:\tXCHG\tAX,CX\r\n\tCALL\tSCNRDT\r\n\tXCHG\tAX,CX\r\n\tRET\t\r\n\tSUBTTL  LINE WRAP LOGIC - Character wrap\r\n\r\n\r\n\r\n;THE LINE WRAP LOGIC IS USED PRIOR TO OUTPUTTING CHARACTERS OR STRINGS\r\n;   IT WILL RESERVE THE NECESSARY NUMBER OF CHARACTERS ON THE CURRENT\r\n;   LOGICAL LINE OR WILL RETURN CARRY SET AND DX=POSN WHERE CHARACTER\r\n;   CAN BE OUTPUT(I.E. IT RETURNS A POSN LESS THAN CURRENT POSN)\r\n\r\n;SUBROUTINE CHWRAP(CHAR):       ; Do single character wrap\r\n;**                     on entry:   AX=character\r\n;**                                 DH=CSRX, DL=CSRY\r\n;**                     on exit:    if cannot wrap, CF=1\r\n;**                                 DX=posn where character can be output\r\n;**                                 cursor posn and terminator table are updated\r\n;**                     NOTE: if CF=1 then DX may be set to a previous posn\r\n;**                         where there is enough room to EOL.\r\n;**\r\nCHWRAP:\tPUSH\tAX\r\n\tXOR\tCH,CH\r\n\tOR\tAH,AH\r\n\tJZ\tCHWRP0\t\t; BRIF Single byte character\r\n\tMOV\tCH,LOW 1\t; It's two byte character\r\nCHWRP0:\tMOV\tCL,CH\r\n\tADD\tCH,DH\t\t; CH=column after char is output\r\n\tCALL\tSCNRDT\t\t; Read terminator\r\n\tXCHG\tCX,AX\r\n;** IF POSN .LT. EOL BEGIN\r\n;** AT THIS POINT AH=POSN(WHERE GOING TO), DX=CURRENT POSN,\r\n;** AL=LENGTH OF CHARACTER, CX=CURRENT TERMINATORS\r\n\tPUSHF\t\r\n\tCMP\tAH,BYTE PTR LINLEN\r\n\tJA\tCHWRP1\t\t; BRIF not space before end of physical line\r\n\tPOPF\t\r\n\tCALL\tMKRMCI\t\t; If insert mode, open up space for character\r\n;** *** IF NOT(LINEFEED .EQ. TERMINATOR(CURRENT_LINE) AND POSN .EQ. LINLEN)\r\n;** *** *** RETURN, OUTPUT IS AT CURRENT POSN\r\n\tJB\tCHWPXI\t\t; EOL terminated, output at current posn\r\n\tJZ\tCHWPLF\t\t; BRIF LF terminated\r\n\tCMP\tCL,LOW OFFSET TRMWRP\r\n\tJZ\tCHWPXI\t\t; BRIF WRAP(always room)\r\n\tCMP\tAH,BYTE PTR LINLEN\r\n\tJB\tCHWPXI\t\t; BRIF NUL_WRAP and not overwriting NULL\r\n\tMOV\tCL,LOW OFFSET TRMWRP\r\nCHWPXI:\tJMP\tCHWRPX\t\t; Overwriting NULL_WRAP, set to WRAP\r\nCHWPLF:\tCMP\tAH,BYTE PTR LINLEN\r\n\tJAE\tCHWPL1\t\t; LF terminated and no room for LF\r\n\tINC\tAH\t\t; Need to terminate at one past posn printing at\r\n\tXCHG\tAX,CX\r\n\tCMP\tAH,CH\r\n\tMOV\tAH,CH\r\n\tJA\tCHWPL0\t\t; BRIF current posn below terinator posn\r\n\tCALL\tSCNWTT\t\t; Terminate line at one more than print posn\r\nCHWPL0:\tCLC\t\r\n\tXCHG\tAX,CX\r\n\tPUSHF\t\r\n\tDEC\tAH\t\t; Restore column actually printing at\r\n\tJMP\tCHWRP9\t\t; Update LSTPOS, FSTPOS, cursor posn, exit\r\n;** *** *** ELSE MOVE LINEFEED TO NEXT LINE\r\nCHWPL1:\tCALL\tWRAPLF\t\t; Move linefeed to next line\r\n\tJB\tCHWRNI\t\t; Error, output at posn-(char length)\r\n\tCLC\t\r\n\tPUSHF\t\r\n\tMOV\tAH,CH\r\n\tJMP\tCHWRP9\t\t; Exit without updating terminator\r\nCHWRNI:\tJMP\tCHWRNO\r\n;** *** END\r\n\r\n;** *** DO CASE TERMINATOR(CURRENT_LINE) OF\r\n;** *** There is not enough room on current line for character\r\nCHWRP1:\tPOPF\t\r\n\tJB\tCHWREL\t\t; BRIF EOL terminated\r\n\tJZ\tCHWRLF\t\t; BRIF LF terminated\r\n;** *** CASE: WRAP; NULL_WRAP; BEGIN\r\n;** *** *** *** SET WRAP TERMINATOR\r\nCHWRWP:\tMOV\tCL,LOW OFFSET TRMWRP\r\n\tMOV\tCH,BYTE PTR LINLEN\r\n\tXCHG\tAX,CX\r\n\tCALL\tSCNWTT\t\t; Set wrap terminator at last column\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tCHWRN0\t\t; BRIF not on last line\r\n\tINC\tBYTE PTR LSTLIN\t; Wrap LSTLIN\r\n\tMOV\tBYTE PTR LSTCOL,LOW 0\t; Force update of LSTCOL at CHWRPZ\r\nCHWRN0:\tINC\tDL\t\t; Next line\r\n\tCALL\tSCNRDT\t\t; Set up for write at new line\r\n\tMOV\tDH,BYTE PTR WDOLFT\t; First column is output posn\r\n\tMOV\tCH,DH\r\n\tADD\tCH,CL\t\t; CH=POSN going to\r\n\tXCHG\tAX,CX\r\n\tCALL\tMKRMCI\t\t; If insert mode, open up space for character\r\n\tCMP\tCL,LOW OFFSET TRMLNF\r\n\tJNZ\tCHWRPX\t\t; BRIF not linefeed terminated\r\n\tXCHG\tAX,CX\t\t; CH=POSN, AX=current terminators\r\n\tINC\tCH\t\t; Need terminator one beyond actual output\r\n\tCMP\tAH,CH\r\n\tMOV\tAH,CH\r\n\tJA\tCHWRN2\t\t; BRIF Current terminator beyond posn for output\r\n\tCALL\tSCNWTT\t\t; Set current terminator to new max posn\r\nCHWRN2:\tDEC\tCH\t\t; Restore POSN going to\r\n\tXCHG\tAX,CX\r\nCHWRPX:\tCLC\t\r\n\tJMP\tSHORT CHWRPZ\t; All done\r\n;** *** *** *** END\r\n;** *** *** END\r\n;** *** CASE: EOL\r\nCHWREL:\tCALL\tMKRMNL\t\t; Make room on next line(make it EOL term'd)\r\n\tJB\tCHWRP3\t\t; If error, make room for char on this line\r\n\tCALL\tSCNRDX\t\t; Reread terminator for this line\r\n\tJMP\tSHORT CHWRWP\t; Wrap to next line\r\n;** *** CASE: LF\r\nCHWRLF:\tXCHG\tAX,CX\r\n\tCALL\tWRAPLF\t\t; First wrap LF to next line\r\n\tMOV\tAL,LOW OFFSET TRMNWP\t; Set to temporary NULL_WRAP at last column\r\n\tMOV\tAH,BYTE PTR LINLEN\r\n\tCALL\tSCNWTT\r\n\tXCHG\tAX,CX\r\n\tJNB\tCHWRWP\t\t; Go do wrap for char\r\n;No room, abort\r\nCHWRP3:\tMOV\tAH,BYTE PTR LINLEN\t; AH=POSN going to\r\nCHWRNO:\tMOV\tDH,AH\r\n\tSUB\tDH,AL\t\t; DH=POSN-(char len)\r\n\tSTC\t\t\t; Error return\r\n;** *** END CASE TERMINATOR(CURRENT_LINE)\r\n\r\n;** EXIT\r\nCHWRPZ:\tPUSHF\t\r\n\tXCHG\tAX,CX\t\t; CH=POSN, AX=current terminators\r\n\tCMP\tAH,CH\r\n\tMOV\tAH,CH\r\n\tJA\tCHWRP9\t\t; BRIF Current terminator beyond posn for output\r\n\tPUSH\tAX\r\n\tCALL\tSCNRDT\r\n\tPOP\tAX\r\n\tCALL\tSCNWTT\t\t; Set current terminator to new max posn\r\nCHWRP9:\tMOV\tBYTE PTR CSRY,DL\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tCHWNTL\t\t; BRIF not on last logical line\r\n\tCMP\tAH,BYTE PTR LSTCOL\r\n\tJB\tCHWNTL\t\t; BRIF not new last position\r\n\tMOV\tBYTE PTR LSTCOL,AH\t; Set new last posn\r\nCHWNTL:\tCMP\tDL,BYTE PTR FSTLIN\r\n\tJNZ\tCHWNTF\t\t; BRIF not on first logical line\r\n\tCMP\tDH,BYTE PTR FSTCOL\r\n\tJAE\tCHWNTF\t\t; BRIF not new first position\r\n\tMOV\tBYTE PTR FSTCOL,DH\r\nCHWNTF:\tINC\tAH\r\n\tMOV\tBYTE PTR CSRX,AH\t; Set new posn(one past last posn printed at)\r\n\tCMP\tBYTE PTR LINLEN,AH\r\n\tJAE\tCHWNTG\t\t; BRIF does not go beyond end of physical line\r\n\tCALL\tSCNRDT\r\n\tJB\tCHWNTG\t\t; BRIF line does not continue\r\n\tINC\tBYTE PTR CSRY\t;   Logical line continues, put cursor at\r\n\tMOV\tAH,BYTE PTR WDOLFT\t;       start of next physical line\r\n\tMOV\tBYTE PTR CSRX,AH\r\nCHWNTG:\tPOPF\t\r\n\tPOP\tAX\r\n\tRET\t\r\n;Wrap linefeed on end of line to next line\r\nWRAPLF:\tPUSH\tWORD PTR TRMCUR\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tMOV\tDH,BYTE PTR LINLEN\r\n\tMOV\tCH,LOW 1\r\n\tCALL\tMKRMCH\t\t; Insert one space before LF\r\n\tPOP\tCX\r\n\tMOV\tCL,DL\r\n\tPOP\tDX\r\n\tXCHG\tCX,DX\r\n\tPOP\tWORD PTR TRMCUR\r\n\tRET\t\r\n\tSUBTTL  LINE WRAP LOGIC - Open next line for wrap\r\n\r\n\r\n\r\n;SUBROUTINE MKRMNL(line)        ; Make the next line a blank, empty line\r\n;**                     on entry:   DL=current line number\r\n;**                     on exit:    DL=current line number(may change from entry)\r\n;**                                 if CF=1 no room available\r\n;**\r\nMKRMNL:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\nMKRMN0:\tCALL\tSCNRDT\r\n\tJB\tMKRMN5\r\n\tCMP\tDL,BYTE PTR WDOBOT\r\n\tJZ\tMKRMN6\r\n\tJB\tMKRMN4\r\n\tMOV\tDL,BYTE PTR WDOBOT\r\n\tJMP\tSHORT MKRMN0\r\nMKRMN4:\tINC\tDL\r\n\tJMP\tSHORT MKRMN0\r\n\r\n;** IF CURRENT_PHYSICAL .LT. WINDOW_BOTTOM\r\nMKRMN5:\tCMP\tDL,BYTE PTR WDOBOT\r\nMKRMN6:\tPOP\tDX\r\n\tPUSH\tDX\t\t; Get back posn to scroll from\r\n\tJZ\tMKRMN7\t\t; BRIF at bottom of window(scroll up)\r\n\tCMC\t\r\n\tJB\tMKRMNZ\t\t; BRIF outside of window\r\n\tCMP\tDL,BYTE PTR WDOTOP\r\n\tJB\tMKRMNZ\t\t; BRIF outside of window\r\n\tTEST\tBYTE PTR F_EDIT,LOW 377O\r\n\tJZ\tMKRMNZ\t\t; BRIF not editing, no need to scroll\r\n\tINC\tDL\t\t; Scroll down starting at next line\r\n;** *** SCROLL DOWN\r\n\tCALL\tSCRLD0\t\t; Scroll down to end of window\r\nMKRMNY:\tCLC\t\t\t; Indicate successful\r\nMKRMNZ:\tPOP\tDX\t\t; Restore current line number\r\n\tJMP\tSHORT MKRMNX\r\n;** *** ELSE IF (FIRST_PHYSICAL(LOGICAL) .NE. WINDOW_TOP) OR NOT(INPUT_EDIT)\r\nMKRMN7:\tTEST\tBYTE PTR F_EDIT,LOW 377O\r\n\tJZ\tMKRMN9\t\t; BRIF not input edit, always allow scroll\r\nMKRMN8:\tCALL\tCSRUP\r\n\tJB\tMKRMNZ\t\t; BRIF logical line starts at top of window(abort)\r\n\tPUSH\tAX\r\n\tCALL\tSCNRDT\r\n\tPOP\tAX\r\n\tJNB\tMKRMN8\t\t; BRIF previous physical part of this logical\r\n;** *** SCROLL UP\r\nMKRMN9:\tPOP\tDX\r\n\tPUSH\tDX\r\n\tCMP\tDL,BYTE PTR WDOBOT\t; Full screen scroll?\r\n\tJAE\tMKRMNF\t\t; BRIF scroll up entire screen\r\n\tCALL\tSCRLUD\t\t; Scroll up from DL to WDOTOP\r\n\tJMP\tSHORT MKRMNU\r\nMKRMNF:\tCALL\tSCRLUP\t\t; Scroll up entire window\r\nMKRMNU:\tPOP\tDX\r\n\tCALL\tCSRUP\t\t; Return line number of original line\r\n\tCLC\t\r\nMKRMNX:\tPOP\tCX\r\n\tPOP\tBX\r\n\tPOP\tAX\r\n\tRET\t\r\n\tSUBTTL  SCROLL ROUTINES - Scroll up and down\r\n\r\n\r\n;Scroll up from DL to WDOTOP\r\nSCRLUD:\tPUSH\tCX\r\n\tMOV\tCL,DL\r\n\tMOV\tDL,BYTE PTR WDOTOP\r\n\tJMP\tSHORT SCRLU1\r\n;SCROLL UP\r\nSCRLUP:\tMOV\tDL,BYTE PTR WDOTOP\t; Top line number\r\n;Scroll up from DL to bottom\r\nSCRLU0:\tPUSH\tCX\r\n\tMOV\tCL,BYTE PTR WDOBOT\r\nSCRLU1:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tDX\r\n\tMOV\tAL,DL\r\n\tMOV\tBL,DL\t\t; From = To = Top line number\r\n\tINC\tAL\t\t; From = To + 1\r\n\tMOV\tBH,BYTE PTR WDOLFT\r\n\tMOV\tAH,BH\t\t; From column = To column = left margin\r\n\tSUB\tCL,BL\t\t; CL = line count\r\n\tJA\tSCRUL1\t\t; BRIF two or more line scroll\r\n\tJB\tSCRUL4\t\t; BRIF TOP > BOTTOM(should never happen)\r\n\tPUSH\tAX\r\n\tMOV\tDL,BL\r\n\tJMP\tSHORT SCRUL3\t; TOP=BOTTOM, just init line\r\nSCRUL1:\tPUSH\tAX\r\n\tMOV\tCH,BYTE PTR CRTWID\t; Scroll entire lines\r\n\tCALL\tSCROLL\t\t; Scroll screen\r\n;If CSRY, FSTLIN, LSTLIN are within scroll, decrement their values\r\n\tADD\tAL,CL\t\t; AL=Last line scrolled + 1\r\n\tDEC\tAL\t\t; AL=Bottom line scrolled\r\n\t\t\t\t; BL=Top line scrolled\r\n\tMOV\tAH,LOW 255D\t; decrement line# variables in scroll window\r\n\tCALL\tTSTSCR\r\n\tMOV\tDL,AL\t\t; DL=bottom line of scroll (initialize it)\r\n;Clear the last line of the scroll\r\nSCRUL3:\tMOV\tDH,BYTE PTR WDOLFT\r\n\tPOP\tAX\r\n\tOR\tCL,CL\r\n\tJE\tSCRUL4\t\t; No scroll(one line init)\r\n\tCALL\tSCRUTT\t\t; Scroll up terminator table\r\nSCRUL4:\tCALL\tPLINIT\t\t; Init physical line from (DL,DH) to (DL,WDORGT)\r\n\tPOP\tDX\r\n\tPOP\tBX\r\n\tPOP\tAX\r\n\tPOP\tCX\r\n\tRET\t\r\n\r\n;TSTSCR is called after Scrolling Up or Down to update Line Number variables\r\n; which may be in the scroll window\r\n; Entry - BL=top line number of scroll window\r\n;         AL=bottom line number of scroll window\r\n;         AH=1 if line# variables are to be incremented, -1 if decremented\r\n;\r\nTSTSCR:\tPUSH\tSI\r\n\tPUSH\tAX\r\n\tMOV\tSI,OFFSET CSRY\r\n\tCALL\tTSTWDO\t\t; Adjust CSRY if its within scroll window\r\n\tMOV\tAH,BYTE PTR WDOTOP\r\n\tCMP\tBYTE PTR 0[SI],AH\r\n\tJB\tTCSRY1\t\t; BRIF CSRY above top of window\r\n\tMOV\tAH,BYTE PTR WDOBOT\r\n\tCMP\tBYTE PTR 0[SI],AH\r\n\tJNA\tCSRYOK\t\t; BRIF CSRY didn't increment beyond bottom\r\nTCSRY1:\tMOV\tBYTE PTR 0[SI],AH\t; Bring it back to within scroll window\r\nCSRYOK:\tMOV\tSI,OFFSET FSTLIN\r\n\tPOP\tAX\r\n\tCALL\tTSTWDO\t\t; Adjust FSTLIN if its within scroll window\r\n\tMOV\tSI,OFFSET LSTLIN\r\n\tCALL\tTSTWDO\t\t; Adjust LSTLIN if its within scroll window\r\n\tPOP\tSI\r\n\tRET\t\r\n\r\n; If BL .LEQ. [SI] .LEQ. AL then [SI]=[SI]+AH\r\n;\r\nTSTWDO:\r\n\tCMP\tAL,BYTE PTR 0[SI]\r\n\tJB\tNINWDO\t\t; BRIF [SI] not within scroll\r\n\tCMP\tBL,BYTE PTR 0[SI]\r\n\tJA\tNINWDO\t\t; BRIF [SI] not within scroll\r\n\tADD\tBYTE PTR 0[SI],AH\t; Adjust [SI] for scroll\r\nNINWDO:\tRET\t\r\n\r\n\r\n\r\n;SCROLL DOWN\r\nSCRLDN:\tMOV\tDL,BYTE PTR WDOTOP\r\n;Scroll down from DL to WDOBOT\r\nSCRLD0:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tMOV\tAL,DL\r\n\tMOV\tBL,DL\t\t; From = To = top of scroll\r\n\tINC\tBL\t\t; To = From + 1\r\n\tMOV\tBH,BYTE PTR WDOLFT\t; Column = left margin\r\n\tMOV\tAH,BH\r\n\tMOV\tCL,BYTE PTR WDOBOT\r\n\tSUB\tCL,AL\t\t; Count of lines =(window bottom)-top of scroll\r\n\tPUSH\tAX\r\n\tJBE\tSCRDL3\t\t; BRIF null scroll, just clear line\r\n\tMOV\tCH,BYTE PTR WDORGT\t; Scroll lines, not columns\r\nSCRLD1:\tCALL\tSCROLL\t\t; Scroll screen\r\n;If CSRY, FSTLIN, LSTLIN are within scroll, increment their values\r\n\tADD\tAL,CL\t\t; AL=Last line scrolled\r\n\tDEC\tAL\r\n\tMOV\tAH,LOW 1\t; increment line# variables in scroll window\r\n\tCALL\tTSTSCR\r\n;Clear the last line of the scroll(in DL)\r\nSCRDL3:\tMOV\tDH,BYTE PTR WDOLFT\r\n\tPOP\tAX\r\n\tOR\tCL,CL\r\n\tJS\tSCRDL4\t\t; No scroll(out of window)\r\n\tJE\tSCRDL4\t\t; No scroll(one line init)\r\n\tCALL\tSCRDTT\t\t; Scroll down term table(mark last line init'd)\r\nSCRDL4:\tCALL\tPLINIT\t\t; Init physical line from (DL,DH) to (DL,WDORGT)\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\n;SCROLL DOWN current line to next line\r\nSCRDLN:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tMOV\tAX,DX\t\t; Start of scroll is current line\r\n\tMOV\tAH,BYTE PTR WDOLFT\r\n\tMOV\tBX,AX\r\n\tINC\tBL\t\t; TO start is next line\r\n\tMOV\tCH,BYTE PTR WDORGT\r\n\tMOV\tCL,LOW 1\t; Scroll one entir line\r\n\tPUSH\tAX\r\n\tJMP\tSHORT SCRLD1\t; Do scroll and update LSTPOS, FSTPOS, CSRY\r\n\tSUBTTL  SCROLL ROUTINES - Support routines: scroll terminator table, line init\r\n\r\n\r\n\r\n;Scroll up terminator table(same parameters as SCROLL)\r\n;                   on entry:   (see SCROLL)\r\n;                   on exit:    modifies AX, BX, CX\r\n;\r\nSCRUTT:\tPUSH\tDX\r\n\tMOV\tDL,BL\r\n\tCALL\tSCNRDT\t\t; TRMCUR=address of top of scroll\r\n\tMOV\tBX,WORD PTR TRMCUR\r\n\tMOV\tCH,LOW 0\r\nSCRUTL:\tMOV\tAX,WORD PTR LINTTB[BX]\t; Get a terminator\r\n\tMOV\tWORD PTR LINTTB-2[BX],AX\t; Save a terminator\r\n\tINC\tBX\r\n\tINC\tBX\r\n\tLOOP\tSCRUTL\t\t; Continue till done\r\n\tMOV\tBYTE PTR LINTTB-2[BX],LOW 0\t; Terminate end line of scroll\r\n\tMOV\tBYTE PTR LINTTB-1[BX],LOW OFFSET TRMEOL\r\n\tPOP\tDX\r\n\tRET\t\r\n\r\n;Scroll down terminator table(same parameters as SCROLL)\r\n;                   on entry:   (see SCROLL)\r\n;                   on exit:    modifies AX, BX, CX\r\n;\r\nSCRDTT:\r\n\tPUSH\tDX\r\n\tMOV\tDL,AL\r\n\tADD\tDL,CL\r\n\tCALL\tSCNRDT\t\t; TRMCUR=displacement of bottom of scroll + 2\r\n\tMOV\tBX,WORD PTR TRMCUR\r\n\tMOV\tCH,LOW 0\r\nSCRDTL:\tSUB\tBX,2\t\t; Next posn\r\n\tMOV\tAX,WORD PTR LINTTB-2[BX]\t; Get a terminator\r\n\tMOV\tWORD PTR LINTTB[BX],AX\t; Save a terminator\r\n\tLOOP\tSCRDTL\t\t; Continue till done\r\n\tMOV\tBYTE PTR LINTTB-2[BX],LOW 0\t; Terminate end line of scroll\r\n\tMOV\tBYTE PTR LINTTB-1[BX],LOW OFFSET TRMEOL\r\n\tMOV\tDL,BYTE PTR WDOBOT\r\n\tCALL\tSCNRTL\r\n\tJB\tSCRDT1\t\t; EOL term'd, all done\r\n\tJNZ\tSCRDT1\r\n\tDEC\tAH\r\nSCRDT1:\tMOV\tAL,LOW OFFSET TRMEOL\r\n\tCALL\tSCNWTT\t\t; Make sure last line in window is EOL term'd\r\n\tPOP\tDX\r\n\tRET\t\r\n\r\n;Physical line initialization\r\n;               on entry:   (DH,DL) = start of initialization\r\n;\r\nPLINIT:\tPUSH\tCX\r\n\tPUSH\tAX\r\n\tCALL\tSCNRDT\r\n\tMOV\tAH,DH\r\n\tDEC\tAH\r\n\tPUSH\tBX\r\n\tMOV\tBX,WORD PTR TRMCUR\t; Terminate line to left of DH\r\n\tMOV\tBYTE PTR LINTTB-1[BX],LOW OFFSET TRMEOL\r\n\tMOV\tBYTE PTR LINTTB-2[BX],AH\r\n\tPOP\tBX\r\n\tPOP\tAX\r\nPLINI2:\tCALL\tCLREOL\t\t; Clear to end of line from (DH,DL)\r\n\tPOP\tCX\r\n\tRET\t\r\n\tSUBTTL  LABEL Key Processing\r\n\r\n\r\n;LABELK - If function key display is off then turn on and exit.\r\n;         If function key display is on then advance display line and\r\n;         redisplay.\r\n;ENTRY  - DX = cursor position\r\n;EXIT   - DX unmodified\r\n;USES   - AX,BX,CX\r\n;\r\n\tEXTRN\tFKYADV:NEAR,KEYDSP:NEAR,FKYFMT:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tKEYSW:WORD\r\nDSEG\tENDS\r\nLABELK:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tPUSH\tSI\r\n\tPUSH\tDI\r\n\tCMP\tBYTE PTR KEYSW,LOW 0D\t;Test for key on\r\n\tCALL\tFKYADV\t\t;If KEYSW was 0(ZF=0) then init PF start key,\r\n\t\t\t\t;   else advance to next set of PF keys\r\n\t\t\t\t;   return ZF=1 if advance beyond last of PF keys\r\n\tJZ\tLABOFF\t\t;Process key off request\r\n\tMOV\tBYTE PTR KEYSW,LOW 255D\t;Turn on key display flag\r\nLABDSP:\tCALL\tKEYDSP\t\t;Display function keys\r\n\tPOP\tDI\r\n\tPOP\tSI\r\n\tPOP\tDX\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tPOP\tAX\r\n\tRET\t\r\n\r\nLABOFF:\r\n\tMOV\tBYTE PTR KEYSW,LOW 0D\t;Turn the key flag off\r\n\tJMP\tSHORT LABDSP\t;Go clear the function key display line\r\n\tSUBTTL  Miscellaneous editor interface routines\r\n\r\n\r\n\r\n;SUBROUTINE SCNMRK              ; Mark current position as first posn of logical\r\n;**                 on entry:   ZF=1 indicates INPUT statement, AL=1 indicates\r\n;**                                 EDIT statement.\r\n;**                 on exit:    -\r\n;**\r\nSCNMRK:\tPUSHF\t\r\n\tMOV\tDL,BYTE PTR CSRY\r\n\tMOV\tDH,BYTE PTR CSRX\r\n\tDEC\tAL\r\n\tJNZ\tSCNMK0\t\t; Not begin of EDIT statement\r\n\tCALL\tLSTART\t\t; Set (DH,DL)=start of current line\r\n\tPUSH\tBX\r\n\tJMP\tSHORT SCNMK2\r\n;** IF NOT TOP OF WINDOW\r\nSCNMK0:\tCALL\tCSRUP\t\t; Move to previous line\r\n\tJB\tSCNMK1\t\t; BRIF at top of window\r\n;** *** TERMINATE PREVIOUS PHYSICAL LINE\r\n\tCALL\tSCNRTL\r\n\tMOV\tAL,LOW OFFSET TRMEOL\t; Make sure current line is start of logical line\r\n\tCALL\tSCNWTT\r\n\tINC\tDL\t\t; Restore current line number\r\n;** IF LINE IS MARKED WITH NULL\r\nSCNMK1:\tCALL\tSCNRDT\r\n\tPUSH\tBX\r\n\tMOV\tBX,WORD PTR TRMCUR\r\n\tTEST\tBYTE PTR LINTTB-1[BX],LOW OFFSET TRMNUL\r\n\tJZ\tSCNMK2\t\t; BRIF not specially marked line\r\n\tPUSH\tDX\r\n\tPUSH\tCX\r\n;** SCAN LINE FOR NULL CHAR(255 DECIMAL)\r\n\tMOV\tDH,BYTE PTR WDOLFT\r\n\tMOV\tCL,BYTE PTR LINLEN\r\nSCNMKL:\tCALL\tSCRINP\r\n\tCMP\tAL,LOW 255D\r\n\tJZ\tSCNML3\t\t; BRIF is specially marked line\r\nSCNML2:\tINC\tDH\r\n\tSUB\tCL,LOW 1\r\n\tJA\tSCNMKL\t\t; BRIF more chars to check\r\n\tOR\tSP,SP\r\nSCNML3:\r\n\tPOP\tCX\r\n\tPOP\tDX\r\n\tJNZ\tSCNMK2\t\t; BRIF char was not on line, don't clear line\r\n;** *** DELETE IT\r\n\tCALL\tLDELET\t\t; Delete this line\r\n;** IF NOT DIRECT, SET LSTPOS, FSTPOS = CURRENT_POSN\r\nSCNMK2:\r\n\tMOV\tBYTE PTR CSRY,DL\r\n\tMOV\tBYTE PTR CSRX,DH\t; Update CURS_POSN in case of change\r\n\tPOP\tBX\r\n\tPOPF\t\r\n\tJZ\tSCNMK3\t\t; INPUT statement, use current posn\r\n\tMOV\tBYTE PTR LSTLIN,LOW 377O\t; Direct, set FSTPOS, LSTPOS to min and max\r\n\tMOV\tBYTE PTR FSTLIN,LOW 0\r\n\tJMP\tSHORT SCNMKX\r\nSCNMK3:\tMOV\tBYTE PTR LSTLIN,DL\r\n\tMOV\tBYTE PTR FSTLIN,DL\r\n\tDEC\tDH\r\n\tMOV\tBYTE PTR LSTCOL,DH\t; Mark LSTCOL one to left of current posn\r\n\tINC\tDH\r\n\tMOV\tBYTE PTR FSTCOL,DH\r\nSCNMKX:\tRET\t\r\n;** END SUBROUTINE SCNMRK\r\n\tSUBTTL  Read logical line\r\n\r\n\r\n\r\n;SUBROUTINE SCNRDL              ; Read a logical line\r\n;**                     on entry:   ZF=1 indicates ignore FSTPOS, LSTPOS(statement\r\n;**                                     line input).\r\n;**                                 DX=current posn(within logical line to return)\r\n;**                                 BX=buffer address\r\n;**                                 CX=max count\r\n;**                     on exit:    BX=last char address plus one\r\n;**                                 CX=CX - (count of chars moved)\r\n;**                                 DX=destroyed\r\n;**\r\nSCNRDL:\tPUSHF\t\t\t; Save statement input flag\r\n;** Set DX=start of move\r\n;** WHILE ((DL .NE FSTLIN) AND DL IN_SAME_LOGICAL_LINE)\r\nSCRD00:\tCMP\tDL,BYTE PTR FSTLIN\r\n\tJZ\tSCRD01\t\t; Found first line of logical\r\n;** *** DL = PREVIOUS LINE\r\n\tCALL\tCSRUP\r\n\tJB\tSCRD01\t\t; At top of window, stop here\r\n\tCALL\tSCNRDT\r\n\tJNB\tSCRD00\t\t; Still same logical, continue\r\n\tINC\tDL\t\t; Set DL = first physical of logical\r\n;** IF (STATEMENT_INPUT OR (NOT ON FIRST_LINE))\r\nSCRD01:\tPOPF\t\t\t; We have start line, now get start column\r\n\tPUSHF\t\r\n;** *** START_COLUMN=LEFT_MARGIN\r\n\tMOV\tDH,BYTE PTR WDOLFT\t; Assume start at left margin\r\n\tJNZ\tSCRD02\t\t; BRIF statement input\r\n\tCMP\tDL,BYTE PTR FSTLIN\r\n\tJNZ\tSCRD02\t\t; BRIF not on FIRST_LINE\r\n;** *** ELSE START_COLUMN=FIRST_COLUMN\r\n\tMOV\tDH,BYTE PTR FSTCOL\r\n\r\n;** WHILE (POSN IS ON SAME LOGICAL) AND ((POSN .LTE. LSTPOS) OR STATEMENT_INPUT) BEGIN\r\nSCRD02:\tPOPF\t\r\n\tPUSHF\t\r\n\tJNZ\tSCRD03\t\t; BRIF statement input, ignore LSTPOS\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJA\tSCRDXZ\t\t; **BRIF passed LSTPOS(was at prev. line term'r)\r\n\tJNZ\tSCRD03\t\t; BRIF not at LSTPOS\r\n\tCMP\tDH,BYTE PTR LSTCOL\r\n\tJA\tSCRDXZ\t\t; BRIF beyond LSTPOS, all done\r\n;** *** READ A CHARACTER INTO THE BUFFER\r\n;** *** DO CASE TERMINATOR OF LINEFEED, NULL_WRAP, WRAP, BEFORE EOL, AT EOL\r\nSCRD03:\tCALL\tSCNRDT\r\n\tPUSH\tAX\r\n\tJB\tSCRD04\t\t; BRIF not reading a linefeed\r\n\tJNZ\tSCRD04\t\t; BRIF not reading a linefeed\r\n\tCMP\tAH,DH\r\n\tJNZ\tSCRD04\t\t; BRIF not reading a linefeed\r\n;** *** *** CASE: LINEFEED\r\nSCRDLF:\tMOV\tAX,OFFSET CHRLNF+0\r\n\tJMP\tSHORT SCRD08\t; At linefeed terminator, pass linefeed\r\nSCRD04:\tCMP\tAH,DH\r\n\tJA\tSCRD07\t\t; BRIF within data on screen\r\n\tJB\tSCRD06\t\t; BRIF beyond terminator\r\n;** *** *** CASE: NULL_WRAP\r\n\tCMP\tAL,LOW OFFSET TRMNWP\r\n\tJNZ\tSCRD07\t\t; BRIF not at NULL_WRAP terminator\r\nSCRD06:\tCMP\tAL,LOW OFFSET TRMEOL\r\n\tPOP\tAX\r\n\tJZ\tSCRDXZ\t\t; BRIF beyond EOL\r\n;** *** *** CASE: WRAP\r\n\tINC\tDL\t\t; Wrap to next line\r\n\tMOV\tDH,BYTE PTR WDOLFT\r\n\tJMP\tSHORT SCRD02\r\n;** *** *** CASE: BEFORE EOL\r\nSCRD07:\r\n\tCLC\t\t\t; Indicate call is from Screen Editor\r\n\tCALL\tSCRINP\t\t; AX=Character at (DH,DL)\r\nSCRD08:\tMOV\tBYTE PTR 0[BX],AL\r\n\tDEC\tCX\r\n\tPOP\tAX\r\n\tJZ\tSCRDEX\r\n\tCMP\tAL,LOW OFFSET TRMEOL\r\n\tJNZ\tSCRD09\t\t; BRIF not at EOL\r\n\tCMP\tAH,DH\r\n\tJBE\tSCRDEX\t\t; BRIF at EOL(or beyond), all done\r\nSCRD09:\tINC\tBX\r\n\tCALL\tCSRADV\r\n\tJB\tSCRDXZ\t\t; If end of window, all done\r\n\tJMP\tSHORT SCRD02\t; Pass next character\r\n;** *** *** CASE: AT(OR BEYOND) EOL\r\nSCRDEX:\tINC\tBX\t\t; Set BX= last posn written plus one\r\nSCRDXZ:\tPOPF\t\r\n\tCALL\tSCNBRK\t\t; Clear any flags associated with INPUT\r\n\tRET\t\r\n;** *** *** END\r\n;** *** END\r\n;** END SUBROUTINE SCNRDL\r\n\tSUBTTL  CONTROL CHARACTER ROUTINES\r\n\r\n\r\n;CONTROL CHARACTER DISPATCH TABLE\r\n;**\r\nFUNTAB:\tDW\tOFFSET CTLIGN\t; ^@  -  Ignore\r\n\tDW\tOFFSET CTLIGN\t; ^A  -  Ignore\r\n\tDW\tOFFSET BCKWRD\t; ^B  -  Back one word\r\n\tDW\tOFFSET CTLIGN\t; ^C  -  Ignore\r\n\tDW\tOFFSET CTLIGN\t; ^D  -  Ignore\r\n\tDW\tOFFSET LTRUNC\t; ^E  -  Truncate logical line\r\n\tDW\tOFFSET FWDWRD\t; ^F  -  Forward one word\r\n\tDW\tOFFSET CBEEP\t; ^G  -  Beep\r\n\tDW\tOFFSET BAKSPC\t; ^H  -  Destructive backspace\r\n\tDW\tOFFSET LTAB\t; ^I  -  Destructive tab\r\n\tDW\tOFFSET LFEED\t; ^J  -  Linefeed\r\n\tDW\tOFFSET WHOME\t; ^K  -  Home within window\r\n\tDW\tOFFSET CCLRSN\t; ^L  -  Clear window, home cursor\r\n\tDW\tOFFSET LCARET\t; ^M  -  Carriage return\r\n\tDW\tOFFSET LAPPND\t; ^N  -  Append to end of line\r\n\tDW\tOFFSET CTLIGN\t; ^O  -  Ignore\r\n\tDW\tOFFSET CTLIGN\t; ^P  -  Ignore\r\n\tDW\tOFFSET CTLIGN\t; ^Q  -  Ignore\r\n\tDW\tOFFSET LINSRT\t; ^R  -  Insert a blank\r\n\tDW\tOFFSET CTLIGN\t; ^S  -  Ignore\r\n\tDW\tOFFSET LABELK\t; ^T  -  LABEL Key\r\n\tDW\tOFFSET LDELET\t; ^U  -  Delete a line\r\n\tDW\tOFFSET CTLIGN\t; ^V  -  Ignore\r\n\tDW\tOFFSET WDELET\t; ^W  -  Delete a word\r\n\tDW\tOFFSET CTLIGN\t; ^X  -  Ignore\r\n\tDW\tOFFSET CTLIGN\t; ^Y  -  Ignore\r\n\tDW\tOFFSET WERASE\t; ^Z  -  Erase to end of window\r\n\tDW\tOFFSET CTLIGN\t; ^[ or ESC - Ignore\r\n\tDW\tOFFSET WCSADV\t; ^\\  -  Cursor advance within window\r\n\tDW\tOFFSET WCSREG\t; ^]  -  Cursor regress within window\r\n\tDW\tOFFSET WCSUP\t; ^^  -  Cursor up within window\r\n\tDW\tOFFSET WCSDWN\t; ^_  -  Cursor down within window\r\n\tDW\tOFFSET CDELET\t; DEL -  Delete a character\r\n\r\n\r\n;SUBROUTINE CTLDSP(CONTROL_CHAR); Do control char logic\r\n;**                         on entry:   AX=control character\r\n;**                         on exit:    if CF=0 then AX=character to output\r\n;**                                     if CF=1 then AX is undefined\r\nCTLDSP:\r\n\tCALL\tSCNPOS\t\t; DH=column, DL=row\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCSRTYP:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tSETCSR:NEAR\r\n\tMOV\tBYTE PTR CSRTYP,LOW 0D\t; Set for off cursor\r\n\tCALL\tSETCSR\t\t; Ensure that the cursor is off\r\n\tMOV\tDH,BYTE PTR CSRX\t; Set DH=true posn(not width truncated)\r\n\tTEST\tBYTE PTR ESCFLG,LOW 377O\r\n\tJNZ\tDOESC\t\t; BRIF in middle of escape sequence\r\n\tCMP\tAL,LOW 33O\r\n\tJZ\tDOESC\r\nCTLDS0:\r\n\r\nCTLDP0:\r\nCTLDP1:\r\n\tEXTRN\tEDTMAP:NEAR,PRTMAP:NEAR\r\n\tTEST\tBYTE PTR F_EDIT,LOW 377O\t; Test for Screen Edit mode\r\n\tJZ\tCTLPRT\t\t; BRIF not edit mode\r\n\tCMP\tAH,LOW 1D\t; Set PSW.C if two byte character\r\n\tCMC\t\r\n\tCALL\tEDTMAP\t\t; Map edit function/output character code\r\n\tJMP\tCTLEDT\r\n\r\nCTLPRT:\tCMP\tAH,LOW 1D\t; Set PSW.C if two byte character\r\n\tCMC\t\r\n\tCALL\tPRTMAP\t\t; Map print function/output character codes\r\nCTLEDT:\tJZ\tCTLDPY\t\t; Ignore this character\r\n\t\t\t\t; Print or perform the editor function\r\n\tCMP\tAH,LOW 255D\t; Is it an editor function (&HFF)?\r\n\tJNZ\tCTLDSX\t\t; No - print the character\r\n\tXOR\tAH,AH\t\t; Clear (no longer needed) editor function flag\r\n\tCMP\tAL,LOW 177O\t; Delete function?\r\n\tJNZ\tCTLNDL\t\t; BRIF not DEL\r\n\tMOV\tAL,LOW \" \"\t; DEL code\r\nCTLNDL:\tCMP\tAL,LOW 255D\r\n\tJNZ\tCTLNMK\t\t; BRIF not \"mark line for deletion\"\r\n\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tCALL\tSCNRDT\r\n\tMOV\tBX,WORD PTR TRMCUR\r\n\tOR\tBYTE PTR LINTTB-1[BX],LOW OFFSET TRMNUL\t; Set \"not for input\" flag on this line\r\n\tPOP\tBX\r\n\tPOP\tAX\r\n;       STC\r\n\tRET\t\r\nCTLNMK:\tCMP\tAL,LOW OFFSET \" \"+1\t; Test for legal function code\r\n\tJNB\tCTLDPY\t\t; Ignore this code\r\n\tPUSH\tAX\r\n\tCALL\tCTLIRS\t\t; Possibly reset insert flag\r\n\tADD\tAX,AX\t\t; Two bytes per entry\r\n\tMOV\tBX,AX\r\n\tMOV\tAX,OFFSET CTLDPX\r\n\tPUSH\tAX\t\t; Put return on stack\r\n\tMOV\tAX,WORD PTR FUNTAB[BX]\r\n\tPUSH\tAX\t\t; Put routine address on stack\r\nCTLDSX:\tCLC\t\r\n\tRET\t\t\t; Go do control routine\r\n;** *** UPDATE CURRENT_POSN, RETURN\r\nCTLDPX:\tMOV\tBYTE PTR CSRY,DL\r\n\tMOV\tBYTE PTR CSRX,DH\t; Update cursor posn\r\n\tPOP\tAX\r\n\tSUB\tAL,LOW OFFSET CHRRET\r\n\tMOV\tBYTE PTR F_CRET,AL\t; F.CRET = 0 if character was Carriage return\r\nCTLDPY:\r\n\tSTC\t\r\nCTLIGN:\r\nCTLDPZ:\tRET\t\r\n;** ESCAPE SEQUENCE PROCESSING\r\nDOESC:\tCALL\tSCROUT\t\t; Returns carry set if continuation of escape sequence\r\n\tSBB\tAL,AL\t\t; If ESC sequence, AL=FF else AL=0\r\n\tMOV\tBYTE PTR ESCFLG,AL\t; Set/Reset flag\r\n\tJMP\tSHORT CTLDPY\r\n;** END SUBROUTINE CTLDSP\r\n\r\n;THE CONTROL CHARACTERS WHICH RESET INSERT FLAG ARE IN TABLE BELOW:\r\n;\r\nCTLITB:\r\n\tDB\tOFFSET CHRLDL\t; LINE_DELETE\r\n\tDB\tOFFSET CHRERA\t; ERASE_SCREEN\r\n\tDB\tOFFSET CHRFDW\t; FORWARD_WORD\r\n\tDB\tOFFSET CHRBKW\t; BACKWARD_WORD\r\n\tDB\tOFFSET CHRAPP\t; APPEND_TO_LINE\r\n\tDB\tOFFSET CHREDT\t; EDIT_PREVIOUS_LINE\r\n\tDB\tOFFSET CHRCLE\t; CLEAR_TO_END\r\n\tDB\tOFFSET CHRBEL\t; BELL\r\n\tDB\tOFFSET CHRHOM\t; HOME\r\n\tDB\tOFFSET CHRADV\t; CURSOR_ADV\r\n\tDB\tOFFSET CHRREG\t; CURSOR_REG\r\n\tDB\tOFFSET CHRUP\t; CURSOR_UP\r\n\tDB\tOFFSET CHRDWN\t; CURSOR_DOWN\r\n\tCTLCNT=$-CTLITB\r\n\r\n;SUBROUTINE CTLIRS              ; Reset insert flag for specified characters\r\n;**                 on entry:   AL=character\r\n;**                 on exit:    DI garbaged\r\n;**\r\nCTLIRS:\tPUSH\tAX\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDI\r\n;** IF (SPECIAL_ACTION(CTLKEY))\r\n\tMOV\tDI,OFFSET CTLITB\t; DI= [control char table]\r\n\tMOV\tCX,OFFSET CTLCNT\t; CX= count of entries in table\r\n\tMOV\tBX,CX\r\n\tPUSH\tES\r\n\tPUSH\tCS\t\t; Scan in code segment\r\n\tPOP\tES\r\n\tCLD\t\t\t; Scan forward\r\n REPNE\tSCASB\t\t\t; Scan for character in table\r\n\tPOP\tES\r\n\tJNE\tINCNOT\t\t; BRIF did not find the control character\r\n;** *** F.INSRT=FALSE\r\n\tMOV\tBYTE PTR F_INST,LOW 0\t; Reset insert flag\r\nINCNOT:\tPOP\tDI\r\n\tPOP\tCX\r\n\tPOP\tBX\r\n\tPOP\tAX\r\n\tRET\t\r\n;** END SUBROUTINE CTLIRS\r\n;** *** END\r\n\r\n\tSUBTTL  CONTROL CHARACTER ROUTINES - Cursor movement by character, line and TAB\r\n\r\n\r\n\r\n;The control character routines are entered with DH=current column and\r\n;   DL=current line. They return updated posn in the same registers. They\r\n;   can modify AX, BX, CX but must save any other registers used.\r\n\r\n;CURSOR CONTROL\r\n;   The cursor control routines are somewhat special. Except for cursor advance,\r\n;   the cursor is made to stay within previously printed data. The cursor\r\n;   advance routine will append blanks by changing the logical right margin,\r\n;   without actually printing anything. All of the cursor control routines\r\n;   will update FSTPOS and LSTPOS as long as the cursor stays within a logical\r\n;   line. When the cursor leaves a logical line, the FSTPOS and LSTPOS values\r\n;   do not change. If the cursor is then moved back onto the original logical\r\n;   line, the values are updated once more.\r\n;\r\n;Cursor advance\r\nWCSADV:\tCALL\tCSRADV\t\t; Advance cursor\r\n\tJB\tWCSABT\t\t; BRIF can't do, quit\r\n;       CALL    SCNRDT          ; AH=end of this physical, AL=terminator\r\n;       CMPB    DH,AH\r\n;If cursor beyond previously printed data, don't update LSTCOL\r\n;       JAE     WCSABT          ; BRIF not to left of line terminator posn\r\n;If cursor beyond previous LSTPOS and on same logical, update LSTPOS\r\nUPDPOS:\tPUSH\tDX\r\n\tDEC\tDH\t\t; LSTCOL is to left of cursor\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJB\tUPDPS3\t\t; BRIF not new LSTPOS\r\n\tJZ\tUPDPS2\t\t; BRIF on same line, possibly update LSTPOS\r\n\tPUSH\tDX\r\n\tCALL\tLSTART\t\t; Get start line of current logical\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tPOP\tDX\r\n\tJA\tUPDPS3\t\t; BRIF LSTPOS not on current logical line\r\n;LSTPOS on current logical, previous physical\r\n\tMOV\tBYTE PTR LSTLIN,DL\t; Set LSTPOS to current\r\n\tMOV\tBYTE PTR LSTCOL,DH\r\nUPDPS2:\tCMP\tDH,BYTE PTR LSTCOL\r\n\tJBE\tUPDPS3\t\t; BRIF not new last posn\r\n\tMOV\tBYTE PTR LSTCOL,DH\t; Set new last posn\r\n;If cursor before previous FSTPOS and on same logical, update FSTPOS\r\nUPDPS3:\tINC\tDH\t\t; Restore column\r\n\tCMP\tDL,BYTE PTR FSTLIN\r\n\tJNZ\tUPDPSX\t\t; BRIF not on same line as first position\r\n\tCMP\tDH,BYTE PTR FSTCOL\r\n\tJAE\tUPDPSX\t\t; BRIF not new first position\r\n\tMOV\tBYTE PTR FSTCOL,DH\t; Set new first position to current position\r\nUPDPSX:\tPOP\tDX\r\nWCSABT:\tRET\t\r\n\r\n;Cursor regress\r\nWCSREG:\tCALL\tCSRREG\t\t; Move cursor\r\n\tJB\tWCSABT\t\t; Can't move, quit\r\nWCSRET:\tCALL\tSCNRDT\r\n\tCMP\tAH,DH\r\n\tJNB\tUPDPOS\t\t; Within logical, update FSTPOS, LSTPOS, return\r\n;Cursor to right of line terminator, don't update LSTCOL\r\n\tJMP\tSHORT WCSABT\t; Return\r\n\r\n;Cursor up\r\nWCSUP:\tCALL\tCSRUP\t\t; Move cursor\r\n\tJNB\tWCSRET\t\t; BRIF successful, possibly update FSTPOS, LSTPOS\r\n\tRET\t\t\t; Unsuccessful, return(NOP)\r\n\r\n;Cursor down\r\nWCSDWN:\tCALL\tCSRDWN\t\t; Move cursor\r\n\tJNB\tWCSRET\t\t; BRIF successful, possibly update FSTPOS, LSTPOS\r\n\tRET\t\t\t; Unsuccessful, return(NOP)\r\n\r\n;TAB                            ; Move cursor to next TAB stop\r\n;\r\nLTAB:\tTEST\tBYTE PTR F_INST,LOW 377O\r\n\tJZ\tLTABL\t\t; BRIF not insert TAB\r\n;Insert spaces until CSRX is at TAB stop or LINLEN\r\nLTABIL:\tMOV\tAX,\" \"\r\n\tCALL\tSCNOUT\t\t; Insert a blank\r\n\tMOV\tDL,BYTE PTR CSRY\r\n\tMOV\tDH,BYTE PTR CSRX\r\n\tCMP\tDH,BYTE PTR LINLEN\r\n\tJA\tLTABZ\t\t; All done, at end of line\r\n\tDEC\tDH\r\n\tTEST\tDH,LOW 7O\r\n\tJNZ\tLTABIL\t\t; Keep inserting\r\n\tINC\tDH\r\n\tJMP\tSHORT LTABZ\t; All done, at TAB stop\r\n;Non-insert TAB, just pass over characters\r\nLTABL:\tCMP\tDH,BYTE PTR LINLEN\r\n\tJAE\tLTABX0\t\t; BRIF need to wrap\r\n\tINC\tDH\r\n\tTEST\tDH,LOW 7O\r\n\tJNZ\tLTABL\r\n\tINC\tDH\r\n\tJMP\tSHORT LTABX\t; BRIF reached good posn\r\nLTABX0:\tCMP\tDL,BYTE PTR WDOBOT\r\n\tJAE\tLTABZ\t\t; BRIF no room to end of page\r\n\tINC\tDL\r\n\tMOV\tDH,BYTE PTR WDOLFT\t; Else move to start of next line\r\nLTABX:\tCALL\tUPDPOS\t\t; Update LSTPOS\r\nLTABZ:\tRET\t\r\n\tSUBTTL  CONTROL CHARACTER ROUTINES - Cursor movement by word\r\n\r\n\r\n;Advance cursor to beginning of next word within screen\r\nFWDWRD:\tPUSH\tDX\r\n\tPUSH\tWORD PTR LSTLIN\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tFWDWR0\t\t; BRIF LSTPOS not on this line\r\n\tCMP\tDH,BYTE PTR LSTCOL\r\n\tJB\tFWDWR0\t\t; BRIF within logical line\r\n\tMOV\tBYTE PTR LSTLIN,LOW 377O\t; Ignore LSTPOS in scan\r\nFWDWR0:\tCLC\t\r\nFWDWR1:\tCALL\tFWDWDL\t\t; Try within logical\r\n\tJB\tFWDWR2\t\t; BRIF unsuccessful\r\n\tPOP\tWORD PTR LSTLIN\r\n\tCALL\tUPDPOS\r\n\tPOP\tAX\t\t; Remove old posn from stack\r\n\tRET\t\r\n;Reached end of logical line, try next logical\r\nFWDWR2:\tCALL\tCSRDWN\r\n\tJB\tFWDWRZ\t\t; BRIF end of screen\r\n\tMOV\tDH,BYTE PTR WDOLFT\t; Start scan again at next line\r\n\tSTC\t\r\n\tJMP\tSHORT FWDWR1\t; Continue scan\r\n;Unsuccessful, return cursor to original posn\r\nFWDWRZ:\tPOP\tWORD PTR LSTLIN\r\n\tPOP\tDX\r\n\tRET\t\r\n\r\nFWDWD0:\tCALL\tLCSADV\r\n\tJB\tFWDWD3\t\t; At end of logical line\r\n;Advance cursor to beginning of next word within logical line\r\nFWDWDL:\tJB\tFWDWD2\t\t; Start as though between words\r\n\tCALL\tANCHK\t\t; Check if current char is within word\r\n\tJNB\tFWDWD0\t\t; BRIF still within previous word\r\n;At space between words\r\nFWDWD1:\tCALL\tLCSADV\r\n\tJB\tFWDWD3\t\t; At end of logical line, check next logical\r\nFWDWD2:\tCALL\tANCHK\r\n\tJB\tFWDWD1\r\nFWDWDX:\tRET\t\t\t; Return, DX=posn of new word or end of logical line\r\nFWDWD3:\tJNZ\tFWDWDX\t\t; BRIF not stop at LSTPOS\r\n;Stopped at LSTPOS, continue scan to end of physical line\r\n\tCMP\tAH,DH\r\n\tJA\tFWDWD4\t\t; BRIF more this line\r\n\tSTC\t\r\n\tRET\t\r\nFWDWD4:\tMOV\tBYTE PTR LSTLIN,LOW 377O\t; Ignore LSTPOS from here on\r\n\tJMP\tSHORT FWDWD1\t; Since crossed LSTPOS, passed end of current word\r\n\r\n;Regress cursor to start of previous word\r\nBCKWRD:\tPUSH\tWORD PTR FSTCOL\r\n\tPUSH\tDX\r\n\tCMP\tDH,BYTE PTR FSTLIN\r\n\tJNZ\tBCKWD2\r\n\tCMP\tDH,BYTE PTR FSTCOL\r\n\tJA\tBCKWD2\r\n\tMOV\tBYTE PTR FSTLIN,LOW 0\r\n;Assume passed beginning of current word, continue to start of next\r\nBCKWD2:\tCALL\tLCSREG\r\n\tJB\tBCKWD7\t\t; BRIF At start of line\r\nBCKWD4:\tCALL\tANCHK\r\n\tJB\tBCKWD2\t\t; BRIF still between words\r\n;Scanning previous word, any termination is good\r\nBCKWD5:\tCALL\tLCSREG\r\n\tJB\tBCKWD6\t\t; BRIF at beginning of line, found previous word\r\n\tCALL\tANCHK\r\n\tJNB\tBCKWD5\t\t; BRIF not at beginning of word\r\n\tCALL\tCSRADV\t\t; Advance back to start of word\r\nBCKWD6:\tPOP\tAX\r\n\tPUSH\tDX\t\t; Push new posn on stack\r\nBCKWDX:\tPOP\tDX\r\n\tPOP\tWORD PTR FSTCOL\r\n\tCALL\tUPDPOS\r\n\tRET\t\t\t; Return, DL=posn of previous word\r\nBCKWD7:\tJNZ\tBCKWD8\t\t; BRIF not stop at FSTPOS\r\n\tMOV\tBYTE PTR FSTLIN,LOW 0\t; Ignore FSTPOS from here on\r\n\tJMP\tSHORT BCKWD2\t; Since passed begginning of logical, between words\r\nBCKWD8:\tCALL\tCSRUP\t\t; Try previous logical line\r\n\tJB\tBCKWDX\t\t; At beginning of screen\r\n\tCALL\tSCNRDT\t\t; Read previous line teminator\r\n\tOR\tAH,AH\r\n\tJZ\tBCKWD8\t\t; Previous line is null, try next previous\r\n\tMOV\tDH,AH\r\n\tJMP\tSHORT BCKWD4\t; Continue scan\r\n\tSUBTTL  CONTROL CHARACTER ROUTINES - Screen home, truncate and clear\r\n\r\n\r\n\tEXTRN\tBEEP:NEAR\r\nCBEEP:\tCALL\tBEEP\t\t; Sound Bell\r\n\tJMP\tSCNPOS\t\t; return current cursor location\r\n\r\n\tEXTRN\tCLRSCN:NEAR\r\n;Clear the screen\r\nCCLRSN:\r\n\tCLC\t\t\t; no-carry = internal parameter\r\n\tMOV\tAL,LOW 2\t; specify text only\r\n\tCALL\tCLRSCN\t\t; OEM supplied Clear-Screen Routine\r\n\t\t\t\t;fall into WHOME\r\n\r\n;Home the cursor\r\nWHOME:\tMOV\tDL,BYTE PTR WDOTOP\r\n\tMOV\tDH,BYTE PTR WDOLFT\r\n\tRET\t\r\n\r\n;Erase to the end of the screen\r\nWERASE:\tCALL\tPLINIT\t\t; Clear current physical to end of line\r\n\tPUSH\tDX\r\n\tMOV\tDH,BYTE PTR WDOLFT\t; Clear rest of lines from left margin\r\n;WHILE POSN .LTE. WDOBOT\r\n;** IF DATA_EXISTS(POSN) THEN INITIALIZE LINE\r\nWERAS0:\tINC\tDL\r\n\tCMP\tDL,BYTE PTR WDOBOT\r\n\tJA\tWERASX\t\t; Beyond window, exit\r\n\tCALL\tPLINIT\t\t; Clear this line\r\n\tJMP\tSHORT WERAS0\t; Init next line\r\nWERASX:\tPOP\tDX\t\t; Return DX=cursor posn\r\n\tRET\t\r\n\tSUBTTL  CONTROL CHARACTER ROUTINES - Line truncate and delete\r\n\r\n\r\n\r\n;Delete entire logical line\r\nLDELET:\tCALL\tLSTART\t\t; Get start of logical line in DX\r\n\r\n;Truncate line from posn in DX\r\nLTRUNC:\tPUSH\tDX\r\n\tCALL\tSCNRTL\t\t; AH=last valid data on physical line\r\n\tPUSHF\t\r\n\tSTC\t\t\t; Indicate don't clear line by scrolling\r\n\tCALL\tLCLEAR\t\t; Clear this physical line\r\n\tJB\tLTRUN9\t\t; Reached LSTPOS, all done\r\n\tINC\tDL\r\n;\"Suck up\" remaining physical lines attached to current logical\r\nLTRUN1:\tPOPF\t\r\n\tJB\tLTRUNX\t\t; Reached end of logical line\r\n\tCALL\tSCNRTL\r\n\tPUSHF\t\r\n\tMOV\tDH,BYTE PTR WDOLFT\r\n\tCLC\t\r\n\tCALL\tLCLEAR\t\t; Clear this line from start of line\r\n\tJB\tLTRUN9\t\t; Reached LSTPOS, all done\r\n\tJMP\tSHORT LTRUN1\r\nLTRUN9:\tPOPF\t\r\nLTRUNX:\tPOP\tDX\r\n\tRET\t\r\n\r\n;Clear current physical to end of physical or LSTPOS, whichever is smallest\r\n; (DH,DL)=start posn, AH=TERM_POSN, if CF=1, don't scroll\r\nLCLEAR:\tPUSHF\t\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJZ\tLCLER2\t\t; BRIF clear up to LSTPOS\r\nLCLER0:\tCMP\tDH,BYTE PTR WDORGT\r\n\tJA\tLCLER5\t\t; BRIF beyond end of physical(just exit)\r\n\tPOPF\t\r\n\tJNB\tLCLER1\t\t; BRIF clear line by scroll\r\n\tCALL\tPLINIT\t\t; Clear this physical line\r\n\tCLC\t\r\n\tRET\t\r\nLCLER1:\tCALL\tSCRLU0\t\t; Scroll up from bottom to current line\r\n\tCLC\t\r\n\tRET\t\r\nLCLER2:\tPOPF\t\r\n\tCALL\tPLINIT\r\n\tSTC\t\r\n\tRET\t\r\nLCLER5:\tPOPF\t\r\n\tCLC\t\r\n\tRET\t\r\n\r\n\r\n\tSUBTTL  CONTROL CHARACTER ROUTINES - Character and word delete\r\n\r\n\r\n\r\n;Word delete\r\n;\r\nWDELET:\r\n\tCMP\tDH,BYTE PTR LINLEN\r\n\tJBE\tWDELT0\t\t; BRIF on physical line\r\n\tCALL\tCSRADV\t\t; Put cursor on next line\r\n\tJB\tWDELTZ\t\t; BRIF at end of screen\r\nWDELT0:\r\n\tCMP\tDL,BYTE PTR LSTLIN\t; **\r\n\tJNZ\tWDELT2\t\t; **BRIF not on LSTPOS line\r\n\tCMP\tDH,BYTE PTR LSTCOL\t; **\r\n\tJAE\tWDELTZ\t\t; **BRIF at or beyond LSTPOS(don't do word delete)\r\nWDELT2:\t\t\t\t; **\r\n\tPUSH\tDX\r\n\tCMP\tDH,BYTE PTR LINLEN\r\n\tJBE\tWDELT4\t\t; Good delete posn(within physical line)\r\n\tCALL\tLCSADV\t\t; Advance cursor to next physical of logical\r\nWDELT4:\tPUSH\tDX\r\n\tCLC\t\r\n\tPUSH\tWORD PTR LSTLIN\r\n\tCALL\tFWDWDL\t\t; Set (DH,DL)= start of next word or end of line\r\n\tPOP\tWORD PTR LSTLIN\r\n\tJNB\tWDELT6\t\t; BRIF found another word following\r\n;No word following, just delete to end of line\r\n\tINC\tDH\t\t; Include terminator in delete\r\nWDELT6:\tMOV\tCX,DX\r\n\tPOP\tDX\r\n\tCMP\tCL,BYTE PTR LSTLIN\t; **\r\n\tJB\tWDELT8\t\t; **BRIF not beyond LSTPOS line\r\n\tJA\tWDELT7\t\t; **BRIF beyond LSTPOS line, use LSTPOS\r\n\tCMP\tCH,BYTE PTR LSTCOL\t; **At LSTPOS line, check if column is OK\r\n\tJB\tWDELT8\t\t; **BRIF before LSTPOS, column is OK\r\nWDELT7:\tMOV\tCX,WORD PTR LSTLIN\t; **Use LSTPOS as end of delete\r\n\tINC\tCH\t\t; **INC because delete is up to char before this posn\r\nWDELT8:\t\t\t\t; **\r\n\tCMP\tDL,CL\r\n\tJNZ\tWDELTC\t\t; BRIF multiple line delete\r\nWDELT9:\tSUB\tCH,DH\t\t; CH=chars to next word minus one\r\n\tJBE\tWDELTX\t\t; BRIF no chars to delete\r\n\tCALL\tCDELLG\t\t; Delete CH chars in this line\r\nWDELTX:\tPOP\tDX\r\nWDELTZ:\tRET\t\r\nWDELTC:\tINC\tDL\r\nWDELTD:\tPUSH\tDX\r\n\tPUSH\tCX\r\n; Delete across physical lines, delete to end of this line\r\n\tCMP\tDL,CL\r\n\tMOV\tDH,BYTE PTR WDOLFT\r\n\tJZ\tWDELTE\r\n\tCALL\tSCNRTL\r\n\tMOV\tCH,AH\r\n\tCALL\tCDELPH\t\t; Erase intervening line\r\n\tPOP\tCX\r\n\tPOP\tDX\r\n\tDEC\tCL\t\t; Each erase of intervening line brings CL closer\r\n\tJMP\tSHORT WDELTD\r\nWDELTE:\tCMP\tCH,BYTE PTR WDOLFT\r\n\tJBE\tWDELTF\t\t; BRIF at begin of line\r\n\tDEC\tCH\r\n\tCALL\tCDELLG\t\t; Delete up to the next word on this line\r\nWDELTF:\tPOP\tCX\r\n\tPOP\tDX\r\n\tDEC\tDL\t\t; Go back to original line\r\n\tMOV\tCH,BYTE PTR LINLEN\r\n\tINC\tCH\r\n\tJMP\tSHORT WDELT9\t; Delete to end of line\r\n\r\n\r\n\r\n;Destructive back space\r\n;\r\nBAKSPC:\r\n\tCALL\tLCSREG\t\t; Back space within logical line\r\n\tCALL\tSCNRTL\r\n\tCMP\tDH,AH\r\n\tJBE\tCDELET\t\t; BRIF current posn less than TERM_POSN\r\n\tCMP\tAH,BYTE PTR WDOLFT\r\n\tJAE\tBAKSP1\t\t; BRIF not on null line\r\n\tMOV\tAH,BYTE PTR WDOLFT\r\nBAKSP1:\tMOV\tDH,AH\t\t; If beyond terminator, set posn to terminator\r\n\r\n;Delete character\r\n;\r\nCDELET:\tMOV\tCH,LOW 1\t; Assume one byte char delete\r\n\tCMP\tDH,BYTE PTR LINLEN\r\n\tJBE\tCDELT1\t\t; BRIF within physical line\r\n\tRET\t\r\nCDELT1:\r\n\r\n;SUBROUTINE CDELLG:             ; Delete CH characters @(DH,DL) within logical\r\n;                       On entry:   CH=count, CL= flag, (DH,DL)=posn\r\n;                                   If CL is non-zero, remove null line from screen\r\n;\r\nCDELLG:\tPUSH\tDX\r\n\tCALL\tSCNRTL\t\t; Get last valid char posn in AH\r\n\tPUSHF\t\r\n\tCALL\tCDELPH\t\t; Delete characters from current physical\r\n\t\t\t\t;   returns new term posn in AH\r\n\tXOR\tCL,CL\t\t; CL is iteration counter\r\n\tPOPF\t\r\n\tMOV\tAL,LOW OFFSET TRMEOL\r\n\tJB\tCDLGEX\t\t; BRIF was EOL term'd, update terminator, exit\r\n\tJNZ\tCDLGWP\t\t; BRIF line was WRAP or NULL_WRAP term'd, get\r\n\t\t\t\t;       chars from next line\r\n;Line was LF terminated, check for LF delete\r\n\tCMP\tAH,DH\r\n\tMOV\tAL,LOW OFFSET TRMLNF\r\n\tJA\tCDLGEX\t\t; BRIF didn't delete LF, update terminator, exit\r\n\tOR\tAH,AH\r\n\tJZ\tCDLGRT\t\t; **BRIF entire line deleted and removed\r\n\tMOV\tAH,DH\r\n\tJMP\tSHORT CDLWP1\r\n;Need to get chars from next physical line at (AH,DL) posn to end of physical\r\nCDLGWP:\tOR\tAH,AH\r\n\tJZ\tCDLGRT\t\t; BRIF entire line deleted and removed\r\n\tINC\tAH\r\nCDLWP1:\tCMP\tDL,BYTE PTR LSTLIN\t; **\r\n\tJZ\tCDLGRT\t\t; **LSTPOS on this line, all done\r\n\tPUSH\tWORD PTR LSTLIN\t; **Save current LSTPOS\r\n\tCALL\tCDUNWP\t\t; Unwrap the characters desired returns terminator\r\n\t\t\t\t;     in (AH,AL) and byte count in CH\r\n\tCALL\tSCNWTT\t\t; Update terminator\r\n\tOR\tCH,CH\r\n\tJNZ\tCDLWP2\t\t; BRIF we have characters to unwrap\r\n\tPOP\tAX\t\t; Restore the stack\r\n\tJMP\tSHORT CDLGRT\t; Return, all done\r\n;Need to delete CH characters unwrapped from next line\r\nCDLWP2:\tMOV\tDH,BYTE PTR WDOLFT\t; Unwrapped from start of line\r\n\tINC\tDL\t\t; Next line\r\n\tDEC\tCL\t\t; Update iteration counter\r\n\tCALL\tSCNRTL\t\t; Read next lines terminator\r\n;Need to restore LSTPOS to old value for character delete\r\n\tMOV\tDI,WORD PTR LSTLIN\t; **Save current value of LSTPOS in SI\r\n\tPOP\tWORD PTR LSTLIN\t; **Restore value before CDUNWP so CDELPH works properly\r\n\tPUSHF\t\r\n\tPUSH\tDI\t\t; **Save current \"true\" value of LSTPOS\r\n\tXCHG\tDI,AX\t\t; **\r\n\tCMP\tAL,BYTE PTR LSTLIN\t; **\r\n\tPUSHF\t\t\t; **\r\n\tXCHG\tDI,AX\t\t; **\r\n\tCALL\tCDELPH\t\t; Delete chars to end of line or LSTPOS\r\n\tPOPF\t\t\t; **\r\n\tPOP\tDI\t\t; **\r\n\tJZ\tCDLGNC\t\t; **BRIF CDUNWP did not change LSTPOS\r\n\tMOV\tWORD PTR LSTLIN,DI\t; **Restore CDUNWP value of LSTPOS\r\nCDLGNC:\tOR\tAH,AH\r\n\tJNZ\tCDLGW1\t\t; BRIF still chars on this line\r\n\tPOPF\t\r\n\tJNB\tCDLGRT\t\t; BRIF LF or wrap term'd, already removed\r\nCDLGNL:\tDEC\tDL\r\n\tINC\tCL\r\n\tCALL\tSCNRTL\r\n\tJB\tCDLGN0\t\t; BRIF previous line EOL term'd, remove null line\r\n\tJZ\tCDLGRT\t\t; BRIF previous line LF term'd, leave null line\r\n\tMOV\tAL,LOW OFFSET TRMEOL\r\n\tCALL\tSCNWTT\t\t; Previous line was wrapped, terminate it and\r\n\t\t\t\t;   remove null line\r\nCDLGN0:\tINC\tDL\r\n\tDEC\tCL\r\n\tCALL\tSCRLU0\t\t; Remove null line by scrolling\r\n\tJMP\tSHORT CDLGRT\t; All done\r\n\r\nCDLGW1:\tPOPF\t\r\n\tJB\tCDLGEX\t\t; BRIF at EOL, all done\r\n\tJNZ\tCDLGWP\t\t; BRIF wrapped, unwrap chars from next line\r\n;We have terminator in (AH,AL), posn in (DH,DL)\r\nCDLGEX:\tCALL\tSCNWTT\t\t; Update terminator\r\nCDLGRT:\tADD\tCL,DL\r\n\tPOP\tDX\r\n\tMOV\tDL,CL\r\n\tRET\t\r\n\r\n\r\n\r\nCDUWXI:\tMOV\tCH,LOW 0\t; Indicate no characters unwrapped\r\n\tJMP\tCDUWPX\t\t; Indirect jump\r\n\r\n;SUBROUTINE CDUNWP:             ; \"Unwrap\" chars from next line\r\n;                       On entry:   (AH,DL)= destination\r\n;                       On exit:    (AH,AL)= new line terminator\r\n;                                   CH=nunber of bytes unwrapped\r\n;\r\nCDUNWP:\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tPUSH\tWORD PTR TRMCUR\r\n\tMOV\tAL,LOW OFFSET TRMWRP\r\n\tMOV\tCH,BYTE PTR LINLEN\r\n\tSUB\tCH,AH\r\n\tJB\tCDUWXI\t\t; BRIF no space to unwrap characters to, just exit\r\n\tCMP\tDL,BYTE PTR LSTLIN\t; **\r\n\tJNZ\tCDUWP0\t\t; **BRIF not unwrapping to LSTPOS\r\n\tTEST\tBYTE PTR LSTCOL,LOW 377O\t; **\r\n\tJNZ\tCDUWP0\t\t; **BRIF have some characters to unwrap\r\n\tMOV\tAH,BYTE PTR LINLEN\t; **\r\n\tJMP\tSHORT CDUWXI\t; **If no characters to unwrap, just exit\r\nCDUWP0:\tINC\tCH\r\n\tMOV\tBX,AX\t\t; Put DESTINATION in BX\r\n\tMOV\tBL,DL\r\n\tINC\tDL\r\n\tCALL\tSCNRTL\t\t; Read terminator for next line\r\n\tPUSH\tAX\r\n\tPUSHF\t\r\n\tCMP\tCH,AH\r\n\tJBE\tCDUWP1\t\t; BRIF enough characters to satisfy demand\r\n\tMOV\tCH,AH\t\t; Else get all characters in next line\r\nCDUWP1:\tMOV\tCL,LOW 1\r\n\tMOV\tDH,BYTE PTR WDOLFT\r\n\tMOV\tAX,DX\t\t; Put SOURCE in AX\r\n\tOR\tCH,CH\r\n\tJNZ\tCDUWPN\t\t; BRIF not a null line following\r\n\tPOPF\t\r\n\tPUSHF\t\r\n\tJZ\tCDUWP4\t\t; BRIF LF term'd, don't remove null line\r\n\tPUSH\tWORD PTR TRMCUR\r\n\tCALL\tSCRLU0\t\t; Get rid of null line following\r\n\tPOP\tWORD PTR TRMCUR\r\n\tJMP\tSHORT CDUWP4\t; Set up terminator for return\r\nCDUWPN:\r\n\tCALL\tSCROLL\t\t; Scroll chars from old line to new\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tCDUWP4\t\t; BRIF not on LSTPOS line\r\n;If LSTPOS is between WDOLFT and SOURCE+COUNT, unwrap LSTPOS\r\n\tPUSH\tAX\r\n\tADD\tAH,CH\r\n\tSUB\tAH,BYTE PTR LSTCOL\r\n\tPOP\tAX\r\n\tJBE\tCDUWP3\t\t; BRIF LSTPOS .GT. SOURCE+COUNT\r\n\tSUB\tBYTE PTR LSTCOL,AH\t; LSTCOL=DESTINATION+(LSTPOS-SOURCE)\r\n\tJNB\tCDUWPL\r\n\tMOV\tBYTE PTR LSTCOL,LOW 0\t; LSTCOL was zero, don't let it go negative\r\nCDUWPL:\tADD\tBYTE PTR LSTCOL,BH\r\n\tDEC\tBYTE PTR LSTLIN\t; LSTLIN is line unwrapped to\r\nCOMMENT\t%\r\n; Blank from DESTINATION+COUNT-((SOURCE+COUNT)-LSTPOS) to EOL\r\n\tPUSH    AX\r\n\tPUSH    DX\r\n\tPUSH    CX\r\n\tADDB    DH,CH\r\n\tSUBB    DH,AH           ; (DH,DL)=start posn for blanking\r\n\tMOVB    CH,LINLEN       ; CH=end column\r\n\tMOVI    AX,\" \"\r\nCDUWPB: CALL    SCROUT\r\n\tINCB    DH\r\n\tCMPB    DH,CH\r\n\tJBE     CDUWPB          ; Continue blanking to EOL\r\n\tPOP     CX\r\n\tPOP     DX\r\n\tPOP     AX\r\n%\r\nCDUWP3:\r\n;Return terminator for DL-1\r\nCDUWP4:\tADD\tBH,CH\t\t; Get new terminator posn into BH\r\n\tDEC\tBH\r\n\tPOPF\t\r\n\tPOP\tAX\t\t; Restore original terminators for this line\r\n\tMOV\tBL,LOW OFFSET TRMEOL\t; Assume line unwrapped is at EOL\r\n\tJB\tCDUWPE\t\t; BRIF at EOL\r\n\tMOV\tBL,LOW OFFSET TRMLNF\t; Assume LF was unwrapped on unwrapped line\r\n\tJZ\tCDUWP6\t\t; BRIF at LF\r\n;WRAP or NULL_WRAP, if BH .NE. LINLEN, then it must be LINLEN-1 and NULL_WRAP\r\nCDUWP5:\tMOV\tBL,LOW OFFSET TRMWRP\t; Assume line is WRAP\r\n\tCMP\tBH,BYTE PTR LINLEN\r\n\tJZ\tCDUWP7\t\t; Previous line is full, must be WRAP\r\n\tMOV\tBL,LOW OFFSET TRMNWP\r\n\tMOV\tBH,BYTE PTR LINLEN\r\n\tJMP\tSHORT CDUWP7\t; Previous line not full even though we had\r\n\t\t\t\t;   enough chars to fill it, must be NULL_WRAP\r\n;EOL terminated\r\nCDUWPE:\tOR\tAH,AH\r\n\tJZ\tCDUWP7\t\t; If unwrapped null line, return EOL\r\n;Was EOL or LF terminated, see if entire line was unwrapped\r\nCDUWP6:\tCMP\tAH,CH\r\n\tJNZ\tCDUWP5\t\t; BRIF wasn't unwrapped, previous line is WRAP\r\n;terminator=(BH,BL)\r\nCDUWP7:\tPUSH\tBX\r\n;       ORB     CH,CH\r\n;       JZ      CDUWP8          ; BRIF no chars to delete from here on\r\n;       MOVBI   CL,^O377        ; Set flag indicating can remove lines deleted\r\n;       CALL    CDELLG          ; Delete CH characters at (DH,DL)\r\nCDUWP8:\tPOP\tAX\r\nCDUWPX:\tPOP\tWORD PTR TRMCUR\r\n\tPOP\tDX\r\n\tMOV\tBH,CH\r\n\tPOP\tCX\r\n\tMOV\tCH,BH\r\n\tPOP\tBX\r\n\tRET\t\r\n;Needed one char and first char on next line is DBLCHR\r\nCDUWPF:\tPOP\tAX\r\n\tPOPF\t\t\t; Clean up stack\r\n\tMOV\tAH,BYTE PTR LINLEN\r\n\tMOV\tAL,LOW OFFSET TRMNWP\t; Set terminator to NULL_WRAP\r\n\tJMP\tSHORT CDUWP7\r\n\r\n\r\n\r\n;SUBROUTINE CDELPH              ; Delete chars on physical line\r\n;                       On entry:   (DH,DL)=posn to start delete from\r\n;                                   (AH,AL)=line terminator for line DL\r\n;                                   CH=count\r\n;                       On exit:    AH=term posn\r\n;                                   (DH,DL)=posn\r\n;\r\nCDELPH:\t\t\t\t;PUSH    SI\r\n\tXOR\tSI,SI\t\t; Set SI to zero(flag no char restore necessary)\r\n\tPUSH\tBX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tPUSH\tAX\r\n\tCMP\tDH,AH\r\n\tJA\tCDEL9I\t\t; BRIF delete beyond or at physical end\r\n\tMOV\tBX,DX\t\t; (BH,BL)=DESTINATION\r\n\tMOV\tAX,DX\r\n\tADD\tAH,CH\t\t; (AH,AL)=SOURCE\r\n\tPOP\tCX\t\t; CH=end of physical line\r\n\tPUSH\tCX\r\n\tCMP\tAH,CH\r\n\tJBE\tCDELP0\t\t; BRIF not deleting more than we have\r\n\tMOV\tAH,CH\r\n\tINC\tAH\t\t; Delete entire line\r\nCDELP0:\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tCDELP1\t\t; BRIF not on line with LSTPOS\r\n\tCMP\tCH,BYTE PTR LSTCOL\r\n\tJBE\tCDELP1\t\t; BRIF physical end less than LSTPOS\r\n\tMOV\tCH,BYTE PTR LSTCOL\t; Use LSTPOS as end of this line\r\n\tCMP\tDH,CH\r\n\tJA\tCDEL9I\t\t; BRIF delete beyond terminator\r\nCDELP1:\r\n\tPUSH\tCX\t\t; Save last posn of SOURCE\r\n\tSUB\tCH,AH\r\n\tPUSHF\t\r\n\tMOV\tDH,BH\r\n\tADD\tDH,CH\t\t; (DH,DL)=end of DESTINATION\r\n\tPOPF\t\r\n\tJB\tCDELP4\t\t; BRIF SOURCE greater than logical end of physical\r\n\tMOV\tCL,LOW 1\r\n\tINC\tCH\r\n\tCALL\tSCROLL\t\t; Move characters to left\r\n;Blank from end of SOURCE to end of DESTINATION+1\r\nCDELP4:\tPOP\tCX\t\t; CH=end column of SOURCE\r\n\tINC\tDH\t\t; DH=end column of DESTINATION plus one\r\n\tPUSH\tDX\r\n\tMOV\tAX,\" \"\r\nCDELP5:\tCMP\tDH,CH\r\n\tJA\tCDELP6\r\n\tCALL\tSCROUT\t\t; Blank this posn\r\n\tINC\tDH\r\n\tJMP\tSHORT CDELP5\r\nCDEL9I:\tJMP\tSHORT CDELP9\t; Indirect to CDELP9\r\nCDELP6:\tPOP\tDX\t\t; Restore end column of DESTINATION plus one\r\n\tPOP\tAX\t\t; Restore terminator passed to routine\r\n;CH=last valid column, DH=first blanking column, AH=term column, AL=term type\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tCDELP7\t\t; BRIF was not delete before LSTPOS\r\n\tCMP\tCH,BYTE PTR LSTCOL\r\n\tJB\tCDELP7\t\t; BRIF delete up to terminator\r\n;Delete included LSTPOS, subtract total deleted from LSTCOL\r\n\tPOP\tDX\r\n\tPOP\tCX\r\n\tSUB\tBYTE PTR LSTCOL,CH\r\n\tJAE\tCDEL8A\t\t; **BRIF LSTCOL valid\r\n\tMOV\tBYTE PTR LSTCOL,LOW 0\t; **Set LSTCOL to 0\r\n\tJMP\tSHORT CDEL8A\t; Delete up to LSTPOS, adjust LSTPOS\r\n;Deleted all data up to terminator, adjust terminator\r\nCDELP7:\tMOV\tAH,DH\r\n\tDEC\tAH\t\t; Set terminator to last column of DESTINATION\r\nCDELP8:\tPOP\tDX\t\t; (DH,DL)=original posn(start of DESTINATION)\r\n\tPOP\tCX\t\t; CL=flag\r\nCDEL8A:\tCMP\tDH,AH\r\n\tJBE\tCDELPX\t\t; BRIF still data remaining to right\r\n\tCMP\tDH,LOW 1\r\n\tJNZ\tCDELPX\t\t; BRIF still data remaining to left\r\n\tCMP\tAL,LOW OFFSET TRMEOL\r\n\tJZ\tCDELPX\t\t; BRIF don't remove null line\r\n;We have null line, remove it from the screen\r\n\tPUSH\tWORD PTR TRMCUR\r\n\tCMP\tDL,BYTE PTR LSTLIN\t; **If LSTPOS is wiped out, put it at\r\n\t\t\t\t; ** end of previous line\r\n\tJNZ\tCDEL8B\t\t; **BRIF not wiped out\r\n\tDEC\tBYTE PTR LSTLIN\t; **\r\n\tMOV\tBH,BYTE PTR WDOLFT\t; **\r\n\tMOV\tBYTE PTR LSTCOL,BH\t; **\r\nCDEL8B:\t\t\t\t; **\r\n\tCALL\tSCRLU0\t\t; Scroll up from bottom of screen to DL\r\n\tPOP\tWORD PTR TRMCUR\r\n\tJMP\tSHORT CDELPX\t; All done\r\n;We are deleting to right of line terminator\r\nCDELP9:\tPOP\tAX\t\t; Restore terminator passed\r\n\tCMP\tAL,LOW OFFSET TRMLNF\r\n\tMOV\tDH,AH\t\t; DH=end of valid data plus one\r\n\tJZ\tCDELP7\t\t; BRIF LF term'd, delete it\r\n\tPOP\tDX\t\t; Delete beyond valid data, ignore it\r\n\tPOP\tCX\r\nCDELPX:\tPOP\tBX\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJZ\tCDELPF\t\t; BRIF not on LSTPOS line, no update\r\n\tCMP\tAH,BYTE PTR LSTCOL\r\n\tJAE\tCDELPF\t\t; BRIF LSTPOS is within line, no update\r\n\t\t\t\t;POP     SI\r\nCDELPF:\tRET\t\r\n\tSUBTTL  CONTROL CHARACTER ROUTINES - Line append, carriage return and linefeed\r\n\r\n\r\n\r\n;Append to end of logical line\r\n;\r\nLAPPND:\r\nLAPPN0:\tCALL\tSCNRDT\r\n\tJB\tLAPPN1\t\t; BRIF we are at last line in logical\r\n\tINC\tDL\r\n\tJMP\tSHORT LAPPN0\t; See if next line is last line in logical\r\nLAPPN1:\tMOV\tDH,AH\t\t; Set current posn to EOL\r\n\tCMP\tAH,BYTE PTR LINLEN\r\n\tJNB\tLAPPN2\t\t; If end of window, advance cursor posn here\r\n\tJMP\tWCSADV\t\t; Use logical cursor advance(advances LSTPOS)\r\n;This will set the cursor posn one beyond end(wrap next char typed)\r\nLAPPN2:\tINC\tDH\r\n\tRET\t\r\n\r\n;Carriage return\r\n;\r\nLCARET:\r\n\tCALL\tSCNRDT\r\n\tJB\tLCRET1\t\t; BRIF this line already EOL terminated\r\n\tJZ\tLCRET0\t\t; BRIF LF terminated\r\n\tCMP\tAL,LOW OFFSET TRMNWP\r\n\tJNZ\tLCRET1\t\t; BRIF not NULL_WRAP terminated\r\nLCRET0:\tDEC\tAH\t\t; Do not include LF or NULL_WRAP in line\r\nLCRET1:\tMOV\tAL,LOW OFFSET TRMEOL\r\n\tCALL\tSCNWTT\t\t; Make this line EOL terminated\r\n\tMOV\tDH,BYTE PTR WDOLFT\t; And move posn to left margin\r\n\tRET\t\r\n\r\n;Line feed\r\n;\r\nLFEED:\tMOV\tSI,0\r\n\tTEST\tBYTE PTR F_CRET,LOW 377O\r\n\tJZ\tLFD90I\t\t; BRIF LF following CR\r\n\tTEST\tBYTE PTR F_INST,LOW 377O\r\n\tJZ\tLFED30\t\t; BRIF not insert mode\r\n\tCALL\tSCNRTL\r\n\tCMP\tAH,DH\r\n\tJB\tLFED30\t\t; Inserting beyond end of physical(just append)\r\n;Insert mode, move characters from cursor to EOL onto the next line\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJZ\tCBEPI2\t\t; BRIF on LSTPOS line, can't do insert LF\r\n; IMPROVEMENT: Find last physical in this logical and see if it can be moved\r\n;   down one line. If not, abort before any inserts\r\nLFED10:\r\n\tCLC\t\t\t; Indicate call is from Screen Editor\r\n\tCALL\tSCRINP\r\n\tMOV\tSI,AX\t\t; Save first char in SI\r\n\tMOV\tAX,\" \"\r\n\tCALL\tSCROUT\r\n\tPUSH\tDX\r\nLFED12:\tMOV\tCH,LOW 1\r\n\tCALL\tMKRMCH\t\t; Move everything over one\r\n\tINC\tDH\r\n\tCMP\tDH,BYTE PTR LINLEN\r\n\tJBE\tLFED12\t\t; Keep going until the end of the line\r\n\tMOV\tAH,DL\r\n\tPOP\tDX\t\t; Restore posn\r\n\tMOV\tDL,AH\r\n\tCALL\tPLINIT\t\t; Terminate line at current posn\r\n\tCMP\tDL,BYTE PTR WDOBOT\r\n\tJNZ\tLFED43\t\t; Change terminator to LF and goto next line\r\n\tJMP\tLFEEDX\r\n;No room!!\r\nCBEEPI:\tPOPF\t\t\t; Clean stack\r\nCBEPI2:\tJMP\tCBEEP\r\nLFD90I:\tJMP\tSHORT LFED90\t; Indirect jump to LFED90\r\n;Insert beyond end of physical=append\r\n; Append LF to end of physical line\r\nLFED30:\tCALL\tSCNRTL\r\n\tPUSHF\t\r\n\tJB\tLFED31\t\t; BRIF need one more space to output LF\r\n\tJZ\tLFED32\t\t; BRIF already LF terminated, don't need space\r\nLFED31:\tINC\tAH\t\t; Need one more space at terminator posn\r\nLFED32:\tCMP\tAH,BYTE PTR LINLEN\r\n\tJBE\tLFED40\t\t; BRIF have room on this line\r\n\tCALL\tLFWRAP\t\t; Wrap linefeed to next line\r\n\tJB\tLFED69\t\t; BRIF no room\r\n;The possibilities at this point are WRAP or EOL terminated\r\n\tPOPF\t\r\n\tJNB\tLFED34\t\t; BRIF not EOL term'd(no change to terminator)\r\n\tCALL\tSCNRDT\r\n\tMOV\tAH,BYTE PTR LINLEN\t; EOL terminated, change to WRAP at LINLEN\r\n\tMOV\tAL,LOW OFFSET TRMWRP\r\n\tCALL\tSCNWTT\r\nLFED34:\tMOV\tDH,BYTE PTR WDOLFT\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tLFED35\t\t; BRIF not extending LSTPOS\r\n\tINC\tBYTE PTR LSTLIN\t; Move LSTPOS with LF\r\n\tMOV\tBYTE PTR LSTCOL,DH\r\nLFED35:\tINC\tDL\t\t; Move to new line(created by MKRMNL above)\r\n\tMOV\tAH,DH\r\n\tJMP\tSHORT LFED43\r\nLFED40:\tPOPF\t\r\n\tJNB\tLFED42\t\t; BRIF not EOL, just change terminator to LF\r\nLFED41:\tCALL\tMKRMNL\t\t; Open up next line\r\n\tJB\tLFEEDX\t\t; No room for LF\r\n;SUCCESS: terminate current line with LF\r\nLFED42:\tMOV\tDH,AH\r\n\tMOV\tAX,\" \"\r\n\tCALL\tSCROUT\t\t; Put a blank at terminator posn\r\nLFED43:\tCALL\tSCNRDT\t\t; Reread terminator in case of MKRMNL scroll up\r\n\tMOV\tAH,DH\r\n\tMOV\tAL,LOW OFFSET TRMLNF\r\n\tCALL\tSCNWTT\t\t; And terminate line with LF\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tLFED95\t\t; BRIF no LSTPOS update\r\n\tMOV\tBYTE PTR LSTCOL,LOW 0\t; LSTPOS moves to line beyond linefeed\r\n\tINC\tBYTE PTR LSTLIN\r\n\tJMP\tSHORT LFED95\r\nLFED90:\tPUSH\tSI\r\n\tCALL\tMKRMNL\t\t; Open up next line\r\n\tPOP\tSI\r\n\tJB\tLFEEDX\t\t; No room\r\nLFED95:\tCALL\tCSRDWN\t\t; Move to next line\r\n\tMOV\tDH,BYTE PTR WDOLFT\r\n\tOR\tSI,SI\r\n\tJZ\tLFEEDX\r\n\tMOV\tAX,SI\r\n\tCALL\tSCROUT\t\t; Restore first char of insert linefeed\r\nLFEEDX:\tCMP\tDL,BYTE PTR WDOBOT\r\n\tJBE\tLFEEDZ\r\n\tMOV\tDL,BYTE PTR WDOBOT\r\nLFEEDZ:\tRET\t\r\n;No room for linefeed, terminate this line and exit\r\nLFED69:\tPOP\tAX\r\n\tJMP\tSHORT LFEEDX\r\n\tSUBTTL  CONTROL CHARACTER ROUTINES - Insert and MKRMCH\r\n\r\n\r\nLINSRT:\tXOR\tBYTE PTR F_INST,LOW 377O\t;Toggle insert flag\r\n\tRET\t\r\n\r\n;SUBROUTINE MKRMCH              ; This routine opens up space in logical lines\r\n;**                     On entry:   (DH,DL)=posn to open space\r\n;**                                 CH=number of spaces to open(1 or 2)\r\n;**                     On exit:    (DH,DL)=same posn(DL value can change)\r\n;**\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tBUF:WORD\r\nDSEG\tENDS\r\nMKRMCH:\tPUSH\tSI\r\n\tPUSH\tAX\r\n\tPUSH\tCX\r\n\tPUSH\tDX\r\n\tMOV\tSI,OFFSET BUF\r\n\tMOV\tDI,OFFSET BUF+128D\t; SI and DI are overflow character buffers\r\n\tCALL\tSCNRDT\r\n\tPUSHF\t\r\n\tPUSH\tAX\r\n\tCALL\tMVCHLN\t\t; Move characters over put overflow at [DI]\r\n\tXOR\tCL,CL\t\t; CL=Iteration depth(and count of physical lines)\r\nMKRMC0:\tOR\tCH,CH\r\n\tJNZ\tMKRMC1\t\t; BRIF line overflowed\r\n\tPOP\tAX\r\n\tPOPF\t\r\nMKRMCX:\tADD\tCL,DL\t\t; CL=original line number\r\n\tPOP\tDX\t\t; DH=orginal column\r\n\tMOV\tDL,CL\t\t; DL=original line number\r\nMKRMX2:\tPOP\tCX\r\n\tPOP\tAX\r\n\tPOP\tSI\r\n\tRET\t\r\n;Line overflow we must wrap char to next line\r\nMKRMC1:\tPOP\tAX\r\n\tPOPF\t\t\t; Get back old terminator\r\n\tJB\tMKRMC3\t\t; BRIF was EOL term'd\r\n\tJNZ\tMKRMC4\t\t; BRIF was WRAP or NULL_WRAP term'd\r\n;Linefeed, make room for linefeed on next line\r\n\tPUSH\tAX\r\n\tCALL\tLFWRAP\r\n\tPOP\tAX\r\n\tJB\tMKRMCQ\t\t;  No room, throw away overflow\r\n\tDEC\tCH\r\n\tJZ\tMKRMCX\t\t; Only wrapped the linefeed, done\r\n\tJMP\tSHORT MKRMC4\t; Pass overflow to next line\r\n;EOL terminatedd\r\nMKRMC3:\tPUSH\tAX\r\n\tCALL\tMKRMNL\t\t; Open up next line for overflow\r\n\tPOP\tAX\r\n\tJNB\tMKRMC4\t\t; BRIF room, wrap overflow\r\n;No room for wrap, terminate this line with EOL and exit\r\nMKRMCQ:\tCALL\tSCNRDT\r\n\tMOV\tAL,LOW OFFSET TRMEOL\r\n\tCALL\tSCNWTT\t\t; No room for overflow, just terminate line\r\n\tJMP\tSHORT MKRMCX\r\n;Insert overflow on next line\r\nMKRMC4:\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tMKRMC6\t\t; BRIF not on LSTPOS line\r\n;AH=Old terminator posn, CH=Overflow count\r\n\tSUB\tAH,CH\r\n\tCMP\tAL,LOW OFFSET TRMNWP\r\n\tJNZ\tMKRMC5\t\t; BRIF wasn't NULL_WRAP, don't adjust posn\r\n\tDEC\tAH\r\n;AH=First position wrapped - 1\r\nMKRMC5:\tCMP\tAH,BYTE PTR LSTCOL\r\n\tJAE\tMKRMC6\t\t; BRIF did not wrap LSTCOL\r\n;Wrapped LSTPOS\r\n\tMOV\tBYTE PTR LSTCOL,LOW 0\t; Set LSTPOS to start of next line\r\n\tINC\tBYTE PTR LSTLIN\r\nMKRMC6:\tINC\tDL\t\t; (DH,DL)=start of next line\r\n\tMOV\tDH,BYTE PTR WDOLFT\r\n\tDEC\tCL\t\t; Decrement interation counter\r\n\tXCHG\tSI,DI\t\t; Use other overflow buffer for this line\r\n\tCALL\tSCNRDT\r\n\tPUSHF\t\r\n\tPUSH\tAX\r\n\tPUSH\tCX\t\t; Save char count\r\n\tCALL\tMVCHLN\t\t; Make room on this line for previous overflow\r\n\tMOV\tBX,CX\t\t; Save count of overflow\r\n\tPOP\tCX\t\t; Get back overflow count in CH\r\n\tPUSH\tSI\t\t; Save pointer to characters for insertion\r\n;Loop to output characters which overflowed onto this line from previous line\r\nMKRMC7:\tCLD\t\t\t; Scan forwards\r\n\tLODSW\t\t\t; Get a character\r\n\tCALL\tSCROUT\t\t; Output it\r\n\tINC\tDH\r\n\tSUB\tCH,LOW 1\r\n\tJA\tMKRMC7\t\t; Output the next char\r\n\tPOP\tSI\r\n\tMOV\tCH,BH\t\t; Restore overflow count for this line\r\n\tJMP\tSHORT MKRMC0\t; Wrap new overflow\r\n\r\n;Wrap a linefeed to next line\r\nLFWRAP:\tINC\tDL\r\n\tCALL\tMKRMNL\r\n\tJB\tLFWPEX\t\t;  room, throw away overflow\r\n\tPUSH\tDX\r\n\tCALL\tSCRDLN\t\t; Scroll this line down to next\r\n\tPOP\tDX\r\n\tCALL\tLFTERM\t\t; Make this line LF term'd\r\n\tCLC\t\r\nLFWPEX:\tDEC\tDL\t\t; Restore original line number\r\n\tRET\t\r\n\r\n;SUBROUTINE MVCHLN              ; Open up space in physical line\r\n;**                     On entry:   (DH,DL)=posn to open space at\r\n;**                                 SI=address of buffer to put overflow chars\r\n;**                     On exit:    (DH,DL)=same posn(DL might change if scroll)\r\n;**                                 CH=No. of bytes overflowed\r\n;**                                 BX destroyed\r\n;**\r\nMVC30I:\tJMP\tMVCH30\r\n;MVC80I: JMP     MVCH80\r\nMVCHLN:\tPUSH\tDI\r\n\tPUSH\tCX\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tMOV\tCL,BYTE PTR LINLEN\r\n\tJNZ\tMVCH00\t\t; BRIF within logical EOL(unless beyond TERM_POS)\r\n\tMOV\tCL,BYTE PTR LSTCOL\r\nMVCH00:\tCALL\tSCNRTL\t\t; AX=current physical terminator\r\n\tCMP\tAH,DH\r\n\tJB\tMVC30I\t\t; BRIF inserting beyond end of physical\r\n\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tMVCH03\r\n\tCMP\tCL,AH\r\n\tJNB\tMVCH03\t\t; BRIF LSTPOS .GTE. TERM_POSN\r\n\tMOV\tAH,CL\t\t; Else use LSTPOS as TERM_POSN\r\n;We are inserting before end of physical line and LSTPOS .GTE. TERM_POSN\r\nMVCH03:\tPUSH\tDX\r\n\tPUSH\tAX\r\n\tADD\tCH,AH\t\t; CH=last column for space needed\r\n\tSUB\tCH,BYTE PTR LINLEN\r\n\tJA\tMVCH10\t\t; BRIF overflow\r\n\tXOR\tBH,BH\t\t; Indicate no overflow\r\n\tJMP\tSHORT MVCH20\r\n;We have overflow bytes to save\r\nMVCH10:\tMOV\tDH,AH\r\n\tSUB\tDH,CH\r\n\tINC\tDH\t\t; DH=column of first overflow to save\r\n\tCLC\t\t\t; Indicate call is from Screen Editor\r\n\tCALL\tSCRINP\t\t; Read an overflow char\r\n\tMOV\tBX,CX\t\t; Save overflow count in BH\r\n;Loop to move overflow character to save buffer\r\nMVCH14:\tCLD\t\r\n\tSTOSW\t\t\t; Save overflow char\r\n\tDEC\tCH\r\n\tJZ\tMVCH20\t\t; All done with overflow save\r\n\tINC\tDH\r\n\tCLC\t\t\t; Indicate call is from Screen Editor\r\n\tCALL\tSCRINP\t\t; Read an overflow char\r\n\tJMP\tSHORT MVCH14\t; And save it\r\n;Move characters in line over\r\nMVCH20:\tMOV\tCX,BX\t\t; Restore # bytes overflowed to CH\r\n\tPOP\tAX\t\t; AH=term posn\r\n\tSUB\tAH,CH\t\t; Adjust term posn so move doesn't overflow\r\n\tPOP\tDX\t\t; DH=start column of insert\r\n\tPOP\tBX\t\t; BH=number of bytes to move over\r\n\tMOV\tCL,BL\r\n\tPUSH\tCX\t\t; Save overflow count and CL for restore on exit\r\n\tMOV\tCH,AH\t\t; CH=last column to move\r\n\tSUB\tCH,DH\r\n\tINC\tCH\t\t; CH=count of chars from CURPOS to TERMPOS\r\n\tPUSHF\t\r\n\tMOV\tCL,LOW 1\t; Move on one line\r\n\tMOV\tAX,DX\t\t; FROM=CURPOS\r\n\tMOV\tBL,DL\r\n\tADD\tBH,DH\t\t; TO=CURPOS+COUNT\r\n\tPOPF\t\r\n\tJNZ\tMVCH21\t\t; BRIF count not zero, do move\r\n\tMOV\tBH,DH\t\t; All characters to move overflowed\r\n\tJMP\tSHORT MVCH22\t; Just update terminator to current posn\r\nMVCH21:\tCALL\tSCROL2\t\t; Move over characters\r\n\tADD\tBH,CH\t\t; New TERMPOS=TO+number of characters moved\r\n\tDEC\tBH\r\nMVCH22:\tPOP\tCX\t\t; CH=-(No. of bytes wrapped)\r\n;CH=overflow count, CL=insert count, BH=terminator posn\r\nMVCH23:\tCALL\tSCNRDT\r\n\tJB\tMVCH25\r\n\tJZ\tMVCH25\r\n;We have wrapped chars, terminate either WRAP or NULL_WRAP\r\nMVCH24:\tCMP\tBH,BYTE PTR LINLEN\r\n\tMOV\tAL,LOW OFFSET TRMWRP\r\n\tJZ\tMVCH26\r\n\tOR\tCH,CH\r\n\tJZ\tMVCH26\r\n\tMOV\tAL,LOW OFFSET TRMNWP\t; Null wrap that does not overflow changes to wrap\r\n\tMOV\tBH,BYTE PTR LINLEN\r\n\tPUSH\tAX\r\n\tPUSH\tDX\r\n\tMOV\tDH,BH\r\n\tMOV\tAX,\" \"\t\t; Blank DBLCHR destroyed by scroll\r\n\tCALL\tSCROUT\r\n\tPOP\tDX\r\n\tPOP\tAX\r\n\tJMP\tSHORT MVCH26\r\n;Was EOL or LF terminated\r\nMVCH25:\tOR\tCH,CH\r\n\tJNZ\tMVCH24\t\t; Overflow means WRAP or NULL_WRAP\r\nMVCH26:\tCMP\tAH,BH\r\n\tJA\tMVCH27\t\t; Terminator beyond scroll end\r\n\tMOV\tAH,BH\r\n;AH=New terminator, CL=insert count\r\n\tCALL\tSCNWTT\t\t; Update terminator\r\nMVCH27:\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tMVCHEX\t\t; BRIF move is not on LSTPOS line\r\n\tCMP\tBH,BYTE PTR LSTCOL\r\n\tJBE\tMVCHEX\t\t; BRIF end of move is before LSTPOS\r\n\tMOV\tBYTE PTR LSTCOL,BH\t; Else add number moved over to LSTPOS\r\nMVCHEX:\tPOP\tDI\r\n\tRET\t\r\n;Inserting beyond end of logical\r\nMVCH30:\tMOV\tCL,CH\t\t; Save insert count in CL\r\n\tADD\tCH,DH\t\t; CH=end of insert\r\n\tCMP\tAL,LOW OFFSET TRMLNF\r\n\tJZ\tMVCH31\t\t; BRIF LF term'd cannot push null off end\r\n\tDEC\tCH\t\t; Ignore one null push off end of physical\r\nMVCH31:\tCMP\tCH,BYTE PTR LINLEN\r\n\tJBE\tMVCH33\t\t; BRIF have room\r\n;No room, return blanks overflow, update terminator\r\n\tSUB\tCH,BYTE PTR LINLEN\t; CH=No. of overflow bytes\r\n\tMOV\tAX,\" \"\r\n\tPUSH\tCX\r\nMVCH32:\tCLD\t\t\t; Store overflow bytes(All blanks)\r\n\tSTOSW\r\n\tDEC\tCH\r\n\tJNZ\tMVCH32\r\n\tPOP\tCX\t\t; Restore CH=number of overflow bytes\r\n\tPOP\tBX\r\n\tMOV\tBH,CH\r\n\tPUSH\tBX\t\t; Put overflow count with original CL on stack\r\n\tMOV\tBH,BYTE PTR LINLEN\t; BH=term posn, CH=overflow count, CL=insert count\r\n\tJMP\tSHORT MVCH23\t; Update terminator and LSTPOS, exit\r\n;Have room, just update terminator\r\nMVCH33:\tPOP\tBX\r\n\tMOV\tBH,LOW 0\t; Put overflow count(=0) on stack for return\r\n\tXCHG\tBH,CH\t\t; BH=term posn, CH=overflow count, CL=insert count\r\n\tJMP\tSHORT MVCH23\t; New term posn still .LTE. LINLEN\r\nCOMMENT\t%\r\n;On LSTLIN, possibly insert to LSTPOS or LSTPOS+COUNT\r\n;N.B. We are guaranteed to be at a posn to left of TERM_POS\r\n;Two cases: insert up to LSTPOS or insert up to LSTPOS+COUNT\r\nMVCH80: PUSH    DX\r\n\tPUSH    CX\r\n\tPUSH    AX\r\n\tMOVB    CL,AH           ; Save TERM_POS in CL for compare\r\n\tMOVB    DH,LSTCOL\r\n;Scan from LSTPOS+1 to lesser of (LSTPOS+COUNT,TERM_POS) or non-blank character\r\nMVCH81: INCB    DH              ; Next column\r\nIFN     IBMLIK,<\r\n\tCLC                     ; Indicate call is from Screen Editor\r\n>                               ; IFN IBMLIK\r\n\tCALL    SCRINP          ; AX=character at this posn\r\nIFN     DBLCHR,<\r\n\tJNB     MVCH82          ; BRIF not reading second of double byte char\r\n\tINCB    DH              ; Restore DH(SCRINP decremented it)\r\n>                               ; IFN DBLCHR\r\nMVCH82: CMPI    AX,\" \"\r\n\tJNZ     MVCH86          ; Found non-blank\r\n\tCMPB    DH,CL\r\n\tJAE     MVCH84          ; At TERM_POS\r\nMVCH83: DECB    CH\r\n\tJNZ     MVCH81          ; Not at LSTPOS+COUNT, continue scan\r\n;Insert to LSTPOS+COUNT [;or TERM_POS+COUNT, whichever is smaller]\r\nMVCH84: POP     AX\r\n\tPOP     CX\r\n\tPOP     DX\r\n\tMOVB    AH,LSTCOL       ; Change end of FROM insert window to LSTPOS\r\nMVCH85: JMP     MVCH03          ; Insert to LSTPOS\r\n;Insert to last blank after LSTPOS\r\nMVCH86: POP     AX              ; AX=current terminators\r\n\tPOP     BX              ; BH=Count desired\r\n\tMOVB    CH,DH           ; CH=end of TO insert window\r\n\tDECB    CH\r\n\tPOP     DX              ; (DH,DL)=current posn\r\n\tADDB    BH,DH           ; BH=start of TO insert window\r\n\tSUBB    CH,BH           ; CH=character count to move\r\n\tJB      MVCH89          ; BRIF at end, just overwrite last char\r\n\tINCB    CH\r\n\tMOVBI   CL,1            ; Move on one line\r\n\tMOVB    BL,DL           ; (BH,BL)=start of TO window\r\n\tMOV     AX,DX           ; (AH,AL)=start of FROM window\r\nIFN     DBLCHR,<\r\n\tPUSH    DX\r\n\tPUSH    AX\r\n\tMOV     DX,AX\r\n\tADDB    DH,CH\r\nIFN     IBMLIK,<\r\n\tCLC                     ; Indicate call is from Screen Editor\r\n>                               ; IFN IBMLIK\r\n\tCALL    SCRINP          ; Are we going to scroll half of a double byte char?\r\n\tMOVI    AX,\" \"\r\n\tJNB     MVCH88\r\n\tINCB    DH\r\nMVCH88: CALL    SCROUT          ; Obliterate double byte char scrolled on top of\r\n\tPOP     AX\r\n\tPOP     DX\r\n>                               ; IFN DBLCHR\r\n\tCALL    SCROL2          ; Move characters over\r\nMVCH89: POP     CX\r\n\tXORB    CH,CH           ; No characters wrapped\r\n\tJMP     MVCHEX          ; All done\r\n%\r\n;SUBROUTINE SCROL2              ; Used by insert code to move over chars in line\r\n;                           On entry:   AH,BH,CH=scroll parameters\r\n;\r\n\tSCROL2\tEQU\tSCROLL\t; No DBLCHR save/restore\r\n;SUBROUTINE SCNRTL              ; Read logical terminator for physical line\r\n;**                     On entry:   DL=line number\r\n;**                     On exit:    AX=terminators\r\n;**                                 CF set indicates EOL terminator\r\n;**                                 CF clear, ZF set indicates LF terminator\r\n;**                                 If NULL_WRAP terminator AH=TERM_POS-1\r\nSCNRTL:\tCALL\tSCNRDT\t\t; Get terminators\r\n\tJB\tSCNRT2\t\t; BRIF not NULL_WRAP\r\n\tJZ\tSCNRT2\t\t; BRIF not NULL_WRAP\r\n\tPUSHF\t\r\n\tCMP\tAL,LOW OFFSET TRMNWP\r\n\tJNZ\tSCNRT1\t\t; BRIF not NULL_WRAP\r\n\tDEC\tAH\t\t; Is NULL_WRAP, decrement posn\r\nSCNRT1:\tPOPF\t\r\nSCNRT2:\tRET\t\r\n\r\n;Wrap a linefeed(already a successful MKRMNL)\r\nLFTERM:\tPUSH\tWORD PTR TRMCUR\r\n\tPUSH\tAX\r\n\tCALL\tSCNRDT\t\t; Read next line terminator\r\n\tMOV\tAL,LOW OFFSET TRMLNF\r\n\tMOV\tAH,BYTE PTR WDOLFT\r\n\tCALL\tSCNWTT\t\t; Write out LF terminator at left margin plus one\r\n\tPOP\tAX\r\n\tPOP\tWORD PTR TRMCUR\r\n\tRET\t\r\n\tSUBTTL CURSOR MOVEMENT within window\r\n\r\n\r\n\r\n;       These routines return CF=1 when they do not change the posn.\r\n;\r\n;Cursor right within window(or within physical line if outside window)\r\nCSRADV:\tINC\tDH\t\t; Next column\r\n\tCMP\tBYTE PTR LINLEN,DH\r\n\tJAE\tCSRRET\t\t; BRIF Good value\r\n\tDEC\tDH\r\n\tCALL\tCSRDWN\r\n\tJB\tCSRRET\t\t; BRIF can't change physical lines\r\n\tMOV\tDH,BYTE PTR WDOLFT\t; First column\r\nCSRRET:\tRET\t\r\n\r\n;Cursor left within window(or within physical line if outside window)\r\nCSRREG:\tDEC\tDH\t\t; Previous column\r\n\tCMP\tDH,BYTE PTR WDOLFT\r\n\tJNB\tCSRRET\t\t; BRIF good value\r\n\tINC\tDH\t\t; Restore column\r\n\tCALL\tCSRUP\r\n\tJB\tCSRRET\t\t; BRIF can't change physical lines\r\n\tMOV\tDH,BYTE PTR LINLEN\t; Last column\r\n\tRET\t\r\n\r\n;Cursor up within window(or NOP if outside window)\r\nCSRUP:\tCMP\tBYTE PTR WDOBOT,DL\r\n\tJB\tCSRRET\t\t; BRIF outside of window\r\n\tCMP\tDL,BYTE PTR WDOTOP\r\n\tJB\tCSRRET\r\n\tSTC\t\r\n\tJZ\tCSRRET\t\t; BRIF at top or outside of window\r\n\tCLC\t\r\n\tDEC\tDL\r\n\tRET\t\r\n\r\n;Cursor down within window(or NOP if outside window)\r\nCSRDWN:\tCMP\tDL,BYTE PTR WDOTOP\r\n\tJB\tCSRRET\t\t; BRIF outside window\r\n\tCMP\tBYTE PTR WDOBOT,DL\r\n\tJB\tCSRRET\t\t; BRIF at bottom or outside of window\r\n\tSTC\t\r\n\tJZ\tCSRRET\r\n\tCLC\t\r\n\tINC\tDL\t\t; Next line\r\n\tRET\t\r\n\tSUBTTL CURSOR MOVEMENT within logical line\r\n\r\n\r\n\r\n;Cursor advance within logical line\r\n;                   on entry:   DH=current column, DL=current line\r\n;                   on exit:    If CF clear, DH=new column, DL=new line\r\n;                                   Else DH=EOL column, DL=EOL line\r\n;                                   ZF=1 if stop at LSTPOS\r\n;                               AH=terminator column, AL=terminator value\r\n;\r\nLCSADV:\tCMP\tDL,BYTE PTR LSTLIN\r\n\tJNZ\tLCSAD0\t\t; BRIF not at LSTPOS\r\n\tCMP\tDH,BYTE PTR LSTCOL\r\n\tJB\tLCSAD0\t\t; BRIF not at LSTPOS\r\n\tCALL\tSCNRDT\r\n\tCMP\tAH,AH\t\t; Set ZF=1 if stop at LSTPOS\r\n\tSTC\t\r\nLCSADX:\tRET\t\r\nLCSAD0:\tCALL\tSCNRDT\r\n\tJB\tLCSAD2\t\t; BRIF at last line\r\nLCSAD1:\tCALL\tCSRADV\r\n\tJB\tLCSADA\t\t; BRIF at end of window\r\n\tCMP\tAH,DH\r\n\tJNB\tLCSADX\t\t; BRIF within logical line\r\n\tINC\tDL\r\n\tMOV\tDH,BYTE PTR WDOLFT\t; Else wrap to next physical of logical\r\n\tCLC\t\r\n\tRET\t\r\nLCSAD2:\tCMP\tAH,DH\r\n\tJA\tLCSAD1\t\t; BRIF not at EOL or beyond\r\nLCSADA:\tOR\tDH,DH\t\t; ZF=1(not stop at LSTPOS)\r\n\tSTC\t\r\n\tRET\t\r\n;Cursor regress within logical line\r\n;                   on entry:   DH=current column, DL=current line\r\n;                   on exit:    If CF clear, DH=new column, DL=new line\r\n;                                   Else DH=EOL column, DL=EOL line\r\n;                                   If stop at FSTPOS, ZF is set\r\n;\r\nLCSREG:\tCMP\tDL,BYTE PTR FSTLIN\r\n\tJNZ\tLCSRG0\t\t; BRIF not at FSTPOS\r\n\tCMP\tDH,BYTE PTR FSTCOL\r\n\tJA\tLCSRG0\t\t; BRIF not at FSTPOS\r\n\tSTC\t\r\n\tRET\t\t\t; ZF=1, CF=1, stop at FSTPOS\r\nLCSRG0:\tPUSH\tBX\r\n\tMOV\tBX,DX\r\n\tCALL\tCSRREG\r\n\tJB\tLCSRGA\t\t; BRIF at top of window\r\n\tCMP\tBL,DL\r\n\tJZ\tLCSRGX\t\t; BRIF on same line, must be good posn\r\n\tCALL\tSCNRDT\r\n\tJNB\tLCSRGX\t\t; BRIF still on same logical line\r\n\tMOV\tDL,BL\t\t; Move back to line we were on\r\n\tMOV\tDH,BYTE PTR WDOLFT\t; And posn at start of that line\r\nLCSRGA:\tOR\tDH,DH\t\t; ZF=0(not stop at FSTPOS)\r\n\tSTC\t\r\nLCSRGX:\tPOP\tBX\r\n\tRET\t\t\t; Return CF set(at EOL)\r\n\r\nLSTART:\r\nLSTRT0:\tCMP\tDL,BYTE PTR FSTLIN\r\n\tJZ\tLSTRT1\r\n\tCALL\tCSRUP\r\n\tJB\tLSTRT1\t\t; Top of window must be start of line\r\n\tCALL\tSCNRDT\r\n\tJNB\tLSTRT0\t\t; BRIF this line is part of logical\r\n\tINC\tDL\r\nLSTRT1:\tMOV\tDH,BYTE PTR WDOLFT\r\n\tJB\tLSTRTX\t\t; BRIF not using FSTPOS, use left margin\r\n\tMOV\tDH,BYTE PTR FSTCOL\r\nLSTRTX:\tRET\t\r\n\tSUBTTL  MISCELLANEOUS ROUTINES\r\n\r\n\r\n\r\n;*********************************************************\r\n;CHECK FOR WORD OR NON-WORD CHAR(ALPHA NUMERIC)\r\n;\r\nANCHK:\tPUSH\tDX\r\n\tCLC\t\t\t; Indicate call is from Screen Editor\r\n\tCALL\tSCRINP\t\t; Read character at current posn in DX\r\n\tJNB\tANCH0\t\t; BRIF DH was not decremented\r\n\tINC\tDH\r\nANCH0:\tOR\tAH,AH\r\n\tJNZ\tANCNO\t\t; BRIF is two-byte character - reject\r\n\tCMP\tAL,LOW 60O\r\n\tJB\tANCNO\t\t; BRIF is not alpha-numeric\r\n\tCMP\tAL,LOW 72O\r\n\tJB\tANYES\t\t; BRIF is numeric\r\n\tCMP\tAL,LOW 101O\r\n\tJB\tANCNO\t\t; BRIF is not alpha-numeric\r\n\tCMP\tAL,LOW 133O\r\n\tJB\tANYES\t\t; BRIF is alpha\r\n\tCMP\tAL,LOW 141O\r\n\tJB\tANCNO\t\t; BRIF is not alpha-numeric\r\n\tCMP\tAL,LOW 173O\r\n\tJB\tANYES\t\t; BRIF is small alpha\r\nANCNO:\tSTC\t\r\n\tPOP\tDX\r\n\tRET\t\r\n\r\nANYES:\tCLC\t\r\n\tPOP\tDX\r\n\tRET\t\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "SCNEDT.ASM",
          "type": "blob",
          "size": 12.875,
          "content": "; [ This translation created 10-Feb-83 by Version 4.3 ]\r\n\r\n\t.RADIX  8\t\t; To be safe\r\n\r\nCSEG\tSEGMENT PUBLIC 'CODESG' \r\n\tASSUME  CS:CSEG\r\n\r\nINCLUDE\tOEM.H\r\n\r\n\tTITLE   SCNEDT  Screen Oriented Editor for GW-BASIC\r\n\tSUBTTL  DATA DEFINITIONS\r\n\r\n\r\nCOMMENT\t*\r\n        --------- --- ---- -- ---------\r\n        COPYRIGHT (C) 1982 BY MICROSOFT\r\n        --------- --- ---- -- ---------\r\n        *\r\n\r\n\tINCLUDE\tGIO86U\r\n\t.RADIX\t8\r\n\t.SALL\r\n\r\n;OEM IFNDEF'S:\r\nMELCO=0\r\nHAL=0\r\n\r\n;GENERIC IFNDEF'S:\r\nTERMSW=0\r\nHLPTRP=0\r\nSTPTRP=0\r\nHLPEDT=0\r\nSCRKEY=0\r\nNMPAGE=0\r\nIBMCSR=IBMLIK\r\n\r\n\r\n\r\n;INTERNAL ROUTINES:\r\n\r\n\tPUBLIC\tPINLIN\t\t; Program line input\r\n\t\t\t\t;on exit:       BX=addr of input -1\r\n\r\n\tPUBLIC\tINLIN\t\t; BASIC INPUT Statements line input\r\n\t\t\t\t;on exit:       BX=addr of input -1\r\n\r\n\tPUBLIC\tSINLIN\t\t; BASIC INPUT Statements redo line input\r\n\t\t\t\t;on exit:       BX=addr of input -1\r\n\r\n\tPUBLIC\tQINLIN\t\t; BASIC INPUT Statements with output of \"?\" first\r\n\t\t\t\t;on exit:       BX=addr of input -1\r\n\r\n\tPUBLIC\tSCNSEM\t\t; BASIC INPUT statement scan for semicolon\r\n\t\t\t\t;on exit:       SEMFLG flag set\r\n\tPUBLIC\tEDTBRK\t\t; BASIC received break, reinitialize routine\r\n\r\n\tPUBLIC\tERREDT\t\t; BASIC Syntax error auto-edit on ERRLIN\r\n\t\t\t\t;on exit:       Removes return and jumps to MAIN after\r\n\t\t\t\t;               listing ERRLIN and positioning cursor at\r\n\t\t\t\t;               start of line.\r\n\r\n\tPUBLIC\tEDIT\t\t; EDIT Statement\r\n\t\t\t\t;on exit:       Same as ERREDT, except takes line number\r\n\t\t\t\t;               to list as argument.\r\n\r\n;       INTERN  EDITRT          ; AUTO Program line input processing\r\n\t\t\t\t;on exit:       BX=addr of input(BUF)\r\n\t\t\t\t;               it also puts PSW on stack with carry\r\n\t\t\t\t;               set and jumps to EDENT for exit\r\n\r\n\r\n;EXTERNAL ROUTINES:\r\n\r\n\tEXTRN\tOUTDO:NEAR\t; Character output(GIO86)\r\n\tEXTRN\tKEYIN:NEAR\t; Key input(expands any string keys-GIOKYB)\r\n\tEXTRN\tSCNMRK:NEAR\t; Mark current posn as start of line(SCNDRV)\r\n\tEXTRN\tSCNRDL:NEAR\t; Read current logical line(SCNDRV)\r\n\tEXTRN\tCRDO:NEAR\t; BASIC new line routine\r\n\tEXTRN\tCHRGTR:NEAR\t; BASIC character scan routine\r\n\r\n;DATA (DEFINED IN RAM MODULE)\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\t\t\r\n\tASSUME DS:DSEG\r\n\tEXTRN\tF_EDPG:WORD\t; Flag - =^O377 indicates program statement edit\r\n\tEXTRN\tSEMFLG:WORD\t; Flag - zero indicates INPUT; statement(no crlf\r\n\t\t\t\t;       at end of input line)\r\n\tEXTRN\tF_INST:WORD\t; Flag - =^O377 indicates insert mode\r\n\tEXTRN\tBUF:WORD\t; Buffer where line of data is returned\r\n\t\t\t\t;   NOTE: assumes non-blank at BUF-1\r\n\tEXTRN\tF_EDIT:WORD\t; Flag - non-zero indicates INLIN active\r\n\tEXTRN\tAUTFLG:WORD\t; AUTO mode flag\r\n\tEXTRN\tCSRX:WORD\t; Cursor column (1..n)\r\n\tEXTRN\tCSRY:WORD\t; Cursor line (1..n)\r\nDSEG\tENDS\r\n;LITERALS NEEDED ELSEWHERE\r\n\tPUBLIC\tCHRLNF\t\t; Line feed character\r\n\tPUBLIC\tCHRRET\t\t; Carriage return character\r\n\r\n\r\n;CHARACTER DEFINITIONS\r\n;\r\n;\r\n\tCHREDT=1\t\t; EDiT\r\n\tCHRBKW=2\t\t; BacK Word\r\n\tCHRCAN=3\t\t; CANcel\r\n\tCHRHCN=4\t\t; Hard CaNcel\r\n\tCHRCLE=5\t\t; CLear to End of line\r\n\tCHRFDW=6\t\t; ForwarD Word\r\n\tCHRBEL=7\t\t; BELl\r\n\tCHRBAK=8D\t\t; BAcKspace\r\n\tCHRTAB=9D\t\t; TAB\r\n\tCHRLNF=10D\t\t; LiNeFeed\r\n\tCHRHOM=11D\t\t; HOMe\r\n\tCHRERA=12D\t\t; ERAse\r\n\tCHRRET=13D\t\t; RETurn\r\n\tCHRAPP=14D\t\t; APPend\r\n\tCHRINS=18D\t\t; INSert\r\n\tCHRLDL=21D\t\t; Line DeLete\r\n\tCHRADV=28D\t\t; cursor RiGhT\r\n\tCHRREG=29D\t\t; cursor LeFT\r\n\tCHRUP=30D\t\t; cursor UP\r\n\tCHRDWN=31D\t\t; cursor DoWN\r\n\tCHRDEL=127D\t\t; DELete\r\n\tSUBTTL  Entry points for editing\r\n\r\n\r\n\r\n;ENTRY: PINLIN, QINLIN, INLIN, SINLIN\r\n;\r\n;PROGRAM STATEMENT INPUT\r\nPUBLIC\tPINLIN\r\nPINLIN:\tCALL\tDSKCHI\t\t; Don't return if Loading ASCII File\r\n\tSTC\t\t\t; Indicate program statement input\r\n\tJMP\tSHORT INLIN0\r\n\r\n;PRINT \"?\" BEFORE GETTING INPUT\r\nPUBLIC\tQINLIN\r\nQINLIN:\tMOV\tAL,LOW \"?\"\r\n\tCALL\tOUTDO\t\t; Output a \"?\"\r\n\tMOV\tAL,LOW \" \"\r\n\tCALL\tOUTDO\t\t; Followed by a space\r\n\r\n;INPUT STATEMENT\r\nPUBLIC\tINLIN\r\nINLIN:\r\n\r\n;INPUT STATEMENT REDO\r\nPUBLIC\tSINLIN\r\nSINLIN:\tOR\tAL,AL\t\t; Indicate INPUT statement line input\r\n\r\nINLIN0:\r\n\tSBB\tAL,AL\t\t; If INPUT statement AL=0, else AL=-1\r\n\tMOV\tBYTE PTR F_EDPG,AL\t; Save flag\r\n\tMOV\tAL,BYTE PTR F_EDIT\t; Get old value of F.EDIT(in case of EDIT statement)\r\n\tMOV\tBYTE PTR F_EDIT,LOW 377O\t; Indicate executing INLIN\r\n\tCALL\tSCNMRK\t\t; Set up for edit\r\n\t\t\t\t;   If AL=1 then move cursor to start of logical\r\n\t\t\t\t;       line which preceeds current.\r\n\t\t\t\t;   Else if ZF=1 then set up FSTPOS, LSTPOS\r\n\t\t\t\t;        if ZF=0 then FSTPOS=0,0; LSTPOS=max,max\r\n\tSUBTTL  MAIN loop of editor\r\n\r\n\r\n\r\n;WHILE EOL.NE.TRUE BEGIN\r\n;** GET A KEY\r\nINLLOP:\r\n\tEXTRN\tSTCTYP:NEAR\r\n\tCLC\t\t\t; Signal for insert or overwrite cursor\r\n\tCALL\tSTCTYP\t\t; Set new cursor type\r\n\tCALL\tKEYIN\t\t; AX=key value\r\n;At this point we can have three classes of characters:\r\n;   CF=1 indicates 2 byte char with 2 sub classes:\r\n;       AH=FF indicates editor control function\r\n;       AH<>FF indicates 2 byte character to echo\r\n;   CF=0 indicates 1 or 3 byte key\r\n;       AL=FF indicates a 3 byte key with scan code in DX - these are ignored\r\n;       AL<>FF indicates a 1 byte key to echo, except if char is CR.\r\n\tJB\tINL2BY\t\t; BRIF 2-byte character, check for editor controls\r\n\tCMP\tAL,LOW OFFSET CHRRET\r\n\tJZ\tINLRET\t\t; BRIF CR, terminate line input\r\n;** IF CURRENT_CHAR IS SPECIAL THREE BYTE CHAR\r\n\tCMP\tAL,LOW 254D\t; Test for 3-byte character\r\n;** *** IGNORE THIS CHAR\r\n\tJZ\tINLLOP\t\t; BRIF to ignore 3-byte character\r\n\tJMP\tSHORT INLOP0\t; Not 3-bytes, just echo single byte\r\nINL2BY:\r\n;** IF CURRENT_CHAR IS CONTROL_CHAR\r\n\tCMP\tAH,LOW 255D\r\n\tJNZ\tINLOP0\t\t; BRIF not editor control character, echo char\r\n\tCMP\tAL,LOW 177O\r\n\tJZ\tINLP0\t\t; BRIF is a control character\r\n\tCMP\tAL,LOW \" \"\r\n\tJNB\tINLOP0\t\t; BRIF is not a control character\r\nINLP0:\r\n;** IF CURRENT_CHAR IS <CR> RETURN CURRENT LOGICAL LINE\r\n\tCMP\tAL,LOW OFFSET CHRRET\r\n\tJZ\tINLRET\t\t; BRIF is carriage return(EOL)\r\n;** IF (CURRENT_CHAR=<HELP> AND INPUT_MODE=PROGRAM) DO EDIT ON KBUF\r\n\tCMP\tAL,LOW OFFSET CHREDT\r\n\tJNZ\tINLOP0\r\n\tJMP\tINLHLP\t\t; BRIF help char, do edit on KBUF\r\n;Echo character in AX\r\nINLOP0:\r\n\tOR\tAH,AH\r\n\tJZ\tINLOP3\t\t; Single byte character\r\n\tXCHG\tAL,AH\t\t; Output AH first\r\n\tCALL\tOUTDO\t\t; Output a char\r\n\tXCHG\tAL,AH\t\t; Restore AL\r\nINLOP3:\tCALL\tOUTDO\t\t; Output a char\r\n\tJMP\tSHORT INLLOP\r\n;** END\r\n\r\n;SCAN FOR SEMICOLON\r\n;\r\nSCNSEM:\tCMP\tAL,LOW \";\"\r\n\tJNZ\tSCNSMR\t\t; BRIF not semicolon, return\r\n\tMOV\tBYTE PTR SEMFLG,AL\r\n\tJMP\tCHRGTR\t\t; Skip semicolon and return\r\nSCNSMR:\tRET\t\r\n\tSUBTTL  Exit, return current logical line\r\n\r\n\r\n\r\n;READ LOGICAL LINE INTO BUF\r\nINLRET:\tMOV\tBX,OFFSET BUF\t; Put data into BUF\r\n\tMOV\tCX,255D\t\t; CX=Max number of bytes to move\r\n\tTEST\tBYTE PTR F_EDPG,LOW 377O\t; Set zero flag if program statement input\r\n\tPUSHF\t\r\n\tMOV\tDL,BYTE PTR CSRY\t; (DH,DL) = (CSRX,CSRY)\r\n\tMOV\tDH,BYTE PTR CSRX\r\n\tCALL\tSCNRDL\t\t; Read the logical line into BUF\r\n\t\t\t\t; BX=address of last char in BUF plus one\r\n;IF PROGRAM_STATEMENT_INPUT BEGIN\r\n\tPOPF\t\r\n\tJZ\tINCRTX\t\t; BRIF not statement input\r\n;** WHILE POSN.NE.BEGIN_OF_LINE AND [POSN].NE.BLANK AND [POSN].NE.LF BEGIN\r\n\tMOV\tCX,BX\r\n\tSUB\tCX,OFFSET BUF\t; CX=count of chars in BUF\r\n\tJZ\tINCRTX\t\t; BUF is empty\r\n\tPUSH\tDI\r\n\tMOV\tDI,BX\r\n\tDEC\tDI\t\t; Start scan at last valid data\r\nINLOT0:\tMOV\tAL,LOW \" \"\r\n;** *** POSN=POSN-1\r\nINLOT1:\tSTD\t\t\t; Scan backwards\r\n REPE\tSCASB\t\t\t; This works for blank line(\",\" at BUF-1)\r\n\tINC\tDI\t\t; [DI] = last valid data\r\n\tMOV\tAL,LOW \" \"\r\n\tCMP\tBYTE PTR 0[DI],AL\r\n\tJZ\tINLOT2\t\t; BRIF more trailing blanks\r\n\tMOV\tAL,LOW OFFSET CHRLNF\r\n\tCMP\tAL,BYTE PTR 0[DI]\r\n\tJNZ\tINLOT3\t\t; BRIF not more trailing linefeeds\r\nINLOT2:\tOR\tCL,CL\r\n\tJNZ\tINLOT1\t\t; BRIF not at beginning of buffer\r\n;** *** END\r\n;** END\r\nINLOT3:\tMOV\tBX,DI\r\n\tPOP\tDI\r\n\tINC\tBX\r\nINCRTX:\tMOV\tBYTE PTR 0[BX],LOW 0\t; Terminate BUF\r\n;** UPDATE CURSOR POSN, RETURN\r\n\tTEST\tBYTE PTR SEMFLG,LOW 377O\r\n\tJNZ\tINCRTF\t\t; BRIF if INPUT<semicolon> statement\r\n\tMOV\tAX,OFFSET CHRAPP\r\n\tCALL\tOUTDO\t\t; Move to end of logical\r\n\tMOV\tBYTE PTR F_EDIT,LOW 0\r\n\tCALL\tCRDO\t\t; Move to first posn beyond this logical\r\nINCRTF:\tMOV\tBX,OFFSET BUF-1\t; Return BUF - 1\r\n\tPUSHF\t\r\n\tCALL\tCLRFLG\t\t; Clear miscellaneous status flags\r\n\tPOPF\t\r\n\tRET\t\r\n\r\n\r\n;SUBROUTINE EDTBRK              ; Routine which initializes when break detected\r\n;**                             ; This is called by the STOP code\r\n;**\r\nEDTBRK:\r\n\tEXTRN\tSETCSR:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tCSRTYP:WORD\r\nDSEG\tENDS\r\n\tMOV\tBYTE PTR CSRTYP,LOW 0D\t; Indicate cursor off\r\n\tCALL\tSETCSR\r\n\tCALL\tCLRFLG\t\t; Clear editor flags\r\n\tPUSH\tAX\r\n\tMOV\tAL,LOW OFFSET CHRAPP\r\n\tMOV\tBYTE PTR F_EDIT,AL\r\n\tCALL\tOUTDO\t\t; Move cursor to end of logical line\r\n\tMOV\tBYTE PTR F_EDIT,LOW 0\t; Reset edit mode\r\n\tCALL\tCRDO\t\t; Move cursor to next physical line\r\n\tPOP\tAX\r\n\tMOV\tBYTE PTR AUTFLG,LOW 0\t; Reset AUTO mode\r\n\tRET\t\r\n;** END SUBROUTINE EDTBRK\r\n\r\n;SUBROUTINE CLRFLG              ; Routine which clears flags\r\n;**\r\nCLRFLG:\tMOV\tBYTE PTR F_EDIT,LOW 0\t; No longer in INLIN\r\n\tMOV\tBYTE PTR F_EDPG,LOW 0\t; Not program edit\r\n\tMOV\tBYTE PTR F_INST,LOW 0\t; Not insert mode\r\n\tMOV\tBYTE PTR SEMFLG,LOW 0\t; Not INPUT; statement\r\n\tRET\t\r\n;** END SUBROUTINE CLRFLG\r\n\r\n\tSUBTTL  EDIT code\r\n\r\n\r\n\r\n\tEXTRN\tMAIN:NEAR,LINSPC:NEAR,FNDLIN:NEAR,DEPTR:NEAR,LISPRT:NEAR\r\n\tEXTRN\tLINPRT:NEAR,FCERR:NEAR,USERR:NEAR,BUFLIN:NEAR\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tDOT:WORD,ERRFLG:WORD,ERRLIN:WORD\r\nDSEG\tENDS\r\n\r\n;EDIT COMMAND\r\n;\r\nPUBLIC\tEDIT\r\nEDIT:\tCALL\tLINSPC\t\t; LINE NUMBER IN DE\r\n\tJNZ\tEFCERR\t\t; STATEMENT MUST HAVE ENDED\r\nEREDIT:\tPOP\tBX\t\t; REMOVE NEWSTT(OR CALL FROM MAIN)RETURN\r\n\tMOV\tWORD PTR DOT,DX\r\n\tCALL\tFNDLIN\t\t; FIND LINE\r\n\tJNB\tEUSERR\t\t; LINE DOES NOT EXIST\r\n\tMOV\tBX,CX\t\t; CX=LINE PTR\r\nERED2:\tINC\tBX\r\n\tINC\tBX\r\n\tMOV\tDX,WORD PTR 0[BX]\t; DE=LINE NUMBER\r\n\tINC\tBX\r\n\tINC\tBX\r\nERED3:\tPUSH\tBX\r\n\tMOV\tBYTE PTR F_EDIT,LOW 1\t; SET FLAG INDICATING IN EDIT MODE\r\n\t\t\t\t; (FORCES OPEN LINES DURING LIST)\r\n\t\t\t\t; (AND TELLS INLIN TO START AT BEGIN OF LOGICAL)\r\n\tXCHG\tBX,DX\r\nERED4:\tCALL\tLINPRT\t\t; PRINT THE LINE NUMBER\r\n\tPOP\tBX\r\n\tCMP\tBYTE PTR 0[BX],LOW 9D\t; LINE START WITH TAB?\r\n\tJZ\tERED5\r\n\tMOV\tAL,LOW \" \"\r\n\tCALL\tOUTDO\t\t; NO, PUT SPACE OUT\r\n;ENTRY FOR EDIT ON KBUF IS HERE\r\nERED5:\r\n\tMOV\tBYTE PTR F_EDIT,LOW 1\t; SET FLAG INDICATING IN EDIT MODE\r\n\t\t\t\t; (FORCES OPEN LINES DURING LIST)\r\n\t\t\t\t; (AND TELLS INLIN TO START AT BEGIN OF LOGICAL)\r\n\tCALL\tBUFLIN\t\t; PUT LINE IN BUF AND SET UP HLPBFA\r\n\tMOV\tBX,OFFSET BUF\r\n\tCALL\tLISPRT\t\t; PRINT THE LINE AND SET UP HLPCSR\r\n\tMOV\tBL,BYTE PTR CSRY\r\n\tMOV\tBH,BYTE PTR CSRX\r\n\tJMP\tMAIN\r\nEFCERR:\tJMP\tFCERR\t\t; Indirect jump to FCERR\r\nEUSERR:\tJMP\tUSERR\t\t; Indirect jump to USERR\r\n\r\n;Help key edit\r\n;\r\nINLHLP:\tTEST\tBYTE PTR F_EDPG,LOW 377O\r\n\tJNZ\tINLHL0\t\t; BRIF do help edit on program statement\r\n;Help during input statement\r\n\tJMP\tINLOP3\t\t; Just output char\r\n\r\n\r\n;DO EDIT ON DOT\r\nINLHL0:\tPOP\tAX\t\t; Remove call to this routine\r\n\r\n;See if edit on error line number\r\n\tMOV\tDX,WORD PTR ERRLIN\r\n\tCALL\tERRED2\t\t; If exists,do edit on error line number\r\n\r\n;See if edit on current line number\r\n\tMOV\tDX,WORD PTR CURLIN\r\n\tCALL\tERRED2\t\t; If exists,do edit on current line number\r\n;ERRLIN AND CURLIN ARE DIRECT, DO EDIT ON KBUF\r\nDSEG\tSEGMENT PUBLIC 'DATASG'\r\n\tEXTRN\tKBUF:WORD,CURLIN:WORD\r\nDSEG\tENDS\r\n\tEXTRN\tSCNEXT:NEAR,DEPTR:NEAR\r\n\tCALL\tDEPTR\t\t; Remove line pointers from program\r\n\tMOV\tBX,OFFSET KBUF\r\n\tPUSH\tBX\r\n\tDEC\tBX\r\n\tCALL\tSCNEXT\t\t; Remove any line pointers from KBUF\r\n\tPOP\tBX\r\n\tJMP\tSHORT ERED5\r\n\r\n;AUTOMATIC EDIT FOR ERRORS\r\n;\r\nPUBLIC\tERREDT\r\nERREDT:\tMOV\tBYTE PTR ERRFLG,AL\t; Reset the flag to call edit\r\n\tMOV\tDX,WORD PTR ERRLIN\t; Get the line number\r\nERRED2:\tCMP\tDX,177777O\t; See if it was direct\r\n\tJZ\tERRED3\t\t; Go back if direct\r\n\tOR\tDX,DX\r\n\tJZ\tERRED3\t\t; Go back if zero\r\n\tJMP\tEREDIT\r\nERRED3:\tRET\t\r\n\tSUBTTL  ASCII LOAD and SAVE line handler\r\n\r\n\r\n\r\n;LOAD ASCII:\r\n;  PROGRAM LINE INPUT FROM DISK\r\n;\r\n\tEXTRN\tISFLIO:NEAR,OUTDO:NEAR,INCHR:NEAR,LBOERR:NEAR\r\nDSKCHI:\r\n\tCALL\tISFLIO\t\t; Set FLAGS.NZ if PTRFIL points to active file\r\n\tJNZ\tISLOAD\t\t; BRIF LOAD statement\r\n\tRET\t\t\t; If so use special screen io\r\nISLOAD:\tPOP\tAX\t\t; Discard Return Address\r\n\tMOV\tCL,LOW OFFSET BUFLEN\t; Setup the maximum character count\r\n\tMOV\tBX,OFFSET BUF\t; Place we are going to stoer the line\r\nLOPBUF:\tCALL\tINCHR\t\t; Get a character from the file\r\n\t\t\t\t; (will call indskc and handle eof)\r\n\tMOV\tBYTE PTR 0[BX],AL\t; Store the character\r\n\tCMP\tAL,LOW 13D\t; Is it the end (a CR)\r\n\tJNZ\tINOTCR\t\t; Not a [CR]\r\n\tCMP\tBYTE PTR -1[BX],LOW 10D\t; Preceeded by a line feed?\r\n\tJZ\tLOPBUF\t\t; Yes, ignore the [CR]\r\n\tJMP\tSHORT FINLIN\t; No, this is the end of a line\r\nINOTCR:\r\n\tOR\tCL,CL\r\n\tJE\tLTLONG\t\t; Branch if line is too long to fit in BUF\r\n\tCMP\tAL,LOW 10D\t; LEADING LINE FEEDS MUST BE IGNORED\r\n\tJNZ\tINOTLF\r\n\tCMP\tCL,LOW OFFSET BUFLEN\t; CL=BUFLEN if this is the 1st char on the line\r\n\tJZ\tLOPBUF\t\t; Branch if this was a leading line-feed\r\nINOTLF:\tINC\tBX\t\t; ADVANCE THE POINTER\r\n\tDEC\tCL\r\n\tJMP\tSHORT LOPBUF\t; DO NEXT CHAR\r\n\tDEC\tCL\r\nFINLIN:\r\n\tMOV\tBYTE PTR 0[BX],LOW 0\r\n\tMOV\tBX,OFFSET BUF-1\t; POINT AT BUFMIN\r\n\tRET\t\r\n\r\nLTLONG:\tJMP\tLBOERR\t\t; Report LINE BUFFER OVERFLOW error\r\n\t\t\t\t; (This program wasn't created by BASIC)\r\n\r\n;SAVE ASCII:\r\n;   PROGRAM LISTING CHAR OUTPUT TO DISK(CONVERT <LF> TO <LF><CR>)\r\n;\r\nPUBLIC\tOUTCH1\r\nOUTCH1:\tCMP\tAL,LOW OFFSET CHRLNF\r\n\tJZ\tOUTCH0\t\t; IS LF\r\n\tJMP\tOUTDO\r\nOUTCH0:\r\n\tEXTRN\tISFLIO:NEAR\r\n\tCALL\tISFLIO\r\n\tJNZ\tOUTCH2\t\t; branch if outputting to file\r\n\tCALL\tOUTDO\r\n\tRET\t\r\n\r\nOUTCH2:\tCALL\tOUTDO\r\n\tMOV\tAL,LOW OFFSET CHRRET\r\n\tCALL\tOUTDO\r\n\tMOV\tAL,LOW OFFSET CHRLNF\r\n\tRET\t\r\nCSEG\tENDS\r\n\tEND\r\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 2.7978515625,
          "content": "<!-- BEGIN MICROSOFT SECURITY.MD V0.0.3 BLOCK -->\r\n\r\n## Security\r\n\r\nMicrosoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/Microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet), [Xamarin](https://github.com/xamarin), and [our GitHub organizations](https://opensource.microsoft.com/).\r\n\r\nIf you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's [Microsoft's definition of a security vulnerability](https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc751383(v=technet.10)) of a security vulnerability, please report it to us as described below.\r\n\r\n## Reporting Security Issues\r\n\r\n**Please do not report security vulnerabilities through public GitHub issues.**\r\n\r\nInstead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://msrc.microsoft.com/create-report).\r\n\r\nIf you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the the [Microsoft Security Response Center PGP Key page](https://www.microsoft.com/en-us/msrc/pgp-key-msrc).\r\n\r\nYou should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://www.microsoft.com/msrc).\r\n\r\nPlease include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:\r\n\r\n  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)\r\n  * Full paths of source file(s) related to the manifestation of the issue\r\n  * The location of the affected source code (tag/branch/commit or direct URL)\r\n  * Any special configuration required to reproduce the issue\r\n  * Step-by-step instructions to reproduce the issue\r\n  * Proof-of-concept or exploit code (if possible)\r\n  * Impact of the issue, including how an attacker might exploit the issue\r\n\r\nThis information will help us triage your report more quickly.\r\n\r\nIf you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://microsoft.com/msrc/bounty) page for more details about our active programs.\r\n\r\n## Preferred Languages\r\n\r\nWe prefer all communications to be in English.\r\n\r\n## Policy\r\n\r\nMicrosoft follows the principle of [Coordinated Vulnerability Disclosure](https://www.microsoft.com/en-us/msrc/cvd).\r\n\r\n<!-- END MICROSOFT SECURITY.MD BLOCK -->\r\n"
        }
      ]
    }
  ]
}