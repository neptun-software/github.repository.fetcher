{
  "metadata": {
    "timestamp": 1736565509900,
    "page": 378,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sharkdp/dbg-macro",
      "stars": 3040,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.0478515625,
          "content": "---\nLanguage:        Cpp\nBasedOnStyle:  Chromium\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0068359375,
          "content": "/build\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.087890625,
          "content": "[submodule \"tests/Catch2\"]\n\tpath = tests/Catch2\n\turl = https://github.com/catchorg/Catch2\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 2.423828125,
          "content": "cmake_minimum_required(VERSION 3.1)\n\nproject(dbg_macro)\n\ninclude(GNUInstallDirs)\n\nstring(COMPARE EQUAL ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_SOURCE_DIR} IS_MAIN_PROJECT)\noption(DBG_MACRO_ENABLE_TESTS \"Enable tests.\" ${IS_MAIN_PROJECT})\n\nadd_library(${PROJECT_NAME} INTERFACE)\ntarget_include_directories(${PROJECT_NAME}\n  INTERFACE\n    $<BUILD_INTERFACE:${${PROJECT_NAME}_SOURCE_DIR}>\n    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n)\n\nif (DBG_MACRO_ENABLE_TESTS)\n    add_subdirectory(tests/Catch2)\n    list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR}/tests/Catch2/contrib)\n\n    include(CTest)\n    include(Catch)\n\n    if(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n        set(WARNING_FLAGS \"-W4\")\n        # Required to force MSVC to set __cplusplus to the correct value\n        # https://devblogs.microsoft.com/cppblog/msvc-now-correctly-reports-__cplusplus/\n        set(ADDITIONAL_FLAGS \"/Zc:__cplusplus\")\n    else()\n        set(WARNING_FLAGS \"-Wall\" \"-pedantic\")\n        set(ADDITIONAL_FLAGS \"\")\n    endif()\n\n    # unit tests with dbg(...) enabled\n    add_executable(${PROJECT_NAME}-tests tests/main.cpp tests/basic.cpp)\n    target_compile_options(${PROJECT_NAME}-tests PRIVATE ${WARNING_FLAGS} ${ADDITIONAL_FLAGS} -DDBG_MACRO_NO_WARNING)\n    target_link_libraries(${PROJECT_NAME}-tests ${PROJECT_NAME} Catch2::Catch2)\n    catch_discover_tests(${PROJECT_NAME}-tests)\n\n    # unit tests with dbg(...) disabled\n    add_executable(${PROJECT_NAME}-tests-macro_disabled tests/main.cpp tests/basic.cpp)\n    target_compile_options(${PROJECT_NAME}-tests-macro_disabled PRIVATE ${WARNING_FLAGS} ${ADDITIONAL_FLAGS} -DDBG_MACRO_NO_WARNING -DDBG_MACRO_DISABLE)\n    target_link_libraries(${PROJECT_NAME}-tests-macro_disabled ${PROJECT_NAME} Catch2::Catch2)\n    catch_discover_tests(${PROJECT_NAME}-tests-macro_disabled)\n\n    # dbg(…) example file\n    add_executable(${PROJECT_NAME}-example tests/example.cpp)\n    target_compile_options(${PROJECT_NAME}-example PRIVATE ${WARNING_FLAGS} ${ADDITIONAL_FLAGS} -DDBG_MACRO_NO_WARNING)\n    target_link_libraries(${PROJECT_NAME}-example ${PROJECT_NAME})\n\n    # dbg(…) demo file\n    add_executable(${PROJECT_NAME}-demo tests/demo.cpp)\n    target_compile_options(${PROJECT_NAME}-demo PRIVATE ${WARNING_FLAGS} ${ADDITIONAL_FLAGS} -DDBG_MACRO_NO_WARNING)\n    target_link_libraries(${PROJECT_NAME}-demo ${PROJECT_NAME})\n    add_test(${PROJECT_NAME}-demo ${PROJECT_NAME}-demo)\nendif()\n\ninstall(FILES \"dbg.h\" DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.064453125,
          "content": "MIT License\n\nCopyright (c) 2019 David Peter <mail@david-peter.de>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.24609375,
          "content": "# `dbg(…)`\n\n[![Build status](https://github.com/sharkdp/dbg-macro/workflows/CI/badge.svg)](https://github.com/sharkdp/dbg-macro/actions) [![Try it online](https://img.shields.io/badge/try-online-f34b7d.svg)](https://godbolt.org/z/Yj13Kaxfh) [![License: MIT](https://img.shields.io/badge/license-MIT-blue.svg)](dbg.h)\n\n*A macro for `printf`-style debugging fans.*\n\nDebuggers are great. But sometimes you just don't have the time or patience to set\nup everything correctly and just want a quick way to inspect some values at runtime.\n\nThis projects provides a [single header file](dbg.h) with a `dbg(…)`\nmacro that can be used in all circumstances where you would typically write\n`printf(\"…\", …)` or `std::cout << …`. But it comes with a few extras.\n\n## Examples\n\n``` c++\n#include <dbg.h>\n#include <cstdint>\n#include <vector>\n\n// You can use \"dbg(..)\" in expressions:\nint32_t factorial(int32_t n) {\n  if (dbg(n <= 1)) {\n    return dbg(1);\n  } else {\n    return dbg(n * factorial(n - 1));\n  }\n}\n\nint32_t main() {\n  std::string message = \"hello\";\n  dbg(message);  // [example.cpp:15 (main)] message = \"hello\" (std::string)\n\n  const int32_t a = 2;\n  const int32_t b = dbg(3 * a) + 1;  // [example.cpp:18 (main)] 3 * a = 6 (int32_t)\n\n  std::vector<int32_t> numbers{b, 13, 42};\n  dbg(numbers);  // [example.cpp:21 (main)] numbers = {7, 13, 42} (std::vector<int32_t>)\n\n  dbg(\"this line is executed\");  // [example.cpp:23 (main)] this line is executed\n\n  factorial(4);\n\n  return 0;\n}\n```\n\nThe code above produces this output ([try it yourself](https://repl.it/@sharkdp/dbg-macro-demo)):\n\n![dbg(…) macro output](https://i.imgur.com/NVTzGRk.png)\n\n## Features\n\n * Easy to read, colorized output (colors auto-disable when the output is not an interactive terminal)\n * Prints file name, line number, function name and the original expression\n * Adds type information for the printed-out value\n * Specialized pretty-printers for containers, pointers, string literals, enums, `std::optional`, etc.\n * Can be used inside expressions (passing through the original value)\n * The `dbg.h` header issues a compiler warning when included (so you don't forget to remove it).\n * Compatible and tested with C++11, C++14 and C++17.\n\n## Installation\n\nTo make this practical, the `dbg.h` header should be readily available from all kinds of different\nplaces and in all kinds of environments. The quick & dirty way is to actually copy the header file\nto `/usr/local/include` or to clone the repository and symlink `dbg.h` to `/usr/local/include/dbg.h`.\n``` bash\ngit clone https://github.com/sharkdp/dbg-macro\nsudo ln -s $(readlink -f dbg-macro/dbg.h) /usr/local/include/dbg.h\n```\nIf you don't want to make untracked changes to your filesystem, check below if there is a package for\nyour operating system or package manager.\n\n### On Arch Linux\n\nYou can install [`dbg-macro` from the AUR](https://aur.archlinux.org/packages/dbg-macro/):\n``` bash\nyay -S dbg-macro\n```\n\n### With vcpkg\n\nYou can install the [`dbg-macro` port](https://github.com/microsoft/vcpkg/tree/master/ports/dbg-macro) via:\n``` bash\nvcpkg install dbg-macro\n```\n\n### With cmake\n\n`CMakeLists.txt`\n```cmake\ncmake_minimum_required(VERSION 3.11) # FetchContent added in cmake 3.11\nproject(app) # name of executable\n\nset(CMAKE_CXX_STANDARD 17)\n\n# dbg-macro\ninclude(FetchContent)\n\nFetchContent_Declare(dbg_macro GIT_REPOSITORY https://github.com/sharkdp/dbg-macro)\nFetchContent_MakeAvailable(dbg_macro)\n\nadd_executable(${PROJECT_NAME} main.cpp) # your source files goes here\ntarget_link_libraries(${PROJECT_NAME} PRIVATE dbg_macro) # make dbg.h available\n```\n\n`main.cpp`\n```cpp\n#include <dbg.h>\n\nint main() {\n  dbg(42, \"hello world\", false);\n  return 0;\n}\n```\n\n## Configuration\n\n* Set the `DBG_MACRO_DISABLE` flag to disable the `dbg(…)` macro (i.e. to make it a no-op).\n* Set the `DBG_MACRO_NO_WARNING` flag to disable the *\"'dbg.h' header is included in your code base\"* warnings.\n* Set the `DBG_MACRO_FORCE_COLOR` flag to force colored output and skip tty checks.\n\n## Advanced features\n\n### Multiple arguments\n\nYou can pass multiple arguments to the `dbg(…)` macro. The output of\n`dbg(x, y, z)` is same as `dbg(x); dbg(y); dbg(z);`:\n``` c++\ndbg(42, \"hello world\", false);\n```\n\nNote that you have to wrap \"unprotected commas\" in parentheses:\n```c++\ndbg(\"a vector:\", (std::vector<int>{2, 3, 4}));\n```\n\n### Hexadecimal, octal and binary format\n\nIf you want to format integers in hexadecimal, octal or binary representation, you can\nsimply wrap them in `dbg::hex(…)`, `dbg::oct(…)` or `dbg::bin(…)`:\n```c++\nconst uint32_t secret = 12648430;\ndbg(dbg::hex(secret));\n```\n\n### Printing type names\n\n`dbg(…)` already prints the type for each value in parenthesis (see screenshot above). But\nsometimes you just want to print a type (maybe because you don't have a value for that type).\nIn this case, you can use the `dbg::type<T>()` helper to pretty-print a given type `T`.\nFor example:\n```c++\ntemplate <typename T>\nvoid my_function_template() {\n  using MyDependentType = typename std::remove_reference<T>::type&&;\n  dbg(dbg::type<MyDependentType>());\n}\n```\n\n### Print the current time\n\nTo print a timestamp, you can use the `dbg::time()` helper:\n```c++\ndbg(dbg::time());\n```\n\n### Customization\n\nIf you want `dbg(…)` to work for your custom datatype, you can simply overload `operator<<` for\n`std::ostream&`:\n```c++\nstd::ostream& operator<<(std::ostream& out, const user_defined_type& v) {\n  out << \"…\";\n  return out;\n}\n```\n\nIf you want to modify the type name that is printed by `dbg(…)`, you can add a custom\n`get_type_name` overload:\n```c++\n// Customization point for type information\nnamespace dbg {\n    std::string get_type_name(type_tag<bool>) {\n        return \"truth value\";\n    }\n}\n```\n\n## Development\n\nIf you want to contribute to `dbg-macro`, here is how you can build the tests and demos:\n\nMake sure that the submodule(s) are up to date:\n```bash\ngit submodule update --init\n```\n\nThen, use the typical `cmake` workflow. Usage of `-DCMAKE_CXX_STANDARD=17` is optional,\nbut recommended in order to have the largest set of features enabled:\n```bash\nmkdir build\ncd build\ncmake .. -DCMAKE_CXX_STANDARD=17\nmake\n```\n\nTo run the tests, simply call:\n```bash\nmake test\n```\nYou can find the unit tests in `tests/basic.cpp`.\n\n## Acknowledgement\n\nThis project is inspired by Rusts [`dbg!(…)` macro](https://doc.rust-lang.org/std/macro.dbg.html).\n"
        },
        {
          "name": "dbg.h",
          "type": "blob",
          "size": 28.05078125,
          "content": "/*****************************************************************************\n\n                                dbg(...) macro\n\nLicense (MIT):\n\n  Copyright (c) 2019 David Peter <mail@david-peter.de>\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to\n  deal in the Software without restriction, including without limitation the\n  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n  sell copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n*****************************************************************************/\n\n#ifndef DBG_MACRO_DBG_H\n#define DBG_MACRO_DBG_H\n\n#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))\n#define DBG_MACRO_UNIX\n#elif defined(_MSC_VER)\n#define DBG_MACRO_WINDOWS\n#endif\n\n#ifndef DBG_MACRO_NO_WARNING\n#pragma message(\"WARNING: the 'dbg.h' header is included in your code base\")\n#endif  // DBG_MACRO_NO_WARNING\n\n#include <algorithm>\n#include <chrono>\n#include <ctime>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <memory>\n#include <queue>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <vector>\n\n#ifdef DBG_MACRO_UNIX\n#include <unistd.h>\n#endif\n\n#if __cplusplus >= 201703L\n#define DBG_MACRO_CXX_STANDARD 17\n#elif __cplusplus >= 201402L\n#define DBG_MACRO_CXX_STANDARD 14\n#else\n#define DBG_MACRO_CXX_STANDARD 11\n#endif\n\n#if DBG_MACRO_CXX_STANDARD >= 17\n#include <optional>\n#include <variant>\n#endif\n\nnamespace dbg {\n\ninline bool isColorizedOutputEnabled() {\n#if defined(DBG_MACRO_FORCE_COLOR)\n  return true;\n#elif defined(DBG_MACRO_UNIX)\n  return isatty(fileno(stderr));\n#else\n  return true;\n#endif\n}\n\nstruct time {};\n\nnamespace pretty_function {\n\n// Compiler-agnostic version of __PRETTY_FUNCTION__ and constants to\n// extract the template argument in `type_name_impl`\n\n#if defined(__clang__)\n#define DBG_MACRO_PRETTY_FUNCTION __PRETTY_FUNCTION__\nstatic constexpr size_t PREFIX_LENGTH =\n    sizeof(\"const char *dbg::type_name_impl() [T = \") - 1;\nstatic constexpr size_t SUFFIX_LENGTH = sizeof(\"]\") - 1;\n#elif defined(__GNUC__) && !defined(__clang__)\n#define DBG_MACRO_PRETTY_FUNCTION __PRETTY_FUNCTION__\nstatic constexpr size_t PREFIX_LENGTH =\n    sizeof(\"const char* dbg::type_name_impl() [with T = \") - 1;\nstatic constexpr size_t SUFFIX_LENGTH = sizeof(\"]\") - 1;\n#elif defined(_MSC_VER)\n#define DBG_MACRO_PRETTY_FUNCTION __FUNCSIG__\nstatic constexpr size_t PREFIX_LENGTH =\n    sizeof(\"const char *__cdecl dbg::type_name_impl<\") - 1;\nstatic constexpr size_t SUFFIX_LENGTH = sizeof(\">(void)\") - 1;\n#else\n#error \"This compiler is currently not supported by dbg_macro.\"\n#endif\n\n}  // namespace pretty_function\n\n// Formatting helpers\n\ntemplate <typename T>\nstruct print_formatted {\n  static_assert(std::is_integral<T>::value,\n                \"Only integral types are supported.\");\n\n  print_formatted(T value, int numeric_base)\n      : inner(value), base(numeric_base) {}\n\n  operator T() const { return inner; }\n\n  const char* prefix() const {\n    switch (base) {\n      case 8:\n        return \"0o\";\n      case 16:\n        return \"0x\";\n      case 2:\n        return \"0b\";\n      default:\n        return \"\";\n    }\n  }\n\n  T inner;\n  int base;\n};\n\ntemplate <typename T>\nprint_formatted<T> hex(T value) {\n  return print_formatted<T>{value, 16};\n}\n\ntemplate <typename T>\nprint_formatted<T> oct(T value) {\n  return print_formatted<T>{value, 8};\n}\n\ntemplate <typename T>\nprint_formatted<T> bin(T value) {\n  return print_formatted<T>{value, 2};\n}\n\n// Implementation of 'type_name<T>()'\n\ntemplate <typename T>\nconst char* type_name_impl() {\n  return DBG_MACRO_PRETTY_FUNCTION;\n}\n\ntemplate <typename T>\nstruct type_tag {};\n\ntemplate <int&... ExplicitArgumentBarrier, typename T>\ntypename std::enable_if<(std::rank<T>::value == 0), std::string>::type\nget_type_name(type_tag<T>) {\n  namespace pf = pretty_function;\n\n  std::string type = type_name_impl<T>();\n  return type.substr(pf::PREFIX_LENGTH,\n                     type.size() - pf::PREFIX_LENGTH - pf::SUFFIX_LENGTH);\n}\n\ntemplate <typename T>\nstd::string type_name() {\n  if (std::is_volatile<T>::value) {\n    if (std::is_pointer<T>::value) {\n      return type_name<typename std::remove_volatile<T>::type>() + \" volatile\";\n    } else {\n      return \"volatile \" + type_name<typename std::remove_volatile<T>::type>();\n    }\n  }\n  if (std::is_const<T>::value) {\n    if (std::is_pointer<T>::value) {\n      return type_name<typename std::remove_const<T>::type>() + \" const\";\n    } else {\n      return \"const \" + type_name<typename std::remove_const<T>::type>();\n    }\n  }\n  if (std::is_pointer<T>::value) {\n    return type_name<typename std::remove_pointer<T>::type>() + \"*\";\n  }\n  if (std::is_lvalue_reference<T>::value) {\n    return type_name<typename std::remove_reference<T>::type>() + \"&\";\n  }\n  if (std::is_rvalue_reference<T>::value) {\n    return type_name<typename std::remove_reference<T>::type>() + \"&&\";\n  }\n  return get_type_name(type_tag<T>{});\n}\n\n// Prefer bitsize variant over standard integral types\n#define DBG_MACRO_REGISTER_TYPE_ASSOC(t_std, t_bit)             \\\n  inline constexpr const char* get_type_name(type_tag<t_std>) { \\\n    return std::is_same<t_std, t_bit>::value ? #t_bit : #t_std; \\\n  }\n\nDBG_MACRO_REGISTER_TYPE_ASSOC(unsigned char, uint8_t)\nDBG_MACRO_REGISTER_TYPE_ASSOC(unsigned short, uint16_t)\nDBG_MACRO_REGISTER_TYPE_ASSOC(unsigned int, uint32_t)\nDBG_MACRO_REGISTER_TYPE_ASSOC(unsigned long, uint64_t)\nDBG_MACRO_REGISTER_TYPE_ASSOC(signed char, int8_t)\nDBG_MACRO_REGISTER_TYPE_ASSOC(short, int16_t)\nDBG_MACRO_REGISTER_TYPE_ASSOC(int, int32_t)\nDBG_MACRO_REGISTER_TYPE_ASSOC(long, int64_t)\n\ninline std::string get_type_name(type_tag<std::string>) {\n  return \"std::string\";\n}\n\ntemplate <typename T>\ntypename std::enable_if<(std::rank<T>::value == 1), std::string>::type\nget_array_dim() {\n  return \"[\" + std::to_string(std::extent<T>::value) + \"]\";\n}\n\ntemplate <typename T>\ntypename std::enable_if<(std::rank<T>::value > 1), std::string>::type\nget_array_dim() {\n  return \"[\" + std::to_string(std::extent<T>::value) + \"]\" +\n         get_array_dim<typename std::remove_extent<T>::type>();\n}\n\ntemplate <typename T>\ntypename std::enable_if<(std::rank<T>::value > 0), std::string>::type\nget_type_name(type_tag<T>) {\n  return type_name<typename std::remove_all_extents<T>::type>() + get_array_dim<T>();\n}\n\ntemplate <typename T, size_t N>\nstd::string get_type_name(type_tag<std::array<T, N>>) {\n  return \"std::array<\" + type_name<T>() + \", \" + std::to_string(N) + \">\";\n}\n\ntemplate <typename T>\nstd::string get_type_name(type_tag<std::vector<T, std::allocator<T>>>) {\n  return \"std::vector<\" + type_name<T>() + \">\";\n}\n\ntemplate <typename T1, typename T2>\nstd::string get_type_name(type_tag<std::pair<T1, T2>>) {\n  return \"std::pair<\" + type_name<T1>() + \", \" + type_name<T2>() + \">\";\n}\n\ntemplate <typename... T>\nstd::string type_list_to_string() {\n  std::string result;\n  auto unused = {(result += type_name<T>() + \", \", 0)..., 0};\n  static_cast<void>(unused);\n\n#if DBG_MACRO_CXX_STANDARD >= 17\n  if constexpr (sizeof...(T) > 0) {\n#else\n  if (sizeof...(T) > 0) {\n#endif\n    result.pop_back();\n    result.pop_back();\n  }\n  return result;\n}\n\ntemplate <typename... T>\nstd::string get_type_name(type_tag<std::tuple<T...>>) {\n  return \"std::tuple<\" + type_list_to_string<T...>() + \">\";\n}\n\ntemplate <typename T>\ninline std::string get_type_name(type_tag<print_formatted<T>>) {\n  return type_name<T>();\n}\n\n// Implementation of 'is_detected' to specialize for container-like types\n\nnamespace detail_detector {\n\nstruct nonesuch {\n  nonesuch() = delete;\n  ~nonesuch() = delete;\n  nonesuch(nonesuch const&) = delete;\n  void operator=(nonesuch const&) = delete;\n};\n\ntemplate <typename...>\nusing void_t = void;\n\ntemplate <class Default,\n          class AlwaysVoid,\n          template <class...>\n          class Op,\n          class... Args>\nstruct detector {\n  using value_t = std::false_type;\n  using type = Default;\n};\n\ntemplate <class Default, template <class...> class Op, class... Args>\nstruct detector<Default, void_t<Op<Args...>>, Op, Args...> {\n  using value_t = std::true_type;\n  using type = Op<Args...>;\n};\n\n}  // namespace detail_detector\n\ntemplate <template <class...> class Op, class... Args>\nusing is_detected = typename detail_detector::\n    detector<detail_detector::nonesuch, void, Op, Args...>::value_t;\n\nnamespace detail {\n\nnamespace {\nusing std::begin;\nusing std::end;\n#if DBG_MACRO_CXX_STANDARD < 17\ntemplate <typename T>\nconstexpr auto size(const T& c) -> decltype(c.size()) {\n  return c.size();\n}\ntemplate <typename T, std::size_t N>\nconstexpr std::size_t size(const T (&)[N]) {\n  return N;\n}\n#else\nusing std::size;\n#endif\n}  // namespace\n\n// Specializations for container adapters\n\ntemplate <class T, class C>\nT pop(std::stack<T, C>& adapter) {\n  T value = std::move(adapter.top());\n  adapter.pop();\n  return value;\n}\n\ntemplate <class T, class C>\nT pop(std::queue<T, C>& adapter) {\n  T value = std::move(adapter.front());\n  adapter.pop();\n  return value;\n}\n\ntemplate <class T, class C, class Cmp>\nT pop(std::priority_queue<T, C, Cmp>& adapter) {\n  T value = std::move(adapter.top());\n  adapter.pop();\n  return value;\n}\n\ntemplate <typename T>\nstruct remove_cvref {\n  typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type\n      type;\n};\n\ntemplate <typename T>\nusing remove_cvref_t = typename remove_cvref<T>::type;\n\ntemplate <typename T>\nusing detect_begin_t = decltype(detail::begin(std::declval<T>()));\n\ntemplate <typename T>\nusing detect_end_t = decltype(detail::end(std::declval<T>()));\n\ntemplate <typename T>\nusing detect_size_t = decltype(detail::size(std::declval<T>()));\n\ntemplate <typename T>\nstruct is_container {\n  static constexpr bool value =\n      is_detected<detect_begin_t, T>::value &&\n      is_detected<detect_end_t, T>::value &&\n      is_detected<detect_size_t, T>::value &&\n      !std::is_same<std::string, remove_cvref_t<T>>::value;\n};\n\ntemplate <typename T>\nusing detect_underlying_container_t =\n    typename remove_cvref_t<T>::container_type;\n\ntemplate <typename T>\nstruct is_container_adapter {\n  static constexpr bool value =\n      is_detected<detect_underlying_container_t, T>::value;\n};\n\ntemplate <typename T>\nusing ostream_operator_t =\n    decltype(std::declval<std::ostream&>() << std::declval<T>());\n\ntemplate <typename T>\nstruct has_ostream_operator : is_detected<ostream_operator_t, T> {};\n\n}  // namespace detail\n\n// Helper to dbg(…)-print types\ntemplate <typename T>\nstruct print_type {};\n\ntemplate <typename T>\nprint_type<T> type() {\n  return print_type<T>{};\n}\n\n// Forward declarations of \"pretty_print\"\n\ntemplate <typename T>\ninline void pretty_print(std::ostream& stream, const T& value, std::true_type);\n\ntemplate <typename T>\ninline void pretty_print(std::ostream&, const T&, std::false_type);\n\ntemplate <typename T>\ninline typename std::enable_if<\n    !detail::is_container<const T&>::value &&\n        !detail::is_container_adapter<const T&>::value &&\n        !std::is_enum<T>::value,\n    bool>::type\npretty_print(std::ostream& stream, const T& value);\n\ninline bool pretty_print(std::ostream& stream, const bool& value);\n\ninline bool pretty_print(std::ostream& stream, const char& value);\n\ntemplate <typename P>\ninline bool pretty_print(std::ostream& stream, P* const& value);\n\ntemplate <typename T, typename Deleter>\ninline bool pretty_print(std::ostream& stream,\n                         std::unique_ptr<T, Deleter>& value);\n\ntemplate <typename T>\ninline bool pretty_print(std::ostream& stream, std::shared_ptr<T>& value);\n\ntemplate <size_t N>\ninline bool pretty_print(std::ostream& stream, const char (&value)[N]);\n\ntemplate <>\ninline bool pretty_print(std::ostream& stream, const char* const& value);\n\ntemplate <typename... Ts>\ninline bool pretty_print(std::ostream& stream, const std::tuple<Ts...>& value);\n\ntemplate <>\ninline bool pretty_print(std::ostream& stream, const std::tuple<>&);\n\ntemplate <>\ninline bool pretty_print(std::ostream& stream, const time&);\n\ntemplate <typename T>\ninline bool pretty_print(std::ostream& stream, const print_formatted<T>& value);\n\ntemplate <typename T>\ninline bool pretty_print(std::ostream& stream, const print_type<T>&);\n\ntemplate <typename Enum>\ninline typename std::enable_if<std::is_enum<Enum>::value, bool>::type\npretty_print(std::ostream& stream, Enum const& value);\n\ninline bool pretty_print(std::ostream& stream, const std::string& value);\n\n#if DBG_MACRO_CXX_STANDARD >= 17\n\ninline bool pretty_print(std::ostream& stream, const std::string_view& value);\n\n#endif\n\ntemplate <typename T1, typename T2>\ninline bool pretty_print(std::ostream& stream, const std::pair<T1, T2>& value);\n\n#if DBG_MACRO_CXX_STANDARD >= 17\n\ntemplate <typename T>\ninline bool pretty_print(std::ostream& stream, const std::optional<T>& value);\n\ntemplate <typename... Ts>\ninline bool pretty_print(std::ostream& stream,\n                         const std::variant<Ts...>& value);\n\n#endif\n\ntemplate <typename Container>\ninline typename std::enable_if<detail::is_container<const Container&>::value,\n                               bool>::type\npretty_print(std::ostream& stream, const Container& value);\n\ntemplate <typename ContainerAdapter>\ninline typename std::enable_if<\n    detail::is_container_adapter<const ContainerAdapter&>::value,\n    bool>::type\npretty_print(std::ostream& stream, ContainerAdapter value);\n\n// Specializations of \"pretty_print\"\n\ntemplate <typename T>\ninline void pretty_print(std::ostream& stream, const T& value, std::true_type) {\n  stream << value;\n}\n\ntemplate <typename T>\ninline void pretty_print(std::ostream&, const T&, std::false_type) {\n  static_assert(detail::has_ostream_operator<const T&>::value,\n                \"Type does not support the << ostream operator\");\n}\n\ntemplate <typename T>\ninline typename std::enable_if<\n    !detail::is_container<const T&>::value &&\n        !detail::is_container_adapter<const T&>::value &&\n        !std::is_enum<T>::value,\n    bool>::type\npretty_print(std::ostream& stream, const T& value) {\n  pretty_print(stream, value,\n               typename detail::has_ostream_operator<const T&>::type{});\n  return true;\n}\n\ninline bool pretty_print(std::ostream& stream, const bool& value) {\n  stream << std::boolalpha << value;\n  return true;\n}\n\ninline bool pretty_print(std::ostream& stream, const char& value) {\n  const bool printable = value >= 0x20 && value <= 0x7E;\n\n  if (printable) {\n    stream << \"'\" << value << \"'\";\n  } else {\n    stream << \"'\\\\x\" << std::setw(2) << std::setfill('0') << std::hex\n           << std::uppercase << (0xFF & value) << \"'\";\n  }\n  return true;\n}\n\ntemplate <typename P>\ninline bool pretty_print(std::ostream& stream, P* const& value) {\n  if (value == nullptr) {\n    stream << \"nullptr\";\n  } else {\n    stream << value;\n  }\n  return true;\n}\n\ntemplate <typename T, typename Deleter>\ninline bool pretty_print(std::ostream& stream,\n                         std::unique_ptr<T, Deleter>& value) {\n  pretty_print(stream, value.get());\n  return true;\n}\n\ntemplate <typename T>\ninline bool pretty_print(std::ostream& stream, std::shared_ptr<T>& value) {\n  pretty_print(stream, value.get());\n  stream << \" (use_count = \" << value.use_count() << \")\";\n\n  return true;\n}\n\ntemplate <size_t N>\ninline bool pretty_print(std::ostream& stream, const char (&value)[N]) {\n  stream << value;\n  return false;\n}\n\ntemplate <>\ninline bool pretty_print(std::ostream& stream, const char* const& value) {\n  stream << '\"' << value << '\"';\n  return true;\n}\n\ntemplate <size_t Idx>\nstruct pretty_print_tuple {\n  template <typename... Ts>\n  static void print(std::ostream& stream, const std::tuple<Ts...>& tuple) {\n    pretty_print_tuple<Idx - 1>::print(stream, tuple);\n    stream << \", \";\n    pretty_print(stream, std::get<Idx>(tuple));\n  }\n};\n\ntemplate <>\nstruct pretty_print_tuple<0> {\n  template <typename... Ts>\n  static void print(std::ostream& stream, const std::tuple<Ts...>& tuple) {\n    pretty_print(stream, std::get<0>(tuple));\n  }\n};\n\ntemplate <typename... Ts>\ninline bool pretty_print(std::ostream& stream, const std::tuple<Ts...>& value) {\n  stream << \"{\";\n  pretty_print_tuple<sizeof...(Ts) - 1>::print(stream, value);\n  stream << \"}\";\n\n  return true;\n}\n\ntemplate <>\ninline bool pretty_print(std::ostream& stream, const std::tuple<>&) {\n  stream << \"{}\";\n\n  return true;\n}\n\ntemplate <>\ninline bool pretty_print(std::ostream& stream, const time&) {\n  using namespace std::chrono;\n\n  const auto now = system_clock::now();\n  const auto us =\n      duration_cast<microseconds>(now.time_since_epoch()).count() % 1000000;\n  const auto hms = system_clock::to_time_t(now);\n#if defined(_MSC_VER) && _MSC_VER >= 1600\n  struct tm t;\n  localtime_s(&t, &hms);\n  const std::tm* tm = &t;\n#else\n  const std::tm* tm = std::localtime(&hms);\n#endif\n  stream << \"current time = \" << std::put_time(tm, \"%H:%M:%S\") << '.'\n         << std::setw(6) << std::setfill('0') << us;\n  return false;\n}\n\n// Converts decimal integer to binary string\ntemplate <typename T>\nstd::string decimalToBinary(T n) {\n  const size_t length = 8 * sizeof(T);\n  std::string toRet;\n  toRet.resize(length);\n\n  for (size_t i = 0; i < length; ++i) {\n    const auto bit_at_index_i = static_cast<char>((n >> i) & 1);\n    toRet[length - 1 - i] = bit_at_index_i + '0';\n  }\n\n  return toRet;\n}\n\ntemplate <typename T>\ninline bool pretty_print(std::ostream& stream,\n                         const print_formatted<T>& value) {\n  if (value.inner < 0) {\n    stream << \"-\";\n  }\n  stream << value.prefix();\n\n  // Print using setbase\n  if (value.base != 2) {\n    stream << std::setw(sizeof(T)) << std::setfill('0')\n           << std::setbase(value.base) << std::uppercase;\n\n    if (value.inner >= 0) {\n      // The '+' sign makes sure that a uint_8 is printed as a number\n      stream << +value.inner;\n    } else {\n      using unsigned_type = typename std::make_unsigned<T>::type;\n      stream << +(static_cast<unsigned_type>(-(value.inner + 1)) + 1);\n    }\n  } else {\n    // Print for binary\n    if (value.inner >= 0) {\n      stream << decimalToBinary(value.inner);\n    } else {\n      using unsigned_type = typename std::make_unsigned<T>::type;\n      stream << decimalToBinary<unsigned_type>(\n          static_cast<unsigned_type>(-(value.inner + 1)) + 1);\n    }\n  }\n\n  return true;\n}\n\ntemplate <typename T>\ninline bool pretty_print(std::ostream& stream, const print_type<T>&) {\n  stream << type_name<T>();\n\n  stream << \" [sizeof: \" << sizeof(T) << \" byte, \";\n\n  stream << \"trivial: \";\n  if (std::is_trivial<T>::value) {\n    stream << \"yes\";\n  } else {\n    stream << \"no\";\n  }\n\n  stream << \", standard layout: \";\n  if (std::is_standard_layout<T>::value) {\n    stream << \"yes\";\n  } else {\n    stream << \"no\";\n  }\n  stream << \"]\";\n\n  return false;\n}\n\ntemplate <typename Enum>\ninline typename std::enable_if<std::is_enum<Enum>::value, bool>::type\npretty_print(std::ostream& stream, Enum const& value) {\n  using UnderlyingType = typename std::underlying_type<Enum>::type;\n  stream << static_cast<UnderlyingType>(value);\n\n  return true;\n}\n\ninline bool pretty_print(std::ostream& stream, const std::string& value) {\n  stream << '\"' << value << '\"';\n  return true;\n}\n\n#if DBG_MACRO_CXX_STANDARD >= 17\n\ninline bool pretty_print(std::ostream& stream, const std::string_view& value) {\n  stream << '\"' << std::string(value) << '\"';\n  return true;\n}\n\n#endif\n\ntemplate <typename T1, typename T2>\ninline bool pretty_print(std::ostream& stream, const std::pair<T1, T2>& value) {\n  stream << \"{\";\n  pretty_print(stream, value.first);\n  stream << \", \";\n  pretty_print(stream, value.second);\n  stream << \"}\";\n  return true;\n}\n\n#if DBG_MACRO_CXX_STANDARD >= 17\n\ntemplate <typename T>\ninline bool pretty_print(std::ostream& stream, const std::optional<T>& value) {\n  if (value) {\n    stream << '{';\n    pretty_print(stream, *value);\n    stream << '}';\n  } else {\n    stream << \"nullopt\";\n  }\n\n  return true;\n}\n\ntemplate <typename... Ts>\ninline bool pretty_print(std::ostream& stream,\n                         const std::variant<Ts...>& value) {\n  stream << \"{\";\n  std::visit([&stream](auto&& arg) { pretty_print(stream, arg); }, value);\n  stream << \"}\";\n\n  return true;\n}\n\n#endif\n\ntemplate <typename Container>\ninline typename std::enable_if<detail::is_container<const Container&>::value,\n                               bool>::type\npretty_print(std::ostream& stream, const Container& value) {\n  stream << \"{\";\n  const size_t size = detail::size(value);\n  const size_t n = std::min(size_t{10}, size);\n  size_t i = 0;\n  using std::begin;\n  using std::end;\n  for (auto it = begin(value); it != end(value) && i < n; ++it, ++i) {\n    pretty_print(stream, *it);\n    if (i != n - 1) {\n      stream << \", \";\n    }\n  }\n\n  if (size > n) {\n    stream << \", ...\";\n    stream << \" size:\" << size;\n  }\n\n  stream << \"}\";\n  return true;\n}\n\ntemplate <typename ContainerAdapter>\ninline typename std::enable_if<\n    detail::is_container_adapter<const ContainerAdapter&>::value,\n    bool>::type\npretty_print(std::ostream& stream, ContainerAdapter value) {\n  stream << \"{\";\n  const size_t size = detail::size(value);\n  const size_t n = std::min(size_t{10}, size);\n\n  std::vector<typename ContainerAdapter::value_type> elements;\n  elements.reserve(n);\n  for (size_t i = 0; i < n; ++i) {\n    elements.push_back(detail::pop(value));\n  }\n  std::reverse(elements.begin(), elements.end());\n\n  if (size > n) {\n    stream << \"..., \";\n  }\n  for (size_t i = 0; i < n; ++i) {\n    pretty_print(stream, elements[i]);\n    if (i != n - 1) {\n      stream << \", \";\n    }\n  }\n  if (size > n) {\n    stream << \" (size:\" << size << \")\";\n  }\n\n  stream << \"}\";\n  return true;\n}\n\ntemplate <typename T, typename... U>\nstruct last {\n  using type = typename last<U...>::type;\n};\n\ntemplate <typename T>\nstruct last<T> {\n  using type = T;\n};\n\ntemplate <typename... T>\nusing last_t = typename last<T...>::type;\n\nclass DebugOutput {\n public:\n  // Helper alias to avoid obscure type `const char* const*` in signature.\n  using expr_t = const char*;\n\n  DebugOutput(const char* filepath, int line, const char* function_name)\n      : m_use_colorized_output(isColorizedOutputEnabled()) {\n    std::string path = filepath;\n    const std::size_t path_length = path.length();\n    if (path_length > MAX_PATH_LENGTH) {\n      path = \"..\" + path.substr(path_length - MAX_PATH_LENGTH, MAX_PATH_LENGTH);\n    }\n    std::stringstream ss;\n    ss << ansi(ANSI_DEBUG) << \"[\" << path << \":\" << line << \" (\"\n       << function_name << \")] \" << ansi(ANSI_RESET);\n    m_location = ss.str();\n  }\n\n  template <typename... T>\n  auto print(std::initializer_list<expr_t> exprs,\n             std::initializer_list<std::string> types,\n             T&&... values) -> last_t<T...> {\n    if (exprs.size() != sizeof...(values)) {\n      std::cerr\n          << m_location << ansi(ANSI_WARN)\n          << \"The number of arguments mismatch, please check unprotected comma\"\n          << ansi(ANSI_RESET) << std::endl;\n    }\n    return print_impl(exprs.begin(), types.begin(), std::forward<T>(values)...);\n  }\n\n private:\n  template <typename T>\n  T&& print_impl(const expr_t* expr, const std::string* type, T&& value) {\n    const T& ref = value;\n    std::stringstream stream_value;\n    const bool print_expr_and_type = pretty_print(stream_value, ref);\n\n    std::stringstream output;\n    output << m_location;\n    if (print_expr_and_type) {\n      output << ansi(ANSI_EXPRESSION) << *expr << ansi(ANSI_RESET) << \" = \";\n    }\n    output << ansi(ANSI_VALUE) << stream_value.str() << ansi(ANSI_RESET);\n    if (print_expr_and_type) {\n      output << \" (\" << ansi(ANSI_TYPE) << *type << ansi(ANSI_RESET) << \")\";\n    }\n    output << std::endl;\n    std::cerr << output.str();\n\n    return std::forward<T>(value);\n  }\n\n  template <typename T, typename... U>\n  auto print_impl(const expr_t* exprs,\n                  const std::string* types,\n                  T&& value,\n                  U&&... rest) -> last_t<T, U...> {\n    print_impl(exprs, types, std::forward<T>(value));\n    return print_impl(exprs + 1, types + 1, std::forward<U>(rest)...);\n  }\n\n  const char* ansi(const char* code) const {\n    if (m_use_colorized_output) {\n      return code;\n    } else {\n      return ANSI_EMPTY;\n    }\n  }\n\n  const bool m_use_colorized_output;\n\n  std::string m_location;\n\n  static constexpr std::size_t MAX_PATH_LENGTH = 20;\n\n  static constexpr const char* const ANSI_EMPTY = \"\";\n  static constexpr const char* const ANSI_DEBUG = \"\\x1b[02m\";\n  static constexpr const char* const ANSI_WARN = \"\\x1b[33m\";\n  static constexpr const char* const ANSI_EXPRESSION = \"\\x1b[36m\";\n  static constexpr const char* const ANSI_VALUE = \"\\x1b[01m\";\n  static constexpr const char* const ANSI_TYPE = \"\\x1b[32m\";\n  static constexpr const char* const ANSI_RESET = \"\\x1b[0m\";\n};\n\n// Identity function to suppress \"-Wunused-value\" warnings in DBG_MACRO_DISABLE\n// mode\ntemplate <typename T>\nT&& identity(T&& t) {\n  return std::forward<T>(t);\n}\n\ntemplate <typename T, typename... U>\nauto identity(T&&, U&&... u) -> last_t<U...> {\n  return identity(std::forward<U>(u)...);\n}\n\n}  // namespace dbg\n\n#ifndef DBG_MACRO_DISABLE\n\n// Force expanding argument with commas for MSVC, ref:\n// https://stackoverflow.com/questions/35210637/macro-expansion-argument-with-commas\n// Note that \"args\" should be a tuple with parentheses, such as \"(e1, e2, ...)\".\n#define DBG_IDENTITY(x) x\n#define DBG_CALL(fn, args) DBG_IDENTITY(fn args)\n\n#define DBG_CAT_IMPL(_1, _2) _1##_2\n#define DBG_CAT(_1, _2) DBG_CAT_IMPL(_1, _2)\n\n#define DBG_16TH_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, \\\n                      _14, _15, _16, ...)                                     \\\n  _16\n#define DBG_16TH(args) DBG_CALL(DBG_16TH_IMPL, args)\n#define DBG_NARG(...) \\\n  DBG_16TH((__VA_ARGS__, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0))\n\n// DBG_VARIADIC_CALL(fn, data, e1, e2, ...) => fn_N(data, (e1, e2, ...))\n#define DBG_VARIADIC_CALL(fn, data, ...) \\\n  DBG_CAT(fn##_, DBG_NARG(__VA_ARGS__))(data, (__VA_ARGS__))\n\n// (e1, e2, e3, ...) => e1\n#define DBG_HEAD_IMPL(_1, ...) _1\n#define DBG_HEAD(args) DBG_CALL(DBG_HEAD_IMPL, args)\n\n// (e1, e2, e3, ...) => (e2, e3, ...)\n#define DBG_TAIL_IMPL(_1, ...) (__VA_ARGS__)\n#define DBG_TAIL(args) DBG_CALL(DBG_TAIL_IMPL, args)\n\n#define DBG_MAP_1(fn, args) DBG_CALL(fn, args)\n#define DBG_MAP_2(fn, args) fn(DBG_HEAD(args)), DBG_MAP_1(fn, DBG_TAIL(args))\n#define DBG_MAP_3(fn, args) fn(DBG_HEAD(args)), DBG_MAP_2(fn, DBG_TAIL(args))\n#define DBG_MAP_4(fn, args) fn(DBG_HEAD(args)), DBG_MAP_3(fn, DBG_TAIL(args))\n#define DBG_MAP_5(fn, args) fn(DBG_HEAD(args)), DBG_MAP_4(fn, DBG_TAIL(args))\n#define DBG_MAP_6(fn, args) fn(DBG_HEAD(args)), DBG_MAP_5(fn, DBG_TAIL(args))\n#define DBG_MAP_7(fn, args) fn(DBG_HEAD(args)), DBG_MAP_6(fn, DBG_TAIL(args))\n#define DBG_MAP_8(fn, args) fn(DBG_HEAD(args)), DBG_MAP_7(fn, DBG_TAIL(args))\n#define DBG_MAP_9(fn, args) fn(DBG_HEAD(args)), DBG_MAP_8(fn, DBG_TAIL(args))\n#define DBG_MAP_10(fn, args) fn(DBG_HEAD(args)), DBG_MAP_9(fn, DBG_TAIL(args))\n#define DBG_MAP_11(fn, args) fn(DBG_HEAD(args)), DBG_MAP_10(fn, DBG_TAIL(args))\n#define DBG_MAP_12(fn, args) fn(DBG_HEAD(args)), DBG_MAP_11(fn, DBG_TAIL(args))\n#define DBG_MAP_13(fn, args) fn(DBG_HEAD(args)), DBG_MAP_12(fn, DBG_TAIL(args))\n#define DBG_MAP_14(fn, args) fn(DBG_HEAD(args)), DBG_MAP_13(fn, DBG_TAIL(args))\n#define DBG_MAP_15(fn, args) fn(DBG_HEAD(args)), DBG_MAP_14(fn, DBG_TAIL(args))\n#define DBG_MAP_16(fn, args) fn(DBG_HEAD(args)), DBG_MAP_15(fn, DBG_TAIL(args))\n\n// DBG_MAP(fn, e1, e2, e3, ...) => fn(e1), fn(e2), fn(e3), ...\n#define DBG_MAP(fn, ...) DBG_VARIADIC_CALL(DBG_MAP, fn, __VA_ARGS__)\n\n#define DBG_STRINGIFY_IMPL(x) #x\n#define DBG_STRINGIFY(x) DBG_STRINGIFY_IMPL(x)\n\n#define DBG_TYPE_NAME(x) dbg::type_name<decltype(x)>()\n\n#define dbg(...)                                    \\\n  dbg::DebugOutput(__FILE__, __LINE__, __func__)    \\\n      .print({DBG_MAP(DBG_STRINGIFY, __VA_ARGS__)}, \\\n             {DBG_MAP(DBG_TYPE_NAME, __VA_ARGS__)}, __VA_ARGS__)\n#else\n#define dbg(...) dbg::identity(__VA_ARGS__)\n#endif  // DBG_MACRO_DISABLE\n\n#endif  // DBG_MACRO_DBG_H\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}