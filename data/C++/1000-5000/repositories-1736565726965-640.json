{
  "metadata": {
    "timestamp": 1736565726965,
    "page": 640,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "seenaburns/dex-ui",
      "stars": 2404,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.009765625,
          "content": ".DS_Store\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.462890625,
          "content": "Copyright (c) 2015, Seena Burns\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the <organization> nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.6982421875,
          "content": "DEX UI\n===\n\n![DEX UI Full Screenshot](http://i.imgur.com/2rjIbFa.png)\n\n*DEX UI is a handcrafted interface programmed in openFrameworks, running fullscreen underneath a functioning terminal, giving the experience of having a sci fi computer.* [More.](http://nnkd.org/dexui/)\n\nThe project's source code is hosted here for reference. Included are the openFrameworks project source files and shaders, as well as the changes I made to BSPWM (more below). Not included are things like fonts and images.\n\nNote: Dex UI was designed as an experiment or an art piece, not distributable software, so as a result, the code (though I've cleaned it up some) is not the easiest to sort through. Also, because it is no longer in development, I won't be trying to make this work on other people machines - that part's up to you.\n\nQ&A\n---\n\n**What's Happening in the Video Demo**\n\nReal desktops revolve around windows, but most sci fi interfaces have these integrated desktops with all sort of animations and no apparent windows. Dex UI aimed to create the illusion of a desktop environment without windows while in reality still operating with windows (in X Windowing System).\n\nTo do this, the interface is a single openFrameworks program that handles all the animations. By modifying BSPWM I added a window mode to allow the interface to sit fullscreen beneath any other window. After the introduction animation occurs, a terminal (URXVT) is created above the interface and its size is constrained to the outline drawn in the interface. In short it is two layered windows, but because the windows have no borders or shadows, visually this looks like one integrated interface.\n\n**How do I run Dex UI**\n\nThe code here is for an [openFrameworks](http://www.openframeworks.cc/) project. The first step is to get openFrameworks, and get the graphics examples running to confirm it's really working. Then you can start a new project and add the files. Beyond that, fonts and images are not included here, which may be problematic as all of the type work is hard coded.\n\n**How I contribute?**\n\nThis project is here for reference and not in active development, so it is very unlikely I will continue to make changes, or respond to requests to make changes.\n\n**Why openFrameworks?**\n\nI needed something capable of creating lots of dynamic animations. This could be Processing, pure OpenGL, openFrameworks, etc. Originally my prototypes were in Processing, but for performance reasons I switched to openFrameworks. From what I've learned, many movie interfaces are put together in AfterEffects, so if you wanted to create an interface that did not respond to input, this is also an option.\n\n**BSPWM?**\n\nBSPWM was what I was working with, but it took some effort to make a window persistently stay fullscreen. The choice of window manager isn't a huge deal, just find something to make the illusion work.\n\nI've also included a .diff file with the changes (to BSPWM commit c49bc92) I made to BSPWM to add what I (for no reason) named power mode. A window can be set to power mode making it stay fullscreen, beneath all other windows across multiple desktops. I've been told a similar effect can be achieved with wmutils, and this might be an easier route.\n\n**Font?**\n\nInside the terminal we have Fira Mono, and the rest is United Sans Medium.\n\n**Is this working with real data**\n\nThe keyboard contains some code to work using /dev/input, but the rest still needs to be hooked up to system data. Luckily this is straightforward and only requires replacing the generated data with sampled data.\n\n**Why the onscreen Keyboard, does it work with touch screens?**\n\nIt's there because I think it looks cool. While it doesn't work with touch screens, it might be possible by making the project respond to mouse/touch input.\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "bspwm-power.diff",
          "type": "blob",
          "size": 8.6474609375,
          "content": "diff --git a/messages.c b/messages.c\nindex d859a3f..8b3d3d1 100644\n--- a/messages.c\n+++ b/messages.c\n@@ -218,6 +218,13 @@ int cmd_window(char **args, int num)\n \t\t\t\tset_sticky(trg.monitor, trg.desktop, trg.node, (a == ALTER_SET ? b : !trg.node->client->sticky));\n \t\t\t} else if (streq(\"private\", key)) {\n \t\t\t\tset_private(trg.monitor, trg.desktop, trg.node, (a == ALTER_SET ? b : !trg.node->client->private));\n+      } else if (streq(\"power\", key)) {\n+        fprintf(stderr, \"SETTING POWER MODE ON\\n\");\n+        set_power(trg.monitor, trg.desktop, trg.node, true);\n+\t\t\t\tset_sticky(trg.monitor, trg.desktop, trg.node, true);\n+        set_locked(trg.monitor, trg.desktop, trg.node, true);\n+\t\t\t\tdirty = true;\n+        // set_power(trg.monitor, trg.desktop, trg.node, true);\n \t\t\t} else {\n \t\t\t\treturn MSG_FAILURE;\n \t\t\t}\ndiff --git a/pointer.c b/pointer.c\nindex 0f4fbf9..42b2925 100644\n--- a/pointer.c\n+++ b/pointer.c\n@@ -56,6 +56,7 @@ void grab_pointer(pointer_action_t pac)\n \n \t\tswitch (pac)  {\n \t\t\tcase ACTION_FOCUS:\n+\t\t\t  fprintf(stderr, \"Focus pointers %p\\n\", (void *)loc.node);\n \t\t\t\tif (loc.node != mon->desk->focus) {\n \t\t\t\t\tbool backup = pointer_follows_monitor;\n \t\t\t\t\tpointer_follows_monitor = false;\ndiff --git a/query.c b/query.c\nindex 6aba083..09b8b5c 100644\n--- a/query.c\n+++ b/query.c\n@@ -317,6 +317,7 @@ bool locate_window(xcb_window_t win, coordinates_t *loc)\n \t\tfor (desktop_t *d = m->desk_head; d != NULL; d = d->next)\n \t\t\tfor (node_t *n = first_extrema(d->root); n != NULL; n = next_leaf(n, d->root))\n \t\t\t\tif (n->client->window == win) {\n+\t\t\t\t//if (n->client->window == win && !n->client->power) {\n \t\t\t\t\tloc->monitor = m;\n \t\t\t\t\tloc->desktop = d;\n \t\t\t\t\tloc->node = n;\ndiff --git a/stack.c b/stack.c\nindex 31397b2..8afe24b 100644\n--- a/stack.c\n+++ b/stack.c\n@@ -37,6 +37,7 @@ stacking_list_t *make_stack(node_t *n)\n \n void stack_insert_after(stacking_list_t *a, node_t *n)\n {\n+  fprintf(stderr, \"Stack insert after %p, %p\\n\", (void *)a, (void *)n);\n \tstacking_list_t *s = make_stack(n);\n \tif (a == NULL) {\n \t\tstack_head = stack_tail = s;\n@@ -53,16 +54,26 @@ void stack_insert_after(stacking_list_t *a, node_t *n)\n \t\tif (stack_tail == a)\n \t\t\tstack_tail = s;\n \t}\n+\tfprintf(stderr, \"stack_insert_after done\\n\");\n }\n \n void stack_insert_before(stacking_list_t *a, node_t *n)\n {\n+  if ( a != NULL)\n+    fprintf(stderr, \"Stack insert before %p:%d, %p:%d\\n\", (void *)a, a->node->client->power, (void *)n, n->client->power);\n+  else\n+    fprintf(stderr, \"Stack insert before NULL, %p %p\\n\", (void *)a, (void *)n);\n \tstacking_list_t *s = make_stack(n);\n \tif (a == NULL) {\n \t\tstack_head = stack_tail = s;\n \t} else {\n \t\tif (a->node == n)\n \t\t\treturn;\n+\t\t/*if (a->node->client->power) {\n+\t\t  fprintf(stderr, \"  stack after next\\n\");\n+\t\t  stack_insert_before(a->next, n);\n+\t\t  return;\n+    }*/\n \t\tremove_stack_node(n);\n \t\tstacking_list_t *b = a->prev;\n \t\tif (b != NULL)\n@@ -73,6 +84,7 @@ void stack_insert_before(stacking_list_t *a, node_t *n)\n \t\tif (stack_head == a)\n \t\t\tstack_head = s;\n \t}\n+\tfprintf(stderr, \"stack_insert_before done\\n\");\n }\n \n void remove_stack(stacking_list_t *s)\n@@ -104,14 +116,20 @@ void remove_stack_node(node_t *n)\n void stack(node_t *n, stack_flavor_t f)\n {\n \tPRINTF(\"stack %X\\n\", n->client->window);\n+  fprintf(stderr, \"stack power mode %p\\n\", (void *)n);\n \n-\tif (stack_head == NULL) {\n+\tif (stack_head == NULL && !n->client->power) {\n+\t  fprintf(stderr, \"stack_head null\\n\");\n \t\tstack_insert_after(NULL, n);\n+  } else if (n->client->power) {\n+    fprintf(stderr, \"stack POWER NODE %p before head\\n\", (void *)n);\n+    stack_insert_before(stack_head, n);\n+    window_lower(n->client->window);\n \t} else if (n->client->fullscreen) {\n \t\tif (f == STACK_ABOVE) {\n \t\t\tstack_insert_after(stack_tail, n);\n \t\t\twindow_raise(n->client->window);\n-\t\t}\n+    }\n \t} else {\n \t\tif (f == STACK_ABOVE && n->client->floating && !auto_raise)\n \t\t\treturn;\n@@ -120,6 +138,9 @@ void stack(node_t *n, stack_flavor_t f)\n \t\tstacking_list_t *oldest_fullscreen = NULL;\n \t\tfor (stacking_list_t *s = (f == STACK_ABOVE ? stack_tail : stack_head); s != NULL; s = (f == STACK_ABOVE ? s->prev : s->next)) {\n \t\t\tif (s->node != n) {\n+\t\t    if (s->node->client->power)\n+\t\t      continue;\n+\n \t\t\t\tif (s->node->client->fullscreen) {\n \t\t\t\t\tif (oldest_fullscreen == NULL)\n \t\t\t\t\t\toldest_fullscreen = s;\n@@ -161,4 +182,18 @@ void stack(node_t *n, stack_flavor_t f)\n \t\t\t}\n \t\t}\n \t}\n+\n+  stacking_list_t *s = stack_head;\n+  stacking_list_t *b = stack_head;\n+  while(s != NULL) {\n+    b = s->next;\n+\t  fprintf(stderr, \"Restack power loop\\n\");\n+\t  if (s->node->client->power && stack_head != s) {\n+\t    fprintf(stderr, \"- window lower power to before stack_head %X\", s->node->client->window);\n+\t    window_below(s->node->client->window, stack_head->node->client->window);\n+\t    fprintf(stderr, \"- move power to before stack_head %X\", s->node->client->window);\n+\t    stack_insert_before(stack_head, s->node);\n+    }\n+    s = b;\n+  }\n }\ndiff --git a/tree.c b/tree.c\nindex 82786d0..590bb0d 100644\n--- a/tree.c\n+++ b/tree.c\n@@ -284,6 +284,9 @@ void pseudo_focus(monitor_t *m, desktop_t *d, node_t *n)\n \n void focus_node(monitor_t *m, desktop_t *d, node_t *n)\n {\n+  // if (n != NULL && n->client->power)\n+  //   n = NULL;\n+\n \tif (mon->desk != d || n == NULL)\n \t\tclear_input_focus();\n \n@@ -297,6 +300,7 @@ void focus_node(monitor_t *m, desktop_t *d, node_t *n)\n \t\t\ta = b;\n \t\t}\n \t\tsticky_still = true;\n+\t\t//if (n == NULL && d->focus != NULL && !d->focus->client->power)\n \t\tif (n == NULL && d->focus != NULL)\n \t\t\tn = d->focus;\n \t}\n@@ -388,6 +392,7 @@ client_t *make_client(xcb_window_t win, unsigned int border_width)\n \tc->border_width = border_width;\n \tc->pseudo_tiled = c->floating = c->fullscreen = false;\n \tc->locked = c->sticky = c->urgent = c->private = c->icccm_focus = false;\n+\tc->power = false;\n \txcb_icccm_get_wm_protocols_reply_t protocols;\n \tif (xcb_icccm_get_wm_protocols_reply(dpy, xcb_icccm_get_wm_protocols(dpy, win, ewmh->WM_PROTOCOLS), &protocols, NULL) == 1) {\n \t\tif (has_proto(WM_TAKE_FOCUS, &protocols))\ndiff --git a/types.h b/types.h\nindex fb7494a..220c6f8 100644\n--- a/types.h\n+++ b/types.h\n@@ -159,6 +159,7 @@ typedef struct {\n \tbool sticky;\n \tbool urgent;\n \tbool private;\n+\tbool power;\n \tbool icccm_focus;\n \txcb_rectangle_t floating_rectangle;\n \txcb_rectangle_t tiled_rectangle;\ndiff --git a/window.c b/window.c\nindex 253e80d..3566e93 100644\n--- a/window.c\n+++ b/window.c\n@@ -373,7 +373,7 @@ void window_kill(monitor_t *m, desktop_t *d, node_t *n)\n \n void set_fullscreen(node_t *n, bool value)\n {\n-\tif (n == NULL || n->client->fullscreen == value)\n+\tif (n == NULL || (n->client->power == true && value == false) || n->client->fullscreen == value)\n \t\treturn;\n \n \tclient_t *c = n->client;\n@@ -388,6 +388,51 @@ void set_fullscreen(node_t *n, bool value)\n \tstack(n, STACK_ABOVE);\n }\n \n+void set_power(monitor_t *m, desktop_t *d, node_t *n, bool value)\n+{\n+\tif (n == NULL || n->client->power == value)\n+\t\treturn;\n+\n+\tclient_t *c = n->client;\n+\n+\tPRINTF(\"power %X: %s\\n\", c->window, BOOLSTR(value));\n+\n+\tc->power = value;\n+\t// c->fullscreen = value;\n+\t\n+\tn->split_mode = MODE_AUTOMATIC;\n+\tc->floating = n->vacant = value;\n+\tupdate_vacant_state(n->parent);\n+\n+\tif (value) {\n+\t\tenable_floating_atom(c->window);\n+\t\tunrotate_brother(n);\n+\t} else {\n+\t\tdisable_floating_atom(c->window);\n+\t\trotate_brother(n);\n+\t}\n+\t\n+\t// No borders\n+\tn->client->border_width = 0;\n+\n+  // Move\n+  fprintf(stderr, \"move power %d, %d, %d, %d\\n\", m->rectangle.x, m->rectangle.y, m->rectangle.width, m->rectangle.height);\n+  window_move(c->window, m->rectangle.x, m->rectangle.y);\n+  window_resize(c->window, m->rectangle.width, m->rectangle.height);\n+  c->floating_rectangle = m->rectangle;\n+\n+  // Unfocus, select another node on desktop if possible\n+  d->focus = NULL;\n+  m->desk->focus = NULL;\n+  ewmh_update_active_window();\n+  clear_input_focus();\n+  focus_node(m, d, NULL);\n+\n+  // Send to bottom\n+\tfprintf(stderr, \"power %X: %s %d\\n\", c->window, BOOLSTR(value), n->client->power);\n+\tstack(n, STACK_BELOW);\n+}\n+\n void set_pseudo_tiled(node_t *n, bool value)\n {\n \tif (n == NULL || n->client->pseudo_tiled == value)\n@@ -614,6 +659,7 @@ void window_border_width(xcb_window_t win, uint32_t bw)\n void window_move(xcb_window_t win, int16_t x, int16_t y)\n {\n \tuint32_t values[] = {x, y};\n+\tfprintf(stderr, \"move window %d, %d\", x, y);\n \txcb_configure_window(dpy, win, XCB_CONFIG_WINDOW_X_Y, values);\n }\n \ndiff --git a/window.h b/window.h\nindex 9cf4eef..2414f5b 100644\n--- a/window.h\n+++ b/window.h\n@@ -43,6 +43,7 @@ void adopt_orphans(void);\n void window_close(node_t *n);\n void window_kill(monitor_t *m, desktop_t *d, node_t *n);\n void set_fullscreen(node_t *n, bool value);\n+void set_power(monitor_t *m, desktop_t *d, node_t *n, bool value);\n void set_pseudo_tiled(node_t *n, bool value);\n void set_floating(node_t *n, bool value);\n void set_locked(monitor_t *m, desktop_t *d, node_t *n, bool value);\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}