{
  "metadata": {
    "timestamp": 1736565613216,
    "page": 492,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "snes9xgit/snes9x",
      "stars": 2718,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 4.8056640625,
          "content": "# vim: sts=2 sw=2 ai\n\n################################################################################\n# snes9x\n################################################################################\n\nsnes9x_linux-gtk-amd64_task:\n  container:\n    image: gcc:latest\n\n  setup_script:\n    - git submodule update --init --recursive\n    - apt-get update && DEBIAN_FRONTEND=noninteractive apt-get -y install meson gettext libsdl2-dev libgtkmm-3.0-dev libgtk-3-dev libminizip-dev portaudio19-dev glslang-dev cmake\n\n  compile_script:\n    - cmake -G Ninja -B build -S gtk -DCMAKE_BUILD_TYPE=Release\n    - ninja -j2 -C build\n\n  package_script:\n    - mkdir snes9x\n    - cp -ar build/snes9x-gtk README.md LICENSE docs data gtk/AUTHORS snes9x/\n    - tar -caf \"snes9x-gtk-${CIRRUS_CHANGE_IN_REPO}.txz\" snes9x\n\n  build_artifacts:\n    path: \"snes9x-gtk-${CIRRUS_CHANGE_IN_REPO}.txz\"\n\n\nsnes9x_linux-x11-amd64_task:\n  container:\n    image: gcc:latest\n\n  setup_script:\n    - apt-get update && DEBIAN_FRONTEND=noninteractive apt-get -y install libxv-dev libxinerama-dev\n\n  compile_script:\n    - cd unix\n    - touch configure\n    - ./configure\n    - make -j2\n\n  package_script:\n    - mkdir snes9x\n    - cp -ar unix/snes9x unix/docs unix/snes9x.conf.default README.md LICENSE data snes9x/\n    - tar -caf \"snes9x-x11-${CIRRUS_CHANGE_IN_REPO}.txz\" snes9x\n\n  build_artifacts:\n    path: \"snes9x-x11-${CIRRUS_CHANGE_IN_REPO}.txz\"\n\n\nsnes9x_freebsd-x11-amd64_task:\n  freebsd_instance:\n    image: freebsd-13-2-release-amd64\n\n  setup_script:\n    - pkg install -y gmake pkgconf minizip libX11 libXext\n\n  compile_script:\n    - cd unix\n    - touch configure\n    - ./configure\n    - gmake -j2\n\n  package_script:\n    - mkdir snes9x\n    - cp -a unix/snes9x unix/docs unix/snes9x.conf.default README.md LICENSE data snes9x/\n    - tar -caf \"snes9x-x11-${CIRRUS_CHANGE_IN_REPO}.txz\" snes9x\n\n  build_artifacts:\n    path: \"snes9x-x11-${CIRRUS_CHANGE_IN_REPO}.txz\"\n\n\nsnes9x_macOS-amd64_task:\n  macos_instance:\n    image: ghcr.io/cirruslabs/macos-ventura-xcode:latest\n\n  compile_script:\n    - xcodebuild -project macosx/snes9x.xcodeproj -target Snes9x -configuration Release build CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO\n\n  package_script:\n    - mkdir snes9x\n    - cp -R macosx/build/Release/Snes9x.app macosx/docs README.md LICENSE snes9x/\n    - zip -r \"snes9x-${CIRRUS_CHANGE_IN_REPO}.zip\" snes9x\n\n  build_artifacts:\n    path: \"snes9x-${CIRRUS_CHANGE_IN_REPO}.zip\"\n\n################################################################################\n# libretro\n################################################################################\n\nlibretro_linux-amd64_task:\n  container:\n    image: gcc:latest\n  compile_script:\n    - make -j2 -C libretro\n  build_artifacts:\n    path: \"libretro/snes9x_libretro.so\"\n\n\nlibretro_linux-i386_task:\n  container:\n    image: dockcross/linux-x86\n  compile_script:\n    - make -j2 -C libretro\n  build_artifacts:\n    path: \"libretro/snes9x_libretro.so\"\n\n\nlibretro_linux-armhf_task:\n  container:\n    image: dockcross/linux-armv7\n  compile_script:\n    - make -j2 -C libretro\n  build_artifacts:\n    path: \"libretro/snes9x_libretro.so\"\n\n\nlibretro_linux-armv7-neon-hf_task:\n  container:\n    image: dockcross/linux-armv7\n  compile_script:\n    - make -j2 -C libretro platform=unix-armv7-neon-hardfloat\n  build_artifacts:\n    path: \"libretro/snes9x_libretro.so\"\n\n\nlibretro_linux-arm64_task:\n  container:\n    image: dockcross/linux-arm64\n  compile_script:\n    - make -j2 -C libretro\n  build_artifacts:\n    path: \"libretro/snes9x_libretro.so\"\n\n\nlibretro_android-arm_task:\n  container:\n    image: dockcross/android-arm\n  compile_script:\n    - make -j2 -C libretro platform=unix\n  build_artifacts:\n    path: \"libretro/snes9x_libretro.so\"\n\n\nlibretro_android-arm64_task:\n  container:\n    image: dockcross/android-arm64\n  compile_script:\n    - make -j2 -C libretro platform=unix-arm64\n  build_artifacts:\n    path: \"libretro/snes9x_libretro.so\"\n\n\nlibretro_emscripten_task:\n  container:\n    image: gcc:latest\n  compile_script:\n    - make -j2 -C libretro platform=emscripten\n  build_artifacts:\n    path: \"libretro/snes9x_libretro_emscripten.bc\"\n\n\nlibretro_macOS-amd64_task:\n  macos_instance:\n    image: ghcr.io/cirruslabs/macos-ventura-xcode:latest\n  compile_script:\n    - make -j2 -C libretro\n  build_artifacts:\n    path: \"libretro/snes9x_libretro.dylib\"\n\n\nlibretro_nintendo-wii_task:\n  container:\n    image: devkitpro/devkitppc\n  compile_script:\n    - make -j2 -C libretro platform=wii\n  build_artifacts:\n    path: \"libretro/snes9x_libretro_wii.a\"\n\n\nlibretro_nintendo-switch-libnx_task:\n  container:\n    image: devkitpro/devkita64\n  compile_script:\n    - make -j2 -C libretro platform=libnx\n  build_artifacts:\n    path: \"libretro/snes9x_libretro_libnx.a\"\n\n\nlibretro_nintendo-ngc_task:\n  container:\n    image: devkitpro/devkitppc\n  compile_script:\n    - make -j2 -C libretro platform=ngc\n  build_artifacts:\n    path: \"libretro/snes9x_libretro_ngc.a\"\n\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 7.927734375,
          "content": "# Files that can arise when using snes9x\nwin32/snes9x.conf\nwin32/Valid.Ext\nwin32/stdout.txt\nwin32/stderr.txt\nwin32/Roms\nwin32/Saves\nwin32/Cheats\nwin32/Screenshots\nwin32/Movies\nwin32/SPCs\nwin32/BIOS\n*.smc\n*.sfc\n*.fig\n*.srm\n*.00[0123456789]\n*.oops\n*.ips\n*.ups\n*.bps\n*.avi\n*.shader\n*.cg\n*.cgp\n*.smv\n*.cht\n*.rtc\n\n\n# Included libraries in OS X that should not be ignored.\n!macosx/libz_u.a\n!macosx/libHIDUtilities_u.a\n\n# Included libraries in windows that should not be ignored.\n!win32/ddraw/ddraw_x86.lib\n!win32/ddraw/ddraw_x64.lib\n\n# Created by https://www.gitignore.io/api/c,c++,xcode,visualstudio\n# Edit at https://www.gitignore.io/?templates=c,c++,xcode,visualstudio\n\n### C ###\n# Prerequisites\n*.d\n\n# Object files\n*.o\n*.ko\n*.obj\n*.elf\n\n# Linker output\n*.ilk\n*.map\n*.exp\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Libraries\n*.lib\n*.a\n*.la\n*.lo\n\n# Shared objects (inc. Windows DLLs)\n*.dll\n*.so\n*.so.*\n*.dylib\n\n# Executables\n*.exe\n*.out\n*.app\n*.i*86\n*.x86_64\n*.hex\n\n# Debug files\n*.dSYM/\n*.su\n*.idb\n*.pdb\n\n# Kernel Module Compile Results\n*.mod*\n*.cmd\n.tmp_versions/\nmodules.order\nModule.symvers\nMkfile.old\ndkms.conf\n\n### C++ ###\n# Prerequisites\n\n# Compiled Object files\n*.slo\n\n# Precompiled Headers\n\n# Compiled Dynamic libraries\n\n# Fortran module files\n*.mod\n*.smod\n\n# Compiled Static libraries\n*.lai\n\n# Executables\n\n### Xcode ###\n# Xcode\n#\n# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore\n\n## User settings\nxcuserdata/\n\n## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)\n*.xcscmblueprint\n*.xccheckout\n\n## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)\nbuild/\nDerivedData/\n*.moved-aside\n*.pbxuser\n!default.pbxuser\n*.mode1v3\n!default.mode1v3\n*.mode2v3\n!default.mode2v3\n*.perspectivev3\n!default.perspectivev3\n\n## Xcode Patch\n*.xcodeproj/*\n!*.xcodeproj/project.pbxproj\n!*.xcodeproj/xcshareddata/\n!*.xcworkspace/contents.xcworkspacedata\n/*.gcno\n\n### Xcode Patch ###\n**/xcshareddata/WorkspaceSettings.xcsettings\n\n### VisualStudio ###\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.rsuser\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Mono auto generated files\nmono_crash.*\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\n[Aa][Rr][Mm]/\n[Aa][Rr][Mm]64/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015/2017 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# Visual Studio 2017 auto generated files\nGenerated\\ Files/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUnit\n*.VisualState.xml\nTestResult.xml\nnunit-*.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts/\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n\n# StyleCop\nStyleCopReport.xml\n\n# Files built by Visual Studio\n*_i.c\n*_p.c\n*_h.h\n*.meta\n*.iobj\n*.ipdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*_wpftmp.csproj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover/*\n!.axoCover/settings.json\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# NuGet Symbol Packages\n*.snupkg\n# The packages folder can be ignored because of Package Restore\n**/[Pp]ackages/*\n# except build/, which is used as an MSBuild target.\n!**/[Pp]ackages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/[Pp]ackages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n*.appxbundle\n*.appxupload\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!?*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Including strong name files can present a security risk\n# (https://github.com/github/gitignore/pull/2483#issue-259490424)\n#*.snk\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\nServiceFabricBackup/\n*.rptproj.bak\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n*.rptproj.rsuser\n*- [Bb]ackup.rdl\n*- [Bb]ackup ([0-9]).rdl\n*- [Bb]ackup ([0-9][0-9]).rdl\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# CodeRush personal settings\n.cr/personal\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover/\n\n# Azure Stream Analytics local run output\nASALocalRun/\n\n# MSBuild Binary and Structured Log\n*.binlog\n\n# NVidia Nsight GPU debugger configuration file\n*.nvuser\n\n# MFractors (Xamarin productivity tool) working folder\n.mfractor/\n\n# Local History for Visual Studio\n.localhistory/\n\n# BeatPulse healthcheck temp database\nhealthchecksdb\n\n# Backup folder for Package Reference Convert tool in Visual Studio 2017\nMigrationBackup/\n\n# End of https://www.gitignore.io/api/c,c++,xcode,visualstudio\n\n# vim\n*.swp\n\n# OS X temporary files\n.DS_Store\n*.lock\nprofile\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.6279296875,
          "content": "[submodule \"win32/libpng/src\"]\n\tpath = win32/libpng/src\n\turl = https://git.code.sf.net/p/libpng/code\n[submodule \"win32/zlib/src\"]\n\tpath = win32/zlib/src\n\turl = https://github.com/madler/zlib.git\n[submodule \"shaders/SPIRV-Cross\"]\n\tpath = external/SPIRV-Cross\n\turl = https://github.com/KhronosGroup/SPIRV-Cross.git\n[submodule \"shaders/glslang\"]\n\tpath = external/glslang\n\turl = https://github.com/KhronosGroup/glslang.git\n[submodule \"external/vulkan-headers\"]\n\tpath = external/vulkan-headers\n\turl = https://github.com/KhronosGroup/Vulkan-Headers.git\n[submodule \"external/cubeb\"]\n\tpath = external/cubeb\n\turl = https://github.com/mozilla/cubeb.git\n"
        },
        {
          "name": "65c816.h",
          "type": "blob",
          "size": 2.607421875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _65C816_H_\n#define _65C816_H_\n\n#define Carry\t\t1\n#define Zero\t\t2\n#define IRQ\t\t\t4\n#define Decimal\t\t8\n#define IndexFlag\t16\n#define MemoryFlag\t32\n#define Overflow\t64\n#define Negative\t128\n#define Emulation\t256\n\n#define SetCarry()\t\t\t(ICPU._Carry = 1)\n#define ClearCarry()\t\t(ICPU._Carry = 0)\n#define SetZero()\t\t\t(ICPU._Zero = 0)\n#define ClearZero()\t\t\t(ICPU._Zero = 1)\n#define SetIRQ()\t\t\t(Registers.PL |= IRQ)\n#define ClearIRQ()\t\t\t(Registers.PL &= ~IRQ)\n#define SetDecimal()\t\t(Registers.PL |= Decimal)\n#define ClearDecimal()\t\t(Registers.PL &= ~Decimal)\n#define SetIndex()\t\t\t(Registers.PL |= IndexFlag)\n#define ClearIndex()\t\t(Registers.PL &= ~IndexFlag)\n#define SetMemory()\t\t\t(Registers.PL |= MemoryFlag)\n#define ClearMemory()\t\t(Registers.PL &= ~MemoryFlag)\n#define SetOverflow()\t\t(ICPU._Overflow = 1)\n#define ClearOverflow()\t\t(ICPU._Overflow = 0)\n#define SetNegative()\t\t(ICPU._Negative = 0x80)\n#define ClearNegative()\t\t(ICPU._Negative = 0)\n\n#define CheckCarry()\t\t(ICPU._Carry)\n#define CheckZero()\t\t\t(ICPU._Zero == 0)\n#define CheckIRQ()\t\t\t(Registers.PL & IRQ)\n#define CheckDecimal()\t\t(Registers.PL & Decimal)\n#define CheckIndex()\t\t(Registers.PL & IndexFlag)\n#define CheckMemory()\t\t(Registers.PL & MemoryFlag)\n#define CheckOverflow()\t\t(ICPU._Overflow)\n#define CheckNegative()\t\t(ICPU._Negative & 0x80)\n#define CheckEmulation()\t(Registers.P.W & Emulation)\n\n#define SetFlags(f)\t\t\t(Registers.P.W |= (f))\n#define ClearFlags(f)\t\t(Registers.P.W &= ~(f))\n#define CheckFlag(f)\t\t(Registers.PL & (f))\n\ntypedef union\n{\n#ifdef LSB_FIRST\n\tstruct { uint8\tl, h; } B;\n#else\n\tstruct { uint8\th, l; } B;\n#endif\n\tuint16\tW;\n}\tpair;\n\ntypedef union\n{\n#ifdef LSB_FIRST\n\tstruct { uint8\txPCl, xPCh, xPB, z; } B;\n\tstruct { uint16\txPC, d; } W;\n#else\n\tstruct { uint8\tz, xPB, xPCh, xPCl; } B;\n\tstruct { uint16\td, xPC; } W;\n#endif\n    uint32\txPBPC;\n}\tPC_t;\n\nstruct SRegisters\n{\n\tuint8\tDB;\n\tpair\tP;\n\tpair\tA;\n\tpair\tD;\n\tpair\tS;\n\tpair\tX;\n\tpair\tY;\n\tPC_t\tPC;\n};\n\n#define AL\t\tA.B.l\n#define AH\t\tA.B.h\n#define XL\t\tX.B.l\n#define XH\t\tX.B.h\n#define YL\t\tY.B.l\n#define YH\t\tY.B.h\n#define SL\t\tS.B.l\n#define SH\t\tS.B.h\n#define DL\t\tD.B.l\n#define DH\t\tD.B.h\n#define PL\t\tP.B.l\n#define PH\t\tP.B.h\n#define PBPC\tPC.xPBPC\n#define PCw\t\tPC.W.xPC\n#define PCh\t\tPC.B.xPCh\n#define PCl\t\tPC.B.xPCl\n#define PB\t\tPC.B.xPB\n\nextern struct SRegisters\tRegisters;\n\n#endif\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 6.8818359375,
          "content": "  Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n\n  (c) Copyright 1996 - 2002  Gary Henderson (gary.henderson@ntlworld.com),\n                             Jerremy Koot (jkoot@snes9x.com)\n\n  (c) Copyright 2002 - 2004  Matthew Kendora\n\n  (c) Copyright 2002 - 2005  Peter Bortas (peter@bortas.org)\n\n  (c) Copyright 2004 - 2005  Joel Yliluoma (http://iki.fi/bisqwit/)\n\n  (c) Copyright 2001 - 2006  John Weidman (jweidman@slip.net)\n\n  (c) Copyright 2002 - 2006  funkyass (funkyass@spam.shaw.ca),\n                             Kris Bleakley (codeviolation@hotmail.com)\n\n  (c) Copyright 2002 - 2010  Brad Jorsch (anomie@users.sourceforge.net),\n                             Nach (n-a-c-h@users.sourceforge.net),\n\n  (c) Copyright 2002 - 2011  zones (kasumitokoduck@yahoo.com)\n\n  (c) Copyright 2006 - 2007  nitsuja\n\n  (c) Copyright 2009 - 2023  BearOso,\n                             OV2\n\n  (c) Copyright 2017         qwertymodo\n\n  (c) Copyright 2011 - 2017  Hans-Kristian Arntzen,\n                             Daniel De Matteis\n                             (Under no circumstances will commercial rights be given)\n\n\n  BS-X C emulator code\n  (c) Copyright 2005 - 2006  Dreamer Nom,\n                             zones\n\n  C4 x86 assembler and some C emulation code\n  (c) Copyright 2000 - 2003  _Demo_ (_demo_@zsnes.com),\n                             Nach,\n                             zsKnight (zsknight@zsnes.com)\n\n  C4 C++ code\n  (c) Copyright 2003 - 2006  Brad Jorsch,\n                             Nach\n\n  DSP-1 emulator code\n  (c) Copyright 1998 - 2006  _Demo_,\n                             Andreas Naive (andreasnaive@gmail.com),\n                             Gary Henderson,\n                             Ivar (ivar@snes9x.com),\n                             John Weidman,\n                             Kris Bleakley,\n                             Matthew Kendora,\n                             Nach,\n                             neviksti (neviksti@hotmail.com)\n\n  DSP-2 emulator code\n  (c) Copyright 2003         John Weidman,\n                             Kris Bleakley,\n                             Lord Nightmare (lord_nightmare@users.sourceforge.net),\n                             Matthew Kendora,\n                             neviksti\n\n  DSP-3 emulator code\n  (c) Copyright 2003 - 2006  John Weidman,\n                             Kris Bleakley,\n                             Lancer,\n                             z80 gaiden\n\n  DSP-4 emulator code\n  (c) Copyright 2004 - 2006  Dreamer Nom,\n                             John Weidman,\n                             Kris Bleakley,\n                             Nach,\n                             z80 gaiden\n\n  OBC1 emulator code\n  (c) Copyright 2001 - 2004  zsKnight,\n                             pagefault (pagefault@zsnes.com),\n                             Kris Bleakley\n                             Ported from x86 assembler to C by sanmaiwashi\n\n  SPC7110 and RTC C++ emulator code used in 1.39-1.51\n  (c) Copyright 2002         Matthew Kendora with research by\n                             zsKnight,\n                             John Weidman,\n                             Dark Force\n\n  SPC7110 and RTC C++ emulator code used in 1.52+\n  (c) Copyright 2009         byuu,\n                             neviksti\n\n  S-DD1 C emulator code\n  (c) Copyright 2003         Brad Jorsch with research by\n                             Andreas Naive,\n                             John Weidman\n\n  S-RTC C emulator code\n  (c) Copyright 2001 - 2006  byuu,\n                             John Weidman\n\n  ST010 C++ emulator code\n  (c) Copyright 2003         Feather,\n                             John Weidman,\n                             Kris Bleakley,\n                             Matthew Kendora\n\n  Super FX x86 assembler emulator code\n  (c) Copyright 1998 - 2003  _Demo_,\n                             pagefault,\n                             zsKnight\n\n  Super FX C emulator code\n  (c) Copyright 1997 - 1999  Ivar,\n                             Gary Henderson,\n                             John Weidman\n\n  Sound emulator code used in 1.5-1.51\n  (c) Copyright 1998 - 2003  Brad Martin\n  (c) Copyright 1998 - 2006  Charles Bilyue'\n\n  Sound emulator code used in 1.52+\n  (c) Copyright 2004 - 2007  Shay Green (gblargg@gmail.com)\n\n  S-SMP emulator code used in 1.54+\n  (c) Copyright 2016         byuu\n\n  SH assembler code partly based on x86 assembler code\n  (c) Copyright 2002 - 2004  Marcus Comstedt (marcus@mc.pp.se)\n\n  2xSaI filter\n  (c) Copyright 1999 - 2001  Derek Liauw Kie Fa\n\n  HQ2x, HQ3x, HQ4x filters\n  (c) Copyright 2003         Maxim Stepin (maxim@hiend3d.com)\n\n  NTSC filter\n  (c) Copyright 2006 - 2007  Shay Green\n\n  GTK+ GUI code\n  (c) Copyright 2004 - 2023  BearOso\n\n  Win32 GUI code\n  (c) Copyright 2003 - 2006  blip,\n                             funkyass,\n                             Matthew Kendora,\n                             Nach,\n                             nitsuja\n  (c) Copyright 2009 - 2023  OV2\n\n  Original Mac OS GUI code\n  (c) Copyright 1998 - 2001  John Stiles\n  (c) Copyright 2001 - 2011  zones\n  New MacOS GUI code\n  (c) Copyright 2022 - 2023  Michael Donald Buckley\n\n  Libretro port\n  (c) Copyright 2011 - 2017  Hans-Kristian Arntzen,\n                             Daniel De Matteis\n                             (Under no circumstances will commercial rights be given)\n\n\n  Specific ports contains the works of other authors. See headers in\n  individual files.\n\n\n  Snes9x homepage: http://www.snes9x.com/\n  Snes9x source code: https://github.com/snes9xgit/snes9x/\n\n  Permission to use, copy, modify and/or distribute Snes9x in both binary\n  and source form, for non-commercial purposes, is hereby granted without\n  fee, providing that this license information and copyright notice appear\n  with all copies and any derived work.\n\n  This software is provided 'as-is', without any express or implied\n  warranty. In no event shall the authors be held liable for any damages\n  arising from the use of this software or it's derivatives.\n\n  Snes9x is freeware for PERSONAL USE only. Commercial users should\n  seek permission of the copyright holders first. Commercial use includes,\n  but is not limited to, charging money for Snes9x or software derived from\n  Snes9x, including Snes9x or derivatives in commercial game bundles, and/or\n  using Snes9x as a promotion for your commercial product.\n\n  The copyright holders request that bug fixes and improvements to the code\n  should be forwarded to them so everyone can benefit from the modifications\n  in future versions.\n\n  Super NES and Super Nintendo Entertainment System are trademarks of\n  Nintendo Co., Limited and its subsidiary companies.\n\n-------------------------------------------------------------------------------\n\nSome parts included in Snes9x are usually available under a different license,\ntheir authors have granted exception for their use in Snes9x (and/or they are\nlicensed as LGPL):\n - JMA: GPL/LGPL, see jma/license.txt\n - snes_ntsc: LGPL, see filter/snes_ntsc-license.txt\n - xBRZ: GPLv3, see filter/xbrz-license.txt\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.0185546875,
          "content": "# Snes9x\n*Snes9x - Portable Super Nintendo Entertainment System (TM) emulator*\n\nThis is the official source code repository for the Snes9x project.\n\nPlease check the [Wiki](https://github.com/snes9xgit/snes9x/wiki) for additional information.\n\n## Nightly builds\n\nDownload nightly builds from continuous integration:\n\n### snes9x\n\n| OS            | status                                           |\n|---------------|--------------------------------------------------|\n| Windows       | [![Status][s9x-win-all]][appveyor]               |\n| Linux (GTK)   | [![Status][snes9x_linux-gtk-amd64]][cirrus-ci]   |\n| Linux (X11)   | [![Status][snes9x_linux-x11-amd64]][cirrus-ci]   |\n| FreeBSD (X11) | [![Status][snes9x_freebsd-x11-amd64]][cirrus-ci] |\n| macOS         | [![Status][snes9x_macOS-amd64]][cirrus-ci]       |\n\n[appveyor]: https://ci.appveyor.com/project/snes9x/snes9x\n[cirrus-ci]: http://cirrus-ci.com/github/snes9xgit/snes9x\n\n[s9x-win-all]: https://ci.appveyor.com/api/projects/status/github/snes9xgit/snes9x?branch=master&svg=true\n[snes9x_linux-gtk-amd64]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=snes9x_linux-gtk-amd64\n[snes9x_linux-x11-amd64]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=snes9x_linux-x11-amd64\n[snes9x_freebsd-x11-amd64]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=snes9x_freebsd-x11-amd64\n[snes9x_macOS-amd64]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=snes9x_macOS-amd64\n\n### libretro core\n\n| OS                  | status                                                  |\n|---------------------|---------------------------------------------------------|\n| Linux/amd64         | [![Status][libretro_linux-amd64]][cirrus-ci]            |\n| Linux/i386          | [![Status][libretro_linux-i386]][cirrus-ci]             |\n| Linux/armhf         | [![Status][libretro_linux-armhf]][cirrus-ci]            |\n| Linux/armv7-neon-hf | [![Status][libretro_linux-armv7-neon-hf]][cirrus-ci]    |\n| Linux/arm64         | [![Status][libretro_linux-arm64]][cirrus-ci]            |\n| Android/arm         | [![Status][libretro_android-arm]][cirrus-ci]            |\n| Android/arm64       | [![Status][libretro_android-arm64]][cirrus-ci]          |\n| Emscripten          | [![Status][libretro_emscripten]][cirrus-ci]             |\n| macOS/amd64         | [![Status][libretro_macOS-amd64]][cirrus-ci]            |\n| Nintendo Wii        | [![Status][libretro_nintendo-wii]][cirrus-ci]           |\n| Nintendo Switch     | [![Status][libretro_nintendo-switch-libnx]][cirrus-ci]  |\n| Nintendo GameCube   | [![Status][libretro_nintendo-ngc]][cirrus-ci]           |\n| PSP                 | [![Status][libretro_playstation-psp]][cirrus-ci]        |\n\n[libretro_linux-amd64]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_linux-amd64\n[libretro_linux-i386]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_linux-i386\n[libretro_linux-armhf]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_linux-armhf\n[libretro_linux-armv7-neon-hf]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_linux-armv7-neon-hf\n[libretro_linux-arm64]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_linux-arm64\n[libretro_android-arm]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_android-arm\n[libretro_android-arm64]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_android-arm64\n[libretro_emscripten]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_emscripten\n[libretro_macOS-amd64]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_macOS-amd64\n[libretro_nintendo-wii]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_nintendo-wii\n[libretro_nintendo-switch-libnx]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_nintendo-switch-libnx\n[libretro_nintendo-ngc]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_nintendo-ngc\n[libretro_playstation-psp]: https://api.cirrus-ci.com/github/snes9xgit/snes9x.svg?task=libretro_playstation-psp\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 1.97265625,
          "content": "version: 1.63-{build}\n\nimage: Visual Studio 2022\n\nenvironment:\n  matrix:\n  - generator: \"Visual Studio 2022\"\n    config: Release Unicode\n    platform: Win32\n    arch: win32\n    output: win32\\snes9x.exe\n    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n\n  - generator: \"Visual Studio 2022\"\n    config: Release Unicode\n    platform: x64\n    arch: win32-x64\n    output: win32\\snes9x-x64.exe\n    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n\n  - generator: \"Visual Studio 2022\"\n    config: libretro Release\n    platform: Win32\n    arch: libretro\n    output: libretro\\Win32\\libretro Release\\snes9x_libretro.dll\n    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n\n  - generator: \"Visual Studio 2022\"\n    config: libretro Release\n    platform: x64\n    arch: libretro-x64\n    output: libretro\\x64\\libretro Release\\snes9x_libretro.dll\n    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2022\n\ninit:\n  - git config --global core.autocrlf input\n\nbefore_build:\n  - git submodule update --init --recursive\n\nbuild_script:\n  - if \"%config%\"==\"Release Unicode\" msbuild win32\\snes9xw.sln /t:build /p:Configuration=\"%config%\";Platform=\"%platform%\" /m /logger:\"C:\\Program Files\\AppVeyor\\BuildAgent\\Appveyor.MSBuildLogger.dll\"\n  - if \"%config%\"==\"libretro Release\" msbuild libretro\\libretro-win32.vcxproj /t:build /p:Configuration=\"%config%\";Platform=\"%platform%\" /m /logger:\"C:\\Program Files\\AppVeyor\\BuildAgent\\Appveyor.MSBuildLogger.dll\"\n\nafter_build:\n  - ps: $env:my_version = \"$env:APPVEYOR_BUILD_VERSION-$($env:APPVEYOR_REPO_COMMIT.substring(0,7))\"\n  - set package_name=snes9x-%my_version%-%arch%\n  - if exist artifacts rmdir /s /q artifacts\n  - mkdir artifacts\n  - copy \"%output%\" artifacts\n  - if \"%config%\"==\"Release Unicode\"\n    copy docs\\changes.txt artifacts |\n    copy LICENSE artifacts |\n    copy win32\\docs\\faqs-windows.txt artifacts |\n    copy win32\\docs\\readme-windows.txt artifacts |\n    copy data\\cheats.bml artifacts\n  - 7z a %package_name%.zip .\\artifacts\\*\n\nartifacts:\n  - path: $(package_name).zip\n    name: $(arch)\n"
        },
        {
          "name": "apu",
          "type": "tree",
          "content": null
        },
        {
          "name": "bml.cpp",
          "type": "blob",
          "size": 5.9443359375,
          "content": "#include <vector>\n#include <iostream>\n#include <fstream>\n#include <stack>\n#include <stdio.h>\n\n#include \"port.h\"\n#include \"bml.h\"\n\nbml_node::bml_node()\n{\n    type = CHILD;\n    depth = -1;\n}\n\nstatic inline int islf(char c)\n{\n    return (c == '\\r' || c == '\\n');\n}\n\nstatic inline int isblank(char c)\n{\n    return (c == ' ' || c == '\\t');\n}\n\nstatic inline int isblankorlf(char c)\n{\n    return (islf(c) || isblank(c));\n}\n\nstatic inline int isalnum(char c)\n{\n    return ((c >= 'a' && c <= 'z') ||\n            (c >= 'A' && c <= 'Z') ||\n            (c >= '0' && c <= '9'));\n}\n\nstatic inline int bml_valid(char c)\n{\n    return (isalnum(c) || c == '-');\n}\n\nstatic std::string trim(std::string str)\n{\n    int start;\n    int end;\n    for (start = 0; str[start] && start != (int)str.length() && isblank(str[start]); start++) {}\n    if (start >= (int)str.length())\n        return std::string(\"\");\n    for (end = str.length() - 1; isblankorlf(str[end]); end--) {}\n    return str.substr(start, end - start + 1);\n}\n\nstatic std::string trimcomments(std::string str)\n{\n    int end = str.length();\n    size_t comment = str.find(\"//\");\n    if (comment != std::string::npos)\n        end = comment;\n\n    for (int i = end - 1; i >= 0; i--)\n    {\n        if (!isblankorlf(str[i]))\n        {\n            end = i + 1;\n            break;\n        }\n    }\n\n    return str.substr(0, end);\n}\n\nstatic inline int bml_read_depth(std::string &data)\n{\n    size_t depth;\n    for (depth = 0; isblank(data[depth]) && depth < data.length(); depth++) {}\n    return depth == data.length() ? -1 : depth;\n}\n\nstatic void bml_parse_depth(bml_node &node, std::string &line)\n{\n    unsigned int depth = bml_read_depth(line);\n    line.erase(0, depth);\n    node.depth = depth;\n}\n\nstatic void bml_parse_name(bml_node &node, std::string &line)\n{\n    int len;\n\n    for (len = 0; bml_valid(line[len]); len++) {};\n\n    node.name = trim(line.substr(0, len));\n    line.erase(0, len);\n}\n\nstatic void bml_parse_data(bml_node &node, std::string &line)\n{\n    int len;\n\n    if (line[0] == '=' && line[1] == '\\\"')\n    {\n        len = 2;\n        while (line[len] && line[len] != '\\\"' && !islf(line[len]))\n            len++;\n        if (line[len] != '\\\"')\n            return;\n\n        node.data = line.substr(2, len - 2);\n        line.erase(0, len + 1);\n    }\n    else if (line[0] == '=')\n    {\n        len = 1;\n        while (line[len] && !islf(line[len]) && line[len] != '\"' && line[len] != ' ')\n            len++;\n        if (line[len] == '\\\"')\n            return;\n        node.data = line.substr(1, len - 1);\n        line.erase(0, len);\n    }\n    else if (line[0] == ':')\n    {\n        len = 1;\n        while (line[len] && !islf(line[len]))\n            len++;\n        node.data = trim(line.substr(1, len - 1));\n        line.erase(0, len);\n    }\n\n    return;\n}\n\nstatic std::string bml_read_line(std::ifstream &fd)\n{\n    std::string line;\n\n    while (fd)\n    {\n        std::getline(fd, line);\n        line = trimcomments(line);\n        if (!line.empty())\n        {\n            return line;\n        }\n    }\n\n    return std::string(\"\");\n}\n\nstatic void bml_parse_attr(bml_node &node, std::string &line)\n{\n    int len;\n\n    while (line.length() > 0)\n    {\n        if (!isblank(line[0]))\n            return;\n\n        while (isblank(line[0]))\n            line.erase(0, 1);\n\n        bml_node n;\n        len = 0;\n        while (bml_valid(line[len]))\n            len++;\n        if (len == 0)\n            return;\n        n.name = trim(line.substr(0, len));\n        line.erase(0, len);\n        bml_parse_data(n, line);\n        n.depth = node.depth + 1;\n        n.type = bml_node::ATTRIBUTE;\n        node.child.push_back(n);\n    }\n}\n\nstatic int contains_space(const char *str)\n{\n    for (int i = 0; str[i]; i++)\n    {\n        if (isblank(str[i]))\n            return 1;\n    }\n\n    return 0;\n}\n\nstatic void bml_print_node(bml_node &node, int depth)\n{\n    int i;\n\n    for (i = 0; i < depth * 2; i++)\n    {\n        printf(\" \");\n    }\n\n    if (!node.name.empty())\n        printf(\"%s\", node.name.c_str());\n\n    if (!node.data.empty())\n    {\n        if (contains_space(node.data.c_str()))\n            printf(\"=\\\"%s\\\"\", node.data.c_str());\n        else\n            printf(\": %s\", node.data.c_str());\n    }\n    for (i = 0; i < (int)node.child.size() && node.child[i].type == bml_node::ATTRIBUTE; i++)\n    {\n        if (!node.child[i].name.empty())\n        {\n            printf(\" %s\", node.child[i].name.c_str());\n            if (!node.child[i].data.empty())\n            {\n                if (contains_space(node.child[i].data.c_str()))\n                    printf(\"=\\\"%s\\\"\", node.child[i].data.c_str());\n                else\n                    printf(\"=%s\", node.child[i].data.c_str());\n            }\n        }\n    }\n\n    if (depth >= 0)\n        printf(\"\\n\");\n\n    for (; i < (int)node.child.size(); i++)\n    {\n        bml_print_node(node.child[i], depth + 1);\n    }\n\n    if (depth == 0)\n        printf(\"\\n\");\n}\n\nvoid bml_node::print()\n{\n    bml_print_node(*this, -1);\n}\n\nvoid bml_node::parse(std::ifstream &fd)\n{\n    std::stack<bml_node *> nodestack;\n    nodestack.push(this);\n\n    while (fd)\n    {\n        bml_node newnode;\n        std::string line = bml_read_line(fd);\n        if (line.empty())\n            return;\n\n        int line_depth = bml_read_depth(line);\n        while (line_depth <= nodestack.top()->depth && nodestack.size() > 1)\n            nodestack.pop();\n\n        bml_parse_depth(newnode, line);\n        bml_parse_name(newnode, line);\n        bml_parse_data(newnode, line);\n        bml_parse_attr(newnode, line);\n\n        nodestack.top()->child.push_back(newnode);\n        nodestack.push(&nodestack.top()->child.back());\n    }\n\n    return;\n}\n\nbml_node *bml_node::find_subnode(std::string name)\n{\n    unsigned int i;\n\n    for (i = 0; i < child.size(); i++)\n    {\n        if (name.compare(child[i].name) == 0)\n            return &child[i];\n    }\n\n    return NULL;\n}\n\nbool bml_node::parse_file(std::string filename)\n{\n    std::ifstream file(filename.c_str(), std::ios_base::binary);\n\n    if (!file)\n        return false;\n\n    parse(file);\n\n    return true;\n}\n"
        },
        {
          "name": "bml.h",
          "type": "blob",
          "size": 0.439453125,
          "content": "#ifndef __BML_H\n#define __BML_H\n#include <vector>\n#include <string>\n#include <fstream>\n\nstruct bml_node\n{\n    enum node_type {\n        CHILD,\n        ATTRIBUTE\n    };\n\n    bml_node();\n    bool parse_file(std::string filename);\n    void parse(std::ifstream &fd);\n    bml_node *find_subnode(std::string name);\n    void print();\n\n    std::string name;\n    std::string data;\n    int depth;\n    std::vector<bml_node> child;\n    node_type type;\n};\n\n#endif\n"
        },
        {
          "name": "bsx.cpp",
          "type": "blob",
          "size": 29.3544921875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n// Dreamer Nom wrote:\n// Large thanks to John Weidman for all his initial research\n// Thanks to Seph3 for his modem notes\n\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"display.h\"\n#include <math.h>\n\n//#define BSX_DEBUG\n\n#define BIOS_SIZE\t0x100000\n#define FLASH_SIZE\t0x100000\n#define PSRAM_SIZE\t0x80000\n\n#define Map\t\t\tMemory.Map\n#define BlockIsRAM\tMemory.BlockIsRAM\n#define BlockIsROM\tMemory.BlockIsROM\n#define RAM\t\t\tMemory.RAM\n#define SRAM\t\tMemory.SRAM\n#define PSRAM\t\tMemory.BSRAM\n#define BIOSROM\t\tMemory.BIOSROM\n#define MAP_BSX\t\tMemory.MAP_BSX\n#define MAP_CPU\t\tMemory.MAP_CPU\n#define MAP_PPU\t\tMemory.MAP_PPU\n#define MAP_NONE\tMemory.MAP_NONE\n\n#define BSXPPUBASE\t0x2180\n\nstruct SBSX_RTC\n{\n\tint year;\n\tint month;\n\tint dayweek;\n\tint day;\n\tint\thours;\n\tint\tminutes;\n\tint\tseconds;\n\tint\tticks;\n};\n\nstatic struct SBSX_RTC\tBSX_RTC;\n\n// flash card vendor information\nstatic const uint8\tflashcard[20] =\n{\n\t0x4D, 0x00, 0x50, 0x00,\t// vendor id\n\t0x00, 0x00,\t\t\t\t// ?\n\t0x1A, 0x00,\t\t\t\t// 2MB Flash (1MB = 0x2A)\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\n#if 0\nstatic const uint8\tinit2192[32] =\t// FIXME\n{\n\t00, 00, 00, 00, 00,\t\t// unknown\n\t01, 01, 00, 00, 00,\n\t00,\t\t\t\t\t\t// seconds (?)\n\t00,\t\t\t\t\t\t// minutes\n\t00,\t\t\t\t\t\t// hours\n\t10, 10, 10, 10, 10,\t\t// unknown\n\t10, 10, 10, 10, 10,\t\t// dummy\n\t00, 00, 00, 00, 00, 00, 00, 00, 00\n};\n#endif\n\nstatic bool8\tFlashMode;\nstatic uint32\tFlashSize;\nstatic uint8\t*MapROM, *FlashROM;\n\nstatic void BSX_Map_SNES (void);\nstatic void BSX_Map_LoROM (void);\nstatic void BSX_Map_HiROM (void);\nstatic void BSX_Map_MMC (void);\nstatic void BSX_Map_FlashIO (void);\nstatic void BSX_Map_SRAM (void);\nstatic void BSX_Map_PSRAM (void);\nstatic void BSX_Map_BIOS (void);\nstatic void BSX_Map_RAM (void);\nstatic void BSX_Map (void);\nstatic bool8 BSX_LoadBIOS (void);\nstatic void map_psram_mirror_sub (uint32);\nstatic int is_bsx (unsigned char *);\n\n\nstatic void BSX_Map_SNES (void)\n{\n\t// These maps will be partially overwritten\n\n\tint\tc;\n\n\t// Banks 00->3F and 80->BF\n\tfor (c = 0; c < 0x400; c += 16)\n\t{\n\t\tMap[c + 0] = Map[c + 0x800] = RAM;\n\t\tMap[c + 1] = Map[c + 0x801] = RAM;\n\t\tBlockIsRAM[c + 0] = BlockIsRAM[c + 0x800] = TRUE;\n\t\tBlockIsRAM[c + 1] = BlockIsRAM[c + 0x801] = TRUE;\n\n\t\tMap[c + 2] = Map[c + 0x802] = (uint8 *) MAP_PPU;\n\t\tMap[c + 3] = Map[c + 0x803] = (uint8 *) MAP_PPU;\n\t\tMap[c + 4] = Map[c + 0x804] = (uint8 *) MAP_CPU;\n\t\tMap[c + 5] = Map[c + 0x805] = (uint8 *) MAP_CPU;\n\t\tMap[c + 6] = Map[c + 0x806] = (uint8 *) MAP_NONE;\n\t\tMap[c + 7] = Map[c + 0x807] = (uint8 *) MAP_NONE;\n\t}\n}\n\nstatic void BSX_Map_LoROM (void)\n{\n\t// These maps will be partially overwritten\n\n\tint\ti, c;\n\n\t// Banks 00->3F and 80->BF\n\tfor (c = 0; c < 0x400; c += 16)\n\t{\n\t\tfor (i = c + 8; i < c + 16; i++)\n\t\t{\n\t\t\tMap[i] = Map[i + 0x800] = &MapROM[(c << 11) % FlashSize] - 0x8000;\n\t\t\tBlockIsRAM[i] = BlockIsRAM[i + 0x800] = BSX.write_enable;\n\t\t\tBlockIsROM[i] = BlockIsROM[i + 0x800] = !BSX.write_enable;\n\t\t}\n\t}\n\n\t// Banks 40->7F and C0->FF\n\tfor (c = 0; c < 0x400; c += 16)\n\t{\n\t\tfor (i = c; i < c + 8; i++)\n\t\t\tMap[i + 0x400] = Map[i + 0xC00] = &MapROM[(c << 11) % FlashSize];\n\n\t\tfor (i = c + 8; i < c + 16; i++)\n\t\t\tMap[i + 0x400] = Map[i + 0xC00] = &MapROM[(c << 11) % FlashSize] - 0x8000;\n\n\t\tfor (i = c; i < c + 16; i++)\n\t\t{\n\t\t\tBlockIsRAM[i + 0x400] = BlockIsRAM[i + 0xC00] = BSX.write_enable;\n\t\t\tBlockIsROM[i + 0x400] = BlockIsROM[i + 0xC00] = !BSX.write_enable;\n\t\t}\n\t}\n}\n\nstatic void BSX_Map_HiROM (void)\n{\n\t// These maps will be partially overwritten\n\n\tint\ti, c;\n\n\t// Banks 00->3F and 80->BF\n\tfor (c = 0; c < 0x400; c += 16)\n\t{\n\t\tfor (i = c + 8; i < c + 16; i++)\n\t\t{\n\t\t\tMap[i] = Map[i + 0x800] = &MapROM[(c << 12) % FlashSize];\n\t\t\tBlockIsRAM[i] = BlockIsRAM[i + 0x800] = BSX.write_enable;\n\t\t\tBlockIsROM[i] = BlockIsROM[i + 0x800] = !BSX.write_enable;\n\t\t}\n\t}\n\n\t// Banks 40->7F and C0->FF\n\tfor (c = 0; c < 0x400; c += 16)\n\t{\n\t\tfor (i = c; i < c + 16; i++)\n\t\t{\n\t\t\tMap[i + 0x400] = Map[i + 0xC00] = &MapROM[(c << 12) % FlashSize];\n\t\t\tBlockIsRAM[i + 0x400] = BlockIsRAM[i + 0xC00] = BSX.write_enable;\n\t\t\tBlockIsROM[i + 0x400] = BlockIsROM[i + 0xC00] = !BSX.write_enable;\n\t\t}\n\t}\n}\n\nstatic void BSX_Map_MMC (void)\n{\n\tint\tc;\n\n\t// Banks 01->0E:5000-5FFF\n\tfor (c = 0x010; c < 0x0F0; c += 16)\n\t{\n\t\tMap[c + 5] = (uint8 *) MAP_BSX;\n\t\tBlockIsRAM[c + 5] = BlockIsROM[c + 5] = FALSE;\n\t}\n}\n\nstatic void BSX_Map_FlashIO (void)\n{\n\tint\ti, c;\n\n\tif (BSX.prevMMC[0x0C])\n\t{\n\t\t// Banks 00->3F and 80->BF\n\t\tfor (c = 0; c < 0x400; c += 16)\n\t\t{\n\t\t\tfor (i = c + 8; i < c + 16; i++)\n\t\t\t{\n\t\t\t\tMap[i] = Map[i + 0x800] = (uint8 *)MAP_BSX;\n\t\t\t\tBlockIsRAM[i] = BlockIsRAM[i + 0x800] = TRUE;\n\t\t\t\tBlockIsROM[i] = BlockIsROM[i + 0x800] = FALSE;\n\t\t\t}\n\t\t}\n\n\t\t// Banks 40->7F and C0->FF\n\t\tfor (c = 0; c < 0x400; c += 16)\n\t\t{\n\t\t\tfor (i = c; i < c + 16; i++)\n\t\t\t{\n\t\t\t\tMap[i + 0x400] = Map[i + 0xC00] = (uint8 *)MAP_BSX;\n\t\t\t\tBlockIsRAM[i + 0x400] = BlockIsRAM[i + 0xC00] = TRUE;\n\t\t\t\tBlockIsROM[i + 0x400] = BlockIsROM[i + 0xC00] = FALSE;\n\t\t\t}\n\t\t}\n\t}\t\n}\n\nstatic void BSX_Map_SRAM (void)\n{\n\tint\tc;\n\n\t// Banks 10->17:5000-5FFF\n\tfor (c = 0x100; c < 0x180; c += 16)\n\t{\n\t\tMap[c + 5] = (uint8 *) SRAM + ((c & 0x70) << 8) - 0x5000;\n\t\tBlockIsRAM[c + 5] = TRUE;\n\t\tBlockIsROM[c + 5] = FALSE;\n\t}\n}\n\nstatic void map_psram_mirror_sub (uint32 bank)\n{\n\tint\ti, c;\n\n\tbank <<= 4;\n\n\tif (BSX.prevMMC[0x02])\n\t{\n\t\t//HiROM\n\t\tfor (c = 0; c < 0x80; c += 16)\n\t\t{\n\t\t\tif ((bank & 0x7F0) >= 0x400)\n\t\t\t{\n\t\t\t\tfor (i = c; i < c + 16; i++)\n\t\t\t\t{\n\t\t\t\t\tMap[i + bank] = &PSRAM[(c << 12) % PSRAM_SIZE];\n\t\t\t\t\tBlockIsRAM[i + bank] = TRUE;\n\t\t\t\t\tBlockIsROM[i + bank] = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (i = c + 8; i < c + 16; i++)\n\t\t\t\t{\n\t\t\t\t\tMap[i + bank] = &PSRAM[(c << 12) % PSRAM_SIZE];\n\t\t\t\t\tBlockIsRAM[i + bank] = TRUE;\n\t\t\t\t\tBlockIsROM[i + bank] = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t//LoROM\n\t\tfor (c = 0; c < 0x100; c += 16)\n\t\t{\n\t\t\tif ((bank & 0x7F0) >= 0x400)\n\t\t\t{\n\t\t\t\tfor (i = c; i < c + 8; i++)\n\t\t\t\t{\n\t\t\t\t\tMap[i + bank] = &PSRAM[(c << 11) % PSRAM_SIZE];\n\t\t\t\t\tBlockIsRAM[i + bank] = TRUE;\n\t\t\t\t\tBlockIsROM[i + bank] = FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = c + 8; i < c + 16; i++)\n\t\t\t{\n\t\t\t\tMap[i + bank] = &PSRAM[(c << 11) % PSRAM_SIZE] - 0x8000;\n\t\t\t\tBlockIsRAM[i + bank] = TRUE;\n\t\t\t\tBlockIsROM[i + bank] = FALSE;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void BSX_Map_PSRAM(void)\n{\n\tint\tc;\n\n\tif (!BSX.prevMMC[0x02])\n\t{\n\t\t//LoROM Mode\n\t\tif (!BSX.prevMMC[0x05] && !BSX.prevMMC[0x06])\n\t\t{\n\t\t\t//Map PSRAM to 00-0F/80-8F\n\t\t\tif (BSX.prevMMC[0x03])\n\t\t\t\tmap_psram_mirror_sub(0x00);\n\n\t\t\tif (BSX.prevMMC[0x04])\n\t\t\t\tmap_psram_mirror_sub(0x80);\n\t\t}\n\t\telse if (BSX.prevMMC[0x05] && !BSX.prevMMC[0x06])\n\t\t{\n\t\t\t//Map PSRAM to 20-2F/A0-AF\n\t\t\tif (BSX.prevMMC[0x03])\n\t\t\t\tmap_psram_mirror_sub(0x20);\n\n\t\t\tif (BSX.prevMMC[0x04])\n\t\t\t\tmap_psram_mirror_sub(0xA0);\n\t\t}\n\t\telse if (!BSX.prevMMC[0x05] && BSX.prevMMC[0x06])\n\t\t{\n\t\t\t//Map PSRAM to 40-4F/C0-CF\n\t\t\tif (BSX.prevMMC[0x03])\n\t\t\t\tmap_psram_mirror_sub(0x40);\n\n\t\t\tif (BSX.prevMMC[0x04])\n\t\t\t\tmap_psram_mirror_sub(0xC0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Map PSRAM to 60-6F/E0-EF\n\t\t\tif (BSX.prevMMC[0x03])\n\t\t\t\tmap_psram_mirror_sub(0x60);\n\n\t\t\tif (BSX.prevMMC[0x04])\n\t\t\t\tmap_psram_mirror_sub(0xE0);\n\t\t}\n\n\t\t//Map PSRAM to 70-7D/F0-FF\n\t\tif (BSX.prevMMC[0x03])\n\t\t\tmap_psram_mirror_sub(0x70);\n\n\t\tif (BSX.prevMMC[0x04])\n\t\t\tmap_psram_mirror_sub(0xF0);\n\t}\n\telse\n\t{\n\t\t//HiROM Mode\n\t\tif (!BSX.prevMMC[0x05] && !BSX.prevMMC[0x06])\n\t\t{\n\t\t\t//Map PSRAM to 00-07/40-47 / 80-87/C0-C7\n\t\t\tif (BSX.prevMMC[0x03])\n\t\t\t{\n\t\t\t\tmap_psram_mirror_sub(0x00);\n\t\t\t\tmap_psram_mirror_sub(0x40);\n\t\t\t}\n\n\t\t\tif (BSX.prevMMC[0x04])\n\t\t\t{\n\t\t\t\tmap_psram_mirror_sub(0x80);\n\t\t\t\tmap_psram_mirror_sub(0xC0);\n\t\t\t}\n\t\t}\n\t\telse if (BSX.prevMMC[0x05] && !BSX.prevMMC[0x06])\n\t\t{\n\t\t\t//Map PSRAM to 10-17/50-57 / 90-97-D0-D7\n\t\t\tif (BSX.prevMMC[0x03])\n\t\t\t{\n\t\t\t\tmap_psram_mirror_sub(0x10);\n\t\t\t\tmap_psram_mirror_sub(0x50);\n\t\t\t}\n\n\t\t\tif (BSX.prevMMC[0x04])\n\t\t\t{\n\t\t\t\tmap_psram_mirror_sub(0x90);\n\t\t\t\tmap_psram_mirror_sub(0xD0);\n\t\t\t}\n\t\t}\n\t\telse if (!BSX.prevMMC[0x05] && BSX.prevMMC[0x06])\n\t\t{\n\t\t\t//Map PSRAM to 20-27/60-67 / A0-A7/E0-E7\n\t\t\tif (BSX.prevMMC[0x03])\n\t\t\t{\n\t\t\t\tmap_psram_mirror_sub(0x20);\n\t\t\t\tmap_psram_mirror_sub(0x60);\n\t\t\t}\n\n\t\t\tif (BSX.prevMMC[0x04])\n\t\t\t{\n\t\t\t\tmap_psram_mirror_sub(0xA0);\n\t\t\t\tmap_psram_mirror_sub(0xE0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Map PSRAM to 30-37/70-77 / B0-B7/F0-F7\n\t\t\tif (BSX.prevMMC[0x03])\n\t\t\t{\n\t\t\t\tmap_psram_mirror_sub(0x30);\n\t\t\t\tmap_psram_mirror_sub(0x70);\n\t\t\t}\n\n\t\t\tif (BSX.prevMMC[0x04])\n\t\t\t{\n\t\t\t\tmap_psram_mirror_sub(0xB0);\n\t\t\t\tmap_psram_mirror_sub(0xF0);\n\t\t\t}\n\t\t}\n\n\t\tif (BSX.prevMMC[0x03])\n\t\t{\n\t\t\t//Map PSRAM to 20->3F:6000-7FFF\n\t\t\tfor (c = 0x200; c < 0x400; c += 16)\n\t\t\t{\n\t\t\t\tMap[c + 6] = &PSRAM[((c & 0x70) << 12) % PSRAM_SIZE];\n\t\t\t\tMap[c + 7] = &PSRAM[((c & 0x70) << 12) % PSRAM_SIZE];\n\t\t\t\tBlockIsRAM[c + 6] = TRUE;\n\t\t\t\tBlockIsRAM[c + 7] = TRUE;\n\t\t\t\tBlockIsROM[c + 6] = FALSE;\n\t\t\t\tBlockIsROM[c + 7] = FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (BSX.prevMMC[0x04])\n\t\t{\n\t\t\t//Map PSRAM to A0->BF:6000-7FFF\n\t\t\tfor (c = 0xA00; c < 0xC00; c += 16)\n\t\t\t{\n\t\t\t\tMap[c + 6] = &PSRAM[((c & 0x70) << 12) % PSRAM_SIZE];\n\t\t\t\tMap[c + 7] = &PSRAM[((c & 0x70) << 12) % PSRAM_SIZE];\n\t\t\t\tBlockIsRAM[c + 6] = TRUE;\n\t\t\t\tBlockIsRAM[c + 7] = TRUE;\n\t\t\t\tBlockIsROM[c + 6] = FALSE;\n\t\t\t\tBlockIsROM[c + 7] = FALSE;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void BSX_Map_BIOS (void)\n{\n\tint\ti,c;\n\n\t// Banks 00->1F:8000-FFFF\n\tif (BSX.prevMMC[0x07])\n\t{\n\t\tfor (c = 0; c < 0x200; c += 16)\n\t\t{\n\t\t\tfor (i = c + 8; i < c + 16; i++)\n\t\t\t{\n\t\t\t\tMap[i] = &BIOSROM[(c << 11) % BIOS_SIZE] - 0x8000;\n\t\t\t\tBlockIsRAM[i] = FALSE;\n\t\t\t\tBlockIsROM[i] = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Banks 80->9F:8000-FFFF\n\tif (BSX.prevMMC[0x08])\n\t{\n\t\tfor (c = 0; c < 0x200; c += 16)\n\t\t{\n\t\t\tfor (i = c + 8; i < c + 16; i++)\n\t\t\t{\n\t\t\t\tMap[i + 0x800] = &BIOSROM[(c << 11) % BIOS_SIZE] - 0x8000;\n\t\t\t\tBlockIsRAM[i + 0x800] = FALSE;\n\t\t\t\tBlockIsROM[i + 0x800] = TRUE;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void BSX_Map_RAM (void)\n{\n\tint\tc;\n\n\t// Banks 7E->7F\n\tfor (c = 0; c < 16; c++)\n\t{\n\t\tMap[c + 0x7E0] = RAM;\n\t\tMap[c + 0x7F0] = RAM + 0x10000;\n\t\tBlockIsRAM[c + 0x7E0] = TRUE;\n\t\tBlockIsRAM[c + 0x7F0] = TRUE;\n\t\tBlockIsROM[c + 0x7E0] = FALSE;\n\t\tBlockIsROM[c + 0x7F0] = FALSE;\n\t}\n}\n\nstatic void BSX_Map (void)\n{\n#ifdef BSX_DEBUG\n\tprintf(\"BS: Remapping\\n\");\n\tfor (int i = 0; i < 32; i++)\n\t\tprintf(\"BS: MMC %02X: %d\\n\", i, BSX.MMC[i]);\n#endif\n\n\tmemcpy(BSX.prevMMC, BSX.MMC, sizeof(BSX.MMC));\n\n\tMapROM = FlashROM;\n\tFlashSize = FLASH_SIZE;\n\t\n\tif (BSX.prevMMC[0x02])\n\t\tBSX_Map_HiROM();\n\telse\n\t\tBSX_Map_LoROM();\n\t\n\tBSX_Map_FlashIO();\n\tBSX_Map_PSRAM();\n\n\tBSX_Map_SNES();\n\tBSX_Map_SRAM();\n\tBSX_Map_RAM();\n\n\tBSX_Map_BIOS();\n\tBSX_Map_MMC();\n\n\t// Monitor new register changes\n\tBSX.dirty  = FALSE;\n\tBSX.dirty2 = FALSE;\n\n\tMemory.map_WriteProtectROM();\n}\n\nstatic uint8 BSX_Get_Bypass_FlashIO (uint32 offset)\n{\n\t//For games other than BS-X\n\tFlashROM = Memory.ROM + Multi.cartOffsetB;\n\n\tif (BSX.prevMMC[0x02])\n\t\treturn (FlashROM[offset & 0x0FFFFF]);\n\telse\n\t\treturn (FlashROM[(offset & 0x1F0000) >> 1 | (offset & 0x7FFF)]);\n}\n\nstatic void BSX_Set_Bypass_FlashIO (uint32 offset, uint8 byte)\n{\n\t//For games other than BS-X\n\tFlashROM = Memory.ROM + Multi.cartOffsetB;\n\n\tif (BSX.prevMMC[0x02])\n\t\tFlashROM[offset & 0x0FFFFF] = FlashROM[offset & 0x0FFFFF] & byte;\n\telse\n\t\tFlashROM[(offset & 0x1F0000) >> 1 | (offset & 0x7FFF)] = FlashROM[(offset & 0x1F0000) >> 1 | (offset & 0x7FFF)] & byte;\n}\n\nuint8 S9xGetBSX (uint32 address)\n{\n\tuint8\tbank = (address >> 16) & 0xFF;\n\tuint16\toffset = address & 0xFFFF;\n\tuint8\tt = 0;\n\n\t// MMC\n\tif ((bank >= 0x01 && bank <= 0x0E) && ((address & 0xF000) == 0x5000))\n\t\treturn (BSX.MMC[bank]);\n\n\t// Flash Mapping\n\n\t// default: read-through mode\n\tt = BSX_Get_Bypass_FlashIO(address);\n\n\t// note: may be more registers, purposes unknown\n\tswitch (offset)\n\t{\n\t\tcase 0x0002:\n\t\tcase 0x8002:\n\t\t\tif (BSX.flash_bsr)\n\t\t\t\tt = 0xC0; // Page Status Register\n\t\t\tbreak;\n\n\t\tcase 0x0004:\n\t\tcase 0x8004:\n\t\t\tif (BSX.flash_gsr)\n\t\t\t\tt = 0x82; // Global Status Register\n\t\t\tbreak;\n\n\t\tcase 0x5555:\n\t\t\tif (BSX.flash_enable)\n\t\t\t\tt = 0x80; // ???\n\t\t\tbreak;\n\n\t\tcase 0xFF00:\n\t\tcase 0xFF02:\n\t\tcase 0xFF04:\n\t\tcase 0xFF06:\n\t\tcase 0xFF08:\n\t\tcase 0xFF0A:\n\t\tcase 0xFF0C:\n\t\tcase 0xFF0E:\n\t\tcase 0xFF10:\n\t\tcase 0xFF12:\n\t\t\t// return flash vendor information\n\t\t\tif (BSX.read_enable)\n\t\t\t\tt = flashcard[offset - 0xFF00];\n\t\t\tbreak;\n\t}\n\n\tif (BSX.flash_csr)\n\t{\n\t\tt = 0x80; // Compatible Status Register\n\t\tBSX.flash_csr = false;\n\t}\n\n\treturn (t);\n}\n\nvoid S9xSetBSX (uint8 byte, uint32 address)\n{\n\tuint8\tbank = (address >> 16) & 0xFF;\n\n\t// MMC\n\tif ((bank >= 0x01 && bank <= 0x0E) && ((address & 0xF000) == 0x5000))\n\t{\n\t\t//Avoid updating the memory map when it is not needed\n\t\tif (bank == 0x0E && BSX.dirty)\n\t\t{\n\t\t\tBSX_Map();\n\t\t\tBSX.dirty = FALSE;\n\t\t}\n\t\telse if (bank != 0x0E && BSX.MMC[bank] != byte)\n\t\t{\n\t\t\tBSX.dirty = TRUE;\n\t\t}\n\n\t\tBSX.MMC[bank] = byte;\n\t}\n\n\t// Flash IO\n\t\n\t// Write to Flash\n\tif (BSX.write_enable)\n\t{\n\t\tBSX_Set_Bypass_FlashIO(address, byte);\n\t\tBSX.write_enable = false;\n\t\treturn;\n\t}\n\n\t// Flash Command Handling\n\t\n\t//Memory Pack Type 1 & 3 & 4\n\tBSX.flash_command <<= 8;\n\tBSX.flash_command |= byte;\n\n\tswitch (BSX.flash_command & 0xFF)\n\t{\n\t\tcase 0x00:\n\t\tcase 0xFF:\n\t\t\t//Reset to normal\n\t\t\tBSX.flash_enable = false;\n\t\t\tBSX.flash_bsr = false;\n\t\t\tBSX.flash_csr = false;\n\t\t\tBSX.flash_gsr = false;\n\t\t\tBSX.read_enable = false;\n\t\t\tBSX.write_enable = false;\n\t\t\tBSX.flash_cmd_done = true;\n\t\t\tbreak;\n\n\t\tcase 0x10:\n\t\tcase 0x40:\n\t\t\t//Write Byte\n\t\t\tBSX.flash_enable = false;\n\t\t\tBSX.flash_bsr = false;\n\t\t\tBSX.flash_csr = true;\n\t\t\tBSX.flash_gsr = false;\n\t\t\tBSX.read_enable = false;\n\t\t\tBSX.write_enable = true;\n\t\t\tBSX.flash_cmd_done = true;\n\t\t\tbreak;\n\n\t\tcase 0x50:\n\t\t\t//Clear Status Register\n\t\t\tBSX.flash_enable = false;\n\t\t\tBSX.flash_bsr = false;\n\t\t\tBSX.flash_csr = false;\n\t\t\tBSX.flash_gsr = false;\n\t\t\tBSX.flash_cmd_done = true;\n\t\t\tbreak;\n\n\t\tcase 0x70:\n\t\t\t//Read CSR\n\t\t\tBSX.flash_enable = false;\n\t\t\tBSX.flash_bsr = false;\n\t\t\tBSX.flash_csr = true;\n\t\t\tBSX.flash_gsr = false;\n\t\t\tBSX.read_enable = false;\n\t\t\tBSX.write_enable = false;\n\t\t\tBSX.flash_cmd_done = true;\n\t\t\tbreak;\n\n\t\tcase 0x71:\n\t\t\t//Read Extended Status Registers (Page and Global)\n\t\t\tBSX.flash_enable = false;\n\t\t\tBSX.flash_bsr = true;\n\t\t\tBSX.flash_csr = false;\n\t\t\tBSX.flash_gsr = true;\n\t\t\tBSX.read_enable = false;\n\t\t\tBSX.write_enable = false;\n\t\t\tBSX.flash_cmd_done = true;\n\t\t\tbreak;\n\n\t\tcase 0x75:\n\t\t\t//Show Page Buffer / Vendor Info\n\t\t\tBSX.flash_csr = false;\n\t\t\tBSX.read_enable = true;\n\t\t\tBSX.flash_cmd_done = true;\n\t\t\tbreak;\n\n\t\tcase 0xD0:\n\t\t\t//DO COMMAND\n\t\t\tswitch (BSX.flash_command & 0xFFFF)\n\t\t\t{\n\t\t\t\tcase 0x20D0: //Block Erase\n\t\t\t\t\tuint32 x;\n\t\t\t\t\tfor (x = 0; x < 0x10000; x++) {\n\t\t\t\t\t\t//BSX_Set_Bypass_FlashIO(((address & 0xFF0000) + x), 0xFF);\n\t\t\t\t\t\tif (BSX.MMC[0x02])\n\t\t\t\t\t\t\tFlashROM[(address & 0x0F0000) + x] = 0xFF;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tFlashROM[((address & 0x1E0000) >> 1) + x] = 0xFF;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xA7D0: //Chip Erase (ONLY IN TYPE 1 AND 4)\n\t\t\t\t\tif ((flashcard[6] & 0xF0) == 0x10 || (flashcard[6] & 0xF0) == 0x40)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32 x;\n\t\t\t\t\t\tfor (x = 0; x < FLASH_SIZE; x++) {\n\t\t\t\t\t\t\t//BSX_Set_Bypass_FlashIO(x, 0xFF);\n\t\t\t\t\t\t\tFlashROM[x] = 0xFF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x38D0: //Flashcart Reset\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n\nvoid S9xBSXSetStream1 (uint8 count)\n{\n\tif (BSX.sat_stream1.is_open())\n\t\tBSX.sat_stream1.close(); //If Stream already opened for one file: Close it.\n\n\tstd::string path = S9xGetDirectory(SAT_DIR) + SLASH_STR;\n\n\tchar name[PATH_MAX];\n\tsnprintf(name, PATH_MAX, \"BSX%04X-%d.bin\", (BSX.PPU[0x2188 - BSXPPUBASE] | (BSX.PPU[0x2189 - BSXPPUBASE] * 256)), count); //BSXHHHH-DDD.bin\n\tpath += name;\n\n\tBSX.sat_stream1.clear();\n\tBSX.sat_stream1.open(path.c_str(), std::ios::in | std::ios::binary);\n\tif (BSX.sat_stream1.good())\n\t{\n\t\tBSX.sat_stream1.seekg(0, BSX.sat_stream1.end);\n\t\tlong str1size = BSX.sat_stream1.tellg();\n\t\tBSX.sat_stream1.seekg(0, BSX.sat_stream1.beg);\n\t\tfloat QueueSize = str1size / 22.;\n\t\tBSX.sat_stream1_queue = (uint16)(ceil(QueueSize));\n\t\tBSX.PPU[0x218D - BSXPPUBASE] = 0;\n\t\tBSX.sat_stream1_first = TRUE;\n\t\tBSX.sat_stream1_loaded = TRUE;\n\t}\n\telse\n\t{\n\t\tBSX.sat_stream1_loaded = FALSE;\n\t}\n}\n\nvoid S9xBSXSetStream2 (uint8 count)\n{\n\tif (BSX.sat_stream2.is_open())\n\t\tBSX.sat_stream2.close(); //If Stream already opened for one file: Close it.\n\n\n\tstd::string path = S9xGetDirectory(SAT_DIR) + SLASH_STR;\n\n\tchar name[PATH_MAX];\n\tsnprintf(name, PATH_MAX, \"BSX%04X-%d.bin\", (BSX.PPU[0x218E - BSXPPUBASE] | (BSX.PPU[0x218F - BSXPPUBASE] * 256)), count); //BSXHHHH-DDD.bin\n\tpath += name;\n\n\tBSX.sat_stream2.clear();\n\tBSX.sat_stream2.open(path.c_str(), std::ios::in | std::ios::binary);\n\tif (BSX.sat_stream2.good())\n\t{\n\t\tBSX.sat_stream2.seekg(0, BSX.sat_stream2.end);\n\t\tlong str2size = BSX.sat_stream2.tellg();\n\t\tBSX.sat_stream2.seekg(0, BSX.sat_stream2.beg);\n\t\tfloat QueueSize = str2size / 22.;\n\t\tBSX.sat_stream2_queue = (uint16)(ceil(QueueSize));\n\t\tBSX.PPU[0x2193 - BSXPPUBASE] = 0;\n\t\tBSX.sat_stream2_first = TRUE;\n\t\tBSX.sat_stream2_loaded = TRUE;\n\t}\n\telse\n\t{\n\t\tBSX.sat_stream2_loaded = FALSE;\n\t}\n}\n\nuint8 S9xBSXGetRTC (void)\n{\n\t//Get Time\n\ttime_t\t\tt;\n\tstruct tm\t*tmr;\n\n\ttime(&t);\n\ttmr = localtime(&t);\n\n\tBSX.test2192[0] = 0x00;\n\tBSX.test2192[1] = 0x00;\n\tBSX.test2192[2] = 0x00;\n\tBSX.test2192[3] = 0x00;\n\tBSX.test2192[4] = 0x10;\n\tBSX.test2192[5] = 0x01;\n\tBSX.test2192[6] = 0x01;\n\tBSX.test2192[7] = 0x00;\n\tBSX.test2192[8] = 0x00;\n\tBSX.test2192[9] = 0x00;\n\tBSX.test2192[10] = BSX_RTC.seconds = tmr->tm_sec;\n\tBSX.test2192[11] = BSX_RTC.minutes = tmr->tm_min;\n\tBSX.test2192[12] = BSX_RTC.hours = tmr->tm_hour;\n\tBSX.test2192[13] = BSX_RTC.dayweek = (tmr->tm_wday) + 1;\n\tBSX.test2192[14] = BSX_RTC.day = tmr->tm_mday;\n\tBSX.test2192[15] = BSX_RTC.month = (tmr->tm_mon) + 1;\n\tBSX_RTC.year = tmr->tm_year + 1900;\n\tBSX.test2192[16] = (BSX_RTC.year) & 0xFF;\n\tBSX.test2192[17] = (BSX_RTC.year) >> 8;\n\n\tt = BSX.test2192[BSX.out_index++];\n\n\tif (BSX.out_index > 22)\n\t\tBSX.out_index = 0;\n\n\treturn t;\n}\n\nuint8 S9xGetBSXPPU (uint16 address)\n{\n\tuint8\tt;\n\n\t// known read registers\n\tswitch (address)\n\t{\n\t\t//Stream 1\n\t\t// Logical Channel 1 + Data Structure (R/W)\n\t\tcase 0x2188:\n\t\t\tt = BSX.PPU[0x2188 - BSXPPUBASE];\n\t\t\tbreak;\n\n\t\t// Logical Channel 2 (R/W) [6bit]\n\t\tcase 0x2189:\n\t\t\tt = BSX.PPU[0x2189 - BSXPPUBASE];\n\t\t\tbreak;\n\n\t\t// Prefix Count (R)\n\t\tcase 0x218A:\n\t\t\tif (!BSX.sat_pf_latch1_enable || !BSX.sat_dt_latch1_enable)\n\t\t\t{\n\t\t\t\tt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (BSX.PPU[0x2188 - BSXPPUBASE] == 0 && BSX.PPU[0x2189 - BSXPPUBASE] == 0)\n\t\t\t{\n\t\t\t\tt = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (BSX.sat_stream1_queue <= 0)\n\t\t\t{\n\t\t\t\tBSX.sat_stream1_count++;\n\t\t\t\tS9xBSXSetStream1(BSX.sat_stream1_count - 1);\n\t\t\t}\n\n\t\t\tif (!BSX.sat_stream1_loaded && (BSX.sat_stream1_count - 1) > 0)\n\t\t\t{\n\t\t\t\tBSX.sat_stream1_count = 1;\n\t\t\t\tS9xBSXSetStream1(BSX.sat_stream1_count - 1);\n\t\t\t}\n\n\t\t\tif (BSX.sat_stream1_loaded)\n\t\t\t{\n\t\t\t\t//Lock at 0x7F for bigger packets\n\t\t\t\tif (BSX.sat_stream1_queue >= 128)\n\t\t\t\t\tBSX.PPU[0x218A - BSXPPUBASE] = 0x7F;\n\t\t\t\telse\n\t\t\t\t\tBSX.PPU[0x218A - BSXPPUBASE] = BSX.sat_stream1_queue;\n\t\t\t\tt = BSX.PPU[0x218A - BSXPPUBASE];\n\t\t\t}\n\t\t\telse\n\t\t\t\tt = 0;\n\t\t\tbreak;\n\n\t\t// Prefix Latch (R/W)\n\t\tcase 0x218B:\n\t\t\tif (BSX.sat_pf_latch1_enable)\n\t\t\t{\n\t\t\t\tif (BSX.PPU[0x2188 - BSXPPUBASE] == 0 && BSX.PPU[0x2189 - BSXPPUBASE] == 0)\n\t\t\t\t{\n\t\t\t\t\tBSX.PPU[0x218B - BSXPPUBASE] = 0x90;\n\t\t\t\t}\n\n\t\t\t\tif (BSX.sat_stream1_loaded)\n\t\t\t\t{\n\t\t\t\t\tuint8 temp = 0;\n\t\t\t\t\tif (BSX.sat_stream1_first)\n\t\t\t\t\t{\n\t\t\t\t\t\t// First packet\n\t\t\t\t\t\ttemp |= 0x10;\n\t\t\t\t\t\tBSX.sat_stream1_first = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tBSX.sat_stream1_queue--;\n\n\t\t\t\t\tif (BSX.sat_stream1_queue == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Last packet\n\t\t\t\t\t\ttemp |= 0x80;\n\t\t\t\t\t}\n\n\t\t\t\t\tBSX.PPU[0x218B - BSXPPUBASE] = temp;\n\t\t\t\t}\n\n\t\t\t\tBSX.PPU[0x218D - BSXPPUBASE] |= BSX.PPU[0x218B - BSXPPUBASE];\n\t\t\t\tt = BSX.PPU[0x218B - BSXPPUBASE];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Data Latch (R/W)\n\t\tcase 0x218C:\n\t\t\tif (BSX.sat_dt_latch1_enable)\n\t\t\t{\n\t\t\t\tif (BSX.PPU[0x2188 - BSXPPUBASE] == 0 && BSX.PPU[0x2189 - BSXPPUBASE] == 0)\n\t\t\t\t{\n\t\t\t\t\tBSX.PPU[0x218C - BSXPPUBASE] = S9xBSXGetRTC();\n\t\t\t\t}\n\t\t\t\telse if (BSX.sat_stream1_loaded)\n\t\t\t\t{\n\t\t\t\t\tif (BSX.sat_stream1.eof())\n\t\t\t\t\t\tBSX.PPU[0x218C - BSXPPUBASE] = 0xFF;\n\t\t\t\t\telse\n\t\t\t\t\t\tBSX.PPU[0x218C - BSXPPUBASE] = BSX.sat_stream1.get();\n\t\t\t\t}\n\t\t\t\tt = BSX.PPU[0x218C - BSXPPUBASE];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// OR gate (R)\n\t\tcase 0x218D:\n\t\t\tt = BSX.PPU[0x218D - BSXPPUBASE];\n\t\t\tBSX.PPU[0x218D - BSXPPUBASE] = 0;\n\t\t\tbreak;\n\n\t\t//Stream 2\n\t\t// Logical Channel 1 + Data Structure (R/W)\n\t\tcase 0x218E:\n\t\t\tt = BSX.PPU[0x218E - BSXPPUBASE];\n\t\t\tbreak;\n\n\t\t// Logical Channel 2 (R/W) [6bit]\n\t\tcase 0x218F:\n\t\t\tt = BSX.PPU[0x218F - BSXPPUBASE];\n\t\t\tbreak;\n\n\t\t// Prefix Count (R)\n\t\tcase 0x2190:\n\t\t\tif (!BSX.sat_pf_latch2_enable || !BSX.sat_dt_latch2_enable)\n\t\t\t{\n\t\t\t\tt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (BSX.PPU[0x218E - BSXPPUBASE] == 0 && BSX.PPU[0x218F - BSXPPUBASE] == 0)\n\t\t\t{\n\t\t\t\tt = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (BSX.sat_stream2_queue <= 0)\n\t\t\t{\n\t\t\t\tBSX.sat_stream2_count++;\n\t\t\t\tS9xBSXSetStream2(BSX.sat_stream2_count - 1);\n\t\t\t}\n\n\t\t\tif (!BSX.sat_stream2_loaded && (BSX.sat_stream2_count - 1) > 0)\n\t\t\t{\n\t\t\t\tBSX.sat_stream2_count = 1;\n\t\t\t\tS9xBSXSetStream2(BSX.sat_stream2_count - 1);\n\t\t\t}\n\n\t\t\tif (BSX.sat_stream2_loaded)\n\t\t\t{\n\t\t\t\tif (BSX.sat_stream2_queue >= 128)\n\t\t\t\t\tBSX.PPU[0x2190 - BSXPPUBASE] = 0x7F;\n\t\t\t\telse\n\t\t\t\t\tBSX.PPU[0x2190 - BSXPPUBASE] = BSX.sat_stream2_queue;\n\t\t\t\tt = BSX.PPU[0x2190 - BSXPPUBASE];\n\t\t\t}\n\t\t\telse\n\t\t\t\tt = 0;\n\t\t\tbreak;\n\n\t\t// Prefix Latch (R/W)\n\t\tcase 0x2191:\n\t\t\tif (BSX.sat_pf_latch2_enable)\n\t\t\t{\n\t\t\t\tif (BSX.PPU[0x218E - BSXPPUBASE] == 0 && BSX.PPU[0x218F - BSXPPUBASE] == 0)\n\t\t\t\t{\n\t\t\t\t\tBSX.PPU[0x2191 - BSXPPUBASE] = 0x90;\n\t\t\t\t}\n\n\t\t\t\tif (BSX.sat_stream2_loaded)\n\t\t\t\t{\n\t\t\t\t\tuint8 temp = 0;\n\t\t\t\t\tif (BSX.sat_stream2_first)\n\t\t\t\t\t{\n\t\t\t\t\t\t// First packet\n\t\t\t\t\t\ttemp |= 0x10;\n\t\t\t\t\t\tBSX.sat_stream2_first = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tBSX.sat_stream2_queue--;\n\n\t\t\t\t\tif (BSX.sat_stream2_queue == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Last packet\n\t\t\t\t\t\ttemp |= 0x80;\n\t\t\t\t\t}\n\n\t\t\t\t\tBSX.PPU[0x2191 - BSXPPUBASE] = temp;\n\t\t\t\t}\n\n\t\t\t\tBSX.PPU[0x2193 - BSXPPUBASE] |= BSX.PPU[0x2191 - BSXPPUBASE];\n\t\t\t\tt = BSX.PPU[0x2191 - BSXPPUBASE];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Data Latch (R/W)\n\t\tcase 0x2192:\n\t\t\tif (BSX.sat_dt_latch2_enable)\n\t\t\t{\n\t\t\t\tif (BSX.PPU[0x218E - BSXPPUBASE] == 0 && BSX.PPU[0x218F - BSXPPUBASE] == 0)\n\t\t\t\t{\n\t\t\t\t\tBSX.PPU[0x2192 - BSXPPUBASE] = S9xBSXGetRTC();\n\t\t\t\t}\n\t\t\t\telse if (BSX.sat_stream2_loaded)\n\t\t\t\t{\n\t\t\t\t\tif (BSX.sat_stream2.eof())\n\t\t\t\t\t\tBSX.PPU[0x2192 - BSXPPUBASE] = 0xFF;\n\t\t\t\t\telse\n\t\t\t\t\t\tBSX.PPU[0x2192 - BSXPPUBASE] = BSX.sat_stream2.get();\n\t\t\t\t}\n\t\t\t\tt = BSX.PPU[0x2192 - BSXPPUBASE];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// OR gate (R)\n\t\tcase 0x2193:\n\t\t\tt = BSX.PPU[0x2193 - BSXPPUBASE];\n\t\t\tBSX.PPU[0x2193 - BSXPPUBASE] = 0;\n\t\t\tbreak;\n\n\t\t//Other\n\t\t// Satellaview LED / Stream Enable (R/W) [4bit]\n\t\tcase 0x2194:\n\t\t\tt = BSX.PPU[0x2194 - BSXPPUBASE];\n\t\t\tbreak;\n\n\t\t// Unknown\n\t\tcase 0x2195:\n\t\t\tt = BSX.PPU[0x2195 - BSXPPUBASE];\n\t\t\tbreak;\n\n\t\t// Satellaview Status (R)\n\t\tcase 0x2196:\n\t\t\tt = BSX.PPU[0x2196 - BSXPPUBASE];\n\t\t\tbreak;\n\n\t\t// Soundlink Settings (R/W)\n\t\tcase 0x2197:\n\t\t\tt = BSX.PPU[0x2197 - BSXPPUBASE];\n\t\t\tbreak;\n\n\t\t// Serial I/O - Serial Number (R/W)\n\t\tcase 0x2198:\n\t\t\tt = BSX.PPU[0x2198 - BSXPPUBASE];\n\t\t\tbreak;\n\n\t\t// Serial I/O - Unknown (R/W)\n\t\tcase 0x2199:\n\t\t\tt = BSX.PPU[0x2199 - BSXPPUBASE];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tt = OpenBus;\n\t\t\tbreak;\n\t}\n\n\treturn (t);\n}\n\nvoid S9xSetBSXPPU (uint8 byte, uint16 address)\n{\n\t// known write registers\n\tswitch (address)\n\t{\n\t\t//Stream 1\n\t\t// Logical Channel 1 + Data Structure (R/W)\n\t\tcase 0x2188:\n\t\t\tif (BSX.PPU[0x2188 - BSXPPUBASE] == byte)\n\t\t\t{\n\t\t\t\tBSX.sat_stream1_count = 0;\n\t\t\t}\n\t\t\tBSX.PPU[0x2188 - BSXPPUBASE] = byte;\n\t\t\tbreak;\n\n\t\t// Logical Channel 2 (R/W) [6bit]\n\t\tcase 0x2189:\n\t\t\tif (BSX.PPU[0x2188 - BSXPPUBASE] == (byte & 0x3F))\n\t\t\t{\n\t\t\t\tBSX.sat_stream1_count = 0;\n\t\t\t}\n\t\t\tBSX.PPU[0x2189 - BSXPPUBASE] = byte & 0x3F;\n\t\t\tbreak;\n\n\t\t// Prefix Latch (R/W)\n\t\tcase 0x218B:\n\t\t\tBSX.sat_pf_latch1_enable = (byte != 0);\n\t\t\tbreak;\n\n\t\t// Data Latch (R/W)\n\t\tcase 0x218C:\n\t\t\tif (BSX.PPU[0x2188 - BSXPPUBASE] == 0 && BSX.PPU[0x2189 - BSXPPUBASE] == 0)\n\t\t\t{\n\t\t\t\tBSX.out_index = 0;\n\t\t\t}\n\t\t\tBSX.sat_dt_latch1_enable = (byte != 0);\n\t\t\tbreak;\n\n\t\t//Stream 2\n\t\t// Logical Channel 1 + Data Structure (R/W)\n\t\tcase 0x218E:\n\t\t\tif (BSX.PPU[0x218E - BSXPPUBASE] == byte)\n\t\t\t{\n\t\t\t\tBSX.sat_stream2_count = 0;\n\t\t\t}\n\t\t\tBSX.PPU[0x218E - BSXPPUBASE] = byte;\n\t\t\tbreak;\n\n\t\t// Logical Channel 2 (R/W) [6bit]\n\t\tcase 0x218F:\n\t\t\tif (BSX.PPU[0x218F - BSXPPUBASE] == (byte & 0x3F))\n\t\t\t{\n\t\t\t\tBSX.sat_stream2_count = 0;\n\t\t\t}\n\t\t\tBSX.PPU[0x218F - BSXPPUBASE] = byte & 0x3F;\n\t\t\tbreak;\n\n\t\t// Prefix Latch (R/W)\n\t\tcase 0x2191:\n\t\t\tBSX.sat_pf_latch2_enable = (byte != 0);\n\t\t\tbreak;\n\n\t\t// Data Latch (R/W)\n\t\tcase 0x2192:\n\t\t\tif (BSX.PPU[0x218E - BSXPPUBASE] == 0 && BSX.PPU[0x218F - BSXPPUBASE] == 0)\n\t\t\t{\n\t\t\t\tBSX.out_index = 0;\n\t\t\t}\n\t\t\tBSX.sat_dt_latch2_enable = (byte != 0);\n\t\t\tbreak;\n\n\t\t//Other\n\t\t// Satellaview LED / Stream Enable (R/W) [4bit]\n\t\tcase 0x2194:\n\t\t\tBSX.PPU[0x2194 - BSXPPUBASE] = byte & 0x0F;\n\t\t\tbreak;\n\n\t\t// Soundlink Settings (R/W)\n\t\tcase 0x2197:\n\t\t\tBSX.PPU[0x2197 - BSXPPUBASE] = byte;\n\t\t\tbreak;\n\t}\n}\n\nuint8 * S9xGetBasePointerBSX (uint32 address)\n{\n\treturn (MapROM);\n}\n\nstatic bool8 BSX_LoadBIOS (void)\n{\n\tFILE\t*fp;\n\tbool8\tr = FALSE;\n\n\tstd::string name = S9xGetDirectory(BIOS_DIR) + SLASH_STR + \"BS-X.bin\";\n\n\tfp = fopen(name.c_str(), \"rb\");\n\tif (!fp)\n\t{\n\t\tname = S9xGetDirectory(BIOS_DIR) + SLASH_STR + \"BS-X.bios\";\n\t\tfp = fopen(name.c_str(), \"rb\");\n\t}\n\n\tif (fp)\n\t{\n\t\tsize_t\tsize;\n\n\t\tsize = fread((void *) BIOSROM, 1, BIOS_SIZE, fp);\n\t\tfclose(fp);\n\t\tif (size == BIOS_SIZE)\n\t\t\tr = TRUE;\n\t}\n\n#ifdef BSX_DEBUG\n\tif (r)\n\t\tprintf(\"BS: BIOS found.\\n\");\n\telse\n\t\tprintf(\"BS: BIOS not found!\\n\");\n#endif\n\n\treturn (r);\n}\n\nstatic bool8 is_BSX_BIOS (const uint8 *data, uint32 size)\n{\n\tif (size == BIOS_SIZE && strncmp((char *) (data + 0x7FC0), \"Satellaview BS-X     \", 21) == 0)\n\t\treturn (TRUE);\n\telse\n\t\treturn (FALSE);\n}\n\nvoid S9xInitBSX (void)\n{\n\tSettings.BS = FALSE;\n\n\tif (is_BSX_BIOS(Memory.ROM,Memory.CalculatedSize))\n\t{\n\t\t// BS-X itself\n\n\t\tSettings.BS = TRUE;\n\t\tSettings.BSXItself = TRUE;\n\n\t\tMemory.LoROM = TRUE;\n\t\tMemory.HiROM = FALSE;\n\n\t\tmemmove(BIOSROM, Memory.ROM, BIOS_SIZE);\n\n\t\tFlashMode = FALSE;\n\t\tFlashSize = FLASH_SIZE;\n\n\t\tBSX.bootup = TRUE;\n\t}\n\telse\n\t{\n\t\tSettings.BSXItself = FALSE;\n\n\t\tint\tr1, r2;\n\n\t\tr1 = (is_bsx(Memory.ROM + 0x7FC0) == 1);\n\t\tr2 = (is_bsx(Memory.ROM + 0xFFC0) == 1);\n\t\tSettings.BS = (r1 | r2) ? TRUE : FALSE;\n\n\t\tif (Settings.BS)\n\t\t{\n\t\t\t// BS games\n\n\t\t\tMemory.LoROM = r1 ? TRUE : FALSE;\n\t\t\tMemory.HiROM = r2 ? TRUE : FALSE;\n\n\t\t\tuint8\t*header = r1 ? Memory.ROM + 0x7FC0 : Memory.ROM + 0xFFC0;\n\n\t\t\tFlashMode = (header[0x18] & 0xEF) == 0x20 ? FALSE : TRUE;\n\t\t\tFlashSize = FLASH_SIZE;\n\n\t\t\t// Fix Block Allocation Flags\n\t\t\t// (for games that don't have it setup properly,\n\t\t\t// for exemple when taken seperately from the upper memory of the Memory Pack,\n\t\t\t// else the game will error out on BS-X)\n\t\t\tfor (; (((header[0x10] & 1) == 0) && header[0x10] != 0); (header[0x10] >>= 1));\n\n#ifdef BSX_DEBUG\n\t\t\tfor (int i = 0; i <= 0x1F; i++)\n\t\t\t\tprintf(\"BS: ROM Header %02X: %02X\\n\", i, header[i]);\n\t\t\tprintf(\"BS: FlashMode: %d, FlashSize: %x\\n\", FlashMode, FlashSize);\n#endif\n\n\t\t\tBSX.bootup = Settings.BSXBootup;\n\n\t\t\tif (!BSX_LoadBIOS() && !is_BSX_BIOS(BIOSROM,BIOS_SIZE))\n\t\t\t{\n\t\t\t\tBSX.bootup = FALSE;\n\t\t\t\tmemset(BIOSROM, 0, BIOS_SIZE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (Settings.BS)\n\t{\n\t\tMapROM = NULL;\n\t\tFlashROM = Memory.ROM;\n\t\t/*\n\t\ttime_t\t\tt;\n\t\tstruct tm\t*tmr;\n\n\t\ttime(&t);\n\t\ttmr = localtime(&t);\n\n\t\tBSX_RTC.ticks = 0;\n\t\tmemcpy(BSX.test2192, init2192, sizeof(init2192));\n\t\tBSX.test2192[10] = BSX_RTC.seconds = tmr->tm_sec;\n\t\tBSX.test2192[11] = BSX_RTC.minutes = tmr->tm_min;\n\t\tBSX.test2192[12] = BSX_RTC.hours   = tmr->tm_hour;\n#ifdef BSX_DEBUG\n\t\tprintf(\"BS: Current Time: %02d:%02d:%02d\\n\",  BSX_RTC.hours, BSX_RTC.minutes, BSX_RTC.seconds);\n#endif\n\t\t*/\n\t\tSNESGameFixes.SRAMInitialValue = 0x00;\n\t}\n}\n\nvoid S9xResetBSX (void)\n{\n\tif (Settings.BSXItself)\n\t\tmemset(Memory.ROM, 0, FLASH_SIZE);\n\n\tmemset(BSX.PPU, 0, sizeof(BSX.PPU));\n\tmemset(BSX.MMC, 0, sizeof(BSX.MMC));\n\tmemset(BSX.prevMMC, 0, sizeof(BSX.prevMMC));\n\n\tBSX.dirty         = FALSE;\n\tBSX.dirty2        = FALSE;\n\tBSX.flash_enable  = FALSE;\n\tBSX.write_enable  = FALSE;\n\tBSX.read_enable   = FALSE;\n\tBSX.flash_command = 0;\n\tBSX.old_write     = 0;\n\tBSX.new_write     = 0;\n\n\tBSX.out_index = 0;\n\tmemset(BSX.output, 0, sizeof(BSX.output));\n\n\t// starting from the bios\n\tBSX.MMC[0x02] = BSX.MMC[0x03] = BSX.MMC[0x05] = BSX.MMC[0x06] = 0x80;\n\tBSX.MMC[0x09] = BSX.MMC[0x0B] = 0x80;\n\n\tBSX.MMC[0x07] = BSX.MMC[0x08] = 0x80;\n\tBSX.MMC[0x0E] = 0x80;\n\n\t// default register values\n\tBSX.PPU[0x2196 - BSXPPUBASE] = 0x10;\n\tBSX.PPU[0x2197 - BSXPPUBASE] = 0x80;\n\n\t// stream reset\n\tBSX.sat_pf_latch1_enable = BSX.sat_dt_latch1_enable = FALSE;\n\tBSX.sat_pf_latch2_enable = BSX.sat_dt_latch2_enable = FALSE;\n\n\tBSX.sat_stream1_loaded = BSX.sat_stream2_loaded = FALSE;\n\tBSX.sat_stream1_first = BSX.sat_stream2_first = FALSE;\n\tBSX.sat_stream1_count = BSX.sat_stream2_count = 0;\n\n    if (BSX.sat_stream1.is_open())\n        BSX.sat_stream1.close();\n\n    if (BSX.sat_stream2.is_open())\n        BSX.sat_stream2.close();\n\n    if (Settings.BS)\n\t    BSX_Map();\n}\n\nvoid S9xBSXPostLoadState (void)\n{\n\tuint8\ttemp[16];\n\tbool8\tpd1, pd2;\n\n\tpd1 = BSX.dirty;\n\tpd2 = BSX.dirty2;\n\tmemcpy(temp, BSX.MMC, sizeof(BSX.MMC));\n\n\tmemcpy(BSX.MMC, BSX.prevMMC, sizeof(BSX.MMC));\n\tBSX_Map();\n\n\tmemcpy(BSX.MMC, temp, sizeof(BSX.MMC));\n\tBSX.dirty  = pd1;\n\tBSX.dirty2 = pd2;\n}\n\nstatic bool valid_normal_bank (unsigned char bankbyte)\n{\n\tswitch (bankbyte)\n\t{\n\t\tcase 32: case 33: case 48: case 49:\n\t\t\treturn (true);\n\t\t\tbreak;\n\t}\n\n\treturn (false);\n}\n\nstatic int is_bsx (unsigned char *p)\n{\n\tif ((p[26] == 0x33 || p[26] == 0xFF) && (!p[21] || (p[21] & 131) == 128) && valid_normal_bank(p[24]))\n\t{\n\t\tunsigned char\tm = p[22];\n\n\t\tif (!m && !p[23])\n\t\t\treturn (2);\n\n\t\tif ((m == 0xFF && p[23] == 0xFF) || (!(m & 0xF) && ((m >> 4) - 1 < 12)))\n\t\t\treturn (1);\n\t}\n\n\treturn (0);\n}\n"
        },
        {
          "name": "bsx.h",
          "type": "blob",
          "size": 1.609375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _BSX_H_\n#define _BSX_H_\n\n#include <fstream>\n\nstruct SBSX\n{\n\tbool8\tdirty;\t\t\t// Changed register values\n\tbool8\tdirty2;\t\t\t// Changed register values\n\tbool8\tbootup;\t\t\t// Start in bios mapping\n\tbool8\tflash_enable;\t// Flash state\n\tbool8\twrite_enable;\t// ROM write protection\n\tbool8\tread_enable;\t// Allow card vendor reading\n\tuint32\tflash_command;\t// Flash command\n\tuint32\told_write;\t\t// Previous flash write address\n\tuint32\tnew_write;\t\t// Current flash write address\n\tuint8\tout_index;\n\tuint8\toutput[32];\n\tuint8\tPPU[32];\n\tuint8\tMMC[16];\n\tuint8\tprevMMC[16];\n\tuint8\ttest2192[32];\n\n\tbool\tflash_csr;\n\tbool\tflash_gsr;\n\tbool\tflash_bsr;\n\tbool\tflash_cmd_done;\n\n\tstd::ifstream\tsat_stream1;\n\tstd::ifstream\tsat_stream2;\n\n\tbool\tsat_pf_latch1_enable, sat_dt_latch1_enable;\n\tbool\tsat_pf_latch2_enable, sat_dt_latch2_enable;\n\n\tbool\tsat_stream1_loaded, sat_stream2_loaded;\n\tbool\tsat_stream1_first, sat_stream2_first;\n\tuint8\tsat_stream1_count, sat_stream2_count;\n\tuint16\tsat_stream1_queue, sat_stream2_queue;\n};\n\nextern struct SBSX\tBSX;\n\nuint8 S9xGetBSX (uint32);\nvoid S9xSetBSX (uint8, uint32);\nuint8 S9xGetBSXPPU (uint16);\nvoid S9xSetBSXPPU (uint8, uint16);\nuint8 * S9xGetBasePointerBSX (uint32);\nvoid S9xInitBSX (void);\nvoid S9xResetBSX (void);\nvoid S9xBSXPostLoadState (void);\n\n#endif\n"
        },
        {
          "name": "c4.cpp",
          "type": "blob",
          "size": 3.681640625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include <math.h>\n#include \"snes9x.h\"\n#include \"memmap.h\"\n\n#define\tC4_PI\t3.14159265\n\nint16\tC4WFXVal;\nint16\tC4WFYVal;\nint16\tC4WFZVal;\nint16\tC4WFX2Val;\nint16\tC4WFY2Val;\nint16\tC4WFDist;\nint16\tC4WFScale;\nint16\tC41FXVal;\nint16\tC41FYVal;\nint16\tC41FAngleRes;\nint16\tC41FDist;\nint16\tC41FDistVal;\n\nstatic double\ttanval;\nstatic double\tc4x, c4y, c4z;\nstatic double\tc4x2, c4y2, c4z2;\n\n\nvoid C4TransfWireFrame (void)\n{\n\tc4x = (double) C4WFXVal;\n\tc4y = (double) C4WFYVal;\n\tc4z = (double) C4WFZVal - 0x95;\n\n\t// Rotate X\n\ttanval = -(double) C4WFX2Val * C4_PI * 2 / 128;\n\tc4y2 = c4y  *  cos(tanval) - c4z  * sin(tanval);\n\tc4z2 = c4y  *  sin(tanval) + c4z  * cos(tanval);\n\n\t// Rotate Y\n\ttanval = -(double) C4WFY2Val * C4_PI * 2 / 128;\n\tc4x2 = c4x  *  cos(tanval) + c4z2 * sin(tanval);\n\tc4z  = c4x  * -sin(tanval) + c4z2 * cos(tanval);\n\n\t// Rotate Z\n\ttanval = -(double) C4WFDist  * C4_PI * 2 / 128;\n\tc4x  = c4x2 *  cos(tanval) - c4y2 * sin(tanval);\n\tc4y  = c4x2 *  sin(tanval) + c4y2 * cos(tanval);\n\n\t// Scale\n\tC4WFXVal = (int16) (c4x * (double) C4WFScale / (0x90 * (c4z + 0x95)) * 0x95);\n\tC4WFYVal = (int16) (c4y * (double) C4WFScale / (0x90 * (c4z + 0x95)) * 0x95);\n}\n\nvoid C4TransfWireFrame2 (void)\n{\n\tc4x = (double) C4WFXVal;\n\tc4y = (double) C4WFYVal;\n\tc4z = (double) C4WFZVal;\n\n\t// Rotate X\n\ttanval = -(double) C4WFX2Val * C4_PI * 2 / 128;\n\tc4y2 = c4y  *  cos(tanval) - c4z  * sin(tanval);\n\tc4z2 = c4y  *  sin(tanval) + c4z  * cos(tanval);\n\n\t// Rotate Y\n\ttanval = -(double) C4WFY2Val * C4_PI * 2 / 128;\n\tc4x2 = c4x  *  cos(tanval) + c4z2 * sin(tanval);\n\tc4z  = c4x  * -sin(tanval) + c4z2 * cos(tanval);\n\n\t// Rotate Z\n\ttanval = -(double) C4WFDist  * C4_PI * 2 / 128;\n\tc4x  = c4x2 *  cos(tanval) - c4y2 * sin(tanval);\n\tc4y  = c4x2 *  sin(tanval) + c4y2 * cos(tanval);\n\n\t// Scale\n\tC4WFXVal = (int16) (c4x * (double) C4WFScale / 0x100);\n\tC4WFYVal = (int16) (c4y * (double) C4WFScale / 0x100);\n}\n\nvoid C4CalcWireFrame (void)\n{\n\tC4WFXVal = C4WFX2Val - C4WFXVal;\n\tC4WFYVal = C4WFY2Val - C4WFYVal;\n\n\tif (abs(C4WFXVal) > abs(C4WFYVal))\n\t{\n\t\tC4WFDist = abs(C4WFXVal) + 1;\n\t\tC4WFYVal = (int16) (256 * (double) C4WFYVal / abs(C4WFXVal));\n\t\tif (C4WFXVal < 0)\n\t\t\tC4WFXVal = -256;\n\t\telse\n\t\t\tC4WFXVal =  256;\n\t}\n\telse\n\t{\n\t\tif (C4WFYVal != 0)\n\t\t{\n\t\t\tC4WFDist = abs(C4WFYVal) + 1;\n\t\t\tC4WFXVal = (int16) (256 * (double) C4WFXVal / abs(C4WFYVal));\n\t\t\tif (C4WFYVal < 0)\n\t\t\t\tC4WFYVal = -256;\n\t\t\telse\n\t\t\t\tC4WFYVal =  256;\n\t\t}\n\t\telse\n\t\t\tC4WFDist = 0;\n\t}\n}\n\nvoid C4Op1F (void)\n{\n\tif (C41FXVal == 0)\n\t{\n\t\tif (C41FYVal > 0)\n\t\t\tC41FAngleRes = 0x80;\n\t\telse\n\t\t\tC41FAngleRes = 0x180;\n\t}\n\telse\n\t{\n\t\ttanval = (double) C41FYVal / C41FXVal;\n\t\tC41FAngleRes = (int16) (atan(tanval) / (C4_PI * 2) * 512);\n\t\tif (C41FXVal< 0)\n\t\t\tC41FAngleRes += 0x100;\n\t\tC41FAngleRes &= 0x1FF;\n\t}\n}\n\nvoid C4Op15 (void)\n{\n\ttanval = sqrt((double) C41FYVal * C41FYVal + (double) C41FXVal * C41FXVal);\n\tC41FDist = (int16) tanval;\n}\n\nvoid C4Op0D (void)\n{\n\ttanval = sqrt((double) C41FYVal * C41FYVal + (double) C41FXVal * C41FXVal);\n\ttanval = C41FDistVal / tanval;\n\tC41FYVal = (int16) (C41FYVal * tanval * 0.99);\n\tC41FXVal = (int16) (C41FXVal * tanval * 0.98);\n}\n\nuint8 * S9xGetBasePointerC4 (uint16 Address)\n{\n\tif (Address >= 0x7f40 && Address <= 0x7f5e)\n\t\treturn (NULL);\n\treturn (Memory.C4RAM - 0x6000);\n}\n\nuint8 * S9xGetMemPointerC4 (uint16 Address)\n{\n\tif (Address >= 0x7f40 && Address <= 0x7f5e)\n\t\treturn (NULL);\n\treturn (Memory.C4RAM - 0x6000 + (Address & 0xffff));\n}\n"
        },
        {
          "name": "c4.h",
          "type": "blob",
          "size": 1.11328125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _C4_H_\n#define _C4_H_\n\nextern int16\tC4WFXVal;\nextern int16\tC4WFYVal;\nextern int16\tC4WFZVal;\nextern int16\tC4WFX2Val;\nextern int16\tC4WFY2Val;\nextern int16\tC4WFDist;\nextern int16\tC4WFScale;\nextern int16\tC41FXVal;\nextern int16\tC41FYVal;\nextern int16\tC41FAngleRes;\nextern int16\tC41FDist;\nextern int16\tC41FDistVal;\n\nvoid C4TransfWireFrame (void);\nvoid C4TransfWireFrame2 (void);\nvoid C4CalcWireFrame (void);\nvoid C4Op0D (void);\nvoid C4Op15 (void);\nvoid C4Op1F (void);\nvoid S9xInitC4 (void);\nvoid S9xSetC4 (uint8, uint16);\nuint8 S9xGetC4 (uint16);\nuint8 * S9xGetBasePointerC4 (uint16);\nuint8 * S9xGetMemPointerC4 (uint16);\n\nstatic inline uint8 * C4GetMemPointer (uint32 Address)\n{\n\treturn (Memory.ROM + ((Address & 0xff0000) >> 1) + (Address & 0x7fff));\n}\n\n#endif\n"
        },
        {
          "name": "c4emu.cpp",
          "type": "blob",
          "size": 33.603515625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include <math.h>\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"sar.h\"\n\nstatic int16\tC4SinTable[512] =\n{\n\t     0,    402,    804,   1206,   1607,   2009,   2410,   2811,\n\t  3211,   3611,   4011,   4409,   4808,   5205,   5602,   5997,\n\t  6392,   6786,   7179,   7571,   7961,   8351,   8739,   9126,\n\t  9512,   9896,  10278,  10659,  11039,  11416,  11793,  12167,\n\t 12539,  12910,  13278,  13645,  14010,  14372,  14732,  15090,\n\t 15446,  15800,  16151,  16499,  16846,  17189,  17530,  17869,\n\t 18204,  18537,  18868,  19195,  19519,  19841,  20159,  20475,\n\t 20787,  21097,  21403,  21706,  22005,  22301,  22594,  22884,\n\t 23170,  23453,  23732,  24007,  24279,  24547,  24812,  25073,\n\t 25330,  25583,  25832,  26077,  26319,  26557,  26790,  27020,\n\t 27245,  27466,  27684,  27897,  28106,  28310,  28511,  28707,\n\t 28898,  29086,  29269,  29447,  29621,  29791,  29956,  30117,\n\t 30273,  30425,  30572,  30714,  30852,  30985,  31114,  31237,\n\t 31357,  31471,  31581,  31685,  31785,  31881,  31971,  32057,\n\t 32138,  32214,  32285,  32351,  32413,  32469,  32521,  32568,\n\t 32610,  32647,  32679,  32706,  32728,  32745,  32758,  32765,\n\t 32767,  32765,  32758,  32745,  32728,  32706,  32679,  32647,\n\t 32610,  32568,  32521,  32469,  32413,  32351,  32285,  32214,\n\t 32138,  32057,  31971,  31881,  31785,  31685,  31581,  31471,\n\t 31357,  31237,  31114,  30985,  30852,  30714,  30572,  30425,\n\t 30273,  30117,  29956,  29791,  29621,  29447,  29269,  29086,\n\t 28898,  28707,  28511,  28310,  28106,  27897,  27684,  27466,\n\t 27245,  27020,  26790,  26557,  26319,  26077,  25832,  25583,\n\t 25330,  25073,  24812,  24547,  24279,  24007,  23732,  23453,\n\t 23170,  22884,  22594,  22301,  22005,  21706,  21403,  21097,\n\t 20787,  20475,  20159,  19841,  19519,  19195,  18868,  18537,\n\t 18204,  17869,  17530,  17189,  16846,  16499,  16151,  15800,\n\t 15446,  15090,  14732,  14372,  14010,  13645,  13278,  12910,\n\t 12539,  12167,  11793,  11416,  11039,  10659,  10278,   9896,\n\t  9512,   9126,   8739,   8351,   7961,   7571,   7179,   6786,\n\t  6392,   5997,   5602,   5205,   4808,   4409,   4011,   3611,\n\t  3211,   2811,   2410,   2009,   1607,   1206,    804,    402,\n\t     0,   -402,   -804,  -1206,  -1607,  -2009,  -2410,  -2811,\n\t -3211,  -3611,  -4011,  -4409,  -4808,  -5205,  -5602,  -5997,\n\t -6392,  -6786,  -7179,  -7571,  -7961,  -8351,  -8739,  -9126,\n\t -9512,  -9896, -10278, -10659, -11039, -11416, -11793, -12167,\n\t-12539, -12910, -13278, -13645, -14010, -14372, -14732, -15090,\n\t-15446, -15800, -16151, -16499, -16846, -17189, -17530, -17869,\n\t-18204, -18537, -18868, -19195, -19519, -19841, -20159, -20475,\n\t-20787, -21097, -21403, -21706, -22005, -22301, -22594, -22884,\n\t-23170, -23453, -23732, -24007, -24279, -24547, -24812, -25073,\n\t-25330, -25583, -25832, -26077, -26319, -26557, -26790, -27020,\n\t-27245, -27466, -27684, -27897, -28106, -28310, -28511, -28707,\n\t-28898, -29086, -29269, -29447, -29621, -29791, -29956, -30117,\n\t-30273, -30425, -30572, -30714, -30852, -30985, -31114, -31237,\n\t-31357, -31471, -31581, -31685, -31785, -31881, -31971, -32057,\n\t-32138, -32214, -32285, -32351, -32413, -32469, -32521, -32568,\n\t-32610, -32647, -32679, -32706, -32728, -32745, -32758, -32765,\n\t-32767, -32765, -32758, -32745, -32728, -32706, -32679, -32647,\n\t-32610, -32568, -32521, -32469, -32413, -32351, -32285, -32214,\n\t-32138, -32057, -31971, -31881, -31785, -31685, -31581, -31471,\n\t-31357, -31237, -31114, -30985, -30852, -30714, -30572, -30425,\n\t-30273, -30117, -29956, -29791, -29621, -29447, -29269, -29086,\n\t-28898, -28707, -28511, -28310, -28106, -27897, -27684, -27466,\n\t-27245, -27020, -26790, -26557, -26319, -26077, -25832, -25583,\n\t-25330, -25073, -24812, -24547, -24279, -24007, -23732, -23453,\n\t-23170, -22884, -22594, -22301, -22005, -21706, -21403, -21097,\n\t-20787, -20475, -20159, -19841, -19519, -19195, -18868, -18537,\n\t-18204, -17869, -17530, -17189, -16846, -16499, -16151, -15800,\n\t-15446, -15090, -14732, -14372, -14010, -13645, -13278, -12910,\n\t-12539, -12167, -11793, -11416, -11039, -10659, -10278,  -9896,\n\t -9512,  -9126,  -8739,  -8351,  -7961,  -7571,  -7179,  -6786,\n\t -6392,  -5997,  -5602,  -5205,  -4808,  -4409,  -4011,  -3611,\n\t -3211,  -2811,  -2410,  -2009,  -1607,  -1206,   -804,   -402\n};\n\nstatic int16\tC4CosTable[512] =\n{\n\t 32767,  32765,  32758,  32745,  32728,  32706,  32679,  32647,\n\t 32610,  32568,  32521,  32469,  32413,  32351,  32285,  32214,\n\t 32138,  32057,  31971,  31881,  31785,  31685,  31581,  31471,\n\t 31357,  31237,  31114,  30985,  30852,  30714,  30572,  30425,\n\t 30273,  30117,  29956,  29791,  29621,  29447,  29269,  29086,\n\t 28898,  28707,  28511,  28310,  28106,  27897,  27684,  27466,\n\t 27245,  27020,  26790,  26557,  26319,  26077,  25832,  25583,\n\t 25330,  25073,  24812,  24547,  24279,  24007,  23732,  23453,\n\t 23170,  22884,  22594,  22301,  22005,  21706,  21403,  21097,\n\t 20787,  20475,  20159,  19841,  19519,  19195,  18868,  18537,\n\t 18204,  17869,  17530,  17189,  16846,  16499,  16151,  15800,\n\t 15446,  15090,  14732,  14372,  14010,  13645,  13278,  12910,\n\t 12539,  12167,  11793,  11416,  11039,  10659,  10278,   9896,\n\t  9512,   9126,   8739,   8351,   7961,   7571,   7179,   6786,\n\t  6392,   5997,   5602,   5205,   4808,   4409,   4011,   3611,\n\t  3211,   2811,   2410,   2009,   1607,   1206,    804,    402,\n\t     0,   -402,   -804,  -1206,  -1607,  -2009,  -2410,  -2811,\n\t -3211,  -3611,  -4011,  -4409,  -4808,  -5205,  -5602,  -5997,\n\t -6392,  -6786,  -7179,  -7571,  -7961,  -8351,  -8739,  -9126,\n\t -9512,  -9896, -10278, -10659, -11039, -11416, -11793, -12167,\n\t-12539, -12910, -13278, -13645, -14010, -14372, -14732, -15090,\n\t-15446, -15800, -16151, -16499, -16846, -17189, -17530, -17869,\n\t-18204, -18537, -18868, -19195, -19519, -19841, -20159, -20475,\n\t-20787, -21097, -21403, -21706, -22005, -22301, -22594, -22884,\n\t-23170, -23453, -23732, -24007, -24279, -24547, -24812, -25073,\n\t-25330, -25583, -25832, -26077, -26319, -26557, -26790, -27020,\n\t-27245, -27466, -27684, -27897, -28106, -28310, -28511, -28707,\n\t-28898, -29086, -29269, -29447, -29621, -29791, -29956, -30117,\n\t-30273, -30425, -30572, -30714, -30852, -30985, -31114, -31237,\n\t-31357, -31471, -31581, -31685, -31785, -31881, -31971, -32057,\n\t-32138, -32214, -32285, -32351, -32413, -32469, -32521, -32568,\n\t-32610, -32647, -32679, -32706, -32728, -32745, -32758, -32765,\n\t-32767, -32765, -32758, -32745, -32728, -32706, -32679, -32647,\n\t-32610, -32568, -32521, -32469, -32413, -32351, -32285, -32214,\n\t-32138, -32057, -31971, -31881, -31785, -31685, -31581, -31471,\n\t-31357, -31237, -31114, -30985, -30852, -30714, -30572, -30425,\n\t-30273, -30117, -29956, -29791, -29621, -29447, -29269, -29086,\n\t-28898, -28707, -28511, -28310, -28106, -27897, -27684, -27466,\n\t-27245, -27020, -26790, -26557, -26319, -26077, -25832, -25583,\n\t-25330, -25073, -24812, -24547, -24279, -24007, -23732, -23453,\n\t-23170, -22884, -22594, -22301, -22005, -21706, -21403, -21097,\n\t-20787, -20475, -20159, -19841, -19519, -19195, -18868, -18537,\n\t-18204, -17869, -17530, -17189, -16846, -16499, -16151, -15800,\n\t-15446, -15090, -14732, -14372, -14010, -13645, -13278, -12910,\n\t-12539, -12167, -11793, -11416, -11039, -10659, -10278,  -9896,\n\t -9512,  -9126,  -8739,  -8351,  -7961,  -7571,  -7179,  -6786,\n\t -6392,  -5997,  -5602,  -5205,  -4808,  -4409,  -4011,  -3611,\n\t -3211,  -2811,  -2410,  -2009,  -1607,  -1206,   -804,   -402,\n\t     0,    402,    804,   1206,   1607,   2009,   2410,   2811,\n\t  3211,   3611,   4011,   4409,   4808,   5205,   5602,   5997,\n\t  6392,   6786,   7179,   7571,   7961,   8351,   8739,   9126,\n\t  9512,   9896,  10278,  10659,  11039,  11416,  11793,  12167,\n\t 12539,  12910,  13278,  13645,  14010,  14372,  14732,  15090,\n\t 15446,  15800,  16151,  16499,  16846,  17189,  17530,  17869,\n\t 18204,  18537,  18868,  19195,  19519,  19841,  20159,  20475,\n\t 20787,  21097,  21403,  21706,  22005,  22301,  22594,  22884,\n\t 23170,  23453,  23732,  24007,  24279,  24547,  24812,  25073,\n\t 25330,  25583,  25832,  26077,  26319,  26557,  26790,  27020,\n\t 27245,  27466,  27684,  27897,  28106,  28310,  28511,  28707,\n\t 28898,  29086,  29269,  29447,  29621,  29791,  29956,  30117,\n\t 30273,  30425,  30572,  30714,  30852,  30985,  31114,  31237,\n\t 31357,  31471,  31581,  31685,  31785,  31881,  31971,  32057,\n\t 32138,  32214,  32285,  32351,  32413,  32469,  32521,  32568,\n\t 32610,  32647,  32679,  32706,  32728,  32745,  32758,  32765\n};\n\nstatic uint8\tC4TestPattern[12 * 4] =\n{\n\t0x00, 0x00, 0x00, 0xff,\n\t0xff, 0xff, 0x00, 0xff,\n\t0x00, 0x00, 0x00, 0xff,\n\t0xff, 0xff, 0x00, 0x00,\n\t0xff, 0xff, 0x00, 0x00,\n\t0x80, 0xff, 0xff, 0x7f,\n\t0x00, 0x80, 0x00, 0xff,\n\t0x7f, 0x00, 0xff, 0x7f,\n\t0xff, 0x7f, 0xff, 0xff,\n\t0x00, 0x00, 0x01, 0xff,\n\t0xff, 0xfe, 0x00, 0x01,\n\t0x00, 0xff, 0xfe, 0x00\n};\n\nstatic void C4ConvOAM (void);\nstatic void C4DoScaleRotate (int);\nstatic void C4DrawLine (int32, int32, int16, int32, int32, int16, uint8);\nstatic void C4DrawWireFrame (void);\nstatic void C4TransformLines (void);\nstatic void C4BitPlaneWave (void);\nstatic void C4SprDisintegrate (void);\nstatic void C4ProcessSprites (void);\n\n\nstatic void C4ConvOAM (void)\n{\n\tuint8\t*OAMptr = Memory.C4RAM + (Memory.C4RAM[0x626] << 2);\n\tfor (uint8 *i = Memory.C4RAM + 0x1fd; i > OAMptr; i -= 4)\n\t\t*i = 0xe0; // Clear OAM-to-be\n\n\tuint8\t*OAMptr2;\n\tuint16\tglobalX, globalY;\n\tint16\tSprX, SprY;\n\tuint8\tSprName, SprAttr;\n\tuint8\tSprCount;\n\n\tglobalX = READ_WORD(Memory.C4RAM + 0x0621);\n\tglobalY = READ_WORD(Memory.C4RAM + 0x0623);\n\tOAMptr2 = Memory.C4RAM + 0x200 + (Memory.C4RAM[0x626] >> 2);\n\n#ifdef DEBUGGER\n\tif (Memory.C4RAM[0x625] != 0)\n\t\tprintf(\"$6625=%02x, expected 00\\n\", Memory.C4RAM[0x625]);\n\tif ((Memory.C4RAM[0x626] >> 2) != Memory.C4RAM[0x629])\n\t\tprintf(\"$6629=%02x, expected %02x\\n\", Memory.C4RAM[0x629], (Memory.C4RAM[0x626] >> 2));\n\tif (((uint16) Memory.C4RAM[0x626] << 2) != READ_WORD(Memory.C4RAM + 0x627))\n\t\tprintf(\"$6627=%04x, expected %04x\\n\", READ_WORD(Memory.C4RAM + 0x627), ((uint16) Memory.C4RAM[0x626] << 2));\n#endif\n\n\tif (Memory.C4RAM[0x0620] != 0)\n\t{\n\t\tSprCount = 128 - Memory.C4RAM[0x626];\n\n\t\tuint8\toffset = (Memory.C4RAM[0x626] & 3) * 2;\n\t\tuint8\t*srcptr = Memory.C4RAM + 0x220;\n\n\t\tfor (int i = Memory.C4RAM[0x0620]; i > 0 && SprCount > 0; i--, srcptr += 16)\n\t\t{\n\t\t\tSprX = READ_WORD(srcptr)     - globalX;\n\t\t\tSprY = READ_WORD(srcptr + 2) - globalY;\n\t\t\tSprName = srcptr[5];\n\t\t\tSprAttr = srcptr[4] | srcptr[0x06]; // XXX: mask bits?\n\n\t\t\tuint8\t*sprptr = C4GetMemPointer(READ_3WORD(srcptr + 7));\n\t\t\tif (*sprptr != 0)\n\t\t\t{\n\t\t\t\tint16\tX, Y;\n\n\t\t\t\tfor (int SprCnt = *sprptr++; SprCnt > 0 && SprCount > 0; SprCnt--, sprptr += 4)\n\t\t\t\t{\n\t\t\t\t\tX = (int8) sprptr[1];\n\t\t\t\t\tif (SprAttr & 0x40)\n\t\t\t\t\t\tX = -X - ((sprptr[0] & 0x20) ? 16 : 8); // flip X\n\t\t\t\t\tX += SprX;\n\n\t\t\t\t\tif (X >= -16 && X <= 272)\n\t\t\t\t\t{\n\t\t\t\t\t\tY = (int8) sprptr[2];\n\t\t\t\t\t\tif (SprAttr & 0x80)\n\t\t\t\t\t\t\tY = -Y - ((sprptr[0] & 0x20) ? 16 : 8);\n\t\t\t\t\t\tY += SprY;\n\n\t\t\t\t\t\tif (Y >= -16 && Y <= 224)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOAMptr[0] = X & 0xff;\n\t\t\t\t\t\t\tOAMptr[1] = (uint8) Y;\n\t\t\t\t\t\t\tOAMptr[2] = SprName + sprptr[3];\n\t\t\t\t\t\t\tOAMptr[3] = SprAttr ^ (sprptr[0] & 0xc0); // XXX: Carry from SprName addition?\n\n\t\t\t\t\t\t\t*OAMptr2 &= ~(3 << offset);\n\t\t\t\t\t\t\tif (X & 0x100)\n\t\t\t\t\t\t\t\t*OAMptr2 |= 1 << offset;\n\t\t\t\t\t\t\tif (sprptr[0] & 0x20)\n\t\t\t\t\t\t\t\t*OAMptr2 |= 2 << offset;\n\n\t\t\t\t\t\t\tOAMptr += 4;\n\t\t\t\t\t\t\tSprCount--;\n\n\t\t\t\t\t\t\toffset = (offset + 2) & 6;\n\t\t\t\t\t\t\tif (offset == 0)\n\t\t\t\t\t\t\t\tOAMptr2++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (SprCount > 0)\n\t\t\t{\n\t\t\t\t// XXX: Should we be testing -16<=SprX<=272 and -16<=SprY<=224?\n\t\t\t\tOAMptr[0] = (uint8) SprX;\n\t\t\t\tOAMptr[1] = (uint8) SprY;\n\t\t\t\tOAMptr[2] = SprName;\n\t\t\t\tOAMptr[3] = SprAttr;\n\n\t\t\t\t*OAMptr2 &= ~(3 << offset);\n\t\t\t\tif (SprX & 0x100)\n\t\t\t\t\t*OAMptr2 |= 3 << offset;\n\t\t\t\telse\n\t\t\t\t\t*OAMptr2 |= 2 << offset;\n\n\t\t\t\tOAMptr += 4;\n\t\t\t\tSprCount--;\n\n\t\t\t\toffset = (offset + 2) & 6;\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tOAMptr2++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void C4DoScaleRotate (int row_padding)\n{\n\tint16\tA, B, C, D;\n\n\t// Calculate matrix\n\tint32\tXScale = READ_WORD(Memory.C4RAM + 0x1f8f);\n\tif (XScale & 0x8000)\n\t\tXScale = 0x7fff;\n\n\tint32\tYScale = READ_WORD(Memory.C4RAM + 0x1f92);\n\tif (YScale & 0x8000)\n\t\tYScale = 0x7fff;\n\n\tif (READ_WORD(Memory.C4RAM + 0x1f80) == 0)\t\t// no rotation\n\t{\n\t\t// XXX: only do this for C and D?\n\t\t// XXX: and then only when YScale is 0x1000?\n\t\tA = (int16) XScale;\n\t\tB = 0;\n\t\tC = 0;\n\t\tD = (int16) YScale;\n\t}\n\telse\n\tif (READ_WORD(Memory.C4RAM + 0x1f80) == 128)\t// 90 degree rotation\n\t{\n\t\t// XXX: Really do this?\n\t\tA = 0;\n\t\tB = (int16) (-YScale);\n\t\tC = (int16) XScale;\n\t\tD = 0;\n\t}\n\telse\n\tif (READ_WORD(Memory.C4RAM + 0x1f80) == 256)\t// 180 degree rotation\n\t{\n\t\t// XXX: Really do this?\n\t\tA = (int16) (-XScale);\n\t\tB = 0;\n\t\tC = 0;\n\t\tD = (int16) (-YScale);\n\t}\n\telse\n\tif (READ_WORD(Memory.C4RAM + 0x1f80) == 384)\t// 270 degree rotation\n\t{\n\t\t// XXX: Really do this?\n\t\tA = 0;\n\t\tB = (int16) YScale;\n\t\tC = (int16) (-XScale);\n\t\tD = 0;\n\t}\n\telse\n\t{\n\t\tA = (int16)   SAR(C4CosTable[READ_WORD(Memory.C4RAM + 0x1f80) & 0x1ff] * XScale, 15);\n\t\tB = (int16) (-SAR(C4SinTable[READ_WORD(Memory.C4RAM + 0x1f80) & 0x1ff] * YScale, 15));\n\t\tC = (int16)   SAR(C4SinTable[READ_WORD(Memory.C4RAM + 0x1f80) & 0x1ff] * XScale, 15);\n\t\tD = (int16)   SAR(C4CosTable[READ_WORD(Memory.C4RAM + 0x1f80) & 0x1ff] * YScale, 15);\n\t}\n\n\t// Calculate Pixel Resolution\n\tuint8\tw = Memory.C4RAM[0x1f89] & ~7;\n\tuint8\th = Memory.C4RAM[0x1f8c] & ~7;\n\n\t//printf(\"%dx%d XScale=%04x YScale=%04x angle=%03x\\n\", w, h, XScale, YScale, READ_WORD(Memory.C4RAM + 0x1f80) & 0x1ff);\n\t//printf(\"Matrix: [%10g %10g]  [%04x %04x]\\n\", A / 4096.0, B / 4096.0, A & 0xffff, B & 0xffff);\n\t//printf(\"        [%10g %10g]  [%04x %04x]\\n\", C / 4096.0, D / 4096.0, C & 0xffff, D & 0xffff);\n\n\t// Clear the output RAM\n\tmemset(Memory.C4RAM, 0, (w + row_padding / 4) * h / 2);\n\n\tint32\tCx = (int16) READ_WORD(Memory.C4RAM + 0x1f83);\n\tint32\tCy = (int16) READ_WORD(Memory.C4RAM + 0x1f86);\n\n#ifdef DEBUGGER\n\tif (Memory.C4RAM[0x1f97] != 0)\n\t\tprintf(\"$7f97=%02x, expected 00\\n\", Memory.C4RAM[0x1f97]);\n\tif ((Cx & ~1) != w / 2 || (Cy & ~1) != h / 2)\n\t\tprintf(\"Center is not middle of image! (%d, %d) != (%d, %d)\\n\", Cx, Cy, w / 2, h / 2);\n#endif\n\n\t// Calculate start position (i.e. (Ox, Oy) = (0, 0))\n\t// The low 12 bits are fractional, so (Cx<<12) gives us the Cx we want in the function.\n\t// We do Cx*A etc normally because the matrix parameters already have the fractional parts.\n\tint32\tLineX = (Cx << 12) - Cx * A - Cx * B;\n\tint32\tLineY = (Cy << 12) - Cy * C - Cy * D;\n\n\t// Start loop\n\tuint32\tX, Y;\n\tuint8\tbyte;\n\tint\t\toutidx = 0;\n\tuint8\tbit = 0x80;\n\n\tfor (int y = 0; y < h; y++)\n\t{\n\t\tX = LineX;\n\t\tY = LineY;\n\n\t\tfor (int x = 0; x < w; x++)\n\t\t{\n\t\t\tif ((X >> 12) >= w || (Y >> 12) >= h)\n\t\t\t\tbyte = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32\taddr = (Y >> 12) * w + (X >> 12);\n\t\t\t\tbyte = Memory.C4RAM[0x600 + (addr >> 1)];\n\t\t\t\tif (addr & 1)\n\t\t\t\t\tbyte >>= 4;\n\t\t\t}\n\n\t\t\t// De-bitplanify\n\t\t\tif (byte & 1)\n\t\t\t\tMemory.C4RAM[outidx]      |= bit;\n\t\t\tif (byte & 2)\n\t\t\t\tMemory.C4RAM[outidx + 1]  |= bit;\n\t\t\tif (byte & 4)\n\t\t\t\tMemory.C4RAM[outidx + 16] |= bit;\n\t\t\tif (byte & 8)\n\t\t\t\tMemory.C4RAM[outidx + 17] |= bit;\n\n\t\t\tbit >>= 1;\n\t\t\tif (bit == 0)\n\t\t\t{\n\t\t\t\tbit = 0x80;\n\t\t\t\toutidx += 32;\n\t\t\t}\n\n\t\t\tX += A; // Add 1 to output x => add an A and a C\n\t\t\tY += C;\n\t\t}\n\n\t\toutidx += 2 + row_padding;\n\t\tif (outidx & 0x10)\n\t\t\toutidx &= ~0x10;\n\t\telse\n\t\t\toutidx -= w * 4 + row_padding;\n\n\t\tLineX += B; // Add 1 to output y => add a B and a D\n\t\tLineY += D;\n\t}\n}\n\nstatic void C4DrawLine (int32 X1, int32 Y1, int16 Z1, int32 X2, int32 Y2, int16 Z2, uint8 Color)\n{\n\t// Transform coordinates\n\tC4WFXVal  = (int16) X1;\n\tC4WFYVal  = (int16) Y1;\n\tC4WFZVal  = Z1;\n\tC4WFScale = Memory.C4RAM[0x1f90];\n\tC4WFX2Val = Memory.C4RAM[0x1f86];\n\tC4WFY2Val = Memory.C4RAM[0x1f87];\n\tC4WFDist  = Memory.C4RAM[0x1f88];\n\tC4TransfWireFrame2();\n\tX1 = (C4WFXVal + 48) << 8;\n\tY1 = (C4WFYVal + 48) << 8;\n\n\tC4WFXVal  = (int16) X2;\n\tC4WFYVal  = (int16) Y2;\n\tC4WFZVal  = Z2;\n\tC4TransfWireFrame2();\n\tX2 = (C4WFXVal + 48) << 8;\n\tY2 = (C4WFYVal + 48) << 8;\n\n\t// Get line info\n\tC4WFXVal  = (int16) (X1 >> 8);\n\tC4WFYVal  = (int16) (Y1 >> 8);\n\tC4WFX2Val = (int16) (X2 >> 8);\n\tC4WFY2Val = (int16) (Y2 >> 8);\n\tC4CalcWireFrame();\n\tX2 = (int16) C4WFXVal;\n\tY2 = (int16) C4WFYVal;\n\n\t// Render line\n\tfor (int i = C4WFDist ? C4WFDist : 1; i > 0; i--)\n\t{\n\t\tif (X1 > 0xff && Y1 > 0xff && X1 < 0x6000 && Y1 < 0x6000)\n\t\t{\n\t\t\tuint16\taddr = (((Y1 >> 8) >> 3) << 8) - (((Y1 >> 8) >> 3) << 6) + (((X1 >> 8) >> 3) << 4) + ((Y1 >> 8) & 7) * 2;\n\t\t\tuint8\tbit = 0x80 >> ((X1 >> 8) & 7);\n\n\t\t\tMemory.C4RAM[addr + 0x300] &= ~bit;\n\t\t\tMemory.C4RAM[addr + 0x301] &= ~bit;\n\t\t\tif (Color & 1)\n\t\t\t\tMemory.C4RAM[addr + 0x300] |= bit;\n\t\t\tif (Color & 2)\n\t\t\t\tMemory.C4RAM[addr + 0x301] |= bit;\n\t\t}\n\n\t\tX1 += X2;\n\t\tY1 += Y2;\n\t}\n}\n\nstatic void C4DrawWireFrame (void)\n{\n\tuint8\t*line = C4GetMemPointer(READ_3WORD(Memory.C4RAM + 0x1f80));\n\tuint8\t*point1, *point2;\n\tint16\tX1, Y1, Z1;\n\tint16\tX2, Y2, Z2;\n\tuint8\tColor;\n\n#ifdef DEBUGGER\n\tif (READ_3WORD(Memory.C4RAM + 0x1f8f) & 0xff00ff)\n\t\tprintf(\"wireframe: Unexpected value in $7f8f: %06x\\n\", READ_3WORD(Memory.C4RAM + 0x1f8f));\n\tif (READ_3WORD(Memory.C4RAM + 0x1fa4) != 0x001000)\n\t\tprintf(\"wireframe: Unexpected value in $7fa4: %06x\\n\", READ_3WORD(Memory.C4RAM + 0x1fa4));\n#endif\n\n\tfor (int i = Memory.C4RAM[0x0295]; i > 0; i--, line += 5)\n\t{\n\t\tif (line[0] == 0xff && line[1] == 0xff)\n\t\t{\n\t\t\tuint8\t*tmp = line - 5;\n\t\t\twhile (tmp[2] == 0xff && tmp[3] == 0xff)\n\t\t\t\ttmp -= 5;\n\t\t\tpoint1 = C4GetMemPointer((Memory.C4RAM[0x1f82] << 16) | (tmp[2]  << 8) |  tmp[3]);\n\t\t}\n\t\telse\n\t\t\tpoint1 = C4GetMemPointer((Memory.C4RAM[0x1f82] << 16) | (line[0] << 8) | line[1]);\n\n\t\tpoint2 = C4GetMemPointer((Memory.C4RAM[0x1f82] << 16) | (line[2] << 8) | line[3]);\n\n\t\tX1 = (point1[0] << 8) | point1[1];\n\t\tY1 = (point1[2] << 8) | point1[3];\n\t\tZ1 = (point1[4] << 8) | point1[5];\n\t\tX2 = (point2[0] << 8) | point2[1];\n\t\tY2 = (point2[2] << 8) | point2[3];\n\t\tZ2 = (point2[4] << 8) | point2[5];\n\n\t\tColor = line[4];\n\n\t\tC4DrawLine(X1, Y1, Z1, X2, Y2, Z2, Color);\n\t}\n}\n\nstatic void C4TransformLines (void)\n{\n\tC4WFX2Val = Memory.C4RAM[0x1f83];\n\tC4WFY2Val = Memory.C4RAM[0x1f86];\n\tC4WFDist  = Memory.C4RAM[0x1f89];\n\tC4WFScale = Memory.C4RAM[0x1f8c];\n\n#ifdef DEBUGGER\n\tif (Memory.C4RAM[0x1f8a] != 0x90)\n\t\tprintf(\"lines: $7f8a = %02x, expected 90\\n\", READ_WORD(Memory.C4RAM + 0x1f8a));\n#endif\n\n\t// Transform vertices\n\tuint8\t*ptr = Memory.C4RAM;\n\n\tfor (int i = READ_WORD(Memory.C4RAM + 0x1f80); i > 0; i--, ptr += 0x10)\n\t{\n\t\tC4WFXVal = READ_WORD(ptr + 1);\n\t\tC4WFYVal = READ_WORD(ptr + 5);\n\t\tC4WFZVal = READ_WORD(ptr + 9);\n\t\tC4TransfWireFrame();\n\n\t\t// Displace\n\t\tWRITE_WORD(ptr + 1, C4WFXVal + 0x80);\n\t\tWRITE_WORD(ptr + 5, C4WFYVal + 0x50);\n\t}\n\n\tWRITE_WORD(Memory.C4RAM + 0x600,       23);\n\tWRITE_WORD(Memory.C4RAM + 0x602,     0x60);\n\tWRITE_WORD(Memory.C4RAM + 0x605,     0x40);\n\tWRITE_WORD(Memory.C4RAM + 0x600 + 8,   23);\n\tWRITE_WORD(Memory.C4RAM + 0x602 + 8, 0x60);\n\tWRITE_WORD(Memory.C4RAM + 0x605 + 8, 0x40);\n\n\tptr = Memory.C4RAM + 0xb02;\n\tuint8\t*ptr2 = Memory.C4RAM;\n\n\tfor (int i = READ_WORD(Memory.C4RAM + 0xb00); i > 0; i--, ptr += 2, ptr2 += 8)\n\t{\n\t\tC4WFXVal  = READ_WORD(Memory.C4RAM + (ptr[0] << 4) + 1);\n\t\tC4WFYVal  = READ_WORD(Memory.C4RAM + (ptr[0] << 4) + 5);\n\t\tC4WFX2Val = READ_WORD(Memory.C4RAM + (ptr[1] << 4) + 1);\n\t\tC4WFY2Val = READ_WORD(Memory.C4RAM + (ptr[1] << 4) + 5);\n\t\tC4CalcWireFrame();\n\n\t\tWRITE_WORD(ptr2 + 0x600, C4WFDist ? C4WFDist : 1);\n\t\tWRITE_WORD(ptr2 + 0x602, C4WFXVal);\n\t\tWRITE_WORD(ptr2 + 0x605, C4WFYVal);\n\t}\n}\n\nstatic void C4BitPlaneWave (void)\n{\n\tstatic uint16 bmpdata[] =\n\t{\n\t\t0x0000, 0x0002, 0x0004, 0x0006, 0x0008, 0x000A, 0x000C, 0x000E,\n\t\t0x0200, 0x0202, 0x0204, 0x0206, 0x0208, 0x020A, 0x020C, 0x020E,\n\t\t0x0400, 0x0402, 0x0404, 0x0406, 0x0408, 0x040A, 0x040C, 0x040E,\n\t\t0x0600, 0x0602, 0x0604, 0x0606, 0x0608, 0x060A, 0x060C, 0x060E,\n\t\t0x0800, 0x0802, 0x0804, 0x0806, 0x0808, 0x080A, 0x080C, 0x080E\n\t};\n\n\tuint8\t*dst = Memory.C4RAM;\n\tuint32\twaveptr = Memory.C4RAM[0x1f83];\n\tuint16\tmask1 = 0xc0c0;\n\tuint16\tmask2 = 0x3f3f;\n\n#ifdef DEBUGGER\n\tif (READ_3WORD(Memory.C4RAM + 0x1f80) != Memory.C4RAM[waveptr + 0xb00])\n\t\tprintf(\"$7f80=%06x, expected %02x\\n\", READ_3WORD(Memory.C4RAM + 0x1f80), Memory.C4RAM[waveptr + 0xb00]);\n#endif\n\n\tfor (int j = 0; j < 0x10; j++)\n\t{\n\t\tdo\n\t\t{\n\t\t\tint16\theight = -((int8) Memory.C4RAM[waveptr + 0xb00]) - 16;\n\n\t\t\tfor (int i = 0; i < 40; i++)\n\t\t\t{\n\t\t\t\tuint16\ttmp = READ_WORD(dst + bmpdata[i]) & mask2;\n\t\t\t\tif (height >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (height < 8)\n\t\t\t\t\t\ttmp |= mask1 & READ_WORD(Memory.C4RAM + 0xa00 + height * 2);\n\t\t\t\t\telse\n\t\t\t\t\t\ttmp |= mask1 & 0xff00;\n\t\t\t\t}\n\n\t\t\t\tWRITE_WORD(dst + bmpdata[i], tmp);\n\n\t\t\t\theight++;\n\t\t\t}\n\n\t\t\twaveptr = (waveptr + 1) & 0x7f;\n\t\t\tmask1 = (mask1 >> 2) | (mask1 << 6);\n\t\t\tmask2 = (mask2 >> 2) | (mask2 << 6);\n\t\t}\n\t\twhile (mask1 != 0xc0c0);\n\n\t\tdst += 16;\n\n\t\tdo\n\t\t{\n\t\t\tint16\theight = -((int8) Memory.C4RAM[waveptr + 0xb00]) - 16;\n\n\t\t\tfor (int i = 0; i < 40; i++)\n\t\t\t{\n\t\t\t\tuint16\ttmp = READ_WORD(dst + bmpdata[i]) & mask2;\n\t\t\t\tif (height >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (height < 8)\n\t\t\t\t\t\ttmp |= mask1 & READ_WORD(Memory.C4RAM + 0xa10 + height * 2);\n\t\t\t\t\telse\n\t\t\t\t\t\ttmp |= mask1 & 0xff00;\n\t\t\t\t}\n\n\t\t\t\tWRITE_WORD(dst + bmpdata[i], tmp);\n\n\t\t\t\theight++;\n\t\t\t}\n\n\t\t\twaveptr = (waveptr + 1) & 0x7f;\n\t\t\tmask1 = (mask1 >> 2) | (mask1 << 6);\n\t\t\tmask2 = (mask2 >> 2) | (mask2 << 6);\n\t\t}\n\t\twhile (mask1 != 0xc0c0);\n\n\t\tdst += 16;\n\t}\n}\n\nstatic void C4SprDisintegrate (void)\n{\n\tuint8\t*src;\n\tuint8\twidth, height;\n\tuint32\tStartX, StartY;\n\tint32\tscaleX, scaleY;\n\tint32\tCx, Cy;\n\n\twidth  = Memory.C4RAM[0x1f89];\n\theight = Memory.C4RAM[0x1f8c];\n\tCx = (int16) READ_WORD(Memory.C4RAM + 0x1f80);\n\tCy = (int16) READ_WORD(Memory.C4RAM + 0x1f83);\n\n#ifdef DEBUGGER\n\tif ((Cx & ~1) != width / 2 || (Cy & ~1) != height / 2)\n\t\tprintf(\"Center is not middle of image for disintegrate! (%d, %d) != (%d, %d)\\n\", Cx, Cy, width / 2, height / 2);\n#endif\n\n\tscaleX = (int16) READ_WORD(Memory.C4RAM + 0x1f86);\n\tscaleY = (int16) READ_WORD(Memory.C4RAM + 0x1f8f);\n\tStartX = -Cx * scaleX + (Cx << 8);\n\tStartY = -Cy * scaleY + (Cy << 8);\n\n\tsrc = Memory.C4RAM + 0x600;\n\n\tmemset(Memory.C4RAM, 0, width * height / 2);\n\n\tfor (uint32 y = StartY, i = 0; i < height; i++, y += scaleY)\n\t{\n\t\tfor (uint32 x = StartX, j = 0; j < width; j++, x += scaleX)\n\t\t{\n\t\t\tif ((x >> 8) < width && (y >> 8) < height && (y >> 8) * width + (x >> 8) < 0x2000)\n\t\t\t{\n\t\t\t\tuint8\tpixel = (j & 1) ? (*src >> 4) : *src;\n\t\t\t\tint\t\tidx   = (y >> 11) * width * 4 + (x >> 11) * 32 + ((y >> 8) & 7) * 2;\n\t\t\t\tuint8\tmask  = 0x80 >> ((x >> 8) & 7);\n\n\t\t\t\tif (pixel & 1)\n\t\t\t\t\tMemory.C4RAM[idx]      |= mask;\n\t\t\t\tif (pixel & 2)\n\t\t\t\t\tMemory.C4RAM[idx + 1]  |= mask;\n\t\t\t\tif (pixel & 4)\n\t\t\t\t\tMemory.C4RAM[idx + 16] |= mask;\n\t\t\t\tif (pixel & 8)\n\t\t\t\t\tMemory.C4RAM[idx + 17] |= mask;\n\t\t\t}\n\n\t\t\tif (j & 1)\n\t\t\t\tsrc++;\n\t\t}\n\t}\n}\n\nstatic void C4ProcessSprites (void)\n{\n\tswitch (Memory.C4RAM[0x1f4d])\n\t{\n\t\tcase 0x00: // Build OAM\n\t\t#ifdef DEBUGGER\n\t\t\t//printf(\"00 00 Build OAM!\\n\");\n\t\t#endif\n\t\t\tC4ConvOAM();\n\t\t\tbreak;\n\n\t\tcase 0x03: // Scale/Rotate\n\t\t#ifdef DEBUGGER\n\t\t\t//printf(\"00 03 Scale/Rotate!\\n\");\n\t\t#endif\n\t\t\tC4DoScaleRotate(0);\n\t\t\tbreak;\n\n\t\tcase 0x05: // Transform Lines\n\t\t#ifdef DEBUGGER\n\t\t\t//printf(\"00 05 Transform Lines!\\n\");\n\t\t#endif\n\t\t\tC4TransformLines();\n\t\t\tbreak;\n\n\t\tcase 0x07: // Scale/Rotate\n\t\t#ifdef DEBUGGER\n\t\t\t//printf(\"00 07 Scale/Rotate!\\n\");\n\t\t#endif\n\t\t\tC4DoScaleRotate(64);\n\t\t\tbreak;\n\n\t\tcase 0x08: // Draw wireframe\n\t\t#ifdef DEBUGGER\n\t\t\t//printf(\"00 08 Draw wireframe!\\n\");\n\t\t#endif\n\t\t\tC4DrawWireFrame();\n\t\t\tbreak;\n\n\t\tcase 0x0b: // Disintegrate\n\t\t#ifdef DEBUGGER\n\t\t\t//printf(\"00 0b Disintegrate!\\n\");\n\t\t#endif\n\t\t\tC4SprDisintegrate();\n\t\t\tbreak;\n\n\t\tcase 0x0c: // Wave\n\t\t#ifdef DEBUGGER\n\t\t\t//printf(\"00 0b Wave!\\n\");\n\t\t#endif\n\t\t\tC4BitPlaneWave();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t#ifdef DEBUGGER\n\t\t\tprintf(\"Unknown C4 sprite command (%02x)\\n\", Memory.C4RAM[0x1f4d]);\n\t\t#endif\n\t\t\tbreak;\n\t}\n}\n\nvoid S9xInitC4 (void)\n{\n\t// Stupid zsnes code, we can't do the logical thing without breaking savestates\n\t// Memory.C4RAM = &Memory.FillRAM [0x6000];\n\tmemset(Memory.C4RAM, 0, 0x2000);\n}\n\nuint8 S9xGetC4 (uint16 Address)\n{\n\tif (Address == 0x7f5e)\n\t\treturn (0);\n\n\treturn (Memory.C4RAM[Address - 0x6000]);\n}\n\nvoid S9xSetC4 (uint8 byte, uint16 Address)\n{\n\tMemory.C4RAM[Address - 0x6000] = byte;\n\n\tif (Address == 0x7f4f)\n\t{\n\t\tif (Memory.C4RAM[0x1f4d] == 0x0e && byte < 0x40 && (byte & 3) == 0)\n\t\t{\n\t\t#ifdef DEBUGGER\n\t\t\tprintf(\"Test command %02x 0e used!\\n\", byte);\n\t\t#endif\n\t\t\tMemory.C4RAM[0x1f80] = byte >> 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch (byte)\n\t\t\t{\n\t\t\t\tcase 0x00: // Sprite\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"00 Sprite!\\n\");\n\t\t\t\t#endif\n\t\t\t\t\tC4ProcessSprites();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x01: // Draw wireframe\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"01 Draw wireframe!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 8)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 08 for command 01 %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tmemset(Memory.C4RAM + 0x300, 0, 16 * 12 * 3 * 4);\n\t\t\t\t\tC4DrawWireFrame();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x05: // Propulsion (?)\n\t\t\t\t{\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"05 Propulsion (?)!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 2)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 02 for command 05 %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tint32\ttmp = 0x10000;\n\t\t\t\t\tif (READ_WORD(Memory.C4RAM + 0x1f83))\n\t\t\t\t\t\ttmp = SAR((tmp / READ_WORD(Memory.C4RAM + 0x1f83)) * READ_WORD(Memory.C4RAM + 0x1f81), 8);\n\n\t\t\t\t\tWRITE_WORD(Memory.C4RAM + 0x1f80, (uint16) tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 0x0d: // Set vector length\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"0d Set vector length!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 2)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 02 for command 0d %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tC41FXVal    = READ_WORD(Memory.C4RAM + 0x1f80);\n\t\t\t\t\tC41FYVal    = READ_WORD(Memory.C4RAM + 0x1f83);\n\t\t\t\t\tC41FDistVal = READ_WORD(Memory.C4RAM + 0x1f86);\n\t\t\t\t\tC4Op0D();\n\t\t\t\t\tWRITE_WORD(Memory.C4RAM + 0x1f89, C41FXVal);\n\t\t\t\t\tWRITE_WORD(Memory.C4RAM + 0x1f8c, C41FYVal);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x10: // Polar to rectangluar\n\t\t\t\t{\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"10 Polar->Rect!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 2)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 02 for command 10 %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tint32\ttmp;\n\t\t\t\t\tint32   r1;\n\t\t\t\t\tr1 = READ_WORD(Memory.C4RAM + 0x1f83);\n\t\t\t\t\tif (r1 & 0x8000)\n\t\t\t\t\t        r1 |= ~0x7fff;\n\t\t\t\t\telse\n\t\t\t\t\t        r1 &= 0x7fff;\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\ttmp = SAR(r1 * C4CosTable[READ_WORD(Memory.C4RAM + 0x1f80) & 0x1ff] * 2, 16);\n\t\t\t\t\tWRITE_3WORD(Memory.C4RAM + 0x1f86, tmp);\n\t\t\t\t\ttmp = SAR(r1 * C4SinTable[READ_WORD(Memory.C4RAM + 0x1f80) & 0x1ff] * 2, 16);\n\t\t\t\t\tWRITE_3WORD(Memory.C4RAM + 0x1f89, (tmp - SAR(tmp, 6)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 0x13: // Polar to rectangluar\n\t\t\t\t{\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"13 Polar->Rect!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 2)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 02 for command 13 %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tint32\ttmp;\n\t\t\t\t\ttmp = SAR((int32) READ_WORD(Memory.C4RAM + 0x1f83) * C4CosTable[READ_WORD(Memory.C4RAM + 0x1f80) & 0x1ff] * 2, 8);\n\t\t\t\t\tWRITE_3WORD(Memory.C4RAM + 0x1f86, tmp);\n\t\t\t\t\ttmp = SAR((int32) READ_WORD(Memory.C4RAM + 0x1f83) * C4SinTable[READ_WORD(Memory.C4RAM + 0x1f80) & 0x1ff] * 2, 8);\n\t\t\t\t\tWRITE_3WORD(Memory.C4RAM + 0x1f89, tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 0x15: // Pythagorean\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"15 Pythagorean!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 2)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 02 for command 15 %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tC41FXVal = READ_WORD(Memory.C4RAM + 0x1f80);\n\t\t\t\t\tC41FYVal = READ_WORD(Memory.C4RAM + 0x1f83);\n\t\t\t\t\t//C4Op15(); // optimized to:\n\t\t\t\t\tC41FDist = (int16) sqrt((double) C41FXVal * C41FXVal + (double) C41FYVal * C41FYVal);\n\t\t\t\t\tWRITE_WORD(Memory.C4RAM + 0x1f80, C41FDist);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x1f: // atan\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"1f atan!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 2)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 02 for command 1f %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tC41FXVal = READ_WORD(Memory.C4RAM + 0x1f80);\n\t\t\t\t\tC41FYVal = READ_WORD(Memory.C4RAM + 0x1f83);\n\t\t\t\t\tC4Op1F();\n\t\t\t\t\tWRITE_WORD(Memory.C4RAM + 0x1f86, C41FAngleRes);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x22: // Trapezoid\n\t\t\t\t{\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"22 Trapezoid!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 2)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 02 for command 22 %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tint16\tangle1 = READ_WORD(Memory.C4RAM + 0x1f8c) & 0x1ff;\n\t\t\t\t\tint16\tangle2 = READ_WORD(Memory.C4RAM + 0x1f8f) & 0x1ff;\n\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tif (C4CosTable[angle1] == 0)\n\t\t\t\t\t\tfprintf(stderr, \"22 Trapezoid: Invalid tangent! angle1=%d\\n\", angle1);\n\t\t\t\t\tif (C4CosTable[angle2] == 0)\n\t\t\t\t\t\tfprintf(stderr, \"22 Trapezoid: Invalid tangent! angle2=%d\\n\", angle2);\n\t\t\t\t#endif\n\n\t\t\t\t\tint32\ttan1 = (C4CosTable[angle1] != 0) ? ((((int32) C4SinTable[angle1]) << 16) / C4CosTable[angle1]) : 0x80000000;\n\t\t\t\t\tint32\ttan2 = (C4CosTable[angle2] != 0) ? ((((int32) C4SinTable[angle2]) << 16) / C4CosTable[angle2]) : 0x80000000;\n\n\t\t\t\t\tint16\ty = READ_WORD(Memory.C4RAM + 0x1f83) - READ_WORD(Memory.C4RAM + 0x1f89);\n\t\t\t\t\tint16\tleft, right;\n\n\t\t\t\t\tfor (int j = 0; j < 225; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (y >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tleft  = SAR((int32) tan1 * y, 16) - READ_WORD(Memory.C4RAM + 0x1f80) + READ_WORD(Memory.C4RAM + 0x1f86);\n\t\t\t\t\t\t\tright = SAR((int32) tan2 * y, 16) - READ_WORD(Memory.C4RAM + 0x1f80) + READ_WORD(Memory.C4RAM + 0x1f86) + READ_WORD(Memory.C4RAM + 0x1f93);\n\n\t\t\t\t\t\t\tif (left < 0 && right < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tleft  = 1;\n\t\t\t\t\t\t\t\tright = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif (left  < 0)\n\t\t\t\t\t\t\t\tleft  = 0;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif (right < 0)\n\t\t\t\t\t\t\t\tright = 0;\n\n\t\t\t\t\t\t\tif (left > 255 && right > 255)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tleft  = 255;\n\t\t\t\t\t\t\t\tright = 254;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif (left  > 255)\n\t\t\t\t\t\t\t\tleft  = 255;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif (right > 255)\n\t\t\t\t\t\t\t\tright = 255;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tleft  = 1;\n\t\t\t\t\t\t\tright = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tMemory.C4RAM[j + 0x800] = (uint8) left;\n\t\t\t\t\t\tMemory.C4RAM[j + 0x900] = (uint8) right;\n\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 0x25: // Multiply\n\t\t\t\t{\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"25 Multiply!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 2)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 02 for command 25 %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tint32\tfoo = READ_3WORD(Memory.C4RAM + 0x1f80);\n\t\t\t\t\tint32\tbar = READ_3WORD(Memory.C4RAM + 0x1f83);\n\t\t\t\t\tfoo *= bar;\n\t\t\t\t\tWRITE_3WORD(Memory.C4RAM + 0x1f80, foo);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 0x2d: // Transform Coords\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"2d Transform Coords!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 2)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 02 for command 2d %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t\tif (READ_3WORD(Memory.C4RAM + 0x1f8f) & 0xff00ff)\n\t\t\t\t\t\tprintf(\"2d transform coords: Unexpected value in $7f8f: %06x\\n\", READ_3WORD(Memory.C4RAM + 0x1f8f));\n\t\t\t\t\tif (READ_3WORD(Memory.C4RAM + 0x1f8c) != 0x001000)\n\t\t\t\t\t\tprintf(\"0d transform coords: Unexpected value in $7f8c: %06x\\n\", READ_3WORD(Memory.C4RAM + 0x1f8c));\n\t\t\t\t#endif\n\t\t\t\t\tC4WFXVal  = READ_WORD(Memory.C4RAM + 0x1f81);\n\t\t\t\t\tC4WFYVal  = READ_WORD(Memory.C4RAM + 0x1f84);\n\t\t\t\t\tC4WFZVal  = READ_WORD(Memory.C4RAM + 0x1f87);\n\t\t\t\t\tC4WFX2Val = Memory.C4RAM[0x1f89];\n\t\t\t\t\tC4WFY2Val = Memory.C4RAM[0x1f8a];\n\t\t\t\t\tC4WFDist  = Memory.C4RAM[0x1f8b];\n\t\t\t\t\tC4WFScale = READ_WORD(Memory.C4RAM + 0x1f90);\n\t\t\t\t\tC4TransfWireFrame2();\n\t\t\t\t\tWRITE_WORD(Memory.C4RAM + 0x1f80, C4WFXVal);\n\t\t\t\t\tWRITE_WORD(Memory.C4RAM + 0x1f83, C4WFYVal);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x40: // Sum\n\t\t\t\t{\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"40 Sum!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 0x0e)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 0e for command 40 %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tuint16\tsum = 0;\n\t\t\t\t\tfor (int i = 0; i < 0x800; sum += Memory.C4RAM[i++]) ;\n\t\t\t\t\tWRITE_WORD(Memory.C4RAM + 0x1f80, sum);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 0x54: // Square\n\t\t\t\t{\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"54 Square!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 0x0e)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 0e for command 54 %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tint64 a = (int64)READ_3WORD(Memory.C4RAM + 0x1f80);\n\t\t\t\t\ta |= 0xffffffffff000000 * ((a >> 23) & 1);\n\t\t\t\t\t//printf(\"%08X%08X\\n\", (uint32) (a>>32), (uint32) (a&0xFFFFFFFF));\n\t\t\t\t\ta *= a;\n\t\t\t\t\t//printf(\"%08X%08X\\n\", (uint32) (a>>32), (uint32) (a&0xFFFFFFFF));\n\t\t\t\t\tWRITE_3WORD(Memory.C4RAM + 0x1f83, a);\n\t\t\t\t\tWRITE_3WORD(Memory.C4RAM + 0x1f86, (a >> 24));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 0x5c: // Immediate Reg\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"5c Immediate Reg!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 0x0e)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 0e for command 5c %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tfor (int i = 0; i < 12 * 4; i++)\n\t\t\t\t\t\tMemory.C4RAM[i] = C4TestPattern[i];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x89: // Immediate ROM\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"89 Immediate ROM!\\n\");\n\t\t\t\t\tif (Memory.C4RAM[0x1f4d] != 0x0e)\n\t\t\t\t\t\tprintf(\"$7f4d=%02x, expected 0e for command 89 %02x\\n\", Memory.C4RAM[0x1f4d], Memory.C4RAM[0x1f4d]);\n\t\t\t\t#endif\n\t\t\t\t\tMemory.C4RAM[0x1f80] = 0x36;\n\t\t\t\t\tMemory.C4RAM[0x1f81] = 0x43;\n\t\t\t\t\tMemory.C4RAM[0x1f82] = 0x05;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tprintf(\"Unknown C4 command (%02x)\\n\", byte);\n\t\t\t\t#endif\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\tif (Address == 0x7f47)\n\t{\n\t#ifdef DEBUGGER\n\t\t//printf(\"C4 load memory %06x => %04x, %04x bytes\\n\", READ_3WORD(Memory.C4RAM + 0x1f40), READ_WORD(Memory.C4RAM + 0x1f45), READ_WORD(Memory.C4RAM + 0x1f43));\n\t\tif (byte != 0)\n\t\t\tprintf(\"C4 load: non-0 written to $7f47! Wrote %02x\\n\", byte);\n\t\tif (READ_WORD(Memory.C4RAM + 0x1f45) < 0x6000 || (READ_WORD(Memory.C4RAM + 0x1f45) + READ_WORD(Memory.C4RAM + 0x1f43)) > 0x6c00)\n\t\t\tprintf(\"C4 load: Dest unusual! It's %04x\\n\", READ_WORD(Memory.C4RAM + 0x1f45));\n\t#endif\n\t\tmemmove(Memory.C4RAM + (READ_WORD(Memory.C4RAM + 0x1f45) & 0x1fff), C4GetMemPointer(READ_3WORD(Memory.C4RAM + 0x1f40)), READ_WORD(Memory.C4RAM + 0x1f43));\n\t}\n}\n"
        },
        {
          "name": "cheats.cpp",
          "type": "blob",
          "size": 7.3642578125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include <ctype.h>\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"cheats.h\"\n\n#define WRAM_BITS\tALL_BITS\n#define SRAM_BITS\tALL_BITS + (0x20000 >> 5)\n#define IRAM_BITS\tALL_BITS + (0x30000 >> 5)\n\n#define BIT_CLEAR(a, v)\t(a)[(v) >> 5] &= ~(1 << ((v) & 31))\n\n#define TEST_BIT(a, v)\t((a)[(v) >> 5] & (1 << ((v) & 31)))\n\n#define _S9XCHTC(c, a, b) \\\n\t((c) == S9X_LESS_THAN             ? (a) <  (b) : \\\n\t (c) == S9X_GREATER_THAN          ? (a) >  (b) : \\\n\t (c) == S9X_LESS_THAN_OR_EQUAL    ? (a) <= (b) : \\\n\t (c) == S9X_GREATER_THAN_OR_EQUAL ? (a) >= (b) : \\\n\t (c) == S9X_EQUAL                 ? (a) == (b) : \\\n\t                                    (a) != (b))\n\n#define _S9XCHTD(s, m, o) \\\n\t((s) == S9X_8_BITS  ? ((uint8)   (*((m) + (o)))) : \\\n\t (s) == S9X_16_BITS ? ((uint16)  (*((m) + (o)) + (*((m) + (o) + 1) << 8))) : \\\n\t (s) == S9X_24_BITS ? ((uint32)  (*((m) + (o)) + (*((m) + (o) + 1) << 8) + (*((m) + (o) + 2) << 16))) : \\\n\t                      ((uint32)  (*((m) + (o)) + (*((m) + (o) + 1) << 8) + (*((m) + (o) + 2) << 16) + (*((m) + (o) + 3) << 24))))\n\n#define _S9XCHTDS(s, m, o) \\\n\t((s) == S9X_8_BITS  ?  ((int8)   (*((m) + (o)))) : \\\n\t (s) == S9X_16_BITS ?  ((int16)  (*((m) + (o)) + (*((m) + (o) + 1) << 8))) : \\\n\t (s) == S9X_24_BITS ? (((int32) ((*((m) + (o)) + (*((m) + (o) + 1) << 8) + (*((m) + (o) + 2) << 16)) << 8)) >> 8): \\\n                           ((int32)  (*((m) + (o)) + (*((m) + (o) + 1) << 8) + (*((m) + (o) + 2) << 16) + (*((m) + (o) + 3) << 24))))\n\nvoid S9xStartCheatSearch (SCheatData *d)\n{\n\tmemmove(d->CWRAM, d->RAM, 0x20000);\n\tmemmove(d->CSRAM, d->SRAM, 0x80000);\n\tmemmove(d->CIRAM, &d->FillRAM[0x3000], 0x2000);\n\tmemset((char *) d->ALL_BITS, 0xff, 0x32000 >> 3);\n}\n\nvoid S9xSearchForChange (SCheatData *d, S9xCheatComparisonType cmp, S9xCheatDataSize size, bool8 is_signed, bool8 update)\n{\n\tint\tl, i;\n\n\tswitch (size)\n\t{\n\t\tcase S9X_8_BITS:\tl = 0; break;\n\t\tcase S9X_16_BITS:\tl = 1; break;\n\t\tcase S9X_24_BITS:\tl = 2; break;\n\t\tdefault:\n\t\tcase S9X_32_BITS:\tl = 3; break;\n\t}\n\n\tif (is_signed)\n\t{\n\t\tfor (i = 0; i < 0x20000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->WRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTDS(size, d->RAM, i), _S9XCHTDS(size, d->CWRAM, i)))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CWRAM[i] = d->RAM[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->WRAM_BITS, i);\n\t\t}\n\n\t\tfor (i = 0; i < 0x10000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->SRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTDS(size, d->SRAM, i), _S9XCHTDS(size, d->CSRAM, i)))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CSRAM[i] = d->SRAM[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->SRAM_BITS, i);\n\t\t}\n\n\t\tfor (i = 0; i < 0x2000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->IRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTDS(size, d->FillRAM + 0x3000, i), _S9XCHTDS(size, d->CIRAM, i)))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CIRAM[i] = d->FillRAM[i + 0x3000];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->IRAM_BITS, i);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < 0x20000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->WRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTD(size, d->RAM, i), _S9XCHTD(size, d->CWRAM, i)))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CWRAM[i] = d->RAM[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->WRAM_BITS, i);\n\t\t}\n\n\t\tfor (i = 0; i < 0x10000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->SRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTD(size, d->SRAM, i), _S9XCHTD(size, d->CSRAM, i)))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CSRAM[i] = d->SRAM[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->SRAM_BITS, i);\n\t\t}\n\n\t\tfor (i = 0; i < 0x2000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->IRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTD(size, d->FillRAM + 0x3000, i), _S9XCHTD(size, d->CIRAM, i)))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CIRAM[i] = d->FillRAM[i + 0x3000];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->IRAM_BITS, i);\n\t\t}\n\t}\n\n\tfor (i = 0x20000 - l; i < 0x20000; i++)\n\t\tBIT_CLEAR(d->WRAM_BITS, i);\n\n\tfor (i = 0x10000 - l; i < 0x10000; i++)\n\t\tBIT_CLEAR(d->SRAM_BITS, i);\n}\n\nvoid S9xSearchForValue (SCheatData *d, S9xCheatComparisonType cmp, S9xCheatDataSize size, uint32 value, bool8 is_signed, bool8 update)\n{\n\tint l, i;\n\n\tswitch (size)\n\t{\n\t\tcase S9X_8_BITS:\tl = 0; break;\n\t\tcase S9X_16_BITS:\tl = 1; break;\n\t\tcase S9X_24_BITS:\tl = 2; break;\n\t\tdefault:\n\t\tcase S9X_32_BITS:\tl = 3; break;\n\t}\n\n\tif (is_signed)\n\t{\n\t\tfor (i = 0; i < 0x20000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->WRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTDS(size, d->RAM, i), (int32) value))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CWRAM[i] = d->RAM[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->WRAM_BITS, i);\n\t\t}\n\n\t\tfor (i = 0; i < 0x10000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->SRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTDS(size, d->SRAM, i), (int32) value))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CSRAM[i] = d->SRAM[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->SRAM_BITS, i);\n\t\t}\n\n\t\tfor (i = 0; i < 0x2000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->IRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTDS(size, d->FillRAM + 0x3000, i), (int32) value))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CIRAM[i] = d->FillRAM[i + 0x3000];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->IRAM_BITS, i);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < 0x20000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->WRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTD(size, d->RAM, i), value))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CWRAM[i] = d->RAM[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->WRAM_BITS, i);\n\t\t}\n\n\t\tfor (i = 0; i < 0x10000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->SRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTD(size, d->SRAM, i), value))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CSRAM[i] = d->SRAM[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->SRAM_BITS, i);\n\t\t}\n\n\t\tfor (i = 0; i < 0x2000 - l; i++)\n\t\t{\n\t\t\tif (TEST_BIT(d->IRAM_BITS, i) && _S9XCHTC(cmp, _S9XCHTD(size, d->FillRAM + 0x3000, i), value))\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t\td->CIRAM[i] = d->FillRAM[i + 0x3000];\n\t\t\t}\n\t\t\telse\n\t\t\t\tBIT_CLEAR(d->IRAM_BITS, i);\n\t\t}\n\t}\n\n\tfor (i = 0x20000 - l; i < 0x20000; i++)\n\t\tBIT_CLEAR(d->WRAM_BITS, i);\n\n\tfor (i = 0x10000 - l; i < 0x10000; i++)\n\t\tBIT_CLEAR(d->SRAM_BITS, i);\n}\n\nvoid S9xSearchForAddress (SCheatData *d, S9xCheatComparisonType cmp, S9xCheatDataSize size, uint32 value, bool8 update)\n{\n\tint\tl, i;\n\n\tswitch (size)\n\t{\n\t\tcase S9X_8_BITS:\tl = 0; break;\n\t\tcase S9X_16_BITS:\tl = 1; break;\n\t\tcase S9X_24_BITS:\tl = 2; break;\n\t\tdefault:\n\t\tcase S9X_32_BITS:\tl = 3; break;\n\t}\n\n\tfor (i = 0; i < 0x20000 - l; i++)\n\t{\n\t\tif (TEST_BIT(d->WRAM_BITS, i) && _S9XCHTC(cmp, i, (int32) value))\n\t\t{\n\t\t\tif (update)\n\t\t\t\td->CWRAM[i] = d->RAM[i];\n\t\t}\n\t\telse\n\t\t\tBIT_CLEAR(d->WRAM_BITS, i);\n\t}\n\n\tfor (i = 0; i < 0x10000 - l; i++)\n\t{\n\t\tif (TEST_BIT(d->SRAM_BITS, i) && _S9XCHTC(cmp, i + 0x20000, (int32) value))\n\t\t{\n\t\t\tif (update)\n\t\t\t\td->CSRAM[i] = d->SRAM[i];\n\t\t}\n\t\telse\n\t\t\tBIT_CLEAR(d->SRAM_BITS, i);\n\t}\n\n\tfor (i = 0; i < 0x2000 - l; i++)\n\t{\n\t\tif (TEST_BIT(d->IRAM_BITS, i) && _S9XCHTC(cmp, i + 0x30000, (int32) value))\n\t\t{\n\t\t\tif (update)\n\t\t\t\td->CIRAM[i] = d->FillRAM[i + 0x3000];\n\t\t}\n\t\telse\n\t\t\tBIT_CLEAR(d->IRAM_BITS, i);\n\t}\n\n\tfor (i = 0x20000 - l; i < 0x20000; i++)\n\t\tBIT_CLEAR(d->WRAM_BITS, i);\n\n\tfor (i = 0x10000 - l; i < 0x10000; i++)\n\t\tBIT_CLEAR(d->SRAM_BITS, i);\n}\n\nvoid S9xOutputCheatSearchResults (SCheatData *d)\n{\n\tint\ti;\n\n\tfor (i = 0; i < 0x20000; i++)\n\t{\n\t\tif (TEST_BIT(d->WRAM_BITS, i))\n\t\t\tprintf(\"WRAM: %05x: %02x\\n\", i, d->RAM[i]);\n\t}\n\n\tfor (i = 0; i < 0x10000; i++)\n\t{\n\t\tif (TEST_BIT(d->SRAM_BITS, i))\n\t\t\tprintf(\"SRAM: %04x: %02x\\n\", i, d->SRAM[i]);\n\t}\n\n\tfor (i = 0; i < 0x2000; i++)\n\t{\n\t\tif (TEST_BIT(d->IRAM_BITS, i))\n\t\t\tprintf(\"IRAM: %05x: %02x\\n\", i, d->FillRAM[i + 0x3000]);\n\t}\n}\n"
        },
        {
          "name": "cheats.h",
          "type": "blob",
          "size": 2.5546875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _CHEATS_H_\n#define _CHEATS_H_\n\n#include <cstdint>\n#include <string>\n#include <vector>\n\nusing bool8 = uint8_t;\n\nstruct SCheat\n{\n\tuint32_t\taddress;\n\tuint8_t\tbyte;\n\tuint8_t\tsaved_byte;\n\tbool8\tconditional;\n\tbool8\tcond_true;\n\tuint8_t\tcond_byte;\n\tbool8\tenabled;\n};\n\nstruct SCheatGroup\n{\n\tstd::string name;\n\tbool8 enabled;\n\tstd::vector<struct SCheat> cheat;\n};\n\nstruct SCheatData\n{\n\tstd::vector<struct SCheatGroup> group;\n\tbool8\tenabled;\n\tuint8_t\tCWRAM[0x20000];\n\tuint8_t\tCSRAM[0x80000];\n\tuint8_t\tCIRAM[0x2000];\n\tuint8_t\t*RAM;\n\tuint8_t\t*FillRAM;\n\tuint8_t\t*SRAM;\n\tuint32_t\tALL_BITS[0x32000 >> 5];\n\tuint8_t\tCWatchRAM[0x32000];\n};\n\nstruct Watch\n{\n\tbool\ton;\n\tint\t\tsize;\n\tint\t\tformat;\n\tuint32_t\taddress;\n\tchar\tbuf[12];\n\tchar\tdesc[32];\n};\n\ntypedef enum\n{\n\tS9X_LESS_THAN,\n\tS9X_GREATER_THAN,\n\tS9X_LESS_THAN_OR_EQUAL,\n\tS9X_GREATER_THAN_OR_EQUAL,\n\tS9X_EQUAL,\n\tS9X_NOT_EQUAL\n}\tS9xCheatComparisonType;\n\ntypedef enum\n{\n\tS9X_8_BITS,\n\tS9X_16_BITS,\n\tS9X_24_BITS,\n\tS9X_32_BITS\n}\tS9xCheatDataSize;\n\nextern SCheatData\tCheat;\nextern Watch\t\twatches[16];\n\nint S9xAddCheatGroup(const std::string &name, const std::string &cheat);\nint S9xModifyCheatGroup(uint32_t index, const std::string &name, const std::string &cheat);\nvoid S9xEnableCheatGroup(uint32_t index);\nvoid S9xDisableCheatGroup(uint32_t index);\nvoid S9xDeleteCheats(void);\nstd::string S9xCheatGroupToText(const SCheatGroup &g);\nstd::string S9xCheatGroupToText(uint32_t index);\nvoid S9xDeleteCheatGroup(uint32_t index);\nbool8 S9xLoadCheatFile(const std::string &filename);\nbool8 S9xSaveCheatFile(const std::string &filename);\nvoid S9xUpdateCheatsInMemory(void);\nint S9xImportCheatsFromDatabase(const std::string &filename);\nvoid S9xCheatsDisable(void);\nvoid S9xCheatsEnable(void);\nstd::string S9xCheatValidate(const std::string &cheat);\n\nvoid S9xInitCheatData (void);\nvoid S9xInitWatchedAddress (void);\nvoid S9xStartCheatSearch (SCheatData *);\nvoid S9xSearchForChange (SCheatData *, S9xCheatComparisonType, S9xCheatDataSize, bool8, bool8);\nvoid S9xSearchForValue (SCheatData *, S9xCheatComparisonType, S9xCheatDataSize, uint32_t, bool8, bool8);\nvoid S9xSearchForAddress (SCheatData *, S9xCheatComparisonType, S9xCheatDataSize, uint32_t, bool8);\nvoid S9xOutputCheatSearchResults (SCheatData *);\n\n#endif\n"
        },
        {
          "name": "cheats2.cpp",
          "type": "blob",
          "size": 17.333984375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"bml.h\"\n#include \"cheats.h\"\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include <cassert>\n\nstatic inline uint8 S9xGetByteFree(uint32 Address)\n{\n    int block = (Address & 0xffffff) >> MEMMAP_SHIFT;\n    uint8 *GetAddress = Memory.Map[block];\n    uint8 byte;\n\n    if (GetAddress >= (uint8 *)CMemory::MAP_LAST)\n    {\n        byte = *(GetAddress + (Address & 0xffff));\n        return (byte);\n    }\n\n    switch ((pint)GetAddress)\n    {\n    case CMemory::MAP_CPU:\n        byte = S9xGetCPU(Address & 0xffff);\n        return (byte);\n\n    case CMemory::MAP_PPU:\n        if (CPU.InDMAorHDMA && (Address & 0xff00) == 0x2100)\n            return (OpenBus);\n\n        byte = S9xGetPPU(Address & 0xffff);\n        return (byte);\n\n    case CMemory::MAP_LOROM_SRAM:\n    case CMemory::MAP_SA1RAM:\n        // Address & 0x7fff   : offset into bank\n        // Address & 0xff0000 : bank\n        // bank >> 1 | offset : SRAM address, unbound\n        // unbound & SRAMMask : SRAM offset\n        byte = *(Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask));\n        return (byte);\n\n    case CMemory::MAP_LOROM_SRAM_B:\n        byte = *(Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB));\n        return (byte);\n\n    case CMemory::MAP_HIROM_SRAM:\n    case CMemory::MAP_RONLY_SRAM:\n        byte = *(Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0x1f0000) >> 3)) & Memory.SRAMMask));\n        return (byte);\n\n    case CMemory::MAP_BWRAM:\n        byte = *(Memory.BWRAM + ((Address & 0x7fff) - 0x6000));\n        return (byte);\n\n    case CMemory::MAP_DSP:\n        byte = S9xGetDSP(Address & 0xffff);\n        return (byte);\n\n    case CMemory::MAP_SPC7110_ROM:\n        byte = S9xGetSPC7110Byte(Address);\n        return (byte);\n\n    case CMemory::MAP_SPC7110_DRAM:\n        byte = S9xGetSPC7110(0x4800);\n        return (byte);\n\n    case CMemory::MAP_C4:\n        byte = S9xGetC4(Address & 0xffff);\n        return (byte);\n\n    case CMemory::MAP_OBC_RAM:\n        byte = S9xGetOBC1(Address & 0xffff);\n        return (byte);\n\n    case CMemory::MAP_SETA_DSP:\n        byte = S9xGetSetaDSP(Address);\n        return (byte);\n\n    case CMemory::MAP_SETA_RISC:\n        byte = S9xGetST018(Address);\n        return (byte);\n\n    case CMemory::MAP_BSX:\n        byte = S9xGetBSX(Address);\n        return (byte);\n\n    case CMemory::MAP_NONE:\n    default:\n        byte = OpenBus;\n        return (byte);\n    }\n}\n\nstatic inline void S9xSetByteFree(uint8 Byte, uint32 Address)\n{\n    int block = (Address & 0xffffff) >> MEMMAP_SHIFT;\n    uint8 *SetAddress = Memory.Map[block];\n\n    if (SetAddress >= (uint8 *)CMemory::MAP_LAST)\n    {\n        *(SetAddress + (Address & 0xffff)) = Byte;\n        return;\n    }\n\n    switch ((pint)SetAddress)\n    {\n    case CMemory::MAP_CPU:\n        S9xSetCPU(Byte, Address & 0xffff);\n        return;\n\n    case CMemory::MAP_PPU:\n        if (CPU.InDMAorHDMA && (Address & 0xff00) == 0x2100)\n            return;\n\n        S9xSetPPU(Byte, Address & 0xffff);\n        return;\n\n    case CMemory::MAP_LOROM_SRAM:\n        if (Memory.SRAMMask)\n        {\n            *(Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask)) = Byte;\n            CPU.SRAMModified = TRUE;\n        }\n\n        return;\n\n    case CMemory::MAP_LOROM_SRAM_B:\n        if (Multi.sramMaskB)\n        {\n            *(Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB)) = Byte;\n            CPU.SRAMModified = TRUE;\n        }\n\n        return;\n\n    case CMemory::MAP_HIROM_SRAM:\n        if (Memory.SRAMMask)\n        {\n            *(Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0x1f0000) >> 3)) & Memory.SRAMMask)) = Byte;\n            CPU.SRAMModified = TRUE;\n        }\n        return;\n\n    case CMemory::MAP_BWRAM:\n        *(Memory.BWRAM + ((Address & 0x7fff) - 0x6000)) = Byte;\n        CPU.SRAMModified = TRUE;\n        return;\n\n    case CMemory::MAP_SA1RAM:\n        *(Memory.SRAM + (Address & 0xffff)) = Byte;\n        return;\n\n    case CMemory::MAP_DSP:\n        S9xSetDSP(Byte, Address & 0xffff);\n        return;\n\n    case CMemory::MAP_C4:\n        S9xSetC4(Byte, Address & 0xffff);\n        return;\n\n    case CMemory::MAP_OBC_RAM:\n        S9xSetOBC1(Byte, Address & 0xffff);\n        return;\n\n    case CMemory::MAP_SETA_DSP:\n        S9xSetSetaDSP(Byte, Address);\n        return;\n\n    case CMemory::MAP_SETA_RISC:\n        S9xSetST018(Byte, Address);\n        return;\n\n    case CMemory::MAP_BSX:\n        S9xSetBSX(Byte, Address);\n        return;\n\n    case CMemory::MAP_NONE:\n    default:\n        return;\n    }\n}\n\nvoid S9xInitWatchedAddress(void)\n{\n    for (unsigned int i = 0; i < sizeof(watches) / sizeof(watches[0]); i++)\n        watches[i].on = false;\n}\n\nvoid S9xInitCheatData(void)\n{\n    Cheat.RAM = Memory.RAM;\n    Cheat.SRAM = Memory.SRAM;\n    Cheat.FillRAM = Memory.FillRAM;\n}\n\nstatic inline std::string trim(const std::string &&string)\n{\n    auto start = string.find_first_not_of(\" \\t\\n\\r\");\n    auto end   = string.find_last_not_of(\" \\t\\n\\r\");\n    if (start != std::string::npos && end != std::string::npos)\n        return string.substr(start, end - start + 1);\n    return \"\";\n}\n\nvoid S9xUpdateCheatInMemory(SCheat &c)\n{\n    uint8 byte;\n\n    if (!c.enabled)\n        return;\n\n    byte = S9xGetByteFree(c.address);\n\n    if (byte != c.byte)\n    {\n        /* The game wrote a different byte to the address, update saved_byte */\n        c.saved_byte = byte;\n\n        if (c.conditional)\n        {\n            if (c.saved_byte != c.cond_byte && c.cond_true)\n            {\n                /* Condition is now false, let the byte stand */\n                c.cond_true = false;\n            }\n            else if (c.saved_byte == c.cond_byte && !c.cond_true)\n            {\n                c.cond_true = true;\n                S9xSetByteFree(c.byte, c.address);\n            }\n        }\n        else\n            S9xSetByteFree(c.byte, c.address);\n    }\n    else if (c.conditional)\n    {\n        if (byte == c.cond_byte)\n        {\n            c.cond_true = true;\n            c.saved_byte = byte;\n            S9xSetByteFree(c.byte, c.address);\n        }\n    }\n}\n\nvoid S9xDisableCheat(SCheat &c)\n{\n    if (!c.enabled)\n        return;\n\n    if (!Cheat.enabled)\n    {\n        c.enabled = false;\n        return;\n    }\n\n    /* Make sure we restore the up-to-date written byte */\n    S9xUpdateCheatInMemory(c);\n    c.enabled = false;\n\n    if (c.conditional && !c.cond_true)\n        return;\n\n    S9xSetByteFree (c.saved_byte, c.address);\n    c.cond_true = false;\n}\n\nvoid S9xDeleteCheatGroup(uint32 g)\n{\n    unsigned int i;\n\n    if (g >= Cheat.group.size())\n        return;\n\n    for (i = 0; i < Cheat.group[g].cheat.size(); i++)\n    {\n        S9xDisableCheat(Cheat.group[g].cheat[i]);\n    }\n\n    Cheat.group.erase(Cheat.group.begin() + g);\n}\n\nvoid S9xDeleteCheats(void)\n{\n    for (size_t i = 0; i < Cheat.group.size(); i++)\n    {\n        S9xDisableCheatGroup(i);\n    }\n\n    Cheat.group.clear();\n}\n\nvoid S9xEnableCheat(SCheat &c)\n{\n    uint8 byte;\n\n    if (c.enabled)\n        return;\n\n    c.enabled = true;\n\n    if (!Cheat.enabled)\n        return;\n\n    byte = S9xGetByteFree(c.address);\n\n    if (c.conditional)\n    {\n        if (byte != c.cond_byte)\n            return;\n\n        c.cond_true = true;\n    }\n\n    c.saved_byte = byte;\n    S9xSetByteFree(c.byte, c.address);\n}\n\nvoid S9xEnableCheatGroup(uint32 num)\n{\n    assert(num < Cheat.group.size());\n\n    for (auto &c : Cheat.group[num].cheat)\n        S9xEnableCheat(c);\n\n    Cheat.group[num].enabled = true;\n}\n\nvoid S9xDisableCheatGroup(uint32 num)\n{\n    for (auto &c : Cheat.group[num].cheat)\n        S9xDisableCheat(c);\n\n    Cheat.group[num].enabled = false;\n}\n\nstatic bool is_all_hex(const std::string &code)\n{\n    for (const auto &c : code)\n    {\n        if ((c < '0' || c > '9') &&\n            (c < 'a' || c > 'f') &&\n            (c < 'A' || c > 'F'))\n            return false;\n    }\n\n    return true;\n}\n\nbool S9xProActionReplayToRaw(const std::string &code, uint32 &address, uint8 &byte)\n{\n    if (code.length() != 8 || !is_all_hex(code))\n        return false;\n\n    uint32 data = std::strtoul(code.c_str(), nullptr, 16);\n\n    address = data >> 8;\n    byte = (uint8)data;\n\n    return true;\n}\n\nbool S9xGameGenieToRaw(const std::string &code, uint32 &address, uint8 &byte)\n{\n    if (code.length() != 9)\n        return false;\n    if (code[4] != '-')\n        return false;\n    if (!is_all_hex(code.substr(0, 4)))\n        return false;\n    if (!is_all_hex(code.substr(5, 4)))\n        return false;\n\n    auto new_code = code.substr(0, 4) + code.substr(5, 4);\n\n    static const char *real_hex = \"0123456789ABCDEF\";\n    static const char *genie_hex = \"DF4709156BC8A23E\";\n\n    for (auto &c : new_code)\n    {\n        c = toupper(c);\n\n        for (int i = 0; i < 16; i++)\n        {\n            if (genie_hex[i] == c)\n            {\n                c = real_hex[i];\n                break;\n            }\n        }\n    }\n\n    uint32 data = strtoul(new_code.c_str(), nullptr, 16);\n    byte = (uint8)(data >> 24);\n    address = data & 0xffffff;\n    address = ((address & 0x003c00) << 10) +\n              ((address & 0x00003c) << 14) +\n              ((address & 0xf00000) >> 8) +\n              ((address & 0x000003) << 10) +\n              ((address & 0x00c000) >> 6) +\n              ((address & 0x0f0000) >> 12) +\n              ((address & 0x0003c0) >> 6);\n\n    return true;\n}\n\nSCheat S9xTextToCheat(const std::string &text)\n{\n    SCheat c;\n    unsigned int byte = 0;\n    unsigned int cond_byte = 0;\n\n    c.enabled     = false;\n    c.conditional = false;\n\n    if (S9xGameGenieToRaw(text, c.address, c.byte))\n    {\n        byte = c.byte;\n    }\n    else if (S9xProActionReplayToRaw(text, c.address, c.byte))\n    {\n        byte = c.byte;\n    }\n    else if (sscanf(text.c_str(), \"%x = %x ? %x\", &c.address, &cond_byte, &byte) == 3)\n    {\n        c.conditional = true;\n    }\n    else if (sscanf(text.c_str(), \"%x = %x\", &c.address, &byte) == 2)\n    {\n    }\n    else if (sscanf(text.c_str(), \"%x / %x / %x\", &c.address, &cond_byte, &byte) == 3)\n    {\n        c.conditional = true;\n    }\n    else if (sscanf(text.c_str(), \"%x : %x\", &c.address, &byte) == 2)\n    {\n    }\n    else if (sscanf(text.c_str(), \"%x / %x\", &c.address, &byte) == 2)\n    {\n    }\n    else\n    {\n        c.address = 0;\n        byte = 0;\n    }\n\n    c.byte = byte;\n    c.cond_byte = cond_byte;\n\n    return c;\n}\n\nstd::vector<std::string> split_string(const std::string &str, unsigned char delim)\n{\n    std::vector<std::string> tokens;\n    size_t pos = 0;\n    size_t index;\n\n    while (pos < str.length())\n    {\n        index = str.find(delim, pos);\n        if (index == std::string::npos)\n        {\n            if (pos < str.length())\n            {\n                tokens.push_back(trim(str.substr(pos)));\n            }\n\n            break;\n        }\n        else if (index > pos)\n        {\n            tokens.push_back(trim(str.substr(pos, index - pos)));\n        }\n\n        pos = index + 1;\n    }\n\n    return tokens;\n}\n\nSCheatGroup S9xCreateCheatGroup(const std::string &name, const std::string &cheat)\n{\n    SCheatGroup g;\n\n    g.name = name;\n    g.enabled = false;\n\n    auto cheats = split_string(cheat, '+');\n    for (const auto &c : cheats)\n    {\n        SCheat new_cheat = S9xTextToCheat(c);\n        if (new_cheat.address)\n            g.cheat.push_back(new_cheat);\n    }\n\n    return g;\n}\n\nint S9xAddCheatGroup(const std::string &name, const std::string &cheat)\n{\n    SCheatGroup g = S9xCreateCheatGroup(name, cheat);\n    if (g.cheat.size() == 0)\n        return -1;\n\n    Cheat.group.push_back(g);\n\n    return Cheat.group.size() - 1;\n}\n\nint S9xModifyCheatGroup(uint32 num, const std::string &name, const std::string &cheat)\n{\n\tif (num >= Cheat.group.size())\n\t\treturn -1;\n\n    bool enabled = Cheat.group[num].enabled;\n    S9xDisableCheatGroup(num);\n\n    Cheat.group[num] = S9xCreateCheatGroup(name, cheat);\n\n    if (enabled)\n        S9xEnableCheatGroup(num);\n\n    return num;\n}\n\nstd::string S9xCheatToText(const SCheat &c)\n{\n    char output[256]{};\n\n    if (c.conditional)\n        sprintf(output, \"%06x=%02x?%02x\", c.address, c.cond_byte, c.byte);\n    else\n        sprintf(output, \"%06x=%02x\", c.address, c.byte);\n\n    return std::string(output);\n}\n\nstd::string S9xCheatGroupToText(const SCheatGroup &g)\n{\n    std::string text = \"\";\n\n    for (size_t i = 0; i < g.cheat.size(); i++)\n    {\n        text += S9xCheatToText(g.cheat[i]);\n        if (i != g.cheat.size() - 1)\n            text += \"+\";\n    }\n\n    return text;\n}\n\nstd::string S9xCheatValidate(const std::string &code_string)\n{\n    SCheatGroup g = S9xCreateCheatGroup(\"temp\", code_string);\n\n    if (g.cheat.size() > 0)\n    {\n        return S9xCheatGroupToText(g);\n    }\n\n    return \"\";\n}\n\nstd::string S9xCheatGroupToText(uint32 num)\n{\n    if (num >= Cheat.group.size())\n        return \"\";\n\n    return S9xCheatGroupToText(Cheat.group[num]);\n}\n\nvoid S9xUpdateCheatsInMemory(void)\n{\n    if (!Cheat.enabled)\n        return;\n\n    for (auto &group : Cheat.group)\n        for (auto &cheat : group.cheat)\n            S9xUpdateCheatInMemory(cheat);\n}\n\nstatic bool S9xCheatIsDuplicate(const std::string &name, const std::string &code)\n{\n    for (size_t i = 0; i < Cheat.group.size(); i++)\n    {\n        if (Cheat.group[i].name == name)\n        {\n            auto code_string = S9xCheatGroupToText(i);\n            auto validated_string = S9xCheatValidate(code);\n\n            if (validated_string == code_string)\n                return true;\n        }\n    }\n\n    return false;\n}\n\nstatic void S9xLoadCheatsFromBMLNode(bml_node &n)\n{\n    for (auto &c : n.child)\n    {\n        if (strcasecmp(c.name.c_str(), \"cheat\"))\n            continue;\n\n        auto subnode = c.find_subnode(\"code\");\n        if (!subnode)\n            continue;\n        std::string code = subnode->data;\n\n        std::string name;\n        subnode = c.find_subnode(\"name\");\n        if (subnode)\n            name = subnode->data;\n\n        bool enable = false;\n        if (c.find_subnode(\"enable\"))\n            enable = true;\n\n        if (S9xCheatIsDuplicate(name, code))\n            continue;\n\n        auto index = S9xAddCheatGroup(name, code);\n        if (enable)\n            S9xEnableCheatGroup(index);\n    }\n\n    return;\n}\n\nstatic bool8 S9xLoadCheatFileClassic(const std::string &filename)\n{\n    FILE *fs;\n    uint8 data[28];\n\n    fs = fopen(filename.c_str(), \"rb\");\n    if (!fs)\n        return (FALSE);\n\n    while (fread(data, 1, 28, fs) == 28)\n    {\n        SCheat c;\n        c.enabled = (data[0] & 4) == 0;\n        c.byte = data[1];\n        c.address = data[2] | (data[3] << 8) | (data[4] << 16);\n\n        std::string name((const char *)&data[8], 20);\n        char code[32]{};\n        sprintf(code, \"%x=%x\", c.address, c.byte);\n        std::string cheat(code);\n        S9xAddCheatGroup(name, cheat);\n\n        if (c.enabled)\n            S9xEnableCheatGroup(Cheat.group.size() - 1);\n    }\n\n    fclose(fs);\n\n    return TRUE;\n}\n\nbool8 S9xLoadCheatFile(const std::string &filename)\n{\n    bml_node bml;\n    if (!bml.parse_file(filename))\n    {\n        return S9xLoadCheatFileClassic(filename);\n    }\n\n    bml_node *n = bml.find_subnode(\"cheat\");\n    if (n)\n    {\n        S9xLoadCheatsFromBMLNode(bml);\n    }\n\n    if (!n)\n    {\n        return S9xLoadCheatFileClassic(filename);\n    }\n\n    return (TRUE);\n}\n\nbool8 S9xSaveCheatFile(const std::string &filename)\n{\n    unsigned int i;\n    FILE *file = NULL;\n\n    if (Cheat.group.size() == 0)\n    {\n        remove(filename.c_str());\n        return TRUE;\n    }\n\n    file = fopen(filename.c_str(), \"w\");\n\n    if (!file)\n        return FALSE;\n\n    for (i = 0; i < Cheat.group.size(); i++)\n    {\n        fprintf(file,\n                \"cheat\\n\"\n                \"  name: %s\\n\"\n                \"  code: %s\\n\"\n                \"%s\\n\",\n                Cheat.group[i].name.c_str(),\n                S9xCheatGroupToText(i).c_str(),\n                Cheat.group[i].enabled ? \"  enable\\n\" : \"\");\n    }\n\n    fclose(file);\n\n    return TRUE;\n}\n\nvoid S9xCheatsDisable(void)\n{\n    unsigned int i;\n\n    if (!Cheat.enabled)\n        return;\n\n    for (i = 0; i < Cheat.group.size(); i++)\n    {\n        if (Cheat.group[i].enabled)\n        {\n            S9xDisableCheatGroup(i);\n            Cheat.group[i].enabled = TRUE;\n        }\n    }\n\n    Cheat.enabled = FALSE;\n}\n\nvoid S9xCheatsEnable(void)\n{\n    unsigned int i;\n\n    if (Cheat.enabled)\n        return;\n\n    Cheat.enabled = TRUE;\n\n    for (i = 0; i < Cheat.group.size(); i++)\n    {\n        if (Cheat.group[i].enabled)\n        {\n            Cheat.group[i].enabled = FALSE;\n            S9xEnableCheatGroup(i);\n        }\n    }\n}\n\nint S9xImportCheatsFromDatabase(const std::string &filename)\n{\n    char sha256_txt[65];\n    char hextable[] = \"0123456789abcdef\";\n    unsigned int i;\n\n    bml_node bml;\n    if (!bml.parse_file(filename))\n        return -1; // No file\n\n    for (i = 0; i < 32; i++)\n    {\n        sha256_txt[i * 2]     = hextable[Memory.ROMSHA256[i] >> 4];\n        sha256_txt[i * 2 + 1] = hextable[Memory.ROMSHA256[i] & 0xf];\n    }\n    sha256_txt[64] = '\\0';\n\n    for (auto &c : bml.child)\n    {\n        if (!strcasecmp(c.name.c_str(), \"cartridge\"))\n        {\n            auto n = c.find_subnode(\"sha256\");\n\n            if (n && !strcasecmp(n->data.c_str(), sha256_txt))\n            {\n                S9xLoadCheatsFromBMLNode(c);\n                return 0;\n            }\n        }\n    }\n\n    return -2; /* No codes */\n}\n"
        },
        {
          "name": "clip.cpp",
          "type": "blob",
          "size": 5.3349609375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n\nstatic uint8\tregion_map[6][6] =\n{\n\t{ 0, 0x01, 0x03, 0x07, 0x0f, 0x1f },\n\t{ 0,    0, 0x02, 0x06, 0x0e, 0x1e },\n\t{ 0,    0,    0, 0x04, 0x0c, 0x1c },\n\t{ 0,    0,    0,    0, 0x08, 0x18 },\n\t{ 0,    0,    0,    0,    0, 0x10 }\n};\n\nstatic inline uint8 CalcWindowMask (int, uint8, uint8);\nstatic inline void StoreWindowRegions (uint8, struct ClipData *, int, int16 *, uint8 *, bool8, bool8 s = FALSE);\n\n\nstatic inline uint8 CalcWindowMask (int i, uint8 W1, uint8 W2)\n{\n\tif (!PPU.ClipWindow1Enable[i])\n\t{\n\t\tif (!PPU.ClipWindow2Enable[i])\n\t\t\treturn (0);\n\t\telse\n\t\t{\n\t\t\tif (!PPU.ClipWindow2Inside[i])\n\t\t\t\treturn (~W2);\n\t\t\treturn (W2);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (!PPU.ClipWindow2Enable[i])\n\t\t{\n\t\t\tif (!PPU.ClipWindow1Inside[i])\n\t\t\t\treturn (~W1);\n\t\t\treturn (W1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!PPU.ClipWindow1Inside[i])\n\t\t\t\tW1 = ~W1;\n\t\t\tif (!PPU.ClipWindow2Inside[i])\n\t\t\t\tW2 = ~W2;\n\n\t\t\tswitch (PPU.ClipWindowOverlapLogic[i])\n\t\t\t{\n\t\t\t\tcase 0: // OR\n\t\t\t\t\treturn (W1 | W2);\n\n\t\t\t\tcase 1: // AND\n\t\t\t\t\treturn (W1 & W2);\n\n\t\t\t\tcase 2: // XOR\n\t\t\t\t\treturn (W1 ^ W2);\n\n\t\t\t\tcase 3: // XNOR\n\t\t\t\t\treturn (~(W1 ^ W2));\n\t\t\t}\n\t\t}\n\t}\n\n\t// Never get here\n\treturn (0);\n}\n\nstatic inline void StoreWindowRegions (uint8 Mask, struct ClipData *Clip, int n_regions, int16 *windows, uint8 *drawing_modes, bool8 sub, bool8 StoreMode0)\n{\n\tint\tct = 0;\n\n\tfor (int j = 0; j < n_regions; j++)\n\t{\n\t\tint\tDrawMode = drawing_modes[j];\n\t\tif (sub)\n\t\t\tDrawMode |= 1;\n\t\tif (Mask & (1 << j))\n\t\t\tDrawMode = 0;\n\n\t\tif (!StoreMode0 && !DrawMode)\n\t\t\tcontinue;\n\n\t\tif (ct > 0 && Clip->Right[ct - 1] == windows[j] && Clip->DrawMode[ct - 1] == DrawMode)\n\t\t\tClip->Right[ct - 1] = windows[j + 1]; // This region borders with and has the same drawing mode as the previous region: merge them.\n\t\telse\n\t\t{\n\t\t\t// Add a new region to the BG\n\t\t\tClip->Left[ct]     = windows[j];\n\t\t\tClip->Right[ct]    = windows[j + 1];\n\t\t\tClip->DrawMode[ct] = DrawMode;\n\t\t\tct++;\n\t\t}\n\t}\n\n\tClip->Count = ct;\n}\n\nvoid S9xComputeClipWindows (void)\n{\n\tint16\twindows[6] = { 0, 256, 256, 256, 256, 256 };\n\tuint8\tdrawing_modes[5] = { 0, 0, 0, 0, 0 };\n\tint\t\tn_regions = 1;\n\tint\t\ti, j;\n\n\t// Calculate window regions. We have at most 5 regions, because we have 6 control points\n\t// (screen edges, window 1 left & right, and window 2 left & right).\n\n\tif (PPU.Window1Left <= PPU.Window1Right)\n\t{\n\t\tif (PPU.Window1Left > 0)\n\t\t{\n\t\t\twindows[2] = 256;\n\t\t\twindows[1] = PPU.Window1Left;\n\t\t\tn_regions = 2;\n\t\t}\n\n\t\tif (PPU.Window1Right < 255)\n\t\t{\n\t\t\twindows[n_regions + 1] = 256;\n\t\t\twindows[n_regions] = PPU.Window1Right + 1;\n\t\t\tn_regions++;\n\t\t}\n\t}\n\n\tif (PPU.Window2Left <= PPU.Window2Right)\n\t{\n\t\tfor (i = 0; i <= n_regions; i++)\n\t\t{\n\t\t\tif (PPU.Window2Left == windows[i])\n\t\t\t\tbreak;\n\n\t\t\tif (PPU.Window2Left <  windows[i])\n\t\t\t{\n\t\t\t\tfor (j = n_regions; j >= i; j--)\n\t\t\t\t\twindows[j + 1] = windows[j];\n\n\t\t\t\twindows[i] = PPU.Window2Left;\n\t\t\t\tn_regions++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (; i <= n_regions; i++)\n\t\t{\n\t\t\tif (PPU.Window2Right + 1 == windows[i])\n\t\t\t\tbreak;\n\n\t\t\tif (PPU.Window2Right + 1 <  windows[i])\n\t\t\t{\n\t\t\t\tfor (j = n_regions; j >= i; j--)\n\t\t\t\t\twindows[j + 1] = windows[j];\n\n\t\t\t\twindows[i] = PPU.Window2Right + 1;\n\t\t\t\tn_regions++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get a bitmap of which regions correspond to each window.\n\n\tuint8\tW1, W2;\n\n\tif (PPU.Window1Left <= PPU.Window1Right)\n\t{\n\t\tfor (i = 0; windows[i] != PPU.Window1Left; i++) ;\n\t\tfor (j = i; windows[j] != PPU.Window1Right + 1; j++) ;\n\t\tW1 = region_map[i][j];\n\t}\n\telse\n\t\tW1 = 0;\n\n\tif (PPU.Window2Left <= PPU.Window2Right)\n\t{\n\t\tfor (i = 0; windows[i] != PPU.Window2Left; i++) ;\n\t\tfor (j = i; windows[j] != PPU.Window2Right + 1; j++) ;\n\t\tW2 = region_map[i][j];\n\t}\n\telse\n\t\tW2 = 0;\n\n\t// Color Window affects the drawing mode for each region.\n\t// Modes are: 3=Draw as normal, 2=clip color (math only), 1=no math (draw only), 0=nothing.\n\n\tuint8\tCW_color = 0, CW_math = 0;\n\tuint8\tCW = CalcWindowMask(5, W1, W2);\n\n\tswitch (Memory.FillRAM[0x2130] & 0xc0)\n\t{\n\t\tcase 0x00:\tCW_color = 0;\t\tbreak;\n\t\tcase 0x40:\tCW_color = ~CW;\t\tbreak;\n\t\tcase 0x80:\tCW_color = CW;\t\tbreak;\n\t\tcase 0xc0:\tCW_color = 0xff;\tbreak;\n\t}\n\n\tswitch (Memory.FillRAM[0x2130] & 0x30)\n\t{\n\t\tcase 0x00:\tCW_math  = 0;\t\tbreak;\n\t\tcase 0x10:\tCW_math  = ~CW;\t\tbreak;\n\t\tcase 0x20:\tCW_math  = CW;\t\tbreak;\n\t\tcase 0x30:\tCW_math  = 0xff;\tbreak;\n\t}\n\n\tfor (i = 0; i < n_regions; i++)\n\t{\n\t\tif (!(CW_color & (1 << i)))\n\t\t\tdrawing_modes[i] |= 1;\n\t\tif (!(CW_math  & (1 << i)))\n\t\t\tdrawing_modes[i] |= 2;\n\t}\n\n\t// Store backdrop clip window (draw everywhere color window allows)\n\n\tStoreWindowRegions(0, &IPPU.Clip[0][5], n_regions, windows, drawing_modes, FALSE, TRUE);\n\tStoreWindowRegions(0, &IPPU.Clip[1][5], n_regions, windows, drawing_modes, TRUE,  TRUE);\n\n\t// Store per-BG and OBJ clip windows\n\n\tfor (j = 0; j < 5; j++)\n\t{\n\t\tuint8\tW = Settings.DisableGraphicWindows ? 0 : CalcWindowMask(j, W1, W2);\n\t\tfor (int sub = 0; sub < 2; sub++)\n\t\t{\n\t\t\tif (Memory.FillRAM[sub + 0x212e] & (1 << j))\n\t\t\t\tStoreWindowRegions(W, &IPPU.Clip[sub][j], n_regions, windows, drawing_modes, sub);\n\t\t\telse\n\t\t\t\tStoreWindowRegions(0, &IPPU.Clip[sub][j], n_regions, windows, drawing_modes, sub);\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "common",
          "type": "tree",
          "content": null
        },
        {
          "name": "conffile.cpp",
          "type": "blob",
          "size": 12.892578125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include <stdio.h>\n#include <time.h>\n#include <string.h>\n#include <string>\n\n#include \"conffile.h\"\n\n#ifdef __WIN32__\n#define snprintf _snprintf // needs ANSI compliant name\n#endif\n\n#define SORT_SECTIONS_BY_SIZE // output\n\nusing namespace std;\n\nbool ConfigFile::defaultAutoAdd = false;\nbool ConfigFile::niceAlignment = false;\nbool ConfigFile::showComments = true;\nbool ConfigFile::alphaSort = true;\nbool ConfigFile::timeSort = false;\nstatic ConfigFile* curConfigFile = NULL; // for section_then_key_less\n\nConfigFile::ConfigFile(void) {\n\tClear();\n}\n\nvoid ConfigFile::Clear(void){\n    data.clear();\n\tsectionSizes.ClearSections();\n\tlinectr = 0;\n}\n\nbool ConfigFile::LoadFile(const char *filename){\n    FSTREAM s;\n    bool ret=false;\n    const char *n, *n2;\n\n    if((s=OPEN_FSTREAM(filename, \"r\"))){\n        n=filename;\n        n2=strrchr(n, '/'); if(n2!=NULL) n=n2+1;\n        n2=strrchr(n, '\\\\'); if(n2!=NULL) n=n2+1;\n\t\tfStream fS(s);\n        LoadFile(&fS, n);\n        CLOSE_FSTREAM(s);\n        ret = true;\n    } else {\n        fprintf(stderr, \"Couldn't open conffile \");\n        perror(filename);\n    }\n    return ret;\n}\n\n\nvoid ConfigFile::LoadFile(Stream *r, const char *name){\n\tcurConfigFile = this;\n    string l, key, val;\n    string section;\n    string comment;\n    int i, line, line2;\n    bool eof;\n\n    line=line2=0;\n    section.clear();\n    do {\n        line=line2++;\n        l=r->getline(eof);\n        ConfigEntry::trim(l);\n        if(l.size()==0) continue;\n\n        if(l[0]=='#' || l[0]==';'){\n            // comment\n            continue;\n        }\n\n        if(l[0]=='['){\n            if(*l.rbegin()!=']'){\n                if(name) fprintf(stderr, \"%s:\", name);\n                fprintf(stderr, \"[%d]: Ignoring invalid section header\\n\", line);\n                continue;\n            }\n            section.assign(l, 1, l.size()-2);\n            continue;\n        }\n\n        while(*l.rbegin()=='\\\\'){\n            l.erase(l.size()-1);\n            line2++;\n            val=r->getline(eof);\n            if(eof){\n                fprintf(stderr, \"Unexpected EOF reading config file\");\n                if(name) fprintf(stderr, \" '%s'\", name);\n                fprintf(stderr, \"\\n\");\n                return;\n            }\n            ConfigEntry::trim(val);\n            l+=val;\n        }\n        i=l.find('=');\n        if(i<0){\n            if(name) fprintf(stderr, \"%s:\", name);\n            fprintf(stderr, \"[%d]: Ignoring invalid entry\\n\", line);\n            continue;\n        }\n        key=l.substr(0,i); ConfigEntry::trim(key);\n\t\tval=l.substr(i+1); comment = ConfigEntry::trimCommented(val);\n\t\tif(val.size() > 0 && val[0]=='\"' && *val.rbegin()=='\"') val=val.substr(1, val.size()-2);\n\n        ConfigEntry e(line, section, key, val);\n\t\te.comment = comment;\n        if(data.erase(e))\n\t\t\tsectionSizes.DecreaseSectionSize(e.section);\n        data.insert(e);\n\t\tsectionSizes.IncreaseSectionSize(e.section);\n    } while(!eof);\n\tcurConfigFile = NULL;\n}\n\nbool ConfigFile::SaveTo(const char *filename){\n    string section;\n    FILE *fp;\n\n    if((fp=fopen(filename, \"w\"))==NULL){\n        fprintf(stderr, \"Couldn't write conffile \");\n        perror(filename);\n        return false;\n    }\n\n\tcurConfigFile = this;\n    section.clear();\n    set<ConfigEntry, ConfigEntry::line_less> tmp;\n    fprintf(fp, \"# Config file output by snes9x\\n\");\n    time_t t=time(NULL);\n    fprintf(fp, \"# %s\", ctime(&t));\n\n#ifdef SORT_SECTIONS_BY_SIZE\n\tstd::set<ConfigEntry, ConfigEntry::section_then_key_less> data2;\n\tfor(set<ConfigEntry, ConfigEntry::key_less>::iterator k=data.begin(); k!=data.end(); k++){\n\t\tConfigEntry e (k->line, k->section, k->key, k->val); e.comment = k->comment;\n\t\tdata2.insert(e);\n\t}\n#else\n\t#define data2 data\n\t#define section_then_key_less key_less\n#endif\n\n    for(set<ConfigEntry, ConfigEntry::section_then_key_less>::iterator j=data2.begin(); ; j++){\n        if(j==data2.end() || j->section!=section){\n            if(!tmp.empty()){\n                fprintf(fp, \"\\n[%s]\\n\", section.c_str());\n\t\t\t\tunsigned int maxKeyLen=0, maxValLen=0; int maxLeftDiv=0; int maxRightDiv=-1;\n\t\t\t\tif(niceAlignment){\n\t\t\t\t\tfor(set<ConfigEntry, ConfigEntry::line_less>::iterator i=tmp.begin(); i!=tmp.end(); i++){\n\t\t\t\t\t\tint len3 = i->key.find_last_of(':');\n\t\t\t\t\t\tmaxRightDiv = MAX(maxRightDiv, len3);\n\t\t\t\t\t\tlen3 = i->key.length() - len3;\n\t\t\t\t\t\tmaxLeftDiv = MAX(maxLeftDiv, len3);\n\t\t\t\t\t\tmaxKeyLen = MAX(maxKeyLen, i->key.length()+3);\n\t\t\t\t\t\tif(showComments){\n\t\t\t\t\t\t\tstring o=i->val; ConfigEntry::trim(o);\n\t\t\t\t\t\t\tunsigned int len = o.length();\n\t\t\t\t\t\t\tfor(signed int j=len-1;j>=0;j--) if(o.at(j)=='#') len++;\n\t\t\t\t\t\t\tif(o!=i->val) len+=2;\n\t\t\t\t\t\t\tmaxValLen = MAX(maxValLen, len);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(maxValLen>48) maxValLen=48; // limit spacing\n\t\t\t\t}\n\n\t\t\t\tfor(set<ConfigEntry, ConfigEntry::line_less>::iterator i=tmp.begin(); i!=tmp.end(); i++){\n                    string o=i->val; ConfigEntry::trim(o);\n                    if(o!=i->val) o=\"\\\"\"+i->val+\"\\\"\";\n\t\t\t\t\tint off=0, len3=0;\n\t\t\t\t\tfor(;;){\n\t\t\t\t\t\tint k=o.find('#',off);\n\t\t\t\t\t\tif(k>=0){\n\t\t\t\t\t\t\to.insert(k,1,'#'); // re-double any comment characters\n\t\t\t\t\t\t\toff=k+2;\n\t\t\t\t\t\t\tif(off<(int)o.length()) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(niceAlignment){\n\t\t\t\t\t\tlen3=i->key.find_last_of(':');\n\t\t\t\t\t\tint len3sub=0;\n\t\t\t\t\t\tif(len3 < maxRightDiv){\n\t\t\t\t\t\t\tfor(int j=len3;j<maxRightDiv;j++) fputc(' ',fp);\n\t\t\t\t\t\t\tlen3sub=maxRightDiv-len3;\n\t\t\t\t\t\t\tlen3 = maxRightDiv;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen3+=maxLeftDiv-i->key.length();\n\t\t\t\t\t\tfor(unsigned int j=i->key.length()+len3+3;j<maxKeyLen;j++) fputc(' ',fp);\n\t\t\t\t\t\tfprintf(fp, \"%s\", i->key.c_str());\n\t\t\t\t\t\tfor(int j=0;j<len3-len3sub;j++) fputc(' ',fp);\n\t\t\t\t\t\tfprintf(fp, \" = %s\", o.c_str());\n\t\t\t\t\t} else\n\t\t\t\t\t\tfprintf(fp, \"%s = %s\", i->key.c_str(), o.c_str());\n\n\t\t\t\t\tif(showComments && !i->comment.empty()){\n\t\t\t\t\t\tif(niceAlignment) for(unsigned int j=o.length();j<maxValLen;j++) fputc(' ',fp);\n\t\t\t\t\t\tfprintf(fp, \"  # %s\", i->comment.c_str());\n\t\t\t\t\t}\n\t\t\t\t\tfprintf(fp, \"\\n\");\n                }\n            }\n            if(j==data2.end()) break;\n            section=j->section;\n            tmp.clear();\n        }\n        tmp.insert(*j);\n    }\n\tcurConfigFile = NULL;\n\n\t#undef data2\n\t#undef section_then_key_less\n\n\tif(ferror(fp))\n\t{\n\t\tprintf (\"Error writing config file %s\\n\", filename);\n\t}\n\n    fclose(fp);\n    return true;\n}\n\n\n/***********************************************/\n\nstring ConfigFile::Get(const char *key){\n\tset<ConfigEntry, ConfigEntry::key_less>::iterator i;\n    i=data.find(ConfigEntry(key));\n\ti->used=true;\n    return i->val;\n}\nbool ConfigFile::Has(const char *key){\n    return data.find(ConfigEntry(key))!=data.end();\n}\n\n// exists and isn't completely empty (any side-effects are intentional)\nbool ConfigFile::Exists(const char *key){\n\tconst char* val = GetString(key, NULL);\n\treturn val && *val;\n}\n\n\nstring ConfigFile::GetString(const char *key, string def){\n    if(!Exists(key))\n\t\treturn def;\n    return Get(key);\n}\n\nchar *ConfigFile::GetString(const char *key, char *out, uint32 outlen){\n    if(!Exists(key)) return NULL;\n    memset(out, 0, outlen);\n    string o=Get(key);\n    if(outlen>0){\n        outlen--;\n        if(o.size()<outlen) outlen=o.size();\n        memcpy(out, o.data(), outlen);\n    }\n    return out;\n}\n\nconst char *ConfigFile::GetString(const char *key, const char *def){\n    set<ConfigEntry, ConfigEntry::key_less>::iterator i;\n    i=data.find(ConfigEntry(key));\n\tif(i==data.end())\n\t{\n\t\tif(defaultAutoAdd) SetString(key,\"\"); //SetString(key, def?def:\"\");\n\t\treturn def;\n\t}\n\ti->used=true;\n    // This should be OK, until this key gets removed\n\tconst std::string &iVal = i->val;\n\treturn iVal.c_str();\n}\n\nchar *ConfigFile::GetStringDup(const char *key, const char *def){\n    const char *c=GetString(key, def);\n    if(c==NULL) return NULL;\n    return strdup(c);\n}\n\nbool ConfigFile::SetString(const char *key, string val, const char *comment){\n    set<ConfigEntry, ConfigEntry::key_less>::iterator i;\n    bool ret=false;\n    bool found;\n\n    ConfigEntry e(key, val);\n\tif(comment && *comment) e.comment = comment;\n\te.used=true;\n\n    i=data.find(e);\n    found=(i==data.end());\n    if(!found){\n        e.line=i->line;\n        data.erase(e);\n\t\tsectionSizes.DecreaseSectionSize(e.section);\n        ret=true;\n    }\n\tif((found && (!alphaSort || timeSort)) || (!alphaSort && timeSort))\n\t\te.line = linectr++;\n\n    data.insert(e);\n\tsectionSizes.IncreaseSectionSize(e.section);\n    return ret;\n}\n\nint32 ConfigFile::GetInt(const char *key, int32 def, bool *bad){\n    if(bad) *bad=false;\n\tif(!Exists(key))\n\t\treturn def;\n    char *c;\n    int32 i;\n    string o=Get(key);\n    i=strtol(o.c_str(), &c, 10);\n    if(c!=NULL && *c!='\\0'){\n        i=def;\n        if(bad) *bad=true;\n    }\n    return i;\n}\n\nbool ConfigFile::SetInt(const char *key, int32 val, const char *comment){\n    char buf[20];\n    snprintf(buf, sizeof(buf), \"%d\", (int)val);\n    return SetString(key, buf, comment);\n}\n\nuint32 ConfigFile::GetUInt(const char *key, uint32 def, int base, bool *bad){\n    if(bad) *bad=false;\n\tif(!Exists(key))\n\t\treturn def;\n    if(base!=8 && base!=10 && base!=16) base=0;\n    char *c;\n    uint32 i;\n    string o=Get(key);\n    i=strtol(o.c_str(), &c, base);\n    if(c!=NULL && *c!='\\0'){\n        i=def;\n        if(bad) *bad=true;\n    }\n    return i;\n}\n\nbool ConfigFile::SetUInt(const char *key, uint32 val, int base, const char *comment){\n    char buf[20];\n    switch(base){\n      case 10:\n      default:\n        snprintf(buf, sizeof(buf), \"%u\", (unsigned int)val);\n        break;\n      case 8:\n        snprintf(buf, sizeof(buf), \"%#o\", (unsigned int)val);\n        break;\n      case 16:\n        snprintf(buf, sizeof(buf), \"%#x\", (unsigned int)val);\n        break;\n    }\n    return SetString(key, buf, comment);\n}\n\nbool ConfigFile::GetBool(const char *key, bool def, bool *bad){\n    if(bad) *bad=false;\n    if(!Exists(key))\n\t\treturn def;\n    string o=Get(key);\n    const char *c=o.c_str();\n    if(!strcasecmp(c, \"true\") || !strcasecmp(c, \"1\") || !strcasecmp(c, \"yes\") || !strcasecmp(c, \"on\")) return true;\n    if(!strcasecmp(c, \"false\") || !strcasecmp(c, \"0\") || !strcasecmp(c, \"no\") || !strcasecmp(c, \"off\")) return false;\n    if(bad) *bad=true;\n    return def;\n}\n\nbool ConfigFile::SetBool(const char *key, bool val, const char *true_val, const char *false_val, const char *comment){\n    return SetString(key, val?true_val:false_val, comment);\n}\n\nconst char* ConfigFile::GetComment(const char *key)\n{\n    set<ConfigEntry, ConfigEntry::key_less>::iterator i;\n    i=data.find(ConfigEntry(key));\n\tif(i==data.end())\n\t\treturn NULL;\n\n    // This should be OK, until this key gets removed\n\tconst std::string &iCom = i->comment;\n\treturn iCom.c_str();\n}\n\nbool ConfigFile::DeleteKey(const char *key){\n\tConfigEntry e = ConfigEntry(key);\n\tif(data.erase(e)) {\n\t\tsectionSizes.DecreaseSectionSize(e.section);\n\t\treturn true;\n\t}\n    return false;\n}\n\n/***********************************************/\n\nbool ConfigFile::DeleteSection(const char *section){\n    set<ConfigEntry, ConfigEntry::key_less>::iterator s, e;\n\n    for(s=data.begin(); s!=data.end() && s->section!=section; s++) ;\n    if(s==data.end()) return false;\n    for(e=s; e!=data.end() && e->section==section; e++) ;\n    data.erase(s, e);\n\tsectionSizes.DeleteSection(section);\n    return true;\n}\n\nConfigFile::secvec_t ConfigFile::GetSection(const char *section){\n    secvec_t v;\n    set<ConfigEntry, ConfigEntry::key_less>::iterator i;\n\n    v.clear();\n    for(i=data.begin(); i!=data.end(); i++){\n        if(i->section!=section) continue;\n        v.push_back(std::pair<string,string>(i->key, i->val));\n    }\n    return v;\n}\n\nint ConfigFile::GetSectionSize(const std::string section){\n\treturn sectionSizes.GetSectionSize(section);\n}\n\n// Clears all key-value pairs that didn't receive a \"Get\" or \"Exists\" command\nvoid ConfigFile::ClearUnused()\n{\n    set<ConfigEntry, ConfigEntry::key_less>::iterator i;\nagain:\n    for(i=data.begin(); i!=data.end(); i++){\n\t\tif(!i->used){\n\t\t\tdata.erase(i);\n\t\t\tgoto again;\n\t\t}\n\t}\n}\n\nvoid ConfigFile::ClearLines()\n{\n    set<ConfigEntry, ConfigEntry::key_less>::iterator i;\n    for(i=data.begin(); i!=data.end(); i++){\n\t\t*(const_cast<int*>(&i->line)) = -1;\n    }\n}\n\nbool ConfigFile::ConfigEntry::section_then_key_less::operator()(const ConfigEntry &a, const ConfigEntry &b) const{\n\tif(curConfigFile && a.section!=b.section){\n\t\tconst int sva = curConfigFile->GetSectionSize(a.section);\n\t\tconst int svb = curConfigFile->GetSectionSize(b.section);\n\t\tif(sva<svb) return true;\n\t\tif(sva>svb) return false;\n\t\treturn a.section<b.section;\n\t}\n\treturn a.key<b.key;\n}\n\n\nvoid ConfigFile::SetDefaultAutoAdd(bool autoAdd)\n{\n\tdefaultAutoAdd = autoAdd;\n}\nvoid ConfigFile::SetNiceAlignment(bool align)\n{\n\tniceAlignment = align;\n}\nvoid ConfigFile::SetShowComments(bool show)\n{\n\tshowComments = show;\n}\nvoid ConfigFile::SetAlphaSort(bool sort)\n{\n\talphaSort = sort;\n}\nvoid ConfigFile::SetTimeSort(bool sort)\n{\n\ttimeSort = sort;\n}\n"
        },
        {
          "name": "conffile.h",
          "type": "blob",
          "size": 9.146484375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _CONFIG_H_\n#define _CONFIG_H_\n\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\n#ifdef UNZIP_SUPPORT\n#  ifdef SYSTEM_ZIP\n#    include <minizip/unzip.h>\n#  else\n#    include \"unzip/unzip.h\"\n#  endif\n#endif\n#include \"snes9x.h\"\n\n#ifndef MAX\n#  define MAX(a,b)  ((a) > (b)? (a) : (b))\n#  define MIN(a,b)  ((a) < (b)? (a) : (b))\n#endif\n\nclass ConfigFile {\n  public:\n    ConfigFile(void);\n\n    void Clear(void);\n\n    // return false on failure\n    bool LoadFile(const char *filename);\n    void LoadFile(Stream *r, const char *name=NULL);\n\n    // return false if key does not exist or is empty\n    bool Exists(const char *key);\n\n    // return the value / default\n    std::string GetString(const char *key, std::string def);\n    char *GetString(const char *key, char *out, uint32 outlen); // return NULL if it doesn't exist, out not affected\n    const char *GetString(const char *key, const char *def=NULL); // NOTE: returned pointer becomes invalid when key is deleted/modified, or the ConfigFile is Clear()ed or deleted.\n    char *GetStringDup(const char *key, const char *def=NULL); // Much like \"strdup(GetString(key, def))\"\n    int32 GetInt(const char *key, int32 def=-1, bool *bad=NULL);\n    uint32 GetUInt(const char *key, uint32 def=0, int base=0, bool *bad=NULL); // base = 0, 8, 10, or 16\n    bool GetBool(const char *key, bool def=false, bool *bad=NULL);\n    const char* GetComment(const char *key); // NOTE: returned pointer becomes invalid when key is deleted/modified, or the ConfigFile is Clear()ed or deleted.\n\n    // return true if the key existed prior to setting\n    bool SetString(const char *key, std::string val, const char *comment=\"\");\n    bool SetInt(const char *key, int32 val, const char *comment=\"\");\n    bool SetUInt(const char *key, uint32 val, int base=10, const char *comment=\"\"); // base = 8, 10, or 16\n    bool SetBool(const char *key, bool val, const char *true_val=\"TRUE\", const char *false_val=\"FALSE\", const char *comment=\"\");\n    bool DeleteKey(const char *key);\n\n    // Operation on entire sections\n    bool DeleteSection(const char *section);\n    typedef std::vector<std::pair<std::string,std::string> > secvec_t;\n    secvec_t GetSection(const char *section);\n    int GetSectionSize(const std::string section);\n\n\t// Clears all key-value pairs that didn't receive a Set command, or a Get command with autoAdd on\n    void ClearUnused(void);\n\n\t// Clears all stored line numbers\n    void ClearLines(void);\n\n    bool SaveTo(const char *filename);\n\n    static void SetDefaultAutoAdd(bool autoAdd);\n    static void SetNiceAlignment(bool align);\n    static void SetShowComments(bool show);\n    static void SetAlphaSort(bool sort);\n    static void SetTimeSort(bool sort);\n\n  private:\n    std::string Get(const char *key);\n    bool Has(const char *key);\n\n    class ConfigEntry {\n      protected:\n        int line;\n        std::string section;\n        std::string key;\n        std::string val;\n        std::string comment;\n\t\tmutable bool used;\n\n        struct section_then_key_less {\n            bool operator()(const ConfigEntry &a, const ConfigEntry &b) const;\n        };\n\n        struct key_less {\n            bool operator()(const ConfigEntry &a, const ConfigEntry &b) const{\n                if(a.section!=b.section) return a.section<b.section;\n                return a.key<b.key;\n            }\n        };\n\n        struct line_less {\n            bool operator()(const ConfigEntry &a, const ConfigEntry &b) const{\n                if(a.line==b.line) return (b.val.empty() && !a.val.empty()) || a.key<b.key;\n                if(b.line<0) return true;\n                if(a.line<0) return false;\n                return a.line<b.line;\n            }\n        };\n\n        static void trim(std::string &s){\n            int i;\n            i=s.find_first_not_of(\" \\f\\n\\r\\t\\v\");\n            if(i==-1){\n                s.clear();\n                return;\n            }\n            if(i>0) s.erase(0, i); // erase leading whitespace\n            i=s.find_last_not_of(\" \\f\\n\\r\\t\\v\");\n            if(i!=-1) s.erase(i+1); // erase trailing whitespace\n\t\t\treturn;\n        }\n\n\t\t// trims comments and leading/trailing whitespace from s, and returns any trimmed comments\n\t\t// make sure not to call this more than once on the same string\n        static std::string trimCommented(std::string &s){\n\t\t\tstd::string cmt;\n            int i;\n            i=s.find_first_not_of(\" \\f\\n\\r\\t\\v\");\n            if(i==-1){\n                s.clear();\n                return cmt;\n            }\n            if(i>0) s.erase(0, i); // erase leading whitespace\n\t\t\tint off=0;\n\t\t\tfor(;;){\n\t\t\t\ti=s.find('#',off); // find trailing comment\n\t\t\t\tif(i>=0)\n\t\t\t\t{\n\t\t\t\t\tif((int)s.length()>i+1 && s.at(i+1) == '#') {\n\t\t\t\t\t\ts.erase(i,1);  // ignore ## and change to #\n\t\t\t\t\t\toff = i+1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint j=s.find_first_not_of(\" \\f\\n\\r\\t\\v\",i+1);\n\t\t\t\t\t\tif(j!=-1) cmt = s.substr(j); // store\n\t\t\t\t\t\ts.erase(i); // erase trailing comment\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n            i=s.find_last_not_of(\" \\f\\n\\r\\t\\v\");\n            if(i!=-1) s.erase(i+1); // erase trailing whitespace\n\t\t\treturn cmt;\n        }\n\n      public:\n        ConfigEntry(int l, const std::string &s, const std::string &k, const std::string &v) :\n            line(l), section(s), key(k), val(v) {\n            trim(section);\n            trim(key);\n\t\t\tused=false;\n        }\n\n        void parse_key(const std::string &k){\n            int i=k.find(\"::\");\n            if(i==-1){\n                section=\"Uncategorized\"; key=k;\n            } else {\n                section=k.substr(0,i); key=k.substr(i+2);\n            }\n            trim(section);\n            trim(key);\n\t\t\tused=false;\n        }\n\n        ConfigEntry(const std::string k){\n            parse_key(k);\n        }\n\n        ConfigEntry(const std::string k, const std::string &v) : line(-1), val(v) {\n            parse_key(k);\n        }\n\n        friend class ConfigFile;\n        friend struct key_less;\n        friend struct line_less;\n    };\n\tclass SectionSizes {\n\t  protected:\n\t\tstd::map<std::string,uint32> sections;\n\n\t  public:\n\t\tuint32 GetSectionSize(const std::string section) {\n\t\t\tuint32 count=0;\n\t\t\tuint32 seclen;\n\t\t\tstd::map<std::string,uint32>::iterator it;\n\t\t\tfor(it=sections.begin(); it!=sections.end(); it++) {\n\t\t\t\tseclen = MIN(section.size(),it->first.size());\n\t\t\t\tif(it->first==section || !section.compare(0,seclen,it->first,0,seclen)) count+=it->second;\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\n\t\tvoid IncreaseSectionSize(const std::string section) {\n\t\t\tstd::map<std::string,uint32>::iterator it=sections.find(section);\n\t\t\tif(it!=sections.end())\n\t\t\t\tit->second++;\n\t\t\telse\n\t\t\t\tsections.insert(std::pair<std::string,uint32>(section,1));\n\t\t}\n\n\t\tvoid DecreaseSectionSize(const std::string section) {\n\t\t\tstd::map<std::string,uint32>::iterator it=sections.find(section);\n\t\t\tif(it!=sections.end())\n\t\t\t\tit->second--;\n\t\t}\n\n\t\tvoid ClearSections() {\n\t\t\tsections.clear();\n\t\t}\n\n\t\tvoid DeleteSection(const std::string section) {\n\t\t\tsections.erase(section);\n\t\t}\n\n\t};\n    std::set<ConfigEntry, ConfigEntry::key_less> data;\n\tSectionSizes sectionSizes;\n\tint linectr;\n\tstatic bool defaultAutoAdd;\n\tstatic bool niceAlignment;\n\tstatic bool showComments;\n\tstatic bool alphaSort;\n\tstatic bool timeSort;\n};\n\n/* Config file format:\n *\n * Comments are any lines whose first non-whitespace character is ';' or '#'.\n * Note that comments can also follow a value, on the same line.\n * To intentionally have a '#' character in the value, use ##\n *\n * All parameters fall into sections. To name a section, the first\n * non-whitespace character on the line will be '[', and the last will be ']'.\n *\n * Parameters are simple key=value pairs. Whitespace around the '=', and at the\n * beginning or end of the line is ignored. Key names may not contain '=' nor\n * begin with '[', however values can. If the last character of the value is\n * '\\', the next line (sans leading/trailing whitespace) is considered part of\n * the value as well. Programmatically, the key \"K\" in section \"S\" is referred\n * to as \"S::K\", much like C++ namespaces. For example:\n *   [Section1]\n *   # this is a comment\n *   foo = bar \\\n *      baz\\\n *      quux \\\n *   ## this is not a comment! # this IS a comment\n * means the value of \"Section1::foo\" is \"bar bazquux # this is not a comment!\"\n *\n * Parameters may be of several types:\n *  String - Bare characters. If the first and last characters are both '\"',\n *           they are removed (so just double them if you really want quotes\n *           there)\n *  Int - A decimal number from -2147483648 to 2147483647\n *  UInt - A number in decimal, hex, or octal from 0 to 4294967295 (or\n *         0xffffffff, or 037777777777)\n *  Bool - true/false, 0/1, on/off, yes/no\n *\n * Of course, the actual accepted values for a parameter may be further\n * restricted ;)\n */\n\n\n/* You must write this for your port */\nvoid S9xParsePortConfig(ConfigFile &, int pass);\n\n/* This may or may not be useful to you */\nconst char *S9xParseDisplayConfig(ConfigFile &, int pass);\n\n#endif\n"
        },
        {
          "name": "controls.cpp",
          "type": "blob",
          "size": 84.08984375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include <map>\n#include <set>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <assert.h>\n#include <ctype.h>\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"apu/apu.h\"\n#include \"snapshot.h\"\n#include \"controls.h\"\n#include \"crosshairs.h\"\n#include \"movie.h\"\n#include \"display.h\"\n#ifdef NETPLAY_SUPPORT\n#include \"netplay.h\"\n#endif\n\nusing namespace\tstd;\n\n#define NONE\t\t\t\t\t(-2)\n#define MP5\t\t\t\t\t\t(-1)\n#define JOYPAD0\t\t\t\t\t0\n#define JOYPAD1\t\t\t\t\t1\n#define JOYPAD2\t\t\t\t\t2\n#define JOYPAD3\t\t\t\t\t3\n#define JOYPAD4\t\t\t\t\t4\n#define JOYPAD5\t\t\t\t\t5\n#define JOYPAD6\t\t\t\t\t6\n#define JOYPAD7\t\t\t\t\t7\n#define MOUSE0\t\t\t\t\t8\n#define MOUSE1\t\t\t\t\t9\n#define SUPERSCOPE\t\t\t\t10\n#define ONE_JUSTIFIER\t\t\t11\n#define TWO_JUSTIFIERS\t\t\t12\n#define MACSRIFLE\t\t\t\t13\n#define NUMCTLS\t\t\t\t\t14 // This must be LAST\n\n#define POLL_ALL\t\t\t\tNUMCTLS\n\n#define SUPERSCOPE_FIRE\t\t\t0x80\n#define SUPERSCOPE_CURSOR\t\t0x40\n#define SUPERSCOPE_TURBO\t\t0x20\n#define SUPERSCOPE_PAUSE\t\t0x10\n#define SUPERSCOPE_OFFSCREEN\t0x02\n\n#define JUSTIFIER_TRIGGER\t\t0x80\n#define JUSTIFIER_START\t\t\t0x20\n#define JUSTIFIER_SELECT\t\t0x08\n\n#define MACSRIFLE_TRIGGER\t\t0x01\n\n#define MAP_UNKNOWN\t\t\t\t(-1)\n#define MAP_NONE\t\t\t\t0\n#define MAP_BUTTON\t\t\t\t1\n#define MAP_AXIS\t\t\t\t2\n#define MAP_POINTER\t\t\t\t3\n\n#define FLAG_IOBIT0\t\t\t\t(Memory.FillRAM[0x4213] & 0x40)\n#define FLAG_IOBIT1\t\t\t\t(Memory.FillRAM[0x4213] & 0x80)\n#define FLAG_IOBIT(n)\t\t\t((n) ? (FLAG_IOBIT1) : (FLAG_IOBIT0))\n\nbool8\tpad_read = 0, pad_read_last = 0;\nuint8\tread_idx[2 /* ports */][2 /* per port */];\n\nstruct exemulti\n{\n\tint32\t\t\t\tpos;\n\tbool8\t\t\t\tdata1;\n\ts9xcommand_t\t\t*script;\n};\n\nstruct crosshair\n{\n\tuint8\t\t\t\tset;\n\tuint8\t\t\t\timg;\n\tuint8\t\t\t\tfg, bg;\n};\n\nstatic struct\n{\n\tint16\t\t\t\tx, y;\n\tint16\t\t\t\tV_adj;\n\tbool8\t\t\t\tV_var;\n\tint16\t\t\t\tH_adj;\n\tbool8\t\t\t\tH_var;\n\tbool8\t\t\t\tmapped;\n}\tpseudopointer[8];\n\nstatic struct\n{\n\tuint16\t\t\t\tbuttons;\n\tuint16\t\t\t\tturbos;\n\tuint16\t\t\t\ttoggleturbo;\n\tuint16\t\t\t\ttogglestick;\n\tuint8\t\t\t\tturbo_ct;\n}\tjoypad[8];\n\nstatic struct\n{\n\tuint8\t\t\t\tdelta_x, delta_y;\n\tint16\t\t\t\told_x, old_y;\n\tint16\t\t\t\tcur_x, cur_y;\n\tuint8\t\t\t\tbuttons;\n\tuint32\t\t\t\tID;\n\tstruct crosshair\tcrosshair;\n}\tmouse[2];\n\nstatic struct\n{\n\tint16\t\t\t\tx, y;\n\tuint8\t\t\t\tphys_buttons;\n\tuint8\t\t\t\tnext_buttons;\n\tuint8\t\t\t\tread_buttons;\n\tuint32\t\t\t\tID;\n\tstruct crosshair\tcrosshair;\n}\tsuperscope;\n\nstatic struct\n{\n\tint16\t\t\t\tx[2], y[2];\n\tuint8\t\t\t\tbuttons;\n\tbool8\t\t\t\toffscreen[2];\n\tuint32\t\t\t\tID[2];\n\tstruct crosshair\tcrosshair[2];\n}\tjustifier;\n\nstatic struct\n{\n\tint8\t\t\t\tpads[4];\n}\tmp5[2];\n\nstatic struct\n{\n\tint16\t\t\t\tx, y;\n\tuint8\t\t\t\tbuttons;\n\tuint32\t\t\t\tID;\n\tstruct crosshair\tcrosshair;\n}\tmacsrifle;\n\nstatic set<struct exemulti *>\t\texemultis;\nstatic set<uint32>\t\t\t\t\tpollmap[NUMCTLS + 1];\nstatic map<uint32, s9xcommand_t>\tkeymap;\nstatic vector<s9xcommand_t *>\t\tmultis;\nstatic uint8\t\t\t\t\t\tturbo_time;\nstatic uint8\t\t\t\t\t\tpseudobuttons[256];\nstatic bool8\t\t\t\t\t\tFLAG_LATCH = FALSE;\nstatic int32\t\t\t\t\t\tcurcontrollers[2] = { NONE,    NONE };\nstatic int32\t\t\t\t\t\tnewcontrollers[2] = { JOYPAD0, NONE };\nstatic char\t\t\t\t\t\t\tbuf[256];\n\nstatic const char\t*color_names[32] =\n{\n\t\"Trans\",\n\t\"Black\",\n\t\"25Grey\",\n\t\"50Grey\",\n\t\"75Grey\",\n\t\"White\",\n\t\"Red\",\n\t\"Orange\",\n\t\"Yellow\",\n\t\"Green\",\n\t\"Cyan\",\n\t\"Sky\",\n\t\"Blue\",\n\t\"Violet\",\n\t\"MagicPink\",\n\t\"Purple\",\n\tNULL,\n\t\"tBlack\",\n\t\"t25Grey\",\n\t\"t50Grey\",\n\t\"t75Grey\",\n\t\"tWhite\",\n\t\"tRed\",\n\t\"tOrange\",\n\t\"tYellow\",\n\t\"tGreen\",\n\t\"tCyan\",\n\t\"tSky\",\n\t\"tBlue\",\n\t\"tViolet\",\n\t\"tMagicPink\",\n\t\"tPurple\"\n};\n\nstatic const char\t*speed_names[4] =\n{\n\t\"Var\",\n\t\"Slow\",\n\t\"Med\",\n\t\"Fast\"\n};\n\nstatic const int\tptrspeeds[4] = { 1, 1, 4, 8 };\n\n// Note: these should be in asciibetical order!\n#define THE_COMMANDS \\\n\tS(BeginRecordingMovie), \\\n\tS(ClipWindows), \\\n\tS(Debugger), \\\n\tS(DecEmuTurbo), \\\n\tS(DecFrameRate), \\\n\tS(DecFrameTime), \\\n\tS(DecTurboSpeed), \\\n\tS(EmuTurbo), \\\n\tS(EndRecordingMovie), \\\n\tS(ExitEmu), \\\n\tS(IncEmuTurbo), \\\n\tS(IncFrameRate), \\\n\tS(IncFrameTime), \\\n\tS(IncTurboSpeed), \\\n\tS(LoadFreezeFile), \\\n\tS(LoadMovie), \\\n\tS(LoadOopsFile), \\\n\tS(Pause), \\\n\tS(QuickLoad000), \\\n\tS(QuickLoad001), \\\n\tS(QuickLoad002), \\\n\tS(QuickLoad003), \\\n\tS(QuickLoad004), \\\n\tS(QuickLoad005), \\\n\tS(QuickLoad006), \\\n\tS(QuickLoad007), \\\n\tS(QuickLoad008), \\\n\tS(QuickLoad009), \\\n\tS(QuickLoad010), \\\n\tS(QuickSave000), \\\n\tS(QuickSave001), \\\n\tS(QuickSave002), \\\n\tS(QuickSave003), \\\n\tS(QuickSave004), \\\n\tS(QuickSave005), \\\n\tS(QuickSave006), \\\n\tS(QuickSave007), \\\n\tS(QuickSave008), \\\n\tS(QuickSave009), \\\n\tS(QuickSave010), \\\n\tS(Reset), \\\n\tS(SaveFreezeFile), \\\n\tS(SaveSPC), \\\n\tS(Screenshot), \\\n\tS(SeekToFrame), \\\n\tS(SoftReset), \\\n\tS(SoundChannel0), \\\n\tS(SoundChannel1), \\\n\tS(SoundChannel2), \\\n\tS(SoundChannel3), \\\n\tS(SoundChannel4), \\\n\tS(SoundChannel5), \\\n\tS(SoundChannel6), \\\n\tS(SoundChannel7), \\\n\tS(SoundChannelsOn), \\\n\tS(SwapJoypads), \\\n\tS(ToggleBG0), \\\n\tS(ToggleBG1), \\\n\tS(ToggleBG2), \\\n\tS(ToggleBG3), \\\n\tS(ToggleBackdrop), \\\n\tS(ToggleEmuTurbo), \\\n\tS(ToggleSprites), \\\n\tS(ToggleTransparency) \\\n\n#define S(x)\tx\n\nenum command_numbers\n{\n\tTHE_COMMANDS,\n\tLAST_COMMAND\n};\n\n#undef S\n#define S(x)\t#x\n\nstatic const char\t*command_names[LAST_COMMAND + 1] =\n{\n\tTHE_COMMANDS,\n\tNULL\n};\n\n#undef S\n#undef THE_COMMANDS\n\nstatic void DisplayStateChange (const char *, bool8);\nstatic void DoGunLatch (int, int);\nstatic void DoMacsRifleLatch (int, int);\nstatic int maptype (int);\nstatic bool strless (const char *, const char *);\nstatic int findstr (const char *, const char **, int);\nstatic int get_threshold (const char **);\nstatic const char * maptypename (int);\nstatic int32 ApplyMulti (s9xcommand_t *, int32, int16);\nstatic void do_polling (int);\nstatic void UpdatePolledMouse (int);\n\n\nstatic string& operator += (string &s, int i)\n{\n\tsnprintf(buf, sizeof(buf), \"%d\", i);\n\ts.append(buf);\n\treturn (s);\n}\n\nstatic string& operator += (string &s, double d)\n{\n\tsnprintf(buf, sizeof(buf), \"%g\", d);\n\ts.append(buf);\n\treturn (s);\n}\n\nstatic void DisplayStateChange (const char *str, bool8 on)\n{\n\tsnprintf(buf, sizeof(buf), \"%s: %s\", str, on ? \"on\":\"off\");\n\tS9xSetInfoString(buf);\n}\n\nstatic void DoGunLatch (int x, int y)\n{\n\tx += 40;\n\n\tif (x > 295)\n\t\tx = 295;\n\telse if (x < 40)\n\t\tx = 40;\n\n\tif (y > PPU.ScreenHeight - 1)\n\t\ty = PPU.ScreenHeight - 1;\n\telse if (y < 0)\n\t\ty = 0;\n\n\tPPU.GunVLatch = (uint16) (y + 1);\n\tPPU.GunHLatch = (uint16) x;\n}\n\nstatic void DoMacsRifleLatch (int x, int y)\n{\n\tPPU.GunVLatch = (uint16) (y + 42);// + (int16) macsrifle.adjust_y;\n\tPPU.GunHLatch = (uint16) (x + 76);// + (int16) macsrifle.adjust_x;\n}\n\nstatic int maptype (int t)\n{\n\tswitch (t)\n\t{\n\t\tcase S9xNoMapping:\n\t\t\treturn (MAP_NONE);\n\n\t\tcase S9xButtonJoypad:\n\t\tcase S9xButtonMouse:\n\t\tcase S9xButtonSuperscope:\n\t\tcase S9xButtonJustifier:\n\t\tcase S9xButtonMacsRifle:\n\t\tcase S9xButtonCommand:\n\t\tcase S9xButtonPseudopointer:\n\t\tcase S9xButtonPort:\n\t\tcase S9xButtonMulti:\n\t\t\treturn (MAP_BUTTON);\n\n\t\tcase S9xAxisJoypad:\n\t\tcase S9xAxisPseudopointer:\n\t\tcase S9xAxisPseudobuttons:\n\t\tcase S9xAxisPort:\n\t\t\treturn (MAP_AXIS);\n\n\t\tcase S9xPointer:\n\t\tcase S9xPointerPort:\n\t\t\treturn (MAP_POINTER);\n\n\t\tdefault:\n\t\t\treturn (MAP_UNKNOWN);\n\t}\n}\n\nvoid S9xControlsReset (void)\n{\n\tS9xControlsSoftReset();\n\tmouse[0].buttons  &= ~0x30;\n\tmouse[1].buttons  &= ~0x30;\n\tjustifier.buttons &= ~JUSTIFIER_SELECT;\n\tmacsrifle.buttons = 0;\n}\n\nvoid S9xControlsSoftReset (void)\n{\n\tfor (set<struct exemulti *>::iterator it = exemultis.begin(); it != exemultis.end(); it++)\n\t\tdelete *it;\n\texemultis.clear();\n\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tread_idx[i][j]=0;\n\n\tFLAG_LATCH = FALSE;\n\n\tcurcontrollers[0] = newcontrollers[0];\n\tcurcontrollers[1] = newcontrollers[1];\n}\n\nvoid S9xUnmapAllControls (void)\n{\n\tS9xControlsReset();\n\n\tkeymap.clear();\n\n\tfor (int i = 0; i < (int) multis.size(); i++)\n\t\tfree(multis[i]);\n\tmultis.clear();\n\n\tfor (int i = 0; i < NUMCTLS + 1; i++)\n\t\tpollmap[i].clear();\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tpseudopointer[i].x = 0;\n\t\tpseudopointer[i].y = 0;\n\t\tpseudopointer[i].H_adj = 0;\n\t\tpseudopointer[i].V_adj = 0;\n\t\tpseudopointer[i].H_var = 0;\n\t\tpseudopointer[i].V_var = 0;\n\t\tpseudopointer[i].mapped = false;\n\n\t\tjoypad[i].buttons  = 0;\n\t\tjoypad[i].turbos   = 0;\n\t\tjoypad[i].turbo_ct = 0;\n\t}\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tmouse[i].old_x = mouse[i].old_y = 0;\n\t\tmouse[i].cur_x = mouse[i].cur_y = 0;\n\t\tmouse[i].buttons = 1;\n\t\tmouse[i].ID = InvalidControlID;\n\n\t\tif (!(mouse[i].crosshair.set & 1))\n\t\t\tmouse[i].crosshair.img = 0; // no image for mouse because its only logical position is game-specific, not known by the emulator\n\t\tif (!(mouse[i].crosshair.set & 2))\n\t\t\tmouse[i].crosshair.fg  = 5;\n\t\tif (!(mouse[i].crosshair.set & 4))\n\t\t\tmouse[i].crosshair.bg  = 1;\n\n\t\tjustifier.x[i] = justifier.y[i] = 0;\n\t\tjustifier.offscreen[i] = 0;\n\t\tjustifier.ID[i] = InvalidControlID;\n\n\t\tif (!(justifier.crosshair[i].set & 1))\n\t\t\tjustifier.crosshair[i].img = 4;\n\t\tif (!(justifier.crosshair[i].set & 2))\n\t\t\tjustifier.crosshair[i].fg  = i ? 14 : 12;\n\t\tif (!(justifier.crosshair[i].set & 4))\n\t\t\tjustifier.crosshair[i].bg  = 1;\n\t}\n\n\tjustifier.buttons = 0;\n\n\tsuperscope.x = superscope.y = 0;\n\tsuperscope.phys_buttons = 0;\n\tsuperscope.next_buttons = 0;\n\tsuperscope.read_buttons = 0;\n\tsuperscope.ID = InvalidControlID;\n\n\tif (!(superscope.crosshair.set & 1))\n\t\tsuperscope.crosshair.img = 2;\n\tif (!(superscope.crosshair.set & 2))\n\t\tsuperscope.crosshair.fg  = 5;\n\tif (!(superscope.crosshair.set & 4))\n\t\tsuperscope.crosshair.bg  = 1;\n\n\tmacsrifle.x = macsrifle.y = 0;\n\tmacsrifle.buttons = 0;\n\tmacsrifle.ID = InvalidControlID;\n\n\tif (!(macsrifle.crosshair.set & 1))\n\t\tmacsrifle.crosshair.img = 2;\n\tif (!(macsrifle.crosshair.set & 2))\n\t\tmacsrifle.crosshair.fg  = 5;\n\tif (!(macsrifle.crosshair.set & 4))\n\t\tmacsrifle.crosshair.bg  = 1;\n\n\tmemset(pseudobuttons, 0, sizeof(pseudobuttons));\n\n\tturbo_time = 1;\n}\n\nvoid S9xSetController (int port, enum controllers controller, int8 id1, int8 id2, int8 id3, int8 id4)\n{\n\tif (port < 0 || port > 1)\n\t\treturn;\n\n\tswitch (controller)\n\t{\n\t\tcase CTL_NONE:\n\t\t\tbreak;\n\n\t\tcase CTL_JOYPAD:\n\t\t\tif (id1 < 0 || id1 > 7)\n\t\t\t\tbreak;\n\n\t\t\tnewcontrollers[port] = JOYPAD0 + id1;\n\t\t\treturn;\n\n\t\tcase CTL_MOUSE:\n\t\t\tif (id1 < 0 || id1 > 1)\n\t\t\t\tbreak;\n\t\t\tif (!Settings.MouseMaster)\n\t\t\t{\n\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, \"Cannot select SNES Mouse: MouseMaster disabled\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnewcontrollers[port] = MOUSE0 + id1;\n\t\t\treturn;\n\n\t\tcase CTL_SUPERSCOPE:\n\t\t\tif (!Settings.SuperScopeMaster)\n\t\t\t{\n\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, \"Cannot select SNES Superscope: SuperScopeMaster disabled\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnewcontrollers[port] = SUPERSCOPE;\n\t\t\treturn;\n\n\t\tcase CTL_JUSTIFIER:\n\t\t\tif (id1 < 0 || id1 > 1)\n\t\t\t\tbreak;\n\t\t\tif (!Settings.JustifierMaster)\n\t\t\t{\n\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, \"Cannot select Konami Justifier: JustifierMaster disabled\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnewcontrollers[port] = ONE_JUSTIFIER + id1;\n\t\t\treturn;\n\n\t\tcase CTL_MACSRIFLE:\n\t\t\tif (!Settings.MacsRifleMaster)\n\t\t\t{\n\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, \"Cannot select SNES M.A.C.S. Rifle: MacsRifleMaster disabled\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnewcontrollers[port] = MACSRIFLE;\n\t\t\treturn;\n\n\t\tcase CTL_MP5:\n\t\t\tif (id1 < -1 || id1 > 7)\n\t\t\t\tbreak;\n\t\t\tif (id2 < -1 || id2 > 7)\n\t\t\t\tbreak;\n\t\t\tif (id3 < -1 || id3 > 7)\n\t\t\t\tbreak;\n\t\t\tif (id4 < -1 || id4 > 7)\n\t\t\t\tbreak;\n\t\t\tif (!Settings.MultiPlayer5Master)\n\t\t\t{\n\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, \"Cannot select MP5: MultiPlayer5Master disabled\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnewcontrollers[port] = MP5;\n\t\t\tmp5[port].pads[0] = (id1 < 0) ? NONE : JOYPAD0 + id1;\n\t\t\tmp5[port].pads[1] = (id2 < 0) ? NONE : JOYPAD0 + id2;\n\t\t\tmp5[port].pads[2] = (id3 < 0) ? NONE : JOYPAD0 + id3;\n\t\t\tmp5[port].pads[3] = (id4 < 0) ? NONE : JOYPAD0 + id4;\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown controller type %d\\n\", controller);\n\t\t\tbreak;\n\t}\n\n\tnewcontrollers[port] = NONE;\n}\n\nbool S9xVerifyControllers (void)\n{\n\tbool\tret = false;\n\tint\t\tport, i, used[NUMCTLS];\n\n\tfor (i = 0; i < NUMCTLS; used[i++] = 0) ;\n\n\tfor (port = 0; port < 2; port++)\n\t{\n\t\tswitch (i = newcontrollers[port])\n\t\t{\n\t\t\tcase MOUSE0:\n\t\t\tcase MOUSE1:\n\t\t\t\tif (!Settings.MouseMaster)\n\t\t\t\t{\n\t\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, \"Cannot select SNES Mouse: MouseMaster disabled\");\n\t\t\t\t\tnewcontrollers[port] = NONE;\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (used[i]++ > 0)\n\t\t\t\t{\n\t\t\t\t\tsnprintf(buf, sizeof(buf), \"Mouse%d used more than once! Disabling extra instances\", i - MOUSE0 + 1);\n\t\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, buf);\n\t\t\t\t\tnewcontrollers[port] = NONE;\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase SUPERSCOPE:\n\t\t\t\tif (!Settings.SuperScopeMaster)\n\t\t\t\t{\n\t\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, \"Cannot select SNES Superscope: SuperScopeMaster disabled\");\n\t\t\t\t\tnewcontrollers[port] = NONE;\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (used[i]++ > 0)\n\t\t\t\t{\n\t\t\t\t\tsnprintf(buf, sizeof(buf), \"Superscope used more than once! Disabling extra instances\");\n\t\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, buf);\n\t\t\t\t\tnewcontrollers[port] = NONE;\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase ONE_JUSTIFIER:\n\t\t\tcase TWO_JUSTIFIERS:\n\t\t\t\tif (!Settings.JustifierMaster)\n\t\t\t\t{\n\t\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, \"Cannot select Konami Justifier: JustifierMaster disabled\");\n\t\t\t\t\tnewcontrollers[port] = NONE;\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (used[ONE_JUSTIFIER]++ > 0)\n\t\t\t\t{\n\t\t\t\t\tsnprintf(buf, sizeof(buf), \"Justifier used more than once! Disabling extra instances\");\n\t\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, buf);\n\t\t\t\t\tnewcontrollers[port] = NONE;\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase MACSRIFLE:\n\t\t\t\tif (!Settings.MacsRifleMaster)\n\t\t\t\t{\n\t\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, \"Cannot select SNES M.A.C.S. Rifle: MacsRifleMaster disabled\");\n\t\t\t\t\tnewcontrollers[port] = NONE;\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (used[i]++ > 0)\n\t\t\t\t{\n\t\t\t\t\tsnprintf(buf, sizeof(buf), \"M.A.C.S. Rifle used more than once! Disabling extra instances\");\n\t\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, buf);\n\t\t\t\t\tnewcontrollers[port] = NONE;\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase MP5:\n\t\t\t\tif (!Settings.MultiPlayer5Master)\n\t\t\t\t{\n\t\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, \"Cannot select MP5: MultiPlayer5Master disabled\");\n\t\t\t\t\tnewcontrollers[port] = NONE;\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (mp5[port].pads[i] != NONE)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (used[mp5[port].pads[i] - JOYPAD0]++ > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsnprintf(buf, sizeof(buf), \"Joypad%d used more than once! Disabling extra instances\", mp5[port].pads[i] - JOYPAD0 + 1);\n\t\t\t\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, buf);\n\t\t\t\t\t\t\tmp5[port].pads[i] = NONE;\n\t\t\t\t\t\t\tret = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase JOYPAD0:\n\t\t\tcase JOYPAD1:\n\t\t\tcase JOYPAD2:\n\t\t\tcase JOYPAD3:\n\t\t\tcase JOYPAD4:\n\t\t\tcase JOYPAD5:\n\t\t\tcase JOYPAD6:\n\t\t\tcase JOYPAD7:\n\t\t\t\tif (used[i - JOYPAD0]++ > 0)\n\t\t\t\t{\n\t\t\t\t\tsnprintf(buf, sizeof(buf), \"Joypad%d used more than once! Disabling extra instances\", i - JOYPAD0 + 1);\n\t\t\t\t\tS9xMessage(S9X_CONFIG_INFO, S9X_ERROR, buf);\n\t\t\t\t\tnewcontrollers[port] = NONE;\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (ret);\n}\n\nvoid S9xGetController (int port, enum controllers *controller, int8 *id1, int8 *id2, int8 *id3, int8 *id4)\n{\n\tint\ti;\n\n\t*controller = CTL_NONE;\n\t*id1 = *id2 = *id3 = *id4 = -1;\n\n\tif (port < 0 || port > 1)\n\t\treturn;\n\n\tswitch (i = newcontrollers[port])\n\t{\n\t\tcase MP5:\n\t\t\t*controller = CTL_MP5;\n\t\t\t*id1 = (mp5[port].pads[0] == NONE) ? -1 : mp5[port].pads[0] - JOYPAD0;\n\t\t\t*id2 = (mp5[port].pads[1] == NONE) ? -1 : mp5[port].pads[1] - JOYPAD0;\n\t\t\t*id3 = (mp5[port].pads[2] == NONE) ? -1 : mp5[port].pads[2] - JOYPAD0;\n\t\t\t*id4 = (mp5[port].pads[3] == NONE) ? -1 : mp5[port].pads[3] - JOYPAD0;\n\t\t\treturn;\n\n\t\tcase JOYPAD0:\n\t\tcase JOYPAD1:\n\t\tcase JOYPAD2:\n\t\tcase JOYPAD3:\n\t\tcase JOYPAD4:\n\t\tcase JOYPAD5:\n\t\tcase JOYPAD6:\n\t\tcase JOYPAD7:\n\t\t\t*controller = CTL_JOYPAD;\n\t\t\t*id1 = i - JOYPAD0;\n\t\t\treturn;\n\n\t\tcase MOUSE0:\n\t\tcase MOUSE1:\n\t\t\t*controller = CTL_MOUSE;\n\t\t\t*id1 = i - MOUSE0;\n\t\t\treturn;\n\n\t\tcase SUPERSCOPE:\n\t\t\t*controller = CTL_SUPERSCOPE;\n\t\t\t*id1 = 1;\n\t\t\treturn;\n\n\t\tcase ONE_JUSTIFIER:\n\t\tcase TWO_JUSTIFIERS:\n\t\t\t*controller = CTL_JUSTIFIER;\n\t\t\t*id1 = i - ONE_JUSTIFIER;\n\t\t\treturn;\n\n\t\tcase MACSRIFLE:\n\t\t\t*controller = CTL_MACSRIFLE;\n\t\t\t*id1 = 1;\n\t\t\treturn;\n\t}\n}\n\nvoid S9xReportControllers (void)\n{\n\tstatic char\tmes[128];\n\tchar\t\t*c = mes;\n\n\tS9xVerifyControllers();\n\n\tfor (int port = 0; port < 2; port++)\n\t{\n\t\tc += sprintf(c, \"Port %d: \", port + 1);\n\n\t\tswitch (newcontrollers[port])\n\t\t{\n\t\t\tcase NONE:\n\t\t\t\tc += sprintf(c, \"<none>. \");\n\t\t\t\tbreak;\n\n\t\t\tcase MP5:\n\t\t\t\tc += sprintf(c, \"MP5 with pads\");\n\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (mp5[port].pads[i] == NONE)\n\t\t\t\t\t\tc += sprintf(c, \" <none>. \");\n\t\t\t\t\telse\n\t\t\t\t\t\tc += sprintf(c, \" #%d. \", mp5[port].pads[i] + 1 - JOYPAD0);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase JOYPAD0:\n\t\t\tcase JOYPAD1:\n\t\t\tcase JOYPAD2:\n\t\t\tcase JOYPAD3:\n\t\t\tcase JOYPAD4:\n\t\t\tcase JOYPAD5:\n\t\t\tcase JOYPAD6:\n\t\t\tcase JOYPAD7:\n\t\t\t\tc += sprintf(c, \"Pad #%d. \", (int) (newcontrollers[port] - JOYPAD0 + 1));\n\t\t\t\tbreak;\n\n\t\t\tcase MOUSE0:\n\t\t\tcase MOUSE1:\n\t\t\t\tc += sprintf(c, \"Mouse #%d. \", (int) (newcontrollers[port] - MOUSE0 + 1));\n\t\t\t\tbreak;\n\n\t\t\tcase SUPERSCOPE:\n\t\t\t\tif (port == 0)\n\t\t\t\t\tc += sprintf(c, \"Superscope (cannot fire). \");\n\t\t\t\telse\n\t\t\t\t\tc += sprintf(c, \"Superscope. \");\n\t\t\t\tbreak;\n\n\t\t\tcase ONE_JUSTIFIER:\n\t\t\t\tif (port == 0)\n\t\t\t\t\tc += sprintf(c, \"Blue Justifier (cannot fire). \");\n\t\t\t\telse\n\t\t\t\t\tc += sprintf(c, \"Blue Justifier. \");\n\t\t\t\tbreak;\n\n\t\t\tcase TWO_JUSTIFIERS:\n\t\t\t\tif (port == 0)\n\t\t\t\t\tc += sprintf(c, \"Blue and Pink Justifiers (cannot fire). \");\n\t\t\t\telse\n\t\t\t\t\tc += sprintf(c, \"Blue and Pink Justifiers. \");\n\t\t\t\tbreak;\n\n\t\t\tcase MACSRIFLE:\n\t\t\t\tif (port == 0)\n\t\t\t\t\tc += sprintf(c, \"M.A.C.S. Rifle (cannot fire). \");\n\t\t\t\telse\n\t\t\t\t\tc += sprintf(c, \"M.A.C.S. Rifle. \");\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tS9xMessage(S9X_INFO, S9X_CONFIG_INFO, mes);\n}\n\nchar * S9xGetCommandName (s9xcommand_t command)\n{\n\tstring\ts;\n\tchar\tc;\n\n\tswitch (command.type)\n\t{\n\t\tcase S9xButtonJoypad:\n\t\t\tif (command.button.joypad.buttons == 0)\n\t\t\t\treturn (strdup(\"None\"));\n\t\t\tif (command.button.joypad.buttons & 0x000f)\n\t\t\t\treturn (strdup(\"None\"));\n\n\t\t\ts = \"Joypad\";\n\t\t\ts += command.button.joypad.idx + 1;\n\n\t\t\tc = ' ';\n\t\t\tif (command.button.joypad.toggle)\t{ if (c) s += c; s += \"Toggle\"; c = 0; }\n\t\t\tif (command.button.joypad.sticky)\t{ if (c) s += c; s += \"Sticky\"; c = 0; }\n\t\t\tif (command.button.joypad.turbo )\t{ if (c) s += c; s += \"Turbo\";  c = 0; }\n\n\t\t\tc = ' ';\n\t\t\tif (command.button.joypad.buttons & SNES_UP_MASK    )\t{ s += c; s += \"Up\";     c = '+'; }\n\t\t\tif (command.button.joypad.buttons & SNES_DOWN_MASK  )\t{ s += c; s += \"Down\";   c = '+'; }\n\t\t\tif (command.button.joypad.buttons & SNES_LEFT_MASK  )\t{ s += c; s += \"Left\";   c = '+'; }\n\t\t\tif (command.button.joypad.buttons & SNES_RIGHT_MASK )\t{ s += c; s += \"Right\";  c = '+'; }\n\t\t\tif (command.button.joypad.buttons & SNES_A_MASK     )\t{ s += c; s += \"A\";      c = '+'; }\n\t\t\tif (command.button.joypad.buttons & SNES_B_MASK     )\t{ s += c; s += \"B\";      c = '+'; }\n\t\t\tif (command.button.joypad.buttons & SNES_X_MASK     )\t{ s += c; s += \"X\";      c = '+'; }\n\t\t\tif (command.button.joypad.buttons & SNES_Y_MASK     )\t{ s += c; s += \"Y\";      c = '+'; }\n\t\t\tif (command.button.joypad.buttons & SNES_TL_MASK    )\t{ s += c; s += \"L\";      c = '+'; }\n\t\t\tif (command.button.joypad.buttons & SNES_TR_MASK    )\t{ s += c; s += \"R\";      c = '+'; }\n\t\t\tif (command.button.joypad.buttons & SNES_START_MASK )\t{ s += c; s += \"Start\";  c = '+'; }\n\t\t\tif (command.button.joypad.buttons & SNES_SELECT_MASK)\t{ s += c; s += \"Select\"; c = '+'; }\n\n\t\t\tbreak;\n\n\t\tcase S9xButtonMouse:\n\t\t\tif (!command.button.mouse.left && !command.button.mouse.right)\n\t\t\t\treturn (strdup(\"None\"));\n\n\t\t\ts = \"Mouse\";\n\t\t\ts += command.button.mouse.idx + 1;\n\t\t\ts += \" \";\n\n\t\t\tif (command.button.mouse.left )\ts += \"L\";\n\t\t\tif (command.button.mouse.right)\ts += \"R\";\n\n\t\t\tbreak;\n\n\t\tcase S9xButtonSuperscope:\n\t\t\tif (!command.button.scope.fire && !command.button.scope.cursor && !command.button.scope.turbo && !command.button.scope.pause && !command.button.scope.aim_offscreen)\n\t\t\t\treturn (strdup(\"None\"));\n\n\t\t\ts = \"Superscope\";\n\n\t\t\tif (command.button.scope.aim_offscreen)\ts += \" AimOffscreen\";\n\n\t\t\tc = ' ';\n\t\t\tif (command.button.scope.fire  )\t{ s += c; s += \"Fire\";        c = '+'; }\n\t\t\tif (command.button.scope.cursor)\t{ s += c; s += \"Cursor\";      c = '+'; }\n\t\t\tif (command.button.scope.turbo )\t{ s += c; s += \"ToggleTurbo\"; c = '+'; }\n\t\t\tif (command.button.scope.pause )\t{ s += c; s += \"Pause\";       c = '+'; }\n\n\t\t\tbreak;\n\n\t\tcase S9xButtonJustifier:\n\t\t\tif (!command.button.justifier.trigger && !command.button.justifier.start && !command.button.justifier.aim_offscreen)\n\t\t\t\treturn (strdup(\"None\"));\n\n\t\t\ts = \"Justifier\";\n\t\t\ts += command.button.justifier.idx + 1;\n\n\t\t\tif (command.button.justifier.aim_offscreen)\ts += \" AimOffscreen\";\n\n\t\t\tc = ' ';\n\t\t\tif (command.button.justifier.trigger)\t{ s += c; s += \"Trigger\"; c = '+'; }\n\t\t\tif (command.button.justifier.start  )\t{ s += c; s += \"Start\";   c = '+'; }\n\n\t\t\tbreak;\n\n\t\tcase S9xButtonMacsRifle:\n\t\t\tif (!command.button.macsrifle.trigger)\n\t\t\t\treturn (strdup(\"None\"));\n\n\t\t\ts = \"MacsRifle\";\n\n\t\t\tc = ' ';\n\t\t\tif (command.button.macsrifle.trigger)\t{ s += c; s += \"Trigger\"; c = '+'; }\n\n\t\t\tbreak;\n\n\t\tcase S9xButtonCommand:\n\t\t\tif (command.button.command >= LAST_COMMAND)\n\t\t\t\treturn (strdup(\"None\"));\n\n\t\t\treturn (strdup(command_names[command.button.command]));\n\n\t\tcase S9xPointer:\n\t\t\tif (!command.pointer.aim_mouse0 && !command.pointer.aim_mouse1 && !command.pointer.aim_scope && !command.pointer.aim_justifier0 && !command.pointer.aim_justifier1 && !command.pointer.aim_macsrifle)\n\t\t\t\treturn (strdup(\"None\"));\n\n\t\t\ts = \"Pointer\";\n\n\t\t\tc = ' ';\n\t\t\tif (command.pointer.aim_mouse0    )\t{ s += c; s += \"Mouse1\";     c = '+'; }\n\t\t\tif (command.pointer.aim_mouse1    )\t{ s += c; s += \"Mouse2\";     c = '+'; }\n\t\t\tif (command.pointer.aim_scope     )\t{ s += c; s += \"Superscope\"; c = '+'; }\n\t\t\tif (command.pointer.aim_justifier0)\t{ s += c; s += \"Justifier1\"; c = '+'; }\n\t\t\tif (command.pointer.aim_justifier1)\t{ s += c; s += \"Justifier2\"; c = '+'; }\n\t\t\tif (command.pointer.aim_macsrifle)  { s += c; s += \"MacsRifle\";  c = '+'; }\n\n\t\t\tbreak;\n\n\t\tcase S9xButtonPseudopointer:\n\t\t\tif (!command.button.pointer.UD && !command.button.pointer.LR)\n\t\t\t\treturn (strdup(\"None\"));\n\t\t\tif (command.button.pointer.UD == -2 || command.button.pointer.LR == -2)\n\t\t\t\treturn (strdup(\"None\"));\n\n\t\t\ts = \"ButtonToPointer \";\n\t\t\ts += command.button.pointer.idx + 1;\n\n\t\t\tif (command.button.pointer.UD)\ts += (command.button.pointer.UD == 1) ? 'd' : 'u';\n\t\t\tif (command.button.pointer.LR)\ts += (command.button.pointer.LR == 1) ? 'r' : 'l';\n\n\t\t\ts += \" \";\n\t\t\ts += speed_names[command.button.pointer.speed_type];\n\n\t\t\tbreak;\n\n\t\tcase S9xAxisJoypad:\n\t\t\ts = \"Joypad\";\n\t\t\ts += command.axis.joypad.idx + 1;\n\t\t\ts += \" Axis \";\n\n\t\t\tswitch (command.axis.joypad.axis)\n\t\t\t{\n\t\t\t\tcase 0:\ts += (command.axis.joypad.invert ? \"Right/Left\" : \"Left/Right\");\tbreak;\n\t\t\t\tcase 1:\ts += (command.axis.joypad.invert ? \"Down/Up\"    : \"Up/Down\"   );\tbreak;\n\t\t\t\tcase 2:\ts += (command.axis.joypad.invert ? \"A/Y\"        : \"Y/A\"       );\tbreak;\n\t\t\t\tcase 3:\ts += (command.axis.joypad.invert ? \"B/X\"        : \"X/B\"       );\tbreak;\n\t\t\t\tcase 4:\ts += (command.axis.joypad.invert ? \"R/L\"        : \"L/R\"       );\tbreak;\n\t\t\t\tdefault:\treturn (strdup(\"None\"));\n\t\t\t}\n\n\t\t\ts += \" T=\";\n\t\t\ts += int((command.axis.joypad.threshold + 1) * 1000 / 256) / 10.0;\n\t\t\ts += \"%\";\n\n\t\t\tbreak;\n\n\t\tcase S9xAxisPseudopointer:\n\t\t\ts = \"AxisToPointer \";\n\t\t\ts += command.axis.pointer.idx + 1;\n\t\t\ts += command.axis.pointer.HV ? 'v' : 'h';\n\t\t\ts += \" \";\n\n\t\t\tif (command.axis.pointer.invert)\ts += \"-\";\n\n\t\t\ts += speed_names[command.axis.pointer.speed_type];\n\n\t\t\tbreak;\n\n\t\tcase S9xAxisPseudobuttons:\n\t\t\ts = \"AxisToButtons \";\n\t\t\ts += command.axis.button.negbutton;\n\t\t\ts += \"/\";\n\t\t\ts += command.axis.button.posbutton;\n\t\t\ts += \" T=\";\n\t\t\ts += int((command.axis.button.threshold + 1) * 1000 / 256) / 10.0;\n\t\t\ts += \"%\";\n\n\t\t\tbreak;\n\n\t\tcase S9xButtonPort:\n\t\tcase S9xAxisPort:\n\t\tcase S9xPointerPort:\n\t\t\treturn (strdup(\"BUG: Port should have handled this instead of calling S9xGetCommandName()\"));\n\n\t\tcase S9xNoMapping:\n\t\t\treturn (strdup(\"None\"));\n\n\t\tcase S9xButtonMulti:\n\t\t{\n\t\t\tif (command.button.multi_idx >= (int) multis.size())\n\t\t\t\treturn (strdup(\"None\"));\n\n\t\t\ts = \"{\";\n\t\t\tif (multis[command.button.multi_idx]->multi_press)\ts = \"+{\";\n\n\t\t\tbool\tsep = false;\n\n\t\t\tfor (s9xcommand_t *m = multis[command.button.multi_idx]; m->multi_press != 3; m++)\n\t\t\t{\n\t\t\t\tif (m->type == S9xNoMapping)\n\t\t\t\t{\n\t\t\t\t\ts += \";\";\n\t\t\t\t\tsep = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (sep)\t\t\t\t\ts += \",\";\n\t\t\t\t\tif (m->multi_press == 1)\ts += \"+\";\n\t\t\t\t\tif (m->multi_press == 2)\ts += \"-\";\n\n\t\t\t\t\ts += S9xGetCommandName(*m);\n\t\t\t\t\tsep = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts += \"}\";\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\treturn (strdup(\"BUG: Unknown command type\"));\n\t}\n\n\treturn (strdup(s.c_str()));\n}\n\nstatic bool strless (const char *a, const char *b)\n{\n\treturn (strcmp(a, b) < 0);\n}\n\nstatic int findstr (const char *needle, const char **haystack, int numstr)\n{\n\tconst char\t**r;\n\n\tr = lower_bound(haystack, haystack + numstr, needle, strless);\n\tif (r >= haystack + numstr || strcmp(needle, *r))\n\t\treturn (-1);\n\n\treturn (r - haystack);\n}\n\nstatic int get_threshold (const char **ss)\n{\n\tconst char\t*s = *ss;\n\tint\t\t\ti;\n\n\tif (s[0] != 'T' || s[1] != '=')\n\t\treturn (-1);\n\n\ts += 2;\n\ti = 0;\n\n\tif (s[0] == '0')\n\t{\n\t\tif (s[1] != '.')\n\t\t\treturn (-1);\n\n\t\ts++;\n\t}\n\telse\n\t{\n\t\tdo\n\t\t{\n\t\t\tif (*s < '0' || *s > '9')\n\t\t\t\treturn (-1);\n\n\t\t\ti = i * 10 + 10 * (*s - '0');\n\t\t\tif (i > 1000)\n\t\t\t\treturn (-1);\n\n\t\t\ts++;\n\t\t}\n\t\twhile (*s != '.' && *s != '%');\n\t}\n\n\tif (*s == '.')\n\t{\n\t\tif (s[1] < '0' || s[1] > '9' || s[2] != '%')\n\t\t\treturn (-1);\n\n\t\ti += s[1] - '0';\n\t}\n\n\tif (i > 1000)\n\t\treturn (-1);\n\n\t*ss = s;\n\n\treturn (i);\n}\n\ns9xcommand_t S9xGetCommandT (const char *name)\n{\n\ts9xcommand_t\tcmd;\n\tint\t\t\t\ti, j;\n\tconst char\t\t*s;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.type         = S9xBadMapping;\n\tcmd.multi_press  = 0;\n\tcmd.button_norpt = 0;\n\n\tif (!strcmp(name, \"None\"))\n\t\tcmd.type = S9xNoMapping;\n\telse if (!strncmp(name, \"Joypad\", 6))\n\t{\n\t\tif (name[6] < '1' || name[6] > '8' || name[7] != ' ')\n\t\t\treturn (cmd);\n\n\t\tif (!strncmp(name + 8, \"Axis \", 5))\n\t\t{\n\t\t\tcmd.axis.joypad.idx = name[6] - '1';\n\t\t\ts = name + 13;\n\n\t\t\tif (!strncmp(s, \"Left/Right \", 11))\t{ j = 0; i = 0; s += 11; }\n\t\t\telse if (!strncmp(s, \"Right/Left \", 11))\t{ j = 0; i = 1; s += 11; }\n\t\t\telse if (!strncmp(s, \"Up/Down \",     8))\t{ j = 1; i = 0; s +=  8; }\n\t\t\telse if (!strncmp(s, \"Down/Up \",     8))\t{ j = 1; i = 1; s +=  8; }\n\t\t\telse if (!strncmp(s, \"Y/A \",         4))\t{ j = 2; i = 0; s +=  4; }\n\t\t\telse if (!strncmp(s, \"A/Y \",         4))\t{ j = 2; i = 1; s +=  4; }\n\t\t\telse if (!strncmp(s, \"X/B \",         4))\t{ j = 3; i = 0; s +=  4; }\n\t\t\telse if (!strncmp(s, \"B/X \",         4))\t{ j = 3; i = 1; s +=  4; }\n\t\t\telse if (!strncmp(s, \"L/R \",         4))\t{ j = 4; i = 0; s +=  4; }\n\t\t\telse if (!strncmp(s, \"R/L \",         4))\t{ j = 4; i = 1; s +=  4; }\n\t\t\telse\n\t\t\t\treturn (cmd);\n\n\t\t\tcmd.axis.joypad.axis      = j;\n\t\t\tcmd.axis.joypad.invert    = i;\n\t\t\ti = get_threshold(&s);\n\t\t\tif (i < 0)\n\t\t\t\treturn (cmd);\n\t\t\tcmd.axis.joypad.threshold = (i - 1) * 256 / 1000;\n\n\t\t\tcmd.type = S9xAxisJoypad;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcmd.button.joypad.idx = name[6] - '1';\n\t\t\ts = name + 8;\n\t\t\ti = 0;\n\n\t\t\tif ((cmd.button.joypad.toggle = strncmp(s, \"Toggle\", 6) ? 0 : 1))\ts += i = 6;\n\t\t\tif ((cmd.button.joypad.sticky = strncmp(s, \"Sticky\", 6) ? 0 : 1))\ts += i = 6;\n\t\t\tif ((cmd.button.joypad.turbo  = strncmp(s, \"Turbo\",  5) ? 0 : 1))\ts += i = 5;\n\n\t\t\tif (cmd.button.joypad.toggle && !(cmd.button.joypad.sticky || cmd.button.joypad.turbo))\n\t\t\t\treturn (cmd);\n\n\t\t\tif (i)\n\t\t\t{\n\t\t\t\tif (*s != ' ')\n\t\t\t\t\treturn (cmd);\n\t\t\t\ts++;\n\t\t\t}\n\n\t\t\ti = 0;\n\n\t\t\tif (!strncmp(s, \"Up\",     2))\t{ i |= SNES_UP_MASK;     s += 2; if (*s == '+') s++; }\n\t\t\tif (!strncmp(s, \"Down\",   4))\t{ i |= SNES_DOWN_MASK;   s += 4; if (*s == '+') s++; }\n\t\t\tif (!strncmp(s, \"Left\",   4))\t{ i |= SNES_LEFT_MASK;   s += 4; if (*s == '+') s++; }\n\t\t\tif (!strncmp(s, \"Right\",  5))\t{ i |= SNES_RIGHT_MASK;  s += 5; if (*s == '+') s++; }\n\n\t\t\tif (*s == 'A')\t{ i |= SNES_A_MASK;  s++; if (*s == '+') s++; }\n\t\t\tif (*s == 'B')\t{ i |= SNES_B_MASK;  s++; if (*s == '+') s++; }\n\t\t\tif (*s == 'X')\t{ i |= SNES_X_MASK;  s++; if (*s == '+') s++; }\n\t\t\tif (*s == 'Y')\t{ i |= SNES_Y_MASK;  s++; if (*s == '+') s++; }\n\t\t\tif (*s == 'L')\t{ i |= SNES_TL_MASK; s++; if (*s == '+') s++; }\n\t\t\tif (*s == 'R')\t{ i |= SNES_TR_MASK; s++; if (*s == '+') s++; }\n\n\t\t\tif (!strncmp(s, \"Start\",  5))\t{ i |= SNES_START_MASK;  s += 5; if (*s == '+') s++; }\n\t\t\tif (!strncmp(s, \"Select\", 6))\t{ i |= SNES_SELECT_MASK; s += 6; }\n\n\t\t\tif (i == 0 || *s != 0 || *(s - 1) == '+')\n\t\t\t\treturn (cmd);\n\n\t\t\tcmd.button.joypad.buttons = i;\n\n\t\t\tcmd.type = S9xButtonJoypad;\n\t\t}\n\t}\n\telse\n\tif (!strncmp(name, \"Mouse\", 5))\n\t{\n\t\tif (name[5] < '1' || name[5] > '2' || name[6] != ' ')\n\t\t\treturn (cmd);\n\n\t\tcmd.button.mouse.idx = name[5] - '1';\n\t\ts = name + 7;\n\t\ti = 0;\n\n\t\tif ((cmd.button.mouse.left  = (*s == 'L')))\ts += i = 1;\n\t\tif ((cmd.button.mouse.right = (*s == 'R')))\ts += i = 1;\n\n\t\tif (i == 0 || *s != 0)\n\t\t\treturn (cmd);\n\n\t\tcmd.type = S9xButtonMouse;\n\t}\n\telse\n\tif (!strncmp(name, \"Superscope \", 11))\n\t{\n\t\ts = name + 11;\n\t\ti = 0;\n\n\t\tif ((cmd.button.scope.aim_offscreen     = strncmp(s, \"AimOffscreen\", 12) ? 0 : 1))\t{ s += i = 12; if (*s == ' ') s++; else if (*s != 0) return (cmd); }\n\t\tif ((cmd.button.scope.fire              = strncmp(s, \"Fire\",          4) ? 0 : 1))\t{ s += i =  4; if (*s == '+') s++; }\n\t\tif ((cmd.button.scope.cursor            = strncmp(s, \"Cursor\",        6) ? 0 : 1))\t{ s += i =  6; if (*s == '+') s++; }\n\t\tif ((cmd.button.scope.turbo             = strncmp(s, \"ToggleTurbo\",  11) ? 0 : 1))\t{ s += i = 11; if (*s == '+') s++; }\n\t\tif ((cmd.button.scope.pause             = strncmp(s, \"Pause\",         5) ? 0 : 1))\t{ s += i =  5; }\n\n\t\tif (i == 0 || *s != 0 || *(s - 1) == '+')\n\t\t\treturn (cmd);\n\n\t\tcmd.type = S9xButtonSuperscope;\n\t}\n\telse\n\tif (!strncmp(name, \"Justifier\", 9))\n\t{\n\t\tif (name[9] < '1' || name[9] > '2' || name[10] != ' ')\n\t\t\treturn (cmd);\n\n\t\tcmd.button.justifier.idx = name[9] - '1';\n\t\ts = name + 11;\n\t\ti = 0;\n\n\t\tif ((cmd.button.justifier.aim_offscreen = strncmp(s, \"AimOffscreen\", 12) ? 0 : 1))\t{ s += i = 12; if (*s == ' ') s++; else if (*s != 0) return (cmd); }\n\t\tif ((cmd.button.justifier.trigger       = strncmp(s, \"Trigger\",       7) ? 0 : 1))\t{ s += i =  7; if (*s == '+') s++; }\n\t\tif ((cmd.button.justifier.start         = strncmp(s, \"Start\",         5) ? 0 : 1))\t{ s += i =  5; }\n\n\t\tif (i == 0 || *s != 0 || *(s - 1) == '+')\n\t\t\treturn (cmd);\n\n\t\tcmd.type = S9xButtonJustifier;\n\t}\n\telse\n\tif (!strncmp(name, \"MacsRifle \", 10))\n\t{\n\t\ts = name + 10;\n\t\ti = 0;\n\n\t\tif ((cmd.button.macsrifle.trigger = strncmp(s, \"Trigger\", 7) ? 0 : 1))\t{ s += i =  7; }\n\n\t\tif (i == 0 || *s != 0 || *(s - 1) == '+')\n\t\t\treturn (cmd);\n\n\t\tcmd.type = S9xButtonMacsRifle;\n\t}\n\telse\n\tif (!strncmp(name, \"Pointer \", 8))\n\t{\n\t\ts = name + 8;\n\t\ti = 0;\n\n\t\tif ((cmd.pointer.aim_mouse0     = strncmp(s, \"Mouse1\",      6) ? 0 : 1))\t{ s += i =  6; if (*s == '+') s++; }\n\t\tif ((cmd.pointer.aim_mouse1     = strncmp(s, \"Mouse2\",      6) ? 0 : 1))\t{ s += i =  6; if (*s == '+') s++; }\n\t\tif ((cmd.pointer.aim_scope      = strncmp(s, \"Superscope\", 10) ? 0 : 1))\t{ s += i = 10; if (*s == '+') s++; }\n\t\tif ((cmd.pointer.aim_justifier0 = strncmp(s, \"Justifier1\", 10) ? 0 : 1))\t{ s += i = 10; if (*s == '+') s++; }\n\t\tif ((cmd.pointer.aim_justifier1 = strncmp(s, \"Justifier2\", 10) ? 0 : 1))\t{ s += i = 10; if (*s == '+') s++; }\n\t\tif ((cmd.pointer.aim_macsrifle  = strncmp(s, \"MacsRifle\",   9) ? 0 : 1))\t{ s += i =  9; }\n\n\t\tif (i == 0 || *s != 0 || *(s - 1) == '+')\n\t\t\treturn (cmd);\n\n\t\tcmd.type = S9xPointer;\n\t}\n\telse\n\tif (!strncmp(name, \"ButtonToPointer \", 16))\n\t{\n\t\tif (name[16] < '1' || name[16] > '8')\n\t\t\treturn (cmd);\n\n\t\tcmd.button.pointer.idx = name[16] - '1';\n\t\ts = name + 17;\n\t\ti = 0;\n\n\t\tif ((cmd.button.pointer.UD = (*s == 'u' ? -1 : (*s == 'd' ? 1 : 0))))\ts += i = 1;\n\t\tif ((cmd.button.pointer.LR = (*s == 'l' ? -1 : (*s == 'r' ? 1 : 0))))\ts += i = 1;\n\n\t\tif (i == 0 || *(s++) != ' ')\n\t\t\treturn (cmd);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (!strcmp(s, speed_names[i]))\n\t\t\t\tbreak;\n\t\tif (i > 3)\n\t\t\treturn (cmd);\n\n\t\tcmd.button.pointer.speed_type = i;\n\n\t\tcmd.type = S9xButtonPseudopointer;\n\t}\n\telse\n\tif (!strncmp(name, \"AxisToPointer \", 14))\n\t{\n\t\tif (name[14] < '1' || name[14] > '8')\n\t\t\treturn (cmd);\n\n\t\tcmd.axis.pointer.idx = name[14] - '1';\n\t\ts= name + 15;\n\t\ti = 0;\n\n\t\tif (*s == 'h')\n\t\t\tcmd.axis.pointer.HV = 0;\n\t\telse if (*s == 'v')\n\t\t\tcmd.axis.pointer.HV = 1;\n\t\telse\n\t\t\treturn (cmd);\n\n\t\tif (s[1] != ' ')\n\t\t\treturn (cmd);\n\n\t\ts += 2;\n\t\tif ((cmd.axis.pointer.invert = *s == '-'))\n\t\t\ts++;\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (!strcmp(s, speed_names[i]))\n\t\t\t\tbreak;\n\t\tif (i > 3)\n\t\t\treturn (cmd);\n\n\t\tcmd.axis.pointer.speed_type = i;\n\n\t\tcmd.type = S9xAxisPseudopointer;\n\t}\n\telse\n\tif (!strncmp(name, \"AxisToButtons \", 14))\n\t{\n\t\ts = name + 14;\n\n\t\tif (s[0] == '0')\n\t\t{\n\t\t\tif (s[1] != '/')\n\t\t\t\treturn (cmd);\n\n\t\t\tcmd.axis.button.negbutton = 0;\n\t\t\ts += 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (*s < '0' || *s > '9')\n\t\t\t\t\treturn (cmd);\n\n\t\t\t\ti = i * 10 + *s - '0';\n\t\t\t\tif (i > 255)\n\t\t\t\t\treturn (cmd);\n\t\t\t}\n\t\t\twhile (*++s != '/');\n\n\t\t\tcmd.axis.button.negbutton = i;\n\t\t\ts++;\n\t\t}\n\n\t\tif (s[0] == '0')\n\t\t{\n\t\t\tif (s[1] != ' ')\n\t\t\t\treturn (cmd);\n\n\t\t\tcmd.axis.button.posbutton = 0;\n\t\t\ts += 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (*s < '0' || *s > '9')\n\t\t\t\t\treturn (cmd);\n\n\t\t\t\ti = i * 10 + *s - '0';\n\t\t\t\tif (i > 255)\n\t\t\t\t\treturn (cmd);\n\t\t\t}\n\t\t\twhile (*++s != ' ');\n\n\t\t\tcmd.axis.button.posbutton = i;\n\t\t\ts++;\n\t\t}\n\n\t\ti = get_threshold(&s);\n\t\tif (i < 0)\n\t\t\treturn (cmd);\n\t\tcmd.axis.button.threshold = (i - 1) * 256 / 1000;\n\n\t\tcmd.type = S9xAxisPseudobuttons;\n\t}\n\telse\n\tif (!strncmp(name, \"MULTI#\", 6))\n\t{\n\t\ti = strtol(name + 6, (char **) &s, 10);\n\t\tif (s != NULL && *s != '\\0')\n\t\t\treturn (cmd);\n\t\tif (i >= (int) multis.size())\n\t\t\treturn (cmd);\n\n\t\tcmd.button.multi_idx = i;\n\t\tcmd.type = S9xButtonMulti;\n\t}\n\telse\n\tif (((name[0] == '+' && name[1] == '{') || name[0] == '{') && name[strlen(name) - 1] == '}')\n\t{\n\t\tif (multis.size() > 2147483640)\n\t\t{\n\t\t\tfprintf(stderr, \"Too many multis!\");\n\t\t\treturn (cmd);\n\t\t}\n\n\t\tstring\tx;\n\t\tint\t\tn;\n\n\t\tj = 2;\n\t\tfor (i = (name[0] == '+') ? 2 : 1; name[i] != '\\0'; i++)\n\t\t{\n\t\t\tif (name[i] == ',' || name[i] == ';')\n\t\t\t{\n\t\t\t\tif (name[i] == ';')\n\t\t\t\t\tj++;\n\t\t\t\tif (++j > 2147483640)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr, \"Multi too long!\");\n\t\t\t\t\treturn (cmd);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (name[i] == '{')\n\t\t\t\treturn (cmd);\n\t\t}\n\n\t\ts9xcommand_t\t*c = (s9xcommand_t *) calloc(j, sizeof(s9xcommand_t));\n\t\tif (c == NULL)\n\t\t{\n\t\t\tperror(\"malloc error while parsing multi\");\n\t\t\treturn (cmd);\n\t\t}\n\n\t\tn = 0;\n\t\ti = (name[0] == '+') ? 2 : 1;\n\n\t\tdo\n\t\t{\n\t\t\tif (name[i] == ';')\n\t\t\t{\n\t\t\t\tc[n].type         = S9xNoMapping;\n\t\t\t\tc[n].multi_press  = 0;\n\t\t\t\tc[n].button_norpt = 0;\n\n\t\t\t\tj = i;\n\t\t\t}\n\t\t\telse if (name[i] == ',')\n\t\t\t{\n\t\t\t\tfree(c);\n\t\t\t\treturn (cmd);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint8\tpress = 0;\n\n\t\t\t\tif (name[0] == '+')\n\t\t\t\t{\n\t\t\t\t\tif (name[i] == '+')\n\t\t\t\t\t\tpress = 1;\n\t\t\t\t\telse if (name[i] == '-')\n\t\t\t\t\t\tpress = 2;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfree(c);\n\t\t\t\t\t\treturn (cmd);\n\t\t\t\t\t}\n\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\tfor (j = i; name[j] != ';' && name[j] != ',' && name[j] != '}'; j++) ;\n\n\t\t\t\tx.assign(name + i, j - i);\n\t\t\t\tc[n] = S9xGetCommandT(x.c_str());\n\t\t\t\tc[n].multi_press = press;\n\n\t\t\t\tif (maptype(c[n].type) != MAP_BUTTON)\n\t\t\t\t{\n\t\t\t\t\tfree(c);\n\t\t\t\t\treturn (cmd);\n\t\t\t\t}\n\n\t\t\t\tif (name[j] == ';')\n\t\t\t\t\tj--;\n\t\t\t}\n\n\t\t\ti = j + 1;\n\t\t\tn++;\n\t\t}\n\t\twhile (name[i] != '\\0');\n\n\t\tc[n].type        = S9xNoMapping;\n\t\tc[n].multi_press = 3;\n\n\t\tmultis.push_back(c);\n\n\t\tcmd.button.multi_idx = multis.size() - 1;\n\t\tcmd.type = S9xButtonMulti;\n\t}\n\telse\n\t{\n\t\ti = findstr(name, command_names, LAST_COMMAND);\n\t\tif (i < 0)\n\t\t\treturn (cmd);\n\n\t\tcmd.type = S9xButtonCommand;\n\t\tcmd.button.command = i;\n\t}\n\n\treturn (cmd);\n}\n\nconst char ** S9xGetAllSnes9xCommands (void)\n{\n\treturn (command_names);\n}\n\ns9xcommand_t S9xGetMapping (uint32 id)\n{\n\tif (keymap.count(id) == 0)\n\t{\n\t\ts9xcommand_t\tcmd;\n\t\tcmd.type = S9xNoMapping;\n\t\treturn (cmd);\n\t}\n\telse\n\t\treturn (keymap[id]);\n}\n\nstatic const char * maptypename (int t)\n{\n\tswitch (t)\n\t{\n\t\tcase MAP_NONE:\t\treturn (\"unmapped\");\n\t\tcase MAP_BUTTON:\treturn (\"button\");\n\t\tcase MAP_AXIS:\t\treturn (\"axis\");\n\t\tcase MAP_POINTER:\treturn (\"pointer\");\n\t\tdefault:\t\t\treturn (\"unknown\");\n\t}\n}\n\nvoid S9xUnmapID (uint32 id)\n{\n\tfor (int i = 0; i < NUMCTLS + 1; i++)\n\t\tpollmap[i].erase(id);\n\n\tif (mouse[0].ID     == id)\tmouse[0].ID     = InvalidControlID;\n\tif (mouse[1].ID     == id)\tmouse[1].ID     = InvalidControlID;\n\tif (superscope.ID   == id)\tsuperscope.ID   = InvalidControlID;\n\tif (justifier.ID[0] == id)\tjustifier.ID[0] = InvalidControlID;\n\tif (justifier.ID[1] == id)\tjustifier.ID[1] = InvalidControlID;\n\tif (macsrifle.ID    == id)\tmacsrifle.ID    = InvalidControlID;\n\n\tif (id >= PseudoPointerBase)\n\t\tpseudopointer[id - PseudoPointerBase].mapped = false;\n\n\tkeymap.erase(id);\n}\n\nbool S9xMapButton (uint32 id, s9xcommand_t mapping, bool poll)\n{\n\tint\tt;\n\n\tif (id == InvalidControlID)\n\t{\n\t\tfprintf(stderr, \"Cannot map InvalidControlID\\n\");\n\t\treturn (false);\n\t}\n\n\tt = maptype(mapping.type);\n\n\tif (t == MAP_NONE)\n\t{\n\t\tS9xUnmapID(id);\n\t\treturn (true);\n\t}\n\n\tif (t != MAP_BUTTON)\n\t\treturn (false);\n\n\tt = maptype(S9xGetMapping(id).type);\n\n\tif (t != MAP_NONE && t != MAP_BUTTON)\n\t\tfprintf(stderr, \"WARNING: Remapping ID 0x%08x from %s to button\\n\", id, maptypename(t));\n\n\tif (id >= PseudoPointerBase)\n\t{\n\t\tfprintf(stderr, \"ERROR: Refusing to map pseudo-pointer #%d as a button\\n\", id - PseudoPointerBase);\n\t\treturn (false);\n\t}\n\n\tt = -1;\n\n\tif (poll)\n\t{\n\t\tif (id >= PseudoButtonBase)\n\t\t\tfprintf(stderr, \"INFO: Ignoring attempt to set pseudo-button #%d to polling\\n\", id - PseudoButtonBase);\n\t\telse\n\t\t{\n\t\t\tswitch (mapping.type)\n\t\t\t{\n\t\t\t\tcase S9xButtonJoypad:\n\t\t\t\t\tt = JOYPAD0 + mapping.button.joypad.idx;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase S9xButtonMouse:\n\t\t\t\t\tt = MOUSE0 + mapping.button.mouse.idx;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase S9xButtonSuperscope:\n\t\t\t\t\tt = SUPERSCOPE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase S9xButtonJustifier:\n\t\t\t\t\tt = ONE_JUSTIFIER + mapping.button.justifier.idx;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase S9xButtonMacsRifle:\n\t\t\t\t\tt = MACSRIFLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase S9xButtonCommand:\n\t\t\t\tcase S9xButtonPseudopointer:\n\t\t\t\tcase S9xButtonPort:\n\t\t\t\tcase S9xButtonMulti:\n\t\t\t\t\tt = POLL_ALL;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tS9xUnmapID(id);\n\n\tkeymap[id] = mapping;\n\n\tif (t >= 0)\n\t\tpollmap[t].insert(id);\n\n\treturn (true);\n}\n\nvoid S9xReportButton (uint32 id, bool pressed)\n{\n\tif (keymap.count(id) == 0)\n\t\treturn;\n\n\tif (keymap[id].type == S9xNoMapping)\n\t\treturn;\n\n\tif (maptype(keymap[id].type) != MAP_BUTTON)\n\t{\n\t\tfprintf(stderr, \"ERROR: S9xReportButton called on %s ID 0x%08x\\n\", maptypename(maptype(keymap[id].type)), id);\n\t\treturn;\n\t}\n\n\tif (keymap[id].type == S9xButtonCommand)\t// skips the \"already-pressed check\" unless it's a command, as a hack to work around the following problem:\n\t\tif (keymap[id].button_norpt == pressed)\t// FIXME: this makes the controls \"stick\" after loading a savestate while recording a movie and holding any button\n\t\t\treturn;\n\n\tkeymap[id].button_norpt = pressed;\n\n\tS9xApplyCommand(keymap[id], pressed, 0);\n}\n\nbool S9xMapPointer (uint32 id, s9xcommand_t mapping, bool poll)\n{\n\tint\tt;\n\n\tif (id == InvalidControlID)\n\t{\n\t\tfprintf(stderr, \"Cannot map InvalidControlID\\n\");\n\t\treturn (false);\n\t}\n\n\tt = maptype(mapping.type);\n\n\tif (t == MAP_NONE)\n\t{\n\t\tS9xUnmapID(id);\n\t\treturn (true);\n\t}\n\n\tif (t != MAP_POINTER)\n\t\treturn (false);\n\n\tt = maptype(S9xGetMapping(id).type);\n\n\tif (t != MAP_NONE && t != MAP_POINTER)\n\t\tfprintf(stderr, \"WARNING: Remapping ID 0x%08x from %s to pointer\\n\", id, maptypename(t));\n\n\tif (id < PseudoPointerBase && id >= PseudoButtonBase)\n\t{\n\t\tfprintf(stderr, \"ERROR: Refusing to map pseudo-button #%d as a pointer\\n\", id - PseudoButtonBase);\n\t\treturn (false);\n\t}\n\n\tif (mapping.type == S9xPointer)\n\t{\n\t\tif (mapping.pointer.aim_mouse0 && mouse[0].ID != InvalidControlID && mouse[0].ID != id)\n\t\t{\n\t\t\tfprintf(stderr, \"ERROR: Rejecting attempt to control Mouse1 with two pointers\\n\");\n\t\t\treturn (false);\n\t\t}\n\n\t\tif (mapping.pointer.aim_mouse1 && mouse[1].ID != InvalidControlID && mouse[1].ID != id)\n\t\t{\n\t\t\tfprintf(stderr, \"ERROR: Rejecting attempt to control Mouse2 with two pointers\\n\");\n\t\t\treturn (false);\n\t\t}\n\n\t\tif (mapping.pointer.aim_scope && superscope.ID != InvalidControlID && superscope.ID != id)\n\t\t{\n\t\t\tfprintf(stderr, \"ERROR: Rejecting attempt to control SuperScope with two pointers\\n\");\n\t\t\treturn (false);\n\t\t}\n\n\t\tif (mapping.pointer.aim_justifier0 && justifier.ID[0] != InvalidControlID && justifier.ID[0] != id)\n\t\t{\n\t\t\tfprintf(stderr, \"ERROR: Rejecting attempt to control Justifier1 with two pointers\\n\");\n\t\t\treturn (false);\n\t\t}\n\n\t\tif (mapping.pointer.aim_justifier1 && justifier.ID[1] != InvalidControlID && justifier.ID[1] != id)\n\t\t{\n\t\t\tfprintf(stderr, \"ERROR: Rejecting attempt to control Justifier2 with two pointers\\n\");\n\t\t\treturn (false);\n\t\t}\n\n\t\tif (mapping.pointer.aim_macsrifle && macsrifle.ID != InvalidControlID && macsrifle.ID != id)\n\t\t{\n\t\t\tfprintf(stderr, \"ERROR: Rejecting attempt to control M.A.C.S. Rifle with two pointers\\n\");\n\t\t\treturn (false);\n\t\t}\n\t}\n\n\tS9xUnmapID(id);\n\n\tif (poll)\n\t{\n\t\tif (id >= PseudoPointerBase)\n\t\t\tfprintf(stderr, \"INFO: Ignoring attempt to set pseudo-pointer #%d to polling\\n\", id - PseudoPointerBase);\n\t\telse\n\t\t{\n\t\t\tswitch (mapping.type)\n\t\t\t{\n\t\t\t\tcase S9xPointer:\n\t\t\t\t\tif (mapping.pointer.aim_mouse0    )\tpollmap[MOUSE0        ].insert(id);\n\t\t\t\t\tif (mapping.pointer.aim_mouse1    )\tpollmap[MOUSE1        ].insert(id);\n\t\t\t\t\tif (mapping.pointer.aim_scope     )\tpollmap[SUPERSCOPE    ].insert(id);\n\t\t\t\t\tif (mapping.pointer.aim_justifier0)\tpollmap[ONE_JUSTIFIER ].insert(id);\n\t\t\t\t\tif (mapping.pointer.aim_justifier1)\tpollmap[TWO_JUSTIFIERS].insert(id);\n\t\t\t\t\tif (mapping.pointer.aim_macsrifle )\tpollmap[MACSRIFLE     ].insert(id);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase S9xPointerPort:\n\t\t\t\t\tpollmap[POLL_ALL].insert(id);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (id >= PseudoPointerBase)\n\t\tpseudopointer[id - PseudoPointerBase].mapped = true;\n\n\tkeymap[id] = mapping;\n\n\tif (mapping.pointer.aim_mouse0    )\tmouse[0].ID     = id;\n\tif (mapping.pointer.aim_mouse1    )\tmouse[1].ID     = id;\n\tif (mapping.pointer.aim_scope     )\tsuperscope.ID   = id;\n\tif (mapping.pointer.aim_justifier0)\tjustifier.ID[0] = id;\n\tif (mapping.pointer.aim_justifier1)\tjustifier.ID[1] = id;\n\tif (mapping.pointer.aim_macsrifle )\tmacsrifle.ID    = id;\n\n\treturn (true);\n}\n\nvoid S9xReportPointer (uint32 id, int16 x, int16 y)\n{\n\tif (keymap.count(id) == 0)\n\t\treturn;\n\n\tif (keymap[id].type == S9xNoMapping)\n\t\treturn;\n\n\tif (maptype(keymap[id].type) != MAP_POINTER)\n\t{\n\t\tfprintf(stderr, \"ERROR: S9xReportPointer called on %s ID 0x%08x\\n\", maptypename(maptype(keymap[id].type)), id);\n\t\treturn;\n\t}\n\n\tS9xApplyCommand(keymap[id], x, y);\n}\n\nbool S9xMapAxis (uint32 id, s9xcommand_t mapping, bool poll)\n{\n\tint\tt;\n\n\tif (id == InvalidControlID)\n\t{\n\t\tfprintf(stderr, \"Cannot map InvalidControlID\\n\");\n\t\treturn (false);\n\t}\n\n\tt = maptype(mapping.type);\n\n\tif (t == MAP_NONE)\n\t{\n\t\tS9xUnmapID(id);\n\t\treturn (true);\n\t}\n\n\tif (t != MAP_AXIS)\n\t\treturn (false);\n\n\tt = maptype(S9xGetMapping(id).type);\n\n\tif (t != MAP_NONE && t != MAP_AXIS)\n\t\tfprintf(stderr, \"WARNING: Remapping ID 0x%08x from %s to axis\\n\", id, maptypename(t));\n\n\tif (id >= PseudoPointerBase)\n\t{\n\t\tfprintf(stderr, \"ERROR: Refusing to map pseudo-pointer #%d as an axis\\n\", id - PseudoPointerBase);\n\t\treturn (false);\n\t}\n\n\tt = -1;\n\n\tif (poll)\n\t{\n\t\tswitch (mapping.type)\n\t\t{\n\t\t\tcase S9xAxisJoypad:\n\t\t\t\tt = JOYPAD0 + mapping.axis.joypad.idx;\n\t\t\t\tbreak;\n\n\t\t\tcase S9xAxisPseudopointer:\n\t\t\tcase S9xAxisPseudobuttons:\n\t\t\tcase S9xAxisPort:\n\t\t\t\tt=POLL_ALL;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tS9xUnmapID(id);\n\n\tkeymap[id] = mapping;\n\n\tif (t >= 0)\n\t\tpollmap[t].insert(id);\n\n\treturn (true);\n}\n\nvoid S9xReportAxis (uint32 id, int16 value)\n{\n\tif (keymap.count(id) == 0)\n\t\treturn;\n\n\tif (keymap[id].type == S9xNoMapping)\n\t\treturn;\n\n\tif (maptype(keymap[id].type) != MAP_AXIS)\n\t{\n\t\tfprintf(stderr, \"ERROR: S9xReportAxis called on %s ID 0x%08x\\n\", maptypename(maptype(keymap[id].type)), id);\n\t\treturn;\n\t}\n\n\tS9xApplyCommand(keymap[id], value, 0);\n}\n\nstatic int32 ApplyMulti (s9xcommand_t *multi, int32 pos, int16 data1)\n{\n\twhile (1)\n\t{\n\t\tif (multi[pos].multi_press == 3)\n\t\t\treturn (-1);\n\n\t\tif (multi[pos].type == S9xNoMapping)\n\t\t\tbreak;\n\n\t\tif (multi[pos].multi_press)\n\t\t\tS9xApplyCommand(multi[pos], multi[pos].multi_press == 1, 0);\n\t\telse\n\t\t\tS9xApplyCommand(multi[pos], data1, 0);\n\n\t\tpos++;\n\t}\n\n\treturn (pos + 1);\n}\n\nvoid S9xApplyCommand (s9xcommand_t cmd, int16 data1, int16 data2)\n{\n\tint\ti;\n\n\tswitch (cmd.type)\n\t{\n\t\tcase S9xNoMapping:\n\t\t\treturn;\n\n\t\tcase S9xButtonJoypad:\n\t\t\tif (cmd.button.joypad.toggle)\n\t\t\t{\n\t\t\t\tif (!data1)\n\t\t\t\t\treturn;\n\n\t\t\t\tuint16\tr = cmd.button.joypad.buttons;\n\n\t\t\t\tif (cmd.button.joypad.turbo)\tjoypad[cmd.button.joypad.idx].toggleturbo ^= r;\n\t\t\t\tif (cmd.button.joypad.sticky)\tjoypad[cmd.button.joypad.idx].togglestick ^= r;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint16\tr, s, t, st;\n\n\t\t\t\tr = cmd.button.joypad.buttons;\n\t\t\t\tst = r & joypad[cmd.button.joypad.idx].togglestick & joypad[cmd.button.joypad.idx].toggleturbo;\n\t\t\t\tr ^= st;\n\t\t\t\tt  = r & joypad[cmd.button.joypad.idx].toggleturbo;\n\t\t\t\tr ^= t;\n\t\t\t\ts  = r & joypad[cmd.button.joypad.idx].togglestick;\n\t\t\t\tr ^= s;\n\n\t\t\t\tif (cmd.button.joypad.turbo && cmd.button.joypad.sticky)\n\t\t\t\t{\n\t\t\t\t\tuint16\tx = r; r = st; st = x;\n\t\t\t\t\tx = s; s = t; t = x;\n\t\t\t\t}\n\t\t\t\telse if (cmd.button.joypad.turbo)\n\t\t\t\t{\n\t\t\t\t\tuint16\tx = r; r = t; t = x;\n\t\t\t\t\tx = s; s = st; st = x;\n\t\t\t\t}\n\t\t\t\telse if (cmd.button.joypad.sticky)\n\t\t\t\t{\n\t\t\t\t\tuint16\tx = r; r = s; s = x;\n\t\t\t\t\tx = t; t = st; st = x;\n\t\t\t\t}\n\n\t\t\t\tif (data1)\n\t\t\t\t{\n\t\t\t\t\tif (!Settings.UpAndDown && !S9xMoviePlaying()) // if up+down isn't allowed AND we are NOT playing a movie,\n\t\t\t\t\t{\n\t\t\t\t\t\tif (cmd.button.joypad.buttons & (SNES_LEFT_MASK | SNES_RIGHT_MASK))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// if we're pressing left or right, then unpress and unturbo them both first\n\t\t\t\t\t\t\t// so we don't end up hittnig left AND right accidentally.\n\t\t\t\t\t\t\t// Note though that the user can still do it on purpose, if Settings.UpAndDown = true.\n\t\t\t\t\t\t\t// This is a feature, look up glitches in tLoZ:aLttP to find out why.\n\t\t\t\t\t\t\tjoypad[cmd.button.joypad.idx].buttons &= ~(SNES_LEFT_MASK | SNES_RIGHT_MASK);\n\t\t\t\t\t\t\tjoypad[cmd.button.joypad.idx].turbos  &= ~(SNES_LEFT_MASK | SNES_RIGHT_MASK);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (cmd.button.joypad.buttons & (SNES_UP_MASK | SNES_DOWN_MASK))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// and ditto for up/down\n\t\t\t\t\t\t\tjoypad[cmd.button.joypad.idx].buttons &= ~(SNES_UP_MASK | SNES_DOWN_MASK);\n\t\t\t\t\t\t\tjoypad[cmd.button.joypad.idx].turbos  &= ~(SNES_UP_MASK | SNES_DOWN_MASK);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tjoypad[cmd.button.joypad.idx].buttons |= r;\n\t\t\t\t\tjoypad[cmd.button.joypad.idx].turbos  |= t;\n\t\t\t\t\tjoypad[cmd.button.joypad.idx].buttons ^= s;\n\t\t\t\t\tjoypad[cmd.button.joypad.idx].buttons &= ~(joypad[cmd.button.joypad.idx].turbos & st);\n\t\t\t\t\tjoypad[cmd.button.joypad.idx].turbos  ^= st;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tjoypad[cmd.button.joypad.idx].buttons &= ~r;\n\t\t\t\t\tjoypad[cmd.button.joypad.idx].buttons &= ~(joypad[cmd.button.joypad.idx].turbos & t);\n\t\t\t\t\tjoypad[cmd.button.joypad.idx].turbos  &= ~t;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tcase S9xButtonMouse:\n\t\t\ti = 0;\n\t\t\tif (cmd.button.mouse.left )\ti |= 0x40;\n\t\t\tif (cmd.button.mouse.right)\ti |= 0x80;\n\n\t\t\tif (data1)\n\t\t\t\tmouse[cmd.button.mouse.idx].buttons |=  i;\n\t\t\telse\n\t\t\t\tmouse[cmd.button.mouse.idx].buttons &= ~i;\n\n\t\t\treturn;\n\n\t\tcase S9xButtonSuperscope:\n\t\t\ti = 0;\n\t\t\tif (cmd.button.scope.fire         )\ti |= SUPERSCOPE_FIRE;\n\t\t\tif (cmd.button.scope.cursor       )\ti |= SUPERSCOPE_CURSOR;\n\t\t\tif (cmd.button.scope.pause        )\ti |= SUPERSCOPE_PAUSE;\n\t\t\tif (cmd.button.scope.aim_offscreen)\ti |= SUPERSCOPE_OFFSCREEN;\n\n\t\t\tif (data1)\n\t\t\t{\n\t\t\t\tsuperscope.phys_buttons |= i;\n\n\t\t\t\tif (cmd.button.scope.turbo)\n\t\t\t\t{\n\t\t\t\t\tsuperscope.phys_buttons ^= SUPERSCOPE_TURBO;\n\n\t\t\t\t\tif (superscope.phys_buttons & SUPERSCOPE_TURBO)\n\t\t\t\t\t\tsuperscope.next_buttons |= superscope.phys_buttons & (SUPERSCOPE_FIRE | SUPERSCOPE_CURSOR);\n\t\t\t\t\telse\n\t\t\t\t\t\tsuperscope.next_buttons &= ~(SUPERSCOPE_FIRE | SUPERSCOPE_CURSOR);\n\t\t\t\t}\n\n\t\t\t\tsuperscope.next_buttons |= i & (SUPERSCOPE_FIRE | SUPERSCOPE_CURSOR | SUPERSCOPE_PAUSE);\n\n\t\t\t\tif (!S9xMovieActive()) // PPU modification during non-recordable command screws up movie synchronization\n\t\t\t\t\tif ((superscope.next_buttons & (SUPERSCOPE_FIRE | SUPERSCOPE_CURSOR)) && curcontrollers[1] == SUPERSCOPE && !(superscope.phys_buttons & SUPERSCOPE_OFFSCREEN))\n\t\t\t\t\t\tDoGunLatch(superscope.x, superscope.y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsuperscope.phys_buttons &= ~i;\n\t\t\t\tsuperscope.next_buttons &= SUPERSCOPE_OFFSCREEN | ~i;\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tcase S9xButtonJustifier:\n\t\t\ti = 0;\n\t\t\tif (cmd.button.justifier.trigger)\ti |= JUSTIFIER_TRIGGER;\n\t\t\tif (cmd.button.justifier.start  )\ti |= JUSTIFIER_START;\n\t\t\tif (cmd.button.justifier.aim_offscreen)\tjustifier.offscreen[cmd.button.justifier.idx] = data1 ? 1 : 0;\n\t\t\ti >>= cmd.button.justifier.idx;\n\n\t\t\tif (data1)\n\t\t\t\tjustifier.buttons |=  i;\n\t\t\telse\n\t\t\t\tjustifier.buttons &= ~i;\n\n\t\t\treturn;\n\n\t\tcase S9xButtonMacsRifle:\n\t\t\ti = 0;\n\t\t\tif (cmd.button.macsrifle.trigger) i |= MACSRIFLE_TRIGGER;\n\n\t\t\tif(data1)\n\t\t\t\tmacsrifle.buttons |= i;\n\t\t\telse\n\t\t\t\tmacsrifle.buttons &= ~i;\n\n\t\t\treturn;\n\n\t\tcase S9xButtonCommand:\n\t\t\tif (((enum command_numbers) cmd.button.command) >= LAST_COMMAND)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"Unknown command %04x\\n\", cmd.button.command);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!data1)\n\t\t\t{\n\t\t\t\tswitch (i = cmd.button.command)\n\t\t\t\t{\n\t\t\t\t\tcase EmuTurbo:\n\t\t\t\t\t\tSettings.TurboMode = FALSE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch ((enum command_numbers) (i = cmd.button.command))\n\t\t\t\t{\n\t\t\t\t\tcase ExitEmu:\n\t\t\t\t\t\tS9xExit();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Reset:\n\t\t\t\t\t\tS9xReset();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SoftReset:\n\t\t\t\t\t\tS9xMovieUpdateOnReset();\n\t\t\t\t\t\tif (S9xMoviePlaying())\n\t\t\t\t\t\t\tS9xMovieStop(TRUE);\n\t\t\t\t\t\tS9xSoftReset();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EmuTurbo:\n\t\t\t\t\t\tSettings.TurboMode = TRUE;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ToggleEmuTurbo:\n\t\t\t\t\t\tSettings.TurboMode = !Settings.TurboMode;\n\t\t\t\t\t\tDisplayStateChange(\"Turbo mode\", Settings.TurboMode);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClipWindows:\n\t\t\t\t\t\tSettings.DisableGraphicWindows = !Settings.DisableGraphicWindows;\n\t\t\t\t\t\tDisplayStateChange(\"Graphic clip windows\", !Settings.DisableGraphicWindows);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Debugger:\n\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t\tCPU.Flags |= DEBUG_MODE_FLAG;\n\t\t\t\t\t#endif\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IncFrameRate:\n\t\t\t\t\t\tif (Settings.SkipFrames == AUTO_FRAMERATE)\n\t\t\t\t\t\t\tSettings.SkipFrames = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (Settings.SkipFrames < 10)\n\t\t\t\t\t\t\tSettings.SkipFrames++;\n\n\t\t\t\t\t\tif (Settings.SkipFrames == AUTO_FRAMERATE)\n\t\t\t\t\t\t\tS9xSetInfoString(\"Auto frame skip\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsprintf(buf, \"Frame skip: %d\", Settings.SkipFrames - 1);\n\t\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DecFrameRate:\n\t\t\t\t\t\tif (Settings.SkipFrames <= 1)\n\t\t\t\t\t\t\tSettings.SkipFrames = AUTO_FRAMERATE;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (Settings.SkipFrames != AUTO_FRAMERATE)\n\t\t\t\t\t\t\tSettings.SkipFrames--;\n\n\t\t\t\t\t\tif (Settings.SkipFrames == AUTO_FRAMERATE)\n\t\t\t\t\t\t\tS9xSetInfoString(\"Auto frame skip\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsprintf(buf, \"Frame skip: %d\", Settings.SkipFrames - 1);\n\t\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IncEmuTurbo:\n\t\t\t\t\t\tif (Settings.TurboSkipFrames < 20)\n\t\t\t\t\t\t\tSettings.TurboSkipFrames += 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (Settings.TurboSkipFrames < 200)\n\t\t\t\t\t\t\tSettings.TurboSkipFrames += 5;\n\t\t\t\t\t\tsprintf(buf, \"Turbo frame skip: %d\", Settings.TurboSkipFrames);\n\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DecEmuTurbo:\n\t\t\t\t\t\tif (Settings.TurboSkipFrames > 20)\n\t\t\t\t\t\t\tSettings.TurboSkipFrames -= 5;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (Settings.TurboSkipFrames > 0)\n\t\t\t\t\t\t\tSettings.TurboSkipFrames -= 1;\n\t\t\t\t\t\tsprintf(buf, \"Turbo frame skip: %d\", Settings.TurboSkipFrames);\n\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IncFrameTime: // Increase emulated frame time by 1ms\n\t\t\t\t\t\tSettings.FrameTime += 1000;\n\t\t\t\t\t\tsprintf(buf, \"Emulated frame time: %dms\", Settings.FrameTime / 1000);\n\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DecFrameTime: // Decrease emulated frame time by 1ms\n\t\t\t\t\t\tif (Settings.FrameTime >= 1000)\n\t\t\t\t\t\t\tSettings.FrameTime -= 1000;\n\t\t\t\t\t\tsprintf(buf, \"Emulated frame time: %dms\", Settings.FrameTime / 1000);\n\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IncTurboSpeed:\n\t\t\t\t\t\tif (turbo_time >= 120)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tturbo_time++;\n\t\t\t\t\t\tsprintf(buf, \"Turbo speed: %d\", turbo_time);\n\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DecTurboSpeed:\n\t\t\t\t\t\tif (turbo_time <= 1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tturbo_time--;\n\t\t\t\t\t\tsprintf(buf, \"Turbo speed: %d\", turbo_time);\n\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LoadFreezeFile:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SaveFreezeFile:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LoadOopsFile:\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string filename = S9xGetFilename(\"oops\", SNAPSHOT_DIR);\n\n\t\t\t\t\t\tif (S9xUnfreezeGame(filename.c_str()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsnprintf(buf, 256, \"%.240s.oops loaded\", S9xBasename(Memory.ROMFilename).c_str());\n\t\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tS9xMessage(S9X_ERROR, S9X_FREEZE_FILE_NOT_FOUND, \"Oops file not found\");\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase Pause:\n\t\t\t\t\t\tSettings.Paused = !Settings.Paused;\n\t\t\t\t\t\tDisplayStateChange(\"Pause\", Settings.Paused);\n\t\t\t\t\t#if defined(NETPLAY_SUPPORT) && !defined(__WIN32__)\n\t\t\t\t\t\tS9xNPSendPause(Settings.Paused);\n\t\t\t\t\t#endif\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase QuickLoad000:\n\t\t\t\t\tcase QuickLoad001:\n\t\t\t\t\tcase QuickLoad002:\n\t\t\t\t\tcase QuickLoad003:\n\t\t\t\t\tcase QuickLoad004:\n\t\t\t\t\tcase QuickLoad005:\n\t\t\t\t\tcase QuickLoad006:\n\t\t\t\t\tcase QuickLoad007:\n\t\t\t\t\tcase QuickLoad008:\n\t\t\t\t\tcase QuickLoad009:\n\t\t\t\t\tcase QuickLoad010:\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string ext = std::to_string(i - QuickLoad000);\n\t\t\t\t\t\twhile (ext.length() < 3)\n\t\t\t\t\t\t\text = '0' + ext;\n\n\t\t\t\t\t\tauto filename = S9xGetFilename(ext, SNAPSHOT_DIR);\n\n\t\t\t\t\t\tif (S9xUnfreezeGame(filename.c_str()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsnprintf(buf, 256, \"%s loaded\", S9xBasename(filename).c_str());\n\t\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tS9xMessage(S9X_ERROR, S9X_FREEZE_FILE_NOT_FOUND, \"Freeze file not found\");\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase QuickSave000:\n\t\t\t\t\tcase QuickSave001:\n\t\t\t\t\tcase QuickSave002:\n\t\t\t\t\tcase QuickSave003:\n\t\t\t\t\tcase QuickSave004:\n\t\t\t\t\tcase QuickSave005:\n\t\t\t\t\tcase QuickSave006:\n\t\t\t\t\tcase QuickSave007:\n\t\t\t\t\tcase QuickSave008:\n\t\t\t\t\tcase QuickSave009:\n\t\t\t\t\tcase QuickSave010:\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string ext = std::to_string(i - QuickSave000);\n\t\t\t\t\t\twhile (ext.length() < 3)\n\t\t\t\t\t\t\text = '0' + ext;\n\n\t\t\t\t\t\tauto filename = S9xGetFilename(ext, SNAPSHOT_DIR);\n\n\t\t\t\t\t\tsnprintf(buf, 256, \"%s saved\", S9xBasename(filename).c_str());\n\t\t\t\t\t\tS9xSetInfoString(buf);\n\n\t\t\t\t\t\tS9xFreezeGame(filename.c_str());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase SaveSPC:\n\t\t\t\t\t\tS9xDumpSPCSnapshot();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Screenshot:\n\t\t\t\t\t\tSettings.TakeScreenshot = TRUE;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SoundChannel0:\n\t\t\t\t\tcase SoundChannel1:\n\t\t\t\t\tcase SoundChannel2:\n\t\t\t\t\tcase SoundChannel3:\n\t\t\t\t\tcase SoundChannel4:\n\t\t\t\t\tcase SoundChannel5:\n\t\t\t\t\tcase SoundChannel6:\n\t\t\t\t\tcase SoundChannel7:\n\t\t\t\t\t\tS9xToggleSoundChannel(i - SoundChannel0);\n\t\t\t\t\t\tsprintf(buf, \"Sound channel %d toggled\", i - SoundChannel0);\n\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SoundChannelsOn:\n\t\t\t\t\t\tS9xToggleSoundChannel(8);\n\t\t\t\t\t\tS9xSetInfoString(\"All sound channels on\");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ToggleBackdrop:\n\t\t\t\t\t\tswitch (Settings.ForcedBackdrop)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tSettings.ForcedBackdrop = 0xf81f;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0xf81f:\n\t\t\t\t\t\t\tSettings.ForcedBackdrop = 0x07e0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x07e0:\n\t\t\t\t\t\t\tSettings.ForcedBackdrop = 0x07ff;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tSettings.ForcedBackdrop = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsprintf(buf, \"Setting backdrop to 0x%04x\", Settings.ForcedBackdrop);\n\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ToggleBG0:\n\t\t\t\t\t\tSettings.BG_Forced ^= 1;\n\t\t\t\t\t\tDisplayStateChange(\"BG#0\", !(Settings.BG_Forced & 1));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ToggleBG1:\n\t\t\t\t\t\tSettings.BG_Forced ^= 2;\n\t\t\t\t\t\tDisplayStateChange(\"BG#1\", !(Settings.BG_Forced & 2));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ToggleBG2:\n\t\t\t\t\t\tSettings.BG_Forced ^= 4;\n\t\t\t\t\t\tDisplayStateChange(\"BG#2\", !(Settings.BG_Forced & 4));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ToggleBG3:\n\t\t\t\t\t\tSettings.BG_Forced ^= 8;\n\t\t\t\t\t\tDisplayStateChange(\"BG#3\", !(Settings.BG_Forced & 8));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ToggleSprites:\n\t\t\t\t\t\tSettings.BG_Forced ^= 16;\n\t\t\t\t\t\tDisplayStateChange(\"Sprites\", !(Settings.BG_Forced & 16));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ToggleTransparency:\n\t\t\t\t\t\tSettings.Transparency = !Settings.Transparency;\n\t\t\t\t\t\tDisplayStateChange(\"Transparency effects\", Settings.Transparency);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase BeginRecordingMovie:\n\t\t\t\t\t\t// if (S9xMovieActive())\n\t\t\t\t\t\t// \tS9xMovieStop(FALSE);\n\t\t\t\t\t\t// S9xMovieCreate(S9xChooseMovieFilename(FALSE), 0xFF, MOVIE_OPT_FROM_RESET, NULL, 0);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LoadMovie:\n\t\t\t\t\t\t// if (S9xMovieActive())\n\t\t\t\t\t\t// \tS9xMovieStop(FALSE);\n\t\t\t\t\t\t// S9xMovieOpen(S9xChooseMovieFilename(TRUE), FALSE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EndRecordingMovie:\n\t\t\t\t\t\tif (S9xMovieActive())\n\t\t\t\t\t\t\tS9xMovieStop(FALSE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SwapJoypads:\n\t\t\t\t\t\tif ((curcontrollers[0] != NONE && !(curcontrollers[0] >= JOYPAD0 && curcontrollers[0] <= JOYPAD7)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tS9xSetInfoString(\"Cannot swap pads: port 1 is not a joypad\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((curcontrollers[1] != NONE && !(curcontrollers[1] >= JOYPAD0 && curcontrollers[1] <= JOYPAD7)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tS9xSetInfoString(\"Cannot swap pads: port 2 is not a joypad\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n#ifdef NETPLAY_SUPPORT\n\t\t\t\t\t\tif (Settings.NetPlay && data2 != 1) { //data2 == 1 means it's sent by the netplay code\n\t\t\t\t\t\t\tif (Settings.NetPlayServer) {\n\t\t\t\t\t\t\t\tS9xNPSendJoypadSwap();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS9xSetInfoString(\"Netplay Client cannot swap pads.\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\n\t\t\t\t\t\tnewcontrollers[1] = curcontrollers[0];\n\t\t\t\t\t\tnewcontrollers[0] = curcontrollers[1];\n\n\t\t\t\t\t\tstrcpy(buf, \"Swap pads: P1=\");\n\t\t\t\t\t\ti = 14;\n\t\t\t\t\t\tif (newcontrollers[0] == NONE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrcpy(buf + i, \"<none>\");\n\t\t\t\t\t\t\ti += 6;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsprintf(buf + i, \"Joypad%d\", newcontrollers[0] - JOYPAD0 + 1);\n\t\t\t\t\t\t\ti += 7;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstrcpy(buf + i, \" P2=\");\n\t\t\t\t\t\ti += 4;\n\t\t\t\t\t\tif (newcontrollers[1] == NONE)\n\t\t\t\t\t\t\tstrcpy(buf + i, \"<none>\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsprintf(buf + i, \"Joypad%d\", newcontrollers[1] - JOYPAD0 + 1);\n\n\t\t\t\t\t\tS9xSetInfoString(buf);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SeekToFrame:\n\t\t\t\t\t\tif (S9xMovieActive())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsprintf(buf, \"Select frame number (current: %d)\", S9xMovieGetFrameCounter());\n\t\t\t\t\t\t\tconst char\t*frameno = S9xStringInput(buf);\n\t\t\t\t\t\t\tif (!frameno)\n\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\tint\tframeDest = atoi(frameno);\n\t\t\t\t\t\t\tif (frameDest > 0 && frameDest > (int) S9xMovieGetFrameCounter())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint\tdistance = frameDest - S9xMovieGetFrameCounter();\n\t\t\t\t\t\t\t\tSettings.HighSpeedSeek = distance;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LAST_COMMAND:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tcase S9xPointer:\n\t\t\tif (cmd.pointer.aim_mouse0)\n\t\t\t{\n\t\t\t\tmouse[0].cur_x = data1;\n\t\t\t\tmouse[0].cur_y = data2;\n\t\t\t}\n\n\t\t\tif (cmd.pointer.aim_mouse1)\n\t\t\t{\n\t\t\t\tmouse[1].cur_x = data1;\n\t\t\t\tmouse[1].cur_y = data2;\n\t\t\t}\n\n\t\t\tif (cmd.pointer.aim_scope)\n\t\t\t{\n\t\t\t\tsuperscope.x   = data1;\n\t\t\t\tsuperscope.y   = data2;\n\t\t\t}\n\n\t\t\tif (cmd.pointer.aim_justifier0)\n\t\t\t{\n\t\t\t\tjustifier.x[0] = data1;\n\t\t\t\tjustifier.y[0] = data2;\n\t\t\t}\n\n\t\t\tif (cmd.pointer.aim_justifier1)\n\t\t\t{\n\t\t\t\tjustifier.x[1] = data1;\n\t\t\t\tjustifier.y[1] = data2;\n\t\t\t}\n\n\t\t\tif (cmd.pointer.aim_macsrifle)\n\t\t\t{\n\t\t\t\tmacsrifle.x = data1;\n\t\t\t\tmacsrifle.y = data2;\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tcase S9xButtonPseudopointer:\n\t\t\tif (data1)\n\t\t\t{\n\t\t\t\tif (cmd.button.pointer.UD)\n\t\t\t\t{\n\t\t\t\t\tif (!pseudopointer[cmd.button.pointer.idx].V_adj)\n\t\t\t\t\t\tpseudopointer[cmd.button.pointer.idx].V_adj = cmd.button.pointer.UD * ptrspeeds[cmd.button.pointer.speed_type];\n\t\t\t\t\tpseudopointer[cmd.button.pointer.idx].V_var = (cmd.button.pointer.speed_type == 0);\n\t\t\t\t}\n\n\t\t\t\tif (cmd.button.pointer.LR)\n\t\t\t\t{\n\t\t\t\t\tif (!pseudopointer[cmd.button.pointer.idx].H_adj)\n\t\t\t\t\t\tpseudopointer[cmd.button.pointer.idx].H_adj = cmd.button.pointer.LR * ptrspeeds[cmd.button.pointer.speed_type];\n\t\t\t\t\tpseudopointer[cmd.button.pointer.idx].H_var = (cmd.button.pointer.speed_type == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cmd.button.pointer.UD)\n\t\t\t\t{\n\t\t\t\t\tpseudopointer[cmd.button.pointer.idx].V_adj = 0;\n\t\t\t\t\tpseudopointer[cmd.button.pointer.idx].V_var = false;\n\t\t\t\t}\n\n\t\t\t\tif (cmd.button.pointer.LR)\n\t\t\t\t{\n\t\t\t\t\tpseudopointer[cmd.button.pointer.idx].H_adj = 0;\n\t\t\t\t\tpseudopointer[cmd.button.pointer.idx].H_var = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tcase S9xAxisJoypad:\n\t\t{\n\t\t\tuint16\tpos, neg;\n\n\t\t\tswitch (cmd.axis.joypad.axis)\n\t\t\t{\n\t\t\t\tcase 0: neg = SNES_LEFT_MASK;\tpos = SNES_RIGHT_MASK;\tbreak;\n\t\t\t\tcase 1: neg = SNES_UP_MASK;\t\tpos = SNES_DOWN_MASK;\tbreak;\n\t\t\t\tcase 2: neg = SNES_Y_MASK;\t\tpos = SNES_A_MASK;\t\tbreak;\n\t\t\t\tcase 3: neg = SNES_X_MASK;\t\tpos = SNES_B_MASK;\t\tbreak;\n\t\t\t\tcase 4: neg = SNES_TL_MASK;\t\tpos = SNES_TR_MASK;\t\tbreak;\n\t\t\t\tdefault: return;\n\t\t\t}\n\n\t\t\tif (cmd.axis.joypad.invert)\n\t\t\t\tdata1 = -data1;\n\n\t\t\tuint16\tp, r;\n\n\t\t\tp = r = 0;\n\t\t\tif (data1 >  ((cmd.axis.joypad.threshold + 1) *  127))\n\t\t\t\tp |= pos;\n\t\t\telse\n\t\t\t\tr |= pos;\n\n\t\t\tif (data1 <= ((cmd.axis.joypad.threshold + 1) * -127))\n\t\t\t\tp |= neg;\n\t\t\telse\n\t\t\t\tr |= neg;\n\n\t\t\tjoypad[cmd.axis.joypad.idx].buttons |= p;\n\t\t\tjoypad[cmd.axis.joypad.idx].buttons &= ~r;\n\t\t\tjoypad[cmd.axis.joypad.idx].turbos  &= ~(p | r);\n\n\t\t\treturn;\n\t\t}\n\n\t\tcase S9xAxisPseudopointer:\n\t\t\tif (data1 == 0)\n\t\t\t{\n\t\t\t\tif (cmd.axis.pointer.HV)\n\t\t\t\t{\n\t\t\t\t\tpseudopointer[cmd.axis.pointer.idx].V_adj = 0;\n\t\t\t\t\tpseudopointer[cmd.axis.pointer.idx].V_var = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpseudopointer[cmd.axis.pointer.idx].H_adj = 0;\n\t\t\t\t\tpseudopointer[cmd.axis.pointer.idx].H_var = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cmd.axis.pointer.invert)\n\t\t\t\t\tdata1 = -data1;\n\n\t\t\t\tif (cmd.axis.pointer.HV)\n\t\t\t\t{\n\t\t\t\t\tif (!pseudopointer[cmd.axis.pointer.idx].V_adj)\n\t\t\t\t\t\tpseudopointer[cmd.axis.pointer.idx].V_adj = (int16) ((int32) data1 * ptrspeeds[cmd.axis.pointer.speed_type] / 32767);\n\t\t\t\t\tpseudopointer[cmd.axis.pointer.idx].V_var = (cmd.axis.pointer.speed_type == 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!pseudopointer[cmd.axis.pointer.idx].H_adj)\n\t\t\t\t\t\tpseudopointer[cmd.axis.pointer.idx].H_adj = (int16) ((int32) data1 * ptrspeeds[cmd.axis.pointer.speed_type] / 32767);\n\t\t\t\t\tpseudopointer[cmd.axis.pointer.idx].H_var = (cmd.axis.pointer.speed_type == 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tcase S9xAxisPseudobuttons:\n\t\t\tif (data1 >  ((cmd.axis.button.threshold + 1) *  127))\n\t\t\t{\n\t\t\t\tif (!pseudobuttons[cmd.axis.button.posbutton])\n\t\t\t\t{\n\t\t\t\t\tpseudobuttons[cmd.axis.button.posbutton] = 1;\n\t\t\t\t\tS9xReportButton(PseudoButtonBase + cmd.axis.button.posbutton, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (pseudobuttons[cmd.axis.button.posbutton])\n\t\t\t\t{\n\t\t\t\t\tpseudobuttons[cmd.axis.button.posbutton] = 0;\n\t\t\t\t\tS9xReportButton(PseudoButtonBase + cmd.axis.button.posbutton, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data1 <= ((cmd.axis.button.threshold + 1) * -127))\n\t\t\t{\n\t\t\t\tif (!pseudobuttons[cmd.axis.button.negbutton])\n\t\t\t\t{\n\t\t\t\t\tpseudobuttons[cmd.axis.button.negbutton] = 1;\n\t\t\t\t\tS9xReportButton(PseudoButtonBase + cmd.axis.button.negbutton, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (pseudobuttons[cmd.axis.button.negbutton])\n\t\t\t\t{\n\t\t\t\t\tpseudobuttons[cmd.axis.button.negbutton] = 0;\n\t\t\t\t\tS9xReportButton(PseudoButtonBase + cmd.axis.button.negbutton, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tcase S9xButtonPort:\n\t\tcase S9xAxisPort:\n\t\tcase S9xPointerPort:\n\t\t\tS9xHandlePortCommand(cmd, data1, data2);\n\t\t\treturn;\n\n\t\tcase S9xButtonMulti:\n\t\t\tif (cmd.button.multi_idx >= (int) multis.size())\n\t\t\t\treturn;\n\n\t\t\tif (multis[cmd.button.multi_idx]->multi_press && !data1)\n\t\t\t\treturn;\n\n\t\t\ti = ApplyMulti(multis[cmd.button.multi_idx], 0, data1);\n\t\t\tif (i >= 0)\n\t\t\t{\n\t\t\t\tstruct exemulti\t*e = new struct exemulti;\n\t\t\t\te->pos    = i;\n\t\t\t\te->data1  = data1 != 0;\n\t\t\t\te->script = multis[cmd.button.multi_idx];\n\t\t\t\texemultis.insert(e);\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"WARNING: Unknown command type %d\\n\", cmd.type);\n\t\t\treturn;\n\t}\n}\n\nstatic void do_polling (int mp)\n{\n\tset<uint32>::iterator\titr;\n\n\tif (S9xMoviePlaying())\n\t\treturn;\n\n\tif (pollmap[mp].empty())\n\t\treturn;\n\n\tfor (itr = pollmap[mp].begin(); itr != pollmap[mp].end(); itr++)\n\t{\n\t\tswitch (maptype(keymap[*itr].type))\n\t\t{\n\t\t\tcase MAP_BUTTON:\n\t\t\t{\n\t\t\t\tbool\tpressed = false;\n\t\t\t\tif (S9xPollButton(*itr, &pressed))\n\t\t\t\t\tS9xReportButton(*itr, pressed);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase MAP_AXIS:\n\t\t\t{\n\t\t\t\tint16\tvalue = 0;\n\t\t\t\tif (S9xPollAxis(*itr, &value))\n\t\t\t\t\tS9xReportAxis(*itr, value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase MAP_POINTER:\n\t\t\t{\n\t\t\t\tint16\tx = 0, y = 0;\n\t\t\t\tif (S9xPollPointer(*itr, &x, &y))\n\t\t\t\t\tS9xReportPointer(*itr, x, y);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void UpdatePolledMouse (int i)\n{\n\tint16\tj;\n\n\tj = mouse[i - MOUSE0].cur_x - mouse[i - MOUSE0].old_x;\n\n\tif (j < -127)\n\t{\n\t\tmouse[i - MOUSE0].delta_x = 0xff;\n\t\tmouse[i - MOUSE0].old_x -= 127;\n\t}\n\telse if (j < 0)\n\t{\n\t\tmouse[i - MOUSE0].delta_x = 0x80 | -j;\n\t\tmouse[i - MOUSE0].old_x = mouse[i - MOUSE0].cur_x;\n\t}\n\telse if (j > 127)\n\t{\n\t\tmouse[i - MOUSE0].delta_x = 0x7f;\n\t\tmouse[i - MOUSE0].old_x += 127;\n\t}\n\telse\n\t{\n\t\tmouse[i - MOUSE0].delta_x = (uint8) j;\n\t\tmouse[i - MOUSE0].old_x = mouse[i - MOUSE0].cur_x;\n\t}\n\n\tj = mouse[i - MOUSE0].cur_y - mouse[i - MOUSE0].old_y;\n\n\tif (j < -127)\n\t{\n\t\tmouse[i - MOUSE0].delta_y = 0xff;\n\t\tmouse[i - MOUSE0].old_y -= 127;\n\t}\n\telse if (j < 0)\n\t{\n\t\tmouse[i - MOUSE0].delta_y = 0x80 | -j;\n\t\tmouse[i - MOUSE0].old_y = mouse[i - MOUSE0].cur_y;\n\t}\n\telse if (j > 127)\n\t{\n\t\tmouse[i - MOUSE0].delta_y = 0x7f;\n\t\tmouse[i - MOUSE0].old_y += 127;\n\t}\n\telse\n\t{\n\t\tmouse[i - MOUSE0].delta_y = (uint8) j;\n\t\tmouse[i - MOUSE0].old_y = mouse[i - MOUSE0].cur_y;\n\t}\n}\n\nvoid S9xSetJoypadLatch (bool latch)\n{\n\tif (!latch && FLAG_LATCH)\n\t{\n\t\t// 1 written, 'plug in' new controllers now\n\t\tcurcontrollers[0] = newcontrollers[0];\n\t\tcurcontrollers[1] = newcontrollers[1];\n\t}\n\n\tif (latch && !FLAG_LATCH)\n\t{\n\t\tint\ti;\n\n\t\tfor (int n = 0; n < 2; n++)\n\t\t{\n\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t\tread_idx[n][j] = 0;\n\n\t\t\tswitch (i = curcontrollers[n])\n\t\t\t{\n\t\t\t\tcase MP5:\n\t\t\t\t\tfor (int j = 0, k; j < 4; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tk = mp5[n].pads[j];\n\t\t\t\t\t\tif (k == NONE)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdo_polling(k);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase JOYPAD0:\n\t\t\t\tcase JOYPAD1:\n\t\t\t\tcase JOYPAD2:\n\t\t\t\tcase JOYPAD3:\n\t\t\t\tcase JOYPAD4:\n\t\t\t\tcase JOYPAD5:\n\t\t\t\tcase JOYPAD6:\n\t\t\t\tcase JOYPAD7:\n\t\t\t\t\tdo_polling(i);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MOUSE0:\n\t\t\t\tcase MOUSE1:\n\t\t\t\t\tdo_polling(i);\n\t\t\t\t\tif (!S9xMoviePlaying())\n\t\t\t\t\t\tUpdatePolledMouse(i);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SUPERSCOPE:\n\t\t\t\t\tif (superscope.next_buttons & SUPERSCOPE_FIRE)\n\t\t\t\t\t{\n\t\t\t\t\t\tsuperscope.next_buttons &= ~SUPERSCOPE_TURBO;\n\t\t\t\t\t\tsuperscope.next_buttons |= superscope.phys_buttons & SUPERSCOPE_TURBO;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (superscope.next_buttons & (SUPERSCOPE_FIRE | SUPERSCOPE_CURSOR))\n\t\t\t\t\t{\n\t\t\t\t\t\tsuperscope.next_buttons &= ~SUPERSCOPE_OFFSCREEN;\n\t\t\t\t\t\tsuperscope.next_buttons |= superscope.phys_buttons & SUPERSCOPE_OFFSCREEN;\n\t\t\t\t\t}\n\n\t\t\t\t\tsuperscope.read_buttons = superscope.next_buttons;\n\n\t\t\t\t\tsuperscope.next_buttons &= ~SUPERSCOPE_PAUSE;\n\t\t\t\t\tif (!(superscope.phys_buttons & SUPERSCOPE_TURBO))\n\t\t\t\t\t\tsuperscope.next_buttons &= ~(SUPERSCOPE_CURSOR | SUPERSCOPE_FIRE);\n\n\t\t\t\t\tdo_polling(i);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TWO_JUSTIFIERS:\n\t\t\t\t\tdo_polling(TWO_JUSTIFIERS);\n\t\t\t\t\t// fall through\n\n\t\t\t\tcase ONE_JUSTIFIER:\n\t\t\t\t\tjustifier.buttons ^= JUSTIFIER_SELECT;\n\t\t\t\t\tdo_polling(ONE_JUSTIFIER);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MACSRIFLE:\n\t\t\t\t\tdo_polling(i);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tFLAG_LATCH = latch;\n}\n\n// prevent read_idx from overflowing (only latching resets it)\n// otherwise $4016/7 reads will start returning input data again\nstatic inline uint8 IncreaseReadIdxPost(uint8 &var)\n{\n\tuint8 oldval = var;\n\tif (var < 255)\n\t\tvar++;\n\treturn oldval;\n}\n\nuint8 S9xReadJOYSERn (int n)\n{\n\tint\ti, j, r;\n\n\tif (n > 1)\n\t\tn -= 0x4016;\n\tassert(n == 0 || n == 1);\n\n\tuint8\tbits = (OpenBus & ~3) | ((n == 1) ? 0x1c : 0);\n\n\tif (FLAG_LATCH)\n\t{\n\t\tswitch (i = curcontrollers[n])\n\t\t{\n\t\t\tcase MP5:\n\t\t\t\treturn (bits | 2);\n\n\t\t\tcase JOYPAD0:\n\t\t\tcase JOYPAD1:\n\t\t\tcase JOYPAD2:\n\t\t\tcase JOYPAD3:\n\t\t\tcase JOYPAD4:\n\t\t\tcase JOYPAD5:\n\t\t\tcase JOYPAD6:\n\t\t\tcase JOYPAD7:\n\t\t\t\treturn (bits | ((joypad[i - JOYPAD0].buttons & 0x8000) ? 1 : 0));\n\n\t\t\tcase MOUSE0:\n\t\t\tcase MOUSE1:\n\t\t\t\tmouse[i - MOUSE0].buttons += 0x10;\n\t\t\t\tif ((mouse[i - MOUSE0].buttons & 0x30) == 0x30)\n\t\t\t\t\tmouse[i - MOUSE0].buttons &= 0xcf;\n\t\t\t\treturn (bits);\n\n\t\t\tcase SUPERSCOPE:\n\t\t\t\treturn (bits | ((superscope.read_buttons & 0x80) ? 1 : 0));\n\n\t\t\tcase ONE_JUSTIFIER:\n\t\t\tcase TWO_JUSTIFIERS:\n\t\t\t\treturn (bits);\n\n\t\t\tcase MACSRIFLE:\n\t\t\t\tdo_polling(i);\n\t\t\t\treturn (bits | ((macsrifle.buttons & 0x01) ? 1 : 0));\n\n\t\t\tdefault:\n\t\t\t\treturn (bits);\n\t\t}\n\t}\n\telse\n\t{\n\t\tswitch (i = curcontrollers[n])\n\t\t{\n\t\t\tcase MP5:\n\t\t\t\tr = IncreaseReadIdxPost(read_idx[n][FLAG_IOBIT(n) ? 0 : 1]);\n\t\t\t\tj = FLAG_IOBIT(n) ? 0 : 2;\n\n\t\t\t\tfor (i = 0; i < 2; i++, j++)\n\t\t\t\t{\n\t\t\t\t\tif (mp5[n].pads[j] == NONE)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (r >= 16)\n\t\t\t\t\t\tbits |= 1 << i;\n\t\t\t\t\telse\n\t\t\t\t\t\tbits |= ((joypad[mp5[n].pads[j] - JOYPAD0].buttons & (0x8000 >> r)) ? 1 : 0) << i;\n\t\t\t\t}\n\n\t\t\t\treturn (bits);\n\n\t\t\tcase JOYPAD0:\n\t\t\tcase JOYPAD1:\n\t\t\tcase JOYPAD2:\n\t\t\tcase JOYPAD3:\n\t\t\tcase JOYPAD4:\n\t\t\tcase JOYPAD5:\n\t\t\tcase JOYPAD6:\n\t\t\tcase JOYPAD7:\n\t\t\t\tif (read_idx[n][0] >= 16)\n\t\t\t\t{\n\t\t\t\t\tIncreaseReadIdxPost(read_idx[n][0]);\n\t\t\t\t\treturn (bits | 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn (bits | ((joypad[i - JOYPAD0].buttons & (0x8000 >> IncreaseReadIdxPost(read_idx[n][0]))) ? 1 : 0));\n\n\t\t\tcase MOUSE0:\n\t\t\tcase MOUSE1:\n\t\t\t\tif (read_idx[n][0] < 8)\n\t\t\t\t{\n\t\t\t\t\tIncreaseReadIdxPost(read_idx[n][0]);\n\t\t\t\t\treturn (bits);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (read_idx[n][0] < 16)\n\t\t\t\t\treturn (bits | ((mouse[i - MOUSE0].buttons & (0x8000     >> IncreaseReadIdxPost(read_idx[n][0]))) ? 1 : 0));\n\t\t\t\telse\n\t\t\t\tif (read_idx[n][0] < 24)\n\t\t\t\t\treturn (bits | ((mouse[i - MOUSE0].delta_y & (0x800000   >> IncreaseReadIdxPost(read_idx[n][0]))) ? 1 : 0));\n\t\t\t\telse\n\t\t\t\tif (read_idx[n][0] < 32)\n\t\t\t\t\treturn (bits | ((mouse[i - MOUSE0].delta_x & (0x80000000 >> IncreaseReadIdxPost(read_idx[n][0]))) ? 1 : 0));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIncreaseReadIdxPost(read_idx[n][0]);\n\t\t\t\t\treturn (bits | 1);\n\t\t\t\t}\n\n\t\t\tcase SUPERSCOPE:\n\t\t\t\tif (read_idx[n][0] < 8)\n\t\t\t\t\treturn (bits | ((superscope.read_buttons & (0x80 >> IncreaseReadIdxPost(read_idx[n][0]))) ? 1 : 0));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIncreaseReadIdxPost(read_idx[n][0]);\n\t\t\t\t\treturn (bits | 1);\n\t\t\t\t}\n\n\t\t\tcase ONE_JUSTIFIER:\n\t\t\t\tif (read_idx[n][0] < 24)\n\t\t\t\t\treturn (bits | ((0xaa7000 >> IncreaseReadIdxPost(read_idx[n][0])) & 1));\n\t\t\t\telse\n\t\t\t\tif (read_idx[n][0] < 32)\n\t\t\t\t\treturn (bits | ((justifier.buttons & (JUSTIFIER_TRIGGER | JUSTIFIER_START | JUSTIFIER_SELECT) & (0x80000000 >> IncreaseReadIdxPost(read_idx[n][0]))) ? 1 : 0));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIncreaseReadIdxPost(read_idx[n][0]);\n\t\t\t\t\treturn (bits | 1);\n\t\t\t\t}\n\n\t\t\tcase TWO_JUSTIFIERS:\n\t\t\t\tif (read_idx[n][0] < 24)\n\t\t\t\t\treturn (bits | ((0xaa7000 >> IncreaseReadIdxPost(read_idx[n][0])) & 1));\n\t\t\t\telse\n\t\t\t\tif (read_idx[n][0] < 32)\n\t\t\t\t\treturn (bits | ((justifier.buttons & (0x80000000 >> IncreaseReadIdxPost(read_idx[n][0]))) ? 1 : 0));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIncreaseReadIdxPost(read_idx[n][0]);\n\t\t\t\t\treturn (bits | 1);\n\t\t\t\t}\n\n\t\t\tcase MACSRIFLE:\n\t\t\t\tdo_polling(i);\n\t\t\t\treturn (bits | ((macsrifle.buttons & 0x01) ? 1 : 0));\n\n\t\t\tdefault:\n\t\t\t\tIncreaseReadIdxPost(read_idx[n][0]);\n\t\t\t\treturn (bits);\n\t\t}\n\t}\n}\n\nvoid S9xDoAutoJoypad (void)\n{\n\tint\ti, j;\n\n\tS9xSetJoypadLatch(1);\n\tS9xSetJoypadLatch(0);\n\n\tS9xMovieUpdate(false);\n\n\tfor (int n = 0; n < 2; n++)\n\t{\n\t\tswitch (i = curcontrollers[n])\n\t\t{\n\t\t\tcase MP5:\n\t\t\t\tj = FLAG_IOBIT(n) ? 0 : 2;\n\t\t\t\tfor (i = 0; i < 2; i++, j++)\n\t\t\t\t{\n\t\t\t\t\tif (mp5[n].pads[j] == NONE)\n\t\t\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x4218 + n * 2 + i * 4, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x4218 + n * 2 + i * 4, joypad[mp5[n].pads[j] - JOYPAD0].buttons);\n\t\t\t\t}\n\n\t\t\t\tread_idx[n][FLAG_IOBIT(n) ? 0 : 1] = 16;\n\t\t\t\tbreak;\n\n\t\t\tcase JOYPAD0:\n\t\t\tcase JOYPAD1:\n\t\t\tcase JOYPAD2:\n\t\t\tcase JOYPAD3:\n\t\t\tcase JOYPAD4:\n\t\t\tcase JOYPAD5:\n\t\t\tcase JOYPAD6:\n\t\t\tcase JOYPAD7:\n\t\t\t\tread_idx[n][0] = 16;\n\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x4218 + n * 2, joypad[i - JOYPAD0].buttons);\n\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x421c + n * 2, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase MOUSE0:\n\t\t\tcase MOUSE1:\n\t\t\t\tread_idx[n][0] = 16;\n\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x4218 + n * 2, mouse[i - MOUSE0].buttons);\n\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x421c + n * 2, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase SUPERSCOPE:\n\t\t\t\tread_idx[n][0] = 16;\n\t\t\t\tMemory.FillRAM[0x4218 + n * 2] = 0xff;\n\t\t\t\tMemory.FillRAM[0x4219 + n * 2] = superscope.read_buttons;\n\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x421c + n * 2, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase ONE_JUSTIFIER:\n\t\t\tcase TWO_JUSTIFIERS:\n\t\t\t\tread_idx[n][0] = 16;\n\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x4218 + n * 2, 0x000e);\n\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x421c + n * 2, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase MACSRIFLE:\n\t\t\t\tread_idx[n][0] = 16;\n\t\t\t\tMemory.FillRAM[0x4218 + n * 2] = 0xff;\n\t\t\t\tMemory.FillRAM[0x4219 + n * 2] = macsrifle.buttons;\n\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x421c + n * 2, 0);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x4218 + n * 2, 0);\n\t\t\t\tWRITE_WORD(Memory.FillRAM + 0x421c + n * 2, 0);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid S9xControlEOF (void)\n{\n\tstruct crosshair\t*c;\n\tint\t\t\t\t\ti, j;\n\n\tPPU.GunVLatch = 1000; // i.e., never latch\n\tPPU.GunHLatch = 0;\n\n\tfor (int n = 0; n < 2; n++)\n\t{\n\t\tswitch (i = curcontrollers[n])\n\t\t{\n\t\t\tcase MP5:\n\t\t\t\tfor (j = 0; j < 4; ++j)\n\t\t\t\t{\n\t\t\t\t\ti = mp5[n].pads[j];\n\t\t\t\t\tif (i == NONE)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (++joypad[i - JOYPAD0].turbo_ct >= turbo_time)\n\t\t\t\t\t{\n\t\t\t\t\t\tjoypad[i - JOYPAD0].turbo_ct = 0;\n\t\t\t\t\t\tjoypad[i - JOYPAD0].buttons ^= joypad[i - JOYPAD0].turbos;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase JOYPAD0:\n\t\t\tcase JOYPAD1:\n\t\t\tcase JOYPAD2:\n\t\t\tcase JOYPAD3:\n\t\t\tcase JOYPAD4:\n\t\t\tcase JOYPAD5:\n\t\t\tcase JOYPAD6:\n\t\t\tcase JOYPAD7:\n\t\t\t\tif (++joypad[i - JOYPAD0].turbo_ct >= turbo_time)\n\t\t\t\t{\n\t\t\t\t\tjoypad[i - JOYPAD0].turbo_ct = 0;\n\t\t\t\t\tjoypad[i - JOYPAD0].buttons ^= joypad[i - JOYPAD0].turbos;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase MOUSE0:\n\t\t\tcase MOUSE1:\n\t\t\t\tc = &mouse[i - MOUSE0].crosshair;\n\t\t\t\tif (IPPU.RenderThisFrame)\n\t\t\t\t\tS9xDrawCrosshair(S9xGetCrosshair(c->img), c->fg, c->bg, mouse[i - MOUSE0].cur_x, mouse[i - MOUSE0].cur_y);\n\t\t\t\tbreak;\n\n\t\t\tcase SUPERSCOPE:\n\t\t\t\tif (n == 1 && !(superscope.phys_buttons & SUPERSCOPE_OFFSCREEN))\n\t\t\t\t{\n\t\t\t\t\tif (superscope.next_buttons & (SUPERSCOPE_FIRE | SUPERSCOPE_CURSOR))\n\t\t\t\t\t\tDoGunLatch(superscope.x, superscope.y);\n\n\t\t\t\t\tc = &superscope.crosshair;\n\t\t\t\t\tif (IPPU.RenderThisFrame)\n\t\t\t\t\t\tS9xDrawCrosshair(S9xGetCrosshair(c->img), c->fg, c->bg, superscope.x, superscope.y);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase TWO_JUSTIFIERS:\n\t\t\t\tif (n == 1 && !justifier.offscreen[1])\n\t\t\t\t{\n\t\t\t\t\tc = &justifier.crosshair[1];\n\t\t\t\t\tif (IPPU.RenderThisFrame)\n\t\t\t\t\t\tS9xDrawCrosshair(S9xGetCrosshair(c->img), c->fg, c->bg, justifier.x[1], justifier.y[1]);\n\t\t\t\t}\n\n\t\t\t\ti = (justifier.buttons & JUSTIFIER_SELECT) ?  1 : 0;\n\t\t\t\tgoto do_justifier;\n\n\t\t\tcase ONE_JUSTIFIER:\n\t\t\t\ti = (justifier.buttons & JUSTIFIER_SELECT) ? -1 : 0;\n\n\t\t\tdo_justifier:\n\t\t\t\tif (n == 1)\n\t\t\t\t{\n\t\t\t\t\tif (i >= 0 && !justifier.offscreen[i])\n\t\t\t\t\t\tDoGunLatch(justifier.x[i], justifier.y[i]);\n\n\t\t\t\t\tif (!justifier.offscreen[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tc = &justifier.crosshair[0];\n\t\t\t\t\t\tif (IPPU.RenderThisFrame)\n\t\t\t\t\t\t\tS9xDrawCrosshair(S9xGetCrosshair(c->img), c->fg, c->bg, justifier.x[0], justifier.y[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase MACSRIFLE:\n\t\t\t\tif (n == 1)\n\t\t\t\t{\n\t\t\t\t\tDoMacsRifleLatch(macsrifle.x, macsrifle.y);\n\n\t\t\t\t\tc = &macsrifle.crosshair;\n\t\t\t\t\tif (IPPU.RenderThisFrame)\n\t\t\t\t\t\tS9xDrawCrosshair(S9xGetCrosshair(c->img), c->fg, c->bg, macsrifle.x, macsrifle.y);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int n = 0; n < 8; n++)\n\t{\n\t\tif (!pseudopointer[n].mapped)\n\t\t\tcontinue;\n\n\t\tif (pseudopointer[n].H_adj)\n\t\t{\n\t\t\tpseudopointer[n].x += pseudopointer[n].H_adj;\n\t\t\tif (pseudopointer[n].x < 0)\n\t\t\t\tpseudopointer[n].x = 0;\n\t\t\telse if (pseudopointer[n].x > 255)\n\t\t\t\tpseudopointer[n].x = 255;\n\n\t\t\tif (pseudopointer[n].H_var)\n\t\t\t{\n\t\t\t\tif (pseudopointer[n].H_adj < 0)\n\t\t\t\t{\n\t\t\t\t\tif (pseudopointer[n].H_adj > -ptrspeeds[3])\n\t\t\t\t\t\tpseudopointer[n].H_adj--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (pseudopointer[n].H_adj <  ptrspeeds[3])\n\t\t\t\t\t\tpseudopointer[n].H_adj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (pseudopointer[n].V_adj)\n\t\t{\n\t\t\tpseudopointer[n].y += pseudopointer[n].V_adj;\n\t\t\tif (pseudopointer[n].y < 0)\n\t\t\t\tpseudopointer[n].y = 0;\n\t\t\telse if (pseudopointer[n].y > PPU.ScreenHeight - 1)\n\t\t\t\tpseudopointer[n].y = PPU.ScreenHeight - 1;\n\n\t\t\tif (pseudopointer[n].V_var)\n\t\t\t{\n\t\t\t\tif (pseudopointer[n].V_adj < 0)\n\t\t\t\t{\n\t\t\t\t\tif (pseudopointer[n].V_adj > -ptrspeeds[3])\n\t\t\t\t\t\tpseudopointer[n].V_adj--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (pseudopointer[n].V_adj <  ptrspeeds[3])\n\t\t\t\t\t\tpseudopointer[n].V_adj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tS9xReportPointer(PseudoPointerBase + n, pseudopointer[n].x, pseudopointer[n].y);\n\t}\n\n\tset<struct exemulti *>::iterator\tit, jt;\n\n\tfor (it = exemultis.begin(); it != exemultis.end(); it++)\n\t{\n\t\ti = ApplyMulti((*it)->script, (*it)->pos, (*it)->data1);\n\n\t\tif (i >= 0)\n\t\t\t(*it)->pos = i;\n\t\telse\n\t\t{\n\t\t\tjt = it;\n\t\t\tit--;\n\t\t\tdelete *jt;\n\t\t\texemultis.erase(jt);\n\t\t}\n\t}\n\n\tdo_polling(POLL_ALL);\n\n\tpad_read_last = pad_read;\n\tpad_read      = false;\n}\n\nvoid S9xSetControllerCrosshair (enum crosscontrols ctl, int8 idx, const char *fg, const char *bg)\n{\n\tstruct crosshair\t*c;\n\tint8\t\t\t\tfgcolor = -1, bgcolor = -1;\n\tint\t\t\t\t\ti, j;\n\n\tif (idx < -1 || idx > 31)\n\t{\n\t\tfprintf(stderr, \"S9xSetControllerCrosshair() called with invalid index\\n\");\n\t\treturn;\n\t}\n\n\tswitch (ctl)\n\t{\n\t\tcase X_MOUSE1:\t\tc = &mouse[0].crosshair;\t\tbreak;\n\t\tcase X_MOUSE2:\t\tc = &mouse[1].crosshair;\t\tbreak;\n\t\tcase X_SUPERSCOPE:\tc = &superscope.crosshair;\t\tbreak;\n\t\tcase X_JUSTIFIER1:\tc = &justifier.crosshair[0];\tbreak;\n\t\tcase X_JUSTIFIER2:\tc = &justifier.crosshair[1];\tbreak;\n\t\tcase X_MACSRIFLE:\tc = &macsrifle.crosshair;\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"S9xSetControllerCrosshair() called with an invalid controller ID %d\\n\", ctl);\n\t\t\treturn;\n\t}\n\n\tif (fg)\n\t{\n\t\tfgcolor = 0;\n\t\tif (*fg == 't')\n\t\t{\n\t\t\tfg++;\n\t\t\tfgcolor = 16;\n\t\t}\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t{\n\t\t\tfor (j = 0; color_names[i][j] && fg[j] == color_names[i][j]; j++) ;\n\n\t\t\tif (isalnum(fg[j]))\n\t\t\t\tcontinue;\n\n\t\t\tif (!color_names[i][j])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfgcolor |= i;\n\t\tif (i > 15 || fgcolor == 16)\n\t\t{\n\t\t\tfprintf(stderr, \"S9xSetControllerCrosshair() called with invalid fgcolor\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (bg)\n\t{\n\t\tbgcolor = 0;\n\t\tif (*bg == 't')\n\t\t{\n\t\t\tbg++;\n\t\t\tbgcolor = 16;\n\t\t}\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t{\n\t\t\tfor (j = 0; color_names[i][j] && bg[j] == color_names[i][j]; j++) ;\n\n\t\t\tif (isalnum(bg[j]))\n\t\t\t\tcontinue;\n\n\t\t\tif (!color_names[i][j])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tbgcolor |= i;\n\t\tif (i > 15 || bgcolor == 16)\n\t\t{\n\t\t\tfprintf(stderr, \"S9xSetControllerCrosshair() called with invalid bgcolor\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (idx != -1)\n\t{\n\t\tc->set |= 1;\n\t\tc->img = idx;\n\t}\n\n\tif (fgcolor != -1)\n\t{\n\t\tc->set |= 2;\n\t\tc->fg = fgcolor;\n\t}\n\n\tif (bgcolor != -1)\n\t{\n\t\tc->set |= 4;\n\t\tc->bg = bgcolor;\n\t}\n}\n\nvoid S9xGetControllerCrosshair (enum crosscontrols ctl, int8 *idx, const char **fg, const char **bg)\n{\n\tstruct crosshair\t*c;\n\n\tswitch (ctl)\n\t{\n\t\tcase X_MOUSE1:\t\tc = &mouse[0].crosshair;\t\tbreak;\n\t\tcase X_MOUSE2:\t\tc = &mouse[1].crosshair;\t\tbreak;\n\t\tcase X_SUPERSCOPE:\tc = &superscope.crosshair;\t\tbreak;\n\t\tcase X_JUSTIFIER1:\tc = &justifier.crosshair[0];\tbreak;\n\t\tcase X_JUSTIFIER2:\tc = &justifier.crosshair[1];\tbreak;\n\t\tcase X_MACSRIFLE:\tc = &macsrifle.crosshair;\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"S9xGetControllerCrosshair() called with an invalid controller ID %d\\n\", ctl);\n\t\t\treturn;\n\t}\n\n\tif (idx)\n\t\t*idx = c->img;\n\n\tif (fg)\n\t\t*fg = color_names[c->fg];\n\n\tif (bg)\n\t\t*bg = color_names[c->bg];\n}\n\nvoid S9xControlPreSaveState (struct SControlSnapshot *s)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->ver = 4;\n\n\tfor (int j = 0; j < 2; j++)\n\t{\n\t\ts->port1_read_idx[j] = read_idx[0][j];\n\t\ts->port2_read_idx[j] = read_idx[1][j];\n\t}\n\n\tfor (int j = 0; j < 2; j++)\n\t\ts->mouse_speed[j] = (mouse[j].buttons & 0x30) >> 4;\n\n\ts->justifier_select = ((justifier.buttons & JUSTIFIER_SELECT) ? 1 : 0);\n\n#define COPY(x)\t{ memcpy((char *) s->internal + i, &(x), sizeof(x)); i += sizeof(x); }\n\n\tint\ti = 0;\n\n\tfor (int j = 0; j < 8; j++)\n\t\tCOPY(joypad[j].buttons);\n\n\tfor (int j = 0; j < 2; j++)\n\t{\n\t\tCOPY(mouse[j].delta_x);\n\t\tCOPY(mouse[j].delta_y);\n\t\tCOPY(mouse[j].old_x);\n\t\tCOPY(mouse[j].old_y);\n\t\tCOPY(mouse[j].cur_x);\n\t\tCOPY(mouse[j].cur_y);\n\t\tCOPY(mouse[j].buttons);\n\t}\n\n\tCOPY(superscope.x);\n\tCOPY(superscope.y);\n\tCOPY(superscope.phys_buttons);\n\tCOPY(superscope.next_buttons);\n\tCOPY(superscope.read_buttons);\n\n\tfor (int j = 0; j < 2; j++)\n\t\tCOPY(justifier.x[j]);\n\tfor (int j = 0; j < 2; j++)\n\t\tCOPY(justifier.y[j]);\n\tCOPY(justifier.buttons);\n\tfor (int j = 0; j < 2; j++)\n\t\tCOPY(justifier.offscreen[j]);\n\n\tfor (int j = 0; j < 2; j++)\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tCOPY(mp5[j].pads[k]);\n\n\tassert(i == sizeof(s->internal));\n\n\t#undef COPY\n\t#define COPY(x)\t{ memcpy((char *) s->internal_macs + i, &(x), sizeof(x)); i += sizeof(x); }\n\ti = 0;\n\n\tCOPY(macsrifle.x);\n\tCOPY(macsrifle.y);\n\tCOPY(macsrifle.buttons);\n\n\tassert(i == sizeof(s->internal_macs));\n\n#undef COPY\n\n\ts->pad_read      = pad_read;\n\ts->pad_read_last = pad_read_last;\n}\n\nvoid S9xControlPostLoadState (struct SControlSnapshot *s)\n{\n\tif (curcontrollers[0] == MP5 && s->ver < 1)\n\t{\n\t\t// Crap. Old snes9x didn't support this.\n\t\tS9xMessage(S9X_WARNING, S9X_FREEZE_FILE_INFO, \"Old savestate has no support for MP5 in port 1.\");\n\t\tnewcontrollers[0] = curcontrollers[0];\n\t\tcurcontrollers[0] = mp5[0].pads[0];\n\t}\n\n\tfor (int j = 0; j < 2; j++)\n\t{\n\t\tread_idx[0][j] = s->port1_read_idx[j];\n\t\tread_idx[1][j] = s->port2_read_idx[j];\n\t}\n\n\tfor (int j = 0; j < 2; j++)\n\t\tmouse[j].buttons |= (s->mouse_speed[j] & 3) << 4;\n\n\tif (s->justifier_select & 1)\n\t\tjustifier.buttons |=  JUSTIFIER_SELECT;\n\telse\n\t\tjustifier.buttons &= ~JUSTIFIER_SELECT;\n\n\tFLAG_LATCH = (Memory.FillRAM[0x4016] & 1) == 1;\n\n\tif (s->ver > 1)\n\t{\n\t#define COPY(x)\t{ memcpy(&(x), (char *) s->internal + i, sizeof(x)); i += sizeof(x); }\n\n\t\tint\ti = 0;\n\n\t\tfor (int j = 0; j < 8; j++)\n\t\t\tCOPY(joypad[j].buttons);\n\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tCOPY(mouse[j].delta_x);\n\t\t\tCOPY(mouse[j].delta_y);\n\t\t\tCOPY(mouse[j].old_x);\n\t\t\tCOPY(mouse[j].old_y);\n\t\t\tCOPY(mouse[j].cur_x);\n\t\t\tCOPY(mouse[j].cur_y);\n\t\t\tCOPY(mouse[j].buttons);\n\t\t}\n\n\t\tCOPY(superscope.x);\n\t\tCOPY(superscope.y);\n\t\tCOPY(superscope.phys_buttons);\n\t\tCOPY(superscope.next_buttons);\n\t\tCOPY(superscope.read_buttons);\n\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tCOPY(justifier.x[j]);\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tCOPY(justifier.y[j]);\n\t\tCOPY(justifier.buttons);\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tCOPY(justifier.offscreen[j]);\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tCOPY(mp5[j].pads[k]);\n\n\t\tassert(i == sizeof(s->internal));\n\n\t\tif (s->ver > 3)\n\t\t{\n\t\t\t#undef COPY\n\t\t\t#define COPY(x)\t{ memcpy(&(x), (char *) s->internal_macs + i, sizeof(x)); i += sizeof(x); }\n\t\t\ti = 0;\n\n\t\t\tCOPY(macsrifle.x);\n\t\t\tCOPY(macsrifle.y);\n\t\t\tCOPY(macsrifle.buttons);\n\n\t\t\tassert(i == sizeof(s->internal_macs));\n\t\t}\n\n\t#undef COPY\n\t}\n\n\tif (s->ver > 2)\n\t{\n\t\tpad_read      = s->pad_read;\n\t\tpad_read_last = s->pad_read_last;\n\t}\n}\n\nuint16 MovieGetJoypad (int i)\n{\n\tif (i < 0 || i > 7)\n\t\treturn (0);\n\n\treturn (joypad[i].buttons);\n}\n\nvoid MovieSetJoypad (int i, uint16 buttons)\n{\n\tif (i < 0 || i > 7)\n\t\treturn;\n\n\tjoypad[i].buttons = buttons;\n}\n\nbool MovieGetMouse (int i, uint8 out[5])\n{\n\tif (i < 0 || i > 1 || (curcontrollers[i] != MOUSE0 && curcontrollers[i] != MOUSE1))\n\t\treturn (false);\n\n\tint\t\tn = curcontrollers[i] - MOUSE0;\n\tuint8\t*ptr = out;\n\n\tWRITE_WORD(ptr, mouse[n].cur_x); ptr += 2;\n\tWRITE_WORD(ptr, mouse[n].cur_y); ptr += 2;\n\t*ptr = mouse[n].buttons;\n\n\treturn (true);\n}\n\nvoid MovieSetMouse (int i, uint8 in[5], bool inPolling)\n{\n\tif (i < 0 || i > 1 || (curcontrollers[i] != MOUSE0 && curcontrollers[i] != MOUSE1))\n\t\treturn;\n\n\tint\t\tn = curcontrollers[i] - MOUSE0;\n\tuint8\t*ptr = in;\n\n\tmouse[n].cur_x = READ_WORD(ptr); ptr += 2;\n\tmouse[n].cur_y = READ_WORD(ptr); ptr += 2;\n\tmouse[n].buttons = *ptr;\n\n\tif (inPolling)\n\t\tUpdatePolledMouse(curcontrollers[i]);\n}\n\nbool MovieGetScope (int i, uint8 out[6])\n{\n\tif (i < 0 || i > 1 || curcontrollers[i] != SUPERSCOPE)\n\t\treturn (false);\n\n\tuint8\t*ptr = out;\n\n\tWRITE_WORD(ptr, superscope.x); ptr += 2;\n\tWRITE_WORD(ptr, superscope.y); ptr += 2;\n\t*ptr++ = superscope.phys_buttons;\n\t*ptr   = superscope.next_buttons;\n\n\treturn (true);\n}\n\nvoid MovieSetScope (int i, uint8 in[6])\n{\n\tif (i < 0 || i > 1 || curcontrollers[i] != SUPERSCOPE)\n\t\treturn;\n\n\tuint8\t*ptr = in;\n\n\tsuperscope.x = READ_WORD(ptr); ptr += 2;\n\tsuperscope.y = READ_WORD(ptr); ptr += 2;\n\tsuperscope.phys_buttons = *ptr++;\n\tsuperscope.next_buttons = *ptr;\n}\n\nbool MovieGetJustifier (int i, uint8 out[11])\n{\n\tif (i < 0 || i > 1 || (curcontrollers[i] != ONE_JUSTIFIER && curcontrollers[i] != TWO_JUSTIFIERS))\n\t\treturn (false);\n\n\tuint8\t*ptr = out;\n\n\tWRITE_WORD(ptr, justifier.x[0]); ptr += 2;\n\tWRITE_WORD(ptr, justifier.x[1]); ptr += 2;\n\tWRITE_WORD(ptr, justifier.y[0]); ptr += 2;\n\tWRITE_WORD(ptr, justifier.y[1]); ptr += 2;\n\t*ptr++ = justifier.buttons;\n\t*ptr++ = justifier.offscreen[0];\n\t*ptr   = justifier.offscreen[1];\n\n\treturn (true);\n}\n\nvoid MovieSetJustifier (int i, uint8 in[11])\n{\n\tif (i < 0 || i > 1 || (curcontrollers[i] != ONE_JUSTIFIER && curcontrollers[i] != TWO_JUSTIFIERS))\n\t\treturn;\n\n\tuint8\t*ptr = in;\n\n\tjustifier.x[0] = READ_WORD(ptr); ptr += 2;\n\tjustifier.x[1] = READ_WORD(ptr); ptr += 2;\n\tjustifier.y[0] = READ_WORD(ptr); ptr += 2;\n\tjustifier.y[1] = READ_WORD(ptr); ptr += 2;\n\tjustifier.buttons      = *ptr++;\n\tjustifier.offscreen[0] = *ptr++;\n\tjustifier.offscreen[1] = *ptr;\n}\n\nbool MovieGetMacsRifle (int i, uint8 out[5])\n{\n\tif (i < 0 || i > 1 || curcontrollers[i] != MACSRIFLE)\n\t\treturn (false);\n\n\tuint8\t*ptr = out;\n\n\tWRITE_WORD(ptr, macsrifle.x); ptr += 2;\n\tWRITE_WORD(ptr, macsrifle.y); ptr += 2;\n\t*ptr = macsrifle.buttons;\n\n\treturn (true);\n}\n\nvoid MovieSetMacsRifle (int i, uint8 in[5])\n{\n\tif (i < 0 || i > 1 || curcontrollers[i] != MACSRIFLE)\n\t\treturn;\n\n\tuint8\t*ptr = in;\n\n\tmacsrifle.x = READ_WORD(ptr); ptr += 2;\n\tmacsrifle.y = READ_WORD(ptr); ptr += 2;\n\tmacsrifle.buttons = *ptr;\n}\n\n"
        },
        {
          "name": "controls.h",
          "type": "blob",
          "size": 9.4072265625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _CONTROLS_H_\n#define _CONTROLS_H_\n\n#define S9xNoMapping\t\t\t0\n#define S9xButtonJoypad\t\t\t1\n#define S9xButtonMouse\t\t\t2\n#define S9xButtonSuperscope\t\t3\n#define S9xButtonJustifier\t\t4\n#define S9xButtonCommand\t\t5\n#define S9xButtonMulti\t\t\t6\n#define S9xButtonMacsRifle\t\t7\n#define S9xAxisJoypad\t\t\t8\n#define S9xPointer\t\t\t\t9\n\n#define S9xButtonPseudopointer\t254\n#define S9xAxisPseudopointer\t253\n#define S9xAxisPseudobuttons\t252\n\n// These are automatically kicked out to the S9xHandlePortCommand function.\n// If your port wants to define port-specific commands or whatever, use these values for the s9xcommand_t type field.\n\n#define S9xButtonPort\t\t\t251\n#define S9xAxisPort\t\t\t\t250\n#define S9xPointerPort\t\t\t249\n\n#define S9xBadMapping\t\t\t255\n#define InvalidControlID\t\t((uint32) -1)\n\n// S9xButtonPseudopointer and S9xAxisPseudopointer will report pointer motion using IDs PseudoPointerBase through PseudoPointerBase+7.\n// S9xAxisPseudopointer command types. S9xAxisPseudobuttons will report buttons with IDs PseudoButtonBase to PseudoButtonBase+255.\n\n#define PseudoPointerBase\t\t(InvalidControlID - 8)\n#define PseudoButtonBase\t\t(PseudoPointerBase - 256)\n\ntypedef struct\n{\n\tuint8\ttype;\n\tuint8\tmulti_press:2;\n\tuint8\tbutton_norpt:1;\n\n\tunion\n\t{\n\t\tunion\n\t\t{\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tuint8\tidx:3;\t\t\t\t// Pad number 0-7\n\t\t\t\tuint8\ttoggle:1;\t\t\t// If set, toggle turbo/sticky for the button\n\t\t\t\tuint8\tturbo:1;\t\t\t// If set, be a 'turbo' button\n\t\t\t\tuint8\tsticky:1;\t\t\t// If set, toggle button state (on/turbo or off) when pressed and do nothing on release\n\t\t\t\tuint16\tbuttons;\t\t\t// Which buttons to actuate. Use SNES_*_MASK constants from snes9x.h\n\t\t\t}\tjoypad;\n\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tuint8\tidx:1;\t\t\t\t// Mouse number 0-1\n\t\t\t\tuint8\tleft:1;\t\t\t\t// buttons\n\t\t\t\tuint8\tright:1;\n\t\t\t}\tmouse;\n\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tuint8\tfire:1;\n\t\t\t\tuint8\tcursor:1;\n\t\t\t\tuint8\tturbo:1;\n\t\t\t\tuint8\tpause:1;\n\t\t\t\tuint8\taim_offscreen:1;\t// Pretend we're pointing the gun offscreen (ignore the pointer)\n\t\t\t}\tscope;\n\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tuint8\tidx:3;\t\t\t\t// Pseudo-pointer number 0-7\n\t\t\t\tuint8\tspeed_type:2;\t\t// 0=variable, 1=slow, 2=med, 3=fast\n\t\t\t\tint8\tUD:2;\t\t\t\t// -1=up, 1=down, 0=no vertical motion\n\t\t\t\tint8\tLR:2;\t\t\t\t// -1=left, 1=right, 0=no horizontal motion\n\t\t\t}\tpointer;\n\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tuint8\tidx:1;\t\t\t\t// Justifier number 0-1\n\t\t\t\tuint8\ttrigger:1;\t\t\t// buttons\n\t\t\t\tuint8\tstart:1;\n\t\t\t\tuint8\taim_offscreen:1;\t// Pretend we're pointing the gun offscreen (ignore the pointer)\n\t\t\t}\tjustifier;\n\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tuint8\ttrigger:1;\n\t\t\t}\tmacsrifle;\n\n\t\t\tint32\tmulti_idx;\n\t\t\tuint16\tcommand;\n\t\t}\tbutton;\n\n\t\tunion\n\t\t{\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tuint8\tidx:3;\t\t\t\t// Pad number 0-7\n\t\t\t\tuint8\tinvert:1;\t\t\t// 1 = positive is Left/Up/Y/X/L\n\t\t\t\tuint8\taxis:3;\t\t\t\t// 0=Left/Right, 1=Up/Down, 2=Y/A, 3=X/B, 4=L/R\n\t\t\t\tuint8\tthreshold;\t\t\t// (threshold+1)/256% deflection is a button press\n\t\t\t}\tjoypad;\n\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tuint8\tidx:3;\t\t\t\t// Pseudo-pointer number 0-7\n\t\t\t\tuint8\tspeed_type:2;\t\t// 0=variable, 1=slow, 2=med, 3=fast\n\t\t\t\tuint8\tinvert:1;\t\t\t// 1 = invert axis, so positive is up/left\n\t\t\t\tuint8\tHV:1;\t\t\t\t// 0=horizontal, 1=vertical\n\t\t\t}\tpointer;\n\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tuint8\tthreshold;\t\t\t// (threshold+1)/256% deflection is a button press\n\t\t\t\tuint8\tnegbutton;\t\t\t// Button ID for negative deflection\n\t\t\t\tuint8\tposbutton;\t\t\t// Button ID for positive deflection\n\t\t\t}\tbutton;\n\t\t}\taxis;\n\n\t\tstruct\t\t\t\t\t\t\t\t// Which SNES-pointers to control with this pointer\n\t\t{\n\t\t\tuint16\taim_mouse0:1;\n\t\t\tuint16\taim_mouse1:1;\n\t\t\tuint16\taim_scope:1;\n\t\t\tuint16\taim_justifier0:1;\n\t\t\tuint16\taim_justifier1:1;\n\t\t\tuint16\taim_macsrifle:1;\n\t\t}\tpointer;\n\n\t\tuint8\tport[4];\n\t};\n}\ts9xcommand_t;\n\n// Starting out...\n\nvoid S9xUnmapAllControls (void);\n\n// Setting which controllers are plugged in.\n\nenum controllers\n{\n\tCTL_NONE,\t\t// all ids ignored\n\tCTL_JOYPAD,\t\t// use id1 to specify 0-7\n\tCTL_MOUSE,\t\t// use id1 to specify 0-1\n\tCTL_SUPERSCOPE,\n\tCTL_JUSTIFIER,\t// use id1: 0=one justifier, 1=two justifiers\n\tCTL_MP5,\t\t\t// use id1-id4 to specify pad 0-7 (or -1)\n\tCTL_MACSRIFLE\n};\n\nvoid S9xSetController (int port, enum controllers controller, int8 id1, int8 id2, int8 id3, int8 id4); // port=0-1\nvoid S9xGetController (int port, enum controllers *controller, int8 *id1, int8 *id2, int8 *id3, int8 *id4);\nvoid S9xReportControllers (void);\n\n// Call this when you're done with S9xSetController, or if you change any of the controller Settings.*Master flags. \n// Returns true if something was disabled.\n\nbool S9xVerifyControllers (void);\n\n// Functions for translation s9xcommand_t's into strings, and vice versa.\n// free() the returned string after you're done with it.\n\nchar * S9xGetCommandName (s9xcommand_t command);\ns9xcommand_t S9xGetCommandT (const char *name);\n\n// Returns an array of strings naming all the snes9x commands.\n// Note that this is only the strings for S9xButtonCommand!\n// The idea is that this would be used for a pull-down list in a config GUI. DO NOT free() the returned value.\n\nconst char ** S9xGetAllSnes9xCommands (void);\n\n// Generic mapping functions\n\ns9xcommand_t S9xGetMapping (uint32 id);\nvoid S9xUnmapID (uint32 id);\n\n// Button mapping functions.\n// If a button is mapped with poll=TRUE, then S9xPollButton will be called whenever snes9x feels a need for that mapping.\n// Otherwise, snes9x will assume you will call S9xReportButton() whenever the button state changes.\n// S9xMapButton() will fail and return FALSE if mapping.type isn't an S9xButton* type.\n\nbool S9xMapButton (uint32 id, s9xcommand_t mapping, bool poll);\nvoid S9xReportButton (uint32 id, bool pressed);\n\n// Pointer mapping functions.\n// If a pointer is mapped with poll=TRUE, then S9xPollPointer will be called whenever snes9x feels a need for that mapping.\n// Otherwise, snes9x will assume you will call S9xReportPointer() whenever the pointer position changes.\n// S9xMapPointer() will fail and return FALSE if mapping.type isn't an S9xPointer* type.\n\n// Note that position [0,0] is considered the upper-left corner of the 'screen',\n// and either [255,223] or [255,239] is the lower-right.\n// Note that the SNES mouse doesn't aim at a particular point,\n// so the SNES's idea of where the mouse pointer is will probably differ from your OS's idea.\n\nbool S9xMapPointer (uint32 id, s9xcommand_t mapping, bool poll);\nvoid S9xReportPointer (uint32 id, int16 x, int16 y);\n\n// Axis mapping functions.\n// If an axis is mapped with poll=TRUE, then S9xPollAxis will be called whenever snes9x feels a need for that mapping.\n// Otherwise, snes9x will assume you will call S9xReportAxis() whenever the axis deflection changes.\n// S9xMapAxis() will fail and return FALSE if mapping.type isn't an S9xAxis* type.\n\n// Note that value is linear -32767 through 32767 with 0 being no deflection.\n// If your axis reports differently you should transform the value before passing it to S9xReportAxis().\n\nbool S9xMapAxis (uint32 id, s9xcommand_t mapping, bool poll);\nvoid S9xReportAxis (uint32 id, int16 value);\n\n// Do whatever the s9xcommand_t says to do.\n// If cmd.type is a button type, data1 should be TRUE (non-0) or FALSE (0) to indicate whether the 'button' is pressed or released.\n// If cmd.type is an axis, data1 holds the deflection value.\n// If cmd.type is a pointer, data1 and data2 are the positions of the pointer.\n\nvoid S9xApplyCommand (s9xcommand_t cmd, int16 data1, int16 data2);\n\n//////////\n// These functions are called by snes9x into your port, so each port should implement them.\n\n// If something was mapped with poll=TRUE, these functions will be called when snes9x needs the button/axis/pointer state.\n// Fill in the reference options as appropriate.\n\nbool S9xPollButton (uint32 id, bool *pressed);\nbool S9xPollPointer (uint32 id, int16 *x, int16 *y);\nbool S9xPollAxis (uint32 id, int16 *value);\n\n// These are called when snes9x tries to apply a command with a S9x*Port type.\n// data1 and data2 are filled in like S9xApplyCommand.\n\nvoid S9xHandlePortCommand (s9xcommand_t cmd, int16 data1, int16 data2);\n\n// Called before already-read SNES joypad data is being used by the game if your port defines SNES_JOY_READ_CALLBACKS.\n\n#ifdef SNES_JOY_READ_CALLBACKS\nvoid S9xOnSNESPadRead (void);\n#endif\n\n// These are for your use.\n\ns9xcommand_t S9xGetPortCommandT (const char *name);\nchar * S9xGetPortCommandName (s9xcommand_t command);\nvoid S9xSetupDefaultKeymap (void);\nbool8 S9xMapInput (const char *name, s9xcommand_t *cmd);\n\n//////////\n// These functions are called from snes9x into this subsystem. No need to use them from a port.\n\n// Use when resetting snes9x.\n\nvoid S9xControlsReset (void);\nvoid S9xControlsSoftReset (void);\n\n// Use when writing to $4016.\n\nvoid S9xSetJoypadLatch (bool latch);\n\n// Use when reading $4016/7 (JOYSER0 and JOYSER1).\n\nuint8 S9xReadJOYSERn (int n);\n\n// End-Of-Frame processing. Sets gun latch variables and tries to draw crosshairs\n\nvoid S9xControlEOF (void);\n\n// Functions and a structure for snapshot.\n\nstruct SControlSnapshot\n{\n\tuint8\tver;\n\tuint8\tport1_read_idx[2];\n\tuint8\tdummy1[4];\t\t\t\t\t// for future expansion\n\tuint8\tport2_read_idx[2];\n\tuint8\tdummy2[4];\n\tuint8\tmouse_speed[2];\n\tuint8\tjustifier_select;\n\tuint8\tdummy3[8];\n\tbool8\tpad_read, pad_read_last;\n\tuint8\tinternal[60];\t\t\t\t// yes, we need to save this!\n\tuint8   internal_macs[5];\n};\n\nvoid S9xControlPreSaveState (struct SControlSnapshot *s);\nvoid S9xControlPostLoadState (struct SControlSnapshot *s);\n\n#endif\n"
        },
        {
          "name": "cpu.cpp",
          "type": "blob",
          "size": 3.6171875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"dma.h\"\n#include \"apu/apu.h\"\n#include \"fxemu.h\"\n#include \"sdd1.h\"\n#include \"srtc.h\"\n#include \"snapshot.h\"\n#include \"cheats.h\"\n#ifdef DEBUGGER\n#include \"debug.h\"\n#endif\n\nstatic void S9xResetCPU (void);\nstatic void S9xSoftResetCPU (void);\n\n\nstatic void S9xResetCPU (void)\n{\n\tS9xSoftResetCPU();\n\tRegisters.SL = 0xff;\n\tRegisters.P.W = 0;\n\tRegisters.A.W = 0;\n\tRegisters.X.W = 0;\n\tRegisters.Y.W = 0;\n\tSetFlags(MemoryFlag | IndexFlag | IRQ | Emulation);\n\tClearFlags(Decimal);\n}\n\nstatic void S9xSoftResetCPU (void)\n{\n\tCPU.Cycles = 182; // Or 188. This is the cycle count just after the jump to the Reset Vector.\n\tCPU.PrevCycles = CPU.Cycles;\n\tCPU.V_Counter = 0;\n\tCPU.Flags = CPU.Flags & (DEBUG_MODE_FLAG | TRACE_FLAG);\n\tCPU.PCBase = NULL;\n\tCPU.NMIPending = FALSE;\n\tCPU.IRQLine = FALSE;\n\tCPU.IRQTransition = FALSE;\n\tCPU.IRQExternal = FALSE;\n\tCPU.MemSpeed = SLOW_ONE_CYCLE;\n\tCPU.MemSpeedx2 = SLOW_ONE_CYCLE * 2;\n\tCPU.FastROMSpeed = SLOW_ONE_CYCLE;\n\tCPU.InDMA = FALSE;\n\tCPU.InHDMA = FALSE;\n\tCPU.InDMAorHDMA = FALSE;\n\tCPU.InWRAMDMAorHDMA = FALSE;\n\tCPU.HDMARanInDMA = 0;\n\tCPU.CurrentDMAorHDMAChannel = -1;\n\tCPU.WhichEvent = HC_RENDER_EVENT;\n\tCPU.NextEvent  = Timings.RenderPos;\n\tCPU.WaitingForInterrupt = FALSE;\n\tCPU.AutoSaveTimer = 0;\n\tCPU.SRAMModified = FALSE;\n\n\tRegisters.PBPC = 0;\n\tRegisters.PB = 0;\n\tRegisters.PCw = S9xGetWord(0xfffc);\n\tOpenBus = Registers.PCh;\n\tRegisters.D.W = 0;\n\tRegisters.DB = 0;\n\tRegisters.SH = 1;\n\tRegisters.SL -= 3;\n\tRegisters.XH = 0;\n\tRegisters.YH = 0;\n\n\tICPU.ShiftedPB = 0;\n\tICPU.ShiftedDB = 0;\n\tSetFlags(MemoryFlag | IndexFlag | IRQ | Emulation);\n\tClearFlags(Decimal);\n\n\tTimings.H_Max = Timings.H_Max_Master;\n\tTimings.V_Max = Timings.V_Max_Master;\n\tTimings.NMITriggerPos = 0xffff;\n\tTimings.NextIRQTimer = 0x0fffffff;\n\tTimings.IRQFlagChanging = IRQ_NONE;\n\n\tif (Model->_5A22 == 2)\n\t\tTimings.WRAMRefreshPos = SNES_WRAM_REFRESH_HC_v2;\n\telse\n\t\tTimings.WRAMRefreshPos = SNES_WRAM_REFRESH_HC_v1;\n\n\tS9xSetPCBase(Registers.PBPC);\n\n\tICPU.S9xOpcodes = S9xOpcodesE1;\n\tICPU.S9xOpLengths = S9xOpLengthsM1X1;\n\n\tS9xUnpackStatus();\n}\n\nvoid S9xReset (void)\n{\n\tS9xResetSaveTimer(FALSE);\n\n\tmemset(Memory.RAM, 0x55, sizeof(Memory.RAM));\n\tmemset(Memory.VRAM, 0x00, sizeof(Memory.VRAM));\n\tmemset(Memory.FillRAM, 0, 0x8000);\n\n\tS9xResetBSX();\n\tS9xResetCPU();\n\tS9xResetPPU();\n\tS9xResetDMA();\n\tS9xResetAPU();\n    S9xResetMSU();\n\n\tif (Settings.DSP)\n\t\tS9xResetDSP();\n\tif (Settings.SuperFX)\n\t\tS9xResetSuperFX();\n\tif (Settings.SA1)\n\t\tS9xSA1Init();\n\tif (Settings.SDD1)\n\t\tS9xResetSDD1();\n\tif (Settings.SPC7110)\n\t\tS9xResetSPC7110();\n\tif (Settings.C4)\n\t\tS9xInitC4();\n\tif (Settings.OBC1)\n\t\tS9xResetOBC1();\n\tif (Settings.SRTC)\n\t\tS9xResetSRTC();\n\tif (Settings.MSU1)\n\t\tS9xMSU1Init();\n\n\tS9xInitCheatData();\n}\n\nvoid S9xSoftReset (void)\n{\n\tS9xResetSaveTimer(FALSE);\n\n\tmemset(Memory.FillRAM, 0, 0x8000);\n\n\tif (Settings.BS)\n\t\tS9xResetBSX();\n\n\tS9xSoftResetCPU();\n\tS9xSoftResetPPU();\n\tS9xResetDMA();\n\tS9xSoftResetAPU();\n    S9xResetMSU();\n\n\tif (Settings.DSP)\n\t\tS9xResetDSP();\n\tif (Settings.SuperFX)\n\t\tS9xResetSuperFX();\n\tif (Settings.SA1)\n\t\tS9xSA1Init();\n\tif (Settings.SDD1)\n\t\tS9xResetSDD1();\n\tif (Settings.SPC7110)\n\t\tS9xResetSPC7110();\n\tif (Settings.C4)\n\t\tS9xInitC4();\n\tif (Settings.OBC1)\n\t\tS9xResetOBC1();\n\tif (Settings.SRTC)\n\t\tS9xResetSRTC();\n\tif (Settings.MSU1)\n\t\tS9xMSU1Init();\n\n\tS9xInitCheatData();\n}\n"
        },
        {
          "name": "cpuaddr.h",
          "type": "blob",
          "size": 11.3310546875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _CPUADDR_H_\n#define _CPUADDR_H_\n\ntypedef enum\n{\n\tNONE   = 0,\n\tREAD   = 1,\n\tWRITE  = 2,\n\tMODIFY = 3,\n\tJUMP   = 5,\n\tJSR    = 8\n}\tAccessMode;\n\nstatic inline uint8 Immediate8Slow (AccessMode a)\n{\n\tuint8\tval = S9xGetByte(Registers.PBPC);\n\tif (a & READ)\n\t\tOpenBus = val;\n\tRegisters.PCw++;\n\n\treturn (val);\n}\n\nstatic inline uint8 Immediate8 (AccessMode a)\n{\n\tuint8\tval = CPU.PCBase[Registers.PCw];\n\tif (a & READ)\n\t\tOpenBus = val;\n\tAddCycles(CPU.MemSpeed);\n\tRegisters.PCw++;\n\n\treturn (val);\n}\n\nstatic inline uint16 Immediate16Slow (AccessMode a)\n{\n\tuint16\tval = S9xGetWord(Registers.PBPC, WRAP_BANK);\n\tif (a & READ)\n\t\tOpenBus = (uint8) (val >> 8);\n\tRegisters.PCw += 2;\n\n\treturn (val);\n}\n\nstatic inline uint16 Immediate16 (AccessMode a)\n{\n\tuint16\tval = READ_WORD(CPU.PCBase + Registers.PCw);\n\tif (a & READ)\n\t\tOpenBus = (uint8) (val >> 8);\n\tAddCycles(CPU.MemSpeedx2);\n\tRegisters.PCw += 2;\n\n\treturn (val);\n}\n\nstatic inline uint32 RelativeSlow (AccessMode a)\t\t\t\t\t\t// branch $xx\n{\n\tint8\toffset = Immediate8Slow(a);\n\n\treturn ((int16) Registers.PCw + offset) & 0xffff;\n}\n\nstatic inline uint32 Relative (AccessMode a)\t\t\t\t\t\t\t// branch $xx\n{\n\tint8\toffset = Immediate8(a);\n\n\treturn ((int16) Registers.PCw + offset) & 0xffff;\n}\n\nstatic inline uint32 RelativeLongSlow (AccessMode a)\t\t\t\t\t// BRL $xxxx\n{\n\tint16\toffset = Immediate16Slow(a);\n\n\treturn ((int32) Registers.PCw + offset) & 0xffff;\n}\n\nstatic inline uint32 RelativeLong (AccessMode a)\t\t\t\t\t\t// BRL $xxxx\n{\n\tint16\toffset = Immediate16(a);\n\n\treturn ((int32) Registers.PCw + offset) & 0xffff;\n}\n\nstatic inline uint32 AbsoluteIndexedIndirectSlow (AccessMode a)\t\t\t// (a,X)\n{\n\tuint16\taddr;\n\n\tif (a & JSR)\n\t{\n\t\t// JSR (a,X) pushes the old address in the middle of loading the new.\n\t\t// OpenBus needs to be set to account for this.\n\t\taddr = Immediate8Slow(READ);\n\t\tif (a == JSR)\n\t\t\tOpenBus = Registers.PCl;\n\t\taddr |= Immediate8Slow(READ) << 8;\n\t}\n\telse\n\t\taddr = Immediate16Slow(READ);\n\n\tAddCycles(ONE_CYCLE);\n\taddr += Registers.X.W;\n\n\t// Address load wraps within the bank\n\tuint16\taddr2 = S9xGetWord(ICPU.ShiftedPB | addr, WRAP_BANK);\n\tOpenBus = addr2 >> 8;\n\n\treturn (addr2);\n}\n\nstatic inline uint32 AbsoluteIndexedIndirect (AccessMode a)\t\t\t\t// (a,X)\n{\n\tuint16\taddr = Immediate16Slow(READ);\n\n\tAddCycles(ONE_CYCLE);\n\taddr += Registers.X.W;\n\n\t// Address load wraps within the bank\n\tuint16\taddr2 = S9xGetWord(ICPU.ShiftedPB | addr, WRAP_BANK);\n\tOpenBus = addr2 >> 8;\n\n\treturn (addr2);\n}\n\nstatic inline uint32 AbsoluteIndirectLongSlow (AccessMode a)\t\t\t// [a]\n{\n\tuint16\taddr = Immediate16Slow(READ);\n\n\t// No info on wrapping, but it doesn't matter anyway due to mirroring\n\tuint32\taddr2 = S9xGetWord(addr);\n\tOpenBus = addr2 >> 8;\n\taddr2 |= (OpenBus = S9xGetByte(addr + 2)) << 16;\n\n\treturn (addr2);\n}\n\nstatic inline uint32 AbsoluteIndirectLong (AccessMode a)\t\t\t\t// [a]\n{\n\tuint16\taddr = Immediate16(READ);\n\n\t// No info on wrapping, but it doesn't matter anyway due to mirroring\n\tuint32\taddr2 = S9xGetWord(addr);\n\tOpenBus = addr2 >> 8;\n\taddr2 |= (OpenBus = S9xGetByte(addr + 2)) << 16;\n\n\treturn (addr2);\n}\n\nstatic inline uint32 AbsoluteIndirectSlow (AccessMode a)\t\t\t\t// (a)\n{\n\t// No info on wrapping, but it doesn't matter anyway due to mirroring\n\tuint16\taddr2 = S9xGetWord(Immediate16Slow(READ));\n\tOpenBus = addr2 >> 8;\n\n\treturn (addr2);\n}\n\nstatic inline uint32 AbsoluteIndirect (AccessMode a)\t\t\t\t\t// (a)\n{\n\t// No info on wrapping, but it doesn't matter anyway due to mirroring\n\tuint16\taddr2 = S9xGetWord(Immediate16(READ));\n\tOpenBus = addr2 >> 8;\n\n\treturn (addr2);\n}\n\nstatic inline uint32 AbsoluteSlow (AccessMode a)\t\t\t\t\t\t// a\n{\n\treturn (ICPU.ShiftedDB | Immediate16Slow(a));\n}\n\nstatic inline uint32 Absolute (AccessMode a)\t\t\t\t\t\t\t// a\n{\n\treturn (ICPU.ShiftedDB | Immediate16(a));\n}\n\nstatic inline uint32 AbsoluteLongSlow (AccessMode a)\t\t\t\t\t// l\n{\n\tuint32\taddr = Immediate16Slow(READ);\n\n\t// JSR l pushes the old bank in the middle of loading the new.\n\t// OpenBus needs to be set to account for this.\n\tif (a == JSR)\n\t\tOpenBus = Registers.PB;\n\n\taddr |= Immediate8Slow(a) << 16;\n\n\treturn (addr);\n}\n\nstatic inline uint32 AbsoluteLong (AccessMode a)\t\t\t\t\t\t// l\n{\n\tuint32\taddr = READ_3WORD(CPU.PCBase + Registers.PCw);\n\tAddCycles(CPU.MemSpeedx2 + CPU.MemSpeed);\n\tif (a & READ)\n\t\tOpenBus = addr >> 16;\n\tRegisters.PCw += 3;\n\n\treturn (addr);\n}\n\nstatic inline uint32 DirectSlow (AccessMode a)\t\t\t\t\t\t\t// d\n{\n\tuint16\taddr = Immediate8Slow(a) + Registers.D.W;\n\tif (Registers.DL != 0)\n\t\tAddCycles(ONE_CYCLE);\n\n\treturn (addr);\n}\n\nstatic inline uint32 Direct (AccessMode a)\t\t\t\t\t\t\t\t// d\n{\n\tuint16\taddr = Immediate8(a) + Registers.D.W;\n\tif (Registers.DL != 0)\n\t\tAddCycles(ONE_CYCLE);\n\n\treturn (addr);\n}\n\nstatic inline uint32 DirectIndirectSlow (AccessMode a)\t\t\t\t\t// (d)\n{\n\tuint32\taddr = S9xGetWord(DirectSlow(READ), (!CheckEmulation() || Registers.DL) ? WRAP_BANK : WRAP_PAGE);\n\tif (a & READ)\n\t\tOpenBus = (uint8) (addr >> 8);\n\taddr |= ICPU.ShiftedDB;\n\n\treturn (addr);\n}\n\nstatic inline uint32 DirectIndirectE0 (AccessMode a)\t\t\t\t\t// (d)\n{\n\tuint32\taddr = S9xGetWord(Direct(READ));\n\tif (a & READ)\n\t\tOpenBus = (uint8) (addr >> 8);\n\taddr |= ICPU.ShiftedDB;\n\n\treturn (addr);\n}\n\nstatic inline uint32 DirectIndirectE1 (AccessMode a)\t\t\t\t\t// (d)\n{\n\tuint32\taddr = S9xGetWord(DirectSlow(READ), Registers.DL ? WRAP_BANK : WRAP_PAGE);\n\tif (a & READ)\n\t\tOpenBus = (uint8) (addr >> 8);\n\taddr |= ICPU.ShiftedDB;\n\n\treturn (addr);\n}\n\nstatic inline uint32 DirectIndirectIndexedSlow (AccessMode a)\t\t\t// (d),Y\n{\n\tuint32\taddr = DirectIndirectSlow(a);\n\tif (a & WRITE || !CheckIndex() || (addr & 0xff) + Registers.YL >= 0x100)\n\t\tAddCycles(ONE_CYCLE);\n\n\treturn (addr + Registers.Y.W);\n}\n\nstatic inline uint32 DirectIndirectIndexedE0X0 (AccessMode a)\t\t\t// (d),Y\n{\n\tuint32\taddr = DirectIndirectE0(a);\n\tAddCycles(ONE_CYCLE);\n\n\treturn (addr + Registers.Y.W);\n}\n\nstatic inline uint32 DirectIndirectIndexedE0X1 (AccessMode a)\t\t\t// (d),Y\n{\n\tuint32\taddr = DirectIndirectE0(a);\n\tif (a & WRITE || (addr & 0xff) + Registers.YL >= 0x100)\n\t\tAddCycles(ONE_CYCLE);\n\n\treturn (addr + Registers.Y.W);\n}\n\nstatic inline uint32 DirectIndirectIndexedE1 (AccessMode a)\t\t\t\t// (d),Y\n{\n\tuint32\taddr = DirectIndirectE1(a);\n\tif (a & WRITE || (addr & 0xff) + Registers.YL >= 0x100)\n\t\tAddCycles(ONE_CYCLE);\n\n\treturn (addr + Registers.Y.W);\n}\n\nstatic inline uint32 DirectIndirectLongSlow (AccessMode a)\t\t\t\t// [d]\n{\n\tuint16\taddr = DirectSlow(READ);\n\tuint32\taddr2 = S9xGetWord(addr);\n\tOpenBus = addr2 >> 8;\n\taddr2 |= (OpenBus = S9xGetByte(addr + 2)) << 16;\n\n\treturn (addr2);\n}\n\nstatic inline uint32 DirectIndirectLong (AccessMode a)\t\t\t\t\t// [d]\n{\n\tuint16\taddr = Direct(READ);\n\tuint32\taddr2 = S9xGetWord(addr);\n\tOpenBus = addr2 >> 8;\n\taddr2 |= (OpenBus = S9xGetByte(addr + 2)) << 16;\n\n\treturn (addr2);\n}\n\nstatic inline uint32 DirectIndirectIndexedLongSlow (AccessMode a)\t\t// [d],Y\n{\n\treturn (DirectIndirectLongSlow(a) + Registers.Y.W);\n}\n\nstatic inline uint32 DirectIndirectIndexedLong (AccessMode a)\t\t\t// [d],Y\n{\n\treturn (DirectIndirectLong(a) + Registers.Y.W);\n}\n\nstatic inline uint32 DirectIndexedXSlow (AccessMode a)\t\t\t\t\t// d,X\n{\n\tpair\taddr;\n\taddr.W = DirectSlow(a);\n\tif (!CheckEmulation() || Registers.DL)\n\t\taddr.W += Registers.X.W;\n\telse\n\t\taddr.B.l += Registers.XL;\n\n\tAddCycles(ONE_CYCLE);\n\n\treturn (addr.W);\n}\n\nstatic inline uint32 DirectIndexedXE0 (AccessMode a)\t\t\t\t\t// d,X\n{\n\tuint16\taddr = Direct(a) + Registers.X.W;\n\tAddCycles(ONE_CYCLE);\n\n\treturn (addr);\n}\n\nstatic inline uint32 DirectIndexedXE1 (AccessMode a)\t\t\t\t\t// d,X\n{\n\tif (Registers.DL)\n\t\treturn (DirectIndexedXE0(a));\n\telse\n\t{\n\t\tpair\taddr;\n\t\taddr.W = Direct(a);\n\t\taddr.B.l += Registers.XL;\n\t\tAddCycles(ONE_CYCLE);\n\n\t\treturn (addr.W);\n\t}\n}\n\nstatic inline uint32 DirectIndexedYSlow (AccessMode a)\t\t\t\t\t// d,Y\n{\n\tpair\taddr;\n\taddr.W = DirectSlow(a);\n\tif (!CheckEmulation() || Registers.DL)\n\t\taddr.W += Registers.Y.W;\n\telse\n\t\taddr.B.l += Registers.YL;\n\n\tAddCycles(ONE_CYCLE);\n\n\treturn (addr.W);\n}\n\nstatic inline uint32 DirectIndexedYE0 (AccessMode a)\t\t\t\t\t// d,Y\n{\n\tuint16\taddr = Direct(a) + Registers.Y.W;\n\tAddCycles(ONE_CYCLE);\n\n\treturn (addr);\n}\n\nstatic inline uint32 DirectIndexedYE1 (AccessMode a)\t\t\t\t\t// d,Y\n{\n\tif (Registers.DL)\n\t\treturn (DirectIndexedYE0(a));\n\telse\n\t{\n\t\tpair\taddr;\n\t\taddr.W = Direct(a);\n\t\taddr.B.l += Registers.YL;\n\t\tAddCycles(ONE_CYCLE);\n\n\t\treturn (addr.W);\n\t}\n}\n\nstatic inline uint32 DirectIndexedIndirectSlow (AccessMode a)\t\t\t// (d,X)\n{\n\tuint32\taddr = S9xGetWord(DirectIndexedXSlow(READ), (!CheckEmulation() || Registers.DL) ? WRAP_BANK : WRAP_PAGE);\n\tif (a & READ)\n\t\tOpenBus = (uint8) (addr >> 8);\n\n\treturn (ICPU.ShiftedDB | addr);\n}\n\nstatic inline uint32 DirectIndexedIndirectE0 (AccessMode a)\t\t\t\t// (d,X)\n{\n\tuint32\taddr = S9xGetWord(DirectIndexedXE0(READ));\n\tif (a & READ)\n\t\tOpenBus = (uint8) (addr >> 8);\n\n\treturn (ICPU.ShiftedDB | addr);\n}\n\nstatic inline uint32 DirectIndexedIndirectE1 (AccessMode a)\t\t\t\t// (d,X)\n{\n\tuint32\taddr = S9xGetWord(DirectIndexedXE1(READ), Registers.DL ? WRAP_BANK : WRAP_PAGE);\n\tif (a & READ)\n\t\tOpenBus = (uint8) (addr >> 8);\n\n\treturn (ICPU.ShiftedDB | addr);\n}\n\nstatic inline uint32 AbsoluteIndexedXSlow (AccessMode a)\t\t\t\t// a,X\n{\n\tuint32\taddr = AbsoluteSlow(a);\n\tif (a & WRITE || !CheckIndex() || (addr & 0xff) + Registers.XL >= 0x100)\n\t\tAddCycles(ONE_CYCLE);\n\n\treturn (addr + Registers.X.W);\n}\n\nstatic inline uint32 AbsoluteIndexedXX0 (AccessMode a)\t\t\t\t\t// a,X\n{\n\tuint32\taddr = Absolute(a);\n\tAddCycles(ONE_CYCLE);\n\n\treturn (addr + Registers.X.W);\n}\n\nstatic inline uint32 AbsoluteIndexedXX1 (AccessMode a)\t\t\t\t\t// a,X\n{\n\tuint32\taddr = Absolute(a);\n\tif (a & WRITE || (addr & 0xff) + Registers.XL >= 0x100)\n\t\tAddCycles(ONE_CYCLE);\n\n\treturn (addr + Registers.X.W);\n}\n\nstatic inline uint32 AbsoluteIndexedYSlow (AccessMode a)\t\t\t\t// a,Y\n{\n\tuint32\taddr = AbsoluteSlow(a);\n\tif (a & WRITE || !CheckIndex() || (addr & 0xff) + Registers.YL >= 0x100)\n\t\tAddCycles(ONE_CYCLE);\n\n\treturn (addr + Registers.Y.W);\n}\n\nstatic inline uint32 AbsoluteIndexedYX0 (AccessMode a)\t\t\t\t\t// a,Y\n{\n\tuint32\taddr = Absolute(a);\n\tAddCycles(ONE_CYCLE);\n\n\treturn (addr + Registers.Y.W);\n}\n\nstatic inline uint32 AbsoluteIndexedYX1 (AccessMode a)\t\t\t\t\t// a,Y\n{\n\tuint32\taddr = Absolute(a);\n\tif (a & WRITE || (addr & 0xff) + Registers.YL >= 0x100)\n\t\tAddCycles(ONE_CYCLE);\n\n\treturn (addr + Registers.Y.W);\n}\n\nstatic inline uint32 AbsoluteLongIndexedXSlow (AccessMode a)\t\t\t// l,X\n{\n\treturn (AbsoluteLongSlow(a) + Registers.X.W);\n}\n\nstatic inline uint32 AbsoluteLongIndexedX (AccessMode a)\t\t\t\t// l,X\n{\n\treturn (AbsoluteLong(a) + Registers.X.W);\n}\n\nstatic inline uint32 StackRelativeSlow (AccessMode a)\t\t\t\t\t// d,S\n{\n\tuint16\taddr = Immediate8Slow(a) + Registers.S.W;\n\tAddCycles(ONE_CYCLE);\n\n\treturn (addr);\n}\n\nstatic inline uint32 StackRelative (AccessMode a)\t\t\t\t\t\t// d,S\n{\n\tuint16\taddr = Immediate8(a) + Registers.S.W;\n\tAddCycles(ONE_CYCLE);\n\n\treturn (addr);\n}\n\nstatic inline uint32 StackRelativeIndirectIndexedSlow (AccessMode a)\t// (d,S),Y\n{\n\tuint32\taddr = S9xGetWord(StackRelativeSlow(READ));\n\tif (a & READ)\n\t\tOpenBus = (uint8) (addr >> 8);\n\taddr = (addr + Registers.Y.W + ICPU.ShiftedDB) & 0xffffff;\n\tAddCycles(ONE_CYCLE);\n\n\treturn (addr);\n}\n\nstatic inline uint32 StackRelativeIndirectIndexed (AccessMode a)\t\t// (d,S),Y\n{\n\tuint32\taddr = S9xGetWord(StackRelative(READ));\n\tif (a & READ)\n\t\tOpenBus = (uint8) (addr >> 8);\n\taddr = (addr + Registers.Y.W + ICPU.ShiftedDB) & 0xffffff;\n\n\treturn (addr);\n}\n\n#endif\n"
        },
        {
          "name": "cpuexec.cpp",
          "type": "blob",
          "size": 10.3515625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"cpuops.h\"\n#include \"dma.h\"\n#include \"apu/apu.h\"\n#include \"fxemu.h\"\n#include \"snapshot.h\"\n#include \"movie.h\"\n#ifdef DEBUGGER\n#include \"debug.h\"\n#include \"missing.h\"\n#endif\n\nstatic inline void S9xReschedule (void);\n\nvoid S9xMainLoop (void)\n{\n\t#define CHECK_FOR_IRQ_CHANGE() \\\n\tif (Timings.IRQFlagChanging) \\\n\t{ \\\n\t\tif (Timings.IRQFlagChanging & IRQ_TRIGGER_NMI) \\\n\t\t{ \\\n\t\t\tCPU.NMIPending = TRUE; \\\n\t\t\tTimings.NMITriggerPos = CPU.Cycles + 6; \\\n\t\t} \\\n\t\tif (Timings.IRQFlagChanging & IRQ_CLEAR_FLAG) \\\n\t\t\tClearIRQ(); \\\n\t\telse if (Timings.IRQFlagChanging & IRQ_SET_FLAG) \\\n\t\t\tSetIRQ(); \\\n\t\tTimings.IRQFlagChanging = IRQ_NONE; \\\n\t}\n\n\tif (CPU.Flags & SCAN_KEYS_FLAG)\n\t{\n\t\tCPU.Flags &= ~SCAN_KEYS_FLAG;\n\t\tS9xMovieUpdate();\n\t}\n\n\tfor (;;)\n\t{\n\t\tif (CPU.NMIPending)\n\t\t{\n\t\t\t#ifdef DEBUGGER\n\t\t\tif (Settings.TraceHCEvent)\n\t\t\t    S9xTraceFormattedMessage (\"Comparing %d to %d\\n\", Timings.NMITriggerPos, CPU.Cycles);\n\t\t\t#endif\n\t\t\tif (Timings.NMITriggerPos <= CPU.Cycles)\n\t\t\t{\n\t\t\t\tCPU.NMIPending = FALSE;\n\t\t\t\tTimings.NMITriggerPos = 0xffff;\n\t\t\t\tif (CPU.WaitingForInterrupt)\n\t\t\t\t{\n\t\t\t\t\tCPU.WaitingForInterrupt = FALSE;\n\t\t\t\t\tRegisters.PCw++;\n\t\t\t\t\tCPU.Cycles += TWO_CYCLES + ONE_DOT_CYCLE / 2;\n\t\t\t\t\twhile (CPU.Cycles >= CPU.NextEvent)\n\t\t\t\t\t\tS9xDoHEventProcessing();\n\t\t\t\t}\n\n\t\t\t\tCHECK_FOR_IRQ_CHANGE();\n\t\t\t\tS9xOpcode_NMI();\n\t\t\t}\n\t\t}\n\n\t\tif (CPU.Cycles >= Timings.NextIRQTimer)\n\t\t{\n\t\t\t#ifdef DEBUGGER\n\t\t\tS9xTraceMessage (\"Timer triggered\\n\");\n\t\t\t#endif\n\n\t\t\tS9xUpdateIRQPositions(false);\n\t\t\tCPU.IRQLine = TRUE;\n\t\t}\n\n\t\tif (CPU.IRQLine || CPU.IRQExternal)\n\t\t{\n\t\t\tif (CPU.WaitingForInterrupt)\n\t\t\t{\n\t\t\t\tCPU.WaitingForInterrupt = FALSE;\n\t\t\t\tRegisters.PCw++;\n\t\t\t\tCPU.Cycles += TWO_CYCLES + ONE_DOT_CYCLE / 2;\n\t\t\t\twhile (CPU.Cycles >= CPU.NextEvent)\n\t\t\t\t\tS9xDoHEventProcessing();\n\t\t\t}\n\n\t\t\tif (!CheckFlag(IRQ))\n\t\t\t{\n\t\t\t\t/* The flag pushed onto the stack is the new value */\n\t\t\t\tCHECK_FOR_IRQ_CHANGE();\n\t\t\t\tS9xOpcode_IRQ();\n\t\t\t}\n\t\t}\n\n\t\t/* Change IRQ flag for instructions that set it only on last cycle */\n\t\tCHECK_FOR_IRQ_CHANGE();\n\n\t#ifdef DEBUGGER\n\t\tif ((CPU.Flags & BREAK_FLAG) && !(CPU.Flags & SINGLE_STEP_FLAG))\n\t\t{\n\t\t\tfor (int Break = 0; Break != 6; Break++)\n\t\t\t{\n\t\t\t\tif (S9xBreakpoint[Break].Enabled &&\n\t\t\t\t\tS9xBreakpoint[Break].Bank == Registers.PB &&\n\t\t\t\t\tS9xBreakpoint[Break].Address == Registers.PCw)\n\t\t\t\t{\n\t\t\t\t\tif (S9xBreakpoint[Break].Enabled == 2)\n\t\t\t\t\t\tS9xBreakpoint[Break].Enabled = TRUE;\n\t\t\t\t\telse\n\t\t\t\t\t\tCPU.Flags |= DEBUG_MODE_FLAG;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (CPU.Flags & DEBUG_MODE_FLAG)\n\t\t\tbreak;\n\n\t\tif (CPU.Flags & TRACE_FLAG)\n\t\t\tS9xTrace();\n\n\t\tif (CPU.Flags & SINGLE_STEP_FLAG)\n\t\t{\n\t\t\tCPU.Flags &= ~SINGLE_STEP_FLAG;\n\t\t\tCPU.Flags |= DEBUG_MODE_FLAG;\n\t\t}\n\t#endif\n\n\t\tif (CPU.Flags & SCAN_KEYS_FLAG)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tuint8\t\t\t\tOp;\n\t\tstruct\tSOpcodes\t*Opcodes;\n\n\t\tif (CPU.PCBase)\n\t\t{\n\t\t\tOp = CPU.PCBase[Registers.PCw];\n\t\t\tCPU.Cycles += CPU.MemSpeed;\n\t\t\tOpcodes = ICPU.S9xOpcodes;\n\n\t\t\tif (CPU.Cycles > 1000000)\n\t\t\t{\n\t\t\t\tSettings.StopEmulation = true;\n\t\t\t\tCPU.Flags |= HALTED_FLAG;\n\t\t\t\tS9xMessage(S9X_FATAL_ERROR, 0, \"CPU is deadlocked\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOp = S9xGetByte(Registers.PBPC);\n\t\t\tOpenBus = Op;\n\t\t\tOpcodes = S9xOpcodesSlow;\n\t\t}\n\n\t\tif ((Registers.PCw & MEMMAP_MASK) + ICPU.S9xOpLengths[Op] >= MEMMAP_BLOCK_SIZE)\n\t\t{\n\t\t\tuint8\t*oldPCBase = CPU.PCBase;\n\n\t\t\tCPU.PCBase = S9xGetBasePointer(ICPU.ShiftedPB + ((uint16) (Registers.PCw + 4)));\n\t\t\tif (oldPCBase != CPU.PCBase || (Registers.PCw & ~MEMMAP_MASK) == (0xffff & ~MEMMAP_MASK))\n\t\t\t\tOpcodes = S9xOpcodesSlow;\n\t\t}\n\n\t\tRegisters.PCw++;\n\t\t(*Opcodes[Op].S9xOpcode)();\n\n\t\tif (Settings.SA1)\n\t\t\tS9xSA1MainLoop();\n\t}\n\n\tS9xPackStatus();\n}\n\nstatic inline void S9xReschedule (void)\n{\n\tswitch (CPU.WhichEvent)\n\t{\n\t\tcase HC_HBLANK_START_EVENT:\n\t\t\tCPU.WhichEvent = HC_HDMA_START_EVENT;\n\t\t\tCPU.NextEvent  = Timings.HDMAStart;\n\t\t\tbreak;\n\n\t\tcase HC_HDMA_START_EVENT:\n\t\t\tCPU.WhichEvent = HC_HCOUNTER_MAX_EVENT;\n\t\t\tCPU.NextEvent  = Timings.H_Max;\n\t\t\tbreak;\n\n\t\tcase HC_HCOUNTER_MAX_EVENT:\n\t\t\tCPU.WhichEvent = HC_HDMA_INIT_EVENT;\n\t\t\tCPU.NextEvent  = Timings.HDMAInit;\n\t\t\tbreak;\n\n\t\tcase HC_HDMA_INIT_EVENT:\n\t\t\tCPU.WhichEvent = HC_RENDER_EVENT;\n\t\t\tCPU.NextEvent  = Timings.RenderPos;\n\t\t\tbreak;\n\n\t\tcase HC_RENDER_EVENT:\n\t\t\tCPU.WhichEvent = HC_WRAM_REFRESH_EVENT;\n\t\t\tCPU.NextEvent  = Timings.WRAMRefreshPos;\n\t\t\tbreak;\n\n\t\tcase HC_WRAM_REFRESH_EVENT:\n\t\t\tCPU.WhichEvent = HC_HBLANK_START_EVENT;\n\t\t\tCPU.NextEvent  = Timings.HBlankStart;\n\t\t\tbreak;\n\t}\n}\n\nvoid S9xDoHEventProcessing (void)\n{\n#ifdef DEBUGGER\n\tstatic char\teventname[7][32] =\n\t{\n\t\t\"\",\n\t\t\"HC_HBLANK_START_EVENT\",\n\t\t\"HC_HDMA_START_EVENT  \",\n\t\t\"HC_HCOUNTER_MAX_EVENT\",\n\t\t\"HC_HDMA_INIT_EVENT   \",\n\t\t\"HC_RENDER_EVENT      \",\n\t\t\"HC_WRAM_REFRESH_EVENT\"\n\t};\n#endif\n\n#ifdef DEBUGGER\n\tif (Settings.TraceHCEvent)\n\t\tS9xTraceFormattedMessage(\"--- HC event processing  (%s)  expected HC:%04d  executed HC:%04d VC:%04d\",\n\t\t\teventname[CPU.WhichEvent], CPU.NextEvent, CPU.Cycles, CPU.V_Counter);\n#endif\n\n\tswitch (CPU.WhichEvent)\n\t{\n\t\tcase HC_HBLANK_START_EVENT:\n\t\t\tS9xReschedule();\n\t\t\tbreak;\n\n\t\tcase HC_HDMA_START_EVENT:\n\t\t\tS9xReschedule();\n\n\t\t\tif (PPU.HDMA && CPU.V_Counter <= PPU.ScreenHeight)\n\t\t\t{\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tS9xTraceFormattedMessage(\"*** HDMA Transfer HC:%04d, Channel:%02x\", CPU.Cycles, PPU.HDMA);\n\t\t\t#endif\n\t\t\t\tPPU.HDMA = S9xDoHDMA(PPU.HDMA);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase HC_HCOUNTER_MAX_EVENT:\n\t\t\tif (Settings.SuperFX)\n\t\t\t{\n\t\t\t\tif (!SuperFX.oneLineDone)\n\t\t\t\t\tS9xSuperFXExec();\n\t\t\t\tSuperFX.oneLineDone = FALSE;\n\t\t\t}\n\n\t\t\tS9xAPUEndScanline();\n\t\t\tCPU.Cycles -= Timings.H_Max;\n\t\t\tif (Timings.NMITriggerPos != 0xffff)\n\t\t\t\tTimings.NMITriggerPos -= Timings.H_Max;\n\t\t\tif (Timings.NextIRQTimer != 0x0fffffff)\n\t\t\t\tTimings.NextIRQTimer -= Timings.H_Max;\n\t\t\tS9xAPUSetReferenceTime(CPU.Cycles);\n\n\t\t\tif (Settings.SA1)\n\t\t\t\tSA1.Cycles -= Timings.H_Max * 3;\n\n\t\t\tCPU.V_Counter++;\n\t\t\tif (CPU.V_Counter >= Timings.V_Max)\t// V ranges from 0 to Timings.V_Max - 1\n\t\t\t{\n\t\t\t\tCPU.V_Counter = 0;\n\n\t\t\t\t// From byuu:\n\t\t\t\t// [NTSC]\n\t\t\t\t// interlace mode has 525 scanlines: 263 on the even frame, and 262 on the odd.\n\t\t\t\t// non-interlace mode has 524 scanlines: 262 scanlines on both even and odd frames.\n\t\t\t\t// [PAL] <PAL info is unverified on hardware>\n\t\t\t\t// interlace mode has 625 scanlines: 313 on the even frame, and 312 on the odd.\n\t\t\t\t// non-interlace mode has 624 scanlines: 312 scanlines on both even and odd frames.\n\t\t\t\tif (IPPU.Interlace && S9xInterlaceField())\n\t\t\t\t\tTimings.V_Max = Timings.V_Max_Master + 1;\t// 263 (NTSC), 313?(PAL)\n\t\t\t\telse\n\t\t\t\t\tTimings.V_Max = Timings.V_Max_Master;\t\t// 262 (NTSC), 312?(PAL)\n\n\t\t\t\tMemory.FillRAM[0x213F] ^= 0x80;\n\t\t\t\tPPU.RangeTimeOver = 0;\n\n\t\t\t\t// FIXME: reading $4210 will wait 2 cycles, then perform reading, then wait 4 more cycles.\n\t\t\t\tMemory.FillRAM[0x4210] = Model->_5A22;\n\n\t\t\t\tICPU.Frame++;\n\t\t\t\tPPU.HVBeamCounterLatched = 0;\n\t\t\t}\n\n\t\t\t// From byuu:\n\t\t\t// In non-interlace mode, there are 341 dots per scanline, and 262 scanlines per frame.\n\t\t\t// On odd frames, scanline 240 is one dot short.\n\t\t\t// In interlace mode, there are always 341 dots per scanline. Even frames have 263 scanlines,\n\t\t\t// and odd frames have 262 scanlines.\n\t\t\t// Interlace mode scanline 240 on odd frames is not missing a dot.\n\t\t\tif (CPU.V_Counter == 240 && !IPPU.Interlace && S9xInterlaceField())\t// V=240\n\t\t\t\tTimings.H_Max = Timings.H_Max_Master - ONE_DOT_CYCLE;\t// HC=1360\n\t\t\telse\n\t\t\t\tTimings.H_Max = Timings.H_Max_Master;\t\t\t\t\t// HC=1364\n\n\t\t\tif (Model->_5A22 == 2)\n\t\t\t{\n\t\t\t\tif (CPU.V_Counter != 240 || IPPU.Interlace || !S9xInterlaceField())\t// V=240\n\t\t\t\t{\n\t\t\t\t\tif (Timings.WRAMRefreshPos == SNES_WRAM_REFRESH_HC_v2 - ONE_DOT_CYCLE)\t// HC=534\n\t\t\t\t\t\tTimings.WRAMRefreshPos = SNES_WRAM_REFRESH_HC_v2;\t\t\t\t\t// HC=538\n\t\t\t\t\telse\n\t\t\t\t\t\tTimings.WRAMRefreshPos = SNES_WRAM_REFRESH_HC_v2 - ONE_DOT_CYCLE;\t// HC=534\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tTimings.WRAMRefreshPos = SNES_WRAM_REFRESH_HC_v1;\n\n\t\t\tif (CPU.V_Counter == PPU.ScreenHeight + FIRST_VISIBLE_LINE)\t// VBlank starts from V=225(240).\n\t\t\t{\n\t\t\t\tS9xEndScreenRefresh();\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tif (!(CPU.Flags & FRAME_ADVANCE_FLAG))\n\t\t\t\t#endif\n\t\t\t\t{\n\t\t\t\t\tS9xSyncSpeed();\n\t\t\t\t}\n\n\t\t\t\tCPU.Flags |= SCAN_KEYS_FLAG;\n\n\t\t\t\tPPU.HDMA = 0;\n\t\t\t\t// Bits 7 and 6 of $4212 are computed when read in S9xGetPPU.\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.dma_this_frame = 0;\n\t\t\t#endif\n\t\t\t\tIPPU.MaxBrightness = PPU.Brightness;\n\t\t\t\tPPU.ForcedBlanking = (Memory.FillRAM[0x2100] >> 7) & 1;\n\n\t\t\t\tif (!PPU.ForcedBlanking)\n\t\t\t\t{\n\t\t\t\t\tPPU.OAMAddr = PPU.SavedOAMAddr;\n\n\t\t\t\t\tuint8\ttmp = 0;\n\n\t\t\t\t\tif (PPU.OAMPriorityRotation)\n\t\t\t\t\t\ttmp = (PPU.OAMAddr & 0xFE) >> 1;\n\t\t\t\t\tif ((PPU.OAMFlip & 1) || PPU.FirstSprite != tmp)\n\t\t\t\t\t{\n\t\t\t\t\t\tPPU.FirstSprite = tmp;\n\t\t\t\t\t\tIPPU.OBJChanged = TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tPPU.OAMFlip = 0;\n\t\t\t\t}\n\n\t\t\t\t// FIXME: writing to $4210 will wait 6 cycles.\n\t\t\t\tMemory.FillRAM[0x4210] = 0x80 | Model->_5A22;\n\t\t\t\tif (Memory.FillRAM[0x4200] & 0x80)\n\t\t\t\t{\n#ifdef DEBUGGER\n\t\t\t\t\tif (Settings.TraceHCEvent)\n\t\t\t\t\t    S9xTraceFormattedMessage (\"NMI Scheduled for next scanline.\");\n#endif\n\t\t\t\t\t// FIXME: triggered at HC=6, checked just before the final CPU cycle,\n\t\t\t\t\t// then, when to call S9xOpcode_NMI()?\n\t\t\t\t\tCPU.NMIPending = TRUE;\n\t\t\t\t\tTimings.NMITriggerPos = 6 + 6;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (CPU.V_Counter == PPU.ScreenHeight + 3)\t// FIXME: not true\n\t\t\t{\n\t\t\t\tif (Memory.FillRAM[0x4200] & 1)\n\t\t\t\t\tS9xDoAutoJoypad();\n\t\t\t}\n\n\t\t\tif (CPU.V_Counter == FIRST_VISIBLE_LINE)\t// V=1\n\t\t\t\tS9xStartScreenRefresh();\n\n\t\t\tS9xReschedule();\n\n\t\t\tbreak;\n\n\t\tcase HC_HDMA_INIT_EVENT:\n\t\t\tS9xReschedule();\n\n\t\t\tif (CPU.V_Counter == 0)\n\t\t\t{\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tS9xTraceFormattedMessage(\"*** HDMA Init     HC:%04d, Channel:%02x\", CPU.Cycles, PPU.HDMA);\n\t\t\t#endif\n\t\t\t\tS9xStartHDMA();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase HC_RENDER_EVENT:\n\t\t\tif (CPU.V_Counter >= FIRST_VISIBLE_LINE && CPU.V_Counter <= PPU.ScreenHeight)\n\t\t\t\tRenderLine((uint8) (CPU.V_Counter - FIRST_VISIBLE_LINE));\n\n\t\t\tS9xReschedule();\n\n\t\t\tbreak;\n\n\t\tcase HC_WRAM_REFRESH_EVENT:\n\t\t#ifdef DEBUGGER\n\t\t\tS9xTraceFormattedMessage(\"*** WRAM Refresh  HC:%04d\", CPU.Cycles);\n\t\t#endif\n\n\t\t\tCPU.Cycles += SNES_WRAM_REFRESH_CYCLES;\n\n\t\t\tS9xReschedule();\n\n\t\t\tbreak;\n\t}\n\n#ifdef DEBUGGER\n\tif (Settings.TraceHCEvent)\n\t\tS9xTraceFormattedMessage(\"--- HC event rescheduled (%s)  expected HC:%04d  current  HC:%04d\",\n\t\t\teventname[CPU.WhichEvent], CPU.NextEvent, CPU.Cycles);\n#endif\n}\n"
        },
        {
          "name": "cpuexec.h",
          "type": "blob",
          "size": 2.265625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _CPUEXEC_H_\n#define _CPUEXEC_H_\n\n#include \"ppu.h\"\n#ifdef DEBUGGER\n#include \"debug.h\"\n#endif\n\nstruct SOpcodes\n{\n\tvoid (*S9xOpcode) (void);\n};\n\nstruct SICPU\n{\n\tstruct SOpcodes\t*S9xOpcodes;\n\tuint8\t*S9xOpLengths;\n\tuint8\t_Carry;\n\tuint8\t_Zero;\n\tuint8\t_Negative;\n\tuint8\t_Overflow;\n\tuint32\tShiftedPB;\n\tuint32\tShiftedDB;\n\tuint32\tFrame;\n\tuint32\tFrameAdvanceCount;\n};\n\nextern struct SICPU\t\tICPU;\n\nextern struct SOpcodes\tS9xOpcodesE1[256];\nextern struct SOpcodes\tS9xOpcodesM1X1[256];\nextern struct SOpcodes\tS9xOpcodesM1X0[256];\nextern struct SOpcodes\tS9xOpcodesM0X1[256];\nextern struct SOpcodes\tS9xOpcodesM0X0[256];\nextern struct SOpcodes\tS9xOpcodesSlow[256];\nextern uint8\t\t\tS9xOpLengthsM1X1[256];\nextern uint8\t\t\tS9xOpLengthsM1X0[256];\nextern uint8\t\t\tS9xOpLengthsM0X1[256];\nextern uint8\t\t\tS9xOpLengthsM0X0[256];\n\nvoid S9xMainLoop (void);\nvoid S9xReset (void);\nvoid S9xSoftReset (void);\nvoid S9xDoHEventProcessing (void);\n\nstatic inline void S9xUnpackStatus (void)\n{\n\tICPU._Zero = (Registers.PL & Zero) == 0;\n\tICPU._Negative = (Registers.PL & Negative);\n\tICPU._Carry = (Registers.PL & Carry);\n\tICPU._Overflow = (Registers.PL & Overflow) >> 6;\n}\n\nstatic inline void S9xPackStatus (void)\n{\n\tRegisters.PL &= ~(Zero | Negative | Carry | Overflow);\n\tRegisters.PL |= ICPU._Carry | ((ICPU._Zero == 0) << 1) | (ICPU._Negative & 0x80) | (ICPU._Overflow << 6);\n}\n\nstatic inline void S9xFixCycles (void)\n{\n\tif (CheckEmulation())\n\t{\n\t\tICPU.S9xOpcodes = S9xOpcodesE1;\n\t\tICPU.S9xOpLengths = S9xOpLengthsM1X1;\n\t}\n\telse\n\tif (CheckMemory())\n\t{\n\t\tif (CheckIndex())\n\t\t{\n\t\t\tICPU.S9xOpcodes = S9xOpcodesM1X1;\n\t\t\tICPU.S9xOpLengths = S9xOpLengthsM1X1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tICPU.S9xOpcodes = S9xOpcodesM1X0;\n\t\t\tICPU.S9xOpLengths = S9xOpLengthsM1X0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (CheckIndex())\n\t\t{\n\t\t\tICPU.S9xOpcodes = S9xOpcodesM0X1;\n\t\t\tICPU.S9xOpLengths = S9xOpLengthsM0X1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tICPU.S9xOpcodes = S9xOpcodesM0X0;\n\t\t\tICPU.S9xOpLengths = S9xOpLengthsM0X0;\n\t\t}\n\t}\n}\n\n#endif\n"
        },
        {
          "name": "cpumacro.h",
          "type": "blob",
          "size": 13.8349609375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _CPUMACRO_H_\n#define _CPUMACRO_H_\n\n#define rOP8(OP, ADDR, WRAP, FUNC) \\\nstatic void Op##OP (void) \\\n{ \\\n\tuint8\tval = OpenBus = S9xGetByte(ADDR(READ)); \\\n\tFUNC(val); \\\n}\n\n#define rOP16(OP, ADDR, WRAP, FUNC) \\\nstatic void Op##OP (void) \\\n{ \\\n\tuint16\tval = S9xGetWord(ADDR(READ), WRAP); \\\n\tOpenBus = (uint8) (val >> 8); \\\n\tFUNC(val); \\\n}\n\n#define rOPC(OP, COND, ADDR, WRAP, FUNC) \\\nstatic void Op##OP (void) \\\n{ \\\n\tif (Check##COND()) \\\n\t{ \\\n\t\tuint8\tval = OpenBus = S9xGetByte(ADDR(READ)); \\\n\t\tFUNC(val); \\\n\t} \\\n\telse \\\n\t{ \\\n\t\tuint16\tval = S9xGetWord(ADDR(READ), WRAP); \\\n\t\tOpenBus = (uint8) (val >> 8); \\\n\t\tFUNC(val); \\\n\t} \\\n}\n\n#define rOPM(OP, ADDR, WRAP, FUNC) \\\nrOPC(OP, Memory, ADDR, WRAP, FUNC)\n\n#define rOPX(OP, ADDR, WRAP, FUNC) \\\nrOPC(OP, Index, ADDR, WRAP, FUNC)\n\n#define wOP8(OP, ADDR, WRAP, FUNC) \\\nstatic void Op##OP (void) \\\n{ \\\n\tFUNC##8(ADDR(WRITE)); \\\n}\n\n#define wOP16(OP, ADDR, WRAP, FUNC) \\\nstatic void Op##OP (void) \\\n{ \\\n\tFUNC##16(ADDR(WRITE), WRAP); \\\n}\n\n#define wOPC(OP, COND, ADDR, WRAP, FUNC) \\\nstatic void Op##OP (void) \\\n{ \\\n\tif (Check##COND()) \\\n\t\tFUNC##8(ADDR(WRITE)); \\\n\telse \\\n\t\tFUNC##16(ADDR(WRITE), WRAP); \\\n}\n\n#define wOPM(OP, ADDR, WRAP, FUNC) \\\nwOPC(OP, Memory, ADDR, WRAP, FUNC)\n\n#define wOPX(OP, ADDR, WRAP, FUNC) \\\nwOPC(OP, Index, ADDR, WRAP, FUNC)\n\n#define mOP8(OP, ADDR, WRAP, FUNC) \\\nstatic void Op##OP (void) \\\n{ \\\n\tFUNC##8(ADDR(MODIFY)); \\\n}\n\n#define mOP16(OP, ADDR, WRAP, FUNC) \\\nstatic void Op##OP (void) \\\n{ \\\n\tFUNC##16(ADDR(MODIFY), WRAP); \\\n}\n\n#define mOPC(OP, COND, ADDR, WRAP, FUNC) \\\nstatic void Op##OP (void) \\\n{ \\\n\tif (Check##COND()) \\\n\t\tFUNC##8(ADDR(MODIFY)); \\\n\telse \\\n\t\tFUNC##16(ADDR(MODIFY), WRAP); \\\n}\n\n#define mOPM(OP, ADDR, WRAP, FUNC) \\\nmOPC(OP, Memory, ADDR, WRAP, FUNC)\n\n#define bOP(OP, REL, COND, CHK, E) \\\nstatic void Op##OP (void) \\\n{ \\\n\tpair\tnewPC; \\\n\tnewPC.W = REL(JUMP); \\\n\tif (COND) \\\n\t{ \\\n\t\tAddCycles(ONE_CYCLE); \\\n\t\tif (E && Registers.PCh != newPC.B.h) \\\n\t\t\tAddCycles(ONE_CYCLE); \\\n\t\tif ((Registers.PCw & ~MEMMAP_MASK) != (newPC.W & ~MEMMAP_MASK)) \\\n\t\t\tS9xSetPCBase(ICPU.ShiftedPB + newPC.W); \\\n\t\telse \\\n\t\t\tRegisters.PCw = newPC.W; \\\n\t} \\\n}\n\n\nstatic inline void SetZN (uint16 Work16)\n{\n\tICPU._Zero = Work16 != 0;\n\tICPU._Negative = (uint8) (Work16 >> 8);\n}\n\nstatic inline void SetZN (uint8 Work8)\n{\n\tICPU._Zero = Work8;\n\tICPU._Negative = Work8;\n}\n\nstatic inline void ADC (uint16 Work16)\n{\n\tif (CheckDecimal())\n\t{\n\t\tuint32 result;\n\t\tuint32 carry = CheckCarry();\n\n\t\tresult = (Registers.A.W & 0x000F) + (Work16 & 0x000F) + carry;\n\t\tif (result > 0x0009)\n\t\t\tresult += 0x0006;\n\t\tcarry = (result > 0x000F);\n\n\t\tresult = (Registers.A.W & 0x00F0) + (Work16 & 0x00F0) + (result & 0x000F) + carry * 0x10;\n\t\tif (result > 0x009F)\n\t\t\tresult += 0x0060;\n\t\tcarry = (result > 0x00FF);\n\n\t\tresult = (Registers.A.W & 0x0F00) + (Work16 & 0x0F00) + (result & 0x00FF) + carry * 0x100;\n\t\tif (result > 0x09FF)\n\t\t\tresult += 0x0600;\n\t\tcarry = (result > 0x0FFF);\n\n\t\tresult = (Registers.A.W & 0xF000) + (Work16 & 0xF000) + (result & 0x0FFF) + carry * 0x1000;\n\n\t\tif ((Registers.A.W & 0x8000) == (Work16 & 0x8000) && (Registers.A.W & 0x8000) != (result & 0x8000))\n\t\t\tSetOverflow();\n\t\telse\n\t\t\tClearOverflow();\n\n\t\tif (result > 0x9FFF)\n\t\t\tresult += 0x6000;\n\n\t\tif (result > 0xFFFF)\n\t\t\tSetCarry();\n\t\telse\n\t\t\tClearCarry();\n\n\t\tRegisters.A.W = result & 0xFFFF;\n\t\tSetZN(Registers.A.W);\n\t}\n\telse\n\t{\n\t\tuint32\tAns32 = Registers.A.W + Work16 + CheckCarry();\n\n\t\tICPU._Carry = Ans32 >= 0x10000;\n\n\t\tif (~(Registers.A.W ^ Work16) & (Work16 ^ (uint16) Ans32) & 0x8000)\n\t\t\tSetOverflow();\n\t\telse\n\t\t\tClearOverflow();\n\n\t\tRegisters.A.W = (uint16) Ans32;\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nstatic inline void ADC (uint8 Work8)\n{\n\tif (CheckDecimal())\n\t{\n\t\tuint32 result;\n\t\tuint32 carry = CheckCarry();\n\n\t\tresult = (Registers.AL & 0x0F) + (Work8 & 0x0F) + carry;\n\t\tif ( result > 0x09 )\n\t\t\tresult += 0x06;\n\t\tcarry = (result > 0x0F);\n\n\t\tresult = (Registers.AL & 0xF0) + (Work8 & 0xF0) + (result & 0x0F) + (carry * 0x10);\n\n\t\tif ((Registers.AL & 0x80) == (Work8 & 0x80) && (Registers.AL & 0x80) != (result & 0x80))\n\t\t\tSetOverflow();\n\t\telse\n\t\t\tClearOverflow();\n\n\t\tif (result > 0x9F)\n\t\t\tresult += 0x60;\n\n\t\tif (result > 0xFF)\n\t\t\tSetCarry();\n\t\telse\n\t\t\tClearCarry();\n\n\t\tRegisters.AL = result & 0xFF;\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tuint16\tAns16 = Registers.AL + Work8 + CheckCarry();\n\n\t\tICPU._Carry = Ans16 >= 0x100;\n\n\t\tif (~(Registers.AL ^ Work8) & (Work8 ^ (uint8) Ans16) & 0x80)\n\t\t\tSetOverflow();\n\t\telse\n\t\t\tClearOverflow();\n\n\t\tRegisters.AL = (uint8) Ans16;\n\t\tSetZN(Registers.AL);\n\t}\n}\n\nstatic inline void AND (uint16 Work16)\n{\n\tRegisters.A.W &= Work16;\n\tSetZN(Registers.A.W);\n}\n\nstatic inline void AND (uint8 Work8)\n{\n\tRegisters.AL &= Work8;\n\tSetZN(Registers.AL);\n}\n\nstatic inline void ASL16 (uint32 OpAddress, s9xwrap_t w)\n{\n\tuint16\tWork16 = S9xGetWord(OpAddress, w);\n\tICPU._Carry = (Work16 & 0x8000) != 0;\n\tWork16 <<= 1;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetWord(Work16, OpAddress, w, WRITE_10);\n\tOpenBus = Work16 & 0xff;\n\tSetZN(Work16);\n}\n\nstatic inline void ASL8 (uint32 OpAddress)\n{\n\tuint8\tWork8 = S9xGetByte(OpAddress);\n\tICPU._Carry = (Work8 & 0x80) != 0;\n\tWork8 <<= 1;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetByte(Work8, OpAddress);\n\tOpenBus = Work8;\n\tSetZN(Work8);\n}\n\nstatic inline void BIT (uint16 Work16)\n{\n\tICPU._Overflow = (Work16 & 0x4000) != 0;\n\tICPU._Negative = (uint8) (Work16 >> 8);\n\tICPU._Zero = (Work16 & Registers.A.W) != 0;\n}\n\nstatic inline void BIT (uint8 Work8)\n{\n\tICPU._Overflow = (Work8 & 0x40) != 0;\n\tICPU._Negative = Work8;\n\tICPU._Zero = Work8 & Registers.AL;\n}\n\nstatic inline void CMP (uint16 val)\n{\n\tint32\tInt32 = (int32) Registers.A.W - (int32) val;\n\tICPU._Carry = Int32 >= 0;\n\tSetZN((uint16) Int32);\n}\n\nstatic inline void CMP (uint8 val)\n{\n\tint16\tInt16 = (int16) Registers.AL - (int16) val;\n\tICPU._Carry = Int16 >= 0;\n\tSetZN((uint8) Int16);\n}\n\nstatic inline void CPX (uint16 val)\n{\n\tint32\tInt32 = (int32) Registers.X.W - (int32) val;\n\tICPU._Carry = Int32 >= 0;\n\tSetZN((uint16) Int32);\n}\n\nstatic inline void CPX (uint8 val)\n{\n\tint16\tInt16 = (int16) Registers.XL - (int16) val;\n\tICPU._Carry = Int16 >= 0;\n\tSetZN((uint8) Int16);\n}\n\nstatic inline void CPY (uint16 val)\n{\n\tint32\tInt32 = (int32) Registers.Y.W - (int32) val;\n\tICPU._Carry = Int32 >= 0;\n\tSetZN((uint16) Int32);\n}\n\nstatic inline void CPY (uint8 val)\n{\n\tint16\tInt16 = (int16) Registers.YL - (int16) val;\n\tICPU._Carry = Int16 >= 0;\n\tSetZN((uint8) Int16);\n}\n\nstatic inline void DEC16 (uint32 OpAddress, s9xwrap_t w)\n{\n\tuint16\tWork16 = S9xGetWord(OpAddress, w) - 1;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetWord(Work16, OpAddress, w, WRITE_10);\n\tOpenBus = Work16 & 0xff;\n\tSetZN(Work16);\n}\n\nstatic inline void DEC8 (uint32 OpAddress)\n{\n\tuint8\tWork8 = S9xGetByte(OpAddress) - 1;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetByte(Work8, OpAddress);\n\tOpenBus = Work8;\n\tSetZN(Work8);\n}\n\nstatic inline void EOR (uint16 val)\n{\n\tRegisters.A.W ^= val;\n\tSetZN(Registers.A.W);\n}\n\nstatic inline void EOR (uint8 val)\n{\n\tRegisters.AL ^= val;\n\tSetZN(Registers.AL);\n}\n\nstatic inline void INC16 (uint32 OpAddress, s9xwrap_t w)\n{\n\tuint16\tWork16 = S9xGetWord(OpAddress, w) + 1;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetWord(Work16, OpAddress, w, WRITE_10);\n\tOpenBus = Work16 & 0xff;\n\tSetZN(Work16);\n}\n\nstatic inline void INC8 (uint32 OpAddress)\n{\n\tuint8\tWork8 = S9xGetByte(OpAddress) + 1;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetByte(Work8, OpAddress);\n\tOpenBus = Work8;\n\tSetZN(Work8);\n}\n\nstatic inline void LDA (uint16 val)\n{\n\tRegisters.A.W = val;\n\tSetZN(Registers.A.W);\n}\n\nstatic inline void LDA (uint8 val)\n{\n\tRegisters.AL = val;\n\tSetZN(Registers.AL);\n}\n\nstatic inline void LDX (uint16 val)\n{\n\tRegisters.X.W = val;\n\tSetZN(Registers.X.W);\n}\n\nstatic inline void LDX (uint8 val)\n{\n\tRegisters.XL = val;\n\tSetZN(Registers.XL);\n}\n\nstatic inline void LDY (uint16 val)\n{\n\tRegisters.Y.W = val;\n\tSetZN(Registers.Y.W);\n}\n\nstatic inline void LDY (uint8 val)\n{\n\tRegisters.YL = val;\n\tSetZN(Registers.YL);\n}\n\nstatic inline void LSR16 (uint32 OpAddress, s9xwrap_t w)\n{\n\tuint16\tWork16 = S9xGetWord(OpAddress, w);\n\tICPU._Carry = Work16 & 1;\n\tWork16 >>= 1;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetWord(Work16, OpAddress, w, WRITE_10);\n\tOpenBus = Work16 & 0xff;\n\tSetZN(Work16);\n}\n\nstatic inline void LSR8 (uint32 OpAddress)\n{\n\tuint8\tWork8 = S9xGetByte(OpAddress);\n\tICPU._Carry = Work8 & 1;\n\tWork8 >>= 1;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetByte(Work8, OpAddress);\n\tOpenBus = Work8;\n\tSetZN(Work8);\n}\n\nstatic inline void ORA (uint16 val)\n{\n\tRegisters.A.W |= val;\n\tSetZN(Registers.A.W);\n}\n\nstatic inline void ORA (uint8 val)\n{\n\tRegisters.AL |= val;\n\tSetZN(Registers.AL);\n}\n\nstatic inline void ROL16 (uint32 OpAddress, s9xwrap_t w)\n{\n\tuint32\tWork32 = (((uint32) S9xGetWord(OpAddress, w)) << 1) | CheckCarry();\n\tICPU._Carry = Work32 >= 0x10000;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetWord((uint16) Work32, OpAddress, w, WRITE_10);\n\tOpenBus = Work32 & 0xff;\n\tSetZN((uint16) Work32);\n}\n\nstatic inline void ROL8 (uint32 OpAddress)\n{\n\tuint16\tWork16 = (((uint16) S9xGetByte(OpAddress)) << 1) | CheckCarry();\n\tICPU._Carry = Work16 >= 0x100;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetByte((uint8) Work16, OpAddress);\n\tOpenBus = Work16 & 0xff;\n\tSetZN((uint8) Work16);\n}\n\nstatic inline void ROR16 (uint32 OpAddress, s9xwrap_t w)\n{\n\tuint32\tWork32 = ((uint32) S9xGetWord(OpAddress, w)) | (((uint32) CheckCarry()) << 16);\n\tICPU._Carry = Work32 & 1;\n\tWork32 >>= 1;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetWord((uint16) Work32, OpAddress, w, WRITE_10);\n\tOpenBus = Work32 & 0xff;\n\tSetZN((uint16) Work32);\n}\n\nstatic inline void ROR8 (uint32 OpAddress)\n{\n\tuint16\tWork16 = ((uint16) S9xGetByte(OpAddress)) | (((uint16) CheckCarry()) << 8);\n\tICPU._Carry = Work16 & 1;\n\tWork16 >>= 1;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetByte((uint8) Work16, OpAddress);\n\tOpenBus = Work16 & 0xff;\n\tSetZN((uint8) Work16);\n}\n\nstatic inline void SBC (uint16 Work16)\n{\n\tif (CheckDecimal())\n\t{\n\t\tint result;\n\t\tint carry = CheckCarry();\n\n\t\tWork16 ^= 0xFFFF;\n\n\t\tresult = (Registers.A.W & 0x000F) + (Work16 & 0x000F) + carry;\n\t\tif (result < 0x0010)\n\t\t\tresult -= 0x0006;\n\t\tcarry = (result > 0x000F);\n\n\t\tresult = (Registers.A.W & 0x00F0) + (Work16 & 0x00F0) + (result & 0x000F) + carry * 0x10;\n\t\tif (result < 0x0100)\n\t\t\tresult -= 0x0060;\n\t\tcarry = (result > 0x00FF);\n\n\t\tresult = (Registers.A.W & 0x0F00) + (Work16 & 0x0F00) + (result & 0x00FF) + carry * 0x100;\n\t\tif (result < 0x1000)\n\t\t\tresult -= 0x0600;\n\t\tcarry = (result > 0x0FFF);\n\n\t\tresult = (Registers.A.W & 0xF000) + (Work16 & 0xF000) + (result & 0x0FFF) + carry * 0x1000;\n\n\t\tif (((Registers.A.W ^ Work16) & 0x8000) == 0 && ((Registers.A.W ^ result) & 0x8000))\n\t\t\tSetOverflow();\n\t\telse\n\t\t\tClearOverflow();\n\n\t\tif (result < 0x10000)\n\t\t\tresult -= 0x6000;\n\n\t\tif (result > 0xFFFF)\n\t\t\tSetCarry();\n\t\telse\n\t\t\tClearCarry();\n\n\t\tRegisters.A.W = result & 0xFFFF;\n\t\tSetZN(Registers.A.W);\n\t}\n\telse\n\t{\n\t\tint32\tInt32 = (int32) Registers.A.W - (int32) Work16 + (int32) CheckCarry() - 1;\n\n\t\tICPU._Carry = Int32 >= 0;\n\n\t\tif ((Registers.A.W ^ Work16) & (Registers.A.W ^ (uint16) Int32) & 0x8000)\n\t\t\tSetOverflow();\n\t\telse\n\t\t\tClearOverflow();\n\n\t\tRegisters.A.W = (uint16) Int32;\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nstatic inline void SBC (uint8 Work8)\n{\n\tif (CheckDecimal())\n\t{\n\t\tint result;\n\t\tint carry = CheckCarry();\n\n\t\tWork8 ^= 0xFF;\n\n\t\tresult = (Registers.AL & 0x0F) + (Work8 & 0x0F) + carry;\n\t\tif (result < 0x10)\n\t\t\tresult -= 0x06;\n\t\tcarry = (result > 0x0F);\n\n\t\tresult = (Registers.AL & 0xF0) + (Work8 & 0xF0) + (result & 0x0F) + carry * 0x10;\n\n\t\tif ((Registers.AL & 0x80) == (Work8 & 0x80) && (Registers.AL & 0x80) != (result & 0x80))\n\t\t\tSetOverflow();\n\t\telse\n\t\t\tClearOverflow();\n\n\t\tif (result < 0x100 )\n\t\t\tresult -= 0x60;\n\n\t\tif (result > 0xFF)\n\t\t\tSetCarry();\n\t\telse\n\t\t\tClearCarry();\n\n\t\tRegisters.AL = result & 0xFF;\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tint16\tInt16 = (int16) Registers.AL - (int16) Work8 + (int16) CheckCarry() - 1;\n\n\t\tICPU._Carry = Int16 >= 0;\n\n\t\tif ((Registers.AL ^ Work8) & (Registers.AL ^ (uint8) Int16) & 0x80)\n\t\t\tSetOverflow();\n\t\telse\n\t\t\tClearOverflow();\n\n\t\tRegisters.AL = (uint8) Int16;\n\t\tSetZN(Registers.AL);\n\t}\n}\n\nstatic inline void STA16 (uint32 OpAddress, enum s9xwrap_t w)\n{\n\tS9xSetWord(Registers.A.W, OpAddress, w);\n\tOpenBus = Registers.AH;\n}\n\nstatic inline void STA8 (uint32 OpAddress)\n{\n\tS9xSetByte(Registers.AL, OpAddress);\n\tOpenBus = Registers.AL;\n}\n\nstatic inline void STX16 (uint32 OpAddress, enum s9xwrap_t w)\n{\n\tS9xSetWord(Registers.X.W, OpAddress, w);\n\tOpenBus = Registers.XH;\n}\n\nstatic inline void STX8 (uint32 OpAddress)\n{\n\tS9xSetByte(Registers.XL, OpAddress);\n\tOpenBus = Registers.XL;\n}\n\nstatic inline void STY16 (uint32 OpAddress, enum s9xwrap_t w)\n{\n\tS9xSetWord(Registers.Y.W, OpAddress, w);\n\tOpenBus = Registers.YH;\n}\n\nstatic inline void STY8 (uint32 OpAddress)\n{\n\tS9xSetByte(Registers.YL, OpAddress);\n\tOpenBus = Registers.YL;\n}\n\nstatic inline void STZ16 (uint32 OpAddress, enum s9xwrap_t w)\n{\n\tS9xSetWord(0, OpAddress, w);\n\tOpenBus = 0;\n}\n\nstatic inline void STZ8 (uint32 OpAddress)\n{\n\tS9xSetByte(0, OpAddress);\n\tOpenBus = 0;\n}\n\nstatic inline void TSB16 (uint32 OpAddress, enum s9xwrap_t w)\n{\n\tuint16\tWork16 = S9xGetWord(OpAddress, w);\n\tICPU._Zero = (Work16 & Registers.A.W) != 0;\n\tWork16 |= Registers.A.W;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetWord(Work16, OpAddress, w, WRITE_10);\n\tOpenBus = Work16 & 0xff;\n}\n\nstatic inline void TSB8 (uint32 OpAddress)\n{\n\tuint8\tWork8 = S9xGetByte(OpAddress);\n\tICPU._Zero = Work8 & Registers.AL;\n\tWork8 |= Registers.AL;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetByte(Work8, OpAddress);\n\tOpenBus = Work8;\n}\n\nstatic inline void TRB16 (uint32 OpAddress, enum s9xwrap_t w)\n{\n\tuint16\tWork16 = S9xGetWord(OpAddress, w);\n\tICPU._Zero = (Work16 & Registers.A.W) != 0;\n\tWork16 &= ~Registers.A.W;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetWord(Work16, OpAddress, w, WRITE_10);\n\tOpenBus = Work16 & 0xff;\n}\n\nstatic inline void TRB8 (uint32 OpAddress)\n{\n\tuint8\tWork8 = S9xGetByte(OpAddress);\n\tICPU._Zero = Work8 & Registers.AL;\n\tWork8 &= ~Registers.AL;\n\tAddCycles(ONE_CYCLE);\n\tS9xSetByte(Work8, OpAddress);\n\tOpenBus = Work8;\n}\n\n#endif\n"
        },
        {
          "name": "cpuops.cpp",
          "type": "blob",
          "size": 108.59375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"apu/apu.h\"\n\n// for \"Magic WDM\" features\n#ifdef DEBUGGER\t\n#include \"snapshot.h\"\n#include \"display.h\"\n#include \"debug.h\"\n#include \"missing.h\"\n#endif\n\n#ifdef SA1_OPCODES\n#define AddCycles(n)\t{ SA1.Cycles += (n); }\n#else\n#define AddCycles(n)\t{ CPU.Cycles += (n); while (CPU.Cycles >= CPU.NextEvent) S9xDoHEventProcessing(); }\n#endif\n\n#include \"cpuaddr.h\"\n#include \"cpuops.h\"\n#include \"cpumacro.h\"\n\n\n/* ADC ********************************************************************* */\n\nstatic void Op69M1 (void)\n{\n\tADC(Immediate8(READ));\n}\n\nstatic void Op69M0 (void)\n{\n\tADC(Immediate16(READ));\n}\n\nstatic void Op69Slow (void)\n{\n\tif (CheckMemory())\n\t\tADC(Immediate8Slow(READ));\n\telse\n\t\tADC(Immediate16Slow(READ));\n}\n\nrOP8 (65M1,     Direct,                           WRAP_BANK, ADC)\nrOP16(65M0,     Direct,                           WRAP_BANK, ADC)\nrOPM (65Slow,   DirectSlow,                       WRAP_BANK, ADC)\n\nrOP8 (75E1,     DirectIndexedXE1,                 WRAP_BANK, ADC)\nrOP8 (75E0M1,   DirectIndexedXE0,                 WRAP_BANK, ADC)\nrOP16(75E0M0,   DirectIndexedXE0,                 WRAP_BANK, ADC)\nrOPM (75Slow,   DirectIndexedXSlow,               WRAP_BANK, ADC)\n\nrOP8 (72E1,     DirectIndirectE1,                 WRAP_NONE, ADC)\nrOP8 (72E0M1,   DirectIndirectE0,                 WRAP_NONE, ADC)\nrOP16(72E0M0,   DirectIndirectE0,                 WRAP_NONE, ADC)\nrOPM (72Slow,   DirectIndirectSlow,               WRAP_NONE, ADC)\n\nrOP8 (61E1,     DirectIndexedIndirectE1,          WRAP_NONE, ADC)\nrOP8 (61E0M1,   DirectIndexedIndirectE0,          WRAP_NONE, ADC)\nrOP16(61E0M0,   DirectIndexedIndirectE0,          WRAP_NONE, ADC)\nrOPM (61Slow,   DirectIndexedIndirectSlow,        WRAP_NONE, ADC)\n\nrOP8 (71E1,     DirectIndirectIndexedE1,          WRAP_NONE, ADC)\nrOP8 (71E0M1X1, DirectIndirectIndexedE0X1,        WRAP_NONE, ADC)\nrOP16(71E0M0X1, DirectIndirectIndexedE0X1,        WRAP_NONE, ADC)\nrOP8 (71E0M1X0, DirectIndirectIndexedE0X0,        WRAP_NONE, ADC)\nrOP16(71E0M0X0, DirectIndirectIndexedE0X0,        WRAP_NONE, ADC)\nrOPM (71Slow,   DirectIndirectIndexedSlow,        WRAP_NONE, ADC)\n\nrOP8 (67M1,     DirectIndirectLong,               WRAP_NONE, ADC)\nrOP16(67M0,     DirectIndirectLong,               WRAP_NONE, ADC)\nrOPM (67Slow,   DirectIndirectLongSlow,           WRAP_NONE, ADC)\n\nrOP8 (77M1,     DirectIndirectIndexedLong,        WRAP_NONE, ADC)\nrOP16(77M0,     DirectIndirectIndexedLong,        WRAP_NONE, ADC)\nrOPM (77Slow,   DirectIndirectIndexedLongSlow,    WRAP_NONE, ADC)\n\nrOP8 (6DM1,     Absolute,                         WRAP_NONE, ADC)\nrOP16(6DM0,     Absolute,                         WRAP_NONE, ADC)\nrOPM (6DSlow,   AbsoluteSlow,                     WRAP_NONE, ADC)\n\nrOP8 (7DM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, ADC)\nrOP16(7DM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, ADC)\nrOP8 (7DM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, ADC)\nrOP16(7DM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, ADC)\nrOPM (7DSlow,   AbsoluteIndexedXSlow,             WRAP_NONE, ADC)\n\nrOP8 (79M1X1,   AbsoluteIndexedYX1,               WRAP_NONE, ADC)\nrOP16(79M0X1,   AbsoluteIndexedYX1,               WRAP_NONE, ADC)\nrOP8 (79M1X0,   AbsoluteIndexedYX0,               WRAP_NONE, ADC)\nrOP16(79M0X0,   AbsoluteIndexedYX0,               WRAP_NONE, ADC)\nrOPM (79Slow,   AbsoluteIndexedYSlow,             WRAP_NONE, ADC)\n\nrOP8 (6FM1,     AbsoluteLong,                     WRAP_NONE, ADC)\nrOP16(6FM0,     AbsoluteLong,                     WRAP_NONE, ADC)\nrOPM (6FSlow,   AbsoluteLongSlow,                 WRAP_NONE, ADC)\n\nrOP8 (7FM1,     AbsoluteLongIndexedX,             WRAP_NONE, ADC)\nrOP16(7FM0,     AbsoluteLongIndexedX,             WRAP_NONE, ADC)\nrOPM (7FSlow,   AbsoluteLongIndexedXSlow,         WRAP_NONE, ADC)\n\nrOP8 (63M1,     StackRelative,                    WRAP_NONE, ADC)\nrOP16(63M0,     StackRelative,                    WRAP_NONE, ADC)\nrOPM (63Slow,   StackRelativeSlow,                WRAP_NONE, ADC)\n\nrOP8 (73M1,     StackRelativeIndirectIndexed,     WRAP_NONE, ADC)\nrOP16(73M0,     StackRelativeIndirectIndexed,     WRAP_NONE, ADC)\nrOPM (73Slow,   StackRelativeIndirectIndexedSlow, WRAP_NONE, ADC)\n\n/* AND ********************************************************************* */\n\nstatic void Op29M1 (void)\n{\n\tRegisters.AL &= Immediate8(READ);\n\tSetZN(Registers.AL);\n}\n\nstatic void Op29M0 (void)\n{\n\tRegisters.A.W &= Immediate16(READ);\n\tSetZN(Registers.A.W);\n}\n\nstatic void Op29Slow (void)\n{\n\tif (CheckMemory())\n\t{\n\t\tRegisters.AL &= Immediate8Slow(READ);\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tRegisters.A.W &= Immediate16Slow(READ);\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nrOP8 (25M1,     Direct,                           WRAP_BANK, AND)\nrOP16(25M0,     Direct,                           WRAP_BANK, AND)\nrOPM (25Slow,   DirectSlow,                       WRAP_BANK, AND)\n\nrOP8 (35E1,     DirectIndexedXE1,                 WRAP_BANK, AND)\nrOP8 (35E0M1,   DirectIndexedXE0,                 WRAP_BANK, AND)\nrOP16(35E0M0,   DirectIndexedXE0,                 WRAP_BANK, AND)\nrOPM (35Slow,   DirectIndexedXSlow,               WRAP_BANK, AND)\n\nrOP8 (32E1,     DirectIndirectE1,                 WRAP_NONE, AND)\nrOP8 (32E0M1,   DirectIndirectE0,                 WRAP_NONE, AND)\nrOP16(32E0M0,   DirectIndirectE0,                 WRAP_NONE, AND)\nrOPM (32Slow,   DirectIndirectSlow,               WRAP_NONE, AND)\n\nrOP8 (21E1,     DirectIndexedIndirectE1,          WRAP_NONE, AND)\nrOP8 (21E0M1,   DirectIndexedIndirectE0,          WRAP_NONE, AND)\nrOP16(21E0M0,   DirectIndexedIndirectE0,          WRAP_NONE, AND)\nrOPM (21Slow,   DirectIndexedIndirectSlow,        WRAP_NONE, AND)\n\nrOP8 (31E1,     DirectIndirectIndexedE1,          WRAP_NONE, AND)\nrOP8 (31E0M1X1, DirectIndirectIndexedE0X1,        WRAP_NONE, AND)\nrOP16(31E0M0X1, DirectIndirectIndexedE0X1,        WRAP_NONE, AND)\nrOP8 (31E0M1X0, DirectIndirectIndexedE0X0,        WRAP_NONE, AND)\nrOP16(31E0M0X0, DirectIndirectIndexedE0X0,        WRAP_NONE, AND)\nrOPM (31Slow,   DirectIndirectIndexedSlow,        WRAP_NONE, AND)\n\nrOP8 (27M1,     DirectIndirectLong,               WRAP_NONE, AND)\nrOP16(27M0,     DirectIndirectLong,               WRAP_NONE, AND)\nrOPM (27Slow,   DirectIndirectLongSlow,           WRAP_NONE, AND)\n\nrOP8 (37M1,     DirectIndirectIndexedLong,        WRAP_NONE, AND)\nrOP16(37M0,     DirectIndirectIndexedLong,        WRAP_NONE, AND)\nrOPM (37Slow,   DirectIndirectIndexedLongSlow,    WRAP_NONE, AND)\n\nrOP8 (2DM1,     Absolute,                         WRAP_NONE, AND)\nrOP16(2DM0,     Absolute,                         WRAP_NONE, AND)\nrOPM (2DSlow,   AbsoluteSlow,                     WRAP_NONE, AND)\n\nrOP8 (3DM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, AND)\nrOP16(3DM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, AND)\nrOP8 (3DM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, AND)\nrOP16(3DM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, AND)\nrOPM (3DSlow,   AbsoluteIndexedXSlow,             WRAP_NONE, AND)\n\nrOP8 (39M1X1,   AbsoluteIndexedYX1,               WRAP_NONE, AND)\nrOP16(39M0X1,   AbsoluteIndexedYX1,               WRAP_NONE, AND)\nrOP8 (39M1X0,   AbsoluteIndexedYX0,               WRAP_NONE, AND)\nrOP16(39M0X0,   AbsoluteIndexedYX0,               WRAP_NONE, AND)\nrOPM (39Slow,   AbsoluteIndexedYSlow,             WRAP_NONE, AND)\n\nrOP8 (2FM1,     AbsoluteLong,                     WRAP_NONE, AND)\nrOP16(2FM0,     AbsoluteLong,                     WRAP_NONE, AND)\nrOPM (2FSlow,   AbsoluteLongSlow,                 WRAP_NONE, AND)\n\nrOP8 (3FM1,     AbsoluteLongIndexedX,             WRAP_NONE, AND)\nrOP16(3FM0,     AbsoluteLongIndexedX,             WRAP_NONE, AND)\nrOPM (3FSlow,   AbsoluteLongIndexedXSlow,         WRAP_NONE, AND)\n\nrOP8 (23M1,     StackRelative,                    WRAP_NONE, AND)\nrOP16(23M0,     StackRelative,                    WRAP_NONE, AND)\nrOPM (23Slow,   StackRelativeSlow,                WRAP_NONE, AND)\n\nrOP8 (33M1,     StackRelativeIndirectIndexed,     WRAP_NONE, AND)\nrOP16(33M0,     StackRelativeIndirectIndexed,     WRAP_NONE, AND)\nrOPM (33Slow,   StackRelativeIndirectIndexedSlow, WRAP_NONE, AND)\n\n/* ASL ********************************************************************* */\n\nstatic void Op0AM1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tICPU._Carry = (Registers.AL & 0x80) != 0;\n\tRegisters.AL <<= 1;\n\tSetZN(Registers.AL);\n}\n\nstatic void Op0AM0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tICPU._Carry = (Registers.AH & 0x80) != 0;\n\tRegisters.A.W <<= 1;\n\tSetZN(Registers.A.W);\n}\n\nstatic void Op0ASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckMemory())\n\t{\n\t\tICPU._Carry = (Registers.AL & 0x80) != 0;\n\t\tRegisters.AL <<= 1;\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tICPU._Carry = (Registers.AH & 0x80) != 0;\n\t\tRegisters.A.W <<= 1;\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nmOP8 (06M1,     Direct,                           WRAP_BANK, ASL)\nmOP16(06M0,     Direct,                           WRAP_BANK, ASL)\nmOPM (06Slow,   DirectSlow,                       WRAP_BANK, ASL)\n\nmOP8 (16E1,     DirectIndexedXE1,                 WRAP_BANK, ASL)\nmOP8 (16E0M1,   DirectIndexedXE0,                 WRAP_BANK, ASL)\nmOP16(16E0M0,   DirectIndexedXE0,                 WRAP_BANK, ASL)\nmOPM (16Slow,   DirectIndexedXSlow,               WRAP_BANK, ASL)\n\nmOP8 (0EM1,     Absolute,                         WRAP_NONE, ASL)\nmOP16(0EM0,     Absolute,                         WRAP_NONE, ASL)\nmOPM (0ESlow,   AbsoluteSlow,                     WRAP_NONE, ASL)\n\nmOP8 (1EM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, ASL)\nmOP16(1EM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, ASL)\nmOP8 (1EM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, ASL)\nmOP16(1EM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, ASL)\nmOPM (1ESlow,   AbsoluteIndexedXSlow,             WRAP_NONE, ASL)\n\n/* BIT ********************************************************************* */\n\nstatic void Op89M1 (void)\n{\n\tICPU._Zero = Registers.AL & Immediate8(READ);\n}\n\nstatic void Op89M0 (void)\n{\n\tICPU._Zero = (Registers.A.W & Immediate16(READ)) != 0;\n}\n\nstatic void Op89Slow (void)\n{\n\tif (CheckMemory())\n\t\tICPU._Zero = Registers.AL & Immediate8Slow(READ);\n\telse\n\t\tICPU._Zero = (Registers.A.W & Immediate16Slow(READ)) != 0;\n}\n\nrOP8 (24M1,     Direct,                           WRAP_BANK, BIT)\nrOP16(24M0,     Direct,                           WRAP_BANK, BIT)\nrOPM (24Slow,   DirectSlow,                       WRAP_BANK, BIT)\n\nrOP8 (34E1,     DirectIndexedXE1,                 WRAP_BANK, BIT)\nrOP8 (34E0M1,   DirectIndexedXE0,                 WRAP_BANK, BIT)\nrOP16(34E0M0,   DirectIndexedXE0,                 WRAP_BANK, BIT)\nrOPM (34Slow,   DirectIndexedXSlow,               WRAP_BANK, BIT)\n\nrOP8 (2CM1,     Absolute,                         WRAP_NONE, BIT)\nrOP16(2CM0,     Absolute,                         WRAP_NONE, BIT)\nrOPM (2CSlow,   AbsoluteSlow,                     WRAP_NONE, BIT)\n\nrOP8 (3CM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, BIT)\nrOP16(3CM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, BIT)\nrOP8 (3CM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, BIT)\nrOP16(3CM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, BIT)\nrOPM (3CSlow,   AbsoluteIndexedXSlow,             WRAP_NONE, BIT)\n\n/* CMP ********************************************************************* */\n\nstatic void OpC9M1 (void)\n{\n\tint16\tInt16 = (int16) Registers.AL - (int16) Immediate8(READ);\n\tICPU._Carry = Int16 >= 0;\n\tSetZN((uint8) Int16);\n}\n\nstatic void OpC9M0 (void)\n{\n\tint32\tInt32 = (int32) Registers.A.W - (int32) Immediate16(READ);\n\tICPU._Carry = Int32 >= 0;\n\tSetZN((uint16) Int32);\n}\n\nstatic void OpC9Slow (void)\n{\n\tif (CheckMemory())\n\t{\n\t\tint16\tInt16 = (int16) Registers.AL - (int16) Immediate8Slow(READ);\n\t\tICPU._Carry = Int16 >= 0;\n\t\tSetZN((uint8) Int16);\n\t}\n\telse\n\t{\n\t\tint32\tInt32 = (int32) Registers.A.W - (int32) Immediate16Slow(READ);\n\t\tICPU._Carry = Int32 >= 0;\n\t\tSetZN((uint16) Int32);\n\t}\n}\n\nrOP8 (C5M1,     Direct,                           WRAP_BANK, CMP)\nrOP16(C5M0,     Direct,                           WRAP_BANK, CMP)\nrOPM (C5Slow,   DirectSlow,                       WRAP_BANK, CMP)\n\nrOP8 (D5E1,     DirectIndexedXE1,                 WRAP_BANK, CMP)\nrOP8 (D5E0M1,   DirectIndexedXE0,                 WRAP_BANK, CMP)\nrOP16(D5E0M0,   DirectIndexedXE0,                 WRAP_BANK, CMP)\nrOPM (D5Slow,   DirectIndexedXSlow,               WRAP_BANK, CMP)\n\nrOP8 (D2E1,     DirectIndirectE1,                 WRAP_NONE, CMP)\nrOP8 (D2E0M1,   DirectIndirectE0,                 WRAP_NONE, CMP)\nrOP16(D2E0M0,   DirectIndirectE0,                 WRAP_NONE, CMP)\nrOPM (D2Slow,   DirectIndirectSlow,               WRAP_NONE, CMP)\n\nrOP8 (C1E1,     DirectIndexedIndirectE1,          WRAP_NONE, CMP)\nrOP8 (C1E0M1,   DirectIndexedIndirectE0,          WRAP_NONE, CMP)\nrOP16(C1E0M0,   DirectIndexedIndirectE0,          WRAP_NONE, CMP)\nrOPM (C1Slow,   DirectIndexedIndirectSlow,        WRAP_NONE, CMP)\n\nrOP8 (D1E1,     DirectIndirectIndexedE1,          WRAP_NONE, CMP)\nrOP8 (D1E0M1X1, DirectIndirectIndexedE0X1,        WRAP_NONE, CMP)\nrOP16(D1E0M0X1, DirectIndirectIndexedE0X1,        WRAP_NONE, CMP)\nrOP8 (D1E0M1X0, DirectIndirectIndexedE0X0,        WRAP_NONE, CMP)\nrOP16(D1E0M0X0, DirectIndirectIndexedE0X0,        WRAP_NONE, CMP)\nrOPM (D1Slow,   DirectIndirectIndexedSlow,        WRAP_NONE, CMP)\n\nrOP8 (C7M1,     DirectIndirectLong,               WRAP_NONE, CMP)\nrOP16(C7M0,     DirectIndirectLong,               WRAP_NONE, CMP)\nrOPM (C7Slow,   DirectIndirectLongSlow,           WRAP_NONE, CMP)\n\nrOP8 (D7M1,     DirectIndirectIndexedLong,        WRAP_NONE, CMP)\nrOP16(D7M0,     DirectIndirectIndexedLong,        WRAP_NONE, CMP)\nrOPM (D7Slow,   DirectIndirectIndexedLongSlow,    WRAP_NONE, CMP)\n\nrOP8 (CDM1,     Absolute,                         WRAP_NONE, CMP)\nrOP16(CDM0,     Absolute,                         WRAP_NONE, CMP)\nrOPM (CDSlow,   AbsoluteSlow,                     WRAP_NONE, CMP)\n\nrOP8 (DDM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, CMP)\nrOP16(DDM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, CMP)\nrOP8 (DDM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, CMP)\nrOP16(DDM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, CMP)\nrOPM (DDSlow,   AbsoluteIndexedXSlow,             WRAP_NONE, CMP)\n\nrOP8 (D9M1X1,   AbsoluteIndexedYX1,               WRAP_NONE, CMP)\nrOP16(D9M0X1,   AbsoluteIndexedYX1,               WRAP_NONE, CMP)\nrOP8 (D9M1X0,   AbsoluteIndexedYX0,               WRAP_NONE, CMP)\nrOP16(D9M0X0,   AbsoluteIndexedYX0,               WRAP_NONE, CMP)\nrOPM (D9Slow,   AbsoluteIndexedYSlow,             WRAP_NONE, CMP)\n\nrOP8 (CFM1,     AbsoluteLong,                     WRAP_NONE, CMP)\nrOP16(CFM0,     AbsoluteLong,                     WRAP_NONE, CMP)\nrOPM (CFSlow,   AbsoluteLongSlow,                 WRAP_NONE, CMP)\n\nrOP8 (DFM1,     AbsoluteLongIndexedX,             WRAP_NONE, CMP)\nrOP16(DFM0,     AbsoluteLongIndexedX,             WRAP_NONE, CMP)\nrOPM (DFSlow,   AbsoluteLongIndexedXSlow,         WRAP_NONE, CMP)\n\nrOP8 (C3M1,     StackRelative,                    WRAP_NONE, CMP)\nrOP16(C3M0,     StackRelative,                    WRAP_NONE, CMP)\nrOPM (C3Slow,   StackRelativeSlow,                WRAP_NONE, CMP)\n\nrOP8 (D3M1,     StackRelativeIndirectIndexed,     WRAP_NONE, CMP)\nrOP16(D3M0,     StackRelativeIndirectIndexed,     WRAP_NONE, CMP)\nrOPM (D3Slow,   StackRelativeIndirectIndexedSlow, WRAP_NONE, CMP)\n\n/* CPX ********************************************************************* */\n\nstatic void OpE0X1 (void)\n{\n\tint16\tInt16 = (int16) Registers.XL - (int16) Immediate8(READ);\n\tICPU._Carry = Int16 >= 0;\n\tSetZN((uint8) Int16);\n}\n\nstatic void OpE0X0 (void)\n{\n\tint32\tInt32 = (int32) Registers.X.W - (int32) Immediate16(READ);\n\tICPU._Carry = Int32 >= 0;\n\tSetZN((uint16) Int32);\n}\n\nstatic void OpE0Slow (void)\n{\n\tif (CheckIndex())\n\t{\n\t\tint16\tInt16 = (int16) Registers.XL - (int16) Immediate8Slow(READ);\n\t\tICPU._Carry = Int16 >= 0;\n\t\tSetZN((uint8) Int16);\n\t}\n\telse\n\t{\n\t\tint32\tInt32 = (int32) Registers.X.W - (int32) Immediate16Slow(READ);\n\t\tICPU._Carry = Int32 >= 0;\n\t\tSetZN((uint16) Int32);\n\t}\n}\n\nrOP8 (E4X1,     Direct,                           WRAP_BANK, CPX)\nrOP16(E4X0,     Direct,                           WRAP_BANK, CPX)\nrOPX (E4Slow,   DirectSlow,                       WRAP_BANK, CPX)\n\nrOP8 (ECX1,     Absolute,                         WRAP_NONE, CPX)\nrOP16(ECX0,     Absolute,                         WRAP_NONE, CPX)\nrOPX (ECSlow,   AbsoluteSlow,                     WRAP_NONE, CPX)\n\n/* CPY ********************************************************************* */\n\nstatic void OpC0X1 (void)\n{\n\tint16\tInt16 = (int16) Registers.YL - (int16) Immediate8(READ);\n\tICPU._Carry = Int16 >= 0;\n\tSetZN((uint8) Int16);\n}\n\nstatic void OpC0X0 (void)\n{\n\tint32\tInt32 = (int32) Registers.Y.W - (int32) Immediate16(READ);\n\tICPU._Carry = Int32 >= 0;\n\tSetZN((uint16) Int32);\n}\n\nstatic void OpC0Slow (void)\n{\n\tif (CheckIndex())\n\t{\n\t\tint16\tInt16 = (int16) Registers.YL - (int16) Immediate8Slow(READ);\n\t\tICPU._Carry = Int16 >= 0;\n\t\tSetZN((uint8) Int16);\n\t}\n\telse\n\t{\n\t\tint32\tInt32 = (int32) Registers.Y.W - (int32) Immediate16Slow(READ);\n\t\tICPU._Carry = Int32 >= 0;\n\t\tSetZN((uint16) Int32);\n\t}\n}\n\nrOP8 (C4X1,     Direct,                           WRAP_BANK, CPY)\nrOP16(C4X0,     Direct,                           WRAP_BANK, CPY)\nrOPX (C4Slow,   DirectSlow,                       WRAP_BANK, CPY)\n\nrOP8 (CCX1,     Absolute,                         WRAP_NONE, CPY)\nrOP16(CCX0,     Absolute,                         WRAP_NONE, CPY)\nrOPX (CCSlow,   AbsoluteSlow,                     WRAP_NONE, CPY)\n\n/* DEC ********************************************************************* */\n\nstatic void Op3AM1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.AL--;\n\tSetZN(Registers.AL);\n}\n\nstatic void Op3AM0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.A.W--;\n\tSetZN(Registers.A.W);\n}\n\nstatic void Op3ASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckMemory())\n\t{\n\t\tRegisters.AL--;\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tRegisters.A.W--;\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nmOP8 (C6M1,     Direct,                           WRAP_BANK, DEC)\nmOP16(C6M0,     Direct,                           WRAP_BANK, DEC)\nmOPM (C6Slow,   DirectSlow,                       WRAP_BANK, DEC)\n\nmOP8 (D6E1,     DirectIndexedXE1,                 WRAP_BANK, DEC)\nmOP8 (D6E0M1,   DirectIndexedXE0,                 WRAP_BANK, DEC)\nmOP16(D6E0M0,   DirectIndexedXE0,                 WRAP_BANK, DEC)\nmOPM (D6Slow,   DirectIndexedXSlow,               WRAP_BANK, DEC)\n\nmOP8 (CEM1,     Absolute,                         WRAP_NONE, DEC)\nmOP16(CEM0,     Absolute,                         WRAP_NONE, DEC)\nmOPM (CESlow,   AbsoluteSlow,                     WRAP_NONE, DEC)\n\nmOP8 (DEM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, DEC)\nmOP16(DEM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, DEC)\nmOP8 (DEM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, DEC)\nmOP16(DEM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, DEC)\nmOPM (DESlow,   AbsoluteIndexedXSlow,             WRAP_NONE, DEC)\n\n/* EOR ********************************************************************* */\n\nstatic void Op49M1 (void)\n{\n\tRegisters.AL ^= Immediate8(READ);\n\tSetZN(Registers.AL);\n}\n\nstatic void Op49M0 (void)\n{\n\tRegisters.A.W ^= Immediate16(READ);\n\tSetZN(Registers.A.W);\n}\n\nstatic void Op49Slow (void)\n{\n\tif (CheckMemory())\n\t{\n\t\tRegisters.AL ^= Immediate8Slow(READ);\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tRegisters.A.W ^= Immediate16Slow(READ);\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nrOP8 (45M1,     Direct,                           WRAP_BANK, EOR)\nrOP16(45M0,     Direct,                           WRAP_BANK, EOR)\nrOPM (45Slow,   DirectSlow,                       WRAP_BANK, EOR)\n\nrOP8 (55E1,     DirectIndexedXE1,                 WRAP_BANK, EOR)\nrOP8 (55E0M1,   DirectIndexedXE0,                 WRAP_BANK, EOR)\nrOP16(55E0M0,   DirectIndexedXE0,                 WRAP_BANK, EOR)\nrOPM (55Slow,   DirectIndexedXSlow,               WRAP_BANK, EOR)\n\nrOP8 (52E1,     DirectIndirectE1,                 WRAP_NONE, EOR)\nrOP8 (52E0M1,   DirectIndirectE0,                 WRAP_NONE, EOR)\nrOP16(52E0M0,   DirectIndirectE0,                 WRAP_NONE, EOR)\nrOPM (52Slow,   DirectIndirectSlow,               WRAP_NONE, EOR)\n\nrOP8 (41E1,     DirectIndexedIndirectE1,          WRAP_NONE, EOR)\nrOP8 (41E0M1,   DirectIndexedIndirectE0,          WRAP_NONE, EOR)\nrOP16(41E0M0,   DirectIndexedIndirectE0,          WRAP_NONE, EOR)\nrOPM (41Slow,   DirectIndexedIndirectSlow,        WRAP_NONE, EOR)\n\nrOP8 (51E1,     DirectIndirectIndexedE1,          WRAP_NONE, EOR)\nrOP8 (51E0M1X1, DirectIndirectIndexedE0X1,        WRAP_NONE, EOR)\nrOP16(51E0M0X1, DirectIndirectIndexedE0X1,        WRAP_NONE, EOR)\nrOP8 (51E0M1X0, DirectIndirectIndexedE0X0,        WRAP_NONE, EOR)\nrOP16(51E0M0X0, DirectIndirectIndexedE0X0,        WRAP_NONE, EOR)\nrOPM (51Slow,   DirectIndirectIndexedSlow,        WRAP_NONE, EOR)\n\nrOP8 (47M1,     DirectIndirectLong,               WRAP_NONE, EOR)\nrOP16(47M0,     DirectIndirectLong,               WRAP_NONE, EOR)\nrOPM (47Slow,   DirectIndirectLongSlow,           WRAP_NONE, EOR)\n\nrOP8 (57M1,     DirectIndirectIndexedLong,        WRAP_NONE, EOR)\nrOP16(57M0,     DirectIndirectIndexedLong,        WRAP_NONE, EOR)\nrOPM (57Slow,   DirectIndirectIndexedLongSlow,    WRAP_NONE, EOR)\n\nrOP8 (4DM1,     Absolute,                         WRAP_NONE, EOR)\nrOP16(4DM0,     Absolute,                         WRAP_NONE, EOR)\nrOPM (4DSlow,   AbsoluteSlow,                     WRAP_NONE, EOR)\n\nrOP8 (5DM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, EOR)\nrOP16(5DM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, EOR)\nrOP8 (5DM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, EOR)\nrOP16(5DM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, EOR)\nrOPM (5DSlow,   AbsoluteIndexedXSlow,             WRAP_NONE, EOR)\n\nrOP8 (59M1X1,   AbsoluteIndexedYX1,               WRAP_NONE, EOR)\nrOP16(59M0X1,   AbsoluteIndexedYX1,               WRAP_NONE, EOR)\nrOP8 (59M1X0,   AbsoluteIndexedYX0,               WRAP_NONE, EOR)\nrOP16(59M0X0,   AbsoluteIndexedYX0,               WRAP_NONE, EOR)\nrOPM (59Slow,   AbsoluteIndexedYSlow,             WRAP_NONE, EOR)\n\nrOP8 (4FM1,     AbsoluteLong,                     WRAP_NONE, EOR)\nrOP16(4FM0,     AbsoluteLong,                     WRAP_NONE, EOR)\nrOPM (4FSlow,   AbsoluteLongSlow,                 WRAP_NONE, EOR)\n\nrOP8 (5FM1,     AbsoluteLongIndexedX,             WRAP_NONE, EOR)\nrOP16(5FM0,     AbsoluteLongIndexedX,             WRAP_NONE, EOR)\nrOPM (5FSlow,   AbsoluteLongIndexedXSlow,         WRAP_NONE, EOR)\n\nrOP8 (43M1,     StackRelative,                    WRAP_NONE, EOR)\nrOP16(43M0,     StackRelative,                    WRAP_NONE, EOR)\nrOPM (43Slow,   StackRelativeSlow,                WRAP_NONE, EOR)\n\nrOP8 (53M1,     StackRelativeIndirectIndexed,     WRAP_NONE, EOR)\nrOP16(53M0,     StackRelativeIndirectIndexed,     WRAP_NONE, EOR)\nrOPM (53Slow,   StackRelativeIndirectIndexedSlow, WRAP_NONE, EOR)\n\n/* INC ********************************************************************* */\n\nstatic void Op1AM1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.AL++;\n\tSetZN(Registers.AL);\n}\n\nstatic void Op1AM0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.A.W++;\n\tSetZN(Registers.A.W);\n}\n\nstatic void Op1ASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckMemory())\n\t{\n\t\tRegisters.AL++;\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tRegisters.A.W++;\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nmOP8 (E6M1,     Direct,                           WRAP_BANK, INC)\nmOP16(E6M0,     Direct,                           WRAP_BANK, INC)\nmOPM (E6Slow,   DirectSlow,                       WRAP_BANK, INC)\n\nmOP8 (F6E1,     DirectIndexedXE1,                 WRAP_BANK, INC)\nmOP8 (F6E0M1,   DirectIndexedXE0,                 WRAP_BANK, INC)\nmOP16(F6E0M0,   DirectIndexedXE0,                 WRAP_BANK, INC)\nmOPM (F6Slow,   DirectIndexedXSlow,               WRAP_BANK, INC)\n\nmOP8 (EEM1,     Absolute,                         WRAP_NONE, INC)\nmOP16(EEM0,     Absolute,                         WRAP_NONE, INC)\nmOPM (EESlow,   AbsoluteSlow,                     WRAP_NONE, INC)\n\nmOP8 (FEM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, INC)\nmOP16(FEM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, INC)\nmOP8 (FEM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, INC)\nmOP16(FEM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, INC)\nmOPM (FESlow,   AbsoluteIndexedXSlow,             WRAP_NONE, INC)\n\n/* LDA ********************************************************************* */\n\nstatic void OpA9M1 (void)\n{\n\tRegisters.AL = Immediate8(READ);\n\tSetZN(Registers.AL);\n}\n\nstatic void OpA9M0 (void)\n{\n\tRegisters.A.W = Immediate16(READ);\n\tSetZN(Registers.A.W);\n}\n\nstatic void OpA9Slow (void)\n{\n\tif (CheckMemory())\n\t{\n\t\tRegisters.AL = Immediate8Slow(READ);\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tRegisters.A.W = Immediate16Slow(READ);\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nrOP8 (A5M1,     Direct,                           WRAP_BANK, LDA)\nrOP16(A5M0,     Direct,                           WRAP_BANK, LDA)\nrOPM (A5Slow,   DirectSlow,                       WRAP_BANK, LDA)\n\nrOP8 (B5E1,     DirectIndexedXE1,                 WRAP_BANK, LDA)\nrOP8 (B5E0M1,   DirectIndexedXE0,                 WRAP_BANK, LDA)\nrOP16(B5E0M0,   DirectIndexedXE0,                 WRAP_BANK, LDA)\nrOPM (B5Slow,   DirectIndexedXSlow,               WRAP_BANK, LDA)\n\nrOP8 (B2E1,     DirectIndirectE1,                 WRAP_NONE, LDA)\nrOP8 (B2E0M1,   DirectIndirectE0,                 WRAP_NONE, LDA)\nrOP16(B2E0M0,   DirectIndirectE0,                 WRAP_NONE, LDA)\nrOPM (B2Slow,   DirectIndirectSlow,               WRAP_NONE, LDA)\n\nrOP8 (A1E1,     DirectIndexedIndirectE1,          WRAP_NONE, LDA)\nrOP8 (A1E0M1,   DirectIndexedIndirectE0,          WRAP_NONE, LDA)\nrOP16(A1E0M0,   DirectIndexedIndirectE0,          WRAP_NONE, LDA)\nrOPM (A1Slow,   DirectIndexedIndirectSlow,        WRAP_NONE, LDA)\n\nrOP8 (B1E1,     DirectIndirectIndexedE1,          WRAP_NONE, LDA)\nrOP8 (B1E0M1X1, DirectIndirectIndexedE0X1,        WRAP_NONE, LDA)\nrOP16(B1E0M0X1, DirectIndirectIndexedE0X1,        WRAP_NONE, LDA)\nrOP8 (B1E0M1X0, DirectIndirectIndexedE0X0,        WRAP_NONE, LDA)\nrOP16(B1E0M0X0, DirectIndirectIndexedE0X0,        WRAP_NONE, LDA)\nrOPM (B1Slow,   DirectIndirectIndexedSlow,        WRAP_NONE, LDA)\n\nrOP8 (A7M1,     DirectIndirectLong,               WRAP_NONE, LDA)\nrOP16(A7M0,     DirectIndirectLong,               WRAP_NONE, LDA)\nrOPM (A7Slow,   DirectIndirectLongSlow,           WRAP_NONE, LDA)\n\nrOP8 (B7M1,     DirectIndirectIndexedLong,        WRAP_NONE, LDA)\nrOP16(B7M0,     DirectIndirectIndexedLong,        WRAP_NONE, LDA)\nrOPM (B7Slow,   DirectIndirectIndexedLongSlow,    WRAP_NONE, LDA)\n\nrOP8 (ADM1,     Absolute,                         WRAP_NONE, LDA)\nrOP16(ADM0,     Absolute,                         WRAP_NONE, LDA)\nrOPM (ADSlow,   AbsoluteSlow,                     WRAP_NONE, LDA)\n\nrOP8 (BDM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, LDA)\nrOP16(BDM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, LDA)\nrOP8 (BDM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, LDA)\nrOP16(BDM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, LDA)\nrOPM (BDSlow,   AbsoluteIndexedXSlow,             WRAP_NONE, LDA)\n\nrOP8 (B9M1X1,   AbsoluteIndexedYX1,               WRAP_NONE, LDA)\nrOP16(B9M0X1,   AbsoluteIndexedYX1,               WRAP_NONE, LDA)\nrOP8 (B9M1X0,   AbsoluteIndexedYX0,               WRAP_NONE, LDA)\nrOP16(B9M0X0,   AbsoluteIndexedYX0,               WRAP_NONE, LDA)\nrOPM (B9Slow,   AbsoluteIndexedYSlow,             WRAP_NONE, LDA)\n\nrOP8 (AFM1,     AbsoluteLong,                     WRAP_NONE, LDA)\nrOP16(AFM0,     AbsoluteLong,                     WRAP_NONE, LDA)\nrOPM (AFSlow,   AbsoluteLongSlow,                 WRAP_NONE, LDA)\n\nrOP8 (BFM1,     AbsoluteLongIndexedX,             WRAP_NONE, LDA)\nrOP16(BFM0,     AbsoluteLongIndexedX,             WRAP_NONE, LDA)\nrOPM (BFSlow,   AbsoluteLongIndexedXSlow,         WRAP_NONE, LDA)\n\nrOP8 (A3M1,     StackRelative,                    WRAP_NONE, LDA)\nrOP16(A3M0,     StackRelative,                    WRAP_NONE, LDA)\nrOPM (A3Slow,   StackRelativeSlow,                WRAP_NONE, LDA)\n\nrOP8 (B3M1,     StackRelativeIndirectIndexed,     WRAP_NONE, LDA)\nrOP16(B3M0,     StackRelativeIndirectIndexed,     WRAP_NONE, LDA)\nrOPM (B3Slow,   StackRelativeIndirectIndexedSlow, WRAP_NONE, LDA)\n\n/* LDX ********************************************************************* */\n\nstatic void OpA2X1 (void)\n{\n\tRegisters.XL = Immediate8(READ);\n\tSetZN(Registers.XL);\n}\n\nstatic void OpA2X0 (void)\n{\n\tRegisters.X.W = Immediate16(READ);\n\tSetZN(Registers.X.W);\n}\n\nstatic void OpA2Slow (void)\n{\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XL = Immediate8Slow(READ);\n\t\tSetZN(Registers.XL);\n\t}\n\telse\n\t{\n\t\tRegisters.X.W = Immediate16Slow(READ);\n\t\tSetZN(Registers.X.W);\n\t}\n}\n\nrOP8 (A6X1,     Direct,                           WRAP_BANK, LDX)\nrOP16(A6X0,     Direct,                           WRAP_BANK, LDX)\nrOPX (A6Slow,   DirectSlow,                       WRAP_BANK, LDX)\n\nrOP8 (B6E1,     DirectIndexedYE1,                 WRAP_BANK, LDX)\nrOP8 (B6E0X1,   DirectIndexedYE0,                 WRAP_BANK, LDX)\nrOP16(B6E0X0,   DirectIndexedYE0,                 WRAP_BANK, LDX)\nrOPX (B6Slow,   DirectIndexedYSlow,               WRAP_BANK, LDX)\n\nrOP8 (AEX1,     Absolute,                         WRAP_BANK, LDX)\nrOP16(AEX0,     Absolute,                         WRAP_BANK, LDX)\nrOPX (AESlow,   AbsoluteSlow,                     WRAP_BANK, LDX)\n\nrOP8 (BEX1,     AbsoluteIndexedYX1,               WRAP_BANK, LDX)\nrOP16(BEX0,     AbsoluteIndexedYX0,               WRAP_BANK, LDX)\nrOPX (BESlow,   AbsoluteIndexedYSlow,             WRAP_BANK, LDX)\n\n/* LDY ********************************************************************* */\n\nstatic void OpA0X1 (void)\n{\n\tRegisters.YL = Immediate8(READ);\n\tSetZN(Registers.YL);\n}\n\nstatic void OpA0X0 (void)\n{\n\tRegisters.Y.W = Immediate16(READ);\n\tSetZN(Registers.Y.W);\n}\n\nstatic void OpA0Slow (void)\n{\n\tif (CheckIndex())\n\t{\n\t\tRegisters.YL = Immediate8Slow(READ);\n\t\tSetZN(Registers.YL);\n\t}\n\telse\n\t{\n\t\tRegisters.Y.W = Immediate16Slow(READ);\n\t\tSetZN(Registers.Y.W);\n\t}\n}\n\nrOP8 (A4X1,     Direct,                           WRAP_BANK, LDY)\nrOP16(A4X0,     Direct,                           WRAP_BANK, LDY)\nrOPX (A4Slow,   DirectSlow,                       WRAP_BANK, LDY)\n\nrOP8 (B4E1,     DirectIndexedXE1,                 WRAP_BANK, LDY)\nrOP8 (B4E0X1,   DirectIndexedXE0,                 WRAP_BANK, LDY)\nrOP16(B4E0X0,   DirectIndexedXE0,                 WRAP_BANK, LDY)\nrOPX (B4Slow,   DirectIndexedXSlow,               WRAP_BANK, LDY)\n\nrOP8 (ACX1,     Absolute,                         WRAP_BANK, LDY)\nrOP16(ACX0,     Absolute,                         WRAP_BANK, LDY)\nrOPX (ACSlow,   AbsoluteSlow,                     WRAP_BANK, LDY)\n\nrOP8 (BCX1,     AbsoluteIndexedXX1,               WRAP_BANK, LDY)\nrOP16(BCX0,     AbsoluteIndexedXX0,               WRAP_BANK, LDY)\nrOPX (BCSlow,   AbsoluteIndexedXSlow,             WRAP_BANK, LDY)\n\n/* LSR ********************************************************************* */\n\nstatic void Op4AM1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tICPU._Carry = Registers.AL & 1;\n\tRegisters.AL >>= 1;\n\tSetZN(Registers.AL);\n}\n\nstatic void Op4AM0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tICPU._Carry = Registers.A.W & 1;\n\tRegisters.A.W >>= 1;\n\tSetZN(Registers.A.W);\n}\n\nstatic void Op4ASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckMemory())\n\t{\n\t\tICPU._Carry = Registers.AL & 1;\n\t\tRegisters.AL >>= 1;\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tICPU._Carry = Registers.A.W & 1;\n\t\tRegisters.A.W >>= 1;\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nmOP8 (46M1,     Direct,                           WRAP_BANK, LSR)\nmOP16(46M0,     Direct,                           WRAP_BANK, LSR)\nmOPM (46Slow,   DirectSlow,                       WRAP_BANK, LSR)\n\nmOP8 (56E1,     DirectIndexedXE1,                 WRAP_BANK, LSR)\nmOP8 (56E0M1,   DirectIndexedXE0,                 WRAP_BANK, LSR)\nmOP16(56E0M0,   DirectIndexedXE0,                 WRAP_BANK, LSR)\nmOPM (56Slow,   DirectIndexedXSlow,               WRAP_BANK, LSR)\n\nmOP8 (4EM1,     Absolute,                         WRAP_NONE, LSR)\nmOP16(4EM0,     Absolute,                         WRAP_NONE, LSR)\nmOPM (4ESlow,   AbsoluteSlow,                     WRAP_NONE, LSR)\n\nmOP8 (5EM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, LSR)\nmOP16(5EM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, LSR)\nmOP8 (5EM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, LSR)\nmOP16(5EM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, LSR)\nmOPM (5ESlow,   AbsoluteIndexedXSlow,             WRAP_NONE, LSR)\n\n/* ORA ********************************************************************* */\n\nstatic void Op09M1 (void)\n{\n\tRegisters.AL |= Immediate8(READ);\n\tSetZN(Registers.AL);\n}\n\nstatic void Op09M0 (void)\n{\n\tRegisters.A.W |= Immediate16(READ);\n\tSetZN(Registers.A.W);\n}\n\nstatic void Op09Slow (void)\n{\n\tif (CheckMemory())\n\t{\n\t\tRegisters.AL |= Immediate8Slow(READ);\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tRegisters.A.W |= Immediate16Slow(READ);\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nrOP8 (05M1,     Direct,                           WRAP_BANK, ORA)\nrOP16(05M0,     Direct,                           WRAP_BANK, ORA)\nrOPM (05Slow,   DirectSlow,                       WRAP_BANK, ORA)\n\nrOP8 (15E1,     DirectIndexedXE1,                 WRAP_BANK, ORA)\nrOP8 (15E0M1,   DirectIndexedXE0,                 WRAP_BANK, ORA)\nrOP16(15E0M0,   DirectIndexedXE0,                 WRAP_BANK, ORA)\nrOPM (15Slow,   DirectIndexedXSlow,               WRAP_BANK, ORA)\n\nrOP8 (12E1,     DirectIndirectE1,                 WRAP_NONE, ORA)\nrOP8 (12E0M1,   DirectIndirectE0,                 WRAP_NONE, ORA)\nrOP16(12E0M0,   DirectIndirectE0,                 WRAP_NONE, ORA)\nrOPM (12Slow,   DirectIndirectSlow,               WRAP_NONE, ORA)\n\nrOP8 (01E1,     DirectIndexedIndirectE1,          WRAP_NONE, ORA)\nrOP8 (01E0M1,   DirectIndexedIndirectE0,          WRAP_NONE, ORA)\nrOP16(01E0M0,   DirectIndexedIndirectE0,          WRAP_NONE, ORA)\nrOPM (01Slow,   DirectIndexedIndirectSlow,        WRAP_NONE, ORA)\n\nrOP8 (11E1,     DirectIndirectIndexedE1,          WRAP_NONE, ORA)\nrOP8 (11E0M1X1, DirectIndirectIndexedE0X1,        WRAP_NONE, ORA)\nrOP16(11E0M0X1, DirectIndirectIndexedE0X1,        WRAP_NONE, ORA)\nrOP8 (11E0M1X0, DirectIndirectIndexedE0X0,        WRAP_NONE, ORA)\nrOP16(11E0M0X0, DirectIndirectIndexedE0X0,        WRAP_NONE, ORA)\nrOPM (11Slow,   DirectIndirectIndexedSlow,        WRAP_NONE, ORA)\n\nrOP8 (07M1,     DirectIndirectLong,               WRAP_NONE, ORA)\nrOP16(07M0,     DirectIndirectLong,               WRAP_NONE, ORA)\nrOPM (07Slow,   DirectIndirectLongSlow,           WRAP_NONE, ORA)\n\nrOP8 (17M1,     DirectIndirectIndexedLong,        WRAP_NONE, ORA)\nrOP16(17M0,     DirectIndirectIndexedLong,        WRAP_NONE, ORA)\nrOPM (17Slow,   DirectIndirectIndexedLongSlow,    WRAP_NONE, ORA)\n\nrOP8 (0DM1,     Absolute,                         WRAP_NONE, ORA)\nrOP16(0DM0,     Absolute,                         WRAP_NONE, ORA)\nrOPM (0DSlow,   AbsoluteSlow,                     WRAP_NONE, ORA)\n\nrOP8 (1DM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, ORA)\nrOP16(1DM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, ORA)\nrOP8 (1DM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, ORA)\nrOP16(1DM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, ORA)\nrOPM (1DSlow,   AbsoluteIndexedXSlow,             WRAP_NONE, ORA)\n\nrOP8 (19M1X1,   AbsoluteIndexedYX1,               WRAP_NONE, ORA)\nrOP16(19M0X1,   AbsoluteIndexedYX1,               WRAP_NONE, ORA)\nrOP8 (19M1X0,   AbsoluteIndexedYX0,               WRAP_NONE, ORA)\nrOP16(19M0X0,   AbsoluteIndexedYX0,               WRAP_NONE, ORA)\nrOPM (19Slow,   AbsoluteIndexedYSlow,             WRAP_NONE, ORA)\n\nrOP8 (0FM1,     AbsoluteLong,                     WRAP_NONE, ORA)\nrOP16(0FM0,     AbsoluteLong,                     WRAP_NONE, ORA)\nrOPM (0FSlow,   AbsoluteLongSlow,                 WRAP_NONE, ORA)\n\nrOP8 (1FM1,     AbsoluteLongIndexedX,             WRAP_NONE, ORA)\nrOP16(1FM0,     AbsoluteLongIndexedX,             WRAP_NONE, ORA)\nrOPM (1FSlow,   AbsoluteLongIndexedXSlow,         WRAP_NONE, ORA)\n\nrOP8 (03M1,     StackRelative,                    WRAP_NONE, ORA)\nrOP16(03M0,     StackRelative,                    WRAP_NONE, ORA)\nrOPM (03Slow,   StackRelativeSlow,                WRAP_NONE, ORA)\n\nrOP8 (13M1,     StackRelativeIndirectIndexed,     WRAP_NONE, ORA)\nrOP16(13M0,     StackRelativeIndirectIndexed,     WRAP_NONE, ORA)\nrOPM (13Slow,   StackRelativeIndirectIndexedSlow, WRAP_NONE, ORA)\n\n/* ROL ********************************************************************* */\n\nstatic void Op2AM1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tuint16\tw = (((uint16) Registers.AL) << 1) | CheckCarry();\n\tICPU._Carry = w >= 0x100;\n\tRegisters.AL = (uint8) w;\n\tSetZN(Registers.AL);\n}\n\nstatic void Op2AM0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tuint32\tw = (((uint32) Registers.A.W) << 1) | CheckCarry();\n\tICPU._Carry = w >= 0x10000;\n\tRegisters.A.W = (uint16) w;\n\tSetZN(Registers.A.W);\n}\n\nstatic void Op2ASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckMemory())\n\t{\n\t\tuint16\tw = (((uint16) Registers.AL) << 1) | CheckCarry();\n\t\tICPU._Carry = w >= 0x100;\n\t\tRegisters.AL = (uint8) w;\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tuint32\tw = (((uint32) Registers.A.W) << 1) | CheckCarry();\n\t\tICPU._Carry = w >= 0x10000;\n\t\tRegisters.A.W = (uint16) w;\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nmOP8 (26M1,     Direct,                           WRAP_BANK, ROL)\nmOP16(26M0,     Direct,                           WRAP_BANK, ROL)\nmOPM (26Slow,   DirectSlow,                       WRAP_BANK, ROL)\n\nmOP8 (36E1,     DirectIndexedXE1,                 WRAP_BANK, ROL)\nmOP8 (36E0M1,   DirectIndexedXE0,                 WRAP_BANK, ROL)\nmOP16(36E0M0,   DirectIndexedXE0,                 WRAP_BANK, ROL)\nmOPM (36Slow,   DirectIndexedXSlow,               WRAP_BANK, ROL)\n\nmOP8 (2EM1,     Absolute,                         WRAP_NONE, ROL)\nmOP16(2EM0,     Absolute,                         WRAP_NONE, ROL)\nmOPM (2ESlow,   AbsoluteSlow,                     WRAP_NONE, ROL)\n\nmOP8 (3EM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, ROL)\nmOP16(3EM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, ROL)\nmOP8 (3EM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, ROL)\nmOP16(3EM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, ROL)\nmOPM (3ESlow,   AbsoluteIndexedXSlow,             WRAP_NONE, ROL)\n\n/* ROR ********************************************************************* */\n\nstatic void Op6AM1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tuint16\tw = ((uint16) Registers.AL) | (((uint16) CheckCarry()) << 8);\n\tICPU._Carry = w & 1;\n\tw >>= 1;\n\tRegisters.AL = (uint8) w;\n\tSetZN(Registers.AL);\n}\n\nstatic void Op6AM0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tuint32\tw = ((uint32) Registers.A.W) | (((uint32) CheckCarry()) << 16);\n\tICPU._Carry = w & 1;\n\tw >>= 1;\n\tRegisters.A.W = (uint16) w;\n\tSetZN(Registers.A.W);\n}\n\nstatic void Op6ASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckMemory())\n\t{\n\t\tuint16\tw = ((uint16) Registers.AL) | (((uint16) CheckCarry()) << 8);\n\t\tICPU._Carry = w & 1;\n\t\tw >>= 1;\n\t\tRegisters.AL = (uint8) w;\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tuint32\tw = ((uint32) Registers.A.W) | (((uint32) CheckCarry()) << 16);\n\t\tICPU._Carry = w & 1;\n\t\tw >>= 1;\n\t\tRegisters.A.W = (uint16) w;\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\nmOP8 (66M1,     Direct,                           WRAP_BANK, ROR)\nmOP16(66M0,     Direct,                           WRAP_BANK, ROR)\nmOPM (66Slow,   DirectSlow,                       WRAP_BANK, ROR)\n\nmOP8 (76E1,     DirectIndexedXE1,                 WRAP_BANK, ROR)\nmOP8 (76E0M1,   DirectIndexedXE0,                 WRAP_BANK, ROR)\nmOP16(76E0M0,   DirectIndexedXE0,                 WRAP_BANK, ROR)\nmOPM (76Slow,   DirectIndexedXSlow,               WRAP_BANK, ROR)\n\nmOP8 (6EM1,     Absolute,                         WRAP_NONE, ROR)\nmOP16(6EM0,     Absolute,                         WRAP_NONE, ROR)\nmOPM (6ESlow,   AbsoluteSlow,                     WRAP_NONE, ROR)\n\nmOP8 (7EM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, ROR)\nmOP16(7EM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, ROR)\nmOP8 (7EM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, ROR)\nmOP16(7EM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, ROR)\nmOPM (7ESlow,   AbsoluteIndexedXSlow,             WRAP_NONE, ROR)\n\n/* SBC ********************************************************************* */\n\nstatic void OpE9M1 (void)\n{\n\tSBC(Immediate8(READ));\n}\n\nstatic void OpE9M0 (void)\n{\n\tSBC(Immediate16(READ));\n}\n\nstatic void OpE9Slow (void)\n{\n\tif (CheckMemory())\n\t\tSBC(Immediate8Slow(READ));\n\telse\n\t\tSBC(Immediate16Slow(READ));\n}\n\nrOP8 (E5M1,     Direct,                           WRAP_BANK, SBC)\nrOP16(E5M0,     Direct,                           WRAP_BANK, SBC)\nrOPM (E5Slow,   DirectSlow,                       WRAP_BANK, SBC)\n\nrOP8 (F5E1,     DirectIndexedXE1,                 WRAP_BANK, SBC)\nrOP8 (F5E0M1,   DirectIndexedXE0,                 WRAP_BANK, SBC)\nrOP16(F5E0M0,   DirectIndexedXE0,                 WRAP_BANK, SBC)\nrOPM (F5Slow,   DirectIndexedXSlow,               WRAP_BANK, SBC)\n\nrOP8 (F2E1,     DirectIndirectE1,                 WRAP_NONE, SBC)\nrOP8 (F2E0M1,   DirectIndirectE0,                 WRAP_NONE, SBC)\nrOP16(F2E0M0,   DirectIndirectE0,                 WRAP_NONE, SBC)\nrOPM (F2Slow,   DirectIndirectSlow,               WRAP_NONE, SBC)\n\nrOP8 (E1E1,     DirectIndexedIndirectE1,          WRAP_NONE, SBC)\nrOP8 (E1E0M1,   DirectIndexedIndirectE0,          WRAP_NONE, SBC)\nrOP16(E1E0M0,   DirectIndexedIndirectE0,          WRAP_NONE, SBC)\nrOPM (E1Slow,   DirectIndexedIndirectSlow,        WRAP_NONE, SBC)\n\nrOP8 (F1E1,     DirectIndirectIndexedE1,          WRAP_NONE, SBC)\nrOP8 (F1E0M1X1, DirectIndirectIndexedE0X1,        WRAP_NONE, SBC)\nrOP16(F1E0M0X1, DirectIndirectIndexedE0X1,        WRAP_NONE, SBC)\nrOP8 (F1E0M1X0, DirectIndirectIndexedE0X0,        WRAP_NONE, SBC)\nrOP16(F1E0M0X0, DirectIndirectIndexedE0X0,        WRAP_NONE, SBC)\nrOPM (F1Slow,   DirectIndirectIndexedSlow,        WRAP_NONE, SBC)\n\nrOP8 (E7M1,     DirectIndirectLong,               WRAP_NONE, SBC)\nrOP16(E7M0,     DirectIndirectLong,               WRAP_NONE, SBC)\nrOPM (E7Slow,   DirectIndirectLongSlow,           WRAP_NONE, SBC)\n\nrOP8 (F7M1,     DirectIndirectIndexedLong,        WRAP_NONE, SBC)\nrOP16(F7M0,     DirectIndirectIndexedLong,        WRAP_NONE, SBC)\nrOPM (F7Slow,   DirectIndirectIndexedLongSlow,    WRAP_NONE, SBC)\n\nrOP8 (EDM1,     Absolute,                         WRAP_NONE, SBC)\nrOP16(EDM0,     Absolute,                         WRAP_NONE, SBC)\nrOPM (EDSlow,   AbsoluteSlow,                     WRAP_NONE, SBC)\n\nrOP8 (FDM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, SBC)\nrOP16(FDM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, SBC)\nrOP8 (FDM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, SBC)\nrOP16(FDM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, SBC)\nrOPM (FDSlow,   AbsoluteIndexedXSlow,             WRAP_NONE, SBC)\n\nrOP8 (F9M1X1,   AbsoluteIndexedYX1,               WRAP_NONE, SBC)\nrOP16(F9M0X1,   AbsoluteIndexedYX1,               WRAP_NONE, SBC)\nrOP8 (F9M1X0,   AbsoluteIndexedYX0,               WRAP_NONE, SBC)\nrOP16(F9M0X0,   AbsoluteIndexedYX0,               WRAP_NONE, SBC)\nrOPM (F9Slow,   AbsoluteIndexedYSlow,             WRAP_NONE, SBC)\n\nrOP8 (EFM1,     AbsoluteLong,                     WRAP_NONE, SBC)\nrOP16(EFM0,     AbsoluteLong,                     WRAP_NONE, SBC)\nrOPM (EFSlow,   AbsoluteLongSlow,                 WRAP_NONE, SBC)\n\nrOP8 (FFM1,     AbsoluteLongIndexedX,             WRAP_NONE, SBC)\nrOP16(FFM0,     AbsoluteLongIndexedX,             WRAP_NONE, SBC)\nrOPM (FFSlow,   AbsoluteLongIndexedXSlow,         WRAP_NONE, SBC)\n\nrOP8 (E3M1,     StackRelative,                    WRAP_NONE, SBC)\nrOP16(E3M0,     StackRelative,                    WRAP_NONE, SBC)\nrOPM (E3Slow,   StackRelativeSlow,                WRAP_NONE, SBC)\n\nrOP8 (F3M1,     StackRelativeIndirectIndexed,     WRAP_NONE, SBC)\nrOP16(F3M0,     StackRelativeIndirectIndexed,     WRAP_NONE, SBC)\nrOPM (F3Slow,   StackRelativeIndirectIndexedSlow, WRAP_NONE, SBC)\n\n/* STA ********************************************************************* */\n\nwOP8 (85M1,     Direct,                           WRAP_BANK, STA)\nwOP16(85M0,     Direct,                           WRAP_BANK, STA)\nwOPM (85Slow,   DirectSlow,                       WRAP_BANK, STA)\n\nwOP8 (95E1,     DirectIndexedXE1,                 WRAP_BANK, STA)\nwOP8 (95E0M1,   DirectIndexedXE0,                 WRAP_BANK, STA)\nwOP16(95E0M0,   DirectIndexedXE0,                 WRAP_BANK, STA)\nwOPM (95Slow,   DirectIndexedXSlow,               WRAP_BANK, STA)\n\nwOP8 (92E1,     DirectIndirectE1,                 WRAP_NONE, STA)\nwOP8 (92E0M1,   DirectIndirectE0,                 WRAP_NONE, STA)\nwOP16(92E0M0,   DirectIndirectE0,                 WRAP_NONE, STA)\nwOPM (92Slow,   DirectIndirectSlow,               WRAP_NONE, STA)\n\nwOP8 (81E1,     DirectIndexedIndirectE1,          WRAP_NONE, STA)\nwOP8 (81E0M1,   DirectIndexedIndirectE0,          WRAP_NONE, STA)\nwOP16(81E0M0,   DirectIndexedIndirectE0,          WRAP_NONE, STA)\nwOPM (81Slow,   DirectIndexedIndirectSlow,        WRAP_NONE, STA)\n\nwOP8 (91E1,     DirectIndirectIndexedE1,          WRAP_NONE, STA)\nwOP8 (91E0M1X1, DirectIndirectIndexedE0X1,        WRAP_NONE, STA)\nwOP16(91E0M0X1, DirectIndirectIndexedE0X1,        WRAP_NONE, STA)\nwOP8 (91E0M1X0, DirectIndirectIndexedE0X0,        WRAP_NONE, STA)\nwOP16(91E0M0X0, DirectIndirectIndexedE0X0,        WRAP_NONE, STA)\nwOPM (91Slow,   DirectIndirectIndexedSlow,        WRAP_NONE, STA)\n\nwOP8 (87M1,     DirectIndirectLong,               WRAP_NONE, STA)\nwOP16(87M0,     DirectIndirectLong,               WRAP_NONE, STA)\nwOPM (87Slow,   DirectIndirectLongSlow,           WRAP_NONE, STA)\n\nwOP8 (97M1,     DirectIndirectIndexedLong,        WRAP_NONE, STA)\nwOP16(97M0,     DirectIndirectIndexedLong,        WRAP_NONE, STA)\nwOPM (97Slow,   DirectIndirectIndexedLongSlow,    WRAP_NONE, STA)\n\nwOP8 (8DM1,     Absolute,                         WRAP_NONE, STA)\nwOP16(8DM0,     Absolute,                         WRAP_NONE, STA)\nwOPM (8DSlow,   AbsoluteSlow,                     WRAP_NONE, STA)\n\nwOP8 (9DM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, STA)\nwOP16(9DM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, STA)\nwOP8 (9DM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, STA)\nwOP16(9DM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, STA)\nwOPM (9DSlow,   AbsoluteIndexedXSlow,             WRAP_NONE, STA)\n\nwOP8 (99M1X1,   AbsoluteIndexedYX1,               WRAP_NONE, STA)\nwOP16(99M0X1,   AbsoluteIndexedYX1,               WRAP_NONE, STA)\nwOP8 (99M1X0,   AbsoluteIndexedYX0,               WRAP_NONE, STA)\nwOP16(99M0X0,   AbsoluteIndexedYX0,               WRAP_NONE, STA)\nwOPM (99Slow,   AbsoluteIndexedYSlow,             WRAP_NONE, STA)\n\nwOP8 (8FM1,     AbsoluteLong,                     WRAP_NONE, STA)\nwOP16(8FM0,     AbsoluteLong,                     WRAP_NONE, STA)\nwOPM (8FSlow,   AbsoluteLongSlow,                 WRAP_NONE, STA)\n\nwOP8 (9FM1,     AbsoluteLongIndexedX,             WRAP_NONE, STA)\nwOP16(9FM0,     AbsoluteLongIndexedX,             WRAP_NONE, STA)\nwOPM (9FSlow,   AbsoluteLongIndexedXSlow,         WRAP_NONE, STA)\n\nwOP8 (83M1,     StackRelative,                    WRAP_NONE, STA)\nwOP16(83M0,     StackRelative,                    WRAP_NONE, STA)\nwOPM (83Slow,   StackRelativeSlow,                WRAP_NONE, STA)\n\nwOP8 (93M1,     StackRelativeIndirectIndexed,     WRAP_NONE, STA)\nwOP16(93M0,     StackRelativeIndirectIndexed,     WRAP_NONE, STA)\nwOPM (93Slow,   StackRelativeIndirectIndexedSlow, WRAP_NONE, STA)\n\n/* STX ********************************************************************* */\n\nwOP8 (86X1,     Direct,                           WRAP_BANK, STX)\nwOP16(86X0,     Direct,                           WRAP_BANK, STX)\nwOPX (86Slow,   DirectSlow,                       WRAP_BANK, STX)\n\nwOP8 (96E1,     DirectIndexedYE1,                 WRAP_BANK, STX)\nwOP8 (96E0X1,   DirectIndexedYE0,                 WRAP_BANK, STX)\nwOP16(96E0X0,   DirectIndexedYE0,                 WRAP_BANK, STX)\nwOPX (96Slow,   DirectIndexedYSlow,               WRAP_BANK, STX)\n\nwOP8 (8EX1,     Absolute,                         WRAP_BANK, STX)\nwOP16(8EX0,     Absolute,                         WRAP_BANK, STX)\nwOPX (8ESlow,   AbsoluteSlow,                     WRAP_BANK, STX)\n\n/* STY ********************************************************************* */\n\nwOP8 (84X1,     Direct,                           WRAP_BANK, STY)\nwOP16(84X0,     Direct,                           WRAP_BANK, STY)\nwOPX (84Slow,   DirectSlow,                       WRAP_BANK, STY)\n\nwOP8 (94E1,     DirectIndexedXE1,                 WRAP_BANK, STY)\nwOP8 (94E0X1,   DirectIndexedXE0,                 WRAP_BANK, STY)\nwOP16(94E0X0,   DirectIndexedXE0,                 WRAP_BANK, STY)\nwOPX (94Slow,   DirectIndexedXSlow,               WRAP_BANK, STY)\n\nwOP8 (8CX1,     Absolute,                         WRAP_BANK, STY)\nwOP16(8CX0,     Absolute,                         WRAP_BANK, STY)\nwOPX (8CSlow,   AbsoluteSlow,                     WRAP_BANK, STY)\n\n/* STZ ********************************************************************* */\n\nwOP8 (64M1,     Direct,                           WRAP_BANK, STZ)\nwOP16(64M0,     Direct,                           WRAP_BANK, STZ)\nwOPM (64Slow,   DirectSlow,                       WRAP_BANK, STZ)\n\nwOP8 (74E1,     DirectIndexedXE1,                 WRAP_BANK, STZ)\nwOP8 (74E0M1,   DirectIndexedXE0,                 WRAP_BANK, STZ)\nwOP16(74E0M0,   DirectIndexedXE0,                 WRAP_BANK, STZ)\nwOPM (74Slow,   DirectIndexedXSlow,               WRAP_BANK, STZ)\n\nwOP8 (9CM1,     Absolute,                         WRAP_NONE, STZ)\nwOP16(9CM0,     Absolute,                         WRAP_NONE, STZ)\nwOPM (9CSlow,   AbsoluteSlow,                     WRAP_NONE, STZ)\n\nwOP8 (9EM1X1,   AbsoluteIndexedXX1,               WRAP_NONE, STZ)\nwOP16(9EM0X1,   AbsoluteIndexedXX1,               WRAP_NONE, STZ)\nwOP8 (9EM1X0,   AbsoluteIndexedXX0,               WRAP_NONE, STZ)\nwOP16(9EM0X0,   AbsoluteIndexedXX0,               WRAP_NONE, STZ)\nwOPM (9ESlow,   AbsoluteIndexedXSlow,             WRAP_NONE, STZ)\n\n/* TRB ********************************************************************* */\n\nmOP8 (14M1,     Direct,                           WRAP_BANK, TRB)\nmOP16(14M0,     Direct,                           WRAP_BANK, TRB)\nmOPM (14Slow,   DirectSlow,                       WRAP_BANK, TRB)\n\nmOP8 (1CM1,     Absolute,                         WRAP_BANK, TRB)\nmOP16(1CM0,     Absolute,                         WRAP_BANK, TRB)\nmOPM (1CSlow,   AbsoluteSlow,                     WRAP_BANK, TRB)\n\n/* TSB ********************************************************************* */\n\nmOP8 (04M1,     Direct,                           WRAP_BANK, TSB)\nmOP16(04M0,     Direct,                           WRAP_BANK, TSB)\nmOPM (04Slow,   DirectSlow,                       WRAP_BANK, TSB)\n\nmOP8 (0CM1,     Absolute,                         WRAP_BANK, TSB)\nmOP16(0CM0,     Absolute,                         WRAP_BANK, TSB)\nmOPM (0CSlow,   AbsoluteSlow,                     WRAP_BANK, TSB)\n\n/* Branch Instructions ***************************************************** */\n\n// BCC\nbOP(90E0,   Relative,     !CheckCarry(),    0, 0)\nbOP(90E1,   Relative,     !CheckCarry(),    0, 1)\nbOP(90Slow, RelativeSlow, !CheckCarry(),    0, CheckEmulation())\n\n// BCS\nbOP(B0E0,   Relative,      CheckCarry(),    0, 0)\nbOP(B0E1,   Relative,      CheckCarry(),    0, 1)\nbOP(B0Slow, RelativeSlow,  CheckCarry(),    0, CheckEmulation())\n\n// BEQ\nbOP(F0E0,   Relative,      CheckZero(),     2, 0)\nbOP(F0E1,   Relative,      CheckZero(),     2, 1)\nbOP(F0Slow, RelativeSlow,  CheckZero(),     2, CheckEmulation())\n\n// BMI\nbOP(30E0,   Relative,      CheckNegative(), 1, 0)\nbOP(30E1,   Relative,      CheckNegative(), 1, 1)\nbOP(30Slow, RelativeSlow,  CheckNegative(), 1, CheckEmulation())\n\n// BNE\nbOP(D0E0,   Relative,     !CheckZero(),     1, 0)\nbOP(D0E1,   Relative,     !CheckZero(),     1, 1)\nbOP(D0Slow, RelativeSlow, !CheckZero(),     1, CheckEmulation())\n\n// BPL\nbOP(10E0,   Relative,     !CheckNegative(), 1, 0)\nbOP(10E1,   Relative,     !CheckNegative(), 1, 1)\nbOP(10Slow, RelativeSlow, !CheckNegative(), 1, CheckEmulation())\n\n// BRA\nbOP(80E0,   Relative,     1,                X, 0)\nbOP(80E1,   Relative,     1,                X, 1)\nbOP(80Slow, RelativeSlow, 1,                X, CheckEmulation())\n\n// BVC\nbOP(50E0,   Relative,     !CheckOverflow(), 0, 0)\nbOP(50E1,   Relative,     !CheckOverflow(), 0, 1)\nbOP(50Slow, RelativeSlow, !CheckOverflow(), 0, CheckEmulation())\n\n// BVS\nbOP(70E0,   Relative,      CheckOverflow(), 0, 0)\nbOP(70E1,   Relative,      CheckOverflow(), 0, 1)\nbOP(70Slow, RelativeSlow,  CheckOverflow(), 0, CheckEmulation())\n\n// BRL\nstatic void Op82 (void)\n{\n\tS9xSetPCBase(ICPU.ShiftedPB + RelativeLong(JUMP));\n\tAddCycles(ONE_CYCLE);\n}\n\nstatic void Op82Slow (void)\n{\n\tS9xSetPCBase(ICPU.ShiftedPB + RelativeLongSlow(JUMP));\n\tAddCycles(ONE_CYCLE);\n}\n\n/* Flag Instructions ******************************************************* */\n\n// CLC\nstatic void Op18 (void)\n{\n\tClearCarry();\n\tAddCycles(ONE_CYCLE);\n}\n\n// SEC\nstatic void Op38 (void)\n{\n\tSetCarry();\n\tAddCycles(ONE_CYCLE);\n}\n\n// CLD\nstatic void OpD8 (void)\n{\n\tClearDecimal();\n\tAddCycles(ONE_CYCLE);\n}\n\n// SED\nstatic void OpF8 (void)\n{\n\tSetDecimal();\n\tAddCycles(ONE_CYCLE);\n#ifdef DEBUGGER\n\tmissing.decimal_mode = 1;\n#endif\n}\n\n// CLI\nstatic void Op58 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n#ifndef SA1_OPCODES\n\tTimings.IRQFlagChanging |= IRQ_CLEAR_FLAG;\n#else\n\tClearIRQ();\n#endif\n}\n\n// SEI\nstatic void Op78 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n#ifndef SA1_OPCODES\n\tTimings.IRQFlagChanging |= IRQ_SET_FLAG;\n#else\n\tSetIRQ();\n#endif\n}\n\n// CLV\nstatic void OpB8 (void)\n{\n\tClearOverflow();\n\tAddCycles(ONE_CYCLE);\n}\n\n/* DEX/DEY ***************************************************************** */\n\nstatic void OpCAX1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.XL--;\n\tSetZN(Registers.XL);\n}\n\nstatic void OpCAX0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.X.W--;\n\tSetZN(Registers.X.W);\n}\n\nstatic void OpCASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XL--;\n\t\tSetZN(Registers.XL);\n\t}\n\telse\n\t{\n\t\tRegisters.X.W--;\n\t\tSetZN(Registers.X.W);\n\t}\n}\n\nstatic void Op88X1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.YL--;\n\tSetZN(Registers.YL);\n}\n\nstatic void Op88X0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.Y.W--;\n\tSetZN(Registers.Y.W);\n}\n\nstatic void Op88Slow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.YL--;\n\t\tSetZN(Registers.YL);\n\t}\n\telse\n\t{\n\t\tRegisters.Y.W--;\n\t\tSetZN(Registers.Y.W);\n\t}\n}\n\n/* INX/INY ***************************************************************** */\n\nstatic void OpE8X1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.XL++;\n\tSetZN(Registers.XL);\n}\n\nstatic void OpE8X0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.X.W++;\n\tSetZN(Registers.X.W);\n}\n\nstatic void OpE8Slow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XL++;\n\t\tSetZN(Registers.XL);\n\t}\n\telse\n\t{\n\t\tRegisters.X.W++;\n\t\tSetZN(Registers.X.W);\n\t}\n}\n\nstatic void OpC8X1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.YL++;\n\tSetZN(Registers.YL);\n}\n\nstatic void OpC8X0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.Y.W++;\n\tSetZN(Registers.Y.W);\n}\n\nstatic void OpC8Slow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.YL++;\n\t\tSetZN(Registers.YL);\n\t}\n\telse\n\t{\n\t\tRegisters.Y.W++;\n\t\tSetZN(Registers.Y.W);\n\t}\n}\n\n/* NOP ********************************************************************* */\n\nstatic void OpEA (void)\n{\n\tAddCycles(ONE_CYCLE);\n}\n\n/* PUSH Instructions ******************************************************* */\n\n#define PushW(w) \\\n\tS9xSetWord(w, Registers.S.W - 1, WRAP_BANK, WRITE_10); \\\n\tRegisters.S.W -= 2;\n\n#define PushWE(w) \\\n\tRegisters.SL--; \\\n\tS9xSetWord(w, Registers.S.W, WRAP_PAGE, WRITE_10); \\\n\tRegisters.SL--;\n\n#define PushB(b) \\\n\tS9xSetByte(b, Registers.S.W--);\n\n#define PushBE(b) \\\n\tS9xSetByte(b, Registers.S.W); \\\n\tRegisters.SL--;\n\n// PEA\nstatic void OpF4E0 (void)\n{\n\tuint16\tval = (uint16) Absolute(NONE);\n\tPushW(val);\n\tOpenBus = val & 0xff;\n}\n\nstatic void OpF4E1 (void)\n{\n\t// Note: PEA is a new instruction,\n\t// and so doesn't respect the emu-mode stack bounds.\n\tuint16\tval = (uint16) Absolute(NONE);\n\tPushW(val);\n\tOpenBus = val & 0xff;\n\tRegisters.SH = 1;\n}\n\nstatic void OpF4Slow (void)\n{\n\tuint16\tval = (uint16) AbsoluteSlow(NONE);\n\tPushW(val);\n\tOpenBus = val & 0xff;\n\tif (CheckEmulation())\n\t\tRegisters.SH = 1;\n}\n\n// PEI\nstatic void OpD4E0 (void)\n{\n\tuint16\tval = (uint16) DirectIndirectE0(NONE);\n\tPushW(val);\n\tOpenBus = val & 0xff;\n}\n\nstatic void OpD4E1 (void)\n{\n\t// Note: PEI is a new instruction,\n\t// and so doesn't respect the emu-mode stack bounds.\n\tuint16\tval = (uint16) DirectIndirectE1(NONE);\n\tPushW(val);\n\tOpenBus = val & 0xff;\n\tRegisters.SH = 1;\n}\n\nstatic void OpD4Slow (void)\n{\n\tuint16\tval = (uint16) DirectIndirectSlow(NONE);\n\tPushW(val);\n\tOpenBus = val & 0xff;\n\tif (CheckEmulation())\n\t\tRegisters.SH = 1;\n}\n\n// PER\nstatic void Op62E0 (void)\n{\n\tuint16\tval = (uint16) RelativeLong(NONE);\n\tPushW(val);\n\tOpenBus = val & 0xff;\n}\n\nstatic void Op62E1 (void)\n{\n\t// Note: PER is a new instruction,\n\t// and so doesn't respect the emu-mode stack bounds.\n\tuint16\tval = (uint16) RelativeLong(NONE);\n\tPushW(val);\n\tOpenBus = val & 0xff;\n\tRegisters.SH = 1;\n}\n\nstatic void Op62Slow (void)\n{\n\tuint16\tval = (uint16) RelativeLongSlow(NONE);\n\tPushW(val);\n\tOpenBus = val & 0xff;\n\tif (CheckEmulation())\n\t\tRegisters.SH = 1;\n}\n\n// PHA\nstatic void Op48E1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushBE(Registers.AL);\n\tOpenBus = Registers.AL;\n}\n\nstatic void Op48E0M1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushB(Registers.AL);\n\tOpenBus = Registers.AL;\n}\n\nstatic void Op48E0M0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushW(Registers.A.W);\n\tOpenBus = Registers.AL;\n}\n\nstatic void Op48Slow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckEmulation())\n\t{\n\t\tPushBE(Registers.AL);\n\t}\n\telse\n\tif (CheckMemory())\n\t{\n\t\tPushB(Registers.AL);\n\t}\n\telse\n\t{\n\t\tPushW(Registers.A.W);\n\t}\n\n\tOpenBus = Registers.AL;\n}\n\n// PHB\nstatic void Op8BE1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushBE(Registers.DB);\n\tOpenBus = Registers.DB;\n}\n\nstatic void Op8BE0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushB(Registers.DB);\n\tOpenBus = Registers.DB;\n}\n\nstatic void Op8BSlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckEmulation())\n\t{\n\t\tPushBE(Registers.DB);\n\t}\n\telse\n\t{\n\t\tPushB(Registers.DB);\n\t}\n\n\tOpenBus = Registers.DB;\n}\n\n// PHD\nstatic void Op0BE0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushW(Registers.D.W);\n\tOpenBus = Registers.DL;\n}\n\nstatic void Op0BE1 (void)\n{\n\t// Note: PHD is a new instruction,\n\t// and so doesn't respect the emu-mode stack bounds.\n\tAddCycles(ONE_CYCLE);\n\tPushW(Registers.D.W);\n\tOpenBus = Registers.DL;\n\tRegisters.SH = 1;\n}\n\nstatic void Op0BSlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushW(Registers.D.W);\n\tOpenBus = Registers.DL;\n\tif (CheckEmulation())\n\t\tRegisters.SH = 1;\n}\n\n// PHK\nstatic void Op4BE1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushBE(Registers.PB);\n\tOpenBus = Registers.PB;\n}\n\nstatic void Op4BE0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushB(Registers.PB);\n\tOpenBus = Registers.PB;\n}\n\nstatic void Op4BSlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckEmulation())\n\t{\n\t\tPushBE(Registers.PB);\n\t}\n\telse\n\t{\n\t\tPushB(Registers.PB);\n\t}\n\n\tOpenBus = Registers.PB;\n}\n\n// PHP\nstatic void Op08E0 (void)\n{\n\tS9xPackStatus();\n\tAddCycles(ONE_CYCLE);\n\tPushB(Registers.PL);\n\tOpenBus = Registers.PL;\n}\n\nstatic void Op08E1 (void)\n{\n\tS9xPackStatus();\n\tAddCycles(ONE_CYCLE);\n\tPushBE(Registers.PL);\n\tOpenBus = Registers.PL;\n}\n\nstatic void Op08Slow (void)\n{\n\tS9xPackStatus();\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckEmulation())\n\t{\n\t\tPushBE(Registers.PL);\n\t}\n\telse\n\t{\n\t\tPushB(Registers.PL);\n\t}\n\n\tOpenBus = Registers.PL;\n}\n\n// PHX\nstatic void OpDAE1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushBE(Registers.XL);\n\tOpenBus = Registers.XL;\n}\n\nstatic void OpDAE0X1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushB(Registers.XL);\n\tOpenBus = Registers.XL;\n}\n\nstatic void OpDAE0X0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushW(Registers.X.W);\n\tOpenBus = Registers.XL;\n}\n\nstatic void OpDASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckEmulation())\n\t{\n\t\tPushBE(Registers.XL);\n\t}\n\telse\n\tif (CheckIndex())\n\t{\n\t\tPushB(Registers.XL);\n\t}\n\telse\n\t{\n\t\tPushW(Registers.X.W);\n\t}\n\n\tOpenBus = Registers.XL;\n}\n\n// PHY\nstatic void Op5AE1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushBE(Registers.YL);\n\tOpenBus = Registers.YL;\n}\n\nstatic void Op5AE0X1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushB(Registers.YL);\n\tOpenBus = Registers.YL;\n}\n\nstatic void Op5AE0X0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tPushW(Registers.Y.W);\n\tOpenBus = Registers.YL;\n}\n\nstatic void Op5ASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckEmulation())\n\t{\n\t\tPushBE(Registers.YL);\n\t}\n\telse\n\tif (CheckIndex())\n\t{\n\t\tPushB(Registers.YL);\n\t}\n\telse\n\t{\n\t\tPushW(Registers.Y.W);\n\t}\n\n\tOpenBus = Registers.YL;\n}\n\n/* PULL Instructions ******************************************************* */\n\n#define PullW(w) \\\n\tw = S9xGetWord(Registers.S.W + 1, WRAP_BANK); \\\n\tRegisters.S.W += 2;\n\n#define PullWE(w) \\\n\tRegisters.SL++; \\\n\tw = S9xGetWord(Registers.S.W, WRAP_PAGE); \\\n\tRegisters.SL++;\n\n#define PullB(b) \\\n\tb = S9xGetByte(++Registers.S.W);\n\n#define PullBE(b) \\\n\tRegisters.SL++; \\\n\tb = S9xGetByte(Registers.S.W);\n\n// PLA\nstatic void Op68E1 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullBE(Registers.AL);\n\tSetZN(Registers.AL);\n\tOpenBus = Registers.AL;\n}\n\nstatic void Op68E0M1 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullB(Registers.AL);\n\tSetZN(Registers.AL);\n\tOpenBus = Registers.AL;\n}\n\nstatic void Op68E0M0 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullW(Registers.A.W);\n\tSetZN(Registers.A.W);\n\tOpenBus = Registers.AH;\n}\n\nstatic void Op68Slow (void)\n{\n\tAddCycles(TWO_CYCLES);\n\n\tif (CheckEmulation())\n\t{\n\t\tPullBE(Registers.AL);\n\t\tSetZN(Registers.AL);\n\t\tOpenBus = Registers.AL;\n\t}\n\telse\n\tif (CheckMemory())\n\t{\n\t\tPullB(Registers.AL);\n\t\tSetZN(Registers.AL);\n\t\tOpenBus = Registers.AL;\n\t}\n\telse\n\t{\n\t\tPullW(Registers.A.W);\n\t\tSetZN(Registers.A.W);\n\t\tOpenBus = Registers.AH;\n\t}\n}\n\n// PLB\nstatic void OpABE1 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullBE(Registers.DB);\n\tSetZN(Registers.DB);\n\tICPU.ShiftedDB = Registers.DB << 16;\n\tOpenBus = Registers.DB;\n}\n\nstatic void OpABE0 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullB(Registers.DB);\n\tSetZN(Registers.DB);\n\tICPU.ShiftedDB = Registers.DB << 16;\n\tOpenBus = Registers.DB;\n}\n\nstatic void OpABSlow (void)\n{\n\tAddCycles(TWO_CYCLES);\n\n\tif (CheckEmulation())\n\t{\n\t\tPullBE(Registers.DB);\n\t}\n\telse\n\t{\n\t\tPullB(Registers.DB);\n\t}\n\n\tSetZN(Registers.DB);\n\tICPU.ShiftedDB = Registers.DB << 16;\n\tOpenBus = Registers.DB;\n}\n\n// PLD\nstatic void Op2BE0 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullW(Registers.D.W);\n\tSetZN(Registers.D.W);\n\tOpenBus = Registers.DH;\n}\n\nstatic void Op2BE1 (void)\n{\n\t// Note: PLD is a new instruction,\n\t// and so doesn't respect the emu-mode stack bounds.\n\tAddCycles(TWO_CYCLES);\n\tPullW(Registers.D.W);\n\tSetZN(Registers.D.W);\n\tOpenBus = Registers.DH;\n\tRegisters.SH = 1;\n}\n\nstatic void Op2BSlow (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullW(Registers.D.W);\n\tSetZN(Registers.D.W);\n\tOpenBus = Registers.DH;\n\tif (CheckEmulation())\n\t\tRegisters.SH = 1;\n}\n\n// PLP\nstatic void Op28E1 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullBE(Registers.PL);\n\tOpenBus = Registers.PL;\n\tSetFlags(MemoryFlag | IndexFlag);\n\tS9xUnpackStatus();\n\tS9xFixCycles();\n\tCHECK_FOR_IRQ();\n}\n\nstatic void Op28E0 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullB(Registers.PL);\n\tOpenBus = Registers.PL;\n\tS9xUnpackStatus();\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XH = 0;\n\t\tRegisters.YH = 0;\n\t}\n\n\tS9xFixCycles();\n\tCHECK_FOR_IRQ();\n}\n\nstatic void Op28Slow (void)\n{\n\tAddCycles(TWO_CYCLES);\n\n\tif (CheckEmulation())\n\t{\n\t\tPullBE(Registers.PL);\n\t\tOpenBus = Registers.PL;\n\t\tSetFlags(MemoryFlag | IndexFlag);\n\t}\n\telse\n\t{\n\t\tPullB(Registers.PL);\n\t\tOpenBus = Registers.PL;\n\t}\n\n\tS9xUnpackStatus();\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XH = 0;\n\t\tRegisters.YH = 0;\n\t}\n\n\tS9xFixCycles();\n\tCHECK_FOR_IRQ();\n}\n\n// PLX\nstatic void OpFAE1 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullBE(Registers.XL);\n\tSetZN(Registers.XL);\n\tOpenBus = Registers.XL;\n}\n\nstatic void OpFAE0X1 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullB(Registers.XL);\n\tSetZN(Registers.XL);\n\tOpenBus = Registers.XL;\n}\n\nstatic void OpFAE0X0 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullW(Registers.X.W);\n\tSetZN(Registers.X.W);\n\tOpenBus = Registers.XH;\n}\n\nstatic void OpFASlow (void)\n{\n\tAddCycles(TWO_CYCLES);\n\n\tif (CheckEmulation())\n\t{\n\t\tPullBE(Registers.XL);\n\t\tSetZN(Registers.XL);\n\t\tOpenBus = Registers.XL;\n\t}\n\telse\n\tif (CheckIndex())\n\t{\n\t\tPullB(Registers.XL);\n\t\tSetZN(Registers.XL);\n\t\tOpenBus = Registers.XL;\n\t}\n\telse\n\t{\n\t\tPullW(Registers.X.W);\n\t\tSetZN(Registers.X.W);\n\t\tOpenBus = Registers.XH;\n\t}\n}\n\n// PLY\nstatic void Op7AE1 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullBE(Registers.YL);\n\tSetZN(Registers.YL);\n\tOpenBus = Registers.YL;\n}\n\nstatic void Op7AE0X1 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullB(Registers.YL);\n\tSetZN(Registers.YL);\n\tOpenBus = Registers.YL;\n}\n\nstatic void Op7AE0X0 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullW(Registers.Y.W);\n\tSetZN(Registers.Y.W);\n\tOpenBus = Registers.YH;\n}\n\nstatic void Op7ASlow (void)\n{\n\tAddCycles(TWO_CYCLES);\n\n\tif (CheckEmulation())\n\t{\n\t\tPullBE(Registers.YL);\n\t\tSetZN(Registers.YL);\n\t\tOpenBus = Registers.YL;\n\t}\n\telse\n\tif (CheckIndex())\n\t{\n\t\tPullB(Registers.YL);\n\t\tSetZN(Registers.YL);\n\t\tOpenBus = Registers.YL;\n\t}\n\telse\n\t{\n\t\tPullW(Registers.Y.W);\n\t\tSetZN(Registers.Y.W);\n\t\tOpenBus = Registers.YH;\n\t}\n}\n\n/* Transfer Instructions *************************************************** */\n\n// TAX\nstatic void OpAAX1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.XL = Registers.AL;\n\tSetZN(Registers.XL);\n}\n\nstatic void OpAAX0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.X.W = Registers.A.W;\n\tSetZN(Registers.X.W);\n}\n\nstatic void OpAASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XL = Registers.AL;\n\t\tSetZN(Registers.XL);\n\t}\n\telse\n\t{\n\t\tRegisters.X.W = Registers.A.W;\n\t\tSetZN(Registers.X.W);\n\t}\n}\n\n// TAY\nstatic void OpA8X1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.YL = Registers.AL;\n\tSetZN(Registers.YL);\n}\n\nstatic void OpA8X0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.Y.W = Registers.A.W;\n\tSetZN(Registers.Y.W);\n}\n\nstatic void OpA8Slow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.YL = Registers.AL;\n\t\tSetZN(Registers.YL);\n\t}\n\telse\n\t{\n\t\tRegisters.Y.W = Registers.A.W;\n\t\tSetZN(Registers.Y.W);\n\t}\n}\n\n// TCD\nstatic void Op5B (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.D.W = Registers.A.W;\n\tSetZN(Registers.D.W);\n}\n\n// TCS\nstatic void Op1B (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.S.W = Registers.A.W;\n\tif (CheckEmulation())\n\t\tRegisters.SH = 1;\n}\n\n// TDC\nstatic void Op7B (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.A.W = Registers.D.W;\n\tSetZN(Registers.A.W);\n}\n\n// TSC\nstatic void Op3B (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.A.W = Registers.S.W;\n\tSetZN(Registers.A.W);\n}\n\n// TSX\nstatic void OpBAX1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.XL = Registers.SL;\n\tSetZN(Registers.XL);\n}\n\nstatic void OpBAX0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.X.W = Registers.S.W;\n\tSetZN(Registers.X.W);\n}\n\nstatic void OpBASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XL = Registers.SL;\n\t\tSetZN(Registers.XL);\n\t}\n\telse\n\t{\n\t\tRegisters.X.W = Registers.S.W;\n\t\tSetZN(Registers.X.W);\n\t}\n}\n\n// TXA\nstatic void Op8AM1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.AL = Registers.XL;\n\tSetZN(Registers.AL);\n}\n\nstatic void Op8AM0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.A.W = Registers.X.W;\n\tSetZN(Registers.A.W);\n}\n\nstatic void Op8ASlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckMemory())\n\t{\n\t\tRegisters.AL = Registers.XL;\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tRegisters.A.W = Registers.X.W;\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\n// TXS\nstatic void Op9A (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.S.W = Registers.X.W;\n\tif (CheckEmulation())\n\t\tRegisters.SH = 1;\n}\n\n// TXY\nstatic void Op9BX1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.YL = Registers.XL;\n\tSetZN(Registers.YL);\n}\n\nstatic void Op9BX0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.Y.W = Registers.X.W;\n\tSetZN(Registers.Y.W);\n}\n\nstatic void Op9BSlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.YL = Registers.XL;\n\t\tSetZN(Registers.YL);\n\t}\n\telse\n\t{\n\t\tRegisters.Y.W = Registers.X.W;\n\t\tSetZN(Registers.Y.W);\n\t}\n}\n\n// TYA\nstatic void Op98M1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.AL = Registers.YL;\n\tSetZN(Registers.AL);\n}\n\nstatic void Op98M0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.A.W = Registers.Y.W;\n\tSetZN(Registers.A.W);\n}\n\nstatic void Op98Slow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckMemory())\n\t{\n\t\tRegisters.AL = Registers.YL;\n\t\tSetZN(Registers.AL);\n\t}\n\telse\n\t{\n\t\tRegisters.A.W = Registers.Y.W;\n\t\tSetZN(Registers.A.W);\n\t}\n}\n\n// TYX\nstatic void OpBBX1 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.XL = Registers.YL;\n\tSetZN(Registers.XL);\n}\n\nstatic void OpBBX0 (void)\n{\n\tAddCycles(ONE_CYCLE);\n\tRegisters.X.W = Registers.Y.W;\n\tSetZN(Registers.X.W);\n}\n\nstatic void OpBBSlow (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XL = Registers.YL;\n\t\tSetZN(Registers.XL);\n\t}\n\telse\n\t{\n\t\tRegisters.X.W = Registers.Y.W;\n\t\tSetZN(Registers.X.W);\n\t}\n}\n\n/* XCE ********************************************************************* */\n\nstatic void OpFB (void)\n{\n\tAddCycles(ONE_CYCLE);\n\n\tuint8\tA1 = ICPU._Carry;\n\tuint8\tA2 = Registers.PH;\n\n\tICPU._Carry = A2 & 1;\n\tRegisters.PH = A1;\n\n\tif (CheckEmulation())\n\t{\n\t\tSetFlags(MemoryFlag | IndexFlag);\n\t\tRegisters.SH = 1;\n\t#ifdef DEBUGGER\n\t\tmissing.emulate6502 = 1;\n\t#endif\n\t}\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XH = 0;\n\t\tRegisters.YH = 0;\n\t}\n\n\tS9xFixCycles();\n}\n\n/* BRK ********************************************************************* */\n\nstatic void Op00 (void)\n{\n#ifdef DEBUGGER\n\tif (CPU.Flags & TRACE_FLAG)\n\t\tS9xTraceMessage(\"*** BRK\");\n#endif\n\n\tAddCycles(CPU.MemSpeed);\n\n\tuint16\taddr;\n\n\tif (!CheckEmulation())\n\t{\n\t\tPushB(Registers.PB);\n\t\tPushW(Registers.PCw + 1);\n\t\tS9xPackStatus();\n\t\tPushB(Registers.PL);\n\t\tOpenBus = Registers.PL;\n\t\tClearDecimal();\n\t\tSetIRQ();\n\n\t\taddr = S9xGetWord(0xFFE6);\n\t}\n\telse\n\t{\n\t\tPushWE(Registers.PCw + 1);\n\t\tS9xPackStatus();\n\t\tPushBE(Registers.PL);\n\t\tOpenBus = Registers.PL;\n\t\tClearDecimal();\n\t\tSetIRQ();\n\n\t\taddr = S9xGetWord(0xFFFE);\n\t}\n\n\tS9xSetPCBase(addr);\n\tOpenBus = addr >> 8;\n}\n\n/* IRQ ********************************************************************* */\n\nvoid S9xOpcode_IRQ (void)\n{\n#ifdef DEBUGGER\n\tif (CPU.Flags & TRACE_FLAG)\n\t#ifdef SA1_OPCODES\n\t\tS9xTraceMessage(\"*** SA1 IRQ\");\n\t#else\n\t\tS9xTraceMessage(\"*** IRQ\");\n\t#endif\n#endif\n\n\t// IRQ and NMI do an opcode fetch as their first \"IO\" cycle.\n\tAddCycles(CPU.MemSpeed + ONE_CYCLE);\n\n\tif (!CheckEmulation())\n\t{\n\t\tPushB(Registers.PB);\n\t\tPushW(Registers.PCw);\n\t\tS9xPackStatus();\n\t\tPushB(Registers.PL);\n\t\tOpenBus = Registers.PL;\n\t\tClearDecimal();\n\t\tSetIRQ();\n\n\t#ifdef SA1_OPCODES\n\t\tOpenBus = Memory.FillRAM[0x2208];\n\t\tAddCycles(2 * ONE_CYCLE);\n\t\tS9xSA1SetPCBase(Memory.FillRAM[0x2207] | (Memory.FillRAM[0x2208] << 8));\n\t#else\n\t\tif (Settings.SA1 && (Memory.FillRAM[0x2209] & 0x40))\n\t\t{\n\t\t\tOpenBus = Memory.FillRAM[0x220f];\n\t\t\tAddCycles(2 * ONE_CYCLE);\n\t\t\tS9xSetPCBase(Memory.FillRAM[0x220e] | (Memory.FillRAM[0x220f] << 8));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\taddr = S9xGetWord(0xFFEE);\n\t\t\tOpenBus = addr >> 8;\n\t\t\tS9xSetPCBase(addr);\n\t\t}\n\t#endif\n\t}\n\telse\n\t{\n\t\tPushWE(Registers.PCw);\n\t\tS9xPackStatus();\n\t\tPushBE(Registers.PL);\n\t\tOpenBus = Registers.PL;\n\t\tClearDecimal();\n\t\tSetIRQ();\n\n\t#ifdef SA1_OPCODES\n\t\tOpenBus = Memory.FillRAM[0x2208];\n\t\tAddCycles(2 * ONE_CYCLE);\n\t\tS9xSA1SetPCBase(Memory.FillRAM[0x2207] | (Memory.FillRAM[0x2208] << 8));\n\t#else\n\t\tif (Settings.SA1 && (Memory.FillRAM[0x2209] & 0x40))\n\t\t{\n\t\t\tOpenBus = Memory.FillRAM[0x220f];\n\t\t\tAddCycles(2 * ONE_CYCLE);\n\t\t\tS9xSetPCBase(Memory.FillRAM[0x220e] | (Memory.FillRAM[0x220f] << 8));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\taddr = S9xGetWord(0xFFFE);\n\t\t\tOpenBus = addr >> 8;\n\t\t\tS9xSetPCBase(addr);\n\t\t}\n\t#endif\n\t}\n}\n\n/* NMI ********************************************************************* */\n\nvoid S9xOpcode_NMI (void)\n{\n#ifdef DEBUGGER\n\tif (CPU.Flags & TRACE_FLAG)\n\t#ifdef SA1_OPCODES\n\t\tS9xTraceMessage(\"*** SA1 NMI\");\n\t#else\n\t\tS9xTraceMessage(\"*** NMI\");\n\t#endif\n#endif\n\n\t// IRQ and NMI do an opcode fetch as their first \"IO\" cycle.\n\tAddCycles(CPU.MemSpeed + ONE_CYCLE);\n\n\tif (!CheckEmulation())\n\t{\n\t\tPushB(Registers.PB);\n\t\tPushW(Registers.PCw);\n\t\tS9xPackStatus();\n\t\tPushB(Registers.PL);\n\t\tOpenBus = Registers.PL;\n\t\tClearDecimal();\n\t\tSetIRQ();\n\n\t#ifdef SA1_OPCODES\n\t\tOpenBus = Memory.FillRAM[0x2206];\n\t\tAddCycles(2 * ONE_CYCLE);\n\t\tS9xSA1SetPCBase(Memory.FillRAM[0x2205] | (Memory.FillRAM[0x2206] << 8));\n\t#else\n\t\tif (Settings.SA1 && (Memory.FillRAM[0x2209] & 0x10))\n\t\t{\n\t\t\tOpenBus = Memory.FillRAM[0x220d];\n\t\t\tAddCycles(2 * ONE_CYCLE);\n\t\t\tS9xSetPCBase(Memory.FillRAM[0x220c] | (Memory.FillRAM[0x220d] << 8));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\taddr = S9xGetWord(0xFFEA);\n\t\t\tOpenBus = addr >> 8;\n\t\t\tS9xSetPCBase(addr);\n\t\t}\n\t#endif\n\t}\n\telse\n\t{\n\t\tPushWE(Registers.PCw);\n\t\tS9xPackStatus();\n\t\tPushBE(Registers.PL);\n\t\tOpenBus = Registers.PL;\n\t\tClearDecimal();\n\t\tSetIRQ();\n\n\t#ifdef SA1_OPCODES\n\t\tOpenBus = Memory.FillRAM[0x2206];\n\t\tAddCycles(2 * ONE_CYCLE);\n\t\tS9xSA1SetPCBase(Memory.FillRAM[0x2205] | (Memory.FillRAM[0x2206] << 8));\n\t#else\n\t\tif (Settings.SA1 && (Memory.FillRAM[0x2209] & 0x10))\n\t\t{\n\t\t\tOpenBus = Memory.FillRAM[0x220d];\n\t\t\tAddCycles(2 * ONE_CYCLE);\n\t\t\tS9xSetPCBase(Memory.FillRAM[0x220c] | (Memory.FillRAM[0x220d] << 8));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint16\taddr = S9xGetWord(0xFFFA);\n\t\t\tOpenBus = addr >> 8;\n\t\t\tS9xSetPCBase(addr);\n\t\t}\n\t#endif\n\t}\n}\n\n/* COP ********************************************************************* */\n\nstatic void Op02 (void)\n{\n#ifdef DEBUGGER\n\tif (CPU.Flags & TRACE_FLAG)\n\t\tS9xTraceMessage(\"*** COP\");\n#endif\n\n\tAddCycles(CPU.MemSpeed);\n\n\tuint16\taddr;\n\n\tif (!CheckEmulation())\n\t{\n\t\tPushB(Registers.PB);\n\t\tPushW(Registers.PCw + 1);\n\t\tS9xPackStatus();\n\t\tPushB(Registers.PL);\n\t\tOpenBus = Registers.PL;\n\t\tClearDecimal();\n\t\tSetIRQ();\n\n\t\taddr = S9xGetWord(0xFFE4);\n\t}\n\telse\n\t{\n\t\tPushWE(Registers.PCw + 1);\n\t\tS9xPackStatus();\n\t\tPushBE(Registers.PL);\n\t\tOpenBus = Registers.PL;\n\t\tClearDecimal();\n\t\tSetIRQ();\n\n\t\taddr = S9xGetWord(0xFFF4);\n\t}\n\n\tS9xSetPCBase(addr);\n\tOpenBus = addr >> 8;\n}\n\n/* JML ********************************************************************* */\n\nstatic void OpDC (void)\n{\n\tS9xSetPCBase(AbsoluteIndirectLong(JUMP));\n#ifdef SA1_OPCODES\n\tAddCycles(ONE_CYCLE);\n#endif\n}\n\nstatic void OpDCSlow (void)\n{\n\tS9xSetPCBase(AbsoluteIndirectLongSlow(JUMP));\n#ifdef SA1_OPCODES\n\tAddCycles(ONE_CYCLE);\n#endif\n}\n\nstatic void Op5C (void)\n{\n\tS9xSetPCBase(AbsoluteLong(JUMP));\n#ifdef SA1_OPCODES\n\tAddCycles(ONE_CYCLE);\n#endif\n}\n\nstatic void Op5CSlow (void)\n{\n\tS9xSetPCBase(AbsoluteLongSlow(JUMP));\n#ifdef SA1_OPCODES\n\tAddCycles(ONE_CYCLE);\n#endif\n}\n\n/* JMP ********************************************************************* */\n\nstatic void Op4C (void)\n{\n\tS9xSetPCBase(ICPU.ShiftedPB + ((uint16) Absolute(JUMP)));\n}\n\nstatic void Op4CSlow (void)\n{\n\tS9xSetPCBase(ICPU.ShiftedPB + ((uint16) AbsoluteSlow(JUMP)));\n}\n\nstatic void Op6C (void)\n{\n\tS9xSetPCBase(ICPU.ShiftedPB + ((uint16) AbsoluteIndirect(JUMP)));\n}\n\nstatic void Op6CSlow (void)\n{\n\tS9xSetPCBase(ICPU.ShiftedPB + ((uint16) AbsoluteIndirectSlow(JUMP)));\n}\n\nstatic void Op7C (void)\n{\n\tS9xSetPCBase(ICPU.ShiftedPB + ((uint16) AbsoluteIndexedIndirect(JUMP)));\n}\n\nstatic void Op7CSlow (void)\n{\n\tS9xSetPCBase(ICPU.ShiftedPB + ((uint16) AbsoluteIndexedIndirectSlow(JUMP)));\n}\n\n/* JSL/RTL ***************************************************************** */\n\nstatic void Op22E1 (void)\n{\n\t// Note: JSL is a new instruction,\n\t// and so doesn't respect the emu-mode stack bounds.\n\tuint32\taddr = AbsoluteLong(JSR);\n\tAddCycles(ONE_CYCLE);\n\tPushB(Registers.PB);\n\tPushW(Registers.PCw - 1);\n\tRegisters.SH = 1;\n\tS9xSetPCBase(addr);\n}\n\nstatic void Op22E0 (void)\n{\n\tuint32\taddr = AbsoluteLong(JSR);\n\tAddCycles(ONE_CYCLE);\n\tPushB(Registers.PB);\n\tPushW(Registers.PCw - 1);\n\tS9xSetPCBase(addr);\n}\n\nstatic void Op22Slow (void)\n{\n\tuint32\taddr = AbsoluteLongSlow(JSR);\n\tAddCycles(ONE_CYCLE);\n\tPushB(Registers.PB);\n\tPushW(Registers.PCw - 1);\n\tif (CheckEmulation())\n\t\tRegisters.SH = 1;\n\tS9xSetPCBase(addr);\n}\n\nstatic void Op6BE1 (void)\n{\n\t// Note: RTL is a new instruction,\n\t// and so doesn't respect the emu-mode stack bounds.\n\tAddCycles(TWO_CYCLES);\n\tPullW(Registers.PCw);\n\tPullB(Registers.PB);\n\tRegisters.SH = 1;\n\tRegisters.PCw++;\n\tS9xSetPCBase(Registers.PBPC);\n}\n\nstatic void Op6BE0 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullW(Registers.PCw);\n\tPullB(Registers.PB);\n\tRegisters.PCw++;\n\tS9xSetPCBase(Registers.PBPC);\n}\n\nstatic void Op6BSlow (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullW(Registers.PCw);\n\tPullB(Registers.PB);\n\tif (CheckEmulation())\n\t\tRegisters.SH = 1;\n\tRegisters.PCw++;\n\tS9xSetPCBase(Registers.PBPC);\n}\n\n/* JSR/RTS ***************************************************************** */\n\nstatic void Op20E1 (void)\n{\n\tuint16\taddr = Absolute(JSR);\n\tAddCycles(ONE_CYCLE);\n\tPushWE(Registers.PCw - 1);\n\tS9xSetPCBase(ICPU.ShiftedPB + addr);\n}\n\nstatic void Op20E0 (void)\n{\n\tuint16\taddr = Absolute(JSR);\n\tAddCycles(ONE_CYCLE);\n\tPushW(Registers.PCw - 1);\n\tS9xSetPCBase(ICPU.ShiftedPB + addr);\n}\n\nstatic void Op20Slow (void)\n{\n\tuint16\taddr = AbsoluteSlow(JSR);\n\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckEmulation())\n\t{\n\t\tPushWE(Registers.PCw - 1);\n\t}\n\telse\n\t{\n\t\tPushW(Registers.PCw - 1);\n\t}\n\n\tS9xSetPCBase(ICPU.ShiftedPB + addr);\n}\n\nstatic void OpFCE1 (void)\n{\n\t// Note: JSR (a,X) is a new instruction,\n\t// and so doesn't respect the emu-mode stack bounds.\n\tuint16\taddr = AbsoluteIndexedIndirect(JSR);\n\tPushW(Registers.PCw - 1);\n\tRegisters.SH = 1;\n\tS9xSetPCBase(ICPU.ShiftedPB + addr);\n}\n\nstatic void OpFCE0 (void)\n{\n\tuint16\taddr = AbsoluteIndexedIndirect(JSR);\n\tPushW(Registers.PCw - 1);\n\tS9xSetPCBase(ICPU.ShiftedPB + addr);\n}\n\nstatic void OpFCSlow (void)\n{\n\tuint16\taddr = AbsoluteIndexedIndirectSlow(JSR);\n\tPushW(Registers.PCw - 1);\n\tif (CheckEmulation())\n\t\tRegisters.SH = 1;\n\tS9xSetPCBase(ICPU.ShiftedPB + addr);\n}\n\nstatic void Op60E1 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullWE(Registers.PCw);\n\tAddCycles(ONE_CYCLE);\n\tRegisters.PCw++;\n\tS9xSetPCBase(Registers.PBPC);\n}\n\nstatic void Op60E0 (void)\n{\n\tAddCycles(TWO_CYCLES);\n\tPullW(Registers.PCw);\n\tAddCycles(ONE_CYCLE);\n\tRegisters.PCw++;\n\tS9xSetPCBase(Registers.PBPC);\n}\n\nstatic void Op60Slow (void)\n{\n\tAddCycles(TWO_CYCLES);\n\n\tif (CheckEmulation())\n\t{\n\t\tPullWE(Registers.PCw);\n\t}\n\telse\n\t{\n\t\tPullW(Registers.PCw);\n\t}\n\n\tAddCycles(ONE_CYCLE);\n\tRegisters.PCw++;\n\tS9xSetPCBase(Registers.PBPC);\n}\n\n/* MVN/MVP ***************************************************************** */\n\nstatic void Op54X1 (void)\n{\n\tuint32\tSrcBank;\n\n\tRegisters.DB = Immediate8(NONE);\n\tICPU.ShiftedDB = Registers.DB << 16;\n\tOpenBus = SrcBank = Immediate8(NONE);\n\n\tS9xSetByte(OpenBus = S9xGetByte((SrcBank << 16) + Registers.X.W), ICPU.ShiftedDB + Registers.Y.W);\n\n\tRegisters.XL++;\n\tRegisters.YL++;\n\tRegisters.A.W--;\n\tif (Registers.A.W != 0xffff)\n\t\tRegisters.PCw -= 3;\n\n\tAddCycles(TWO_CYCLES);\n}\n\nstatic void Op54X0 (void)\n{\n\tuint32\tSrcBank;\n\n\tRegisters.DB = Immediate8(NONE);\n\tICPU.ShiftedDB = Registers.DB << 16;\n\tOpenBus = SrcBank = Immediate8(NONE);\n\n\tS9xSetByte(OpenBus = S9xGetByte((SrcBank << 16) + Registers.X.W), ICPU.ShiftedDB + Registers.Y.W);\n\n\tRegisters.X.W++;\n\tRegisters.Y.W++;\n\tRegisters.A.W--;\n\tif (Registers.A.W != 0xffff)\n\t\tRegisters.PCw -= 3;\n\n\tAddCycles(TWO_CYCLES);\n}\n\nstatic void Op54Slow (void)\n{\n\tuint32\tSrcBank;\n\n\tOpenBus = Registers.DB = Immediate8Slow(NONE);\n\tICPU.ShiftedDB = Registers.DB << 16;\n\tOpenBus = SrcBank = Immediate8Slow(NONE);\n\n\tS9xSetByte(OpenBus = S9xGetByte((SrcBank << 16) + Registers.X.W), ICPU.ShiftedDB + Registers.Y.W);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XL++;\n\t\tRegisters.YL++;\n\t}\n\telse\n\t{\n\t\tRegisters.X.W++;\n\t\tRegisters.Y.W++;\n\t}\n\n\tRegisters.A.W--;\n\tif (Registers.A.W != 0xffff)\n\t\tRegisters.PCw -= 3;\n\n\tAddCycles(TWO_CYCLES);\n}\n\nstatic void Op44X1 (void)\n{\n\tuint32\tSrcBank;\n\n\tRegisters.DB = Immediate8(NONE);\n\tICPU.ShiftedDB = Registers.DB << 16;\n\tOpenBus = SrcBank = Immediate8(NONE);\n\n\tS9xSetByte(OpenBus = S9xGetByte((SrcBank << 16) + Registers.X.W), ICPU.ShiftedDB + Registers.Y.W);\n\n\tRegisters.XL--;\n\tRegisters.YL--;\n\tRegisters.A.W--;\n\tif (Registers.A.W != 0xffff)\n\t\tRegisters.PCw -= 3;\n\n\tAddCycles(TWO_CYCLES);\n}\n\nstatic void Op44X0 (void)\n{\n\tuint32\tSrcBank;\n\n\tRegisters.DB = Immediate8(NONE);\n\tICPU.ShiftedDB = Registers.DB << 16;\n\tOpenBus = SrcBank = Immediate8(NONE);\n\n\tS9xSetByte(OpenBus = S9xGetByte((SrcBank << 16) + Registers.X.W), ICPU.ShiftedDB + Registers.Y.W);\n\n\tRegisters.X.W--;\n\tRegisters.Y.W--;\n\tRegisters.A.W--;\n\tif (Registers.A.W != 0xffff)\n\t\tRegisters.PCw -= 3;\n\n\tAddCycles(TWO_CYCLES);\n}\n\nstatic void Op44Slow (void)\n{\n\tuint32\tSrcBank;\n\n\tOpenBus = Registers.DB = Immediate8Slow(NONE);\n\tICPU.ShiftedDB = Registers.DB << 16;\n\tOpenBus = SrcBank = Immediate8Slow(NONE);\n\n\tS9xSetByte(OpenBus = S9xGetByte((SrcBank << 16) + Registers.X.W), ICPU.ShiftedDB + Registers.Y.W);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XL--;\n\t\tRegisters.YL--;\n\t}\n\telse\n\t{\n\t\tRegisters.X.W--;\n\t\tRegisters.Y.W--;\n\t}\n\n\tRegisters.A.W--;\n\tif (Registers.A.W != 0xffff)\n\t\tRegisters.PCw -= 3;\n\n\tAddCycles(TWO_CYCLES);\n}\n\n/* REP/SEP ***************************************************************** */\n\nstatic void OpC2 (void)\n{\n\tuint8\tWork8 = ~Immediate8(READ);\n\tRegisters.PL &= Work8;\n\tICPU._Carry &= Work8;\n\tICPU._Overflow &= (Work8 >> 6);\n\tICPU._Negative &= Work8;\n\tICPU._Zero |= ~Work8 & Zero;\n\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckEmulation())\n\t{\n\t\tSetFlags(MemoryFlag | IndexFlag);\n\t#ifdef DEBUGGER\n\t\tmissing.emulate6502 = 1;\n\t#endif\n\t}\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XH = 0;\n\t\tRegisters.YH = 0;\n\t}\n\n\tS9xFixCycles();\n\tCHECK_FOR_IRQ();\n}\n\nstatic void OpC2Slow (void)\n{\n\tuint8\tWork8 = ~Immediate8Slow(READ);\n\tRegisters.PL &= Work8;\n\tICPU._Carry &= Work8;\n\tICPU._Overflow &= (Work8 >> 6);\n\tICPU._Negative &= Work8;\n\tICPU._Zero |= ~Work8 & Zero;\n\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckEmulation())\n\t{\n\t\tSetFlags(MemoryFlag | IndexFlag);\n\t#ifdef DEBUGGER\n\t\tmissing.emulate6502 = 1;\n\t#endif\n\t}\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XH = 0;\n\t\tRegisters.YH = 0;\n\t}\n\n\tS9xFixCycles();\n\tCHECK_FOR_IRQ();\n}\n\nstatic void OpE2 (void)\n{\n\tuint8\tWork8 = Immediate8(READ);\n\tRegisters.PL |= Work8;\n\tICPU._Carry |= Work8 & 1;\n\tICPU._Overflow |= (Work8 >> 6) & 1;\n\tICPU._Negative |= Work8;\n\tif (Work8 & Zero)\n\t\tICPU._Zero = 0;\n\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckEmulation())\n\t{\n\t\tSetFlags(MemoryFlag | IndexFlag);\n\t#ifdef DEBUGGER\n\t\tmissing.emulate6502 = 1;\n\t#endif\n\t}\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XH = 0;\n\t\tRegisters.YH = 0;\n\t}\n\n\tS9xFixCycles();\n}\n\nstatic void OpE2Slow (void)\n{\n\tuint8\tWork8 = Immediate8Slow(READ);\n\tRegisters.PL |= Work8;\n\tICPU._Carry |= Work8 & 1;\n\tICPU._Overflow |= (Work8 >> 6) & 1;\n\tICPU._Negative |= Work8;\n\tif (Work8 & Zero)\n\t\tICPU._Zero = 0;\n\n\tAddCycles(ONE_CYCLE);\n\n\tif (CheckEmulation())\n\t{\n\t\tSetFlags(MemoryFlag | IndexFlag);\n\t#ifdef DEBUGGER\n\t\tmissing.emulate6502 = 1;\n\t#endif\n\t}\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XH = 0;\n\t\tRegisters.YH = 0;\n\t}\n\n\tS9xFixCycles();\n}\n\n/* XBA ********************************************************************* */\n\nstatic void OpEB (void)\n{\n\tuint8\tWork8 = Registers.AL;\n\tRegisters.AL = Registers.AH;\n\tRegisters.AH = Work8;\n\tSetZN(Registers.AL);\n\tAddCycles(TWO_CYCLES);\n}\n\n/* RTI ********************************************************************* */\n\nstatic void Op40Slow (void)\n{\n\tAddCycles(TWO_CYCLES);\n\n\tif (!CheckEmulation())\n\t{\n\t\tPullB(Registers.PL);\n\t\tS9xUnpackStatus();\n\t\tPullW(Registers.PCw);\n\t\tPullB(Registers.PB);\n\t\tOpenBus = Registers.PB;\n\t\tICPU.ShiftedPB = Registers.PB << 16;\n\t}\n\telse\n\t{\n\t\tPullBE(Registers.PL);\n\t\tS9xUnpackStatus();\n\t\tPullWE(Registers.PCw);\n\t\tOpenBus = Registers.PCh;\n\t\tSetFlags(MemoryFlag | IndexFlag);\n\t#ifdef DEBUGGER\n\t\tmissing.emulate6502 = 1;\n\t#endif\n\t}\n\n\tS9xSetPCBase(Registers.PBPC);\n\n\tif (CheckIndex())\n\t{\n\t\tRegisters.XH = 0;\n\t\tRegisters.YH = 0;\n\t}\n\n\tS9xFixCycles();\n\tCHECK_FOR_IRQ();\n}\n\n/* STP/WAI ***************************************************************** */\n\n// WAI\nstatic void OpCB (void)\n{\n#ifdef SA1_OPCODES\n\tSA1.WaitingForInterrupt = TRUE;\n\tRegisters.PCw--;\n\tAddCycles(TWO_CYCLES);\n#else\n\tCPU.WaitingForInterrupt = TRUE;\n\n\tRegisters.PCw--;\n\tAddCycles(ONE_CYCLE);\n#endif\n}\n\n// STP\nstatic void OpDB (void)\n{\n\tRegisters.PCw--;\n\tCPU.Flags |= DEBUG_MODE_FLAG | HALTED_FLAG;\n}\n\n/* WDM (Reserved S9xOpcode) ************************************************ */\n\n#ifdef DEBUGGER\nextern FILE\t*trace, *trace2;\n#endif\n\nstatic void Op42 (void)\n{\n#ifdef DEBUGGER\n\tuint8\tbyte = (uint8) S9xGetWord(Registers.PBPC);\n#else\n\tS9xGetWord(Registers.PBPC);\n#endif\n\tRegisters.PCw++;\n\n#ifdef DEBUGGER\n\t// Hey, let's use this to trigger debug modes.\n\tswitch (byte)\n\t{\n\t\tcase 0xdb: // \"STP\" = Enter debug mode\n\t\t\tCPU.Flags |= DEBUG_MODE_FLAG;\n\t\t\tbreak;\n\n\t#ifndef SA1_OPCODES\n\t\tcase 0xe2: // \"SEP\" = Trace on\n\t\t\tif (!(CPU.Flags & TRACE_FLAG))\n\t\t\t{\n\t\t\t\tchar\tbuf[25];\n\t\t\t\tCPU.Flags |= TRACE_FLAG;\n\t\t\t\tsnprintf(buf, 25, \"WDM trace on at $%02X:%04X\", Registers.PB, Registers.PCw);\n\t\t\t\tS9xMessage(S9X_DEBUG, S9X_DEBUG_OUTPUT, buf);\n\t\t\t\tif (trace != NULL)\n\t\t\t\t\tfclose(trace);\n\t\t\t\tENSURE_TRACE_OPEN(trace, \"WDMtrace.log\", \"ab\")\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0xc2: // \"REP\" = Trace off\n\t\t\tif (CPU.Flags & TRACE_FLAG)\n\t\t\t{\n\t\t\t\tchar\tbuf[26];\n\t\t\t\tCPU.Flags &= ~TRACE_FLAG;\n\t\t\t\tsnprintf(buf, 26, \"WDM trace off at $%02X:%04X\", Registers.PB, Registers.PCw);\n\t\t\t\tS9xMessage(S9X_DEBUG, S9X_DEBUG_OUTPUT, buf);\n\t\t\t\tif (trace != NULL)\n\t\t\t\t\tfclose(trace);\n\t\t\t\ttrace = NULL;\n\t\t\t}\n\n\t\t\tbreak;\n\t#endif\n\n\t\tcase 0x42: // \"WDM\" = Snapshot\n        {\n            char\ttmp[PATH_MAX + 1];\n            SplitPath split = splitpath(Memory.ROMFilename);\n\n            snprintf(tmp, PATH_MAX, \"%s-%06X\", split.stem.c_str(), Registers.PBPC & 0xffffff);\n            std::string filename = makepath(split.dir, S9xGetDirectory(SNAPSHOT_DIR), tmp, \".wdm\");\n\n            sprintf(tmp, \"WDM Snapshot at $%02X:%04X: %s\", Registers.PB, Registers.PCw, filename.c_str());\n            S9xMessage(S9X_DEBUG, S9X_DEBUG_OUTPUT, tmp);\n            S9xFreezeGame(filename.c_str());\n\n            break;\n        }\n\t\tdefault:\n\t\t\tbreak;\n\t}\n#endif\n}\n\n/* CPU-S9xOpcodes Definitions ************************************************/\n\nstruct SOpcodes S9xOpcodesM1X1[256] =\n{\n\t{ Op00 },        { Op01E0M1 },    { Op02 },        { Op03M1 },      { Op04M1 },\n\t{ Op05M1 },      { Op06M1 },      { Op07M1 },      { Op08E0 },      { Op09M1 },\n\t{ Op0AM1 },      { Op0BE0 },      { Op0CM1 },      { Op0DM1 },      { Op0EM1 },\n\t{ Op0FM1 },      { Op10E0 },      { Op11E0M1X1 },  { Op12E0M1 },    { Op13M1 },\n\t{ Op14M1 },      { Op15E0M1 },    { Op16E0M1 },    { Op17M1 },      { Op18 },\n\t{ Op19M1X1 },    { Op1AM1 },      { Op1B },        { Op1CM1 },      { Op1DM1X1 },\n\t{ Op1EM1X1 },    { Op1FM1 },      { Op20E0 },      { Op21E0M1 },    { Op22E0 },\n\t{ Op23M1 },      { Op24M1 },      { Op25M1 },      { Op26M1 },      { Op27M1 },\n\t{ Op28E0 },      { Op29M1 },      { Op2AM1 },      { Op2BE0 },      { Op2CM1 },\n\t{ Op2DM1 },      { Op2EM1 },      { Op2FM1 },      { Op30E0 },      { Op31E0M1X1 },\n\t{ Op32E0M1 },    { Op33M1 },      { Op34E0M1 },    { Op35E0M1 },    { Op36E0M1 },\n\t{ Op37M1 },      { Op38 },        { Op39M1X1 },    { Op3AM1 },      { Op3B },\n\t{ Op3CM1X1 },    { Op3DM1X1 },    { Op3EM1X1 },    { Op3FM1 },      { Op40Slow },\n\t{ Op41E0M1 },    { Op42 },        { Op43M1 },      { Op44X1 },      { Op45M1 },\n\t{ Op46M1 },      { Op47M1 },      { Op48E0M1 },    { Op49M1 },      { Op4AM1 },\n\t{ Op4BE0 },      { Op4C },        { Op4DM1 },      { Op4EM1 },      { Op4FM1 },\n\t{ Op50E0 },      { Op51E0M1X1 },  { Op52E0M1 },    { Op53M1 },      { Op54X1 },\n\t{ Op55E0M1 },    { Op56E0M1 },    { Op57M1 },      { Op58 },        { Op59M1X1 },\n\t{ Op5AE0X1 },    { Op5B },        { Op5C },        { Op5DM1X1 },    { Op5EM1X1 },\n\t{ Op5FM1 },      { Op60E0 },      { Op61E0M1 },    { Op62E0 },      { Op63M1 },\n\t{ Op64M1 },      { Op65M1 },      { Op66M1 },      { Op67M1 },      { Op68E0M1 },\n\t{ Op69M1 },      { Op6AM1 },      { Op6BE0 },      { Op6C },        { Op6DM1 },\n\t{ Op6EM1 },      { Op6FM1 },      { Op70E0 },      { Op71E0M1X1 },  { Op72E0M1 },\n\t{ Op73M1 },      { Op74E0M1 },    { Op75E0M1 },    { Op76E0M1 },    { Op77M1 },\n\t{ Op78 },        { Op79M1X1 },    { Op7AE0X1 },    { Op7B },        { Op7C },\n\t{ Op7DM1X1 },    { Op7EM1X1 },    { Op7FM1 },      { Op80E0 },      { Op81E0M1 },\n\t{ Op82 },        { Op83M1 },      { Op84X1 },      { Op85M1 },      { Op86X1 },\n\t{ Op87M1 },      { Op88X1 },      { Op89M1 },      { Op8AM1 },      { Op8BE0 },\n\t{ Op8CX1 },      { Op8DM1 },      { Op8EX1 },      { Op8FM1 },      { Op90E0 },\n\t{ Op91E0M1X1 },  { Op92E0M1 },    { Op93M1 },      { Op94E0X1 },    { Op95E0M1 },\n\t{ Op96E0X1 },    { Op97M1 },      { Op98M1 },      { Op99M1X1 },    { Op9A },\n\t{ Op9BX1 },      { Op9CM1 },      { Op9DM1X1 },    { Op9EM1X1 },    { Op9FM1 },\n\t{ OpA0X1 },      { OpA1E0M1 },    { OpA2X1 },      { OpA3M1 },      { OpA4X1 },\n\t{ OpA5M1 },      { OpA6X1 },      { OpA7M1 },      { OpA8X1 },      { OpA9M1 },\n\t{ OpAAX1 },      { OpABE0 },      { OpACX1 },      { OpADM1 },      { OpAEX1 },\n\t{ OpAFM1 },      { OpB0E0 },      { OpB1E0M1X1 },  { OpB2E0M1 },    { OpB3M1 },\n\t{ OpB4E0X1 },    { OpB5E0M1 },    { OpB6E0X1 },    { OpB7M1 },      { OpB8 },\n\t{ OpB9M1X1 },    { OpBAX1 },      { OpBBX1 },      { OpBCX1 },      { OpBDM1X1 },\n\t{ OpBEX1 },      { OpBFM1 },      { OpC0X1 },      { OpC1E0M1 },    { OpC2 },\n\t{ OpC3M1 },      { OpC4X1 },      { OpC5M1 },      { OpC6M1 },      { OpC7M1 },\n\t{ OpC8X1 },      { OpC9M1 },      { OpCAX1 },      { OpCB },        { OpCCX1 },\n\t{ OpCDM1 },      { OpCEM1 },      { OpCFM1 },      { OpD0E0 },      { OpD1E0M1X1 },\n\t{ OpD2E0M1 },    { OpD3M1 },      { OpD4E0 },      { OpD5E0M1 },    { OpD6E0M1 },\n\t{ OpD7M1 },      { OpD8 },        { OpD9M1X1 },    { OpDAE0X1 },    { OpDB },\n\t{ OpDC },        { OpDDM1X1 },    { OpDEM1X1 },    { OpDFM1 },      { OpE0X1 },\n\t{ OpE1E0M1 },    { OpE2 },        { OpE3M1 },      { OpE4X1 },      { OpE5M1 },\n\t{ OpE6M1 },      { OpE7M1 },      { OpE8X1 },      { OpE9M1 },      { OpEA },\n\t{ OpEB },        { OpECX1 },      { OpEDM1 },      { OpEEM1 },      { OpEFM1 },\n\t{ OpF0E0 },      { OpF1E0M1X1 },  { OpF2E0M1 },    { OpF3M1 },      { OpF4E0 },\n\t{ OpF5E0M1 },    { OpF6E0M1 },    { OpF7M1 },      { OpF8 },        { OpF9M1X1 },\n\t{ OpFAE0X1 },    { OpFB },        { OpFCE0 },      { OpFDM1X1 },    { OpFEM1X1 },\n\t{ OpFFM1 }\n};\n\nstruct SOpcodes S9xOpcodesE1[256] =\n{\n\t{ Op00 },        { Op01E1 },      { Op02 },        { Op03M1 },      { Op04M1 },\n\t{ Op05M1 },      { Op06M1 },      { Op07M1 },      { Op08E1 },      { Op09M1 },\n\t{ Op0AM1 },      { Op0BE1 },      { Op0CM1 },      { Op0DM1 },      { Op0EM1 },\n\t{ Op0FM1 },      { Op10E1 },      { Op11E1 },      { Op12E1 },      { Op13M1 },\n\t{ Op14M1 },      { Op15E1 },      { Op16E1 },      { Op17M1 },      { Op18 },\n\t{ Op19M1X1 },    { Op1AM1 },      { Op1B },        { Op1CM1 },      { Op1DM1X1 },\n\t{ Op1EM1X1 },    { Op1FM1 },      { Op20E1 },      { Op21E1 },      { Op22E1 },\n\t{ Op23M1 },      { Op24M1 },      { Op25M1 },      { Op26M1 },      { Op27M1 },\n\t{ Op28E1 },      { Op29M1 },      { Op2AM1 },      { Op2BE1 },      { Op2CM1 },\n\t{ Op2DM1 },      { Op2EM1 },      { Op2FM1 },      { Op30E1 },      { Op31E1 },\n\t{ Op32E1 },      { Op33M1 },      { Op34E1 },      { Op35E1 },      { Op36E1 },\n\t{ Op37M1 },      { Op38 },        { Op39M1X1 },    { Op3AM1 },      { Op3B },\n\t{ Op3CM1X1 },    { Op3DM1X1 },    { Op3EM1X1 },    { Op3FM1 },      { Op40Slow },\n\t{ Op41E1 },      { Op42 },        { Op43M1 },      { Op44X1 },      { Op45M1 },\n\t{ Op46M1 },      { Op47M1 },      { Op48E1 },      { Op49M1 },      { Op4AM1 },\n\t{ Op4BE1 },      { Op4C },        { Op4DM1 },      { Op4EM1 },      { Op4FM1 },\n\t{ Op50E1 },      { Op51E1 },      { Op52E1 },      { Op53M1 },      { Op54X1 },\n\t{ Op55E1 },      { Op56E1 },      { Op57M1 },      { Op58 },        { Op59M1X1 },\n\t{ Op5AE1 },      { Op5B },        { Op5C },        { Op5DM1X1 },    { Op5EM1X1 },\n\t{ Op5FM1 },      { Op60E1 },      { Op61E1 },      { Op62E1 },      { Op63M1 },\n\t{ Op64M1 },      { Op65M1 },      { Op66M1 },      { Op67M1 },      { Op68E1 },\n\t{ Op69M1 },      { Op6AM1 },      { Op6BE1 },      { Op6C },        { Op6DM1 },\n\t{ Op6EM1 },      { Op6FM1 },      { Op70E1 },      { Op71E1 },      { Op72E1 },\n\t{ Op73M1 },      { Op74E1 },      { Op75E1 },      { Op76E1 },      { Op77M1 },\n\t{ Op78 },        { Op79M1X1 },    { Op7AE1 },      { Op7B },        { Op7C },\n\t{ Op7DM1X1 },    { Op7EM1X1 },    { Op7FM1 },      { Op80E1 },      { Op81E1 },\n\t{ Op82 },        { Op83M1 },      { Op84X1 },      { Op85M1 },      { Op86X1 },\n\t{ Op87M1 },      { Op88X1 },      { Op89M1 },      { Op8AM1 },      { Op8BE1 },\n\t{ Op8CX1 },      { Op8DM1 },      { Op8EX1 },      { Op8FM1 },      { Op90E1 },\n\t{ Op91E1 },      { Op92E1 },      { Op93M1 },      { Op94E1 },      { Op95E1 },\n\t{ Op96E1 },      { Op97M1 },      { Op98M1 },      { Op99M1X1 },    { Op9A },\n\t{ Op9BX1 },      { Op9CM1 },      { Op9DM1X1 },    { Op9EM1X1 },    { Op9FM1 },\n\t{ OpA0X1 },      { OpA1E1 },      { OpA2X1 },      { OpA3M1 },      { OpA4X1 },\n\t{ OpA5M1 },      { OpA6X1 },      { OpA7M1 },      { OpA8X1 },      { OpA9M1 },\n\t{ OpAAX1 },      { OpABE1 },      { OpACX1 },      { OpADM1 },      { OpAEX1 },\n\t{ OpAFM1 },      { OpB0E1 },      { OpB1E1 },      { OpB2E1 },      { OpB3M1 },\n\t{ OpB4E1 },      { OpB5E1 },      { OpB6E1 },      { OpB7M1 },      { OpB8 },\n\t{ OpB9M1X1 },    { OpBAX1 },      { OpBBX1 },      { OpBCX1 },      { OpBDM1X1 },\n\t{ OpBEX1 },      { OpBFM1 },      { OpC0X1 },      { OpC1E1 },      { OpC2 },\n\t{ OpC3M1 },      { OpC4X1 },      { OpC5M1 },      { OpC6M1 },      { OpC7M1 },\n\t{ OpC8X1 },      { OpC9M1 },      { OpCAX1 },      { OpCB },        { OpCCX1 },\n\t{ OpCDM1 },      { OpCEM1 },      { OpCFM1 },      { OpD0E1 },      { OpD1E1 },\n\t{ OpD2E1 },      { OpD3M1 },      { OpD4E1 },      { OpD5E1 },      { OpD6E1 },\n\t{ OpD7M1 },      { OpD8 },        { OpD9M1X1 },    { OpDAE1 },      { OpDB },\n\t{ OpDC },        { OpDDM1X1 },    { OpDEM1X1 },    { OpDFM1 },      { OpE0X1 },\n\t{ OpE1E1 },      { OpE2 },        { OpE3M1 },      { OpE4X1 },      { OpE5M1 },\n\t{ OpE6M1 },      { OpE7M1 },      { OpE8X1 },      { OpE9M1 },      { OpEA },\n\t{ OpEB },        { OpECX1 },      { OpEDM1 },      { OpEEM1 },      { OpEFM1 },\n\t{ OpF0E1 },      { OpF1E1 },      { OpF2E1 },      { OpF3M1 },      { OpF4E1 },\n\t{ OpF5E1 },      { OpF6E1 },      { OpF7M1 },      { OpF8 },        { OpF9M1X1 },\n\t{ OpFAE1 },      { OpFB },        { OpFCE1 },      { OpFDM1X1 },    { OpFEM1X1 },\n\t{ OpFFM1 }\n};\n\nstruct SOpcodes S9xOpcodesM1X0[256] =\n{\n\t{ Op00 },        { Op01E0M1 },    { Op02 },        { Op03M1 },      { Op04M1 },\n\t{ Op05M1 },      { Op06M1 },      { Op07M1 },      { Op08E0 },      { Op09M1 },\n\t{ Op0AM1 },      { Op0BE0 },      { Op0CM1 },      { Op0DM1 },      { Op0EM1 },\n\t{ Op0FM1 },      { Op10E0 },      { Op11E0M1X0 },  { Op12E0M1 },    { Op13M1 },\n\t{ Op14M1 },      { Op15E0M1 },    { Op16E0M1 },    { Op17M1 },      { Op18 },\n\t{ Op19M1X0 },    { Op1AM1 },      { Op1B },        { Op1CM1 },      { Op1DM1X0 },\n\t{ Op1EM1X0 },    { Op1FM1 },      { Op20E0 },      { Op21E0M1 },    { Op22E0 },\n\t{ Op23M1 },      { Op24M1 },      { Op25M1 },      { Op26M1 },      { Op27M1 },\n\t{ Op28E0 },      { Op29M1 },      { Op2AM1 },      { Op2BE0 },      { Op2CM1 },\n\t{ Op2DM1 },      { Op2EM1 },      { Op2FM1 },      { Op30E0 },      { Op31E0M1X0 },\n\t{ Op32E0M1 },    { Op33M1 },      { Op34E0M1 },    { Op35E0M1 },    { Op36E0M1 },\n\t{ Op37M1 },      { Op38 },        { Op39M1X0 },    { Op3AM1 },      { Op3B },\n\t{ Op3CM1X0 },    { Op3DM1X0 },    { Op3EM1X0 },    { Op3FM1 },      { Op40Slow },\n\t{ Op41E0M1 },    { Op42 },        { Op43M1 },      { Op44X0 },      { Op45M1 },\n\t{ Op46M1 },      { Op47M1 },      { Op48E0M1 },    { Op49M1 },      { Op4AM1 },\n\t{ Op4BE0 },      { Op4C },        { Op4DM1 },      { Op4EM1 },      { Op4FM1 },\n\t{ Op50E0 },      { Op51E0M1X0 },  { Op52E0M1 },    { Op53M1 },      { Op54X0 },\n\t{ Op55E0M1 },    { Op56E0M1 },    { Op57M1 },      { Op58 },        { Op59M1X0 },\n\t{ Op5AE0X0 },    { Op5B },        { Op5C },        { Op5DM1X0 },    { Op5EM1X0 },\n\t{ Op5FM1 },      { Op60E0 },      { Op61E0M1 },    { Op62E0 },      { Op63M1 },\n\t{ Op64M1 },      { Op65M1 },      { Op66M1 },      { Op67M1 },      { Op68E0M1 },\n\t{ Op69M1 },      { Op6AM1 },      { Op6BE0 },      { Op6C },        { Op6DM1 },\n\t{ Op6EM1 },      { Op6FM1 },      { Op70E0 },      { Op71E0M1X0 },  { Op72E0M1 },\n\t{ Op73M1 },      { Op74E0M1 },    { Op75E0M1 },    { Op76E0M1 },    { Op77M1 },\n\t{ Op78 },        { Op79M1X0 },    { Op7AE0X0 },    { Op7B },        { Op7C },\n\t{ Op7DM1X0 },    { Op7EM1X0 },    { Op7FM1 },      { Op80E0 },      { Op81E0M1 },\n\t{ Op82 },        { Op83M1 },      { Op84X0 },      { Op85M1 },      { Op86X0 },\n\t{ Op87M1 },      { Op88X0 },      { Op89M1 },      { Op8AM1 },      { Op8BE0 },\n\t{ Op8CX0 },      { Op8DM1 },      { Op8EX0 },      { Op8FM1 },      { Op90E0 },\n\t{ Op91E0M1X0 },  { Op92E0M1 },    { Op93M1 },      { Op94E0X0 },    { Op95E0M1 },\n\t{ Op96E0X0 },    { Op97M1 },      { Op98M1 },      { Op99M1X0 },    { Op9A },\n\t{ Op9BX0 },      { Op9CM1 },      { Op9DM1X0 },    { Op9EM1X0 },    { Op9FM1 },\n\t{ OpA0X0 },      { OpA1E0M1 },    { OpA2X0 },      { OpA3M1 },      { OpA4X0 },\n\t{ OpA5M1 },      { OpA6X0 },      { OpA7M1 },      { OpA8X0 },      { OpA9M1 },\n\t{ OpAAX0 },      { OpABE0 },      { OpACX0 },      { OpADM1 },      { OpAEX0 },\n\t{ OpAFM1 },      { OpB0E0 },      { OpB1E0M1X0 },  { OpB2E0M1 },    { OpB3M1 },\n\t{ OpB4E0X0 },    { OpB5E0M1 },    { OpB6E0X0 },    { OpB7M1 },      { OpB8 },\n\t{ OpB9M1X0 },    { OpBAX0 },      { OpBBX0 },      { OpBCX0 },      { OpBDM1X0 },\n\t{ OpBEX0 },      { OpBFM1 },      { OpC0X0 },      { OpC1E0M1 },    { OpC2 },\n\t{ OpC3M1 },      { OpC4X0 },      { OpC5M1 },      { OpC6M1 },      { OpC7M1 },\n\t{ OpC8X0 },      { OpC9M1 },      { OpCAX0 },      { OpCB },        { OpCCX0 },\n\t{ OpCDM1 },      { OpCEM1 },      { OpCFM1 },      { OpD0E0 },      { OpD1E0M1X0 },\n\t{ OpD2E0M1 },    { OpD3M1 },      { OpD4E0 },      { OpD5E0M1 },    { OpD6E0M1 },\n\t{ OpD7M1 },      { OpD8 },        { OpD9M1X0 },    { OpDAE0X0 },    { OpDB },\n\t{ OpDC },        { OpDDM1X0 },    { OpDEM1X0 },    { OpDFM1 },      { OpE0X0 },\n\t{ OpE1E0M1 },    { OpE2 },        { OpE3M1 },      { OpE4X0 },      { OpE5M1 },\n\t{ OpE6M1 },      { OpE7M1 },      { OpE8X0 },      { OpE9M1 },      { OpEA },\n\t{ OpEB },        { OpECX0 },      { OpEDM1 },      { OpEEM1 },      { OpEFM1 },\n\t{ OpF0E0 },      { OpF1E0M1X0 },  { OpF2E0M1 },    { OpF3M1 },      { OpF4E0 },\n\t{ OpF5E0M1 },    { OpF6E0M1 },    { OpF7M1 },      { OpF8 },        { OpF9M1X0 },\n\t{ OpFAE0X0 },    { OpFB },        { OpFCE0 },      { OpFDM1X0 },    { OpFEM1X0 },\n\t{ OpFFM1 }\n};\n\nstruct SOpcodes S9xOpcodesM0X0[256] =\n{\n\t{ Op00 },        { Op01E0M0 },    { Op02 },        { Op03M0 },      { Op04M0 },\n\t{ Op05M0 },      { Op06M0 },      { Op07M0 },      { Op08E0 },      { Op09M0 },\n\t{ Op0AM0 },      { Op0BE0 },      { Op0CM0 },      { Op0DM0 },      { Op0EM0 },\n\t{ Op0FM0 },      { Op10E0 },      { Op11E0M0X0 },  { Op12E0M0 },    { Op13M0 },\n\t{ Op14M0 },      { Op15E0M0 },    { Op16E0M0 },    { Op17M0 },      { Op18 },\n\t{ Op19M0X0 },    { Op1AM0 },      { Op1B },        { Op1CM0 },      { Op1DM0X0 },\n\t{ Op1EM0X0 },    { Op1FM0 },      { Op20E0 },      { Op21E0M0 },    { Op22E0 },\n\t{ Op23M0 },      { Op24M0 },      { Op25M0 },      { Op26M0 },      { Op27M0 },\n\t{ Op28E0 },      { Op29M0 },      { Op2AM0 },      { Op2BE0 },      { Op2CM0 },\n\t{ Op2DM0 },      { Op2EM0 },      { Op2FM0 },      { Op30E0 },      { Op31E0M0X0 },\n\t{ Op32E0M0 },    { Op33M0 },      { Op34E0M0 },    { Op35E0M0 },    { Op36E0M0 },\n\t{ Op37M0 },      { Op38 },        { Op39M0X0 },    { Op3AM0 },      { Op3B },\n\t{ Op3CM0X0 },    { Op3DM0X0 },    { Op3EM0X0 },    { Op3FM0 },      { Op40Slow },\n\t{ Op41E0M0 },    { Op42 },        { Op43M0 },      { Op44X0 },      { Op45M0 },\n\t{ Op46M0 },      { Op47M0 },      { Op48E0M0 },    { Op49M0 },      { Op4AM0 },\n\t{ Op4BE0 },      { Op4C },        { Op4DM0 },      { Op4EM0 },      { Op4FM0 },\n\t{ Op50E0 },      { Op51E0M0X0 },  { Op52E0M0 },    { Op53M0 },      { Op54X0 },\n\t{ Op55E0M0 },    { Op56E0M0 },    { Op57M0 },      { Op58 },        { Op59M0X0 },\n\t{ Op5AE0X0 },    { Op5B },        { Op5C },        { Op5DM0X0 },    { Op5EM0X0 },\n\t{ Op5FM0 },      { Op60E0 },      { Op61E0M0 },    { Op62E0 },      { Op63M0 },\n\t{ Op64M0 },      { Op65M0 },      { Op66M0 },      { Op67M0 },      { Op68E0M0 },\n\t{ Op69M0 },      { Op6AM0 },      { Op6BE0 },      { Op6C },        { Op6DM0 },\n\t{ Op6EM0 },      { Op6FM0 },      { Op70E0 },      { Op71E0M0X0 },  { Op72E0M0 },\n\t{ Op73M0 },      { Op74E0M0 },    { Op75E0M0 },    { Op76E0M0 },    { Op77M0 },\n\t{ Op78 },        { Op79M0X0 },    { Op7AE0X0 },    { Op7B },        { Op7C },\n\t{ Op7DM0X0 },    { Op7EM0X0 },    { Op7FM0 },      { Op80E0 },      { Op81E0M0 },\n\t{ Op82 },        { Op83M0 },      { Op84X0 },      { Op85M0 },      { Op86X0 },\n\t{ Op87M0 },      { Op88X0 },      { Op89M0 },      { Op8AM0 },      { Op8BE0 },\n\t{ Op8CX0 },      { Op8DM0 },      { Op8EX0 },      { Op8FM0 },      { Op90E0 },\n\t{ Op91E0M0X0 },  { Op92E0M0 },    { Op93M0 },      { Op94E0X0 },    { Op95E0M0 },\n\t{ Op96E0X0 },    { Op97M0 },      { Op98M0 },      { Op99M0X0 },    { Op9A },\n\t{ Op9BX0 },      { Op9CM0 },      { Op9DM0X0 },    { Op9EM0X0 },    { Op9FM0 },\n\t{ OpA0X0 },      { OpA1E0M0 },    { OpA2X0 },      { OpA3M0 },      { OpA4X0 },\n\t{ OpA5M0 },      { OpA6X0 },      { OpA7M0 },      { OpA8X0 },      { OpA9M0 },\n\t{ OpAAX0 },      { OpABE0 },      { OpACX0 },      { OpADM0 },      { OpAEX0 },\n\t{ OpAFM0 },      { OpB0E0 },      { OpB1E0M0X0 },  { OpB2E0M0 },    { OpB3M0 },\n\t{ OpB4E0X0 },    { OpB5E0M0 },    { OpB6E0X0 },    { OpB7M0 },      { OpB8 },\n\t{ OpB9M0X0 },    { OpBAX0 },      { OpBBX0 },      { OpBCX0 },      { OpBDM0X0 },\n\t{ OpBEX0 },      { OpBFM0 },      { OpC0X0 },      { OpC1E0M0 },    { OpC2 },\n\t{ OpC3M0 },      { OpC4X0 },      { OpC5M0 },      { OpC6M0 },      { OpC7M0 },\n\t{ OpC8X0 },      { OpC9M0 },      { OpCAX0 },      { OpCB },        { OpCCX0 },\n\t{ OpCDM0 },      { OpCEM0 },      { OpCFM0 },      { OpD0E0 },      { OpD1E0M0X0 },\n\t{ OpD2E0M0 },    { OpD3M0 },      { OpD4E0 },      { OpD5E0M0 },    { OpD6E0M0 },\n\t{ OpD7M0 },      { OpD8 },        { OpD9M0X0 },    { OpDAE0X0 },    { OpDB },\n\t{ OpDC },        { OpDDM0X0 },    { OpDEM0X0 },    { OpDFM0 },      { OpE0X0 },\n\t{ OpE1E0M0 },    { OpE2 },        { OpE3M0 },      { OpE4X0 },      { OpE5M0 },\n\t{ OpE6M0 },      { OpE7M0 },      { OpE8X0 },      { OpE9M0 },      { OpEA },\n\t{ OpEB },        { OpECX0 },      { OpEDM0 },      { OpEEM0 },      { OpEFM0 },\n\t{ OpF0E0 },      { OpF1E0M0X0 },  { OpF2E0M0 },    { OpF3M0 },      { OpF4E0 },\n\t{ OpF5E0M0 },    { OpF6E0M0 },    { OpF7M0 },      { OpF8 },        { OpF9M0X0 },\n\t{ OpFAE0X0 },    { OpFB },        { OpFCE0 },      { OpFDM0X0 },    { OpFEM0X0 },\n\t{ OpFFM0 }\n};\n\nstruct SOpcodes S9xOpcodesM0X1[256] =\n{\n\t{ Op00 },        { Op01E0M0 },    { Op02 },        { Op03M0 },      { Op04M0 },\n\t{ Op05M0 },      { Op06M0 },      { Op07M0 },      { Op08E0 },      { Op09M0 },\n\t{ Op0AM0 },      { Op0BE0 },      { Op0CM0 },      { Op0DM0 },      { Op0EM0 },\n\t{ Op0FM0 },      { Op10E0 },      { Op11E0M0X1 },  { Op12E0M0 },    { Op13M0 },\n\t{ Op14M0 },      { Op15E0M0 },    { Op16E0M0 },    { Op17M0 },      { Op18 },\n\t{ Op19M0X1 },    { Op1AM0 },      { Op1B },        { Op1CM0 },      { Op1DM0X1 },\n\t{ Op1EM0X1 },    { Op1FM0 },      { Op20E0 },      { Op21E0M0 },    { Op22E0 },\n\t{ Op23M0 },      { Op24M0 },      { Op25M0 },      { Op26M0 },      { Op27M0 },\n\t{ Op28E0 },      { Op29M0 },      { Op2AM0 },      { Op2BE0 },      { Op2CM0 },\n\t{ Op2DM0 },      { Op2EM0 },      { Op2FM0 },      { Op30E0 },      { Op31E0M0X1 },\n\t{ Op32E0M0 },    { Op33M0 },      { Op34E0M0 },    { Op35E0M0 },    { Op36E0M0 },\n\t{ Op37M0 },      { Op38 },        { Op39M0X1 },    { Op3AM0 },      { Op3B },\n\t{ Op3CM0X1 },    { Op3DM0X1 },    { Op3EM0X1 },    { Op3FM0 },      { Op40Slow },\n\t{ Op41E0M0 },    { Op42 },        { Op43M0 },      { Op44X1 },      { Op45M0 },\n\t{ Op46M0 },      { Op47M0 },      { Op48E0M0 },    { Op49M0 },      { Op4AM0 },\n\t{ Op4BE0 },      { Op4C },        { Op4DM0 },      { Op4EM0 },      { Op4FM0 },\n\t{ Op50E0 },      { Op51E0M0X1 },  { Op52E0M0 },    { Op53M0 },      { Op54X1 },\n\t{ Op55E0M0 },    { Op56E0M0 },    { Op57M0 },      { Op58 },        { Op59M0X1 },\n\t{ Op5AE0X1 },    { Op5B },        { Op5C },        { Op5DM0X1 },    { Op5EM0X1 },\n\t{ Op5FM0 },      { Op60E0 },      { Op61E0M0 },    { Op62E0 },      { Op63M0 },\n\t{ Op64M0 },      { Op65M0 },      { Op66M0 },      { Op67M0 },      { Op68E0M0 },\n\t{ Op69M0 },      { Op6AM0 },      { Op6BE0 },      { Op6C },        { Op6DM0 },\n\t{ Op6EM0 },      { Op6FM0 },      { Op70E0 },      { Op71E0M0X1 },  { Op72E0M0 },\n\t{ Op73M0 },      { Op74E0M0 },    { Op75E0M0 },    { Op76E0M0 },    { Op77M0 },\n\t{ Op78 },        { Op79M0X1 },    { Op7AE0X1 },    { Op7B },        { Op7C },\n\t{ Op7DM0X1 },    { Op7EM0X1 },    { Op7FM0 },      { Op80E0 },      { Op81E0M0 },\n\t{ Op82 },        { Op83M0 },      { Op84X1 },      { Op85M0 },      { Op86X1 },\n\t{ Op87M0 },      { Op88X1 },      { Op89M0 },      { Op8AM0 },      { Op8BE0 },\n\t{ Op8CX1 },      { Op8DM0 },      { Op8EX1 },      { Op8FM0 },      { Op90E0 },\n\t{ Op91E0M0X1 },  { Op92E0M0 },    { Op93M0 },      { Op94E0X1 },    { Op95E0M0 },\n\t{ Op96E0X1 },    { Op97M0 },      { Op98M0 },      { Op99M0X1 },    { Op9A },\n\t{ Op9BX1 },      { Op9CM0 },      { Op9DM0X1 },    { Op9EM0X1 },    { Op9FM0 },\n\t{ OpA0X1 },      { OpA1E0M0 },    { OpA2X1 },      { OpA3M0 },      { OpA4X1 },\n\t{ OpA5M0 },      { OpA6X1 },      { OpA7M0 },      { OpA8X1 },      { OpA9M0 },\n\t{ OpAAX1 },      { OpABE0 },      { OpACX1 },      { OpADM0 },      { OpAEX1 },\n\t{ OpAFM0 },      { OpB0E0 },      { OpB1E0M0X1 },  { OpB2E0M0 },    { OpB3M0 },\n\t{ OpB4E0X1 },    { OpB5E0M0 },    { OpB6E0X1 },    { OpB7M0 },      { OpB8 },\n\t{ OpB9M0X1 },    { OpBAX1 },      { OpBBX1 },      { OpBCX1 },      { OpBDM0X1 },\n\t{ OpBEX1 },      { OpBFM0 },      { OpC0X1 },      { OpC1E0M0 },    { OpC2 },\n\t{ OpC3M0 },      { OpC4X1 },      { OpC5M0 },      { OpC6M0 },      { OpC7M0 },\n\t{ OpC8X1 },      { OpC9M0 },      { OpCAX1 },      { OpCB },        { OpCCX1 },\n\t{ OpCDM0 },      { OpCEM0 },      { OpCFM0 },      { OpD0E0 },      { OpD1E0M0X1 },\n\t{ OpD2E0M0 },    { OpD3M0 },      { OpD4E0 },      { OpD5E0M0 },    { OpD6E0M0 },\n\t{ OpD7M0 },      { OpD8 },        { OpD9M0X1 },    { OpDAE0X1 },    { OpDB },\n\t{ OpDC },        { OpDDM0X1 },    { OpDEM0X1 },    { OpDFM0 },      { OpE0X1 },\n\t{ OpE1E0M0 },    { OpE2 },        { OpE3M0 },      { OpE4X1 },      { OpE5M0 },\n\t{ OpE6M0 },      { OpE7M0 },      { OpE8X1 },      { OpE9M0 },      { OpEA },\n\t{ OpEB },        { OpECX1 },      { OpEDM0 },      { OpEEM0 },      { OpEFM0 },\n\t{ OpF0E0 },      { OpF1E0M0X1 },  { OpF2E0M0 },    { OpF3M0 },      { OpF4E0 },\n\t{ OpF5E0M0 },    { OpF6E0M0 },    { OpF7M0 },      { OpF8 },        { OpF9M0X1 },\n\t{ OpFAE0X1 },    { OpFB },        { OpFCE0 },      { OpFDM0X1 },    { OpFEM0X1 },\n\t{ OpFFM0 }\n};\n\nstruct SOpcodes S9xOpcodesSlow[256] =\n{\n\t{ Op00 },        { Op01Slow },    { Op02 },        { Op03Slow },    { Op04Slow },\n\t{ Op05Slow },    { Op06Slow },    { Op07Slow },    { Op08Slow },    { Op09Slow },\n\t{ Op0ASlow },    { Op0BSlow },    { Op0CSlow },    { Op0DSlow },    { Op0ESlow },\n\t{ Op0FSlow },    { Op10Slow },    { Op11Slow },    { Op12Slow },    { Op13Slow },\n\t{ Op14Slow },    { Op15Slow },    { Op16Slow },    { Op17Slow },    { Op18 },\n\t{ Op19Slow },    { Op1ASlow },    { Op1B },        { Op1CSlow },    { Op1DSlow },\n\t{ Op1ESlow },    { Op1FSlow },    { Op20Slow },    { Op21Slow },    { Op22Slow },\n\t{ Op23Slow },    { Op24Slow },    { Op25Slow },    { Op26Slow },    { Op27Slow },\n\t{ Op28Slow },    { Op29Slow },    { Op2ASlow },    { Op2BSlow },    { Op2CSlow },\n\t{ Op2DSlow },    { Op2ESlow },    { Op2FSlow },    { Op30Slow },    { Op31Slow },\n\t{ Op32Slow },    { Op33Slow },    { Op34Slow },    { Op35Slow },    { Op36Slow },\n\t{ Op37Slow },    { Op38 },        { Op39Slow },    { Op3ASlow },    { Op3B },\n\t{ Op3CSlow },    { Op3DSlow },    { Op3ESlow },    { Op3FSlow },    { Op40Slow },\n\t{ Op41Slow },    { Op42 },        { Op43Slow },    { Op44Slow },    { Op45Slow },\n\t{ Op46Slow },    { Op47Slow },    { Op48Slow },    { Op49Slow },    { Op4ASlow },\n\t{ Op4BSlow },    { Op4CSlow },    { Op4DSlow },    { Op4ESlow },    { Op4FSlow },\n\t{ Op50Slow },    { Op51Slow },    { Op52Slow },    { Op53Slow },    { Op54Slow },\n\t{ Op55Slow },    { Op56Slow },    { Op57Slow },    { Op58 },        { Op59Slow },\n\t{ Op5ASlow },    { Op5B },        { Op5CSlow },    { Op5DSlow },    { Op5ESlow },\n\t{ Op5FSlow },    { Op60Slow },    { Op61Slow },    { Op62Slow },    { Op63Slow },\n\t{ Op64Slow },    { Op65Slow },    { Op66Slow },    { Op67Slow },    { Op68Slow },\n\t{ Op69Slow },    { Op6ASlow },    { Op6BSlow },    { Op6CSlow },    { Op6DSlow },\n\t{ Op6ESlow },    { Op6FSlow },    { Op70Slow },    { Op71Slow },    { Op72Slow },\n\t{ Op73Slow },    { Op74Slow },    { Op75Slow },    { Op76Slow },    { Op77Slow },\n\t{ Op78 },        { Op79Slow },    { Op7ASlow },    { Op7B },        { Op7CSlow },\n\t{ Op7DSlow },    { Op7ESlow },    { Op7FSlow },    { Op80Slow },    { Op81Slow },\n\t{ Op82Slow },    { Op83Slow },    { Op84Slow },    { Op85Slow },    { Op86Slow },\n\t{ Op87Slow },    { Op88Slow },    { Op89Slow },    { Op8ASlow },    { Op8BSlow },\n\t{ Op8CSlow },    { Op8DSlow },    { Op8ESlow },    { Op8FSlow },    { Op90Slow },\n\t{ Op91Slow },    { Op92Slow },    { Op93Slow },    { Op94Slow },    { Op95Slow },\n\t{ Op96Slow },    { Op97Slow },    { Op98Slow },    { Op99Slow },    { Op9A },\n\t{ Op9BSlow },    { Op9CSlow },    { Op9DSlow },    { Op9ESlow },    { Op9FSlow },\n\t{ OpA0Slow },    { OpA1Slow },    { OpA2Slow },    { OpA3Slow },    { OpA4Slow },\n\t{ OpA5Slow },    { OpA6Slow },    { OpA7Slow },    { OpA8Slow },    { OpA9Slow },\n\t{ OpAASlow },    { OpABSlow },    { OpACSlow },    { OpADSlow },    { OpAESlow },\n\t{ OpAFSlow },    { OpB0Slow },    { OpB1Slow },    { OpB2Slow },    { OpB3Slow },\n\t{ OpB4Slow },    { OpB5Slow },    { OpB6Slow },    { OpB7Slow },    { OpB8 },\n\t{ OpB9Slow },    { OpBASlow },    { OpBBSlow },    { OpBCSlow },    { OpBDSlow },\n\t{ OpBESlow },    { OpBFSlow },    { OpC0Slow },    { OpC1Slow },    { OpC2Slow },\n\t{ OpC3Slow },    { OpC4Slow },    { OpC5Slow },    { OpC6Slow },    { OpC7Slow },\n\t{ OpC8Slow },    { OpC9Slow },    { OpCASlow },    { OpCB },        { OpCCSlow },\n\t{ OpCDSlow },    { OpCESlow },    { OpCFSlow },    { OpD0Slow },    { OpD1Slow },\n\t{ OpD2Slow },    { OpD3Slow },    { OpD4Slow },    { OpD5Slow },    { OpD6Slow },\n\t{ OpD7Slow },    { OpD8 },        { OpD9Slow },    { OpDASlow },    { OpDB },\n\t{ OpDCSlow },    { OpDDSlow },    { OpDESlow },    { OpDFSlow },    { OpE0Slow },\n\t{ OpE1Slow },    { OpE2Slow },    { OpE3Slow },    { OpE4Slow },    { OpE5Slow },\n\t{ OpE6Slow },    { OpE7Slow },    { OpE8Slow },    { OpE9Slow },    { OpEA },\n\t{ OpEB },        { OpECSlow },    { OpEDSlow },    { OpEESlow },    { OpEFSlow },\n\t{ OpF0Slow },    { OpF1Slow },    { OpF2Slow },    { OpF3Slow },    { OpF4Slow },\n\t{ OpF5Slow },    { OpF6Slow },    { OpF7Slow },    { OpF8 },        { OpF9Slow },\n\t{ OpFASlow },    { OpFB },        { OpFCSlow },    { OpFDSlow },    { OpFESlow },\n\t{ OpFFSlow }\n};\n"
        },
        {
          "name": "cpuops.h",
          "type": "blob",
          "size": 0.587890625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _CPUOPS_H_\n#define _CPUOPS_H_\n\nvoid S9xOpcode_NMI (void);\nvoid S9xOpcode_IRQ (void);\n\n#ifndef SA1_OPCODES\n#define CHECK_FOR_IRQ() {} // if (CPU.IRQLine) S9xOpcode_IRQ(); }\n#else\n#define CHECK_FOR_IRQ()\t{}\n#endif\n#endif\n"
        },
        {
          "name": "crosshairs.cpp",
          "type": "blob",
          "size": 10.7880859375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifdef HAVE_LIBPNG\n#include <png.h>\n#endif\n#include \"port.h\"\n#include \"crosshairs.h\"\n\nstatic const char\t*crosshairs[32] =\n{\n\t\"`              \"  // Crosshair 0 (no image)\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \",\n\n\t\"`              \"  // Crosshair 1 (the classic small dot)\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"       #.      \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \",\n\n\t\"`              \"  // Crosshair 2 (a standard cross)\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"    ...#...    \"\n\t\"    #######    \"\n\t\"    ...#...    \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \",\n\n\t\"`     .#.      \"  // Crosshair 3 (a standard cross)\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\".......#.......\"\n\t\"###############\"\n\t\".......#.......\"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \",\n\n\t\"`              \"  // Crosshair 4 (an X)\n\t\"               \"\n\t\"               \"\n\t\"    .     .    \"\n\t\"   .#.   .#.   \"\n\t\"    .#. .#.    \"\n\t\"     .#.#.     \"\n\t\"      .#.      \"\n\t\"     .#.#.     \"\n\t\"    .#. .#.    \"\n\t\"   .#.   .#.   \"\n\t\"    .     .    \"\n\t\"               \"\n\t\"               \"\n\t\"               \",\n\n\t\"`.           . \"  // Crosshair 5 (an X)\n\t\".#.         .#.\"\n\t\" .#.       .#. \"\n\t\"  .#.     .#.  \"\n\t\"   .#.   .#.   \"\n\t\"    .#. .#.    \"\n\t\"     .#.#.     \"\n\t\"      .#.      \"\n\t\"     .#.#.     \"\n\t\"    .#. .#.    \"\n\t\"   .#.   .#.   \"\n\t\"  .#.     .#.  \"\n\t\" .#.       .#. \"\n\t\".#.         .#.\"\n\t\" .           . \",\n\n\t\"`              \"  // Crosshair 6 (a combo)\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"    #  .  #    \"\n\t\"     # . #     \"\n\t\"      #.#      \"\n\t\"    ...#...    \"\n\t\"      #.#      \"\n\t\"     # . #     \"\n\t\"    #  .  #    \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \",\n\n\t\"`      .       \"  // Crosshair 7 (a combo)\n\t\" #     .     # \"\n\t\"  #    .    #  \"\n\t\"   #   .   #   \"\n\t\"    #  .  #    \"\n\t\"     # . #     \"\n\t\"      #.#      \"\n\t\".......#.......\"\n\t\"      #.#      \"\n\t\"     # . #     \"\n\t\"    #  .  #    \"\n\t\"   #   .   #   \"\n\t\"  #    .    #  \"\n\t\" #     .     # \"\n\t\"       .       \",\n\n\t\"`      #       \"  // Crosshair 8 (a diamond cross)\n\t\"      #.#      \"\n\t\"     # . #     \"\n\t\"    #  .  #    \"\n\t\"   #   .   #   \"\n\t\"  #    .    #  \"\n\t\" #     .     # \"\n\t\"#......#......#\"\n\t\" #     .     # \"\n\t\"  #    .    #  \"\n\t\"   #   .   #   \"\n\t\"    #  .  #    \"\n\t\"     # . #     \"\n\t\"      #.#      \"\n\t\"       #       \",\n\n\t\"`     ###      \"  // Crosshair 9 (a circle cross)\n\t\"    ## . ##    \"\n\t\"   #   .   #   \"\n\t\"  #    .    #  \"\n\t\" #     .     # \"\n\t\" #     .     # \"\n\t\"#      .      #\"\n\t\"#......#......#\"\n\t\"#      .      #\"\n\t\" #     .     # \"\n\t\" #     .     # \"\n\t\"  #    .    #  \"\n\t\"   #   .   #   \"\n\t\"    ## . ##    \"\n\t\"      ###      \",\n\n\t\"`     .#.      \"  // Crosshair 10 (a square cross)\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"   ....#....   \"\n\t\"   .#######.   \"\n\t\"   .#     #.   \"\n\t\"....#     #....\"\n\t\"#####     #####\"\n\t\"....#     #....\"\n\t\"   .#     #.   \"\n\t\"   .#######.   \"\n\t\"   ....#....   \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \",\n\n\t\"`     .#.      \"  // Crosshair 11 (an interrupted cross)\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"               \"\n\t\".....     .....\"\n\t\"#####     #####\"\n\t\".....     .....\"\n\t\"               \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \"\n\t\"      .#.      \",\n\n\t\"`.           . \"  // Crosshair 12 (an interrupted X)\n\t\".#.         .#.\"\n\t\" .#.       .#. \"\n\t\"  .#.     .#.  \"\n\t\"   .#.   .#.   \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"   .#.   .#.   \"\n\t\"  .#.     .#.  \"\n\t\" .#.       .#. \"\n\t\".#.         .#.\"\n\t\" .           . \",\n\n\t\"`      .       \"  // Crosshair 13 (an interrupted combo)\n\t\" #     .     # \"\n\t\"  #    .    #  \"\n\t\"   #   .   #   \"\n\t\"    #  .  #    \"\n\t\"               \"\n\t\"               \"\n\t\".....     .....\"\n\t\"               \"\n\t\"               \"\n\t\"    #  .  #    \"\n\t\"   #   .   #   \"\n\t\"  #    .    #  \"\n\t\" #     .     # \"\n\t\"       .       \",\n\n\t\"`####     #### \"  // Crosshair 14\n\t\"#....     ....#\"\n\t\"#.           .#\"\n\t\"#.           .#\"\n\t\"#.           .#\"\n\t\"       #       \"\n\t\"       #       \"\n\t\"     #####     \"\n\t\"       #       \"\n\t\"       #       \"\n\t\"#.           .#\"\n\t\"#.           .#\"\n\t\"#.           .#\"\n\t\"#....     ....#\"\n\t\" ####     #### \",\n\n\t\"`  .#     #.   \"  // Crosshair 15\n\t\"   .#     #.   \"\n\t\"   .#     #.   \"\n\t\"....#     #....\"\n\t\"#####     #####\"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"               \"\n\t\"#####     #####\"\n\t\"....#     #....\"\n\t\"   .#     #.   \"\n\t\"   .#     #.   \"\n\t\"   .#     #.   \",\n\n\t\"`      #       \"  // Crosshair 16\n\t\"       #       \"\n\t\"       #       \"\n\t\"   ....#....   \"\n\t\"   .   #   .   \"\n\t\"   .   #   .   \"\n\t\"   .   #   .   \"\n\t\"###############\"\n\t\"   .   #   .   \"\n\t\"   .   #   .   \"\n\t\"   .   #   .   \"\n\t\"   ....#....   \"\n\t\"       #       \"\n\t\"       #       \"\n\t\"       #       \",\n\n\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n};\n\n\nbool S9xLoadCrosshairFile (int idx, const char *filename)\n{\n\tif (idx < 1 || idx > 31)\n\t\treturn (false);\n\n\tchar\t*s = (char *) calloc(15 * 15 + 1, sizeof(char));\n\tif (s == NULL)\n\t{\n\t\tfprintf(stderr, \"S9xLoadCrosshairFile: malloc error while reading \");\n\t\tperror(filename);\n\t\treturn (false);\n\t}\n\n\tFILE\t*fp = fopen(filename, \"rb\");\n\tif (fp == NULL)\n\t{\n\t\tfprintf(stderr, \"S9xLoadCrosshairFile: Couldn't open \");\n\t\tperror(filename);\n\t\tfree(s);\n\t\treturn (false);\n\t}\n\n\tsize_t\tl = fread(s, 1, 8, fp);\n\tif (l != 8)\n\t{\n\t\tfprintf(stderr, \"S9xLoadCrosshairFile: File is too short!\\n\");\n\t\tfree(s);\n\t\tfclose(fp);\n\t\treturn (false);\n\t}\n\n#ifdef HAVE_LIBPNG\n\tpng_structp\tpng_ptr;\n\tpng_infop\tinfo_ptr;\n\n\tif (!png_sig_cmp((png_byte *) s, 0, 8))\n\t{\n\t\tpng_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n\t\tif (!png_ptr)\n\t\t{\n\t\t\tfree(s);\n\t\t\tfclose(fp);\n\t\t\treturn (false);\n\t\t}\n\n\t\tinfo_ptr = png_create_info_struct(png_ptr);\n\t\tif (!info_ptr)\n\t\t{\n\t\t\tpng_destroy_read_struct(&png_ptr, (png_infopp) NULL, (png_infopp) NULL);\n\t\t\tfree(s);\n\t\t\tfclose(fp);\n\t\t\treturn (false);\n\t\t}\n\n\t\tpng_init_io(png_ptr, fp);\n\t\tpng_set_sig_bytes(png_ptr, 8);\n\t\tpng_read_info(png_ptr, info_ptr);\n\n\t\tpng_uint_32\twidth, height;\n\t\tint\t\t\tbit_depth, color_type;\n\n\t\tpng_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, NULL, NULL, NULL);\n\t\tif (color_type != PNG_COLOR_TYPE_PALETTE)\n\t\t{\n\t\t\tfprintf(stderr, \"S9xLoadCrosshairFile: Input PNG is not a palettized image!\\n\");\n\t\t\tpng_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp) NULL);\n\t\t\tfree(s);\n\t\t\tfclose(fp);\n\t\t\treturn (false);\n\t\t}\n\n\t\tif (bit_depth == 16)\n\t\t\tpng_set_strip_16(png_ptr);\n\n\t\tif (width != 15 || height != 15)\n\t\t{\n\t\t\tfprintf(stderr, \"S9xLoadCrosshairFile: Expecting a 15x15 PNG\\n\");\n\t\t\tpng_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp) NULL);\n\t\t\tfree(s);\n\t\t\tfclose(fp);\n\t\t\treturn (false);\n\t\t}\n\n\t\tpng_color\t*pngpal;\n\t\tpng_byte\t*trans;\n\t\tint\t\t\tnum_palette = 0, num_trans = 0;\n\t\tint\t\t\ttranscol = -1, fgcol = -1, bgcol = -1;\n\n\t\tpng_get_PLTE(png_ptr, info_ptr, &pngpal, &num_palette);\n\t\tpng_get_tRNS(png_ptr, info_ptr, &trans, &num_trans, NULL);\n\n\t\tif (num_palette != 3 || num_trans != 1)\n\t\t{\n\t\t\tfprintf(stderr, \"S9xLoadCrosshairFile: Expecting a 3-color PNG with 1 trasnparent color\\n\");\n\t\t\tpng_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp) NULL);\n\t\t\tfree(s);\n\t\t\tfclose(fp);\n\t\t\treturn (false);\n\t\t}\n\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tif (trans[0] == i)\n\t\t\t\ttranscol = i;\n\t\t\telse\n\t\t\tif (pngpal[i].red ==   0 && pngpal[i].green ==   0 && pngpal[i].blue ==   0)\n\t\t\t\tbgcol = i;\n\t\t\telse\n\t\t\tif (pngpal[i].red == 255 && pngpal[i].green == 255 && pngpal[i].blue == 255)\n\t\t\t\tfgcol = i;\n\t\t}\n\n\t\tif (transcol < 0 || fgcol < 0 || bgcol < 0)\n\t\t{\n\t\t\tfprintf(stderr, \"S9xLoadCrosshairFile: PNG must have 3 colors: white (fg), black (bg), and transparent.\\n\");\n\t\t\tpng_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp) NULL);\n\t\t\tfree(s);\n\t\t\tfclose(fp);\n\t\t\treturn (false);\n\t\t}\n\n\t\tpng_set_packing(png_ptr);\n\t\tpng_read_update_info(png_ptr, info_ptr);\n\t\tpng_byte\t*row_pointer = new png_byte[png_get_rowbytes(png_ptr, info_ptr)];\n\n\t\tfor (int r = 0; r < 15 * 15; r += 15)\n\t\t{\n\t\t\tpng_read_row(png_ptr, row_pointer, NULL);\n\n\t\t\tfor (int i = 0; i < 15; i++)\n\t\t\t{\n\t\t\t\tif (row_pointer[i] == transcol)\n\t\t\t\t\ts[r + i] = ' ';\n\t\t\t\telse\n\t\t\t\tif (row_pointer[i] == fgcol)\n\t\t\t\t\ts[r + i] = '#';\n\t\t\t\telse\n\t\t\t\tif (row_pointer[i] == bgcol)\n\t\t\t\t\ts[r + i] = '.';\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr, \"S9xLoadCrosshairFile: WTF? This was supposed to be a 3-color PNG!\\n\");\n\t\t\t\t\tpng_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp) NULL);\n\t\t\t\t\tfree(s);\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\treturn (false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ts[15 * 15] = 0;\n\t\tpng_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp) NULL);\n\t}\n\telse\n#endif\n\t{\n\t\tl = fread(s + 8, 1, 15 - 8, fp);\n\t\tif (l != 15 - 8)\n\t\t{\n\t\t\tfprintf(stderr, \"S9xLoadCrosshairFile: File is too short!\\n\");\n\t\t\tfree(s);\n\t\t\tfclose(fp);\n\t\t\treturn (false);\n\t\t}\n\n\t\tif (getc(fp) != '\\n')\n\t\t{\n\t\t\tfprintf(stderr, \"S9xLoadCrosshairFile: Invalid file format! (note: PNG support is not available)\\n\");\n\t\t\tfree(s);\n\t\t\tfclose(fp);\n\t\t\treturn (false);\n\t\t}\n\n\t\tfor (int r = 1; r < 15; r++)\n\t\t{\n\t\t\tl = fread(s + r * 15, 1, 15, fp);\n\t\t\tif (l != 15)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"S9xLoadCrosshairFile: File is too short! (note: PNG support is not available)\\n\");\n\t\t\t\tfree(s);\n\t\t\t\tfclose(fp);\n\t\t\t\treturn (false);\n\t\t\t}\n\n\t\t\tif (getc(fp) != '\\n')\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"S9xLoadCrosshairFile: Invalid file format! (note: PNG support is not available)\\n\");\n\t\t\t\tfree(s);\n\t\t\t\tfclose(fp);\n\t\t\t\treturn (false);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 15 * 15; i++)\n\t\t{\n\t\t\tif (s[i] != ' ' && s[i] != '#' && s[i] != '.')\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"S9xLoadCrosshairFile: Invalid file format! (note: PNG support is not available)\\n\");\n\t\t\t\tfree(s);\n\t\t\t\tfclose(fp);\n\t\t\t\treturn (false);\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\tif (crosshairs[idx] != NULL && crosshairs[idx][0] != '`')\n\t\tfree((void *) crosshairs[idx]);\n\tcrosshairs[idx] = s;\n\n\treturn (true);\n}\n\nconst char * S9xGetCrosshair (int idx)\n{\n\tif (idx < 0 || idx > 31)\n\t\treturn (NULL);\n\n\treturn (crosshairs[idx]);\n}\n"
        },
        {
          "name": "crosshairs.h",
          "type": "blob",
          "size": 2.6220703125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _CROSSHAIRS_H_\n#define _CROSSHAIRS_H_\n\n// Read in the specified crosshair file, replacing whatever data might be in that slot.\n// Available slots are 1-31.\n// The input file must be a PNG or a text file. \n// PNG:  15x15 pixels, palettized, with 3 colors (white, black, and transparent).\n// text: 15 lines of 16 characters (counting the \\n), consisting of ' ', '#', or '.'.\n\nbool S9xLoadCrosshairFile (int idx, const char *filename);\n\n// Return the specified crosshair. Woo-hoo.\n// char * to a 225-byte string, with '#' marking foreground, '.' marking background,\n// and anything else transparent.\n\nconst char * S9xGetCrosshair (int idx);\n\n// In controls.cpp. Sets the crosshair for the specified device. Defaults are:\n//                cross   fgcolor    bgcolor\n//   Mouse 1:       1     White      Black\n//   Mouse 2:       1     Purple     White\n//   Superscope:    2     White      Black\n//   Justifier 1:   4     Blue       Black\n//   Justifier 2:   4     MagicPink  Black\n//   Macs Rifle:    2     White      Black\n//\n// Available colors are: Trans, Black, 25Grey, 50Grey, 75Grey, White, Red, Orange,\n// Yellow, Green, Cyan, Sky, Blue, Violet, MagicPink, and Purple.\n// You may also prefix a 't' (e.g. tBlue) for a 50%-transparent version.\n// Use idx = -1 or fg/bg = NULL to keep the current setting.\n\nenum crosscontrols\n{\n\tX_MOUSE1,\n\tX_MOUSE2,\n\tX_SUPERSCOPE,\n\tX_JUSTIFIER1,\n\tX_JUSTIFIER2,\n\tX_MACSRIFLE\n};\n\nvoid S9xSetControllerCrosshair (enum crosscontrols ctl, int8 idx, const char *fg, const char *bg);\nvoid S9xGetControllerCrosshair (enum crosscontrols ctl, int8 *idx, const char **fg, const char **bg);\n\n// In gfx.cpp, much like S9xDisplayChar() except it takes the parameters\n// listed and looks up GFX.Screen.\n// The 'crosshair' arg is a 15x15 image, with '#' meaning fgcolor,\n// '.' meaning bgcolor, and anything else meaning transparent.\n// Color values should be (RGB):\n//  0 = transparent  4 = 23 23 23    8 = 31 31  0   12 =  0  0 31\n//  1 =  0  0  0     5 = 31 31 31    9 =  0 31  0   13 = 23  0 31\n//  2 =  8  8  8     6 = 31  0  0   10 =  0 31 31   14 = 31  0 31\n//  3 = 16 16 16     7 = 31 16  0   11 =  0 23 31   15 = 31  0 16\n//  16-31 are 50% transparent versions of 0-15.\n\nvoid S9xDrawCrosshair (const char *crosshair, uint8 fgcolor, uint8 bgcolor, int16 x, int16 y);\n\n#endif\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "debug.cpp",
          "type": "blob",
          "size": 56.5263671875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifdef DEBUGGER\n\n#include <stdarg.h>\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"cpuops.h\"\n#include \"dma.h\"\n#include \"apu/apu.h\"\n#include \"display.h\"\n#include \"debug.h\"\n#include \"missing.h\"\n\n#include \"apu/bapu/snes/snes.hpp\"\n\nextern SDMA\tDMA[8];\nextern FILE\t*apu_trace;\nFILE\t\t*trace = NULL, *trace2 = NULL;\n\nstruct SBreakPoint\tS9xBreakpoint[6];\n\nstruct SDebug\n{\n\tstruct\n\t{\n\t\tuint8\tBank;\n\t\tuint16\tAddress;\n\t}\tDump;\n\n\tstruct\n\t{\n\t\tuint8\tBank;\n\t\tuint16\tAddress;\n\t}\tUnassemble;\n};\n\nstatic struct SDebug\tDebug = { { 0, 0 }, { 0, 0 } };\n\nstatic const char\t*HelpMessage[] =\n{\n\t\"Command Help:\",\n\t\"?, help                - Shows this command help\",\n\t\"r                      - Shows the registers\",\n\t\"i                      - Shows the interrupt vectors\",\n\t\"t                      - Trace current instruction   [step-into]\",\n\t\"p                      - Proceed to next instruction [step-over]\",\n\t\"s                      - Skip to next instruction    [skip]\",\n\t\"T                      - Toggle CPU instruction tracing to trace.log\",\n\t\"TS                     - Toggle SA-1 instruction tracing to trace_sa1.log\",\n\t\"E                      - Toggle HC-based event tracing to trace.log\",\n\t\"V                      - Toggle non-DMA V-RAM read/write tracing to stdout\",\n\t\"D                      - Toggle on-screen DMA tracing\",\n\t\"H                      - Toggle on-screen HDMA tracing\",\n\t\"U                      - Toggle on-screen unknown register read/write tracing\",\n\t\"P                      - Toggle on-screen DSP tracing\",\n\t\"S                      - Dump sprite (OBJ) status\",\n\t\"g [Address]            - Go or go to [Address]\",\n\t\"u [Address]            - Disassemble from PC or [Address]\",\n\t\"d [Address]            - Dump from PC or [Address]\",\n\t\"bv [Number]            - View breakpoints or view breakpoint [Number]\",\n\t\"bs [Number] [Address]  - Enable/disable breakpoint\",\n\t\"                         [enable example: bs #2 $02:8002]\",\n\t\"                         [disable example: bs #2]\",\n\t\"c                      - Dump SNES colour palette\",\n\t\"W                      - Show what SNES hardware features the ROM is using\",\n\t\"                         which might not be implemented yet\",\n\t\"w                      - Show some SNES hardware features used so far in this frame\",\n\t\"R                      - Reset SNES\",\n\t\"q                      - Quit emulation\",\n//\t\"ai                     - Shou APU vectors\",\n//\t\"a                      - Show APU status\",\n//\t\"x                      - Show Sound DSP status\",\n\t\"A                      - Toggle APU instruction tracing to trace.log\",\n//\t\"B                      - Toggle sound DSP register tracing to aputrace.log\",\n//\t\"C                      - Dump sound sample addresses\",\n//\t\"ad [Address]           - Dump APU RAM from PC or [Address]\",\n\t\"\",\n\t\"[Address]              - $Bank:Address or $Address\",\n\t\"                         [for example: $01:8123]\",\n\t\"[Number]               - #Number\",\n\t\"                         [for example: #1]\",\n\t\"z                      - \",\n\t\"f                      - \",\n\t\"dump                   - \",\n\t\"\",\n\tNULL\n};\n\nstatic const char\t*S9xMnemonics[256] =\n{\n\t\"BRK\", \"ORA\", \"COP\", \"ORA\", \"TSB\", \"ORA\", \"ASL\", \"ORA\",\n\t\"PHP\", \"ORA\", \"ASL\", \"PHD\", \"TSB\", \"ORA\", \"ASL\", \"ORA\",\n\t\"BPL\", \"ORA\", \"ORA\", \"ORA\", \"TRB\", \"ORA\", \"ASL\", \"ORA\",\n\t\"CLC\", \"ORA\", \"INC\", \"TCS\", \"TRB\", \"ORA\", \"ASL\", \"ORA\",\n\t\"JSR\", \"AND\", \"JSL\", \"AND\", \"BIT\", \"AND\", \"ROL\", \"AND\",\n\t\"PLP\", \"AND\", \"ROL\", \"PLD\", \"BIT\", \"AND\", \"ROL\", \"AND\",\n\t\"BMI\", \"AND\", \"AND\", \"AND\", \"BIT\", \"AND\", \"ROL\", \"AND\",\n\t\"SEC\", \"AND\", \"DEC\", \"TSC\", \"BIT\", \"AND\", \"ROL\", \"AND\",\n\t\"RTI\", \"EOR\", \"WDM\", \"EOR\", \"MVP\", \"EOR\", \"LSR\", \"EOR\",\n\t\"PHA\", \"EOR\", \"LSR\", \"PHK\", \"JMP\", \"EOR\", \"LSR\", \"EOR\",\n\t\"BVC\", \"EOR\", \"EOR\", \"EOR\", \"MVN\", \"EOR\", \"LSR\", \"EOR\",\n\t\"CLI\", \"EOR\", \"PHY\", \"TCD\", \"JMP\", \"EOR\", \"LSR\", \"EOR\",\n\t\"RTS\", \"ADC\", \"PER\", \"ADC\", \"STZ\", \"ADC\", \"ROR\", \"ADC\",\n\t\"PLA\", \"ADC\", \"ROR\", \"RTL\", \"JMP\", \"ADC\", \"ROR\", \"ADC\",\n\t\"BVS\", \"ADC\", \"ADC\", \"ADC\", \"STZ\", \"ADC\", \"ROR\", \"ADC\",\n\t\"SEI\", \"ADC\", \"PLY\", \"TDC\", \"JMP\", \"ADC\", \"ROR\", \"ADC\",\n\t\"BRA\", \"STA\", \"BRL\", \"STA\", \"STY\", \"STA\", \"STX\", \"STA\",\n\t\"DEY\", \"BIT\", \"TXA\", \"PHB\", \"STY\", \"STA\", \"STX\", \"STA\",\n\t\"BCC\", \"STA\", \"STA\", \"STA\", \"STY\", \"STA\", \"STX\", \"STA\",\n\t\"TYA\", \"STA\", \"TXS\", \"TXY\", \"STZ\", \"STA\", \"STZ\", \"STA\",\n\t\"LDY\", \"LDA\", \"LDX\", \"LDA\", \"LDY\", \"LDA\", \"LDX\", \"LDA\",\n\t\"TAY\", \"LDA\", \"TAX\", \"PLB\", \"LDY\", \"LDA\", \"LDX\", \"LDA\",\n\t\"BCS\", \"LDA\", \"LDA\", \"LDA\", \"LDY\", \"LDA\", \"LDX\", \"LDA\",\n\t\"CLV\", \"LDA\", \"TSX\", \"TYX\", \"LDY\", \"LDA\", \"LDX\", \"LDA\",\n\t\"CPY\", \"CMP\", \"REP\", \"CMP\", \"CPY\", \"CMP\", \"DEC\", \"CMP\",\n\t\"INY\", \"CMP\", \"DEX\", \"WAI\", \"CPY\", \"CMP\", \"DEC\", \"CMP\",\n\t\"BNE\", \"CMP\", \"CMP\", \"CMP\", \"PEI\", \"CMP\", \"DEC\", \"CMP\",\n\t\"CLD\", \"CMP\", \"PHX\", \"STP\", \"JML\", \"CMP\", \"DEC\", \"CMP\",\n\t\"CPX\", \"SBC\", \"SEP\", \"SBC\", \"CPX\", \"SBC\", \"INC\", \"SBC\",\n\t\"INX\", \"SBC\", \"NOP\", \"XBA\", \"CPX\", \"SBC\", \"INC\", \"SBC\",\n\t\"BEQ\", \"SBC\", \"SBC\", \"SBC\", \"PEA\", \"SBC\", \"INC\", \"SBC\",\n\t\"SED\", \"SBC\", \"PLX\", \"XCE\", \"JSR\", \"SBC\", \"INC\", \"SBC\"\n};\n\nstatic int\tAddrModes[256] =\n{\n  // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n\t 3, 10,  3, 19,  6,  6,  6, 12,  0,  1, 24,  0, 14, 14, 14, 17, // 0\n\t 4, 11,  9, 20,  6,  7,  7, 13,  0, 16, 24,  0, 14, 15, 15, 18, // 1\n\t14, 10, 17, 19,  6,  6,  6, 12,  0,  1, 24,  0, 14, 14, 14, 17, // 2\n\t 4, 11,  9, 20,  7,  7,  7, 13,  0, 16, 24,  0, 15, 15, 15, 18, // 3\n\t 0, 10,  3, 19, 25,  6,  6, 12,  0,  1, 24,  0, 14, 14, 14, 17, // 4\n\t 4, 11,  9, 20, 25,  7,  7, 13,  0, 16,  0,  0, 17, 15, 15, 18, // 5\n\t 0, 10,  5, 19,  6,  6,  6, 12,  0,  1, 24,  0, 21, 14, 14, 17, // 6\n\t 4, 11,  9, 20,  7,  7,  7, 13,  0, 16,  0,  0, 23, 15, 15, 18, // 7\n\t 4, 10,  5, 19,  6,  6,  6, 12,  0,  1,  0,  0, 14, 14, 14, 17, // 8\n\t 4, 11,  9, 20,  7,  7,  8, 13,  0, 16,  0,  0, 14, 15, 15, 18, // 9\n\t 2, 10,  2, 19,  6,  6,  6, 12,  0,  1,  0,  0, 14, 14, 14, 17, // A\n\t 4, 11,  9, 20,  7,  7,  8, 13,  0, 16,  0,  0, 15, 15, 16, 18, // B\n\t 2, 10,  3, 19,  6,  6,  6, 12,  0,  1,  0,  0, 14, 14, 14, 17, // C\n\t 4, 11,  9,  9, 27,  7,  7, 13,  0, 16,  0,  0, 22, 15, 15, 18, // D\n\t 2, 10,  3, 19,  6,  6,  6, 12,  0,  1,  0,  0, 14, 14, 14, 17, // E\n\t 4, 11,  9, 20, 26,  7,  7, 13,  0, 16,  0,  0, 23, 15, 15, 18  // F\n};\n\nstatic uint8 S9xDebugGetByte (uint32);\nstatic uint16 S9xDebugGetWord (uint32);\nstatic uint8 S9xDebugSA1GetByte (uint32);\nstatic uint16 S9xDebugSA1GetWord (uint32);\nstatic uint8 debug_cpu_op_print (char *, uint8, uint16);\nstatic uint8 debug_sa1_op_print (char *, uint8, uint16);\nstatic void debug_line_print (const char *);\nstatic int debug_get_number (char *, uint16 *);\nstatic short debug_get_start_address (char *, uint8 *, uint32 *);\nstatic void debug_print_window (uint8 *);\nstatic const char * debug_clip_fn (int);\nstatic void debug_whats_used (void);\nstatic void debug_whats_missing (void);\n\n\nstatic uint8 S9xDebugGetByte (uint32 Address)\n{\n\tint\t\tblock = (Address & 0xffffff) >> MEMMAP_SHIFT;\n\tuint8\t*GetAddress = Memory.Map[block];\n\tuint8\tbyte = 0;\n\n\tif (GetAddress >= (uint8 *) CMemory::MAP_LAST)\n\t{\n\t\tbyte = *(GetAddress + (Address & 0xffff));\n\t\treturn (byte);\n\t}\n\n\tswitch ((pint) GetAddress)\n\t{\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\tbyte = *(Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask));\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_LOROM_SRAM_B:\n\t\t\tbyte = *(Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB));\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_HIROM_SRAM:\n\t\tcase CMemory::MAP_RONLY_SRAM:\n\t\t\tbyte = *(Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0xf0000) >> 3)) & Memory.SRAMMask));\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\tbyte = *(Memory.BWRAM + ((Address & 0x7fff) - 0x6000));\n\t\t\treturn (byte);\n\n\t\tdefault:\n\t\t\treturn (byte);\n\t}\n}\n\nstatic uint16 S9xDebugGetWord (uint32 Address)\n{\n\tuint16\tword;\n\n\tword  = S9xDebugGetByte(Address);\n\tword |= S9xDebugGetByte(Address + 1) << 8;\n\n\treturn (word);\n}\n\nstatic uint8 S9xDebugSA1GetByte (uint32 Address)\n{\n\tint\t\tblock = (Address & 0xffffff) >> MEMMAP_SHIFT;\n\tuint8\t*GetAddress = SA1.Map[block];\n\tuint8\tbyte = 0;\n\n\tif (GetAddress >= (uint8 *) CMemory::MAP_LAST)\n\t{\n\t\tbyte = *(GetAddress + (Address & 0xffff));\n\t\treturn (byte);\n\t}\n\n\tswitch ((pint) GetAddress)\n\t{\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\tbyte = *(Memory.SRAM + (Address & 0xffff));\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\tbyte = *(SA1.BWRAM + ((Address & 0x7fff) - 0x6000));\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_BWRAM_BITMAP:\n\t\t\tAddress -= 0x600000;\n\t\t\tif (SA1.VirtualBitmapFormat == 2)\n\t\t\t\tbyte = (Memory.SRAM[(Address >> 2) & 0xffff] >> ((Address & 3) << 1)) &  3;\n\t\t\telse\n\t\t\t\tbyte = (Memory.SRAM[(Address >> 1) & 0xffff] >> ((Address & 1) << 2)) & 15;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_BWRAM_BITMAP2:\n\t\t\tAddress = (Address & 0xffff) - 0x6000;\n\t\t\tif (SA1.VirtualBitmapFormat == 2)\n\t\t\t\tbyte = (SA1.BWRAM[(Address >> 2) & 0xffff] >> ((Address & 3) << 1)) &  3;\n\t\t\telse\n\t\t\t\tbyte = (SA1.BWRAM[(Address >> 1) & 0xffff] >> ((Address & 1) << 2)) & 15;\n\t\t\treturn (byte);\n\n\t\tdefault:\n\t\t\treturn (byte);\n\t}\n}\n\nstatic uint16 S9xDebugSA1GetWord (uint32 Address)\n{\n\tuint16\tword;\n\n\tword  = S9xDebugSA1GetByte(Address);\n\tword |= S9xDebugSA1GetByte(Address + 1) << 8;\n\n\treturn (word);\n}\n\nstatic uint8 debug_cpu_op_print (char *Line, uint8 Bank, uint16 Address)\n{\n\tuint8\tS9xOpcode;\n\tuint8\tOperant[3];\n\tuint16\tWord;\n\tuint8\tByte;\n\tint16\tSWord;\n\tint8\tSByte;\n\tuint8\tSize = 0;\n\n\tS9xOpcode = S9xDebugGetByte((Bank << 16) + Address);\n\tsprintf(Line, \"$%02X:%04X %02X \", Bank, Address, S9xOpcode);\n\n\tOperant[0] = S9xDebugGetByte((Bank << 16) + Address + 1);\n\tOperant[1] = S9xDebugGetByte((Bank << 16) + Address + 2);\n\tOperant[2] = S9xDebugGetByte((Bank << 16) + Address + 3);\n\n\tswitch (AddrModes[S9xOpcode])\n\t{\n\t\tcase 0:\n\t\t\t// Implied\n\t\t\tsprintf(Line, \"%s         %s\",\n\t\t\t\t\tLine,\n\t\t\t\t\tS9xMnemonics[S9xOpcode]);\n\t\t\tSize = 1;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t// Immediate[MemoryFlag]\n\t\t\tif (!CheckFlag(MemoryFlag))\n\t\t\t{\n\t\t\t\t// Accumulator 16 - Bit\n\t\t\t\tsprintf(Line, \"%s%02X %02X    %s #$%02X%02X\",\n\t\t\t\t\t\tLine,\n\t\t\t\t\t\tOperant[0],\n\t\t\t\t\t\tOperant[1],\n\t\t\t\t\t\tS9xMnemonics[S9xOpcode],\n\t\t\t\t\t\tOperant[1],\n\t\t\t\t\t\tOperant[0]);\n\t\t\t\tSize = 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Accumulator 8 - Bit\n\t\t\t\tsprintf(Line, \"%s%02X       %s #$%02X\",\n\t\t\t\t\t\tLine,\n\t\t\t\t\t\tOperant[0],\n\t\t\t\t\t\tS9xMnemonics[S9xOpcode],\n\t\t\t\t\t\tOperant[0]);\n\t\t\t\tSize = 2;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t// Immediate[IndexFlag]\n\t\t\tif (!CheckFlag(IndexFlag))\n\t\t\t{\n\t\t\t\t// X / Y 16 - Bit\n\t\t\t\tsprintf(Line, \"%s%02X %02X    %s #$%02X%02X\",\n\t\t\t\t        Line,\n\t\t\t\t        Operant[0],\n\t\t\t\t        Operant[1],\n\t\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t\t        Operant[1],\n\t\t\t\t        Operant[0]);\n\t\t\t\tSize = 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// X / Y 8 - Bit\n\t\t\t\tsprintf(Line, \"%s%02X       %s #$%02X\",\n\t\t\t\t        Line,\n\t\t\t\t        Operant[0],\n\t\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t\t        Operant[0]);\n\t\t\t\tSize = 2;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t// Immediate[Always 8 - Bit]\n\t\t\tsprintf(Line, \"%s%02X       %s #$%02X\",\n\t\t\t\t\tLine,\n\t\t\t\t\tOperant[0],\n\t\t\t\t\tS9xMnemonics[S9xOpcode],\n\t\t\t\t\tOperant[0]);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\t// Relative\n\t\t\tsprintf(Line, \"%s%02X       %s $%02X\",\n\t\t\t\t\tLine,\n\t\t\t\t\tOperant[0],\n\t\t\t\t\tS9xMnemonics[S9xOpcode],\n\t\t\t\t\tOperant[0]);\n\t\t\tSByte = Operant[0];\n\t\t\tWord = Address;\n\t\t\tWord += SByte;\n\t\t\tWord += 2;\n\t\t\tsprintf(Line, \"%-32s[$%04X]\", Line, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\t// Relative Long\n\t\t\tsprintf(Line, \"%s%02X %02X    %s $%02X%02X\",\n\t\t\t\t\tLine,\n\t\t\t\t\tOperant[0],\n\t\t\t\t\tOperant[1],\n\t\t\t\t\tS9xMnemonics[S9xOpcode],\n\t\t\t\t\tOperant[1],\n\t\t\t\t\tOperant[0]);\n\t\t\tSWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord = Address;\n\t\t\tWord += SWord;\n\t\t\tWord += 3;\n\t\t\tsprintf(Line, \"%-32s[$%04X]\", Line, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\t// Direct\n\t\t\tsprintf(Line, \"%s%02X       %s $%02X\",\n\t\t\t\t\tLine,\n\t\t\t\t\tOperant[0],\n\t\t\t\t\tS9xMnemonics[S9xOpcode],\n\t\t\t\t\tOperant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += Registers.D.W;\n\t\t\tsprintf(Line, \"%-32s[$00:%04X]\", Line, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 7:\n\t\t\t// Direct Indexed (with X)\n\t\t\tsprintf(Line, \"%s%02X       %s $%02X,x\",\n\t\t\t\t\tLine,\n\t\t\t\t\tOperant[0],\n\t\t\t\t\tS9xMnemonics[S9xOpcode],\n\t\t\t\t\tOperant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += Registers.D.W;\n\t\t\tWord += Registers.X.W;\n\t\t\tsprintf(Line, \"%-32s[$00:%04X]\", Line, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\t// Direct Indexed (with Y)\n\t\t\tsprintf(Line, \"%s%02X       %s $%02X,y\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += Registers.D.W;\n\t\t\tWord += Registers.Y.W;\n\t\t\tsprintf(Line, \"%-32s[$00:%04X]\", Line, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 9:\n\t\t\t// Direct Indirect\n\t\t\tsprintf(Line, \"%s%02X       %s ($%02X)\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += Registers.D.W;\n\t\t\tWord = S9xDebugGetWord(Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Registers.DB, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 10:\n\t\t\t// Direct Indexed Indirect\n\t\t\tsprintf(Line, \"%s%02X       %s ($%02X,x)\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += Registers.D.W;\n\t\t\tWord += Registers.X.W;\n\t\t\tWord = S9xDebugGetWord(Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Registers.DB, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 11:\n\t\t\t// Direct Indirect Indexed\n\t\t\tsprintf(Line, \"%s%02X       %s ($%02X),y\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += Registers.D.W;\n\t\t\tWord = S9xDebugGetWord(Word);\n\t\t\tWord += Registers.Y.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Registers.DB, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 12:\n\t\t\t// Direct Indirect Long\n\t\t\tsprintf(Line, \"%s%02X       %s [$%02X]\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += Registers.D.W;\n\t\t\tByte = S9xDebugGetByte(Word + 2);\n\t\t\tWord = S9xDebugGetWord(Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Byte, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 13:\n\t\t\t// Direct Indirect Indexed Long\n\t\t\tsprintf(Line, \"%s%02X       %s [$%02X],y\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += Registers.D.W;\n\t\t\tByte = S9xDebugGetByte(Word + 2);\n\t\t\tWord = S9xDebugGetWord(Word);\n\t\t\tWord += Registers.Y.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Byte, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 14:\n\t\t\t// Absolute\n\t\t\tsprintf(Line, \"%s%02X %02X    %s $%02X%02X\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Registers.DB, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 15:\n\t\t\t// Absolute Indexed (with X)\n\t\t\tsprintf(Line, \"%s%02X %02X    %s $%02X%02X,x\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord += Registers.X.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Registers.DB, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 16:\n\t\t\t// Absolute Indexed (with Y)\n\t\t\tsprintf(Line, \"%s%02X %02X    %s $%02X%02X,y\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord += Registers.Y.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Registers.DB, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 17:\n\t\t\t// Absolute Long\n\t\t\tsprintf(Line, \"%s%02X %02X %02X %s $%02X%02X%02X\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        Operant[2],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[2],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Operant[2], Word);\n\t\t\tSize = 4;\n\t\t\tbreak;\n\n\t\tcase 18:\n\t\t\t// Absolute Indexed Long\n\t\t\tsprintf(Line, \"%s%02X %02X %02X %s $%02X%02X%02X,x\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        Operant[2],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[2],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord += Registers.X.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Operant[2], Word);\n\t\t\tSize = 4;\n\t\t\tbreak;\n\n\t\tcase 19:\n\t\t\t// Stack Relative\n\t\t\tsprintf(Line, \"%s%02X       %s $%02X,s\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Registers.S.W;\n\t\t\tWord += Operant[0];\n\t\t\tsprintf(Line, \"%-32s[$00:%04X]\", Line, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 20:\n\t\t\t// Stack Relative Indirect Indexed\n\t\t\tsprintf(Line, \"%s%02X       %s ($%02X,s),y\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Registers.S.W;\n\t\t\tWord += Operant[0];\n\t\t\tWord = S9xDebugGetWord(Word);\n\t\t\tWord += Registers.Y.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Registers.DB, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 21:\n\t\t\t// Absolute Indirect\n\t\t\tsprintf(Line, \"%s%02X %02X    %s ($%02X%02X)\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord = S9xDebugGetWord(Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Registers.PB, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 22:\n\t\t\t// Absolute Indirect Long\n\t\t\tsprintf(Line, \"%s%02X %02X    %s [$%02X%02X]\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tByte = S9xDebugGetByte(Word + 2);\n\t\t\tWord = S9xDebugGetWord(Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Byte, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 23:\n\t\t\t// Absolute Indexed Indirect\n\t\t\tsprintf(Line, \"%s%02X %02X    %s ($%02X%02X,x)\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord += Registers.X.W;\n\t\t\tWord = S9xDebugGetWord(ICPU.ShiftedPB + Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Registers.PB, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 24:\n\t\t\t// Implied Accumulator\n\t\t\tsprintf(Line, \"%s         %s A\",\n\t\t\t        Line,\n\t\t\t        S9xMnemonics[S9xOpcode]);\n\t\t\tSize = 1;\n\t\t\tbreak;\n\n\t\tcase 25:\n\t\t\t// MVN/MVP SRC DST\n\t\t\tsprintf(Line, \"%s%02X %02X    %s %02X %02X\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 26:\n\t\t\t// PEA\n\t\t\tsprintf(Line, \"%s%02X %02X    %s $%02X%02X\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 27:\n\t\t\t// PEI Direct Indirect\n\t\t\tsprintf(Line, \"%s%02X       %s ($%02X)\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += Registers.D.W;\n\t\t\tWord = S9xDebugGetWord(Word);\n\t\t\tsprintf(Line, \"%-32s[$%04X]\", Line, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\t}\n\n\tsprintf(Line, \"%-44s A:%04X X:%04X Y:%04X D:%04X DB:%02X S:%04X P:%c%c%c%c%c%c%c%c%c HC:%04ld VC:%03ld FC:%02d %c%c%c %c%c%c %c%c HT:%d VT:%d C:%d\",\n\t        Line, Registers.A.W, Registers.X.W, Registers.Y.W,\n\t        Registers.D.W, Registers.DB, Registers.S.W,\n\t        CheckEmulation() ? 'E' : 'e',\n\t        CheckNegative() ? 'N' : 'n',\n\t        CheckOverflow() ? 'V' : 'v',\n\t        CheckMemory() ? 'M' : 'm',\n\t        CheckIndex() ? 'X' : 'x',\n\t        CheckDecimal() ? 'D' : 'd',\n\t        CheckIRQ() ? 'I' : 'i',\n\t        CheckZero() ? 'Z' : 'z',\n\t        CheckCarry() ? 'C' : 'c',\n\t        (long) CPU.Cycles,\n\t        (long) CPU.V_Counter,\n\t        IPPU.FrameCount,\n\t        CPU.IRQExternal ?  'E' : ' ', PPU.HTimerEnabled ? 'H' : ' ', PPU.VTimerEnabled ? 'V' : ' ',\n\t        CPU.NMIPending ? 'N' : '.',\n\t        Memory.FillRAM[0x4200] & 0x80 ? 'n' : '.',\n\t        Memory.FillRAM[0x4210] & 0x80 ? '+' : '.',\n\t        CPU.IRQTransition ? 'T' : ' ',\n\t        CPU.IRQLine ? 'L' : ' ',\n\t        PPU.HTimerPosition, PPU.VTimerPosition, Timings.NextIRQTimer);\n\n\treturn (Size);\n}\n\nstatic uint8 debug_sa1_op_print (char *Line, uint8 Bank, uint16 Address)\n{\n\tuint8\tS9xOpcode;\n\tuint8\tOperant[3];\n\tuint16\tWord;\n\tuint8\tByte;\n\tint16\tSWord;\n\tint8\tSByte;\n\tuint8\tSize = 0;\n\n\tS9xOpcode = S9xDebugSA1GetByte((Bank << 16) + Address);\n\tsprintf(Line, \"$%02X:%04X %02X \", Bank, Address, S9xOpcode);\n\n\tOperant[0] = S9xDebugSA1GetByte((Bank << 16) + Address + 1);\n\tOperant[1] = S9xDebugSA1GetByte((Bank << 16) + Address + 2);\n\tOperant[2] = S9xDebugSA1GetByte((Bank << 16) + Address + 3);\n\n\tswitch (AddrModes[S9xOpcode])\n\t{\n\t\tcase 0:\n\t\t\t// Implied\n\t\t\tsprintf(Line, \"%s         %s\",\n\t\t\t        Line,\n\t\t\t        S9xMnemonics[S9xOpcode]);\n\t\t\tSize = 1;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t// Immediate[MemoryFlag]\n\t\t\tif (!SA1CheckFlag(MemoryFlag))\n\t\t\t{\n\t\t\t\t// Accumulator 16 - Bit\n\t\t\t\tsprintf(Line, \"%s%02X %02X    %s #$%02X%02X\",\n\t\t\t\t        Line,\n\t\t\t\t        Operant[0],\n\t\t\t\t        Operant[1],\n\t\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t\t        Operant[1],\n\t\t\t\t        Operant[0]);\n\t\t\t\tSize = 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Accumulator 8 - Bit\n\t\t\t\tsprintf(Line, \"%s%02X       %s #$%02X\",\n\t\t\t\t        Line,\n\t\t\t\t        Operant[0],\n\t\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t\t        Operant[0]);\n\t\t\t\tSize = 2;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t// Immediate[IndexFlag]\n\t\t\tif (!SA1CheckFlag(IndexFlag))\n\t\t\t{\n\t\t\t\t// X / Y 16 - Bit\n\t\t\t\tsprintf(Line, \"%s%02X %02X    %s #$%02X%02X\",\n\t\t\t\t        Line,\n\t\t\t\t        Operant[0],\n\t\t\t\t        Operant[1],\n\t\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t\t        Operant[1],\n\t\t\t\t        Operant[0]);\n\t\t\t\tSize = 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// X / Y 8 - Bit\n\t\t\t\tsprintf(Line, \"%s%02X       %s #$%02X\",\n\t\t\t\t        Line,\n\t\t\t\t        Operant[0],\n\t\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t\t        Operant[0]);\n\t\t\t\tSize = 2;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t// Immediate[Always 8 - Bit]\n\t\t\tsprintf(Line, \"%s%02X       %s #$%02X\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\t// Relative\n\t\t\tsprintf(Line, \"%s%02X       %s $%02X\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tSByte = Operant[0];\n\t\t\tWord = Address;\n\t\t\tWord += SByte;\n\t\t\tWord += 2;\n\t\t\tsprintf(Line, \"%-32s[$%04X]\", Line, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\t// Relative Long\n\t\t\tsprintf(Line, \"%s%02X %02X    %s $%02X%02X\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tSWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord = Address;\n\t\t\tWord += SWord;\n\t\t\tWord += 3;\n\t\t\tsprintf(Line, \"%-32s[$%04X]\", Line, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\t// Direct\n\t\t\tsprintf(Line, \"%s%02X       %s $%02X\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += SA1Registers.D.W;\n\t\t\tsprintf(Line, \"%-32s[$00:%04X]\", Line, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 7:\n\t\t\t// Direct Indexed (with X)\n\t\t\tsprintf(Line, \"%s%02X       %s $%02X,x\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += SA1Registers.D.W;\n\t\t\tWord += SA1Registers.X.W;\n\t\t\tsprintf(Line, \"%-32s[$00:%04X]\", Line, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\t// Direct Indexed (with Y)\n\t\t\tsprintf(Line, \"%s%02X       %s $%02X,y\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += SA1Registers.D.W;\n\t\t\tWord += SA1Registers.Y.W;\n\t\t\tsprintf(Line, \"%-32s[$00:%04X]\", Line, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 9:\n\t\t\t// Direct Indirect\n\t\t\tsprintf(Line, \"%s%02X       %s ($%02X)\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += SA1Registers.D.W;\n\t\t\tWord = S9xDebugSA1GetWord(Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, SA1Registers.DB, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 10:\n\t\t\t// Direct Indexed Indirect\n\t\t\tsprintf(Line, \"%s%02X       %s ($%02X,x)\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += SA1Registers.D.W;\n\t\t\tWord += SA1Registers.X.W;\n\t\t\tWord = S9xDebugSA1GetWord(Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, SA1Registers.DB, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 11:\n\t\t\t// Direct Indirect Indexed\n\t\t\tsprintf(Line, \"%s%02X       %s ($%02X),y\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += SA1Registers.D.W;\n\t\t\tWord = S9xDebugSA1GetWord(Word);\n\t\t\tWord += SA1Registers.Y.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, SA1Registers.DB, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 12:\n\t\t\t// Direct Indirect Long\n\t\t\tsprintf(Line, \"%s%02X       %s [$%02X]\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += SA1Registers.D.W;\n\t\t\tByte = S9xDebugSA1GetByte(Word + 2);\n\t\t\tWord = S9xDebugSA1GetWord(Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Byte, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 13:\n\t\t\t// Direct Indirect Indexed Long\n\t\t\tsprintf(Line, \"%s%02X       %s [$%02X],y\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = Operant[0];\n\t\t\tWord += SA1Registers.D.W;\n\t\t\tByte = S9xDebugSA1GetByte(Word + 2);\n\t\t\tWord = S9xDebugSA1GetWord(Word);\n\t\t\tWord += SA1Registers.Y.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Byte, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 14:\n\t\t\t// Absolute\n\t\t\tsprintf(Line, \"%s%02X %02X    %s $%02X%02X\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, SA1Registers.DB, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 15:\n\t\t\t// Absolute Indexed (with X)\n\t\t\tsprintf(Line, \"%s%02X %02X    %s $%02X%02X,x\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord += SA1Registers.X.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, SA1Registers.DB, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 16:\n\t\t\t// Absolute Indexed (with Y)\n\t\t\tsprintf(Line, \"%s%02X %02X    %s $%02X%02X,y\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord += SA1Registers.Y.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, SA1Registers.DB, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 17:\n\t\t\t// Absolute Long\n\t\t\tsprintf(Line, \"%s%02X %02X %02X %s $%02X%02X%02X\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        Operant[2],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[2],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Operant[2], Word);\n\t\t\tSize = 4;\n\t\t\tbreak;\n\n\t\tcase 18:\n\t\t\t// Absolute Indexed Long\n\t\t\tsprintf(Line, \"%s%02X %02X %02X %s $%02X%02X%02X,x\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        Operant[2],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[2],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord += SA1Registers.X.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Operant[2], Word);\n\t\t\tSize = 4;\n\t\t\tbreak;\n\n\t\tcase 19:\n\t\t\t// Stack Relative\n\t\t\tsprintf(Line, \"%s%02X       %s $%02X,s\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = SA1Registers.S.W;\n\t\t\tWord += Operant[0];\n\t\t\tsprintf(Line, \"%-32s[$00:%04X]\", Line, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 20:\n\t\t\t// Stack Relative Indirect Indexed\n\t\t\tsprintf(Line, \"%s%02X       %s ($%02X,s),y\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0]);\n\t\t\tWord = SA1Registers.S.W;\n\t\t\tWord += Operant[0];\n\t\t\tWord = S9xDebugSA1GetWord(Word);\n\t\t\tWord += SA1Registers.Y.W;\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, SA1Registers.DB, Word);\n\t\t\tSize = 2;\n\t\t\tbreak;\n\n\t\tcase 21:\n\t\t\t// Absolute Indirect\n\t\t\tsprintf(Line, \"%s%02X %02X    %s ($%02X%02X)\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord = S9xDebugSA1GetWord(Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, SA1Registers.PB, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 22:\n\t\t\t// Absolute Indirect Long\n\t\t\tsprintf(Line, \"%s%02X %02X    %s [$%02X%02X]\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tByte = S9xDebugSA1GetByte(Word + 2);\n\t\t\tWord = S9xDebugSA1GetWord(Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, Byte, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 23:\n\t\t\t// Absolute Indexed Indirect\n\t\t\tsprintf(Line, \"%s%02X %02X    %s ($%02X%02X,x)\",\n\t\t\t        Line,\n\t\t\t        Operant[0],\n\t\t\t        Operant[1],\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[1],\n\t\t\t        Operant[0]);\n\t\t\tWord = (Operant[1] << 8) | Operant[0];\n\t\t\tWord += SA1Registers.X.W;\n\t\t\tWord = S9xDebugSA1GetWord(SA1.ShiftedPB + Word);\n\t\t\tsprintf(Line, \"%-32s[$%02X:%04X]\", Line, SA1Registers.PB, Word);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\n\t\tcase 24:\n\t\t\t// Implied Accumulator\n\t\t\tsprintf(Line, \"%s         %s A\",\n\t\t\t        Line,\n\t\t\t        S9xMnemonics[S9xOpcode]);\n\t\t\tSize = 1;\n\t\t\tbreak;\n\n\t\tcase 25:\n\t\t\t// MVN/MVP SRC DST\n\t\t\tsprintf(Line, \"%s         %s %02X %02X\",\n\t\t\t        Line,\n\t\t\t        S9xMnemonics[S9xOpcode],\n\t\t\t        Operant[0],\n\t\t\t        Operant[1]);\n\t\t\tSize = 3;\n\t\t\tbreak;\n\t}\n\n\tsprintf(Line, \"%-44s A:%04X X:%04X Y:%04X D:%04X DB:%02X S:%04X P:%c%c%c%c%c%c%c%c%c HC:%04ld VC:%03ld FC:%02d %c%c\",\n\t        Line, SA1Registers.A.W, SA1Registers.X.W, SA1Registers.Y.W,\n\t        SA1Registers.D.W, SA1Registers.DB, SA1Registers.S.W,\n\t        SA1CheckEmulation() ? 'E' : 'e',\n\t        SA1CheckNegative() ? 'N' : 'n',\n\t        SA1CheckOverflow() ? 'V' : 'v',\n\t        SA1CheckMemory() ? 'M' : 'm',\n\t        SA1CheckIndex() ? 'X' : 'x',\n\t        SA1CheckDecimal() ? 'D' : 'd',\n\t        SA1CheckIRQ() ? 'I' : 'i',\n\t        SA1CheckZero() ? 'Z' : 'z',\n\t        SA1CheckCarry() ? 'C' : 'c',\n\t        (long) CPU.Cycles,\n\t        (long) CPU.V_Counter,\n\t        IPPU.FrameCount,\n\t        CPU.NMIPending ? 'P' : ' ',\n\t        Memory.FillRAM[0x4210] & 0x80 ? 'N' : ' ');\n\n\treturn (Size);\n}\n\nstatic void debug_line_print (const char *Line)\n{\n\tprintf(\"%s\\n\", Line);\n}\n\nstatic int debug_get_number (char *Line, uint16 *Number)\n{\n\tint\ti;\n\n\tif (sscanf(Line, \" #%d\", &i) == 1)\n\t{\n\t\t*Number = i;\n\t\treturn (1);\n\t}\n\n\treturn (-1);\n}\n\nstatic short debug_get_start_address (char *Line, uint8 *Bank, uint32 *Address)\n{\n\tuint32\ta, b;\n\n\tif (sscanf(Line + 1, \" $%x:%x\", &b, &a) != 2)\n\t\treturn (-1);\n\n\t*Bank = b;\n\t*Address = a;\n\n\treturn (1);\n}\n\nvoid S9xDebugProcessCommand(char *Line)\n{\n\tuint8\tBank = Registers.PB;\n\tuint32\tAddress = Registers.PCw;\n\tuint16\tHold = 0;\n\tuint16\tNumber;\n\tshort\tErrorCode;\n\tchar\tstring[512];\n\n\tif (strncasecmp(Line, \"dump\", 4) == 0)\n\t{\n\t\tint\tCount;\n\n\t\tif (sscanf(&Line[4], \"%x %d\", &Address, &Count) == 2)\n\t\t{\n\t\t\tFILE\t*fs;\n\n\t\t\tsprintf(string, \"%06x%05d.sd2\", Address, Count);\n\t\t\tfs = fopen(string, \"wb\");\n\t\t\tif (fs)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < Count; i++)\n\t\t\t\t\tputc(S9xDebugGetByte(Address + i), fs);\n\t\t\t\tfclose(fs);\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"Can't open %s for writing\\n\", string);\n\t\t}\n\t\telse\n\t\t\tprintf(\"Usage: dump start_address_in_hex count_in_decimal\\n\");\n\n\t\treturn;\n\t}\n\n\tif (*Line == 'i')\n\t{\n\t\tprintf(\"Vectors:\\n\");\n\t\tsprintf(string, \"      8 Bit   16 Bit \");\n\t\tdebug_line_print(string);\n\t\tsprintf(string, \"ABT $00:%04X|$00:%04X\", S9xDebugGetWord(0xFFF8), S9xDebugGetWord(0xFFE8));\n\t\tdebug_line_print(string);\n\t\tsprintf(string, \"BRK $00:%04X|$00:%04X\", S9xDebugGetWord(0xFFFE), S9xDebugGetWord(0xFFE6));\n\t\tdebug_line_print(string);\n\t\tsprintf(string, \"COP $00:%04X|$00:%04X\", S9xDebugGetWord(0xFFF4), S9xDebugGetWord(0xFFE4));\n\t\tdebug_line_print(string);\n\t\tsprintf(string, \"IRQ $00:%04X|$00:%04X\", S9xDebugGetWord(0xFFFE), S9xDebugGetWord(0xFFEE));\n\t\tdebug_line_print(string);\n\t\tsprintf(string, \"NMI $00:%04X|$00:%04X\", S9xDebugGetWord(0xFFFA), S9xDebugGetWord(0xFFEA));\n\t\tdebug_line_print(string);\n\t\tsprintf(string, \"RES     $00:%04X\", S9xDebugGetWord(0xFFFC));\n\t\tdebug_line_print(string);\n\t}\n\n/*\n\tif (strncmp(Line, \"ai\", 2) == 0)\n\t{\n\t\tprintf(\"APU vectors:\");\n\n\t\tfor (int i = 0; i < 0x40; i += 2)\n\t\t{\n\t\t\tif (i % 16 == 0)\n\t\t\t\tprintf(\"\\n%04x \", 0xffc0 + i);\n\n\t\t\tprintf(\"%04x \", APU.ExtraRAM[i]);\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t}\n*/\n\n\tif (*Line == 's')\n\t{\n\t\tRegisters.PCw += debug_cpu_op_print(string, Bank, Address);\n\t\tBank = Registers.PB;\n\t\tAddress = Registers.PCw;\n\t\t*Line = 'r';\n\t}\n\n\tif (*Line == 'z')\n\t{\n\t\tuint16\t*p = (uint16 *) &Memory.VRAM[PPU.BG[2].SCBase << 1];\n\n\t\tfor (int l = 0; l < 32; l++)\n\t\t{\n\t\t\tfor (int c = 0; c < 32; c++, p++)\n\t\t\t\tprintf(\"%04x,\", *p++);\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\tif (*Line == 'c')\n\t{\n\t\tprintf(\"Colours:\\n\");\n\n\t\tfor (int i = 0; i < 256; i++)\n\t\t\tprintf(\"%02x%02x%02x  \", PPU.CGDATA[i] & 0x1f, (PPU.CGDATA[i] >> 5) & 0x1f, (PPU.CGDATA[i] >> 10) & 0x1f);\n\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (*Line == 'S')\n\t{\n\t\tint\tSmallWidth, LargeWidth, SmallHeight, LargeHeight;\n\n\t\tswitch ((Memory.FillRAM[0x2101] >> 5) & 7)\n\t\t{\n\n\t\t\tcase 0:\n\t\t\t\tSmallWidth = SmallHeight = 8;\n\t\t\t\tLargeWidth = LargeHeight = 16;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tSmallWidth = SmallHeight = 8;\n\t\t\t\tLargeWidth = LargeHeight = 32;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tSmallWidth = SmallHeight = 8;\n\t\t\t\tLargeWidth = LargeHeight = 64;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tSmallWidth = SmallHeight = 16;\n\t\t\t\tLargeWidth = LargeHeight = 32;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tSmallWidth = SmallHeight = 16;\n\t\t\t\tLargeWidth = LargeHeight = 64;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tcase 5:\n\t\t\t\tSmallWidth = SmallHeight = 32;\n\t\t\t\tLargeWidth = LargeHeight = 64;\n\t\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\t\tSmallWidth = 16;\n\t\t\t\tSmallHeight = 32;\n\t\t\t\tLargeWidth = 32;\n\t\t\t\tLargeHeight = 64;\n\t\t\t\tbreak;\n\n\t\t\tcase 7:\n\t\t\t\tSmallWidth = 16;\n\t\t\t\tSmallHeight = 32;\n\t\t\t\tLargeWidth = LargeHeight = 32;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"Sprites: Small: %dx%d, Large: %dx%d, OAMAddr: 0x%04x, OBJNameBase: 0x%04x, OBJNameSelect: 0x%04x, First: %d\\n\",\n\t\t       SmallWidth, SmallHeight, LargeWidth, LargeHeight, PPU.OAMAddr, PPU.OBJNameBase, PPU.OBJNameSelect, PPU.FirstSprite);\n\n\t\tfor (int i = 0; i < 128; i++)\n\t\t{\n\t\t\tprintf(\"X:%3d Y:%3d %c%c%d%c \",\n\t\t\t       PPU.OBJ[i].HPos,\n\t\t\t       PPU.OBJ[i].VPos,\n\t\t\t       PPU.OBJ[i].VFlip ? 'V' : 'v',\n\t\t\t       PPU.OBJ[i].HFlip ? 'H' : 'h',\n\t\t\t       PPU.OBJ[i].Priority,\n\t\t\t       PPU.OBJ[i].Size ? 'S' : 's');\n\n\t\t\tif (i % 4 == 3)\n\t\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\tif (*Line == 'T')\n\t{\n\t\tif (Line[1] == 'S')\n\t\t{\n\t\t\tSA1.Flags ^= TRACE_FLAG;\n\n\t\t\tif (SA1.Flags & TRACE_FLAG)\n\t\t\t{\n\t\t\t\tprintf(\"SA1 CPU instruction tracing enabled.\\n\");\n\t\t\t\tENSURE_TRACE_OPEN(trace2, \"trace_sa1.log\", \"wb\")\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"SA1 CPU instruction tracing disabled.\\n\");\n\t\t\t\tfclose(trace2);\n\t\t\t\ttrace2 = NULL;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCPU.Flags ^= TRACE_FLAG;\n\n\t\t\tif (CPU.Flags & TRACE_FLAG)\n\t\t\t{\n\t\t\t\tprintf(\"CPU instruction tracing enabled.\\n\");\n\t\t\t\tENSURE_TRACE_OPEN(trace, \"trace.log\", \"wb\")\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"CPU instruction tracing disabled.\\n\");\n\t\t\t\tfclose(trace);\n\t\t\t\ttrace = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*Line == 'E')\n\t{\n\t\tSettings.TraceHCEvent = !Settings.TraceHCEvent;\n\t\tprintf(\"HC event tracing %s.\\n\", Settings.TraceHCEvent ? \"enabled\" : \"disabled\");\n\t}\n\n\t// TODO: reactivate once APU debugger works again\n\tif (*Line == 'A')\n\t{\n\t\tSettings.TraceSMP = !Settings.TraceSMP;\n\t\tprintf(\"SMP tracing %s\\n\", Settings.TraceSMP ? \"enabled\" : \"disabled\");\n\t}\n\n/*\n\tif (*Line == 'B')\n\t{\n\t\tSettings.TraceSoundDSP = !Settings.TraceSoundDSP;\n\t\tprintf(\"Sound DSP register tracing %s.\\n\", Settings.TraceSoundDSP ? \"enabled\" : \"disabled\");\n\t}\n\n\tif (*Line == 'x')\n\t\tS9xPrintSoundDSPState();\n\n\tif (*Line == 'C')\n\t{\n\t\tprintf(\"SPC700 sample addresses at 0x%04x:\\n\", APU.DSP[APU_DIR] << 8);\n\n\t\tfor (int i = 0; i < 256; i++)\n\t\t{\n\t\t\tuint8\t*dir = IAPU.RAM + (((APU.DSP[APU_DIR] << 8) + i * 4) & 0xffff);\n\t\t\tint\t\taddr = *dir + (*(dir + 1) << 8);\n\t\t\tint\t\taddr2 = *(dir + 2) + (*(dir + 3) << 8);\n\t\t\tprintf(\"%04X %04X;\", addr, addr2);\n\n\t\t\tif (i % 8 == 7)\n\t\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n*/\n\n\tif (*Line == 'R')\n\t{\n\t\tS9xReset();\n\t\tprintf(\"SNES reset.\\n\");\n\t\tCPU.Flags |= DEBUG_MODE_FLAG;\n\t}\n\n/*\n\tif (strncmp(Line, \"ad\", 2) == 0)\n\t{\n\t\tuint32\tCount = 16;\n\t\tAddress = 0;\n\n\t\tif (sscanf(Line + 2, \"%x,%x\", &Address, &Count) != 2)\n\t\t{\n\t\t\tif (sscanf(Line + 2, \"%x\", &Address) == 1)\n\t\t\t\tCount = 16;\n\t\t}\n\n\t\tprintf(\"APU RAM dump:\\n\");\n\n\t\tfor (uint32 l = 0; l < Count; l += 16)\n\t\t{\n\t\t\tprintf(\"%04X \", Address);\n\n\t\t\tfor (int i = 0; i < 16; i++)\n\t\t\t\tprintf(\"%02X \", IAPU.RAM[Address++]);\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\t*Line = 0;\n\t}*/\n\n\n\n\tif (*Line == 'a')\n\t{\n\t\tprintf(\"S-CPU-side ports S-CPU writes these, S-SMP reads: %02X %02X %02X %02X\\n\", SNES::cpu.port_read(0), SNES::cpu.port_read(1), SNES::cpu.port_read(2), SNES::cpu.port_read(3));\n\t\tprintf(\"S-SMP-side ports S-SMP writes these, S-CPU reads: %02X %02X %02X %02X\\n\", SNES::smp.port_read(0), SNES::smp.port_read(1), SNES::smp.port_read(2), SNES::smp.port_read(3));\n\t}\n/*\n\tif (*Line == 'P')\n\t{\n\t\tSettings.TraceDSP = !Settings.TraceDSP;\n\t\tprintf(\"DSP tracing %s.\\n\", Settings.TraceDSP ? \"enabled\" : \"disabled\");\n\t}\n*/\n\n\tif (*Line == 'p')\n\t{\n\t\tS9xBreakpoint[5].Enabled = FALSE;\n\t\tAddress += debug_cpu_op_print(string, Bank, Address);\n\n\t\tif (strncmp(&string[18], \"JMP\", 3) != 0 &&\n\t\t    strncmp(&string[18], \"JML\", 3) != 0 &&\n\t\t    strncmp(&string[18], \"RT\" , 2) != 0 &&\n\t\t    strncmp(&string[18], \"BRA\", 3))\n\t\t{\n\t\t\tS9xBreakpoint[5].Enabled = TRUE;\n\t\t\tS9xBreakpoint[5].Bank = Bank;\n\t\t\tS9xBreakpoint[5].Address = Address;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCPU.Flags |= SINGLE_STEP_FLAG;\n\t\t\tCPU.Flags &= ~DEBUG_MODE_FLAG;\n\t\t}\n\t}\n\n\tif (*Line == 'b')\n\t{\n\t\tif (Line[1] == 's')\n\t\t{\n\t\t\tdebug_get_number(Line + 2, &Hold);\n\n\t\t\tif (Hold > 4)\n\t\t\t\tHold = 0;\n\n\t\t\tif (Hold < 5)\n\t\t\t{\n\t\t\t\tif (debug_get_start_address(Line + 5, &Bank, &Address) == -1)\n\t\t\t\t\tS9xBreakpoint[Hold].Enabled = FALSE;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tS9xBreakpoint[Hold].Enabled = TRUE;\n\t\t\t\t\tS9xBreakpoint[Hold].Bank = Bank;\n\t\t\t\t\tS9xBreakpoint[Hold].Address = Address;\n\t\t\t\t\tCPU.Flags |= BREAK_FLAG;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLine[1] = 'v';\n\t\t}\n\n\t\tif (Line[1] == 'v')\n\t\t{\n\t\t\tNumber = 0;\n\n\t\t\tif (debug_get_number(Line + 2, &Number) == -1 && Number < 5)\n\t\t\t{\n\t\t\t\tdebug_line_print(\"Breakpoints:\");\n\n\t\t\t\tfor (Number = 0; Number != 5; Number++)\n\t\t\t\t{\n\t\t\t\t\tif (S9xBreakpoint[Number].Enabled)\n\t\t\t\t\t\tsprintf(string, \"%i @ $%02X:%04X\", Number, S9xBreakpoint[Number].Bank, S9xBreakpoint[Number].Address);\n\t\t\t\t\telse\n\t\t\t\t\t\tsprintf(string, \"%i @ Disabled\", Number);\n\n\t\t\t\t\tdebug_line_print(string);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdebug_line_print(\"Breakpoint:\");\n\n\t\t\t\tif (S9xBreakpoint[Number].Enabled)\n\t\t\t\t\tsprintf(string, \"%i @ $%02X:%04X\", Number, S9xBreakpoint[Number].Bank, S9xBreakpoint[Number].Address);\n\t\t\t\telse\n\t\t\t\t\tsprintf(string, \"%i @ Disabled\", Number);\n\n\t\t\t\tdebug_line_print(string);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*Line == '?' || strcasecmp(Line, \"help\") == 0)\n\t{\n\t\tfor (int i = 0; HelpMessage[i] != NULL; i++)\n\t\t\tdebug_line_print(HelpMessage[i]);\n\t}\n\n\tif (*Line == 't')\n\t{\n\t\tCPU.Flags |= SINGLE_STEP_FLAG;\n\t\tCPU.Flags &= ~DEBUG_MODE_FLAG;\n\t}\n\n\tif (*Line == 'f')\n\t{\n\t\tCPU.Flags |= FRAME_ADVANCE_FLAG;\n\t\tCPU.Flags &= ~DEBUG_MODE_FLAG;\n\n\t\tIPPU.RenderThisFrame = TRUE;\n\t\tIPPU.FrameSkip = 0;\n\n\t\tif (sscanf(&Line[1], \"%u\", &ICPU.FrameAdvanceCount) != 1)\n\t\t\tICPU.Frame = 0;\n\t}\n\n\tif (*Line == 'g')\n\t{\n\t\tS9xBreakpoint[5].Enabled = FALSE;\n\n\t\tbool8\tfound = FALSE;\n\n\t\tfor (int i = 0; i < 5; i++)\n\t\t{\n\t\t\tif (S9xBreakpoint[i].Enabled)\n\t\t\t{\n\t\t\t\tfound = TRUE;\n\n\t\t\t\tif (S9xBreakpoint[i].Bank == Registers.PB && S9xBreakpoint[i].Address == Registers.PCw)\n\t\t\t\t{\n\t\t\t\t\tS9xBreakpoint[i].Enabled = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\tCPU.Flags &= ~BREAK_FLAG;\n\n\t\tErrorCode = debug_get_start_address(Line, &Bank, &Address);\n\n\t\tif (ErrorCode == 1)\n\t\t{\n\t\t\tS9xBreakpoint[5].Enabled = TRUE;\n\t\t\tS9xBreakpoint[5].Bank = Bank;\n\t\t\tS9xBreakpoint[5].Address = Address;\n\t\t\tCPU.Flags |= BREAK_FLAG;\n\t\t}\n\n\t\tCPU.Flags &= ~DEBUG_MODE_FLAG;\n\t}\n\n\tif (*Line == 'D')\n\t{\n\t\tSettings.TraceDMA = !Settings.TraceDMA;\n\t\tprintf(\"DMA tracing %s.\\n\", Settings.TraceDMA ? \"enabled\" : \"disabled\");\n\t}\n\n\tif (*Line == 'V')\n\t{\n\t\tSettings.TraceVRAM = !Settings.TraceVRAM;\n\t\tprintf(\"Non-DMA VRAM write tracing %s.\\n\", Settings.TraceVRAM ? \"enabled\" : \"disabled\");\n\t}\n\n\tif (*Line == 'H')\n\t{\n\t\tSettings.TraceHDMA = !Settings.TraceHDMA;\n\t\tprintf(\"HDMA tracing %s.\\n\", Settings.TraceHDMA ? \"enabled\" : \"disabled\");\n\t}\n\n\tif (*Line == 'U')\n\t{\n\t\tSettings.TraceUnknownRegisters = !Settings.TraceUnknownRegisters;\n\t\tprintf(\"Unknown registers read/write tracing %s.\\n\", Settings.TraceUnknownRegisters ? \"enabled\" : \"disabled\");\n\t}\n\n\tif (*Line == 'd')\n\t{\n\t\tint\t\tCLine;\n\t\tint\t\tCByte;\n\t\tuint8\tMemoryByte;\n\n\t\tif (Debug.Dump.Bank != 0 || Debug.Dump.Address != 0)\n\t\t{\n\t\t\tBank = Debug.Dump.Bank;\n\t\t\tAddress = Debug.Dump.Address;\n\t\t}\n\n\t\tErrorCode = debug_get_start_address(Line, &Bank, &Address);\n\n\t\tfor (CLine = 0; CLine != 10; CLine++)\n\t\t{\n\t\t\tsprintf(string, \"$%02X:%04X\", Bank, Address);\n\n\t\t\tfor (CByte = 0; CByte != 16; CByte++)\n\t\t\t{\n\t\t\t\tif (Address + CByte == 0x2140 ||\n\t\t\t\t    Address + CByte == 0x2141 ||\n\t\t\t\t    Address + CByte == 0x2142 ||\n\t\t\t\t    Address + CByte == 0x2143 ||\n\t\t\t\t    Address + CByte == 0x4210)\n\t\t\t\t\tMemoryByte = 0;\n\t\t\t\telse\n\t\t\t\t\tMemoryByte = S9xDebugGetByte((Bank << 16) + Address + CByte);\n\n\t\t\t\tsprintf(string, \"%s %02X\", string, MemoryByte);\n\t\t\t}\n\n\t\t\tsprintf(string, \"%s-\", string);\n\n\t\t\tfor (CByte = 0; CByte != 16; CByte++)\n\t\t\t{\n\t\t\t\tif (Address + CByte == 0x2140 ||\n\t\t\t\t    Address + CByte == 0x2141 ||\n\t\t\t\t    Address + CByte == 0x2142 ||\n\t\t\t\t    Address + CByte == 0x2143 ||\n\t\t\t\t    Address + CByte == 0x4210)\n\t\t\t\t\tMemoryByte = 0;\n\t\t\t\telse\n\t\t\t\t\tMemoryByte = S9xDebugGetByte((Bank << 16) + Address + CByte);\n\n\t\t\t\tif (MemoryByte < 32 || MemoryByte >= 127)\n\t\t\t\t\tMemoryByte = '?';\n\n\t\t\t\tsprintf(string, \"%s%c\", string, MemoryByte);\n\t\t\t}\n\n\t\t\tAddress += 16;\n\n\t\t\tdebug_line_print(string);\n\t\t}\n\n\t\tDebug.Dump.Bank = Bank;\n\t\tDebug.Dump.Address = Address;\n\t}\n\n\tif (*Line == 'q')\n\t\tS9xExit();\n\n\tif (*Line == 'W')\n\t\tdebug_whats_missing();\n\n\tif (*Line == 'w')\n\t\tdebug_whats_used();\n\n\tif (*Line == 'r')\n\t{\n\t\tdebug_cpu_op_print(string, Bank, Address);\n\t\tdebug_line_print(string);\n\t}\n\n\tif (*Line == 'u')\n\t{\n\t\tif (Debug.Unassemble.Bank != 0 || Debug.Unassemble.Address != 0)\n\t\t{\n\t\t\tBank = Debug.Unassemble.Bank;\n\t\t\tAddress = Debug.Unassemble.Address;\n\t\t}\n\n\t\tErrorCode = debug_get_start_address(Line, &Bank, &Address);\n\n\t\tfor (int i = 0; i != 10; i++)\n\t\t{\n\t\t\tAddress += debug_cpu_op_print(string, Bank, Address);\n\t\t\tdebug_line_print(string);\n\t\t}\n\n\t\tDebug.Unassemble.Bank = Bank;\n\t\tDebug.Unassemble.Address = Address;\n\t}\n\n\tdebug_line_print(\"\");\n\n\treturn;\n}\n\nstatic void debug_print_window (uint8 *window)\n{\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tif (window[i])\n\t\t{\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tprintf(\"Background 0, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tprintf(\"Background 1, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tprintf(\"Background 2, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tprintf(\"Background 3, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tprintf(\"Objects, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 5:\n\t\t\t\t\tprintf(\"Color window, \");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const char * debug_clip_fn (int logic)\n{\n\tswitch (logic)\n\t{\n\t\tcase CLIP_OR:\n\t\t\treturn (\"OR\");\n\n\t\tcase CLIP_AND:\n\t\t\treturn (\"AND\");\n\n\t\tcase CLIP_XOR:\n\t\t\treturn (\"XOR\");\n\n\t\tcase CLIP_XNOR:\n\t\t\treturn (\"XNOR\");\n\n\t\tdefault:\n\t\t\treturn (\"???\");\n\t}\n}\n\nstatic void debug_whats_used (void)\n{\n\tprintf(\"V-line: %ld, H-Pos: %ld, \\n\", (long) CPU.V_Counter, (long) CPU.Cycles);\n\n\tprintf(\"Screen mode: %d, \", PPU.BGMode);\n\n\tif (PPU.BGMode <= 1 && (Memory.FillRAM[0x2105] & 8))\n\t\tprintf(\"(BG#2 Priority), \");\n\n\tprintf(\"Brightness: %d, \", PPU.Brightness);\n\n\tif (Memory.FillRAM[0x2100] & 0x80)\n\t\tprintf(\"(screen blanked), \");\n\n\tprintf(\"\\n\");\n\n\tif (Memory.FillRAM[0x2133] & 1)\n\t\tprintf(\"Interlace, \");\n\n\tif (Memory.FillRAM[0x2133] & 4)\n\t\tprintf(\"240 line visible, \");\n\n\tif (Memory.FillRAM[0x2133] & 8)\n\t\tprintf(\"Pseudo 512 pixels horizontal resolution, \");\n\n\tif (Memory.FillRAM[0x2133] & 0x40)\n\t\tprintf(\"Mode 7 priority per pixel, \");\n\n\tprintf(\"\\n\");\n\n\tif (PPU.BGMode == 7 && (Memory.FillRAM[0x211a] & 3))\n\t\tprintf(\"Mode 7 flipping, \");\n\n\tif (PPU.BGMode == 7)\n\t\tprintf(\"Mode 7 screen repeat: %d, \", (Memory.FillRAM[0x211a] & 0xc0) >> 6);\n\n\tif (Memory.FillRAM[0x2130] & 1)\n\t\tprintf(\"32K colour mode, \");\n\n\tprintf(\"\\n\");\n\n\tif (PPU.BGMode == 7)\n\t{\n\t\t// Sign extend 13 bit values to 16 bit values...\n\t\tif (PPU.CentreX & (1 << 12))\n\t\t\tPPU.CentreX |= 0xe000;\n\n\t\tif (PPU.CentreY & (1 << 12))\n\t\t\tPPU.CentreY |= 0xe000;\n\n\t\tprintf(\"Matrix A: %.3f, B: %.3f, C: %.3f, D: %.3f, Centre X: %d Y:%d, \\n\",\n\t\t       (double) PPU.MatrixA / 256, (double) PPU.MatrixB / 256,\n\t\t       (double) PPU.MatrixC / 256, (double) PPU.MatrixD / 256,\n\t\t       PPU.CentreX, PPU.CentreY);\n\t}\n\n\tif ((Memory.FillRAM[0x2106] & 0xf0) && (Memory.FillRAM[0x2106] & 0x0f))\n\t{\n\t\tprintf(\"Mosaic effect(%d) on, \", PPU.Mosaic);\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tif (Memory.FillRAM[0x2106] & (1 << i))\n\t\t\t\tprintf(\"BG%d, \", i);\n\t}\n\n\tprintf(\"\\n\");\n\n\tif (PPU.HVBeamCounterLatched)\n\t\tprintf(\"V and H beam pos latched, \\n\");\n\n\tif (Memory.FillRAM[0x4200] & 0x20)\n\t\tprintf(\"V-IRQ enabled at %d, \\n\", PPU.IRQVBeamPos);\n\n\tif (Memory.FillRAM[0x4200] & 0x10)\n\t\tprintf(\"H-IRQ enabled at %d, \\n\", PPU.IRQHBeamPos);\n\n\tif (Memory.FillRAM[0x4200] & 0x80)\n\t\tprintf(\"V-blank NMI enabled, \\n\");\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (missing.hdma_this_frame & (1 << i))\n\t\t{\n\t\t\tprintf(\"H-DMA %d [%d] 0x%02X%04X->0x21%02X %s %s 0x%02X%04X %s addressing, \\n\",\n\t\t\t       i, DMA[i].TransferMode, DMA[i].ABank, DMA[i].AAddress, DMA[i].BAddress,\n\t\t\t       DMA[i].AAddressDecrement ? \"dec\" : \"inc\",\n\t\t\t       DMA[i].Repeat ? \"repeat\" : \"continue\",\n\t\t\t       DMA[i].IndirectBank, DMA[i].IndirectAddress,\n\t\t\t       DMA[i].HDMAIndirectAddressing ? \"indirect\" : \"absolute\");\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (missing.dma_this_frame & (1 << i))\n\t\t{\n\t\t\tprintf(\"DMA %d [%d] 0x%02X%04X->0x21%02X Num: %d %s, \\n\",\n\t\t\t       i, DMA[i].TransferMode, DMA[i].ABank, DMA[i].AAddress, DMA[i].BAddress, DMA[i].TransferBytes,\n\t\t\t       DMA[i].AAddressFixed ? \"fixed\" : (DMA[i].AAddressDecrement ? \"dec\" : \"inc\"));\n\t\t}\n\t}\n\n\tprintf(\"VRAM write address: 0x%04x(%s), Full Graphic: %d, Address inc: %d, \\n\",\n\t       PPU.VMA.Address,\n\t       PPU.VMA.High  ? \"Byte\" : \"Word\",\n\t       PPU.VMA.FullGraphicCount, PPU.VMA.Increment);\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tprintf(\"BG%d: VOffset:%d, HOffset:%d, W:%d, H:%d, TS:%d, BA:0x%04x, TA:0x%04X, \\n\",\n\t\t       i, PPU.BG[i].VOffset, PPU.BG[i].HOffset,\n\t\t       (PPU.BG[i].SCSize & 1) * 32 + 32,\n\t\t       (PPU.BG[i].SCSize & 2) * 16 + 32,\n\t\t       PPU.BG[i].BGSize * 8 + 8,\n\t\t       PPU.BG[i].SCBase,\n\t\t       PPU.BG[i].NameBase);\n\t}\n\n\tconst char\t*s = \"\";\n\n\tswitch ((Memory.FillRAM[0x2130] & 0xc0) >> 6)\n\t{\n\t\tcase 0:\n\t\t\ts = \"always on\";\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\ts = \"inside\";\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\ts = \"outside\";\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\ts = \"always off\";\n\t\t\tbreak;\n\t}\n\n\tprintf(\"Main screen (%s): \", s);\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif (Memory.FillRAM[0x212c] & (1 << i))\n\t\t{\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tprintf(\"BG0, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tprintf(\"BG1, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tprintf(\"BG2, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tprintf(\"BG3, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tprintf(\"OBJ, \");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n\n\tswitch ((Memory.FillRAM[0x2130] & 0x30) >> 4)\n\t{\n\t\tcase 0:\n\t\t\ts = \"always on\";\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\ts = \"inside\";\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\ts = \"outside\";\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\ts = \"always off\";\n\t\t\tbreak;\n\t}\n\n\tprintf(\"Subscreen (%s): \", s);\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif (Memory.FillRAM[0x212d] & (1 << i))\n\t\t{\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tprintf(\"BG0, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tprintf(\"BG1, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tprintf(\"BG2, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tprintf(\"BG3, \");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tprintf(\"OBJ, \");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n\n\tif ((Memory.FillRAM[0x2131] & 0x3f))\n\t{\n\t\tif (Memory.FillRAM[0x2131] & 0x80)\n\t\t{\n\t\t\tif (Memory.FillRAM[0x2130] & 0x02)\n\t\t\t\tprintf(\"Subscreen subtract\");\n\t\t\telse\n\t\t\t\tprintf(\"Fixed colour subtract\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Memory.FillRAM[0x2130] & 0x02)\n\t\t\t\tprintf(\"Subscreen addition\");\n\t\t\telse\n\t\t\t\tprintf(\"Fixed colour addition\");\n\t\t}\n\n\t\tif (Memory.FillRAM[0x2131] & 0x40)\n\t\t\tprintf(\"(half): \");\n\t\telse\n\t\t\tprintf(\": \");\n\n\t\tfor (int i = 0; i < 6; i++)\n\t\t{\n\t\t\tif (Memory.FillRAM[0x2131] & (1 << i))\n\t\t\t{\n\t\t\t\tswitch (i)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tprintf(\"BG0, \");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tprintf(\"BG1, \");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tprintf(\"BG2, \");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tprintf(\"BG3, \");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tprintf(\"OBJ, \");\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tprintf(\"BACK, \");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t}\n\n\tprintf(\"Window 1 (%d, %d, %02x, %02x): \", PPU.Window1Left, PPU.Window1Right, Memory.FillRAM[0x212e], Memory.FillRAM[0x212f]);\n\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tif (PPU.ClipWindow1Enable[i])\n\t\t{\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tprintf(\"BG0(%s-%s), \", PPU.ClipWindow1Inside[0] ? \"I\" : \"O\", debug_clip_fn(PPU.ClipWindowOverlapLogic[0]));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tprintf(\"BG1(%s-%s), \", PPU.ClipWindow1Inside[1] ? \"I\" : \"O\", debug_clip_fn(PPU.ClipWindowOverlapLogic[1]));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tprintf(\"BG2(%s-%s), \", PPU.ClipWindow1Inside[2] ? \"I\" : \"O\", debug_clip_fn(PPU.ClipWindowOverlapLogic[2]));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tprintf(\"BG3(%s-%s), \", PPU.ClipWindow1Inside[3] ? \"I\" : \"O\", debug_clip_fn(PPU.ClipWindowOverlapLogic[3]));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tprintf(\"OBJ(%s-%s), \", PPU.ClipWindow1Inside[4] ? \"I\" : \"O\", debug_clip_fn(PPU.ClipWindowOverlapLogic[4]));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 5:\n\t\t\t\t\tprintf(\"COL(%s-%s), \", PPU.ClipWindow1Inside[5] ? \"I\" : \"O\", debug_clip_fn(PPU.ClipWindowOverlapLogic[5]));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n\n\tprintf(\"Window 2 (%d, %d): \", PPU.Window2Left, PPU.Window2Right);\n\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tif (PPU.ClipWindow2Enable[i])\n\t\t{\n\t\t\tswitch (i)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tprintf(\"BG0(%s), \", PPU.ClipWindow2Inside[0] ? \"I\" : \"O\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tprintf(\"BG1(%s), \", PPU.ClipWindow2Inside[1] ? \"I\" : \"O\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tprintf(\"BG2(%s), \", PPU.ClipWindow2Inside[2] ? \"I\" : \"O\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tprintf(\"BG3(%s), \", PPU.ClipWindow2Inside[3] ? \"I\" : \"O\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tprintf(\"OBJ(%s), \", PPU.ClipWindow2Inside[4] ? \"I\" : \"O\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 5:\n\t\t\t\t\tprintf(\"COL(%s), \" , PPU.ClipWindow2Inside[5] ? \"I\" : \"O\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n\n\tprintf(\"Fixed colour: %02x%02x%02x, \\n\", PPU.FixedColourRed, PPU.FixedColourGreen, PPU.FixedColourBlue);\n}\n\nstatic void debug_whats_missing (void)\n{\n\tprintf(\"Processor: \");\n\n\tif (missing.emulate6502)\n\t\tprintf(\"emulation mode, \");\n\n\tif (missing.decimal_mode)\n\t\tprintf(\"decimal mode, \");\n\n\tif (missing.mv_8bit_index)\n\t\tprintf(\"MVP/MVN with 8bit index registers and XH or YH > 0, \");\n\n\tif (missing.mv_8bit_acc)\n\t\tprintf(\"MVP/MVN with 8bit accumulator > 255, \");\n\n\tprintf(\"\\n\");\n\n\tprintf(\"Screen modes used: \");\n\n\tfor (int i = 0; i < 8; i++)\n\t\tif (missing.modes[i])\n\t\t\tprintf(\"%d, \", i);\n\n\tprintf(\"\\n\");\n\n\tif (missing.interlace)\n\t\tprintf(\"Interlace, \");\n\n\tif (missing.pseudo_512)\n\t\tprintf(\"Pseudo 512 pixels horizontal resolution, \");\n\n\tif (missing.lines_239)\n\t\tprintf(\"240 lines visible, \");\n\n\tif (missing.sprite_double_height)\n\t\tprintf(\"double-hight sprites, \");\n\n\tprintf(\"\\n\");\n\n\tif (missing.mode7_fx)\n\t\tprintf(\"Mode 7 rotation/scaling, \");\n\n\tif (missing.matrix_read)\n\t\tprintf(\"Mode 7 read matrix registers, \");\n\n\tif (missing.mode7_flip)\n\t\tprintf(\"Mode 7 flipping, \");\n\n\tif (missing.mode7_bgmode)\n\t\tprintf(\"Mode 7 priority per pixel, \");\n\n\tif (missing.direct)\n\t\tprintf(\"Direct 32000 colour mode, \");\n\n\tprintf(\"\\n\");\n\n\tif (missing.mosaic)\n\t\tprintf(\"Mosaic effect, \");\n\n\tif (missing.subscreen)\n\t\tprintf(\"Subscreen enabled, \");\n\n\tif (missing.subscreen_add)\n\t\tprintf(\"Subscreen colour add, \");\n\n\tif (missing.subscreen_sub)\n\t\tprintf(\"Subscreen colour subtract, \");\n\n\tif (missing.fixed_colour_add)\n\t\tprintf(\"Fixed colour add, \");\n\n\tif (missing.fixed_colour_sub)\n\t\tprintf(\"Fixed colour subtract, \");\n\n\tprintf(\"\\n\");\n\n\tprintf(\"Window 1 enabled on: \");\n\tdebug_print_window(missing.window1);\n\n\tprintf(\"\\n\");\n\t\n\tprintf(\"Window 2 enabled on: \");\n\tdebug_print_window(missing.window2);\n\n\tprintf(\"\\n\");\n\n\tif (missing.bg_offset_read)\n\t\tprintf(\"BG offset read, \");\n\n\tif (missing.oam_address_read)\n\t\tprintf(\"OAM address read, \");\n\n\tif (missing.sprite_priority_rotation)\n\t\tprintf(\"Sprite priority rotation, \");\n\n\tif (missing.fast_rom)\n\t\tprintf(\"Fast 3.58MHz ROM access enabled, \");\n\n\tif (missing.matrix_multiply)\n\t\tprintf(\"Matrix multiply 16bit by 8bit used, \");\n\n\tprintf(\"\\n\");\n\n\tif (missing.virq)\n\t\tprintf(\"V-IRQ used at line %d, \", missing.virq_pos);\n\n\tif (missing.hirq)\n\t\tprintf(\"H-IRQ used at position %d, \", missing.hirq_pos);\n\n\tprintf(\"\\n\");\n\n\tif (missing.h_v_latch)\n\t\tprintf(\"H and V-Pos latched, \");\n\n\tif (missing.h_counter_read)\n\t\tprintf(\"H-Pos read, \");\n\n\tif (missing.v_counter_read)\n\t\tprintf(\"V-Pos read, \");\n\n\tprintf(\"\\n\");\n\n\tif (missing.oam_read)\n\t\tprintf(\"OAM read, \");\n\n\tif (missing.vram_read)\n\t\tprintf(\"VRAM read, \");\n\n\tif (missing.cgram_read)\n\t\tprintf(\"CG-RAM read, \");\n\n\tif (missing.wram_read)\n\t\tprintf(\"WRAM read, \");\n\n\tif (missing.dma_read)\n\t\tprintf(\"DMA read, \");\n\n\tif (missing.vram_inc)\n\t\tprintf(\"VRAM inc: %d, \", missing.vram_inc);\n\n\tif (missing.vram_full_graphic_inc)\n\t\tprintf(\"VRAM full graphic inc: %d, \", missing.vram_full_graphic_inc);\n\n\tprintf(\"\\n\");\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (missing.hdma[i].used)\n\t\t{\n\t\t\tprintf(\"HDMA %d 0x%02X%04X->0x21%02X %s, \",\n\t\t\t       i, missing.hdma[i].abus_bank, missing.hdma[i].abus_address, missing.hdma[i].bbus_address,\n\t\t\t       missing.hdma[i].indirect_address ? \"indirect\" : \"absolute\");\n\n\t\t\tif (missing.hdma[i].force_table_address_write)\n\t\t\t\tprintf(\"Forced address write, \");\n\n\t\t\tif (missing.hdma[i].force_table_address_read)\n\t\t\t\tprintf(\"Current address read, \");\n\n\t\t\tif (missing.hdma[i].line_count_write)\n\t\t\t\tprintf(\"Line count write, \");\n\n\t\t\tif (missing.hdma[i].line_count_read)\n\t\t\t\tprintf(\"Line count read, \");\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (missing.dma_channels & (1 << i))\n\t\t{\n\t\t\tprintf(\"DMA %d [%d] 0x%02X%04X->0x21%02X Num: %d %s, \\n\",\n\t\t\t       i, DMA[i].TransferMode, DMA[i].ABank, DMA[i].AAddress, DMA[i].BAddress, DMA[i].TransferBytes,\n\t\t\t       DMA[i].AAddressFixed ? \"fixed\" : (DMA[i].AAddressDecrement ? \"dec\" : \"inc\"));\n\t\t}\n\t}\n\n\tif (missing.unknownppu_read)\n\t\tprintf(\"Read from unknown PPU register: $%04X, \\n\", missing.unknownppu_read);\n\n\tif (missing.unknownppu_write)\n\t\tprintf(\"Write to unknown PPU register: $%04X, \\n\", missing.unknownppu_write);\n\n\tif (missing.unknowncpu_read)\n\t\tprintf(\"Read from unknown CPU register: $%04X, \\n\", missing.unknowncpu_read);\n\n\tif (missing.unknowncpu_write)\n\t\tprintf(\"Write to unknown CPU register: $%04X, \\n\", missing.unknowncpu_write);\n\n\tif (missing.unknowndsp_read)\n\t\tprintf(\"Read from unknown DSP register: $%04X, \\n\", missing.unknowndsp_read);\n\n\tif (missing.unknowndsp_write)\n\t\tprintf(\"Write to unknown DSP register: $%04X, \\n\", missing.unknowndsp_write);\n}\n\nvoid S9xDoDebug (void)\n{\n\tchar\tLine[513];\n\n\tDebug.Dump.Bank = 0;\n\tDebug.Dump.Address = 0;\n\tDebug.Unassemble.Bank = 0;\n\tDebug.Unassemble.Address = 0;\n\n\tS9xTextMode();\n\n\tstrcpy(Line, \"r\");\n\tS9xDebugProcessCommand(Line);\n\n\twhile (CPU.Flags & DEBUG_MODE_FLAG)\n\t{\n\t\tint32\tCycles;\n\t\tchar\t*p;\n\n\t\tprintf(\"> \");\n\t\tfflush(stdout);\n\n\t\tp = fgets(Line, sizeof(Line) - 1, stdin);\n\t\tLine[strlen(Line) - 1] = 0;\n\n\t\tCycles = CPU.Cycles;\n\t\tS9xDebugProcessCommand(Line);\n\t\tCPU.Cycles = Cycles;\n\t}\n\n\tif (!(CPU.Flags & SINGLE_STEP_FLAG))\n\t\tS9xGraphicsMode();\n}\n\nvoid S9xTrace (void)\n{\n\tchar\tmsg[512];\n\n\tENSURE_TRACE_OPEN(trace, \"trace.log\", \"a\")\n\n\tdebug_cpu_op_print(msg, Registers.PB, Registers.PCw);\n\tfprintf(trace, \"%s\\n\", msg);\n}\n\nvoid S9xSA1Trace (void)\n{\n\tchar\tmsg[512];\n\n\tENSURE_TRACE_OPEN(trace2, \"trace_sa1.log\", \"a\")\n\n\tdebug_sa1_op_print(msg, SA1Registers.PB, SA1Registers.PCw);\n\tfprintf(trace2, \"%s\\n\", msg);\n}\n\nvoid S9xTraceMessage (const char *s)\n{\n\tif (s)\n\t{\n\t\tif (trace)\n\t\t\tfprintf(trace, \"%s\\n\", s);\n\t\telse\n\t\tif (trace2)\n\t\t\tfprintf(trace2, \"%s\\n\", s);\n\t}\n}\n\nvoid S9xTraceFormattedMessage (const char *s, ...)\n{\n\tchar\tmsg[512];\n\n\tif (s)\n\t{\n\t\tva_list\targptr;\n\n\t\tva_start(argptr, s);\n\t\tvsprintf(msg, s, argptr);\n\t\tva_end(argptr);\n\n\t\tS9xTraceMessage(msg);\n\t}\n}\n\nvoid S9xPrintHVPosition (char *s)\n{\n\tsprintf(s, \"HC:%04ld VC:%03ld FC:%02d\", (long) CPU.Cycles, (long) CPU.V_Counter, IPPU.FrameCount);\n}\n\n#endif\n"
        },
        {
          "name": "debug.h",
          "type": "blob",
          "size": 0.958984375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifdef DEBUGGER\n\n#ifndef _DEBUG_H_\n#define _DEBUG_H_\n\n#include <string>\n\nstruct SBreakPoint\n{\n\tbool8\tEnabled;\n\tuint8\tBank;\n\tuint16\tAddress;\n};\n\n#define ENSURE_TRACE_OPEN(fp, file, mode) \\\n\tif (!fp) \\\n\t{ \\\n\t\tstd::string fn = S9xGetDirectory(LOG_DIR); \\\n\t\tfn += SLASH_STR file; \\\n\t\tfp = fopen(fn.c_str(), mode); \\\n\t}\n\nextern struct SBreakPoint\tS9xBreakpoint[6];\n\nvoid S9xDoDebug (void);\nvoid S9xTrace (void);\nvoid S9xSA1Trace (void);\nvoid S9xTraceMessage (const char *);\nvoid S9xTraceFormattedMessage (const char *, ...);\nvoid S9xPrintHVPosition (char *);\nvoid S9xDebugProcessCommand(char *);\n\n#endif\n\n#endif\n"
        },
        {
          "name": "display.h",
          "type": "blob",
          "size": 1.4248046875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _DISPLAY_H_\n#define _DISPLAY_H_\n\n#include \"snes9x.h\"\n\nvoid S9xUsage (void);\nchar * S9xParseArgs (char **, int);\nvoid S9xParseArgsForCheats (char **, int);\nvoid S9xLoadConfigFiles (char **, int);\nvoid S9xSetInfoString (const char *);\n\n// Routines the port has to implement even if it doesn't use them\n\nvoid S9xPutImage (int, int);\nvoid S9xInitDisplay (int, char **);\nvoid S9xDeinitDisplay (void);\nvoid S9xTextMode (void);\nvoid S9xGraphicsMode (void);\nvoid S9xToggleSoundChannel (int);\nbool8 S9xOpenSnapshotFile (const char *, bool8, STREAM *);\nvoid S9xCloseSnapshotFile (STREAM);\nconst char * S9xStringInput (const char *);\n\n// Routines the port has to implement if it uses command-line\n\nvoid S9xExtraUsage (void);\nvoid S9xParseArg (char **, int &, int);\n\n// Routines the port may implement as needed\n\nvoid S9xExtraDisplayUsage (void);\nvoid S9xParseDisplayArg (char **, int &, int);\nvoid S9xSetTitle (const char *);\nvoid S9xInitInputDevices (void);\nvoid S9xProcessEvents (bool8);\nconst char * S9xSelectFilename (const char *, const char *, const char *, const char *);\n\n#endif\n"
        },
        {
          "name": "dma.cpp",
          "type": "blob",
          "size": 38.763671875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"dma.h\"\n#include \"apu/apu.h\"\n#include \"sdd1emu.h\"\n#include \"spc7110emu.h\"\n#ifdef DEBUGGER\n#include \"missing.h\"\n#endif\n\n#define ADD_CYCLES(n)\t{ CPU.Cycles += (n); }\n\nextern uint8\t*HDMAMemPointers[8];\nextern int\t\tHDMA_ModeByteCounts[8];\nextern SPC7110\ts7emu;\n\nstatic uint8\tsdd1_decode_buffer[0x10000];\n\nstatic inline bool8 addCyclesInDMA (uint8);\nstatic inline bool8 HDMAReadLineCount (int);\n\n\nstatic inline bool8 addCyclesInDMA (uint8 dma_channel)\n{\n\t// Add 8 cycles per byte, sync APU, and do HC related events.\n\t// If HDMA was done in S9xDoHEventProcessing(), check if it used the same channel as DMA.\n\tADD_CYCLES(SLOW_ONE_CYCLE);\n\twhile (CPU.Cycles >= CPU.NextEvent)\n\t\tS9xDoHEventProcessing();\n\n\tif (CPU.HDMARanInDMA & (1 << dma_channel))\n\t{\n\t\tCPU.HDMARanInDMA = 0;\n\t#ifdef DEBUGGER\n\t\tprintf(\"HDMA and DMA use the same channel %d!\\n\", dma_channel);\n\t#endif\n\t\t// If HDMA triggers in the middle of DMA transfer and it uses the same channel,\n\t\t// it kills the DMA transfer immediately. $43x2 and $43x5 stop updating.\n\t\treturn (FALSE);\n\t}\n\n\tCPU.HDMARanInDMA = 0;\n\treturn (TRUE);\n}\n\nbool8 S9xDoDMA (uint8 Channel)\n{\n\tCPU.InDMA = TRUE;\n    CPU.InDMAorHDMA = TRUE;\n\tCPU.CurrentDMAorHDMAChannel = Channel;\n\n    SDMA\t*d = &DMA[Channel];\n\n\t// Check invalid DMA first\n\tif ((d->ABank == 0x7E || d->ABank == 0x7F) && d->BAddress == 0x80 && !d->ReverseTransfer)\n\t{\n\t\t// Attempting a DMA from WRAM to $2180 will not work, WRAM will not be written.\n\t\t// Attempting a DMA from $2180 to WRAM will similarly not work,\n\t\t// the value written is (initially) the OpenBus value.\n\t\t// In either case, the address in $2181-3 is not incremented.\n\n\t\t// Does an invalid DMA actually take time?\n\t\t// I'd say yes, since 'invalid' is probably just the WRAM chip\n\t\t// not being able to read and write itself at the same time\n\t\t// And no, PPU.WRAM should not be updated.\n\n\t\tint32\tc = d->TransferBytes;\n\t\t// Writing $0000 to $43x5 actually results in a transfer of $10000 bytes, not 0.\n\t\tif (c == 0)\n\t\t\tc = 0x10000;\n\n\t\t// 8 cycles per channel\n\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t// 8 cycles per byte\n\t\twhile (c)\n\t\t{\n\t\t\td->TransferBytes--;\n\t\t\td->AAddress++;\n\t\t\tc--;\n\t\t\tif (!addCyclesInDMA(Channel))\n\t\t\t{\n\t\t\t\tCPU.InDMA = FALSE;\n\t\t\t\tCPU.InDMAorHDMA = FALSE;\n\t\t\t\tCPU.CurrentDMAorHDMAChannel = -1;\n\t\t\t\treturn (FALSE);\n\t\t\t}\n\t\t}\n\n\t#ifdef DEBUGGER\n\t\tif (Settings.TraceDMA)\n\t\t{\n\t\t\tsprintf(String, \"DMA[%d]: WRAM Bank:%02X->$2180\", Channel, d->ABank);\n\t\t\tS9xMessage(S9X_TRACE, S9X_DMA_TRACE, String);\n\t\t}\n\t#endif\n\n\t\tCPU.InDMA = FALSE;\n\t\tCPU.InDMAorHDMA = FALSE;\n\t\tCPU.CurrentDMAorHDMAChannel = -1;\n\t\treturn (TRUE);\n\t}\n\n\t// Prepare for accessing $2118-2119\n\tswitch (d->BAddress)\n\t{\n\t\tcase 0x18:\n\t\tcase 0x19:\n\t\t\tif (IPPU.RenderThisFrame)\n\t\t\t\tFLUSH_REDRAW();\n\t\t\tbreak;\n\t}\n\n\tint32\tinc = d->AAddressFixed ? 0 : (!d->AAddressDecrement ? 1 : -1);\n\tint32\tcount = d->TransferBytes;\n\t// Writing $0000 to $43x5 actually results in a transfer of $10000 bytes, not 0.\n\tif (count == 0)\n\t\tcount = 0x10000;\n\n\t// Prepare for custom chip DMA\n\n\t// S-DD1\n\n\tuint8\t*in_sdd1_dma = NULL;\n\n\tif (Settings.SDD1)\n\t{\n\t\tif (d->AAddressFixed && Memory.FillRAM[0x4801] > 0)\n\t\t{\n\t\t\t// XXX: Should probably verify that we're DMAing from ROM?\n\t\t\t// And somewhere we should make sure we're not running across a mapping boundary too.\n\t\t\t// Hacky support for pre-decompressed S-DD1 data\n\t\t\tinc = !d->AAddressDecrement ? 1 : -1;\n\n\t\t\tuint8\t*in_ptr = S9xGetBasePointer(((d->ABank << 16) | d->AAddress));\n\t\t\tif (in_ptr)\n\t\t\t{\n\t\t\t\tin_ptr += d->AAddress;\n\t\t\t\tSDD1_decompress(sdd1_decode_buffer, in_ptr, d->TransferBytes);\n\t\t\t}\n\t\t#ifdef DEBUGGER\n\t\t\telse\n\t\t\t{\n\t\t\t\tsprintf(String, \"S-DD1: DMA from non-block address $%02X:%04X\", d->ABank, d->AAddress);\n\t\t\t\tS9xMessage(S9X_WARNING, S9X_DMA_TRACE, String);\n\t\t\t}\n\t\t#endif\n\n\t\t\tin_sdd1_dma = sdd1_decode_buffer;\n\t\t}\n\n\t\tMemory.FillRAM[0x4801] = 0;\n\t}\n\n\t// SPC7110\n\n\tuint8\t*spc7110_dma = NULL;\n\n\tif (Settings.SPC7110)\n\t{\n\t\tif (d->AAddress == 0x4800 || d->ABank == 0x50)\n\t\t{\n\t\t\tspc7110_dma = new uint8[d->TransferBytes];\n\t\t\tfor (int i = 0; i < d->TransferBytes; i++)\n\t\t\t\tspc7110_dma[i] = s7emu.decomp.read();\n\n\t\t\tint32\ticount = s7emu.r4809 | (s7emu.r480a << 8);\n\t\t\ticount -= d->TransferBytes;\n\t\t\ts7emu.r4809 =  icount & 0x00ff;\n\t\t\ts7emu.r480a = (icount & 0xff00) >> 8;\n\n\t\t\tinc = 1;\n\t\t\td->AAddress -= count;\n\t\t}\n\t}\n\n\t// SA-1\n\n\tbool8\tin_sa1_dma = FALSE;\n\n\tif (Settings.SA1)\n\t{\n\t\tif (SA1.in_char_dma && d->BAddress == 0x18 && (d->ABank & 0xf0) == 0x40)\n\t\t{\n\t\t\t// Perform packed bitmap to PPU character format conversion on the data\n\t\t\t// before transmitting it to V-RAM via-DMA.\n\t\t\tint32\tnum_chars = 1 << ((Memory.FillRAM[0x2231] >> 2) & 7);\n\t\t\tint32\tdepth = (Memory.FillRAM[0x2231] & 3) == 0 ? 8 : (Memory.FillRAM[0x2231] & 3) == 1 ? 4 : 2;\n\t\t\tint32\tbytes_per_char = 8 * depth;\n\t\t\tint32\tbytes_per_line = depth * num_chars;\n\t\t\tint32\tchar_line_bytes = bytes_per_char * num_chars;\n\t\t\tuint32\taddr = (d->AAddress / char_line_bytes) * char_line_bytes;\n\n\t\t\tuint8\t*base = S9xGetBasePointer((d->ABank << 16) + addr);\n\t\t\tif (!base)\n\t\t\t{\n\t\t\t\tsprintf(String, \"SA-1: DMA from non-block address $%02X:%04X\", d->ABank, addr);\n\t\t\t\tS9xMessage(S9X_WARNING, S9X_DMA_TRACE, String);\n\t\t\t\tbase = Memory.ROM;\n\t\t\t}\n\n\t\t\tbase += addr;\n\n\t\t\tuint8\t*buffer = &Memory.ROM[CMemory::MAX_ROM_SIZE - 0x10000];\n\t\t\tuint8\t*p = buffer;\n\t\t\tuint32\tinc_sa1 = char_line_bytes - (d->AAddress % char_line_bytes);\n\t\t\tuint32\tchar_count = inc_sa1 / bytes_per_char;\n\n\t\t\tin_sa1_dma = TRUE;\n\n\t\t#if 0\n\t\t\tprintf(\"SA-1 DMA: %08x,\", base);\n\t\t\tprintf(\"depth = %d, count = %d, bytes_per_char = %d, bytes_per_line = %d, num_chars = %d, char_line_bytes = %d\\n\",\n\t\t\t\tdepth, count, bytes_per_char, bytes_per_line, num_chars, char_line_bytes);\n\t\t#endif\n\n\t\t\tswitch (depth)\n\t\t\t{\n\t\t\t\tcase 2:\n\t\t\t\t\tfor (int32 i = 0; i < count; i += inc_sa1, base += char_line_bytes, inc_sa1 = char_line_bytes, char_count = num_chars)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8\t*line = base + (num_chars - char_count) * 2;\n\t\t\t\t\t\tfor (uint32 j = 0; j < char_count && p - buffer < count; j++, line += 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8\t*q = line;\n\t\t\t\t\t\t\tfor (int32 l = 0; l < 8; l++, q += bytes_per_line)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int32 b = 0; b < 2; b++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint8\tr = *(q + b);\n\t\t\t\t\t\t\t\t\t*(p + 0) = (*(p + 0) << 1) | ((r >> 0) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 1) = (*(p + 1) << 1) | ((r >> 1) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 0) = (*(p + 0) << 1) | ((r >> 2) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 1) = (*(p + 1) << 1) | ((r >> 3) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 0) = (*(p + 0) << 1) | ((r >> 4) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 1) = (*(p + 1) << 1) | ((r >> 5) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 0) = (*(p + 0) << 1) | ((r >> 6) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 1) = (*(p + 1) << 1) | ((r >> 7) & 1);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tfor (int32 i = 0; i < count; i += inc_sa1, base += char_line_bytes, inc_sa1 = char_line_bytes, char_count = num_chars)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8\t*line = base + (num_chars - char_count) * 4;\n\t\t\t\t\t\tfor (uint32 j = 0; j < char_count && p - buffer < count; j++, line += 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8\t*q = line;\n\t\t\t\t\t\t\tfor (int32 l = 0; l < 8; l++, q += bytes_per_line)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int32 b = 0; b < 4; b++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint8\tr = *(q + b);\n\t\t\t\t\t\t\t\t\t*(p +  0) = (*(p +  0) << 1) | ((r >> 0) & 1);\n\t\t\t\t\t\t\t\t\t*(p +  1) = (*(p +  1) << 1) | ((r >> 1) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 16) = (*(p + 16) << 1) | ((r >> 2) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 17) = (*(p + 17) << 1) | ((r >> 3) & 1);\n\t\t\t\t\t\t\t\t\t*(p +  0) = (*(p +  0) << 1) | ((r >> 4) & 1);\n\t\t\t\t\t\t\t\t\t*(p +  1) = (*(p +  1) << 1) | ((r >> 5) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 16) = (*(p + 16) << 1) | ((r >> 6) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 17) = (*(p + 17) << 1) | ((r >> 7) & 1);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tp += 32 - 16;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 8:\n\t\t\t\t\tfor (int32 i = 0; i < count; i += inc_sa1, base += char_line_bytes, inc_sa1 = char_line_bytes, char_count = num_chars)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8\t*line = base + (num_chars - char_count) * 8;\n\t\t\t\t\t\tfor (uint32 j = 0; j < char_count && p - buffer < count; j++, line += 8)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8\t*q = line;\n\t\t\t\t\t\t\tfor (int32 l = 0; l < 8; l++, q += bytes_per_line)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int32 b = 0; b < 8; b++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint8\tr = *(q + b);\n\t\t\t\t\t\t\t\t\t*(p +  0) = (*(p +  0) << 1) | ((r >> 0) & 1);\n\t\t\t\t\t\t\t\t\t*(p +  1) = (*(p +  1) << 1) | ((r >> 1) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 16) = (*(p + 16) << 1) | ((r >> 2) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 17) = (*(p + 17) << 1) | ((r >> 3) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 32) = (*(p + 32) << 1) | ((r >> 4) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 33) = (*(p + 33) << 1) | ((r >> 5) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 48) = (*(p + 48) << 1) | ((r >> 6) & 1);\n\t\t\t\t\t\t\t\t\t*(p + 49) = (*(p + 49) << 1) | ((r >> 7) & 1);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tp += 64 - 16;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DEBUGGER\n\tif (Settings.TraceDMA)\n\t{\n\t\tsprintf(String, \"DMA[%d]: %s Mode:%d 0x%02X%04X->0x21%02X Bytes:%d (%s) V:%03d\",\n\t\t\tChannel, d->ReverseTransfer ? \"PPU->CPU\" : \"CPU->PPU\", d->TransferMode, d->ABank, d->AAddress, d->BAddress,\n\t\t\td->TransferBytes, d->AAddressFixed ? \"fixed\" : (d->AAddressDecrement ? \"dec\" : \"inc\"), CPU.V_Counter);\n\n\t\tif (d->BAddress == 0x18 || d->BAddress == 0x19 || d->BAddress == 0x39 || d->BAddress == 0x3a)\n\t\t\tsprintf(String, \"%s VRAM: %04X (%d,%d) %s\", String,\n\t\t\t\tPPU.VMA.Address, PPU.VMA.Increment, PPU.VMA.FullGraphicCount, PPU.VMA.High ? \"word\" : \"byte\");\n\t\telse\n\t\tif (d->BAddress == 0x22 || d->BAddress == 0x3b)\n\t\t\tsprintf(String, \"%s CGRAM: %02X (%x)\", String, PPU.CGADD, PPU.CGFLIP);\n\t\telse\n\t\tif (d->BAddress == 0x04 || d->BAddress == 0x38)\n\t\t\tsprintf(String, \"%s OBJADDR: %04X\", String, PPU.OAMAddr);\n\n\t\tS9xMessage(S9X_TRACE, S9X_DMA_TRACE, String);\n\t}\n#endif\n\n\t// Do Transfer\n\n\tuint8\tWork;\n\n\t// 8 cycles per channel\n\tADD_CYCLES(SLOW_ONE_CYCLE);\n\n\tif (!d->ReverseTransfer)\n    {\n\t\t// CPU -> PPU\n\t\tint32\tb = 0;\n\t\tuint16\tp = d->AAddress;\n\t\tuint8\t*base = S9xGetBasePointer((d->ABank << 16) + d->AAddress);\n\t\tbool8\tinWRAM_DMA;\n\n\t\tint32\trem = count;\n\t\t// Transfer per block if d->AAdressFixed is FALSE\n\t\tcount = d->AAddressFixed ? rem : (d->AAddressDecrement ? ((p & MEMMAP_MASK) + 1) : (MEMMAP_BLOCK_SIZE - (p & MEMMAP_MASK)));\n\n\t\t// Settings for custom chip DMA\n\t\tif (in_sa1_dma)\n\t\t{\n\t\t\tbase = &Memory.ROM[CMemory::MAX_ROM_SIZE - 0x10000];\n\t\t\tp = 0;\n\t\t\tcount = rem;\n\t\t}\n\t\telse\n\t\tif (in_sdd1_dma)\n\t\t{\n\t\t\tbase = in_sdd1_dma;\n\t\t\tp = 0;\n\t\t\tcount = rem;\n\t\t}\n\t\telse\n\t\tif (spc7110_dma)\n\t\t{\n\t\t\tbase = spc7110_dma;\n\t\t\tp = 0;\n\t\t\tcount = rem;\n\t\t}\n\n\t\tinWRAM_DMA = ((!in_sa1_dma && !in_sdd1_dma && !spc7110_dma) &&\n\t\t\t(d->ABank == 0x7e || d->ABank == 0x7f || (!(d->ABank & 0x40) && d->AAddress < 0x2000)));\n\n\t\t// 8 cycles per byte\n\t\t#define\tUPDATE_COUNTERS \\\n\t\t\td->TransferBytes--; \\\n\t\t\td->AAddress += inc; \\\n\t\t\tp += inc; \\\n\t\t\tif (!addCyclesInDMA(Channel)) \\\n\t\t\t{ \\\n\t\t\t\tCPU.InDMA = FALSE; \\\n\t\t\t\tCPU.InDMAorHDMA = FALSE; \\\n\t\t\t\tCPU.InWRAMDMAorHDMA = FALSE; \\\n\t\t\t\tCPU.CurrentDMAorHDMAChannel = -1; \\\n\t\t\t\treturn (FALSE); \\\n\t\t\t}\n\n\t\twhile (1)\n\t\t{\n\t\t\tif (count > rem)\n\t\t\t\tcount = rem;\n\t\t\trem -= count;\n\n\t\t\tCPU.InWRAMDMAorHDMA = inWRAM_DMA;\n\n\t\t\tif (!base)\n\t\t\t{\n\t\t\t\t// DMA SLOW PATH\n\t\t\t\tif (d->TransferMode == 0 || d->TransferMode == 2 || d->TransferMode == 6)\n\t\t\t\t{\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t} while (--count > 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (d->TransferMode == 1 || d->TransferMode == 5)\n\t\t\t\t{\n\t\t\t\t\t// This is a variation on Duff's Device. It is legal C/C++.\n\t\t\t\t\tswitch (b)\n\t\t\t\t\t{\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\twhile (count > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2101 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (count == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tb = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tb = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (d->TransferMode == 3 || d->TransferMode == 7)\n\t\t\t\t{\n\t\t\t\t\tswitch (b)\n\t\t\t\t\t{\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2101 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 3;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2101 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (d->TransferMode == 4)\n\t\t\t\t{\n\t\t\t\t\tswitch (b)\n\t\t\t\t\t{\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2101 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2102 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 3;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tWork = S9xGetByte((d->ABank << 16) + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2103 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t#ifdef DEBUGGER\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(String, \"Unknown DMA transfer mode: %d on channel %d\\n\", d->TransferMode, Channel);\n\t\t\t\t\tS9xMessage(S9X_TRACE, S9X_DMA_TRACE, String);\n\t\t\t\t}\n\t\t\t#endif\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// DMA FAST PATH\n\t\t\t\tif (d->TransferMode == 0 || d->TransferMode == 2 || d->TransferMode == 6)\n\t\t\t\t{\n\t\t\t\t\tswitch (d->BAddress)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 0x04: // OAMDATA\n\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\tREGISTER_2104(Work);\n\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t} while (--count > 0);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x18: // VMDATAL\n\t\t\t\t\t\t\tif (!PPU.VMA.FullGraphicCount)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\t\tREGISTER_2118_linear(Work);\n\t\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\t} while (--count > 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\t\tREGISTER_2118_tile(Work);\n\t\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\t} while (--count > 0);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x19: // VMDATAH\n\t\t\t\t\t\t\tif (!PPU.VMA.FullGraphicCount)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\t\tREGISTER_2119_linear(Work);\n\t\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\t} while (--count > 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\t\tREGISTER_2119_tile(Work);\n\t\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\t} while (--count > 0);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x22: // CGDATA\n\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\tREGISTER_2122(Work);\n\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t} while (--count > 0);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x80: // WMDATA\n\t\t\t\t\t\t\tif (!CPU.InWRAMDMAorHDMA)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\t\tREGISTER_2180(Work);\n\t\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\t} while (--count > 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\t} while (--count > 0);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t} while (--count > 0);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (d->TransferMode == 1 || d->TransferMode == 5)\n\t\t\t\t{\n\t\t\t\t\tif (d->BAddress == 0x18)\n\t\t\t\t\t{\n\t\t\t\t\t\t// VMDATAL\n\t\t\t\t\t\tif (!PPU.VMA.FullGraphicCount)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (b)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\twhile (count > 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\t\tREGISTER_2118_linear(Work);\n\t\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tOpenBus = *(base + p);\n\t\t\t\t\t\t\t\t\tREGISTER_2119_linear(OpenBus);\n\t\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (count == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\tREGISTER_2118_linear(Work);\n\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch (b)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\twhile (count > 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\t\tREGISTER_2118_tile(Work);\n\t\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\t\tREGISTER_2119_tile(Work);\n\t\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (count == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\tREGISTER_2118_tile(Work);\n\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// DMA mode 1 general case\n\t\t\t\t\t\tswitch (b)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\twhile (count > 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2101 + d->BAddress);\n\t\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (count == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (d->TransferMode == 3 || d->TransferMode == 7)\n\t\t\t\t{\n\t\t\t\t\tswitch (b)\n\t\t\t\t\t{\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2101 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 3;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2101 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (d->TransferMode == 4)\n\t\t\t\t{\n\t\t\t\t\tswitch (b)\n\t\t\t\t\t{\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2100 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2101 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2102 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 3;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tWork = *(base + p);\n\t\t\t\t\t\t\tS9xSetPPU(Work, 0x2103 + d->BAddress);\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tif (--count <= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t#ifdef DEBUGGER\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(String, \"Unknown DMA transfer mode: %d on channel %d\\n\", d->TransferMode, Channel);\n\t\t\t\t\tS9xMessage(S9X_TRACE, S9X_DMA_TRACE, String);\n\t\t\t\t}\n\t\t\t#endif\n\t\t\t}\n\n\t\t\tif (rem <= 0)\n\t\t\t\tbreak;\n\n\t\t\tbase = S9xGetBasePointer((d->ABank << 16) + d->AAddress);\n\t\t\tcount = MEMMAP_BLOCK_SIZE;\n\t\t\tinWRAM_DMA = ((!in_sa1_dma && !in_sdd1_dma && !spc7110_dma) &&\n\t\t\t\t(d->ABank == 0x7e || d->ABank == 0x7f || (!(d->ABank & 0x40) && d->AAddress < 0x2000)));\n\t\t}\n\n\t\t#undef UPDATE_COUNTERS\n\t}\n    else\n    {\n\t\t// PPU -> CPU\n\n\t\t// 8 cycles per byte\n\t\t#define\tUPDATE_COUNTERS \\\n\t\t\td->TransferBytes--; \\\n\t\t\td->AAddress += inc; \\\n\t\t\tif (!addCyclesInDMA(Channel)) \\\n\t\t\t{ \\\n\t\t\t\tCPU.InDMA = FALSE; \\\n\t\t\t\tCPU.InDMAorHDMA = FALSE; \\\n\t\t\t\tCPU.InWRAMDMAorHDMA = FALSE; \\\n\t\t\t\tCPU.CurrentDMAorHDMAChannel = -1; \\\n\t\t\t\treturn (FALSE); \\\n\t\t\t}\n\n\t\tif (d->BAddress > 0x80 - 4 && d->BAddress <= 0x83 && !(d->ABank & 0x40))\n\t\t{\n\t\t\t// REVERSE-DMA REALLY-SLOW PATH\n\t\t\tdo\n\t\t\t{\n\t\t\t\tswitch (d->TransferMode)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (d->AAddress < 0x2000);\n\t\t\t\t\t\tWork = S9xGetPPU(0x2100 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tcount--;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (d->AAddress < 0x2000);\n\t\t\t\t\t\tWork = S9xGetPPU(0x2100 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (d->AAddress < 0x2000);\n\t\t\t\t\t\tWork = S9xGetPPU(0x2101 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tcount--;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (d->AAddress < 0x2000);\n\t\t\t\t\t\tWork = S9xGetPPU(0x2100 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (d->AAddress < 0x2000);\n\t\t\t\t\t\tWork = S9xGetPPU(0x2100 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (d->AAddress < 0x2000);\n\t\t\t\t\t\tWork = S9xGetPPU(0x2101 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (d->AAddress < 0x2000);\n\t\t\t\t\t\tWork = S9xGetPPU(0x2101 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tcount--;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (d->AAddress < 0x2000);\n\t\t\t\t\t\tWork = S9xGetPPU(0x2100 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (d->AAddress < 0x2000);\n\t\t\t\t\t\tWork = S9xGetPPU(0x2101 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (d->AAddress < 0x2000);\n\t\t\t\t\t\tWork = S9xGetPPU(0x2102 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (d->AAddress < 0x2000);\n\t\t\t\t\t\tWork = S9xGetPPU(0x2103 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tcount--;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t\tsprintf(String, \"Unknown DMA transfer mode: %d on channel %d\\n\", d->TransferMode, Channel);\n\t\t\t\t\t\tS9xMessage(S9X_TRACE, S9X_DMA_TRACE, String);\n\t\t\t\t\t#endif\n\t\t\t\t\t\twhile (count)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (count);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// REVERSE-DMA FASTER PATH\n\t\t\tCPU.InWRAMDMAorHDMA = (d->ABank == 0x7e || d->ABank == 0x7f);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tswitch (d->TransferMode)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tWork = S9xGetPPU(0x2100 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tcount--;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tWork = S9xGetPPU(0x2100 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tWork = S9xGetPPU(0x2101 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tcount--;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\tWork = S9xGetPPU(0x2100 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tWork = S9xGetPPU(0x2100 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tWork = S9xGetPPU(0x2101 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tWork = S9xGetPPU(0x2101 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tcount--;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tWork = S9xGetPPU(0x2100 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tWork = S9xGetPPU(0x2101 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tWork = S9xGetPPU(0x2102 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tif (!--count)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tWork = S9xGetPPU(0x2103 + d->BAddress);\n\t\t\t\t\t\tS9xSetByte(Work, (d->ABank << 16) + d->AAddress);\n\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\tcount--;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t\tsprintf(String, \"Unknown DMA transfer mode: %d on channel %d\\n\", d->TransferMode, Channel);\n\t\t\t\t\t\tS9xMessage(S9X_TRACE, S9X_DMA_TRACE, String);\n\t\t\t\t\t#endif\n\t\t\t\t\t\twhile (count)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUPDATE_COUNTERS;\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (count);\n\t\t}\n\t}\n\n\tif (CPU.NMIPending && (Timings.NMITriggerPos != 0xffff))\n\t{\n\t\tTimings.NMITriggerPos = CPU.Cycles + Timings.NMIDMADelay;\n\t}\n\n\t// Release the memory used in SPC7110 DMA\n    if (Settings.SPC7110)\n    {\n        if (spc7110_dma)\n            delete [] spc7110_dma;\n    }\n\n#if 0\n\t// sanity check\n    if (d->TransferBytes != 0)\n\t\tfprintf(stderr,\"DMA[%d] TransferBytes not 0! $21%02x Reverse:%d %04x\\n\", Channel, d->BAddress, d->ReverseTransfer, d->TransferBytes);\n#endif\n\n\tCPU.InDMA = FALSE;\n\tCPU.InDMAorHDMA = FALSE;\n\tCPU.InWRAMDMAorHDMA = FALSE;\n\tCPU.CurrentDMAorHDMAChannel = -1;\n\n\treturn (TRUE);\n}\n\nstatic inline bool8 HDMAReadLineCount (int d)\n{\n\t// CPU.InDMA is set, so S9xGetXXX() / S9xSetXXX() incur no charges.\n\n\tuint8\tline;\n\n\tline = S9xGetByte((DMA[d].ABank << 16) + DMA[d].Address);\n\tADD_CYCLES(SLOW_ONE_CYCLE);\n\n\tif (!line)\n\t{\n\t\tDMA[d].Repeat = FALSE;\n\t\tDMA[d].LineCount = 128;\n\n\t\tif (DMA[d].HDMAIndirectAddressing)\n\t\t{\n\t\t\tif (PPU.HDMA & (0xfe << d))\n\t\t\t{\n\t\t\t\tDMA[d].Address++;\n\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE << 1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\n\t\t\tDMA[d].IndirectAddress = S9xGetWord((DMA[d].ABank << 16) + DMA[d].Address);\n\t\t\tDMA[d].Address++;\n\t\t}\n\n\t\tDMA[d].Address++;\n\t\tHDMAMemPointers[d] = NULL;\n\n\t\treturn (FALSE);\n\t}\n\telse\n\tif (line == 0x80)\n\t{\n\t\tDMA[d].Repeat = TRUE;\n\t\tDMA[d].LineCount = 128;\n\t}\n\telse\n\t{\n\t\tDMA[d].Repeat = !(line & 0x80);\n\t\tDMA[d].LineCount = line & 0x7f;\n\t}\n\n\tDMA[d].Address++;\n\tDMA[d].DoTransfer = TRUE;\n\n\tif (DMA[d].HDMAIndirectAddressing)\n\t{\n\t\tADD_CYCLES(SLOW_ONE_CYCLE << 1);\n\t\tDMA[d].IndirectAddress = S9xGetWord((DMA[d].ABank << 16) + DMA[d].Address);\n\t\tDMA[d].Address += 2;\n\t\tHDMAMemPointers[d] = S9xGetMemPointer((DMA[d].IndirectBank << 16) + DMA[d].IndirectAddress);\n\t}\n\telse\n\t\tHDMAMemPointers[d] = S9xGetMemPointer((DMA[d].ABank << 16) + DMA[d].Address);\n\n\treturn (TRUE);\n}\n\nvoid S9xStartHDMA (void)\n{\n\tPPU.HDMA = Memory.FillRAM[0x420c];\n\n#ifdef DEBUGGER\n\tmissing.hdma_this_frame = PPU.HDMA;\n#endif\n\n\tPPU.HDMAEnded = 0;\n\n\tint32\ttmpch;\n\n\tCPU.InHDMA = TRUE;\n\tCPU.InDMAorHDMA = TRUE;\n\ttmpch = CPU.CurrentDMAorHDMAChannel;\n\n\t// XXX: Not quite right...\n\tif (PPU.HDMA != 0)\n\t\tADD_CYCLES(Timings.DMACPUSync);\n\n\tfor (uint8 i = 0; i < 8; i++)\n\t{\n\t\tif (PPU.HDMA & (1 << i))\n\t\t{\n\t\t\tCPU.CurrentDMAorHDMAChannel = i;\n\n\t\t\tDMA[i].Address = DMA[i].AAddress;\n\n\t\t\tif (!HDMAReadLineCount(i))\n\t\t\t{\n\t\t\t\tPPU.HDMA &= ~(1 << i);\n\t\t\t\tPPU.HDMAEnded |= (1 << i);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tDMA[i].DoTransfer = FALSE;\n\t}\n\n\tCPU.InHDMA = FALSE;\n\tCPU.InDMAorHDMA = CPU.InDMA;\n\tCPU.HDMARanInDMA = CPU.InDMA ? PPU.HDMA : 0;\n\tCPU.CurrentDMAorHDMAChannel = tmpch;\n}\n\nuint8 S9xDoHDMA (uint8 byte)\n{\n\tstruct SDMA *p;\n\n\tuint32\tShiftedIBank;\n\tuint16\tIAddr;\n\tbool8\ttemp;\n\tint32\ttmpch;\n\tint\td;\n\tuint8\tmask;\n\n\tCPU.InHDMA = TRUE;\n\tCPU.InDMAorHDMA = TRUE;\n\tCPU.HDMARanInDMA = CPU.InDMA ? byte : 0;\n\ttemp = CPU.InWRAMDMAorHDMA;\n\ttmpch = CPU.CurrentDMAorHDMAChannel;\n\n\t// XXX: Not quite right...\n\tADD_CYCLES(Timings.DMACPUSync);\n\n\tfor (mask = 1, p = &DMA[0], d = 0; mask; mask <<= 1, p++, d++)\n\t{\n\t\tif (byte & mask)\n\t\t{\n\t\t\tCPU.InWRAMDMAorHDMA = FALSE;\n\t\t\tCPU.CurrentDMAorHDMAChannel = d;\n\n\t\t\tif (p->HDMAIndirectAddressing)\n\t\t\t{\n\t\t\t\tShiftedIBank = (p->IndirectBank << 16);\n\t\t\t\tIAddr = p->IndirectAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tShiftedIBank = (p->ABank << 16);\n\t\t\t\tIAddr = p->Address;\n\t\t\t}\n\n\t\t\tif (!HDMAMemPointers[d])\n\t\t\t\tHDMAMemPointers[d] = S9xGetMemPointer(ShiftedIBank + IAddr);\n\n\t\t\tif (p->DoTransfer)\n\t\t\t{\n\t\t\t\t// XXX: Hack for Uniracers, because we don't understand\n\t\t\t\t// OAM Address Invalidation\n\t\t\t\tif (p->BAddress == 0x04)\n\t\t\t\t{\n\t\t\t\t\tif (SNESGameFixes.Uniracers)\n\t\t\t\t\t{\n\t\t\t\t\t\tPPU.OAMAddr = 0x10c;\n\t\t\t\t\t\tPPU.OAMFlip = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tif (Settings.TraceHDMA && p->DoTransfer)\n\t\t\t\t{\n\t\t\t\t\tsprintf(String, \"H-DMA[%d] %s (%d) 0x%06X->0x21%02X %s, Count: %3d, Rep: %s, V-LINE: %3ld %02X%04X\",\n\t\t\t\t\t\t\tp-DMA, p->ReverseTransfer? \"read\" : \"write\",\n\t\t\t\t\t\t\tp->TransferMode, ShiftedIBank+IAddr, p->BAddress,\n\t\t\t\t\t\t\tp->HDMAIndirectAddressing ? \"ind\" : \"abs\",\n\t\t\t\t\t\t\tp->LineCount,\n\t\t\t\t\t\t\tp->Repeat ? \"yes\" : \"no \", (long) CPU.V_Counter,\n\t\t\t\t\t\t\tp->ABank, p->Address);\n\t\t\t\t\tS9xMessage(S9X_TRACE, S9X_HDMA_TRACE, String);\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t\tif (!p->ReverseTransfer)\n\t\t\t\t{\n\t\t\t\t\tif ((IAddr & MEMMAP_MASK) + HDMA_ModeByteCounts[p->TransferMode] >= MEMMAP_BLOCK_SIZE)\n\t\t\t\t\t{\n\t\t\t\t\t\t// HDMA REALLY-SLOW PATH\n\t\t\t\t\t\tHDMAMemPointers[d] = NULL;\n\n\t\t\t\t\t\t#define DOBYTE(Addr, RegOff) \\\n\t\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (ShiftedIBank == 0x7e0000 || ShiftedIBank == 0x7f0000 || \\\n\t\t\t\t\t\t\t\t(!(ShiftedIBank & 0x400000) && ((uint16) (Addr)) < 0x2000)); \\\n\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(ShiftedIBank + ((uint16) (Addr))), 0x2100 + p->BAddress + (RegOff));\n\n\t\t\t\t\t\tswitch (p->TransferMode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tDOBYTE(IAddr, 0);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 0, 0);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 1, 1);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 2, 0);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 3, 1);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 0, 0);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 1, 1);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 0, 0);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 1, 0);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tcase 7:\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 0, 0);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 1, 0);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 2, 1);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 3, 1);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 0, 0);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 1, 1);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 2, 2);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tDOBYTE(IAddr + 3, 3);\n\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#undef DOBYTE\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (ShiftedIBank == 0x7e0000 || ShiftedIBank == 0x7f0000 ||\n\t\t\t\t\t\t\t(!(ShiftedIBank & 0x400000) && IAddr < 0x2000));\n\n\t\t\t\t\t\tif (!HDMAMemPointers[d])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// HDMA SLOW PATH\n\t\t\t\t\t\t\tuint32\tAddr = ShiftedIBank + IAddr;\n\n\t\t\t\t\t\t\tswitch (p->TransferMode)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 0), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 1), 0x2101 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tAddr += 2;\n\t\t\t\t\t\t\t\t\t/* fall through */\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 0), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 1), 0x2101 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 0), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 1), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tcase 7:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 0), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 1), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 2), 0x2101 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 3), 0x2101 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 0), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 1), 0x2101 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 2), 0x2102 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(S9xGetByte(Addr + 3), 0x2103 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// HDMA FAST PATH\n\t\t\t\t\t\t\tswitch (p->TransferMode)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*HDMAMemPointers[d]++, 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 0), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 1), 0x2101 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tHDMAMemPointers[d] += 2;\n\t\t\t\t\t\t\t\t\t/* fall through */\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 0), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\t// XXX: All HDMA should read to MDR first. This one just\n\t\t\t\t\t\t\t\t\t// happens to fix Speedy Gonzales.\n\t\t\t\t\t\t\t\t\tOpenBus = *(HDMAMemPointers[d] + 1);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(OpenBus, 0x2101 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tHDMAMemPointers[d] += 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 0), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 1), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tHDMAMemPointers[d] += 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tcase 7:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 0), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 1), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 2), 0x2101 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 3), 0x2101 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tHDMAMemPointers[d] += 4;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 0), 0x2100 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 1), 0x2101 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 2), 0x2102 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tS9xSetPPU(*(HDMAMemPointers[d] + 3), 0x2103 + p->BAddress);\n\t\t\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\t\t\tHDMAMemPointers[d] += 4;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// REVERSE HDMA REALLY-SLOW PATH\n\t\t\t\t\t// anomie says: Since this is apparently never used\n\t\t\t\t\t// (otherwise we would have noticed before now), let's not bother with faster paths.\n\t\t\t\t\tHDMAMemPointers[d] = NULL;\n\n\t\t\t\t\t#define DOBYTE(Addr, RegOff) \\\n\t\t\t\t\t\tCPU.InWRAMDMAorHDMA = (ShiftedIBank == 0x7e0000 || ShiftedIBank == 0x7f0000 || \\\n\t\t\t\t\t\t\t(!(ShiftedIBank & 0x400000) && ((uint16) (Addr)) < 0x2000)); \\\n\t\t\t\t\t\tS9xSetByte(S9xGetPPU(0x2100 + p->BAddress + (RegOff)), ShiftedIBank + ((uint16) (Addr)));\n\n\t\t\t\t\tswitch (p->TransferMode)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tDOBYTE(IAddr, 0);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\tDOBYTE(IAddr + 0, 0);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tDOBYTE(IAddr + 1, 1);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tDOBYTE(IAddr + 2, 0);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tDOBYTE(IAddr + 3, 1);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tDOBYTE(IAddr + 0, 0);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tDOBYTE(IAddr + 1, 1);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\tDOBYTE(IAddr + 0, 0);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tDOBYTE(IAddr + 1, 0);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\tcase 7:\n\t\t\t\t\t\t\tDOBYTE(IAddr + 0, 0);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tDOBYTE(IAddr + 1, 0);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tDOBYTE(IAddr + 2, 1);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tDOBYTE(IAddr + 3, 1);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tDOBYTE(IAddr + 0, 0);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tDOBYTE(IAddr + 1, 1);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tDOBYTE(IAddr + 2, 2);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tDOBYTE(IAddr + 3, 3);\n\t\t\t\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t#undef DOBYTE\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (mask = 1, p = &DMA[0], d = 0; mask; mask <<= 1, p++, d++)\n\t{\n\t\tif (byte & mask)\n\t\t{\n\t\t\tif (p->DoTransfer)\n\t\t\t{\n\t\t\t\tif (p->HDMAIndirectAddressing)\n\t\t\t\t\tp->IndirectAddress += HDMA_ModeByteCounts[p->TransferMode];\n\t\t\t\telse\n\t\t\t\t\tp->Address += HDMA_ModeByteCounts[p->TransferMode];\n\t\t\t}\n\n\t\t\tp->DoTransfer = !p->Repeat;\n\n\t\t\tif (!--p->LineCount)\n\t\t\t{\n\t\t\t\tif (!HDMAReadLineCount(d))\n\t\t\t\t{\n\t\t\t\t\tbyte &= ~mask;\n\t\t\t\t\tPPU.HDMAEnded |= mask;\n\t\t\t\t\tp->DoTransfer = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tADD_CYCLES(SLOW_ONE_CYCLE);\n\t\t}\n\t}\n\n\tCPU.InHDMA = FALSE;\n\tCPU.InDMAorHDMA = CPU.InDMA;\n\tCPU.InWRAMDMAorHDMA = temp;\n\tCPU.CurrentDMAorHDMAChannel = tmpch;\n\n\treturn (byte);\n}\n\nvoid S9xResetDMA (void)\n{\n\tfor (int d = 0; d < 8; d++)\n\t{\n\t\tDMA[d].ReverseTransfer = TRUE;\n\t\tDMA[d].HDMAIndirectAddressing = TRUE;\n\t\tDMA[d].AAddressFixed = TRUE;\n\t\tDMA[d].AAddressDecrement = TRUE;\n\t\tDMA[d].TransferMode = 7;\n\t\tDMA[d].BAddress = 0xff;\n\t\tDMA[d].AAddress = 0xffff;\n\t\tDMA[d].ABank = 0xff;\n\t\tDMA[d].DMACount_Or_HDMAIndirectAddress = 0xffff;\n\t\tDMA[d].IndirectBank = 0xff;\n\t\tDMA[d].Address = 0xffff;\n\t\tDMA[d].Repeat = FALSE;\n\t\tDMA[d].LineCount = 0x7f;\n\t\tDMA[d].UnknownByte = 0xff;\n\t\tDMA[d].DoTransfer = FALSE;\n\t\tDMA[d].UnusedBit43x0 = 1;\n\t}\n}\n"
        },
        {
          "name": "dma.h",
          "type": "blob",
          "size": 0.9951171875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _DMA_H_\n#define _DMA_H_\n\nstruct SDMA\n{\n\tbool8\tReverseTransfer;\n\tbool8\tHDMAIndirectAddressing;\n\tbool8\tUnusedBit43x0;\n\tbool8\tAAddressFixed;\n\tbool8\tAAddressDecrement;\n\tuint8\tTransferMode;\n\tuint8\tBAddress;\n\tuint16\tAAddress;\n\tuint8\tABank;\n\tuint16\tDMACount_Or_HDMAIndirectAddress;\n\tuint8\tIndirectBank;\n\tuint16\tAddress;\n\tuint8\tRepeat;\n\tuint8\tLineCount;\n\tuint8\tUnknownByte;\n\tuint8\tDoTransfer;\n};\n\n#define TransferBytes\tDMACount_Or_HDMAIndirectAddress\n#define IndirectAddress\tDMACount_Or_HDMAIndirectAddress\n\nextern struct SDMA\tDMA[8];\n\nbool8 S9xDoDMA (uint8);\nvoid S9xStartHDMA (void);\nuint8 S9xDoHDMA (uint8);\nvoid S9xResetDMA (void);\n\n#endif\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "dsp.cpp",
          "type": "blob",
          "size": 1.3046875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#ifdef DEBUGGER\n#include \"missing.h\"\n#endif\n\nuint8\t(*GetDSP) (uint16)        = NULL;\nvoid\t(*SetDSP) (uint8, uint16) = NULL;\n\n\nvoid S9xResetDSP (void)\n{\n\tmemset(&DSP1, 0, sizeof(DSP1));\n\tDSP1.waiting4command = TRUE;\n\tDSP1.first_parameter = TRUE;\n\n\tmemset(&DSP2, 0, sizeof(DSP2));\n\tDSP2.waiting4command = TRUE;\n\n\tmemset(&DSP3, 0, sizeof(DSP3));\n\tDSP3_Reset();\n\n\tmemset(&DSP4, 0, sizeof(DSP4));\n\tDSP4.waiting4command = TRUE;\n}\n\nuint8 S9xGetDSP (uint16 address)\n{\n#ifdef DEBUGGER\n\tif (Settings.TraceDSP)\n\t{\n\t\tsprintf(String, \"DSP read: 0x%04X\", address);\n\t\tS9xMessage(S9X_TRACE, S9X_TRACE_DSP1, String);\n\t}\n#endif\n\n\treturn ((*GetDSP)(address));\n}\n\nvoid S9xSetDSP (uint8 byte, uint16 address)\n{\n#ifdef DEBUGGER\n\tmissing.unknowndsp_write = address;\n\tif (Settings.TraceDSP)\n\t{\n\t\tsprintf(String, \"DSP write: 0x%04X=0x%02X\", address, byte);\n\t\tS9xMessage(S9X_TRACE, S9X_TRACE_DSP1, String);\n\t}\n#endif\n\n\t(*SetDSP)(byte, address);\n}\n"
        },
        {
          "name": "dsp.h",
          "type": "blob",
          "size": 8.1806640625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _DSP1_H_\n#define _DSP1_H_\n\nenum\n{\n\tM_DSP1_LOROM_S,\n\tM_DSP1_LOROM_L,\n\tM_DSP1_HIROM,\n\tM_DSP2_LOROM,\n\tM_DSP3_LOROM,\n\tM_DSP4_LOROM\n};\n\nstruct SDSP0\n{\n\tuint32\tmaptype;\n\tuint32\tboundary;\n};\n\nstruct SDSP1\n{\n\tbool8\twaiting4command;\n\tbool8\tfirst_parameter;\n\tuint8\tcommand;\n\tuint32\tin_count;\n\tuint32\tin_index;\n\tuint32\tout_count;\n\tuint32\tout_index;\n\tuint8\tparameters[512];\n\tuint8\toutput[512];\n\n\tint16\tCentreX;\n\tint16\tCentreY;\n\tint16\tVOffset;\n\n\tint16\tVPlane_C;\n\tint16\tVPlane_E;\n\n\t// Azimuth and Zenith angles\n\tint16\tSinAas;\n\tint16\tCosAas;\n\tint16\tSinAzs;\n\tint16\tCosAzs;\n\n\t// Clipped Zenith angle\n\tint16\tSinAZS;\n\tint16\tCosAZS;\n\tint16\tSecAZS_C1;\n\tint16\tSecAZS_E1;\n\tint16\tSecAZS_C2;\n\tint16\tSecAZS_E2;\n\n\tint16\tNx;\n\tint16\tNy;\n\tint16\tNz;\n\tint16\tGx;\n\tint16\tGy;\n\tint16\tGz;\n\tint16\tC_Les;\n\tint16\tE_Les;\n\tint16\tG_Les;\n\n\tint16\tmatrixA[3][3];\n\tint16\tmatrixB[3][3];\n\tint16\tmatrixC[3][3];\n\n\tint16\tOp00Multiplicand;\n\tint16\tOp00Multiplier;\n\tint16\tOp00Result;\n\n\tint16\tOp20Multiplicand;\n\tint16\tOp20Multiplier;\n\tint16\tOp20Result;\n\n\tint16\tOp10Coefficient;\n\tint16\tOp10Exponent;\n\tint16\tOp10CoefficientR;\n\tint16\tOp10ExponentR;\n\n\tint16\tOp04Angle;\n\tint16\tOp04Radius;\n\tint16\tOp04Sin;\n\tint16\tOp04Cos;\n\n\tint16\tOp0CA;\n\tint16\tOp0CX1;\n\tint16\tOp0CY1;\n\tint16\tOp0CX2;\n\tint16\tOp0CY2;\n\n\tint16\tOp02FX;\n\tint16\tOp02FY;\n\tint16\tOp02FZ;\n\tint16\tOp02LFE;\n\tint16\tOp02LES;\n\tint16\tOp02AAS;\n\tint16\tOp02AZS;\n\tint16\tOp02VOF;\n\tint16\tOp02VVA;\n\tint16\tOp02CX;\n\tint16\tOp02CY;\n\n\tint16\tOp0AVS;\n\tint16\tOp0AA;\n\tint16\tOp0AB;\n\tint16\tOp0AC;\n\tint16\tOp0AD;\n\n\tint16\tOp06X;\n\tint16\tOp06Y;\n\tint16\tOp06Z;\n\tint16\tOp06H;\n\tint16\tOp06V;\n\tint16\tOp06M;\n\n\tint16\tOp01m;\n\tint16\tOp01Zr;\n\tint16\tOp01Xr;\n\tint16\tOp01Yr;\n\n\tint16\tOp11m;\n\tint16\tOp11Zr;\n\tint16\tOp11Xr;\n\tint16\tOp11Yr;\n\n\tint16\tOp21m;\n\tint16\tOp21Zr;\n\tint16\tOp21Xr;\n\tint16\tOp21Yr;\n\n\tint16\tOp0DX;\n\tint16\tOp0DY;\n\tint16\tOp0DZ;\n\tint16\tOp0DF;\n\tint16\tOp0DL;\n\tint16\tOp0DU;\n\n\tint16\tOp1DX;\n\tint16\tOp1DY;\n\tint16\tOp1DZ;\n\tint16\tOp1DF;\n\tint16\tOp1DL;\n\tint16\tOp1DU;\n\n\tint16\tOp2DX;\n\tint16\tOp2DY;\n\tint16\tOp2DZ;\n\tint16\tOp2DF;\n\tint16\tOp2DL;\n\tint16\tOp2DU;\n\n\tint16\tOp03F;\n\tint16\tOp03L;\n\tint16\tOp03U;\n\tint16\tOp03X;\n\tint16\tOp03Y;\n\tint16\tOp03Z;\n\n\tint16\tOp13F;\n\tint16\tOp13L;\n\tint16\tOp13U;\n\tint16\tOp13X;\n\tint16\tOp13Y;\n\tint16\tOp13Z;\n\n\tint16\tOp23F;\n\tint16\tOp23L;\n\tint16\tOp23U;\n\tint16\tOp23X;\n\tint16\tOp23Y;\n\tint16\tOp23Z;\n\n\tint16\tOp14Zr;\n\tint16\tOp14Xr;\n\tint16\tOp14Yr;\n\tint16\tOp14U;\n\tint16\tOp14F;\n\tint16\tOp14L;\n\tint16\tOp14Zrr;\n\tint16\tOp14Xrr;\n\tint16\tOp14Yrr;\n\n\tint16\tOp0EH;\n\tint16\tOp0EV;\n\tint16\tOp0EX;\n\tint16\tOp0EY;\n\n\tint16\tOp0BX;\n\tint16\tOp0BY;\n\tint16\tOp0BZ;\n\tint16\tOp0BS;\n\n\tint16\tOp1BX;\n\tint16\tOp1BY;\n\tint16\tOp1BZ;\n\tint16\tOp1BS;\n\n\tint16\tOp2BX;\n\tint16\tOp2BY;\n\tint16\tOp2BZ;\n\tint16\tOp2BS;\n\n\tint16\tOp28X;\n\tint16\tOp28Y;\n\tint16\tOp28Z;\n\tint16\tOp28R;\n\n\tint16\tOp1CX;\n\tint16\tOp1CY;\n\tint16\tOp1CZ;\n\tint16\tOp1CXBR;\n\tint16\tOp1CYBR;\n\tint16\tOp1CZBR;\n\tint16\tOp1CXAR;\n\tint16\tOp1CYAR;\n\tint16\tOp1CZAR;\n\tint16\tOp1CX1;\n\tint16\tOp1CY1;\n\tint16\tOp1CZ1;\n\tint16\tOp1CX2;\n\tint16\tOp1CY2;\n\tint16\tOp1CZ2;\n\n\tuint16\tOp0FRamsize;\n\tuint16\tOp0FPass;\n\n\tint16\tOp2FUnknown;\n\tint16\tOp2FSize;\n\n\tint16\tOp08X;\n\tint16\tOp08Y;\n\tint16\tOp08Z;\n\tint16\tOp08Ll;\n\tint16\tOp08Lh;\n\n\tint16\tOp18X;\n\tint16\tOp18Y;\n\tint16\tOp18Z;\n\tint16\tOp18R;\n\tint16\tOp18D;\n\n\tint16\tOp38X;\n\tint16\tOp38Y;\n\tint16\tOp38Z;\n\tint16\tOp38R;\n\tint16\tOp38D;\n};\n\nstruct SDSP2\n{\n\tbool8\twaiting4command;\n\tuint8\tcommand;\n\tuint32\tin_count;\n\tuint32\tin_index;\n\tuint32\tout_count;\n\tuint32\tout_index;\n\tuint8\tparameters[512];\n\tuint8\toutput[512];\n\n\tbool8\tOp05HasLen;\n\tint32\tOp05Len;\n\tuint8\tOp05Transparent;\n\n\tbool8\tOp06HasLen;\n\tint32\tOp06Len;\n\n\tuint16\tOp09Word1;\n\tuint16\tOp09Word2;\n\n\tbool8\tOp0DHasLen;\n\tint32\tOp0DOutLen;\n\tint32\tOp0DInLen;\n};\n\nstruct SDSP3\n{\n\tuint16\tDR;\n\tuint16\tSR;\n\tuint16\tMemoryIndex;\n\n\tint16\tWinLo;\n\tint16\tWinHi;\n\tint16\tAddLo;\n\tint16\tAddHi;\n\n\tuint16\tCodewords;\n\tuint16\tOutwords;\n\tuint16\tSymbol;\n\tuint16\tBitCount;\n\tuint16\tIndex;\n\tuint16\tCodes[512];\n\tuint16\tBitsLeft;\n\tuint16\tReqBits;\n\tuint16\tReqData;\n\tuint16\tBitCommand;\n\tuint8\tBaseLength;\n\tuint16\tBaseCodes;\n\tuint16\tBaseCode;\n\tuint8\tCodeLengths[8];\n\tuint16\tCodeOffsets[8];\n\tuint16\tLZCode;\n\tuint8\tLZLength;\n\n\tuint16\tX;\n\tuint16\tY;\n\n\tuint8\tBitmap[8];\n\tuint8\tBitplane[8];\n\tuint16\tBMIndex;\n\tuint16\tBPIndex;\n\tuint16\tCount;\n\n\tint16\top3e_x;\n\tint16\top3e_y;\n\n\tint16\top1e_terrain[0x2000];\n\tint16\top1e_cost[0x2000];\n\tint16\top1e_weight[0x2000];\n\n\tint16\top1e_cell;\n\tint16\top1e_turn;\n\tint16\top1e_search;\n\n\tint16\top1e_x;\n\tint16\top1e_y;\n\n\tint16\top1e_min_radius;\n\tint16\top1e_max_radius;\n\n\tint16\top1e_max_search_radius;\n\tint16\top1e_max_path_radius;\n\n\tint16\top1e_lcv_radius;\n\tint16\top1e_lcv_steps;\n\tint16\top1e_lcv_turns;\n};\n\nstruct SDSP4\n{\n\tbool8\twaiting4command;\n\tbool8\thalf_command;\n\tuint16\tcommand;\n\tuint32\tin_count;\n\tuint32\tin_index;\n\tuint32\tout_count;\n\tuint32\tout_index;\n\tuint8\tparameters[512];\n\tuint8\toutput[512];\n\tuint8\tbyte;\n\tuint16\taddress;\n\n\t// op control\n\tint8\tLogic;\t\t\t\t// controls op flow\n\n\t// projection format\n\tint16\tlcv;\t\t\t\t// loop-control variable\n\tint16\tdistance;\t\t\t// z-position into virtual world\n\tint16\traster;\t\t\t\t// current raster line\n\tint16\tsegments;\t\t\t// number of raster lines drawn\n\n\t// 1.15.16 or 1.15.0 [sign, integer, fraction]\n\tint32\tworld_x;\t\t\t// line of x-projection in world\n\tint32\tworld_y;\t\t\t// line of y-projection in world\n\tint32\tworld_dx;\t\t\t// projection line x-delta\n\tint32\tworld_dy;\t\t\t// projection line y-delta\n\tint16\tworld_ddx;\t\t\t// x-delta increment\n\tint16\tworld_ddy;\t\t\t// y-delta increment\n\tint32\tworld_xenv;\t\t\t// world x-shaping factor\n\tint16\tworld_yofs;\t\t\t// world y-vertical scroll\n\tint16\tview_x1;\t\t\t// current viewer-x\n\tint16\tview_y1;\t\t\t// current viewer-y\n\tint16\tview_x2;\t\t\t// future viewer-x\n\tint16\tview_y2;\t\t\t// future viewer-y\n\tint16\tview_dx;\t\t\t// view x-delta factor\n\tint16\tview_dy;\t\t\t// view y-delta factor\n\tint16\tview_xofs1;\t\t\t// current viewer x-vertical scroll\n\tint16\tview_yofs1;\t\t\t// current viewer y-vertical scroll\n\tint16\tview_xofs2;\t\t\t// future viewer x-vertical scroll\n\tint16\tview_yofs2;\t\t\t// future viewer y-vertical scroll\n\tint16\tview_yofsenv;\t\t// y-scroll shaping factor\n\tint16\tview_turnoff_x;\t\t// road turnoff data\n\tint16\tview_turnoff_dx;\t// road turnoff delta factor\n\n\t// drawing area\n\tint16\tviewport_cx;\t\t// x-center of viewport window\n\tint16\tviewport_cy;\t\t// y-center of render window\n\tint16\tviewport_left;\t\t// x-left of viewport\n\tint16\tviewport_right;\t\t// x-right of viewport\n\tint16\tviewport_top;\t\t// y-top of viewport\n\tint16\tviewport_bottom;\t// y-bottom of viewport\n\n\t// sprite structure\n\tint16\tsprite_x;\t\t\t// projected x-pos of sprite\n\tint16\tsprite_y;\t\t\t// projected y-pos of sprite\n\tint16\tsprite_attr;\t\t// obj attributes\n\tbool8\tsprite_size;\t\t// sprite size: 8x8 or 16x16\n\tint16\tsprite_clipy;\t\t// visible line to clip pixels off\n\tint16\tsprite_count;\n\n\t// generic projection variables designed for two solid polygons + two polygon sides\n\tint16\tpoly_clipLf[2][2];\t// left clip boundary\n\tint16\tpoly_clipRt[2][2];\t// right clip boundary\n\tint16\tpoly_ptr[2][2];\t\t// HDMA structure pointers\n\tint16\tpoly_raster[2][2];\t// current raster line below horizon\n\tint16\tpoly_top[2][2];\t\t// top clip boundary\n\tint16\tpoly_bottom[2][2];\t// bottom clip boundary\n\tint16\tpoly_cx[2][2];\t\t// center for left/right points\n\tint16\tpoly_start[2];\t\t// current projection points\n\tint16\tpoly_plane[2];\t\t// previous z-plane distance\n\n\t// OAM\n\tint16\tOAM_attr[16];\t\t// OAM (size, MSB) data\n\tint16\tOAM_index;\t\t\t// index into OAM table\n\tint16\tOAM_bits;\t\t\t// offset into OAM table\n\tint16\tOAM_RowMax;\t\t\t// maximum number of tiles per 8 aligned pixels (row)\n\tint16\tOAM_Row[32];\t\t// current number of tiles per row\n};\n\nextern struct SDSP0\tDSP0;\nextern struct SDSP1\tDSP1;\nextern struct SDSP2\tDSP2;\nextern struct SDSP3\tDSP3;\nextern struct SDSP4\tDSP4;\n\nuint8 S9xGetDSP (uint16);\nvoid S9xSetDSP (uint8, uint16);\nvoid S9xResetDSP (void);\nuint8 DSP1GetByte (uint16);\nvoid DSP1SetByte (uint8, uint16);\nuint8 DSP2GetByte (uint16);\nvoid DSP2SetByte (uint8, uint16);\nuint8 DSP3GetByte (uint16);\nvoid DSP3SetByte (uint8, uint16);\nuint8 DSP4GetByte (uint16);\nvoid DSP4SetByte (uint8, uint16);\nvoid DSP3_Reset (void);\n\nextern uint8 (*GetDSP) (uint16);\nextern void (*SetDSP) (uint8, uint16);\n\n#endif\n"
        },
        {
          "name": "dsp1.cpp",
          "type": "blob",
          "size": 53.5478515625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n/*\nCopyright (C) 1997-2006 ZSNES Team ( zsKnight, _Demo_, pagefault, Nach )\n\nhttp://www.zsnes.com\nhttp://sourceforge.net/projects/zsnes\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nversion 2 as published by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/\n\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n\n#ifdef DEBUGGER\n//#define DebugDSP1\n#endif\n\n#ifdef DebugDSP1\n#include <stdarg.h>\nstatic FILE\t*LogFile = NULL;\n#endif\n\nstatic const uint16\tDSP1ROM[1024] =\n{\n\t 0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,\n\t 0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,\n\t 0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,\n\t 0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,\n\t 0x0000,  0x0000,  0x0001,  0x0002,  0x0004,  0x0008,  0x0010,  0x0020,\n\t 0x0040,  0x0080,  0x0100,  0x0200,  0x0400,  0x0800,  0x1000,  0x2000,\n\t 0x4000,  0x7fff,  0x4000,  0x2000,  0x1000,  0x0800,  0x0400,  0x0200,\n\t 0x0100,  0x0080,  0x0040,  0x0020,  0x0001,  0x0008,  0x0004,  0x0002,\n\t 0x0001,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,\n\t 0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,\n\t 0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,\n\t 0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,  0x0000,\n\t 0x0000,  0x0000,  0x8000,  0xffe5,  0x0100,  0x7fff,  0x7f02,  0x7e08,\n\t 0x7d12,  0x7c1f,  0x7b30,  0x7a45,  0x795d,  0x7878,  0x7797,  0x76ba,\n\t 0x75df,  0x7507,  0x7433,  0x7361,  0x7293,  0x71c7,  0x70fe,  0x7038,\n\t 0x6f75,  0x6eb4,  0x6df6,  0x6d3a,  0x6c81,  0x6bca,  0x6b16,  0x6a64,\n\t 0x69b4,  0x6907,  0x685b,  0x67b2,  0x670b,  0x6666,  0x65c4,  0x6523,\n\t 0x6484,  0x63e7,  0x634c,  0x62b3,  0x621c,  0x6186,  0x60f2,  0x6060,\n\t 0x5fd0,  0x5f41,  0x5eb5,  0x5e29,  0x5d9f,  0x5d17,  0x5c91,  0x5c0c,\n\t 0x5b88,  0x5b06,  0x5a85,  0x5a06,  0x5988,  0x590b,  0x5890,  0x5816,\n\t 0x579d,  0x5726,  0x56b0,  0x563b,  0x55c8,  0x5555,  0x54e4,  0x5474,\n\t 0x5405,  0x5398,  0x532b,  0x52bf,  0x5255,  0x51ec,  0x5183,  0x511c,\n\t 0x50b6,  0x5050,  0x4fec,  0x4f89,  0x4f26,  0x4ec5,  0x4e64,  0x4e05,\n\t 0x4da6,  0x4d48,  0x4cec,  0x4c90,  0x4c34,  0x4bda,  0x4b81,  0x4b28,\n\t 0x4ad0,  0x4a79,  0x4a23,  0x49cd,  0x4979,  0x4925,  0x48d1,  0x487f,\n\t 0x482d,  0x47dc,  0x478c,  0x473c,  0x46ed,  0x469f,  0x4651,  0x4604,\n\t 0x45b8,  0x456c,  0x4521,  0x44d7,  0x448d,  0x4444,  0x43fc,  0x43b4,\n\t 0x436d,  0x4326,  0x42e0,  0x429a,  0x4255,  0x4211,  0x41cd,  0x4189,\n\t 0x4146,  0x4104,  0x40c2,  0x4081,  0x4040,  0x3fff,  0x41f7,  0x43e1,\n\t 0x45bd,  0x478d,  0x4951,  0x4b0b,  0x4cbb,  0x4e61,  0x4fff,  0x5194,\n\t 0x5322,  0x54a9,  0x5628,  0x57a2,  0x5914,  0x5a81,  0x5be9,  0x5d4a,\n\t 0x5ea7,  0x5fff,  0x6152,  0x62a0,  0x63ea,  0x6530,  0x6672,  0x67b0,\n\t 0x68ea,  0x6a20,  0x6b53,  0x6c83,  0x6daf,  0x6ed9,  0x6fff,  0x7122,\n\t 0x7242,  0x735f,  0x747a,  0x7592,  0x76a7,  0x77ba,  0x78cb,  0x79d9,\n\t 0x7ae5,  0x7bee,  0x7cf5,  0x7dfa,  0x7efe,  0x7fff,  0x0000,  0x0324,\n\t 0x0647,  0x096a,  0x0c8b,  0x0fab,  0x12c8,  0x15e2,  0x18f8,  0x1c0b,\n\t 0x1f19,  0x2223,  0x2528,  0x2826,  0x2b1f,  0x2e11,  0x30fb,  0x33de,\n\t 0x36ba,  0x398c,  0x3c56,  0x3f17,  0x41ce,  0x447a,  0x471c,  0x49b4,\n\t 0x4c3f,  0x4ebf,  0x5133,  0x539b,  0x55f5,  0x5842,  0x5a82,  0x5cb4,\n\t 0x5ed7,  0x60ec,  0x62f2,  0x64e8,  0x66cf,  0x68a6,  0x6a6d,  0x6c24,\n\t 0x6dca,  0x6f5f,  0x70e2,  0x7255,  0x73b5,  0x7504,  0x7641,  0x776c,\n\t 0x7884,  0x798a,  0x7a7d,  0x7b5d,  0x7c29,  0x7ce3,  0x7d8a,  0x7e1d,\n\t 0x7e9d,  0x7f09,  0x7f62,  0x7fa7,  0x7fd8,  0x7ff6,  0x7fff,  0x7ff6,\n\t 0x7fd8,  0x7fa7,  0x7f62,  0x7f09,  0x7e9d,  0x7e1d,  0x7d8a,  0x7ce3,\n\t 0x7c29,  0x7b5d,  0x7a7d,  0x798a,  0x7884,  0x776c,  0x7641,  0x7504,\n\t 0x73b5,  0x7255,  0x70e2,  0x6f5f,  0x6dca,  0x6c24,  0x6a6d,  0x68a6,\n\t 0x66cf,  0x64e8,  0x62f2,  0x60ec,  0x5ed7,  0x5cb4,  0x5a82,  0x5842,\n\t 0x55f5,  0x539b,  0x5133,  0x4ebf,  0x4c3f,  0x49b4,  0x471c,  0x447a,\n\t 0x41ce,  0x3f17,  0x3c56,  0x398c,  0x36ba,  0x33de,  0x30fb,  0x2e11,\n\t 0x2b1f,  0x2826,  0x2528,  0x2223,  0x1f19,  0x1c0b,  0x18f8,  0x15e2,\n\t 0x12c8,  0x0fab,  0x0c8b,  0x096a,  0x0647,  0x0324,  0x7fff,  0x7ff6,\n\t 0x7fd8,  0x7fa7,  0x7f62,  0x7f09,  0x7e9d,  0x7e1d,  0x7d8a,  0x7ce3,\n\t 0x7c29,  0x7b5d,  0x7a7d,  0x798a,  0x7884,  0x776c,  0x7641,  0x7504,\n\t 0x73b5,  0x7255,  0x70e2,  0x6f5f,  0x6dca,  0x6c24,  0x6a6d,  0x68a6,\n\t 0x66cf,  0x64e8,  0x62f2,  0x60ec,  0x5ed7,  0x5cb4,  0x5a82,  0x5842,\n\t 0x55f5,  0x539b,  0x5133,  0x4ebf,  0x4c3f,  0x49b4,  0x471c,  0x447a,\n\t 0x41ce,  0x3f17,  0x3c56,  0x398c,  0x36ba,  0x33de,  0x30fb,  0x2e11,\n\t 0x2b1f,  0x2826,  0x2528,  0x2223,  0x1f19,  0x1c0b,  0x18f8,  0x15e2,\n\t 0x12c8,  0x0fab,  0x0c8b,  0x096a,  0x0647,  0x0324,  0x0000,  0xfcdc,\n\t 0xf9b9,  0xf696,  0xf375,  0xf055,  0xed38,  0xea1e,  0xe708,  0xe3f5,\n\t 0xe0e7,  0xdddd,  0xdad8,  0xd7da,  0xd4e1,  0xd1ef,  0xcf05,  0xcc22,\n\t 0xc946,  0xc674,  0xc3aa,  0xc0e9,  0xbe32,  0xbb86,  0xb8e4,  0xb64c,\n\t 0xb3c1,  0xb141,  0xaecd,  0xac65,  0xaa0b,  0xa7be,  0xa57e,  0xa34c,\n\t 0xa129,  0x9f14,  0x9d0e,  0x9b18,  0x9931,  0x975a,  0x9593,  0x93dc,\n\t 0x9236,  0x90a1,  0x8f1e,  0x8dab,  0x8c4b,  0x8afc,  0x89bf,  0x8894,\n\t 0x877c,  0x8676,  0x8583,  0x84a3,  0x83d7,  0x831d,  0x8276,  0x81e3,\n\t 0x8163,  0x80f7,  0x809e,  0x8059,  0x8028,  0x800a,  0x6488,  0x0080,\n\t 0x03ff,  0x0116,  0x0002,  0x0080,  0x4000,  0x3fd7,  0x3faf,  0x3f86,\n\t 0x3f5d,  0x3f34,  0x3f0c,  0x3ee3,  0x3eba,  0x3e91,  0x3e68,  0x3e40,\n\t 0x3e17,  0x3dee,  0x3dc5,  0x3d9c,  0x3d74,  0x3d4b,  0x3d22,  0x3cf9,\n\t 0x3cd0,  0x3ca7,  0x3c7f,  0x3c56,  0x3c2d,  0x3c04,  0x3bdb,  0x3bb2,\n\t 0x3b89,  0x3b60,  0x3b37,  0x3b0e,  0x3ae5,  0x3abc,  0x3a93,  0x3a69,\n\t 0x3a40,  0x3a17,  0x39ee,  0x39c5,  0x399c,  0x3972,  0x3949,  0x3920,\n\t 0x38f6,  0x38cd,  0x38a4,  0x387a,  0x3851,  0x3827,  0x37fe,  0x37d4,\n\t 0x37aa,  0x3781,  0x3757,  0x372d,  0x3704,  0x36da,  0x36b0,  0x3686,\n\t 0x365c,  0x3632,  0x3609,  0x35df,  0x35b4,  0x358a,  0x3560,  0x3536,\n\t 0x350c,  0x34e1,  0x34b7,  0x348d,  0x3462,  0x3438,  0x340d,  0x33e3,\n\t 0x33b8,  0x338d,  0x3363,  0x3338,  0x330d,  0x32e2,  0x32b7,  0x328c,\n\t 0x3261,  0x3236,  0x320b,  0x31df,  0x31b4,  0x3188,  0x315d,  0x3131,\n\t 0x3106,  0x30da,  0x30ae,  0x3083,  0x3057,  0x302b,  0x2fff,  0x2fd2,\n\t 0x2fa6,  0x2f7a,  0x2f4d,  0x2f21,  0x2ef4,  0x2ec8,  0x2e9b,  0x2e6e,\n\t 0x2e41,  0x2e14,  0x2de7,  0x2dba,  0x2d8d,  0x2d60,  0x2d32,  0x2d05,\n\t 0x2cd7,  0x2ca9,  0x2c7b,  0x2c4d,  0x2c1f,  0x2bf1,  0x2bc3,  0x2b94,\n\t 0x2b66,  0x2b37,  0x2b09,  0x2ada,  0x2aab,  0x2a7c,  0x2a4c,  0x2a1d,\n\t 0x29ed,  0x29be,  0x298e,  0x295e,  0x292e,  0x28fe,  0x28ce,  0x289d,\n\t 0x286d,  0x283c,  0x280b,  0x27da,  0x27a9,  0x2777,  0x2746,  0x2714,\n\t 0x26e2,  0x26b0,  0x267e,  0x264c,  0x2619,  0x25e7,  0x25b4,  0x2581,\n\t 0x254d,  0x251a,  0x24e6,  0x24b2,  0x247e,  0x244a,  0x2415,  0x23e1,\n\t 0x23ac,  0x2376,  0x2341,  0x230b,  0x22d6,  0x229f,  0x2269,  0x2232,\n\t 0x21fc,  0x21c4,  0x218d,  0x2155,  0x211d,  0x20e5,  0x20ad,  0x2074,\n\t 0x203b,  0x2001,  0x1fc7,  0x1f8d,  0x1f53,  0x1f18,  0x1edd,  0x1ea1,\n\t 0x1e66,  0x1e29,  0x1ded,  0x1db0,  0x1d72,  0x1d35,  0x1cf6,  0x1cb8,\n\t 0x1c79,  0x1c39,  0x1bf9,  0x1bb8,  0x1b77,  0x1b36,  0x1af4,  0x1ab1,\n\t 0x1a6e,  0x1a2a,  0x19e6,  0x19a1,  0x195c,  0x1915,  0x18ce,  0x1887,\n\t 0x183f,  0x17f5,  0x17ac,  0x1761,  0x1715,  0x16c9,  0x167c,  0x162e,\n\t 0x15df,  0x158e,  0x153d,  0x14eb,  0x1497,  0x1442,  0x13ec,  0x1395,\n\t 0x133c,  0x12e2,  0x1286,  0x1228,  0x11c9,  0x1167,  0x1104,  0x109e,\n\t 0x1036,  0x0fcc,  0x0f5f,  0x0eef,  0x0e7b,  0x0e04,  0x0d89,  0x0d0a,\n\t 0x0c86,  0x0bfd,  0x0b6d,  0x0ad6,  0x0a36,  0x098d,  0x08d7,  0x0811,\n\t 0x0736,  0x063e,  0x0519,  0x039a,  0x0000,  0x7fff,  0x0100,  0x0080,\n\t 0x021d,  0x00c8,  0x00ce,  0x0048,  0x0a26,  0x277a,  0x00ce,  0x6488,\n\t 0x14ac,  0x0001,  0x00f9,  0x00fc,  0x00ff,  0x00fc,  0x00f9,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,\n\t 0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff,  0xffff\n};\n\nstatic const int16\tDSP1_MulTable[256] =\n{\n\t 0x0000,  0x0003,  0x0006,  0x0009,  0x000c,  0x000f,  0x0012,  0x0015,\n\t 0x0019,  0x001c,  0x001f,  0x0022,  0x0025,  0x0028,  0x002b,  0x002f,\n\t 0x0032,  0x0035,  0x0038,  0x003b,  0x003e,  0x0041,  0x0045,  0x0048,\n\t 0x004b,  0x004e,  0x0051,  0x0054,  0x0057,  0x005b,  0x005e,  0x0061,\n\t 0x0064,  0x0067,  0x006a,  0x006d,  0x0071,  0x0074,  0x0077,  0x007a,\n\t 0x007d,  0x0080,  0x0083,  0x0087,  0x008a,  0x008d,  0x0090,  0x0093,\n\t 0x0096,  0x0099,  0x009d,  0x00a0,  0x00a3,  0x00a6,  0x00a9,  0x00ac,\n\t 0x00af,  0x00b3,  0x00b6,  0x00b9,  0x00bc,  0x00bf,  0x00c2,  0x00c5,\n\t 0x00c9,  0x00cc,  0x00cf,  0x00d2,  0x00d5,  0x00d8,  0x00db,  0x00df,\n\t 0x00e2,  0x00e5,  0x00e8,  0x00eb,  0x00ee,  0x00f1,  0x00f5,  0x00f8,\n\t 0x00fb,  0x00fe,  0x0101,  0x0104,  0x0107,  0x010b,  0x010e,  0x0111,\n\t 0x0114,  0x0117,  0x011a,  0x011d,  0x0121,  0x0124,  0x0127,  0x012a,\n\t 0x012d,  0x0130,  0x0133,  0x0137,  0x013a,  0x013d,  0x0140,  0x0143,\n\t 0x0146,  0x0149,  0x014d,  0x0150,  0x0153,  0x0156,  0x0159,  0x015c,\n\t 0x015f,  0x0163,  0x0166,  0x0169,  0x016c,  0x016f,  0x0172,  0x0175,\n\t 0x0178,  0x017c,  0x017f,  0x0182,  0x0185,  0x0188,  0x018b,  0x018e,\n\t 0x0192,  0x0195,  0x0198,  0x019b,  0x019e,  0x01a1,  0x01a4,  0x01a8,\n\t 0x01ab,  0x01ae,  0x01b1,  0x01b4,  0x01b7,  0x01ba,  0x01be,  0x01c1,\n\t 0x01c4,  0x01c7,  0x01ca,  0x01cd,  0x01d0,  0x01d4,  0x01d7,  0x01da,\n\t 0x01dd,  0x01e0,  0x01e3,  0x01e6,  0x01ea,  0x01ed,  0x01f0,  0x01f3,\n\t 0x01f6,  0x01f9,  0x01fc,  0x0200,  0x0203,  0x0206,  0x0209,  0x020c,\n\t 0x020f,  0x0212,  0x0216,  0x0219,  0x021c,  0x021f,  0x0222,  0x0225,\n\t 0x0228,  0x022c,  0x022f,  0x0232,  0x0235,  0x0238,  0x023b,  0x023e,\n\t 0x0242,  0x0245,  0x0248,  0x024b,  0x024e,  0x0251,  0x0254,  0x0258,\n\t 0x025b,  0x025e,  0x0261,  0x0264,  0x0267,  0x026a,  0x026e,  0x0271,\n\t 0x0274,  0x0277,  0x027a,  0x027d,  0x0280,  0x0284,  0x0287,  0x028a,\n\t 0x028d,  0x0290,  0x0293,  0x0296,  0x029a,  0x029d,  0x02a0,  0x02a3,\n\t 0x02a6,  0x02a9,  0x02ac,  0x02b0,  0x02b3,  0x02b6,  0x02b9,  0x02bc,\n\t 0x02bf,  0x02c2,  0x02c6,  0x02c9,  0x02cc,  0x02cf,  0x02d2,  0x02d5,\n\t 0x02d8,  0x02db,  0x02df,  0x02e2,  0x02e5,  0x02e8,  0x02eb,  0x02ee,\n\t 0x02f1,  0x02f5,  0x02f8,  0x02fb,  0x02fe,  0x0301,  0x0304,  0x0307,\n\t 0x030b,  0x030e,  0x0311,  0x0314,  0x0317,  0x031a,  0x031d,  0x0321\n};\n\nstatic const int16\tDSP1_SinTable[256] =\n{\n\t 0x0000,  0x0324,  0x0647,  0x096a,  0x0c8b,  0x0fab,  0x12c8,  0x15e2,\n\t 0x18f8,  0x1c0b,  0x1f19,  0x2223,  0x2528,  0x2826,  0x2b1f,  0x2e11,\n\t 0x30fb,  0x33de,  0x36ba,  0x398c,  0x3c56,  0x3f17,  0x41ce,  0x447a,\n\t 0x471c,  0x49b4,  0x4c3f,  0x4ebf,  0x5133,  0x539b,  0x55f5,  0x5842,\n\t 0x5a82,  0x5cb4,  0x5ed7,  0x60ec,  0x62f2,  0x64e8,  0x66cf,  0x68a6,\n\t 0x6a6d,  0x6c24,  0x6dca,  0x6f5f,  0x70e2,  0x7255,  0x73b5,  0x7504,\n\t 0x7641,  0x776c,  0x7884,  0x798a,  0x7a7d,  0x7b5d,  0x7c29,  0x7ce3,\n\t 0x7d8a,  0x7e1d,  0x7e9d,  0x7f09,  0x7f62,  0x7fa7,  0x7fd8,  0x7ff6,\n\t 0x7fff,  0x7ff6,  0x7fd8,  0x7fa7,  0x7f62,  0x7f09,  0x7e9d,  0x7e1d,\n\t 0x7d8a,  0x7ce3,  0x7c29,  0x7b5d,  0x7a7d,  0x798a,  0x7884,  0x776c,\n\t 0x7641,  0x7504,  0x73b5,  0x7255,  0x70e2,  0x6f5f,  0x6dca,  0x6c24,\n\t 0x6a6d,  0x68a6,  0x66cf,  0x64e8,  0x62f2,  0x60ec,  0x5ed7,  0x5cb4,\n\t 0x5a82,  0x5842,  0x55f5,  0x539b,  0x5133,  0x4ebf,  0x4c3f,  0x49b4,\n\t 0x471c,  0x447a,  0x41ce,  0x3f17,  0x3c56,  0x398c,  0x36ba,  0x33de,\n\t 0x30fb,  0x2e11,  0x2b1f,  0x2826,  0x2528,  0x2223,  0x1f19,  0x1c0b,\n\t 0x18f8,  0x15e2,  0x12c8,  0x0fab,  0x0c8b,  0x096a,  0x0647,  0x0324,\n\t-0x0000, -0x0324, -0x0647, -0x096a, -0x0c8b, -0x0fab, -0x12c8, -0x15e2,\n\t-0x18f8, -0x1c0b, -0x1f19, -0x2223, -0x2528, -0x2826, -0x2b1f, -0x2e11,\n\t-0x30fb, -0x33de, -0x36ba, -0x398c, -0x3c56, -0x3f17, -0x41ce, -0x447a,\n\t-0x471c, -0x49b4, -0x4c3f, -0x4ebf, -0x5133, -0x539b, -0x55f5, -0x5842,\n\t-0x5a82, -0x5cb4, -0x5ed7, -0x60ec, -0x62f2, -0x64e8, -0x66cf, -0x68a6,\n\t-0x6a6d, -0x6c24, -0x6dca, -0x6f5f, -0x70e2, -0x7255, -0x73b5, -0x7504,\n\t-0x7641, -0x776c, -0x7884, -0x798a, -0x7a7d, -0x7b5d, -0x7c29, -0x7ce3,\n\t-0x7d8a, -0x7e1d, -0x7e9d, -0x7f09, -0x7f62, -0x7fa7, -0x7fd8, -0x7ff6,\n\t-0x7fff, -0x7ff6, -0x7fd8, -0x7fa7, -0x7f62, -0x7f09, -0x7e9d, -0x7e1d,\n\t-0x7d8a, -0x7ce3, -0x7c29, -0x7b5d, -0x7a7d, -0x798a, -0x7884, -0x776c,\n\t-0x7641, -0x7504, -0x73b5, -0x7255, -0x70e2, -0x6f5f, -0x6dca, -0x6c24,\n\t-0x6a6d, -0x68a6, -0x66cf, -0x64e8, -0x62f2, -0x60ec, -0x5ed7, -0x5cb4,\n\t-0x5a82, -0x5842, -0x55f5, -0x539b, -0x5133, -0x4ebf, -0x4c3f, -0x49b4,\n\t-0x471c, -0x447a, -0x41ce, -0x3f17, -0x3c56, -0x398c, -0x36ba, -0x33de,\n\t-0x30fb, -0x2e11, -0x2b1f, -0x2826, -0x2528, -0x2223, -0x1f19, -0x1c0b,\n\t-0x18f8, -0x15e2, -0x12c8, -0x0fab, -0x0c8b, -0x096a, -0x0647, -0x0324\n};\n\n\n#ifdef DebugDSP1\n\nstatic void Log_Message (const char *Message, ...)\n{\n\tchar\tMsg[400];\n\tva_list\tap;\n\tsize_t\tignore;\n\n\tva_start(ap, Message);\n\tvsprintf(Msg, Message, ap);\n\tva_end(ap);\n\n\tstrcat(Msg, \"\\r\\n\\0\");\n\tignore = fwrite(Msg, strlen(Msg), 1, LogFile);\n\tfflush(LogFile);\n}\n\nstatic void Start_Log (void)\n{\n\tLogFile = fopen(\"dsp1emu.log\", \"wb\");\n}\n\nstatic void Stop_Log (void)\n{\n\tif (LogFile)\n\t{\n\t\tfclose(LogFile);\n\t\tLogFile = NULL;\n\t}\n}\n\n#endif\n\nstatic void DSP1_Op00 (void)\n{\n\tDSP1.Op00Result = DSP1.Op00Multiplicand * DSP1.Op00Multiplier >> 15;\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP00 MULT %d*%d/32768=%d\", DSP1.Op00Multiplicand, DSP1.Op00Multiplier, DSP1.Op00Result);\n#endif\n}\n\nstatic void DSP1_Op20 (void)\n{\n\tDSP1.Op20Result = DSP1.Op20Multiplicand * DSP1.Op20Multiplier >> 15;\n\tDSP1.Op20Result++;\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP20 MULT %d*%d/32768=%d\", DSP1.Op20Multiplicand, DSP1.Op20Multiplier, DSP1.Op20Result);\n#endif\n}\n\nstatic void DSP1_Inverse (int16 Coefficient, int16 Exponent, int16 *iCoefficient, int16 *iExponent)\n{\n\t// Step One: Division by Zero\n\tif (Coefficient == 0x0000)\n\t{\n\t\t*iCoefficient = 0x7fff;\n\t\t*iExponent    = 0x002f;\n\t}\n\telse\n\t{\n\t\tint16\tSign = 1;\n\n\t\t// Step Two: Remove Sign\n\t\tif (Coefficient < 0)\n\t\t{\n\t\t\tif (Coefficient < -32767)\n\t\t\t\tCoefficient = -32767;\n\t\t\tCoefficient = -Coefficient;\n\t\t\tSign = -1;\n\t\t}\n\n\t\t// Step Three: Normalize\n#ifdef __GNUC__\n\t\tconst int shift = __builtin_clz(Coefficient) - (8 * sizeof(int) - 15);\n\t\tCoefficient <<= shift;\n\t\tExponent -= shift;\n#else\n\t\twhile (Coefficient < 0x4000)\n\t\t{\n\t\t\tCoefficient <<= 1;\n\t\t\tExponent--;\n\t\t}\n#endif\n\n\t\t// Step Four: Special Case\n\t\tif (Coefficient == 0x4000)\n\t\t{\n\t\t\tif (Sign == 1)\n\t\t\t\t*iCoefficient =  0x7fff;\n\t\t\telse\n\t\t\t{\n\t\t\t\t*iCoefficient = -0x4000;\n\t\t\t\tExponent--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Step Five: Initial Guess\n\t\t\tint16\ti = DSP1ROM[((Coefficient - 0x4000) >> 7) + 0x0065];\n\n\t\t\t// Step Six: Iterate \"estimated\" Newton's Method\n\t\t\ti = (i + (-i * (Coefficient * i >> 15) >> 15)) << 1;\n\t\t\ti = (i + (-i * (Coefficient * i >> 15) >> 15)) << 1;\n\n\t\t\t*iCoefficient = i * Sign;\n\t\t}\n\n\t\t*iExponent = 1 - Exponent;\n\t}\n}\n\nstatic void DSP1_Op10 (void)\n{\n\tDSP1_Inverse(DSP1.Op10Coefficient, DSP1.Op10Exponent, &DSP1.Op10CoefficientR, &DSP1.Op10ExponentR);\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP10 INV %d*2^%d = %d*2^%d\", DSP1.Op10Coefficient, DSP1.Op10Exponent, DSP1.Op10CoefficientR, DSP1.Op10ExponentR);\n#endif\n}\n\nstatic int16 DSP1_Sin (int16 Angle)\n{\n\tint32\tS;\n\n\tif (Angle < 0)\n\t{\n\t\tif (Angle == -32768)\n\t\t\treturn (0);\n\n\t\treturn (-DSP1_Sin(-Angle));\n\t}\n\n\tS = DSP1_SinTable[Angle >> 8] + (DSP1_MulTable[Angle & 0xff] * DSP1_SinTable[0x40 + (Angle >> 8)] >> 15);\n\tif (S > 32767)\n\t\tS = 32767;\n\n\treturn ((int16) S);\n}\n\nstatic int16 DSP1_Cos (int16 Angle)\n{\n\tint32\tS;\n\n\tif (Angle < 0)\n\t{\n\t\tif (Angle == -32768)\n\t\t\treturn (-32768);\n\n\t\tAngle = -Angle;\n\t}\n\n\tS = DSP1_SinTable[0x40 + (Angle >> 8)] - (DSP1_MulTable[Angle & 0xff] * DSP1_SinTable[Angle >> 8] >> 15);\n\tif (S < -32768)\n\t\tS = -32767;\n\n\treturn ((int16) S);\n}\n\nstatic void DSP1_Normalize (int16 m, int16 *Coefficient, int16 *Exponent)\n{\n\tint16\te = 0;\n\n#ifdef __GNUC__\n\tint16\tn = m < 0 ? ~m : m;\n\n\tif (n == 0)\n\t\te = 15;\n\telse\n\t\te = __builtin_clz(n) - (8 * sizeof(int) - 15);\n#else\n\tint16\ti = 0x4000;\n\n\tif (m < 0)\n\t{\n\t\twhile ((m & i) && i)\n\t\t{\n\t\t\ti >>= 1;\n\t\t\te++;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (!(m & i) && i)\n\t\t{\n\t\t\ti >>= 1;\n\t\t\te++;\n\t\t}\n\t}\n#endif\n\n\tif (e > 0)\n\t\t*Coefficient = m * DSP1ROM[0x21 + e] << 1;\n\telse\n\t\t*Coefficient = m;\n\n\t*Exponent -= e;\n}\n\nstatic void DSP1_NormalizeDouble (int32 Product, int16 *Coefficient, int16 *Exponent)\n{\n\tint16\tn = Product & 0x7fff;\n\tint16\tm = Product >> 15;\n\tint16\te = 0;\n\n#ifdef __GNUC__\n\tint16\tt = m < 0 ? ~m : m;\n\n\tif (t == 0)\n\t\te = 15;\n\telse\n\t\te = __builtin_clz(t) - (8 * sizeof(int) - 15);\n#else\n\tint16\ti = 0x4000;\n\n\tif (m < 0)\n\t{\n\t\twhile ((m & i) && i)\n\t\t{\n\t\t\ti >>= 1;\n\t\t\te++;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (!(m & i) && i)\n\t\t{\n\t\t\ti >>= 1;\n\t\t\te++;\n\t\t}\n\t}\n#endif\n\n\tif (e > 0)\n\t{\n\t\t*Coefficient = m * DSP1ROM[0x0021 + e] << 1;\n\n\t\tif (e < 15)\n\t\t\t*Coefficient += n * DSP1ROM[0x0040 - e] >> 15;\n\t\telse\n\t\t{\n#ifdef __GNUC__\n\t\t\tt = m < 0 ? ~(n | 0x8000) : n;\n\n\t\t\tif (t == 0)\n\t\t\t\te += 15;\n\t\t\telse\n\t\t\t\te += __builtin_clz(t) - (8 * sizeof(int) - 15);\n#else\n\t\t\ti = 0x4000;\n\n\t\t\tif (m < 0)\n\t\t\t{\n\t\t\t\twhile ((n & i) && i)\n\t\t\t\t{\n\t\t\t\t\ti >>= 1;\n\t\t\t\t\te++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (!(n & i) && i)\n\t\t\t\t{\n\t\t\t\t\ti >>= 1;\n\t\t\t\t\te++;\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t\tif (e > 15)\n\t\t\t\t*Coefficient = n * DSP1ROM[0x0012 + e] << 1;\n\t\t\telse\n\t\t\t\t*Coefficient += n;\n\t\t}\n\t}\n\telse\n\t\t*Coefficient = m;\n\n\t*Exponent = e;\n}\n\nstatic int16 DSP1_Truncate (int16 C, int16 E)\n{\n\tif (E > 0)\n\t{\n\t\tif (C > 0)\n\t\t\treturn (32767);\n\t\telse\n\t\tif (C < 0)\n\t\t\treturn (-32767);\n\t}\n\telse\n\t{\n\t\tif (E < 0)\n\t\t\treturn (C * DSP1ROM[0x0031 + E] >> 15);\n\t}\n\n\treturn (C);\n}\n\nstatic void DSP1_Op04 (void)\n{\n\tDSP1.Op04Sin = DSP1_Sin(DSP1.Op04Angle) * DSP1.Op04Radius >> 15;\n\tDSP1.Op04Cos = DSP1_Cos(DSP1.Op04Angle) * DSP1.Op04Radius >> 15;\n}\n\nstatic void DSP1_Op0C (void)\n{\n\tDSP1.Op0CX2 = (DSP1.Op0CY1 * DSP1_Sin(DSP1.Op0CA) >> 15) + (DSP1.Op0CX1 * DSP1_Cos(DSP1.Op0CA) >> 15);\n\tDSP1.Op0CY2 = (DSP1.Op0CY1 * DSP1_Cos(DSP1.Op0CA) >> 15) - (DSP1.Op0CX1 * DSP1_Sin(DSP1.Op0CA) >> 15);\n}\n\nstatic void DSP1_Parameter (int16 Fx, int16 Fy, int16 Fz, int16 Lfe, int16 Les, int16 Aas, int16 Azs, int16 *Vof, int16 *Vva, int16 *Cx, int16 *Cy)\n{\n\tstatic const int16\tMaxAZS_Exp[16] =\n\t{\n\t\t0x38b4, 0x38b7, 0x38ba, 0x38be, 0x38c0, 0x38c4, 0x38c7, 0x38ca,\n\t\t0x38ce,\t0x38d0, 0x38d4, 0x38d7, 0x38da, 0x38dd, 0x38e0, 0x38e4\n\t};\n\n\tint16\tCSec, C, E, MaxAZS, Aux;\n\tint16\tLfeNx, LfeNy, LfeNz;\n\tint16\tLesNx, LesNy, LesNz;\n\tint16\tCentreZ;\n\n\t// Copy Zenith angle for clipping\n\tint16\tAZS = Azs;\n\n\t// Store Sine and Cosine of Azimuth and Zenith angle\n\tDSP1.SinAas = DSP1_Sin(Aas);\n\tDSP1.CosAas = DSP1_Cos(Aas);\n\tDSP1.SinAzs = DSP1_Sin(Azs);\n\tDSP1.CosAzs = DSP1_Cos(Azs);\n\n\tDSP1.Nx = DSP1.SinAzs * -DSP1.SinAas >> 15;\n\tDSP1.Ny = DSP1.SinAzs *  DSP1.CosAas >> 15;\n\tDSP1.Nz = DSP1.CosAzs *  0x7fff >> 15;\n\n\tLfeNx = Lfe * DSP1.Nx >> 15;\n\tLfeNy = Lfe * DSP1.Ny >> 15;\n\tLfeNz = Lfe * DSP1.Nz >> 15;\n\n\t// Center of Projection\n\tDSP1.CentreX = Fx + LfeNx;\n\tDSP1.CentreY = Fy + LfeNy;\n\tCentreZ = Fz + LfeNz;\n\n\tLesNx = Les * DSP1.Nx >> 15;\n\tLesNy = Les * DSP1.Ny >> 15;\n\tLesNz = Les * DSP1.Nz >> 15;\n\n\tDSP1.Gx = DSP1.CentreX - LesNx;\n\tDSP1.Gy = DSP1.CentreY - LesNy;\n\tDSP1.Gz = CentreZ - LesNz;\n\n\tDSP1.E_Les = 0;\n\tDSP1_Normalize(Les, &DSP1.C_Les, &DSP1.E_Les);\n\tDSP1.G_Les = Les;\n\n\tE = 0;\n\tDSP1_Normalize(CentreZ, &C, &E);\n\n\tDSP1.VPlane_C = C;\n\tDSP1.VPlane_E = E;\n\n\t// Determine clip boundary and clip Zenith angle if necessary\n\tMaxAZS = MaxAZS_Exp[-E];\n\n\tif (AZS < 0)\n\t{\n\t\tMaxAZS = -MaxAZS;\n\t\tif (AZS < MaxAZS + 1)\n\t\t\tAZS = MaxAZS + 1;\n\t}\n\telse\n\t{\n\t\tif (AZS > MaxAZS)\n\t\t\tAZS = MaxAZS;\n\t}\n\n\t// Store Sine and Cosine of clipped Zenith angle\n\tDSP1.SinAZS = DSP1_Sin(AZS);\n\tDSP1.CosAZS = DSP1_Cos(AZS);\n\n\tDSP1_Inverse(DSP1.CosAZS, 0, &DSP1.SecAZS_C1, &DSP1.SecAZS_E1);\n\tDSP1_Normalize(C * DSP1.SecAZS_C1 >> 15, &C, &E);\n\tE += DSP1.SecAZS_E1;\n\n\tC = DSP1_Truncate(C, E) * DSP1.SinAZS >> 15;\n\n\tDSP1.CentreX += C * DSP1.SinAas >> 15;\n\tDSP1.CentreY -= C * DSP1.CosAas >> 15;\n\n\t*Cx = DSP1.CentreX;\n\t*Cy = DSP1.CentreY;\n\n\t// Raster number of imaginary center and horizontal line\n\t*Vof = 0;\n\n\tif ((Azs != AZS) || (Azs == MaxAZS))\n\t{\n\t\tif (Azs == -32768)\n\t\t\tAzs = -32767;\n\n\t\tC = Azs - MaxAZS;\n\t\tif (C >= 0)\n\t\t\tC--;\n\t\tAux = ~(C << 2);\n\n\t\tC = Aux * DSP1ROM[0x0328] >> 15;\n\t\tC = (C * Aux >> 15) + DSP1ROM[0x0327];\n\t\t*Vof -= (C * Aux >> 15) * Les >> 15;\n\n\t\tC = Aux * Aux >> 15;\n\t\tAux = (C * DSP1ROM[0x0324] >> 15) + DSP1ROM[0x0325];\n\t\tDSP1.CosAZS += (C * Aux >> 15) * DSP1.CosAZS >> 15;\n\t}\n\n\tDSP1.VOffset = Les * DSP1.CosAZS >> 15;\n\n\tDSP1_Inverse(DSP1.SinAZS, 0, &CSec, &E);\n\tDSP1_Normalize(DSP1.VOffset, &C, &E);\n\tDSP1_Normalize(C * CSec >> 15, &C, &E);\n\n\tif (C == -32768)\n\t{\n\t\tC >>= 1;\n\t\tE++;\n\t}\n\n\t*Vva = DSP1_Truncate(-C, E);\n\n\t// Store Secant of clipped Zenith angle\n\tDSP1_Inverse(DSP1.CosAZS, 0, &DSP1.SecAZS_C2, &DSP1.SecAZS_E2);\n}\n\nstatic void DSP1_Raster (int16 Vs, int16 *An, int16 *Bn, int16 *Cn, int16 *Dn)\n{\n\tint16\tC, E, C1, E1;\n\n\tDSP1_Inverse((Vs * DSP1.SinAzs >> 15) + DSP1.VOffset, 7, &C, &E);\n\tE += DSP1.VPlane_E;\n\n\tC1 = C * DSP1.VPlane_C >> 15;\n\tE1 = E + DSP1.SecAZS_E2;\n\n\tDSP1_Normalize(C1, &C, &E);\n\n\tC = DSP1_Truncate(C, E);\n\n\t*An = C *  DSP1.CosAas >> 15;\n\t*Cn = C *  DSP1.SinAas >> 15;\n\n\tDSP1_Normalize(C1 * DSP1.SecAZS_C2 >> 15, &C, &E1);\n\n\tC = DSP1_Truncate(C, E1);\n\n\t*Bn = C * -DSP1.SinAas >> 15;\n\t*Dn = C *  DSP1.CosAas >> 15;\n}\n\nstatic void DSP1_Op02 (void)\n{\n\tDSP1_Parameter(DSP1.Op02FX, DSP1.Op02FY, DSP1.Op02FZ, DSP1.Op02LFE, DSP1.Op02LES, DSP1.Op02AAS, DSP1.Op02AZS, &DSP1.Op02VOF, &DSP1.Op02VVA, &DSP1.Op02CX, &DSP1.Op02CY);\n}\n\nstatic void DSP1_Op0A (void)\n{\n\tDSP1_Raster(DSP1.Op0AVS, &DSP1.Op0AA, &DSP1.Op0AB, &DSP1.Op0AC, &DSP1.Op0AD);\n\tDSP1.Op0AVS++;\n}\n\nstatic int16 DSP1_ShiftR (int16 C, int16 E)\n{\n\treturn (C * DSP1ROM[0x0031 + E] >> 15);\n}\n\nstatic void DSP1_Project (int16 X, int16 Y, int16 Z, int16 *H, int16 *V, int16 *M)\n{\n\tint32\taux, aux4;\n\tint16\tE, E2, E3, E4, E5, refE, E6, E7;\n\tint16\tC2, C4, C6, C8, C9, C10, C11, C12, C16, C17, C18, C19, C20, C21, C22, C23, C24, C25, C26;\n\tint16\tPx, Py, Pz;\n\n\tE4 = E3 = E2 = E = E5 = 0;\n\n\tDSP1_NormalizeDouble((int32) X - DSP1.Gx, &Px, &E4);\n\tDSP1_NormalizeDouble((int32) Y - DSP1.Gy, &Py, &E );\n\tDSP1_NormalizeDouble((int32) Z - DSP1.Gz, &Pz, &E3);\n\tPx >>= 1; // to avoid overflows when calculating the scalar products\n\tE4--;\n\tPy >>= 1;\n\tE--;\n\tPz >>= 1;\n\tE3--;\n\n\trefE = (E < E3) ? E : E3;\n\trefE = (refE < E4) ? refE : E4;\n\n\tPx = DSP1_ShiftR(Px, E4 - refE); // normalize them to the same exponent\n\tPy = DSP1_ShiftR(Py, E  - refE);\n\tPz = DSP1_ShiftR(Pz, E3 - refE);\n\n\tC11 = -(Px * DSP1.Nx >> 15);\n\tC8  = -(Py * DSP1.Ny >> 15);\n\tC9  = -(Pz * DSP1.Nz >> 15);\n\tC12 = C11 + C8 + C9; // this cannot overflow!\n\n\taux4 = C12; // de-normalization with 32-bits arithmetic\n\trefE = 16 - refE; // refE can be up to 3\n\tif (refE >= 0)\n\t\taux4 <<=  (refE);\n\telse\n\t\taux4 >>= -(refE);\n\tif (aux4 == -1)\n\t\taux4 = 0; // why?\n\taux4 >>= 1;\n\n\taux = ((uint16) DSP1.G_Les) + aux4; // Les - the scalar product of P with the normal vector of the screen\n\tDSP1_NormalizeDouble(aux, &C10, &E2);\n\tE2 = 15 - E2;\n\n\tDSP1_Inverse(C10, 0, &C4, &E4);\n\tC2 = C4 * DSP1.C_Les >> 15; // scale factor\n\n\t// H\n\tE7 = 0;\n\tC16 = Px * ( DSP1.CosAas *  0x7fff >> 15) >> 15;\n\tC20 = Py * ( DSP1.SinAas *  0x7fff >> 15) >> 15;\n\tC17 = C16 + C20; // scalar product of P with the normalized horizontal vector of the screen...\n\n\tC18 = C17 * C2 >> 15; // ... multiplied by the scale factor\n\tDSP1_Normalize(C18, &C19, &E7);\n\t*H = DSP1_Truncate(C19, DSP1.E_Les - E2 + refE + E7);\n\n\t// V\n\tE6 = 0;\n\tC21 = Px * ( DSP1.CosAzs * -DSP1.SinAas >> 15) >> 15;\n\tC22 = Py * ( DSP1.CosAzs *  DSP1.CosAas >> 15) >> 15;\n\tC23 = Pz * (-DSP1.SinAzs *  0x7fff >> 15) >> 15;\n\tC24 = C21 + C22 + C23; // scalar product of P with the normalized vertical vector of the screen...\n\n\tC26 = C24 * C2 >> 15; // ... multiplied by the scale factor\n\tDSP1_Normalize(C26, &C25, &E6);\n\t*V = DSP1_Truncate(C25, DSP1.E_Les - E2 + refE + E6);\n\n\t// M\n\tDSP1_Normalize(C2, &C6, &E4);\n\t*M = DSP1_Truncate(C6, E4 + DSP1.E_Les - E2 - 7); // M is the scale factor divided by 2^7\n}\n\nstatic void DSP1_Op06 (void)\n{\n\tDSP1_Project(DSP1.Op06X, DSP1.Op06Y, DSP1.Op06Z, &DSP1.Op06H, &DSP1.Op06V, &DSP1.Op06M);\n}\n\nstatic void DSP1_Op01 (void)\n{\n\tint16\tSinAz = DSP1_Sin(DSP1.Op01Zr);\n\tint16\tCosAz = DSP1_Cos(DSP1.Op01Zr);\n\tint16\tSinAy = DSP1_Sin(DSP1.Op01Yr);\n\tint16\tCosAy = DSP1_Cos(DSP1.Op01Yr);\n\tint16\tSinAx = DSP1_Sin(DSP1.Op01Xr);\n\tint16\tCosAx = DSP1_Cos(DSP1.Op01Xr);\n\n\tDSP1.Op01m >>= 1;\n\n\tDSP1.matrixA[0][0] =   (DSP1.Op01m * CosAz >> 15) * CosAy >> 15;\n\tDSP1.matrixA[0][1] = -((DSP1.Op01m * SinAz >> 15) * CosAy >> 15);\n\tDSP1.matrixA[0][2] =    DSP1.Op01m * SinAy >> 15;\n\n\tDSP1.matrixA[1][0] =  ((DSP1.Op01m * SinAz >> 15) * CosAx >> 15) + (((DSP1.Op01m * CosAz >> 15) * SinAx >> 15) * SinAy >> 15);\n\tDSP1.matrixA[1][1] =  ((DSP1.Op01m * CosAz >> 15) * CosAx >> 15) - (((DSP1.Op01m * SinAz >> 15) * SinAx >> 15) * SinAy >> 15);\n\tDSP1.matrixA[1][2] = -((DSP1.Op01m * SinAx >> 15) * CosAy >> 15);\n\n\tDSP1.matrixA[2][0] =  ((DSP1.Op01m * SinAz >> 15) * SinAx >> 15) - (((DSP1.Op01m * CosAz >> 15) * CosAx >> 15) * SinAy >> 15);\n\tDSP1.matrixA[2][1] =  ((DSP1.Op01m * CosAz >> 15) * SinAx >> 15) + (((DSP1.Op01m * SinAz >> 15) * CosAx >> 15) * SinAy >> 15);\n\tDSP1.matrixA[2][2] =   (DSP1.Op01m * CosAx >> 15) * CosAy >> 15;\n}\n\nstatic void DSP1_Op11 (void)\n{\n\tint16\tSinAz = DSP1_Sin(DSP1.Op11Zr);\n\tint16\tCosAz = DSP1_Cos(DSP1.Op11Zr);\n\tint16\tSinAy = DSP1_Sin(DSP1.Op11Yr);\n\tint16\tCosAy = DSP1_Cos(DSP1.Op11Yr);\n\tint16\tSinAx = DSP1_Sin(DSP1.Op11Xr);\n\tint16\tCosAx = DSP1_Cos(DSP1.Op11Xr);\n\n\tDSP1.Op11m >>= 1;\n\n\tDSP1.matrixB[0][0] =   (DSP1.Op11m * CosAz >> 15) * CosAy >> 15;\n\tDSP1.matrixB[0][1] = -((DSP1.Op11m * SinAz >> 15) * CosAy >> 15);\n\tDSP1.matrixB[0][2] =    DSP1.Op11m * SinAy >> 15;\n\n\tDSP1.matrixB[1][0] =  ((DSP1.Op11m * SinAz >> 15) * CosAx >> 15) + (((DSP1.Op11m * CosAz >> 15) * SinAx >> 15) * SinAy >> 15);\n\tDSP1.matrixB[1][1] =  ((DSP1.Op11m * CosAz >> 15) * CosAx >> 15) - (((DSP1.Op11m * SinAz >> 15) * SinAx >> 15) * SinAy >> 15);\n\tDSP1.matrixB[1][2] = -((DSP1.Op11m * SinAx >> 15) * CosAy >> 15);\n\n\tDSP1.matrixB[2][0] =  ((DSP1.Op11m * SinAz >> 15) * SinAx >> 15) - (((DSP1.Op11m * CosAz >> 15) * CosAx >> 15) * SinAy >> 15);\n\tDSP1.matrixB[2][1] =  ((DSP1.Op11m * CosAz >> 15) * SinAx >> 15) + (((DSP1.Op11m * SinAz >> 15) * CosAx >> 15) * SinAy >> 15);\n\tDSP1.matrixB[2][2] =   (DSP1.Op11m * CosAx >> 15) * CosAy >> 15;\n}\n\nstatic void DSP1_Op21 (void)\n{\n\tint16\tSinAz = DSP1_Sin(DSP1.Op21Zr);\n\tint16\tCosAz = DSP1_Cos(DSP1.Op21Zr);\n\tint16\tSinAy = DSP1_Sin(DSP1.Op21Yr);\n\tint16\tCosAy = DSP1_Cos(DSP1.Op21Yr);\n\tint16\tSinAx = DSP1_Sin(DSP1.Op21Xr);\n\tint16\tCosAx = DSP1_Cos(DSP1.Op21Xr);\n\n\tDSP1.Op21m >>= 1;\n\n\tDSP1.matrixC[0][0] =   (DSP1.Op21m * CosAz >> 15) * CosAy >> 15;\n\tDSP1.matrixC[0][1] = -((DSP1.Op21m * SinAz >> 15) * CosAy >> 15);\n\tDSP1.matrixC[0][2] =    DSP1.Op21m * SinAy >> 15;\n\n\tDSP1.matrixC[1][0] =  ((DSP1.Op21m * SinAz >> 15) * CosAx >> 15) + (((DSP1.Op21m * CosAz >> 15) * SinAx >> 15) * SinAy >> 15);\n\tDSP1.matrixC[1][1] =  ((DSP1.Op21m * CosAz >> 15) * CosAx >> 15) - (((DSP1.Op21m * SinAz >> 15) * SinAx >> 15) * SinAy >> 15);\n\tDSP1.matrixC[1][2] = -((DSP1.Op21m * SinAx >> 15) * CosAy >> 15);\n\n\tDSP1.matrixC[2][0] =  ((DSP1.Op21m * SinAz >> 15) * SinAx >> 15) - (((DSP1.Op21m * CosAz >> 15) * CosAx >> 15) * SinAy >> 15);\n\tDSP1.matrixC[2][1] =  ((DSP1.Op21m * CosAz >> 15) * SinAx >> 15) + (((DSP1.Op21m * SinAz >> 15) * CosAx >> 15) * SinAy >> 15);\n\tDSP1.matrixC[2][2] =   (DSP1.Op21m * CosAx >> 15) * CosAy >> 15;\n}\n\nstatic void DSP1_Op0D (void)\n{\n\tDSP1.Op0DF = (DSP1.Op0DX * DSP1.matrixA[0][0] >> 15) + (DSP1.Op0DY * DSP1.matrixA[0][1] >> 15) + (DSP1.Op0DZ * DSP1.matrixA[0][2] >> 15);\n\tDSP1.Op0DL = (DSP1.Op0DX * DSP1.matrixA[1][0] >> 15) + (DSP1.Op0DY * DSP1.matrixA[1][1] >> 15) + (DSP1.Op0DZ * DSP1.matrixA[1][2] >> 15);\n\tDSP1.Op0DU = (DSP1.Op0DX * DSP1.matrixA[2][0] >> 15) + (DSP1.Op0DY * DSP1.matrixA[2][1] >> 15) + (DSP1.Op0DZ * DSP1.matrixA[2][2] >> 15);\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP0D X: %d Y: %d Z: %d / F: %d L: %d U: %d\", DSP1.Op0DX, DSP1.Op0DY, DSP1.Op0DZ, DSP1.Op0DF, DSP1.Op0DL, DSP1.Op0DU);\n#endif\n}\n\nstatic void DSP1_Op1D (void)\n{\n\tDSP1.Op1DF = (DSP1.Op1DX * DSP1.matrixB[0][0] >> 15) + (DSP1.Op1DY * DSP1.matrixB[0][1] >> 15) + (DSP1.Op1DZ * DSP1.matrixB[0][2] >> 15);\n\tDSP1.Op1DL = (DSP1.Op1DX * DSP1.matrixB[1][0] >> 15) + (DSP1.Op1DY * DSP1.matrixB[1][1] >> 15) + (DSP1.Op1DZ * DSP1.matrixB[1][2] >> 15);\n\tDSP1.Op1DU = (DSP1.Op1DX * DSP1.matrixB[2][0] >> 15) + (DSP1.Op1DY * DSP1.matrixB[2][1] >> 15) + (DSP1.Op1DZ * DSP1.matrixB[2][2] >> 15);\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP1D X: %d Y: %d Z: %d / F: %d L: %d U: %d\", DSP1.Op1DX, DSP1.Op1DY, DSP1.Op1DZ, DSP1.Op1DF, DSP1.Op1DL, DSP1.Op1DU);\n#endif\n}\n\nstatic void DSP1_Op2D (void)\n{\n\tDSP1.Op2DF = (DSP1.Op2DX * DSP1.matrixC[0][0] >> 15) + (DSP1.Op2DY * DSP1.matrixC[0][1] >> 15) + (DSP1.Op2DZ * DSP1.matrixC[0][2] >> 15);\n\tDSP1.Op2DL = (DSP1.Op2DX * DSP1.matrixC[1][0] >> 15) + (DSP1.Op2DY * DSP1.matrixC[1][1] >> 15) + (DSP1.Op2DZ * DSP1.matrixC[1][2] >> 15);\n\tDSP1.Op2DU = (DSP1.Op2DX * DSP1.matrixC[2][0] >> 15) + (DSP1.Op2DY * DSP1.matrixC[2][1] >> 15) + (DSP1.Op2DZ * DSP1.matrixC[2][2] >> 15);\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP2D X: %d Y: %d Z: %d / F: %d L: %d U: %d\", DSP1.Op2DX, DSP1.Op2DY, DSP1.Op2DZ, DSP1.Op2DF, DSP1.Op2DL, DSP1.Op2DU);\n#endif\n}\n\nstatic void DSP1_Op03 (void)\n{\n\tDSP1.Op03X = (DSP1.Op03F * DSP1.matrixA[0][0] >> 15) + (DSP1.Op03L * DSP1.matrixA[1][0] >> 15) + (DSP1.Op03U * DSP1.matrixA[2][0] >> 15);\n\tDSP1.Op03Y = (DSP1.Op03F * DSP1.matrixA[0][1] >> 15) + (DSP1.Op03L * DSP1.matrixA[1][1] >> 15) + (DSP1.Op03U * DSP1.matrixA[2][1] >> 15);\n\tDSP1.Op03Z = (DSP1.Op03F * DSP1.matrixA[0][2] >> 15) + (DSP1.Op03L * DSP1.matrixA[1][2] >> 15) + (DSP1.Op03U * DSP1.matrixA[2][2] >> 15);\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP03 F: %d L: %d U: %d / X: %d Y: %d Z: %d\", DSP1.Op03F, DSP1.Op03L, DSP1.Op03U, DSP1.Op03X, DSP1.Op03Y, DSP1.Op03Z);\n#endif\n}\n\nstatic void DSP1_Op13 (void)\n{\n\tDSP1.Op13X = (DSP1.Op13F * DSP1.matrixB[0][0] >> 15) + (DSP1.Op13L * DSP1.matrixB[1][0] >> 15) + (DSP1.Op13U * DSP1.matrixB[2][0] >> 15);\n\tDSP1.Op13Y = (DSP1.Op13F * DSP1.matrixB[0][1] >> 15) + (DSP1.Op13L * DSP1.matrixB[1][1] >> 15) + (DSP1.Op13U * DSP1.matrixB[2][1] >> 15);\n\tDSP1.Op13Z = (DSP1.Op13F * DSP1.matrixB[0][2] >> 15) + (DSP1.Op13L * DSP1.matrixB[1][2] >> 15) + (DSP1.Op13U * DSP1.matrixB[2][2] >> 15);\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP13 F: %d L: %d U: %d / X: %d Y: %d Z: %d\", DSP1.Op13F, DSP1.Op13L, DSP1.Op13U, DSP1.Op13X, DSP1.Op13Y, DSP1.Op13Z);\n#endif\n}\n\nstatic void DSP1_Op23 (void)\n{\n\tDSP1.Op23X = (DSP1.Op23F * DSP1.matrixC[0][0] >> 15) + (DSP1.Op23L * DSP1.matrixC[1][0] >> 15) + (DSP1.Op23U * DSP1.matrixC[2][0] >> 15);\n\tDSP1.Op23Y = (DSP1.Op23F * DSP1.matrixC[0][1] >> 15) + (DSP1.Op23L * DSP1.matrixC[1][1] >> 15) + (DSP1.Op23U * DSP1.matrixC[2][1] >> 15);\n\tDSP1.Op23Z = (DSP1.Op23F * DSP1.matrixC[0][2] >> 15) + (DSP1.Op23L * DSP1.matrixC[1][2] >> 15) + (DSP1.Op23U * DSP1.matrixC[2][2] >> 15);\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP23 F: %d L: %d U: %d / X: %d Y: %d Z: %d\", DSP1.Op23F, DSP1.Op23L, DSP1.Op23U, DSP1.Op23X, DSP1.Op23Y, DSP1.Op23Z);\n#endif\n}\n\nstatic void DSP1_Op14 (void)\n{\n\tint16\tCSec, ESec, CTan, CSin, C, E;\n\n\tDSP1_Inverse(DSP1_Cos(DSP1.Op14Xr), 0, &CSec, &ESec);\n\n\t// Rotation Around Z\n\tDSP1_NormalizeDouble(DSP1.Op14U * DSP1_Cos(DSP1.Op14Yr) - DSP1.Op14F * DSP1_Sin(DSP1.Op14Yr), &C, &E);\n\n\tE = ESec - E;\n\n\tDSP1_Normalize(C * CSec >> 15, &C, &E);\n\n\tDSP1.Op14Zrr = DSP1.Op14Zr + DSP1_Truncate(C, E);\n\n\t// Rotation Around X\n\tDSP1.Op14Xrr = DSP1.Op14Xr + (DSP1.Op14U * DSP1_Sin(DSP1.Op14Yr) >> 15) + (DSP1.Op14F * DSP1_Cos(DSP1.Op14Yr) >> 15);\n\n\t// Rotation Around Y\n\tDSP1_NormalizeDouble(DSP1.Op14U * DSP1_Cos(DSP1.Op14Yr) + DSP1.Op14F * DSP1_Sin(DSP1.Op14Yr), &C, &E);\n\n\tE = ESec - E;\n\n\tDSP1_Normalize(DSP1_Sin(DSP1.Op14Xr), &CSin, &E);\n\n\tCTan = CSec * CSin >> 15;\n\n\tDSP1_Normalize(-(C * CTan >> 15), &C, &E);\n\n\tDSP1.Op14Yrr = DSP1.Op14Yr + DSP1_Truncate(C, E) + DSP1.Op14L;\n}\n\nstatic void DSP1_Target (int16 H, int16 V, int16 *X, int16 *Y)\n{\n\tint16\tC, E, C1, E1;\n\n\tDSP1_Inverse((V * DSP1.SinAzs >> 15) + DSP1.VOffset, 8, &C, &E);\n\tE += DSP1.VPlane_E;\n\n\tC1 = C * DSP1.VPlane_C >> 15;\n\tE1 = E + DSP1.SecAZS_E1;\n\n\tH <<= 8;\n\n\tDSP1_Normalize(C1, &C, &E);\n\n\tC = DSP1_Truncate(C, E) * H >> 15;\n\n\t*X = DSP1.CentreX + (C * DSP1.CosAas >> 15);\n\t*Y = DSP1.CentreY - (C * DSP1.SinAas >> 15);\n\n\tV <<= 8;\n\n\tDSP1_Normalize(C1 * DSP1.SecAZS_C1 >> 15, &C, &E1);\n\n\tC = DSP1_Truncate(C, E1) * V >> 15;\n\n\t*X += C * -DSP1.SinAas >> 15;\n\t*Y += C *  DSP1.CosAas >> 15;\n}\n\nstatic void DSP1_Op0E (void)\n{\n\tDSP1_Target(DSP1.Op0EH, DSP1.Op0EV, &DSP1.Op0EX, &DSP1.Op0EY);\n}\n\nstatic void DSP1_Op0B (void)\n{\n\tDSP1.Op0BS = (DSP1.Op0BX * DSP1.matrixA[0][0] + DSP1.Op0BY * DSP1.matrixA[0][1] + DSP1.Op0BZ * DSP1.matrixA[0][2]) >> 15;\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP0B\");\n#endif\n}\n\nstatic void DSP1_Op1B (void)\n{\n\tDSP1.Op1BS = (DSP1.Op1BX * DSP1.matrixB[0][0] + DSP1.Op1BY * DSP1.matrixB[0][1] + DSP1.Op1BZ * DSP1.matrixB[0][2]) >> 15;\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP1B X: %d Y: %d Z: %d S: %d\", DSP1.Op1BX, DSP1.Op1BY, DSP1.Op1BZ, DSP1.Op1BS);\n\tLog_Message(\"     MX: %d MY: %d MZ: %d Scale: %d\", (int16) (DSP1.matrixB[0][0] * 100), (int16) (DSP1.matrixB[0][1] * 100), (int16) (DSP1.matrixB[0][2] * 100), (int16) (DSP1.Op1BS * 100));\n#endif\n}\n\nstatic void DSP1_Op2B (void)\n{\n\tDSP1.Op2BS = (DSP1.Op2BX * DSP1.matrixC[0][0] + DSP1.Op2BY * DSP1.matrixC[0][1] + DSP1.Op2BZ * DSP1.matrixC[0][2]) >> 15;\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP2B\");\n#endif\n}\n\nstatic void DSP1_Op08 (void)\n{\n\tint32\top08Size = (DSP1.Op08X * DSP1.Op08X + DSP1.Op08Y * DSP1.Op08Y + DSP1.Op08Z * DSP1.Op08Z) << 1;\n\tDSP1.Op08Ll =  op08Size        & 0xffff;\n\tDSP1.Op08Lh = (op08Size >> 16) & 0xffff;\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP08 %d,%d,%d\", DSP1.Op08X, DSP1.Op08Y, DSP1.Op08Z);\n\tLog_Message(\"OP08 ((OP08X^2)+(OP08Y^2)+(OP08Z^2))=%x\", op08Size);\n#endif\n}\n\nstatic void DSP1_Op18 (void)\n{\n\tDSP1.Op18D = (DSP1.Op18X * DSP1.Op18X + DSP1.Op18Y * DSP1.Op18Y + DSP1.Op18Z * DSP1.Op18Z - DSP1.Op18R * DSP1.Op18R) >> 15;\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP18 X: %d Y: %d Z: %d R: %D DIFF %d\", DSP1.Op18X, DSP1.Op18Y, DSP1.Op38Z, DSP1.Op18D);\n#endif\n}\n\nstatic void DSP1_Op38 (void)\n{\n\tDSP1.Op38D = (DSP1.Op38X * DSP1.Op38X + DSP1.Op38Y * DSP1.Op38Y + DSP1.Op38Z * DSP1.Op38Z - DSP1.Op38R * DSP1.Op38R) >> 15;\n\tDSP1.Op38D++;\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP38 X: %d Y: %d Z: %d R: %D DIFF %d\", DSP1.Op38X, DSP1.Op38Y, DSP1.Op38Z, DSP1.Op38D);\n#endif\n}\n\nstatic void DSP1_Op28 (void)\n{\n\tint32\tRadius = DSP1.Op28X * DSP1.Op28X + DSP1.Op28Y * DSP1.Op28Y + DSP1.Op28Z * DSP1.Op28Z;\n\n\tif (Radius == 0)\n\t\tDSP1.Op28R = 0;\n\telse\n\t{\n\t\tint16\tC, E, Pos, Node1, Node2;\n\n\t\tDSP1_NormalizeDouble(Radius, &C, &E);\n\t\tif (E & 1)\n\t\t\tC = C * 0x4000 >> 15;\n\n\t\tPos = C * 0x0040 >> 15;\n\n\t\tNode1 = DSP1ROM[0x00d5 + Pos];\n\t\tNode2 = DSP1ROM[0x00d6 + Pos];\n\n\t\tDSP1.Op28R = ((Node2 - Node1) * (C & 0x1ff) >> 9) + Node1;\n\t\tDSP1.Op28R >>= (E >> 1);\n\t}\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP28 X:%d Y:%d Z:%d\", DSP1.Op28X, DSP1.Op28Y, DSP1.Op28Z);\n\tLog_Message(\"OP28 Vector Length %d\", DSP1.Op28R);\n#endif\n}\n\nstatic void DSP1_Op1C (void)\n{\n\t// Rotate Around Op1CZ1\n\tDSP1.Op1CX1 = (DSP1.Op1CYBR * DSP1_Sin(DSP1.Op1CZ) >> 15) + (DSP1.Op1CXBR * DSP1_Cos(DSP1.Op1CZ) >> 15);\n\tDSP1.Op1CY1 = (DSP1.Op1CYBR * DSP1_Cos(DSP1.Op1CZ) >> 15) - (DSP1.Op1CXBR * DSP1_Sin(DSP1.Op1CZ) >> 15);\n\tDSP1.Op1CXBR = DSP1.Op1CX1;\n\tDSP1.Op1CYBR = DSP1.Op1CY1;\n\n\t// Rotate Around Op1CY1\n\tDSP1.Op1CZ1 = (DSP1.Op1CXBR * DSP1_Sin(DSP1.Op1CY) >> 15) + (DSP1.Op1CZBR * DSP1_Cos(DSP1.Op1CY) >> 15);\n\tDSP1.Op1CX1 = (DSP1.Op1CXBR * DSP1_Cos(DSP1.Op1CY) >> 15) - (DSP1.Op1CZBR * DSP1_Sin(DSP1.Op1CY) >> 15);\n\tDSP1.Op1CXAR = DSP1.Op1CX1;\n\tDSP1.Op1CZBR = DSP1.Op1CZ1;\n\n\t// Rotate Around Op1CX1\n\tDSP1.Op1CY1 = (DSP1.Op1CZBR * DSP1_Sin(DSP1.Op1CX) >> 15) + (DSP1.Op1CYBR * DSP1_Cos(DSP1.Op1CX) >> 15);\n\tDSP1.Op1CZ1 = (DSP1.Op1CZBR * DSP1_Cos(DSP1.Op1CX) >> 15) - (DSP1.Op1CYBR * DSP1_Sin(DSP1.Op1CX) >> 15);\n\tDSP1.Op1CYAR = DSP1.Op1CY1;\n\tDSP1.Op1CZAR = DSP1.Op1CZ1;\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP1C Apply Matrix CX:%d CY:%d CZ\", DSP1.Op1CXAR, DSP1.Op1CYAR, DSP1.Op1CZAR);\n#endif\n}\n\nstatic void DSP1_Op0F (void)\n{\n\tDSP1.Op0FPass = 0x0000;\n\n#ifdef DebugDSP1\n\tLog_Message(\"OP0F RAM Test Pass:%d\", DSP1.Op0FPass);\n#endif\n}\n\nstatic void DSP1_Op2F (void)\n{\n\tDSP1.Op2FSize = 0x100;\n}\n\nvoid DSP1SetByte (uint8 byte, uint16 address)\n{\n\tif (address < DSP0.boundary)\n\t{\n\t\tif ((DSP1.command == 0x0A || DSP1.command == 0x1A) && DSP1.out_count != 0)\n\t\t{\n\t\t\tDSP1.out_count--;\n\t\t\tDSP1.out_index++;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\tif (DSP1.waiting4command)\n\t\t{\n\t\t\tDSP1.command         = byte;\n\t\t\tDSP1.in_index        = 0;\n\t\t\tDSP1.waiting4command = FALSE;\n\t\t\tDSP1.first_parameter = TRUE;\n\t\t\t#ifdef DEBUGGER\n\t\t\t\t//printf(\"OP%02X\\n\",byte);\n\t\t\t#endif\n\n\t\t\tswitch (byte)\n\t\t\t{\n\t\t\t\tcase 0x00: DSP1.in_count = 2; break;\n\t\t\t\tcase 0x30:\n\t\t\t\tcase 0x10: DSP1.in_count = 2; break;\n\t\t\t\tcase 0x20: DSP1.in_count = 2; break;\n\t\t\t\tcase 0x24:\n\t\t\t\tcase 0x04: DSP1.in_count = 2; break;\n\t\t\t\tcase 0x08: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x18: DSP1.in_count = 4; break;\n\t\t\t\tcase 0x28: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x38: DSP1.in_count = 4; break;\n\t\t\t\tcase 0x2c:\n\t\t\t\tcase 0x0c: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x3c:\n\t\t\t\tcase 0x1c: DSP1.in_count = 6; break;\n\t\t\t\tcase 0x32:\n\t\t\t\tcase 0x22:\n\t\t\t\tcase 0x12:\n\t\t\t\tcase 0x02: DSP1.in_count = 7; break;\n\t\t\t\tcase 0x0a: DSP1.in_count = 1; break;\n\t\t\t\tcase 0x3a:\n\t\t\t\tcase 0x2a:\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tDSP1.command = 0x1a;\n\t\t\t\t\tDSP1.in_count = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x16:\n\t\t\t\tcase 0x26:\n\t\t\t\tcase 0x36:\n\t\t\t\tcase 0x06: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x1e:\n\t\t\t\tcase 0x2e:\n\t\t\t\tcase 0x3e:\n\t\t\t\tcase 0x0e: DSP1.in_count = 2; break;\n\t\t\t\tcase 0x05:\n\t\t\t\tcase 0x35:\n\t\t\t\tcase 0x31:\n\t\t\t\tcase 0x01: DSP1.in_count = 4; break;\n\t\t\t\tcase 0x15:\n\t\t\t\tcase 0x11: DSP1.in_count = 4; break;\n\t\t\t\tcase 0x25:\n\t\t\t\tcase 0x21: DSP1.in_count = 4; break;\n\t\t\t\tcase 0x09:\n\t\t\t\tcase 0x39:\n\t\t\t\tcase 0x3d:\n\t\t\t\tcase 0x0d: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x19:\n\t\t\t\tcase 0x1d: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x29:\n\t\t\t\tcase 0x2d: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x33:\n\t\t\t\tcase 0x03: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x13: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x23: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x3b:\n\t\t\t\tcase 0x0b: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x1b: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x2b: DSP1.in_count = 3; break;\n\t\t\t\tcase 0x34:\n\t\t\t\tcase 0x14: DSP1.in_count = 6; break;\n\t\t\t\tcase 0x07:\n\t\t\t\tcase 0x0f: DSP1.in_count = 1; break;\n\t\t\t\tcase 0x27:\n\t\t\t\tcase 0x2F: DSP1.in_count = 1; break;\n\t\t\t\tcase 0x17:\n\t\t\t\tcase 0x37:\n\t\t\t\tcase 0x3F:\n\t\t\t\t\tDSP1.command = 0x1f; // Fall through\n\t\t\t\tcase 0x1f: DSP1.in_count = 1; break;\n\t\t\t\tdefault:\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"OP%02X\\n\", byte);\n\t\t\t\t#endif\n\t\t\t\tcase 0x80:\n\t\t\t\t\tDSP1.in_count        = 0;\n\t\t\t\t\tDSP1.waiting4command = TRUE;\n\t\t\t\t\tDSP1.first_parameter = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tDSP1.in_count <<= 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDSP1.parameters[DSP1.in_index] = byte;\n\t\t\tDSP1.first_parameter = FALSE;\n\t\t\tDSP1.in_index++;\n\t\t}\n\n\t\tif (DSP1.waiting4command || (DSP1.first_parameter && byte == 0x80))\n\t\t{\n\t\t\tDSP1.waiting4command = TRUE;\n\t\t\tDSP1.first_parameter = FALSE;\n\t\t}\n\t\telse\n\t\tif (DSP1.first_parameter && (DSP1.in_count != 0 || (DSP1.in_count == 0 && DSP1.in_index == 0)))\n\t\t\t;\n\t\telse\n\t\t{\n\t\t\tif (DSP1.in_count)\n\t\t\t{\n\t\t\t\tif (--DSP1.in_count == 0)\n\t\t\t\t{\n\t\t\t\t\t// Actually execute the command\n\t\t\t\t\tDSP1.waiting4command = TRUE;\n\t\t\t\t\tDSP1.out_index       = 0;\n\n\t\t\t\t\tswitch (DSP1.command)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 0x1f:\n\t\t\t\t\t\t\tDSP1.out_count = 2048;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x00: // Multiple\n\t\t\t\t\t\t\tDSP1.Op00Multiplicand = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op00Multiplier   = (int16) READ_WORD(&DSP1.parameters[2]);\n\n\t\t\t\t\t\t\tDSP1_Op00();\n\n\t\t\t\t\t\t\tDSP1.out_count = 2;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op00Result);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x20: // Multiple\n\t\t\t\t\t\t\tDSP1.Op20Multiplicand = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op20Multiplier   = (int16) READ_WORD(&DSP1.parameters[2]);\n\n\t\t\t\t\t\t\tDSP1_Op20();\n\n\t\t\t\t\t\t\tDSP1.out_count = 2;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op20Result);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x30:\n\t\t\t\t\t\tcase 0x10: // Inverse\n\t\t\t\t\t\t\tDSP1.Op10Coefficient = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op10Exponent    = (int16) READ_WORD(&DSP1.parameters[2]);\n\n\t\t\t\t\t\t\tDSP1_Op10();\n\n\t\t\t\t\t\t\tDSP1.out_count = 4;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op10CoefficientR);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op10ExponentR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x24:\n\t\t\t\t\t\tcase 0x04: // Sin and Cos of angle\n\t\t\t\t\t\t\tDSP1.Op04Angle  = (int16)  READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op04Radius = (uint16) READ_WORD(&DSP1.parameters[2]);\n\n\t\t\t\t\t\t\tDSP1_Op04();\n\n\t\t\t\t\t\t\tDSP1.out_count = 4;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op04Sin);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op04Cos);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x08: // Radius\n\t\t\t\t\t\t\tDSP1.Op08X = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op08Y = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op08Z = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op08();\n\n\t\t\t\t\t\t\tDSP1.out_count = 4;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op08Ll);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op08Lh);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x18: // Range\n\n\t\t\t\t\t\t\tDSP1.Op18X = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op18Y = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op18Z = (int16) READ_WORD(&DSP1.parameters[4]);\n\t\t\t\t\t\t\tDSP1.Op18R = (int16) READ_WORD(&DSP1.parameters[6]);\n\n\t\t\t\t\t\t\tDSP1_Op18();\n\n\t\t\t\t\t\t\tDSP1.out_count = 2;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op18D);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x38: // Range\n\n\t\t\t\t\t\t\tDSP1.Op38X = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op38Y = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op38Z = (int16) READ_WORD(&DSP1.parameters[4]);\n\t\t\t\t\t\t\tDSP1.Op38R = (int16) READ_WORD(&DSP1.parameters[6]);\n\n\t\t\t\t\t\t\tDSP1_Op38();\n\n\t\t\t\t\t\t\tDSP1.out_count = 2;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op38D);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x28: // Distance (vector length)\n\t\t\t\t\t\t\tDSP1.Op28X = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op28Y = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op28Z = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op28();\n\n\t\t\t\t\t\t\tDSP1.out_count = 2;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op28R);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x2c:\n\t\t\t\t\t\tcase 0x0c: // Rotate (2D rotate)\n\t\t\t\t\t\t\tDSP1.Op0CA  = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op0CX1 = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op0CY1 = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op0C();\n\n\t\t\t\t\t\t\tDSP1.out_count = 4;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op0CX2);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op0CY2);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x3c:\n\t\t\t\t\t\tcase 0x1c: // Polar (3D rotate)\n\t\t\t\t\t\t\tDSP1.Op1CZ   = READ_WORD(&DSP1.parameters[ 0]);\n\t\t\t\t\t\t\t//MK: reversed X and Y on neviksti and John's advice.\n\t\t\t\t\t\t\tDSP1.Op1CY   = READ_WORD(&DSP1.parameters[ 2]);\n\t\t\t\t\t\t\tDSP1.Op1CX   = READ_WORD(&DSP1.parameters[ 4]);\n\t\t\t\t\t\t\tDSP1.Op1CXBR = READ_WORD(&DSP1.parameters[ 6]);\n\t\t\t\t\t\t\tDSP1.Op1CYBR = READ_WORD(&DSP1.parameters[ 8]);\n\t\t\t\t\t\t\tDSP1.Op1CZBR = READ_WORD(&DSP1.parameters[10]);\n\n\t\t\t\t\t\t\tDSP1_Op1C();\n\n\t\t\t\t\t\t\tDSP1.out_count = 6;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op1CXAR);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op1CYAR);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[4], DSP1.Op1CZAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x32:\n\t\t\t\t\t\tcase 0x22:\n\t\t\t\t\t\tcase 0x12:\n\t\t\t\t\t\tcase 0x02: // Parameter (Projection)\n\t\t\t\t\t\t\tDSP1.Op02FX  = (int16)  READ_WORD(&DSP1.parameters[ 0]);\n\t\t\t\t\t\t\tDSP1.Op02FY  = (int16)  READ_WORD(&DSP1.parameters[ 2]);\n\t\t\t\t\t\t\tDSP1.Op02FZ  = (int16)  READ_WORD(&DSP1.parameters[ 4]);\n\t\t\t\t\t\t\tDSP1.Op02LFE = (int16)  READ_WORD(&DSP1.parameters[ 6]);\n\t\t\t\t\t\t\tDSP1.Op02LES = (int16)  READ_WORD(&DSP1.parameters[ 8]);\n\t\t\t\t\t\t\tDSP1.Op02AAS = (uint16) READ_WORD(&DSP1.parameters[10]);\n\t\t\t\t\t\t\tDSP1.Op02AZS = (uint16) READ_WORD(&DSP1.parameters[12]);\n\n\t\t\t\t\t\t\tDSP1_Op02();\n\n\t\t\t\t\t\t\tDSP1.out_count = 8;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op02VOF);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op02VVA);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[4], DSP1.Op02CX);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[6], DSP1.Op02CY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x3a:\n\t\t\t\t\t\tcase 0x2a:\n\t\t\t\t\t\tcase 0x1a: // Raster mode 7 matrix data\n\t\t\t\t\t\tcase 0x0a:\n\t\t\t\t\t\t\tDSP1.Op0AVS = (int16) READ_WORD(&DSP1.parameters[0]);\n\n\t\t\t\t\t\t\tDSP1_Op0A();\n\n\t\t\t\t\t\t\tDSP1.out_count = 8;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op0AA);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op0AB);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[4], DSP1.Op0AC);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[6], DSP1.Op0AD);\n\t\t\t\t\t\t\tDSP1.in_index  = 0;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x16:\n\t\t\t\t\t\tcase 0x26:\n\t\t\t\t\t\tcase 0x36:\n\t\t\t\t\t\tcase 0x06: // Project object\n\t\t\t\t\t\t\tDSP1.Op06X = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op06Y = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op06Z = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op06();\n\n\t\t\t\t\t\t\tDSP1.out_count = 6;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op06H);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op06V);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[4], DSP1.Op06M);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x1e:\n\t\t\t\t\t\tcase 0x2e:\n\t\t\t\t\t\tcase 0x3e:\n\t\t\t\t\t\tcase 0x0e: // Target\n\t\t\t\t\t\t\tDSP1.Op0EH = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op0EV = (int16) READ_WORD(&DSP1.parameters[2]);\n\n\t\t\t\t\t\t\tDSP1_Op0E();\n\n\t\t\t\t\t\t\tDSP1.out_count = 4;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op0EX);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op0EY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// Extra commands used by Pilot Wings\n\t\t\t\t\t\tcase 0x05:\n\t\t\t\t\t\tcase 0x35:\n\t\t\t\t\t\tcase 0x31:\n\t\t\t\t\t\tcase 0x01: // Set attitude matrix A\n\t\t\t\t\t\t\tDSP1.Op01m  = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op01Zr = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op01Yr = (int16) READ_WORD(&DSP1.parameters[4]);\n\t\t\t\t\t\t\tDSP1.Op01Xr = (int16) READ_WORD(&DSP1.parameters[6]);\n\n\t\t\t\t\t\t\tDSP1_Op01();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x15:\n\t\t\t\t\t\tcase 0x11: // Set attitude matrix B\n\t\t\t\t\t\t\tDSP1.Op11m  = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op11Zr = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op11Yr = (int16) READ_WORD(&DSP1.parameters[4]);\n\t\t\t\t\t\t\tDSP1.Op11Xr = (int16) READ_WORD(&DSP1.parameters[6]);\n\n\t\t\t\t\t\t\tDSP1_Op11();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x25:\n\t\t\t\t\t\tcase 0x21: // Set attitude matrix C\n\t\t\t\t\t\t\tDSP1.Op21m  = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op21Zr = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op21Yr = (int16) READ_WORD(&DSP1.parameters[4]);\n\t\t\t\t\t\t\tDSP1.Op21Xr = (int16) READ_WORD(&DSP1.parameters[6]);\n\n\t\t\t\t\t\t\tDSP1_Op21();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x09:\n\t\t\t\t\t\tcase 0x39:\n\t\t\t\t\t\tcase 0x3d:\n\t\t\t\t\t\tcase 0x0d: // Objective matrix A\n\t\t\t\t\t\t\tDSP1.Op0DX = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op0DY = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op0DZ = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op0D();\n\n\t\t\t\t\t\t\tDSP1.out_count = 6;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op0DF);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op0DL);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[4], DSP1.Op0DU);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x19:\n\t\t\t\t\t\tcase 0x1d: // Objective matrix B\n\t\t\t\t\t\t\tDSP1.Op1DX = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op1DY = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op1DZ = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op1D();\n\n\t\t\t\t\t\t\tDSP1.out_count = 6;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op1DF);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op1DL);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[4], DSP1.Op1DU);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x29:\n\t\t\t\t\t\tcase 0x2d: // Objective matrix C\n\t\t\t\t\t\t\tDSP1.Op2DX = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op2DY = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op2DZ = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op2D();\n\n\t\t\t\t\t\t\tDSP1.out_count = 6;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op2DF);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op2DL);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[4], DSP1.Op2DU);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x33:\n\t\t\t\t\t\tcase 0x03: // Subjective matrix A\n\t\t\t\t\t\t\tDSP1.Op03F = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op03L = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op03U = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op03();\n\n\t\t\t\t\t\t\tDSP1.out_count = 6;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op03X);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op03Y);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[4], DSP1.Op03Z);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x13: // Subjective matrix B\n\t\t\t\t\t\t\tDSP1.Op13F = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op13L = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op13U = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op13();\n\n\t\t\t\t\t\t\tDSP1.out_count = 6;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op13X);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op13Y);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[4], DSP1.Op13Z);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x23: // Subjective matrix C\n\t\t\t\t\t\t\tDSP1.Op23F = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op23L = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op23U = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op23();\n\n\t\t\t\t\t\t\tDSP1.out_count = 6;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op23X);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op23Y);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[4], DSP1.Op23Z);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x3b:\n\t\t\t\t\t\tcase 0x0b:\n\t\t\t\t\t\t\tDSP1.Op0BX = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op0BY = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op0BZ = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op0B();\n\n\t\t\t\t\t\t\tDSP1.out_count = 2;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op0BS);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x1b:\n\t\t\t\t\t\t\tDSP1.Op1BX = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op1BY = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op1BZ = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op1B();\n\n\t\t\t\t\t\t\tDSP1.out_count = 2;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op1BS);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x2b:\n\t\t\t\t\t\t\tDSP1.Op2BX = (int16) READ_WORD(&DSP1.parameters[0]);\n\t\t\t\t\t\t\tDSP1.Op2BY = (int16) READ_WORD(&DSP1.parameters[2]);\n\t\t\t\t\t\t\tDSP1.Op2BZ = (int16) READ_WORD(&DSP1.parameters[4]);\n\n\t\t\t\t\t\t\tDSP1_Op2B();\n\n\t\t\t\t\t\t\tDSP1.out_count = 2;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op2BS);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x34:\n\t\t\t\t\t\tcase 0x14:\n\t\t\t\t\t\t\tDSP1.Op14Zr = (int16) READ_WORD(&DSP1.parameters[ 0]);\n\t\t\t\t\t\t\tDSP1.Op14Xr = (int16) READ_WORD(&DSP1.parameters[ 2]);\n\t\t\t\t\t\t\tDSP1.Op14Yr = (int16) READ_WORD(&DSP1.parameters[ 4]);\n\t\t\t\t\t\t\tDSP1.Op14U  = (int16) READ_WORD(&DSP1.parameters[ 6]);\n\t\t\t\t\t\t\tDSP1.Op14F  = (int16) READ_WORD(&DSP1.parameters[ 8]);\n\t\t\t\t\t\t\tDSP1.Op14L  = (int16) READ_WORD(&DSP1.parameters[10]);\n\n\t\t\t\t\t\t\tDSP1_Op14();\n\n\t\t\t\t\t\t\tDSP1.out_count = 6;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op14Zrr);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[2], DSP1.Op14Xrr);\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[4], DSP1.Op14Yrr);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 0x27:\n\t\t\t\t\t\tcase 0x2F:\n\t\t\t\t\t\t\tDSP1.Op2FUnknown = (int16) READ_WORD(&DSP1.parameters[0]);\n\n\t\t\t\t\t\t\tDSP1_Op2F();\n\n\t\t\t\t\t\t\tDSP1.out_count = 2;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op2FSize);\n\t\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\t\tcase 0x07:\n\t\t\t\t\t\tcase 0x0F:\n\t\t\t\t\t\t\tDSP1.Op0FRamsize = (int16) READ_WORD(&DSP1.parameters[0]);\n\n\t\t\t\t\t\t\tDSP1_Op0F();\n\n\t\t\t\t\t\t\tDSP1.out_count = 2;\n\t\t\t\t\t\t\tWRITE_WORD(&DSP1.output[0], DSP1.Op0FPass);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nuint8 DSP1GetByte (uint16 address)\n{\n\tuint8\tt;\n\n\tif (address < DSP0.boundary)\n\t{\n\t\tif (DSP1.out_count)\n\t\t{\n\t\t\tt = (uint8) DSP1.output[DSP1.out_index];\n\n\t\t\tDSP1.out_index++;\n\n\t\t\tif (--DSP1.out_count == 0)\n\t\t\t{\n\t\t\t\tif (DSP1.command == 0x1a || DSP1.command == 0x0a)\n\t\t\t\t{\n\t\t\t\t\tDSP1_Op0A();\n\t\t\t\t\tDSP1.out_count = 8;\n\t\t\t\t\tDSP1.out_index = 0;\n\t\t\t\t\tDSP1.output[0] =  DSP1.Op0AA       & 0xFF;\n\t\t\t\t\tDSP1.output[1] = (DSP1.Op0AA >> 8) & 0xFF;\n\t\t\t\t\tDSP1.output[2] =  DSP1.Op0AB       & 0xFF;\n\t\t\t\t\tDSP1.output[3] = (DSP1.Op0AB >> 8) & 0xFF;\n\t\t\t\t\tDSP1.output[4] =  DSP1.Op0AC       & 0xFF;\n\t\t\t\t\tDSP1.output[5] = (DSP1.Op0AC >> 8) & 0xFF;\n\t\t\t\t\tDSP1.output[6] =  DSP1.Op0AD       & 0xFF;\n\t\t\t\t\tDSP1.output[7] = (DSP1.Op0AD >> 8) & 0xFF;\n\t\t\t\t}\n\n\t\t\t\tif (DSP1.command == 0x1f)\n\t\t\t\t{\n\t\t\t\t\tif ((DSP1.out_index % 2) != 0)\n\t\t\t\t\t\tt = (uint8) DSP1ROM[DSP1.out_index >> 1];\n\t\t\t\t\telse\n\t\t\t\t\t\tt = DSP1ROM[DSP1.out_index >> 1] >> 8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDSP1.waiting4command = TRUE;\n\t\t}\n\t\telse\n\t\t\tt = 0x80;\n\t}\n\telse\n\t\tt = 0x80;\n\n\treturn (t);\n}\n"
        },
        {
          "name": "dsp2.cpp",
          "type": "blob",
          "size": 8.4296875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n\nstatic void DSP2_Op01 (void);\nstatic void DSP2_Op03 (void);\nstatic void DSP2_Op05 (void);\nstatic void DSP2_Op06 (void);\nstatic void DSP2_Op09 (void);\nstatic void DSP2_Op0D (void);\n\n\n// convert bitmap to bitplane tile\nstatic void DSP2_Op01 (void)\n{\n\t// Op01 size is always 32 bytes input and output\n\t// The hardware does strange things if you vary the size\n\n\tuint8\tc0, c1, c2, c3;\n\tuint8\t*p1  = DSP2.parameters;\n\tuint8\t*p2a = DSP2.output;\n\tuint8\t*p2b = DSP2.output + 16; // halfway\n\n\t// Process 8 blocks of 4 bytes each\n\n\tfor (int j = 0; j < 8; j++)\n\t{\n\t\tc0 = *p1++;\n\t\tc1 = *p1++;\n\t\tc2 = *p1++;\n\t\tc3 = *p1++;\n\n\t\t*p2a++ = (c0 & 0x10) << 3 |\n\t\t\t\t (c0 & 0x01) << 6 |\n\t\t\t\t (c1 & 0x10) << 1 |\n\t\t\t\t (c1 & 0x01) << 4 |\n\t\t\t\t (c2 & 0x10) >> 1 |\n\t\t\t\t (c2 & 0x01) << 2 |\n\t\t\t\t (c3 & 0x10) >> 3 |\n\t\t\t\t (c3 & 0x01);\n\n\t\t*p2a++ = (c0 & 0x20) << 2 |\n\t\t\t\t (c0 & 0x02) << 5 |\n\t\t\t\t (c1 & 0x20)      |\n\t\t\t\t (c1 & 0x02) << 3 |\n\t\t\t\t (c2 & 0x20) >> 2 |\n\t\t\t\t (c2 & 0x02) << 1 |\n\t\t\t\t (c3 & 0x20) >> 4 |\n\t\t\t\t (c3 & 0x02) >> 1;\n\n\t\t*p2b++ = (c0 & 0x40) << 1 |\n\t\t\t\t (c0 & 0x04) << 4 |\n\t\t\t\t (c1 & 0x40) >> 1 |\n\t\t\t\t (c1 & 0x04) << 2 |\n\t\t\t\t (c2 & 0x40) >> 3 |\n\t\t\t\t (c2 & 0x04)      |\n\t\t\t\t (c3 & 0x40) >> 5 |\n\t\t\t\t (c3 & 0x04) >> 2;\n\n\t\t*p2b++ = (c0 & 0x80)      |\n\t\t\t\t (c0 & 0x08) << 3 |\n\t\t\t\t (c1 & 0x80) >> 2 |\n\t\t\t\t (c1 & 0x08) << 1 |\n\t\t\t\t (c2 & 0x80) >> 4 |\n\t\t\t\t (c2 & 0x08) >> 1 |\n\t\t\t\t (c3 & 0x80) >> 6 |\n\t\t\t\t (c3 & 0x08) >> 3;\n\t}\n}\n\n// set transparent color\nstatic void DSP2_Op03 (void)\n{\n\tDSP2.Op05Transparent = DSP2.parameters[0];\n}\n\n// replace bitmap using transparent color\nstatic void DSP2_Op05 (void)\n{\n\t// Overlay bitmap with transparency.\n\t// Input:\n\t//\n\t//   Bitmap 1:  i[0] <=> i[size-1]\n\t//   Bitmap 2:  i[size] <=> i[2*size-1]\n\t//\n\t// Output:\n\t//\n\t//   Bitmap 3:  o[0] <=> o[size-1]\n\t//\n\t// Processing:\n\t//\n\t//   Process all 4-bit pixels (nibbles) in the bitmap\n\t//\n\t//   if ( BM2_pixel == transparent_color )\n\t//      pixelout = BM1_pixel\n\t//   else\n\t//      pixelout = BM2_pixel\n\n\t// The max size bitmap is limited to 255 because the size parameter is a byte\n\t// I think size=0 is an error.  The behavior of the chip on size=0 is to\n\t// return the last value written to DR if you read DR on Op05 with\n\t// size = 0.  I don't think it's worth implementing this quirk unless it's\n\t// proven necessary.\n\n\tuint8\tcolor;\n\tuint8\tc1, c2;\n\tuint8\t*p1 = DSP2.parameters;\n\tuint8\t*p2 = DSP2.parameters + DSP2.Op05Len;\n\tuint8\t*p3 = DSP2.output;\n\n\tcolor = DSP2.Op05Transparent & 0x0f;\n\n\tfor (int32 n = 0; n < DSP2.Op05Len; n++)\n\t{\n\t\tc1 = *p1++;\n\t\tc2 = *p2++;\n\t\t*p3++ = (((c2 >> 4) == color) ? c1 & 0xf0: c2 & 0xf0) | (((c2 & 0x0f) == color) ? c1 & 0x0f: c2 & 0x0f);\n\t}\n}\n\n// reverse bitmap\nstatic void DSP2_Op06 (void)\n{\n\t// Input:\n\t//    size\n\t//    bitmap\n\n\tfor (int32 i = 0, j = DSP2.Op06Len - 1; i < DSP2.Op06Len; i++, j--)\n\t\tDSP2.output[j] = (DSP2.parameters[i] << 4) | (DSP2.parameters[i] >> 4);\n}\n\n// multiply\nstatic void DSP2_Op09 (void)\n{\n\tDSP2.Op09Word1 = DSP2.parameters[0] | (DSP2.parameters[1] << 8);\n\tDSP2.Op09Word2 = DSP2.parameters[2] | (DSP2.parameters[3] << 8);\n\n\tuint32\ttemp = DSP2.Op09Word1 * DSP2.Op09Word2;\n\tDSP2.output[0] =  temp        & 0xFF;\n\tDSP2.output[1] = (temp >>  8) & 0xFF;\n\tDSP2.output[2] = (temp >> 16) & 0xFF;\n\tDSP2.output[3] = (temp >> 24) & 0xFF;\n}\n\n// scale bitmap\nstatic void DSP2_Op0D (void)\n{\n\t// Bit accurate hardware algorithm - uses fixed point math\n\t// This should match the DSP2 Op0D output exactly\n\t// I wouldn't recommend using this unless you're doing hardware debug.\n\t// In some situations it has small visual artifacts that\n\t// are not readily apparent on a TV screen but show up clearly\n\t// on a monitor.  Use Overload's scaling instead.\n\t// This is for hardware verification testing.\n\t//\n\t// One note:  the HW can do odd byte scaling but since we divide\n\t// by two to get the count of bytes this won't work well for\n\t// odd byte scaling (in any of the current algorithm implementations).\n\t// So far I haven't seen Dungeon Master use it.\n\t// If it does we can adjust the parameters and code to work with it\n\n\tuint32\tmultiplier; // Any size int >= 32-bits\n\tuint32\tpixloc;\t    // match size of multiplier\n\tuint8\tpixelarray[512];\n\n\tif (DSP2.Op0DInLen <= DSP2.Op0DOutLen)\n\t\tmultiplier = 0x10000; // In our self defined fixed point 0x10000 == 1\n\telse\n\t\tmultiplier = (DSP2.Op0DInLen << 17) / ((DSP2.Op0DOutLen << 1) + 1);\n\n\tpixloc = 0;\n\n\tfor (int32 i = 0; i < DSP2.Op0DOutLen * 2; i++)\n\t{\n\t\tint32\tj = pixloc >> 16;\n\n\t\tif (j & 1)\n\t\t\tpixelarray[i] =  DSP2.parameters[j >> 1] & 0x0f;\n\t\telse\n\t\t\tpixelarray[i] = (DSP2.parameters[j >> 1] & 0xf0) >> 4;\n\n\t\tpixloc += multiplier;\n\t}\n\n\tfor (int32 i = 0; i < DSP2.Op0DOutLen; i++)\n\t\tDSP2.output[i] = (pixelarray[i << 1] << 4) | pixelarray[(i << 1) + 1];\n}\n\n/*\nstatic void DSP2_Op0D (void)\n{\n\t// Overload's algorithm - use this unless doing hardware testing\n\n\t// One note:  the HW can do odd byte scaling but since we divide\n\t// by two to get the count of bytes this won't work well for\n\t// odd byte scaling (in any of the current algorithm implementations).\n\t// So far I haven't seen Dungeon Master use it.\n\t// If it does we can adjust the parameters and code to work with it\n\n\tint32\tpixel_offset;\n\tuint8\tpixelarray[512];\n\n\tfor (int32 i = 0; i < DSP2.Op0DOutLen * 2; i++)\n\t{\n\t\tpixel_offset = (i * DSP2.Op0DInLen) / DSP2.Op0DOutLen;\n\n\t\tif ((pixel_offset & 1) == 0)\n\t\t\tpixelarray[i] = DSP2.parameters[pixel_offset >> 1] >> 4;\n\t\telse\n\t\t\tpixelarray[i] = DSP2.parameters[pixel_offset >> 1] & 0x0f;\n\t}\n\n\tfor (int32 i = 0; i < DSP2.Op0DOutLen; i++)\n\t\tDSP2.output[i] = (pixelarray[i << 1] << 4) | pixelarray[(i << 1) + 1];\n}\n*/\n\nvoid DSP2SetByte (uint8 byte, uint16 address)\n{\n\tif ((address & 0xf000) == 0x6000 || (address >= 0x8000 && address < 0xc000))\n\t{\n\t\tif (DSP2.waiting4command)\n\t\t{\n\t\t\tDSP2.command         = byte;\n\t\t\tDSP2.in_index        = 0;\n\t\t\tDSP2.waiting4command = FALSE;\n\n\t\t\tswitch (byte)\n\t\t\t{\n\t\t\t\tcase 0x01: DSP2.in_count = 32; break;\n\t\t\t\tcase 0x03: DSP2.in_count =  1; break;\n\t\t\t\tcase 0x05: DSP2.in_count =  1; break;\n\t\t\t\tcase 0x06: DSP2.in_count =  1; break;\n\t\t\t\tcase 0x09: DSP2.in_count =  4; break;\n\t\t\t\tcase 0x0D: DSP2.in_count =  2; break;\n\t\t\t\tdefault:\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t//printf(\"Op%02X\\n\", byte);\n\t\t\t\t#endif\n\t\t\t\tcase 0x0f: DSP2.in_count =  0; break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDSP2.parameters[DSP2.in_index] = byte;\n\t\t\tDSP2.in_index++;\n\t\t}\n\n\t\tif (DSP2.in_count == DSP2.in_index)\n\t\t{\n\t\t\tDSP2.waiting4command = TRUE;\n\t\t\tDSP2.out_index       = 0;\n\n\t\t\tswitch (DSP2.command)\n\t\t\t{\n\t\t\t\tcase 0x01:\n\t\t\t\t\tDSP2.out_count = 32;\n\t\t\t\t\tDSP2_Op01();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x03:\n\t\t\t\t\tDSP2_Op03();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x05:\n\t\t\t\t\tif (DSP2.Op05HasLen)\n\t\t\t\t\t{\n\t\t\t\t\t\tDSP2.Op05HasLen = FALSE;\n\t\t\t\t\t\tDSP2.out_count  = DSP2.Op05Len;\n\t\t\t\t\t\tDSP2_Op05();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDSP2.Op05Len    = DSP2.parameters[0];\n\t\t\t\t\t\tDSP2.in_index   = 0;\n\t\t\t\t\t\tDSP2.in_count   = 2 * DSP2.Op05Len;\n\t\t\t\t\t\tDSP2.Op05HasLen = TRUE;\n\t\t\t\t\t\tif (byte)\n\t\t\t\t\t\t\tDSP2.waiting4command = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x06:\n\t\t\t\t\tif (DSP2.Op06HasLen)\n\t\t\t\t\t{\n\t\t\t\t\t\tDSP2.Op06HasLen = FALSE;\n\t\t\t\t\t\tDSP2.out_count  = DSP2.Op06Len;\n\t\t\t\t\t\tDSP2_Op06();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDSP2.Op06Len    = DSP2.parameters[0];\n\t\t\t\t\t\tDSP2.in_index   = 0;\n\t\t\t\t\t\tDSP2.in_count   = DSP2.Op06Len;\n\t\t\t\t\t\tDSP2.Op06HasLen = TRUE;\n\t\t\t\t\t\tif (byte)\n\t\t\t\t\t\t\tDSP2.waiting4command = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x09:\n\t\t\t\t\tDSP2.out_count = 4;\n\t\t\t\t\tDSP2_Op09();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0D:\n\t\t\t\t\tif (DSP2.Op0DHasLen)\n\t\t\t\t\t{\n\t\t\t\t\t\tDSP2.Op0DHasLen = FALSE;\n\t\t\t\t\t\tDSP2.out_count  = DSP2.Op0DOutLen;\n\t\t\t\t\t\tDSP2_Op0D();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDSP2.Op0DInLen  = DSP2.parameters[0];\n\t\t\t\t\t\tDSP2.Op0DOutLen = DSP2.parameters[1];\n\t\t\t\t\t\tDSP2.in_index   = 0;\n\t\t\t\t\t\tDSP2.in_count   = (DSP2.Op0DInLen + 1) >> 1;\n\t\t\t\t\t\tDSP2.Op0DHasLen = TRUE;\n\t\t\t\t\t\tif (byte)\n\t\t\t\t\t\t\tDSP2.waiting4command = FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0x0f:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nuint8 DSP2GetByte (uint16 address)\n{\n\tuint8\tt;\n\n\tif ((address & 0xf000) == 0x6000 || (address >= 0x8000 && address < 0xc000))\n\t{\n\t\tif (DSP2.out_count)\n\t\t{\n\t\t\tt = (uint8) DSP2.output[DSP2.out_index];\n\t\t\tDSP2.out_index++;\n\t\t\tif (DSP2.out_count == DSP2.out_index)\n\t\t\t\tDSP2.out_count = 0;\n\t\t}\n\t\telse\n\t\t\tt = 0xff;\n\t}\n\telse\n\t\tt = 0x80;\n\n\treturn (t);\n}\n"
        },
        {
          "name": "dsp3.cpp",
          "type": "blob",
          "size": 25.630859375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n\nstatic void (*SetDSP3) (void);\n\nstatic const uint16\tDSP3_DataROM[1024] =\n{\n\t0x8000, 0x4000, 0x2000, 0x1000, 0x0800, 0x0400, 0x0200, 0x0100,\n\t0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004, 0x0002, 0x0001,\n\t0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,\n\t0x0000, 0x000f, 0x0400, 0x0200, 0x0140, 0x0400, 0x0200, 0x0040,\n\t0x007d, 0x007e, 0x007e, 0x007b, 0x007c, 0x007d, 0x007b, 0x007c,\n\t0x0002, 0x0020, 0x0030, 0x0000, 0x000d, 0x0019, 0x0026, 0x0032,\n\t0x003e, 0x004a, 0x0056, 0x0062, 0x006d, 0x0079, 0x0084, 0x008e,\n\t0x0098, 0x00a2, 0x00ac, 0x00b5, 0x00be, 0x00c6, 0x00ce, 0x00d5,\n\t0x00dc, 0x00e2, 0x00e7, 0x00ec, 0x00f1, 0x00f5, 0x00f8, 0x00fb,\n\t0x00fd, 0x00ff, 0x0100, 0x0100, 0x0100, 0x00ff, 0x00fd, 0x00fb,\n\t0x00f8, 0x00f5, 0x00f1, 0x00ed, 0x00e7, 0x00e2, 0x00dc, 0x00d5,\n\t0x00ce, 0x00c6, 0x00be, 0x00b5, 0x00ac, 0x00a2, 0x0099, 0x008e,\n\t0x0084, 0x0079, 0x006e, 0x0062, 0x0056, 0x004a, 0x003e, 0x0032,\n\t0x0026, 0x0019, 0x000d, 0x0000, 0xfff3, 0xffe7, 0xffdb, 0xffce,\n\t0xffc2, 0xffb6, 0xffaa, 0xff9e, 0xff93, 0xff87, 0xff7d, 0xff72,\n\t0xff68, 0xff5e, 0xff54, 0xff4b, 0xff42, 0xff3a, 0xff32, 0xff2b,\n\t0xff25, 0xff1e, 0xff19, 0xff14, 0xff0f, 0xff0b, 0xff08, 0xff05,\n\t0xff03, 0xff01, 0xff00, 0xff00, 0xff00, 0xff01, 0xff03, 0xff05,\n\t0xff08, 0xff0b, 0xff0f, 0xff13, 0xff18, 0xff1e, 0xff24, 0xff2b,\n\t0xff32, 0xff3a, 0xff42, 0xff4b, 0xff54, 0xff5d, 0xff67, 0xff72,\n\t0xff7c, 0xff87, 0xff92, 0xff9e, 0xffa9, 0xffb5, 0xffc2, 0xffce,\n\t0xffda, 0xffe7, 0xfff3, 0x002b, 0x007f, 0x0020, 0x00ff, 0xff00,\n\t0xffbe, 0x0000, 0x0044, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xffc1, 0x0001, 0x0002, 0x0045,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffc5, 0x0003, 0x0004, 0x0005, 0x0047, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xffca, 0x0006, 0x0007, 0x0008,\n\t0x0009, 0x004a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffd0, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x004e, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xffd7, 0x000f, 0x0010, 0x0011,\n\t0x0012, 0x0013, 0x0014, 0x0053, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffdf, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b,\n\t0x0059, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xffe8, 0x001c, 0x001d, 0x001e,\n\t0x001f, 0x0020, 0x0021, 0x0022, 0x0023, 0x0060, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xfff2, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a,\n\t0x002b, 0x002c, 0x0068, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xfffd, 0x002d, 0x002e, 0x002f,\n\t0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0071,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffc7, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d,\n\t0x003e, 0x003f, 0x0040, 0x0041, 0x007b, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xffd4, 0x0000, 0x0001, 0x0002,\n\t0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a,\n\t0x000b, 0x0044, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffe2, 0x000c, 0x000d, 0x000e, 0x000f, 0x0010, 0x0011, 0x0012,\n\t0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0050, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xfff1, 0x0019, 0x001a, 0x001b,\n\t0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 0x0023,\n\t0x0024, 0x0025, 0x0026, 0x005d, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffcb, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d,\n\t0x002e, 0x002f, 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035,\n\t0x006b, 0x0000, 0x0000, 0x0000, 0xffdc, 0x0000, 0x0001, 0x0002,\n\t0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a,\n\t0x000b, 0x000c, 0x000d, 0x000e, 0x000f, 0x0044, 0x0000, 0x0000,\n\t0xffee, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016,\n\t0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e,\n\t0x001f, 0x0020, 0x0054, 0x0000, 0xffee, 0x0021, 0x0022, 0x0023,\n\t0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b,\n\t0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 0x0031, 0x0032, 0x0065,\n\t0xffbe, 0x0000, 0xfeac, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xffc1, 0x0001, 0x0002, 0xfead,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffc5, 0x0003, 0x0004, 0x0005, 0xfeaf, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xffca, 0x0006, 0x0007, 0x0008,\n\t0x0009, 0xfeb2, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffd0, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0xfeb6, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xffd7, 0x000f, 0x0010, 0x0011,\n\t0x0012, 0x0013, 0x0014, 0xfebb, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffdf, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b,\n\t0xfec1, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xffe8, 0x001c, 0x001d, 0x001e,\n\t0x001f, 0x0020, 0x0021, 0x0022, 0x0023, 0xfec8, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xfff2, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a,\n\t0x002b, 0x002c, 0xfed0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xfffd, 0x002d, 0x002e, 0x002f,\n\t0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0xfed9,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffc7, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d,\n\t0x003e, 0x003f, 0x0040, 0x0041, 0xfee3, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xffd4, 0x0000, 0x0001, 0x0002,\n\t0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a,\n\t0x000b, 0xfeac, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffe2, 0x000c, 0x000d, 0x000e, 0x000f, 0x0010, 0x0011, 0x0012,\n\t0x0013, 0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0xfeb8, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0xfff1, 0x0019, 0x001a, 0x001b,\n\t0x001c, 0x001d, 0x001e, 0x001f, 0x0020, 0x0021, 0x0022, 0x0023,\n\t0x0024, 0x0025, 0x0026, 0xfec5, 0x0000, 0x0000, 0x0000, 0x0000,\n\t0xffcb, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d,\n\t0x002e, 0x002f, 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035,\n\t0xfed3, 0x0000, 0x0000, 0x0000, 0xffdc, 0x0000, 0x0001, 0x0002,\n\t0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a,\n\t0x000b, 0x000c, 0x000d, 0x000e, 0x000f, 0xfeac, 0x0000, 0x0000,\n\t0xffee, 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016,\n\t0x0017, 0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e,\n\t0x001f, 0x0020, 0xfebc, 0x0000, 0xffee, 0x0021, 0x0022, 0x0023,\n\t0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b,\n\t0x002c, 0x002d, 0x002e, 0x002f, 0x0030, 0x0031, 0x0032, 0xfecd,\n\t0x0154, 0x0218, 0x0110, 0x00b0, 0x00cc, 0x00b0, 0x0088, 0x00b0,\n\t0x0044, 0x00b0, 0x0000, 0x00b0, 0x00fe, 0xff07, 0x0002, 0x00ff,\n\t0x00f8, 0x0007, 0x00fe, 0x00ee, 0x07ff, 0x0200, 0x00ef, 0xf800,\n\t0x0700, 0x00ee, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0x0001,\n\t0x0001, 0x0001, 0x0001, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff,\n\t0xffff, 0x0000, 0x0000, 0x0001, 0x0001, 0x0001, 0x0001, 0x0000,\n\t0x0000, 0xffff, 0xffff, 0x0000, 0xffff, 0x0001, 0x0000, 0x0001,\n\t0x0001, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000,\n\t0xffff, 0x0001, 0x0000, 0x0001, 0x0001, 0x0000, 0x0000, 0xffff,\n\t0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0044, 0x0088, 0x00cc,\n\t0x0110, 0x0154, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n\t0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n\t0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n\t0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n\t0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n\t0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff\n};\n\nstatic bool8 DSP3_GetBits (uint8);\n//static void DSP3_MemorySize (void);\nstatic void DSP3_TestMemory (void);\nstatic void DSP3_DumpDataROM (void);\nstatic void DSP3_MemoryDump (void);\nstatic void DSP3_Coordinate (void);\nstatic void DSP3_Command (void);\nstatic void DSP3_Decode_Data (void);\nstatic void DSP3_Decode_Tree (void);\nstatic void DSP3_Decode_Symbols (void);\nstatic void DSP3_Decode (void);\nstatic void DSP3_Decode_A (void);\nstatic void DSP3_Convert (void);\nstatic void DSP3_Convert_A (void);\nstatic void DSP3_OP03 (void);\nstatic void DSP3_OP06 (void);\nstatic void DSP3_OP07 (void);\nstatic void DSP3_OP07_A (void);\nstatic void DSP3_OP07_B (void);\nstatic void DSP3_OP0C (void);\n//static void DSP3_OP0C_A (void);\nstatic void DSP3_OP10 (void);\nstatic void DSP3_OP1C (void);\nstatic void DSP3_OP1C_A (void);\nstatic void DSP3_OP1C_B (void);\nstatic void DSP3_OP1C_C (void);\nstatic void DSP3_OP1E (void);\nstatic void DSP3_OP1E_A (void);\nstatic void DSP3_OP1E_A1 (void);\nstatic void DSP3_OP1E_A2 (void);\nstatic void DSP3_OP1E_A3 (void);\nstatic void DSP3_OP1E_B (void);\nstatic void DSP3_OP1E_B1 (void);\nstatic void DSP3_OP1E_B2 (void);\nstatic void DSP3_OP1E_C (void);\nstatic void DSP3_OP1E_C1 (void);\nstatic void DSP3_OP1E_C2 (void);\nstatic void DSP3_OP1E_D (int16, int16 *, int16 *);\nstatic void DSP3_OP1E_D1 (int16, int16 *, int16 *);\nstatic void DSP3_OP3E (void);\n\n\nvoid DSP3_Reset (void)\n{\n\tDSP3.DR = 0x0080;\n\tDSP3.SR = 0x0084;\n\tSetDSP3 = &DSP3_Command;\n}\n\n/*\nstatic void DSP3_MemorySize (void)\n{\n\tDSP3.DR = 0x0300;\n\tSetDSP3 = &DSP3_Reset;\n}\n*/\n\nstatic void DSP3_TestMemory (void)\n{\n\tDSP3.DR = 0x0000;\n\tSetDSP3 = &DSP3_Reset;\n}\n\nstatic void DSP3_DumpDataROM (void)\n{\n\tDSP3.DR = DSP3_DataROM[DSP3.MemoryIndex++];\n\tif (DSP3.MemoryIndex == 1024)\n\t\tSetDSP3 = &DSP3_Reset;\n}\n\nstatic void DSP3_MemoryDump (void)\n{\n\tDSP3.MemoryIndex = 0;\n\tSetDSP3 = &DSP3_DumpDataROM;\n\tDSP3_DumpDataROM();\n}\n\nstatic void DSP3_OP06 (void)\n{\n\tDSP3.WinLo = (uint8) (DSP3.DR);\n\tDSP3.WinHi = (uint8) (DSP3.DR >> 8);\n\tDSP3_Reset();\n}\n\nstatic void DSP3_OP03 (void)\n{\n\tint16\tLo  = (uint8) (DSP3.DR);\n\tint16\tHi  = (uint8) (DSP3.DR >> 8);\n\tint16\tOfs = (DSP3.WinLo * Hi << 1) + (Lo << 1);\n\n\tDSP3.DR = Ofs >> 1;\n\tSetDSP3 = &DSP3_Reset;\n}\n\nstatic void DSP3_OP07_B (void)\n{\n\tint16\tOfs = (DSP3.WinLo * DSP3.AddHi << 1) + (DSP3.AddLo << 1);\n\n\tDSP3.DR = Ofs >> 1;\n\tSetDSP3 = &DSP3_Reset;\n}\n\nstatic void DSP3_OP07_A (void)\n{\n\tint16\tLo = (uint8) (DSP3.DR);\n\tint16\tHi = (uint8) (DSP3.DR >> 8);\n\n\tif (Lo & 1)\n\t\tHi += (DSP3.AddLo & 1);\n\n\tDSP3.AddLo += Lo;\n\tDSP3.AddHi += Hi;\n\n\tif (DSP3.AddLo < 0)\n\t\tDSP3.AddLo += DSP3.WinLo;\n\telse\n\tif (DSP3.AddLo >= DSP3.WinLo)\n\t\tDSP3.AddLo -= DSP3.WinLo;\n\n\tif (DSP3.AddHi < 0)\n\t\tDSP3.AddHi += DSP3.WinHi;\n\telse\n\tif (DSP3.AddHi >= DSP3.WinHi)\n\t\tDSP3.AddHi -= DSP3.WinHi;\n\n\tDSP3.DR = DSP3.AddLo | (DSP3.AddHi << 8) | ((DSP3.AddHi >> 8) & 0xff);\n\tSetDSP3 = &DSP3_OP07_B;\n}\n\nstatic void DSP3_OP07 (void)\n{\n\tuint32\tdataOfs = ((DSP3.DR << 1) + 0x03b2) & 0x03ff;\n\n\tDSP3.AddHi = DSP3_DataROM[dataOfs];\n\tDSP3.AddLo = DSP3_DataROM[dataOfs + 1];\n\n\tSetDSP3 = &DSP3_OP07_A;\n\tDSP3.SR = 0x0080;\n}\n\nstatic void DSP3_Coordinate (void)\n{\n\tDSP3.Index++;\n\n\tswitch (DSP3.Index)\n\t{\n\t\tcase 3:\n\t\t\tif (DSP3.DR == 0xffff)\n\t\t\t\tDSP3_Reset();\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tDSP3.X = DSP3.DR;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\tDSP3.Y = DSP3.DR;\n\t\t\tDSP3.DR = 1;\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\tDSP3.DR = DSP3.X;\n\t\t\tbreak;\n\n\t\tcase 7:\n\t\t\tDSP3.DR = DSP3.Y;\n\t\t\tDSP3.Index = 0;\n\t\t\tbreak;\n\t}\n}\n\nstatic void DSP3_Convert_A (void)\n{\n\tif (DSP3.BMIndex < 8)\n\t{\n\t\tDSP3.Bitmap[DSP3.BMIndex++] = (uint8) (DSP3.DR);\n\t\tDSP3.Bitmap[DSP3.BMIndex++] = (uint8) (DSP3.DR >> 8);\n\n\t\tif (DSP3.BMIndex == 8)\n\t\t{\n\t\t\tfor (int i = 0; i < 8; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t\t{\n\t\t\t\t\tDSP3.Bitplane[j] <<= 1;\n\t\t\t\t\tDSP3.Bitplane[j] |= (DSP3.Bitmap[i] >> j) & 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDSP3.BPIndex = 0;\n\t\t\tDSP3.Count--;\n\t\t}\n\t}\n\n\tif (DSP3.BMIndex == 8)\n\t{\n\t\tif (DSP3.BPIndex == 8)\n\t\t{\n\t\t\tif (!DSP3.Count)\n\t\t\t\tDSP3_Reset();\n\n\t\t\tDSP3.BMIndex = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDSP3.DR  = DSP3.Bitplane[DSP3.BPIndex++];\n\t\t\tDSP3.DR |= DSP3.Bitplane[DSP3.BPIndex++] << 8;\n\t\t}\n\t}\n}\n\nstatic void DSP3_Convert (void)\n{\n\tDSP3.Count = DSP3.DR;\n\tDSP3.BMIndex = 0;\n\tSetDSP3 = &DSP3_Convert_A;\n}\n\nstatic bool8 DSP3_GetBits (uint8 Count)\n{\n\tif (!DSP3.BitsLeft)\n\t{\n\t\tDSP3.BitsLeft = Count;\n\t\tDSP3.ReqBits = 0;\n\t}\n\n\tdo\n\t{\n\t\tif (!DSP3.BitCount)\n\t\t{\n\t\t\tDSP3.SR = 0xC0;\n\t\t\treturn (FALSE);\n\t\t}\n\n\t\tDSP3.ReqBits <<= 1;\n\t\tif (DSP3.ReqData & 0x8000)\n\t\t\tDSP3.ReqBits++;\n\t\tDSP3.ReqData <<= 1;\n\n\t\tDSP3.BitCount--;\n\t\tDSP3.BitsLeft--;\n\n\t}\n\twhile (DSP3.BitsLeft);\n\n\treturn (TRUE);\n}\n\nstatic void DSP3_Decode_Data (void)\n{\n\tif (!DSP3.BitCount)\n\t{\n\t\tif (DSP3.SR & 0x40)\n\t\t{\n\t\t\tDSP3.ReqData = DSP3.DR;\n\t\t\tDSP3.BitCount += 16;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDSP3.SR = 0xC0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (DSP3.LZCode == 1)\n\t{\n\t\tif (!DSP3_GetBits(1))\n\t\t\treturn;\n\n\t\tif (DSP3.ReqBits)\n\t\t\tDSP3.LZLength = 12;\n\t\telse\n\t\t\tDSP3.LZLength = 8;\n\n\t\tDSP3.LZCode++;\n\t}\n\n\tif (DSP3.LZCode == 2)\n\t{\n\t\tif (!DSP3_GetBits(DSP3.LZLength))\n\t\t\treturn;\n\n\t\tDSP3.LZCode = 0;\n\t\tDSP3.Outwords--;\n\t\tif (!DSP3.Outwords)\n\t\t\tSetDSP3 = &DSP3_Reset;\n\n\t\tDSP3.SR = 0x80;\n\t\tDSP3.DR = DSP3.ReqBits;\n\t\treturn;\n\t}\n\n\tif (DSP3.BaseCode == 0xffff)\n\t{\n\t\tif (!DSP3_GetBits(DSP3.BaseLength))\n\t\t\treturn;\n\n\t\tDSP3.BaseCode = DSP3.ReqBits;\n\t}\n\n\tif (!DSP3_GetBits(DSP3.CodeLengths[DSP3.BaseCode]))\n\t\treturn;\n\n\tDSP3.Symbol = DSP3.Codes[DSP3.CodeOffsets[DSP3.BaseCode] + DSP3.ReqBits];\n\tDSP3.BaseCode = 0xffff;\n\n\tif (DSP3.Symbol & 0xff00)\n\t{\n\t\tDSP3.Symbol += 0x7f02;\n\t\tDSP3.LZCode++;\n\t}\n\telse\n\t{\n\t\tDSP3.Outwords--;\n\t\tif (!DSP3.Outwords)\n\t\t\tSetDSP3 = &DSP3_Reset;\n\t}\n\n\tDSP3.SR = 0x80;\n\tDSP3.DR = DSP3.Symbol;\n}\n\nstatic void DSP3_Decode_Tree (void)\n{\n\tif (!DSP3.BitCount)\n\t{\n\t\tDSP3.ReqData = DSP3.DR;\n\t\tDSP3.BitCount += 16;\n\t}\n\n\tif (!DSP3.BaseCodes)\n\t{\n\t\tDSP3_GetBits(1);\n\n\t\tif (DSP3.ReqBits)\n\t\t{\n\t\t\tDSP3.BaseLength = 3;\n\t\t\tDSP3.BaseCodes = 8;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDSP3.BaseLength = 2;\n\t\t\tDSP3.BaseCodes = 4;\n\t\t}\n\t}\n\n\twhile (DSP3.BaseCodes)\n\t{\n\t\tif (!DSP3_GetBits(3))\n\t\t\treturn;\n\n\t\tDSP3.ReqBits++;\n\n\t\tDSP3.CodeLengths[DSP3.Index] = (uint8) DSP3.ReqBits;\n\t\tDSP3.CodeOffsets[DSP3.Index] = DSP3.Symbol;\n\t\tDSP3.Index++;\n\n\t\tDSP3.Symbol += 1 << DSP3.ReqBits;\n\t\tDSP3.BaseCodes--;\n\t}\n\n\tDSP3.BaseCode = 0xffff;\n\tDSP3.LZCode = 0;\n\n\tSetDSP3 = &DSP3_Decode_Data;\n\tif (DSP3.BitCount)\n\t\tDSP3_Decode_Data();\n}\n\nstatic void DSP3_Decode_Symbols (void)\n{\n\tDSP3.ReqData = DSP3.DR;\n\tDSP3.BitCount += 16;\n\n\tdo\n\t{\n\t\tif (DSP3.BitCommand == 0xffff)\n\t\t{\n\t\t\tif (!DSP3_GetBits(2))\n\t\t\t\treturn;\n\n\t\t\tDSP3.BitCommand = DSP3.ReqBits;\n\t\t}\n\n\t\tswitch (DSP3.BitCommand)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tif (!DSP3_GetBits(9))\n\t\t\t\t\treturn;\n\t\t\t\tDSP3.Symbol = DSP3.ReqBits;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tDSP3.Symbol++;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tif (!DSP3_GetBits(1))\n\t\t\t\t\treturn;\n\t\t\t\tDSP3.Symbol += 2 + DSP3.ReqBits;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tif (!DSP3_GetBits(4))\n\t\t\t\t\treturn;\n\t\t\t\tDSP3.Symbol += 4 + DSP3.ReqBits;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tDSP3.BitCommand = 0xffff;\n\n\t\tDSP3.Codes[DSP3.Index++] = DSP3.Symbol;\n\t\tDSP3.Codewords--;\n\n\t}\n\twhile (DSP3.Codewords);\n\n\tDSP3.Index = 0;\n\tDSP3.Symbol = 0;\n\tDSP3.BaseCodes = 0;\n\n\tSetDSP3 = &DSP3_Decode_Tree;\n\tif (DSP3.BitCount)\n\t\tDSP3_Decode_Tree();\n}\n\nstatic void DSP3_Decode_A (void)\n{\n\tDSP3.Outwords = DSP3.DR;\n\tSetDSP3 = &DSP3_Decode_Symbols;\n\tDSP3.BitCount = 0;\n\tDSP3.BitsLeft = 0;\n\tDSP3.Symbol = 0;\n\tDSP3.Index = 0;\n\tDSP3.BitCommand = 0xffff;\n\tDSP3.SR = 0xC0;\n}\n\nstatic void DSP3_Decode (void)\n{\n\tDSP3.Codewords = DSP3.DR;\n\tSetDSP3 = &DSP3_Decode_A;\n}\n\n// Opcodes 1E/3E bit-perfect to 'dsp3-intro' log\n// src: adapted from SD Gundam X/G-Next\n\nstatic void DSP3_OP3E (void)\n{\n\tDSP3. op3e_x = (uint8)  (DSP3.DR & 0x00ff);\n\tDSP3. op3e_y = (uint8) ((DSP3.DR & 0xff00) >> 8);\n\n\tDSP3_OP03();\n\n\tDSP3.op1e_terrain[DSP3.DR] = 0x00;\n\tDSP3.op1e_cost[DSP3.DR]    = 0xff;\n\tDSP3.op1e_weight[DSP3.DR]  = 0;\n\n\tDSP3.op1e_max_search_radius = 0;\n\tDSP3.op1e_max_path_radius   = 0;\n}\n\nstatic void DSP3_OP1E (void)\n{\n\tDSP3.op1e_min_radius = (uint8)  (DSP3.DR & 0x00ff);\n\tDSP3.op1e_max_radius = (uint8) ((DSP3.DR & 0xff00) >> 8);\n\n\tif (DSP3.op1e_min_radius == 0)\n\t\tDSP3.op1e_min_radius++;\n\n\tif (DSP3.op1e_max_search_radius >= DSP3.op1e_min_radius)\n\t\tDSP3.op1e_min_radius = DSP3.op1e_max_search_radius + 1;\n\n\tif (DSP3.op1e_max_radius > DSP3.op1e_max_search_radius)\n\t\tDSP3.op1e_max_search_radius = DSP3.op1e_max_radius;\n\n\tDSP3.op1e_lcv_radius = DSP3.op1e_min_radius;\n\tDSP3.op1e_lcv_steps = DSP3.op1e_min_radius;\n\n\tDSP3.op1e_lcv_turns = 6;\n\tDSP3.op1e_turn = 0;\n\n\tDSP3.op1e_x = DSP3. op3e_x;\n\tDSP3.op1e_y = DSP3. op3e_y;\n\n\tfor (int lcv = 0; lcv < DSP3.op1e_min_radius; lcv++)\n\t\tDSP3_OP1E_D(DSP3.op1e_turn, &DSP3.op1e_x, &DSP3.op1e_y);\n\n\tDSP3_OP1E_A();\n}\n\nstatic void DSP3_OP1E_A (void)\n{\n\tif (DSP3.op1e_lcv_steps == 0)\n\t{\n\t\tDSP3.op1e_lcv_radius++;\n\n\t\tDSP3.op1e_lcv_steps = DSP3.op1e_lcv_radius;\n\n\t\tDSP3.op1e_x = DSP3. op3e_x;\n\t\tDSP3.op1e_y = DSP3. op3e_y;\n\n\t\tfor (int lcv = 0; lcv < DSP3.op1e_lcv_radius; lcv++)\n\t\t\tDSP3_OP1E_D(DSP3.op1e_turn, &DSP3.op1e_x, &DSP3.op1e_y);\n\t}\n\n\tif (DSP3.op1e_lcv_radius > DSP3.op1e_max_radius)\n\t{\n\t\tDSP3.op1e_turn++;\n\t\tDSP3.op1e_lcv_turns--;\n\n\t\tDSP3.op1e_lcv_radius = DSP3.op1e_min_radius;\n\t\tDSP3.op1e_lcv_steps = DSP3.op1e_min_radius;\n\n\t\tDSP3.op1e_x = DSP3. op3e_x;\n\t\tDSP3.op1e_y = DSP3. op3e_y;\n\n\t\tfor (int lcv = 0; lcv < DSP3.op1e_min_radius; lcv++)\n\t\t\tDSP3_OP1E_D(DSP3.op1e_turn, &DSP3.op1e_x, &DSP3.op1e_y);\n\t}\n\n\tif (DSP3.op1e_lcv_turns == 0)\n\t{\n\t\tDSP3.DR = 0xffff;\n\t\tDSP3.SR = 0x0080;\n\t\tSetDSP3 = &DSP3_OP1E_B;\n\t\treturn;\n\t}\n\n\tDSP3.DR = (uint8) (DSP3.op1e_x) | ((uint8) (DSP3.op1e_y) << 8);\n\tDSP3_OP03();\n\n\tDSP3.op1e_cell = DSP3.DR;\n\n\tDSP3.SR = 0x0080;\n\tSetDSP3 = &DSP3_OP1E_A1;\n}\n\nstatic void DSP3_OP1E_A1 (void)\n{\n\tDSP3.SR = 0x0084;\n\tSetDSP3 = &DSP3_OP1E_A2;\n}\n\nstatic void DSP3_OP1E_A2 (void)\n{\n\tDSP3.op1e_terrain[DSP3.op1e_cell] = (uint8) (DSP3.DR & 0x00ff);\n\n\tDSP3.SR = 0x0084;\n\tSetDSP3 = &DSP3_OP1E_A3;\n}\n\nstatic void DSP3_OP1E_A3 (void)\n{\n\tDSP3.op1e_cost[DSP3.op1e_cell] = (uint8) (DSP3.DR & 0x00ff);\n\n\tif (DSP3.op1e_lcv_radius == 1)\n\t{\n\t\tif (DSP3.op1e_terrain[DSP3.op1e_cell] & 1)\n\t\t\tDSP3.op1e_weight[DSP3.op1e_cell] = 0xff;\n\t\telse\n\t\t\tDSP3.op1e_weight[DSP3.op1e_cell] = DSP3.op1e_cost[DSP3.op1e_cell];\n\t}\n\telse\n\t\tDSP3.op1e_weight[DSP3.op1e_cell] = 0xff;\n\n\tDSP3_OP1E_D((int16) (DSP3.op1e_turn + 2), &DSP3.op1e_x, &DSP3.op1e_y);\n\tDSP3.op1e_lcv_steps--;\n\n\tDSP3.SR = 0x0080;\n\tDSP3_OP1E_A();\n}\n\nstatic void DSP3_OP1E_B (void)\n{\n\tDSP3.op1e_x = DSP3. op3e_x;\n\tDSP3.op1e_y = DSP3. op3e_y;\n\tDSP3.op1e_lcv_radius = 1;\n\n\tDSP3.op1e_search = 0;\n\n\tDSP3_OP1E_B1();\n\n\tSetDSP3 = &DSP3_OP1E_C;\n}\n\nstatic void DSP3_OP1E_B1 (void)\n{\n\twhile (DSP3.op1e_lcv_radius < DSP3.op1e_max_radius)\n\t{\n\t\tDSP3.op1e_y--;\n\n\t\tDSP3.op1e_lcv_turns = 6;\n\t\tDSP3.op1e_turn = 5;\n\n\t\twhile (DSP3.op1e_lcv_turns)\n\t\t{\n\t\t\tDSP3.op1e_lcv_steps = DSP3.op1e_lcv_radius;\n\n\t\t\twhile (DSP3.op1e_lcv_steps)\n\t\t\t{\n\t\t\t\tDSP3_OP1E_D1(DSP3.op1e_turn, &DSP3.op1e_x, &DSP3.op1e_y);\n\n\t\t\t\tif (0 <= DSP3.op1e_y && DSP3.op1e_y < DSP3.WinHi && 0 <= DSP3.op1e_x && DSP3.op1e_x < DSP3.WinLo)\n\t\t\t\t{\n\t\t\t\t\tDSP3.DR = (uint8) (DSP3.op1e_x) | ((uint8) (DSP3.op1e_y) << 8);\n\t\t\t\t\tDSP3_OP03();\n\n\t\t\t\t\tDSP3.op1e_cell = DSP3.DR;\n\t\t\t\t\tif (DSP3.op1e_cost[DSP3.op1e_cell] < 0x80 && DSP3.op1e_terrain[DSP3.op1e_cell] < 0x40)\n\t\t\t\t\t\tDSP3_OP1E_B2(); // end cell perimeter\n\t\t\t\t}\n\n\t\t\t\tDSP3.op1e_lcv_steps--;\n\t\t\t} // end search line\n\n\t\t\tDSP3.op1e_turn--;\n\t\t\tif (DSP3.op1e_turn == 0)\n\t\t\t\tDSP3.op1e_turn = 6;\n\n\t\t\tDSP3.op1e_lcv_turns--;\n\t\t} // end circle search\n\n\t\tDSP3.op1e_lcv_radius++;\n\t} // end radius search\n}\n\nstatic void DSP3_OP1E_B2 (void)\n{\n\tint16\tcell;\n\tint16\tpath;\n\tint16\tx, y;\n\tint16\tlcv_turns;\n\n\tpath = 0xff;\n\tlcv_turns = 6;\n\n\twhile (lcv_turns)\n\t{\n\t\tx = DSP3.op1e_x;\n\t\ty = DSP3.op1e_y;\n\n\t\tDSP3_OP1E_D1(lcv_turns, &x, &y);\n\n\t\tDSP3.DR = (uint8) (x) | ((uint8) (y) << 8);\n\t\tDSP3_OP03();\n\n\t\tcell = DSP3.DR;\n\n\t\tif (0 <= y && y < DSP3.WinHi && 0 <= x && x < DSP3.WinLo)\n\t\t{\n\t\t\tif (DSP3.op1e_terrain[cell] < 0x80 || DSP3.op1e_weight[cell] == 0)\n\t\t\t{\n\t\t\t\tif (DSP3.op1e_weight[cell] < path)\n\t\t\t\t\tpath = DSP3.op1e_weight[cell];\n\t\t\t}\n\t\t} // end step travel\n\n\t\tlcv_turns--;\n\t} // end while turns\n\n\tif (path != 0xff)\n\t\tDSP3.op1e_weight[DSP3.op1e_cell] = path + DSP3.op1e_cost[DSP3.op1e_cell];\n}\n\nstatic void DSP3_OP1E_C (void)\n{\n\tDSP3.op1e_min_radius = (uint8)  (DSP3.DR & 0x00ff);\n\tDSP3.op1e_max_radius = (uint8) ((DSP3.DR & 0xff00) >> 8);\n\n\tif (DSP3.op1e_min_radius == 0)\n\t\tDSP3.op1e_min_radius++;\n\n\tif (DSP3.op1e_max_path_radius >= DSP3.op1e_min_radius)\n\t\tDSP3.op1e_min_radius = DSP3.op1e_max_path_radius + 1;\n\n\tif (DSP3.op1e_max_radius > DSP3.op1e_max_path_radius)\n\t\tDSP3.op1e_max_path_radius = DSP3.op1e_max_radius;\n\n\tDSP3.op1e_lcv_radius = DSP3.op1e_min_radius;\n\tDSP3.op1e_lcv_steps = DSP3.op1e_min_radius;\n\n\tDSP3.op1e_lcv_turns = 6;\n\tDSP3.op1e_turn = 0;\n\n\tDSP3.op1e_x = DSP3. op3e_x;\n\tDSP3.op1e_y = DSP3. op3e_y;\n\n\tfor (int lcv = 0; lcv < DSP3.op1e_min_radius; lcv++)\n\t\tDSP3_OP1E_D(DSP3.op1e_turn, &DSP3.op1e_x, &DSP3.op1e_y);\n\n\tDSP3_OP1E_C1();\n}\n\nstatic void DSP3_OP1E_C1 (void)\n{\n\tif (DSP3.op1e_lcv_steps == 0)\n\t{\n\t\tDSP3.op1e_lcv_radius++;\n\n\t\tDSP3.op1e_lcv_steps = DSP3.op1e_lcv_radius;\n\n\t\tDSP3.op1e_x = DSP3. op3e_x;\n\t\tDSP3.op1e_y = DSP3. op3e_y;\n\n\t\tfor (int lcv = 0; lcv < DSP3.op1e_lcv_radius; lcv++)\n\t\t\tDSP3_OP1E_D(DSP3.op1e_turn, &DSP3.op1e_x, &DSP3.op1e_y);\n\t}\n\n\tif (DSP3.op1e_lcv_radius > DSP3.op1e_max_radius)\n\t{\n\t\tDSP3.op1e_turn++;\n\t\tDSP3.op1e_lcv_turns--;\n\n\t\tDSP3.op1e_lcv_radius = DSP3.op1e_min_radius;\n\t\tDSP3.op1e_lcv_steps = DSP3.op1e_min_radius;\n\n\t\tDSP3.op1e_x = DSP3. op3e_x;\n\t\tDSP3.op1e_y = DSP3. op3e_y;\n\n\t\tfor (int lcv = 0; lcv < DSP3.op1e_min_radius; lcv++)\n\t\t\tDSP3_OP1E_D(DSP3.op1e_turn, &DSP3.op1e_x, &DSP3.op1e_y);\n\t}\n\n\tif (DSP3.op1e_lcv_turns == 0)\n\t{\n\t\tDSP3.DR = 0xffff;\n\t\tDSP3.SR = 0x0080;\n\t\tSetDSP3 = &DSP3_Reset;\n\t\treturn;\n\t}\n\n\tDSP3.DR = (uint8) (DSP3.op1e_x) | ((uint8) (DSP3.op1e_y) << 8);\n\tDSP3_OP03();\n\n\tDSP3.op1e_cell = DSP3.DR;\n\n\tDSP3.SR = 0x0080;\n\tSetDSP3 = &DSP3_OP1E_C2;\n}\n\nstatic void DSP3_OP1E_C2 (void)\n{\n\tDSP3.DR = DSP3.op1e_weight[DSP3.op1e_cell];\n\n\tDSP3_OP1E_D((int16) (DSP3.op1e_turn + 2), &DSP3.op1e_x, &DSP3.op1e_y);\n\tDSP3.op1e_lcv_steps--;\n\n\tDSP3.SR = 0x0084;\n\tSetDSP3 = &DSP3_OP1E_C1;\n}\n\nstatic void DSP3_OP1E_D (int16 move, int16 *lo, int16 *hi)\n{\n\tuint32\tdataOfs = ((move << 1) + 0x03b2) & 0x03ff;\n\tint16\tLo;\n\tint16\tHi;\n\n\tDSP3.AddHi = DSP3_DataROM[dataOfs];\n\tDSP3.AddLo = DSP3_DataROM[dataOfs + 1];\n\n\tLo = (uint8) (*lo);\n\tHi = (uint8) (*hi);\n\n\tif (Lo & 1)\n\t\tHi += (DSP3.AddLo & 1);\n\n\tDSP3.AddLo += Lo;\n\tDSP3.AddHi += Hi;\n\n\tif (DSP3.AddLo < 0)\n\t\tDSP3.AddLo += DSP3.WinLo;\n\telse\n\tif (DSP3.AddLo >= DSP3.WinLo)\n\t\tDSP3.AddLo -= DSP3.WinLo;\n\n\tif (DSP3.AddHi < 0)\n\t\tDSP3.AddHi += DSP3.WinHi;\n\telse\n\tif (DSP3.AddHi >= DSP3.WinHi)\n\t\tDSP3.AddHi -= DSP3.WinHi;\n\n\t*lo = DSP3.AddLo;\n\t*hi = DSP3.AddHi;\n}\n\nstatic void DSP3_OP1E_D1 (int16 move, int16 *lo, int16 *hi)\n{\n\tstatic const uint16\tHiAdd[] =\n\t{\n\t\t0x00, 0xFF, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x01, 0x00, 0xFF, 0x00\n\t};\n\n\tstatic const uint16\tLoAdd[] =\n\t{\n\t\t0x00, 0x00, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x00\n\t};\n\n\tint16\tLo;\n\tint16\tHi;\n\n\tif ((*lo) & 1)\n\t\tDSP3.AddHi = HiAdd[move + 8];\n\telse\n\t\tDSP3.AddHi = HiAdd[move + 0];\n\n\tDSP3.AddLo = LoAdd[move];\n\n\tLo = (uint8) (*lo);\n\tHi = (uint8) (*hi);\n\n\tif (Lo & 1)\n\t\tHi += (DSP3.AddLo & 1);\n\n\tDSP3.AddLo += Lo;\n\tDSP3.AddHi += Hi;\n\n\t*lo = DSP3.AddLo;\n\t*hi = DSP3.AddHi;\n}\n\nstatic void DSP3_OP10 (void)\n{\n\tif (DSP3.DR == 0xffff)\n\t\tDSP3_Reset();\n\telse\n\t\t// absorb 2 bytes\n\t\tDSP3.DR = DSP3.DR; // FIXME?\n}\n\n/*\nstatic void DSP3_OP0C_A (void)\n{\n\t// absorb 2 bytes\n\tDSP3.DR = 0;\n\tSetDSP3 = &DSP3_Reset;\n}\n*/\n\nstatic void DSP3_OP0C (void)\n{\n\t// absorb 2 bytes\n\tDSP3.DR = 0;\n\t//SetDSP3 = &DSP3_OP0C_A;\n\tSetDSP3 = &DSP3_Reset;\n}\n\nstatic void DSP3_OP1C_C (void)\n{\n\t// return 2 bytes\n\tDSP3.DR = 0;\n\tSetDSP3 = &DSP3_Reset;\n}\n\nstatic void DSP3_OP1C_B (void)\n{\n\t// return 2 bytes\n\tDSP3.DR = 0;\n\tSetDSP3 = &DSP3_OP1C_C;\n}\n\nstatic void DSP3_OP1C_A (void)\n{\n\t// absorb 2 bytes\n\tSetDSP3 = &DSP3_OP1C_B;\n}\n\nstatic void DSP3_OP1C (void)\n{\n\t// absorb 2 bytes\n\tSetDSP3 = &DSP3_OP1C_A;\n}\n\nstatic void DSP3_Command (void)\n{\n\tif (DSP3.DR < 0x40)\n\t{\n\t\tswitch (DSP3.DR)\n\t\t{\n\t\t\tcase 0x02: SetDSP3 = &DSP3_Coordinate; break;\n\t\t\tcase 0x03: SetDSP3 = &DSP3_OP03;       break;\n\t\t\tcase 0x06: SetDSP3 = &DSP3_OP06;       break;\n\t\t\tcase 0x07: SetDSP3 = &DSP3_OP07;       return;\n\t\t\tcase 0x0c: SetDSP3 = &DSP3_OP0C;       break;\n\t\t\tcase 0x0f: SetDSP3 = &DSP3_TestMemory; break;\n\t\t\tcase 0x10: SetDSP3 = &DSP3_OP10;       break;\n\t\t\tcase 0x18: SetDSP3 = &DSP3_Convert;    break;\n\t\t\tcase 0x1c: SetDSP3 = &DSP3_OP1C;       break;\n\t\t\tcase 0x1e: SetDSP3 = &DSP3_OP1E;       break;\n\t\t\tcase 0x1f: SetDSP3 = &DSP3_MemoryDump; break;\n\t\t\tcase 0x38: SetDSP3 = &DSP3_Decode;     break;\n\t\t\tcase 0x3e: SetDSP3 = &DSP3_OP3E;       break;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tDSP3.SR = 0x0080;\n\t\tDSP3.Index = 0;\n\t}\n}\n\nvoid DSP3SetByte (uint8 byte, uint16 address)\n{\n\tif (address < DSP0.boundary)\n\t{\n\t\tif (DSP3.SR & 0x04)\n\t\t{\n\t\t\tDSP3.DR = (DSP3.DR & 0xff00) + byte;\n\t\t\t(*SetDSP3)();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDSP3.SR ^= 0x10;\n\n\t\t\tif (DSP3.SR & 0x10)\n\t\t\t\tDSP3.DR = (DSP3.DR & 0xff00) + byte;\n\t\t\telse\n\t\t\t{\n\t\t\t\tDSP3.DR = (DSP3.DR & 0x00ff) + (byte << 8);\n\t\t\t\t(*SetDSP3)();\n\t\t\t}\n\t\t}\n\t}\n}\n\nuint8 DSP3GetByte (uint16 address)\n{\n\tif (address < DSP0.boundary)\n\t{\n\t\tuint8\tbyte;\n\n\t\tif (DSP3.SR & 0x04)\n\t\t{\n\t\t\tbyte = (uint8) DSP3.DR;\n\t\t\t(*SetDSP3)();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDSP3.SR ^= 0x10;\n\n\t\t\tif (DSP3.SR & 0x10)\n\t\t\t\tbyte = (uint8) (DSP3.DR);\n\t\t\telse\n\t\t\t{\n\t\t\t\tbyte = (uint8) (DSP3.DR >> 8);\n\t\t\t\t(*SetDSP3)();\n\t\t\t}\n\t\t}\n\n\t\treturn (byte);\n\t}\n\n\treturn (uint8) DSP3.SR;\n}\n"
        },
        {
          "name": "dsp4.cpp",
          "type": "blob",
          "size": 51.080078125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n/*\n  Due recognition and credit are given on Overload's DSP website.\n  Thank those contributors for their hard work on this chip.\n\n  Fixed-point math reminder:\n  [sign, integer, fraction]\n  1.15.00 * 1.15.00 = 2.30.00 -> 1.30.00 (DSP) -> 1.31.00 (LSB is '0')\n  1.15.00 * 1.00.15 = 2.15.15 -> 1.15.15 (DSP) -> 1.15.16 (LSB is '0')\n*/\n\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n\n#define DSP4_CLEAR_OUT() \\\n\t{ DSP4.out_count = 0; DSP4.out_index = 0; }\n\n#define DSP4_WRITE_BYTE(d) \\\n\t{ WRITE_WORD(DSP4.output + DSP4.out_count, (d)); DSP4.out_count++; }\n\n#define DSP4_WRITE_WORD(d) \\\n\t{ WRITE_WORD(DSP4.output + DSP4.out_count, (d)); DSP4.out_count += 2; }\n\n#ifndef MSB_FIRST\n#define DSP4_WRITE_16_WORD(d) \\\n\t{ memcpy(DSP4.output + DSP4.out_count, (d), 32); DSP4.out_count += 32; }\n#else\n#define DSP4_WRITE_16_WORD(d) \\\n\t{ for (int p = 0; p < 16; p++) DSP4_WRITE_WORD((d)[p]); }\n#endif\n\n// used to wait for dsp i/o\n#define DSP4_WAIT(x) \\\n\tDSP4.in_index = 0; DSP4.Logic = (x); return\n\n// 1.7.8 -> 1.15.16\n#define SEX78(a)\t(((int32) ((int16) (a))) << 8)\n\n// 1.15.0 -> 1.15.16\n#define SEX16(a)\t(((int32) ((int16) (a))) << 16)\n\nstatic int16 DSP4_READ_WORD (void);\nstatic int32 DSP4_READ_DWORD (void);\nstatic int16 DSP4_Inverse (int16);\nstatic void DSP4_Multiply (int16, int16, int32 *);\nstatic void DSP4_OP01 (void);\nstatic void DSP4_OP03 (void);\nstatic void DSP4_OP05 (void);\nstatic void DSP4_OP06 (void);\nstatic void DSP4_OP07 (void);\nstatic void DSP4_OP08 (void);\nstatic void DSP4_OP09 (void);\nstatic void DSP4_OP0A (int16, int16 *, int16 *, int16 *, int16 *);\nstatic void DSP4_OP0B (bool8 *, int16, int16, int16, bool8, bool8);\nstatic void DSP4_OP0D (void);\nstatic void DSP4_OP0E (void);\nstatic void DSP4_OP0F (void);\nstatic void DSP4_OP10 (void);\nstatic void DSP4_OP11 (int16, int16, int16, int16, int16 *);\nstatic void DSP4_SetByte (void);\nstatic void DSP4_GetByte (void);\n\n\nstatic int16 DSP4_READ_WORD (void)\n{\n\tint16\tout;\n\n\tout = READ_WORD(DSP4.parameters + DSP4.in_index);\n\tDSP4.in_index += 2;\n\n\treturn (out);\n}\n\nstatic int32 DSP4_READ_DWORD (void)\n{\n\tint32\tout;\n\n\tout = READ_DWORD(DSP4.parameters + DSP4.in_index);\n\tDSP4.in_index += 4;\n\n\treturn (out);\n}\n\nstatic int16 DSP4_Inverse (int16 value)\n{\n\t// Attention: This lookup table is not verified\n\tstatic const uint16\tdiv_lut[64] =\n\t{\n\t\t0x0000, 0x8000, 0x4000, 0x2aaa, 0x2000, 0x1999, 0x1555, 0x1249,\n\t\t0x1000, 0x0e38, 0x0ccc, 0x0ba2, 0x0aaa, 0x09d8, 0x0924, 0x0888,\n\t\t0x0800, 0x0787, 0x071c, 0x06bc, 0x0666, 0x0618, 0x05d1, 0x0590,\n\t\t0x0555, 0x051e, 0x04ec, 0x04bd, 0x0492, 0x0469, 0x0444, 0x0421,\n\t\t0x0400, 0x03e0, 0x03c3, 0x03a8, 0x038e, 0x0375, 0x035e, 0x0348,\n\t\t0x0333, 0x031f, 0x030c, 0x02fa, 0x02e8, 0x02d8, 0x02c8, 0x02b9,\n\t\t0x02aa, 0x029c, 0x028f, 0x0282, 0x0276, 0x026a, 0x025e, 0x0253,\n\t\t0x0249, 0x023e, 0x0234, 0x022b, 0x0222, 0x0219, 0x0210, 0x0208\n\t};\n\n\t// saturate bounds\n\tif (value < 0)\n\t\tvalue = 0;\n\tif (value > 63)\n\t\tvalue = 63;\n\n\treturn (div_lut[value]);\n}\n\nstatic void DSP4_Multiply (int16 Multiplicand, int16 Multiplier, int32 *Product)\n{\n\t*Product = (Multiplicand * Multiplier << 1) >> 1;\n}\n\nstatic void DSP4_OP01 (void)\n{\n\tDSP4.waiting4command = FALSE;\n\n\t// op flow control\n\tswitch (DSP4.Logic)\n\t{\n\t\tcase 1: goto resume1; break;\n\t\tcase 2: goto resume2; break;\n\t\tcase 3: goto resume3; break;\n\t}\n\n\t////////////////////////////////////////////////////\n\t// process initial inputs\n\n\t// sort inputs\n\tDSP4.world_y           = DSP4_READ_DWORD();\n\tDSP4.poly_bottom[0][0] = DSP4_READ_WORD();\n\tDSP4.poly_top[0][0]    = DSP4_READ_WORD();\n\tDSP4.poly_cx[1][0]     = DSP4_READ_WORD();\n\tDSP4.viewport_bottom   = DSP4_READ_WORD();\n\tDSP4.world_x           = DSP4_READ_DWORD();\n\tDSP4.poly_cx[0][0]     = DSP4_READ_WORD();\n\tDSP4.poly_ptr[0][0]    = DSP4_READ_WORD();\n\tDSP4.world_yofs        = DSP4_READ_WORD();\n\tDSP4.world_dy          = DSP4_READ_DWORD();\n\tDSP4.world_dx          = DSP4_READ_DWORD();\n\tDSP4.distance          = DSP4_READ_WORD();\n\tDSP4_READ_WORD(); // 0x0000\n\tDSP4.world_xenv        = DSP4_READ_DWORD();\n\tDSP4.world_ddy         = DSP4_READ_WORD();\n\tDSP4.world_ddx         = DSP4_READ_WORD();\n\tDSP4.view_yofsenv      = DSP4_READ_WORD();\n\n\t// initial (x, y, offset) at starting raster line\n\tDSP4.view_x1         = (DSP4.world_x + DSP4.world_xenv) >> 16;\n\tDSP4.view_y1         = DSP4.world_y >> 16;\n\tDSP4.view_xofs1      = DSP4.world_x >> 16;\n\tDSP4.view_yofs1      = DSP4.world_yofs;\n\tDSP4.view_turnoff_x  = 0;\n\tDSP4.view_turnoff_dx = 0;\n\n\t// first raster line\n\tDSP4.poly_raster[0][0] = DSP4.poly_bottom[0][0];\n\n\tdo\n\t{\n\t\t////////////////////////////////////////////////////\n\t\t// process one iteration of projection\n\n\t\t// perspective projection of world (x, y, scroll) points\n\t\t// based on the current projection lines\n\t\tDSP4.view_x2    = (((DSP4.world_x + DSP4.world_xenv) >> 16) * DSP4.distance >> 15) + (DSP4.view_turnoff_x * DSP4.distance >> 15);\n\t\tDSP4.view_y2    = (DSP4.world_y >> 16) * DSP4.distance >> 15;\n\t\tDSP4.view_xofs2 = DSP4.view_x2;\n\t\tDSP4.view_yofs2 = (DSP4.world_yofs * DSP4.distance >> 15) + DSP4.poly_bottom[0][0] - DSP4.view_y2;\n\n\t\t// 1. World x-location before transformation\n\t\t// 2. Viewer x-position at the next\n\t\t// 3. World y-location before perspective projection\n\t\t// 4. Viewer y-position below the horizon\n\t\t// 5. Number of raster lines drawn in this iteration\n\t\tDSP4_CLEAR_OUT();\n\t\tDSP4_WRITE_WORD((DSP4.world_x + DSP4.world_xenv) >> 16);\n\t\tDSP4_WRITE_WORD(DSP4.view_x2);\n\t\tDSP4_WRITE_WORD(DSP4.world_y >> 16);\n\t\tDSP4_WRITE_WORD(DSP4.view_y2);\n\n\t\t//////////////////////////////////////////////////////\n\n\t\t// SR = 0x00\n\n\t\t// determine # of raster lines used\n\t\tDSP4.segments = DSP4.poly_raster[0][0] - DSP4.view_y2;\n\n\t\t// prevent overdraw\n\t\tif (DSP4.view_y2 >= DSP4.poly_raster[0][0])\n\t\t\tDSP4.segments = 0;\n\t\telse\n\t\t\tDSP4.poly_raster[0][0] = DSP4.view_y2;\n\n\t\t// don't draw outside the window\n\t\tif (DSP4.view_y2 < DSP4.poly_top[0][0])\n\t\t{\n\t\t\tDSP4.segments = 0;\n\n\t\t\t// flush remaining raster lines\n\t\t\tif (DSP4.view_y1 >= DSP4.poly_top[0][0])\n\t\t\t\tDSP4.segments = DSP4.view_y1 - DSP4.poly_top[0][0];\n\t\t}\n\n\t\t// SR = 0x80\n\n\t\tDSP4_WRITE_WORD(DSP4.segments);\n\n\t\t//////////////////////////////////////////////////////\n\n\t\t// scan next command if no SR check needed\n\t\tif (DSP4.segments)\n\t\t{\n\t\t\tint32\tpx_dx, py_dy;\n\t\t\tint32\tx_scroll, y_scroll;\n\n\t\t\t// SR = 0x00\n\n\t\t\t// linear interpolation (lerp) between projected points\n\t\t\tpx_dx = (DSP4.view_xofs2 - DSP4.view_xofs1) * DSP4_Inverse(DSP4.segments) << 1;\n\t\t\tpy_dy = (DSP4.view_yofs2 - DSP4.view_yofs1) * DSP4_Inverse(DSP4.segments) << 1;\n\n\t\t\t// starting step values\n\t\t\tx_scroll = SEX16(DSP4.poly_cx[0][0] + DSP4.view_xofs1);\n\t\t\ty_scroll = SEX16(-DSP4.viewport_bottom + DSP4.view_yofs1 + DSP4.view_yofsenv + DSP4.poly_cx[1][0] - DSP4.world_yofs);\n\n\t\t\t// SR = 0x80\n\n\t\t\t// rasterize line\n\t\t\tfor (DSP4.lcv = 0; DSP4.lcv < DSP4.segments; DSP4.lcv++)\n\t\t\t{\n\t\t\t\t// 1. HDMA memory pointer (bg1)\n\t\t\t\t// 2. vertical scroll offset ($210E)\n\t\t\t\t// 3. horizontal scroll offset ($210D)\n\t\t\t\tDSP4_WRITE_WORD(DSP4.poly_ptr[0][0]);\n\t\t\t\tDSP4_WRITE_WORD((y_scroll + 0x8000) >> 16);\n\t\t\t\tDSP4_WRITE_WORD((x_scroll + 0x8000) >> 16);\n\n\t\t\t\t// update memory address\n\t\t\t\tDSP4.poly_ptr[0][0] -= 4;\n\n\t\t\t\t// update screen values\n\t\t\t\tx_scroll += px_dx;\n\t\t\t\ty_scroll += py_dy;\n\t\t\t}\n\t\t}\n\n\t\t////////////////////////////////////////////////////\n\t\t// Post-update\n\n\t\t// update new viewer (x, y, scroll) to last raster line drawn\n\t\tDSP4.view_x1    = DSP4.view_x2;\n\t\tDSP4.view_y1    = DSP4.view_y2;\n\t\tDSP4.view_xofs1 = DSP4.view_xofs2;\n\t\tDSP4.view_yofs1 = DSP4.view_yofs2;\n\n\t\t// add deltas for projection lines\n\t\tDSP4.world_dx += SEX78(DSP4.world_ddx);\n\t\tDSP4.world_dy += SEX78(DSP4.world_ddy);\n\n\t\t// update projection lines\n\t\tDSP4.world_x += (DSP4.world_dx + DSP4.world_xenv);\n\t\tDSP4.world_y += DSP4.world_dy;\n\n\t\t// update road turnoff position\n\t\tDSP4.view_turnoff_x += DSP4.view_turnoff_dx;\n\n\t\t////////////////////////////////////////////////////\n\t\t// command check\n\n\t\t// scan next command\n\t\tDSP4.in_count = 2;\n\t\tDSP4_WAIT(1);\n\t\t\n\t\tresume1:\n\n\t\t// check for termination\n\t\tDSP4.distance = DSP4_READ_WORD();\n\t\tif (DSP4.distance == -0x8000)\n\t\t\tbreak;\n\n\t\t// road turnoff\n\t\tif ((uint16) DSP4.distance == 0x8001)\n\t\t{\n\t\t\tDSP4.in_count = 6;\n\t\t\tDSP4_WAIT(2);\n\n\t\t\tresume2:\n\n\t\t\tDSP4.distance        = DSP4_READ_WORD();\n\t\t\tDSP4.view_turnoff_x  = DSP4_READ_WORD();\n\t\t\tDSP4.view_turnoff_dx = DSP4_READ_WORD();\n\n\t\t\t// factor in new changes\n\t\t\tDSP4.view_x1    += (DSP4.view_turnoff_x * DSP4.distance >> 15);\n\t\t\tDSP4.view_xofs1 += (DSP4.view_turnoff_x * DSP4.distance >> 15);\n\n\t\t\t// update stepping values\n\t\t\tDSP4.view_turnoff_x += DSP4.view_turnoff_dx;\n\n\t\t\tDSP4.in_count = 2;\n\t\t\tDSP4_WAIT(1);\n\t\t}\n\n\t\t// already have 2 bytes read\n\t\tDSP4.in_count = 6;\n\t\tDSP4_WAIT(3);\n\n\t\tresume3:\n\n\t\t// inspect inputs\n\t\tDSP4.world_ddy    = DSP4_READ_WORD();\n\t\tDSP4.world_ddx    = DSP4_READ_WORD();\n\t\tDSP4.view_yofsenv = DSP4_READ_WORD();\n\n\t\t// no envelope here\n\t\tDSP4.world_xenv = 0;\n\t}\n\twhile (1);\n\n\t// terminate op\n\tDSP4.waiting4command = TRUE;\n}\n\nstatic void DSP4_OP03 (void)\n{\n\tDSP4.OAM_RowMax = 33;\n\tmemset(DSP4.OAM_Row, 0, 64);\n}\n\nstatic void DSP4_OP05 (void)\n{\n\tDSP4.OAM_index = 0;\n\tDSP4.OAM_bits = 0;\n\tmemset(DSP4.OAM_attr, 0, 32);\n\tDSP4.sprite_count = 0;\n}\n\nstatic void DSP4_OP06 (void)\n{\n\tDSP4_CLEAR_OUT();\n\tDSP4_WRITE_16_WORD(DSP4.OAM_attr);\n}\n\nstatic void DSP4_OP07 (void)\n{\n\tDSP4.waiting4command = FALSE;\n\n\t// op flow control\n\tswitch (DSP4.Logic)\n\t{\n\t\tcase 1: goto resume1; break;\n\t\tcase 2: goto resume2; break;\n\t}\n\n\t////////////////////////////////////////////////////\n\t// sort inputs\n\n\tDSP4.world_y           = DSP4_READ_DWORD();\n\tDSP4.poly_bottom[0][0] = DSP4_READ_WORD();\n\tDSP4.poly_top[0][0]    = DSP4_READ_WORD();\n\tDSP4.poly_cx[1][0]     = DSP4_READ_WORD();\n\tDSP4.viewport_bottom   = DSP4_READ_WORD();\n\tDSP4.world_x           = DSP4_READ_DWORD();\n\tDSP4.poly_cx[0][0]     = DSP4_READ_WORD();\n\tDSP4.poly_ptr[0][0]    = DSP4_READ_WORD();\n\tDSP4.world_yofs        = DSP4_READ_WORD();\n\tDSP4.distance          = DSP4_READ_WORD();\n\tDSP4.view_y2           = DSP4_READ_WORD();\n\tDSP4.view_dy           = DSP4_READ_WORD() * DSP4.distance >> 15;\n\tDSP4.view_x2           = DSP4_READ_WORD();\n\tDSP4.view_dx           = DSP4_READ_WORD() * DSP4.distance >> 15;\n\tDSP4.view_yofsenv      = DSP4_READ_WORD();\n\n\t// initial (x, y, offset) at starting raster line\n\tDSP4.view_x1    = DSP4.world_x >> 16;\n\tDSP4.view_y1    = DSP4.world_y >> 16;\n\tDSP4.view_xofs1 = DSP4.view_x1;\n\tDSP4.view_yofs1 = DSP4.world_yofs;\n\n\t// first raster line\n\tDSP4.poly_raster[0][0] = DSP4.poly_bottom[0][0];\n\n\tdo\n\t{\n\t\t////////////////////////////////////////////////////\n\t\t// process one iteration of projection\n\n\t\t// add shaping\n\t\tDSP4.view_x2 += DSP4.view_dx;\n\t\tDSP4.view_y2 += DSP4.view_dy;\n\n\t\t// vertical scroll calculation\n\t\tDSP4.view_xofs2 = DSP4.view_x2;\n\t\tDSP4.view_yofs2 = (DSP4.world_yofs * DSP4.distance >> 15) + DSP4.poly_bottom[0][0] - DSP4.view_y2;\n\n\t\t// 1. Viewer x-position at the next\n\t\t// 2. Viewer y-position below the horizon\n\t\t// 3. Number of raster lines drawn in this iteration\n\t\tDSP4_CLEAR_OUT();\n\t\tDSP4_WRITE_WORD(DSP4.view_x2);\n\t\tDSP4_WRITE_WORD(DSP4.view_y2);\n\n\t\t//////////////////////////////////////////////////////\n\n\t\t// SR = 0x00\n\n\t\t// determine # of raster lines used\n\t\tDSP4.segments = DSP4.view_y1 - DSP4.view_y2;\n\n\t\t// prevent overdraw\n\t\tif (DSP4.view_y2 >= DSP4.poly_raster[0][0])\n\t\t\tDSP4.segments = 0;\n\t\telse\n\t\t\tDSP4.poly_raster[0][0] = DSP4.view_y2;\n\n\t\t// don't draw outside the window\n\t\tif (DSP4.view_y2 < DSP4.poly_top[0][0])\n\t\t{\n\t\t\tDSP4.segments = 0;\n\n\t\t\t// flush remaining raster lines\n\t\t\tif (DSP4.view_y1 >= DSP4.poly_top[0][0])\n\t\t\t\tDSP4.segments = DSP4.view_y1 - DSP4.poly_top[0][0];\n\t\t}\n\n\t\t// SR = 0x80\n\n\t\tDSP4_WRITE_WORD(DSP4.segments);\n\n\t\t//////////////////////////////////////////////////////\n\n\t\t// scan next command if no SR check needed\n\t\tif (DSP4.segments)\n\t\t{\n\t\t\tint32\tpx_dx, py_dy;\n\t\t\tint32\tx_scroll, y_scroll;\n\n\t\t\t// SR = 0x00\n\n\t\t\t// linear interpolation (lerp) between projected points\n\t\t\tpx_dx = (DSP4.view_xofs2 - DSP4.view_xofs1) * DSP4_Inverse(DSP4.segments) << 1;\n\t\t\tpy_dy = (DSP4.view_yofs2 - DSP4.view_yofs1) * DSP4_Inverse(DSP4.segments) << 1;\n\n\t\t\t// starting step values\n\t\t\tx_scroll = SEX16(DSP4.poly_cx[0][0] + DSP4.view_xofs1);\n\t\t\ty_scroll = SEX16(-DSP4.viewport_bottom + DSP4.view_yofs1 + DSP4.view_yofsenv + DSP4.poly_cx[1][0] - DSP4.world_yofs);\n\n\t\t\t// SR = 0x80\n\n\t\t\t// rasterize line\n\t\t\tfor (DSP4.lcv = 0; DSP4.lcv < DSP4.segments; DSP4.lcv++)\n\t\t\t{\n\t\t\t\t// 1. HDMA memory pointer (bg2)\n\t\t\t\t// 2. vertical scroll offset ($2110)\n\t\t\t\t// 3. horizontal scroll offset ($210F)\n\t\t\t\tDSP4_WRITE_WORD(DSP4.poly_ptr[0][0]);\n\t\t\t\tDSP4_WRITE_WORD((y_scroll + 0x8000) >> 16);\n\t\t\t\tDSP4_WRITE_WORD((x_scroll + 0x8000) >> 16);\n\n\t\t\t\t// update memory address\n\t\t\t\tDSP4.poly_ptr[0][0] -= 4;\n\n\t\t\t\t// update screen values\n\t\t\t\tx_scroll += px_dx;\n\t\t\t\ty_scroll += py_dy;\n\t\t\t}\n\t\t}\n\n\t\t/////////////////////////////////////////////////////\n\t\t// Post-update\n\n\t\t// update new viewer (x, y, scroll) to last raster line drawn\n\t\tDSP4.view_x1    = DSP4.view_x2;\n\t\tDSP4.view_y1    = DSP4.view_y2;\n\t\tDSP4.view_xofs1 = DSP4.view_xofs2;\n\t\tDSP4.view_yofs1 = DSP4.view_yofs2;\n\n\t\t////////////////////////////////////////////////////\n\t\t// command check\n\n\t\t// scan next command\n\t\tDSP4.in_count = 2;\n\t\tDSP4_WAIT(1);\n\n\t\tresume1:\n\n\t\t// check for opcode termination\n\t\tDSP4.distance = DSP4_READ_WORD();\n\t\tif (DSP4.distance == -0x8000)\n\t\t\tbreak;\n\n\t\t// already have 2 bytes in queue\n\t\tDSP4.in_count = 10;\n\t\tDSP4_WAIT(2);\n\n\t\tresume2:\n\n\t\t// inspect inputs\n\t\tDSP4.view_y2      = DSP4_READ_WORD();\n\t\tDSP4.view_dy      = DSP4_READ_WORD() * DSP4.distance >> 15;\n\t\tDSP4.view_x2      = DSP4_READ_WORD();\n\t\tDSP4.view_dx      = DSP4_READ_WORD() * DSP4.distance >> 15;\n\t\tDSP4.view_yofsenv = DSP4_READ_WORD();\n\t}\n\twhile (1);\n\n\tDSP4.waiting4command = TRUE;\n}\n\nstatic void DSP4_OP08 (void)\n{\n\tint16\twin_left, win_right;\n\tint16\tview_x[2], view_y[2];\n\tint16\tenvelope[2][2];\n\n\tDSP4.waiting4command = FALSE;\n\n\t// op flow control\n\tswitch (DSP4.Logic)\n\t{\n\t\tcase 1: goto resume1; break;\n\t\tcase 2: goto resume2; break;\n\t}\n\n\t////////////////////////////////////////////////////\n\t// process initial inputs for two polygons\n\n\t// clip values\n\tDSP4.poly_clipRt[0][0] = DSP4_READ_WORD();\n\tDSP4.poly_clipRt[0][1] = DSP4_READ_WORD();\n\tDSP4.poly_clipRt[1][0] = DSP4_READ_WORD();\n\tDSP4.poly_clipRt[1][1] = DSP4_READ_WORD();\n\n\tDSP4.poly_clipLf[0][0] = DSP4_READ_WORD();\n\tDSP4.poly_clipLf[0][1] = DSP4_READ_WORD();\n\tDSP4.poly_clipLf[1][0] = DSP4_READ_WORD();\n\tDSP4.poly_clipLf[1][1] = DSP4_READ_WORD();\n\n\t// unknown (constant) (ex. 1P/2P = $00A6, $00A6, $00A6, $00A6)\n\tDSP4_READ_WORD();\n\tDSP4_READ_WORD();\n\tDSP4_READ_WORD();\n\tDSP4_READ_WORD();\n\n\t// unknown (constant) (ex. 1P/2P = $00A5, $00A5, $00A7, $00A7)\n\tDSP4_READ_WORD();\n\tDSP4_READ_WORD();\n\tDSP4_READ_WORD();\n\tDSP4_READ_WORD();\n\n\t// polygon centering (left, right)\n\tDSP4.poly_cx[0][0] = DSP4_READ_WORD();\n\tDSP4.poly_cx[0][1] = DSP4_READ_WORD();\n\tDSP4.poly_cx[1][0] = DSP4_READ_WORD();\n\tDSP4.poly_cx[1][1] = DSP4_READ_WORD();\n\n\t// HDMA pointer locations\n\tDSP4.poly_ptr[0][0] = DSP4_READ_WORD();\n\tDSP4.poly_ptr[0][1] = DSP4_READ_WORD();\n\tDSP4.poly_ptr[1][0] = DSP4_READ_WORD();\n\tDSP4.poly_ptr[1][1] = DSP4_READ_WORD();\n\n\t// starting raster line below the horizon\n\tDSP4.poly_bottom[0][0] = DSP4_READ_WORD();\n\tDSP4.poly_bottom[0][1] = DSP4_READ_WORD();\n\tDSP4.poly_bottom[1][0] = DSP4_READ_WORD();\n\tDSP4.poly_bottom[1][1] = DSP4_READ_WORD();\n\n\t// top boundary line to clip\n\tDSP4.poly_top[0][0] = DSP4_READ_WORD();\n\tDSP4.poly_top[0][1] = DSP4_READ_WORD();\n\tDSP4.poly_top[1][0] = DSP4_READ_WORD();\n\tDSP4.poly_top[1][1] = DSP4_READ_WORD();\n\n\t// unknown\n\t// (ex. 1P = $2FC8, $0034, $FF5C, $0035)\n\t//\n\t// (ex. 2P = $3178, $0034, $FFCC, $0035)\n\t// (ex. 2P = $2FC8, $0034, $FFCC, $0035)\n\tDSP4_READ_WORD();\n\tDSP4_READ_WORD();\n\tDSP4_READ_WORD();\n\tDSP4_READ_WORD();\n\n\t// look at guidelines for both polygon shapes\n\tDSP4.distance = DSP4_READ_WORD();\n\tview_x[0] = DSP4_READ_WORD();\n\tview_y[0] = DSP4_READ_WORD();\n\tview_x[1] = DSP4_READ_WORD();\n\tview_y[1] = DSP4_READ_WORD();\n\n\t// envelope shaping guidelines (one frame only)\n\tenvelope[0][0] = DSP4_READ_WORD();\n\tenvelope[0][1] = DSP4_READ_WORD();\n\tenvelope[1][0] = DSP4_READ_WORD();\n\tenvelope[1][1] = DSP4_READ_WORD();\n\n\t// starting base values to project from\n\tDSP4.poly_start[0] = view_x[0];\n\tDSP4.poly_start[1] = view_x[1];\n\n\t// starting raster lines to begin drawing\n\tDSP4.poly_raster[0][0] = view_y[0];\n\tDSP4.poly_raster[0][1] = view_y[0];\n\tDSP4.poly_raster[1][0] = view_y[1];\n\tDSP4.poly_raster[1][1] = view_y[1];\n\n\t// starting distances\n\tDSP4.poly_plane[0] = DSP4.distance;\n\tDSP4.poly_plane[1] = DSP4.distance;\n\n\t// SR = 0x00\n\n\t// re-center coordinates\n\twin_left  = DSP4.poly_cx[0][0] - view_x[0] + envelope[0][0];\n\twin_right = DSP4.poly_cx[0][1] - view_x[0] + envelope[0][1];\n\n\t// saturate offscreen data for polygon #1\n\tif (win_left  < DSP4.poly_clipLf[0][0])\n\t\twin_left  = DSP4.poly_clipLf[0][0];\n\tif (win_left  > DSP4.poly_clipRt[0][0])\n\t\twin_left  = DSP4.poly_clipRt[0][0];\n\tif (win_right < DSP4.poly_clipLf[0][1])\n\t\twin_right = DSP4.poly_clipLf[0][1];\n\tif (win_right > DSP4.poly_clipRt[0][1])\n\t\twin_right = DSP4.poly_clipRt[0][1];\n\n\t// SR = 0x80\n\n\t// initial output for polygon #1\n\tDSP4_CLEAR_OUT();\n\tDSP4_WRITE_BYTE(win_left  & 0xff);\n\tDSP4_WRITE_BYTE(win_right & 0xff);\n\n\tdo\n\t{\n\t\tint16\tpolygon;\n\n\t\t////////////////////////////////////////////////////\n\t\t// command check\n\n\t\t// scan next command\n\t\tDSP4.in_count = 2;\n\t\tDSP4_WAIT(1);\n\n\t\tresume1:\n\n\t\t// terminate op\n\t\tDSP4.distance = DSP4_READ_WORD();\n\t\tif (DSP4.distance == -0x8000)\n\t\t\tbreak;\n\n\t\t// already have 2 bytes in queue\n\t\tDSP4.in_count = 16;\n\t\tDSP4_WAIT(2);\n\n\t\tresume2:\n\n\t\t// look at guidelines for both polygon shapes\n\t\tview_x[0] = DSP4_READ_WORD();\n\t\tview_y[0] = DSP4_READ_WORD();\n\t\tview_x[1] = DSP4_READ_WORD();\n\t\tview_y[1] = DSP4_READ_WORD();\n\n\t\t// envelope shaping guidelines (one frame only)\n\t\tenvelope[0][0] = DSP4_READ_WORD();\n\t\tenvelope[0][1] = DSP4_READ_WORD();\n\t\tenvelope[1][0] = DSP4_READ_WORD();\n\t\tenvelope[1][1] = DSP4_READ_WORD();\n\n\t\t////////////////////////////////////////////////////\n\t\t// projection begins\n\n\t\t// init\n\t\tDSP4_CLEAR_OUT();\n\n\t\t//////////////////////////////////////////////\n\t\t// solid polygon renderer - 2 shapes\n\n\t\tfor (polygon = 0; polygon < 2; polygon++)\n\t\t{\n\t\t\tint32\tleft_inc, right_inc;\n\t\t\tint16\tx1_final, x2_final;\n\t\t\tint16\tenv[2][2];\n\t\t\tint16\tpoly;\n\n\t\t\t// SR = 0x00\n\n\t\t\t// # raster lines to draw\n\t\t\tDSP4.segments = DSP4.poly_raster[polygon][0] - view_y[polygon];\n\n\t\t\t// prevent overdraw\n\t\t\tif (DSP4.segments > 0)\n\t\t\t{\n\t\t\t\t// bump drawing cursor\n\t\t\t\tDSP4.poly_raster[polygon][0] = view_y[polygon];\n\t\t\t\tDSP4.poly_raster[polygon][1] = view_y[polygon];\n\t\t\t}\n\t\t\telse\n\t\t\t\tDSP4.segments = 0;\n\n\t\t\t// don't draw outside the window\n\t\t\tif (view_y[polygon] < DSP4.poly_top[polygon][0])\n\t\t\t{\n\t\t\t\tDSP4.segments = 0;\n\n\t\t\t\t// flush remaining raster lines\n\t\t\t\tif (view_y[polygon] >= DSP4.poly_top[polygon][0])\n\t\t\t\t\tDSP4.segments = view_y[polygon] - DSP4.poly_top[polygon][0];\n\t\t\t}\n\n\t\t\t// SR = 0x80\n\n\t\t\t// tell user how many raster structures to read in\n\t\t\tDSP4_WRITE_WORD(DSP4.segments);\n\n\t\t\t// normal parameters\n\t\t\tpoly = polygon;\n\n\t\t\t/////////////////////////////////////////////////////\n\n\t\t\t// scan next command if no SR check needed\n\t\t\tif (DSP4.segments)\n\t\t\t{\n\t\t\t\tint32\tw_left, w_right;\n\n\t\t\t\t// road turnoff selection\n\t\t\t\tif ((uint16) envelope[polygon][0] == (uint16) 0xc001)\n\t\t\t\t\tpoly = 1;\n\t\t\t\telse\n\t\t\t\tif (envelope[polygon][1] == 0x3fff)\n\t\t\t\t\tpoly = 1;\n\n\t\t\t\t///////////////////////////////////////////////\n\t\t\t\t// left side of polygon\n\n\t\t\t\t// perspective correction on additional shaping parameters\n\t\t\t\tenv[0][0] = envelope[polygon][0] * DSP4.poly_plane[poly] >> 15;\n\t\t\t\tenv[0][1] = envelope[polygon][0] * DSP4.distance >> 15;\n\n\t\t\t\t// project new shapes (left side)\n\t\t\t\tx1_final = view_x[poly] + env[0][0];\n\t\t\t\tx2_final = DSP4.poly_start[poly] + env[0][1];\n\n\t\t\t\t// interpolate between projected points with shaping\n\t\t\t\tleft_inc = (x2_final - x1_final) * DSP4_Inverse(DSP4.segments) << 1;\n\t\t\t\tif (DSP4.segments == 1)\n\t\t\t\t\tleft_inc = -left_inc;\n\n\t\t\t\t///////////////////////////////////////////////\n\t\t\t\t// right side of polygon\n\n\t\t\t\t// perspective correction on additional shaping parameters\n\t\t\t\tenv[1][0] = envelope[polygon][1] * DSP4.poly_plane[poly] >> 15;\n\t\t\t\tenv[1][1] = envelope[polygon][1] * DSP4.distance >> 15;\n\n\t\t\t\t// project new shapes (right side)\n\t\t\t\tx1_final = view_x[poly] + env[1][0];\n\t\t\t\tx2_final = DSP4.poly_start[poly] + env[1][1];\n\n\t\t\t\t// interpolate between projected points with shaping\n\t\t\t\tright_inc = (x2_final - x1_final) * DSP4_Inverse(DSP4.segments) << 1;\n\t\t\t\tif (DSP4.segments == 1)\n\t\t\t\t\tright_inc = -right_inc;\n\n\t\t\t\t///////////////////////////////////////////////\n\t\t\t\t// update each point on the line\n\n\t\t\t\tw_left  = SEX16(DSP4.poly_cx[polygon][0] - DSP4.poly_start[poly] + env[0][0]);\n\t\t\t\tw_right = SEX16(DSP4.poly_cx[polygon][1] - DSP4.poly_start[poly] + env[1][0]);\n\n\t\t\t\t// update distance drawn into world\n\t\t\t\tDSP4.poly_plane[polygon] = DSP4.distance;\n\n\t\t\t\t// rasterize line\n\t\t\t\tfor (DSP4.lcv = 0; DSP4.lcv < DSP4.segments; DSP4.lcv++)\n\t\t\t\t{\n\t\t\t\t\tint16\tx_left, x_right;\n\n\t\t\t\t\t// project new coordinates\n\t\t\t\t\tw_left  += left_inc;\n\t\t\t\t\tw_right += right_inc;\n\n\t\t\t\t\t// grab integer portion, drop fraction (no rounding)\n\t\t\t\t\tx_left  = w_left  >> 16;\n\t\t\t\t\tx_right = w_right >> 16;\n\n\t\t\t\t\t// saturate offscreen data\n\t\t\t\t\tif (x_left  < DSP4.poly_clipLf[polygon][0])\n\t\t\t\t\t\tx_left  = DSP4.poly_clipLf[polygon][0];\n\t\t\t\t\tif (x_left  > DSP4.poly_clipRt[polygon][0])\n\t\t\t\t\t\tx_left  = DSP4.poly_clipRt[polygon][0];\n\t\t\t\t\tif (x_right < DSP4.poly_clipLf[polygon][1])\n\t\t\t\t\t\tx_right = DSP4.poly_clipLf[polygon][1];\n\t\t\t\t\tif (x_right > DSP4.poly_clipRt[polygon][1])\n\t\t\t\t\t\tx_right = DSP4.poly_clipRt[polygon][1];\n\n\t\t\t\t\t// 1. HDMA memory pointer\n\t\t\t\t\t// 2. Left window position ($2126/$2128)\n\t\t\t\t\t// 3. Right window position ($2127/$2129)\n\t\t\t\t\tDSP4_WRITE_WORD(DSP4.poly_ptr[polygon][0]);\n\t\t\t\t\tDSP4_WRITE_BYTE(x_left  & 0xff);\n\t\t\t\t\tDSP4_WRITE_BYTE(x_right & 0xff);\n\n\t\t\t\t\t// update memory pointers\n\t\t\t\t\tDSP4.poly_ptr[polygon][0] -= 4;\n\t\t\t\t\tDSP4.poly_ptr[polygon][1] -= 4;\n\t\t\t\t} // end rasterize line\n\t\t\t}\n\n\t\t\t////////////////////////////////////////////////\n\t\t\t// Post-update\n\n\t\t\t// new projection spot to continue rasterizing from\n\t\t\tDSP4.poly_start[polygon] = view_x[poly];\n\t\t} // end polygon rasterizer\n\t}\n\twhile (1);\n\n\t// unknown output\n\tDSP4_CLEAR_OUT();\n\tDSP4_WRITE_WORD(0);\n\n\tDSP4.waiting4command = TRUE;\n}\n\nstatic void DSP4_OP09 (void)\n{\n\tDSP4.waiting4command = FALSE;\n\n\t// op flow control\n\tswitch (DSP4.Logic)\n\t{\n\t\tcase 1: goto resume1; break;\n\t\tcase 2: goto resume2; break;\n\t\tcase 3: goto resume3; break;\n\t\tcase 4: goto resume4; break;\n\t\tcase 5: goto resume5; break;\n\t\tcase 6: goto resume6; break;\n\t}\n\n\t////////////////////////////////////////////////////\n\t// process initial inputs\n\n\t// grab screen information\n\tDSP4.viewport_cx     = DSP4_READ_WORD();\n\tDSP4.viewport_cy     = DSP4_READ_WORD();\n\tDSP4_READ_WORD(); // 0x0000\n\tDSP4.viewport_left   = DSP4_READ_WORD();\n\tDSP4.viewport_right  = DSP4_READ_WORD();\n\tDSP4.viewport_top    = DSP4_READ_WORD();\n\tDSP4.viewport_bottom = DSP4_READ_WORD();\n\n\t// starting raster line below the horizon\n\tDSP4.poly_bottom[0][0] = DSP4.viewport_bottom - DSP4.viewport_cy;\n\tDSP4.poly_raster[0][0] = 0x100;\n\n\tdo\n\t{\n\t\t////////////////////////////////////////////////////\n\t\t// check for new sprites\n\n\t\tDSP4.in_count = 4;\n\t\tDSP4_WAIT(1);\n\n\t\tresume1:\n\n\t\t////////////////////////////////////////////////\n\t\t// raster overdraw check\n\n\t\tDSP4.raster = DSP4_READ_WORD();\n\n\t\t// continue updating the raster line where overdraw begins\n\t\tif (DSP4.raster < DSP4.poly_raster[0][0])\n\t\t{\n\t\t\tDSP4.sprite_clipy = DSP4.viewport_bottom - (DSP4.poly_bottom[0][0] - DSP4.raster);\n\t\t\tDSP4.poly_raster[0][0] = DSP4.raster;\n\t\t}\n\n\t\t/////////////////////////////////////////////////\n\t\t// identify sprite\n\n\t\t// op termination\n\t\tDSP4.distance = DSP4_READ_WORD();\n\t\tif (DSP4.distance == -0x8000)\n\t\t\tgoto terminate;\n\n\t\t// no sprite\n\t\tif (DSP4.distance == 0x0000)\n\t\t\tcontinue;\n\n\t\t////////////////////////////////////////////////////\n\t\t// process projection information\n\n\t\t// vehicle sprite\n\t\tif ((uint16) DSP4.distance == 0x9000)\n\t\t{\n\t\t\tint16\tcar_left, car_right, car_back;\n\t\t\tint16\timpact_left, impact_back;\n\t\t\tint16\tworld_spx, world_spy;\n\t\t\tint16\tview_spx, view_spy;\n\t\t\tuint16\tenergy;\n\n\t\t\t// we already have 4 bytes we want\n\t\t\tDSP4.in_count = 14;\n\t\t\tDSP4_WAIT(2);\n\n\t\t\tresume2:\n\n\t\t\t// filter inputs\n\t\t\tenergy        = DSP4_READ_WORD();\n\t\t\timpact_back   = DSP4_READ_WORD();\n\t\t\tcar_back      = DSP4_READ_WORD();\n\t\t\timpact_left   = DSP4_READ_WORD();\n\t\t\tcar_left      = DSP4_READ_WORD();\n\t\t\tDSP4.distance = DSP4_READ_WORD();\n\t\t\tcar_right     = DSP4_READ_WORD();\n\n\t\t\t// calculate car's world (x, y) values\n\t\t\tworld_spx = car_right - car_left;\n\t\t\tworld_spy = car_back;\n\n\t\t\t// add in collision vector [needs bit-twiddling]\n\t\t\tworld_spx -= energy * (impact_left - car_left) >> 16;\n\t\t\tworld_spy -= energy * (car_back - impact_back) >> 16;\n\n\t\t\t// perspective correction for world (x, y)\n\t\t\tview_spx = world_spx * DSP4.distance >> 15;\n\t\t\tview_spy = world_spy * DSP4.distance >> 15;\n\n\t\t\t// convert to screen values\n\t\t\tDSP4.sprite_x = DSP4.viewport_cx + view_spx;\n\t\t\tDSP4.sprite_y = DSP4.viewport_bottom - (DSP4.poly_bottom[0][0] - view_spy);\n\n\t\t\t// make the car's (x)-coordinate available\n\t\t\tDSP4_CLEAR_OUT();\n\t\t\tDSP4_WRITE_WORD(world_spx);\n\n\t\t\t// grab a few remaining vehicle values\n\t\t\tDSP4.in_count = 4;\n\t\t\tDSP4_WAIT(3);\n\n\t\t\tresume3:\n\n\t\t\t// add vertical lift factor\n\t\t\tDSP4.sprite_y += DSP4_READ_WORD();\n\t\t}\n\t\t// terrain sprite\n\t\telse\n\t\t{\n\t\t\tint16\tworld_spx, world_spy;\n\t\t\tint16\tview_spx, view_spy;\n\n\t\t\t// we already have 4 bytes we want\n\t\t\tDSP4.in_count = 10;\n\t\t\tDSP4_WAIT(4);\n\n\t\t\tresume4:\n\n\t\t\t// sort loop inputs\n\t\t\tDSP4.poly_cx[0][0]     = DSP4_READ_WORD();\n\t\t\tDSP4.poly_raster[0][1] = DSP4_READ_WORD();\n\t\t\tworld_spx              = DSP4_READ_WORD();\n\t\t\tworld_spy              = DSP4_READ_WORD();\n\n\t\t\t// compute base raster line from the bottom\n\t\t\tDSP4.segments = DSP4.poly_bottom[0][0] - DSP4.raster;\n\n\t\t\t// perspective correction for world (x, y)\n\t\t\tview_spx = world_spx * DSP4.distance >> 15;\n\t\t\tview_spy = world_spy * DSP4.distance >> 15;\n\n\t\t\t// convert to screen values\n\t\t\tDSP4.sprite_x = DSP4.viewport_cx + view_spx - DSP4.poly_cx[0][0];\n\t\t\tDSP4.sprite_y = DSP4.viewport_bottom - DSP4.segments + view_spy;\n\t\t}\n\n\t\t// default sprite size: 16x16\n\t\tDSP4.sprite_size = 1;\n\t\tDSP4.sprite_attr = DSP4_READ_WORD();\n\n\t\t////////////////////////////////////////////////////\n\t\t// convert tile data to SNES OAM format\n\n\t\tdo\n\t\t{\n\t\t\tint16\tsp_x, sp_y, sp_attr, sp_dattr;\n\t\t\tint16\tsp_dx, sp_dy;\n\t\t\tint16\tpixels;\n\t\t\tuint16\theader;\n\t\t\tbool8\tdraw;\n\n\t\t\tDSP4.in_count = 2;\n\t\t\tDSP4_WAIT(5);\n\n\t\t\tresume5:\n\n\t\t\tdraw = TRUE;\n\n\t\t\t// opcode termination\n\t\t\tDSP4.raster = DSP4_READ_WORD();\n\t\t\tif (DSP4.raster == -0x8000)\n\t\t\t\tgoto terminate;\n\n\t\t\t// stop code\n\t\t\tif (DSP4.raster == 0x0000 && !DSP4.sprite_size)\n\t\t\t\tbreak;\n\n\t\t\t// toggle sprite size\n\t\t\tif (DSP4.raster == 0x0000)\n\t\t\t{\n\t\t\t\tDSP4.sprite_size = !DSP4.sprite_size;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// check for valid sprite header\n\t\t\theader = DSP4.raster;\n\t\t\theader >>= 8;\n\t\t\tif (header != 0x20 &&\n\t\t\t\theader != 0x2e && // This is for attractor sprite\n\t\t\t\theader != 0x40 &&\n\t\t\t\theader != 0x60 &&\n\t\t\t\theader != 0xa0 &&\n\t\t\t\theader != 0xc0 &&\n\t\t\t\theader != 0xe0)\n\t\t\t\tbreak;\n\n\t\t\t// read in rest of sprite data\n\t\t\tDSP4.in_count = 4;\n\t\t\tDSP4_WAIT(6);\n\n\t\t\tresume6:\n\n\t\t\tdraw = TRUE;\n\n\t\t\t/////////////////////////////////////\n\t\t\t// process tile data\n\n\t\t\t// sprite deltas\n\t\t\tsp_dattr = DSP4.raster;\n\t\t\tsp_dy = DSP4_READ_WORD();\n\t\t\tsp_dx = DSP4_READ_WORD();\n\n\t\t\t// update coordinates to screen space\n\t\t\tsp_x = DSP4.sprite_x + sp_dx;\n\t\t\tsp_y = DSP4.sprite_y + sp_dy;\n\n\t\t\t// update sprite nametable/attribute information\n\t\t\tsp_attr = DSP4.sprite_attr + sp_dattr;\n\n\t\t\t// allow partially visibile tiles\n\t\t\tpixels = DSP4.sprite_size ? 15 : 7;\n\n\t\t\tDSP4_CLEAR_OUT();\n\n\t\t\t// transparent tile to clip off parts of a sprite (overdraw)\n\t\t\tif (DSP4.sprite_clipy - pixels <= sp_y && sp_y <= DSP4.sprite_clipy && sp_x >= DSP4.viewport_left - pixels && sp_x <= DSP4.viewport_right && DSP4.sprite_clipy >= DSP4.viewport_top - pixels && DSP4.sprite_clipy <= DSP4.viewport_bottom)\n\t\t\t\tDSP4_OP0B(&draw, sp_x, DSP4.sprite_clipy, 0x00EE, DSP4.sprite_size, 0);\n\n\t\t\t// normal sprite tile\n\t\t\tif (sp_x >= DSP4.viewport_left - pixels && sp_x <= DSP4.viewport_right && sp_y >= DSP4.viewport_top - pixels && sp_y <= DSP4.viewport_bottom && sp_y <= DSP4.sprite_clipy)\n\t\t\t\tDSP4_OP0B(&draw, sp_x, sp_y, sp_attr, DSP4.sprite_size, 0);\n\n\t\t\t// no following OAM data\n\t\t\tDSP4_OP0B(&draw, 0, 0x0100, 0, 0, 1);\n\t\t}\n\t\twhile (1);\n\t}\n\twhile (1);\n\n\tterminate:\n\tDSP4.waiting4command = TRUE;\n}\n\nstatic void DSP4_OP0A (int16 n2, int16 *o1, int16 *o2, int16 *o3, int16 *o4)\n{\n\tstatic const uint16\tOP0A_Values[16] =\n\t{\n\t\t0x0000, 0x0030, 0x0060, 0x0090, 0x00c0, 0x00f0, 0x0120, 0x0150,\n\t\t0xfe80, 0xfeb0, 0xfee0, 0xff10, 0xff40, 0xff70, 0xffa0, 0xffd0\n\t};\n\n\t*o4 = OP0A_Values[(n2 & 0x000f)];\n\t*o3 = OP0A_Values[(n2 & 0x00f0) >> 4];\n\t*o2 = OP0A_Values[(n2 & 0x0f00) >> 8];\n\t*o1 = OP0A_Values[(n2 & 0xf000) >> 12];\n}\n\nstatic void DSP4_OP0B (bool8 *draw, int16 sp_x, int16 sp_y, int16 sp_attr, bool8 size, bool8 stop)\n{\n\tint16\tRow1, Row2;\n\n\t// SR = 0x00\n\n\t// align to nearest 8-pixel row\n\tRow1 = (sp_y >> 3) & 0x1f;\n\tRow2 = (Row1 + 1)  & 0x1f;\n\n\t// check boundaries\n\tif (!((sp_y < 0) || ((sp_y & 0x01ff) < 0x00eb)))\n\t\t*draw = 0;\n\n\tif (size)\n\t{\n\t\tif (DSP4.OAM_Row[Row1] + 1 >= DSP4.OAM_RowMax)\n\t\t\t*draw = 0;\n\t\tif (DSP4.OAM_Row[Row2] + 1 >= DSP4.OAM_RowMax)\n\t\t\t*draw = 0;\n\t}\n\telse\n\t{\n\t\tif (DSP4.OAM_Row[Row1] >= DSP4.OAM_RowMax)\n\t\t\t*draw = 0;\n\t}\n\n\t// emulator fail-safe (unknown if this really exists)\n\tif (DSP4.sprite_count >= 128)\n\t\t*draw = 0;\n\n\t// SR = 0x80\n\n\tif (*draw)\n\t{\n\t\t// Row tiles\n\t\tif (size)\n\t\t{\n\t\t\tDSP4.OAM_Row[Row1] += 2;\n\t\t\tDSP4.OAM_Row[Row2] += 2;\n\t\t}\n\t\telse\n\t\t\tDSP4.OAM_Row[Row1]++;\n\n\t\t// yield OAM output\n\t\tDSP4_WRITE_WORD(1);\n\n\t\t// pack OAM data: x, y, name, attr\n\t\tDSP4_WRITE_BYTE(sp_x & 0xff);\n\t\tDSP4_WRITE_BYTE(sp_y & 0xff);\n\t\tDSP4_WRITE_WORD(sp_attr);\n\n\t\tDSP4.sprite_count++;\n\n\t\t// OAM: size, msb data\n\t\t// save post-oam table data for future retrieval\n\t\tDSP4.OAM_attr[DSP4.OAM_index] |= ((sp_x < 0 || sp_x > 255) << DSP4.OAM_bits);\n\t\tDSP4.OAM_bits++;\n\n\t\tDSP4.OAM_attr[DSP4.OAM_index] |= (size << DSP4.OAM_bits);\n\t\tDSP4.OAM_bits++;\n\n\t\t// move to next byte in buffer\n\t\tif (DSP4.OAM_bits == 16)\n\t\t{\n\t\t\tDSP4.OAM_bits = 0;\n\t\t\tDSP4.OAM_index++;\n\t\t}\n\t}\n\telse\n\tif (stop)\n\t\t// yield no OAM output\n\t\tDSP4_WRITE_WORD(0);\n}\n\nstatic void DSP4_OP0D (void)\n{\n\tDSP4.waiting4command = FALSE;\n\n\t// op flow control\n\tswitch (DSP4.Logic)\n\t{\n\t\tcase 1: goto resume1; break;\n\t\tcase 2: goto resume2; break;\n\t}\n\n\t////////////////////////////////////////////////////\n\t// process initial inputs\n\n\t// sort inputs\n\tDSP4.world_y           = DSP4_READ_DWORD();\n\tDSP4.poly_bottom[0][0] = DSP4_READ_WORD();\n\tDSP4.poly_top[0][0]    = DSP4_READ_WORD();\n\tDSP4.poly_cx[1][0]     = DSP4_READ_WORD();\n\tDSP4.viewport_bottom   = DSP4_READ_WORD();\n\tDSP4.world_x           = DSP4_READ_DWORD();\n\tDSP4.poly_cx[0][0]     = DSP4_READ_WORD();\n\tDSP4.poly_ptr[0][0]    = DSP4_READ_WORD();\n\tDSP4.world_yofs        = DSP4_READ_WORD();\n\tDSP4.world_dy          = DSP4_READ_DWORD();\n\tDSP4.world_dx          = DSP4_READ_DWORD();\n\tDSP4.distance          = DSP4_READ_WORD();\n\tDSP4_READ_WORD(); // 0x0000\n\tDSP4.world_xenv        = SEX78(DSP4_READ_WORD());\n\tDSP4.world_ddy         = DSP4_READ_WORD();\n\tDSP4.world_ddx         = DSP4_READ_WORD();\n\tDSP4.view_yofsenv      = DSP4_READ_WORD();\n\n\t// initial (x, y, offset) at starting raster line\n\tDSP4.view_x1    = (DSP4.world_x + DSP4.world_xenv) >> 16;\n\tDSP4.view_y1    = DSP4.world_y >> 16;\n\tDSP4.view_xofs1 = DSP4.world_x >> 16;\n\tDSP4.view_yofs1 = DSP4.world_yofs;\n\n\t// first raster line\n\tDSP4.poly_raster[0][0] = DSP4.poly_bottom[0][0];\n\n\tdo\n\t{\n\t\t////////////////////////////////////////////////////\n\t\t// process one iteration of projection\n\n\t\t// perspective projection of world (x, y, scroll) points\n\t\t// based on the current projection lines\n\t\tDSP4.view_x2    = (((DSP4.world_x + DSP4.world_xenv) >> 16) * DSP4.distance >> 15) + (DSP4.view_turnoff_x * DSP4.distance >> 15);\n\t\tDSP4.view_y2    = (DSP4.world_y >> 16) * DSP4.distance >> 15;\n\t\tDSP4.view_xofs2 = DSP4.view_x2;\n\t\tDSP4.view_yofs2 = (DSP4.world_yofs * DSP4.distance >> 15) + DSP4.poly_bottom[0][0] - DSP4.view_y2;\n\n\t\t// 1. World x-location before transformation\n\t\t// 2. Viewer x-position at the current\n\t\t// 3. World y-location before perspective projection\n\t\t// 4. Viewer y-position below the horizon\n\t\t// 5. Number of raster lines drawn in this iteration\n\t\tDSP4_CLEAR_OUT();\n\t\tDSP4_WRITE_WORD((DSP4.world_x + DSP4.world_xenv) >> 16);\n\t\tDSP4_WRITE_WORD(DSP4.view_x2);\n\t\tDSP4_WRITE_WORD(DSP4.world_y >> 16);\n\t\tDSP4_WRITE_WORD(DSP4.view_y2);\n\n\t\t//////////////////////////////////////////////////////////\n\n\t\t// SR = 0x00\n\n\t\t// determine # of raster lines used\n\t\tDSP4.segments = DSP4.view_y1 - DSP4.view_y2;\n\n\t\t// prevent overdraw\n\t\tif (DSP4.view_y2 >= DSP4.poly_raster[0][0])\n\t\t\tDSP4.segments = 0;\n\t\telse\n\t\t\tDSP4.poly_raster[0][0] = DSP4.view_y2;\n\n\t\t// don't draw outside the window\n\t\tif (DSP4.view_y2 < DSP4.poly_top[0][0])\n\t\t{\n\t\t\tDSP4.segments = 0;\n\n\t\t\t// flush remaining raster lines\n\t\t\tif (DSP4.view_y1 >= DSP4.poly_top[0][0])\n\t\t\t\tDSP4.segments = DSP4.view_y1 - DSP4.poly_top[0][0];\n\t\t}\n\n\t\t// SR = 0x80\n\n\t\tDSP4_WRITE_WORD(DSP4.segments);\n\n\t\t//////////////////////////////////////////////////////////\n\n\t\t// scan next command if no SR check needed\n\t\tif (DSP4.segments)\n\t\t{\n\t\t\tint32\tpx_dx, py_dy;\n\t\t\tint32\tx_scroll, y_scroll;\n\n\t\t\t// SR = 0x00\n\n\t\t\t// linear interpolation (lerp) between projected points\n\t\t\tpx_dx = (DSP4.view_xofs2 - DSP4.view_xofs1) * DSP4_Inverse(DSP4.segments) << 1;\n\t\t\tpy_dy = (DSP4.view_yofs2 - DSP4.view_yofs1) * DSP4_Inverse(DSP4.segments) << 1;\n\n\t\t\t// starting step values\n\t\t\tx_scroll = SEX16(DSP4.poly_cx[0][0] + DSP4.view_xofs1);\n\t\t\ty_scroll = SEX16(-DSP4.viewport_bottom + DSP4.view_yofs1 + DSP4.view_yofsenv + DSP4.poly_cx[1][0] - DSP4.world_yofs);\n\n\t\t\t// SR = 0x80\n\n\t\t\t// rasterize line\n\t\t\tfor (DSP4.lcv = 0; DSP4.lcv < DSP4.segments; DSP4.lcv++)\n\t\t\t{\n\t\t\t\t// 1. HDMA memory pointer (bg1)\n\t\t\t\t// 2. vertical scroll offset ($210E)\n\t\t\t\t// 3. horizontal scroll offset ($210D)\n\t\t\t\tDSP4_WRITE_WORD(DSP4.poly_ptr[0][0]);\n\t\t\t\tDSP4_WRITE_WORD((y_scroll + 0x8000) >> 16);\n\t\t\t\tDSP4_WRITE_WORD((x_scroll + 0x8000) >> 16);\n\n\t\t\t\t// update memory address\n\t\t\t\tDSP4.poly_ptr[0][0] -= 4;\n\n\t\t\t\t// update screen values\n\t\t\t\tx_scroll += px_dx;\n\t\t\t\ty_scroll += py_dy;\n\t\t\t}\n\t\t}\n\n\t\t/////////////////////////////////////////////////////\n\t\t// Post-update\n\n\t\t// update new viewer (x, y, scroll) to last raster line drawn\n\t\tDSP4.view_x1    = DSP4.view_x2;\n\t\tDSP4.view_y1    = DSP4.view_y2;\n\t\tDSP4.view_xofs1 = DSP4.view_xofs2;\n\t\tDSP4.view_yofs1 = DSP4.view_yofs2;\n\n\t\t// add deltas for projection lines\n\t\tDSP4.world_dx += SEX78(DSP4.world_ddx);\n\t\tDSP4.world_dy += SEX78(DSP4.world_ddy);\n\n\t\t// update projection lines\n\t\tDSP4.world_x += (DSP4.world_dx + DSP4.world_xenv);\n\t\tDSP4.world_y += DSP4.world_dy;\n\n\t\t////////////////////////////////////////////////////\n\t\t// command check\n\n\t\t// scan next command\n\t\tDSP4.in_count = 2;\n\t\tDSP4_WAIT(1);\n\n\t\tresume1:\n\n\t\t// inspect input\n\t\tDSP4.distance = DSP4_READ_WORD();\n\n\t\t// terminate op\n\t\tif (DSP4.distance == -0x8000)\n\t\t\tbreak;\n\n\t\t// already have 2 bytes in queue\n\t\tDSP4.in_count = 6;\n\t\tDSP4_WAIT(2);\n\n\t\tresume2:\n\n\t\t// inspect inputs\n\t\tDSP4.world_ddy    = DSP4_READ_WORD();\n\t\tDSP4.world_ddx    = DSP4_READ_WORD();\n\t\tDSP4.view_yofsenv = DSP4_READ_WORD();\n\n\t\t// no envelope here\n\t\tDSP4.world_xenv = 0;\n\t}\n\twhile (1);\n\n\tDSP4.waiting4command = TRUE;\n}\n\nstatic void DSP4_OP0E (void)\n{\n\tDSP4.OAM_RowMax = 16;\n\tmemset(DSP4.OAM_Row, 0, 64);\n}\n\nstatic void DSP4_OP0F (void)\n{\n\tDSP4.waiting4command = FALSE;\n\n\t// op flow control\n\tswitch (DSP4.Logic)\n\t{\n\t\tcase 1: goto resume1; break;\n\t\tcase 2: goto resume2; break;\n\t\tcase 3: goto resume3; break;\n\t\tcase 4: goto resume4; break;\n\t}\n\n\t////////////////////////////////////////////////////\n\t// process initial inputs\n\n\t// sort inputs\n\tDSP4_READ_WORD(); // 0x0000\n\tDSP4.world_y           = DSP4_READ_DWORD();\n\tDSP4.poly_bottom[0][0] = DSP4_READ_WORD();\n\tDSP4.poly_top[0][0]    = DSP4_READ_WORD();\n\tDSP4.poly_cx[1][0]     = DSP4_READ_WORD();\n\tDSP4.viewport_bottom   = DSP4_READ_WORD();\n\tDSP4.world_x           = DSP4_READ_DWORD();\n\tDSP4.poly_cx[0][0]     = DSP4_READ_WORD();\n\tDSP4.poly_ptr[0][0]    = DSP4_READ_WORD();\n\tDSP4.world_yofs        = DSP4_READ_WORD();\n\tDSP4.world_dy          = DSP4_READ_DWORD();\n\tDSP4.world_dx          = DSP4_READ_DWORD();\n\tDSP4.distance          = DSP4_READ_WORD();\n\tDSP4_READ_WORD(); // 0x0000\n\tDSP4.world_xenv        = DSP4_READ_DWORD();\n\tDSP4.world_ddy         = DSP4_READ_WORD();\n\tDSP4.world_ddx         = DSP4_READ_WORD();\n\tDSP4.view_yofsenv      = DSP4_READ_WORD();\n\n\t// initial (x, y, offset) at starting raster line\n\tDSP4.view_x1         = (DSP4.world_x + DSP4.world_xenv) >> 16;\n\tDSP4.view_y1         = DSP4.world_y >> 16;\n\tDSP4.view_xofs1      = DSP4.world_x >> 16;\n\tDSP4.view_yofs1      = DSP4.world_yofs;\n\tDSP4.view_turnoff_x  = 0;\n\tDSP4.view_turnoff_dx = 0;\n\n\t// first raster line\n\tDSP4.poly_raster[0][0] = DSP4.poly_bottom[0][0];\n\n\tdo\n\t{\n\t\t////////////////////////////////////////////////////\n\t\t// process one iteration of projection\n\n\t\t// perspective projection of world (x, y, scroll) points\n\t\t// based on the current projection lines\n\t\tDSP4.view_x2    = ((DSP4.world_x + DSP4.world_xenv) >> 16) * DSP4.distance >> 15;\n\t\tDSP4.view_y2    = (DSP4.world_y >> 16) * DSP4.distance >> 15;\n\t\tDSP4.view_xofs2 = DSP4.view_x2;\n\t\tDSP4.view_yofs2 = (DSP4.world_yofs * DSP4.distance >> 15) + DSP4.poly_bottom[0][0] - DSP4.view_y2;\n\n\t\t// 1. World x-location before transformation\n\t\t// 2. Viewer x-position at the next\n\t\t// 3. World y-location before perspective projection\n\t\t// 4. Viewer y-position below the horizon\n\t\t// 5. Number of raster lines drawn in this iteration\n\t\tDSP4_CLEAR_OUT();\n\t\tDSP4_WRITE_WORD((DSP4.world_x + DSP4.world_xenv) >> 16);\n\t\tDSP4_WRITE_WORD(DSP4.view_x2);\n\t\tDSP4_WRITE_WORD(DSP4.world_y >> 16);\n\t\tDSP4_WRITE_WORD(DSP4.view_y2);\n\n\t\t//////////////////////////////////////////////////////\n\n\t\t// SR = 0x00\n\n\t\t// determine # of raster lines used\n\t\tDSP4.segments = DSP4.poly_raster[0][0] - DSP4.view_y2;\n\n\t\t// prevent overdraw\n\t\tif (DSP4.view_y2 >= DSP4.poly_raster[0][0])\n\t\t\tDSP4.segments = 0;\n\t\telse\n\t\t\tDSP4.poly_raster[0][0] = DSP4.view_y2;\n\n\t\t// don't draw outside the window\n\t\tif (DSP4.view_y2 < DSP4.poly_top[0][0])\n\t\t{\n\t\t\tDSP4.segments = 0;\n\n\t\t\t// flush remaining raster lines\n\t\t\tif (DSP4.view_y1 >= DSP4.poly_top[0][0])\n\t\t\t\tDSP4.segments = DSP4.view_y1 - DSP4.poly_top[0][0];\n\t\t}\n\n\t\t// SR = 0x80\n\n\t\tDSP4_WRITE_WORD(DSP4.segments);\n\n\t\t//////////////////////////////////////////////////////\n\n\t\t// scan next command if no SR check needed\n\t\tif (DSP4.segments)\n\t\t{\n\t\t\tint32\tpx_dx, py_dy;\n\t\t\tint32\tx_scroll, y_scroll;\n\n\t\t\tfor (DSP4.lcv = 0; DSP4.lcv < 4; DSP4.lcv++)\n\t\t\t{\n\t\t\t\t// grab inputs\n\t\t\t\tDSP4.in_count = 4;\n\t\t\t\tDSP4_WAIT(1);\n\n\t\t\t\tresume1:\n\n\t\t\t\tfor (;;)\n\t\t\t\t{\n\t\t\t\t\tint16\tdist;\n\t\t\t\t\tint16\tcolor, red, green, blue;\n\n\t\t\t\t\tdist  = DSP4_READ_WORD();\n\t\t\t\t\tcolor = DSP4_READ_WORD();\n\n\t\t\t\t\t// U1+B5+G5+R5\n\t\t\t\t\tred   =  color        & 0x1f;\n\t\t\t\t\tgreen = (color >>  5) & 0x1f;\n\t\t\t\t\tblue  = (color >> 10) & 0x1f;\n\n\t\t\t\t\t// dynamic lighting\n\t\t\t\t\tred   = (red   * dist >> 15) & 0x1f;\n\t\t\t\t\tgreen = (green * dist >> 15) & 0x1f;\n\t\t\t\t\tblue  = (blue  * dist >> 15) & 0x1f;\n\t\t\t\t\tcolor = red | (green << 5) | (blue << 10);\n\n\t\t\t\t\tDSP4_CLEAR_OUT();\n\t\t\t\t\tDSP4_WRITE_WORD(color);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//////////////////////////////////////////////////////\n\n\t\t\t// SR = 0x00\n\n\t\t\t// linear interpolation (lerp) between projected points\n\t\t\tpx_dx = (DSP4.view_xofs2 - DSP4.view_xofs1) * DSP4_Inverse(DSP4.segments) << 1;\n\t\t\tpy_dy = (DSP4.view_yofs2 - DSP4.view_yofs1) * DSP4_Inverse(DSP4.segments) << 1;\n\n\t\t\t// starting step values\n\t\t\tx_scroll = SEX16(DSP4.poly_cx[0][0] + DSP4.view_xofs1);\n\t\t\ty_scroll = SEX16(-DSP4.viewport_bottom + DSP4.view_yofs1 + DSP4.view_yofsenv + DSP4.poly_cx[1][0] - DSP4.world_yofs);\n\n\t\t\t// SR = 0x80\n\n\t\t\t// rasterize line\n\t\t\tfor (DSP4.lcv = 0; DSP4.lcv < DSP4.segments; DSP4.lcv++)\n\t\t\t{\n\t\t\t\t// 1. HDMA memory pointer\n\t\t\t\t// 2. vertical scroll offset ($210E)\n\t\t\t\t// 3. horizontal scroll offset ($210D)\n\t\t\t\tDSP4_WRITE_WORD(DSP4.poly_ptr[0][0]);\n\t\t\t\tDSP4_WRITE_WORD((y_scroll + 0x8000) >> 16);\n\t\t\t\tDSP4_WRITE_WORD((x_scroll + 0x8000) >> 16);\n\n\t\t\t\t// update memory address\n\t\t\t\tDSP4.poly_ptr[0][0] -= 4;\n\n\t\t\t\t// update screen values\n\t\t\t\tx_scroll += px_dx;\n\t\t\t\ty_scroll += py_dy;\n\t\t\t}\n\t\t}\n\n\t\t////////////////////////////////////////////////////\n\t\t// Post-update\n\n\t\t// update new viewer (x, y, scroll) to last raster line drawn\n\t\tDSP4.view_x1    = DSP4.view_x2;\n\t\tDSP4.view_y1    = DSP4.view_y2;\n\t\tDSP4.view_xofs1 = DSP4.view_xofs2;\n\t\tDSP4.view_yofs1 = DSP4.view_yofs2;\n\n\t\t// add deltas for projection lines\n\t\tDSP4.world_dx += SEX78(DSP4.world_ddx);\n\t\tDSP4.world_dy += SEX78(DSP4.world_ddy);\n\n\t\t// update projection lines\n\t\tDSP4.world_x += (DSP4.world_dx + DSP4.world_xenv);\n\t\tDSP4.world_y += DSP4.world_dy;\n\n\t\t// update road turnoff position\n\t\tDSP4.view_turnoff_x += DSP4.view_turnoff_dx;\n\n\t\t////////////////////////////////////////////////////\n\t\t// command check\n\n\t\t// scan next command\n\t\tDSP4.in_count = 2;\n\t\tDSP4_WAIT(2);\n\n\t\tresume2:\n\n\t\t// check for termination\n\t\tDSP4.distance = DSP4_READ_WORD();\n\t\tif (DSP4.distance == -0x8000)\n\t\t\tbreak;\n\n\t\t// road splice\n\t\tif ((uint16) DSP4.distance == 0x8001)\n\t\t{\n\t\t\tDSP4.in_count = 6;\n\t\t\tDSP4_WAIT(3);\n\n\t\t\tresume3:\n\n\t\t\tDSP4.distance        = DSP4_READ_WORD();\n\t\t\tDSP4.view_turnoff_x  = DSP4_READ_WORD();\n\t\t\tDSP4.view_turnoff_dx = DSP4_READ_WORD();\n\n\t\t\t// factor in new changes\n\t\t\tDSP4.view_x1    += (DSP4.view_turnoff_x * DSP4.distance >> 15);\n\t\t\tDSP4.view_xofs1 += (DSP4.view_turnoff_x * DSP4.distance >> 15);\n\n\t\t\t// update stepping values\n\t\t\tDSP4.view_turnoff_x += DSP4.view_turnoff_dx;\n\n\t\t\tDSP4.in_count = 2;\n\t\t\tDSP4_WAIT(2);\n\t\t}\n\n\t\t// already have 2 bytes in queue\n\t\tDSP4.in_count = 6;\n\t\tDSP4_WAIT(4);\n\n\t\tresume4:\n\n\t\t// inspect inputs\n\t\tDSP4.world_ddy    = DSP4_READ_WORD();\n\t\tDSP4.world_ddx    = DSP4_READ_WORD();\n\t\tDSP4.view_yofsenv = DSP4_READ_WORD();\n\n\t\t// no envelope here\n\t\tDSP4.world_xenv = 0;\n\t}\n\twhile (1);\n\n\t// terminate op\n\tDSP4.waiting4command = TRUE;\n}\n\nstatic void DSP4_OP10 (void)\n{\n\tDSP4.waiting4command = FALSE;\n\n\t// op flow control\n\tswitch (DSP4.Logic)\n\t{\n\t\tcase 1: goto resume1; break;\n\t\tcase 2: goto resume2; break;\n\t\tcase 3: goto resume3; break;\n\t}\n\n\t////////////////////////////////////////////////////\n\t// sort inputs\n\n\tDSP4_READ_WORD(); // 0x0000\n\tDSP4.world_y           = DSP4_READ_DWORD();\n\tDSP4.poly_bottom[0][0] = DSP4_READ_WORD();\n\tDSP4.poly_top[0][0]    = DSP4_READ_WORD();\n\tDSP4.poly_cx[1][0]     = DSP4_READ_WORD();\n\tDSP4.viewport_bottom   = DSP4_READ_WORD();\n\tDSP4.world_x           = DSP4_READ_DWORD();\n\tDSP4.poly_cx[0][0]     = DSP4_READ_WORD();\n\tDSP4.poly_ptr[0][0]    = DSP4_READ_WORD();\n\tDSP4.world_yofs        = DSP4_READ_WORD();\n\tDSP4.distance          = DSP4_READ_WORD();\n\tDSP4.view_y2           = DSP4_READ_WORD();\n\tDSP4.view_dy           = DSP4_READ_WORD() * DSP4.distance >> 15;\n\tDSP4.view_x2           = DSP4_READ_WORD();\n\tDSP4.view_dx           = DSP4_READ_WORD() * DSP4.distance >> 15;\n\tDSP4.view_yofsenv      = DSP4_READ_WORD();\n\n\t// initial (x, y, offset) at starting raster line\n\tDSP4.view_x1    = DSP4.world_x >> 16;\n\tDSP4.view_y1    = DSP4.world_y >> 16;\n\tDSP4.view_xofs1 = DSP4.view_x1;\n\tDSP4.view_yofs1 = DSP4.world_yofs;\n\n\t// first raster line\n\tDSP4.poly_raster[0][0] = DSP4.poly_bottom[0][0];\n\n\tdo\n\t{\n\t\t////////////////////////////////////////////////////\n\t\t// process one iteration of projection\n\n\t\t// add shaping\n\t\tDSP4.view_x2 += DSP4.view_dx;\n\t\tDSP4.view_y2 += DSP4.view_dy;\n\n\t\t// vertical scroll calculation\n\t\tDSP4.view_xofs2 = DSP4.view_x2;\n\t\tDSP4.view_yofs2 = (DSP4.world_yofs * DSP4.distance >> 15) + DSP4.poly_bottom[0][0] - DSP4.view_y2;\n\n\t\t// 1. Viewer x-position at the next\n\t\t// 2. Viewer y-position below the horizon\n\t\t// 3. Number of raster lines drawn in this iteration\n\t\tDSP4_CLEAR_OUT();\n\t\tDSP4_WRITE_WORD(DSP4.view_x2);\n\t\tDSP4_WRITE_WORD(DSP4.view_y2);\n\n\t\t//////////////////////////////////////////////////////\n\n\t\t// SR = 0x00\n\n\t\t// determine # of raster lines used\n\t\tDSP4.segments = DSP4.view_y1 - DSP4.view_y2;\n\n\t\t// prevent overdraw\n\t\tif (DSP4.view_y2 >= DSP4.poly_raster[0][0])\n\t\t\tDSP4.segments = 0;\n\t\telse\n\t\t\tDSP4.poly_raster[0][0] = DSP4.view_y2;\n\n\t\t// don't draw outside the window\n\t\tif (DSP4.view_y2 < DSP4.poly_top[0][0])\n\t\t{\n\t\t\tDSP4.segments = 0;\n\n\t\t\t// flush remaining raster lines\n\t\t\tif (DSP4.view_y1 >= DSP4.poly_top[0][0])\n\t\t\t\tDSP4.segments = DSP4.view_y1 - DSP4.poly_top[0][0];\n\t\t}\n\n\t\t// SR = 0x80\n\n\t\tDSP4_WRITE_WORD(DSP4.segments);\n\n\t\t//////////////////////////////////////////////////////\n\n\t\t// scan next command if no SR check needed\n\t\tif (DSP4.segments)\n\t\t{\n\t\t\tfor (DSP4.lcv = 0; DSP4.lcv < 4; DSP4.lcv++)\n\t\t\t{\n\t\t\t\t// grab inputs\n\t\t\t\tDSP4.in_count = 4;\n\t\t\t\tDSP4_WAIT(1);\n\n\t\t\t\tresume1:\n\n\t\t\t\tfor (;;)\n\t\t\t\t{\n\t\t\t\t\tint16\tdist;\n\t\t\t\t\tint16\tcolor, red, green, blue;\n\n\t\t\t\t\tdist  = DSP4_READ_WORD();\n\t\t\t\t\tcolor = DSP4_READ_WORD();\n\n\t\t\t\t\t// U1+B5+G5+R5\n\t\t\t\t\tred   =  color        & 0x1f;\n\t\t\t\t\tgreen = (color >>  5) & 0x1f;\n\t\t\t\t\tblue  = (color >> 10) & 0x1f;\n\n\t\t\t\t\t// dynamic lighting\n\t\t\t\t\tred   = (red   * dist >> 15) & 0x1f;\n\t\t\t\t\tgreen = (green * dist >> 15) & 0x1f;\n\t\t\t\t\tblue  = (blue  * dist >> 15) & 0x1f;\n\t\t\t\t\tcolor = red | (green << 5) | (blue << 10);\n\n\t\t\t\t\tDSP4_CLEAR_OUT();\n\t\t\t\t\tDSP4_WRITE_WORD(color);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//////////////////////////////////////////////////////\n\n\t\t// scan next command if no SR check needed\n\t\tif (DSP4.segments)\n\t\t{\n\t\t\tint32\tpx_dx, py_dy;\n\t\t\tint32\tx_scroll, y_scroll;\n\n\t\t\t// SR = 0x00\n\n\t\t\t// linear interpolation (lerp) between projected points\n\t\t\tpx_dx = (DSP4.view_xofs2 - DSP4.view_xofs1) * DSP4_Inverse(DSP4.segments) << 1;\n\t\t\tpy_dy = (DSP4.view_yofs2 - DSP4.view_yofs1) * DSP4_Inverse(DSP4.segments) << 1;\n\n\t\t\t// starting step values\n\t\t\tx_scroll = SEX16(DSP4.poly_cx[0][0] + DSP4.view_xofs1);\n\t\t\ty_scroll = SEX16(-DSP4.viewport_bottom + DSP4.view_yofs1 + DSP4.view_yofsenv + DSP4.poly_cx[1][0] - DSP4.world_yofs);\n\n\t\t\t// SR = 0x80\n\n\t\t\t// rasterize line\n\t\t\tfor (DSP4.lcv = 0; DSP4.lcv < DSP4.segments; DSP4.lcv++)\n\t\t\t{\n\t\t\t\t// 1. HDMA memory pointer (bg2)\n\t\t\t\t// 2. vertical scroll offset ($2110)\n\t\t\t\t// 3. horizontal scroll offset ($210F)\n\t\t\t\tDSP4_WRITE_WORD(DSP4.poly_ptr[0][0]);\n\t\t\t\tDSP4_WRITE_WORD((y_scroll + 0x8000) >> 16);\n\t\t\t\tDSP4_WRITE_WORD((x_scroll + 0x8000) >> 16);\n\n\t\t\t\t// update memory address\n\t\t\t\tDSP4.poly_ptr[0][0] -= 4;\n\n\t\t\t\t// update screen values\n\t\t\t\tx_scroll += px_dx;\n\t\t\t\ty_scroll += py_dy;\n\t\t\t}\n\t\t}\n\n\t\t/////////////////////////////////////////////////////\n\t\t// Post-update\n\n\t\t// update new viewer (x, y, scroll) to last raster line drawn\n\t\tDSP4.view_x1    = DSP4.view_x2;\n\t\tDSP4.view_y1    = DSP4.view_y2;\n\t\tDSP4.view_xofs1 = DSP4.view_xofs2;\n\t\tDSP4.view_yofs1 = DSP4.view_yofs2;\n\n\t\t////////////////////////////////////////////////////\n\t\t// command check\n\n\t\t// scan next command\n\t\tDSP4.in_count = 2;\n\t\tDSP4_WAIT(2);\n\n\t\tresume2:\n\n\t\t// check for opcode termination\n\t\tDSP4.distance = DSP4_READ_WORD();\n\t\tif (DSP4.distance == -0x8000)\n\t\t\tbreak;\n\n\t\t// already have 2 bytes in queue\n\t\tDSP4.in_count = 10;\n\t\tDSP4_WAIT(3);\n\n\t\tresume3:\n\n\t\t// inspect inputs\n\t\tDSP4.view_y2 = DSP4_READ_WORD();\n\t\tDSP4.view_dy = DSP4_READ_WORD() * DSP4.distance >> 15;\n\t\tDSP4.view_x2 = DSP4_READ_WORD();\n\t\tDSP4.view_dx = DSP4_READ_WORD() * DSP4.distance >> 15;\n\t}\n\twhile (1);\n\n\tDSP4.waiting4command = TRUE;\n}\n\nstatic void DSP4_OP11 (int16 A, int16 B, int16 C, int16 D, int16 *M)\n{\n\t// 0x155 = 341 = Horizontal Width of the Screen\n\t*M = ((A * 0x0155 >> 2) & 0xf000) | ((B * 0x0155 >> 6) & 0x0f00) | ((C * 0x0155 >> 10) & 0x00f0) | ((D * 0x0155 >> 14) & 0x000f);\n}\n\nstatic void DSP4_SetByte (void)\n{\n\t// clear pending read\n\tif (DSP4.out_index < DSP4.out_count)\n\t{\n\t\tDSP4.out_index++;\n\t\treturn;\n\t}\n\n\tif (DSP4.waiting4command)\n\t{\n\t\tif (DSP4.half_command)\n\t\t{\n\t\t\tDSP4.command |= (DSP4.byte << 8);\n\t\t\tDSP4.in_index        = 0;\n\t\t\tDSP4.waiting4command = FALSE;\n\t\t\tDSP4.half_command    = FALSE;\n\t\t\tDSP4.out_count       = 0;\n\t\t\tDSP4.out_index       = 0;\n\n\t\t\tDSP4.Logic = 0;\n\n\t\t\tswitch (DSP4.command)\n\t\t\t{\n\t\t\t\tcase 0x0000: DSP4.in_count =  4; break;\n\t\t\t\tcase 0x0001: DSP4.in_count = 44; break;\n\t\t\t\tcase 0x0003: DSP4.in_count =  0; break;\n\t\t\t\tcase 0x0005: DSP4.in_count =  0; break;\n\t\t\t\tcase 0x0006: DSP4.in_count =  0; break;\n\t\t\t\tcase 0x0007: DSP4.in_count = 34; break;\n\t\t\t\tcase 0x0008: DSP4.in_count = 90; break;\n\t\t\t\tcase 0x0009: DSP4.in_count = 14; break;\n\t\t\t\tcase 0x000a: DSP4.in_count =  6; break;\n\t\t\t\tcase 0x000b: DSP4.in_count =  6; break;\n\t\t\t\tcase 0x000d: DSP4.in_count = 42; break;\n\t\t\t\tcase 0x000e: DSP4.in_count =  0; break;\n\t\t\t\tcase 0x000f: DSP4.in_count = 46; break;\n\t\t\t\tcase 0x0010: DSP4.in_count = 36; break;\n\t\t\t\tcase 0x0011: DSP4.in_count =  8; break;\n\t\t\t\tdefault:\n\t\t\t\t\tDSP4.waiting4command = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDSP4.command = DSP4.byte;\n\t\t\tDSP4.half_command = TRUE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tDSP4.parameters[DSP4.in_index] = DSP4.byte;\n\t\tDSP4.in_index++;\n\t}\n\n\tif (!DSP4.waiting4command && DSP4.in_count == DSP4.in_index)\n\t{\n\t\t// Actually execute the command\n\t\tDSP4.waiting4command = TRUE;\n\t\tDSP4.out_index       = 0;\n\t\tDSP4.in_index        = 0;\n\n\t\tswitch (DSP4.command)\n\t\t{\n\t\t\t// 16-bit multiplication\n\t\t\tcase 0x0000:\n\t\t\t{\n\t\t\t\tint16\tmultiplier, multiplicand;\n\t\t\t\tint32\tproduct;\n\n\t\t\t\tmultiplier   = DSP4_READ_WORD();\n\t\t\t\tmultiplicand = DSP4_READ_WORD();\n\n\t\t\t\tDSP4_Multiply(multiplicand, multiplier, &product);\n\n\t\t\t\tDSP4_CLEAR_OUT();\n\t\t\t\tDSP4_WRITE_WORD(product);\n\t\t\t\tDSP4_WRITE_WORD(product >> 16);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// single-player track projection\n\t\t\tcase 0x0001:\n\t\t\t\tDSP4_OP01();\n\t\t\t\tbreak;\n\n\t\t\t// single-player selection\n\t\t\tcase 0x0003:\n\t\t\t\tDSP4_OP03();\n\t\t\t\tbreak;\n\n\t\t\t// clear OAM\n\t\t\tcase 0x0005:\n\t\t\t\tDSP4_OP05();\n\t\t\t\tbreak;\n\n\t\t\t// transfer OAM\n\t\t\tcase 0x0006:\n\t\t\t\tDSP4_OP06();\n\t\t\t\tbreak;\n\n\t\t\t// single-player track turnoff projection\n\t\t\tcase 0x0007:\n\t\t\t\tDSP4_OP07();\n\t\t\t\tbreak;\n\n\t\t\t// solid polygon projection\n\t\t\tcase 0x0008:\n\t\t\t\tDSP4_OP08();\n\t\t\t\tbreak;\n\n\t\t\t// sprite projection\n\t\t\tcase 0x0009:\n\t\t\t\tDSP4_OP09();\n\t\t\t\tbreak;\n\n\t\t\t// unknown\n\t\t\tcase 0x000A:\n\t\t\t{\n\t\t\t\tDSP4_READ_WORD();\n\t\t\t\tint16\tin2a = DSP4_READ_WORD();\n\t\t\t\tDSP4_READ_WORD();\n\t\t\t\tint16\tout1a, out2a, out3a, out4a;\n\n\t\t\t\tDSP4_OP0A(in2a, &out2a, &out1a, &out4a, &out3a);\n\n\t\t\t\tDSP4_CLEAR_OUT();\n\t\t\t\tDSP4_WRITE_WORD(out1a);\n\t\t\t\tDSP4_WRITE_WORD(out2a);\n\t\t\t\tDSP4_WRITE_WORD(out3a);\n\t\t\t\tDSP4_WRITE_WORD(out4a);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// set OAM\n\t\t\tcase 0x000B:\n\t\t\t{\n\t\t\t\tint16\tsp_x    = DSP4_READ_WORD();\n\t\t\t\tint16\tsp_y    = DSP4_READ_WORD();\n\t\t\t\tint16\tsp_attr = DSP4_READ_WORD();\n\t\t\t\tbool8\tdraw = TRUE;\n\n\t\t\t\tDSP4_CLEAR_OUT();\n\t\t\t\tDSP4_OP0B(&draw, sp_x, sp_y, sp_attr, 0, 1);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// multi-player track projection\n\t\t\tcase 0x000D:\n\t\t\t\tDSP4_OP0D();\n\t\t\t\tbreak;\n\n\t\t\t// multi-player selection\n\t\t\tcase 0x000E:\n\t\t\t\tDSP4_OP0E();\n\t\t\t\tbreak;\n\n\t\t\t// single-player track projection with lighting\n\t\t\tcase 0x000F:\n\t\t\t\tDSP4_OP0F();\n\t\t\t\tbreak;\n\n\t\t\t// single-player track turnoff projection with lighting\n\t\t\tcase 0x0010:\n\t\t\t\tDSP4_OP10();\n\t\t\t\tbreak;\n\n\t\t\t// unknown: horizontal mapping command\n\t\t\tcase 0x0011:\n\t\t\t{\n\t\t\t\tint16\ta, b, c, d, m;\n\n\t\t\t\td = DSP4_READ_WORD();\n\t\t\t\tc = DSP4_READ_WORD();\n\t\t\t\tb = DSP4_READ_WORD();\n\t\t\t\ta = DSP4_READ_WORD();\n\n\t\t\t\tDSP4_OP11(a, b, c, d, &m);\n\n\t\t\t\tDSP4_CLEAR_OUT();\n\t\t\t\tDSP4_WRITE_WORD(m);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void DSP4_GetByte (void)\n{\n\tif (DSP4.out_count)\n\t{\n\t\tDSP4.byte = (uint8) DSP4.output[DSP4.out_index & 0x1FF];\n\n\t\tDSP4.out_index++;\n\t\tif (DSP4.out_count == DSP4.out_index)\n\t\t\tDSP4.out_count = 0;\n\t}\n\telse\n\t\tDSP4.byte = 0xff;\n}\n\nvoid DSP4SetByte (uint8 byte, uint16 address)\n{\n\tif (address < DSP0.boundary)\n\t{\n\t\tDSP4.byte    = byte;\n\t\tDSP4.address = address;\n\t\tDSP4_SetByte();\n\t}\n}\n\nuint8 DSP4GetByte (uint16 address)\n{\n\tif (address < DSP0.boundary)\n\t{\n\t\tDSP4.address = address;\n\t\tDSP4_GetByte();\n\t\treturn (DSP4.byte);\n\t}\n\n\treturn (0x80);\n}\n"
        },
        {
          "name": "external",
          "type": "tree",
          "content": null
        },
        {
          "name": "filter",
          "type": "tree",
          "content": null
        },
        {
          "name": "font.h",
          "type": "blob",
          "size": 18.595703125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _FONT_H_\n#define _FONT_H_\n\nstatic const char\t*font[] =\n{\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"           .      . .                    .                ..       .      .                                                     \",\n\t\"          .#.    .#.#.    . .     ...   .#. .     .      .##.     .#.    .#.     . .       .                                .   \",\n\t\"          .#.    .#.#.   .#.#.   .###.  .#..#.   .#.     .#.     .#.      .#.   .#.#.     .#.                              .#.  \",\n\t\"          .#.    .#.#.  .#####. .#.#.    ..#.   .#.#.   .#.      .#.      .#.    .#.     ..#..           ....             .#.   \",\n\t\"          .#.     . .    .#.#.   .###.   .#..    .#.     .       .#.      .#.   .###.   .#####.   ..    .####.    ..     .#.    \",\n\t\"           .            .#####.   .#.#. .#..#.  .#.#.            .#.      .#.    .#.     ..#..   .##.    ....    .##.   .#.     \",\n\t\"          .#.            .#.#.   .###.   . .#.   .#.#.            .#.    .#.    .#.#.     .#.    .#.             .##.    .      \",\n\t\"           .              . .     ...       .     . .              .      .      . .       .    .#.               ..            \",\n\t\"                                                                                                 .                              \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"  .       .       ..     ....      .     ....     ..     ....     ..      ..                                              .     \",\n\t\" .#.     .#.     .##.   .####.    .#.   .####.   .##.   .####.   .##.    .##.     ..      ..       .             .       .#.    \",\n\t\".#.#.   .##.    .#..#.   ...#.   .##.   .#...   .#..     ...#.  .#..#.  .#..#.   .##.    .##.     .#.    ....   .#.     .#.#.   \",\n\t\".#.#.    .#.     . .#.   .##.   .#.#.   .###.   .###.     .#.    .##.   .#..#.   .##.    .##.    .#.    .####.   .#.     ..#.   \",\n\t\".#.#.    .#.      .#.    ...#.  .####.   ...#.  .#..#.    .#.   .#..#.   .###.    ..      ..    .#.      ....     .#.    .#.    \",\n\t\".#.#.    .#.     .#..   .#..#.   ..#.   .#..#.  .#..#.   .#.    .#..#.    ..#.   .##.    .##.    .#.    .####.   .#.      .     \",\n\t\" .#.    .###.   .####.   .##.     .#.    .##.    .##.    .#.     .##.    .##.    .##.    .#.      .#.    ....   .#.      .#.    \",\n\t\"  .      ...     ....     ..       .      ..      ..      .       ..      ..      ..    .#.        .             .        .     \",\n\t\"                                                                                         .                                      \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"  ..      ..     ...      ..     ...     ....    ....     ..     .  .    ...        .    .  .    .       .   .   .   .    ..    \",\n\t\" .##.    .##.   .###.    .##.   .###.   .####.  .####.   .##.   .#..#.  .###.      .#.  .#..#.  .#.     .#. .#. .#. .#.  .##.   \",\n\t\".#..#.  .#..#.  .#..#.  .#..#.  .#..#.  .#...   .#...   .#..#.  .#..#.   .#.       .#.  .#.#.   .#.     .##.##. .##..#. .#..#.  \",\n\t\".#.##.  .#..#.  .###.   .#. .   .#..#.  .###.   .###.   .#...   .####.   .#.       .#.  .##.    .#.     .#.#.#. .#.#.#. .#..#.  \",\n\t\".#.##.  .####.  .#..#.  .#. .   .#..#.  .#..    .#..    .#.##.  .#..#.   .#.     . .#.  .##.    .#.     .#...#. .#.#.#. .#..#.  \",\n\t\".#...   .#..#.  .#..#.  .#..#.  .#..#.  .#...   .#.     .#..#.  .#..#.   .#.    .#..#.  .#.#.   .#...   .#. .#. .#..##. .#..#.  \",\n\t\" .##.   .#..#.  .###.    .##.   .###.   .####.  .#.      .###.  .#..#.  .###.    .##.   .#..#.  .####.  .#. .#. .#. .#.  .##.   \",\n\t\"  ..     .  .    ...      ..     ...     ....    .        ...    .  .    ...      ..     .  .    ....    .   .   .   .    ..    \",\n\t\"                                                                                                                                \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\" ...      ..     ...      ..     ...     .   .   .   .   .   .   .  .    . .     ....    ...             ...      .             \",\n\t\".###.    .##.   .###.    .##.   .###.   .#. .#. .#. .#. .#. .#. .#..#.  .#.#.   .####.  .###.    .      .###.    .#.            \",\n\t\".#..#.  .#..#.  .#..#.  .#..#.   .#.    .#. .#. .#. .#. .#...#. .#..#.  .#.#.    ...#.  .#..    .#.      ..#.   .#.#.           \",\n\t\".#..#.  .#..#.  .#..#.   .#..    .#.    .#. .#. .#. .#. .#.#.#.  .##.   .#.#.     .#.   .#.      .#.      .#.    . .            \",\n\t\".###.   .#..#.  .###.    ..#.    .#.    .#. .#. .#. .#. .#.#.#. .#..#.   .#.     .#.    .#.       .#.     .#.                   \",\n\t\".#..    .##.#.  .#.#.   .#..#.   .#.    .#...#.  .#.#.  .##.##. .#..#.   .#.    .#...   .#..       .#.   ..#.            ....   \",\n\t\".#.      .##.   .#..#.   .##.    .#.     .###.    .#.   .#. .#. .#..#.   .#.    .####.  .###.       .   .###.           .####.  \",\n\t\" .        ..#.   .  .     ..      .       ...      .     .   .   .  .     .      ....    ...             ...             ....   \",\n\t\"            .                                                                                                                   \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\" ..              .                  .              .             .        .        .     .       ..                             \",\n\t\".##.            .#.                .#.            .#.           .#.      .#.      .#.   .#.     .##.                            \",\n\t\" .#.      ...   .#..      ..      ..#.    ..     .#.#.    ...   .#..     ..        .    .#..     .#.     .. ..   ...      ..    \",\n\t\"  .#.    .###.  .###.    .##.    .###.   .##.    .#..    .###.  .###.   .##.      .#.   .#.#.    .#.    .##.##. .###.    .##.   \",\n\t\"   .    .#..#.  .#..#.  .#..    .#..#.  .#.##.  .###.   .#..#.  .#..#.   .#.      .#.   .##.     .#.    .#.#.#. .#..#.  .#..#.  \",\n\t\"        .#.##.  .#..#.  .#..    .#..#.  .##..    .#.     .##.   .#..#.   .#.     ..#.   .#.#.    .#.    .#...#. .#..#.  .#..#.  \",\n\t\"         .#.#.  .###.    .##.    .###.   .##.    .#.    .#...   .#..#.  .###.   .#.#.   .#..#.  .###.   .#. .#. .#..#.   .##.   \",\n\t\"          . .    ...      ..      ...     ..      .      .###.   .  .    ...     .#.     .  .    ...     .   .   .  .     ..    \",\n\t\"                                                          ...                     .                                             \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"                                  .                                                        .      .      .        . .           \",\n\t\"                                 .#.                                                      .#.    .#.    .#.      .#.#.          \",\n\t\" ...      ...    ...      ...    .#.     .  .    . .     .   .   .  .    .  .    ....    .#.     .#.     .#.    .#.#.           \",\n\t\".###.    .###.  .###.    .###.  .###.   .#..#.  .#.#.   .#...#. .#..#.  .#..#.  .####.  .##.     .#.     .##.    . .            \",\n\t\".#..#.  .#..#.  .#..#.  .##..    .#.    .#..#.  .#.#.   .#.#.#.  .##.   .#..#.   ..#.    .#.     .#.     .#.                    \",\n\t\".#..#.  .#..#.  .#. .    ..##.   .#..   .#..#.  .#.#.   .#.#.#.  .##.    .#.#.   .#..    .#.     .#.     .#.                    \",\n\t\".###.    .###.  .#.     .###.     .##.   .###.   .#.     .#.#.  .#..#.    .#.   .####.    .#.    .#.    .#.                     \",\n\t\".#..      ..#.   .       ...       ..     ...     .       . .    .  .    .#.     ....      .      .      .                      \",\n\t\" .          .                                                             .                                                     \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"                   ..                            .....                                                                          \",\n\t\"                  .##.                          .#####.  ...       .      .               .       .               ..            \",\n\t\"                  .#.       .             ..     ....#. .###.     .#.    .#.             .#.     .#..            .##.    . . .  \",\n\t\"                  .#.      .#.           .##.   .#####.   .#.    .#.    .###.    ...    .###.    .###.    ..      .#.   .#.#.#. \",\n\t\"          .       .#.      .#.     .     .##.    ....#.  .#.    .##.    .#.#.   .###.    .#.    .##.#.   .##.    .##.   .#.#.#. \",\n\t\"         .#.       .       .#.    .#.     ..     ...#.   .#.     .#.     ..#.    .#.    .##.     .#..    ..#.     .#.    ...#.  \",\n\t\"        .#.#.             .##.     .#.          .###.   .#.      .#.     .#.    .###.    .#.     .#.    .####.   .##.    .##.   \",\n\t\"         .#.               ..       .#.          ...     .        .       .      ...      .       .      ....     ..      ..    \",\n\t\"          .                          .                                                                                          \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"         ....       .      .      ...       .      .       .      ....    .               . .    ..  .   .....    .      .   .  \",\n\t\"        .####.     .#.   ..#..   .###.   ...#.   ..#..   ..#..   .####.  .#...   ....    .#.#.  .##..#. .#####.  .#...  .#. .#. \",\n\t\" ....    ...#.    .#.   .#####.   .#.   .#####. .#####. .#####.  .#..#.  .####. .####.  .#####.  .. .#.  ....#. .#####. .#. .#. \",\n\t\".####.   .##.    .##    .#...#.   .#.    ...#.   ..#.#.  ..#..   .# .#. .#..#.   ...#.   .#.#.  .##..#.    .#.   .#..#.  .#..#. \",\n\t\" ....    .#.    .#.#     .  .#.   .#.     .##.   .#..#. .#####. .#. .#.  . .#.     .#.    ..#.   .. .#.   .#.    .#.#.    . .#. \",\n\t\"         .#.      .#.     ..#.   ..#..   .#.#.   .#..#.  ..#..   . .#.     .#.   ...#.    .#.    ...#.   .#.#.   .#...   ...#.  \",\n\t\"        .#.       .#.    .##.   .#####. .#..#.  .#..#.    .#.     .#.     .#.   .####.   .#.    .###.   .#. .#.   .###. .###.   \",\n\t\"         .         .      ..     .....   .  .    .  .      .       .       .     ....     .      ...     .   .     ...   ...    \",\n\t\"                                                                                                                                \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"  ....     ..    . . .    ...     .        .      ...     ....     .        .            .       .....     .       .            \",\n\t\" .####.  ..##.  .#.#.#.  .###.   .#.     ..#..   .###.   .####.  ..#..     .#.    . .   .#. ..  .#####.   .#.    ..#..   .....  \",\n\t\" .#..#. .###.   .#.#.#.  .....   .#.    .#####.   ...     ...#. .#####.    .#.   .#.#.  .#..##.  ....#.  .#.#.  .#####. .#####. \",\n\t\" .####.  ..#.   .#.#.#. .#####.  .##.    ..#..           .#.#.   ....#.    .#.   .#.#.  .###..      .#. .#..#.   ..#..      .#. \",\n\t\".#...#. .####.   . ..#.  ..#..   .#.#.    .#.             .#.    .###.    .#.   .#. .#. .#..       .#.   .  .#. .#.#.#.  .#.#.  \",\n\t\" . .#.   ..#.    ...#.    .#.    .#..    ..#.    .....   .#.#.  .#.#.#.   .#.   .#. .#. .#....   ..#.       .#. .#.#.#.   .#.   \",\n\t\"  .#.   .##.    .###.    .#.     .#.    .##.    .#####. .#. .#.  ..#..   .#.    .#. .#.  .####. .##.        .#.  ..#..     .#.  \",\n\t\"   .     ..      ...      .       .      ..      .....   .   .     .      .      .   .    ....   ..          .     .        .   \",\n\t\"                                                                                                                                \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"  ..       .         .    ...     .               ....   ....     .  .     . .   .               .....       .   . .      .     \",\n\t\" .##.     .#.       .#.  .###.   .#...    ...    .####. .####.   .#..#.   .#.#. .#.      .....  .#####.  ....#. .#.#.    .#.    \",\n\t\"  ..#.   .#.      . .#.   .#.    .#.##.  .###.    ...#.  .....   .#..#.   .#.#. .#.     .#####. .#...#. .###.#.  .#.#.  .#.#.   \",\n\t\" .##.   .#. .    .#.#.  .#####.  .##.#.    .#.    .###. .#####.  .#..#.   .#.#. .#. .   .#...#.  .  .#.  ....#.   . .    .#.    \",\n\t\"  ..#.  .#..#.    .##.   ..#..  .#.#.     ..#.     ..#.  ....#.   . .#.  .#.#.  .#..#.  .#...#.     .#.    .#.            .     \",\n\t\" .##.   .####.   ..#.#.   .#..     .#.   ...#.    ...#.   ..#.    ..#.   .#.#.  .#.#.   .#####.   ..#.   ...#.                  \",\n\t\"  ..#.   ...#.  .##. .    .###.    .#.  .#####.  .####.  .##.    .##.   .#..##. .##.    .#...#.  .##.   .###.                   \",\n\t\"    .       .    ..        ...      .    .....    ....    ..      ...    .  ..   ..      .   .    ..     ...                    \",\n\t\"                                                                                                                                \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"                                                                                                                                \",\n\t\"    .     .                                                                                                                     \",\n\t\"   .#.   .#.       .     .....                                                                                                  \",\n\t\"  .##.   .##.     .#.   .#####.                                                                                                 \",\n\t\" .###.   .###.   .###.   .###.                                                                                                  \",\n\t\"  .##.   .##.   .#####.   .#.                                                                                                   \",\n\t\"   .#.   .#.     .....     .                                                                                                    \",\n\t\"    .     .                                                                                                                     \",\n\t\"                                                                                                                                \",\n\t//2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \",\n\t\"                                                                                                                                \"\n};\n\n#endif\n"
        },
        {
          "name": "fscompat.cpp",
          "type": "blob",
          "size": 5.173828125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include <cstring>\n#include <string>\n\n#include \"display.h\"\n#include \"fscompat.h\"\n#include \"port.h\"\n#include \"memmap.h\"\n\nusing std::string;\n\nbool SplitPath::ext_is(const string &other)\n{\n    if (strcasecmp(ext.c_str(), other.c_str()) == 0)\n        return true;\n    if (other[0] != '.' && (strcasecmp(other.c_str(), &(ext.c_str()[1])) == 0))\n        return true;\n    return false;\n}\n\nstd::string makepath(const SplitPath &path)\n{\n    return makepath(path.drive, path.dir, path.stem, path.ext);\n}\n\nstd::string S9xGetFilename(string filename, string ext, enum s9x_getdirtype dirtype)\n{\n    auto path = splitpath(filename);\n    auto dir  = S9xGetDirectory(dirtype);\n    return makepath(path.drive, dir, path.stem, ext);\n}\n\nstd::string S9xGetFilename(string ext, enum s9x_getdirtype dirtype)\n{\n    return S9xGetFilename(Memory.ROMFilename, ext, dirtype);\n}\n\nstd::string S9xBasename(std::string filename)\n{\n    auto path = splitpath(filename);\n    return path.stem + path.ext;\n}\n\nstd::string S9xBasenameNoExt(std::string filename)\n{\n    return splitpath(filename).stem;\n}\n\n#if __cplusplus >= 201703L && 0\n#include <filesystem>\nnamespace fs = std::filesystem;\n\nSplitPath splitpath(string str)\n{\n    SplitPath output{};\n    fs::path path(str);\n\n    if (path.has_root_name())\n        output.drive = path.root_name().string();\n\n    if (path.has_filename())\n    {\n        output.stem = path.stem().string();\n        output.ext  = path.extension().string();\n        path.remove_filename();\n    }\n\n    if (!path.empty())\n        output.dir = path.string();\n\n    return output;\n}\n\nstring makepath(const string &drive, const string &dir, const string &stem, const string &ext)\n{\n    auto dot_position = ext.find('.');\n\n    if (dot_position == string::npos)\n    {\n        fs::path path(drive);\n        path = path / dir / stem;\n        path.replace_extension(ext);\n        return path.string();\n    }\n\n    auto filename = stem + ext;\n    fs::path path(drive);\n    path = path / dir / filename;\n    return path.string();\n}\n\n#else\nconstexpr auto npos = std::string::npos;\n\nSplitPath splitpath(string path)\n{\n    SplitPath output{};\n\n#ifdef _WIN32\n    if (path.length() > 2 && path[1] == ':')\n    {\n        output.drive = path.substr(0, 2);\n        path = path.substr(2);\n    }\n#endif\n    auto backslash = path.rfind('\\\\');\n    auto slash = path.rfind('/');\n    if (backslash != npos)\n    {\n        if (slash == npos || backslash > slash)\n            slash = backslash;\n    }\n    else if (slash != npos)\n    {\n        if (backslash != npos && backslash > slash)\n            slash = backslash;\n    }\n    auto dot = path.rfind('.');\n\n    if (dot != npos && slash != npos && dot < slash)\n    {\n        dot = npos;\n    }\n    else if (dot != npos)\n    {\n        output.ext = path.substr(dot);\n    }\n\n    if (slash != npos)\n    {\n        output.dir = path.substr(0, slash + 1);\n        output.stem = path.substr(slash + 1, dot - slash - 1);\n    }\n    else\n    {\n        output.stem = path.substr(0, dot);\n    }\n\n    return output;\n}\n\nstring makepath(const string &drive, const string &dir, const string &stem, const string &ext)\n{\n    string output;\n\n    if (!drive.empty())\n    {\n        if (!(dir.length() > 2 && dir[1] == ':'))\n        {\n            output += drive + \":\";\n            if (!dir.empty() && dir[0] != SLASH_CHAR)\n                output += SLASH_CHAR;\n        }\n    }\n\n    if (!dir.empty())\n    {\n        output += dir;\n        if (output[output.length() - 1] != SLASH_CHAR)\n            output += SLASH_CHAR;\n    }\n\n    if (!stem.empty())\n    {\n        output += stem;\n    }\n\n    if (!ext.empty())\n    {\n        if (ext.find('.') == string::npos)\n            output += '.';\n        output += ext;\n    }\n\n    return output;\n}\n\n#ifndef _WIN32\nvoid _splitpath(const char *path, char *drive, char *dir, char *fname, char *ext)\n{\n    char *slash = strrchr((char *)path, SLASH_CHAR);\n    char *dot = strrchr((char *)path, '.');\n\n    *drive = '\\0';\n\n    if (dot && slash && dot < slash)\n    {\n        dot = 0;\n    }\n\n    if (!slash)\n    {\n        *dir = '\\0';\n        strcpy(fname, path);\n\n        if (dot)\n        {\n            fname[dot - path] = '\\0';\n            strcpy(ext, dot + 1);\n        }\n        else\n        {\n            *ext = '\\0';\n        }\n    }\n    else\n    {\n        strcpy(dir, path);\n        dir[slash - path] = '\\0';\n        strcpy(fname, slash + 1);\n\n        if (dot)\n        {\n            fname[(dot - slash) - 1] = '\\0';\n            strcpy(ext, dot + 1);\n        }\n        else\n        {\n            *ext = '\\0';\n        }\n    }\n}\n\nvoid _makepath(char *path, const char *drive, const char *dir, const char *fname, const char *ext)\n{\n    if (dir && *dir)\n    {\n        strcpy(path, dir);\n        strcat(path, \"/\");\n    }\n    else\n        *path = '\\0';\n\n    strcat(path, fname);\n\n    if (ext && *ext)\n    {\n        if (!strchr(ext, '.'))\n            strcat(path, \".\");\n        strcat(path, ext);\n    }\n}\n#endif\n#endif"
        },
        {
          "name": "fscompat.h",
          "type": "blob",
          "size": 1.4072265625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#pragma once\n\n#ifdef __cplusplus\n#include <string>\n\nenum s9x_getdirtype\n{\n\tDEFAULT_DIR = 0,\n\tHOME_DIR,\n\tROMFILENAME_DIR,\n\tROM_DIR,\n\tSRAM_DIR,\n\tSNAPSHOT_DIR,\n\tSCREENSHOT_DIR,\n\tSPC_DIR,\n\tCHEAT_DIR,\n\tPATCH_DIR,\n\tBIOS_DIR,\n\tLOG_DIR,\n\tSAT_DIR,\n\tLAST_DIR\n};\n\nstruct SplitPath\n{\n   bool ext_is(const std::string &ext);\n    std::string drive;\n    std::string dir;\n    std::string stem;\n    std::string ext;\n};\n\nSplitPath splitpath(std::string filename);\nstd::string makepath(const std::string &drive, \n                     const std::string &directory, \n                     const std::string &stem, \n                     const std::string &extension);\nstd::string makepath(const SplitPath &);\n\nstd::string S9xBasename (std::string);\nstd::string S9xBasenameNoExt (std::string);\nstd::string S9xGetFilename (std::string ext, enum s9x_getdirtype dirtype);\nstd::string S9xGetFilename (std::string filename, std::string ext, enum s9x_getdirtype dirtype);\nstd::string S9xGetDirectory (enum s9x_getdirtype);\nstd::string S9xGetFilenameInc (std::string, enum s9x_getdirtype);\n#endif\n"
        },
        {
          "name": "fxdbg.cpp",
          "type": "blob",
          "size": 16.74609375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifdef DEBUGGER\n\n#include \"snes9x.h\"\n#include \"fxinst.h\"\n#include \"fxemu.h\"\n\n/*\n  When printing a line from the pipe, it could look like this:\n\n  01:8006 f4 fb 86 iwt r4, #$86fb\n\n  The values are:\n  program bank                  : 01\n  adress                        : 8006\n  values at memory address 8006 : f4 fb 86\n  instruction in the pipe       : iwt r4, #$86fb\n\n  Note! If the instruction has more than one byte (like in 'iwt') and the instruction is in a delay slot,\n  the second and third byte displayed will not be the same as those used.\n  Since the instrction is in a delay slot,\n  the first byte of the instruction will be taken from the pipe at the address after the branch instruction,\n  and the next one or two bytes will be taken from the address that the branch points to.\n  This is a bit complicated, but I've taken this into account, in this debug function.\n  (See the diffrence of how the values vPipe1 and vPipe2 are read, compared to the values vByte1 and vByte2)\n*/\n\n/*\nstatic const char\t*fx_apvMnemonicTable[] =\n{\n\t// ALT0 Table\n\n\t// 00 - 0f\n\t\"stop\",\n\t\"nop\",\n\t\"cache\",\n\t\"lsr\",\n\t\"rol\",\n\t\"bra $%04x\",\n\t\"blt $%04x\",\n\t\"bge $%04x\",\n\t\"bne $%04x\",\n\t\"beq $%04x\",\n\t\"bpl $%04x\",\n\t\"bmi $%04x\",\n\t\"bcc $%04x\",\n\t\"bcs $%04x\",\n\t\"bvc $%04x\",\n\t\"bvs $%04x\",\n\n\t// 10 - 1f\n\t\"to r0\",\n\t\"to r1\",\n\t\"to r2\",\n\t\"to r3\",\n\t\"to r4\",\n\t\"to r5\",\n\t\"to r6\",\n\t\"to r7\",\n\t\"to r8\",\n\t\"to r9\",\n\t\"to r10\",\n\t\"to r11\",\n\t\"to r12\",\n\t\"to r13\",\n\t\"to r14\",\n\t\"to r15\",\n\n\t// 20 - 2f\n\t\"with r0\",\n\t\"with r1\",\n\t\"with r2\",\n\t\"with r3\",\n\t\"with r4\",\n\t\"with r5\",\n\t\"with r6\",\n\t\"with r7\",\n\t\"with r8\",\n\t\"with r9\",\n\t\"with r10\",\n\t\"with r11\",\n\t\"with r12\",\n\t\"with r13\",\n\t\"with r14\",\n\t\"with r15\",\n\n\t// 30 - 3f\n\t\"stw (r0)\",\n\t\"stw (r1)\",\n\t\"stw (r2)\",\n\t\"stw (r3)\",\n\t\"stw (r4)\",\n\t\"stw (r5)\",\n\t\"stw (r6)\",\n\t\"stw (r7)\",\n\t\"stw (r8)\",\n\t\"stw (r9)\",\n\t\"stw (r10)\",\n\t\"stw (r11)\",\n\t\"loop\",\n\t\"alt1\",\n\t\"alt2\",\n\t\"alt3\",\n\n\t// 40 - 4f\n\t\"ldw (r0)\",\n\t\"ldw (r1)\",\n\t\"ldw (r2)\",\n\t\"ldw (r3)\",\n\t\"ldw (r4)\",\n\t\"ldw (r5)\",\n\t\"ldw (r6)\",\n\t\"ldw (r7)\",\n\t\"ldw (r8)\",\n\t\"ldw (r9)\",\n\t\"ldw (r10)\",\n\t\"ldw (r11)\",\n\t\"plot\",\n\t\"swap\",\n\t\"color\",\n\t\"not\",\n\n\t// 50 - 5f\n\t\"add r0\",\n\t\"add r1\",\n\t\"add r2\",\n\t\"add r3\",\n\t\"add r4\",\n\t\"add r5\",\n\t\"add r6\",\n\t\"add r7\",\n\t\"add r8\",\n\t\"add r9\",\n\t\"add r10\",\n\t\"add r11\",\n\t\"add r12\",\n\t\"add r13\",\n\t\"add r14\",\n\t\"add r15\",\n\n\t// 60 - 6f\n\t\"sub r0\",\n\t\"sub r1\",\n\t\"sub r2\",\n\t\"sub r3\",\n\t\"sub r4\",\n\t\"sub r5\",\n\t\"sub r6\",\n\t\"sub r7\",\n\t\"sub r8\",\n\t\"sub r9\",\n\t\"sub r10\",\n\t\"sub r11\",\n\t\"sub r12\",\n\t\"sub r13\",\n\t\"sub r14\",\n\t\"sub r15\",\n\n\t// 70 - 7f\n\t\"merge\",\n\t\"and r1\",\n\t\"and r2\",\n\t\"and r3\",\n\t\"and r4\",\n\t\"and r5\",\n\t\"and r6\",\n\t\"and r7\",\n\t\"and r8\",\n\t\"and r9\",\n\t\"and r10\",\n\t\"and r11\",\n\t\"and r12\",\n\t\"and r13\",\n\t\"and r14\",\n\t\"and r15\",\n\n\t// 80 - 8f\n\t\"mult r0\",\n\t\"mult r1\",\n\t\"mult r2\",\n\t\"mult r3\",\n\t\"mult r4\",\n\t\"mult r5\",\n\t\"mult r6\",\n\t\"mult r7\",\n\t\"mult r8\",\n\t\"mult r9\",\n\t\"mult r10\",\n\t\"mult r11\",\n\t\"mult r12\",\n\t\"mult r13\",\n\t\"mult r14\",\n\t\"mult r15\",\n\n\t// 90 - 9f\n\t\"sbk\",\n\t\"link #1\",\n\t\"link #2\",\n\t\"link #3\",\n\t\"link #4\",\n\t\"sex\",\n\t\"asr\",\n\t\"ror\",\n\t\"jmp (r8)\",\n\t\"jmp (r9)\",\n\t\"jmp (r10)\",\n\t\"jmp (r11)\",\n\t\"jmp (r12)\",\n\t\"jmp (r13)\",\n\t\"lob\",\n\t\"fmult\",\n\n\t// a0 - af\n\t\"ibt r0, #$%02x\",\n\t\"ibt r1, #$%02x\",\n\t\"ibt r2, #$%02x\",\n\t\"ibt r3, #$%02x\",\n\t\"ibt r4, #$%02x\",\n\t\"ibt r5, #$%02x\",\n\t\"ibt r6, #$%02x\",\n\t\"ibt r7, #$%02x\",\n\t\"ibt r8, #$%02x\",\n\t\"ibt r9, #$%02x\",\n\t\"ibt r10, #$%02x\",\n\t\"ibt r11, #$%02x\",\n\t\"ibt r12, #$%02x\",\n\t\"ibt r13, #$%02x\",\n\t\"ibt r14, #$%02x\",\n\t\"ibt r15, #$%02x\",\n\n\t// b0 - bf\n\t\"from r0\",\n\t\"from r1\",\n\t\"from r2\",\n\t\"from r3\",\n\t\"from r4\",\n\t\"from r5\",\n\t\"from r6\",\n\t\"from r7\",\n\t\"from r8\",\n\t\"from r9\",\n\t\"from r10\",\n\t\"from r11\",\n\t\"from r12\",\n\t\"from r13\",\n\t\"from r14\",\n\t\"from r15\",\n\n\t// c0 - cf\n\t\"hib\",\n\t\"or r1\",\n\t\"or r2\",\n\t\"or r3\",\n\t\"or r4\",\n\t\"or r5\",\n\t\"or r6\",\n\t\"or r7\",\n\t\"or r8\",\n\t\"or r9\",\n\t\"or r10\",\n\t\"or r11\",\n\t\"or r12\",\n\t\"or r13\",\n\t\"or r14\",\n\t\"or r15\",\n\n\t// d0 - df\n\t\"inc r0\",\n\t\"inc r1\",\n\t\"inc r2\",\n\t\"inc r3\",\n\t\"inc r4\",\n\t\"inc r5\",\n\t\"inc r6\",\n\t\"inc r7\",\n\t\"inc r8\",\n\t\"inc r9\",\n\t\"inc r10\",\n\t\"inc r11\",\n\t\"inc r12\",\n\t\"inc r13\",\n\t\"inc r14\",\n\t\"getc\",\n\n\t// e0 - ef\n\t\"dec r0\",\n\t\"dec r1\",\n\t\"dec r2\",\n\t\"dec r3\",\n\t\"dec r4\",\n\t\"dec r5\",\n\t\"dec r6\",\n\t\"dec r7\",\n\t\"dec r8\",\n\t\"dec r9\",\n\t\"dec r10\",\n\t\"dec r11\",\n\t\"dec r12\",\n\t\"dec r13\",\n\t\"dec r14\",\n\t\"getb\",\n\n\t// f0 - ff\n\t\"iwt r0, #$%04x\",\n\t\"iwt r1, #$%04x\",\n\t\"iwt r2, #$%04x\",\n\t\"iwt r3, #$%04x\",\n\t\"iwt r4, #$%04x\",\n\t\"iwt r5, #$%04x\",\n\t\"iwt r6, #$%04x\",\n\t\"iwt r7, #$%04x\",\n\t\"iwt r8, #$%04x\",\n\t\"iwt r9, #$%04x\",\n\t\"iwt r10, #$%04x\",\n\t\"iwt r11, #$%04x\",\n\t\"iwt r12, #$%04x\",\n\t\"iwt r13, #$%04x\",\n\t\"iwt r14, #$%04x\",\n\t\"iwt r15, #$%04x\",\n\n\t// ALT1 Table\n\n\t// 00 - 0f\n\t\"stop\",\n\t\"nop\",\n\t\"cache\",\n\t\"lsr\",\n\t\"rol\",\n\t\"bra $%04x\",\n\t\"blt $%04x\",\n\t\"bge $%04x\",\n\t\"bne $%04x\",\n\t\"beq $%04x\",\n\t\"bpl $%04x\",\n\t\"bmi $%04x\",\n\t\"bcc $%04x\",\n\t\"bcs $%04x\",\n\t\"bvc $%04x\",\n\t\"bvs $%04x\",\n\n\t// 10 - 1f\n\t\"to r0\",\n\t\"to r1\",\n\t\"to r2\",\n\t\"to r3\",\n\t\"to r4\",\n\t\"to r5\",\n\t\"to r6\",\n\t\"to r7\",\n\t\"to r8\",\n\t\"to r9\",\n\t\"to r10\",\n\t\"to r11\",\n\t\"to r12\",\n\t\"to r13\",\n\t\"to r14\",\n\t\"to r15\",\n\n\t// 20 - 2f\n\t\"with r0\",\n\t\"with r1\",\n\t\"with r2\",\n\t\"with r3\",\n\t\"with r4\",\n\t\"with r5\",\n\t\"with r6\",\n\t\"with r7\",\n\t\"with r8\",\n\t\"with r9\",\n\t\"with r10\",\n\t\"with r11\",\n\t\"with r12\",\n\t\"with r13\",\n\t\"with r14\",\n\t\"with r15\",\n\n\t// 30 - 3f\n\t\"stb (r0)\",\n\t\"stb (r1)\",\n\t\"stb (r2)\",\n\t\"stb (r3)\",\n\t\"stb (r4)\",\n\t\"stb (r5)\",\n\t\"stb (r6)\",\n\t\"stb (r7)\",\n\t\"stb (r8)\",\n\t\"stb (r9)\",\n\t\"stb (r10)\",\n\t\"stb (r11)\",\n\t\"loop\",\n\t\"alt1\",\n\t\"alt2\",\n\t\"alt3\",\n\n\t// 40 - 4f\n\t\"ldb (r0)\",\n\t\"ldb (r1)\",\n\t\"ldb (r2)\",\n\t\"ldb (r3)\",\n\t\"ldb (r4)\",\n\t\"ldb (r5)\",\n\t\"ldb (r6)\",\n\t\"ldb (r7)\",\n\t\"ldb (r8)\",\n\t\"ldb (r9)\",\n\t\"ldb (r10)\",\n\t\"ldb (r11)\",\n\t\"rpix\",\n\t\"swap\",\n\t\"cmode\",\n\t\"not\",\n\n\t// 50 - 5f\n\t\"adc r0\",\n\t\"adc r1\",\n\t\"adc r2\",\n\t\"adc r3\",\n\t\"adc r4\",\n\t\"adc r5\",\n\t\"adc r6\",\n\t\"adc r7\",\n\t\"adc r8\",\n\t\"adc r9\",\n\t\"adc r10\",\n\t\"adc r11\",\n\t\"adc r12\",\n\t\"adc r13\",\n\t\"adc r14\",\n\t\"adc r15\",\n\n\t// 60 - 6f\n\t\"sbc r0\",\n\t\"sbc r1\",\n\t\"sbc r2\",\n\t\"sbc r3\",\n\t\"sbc r4\",\n\t\"sbc r5\",\n\t\"sbc r6\",\n\t\"sbc r7\",\n\t\"sbc r8\",\n\t\"sbc r9\",\n\t\"sbc r10\",\n\t\"sbc r11\",\n\t\"sbc r12\",\n\t\"sbc r13\",\n\t\"sbc r14\",\n\t\"sbc r15\",\n\n\t// 70 - 7f\n\t\"merge\",\n\t\"bic r1\",\n\t\"bic r2\",\n\t\"bic r3\",\n\t\"bic r4\",\n\t\"bic r5\",\n\t\"bic r6\",\n\t\"bic r7\",\n\t\"bic r8\",\n\t\"bic r9\",\n\t\"bic r10\",\n\t\"bic r11\",\n\t\"bic r12\",\n\t\"bic r13\",\n\t\"bic r14\",\n\t\"bic r15\",\n\n\t// 80 - 8f\n\t\"umult r0\",\n\t\"umult r1\",\n\t\"umult r2\",\n\t\"umult r3\",\n\t\"umult r4\",\n\t\"umult r5\",\n\t\"umult r6\",\n\t\"umult r7\",\n\t\"umult r8\",\n\t\"umult r9\",\n\t\"umult r10\",\n\t\"umult r11\",\n\t\"umult r12\",\n\t\"umult r13\",\n\t\"umult r14\",\n\t\"umult r15\",\n\n\t// 90 - 9f\n\t\"sbk\",\n\t\"link #1\",\n\t\"link #2\",\n\t\"link #3\",\n\t\"link #4\",\n\t\"sex\",\n\t\"div2\",\n\t\"ror\",\n\t\"ljmp (r8)\",\n\t\"ljmp (r9)\",\n\t\"ljmp (r10)\",\n\t\"ljmp (r11)\",\n\t\"ljmp (r12)\",\n\t\"ljmp (r13)\",\n\t\"lob\",\n\t\"lmult\",\n\n\t// a0 - af\n\t\"lms r0, ($%04x)\",\n\t\"lms r1, ($%04x)\",\n\t\"lms r2, ($%04x)\",\n\t\"lms r3, ($%04x)\",\n\t\"lms r4, ($%04x)\",\n\t\"lms r5, ($%04x)\",\n\t\"lms r6, ($%04x)\",\n\t\"lms r7, ($%04x)\",\n\t\"lms r8, ($%04x)\",\n\t\"lms r9, ($%04x)\",\n\t\"lms r10, ($%04x)\",\n\t\"lms r11, ($%04x)\",\n\t\"lms r12, ($%04x)\",\n\t\"lms r13, ($%04x)\",\n\t\"lms r14, ($%04x)\",\n\t\"lms r15, ($%04x)\",\n\n\t// b0 - bf\n\t\"from r0\",\n\t\"from r1\",\n\t\"from r2\",\n\t\"from r3\",\n\t\"from r4\",\n\t\"from r5\",\n\t\"from r6\",\n\t\"from r7\",\n\t\"from r8\",\n\t\"from r9\",\n\t\"from r10\",\n\t\"from r11\",\n\t\"from r12\",\n\t\"from r13\",\n\t\"from r14\",\n\t\"from r15\",\n\n\t// c0 - cf\n\t\"hib\",\n\t\"xor r1\",\n\t\"xor r2\",\n\t\"xor r3\",\n\t\"xor r4\",\n\t\"xor r5\",\n\t\"xor r6\",\n\t\"xor r7\",\n\t\"xor r8\",\n\t\"xor r9\",\n\t\"xor r10\",\n\t\"xor r11\",\n\t\"xor r12\",\n\t\"xor r13\",\n\t\"xor r14\",\n\t\"xor r15\",\n\n\t// d0 - df\n\t\"inc r0\",\n\t\"inc r1\",\n\t\"inc r2\",\n\t\"inc r3\",\n\t\"inc r4\",\n\t\"inc r5\",\n\t\"inc r6\",\n\t\"inc r7\",\n\t\"inc r8\",\n\t\"inc r9\",\n\t\"inc r10\",\n\t\"inc r11\",\n\t\"inc r12\",\n\t\"inc r13\",\n\t\"inc r14\",\n\t\"getc\",\n\n\t// e0 - ef\n\t\"dec r0\",\n\t\"dec r1\",\n\t\"dec r2\",\n\t\"dec r3\",\n\t\"dec r4\",\n\t\"dec r5\",\n\t\"dec r6\",\n\t\"dec r7\",\n\t\"dec r8\",\n\t\"dec r9\",\n\t\"dec r10\",\n\t\"dec r11\",\n\t\"dec r12\",\n\t\"dec r13\",\n\t\"dec r14\",\n\t\"getbh\",\n\n\t// f0 - ff\n\t\"lm r0, ($%04x)\",\n\t\"lm r1, ($%04x)\",\n\t\"lm r2, ($%04x)\",\n\t\"lm r3, ($%04x)\",\n\t\"lm r4, ($%04x)\",\n\t\"lm r5, ($%04x)\",\n\t\"lm r6, ($%04x)\",\n\t\"lm r7, ($%04x)\",\n\t\"lm r8, ($%04x)\",\n\t\"lm r9, ($%04x)\",\n\t\"lm r10, ($%04x)\",\n\t\"lm r11, ($%04x)\",\n\t\"lm r12, ($%04x)\",\n\t\"lm r13, ($%04x)\",\n\t\"lm r14, ($%04x)\",\n\t\"lm r15, ($%04x)\",\n\n\t// ALT2 Table\n\n\t// 00 - 0f\n\t\"stop\",\n\t\"nop\",\n\t\"cache\",\n\t\"lsr\",\n\t\"rol\",\n\t\"bra $%04x\",\n\t\"blt $%04x\",\n\t\"bge $%04x\",\n\t\"bne $%04x\",\n\t\"beq $%04x\",\n\t\"bpl $%04x\",\n\t\"bmi $%04x\",\n\t\"bcc $%04x\",\n\t\"bcs $%04x\",\n\t\"bvc $%04x\",\n\t\"bvs $%04x\",\n\n\t// 10 - 1f\n\t\"to r0\",\n\t\"to r1\",\n\t\"to r2\",\n\t\"to r3\",\n\t\"to r4\",\n\t\"to r5\",\n\t\"to r6\",\n\t\"to r7\",\n\t\"to r8\",\n\t\"to r9\",\n\t\"to r10\",\n\t\"to r11\",\n\t\"to r12\",\n\t\"to r13\",\n\t\"to r14\",\n\t\"to r15\",\n\n\t// 20 - 2f\n\t\"with r0\",\n\t\"with r1\",\n\t\"with r2\",\n\t\"with r3\",\n\t\"with r4\",\n\t\"with r5\",\n\t\"with r6\",\n\t\"with r7\",\n\t\"with r8\",\n\t\"with r9\",\n\t\"with r10\",\n\t\"with r11\",\n\t\"with r12\",\n\t\"with r13\",\n\t\"with r14\",\n\t\"with r15\",\n\n\t// 30 - 3f\n\t\"stw (r0)\",\n\t\"stw (r1)\",\n\t\"stw (r2)\",\n\t\"stw (r3)\",\n\t\"stw (r4)\",\n\t\"stw (r5)\",\n\t\"stw (r6)\",\n\t\"stw (r7)\",\n\t\"stw (r8)\",\n\t\"stw (r9)\",\n\t\"stw (r10)\",\n\t\"stw (r11)\",\n\t\"loop\",\n\t\"alt1\",\n\t\"alt2\",\n\t\"alt3\",\n\n\t// 40 - 4f\n\t\"ldw (r0)\",\n\t\"ldw (r1)\",\n\t\"ldw (r2)\",\n\t\"ldw (r3)\",\n\t\"ldw (r4)\",\n\t\"ldw (r5)\",\n\t\"ldw (r6)\",\n\t\"ldw (r7)\",\n\t\"ldw (r8)\",\n\t\"ldw (r9)\",\n\t\"ldw (r10)\",\n\t\"ldw (r11)\",\n\t\"plot\",\n\t\"swap\",\n\t\"color\",\n\t\"not\",\n\n\t// 50 - 5f\n\t\"add #0\",\n\t\"add #1\",\n\t\"add #2\",\n\t\"add #3\",\n\t\"add #4\",\n\t\"add #5\",\n\t\"add #6\",\n\t\"add #7\",\n\t\"add #8\",\n\t\"add #9\",\n\t\"add #10\",\n\t\"add #11\",\n\t\"add #12\",\n\t\"add #13\",\n\t\"add #14\",\n\t\"add #15\",\n\n\t// 60 - 6f\n\t\"sub #0\",\n\t\"sub #1\",\n\t\"sub #2\",\n\t\"sub #3\",\n\t\"sub #4\",\n\t\"sub #5\",\n\t\"sub #6\",\n\t\"sub #7\",\n\t\"sub #8\",\n\t\"sub #9\",\n\t\"sub #10\",\n\t\"sub #11\",\n\t\"sub #12\",\n\t\"sub #13\",\n\t\"sub #14\",\n\t\"sub #15\",\n\n\t// 70 - 7f\n\t\"merge\",\n\t\"and #1\",\n\t\"and #2\",\n\t\"and #3\",\n\t\"and #4\",\n\t\"and #5\",\n\t\"and #6\",\n\t\"and #7\",\n\t\"and #8\",\n\t\"and #9\",\n\t\"and #10\",\n\t\"and #11\",\n\t\"and #12\",\n\t\"and #13\",\n\t\"and #14\",\n\t\"and #15\",\n\n\t// 80 - 8f\n\t\"mult #0\",\n\t\"mult #1\",\n\t\"mult #2\",\n\t\"mult #3\",\n\t\"mult #4\",\n\t\"mult #5\",\n\t\"mult #6\",\n\t\"mult #7\",\n\t\"mult #8\",\n\t\"mult #9\",\n\t\"mult #10\",\n\t\"mult #11\",\n\t\"mult #12\",\n\t\"mult #13\",\n\t\"mult #14\",\n\t\"mult #15\",\n\n\t// 90 - 9f\n\t\"sbk\",\n\t\"link #1\",\n\t\"link #2\",\n\t\"link #3\",\n\t\"link #4\",\n\t\"sex\",\n\t\"asr\",\n\t\"ror\",\n\t\"jmp (r8)\",\n\t\"jmp (r9)\",\n\t\"jmp (r10)\",\n\t\"jmp (r11)\",\n\t\"jmp (r12)\",\n\t\"jmp (r13)\",\n\t\"lob\",\n\t\"fmult\",\n\n\t// a0 - af\n\t\"sms ($%04x), r0\",\n\t\"sms ($%04x), r1\",\n\t\"sms ($%04x), r2\",\n\t\"sms ($%04x), r3\",\n\t\"sms ($%04x), r4\",\n\t\"sms ($%04x), r5\",\n\t\"sms ($%04x), r6\",\n\t\"sms ($%04x), r7\",\n\t\"sms ($%04x), r8\",\n\t\"sms ($%04x), r9\",\n\t\"sms ($%04x), r10\",\n\t\"sms ($%04x), r11\",\n\t\"sms ($%04x), r12\",\n\t\"sms ($%04x), r13\",\n\t\"sms ($%04x), r14\",\n\t\"sms ($%04x), r15\",\n\n\t// b0 - bf\n\t\"from r0\",\n\t\"from r1\",\n\t\"from r2\",\n\t\"from r3\",\n\t\"from r4\",\n\t\"from r5\",\n\t\"from r6\",\n\t\"from r7\",\n\t\"from r8\",\n\t\"from r9\",\n\t\"from r10\",\n\t\"from r11\",\n\t\"from r12\",\n\t\"from r13\",\n\t\"from r14\",\n\t\"from r15\",\n\n\t// c0 - cf\n\t\"hib\",\n\t\"or #1\",\n\t\"or #2\",\n\t\"or #3\",\n\t\"or #4\",\n\t\"or #5\",\n\t\"or #6\",\n\t\"or #7\",\n\t\"or #8\",\n\t\"or #9\",\n\t\"or #10\",\n\t\"or #11\",\n\t\"or #12\",\n\t\"or #13\",\n\t\"or #14\",\n\t\"or #15\",\n\n\t// d0 - df\n\t\"inc r0\",\n\t\"inc r1\",\n\t\"inc r2\",\n\t\"inc r3\",\n\t\"inc r4\",\n\t\"inc r5\",\n\t\"inc r6\",\n\t\"inc r7\",\n\t\"inc r8\",\n\t\"inc r9\",\n\t\"inc r10\",\n\t\"inc r11\",\n\t\"inc r12\",\n\t\"inc r13\",\n\t\"inc r14\",\n\t\"ramb\",\n\n\t// e0 - ef\n\t\"dec r0\",\n\t\"dec r1\",\n\t\"dec r2\",\n\t\"dec r3\",\n\t\"dec r4\",\n\t\"dec r5\",\n\t\"dec r6\",\n\t\"dec r7\",\n\t\"dec r8\",\n\t\"dec r9\",\n\t\"dec r10\",\n\t\"dec r11\",\n\t\"dec r12\",\n\t\"dec r13\",\n\t\"dec r14\",\n\t\"getbl\",\n\n\t// f0 - ff\n\t\"sm ($%04x), r0\",\n\t\"sm ($%04x), r1\",\n\t\"sm ($%04x), r2\",\n\t\"sm ($%04x), r3\",\n\t\"sm ($%04x), r4\",\n\t\"sm ($%04x), r5\",\n\t\"sm ($%04x), r6\",\n\t\"sm ($%04x), r7\",\n\t\"sm ($%04x), r8\",\n\t\"sm ($%04x), r9\",\n\t\"sm ($%04x), r10\",\n\t\"sm ($%04x), r11\",\n\t\"sm ($%04x), r12\",\n\t\"sm ($%04x), r13\",\n\t\"sm ($%04x), r14\",\n\t\"sm ($%04x), r15\",\n\n\t// ALT3 Table\n\n\t// 00 - 0f\n\t\"stop\",\n\t\"nop\",\n\t\"cache\",\n\t\"lsr\",\n\t\"rol\",\n\t\"bra $%04x\",\n\t\"blt $%04x\",\n\t\"bge $%04x\",\n\t\"bne $%04x\",\n\t\"beq $%04x\",\n\t\"bpl $%04x\",\n\t\"bmi $%04x\",\n\t\"bcc $%04x\",\n\t\"bcs $%04x\",\n\t\"bvc $%04x\",\n\t\"bvs $%04x\",\n\n\t// 10 - 1f\n\t\"to r0\",\n\t\"to r1\",\n\t\"to r2\",\n\t\"to r3\",\n\t\"to r4\",\n\t\"to r5\",\n\t\"to r6\",\n\t\"to r7\",\n\t\"to r8\",\n\t\"to r9\",\n\t\"to r10\",\n\t\"to r11\",\n\t\"to r12\",\n\t\"to r13\",\n\t\"to r14\",\n\t\"to r15\",\n\n\t// 20 - 2f\n\t\"with r0\",\n\t\"with r1\",\n\t\"with r2\",\n\t\"with r3\",\n\t\"with r4\",\n\t\"with r5\",\n\t\"with r6\",\n\t\"with r7\",\n\t\"with r8\",\n\t\"with r9\",\n\t\"with r10\",\n\t\"with r11\",\n\t\"with r12\",\n\t\"with r13\",\n\t\"with r14\",\n\t\"with r15\",\n\n\t// 30 - 3f\n\t\"stb (r0)\",\n\t\"stb (r1)\",\n\t\"stb (r2)\",\n\t\"stb (r3)\",\n\t\"stb (r4)\",\n\t\"stb (r5)\",\n\t\"stb (r6)\",\n\t\"stb (r7)\",\n\t\"stb (r8)\",\n\t\"stb (r9)\",\n\t\"stb (r10)\",\n\t\"stb (r11)\",\n\t\"loop\",\n\t\"alt1\",\n\t\"alt2\",\n\t\"alt3\",\n\n\t// 40 - 4f\n\t\"ldb (r0)\",\n\t\"ldb (r1)\",\n\t\"ldb (r2)\",\n\t\"ldb (r3)\",\n\t\"ldb (r4)\",\n\t\"ldb (r5)\",\n\t\"ldb (r6)\",\n\t\"ldb (r7)\",\n\t\"ldb (r8)\",\n\t\"ldb (r9)\",\n\t\"ldb (r10)\",\n\t\"ldb (r11)\",\n\t\"rpix\",\n\t\"swap\",\n\t\"cmode\",\n\t\"not\",\n\n\t// 50 - 5f\n\t\"adc #0\",\n\t\"adc #1\",\n\t\"adc #2\",\n\t\"adc #3\",\n\t\"adc #4\",\n\t\"adc #5\",\n\t\"adc #6\",\n\t\"adc #7\",\n\t\"adc #8\",\n\t\"adc #9\",\n\t\"adc #10\",\n\t\"adc #11\",\n\t\"adc #12\",\n\t\"adc #13\",\n\t\"adc #14\",\n\t\"adc #15\",\n\n\t// 60 - 6f\n\t\"cmp r0\",\n\t\"cmp r1\",\n\t\"cmp r2\",\n\t\"cmp r3\",\n\t\"cmp r4\",\n\t\"cmp r5\",\n\t\"cmp r6\",\n\t\"cmp r7\",\n\t\"cmp r8\",\n\t\"cmp r9\",\n\t\"cmp r10\",\n\t\"cmp r11\",\n\t\"cmp r12\",\n\t\"cmp r13\",\n\t\"cmp r14\",\n\t\"cmp r15\",\n\n\t// 70 - 7f\n\t\"merge\",\n\t\"bic #1\",\n\t\"bic #2\",\n\t\"bic #3\",\n\t\"bic #4\",\n\t\"bic #5\",\n\t\"bic #6\",\n\t\"bic #7\",\n\t\"bic #8\",\n\t\"bic #9\",\n\t\"bic #10\",\n\t\"bic #11\",\n\t\"bic #12\",\n\t\"bic #13\",\n\t\"bic #14\",\n\t\"bic #15\",\n\n\t// 80 - 8f\n\t\"umult #0\",\n\t\"umult #1\",\n\t\"umult #2\",\n\t\"umult #3\",\n\t\"umult #4\",\n\t\"umult #5\",\n\t\"umult #6\",\n\t\"umult #7\",\n\t\"umult #8\",\n\t\"umult #9\",\n\t\"umult #10\",\n\t\"umult #11\",\n\t\"umult #12\",\n\t\"umult #13\",\n\t\"umult #14\",\n\t\"umult #15\",\n\n\t// 90 - 9f\n\t\"sbk\",\n\t\"link #1\",\n\t\"link #2\",\n\t\"link #3\",\n\t\"link #4\",\n\t\"sex\",\n\t\"div2\",\n\t\"ror\",\n\t\"ljmp (r8)\",\n\t\"ljmp (r9)\",\n\t\"ljmp (r10)\",\n\t\"ljmp (r11)\",\n\t\"ljmp (r12)\",\n\t\"ljmp (r13)\",\n\t\"lob\",\n\t\"lmult\",\n\n\t// a0 - af\n\t\"lms r0, ($%04x)\",\n\t\"lms r1, ($%04x)\",\n\t\"lms r2, ($%04x)\",\n\t\"lms r3, ($%04x)\",\n\t\"lms r4, ($%04x)\",\n\t\"lms r5, ($%04x)\",\n\t\"lms r6, ($%04x)\",\n\t\"lms r7, ($%04x)\",\n\t\"lms r8, ($%04x)\",\n\t\"lms r9, ($%04x)\",\n\t\"lms r10, ($%04x)\",\n\t\"lms r11, ($%04x)\",\n\t\"lms r12, ($%04x)\",\n\t\"lms r13, ($%04x)\",\n\t\"lms r14, ($%04x)\",\n\t\"lms r15, ($%04x)\",\n\n\t// b0 - bf\n\t\"from r0\",\n\t\"from r1\",\n\t\"from r2\",\n\t\"from r3\",\n\t\"from r4\",\n\t\"from r5\",\n\t\"from r6\",\n\t\"from r7\",\n\t\"from r8\",\n\t\"from r9\",\n\t\"from r10\",\n\t\"from r11\",\n\t\"from r12\",\n\t\"from r13\",\n\t\"from r14\",\n\t\"from r15\",\n\n\t// c0 - cf\n\t\"hib\",\n\t\"xor #1\",\n\t\"xor #2\",\n\t\"xor #3\",\n\t\"xor #4\",\n\t\"xor #5\",\n\t\"xor #6\",\n\t\"xor #7\",\n\t\"xor #8\",\n\t\"xor #9\",\n\t\"xor #10\",\n\t\"xor #11\",\n\t\"xor #12\",\n\t\"xor #13\",\n\t\"xor #14\",\n\t\"xor #15\",\n\n\t// d0 - df\n\t\"inc r0\",\n\t\"inc r1\",\n\t\"inc r2\",\n\t\"inc r3\",\n\t\"inc r4\",\n\t\"inc r5\",\n\t\"inc r6\",\n\t\"inc r7\",\n\t\"inc r8\",\n\t\"inc r9\",\n\t\"inc r10\",\n\t\"inc r11\",\n\t\"inc r12\",\n\t\"inc r13\",\n\t\"inc r14\",\n\t\"romb\",\n\n\t// e0 - ef\n\t\"dec r0\",\n\t\"dec r1\",\n\t\"dec r2\",\n\t\"dec r3\",\n\t\"dec r4\",\n\t\"dec r5\",\n\t\"dec r6\",\n\t\"dec r7\",\n\t\"dec r8\",\n\t\"dec r9\",\n\t\"dec r10\",\n\t\"dec r11\",\n\t\"dec r12\",\n\t\"dec r13\",\n\t\"dec r14\",\n\t\"getbs\",\n\n\t// f0 - ff\n\t\"lm r0, ($%04x)\",\n\t\"lm r1, ($%04x)\",\n\t\"lm r2, ($%04x)\",\n\t\"lm r3, ($%04x)\",\n\t\"lm r4, ($%04x)\",\n\t\"lm r5, ($%04x)\",\n\t\"lm r6, ($%04x)\",\n\t\"lm r7, ($%04x)\",\n\t\"lm r8, ($%04x)\",\n\t\"lm r9, ($%04x)\",\n\t\"lm r10, ($%04x)\",\n\t\"lm r11, ($%04x)\",\n\t\"lm r12, ($%04x)\",\n\t\"lm r13, ($%04x)\",\n\t\"lm r14, ($%04x)\",\n\t\"lm r15, ($%04x)\"\n};\n*/\n\n/*\nstatic void FxPipeString (char *pvString)\n{\n\tuint32\t\tvOpcode = (GSU.vStatusReg & 0x300) | ((uint32) PIPE);\n\tconst char\t*m = fx_apvMnemonicTable[vOpcode];\n\tuint8\t\tvPipe1, vPipe2, vByte1, vByte2;\n\tuint8\t\tvPipeBank = GSU.vPipeAdr >> 16;\n\tchar\t\t*p;\n\n\t// The next two bytes after the pipe's address\n\tvPipe1 = GSU.apvRomBank[vPipeBank][USEX16(GSU.vPipeAdr + 1)];\n\tvPipe2 = GSU.apvRomBank[vPipeBank][USEX16(GSU.vPipeAdr + 2)];\n\n\t// The actual next two bytes to be read\n\tvByte1 = PRGBANK(USEX16(R15));\n\tvByte2 = PRGBANK(USEX16(R15 + 1));\n\n\t// Print ROM address of the pipe\n\tsprintf(pvString, \"%02x:%04x %02x       \", USEX8(vPipeBank), USEX16(GSU.vPipeAdr), USEX8(PIPE));\n\tp = &pvString[strlen(pvString)];\n\n\tif (PIPE >= 0x05 && PIPE <= 0x0f)\t\t\t// Check if it's a branch instruction\n\t{\n\t\tsprintf(&pvString[11], \"%02x    \", USEX8(vPipe1));\n\t#ifdef BRANCH_DELAY_RELATIVE\n\t\tsprintf(p, m, USEX16(R15 + SEX8(vByte1) + 1));\n\t#else\n\t\tsprintf(p, m, USEX16(R15 + SEX8(vByte1) - 1));\n\t#endif\n\t}\n\telse\n\tif (PIPE >= 0x10 && PIPE <= 0x1f && TF(B))\t// Check for 'move' instruction\n\t\tsprintf(p, \"move r%d, r%d\", USEX8(PIPE & 0x0f), (uint32) (GSU.pvSreg - GSU.avReg));\n\telse\n\tif (PIPE >= 0xa0 && PIPE <= 0xaf)\t\t\t// Check for 'ibt', 'lms' or 'sms'\n\t{\n\t\tsprintf(&pvString[11], \"%02x    \", USEX8(vPipe1));\n\t\tif ((GSU.vStatusReg & 0x300) == 0x100 || (GSU.vStatusReg & 0x300) == 0x200)\n\t\t\tsprintf(p, m, USEX16(vByte1) << 1);\n\t\telse\n\t\t\tsprintf(p, m, USEX16(vByte1));\n\t}\n\telse\n\tif (PIPE >= 0xb0 && PIPE <= 0xbf && TF(B))\t// Check for 'moves'\n\t\tsprintf(p, \"moves r%d, r%d\", (uint32) (GSU.pvDreg - GSU.avReg), USEX8(PIPE & 0x0f));\n\telse\n\tif (PIPE >= 0xf0)\t\t\t\t\t\t\t// Check for 'iwt', 'lm' or 'sm'\n\t{\n\t\tsprintf(&pvString[11], \"%02x %02x \", USEX8(vPipe1), USEX8(vPipe2));\n\t\tsprintf(p, m, USEX8(vByte1) | (USEX16(vByte2) << 8));\n\t}\n\telse\t\t\t\t\t\t\t\t\t\t// Normal instruction\n\t\tstrcpy(p, m);\n}\n*/\n\n#endif\n"
        },
        {
          "name": "fxemu.cpp",
          "type": "blob",
          "size": 15.4013671875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"fxinst.h\"\n#include \"fxemu.h\"\n\nstatic void FxReset (struct FxInfo_s *);\nstatic void fx_readRegisterSpace (void);\nstatic void fx_writeRegisterSpace (void);\nstatic void fx_updateRamBank (uint8);\nstatic void fx_dirtySCBR (void);\nstatic bool8 fx_checkStartAddress (void);\nstatic uint32 FxEmulate (uint32);\nstatic void FxCacheWriteAccess (uint16);\nstatic void FxFlushCache (void);\n\n\nvoid S9xInitSuperFX (void)\n{\n\tmemset((uint8 *) &GSU, 0, sizeof(struct FxRegs_s));\n}\n\nvoid S9xResetSuperFX (void)\n{\n\t// FIXME: Snes9x only runs the SuperFX at the end of every line.\n\t// 5823405 is a magic number that seems to work for most games.\n\tSuperFX.speedPerLine = (uint32) (5823405 * ((1.0 / (float) Memory.ROMFramesPerSecond) / ((float) (Timings.V_Max))));\n\tSuperFX.oneLineDone = FALSE;\n\tSuperFX.vFlags = 0;\n\tCPU.IRQExternal = FALSE;\n\tFxReset(&SuperFX);\n}\n\nvoid S9xSetSuperFX (uint8 byte, uint16 address)\n{\n\tswitch (address)\n\t{\n\t\tcase 0x3030:\n\t\t\tif ((Memory.FillRAM[0x3030] ^ byte) & FLG_G)\n\t\t\t{\n\t\t\t\tMemory.FillRAM[0x3030] = byte;\n\t\t\t\tif (byte & FLG_G)\n\t\t\t\t{\n\t\t\t\t\tif (!SuperFX.oneLineDone)\n\t\t\t\t\t{\n\t\t\t\t\t\tS9xSuperFXExec();\n\t\t\t\t\t\tSuperFX.oneLineDone = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tFxFlushCache();\n\t\t\t}\n\t\t\telse\n\t\t\t\tMemory.FillRAM[0x3030] = byte;\n\n\t\t\tbreak;\n\n\t\tcase 0x3031:\n\t\t\tMemory.FillRAM[0x3031] = byte;\n\t\t\tbreak;\n\n\t\tcase 0x3033:\n\t\t\tMemory.FillRAM[0x3033] = byte;\n\t\t\tbreak;\n\n\t\tcase 0x3034:\n\t\t\tMemory.FillRAM[0x3034] = byte & 0x7f;\n\t\t\tbreak;\n\n\t\tcase 0x3036:\n\t\t\tMemory.FillRAM[0x3036] = byte & 0x7f;\n\t\t\tbreak;\n\n\t\tcase 0x3037:\n\t\t\tMemory.FillRAM[0x3037] = byte;\n\t\t\tbreak;\n\n\t\tcase 0x3038:\n\t\t\tMemory.FillRAM[0x3038] = byte;\n\t\t\tfx_dirtySCBR();\n\t\t\tbreak;\n\n\t\tcase 0x3039:\n\t\t\tMemory.FillRAM[0x3039] = byte;\n\t\t\tbreak;\n\n\t\tcase 0x303a:\n\t\t\tMemory.FillRAM[0x303a] = byte;\n\t\t\tbreak;\n\n\t\tcase 0x303b:\n\t\t\tbreak;\n\n\t\tcase 0x303c:\n\t\t\tMemory.FillRAM[0x303c] = byte;\n\t\t\tfx_updateRamBank(byte);\n\t\t\tbreak;\n\n\t\tcase 0x303f:\n\t\t\tMemory.FillRAM[0x303f] = byte;\n\t\t\tbreak;\n\n\t\tcase 0x301f:\n\t\t\tMemory.FillRAM[0x301f] = byte;\n\t\t\tMemory.FillRAM[0x3000 + GSU_SFR] |= FLG_G;\n\t\t\tif (!SuperFX.oneLineDone)\n\t\t\t{\n\t\t\t\tS9xSuperFXExec();\n\t\t\t\tSuperFX.oneLineDone = TRUE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tMemory.FillRAM[address] = byte;\n\t\t\tif (address >= 0x3100)\n\t\t\t\tFxCacheWriteAccess(address);\n\n\t\t\tbreak;\n\t}\n}\n\nuint8 S9xGetSuperFX (uint16 address)\n{\n\tuint8\tbyte;\n\n\tbyte = Memory.FillRAM[address];\n\n\tif (address == 0x3031)\n\t{\n\t\tCPU.IRQExternal = FALSE;\n\t\tMemory.FillRAM[0x3031] = byte & 0x7f;\n\t}\n\n\treturn (byte);\n}\n\nvoid S9xSuperFXExec (void)\n{\n\tif ((Memory.FillRAM[0x3000 + GSU_SFR] & FLG_G) && (Memory.FillRAM[0x3000 + GSU_SCMR] & 0x18) != 0)\n\t{\n\t\tFxEmulate(((Memory.FillRAM[0x3000 + GSU_CLSR] & 1) ? (SuperFX.speedPerLine * 5 / 2) : SuperFX.speedPerLine) * Settings.SuperFXClockMultiplier / 100);\n\n\t\tuint16 GSUStatus = Memory.FillRAM[0x3000 + GSU_SFR] | (Memory.FillRAM[0x3000 + GSU_SFR + 1] << 8);\n\t\tif ((GSUStatus & (FLG_G | FLG_IRQ)) == FLG_IRQ)\n\t\t\tCPU.IRQExternal = TRUE;\n\t}\n}\n\nstatic void FxReset (struct FxInfo_s *psFxInfo)\n{\n\t// Clear all internal variables\n\tmemset((uint8 *) &GSU, 0, sizeof(struct FxRegs_s));\n\n\t// Set default registers\n\tGSU.pvSreg = GSU.pvDreg = &R0;\n\n\t// Set RAM and ROM pointers\n\tGSU.pvRegisters       = psFxInfo->pvRegisters;\n\tGSU.nRamBanks         = psFxInfo->nRamBanks;\n\tGSU.pvRam             = psFxInfo->pvRam;\n\tGSU.nRomBanks         = psFxInfo->nRomBanks;\n\tGSU.pvRom             = psFxInfo->pvRom;\n\tGSU.vPrevScreenHeight = ~0;\n\tGSU.vPrevMode         = ~0;\n\n\t// The GSU can't access more than 2mb (16mbits)\n\tif (GSU.nRomBanks > 0x20)\n\t\tGSU.nRomBanks = 0x20;\n\n\t// Clear FxChip register space\n\tmemset(GSU.pvRegisters, 0, 0x300);\n\n\t// Set FxChip version Number\n\tGSU.pvRegisters[0x3b] = 0;\n\n\t// Make ROM bank table\n\tfor (int i = 0; i < 256; i++)\n\t{\n\t\tuint32\tb = i & 0x7f;\n\n\t\tif (b >= 0x40)\n\t\t{\n\t\t\tif (GSU.nRomBanks > 1)\n\t\t\t\tb %= GSU.nRomBanks;\n\t\t\telse\n\t\t\t\tb &= 1;\n\n\t\t\tGSU.apvRomBank[i] = &GSU.pvRom[b << 16];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb %= GSU.nRomBanks * 2;\n\t\t\tGSU.apvRomBank[i] = &GSU.pvRom[(b << 16) + 0x800000];\n\t\t}\n\t}\n\n\t// Make RAM bank table\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tGSU.apvRamBank[i] = &GSU.pvRam[(i % GSU.nRamBanks) << 16];\n\t\tGSU.apvRomBank[0x70 + i] = GSU.apvRamBank[i];\n\t}\n\n\t// Start with a nop in the pipe\n\tGSU.vPipe = 0x01;\n\n\t// Set pointer to GSU cache\n\tGSU.pvCache = &GSU.pvRegisters[0x100];\n\n\tfx_readRegisterSpace();\n}\n\nstatic void fx_readRegisterSpace (void)\n{\n\tstatic const uint32\tavHeight[] = { 128, 160, 192, 256 };\n\tstatic const uint32\tavMult[]   = {  16,  32,  32,  64 };\n\n\tuint8\t*p;\n\tint\t\tn;\n\n\tGSU.vErrorCode = 0;\n\n\t// Update R0-R15\n\tp = GSU.pvRegisters;\n\tfor (int i = 0; i < 16; i++, p += 2)\n\t\tGSU.avReg[i] = (uint32) READ_WORD(p);\n\n\t// Update other registers\n\tp = GSU.pvRegisters;\n\tGSU.vStatusReg     =  (uint32) READ_WORD(&p[GSU_SFR]);\n\tGSU.vPrgBankReg    =  (uint32) p[GSU_PBR];\n\tGSU.vRomBankReg    =  (uint32) p[GSU_ROMBR];\n\tGSU.vRamBankReg    = ((uint32) p[GSU_RAMBR]) & (FX_RAM_BANKS - 1);\n\tGSU.vCacheBaseReg  =  (uint32) p[GSU_CBR];\n\tGSU.vCacheBaseReg |= ((uint32) p[GSU_CBR + 1]) << 8;\n\n\t// Update status register variables\n\tGSU.vZero     = !(GSU.vStatusReg & FLG_Z);\n\tGSU.vSign     =  (GSU.vStatusReg & FLG_S)  << 12;\n\tGSU.vOverflow =  (GSU.vStatusReg & FLG_OV) << 16;\n\tGSU.vCarry    =  (GSU.vStatusReg & FLG_CY) >> 2;\n\n\t// Set bank pointers\n\tGSU.pvRamBank = GSU.apvRamBank[GSU.vRamBankReg & 0x3];\n\tGSU.pvRomBank = GSU.apvRomBank[GSU.vRomBankReg];\n\tGSU.pvPrgBank = GSU.apvRomBank[GSU.vPrgBankReg];\n\n\t// Set screen pointers\n\tGSU.pvScreenBase = &GSU.pvRam[USEX8(p[GSU_SCBR]) << 10];\n\tn  =  (int) (!!(p[GSU_SCMR] & 0x04));\n\tn |= ((int) (!!(p[GSU_SCMR] & 0x20))) << 1;\n\tGSU.vScreenHeight = GSU.vScreenRealHeight = avHeight[n];\n\tGSU.vMode = p[GSU_SCMR] & 0x03;\n\n\tif (n == 3)\n\t\tGSU.vScreenSize = (256 / 8) * (256 / 8) * 32;\n\telse\n\t\tGSU.vScreenSize = (GSU.vScreenHeight / 8) * (256 / 8) * avMult[GSU.vMode];\n\n\tif (GSU.vPlotOptionReg & 0x10) // OBJ Mode (for drawing into sprites)\n\t\tGSU.vScreenHeight = 256;\n\n\tif (GSU.pvScreenBase + GSU.vScreenSize > GSU.pvRam + (GSU.nRamBanks * 65536))\n\t\tGSU.pvScreenBase = GSU.pvRam + (GSU.nRamBanks * 65536) - GSU.vScreenSize;\n\n\tGSU.pfPlot = fx_PlotTable[GSU.vMode];\n\tGSU.pfRpix = fx_PlotTable[GSU.vMode + 5];\n\n\tfx_OpcodeTable[0x04c] = GSU.pfPlot;\n\tfx_OpcodeTable[0x14c] = GSU.pfRpix;\n\tfx_OpcodeTable[0x24c] = GSU.pfPlot;\n\tfx_OpcodeTable[0x34c] = GSU.pfRpix;\n\n\tfx_computeScreenPointers();\n\n\t//fx_backupCache();\n}\n\nstatic void fx_writeRegisterSpace (void)\n{\n\tuint8\t*p;\n\n\tp = GSU.pvRegisters;\n\tfor (int i = 0; i < 16; i++, p += 2)\n\t\tWRITE_WORD(p, GSU.avReg[i]);\n\n\t// Update status register\n\tif (USEX16(GSU.vZero) == 0)\n\t\tSF(Z);\n\telse\n\t\tCF(Z);\n\n\tif (GSU.vSign & 0x8000)\n\t\tSF(S);\n\telse\n\t\tCF(S);\n\n\tif (GSU.vOverflow >= 0x8000 || GSU.vOverflow < -0x8000)\n\t\tSF(OV);\n\telse\n\t\tCF(OV);\n\n\tif (GSU.vCarry)\n\t\tSF(CY);\n\telse\n\t\tCF(CY);\n\n\tp = GSU.pvRegisters;\n\tWRITE_WORD(&p[GSU_SFR], GSU.vStatusReg);\n\tp[GSU_PBR]     = (uint8)  GSU.vPrgBankReg;\n\tp[GSU_ROMBR]   = (uint8)  GSU.vRomBankReg;\n\tp[GSU_RAMBR]   = (uint8)  GSU.vRamBankReg;\n\tWRITE_WORD(&p[GSU_CBR], GSU.vCacheBaseReg);\n\n\t//fx_restoreCache();\n}\n\n// Update RamBankReg and RAM Bank pointer\nstatic void fx_updateRamBank (uint8 byte)\n{\n\t// Update BankReg and Bank pointer\n\tGSU.vRamBankReg = (uint32) byte & (FX_RAM_BANKS - 1);\n\tGSU.pvRamBank = GSU.apvRamBank[byte & 0x3];\n}\n\n// SCBR write seen. We need to update our cached screen pointers\nstatic void fx_dirtySCBR (void)\n{\n\tGSU.vSCBRDirty = TRUE;\n}\n\nstatic bool8 fx_checkStartAddress (void)\n{\n\t// Check if we start inside the cache\n\tif (GSU.bCacheActive && R15 >= GSU.vCacheBaseReg && R15 < (GSU.vCacheBaseReg + 512))\n\t\treturn true;\n\n\n\tif (SCMR & (1 << 4))\n\t{\n\t\tif (GSU.vPrgBankReg <= 0x5f || GSU.vPrgBankReg >= 0x80)\n\t\t\treturn true;\n\t}\n\n\tif (GSU.vPrgBankReg <= 0x7f && (SCMR & (1 << 3)))\n\t\treturn true;\n\n\treturn false;\n}\n\n// Execute until the next stop instruction\nstatic uint32 FxEmulate (uint32 nInstructions)\n{\n\tuint32\tvCount;\n\n\t// Read registers and initialize GSU session\n\tfx_readRegisterSpace();\n\n\t// Check if the start address is valid\n\tif (!fx_checkStartAddress())\n\t{\n\t\tCF(G);\n\t\tfx_writeRegisterSpace();\n\t\t/*\n\t\tGSU.vIllegalAddress = (GSU.vPrgBankReg << 24) | R15;\n\t\treturn (FX_ERROR_ILLEGAL_ADDRESS);\n\t\t*/\n\n\t\treturn (0);\n\t}\n\n\t// Execute GSU session\n\tCF(IRQ);\n\n\t/*\n\tif (GSU.bBreakPoint)\n\t\tvCount = fx_run_to_breakpoint(nInstructions);\n\telse\n\t*/\n\tvCount = fx_run(nInstructions);\n\n\t// Store GSU registers\n\tfx_writeRegisterSpace();\n\n\t// Check for error code\n\tif (GSU.vErrorCode)\n\t\treturn (GSU.vErrorCode);\n\telse\n\t\treturn (vCount);\n}\n\nvoid fx_computeScreenPointers (void)\n{\n\tif (GSU.vMode != GSU.vPrevMode || GSU.vPrevScreenHeight != GSU.vScreenHeight || GSU.vSCBRDirty)\n\t{\n\t\tGSU.vSCBRDirty = FALSE;\n\n\t\t// Make a list of pointers to the start of each screen column\n\t\tswitch (GSU.vScreenHeight)\n\t\t{\n\t\t\tcase 128:\n\t\t\t\tswitch (GSU.vMode)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + (i << 4);\n\t\t\t\t\t\t\tGSU.x[i] = i <<  8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + (i << 5);\n\t\t\t\t\t\t\tGSU.x[i] = i <<  9;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + (i << 6);\n\t\t\t\t\t\t\tGSU.x[i] = i << 10;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 160:\n\t\t\t\tswitch (GSU.vMode)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + (i << 4);\n\t\t\t\t\t\t\tGSU.x[i] = (i <<  8) + (i << 6);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + (i << 5);\n\t\t\t\t\t\t\tGSU.x[i] = (i <<  9) + (i << 7);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + (i << 6);\n\t\t\t\t\t\t\tGSU.x[i] = (i << 10) + (i << 8);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 192:\n\t\t\t\tswitch (GSU.vMode)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + (i << 4);\n\t\t\t\t\t\t\tGSU.x[i] = (i <<  8) + (i << 7);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + (i << 5);\n\t\t\t\t\t\t\tGSU.x[i] = (i <<  9) + (i << 8);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + (i << 6);\n\t\t\t\t\t\t\tGSU.x[i] = (i << 10) + (i << 9);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 256:\n\t\t\t\tswitch (GSU.vMode)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + ((i & 0x10) <<  9) + ((i & 0xf) <<  8);\n\t\t\t\t\t\t\tGSU.x[i] = ((i & 0x10) <<  8) + ((i & 0xf) << 4);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + ((i & 0x10) << 10) + ((i & 0xf) <<  9);\n\t\t\t\t\t\t\tGSU.x[i] = ((i & 0x10) <<  9) + ((i & 0xf) << 5);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tfor (int i = 0; i < 32; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGSU.apvScreen[i] = GSU.pvScreenBase + ((i & 0x10) << 11) + ((i & 0xf) << 10);\n\t\t\t\t\t\t\tGSU.x[i] = ((i & 0x10) << 10) + ((i & 0xf) << 6);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\tGSU.vPrevMode = GSU.vMode;\n\t\tGSU.vPrevScreenHeight = GSU.vScreenHeight;\n\t}\n}\n\n// Write access to the cache\nstatic void FxCacheWriteAccess (uint16 vAddress)\n{\n\t/*\n\tif (!GSU.bCacheActive)\n\t{\n\t\tuint8\tv = GSU.pvCache[GSU.pvCache[vAddress & 0x1ff];\n\t\tfx_setCache();\n\t\tGSU.pvCache[GSU.pvCache[vAddress & 0x1ff] = v;\n\t}\n\t*/\n\n\tif ((vAddress & 0x00f) == 0x00f)\n\t\tGSU.vCacheFlags |= 1 << ((vAddress & 0x1f0) >> 4);\n}\n\nstatic void FxFlushCache (void)\n{\n\tGSU.vCacheFlags = 0;\n\tGSU.vCacheBaseReg = 0;\n\tGSU.bCacheActive = FALSE;\n\t//GSU.vPipe = 0x1;\n}\n\nvoid fx_flushCache (void)\n{\n\t//fx_restoreCache();\n\tGSU.vCacheFlags = 0;\n\tGSU.bCacheActive = FALSE;\n}\n\n/*\nstatic void fx_setCache (void)\n{\n\tuint32\tc;\n\n\tGSU.bCacheActive = TRUE;\n\tGSU.pvRegisters[0x3e] &= 0xf0;\n\n\tc  =  (uint32) GSU.pvRegisters[0x3e];\n\tc |= ((uint32) GSU.pvRegisters[0x3f]) << 8;\n\tif (c == GSU.vCacheBaseReg)\n\t\treturn;\n\n\tGSU.vCacheBaseReg = c;\n\tGSU.vCacheFlags = 0;\n\n\tif (c < (0x10000 - 512))\n\t{\n\t\tconst uint8\t*t = &ROM(c);\n\t\tmemcpy(GSU.pvCache, t, 512);\n\t}\n\telse\n\t{\n\t\tconst uint8\t*t1, *t2;\n\t\tuint32\t\ti = 0x10000 - c;\n\n\t\tt1 = &ROM(c);\n\t\tt2 = &ROM(0);\n\t\tmemcpy(GSU.pvCache, t1, i);\n\t\tmemcpy(&GSU.pvCache[i], t2, 512 - i);\n\t}\n}\n*/\n\n/*\nstatic void fx_backupCache (void)\n{\n\tuint32\tv = GSU.vCacheFlags;\n\tuint32\tc = USEX16(GSU.vCacheBaseReg);\n\n\tif (v)\n\t{\n\t\tfor (int i = 0; i < 32; i++)\n\t\t{\n\t\t\tif (v & 1)\n\t\t\t{\n\t\t\t\tif (c < (0x10000 - 16))\n\t\t\t\t{\n\t\t\t\t\tuint8\t*t = &GSU.pvPrgBank[c];\n\t\t\t\t\tmemcpy(&GSU.avCacheBackup[i << 4], t, 16);\n\t\t\t\t\tmemcpy(t, &GSU.pvCache[i << 4], 16);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tuint8\t*t1, *t2;\n\t\t\t\t\tuint32\ta = 0x10000 - c;\n\n\t\t\t\t\tt1 = &GSU.pvPrgBank[c];\n\t\t\t\t\tt2 = &GSU.pvPrgBank[0];\n\t\t\t\t\tmemcpy(&GSU.avCacheBackup[i << 4], t1, a);\n\t\t\t\t\tmemcpy(t1, &GSU.pvCache[i << 4], a);\n\t\t\t\t\tmemcpy(&GSU.avCacheBackup[(i << 4) + a], t2, 16 - a);\n\t\t\t\t\tmemcpy(t2, &GSU.pvCache[(i << 4) + a], 16 - a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc = USEX16(c + 16);\n\t\t\tv >>= 1;\n\t\t}\n\t}\n}\n*/\n\n/*\nstatic void fx_restoreCache()\n{\n\tuint32\tv = GSU.vCacheFlags;\n\tuint32\tc = USEX16(GSU.vCacheBaseReg);\n\n\tif (v)\n\t{\n\t\tfor (int i = 0; i < 32; i++)\n\t\t{\n\t\t\tif (v & 1)\n\t\t\t{\n\t\t\t\tif (c < (0x10000 - 16))\n\t\t\t\t{\n\t\t\t\t\tuint8\t*t = &GSU.pvPrgBank[c];\n\t\t\t\t\tmemcpy(t, &GSU.avCacheBackup[i << 4], 16);\n\t\t\t\t\tmemcpy(&GSU.pvCache[i << 4], t, 16);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tuint8\t*t1, *t2;\n\t\t\t\t\tuint32\ta = 0x10000 - c;\n\n\t\t\t\t\tt1 = &GSU.pvPrgBank[c];\n\t\t\t\t\tt2 = &GSU.pvPrgBank[0];\n\t\t\t\t\tmemcpy(t1, &GSU.avCacheBackup[i << 4], a);\n\t\t\t\t\tmemcpy(&GSU.pvCache[i << 4], t1, a);\n\t\t\t\t\tmemcpy(t2, &GSU.avCacheBackup[(i << 4) + a], 16 - a);\n\t\t\t\t\tmemcpy(&GSU.pvCache[(i << 4) + a], t2, 16 - a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc = USEX16(c + 16);\n\t\t\tv >>= 1;\n\t\t}\n\t}\n}\n*/\n\n// Breakpoints\n/*\nstatic void FxBreakPointSet (uint32 vAddress)\n{\n\tGSU.bBreakPoint = TRUE;\n\tGSU.vBreakPoint = USEX16(vAddress);\n}\n*/\n\n/*\nstatic void FxBreakPointClear (void)\n{\n\tGSU.bBreakPoint = FALSE;\n}\n*/\n\n// Step by step execution\n/*\nstatic uint32 FxStepOver (uint32 nInstructions)\n{\n\tuint32\tvCount;\n\n\tfx_readRegisterSpace();\n\n\tif (!fx_checkStartAddress())\n\t{\n\t\tCF(G);\n\t#if 0\n\t\tGSU.vIllegalAddress = (GSU.vPrgBankReg << 24) | R15;\n\t\treturn (FX_ERROR_ILLEGAL_ADDRESS);\n\t#else\n\t\treturn (0);\n\t#endif\n\t}\n\n\tif (PIPE >= 0xf0)\n\t\tGSU.vStepPoint = USEX16(R15 + 3);\n\telse\n\tif ((PIPE >= 0x05 && PIPE <= 0x0f) || (PIPE >= 0xa0 && PIPE <= 0xaf))\n\t\tGSU.vStepPoint = USEX16(R15 + 2);\n\telse\n\t\tGSU.vStepPoint = USEX16(R15 + 1);\n\n\tvCount = fx_step_over(nInstructions);\n\n\tfx_writeRegisterSpace();\n\n\tif (GSU.vErrorCode)\n\t\treturn (GSU.vErrorCode);\n\telse\n\t\treturn (vCount);\n}\n*/\n\n// Errors\n/*\nstatic int FxGetErrorCode (void)\n{\n\treturn (GSU.vErrorCode);\n}\n*/\n\n/*\nstatic int FxGetIllegalAddress (void)\n{\n\treturn (GSU.vIllegalAddress);\n}\n*/\n\n// Access to internal registers\n/*\nstatic uint32 FxGetColorRegister (void)\n{\n\treturn (GSU.vColorReg & 0xff);\n}\n*/\n\n/*\nstatic uint32 FxGetPlotOptionRegister (void)\n{\n\treturn (GSU.vPlotOptionReg & 0x1f);\n}\n*/\n\n/*\nstatic uint32 FxGetSourceRegisterIndex (void)\n{\n\treturn (GSU.pvSreg - GSU.avReg);\n}\n*/\n\n/*\nstatic uint32 FxGetDestinationRegisterIndex (void)\n{\n\treturn (GSU.pvDreg - GSU.avReg);\n}\n*/\n\n// Get the byte currently in the pipe\n/*\nstatic uint8 FxPipe (void)\n{\n\treturn (GSU.vPipe);\n}\n*/\n"
        },
        {
          "name": "fxemu.h",
          "type": "blob",
          "size": 1.1865234375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _FXEMU_H_\n#define _FXEMU_H_\n\n#define FX_BREAKPOINT\t\t\t\t(-1)\n#define FX_ERROR_ILLEGAL_ADDRESS\t(-2)\n\n// The FxInfo_s structure, the link between the FxEmulator and the Snes Emulator\nstruct FxInfo_s\n{\n\tuint32\tvFlags;\n\tuint8\t*pvRegisters;\t// 768 bytes located in the memory at address 0x3000\n\tuint32\tnRamBanks;\t\t// Number of 64kb-banks in GSU-RAM/BackupRAM (banks 0x70-0x73)\n\tuint8\t*pvRam;\t\t\t// Pointer to GSU-RAM\n\tuint32\tnRomBanks;\t\t// Number of 32kb-banks in Cart-ROM\n\tuint8\t*pvRom;\t\t\t// Pointer to Cart-ROM\n\tuint32\tspeedPerLine;\n\tbool8\toneLineDone;\n};\n\nextern struct FxInfo_s\tSuperFX;\n\nvoid S9xInitSuperFX (void);\nvoid S9xResetSuperFX (void);\nvoid S9xSuperFXExec (void);\nvoid S9xSetSuperFX (uint8, uint16);\nuint8 S9xGetSuperFX (uint16);\nvoid fx_flushCache (void);\nvoid fx_computeScreenPointers (void);\nuint32 fx_run (uint32);\n\n#endif\n"
        },
        {
          "name": "fxinst.cpp",
          "type": "blob",
          "size": 65.048828125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"fxinst.h\"\n#include \"fxemu.h\"\n\n// Set this define if you wish the plot instruction to check for y-pos limits (I don't think it's nessecary)\n#define CHECK_LIMITS\n\n\n/*\n Codes used:\n   rn   = a GSU register (r0 - r15)\n   #n   = 4 bit immediate value\n   #pp  = 8 bit immediate value\n   (yy) = 8 bit word address (0x0000 - 0x01fe)\n   #xx  = 16 bit immediate value\n   (xx) = 16 bit address (0x0000 - 0xffff)\n*/\n\n// 00 - stop - stop GSU execution (and maybe generate an IRQ)\nstatic void fx_stop (void)\n{\n\tCF(G);\n\tGSU.vCounter = 0;\n\tGSU.vInstCount = GSU.vCounter;\n\n\t// Check if we need to generate an IRQ\n\tif (!(GSU.pvRegisters[GSU_CFGR] & 0x80))\n\t\tSF(IRQ);\n\n\tGSU.vPlotOptionReg = 0;\n\tGSU.vPipe = 1;\n\tCLRFLAGS;\n\tR15++;\n}\n\n// 01 - nop - no operation\nstatic void fx_nop (void)\n{\n\tCLRFLAGS;\n\tR15++;\n}\n\n// 02 - cache - reintialize GSU cache\nstatic void fx_cache (void)\n{\n\tuint32\tc = R15 & 0xfff0;\n\n\tif (GSU.vCacheBaseReg != c || !GSU.bCacheActive)\n\t{\n\t\tfx_flushCache();\n\t\tGSU.vCacheBaseReg = c;\n\t\tGSU.bCacheActive = TRUE;\n\n\t#if 0\n\t\tif (c < (0x10000 - 512))\n\t\t{\n\t\t\tconst uint8\t*t = &ROM(c);\n\t\t\tmemcpy(GSU.pvCache, t, 512);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst uint8\t*t1, t2;\n\t\t\tuint32\ti = 0x10000 - c;\n\t\t\tt1 = &ROM(c);\n\t\t\tt2 = &ROM(0);\n\t\t\tmemcpy(GSU.pvCache, t1, i);\n\t\t\tmemcpy(&GSU.pvCache[i], t2, 512 - i);\n\t\t}\n\t#endif\n\t}\n\n\tCLRFLAGS;\n\tR15++;\n}\n\n// 03 - lsr - logic shift right\nstatic void fx_lsr (void)\n{\n\tuint32\tv;\n\tGSU.vCarry = SREG & 1;\n\tv = USEX16(SREG) >> 1;\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v;\n\tGSU.vZero = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// 04 - rol - rotate left\nstatic void fx_rol (void)\n{\n\tuint32\tv = USEX16((SREG << 1) + GSU.vCarry);\n\tGSU.vCarry = (SREG >> 15) & 1;\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v;\n\tGSU.vZero = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// 05 - bra - branch always\nstatic void fx_bra (void)\n{\n\tuint8\tv = PIPE;\n\tR15++;\n\tFETCHPIPE;\n\tR15 += SEX8(v);\n}\n\n// Branch on condition\n#define\tBRA_COND(cond) \\\n\tuint8 v = PIPE; \\\n\tR15++; \\\n\tFETCHPIPE; \\\n\tif (cond) \\\n\t\tR15 += SEX8(v); \\\n\telse \\\n\t\tR15++\n\n#define TEST_S\t(GSU.vSign & 0x8000)\n#define TEST_Z\t(USEX16(GSU.vZero) == 0)\n#define TEST_OV\t(GSU.vOverflow >= 0x8000 || GSU.vOverflow < -0x8000)\n#define TEST_CY\t(GSU.vCarry & 1)\n\n// 06 - blt - branch on less than\nstatic void fx_blt (void)\n{\n\tBRA_COND((TEST_S != 0) != (TEST_OV != 0));\n}\n\n// 07 - bge - branch on greater or equals\nstatic void fx_bge (void)\n{\n\tBRA_COND((TEST_S != 0) == (TEST_OV != 0));\n}\n\n// 08 - bne - branch on not equal\nstatic void fx_bne (void)\n{\n\tBRA_COND(!TEST_Z);\n}\n\n// 09 - beq - branch on equal\nstatic void fx_beq (void)\n{\n\tBRA_COND(TEST_Z);\n}\n\n// 0a - bpl - branch on plus\nstatic void fx_bpl (void)\n{\n\tBRA_COND(!TEST_S);\n}\n\n// 0b - bmi - branch on minus\nstatic void fx_bmi (void)\n{\n\tBRA_COND(TEST_S);\n}\n\n// 0c - bcc - branch on carry clear\nstatic void fx_bcc (void)\n{\n\tBRA_COND(!TEST_CY);\n}\n\n// 0d - bcs - branch on carry set\nstatic void fx_bcs (void)\n{\n\tBRA_COND(TEST_CY);\n}\n\n// 0e - bvc - branch on overflow clear\nstatic void fx_bvc (void)\n{\n\tBRA_COND(!TEST_OV);\n}\n\n// 0f - bvs - branch on overflow set\nstatic void fx_bvs (void)\n{\n\tBRA_COND(TEST_OV);\n}\n\n// 10-1f - to rn - set register n as destination register\n// 10-1f (B) - move rn - move one register to another (if B flag is set)\n#define FX_TO(reg) \\\n\tif (TF(B)) \\\n\t{ \\\n\t\tGSU.avReg[(reg)] = SREG; \\\n\t\tCLRFLAGS; \\\n\t} \\\n\telse \\\n\t\tGSU.pvDreg = &GSU.avReg[reg]; \\\n\tR15++\n\n#define FX_TO_R14(reg) \\\n\tif (TF(B)) \\\n\t{ \\\n\t\tGSU.avReg[(reg)] = SREG; \\\n\t\tCLRFLAGS; \\\n\t\tREADR14; \\\n\t} \\\n\telse \\\n\t\tGSU.pvDreg = &GSU.avReg[reg]; \\\n\tR15++\n\n#define FX_TO_R15(reg) \\\n\tif (TF(B)) \\\n\t{ \\\n\t\tGSU.avReg[(reg)] = SREG; \\\n\t\tCLRFLAGS; \\\n\t} \\\n\telse \\\n\t{ \\\n\t\tGSU.pvDreg = &GSU.avReg[reg]; \\\n\t\tR15++; \\\n\t}\n\nstatic void fx_to_r0 (void)\n{\n\tFX_TO(0);\n}\n\nstatic void fx_to_r1 (void)\n{\n\tFX_TO(1);\n}\n\nstatic void fx_to_r2 (void)\n{\n\tFX_TO(2);\n}\n\nstatic void fx_to_r3 (void)\n{\n\tFX_TO(3);\n}\n\nstatic void fx_to_r4 (void)\n{\n\tFX_TO(4);\n}\n\nstatic void fx_to_r5 (void)\n{\n\tFX_TO(5);\n}\n\nstatic void fx_to_r6 (void)\n{\n\tFX_TO(6);\n}\n\nstatic void fx_to_r7 (void)\n{\n\tFX_TO(7);\n}\n\nstatic void fx_to_r8 (void)\n{\n\tFX_TO(8);\n}\n\nstatic void fx_to_r9 (void)\n{\n\tFX_TO(9);\n}\n\nstatic void fx_to_r10 (void)\n{\n\tFX_TO(10);\n}\n\nstatic void fx_to_r11 (void)\n{\n\tFX_TO(11);\n}\n\nstatic void fx_to_r12 (void)\n{\n\tFX_TO(12);\n}\n\nstatic void fx_to_r13 (void)\n{\n\tFX_TO(13);\n}\n\nstatic void fx_to_r14 (void)\n{\n\tFX_TO_R14(14);\n}\n\nstatic void fx_to_r15 (void)\n{\n\tFX_TO_R15(15);\n}\n\n// 20-2f - to rn - set register n as source and destination register\n#define FX_WITH(reg) \\\n\tSF(B); \\\n\tGSU.pvSreg = GSU.pvDreg = &GSU.avReg[reg]; \\\n\tR15++\n\nstatic void fx_with_r0 (void)\n{\n\tFX_WITH(0);\n}\n\nstatic void fx_with_r1 (void)\n{\n\tFX_WITH(1);\n}\n\nstatic void fx_with_r2 (void)\n{\n\tFX_WITH(2);\n}\n\nstatic void fx_with_r3 (void)\n{\n\tFX_WITH(3);\n}\n\nstatic void fx_with_r4 (void)\n{\n\tFX_WITH(4);\n}\n\nstatic void fx_with_r5 (void)\n{\n\tFX_WITH(5);\n}\n\nstatic void fx_with_r6 (void)\n{\n\tFX_WITH(6);\n}\n\nstatic void fx_with_r7 (void)\n{\n\tFX_WITH(7);\n}\n\nstatic void fx_with_r8 (void)\n{\n\tFX_WITH(8);\n}\n\nstatic void fx_with_r9 (void)\n{\n\tFX_WITH(9);\n}\n\nstatic void fx_with_r10 (void)\n{\n\tFX_WITH(10);\n}\n\nstatic void fx_with_r11 (void)\n{\n\tFX_WITH(11);\n}\n\nstatic void fx_with_r12 (void)\n{\n\tFX_WITH(12);\n}\n\nstatic void fx_with_r13 (void)\n{\n\tFX_WITH(13);\n}\n\nstatic void fx_with_r14 (void)\n{\n\tFX_WITH(14);\n}\n\nstatic void fx_with_r15 (void)\n{\n\tFX_WITH(15);\n}\n\n// 30-3b - stw (rn) - store word\n#define FX_STW(reg) \\\n\tGSU.vLastRamAdr = GSU.avReg[reg]; \\\n\tRAM(GSU.avReg[reg]) = (uint8) SREG; \\\n\tRAM(GSU.avReg[reg] ^ 1) = (uint8) (SREG >> 8); \\\n\tCLRFLAGS; \\\n\tR15++\n\nstatic void fx_stw_r0 (void)\n{\n\tFX_STW(0);\n}\n\nstatic void fx_stw_r1 (void)\n{\n\tFX_STW(1);\n}\n\nstatic void fx_stw_r2 (void)\n{\n\tFX_STW(2);\n}\n\nstatic void fx_stw_r3 (void)\n{\n\tFX_STW(3);\n}\n\nstatic void fx_stw_r4 (void)\n{\n\tFX_STW(4);\n}\n\nstatic void fx_stw_r5 (void)\n{\n\tFX_STW(5);\n}\n\nstatic void fx_stw_r6 (void)\n{\n\tFX_STW(6);\n}\n\nstatic void fx_stw_r7 (void)\n{\n\tFX_STW(7);\n}\n\nstatic void fx_stw_r8 (void)\n{\n\tFX_STW(8);\n}\n\nstatic void fx_stw_r9 (void)\n{\n\tFX_STW(9);\n}\n\nstatic void fx_stw_r10 (void)\n{\n\tFX_STW(10);\n}\n\nstatic void fx_stw_r11 (void)\n{\n\tFX_STW(11);\n}\n\n// 30-3b (ALT1) - stb (rn) - store byte\n#define FX_STB(reg) \\\n\tGSU.vLastRamAdr = GSU.avReg[reg]; \\\n\tRAM(GSU.avReg[reg]) = (uint8) SREG; \\\n\tCLRFLAGS; \\\n\tR15++\n\nstatic void fx_stb_r0 (void)\n{\n\tFX_STB(0);\n}\n\nstatic void fx_stb_r1 (void)\n{\n\tFX_STB(1);\n}\n\nstatic void fx_stb_r2 (void)\n{\n\tFX_STB(2);\n}\n\nstatic void fx_stb_r3 (void)\n{\n\tFX_STB(3);\n}\n\nstatic void fx_stb_r4 (void)\n{\n\tFX_STB(4);\n}\n\nstatic void fx_stb_r5 (void)\n{\n\tFX_STB(5);\n}\n\nstatic void fx_stb_r6 (void)\n{\n\tFX_STB(6);\n}\n\nstatic void fx_stb_r7 (void)\n{\n\tFX_STB(7);\n}\n\nstatic void fx_stb_r8 (void)\n{\n\tFX_STB(8);\n}\n\nstatic void fx_stb_r9 (void)\n{\n\tFX_STB(9);\n}\n\nstatic void fx_stb_r10 (void)\n{\n\tFX_STB(10);\n}\n\nstatic void fx_stb_r11 (void)\n{\n\tFX_STB(11);\n}\n\n// 3c - loop - decrement loop counter, and branch on not zero\nstatic void fx_loop (void)\n{\n\tGSU.vSign = GSU.vZero = --R12;\n\tif ((uint16) R12 != 0)\n\t\tR15 = R13;\n\telse\n\t\tR15++;\n\tCLRFLAGS;\n}\n\n// 3d - alt1 - set alt1 mode\nstatic void fx_alt1 (void)\n{\n\tSF(ALT1);\n\tCF(B);\n\tR15++;\n}\n\n// 3e - alt2 - set alt2 mode\nstatic void fx_alt2 (void)\n{\n\tSF(ALT2);\n\tCF(B);\n\tR15++;\n}\n\n// 3f - alt3 - set alt3 mode\nstatic void fx_alt3 (void)\n{\n\tSF(ALT1);\n\tSF(ALT2);\n\tCF(B);\n\tR15++;\n}\n\n// 40-4b - ldw (rn) - load word from RAM\n#define FX_LDW(reg) \\\n\tuint32\tv; \\\n\tGSU.vLastRamAdr = GSU.avReg[reg]; \\\n\tv = (uint32) RAM(GSU.avReg[reg]); \\\n\tv |= ((uint32) RAM(GSU.avReg[reg] ^ 1)) << 8; \\\n\tR15++; \\\n\tDREG = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_ldw_r0 (void)\n{\n\tFX_LDW(0);\n}\n\nstatic void fx_ldw_r1 (void)\n{\n\tFX_LDW(1);\n}\n\nstatic void fx_ldw_r2 (void)\n{\n\tFX_LDW(2);\n}\n\nstatic void fx_ldw_r3 (void)\n{\n\tFX_LDW(3);\n}\n\nstatic void fx_ldw_r4 (void)\n{\n\tFX_LDW(4);\n}\n\nstatic void fx_ldw_r5 (void)\n{\n\tFX_LDW(5);\n}\n\nstatic void fx_ldw_r6 (void)\n{\n\tFX_LDW(6);\n}\n\nstatic void fx_ldw_r7 (void)\n{\n\tFX_LDW(7);\n}\n\nstatic void fx_ldw_r8 (void)\n{\n\tFX_LDW(8);\n}\n\nstatic void fx_ldw_r9 (void)\n{\n\tFX_LDW(9);\n}\n\nstatic void fx_ldw_r10 (void)\n{\n\tFX_LDW(10);\n}\n\nstatic void fx_ldw_r11 (void)\n{\n\tFX_LDW(11);\n}\n\n// 40-4b (ALT1) - ldb (rn) - load byte\n#define FX_LDB(reg) \\\n\tuint32\tv; \\\n\tGSU.vLastRamAdr = GSU.avReg[reg]; \\\n\tv = (uint32) RAM(GSU.avReg[reg]); \\\n\tR15++; \\\n\tDREG = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_ldb_r0 (void)\n{\n\tFX_LDB(0);\n}\n\nstatic void fx_ldb_r1 (void)\n{\n\tFX_LDB(1);\n}\n\nstatic void fx_ldb_r2 (void)\n{\n\tFX_LDB(2);\n}\n\nstatic void fx_ldb_r3 (void)\n{\n\tFX_LDB(3);\n}\n\nstatic void fx_ldb_r4 (void)\n{\n\tFX_LDB(4);\n}\n\nstatic void fx_ldb_r5 (void)\n{\n\tFX_LDB(5);\n}\n\nstatic void fx_ldb_r6 (void)\n{\n\tFX_LDB(6);\n}\n\nstatic void fx_ldb_r7 (void)\n{\n\tFX_LDB(7);\n}\n\nstatic void fx_ldb_r8 (void)\n{\n\tFX_LDB(8);\n}\n\nstatic void fx_ldb_r9 (void)\n{\n\tFX_LDB(9);\n}\n\nstatic void fx_ldb_r10 (void)\n{\n\tFX_LDB(10);\n}\n\nstatic void fx_ldb_r11 (void)\n{\n\tFX_LDB(11);\n}\n\n// 4c - plot - plot pixel with R1, R2 as x, y and the color register as the color\nstatic void fx_plot_2bit (void)\n{\n\tuint32\tx = USEX8(R1);\n\tuint32\ty = USEX8(R2);\n\tuint8\t*a;\n\tuint8\tv, c;\n\n\tR15++;\n\tCLRFLAGS;\n\tR1++;\n\n#ifdef CHECK_LIMITS\n\tif (y >= GSU.vScreenHeight)\n\t\treturn;\n#endif\n\n\tif (!(GSU.vPlotOptionReg & 0x01) && !(COLR & 0xf))\n\t\treturn;\n\n\tif (GSU.vPlotOptionReg & 0x02)\n\t\tc = ((x ^ y) & 1) ? (uint8) (GSU.vColorReg >> 4) : (uint8) GSU.vColorReg;\n\telse\n\t\tc = (uint8) GSU.vColorReg;\n\n\ta = GSU.apvScreen[y >> 3] + GSU.x[x >> 3] + ((y & 7) << 1);\n\tv = 128 >> (x & 7);\n\n\tif (c & 0x01)\n\t\ta[0] |=  v;\n\telse\n\t\ta[0] &= ~v;\n\n\tif (c & 0x02)\n\t\ta[1] |=  v;\n\telse\n\t\ta[1] &= ~v;\n}\n\n// 4c (ALT1) - rpix - read color of the pixel with R1, R2 as x, y\nstatic void fx_rpix_2bit (void)\n{\n\tuint32\tx = USEX8(R1);\n\tuint32\ty = USEX8(R2);\n\tuint8\t*a;\n\tuint8\tv;\n\n\tR15++;\n\tCLRFLAGS;\n\n#ifdef CHECK_LIMITS\n\tif (y >= GSU.vScreenHeight)\n\t\treturn;\n#endif\n\n\ta = GSU.apvScreen[y >> 3] + GSU.x[x >> 3] + ((y & 7) << 1);\n\tv = 128 >> (x & 7);\n\n\tDREG = 0;\n\tDREG |= ((uint32) ((a[0] & v) != 0)) << 0;\n\tDREG |= ((uint32) ((a[1] & v) != 0)) << 1;\n\tTESTR14;\n}\n\n// 4c - plot - plot pixel with R1, R2 as x, y and the color register as the color\nstatic void fx_plot_4bit (void)\n{\n\tuint32\tx = USEX8(R1);\n\tuint32\ty = USEX8(R2);\n\tuint8\t*a;\n\tuint8\tv, c;\n\n\tR15++;\n\tCLRFLAGS;\n\tR1++;\n\n#ifdef CHECK_LIMITS\n\tif (y >= GSU.vScreenHeight)\n\t\treturn;\n#endif\n\n\tif (!(GSU.vPlotOptionReg & 0x01) && !(COLR & 0xf))\n\t\treturn;\n\n\tif (GSU.vPlotOptionReg & 0x02)\n\t\tc = ((x ^ y) & 1) ? (uint8) (GSU.vColorReg >> 4) : (uint8) GSU.vColorReg;\n\telse\n\t\tc = (uint8) GSU.vColorReg;\n\n\ta = GSU.apvScreen[y >> 3] + GSU.x[x >> 3] + ((y & 7) << 1);\n\tv = 128 >> (x & 7);\n\n\tif (c & 0x01)\n\t\ta[0x00] |=  v;\n\telse\n\t\ta[0x00] &= ~v;\n\n\tif (c & 0x02)\n\t\ta[0x01] |=  v;\n\telse\n\t\ta[0x01] &= ~v;\n\n\tif (c & 0x04)\n\t\ta[0x10] |=  v;\n\telse\n\t\ta[0x10] &= ~v;\n\n\tif (c & 0x08)\n\t\ta[0x11] |=  v;\n\telse\n\t\ta[0x11] &= ~v;\n}\n\n// 4c (ALT1) - rpix - read color of the pixel with R1, R2 as x, y\nstatic void fx_rpix_4bit (void)\n{\n\tuint32\tx = USEX8(R1);\n\tuint32\ty = USEX8(R2);\n\tuint8\t*a;\n\tuint8\tv;\n\n\tR15++;\n\tCLRFLAGS;\n\n#ifdef CHECK_LIMITS\n\tif (y >= GSU.vScreenHeight)\n\t\treturn;\n#endif\n\n\ta = GSU.apvScreen[y >> 3] + GSU.x[x >> 3] + ((y & 7) << 1);\n\tv = 128 >> (x & 7);\n\n\tDREG = 0;\n\tDREG |= ((uint32) ((a[0x00] & v) != 0)) << 0;\n\tDREG |= ((uint32) ((a[0x01] & v) != 0)) << 1;\n\tDREG |= ((uint32) ((a[0x10] & v) != 0)) << 2;\n\tDREG |= ((uint32) ((a[0x11] & v) != 0)) << 3;\n\tTESTR14;\n}\n\n// 4c - plot - plot pixel with R1, R2 as x, y and the color register as the color\nstatic void fx_plot_8bit (void)\n{\n\tuint32\tx = USEX8(R1);\n\tuint32\ty = USEX8(R2);\n\tuint8\t*a;\n\tuint8\tv, c;\n\n\tR15++;\n\tCLRFLAGS;\n\tR1++;\n\n#ifdef CHECK_LIMITS\n\tif (y >= GSU.vScreenHeight)\n\t\treturn;\n#endif\n\n\tc = (uint8) GSU.vColorReg;\n\tif (!(GSU.vPlotOptionReg & 0x10))\n\t{\n\t\tif (!(GSU.vPlotOptionReg & 0x01) && (!c || ((GSU.vPlotOptionReg & 0x08) && !(c & 0xf))))\n\t\t\treturn;\n\t}\n\telse\n\tif (!(GSU.vPlotOptionReg & 0x01) && !c)\n\t\treturn;\n\n\ta = GSU.apvScreen[y >> 3] + GSU.x[x >> 3] + ((y & 7) << 1);\n\tv = 128 >> (x & 7);\n\n\tif (c & 0x01)\n\t\ta[0x00] |=  v;\n\telse\n\t\ta[0x00] &= ~v;\n\n\tif (c & 0x02)\n\t\ta[0x01] |=  v;\n\telse\n\t\ta[0x01] &= ~v;\n\n\tif (c & 0x04)\n\t\ta[0x10] |=  v;\n\telse\n\t\ta[0x10] &= ~v;\n\n\tif (c & 0x08)\n\t\ta[0x11] |=  v;\n\telse\n\t\ta[0x11] &= ~v;\n\n\tif (c & 0x10)\n\t\ta[0x20] |=  v;\n\telse\n\t\ta[0x20] &= ~v;\n\n\tif (c & 0x20)\n\t\ta[0x21] |=  v;\n\telse\n\t\ta[0x21] &= ~v;\n\n\tif (c & 0x40)\n\t\ta[0x30] |=  v;\n\telse\n\t\ta[0x30] &= ~v;\n\n\tif (c & 0x80)\n\t\ta[0x31] |=  v;\n\telse\n\t\ta[0x31] &= ~v;\n}\n\n// 4c (ALT1) - rpix - read color of the pixel with R1, R2 as x, y\nstatic void fx_rpix_8bit (void)\n{\n\tuint32\tx = USEX8(R1);\n\tuint32\ty = USEX8(R2);\n\tuint8\t*a;\n\tuint8\tv;\n\n\tR15++;\n\tCLRFLAGS;\n\n#ifdef CHECK_LIMITS\n\tif (y >= GSU.vScreenHeight)\n\t\treturn;\n#endif\n\n\ta = GSU.apvScreen[y >> 3] + GSU.x[x >> 3] + ((y & 7) << 1);\n\tv = 128 >> (x & 7);\n\n\tDREG = 0;\n\tDREG |= ((uint32) ((a[0x00] & v) != 0)) << 0;\n\tDREG |= ((uint32) ((a[0x01] & v) != 0)) << 1;\n\tDREG |= ((uint32) ((a[0x10] & v) != 0)) << 2;\n\tDREG |= ((uint32) ((a[0x11] & v) != 0)) << 3;\n\tDREG |= ((uint32) ((a[0x20] & v) != 0)) << 4;\n\tDREG |= ((uint32) ((a[0x21] & v) != 0)) << 5;\n\tDREG |= ((uint32) ((a[0x30] & v) != 0)) << 6;\n\tDREG |= ((uint32) ((a[0x31] & v) != 0)) << 7;\n\tGSU.vZero = DREG;\n\tTESTR14;\n}\n\n// 4c - plot - plot pixel with R1, R2 as x, y and the color register as the color\nstatic void fx_plot_obj (void)\n{\n#ifdef DEBUGGER\n\tfprintf(stderr, \"ERROR fx_plot_obj called\\n\");\n#endif\n}\n\n// 4c (ALT1) - rpix - read color of the pixel with R1, R2 as x, y\nstatic void fx_rpix_obj (void)\n{\n#ifdef DEBUGGER\n\tfprintf(stderr, \"ERROR fx_rpix_obj called\\n\");\n#endif\n}\n\n// 4d - swap - swap upper and lower byte of a register\nstatic void fx_swap (void)\n{\n\tuint8\tc = (uint8) SREG;\n\tuint8\td = (uint8) (SREG >> 8);\n\tuint32\tv = (((uint32) c) << 8) | ((uint32) d);\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v;\n\tGSU.vZero = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// 4e - color - copy source register to color register\nstatic void fx_color (void)\n{\n\tuint8\tc = (uint8) SREG;\n\n\tif (GSU.vPlotOptionReg & 0x04)\n\t\tc = (c & 0xf0) | (c >> 4);\n\tif (GSU.vPlotOptionReg & 0x08)\n\t{\n\t\tGSU.vColorReg &= 0xf0;\n\t\tGSU.vColorReg |= c & 0x0f;\n\t}\n\telse\n\t\tGSU.vColorReg = USEX8(c);\n\n\tCLRFLAGS;\n\tR15++;\n}\n\n// 4e (ALT1) - cmode - set plot option register\nstatic void fx_cmode (void)\n{\n\tGSU.vPlotOptionReg = SREG;\n\n\tif (GSU.vPlotOptionReg & 0x10)\n\t\tGSU.vScreenHeight = 256; // OBJ Mode (for drawing into sprites)\n\telse\n\t\tGSU.vScreenHeight = GSU.vScreenRealHeight;\n\n\tfx_computeScreenPointers();\n\tCLRFLAGS;\n\tR15++;\n}\n\n// 4f - not - perform exclusive exor with 1 on all bits\nstatic void fx_not (void)\n{\n\tuint32\tv = ~SREG;\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v;\n\tGSU.vZero = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// 50-5f - add rn - add, register + register\n#define FX_ADD(reg) \\\n\tint32\ts = SUSEX16(SREG) + SUSEX16(GSU.avReg[reg]); \\\n\tGSU.vCarry = s >= 0x10000; \\\n\tGSU.vOverflow = ~(SREG ^ GSU.avReg[reg]) & (GSU.avReg[reg] ^ s) & 0x8000; \\\n\tGSU.vSign = s; \\\n\tGSU.vZero = s; \\\n\tR15++; \\\n\tDREG = s; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_add_r0 (void)\n{\n\tFX_ADD(0);\n}\n\nstatic void fx_add_r1 (void)\n{\n\tFX_ADD(1);\n}\n\nstatic void fx_add_r2 (void)\n{\n\tFX_ADD(2);\n}\n\nstatic void fx_add_r3 (void)\n{\n\tFX_ADD(3);\n}\n\nstatic void fx_add_r4 (void)\n{\n\tFX_ADD(4);\n}\n\nstatic void fx_add_r5 (void)\n{\n\tFX_ADD(5);\n}\n\nstatic void fx_add_r6 (void)\n{\n\tFX_ADD(6);\n}\n\nstatic void fx_add_r7 (void)\n{\n\tFX_ADD(7);\n}\n\nstatic void fx_add_r8 (void)\n{\n\tFX_ADD(8);\n}\n\nstatic void fx_add_r9 (void)\n{\n\tFX_ADD(9);\n}\n\nstatic void fx_add_r10 (void)\n{\n\tFX_ADD(10);\n}\n\nstatic void fx_add_r11 (void)\n{\n\tFX_ADD(11);\n}\n\nstatic void fx_add_r12 (void)\n{\n\tFX_ADD(12);\n}\n\nstatic void fx_add_r13 (void)\n{\n\tFX_ADD(13);\n}\n\nstatic void fx_add_r14 (void)\n{\n\tFX_ADD(14);\n}\n\nstatic void fx_add_r15 (void)\n{\n\tFX_ADD(15);\n}\n\n// 50-5f (ALT1) - adc rn - add with carry, register + register\n#define FX_ADC(reg) \\\n\tint32\ts = SUSEX16(SREG) + SUSEX16(GSU.avReg[reg]) + SEX16(GSU.vCarry); \\\n\tGSU.vCarry = s >= 0x10000; \\\n\tGSU.vOverflow = ~(SREG ^ GSU.avReg[reg]) & (GSU.avReg[reg] ^ s) & 0x8000; \\\n\tGSU.vSign = s; \\\n\tGSU.vZero = s; \\\n\tR15++; \\\n\tDREG = s; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_adc_r0 (void)\n{\n\tFX_ADC(0);\n}\n\nstatic void fx_adc_r1 (void)\n{\n\tFX_ADC(1);\n}\n\nstatic void fx_adc_r2 (void)\n{\n\tFX_ADC(2);\n}\n\nstatic void fx_adc_r3 (void)\n{\n\tFX_ADC(3);\n}\n\nstatic void fx_adc_r4 (void)\n{\n\tFX_ADC(4);\n}\n\nstatic void fx_adc_r5 (void)\n{\n\tFX_ADC(5);\n}\n\nstatic void fx_adc_r6 (void)\n{\n\tFX_ADC(6);\n}\n\nstatic void fx_adc_r7 (void)\n{\n\tFX_ADC(7);\n}\n\nstatic void fx_adc_r8 (void)\n{\n\tFX_ADC(8);\n}\n\nstatic void fx_adc_r9 (void)\n{\n\tFX_ADC(9);\n}\n\nstatic void fx_adc_r10 (void)\n{\n\tFX_ADC(10);\n}\n\nstatic void fx_adc_r11 (void)\n{\n\tFX_ADC(11);\n}\n\nstatic void fx_adc_r12 (void)\n{\n\tFX_ADC(12);\n}\n\nstatic void fx_adc_r13 (void)\n{\n\tFX_ADC(13);\n}\n\nstatic void fx_adc_r14 (void)\n{\n\tFX_ADC(14);\n}\n\nstatic void fx_adc_r15 (void)\n{\n\tFX_ADC(15);\n}\n\n// 50-5f (ALT2) - add #n - add, register + immediate\n#define FX_ADD_I(imm) \\\n\tint32\ts = SUSEX16(SREG) + imm; \\\n\tGSU.vCarry = s >= 0x10000; \\\n\tGSU.vOverflow = ~(SREG ^ imm) & (imm ^ s) & 0x8000; \\\n\tGSU.vSign = s; \\\n\tGSU.vZero = s; \\\n\tR15++; \\\n\tDREG = s; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_add_i0 (void)\n{\n\tFX_ADD_I(0);\n}\n\nstatic void fx_add_i1 (void)\n{\n\tFX_ADD_I(1);\n}\n\nstatic void fx_add_i2 (void)\n{\n\tFX_ADD_I(2);\n}\n\nstatic void fx_add_i3 (void)\n{\n\tFX_ADD_I(3);\n}\n\nstatic void fx_add_i4 (void)\n{\n\tFX_ADD_I(4);\n}\n\nstatic void fx_add_i5 (void)\n{\n\tFX_ADD_I(5);\n}\n\nstatic void fx_add_i6 (void)\n{\n\tFX_ADD_I(6);\n}\n\nstatic void fx_add_i7 (void)\n{\n\tFX_ADD_I(7);\n}\n\nstatic void fx_add_i8 (void)\n{\n\tFX_ADD_I(8);\n}\n\nstatic void fx_add_i9 (void)\n{\n\tFX_ADD_I(9);\n}\n\nstatic void fx_add_i10 (void)\n{\n\tFX_ADD_I(10);\n}\n\nstatic void fx_add_i11 (void)\n{\n\tFX_ADD_I(11);\n}\n\nstatic void fx_add_i12 (void)\n{\n\tFX_ADD_I(12);\n}\n\nstatic void fx_add_i13 (void)\n{\n\tFX_ADD_I(13);\n}\n\nstatic void fx_add_i14 (void)\n{\n\tFX_ADD_I(14);\n}\n\nstatic void fx_add_i15 (void)\n{\n\tFX_ADD_I(15);\n}\n\n// 50-5f (ALT3) - adc #n - add with carry, register + immediate\n#define FX_ADC_I(imm) \\\n\tint32\ts = SUSEX16(SREG) + imm + SUSEX16(GSU.vCarry); \\\n\tGSU.vCarry = s >= 0x10000; \\\n\tGSU.vOverflow = ~(SREG ^ imm) & (imm ^ s) & 0x8000; \\\n\tGSU.vSign = s; \\\n\tGSU.vZero = s; \\\n\tR15++; \\\n\tDREG = s; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_adc_i0 (void)\n{\n\tFX_ADC_I(0);\n}\n\nstatic void fx_adc_i1 (void)\n{\n\tFX_ADC_I(1);\n}\n\nstatic void fx_adc_i2 (void)\n{\n\tFX_ADC_I(2);\n}\n\nstatic void fx_adc_i3 (void)\n{\n\tFX_ADC_I(3);\n}\n\nstatic void fx_adc_i4 (void)\n{\n\tFX_ADC_I(4);\n}\n\nstatic void fx_adc_i5 (void)\n{\n\tFX_ADC_I(5);\n}\n\nstatic void fx_adc_i6 (void)\n{\n\tFX_ADC_I(6);\n}\n\nstatic void fx_adc_i7 (void)\n{\n\tFX_ADC_I(7);\n}\n\nstatic void fx_adc_i8 (void)\n{\n\tFX_ADC_I(8);\n}\n\nstatic void fx_adc_i9 (void)\n{\n\tFX_ADC_I(9);\n}\n\nstatic void fx_adc_i10 (void)\n{\n\tFX_ADC_I(10);\n}\n\nstatic void fx_adc_i11 (void)\n{\n\tFX_ADC_I(11);\n}\n\nstatic void fx_adc_i12 (void)\n{\n\tFX_ADC_I(12);\n}\n\nstatic void fx_adc_i13 (void)\n{\n\tFX_ADC_I(13);\n}\n\nstatic void fx_adc_i14 (void)\n{\n\tFX_ADC_I(14);\n}\n\nstatic void fx_adc_i15 (void)\n{\n\tFX_ADC_I(15);\n}\n\n// 60-6f - sub rn - subtract, register - register\n#define FX_SUB(reg) \\\n\tint32\ts = SUSEX16(SREG) - SUSEX16(GSU.avReg[reg]); \\\n\tGSU.vCarry = s >= 0; \\\n\tGSU.vOverflow = (SREG ^ GSU.avReg[reg]) & (SREG ^ s) & 0x8000; \\\n\tGSU.vSign = s; \\\n\tGSU.vZero = s; \\\n\tR15++; \\\n\tDREG = s; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_sub_r0 (void)\n{\n\tFX_SUB(0);\n}\n\nstatic void fx_sub_r1 (void)\n{\n\tFX_SUB(1);\n}\n\nstatic void fx_sub_r2 (void)\n{\n\tFX_SUB(2);\n}\n\nstatic void fx_sub_r3 (void)\n{\n\tFX_SUB(3);\n}\n\nstatic void fx_sub_r4 (void)\n{\n\tFX_SUB(4);\n}\n\nstatic void fx_sub_r5 (void)\n{\n\tFX_SUB(5);\n}\n\nstatic void fx_sub_r6 (void)\n{\n\tFX_SUB(6);\n}\n\nstatic void fx_sub_r7 (void)\n{\n\tFX_SUB(7);\n}\n\nstatic void fx_sub_r8 (void)\n{\n\tFX_SUB(8);\n}\n\nstatic void fx_sub_r9 (void)\n{\n\tFX_SUB(9);\n}\n\nstatic void fx_sub_r10 (void)\n{\n\tFX_SUB(10);\n}\n\nstatic void fx_sub_r11 (void)\n{\n\tFX_SUB(11);\n}\n\nstatic void fx_sub_r12 (void)\n{\n\tFX_SUB(12);\n}\n\nstatic void fx_sub_r13 (void)\n{\n\tFX_SUB(13);\n}\n\nstatic void fx_sub_r14 (void)\n{\n\tFX_SUB(14);\n}\n\nstatic void fx_sub_r15 (void)\n{\n\tFX_SUB(15);\n}\n\n// 60-6f (ALT1) - sbc rn - subtract with carry, register - register\n#define FX_SBC(reg) \\\n\tint32\ts = SUSEX16(SREG) - SUSEX16(GSU.avReg[reg]) - (SUSEX16(GSU.vCarry ^ 1)); \\\n\tGSU.vCarry = s >= 0; \\\n\tGSU.vOverflow = (SREG ^ GSU.avReg[reg]) & (SREG ^ s) & 0x8000; \\\n\tGSU.vSign = s; \\\n\tGSU.vZero = s; \\\n\tR15++; \\\n\tDREG = s; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_sbc_r0 (void)\n{\n\tFX_SBC(0);\n}\n\nstatic void fx_sbc_r1 (void)\n{\n\tFX_SBC(1);\n}\n\nstatic void fx_sbc_r2 (void)\n{\n\tFX_SBC(2);\n}\n\nstatic void fx_sbc_r3 (void)\n{\n\tFX_SBC(3);\n}\n\nstatic void fx_sbc_r4 (void)\n{\n\tFX_SBC(4);\n}\n\nstatic void fx_sbc_r5 (void)\n{\n\tFX_SBC(5);\n}\n\nstatic void fx_sbc_r6 (void)\n{\n\tFX_SBC(6);\n}\n\nstatic void fx_sbc_r7 (void)\n{\n\tFX_SBC(7);\n}\n\nstatic void fx_sbc_r8 (void)\n{\n\tFX_SBC(8);\n}\n\nstatic void fx_sbc_r9 (void)\n{\n\tFX_SBC(9);\n}\n\nstatic void fx_sbc_r10 (void)\n{\n\tFX_SBC(10);\n}\n\nstatic void fx_sbc_r11 (void)\n{\n\tFX_SBC(11);\n}\n\nstatic void fx_sbc_r12 (void)\n{\n\tFX_SBC(12);\n}\n\nstatic void fx_sbc_r13 (void)\n{\n\tFX_SBC(13);\n}\n\nstatic void fx_sbc_r14 (void)\n{\n\tFX_SBC(14);\n}\n\nstatic void fx_sbc_r15 (void)\n{\n\tFX_SBC(15);\n}\n\n// 60-6f (ALT2) - sub #n - subtract, register - immediate\n#define FX_SUB_I(imm) \\\n\tint32\ts = SUSEX16(SREG) - imm; \\\n\tGSU.vCarry = s >= 0; \\\n\tGSU.vOverflow = (SREG ^ imm) & (SREG ^ s) & 0x8000; \\\n\tGSU.vSign = s; \\\n\tGSU.vZero = s; \\\n\tR15++; \\\n\tDREG = s; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_sub_i0 (void)\n{\n\tFX_SUB_I(0);\n}\n\nstatic void fx_sub_i1 (void)\n{\n\tFX_SUB_I(1);\n}\n\nstatic void fx_sub_i2 (void)\n{\n\tFX_SUB_I(2);\n}\n\nstatic void fx_sub_i3 (void)\n{\n\tFX_SUB_I(3);\n}\n\nstatic void fx_sub_i4 (void)\n{\n\tFX_SUB_I(4);\n}\n\nstatic void fx_sub_i5 (void)\n{\n\tFX_SUB_I(5);\n}\n\nstatic void fx_sub_i6 (void)\n{\n\tFX_SUB_I(6);\n}\n\nstatic void fx_sub_i7 (void)\n{\n\tFX_SUB_I(7);\n}\n\nstatic void fx_sub_i8 (void)\n{\n\tFX_SUB_I(8);\n}\n\nstatic void fx_sub_i9 (void)\n{\n\tFX_SUB_I(9);\n}\n\nstatic void fx_sub_i10 (void)\n{\n\tFX_SUB_I(10);\n}\n\nstatic void fx_sub_i11 (void)\n{\n\tFX_SUB_I(11);\n}\n\nstatic void fx_sub_i12 (void)\n{\n\tFX_SUB_I(12);\n}\n\nstatic void fx_sub_i13 (void)\n{\n\tFX_SUB_I(13);\n}\n\nstatic void fx_sub_i14 (void)\n{\n\tFX_SUB_I(14);\n}\n\nstatic void fx_sub_i15 (void)\n{\n\tFX_SUB_I(15);\n}\n\n// 60-6f (ALT3) - cmp rn - compare, register, register\n#define FX_CMP(reg) \\\n\tint32\ts = SUSEX16(SREG) - SUSEX16(GSU.avReg[reg]); \\\n\tGSU.vCarry = s >= 0; \\\n\tGSU.vOverflow = (SREG ^ GSU.avReg[reg]) & (SREG ^ s) & 0x8000; \\\n\tGSU.vSign = s; \\\n\tGSU.vZero = s; \\\n\tR15++; \\\n\tCLRFLAGS\n\nstatic void fx_cmp_r0 (void)\n{\n\tFX_CMP(0);\n}\n\nstatic void fx_cmp_r1 (void)\n{\n\tFX_CMP(1);\n}\n\nstatic void fx_cmp_r2 (void)\n{\n\tFX_CMP(2);\n}\n\nstatic void fx_cmp_r3 (void)\n{\n\tFX_CMP(3);\n}\n\nstatic void fx_cmp_r4 (void)\n{\n\tFX_CMP(4);\n}\n\nstatic void fx_cmp_r5 (void)\n{\n\tFX_CMP(5);\n}\n\nstatic void fx_cmp_r6 (void)\n{\n\tFX_CMP(6);\n}\n\nstatic void fx_cmp_r7 (void)\n{\n\tFX_CMP(7);\n}\n\nstatic void fx_cmp_r8 (void)\n{\n\tFX_CMP(8);\n}\n\nstatic void fx_cmp_r9 (void)\n{\n\tFX_CMP(9);\n}\n\nstatic void fx_cmp_r10 (void)\n{\n\tFX_CMP(10);\n}\n\nstatic void fx_cmp_r11 (void)\n{\n\tFX_CMP(11);\n}\n\nstatic void fx_cmp_r12 (void)\n{\n\tFX_CMP(12);\n}\n\nstatic void fx_cmp_r13 (void)\n{\n\tFX_CMP(13);\n}\n\nstatic void fx_cmp_r14 (void)\n{\n\tFX_CMP(14);\n}\n\nstatic void fx_cmp_r15 (void)\n{\n\tFX_CMP(15);\n}\n\n// 70 - merge - R7 as upper byte, R8 as lower byte (used for texture-mapping)\nstatic void fx_merge (void)\n{\n\tuint32\tv = (R7 & 0xff00) | ((R8 & 0xff00) >> 8);\n\tR15++;\n\tDREG = v;\n\tGSU.vOverflow = (v & 0xc0c0) << 16;\n\tGSU.vZero = !(v & 0xf0f0);\n\tGSU.vSign = ((v | (v << 8)) & 0x8000);\n\tGSU.vCarry = (v & 0xe0e0) != 0;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// 71-7f - and rn - reister & register\n#define FX_AND(reg) \\\n\tuint32\tv = SREG & GSU.avReg[reg]; \\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_and_r1 (void)\n{\n\tFX_AND(1);\n}\n\nstatic void fx_and_r2 (void)\n{\n\tFX_AND(2);\n}\n\nstatic void fx_and_r3 (void)\n{\n\tFX_AND(3);\n}\n\nstatic void fx_and_r4 (void)\n{\n\tFX_AND(4);\n}\n\nstatic void fx_and_r5 (void)\n{\n\tFX_AND(5);\n}\n\nstatic void fx_and_r6 (void)\n{\n\tFX_AND(6);\n}\n\nstatic void fx_and_r7 (void)\n{\n\tFX_AND(7);\n}\n\nstatic void fx_and_r8 (void)\n{\n\tFX_AND(8);\n}\n\nstatic void fx_and_r9 (void)\n{\n\tFX_AND(9);\n}\n\nstatic void fx_and_r10 (void)\n{\n\tFX_AND(10);\n}\n\nstatic void fx_and_r11 (void)\n{\n\tFX_AND(11);\n}\n\nstatic void fx_and_r12 (void)\n{\n\tFX_AND(12);\n}\n\nstatic void fx_and_r13 (void)\n{\n\tFX_AND(13);\n}\n\nstatic void fx_and_r14 (void)\n{\n\tFX_AND(14);\n}\n\nstatic void fx_and_r15 (void)\n{\n\tFX_AND(15);\n}\n\n// 71-7f (ALT1) - bic rn - reister & ~register\n#define FX_BIC(reg) \\\n\tuint32\tv = SREG & ~GSU.avReg[reg];\t\\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_bic_r1 (void)\n{\n\tFX_BIC(1);\n}\n\nstatic void fx_bic_r2 (void)\n{\n\tFX_BIC(2);\n}\n\nstatic void fx_bic_r3 (void)\n{\n\tFX_BIC(3);\n}\n\nstatic void fx_bic_r4 (void)\n{\n\tFX_BIC(4);\n}\n\nstatic void fx_bic_r5 (void)\n{\n\tFX_BIC(5);\n}\n\nstatic void fx_bic_r6 (void)\n{\n\tFX_BIC(6);\n}\n\nstatic void fx_bic_r7 (void)\n{\n\tFX_BIC(7);\n}\n\nstatic void fx_bic_r8 (void)\n{\n\tFX_BIC(8);\n}\n\nstatic void fx_bic_r9 (void)\n{\n\tFX_BIC(9);\n}\n\nstatic void fx_bic_r10 (void)\n{\n\tFX_BIC(10);\n}\n\nstatic void fx_bic_r11 (void)\n{\n\tFX_BIC(11);\n}\n\nstatic void fx_bic_r12 (void)\n{\n\tFX_BIC(12);\n}\n\nstatic void fx_bic_r13 (void)\n{\n\tFX_BIC(13);\n}\n\nstatic void fx_bic_r14 (void)\n{\n\tFX_BIC(14);\n}\n\nstatic void fx_bic_r15 (void)\n{\n\tFX_BIC(15);\n}\n\n// 71-7f (ALT2) - and #n - reister & immediate\n#define FX_AND_I(imm) \\\n\tuint32\tv = SREG & imm; \\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_and_i1 (void)\n{\n\tFX_AND_I(1);\n}\n\nstatic void fx_and_i2 (void)\n{\n\tFX_AND_I(2);\n}\n\nstatic void fx_and_i3 (void)\n{\n\tFX_AND_I(3);\n}\n\nstatic void fx_and_i4 (void)\n{\n\tFX_AND_I(4);\n}\n\nstatic void fx_and_i5 (void)\n{\n\tFX_AND_I(5);\n}\n\nstatic void fx_and_i6 (void)\n{\n\tFX_AND_I(6);\n}\n\nstatic void fx_and_i7 (void)\n{\n\tFX_AND_I(7);\n}\n\nstatic void fx_and_i8 (void)\n{\n\tFX_AND_I(8);\n}\n\nstatic void fx_and_i9 (void)\n{\n\tFX_AND_I(9);\n}\n\nstatic void fx_and_i10 (void)\n{\n\tFX_AND_I(10);\n}\n\nstatic void fx_and_i11 (void)\n{\n\tFX_AND_I(11);\n}\n\nstatic void fx_and_i12 (void)\n{\n\tFX_AND_I(12);\n}\n\nstatic void fx_and_i13 (void)\n{\n\tFX_AND_I(13);\n}\n\nstatic void fx_and_i14 (void)\n{\n\tFX_AND_I(14);\n}\n\nstatic void fx_and_i15 (void)\n{\n\tFX_AND_I(15);\n}\n\n// 71-7f (ALT3) - bic #n - reister & ~immediate\n#define FX_BIC_I(imm) \\\n\tuint32\tv = SREG & ~imm; \\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_bic_i1 (void)\n{\n\tFX_BIC_I(1);\n}\n\nstatic void fx_bic_i2 (void)\n{\n\tFX_BIC_I(2);\n}\n\nstatic void fx_bic_i3 (void)\n{\n\tFX_BIC_I(3);\n}\n\nstatic void fx_bic_i4 (void)\n{\n\tFX_BIC_I(4);\n}\n\nstatic void fx_bic_i5 (void)\n{\n\tFX_BIC_I(5);\n}\n\nstatic void fx_bic_i6 (void)\n{\n\tFX_BIC_I(6);\n}\n\nstatic void fx_bic_i7 (void)\n{\n\tFX_BIC_I(7);\n}\n\nstatic void fx_bic_i8 (void)\n{\n\tFX_BIC_I(8);\n}\n\nstatic void fx_bic_i9 (void)\n{\n\tFX_BIC_I(9);\n}\n\nstatic void fx_bic_i10 (void)\n{\n\tFX_BIC_I(10);\n}\n\nstatic void fx_bic_i11 (void)\n{\n\tFX_BIC_I(11);\n}\n\nstatic void fx_bic_i12 (void)\n{\n\tFX_BIC_I(12);\n}\n\nstatic void fx_bic_i13 (void)\n{\n\tFX_BIC_I(13);\n}\n\nstatic void fx_bic_i14 (void)\n{\n\tFX_BIC_I(14);\n}\n\nstatic void fx_bic_i15 (void)\n{\n\tFX_BIC_I(15);\n}\n\n// 80-8f - mult rn - 8 bit to 16 bit signed multiply, register * register\n#define FX_MULT(reg) \\\n\tuint32\tv = (uint32) (SEX8(SREG) * SEX8(GSU.avReg[reg])); \\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_mult_r0 (void)\n{\n\tFX_MULT(0);\n}\n\nstatic void fx_mult_r1 (void)\n{\n\tFX_MULT(1);\n}\n\nstatic void fx_mult_r2 (void)\n{\n\tFX_MULT(2);\n}\n\nstatic void fx_mult_r3 (void)\n{\n\tFX_MULT(3);\n}\n\nstatic void fx_mult_r4 (void)\n{\n\tFX_MULT(4);\n}\n\nstatic void fx_mult_r5 (void)\n{\n\tFX_MULT(5);\n}\n\nstatic void fx_mult_r6 (void)\n{\n\tFX_MULT(6);\n}\n\nstatic void fx_mult_r7 (void)\n{\n\tFX_MULT(7);\n}\n\nstatic void fx_mult_r8 (void)\n{\n\tFX_MULT(8);\n}\n\nstatic void fx_mult_r9 (void)\n{\n\tFX_MULT(9);\n}\n\nstatic void fx_mult_r10 (void)\n{\n\tFX_MULT(10);\n}\n\nstatic void fx_mult_r11 (void)\n{\n\tFX_MULT(11);\n}\n\nstatic void fx_mult_r12 (void)\n{\n\tFX_MULT(12);\n}\n\nstatic void fx_mult_r13 (void)\n{\n\tFX_MULT(13);\n}\n\nstatic void fx_mult_r14 (void)\n{\n\tFX_MULT(14);\n}\n\nstatic void fx_mult_r15 (void)\n{\n\tFX_MULT(15);\n}\n\n// 80-8f (ALT1) - umult rn - 8 bit to 16 bit unsigned multiply, register * register\n#define FX_UMULT(reg) \\\n\tuint32\tv = USEX8(SREG) * USEX8(GSU.avReg[reg]); \\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_umult_r0 (void)\n{\n\tFX_UMULT(0);\n}\n\nstatic void fx_umult_r1 (void)\n{\n\tFX_UMULT(1);\n}\n\nstatic void fx_umult_r2 (void)\n{\n\tFX_UMULT(2);\n}\n\nstatic void fx_umult_r3 (void)\n{\n\tFX_UMULT(3);\n}\n\nstatic void fx_umult_r4 (void)\n{\n\tFX_UMULT(4);\n}\n\nstatic void fx_umult_r5 (void)\n{\n\tFX_UMULT(5);\n}\n\nstatic void fx_umult_r6 (void)\n{\n\tFX_UMULT(6);\n}\n\nstatic void fx_umult_r7 (void)\n{\n\tFX_UMULT(7);\n}\n\nstatic void fx_umult_r8 (void)\n{\n\tFX_UMULT(8);\n}\n\nstatic void fx_umult_r9 (void)\n{\n\tFX_UMULT(9);\n}\n\nstatic void fx_umult_r10 (void)\n{\n\tFX_UMULT(10);\n}\n\nstatic void fx_umult_r11 (void)\n{\n\tFX_UMULT(11);\n}\n\nstatic void fx_umult_r12 (void)\n{\n\tFX_UMULT(12);\n}\n\nstatic void fx_umult_r13 (void)\n{\n\tFX_UMULT(13);\n}\n\nstatic void fx_umult_r14 (void)\n{\n\tFX_UMULT(14);\n}\n\nstatic void fx_umult_r15 (void)\n{\n\tFX_UMULT(15);\n}\n\n// 80-8f (ALT2) - mult #n - 8 bit to 16 bit signed multiply, register * immediate\n#define FX_MULT_I(imm) \\\n\tuint32\tv = (uint32) (SEX8(SREG) * ((int32) imm)); \\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_mult_i0 (void)\n{\n\tFX_MULT_I(0);\n}\n\nstatic void fx_mult_i1 (void)\n{\n\tFX_MULT_I(1);\n}\n\nstatic void fx_mult_i2 (void)\n{\n\tFX_MULT_I(2);\n}\n\nstatic void fx_mult_i3 (void)\n{\n\tFX_MULT_I(3);\n}\n\nstatic void fx_mult_i4 (void)\n{\n\tFX_MULT_I(4);\n}\n\nstatic void fx_mult_i5 (void)\n{\n\tFX_MULT_I(5);\n}\n\nstatic void fx_mult_i6 (void)\n{\n\tFX_MULT_I(6);\n}\n\nstatic void fx_mult_i7 (void)\n{\n\tFX_MULT_I(7);\n}\n\nstatic void fx_mult_i8 (void)\n{\n\tFX_MULT_I(8);\n}\n\nstatic void fx_mult_i9 (void)\n{\n\tFX_MULT_I(9);\n}\n\nstatic void fx_mult_i10 (void)\n{\n\tFX_MULT_I(10);\n}\n\nstatic void fx_mult_i11 (void)\n{\n\tFX_MULT_I(11);\n}\n\nstatic void fx_mult_i12 (void)\n{\n\tFX_MULT_I(12);\n}\n\nstatic void fx_mult_i13 (void)\n{\n\tFX_MULT_I(13);\n}\n\nstatic void fx_mult_i14 (void)\n{\n\tFX_MULT_I(14);\n}\n\nstatic void fx_mult_i15 (void)\n{\n\tFX_MULT_I(15);\n}\n\n// 80-8f (ALT3) - umult #n - 8 bit to 16 bit unsigned multiply, register * immediate\n#define FX_UMULT_I(imm) \\\n\tuint32\tv = USEX8(SREG) * ((uint32) imm); \\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_umult_i0 (void)\n{\n\tFX_UMULT_I(0);\n}\n\nstatic void fx_umult_i1 (void)\n{\n\tFX_UMULT_I(1);\n}\n\nstatic void fx_umult_i2 (void)\n{\n\tFX_UMULT_I(2);\n}\n\nstatic void fx_umult_i3 (void)\n{\n\tFX_UMULT_I(3);\n}\n\nstatic void fx_umult_i4 (void)\n{\n\tFX_UMULT_I(4);\n}\n\nstatic void fx_umult_i5 (void)\n{\n\tFX_UMULT_I(5);\n}\n\nstatic void fx_umult_i6 (void)\n{\n\tFX_UMULT_I(6);\n}\n\nstatic void fx_umult_i7 (void)\n{\n\tFX_UMULT_I(7);\n}\n\nstatic void fx_umult_i8 (void)\n{\n\tFX_UMULT_I(8);\n}\n\nstatic void fx_umult_i9 (void)\n{\n\tFX_UMULT_I(9);\n}\n\nstatic void fx_umult_i10 (void)\n{\n\tFX_UMULT_I(10);\n}\n\nstatic void fx_umult_i11 (void)\n{\n\tFX_UMULT_I(11);\n}\n\nstatic void fx_umult_i12 (void)\n{\n\tFX_UMULT_I(12);\n}\n\nstatic void fx_umult_i13 (void)\n{\n\tFX_UMULT_I(13);\n}\n\nstatic void fx_umult_i14 (void)\n{\n\tFX_UMULT_I(14);\n}\n\nstatic void fx_umult_i15 (void)\n{\n\tFX_UMULT_I(15);\n}\n\n// 90 - sbk - store word to last accessed RAM address\nstatic void fx_sbk (void)\n{\n\tRAM(GSU.vLastRamAdr) = (uint8) SREG;\n\tRAM(GSU.vLastRamAdr ^ 1) = (uint8) (SREG >> 8);\n\tCLRFLAGS;\n\tR15++;\n}\n\n// 91-94 - link #n - R11 = R15 + immediate\n#define FX_LINK_I(lkn) \\\n\tR11 = R15 + lkn; \\\n\tCLRFLAGS; \\\n\tR15++\n\nstatic void fx_link_i1 (void)\n{\n\tFX_LINK_I(1);\n}\n\nstatic void fx_link_i2 (void)\n{\n\tFX_LINK_I(2);\n}\n\nstatic void fx_link_i3 (void)\n{\n\tFX_LINK_I(3);\n}\n\nstatic void fx_link_i4 (void)\n{\n\tFX_LINK_I(4);\n}\n\n// 95 - sex - sign extend 8 bit to 16 bit\nstatic void fx_sex (void)\n{\n\tuint32\tv = (uint32) SEX8(SREG);\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v;\n\tGSU.vZero = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// 96 - asr - aritmetric shift right by one\nstatic void fx_asr (void)\n{\n\tuint32\tv;\n\tGSU.vCarry = SREG & 1;\n\tv = (uint32) (SEX16(SREG) >> 1);\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v;\n\tGSU.vZero = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// 96 (ALT1) - div2 - aritmetric shift right by one\nstatic void fx_div2 (void)\n{\n\tuint32\tv;\n\tint32\ts = SEX16(SREG);\n\tGSU.vCarry = s & 1;\n\tif (s == -1)\n\t\tv = 0;\n\telse\n\t\tv = (uint32) (s >> 1);\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v;\n\tGSU.vZero = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// 97 - ror - rotate right by one\nstatic void fx_ror (void)\n{\n\tuint32\tv = (USEX16(SREG) >> 1) | (GSU.vCarry << 15);\n\tGSU.vCarry = SREG & 1;\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v;\n\tGSU.vZero = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// 98-9d - jmp rn - jump to address of register\n#define FX_JMP(reg) \\\n\tR15 = GSU.avReg[reg]; \\\n\tCLRFLAGS\n\nstatic void fx_jmp_r8 (void)\n{\n\tFX_JMP(8);\n}\n\nstatic void fx_jmp_r9 (void)\n{\n\tFX_JMP(9);\n}\n\nstatic void fx_jmp_r10 (void)\n{\n\tFX_JMP(10);\n}\n\nstatic void fx_jmp_r11 (void)\n{\n\tFX_JMP(11);\n}\n\nstatic void fx_jmp_r12 (void)\n{\n\tFX_JMP(12);\n}\n\nstatic void fx_jmp_r13 (void)\n{\n\tFX_JMP(13);\n}\n\n// 98-9d (ALT1) - ljmp rn - set program bank to source register and jump to address of register\n#define FX_LJMP(reg) \\\n\tGSU.vPrgBankReg = GSU.avReg[reg] & 0x7f; \\\n\tGSU.pvPrgBank = GSU.apvRomBank[GSU.vPrgBankReg]; \\\n\tR15 = SREG; \\\n\tGSU.bCacheActive = FALSE; \\\n\tfx_cache(); \\\n\tR15--\n\nstatic void fx_ljmp_r8 (void)\n{\n\tFX_LJMP(8);\n}\n\nstatic void fx_ljmp_r9 (void)\n{\n\tFX_LJMP(9);\n}\n\nstatic void fx_ljmp_r10 (void)\n{\n\tFX_LJMP(10);\n}\n\nstatic void fx_ljmp_r11 (void)\n{\n\tFX_LJMP(11);\n}\n\nstatic void fx_ljmp_r12 (void)\n{\n\tFX_LJMP(12);\n}\n\nstatic void fx_ljmp_r13 (void)\n{\n\tFX_LJMP(13);\n}\n\n// 9e - lob - set upper byte to zero (keep low byte)\nstatic void fx_lob (void)\n{\n\tuint32\tv = USEX8(SREG);\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v << 8;\n\tGSU.vZero = v << 8;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// 9f - fmult - 16 bit to 32 bit signed multiplication, upper 16 bits only\nstatic void fx_fmult (void)\n{\n\tuint32\tv;\n\tuint32\tc = (uint32) (SEX16(SREG) * SEX16(R6));\n\tv = c >> 16;\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v;\n\tGSU.vZero = v;\n\tGSU.vCarry = (c >> 15) & 1;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// 9f (ALT1) - lmult - 16 bit to 32 bit signed multiplication\nstatic void fx_lmult (void)\n{\n\tuint32\tv;\n\tuint32\tc = (uint32) (SEX16(SREG) * SEX16(R6));\n\tR4 = c;\n\tv = c >> 16;\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v;\n\tGSU.vZero = v;\n\t// XXX: R6 or R4?\n\tGSU.vCarry = (R4 >> 15) & 1; // should it be bit 15 of R4 instead ?\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// a0-af - ibt rn, #pp - immediate byte transfer\n#define FX_IBT(reg) \\\n\tuint8\tv = PIPE; \\\n\tR15++; \\\n\tFETCHPIPE; \\\n\tR15++; \\\n\tGSU.avReg[reg] = SEX8(v); \\\n\tCLRFLAGS\n\nstatic void fx_ibt_r0 (void)\n{\n\tFX_IBT(0);\n}\n\nstatic void fx_ibt_r1 (void)\n{\n\tFX_IBT(1);\n}\n\nstatic void fx_ibt_r2 (void)\n{\n\tFX_IBT(2);\n}\n\nstatic void fx_ibt_r3 (void)\n{\n\tFX_IBT(3);\n}\n\nstatic void fx_ibt_r4 (void)\n{\n\tFX_IBT(4);\n}\n\nstatic void fx_ibt_r5 (void)\n{\n\tFX_IBT(5);\n}\n\nstatic void fx_ibt_r6 (void)\n{\n\tFX_IBT(6);\n}\n\nstatic void fx_ibt_r7 (void)\n{\n\tFX_IBT(7);\n}\n\nstatic void fx_ibt_r8 (void)\n{\n\tFX_IBT(8);\n}\n\nstatic void fx_ibt_r9 (void)\n{\n\tFX_IBT(9);\n}\n\nstatic void fx_ibt_r10 (void)\n{\n\tFX_IBT(10);\n}\n\nstatic void fx_ibt_r11 (void)\n{\n\tFX_IBT(11);\n}\n\nstatic void fx_ibt_r12 (void)\n{\n\tFX_IBT(12);\n}\n\nstatic void fx_ibt_r13 (void)\n{\n\tFX_IBT(13);\n}\n\nstatic void fx_ibt_r14 (void)\n{\n\tFX_IBT(14);\n\tREADR14;\n}\n\nstatic void fx_ibt_r15 (void)\n{\n\tFX_IBT(15);\n}\n\n// a0-af (ALT1) - lms rn, (yy) - load word from RAM (short address)\n#define FX_LMS(reg) \\\n\tGSU.vLastRamAdr = ((uint32) PIPE) << 1; \\\n\tR15++; \\\n\tFETCHPIPE; \\\n\tR15++; \\\n\tGSU.avReg[reg] = (uint32) RAM(GSU.vLastRamAdr); \\\n\tGSU.avReg[reg] |= ((uint32) RAM(GSU.vLastRamAdr + 1)) << 8; \\\n\tCLRFLAGS\n\nstatic void fx_lms_r0 (void)\n{\n\tFX_LMS(0);\n}\n\nstatic void fx_lms_r1 (void)\n{\n\tFX_LMS(1);\n}\n\nstatic void fx_lms_r2 (void)\n{\n\tFX_LMS(2);\n}\n\nstatic void fx_lms_r3 (void)\n{\n\tFX_LMS(3);\n}\n\nstatic void fx_lms_r4 (void)\n{\n\tFX_LMS(4);\n}\n\nstatic void fx_lms_r5 (void)\n{\n\tFX_LMS(5);\n}\n\nstatic void fx_lms_r6 (void)\n{\n\tFX_LMS(6);\n}\n\nstatic void fx_lms_r7 (void)\n{\n\tFX_LMS(7);\n}\n\nstatic void fx_lms_r8 (void)\n{\n\tFX_LMS(8);\n}\n\nstatic void fx_lms_r9 (void)\n{\n\tFX_LMS(9);\n}\n\nstatic void fx_lms_r10 (void)\n{\n\tFX_LMS(10);\n}\n\nstatic void fx_lms_r11 (void)\n{\n\tFX_LMS(11);\n}\n\nstatic void fx_lms_r12 (void)\n{\n\tFX_LMS(12);\n}\n\nstatic void fx_lms_r13 (void)\n{\n\tFX_LMS(13);\n}\n\nstatic void fx_lms_r14 (void)\n{\n\tFX_LMS(14);\n\tREADR14;\n}\n\nstatic void fx_lms_r15 (void)\n{\n\tFX_LMS(15);\n}\n\n// a0-af (ALT2) - sms (yy), rn - store word in RAM (short address)\n// XXX: If rn == r15, is the value of r15 before or after the extra byte is read ?\n#define FX_SMS(reg) \\\n\tuint32\tv = GSU.avReg[reg]; \\\n\tGSU.vLastRamAdr = ((uint32) PIPE) << 1; \\\n\tR15++; \\\n\tFETCHPIPE; \\\n\tRAM(GSU.vLastRamAdr) = (uint8) v; \\\n\tRAM(GSU.vLastRamAdr + 1) = (uint8) (v >> 8); \\\n\tCLRFLAGS; \\\n\tR15++\n\nstatic void fx_sms_r0 (void)\n{\n\tFX_SMS(0);\n}\n\nstatic void fx_sms_r1 (void)\n{\n\tFX_SMS(1);\n}\n\nstatic void fx_sms_r2 (void)\n{\n\tFX_SMS(2);\n}\n\nstatic void fx_sms_r3 (void)\n{\n\tFX_SMS(3);\n}\n\nstatic void fx_sms_r4 (void)\n{\n\tFX_SMS(4);\n}\n\nstatic void fx_sms_r5 (void)\n{\n\tFX_SMS(5);\n}\n\nstatic void fx_sms_r6 (void)\n{\n\tFX_SMS(6);\n}\n\nstatic void fx_sms_r7 (void)\n{\n\tFX_SMS(7);\n}\n\nstatic void fx_sms_r8 (void)\n{\n\tFX_SMS(8);\n}\n\nstatic void fx_sms_r9 (void)\n{\n\tFX_SMS(9);\n}\n\nstatic void fx_sms_r10 (void)\n{\n\tFX_SMS(10);\n}\n\nstatic void fx_sms_r11 (void)\n{\n\tFX_SMS(11);\n}\n\nstatic void fx_sms_r12 (void)\n{\n\tFX_SMS(12);\n}\n\nstatic void fx_sms_r13 (void)\n{\n\tFX_SMS(13);\n}\n\nstatic void fx_sms_r14 (void)\n{\n\tFX_SMS(14);\n}\n\nstatic void fx_sms_r15 (void)\n{\n\tFX_SMS(15);\n}\n\n// b0-bf - from rn - set source register\n// b0-bf (B) - moves rn - move register to register, and set flags, (if B flag is set)\n#define FX_FROM(reg) \\\n\tif (TF(B)) \\\n\t{ \\\n\t\tuint32\tv = GSU.avReg[reg]; \\\n\t\tR15++; \\\n\t\tDREG = v; \\\n\t\tGSU.vOverflow = (v & 0x80) << 16; \\\n\t\tGSU.vSign = v; \\\n\t\tGSU.vZero = v; \\\n\t\tTESTR14; \\\n\t\tCLRFLAGS; \\\n\t} \\\n\telse \\\n\t{ \\\n\t\tGSU.pvSreg = &GSU.avReg[reg]; \\\n\t\tR15++; \\\n\t}\n\nstatic void fx_from_r0 (void)\n{\n\tFX_FROM(0);\n}\n\nstatic void fx_from_r1 (void)\n{\n\tFX_FROM(1);\n}\n\nstatic void fx_from_r2 (void)\n{\n\tFX_FROM(2);\n}\n\nstatic void fx_from_r3 (void)\n{\n\tFX_FROM(3);\n}\n\nstatic void fx_from_r4 (void)\n{\n\tFX_FROM(4);\n}\n\nstatic void fx_from_r5 (void)\n{\n\tFX_FROM(5);\n}\n\nstatic void fx_from_r6 (void)\n{\n\tFX_FROM(6);\n}\n\nstatic void fx_from_r7 (void)\n{\n\tFX_FROM(7);\n}\n\nstatic void fx_from_r8 (void)\n{\n\tFX_FROM(8);\n}\n\nstatic void fx_from_r9 (void)\n{\n\tFX_FROM(9);\n}\n\nstatic void fx_from_r10 (void)\n{\n\tFX_FROM(10);\n}\n\nstatic void fx_from_r11 (void)\n{\n\tFX_FROM(11);\n}\n\nstatic void fx_from_r12 (void)\n{\n\tFX_FROM(12);\n}\n\nstatic void fx_from_r13 (void)\n{\n\tFX_FROM(13);\n}\n\nstatic void fx_from_r14 (void)\n{\n\tFX_FROM(14);\n}\n\nstatic void fx_from_r15 (void)\n{\n\tFX_FROM(15);\n}\n\n// c0 - hib - move high-byte to low-byte\nstatic void fx_hib (void)\n{\n\tuint32\tv = USEX8(SREG >> 8);\n\tR15++;\n\tDREG = v;\n\tGSU.vSign = v << 8;\n\tGSU.vZero = v << 8;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// c1-cf - or rn\n#define FX_OR(reg) \\\n\tuint32\tv = SREG | GSU.avReg[reg]; \\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_or_r1 (void)\n{\n\tFX_OR(1);\n}\n\nstatic void fx_or_r2 (void)\n{\n\tFX_OR(2);\n}\n\nstatic void fx_or_r3 (void)\n{\n\tFX_OR(3);\n}\n\nstatic void fx_or_r4 (void)\n{\n\tFX_OR(4);\n}\n\nstatic void fx_or_r5 (void)\n{\n\tFX_OR(5);\n}\n\nstatic void fx_or_r6 (void)\n{\n\tFX_OR(6);\n}\n\nstatic void fx_or_r7 (void)\n{\n\tFX_OR(7);\n}\n\nstatic void fx_or_r8 (void)\n{\n\tFX_OR(8);\n}\n\nstatic void fx_or_r9 (void)\n{\n\tFX_OR(9);\n}\n\nstatic void fx_or_r10 (void)\n{\n\tFX_OR(10);\n}\n\nstatic void fx_or_r11 (void)\n{\n\tFX_OR(11);\n}\n\nstatic void fx_or_r12 (void)\n{\n\tFX_OR(12);\n}\n\nstatic void fx_or_r13 (void)\n{\n\tFX_OR(13);\n}\n\nstatic void fx_or_r14 (void)\n{\n\tFX_OR(14);\n}\n\nstatic void fx_or_r15 (void)\n{\n\tFX_OR(15);\n}\n\n// c1-cf (ALT1) - xor rn\n#define FX_XOR(reg) \\\n\tuint32\tv = SREG ^ GSU.avReg[reg]; \\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_xor_r1 (void)\n{\n\tFX_XOR(1);\n}\n\nstatic void fx_xor_r2 (void)\n{\n\tFX_XOR(2);\n}\n\nstatic void fx_xor_r3 (void)\n{\n\tFX_XOR(3);\n}\n\nstatic void fx_xor_r4 (void)\n{\n\tFX_XOR(4);\n}\n\nstatic void fx_xor_r5 (void)\n{\n\tFX_XOR(5);\n}\n\nstatic void fx_xor_r6 (void)\n{\n\tFX_XOR(6);\n}\n\nstatic void fx_xor_r7 (void)\n{\n\tFX_XOR(7);\n}\n\nstatic void fx_xor_r8 (void)\n{\n\tFX_XOR(8);\n}\n\nstatic void fx_xor_r9 (void)\n{\n\tFX_XOR(9);\n}\n\nstatic void fx_xor_r10 (void)\n{\n\tFX_XOR(10);\n}\n\nstatic void fx_xor_r11 (void)\n{\n\tFX_XOR(11);\n}\n\nstatic void fx_xor_r12 (void)\n{\n\tFX_XOR(12);\n}\n\nstatic void fx_xor_r13 (void)\n{\n\tFX_XOR(13);\n}\n\nstatic void fx_xor_r14 (void)\n{\n\tFX_XOR(14);\n}\n\nstatic void fx_xor_r15 (void)\n{\n\tFX_XOR(15);\n}\n\n// c1-cf (ALT2) - or #n\n#define FX_OR_I(imm) \\\n\tuint32\tv = SREG | imm; \\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_or_i1 (void)\n{\n\tFX_OR_I(1);\n}\n\nstatic void fx_or_i2 (void)\n{\n\tFX_OR_I(2);\n}\n\nstatic void fx_or_i3 (void)\n{\n\tFX_OR_I(3);\n}\n\nstatic void fx_or_i4 (void)\n{\n\tFX_OR_I(4);\n}\n\nstatic void fx_or_i5 (void)\n{\n\tFX_OR_I(5);\n}\n\nstatic void fx_or_i6 (void)\n{\n\tFX_OR_I(6);\n}\n\nstatic void fx_or_i7 (void)\n{\n\tFX_OR_I(7);\n}\n\nstatic void fx_or_i8 (void)\n{\n\tFX_OR_I(8);\n}\n\nstatic void fx_or_i9 (void)\n{\n\tFX_OR_I(9);\n}\n\nstatic void fx_or_i10 (void)\n{\n\tFX_OR_I(10);\n}\n\nstatic void fx_or_i11 (void)\n{\n\tFX_OR_I(11);\n}\n\nstatic void fx_or_i12 (void)\n{\n\tFX_OR_I(12);\n}\n\nstatic void fx_or_i13 (void)\n{\n\tFX_OR_I(13);\n}\n\nstatic void fx_or_i14 (void)\n{\n\tFX_OR_I(14);\n}\n\nstatic void fx_or_i15 (void)\n{\n\tFX_OR_I(15);\n}\n\n// c1-cf (ALT3) - xor #n\n#define FX_XOR_I(imm) \\\n\tuint32\tv = SREG ^ imm; \\\n\tR15++; \\\n\tDREG = v; \\\n\tGSU.vSign = v; \\\n\tGSU.vZero = v; \\\n\tTESTR14; \\\n\tCLRFLAGS\n\nstatic void fx_xor_i1 (void)\n{\n\tFX_XOR_I(1);\n}\n\nstatic void fx_xor_i2 (void)\n{\n\tFX_XOR_I(2);\n}\n\nstatic void fx_xor_i3 (void)\n{\n\tFX_XOR_I(3);\n}\n\nstatic void fx_xor_i4 (void)\n{\n\tFX_XOR_I(4);\n}\n\nstatic void fx_xor_i5 (void)\n{\n\tFX_XOR_I(5);\n}\n\nstatic void fx_xor_i6 (void)\n{\n\tFX_XOR_I(6);\n}\n\nstatic void fx_xor_i7 (void)\n{\n\tFX_XOR_I(7);\n}\n\nstatic void fx_xor_i8 (void)\n{\n\tFX_XOR_I(8);\n}\n\nstatic void fx_xor_i9 (void)\n{\n\tFX_XOR_I(9);\n}\n\nstatic void fx_xor_i10 (void)\n{\n\tFX_XOR_I(10);\n}\n\nstatic void fx_xor_i11 (void)\n{\n\tFX_XOR_I(11);\n}\n\nstatic void fx_xor_i12 (void)\n{\n\tFX_XOR_I(12);\n}\n\nstatic void fx_xor_i13 (void)\n{\n\tFX_XOR_I(13);\n}\n\nstatic void fx_xor_i14 (void)\n{\n\tFX_XOR_I(14);\n}\n\nstatic void fx_xor_i15 (void)\n{\n\tFX_XOR_I(15);\n}\n\n// d0-de - inc rn - increase by one\n#define FX_INC(reg) \\\n\tGSU.avReg[reg] += 1; \\\n\tGSU.vSign = GSU.avReg[reg]; \\\n\tGSU.vZero = GSU.avReg[reg]; \\\n\tCLRFLAGS; \\\n\tR15++\n\nstatic void fx_inc_r0 (void)\n{\n\tFX_INC(0);\n}\n\nstatic void fx_inc_r1 (void)\n{\n\tFX_INC(1);\n}\n\nstatic void fx_inc_r2 (void)\n{\n\tFX_INC(2);\n}\n\nstatic void fx_inc_r3 (void)\n{\n\tFX_INC(3);\n}\n\nstatic void fx_inc_r4 (void)\n{\n\tFX_INC(4);\n}\n\nstatic void fx_inc_r5 (void)\n{\n\tFX_INC(5);\n}\n\nstatic void fx_inc_r6 (void)\n{\n\tFX_INC(6);\n}\n\nstatic void fx_inc_r7 (void)\n{\n\tFX_INC(7);\n}\n\nstatic void fx_inc_r8 (void)\n{\n\tFX_INC(8);\n}\n\nstatic void fx_inc_r9 (void)\n{\n\tFX_INC(9);\n}\n\nstatic void fx_inc_r10 (void)\n{\n\tFX_INC(10);\n}\n\nstatic void fx_inc_r11 (void)\n{\n\tFX_INC(11);\n}\n\nstatic void fx_inc_r12 (void)\n{\n\tFX_INC(12);\n}\n\nstatic void fx_inc_r13 (void)\n{\n\tFX_INC(13);\n}\n\nstatic void fx_inc_r14 (void)\n{\n\tFX_INC(14);\n\tREADR14;\n}\n\n// df - getc - transfer ROM buffer to color register\nstatic void fx_getc (void)\n{\n#ifndef FX_DO_ROMBUFFER\n\tuint8\tc = ROM(R14);\n#else\n\tuint8\tc = GSU.vRomBuffer;\n#endif\n\n\tif (GSU.vPlotOptionReg & 0x04)\n\t\tc = (c & 0xf0) | (c >> 4);\n\n\tif (GSU.vPlotOptionReg & 0x08)\n\t{\n\t\tGSU.vColorReg &= 0xf0;\n\t\tGSU.vColorReg |= c & 0x0f;\n\t}\n\telse\n\t\tGSU.vColorReg = USEX8(c);\n\n\tCLRFLAGS;\n\tR15++;\n}\n\n// df (ALT2) - ramb - set current RAM bank\nstatic void fx_ramb (void)\n{\n\tGSU.vRamBankReg = SREG & (FX_RAM_BANKS - 1);\n\tGSU.pvRamBank = GSU.apvRamBank[GSU.vRamBankReg & 0x3];\n\tCLRFLAGS;\n\tR15++;\n}\n\n// df (ALT3) - romb - set current ROM bank\nstatic void fx_romb (void)\n{\n\tGSU.vRomBankReg = USEX8(SREG) & 0x7f;\n\tGSU.pvRomBank = GSU.apvRomBank[GSU.vRomBankReg];\n\tCLRFLAGS;\n\tR15++;\n}\n\n// e0-ee - dec rn - decrement by one\n#define FX_DEC(reg) \\\n\tGSU.avReg[reg] -= 1; \\\n\tGSU.vSign = GSU.avReg[reg]; \\\n\tGSU.vZero = GSU.avReg[reg]; \\\n\tCLRFLAGS; \\\n\tR15++\n\nstatic void fx_dec_r0 (void)\n{\n\tFX_DEC(0);\n}\n\nstatic void fx_dec_r1 (void)\n{\n\tFX_DEC(1);\n}\n\nstatic void fx_dec_r2 (void)\n{\n\tFX_DEC(2);\n}\n\nstatic void fx_dec_r3 (void)\n{\n\tFX_DEC(3);\n}\n\nstatic void fx_dec_r4 (void)\n{\n\tFX_DEC(4);\n}\n\nstatic void fx_dec_r5 (void)\n{\n\tFX_DEC(5);\n}\n\nstatic void fx_dec_r6 (void)\n{\n\tFX_DEC(6);\n}\n\nstatic void fx_dec_r7 (void)\n{\n\tFX_DEC(7);\n}\n\nstatic void fx_dec_r8 (void)\n{\n\tFX_DEC(8);\n}\n\nstatic void fx_dec_r9 (void)\n{\n\tFX_DEC(9);\n}\n\nstatic void fx_dec_r10 (void)\n{\n\tFX_DEC(10);\n}\n\nstatic void fx_dec_r11 (void)\n{\n\tFX_DEC(11);\n}\n\nstatic void fx_dec_r12 (void)\n{\n\tFX_DEC(12);\n}\n\nstatic void fx_dec_r13 (void)\n{\n\tFX_DEC(13);\n}\n\nstatic void fx_dec_r14 (void)\n{\n\tFX_DEC(14);\n\tREADR14;\n}\n\n// ef - getb - get byte from ROM at address R14\nstatic void fx_getb (void)\n{\n\tuint32\tv;\n#ifndef FX_DO_ROMBUFFER\n\tv = (uint32) ROM(R14);\n#else\n\tv = (uint32) GSU.vRomBuffer;\n#endif\n\tR15++;\n\tDREG = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// ef (ALT1) - getbh - get high-byte from ROM at address R14\nstatic void fx_getbh (void)\n{\n\tuint32\tv;\n#ifndef FX_DO_ROMBUFFER\n\tuint32\tc = (uint32) ROM(R14);\n#else\n\tuint32\tc = USEX8(GSU.vRomBuffer);\n#endif\n\tv = USEX8(SREG) | (c << 8);\n\tR15++;\n\tDREG = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// ef (ALT2) - getbl - get low-byte from ROM at address R14\nstatic void fx_getbl (void)\n{\n\tuint32\tv;\n#ifndef FX_DO_ROMBUFFER\n\tuint32\tc = (uint32) ROM(R14);\n#else\n\tuint32\tc = USEX8(GSU.vRomBuffer);\n#endif\n\tv = (SREG & 0xff00) | c;\n\tR15++;\n\tDREG = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// ef (ALT3) - getbs - get sign extended byte from ROM at address R14\nstatic void fx_getbs (void)\n{\n\tuint32\tv;\n#ifndef FX_DO_ROMBUFFER\n\tint8\tc;\n\tc = ROM(R14);\n\tv = SEX8(c);\n#else\n\tv = SEX8(GSU.vRomBuffer);\n#endif\n\tR15++;\n\tDREG = v;\n\tTESTR14;\n\tCLRFLAGS;\n}\n\n// f0-ff - iwt rn, #xx - immediate word transfer to register\n#define FX_IWT(reg) \\\n\tuint32\tv = PIPE; \\\n\tR15++; \\\n\tFETCHPIPE; \\\n\tR15++; \\\n\tv |= USEX8(PIPE) << 8; \\\n\tFETCHPIPE; \\\n\tR15++; \\\n\tGSU.avReg[reg] = v; \\\n\tCLRFLAGS\n\nstatic void fx_iwt_r0 (void)\n{\n\tFX_IWT(0);\n}\n\nstatic void fx_iwt_r1 (void)\n{\n\tFX_IWT(1);\n}\n\nstatic void fx_iwt_r2 (void)\n{\n\tFX_IWT(2);\n}\n\nstatic void fx_iwt_r3 (void)\n{\n\tFX_IWT(3);\n}\n\nstatic void fx_iwt_r4 (void)\n{\n\tFX_IWT(4);\n}\n\nstatic void fx_iwt_r5 (void)\n{\n\tFX_IWT(5);\n}\n\nstatic void fx_iwt_r6 (void)\n{\n\tFX_IWT(6);\n}\n\nstatic void fx_iwt_r7 (void)\n{\n\tFX_IWT(7);\n}\n\nstatic void fx_iwt_r8 (void)\n{\n\tFX_IWT(8);\n}\n\nstatic void fx_iwt_r9 (void)\n{\n\tFX_IWT(9);\n}\n\nstatic void fx_iwt_r10 (void)\n{\n\tFX_IWT(10);\n}\n\nstatic void fx_iwt_r11 (void)\n{\n\tFX_IWT(11);\n}\n\nstatic void fx_iwt_r12 (void)\n{\n\tFX_IWT(12);\n}\n\nstatic void fx_iwt_r13 (void)\n{\n\tFX_IWT(13);\n}\n\nstatic void fx_iwt_r14 (void)\n{\n\tFX_IWT(14);\n\tREADR14;\n}\n\nstatic void fx_iwt_r15 (void)\n{\n\tFX_IWT(15);\n}\n\n// f0-ff (ALT1) - lm rn, (xx) - load word from RAM\n#define FX_LM(reg) \\\n\tGSU.vLastRamAdr = PIPE; \\\n\tR15++; \\\n\tFETCHPIPE; \\\n\tR15++; \\\n\tGSU.vLastRamAdr |= USEX8(PIPE) << 8; \\\n\tFETCHPIPE; \\\n\tR15++; \\\n\tGSU.avReg[reg] = RAM(GSU.vLastRamAdr); \\\n\tGSU.avReg[reg] |= USEX8(RAM(GSU.vLastRamAdr ^ 1)) << 8; \\\n\tCLRFLAGS\n\nstatic void fx_lm_r0 (void)\n{\n\tFX_LM(0);\n}\n\nstatic void fx_lm_r1 (void)\n{\n\tFX_LM(1);\n}\n\nstatic void fx_lm_r2 (void)\n{\n\tFX_LM(2);\n}\n\nstatic void fx_lm_r3 (void)\n{\n\tFX_LM(3);\n}\n\nstatic void fx_lm_r4 (void)\n{\n\tFX_LM(4);\n}\n\nstatic void fx_lm_r5 (void)\n{\n\tFX_LM(5);\n}\n\nstatic void fx_lm_r6 (void)\n{\n\tFX_LM(6);\n}\n\nstatic void fx_lm_r7 (void)\n{\n\tFX_LM(7);\n}\n\nstatic void fx_lm_r8 (void)\n{\n\tFX_LM(8);\n}\n\nstatic void fx_lm_r9 (void)\n{\n\tFX_LM(9);\n}\n\nstatic void fx_lm_r10 (void)\n{\n\tFX_LM(10);\n}\n\nstatic void fx_lm_r11 (void)\n{\n\tFX_LM(11);\n}\n\nstatic void fx_lm_r12 (void)\n{\n\tFX_LM(12);\n}\n\nstatic void fx_lm_r13 (void)\n{\n\tFX_LM(13);\n}\n\nstatic void fx_lm_r14 (void)\n{\n\tFX_LM(14);\n\tREADR14;\n}\n\nstatic void fx_lm_r15 (void)\n{\n\tFX_LM(15);\n}\n\n// f0-ff (ALT2) - sm (xx), rn - store word in RAM\n// XXX: If rn == r15, is the value of r15 before or after the extra bytes are read ?\n#define FX_SM(reg) \\\n\tuint32\tv = GSU.avReg[reg]; \\\n\tGSU.vLastRamAdr = PIPE; \\\n\tR15++; \\\n\tFETCHPIPE; \\\n\tR15++; \\\n\tGSU.vLastRamAdr |= USEX8(PIPE) << 8; \\\n\tFETCHPIPE; \\\n\tRAM(GSU.vLastRamAdr) = (uint8) v; \\\n\tRAM(GSU.vLastRamAdr ^ 1) = (uint8) (v >> 8); \\\n\tCLRFLAGS; \\\n\tR15++\n\nstatic void fx_sm_r0 (void)\n{\n\tFX_SM(0);\n}\n\nstatic void fx_sm_r1 (void)\n{\n\tFX_SM(1);\n}\n\nstatic void fx_sm_r2 (void)\n{\n\tFX_SM(2);\n}\n\nstatic void fx_sm_r3 (void)\n{\n\tFX_SM(3);\n}\n\nstatic void fx_sm_r4 (void)\n{\n\tFX_SM(4);\n}\n\nstatic void fx_sm_r5 (void)\n{\n\tFX_SM(5);\n}\n\nstatic void fx_sm_r6 (void)\n{\n\tFX_SM(6);\n}\n\nstatic void fx_sm_r7 (void)\n{\n\tFX_SM(7);\n}\n\nstatic void fx_sm_r8 (void)\n{\n\tFX_SM(8);\n}\n\nstatic void fx_sm_r9 (void)\n{\n\tFX_SM(9);\n}\n\nstatic void fx_sm_r10 (void)\n{\n\tFX_SM(10);\n}\n\nstatic void fx_sm_r11 (void)\n{\n\tFX_SM(11);\n}\n\nstatic void fx_sm_r12 (void)\n{\n\tFX_SM(12);\n}\n\nstatic void fx_sm_r13 (void)\n{\n\tFX_SM(13);\n}\n\nstatic void fx_sm_r14 (void)\n{\n\tFX_SM(14);\n}\n\nstatic void fx_sm_r15 (void)\n{\n\tFX_SM(15);\n}\n\n// GSU executions functions\n\nuint32 fx_run (uint32 nInstructions)\n{\n\tGSU.vCounter = nInstructions;\n\twhile (TF(G) && (GSU.vCounter-- > 0))\n\t\tFX_STEP;\n#if 0\n#ifndef FX_ADDRESS_CHECK\n\tGSU.vPipeAdr = USEX16(R15 - 1) | (USEX8(GSU.vPrgBankReg) << 16);\n#endif\n#endif\n\n\treturn (nInstructions - GSU.vInstCount);\n}\n\n/*\nuint32 fx_run_to_breakpoint (uint32 nInstructions)\n{\n\tuint32\tvCounter = 0;\n\n\twhile (TF(G) && vCounter < nInstructions)\n\t{\n\t\tvCounter++;\n\t\tFX_STEP;\n\n\t\tif (USEX16(R15) == GSU.vBreakPoint)\n\t\t{\n\t\t\tGSU.vErrorCode = FX_BREAKPOINT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#if 0\n#ifndef FX_ADDRESS_CHECK\n\tGSU.vPipeAdr = USEX16(R15 - 1) | (USEX8(GSU.vPrgBankReg) << 16);\n#endif\n#endif\n\n\treturn (vCounter);\n}\n*/\n\n/*\nuint32 fx_step_over (uint32 nInstructions)\n{\n\tuint32\tvCounter = 0;\n\n\twhile (TF(G) && vCounter < nInstructions)\n\t{\n\t\tvCounter++;\n\t\tFX_STEP;\n\n\t\tif (USEX16(R15) == GSU.vBreakPoint)\n\t\t{\n\t\t\tGSU.vErrorCode = FX_BREAKPOINT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (USEX16(R15) == GSU.vStepPoint)\n\t\t\tbreak;\n\t}\n\n#if 0\n#ifndef FX_ADDRESS_CHECK\n\tGSU.vPipeAdr = USEX16(R15 - 1) | (USEX8(GSU.vPrgBankReg) << 16);\n#endif\n#endif\n\n\treturn (vCounter);\n}\n*/\n\n// Special table for the different plot configurations\n\nvoid (*fx_PlotTable[]) (void) =\n{\n\t&fx_plot_2bit, &fx_plot_4bit, &fx_plot_4bit, &fx_plot_8bit, &fx_plot_obj,\n\t&fx_rpix_2bit, &fx_rpix_4bit, &fx_rpix_4bit, &fx_rpix_8bit, &fx_rpix_obj\n};\n\n// Opcode table\n\nvoid (*fx_OpcodeTable[]) (void) =\n{\n\t// ALT0 Table\n\n\t// 00 - 0f\n\t&fx_stop,      &fx_nop,       &fx_cache,     &fx_lsr,       &fx_rol,       &fx_bra,       &fx_bge,       &fx_blt,\n\t&fx_bne,       &fx_beq,       &fx_bpl,       &fx_bmi,       &fx_bcc,       &fx_bcs,       &fx_bvc,       &fx_bvs,\n\t// 10 - 1f\n\t&fx_to_r0,     &fx_to_r1,     &fx_to_r2,     &fx_to_r3,     &fx_to_r4,     &fx_to_r5,     &fx_to_r6,     &fx_to_r7,\n\t&fx_to_r8,     &fx_to_r9,     &fx_to_r10,    &fx_to_r11,    &fx_to_r12,    &fx_to_r13,    &fx_to_r14,    &fx_to_r15,\n\t// 20 - 2f\n\t&fx_with_r0,   &fx_with_r1,   &fx_with_r2,   &fx_with_r3,   &fx_with_r4,   &fx_with_r5,   &fx_with_r6,   &fx_with_r7,\n\t&fx_with_r8,   &fx_with_r9,   &fx_with_r10,  &fx_with_r11,  &fx_with_r12,  &fx_with_r13,  &fx_with_r14,  &fx_with_r15,\n\t// 30 - 3f\n\t&fx_stw_r0,    &fx_stw_r1,    &fx_stw_r2,    &fx_stw_r3,    &fx_stw_r4,    &fx_stw_r5,    &fx_stw_r6,    &fx_stw_r7,\n\t&fx_stw_r8,    &fx_stw_r9,    &fx_stw_r10,   &fx_stw_r11,   &fx_loop,      &fx_alt1,      &fx_alt2,      &fx_alt3,\n\t// 40 - 4f\n\t&fx_ldw_r0,    &fx_ldw_r1,    &fx_ldw_r2,    &fx_ldw_r3,    &fx_ldw_r4,    &fx_ldw_r5,    &fx_ldw_r6,    &fx_ldw_r7,\n\t&fx_ldw_r8,    &fx_ldw_r9,    &fx_ldw_r10,   &fx_ldw_r11,   &fx_plot_2bit, &fx_swap,      &fx_color,     &fx_not,\n\t// 50 - 5f\n\t&fx_add_r0,    &fx_add_r1,    &fx_add_r2,    &fx_add_r3,    &fx_add_r4,    &fx_add_r5,    &fx_add_r6,    &fx_add_r7,\n\t&fx_add_r8,    &fx_add_r9,    &fx_add_r10,   &fx_add_r11,   &fx_add_r12,   &fx_add_r13,   &fx_add_r14,   &fx_add_r15,\n\t// 60 - 6f\n\t&fx_sub_r0,    &fx_sub_r1,    &fx_sub_r2,    &fx_sub_r3,    &fx_sub_r4,    &fx_sub_r5,    &fx_sub_r6,    &fx_sub_r7,\n\t&fx_sub_r8,    &fx_sub_r9,    &fx_sub_r10,   &fx_sub_r11,   &fx_sub_r12,   &fx_sub_r13,   &fx_sub_r14,   &fx_sub_r15,\n\t// 70 - 7f\n\t&fx_merge,     &fx_and_r1,    &fx_and_r2,    &fx_and_r3,    &fx_and_r4,    &fx_and_r5,    &fx_and_r6,    &fx_and_r7,\n\t&fx_and_r8,    &fx_and_r9,    &fx_and_r10,   &fx_and_r11,   &fx_and_r12,   &fx_and_r13,   &fx_and_r14,   &fx_and_r15,\n\t// 80 - 8f\n\t&fx_mult_r0,   &fx_mult_r1,   &fx_mult_r2,   &fx_mult_r3,   &fx_mult_r4,   &fx_mult_r5,   &fx_mult_r6,   &fx_mult_r7,\n\t&fx_mult_r8,   &fx_mult_r9,   &fx_mult_r10,  &fx_mult_r11,  &fx_mult_r12,  &fx_mult_r13,  &fx_mult_r14,  &fx_mult_r15,\n\t// 90 - 9f\n\t&fx_sbk,       &fx_link_i1,   &fx_link_i2,   &fx_link_i3,   &fx_link_i4,   &fx_sex,       &fx_asr,       &fx_ror,\n\t&fx_jmp_r8,    &fx_jmp_r9,    &fx_jmp_r10,   &fx_jmp_r11,   &fx_jmp_r12,   &fx_jmp_r13,   &fx_lob,       &fx_fmult,\n\t// a0 - af\n\t&fx_ibt_r0,    &fx_ibt_r1,    &fx_ibt_r2,    &fx_ibt_r3,    &fx_ibt_r4,    &fx_ibt_r5,    &fx_ibt_r6,    &fx_ibt_r7,\n\t&fx_ibt_r8,    &fx_ibt_r9,    &fx_ibt_r10,   &fx_ibt_r11,   &fx_ibt_r12,   &fx_ibt_r13,   &fx_ibt_r14,   &fx_ibt_r15,\n\t// b0 - bf\n\t&fx_from_r0,   &fx_from_r1,   &fx_from_r2,   &fx_from_r3,   &fx_from_r4,   &fx_from_r5,   &fx_from_r6,   &fx_from_r7,\n\t&fx_from_r8,   &fx_from_r9,   &fx_from_r10,  &fx_from_r11,  &fx_from_r12,  &fx_from_r13,  &fx_from_r14,  &fx_from_r15,\n\t// c0 - cf\n\t&fx_hib,       &fx_or_r1,     &fx_or_r2,     &fx_or_r3,     &fx_or_r4,     &fx_or_r5,     &fx_or_r6,     &fx_or_r7,\n\t&fx_or_r8,     &fx_or_r9,     &fx_or_r10,    &fx_or_r11,    &fx_or_r12,    &fx_or_r13,    &fx_or_r14,    &fx_or_r15,\n\t// d0 - df\n\t&fx_inc_r0,    &fx_inc_r1,    &fx_inc_r2,    &fx_inc_r3,    &fx_inc_r4,    &fx_inc_r5,    &fx_inc_r6,    &fx_inc_r7,\n\t&fx_inc_r8,    &fx_inc_r9,    &fx_inc_r10,   &fx_inc_r11,   &fx_inc_r12,   &fx_inc_r13,   &fx_inc_r14,   &fx_getc,\n\t// e0 - ef\n\t&fx_dec_r0,    &fx_dec_r1,    &fx_dec_r2,    &fx_dec_r3,    &fx_dec_r4,    &fx_dec_r5,    &fx_dec_r6,    &fx_dec_r7,\n\t&fx_dec_r8,    &fx_dec_r9,    &fx_dec_r10,   &fx_dec_r11,   &fx_dec_r12,   &fx_dec_r13,   &fx_dec_r14,   &fx_getb,\n\t// f0 - ff\n\t&fx_iwt_r0,    &fx_iwt_r1,    &fx_iwt_r2,    &fx_iwt_r3,    &fx_iwt_r4,    &fx_iwt_r5,    &fx_iwt_r6,    &fx_iwt_r7,\n\t&fx_iwt_r8,    &fx_iwt_r9,    &fx_iwt_r10,   &fx_iwt_r11,   &fx_iwt_r12,   &fx_iwt_r13,   &fx_iwt_r14,   &fx_iwt_r15,\n\n\t// ALT1 Table\n\n\t// 00 - 0f\n\t&fx_stop,      &fx_nop,       &fx_cache,     &fx_lsr,       &fx_rol,       &fx_bra,       &fx_bge,       &fx_blt,\n\t&fx_bne,       &fx_beq,       &fx_bpl,       &fx_bmi,       &fx_bcc,       &fx_bcs,       &fx_bvc,       &fx_bvs,\n\t// 10 - 1f\n\t&fx_to_r0,     &fx_to_r1,     &fx_to_r2,     &fx_to_r3,     &fx_to_r4,     &fx_to_r5,     &fx_to_r6,     &fx_to_r7,\n\t&fx_to_r8,     &fx_to_r9,     &fx_to_r10,    &fx_to_r11,    &fx_to_r12,    &fx_to_r13,    &fx_to_r14,    &fx_to_r15,\n\t// 20 - 2f\n\t&fx_with_r0,   &fx_with_r1,   &fx_with_r2,   &fx_with_r3,   &fx_with_r4,   &fx_with_r5,   &fx_with_r6,   &fx_with_r7,\n\t&fx_with_r8,   &fx_with_r9,   &fx_with_r10,  &fx_with_r11,  &fx_with_r12,  &fx_with_r13,  &fx_with_r14,  &fx_with_r15,\n\t// 30 - 3f\n\t&fx_stb_r0,    &fx_stb_r1,    &fx_stb_r2,    &fx_stb_r3,    &fx_stb_r4,    &fx_stb_r5,    &fx_stb_r6,    &fx_stb_r7,\n\t&fx_stb_r8,    &fx_stb_r9,    &fx_stb_r10,   &fx_stb_r11,   &fx_loop,      &fx_alt1,      &fx_alt2,      &fx_alt3,\n\t// 40 - 4f\n\t&fx_ldb_r0,    &fx_ldb_r1,    &fx_ldb_r2,    &fx_ldb_r3,    &fx_ldb_r4,    &fx_ldb_r5,    &fx_ldb_r6,    &fx_ldb_r7,\n\t&fx_ldb_r8,    &fx_ldb_r9,    &fx_ldb_r10,   &fx_ldb_r11,   &fx_rpix_2bit, &fx_swap,      &fx_cmode,     &fx_not,\n\t// 50 - 5f\n\t&fx_adc_r0,    &fx_adc_r1,    &fx_adc_r2,    &fx_adc_r3,    &fx_adc_r4,    &fx_adc_r5,    &fx_adc_r6,    &fx_adc_r7,\n\t&fx_adc_r8,    &fx_adc_r9,    &fx_adc_r10,   &fx_adc_r11,   &fx_adc_r12,   &fx_adc_r13,   &fx_adc_r14,   &fx_adc_r15,\n\t// 60 - 6f\n\t&fx_sbc_r0,    &fx_sbc_r1,    &fx_sbc_r2,    &fx_sbc_r3,    &fx_sbc_r4,    &fx_sbc_r5,    &fx_sbc_r6,    &fx_sbc_r7,\n\t&fx_sbc_r8,    &fx_sbc_r9,    &fx_sbc_r10,   &fx_sbc_r11,   &fx_sbc_r12,   &fx_sbc_r13,   &fx_sbc_r14,   &fx_sbc_r15,\n\t// 70 - 7f\n\t&fx_merge,     &fx_bic_r1,    &fx_bic_r2,    &fx_bic_r3,    &fx_bic_r4,    &fx_bic_r5,    &fx_bic_r6,    &fx_bic_r7,\n\t&fx_bic_r8,    &fx_bic_r9,    &fx_bic_r10,   &fx_bic_r11,   &fx_bic_r12,   &fx_bic_r13,   &fx_bic_r14,   &fx_bic_r15,\n\t// 80 - 8f\n\t&fx_umult_r0,  &fx_umult_r1,  &fx_umult_r2,  &fx_umult_r3,  &fx_umult_r4,  &fx_umult_r5,  &fx_umult_r6,  &fx_umult_r7,\n\t&fx_umult_r8,  &fx_umult_r9,  &fx_umult_r10, &fx_umult_r11, &fx_umult_r12, &fx_umult_r13, &fx_umult_r14, &fx_umult_r15,\n\t// 90 - 9f\n\t&fx_sbk,       &fx_link_i1,   &fx_link_i2,   &fx_link_i3,   &fx_link_i4,   &fx_sex,       &fx_div2,      &fx_ror,\n\t&fx_ljmp_r8,   &fx_ljmp_r9,   &fx_ljmp_r10,  &fx_ljmp_r11,  &fx_ljmp_r12,  &fx_ljmp_r13,  &fx_lob,       &fx_lmult,\n\t// a0 - af\n\t&fx_lms_r0,    &fx_lms_r1,    &fx_lms_r2,    &fx_lms_r3,    &fx_lms_r4,    &fx_lms_r5,    &fx_lms_r6,    &fx_lms_r7,\n\t&fx_lms_r8,    &fx_lms_r9,    &fx_lms_r10,   &fx_lms_r11,   &fx_lms_r12,   &fx_lms_r13,   &fx_lms_r14,   &fx_lms_r15,\n\t// b0 - bf\n\t&fx_from_r0,   &fx_from_r1,   &fx_from_r2,   &fx_from_r3,   &fx_from_r4,   &fx_from_r5,   &fx_from_r6,   &fx_from_r7,\n\t&fx_from_r8,   &fx_from_r9,   &fx_from_r10,  &fx_from_r11,  &fx_from_r12,  &fx_from_r13,  &fx_from_r14,  &fx_from_r15,\n\t// c0 - cf\n\t&fx_hib,       &fx_xor_r1,    &fx_xor_r2,    &fx_xor_r3,    &fx_xor_r4,    &fx_xor_r5,    &fx_xor_r6,    &fx_xor_r7,\n\t&fx_xor_r8,    &fx_xor_r9,    &fx_xor_r10,   &fx_xor_r11,   &fx_xor_r12,   &fx_xor_r13,   &fx_xor_r14,   &fx_xor_r15,\n\t// d0 - df\n\t&fx_inc_r0,    &fx_inc_r1,    &fx_inc_r2,    &fx_inc_r3,    &fx_inc_r4,    &fx_inc_r5,    &fx_inc_r6,    &fx_inc_r7,\n\t&fx_inc_r8,    &fx_inc_r9,    &fx_inc_r10,   &fx_inc_r11,   &fx_inc_r12,   &fx_inc_r13,   &fx_inc_r14,   &fx_getc,\n\t// e0 - ef\n\t&fx_dec_r0,    &fx_dec_r1,    &fx_dec_r2,    &fx_dec_r3,    &fx_dec_r4,    &fx_dec_r5,    &fx_dec_r6,    &fx_dec_r7,\n\t&fx_dec_r8,    &fx_dec_r9,    &fx_dec_r10,   &fx_dec_r11,   &fx_dec_r12,   &fx_dec_r13,   &fx_dec_r14,   &fx_getbh,\n\t// f0 - ff\n\t&fx_lm_r0,     &fx_lm_r1,     &fx_lm_r2,     &fx_lm_r3,     &fx_lm_r4,     &fx_lm_r5,     &fx_lm_r6,     &fx_lm_r7,\n\t&fx_lm_r8,     &fx_lm_r9,     &fx_lm_r10,    &fx_lm_r11,    &fx_lm_r12,    &fx_lm_r13,    &fx_lm_r14,    &fx_lm_r15,\n\n\t// ALT2 Table\n\n\t// 00 - 0f\n\t&fx_stop,      &fx_nop,       &fx_cache,     &fx_lsr,       &fx_rol,       &fx_bra,       &fx_bge,       &fx_blt,\n\t&fx_bne,       &fx_beq,       &fx_bpl,       &fx_bmi,       &fx_bcc,       &fx_bcs,       &fx_bvc,       &fx_bvs,\n\t// 10 - 1f\n\t&fx_to_r0,     &fx_to_r1,     &fx_to_r2,     &fx_to_r3,     &fx_to_r4,     &fx_to_r5,     &fx_to_r6,     &fx_to_r7,\n\t&fx_to_r8,     &fx_to_r9,     &fx_to_r10,    &fx_to_r11,    &fx_to_r12,    &fx_to_r13,    &fx_to_r14,    &fx_to_r15,\n\t// 20 - 2f\n\t&fx_with_r0,   &fx_with_r1,   &fx_with_r2,   &fx_with_r3,   &fx_with_r4,   &fx_with_r5,   &fx_with_r6,   &fx_with_r7,\n\t&fx_with_r8,   &fx_with_r9,   &fx_with_r10,  &fx_with_r11,  &fx_with_r12,  &fx_with_r13,  &fx_with_r14,  &fx_with_r15,\n\t// 30 - 3f\n\t&fx_stw_r0,    &fx_stw_r1,    &fx_stw_r2,    &fx_stw_r3,    &fx_stw_r4,    &fx_stw_r5,    &fx_stw_r6,    &fx_stw_r7,\n\t&fx_stw_r8,    &fx_stw_r9,    &fx_stw_r10,   &fx_stw_r11,   &fx_loop,      &fx_alt1,      &fx_alt2,      &fx_alt3,\n\t// 40 - 4f\n\t&fx_ldw_r0,    &fx_ldw_r1,    &fx_ldw_r2,    &fx_ldw_r3,    &fx_ldw_r4,    &fx_ldw_r5,    &fx_ldw_r6,    &fx_ldw_r7,\n\t&fx_ldw_r8,    &fx_ldw_r9,    &fx_ldw_r10,   &fx_ldw_r11,   &fx_plot_2bit, &fx_swap,      &fx_color,     &fx_not,\n\t// 50 - 5f\n\t&fx_add_i0,    &fx_add_i1,    &fx_add_i2,    &fx_add_i3,    &fx_add_i4,    &fx_add_i5,    &fx_add_i6,    &fx_add_i7,\n\t&fx_add_i8,    &fx_add_i9,    &fx_add_i10,   &fx_add_i11,   &fx_add_i12,   &fx_add_i13,   &fx_add_i14,   &fx_add_i15,\n\t// 60 - 6f\n\t&fx_sub_i0,    &fx_sub_i1,    &fx_sub_i2,    &fx_sub_i3,    &fx_sub_i4,    &fx_sub_i5,    &fx_sub_i6,    &fx_sub_i7,\n\t&fx_sub_i8,    &fx_sub_i9,    &fx_sub_i10,   &fx_sub_i11,   &fx_sub_i12,   &fx_sub_i13,   &fx_sub_i14,   &fx_sub_i15,\n\t// 70 - 7f\n\t&fx_merge,     &fx_and_i1,    &fx_and_i2,    &fx_and_i3,    &fx_and_i4,    &fx_and_i5,    &fx_and_i6,    &fx_and_i7,\n\t&fx_and_i8,    &fx_and_i9,    &fx_and_i10,   &fx_and_i11,   &fx_and_i12,   &fx_and_i13,   &fx_and_i14,   &fx_and_i15,\n\t// 80 - 8f\n\t&fx_mult_i0,   &fx_mult_i1,   &fx_mult_i2,   &fx_mult_i3,   &fx_mult_i4,   &fx_mult_i5,   &fx_mult_i6,   &fx_mult_i7,\n\t&fx_mult_i8,   &fx_mult_i9,   &fx_mult_i10,  &fx_mult_i11,  &fx_mult_i12,  &fx_mult_i13,  &fx_mult_i14,  &fx_mult_i15,\n\t// 90 - 9f\n\t&fx_sbk,       &fx_link_i1,   &fx_link_i2,   &fx_link_i3,   &fx_link_i4,   &fx_sex,       &fx_asr,       &fx_ror,\n\t&fx_jmp_r8,    &fx_jmp_r9,    &fx_jmp_r10,   &fx_jmp_r11,   &fx_jmp_r12,   &fx_jmp_r13,   &fx_lob,       &fx_fmult,\n\t// a0 - af\n\t&fx_sms_r0,    &fx_sms_r1,    &fx_sms_r2,    &fx_sms_r3,    &fx_sms_r4,    &fx_sms_r5,    &fx_sms_r6,    &fx_sms_r7,\n\t&fx_sms_r8,    &fx_sms_r9,    &fx_sms_r10,   &fx_sms_r11,   &fx_sms_r12,   &fx_sms_r13,   &fx_sms_r14,   &fx_sms_r15,\n\t// b0 - bf\n\t&fx_from_r0,   &fx_from_r1,   &fx_from_r2,   &fx_from_r3,   &fx_from_r4,   &fx_from_r5,   &fx_from_r6,   &fx_from_r7,\n\t&fx_from_r8,   &fx_from_r9,   &fx_from_r10,  &fx_from_r11,  &fx_from_r12,  &fx_from_r13,  &fx_from_r14,  &fx_from_r15,\n\t// c0 - cf\n\t&fx_hib,       &fx_or_i1,     &fx_or_i2,     &fx_or_i3,     &fx_or_i4,     &fx_or_i5,     &fx_or_i6,     &fx_or_i7,\n\t&fx_or_i8,     &fx_or_i9,     &fx_or_i10,    &fx_or_i11,    &fx_or_i12,    &fx_or_i13,    &fx_or_i14,    &fx_or_i15,\n\t// d0 - df\n\t&fx_inc_r0,    &fx_inc_r1,    &fx_inc_r2,    &fx_inc_r3,    &fx_inc_r4,    &fx_inc_r5,    &fx_inc_r6,    &fx_inc_r7,\n\t&fx_inc_r8,    &fx_inc_r9,    &fx_inc_r10,   &fx_inc_r11,   &fx_inc_r12,   &fx_inc_r13,   &fx_inc_r14,   &fx_ramb,\n\t// e0 - ef\n\t&fx_dec_r0,    &fx_dec_r1,    &fx_dec_r2,    &fx_dec_r3,    &fx_dec_r4,    &fx_dec_r5,    &fx_dec_r6,    &fx_dec_r7,\n\t&fx_dec_r8,    &fx_dec_r9,    &fx_dec_r10,   &fx_dec_r11,   &fx_dec_r12,   &fx_dec_r13,   &fx_dec_r14,   &fx_getbl,\n\t// f0 - ff\n\t&fx_sm_r0,     &fx_sm_r1,     &fx_sm_r2,     &fx_sm_r3,     &fx_sm_r4,     &fx_sm_r5,     &fx_sm_r6,     &fx_sm_r7,\n\t&fx_sm_r8,     &fx_sm_r9,     &fx_sm_r10,    &fx_sm_r11,    &fx_sm_r12,    &fx_sm_r13,    &fx_sm_r14,    &fx_sm_r15,\n\n\t// ALT3 Table\n\n\t// 00 - 0f\n\t&fx_stop,      &fx_nop,       &fx_cache,     &fx_lsr,       &fx_rol,       &fx_bra,       &fx_bge,       &fx_blt,\n\t&fx_bne,       &fx_beq,       &fx_bpl,       &fx_bmi,       &fx_bcc,       &fx_bcs,       &fx_bvc,       &fx_bvs,\n\t// 10 - 1f\n\t&fx_to_r0,     &fx_to_r1,     &fx_to_r2,     &fx_to_r3,     &fx_to_r4,     &fx_to_r5,     &fx_to_r6,     &fx_to_r7,\n\t&fx_to_r8,     &fx_to_r9,     &fx_to_r10,    &fx_to_r11,    &fx_to_r12,    &fx_to_r13,    &fx_to_r14,    &fx_to_r15,\n\t// 20 - 2f\n\t&fx_with_r0,   &fx_with_r1,   &fx_with_r2,   &fx_with_r3,   &fx_with_r4,   &fx_with_r5,   &fx_with_r6,   &fx_with_r7,\n\t&fx_with_r8,   &fx_with_r9,   &fx_with_r10,  &fx_with_r11,  &fx_with_r12,  &fx_with_r13,  &fx_with_r14,  &fx_with_r15,\n\t// 30 - 3f\n\t&fx_stb_r0,    &fx_stb_r1,    &fx_stb_r2,    &fx_stb_r3,    &fx_stb_r4,    &fx_stb_r5,    &fx_stb_r6,    &fx_stb_r7,\n\t&fx_stb_r8,    &fx_stb_r9,    &fx_stb_r10,   &fx_stb_r11,   &fx_loop,      &fx_alt1,      &fx_alt2,      &fx_alt3,\n\t// 40 - 4f\n\t&fx_ldb_r0,    &fx_ldb_r1,    &fx_ldb_r2,    &fx_ldb_r3,    &fx_ldb_r4,    &fx_ldb_r5,    &fx_ldb_r6,    &fx_ldb_r7,\n\t&fx_ldb_r8,    &fx_ldb_r9,    &fx_ldb_r10,   &fx_ldb_r11,   &fx_rpix_2bit, &fx_swap,      &fx_cmode,     &fx_not,\n\t// 50 - 5f\n\t&fx_adc_i0,    &fx_adc_i1,    &fx_adc_i2,    &fx_adc_i3,    &fx_adc_i4,    &fx_adc_i5,    &fx_adc_i6,    &fx_adc_i7,\n\t&fx_adc_i8,    &fx_adc_i9,    &fx_adc_i10,   &fx_adc_i11,   &fx_adc_i12,   &fx_adc_i13,   &fx_adc_i14,   &fx_adc_i15,\n\t// 60 - 6f\n\t&fx_cmp_r0,    &fx_cmp_r1,    &fx_cmp_r2,    &fx_cmp_r3,    &fx_cmp_r4,    &fx_cmp_r5,    &fx_cmp_r6,    &fx_cmp_r7,\n\t&fx_cmp_r8,    &fx_cmp_r9,    &fx_cmp_r10,   &fx_cmp_r11,   &fx_cmp_r12,   &fx_cmp_r13,   &fx_cmp_r14,   &fx_cmp_r15,\n\t// 70 - 7f\n\t&fx_merge,     &fx_bic_i1,    &fx_bic_i2,    &fx_bic_i3,    &fx_bic_i4,    &fx_bic_i5,    &fx_bic_i6,    &fx_bic_i7,\n\t&fx_bic_i8,    &fx_bic_i9,    &fx_bic_i10,   &fx_bic_i11,   &fx_bic_i12,   &fx_bic_i13,   &fx_bic_i14,   &fx_bic_i15,\n\t// 80 - 8f\n\t&fx_umult_i0,  &fx_umult_i1,  &fx_umult_i2,  &fx_umult_i3,  &fx_umult_i4,  &fx_umult_i5,  &fx_umult_i6,  &fx_umult_i7,\n\t&fx_umult_i8,  &fx_umult_i9,  &fx_umult_i10, &fx_umult_i11, &fx_umult_i12, &fx_umult_i13, &fx_umult_i14, &fx_umult_i15,\n\t// 90 - 9f\n\t&fx_sbk,       &fx_link_i1,   &fx_link_i2,   &fx_link_i3,   &fx_link_i4,   &fx_sex,       &fx_div2,      &fx_ror,\n\t&fx_ljmp_r8,   &fx_ljmp_r9,   &fx_ljmp_r10,  &fx_ljmp_r11,  &fx_ljmp_r12,  &fx_ljmp_r13,  &fx_lob,       &fx_lmult,\n\t// a0 - af\n\t&fx_lms_r0,    &fx_lms_r1,    &fx_lms_r2,    &fx_lms_r3,    &fx_lms_r4,    &fx_lms_r5,    &fx_lms_r6,    &fx_lms_r7,\n\t&fx_lms_r8,    &fx_lms_r9,    &fx_lms_r10,   &fx_lms_r11,   &fx_lms_r12,   &fx_lms_r13,   &fx_lms_r14,   &fx_lms_r15,\n\t// b0 - bf\n\t&fx_from_r0,   &fx_from_r1,   &fx_from_r2,   &fx_from_r3,   &fx_from_r4,   &fx_from_r5,   &fx_from_r6,   &fx_from_r7,\n\t&fx_from_r8,   &fx_from_r9,   &fx_from_r10,  &fx_from_r11,  &fx_from_r12,  &fx_from_r13,  &fx_from_r14,  &fx_from_r15,\n\t// c0 - cf\n\t&fx_hib,       &fx_xor_i1,    &fx_xor_i2,    &fx_xor_i3,    &fx_xor_i4,    &fx_xor_i5,    &fx_xor_i6,    &fx_xor_i7,\n\t&fx_xor_i8,    &fx_xor_i9,    &fx_xor_i10,   &fx_xor_i11,   &fx_xor_i12,   &fx_xor_i13,   &fx_xor_i14,   &fx_xor_i15,\n\t// d0 - df\n\t&fx_inc_r0,    &fx_inc_r1,    &fx_inc_r2,    &fx_inc_r3,    &fx_inc_r4,    &fx_inc_r5,    &fx_inc_r6,    &fx_inc_r7,\n\t&fx_inc_r8,    &fx_inc_r9,    &fx_inc_r10,   &fx_inc_r11,   &fx_inc_r12,   &fx_inc_r13,   &fx_inc_r14,   &fx_romb,\n\t// e0 - ef\n\t&fx_dec_r0,    &fx_dec_r1,    &fx_dec_r2,    &fx_dec_r3,    &fx_dec_r4,    &fx_dec_r5,    &fx_dec_r6,    &fx_dec_r7,\n\t&fx_dec_r8,    &fx_dec_r9,    &fx_dec_r10,   &fx_dec_r11,   &fx_dec_r12,   &fx_dec_r13,   &fx_dec_r14,   &fx_getbs,\n\t// f0 - ff\n\t&fx_lm_r0,     &fx_lm_r1,     &fx_lm_r2,     &fx_lm_r3,     &fx_lm_r4,     &fx_lm_r5,     &fx_lm_r6,     &fx_lm_r7,\n\t&fx_lm_r8,     &fx_lm_r9,     &fx_lm_r10,    &fx_lm_r11,    &fx_lm_r12,    &fx_lm_r13,    &fx_lm_r14,    &fx_lm_r15\n};\n"
        },
        {
          "name": "fxinst.h",
          "type": "blob",
          "size": 10.7607421875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _FXINST_H_\n#define _FXINST_H_\n\n/*\n * FxChip(GSU) register space specification\n * (Register address space 3000-32ff)\n *\n * The 16 generic 16 bit registers:\n * (Some have a special function in special circumstances)\n * 3000 - R0    default source/destination register\n * 3002 - R1    pixel plot X position register\n * 3004 - R2    pixel plot Y position register\n * 3006 - R3\n * 3008 - R4    lower 16 bit result of lmult\n * 300a - R5\n * 300c - R6    multiplier for fmult and lmult\n * 300e - R7    fixed point texel X position for merge\n * 3010 - R8    fixed point texel Y position for merge\n * 3012 - R9\n * 3014 - R10\n * 3016 - R11   return address set by link\n * 3018 - R12   loop counter\n * 301a - R13   loop point address\n * 301c - R14   rom address for getb, getbh, getbl, getbs\n * 301e - R15   program counter\n *\n * 3020-302f -  unused\n *\n * Other internal registers\n * 3030 - SFR   status flag register  (16bit)\n * 3032 - unused\n * 3033 - BRAMR Backup RAM register    (8bit)\n * 3034 - PBR   program bank register  (8bit)\n * 3035 - unused\n * 3036 - ROMBR rom bank register      (8bit)\n * 3037 - CFGR  control flags register (8bit)\n * 3038 - SCBR  screen base register   (8bit)\n * 3039 - CLSR  clock speed register   (8bit)\n * 303a - SCMR  screen mode register   (8bit)\n * 303b - VCR   version code register  (8bit) (read only)\n * 303c - RAMBR ram bank register      (8bit)\n * 303d - unused\n * 303e - CBR   cache base register   (16bit)\n *\n * 3040-30ff -  unused\n *\n * 3100-32ff -  CACHERAM 512 bytes of GSU cache memory\n *\n * SFR status flag register bits:\n *  0   -\n *  1   Z     Zero flag\n *  2   CY    Carry flag\n *  3   S     Sign flag\n *  4   OV    Overflow flag\n *  5   G     Go flag (set to 1 when the GSU is running)\n *  6   R     Set to 1 when reading ROM using R14 address\n *  7   -\n *  8   ALT1  Mode set-up flag for the next instruction\n *  9   ALT2  Mode set-up flag for the next instruction\n * 10   IL    Immediate lower 8-bit flag\n * 11   IH    Immediate higher 8-bit flag\n * 12   B     Set to 1 when the WITH instruction is executed\n * 13   -\n * 14   -\n * 15   IRQ   Set to 1 when GSU caused an interrupt\n *            Set to 0 when read by 658c16\n *\n * BRAMR = 0, BackupRAM is disabled\n * BRAMR = 1, BackupRAM is enabled\n *\n * CFGR control flags register bits:\n *  0   -\n *  1   -\n *  2   -\n *  3   -\n *  4   -\n *  5   MS0   Multiplier speed, 0=standard, 1=high speed\n *  6   -\n *  7   IRQ   Set to 1 when GSU interrupt request is masked\n *\n * CLSR clock speed register bits:\n *  0   CLSR  clock speed, 0 = 10.7Mhz, 1 = 21.4Mhz\n *\n * SCMR screen mode register bits:\n *  0\tMD0   color depth mode bit 0\n *  1\tMD1   color depth mode bit 1\n *  2\tHT0   screen height bit 1\n *  3\tRAN   RAM access control\n *  4\tRON   ROM access control\n *  5\tHT1   screen height bit 2\n *  6\t-\n *  7\t-\n *\n * RON = 0    SNES CPU has ROM access\n * RON = 1    GSU has ROM access\n *\n * RAN = 0    SNES has game pak RAM access\n * RAN = 1    GSU has game pak RAM access\n *\n * HT1  HT0   Screen height mode\n *  0    0    128 pixels high\n *  0    1    160 pixels high\n *  1    0    192 pixels high\n *  1    1    OBJ mode\n *\n * MD1  MD0   Color depth mode\n *  0    0    4   color mode\n *  0    1    16  color mode\n *  1    0    not used\n *  1    1    256 color mode\n *\n * CBR cache base register bits:\n * 15-4       Specify base address for data to cache from ROM or RAM\n *  3-0       Are 0 when address is read\n *\n * Write access to the program counter (301e) from\n * the SNES-CPU will start the GSU, and it will not\n * stop until it reaches a stop instruction.\n *\n */\n\n// Number of banks in GSU RAM\n#define FX_RAM_BANKS\t4\n\n// Emulate proper R14 ROM access (slower, but safer)\n#define FX_DO_ROMBUFFER\n\n// Address checking (definately slow)\n//#define FX_ADDRESS_CHECK\n\nstruct FxRegs_s\n{\n\t// FxChip registers\n\tuint32\tavReg[16];\t\t\t\t\t// 16 Generic registers\n\tuint32\tvColorReg;\t\t\t\t\t// Internal color register\n\tuint32\tvPlotOptionReg;\t\t\t\t// Plot option register\n\tuint32\tvStatusReg;\t\t\t\t\t// Status register\n\tuint32\tvPrgBankReg;\t\t\t\t// Program bank index register\n\tuint32\tvRomBankReg;\t\t\t\t// Rom bank index register\n\tuint32\tvRamBankReg;\t\t\t\t// Ram bank index register\n\tuint32\tvCacheBaseReg;\t\t\t\t// Cache base address register\n\tuint32\tvCacheFlags;\t\t\t\t// Saying what parts of the cache was written to\n\tuint32\tvLastRamAdr;\t\t\t\t// Last RAM address accessed\n\tuint32\t*pvDreg;\t\t\t\t\t// Pointer to current destination register\n\tuint32\t*pvSreg;\t\t\t\t\t// Pointer to current source register\n\tuint8\tvRomBuffer;\t\t\t\t\t// Current byte read by R14\n\tuint8\tvPipe;\t\t\t\t\t\t// Instructionset pipe\n\tuint32\tvPipeAdr;\t\t\t\t\t// The address of where the pipe was read from\n\n\t// Status register optimization stuff\n\tuint32\tvSign;\t\t\t\t\t\t// v & 0x8000\n\tuint32\tvZero;\t\t\t\t\t\t// v == 0\n\tuint32\tvCarry;\t\t\t\t\t\t// a value of 1 or 0\n\tint32\tvOverflow;\t\t\t\t\t// (v >= 0x8000 || v < -0x8000)\n\n\t// Other emulator variables\n\tint32\tvErrorCode;\n\tuint32\tvIllegalAddress;\n\n\tuint8\tbBreakPoint;\n\tuint32\tvBreakPoint;\n\tuint32\tvStepPoint;\n\n\tuint8\t*pvRegisters;\t\t\t\t// 768 bytes located in the memory at address 0x3000\n\tuint32\tnRamBanks;\t\t\t\t\t// Number of 64kb-banks in FxRam (Don't confuse it with SNES-Ram!!!)\n\tuint8\t*pvRam;\t\t\t\t\t\t// Pointer to FxRam\n\tuint32\tnRomBanks;\t\t\t\t\t// Number of 32kb-banks in Cart-ROM\n\tuint8\t*pvRom;\t\t\t\t\t\t// Pointer to Cart-ROM\n\n\tuint32\tvMode;\t\t\t\t\t\t// Color depth/mode\n\tuint32\tvPrevMode;\t\t\t\t\t// Previous depth\n\tuint8\t*pvScreenBase;\n\tuint8\t*apvScreen[32];\t\t\t\t// Pointer to each of the 32 screen colums\n\tint32\tx[32];\n\tuint32\tvScreenHeight;\t\t\t\t// 128, 160, 192 or 256 (could be overriden by cmode)\n\tuint32\tvScreenRealHeight;\t\t\t// 128, 160, 192 or 256\n\tuint32\tvPrevScreenHeight;\n\tuint32\tvScreenSize;\n\tvoid\t(*pfPlot) (void);\n\tvoid\t(*pfRpix) (void);\n\n\tuint8\t*pvRamBank;\t\t\t\t\t// Pointer to current RAM-bank\n\tuint8\t*pvRomBank;\t\t\t\t\t// Pointer to current ROM-bank\n\tuint8\t*pvPrgBank;\t\t\t\t\t// Pointer to current program ROM-bank\n\n\tuint8\t*apvRamBank[FX_RAM_BANKS];\t// Ram bank table (max 256kb)\n\tuint8\t*apvRomBank[256];\t\t\t// Rom bank table\n\n\tuint8\tbCacheActive;\n\tuint8\t*pvCache;\t\t\t\t\t// Pointer to the GSU cache\n\tuint8\tavCacheBackup[512];\t\t\t// Backup of ROM when the cache has replaced it\n\tuint32\tvCounter;\n\tuint32\tvInstCount;\n\tuint32\tvSCBRDirty;\t\t\t\t\t// If SCBR is written, our cached screen pointers need updating\n\t\n\tuint8\t*avRegAddr;\t\t\t\t\t// To reference avReg in snapshot.cpp\n};\n\nextern struct FxRegs_s\tGSU;\n\n// GSU registers\n#define GSU_R0\t\t\t0x000\n#define GSU_R1\t\t\t0x002\n#define GSU_R2\t\t\t0x004\n#define GSU_R3\t\t\t0x006\n#define GSU_R4\t\t\t0x008\n#define GSU_R5\t\t\t0x00a\n#define GSU_R6\t\t\t0x00c\n#define GSU_R7\t\t\t0x00e\n#define GSU_R8\t\t\t0x010\n#define GSU_R9\t\t\t0x012\n#define GSU_R10\t\t\t0x014\n#define GSU_R11\t\t\t0x016\n#define GSU_R12\t\t\t0x018\n#define GSU_R13\t\t\t0x01a\n#define GSU_R14\t\t\t0x01c\n#define GSU_R15\t\t\t0x01e\n#define GSU_SFR\t\t\t0x030\n#define GSU_BRAMR\t\t0x033\n#define GSU_PBR\t\t\t0x034\n#define GSU_ROMBR\t\t0x036\n#define GSU_CFGR\t\t0x037\n#define GSU_SCBR\t\t0x038\n#define GSU_CLSR\t\t0x039\n#define GSU_SCMR\t\t0x03a\n#define GSU_VCR\t\t\t0x03b\n#define GSU_RAMBR\t\t0x03c\n#define GSU_CBR\t\t\t0x03e\n#define GSU_CACHERAM\t0x100\n\n// SFR flags\n#define FLG_Z\t\t\t(1 <<  1)\n#define FLG_CY\t\t\t(1 <<  2)\n#define FLG_S\t\t\t(1 <<  3)\n#define FLG_OV\t\t\t(1 <<  4)\n#define FLG_G\t\t\t(1 <<  5)\n#define FLG_R\t\t\t(1 <<  6)\n#define FLG_ALT1\t\t(1 <<  8)\n#define FLG_ALT2\t\t(1 <<  9)\n#define FLG_IL\t\t\t(1 << 10)\n#define FLG_IH\t\t\t(1 << 11)\n#define FLG_B\t\t\t(1 << 12)\n#define FLG_IRQ\t\t\t(1 << 15)\n\n// Test flag\n#define TF(a)\t\t\t(GSU.vStatusReg &   FLG_##a)\n#define CF(a)\t\t\t(GSU.vStatusReg &= ~FLG_##a)\n#define SF(a)\t\t\t(GSU.vStatusReg |=  FLG_##a)\n\n// Test and set flag if condition, clear if not\n#define TS(a, b)\t\tGSU.vStatusReg = ((GSU.vStatusReg & (~FLG_##a)) | ((!!(##b)) * FLG_##a))\n\n// Testing ALT1 & ALT2 bits\n#define ALT0\t\t\t(!TF(ALT1) && !TF(ALT2))\n#define ALT1\t\t\t( TF(ALT1) && !TF(ALT2))\n#define ALT2\t\t\t(!TF(ALT1) &&  TF(ALT2))\n#define ALT3\t\t\t( TF(ALT1) &&  TF(ALT2))\n\n// Sign extend from 8/16 bit to 32 bit\n#define SEX8(a)\t\t\t((int32)  ((int8)   (a)))\n#define SEX16(a)\t\t((int32)  ((int16)  (a)))\n\n// Unsign extend from 8/16 bit to 32 bit\n#define USEX8(a)\t\t((uint32) ((uint8)  (a)))\n#define USEX16(a)\t\t((uint32) ((uint16) (a)))\n#define SUSEX16(a)\t\t((int32)  ((uint16) (a)))\n\n// Set/Clr Sign and Zero flag\n#define TSZ(num)\t\tTS(S, ((num) & 0x8000)); TS(Z, (!USEX16(num)))\n\n// Clear flags\n#define CLRFLAGS\t\tGSU.vStatusReg &= ~(FLG_ALT1 | FLG_ALT2 | FLG_B); GSU.pvDreg = GSU.pvSreg = &R0\n\n// Read current RAM-Bank\n#define RAM(adr)\t\tGSU.pvRamBank[USEX16(adr)]\n\n// Read current ROM-Bank\n#define ROM(idx)\t\tGSU.pvRomBank[USEX16(idx)]\n\n// Access the current value in the pipe\n#define PIPE\t\t\tGSU.vPipe\n\n// Access data in the current program bank\n#define PRGBANK(idx)\tGSU.pvPrgBank[USEX16(idx)]\n\n// Update pipe from ROM\n#if 0\n#define FETCHPIPE\t\t{ PIPE = PRGBANK(R15); GSU.vPipeAdr = (GSU.vPrgBankReg << 16) + R15; }\n#else\n#define FETCHPIPE\t\t{ PIPE = PRGBANK(R15); }\n#endif\n\n// ABS\n#define ABS(x)\t\t\t((x) < 0 ? -(x) : (x))\n\n// Access source register\n#define SREG\t\t\t(*GSU.pvSreg)\n\n// Access destination register\n#define DREG\t\t\t(*GSU.pvDreg)\n\n#ifndef FX_DO_ROMBUFFER\n\n// Don't read R14\n#define READR14\n\n// Don't test and/or read R14\n#define TESTR14\n\n#else\n\n// Read R14\n#define READR14\t\t\tGSU.vRomBuffer = ROM(R14)\n\n// Test and/or read R14\n#define TESTR14\t\t\tif (GSU.pvDreg == &R14) READR14\n\n#endif\n\n// Access to registers\n#define R0\t\t\t\tGSU.avReg[0]\n#define R1\t\t\t\tGSU.avReg[1]\n#define R2\t\t\t\tGSU.avReg[2]\n#define R3\t\t\t\tGSU.avReg[3]\n#define R4\t\t\t\tGSU.avReg[4]\n#define R5\t\t\t\tGSU.avReg[5]\n#define R6\t\t\t\tGSU.avReg[6]\n#define R7\t\t\t\tGSU.avReg[7]\n#define R8\t\t\t\tGSU.avReg[8]\n#define R9\t\t\t\tGSU.avReg[9]\n#define R10\t\t\t\tGSU.avReg[10]\n#define R11\t\t\t\tGSU.avReg[11]\n#define R12\t\t\t\tGSU.avReg[12]\n#define R13\t\t\t\tGSU.avReg[13]\n#define R14\t\t\t\tGSU.avReg[14]\n#define R15\t\t\t\tGSU.avReg[15]\n#define SFR\t\t\t\tGSU.vStatusReg\n#define PBR\t\t\t\tGSU.vPrgBankReg\n#define ROMBR\t\t\tGSU.vRomBankReg\n#define RAMBR\t\t\tGSU.vRamBankReg\n#define CBR\t\t\t\tGSU.vCacheBaseReg\n#define SCBR\t\t\tUSEX8(GSU.pvRegisters[GSU_SCBR])\n#define SCMR\t\t\tUSEX8(GSU.pvRegisters[GSU_SCMR])\n#define COLR\t\t\tGSU.vColorReg\n#define POR\t\t\t\tGSU.vPlotOptionReg\n#define BRAMR\t\t\tUSEX8(GSU.pvRegisters[GSU_BRAMR])\n#define VCR\t\t\t\tUSEX8(GSU.pvRegisters[GSU_VCR])\n#define CFGR\t\t\tUSEX8(GSU.pvRegisters[GSU_CFGR])\n#define CLSR\t\t\tUSEX8(GSU.pvRegisters[GSU_CLSR])\n\n// Execute instruction from the pipe, and fetch next byte to the pipe\n#define FX_STEP \\\n{ \\\n\tuint32\tvOpcode = (uint32) PIPE; \\\n\tFETCHPIPE; \\\n\t(*fx_OpcodeTable[(GSU.vStatusReg & 0x300) | vOpcode])(); \\\n}\n\nextern void (*fx_PlotTable[]) (void);\nextern void (*fx_OpcodeTable[]) (void);\n\n// Set this define if branches are relative to the instruction in the delay slot (I think they are)\n#define BRANCH_DELAY_RELATIVE\n\n#endif\n"
        },
        {
          "name": "getset.h",
          "type": "blob",
          "size": 21.1005859375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _GETSET_H_\n#define _GETSET_H_\n\n#include \"cpuexec.h\"\n#include \"dsp.h\"\n#include \"sa1.h\"\n#include \"spc7110.h\"\n#include \"c4.h\"\n#include \"obc1.h\"\n#include \"seta.h\"\n#include \"bsx.h\"\n#include \"msu1.h\"\n\n#define addCyclesInMemoryAccess \\\n\tif (!CPU.InDMAorHDMA) \\\n\t{ \\\n\t\tCPU.Cycles += speed; \\\n\t\twhile (CPU.Cycles >= CPU.NextEvent) \\\n\t\t\tS9xDoHEventProcessing(); \\\n\t}\n\n#define addCyclesInMemoryAccess_x2 \\\n\tif (!CPU.InDMAorHDMA) \\\n\t{ \\\n\t\tCPU.Cycles += speed << 1; \\\n\t\twhile (CPU.Cycles >= CPU.NextEvent) \\\n\t\t\tS9xDoHEventProcessing(); \\\n\t}\n\nextern uint8\tOpenBus;\n\nstatic inline int32 memory_speed (uint32 address)\n{\n\tif (address & 0x408000)\n\t{\n\t\tif (address & 0x800000)\n\t\t\treturn (CPU.FastROMSpeed);\n\n\t\treturn (SLOW_ONE_CYCLE);\n\t}\n\n\tif ((address + 0x6000) & 0x4000)\n\t\treturn (SLOW_ONE_CYCLE);\n\n\tif ((address - 0x4000) & 0x7e00)\n\t\treturn (ONE_CYCLE);\n\n\treturn (TWO_CYCLES);\n}\n\ninline uint8 S9xGetByte (uint32 Address)\n{\n\tint\t\tblock = (Address & 0xffffff) >> MEMMAP_SHIFT;\n\tuint8\t*GetAddress = Memory.Map[block];\n\tint32\tspeed = memory_speed(Address);\n\tuint8\tbyte;\n\n\tif (GetAddress >= (uint8 *) CMemory::MAP_LAST)\n\t{\n\t\tbyte = *(GetAddress + (Address & 0xffff));\n\t\taddCyclesInMemoryAccess;\n\t\treturn (byte);\n\t}\n\n\tswitch ((pint) GetAddress)\n\t{\n\t\tcase CMemory::MAP_CPU:\n\t\t\tbyte = S9xGetCPU(Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_PPU:\n\t\t\tif (CPU.InDMAorHDMA && (Address & 0xff00) == 0x2100)\n\t\t\t\treturn (OpenBus);\n\n\t\t\tbyte = S9xGetPPU(Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\t// Address & 0x7fff   : offset into bank\n\t\t\t// Address & 0xff0000 : bank\n\t\t\t// bank >> 1 | offset : SRAM address, unbound\n\t\t\t// unbound & SRAMMask : SRAM offset\n\t\t\tbyte = *(Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask));\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_LOROM_SRAM_B:\n\t\t\tbyte = *(Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB));\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_HIROM_SRAM:\n\t\tcase CMemory::MAP_RONLY_SRAM:\n\t\t\tbyte = *(Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0x1f0000) >> 3)) & Memory.SRAMMask));\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\tbyte = *(Memory.BWRAM + ((Address & 0x7fff) - 0x6000));\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_DSP:\n\t\t\tbyte = S9xGetDSP(Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_SPC7110_ROM:\n\t\t\tbyte = S9xGetSPC7110Byte(Address);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_SPC7110_DRAM:\n\t\t\tbyte = S9xGetSPC7110(0x4800);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_C4:\n\t\t\tbyte = S9xGetC4(Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_OBC_RAM:\n\t\t\tbyte = S9xGetOBC1(Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_SETA_DSP:\n\t\t\tbyte = S9xGetSetaDSP(Address);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_SETA_RISC:\n\t\t\tbyte = S9xGetST018(Address);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_BSX:\n\t\t\tbyte = S9xGetBSX(Address);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\n\t\tcase CMemory::MAP_NONE:\n\t\tdefault:\n\t\t\tbyte = OpenBus;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (byte);\n\t}\n}\n\ninline uint16 S9xGetWord (uint32 Address, enum s9xwrap_t w = WRAP_NONE)\n{\n\tuint16\tword;\n\n\tuint32\tmask = MEMMAP_MASK & (w == WRAP_PAGE ? 0xff : (w == WRAP_BANK ? 0xffff : 0xffffff));\n\tif ((Address & mask) == mask)\n\t{\n\t\tPC_t\ta;\n\n\t\tword = OpenBus = S9xGetByte(Address);\n\n\t\tswitch (w)\n\t\t{\n\t\t\tcase WRAP_PAGE:\n\t\t\t\ta.xPBPC = Address;\n\t\t\t\ta.B.xPCl++;\n\t\t\t\treturn (word | (S9xGetByte(a.xPBPC) << 8));\n\n\t\t\tcase WRAP_BANK:\n\t\t\t\ta.xPBPC = Address;\n\t\t\t\ta.W.xPC++;\n\t\t\t\treturn (word | (S9xGetByte(a.xPBPC) << 8));\n\n\t\t\tcase WRAP_NONE:\n\t\t\tdefault:\n\t\t\t\treturn (word | (S9xGetByte(Address + 1) << 8));\n\t\t}\n\t}\n\n\tint\t\tblock = (Address & 0xffffff) >> MEMMAP_SHIFT;\n\tuint8\t*GetAddress = Memory.Map[block];\n\tint32\tspeed = memory_speed(Address);\n\n\tif (GetAddress >= (uint8 *) CMemory::MAP_LAST)\n\t{\n\t\tword = READ_WORD(GetAddress + (Address & 0xffff));\n\t\taddCyclesInMemoryAccess_x2;\n\t\treturn (word);\n\t}\n\n\tswitch ((pint) GetAddress)\n\t{\n\t\tcase CMemory::MAP_CPU:\n\t\t\tword  = S9xGetCPU(Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\tword |= S9xGetCPU((Address + 1) & 0xffff) << 8;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_PPU:\n\t\t\tif (CPU.InDMAorHDMA)\n\t\t\t{\n\t\t\t\tword = OpenBus = S9xGetByte(Address);\n\t\t\t\treturn (word | (S9xGetByte(Address + 1) << 8));\n\t\t\t}\n\n\t\t\tword  = S9xGetPPU(Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\tword |= S9xGetPPU((Address + 1) & 0xffff) << 8;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\tif (Memory.SRAMMask >= MEMMAP_MASK)\n\t\t\t\tword = READ_WORD(Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask));\n\t\t\telse\n\t\t\t\tword = (*(Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask))) |\n\t\t\t\t\t  ((*(Memory.SRAM + (((((Address + 1) & 0xff0000) >> 1) | ((Address + 1) & 0x7fff)) & Memory.SRAMMask))) << 8);\n\t\t\taddCyclesInMemoryAccess_x2;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_LOROM_SRAM_B:\n\t\t\tif (Multi.sramMaskB >= MEMMAP_MASK)\n\t\t\t\tword = READ_WORD(Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB));\n\t\t\telse\n\t\t\t\tword = (*(Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB))) |\n\t\t\t\t\t  ((*(Multi.sramB + (((((Address + 1) & 0xff0000) >> 1) | ((Address + 1) & 0x7fff)) & Multi.sramMaskB))) << 8);\n\t\t\taddCyclesInMemoryAccess_x2;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_HIROM_SRAM:\n\t\tcase CMemory::MAP_RONLY_SRAM:\n\t\t\tif (Memory.SRAMMask >= MEMMAP_MASK)\n\t\t\t\tword = READ_WORD(Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0x1f0000) >> 3)) & Memory.SRAMMask));\n\t\t\telse\n\t\t\t\tword = (*(Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0x1f0000) >> 3)) & Memory.SRAMMask)) |\n\t\t\t\t\t   (*(Memory.SRAM + ((((Address + 1) & 0x7fff) - 0x6000 + (((Address + 1) & 0x1f0000) >> 3)) & Memory.SRAMMask)) << 8));\n\t\t\taddCyclesInMemoryAccess_x2;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\tword = READ_WORD(Memory.BWRAM + ((Address & 0x7fff) - 0x6000));\n\t\t\taddCyclesInMemoryAccess_x2;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_DSP:\n\t\t\tword  = S9xGetDSP(Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\tword |= S9xGetDSP((Address + 1) & 0xffff) << 8;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_SPC7110_ROM:\n\t\t\tword  = S9xGetSPC7110Byte(Address);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\tword |= S9xGetSPC7110Byte(Address + 1) << 8;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_SPC7110_DRAM:\n\t\t\tword  = S9xGetSPC7110(0x4800);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\tword |= S9xGetSPC7110(0x4800) << 8;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_C4:\n\t\t\tword  = S9xGetC4(Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\tword |= S9xGetC4((Address + 1) & 0xffff) << 8;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_OBC_RAM:\n\t\t\tword  = S9xGetOBC1(Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\tword |= S9xGetOBC1((Address + 1) & 0xffff) << 8;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_SETA_DSP:\n\t\t\tword  = S9xGetSetaDSP(Address);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\tword |= S9xGetSetaDSP(Address + 1) << 8;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_SETA_RISC:\n\t\t\tword  = S9xGetST018(Address);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\tword |= S9xGetST018(Address + 1) << 8;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_BSX:\n\t\t\tword  = S9xGetBSX(Address);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\tword |= S9xGetBSX(Address + 1) << 8;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn (word);\n\n\t\tcase CMemory::MAP_NONE:\n\t\tdefault:\n\t\t\tword = OpenBus | (OpenBus << 8);\n\t\t\taddCyclesInMemoryAccess_x2;\n\t\t\treturn (word);\n\t}\n}\n\ninline void S9xSetByte (uint8 Byte, uint32 Address)\n{\n\tint\t\tblock = (Address & 0xffffff) >> MEMMAP_SHIFT;\n\tuint8\t*SetAddress = Memory.WriteMap[block];\n\tint32\tspeed = memory_speed(Address);\n\n\tif (SetAddress >= (uint8 *) CMemory::MAP_LAST)\n\t{\n\t\t*(SetAddress + (Address & 0xffff)) = Byte;\n\t\taddCyclesInMemoryAccess;\n\t\treturn;\n\t}\n\n\tswitch ((pint) SetAddress)\n\t{\n\t\tcase CMemory::MAP_CPU:\n\t\t\tS9xSetCPU(Byte, Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_PPU:\n\t\t\tif (CPU.InDMAorHDMA && (Address & 0xff00) == 0x2100)\n\t\t\t\treturn;\n\n\t\t\tS9xSetPPU(Byte, Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\t\tif (Memory.SRAMMask)\n\t\t\t{\n\t\t\t\t*(Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask)) = Byte;\n\t\t\t\tCPU.SRAMModified = TRUE;\n\t\t\t}\n\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_LOROM_SRAM_B:\n\t\t\tif (Multi.sramMaskB)\n\t\t\t{\n\t\t\t\t*(Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB)) = Byte;\n\t\t\t\tCPU.SRAMModified = TRUE;\n\t\t\t}\n\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_HIROM_SRAM:\n\t\t\tif (Memory.SRAMMask)\n\t\t\t{\n\t\t\t\t*(Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0x1f0000) >> 3)) & Memory.SRAMMask)) = Byte;\n\t\t\t\tCPU.SRAMModified = TRUE;\n\t\t\t}\n\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\t*(Memory.BWRAM + ((Address & 0x7fff) - 0x6000)) = Byte;\n\t\t\tCPU.SRAMModified = TRUE;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\t*(Memory.SRAM + (Address & 0xffff)) = Byte;\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_DSP:\n\t\t\tS9xSetDSP(Byte, Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_C4:\n\t\t\tS9xSetC4(Byte, Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_OBC_RAM:\n\t\t\tS9xSetOBC1(Byte, Address & 0xffff);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_SETA_DSP:\n\t\t\tS9xSetSetaDSP(Byte, Address);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_SETA_RISC:\n\t\t\tS9xSetST018(Byte, Address);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_BSX:\n\t\t\tS9xSetBSX(Byte, Address);\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_NONE:\n\t\tdefault:\n\t\t\taddCyclesInMemoryAccess;\n\t\t\treturn;\n\t}\n}\n\ninline void S9xSetWord (uint16 Word, uint32 Address, enum s9xwrap_t w = WRAP_NONE, enum s9xwriteorder_t o = WRITE_01)\n{\n\tuint32\tmask = MEMMAP_MASK & (w == WRAP_PAGE ? 0xff : (w == WRAP_BANK ? 0xffff : 0xffffff));\n\tif ((Address & mask) == mask)\n\t{\n\t\tPC_t\ta;\n\n\t\tif (!o)\n\t\t\tS9xSetByte((uint8) Word, Address);\n\n\t\tswitch (w)\n\t\t{\n\t\t\tcase WRAP_PAGE:\n\t\t\t\ta.xPBPC = Address;\n\t\t\t\ta.B.xPCl++;\n\t\t\t\tS9xSetByte(Word >> 8, a.xPBPC);\n\t\t\t\tbreak;\n\n\t\t\tcase WRAP_BANK:\n\t\t\t\ta.xPBPC = Address;\n\t\t\t\ta.W.xPC++;\n\t\t\t\tS9xSetByte(Word >> 8, a.xPBPC);\n\t\t\t\tbreak;\n\n\t\t\tcase WRAP_NONE:\n\t\t\tdefault:\n\t\t\t\tS9xSetByte(Word >> 8, Address + 1);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (o)\n\t\t\tS9xSetByte((uint8) Word, Address);\n\n\t\treturn;\n\t}\n\n\tint\t\tblock = (Address & 0xffffff) >> MEMMAP_SHIFT;\n\tuint8\t*SetAddress = Memory.WriteMap[block];\n\tint32\tspeed = memory_speed(Address);\n\n\tif (SetAddress >= (uint8 *) CMemory::MAP_LAST)\n\t{\n\t\tWRITE_WORD(SetAddress + (Address & 0xffff), Word);\n\t\taddCyclesInMemoryAccess_x2;\n\t\treturn;\n\t}\n\n\tswitch ((pint) SetAddress)\n\t{\n\t\tcase CMemory::MAP_CPU:\n\t\t\tif (o)\n\t\t\t{\n\t\t\t\tS9xSetCPU(Word >> 8, (Address + 1) & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetCPU((uint8) Word, Address & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS9xSetCPU((uint8) Word, Address & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetCPU(Word >> 8, (Address + 1) & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase CMemory::MAP_PPU:\n\t\t\tif (CPU.InDMAorHDMA)\n\t\t\t{\n\t\t\t\tif ((Address & 0xff00) != 0x2100)\n\t\t\t\t\tS9xSetPPU((uint8) Word, Address & 0xffff);\n\t\t\t\tif (((Address + 1) & 0xff00) != 0x2100)\n\t\t\t\t\tS9xSetPPU(Word >> 8, (Address + 1) & 0xffff);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (o)\n\t\t\t{\n\t\t\t\tS9xSetPPU(Word >> 8, (Address + 1) & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetPPU((uint8) Word, Address & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS9xSetPPU((uint8) Word, Address & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetPPU(Word >> 8, (Address + 1) & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\t\tif (Memory.SRAMMask)\n\t\t\t{\n\t\t\t\tif (Memory.SRAMMask >= MEMMAP_MASK)\n\t\t\t\t\tWRITE_WORD(Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask), Word);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*(Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask)) = (uint8) Word;\n\t\t\t\t\t*(Memory.SRAM + (((((Address + 1) & 0xff0000) >> 1) | ((Address + 1) & 0x7fff)) & Memory.SRAMMask)) = Word >> 8;\n\t\t\t\t}\n\n\t\t\t\tCPU.SRAMModified = TRUE;\n\t\t\t}\n\n\t\t\taddCyclesInMemoryAccess_x2;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_LOROM_SRAM_B:\n\t\t\tif (Multi.sramMaskB)\n\t\t\t{\n\t\t\t\tif (Multi.sramMaskB >= MEMMAP_MASK)\n\t\t\t\t\tWRITE_WORD(Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB), Word);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*(Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB)) = (uint8) Word;\n\t\t\t\t\t*(Multi.sramB + (((((Address + 1) & 0xff0000) >> 1) | ((Address + 1) & 0x7fff)) & Multi.sramMaskB)) = Word >> 8;\n\t\t\t\t}\n\n\t\t\t\tCPU.SRAMModified = TRUE;\n\t\t\t}\n\n\t\t\taddCyclesInMemoryAccess_x2;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_HIROM_SRAM:\n\t\t\tif (Memory.SRAMMask)\n\t\t\t{\n\t\t\t\tif (Memory.SRAMMask >= MEMMAP_MASK)\n\t\t\t\t\tWRITE_WORD(Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0x1f0000) >> 3)) & Memory.SRAMMask), Word);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*(Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0x1f0000) >> 3)) & Memory.SRAMMask)) = (uint8) Word;\n\t\t\t\t\t*(Memory.SRAM + ((((Address + 1) & 0x7fff) - 0x6000 + (((Address + 1) & 0x1f0000) >> 3)) & Memory.SRAMMask)) = Word >> 8;\n\t\t\t\t}\n\n\t\t\t\tCPU.SRAMModified = TRUE;\n\t\t\t}\n\n\t\t\taddCyclesInMemoryAccess_x2;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\tWRITE_WORD(Memory.BWRAM + ((Address & 0x7fff) - 0x6000), Word);\n\t\t\tCPU.SRAMModified = TRUE;\n\t\t\taddCyclesInMemoryAccess_x2;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\tWRITE_WORD(Memory.SRAM + (Address & 0xffff), Word);\n\t\t\taddCyclesInMemoryAccess_x2;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_DSP:\n\t\t\tif (o)\n\t\t\t{\n\t\t\t\tS9xSetDSP(Word >> 8, (Address + 1) & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetDSP((uint8) Word, Address & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS9xSetDSP((uint8) Word, Address & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetDSP(Word >> 8, (Address + 1) & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase CMemory::MAP_C4:\n\t\t\tif (o)\n\t\t\t{\n\t\t\t\tS9xSetC4(Word >> 8, (Address + 1) & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetC4((uint8) Word, Address & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS9xSetC4((uint8) Word, Address & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetC4(Word >> 8, (Address + 1) & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase CMemory::MAP_OBC_RAM:\n\t\t\tif (o)\n\t\t\t{\n\t\t\t\tS9xSetOBC1(Word >> 8, (Address + 1) & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetOBC1((uint8) Word, Address & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS9xSetOBC1((uint8) Word, Address & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetOBC1(Word >> 8, (Address + 1) & 0xffff);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase CMemory::MAP_SETA_DSP:\n\t\t\tif (o)\n\t\t\t{\n\t\t\t\tS9xSetSetaDSP(Word >> 8, Address + 1);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetSetaDSP((uint8) Word, Address);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS9xSetSetaDSP((uint8) Word, Address);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetSetaDSP(Word >> 8, Address + 1);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase CMemory::MAP_SETA_RISC:\n\t\t\tif (o)\n\t\t\t{\n\t\t\t\tS9xSetST018(Word >> 8, Address + 1);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetST018((uint8) Word, Address);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS9xSetST018((uint8) Word, Address);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetST018(Word >> 8, Address + 1);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase CMemory::MAP_BSX:\n\t\t\tif (o)\n\t\t\t{\n\t\t\t\tS9xSetBSX(Word >> 8, Address + 1);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetBSX((uint8) Word, Address);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS9xSetBSX((uint8) Word, Address);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\tS9xSetBSX(Word >> 8, Address + 1);\n\t\t\t\taddCyclesInMemoryAccess;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase CMemory::MAP_NONE:\n\t\tdefault:\n\t\t\taddCyclesInMemoryAccess_x2;\n\t\t\treturn;\n\t}\n}\n\ninline void S9xSetPCBase (uint32 Address)\n{\n\tRegisters.PBPC = Address & 0xffffff;\n\tICPU.ShiftedPB = Address & 0xff0000;\n\n\tuint8\t*GetAddress = Memory.Map[(int)((Address & 0xffffff) >> MEMMAP_SHIFT)];\n\n\tCPU.MemSpeed = memory_speed(Address);\n\tCPU.MemSpeedx2 = CPU.MemSpeed << 1;\n\n\tif (GetAddress >= (uint8 *) CMemory::MAP_LAST)\n\t{\n\t\tCPU.PCBase = GetAddress;\n\t\treturn;\n\t}\n\n\tswitch ((pint) GetAddress)\n\t{\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\t\tif ((Memory.SRAMMask & MEMMAP_MASK) != MEMMAP_MASK)\n\t\t\t\tCPU.PCBase = NULL;\n\t\t\telse\n\t\t\t\tCPU.PCBase = Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask) - (Address & 0xffff);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_LOROM_SRAM_B:\n\t\t\tif ((Multi.sramMaskB & MEMMAP_MASK) != MEMMAP_MASK)\n\t\t\t\tCPU.PCBase = NULL;\n\t\t\telse\n\t\t\t\tCPU.PCBase = Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB) - (Address & 0xffff);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_HIROM_SRAM:\n\t\t\tif ((Memory.SRAMMask & MEMMAP_MASK) != MEMMAP_MASK)\n\t\t\t\tCPU.PCBase = NULL;\n\t\t\telse\n\t\t\t\tCPU.PCBase = Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0x1f0000) >> 3)) & Memory.SRAMMask) - (Address & 0xffff);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\tCPU.PCBase = Memory.BWRAM - 0x6000 - (Address & 0x8000);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\tCPU.PCBase = Memory.SRAM;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_SPC7110_ROM:\n\t\t\tCPU.PCBase = S9xGetBasePointerSPC7110(Address);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_C4:\n\t\t\tCPU.PCBase = S9xGetBasePointerC4(Address & 0xffff);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_OBC_RAM:\n\t\t\tCPU.PCBase = S9xGetBasePointerOBC1(Address & 0xffff);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_BSX:\n\t\t\tCPU.PCBase = S9xGetBasePointerBSX(Address);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_NONE:\n\t\tdefault:\n\t\t\tCPU.PCBase = NULL;\n\t\t\treturn;\n\t}\n}\n\ninline uint8 * S9xGetBasePointer (uint32 Address)\n{\n\tuint8\t*GetAddress = Memory.Map[(Address & 0xffffff) >> MEMMAP_SHIFT];\n\n\tif (GetAddress >= (uint8 *) CMemory::MAP_LAST)\n\t\treturn (GetAddress);\n\n\tswitch ((pint) GetAddress)\n\t{\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\t\tif ((Memory.SRAMMask & MEMMAP_MASK) != MEMMAP_MASK)\n\t\t\t\treturn (NULL);\n\t\t\treturn (Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask) - (Address & 0xffff));\n\n\t\tcase CMemory::MAP_LOROM_SRAM_B:\n\t\t\tif ((Multi.sramMaskB & MEMMAP_MASK) != MEMMAP_MASK)\n\t\t\t\treturn (NULL);\n\t\t\treturn (Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB) - (Address & 0xffff));\n\n\t\tcase CMemory::MAP_HIROM_SRAM:\n\t\t\tif ((Memory.SRAMMask & MEMMAP_MASK) != MEMMAP_MASK)\n\t\t\t\treturn (NULL);\n\t\t\treturn (Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0x1f0000) >> 3)) & Memory.SRAMMask) - (Address & 0xffff));\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\treturn (Memory.BWRAM - 0x6000 - (Address & 0x8000));\n\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\treturn (Memory.SRAM);\n\n\t\tcase CMemory::MAP_SPC7110_ROM:\n\t\t\treturn (S9xGetBasePointerSPC7110(Address));\n\n\t\tcase CMemory::MAP_C4:\n\t\t\treturn (S9xGetBasePointerC4(Address & 0xffff));\n\n\t\tcase CMemory::MAP_OBC_RAM:\n\t\t\treturn (S9xGetBasePointerOBC1(Address & 0xffff));\n\n\t\tcase CMemory::MAP_NONE:\n\t\tdefault:\n\t\t\treturn (NULL);\n\t}\n}\n\ninline uint8 * S9xGetMemPointer (uint32 Address)\n{\n\tuint8\t*GetAddress = Memory.Map[(Address & 0xffffff) >> MEMMAP_SHIFT];\n\n\tif (GetAddress >= (uint8 *) CMemory::MAP_LAST)\n\t\treturn (GetAddress + (Address & 0xffff));\n\n\tswitch ((pint) GetAddress)\n\t{\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\t\tif ((Memory.SRAMMask & MEMMAP_MASK) != MEMMAP_MASK)\n\t\t\t\treturn (NULL);\n\t\t\treturn (Memory.SRAM + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Memory.SRAMMask));\n\n\t\tcase CMemory::MAP_LOROM_SRAM_B:\n\t\t\tif ((Multi.sramMaskB & MEMMAP_MASK) != MEMMAP_MASK)\n\t\t\t\treturn (NULL);\n\t\t\treturn (Multi.sramB + ((((Address & 0xff0000) >> 1) | (Address & 0x7fff)) & Multi.sramMaskB));\n\n\t\tcase CMemory::MAP_HIROM_SRAM:\n\t\t\tif ((Memory.SRAMMask & MEMMAP_MASK) != MEMMAP_MASK)\n\t\t\t\treturn (NULL);\n\t\t\treturn (Memory.SRAM + (((Address & 0x7fff) - 0x6000 + ((Address & 0x1f0000) >> 3)) & Memory.SRAMMask));\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\treturn (Memory.BWRAM - 0x6000 + (Address & 0x7fff));\n\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\treturn (Memory.SRAM + (Address & 0xffff));\n\n\t\tcase CMemory::MAP_SPC7110_ROM:\n\t\t\treturn (S9xGetBasePointerSPC7110(Address) + (Address & 0xffff));\n\n\t\tcase CMemory::MAP_C4:\n\t\t\treturn (S9xGetMemPointerC4(Address & 0xffff));\n\n\t\tcase CMemory::MAP_OBC_RAM:\n\t\t\treturn (S9xGetMemPointerOBC1(Address & 0xffff));\n\n\t\tcase CMemory::MAP_NONE:\n\t\tdefault:\n\t\t\treturn (NULL);\n\t}\n}\n\n#endif\n"
        },
        {
          "name": "gfx.cpp",
          "type": "blob",
          "size": 53.626953125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"ppu.h\"\n#include \"tile.h\"\n#include \"controls.h\"\n#include \"crosshairs.h\"\n#include \"cheats.h\"\n#include \"movie.h\"\n#include \"screenshot.h\"\n#include \"display.h\"\n\nextern struct SCheatData\t\tCheat;\nextern struct SLineData\t\t\tLineData[240];\nextern struct SLineMatrixData\tLineMatrixData[240];\n\nvoid S9xComputeClipWindows (void);\n\nvoid (*S9xCustomDisplayString) (const char *, int, int, bool, int) = NULL;\n\nstatic void SetupOBJ (void);\nstatic void DrawOBJS (int);\nstatic void DisplayTime (void);\nstatic void DisplayFrameRate (void);\nstatic void DisplayPressedKeys (void);\nstatic void DisplayWatchedAddresses (void);\nstatic void DisplayStringFromBottom (const char *, int, int, bool);\nstatic void DrawBackground (int, uint8, uint8);\nstatic void DrawBackgroundMosaic (int, uint8, uint8);\nstatic void DrawBackgroundOffset (int, uint8, uint8, int);\nstatic void DrawBackgroundOffsetMosaic (int, uint8, uint8, int);\nstatic inline void DrawBackgroundMode7 (int, void (*DrawMath) (uint32, uint32, int), void (*DrawNomath) (uint32, uint32, int), int);\nstatic inline void DrawBackdrop (void);\nstatic inline void RenderScreen (bool8);\nstatic uint16 get_crosshair_color (uint8);\nstatic void S9xDisplayStringType (const char *, int, int, bool, int);\n\n#define TILE_PLUS(t, x)\t(((t) & 0xfc00) | ((t + x) & 0x3ff))\n\n\nbool8 S9xGraphicsInit (void)\n{\n\tS9xInitTileRenderer();\n\tmemset(BlackColourMap, 0, 256 * sizeof(uint16));\n\n\tIPPU.OBJChanged = TRUE;\n\tSettings.BG_Forced = 0;\n\tSettings.ForcedBackdrop = 0;\n\tS9xFixColourBrightness();\n\tS9xBuildDirectColourMaps();\n\n\tGFX.ScreenBuffer.resize(MAX_SNES_WIDTH * (MAX_SNES_HEIGHT + 64));\n\tGFX.Screen = &GFX.ScreenBuffer[GFX.RealPPL * 32];\n\tGFX.ZERO = (uint16 *) malloc(sizeof(uint16) * 0x10000);\n\tGFX.SubScreen  = (uint16 *) malloc(GFX.ScreenSize * sizeof(uint16));\n\tGFX.ZBuffer    = (uint8 *)  malloc(GFX.ScreenSize);\n\tGFX.SubZBuffer = (uint8 *)  malloc(GFX.ScreenSize);\n\n\tif (!GFX.ZERO || !GFX.SubScreen || !GFX.ZBuffer || !GFX.SubZBuffer)\n\t{\n\t\tS9xGraphicsDeinit();\n\t\treturn (FALSE);\n\t}\n\n\t// Lookup table for 1/2 color subtraction\n\tmemset(GFX.ZERO, 0, 0x10000 * sizeof(uint16));\n\tfor (uint32 r = 0; r <= MAX_RED; r++)\n\t{\n\t\tuint32\tr2 = r;\n\t\tif (r2 & 0x10)\n\t\t\tr2 &= ~0x10;\n\t\telse\n\t\t\tr2 = 0;\n\n\t\tfor (uint32 g = 0; g <= MAX_GREEN; g++)\n\t\t{\n\t\t\tuint32\tg2 = g;\n\t\t\tif (g2 & GREEN_HI_BIT)\n\t\t\t\tg2 &= ~GREEN_HI_BIT;\n\t\t\telse\n\t\t\t\tg2 = 0;\n\n\t\t\tfor (uint32 b = 0; b <= MAX_BLUE; b++)\n\t\t\t{\n\t\t\t\tuint32\tb2 = b;\n\t\t\t\tif (b2 & 0x10)\n\t\t\t\t\tb2 &= ~0x10;\n\t\t\t\telse\n\t\t\t\t\tb2 = 0;\n\n\t\t\t\tGFX.ZERO[BUILD_PIXEL2(r, g, b)] = BUILD_PIXEL2(r2, g2, b2);\n\t\t\t\tGFX.ZERO[BUILD_PIXEL2(r, g, b) & ~ALPHA_BITS_MASK] = BUILD_PIXEL2(r2, g2, b2);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (TRUE);\n}\n\nvoid S9xGraphicsDeinit (void)\n{\n\tif (GFX.ZERO)       { free(GFX.ZERO);       GFX.ZERO       = NULL; }\n\tif (GFX.SubScreen)  { free(GFX.SubScreen);  GFX.SubScreen  = NULL; }\n\tif (GFX.ZBuffer)    { free(GFX.ZBuffer);    GFX.ZBuffer    = NULL; }\n\tif (GFX.SubZBuffer) { free(GFX.SubZBuffer); GFX.SubZBuffer = NULL; }\n}\n\nvoid S9xGraphicsScreenResize (void)\n{\n\tIPPU.MaxBrightness = PPU.Brightness;\n\n\tIPPU.Interlace    = Memory.FillRAM[0x2133] & 1;\n\tIPPU.InterlaceOBJ = Memory.FillRAM[0x2133] & 2;\n\tIPPU.PseudoHires = Memory.FillRAM[0x2133] & 8;\n\n\tif (PPU.BGMode == 5 || PPU.BGMode == 6 || IPPU.PseudoHires)\n\t{\n\t\tIPPU.DoubleWidthPixels = TRUE;\n\t\tIPPU.RenderedScreenWidth = SNES_WIDTH << 1;\n\t}\n\telse\n\t{\n\t\tIPPU.DoubleWidthPixels = FALSE;\n\t\tIPPU.RenderedScreenWidth = SNES_WIDTH;\n\t}\n\n\tif (IPPU.Interlace)\n\t{\n\t\tGFX.PPL = GFX.RealPPL << 1;\n\t\tIPPU.DoubleHeightPixels = TRUE;\n\t\tIPPU.RenderedScreenHeight = PPU.ScreenHeight << 1;\n\t\tGFX.DoInterlace++;\n\t}\n\telse\n\t{\n\t\tGFX.PPL = GFX.RealPPL;\n\t\tIPPU.DoubleHeightPixels = FALSE;\n\t\tIPPU.RenderedScreenHeight = PPU.ScreenHeight;\n\t}\n}\n\nvoid S9xBuildDirectColourMaps (void)\n{\n\tIPPU.XB = mul_brightness[PPU.Brightness];\n\n\tfor (uint32 p = 0; p < 8; p++)\n\t\tfor (uint32 c = 0; c < 256; c++)\n\t\t\tDirectColourMaps[p][c] = BUILD_PIXEL(IPPU.XB[((c & 7) << 2) | ((p & 1) << 1)], IPPU.XB[((c & 0x38) >> 1) | (p & 2)], IPPU.XB[((c & 0xc0) >> 3) | (p & 4)]);\n}\n\nvoid S9xStartScreenRefresh (void)\n{\n\tif (GFX.DoInterlace)\n\t\tGFX.DoInterlace--;\n\n\tif (IPPU.RenderThisFrame)\n\t{\n\t\tif (!GFX.DoInterlace || !S9xInterlaceField())\n\t\t{\n\t\t\tif (!S9xInitUpdate())\n\t\t\t{\n\t\t\t\tIPPU.RenderThisFrame = FALSE;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tS9xGraphicsScreenResize();\n\n\t\t\tIPPU.RenderedFramesCount++;\n\t\t}\n\n\t\tPPU.MosaicStart = 0;\n\t\tPPU.RecomputeClipWindows = TRUE;\n\t\tIPPU.PreviousLine = IPPU.CurrentLine = 0;\n\n\t\tmemset(GFX.ZBuffer, 0, GFX.ScreenSize);\n\t\tmemset(GFX.SubZBuffer, 0, GFX.ScreenSize);\n\t}\n\n\tif (++IPPU.FrameCount == (uint32)Memory.ROMFramesPerSecond)\n\t{\n\t\tIPPU.DisplayedRenderedFrameCount = IPPU.RenderedFramesCount;\n\t\tIPPU.RenderedFramesCount = 0;\n\t\tIPPU.FrameCount = 0;\n\t}\n\n\tif (GFX.InfoStringTimeout > 0 && --GFX.InfoStringTimeout == 0)\n\t\tGFX.InfoString.clear();\n\n\tIPPU.TotalEmulatedFrames++;\n}\n\nvoid S9xEndScreenRefresh (void)\n{\n\tif (IPPU.RenderThisFrame)\n\t{\n\t\tFLUSH_REDRAW();\n\n\t\tif (GFX.DoInterlace && S9xInterlaceField() == 0)\n\t\t{\n\t\t\tS9xControlEOF();\n\t\t\tS9xContinueUpdate(IPPU.RenderedScreenWidth, IPPU.RenderedScreenHeight);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (IPPU.ColorsChanged)\n\t\t\t{\n\t\t\t\tuint32 saved = PPU.CGDATA[0];\n\t\t\t\tIPPU.ColorsChanged = FALSE;\n\t\t\t\tPPU.CGDATA[0] = saved;\n\t\t\t}\n\n\t\t\tS9xControlEOF();\n\n\t\t\tif (Settings.TakeScreenshot)\n\t\t\t\tS9xDoScreenshot(IPPU.RenderedScreenWidth, IPPU.RenderedScreenHeight);\n\n\t\t\tif (Settings.AutoDisplayMessages)\n\t\t\t\tS9xDisplayMessages(GFX.Screen, GFX.RealPPL, IPPU.RenderedScreenWidth, IPPU.RenderedScreenHeight, 1);\n\n\t\t\tS9xDeinitUpdate(IPPU.RenderedScreenWidth, IPPU.RenderedScreenHeight);\n\t\t}\n\t}\n\telse\n\t\tS9xControlEOF();\n\n\tS9xUpdateCheatsInMemory ();\n\n#ifdef DEBUGGER\n\tif (CPU.Flags & FRAME_ADVANCE_FLAG)\n\t{\n\t\tif (ICPU.FrameAdvanceCount)\n\t\t{\n\t\t\tICPU.FrameAdvanceCount--;\n\t\t\tIPPU.RenderThisFrame = TRUE;\n\t\t\tIPPU.FrameSkip = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCPU.Flags &= ~FRAME_ADVANCE_FLAG;\n\t\t\tCPU.Flags |= DEBUG_MODE_FLAG;\n\t\t}\n\t}\n#endif\n\n\tif (CPU.SRAMModified)\n\t{\n\t\tif (!CPU.AutoSaveTimer)\n\t\t{\n\t\t\tif (!(CPU.AutoSaveTimer = Settings.AutoSaveDelay * Memory.ROMFramesPerSecond))\n\t\t\t\tCPU.SRAMModified = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!--CPU.AutoSaveTimer)\n\t\t\t{\n\t\t\t\tS9xAutoSaveSRAM();\n\t\t\t\tCPU.SRAMModified = FALSE;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid RenderLine (uint8 C)\n{\n\tif (IPPU.RenderThisFrame)\n\t{\n\t\tLineData[C].BG[0].VOffset = PPU.BG[0].VOffset + 1;\n\t\tLineData[C].BG[0].HOffset = PPU.BG[0].HOffset;\n\t\tLineData[C].BG[1].VOffset = PPU.BG[1].VOffset + 1;\n\t\tLineData[C].BG[1].HOffset = PPU.BG[1].HOffset;\n\n\t\tif (PPU.BGMode == 7)\n\t\t{\n\t\t\tstruct SLineMatrixData *p = &LineMatrixData[C];\n\t\t\tp->MatrixA = PPU.MatrixA;\n\t\t\tp->MatrixB = PPU.MatrixB;\n\t\t\tp->MatrixC = PPU.MatrixC;\n\t\t\tp->MatrixD = PPU.MatrixD;\n\t\t\tp->CentreX = PPU.CentreX;\n\t\t\tp->CentreY = PPU.CentreY;\n\t\t\tp->M7HOFS  = PPU.M7HOFS;\n\t\t\tp->M7VOFS  = PPU.M7VOFS;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLineData[C].BG[2].VOffset = PPU.BG[2].VOffset + 1;\n\t\t\tLineData[C].BG[2].HOffset = PPU.BG[2].HOffset;\n\t\t\tLineData[C].BG[3].VOffset = PPU.BG[3].VOffset + 1;\n\t\t\tLineData[C].BG[3].HOffset = PPU.BG[3].HOffset;\n\t\t}\n\n\t\tIPPU.CurrentLine = C + 1;\n\t}\n\telse\n\t{\n\t\t// if we're not rendering this frame, we still need to update this\n\t\t// XXX: Check ForceBlank? Or anything else?\n\t\tif (IPPU.OBJChanged)\n\t\t\tSetupOBJ();\n\t\tPPU.RangeTimeOver |= GFX.OBJLines[C].RTOFlags;\n\t}\n}\n\nstatic inline void RenderScreen (bool8 sub)\n{\n\tuint8\tBGActive;\n\tint\t\tD;\n\n\tif (!sub)\n\t{\n\t\tGFX.S = GFX.Screen;\n\t\tif (GFX.DoInterlace && S9xInterlaceField())\n\t\t\tGFX.S += GFX.RealPPL;\n\t\tGFX.DB = GFX.ZBuffer;\n\t\tGFX.Clip = IPPU.Clip[0];\n\t\tBGActive = Memory.FillRAM[0x212c] & ~Settings.BG_Forced;\n\t\tD = 32;\n\t}\n\telse\n\t{\n\t\tGFX.S = GFX.SubScreen;\n\t\tGFX.DB = GFX.SubZBuffer;\n\t\tGFX.Clip = IPPU.Clip[1];\n\t\tBGActive = Memory.FillRAM[0x212d] & ~Settings.BG_Forced;\n\t\tD = (Memory.FillRAM[0x2130] & 2) << 4; // 'do math' depth flag\n\t}\n\n\tif (BGActive & 0x10)\n\t{\n\t\tBG.TileAddress = PPU.OBJNameBase;\n\t\tBG.NameSelect = PPU.OBJNameSelect;\n\t\tBG.EnableMath = !sub && (Memory.FillRAM[0x2131] & 0x10);\n\t\tBG.StartPalette = 128;\n\t\tS9xSelectTileConverter(4, FALSE, sub, FALSE);\n\t\tS9xSelectTileRenderers(PPU.BGMode, sub, TRUE);\n\t\tDrawOBJS(D + 4);\n\t}\n\n\tBG.NameSelect = 0;\n\tS9xSelectTileRenderers(PPU.BGMode, sub, FALSE);\n\n\t#define DO_BG(n, pal, depth, hires, offset, Zh, Zl, voffoff) \\\n\t\tif (BGActive & (1 << n)) \\\n\t\t{ \\\n\t\t\tBG.StartPalette = pal; \\\n\t\t\tBG.EnableMath = !sub && (Memory.FillRAM[0x2131] & (1 << n)); \\\n\t\t\tBG.TileSizeH = (!hires && PPU.BG[n].BGSize) ? 16 : 8; \\\n\t\t\tBG.TileSizeV = (PPU.BG[n].BGSize) ? 16 : 8; \\\n\t\t\tS9xSelectTileConverter(depth, hires, sub, PPU.BGMosaic[n]); \\\n\t\t\t\\\n\t\t\tif (offset) \\\n\t\t\t{ \\\n\t\t\t\tBG.OffsetSizeH = (!hires && PPU.BG[2].BGSize) ? 16 : 8; \\\n\t\t\t\tBG.OffsetSizeV = (PPU.BG[2].BGSize) ? 16 : 8; \\\n\t\t\t\t\\\n\t\t\t\tif (PPU.BGMosaic[n] && (hires || PPU.Mosaic > 1)) \\\n\t\t\t\t\tDrawBackgroundOffsetMosaic(n, D + Zh, D + Zl, voffoff); \\\n\t\t\t\telse \\\n\t\t\t\t\tDrawBackgroundOffset(n, D + Zh, D + Zl, voffoff); \\\n\t\t\t} \\\n\t\t\telse \\\n\t\t\t{ \\\n\t\t\t\tif (PPU.BGMosaic[n] && (hires || PPU.Mosaic > 1)) \\\n\t\t\t\t\tDrawBackgroundMosaic(n, D + Zh, D + Zl); \\\n\t\t\t\telse \\\n\t\t\t\t\tDrawBackground(n, D + Zh, D + Zl); \\\n\t\t\t} \\\n\t\t}\n\n\tswitch (PPU.BGMode)\n\t{\n\t\tcase 0:\n\t\t\tDO_BG(0,  0, 2, FALSE, FALSE, 15, 11, 0);\n\t\t\tDO_BG(1, 32, 2, FALSE, FALSE, 14, 10, 0);\n\t\t\tDO_BG(2, 64, 2, FALSE, FALSE,  7,  3, 0);\n\t\t\tDO_BG(3, 96, 2, FALSE, FALSE,  6,  2, 0);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tDO_BG(0,  0, 4, FALSE, FALSE, 15, 11, 0);\n\t\t\tDO_BG(1,  0, 4, FALSE, FALSE, 14, 10, 0);\n\t\t\tDO_BG(2,  0, 2, FALSE, FALSE, (PPU.BG3Priority ? 17 : 7), 3, 0);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tDO_BG(0,  0, 4, FALSE, TRUE,  15,  7, 8);\n\t\t\tDO_BG(1,  0, 4, FALSE, TRUE,  11,  3, 8);\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tDO_BG(0,  0, 8, FALSE, FALSE, 15,  7, 0);\n\t\t\tDO_BG(1,  0, 4, FALSE, FALSE, 11,  3, 0);\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tDO_BG(0,  0, 8, FALSE, TRUE,  15,  7, 0);\n\t\t\tDO_BG(1,  0, 2, FALSE, TRUE,  11,  3, 0);\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\tDO_BG(0,  0, 4, TRUE,  FALSE, 15,  7, 0);\n\t\t\tDO_BG(1,  0, 2, TRUE,  FALSE, 11,  3, 0);\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\tDO_BG(0,  0, 4, TRUE,  TRUE,  15,  7, 8);\n\t\t\tbreak;\n\n\t\tcase 7:\n\t\t\tif (BGActive & 0x01)\n\t\t\t{\n\t\t\t\tBG.EnableMath = !sub && (Memory.FillRAM[0x2131] & 1);\n\t\t\t\tDrawBackgroundMode7(0, GFX.DrawMode7BG1Math, GFX.DrawMode7BG1Nomath, D);\n\t\t\t}\n\n\t\t\tif ((Memory.FillRAM[0x2133] & 0x40) && (BGActive & 0x02))\n\t\t\t{\n\t\t\t\tBG.EnableMath = !sub && (Memory.FillRAM[0x2131] & 2);\n\t\t\t\tDrawBackgroundMode7(1, GFX.DrawMode7BG2Math, GFX.DrawMode7BG2Nomath, D);\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n\n\t#undef DO_BG\n\n\tBG.EnableMath = !sub && (Memory.FillRAM[0x2131] & 0x20);\n\n\tDrawBackdrop();\n}\n\nvoid S9xUpdateScreen (void)\n{\n\tif (IPPU.OBJChanged || IPPU.InterlaceOBJ)\n\t\tSetupOBJ();\n\n\t// XXX: Check ForceBlank? Or anything else?\n\tPPU.RangeTimeOver |= GFX.OBJLines[GFX.EndY].RTOFlags;\n\n\tGFX.StartY = IPPU.PreviousLine;\n\tif ((GFX.EndY = IPPU.CurrentLine - 1) >= PPU.ScreenHeight)\n\t\tGFX.EndY = PPU.ScreenHeight - 1;\n\n\tif (!PPU.ForcedBlanking)\n\t{\n\t\t// If force blank, may as well completely skip all this. We only did\n\t\t// the OBJ because (AFAWK) the RTO flags are updated even during force-blank.\n\n\t\tif (PPU.RecomputeClipWindows)\n\t\t{\n\t\t\tS9xComputeClipWindows();\n\t\t\tPPU.RecomputeClipWindows = FALSE;\n\t\t}\n\n\t\tif (!IPPU.DoubleWidthPixels && (PPU.BGMode == 5 || PPU.BGMode == 6 || IPPU.PseudoHires))\n\t\t{\n\t\t\t// Have to back out of the regular speed hack\n\t\t\tfor (uint32 y = 0; y < GFX.StartY; y++)\n\t\t\t{\n\t\t\t\tuint16\t*p = GFX.Screen + y * GFX.PPL + 255;\n\t\t\t\tuint16\t*q = GFX.Screen + y * GFX.PPL + 510;\n\n\t\t\t\tfor (int x = 255; x >= 0; x--, p--, q -= 2)\n\t\t\t\t\t*q = *(q + 1) = *p;\n\t\t\t}\n\n\t\t\tIPPU.DoubleWidthPixels = TRUE;\n\t\t\tIPPU.RenderedScreenWidth = 512;\n\t\t}\n\n\t\tif (!IPPU.DoubleHeightPixels && IPPU.Interlace && (PPU.BGMode == 5 || PPU.BGMode == 6))\n\t\t{\n\t\t\tIPPU.DoubleHeightPixels = TRUE;\n\t\t\tIPPU.RenderedScreenHeight = PPU.ScreenHeight << 1;\n\t\t\tGFX.PPL = GFX.RealPPL << 1;\n\t\t\tGFX.DoInterlace = 2;\n\n\t\t\tfor (int32 y = (int32) GFX.StartY - 2; y >= 0; y--)\n\t\t\t\tmemmove(GFX.Screen + (y + 1) * GFX.PPL, GFX.Screen + y * GFX.RealPPL, GFX.PPL * sizeof(uint16));\n\t\t}\n\n\t\tif ((Memory.FillRAM[0x2130] & 0x30) != 0x30 && (Memory.FillRAM[0x2131] & 0x3f))\n\t\t\tGFX.FixedColour = BUILD_PIXEL(IPPU.XB[PPU.FixedColourRed], IPPU.XB[PPU.FixedColourGreen], IPPU.XB[PPU.FixedColourBlue]);\n\n\t\tif (PPU.BGMode == 5 || PPU.BGMode == 6 || IPPU.PseudoHires ||\n\t\t\t((Memory.FillRAM[0x2130] & 0x30) != 0x30 && (Memory.FillRAM[0x2130] & 2) && (Memory.FillRAM[0x2131] & 0x3f) && (Memory.FillRAM[0x212d] & 0x1f)))\n\t\t\t// If hires (Mode 5/6 or pseudo-hires) or math is to be done\n\t\t\t// involving the subscreen, then we need to render the subscreen...\n\t\t\tRenderScreen(TRUE);\n\n\t\tRenderScreen(FALSE);\n\t}\n\telse\n\t{\n\t\tconst uint16\tblack = BUILD_PIXEL(0, 0, 0);\n\n\t\tGFX.S = GFX.Screen + GFX.StartY * GFX.PPL;\n\t\tif (GFX.DoInterlace && S9xInterlaceField())\n\t\t\tGFX.S += GFX.RealPPL;\n\n\t\tfor (uint32 l = GFX.StartY; l <= GFX.EndY; l++, GFX.S += GFX.PPL)\n\t\t\tfor (int x = 0; x < IPPU.RenderedScreenWidth; x++)\n\t\t\t\tGFX.S[x] = black;\n\t}\n\n\tIPPU.PreviousLine = IPPU.CurrentLine;\n}\n\nstatic void SetupOBJ (void)\n{\n\tint\tSmallWidth, SmallHeight, LargeWidth, LargeHeight;\n\n\tswitch (PPU.OBJSizeSelect)\n\t{\n\t\tcase 0:\n\t\t\tSmallWidth = SmallHeight = 8;\n\t\t\tLargeWidth = LargeHeight = 16;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tSmallWidth = SmallHeight = 8;\n\t\t\tLargeWidth = LargeHeight = 32;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tSmallWidth = SmallHeight = 8;\n\t\t\tLargeWidth = LargeHeight = 64;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tSmallWidth = SmallHeight = 16;\n\t\t\tLargeWidth = LargeHeight = 32;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tSmallWidth = SmallHeight = 16;\n\t\t\tLargeWidth = LargeHeight = 64;\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\tdefault:\n\t\t\tSmallWidth = SmallHeight = 32;\n\t\t\tLargeWidth = LargeHeight = 64;\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\tSmallWidth = 16; SmallHeight = 32;\n\t\t\tLargeWidth = 32; LargeHeight = 64;\n\t\t\tbreak;\n\n\t\tcase 7:\n\t\t\tSmallWidth = 16; SmallHeight = 32;\n\t\t\tLargeWidth = LargeHeight = 32;\n\t\t\tbreak;\n\t}\n\n\tint\tinc = IPPU.InterlaceOBJ ? 2 : 1;\n\n\tint startline = (IPPU.InterlaceOBJ && S9xInterlaceField()) ? 1 : 0;\n\n\t// OK, we have three cases here. Either there's no priority, priority is\n\t// normal FirstSprite, or priority is FirstSprite+Y. The first two are\n\t// easy, the last is somewhat more ... interesting. So we split them up.\n\n\tint\t\tHeight;\n\tuint8\tS;\n\tint sprite_limit = (Settings.MaxSpriteTilesPerLine == 128) ? 128 : 32;\n\n\tif (!PPU.OAMPriorityRotation || !(PPU.OAMFlip & PPU.OAMAddr & 1)) // normal case\n\t{\n\t\tuint8\tLineOBJ[SNES_HEIGHT_EXTENDED];\n\t\tmemset(LineOBJ, 0, sizeof(LineOBJ));\n\n\t\tfor (int i = 0; i < SNES_HEIGHT_EXTENDED; i++)\n\t\t{\n\t\t\tGFX.OBJLines[i].RTOFlags = 0;\n\t\t\tGFX.OBJLines[i].Tiles = Settings.MaxSpriteTilesPerLine;\n\t\t\tfor (int j = 0; j < sprite_limit; j++)\n\t\t\t\tGFX.OBJLines[i].OBJ[j].Sprite = -1;\n\t\t}\n\n\t\tuint8\tFirstSprite = PPU.FirstSprite;\n\t\tS = FirstSprite;\n\n\t\tdo\n\t\t{\n\t\t\tif (PPU.OBJ[S].Size)\n\t\t\t{\n\t\t\t\tGFX.OBJWidths[S] = LargeWidth;\n\t\t\t\tHeight = LargeHeight;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGFX.OBJWidths[S] = SmallWidth;\n\t\t\t\tHeight = SmallHeight;\n\t\t\t}\n\n\t\t\tint\tHPos = PPU.OBJ[S].HPos;\n\t\t\tif (HPos == -256)\n\t\t\t\tHPos = 0;\n\n\t\t\tif (HPos > -GFX.OBJWidths[S] && HPos <= 256)\n\t\t\t{\n\t\t\t\tif (HPos < 0)\n\t\t\t\t\tGFX.OBJVisibleTiles[S] = (GFX.OBJWidths[S] + HPos + 7) >> 3;\n\t\t\t\telse if (HPos + GFX.OBJWidths[S] > 255)\n\t\t\t\t\tGFX.OBJVisibleTiles[S] = (256 - HPos + 7) >> 3;\n\t\t\t\telse\n\t\t\t\t\tGFX.OBJVisibleTiles[S] = GFX.OBJWidths[S] >> 3;\n\n\t\t\t\tfor (uint8 line = startline, Y = (uint8) (PPU.OBJ[S].VPos & 0xff); line < Height; Y++, line += inc)\n\t\t\t\t{\n\t\t\t\t\tif (Y >= SNES_HEIGHT_EXTENDED)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (LineOBJ[Y] >= sprite_limit)\n\t\t\t\t\t{\n\t\t\t\t\t\tGFX.OBJLines[Y].RTOFlags |= 0x40;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tGFX.OBJLines[Y].Tiles -= GFX.OBJVisibleTiles[S];\n\t\t\t\t\tif (GFX.OBJLines[Y].Tiles < 0)\n\t\t\t\t\t\tGFX.OBJLines[Y].RTOFlags |= 0x80;\n\n\t\t\t\t\tGFX.OBJLines[Y].OBJ[LineOBJ[Y]].Sprite = S;\n\t\t\t\t\tif (PPU.OBJ[S].VFlip)\n\t\t\t\t\t\t// Yes, Width not Height. It so happens that the\n\t\t\t\t\t\t// sprites with H=2*W flip as two WxW sprites.\n\t\t\t\t\t\tGFX.OBJLines[Y].OBJ[LineOBJ[Y]].Line = line ^ (GFX.OBJWidths[S] - 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tGFX.OBJLines[Y].OBJ[LineOBJ[Y]].Line = line;\n\n\t\t\t\t\tLineOBJ[Y]++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tS = (S + 1) & 0x7f;\n\t\t} while (S != FirstSprite);\n\n\t\tfor (int Y = 1; Y < SNES_HEIGHT_EXTENDED; Y++)\n\t\t\tGFX.OBJLines[Y].RTOFlags |= GFX.OBJLines[Y - 1].RTOFlags;\n\t}\n\telse // evil FirstSprite+Y case\n\t{\n\t\t// First, find out which sprites are on which lines\n\t\tuint8 OBJOnLine[SNES_HEIGHT_EXTENDED][128];\n\t\t// memset(OBJOnLine, 0, sizeof(OBJOnLine));\n\t\t/* Hold on here, that's a lot of bytes to initialise at once!\n\t\t * So we only initialise them per line, as needed. [Neb]\n\t\t * Bonus: We can quickly avoid looping if a line has no OBJs.\n\t\t */\n        bool8 AnyOBJOnLine[SNES_HEIGHT_EXTENDED];\n        memset(AnyOBJOnLine, FALSE, sizeof(AnyOBJOnLine)); // better\n\n\t\tfor (S = 0; S < 128; S++)\n\t\t{\n\t\t\tif (PPU.OBJ[S].Size)\n\t\t\t{\n\t\t\t\tGFX.OBJWidths[S] = LargeWidth;\n\t\t\t\tHeight = LargeHeight;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGFX.OBJWidths[S] = SmallWidth;\n\t\t\t\tHeight = SmallHeight;\n\t\t\t}\n\n\t\t\tint\tHPos = PPU.OBJ[S].HPos;\n\t\t\tif (HPos == -256)\n\t\t\t\tHPos = 256;\n\n\t\t\tif (HPos > -GFX.OBJWidths[S] && HPos <= 256)\n\t\t\t{\n\t\t\t\tif (HPos < 0)\n\t\t\t\t\tGFX.OBJVisibleTiles[S] = (GFX.OBJWidths[S] + HPos + 7) >> 3;\n\t\t\t\telse if (HPos + GFX.OBJWidths[S] >= 257)\n\t\t\t\t\tGFX.OBJVisibleTiles[S] = (257 - HPos + 7) >> 3;\n\t\t\t\telse\n\t\t\t\t\tGFX.OBJVisibleTiles[S] = GFX.OBJWidths[S] >> 3;\n\n\t\t\t\tfor (uint8 line = startline, Y = (uint8) (PPU.OBJ[S].VPos & 0xff); line < Height; Y++, line += inc)\n\t\t\t\t{\n\t\t\t\t\tif (Y >= SNES_HEIGHT_EXTENDED)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!AnyOBJOnLine[Y]) {\n\t\t\t\t\t\tmemset(OBJOnLine[Y], 0, sizeof(OBJOnLine[Y]));\n\t\t\t\t\t\tAnyOBJOnLine[Y] = TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (PPU.OBJ[S].VFlip)\n\t\t\t\t\t\t// Yes, Width not Height. It so happens that the\n\t\t\t\t\t\t// sprites with H=2*W flip as two WxW sprites.\n\t\t\t\t\t\tOBJOnLine[Y][S] = (line ^ (GFX.OBJWidths[S] - 1)) | 0x80;\n\t\t\t\t\telse\n\t\t\t\t\t\tOBJOnLine[Y][S] = line | 0x80;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now go through and pull out those OBJ that are actually visible.\n\t\tint\tj;\n\t\tfor (int Y = 0; Y < SNES_HEIGHT_EXTENDED; Y++)\n\t\t{\n\t\t\tGFX.OBJLines[Y].RTOFlags = Y ? GFX.OBJLines[Y - 1].RTOFlags : 0;\n\t\t\tGFX.OBJLines[Y].Tiles = Settings.MaxSpriteTilesPerLine;\n\n\t\t\tuint8\tFirstSprite = (PPU.FirstSprite + Y) & 0x7f;\n\t\t\tS = FirstSprite;\n\t\t\tj = 0;\n\n\t\t\tif (AnyOBJOnLine[Y])\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tif (OBJOnLine[Y][S])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j >= sprite_limit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGFX.OBJLines[Y].RTOFlags |= 0x40;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tGFX.OBJLines[Y].Tiles -= GFX.OBJVisibleTiles[S];\n\t\t\t\t\t\tif (GFX.OBJLines[Y].Tiles < 0)\n\t\t\t\t\t\t\tGFX.OBJLines[Y].RTOFlags |= 0x80;\n\t\t\t\t\t\tGFX.OBJLines[Y].OBJ[j].Sprite = S;\n\t\t\t\t\t\tGFX.OBJLines[Y].OBJ[j++].Line = OBJOnLine[Y][S] & ~0x80;\n\t\t\t\t\t}\n\n\t\t\t\t\tS = (S + 1) & 0x7f;\n\t\t\t\t} while (S != FirstSprite);\n\t\t\t}\n\n\t\t\tif (j < sprite_limit)\n\t\t\t\tGFX.OBJLines[Y].OBJ[j].Sprite = -1;\n\t\t}\n\t}\n\n\tIPPU.OBJChanged = FALSE;\n}\n\n#if defined(__GNUC__) && !defined(__clang__)\n#pragma GCC push_options\n#pragma GCC optimize (\"no-tree-vrp\")\n#endif\nstatic void DrawOBJS (int D)\n{\n\tvoid (*DrawTile) (uint32, uint32, uint32, uint32) = NULL;\n\tvoid (*DrawClippedTile) (uint32, uint32, uint32, uint32, uint32, uint32) = NULL;\n\n\tint\tPixWidth = IPPU.DoubleWidthPixels ? 2 : 1;\n\tBG.InterlaceLine = S9xInterlaceField() ? 8 : 0;\n\tGFX.Z1 = 2;\n\tint sprite_limit = (Settings.MaxSpriteTilesPerLine == 128) ? 128 : 32;\n\n\tfor (uint32 Y = GFX.StartY, Offset = Y * GFX.PPL; Y <= GFX.EndY; Y++, Offset += GFX.PPL)\n\t{\n\t\tint\tI = 0;\n\t\tint\ttiles = GFX.OBJLines[Y].Tiles;\n\n\t\tfor (int S = GFX.OBJLines[Y].OBJ[I].Sprite; S >= 0 && I < sprite_limit; S = GFX.OBJLines[Y].OBJ[++I].Sprite)\n\t\t{\n\t\t\ttiles += GFX.OBJVisibleTiles[S];\n\t\t\tif (tiles <= 0)\n\t\t\t\tcontinue;\n\n\t\t\tint\tBaseTile = (((GFX.OBJLines[Y].OBJ[I].Line << 1) + (PPU.OBJ[S].Name & 0xf0)) & 0xf0) | (PPU.OBJ[S].Name & 0x100) | (PPU.OBJ[S].Palette << 10);\n\t\t\tint\tTileX = PPU.OBJ[S].Name & 0x0f;\n\t\t\tint\tTileLine = (GFX.OBJLines[Y].OBJ[I].Line & 7) * 8;\n\t\t\tint\tTileInc = 1;\n\n\t\t\tif (PPU.OBJ[S].HFlip)\n\t\t\t{\n\t\t\t\tTileX = (TileX + (GFX.OBJWidths[S] >> 3) - 1) & 0x0f;\n\t\t\t\tBaseTile |= H_FLIP;\n\t\t\t\tTileInc = -1;\n\t\t\t}\n\n\t\t\tGFX.Z2 = D + PPU.OBJ[S].Priority * 4;\n\n\t\t\tint\tDrawMode = 3;\n\t\t\tint\tclip = 0, next_clip = -1000;\n\t\t\tint\tX = PPU.OBJ[S].HPos;\n\t\t\tif (X == -256)\n\t\t\t\tX = 256;\n\n\t\t\tfor (int t = tiles, O = Offset + X * PixWidth; X <= 256 && X < PPU.OBJ[S].HPos + GFX.OBJWidths[S]; TileX = (TileX + TileInc) & 0x0f, X += 8, O += 8 * PixWidth)\n\t\t\t{\n\t\t\t\tif (X < -7 || --t < 0 || X == 256)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (int x = X; x < X + 8;)\n\t\t\t\t{\n\t\t\t\t\tif (x >= next_clip)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (; clip < GFX.Clip[4].Count && GFX.Clip[4].Left[clip] <= x; clip++) ;\n\t\t\t\t\t\tif (clip == 0 || x >= GFX.Clip[4].Right[clip - 1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDrawMode = 0;\n\t\t\t\t\t\t\tnext_clip = ((clip < GFX.Clip[4].Count) ? GFX.Clip[4].Left[clip] : 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDrawMode = GFX.Clip[4].DrawMode[clip - 1];\n\t\t\t\t\t\t\tnext_clip = GFX.Clip[4].Right[clip - 1];\n\t\t\t\t\t\t\tGFX.ClipColors = !(DrawMode & 1);\n\n\t\t\t\t\t\t\tif (BG.EnableMath && (PPU.OBJ[S].Palette & 4) && (DrawMode & 2))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDrawTile = GFX.DrawTileMath;\n\t\t\t\t\t\t\t\tDrawClippedTile = GFX.DrawClippedTileMath;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDrawTile = GFX.DrawTileNomath;\n\t\t\t\t\t\t\t\tDrawClippedTile = GFX.DrawClippedTileNomath;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (x == X && x + 8 < next_clip)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (DrawMode)\n\t\t\t\t\t\t\tDrawTile(BaseTile | TileX, O, TileLine, 1);\n\t\t\t\t\t\tx += 8;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint\tw = (next_clip <= X + 8) ? next_clip - x : X + 8 - x;\n\t\t\t\t\t\tif (DrawMode)\n\t\t\t\t\t\t\tDrawClippedTile(BaseTile | TileX, O, x - X, w, TileLine, 1);\n\t\t\t\t\t\tx += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n#if defined(__GNUC__) && !defined(__clang__)\n#pragma GCC pop_options\n#endif\n\nstatic void DrawBackground (int bg, uint8 Zh, uint8 Zl)\n{\n\tBG.TileAddress = PPU.BG[bg].NameBase << 1;\n\n\tuint32\tTile;\n\tuint16\t*SC0, *SC1, *SC2, *SC3;\n\n\tSC0 = (uint16 *) &Memory.VRAM[PPU.BG[bg].SCBase << 1];\n\tSC1 = (PPU.BG[bg].SCSize & 1) ? SC0 + 1024 : SC0;\n\tif (SC1 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC1 -= 0x8000;\n\tSC2 = (PPU.BG[bg].SCSize & 2) ? SC1 + 1024 : SC0;\n\tif (SC2 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC2 -= 0x8000;\n\tSC3 = (PPU.BG[bg].SCSize & 1) ? SC2 + 1024 : SC2;\n\tif (SC3 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC3 -= 0x8000;\n\n\tuint32\tLines;\n\tint\t\tOffsetMask  = (BG.TileSizeH == 16) ? 0x3ff : 0x1ff;\n\tint\t\tOffsetShift = (BG.TileSizeV == 16) ? 4 : 3;\n\tint\t\tPixWidth = IPPU.DoubleWidthPixels ? 2 : 1;\n\tbool8\tHiresInterlace = IPPU.Interlace && IPPU.DoubleWidthPixels;\n\n\tvoid (*DrawTile) (uint32, uint32, uint32, uint32);\n\tvoid (*DrawClippedTile) (uint32, uint32, uint32, uint32, uint32, uint32);\n\n\tfor (int clip = 0; clip < GFX.Clip[bg].Count; clip++)\n\t{\n\t\tGFX.ClipColors = !(GFX.Clip[bg].DrawMode[clip] & 1);\n\n\t\tif (BG.EnableMath && (GFX.Clip[bg].DrawMode[clip] & 2))\n\t\t{\n\t\t\tDrawTile = GFX.DrawTileMath;\n\t\t\tDrawClippedTile = GFX.DrawClippedTileMath;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDrawTile = GFX.DrawTileNomath;\n\t\t\tDrawClippedTile = GFX.DrawClippedTileNomath;\n\t\t}\n\n\t\tfor (uint32 Y = GFX.StartY; Y <= GFX.EndY; Y += Lines)\n\t\t{\n\t\t\tuint32\tY2 = HiresInterlace ? Y * 2 + S9xInterlaceField() : Y;\n\t\t\tuint32\tVOffset = LineData[Y].BG[bg].VOffset + (HiresInterlace ? 1 : 0);\n\t\t\tuint32\tHOffset = LineData[Y].BG[bg].HOffset;\n\t\t\tint\t\tVirtAlign = ((Y2 + VOffset) & 7) >> (HiresInterlace ? 1 : 0);\n\n\t\t\tfor (Lines = 1; Lines < GFX.LinesPerTile - VirtAlign; Lines++)\n\t\t\t{\n\t\t\t\tif ((VOffset != LineData[Y + Lines].BG[bg].VOffset) || (HOffset != LineData[Y + Lines].BG[bg].HOffset))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (Y + Lines > GFX.EndY)\n\t\t\t\tLines = GFX.EndY - Y + 1;\n\n\t\t\tVirtAlign <<= 3;\n\n\t\t\tuint32\tt1, t2;\n\t\t\tuint32\tTilemapRow = (VOffset + Y2) >> OffsetShift;\n\t\t\tBG.InterlaceLine = ((VOffset + Y2) & 1) << 3;\n\n\t\t\tif ((VOffset + Y2) & 8)\n\t\t\t{\n\t\t\t\tt1 = 16;\n\t\t\t\tt2 = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tt1 = 0;\n\t\t\t\tt2 = 16;\n\t\t\t}\n\n\t\t\tuint16\t*b1, *b2;\n\n\t\t\tif (TilemapRow & 0x20)\n\t\t\t{\n\t\t\t\tb1 = SC2;\n\t\t\t\tb2 = SC3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb1 = SC0;\n\t\t\t\tb2 = SC1;\n\t\t\t}\n\n\t\t\tb1 += (TilemapRow & 0x1f) << 5;\n\t\t\tb2 += (TilemapRow & 0x1f) << 5;\n\n\t\t\tuint32\tLeft   = GFX.Clip[bg].Left[clip];\n\t\t\tuint32\tRight  = GFX.Clip[bg].Right[clip];\n\t\t\tuint32\tOffset = Left * PixWidth + Y * GFX.PPL;\n\t\t\tuint32\tHPos   = (HOffset + Left) & OffsetMask;\n\t\t\tuint32\tHTile  = HPos >> 3;\n\t\t\tuint16\t*t;\n\n\t\t\tif (BG.TileSizeH == 8)\n\t\t\t{\n\t\t\t\tif (HTile > 31)\n\t\t\t\t\tt = b2 + (HTile & 0x1f);\n\t\t\t\telse\n\t\t\t\t\tt = b1 + HTile;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (HTile > 63)\n\t\t\t\t\tt = b2 + ((HTile >> 1) & 0x1f);\n\t\t\t\telse\n\t\t\t\t\tt = b1 + (HTile >> 1);\n\t\t\t}\n\n\t\t\tuint32\tWidth = Right - Left;\n\n\t\t\tif (HPos & 7)\n\t\t\t{\n\t\t\t\tuint32\tl = HPos & 7;\n\t\t\t\tuint32\tw = 8 - l;\n\t\t\t\tif (w > Width)\n\t\t\t\t\tw = Width;\n\n\t\t\t\tOffset -= l * PixWidth;\n\t\t\t\tTile = READ_WORD(t);\n\t\t\t\tGFX.Z1 = GFX.Z2 = (Tile & 0x2000) ? Zh : Zl;\n\n\t\t\t\tif (BG.TileSizeV == 16)\n\t\t\t\t\tTile = TILE_PLUS(Tile, ((Tile & V_FLIP) ? t2 : t1));\n\n\t\t\t\tif (BG.TileSizeH == 8)\n\t\t\t\t{\n\t\t\t\t\tDrawClippedTile(Tile, Offset, l, w, VirtAlign, Lines);\n\t\t\t\t\tt++;\n\t\t\t\t\tif (HTile == 31)\n\t\t\t\t\t\tt = b2;\n\t\t\t\t\telse\n\t\t\t\t\tif (HTile == 63)\n\t\t\t\t\t\tt = b1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!(Tile & H_FLIP))\n\t\t\t\t\t\tDrawClippedTile(TILE_PLUS(Tile, (HTile & 1)), Offset, l, w, VirtAlign, Lines);\n\t\t\t\t\telse\n\t\t\t\t\t\tDrawClippedTile(TILE_PLUS(Tile, 1 - (HTile & 1)), Offset, l, w, VirtAlign, Lines);\n\t\t\t\t\tt += HTile & 1;\n\t\t\t\t\tif (HTile == 63)\n\t\t\t\t\t\tt = b2;\n\t\t\t\t\telse\n\t\t\t\t\tif (HTile == 127)\n\t\t\t\t\t\tt = b1;\n\t\t\t\t}\n\n\t\t\t\tHTile++;\n\t\t\t\tOffset += 8 * PixWidth;\n\t\t\t\tWidth -= w;\n\t\t\t}\n\n\t\t\twhile (Width >= 8)\n\t\t\t{\n\t\t\t\tTile = READ_WORD(t);\n\t\t\t\tGFX.Z1 = GFX.Z2 = (Tile & 0x2000) ? Zh : Zl;\n\n\t\t\t\tif (BG.TileSizeV == 16)\n\t\t\t\t\tTile = TILE_PLUS(Tile, ((Tile & V_FLIP) ? t2 : t1));\n\n\t\t\t\tif (BG.TileSizeH == 8)\n\t\t\t\t{\n\t\t\t\t\tDrawTile(Tile, Offset, VirtAlign, Lines);\n\t\t\t\t\tt++;\n\t\t\t\t\tif (HTile == 31)\n\t\t\t\t\t\tt = b2;\n\t\t\t\t\telse\n\t\t\t\t\tif (HTile == 63)\n\t\t\t\t\t\tt = b1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!(Tile & H_FLIP))\n\t\t\t\t\t\tDrawTile(TILE_PLUS(Tile, (HTile & 1)), Offset, VirtAlign, Lines);\n\t\t\t\t\telse\n\t\t\t\t\t\tDrawTile(TILE_PLUS(Tile, 1 - (HTile & 1)), Offset, VirtAlign, Lines);\n\t\t\t\t\tt += HTile & 1;\n\t\t\t\t\tif (HTile == 63)\n\t\t\t\t\t\tt = b2;\n\t\t\t\t\telse\n\t\t\t\t\tif (HTile == 127)\n\t\t\t\t\t\tt = b1;\n\t\t\t\t}\n\n\t\t\t\tHTile++;\n\t\t\t\tOffset += 8 * PixWidth;\n\t\t\t\tWidth -= 8;\n\t\t\t}\n\n\t\t\tif (Width)\n\t\t\t{\n\t\t\t\tTile = READ_WORD(t);\n\t\t\t\tGFX.Z1 = GFX.Z2 = (Tile & 0x2000) ? Zh : Zl;\n\n\t\t\t\tif (BG.TileSizeV == 16)\n\t\t\t\t\tTile = TILE_PLUS(Tile, ((Tile & V_FLIP) ? t2 : t1));\n\n\t\t\t\tif (BG.TileSizeH == 8)\n\t\t\t\t\tDrawClippedTile(Tile, Offset, 0, Width, VirtAlign, Lines);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!(Tile & H_FLIP))\n\t\t\t\t\t\tDrawClippedTile(TILE_PLUS(Tile, (HTile & 1)), Offset, 0, Width, VirtAlign, Lines);\n\t\t\t\t\telse\n\t\t\t\t\t\tDrawClippedTile(TILE_PLUS(Tile, 1 - (HTile & 1)), Offset, 0, Width, VirtAlign, Lines);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void DrawBackgroundMosaic (int bg, uint8 Zh, uint8 Zl)\n{\n\tBG.TileAddress = PPU.BG[bg].NameBase << 1;\n\n\tuint32\tTile;\n\tuint16\t*SC0, *SC1, *SC2, *SC3;\n\n\tSC0 = (uint16 *) &Memory.VRAM[PPU.BG[bg].SCBase << 1];\n\tSC1 = (PPU.BG[bg].SCSize & 1) ? SC0 + 1024 : SC0;\n\tif (SC1 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC1 -= 0x8000;\n\tSC2 = (PPU.BG[bg].SCSize & 2) ? SC1 + 1024 : SC0;\n\tif (SC2 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC2 -= 0x8000;\n\tSC3 = (PPU.BG[bg].SCSize & 1) ? SC2 + 1024 : SC2;\n\tif (SC3 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC3 -= 0x8000;\n\n\tint\tLines;\n\tint\tOffsetMask  = (BG.TileSizeH == 16) ? 0x3ff : 0x1ff;\n\tint\tOffsetShift = (BG.TileSizeV == 16) ? 4 : 3;\n\tint\tPixWidth = IPPU.DoubleWidthPixels ? 2 : 1;\n\tbool8\tHiresInterlace = IPPU.Interlace && IPPU.DoubleWidthPixels;\n\n\tvoid (*DrawPix) (uint32, uint32, uint32, uint32, uint32, uint32);\n\n\tint\tMosaicStart = ((uint32) GFX.StartY - PPU.MosaicStart) % PPU.Mosaic;\n\n\tfor (int clip = 0; clip < GFX.Clip[bg].Count; clip++)\n\t{\n\t\tGFX.ClipColors = !(GFX.Clip[bg].DrawMode[clip] & 1);\n\n\t\tif (BG.EnableMath && (GFX.Clip[bg].DrawMode[clip] & 2))\n\t\t\tDrawPix = GFX.DrawMosaicPixelMath;\n\t\telse\n\t\t\tDrawPix = GFX.DrawMosaicPixelNomath;\n\n\t\tfor (uint32 Y = GFX.StartY - MosaicStart; Y <= GFX.EndY; Y += PPU.Mosaic)\n\t\t{\n\t\t\tuint32\tY2 = HiresInterlace ? Y * 2 : Y;\n\t\t\tuint32\tVOffset = LineData[Y + MosaicStart].BG[bg].VOffset + (HiresInterlace ? 1 : 0);\n\t\t\tuint32\tHOffset = LineData[Y + MosaicStart].BG[bg].HOffset;\n\n\t\t\tLines = PPU.Mosaic - MosaicStart;\n\t\t\tif (Y + MosaicStart + Lines > GFX.EndY)\n\t\t\t\tLines = GFX.EndY - Y - MosaicStart + 1;\n\n\t\t\tint\tVirtAlign = (((Y2 + VOffset) & 7) >> (HiresInterlace ? 1 : 0)) << 3;\n\n\t\t\tuint32\tt1, t2;\n\t\t\tuint32\tTilemapRow = (VOffset + Y2) >> OffsetShift;\n\t\t\tBG.InterlaceLine = ((VOffset + Y2) & 1) << 3;\n\n\t\t\tif ((VOffset + Y2) & 8)\n\t\t\t{\n\t\t\t\tt1 = 16;\n\t\t\t\tt2 = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tt1 = 0;\n\t\t\t\tt2 = 16;\n\t\t\t}\n\n\t\t\tuint16\t*b1, *b2;\n\n\t\t\tif (TilemapRow & 0x20)\n\t\t\t{\n\t\t\t\tb1 = SC2;\n\t\t\t\tb2 = SC3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb1 = SC0;\n\t\t\t\tb2 = SC1;\n\t\t\t}\n\n\t\t\tb1 += (TilemapRow & 0x1f) << 5;\n\t\t\tb2 += (TilemapRow & 0x1f) << 5;\n\n\t\t\tuint32\tLeft   = GFX.Clip[bg].Left[clip];\n\t\t\tuint32\tRight  = GFX.Clip[bg].Right[clip];\n\t\t\tuint32\tOffset = Left * PixWidth + (Y + MosaicStart) * GFX.PPL;\n\t\t\tuint32\tHPos   = (HOffset + Left - (Left % PPU.Mosaic)) & OffsetMask;\n\t\t\tuint32\tHTile  = HPos >> 3;\n\t\t\tuint16\t*t;\n\n\t\t\tif (BG.TileSizeH == 8)\n\t\t\t{\n\t\t\t\tif (HTile > 31)\n\t\t\t\t\tt = b2 + (HTile & 0x1f);\n\t\t\t\telse\n\t\t\t\t\tt = b1 + HTile;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (HTile > 63)\n\t\t\t\t\tt = b2 + ((HTile >> 1) & 0x1f);\n\t\t\t\telse\n\t\t\t\t\tt = b1 + (HTile >> 1);\n\t\t\t}\n\n\t\t\tuint32\tWidth = Right - Left;\n\n\t\t\tHPos &= 7;\n\n\t\t\twhile (Left < Right)\n\t\t\t{\n\t\t\t\tuint32\tw = PPU.Mosaic - (Left % PPU.Mosaic);\n\t\t\t\tif (w > Width)\n\t\t\t\t\tw = Width;\n\n\t\t\t\tTile = READ_WORD(t);\n\t\t\t\tGFX.Z1 = GFX.Z2 = (Tile & 0x2000) ? Zh : Zl;\n\n\t\t\t\tif (BG.TileSizeV == 16)\n\t\t\t\t\tTile = TILE_PLUS(Tile, ((Tile & V_FLIP) ? t2 : t1));\n\n\t\t\t\tif (BG.TileSizeH == 8)\n\t\t\t\t\tDrawPix(Tile, Offset, VirtAlign, HPos & 7, w, Lines);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!(Tile & H_FLIP))\n\t\t\t\t\t\tDrawPix(TILE_PLUS(Tile, (HTile & 1)), Offset, VirtAlign, HPos & 7, w, Lines);\n\t\t\t\t\telse\n\t\t\t\t\t\tDrawPix(TILE_PLUS(Tile, 1 - (HTile & 1)), Offset, VirtAlign, HPos & 7, w, Lines);\n\t\t\t\t}\n\n\t\t\t\tHPos += PPU.Mosaic;\n\n\t\t\t\twhile (HPos >= 8)\n\t\t\t\t{\n\t\t\t\t\tHPos -= 8;\n\n\t\t\t\t\tif (BG.TileSizeH == 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tt++;\n\t\t\t\t\t\tif (HTile == 31)\n\t\t\t\t\t\t\tt = b2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (HTile == 63)\n\t\t\t\t\t\t\tt = b1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tt += HTile & 1;\n\t\t\t\t\t\tif (HTile == 63)\n\t\t\t\t\t\t\tt = b2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (HTile == 127)\n\t\t\t\t\t\t\tt = b1;\n\t\t\t\t\t}\n\n\t\t\t\t\tHTile++;\n\t\t\t\t}\n\n\t\t\t\tOffset += w * PixWidth;\n\t\t\t\tWidth -= w;\n\t\t\t\tLeft += w;\n\t\t\t}\n\n\t\t\tMosaicStart = 0;\n\t\t}\n\t}\n}\n\nstatic void DrawBackgroundOffset (int bg, uint8 Zh, uint8 Zl, int VOffOff)\n{\n\tBG.TileAddress = PPU.BG[bg].NameBase << 1;\n\n\tuint32\tTile;\n\tuint16\t*SC0, *SC1, *SC2, *SC3;\n\tuint16\t*BPS0, *BPS1, *BPS2, *BPS3;\n\n\tBPS0 = (uint16 *) &Memory.VRAM[PPU.BG[2].SCBase << 1];\n\tBPS1 = (PPU.BG[2].SCSize & 1) ? BPS0 + 1024 : BPS0;\n\tif (BPS1 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tBPS1 -= 0x8000;\n\tBPS2 = (PPU.BG[2].SCSize & 2) ? BPS1 + 1024 : BPS0;\n\tif (BPS2 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tBPS2 -= 0x8000;\n\tBPS3 = (PPU.BG[2].SCSize & 1) ? BPS2 + 1024 : BPS2;\n\tif (BPS3 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tBPS3 -= 0x8000;\n\n\tSC0 = (uint16 *) &Memory.VRAM[PPU.BG[bg].SCBase << 1];\n\tSC1 = (PPU.BG[bg].SCSize & 1) ? SC0 + 1024 : SC0;\n\tif (SC1 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC1 -= 0x8000;\n\tSC2 = (PPU.BG[bg].SCSize & 2) ? SC1 + 1024 : SC0;\n\tif (SC2 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC2 -= 0x8000;\n\tSC3 = (PPU.BG[bg].SCSize & 1) ? SC2 + 1024 : SC2;\n\tif (SC3 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC3 -= 0x8000;\n\n\tint\tOffsetMask   = (BG.TileSizeH   == 16) ? 0x3ff : 0x1ff;\n\tint\tOffsetShift  = (BG.TileSizeV   == 16) ? 4 : 3;\n\tint\tOffset2Mask  = (BG.OffsetSizeH == 16) ? 0x3ff : 0x1ff;\n\tint\tOffset2Shift = (BG.OffsetSizeV == 16) ? 4 : 3;\n\tint\tOffsetEnableMask = 0x2000 << bg;\n\tint\tPixWidth = IPPU.DoubleWidthPixels ? 2 : 1;\n\tbool8\tHiresInterlace = IPPU.Interlace && IPPU.DoubleWidthPixels;\n\n\tvoid (*DrawClippedTile) (uint32, uint32, uint32, uint32, uint32, uint32);\n\n\tfor (int clip = 0; clip < GFX.Clip[bg].Count; clip++)\n\t{\n\t\tGFX.ClipColors = !(GFX.Clip[bg].DrawMode[clip] & 1);\n\n\t\tif (BG.EnableMath && (GFX.Clip[bg].DrawMode[clip] & 2))\n\t\t{\n\t\t\tDrawClippedTile = GFX.DrawClippedTileMath;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDrawClippedTile = GFX.DrawClippedTileNomath;\n\t\t}\n\n\t\tfor (uint32 Y = GFX.StartY; Y <= GFX.EndY; Y++)\n\t\t{\n\t\t\tuint32\tY2 = HiresInterlace ? Y * 2 + S9xInterlaceField() : Y;\n\t\t\tuint32\tVOff = LineData[Y].BG[2].VOffset - 1;\n\t\t\tuint32\tHOff = LineData[Y].BG[2].HOffset;\n\t\t\tuint32\tHOffsetRow = VOff >> Offset2Shift;\n\t\t\tuint32\tVOffsetRow = (VOff + VOffOff) >> Offset2Shift;\n\t\t\tuint16\t*s, *s1, *s2;\n\n\t\t\tif (HOffsetRow & 0x20)\n\t\t\t{\n\t\t\t\ts1 = BPS2;\n\t\t\t\ts2 = BPS3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts1 = BPS0;\n\t\t\t\ts2 = BPS1;\n\t\t\t}\n\n\t\t\ts1 += (HOffsetRow & 0x1f) << 5;\n\t\t\ts2 += (HOffsetRow & 0x1f) << 5;\n\t\t\ts = ((VOffsetRow & 0x20) ? BPS2 : BPS0) + ((VOffsetRow & 0x1f) << 5);\n\t\t\tint32\tVOffsetOffset = s - s1;\n\n\t\t\tuint32\tLeft  = GFX.Clip[bg].Left[clip];\n\t\t\tuint32\tRight = GFX.Clip[bg].Right[clip];\n\t\t\tuint32\tOffset = Left * PixWidth + Y * GFX.PPL;\n\t\t\tuint32\tHScroll = LineData[Y].BG[bg].HOffset;\n\t\t\tbool8\tleft_edge = (Left < (8 - (HScroll & 7)));\n\t\t\tuint32\tWidth = Right - Left;\n\n\t\t\twhile (Left < Right)\n\t\t\t{\n\t\t\t\tuint32\tVOffset, HOffset;\n\n\t\t\t\tif (left_edge)\n\t\t\t\t{\n\t\t\t\t\t// SNES cannot do OPT for leftmost tile column\n\t\t\t\t\tVOffset = LineData[Y].BG[bg].VOffset;\n\t\t\t\t\tHOffset = HScroll;\n\t\t\t\t\tleft_edge = FALSE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint HOffTile = ((HOff + Left - 1) & Offset2Mask) >> 3;\n\n\t\t\t\t\tif (BG.OffsetSizeH == 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (HOffTile > 31)\n\t\t\t\t\t\t\ts = s2 + (HOffTile & 0x1f);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ts = s1 + HOffTile;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (HOffTile > 63)\n\t\t\t\t\t\t\ts = s2 + ((HOffTile >> 1) & 0x1f);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ts = s1 + (HOffTile >> 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tuint16\tHCellOffset = READ_WORD(s);\n\t\t\t\t\tuint16\tVCellOffset;\n\n\t\t\t\t\tif (VOffOff)\n\t\t\t\t\t\tVCellOffset = READ_WORD(s + VOffsetOffset);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (HCellOffset & 0x8000)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVCellOffset = HCellOffset;\n\t\t\t\t\t\t\tHCellOffset = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tVCellOffset = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (VCellOffset & OffsetEnableMask)\n\t\t\t\t\t\tVOffset = VCellOffset + 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tVOffset = LineData[Y].BG[bg].VOffset;\n\n\t\t\t\t\tif (HCellOffset & OffsetEnableMask)\n\t\t\t\t\t\tHOffset = (HCellOffset & ~7) | (HScroll & 7);\n\t\t\t\t\telse\n\t\t\t\t\t\tHOffset = HScroll;\n\t\t\t\t}\n\n\t\t\t\tif (HiresInterlace)\n\t\t\t\t\tVOffset++;\n\n\t\t\t\tuint32\tt1, t2;\n\t\t\t\tint\t\tVirtAlign = (((Y2 + VOffset) & 7) >> (HiresInterlace ? 1 : 0)) << 3;\n\t\t\t\tint\t\tTilemapRow = (VOffset + Y2) >> OffsetShift;\n\t\t\t\tBG.InterlaceLine = ((VOffset + Y2) & 1) << 3;\n\n\t\t\t\tif ((VOffset + Y2) & 8)\n\t\t\t\t{\n\t\t\t\t\tt1 = 16;\n\t\t\t\t\tt2 = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tt1 = 0;\n\t\t\t\t\tt2 = 16;\n\t\t\t\t}\n\n\t\t\t\tuint16\t*b1, *b2;\n\n\t\t\t\tif (TilemapRow & 0x20)\n\t\t\t\t{\n\t\t\t\t\tb1 = SC2;\n\t\t\t\t\tb2 = SC3;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tb1 = SC0;\n\t\t\t\t\tb2 = SC1;\n\t\t\t\t}\n\n\t\t\t\tb1 += (TilemapRow & 0x1f) << 5;\n\t\t\t\tb2 += (TilemapRow & 0x1f) << 5;\n\n\t\t\t\tuint32\tHPos = (HOffset + Left) & OffsetMask;\n\t\t\t\tuint32\tHTile = HPos >> 3;\n\t\t\t\tuint16\t*t;\n\n\t\t\t\tif (BG.TileSizeH == 8)\n\t\t\t\t{\n\t\t\t\t\tif (HTile > 31)\n\t\t\t\t\t\tt = b2 + (HTile & 0x1f);\n\t\t\t\t\telse\n\t\t\t\t\t\tt = b1 + HTile;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (HTile > 63)\n\t\t\t\t\t\tt = b2 + ((HTile >> 1) & 0x1f);\n\t\t\t\t\telse\n\t\t\t\t\t\tt = b1 + (HTile >> 1);\n\t\t\t\t}\n\n\t\t\t\tuint32\tl = HPos & 7;\n\t\t\t\tuint32\tw = 8 - l;\n\t\t\t\tif (w > Width)\n\t\t\t\t\tw = Width;\n\n\t\t\t\tOffset -= l * PixWidth;\n\t\t\t\tTile = READ_WORD(t);\n\t\t\t\tGFX.Z1 = GFX.Z2 = (Tile & 0x2000) ? Zh : Zl;\n\n\t\t\t\tif (BG.TileSizeV == 16)\n\t\t\t\t\tTile = TILE_PLUS(Tile, ((Tile & V_FLIP) ? t2 : t1));\n\n\t\t\t\tif (BG.TileSizeH == 8)\n\t\t\t\t{\n\t\t\t\t\tDrawClippedTile(Tile, Offset, l, w, VirtAlign, 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!(Tile & H_FLIP))\n\t\t\t\t\t\tDrawClippedTile(TILE_PLUS(Tile, (HTile & 1)), Offset, l, w, VirtAlign, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tDrawClippedTile(TILE_PLUS(Tile, 1 - (HTile & 1)), Offset, l, w, VirtAlign, 1);\n\t\t\t\t}\n\n\t\t\t\tLeft += w;\n\t\t\t\tOffset += 8 * PixWidth;\n\t\t\t\tWidth -= w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void DrawBackgroundOffsetMosaic (int bg, uint8 Zh, uint8 Zl, int VOffOff)\n{\n\tBG.TileAddress = PPU.BG[bg].NameBase << 1;\n\n\tuint32\tTile;\n\tuint16\t*SC0, *SC1, *SC2, *SC3;\n\tuint16\t*BPS0, *BPS1, *BPS2, *BPS3;\n\n\tBPS0 = (uint16 *) &Memory.VRAM[PPU.BG[2].SCBase << 1];\n\tBPS1 = (PPU.BG[2].SCSize & 1) ? BPS0 + 1024 : BPS0;\n\tif (BPS1 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tBPS1 -= 0x8000;\n\tBPS2 = (PPU.BG[2].SCSize & 2) ? BPS1 + 1024 : BPS0;\n\tif (BPS2 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tBPS2 -= 0x8000;\n\tBPS3 = (PPU.BG[2].SCSize & 1) ? BPS2 + 1024 : BPS2;\n\tif (BPS3 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tBPS3 -= 0x8000;\n\n\tSC0 = (uint16 *) &Memory.VRAM[PPU.BG[bg].SCBase << 1];\n\tSC1 = (PPU.BG[bg].SCSize & 1) ? SC0 + 1024 : SC0;\n\tif (SC1 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC1 -= 0x8000;\n\tSC2 = (PPU.BG[bg].SCSize & 2) ? SC1 + 1024 : SC0;\n\tif (SC2 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC2 -= 0x8000;\n\tSC3 = (PPU.BG[bg].SCSize & 1) ? SC2 + 1024 : SC2;\n\tif (SC3 >= (uint16 *) (Memory.VRAM + 0x10000))\n\t\tSC3 -= 0x8000;\n\n\tint\tLines;\n\tint\tOffsetMask   = (BG.TileSizeH   == 16) ? 0x3ff : 0x1ff;\n\tint\tOffsetShift  = (BG.TileSizeV   == 16) ? 4 : 3;\n\tint\tOffset2Shift = (BG.OffsetSizeV == 16) ? 4 : 3;\n\tint\tOffsetEnableMask = 0x2000 << bg;\n\tint\tPixWidth = IPPU.DoubleWidthPixels ? 2 : 1;\n\tbool8\tHiresInterlace = IPPU.Interlace && IPPU.DoubleWidthPixels;\n\n\tvoid (*DrawPix) (uint32, uint32, uint32, uint32, uint32, uint32);\n\n\tint\tMosaicStart = ((uint32) GFX.StartY - PPU.MosaicStart) % PPU.Mosaic;\n\n\tfor (int clip = 0; clip < GFX.Clip[bg].Count; clip++)\n\t{\n\t\tGFX.ClipColors = !(GFX.Clip[bg].DrawMode[clip] & 1);\n\n\t\tif (BG.EnableMath && (GFX.Clip[bg].DrawMode[clip] & 2))\n\t\t\tDrawPix = GFX.DrawMosaicPixelMath;\n\t\telse\n\t\t\tDrawPix = GFX.DrawMosaicPixelNomath;\n\n\t\tfor (uint32 Y = GFX.StartY - MosaicStart; Y <= GFX.EndY; Y += PPU.Mosaic)\n\t\t{\n\t\t\tuint32\tY2 = HiresInterlace ? Y * 2 : Y;\n\t\t\tuint32\tVOff = LineData[Y + MosaicStart].BG[2].VOffset - 1;\n\t\t\tuint32\tHOff = LineData[Y + MosaicStart].BG[2].HOffset;\n\n\t\t\tLines = PPU.Mosaic - MosaicStart;\n\t\t\tif (Y + MosaicStart + Lines > GFX.EndY)\n\t\t\t\tLines = GFX.EndY - Y - MosaicStart + 1;\n\n\t\t\tuint32\tHOffsetRow = VOff >> Offset2Shift;\n\t\t\tuint32\tVOffsetRow = (VOff + VOffOff) >> Offset2Shift;\n\t\t\tuint16\t*s, *s1, *s2;\n\n\t\t\tif (HOffsetRow & 0x20)\n\t\t\t{\n\t\t\t\ts1 = BPS2;\n\t\t\t\ts2 = BPS3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts1 = BPS0;\n\t\t\t\ts2 = BPS1;\n\t\t\t}\n\n\t\t\ts1 += (HOffsetRow & 0x1f) << 5;\n\t\t\ts2 += (HOffsetRow & 0x1f) << 5;\n\t\t\ts = ((VOffsetRow & 0x20) ? BPS2 : BPS0) + ((VOffsetRow & 0x1f) << 5);\n\t\t\tint32\tVOffsetOffset = s - s1;\n\n\t\t\tuint32\tLeft =  GFX.Clip[bg].Left[clip];\n\t\t\tuint32\tRight = GFX.Clip[bg].Right[clip];\n\t\t\tuint32\tOffset = Left * PixWidth + (Y + MosaicStart) * GFX.PPL;\n\t\t\tuint32\tHScroll = LineData[Y + MosaicStart].BG[bg].HOffset;\n\t\t\tuint32\tWidth = Right - Left;\n\n\t\t\twhile (Left < Right)\n\t\t\t{\n\t\t\t\tuint32\tVOffset, HOffset;\n\n\t\t\t\tif (Left < (8 - (HScroll & 7)))\n\t\t\t\t{\n\t\t\t\t\t// SNES cannot do OPT for leftmost tile column\n\t\t\t\t\tVOffset = LineData[Y + MosaicStart].BG[bg].VOffset;\n\t\t\t\t\tHOffset = HScroll;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint HOffTile = (((Left + (HScroll & 7)) - 8) + (HOff & ~7)) >> 3;\n\n\t\t\t\t\tif (BG.OffsetSizeH == 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (HOffTile > 31)\n\t\t\t\t\t\t\ts = s2 + (HOffTile & 0x1f);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ts = s1 + HOffTile;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (HOffTile > 63)\n\t\t\t\t\t\t\ts = s2 + ((HOffTile >> 1) & 0x1f);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ts = s1 + (HOffTile >> 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tuint16\tHCellOffset = READ_WORD(s);\n\t\t\t\t\tuint16\tVCellOffset;\n\n\t\t\t\t\tif (VOffOff)\n\t\t\t\t\t\tVCellOffset = READ_WORD(s + VOffsetOffset);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (HCellOffset & 0x8000)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVCellOffset = HCellOffset;\n\t\t\t\t\t\t\tHCellOffset = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tVCellOffset = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (VCellOffset & OffsetEnableMask)\n\t\t\t\t\t\tVOffset = VCellOffset + 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tVOffset = LineData[Y + MosaicStart].BG[bg].VOffset;\n\n\t\t\t\t\tif (HCellOffset & OffsetEnableMask)\n\t\t\t\t\t\tHOffset = (HCellOffset & ~7) | (HScroll & 7);\n\t\t\t\t\telse\n\t\t\t\t\t\tHOffset = HScroll;\n\t\t\t\t}\n\n\t\t\t\tif (HiresInterlace)\n\t\t\t\t\tVOffset++;\n\n\t\t\t\tuint32\tt1, t2;\n\t\t\t\tint\t\tVirtAlign = (((Y2 + VOffset) & 7) >> (HiresInterlace ? 1 : 0)) << 3;\n\t\t\t\tint\t\tTilemapRow = (VOffset + Y2) >> OffsetShift;\n\t\t\t\tBG.InterlaceLine = ((VOffset + Y2) & 1) << 3;\n\n\t\t\t\tif ((VOffset + Y2) & 8)\n\t\t\t\t{\n\t\t\t\t\tt1 = 16;\n\t\t\t\t\tt2 = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tt1 = 0;\n\t\t\t\t\tt2 = 16;\n\t\t\t\t}\n\n\t\t\t\tuint16\t*b1, *b2;\n\n\t\t\t\tif (TilemapRow & 0x20)\n\t\t\t\t{\n\t\t\t\t\tb1 = SC2;\n\t\t\t\t\tb2 = SC3;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tb1 = SC0;\n\t\t\t\t\tb2 = SC1;\n\t\t\t\t}\n\n\t\t\t\tb1 += (TilemapRow & 0x1f) << 5;\n\t\t\t\tb2 += (TilemapRow & 0x1f) << 5;\n\n\t\t\t\tuint32\tHPos = (HOffset + Left - (Left % PPU.Mosaic)) & OffsetMask;\n\t\t\t\tuint32\tHTile = HPos >> 3;\n\t\t\t\tuint16\t*t;\n\n\t\t\t\tif (BG.TileSizeH == 8)\n\t\t\t\t{\n\t\t\t\t\tif (HTile > 31)\n\t\t\t\t\t\tt = b2 + (HTile & 0x1f);\n\t\t\t\t\telse\n\t\t\t\t\t\tt = b1 + HTile;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (HTile > 63)\n\t\t\t\t\t\tt = b2 + ((HTile >> 1) & 0x1f);\n\t\t\t\t\telse\n\t\t\t\t\t\tt = b1 + (HTile >> 1);\n\t\t\t\t}\n\n\t\t\t\tuint32\tw = PPU.Mosaic - (Left % PPU.Mosaic);\n\t\t\t\tif (w > Width)\n\t\t\t\t\tw = Width;\n\n\t\t\t\tTile = READ_WORD(t);\n\t\t\t\tGFX.Z1 = GFX.Z2 = (Tile & 0x2000) ? Zh : Zl;\n\n\t\t\t\tif (BG.TileSizeV == 16)\n\t\t\t\t\tTile = TILE_PLUS(Tile, ((Tile & V_FLIP) ? t2 : t1));\n\n\t\t\t\tif (BG.TileSizeH == 8)\n\t\t\t\t\tDrawPix(Tile, Offset, VirtAlign, HPos & 7, w, Lines);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!(Tile & H_FLIP))\n\t\t\t\t\t\tDrawPix(TILE_PLUS(Tile, (HTile & 1)), Offset, VirtAlign, HPos & 7, w, Lines);\n\t\t\t\t\telse\n\t\t\t\t\tif (!(Tile & V_FLIP))\n\t\t\t\t\t\tDrawPix(TILE_PLUS(Tile, 1 - (HTile & 1)), Offset, VirtAlign, HPos & 7, w, Lines);\n\t\t\t\t}\n\n\t\t\t\tLeft += w;\n\t\t\t\tOffset += w * PixWidth;\n\t\t\t\tWidth -= w;\n\t\t\t}\n\n\t\t\tMosaicStart = 0;\n\t\t}\n\t}\n}\n\nstatic inline void DrawBackgroundMode7 (int bg, void (*DrawMath) (uint32, uint32, int), void (*DrawNomath) (uint32, uint32, int), int D)\n{\n\tfor (int clip = 0; clip < GFX.Clip[bg].Count; clip++)\n\t{\n\t\tGFX.ClipColors = !(GFX.Clip[bg].DrawMode[clip] & 1);\n\n\t\tif (BG.EnableMath && (GFX.Clip[bg].DrawMode[clip] & 2))\n\t\t\tDrawMath(GFX.Clip[bg].Left[clip], GFX.Clip[bg].Right[clip], D);\n\t\telse\n\t\t\tDrawNomath(GFX.Clip[bg].Left[clip], GFX.Clip[bg].Right[clip], D);\n\t}\n}\n\nstatic inline void DrawBackdrop (void)\n{\n\tuint32\tOffset = GFX.StartY * GFX.PPL;\n\n\tfor (int clip = 0; clip < GFX.Clip[5].Count; clip++)\n\t{\n\t\tGFX.ClipColors = !(GFX.Clip[5].DrawMode[clip] & 1);\n\n\t\tif (BG.EnableMath && (GFX.Clip[5].DrawMode[clip] & 2))\n\t\t\tGFX.DrawBackdropMath(Offset, GFX.Clip[5].Left[clip], GFX.Clip[5].Right[clip]);\n\t\telse\n\t\t\tGFX.DrawBackdropNomath(Offset, GFX.Clip[5].Left[clip], GFX.Clip[5].Right[clip]);\n\t}\n}\n\nvoid S9xReRefresh (void)\n{\n\t// Be careful when calling this function from the thread other than the emulation one...\n\t// Here it's assumed no drawing occurs from the emulation thread when Settings.Paused is TRUE.\n\tif (Settings.Paused)\n\t\tS9xDeinitUpdate(IPPU.RenderedScreenWidth, IPPU.RenderedScreenHeight);\n}\n\nvoid S9xSetInfoString (const char *string)\n{\n\tif (Settings.InitialInfoStringTimeout > 0)\n\t{\n\t\tGFX.InfoString = string;\n\t\tGFX.InfoStringTimeout = Settings.InitialInfoStringTimeout;\n\t\tS9xReRefresh();\n\t}\n}\n\n#include \"var8x10font.h\"\nstatic const int font_width = 8;\nstatic const int font_height = 10;\n\nstatic inline int CharWidth(uint8 c)\n{\n\treturn font_width - var8x10font_kern[c - 32][0] - var8x10font_kern[c - 32][1];\n}\n\nstatic int StringWidth(const char* str)\n{\n\tint length = strlen(str);\n\tint pixcount = 0;\n\n\tif (length > 0)\n\t\tpixcount++;\n\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tpixcount += (CharWidth(str[i]) - 1);\n\t}\n\n\treturn pixcount;\n}\n\nstatic void VariableDisplayChar(int x, int y, uint8 c, bool monospace = false, int overlap = 0)\n{\n\tint cindex = c - 32;\n\tint crow = cindex >> 4;\n\tint ccol = cindex & 15;\n\tint cwidth = font_width - (monospace ? 0 : (var8x10font_kern[cindex][0] + var8x10font_kern[cindex][1]));\n\n\tint\tline = crow * font_height;\n\tint\toffset = ccol * font_width + (monospace ? 0 : var8x10font_kern[cindex][0]);\n\tint scale = IPPU.RenderedScreenWidth / SNES_WIDTH;\n\n\tuint16* s = GFX.Screen + y * GFX.RealPPL + x * scale;\n\n\tfor (int h = 0; h < font_height; h++, line++, s += GFX.RealPPL - cwidth * scale)\n\t{\n\t\tfor (int w = 0; w < cwidth; w++, s++)\n\t\t{\n\t\t\tif (var8x10font[line][offset + w] == '#')\n\t\t\t\t*s = Settings.DisplayColor;\n\t\t\telse if (var8x10font[line][offset + w] == '.')\n\t\t\t\t*s = 0x0000;\n\t\t\t//            else if (!monospace && w >= overlap)\n\t\t\t//                *s = (*s & 0xf7de) >> 1;\n\t\t\t//                *s = (*s & 0xe79c) >> 2;\n\n\t\t\tif (scale > 1)\n\t\t\t{\n\t\t\t\ts[1] = s[0];\n\t\t\t\ts++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid S9xVariableDisplayString(const char* string, int linesFromBottom,\tint pixelsFromLeft, bool allowWrap, int type)\n{\n\tif (GFX.ScreenBuffer.empty() || IPPU.RenderedScreenWidth == 0)\n\t\treturn;\n\n\tbool monospace = true;\n\tif (type == S9X_NO_INFO)\n\t{\n\t\tif (linesFromBottom <= 0)\n\t\t\tlinesFromBottom = 1;\n\n\t\tif (linesFromBottom >= 5 && !Settings.DisplayPressedKeys)\n\t\t{\n\t\t\tif (!Settings.DisplayPressedKeys)\n\t\t\t\tlinesFromBottom -= 3;\n\t\t\telse\n\t\t\t\tlinesFromBottom -= 1;\n\t\t}\n\n\t\tif (pixelsFromLeft > 128)\n\t\t\tpixelsFromLeft = SNES_WIDTH - StringWidth(string);\n\n\t\tmonospace = false;\n\t}\n\n\tint min_lines = 1;\n\tstd::string msg(string);\n\tfor (auto& c : msg)\n\t\tif (c == '\\n')\n\t\t\tmin_lines++;\n\tif (min_lines > linesFromBottom)\n\t\tlinesFromBottom = min_lines;\n\n\tint dst_x = pixelsFromLeft;\n\tint dst_y = IPPU.RenderedScreenHeight - (font_height)*linesFromBottom;\n\tint len = strlen(string);\n\n\tif (IPPU.RenderedScreenHeight % 224 && !Settings.ShowOverscan)\n\t\tdst_y -= 8;\n\telse if (Settings.ShowOverscan)\n\t\tdst_y += 8;\n\n\tint overlap = 0;\n\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tint cindex = (uint8)string[i] - 32;\n\t\tint char_width = font_width - (monospace ? 1 : (var8x10font_kern[cindex][0] + var8x10font_kern[cindex][1]));\n\n\t\tif (dst_x + char_width > SNES_WIDTH || string[i] == '\\n')\n\t\t{\n\t\t\tif (!allowWrap)\n\t\t\t\tbreak;\n\n\t\t\tlinesFromBottom--;\n\t\t\tdst_y = IPPU.RenderedScreenHeight - font_height * linesFromBottom;\n\t\t\tdst_x = pixelsFromLeft;\n\n\t\t\tif (dst_y >= IPPU.RenderedScreenHeight)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (string[i] == '\\n')\n\t\t\tcontinue;\n\n\t\tVariableDisplayChar(dst_x, dst_y, string[i], monospace, overlap);\n\n\t\tdst_x += char_width - 1;\n\t\toverlap = 1;\n\t}\n}\n\nstatic void DisplayStringFromBottom(const char* string, int linesFromBottom, int pixelsFromLeft, bool allowWrap)\n{\n\tif (S9xCustomDisplayString)\n\t{\n\t\tS9xCustomDisplayString(string, linesFromBottom, pixelsFromLeft, allowWrap, S9X_NO_INFO);\n\t\treturn;\n\t}\n\n\tS9xVariableDisplayString(string, linesFromBottom, pixelsFromLeft, allowWrap, S9X_NO_INFO);\n}\n\nstatic void S9xDisplayStringType(const char* string, int linesFromBottom, int pixelsFromLeft, bool allowWrap, int type)\n{\n\tif (S9xCustomDisplayString)\n\t{\n\t\tS9xCustomDisplayString(string, linesFromBottom, pixelsFromLeft, allowWrap, type);\n\t\treturn;\n\t}\n\n\tS9xVariableDisplayString(string, linesFromBottom, pixelsFromLeft, allowWrap, type);\n}\n\nstatic void DisplayTime (void)\n{\n\tchar string[10];\n\n\ttime_t rawtime;\n\tstruct tm *timeinfo;\n\n\ttime (&rawtime);\n\ttimeinfo = localtime(&rawtime);\n\n\tsprintf(string, \"%02u:%02u\", timeinfo->tm_hour, timeinfo->tm_min);\n\tS9xDisplayString(string, 0, 0, false);\n}\n\nstatic void DisplayFrameRate (void)\n{\n\tchar\tstring[10];\n\tstatic uint32 lastFrameCount = 0, calcFps = 0;\n\tstatic time_t lastTime = time(NULL);\n\n\ttime_t currTime = time(NULL);\n\tif (lastTime != currTime) {\n\t\tif (lastFrameCount < IPPU.TotalEmulatedFrames) {\n\t\t\tcalcFps = (IPPU.TotalEmulatedFrames - lastFrameCount) / (uint32)(currTime - lastTime);\n\t\t}\n\t\tlastTime = currTime;\n\t\tlastFrameCount = IPPU.TotalEmulatedFrames;\n\t}\n\tsprintf(string, \"%u fps\", calcFps);\n\tS9xDisplayString(string, 2, IPPU.RenderedScreenWidth - (font_width - 1) * strlen(string) - 1, false);\n\n#ifdef DEBUGGER\n\tconst int\tlen = 8;\n\tsprintf(string, \"%02d/%02d %02d\", (int) IPPU.DisplayedRenderedFrameCount, (int) Memory.ROMFramesPerSecond, (int) IPPU.FrameCount);\n#else\n\tconst int\tlen = 5;\n\tsprintf(string, \"%02d/%02d\",      (int) IPPU.DisplayedRenderedFrameCount, (int) Memory.ROMFramesPerSecond);\n#endif\n\n\tS9xDisplayString(string, 1, IPPU.RenderedScreenWidth - (font_width - 1) * len - 1, false);\n}\n\nstatic void DisplayPressedKeys (void)\n{\n\tstatic unsigned char\tKeyMap[]   = { '0', '1', '2', 'R', 'L', 'X', 'A', 225, 224, 227, 226, 'S', 's', 'Y', 'B' };\n\tstatic int\t\tKeyOrder[] = { 8, 10, 7, 9, 0, 6, 14, 13, 5, 1, 4, 3, 2, 11, 12 }; // < ^ > v   A B Y X  L R  S s\n\n\tenum controllers\tcontroller;\n    int\t\t\t\t\tline = Settings.DisplayMovieFrame && S9xMovieActive() ? 2 : 1;\n\tint8\t\t\t\tids[4];\n\tchar\t\t\t\tstring[255];\n\n\tfor (int port = 0; port < 2; port++)\n\t{\n\t\tS9xGetController(port, &controller, &ids[0], &ids[1], &ids[2], &ids[3]);\n\n\t\tswitch (controller)\n\t\t{\n\t\t\tcase CTL_MOUSE:\n\t\t\t{\n\t\t\t\tuint8 buf[5];\n\t\t\t\tif (!MovieGetMouse(port, buf))\n\t\t\t\t\tbreak;\n\t\t\t\tint16 x = READ_WORD(buf);\n\t\t\t\tint16 y = READ_WORD(buf + 2);\n\t\t\t\tuint8 buttons = buf[4];\n\t\t\t\tsprintf(string, \"#%d %d: (%03d,%03d) %c%c\", port + 1, ids[0] + 1, x, y,\n\t\t\t\t\t\t(buttons & 0x40) ? 'L' : ' ', (buttons & 0x80) ? 'R' : ' ');\n\t\t\t\tS9xDisplayStringType(string, line++, 1, false, S9X_PRESSED_KEYS_INFO);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase CTL_SUPERSCOPE:\n\t\t\t{\n\t\t\t\tuint8 buf[6];\n\t\t\t\tif (!MovieGetScope(port, buf))\n\t\t\t\t\tbreak;\n\t\t\t\tint16 x = READ_WORD(buf);\n\t\t\t\tint16 y = READ_WORD(buf + 2);\n\t\t\t\tuint8 buttons = buf[4];\n\t\t\t\tsprintf(string, \"#%d %d: (%03d,%03d) %c%c%c%c\", port + 1, ids[0] + 1, x, y,\n\t\t\t\t\t\t(buttons & 0x80) ? 'F' : ' ', (buttons & 0x40) ? 'C' : ' ',\n\t\t\t\t\t\t(buttons & 0x20) ? 'T' : ' ', (buttons & 0x10) ? 'P' : ' ');\n\t\t\t\tS9xDisplayStringType(string, line++, 1, false, S9X_PRESSED_KEYS_INFO);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase CTL_JUSTIFIER:\n\t\t\t{\n\t\t\t\tuint8 buf[11];\n\t\t\t\tif (!MovieGetJustifier(port, buf))\n\t\t\t\t\tbreak;\n\t\t\t\tint16 x1 = READ_WORD(buf);\n\t\t\t\tint16 x2 = READ_WORD(buf + 2);\n\t\t\t\tint16 y1 = READ_WORD(buf + 4);\n\t\t\t\tint16 y2 = READ_WORD(buf + 6);\n\t\t\t\tuint8 buttons = buf[8];\n\t\t\t\tbool8 offscreen1 = buf[9];\n\t\t\t\tbool8 offscreen2 = buf[10];\n\t\t\t\tsprintf(string, \"#%d %d: (%03d,%03d) %c%c%c / (%03d,%03d) %c%c%c\", port + 1, ids[0] + 1,\n\t\t\t\t\t\tx1, y1, (buttons & 0x80) ? 'T' : ' ', (buttons & 0x20) ? 'S' : ' ', offscreen1 ? 'O' : ' ',\n\t\t\t\t\t\tx2, y2, (buttons & 0x40) ? 'T' : ' ', (buttons & 0x10) ? 'S' : ' ', offscreen2 ? 'O' : ' ');\n\t\t\t\tS9xDisplayStringType(string, line++, 1, false, S9X_PRESSED_KEYS_INFO);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase CTL_JOYPAD:\n\t\t\t{\n\t\t\t\tsprintf(string, \"#%d %d:                  \", port + 1, ids[0] + 1);\n\t\t\t\tuint16 pad = MovieGetJoypad(ids[0]);\n\t\t\t\tfor (int i = 0; i < 15; i++)\n\t\t\t\t{\n\t\t\t\t\tint j = KeyOrder[i];\n\t\t\t\t\tint mask = (1 << (j + 1));\n\t\t\t\t\tstring[6 + i]= (pad & mask) ? KeyMap[j] : ' ';\n\t\t\t\t}\n\n\t\t\t\tS9xDisplayStringType(string, line++, 1, false, S9X_PRESSED_KEYS_INFO);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase CTL_MP5:\n\t\t\t{\n\t\t\t\tfor (int n = 0; n < 4; n++)\n\t\t\t\t{\n\t\t\t\t\tif (ids[n] != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tsprintf(string, \"#%d %d:                  \", port + 1, ids[n] + 1);\n\t\t\t\t\t\tuint16 pad = MovieGetJoypad(ids[n]);\n\t\t\t\t\t\tfor (int i = 0; i < 15; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint j = KeyOrder[i];\n\t\t\t\t\t\t\tint mask = (1 << (j + 1));\n\t\t\t\t\t\t\tstring[6 + i]= (pad & mask) ? KeyMap[j] : ' ';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tS9xDisplayStringType(string, line++, 1, false, S9X_PRESSED_KEYS_INFO);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase CTL_MACSRIFLE:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\tuint8 buf[6], *p = buf;\n\t\t\t\tMovieGetScope(port, buf);\n\t\t\t\tint16 x = READ_WORD(p);\n\t\t\t\tint16 y = READ_WORD(p + 2);\n\t\t\t\tuint8 buttons = buf[4];\n\t\t\t\tsprintf(string, \"#%d %d: (%03d,%03d) %c%c%c%c\", port, ids[0], x, y,\n\t\t\t\t\t\t(buttons & 0x80) ? 'F' : ' ', (buttons & 0x40) ? 'C' : ' ',\n\t\t\t\t\t\t(buttons & 0x20) ? 'T' : ' ', (buttons & 0x10) ? 'P' : ' ');\n\t\t\t\tS9xDisplayString(string, line++, 1, false);\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase CTL_NONE:\n\t\t\t{\n\t\t\t\t// Display Nothing\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void DisplayWatchedAddresses (void)\n{\n\tfor (unsigned int i = 0; i < sizeof(watches) / sizeof(watches[0]); i++)\n\t{\n\t\tif (!watches[i].on)\n\t\t\tbreak;\n\n\t\tint32\tdisplayNumber = 0;\n\t\tchar\tbuf[64];\n\n\t\tfor (int r = 0; r < watches[i].size; r++)\n\t\t\tdisplayNumber += (Cheat.CWatchRAM[(watches[i].address - 0x7E0000) + r]) << (8 * r);\n\n\t\tif (watches[i].format == 1)\n\t\t\tsprintf(buf, \"%s,%du = %u\", watches[i].desc, watches[i].size, (unsigned int) displayNumber);\n\t\telse\n\t\tif (watches[i].format == 3)\n\t\t\tsprintf(buf, \"%s,%dx = %X\", watches[i].desc, watches[i].size, (unsigned int) displayNumber);\n\t\telse // signed\n\t\t{\n\t\t\tif (watches[i].size == 1)\n\t\t\t\tdisplayNumber = (int32) ((int8)  displayNumber);\n\t\t\telse if (watches[i].size == 2)\n\t\t\t\tdisplayNumber = (int32) ((int16) displayNumber);\n\t\t\telse if (watches[i].size == 3)\n\t\t\t\tif (displayNumber >= 8388608)\n\t\t\t\t\tdisplayNumber -= 16777216;\n\n\t\t\tsprintf(buf, \"%s,%ds = %d\", watches[i].desc, watches[i].size, (int) displayNumber);\n\t\t}\n\n\t\tS9xDisplayString(buf, 6 + i, 1, false);\n\t}\n}\n\nvoid S9xDisplayMessages (uint16 *screen, int ppl, int width, int height, int scale)\n{\n\tif (Settings.DisplayTime)\n\t\tDisplayTime();\n\n\tif (Settings.DisplayFrameRate)\n\t\tDisplayFrameRate();\n\n\tif (Settings.DisplayWatchedAddresses)\n\t\tDisplayWatchedAddresses();\n\n\tif (Settings.DisplayPressedKeys)\n\t\tDisplayPressedKeys();\n\n\tif (Settings.DisplayMovieFrame && S9xMovieActive())\n\t\tS9xDisplayString(GFX.FrameDisplayString, 1, 1, false);\n\n\tif (!GFX.InfoString.empty())\n\t\tS9xDisplayString(GFX.InfoString.c_str(), 5, 1, true);\n}\n\nstatic uint16 get_crosshair_color (uint8 color)\n{\n\tswitch (color & 15)\n\t{\n\t\tcase  0: return (BUILD_PIXEL( 0,  0,  0)); // transparent, shouldn't be used\n\t\tcase  1: return (BUILD_PIXEL( 0,  0,  0)); // Black\n\t\tcase  2: return (BUILD_PIXEL( 8,  8,  8)); // 25Grey\n\t\tcase  3: return (BUILD_PIXEL(16, 16, 16)); // 50Grey\n\t\tcase  4: return (BUILD_PIXEL(23, 23, 23)); // 75Grey\n\t\tcase  5: return (BUILD_PIXEL(31, 31, 31)); // White\n\t\tcase  6: return (BUILD_PIXEL(31,  0,  0)); // Red\n\t\tcase  7: return (BUILD_PIXEL(31, 16,  0)); // Orange\n\t\tcase  8: return (BUILD_PIXEL(31, 31,  0)); // Yellow\n\t\tcase  9: return (BUILD_PIXEL( 0, 31,  0)); // Green\n\t\tcase 10: return (BUILD_PIXEL( 0, 31, 31)); // Cyan\n\t\tcase 11: return (BUILD_PIXEL( 0, 23, 31)); // Sky\n\t\tcase 12: return (BUILD_PIXEL( 0,  0, 31)); // Blue\n\t\tcase 13: return (BUILD_PIXEL(23,  0, 31)); // Violet\n\t\tcase 14: return (BUILD_PIXEL(31,  0, 31)); // Magenta\n\t\tcase 15: return (BUILD_PIXEL(31,  0, 16)); // Purple\n\t}\n\n\treturn (0);\n}\n\nvoid S9xDrawCrosshair (const char *crosshair, uint8 fgcolor, uint8 bgcolor, int16 x, int16 y)\n{\n\tif (!crosshair)\n\t\treturn;\n\n\tint16\tr, rx = 1, c, cx = 1, W = SNES_WIDTH, H = PPU.ScreenHeight;\n\tuint16\tfg, bg;\n\n\tx -= 7;\n\ty -= 7;\n\n\tif (IPPU.DoubleWidthPixels)  { cx = 2; x *= 2; W *= 2; }\n\tif (IPPU.DoubleHeightPixels) { rx = 2; y *= 2; H *= 2; }\n\n\tfg = get_crosshair_color(fgcolor);\n\tbg = get_crosshair_color(bgcolor);\n\n\tuint16\t*s = GFX.Screen + y * (int32)GFX.RealPPL + x;\n\n\tfor (r = 0; r < 15 * rx; r++, s += GFX.RealPPL - 15 * cx)\n\t{\n\t\tif (y + r < 0)\n\t\t{\n\t\t\ts += 15 * cx;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (y + r >= H)\n\t\t\tbreak;\n\n\t\tfor (c = 0; c < 15 * cx; c++, s++)\n\t\t{\n\t\t\tif (x + c < 0 || s < GFX.Screen)\n\t\t\t\tcontinue;\n\n\t\t\tif (x + c >= W)\n\t\t\t{\n\t\t\t\ts += 15 * cx - c;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuint8\tp = crosshair[(r / rx) * 15 + (c / cx)];\n\n\t\t\tif (p == '#' && fgcolor)\n\t\t\t\t*s = (fgcolor & 0x10) ? COLOR_ADD::fn1_2(fg, *s) : fg;\n\t\t\telse\n\t\t\tif (p == '.' && bgcolor)\n\t\t\t\t*s = (bgcolor & 0x10) ? COLOR_ADD::fn1_2(*s, bg) : bg;\n\t\t}\n\t}\n}\n\n"
        },
        {
          "name": "gfx.h",
          "type": "blob",
          "size": 6.4580078125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _GFX_H_\n#define _GFX_H_\n\n#include \"port.h\"\n#include <vector>\n\nstruct SGFX\n{\n\tconst uint32 Pitch = sizeof(uint16) * MAX_SNES_WIDTH;\n\tconst uint32 RealPPL = MAX_SNES_WIDTH; // true PPL of Screen buffer\n\tconst uint32 ScreenSize =  MAX_SNES_WIDTH * MAX_SNES_HEIGHT;\n\tstd::vector<uint16> ScreenBuffer;\n\tuint16\t*Screen;\n\tuint16\t*SubScreen;\n\tuint8\t*ZBuffer;\n\tuint8\t*SubZBuffer;\n\tuint16\t*S;\n\tuint8\t*DB;\n\tuint16\t*ZERO;\n\tuint32\tPPL;\t\t\t\t// number of pixels on each of Screen buffer\n\tuint32\tLinesPerTile;\t\t// number of lines in 1 tile (4 or 8 due to interlace)\n\tuint16\t*ScreenColors;\t\t// screen colors for rendering main\n\tuint16\t*RealScreenColors;\t// screen colors, ignoring color window clipping\n\tuint8\tZ1;\t\t\t\t\t// depth for comparison\n\tuint8\tZ2;\t\t\t\t\t// depth to save\n\tuint32\tFixedColour;\n\tuint8\tDoInterlace;\n\tuint32\tStartY;\n\tuint32\tEndY;\n\tbool8\tClipColors;\n\tuint8\tOBJWidths[128];\n\tuint8\tOBJVisibleTiles[128];\n\n\tstruct ClipData\t*Clip;\n\n\tstruct\n\t{\n\t\tuint8\tRTOFlags;\n\t\tint16\tTiles;\n\n\t\tstruct\n\t\t{\n\t\t\tint8\tSprite;\n\t\t\tuint8\tLine;\n\t\t}\tOBJ[128];\n\t}\tOBJLines[SNES_HEIGHT_EXTENDED];\n\n\tvoid\t(*DrawBackdropMath) (uint32, uint32, uint32);\n\tvoid\t(*DrawBackdropNomath) (uint32, uint32, uint32);\n\tvoid\t(*DrawTileMath) (uint32, uint32, uint32, uint32);\n\tvoid\t(*DrawTileNomath) (uint32, uint32, uint32, uint32);\n\tvoid\t(*DrawClippedTileMath) (uint32, uint32, uint32, uint32, uint32, uint32);\n\tvoid\t(*DrawClippedTileNomath) (uint32, uint32, uint32, uint32, uint32, uint32);\n\tvoid\t(*DrawMosaicPixelMath) (uint32, uint32, uint32, uint32, uint32, uint32);\n\tvoid\t(*DrawMosaicPixelNomath) (uint32, uint32, uint32, uint32, uint32, uint32);\n\tvoid\t(*DrawMode7BG1Math) (uint32, uint32, int);\n\tvoid\t(*DrawMode7BG1Nomath) (uint32, uint32, int);\n\tvoid\t(*DrawMode7BG2Math) (uint32, uint32, int);\n\tvoid\t(*DrawMode7BG2Nomath) (uint32, uint32, int);\n\n\tstd::string InfoString;\n\tuint32\tInfoStringTimeout;\n\tchar\tFrameDisplayString[256];\n};\n\nstruct SBG\n{\n\tuint8\t(*ConvertTile) (uint8 *, uint32, uint32);\n\tuint8\t(*ConvertTileFlip) (uint8 *, uint32, uint32);\n\n\tuint32\tTileSizeH;\n\tuint32\tTileSizeV;\n\tuint32\tOffsetSizeH;\n\tuint32\tOffsetSizeV;\n\tuint32\tTileShift;\n\tuint32\tTileAddress;\n\tuint32\tNameSelect;\n\tuint32\tSCBase;\n\n\tuint32\tStartPalette;\n\tuint32\tPaletteShift;\n\tuint32\tPaletteMask;\n\tuint8\tEnableMath;\n\tuint8\tInterlaceLine;\n\n\tuint8\t*Buffer;\n\tuint8\t*BufferFlip;\n\tuint8\t*Buffered;\n\tuint8\t*BufferedFlip;\n\tbool8\tDirectColourMode;\n};\n\nstruct SLineData\n{\n\tstruct\n\t{\n\t\tuint16\tVOffset;\n\t\tuint16\tHOffset;\n\t}\tBG[4];\n};\n\nstruct SLineMatrixData\n{\n\tshort\tMatrixA;\n\tshort\tMatrixB;\n\tshort\tMatrixC;\n\tshort\tMatrixD;\n\tshort\tCentreX;\n\tshort\tCentreY;\n\tshort\tM7HOFS;\n\tshort\tM7VOFS;\n};\n\nextern uint16\t\tBlackColourMap[256];\nextern uint16\t\tDirectColourMaps[8][256];\nextern uint8\t\tmul_brightness[16][32];\nextern uint8\t\tbrightness_cap[64];\nextern struct SBG\tBG;\nextern struct SGFX\tGFX;\n\n#define H_FLIP\t\t0x4000\n#define V_FLIP\t\t0x8000\n#define BLANK_TILE\t2\n\nstruct COLOR_ADD\n{\n\tstatic alwaysinline uint16 fn(uint16 C1, uint16 C2)\n\t{\n\t\tconst int RED_MASK = 0x1F << RED_SHIFT_BITS;\n\t\tconst int GREEN_MASK = 0x1F << GREEN_SHIFT_BITS;\n\t\tconst int BLUE_MASK = 0x1F;\n\n\t\tint rb = C1 & (RED_MASK | BLUE_MASK);\n\t\trb += C2 & (RED_MASK | BLUE_MASK);\n\t\tint rbcarry = rb & ((0x20 << RED_SHIFT_BITS) | (0x20 << 0));\n\t\tint g = (C1 & (GREEN_MASK)) + (C2 & (GREEN_MASK));\n\t\tint rgbsaturate = (((g & (0x20 << GREEN_SHIFT_BITS)) | rbcarry) >> 5) * 0x1f;\n\t\tuint16 retval = (rb & (RED_MASK | BLUE_MASK)) | (g & GREEN_MASK) | rgbsaturate;\n#if GREEN_SHIFT_BITS == 6\n\t\tretval |= (retval & 0x0400) >> 5;\n#endif\n\t\treturn retval;\n\t}\n\n\tstatic alwaysinline uint16 fn1_2(uint16 C1, uint16 C2)\n\t{\n\t\treturn ((((C1 & RGB_REMOVE_LOW_BITS_MASK) +\n\t\t\t(C2 & RGB_REMOVE_LOW_BITS_MASK)) >> 1) +\n\t\t\t(C1 & C2 & RGB_LOW_BITS_MASK)) | ALPHA_BITS_MASK;\n\t}\n};\n\nstruct COLOR_ADD_BRIGHTNESS\n{\n\tstatic alwaysinline uint16 fn(uint16 C1, uint16 C2)\n\t{\n\t\treturn ((brightness_cap[ (C1 >> RED_SHIFT_BITS)           +  (C2 >> RED_SHIFT_BITS)          ] << RED_SHIFT_BITS)   |\n\t\t\t\t(brightness_cap[((C1 >> GREEN_SHIFT_BITS) & 0x1f) + ((C2 >> GREEN_SHIFT_BITS) & 0x1f)] << GREEN_SHIFT_BITS) |\n\t// Proper 15->16bit color conversion moves the high bit of green into the low bit.\n\t#if GREEN_SHIFT_BITS == 6\n\t\t\t   ((brightness_cap[((C1 >> 6) & 0x1f) + ((C2 >> 6) & 0x1f)] & 0x10) << 1) |\n\t#endif\n\t\t\t\t(brightness_cap[ (C1                      & 0x1f) +  (C2                      & 0x1f)]      ));\n\t}\n\n\tstatic alwaysinline uint16 fn1_2(uint16 C1, uint16 C2)\n\t{\n\t\treturn COLOR_ADD::fn1_2(C1, C2);\n\t}\n};\n\n\nstruct COLOR_SUB\n{\n\tstatic alwaysinline uint16 fn(uint16 C1, uint16 C2)\n\t{\n\t\tint rb1 = (C1 & (THIRD_COLOR_MASK | FIRST_COLOR_MASK)) | ((0x20 << 0) | (0x20 << RED_SHIFT_BITS));\n\t\tint rb2 = C2 & (THIRD_COLOR_MASK | FIRST_COLOR_MASK);\n\t\tint rb = rb1 - rb2;\n\t\tint rbcarry = rb & ((0x20 << RED_SHIFT_BITS) | (0x20 << 0));\n\t\tint g = ((C1 & (SECOND_COLOR_MASK)) | (0x20 << GREEN_SHIFT_BITS)) - (C2 & (SECOND_COLOR_MASK));\n\t\tint rgbsaturate = (((g & (0x20 << GREEN_SHIFT_BITS)) | rbcarry) >> 5) * 0x1f;\n\t\tuint16 retval = ((rb & (THIRD_COLOR_MASK | FIRST_COLOR_MASK)) | (g & SECOND_COLOR_MASK)) & rgbsaturate;\n#if GREEN_SHIFT_BITS == 6\n\t\tretval |= (retval & 0x0400) >> 5;\n#endif\n\t\treturn retval;\n\t}\n\n\tstatic alwaysinline uint16 fn1_2(uint16 C1, uint16 C2)\n\t{\n\t\treturn GFX.ZERO[((C1 | RGB_HI_BITS_MASKx2) -\n\t\t\t(C2 & RGB_REMOVE_LOW_BITS_MASK)) >> 1];\n\t}\n};\n\nvoid S9xStartScreenRefresh (void);\nvoid S9xEndScreenRefresh (void);\nvoid S9xBuildDirectColourMaps (void);\nvoid RenderLine (uint8);\nvoid S9xComputeClipWindows (void);\nvoid S9xDisplayChar (uint16 *, uint8);\nvoid S9xGraphicsScreenResize (void);\n// called automatically unless Settings.AutoDisplayMessages is false\nvoid S9xDisplayMessages (uint16 *, int, int, int, int);\n\n// external port interface which must be implemented or initialised for each port\nbool8 S9xGraphicsInit (void);\nvoid S9xGraphicsDeinit (void);\nbool8 S9xInitUpdate (void);\nbool8 S9xDeinitUpdate (int, int);\nbool8 S9xContinueUpdate (int, int);\nvoid S9xReRefresh (void);\nvoid S9xSyncSpeed (void);\n\n// called instead of S9xDisplayString if set to non-NULL\nextern void (*S9xCustomDisplayString) (const char *, int, int, bool, int type);\nvoid S9xVariableDisplayString(const char* string, int linesFromBottom, int pixelsFromLeft, bool allowWrap, int type);\n\n#endif\n"
        },
        {
          "name": "globals.cpp",
          "type": "blob",
          "size": 8.80859375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"dma.h\"\n#include \"apu/apu.h\"\n#include \"fxinst.h\"\n#include \"fxemu.h\"\n#include \"srtc.h\"\n#include \"cheats.h\"\n#ifdef NETPLAY_SUPPORT\n#include \"netplay.h\"\n#endif\n#ifdef DEBUGGER\n#include \"debug.h\"\n#include \"missing.h\"\n#endif\n\nstruct SCPUState\t\tCPU;\nstruct SICPU\t\t\tICPU;\nstruct SRegisters\t\tRegisters;\nstruct SPPU\t\t\t\tPPU;\nstruct InternalPPU\t\tIPPU;\nstruct SDMA\t\t\t\tDMA[8];\nstruct STimings\t\t\tTimings;\nstruct SGFX\t\t\t\tGFX;\nstruct SBG\t\t\t\tBG;\nstruct SLineData\t\tLineData[240];\nstruct SLineMatrixData\tLineMatrixData[240];\nstruct SDSP0\t\t\tDSP0;\nstruct SDSP1\t\t\tDSP1;\nstruct SDSP2\t\t\tDSP2;\nstruct SDSP3\t\t\tDSP3;\nstruct SDSP4\t\t\tDSP4;\nstruct SSA1\t\t\t\tSA1;\nstruct SSA1Registers\tSA1Registers;\nstruct FxRegs_s\t\t\tGSU;\nstruct FxInfo_s\t\t\tSuperFX;\nstruct SST010\t\t\tST010;\nstruct SST011\t\t\tST011;\nstruct SST018\t\t\tST018;\nstruct SOBC1\t\t\tOBC1;\nstruct SSPC7110Snapshot\ts7snap;\nstruct SSRTCSnapshot\tsrtcsnap;\nstruct SRTCData\t\t\tRTCData;\nstruct SBSX\t\t\t\tBSX;\nstruct SMSU1\t\t\tMSU1;\nstruct SMulti\t\t\tMulti;\nstruct SSettings\t\tSettings;\nstruct SSNESGameFixes\tSNESGameFixes;\n#ifdef NETPLAY_SUPPORT\nstruct SNetPlay\t\t\tNetPlay;\n#endif\n#ifdef DEBUGGER\nstruct Missing\t\t\tmissing;\n#endif\nstruct SCheatData\t\tCheat;\nstruct Watch\t\t\twatches[16];\nCMemory\t\t\t\t\tMemory;\n\nchar\tString[513];\nuint8\tOpenBus = 0;\nuint8\t*HDMAMemPointers[8];\nuint16\tBlackColourMap[256];\nuint16\tDirectColourMaps[8][256];\n\nSnesModel\tM1SNES = { 1, 3, 2 };\nSnesModel\tM2SNES = { 2, 4, 3 };\nSnesModel\t*Model = &M1SNES;\n\nuint16 SignExtend[2] =\n{\n\t0x0000,\n\t0xff00\n};\n\nint HDMA_ModeByteCounts[8] =\n{\n\t1, 2, 2, 4, 4, 4, 2, 4\n};\n\nuint8 mul_brightness[16][32] =\n{\n\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n\t  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02 },\n\t{ 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,\n\t  0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04 },\n\t{ 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03,\n\t  0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06 },\n\t{ 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04,\n\t  0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08 },\n\t{ 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05,\n\t  0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a },\n\t{ 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06,\n\t  0x06, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c, 0x0c, 0x0c },\n\t{ 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x07,\n\t  0x07, 0x08, 0x08, 0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c, 0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0e },\n\t{ 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08,\n\t  0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c, 0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f, 0x10, 0x11 },\n\t{ 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x07, 0x07, 0x08, 0x08, 0x09,\n\t  0x0a, 0x0a, 0x0b, 0x0b, 0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x10, 0x10, 0x11, 0x11, 0x12, 0x13 },\n\t{ 0x00, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x07, 0x08, 0x09, 0x09, 0x0a,\n\t  0x0b, 0x0b, 0x0c, 0x0d, 0x0d, 0x0e, 0x0f, 0x0f, 0x10, 0x11, 0x11, 0x12, 0x13, 0x13, 0x14, 0x15 },\n\t{ 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0a, 0x0a, 0x0b,\n\t  0x0c, 0x0c, 0x0d, 0x0e, 0x0f, 0x0f, 0x10, 0x11, 0x12, 0x12, 0x13, 0x14, 0x15, 0x15, 0x16, 0x17 },\n\t{ 0x00, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0a, 0x0b, 0x0c,\n\t  0x0d, 0x0e, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x12, 0x13, 0x14, 0x15, 0x16, 0x16, 0x17, 0x18, 0x19 },\n\t{ 0x00, 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0a, 0x0b, 0x0c, 0x0d,\n\t  0x0e, 0x0f, 0x10, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x17, 0x18, 0x19, 0x1a, 0x1b },\n\t{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,\n\t  0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d },\n\t{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }\n};\n\nuint8 brightness_cap[64];\n\nuint8 S9xOpLengthsM0X0[256] =\n{\n//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 0\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 1\n\t3, 2, 4, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 2\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 3\n\t1, 2, 2, 2, 3, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 4\n\t2, 2, 2, 2, 3, 2, 2, 2, 1, 3, 1, 1, 4, 3, 3, 4, // 5\n\t1, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 6\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 7\n\t2, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 8\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 9\n\t3, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // A\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // B\n\t3, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // C\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // D\n\t3, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // E\n\t2, 2, 2, 2, 3, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4  // F\n};\n\nuint8 S9xOpLengthsM0X1[256] =\n{\n//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 0\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 1\n\t3, 2, 4, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 2\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 3\n\t1, 2, 2, 2, 3, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 4\n\t2, 2, 2, 2, 3, 2, 2, 2, 1, 3, 1, 1, 4, 3, 3, 4, // 5\n\t1, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 6\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 7\n\t2, 2, 3, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 8\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 9\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // A\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // B\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // C\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // D\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // E\n\t2, 2, 2, 2, 3, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4  // F\n};\n\nuint8 S9xOpLengthsM1X0[256] =\n{\n//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // 0\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 1\n\t3, 2, 4, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // 2\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 3\n\t1, 2, 2, 2, 3, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // 4\n\t2, 2, 2, 2, 3, 2, 2, 2, 1, 3, 1, 1, 4, 3, 3, 4, // 5\n\t1, 2, 3, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // 6\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 7\n\t2, 2, 3, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // 8\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 9\n\t3, 2, 3, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // A\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // B\n\t3, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // C\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // D\n\t3, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // E\n\t2, 2, 2, 2, 3, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4  // F\n};\n\nuint8 S9xOpLengthsM1X1[256] =\n{\n//  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // 0\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 1\n\t3, 2, 4, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // 2\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 3\n\t1, 2, 2, 2, 3, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // 4\n\t2, 2, 2, 2, 3, 2, 2, 2, 1, 3, 1, 1, 4, 3, 3, 4, // 5\n\t1, 2, 3, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // 6\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 7\n\t2, 2, 3, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // 8\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // 9\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // A\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // B\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // C\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4, // D\n\t2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 3, 4, // E\n\t2, 2, 2, 2, 3, 2, 2, 2, 1, 3, 1, 1, 3, 3, 3, 4  // F\n};\n"
        },
        {
          "name": "gtk",
          "type": "tree",
          "content": null
        },
        {
          "name": "jma",
          "type": "tree",
          "content": null
        },
        {
          "name": "language.h",
          "type": "blob",
          "size": 1.3505859375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _LANGUAGE_H_\n#define _LANGUAGE_H_\n\n// Movie Messages\n#define MOVIE_ERR_SNAPSHOT_WRONG_MOVIE\t\"Snapshot not from this movie\"\n#define MOVIE_ERR_SNAPSHOT_NOT_MOVIE\t\"Not a movie snapshot\"\n#define MOVIE_INFO_REPLAY\t\t\t\t\"Movie replay\"\n#define MOVIE_INFO_RECORD\t\t\t\t\"Movie record\"\n#define MOVIE_INFO_RERECORD\t\t\t\t\"Movie re-record\"\n#define MOVIE_INFO_REWIND\t\t\t\t\"Movie rewind\"\n#define MOVIE_INFO_STOP\t\t\t\t\t\"Movie stop\"\n#define MOVIE_INFO_END\t\t\t\t\t\"Movie end\"\n#define MOVIE_INFO_SNAPSHOT\t\t\t\t\"Movie snapshot\"\n#define MOVIE_ERR_SNAPSHOT_INCONSISTENT\t\"Snapshot inconsistent with movie\"\n\n// Snapshot Messages\n#define SAVE_INFO_SNAPSHOT\t\t\t\t\"Saved\"\n#define SAVE_INFO_LOAD\t\t\t\t\t\"Loaded\"\n#define SAVE_INFO_OOPS\t\t\t\t\t\"Auto-saving 'oops' snapshot\"\n#define SAVE_ERR_WRONG_FORMAT\t\t\t\"File not in Snes9x snapshot format\"\n#define SAVE_ERR_WRONG_VERSION\t\t\t\"Incompatible snapshot version\"\n#define SAVE_ERR_ROM_NOT_FOUND\t\t\t\"ROM image \\\"%s\\\" for snapshot not found\"\n#define SAVE_ERR_SAVE_NOT_FOUND\t\t\t\"Snapshot %s does not exist\"\n\n#endif\n"
        },
        {
          "name": "libretro",
          "type": "tree",
          "content": null
        },
        {
          "name": "loadzip.cpp",
          "type": "blob",
          "size": 3.49609375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifdef UNZIP_SUPPORT\n\n#include <assert.h>\n#include <ctype.h>\n#ifdef SYSTEM_ZIP\n#include <minizip/unzip.h>\n#else\n#include \"unzip/unzip.h\"\n#endif\n#include \"snes9x.h\"\n#include \"memmap.h\"\n\n\nbool8 LoadZip (const char *zipname, uint32 *TotalFileSize, uint8 *buffer)\n{\n\t*TotalFileSize = 0;\n\n\tunzFile\tfile = unzOpen(zipname);\n\tif (file == NULL)\n\t\treturn (FALSE);\n\n\t// find largest file in zip file (under MAX_ROM_SIZE) or a file with extension .1, or a file named program.rom\n\tchar\tfilename[132];\n\tuint32\tfilesize = 0;\n\tint\t\tport = unzGoToFirstFile(file);\n\n\tunz_file_info\tinfo;\n\n\twhile (port == UNZ_OK)\n\t{\n\t\tchar\tname[132];\n\t\tunzGetCurrentFileInfo(file, &info, name, 128, NULL, 0, NULL, 0);\n\n\t\tif (info.uncompressed_size > CMemory::MAX_ROM_SIZE + 512)\n\t\t{\n\t\t\tport = unzGoToNextFile(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (info.uncompressed_size > filesize)\n\t\t{\n\t\t\tstrcpy(filename, name);\n\t\t\tfilesize = info.uncompressed_size;\n\t\t}\n\n\t\tint\tlen = strlen(name);\n\t\tif (len > 2 && name[len - 2] == '.' && name[len - 1] == '1')\n\t\t{\n\t\t\tstrcpy(filename, name);\n\t\t\tfilesize = info.uncompressed_size;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strncasecmp(name, \"program.rom\", 11) == 0)\n\t\t{\n\t\t\tstrcpy(filename, name);\n\t\t\tfilesize = info.uncompressed_size;\n\t\t\tbreak;\n\t\t}\n\n\t\tport = unzGoToNextFile(file);\n\t}\n\n\tint len = strlen(zipname);\n\tif (!(port == UNZ_END_OF_LIST_OF_FILE || port == UNZ_OK) || filesize == 0 ||\n\t\t(len > 5 && strcasecmp(zipname + len - 5, \".msu1\") == 0 && strcasecmp(filename, \"program.rom\") != 0))\n\t{\n\t\tif (unzClose(file) != UNZ_OK)\n\t\t\tassert(FALSE);\n\t\treturn (FALSE);\n\t}\n\n\t// find extension\n\tchar\ttmp[2] = { 0, 0 };\n\tchar\t*ext = strrchr(filename, '.');\n\tif (ext)\n\t\text++;\n\telse\n\t\text = tmp;\n\n\tuint8\t*ptr = buffer;\n\tbool8\tmore = FALSE;\n\n\tunzLocateFile(file, filename, 0);\n\tunzGetCurrentFileInfo(file, &info, filename, 128, NULL, 0, NULL, 0);\n\n\tif (unzOpenCurrentFile(file) != UNZ_OK)\n\t{\n\t\tunzClose(file);\n\t\treturn (FALSE);\n\t}\n\n\tdo\n\t{\n\t\tassert(info.uncompressed_size <= CMemory::MAX_ROM_SIZE + 512);\n\n\t\tuint32 FileSize = info.uncompressed_size;\n\t\tint\tl = unzReadCurrentFile(file, ptr, FileSize);\n\n\t\tif (unzCloseCurrentFile(file) == UNZ_CRCERROR)\n\t\t{\n\t\t\tunzClose(file);\n\t\t\treturn (FALSE);\n\t\t}\n\n\t\tif (l <= 0 || l != (int) FileSize)\n\t\t{\n\t\t\tunzClose(file);\n\t\t\treturn (FALSE);\n\t\t}\n\n\t\tFileSize = Memory.HeaderRemove(FileSize, ptr);\n\t\tptr += FileSize;\n\t\t*TotalFileSize += FileSize;\n\n\t\tint\tlen;\n\n\t\tif (ptr - Memory.ROM < CMemory::MAX_ROM_SIZE + 512 && (isdigit(ext[0]) && ext[1] == 0 && ext[0] < '9'))\n\t\t{\n\t\t\tmore = TRUE;\n\t\t\text[0]++;\n\t\t}\n\t\telse\n\t\tif (ptr - Memory.ROM < CMemory::MAX_ROM_SIZE + 512)\n\t\t{\n\t\t\tif (ext == tmp)\n\t\t\t\tlen = strlen(filename);\n\t\t\telse\n\t\t\t\tlen = ext - filename - 1;\n\n\t\t\tif ((len == 7 || len == 8) && strncasecmp(filename, \"sf\", 2) == 0 &&\n\t\t\t\tisdigit(filename[2]) && isdigit(filename[3]) && isdigit(filename[4]) &&\n\t\t\t\tisdigit(filename[5]) && isalpha(filename[len - 1]))\n\t\t\t{\n\t\t\t\tmore = TRUE;\n\t\t\t\tfilename[len - 1]++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tmore = FALSE;\n\n\t\tif (more)\n\t\t{\n\t\t\tif (unzLocateFile(file, filename, 0) != UNZ_OK ||\n\t\t\t\tunzGetCurrentFileInfo(file, &info, filename, 128, NULL, 0, NULL, 0) != UNZ_OK ||\n\t\t\t\tunzOpenCurrentFile(file) != UNZ_OK)\n\t\t\t\tbreak;\n\t\t}\n\t} while (more);\n\n\tunzClose(file);\n\n\treturn (TRUE);\n}\n\n#endif\n"
        },
        {
          "name": "macosx",
          "type": "tree",
          "content": null
        },
        {
          "name": "memmap.cpp",
          "type": "blob",
          "size": 94.9248046875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <assert.h>\n\n#ifdef UNZIP_SUPPORT\n#  ifdef SYSTEM_ZIP\n#    include <minizip/unzip.h>\n#  else\n#    include \"unzip/unzip.h\"\n#  endif\n#endif\n\n#ifdef JMA_SUPPORT\n#include \"jma/s9x-jma.h\"\n#endif\n\n#include <ctype.h>\n#include <sys/stat.h>\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"apu/apu.h\"\n#include \"fxemu.h\"\n#include \"sdd1.h\"\n#include \"srtc.h\"\n#include \"controls.h\"\n#include \"cheats.h\"\n#include \"movie.h\"\n#include \"display.h\"\n#include \"sha256.h\"\n#include \"snapshot.h\"\n\n#ifndef SET_UI_COLOR\n#define SET_UI_COLOR(r, g, b) ;\n#endif\n\n#ifndef max\n#define max(a, b) (((a) > (b)) ? (a) : (b))\n#endif\n\n#ifndef min\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n#endif\n\nstatic bool8\tstopMovie = TRUE;\n\n// from NSRT\nstatic const char\t*nintendo_licensees[] =\n{\n\t\"Unlicensed\",\n\t\"Nintendo\",\n\t\"Rocket Games/Ajinomoto\",\n\t\"Imagineer-Zoom\",\n\t\"Gray Matter\",\n\t\"Zamuse\",\n\t\"Falcom\",\n\tNULL,\n\t\"Capcom\",\n\t\"Hot B Co.\",\n\t\"Jaleco\",\n\t\"Coconuts Japan\",\n\t\"Coconuts Japan/G.X.Media\",\n\t\"Micronet\",\n\t\"Technos\",\n\t\"Mebio Software\",\n\t\"Shouei System\",\n\t\"Starfish\",\n\tNULL,\n\t\"Mitsui Fudosan/Dentsu\",\n\tNULL,\n\t\"Warashi Inc.\",\n\tNULL,\n\t\"Nowpro\",\n\tNULL,\n\t\"Game Village\",\n\t\"IE Institute\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Banarex\",\n\t\"Starfish\",\n\t\"Infocom\",\n\t\"Electronic Arts Japan\",\n\tNULL,\n\t\"Cobra Team\",\n\t\"Human/Field\",\n\t\"KOEI\",\n\t\"Hudson Soft\",\n\t\"S.C.P./Game Village\",\n\t\"Yanoman\",\n\tNULL,\n\t\"Tecmo Products\",\n\t\"Japan Glary Business\",\n\t\"Forum/OpenSystem\",\n\t\"Virgin Games (Japan)\",\n\t\"SMDE\",\n\t\"Yojigen\",\n\tNULL,\n\t\"Daikokudenki\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Creatures Inc.\",\n\t\"TDK Deep Impresion\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Destination Software/KSS\",\n\t\"Sunsoft/Tokai Engineering\",\n\t\"POW (Planning Office Wada)/VR 1 Japan\",\n\t\"Micro World\",\n\tNULL,\n\t\"San-X\",\n\t\"Enix\",\n\t\"Loriciel/Electro Brain\",\n\t\"Kemco Japan\",\n\t\"Seta Co.,Ltd.\",\n\t\"Culture Brain\",\n\t\"Irem Corp.\",\n\t\"Palsoft\",\n\t\"Visit Co., Ltd.\",\n\t\"Intec\",\n\t\"System Sacom\",\n\t\"Poppo\",\n\t\"Ubisoft Japan\",\n\tNULL,\n\t\"Media Works\",\n\t\"NEC InterChannel\",\n\t\"Tam\",\n\t\"Gajin/Jordan\",\n\t\"Smilesoft\",\n\tNULL,\n\tNULL,\n\t\"Mediakite\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Viacom\",\n\t\"Carrozzeria\",\n\t\"Dynamic\",\n\tNULL,\n\t\"Magifact\",\n\t\"Hect\",\n\t\"Codemasters\",\n\t\"Taito/GAGA Communications\",\n\t\"Laguna\",\n\t\"Telstar Fun & Games/Event/Taito\",\n\tNULL,\n\t\"Arcade Zone Ltd.\",\n\t\"Entertainment International/Empire Software\",\n\t\"Loriciel\",\n\t\"Gremlin Graphics\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Seika Corp.\",\n\t\"UBI SOFT Entertainment Software\",\n\t\"Sunsoft US\",\n\tNULL,\n\t\"Life Fitness\",\n\tNULL,\n\t\"System 3\",\n\t\"Spectrum Holobyte\",\n\tNULL,\n\t\"Irem\",\n\tNULL,\n\t\"Raya Systems\",\n\t\"Renovation Products\",\n\t\"Malibu Games\",\n\tNULL,\n\t\"Eidos/U.S. Gold\",\n\t\"Playmates Interactive\",\n\tNULL,\n\tNULL,\n\t\"Fox Interactive\",\n\t\"Time Warner Interactive\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Disney Interactive\",\n\tNULL,\n\t\"Black Pearl\",\n\tNULL,\n\t\"Advanced Productions\",\n\tNULL,\n\tNULL,\n\t\"GT Interactive\",\n\t\"RARE\",\n\t\"Crave Entertainment\",\n\t\"Absolute Entertainment\",\n\t\"Acclaim\",\n\t\"Activision\",\n\t\"American Sammy\",\n\t\"Take 2/GameTek\",\n\t\"Hi Tech\",\n\t\"LJN Ltd.\",\n\tNULL,\n\t\"Mattel\",\n\tNULL,\n\t\"Mindscape/Red Orb Entertainment\",\n\t\"Romstar\",\n\t\"Taxan\",\n\t\"Midway/Tradewest\",\n\tNULL,\n\t\"American Softworks Corp.\",\n\t\"Majesco Sales Inc.\",\n\t\"3DO\",\n\tNULL,\n\tNULL,\n\t\"Hasbro\",\n\t\"NewKidCo\",\n\t\"Telegames\",\n\t\"Metro3D\",\n\tNULL,\n\t\"Vatical Entertainment\",\n\t\"LEGO Media\",\n\tNULL,\n\t\"Xicat Interactive\",\n\t\"Cryo Interactive\",\n\tNULL,\n\tNULL,\n\t\"Red Storm Entertainment\",\n\t\"Microids\",\n\tNULL,\n\t\"Conspiracy/Swing\",\n\t\"Titus\",\n\t\"Virgin Interactive\",\n\t\"Maxis\",\n\tNULL,\n\t\"LucasArts Entertainment\",\n\tNULL,\n\tNULL,\n\t\"Ocean\",\n\tNULL,\n\t\"Electronic Arts\",\n\tNULL,\n\t\"Laser Beam\",\n\tNULL,\n\tNULL,\n\t\"Elite Systems\",\n\t\"Electro Brain\",\n\t\"The Learning Company\",\n\t\"BBC\",\n\tNULL,\n\t\"Software 2000\",\n\tNULL,\n\t\"BAM! Entertainment\",\n\t\"Studio 3\",\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Classified Games\",\n\tNULL,\n\t\"TDK Mediactive\",\n\tNULL,\n\t\"DreamCatcher\",\n\t\"JoWood Produtions\",\n\t\"SEGA\",\n\t\"Wannado Edition\",\n\t\"LSP (Light & Shadow Prod.)\",\n\t\"ITE Media\",\n\t\"Infogrames\",\n\t\"Interplay\",\n\t\"JVC (US)\",\n\t\"Parker Brothers\",\n\tNULL,\n\t\"SCI (Sales Curve Interactive)/Storm\",\n\tNULL,\n\tNULL,\n\t\"THQ Software\",\n\t\"Accolade Inc.\",\n\t\"Triffix Entertainment\",\n\tNULL,\n\t\"Microprose Software\",\n\t\"Universal Interactive/Sierra/Simon & Schuster\",\n\tNULL,\n\t\"Kemco\",\n\t\"Rage Software\",\n\t\"Encore\",\n\tNULL,\n\t\"Zoo\",\n\t\"Kiddinx\",\n\t\"Simon & Schuster Interactive\",\n\t\"Asmik Ace Entertainment Inc./AIA\",\n\t\"Empire Interactive\",\n\tNULL,\n\tNULL,\n\t\"Jester Interactive\",\n\tNULL,\n\t\"Rockstar Games\",\n\t\"Scholastic\",\n\t\"Ignition Entertainment\",\n\t\"Summitsoft\",\n\t\"Stadlbauer\",\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Misawa\",\n\t\"Teichiku\",\n\t\"Namco Ltd.\",\n\t\"LOZC\",\n\t\"KOEI\",\n\tNULL,\n\t\"Tokuma Shoten Intermedia\",\n\t\"Tsukuda Original\",\n\t\"DATAM-Polystar\",\n\tNULL,\n\tNULL,\n\t\"Bullet-Proof Software\",\n\t\"Vic Tokai Inc.\",\n\tNULL,\n\t\"Character Soft\",\n\t\"I'Max\",\n\t\"Saurus\",\n\tNULL,\n\tNULL,\n\t\"General Entertainment\",\n\tNULL,\n\tNULL,\n\t\"I'Max\",\n\t\"Success\",\n\tNULL,\n\t\"SEGA Japan\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Takara\",\n\t\"Chun Soft\",\n\t\"Video System Co., Ltd./McO'River\",\n\t\"BEC\",\n\tNULL,\n\t\"Varie\",\n\t\"Yonezawa/S'pal\",\n\t\"Kaneko\",\n\tNULL,\n\t\"Victor Interactive Software/Pack-in-Video\",\n\t\"Nichibutsu/Nihon Bussan\",\n\t\"Tecmo\",\n\t\"Imagineer\",\n\tNULL,\n\tNULL,\n\t\"Nova\",\n\t\"Den'Z\",\n\t\"Bottom Up\",\n\tNULL,\n\t\"TGL (Technical Group Laboratory)\",\n\tNULL,\n\t\"Hasbro Japan\",\n\tNULL,\n\t\"Marvelous Entertainment\",\n\tNULL,\n\t\"Keynet Inc.\",\n\t\"Hands-On Entertainment\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Telenet\",\n\t\"Hori\",\n\tNULL,\n\tNULL,\n\t\"Konami\",\n\t\"K.Amusement Leasing Co.\",\n\t\"Kawada\",\n\t\"Takara\",\n\tNULL,\n\t\"Technos Japan Corp.\",\n\t\"JVC (Europe/Japan)/Victor Musical Industries\",\n\tNULL,\n\t\"Toei Animation\",\n\t\"Toho\",\n\tNULL,\n\t\"Namco\",\n\t\"Media Rings Corp.\",\n\t\"J-Wing\",\n\tNULL,\n\t\"Pioneer LDC\",\n\t\"KID\",\n\t\"Mediafactory\",\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Infogrames Hudson\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Acclaim Japan\",\n\t\"ASCII Co./Nexoft\",\n\t\"Bandai\",\n\tNULL,\n\t\"Enix\",\n\tNULL,\n\t\"HAL Laboratory/Halken\",\n\t\"SNK\",\n\tNULL,\n\t\"Pony Canyon Hanbai\",\n\t\"Culture Brain\",\n\t\"Sunsoft\",\n\t\"Toshiba EMI\",\n\t\"Sony Imagesoft\",\n\tNULL,\n\t\"Sammy\",\n\t\"Magical\",\n\t\"Visco\",\n\tNULL,\n\t\"Compile\",\n\tNULL,\n\t\"MTO Inc.\",\n\tNULL,\n\t\"Sunrise Interactive\",\n\tNULL,\n\t\"Global A Entertainment\",\n\t\"Fuuki\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Taito\",\n\tNULL,\n\t\"Kemco\",\n\t\"Square\",\n\t\"Tokuma Shoten\",\n\t\"Data East\",\n\t\"Tonkin House\",\n\tNULL,\n\t\"KOEI\",\n\tNULL,\n\t\"Konami/Ultra/Palcom\",\n\t\"NTVIC/VAP\",\n\t\"Use Co., Ltd.\",\n\t\"Meldac\",\n\t\"Pony Canyon (Japan)/FCI (US)\",\n\t\"Angel/Sotsu Agency/Sunrise\",\n\t\"Yumedia/Aroma Co., Ltd.\",\n\tNULL,\n\tNULL,\n\t\"Boss\",\n\t\"Axela/Crea-Tech\",\n\t\"Sekaibunka-Sha/Sumire kobo/Marigul Management Inc.\",\n\t\"Konami Computer Entertainment Osaka\",\n\tNULL,\n\tNULL,\n\t\"Enterbrain\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Taito/Disco\",\n\t\"Sofel\",\n\t\"Quest Corp.\",\n\t\"Sigma\",\n\t\"Ask Kodansha\",\n\tNULL,\n\t\"Naxat\",\n\t\"Copya System\",\n\t\"Capcom Co., Ltd.\",\n\t\"Banpresto\",\n\t\"TOMY\",\n\t\"Acclaim/LJN Japan\",\n\tNULL,\n\t\"NCS\",\n\t\"Human Entertainment\",\n\t\"Altron\",\n\t\"Jaleco\",\n\t\"Gaps Inc.\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Elf\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Jaleco\",\n\tNULL,\n\t\"Yutaka\",\n\t\"Varie\",\n\t\"T&ESoft\",\n\t\"Epoch Co., Ltd.\",\n\tNULL,\n\t\"Athena\",\n\t\"Asmik\",\n\t\"Natsume\",\n\t\"King Records\",\n\t\"Atlus\",\n\t\"Epic/Sony Records (Japan)\",\n\tNULL,\n\t\"IGS (Information Global Service)\",\n\tNULL,\n\t\"Chatnoir\",\n\t\"Right Stuff\",\n\tNULL,\n\t\"NTT COMWARE\",\n\tNULL,\n\t\"Spike\",\n\t\"Konami Computer Entertainment Tokyo\",\n\t\"Alphadream Corp.\",\n\tNULL,\n\t\"Sting\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"A Wave\",\n\t\"Motown Software\",\n\t\"Left Field Entertainment\",\n\t\"Extreme Entertainment Group\",\n\t\"TecMagik\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Cybersoft\",\n\tNULL,\n\t\"Psygnosis\",\n\tNULL,\n\tNULL,\n\t\"Davidson/Western Tech.\",\n\t\"Unlicensed\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"The Game Factory Europe\",\n\t\"Hip Games\",\n\t\"Aspyr\",\n\tNULL,\n\tNULL,\n\t\"Mastiff\",\n\t\"iQue\",\n\t\"Digital Tainment Pool\",\n\t\"XS Games\",\n\t\"Daiwon\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"PCCW Japan\",\n\tNULL,\n\tNULL,\n\t\"KiKi Co. Ltd.\",\n\t\"Open Sesame Inc.\",\n\t\"Sims\",\n\t\"Broccoli\",\n\t\"Avex\",\n\t\"D3 Publisher\",\n\tNULL,\n\t\"Konami Computer Entertainment Japan\",\n\tNULL,\n\t\"Square-Enix\",\n\t\"KSG\",\n\t\"Micott & Basara Inc.\",\n\tNULL,\n\t\"Orbital Media\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"The Game Factory USA\",\n\tNULL,\n\tNULL,\n\t\"Treasure\",\n\t\"Aruze\",\n\t\"Ertain\",\n\t\"SNK Playmore\",\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Yojigen\"\n};\n\nstatic const uint32\tcrc32Table[256] =\n{\n\t0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n\t0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n\t0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n\t0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n\t0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n\t0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n\t0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\n\t0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n\t0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n\t0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n\t0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\n\t0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n\t0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n\t0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n\t0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n\t0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n\t0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n\t0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n\t0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n\t0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n\t0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n\t0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n\t0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n\t0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n\t0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n\t0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n\t0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n\t0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n\t0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n\t0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n\t0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n\t0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n\t0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n\t0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n\t0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n\t0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n\t0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n\t0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n\t0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n\t0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n\t0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n\t0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n\t0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n};\n\nstatic void S9xDeinterleaveType1 (int, uint8 *);\nstatic void S9xDeinterleaveType2 (int, uint8 *);\nstatic void S9xDeinterleaveGD24 (int, uint8 *);\nstatic bool8 allASCII (uint8 *, int);\nstatic bool8 is_SufamiTurbo_BIOS (const uint8 *, uint32);\nstatic bool8 is_SufamiTurbo_Cart (const uint8 *, uint32);\nstatic bool8 is_BSCart_BIOS (const uint8 *, uint32);\nstatic bool8 is_BSCartSA1_BIOS(const uint8 *, uint32);\nstatic bool8 is_GNEXT_Add_On (const uint8 *, uint32);\nstatic uint32 caCRC32 (uint8 *, uint32, uint32 crc32 = 0xffffffff);\nstatic bool8 ReadUPSPatch (Stream *, long, int32 &);\nstatic long ReadInt (Stream *, unsigned);\nstatic bool8 ReadIPSPatch (Stream *, long, int32 &);\n#ifdef UNZIP_SUPPORT\nstatic int unzFindExtension (unzFile &, const char *, bool restart = TRUE, bool print = TRUE, bool allowExact = FALSE);\n#endif\n\n// deinterleave\n\nstatic void S9xDeinterleaveType1 (int size, uint8 *base)\n{\n\tSettings.DisplayColor = BUILD_PIXEL(0, 31, 0);\n\tSET_UI_COLOR(0, 255, 0);\n\n\tuint8\tblocks[256];\n\tint\t\tnblocks = size >> 16;\n\n\tfor (int i = 0; i < nblocks; i++)\n\t{\n\t\tblocks[i * 2] = i + nblocks;\n\t\tblocks[i * 2 + 1] = i;\n\t}\n\n\tuint8\t*tmp = (uint8 *) malloc(0x8000);\n\tif (tmp)\n\t{\n\t\tfor (int i = 0; i < nblocks * 2; i++)\n\t\t{\n\t\t\tfor (int j = i; j < nblocks * 2; j++)\n\t\t\t{\n\t\t\t\tif (blocks[j] == i)\n\t\t\t\t{\n\t\t\t\t\tmemmove(tmp, &base[blocks[j] * 0x8000], 0x8000);\n\t\t\t\t\tmemmove(&base[blocks[j] * 0x8000], &base[blocks[i] * 0x8000], 0x8000);\n\t\t\t\t\tmemmove(&base[blocks[i] * 0x8000], tmp, 0x8000);\n\t\t\t\t\tuint8\tb = blocks[j];\n\t\t\t\t\tblocks[j] = blocks[i];\n\t\t\t\t\tblocks[i] = b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree(tmp);\n\t}\n}\n\nstatic void S9xDeinterleaveType2 (int size, uint8 *base)\n{\n\t// for odd Super FX images\n\tSettings.DisplayColor = BUILD_PIXEL(31, 14, 6);\n\tSET_UI_COLOR(255, 119, 25);\n\n\tuint8\tblocks[256];\n\tint\t\tnblocks = size >> 16;\n\tint\t\tstep = 64;\n\n\twhile (nblocks <= step)\n\t\tstep >>= 1;\n\tnblocks = step;\n\n\tfor (int i = 0; i < nblocks * 2; i++)\n\t\tblocks[i] = (i & ~0xf) | ((i & 3) << 2) | ((i & 12) >> 2);\n\n\tuint8\t*tmp = (uint8 *) malloc(0x10000);\n\tif (tmp)\n\t{\n\t\tfor (int i = 0; i < nblocks * 2; i++)\n\t\t{\n\t\t\tfor (int j = i; j < nblocks * 2; j++)\n\t\t\t{\n\t\t\t\tif (blocks[j] == i)\n\t\t\t\t{\n\t\t\t\t\tmemmove(tmp, &base[blocks[j] * 0x10000], 0x10000);\n\t\t\t\t\tmemmove(&base[blocks[j] * 0x10000], &base[blocks[i] * 0x10000], 0x10000);\n\t\t\t\t\tmemmove(&base[blocks[i] * 0x10000], tmp, 0x10000);\n\t\t\t\t\tuint8\tb = blocks[j];\n\t\t\t\t\tblocks[j] = blocks[i];\n\t\t\t\t\tblocks[i] = b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree(tmp);\n\t}\n}\n\nstatic void S9xDeinterleaveGD24 (int size, uint8 *base)\n{\n\t// for 24Mb images dumped with Game Doctor\n\tif (size != 0x300000)\n\t\treturn;\n\n\tSettings.DisplayColor = BUILD_PIXEL(0, 31, 31);\n\tSET_UI_COLOR(0, 255, 255);\n\n\tuint8\t*tmp = (uint8 *) malloc(0x80000);\n\tif (tmp)\n\t{\n\t\tmemmove(tmp, &base[0x180000], 0x80000);\n\t\tmemmove(&base[0x180000], &base[0x200000], 0x80000);\n\t\tmemmove(&base[0x200000], &base[0x280000], 0x80000);\n\t\tmemmove(&base[0x280000], tmp, 0x80000);\n\n\t\tfree(tmp);\n\n\t\tS9xDeinterleaveType1(size, base);\n\t}\n}\n\n// allocation and deallocation\n\nbool8 CMemory::Init (void)\n{\n\tIPPU.TileCache[TILE_2BIT]       = (uint8 *) malloc(MAX_2BIT_TILES * 64);\n\tIPPU.TileCache[TILE_4BIT]       = (uint8 *) malloc(MAX_4BIT_TILES * 64);\n\tIPPU.TileCache[TILE_8BIT]       = (uint8 *) malloc(MAX_8BIT_TILES * 64);\n\tIPPU.TileCache[TILE_2BIT_EVEN]  = (uint8 *) malloc(MAX_2BIT_TILES * 64);\n\tIPPU.TileCache[TILE_2BIT_ODD]   = (uint8 *) malloc(MAX_2BIT_TILES * 64);\n\tIPPU.TileCache[TILE_4BIT_EVEN]  = (uint8 *) malloc(MAX_4BIT_TILES * 64);\n\tIPPU.TileCache[TILE_4BIT_ODD]   = (uint8 *) malloc(MAX_4BIT_TILES * 64);\n\n\tIPPU.TileCached[TILE_2BIT]      = (uint8 *) malloc(MAX_2BIT_TILES);\n\tIPPU.TileCached[TILE_4BIT]      = (uint8 *) malloc(MAX_4BIT_TILES);\n\tIPPU.TileCached[TILE_8BIT]      = (uint8 *) malloc(MAX_8BIT_TILES);\n\tIPPU.TileCached[TILE_2BIT_EVEN] = (uint8 *) malloc(MAX_2BIT_TILES);\n\tIPPU.TileCached[TILE_2BIT_ODD]  = (uint8 *) malloc(MAX_2BIT_TILES);\n\tIPPU.TileCached[TILE_4BIT_EVEN] = (uint8 *) malloc(MAX_4BIT_TILES);\n\tIPPU.TileCached[TILE_4BIT_ODD]  = (uint8 *) malloc(MAX_4BIT_TILES);\n\n\tif (!IPPU.TileCache[TILE_2BIT]       ||\n\t\t!IPPU.TileCache[TILE_4BIT]       ||\n\t\t!IPPU.TileCache[TILE_8BIT]       ||\n\t\t!IPPU.TileCache[TILE_2BIT_EVEN]  ||\n\t\t!IPPU.TileCache[TILE_2BIT_ODD]   ||\n\t\t!IPPU.TileCache[TILE_4BIT_EVEN]  ||\n\t\t!IPPU.TileCache[TILE_4BIT_ODD]   ||\n\t\t!IPPU.TileCached[TILE_2BIT]      ||\n\t\t!IPPU.TileCached[TILE_4BIT]      ||\n\t\t!IPPU.TileCached[TILE_8BIT]      ||\n\t\t!IPPU.TileCached[TILE_2BIT_EVEN] ||\n\t\t!IPPU.TileCached[TILE_2BIT_ODD]  ||\n\t\t!IPPU.TileCached[TILE_4BIT_EVEN] ||\n\t\t!IPPU.TileCached[TILE_4BIT_ODD])\n    {\n\t\tDeinit();\n\t\treturn (FALSE);\n    }\n\n\tROMStorage.resize(MAX_ROM_SIZE + 0x200 + 0x8000);\n\tstd::fill(ROMStorage.begin(), ROMStorage.end(), 0);\n\tSRAMStorage.resize(SRAM_SIZE);\n\tstd::fill(SRAMStorage.begin(), SRAMStorage.end(), 0);\n\tSRAM = &SRAMStorage[0];\n\tmemset(RAM, 0,  sizeof(RAM));\n\tmemset(VRAM, 0, sizeof(VRAM));\n\n\tmemset(IPPU.TileCache[TILE_2BIT], 0,       MAX_2BIT_TILES * 64);\n\tmemset(IPPU.TileCache[TILE_4BIT], 0,       MAX_4BIT_TILES * 64);\n\tmemset(IPPU.TileCache[TILE_8BIT], 0,       MAX_8BIT_TILES * 64);\n\tmemset(IPPU.TileCache[TILE_2BIT_EVEN], 0,  MAX_2BIT_TILES * 64);\n\tmemset(IPPU.TileCache[TILE_2BIT_ODD], 0,   MAX_2BIT_TILES * 64);\n\tmemset(IPPU.TileCache[TILE_4BIT_EVEN], 0,  MAX_4BIT_TILES * 64);\n\tmemset(IPPU.TileCache[TILE_4BIT_ODD], 0,   MAX_4BIT_TILES * 64);\n\n\tmemset(IPPU.TileCached[TILE_2BIT], 0,      MAX_2BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_4BIT], 0,      MAX_4BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_8BIT], 0,      MAX_8BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_2BIT_EVEN], 0, MAX_2BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_2BIT_ODD], 0,  MAX_2BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_4BIT_EVEN], 0, MAX_4BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_4BIT_ODD], 0,  MAX_4BIT_TILES);\n\n\t// FillRAM uses first 32K of ROM image area, otherwise space just\n\t// wasted. Might be read by the SuperFX code.\n\n\tFillRAM = &ROMStorage[0];\n\n\t// Add 0x8000 to ROM image pointer to stop SuperFX code accessing\n\t// unallocated memory (can cause crash on some ports).\n\n\tROM = &ROMStorage[0x8000];\n\n\tC4RAM   = ROM + 0x400000 + 8192 * 8; // C4\n\tOBC1RAM = ROM + 0x400000; // OBC1\n\tBIOSROM = ROM + 0x300000; // BS\n\tBSRAM   = ROM + 0x400000; // BS\n\n\tSuperFX.pvRegisters = FillRAM + 0x3000;\n\tSuperFX.nRamBanks   = 2; // Most only use 1.  1=64KB=512Mb, 2=128KB=1024Mb\n\tSuperFX.pvRam       = SRAM;\n\tSuperFX.nRomBanks   = (2 * 1024 * 1024) / (32 * 1024);\n\tSuperFX.pvRom       = (uint8 *) ROM;\n\n\tPostRomInitFunc = NULL;\n\n\treturn (TRUE);\n}\n\nvoid CMemory::Deinit (void)\n{\n\tROM = NULL;\n\n\tfor (int t = 0; t < 7; t++)\n\t{\n\t\tif (IPPU.TileCache[t])\n\t\t{\n\t\t\tfree(IPPU.TileCache[t]);\n\t\t\tIPPU.TileCache[t] = NULL;\n\t\t}\n\n\t\tif (IPPU.TileCached[t])\n\t\t{\n\t\t\tfree(IPPU.TileCached[t]);\n\t\t\tIPPU.TileCached[t] = NULL;\n\t\t}\n\t}\n}\n\n// file management and ROM detection\n\nstatic bool8 allASCII (uint8 *b, int size)\n{\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tif (b[i] < 32 || b[i] > 126)\n\t\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nstatic bool8 is_SufamiTurbo_BIOS (const uint8 *data, uint32 size)\n{\n\tif (size == 0x40000 &&\n\t\tstrncmp((char *) data, \"BANDAI SFC-ADX\", 14) == 0 && strncmp((char * ) (data + 0x10), \"SFC-ADX BACKUP\", 14) == 0)\n\t\treturn (TRUE);\n\telse\n\t\treturn (FALSE);\n}\n\nstatic bool8 is_SufamiTurbo_Cart (const uint8 *data, uint32 size)\n{\n\tif (size >= 0x80000 && size <= 0x100000 &&\n\t\tstrncmp((char *) data, \"BANDAI SFC-ADX\", 14) == 0 && strncmp((char * ) (data + 0x10), \"SFC-ADX BACKUP\", 14) != 0)\n\t\treturn (TRUE);\n\telse\n\t\treturn (FALSE);\n}\n\nstatic bool8 is_BSCart_BIOS(const uint8 *data, uint32 size)\n{\n\tif ((data[0x7FB2] == 0x5A) && (data[0x7FB5] != 0x20) && (data[0x7FDA] == 0x33))\n\t{\n\t\tMemory.LoROM = TRUE;\n\t\tMemory.HiROM = FALSE;\n\n\t\treturn (TRUE);\n\t}\n\telse if ((data[0xFFB2] == 0x5A) && (data[0xFFB5] != 0x20) && (data[0xFFDA] == 0x33))\n\t{\n\t\tMemory.LoROM = FALSE;\n\t\tMemory.HiROM = TRUE;\n\n\t\treturn (TRUE);\n\t}\n\telse\n\t\treturn (FALSE);\n}\n\nstatic bool8 is_BSCartSA1_BIOS (const uint8 *data, uint32 size)\n{\n\t//Same basic check as BSCart\n\tif (!is_BSCart_BIOS(data, size))\n\t\treturn (FALSE);\n\n\t//Checks if the game is Itoi's Bass Fishing No. 1 (ZBPJ) or SD Gundam G-NEXT (ZX3J)\n\tif (strncmp((char *)(data + 0x7fb2), \"ZBPJ\", 4) == 0 || strncmp((char *)(data + 0x7fb2), \"ZX3J\", 4) == 0)\n\t\treturn (TRUE);\n\telse\n\t\treturn (FALSE);\n}\n\nstatic bool8 is_GNEXT_Add_On (const uint8 *data, uint32 size)\n{\n\tif (size == 0x80000)\n\t\treturn (TRUE);\n\telse\n\t\treturn (FALSE);\n}\n\nint CMemory::ScoreHiROM (bool8 skip_header, int32 romoff)\n{\n\tuint8\t*buf = ROM + 0xff00 + romoff + (skip_header ? 0x200 : 0);\n\tint\t\tscore = 0;\n\n\t// Check for extended HiROM expansion used in Mother 2 Deluxe et al.\n\t// Looks for size byte 13 (8MB) and an actual ROM size greater than 4MB\n\tif (buf[0xd7] == 13 && CalculatedSize > 1024 * 1024 * 4)\n\t\tscore += 3;\n\n\tif (buf[0xd5] & 0x1)\n\t\tscore += 2;\n\n\t// Mode23 is SA-1\n\tif (buf[0xd5] == 0x23)\n\t\tscore -= 2;\n\n\tif (buf[0xd4] == 0x20)\n\t\tscore += 2;\n\n\tif ((buf[0xdc] + (buf[0xdd] << 8)) + (buf[0xde] + (buf[0xdf] << 8)) == 0xffff)\n\t{\n\t\tscore += 2;\n\t\tif (0 != (buf[0xde] + (buf[0xdf] << 8)))\n\t\t\tscore++;\n\t}\n\n\tif (buf[0xda] == 0x33)\n\t\tscore += 2;\n\n\tif ((buf[0xd5] & 0xf) < 4)\n\t\tscore += 2;\n\n\tif (!(buf[0xfd] & 0x80))\n\t\tscore -= 6;\n\n\tif ((buf[0xfc] + (buf[0xfd] << 8)) > 0xffb0)\n\t\tscore -= 2; // reduced after looking at a scan by Cowering\n\n\tif (CalculatedSize > 1024 * 1024 * 3)\n\t\tscore += 4;\n\n\tif (buf[0xd7] > 12)\n\t\tscore -= 1;\n\n\tif (!allASCII(&buf[0xb0], 6))\n\t\tscore -= 1;\n\n\tif (!allASCII(&buf[0xc0], ROM_NAME_LEN - 1))\n\t\tscore -= 1;\n\n\treturn (score);\n}\n\nint CMemory::ScoreLoROM (bool8 skip_header, int32 romoff)\n{\n\tuint8\t*buf = ROM + 0x7f00 + romoff + (skip_header ? 0x200 : 0);\n\tint\t\tscore = 0;\n\n\tif (!(buf[0xd5] & 0x1))\n\t\tscore += 3;\n\n\t// Mode23 is SA-1\n\tif (buf[0xd5] == 0x23)\n\t\tscore += 2;\n\n\tif ((buf[0xdc] + (buf[0xdd] << 8)) + (buf[0xde] + (buf[0xdf] << 8)) == 0xffff)\n\t{\n\t\tscore += 2;\n\t\tif (0 != (buf[0xde] + (buf[0xdf] << 8)))\n\t\t\tscore++;\n\t}\n\n\tif (buf[0xda] == 0x33)\n\t\tscore += 2;\n\n\tif ((buf[0xd5] & 0xf) < 4)\n\t\tscore += 2;\n\n\tif (!(buf[0xfd] & 0x80))\n\t\tscore -= 6;\n\n\tif ((buf[0xfc] + (buf[0xfd] << 8)) > 0xffb0)\n\t\tscore -= 2; // reduced per Cowering suggestion\n\n\tif (CalculatedSize <= 1024 * 1024 * 16)\n\t\tscore += 2;\n\n\tif ((1 << (buf[0xd7] - 7)) > 48)\n\t\tscore -= 1;\n\n\tif (!allASCII(&buf[0xb0], 6))\n\t\tscore -= 1;\n\n\tif (!allASCII(&buf[0xc0], ROM_NAME_LEN - 1))\n\t\tscore -= 1;\n\n\treturn (score);\n}\n\nint CMemory::First512BytesCountZeroes() const\n{\n\tconst uint8 *buf = ROM;\n\tint zeroCount = 0;\n\tfor (int i = 0; i < 512; i++)\n\t{\n\t\tif (buf[i] == 0)\n\t\t{\n\t\t\tzeroCount++;\n\t\t}\n\t}\n\treturn zeroCount;\n}\n\nuint32 CMemory::HeaderRemove (uint32 size, uint8 *buf)\n{\n\tuint32\tcalc_size = (size / 0x2000) * 0x2000;\n\n\tif ((size - calc_size == 512 && !Settings.ForceNoHeader) || Settings.ForceHeader)\n\t{\n\t\tuint8\t*NSRTHead = buf + 0x1D0; // NSRT Header Location\n\n\t\t// detect NSRT header\n\t\tif (!strncmp(\"NSRT\", (char *) &NSRTHead[24], 4))\n\t\t{\n\t\t\tif (NSRTHead[28] == 22)\n\t\t\t{\n\t\t\t\tif (((std::accumulate(NSRTHead, NSRTHead + sizeof(NSRTHeader), 0) & 0xFF) == NSRTHead[30]) &&\n\t\t\t\t\t(NSRTHead[30] + NSRTHead[31] == 255) && ((NSRTHead[0] & 0x0F) <= 13) &&\n\t\t\t\t\t(((NSRTHead[0] & 0xF0) >> 4) <= 3) && ((NSRTHead[0] & 0xF0) >> 4))\n\t\t\t\t\tmemcpy(NSRTHeader, NSRTHead, sizeof(NSRTHeader));\n\t\t\t}\n\t\t}\n\n\t\tmemmove(buf, buf + 512, calc_size);\n\t\tHeaderCount++;\n\t\tsize -= 512;\n\t}\n\n\treturn (size);\n}\n\nuint32 CMemory::FileLoader (uint8 *buffer, const char *filename, uint32 maxsize)\n{\n\t// <- ROM size without header\n\t// ** Memory.HeaderCount\n\t// ** Memory.ROMFilename\n\n\tuint32\ttotalSize = 0;\n\tmemset(NSRTHeader, 0, sizeof(NSRTHeader));\n\tHeaderCount = 0;\n\n\tauto path = splitpath(filename);\n\n\tint\tnFormat = FILE_DEFAULT;\n\tif (path.ext_is(\".zip\") || path.ext_is(\".msu1\"))\n\t\tnFormat = FILE_ZIP;\n\telse if (path.ext_is(\".jma\"))\n\t\tnFormat = FILE_JMA;\n\n\tswitch (nFormat)\n\t{\n\t\tcase FILE_ZIP:\n\t\t{\n\t\t#ifdef UNZIP_SUPPORT\n\t\t\tif (!LoadZip(filename, &totalSize, buffer))\n\t\t\t{\n\t\t\t \tS9xMessage(S9X_ERROR, S9X_ROM_INFO, \"Invalid Zip archive.\");\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\tROMFilename = filename;\n\t\t#else\n\t\t\tS9xMessage(S9X_ERROR, S9X_ROM_INFO, \"This binary was not created with Zip support.\");\n\t\t\treturn (0);\n\t\t#endif\n\t\t\tbreak;\n\t\t}\n\n\t\tcase FILE_JMA:\n\t\t{\n\t\t#ifdef JMA_SUPPORT\n\t\t\tsize_t\tsize = load_jma_file(filename, buffer);\n\t\t\tif (!size)\n\t\t\t{\n\t\t\t \tS9xMessage(S9X_ERROR, S9X_ROM_INFO, \"Invalid JMA archive.\");\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\ttotalSize = HeaderRemove(size, buffer);\n\n\t\t\tROMFilename = filename;\n\t\t#else\n\t\t\tS9xMessage(S9X_ERROR, S9X_ROM_INFO, \"This binary was not created with JMA support.\");\n\t\t\treturn (0);\n\t\t#endif\n\t\t\tbreak;\n\t\t}\n\n\t\tcase FILE_DEFAULT:\n\t\tdefault:\n\t\t{\n\t\t\tSTREAM\tfp = OPEN_STREAM(filename, \"rb\");\n\t\t\tif (!fp)\n\t\t\t\treturn (0);\n\n\t\t\tROMFilename = filename;\n\n\t\t\tuint32\tsize = 0;\n\n\t\t\tsize = READ_STREAM(buffer, maxsize + 0x200, fp);\n\t\t\tCLOSE_STREAM(fp);\n\n\t\t\ttotalSize = HeaderRemove(size, buffer);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (HeaderCount == 0)\n\t\tS9xMessage(S9X_INFO, S9X_HEADERS_INFO, \"No ROM file header found.\");\n\telse if (HeaderCount == 1)\n\t\tS9xMessage(S9X_INFO, S9X_HEADERS_INFO, \"Found ROM file header (and ignored it).\");\n\telse\n\t\tS9xMessage(S9X_INFO, S9X_HEADERS_INFO, \"Found multiple ROM file headers (and ignored them).\");\n\n\treturn ((uint32) totalSize);\n}\n\nbool8 CMemory::LoadROMMem (const uint8 *source, uint32 sourceSize, const char* optional_rom_filename /*= NULL*/)\n{\n    if(!source || sourceSize > MAX_ROM_SIZE)\n        return FALSE;\n\n    if (optional_rom_filename)\n        ROMFilename = optional_rom_filename;\n    else\n        ROMFilename = \"MemoryROM\";\n\n    do\n    {\n        memset(ROM,0, MAX_ROM_SIZE);\n        memset(&Multi, 0,sizeof(Multi));\n        memcpy(ROM,source,sourceSize);\n    }\n    while(!LoadROMInt(sourceSize));\n\n    return TRUE;\n}\n\nbool8 CMemory::LoadROM (const char *filename)\n{\n    if(!filename || !*filename)\n        return FALSE;\n\n    S9xResetSaveTimer(FALSE); // reset oops timer here so that .oops file has rom name of previous rom\n\n    int32 totalFileSize;\n\n    do\n    {\n        memset(ROM,0, MAX_ROM_SIZE);\n        memset(&Multi, 0,sizeof(Multi));\n        totalFileSize = FileLoader(ROM, filename, MAX_ROM_SIZE);\n\n        if (!totalFileSize)\n            return (FALSE);\n\n        CheckForAnyPatch(filename, HeaderCount != 0, totalFileSize);\n    }\n    while(!LoadROMInt(totalFileSize));\n\n    return TRUE;\n}\n\nbool8 CMemory::LoadROMInt (int32 ROMfillSize)\n{\n\tSettings.DisplayColor = BUILD_PIXEL(31, 31, 31);\n\tSET_UI_COLOR(255, 255, 255);\n\n\tCalculatedSize = 0;\n\tExtendedFormat = NOPE;\n\n\tint\thi_score, lo_score;\n\tint score_headered;\n\tint score_nonheadered;\n\n\thi_score = ScoreHiROM(FALSE);\n\tlo_score = ScoreLoROM(FALSE);\n\tscore_nonheadered = max(hi_score, lo_score);\n\tscore_headered = max(ScoreHiROM(TRUE), ScoreLoROM(TRUE));\n\n\tbool size_is_likely_headered = ((ROMfillSize - 512) & 0xFFFF) == 0;\n\tif (size_is_likely_headered) { score_headered += 2; } else { score_headered -= 2; }\n\tif (First512BytesCountZeroes() >= 0x1E0) { score_headered += 2; } else { score_headered -= 2; }\n\n\tbool headered_score_highest = score_headered > score_nonheadered;\n\n\tif (HeaderCount == 0 && !Settings.ForceNoHeader && headered_score_highest)\n\t{\n\t\tmemmove(ROM, ROM + 512, ROMfillSize - 512);\n\t\tROMfillSize -= 512;\n\t\tS9xMessage(S9X_INFO, S9X_HEADER_WARNING, \"Try 'force no-header' option if the game doesn't work\");\n\t\t// modifying ROM, so we need to rescore\n\t\thi_score = ScoreHiROM(FALSE);\n\t\tlo_score = ScoreLoROM(FALSE);\n\t}\n\n\tCalculatedSize = ((ROMfillSize + 0x1fff) / 0x2000) * 0x2000;\n\n\tif (CalculatedSize > 0x400000 &&\n\t\t(ROM[0x7fd5] + (ROM[0x7fd6] << 8)) != 0x1320 && // exclude SuperFX\n\t\t(ROM[0x7fd5] + (ROM[0x7fd6] << 8)) != 0x1420 &&\n\t\t(ROM[0x7fd5] + (ROM[0x7fd6] << 8)) != 0x1520 &&\n\t\t(ROM[0x7fd5] + (ROM[0x7fd6] << 8)) != 0x1A20 &&\n\t\t(ROM[0x7fd5] + (ROM[0x7fd6] << 8)) != 0x3423 && // exclude SA-1\n\t\t(ROM[0x7fd5] + (ROM[0x7fd6] << 8)) != 0x3523 &&\n\t\t(ROM[0x7fd5] + (ROM[0x7fd6] << 8)) != 0x4332 && // exclude S-DD1\n\t\t(ROM[0x7fd5] + (ROM[0x7fd6] << 8)) != 0x4532 &&\n\t\t(ROM[0xffd5] + (ROM[0xffd6] << 8)) != 0xF93a && // exclude SPC7110\n\t\t(ROM[0xffd5] + (ROM[0xffd6] << 8)) != 0xF53a)\n\t\tExtendedFormat = YEAH;\n\n\t// if both vectors are invalid, it's type 1 interleaved LoROM\n\tif (ExtendedFormat == NOPE &&\n\t\t((ROM[0x7ffc] + (ROM[0x7ffd] << 8)) < 0x8000) &&\n\t\t((ROM[0xfffc] + (ROM[0xfffd] << 8)) < 0x8000))\n\t{\n\t\tif (!Settings.ForceInterleaved && !Settings.ForceNotInterleaved)\n\t\t\tS9xDeinterleaveType1(ROMfillSize, ROM);\n\t}\n\n\t// CalculatedSize is now set, so rescore\n\thi_score = ScoreHiROM(FALSE);\n\tlo_score = ScoreLoROM(FALSE);\n\n\tuint8\t*RomHeader = ROM;\n\n\tif (ExtendedFormat != NOPE)\n\t{\n\t\tint\tswappedhirom, swappedlorom;\n\n\t\tswappedhirom = ScoreHiROM(FALSE, 0x400000);\n\t\tswappedlorom = ScoreLoROM(FALSE, 0x400000);\n\n\t\t// set swapped here\n\t\tif (max(swappedlorom, swappedhirom) >= max(lo_score, hi_score))\n\t\t{\n\t\t\tExtendedFormat = BIGFIRST;\n\t\t\thi_score = swappedhirom;\n\t\t\tlo_score = swappedlorom;\n\t\t\tRomHeader += 0x400000;\n\t\t}\n\t\telse\n\t\t\tExtendedFormat = SMALLFIRST;\n\t}\n\n\tbool8\tinterleaved, tales = FALSE;\n\n    interleaved = Settings.ForceInterleaved || Settings.ForceInterleaved2 || Settings.ForceInterleaveGD24;\n\n\tif (Settings.ForceLoROM || (!Settings.ForceHiROM && lo_score >= hi_score))\n\t{\n\t\tLoROM = TRUE;\n\t\tHiROM = FALSE;\n\n\t\t// ignore map type byte if not 0x2x or 0x3x\n\t\tif ((RomHeader[0x7fd5] & 0xf0) == 0x20 || (RomHeader[0x7fd5] & 0xf0) == 0x30)\n\t\t{\n\t\t\tswitch (RomHeader[0x7fd5] & 0xf)\n\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tinterleaved = TRUE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 5:\n\t\t\t\t\tinterleaved = TRUE;\n\t\t\t\t\ttales = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tLoROM = FALSE;\n\t\tHiROM = TRUE;\n\n\t\tif ((RomHeader[0xffd5] & 0xf0) == 0x20 || (RomHeader[0xffd5] & 0xf0) == 0x30)\n\t\t{\n\t\t\tswitch (RomHeader[0xffd5] & 0xf)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\tcase 3:\n\t\t\t\t\tinterleaved = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// this two games fail to be detected\n\tif (!Settings.ForceHiROM && !Settings.ForceLoROM)\n\t{\n\t\tif (strncmp((char *) &ROM[0x7fc0], \"YUYU NO QUIZ DE GO!GO!\", 22) == 0 ||\n\t\t   (strncmp((char *) &ROM[0xffc0], \"BATMAN--REVENGE JOKER\",  21) == 0))\n\t\t{\n\t\t\tLoROM = TRUE;\n\t\t\tHiROM = FALSE;\n\t\t\tinterleaved = FALSE;\n\t\t\ttales = FALSE;\n\t\t}\n\t}\n\n\tif (!Settings.ForceNotInterleaved && interleaved)\n\t{\n\t\tS9xMessage(S9X_INFO, S9X_ROM_INTERLEAVED_INFO, \"ROM image is in interleaved format - converting...\");\n\n\t\tif (tales)\n\t\t{\n\t\t\tif (ExtendedFormat == BIGFIRST)\n\t\t\t{\n\t\t\t\tS9xDeinterleaveType1(0x400000, ROM);\n\t\t\t\tS9xDeinterleaveType1(CalculatedSize - 0x400000, ROM + 0x400000);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS9xDeinterleaveType1(CalculatedSize - 0x400000, ROM);\n\t\t\t\tS9xDeinterleaveType1(0x400000, ROM + CalculatedSize - 0x400000);\n\t\t\t}\n\n\t\t\tLoROM = FALSE;\n\t\t\tHiROM = TRUE;\n\t\t}\n\t\telse if (Settings.ForceInterleaveGD24 && CalculatedSize == 0x300000)\n\t\t{\n\t\t\tbool8\tt = LoROM;\n\t\t\tLoROM = HiROM;\n\t\t\tHiROM = t;\n\t\t\tS9xDeinterleaveGD24(CalculatedSize, ROM);\n\t\t}\n\t\telse if (Settings.ForceInterleaved2)\n\t\t\tS9xDeinterleaveType2(CalculatedSize, ROM);\n\t\telse\n\t\t{\n\t\t\tbool8\tt = LoROM;\n\t\t\tLoROM = HiROM;\n\t\t\tHiROM = t;\n\t\t\tS9xDeinterleaveType1(CalculatedSize, ROM);\n\t\t}\n\n\t\thi_score = ScoreHiROM(FALSE);\n\t\tlo_score = ScoreLoROM(FALSE);\n\n\t\tif ((HiROM && (lo_score >= hi_score || hi_score < 0)) ||\n\t\t\t(LoROM && (hi_score >  lo_score || lo_score < 0)))\n\t\t{\n\t\t\tS9xMessage(S9X_INFO, S9X_ROM_CONFUSING_FORMAT_INFO, \"ROM lied about its type! Trying again.\");\n\t\t\tSettings.ForceNotInterleaved = TRUE;\n\t\t\tSettings.ForceInterleaved = FALSE;\n            return (FALSE);\n\t\t}\n    }\n\n\tif (ExtendedFormat == SMALLFIRST)\n\t\ttales = TRUE;\n\n\tif (tales)\n\t{\n\t\tuint8\t*tmp = (uint8 *) malloc(CalculatedSize - 0x400000);\n\t\tif (tmp)\n\t\t{\n\t\t\tS9xMessage(S9X_INFO, S9X_ROM_INTERLEAVED_INFO, \"Fixing swapped ExHiROM...\");\n\t\t\tmemmove(tmp, ROM, CalculatedSize - 0x400000);\n\t\t\tmemmove(ROM, ROM + CalculatedSize - 0x400000, 0x400000);\n\t\t\tmemmove(ROM + 0x400000, tmp, CalculatedSize - 0x400000);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\n\tmemset(&SNESGameFixes, 0, sizeof(SNESGameFixes));\n\tSNESGameFixes.SRAMInitialValue = 0x60;\n\n\tInitROM();\n\n\tS9xReset();\n\n\tS9xDeleteCheats();\n\tS9xLoadCheatFile(S9xGetFilename(\".cht\", CHEAT_DIR).c_str());\n\n    return (TRUE);\n}\n\nbool8 CMemory::LoadMultiCartMem (const uint8 *sourceA, uint32 sourceASize,\n                                 const uint8 *sourceB, uint32 sourceBSize,\n                                 const uint8 *bios, uint32 biosSize)\n{\n    uint32 offset = 0;\n    memset(ROM, 0, MAX_ROM_SIZE);\n\tmemset(&Multi, 0, sizeof(Multi));\n\n    if(bios) {\n        if(!is_SufamiTurbo_BIOS(bios,biosSize))\n            return FALSE;\n\n        memcpy(ROM,bios,biosSize);\n        offset+=biosSize;\n    }\n\n    if(sourceA) {\n        memcpy(ROM + offset,sourceA,sourceASize);\n        Multi.cartOffsetA = offset;\n        Multi.cartSizeA = sourceASize;\n        offset += sourceASize;\n        strcpy(Multi.fileNameA,\"MemCartA\");\n    }\n\n    if(sourceB) {\n        memcpy(ROM + offset,sourceB,sourceBSize);\n        Multi.cartOffsetB = offset;\n        Multi.cartSizeB = sourceBSize;\n        offset += sourceBSize;\n        strcpy(Multi.fileNameB,\"MemCartB\");\n    }\n\n    return LoadMultiCartInt();\n}\n\nbool8 CMemory::LoadMultiCart (const char *cartA, const char *cartB)\n{\n    S9xResetSaveTimer(FALSE); // reset oops timer here so that .oops file has rom name of previous rom\n\n    memset(ROM, 0, MAX_ROM_SIZE);\n\tmemset(&Multi, 0, sizeof(Multi));\n\n\tSettings.DisplayColor = BUILD_PIXEL(31, 31, 31);\n\tSET_UI_COLOR(255, 255, 255);\n\n    if (cartB && cartB[0])\n\t\tMulti.cartSizeB = FileLoader(ROM, cartB, MAX_ROM_SIZE);\n\n    if (Multi.cartSizeB) {\n        strcpy(Multi.fileNameB, cartB);\n\n\t\tCheckForAnyPatch(cartB, HeaderCount != 0, Multi.cartSizeB);\n\n        Multi.cartOffsetB = 0x400000;\n        memcpy(ROM + Multi.cartOffsetB,ROM,Multi.cartSizeB);\n    }\n\n\tif (cartA && cartA[0])\n\t\tMulti.cartSizeA = FileLoader(ROM, cartA, MAX_ROM_SIZE);\n\n    if (Multi.cartSizeA) {\n        strcpy(Multi.fileNameA, cartA);\n\n\t\tCheckForAnyPatch(cartA, HeaderCount != 0, Multi.cartSizeA);\n    }\n\n    return LoadMultiCartInt();\n}\n\nbool8 CMemory::LoadMultiCartInt ()\n{\n\tbool8\tr = TRUE;\n\n\tCalculatedSize = 0;\n\tExtendedFormat = NOPE;\n\n\tif (Multi.cartSizeA)\n\t{\n\t\tif (is_SufamiTurbo_Cart(ROM + Multi.cartOffsetA, Multi.cartSizeA))\n\t\t\tMulti.cartType = 4;\n\t\telse\n\t\tif (is_BSCartSA1_BIOS(ROM + Multi.cartOffsetA, Multi.cartSizeA))\n\t\t\tMulti.cartType = 5;\n\t\telse\n\t\tif (is_BSCart_BIOS(ROM + Multi.cartOffsetA, Multi.cartSizeA))\n\t\t\tMulti.cartType = 3;\n\t}\n\telse\n\tif (Multi.cartSizeB)\n\t{\n        if (is_SufamiTurbo_Cart(ROM + Multi.cartOffsetB, Multi.cartSizeB))\n\t\t\tMulti.cartType = 4;\n\t}\n\telse\n\t\tMulti.cartType = 4; // assuming BIOS only\n\n\n    if(Multi.cartType == 4 && Multi.cartOffsetA == 0) { // try to load bios from file\n        Multi.cartOffsetA = 0x40000;\n        if(Multi.cartSizeA)\n            memmove(ROM + Multi.cartOffsetA, ROM, Multi.cartSizeA + Multi.cartSizeB);\n        else if(Multi.cartOffsetB) // clear cart A so the bios can detect that it's not present\n            memset(ROM, 0, Multi.cartOffsetB);\n\n        FILE\t*fp;\n\t    size_t\tsize;\n\t\tstd::string path = S9xGetDirectory(BIOS_DIR) + SLASH_STR + \"STBIOS.bin\";\n\n\t    fp = fopen(path.c_str(), \"rb\");\n\t    if (fp)\n\t    {\n\t\t    size = fread((void *) ROM, 1, 0x40000, fp);\n\t\t    fclose(fp);\n\t\t    if (!is_SufamiTurbo_BIOS(ROM, size))\n\t\t\t    return (FALSE);\n\t    }\n\t    else\n\t\t    return (FALSE);\n\n        ROMFilename = path;\n    }\n\n\tswitch (Multi.cartType)\n\t{\n\t\tcase 4:\n\t\t\tr = LoadSufamiTurbo();\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\tcase 5:\n\t\t\tr = LoadBSCart();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tr = FALSE;\n\t}\n\n\tif (!r)\n\t{\n\t\tmemset(&Multi, 0, sizeof(Multi));\n\t\treturn (FALSE);\n\t}\n\n\tif (Multi.cartSizeA)\n\t\tROMFilename = Multi.fileNameA;\n\telse if (Multi.cartSizeB)\n\t\tROMFilename = Multi.fileNameB;\n\n\tmemset(&SNESGameFixes, 0, sizeof(SNESGameFixes));\n\tSNESGameFixes.SRAMInitialValue = 0x60;\n\n\tInitROM();\n\n\tS9xReset();\n\n\tS9xDeleteCheats();\n\tS9xLoadCheatFile(S9xGetFilename(\".cht\", CHEAT_DIR).c_str());\n\n\treturn (TRUE);\n}\n\nbool8 CMemory::LoadSufamiTurbo ()\n{\n\tMulti.sramA = SRAM;\n\tMulti.sramB = SRAM + 0x10000;\n\n\tif (Multi.cartSizeA)\n\t{\n\t\tMulti.sramSizeA = 4; // ROM[0x37]?\n\t\tMulti.sramMaskA = Multi.sramSizeA ? ((1 << (Multi.sramSizeA + 3)) * 128 - 1) : 0;\n\t}\n\n\tif (Multi.cartSizeB)\n\t{\n        if (!is_SufamiTurbo_Cart(ROM + Multi.cartOffsetB, Multi.cartSizeB))\n\t\t\tMulti.cartSizeB = 0;\n\t}\n\n\tif (Multi.cartSizeB)\n\t{\n\t\tMulti.sramSizeB = 4; // ROM[0x37]?\n\t\tMulti.sramMaskB = Multi.sramSizeB ? ((1 << (Multi.sramSizeB + 3)) * 128 - 1) : 0;\n\t}\n\n\tLoROM = TRUE;\n\tHiROM = FALSE;\n\tCalculatedSize = 0x40000;\n\n\treturn (TRUE);\n}\n\nbool8 CMemory::LoadBSCart ()\n{\n\tMulti.sramA = SRAM;\n\tMulti.sramB = NULL;\n\n\tif (LoROM)\n\t\tMulti.sramSizeA = ROM[0x7fd8];\n\telse\n\t\tMulti.sramSizeA = ROM[0xffd8];\n\n\tMulti.sramMaskA = Multi.sramSizeA ? ((1 << (Multi.sramSizeA + 3)) * 128 - 1) : 0;\n\tMulti.sramSizeB = 0;\n\tMulti.sramMaskB = 0;\n\n\tCalculatedSize = Multi.cartSizeA;\n\n\tif (Multi.cartSizeB == 0 && Multi.cartSizeA <= (int32)(MAX_ROM_SIZE - 0x100000 - Multi.cartOffsetA))\n\t{\n\t\t//Initialize 1MB Empty Memory Pack only if cart B is cleared\n\t\t//It does not make a Memory Pack if game is loaded like a normal ROM\n\t\tMulti.cartOffsetB = Multi.cartOffsetA + CalculatedSize;\n\t\tMulti.cartSizeB = 0x100000;\n\t\tmemset(Memory.ROM + Multi.cartOffsetB, 0xFF, 0x100000);\n\t}\n\n\treturn (TRUE);\n}\n\nbool8 CMemory::LoadGNEXT ()\n{\n\tMulti.sramA = SRAM;\n\tMulti.sramB = NULL;\n\n\tMulti.sramSizeA = ROM[0x7fd8];\n\tMulti.sramMaskA = Multi.sramSizeA ? ((1 << (Multi.sramSizeA + 3)) * 128 - 1) : 0;\n\tMulti.sramSizeB = 0;\n\tMulti.sramMaskB = 0;\n\n\tif (Multi.cartSizeB)\n\t{\n\t\tif (!is_GNEXT_Add_On(ROM + Multi.cartOffsetB, Multi.cartSizeB))\n\t\t\tMulti.cartSizeB = 0;\n\t}\n\n\tLoROM = TRUE;\n\tHiROM = FALSE;\n\tCalculatedSize = Multi.cartSizeA;\n\n\treturn (TRUE);\n}\n\nbool8 CMemory::LoadSRTC (void)\n{\n\tFILE\t*fp;\n\n\tfp = fopen(S9xGetFilename(\".rtc\", SRAM_DIR).c_str(), \"rb\");\n\tif (!fp)\n\t\treturn (FALSE);\n\n\tif (fread(RTCData.reg, 1, 20, fp) < 20)\n\t\tmemset (RTCData.reg, 0, 20);\n\tfclose(fp);\n\n\treturn (TRUE);\n}\n\nbool8 CMemory::SaveSRTC (void)\n{\n\tFILE\t*fp;\n\n\tfp = fopen(S9xGetFilename(\".rtc\", SRAM_DIR).c_str(), \"wb\");\n\tif (!fp)\n\t\treturn (FALSE);\n\n\tif (fwrite(RTCData.reg, 1, 20, fp) < 20)\n\t{\n\t\tprintf (\"Failed to save clock data.\\n\");\n\t}\n\tfclose(fp);\n\n\treturn (TRUE);\n}\n\nvoid CMemory::ClearSRAM (bool8 onlyNonSavedSRAM)\n{\n\tif (onlyNonSavedSRAM)\n\t\tif (!(Settings.SuperFX && ROMType < 0x15) && !(Settings.SA1 && ROMType == 0x34)) // can have SRAM\n\t\t\treturn;\n\t// TODO: If SRAM size changes change this value as well\n\tmemset(SRAM, SNESGameFixes.SRAMInitialValue, 0x80000);\n}\n\nbool8 CMemory::LoadSRAM (const char *filename)\n{\n\tFILE\t*file;\n\tint\t\tsize, len;\n\n\tClearSRAM();\n\n\tif (Multi.cartType && Multi.sramSizeB)\n\t{\n\t\tsize = (1 << (Multi.sramSizeB + 3)) * 128;\n\n\t\tfile = fopen(S9xGetFilename(Multi.fileNameB, \".srm\", SRAM_DIR).c_str(), \"rb\");\n\t\tif (file)\n\t\t{\n\t\t\tlen = fread((char *) Multi.sramB, 1, 0x10000, file);\n\t\t\tfclose(file);\n\t\t\tif (len - size == 512)\n\t\t\t\tmemmove(Multi.sramB, Multi.sramB + 512, size);\n\t\t}\n\t}\n\n\tsize = SRAMSize ? (1 << (SRAMSize + 3)) * 128 : 0;\n\tif (LoROM)\n\t\tsize = size < 0x70000 ? size : 0x70000;\n\telse if (HiROM)\n\t\tsize = size < 0x40000 ? size : 0x40000;\n\n\tif (size)\n\t{\n\t\tfile = fopen(filename, \"rb\");\n\t\tif (file)\n\t\t{\n\t\t\tlen = fread((char *) SRAM, 1, size, file);\n\t\t\tfclose(file);\n\t\t\tif (len - size == 512)\n\t\t\t\tmemmove(SRAM, SRAM + 512, size);\n\n\t\t\tif (Settings.SRTC || Settings.SPC7110RTC)\n\t\t\t\tLoadSRTC();\n\n\t\t\treturn (TRUE);\n\t\t}\n\t\telse if (Settings.BS && !Settings.BSXItself)\n\t\t{\n\t\t\t// The BS game's SRAM was not found\n\t\t\t// Try to read BS-X.srm instead\n\t\t\tstd::string path = S9xGetDirectory(SRAM_DIR) + SLASH_STR + \"BS-X.srm\";\n\n\t\t\tfile = fopen(path.c_str(), \"rb\");\n\t\t\tif (file)\n\t\t\t{\n\t\t\t\tlen = fread((char *) SRAM, 1, size, file);\n\t\t\t\tfclose(file);\n\t\t\t\tif (len - size == 512)\n\t\t\t\t\tmemmove(SRAM, SRAM + 512, size);\n\n\t\t\t\tS9xMessage(S9X_INFO, S9X_ROM_INFO, \"The SRAM file wasn't found: BS-X.srm was read instead.\");\n\t\t\t\treturn (TRUE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS9xMessage(S9X_INFO, S9X_ROM_INFO, \"The SRAM file wasn't found, BS-X.srm wasn't found either.\");\n\t\t\t\treturn (FALSE);\n\t\t\t}\n\t\t}\n\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool8 CMemory::SaveSRAM (const char *filename)\n{\n\tif (Settings.SuperFX && ROMType < 0x15) // doesn't have SRAM\n\t\treturn (TRUE);\n\n\tif (Settings.SA1 && ROMType == 0x34)    // doesn't have SRAM\n\t\treturn (TRUE);\n\n\tFILE\t*file;\n\tint\t\tsize;\n\n\tif (Multi.cartType && Multi.sramSizeB)\n\t{\n\t\tstd::string name = S9xGetFilename(Multi.fileNameB, \".srm\", SRAM_DIR);\n\t\tsize = (1 << (Multi.sramSizeB + 3)) * 128;\n\n\t\tfile = fopen(name.c_str(), \"wb\");\n\t\tif (file)\n\t\t{\n\t\t\tif (!fwrite((char *) Multi.sramB, size, 1, file))\n\t\t\t\tprintf (\"Couldn't write to subcart SRAM file.\\n\");\n\t\t\tfclose(file);\n\t\t}\n    }\n\n    size = SRAMSize ? (1 << (SRAMSize + 3)) * 128 : 0;\n\tif (LoROM)\n\t\tsize = size < 0x70000 ? size : 0x70000;\n\telse if (HiROM)\n\t\tsize = size < 0x40000 ? size : 0x40000;\n\n\tif (size)\n\t{\n\t\tfile = fopen(filename, \"wb\");\n\t\tif (file)\n\t\t{\n\t\t\tif (!fwrite((char *) SRAM, size, 1, file))\n\t\t\t\tprintf (\"Couldn't write to SRAM file.\\n\");\n\t\t\tfclose(file);\n\n\t\t\tif (Settings.SRTC || Settings.SPC7110RTC)\n\t\t\t\tSaveSRTC();\n\n\t\t\treturn (TRUE);\n\t\t}\n\t}\n\n\treturn (FALSE);\n}\n\nbool8 CMemory::SaveMPAK (const char *filename)\n{\n\tif (Settings.BS || (Multi.cartSizeB && (Multi.cartType == 3)))\n\t{\n\t\tFILE\t*file;\n\t\tint\t\tsize;\n\n\t\tsize = 0x100000;\n\t\tif (size)\n\t\t{\n\t\t\tfile = fopen(filename, \"wb\");\n\t\t\tif (file)\n\t\t\t{\n\t\t\t\tsize_t\twritten;\n\t\t\t\twritten = fwrite((char *)Memory.ROM + Multi.cartOffsetB, size, 1, file);\n\t\t\t\tfclose(file);\n\n\t\t\t\treturn (written > 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn (FALSE);\n}\n\n// initialization\n\nstatic uint32 caCRC32 (uint8 *array, uint32 size, uint32 crc32)\n{\n\tfor (uint32 i = 0; i < size; i++)\n\t\tcrc32 = ((crc32 >> 8) & 0x00FFFFFF) ^ crc32Table[(crc32 ^ array[i]) & 0xFF];\n\n\treturn (~crc32);\n}\n\nvoid CMemory::ParseSNESHeader (uint8 *RomHeader)\n{\n\tbool8\tbs = Settings.BS & !Settings.BSXItself;\n\n\tstrncpy(ROMName, (char *) &RomHeader[0x10], ROM_NAME_LEN - 1);\n\tif (bs)\n\t\tmemset(ROMName + 16, 0x20, ROM_NAME_LEN - 17);\n\n\tif (bs)\n\t{\n\t\tif (!(((RomHeader[0x29] & 0x20) && CalculatedSize <  0x100000) ||\n\t\t\t (!(RomHeader[0x29] & 0x20) && CalculatedSize == 0x100000)))\n\t\t\tprintf(\"BS: Size mismatch\\n\");\n\n\t\t// FIXME\n\t\tint\tp = 0;\n\t\twhile ((1 << p) < (int) CalculatedSize)\n\t\t\tp++;\n\t\tROMSize = p - 10;\n\t}\n\telse\n\t\tROMSize = RomHeader[0x27];\n\n\tSRAMSize  = bs ? 5 /* BS-X */    : RomHeader[0x28];\n\tROMSpeed  = bs ? RomHeader[0x28] : RomHeader[0x25];\n\tROMType   = bs ? 0xE5 /* BS-X */ : RomHeader[0x26];\n\tROMRegion = bs ? 0               : RomHeader[0x29];\n\n\tROMChecksum           = RomHeader[0x2E] + (RomHeader[0x2F] << 8);\n\tROMComplementChecksum = RomHeader[0x2C] + (RomHeader[0x2D] << 8);\n\n\tmemmove(ROMId, &RomHeader[0x02], 4);\n\n\tif (RomHeader[0x2A] != 0x33)\n\t\tCompanyId = ((RomHeader[0x2A] >> 4) & 0x0F) * 36 + (RomHeader[0x2A] & 0x0F);\n\telse\n\tif (isalnum(RomHeader[0x00]) && isalnum(RomHeader[0x01]))\n\t{\n\t\tint\tl, r, l2, r2;\n\t\tl = toupper(RomHeader[0x00]);\n\t\tr = toupper(RomHeader[0x01]);\n\t\tl2 = (l > '9') ? l - '7' : l - '0';\n\t\tr2 = (r > '9') ? r - '7' : r - '0';\n\t\tCompanyId = l2 * 36 + r2;\n\t}\n}\n\nvoid CMemory::InitROM (void)\n{\n\tSettings.SuperFX = FALSE;\n\tSettings.DSP = 0;\n\tSettings.SA1 = FALSE;\n\tSettings.C4 = FALSE;\n\tSettings.SDD1 = FALSE;\n\tSettings.SPC7110 = FALSE;\n\tSettings.SPC7110RTC = FALSE;\n\tSettings.OBC1 = FALSE;\n\tSettings.SETA = 0;\n\tSettings.SRTC = FALSE;\n\tSettings.BS = FALSE;\n\tSettings.MSU1 = FALSE;\n\n\tSuperFX.nRomBanks = CalculatedSize >> 15;\n\n\t//// Parse ROM header and read ROM informatoin\n\n\tCompanyId = -1;\n\tmemset(ROMId, 0, 5);\n\n\tuint8\t*RomHeader = ROM + 0x7FB0;\n\tif (ExtendedFormat == BIGFIRST)\n\t\tRomHeader += 0x400000;\n\tif (HiROM)\n\t\tRomHeader += 0x8000;\n\n\tS9xInitBSX(); // Set BS header before parsing\n\n\tParseSNESHeader(RomHeader);\n\n\t//// Detect and initialize chips\n\t//// detection codes are compatible with NSRT\n\n\t// DSP1/2/3/4\n\tif (ROMType == 0x03)\n\t{\n\t\tif (ROMSpeed == 0x30)\n\t\t\tSettings.DSP = 4; // DSP4\n\t\telse\n\t\t\tSettings.DSP = 1; // DSP1\n\t}\n\telse if (ROMType == 0x05)\n\t{\n\t\tif (ROMSpeed == 0x20)\n\t\t\tSettings.DSP = 2; // DSP2\n\t\telse if (ROMSpeed == 0x30 && RomHeader[0x2a] == 0xb2)\n\t\t\tSettings.DSP = 3; // DSP3\n\t\telse\n\t\t\tSettings.DSP = 1; // DSP1\n\t}\n\n\tswitch (Settings.DSP)\n\t{\n\t\tcase 1:\t// DSP1\n\t\t\tif (HiROM)\n\t\t\t{\n\t\t\t\tDSP0.boundary = 0x7000;\n\t\t\t\tDSP0.maptype = M_DSP1_HIROM;\n\t\t\t}\n\t\t\telse if (CalculatedSize > 0x100000)\n\t\t\t{\n\t\t\t\tDSP0.boundary = 0x4000;\n\t\t\t\tDSP0.maptype = M_DSP1_LOROM_L;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDSP0.boundary = 0xc000;\n\t\t\t\tDSP0.maptype = M_DSP1_LOROM_S;\n\t\t\t}\n\n\t\t\tSetDSP = &DSP1SetByte;\n\t\t\tGetDSP = &DSP1GetByte;\n\t\t\tbreak;\n\n\t\tcase 2: // DSP2\n\t\t\tDSP0.boundary = 0x10000;\n\t\t\tDSP0.maptype = M_DSP2_LOROM;\n\t\t\tSetDSP = &DSP2SetByte;\n\t\t\tGetDSP = &DSP2GetByte;\n\t\t\tbreak;\n\n\t\tcase 3: // DSP3\n\t\t\tDSP0.boundary = 0xc000;\n\t\t\tDSP0.maptype = M_DSP3_LOROM;\n\t\t\tSetDSP = &DSP3SetByte;\n\t\t\tGetDSP = &DSP3GetByte;\n\t\t\tbreak;\n\n\t\tcase 4: // DSP4\n\t\t\tDSP0.boundary = 0xc000;\n\t\t\tDSP0.maptype = M_DSP4_LOROM;\n\t\t\tSetDSP = &DSP4SetByte;\n\t\t\tGetDSP = &DSP4GetByte;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tSetDSP = NULL;\n\t\t\tGetDSP = NULL;\n\t\t\tbreak;\n\t}\n\n\tuint32\tidentifier = ((ROMType & 0xff) << 8) + (ROMSpeed & 0xff);\n\n\tswitch (identifier)\n\t{\n\t    // SRTC\n\t\tcase 0x5535:\n\t\t\tSettings.SRTC = TRUE;\n\t\t\tS9xInitSRTC();\n\t\t\tbreak;\n\n\t\t// SPC7110\n\t\tcase 0xF93A:\n\t\t\tSettings.SPC7110RTC = TRUE;\n\t\t\t// Fall through\n\t\tcase 0xF53A:\n\t\t\tSettings.SPC7110 = TRUE;\n\t\t\tS9xInitSPC7110();\n\t\t\tbreak;\n\n\t\t// OBC1\n\t\tcase 0x2530:\n\t\t\tSettings.OBC1 = TRUE;\n\t\t\tbreak;\n\n\t\t// SA1\n\t\tcase 0x3423:\n\t\tcase 0x3523:\n\t\t\tSettings.SA1 = TRUE;\n\t\t\tbreak;\n\n\t\t// SuperFX\n\t\tcase 0x1320:\n\t\tcase 0x1420:\n\t\tcase 0x1520:\n\t\tcase 0x1A20:\n\t\t// SuperFX FastROM for ROM hacks\n\t\tcase 0x1330:\n\t\tcase 0x1430:\n\t\tcase 0x1530:\n\t\tcase 0x1A30:\n\t\t\tSettings.SuperFX = TRUE;\n\t\t\tS9xInitSuperFX();\n\t\t\tif (ROM[0x7FDA] == 0x33)\n\t\t\t\tSRAMSize = ROM[0x7FBD];\n\t\t\telse\n\t\t\t\tSRAMSize = 5;\n\t\t\tbreak;\n\n\t\t// SDD1\n\t\tcase 0x4332:\n\t\tcase 0x4532:\n\t\t\tSettings.SDD1 = TRUE;\n\t\t\tbreak;\n\n\t\t// ST018\n\t\tcase 0xF530:\n\t\t\tSettings.SETA = ST_018;\n\t\t\tSetSETA = NULL;\n\t\t\tGetSETA = NULL;\n\t\t\tSRAMSize = 2;\n\t\t\tSNESGameFixes.SRAMInitialValue = 0x00;\n\t\t\tbreak;\n\n\t\t// ST010/011\n\t\tcase 0xF630:\n\t\t\tif (ROM[0x7FD7] == 0x09)\n\t\t\t{\n\t\t\t\tSettings.SETA = ST_011;\n\t\t\t\tSetSETA = &S9xSetST011;\n\t\t\t\tGetSETA = &S9xGetST011;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSettings.SETA = ST_010;\n\t\t\t\tSetSETA = &S9xSetST010;\n\t\t\t\tGetSETA = &S9xGetST010;\n\t\t\t}\n\n\t\t\tSRAMSize = 2;\n\t\t\tSNESGameFixes.SRAMInitialValue = 0x00;\n\t\t\tbreak;\n\n\t\t// C4\n\t\tcase 0xF320:\n\t\t\tSettings.C4 = TRUE;\n\t\t\tbreak;\n\t}\n\n\t// MSU1\n\tSettings.MSU1 = S9xMSU1ROMExists();\n\n\t//// Map memory and calculate checksum\n\n\tMap_Initialize();\n\tCalculatedChecksum = 0;\n\n\tif (HiROM)\n\t{\n\t\tif (Settings.BS)\n\t\t\t/* Do nothing */;\n\t\telse if (Settings.SPC7110)\n\t\t\tMap_SPC7110HiROMMap();\n\t\telse if (ExtendedFormat != NOPE)\n\t\t\tMap_ExtendedHiROMMap();\n\t\telse if (Multi.cartType == 3)\n\t\t\tMap_BSCartHiROMMap();\n\t\telse\n\t\t\tMap_HiROMMap();\n\t}\n\telse\n\t{\n\t\tif (Settings.BS)\n\t\t\t/* Do nothing */;\n\t\telse if (Settings.SETA && Settings.SETA != ST_018)\n\t\t\tMap_SetaDSPLoROMMap();\n\t\telse if (Settings.SuperFX)\n\t\t\tMap_SuperFXLoROMMap();\n\t\telse if (Settings.SA1)\n\t\t{\n\t\t\tif (Multi.cartType == 5)\n\t\t\t\tMap_BSSA1LoROMMap();\n\t\t\telse\n\t\t\t\tMap_SA1LoROMMap();\n\t\t}\n\t\telse if (Settings.SDD1)\n\t\t\tMap_SDD1LoROMMap();\n\t\telse if (ExtendedFormat != NOPE)\n\t\t\tMap_JumboLoROMMap();\n\t\telse\n\t\tif (strncmp(ROMName, \"WANDERERS FROM YS\", 17) == 0)\n\t\t\tMap_NoMAD1LoROMMap();\n\t\telse if (Multi.cartType == 3)\n\t\t\tif (strncmp(ROMName, \"SOUND NOVEL-TCOOL\", 17) == 0 ||\n\t\t\t\tstrncmp(ROMName, \"DERBY STALLION 96\", 17) == 0)\n\t\t\t\tMap_BSCartLoROMMap(1);\n\t\t\telse\n\t\t\t\tMap_BSCartLoROMMap(0);\n\t\telse if (strncmp(ROMName, \"SOUND NOVEL-TCOOL\", 17) == 0 ||\n\t\t\tstrncmp(ROMName, \"DERBY STALLION 96\", 17) == 0)\n\t\t\tMap_ROM24MBSLoROMMap();\n\t\telse if (strncmp(ROMName, \"THOROUGHBRED BREEDER3\", 21) == 0 ||\n\t\t\tstrncmp(ROMName, \"RPG-TCOOL 2\", 11) == 0)\n\t\t\tMap_SRAM512KLoROMMap();\n\t\telse if (strncmp(ROMName, \"ADD-ON BASE CASSETE\", 19) == 0)\n\t\t{\n\t\t\tif (Multi.cartType == 4)\n\t\t\t{\n\t\t\t\tSRAMSize = Multi.sramSizeA;\n\t\t\t\tMap_SufamiTurboLoROMMap();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSRAMSize = 5;\n\t\t\t\tMap_SufamiTurboPseudoLoROMMap();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tMap_LoROMMap();\n    }\n\n\tChecksum_Calculate();\n\n\tbool8 isChecksumOK = (ROMChecksum + ROMComplementChecksum == 0xffff) &\n\t\t\t\t\t\t (ROMChecksum == CalculatedChecksum);\n\n\t//// Build more ROM information\n\n\t// CRC32\n\tif (!Settings.BS || Settings.BSXItself) // Not BS Dump\n\t{\n\t\tROMCRC32 = caCRC32(ROM, CalculatedSize);\n\t\tsha256sum(ROM, CalculatedSize, ROMSHA256);\n\t}\n\telse // Convert to correct format before scan\n\t{\n\t\tint offset = HiROM ? 0xffc0 : 0x7fc0;\n\t\t// Backup\n\t\tuint8 BSMagic0 = ROM[offset + 22],\n\t\t\t  BSMagic1 = ROM[offset + 23];\n\t\t// uCONSRT standard\n\t\tROM[offset + 22] = 0x42;\n\t\tROM[offset + 23] = 0x00;\n\t\t// Calc\n\t\tROMCRC32 = caCRC32(ROM, CalculatedSize);\n\t\tsha256sum(ROM, CalculatedSize, ROMSHA256);\n\t\t// Convert back\n\t\tROM[offset + 22] = BSMagic0;\n\t\tROM[offset + 23] = BSMagic1;\n\t}\n\n\t// NTSC/PAL\n\tif (Settings.ForceNTSC)\n\t\tSettings.PAL = FALSE;\n\telse if (Settings.ForcePAL)\n\t\tSettings.PAL = TRUE;\n\telse if (!Settings.BS && (((ROMRegion >= 2) && (ROMRegion <= 12)) || ROMRegion == 18)) // 18 is used by \"Tintin in Tibet (Europe) (En,Es,Sv)\"\n\t\tSettings.PAL = TRUE;\n\telse\n\t\tSettings.PAL = FALSE;\n\n\tif (Settings.PAL)\n\t{\n\t\tSettings.FrameTime = Settings.FrameTimePAL;\n\t\tROMFramesPerSecond = 50;\n\t}\n\telse\n\t{\n\t\tSettings.FrameTime = Settings.FrameTimeNTSC;\n\t\tROMFramesPerSecond = 60;\n\t}\n\n\t// truncate cart name\n\tROMName[ROM_NAME_LEN - 1] = 0;\n\tif (strlen(ROMName))\n\t{\n\t\tchar *p = ROMName + strlen(ROMName);\n\t\tif (p > ROMName + 21 && ROMName[20] == ' ')\n\t\t\tp = ROMName + 21;\n\t\twhile (p > ROMName && *(p - 1) == ' ')\n\t\t\tp--;\n\t\t*p = 0;\n\t}\n\n\t// SRAM size\n\tSRAMMask = SRAMSize ? ((1 << (SRAMSize + 3)) * 128) - 1 : 0;\n\n\t// checksum\n\tif (!isChecksumOK || ((uint32) CalculatedSize > (uint32) (((1 << (ROMSize - 7)) * 128) * 1024)))\n\t{\n\t\tSettings.DisplayColor = BUILD_PIXEL(31, 31, 0);\n\t\tSET_UI_COLOR(255, 255, 0);\n\t}\n\n\t// Use slight blue tint to indicate ROM was patched.\n\tif (Settings.IsPatched)\n\t{\n\t\tSettings.DisplayColor = BUILD_PIXEL(26, 26, 31);\n\t\tSET_UI_COLOR(216, 216, 255);\n\t}\n\n\tif (Multi.cartType == 4)\n\t{\n\t\tSettings.DisplayColor = BUILD_PIXEL(0, 16, 31);\n\t\tSET_UI_COLOR(0, 128, 255);\n\t}\n\n\t//// Initialize emulation\n\n\tTimings.H_Max_Master = SNES_CYCLES_PER_SCANLINE;\n\tTimings.H_Max        = Timings.H_Max_Master;\n\tTimings.HBlankStart  = SNES_HBLANK_START_HC;\n\tTimings.HBlankEnd    = SNES_HBLANK_END_HC;\n\tTimings.HDMAInit     = SNES_HDMA_INIT_HC;\n\tTimings.HDMAStart    = SNES_HDMA_START_HC;\n\tTimings.RenderPos    = SNES_RENDER_START_HC;\n\tTimings.V_Max_Master = Settings.PAL ? SNES_MAX_PAL_VCOUNTER : SNES_MAX_NTSC_VCOUNTER;\n\tTimings.V_Max        = Timings.V_Max_Master;\n\t/* From byuu: The total delay time for both the initial (H)DMA sync (to the DMA clock),\n\t   and the end (H)DMA sync (back to the last CPU cycle's mcycle rate (6, 8, or 12)) always takes between 12-24 mcycles.\n\t   Possible delays: { 12, 14, 16, 18, 20, 22, 24 }\n\t   XXX: Snes9x can't emulate this timing :( so let's use the average value... */\n\tTimings.DMACPUSync   = 18;\n\t/* If the CPU is halted (i.e. for DMA) while /NMI goes low, the NMI will trigger\n\t   after the DMA completes (even if /NMI goes high again before the DMA\n\t   completes). In this case, there is a 24-30 cycle delay between the end of DMA\n\t   and the NMI handler, time enough for an instruction or two. */\n\t// Wild Guns, Mighty Morphin Power Rangers - The Fighting Edition\n\tTimings.NMIDMADelay  = 24;\n\tTimings.IRQTriggerCycles = 14;\n\tTimings.APUSpeedup = 0;\n\tS9xAPUTimingSetSpeedup(Timings.APUSpeedup);\n\n\tIPPU.TotalEmulatedFrames = 0;\n\n\t//// Hack games\n\n\tApplyROMFixes();\n\n\t//// Show ROM information\n\tROMId[4] = 0;\n    strcpy(ROMId, SafeString(ROMId).c_str());\n\n\n\tsprintf(String, \"\\\"%s\\\" [%s] %s, %s, %s, %s, SRAM:%s, ID:%s, CRC32:%08X\",\n\t\tSafeString(ROMName).c_str(),\n\t\t isChecksumOK ? \"checksum ok\"\n\t\t : Settings.IsPatched == 3 ? \"UPS Patched\"\n\t\t : Settings.IsPatched == 2 ? \"BPS Patched\"\n\t\t : Settings.IsPatched == 1 ? \"IPS Patched\"\n\t\t : ((Multi.cartType == 4) ? \"no checksum\"\n\t\t : \"bad checksum\"),\n\t\tMapType(), Size(), KartContents(), Settings.PAL ? \"PAL\" : \"NTSC\", StaticRAMSize(), ROMId, ROMCRC32);\n\n\tS9xMessage(S9X_INFO, S9X_ROM_INFO, GetMultilineROMInfo().c_str());\n\n\tSettings.ForceLoROM = FALSE;\n\tSettings.ForceHiROM = FALSE;\n\tSettings.ForceHeader = FALSE;\n\tSettings.ForceNoHeader = FALSE;\n\tSettings.ForceInterleaved = FALSE;\n\tSettings.ForceInterleaved2 = FALSE;\n\tSettings.ForceInterleaveGD24 = FALSE;\n\tSettings.ForceNotInterleaved = FALSE;\n\tSettings.ForcePAL = FALSE;\n\tSettings.ForceNTSC = FALSE;\n\n\tSettings.TakeScreenshot = FALSE;\n\n\tif (stopMovie)\n\t\tS9xMovieStop(TRUE);\n\n\tif (PostRomInitFunc)\n\t\tPostRomInitFunc();\n\n    S9xVerifyControllers();\n}\n\n// memory map\n\nuint32 CMemory::map_mirror (uint32 size, uint32 pos)\n{\n\t// from bsnes\n\tif (size == 0)\n\t\treturn (0);\n\tif (pos < size)\n\t\treturn (pos);\n\n\tuint32\tmask = 1 << 31;\n\twhile (!(pos & mask))\n\t\tmask >>= 1;\n\n\tif (size <= (pos & mask))\n\t\treturn (map_mirror(size, pos - mask));\n\telse\n\t\treturn (mask + map_mirror(size - mask, pos - mask));\n}\n\nvoid CMemory::map_lorom (uint32 bank_s, uint32 bank_e, uint32 addr_s, uint32 addr_e, uint32 size)\n{\n\tuint32\tc, i, p, addr;\n\n\tfor (c = bank_s; c <= bank_e; c++)\n\t{\n\t\tfor (i = addr_s; i <= addr_e; i += 0x1000)\n\t\t{\n\t\t\tp = (c << 4) | (i >> 12);\n\t\t\taddr = (c & 0x7f) * 0x8000;\n\t\t\tMap[p] = ROM + map_mirror(size, addr) - (i & 0x8000);\n\t\t\tBlockIsROM[p] = TRUE;\n\t\t\tBlockIsRAM[p] = FALSE;\n\t\t}\n\t}\n}\n\nvoid CMemory::map_hirom (uint32 bank_s, uint32 bank_e, uint32 addr_s, uint32 addr_e, uint32 size)\n{\n\tuint32\tc, i, p, addr;\n\n\tfor (c = bank_s; c <= bank_e; c++)\n\t{\n\t\tfor (i = addr_s; i <= addr_e; i += 0x1000)\n\t\t{\n\t\t\tp = (c << 4) | (i >> 12);\n\t\t\taddr = c << 16;\n\t\t\tMap[p] = ROM + map_mirror(size, addr);\n\t\t\tBlockIsROM[p] = TRUE;\n\t\t\tBlockIsRAM[p] = FALSE;\n\t\t}\n\t}\n}\n\nvoid CMemory::map_lorom_offset (uint32 bank_s, uint32 bank_e, uint32 addr_s, uint32 addr_e, uint32 size, uint32 offset)\n{\n\tuint32\tc, i, p, addr;\n\n\tfor (c = bank_s; c <= bank_e; c++)\n\t{\n\t\tfor (i = addr_s; i <= addr_e; i += 0x1000)\n\t\t{\n\t\t\tp = (c << 4) | (i >> 12);\n\t\t\taddr = ((c - bank_s) & 0x7f) * 0x8000;\n\t\t\tMap[p] = ROM + offset + map_mirror(size, addr) - (i & 0x8000);\n\t\t\tBlockIsROM[p] = TRUE;\n\t\t\tBlockIsRAM[p] = FALSE;\n\t\t}\n\t}\n}\n\nvoid CMemory::map_hirom_offset (uint32 bank_s, uint32 bank_e, uint32 addr_s, uint32 addr_e, uint32 size, uint32 offset)\n{\n\tuint32\tc, i, p, addr;\n\n\tfor (c = bank_s; c <= bank_e; c++)\n\t{\n\t\tfor (i = addr_s; i <= addr_e; i += 0x1000)\n\t\t{\n\t\t\tp = (c << 4) | (i >> 12);\n\t\t\taddr = (c - bank_s) << 16;\n\t\t\tMap[p] = ROM + offset + map_mirror(size, addr);\n\t\t\tBlockIsROM[p] = TRUE;\n\t\t\tBlockIsRAM[p] = FALSE;\n\t\t}\n\t}\n}\n\nvoid CMemory::map_space (uint32 bank_s, uint32 bank_e, uint32 addr_s, uint32 addr_e, uint8 *data)\n{\n\tuint32\tc, i, p;\n\n\tfor (c = bank_s; c <= bank_e; c++)\n\t{\n\t\tfor (i = addr_s; i <= addr_e; i += 0x1000)\n\t\t{\n\t\t\tp = (c << 4) | (i >> 12);\n\t\t\tMap[p] = data;\n\t\t\tBlockIsROM[p] = FALSE;\n\t\t\tBlockIsRAM[p] = TRUE;\n\t\t}\n\t}\n}\n\nvoid CMemory::map_index (uint32 bank_s, uint32 bank_e, uint32 addr_s, uint32 addr_e, int index, int type)\n{\n\tuint32\tc, i, p;\n\tbool8\tisROM, isRAM;\n\n\tisROM = ((type == MAP_TYPE_I_O) || (type == MAP_TYPE_RAM)) ? FALSE : TRUE;\n\tisRAM = ((type == MAP_TYPE_I_O) || (type == MAP_TYPE_ROM)) ? FALSE : TRUE;\n\n\tfor (c = bank_s; c <= bank_e; c++)\n\t{\n\t\tfor (i = addr_s; i <= addr_e; i += 0x1000)\n\t\t{\n\t\t\tp = (c << 4) | (i >> 12);\n\t\t\tMap[p] = (uint8 *) (pint) index;\n\t\t\tBlockIsROM[p] = isROM;\n\t\t\tBlockIsRAM[p] = isRAM;\n\t\t}\n\t}\n}\n\nvoid CMemory::map_System (void)\n{\n\t// will be overwritten\n\tmap_space(0x00, 0x3f, 0x0000, 0x1fff, RAM);\n\tmap_index(0x00, 0x3f, 0x2000, 0x3fff, MAP_PPU, MAP_TYPE_I_O);\n\tmap_index(0x00, 0x3f, 0x4000, 0x5fff, MAP_CPU, MAP_TYPE_I_O);\n\tmap_space(0x80, 0xbf, 0x0000, 0x1fff, RAM);\n\tmap_index(0x80, 0xbf, 0x2000, 0x3fff, MAP_PPU, MAP_TYPE_I_O);\n\tmap_index(0x80, 0xbf, 0x4000, 0x5fff, MAP_CPU, MAP_TYPE_I_O);\n}\n\nvoid CMemory::map_WRAM (void)\n{\n\t// will overwrite others\n\tmap_space(0x7e, 0x7e, 0x0000, 0xffff, RAM);\n\tmap_space(0x7f, 0x7f, 0x0000, 0xffff, RAM + 0x10000);\n}\n\nvoid CMemory::map_LoROMSRAM (void)\n{\n        uint32 hi;\n\n        if (ROMSize > 11 || SRAMSize > 5)\n            hi = 0x7fff;\n        else\n            hi = 0xffff;\n\n\tmap_index(0x70, 0x7d, 0x0000, hi, MAP_LOROM_SRAM, MAP_TYPE_RAM);\n\tif (SRAMSize > 0)\n            map_index(0xf0, 0xff, 0x0000, hi, MAP_LOROM_SRAM, MAP_TYPE_RAM);\n}\n\nvoid CMemory::map_HiROMSRAM (void)\n{\n\tmap_index(0x20, 0x3f, 0x6000, 0x7fff, MAP_HIROM_SRAM, MAP_TYPE_RAM);\n\tmap_index(0xa0, 0xbf, 0x6000, 0x7fff, MAP_HIROM_SRAM, MAP_TYPE_RAM);\n}\n\nvoid CMemory::map_DSP (void)\n{\n\tswitch (DSP0.maptype)\n\t{\n\t\tcase M_DSP1_LOROM_S:\n\t\t\tmap_index(0x20, 0x3f, 0x8000, 0xffff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tmap_index(0xa0, 0xbf, 0x8000, 0xffff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tbreak;\n\n\t\tcase M_DSP1_LOROM_L:\n\t\t\tmap_index(0x60, 0x6f, 0x0000, 0x7fff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tmap_index(0xe0, 0xef, 0x0000, 0x7fff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tbreak;\n\n\t\tcase M_DSP1_HIROM:\n\t\t\tmap_index(0x00, 0x1f, 0x6000, 0x7fff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tmap_index(0x80, 0x9f, 0x6000, 0x7fff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tbreak;\n\n\t\tcase M_DSP2_LOROM:\n\t\t\tmap_index(0x20, 0x3f, 0x6000, 0x6fff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tmap_index(0x20, 0x3f, 0x8000, 0xbfff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tmap_index(0xa0, 0xbf, 0x6000, 0x6fff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tmap_index(0xa0, 0xbf, 0x8000, 0xbfff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tbreak;\n\n\t\tcase M_DSP3_LOROM:\n\t\t\tmap_index(0x20, 0x3f, 0x8000, 0xffff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tmap_index(0xa0, 0xbf, 0x8000, 0xffff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tbreak;\n\n\t\tcase M_DSP4_LOROM:\n\t\t\tmap_index(0x30, 0x3f, 0x8000, 0xffff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tmap_index(0xb0, 0xbf, 0x8000, 0xffff, MAP_DSP, MAP_TYPE_I_O);\n\t\t\tbreak;\n\t}\n}\n\nvoid CMemory::map_C4 (void)\n{\n\tmap_index(0x00, 0x3f, 0x6000, 0x7fff, MAP_C4, MAP_TYPE_I_O);\n\tmap_index(0x80, 0xbf, 0x6000, 0x7fff, MAP_C4, MAP_TYPE_I_O);\n}\n\nvoid CMemory::map_OBC1 (void)\n{\n\tmap_index(0x00, 0x3f, 0x6000, 0x7fff, MAP_OBC_RAM, MAP_TYPE_I_O);\n\tmap_index(0x80, 0xbf, 0x6000, 0x7fff, MAP_OBC_RAM, MAP_TYPE_I_O);\n}\n\nvoid CMemory::map_SetaRISC (void)\n{\n\tmap_index(0x00, 0x3f, 0x3000, 0x3fff, MAP_SETA_RISC, MAP_TYPE_I_O);\n\tmap_index(0x80, 0xbf, 0x3000, 0x3fff, MAP_SETA_RISC, MAP_TYPE_I_O);\n}\n\nvoid CMemory::map_SetaDSP (void)\n{\n\t// where does the SETA chip access, anyway?\n\t// please confirm this?\n\tmap_index(0x68, 0x6f, 0x0000, 0x7fff, MAP_SETA_DSP, MAP_TYPE_RAM);\n\t// and this!\n\tmap_index(0x60, 0x67, 0x0000, 0x3fff, MAP_SETA_DSP, MAP_TYPE_I_O);\n\n\t// ST-0010:\n\t// map_index(0x68, 0x6f, 0x0000, 0x0fff, MAP_SETA_DSP, ?);\n}\n\nvoid CMemory::map_WriteProtectROM (void)\n{\n\tmemmove((void *) WriteMap, (void *) Map, sizeof(Map));\n\n\tfor (int c = 0; c < 0x1000; c++)\n\t{\n\t\tif (BlockIsROM[c])\n\t\t\tWriteMap[c] = (uint8 *) MAP_NONE;\n\t}\n}\n\nvoid CMemory::Map_Initialize (void)\n{\n\tfor (int c = 0; c < 0x1000; c++)\n\t{\n\t\tMap[c]      = (uint8 *) MAP_NONE;\n\t\tWriteMap[c] = (uint8 *) MAP_NONE;\n\t\tBlockIsROM[c] = FALSE;\n\t\tBlockIsRAM[c] = FALSE;\n\t}\n}\n\nvoid CMemory::Map_LoROMMap (void)\n{\n\tprintf(\"Map_LoROMMap\\n\");\n\tmap_System();\n\n\tmap_lorom(0x00, 0x3f, 0x8000, 0xffff, CalculatedSize);\n\tmap_lorom(0x40, 0x7f, 0x0000, 0xffff, CalculatedSize);\n\tmap_lorom(0x80, 0xbf, 0x8000, 0xffff, CalculatedSize);\n\tmap_lorom(0xc0, 0xff, 0x0000, 0xffff, CalculatedSize);\n\n\tif (Settings.DSP)\n\t\tmap_DSP();\n\telse\n\tif (Settings.C4)\n\t\tmap_C4();\n\telse\n\tif (Settings.OBC1)\n\t\tmap_OBC1();\n\telse\n\tif (Settings.SETA == ST_018)\n\t\tmap_SetaRISC();\n\n    map_LoROMSRAM();\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_NoMAD1LoROMMap (void)\n{\n\tprintf(\"Map_NoMAD1LoROMMap\\n\");\n\tmap_System();\n\n\tmap_lorom(0x00, 0x3f, 0x8000, 0xffff, CalculatedSize);\n\tmap_lorom(0x40, 0x7f, 0x0000, 0xffff, CalculatedSize);\n\tmap_lorom(0x80, 0xbf, 0x8000, 0xffff, CalculatedSize);\n\tmap_lorom(0xc0, 0xff, 0x0000, 0xffff, CalculatedSize);\n\n\tmap_index(0x70, 0x7f, 0x0000, 0xffff, MAP_LOROM_SRAM, MAP_TYPE_RAM);\n\tmap_index(0xf0, 0xff, 0x0000, 0xffff, MAP_LOROM_SRAM, MAP_TYPE_RAM);\n\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_JumboLoROMMap (void)\n{\n\t// XXX: Which game uses this?\n\tprintf(\"Map_JumboLoROMMap\\n\");\n\tmap_System();\n\n\tmap_lorom_offset(0x00, 0x3f, 0x8000, 0xffff, CalculatedSize - 0x400000, 0x400000);\n\tmap_lorom_offset(0x40, 0x7f, 0x0000, 0xffff, CalculatedSize - 0x600000, 0x600000);\n\tmap_lorom_offset(0x80, 0xbf, 0x8000, 0xffff, 0x400000, 0);\n\tmap_lorom_offset(0xc0, 0xff, 0x0000, 0xffff, 0x400000, 0x200000);\n\n\tmap_LoROMSRAM();\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_ROM24MBSLoROMMap (void)\n{\n\t// PCB: BSC-1A5M-01, BSC-1A7M-10\n\tprintf(\"Map_ROM24MBSLoROMMap\\n\");\n\tmap_System();\n\n\tmap_lorom_offset(0x00, 0x1f, 0x8000, 0xffff, 0x100000, 0);\n\tmap_lorom_offset(0x20, 0x3f, 0x8000, 0xffff, 0x100000, 0x100000);\n\tmap_lorom_offset(0x80, 0x9f, 0x8000, 0xffff, 0x100000, 0x200000);\n\tmap_lorom_offset(0xa0, 0xbf, 0x8000, 0xffff, 0x100000, 0x100000);\n\n\tmap_LoROMSRAM();\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_SRAM512KLoROMMap (void)\n{\n\tprintf(\"Map_SRAM512KLoROMMap\\n\");\n\tmap_System();\n\n\tmap_lorom(0x00, 0x3f, 0x8000, 0xffff, CalculatedSize);\n\tmap_lorom(0x40, 0x7f, 0x0000, 0xffff, CalculatedSize);\n\tmap_lorom(0x80, 0xbf, 0x8000, 0xffff, CalculatedSize);\n\tmap_lorom(0xc0, 0xff, 0x0000, 0xffff, CalculatedSize);\n\n\tmap_space(0x70, 0x70, 0x0000, 0xffff, SRAM);\n\tmap_space(0x71, 0x71, 0x0000, 0xffff, SRAM + 0x8000);\n\tmap_space(0x72, 0x72, 0x0000, 0xffff, SRAM + 0x10000);\n\tmap_space(0x73, 0x73, 0x0000, 0xffff, SRAM + 0x18000);\n\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_SufamiTurboLoROMMap (void)\n{\n\tprintf(\"Map_SufamiTurboLoROMMap\\n\");\n\tmap_System();\n\n\tmap_lorom_offset(0x00, 0x1f, 0x8000, 0xffff, 0x40000, 0);\n\tmap_lorom_offset(0x20, 0x3f, 0x8000, 0xffff, Multi.cartSizeA, Multi.cartOffsetA);\n\tmap_lorom_offset(0x40, 0x5f, 0x8000, 0xffff, Multi.cartSizeB, Multi.cartOffsetB);\n\tmap_lorom_offset(0x80, 0x9f, 0x8000, 0xffff, 0x40000, 0);\n\tmap_lorom_offset(0xa0, 0xbf, 0x8000, 0xffff, Multi.cartSizeA, Multi.cartOffsetA);\n\tmap_lorom_offset(0xc0, 0xdf, 0x8000, 0xffff, Multi.cartSizeB, Multi.cartOffsetB);\n\n\tif (Multi.sramSizeA)\n\t{\n\t\tmap_index(0x60, 0x63, 0x8000, 0xffff, MAP_LOROM_SRAM, MAP_TYPE_RAM);\n\t\tmap_index(0xe0, 0xe3, 0x8000, 0xffff, MAP_LOROM_SRAM, MAP_TYPE_RAM);\n\t}\n\n\tif (Multi.sramSizeB)\n\t{\n\t\tmap_index(0x70, 0x73, 0x8000, 0xffff, MAP_LOROM_SRAM_B, MAP_TYPE_RAM);\n\t\tmap_index(0xf0, 0xf3, 0x8000, 0xffff, MAP_LOROM_SRAM_B, MAP_TYPE_RAM);\n\t}\n\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_SufamiTurboPseudoLoROMMap (void)\n{\n\t// for combined images\n\tprintf(\"Map_SufamiTurboPseudoLoROMMap\\n\");\n\tmap_System();\n\n\tmap_lorom_offset(0x00, 0x1f, 0x8000, 0xffff, 0x40000, 0);\n\tmap_lorom_offset(0x20, 0x3f, 0x8000, 0xffff, 0x100000, 0x100000);\n\tmap_lorom_offset(0x40, 0x5f, 0x8000, 0xffff, 0x100000, 0x200000);\n\tmap_lorom_offset(0x80, 0x9f, 0x8000, 0xffff, 0x40000, 0);\n\tmap_lorom_offset(0xa0, 0xbf, 0x8000, 0xffff, 0x100000, 0x100000);\n\tmap_lorom_offset(0xc0, 0xdf, 0x8000, 0xffff, 0x100000, 0x200000);\n\n\t// I don't care :P\n\tmap_space(0x60, 0x63, 0x8000, 0xffff, SRAM - 0x8000);\n\tmap_space(0xe0, 0xe3, 0x8000, 0xffff, SRAM - 0x8000);\n\tmap_space(0x70, 0x73, 0x8000, 0xffff, SRAM + 0x4000 - 0x8000);\n\tmap_space(0xf0, 0xf3, 0x8000, 0xffff, SRAM + 0x4000 - 0x8000);\n\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_SuperFXLoROMMap (void)\n{\n\tprintf(\"Map_SuperFXLoROMMap\\n\");\n\tmap_System();\n\n\t// Replicate the first 2Mb of the ROM at ROM + 8MB such that each 32K\n\t// block is repeated twice in each 64K block.\n\tfor (int c = 0; c < 64; c++)\n\t{\n\t\tmemmove(&ROM[0x800000 + c * 0x10000], &ROM[c * 0x8000], 0x8000);\n\t\tmemmove(&ROM[0x808000 + c * 0x10000], &ROM[c * 0x8000], 0x8000);\n\t}\n\n\t// Check GSU revision (not 100% accurate but it works)\n\t// GSU2\n\tif (CalculatedSize > 0x400000)\n\t{\n\t\tmap_lorom(0x00, 0x3f, 0x8000, 0xffff, 0x200000);\n\t\tmap_lorom(0x80, 0xbf, 0x8000, 0xffff, 0x200000);\n\n\t\tmap_hirom_offset(0x40, 0x5f, 0x0000, 0xffff, 0x200000, 0);\n\t\tmap_hirom_offset(0xc0, 0xff, 0x0000, 0xffff, CalculatedSize, 0);\n\n\t\tmap_space(0x00, 0x3f, 0x6000, 0x7fff, SRAM - 0x6000);\n\t\tmap_space(0x80, 0xbf, 0x6000, 0x7fff, SRAM - 0x6000);\n\t\tmap_space(0x70, 0x70, 0x0000, 0xffff, SRAM);\n\t\tmap_space(0x71, 0x71, 0x0000, 0xffff, SRAM + 0x10000);\n\t}\n\telse if (CalculatedSize > 0x200000)\n\t{\n\t\tmap_lorom(0x00, 0x3f, 0x8000, 0xffff, 0x200000);\n\t\tmap_lorom(0x80, 0xbf, 0x8000, 0xffff, 0x200000);\n\n\t\tmap_hirom_offset(0x40, 0x5f, 0x0000, 0xffff, 0x200000, 0);\n\t\tmap_hirom_offset(0xc0, 0xff, 0x0000, 0xffff, CalculatedSize, 0);\n\n\t\tmap_space(0x00, 0x3f, 0x6000, 0x7fff, SRAM - 0x6000);\n\t\tmap_space(0x80, 0xbf, 0x6000, 0x7fff, SRAM - 0x6000);\n\t\tmap_space(0x70, 0x70, 0x0000, 0xffff, SRAM);\n\t\tmap_space(0x71, 0x71, 0x0000, 0xffff, SRAM + 0x10000);\n\t}\n\t// GSU1\n\telse\n\t{\n\t\tmap_lorom(0x00, 0x3f, 0x8000, 0xffff, CalculatedSize);\n\t\tmap_lorom(0x80, 0xbf, 0x8000, 0xffff, CalculatedSize);\n\n\t\tmap_hirom_offset(0x40, 0x5f, 0x0000, 0xffff, CalculatedSize, 0);\n\t\tmap_hirom_offset(0xc0, 0xdf, 0x0000, 0xffff, CalculatedSize, 0);\n\n\t\tmap_space(0x00, 0x3f, 0x6000, 0x7fff, SRAM - 0x6000);\n\t\tmap_space(0x80, 0xbf, 0x6000, 0x7fff, SRAM - 0x6000);\n\t\tmap_space(0x70, 0x70, 0x0000, 0xffff, SRAM);\n\t\tmap_space(0x71, 0x71, 0x0000, 0xffff, SRAM + 0x10000);\n\t\tmap_space(0xf0, 0xf0, 0x0000, 0xffff, SRAM);\n\t\tmap_space(0xf1, 0xf1, 0x0000, 0xffff, SRAM + 0x10000);\n\t}\n\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_SetaDSPLoROMMap (void)\n{\n\tprintf(\"Map_SetaDSPLoROMMap\\n\");\n\tmap_System();\n\n\tmap_lorom(0x00, 0x3f, 0x8000, 0xffff, CalculatedSize);\n\tmap_lorom(0x40, 0x7f, 0x8000, 0xffff, CalculatedSize);\n\tmap_lorom(0x80, 0xbf, 0x8000, 0xffff, CalculatedSize);\n\tmap_lorom(0xc0, 0xff, 0x8000, 0xffff, CalculatedSize);\n\n\tmap_SetaDSP();\n\n    map_LoROMSRAM();\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_SDD1LoROMMap (void)\n{\n\tprintf(\"Map_SDD1LoROMMap\\n\");\n\tmap_System();\n\n\tmap_lorom(0x00, 0x3f, 0x8000, 0xffff, CalculatedSize);\n\tmap_lorom(0x80, 0xbf, 0x8000, 0xffff, CalculatedSize);\n\n\tmap_hirom_offset(0x60, 0x7f, 0x0000, 0xffff, CalculatedSize, 0);\n\tmap_hirom_offset(0xc0, 0xff, 0x0000, 0xffff, CalculatedSize, 0); // will be overwritten dynamically\n\n\tmap_index(0x70, 0x7f, 0x0000, 0x7fff, MAP_LOROM_SRAM, MAP_TYPE_RAM);\n\tmap_index(0xa0, 0xbf, 0x6000, 0x7fff, MAP_LOROM_SRAM, MAP_TYPE_RAM);\n\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_SA1LoROMMap (void)\n{\n\tprintf(\"Map_SA1LoROMMap\\n\");\n\tmap_System();\n\n\tmap_lorom(0x00, 0x3f, 0x8000, 0xffff, CalculatedSize);\n\tmap_lorom(0x80, 0xbf, 0x8000, 0xffff, CalculatedSize);\n\n\tmap_hirom_offset(0xc0, 0xff, 0x0000, 0xffff, CalculatedSize, 0);\n\n\tmap_space(0x00, 0x3f, 0x3000, 0x37ff, FillRAM);\n\tmap_space(0x80, 0xbf, 0x3000, 0x37ff, FillRAM);\n\tmap_index(0x00, 0x3f, 0x6000, 0x7fff, MAP_BWRAM, MAP_TYPE_I_O);\n\tmap_index(0x80, 0xbf, 0x6000, 0x7fff, MAP_BWRAM, MAP_TYPE_I_O);\n\n\tfor (int c = 0x40; c < 0x4f; c++)\n\t\tmap_space(c, c, 0x0000, 0xffff, SRAM + (c & 3) * 0x10000);\n\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n\n\t// Now copy the map and correct it for the SA1 CPU.\n\tmemmove((void *) SA1.Map, (void *) Map, sizeof(Map));\n\tmemmove((void *) SA1.WriteMap, (void *) WriteMap, sizeof(WriteMap));\n\n\t// SA-1 Banks 00->3f and 80->bf\n\tfor (int c = 0x000; c < 0x400; c += 0x10)\n\t{\n\t\tSA1.Map[c + 0] = SA1.Map[c + 0x800] = FillRAM + 0x3000;\n\t\tSA1.Map[c + 1] = SA1.Map[c + 0x801] = (uint8 *) MAP_NONE;\n\t\tSA1.WriteMap[c + 0] = SA1.WriteMap[c + 0x800] = FillRAM + 0x3000;\n\t\tSA1.WriteMap[c + 1] = SA1.WriteMap[c + 0x801] = (uint8 *) MAP_NONE;\n\t}\n\n\t// SA-1 Banks 40->4f\n\tfor (int c = 0x400; c < 0x500; c++)\n\t\tSA1.Map[c] = SA1.WriteMap[c] = (uint8*) MAP_SA1RAM;\n\n\t// SA-1 Banks 60->6f\n\tfor (int c = 0x600; c < 0x700; c++)\n\t\tSA1.Map[c] = SA1.WriteMap[c] = (uint8 *) MAP_BWRAM_BITMAP;\n\n\t// WRAM is inaccessable\n\tfor (int c = 0x7e0; c < 0x800; c++)\n\t\tSA1.Map[c] = SA1.WriteMap[c] = (uint8 *) MAP_NONE;\n\n\tBWRAM = SRAM;\n}\n\nvoid CMemory::Map_BSSA1LoROMMap(void)\n{\n\tprintf(\"Map_BSSA1LoROMMap\\n\");\n\tmap_System();\n\n\tmap_lorom_offset(0x00, 0x3f, 0x8000, 0xffff, Multi.cartSizeA, Multi.cartOffsetA);\n\tmap_lorom_offset(0x80, 0xbf, 0x8000, 0xffff, Multi.cartSizeA, Multi.cartOffsetA);\n\n\tmap_hirom_offset(0xc0, 0xff, 0x0000, 0xffff, Multi.cartSizeA, Multi.cartOffsetA);\n\n\tmap_space(0x00, 0x3f, 0x3000, 0x3fff, FillRAM);\n\tmap_space(0x80, 0xbf, 0x3000, 0x3fff, FillRAM);\n\tmap_index(0x00, 0x3f, 0x6000, 0x7fff, MAP_BWRAM, MAP_TYPE_I_O);\n\tmap_index(0x80, 0xbf, 0x6000, 0x7fff, MAP_BWRAM, MAP_TYPE_I_O);\n\n\tfor (int c = 0x40; c < 0x80; c++)\n\t\tmap_space(c, c, 0x0000, 0xffff, SRAM + (c & 1) * 0x10000);\n\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n\n\t// Now copy the map and correct it for the SA1 CPU.\n\tmemmove((void *) SA1.Map, (void *) Map, sizeof(Map));\n\tmemmove((void *) SA1.WriteMap, (void *) WriteMap, sizeof(WriteMap));\n\n\t// SA-1 Banks 00->3f and 80->bf\n\tfor (int c = 0x000; c < 0x400; c += 0x10)\n\t{\n\t\tSA1.Map[c + 0] = SA1.Map[c + 0x800] = FillRAM + 0x3000;\n\t\tSA1.Map[c + 1] = SA1.Map[c + 0x801] = (uint8 *) MAP_NONE;\n\t\tSA1.WriteMap[c + 0] = SA1.WriteMap[c + 0x800] = FillRAM + 0x3000;\n\t\tSA1.WriteMap[c + 1] = SA1.WriteMap[c + 0x801] = (uint8 *) MAP_NONE;\n\t}\n\n\t// SA-1 Banks 60->6f\n\tfor (int c = 0x600; c < 0x700; c++)\n\t\tSA1.Map[c] = SA1.WriteMap[c] = (uint8 *) MAP_BWRAM_BITMAP;\n\n\t// WRAM is inaccessable\n\tfor (int c = 0x7e0; c < 0x800; c++)\n\t\tSA1.Map[c] = SA1.WriteMap[c] = (uint8 *) MAP_NONE;\n\n\tBWRAM = SRAM;\n}\n\nvoid CMemory::Map_HiROMMap (void)\n{\n\tprintf(\"Map_HiROMMap\\n\");\n\tmap_System();\n\n\tmap_hirom(0x00, 0x3f, 0x8000, 0xffff, CalculatedSize);\n\tmap_hirom(0x40, 0x7f, 0x0000, 0xffff, CalculatedSize);\n\tmap_hirom(0x80, 0xbf, 0x8000, 0xffff, CalculatedSize);\n\tmap_hirom(0xc0, 0xff, 0x0000, 0xffff, CalculatedSize);\n\n\tif (Settings.DSP)\n\t\tmap_DSP();\n\n\tmap_HiROMSRAM();\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_ExtendedHiROMMap (void)\n{\n\tprintf(\"Map_ExtendedHiROMMap\\n\");\n\tmap_System();\n\n\tmap_hirom_offset(0x00, 0x3f, 0x8000, 0xffff, CalculatedSize - 0x400000, 0x400000);\n\tmap_hirom_offset(0x40, 0x7f, 0x0000, 0xffff, CalculatedSize - 0x400000, 0x400000);\n\tmap_hirom_offset(0x80, 0xbf, 0x8000, 0xffff, 0x400000, 0);\n\tmap_hirom_offset(0xc0, 0xff, 0x0000, 0xffff, 0x400000, 0);\n\n\tmap_HiROMSRAM();\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_SPC7110HiROMMap (void)\n{\n\tprintf(\"Map_SPC7110HiROMMap\\n\");\n\tmap_System();\n\n\tmap_index(0x00, 0x00, 0x6000, 0x7fff, MAP_HIROM_SRAM, MAP_TYPE_RAM);\n\tmap_hirom(0x00, 0x0f, 0x8000, 0xffff, CalculatedSize);\n\tmap_index(0x30, 0x30, 0x6000, 0x7fff, MAP_HIROM_SRAM, MAP_TYPE_RAM);\n\tif(Memory.ROMSize >= 13)\n\t\tmap_hirom_offset(0x40, 0x4f, 0x0000, 0xffff, CalculatedSize, 0x600000);\n\tmap_index(0x50, 0x50, 0x0000, 0xffff, MAP_SPC7110_DRAM, MAP_TYPE_ROM);\n\tmap_hirom(0x80, 0x8f, 0x8000, 0xffff, CalculatedSize);\n\tmap_hirom_offset(0xc0, 0xcf, 0x0000, 0xffff, CalculatedSize, 0);\n\tmap_index(0xd0, 0xff, 0x0000, 0xffff, MAP_SPC7110_ROM,  MAP_TYPE_ROM);\n\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_BSCartLoROMMap(uint8 mapping)\n{\n\tprintf(\"Map_BSCartLoROMMap\\n\");\n\n\tBSX.MMC[0x02] = 0x00;\n\tBSX.MMC[0x0C] = 0x80;\n\n\tmap_System();\n\n\tif (mapping)\n\t{\n\t\tmap_lorom_offset(0x00, 0x1f, 0x8000, 0xffff, 0x100000, 0);\n\t\tmap_lorom_offset(0x20, 0x3f, 0x8000, 0xffff, 0x100000, 0x100000);\n\t\tmap_lorom_offset(0x80, 0x9f, 0x8000, 0xffff, 0x100000, 0x200000);\n\t\tmap_lorom_offset(0xa0, 0xbf, 0x8000, 0xffff, 0x100000, 0x100000);\n\t}\n\telse\n\t{\n\t\tmap_lorom(0x00, 0x3f, 0x8000, 0xffff, CalculatedSize);\n\t\tmap_lorom(0x40, 0x7f, 0x0000, 0x7fff, CalculatedSize);\n\t\tmap_lorom(0x80, 0xbf, 0x8000, 0xffff, CalculatedSize);\n\t\tmap_lorom(0xc0, 0xff, 0x0000, 0x7fff, CalculatedSize);\n\t}\n\n\tmap_LoROMSRAM();\n\tmap_index(0xc0, 0xef, 0x0000, 0xffff, MAP_BSX, MAP_TYPE_RAM);\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\nvoid CMemory::Map_BSCartHiROMMap(void)\n{\n\tprintf(\"Map_BSCartHiROMMap\\n\");\n\n\tBSX.MMC[0x02] = 0x80;\n\tBSX.MMC[0x0C] = 0x80;\n\n\tmap_System();\n\tmap_hirom_offset(0x00, 0x1f, 0x8000, 0xffff, Multi.cartSizeA, Multi.cartOffsetA);\n\tmap_hirom_offset(0x20, 0x3f, 0x8000, 0xffff, Multi.cartSizeB, Multi.cartOffsetB);\n\tmap_hirom_offset(0x40, 0x5f, 0x0000, 0xffff, Multi.cartSizeA, Multi.cartOffsetA);\n\tmap_hirom_offset(0x60, 0x7f, 0x0000, 0xffff, Multi.cartSizeB, Multi.cartOffsetB);\n\tmap_hirom_offset(0x80, 0x9f, 0x8000, 0xffff, Multi.cartSizeA, Multi.cartOffsetA);\n\tmap_hirom_offset(0xa0, 0xbf, 0x8000, 0xffff, Multi.cartSizeB, Multi.cartOffsetB);\n\tmap_hirom_offset(0xc0, 0xdf, 0x0000, 0xffff, Multi.cartSizeA, Multi.cartOffsetA);\n\n\tif ((ROM[Multi.cartOffsetB + 0xFF00] == 0x4D)\n\t\t&& (ROM[Multi.cartOffsetB + 0xFF02] == 0x50)\n\t\t&& ((ROM[Multi.cartOffsetB + 0xFF06] & 0xF0) == 0x70))\n\t{\n\t\t//Type 7 Memory Pack detection - if detected, emulate it as Mask ROM\n\t\tmap_hirom_offset(0xe0, 0xff, 0x0000, 0xffff, Multi.cartSizeB, Multi.cartOffsetB);\n\t}\n\telse\n\t{\n\t\tmap_index(0xe0, 0xff, 0x0000, 0xffff, MAP_BSX, MAP_TYPE_RAM);\n\t}\n\n\tmap_HiROMSRAM();\n\tmap_WRAM();\n\n\tmap_WriteProtectROM();\n}\n\n// checksum\n\nuint16 CMemory::checksum_calc_sum (uint8 *data, uint32 length)\n{\n\tuint16\tsum = 0;\n\n\tfor (uint32 i = 0; i < length; i++)\n\t\tsum += data[i];\n\n\treturn (sum);\n}\n\nuint16 CMemory::checksum_mirror_sum (uint8 *start, uint32 &length, uint32 mask)\n{\n\t// from NSRT\n\twhile (!(length & mask) && mask)\n\t\tmask >>= 1;\n\n\tuint16\tpart1 = checksum_calc_sum(start, mask);\n\tuint16\tpart2 = 0;\n\n\tuint32\tnext_length = length - mask;\n\tif (next_length)\n\t{\n\t\tpart2 = checksum_mirror_sum(start + mask, next_length, mask >> 1);\n\n\t\twhile (next_length < mask)\n\t\t{\n\t\t\tnext_length += next_length;\n\t\t\tpart2 += part2;\n\t\t}\n\n\t\tlength = mask + mask;\n\t}\n\n\treturn (part1 + part2);\n}\n\nvoid CMemory::Checksum_Calculate (void)\n{\n\t// from NSRT\n\tuint16\tsum = 0;\n\n\tif (Settings.BS && !Settings.BSXItself)\n\t\tsum = checksum_calc_sum(ROM, CalculatedSize) - checksum_calc_sum(ROM + (HiROM ? 0xffb0 : 0x7fb0), 48);\n\telse if (Settings.SPC7110)\n\t{\n\t\tsum = checksum_calc_sum(ROM, CalculatedSize);\n\t\tif (CalculatedSize == 0x300000)\n\t\t\tsum += sum;\n\t}\n\telse\n\t{\n\t\tif (CalculatedSize & 0x7fff)\n\t\t\tsum = checksum_calc_sum(ROM, CalculatedSize);\n\t\telse\n\t\t{\n\t\t\tuint32\tlength = CalculatedSize;\n\t\t\tsum = checksum_mirror_sum(ROM, length);\n\t\t}\n\t}\n\n\tCalculatedChecksum = sum;\n}\n\n// information\n\nconst char * CMemory::MapType (void)\n{\n\treturn (HiROM ? ((ExtendedFormat != NOPE) ? \"ExHiROM\": \"HiROM\") : \"LoROM\");\n}\n\nconst char * CMemory::StaticRAMSize (void)\n{\n\tstatic char\tstr[20];\n\n\tif (SRAMSize > 16)\n\t\tstrcpy(str, \"Corrupt\");\n\telse\n\t\tsprintf(str, \"%d Kbit\", 8 * (SRAMMask + 1) / 1024);\n\n\treturn (str);\n}\n\nconst char * CMemory::Size (void)\n{\n\tstatic char\tstr[20];\n\n\tif (Multi.cartType == 4)\n\t\tstrcpy(str, \"N/A\");\n\telse if (ROMSize < 7 || ROMSize - 7 > 23)\n\t\tstrcpy(str, \"Corrupt\");\n\telse\n\t\tsprintf(str, \"%d Mbit\", 1 << (ROMSize - 7));\n\n\treturn (str);\n}\n\nconst char * CMemory::Revision (void)\n{\n\tstatic char\tstr[20];\n\n\tsprintf(str, \"1.%d\", HiROM ? ((ExtendedFormat != NOPE) ? ROM[0x40ffdb] : ROM[0xffdb]) : ROM[0x7fdb]);\n\n\treturn (str);\n}\n\nconst char * CMemory::KartContents (void)\n{\n\tstatic char\t\t\tstr[64];\n\tstatic const char\t*contents[3] = { \"ROM\", \"ROM+RAM\", \"ROM+RAM+BAT\" };\n\n\tchar\tchip[20];\n\n\tif (ROMType == 0 && !Settings.BS)\n\t\treturn (\"ROM\");\n\n\tif (Settings.BS)\n\t\tstrcpy(chip, \"+BS\");\n\telse if (Settings.SuperFX)\n\t\tstrcpy(chip, \"+Super FX\");\n\telse if (Settings.SDD1)\n\t\tstrcpy(chip, \"+S-DD1\");\n\telse if (Settings.OBC1)\n\t\tstrcpy(chip, \"+OBC1\");\n\telse if (Settings.SA1)\n\t\tstrcpy(chip, \"+SA-1\");\n\telse if (Settings.SPC7110RTC)\n\t\tstrcpy(chip, \"+SPC7110+RTC\");\n\telse if (Settings.SPC7110)\n\t\tstrcpy(chip, \"+SPC7110\");\n\telse if (Settings.SRTC)\n\t\tstrcpy(chip, \"+S-RTC\");\n\telse if (Settings.C4)\n\t\tstrcpy(chip, \"+C4\");\n\telse if (Settings.SETA == ST_010)\n\t\tstrcpy(chip, \"+ST-010\");\n\telse if (Settings.SETA == ST_011)\n\t\tstrcpy(chip, \"+ST-011\");\n\telse if (Settings.SETA == ST_018)\n\t\tstrcpy(chip, \"+ST-018\");\n\telse if (Settings.DSP)\n\t\tsprintf(chip, \"+DSP-%d\", Settings.DSP);\n\telse\n\t\tstrcpy(chip, \"\");\n\n\tif (Settings.MSU1)\n\t\tsprintf(chip + strlen(chip), \"+MSU-1\");\n\n\tsprintf(str, \"%s%s\", contents[(ROMType & 0xf) % 3], chip);\n\n\treturn (str);\n}\n\nconst char * CMemory::Country (void)\n{\n\tswitch (ROMRegion)\n\t{\n\t\tcase 0:\t\treturn(\"Japan\");\n\t\tcase 1:\t\treturn(\"USA and Canada\");\n\t\tcase 2:\t\treturn(\"Oceania, Europe and Asia\");\n\t\tcase 3:\t\treturn(\"Sweden\");\n\t\tcase 4:\t\treturn(\"Finland\");\n\t\tcase 5:\t\treturn(\"Denmark\");\n\t\tcase 6:\t\treturn(\"France\");\n\t\tcase 7:\t\treturn(\"Holland\");\n\t\tcase 8:\t\treturn(\"Spain\");\n\t\tcase 9:\t\treturn(\"Germany, Austria and Switzerland\");\n\t\tcase 10:\treturn(\"Italy\");\n\t\tcase 11:\treturn(\"Hong Kong and China\");\n\t\tcase 12:\treturn(\"Indonesia\");\n\t\tcase 13:\treturn(\"South Korea\");\n\t\tdefault:\treturn(\"Unknown\");\n\t}\n}\n\nconst char * CMemory::PublishingCompany (void)\n{\n\tif (CompanyId >= (int) (sizeof(nintendo_licensees) / sizeof(nintendo_licensees[0])) || CompanyId < 0)\n\t\treturn (\"Unknown\");\n\n\tif (nintendo_licensees[CompanyId] == NULL)\n\t\treturn (\"Unknown\");\n\n\treturn (nintendo_licensees[CompanyId]);\n}\n\nstd::string CMemory::GetMultilineROMInfo()\n{\n    bool8 isChecksumOK = (Memory.ROMChecksum + Memory.ROMComplementChecksum == 0xffff) &&\n                         (Memory.ROMChecksum == Memory.CalculatedChecksum);\n    std::string utf8_romname = Memory.ROMName;\n    std::string tvstandard = Settings.PAL ? \"PAL\" : \"NTSC\";\n\tstd::string romid = Memory.ROMId;\n    std::string checksum = isChecksumOK              ? \"Checksum OK\"\n                           : Settings.IsPatched == 3 ? \"UPS patched\"\n                           : Settings.IsPatched == 2 ? \"BPS patched\"\n                           : Settings.IsPatched == 1 ? \"IPS patched\"\n                                                     : \"Invalid Checksum\";\n\n    std::stringstream ss;\n    ss << \"\\\"\" << utf8_romname << \"\\\" (\" + tvstandard + \") version \" << Memory.Revision() << \"\\n\";\n    ss << Memory.KartContents() << \": \" << Memory.MapType() << \": \" << Memory.Size() << \", SRAM: \" << Memory.StaticRAMSize() << \"\\n\";\n    ss << \"ID: \" << romid << \", CRC32: \" << std::setfill('0') << std::setw(8) << std::setbase(16) << Memory.ROMCRC32 << \", \" << checksum;\n\n\treturn ss.str();\n}\n\nvoid CMemory::MakeRomInfoText (char *romtext)\n{\n\tchar\ttemp[256];\n\n\tromtext[0] = 0;\n\n\tsprintf(temp,   \"            Cart Name: %s\", ROMName);\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n            Game Code: %s\", ROMId);\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n             Contents: %s\", KartContents());\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n                  Map: %s\", MapType());\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n                Speed: 0x%02X (%s)\", ROMSpeed, (ROMSpeed & 0x10) ? \"FastROM\" : \"SlowROM\");\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n                 Type: 0x%02X\", ROMType);\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n    Size (calculated): %dMbits\", CalculatedSize / 0x20000);\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n        Size (header): %s\", Size());\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n            SRAM size: %s\", StaticRAMSize());\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\nChecksum (calculated): 0x%04X\", CalculatedChecksum);\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n    Checksum (header): 0x%04X\", ROMChecksum);\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n  Complement (header): 0x%04X\", ROMComplementChecksum);\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n         Video Output: %s\", (ROMRegion > 12 || ROMRegion < 2) ? \"NTSC 60Hz\" : \"PAL 50Hz\");\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n             Revision: %s\", Revision());\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n             Licensee: %s\", PublishingCompany());\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n               Region: %s\", Country());\n\tstrcat(romtext, temp);\n\tsprintf(temp, \"\\n                CRC32: 0x%08X\", ROMCRC32);\n\tstrcat(romtext, temp);\n}\n\n// hack\n\nbool8 CMemory::match_na (const char *str)\n{\n\treturn (strcmp(ROMName, str) == 0);\n}\n\nbool8 CMemory::match_nn (const char *str)\n{\n\treturn (strncmp(ROMName, str, strlen(str)) == 0);\n}\n\nbool8 CMemory::match_nc (const char *str)\n{\n\treturn (strncasecmp(ROMName, str, strlen(str)) == 0);\n}\n\nbool8 CMemory::match_id (const char *str)\n{\n\treturn (strncmp(ROMId, str, strlen(str)) == 0);\n}\n\nvoid CMemory::ApplyROMFixes (void)\n{\n\tSettings.BlockInvalidVRAMAccess = Settings.BlockInvalidVRAMAccessMaster;\n\n\tif (Settings.DisableGameSpecificHacks)\n\t\treturn;\n\n\t// APU timing hacks\n\tif (match_na(\"CIRCUIT USA\"))\n\t\tTimings.APUSpeedup = 3;\n\n\tS9xAPUTimingSetSpeedup(Timings.APUSpeedup);\n\n\t// Other timing hacks\n\t// The delay to sync CPU and DMA which Snes9x does not emulate.\n\t// Some games need really severe delay timing...\n\tif (match_na(\"BATTLE GRANDPRIX\")) // Battle Grandprix\n\t\tTimings.DMACPUSync = 20;\n\telse if (match_na(\"KORYU NO MIMI ENG\")) // Koryu no Mimi translation by rpgone)\n\t{\n\t\t// An infinite loop reads $4210 and checks NMI flag. This only works if LDA instruction executes before the NMI triggers,\n\t\t// which doesn't work very well with s9x's default DMA timing.\n\t\tTimings.DMACPUSync = 20;\n\t}\n\n\tif (Timings.DMACPUSync != 18)\n\t\tprintf(\"DMA sync: %d\\n\", Timings.DMACPUSync);\n\n\t// SRAM initial value\n\tif (match_na(\"HITOMI3\"))\n\t{\n\t\tSRAMSize = 1;\n\t\tSRAMMask = ((1 << (SRAMSize + 3)) * 128) - 1;\n\t}\n\n\t// SRAM value fixes\n\tif (match_na(\"SUPER DRIFT OUT\")      || // Super Drift Out\n\t\tmatch_na(\"SATAN IS OUR FATHER!\") ||\n\t\tmatch_na(\"S.F.S.95 della SerieA\") ||\n\t\tmatch_id(\"AACJ\") || // Nichibutsu Arcade Classics\n\t\tmatch_na(\"goemon 4\"))               // Ganbare Goemon Kirakira Douchuu\n\t\tSNESGameFixes.SRAMInitialValue = 0x00;\n\n\t// Additional game fixes by sanmaiwashi ...\n\t// XXX: unnecessary?\n\tif (match_na(\"SFX \\xC5\\xB2\\xC4\\xB6\\xDE\\xDD\\xC0\\xDE\\xD1\\xD3\\xC9\\xB6\\xDE\\xC0\\xD8 1\")) // SD Gundam Gaiden - Knight Gundam Monogatari\n\t\tSNESGameFixes.SRAMInitialValue = 0x6b;\n\n\t// others: BS and ST-01x games are 0x00.\n\n\t// OAM hacks :(\n\t// OAM hacks because we don't fully understand the behavior of the SNES.\n\t// Totally wacky display in 2P mode...\n\t// seems to need a disproven behavior, so we're definitely overlooking some other bug?\n\tif (match_nn(\"UNIRACERS\")) // Uniracers\n\t{\n\t\tSNESGameFixes.Uniracers = TRUE;\n\t\tprintf(\"Applied Uniracers hack.\\n\");\n\t}\n\n\t// Render Position\n\tif (match_na(\"Sugoro Quest++\"))\n\t\tTimings.RenderPos = 128;\n\telse if (match_na(\"FIREPOWER 2000\") || match_na(\"SUPER SWIV\"))\n\t\tTimings.RenderPos = 32;\n\telse if (match_na(\"DERBY STALLION 98\"))\n\t\tTimings.RenderPos = 128;\n\telse if (match_na(\"AIR STRIKE PATROL\") || match_na(\"DESERT FIGHTER\"))\n\t\tTimings.RenderPos = 128; // Just hides shadow\n\telse if (match_na(\"FULL THROTTLE RACING\"))\n\t\tTimings.RenderPos = 128;\n\t// From bsnes\n\telse if (match_na(\"NHL '94\") || match_na(\"NHL PROHOCKEY'94\"))\n\t\tTimings.RenderPos = 32;\n\telse if (match_na(\"ADVENTURES OF FRANKEN\") && Settings.PAL)\n\t\tTimings.RenderPos = 32;\n}\n\nstd::string CMemory::SafeString(std::string s, bool allow_jis /*=false*/)\n{\n    std::string safe;\n    for (size_t i = 0; i < s.length(); i++)\n    {\n        if (s[i] >= 32 && s[i] < 127) // ASCII\n            safe += s[i];\n        else\n            if (allow_jis && ROMRegion == 0 && ((uint8)s[i] >= 0xa0 && (uint8)s[i] < 0xe0)) // JIS X 201 - Katakana\n                safe += s[i];\n            else\n                safe += '_';\n    }\n\n    return safe;\n}\n\n// BPS % UPS % IPS\n\n// number decoding used for both BPS and UPS\nstatic uint32 XPSdecode (const uint8 *data, unsigned &addr, unsigned size)\n{\n\tuint32 offset = 0, shift = 1;\n\twhile(addr < size) {\n\t\tuint8 x = data[addr++];\n\t\toffset += (x & 0x7f) * shift;\n\t\tif(x & 0x80) break;\n\t\tshift <<= 7;\n\t\toffset += shift;\n\t}\n\treturn offset;\n}\n\nstatic std::vector<uint8_t> ReadStreamUntilEOF(Stream *r)\n{\n    const size_t max_buffer_size = 4096;\n    std::vector<uint8_t> data;\n    uint8_t buffer[max_buffer_size];\n    size_t total_size = 0;\n    size_t buffer_size = 0;\n\n    int value = 0;\n    while (value != EOF)\n    {\n        value = r->get_char();\n        if (value != EOF)\n            buffer[buffer_size++] = value;\n\n        if (buffer_size == max_buffer_size || (value == EOF && buffer_size > 0))\n        {\n            data.resize(data.size() + buffer_size);\n            memcpy(&data[total_size], buffer, buffer_size);\n            total_size += buffer_size;\n            buffer_size = 0;\n        }\n    }\n\n    return data;\n}\n\n//NOTE: UPS patches are *never* created against a headered ROM!\n//this is per the UPS file specification. however, do note that it is\n//technically possible for a non-compliant patcher to ignore this requirement.\n//therefore, it is *imperative* that no emulator support such patches.\n//thusly, we ignore the \"long offset\" parameter below. failure to do so would\n//completely invalidate the purpose of UPS; which is to avoid header vs\n//no-header patching errors that result in IPS patches having a 50/50 chance of\n//being applied correctly.\n\nstatic bool8 ReadUPSPatch (Stream *r, long, int32 &rom_size)\n{\n\t//Reader lacks size() and rewind(), so we need to read in the file to get its size\n\tauto data_vector = ReadStreamUntilEOF(r);\n\tuint8 *data = &data_vector[0];\n\tuint32 size = data_vector.size();\n\n\t//4-byte header + 1-byte input size + 1-byte output size + 4-byte patch CRC32 + 4-byte unpatched CRC32 + 4-byte patched CRC32\n\tif(size < 18) return false;  //patch is too small\n\n\tuint32 addr = 4;\n\tif (memcmp(data, \"UPS1\", 4) != 0) return false; //patch has an invalid header\n\n\tuint32 patch_crc32 = caCRC32(data, size - 4);  //don't include patch CRC32 itself in CRC32 calculation\n\tuint32 rom_crc32 = caCRC32(Memory.ROM, rom_size);\n\tuint32 px_crc32 = (data[size - 12] << 0) + (data[size - 11] << 8) + (data[size - 10] << 16) + (data[size -  9] << 24);\n\tuint32 py_crc32 = (data[size -  8] << 0) + (data[size -  7] << 8) + (data[size -  6] << 16) + (data[size -  5] << 24);\n\tuint32 pp_crc32 = (data[size -  4] << 0) + (data[size -  3] << 8) + (data[size -  2] << 16) + (data[size -  1] << 24);\n\tif(patch_crc32 != pp_crc32) { return false; }  //patch is corrupted\n\tif(!Settings.IgnorePatchChecksum && (rom_crc32 != px_crc32) && (rom_crc32 != py_crc32)) return false; //patch is for a different ROM\n\n\tuint32 px_size = XPSdecode(data, addr, size);\n\tuint32 py_size = XPSdecode(data, addr, size);\n\tuint32 out_size = ((uint32) rom_size == px_size) ? py_size : px_size;\n\tif(out_size > CMemory::MAX_ROM_SIZE) { return false; }  //applying this patch will overflow Memory.ROM buffer\n\n\t//fill expanded area with 0x00s; so that XORing works as expected below.\n\t//note that this is needed (and works) whether output ROM is larger or smaller than pre-patched ROM\n\tfor(unsigned i = min((uint32) rom_size, out_size); i < max((uint32) rom_size, out_size); i++) {\n\t\tMemory.ROM[i] = 0x00;\n\t}\n\n\tuint32 relative = 0;\n\twhile(addr < size - 12) {\n\t\trelative += XPSdecode(data, addr, size);\n\t\twhile(addr < size - 12) {\n\t\t\tuint8 x = data[addr++];\n\t\t\tMemory.ROM[relative++] ^= x;\n\t\t\tif(!x) break;\n\t\t}\n\t}\n\n\trom_size = out_size;\n\n\tuint32 out_crc32 = caCRC32(Memory.ROM, rom_size);\n\tif(Settings.IgnorePatchChecksum\n\t|| ((rom_crc32 == px_crc32) && (out_crc32 == py_crc32))\n\t|| ((rom_crc32 == py_crc32) && (out_crc32 == px_crc32))\n\t) {\n\t\tSettings.IsPatched = 3;\n\t\treturn true;\n\t} else {\n\t\t//technically, reaching here means that patching has failed.\n\t\t//we should return false, but unfortunately Memory.ROM has already\n\t\t//been modified above and cannot be undone. to do this properly, we\n\t\t//would need to make a copy of Memory.ROM, apply the patch, and then\n\t\t//copy that back to Memory.ROM.\n\t\t//\n\t\t//however, the only way for this case to happen is if the UPS patch file\n\t\t//itself is corrupted, which should be detected by the patch CRC32 check\n\t\t//above anyway. errors due to the wrong ROM or patch file being used are\n\t\t//already caught above.\n\t\tfprintf(stderr, \"WARNING: UPS patching appears to have failed.\\nGame may not be playable.\\n\");\n\t\treturn true;\n\t}\n}\n\n// header notes for UPS patches also apply to BPS\n//\n// logic taken from http://byuu.org/programming/bps and the accompanying source\n//\nstatic bool8 ReadBPSPatch (Stream *r, long, int32 &rom_size)\n{\n\tauto data_vector = ReadStreamUntilEOF(r);\n\tuint8 *data = &data_vector[0];\n\tuint32 size = data_vector.size();\n\n\t/* 4-byte header + 1-byte input size + 1-byte output size + 1-byte metadata size\n\t   + 4-byte unpatched CRC32 + 4-byte patched CRC32 + 4-byte patch CRC32 */\n\tif(size < 19) return false; //patch is too small\n\n\tuint32 addr = 4;\n\tif (memcmp(data, \"BPS1\", 4) != 0) return false; //patch has an invalid header\n\n\tuint32 patch_crc32 = caCRC32(data, size - 4);  //don't include patch CRC32 itself in CRC32 calculation\n\tuint32 rom_crc32 = caCRC32(Memory.ROM, rom_size);\n\tuint32 source_crc32 = (data[size - 12] << 0) + (data[size - 11] << 8) + (data[size - 10] << 16) + (data[size -  9] << 24);\n\tuint32 target_crc32 = (data[size -  8] << 0) + (data[size -  7] << 8) + (data[size -  6] << 16) + (data[size -  5] << 24);\n\tuint32 pp_crc32 = (data[size -  4] << 0) + (data[size -  3] << 8) + (data[size -  2] << 16) + (data[size -  1] << 24);\n\tif(patch_crc32 != pp_crc32) return false;  //patch is corrupted\n\tif(!Settings.IgnorePatchChecksum && rom_crc32 != source_crc32) return false;  //patch is for a different ROM\n\n\tXPSdecode(data, addr, size);\n\tuint32 target_size = XPSdecode(data, addr, size);\n\tuint32 metadata_size = XPSdecode(data, addr, size);\n\taddr += metadata_size;\n\n\tif(target_size > CMemory::MAX_ROM_SIZE) return false;  //applying this patch will overflow Memory.ROM buffer\n\n\tenum { SourceRead, TargetRead, SourceCopy, TargetCopy };\n\tuint32 outputOffset = 0, sourceRelativeOffset = 0, targetRelativeOffset = 0;\n\n\tstd::vector<uint8_t> patched_rom_vector(target_size);\n\tuint8 *patched_rom = &patched_rom_vector[0];\n\tmemset(patched_rom, 0, target_size);\n\n\twhile(addr < size - 12) {\n\t\tuint32 length = XPSdecode(data, addr, size);\n\t\tuint32 mode = length & 3;\n\t\tlength = (length >> 2) + 1;\n\n\t\tswitch((int)mode) {\n\t\t\tcase SourceRead:\n\t\t\t\twhile(length--) {\n\t\t\t\t\tpatched_rom[outputOffset] = Memory.ROM[outputOffset];\n\t\t\t\t\toutputOffset++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TargetRead:\n\t\t\t\twhile(length--) patched_rom[outputOffset++] = data[addr++];\n\t\t\t\tbreak;\n\t\t\tcase SourceCopy:\n\t\t\tcase TargetCopy:\n\t\t\t\tint32 offset = XPSdecode(data, addr, size);\n\t\t\t\tbool negative = offset & 1;\n\t\t\t\toffset >>= 1;\n\t\t\t\tif(negative) offset = -offset;\n\n\t\t\t\tif(mode == SourceCopy) {\n\t\t\t\t\tsourceRelativeOffset += offset;\n\t\t\t\t\twhile(length--) patched_rom[outputOffset++] = Memory.ROM[sourceRelativeOffset++];\n\t\t\t\t} else {\n\t\t\t\t\ttargetRelativeOffset += offset;\n\t\t\t\t\twhile(length--) patched_rom[outputOffset++] = patched_rom[targetRelativeOffset++];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tuint32 out_crc32 = caCRC32(patched_rom, target_size);\n\tif(Settings.IgnorePatchChecksum || out_crc32 == target_crc32) {\n\t\tmemcpy(Memory.ROM, patched_rom, target_size);\n\t\trom_size = target_size;\n\t\tSettings.IsPatched = 2;\n\t\treturn true;\n\t} else {\n\t\tfprintf(stderr, \"WARNING: BPS patching failed.\\nROM has not been altered.\\n\");\n\t\treturn false;\n\t}\n}\n\nstatic long ReadInt (Stream *r, unsigned nbytes)\n{\n\tlong\tv = 0;\n\n\twhile (nbytes--)\n\t{\n\t\tint\tc = r->get_char();\n\t\tif (c == EOF)\n\t\t\treturn (-1);\n\t\tv = (v << 8) | (c & 0xFF);\n\t}\n\n\treturn (v);\n}\n\nstatic bool8 ReadIPSPatch (Stream *r, long offset, int32 &rom_size)\n{\n\tconst int32\tIPS_EOF = 0x00454F46l;\n\tint32\t\tofs;\n\tchar\t\tfname[6];\n\n\tfname[5] = 0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tint\tc = r->get_char();\n\t\tif (c == EOF)\n\t\t\treturn (0);\n\t\tfname[i] = (char) c;\n\t}\n\n\tif (strncmp(fname, \"PATCH\", 5))\n\t\treturn (0);\n\n\tfor (;;)\n\t{\n\t\tlong\tlen, rlen;\n\t\tint\t\trchar;\n\n\t\tofs = ReadInt(r, 3);\n\t\tif (ofs == -1)\n\t\t\treturn (0);\n\n\t\tif (ofs == IPS_EOF)\n\t\t\tbreak;\n\n\t\tofs -= offset;\n\n\t\tlen = ReadInt(r, 2);\n\t\tif (len == -1)\n\t\t\treturn (0);\n\n\t\tif (len)\n\t\t{\n\t\t\tif (ofs + len > CMemory::MAX_ROM_SIZE)\n\t\t\t\treturn (0);\n\n\t\t\twhile (len--)\n\t\t\t{\n\t\t\t\trchar = r->get_char();\n\t\t\t\tif (rchar == EOF)\n\t\t\t\t\treturn (0);\n\t\t\t\tMemory.ROM[ofs++] = (uint8) rchar;\n\t\t\t}\n\n\t\t\tif (ofs > rom_size)\n\t\t\t\trom_size = ofs;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trlen = ReadInt(r, 2);\n\t\t\tif (rlen == -1)\n\t\t\t\treturn (0);\n\n\t\t\trchar = r->get_char();\n\t\t\tif (rchar == EOF)\n\t\t\t\treturn (0);\n\n\t\t\tif (ofs + rlen > CMemory::MAX_ROM_SIZE)\n\t\t\t\treturn (0);\n\n\t\t\twhile (rlen--)\n\t\t\t\tMemory.ROM[ofs++] = (uint8) rchar;\n\n\t\t\tif (ofs > rom_size)\n\t\t\t\trom_size = ofs;\n\t\t}\n\t}\n\n\tofs = ReadInt(r, 3);\n\tif (ofs != -1 && ofs - offset < rom_size)\n\t\trom_size = ofs - offset;\n\n\tSettings.IsPatched = 1;\n\treturn (1);\n}\n\n#ifdef UNZIP_SUPPORT\nstatic int unzFindExtension (unzFile &file, const char *ext, bool restart, bool print, bool allowExact)\n{\n\tunz_file_info\tinfo;\n\tint\t\t\t\tport, l = strlen(ext), e = allowExact ? 0 : 1;\n\n\tif (restart)\n\t\tport = unzGoToFirstFile(file);\n\telse\n\t\tport = unzGoToNextFile(file);\n\n\twhile (port == UNZ_OK)\n\t{\n\t\tint\t\tlen;\n\t\tchar\tname[132];\n\n\t\tunzGetCurrentFileInfo(file, &info, name, 128, NULL, 0, NULL, 0);\n\t\tlen = strlen(name);\n\n\t\tif (len >= l + e && name[len - l - 1] == '.' && strcasecmp(name + len - l, ext) == 0 && unzOpenCurrentFile(file) == UNZ_OK)\n\t\t{\n\t\t\tif (print)\n\t\t\t\tprintf(\"Using patch %s\", name);\n\n\t\t\treturn (port);\n\t\t}\n\n\t\tport = unzGoToNextFile(file);\n\t}\n\n\treturn (port);\n}\n#endif\n\nvoid CMemory::CheckForAnyPatch(const char *rom_filename, bool8 header, int32 &rom_size)\n{\n    Settings.IsPatched = false;\n\n    if (Settings.NoPatch)\n        return;\n\n    FSTREAM patch_file = NULL;\n    long offset = header ? 512 : 0;\n    int ret;\n    bool flag = false;\n\n    auto path = splitpath(rom_filename);\n\n    auto try_patch = [&](const char *type, std::string filename, bool8(*read_patch_func)(Stream * r, long offset, int32 &rom_size)) -> bool {\n        if ((patch_file = OPEN_FSTREAM(filename.c_str(), \"rb\")) != NULL)\n        {\n            printf(\"Using %s patch %s\", type, filename.c_str());\n\n            Stream *s = new fStream(patch_file);\n            ret = read_patch_func(s, offset, rom_size);\n            s->closeStream();\n\n            if (ret)\n            {\n                printf(\"!\\n\");\n                flag = true;\n                return true;\n            }\n            else\n                printf(\" failed!\\n\");\n        }\n        return false;\n    };\n\n    auto try_ips_sequence = [&](const char *pattern, enum s9x_getdirtype dirtype) -> bool {\n        for (int i = 0; i < 1000; i++)\n        {\n            char ips[9];\n            snprintf(ips, 9, pattern, i);\n            if (!try_patch(\"IPS\", S9xGetFilename(ips, dirtype), ReadIPSPatch))\n                break;\n        }\n        return flag;\n    };\n\n    auto try_patch_type_sequence = [&](enum s9x_getdirtype dirtype) -> bool {\n        if (try_patch(\"BPS\", S9xGetFilename(\".bps\", dirtype), ReadBPSPatch))\n            return true;\n        if (try_patch(\"UPS\", S9xGetFilename(\".ups\", dirtype), ReadUPSPatch))\n            return true;\n        if (try_patch(\"IPS\", S9xGetFilename(\".ips\", dirtype), ReadIPSPatch))\n            return true;\n        if (try_ips_sequence(\".%03d.ips\", dirtype))\n            return true;\n        if (try_ips_sequence(\".ips%d\", dirtype))\n            return true;\n        if (try_ips_sequence(\".ip%d\", dirtype))\n            return true;\n\n        return false;\n    };\n\n    if (try_patch_type_sequence(ROMFILENAME_DIR))\n        return;\n\n#ifdef UNZIP_SUPPORT\n    if (path.ext_is(\".zip\"))\n    {\n        unzFile file = unzOpen(rom_filename);\n        if (file)\n        {\n            auto try_zip_patch = [&](const char *ext, bool8 (*read_patch_func)(Stream * r, long offset, int32 &rom_size)) -> bool {\n                if (unzFindExtension(file, ext) == UNZ_OK)\n                {\n                    printf(\" in %s\", rom_filename);\n\n                    Stream *s = new unzStream(file);\n                    ret = read_patch_func(s, offset, rom_size);\n                    delete s;\n\n                    if (ret)\n                    {\n                        printf(\"!\\n\");\n                        flag = true;\n                        return true;\n                    }\n\n                    printf(\" failed!\\n\");\n                }\n                return false;\n            };\n\n            auto try_zip_ips_sequence = [&](const char *pattern) {\n                for (int i = 0; i < 1000; i++)\n                {\n                    char ips[8];\n                    snprintf(ips, 8, pattern, i);\n                    if (!try_zip_patch(ips, ReadIPSPatch))\n                        break;\n                }\n            };\n\n            if (!flag)\n                try_zip_patch(\"bps\", ReadBPSPatch);\n            if (!flag)\n                try_zip_patch(\"ups\", ReadUPSPatch);\n            if (!flag)\n                try_zip_patch(\"ips\", ReadIPSPatch);\n            if (!flag)\n                try_zip_ips_sequence(\"%03d.ips\");\n            if (!flag)\n                try_zip_ips_sequence(\"ips%d\");\n            if (!flag)\n                try_zip_ips_sequence(\"ip%d\");\n\n            int close_ret = unzClose(file);\n            assert(close_ret == UNZ_OK);\n\n            if (flag)\n                return;\n        }\n    }\n\n    // Mercurial Magic (MSU-1 distribution pack)\n    if (path.ext_is(\".msu1\")) // ROM was *NOT* loaded from a .msu1 pack\n    {\n        Stream *s = S9xMSU1OpenFile(\"patch.bps\", TRUE);\n        if (s)\n        {\n            printf(\"Using BPS patch from msu1\");\n            ret = ReadBPSPatch(s, offset, rom_size);\n            s->closeStream();\n\n            if (ret)\n                printf(\"!\\n\");\n            else\n                printf(\" failed!\\n\");\n        }\n    }\n#endif\n\n    if (try_patch_type_sequence(PATCH_DIR))\n        return;\n}\n"
        },
        {
          "name": "memmap.h",
          "type": "blob",
          "size": 5.5517578125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _MEMMAP_H_\n#define _MEMMAP_H_\n\n#define MEMMAP_BLOCK_SIZE\t(0x1000)\n#define MEMMAP_NUM_BLOCKS\t(0x1000000 / MEMMAP_BLOCK_SIZE)\n#define MEMMAP_SHIFT\t\t(12)\n#define MEMMAP_MASK\t\t\t(MEMMAP_BLOCK_SIZE - 1)\n\n#include <string>\n#include <vector>\n#include <cstdint>\n\nstruct CMemory\n{\n\tenum\n\t{ MAX_ROM_SIZE = 0xC00000 };\n\n\tenum file_formats\n\t{ FILE_ZIP, FILE_JMA, FILE_DEFAULT };\n\n\tenum\n\t{ NOPE, YEAH, BIGFIRST, SMALLFIRST };\n\n\tenum\n\t{ MAP_TYPE_I_O, MAP_TYPE_ROM, MAP_TYPE_RAM };\n\n\tenum\n\t{\n\t\tMAP_CPU,\n\t\tMAP_PPU,\n\t\tMAP_LOROM_SRAM,\n\t\tMAP_LOROM_SRAM_B,\n\t\tMAP_HIROM_SRAM,\n\t\tMAP_DSP,\n\t\tMAP_SA1RAM,\n\t\tMAP_BWRAM,\n\t\tMAP_BWRAM_BITMAP,\n\t\tMAP_BWRAM_BITMAP2,\n\t\tMAP_SPC7110_ROM,\n\t\tMAP_SPC7110_DRAM,\n\t\tMAP_RONLY_SRAM,\n\t\tMAP_C4,\n\t\tMAP_OBC_RAM,\n\t\tMAP_SETA_DSP,\n\t\tMAP_SETA_RISC,\n\t\tMAP_BSX,\n\t\tMAP_NONE,\n\t\tMAP_LAST\n\t};\n\n\tuint8\tNSRTHeader[32];\n\tint32\tHeaderCount;\n\n\tuint8\tRAM[0x20000];\n\tstd::vector<uint8_t> ROMStorage;\n\tuint8   *ROM;\n\tstd::vector<uint8_t> SRAMStorage;\n\tuint8\t*SRAM;\n\tconst size_t SRAM_SIZE = 0x80000;\n\tuint8\tVRAM[0x10000];\n\tuint8\t*FillRAM;\n\tuint8\t*BWRAM;\n\tuint8\t*C4RAM;\n\tuint8\t*OBC1RAM;\n\tuint8\t*BSRAM;\n\tuint8\t*BIOSROM;\n\n\tuint8\t*Map[MEMMAP_NUM_BLOCKS];\n\tuint8\t*WriteMap[MEMMAP_NUM_BLOCKS];\n\tuint8\tBlockIsRAM[MEMMAP_NUM_BLOCKS];\n\tuint8\tBlockIsROM[MEMMAP_NUM_BLOCKS];\n\tuint8\tExtendedFormat;\n\n\tstd::string ROMFilename;\n\tchar\tROMName[ROM_NAME_LEN];\n\tchar\tROMId[5];\n\tint32\tCompanyId;\n\tuint8\tROMRegion;\n\tuint8\tROMSpeed;\n\tuint8\tROMType;\n\tuint8\tROMSize;\n\tuint32\tROMChecksum;\n\tuint32\tROMComplementChecksum;\n\tuint32\tROMCRC32;\n\tunsigned char ROMSHA256[32];\n\tint32\tROMFramesPerSecond;\n\n\tbool8\tHiROM;\n\tbool8\tLoROM;\n\tuint8\tSRAMSize;\n\tuint32\tSRAMMask;\n\tuint32\tCalculatedSize;\n\tuint32\tCalculatedChecksum;\n\n\t// ports can assign this to perform some custom action upon loading a ROM (such as adjusting controls)\n\tvoid\t(*PostRomInitFunc) (void);\n\n\tbool8\tInit (void);\n\tvoid\tDeinit (void);\n\n\tint\t\tScoreHiROM (bool8, int32 romoff = 0);\n\tint\t\tScoreLoROM (bool8, int32 romoff = 0);\n\tint\t\tFirst512BytesCountZeroes() const;\n\tuint32\tHeaderRemove (uint32, uint8 *);\n\tuint32\tFileLoader (uint8 *, const char *, uint32);\n    bool8   LoadROMMem (const uint8 *, uint32, const char* optional_rom_filename = NULL);\n\tbool8\tLoadROM (const char *);\n    bool8\tLoadROMInt (int32);\n    bool8   LoadMultiCartMem (const uint8 *, uint32, const uint8 *, uint32, const uint8 *, uint32);\n\tbool8\tLoadMultiCart (const char *, const char *);\n    bool8\tLoadMultiCartInt ();\n\tbool8\tLoadSufamiTurbo ();\n\tbool8\tLoadBSCart ();\n\tbool8\tLoadGNEXT ();\n\tbool8\tLoadSRAM (const char *);\n\tbool8\tSaveSRAM (const char *);\n\tvoid\tClearSRAM (bool8 onlyNonSavedSRAM = 0);\n\tbool8\tLoadSRTC (void);\n\tbool8\tSaveSRTC (void);\n\tbool8\tSaveMPAK (const char *);\n\n\tvoid\tParseSNESHeader (uint8 *);\n\tvoid\tInitROM (void);\n\n\tuint32\tmap_mirror (uint32, uint32);\n\tvoid\tmap_lorom (uint32, uint32, uint32, uint32, uint32);\n\tvoid\tmap_hirom (uint32, uint32, uint32, uint32, uint32);\n\tvoid\tmap_lorom_offset (uint32, uint32, uint32, uint32, uint32, uint32);\n\tvoid\tmap_hirom_offset (uint32, uint32, uint32, uint32, uint32, uint32);\n\tvoid\tmap_space (uint32, uint32, uint32, uint32, uint8 *);\n\tvoid\tmap_index (uint32, uint32, uint32, uint32, int, int);\n\tvoid\tmap_System (void);\n\tvoid\tmap_WRAM (void);\n\tvoid\tmap_LoROMSRAM (void);\n\tvoid\tmap_HiROMSRAM (void);\n\tvoid\tmap_DSP (void);\n\tvoid\tmap_C4 (void);\n\tvoid\tmap_OBC1 (void);\n\tvoid\tmap_SetaRISC (void);\n\tvoid\tmap_SetaDSP (void);\n\tvoid\tmap_WriteProtectROM (void);\n\tvoid\tMap_Initialize (void);\n\tvoid\tMap_LoROMMap (void);\n\tvoid\tMap_NoMAD1LoROMMap (void);\n\tvoid\tMap_JumboLoROMMap (void);\n\tvoid\tMap_ROM24MBSLoROMMap (void);\n\tvoid\tMap_SRAM512KLoROMMap (void);\n\tvoid\tMap_SufamiTurboLoROMMap (void);\n\tvoid\tMap_SufamiTurboPseudoLoROMMap (void);\n\tvoid\tMap_SuperFXLoROMMap (void);\n\tvoid\tMap_SetaDSPLoROMMap (void);\n\tvoid\tMap_SDD1LoROMMap (void);\n\tvoid\tMap_SA1LoROMMap (void);\n\tvoid\tMap_BSSA1LoROMMap (void);\n\tvoid\tMap_HiROMMap (void);\n\tvoid\tMap_ExtendedHiROMMap (void);\n\tvoid\tMap_SPC7110HiROMMap (void);\n\tvoid\tMap_BSCartLoROMMap(uint8);\n\tvoid\tMap_BSCartHiROMMap(void);\n\n\tuint16\tchecksum_calc_sum (uint8 *, uint32);\n\tuint16\tchecksum_mirror_sum (uint8 *, uint32 &, uint32 mask = 0x800000);\n\tvoid\tChecksum_Calculate (void);\n\n\tbool8\tmatch_na (const char *);\n\tbool8\tmatch_nn (const char *);\n\tbool8\tmatch_nc (const char *);\n\tbool8\tmatch_id (const char *);\n\tvoid\tApplyROMFixes (void);\n    std::string SafeString(std::string s, bool allow_jis = false);\n\tvoid\tCheckForAnyPatch (const char *, bool8, int32 &);\n\n\tvoid\tMakeRomInfoText (char *);\n\tstd::string GetMultilineROMInfo();\n\n\tconst char *\tMapType (void);\n\tconst char *\tStaticRAMSize (void);\n\tconst char *\tSize (void);\n\tconst char *\tRevision (void);\n\tconst char *\tKartContents (void);\n\tconst char *\tCountry (void);\n\tconst char *\tPublishingCompany (void);\n};\n\nstruct SMulti\n{\n\tint\t\tcartType;\n\tint32\tcartSizeA, cartSizeB;\n\tint32\tsramSizeA, sramSizeB;\n\tuint32\tsramMaskA, sramMaskB;\n\tuint32\tcartOffsetA, cartOffsetB;\n\tuint8\t*sramA, *sramB;\n\tchar\tfileNameA[PATH_MAX + 1], fileNameB[PATH_MAX + 1];\n};\n\nextern CMemory\tMemory;\nextern SMulti\tMulti;\n\ninline bool S9xInterlaceField()\n{\n\treturn (Memory.FillRAM[0x213F] & 0x80) >> 7;\n}\n\nvoid S9xAutoSaveSRAM (void);\nbool8 LoadZip(const char *, uint32 *, uint8 *);\n\nenum s9xwrap_t\n{\n\tWRAP_NONE,\n\tWRAP_BANK,\n\tWRAP_PAGE\n};\n\nenum s9xwriteorder_t\n{\n\tWRITE_01,\n\tWRITE_10\n};\n\n#include \"getset.h\"\n\n#endif\n"
        },
        {
          "name": "messages.h",
          "type": "blob",
          "size": 1.27734375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _MESSAGES_H_\n#define _MESSAGES_H_\n\n// Types of message sent to S9xMessage()\nenum\n{\n\tS9X_TRACE,\n\tS9X_DEBUG,\n\tS9X_WARNING,\n\tS9X_INFO,\n\tS9X_ERROR,\n\tS9X_FATAL_ERROR\n};\n\n// Individual message numbers\nenum\n{\n\tS9X_NO_INFO,\n\tS9X_ROM_INFO,\n\tS9X_HEADERS_INFO,\n\tS9X_CONFIG_INFO,\n\tS9X_ROM_CONFUSING_FORMAT_INFO,\n\tS9X_ROM_INTERLEAVED_INFO,\n\tS9X_SOUND_DEVICE_OPEN_FAILED,\n\tS9X_APU_STOPPED,\n\tS9X_USAGE,\n\tS9X_GAME_GENIE_CODE_ERROR,\n\tS9X_ACTION_REPLY_CODE_ERROR,\n\tS9X_GOLD_FINGER_CODE_ERROR,\n\tS9X_DEBUG_OUTPUT,\n\tS9X_DMA_TRACE,\n\tS9X_HDMA_TRACE,\n\tS9X_WRONG_FORMAT,\n\tS9X_WRONG_VERSION,\n\tS9X_ROM_NOT_FOUND,\n\tS9X_FREEZE_FILE_NOT_FOUND,\n\tS9X_PPU_TRACE,\n\tS9X_TRACE_DSP1,\n\tS9X_FREEZE_ROM_NAME,\n\tS9X_HEADER_WARNING,\n\tS9X_NETPLAY_NOT_SERVER,\n\tS9X_FREEZE_FILE_INFO,\n\tS9X_TURBO_MODE,\n\tS9X_SOUND_NOT_BUILT,\n\tS9X_MOVIE_INFO,\n\tS9X_WRONG_MOVIE_SNAPSHOT,\n\tS9X_NOT_A_MOVIE_SNAPSHOT,\n\tS9X_SNAPSHOT_INCONSISTENT,\n\tS9X_AVI_INFO,\n\tS9X_PRESSED_KEYS_INFO\n};\n\n#endif\n"
        },
        {
          "name": "missing.h",
          "type": "blob",
          "size": 1.794921875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifdef DEBUGGER\n\n#ifndef _MISSING_H_\n#define _MISSING_H_\n\nstruct MissingHDMA\n{\n\tuint8\tused;\n\tuint8\tbbus_address;\n\tuint8\tabus_bank;\n\tuint16\tabus_address;\n\tuint8\tindirect_address;\n\tuint8\tforce_table_address_write;\n\tuint8\tforce_table_address_read;\n\tuint8\tline_count_write;\n\tuint8\tline_count_read;\n};\n\nstruct Missing\n{\n\tstruct MissingHDMA hdma[8];\n\tuint8\temulate6502;\n\tuint8\tdecimal_mode;\n\tuint8\tmv_8bit_index;\n\tuint8\tmv_8bit_acc;\n\tuint8\tinterlace;\n\tuint8\tlines_239;\n\tuint8\tpseudo_512;\n\tuint8\tmodes[8];\n\tuint8\tmode7_fx;\n\tuint8\tmode7_flip;\n\tuint8\tmode7_bgmode;\n\tuint8\tdirect;\n\tuint8\tmatrix_multiply;\n\tuint8\toam_read;\n\tuint8\tvram_read;\n\tuint8\tcgram_read;\n\tuint8\twram_read;\n\tuint8\tdma_read;\n\tuint8\tvram_inc;\n\tuint8\tvram_full_graphic_inc;\n\tuint8\tvirq;\n\tuint8\thirq;\n\tuint16\tvirq_pos;\n\tuint16\thirq_pos;\n\tuint8\th_v_latch;\n\tuint8\th_counter_read;\n\tuint8\tv_counter_read;\n\tuint8\tfast_rom;\n\tuint8\twindow1[6];\n\tuint8\twindow2[6];\n\tuint8\tsprite_priority_rotation;\n\tuint8\tsubscreen;\n\tuint8\tsubscreen_add;\n\tuint8\tsubscreen_sub;\n\tuint8\tfixed_colour_add;\n\tuint8\tfixed_colour_sub;\n\tuint8\tmosaic;\n\tuint8\tsprite_double_height;\n\tuint8\tdma_channels;\n\tuint8\tdma_this_frame;\n\tuint8\toam_address_read;\n\tuint8\tbg_offset_read;\n\tuint8\tmatrix_read;\n\tuint8\thdma_channels;\n\tuint8\thdma_this_frame;\n\tuint16\tunknownppu_read;\n\tuint16\tunknownppu_write;\n\tuint16\tunknowncpu_read;\n\tuint16\tunknowncpu_write;\n\tuint16\tunknowndsp_read;\n\tuint16\tunknowndsp_write;\n};\n\nextern struct Missing\tmissing;\n\n#endif\n\n#endif\n"
        },
        {
          "name": "movie.cpp",
          "type": "blob",
          "size": 25.4140625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n//  Input recording/playback code\n//  (c) Copyright 2004 blip\n\n#ifndef __WIN32__\n#include <unistd.h>\n#endif\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"controls.h\"\n#include \"snapshot.h\"\n#include \"movie.h\"\n#include \"language.h\"\n#ifdef NETPLAY_SUPPORT\n#include \"netplay.h\"\n#endif\n\n#ifdef __WIN32__\n#include <io.h>\n#ifndef W_OK\n#define W_OK 2\n#endif\n#define ftruncate chsize\n#endif\n\n#define SMV_MAGIC\t\t\t\t0x1a564d53 // SMV0x1a\n#define SMV_VERSION\t\t\t\t5\n#define SMV_HEADER_SIZE\t\t\t64\n#define SMV_EXTRAROMINFO_SIZE\t30\n#define BUFFER_GROWTH_SIZE\t\t4096\n\nenum MovieState\n{\n\tMOVIE_STATE_NONE = 0,\n\tMOVIE_STATE_PLAY,\n\tMOVIE_STATE_RECORD\n};\n\nstruct SMovie\n{\n\tenum MovieState\tState;\n\n\tFILE\t*File;\n\tchar\tFilename[PATH_MAX + 1];\n\tchar\tROMName[23];\n\tuint32\tROMCRC32;\n\tuint32\tMovieId;\n\tuint32\tVersion;\n\n\tuint32\tSaveStateOffset;\n\tuint32\tControllerDataOffset;\n\n\tuint8\tControllersMask;\n\tuint8\tOpts;\n\tuint8\tSyncFlags;\n\tuint32\tMaxFrame;\n\tuint32\tMaxSample;\n\tuint32\tCurrentFrame;\n\tuint32\tCurrentSample;\n\tuint32\tBytesPerSample;\n\tuint32\tRerecordCount;\n\tbool8\tReadOnly;\n\tuint8\tPortType[2];\n\tint8\tPortIDs[2][4];\n\n\tuint8\t*InputBuffer;\n\tuint8\t*InputBufferPtr;\n\tuint32\tInputBufferSize;\n};\n\nstatic struct SMovie\tMovie;\n\nstatic uint8\tprevPortType[2];\nstatic int8\t\tprevPortIDs[2][4];\nstatic bool8\tprevMouseMaster, prevSuperScopeMaster, prevJustifierMaster, prevMultiPlayer5Master;\n\nstatic uint8\tRead8 (uint8 *&);\nstatic uint16\tRead16 (uint8 *&);\nstatic uint32\tRead32 (uint8 *&);\nstatic void\t\tWrite8 (uint8, uint8 *&);\nstatic void\t\tWrite16 (uint16, uint8 *&);\nstatic void\t\tWrite32 (uint32, uint8 *&);\nstatic void\t\tstore_previous_settings (void);\nstatic void\t\trestore_previous_settings (void);\nstatic void\t\tstore_movie_settings (void);\nstatic void\t\trestore_movie_settings (void);\nstatic int\t\tbytes_per_sample (void);\nstatic void\t\treserve_buffer_space (uint32);\nstatic void\t\treset_controllers (void);\nstatic void\t\tread_frame_controller_data (bool);\nstatic void\t\twrite_frame_controller_data (void);\nstatic void\t\tflush_movie (void);\nstatic void\t\ttruncate_movie (void);\nstatic int\t\tread_movie_header (FILE *, SMovie *);\nstatic int\t\tread_movie_extrarominfo (FILE *, SMovie *);\nstatic void\t\twrite_movie_header (FILE *, SMovie *);\nstatic void\t\twrite_movie_extrarominfo (FILE *, SMovie *);\nstatic void\t\tchange_state (MovieState);\n\n// HACK: reduce movie size by not storing changes that can only affect polled input in the movie for these types,\n//       because currently no port sets these types to polling\n#define SKIPPED_POLLING_PORT_TYPE(x)\t(((x) == CTL_NONE) || ((x) == CTL_JOYPAD) || ((x) == CTL_MP5))\n\n#ifndef max\n#define max(a, b)\t(((a) > (b)) ? (a) : (b))\n#endif\n\n\nstatic uint8 Read8 (uint8 *&ptr)\n{\n\tuint8\tv = *ptr++;\n\treturn (v);\n}\n\nstatic uint16 Read16 (uint8 *&ptr)\n{\n\tuint16\tv = READ_WORD(ptr);\n\tptr += 2;\n\treturn (v);\n}\n\nstatic uint32 Read32 (uint8 *&ptr)\n{\n\tuint32\tv = READ_DWORD(ptr);\n\tptr += 4;\n\treturn (v);\n}\n\nstatic void Write8 (uint8 v, uint8 *&ptr)\n{\n\t*ptr++ = v;\n}\n\nstatic void Write16 (uint16 v, uint8 *&ptr)\n{\n\tWRITE_WORD(ptr, v);\n\tptr += 2;\n}\n\nstatic void Write32 (uint32 v, uint8 *&ptr)\n{\n\tWRITE_DWORD(ptr, v);\n\tptr += 4;\n}\n\nstatic void store_previous_settings (void)\n{\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tenum controllers pt;\n\t\tS9xGetController(i, &pt, &prevPortIDs[i][0], &prevPortIDs[i][1], &prevPortIDs[i][2], &prevPortIDs[i][3]);\n\t\tprevPortType[i] = (uint8) pt;\n\t}\n\n\tprevMouseMaster        = Settings.MouseMaster;\n\tprevSuperScopeMaster   = Settings.SuperScopeMaster;\n\tprevJustifierMaster    = Settings.JustifierMaster;\n\tprevMultiPlayer5Master = Settings.MultiPlayer5Master;\n}\n\nstatic void restore_previous_settings (void)\n{\n\tSettings.MouseMaster        = prevMouseMaster;\n\tSettings.SuperScopeMaster   = prevSuperScopeMaster;\n\tSettings.JustifierMaster    = prevJustifierMaster;\n\tSettings.MultiPlayer5Master = prevMultiPlayer5Master;\n\n\tS9xSetController(0, (enum controllers) prevPortType[0], prevPortIDs[0][0], prevPortIDs[0][1], prevPortIDs[0][2], prevPortIDs[0][3]);\n\tS9xSetController(1, (enum controllers) prevPortType[1], prevPortIDs[1][0], prevPortIDs[1][1], prevPortIDs[1][2], prevPortIDs[1][3]);\n}\n\nstatic void store_movie_settings (void)\n{\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tenum controllers pt;\n\t\tS9xGetController(i, &pt, &Movie.PortIDs[i][0], &Movie.PortIDs[i][1], &Movie.PortIDs[i][2], &Movie.PortIDs[i][3]);\n\t\tMovie.PortType[i] = (uint8) pt;\n\t}\n}\n\nstatic void restore_movie_settings (void)\n{\n\tSettings.MouseMaster        = (Movie.PortType[0] == CTL_MOUSE      || Movie.PortType[1] == CTL_MOUSE);\n\tSettings.SuperScopeMaster   = (Movie.PortType[0] == CTL_SUPERSCOPE || Movie.PortType[1] == CTL_SUPERSCOPE);\n\tSettings.JustifierMaster    = (Movie.PortType[0] == CTL_JUSTIFIER  || Movie.PortType[1] == CTL_JUSTIFIER);\n\tSettings.MultiPlayer5Master = (Movie.PortType[0] == CTL_MP5        || Movie.PortType[1] == CTL_MP5);\n\n\tS9xSetController(0, (enum controllers) Movie.PortType[0], Movie.PortIDs[0][0], Movie.PortIDs[0][1], Movie.PortIDs[0][2], Movie.PortIDs[0][3]);\n\tS9xSetController(1, (enum controllers) Movie.PortType[1], Movie.PortIDs[1][0], Movie.PortIDs[1][1], Movie.PortIDs[1][2], Movie.PortIDs[1][3]);\n}\n\nstatic int bytes_per_sample (void)\n{\n\tint\tnum_controllers = 0;\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (Movie.ControllersMask & (1 << i))\n\t\t\tnum_controllers++;\n\t}\n\n\tint\tbytes = CONTROLLER_DATA_SIZE * num_controllers;\n\n\tfor (int p = 0; p < 2; p++)\n\t{\n\t\tif (Movie.PortType[p] == CTL_MOUSE)\n\t\t\tbytes += MOUSE_DATA_SIZE;\n\t\telse\n\t\tif (Movie.PortType[p] == CTL_SUPERSCOPE)\n\t\t\tbytes += SCOPE_DATA_SIZE;\n\t\telse\n\t\tif (Movie.PortType[p] == CTL_JUSTIFIER)\n\t\t\tbytes += JUSTIFIER_DATA_SIZE;\n\t}\n\n\treturn (bytes);\n}\n\nstatic void reserve_buffer_space (uint32 space_needed)\n{\n\tif (space_needed > Movie.InputBufferSize)\n\t{\n\t\tuint32 ptr_offset   = Movie.InputBufferPtr - Movie.InputBuffer;\n\t\tuint32 alloc_chunks = space_needed / BUFFER_GROWTH_SIZE;\n\n\t\tMovie.InputBufferSize = BUFFER_GROWTH_SIZE * (alloc_chunks + 1);\n\t\tMovie.InputBuffer     = (uint8 *) realloc(Movie.InputBuffer, Movie.InputBufferSize);\n\t\tMovie.InputBufferPtr  = Movie.InputBuffer + ptr_offset;\n\t}\n}\n\nstatic void reset_controllers (void)\n{\n\tfor (int i = 0; i < 8; i++)\n\t\tMovieSetJoypad(i, 0);\n\n\tuint8 clearedMouse[MOUSE_DATA_SIZE];\n\tmemset(clearedMouse, 0, MOUSE_DATA_SIZE);\n\tclearedMouse[4] = 1;\n\n\tuint8 clearedScope[SCOPE_DATA_SIZE];\n\tmemset(clearedScope, 0, SCOPE_DATA_SIZE);\n\n\tuint8 clearedJustifier[JUSTIFIER_DATA_SIZE];\n\tmemset(clearedJustifier, 0, JUSTIFIER_DATA_SIZE);\n\n\tfor (int p = 0; p < 2; p++)\n\t{\n\t\tMovieSetMouse(p, clearedMouse, true);\n\t\tMovieSetScope(p, clearedScope);\n\t\tMovieSetJustifier(p, clearedJustifier);\n\t}\n}\n\nstatic void read_frame_controller_data (bool addFrame)\n{\n\t// reset code check\n\tif (Movie.InputBufferPtr[0] == 0xff)\n\t{\n\t\tbool reset = true;\n\t\tfor (int i = 1; i < (int) Movie.BytesPerSample; i++)\n\t\t{\n\t\t\tif (Movie.InputBufferPtr[i] != 0xff)\n\t\t\t{\n\t\t\t\treset = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (reset)\n\t\t{\n\t\t\tMovie.InputBufferPtr += Movie.BytesPerSample;\n\t\t\tS9xSoftReset();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (Movie.ControllersMask & (1 << i))\n\t\t\tMovieSetJoypad(i, Read16(Movie.InputBufferPtr));\n\t\telse\n\t\t\tMovieSetJoypad(i, 0); // pretend the controller is disconnected\n\t}\n\n\tfor (int p = 0; p < 2; p++)\n\t{\n\t\tif (Movie.PortType[p] == CTL_MOUSE)\n\t\t{\n\t\t\tuint8 buf[MOUSE_DATA_SIZE];\n\t\t\tmemcpy(buf, Movie.InputBufferPtr, MOUSE_DATA_SIZE);\n\t\t\tMovie.InputBufferPtr += MOUSE_DATA_SIZE;\n\t\t\tMovieSetMouse(p, buf, !addFrame);\n\t\t}\n\t\telse\n\t\tif (Movie.PortType[p] == CTL_SUPERSCOPE)\n\t\t{\n\t\t\tuint8 buf[SCOPE_DATA_SIZE];\n\t\t\tmemcpy(buf, Movie.InputBufferPtr, SCOPE_DATA_SIZE);\n\t\t\tMovie.InputBufferPtr += SCOPE_DATA_SIZE;\n\t\t\tMovieSetScope(p, buf);\n\t\t}\n\t\telse\n\t\tif (Movie.PortType[p] == CTL_JUSTIFIER)\n\t\t{\n\t\t\tuint8 buf[JUSTIFIER_DATA_SIZE];\n\t\t\tmemcpy(buf, Movie.InputBufferPtr, JUSTIFIER_DATA_SIZE);\n\t\t\tMovie.InputBufferPtr += JUSTIFIER_DATA_SIZE;\n\t\t\tMovieSetJustifier(p, buf);\n\t\t}\n\t}\n}\n\nstatic void write_frame_controller_data (void)\n{\n\treserve_buffer_space((uint32) (Movie.InputBufferPtr + Movie.BytesPerSample - Movie.InputBuffer));\n\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tif (Movie.ControllersMask & (1 << i))\n\t\t\tWrite16(MovieGetJoypad(i), Movie.InputBufferPtr);\n\t\telse\n\t\t\tMovieSetJoypad(i, 0); // pretend the controller is disconnected\n\t}\n\n\tfor (int p = 0; p < 2; p++)\n\t{\n\t\tif (Movie.PortType[p] == CTL_MOUSE)\n\t\t{\n\t\t\tuint8 buf[MOUSE_DATA_SIZE];\n\t\t\tMovieGetMouse(p, buf);\n\t\t\tmemcpy(Movie.InputBufferPtr, buf, MOUSE_DATA_SIZE);\n\t\t\tMovie.InputBufferPtr += MOUSE_DATA_SIZE;\n\t\t}\n\t\telse\n\t\tif (Movie.PortType[p] == CTL_SUPERSCOPE)\n\t\t{\n\t\t\tuint8 buf[SCOPE_DATA_SIZE];\n\t\t\tMovieGetScope(p, buf);\n\t\t\tmemcpy(Movie.InputBufferPtr, buf, SCOPE_DATA_SIZE);\n\t\t\tMovie.InputBufferPtr += SCOPE_DATA_SIZE;\n\t\t}\n\t\telse\n\t\tif (Movie.PortType[p] == CTL_JUSTIFIER)\n\t\t{\n\t\t\tuint8 buf[JUSTIFIER_DATA_SIZE];\n\t\t\tMovieGetJustifier(p, buf);\n\t\t\tmemcpy(Movie.InputBufferPtr, buf, JUSTIFIER_DATA_SIZE);\n\t\t\tMovie.InputBufferPtr += JUSTIFIER_DATA_SIZE;\n\t\t}\n\t}\n}\n\nstatic void flush_movie (void)\n{\n\tif (!Movie.File)\n\t\treturn;\n\n\tfseek(Movie.File, 0, SEEK_SET);\n\twrite_movie_header(Movie.File, &Movie);\n\tfseek(Movie.File, Movie.ControllerDataOffset, SEEK_SET);\n\n\tif (!fwrite(Movie.InputBuffer, 1, Movie.BytesPerSample * (Movie.MaxSample + 1), Movie.File))\n\t\tprintf (\"Movie flush failed.\\n\");\n}\n\nstatic void truncate_movie (void)\n{\n\tif (!Movie.File || !Settings.MovieTruncate)\n\t\treturn;\n\n\tif (Movie.SaveStateOffset > Movie.ControllerDataOffset)\n\t\treturn;\n\n\tif (ftruncate(fileno(Movie.File), Movie.ControllerDataOffset + Movie.BytesPerSample * (Movie.MaxSample + 1)))\n\t\tprintf (\"Couldn't truncate file.\\n\");\n}\n\nstatic int read_movie_header (FILE *fd, SMovie *movie)\n{\n\tuint32\tvalue;\n\tuint8\tbuf[SMV_HEADER_SIZE], *ptr = buf;\n\n\tif (fread(buf, 1, SMV_HEADER_SIZE, fd) != SMV_HEADER_SIZE)\n\t\treturn (WRONG_FORMAT);\n\n\tvalue = Read32(ptr);\n\tif (value != SMV_MAGIC)\n\t\treturn (WRONG_FORMAT);\n\n\tvalue = Read32(ptr);\n\tif(value > SMV_VERSION || value < 4)\n\t\treturn (WRONG_VERSION);\n\n\tmovie->Version              = value;\n\tmovie->MovieId              = Read32(ptr);\n\tmovie->RerecordCount        = Read32(ptr);\n\tmovie->MaxFrame             = Read32(ptr);\n\tmovie->ControllersMask      = Read8(ptr);\n\tmovie->Opts                 = Read8(ptr);\n\tptr++;\n\tmovie->SyncFlags            = Read8(ptr);\n\tmovie->SaveStateOffset      = Read32(ptr);\n\tmovie->ControllerDataOffset = Read32(ptr);\n\tmovie->MaxSample            = Read32(ptr);\n\tmovie->PortType[0]          = Read8(ptr);\n\tmovie->PortType[1]          = Read8(ptr);\n\tfor (int p = 0; p < 2; p++)\n\t{\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tmovie->PortIDs[p][i] = Read8(ptr);\n\t}\n\n\tif (movie->MaxSample < movie->MaxFrame)\n\t\tmovie->MaxSample = movie->MaxFrame;\n\n\treturn (SUCCESS);\n}\n\nstatic int read_movie_extrarominfo (FILE *fd, SMovie *movie)\n{\n\tuint8\tbuf[SMV_EXTRAROMINFO_SIZE], *ptr = buf;\n\n\tfseek(fd, movie->SaveStateOffset - SMV_EXTRAROMINFO_SIZE, SEEK_SET);\n\n\tif (fread(buf, 1, SMV_EXTRAROMINFO_SIZE, fd) != SMV_EXTRAROMINFO_SIZE)\n\t\treturn (WRONG_FORMAT);\n\n\tptr += 3; // zero bytes\n\tmovie->ROMCRC32 = Read32(ptr);\n\tmemcpy(movie->ROMName, (char *) ptr, 23);\n\n\treturn (SUCCESS);\n}\n\nstatic void write_movie_header (FILE *fd, SMovie *movie)\n{\n\tuint8\tbuf[SMV_HEADER_SIZE], *ptr = buf;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tWrite32(SMV_MAGIC, ptr);\n\tWrite32(SMV_VERSION, ptr);\n\tWrite32(movie->MovieId, ptr);\n\tWrite32(movie->RerecordCount, ptr);\n\tWrite32(movie->MaxFrame, ptr);\n\tWrite8(movie->ControllersMask, ptr);\n\tWrite8(movie->Opts, ptr);\n\tptr++;\n\tWrite8(movie->SyncFlags, ptr);\n\tWrite32(movie->SaveStateOffset, ptr);\n\tWrite32(movie->ControllerDataOffset, ptr);\n\tWrite32(movie->MaxSample, ptr);\n\tWrite8(movie->PortType[0], ptr);\n\tWrite8(movie->PortType[1], ptr);\n\tfor (int p = 0; p < 2; p++)\n\t{\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tWrite8(movie->PortIDs[p][i], ptr);\n\t}\n\n\tif (!fwrite(buf, 1, SMV_HEADER_SIZE, fd))\n\t\tprintf (\"Couldn't write movie header.\\n\");\n}\n\nstatic void write_movie_extrarominfo (FILE *fd, SMovie *movie)\n{\n\tuint8\tbuf[SMV_EXTRAROMINFO_SIZE], *ptr = buf;\n\n\tWrite8(0, ptr);\n\tWrite8(0, ptr);\n\tWrite8(0, ptr);\n\tWrite32(movie->ROMCRC32, ptr);\n\tstrncpy((char *) ptr, movie->ROMName, 23);\n\n\tfwrite(buf, 1, SMV_EXTRAROMINFO_SIZE, fd);\n}\n\nstatic void change_state (MovieState new_state)\n{\n\tif (new_state == Movie.State)\n\t\treturn;\n\n\tif (Movie.State == MOVIE_STATE_RECORD)\n\t\tflush_movie();\n\n\tif (new_state == MOVIE_STATE_NONE)\n\t{\n\t\ttruncate_movie();\n\t\tfclose(Movie.File);\n\t\tMovie.File = NULL;\n\n\t\tif (S9xMoviePlaying() || S9xMovieRecording())\n\t\t\trestore_previous_settings();\n\t}\n\n\tMovie.State = new_state;\n}\n\nvoid S9xMovieFreeze (uint8 **buf, uint32 *size)\n{\n\tif (!S9xMovieActive())\n\t\treturn;\n\n\tuint32\tsize_needed;\n\tuint8\t*ptr;\n\n\tsize_needed = sizeof(Movie.MovieId) + sizeof(Movie.CurrentFrame) + sizeof(Movie.MaxFrame) + sizeof(Movie.CurrentSample) + sizeof(Movie.MaxSample);\n\tsize_needed += (uint32) (Movie.BytesPerSample * (Movie.MaxSample + 1));\n\t*size = size_needed;\n\n\t*buf = new uint8[size_needed];\n\tptr = *buf;\n\tif (!ptr)\n\t\treturn;\n\n\tWrite32(Movie.MovieId, ptr);\n\tWrite32(Movie.CurrentFrame, ptr);\n\tWrite32(Movie.MaxFrame, ptr);\n\tWrite32(Movie.CurrentSample, ptr);\n\tWrite32(Movie.MaxSample, ptr);\n\n\tmemcpy(ptr, Movie.InputBuffer, Movie.BytesPerSample * (Movie.MaxSample + 1));\n}\n\nint S9xMovieUnfreeze (uint8 *buf, uint32 size)\n{\n\tif (!S9xMovieActive())\n\t\treturn (FILE_NOT_FOUND);\n\n\tif (size < sizeof(Movie.MovieId) + sizeof(Movie.CurrentFrame) + sizeof(Movie.MaxFrame) + sizeof(Movie.CurrentSample) + sizeof(Movie.MaxSample))\n\t\treturn (WRONG_FORMAT);\n\n\tuint8\t*ptr = buf;\n\n\tuint32\tmovie_id       = Read32(ptr);\n\tuint32\tcurrent_frame  = Read32(ptr);\n\tuint32\tmax_frame      = Read32(ptr);\n\tuint32\tcurrent_sample = Read32(ptr);\n\tuint32\tmax_sample     = Read32(ptr);\n\tuint32\tspace_needed   = (Movie.BytesPerSample * (max_sample + 1));\n\n\tif (current_frame > max_frame || current_sample > max_sample || space_needed > size)\n\t\treturn (WRONG_MOVIE_SNAPSHOT);\n\n\tif (Settings.WrongMovieStateProtection)\n\t\tif (movie_id != Movie.MovieId)\n\t\t\tif (max_frame < Movie.MaxFrame || max_sample < Movie.MaxSample || memcmp(Movie.InputBuffer, ptr, space_needed))\n\t\t\t\treturn (WRONG_MOVIE_SNAPSHOT);\n\n\tif (!Movie.ReadOnly)\n\t{\n\t\tchange_state(MOVIE_STATE_RECORD);\n\n\t\tMovie.CurrentFrame  = current_frame;\n\t\tMovie.MaxFrame      = max_frame;\n\t\tMovie.CurrentSample = current_sample;\n\t\tMovie.MaxSample     = max_sample;\n\t\tMovie.RerecordCount++;\n\n\t\tstore_movie_settings();\n\n\t\treserve_buffer_space(space_needed);\n\t\tmemcpy(Movie.InputBuffer, ptr, space_needed);\n\n\t\tflush_movie();\n\t\tfseek(Movie.File, Movie.ControllerDataOffset + (Movie.BytesPerSample * (Movie.CurrentSample + 1)), SEEK_SET);\n\t}\n\telse\n\t{\n      uint32   space_processed = (Movie.BytesPerSample * (current_sample + 1));\n      if (current_frame > Movie.MaxFrame || current_sample > Movie.MaxSample || memcmp(Movie.InputBuffer, ptr, space_processed))\n\t\t\treturn (SNAPSHOT_INCONSISTENT);\n\n\t\tchange_state(MOVIE_STATE_PLAY);\n\n\t\tMovie.CurrentFrame  = current_frame;\n\t\tMovie.CurrentSample = current_sample;\n\t}\n\n\tMovie.InputBufferPtr = Movie.InputBuffer + (Movie.BytesPerSample * Movie.CurrentSample);\n\tread_frame_controller_data(true);\n\n\treturn (SUCCESS);\n}\n\nint S9xMovieOpen (const char *filename, bool8 read_only)\n{\n\tFILE\t*fd;\n\tSTREAM\tstream;\n\tint\t\tresult;\n\tint\t\tfn;\n\n\tif (!(fd = fopen(filename, \"rb+\")))\n\t{\n\t\tif (!(fd = fopen(filename, \"rb\")))\n\t\t\treturn (FILE_NOT_FOUND);\n\t\telse\n\t\t\tread_only = TRUE;\n\t}\n\n\tchange_state(MOVIE_STATE_NONE);\n\n\tresult = read_movie_header(fd, &Movie);\n\tif (result != SUCCESS)\n\t{\n\t\tfclose(fd);\n\t\treturn (result);\n\t}\n\n\tread_movie_extrarominfo(fd, &Movie);\n\n\tfflush(fd);\n\tfn = fileno(fd);\n\n\tstore_previous_settings();\n\trestore_movie_settings();\n\n\tlseek(fn, Movie.SaveStateOffset, SEEK_SET);\n\n    // reopen stream to access as gzipped data\n    stream = REOPEN_STREAM(fn, \"rb\");\n\tif (!stream)\n\t\treturn (FILE_NOT_FOUND);\n\n\tif (Movie.Opts & MOVIE_OPT_FROM_RESET)\n\t{\n\t\tS9xReset();\n\t\treset_controllers();\n\t\tresult = (READ_STREAM(Memory.SRAM, 0x20000, stream) == 0x20000) ? SUCCESS : WRONG_FORMAT;\n\t}\n\telse\n\t\tresult = S9xUnfreezeFromStream(stream);\n\n    // do not close stream but close FILE *\n    // (msvcrt will try to close all open FILE *handles on exit - if we do CLOSE_STREAM here\n    //  the underlying file will be closed by zlib, causing problems when msvcrt tries to do it)\n    delete stream;\n    fclose(fd);\n\n\tif (result != SUCCESS)\n\t\treturn (result);\n\n\tif (!(fd = fopen(filename, \"rb+\")))\n\t{\n\t\tif (!(fd = fopen(filename, \"rb\")))\n\t\t\treturn (FILE_NOT_FOUND);\n\t\telse\n\t\t\tread_only = TRUE;\n\t}\n\n\tif (fseek(fd, Movie.ControllerDataOffset, SEEK_SET))\n\t{\n\t\tfclose(fd);\n\t\treturn (WRONG_FORMAT);\n\t}\n\n\tMovie.File           = fd;\n\tMovie.BytesPerSample = bytes_per_sample();\n\tMovie.InputBufferPtr = Movie.InputBuffer;\n\treserve_buffer_space(Movie.BytesPerSample * (Movie.MaxSample + 1));\n\n\tif (!fread(Movie.InputBufferPtr, 1, Movie.BytesPerSample * (Movie.MaxSample + 1), fd))\n\t{\n\t\tprintf (\"Failed to read from movie file.\\n\");\n\t\tfclose(fd);\n\t\treturn (WRONG_FORMAT);\n\t}\n\n\t// read \"baseline\" controller data\n\tif (Movie.MaxSample && Movie.MaxFrame)\n\t\tread_frame_controller_data(true);\n\n\tMovie.CurrentFrame  = 0;\n\tMovie.CurrentSample = 0;\n\tMovie.ReadOnly      = read_only;\n\tstrncpy(Movie.Filename, filename, PATH_MAX + 1);\n\tMovie.Filename[PATH_MAX] = 0;\n\n\tchange_state(MOVIE_STATE_PLAY);\n\n\tS9xUpdateFrameCounter(-1);\n\n\tS9xMessage(S9X_INFO, S9X_MOVIE_INFO, MOVIE_INFO_REPLAY);\n\n\treturn (SUCCESS);\n}\n\nint S9xMovieCreate (const char *filename, uint8 controllers_mask, uint8 opts, const wchar_t *metadata, int metadata_length)\n{\n\tFILE\t*fd;\n\tSTREAM\tstream;\n\n\tif (controllers_mask == 0)\n\t\treturn (WRONG_FORMAT);\n\n\tif (!(fd = fopen(filename, \"wb\")))\n\t\treturn (FILE_NOT_FOUND);\n\n\tif (metadata_length > MOVIE_MAX_METADATA)\n\t\tmetadata_length = MOVIE_MAX_METADATA;\n\n\tchange_state(MOVIE_STATE_NONE);\n\n\tstore_previous_settings();\n\tstore_movie_settings();\n\n\tMovie.MovieId              = (uint32) time(NULL);\n\tMovie.RerecordCount        = 0;\n\tMovie.MaxFrame             = 0;\n\tMovie.MaxSample            = 0;\n\tMovie.SaveStateOffset      = SMV_HEADER_SIZE + (sizeof(uint16) * metadata_length) + SMV_EXTRAROMINFO_SIZE;\n\tMovie.ControllerDataOffset = 0;\n\tMovie.ControllersMask      = controllers_mask;\n\tMovie.Opts                 = opts;\n\tMovie.SyncFlags            = MOVIE_SYNC_DATA_EXISTS | MOVIE_SYNC_HASROMINFO;\n\n\twrite_movie_header(fd, &Movie);\n\n\t// convert wchar_t metadata string/array to a uint16 array\n\t// XXX: UTF-8 is much better...\n\tif (metadata_length > 0)\n\t{\n\t\tuint8 meta_buf[sizeof(uint16) * MOVIE_MAX_METADATA];\n\t\tfor (int i = 0; i < metadata_length; i++)\n\t\t{\n\t\t\tuint16 c = (uint16) metadata[i];\n\t\t\tmeta_buf[i * 2]     = (uint8) (c & 0xff);\n\t\t\tmeta_buf[i * 2 + 1] = (uint8) ((c >> 8) & 0xff);\n\t\t}\n\n\t\tif (!fwrite(meta_buf, sizeof(uint16), metadata_length, fd))\n\t\t\tprintf (\"Failed writing movie metadata.\\n\");\n\t}\n\n\tMovie.ROMCRC32 = Memory.ROMCRC32;\n\n\twrite_movie_extrarominfo(fd, &Movie);\n\n\tfclose(fd);\n\n\tstream = OPEN_STREAM(filename, \"ab\");\n\tif (!stream)\n\t\treturn (FILE_NOT_FOUND);\n\n\tif (opts & MOVIE_OPT_FROM_RESET)\n\t{\n\t\tS9xReset();\n\t\treset_controllers();\n\t\tWRITE_STREAM(Memory.SRAM, 0x20000, stream);\n\t}\n\telse\n\t\tS9xFreezeToStream(stream);\n\n\tCLOSE_STREAM(stream);\n\n\tif (!(fd = fopen(filename, \"rb+\")))\n\t\treturn (FILE_NOT_FOUND);\n\n\tfseek(fd, 0, SEEK_END);\n\tMovie.ControllerDataOffset = (uint32) ftell(fd);\n\n\t// 16-byte align the controller input, for hex-editing friendliness if nothing else\n\twhile (Movie.ControllerDataOffset % 16)\n\t{\n\t\tfputc(0xcc, fd); // arbitrary\n\t\tMovie.ControllerDataOffset++;\n\t}\n\n\t// write \"baseline\" controller data\n\tMovie.File           = fd;\n\tMovie.BytesPerSample = bytes_per_sample();\n\tMovie.InputBufferPtr = Movie.InputBuffer;\n\twrite_frame_controller_data();\n\n\tMovie.CurrentFrame  = 0;\n\tMovie.CurrentSample = 0;\n\tMovie.ReadOnly      = false;\n\tstrncpy(Movie.Filename, filename, PATH_MAX + 1);\n\tMovie.Filename[PATH_MAX] = 0;\n\n\tchange_state(MOVIE_STATE_RECORD);\n\n\tS9xUpdateFrameCounter(-1);\n\n\tS9xMessage(S9X_INFO, S9X_MOVIE_INFO, MOVIE_INFO_RECORD);\n\n\treturn (SUCCESS);\n}\n\nint S9xMovieGetInfo (const char *filename, struct MovieInfo *info)\n{\n\tFILE\t*fd;\n\tSMovie\tlocal_movie;\n\tint\t\tmetadata_length;\n\tint\t\tresult, i;\n\n\tflush_movie();\n\n\tmemset(info, 0, sizeof(*info));\n\n\tif (!(fd = fopen(filename, \"rb\")))\n\t\treturn (FILE_NOT_FOUND);\n\n\tresult = read_movie_header(fd, &local_movie);\n\tif (result != SUCCESS)\n\t{\n\t\tfclose(fd);\n\t\treturn (result);\n\t}\n\n\tinfo->TimeCreated     = (time_t) local_movie.MovieId;\n\tinfo->Version         = local_movie.Version;\n\tinfo->Opts            = local_movie.Opts;\n\tinfo->SyncFlags       = local_movie.SyncFlags;\n\tinfo->ControllersMask = local_movie.ControllersMask;\n\tinfo->RerecordCount   = local_movie.RerecordCount;\n\tinfo->LengthFrames    = local_movie.MaxFrame;\n\tinfo->LengthSamples   = local_movie.MaxSample;\n\tinfo->PortType[0]     = local_movie.PortType[0];\n\tinfo->PortType[1]     = local_movie.PortType[1];\n\n\tif (local_movie.SaveStateOffset > SMV_HEADER_SIZE)\n\t{\n\t\tuint8\tmeta_buf[sizeof(uint16) * MOVIE_MAX_METADATA];\n\t\tint\t\tcurRomInfoSize = (local_movie.SyncFlags & MOVIE_SYNC_HASROMINFO) ? SMV_EXTRAROMINFO_SIZE : 0;\n\n\t\tmetadata_length = ((int) local_movie.SaveStateOffset - SMV_HEADER_SIZE - curRomInfoSize) / sizeof(uint16);\n\t\tmetadata_length = (metadata_length >= MOVIE_MAX_METADATA) ? MOVIE_MAX_METADATA - 1 : metadata_length;\n\t\tmetadata_length = (int) fread(meta_buf, sizeof(uint16), metadata_length, fd);\n\n\t\tfor (i = 0; i < metadata_length; i++)\n\t\t{\n\t\t\tuint16 c = meta_buf[i * 2] | (meta_buf[i * 2 + 1] << 8);\n\t\t\tinfo->Metadata[i] = (wchar_t) c;\n\t\t}\n\n\t\tinfo->Metadata[i] = '\\0';\n\t}\n\telse\n\t\tinfo->Metadata[0] = '\\0';\n\n\tread_movie_extrarominfo(fd, &local_movie);\n\n\tinfo->ROMCRC32 = local_movie.ROMCRC32;\n\tstrncpy(info->ROMName, local_movie.ROMName, 23);\n\n\tfclose(fd);\n\tif ((fd = fopen(filename, \"r+\")) == NULL)\n\t\tinfo->ReadOnly = true;\n\telse\n\t\tfclose(fd);\n\n\treturn (SUCCESS);\n}\n\nvoid S9xMovieUpdate (bool addFrame)\n{\n\tswitch (Movie.State)\n\t{\n\t\tcase MOVIE_STATE_PLAY:\n\t\t{\n\t\t\tif (Movie.CurrentFrame >= Movie.MaxFrame || Movie.CurrentSample >= Movie.MaxSample)\n\t\t\t{\n\t\t\t\tchange_state(MOVIE_STATE_NONE);\n\t\t\t\tS9xMessage(S9X_INFO, S9X_MOVIE_INFO, MOVIE_INFO_END);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (addFrame)\n\t\t\t\t\tS9xUpdateFrameCounter();\n\t\t\t\telse\n\t\t\t\tif (SKIPPED_POLLING_PORT_TYPE(Movie.PortType[0]) && SKIPPED_POLLING_PORT_TYPE(Movie.PortType[1]))\n\t\t\t\t\treturn;\n\n\t\t\t\tread_frame_controller_data(addFrame);\n\t\t\t\tMovie.CurrentSample++;\n\t\t\t\tif (addFrame)\n\t\t\t\t\tMovie.CurrentFrame++;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase MOVIE_STATE_RECORD:\n\t\t{\n\t\t\tif (addFrame)\n\t\t\t\tS9xUpdateFrameCounter();\n\t\t\telse\n\t\t\tif (SKIPPED_POLLING_PORT_TYPE(Movie.PortType[0]) && SKIPPED_POLLING_PORT_TYPE(Movie.PortType[1]))\n\t\t\t\treturn;\n\n\t\t\twrite_frame_controller_data();\n\t\t\tMovie.MaxSample = ++Movie.CurrentSample;\n\t\t\tif (addFrame)\n\t\t\t\tMovie.MaxFrame = ++Movie.CurrentFrame;\n\n\t\t\tif (!fwrite((Movie.InputBufferPtr - Movie.BytesPerSample), 1, Movie.BytesPerSample, Movie.File))\n\t\t\t\tprintf (\"Error writing control data.\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t{\n\t\t\tif (addFrame)\n\t\t\t\tS9xUpdateFrameCounter();\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid S9xMovieUpdateOnReset (void)\n{\n\tif (Movie.State == MOVIE_STATE_RECORD)\n\t{\n\t\treserve_buffer_space((uint32) (Movie.InputBufferPtr + Movie.BytesPerSample - Movie.InputBuffer));\n\t\tmemset(Movie.InputBufferPtr, 0xFF, Movie.BytesPerSample);\n\t\tMovie.InputBufferPtr += Movie.BytesPerSample;\n\t\tMovie.MaxSample = ++Movie.CurrentSample;\n\t\tMovie.MaxFrame = ++Movie.CurrentFrame;\n\n\t\tif (!fwrite((Movie.InputBufferPtr - Movie.BytesPerSample), 1, Movie.BytesPerSample, Movie.File))\n\t\t\tprintf (\"Failed writing reset data.\\n\");\n\t}\n}\n\nvoid S9xMovieInit (void)\n{\n\tmemset(&Movie, 0, sizeof(Movie));\n\tMovie.State = MOVIE_STATE_NONE;\n}\n\nvoid S9xMovieStop (bool8 suppress_message)\n{\n\tif (Movie.State != MOVIE_STATE_NONE)\n\t{\n\t\tchange_state(MOVIE_STATE_NONE);\n\n\t\tif (!suppress_message)\n\t\t\tS9xMessage(S9X_INFO, S9X_MOVIE_INFO, MOVIE_INFO_STOP);\n\t}\n}\n\nvoid S9xMovieShutdown (void)\n{\n\tif (S9xMovieActive())\n\t\tS9xMovieStop(TRUE);\n}\n\nbool8 S9xMovieActive (void)\n{\n\treturn (Movie.State != MOVIE_STATE_NONE);\n}\n\nbool8 S9xMoviePlaying (void)\n{\n\treturn (Movie.State == MOVIE_STATE_PLAY);\n}\n\nbool8 S9xMovieRecording (void)\n{\n\treturn (Movie.State == MOVIE_STATE_RECORD);\n}\n\nuint8 S9xMovieControllers (void)\n{\n\treturn (Movie.ControllersMask);\n}\n\nbool8 S9xMovieReadOnly (void)\n{\n\tif (!S9xMovieActive())\n\t\treturn (FALSE);\n\treturn (Movie.ReadOnly);\n}\n\nuint32 S9xMovieGetId (void)\n{\n\tif (!S9xMovieActive())\n\t\treturn (0);\n\treturn (Movie.MovieId);\n}\n\nuint32 S9xMovieGetLength (void)\n{\n\tif (!S9xMovieActive())\n\t\treturn (0);\n\treturn (Movie.MaxFrame);\n}\n\nuint32 S9xMovieGetFrameCounter (void)\n{\n\tif (!S9xMovieActive())\n\t\treturn (0);\n\treturn (Movie.CurrentFrame);\n}\n\nvoid S9xMovieToggleRecState (void)\n{\n\tMovie.ReadOnly = !Movie.ReadOnly;\n\n\tif (Movie.ReadOnly)\n\t   S9xMessage(S9X_INFO, S9X_MOVIE_INFO, \"Movie is now read-only.\");\n\telse\n\t   S9xMessage(S9X_INFO, S9X_MOVIE_INFO, \"Movie is now read+write.\");\n}\n\nvoid S9xMovieToggleFrameDisplay (void)\n{\n\tSettings.DisplayMovieFrame = !Settings.DisplayMovieFrame;\n\tS9xReRefresh();\n}\n\nvoid S9xUpdateFrameCounter (int offset)\n{\n\textern bool8\tpad_read;\n\n\toffset++;\n\n\tif (!Settings.DisplayMovieFrame)\n\t\t*GFX.FrameDisplayString = 0;\n\telse\n\tif (Movie.State == MOVIE_STATE_RECORD)\n\t\tsprintf(GFX.FrameDisplayString, \"Recording frame: %d%s\",\n\t\t\tmax(0, (int) (Movie.CurrentFrame + offset)), pad_read || !Settings.MovieNotifyIgnored ? \"\" : \" (ignored)\");\n\telse\n\tif (Movie.State == MOVIE_STATE_PLAY)\n\t\tsprintf(GFX.FrameDisplayString, \"Playing frame: %d / %d\",\n\t\t\tmax(0, (int) (Movie.CurrentFrame + offset)), Movie.MaxFrame);\n#ifdef NETPLAY_SUPPORT\n\telse\n\tif (Settings.NetPlay)\n\t\tsprintf(GFX.FrameDisplayString, \"%s frame: %d\", Settings.NetPlayServer ? \"Server\" : \"Client\",\n\t\t\tmax(0, (int) (NetPlay.FrameCount + offset)));\n#endif\n}\n"
        },
        {
          "name": "movie.h",
          "type": "blob",
          "size": 2.4560546875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _MOVIE_H_\n#define _MOVIE_H_\n\n#define MOVIE_OPT_FROM_SNAPSHOT\t\t0\n#define MOVIE_OPT_FROM_RESET\t\t(1 << 0)\n#define MOVIE_OPT_PAL\t\t\t\t(1 << 1)\n#define MOVIE_OPT_NOSAVEDATA\t\t(1 << 2)\n#define MOVIE_SYNC_DATA_EXISTS\t\t0x01\n#define MOVIE_SYNC_OBSOLETE\t\t\t0x02\n#define MOVIE_SYNC_VOLUMEENVX\t\t0x08\n#define MOVIE_SYNC_FAKEMUTE\t\t\t0x10\n#define MOVIE_SYNC_HASROMINFO\t\t0x40\n#define MOVIE_SYNC_NOCPUSHUTDOWN\t0x80\n#define MOVIE_MAX_METADATA\t\t\t512\n\n#define CONTROLLER_DATA_SIZE\t\t2\n#define MOUSE_DATA_SIZE\t\t\t\t5\n#define SCOPE_DATA_SIZE\t\t\t\t6\n#define JUSTIFIER_DATA_SIZE\t\t\t11\n\nstruct MovieInfo\n{\n\ttime_t\tTimeCreated;\n\tuint32\tVersion;\n\tuint32\tLengthFrames;\n\tuint32\tLengthSamples;\n\tuint32\tRerecordCount;\n\tuint8\tOpts;\n\tuint8\tControllersMask;\n\tuint8\tSyncFlags;\n\tbool8\tReadOnly;\n\tuint8\tPortType[2];\n\twchar_t\tMetadata[MOVIE_MAX_METADATA];\n\tuint32\tROMCRC32;\n\tchar\tROMName[23];\n};\n\n// methods used by the user-interface code\nint S9xMovieOpen (const char *, bool8);\nint S9xMovieCreate (const char *, uint8, uint8, const wchar_t *, int);\nint S9xMovieGetInfo (const char *, struct MovieInfo *);\nvoid S9xMovieStop (bool8);\nvoid S9xMovieToggleRecState (void);\nvoid S9xMovieToggleFrameDisplay (void);\n\n// methods used by the emulation\nvoid S9xMovieInit (void);\nvoid S9xMovieShutdown (void);\nvoid S9xMovieUpdate (bool a = true);\nvoid S9xMovieUpdateOnReset (void);\nvoid S9xUpdateFrameCounter (int o = 0);\nvoid S9xMovieFreeze (uint8 **, uint32 *);\nint S9xMovieUnfreeze (uint8 *, uint32);\n\n// accessor functions\nbool8 S9xMovieActive (void);\nbool8 S9xMoviePlaying (void);\nbool8 S9xMovieRecording (void);\nbool8 S9xMovieReadOnly (void);\nuint8 S9xMovieControllers (void);\nuint32 S9xMovieGetId (void);\nuint32 S9xMovieGetLength (void);\nuint32 S9xMovieGetFrameCounter (void);\n\nuint16 MovieGetJoypad (int);\nvoid MovieSetJoypad (int, uint16);\nbool MovieGetMouse (int, uint8 d[MOUSE_DATA_SIZE]);\nvoid MovieSetMouse (int, uint8 d[MOUSE_DATA_SIZE], bool);\nbool MovieGetScope (int, uint8 d[SCOPE_DATA_SIZE]);\nvoid MovieSetScope (int, uint8 d[SCOPE_DATA_SIZE]);\nbool MovieGetJustifier (int, uint8 d[JUSTIFIER_DATA_SIZE]);\nvoid MovieSetJustifier (int, uint8 d[JUSTIFIER_DATA_SIZE]);\n\n#endif\n"
        },
        {
          "name": "msu1.cpp",
          "type": "blob",
          "size": 8.6669921875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"display.h\"\n#include \"msu1.h\"\n#include \"apu/resampler.h\"\n#include \"apu/bapu/dsp/blargg_endian.h\"\n#include <fstream>\n#include <sys/stat.h>\n\nSTREAM dataStream = NULL;\nSTREAM audioStream = NULL;\nuint32 audioLoopPos;\nsize_t partial_frames;\n\n// Sample buffer\nstatic Resampler *msu_resampler = NULL;\n\n#ifdef UNZIP_SUPPORT\nstatic int unzFindExtension(unzFile &file, const char *ext, bool restart = TRUE, bool print = TRUE, bool allowExact = FALSE)\n{\n    unz_file_info\tinfo;\n    int\t\t\t\tport, l = strlen(ext), e = allowExact ? 0 : 1;\n\n    if (restart)\n        port = unzGoToFirstFile(file);\n    else\n        port = unzGoToNextFile(file);\n\n    while (port == UNZ_OK)\n    {\n        int\t\tlen;\n        char\tname[132];\n\n        unzGetCurrentFileInfo(file, &info, name, 128, NULL, 0, NULL, 0);\n        len = strlen(name);\n\n        if (len >= l + e && strcasecmp(name + len - l, ext) == 0 && unzOpenCurrentFile(file) == UNZ_OK)\n        {\n            if (print)\n                printf(\"Using msu file %s\", name);\n\n            return (port);\n        }\n\n        port = unzGoToNextFile(file);\n    }\n\n    return (port);\n}\n#endif\n\nSTREAM S9xMSU1OpenFile(const char *msu_ext, bool skip_unpacked)\n{\n    auto filename = S9xGetFilename(msu_ext, ROMFILENAME_DIR);\n\tSTREAM file = 0;\n\n\tif (!skip_unpacked)\n\t{\n\t\tfile = OPEN_STREAM(filename.c_str(), \"rb\");\n\t\tif (file)\n\t\t\tprintf(\"Using msu file %s.\\n\", filename.c_str());\n\t}\n\n#ifdef UNZIP_SUPPORT\n    // look for msu1 pack file in the rom or patch dir if msu data file not found in rom dir\n    if (!file)\n    {\n        auto zip_filename = S9xGetFilename(\".msu1\", ROMFILENAME_DIR);\n\t\tunzFile\tunzFile = unzOpen(zip_filename.c_str());\n\n\t\tif (!unzFile)\n\t\t{\n\t\t\tzip_filename = S9xGetFilename(\".msu1\", PATCH_DIR);\n\t\t\tunzFile = unzOpen(zip_filename.c_str());\n\t\t}\n\n        if (unzFile)\n        {\n            int\tport = unzFindExtension(unzFile, msu_ext, true, true, true);\n            if (port == UNZ_OK)\n            {\n                file = new unzStream(unzFile);\n            }\n            else\n                unzClose(unzFile);\n        }\n    }\n#endif\n\n    return file;\n}\n\nstatic void AudioClose()\n{\n\tif (audioStream)\n\t{\n\t\tCLOSE_STREAM(audioStream);\n\t\taudioStream = NULL;\n\t}\n}\n\nstatic bool AudioOpen()\n{\n\tMSU1.MSU1_STATUS |= AudioError;\n\n\tAudioClose();\n\n\tstd::string extension = \"-\" + std::to_string(MSU1.MSU1_CURRENT_TRACK) + \".pcm\";\n\n    audioStream = S9xMSU1OpenFile(extension.c_str());\n\tif (audioStream)\n\t{\n\t\tif (GETC_STREAM(audioStream) != 'M')\n\t\t\treturn false;\n\t\tif (GETC_STREAM(audioStream) != 'S')\n\t\t\treturn false;\n\t\tif (GETC_STREAM(audioStream) != 'U')\n\t\t\treturn false;\n\t\tif (GETC_STREAM(audioStream) != '1')\n\t\t\treturn false;\n\n        READ_STREAM((char *)&audioLoopPos, 4, audioStream);\n\t\taudioLoopPos = GET_LE32(&audioLoopPos);\n\t\taudioLoopPos <<= 2;\n\t\taudioLoopPos += 8;\n\n        MSU1.MSU1_AUDIO_POS = 8;\n\n\t\tMSU1.MSU1_STATUS &= ~AudioError;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void DataClose()\n{\n\tif (dataStream)\n\t{\n\t\tCLOSE_STREAM(dataStream);\n\t\tdataStream = NULL;\n\t}\n}\n\nstatic bool DataOpen()\n{\n\tDataClose();\n\n    dataStream = S9xMSU1OpenFile(\".msu\");\n\n\tif(!dataStream)\n\t\tdataStream = S9xMSU1OpenFile(\"msu1.rom\");\n\n\treturn dataStream != NULL;\n}\n\nvoid S9xResetMSU(void)\n{\n\tMSU1.MSU1_STATUS\t\t= 0;\n\tMSU1.MSU1_DATA_SEEK\t\t= 0;\n\tMSU1.MSU1_DATA_POS\t\t= 0;\n\tMSU1.MSU1_TRACK_SEEK\t= 0;\n\tMSU1.MSU1_CURRENT_TRACK = 0;\n\tMSU1.MSU1_RESUME_TRACK\t= 0;\n\tMSU1.MSU1_VOLUME\t\t= 0;\n\tMSU1.MSU1_CONTROL\t\t= 0;\n\tMSU1.MSU1_AUDIO_POS\t\t= 0;\n\tMSU1.MSU1_RESUME_POS\t= 0;\n\n\tif (msu_resampler)\n\t\tmsu_resampler->clear();\n\n\tpartial_frames = 0;\n\n\tDataClose();\n\n\tAudioClose();\n\n\tSettings.MSU1 = S9xMSU1ROMExists();\n}\n\nvoid S9xMSU1Init(void)\n{\n\tDataOpen();\n}\n\nvoid S9xMSU1DeInit(void)\n{\n\tDataClose();\n\tAudioClose();\n}\n\nbool S9xMSU1ROMExists(void)\n{\n    STREAM s = S9xMSU1OpenFile(\".msu\");\n\tif (s)\n\t{\n\t\tCLOSE_STREAM(s);\n\t\treturn true;\n\t}\n#ifdef UNZIP_SUPPORT\n\n\tif (splitpath(Memory.ROMFilename).ext_is(\".msu1\"))\n\t\treturn true;\n\n\tunzFile unzFile = unzOpen(S9xGetFilename(\".msu1\", ROMFILENAME_DIR).c_str());\n\n\tif(!unzFile)\n\t\tunzFile = unzOpen(S9xGetFilename(\".msu1\", PATCH_DIR).c_str());\n\n\tif (unzFile)\n\t{\n\t\tunzClose(unzFile);\n\t\treturn true;\n\t}\n#endif\n    return false;\n}\n\nvoid S9xMSU1Generate(size_t sample_count)\n{\n\tpartial_frames += 4410 * (sample_count / 2);\n\n\twhile (partial_frames >= 3204)\n\t{\n\t\tif (MSU1.MSU1_STATUS & AudioPlaying && audioStream)\n\t\t{\n\t\t\tint32 sample;\n\t\t\tint16* left = (int16*)&sample;\n\t\t\tint16* right = left + 1;\n\n\t\t\tint bytes_read = READ_STREAM((char *)&sample, 4, audioStream);\n\t\t\tif (bytes_read == 4)\n\t\t\t{\n\t\t\t\t*left = ((int32)(int16)GET_LE16(left) * MSU1.MSU1_VOLUME / 255);\n\t\t\t\t*right = ((int32)(int16)GET_LE16(right) * MSU1.MSU1_VOLUME / 255);\n\n\t\t\t\tmsu_resampler->push_sample(*left, *right);\n\t\t\t\tMSU1.MSU1_AUDIO_POS += 4;\n\t\t\t\tpartial_frames -= 3204;\n\t\t\t}\n\t\t\telse\n\t\t\tif (bytes_read >= 0)\n\t\t\t{\n\t\t\t\tif (MSU1.MSU1_STATUS & AudioRepeating)\n\t\t\t\t{\n\t\t\t\t\tif (audioLoopPos < MSU1.MSU1_AUDIO_POS)\n\t\t\t\t\t{\n\t\t\t\t\t\tMSU1.MSU1_AUDIO_POS = audioLoopPos;\n\t\t\t\t\t}\n\t\t\t\t\telse // if the loop point is invalid, revert to start\n\t\t\t\t\t{\n\t\t\t\t\t\tMSU1.MSU1_AUDIO_POS = 8;\n\t\t\t\t\t}\n\t\t\t\t\tREVERT_STREAM(audioStream, MSU1.MSU1_AUDIO_POS, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tMSU1.MSU1_STATUS &= ~(AudioPlaying | AudioRepeating);\n\t\t\t\t\tREVERT_STREAM(audioStream, 8, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMSU1.MSU1_STATUS &= ~(AudioPlaying | AudioRepeating);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMSU1.MSU1_STATUS &= ~(AudioPlaying | AudioRepeating);\n\t\t\tpartial_frames -= 3204;\n\t\t\tmsu_resampler->push_sample(0, 0);\n\t\t}\n\t}\n}\n\n\nuint8 S9xMSU1ReadPort(uint8 port)\n{\n\tswitch (port)\n\t{\n\tcase 0:\n\t\treturn MSU1.MSU1_STATUS | MSU1_REVISION;\n\tcase 1:\n    {\n        if (MSU1.MSU1_STATUS & DataBusy)\n            return 0;\n        if (!dataStream)\n            return 0;\n        int data = GETC_STREAM(dataStream);\n        if (data >= 0)\n        {\n            MSU1.MSU1_DATA_POS++;\n            return data;\n        }\n        return 0;\n    }\n\tcase 2:\n\t\treturn 'S';\n\tcase 3:\n\t\treturn '-';\n\tcase 4:\n\t\treturn 'M';\n\tcase 5:\n\t\treturn 'S';\n\tcase 6:\n\t\treturn 'U';\n\tcase 7:\n\t\treturn '1';\n\t}\n\n\treturn 0;\n}\n\n\nvoid S9xMSU1WritePort(uint8 port, uint8 byte)\n{\n\tswitch (port)\n\t{\n\tcase 0:\n\t\tMSU1.MSU1_DATA_SEEK &= 0xFFFFFF00;\n\t\tMSU1.MSU1_DATA_SEEK |= byte << 0;\n\t\tbreak;\n\tcase 1:\n\t\tMSU1.MSU1_DATA_SEEK &= 0xFFFF00FF;\n\t\tMSU1.MSU1_DATA_SEEK |= byte << 8;\n\t\tbreak;\n\tcase 2:\n\t\tMSU1.MSU1_DATA_SEEK &= 0xFF00FFFF;\n\t\tMSU1.MSU1_DATA_SEEK |= byte << 16;\n\t\tbreak;\n\tcase 3:\n\t\tMSU1.MSU1_DATA_SEEK &= 0x00FFFFFF;\n\t\tMSU1.MSU1_DATA_SEEK |= byte << 24;\n\t\tMSU1.MSU1_DATA_POS = MSU1.MSU1_DATA_SEEK;\n        if (dataStream)\n        {\n            REVERT_STREAM(dataStream, MSU1.MSU1_DATA_POS, 0);\n        }\n\t\tbreak;\n\tcase 4:\n\t\tMSU1.MSU1_TRACK_SEEK &= 0xFF00;\n\t\tMSU1.MSU1_TRACK_SEEK |= byte;\n\t\tbreak;\n\tcase 5:\n\t\tMSU1.MSU1_TRACK_SEEK &= 0x00FF;\n\t\tMSU1.MSU1_TRACK_SEEK |= (byte << 8);\n\t\tMSU1.MSU1_CURRENT_TRACK = MSU1.MSU1_TRACK_SEEK;\n\n\t\tMSU1.MSU1_STATUS &= ~AudioPlaying;\n\t\tMSU1.MSU1_STATUS &= ~AudioRepeating;\n\n\t\tif (AudioOpen())\n\t\t{\n\t\t\tif (MSU1.MSU1_CURRENT_TRACK == MSU1.MSU1_RESUME_TRACK)\n\t\t\t{\n\t\t\t\tMSU1.MSU1_AUDIO_POS = MSU1.MSU1_RESUME_POS;\n\t\t\t\tMSU1.MSU1_RESUME_POS = 0;\n\t\t\t\tMSU1.MSU1_RESUME_TRACK = ~0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMSU1.MSU1_AUDIO_POS = 8;\n\t\t\t}\n\n            REVERT_STREAM(audioStream, MSU1.MSU1_AUDIO_POS, 0);\n\t\t}\n\t\tbreak;\n\tcase 6:\n\t\tMSU1.MSU1_VOLUME = byte;\n\t\tbreak;\n\tcase 7:\n\t\tif (MSU1.MSU1_STATUS & (AudioBusy | AudioError))\n\t\t\tbreak;\n\n\t\tMSU1.MSU1_STATUS = (MSU1.MSU1_STATUS & ~0x30) | ((byte & 0x03) << 4);\n\n\t\tif ((byte & (Play | Resume)) == Resume)\n\t\t{\n\t\t\tMSU1.MSU1_RESUME_TRACK = MSU1.MSU1_CURRENT_TRACK;\n\t\t\tMSU1.MSU1_RESUME_POS = MSU1.MSU1_AUDIO_POS;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nsize_t S9xMSU1Samples(void)\n{\n\treturn msu_resampler->space_filled();\n}\n\nvoid S9xMSU1SetOutput(Resampler *resampler)\n{\n\tmsu_resampler = resampler;\n}\n\nvoid S9xMSU1PostLoadState(void)\n{\n\tif (DataOpen())\n\t{\n        REVERT_STREAM(dataStream, MSU1.MSU1_DATA_POS, 0);\n\t}\n\n\tif (MSU1.MSU1_STATUS & AudioPlaying)\n\t{\n\t\tuint32 savedPosition = MSU1.MSU1_AUDIO_POS;\n\n\t\tif (AudioOpen())\n\t\t{\n            REVERT_STREAM(audioStream, 4, 0);\n            READ_STREAM((char *)&audioLoopPos, 4, audioStream);\n\t\t\taudioLoopPos = GET_LE32(&audioLoopPos);\n\t\t\taudioLoopPos <<= 2;\n\t\t\taudioLoopPos += 8;\n\n\t\t\tMSU1.MSU1_AUDIO_POS = savedPosition;\n            REVERT_STREAM(audioStream, MSU1.MSU1_AUDIO_POS, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMSU1.MSU1_STATUS &= ~(AudioPlaying | AudioRepeating);\n\t\t\tMSU1.MSU1_STATUS |= AudioError;\n\t\t}\n\t}\n\n\tif (msu_resampler)\n\t\tmsu_resampler->clear();\n\n\tpartial_frames = 0;\n}\n"
        },
        {
          "name": "msu1.h",
          "type": "blob",
          "size": 1.42578125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _MSU1_H_\n#define _MSU1_H_\n#include \"snes9x.h\"\n\n#define MSU1_REVISION 0x02\n\nstruct SMSU1\n{\n\tuint8\tMSU1_STATUS;\n\tuint32\tMSU1_DATA_SEEK;\n\tuint32\tMSU1_DATA_POS;\n\tuint16\tMSU1_TRACK_SEEK;\n\tuint16\tMSU1_CURRENT_TRACK;\n\tuint32\tMSU1_RESUME_TRACK;\n\tuint8\tMSU1_VOLUME;\n\tuint8\tMSU1_CONTROL;\n\tuint32\tMSU1_AUDIO_POS;\n\tuint32\tMSU1_RESUME_POS;\n};\n\nenum SMSU1_FLAG {\n\tRevision\t\t= 0x07,\t// bitmask, not the actual version number\n\tAudioError\t\t= 0x08,\n\tAudioPlaying\t\t= 0x10,\n\tAudioRepeating\t\t= 0x20,\n\tAudioBusy\t\t= 0x40,\n\tDataBusy\t\t= 0x80\n};\n\nenum SMSU1_CMD {\n\tPlay\t\t\t= 0x01,\n\tRepeat\t\t\t= 0x02,\n\tResume\t\t\t= 0x04\n};\n\nextern struct SMSU1\tMSU1;\n\nvoid S9xResetMSU(void);\nvoid S9xMSU1Init(void);\nvoid S9xMSU1DeInit(void);\nbool S9xMSU1ROMExists(void);\nSTREAM S9xMSU1OpenFile(const char *msu_ext, bool skip_unpacked = FALSE);\nvoid S9xMSU1Init(void);\nvoid S9xMSU1Generate(size_t sample_count);\nuint8 S9xMSU1ReadPort(uint8 port);\nvoid S9xMSU1WritePort(uint8 port, uint8 byte);\nsize_t S9xMSU1Samples(void);\nclass Resampler;\nvoid S9xMSU1SetOutput(Resampler *resampler);\nvoid S9xMSU1PostLoadState(void);\n\n#endif\n"
        },
        {
          "name": "netplay.cpp",
          "type": "blob",
          "size": 27.595703125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifdef NETPLAY_SUPPORT\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <memory.h>\n#include <sys/types.h>\n\n#include \"snes9x.h\"\n#include \"controls.h\"\n\n#ifdef __WIN32__\n\t#include <winsock.h>\n\t#include <process.h>\n\t#include \"win32/wsnes9x.h\"\n\n\t#define ioctl ioctlsocket\n\t#define close(h) if(h){closesocket(h);}\n\t#define read(a,b,c) recv(a, b, c, 0)\n\t#define write(a,b,c) send(a, b, c, 0)\n#else\n\t#include <unistd.h>\n\t#include <sys/time.h>\n\t#include <sys/types.h>\n\t#include <sys/stat.h>\n\n\t#include <netdb.h>\n\t#include <sys/ioctl.h>\n\t#include <sys/socket.h>\n\t#include <sys/param.h>\n\t#include <netinet/in.h>\n\t#include <arpa/inet.h>\n\n\t#ifdef __SVR4\n\t\t#include <sys/stropts.h>\n\t#endif\n#endif\n\n#ifdef USE_THREADS\n#include <pthread.h>\n#include <sched.h>\n#include <semaphore.h>\n#endif\n\n#include \"memmap.h\"\n#include \"netplay.h\"\n#include \"snapshot.h\"\n#include \"display.h\"\n\nvoid S9xNPClientLoop (void *);\nbool8 S9xNPLoadROM (uint32 len);\nbool8 S9xNPLoadROMDialog (const char *);\nbool8 S9xNPGetROMImage (uint32 len);\nvoid S9xNPGetSRAMData (uint32 len);\nvoid S9xNPGetFreezeFile (uint32 len);\n\nunsigned long START = 0;\n\nbool8 S9xNPConnect ();\n\nbool8 S9xNPConnectToServer (const char *hostname, int port,\n                            const char *rom_name)\n{\n    if (!S9xNPInitialise ())\n        return (FALSE);\n\n    S9xNPDisconnect ();\n\n    NetPlay.MySequenceNum = 0;\n    NetPlay.ServerSequenceNum = 0;\n    NetPlay.Connected = FALSE;\n    NetPlay.Abort = FALSE;\n    NetPlay.Player = 0;\n    NetPlay.Paused = FALSE;\n    NetPlay.PercentageComplete = 0;\n    NetPlay.Socket = 0;\n    if (NetPlay.ServerHostName)\n        free ((char *) NetPlay.ServerHostName);\n    NetPlay.ServerHostName = strdup (hostname);\n    if (NetPlay.ROMName)\n        free ((char *) NetPlay.ROMName);\n    NetPlay.ROMName = strdup (rom_name);\n    NetPlay.Port = port;\n    NetPlay.PendingWait4Sync = FALSE;\n\n#ifdef __WIN32__\n    if (GUI.ClientSemaphore == NULL)\n        GUI.ClientSemaphore = CreateSemaphore (NULL, 0, NP_JOYPAD_HIST_SIZE, NULL);\n\n    if (NetPlay.ReplyEvent == NULL)\n        NetPlay.ReplyEvent = CreateEvent (NULL, FALSE, FALSE, NULL);\n\n    _beginthread (S9xNPClientLoop, 0, NULL);\n\n    return (TRUE);\n#endif\n\n    return S9xNPConnect();\n}\n\nbool8 S9xNPConnect ()\n{\n    struct sockaddr_in address;\n    struct hostent *hostinfo;\n    unsigned int addr;\n\n    address.sin_family = AF_INET;\n    address.sin_port = htons (NetPlay.Port);\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Looking up server's hostname (%s) @%ld\\n\", NetPlay.ServerHostName, S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"Looking up server's hostname...\");\n    if ((int) (addr = inet_addr (NetPlay.ServerHostName)) == -1)\n    {\n\tif ((hostinfo = gethostbyname (NetPlay.ServerHostName)))\n\t{\n\t    memcpy ((char *)&address.sin_addr, hostinfo->h_addr,\n\t\t    hostinfo->h_length);\n\t}\n\telse\n\t{\n            S9xNPSetError (\"\\\nUnable to look up server's IP address from hostname.\\n\\n\\\nUnknown hostname or may be your nameserver isn't set\\n\\\nup correctly?\");\n\t    return (FALSE);\n\t}\n    }\n    else\n    {\n\tmemcpy ((char *)&address.sin_addr, &addr, sizeof (addr));\n    }\n\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Creating socket @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"Creating network socket...\");\n    if ((NetPlay.Socket = socket (AF_INET, SOCK_STREAM, 0)) < 0)\n    {\n        S9xNPSetError (\"Creating network socket failed.\");\n\treturn (FALSE);\n    }\n\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Trying to connect to server @%ld...\\n\", S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"Trying to connect to Snes9x server...\");\n\n    if (connect (NetPlay.Socket, (struct sockaddr *) &address, sizeof (address)) < 0)\n    {\n        char buf [100];\n#ifdef __WIN32__\n        if (WSAGetLastError () == WSAECONNREFUSED)\n#else\n\tif (errno == ECONNREFUSED)\n#endif\n        {\n            S9xNPSetError (\"\\\nConnection to remote server socket refused:\\n\\n\\\nIs there actually a Snes9x NetPlay server running\\n\\\non the remote machine on this port?\");\n        }\n        else\n        {\n            sprintf (buf, \"Connection to server failed with error number %d\",\n#ifdef __WIN32__\n                     WSAGetLastError ()\n#else\n\t\t     errno\n#endif\n\t\t     );\n            S9xNPSetError(buf);\n            S9xNPDisconnect ();\n        }\n\treturn (FALSE);\n    }\n    NetPlay.Connected = TRUE;\n\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Sending 'HELLO' message @%ld...\\n\", S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"Sending 'HELLO' message...\");\n    /* Send the server a HELLO packet*/\n    int len = 7 + 4 + strlen (NetPlay.ROMName) + 1;\n    uint8 *tmp = new uint8 [len];\n    uint8 *ptr = tmp;\n\n    *ptr++ = NP_CLNT_MAGIC;\n    *ptr++ = NetPlay.MySequenceNum++;\n    *ptr++ = NP_CLNT_HELLO;\n    WRITE_LONG (ptr, len);\n    ptr += 4;\n#ifdef __WIN32__\n    uint32 ft = Settings.FrameTime;\n\n    WRITE_LONG (ptr, ft);\n#else\n    WRITE_LONG (ptr, Settings.FrameTime);\n#endif\n    ptr += 4;\n    strcpy ((char *) ptr, NetPlay.ROMName);\n\n    if (!S9xNPSendData (NetPlay.Socket, tmp, len))\n    {\n        S9xNPSetError (\"Sending 'HELLO' message failed.\");\n\tS9xNPDisconnect ();\n\tdelete[] tmp;\n\treturn (FALSE);\n    }\n    delete[] tmp;\n\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Waiting for 'WELCOME' reply from server @%ld...\\n\", S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"Waiting for 'HELLO' reply from server...\");\n\n    uint8 header [7];\n\n    if (!S9xNPGetData (NetPlay.Socket, header, 7) ||\n        header [0] != NP_SERV_MAGIC || header [1] != 0 ||\n        (header [2] & 0x1f) != NP_SERV_HELLO)\n    {\n        S9xNPSetError (\"Error in 'HELLO' reply packet received from server.\");\n\tS9xNPDisconnect ();\n\treturn (FALSE);\n    }\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Got 'WELCOME' reply @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    len = READ_LONG (&header [3]);\n    if (len > 256)\n    {\n        S9xNPSetError (\"Error in 'HELLO' reply packet received from server.\");\n\tS9xNPDisconnect ();\n\treturn (FALSE);\n    }\n    uint8 *data = new uint8 [len];\n    if (!S9xNPGetData (NetPlay.Socket, data, len - 7))\n    {\n        S9xNPSetError (\"Error in 'HELLO' reply packet received from server.\");\n        delete[] data;\n\tS9xNPDisconnect ();\n\treturn (FALSE);\n    }\n\n    if (data [0] != NP_VERSION)\n    {\n        S9xNPSetError (\"\\\nThe Snes9x NetPlay server implements a different\\n\\\nversion of the protocol. Disconnecting.\");\n        delete[] data;\n\tS9xNPDisconnect ();\n        return (FALSE);\n    }\n\n    NetPlay.FrameCount = READ_LONG (&data [2]);\n\n    if (!(header [2] & 0x80) &&\n        strcmp ((char *) data + 4 + 2, NetPlay.ROMName) != 0)\n    {\n        if (!S9xNPLoadROMDialog ((char *) data + 4 + 2))\n        {\n            delete[] data;\n            S9xNPDisconnect ();\n            return (FALSE);\n        }\n    }\n    NetPlay.Player = data [1];\n    delete[] data;\n\n    NetPlay.PendingWait4Sync = TRUE;\n    Settings.NetPlay = TRUE;\n    S9xNPResetJoypadReadPos ();\n    NetPlay.ServerSequenceNum = 1;\n\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Sending 'READY' to server @%ld...\\n\", S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"Sending 'READY' to the server...\");\n\n    return (S9xNPSendReady ((header [2] & 0x80) ?\n                            NP_CLNT_WAITING_FOR_ROM_IMAGE :\n                            NP_CLNT_READY));\n}\n\nbool8 S9xNPSendReady (uint8 op)\n{\n    uint8 ready [7];\n    uint8 *ptr = ready;\n    *ptr++ = NP_CLNT_MAGIC;\n    *ptr++ = NetPlay.MySequenceNum++;\n    *ptr++ = op;\n    WRITE_LONG (ptr, 7);\n    ptr += 4;\n\n    if (!S9xNPSendData (NetPlay.Socket, ready, 7))\n    {\n\tS9xNPDisconnect ();\n        S9xNPSetError (\"Sending 'READY' message failed.\");\n\treturn (FALSE);\n    }\n\n    return (TRUE);\n}\n\nbool8 S9xNPSendPause (bool8 paused)\n{\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Pause - %s @%ld\\n\", paused ? \"YES\" : \"NO\", S9xGetMilliTime () - START);\n#endif\n    uint8 pause [7];\n    uint8 *ptr = pause;\n    *ptr++ = NP_CLNT_MAGIC;\n    *ptr++ = NetPlay.MySequenceNum++;\n    *ptr++ = NP_CLNT_PAUSE | (paused ? 0x80 : 0);\n    WRITE_LONG (ptr, 7);\n    ptr += 4;\n\n    if (!S9xNPSendData (NetPlay.Socket, pause, 7))\n    {\n        S9xNPSetError (\"Sending 'PAUSE' message failed.\");\n\tS9xNPDisconnect ();\n\treturn (FALSE);\n    }\n\n    return (TRUE);\n}\n\n#ifdef __WIN32__\nvoid S9xNPClientLoop (void *)\n{\n    NetPlay.Waiting4EmulationThread = FALSE;\n\n    if (S9xNPConnect ())\n    {\n        S9xClearPause (PAUSE_NETPLAY_CONNECT);\n        while (NetPlay.Connected)\n        {\n            if (S9xNPWaitForHeartBeat ())\n            {\n                LONG prev;\n                if (!ReleaseSemaphore (GUI.ClientSemaphore, 1, &prev))\n                {\n#ifdef NP_DEBUG\n                    printf (\"CLIENT: ReleaseSemaphore failed - already hit max count (%d) %ld\\n\", NP_JOYPAD_HIST_SIZE, S9xGetMilliTime () - START);\n#endif\n                    S9xNPSetWarning (\"NetPlay: Client may be out of sync with server.\");\n                }\n                else\n                {\n                    if (!NetPlay.Waiting4EmulationThread &&\n                        prev == (int) NetPlay.MaxBehindFrameCount)\n                    {\n                        NetPlay.Waiting4EmulationThread = TRUE;\n                        S9xNPSendPause (TRUE);\n                    }\n                }\n            }\n            else\n                S9xNPDisconnect ();\n        }\n    }\n    else\n    {\n        S9xClearPause (PAUSE_NETPLAY_CONNECT);\n    }\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Client thread exiting @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n}\n#endif\n\nbool8 S9xNPCheckForHeartBeat (uint32 time_msec)\n{\n    fd_set read_fds;\n    struct timeval timeout;\n    int res;\n    int i;\n\n    int max_fd = NetPlay.Socket;\n\n    FD_ZERO (&read_fds);\n    FD_SET (NetPlay.Socket, &read_fds);\n\n    timeout.tv_sec = 0;\n    timeout.tv_usec = time_msec * 1000;\n    res = select (max_fd + 1, &read_fds, NULL, NULL, &timeout);\n\n    i = (res > 0 && FD_ISSET(NetPlay.Socket, &read_fds));\n\n#if defined(NP_DEBUG) && NP_DEBUG >= 4\n    printf (\"CLIENT: S9xCheckForHeartBeat %s @%ld\\n\", (i?\"successful\":\"still waiting\"), S9xGetMilliTime () - START);\n#endif\n\n    return i;\n}\n\nbool8 S9xNPWaitForHeartBeatDelay (uint32 time_msec)\n{\n    if (!S9xNPCheckForHeartBeat(time_msec))\n        return FALSE;\n\n    if (!S9xNPWaitForHeartBeat())\n    {\n        S9xNPDisconnect();\n\treturn FALSE;\n    }\n\n    return TRUE;\n}\n\nbool8 S9xNPWaitForHeartBeat ()\n{\n    uint8 header [3 + 4 + 4 * 5];\n\n    while (S9xNPGetData (NetPlay.Socket, header, 3 + 4))\n    {\n        if (header [0] != NP_SERV_MAGIC)\n        {\n            S9xNPSetError (\"Bad magic value from server while waiting for heart-beat message\\n\");\n            S9xNPDisconnect ();\n            return (FALSE);\n        }\n        if (header [1] != NetPlay.ServerSequenceNum)\n        {\n            char buf [200];\n            sprintf (buf, \"Unexpected message sequence number from server, expected %d, got %d\\n\", NetPlay.ServerSequenceNum, header [1]);\n            S9xNPSetWarning (buf);\n            NetPlay.ServerSequenceNum = header [1] + 1;\n        }\n        else\n            NetPlay.ServerSequenceNum++;\n\n        if ((header [2] & 0x1f) == NP_SERV_JOYPAD)\n        {\n            // Top 2 bits + 1 of opcode is joypad data count.\n            int num = (header [2] >> 6) + 1;\n\n            if (num)\n            {\n                if (!S9xNPGetData (NetPlay.Socket, header + 3 + 4, num * 4))\n                {\n                    S9xNPSetError (\"Error while receiving 'JOYPAD' message.\");\n                    S9xNPDisconnect ();\n                    return (FALSE);\n                }\n            }\n            NetPlay.Frame [NetPlay.JoypadWriteInd] = READ_LONG (&header [3]);\n\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < num; i++)\n                NetPlay.Joypads [NetPlay.JoypadWriteInd][i] = READ_LONG (&header [3 + 4 + i * sizeof (uint32)]);\n\n\t\t\tfor (i = 0; i < NP_MAX_CLIENTS; i++)\n\t\t\t\tNetPlay.JoypadsReady [NetPlay.JoypadWriteInd][i] = TRUE;\n\n\t\t\tNetPlay.Paused = (header [2] & 0x20) != 0;\n\n            NetPlay.JoypadWriteInd = (NetPlay.JoypadWriteInd + 1) % NP_JOYPAD_HIST_SIZE;\n\n            if (NetPlay.JoypadWriteInd != (NetPlay.JoypadReadInd + 1) % NP_JOYPAD_HIST_SIZE)\n            {\n                //printf (\"(%d)\", (NetPlay.JoypadWriteInd - NetPlay.JoypadReadInd) % NP_JOYPAD_HIST_SIZE); fflush (stdout);\n            }\n//printf (\"CLIENT: HB: @%d\\n\", S9xGetMilliTime () - START);\n            return (TRUE);\n        }\n        else\n        {\n            uint32 len = READ_LONG (&header [3]);\n\t    switch (header [2] & 0x1f)\n\t    {\n\t    case NP_SERV_RESET:\n#ifdef NP_DEBUG\n                printf (\"CLIENT: RESET received @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n                S9xNPDiscardHeartbeats ();\n\t\tS9xReset ();\n                NetPlay.FrameCount = READ_LONG (&header [3]);\n                S9xNPResetJoypadReadPos ();\n                S9xNPSendReady ();\n                break;\n\t    case NP_SERV_PAUSE:\n                NetPlay.Paused = (header [2] & 0x20) != 0;\n\t\t\t\tif (NetPlay.Paused)\n\t\t\t\t\tS9xNPSetWarning(\"CLIENT: Server has paused.\");\n\t\t\t\telse\n\t\t\t\t\tS9xNPSetWarning(\"CLIENT: Server has resumed.\");\n                break;\n\t\tcase NP_SERV_JOYPAD_SWAP:\n#ifdef NP_DEBUG\n\t\t\tprintf(\"CLIENT: Joypad Swap received @%ld\\n\", S9xGetMilliTime() - START);\n#endif\n\t\t\tS9xApplyCommand(S9xGetCommandT(\"SwapJoypads\"), 1, 1);\n\t\t\tbreak;\n        case NP_SERV_LOAD_ROM:\n#ifdef NP_DEBUG\n                printf (\"CLIENT: LOAD_ROM received @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n                S9xNPDiscardHeartbeats ();\n                if (S9xNPLoadROM (len - 7))\n                    S9xNPSendReady (NP_CLNT_LOADED_ROM);\n                break;\n            case NP_SERV_ROM_IMAGE:\n#ifdef NP_DEBUG\n                printf (\"CLIENT: ROM_IMAGE received @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n                S9xNPDiscardHeartbeats ();\n                if (S9xNPGetROMImage (len - 7))\n                    S9xNPSendReady (NP_CLNT_RECEIVED_ROM_IMAGE);\n                break;\n            case NP_SERV_SRAM_DATA:\n#ifdef NP_DEBUG\n                printf (\"CLIENT: SRAM_DATA received @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n                S9xNPDiscardHeartbeats ();\n                S9xNPGetSRAMData (len - 7);\n                break;\n            case NP_SERV_FREEZE_FILE:\n#ifdef NP_DEBUG\n                printf (\"CLIENT: FREEZE_FILE received @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n                S9xNPDiscardHeartbeats ();\n                S9xNPGetFreezeFile (len - 7);\n                S9xNPResetJoypadReadPos ();\n                S9xNPSendReady ();\n                break;\n            default:\n#ifdef NP_DEBUG\n                printf (\"CLIENT: UNKNOWN received @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n                S9xNPDisconnect ();\n                return (FALSE);\n\t    }\n\t}\n    }\n\n    S9xNPDisconnect ();\n    return (FALSE);\n}\n\nbool8 S9xNPLoadROMDialog (const char *rom_name)\n{\n    NetPlay.Answer = FALSE;\n\n#ifdef __WIN32__\n    ResetEvent (NetPlay.ReplyEvent);\n\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Asking GUI thread to open ROM load dialog...\\n\");\n#endif\n\n    PostMessage (GUI.hWnd, WM_USER + 3, (WPARAM) rom_name, (LPARAM) rom_name);\n\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Waiting for reply from GUI thread...\\n\");\n#endif\n\n    WaitForSingleObject (NetPlay.ReplyEvent, INFINITE);\n\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Got reply from GUI thread (%d)\\n\", NetPlay.Answer);\n#endif\n\n#else\n\tNetPlay.Answer = TRUE;\n#endif\n\n    return (NetPlay.Answer);\n}\n\nbool8 S9xNPLoadROM (uint32 len)\n{\n    uint8 *data = new uint8 [len];\n\n    S9xNPSetAction (\"Receiving ROM name...\");\n    if (!S9xNPGetData (NetPlay.Socket, data, len))\n    {\n        S9xNPSetError (\"Error while receiving ROM name.\");\n        delete[] data;\n        S9xNPDisconnect ();\n        return (FALSE);\n    }\n\n    S9xNPSetAction (\"Opening LoadROM dialog...\");\n    if (!S9xNPLoadROMDialog ((char *) data))\n    {\n        S9xNPSetError (\"Disconnected from NetPlay server because you are playing a different game!\");\n        delete[] data;\n        S9xNPDisconnect ();\n        return (FALSE);\n    }\n    delete[] data;\n    return (TRUE);\n}\n\nbool8 S9xNPGetROMImage (uint32 len)\n{\n    uint8 rom_info [5];\n\n    S9xNPSetAction (\"Receiving ROM information...\");\n    if (!S9xNPGetData (NetPlay.Socket, rom_info, 5))\n    {\n        S9xNPSetError (\"Error while receiving ROM information.\");\n        S9xNPDisconnect ();\n        return (FALSE);\n    }\n    uint32 CalculatedSize = READ_LONG (&rom_info [1]);\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Hi-ROM: %s, Size: %04x\\n\", rom_info [0] ? \"Y\" : \"N\", CalculatedSize);\n#endif\n    if (CalculatedSize + 5 >= len ||\n        CalculatedSize >= CMemory::MAX_ROM_SIZE)\n    {\n        S9xNPSetError (\"Size error in ROM image data received from server.\");\n        S9xNPDisconnect ();\n        return (FALSE);\n    }\n\n    Memory.HiROM = rom_info [0];\n    Memory.LoROM = !Memory.HiROM;\n    Memory.HeaderCount = 0;\n    Memory.CalculatedSize = CalculatedSize;\n\n    // Load up ROM image\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Receiving ROM image @%ld...\\n\", S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"Receiving ROM image...\");\n    if (!S9xNPGetData (NetPlay.Socket, Memory.ROM, Memory.CalculatedSize))\n    {\n        S9xNPSetError (\"Error while receiving ROM image from server.\");\n        Settings.StopEmulation = TRUE;\n        S9xNPDisconnect ();\n        return (FALSE);\n    }\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Receiving ROM filename @%ld...\\n\", S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"Receiving ROM filename...\");\n    uint32 filename_len = len - Memory.CalculatedSize - 5;\n    if (filename_len > PATH_MAX ||\n        !S9xNPGetData (NetPlay.Socket, (uint8 *) Memory.ROMFilename.c_str(), filename_len))\n    {\n        S9xNPSetError (\"Error while receiving ROM filename from server.\");\n        S9xNPDisconnect ();\n        Settings.StopEmulation = TRUE;\n        return (FALSE);\n    }\n    Memory.InitROM ();\n    S9xReset ();\n    S9xNPResetJoypadReadPos ();\n    Settings.StopEmulation = FALSE;\n\n#ifdef __WIN32__\n    PostMessage (GUI.hWnd, WM_NULL, 0, 0);\n#endif\n\n    return (TRUE);\n}\n\nvoid S9xNPGetSRAMData (uint32 len)\n{\n    if (len > 0x70000)\n    {\n        S9xNPSetError (\"Length error in S-RAM data received from server.\");\n        S9xNPDisconnect ();\n        return;\n    }\n    S9xNPSetAction (\"Receiving S-RAM data...\");\n    if (len > 0 && !S9xNPGetData (NetPlay.Socket, Memory.SRAM, len))\n    {\n        S9xNPSetError (\"Error while receiving S-RAM data from server.\");\n        S9xNPDisconnect ();\n    }\n\tS9xNPSetAction (\"\", TRUE);\n}\n\nvoid S9xNPGetFreezeFile (uint32 len)\n{\n    uint8 frame_count [4];\n\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Receiving freeze file information @%ld...\\n\", S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"Receiving freeze file information...\");\n    if (!S9xNPGetData (NetPlay.Socket, frame_count, 4))\n    {\n        S9xNPSetError (\"Error while receiving freeze file information from server.\");\n        S9xNPDisconnect ();\n        return;\n    }\n    NetPlay.FrameCount = READ_LONG (frame_count);\n\n#ifdef NP_DEBUG\n    printf (\"CLIENT: Receiving freeze file @%ld...\\n\", S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"Receiving freeze file...\");\n    uint8 *data = new uint8 [len];\n    if (!S9xNPGetData (NetPlay.Socket, data, len - 4))\n    {\n        S9xNPSetError (\"Error while receiving freeze file from server.\");\n        S9xNPDisconnect ();\n        delete[] data;\n        return;\n    }\n\tS9xNPSetAction (\"\", TRUE);\n\n    //FIXME: Setting umask here wouldn't hurt.\n    FILE *file;\n#ifdef HAVE_MKSTEMP\n    int fd;\n    char fname[] = \"/tmp/snes9x_fztmpXXXXXX\";\n    if ((fd = mkstemp(fname)) >= 0)\n    {\n        if ((file = fdopen (fd, \"wb\")))\n#else\n    char fname [L_tmpnam];\n    if (tmpnam (fname))\n    {\n        if ((file = fopen (fname, \"wb\")))\n#endif\n        {\n            if (fwrite (data, 1, len, file) == len)\n            {\n                fclose(file);\n#ifndef __WIN32__\n\t\t/* We need .s96 extension, else .s96 is addded by unix code */\n                char buf[PATH_MAX +1 ];\n\n                strncpy(buf, fname, PATH_MAX);\n                strcat(buf, \".s96\");\n\n                rename(fname, buf);\n\n                if (!S9xUnfreezeGame (buf))\n#else\n                if (!S9xUnfreezeGame (fname))\n#endif\n                    S9xNPSetError (\"Unable to load freeze file just received.\");\n            } else {\n                S9xNPSetError (\"Failed to write to temporary freeze file.\");\n                fclose(file);\n            }\n        } else\n            S9xNPSetError (\"Failed to create temporary freeze file.\");\n        remove (fname);\n    } else\n        S9xNPSetError (\"Unable to get name for temporary freeze file.\");\n    delete[] data;\n}\n\nuint32 S9xNPGetJoypad (int which1)\n{\n    if (Settings.NetPlay && which1 < 8)\n\t{\n#ifdef NP_DEBUG\n\t\tif(!NetPlay.JoypadsReady [NetPlay.JoypadReadInd][which1])\n\t\t{\n            S9xNPSetWarning (\"Missing input from server!\");\n\t\t}\n#endif\n\t\tNetPlay.JoypadsReady [NetPlay.JoypadReadInd][which1] = FALSE;\n\n\t\treturn (NetPlay.Joypads [NetPlay.JoypadReadInd][which1]);\n\t}\n\n    return (0);\n}\n\nvoid S9xNPStepJoypadHistory ()\n{\n    if ((NetPlay.JoypadReadInd + 1) % NP_JOYPAD_HIST_SIZE != NetPlay.JoypadWriteInd)\n    {\n        NetPlay.JoypadReadInd = (NetPlay.JoypadReadInd + 1) % NP_JOYPAD_HIST_SIZE;\n        if (NetPlay.FrameCount != NetPlay.Frame [NetPlay.JoypadReadInd])\n        {\n            S9xNPSetWarning (\"This Snes9x session may be out of sync with the server.\");\n#ifdef NP_DEBUG\n            printf (\"*** CLIENT: client out of sync with server (%d, %d) @%ld\\n\", NetPlay.FrameCount, NetPlay.Frame [NetPlay.JoypadReadInd], S9xGetMilliTime () - START);\n#endif\n        }\n    }\n    else\n    {\n#ifdef NP_DEBUG\n        printf (\"*** CLIENT: S9xNPStepJoypadHistory NOT OK@%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    }\n}\n\n\nvoid S9xNPResetJoypadReadPos ()\n{\n#ifdef NP_DEBUG\n    printf (\"CLIENT: ResetJoyReadPos @%ld\\n\", S9xGetMilliTime () - START); fflush (stdout);\n#endif\n    NetPlay.JoypadWriteInd = 0;\n    NetPlay.JoypadReadInd = NP_JOYPAD_HIST_SIZE - 1;\n    for (int h = 0; h < NP_JOYPAD_HIST_SIZE; h++)\n        memset ((void *) &NetPlay.Joypads [h], 0, sizeof (NetPlay.Joypads [0]));\n    for (int h = 0; h < NP_JOYPAD_HIST_SIZE; h++)\n        memset ((void *) &NetPlay.JoypadsReady [h], 0, sizeof (NetPlay.JoypadsReady [0]));\n}\n\nbool8 S9xNPSendJoypadUpdate (uint32 joypad)\n{\n    uint8 data [7];\n    uint8 *ptr = data;\n\n    *ptr++ = NP_CLNT_MAGIC;\n    *ptr++ = NetPlay.MySequenceNum++;\n    *ptr++ = NP_CLNT_JOYPAD;\n\n    joypad |= 0x80000000;\n\n    WRITE_LONG (ptr, joypad);\n    if (!S9xNPSendData (NetPlay.Socket, data, 7))\n    {\n        S9xNPSetError (\"Error while sending joypad data server.\");\n\tS9xNPDisconnect ();\n\treturn (FALSE);\n    }\n    return (TRUE);\n}\n\nvoid S9xNPDisconnect ()\n{\n    close (NetPlay.Socket);\n    NetPlay.Socket = -1;\n    NetPlay.Connected = FALSE;\n    Settings.NetPlay = FALSE;\n}\n\nbool8 S9xNPSendData (int socket, const uint8 *data, int length)\n{\n    int len = length;\n    const uint8 *ptr = data;\n\n    NetPlay.PercentageComplete = 0;\n\n    do\n    {\n        if (NetPlay.Abort)\n            return (FALSE);\n\n        int num_bytes = len;\n\n        // Write the data in small chunks, allowing this thread to spot an\n        // abort request from another thread.\n        if (num_bytes > 512)\n            num_bytes = 512;\n\n\tint sent = write (socket, (char *) ptr, num_bytes);\n\tif (sent < 0)\n\t{\n\t    if (errno == EINTR\n#ifdef EAGAIN\n\t\t|| errno == EAGAIN\n#endif\n#ifdef EWOULDBLOCK\n\t\t|| errno == EWOULDBLOCK\n#endif\n\t\t)\n            {\n#ifdef NP_DEBUG\n                printf (\"CLIENT: EINTR, EAGAIN or EWOULDBLOCK while sending data @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n\t\tcontinue;\n            }\n\t    return (FALSE);\n\t}\n\telse\n\tif (sent == 0)\n\t    return (FALSE);\n\tlen -= sent;\n\tptr += sent;\n\n        NetPlay.PercentageComplete = (uint8) (((length - len) * 100) / length);\n    } while (len > 0);\n\n    return (TRUE);\n}\n\nbool8 S9xNPGetData (int socket, uint8 *data, int length)\n{\n    int len = length;\n    uint8 *ptr = data;\n    int chunk = length / 50;\n\n    if (chunk < 1024)\n        chunk = 1024;\n\n    NetPlay.PercentageComplete = 0;\n    do\n    {\n        if (NetPlay.Abort)\n            return (FALSE);\n\n        int num_bytes = len;\n\n        // Read the data in small chunks, allowing this thread to spot an\n        // abort request from another thread.\n        if (num_bytes > chunk)\n            num_bytes = chunk;\n\n        int got = read (socket, (char *) ptr, num_bytes);\n        if (got < 0)\n        {\n\t    if (errno == EINTR\n#ifdef EAGAIN\n\t\t|| errno == EAGAIN\n#endif\n#ifdef EWOULDBLOCK\n\t\t|| errno == EWOULDBLOCK\n#endif\n#ifdef WSAEWOULDBLOCK\n                || errno == WSAEWOULDBLOCK\n#endif\n\t\t)\n            {\n#ifdef NP_DEBUG\n                printf (\"CLIENT: EINTR, EAGAIN or EWOULDBLOCK while receiving data @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n\t\tcontinue;\n            }\n#ifdef WSAEMSGSIZE\n            if (errno != WSAEMSGSIZE)\n                return (FALSE);\n            else\n            {\n                got = num_bytes;\n#ifdef NP_DEBUG\n                printf (\"CLIENT: WSAEMSGSIZE, actual bytes %d while receiving data @%ld\\n\", got, S9xGetMilliTime () - START);\n#endif\n            }\n#else\n            return (FALSE);\n#endif\n        }\n        else\n        if (got == 0)\n            return (FALSE);\n\n        len -= got;\n        ptr += got;\n\n        if (!Settings.NetPlayServer && length > 1024)\n        {\n            NetPlay.PercentageComplete = (uint8) (((length - len) * 100) / length);\n#ifdef __WIN32__\n            PostMessage (GUI.hWnd, WM_USER, NetPlay.PercentageComplete,\n                         NetPlay.PercentageComplete);\n            Sleep (0);\n#endif\n        }\n\n    } while (len > 0);\n\n    return (TRUE);\n}\n\nbool8 S9xNPInitialise ()\n{\n#ifdef __WIN32__\n    static bool8 initialised = FALSE;\n\n    if (!initialised)\n    {\n        initialised = TRUE;\n        WSADATA data;\n\n#ifdef NP_DEBUG\n        START = S9xGetMilliTime ();\n\n        printf (\"CLIENT/SERVER: Initialising WinSock @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n        S9xNPSetAction (\"Initialising Windows sockets interface...\");\n        if (WSAStartup (MAKEWORD (1, 0), &data) != 0)\n        {\n            S9xNPSetError (\"Call to init Windows sockets failed. Do you have WinSock2 installed?\");\n            return (FALSE);\n        }\n    }\n#endif\n    return (TRUE);\n}\n\nvoid S9xNPDiscardHeartbeats ()\n{\n    // Discard any pending heartbeats and wait for any frame that is currently\n    // being emulated to complete.\n#ifdef NP_DEBUG\n    printf (\"CLIENT: DiscardHeartbeats @%ld, finished @\", S9xGetMilliTime () - START);\n    fflush (stdout);\n#endif\n\n#ifdef __WIN32__\n    while (WaitForSingleObject (GUI.ClientSemaphore, 200) == WAIT_OBJECT_0)\n        ;\n#endif\n\n#ifdef NP_DEBUG\n    printf (\"%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    NetPlay.Waiting4EmulationThread = FALSE;\n}\n\nvoid S9xNPSetAction (const char *action, bool8 force)\n{\n#ifdef NP_DEBUG\n    printf (\"NPSetAction: %s, forced = %d %ld\\n\", action, force, S9xGetMilliTime () - START);\n#endif\n    if (force || !Settings.NetPlayServer)\n    {\n        strncpy (NetPlay.ActionMsg, action, NP_MAX_ACTION_LEN - 1);\n        NetPlay.ActionMsg [NP_MAX_ACTION_LEN - 1] = 0;\n#ifdef __WIN32__\n        PostMessage (GUI.hWnd, WM_USER, 0, 0);\n        Sleep (0);\n#endif\n    }\n}\n\nvoid S9xNPSetError (const char *error)\n{\n#if defined(NP_DEBUG) && NP_DEBUG == 2\n    printf(\"ERROR: %s\\n\", error);\n    fflush (stdout);\n#endif\n    strncpy (NetPlay.ErrorMsg, error, NP_MAX_ACTION_LEN - 1);\n    NetPlay.ErrorMsg [NP_MAX_ACTION_LEN - 1] = 0;\n#ifdef __WIN32__\n    PostMessage (GUI.hWnd, WM_USER + 1, 0, 0);\n    Sleep (0);\n#endif\n}\n\nvoid S9xNPSetWarning (const char *warning)\n{\n#if defined(NP_DEBUG) && NP_DEBUG == 3\n    printf(\"Warning: %s\\n\", warning);\n    fflush (stdout);\n#endif\n    strncpy (NetPlay.WarningMsg, warning, NP_MAX_ACTION_LEN - 1);\n    NetPlay.WarningMsg [NP_MAX_ACTION_LEN - 1] = 0;\n#ifdef __WIN32__\n    PostMessage (GUI.hWnd, WM_USER + 2, 0, 0);\n    Sleep (0);\n#endif\n}\n#endif\n"
        },
        {
          "name": "netplay.h",
          "type": "blob",
          "size": 5.2763671875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _NETPLAY_H_\n#define _NETPLAY_H_\n\n/*\n * Client to server joypad update\n *\n * magic        1\n * sequence_no  1\n * opcode       1\n * joypad data  4\n *\n * Server to client joypad update\n * magic        1\n * sequence_no  1\n * opcode       1 + num joypads (top 3 bits)\n * joypad data  4 * n\n */\n\n#ifdef _DEBUG\n#define NP_DEBUG 1\n#endif\n\n#define NP_VERSION 10\n#define NP_JOYPAD_HIST_SIZE 120\n#define NP_DEFAULT_PORT 6096\n\n#define NP_MAX_CLIENTS 8\n\n#define NP_SERV_MAGIC 'S'\n#define NP_CLNT_MAGIC 'C'\n\n#define NP_CLNT_HELLO 0\n#define NP_CLNT_JOYPAD 1\n#define NP_CLNT_RESET 2\n#define NP_CLNT_PAUSE 3\n#define NP_CLNT_LOAD_ROM 4\n#define NP_CLNT_ROM_IMAGE 5\n#define NP_CLNT_FREEZE_FILE 6\n#define NP_CLNT_SRAM_DATA 7\n#define NP_CLNT_READY 8\n#define NP_CLNT_LOADED_ROM 9\n#define NP_CLNT_RECEIVED_ROM_IMAGE 10\n#define NP_CLNT_WAITING_FOR_ROM_IMAGE 11\n\n#define NP_SERV_HELLO 0\n#define NP_SERV_JOYPAD 1\n#define NP_SERV_RESET 2\n#define NP_SERV_PAUSE 3\n#define NP_SERV_LOAD_ROM 4\n#define NP_SERV_ROM_IMAGE 5\n#define NP_SERV_FREEZE_FILE 6\n#define NP_SERV_SRAM_DATA 7\n#define NP_SERV_READY 8\n// ...\n#define NP_SERV_JOYPAD_SWAP 12\n\nstruct SNPClient\n{\n    volatile uint8 SendSequenceNum;\n    volatile uint8 ReceiveSequenceNum;\n    volatile bool8 Connected;\n    volatile bool8 SaidHello;\n    volatile bool8 Paused;\n    volatile bool8 Ready;\n    int Socket;\n    char *ROMName;\n    char *HostName;\n    char *Who;\n};\n\nenum {\n    NP_SERVER_SEND_ROM_IMAGE,\n    NP_SERVER_SYNC_ALL,\n    NP_SERVER_SYNC_CLIENT,\n    NP_SERVER_SEND_FREEZE_FILE_ALL,\n    NP_SERVER_SEND_ROM_LOAD_REQUEST_ALL,\n    NP_SERVER_RESET_ALL,\n    NP_SERVER_SEND_SRAM_ALL,\n    NP_SERVER_SEND_SRAM\n};\n\n#define NP_MAX_TASKS 20\n\nstruct NPServerTask\n{\n    uint32 Task;\n    void  *Data;\n};\n\nstruct SNPServer\n{\n    struct SNPClient Clients [NP_MAX_CLIENTS];\n    int    NumClients;\n    volatile struct NPServerTask TaskQueue [NP_MAX_TASKS];\n    volatile uint32 TaskHead;\n    volatile uint32 TaskTail;\n    int    Socket;\n    uint32 FrameTime;\n    uint32 FrameCount;\n    char   ROMName [30];\n    uint32 Joypads [NP_MAX_CLIENTS];\n    bool8  ClientPaused;\n    uint32 Paused;\n    bool8  SendROMImageOnConnect;\n    bool8  SyncByReset;\n};\n\n#define NP_MAX_ACTION_LEN 200\n\nstruct SNetPlay\n{\n    volatile uint8  MySequenceNum;\n    volatile uint8  ServerSequenceNum;\n    volatile bool8  Connected;\n    volatile bool8  Abort;\n    volatile uint8  Player;\n    volatile bool8  ClientsReady [NP_MAX_CLIENTS];\n    volatile bool8  ClientsPaused [NP_MAX_CLIENTS];\n    volatile bool8  Paused;\n    volatile bool8  PendingWait4Sync;\n    volatile uint8  PercentageComplete;\n    volatile bool8  Waiting4EmulationThread;\n    volatile bool8  Answer;\n#ifdef __WIN32__\n    HANDLE          ReplyEvent;\n#endif\n    volatile int    Socket;\n    char *ServerHostName;\n    char *ROMName;\n    int Port;\n    volatile uint32 JoypadWriteInd;\n    volatile uint32 JoypadReadInd;\n    uint32 Joypads [NP_JOYPAD_HIST_SIZE][NP_MAX_CLIENTS];\n    uint32 Frame [NP_JOYPAD_HIST_SIZE];\n    uint32 FrameCount;\n    uint32 MaxFrameSkip;\n    uint32 MaxBehindFrameCount;\n    bool8 JoypadsReady [NP_JOYPAD_HIST_SIZE][NP_MAX_CLIENTS];\n    char   ActionMsg [NP_MAX_ACTION_LEN];\n    char   ErrorMsg [NP_MAX_ACTION_LEN];\n    char   WarningMsg [NP_MAX_ACTION_LEN];\n};\n\nextern \"C\" struct SNetPlay NetPlay;\n\n//\n// NETPLAY_CLIENT_HELLO message format:\n// header\n// frame_time (4)\n// ROMName (variable)\n\n#define WRITE_LONG(p, v) { \\\n*((p) + 0) = (uint8) ((v) >> 24); \\\n*((p) + 1) = (uint8) ((v) >> 16); \\\n*((p) + 2) = (uint8) ((v) >> 8); \\\n*((p) + 3) = (uint8) ((v) >> 0); \\\n}\n\n#define READ_LONG(p) \\\n((((uint8) *((p) + 0)) << 24) | \\\n (((uint8) *((p) + 1)) << 16) | \\\n (((uint8) *((p) + 2)) <<  8) | \\\n (((uint8) *((p) + 3)) <<  0))\n\nbool8 S9xNPConnectToServer (const char *server_name, int port,\n                            const char *rom_name);\nbool8 S9xNPWaitForHeartBeat ();\nbool8 S9xNPWaitForHeartBeatDelay (uint32 time_msec = 0);\nbool8 S9xNPCheckForHeartBeat (uint32 time_msec = 0);\nuint32 S9xNPGetJoypad (int which1);\nbool8 S9xNPSendJoypadUpdate (uint32 joypad);\nvoid S9xNPDisconnect ();\nbool8 S9xNPInitialise ();\nbool8 S9xNPSendData (int fd, const uint8 *data, int len);\nbool8 S9xNPGetData (int fd, uint8 *data, int len);\n\nvoid S9xNPSyncClients ();\nvoid S9xNPStepJoypadHistory ();\n\nvoid S9xNPResetJoypadReadPos ();\nbool8 S9xNPSendReady (uint8 op = NP_CLNT_READY);\nbool8 S9xNPSendPause (bool8 pause);\nvoid S9xNPReset ();\nvoid S9xNPSetAction (const char *action, bool8 force = FALSE);\nvoid S9xNPSetError (const char *error);\nvoid S9xNPSetWarning (const char *warning);\nvoid S9xNPDiscardHeartbeats ();\nvoid S9xNPServerQueueSendingFreezeFile (const char *filename);\nvoid S9xNPServerQueueSyncAll ();\nvoid S9xNPServerQueueSendingROMImage ();\nvoid S9xNPServerQueueSendingLoadROMRequest (const char *filename);\n\nvoid S9xNPServerAddTask (uint32 task, void *data);\n\nbool8 S9xNPStartServer (int port);\nvoid S9xNPStopServer ();\nvoid S9xNPSendJoypadSwap ();\n#ifdef __WIN32__\n#define S9xGetMilliTime timeGetTime\n#else\nuint32 S9xGetMilliTime ();\n#endif\n#endif\n"
        },
        {
          "name": "obc1.cpp",
          "type": "blob",
          "size": 2.404296875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n\n\nuint8 S9xGetOBC1 (uint16 Address)\n{\n\tswitch (Address)\n\t{\n\t\tcase 0x7ff0:\n\t\t\treturn (Memory.OBC1RAM[OBC1.basePtr + (OBC1.address << 2)]);\n\n\t\tcase 0x7ff1:\n\t\t\treturn (Memory.OBC1RAM[OBC1.basePtr + (OBC1.address << 2) + 1]);\n\n\t\tcase 0x7ff2:\n\t\t\treturn (Memory.OBC1RAM[OBC1.basePtr + (OBC1.address << 2) + 2]);\n\n\t\tcase 0x7ff3:\n\t\t\treturn (Memory.OBC1RAM[OBC1.basePtr + (OBC1.address << 2) + 3]);\n\n\t\tcase 0x7ff4:\n\t\t\treturn (Memory.OBC1RAM[OBC1.basePtr + (OBC1.address >> 2) + 0x200]);\n\t}\n\n\treturn (Memory.OBC1RAM[Address - 0x6000]);\n}\n\nvoid S9xSetOBC1 (uint8 Byte, uint16 Address)\n{\n\tswitch (Address)\n\t{\n\t\tcase 0x7ff0:\n\t\t\tMemory.OBC1RAM[OBC1.basePtr + (OBC1.address << 2)] = Byte;\n\t\t\tbreak;\n\n\t\tcase 0x7ff1:\n\t\t\tMemory.OBC1RAM[OBC1.basePtr + (OBC1.address << 2) + 1] = Byte;\n\t\t\tbreak;\n\n\t\tcase 0x7ff2:\n\t\t\tMemory.OBC1RAM[OBC1.basePtr + (OBC1.address << 2) + 2] = Byte;\n\t\t\tbreak;\n\n\t\tcase 0x7ff3:\n\t\t\tMemory.OBC1RAM[OBC1.basePtr + (OBC1.address << 2) + 3] = Byte;\n\t\t\tbreak;\n\n\t\tcase 0x7ff4:\n\t\t{\n\t\t\tuint8 Temp;\n\t\t\tTemp = Memory.OBC1RAM[OBC1.basePtr + (OBC1.address >> 2) + 0x200];\n\t\t\tTemp = (Temp & ~(3 << OBC1.shift)) | ((Byte & 3) << OBC1.shift);\n\t\t\tMemory.OBC1RAM[OBC1.basePtr + (OBC1.address >> 2) + 0x200] = Temp;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 0x7ff5:\n\t\t\tif (Byte & 1)\n\t\t\t\tOBC1.basePtr = 0x1800;\n\t\t\telse\n\t\t\t\tOBC1.basePtr = 0x1c00;\n\t\t\tbreak;\n\n\t\tcase 0x7ff6:\n\t\t\tOBC1.address = Byte & 0x7f;\n\t\t\tOBC1.shift = (Byte & 3) << 1;\n\t\t\tbreak;\n\t}\n\n\tMemory.OBC1RAM[Address - 0x6000] = Byte;\n}\n\nvoid S9xResetOBC1 (void)\n{\n\tfor (int i = 0; i <= 0x1fff; i++)\n\t\tMemory.OBC1RAM[i] = 0xff;\n\n\tif (Memory.OBC1RAM[0x1ff5] & 1)\n\t\tOBC1.basePtr = 0x1800;\n\telse\n\t\tOBC1.basePtr = 0x1c00;\n\n\tOBC1.address = Memory.OBC1RAM[0x1ff6] & 0x7f;\n\tOBC1.shift = (Memory.OBC1RAM[0x1ff6] & 3) << 1;\n}\n\nuint8 * S9xGetBasePointerOBC1 (uint16 Address)\n{\n\tif (Address >= 0x7ff0 && Address <= 0x7ff6)\n\t\treturn (NULL);\n\treturn (Memory.OBC1RAM - 0x6000);\n}\n\nuint8 * S9xGetMemPointerOBC1 (uint16 Address)\n{\n\tif (Address >= 0x7ff0 && Address <= 0x7ff6)\n\t\treturn (NULL);\n\treturn (Memory.OBC1RAM + Address - 0x6000);\n}\n"
        },
        {
          "name": "obc1.h",
          "type": "blob",
          "size": 0.662109375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _OBC1_H_\n#define _OBC1_H_\n\nstruct SOBC1\n{\n\tuint16\taddress;\n\tuint16\tbasePtr;\n\tuint16\tshift;\n};\n\nextern struct SOBC1\tOBC1;\n\nvoid S9xSetOBC1 (uint8, uint16);\nuint8 S9xGetOBC1 (uint16);\nvoid S9xResetOBC1 (void);\nuint8 * S9xGetBasePointerOBC1 (uint16);\nuint8 * S9xGetMemPointerOBC1 (uint16);\n\n#endif\n"
        },
        {
          "name": "pixform.h",
          "type": "blob",
          "size": 5.5771484375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _PIXFORM_H_\n#define _PIXFORM_H_\n\n/* RGB565 format */\n#define BUILD_PIXEL_RGB565(R, G, B)  (((int)(R) << 11) | ((int)(G) << 6) | (((int)(G) & 0x10) << 1) | (int)(B))\n#define BUILD_PIXEL2_RGB565(R, G, B) (((int)(R) << 11) | ((int)(G) << 5) | (int)(B))\n#define DECOMPOSE_PIXEL_RGB565(PIX, R, G, B) \\\n    {                                        \\\n        (R) = (PIX) >> 11;                   \\\n        (G) = ((PIX) >> 6) & 0x1f;           \\\n        (B) = (PIX)&0x1f;                    \\\n    }\n#define SPARE_RGB_BIT_MASK_RGB565 (1 << 5)\n\n#define MAX_RED_RGB565            31\n#define MAX_GREEN_RGB565          63\n#define MAX_BLUE_RGB565           31\n#define RED_SHIFT_BITS_RGB565     11\n#define GREEN_SHIFT_BITS_RGB565   6\n#define RED_LOW_BIT_MASK_RGB565   0x0800\n#define GREEN_LOW_BIT_MASK_RGB565 0x0020\n#define BLUE_LOW_BIT_MASK_RGB565  0x0001\n#define RED_HI_BIT_MASK_RGB565    0x8000\n#define GREEN_HI_BIT_MASK_RGB565  0x0400\n#define BLUE_HI_BIT_MASK_RGB565   0x0010\n#define FIRST_COLOR_MASK_RGB565   0xF800\n#define SECOND_COLOR_MASK_RGB565  0x07E0\n#define THIRD_COLOR_MASK_RGB565   0x001F\n#define ALPHA_BITS_MASK_RGB565    0x0000\n\n/* RGB555 format */\n#define BUILD_PIXEL_RGB555(R, G, B)  (((int)(R) << 10) | ((int)(G) << 5) | (int)(B))\n#define BUILD_PIXEL2_RGB555(R, G, B) (((int)(R) << 10) | ((int)(G) << 5) | (int)(B))\n#define DECOMPOSE_PIXEL_RGB555(PIX, R, G, B) \\\n    {                                        \\\n        (R) = (PIX) >> 10;                   \\\n        (G) = ((PIX) >> 5) & 0x1f;           \\\n        (B) = (PIX)&0x1f;                    \\\n    }\n#define SPARE_RGB_BIT_MASK_RGB555 (1 << 15)\n\n#define MAX_RED_RGB555            31\n#define MAX_GREEN_RGB555          31\n#define MAX_BLUE_RGB555           31\n#define RED_SHIFT_BITS_RGB555     10\n#define GREEN_SHIFT_BITS_RGB555   5\n#define RED_LOW_BIT_MASK_RGB555   0x0400\n#define GREEN_LOW_BIT_MASK_RGB555 0x0020\n#define BLUE_LOW_BIT_MASK_RGB555  0x0001\n#define RED_HI_BIT_MASK_RGB555    0x4000\n#define GREEN_HI_BIT_MASK_RGB555  0x0200\n#define BLUE_HI_BIT_MASK_RGB555   0x0010\n#define FIRST_COLOR_MASK_RGB555   0x7C00\n#define SECOND_COLOR_MASK_RGB555  0x03E0\n#define THIRD_COLOR_MASK_RGB555   0x001F\n#define ALPHA_BITS_MASK_RGB555    0x0000\n\n#define CONCAT(X, Y) X##Y\n\n// C pre-processor needs a two stage macro define to enable it to concat\n// to macro names together to form the name of another macro.\n#define BUILD_PIXEL_D(F, R, G, B)          CONCAT(BUILD_PIXEL_, F) (R, G, B)\n#define BUILD_PIXEL2_D(F, R, G, B)         CONCAT(BUILD_PIXEL2_, F) (R, G, B)\n#define DECOMPOSE_PIXEL_D(F, PIX, R, G, B) CONCAT(DECOMPOSE_PIXEL_, F) (PIX, R, G, B)\n\n#define BUILD_PIXEL(R, G, B)               BUILD_PIXEL_D(PIXEL_FORMAT, R, G, B)\n#define BUILD_PIXEL2(R, G, B)              BUILD_PIXEL2_D(PIXEL_FORMAT, R, G, B)\n#define DECOMPOSE_PIXEL(PIX, R, G, B)      DECOMPOSE_PIXEL_D(PIXEL_FORMAT, PIX, R, G, B)\n\n#define MAX_RED_D(F)            CONCAT(MAX_RED_, F)\n#define MAX_GREEN_D(F)          CONCAT(MAX_GREEN_, F)\n#define MAX_BLUE_D(F)           CONCAT(MAX_BLUE_, F)\n#define RED_SHIFT_BITS_D(F)     CONCAT(RED_SHIFT_BITS_, F)\n#define GREEN_SHIFT_BITS_D(F)   CONCAT(GREEN_SHIFT_BITS_, F)\n#define RED_LOW_BIT_MASK_D(F)   CONCAT(RED_LOW_BIT_MASK_, F)\n#define GREEN_LOW_BIT_MASK_D(F) CONCAT(GREEN_LOW_BIT_MASK_, F)\n#define BLUE_LOW_BIT_MASK_D(F)  CONCAT(BLUE_LOW_BIT_MASK_, F)\n#define RED_HI_BIT_MASK_D(F)    CONCAT(RED_HI_BIT_MASK_, F)\n#define GREEN_HI_BIT_MASK_D(F)  CONCAT(GREEN_HI_BIT_MASK_, F)\n#define BLUE_HI_BIT_MASK_D(F)   CONCAT(BLUE_HI_BIT_MASK_, F)\n#define FIRST_COLOR_MASK_D(F)   CONCAT(FIRST_COLOR_MASK_, F)\n#define SECOND_COLOR_MASK_D(F)  CONCAT(SECOND_COLOR_MASK_, F)\n#define THIRD_COLOR_MASK_D(F)   CONCAT(THIRD_COLOR_MASK_, F)\n#define ALPHA_BITS_MASK_D(F)    CONCAT(ALPHA_BITS_MASK_, F)\n\n#define MAX_RED            MAX_RED_D(PIXEL_FORMAT)\n#define MAX_GREEN          MAX_GREEN_D(PIXEL_FORMAT)\n#define MAX_BLUE           MAX_BLUE_D(PIXEL_FORMAT)\n#define RED_SHIFT_BITS     RED_SHIFT_BITS_D(PIXEL_FORMAT)\n#define GREEN_SHIFT_BITS   GREEN_SHIFT_BITS_D(PIXEL_FORMAT)\n#define RED_LOW_BIT_MASK   RED_LOW_BIT_MASK_D(PIXEL_FORMAT)\n#define GREEN_LOW_BIT_MASK GREEN_LOW_BIT_MASK_D(PIXEL_FORMAT)\n#define BLUE_LOW_BIT_MASK  BLUE_LOW_BIT_MASK_D(PIXEL_FORMAT)\n#define RED_HI_BIT_MASK    RED_HI_BIT_MASK_D(PIXEL_FORMAT)\n#define GREEN_HI_BIT_MASK  GREEN_HI_BIT_MASK_D(PIXEL_FORMAT)\n#define BLUE_HI_BIT_MASK   BLUE_HI_BIT_MASK_D(PIXEL_FORMAT)\n#define FIRST_COLOR_MASK   FIRST_COLOR_MASK_D(PIXEL_FORMAT)\n#define SECOND_COLOR_MASK  SECOND_COLOR_MASK_D(PIXEL_FORMAT)\n#define THIRD_COLOR_MASK   THIRD_COLOR_MASK_D(PIXEL_FORMAT)\n#define ALPHA_BITS_MASK    ALPHA_BITS_MASK_D(PIXEL_FORMAT)\n\n#define GREEN_HI_BIT               ((MAX_GREEN + 1) >> 1)\n#define RGB_LOW_BITS_MASK          (RED_LOW_BIT_MASK | GREEN_LOW_BIT_MASK | BLUE_LOW_BIT_MASK)\n#define RGB_HI_BITS_MASK           (RED_HI_BIT_MASK | GREEN_HI_BIT_MASK | BLUE_HI_BIT_MASK)\n#define RGB_HI_BITS_MASKx2         ((RED_HI_BIT_MASK | GREEN_HI_BIT_MASK | BLUE_HI_BIT_MASK) << 1)\n#define RGB_REMOVE_LOW_BITS_MASK   (~RGB_LOW_BITS_MASK)\n#define FIRST_THIRD_COLOR_MASK     (FIRST_COLOR_MASK | THIRD_COLOR_MASK)\n#define TWO_LOW_BITS_MASK          (RGB_LOW_BITS_MASK | (RGB_LOW_BITS_MASK << 1))\n#define HIGH_BITS_SHIFTED_TWO_MASK (((FIRST_COLOR_MASK | SECOND_COLOR_MASK | THIRD_COLOR_MASK) & ~TWO_LOW_BITS_MASK) >> 2)\n\n#endif // _PIXFORM_H_\n"
        },
        {
          "name": "port.h",
          "type": "blob",
          "size": 5.1015625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _PORT_H_\n#define _PORT_H_\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <limits.h>\n#ifndef __LIBRETRO__\n#include <memory.h>\n#endif\n#include <time.h>\n#include <string.h>\n#ifdef HAVE_STRINGS_H\n#include <strings.h>\n#endif\n#include <sys/types.h>\n\n#ifdef __WIN32__\n#define NOMINMAX 1\n#include <windows.h>\n#endif\n\n#ifdef __WIN32__\n//#define RIGHTSHIFT_IS_SAR\n#define RIGHTSHIFT_int8_IS_SAR\n#define RIGHTSHIFT_int16_IS_SAR\n#define RIGHTSHIFT_int32_IS_SAR\n#ifndef __LIBRETRO__\n\n#endif //__LIBRETRO__\n#endif\n\n#ifdef __MACOSX__\n#define PIXEL_FORMAT RGB555\n#endif\n\n#ifndef PIXEL_FORMAT\n#define PIXEL_FORMAT RGB565\n#endif\n\n#if defined(__GNUC__)\n#define alwaysinline  inline __attribute__((always_inline))\n#elif defined(_MSC_VER)\n#define alwaysinline  __forceinline\n#else\n#define alwaysinline  inline\n#endif\n\n#ifndef snes9x_types_defined\n#define snes9x_types_defined\ntypedef unsigned char\t\tbool8;\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\ntypedef intptr_t\t\t\tpint;\ntypedef int8_t\t\t\t\tint8;\ntypedef uint8_t\t\t\t\tuint8;\ntypedef int16_t\t\t\t\tint16;\ntypedef uint16_t\t\t\tuint16;\ntypedef int32_t\t\t\t\tint32;\ntypedef uint32_t\t\t\tuint32;\ntypedef int64_t\t\t\t\tint64;\ntypedef uint64_t\t\t\tuint64;\n#else\t// HAVE_STDINT_H\n#ifdef __WIN32__\ntypedef intptr_t\t\t\tpint;\ntypedef signed char\t\t\tint8;\ntypedef unsigned char\t\tuint8;\ntypedef signed short\t\tint16;\ntypedef unsigned short\t\tuint16;\ntypedef signed int     \t\tint32;\ntypedef unsigned int\t\tuint32;\ntypedef signed __int64\t\tint64;\ntypedef unsigned __int64\tuint64;\ntypedef int8                int8_t;\ntypedef uint8       \t\tuint8_t;\ntypedef int16       \t\tint16_t;\ntypedef uint16      \t\tuint16_t;\ntypedef int32\t\t    \tint32_t;\ntypedef uint32      \t\tuint32_t;\ntypedef int64               int64_t;\ntypedef uint64              uint64_t;\ntypedef int\t\t\t\t\tsocklen_t;\n#else\t// __WIN32__\ntypedef signed char\t\t\tint8;\ntypedef unsigned char\t\tuint8;\ntypedef signed short\t\tint16;\ntypedef unsigned short\t\tuint16;\ntypedef signed int\t\t\tint32;\ntypedef unsigned int\t\tuint32;\n#ifdef __GNUC__\n// long long is not part of ISO C++ \n__extension__\n#endif\ntypedef long long\t\t\tint64;\ntypedef unsigned long long\tuint64;\ntypedef size_t\t\t\t\tpint;\n#endif\t//  __WIN32__\n#endif\t// HAVE_STDINT_H\n#endif\t// snes9x_types_defined\n\n#ifndef TRUE\n#define TRUE\t1\n#endif\n#ifndef FALSE\n#define FALSE\t0\n#endif\n\n#ifndef __WIN32__\n#ifndef PATH_MAX\n#define PATH_MAX        1024\n#endif\n#else\n#ifndef PATH_MAX\n#define PATH_MAX        _MAX_PATH\n#endif\n#endif\n\n#include \"fscompat.h\"\n\n#define S9xDisplayString\tDisplayStringFromBottom\n#ifdef __WIN32__\n#if !defined(SNES9X_QT) && !defined(__LIBRETRO__)\nvoid SetInfoDlgColor(unsigned char, unsigned char, unsigned char);\n#define SET_UI_COLOR(r,g,b) SetInfoDlgColor(r,g,b)\n#endif\n#ifndef snprintf\n   #define snprintf _snprintf\n#endif\n#ifndef strcasecmp\n   #define strcasecmp\tstricmp\n#endif\n#ifndef strncasecmp\n   #define strncasecmp\tstrnicmp\n#endif\n#endif  // __WIN32__\n\n#if defined(__DJGPP) || defined(__WIN32__)\n#define SLASH_STR\t\"\\\\\"\n#define SLASH_CHAR\t'\\\\'\n#else\n#define SLASH_STR\t\"/\"\n#define SLASH_CHAR\t'/'\n#endif\n\n#ifndef TITLE\n#define TITLE \"Snes9x\"\n#endif\n\n#if defined(__i386__) || defined(__i486__) || defined(__i586__) || defined(__i686__) || defined(__x86_64__) || defined(__alpha__) || defined(__MIPSEL__) || defined(_M_IX86) || defined(_M_X64) || defined(_XBOX1) || defined(__arm__) || defined(ANDROID) || defined(__aarch64__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER == __ORDER_LITTLE_ENDIAN__)\n#define LSB_FIRST\n#define FAST_LSB_WORD_ACCESS\n#else\n#define MSB_FIRST\n#endif\n\n#ifdef FAST_LSB_WORD_ACCESS\n#define READ_WORD(s)\t\t(*(uint16 *) (s))\n#define READ_3WORD(s)\t\t(*(uint32 *) (s) & 0x00ffffff)\n#define READ_DWORD(s)\t\t(*(uint32 *) (s))\n#define WRITE_WORD(s, d)\t*(uint16 *) (s) = (d)\n#define WRITE_3WORD(s, d)\t*(uint16 *) (s) = (uint16) (d), *((uint8 *) (s) + 2) = (uint8) ((d) >> 16)\n#define WRITE_DWORD(s, d)\t*(uint32 *) (s) = (d)\n#else\n#define READ_WORD(s)\t\t(*(uint8 *) (s) | (*((uint8 *) (s) + 1) << 8))\n#define READ_3WORD(s)\t\t(*(uint8 *) (s) | (*((uint8 *) (s) + 1) << 8) | (*((uint8 *) (s) + 2) << 16))\n#define READ_DWORD(s)\t\t(*(uint8 *) (s) | (*((uint8 *) (s) + 1) << 8) | (*((uint8 *) (s) + 2) << 16) | (*((uint8 *) (s) + 3) << 24))\n#define WRITE_WORD(s, d)\t*(uint8 *) (s) = (uint8) (d), *((uint8 *) (s) + 1) = (uint8) ((d) >> 8)\n#define WRITE_3WORD(s, d)\t*(uint8 *) (s) = (uint8) (d), *((uint8 *) (s) + 1) = (uint8) ((d) >> 8), *((uint8 *) (s) + 2) = (uint8) ((d) >> 16)\n#define WRITE_DWORD(s, d)\t*(uint8 *) (s) = (uint8) (d), *((uint8 *) (s) + 1) = (uint8) ((d) >> 8), *((uint8 *) (s) + 2) = (uint8) ((d) >> 16), *((uint8 *) (s) + 3) = (uint8) ((d) >> 24)\n#endif\n\n#define SWAP_WORD(s)\t\t(s) = (((s) & 0xff) <<  8) | (((s) & 0xff00) >> 8)\n#define SWAP_DWORD(s)\t\t(s) = (((s) & 0xff) << 24) | (((s) & 0xff00) << 8) | (((s) & 0xff0000) >> 8) | (((s) & 0xff000000) >> 24)\n\n#include \"pixform.h\"\n\n#endif\n"
        },
        {
          "name": "ppu.cpp",
          "type": "blob",
          "size": 44.8427734375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"dma.h\"\n#include \"apu/apu.h\"\n#include \"fxemu.h\"\n#include \"sdd1.h\"\n#include \"srtc.h\"\n#include \"controls.h\"\n#include \"movie.h\"\n#include \"display.h\"\n#ifdef NETPLAY_SUPPORT\n#include \"netplay.h\"\n#endif\n#ifdef DEBUGGER\n#include \"debug.h\"\n#include \"missing.h\"\n#endif\n\nextern uint8\t*HDMAMemPointers[8];\n\n\nstatic inline void S9xLatchCounters (bool force)\n{\n\tif (force || (Memory.FillRAM[0x4213] & 0x80))\n\t{\n\t\t// Latch h and v counters, like the gun\n\t#ifdef DEBUGGER\n\t\tmissing.h_v_latch = 1;\n\t#endif\n\n\t\tPPU.HVBeamCounterLatched = 1;\n\t\tPPU.VBeamPosLatched = (uint16) CPU.V_Counter;\n\n\t\t// From byuu:\n\t\t// All dots are 4 cycles long, except dots 322 and 326. dots 322 and 326 are 6 cycles long.\n\t\t// This holds true for all scanlines except scanline 240 on non-interlace odd frames.\n\t\t// The reason for this is because this scanline is only 1360 cycles long,\n\t\t// instead of 1364 like all other scanlines.\n\t\t// This makes the effective range of hscan_pos 0-339 at all times.\n\t\tint32\thc = CPU.Cycles;\n\n\t\tif (Timings.H_Max == Timings.H_Max_Master) // 1364\n\t\t{\n\t\t\tif (hc >= 1292)\n\t\t\t\thc -= (ONE_DOT_CYCLE / 2);\n\t\t\tif (hc >= 1308)\n\t\t\t\thc -= (ONE_DOT_CYCLE / 2);\n\t\t}\n\n\t\tPPU.HBeamPosLatched = (uint16) (hc / ONE_DOT_CYCLE);\n\n\t\tMemory.FillRAM[0x213f] |= 0x40;\n\t}\n\n\tif (CPU.V_Counter >  PPU.GunVLatch || (CPU.V_Counter == PPU.GunVLatch && CPU.Cycles >= PPU.GunHLatch * ONE_DOT_CYCLE))\n\t\tPPU.GunVLatch = 1000;\n}\n\nstatic inline void S9xTryGunLatch (bool force)\n{\n\tif (CPU.V_Counter >  PPU.GunVLatch || (CPU.V_Counter == PPU.GunVLatch && CPU.Cycles >= PPU.GunHLatch * ONE_DOT_CYCLE))\n\t{\n\t\tif (force || (Memory.FillRAM[0x4213] & 0x80))\n\t\t{\n\t\t#ifdef DEBUGGER\n\t\t\tmissing.h_v_latch = 1;\n\t\t#endif\n\n\t\t\tPPU.HVBeamCounterLatched = 1;\n\t\t\tPPU.VBeamPosLatched = (uint16) PPU.GunVLatch;\n\t\t\tPPU.HBeamPosLatched = (uint16) PPU.GunHLatch;\n\n\t\t\tMemory.FillRAM[0x213f] |= 0x40;\n\t\t}\n\n\t\tPPU.GunVLatch = 1000;\n\t}\n}\n\nstatic int CyclesUntilNext (int hc, int vc)\n{\n\tint32 total = 0;\n\tint vpos = CPU.V_Counter;\n\n\tif (vc - vpos > 0)\n\t{\n\t\t// It's still in this frame */\n\t\t// Add number of lines\n\t\ttotal += (vc - vpos) * Timings.H_Max_Master;\n\t\t// If line 240 is in there and we're odd, subtract a dot\n\t\tif (vpos <= 240 && vc > 240 && S9xInterlaceField() & !IPPU.Interlace)\n\t\t\ttotal -= ONE_DOT_CYCLE;\n\t}\n\telse\n\t{\n\t\tif (vc == vpos && (hc > CPU.Cycles))\n\t\t{\n\t\t\treturn hc;\n\t\t}\n\n\t\ttotal += (Timings.V_Max - vpos) * Timings.H_Max_Master;\n\t\tif (vpos <= 240 && S9xInterlaceField() && !IPPU.Interlace)\n\t\t\ttotal -= ONE_DOT_CYCLE;\n\n\t\ttotal += (vc) * Timings.H_Max_Master;\n\t\tif (vc > 240 && !S9xInterlaceField() && !IPPU.Interlace)\n\t\t\ttotal -= ONE_DOT_CYCLE;\n\t}\n\n\ttotal += hc;\n\n\treturn total;\n}\n\nvoid S9xUpdateIRQPositions (bool initial)\n{\n\tPPU.HTimerPosition = PPU.IRQHBeamPos * ONE_DOT_CYCLE + Timings.IRQTriggerCycles;\n\tPPU.HTimerPosition -= PPU.IRQHBeamPos ? 0 : ONE_DOT_CYCLE;\n\tPPU.HTimerPosition += PPU.IRQHBeamPos > 322 ? (ONE_DOT_CYCLE / 2) : 0;\n\tPPU.HTimerPosition += PPU.IRQHBeamPos > 326 ? (ONE_DOT_CYCLE / 2) : 0;\n\tPPU.VTimerPosition = PPU.IRQVBeamPos;\n\n\tif (PPU.VTimerEnabled && (PPU.VTimerPosition >= (Timings.V_Max + (IPPU.Interlace ? 1 : 0))))\n\t{\n\t\tTimings.NextIRQTimer = 0x0fffffff;\n\t}\n\telse if (!PPU.HTimerEnabled && !PPU.VTimerEnabled)\n\t{\n\t\tTimings.NextIRQTimer = 0x0fffffff;\n\t}\n\telse if (PPU.HTimerEnabled && !PPU.VTimerEnabled)\n\t{\n\t\tint v_pos = CPU.V_Counter;\n\n\t\tTimings.NextIRQTimer = PPU.HTimerPosition;\n\t\tif (CPU.Cycles > Timings.NextIRQTimer - Timings.IRQTriggerCycles)\n\t\t{\n\t\t\tTimings.NextIRQTimer += Timings.H_Max;\n\t\t\tv_pos++;\n\t\t}\n\n\t\t// Check for short dot scanline\n\t\tif (v_pos == 240 && S9xInterlaceField() && !IPPU.Interlace)\n\t\t{\n\t\t\tTimings.NextIRQTimer -= PPU.IRQHBeamPos <= 322 ? ONE_DOT_CYCLE / 2 : 0;\n\t\t\tTimings.NextIRQTimer -= PPU.IRQHBeamPos <= 326 ? ONE_DOT_CYCLE / 2 : 0;\n\t\t}\n\t}\n\telse if (!PPU.HTimerEnabled && PPU.VTimerEnabled)\n\t{\n\t\tif (CPU.V_Counter == PPU.VTimerPosition && initial)\n\t\t\tTimings.NextIRQTimer = CPU.Cycles + Timings.IRQTriggerCycles - ONE_DOT_CYCLE;\n\t\telse\n\t\t\tTimings.NextIRQTimer = CyclesUntilNext (Timings.IRQTriggerCycles - ONE_DOT_CYCLE, PPU.VTimerPosition);\n\t}\n\telse\n\t{\n\t\tTimings.NextIRQTimer = CyclesUntilNext (PPU.HTimerPosition, PPU.VTimerPosition);\n\n\t\t// Check for short dot scanline\n\t\tint field = S9xInterlaceField();\n\n\t\tif (PPU.VTimerPosition < CPU.V_Counter ||\n\t\t   (PPU.VTimerPosition == CPU.V_Counter && Timings.NextIRQTimer > Timings.H_Max))\n\t\t{\n\t\t\tfield = !field;\n\t\t}\n\n\t\tif (PPU.VTimerPosition == 240 && field && !IPPU.Interlace)\n\t\t{\n\t\t\tTimings.NextIRQTimer -= PPU.IRQHBeamPos <= 322 ? ONE_DOT_CYCLE / 2 : 0;\n\t\t\tTimings.NextIRQTimer -= PPU.IRQHBeamPos <= 326 ? ONE_DOT_CYCLE / 2 : 0;\n\t\t}\n\t}\n\n#ifdef DEBUGGER\n\tS9xTraceFormattedMessage(\"--- IRQ Timer HC:%d VC:%d set %d cycles HTimer:%d Pos:%04d->%04d  VTimer:%d Pos:%03d->%03d\", CPU.Cycles, CPU.V_Counter,\n\t\tTimings.NextIRQTimer, PPU.HTimerEnabled, PPU.IRQHBeamPos, PPU.HTimerPosition, PPU.VTimerEnabled, PPU.IRQVBeamPos, PPU.VTimerPosition);\n#endif\n}\n\nvoid S9xFixColourBrightness (void)\n{\n\tIPPU.XB = mul_brightness[PPU.Brightness];\n\n\tfor (int i = 0; i < 64; i++)\n\t{\n\t\tif (i > IPPU.XB[0x1f])\n\t\t\tbrightness_cap[i] = IPPU.XB[0x1f];\n\t\telse\n\t\t\tbrightness_cap[i] = i;\n\t}\n\n\tfor (int i = 0; i < 256; i++)\n\t{\n\t\tIPPU.Red[i]   = IPPU.XB[(PPU.CGDATA[i])       & 0x1f];\n\t\tIPPU.Green[i] = IPPU.XB[(PPU.CGDATA[i] >>  5) & 0x1f];\n\t\tIPPU.Blue[i]  = IPPU.XB[(PPU.CGDATA[i] >> 10) & 0x1f];\n\t\tIPPU.ScreenColors[i] = BUILD_PIXEL(IPPU.Red[i], IPPU.Green[i], IPPU.Blue[i]);\n\t}\n}\n\nvoid S9xSetPPU (uint8 Byte, uint16 Address)\n{\n\t// MAP_PPU: $2000-$3FFF\n\n\tif (CPU.InDMAorHDMA)\n\t{\n\t\tif (CPU.CurrentDMAorHDMAChannel >= 0 && DMA[CPU.CurrentDMAorHDMAChannel].ReverseTransfer)\n\t\t{\n\t\t\t// S9xSetPPU() is called to write to DMA[].AAddress\n\t\t\tif ((Address & 0xff00) == 0x2100)\n\t\t\t{\n\t\t\t\t// Cannot access to Address Bus B ($2100-$21ff) via (H)DMA\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 0x2000-0x3FFF is connected to Address Bus A\n\t\t\t\t// SA1, SuperFX and SRTC are mapped here\n\t\t\t\t// I don't bother for now...\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// S9xSetPPU() is called to read from $21xx\n\t\t\t// Take care of DMA wrapping\n\t\t\tif (Address > 0x21ff)\n\t\t\t\tAddress = 0x2100 + (Address & 0xff);\n\t\t}\n\t}\n\n#ifdef DEBUGGER\n\tif (CPU.InHDMA)\n\t\tS9xTraceFormattedMessage(\"--- HDMA PPU %04X -> %02X\", Address, Byte);\n#endif\n\n\tif (Settings.MSU1 && (Address & 0xfff8) == 0x2000) // MSU-1\n\t\tS9xMSU1WritePort(Address & 7, Byte);\n\telse\n\tif ((Address & 0xffc0) == 0x2140) // APUIO0, APUIO1, APUIO2, APUIO3\n\t\t// write_port will run the APU until given clock before writing value\n\t\tS9xAPUWritePort(Address & 3, Byte);\n\telse\n\tif (Address <= 0x2183)\n\t{\n\t\tswitch (Address)\n\t\t{\n\t\t\tcase 0x2100: // INIDISP\n\t\t\t\tif (Byte != Memory.FillRAM[0x2100])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\n\t\t\t\t\tif (PPU.Brightness != (Byte & 0xf))\n\t\t\t\t\t{\n\t\t\t\t\t\tIPPU.ColorsChanged = TRUE;\n\t\t\t\t\t\tPPU.Brightness = Byte & 0xf;\n\t\t\t\t\t\tS9xFixColourBrightness();\n\t\t\t\t\t\tS9xBuildDirectColourMaps();\n\t\t\t\t\t\tif (PPU.Brightness > IPPU.MaxBrightness)\n\t\t\t\t\t\t\tIPPU.MaxBrightness = PPU.Brightness;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((Memory.FillRAM[0x2100] & 0x80) != (Byte & 0x80))\n\t\t\t\t\t{\n\t\t\t\t\t\tIPPU.ColorsChanged = TRUE;\n\t\t\t\t\t\tPPU.ForcedBlanking = (Byte >> 7) & 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ((Memory.FillRAM[0x2100] & 0x80) && CPU.V_Counter == PPU.ScreenHeight + FIRST_VISIBLE_LINE)\n\t\t\t\t{\n\t\t\t\t\tPPU.OAMAddr = PPU.SavedOAMAddr;\n\n\t\t\t\t\tuint8 tmp = 0;\n\t\t\t\t\tif (PPU.OAMPriorityRotation)\n\t\t\t\t\t\ttmp = (PPU.OAMAddr & 0xfe) >> 1;\n\t\t\t\t\tif ((PPU.OAMFlip & 1) || PPU.FirstSprite != tmp)\n\t\t\t\t\t{\n\t\t\t\t\t\tPPU.FirstSprite = tmp;\n\t\t\t\t\t\tIPPU.OBJChanged = TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tPPU.OAMFlip = 0;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2101: // OBSEL\n\t\t\t\tif (Byte != Memory.FillRAM[0x2101])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.OBJNameBase = (Byte & 3) << 14;\n\t\t\t\t\tPPU.OBJNameSelect = ((Byte >> 3) & 3) << 13;\n\t\t\t\t\tPPU.OBJSizeSelect = (Byte >> 5) & 7;\n\t\t\t\t\tIPPU.OBJChanged = TRUE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2102: // OAMADDL\n\t\t\t\tPPU.OAMAddr = ((Memory.FillRAM[0x2103] & 1) << 8) | Byte;\n\t\t\t\tPPU.OAMFlip = 0;\n\t\t\t\tPPU.OAMReadFlip = 0;\n\t\t\t\tPPU.SavedOAMAddr = PPU.OAMAddr;\n\t\t\t\tif (PPU.OAMPriorityRotation && PPU.FirstSprite != (PPU.OAMAddr >> 1))\n\t\t\t\t{\n\t\t\t\t\tPPU.FirstSprite = (PPU.OAMAddr & 0xfe) >> 1;\n\t\t\t\t\tIPPU.OBJChanged = TRUE;\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tmissing.sprite_priority_rotation = 1;\n\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2103: // OAMADDH\n\t\t\t\tPPU.OAMAddr = ((Byte & 1) << 8) | Memory.FillRAM[0x2102];\n\t\t\t\tPPU.OAMPriorityRotation = (Byte & 0x80) ? 1 : 0;\n\t\t\t\tif (PPU.OAMPriorityRotation)\n\t\t\t\t{\n\t\t\t\t\tif (PPU.FirstSprite != (PPU.OAMAddr >> 1))\n\t\t\t\t\t{\n\t\t\t\t\t\tPPU.FirstSprite = (PPU.OAMAddr & 0xfe) >> 1;\n\t\t\t\t\t\tIPPU.OBJChanged = TRUE;\n\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t\tmissing.sprite_priority_rotation = 1;\n\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (PPU.FirstSprite != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tPPU.FirstSprite = 0;\n\t\t\t\t\t\tIPPU.OBJChanged = TRUE;\n\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t\tmissing.sprite_priority_rotation = 1;\n\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPPU.OAMFlip = 0;\n\t\t\t\tPPU.OAMReadFlip = 0;\n\t\t\t\tPPU.SavedOAMAddr = PPU.OAMAddr;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2104: // OAMDATA\n\t\t\t\tREGISTER_2104(Byte);\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2105: // BGMODE\n\t\t\t\tif (Byte != Memory.FillRAM[0x2105])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.BG[0].BGSize = (Byte >> 4) & 1;\n\t\t\t\t\tPPU.BG[1].BGSize = (Byte >> 5) & 1;\n\t\t\t\t\tPPU.BG[2].BGSize = (Byte >> 6) & 1;\n\t\t\t\t\tPPU.BG[3].BGSize = (Byte >> 7) & 1;\n\t\t\t\t\tPPU.BGMode = Byte & 7;\n\t\t\t\t\t// BJ: BG3Priority only takes effect if BGMode == 1 and the bit is set\n\t\t\t\t\tPPU.BG3Priority = ((Byte & 0x0f) == 0x09);\n\t\t\t\t\tif (PPU.BGMode == 6 || PPU.BGMode == 5 || PPU.BGMode == 7)\n\t\t\t\t\t    IPPU.Interlace = Memory.FillRAM[0x2133] & 1;\n\t\t\t\t\telse\n\t\t\t\t\t    IPPU.Interlace = 0;\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tmissing.modes[PPU.BGMode] = 1;\n\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2106: // MOSAIC\n\t\t\t\tif (Byte != Memory.FillRAM[0x2106])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.MosaicStart = CPU.V_Counter;\n\t\t\t\t\tif (PPU.MosaicStart > PPU.ScreenHeight)\n\t\t\t\t\t\tPPU.MosaicStart = 0;\n\t\t\t\t\tPPU.Mosaic = (Byte >> 4) + 1;\n\t\t\t\t\tPPU.BGMosaic[0] = (Byte & 1);\n\t\t\t\t\tPPU.BGMosaic[1] = (Byte & 2);\n\t\t\t\t\tPPU.BGMosaic[2] = (Byte & 4);\n\t\t\t\t\tPPU.BGMosaic[3] = (Byte & 8);\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tif ((Byte & 0xf0) && (Byte & 0x0f))\n\t\t\t\t\t\tmissing.mosaic = 1;\n\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2107: // BG1SC\n\t\t\t\tif (Byte != Memory.FillRAM[0x2107])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.BG[0].SCSize = Byte & 3;\n\t\t\t\t\tPPU.BG[0].SCBase = (Byte & 0x7c) << 8;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2108: // BG2SC\n\t\t\t\tif (Byte != Memory.FillRAM[0x2108])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.BG[1].SCSize = Byte & 3;\n\t\t\t\t\tPPU.BG[1].SCBase = (Byte & 0x7c) << 8;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2109: // BG3SC\n\t\t\t\tif (Byte != Memory.FillRAM[0x2109])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.BG[2].SCSize = Byte & 3;\n\t\t\t\t\tPPU.BG[2].SCBase = (Byte & 0x7c) << 8;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x210a: // BG4SC\n\t\t\t\tif (Byte != Memory.FillRAM[0x210a])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.BG[3].SCSize = Byte & 3;\n\t\t\t\t\tPPU.BG[3].SCBase = (Byte & 0x7c) << 8;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x210b: // BG12NBA\n\t\t\t\tif (Byte != Memory.FillRAM[0x210b])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.BG[0].NameBase = (Byte & 7) << 12;\n\t\t\t\t\tPPU.BG[1].NameBase = ((Byte >> 4) & 7) << 12;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x210c: // BG34NBA\n\t\t\t\tif (Byte != Memory.FillRAM[0x210c])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.BG[2].NameBase = (Byte & 7) << 12;\n\t\t\t\t\tPPU.BG[3].NameBase = ((Byte >> 4) & 7) << 12;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x210d: // BG1HOFS, M7HOFS\n\t\t\t\tPPU.BG[0].HOffset = (Byte << 8) | (PPU.BGnxOFSbyte & ~7) | ((PPU.BG[0].HOffset >> 8) & 7);\n\t\t\t\tPPU.M7HOFS = (Byte << 8) | PPU.M7byte;\n\t\t\t\tPPU.BGnxOFSbyte = Byte;\n\t\t\t\tPPU.M7byte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x210e: // BG1VOFS, M7VOFS\n\t\t\t\tPPU.BG[0].VOffset = (Byte << 8) | PPU.BGnxOFSbyte;\n\t\t\t\tPPU.M7VOFS = (Byte << 8) | PPU.M7byte;\n\t\t\t\tPPU.BGnxOFSbyte = Byte;\n\t\t\t\tPPU.M7byte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x210f: // BG2HOFS\n\t\t\t\tPPU.BG[1].HOffset = (Byte << 8) | (PPU.BGnxOFSbyte & ~7) | ((PPU.BG[1].HOffset >> 8) & 7);\n\t\t\t\tPPU.BGnxOFSbyte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2110: // BG2VOFS\n\t\t\t\tPPU.BG[1].VOffset = (Byte << 8) | PPU.BGnxOFSbyte;\n\t\t\t\tPPU.BGnxOFSbyte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2111: // BG3HOFS\n\t\t\t\tPPU.BG[2].HOffset = (Byte << 8) | (PPU.BGnxOFSbyte & ~7) | ((PPU.BG[2].HOffset >> 8) & 7);\n\t\t\t\tPPU.BGnxOFSbyte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2112: // BG3VOFS\n\t\t\t\tPPU.BG[2].VOffset = (Byte << 8) | PPU.BGnxOFSbyte;\n\t\t\t\tPPU.BGnxOFSbyte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2113: // BG4HOFS\n\t\t\t\tPPU.BG[3].HOffset = (Byte << 8) | (PPU.BGnxOFSbyte & ~7) | ((PPU.BG[3].HOffset >> 8) & 7);\n\t\t\t\tPPU.BGnxOFSbyte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2114: // BG4VOFS\n\t\t\t\tPPU.BG[3].VOffset = (Byte << 8) | PPU.BGnxOFSbyte;\n\t\t\t\tPPU.BGnxOFSbyte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2115: // VMAIN\n\t\t\t\tPPU.VMA.High = (Byte & 0x80) == 0 ? FALSE : TRUE;\n\t\t\t\tswitch (Byte & 3)\n\t\t\t\t{\n\t\t\t\t\tcase 0: PPU.VMA.Increment = 1;   break;\n\t\t\t\t\tcase 1: PPU.VMA.Increment = 32;  break;\n\t\t\t\t\tcase 2: PPU.VMA.Increment = 128; break;\n\t\t\t\t\tcase 3: PPU.VMA.Increment = 128; break;\n\t\t\t\t}\n\n\t\t\t\tif (Byte & 0x0c)\n\t\t\t\t{\n\t\t\t\t\tstatic uint16 Shift[4]    = { 0, 5, 6, 7 };\n\t\t\t\t\tstatic uint16 IncCount[4] = { 0, 32, 64, 128 };\n\n\t\t\t\t\tuint8 i = (Byte & 0x0c) >> 2;\n\t\t\t\t\tPPU.VMA.FullGraphicCount = IncCount[i];\n\t\t\t\t\tPPU.VMA.Mask1 = IncCount[i] * 8 - 1;\n\t\t\t\t\tPPU.VMA.Shift = Shift[i];\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tmissing.vram_full_graphic_inc = (Byte & 0x0c) >> 2;\n\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tPPU.VMA.FullGraphicCount = 0;\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tif (Byte & 3)\n\t\t\t\t\tmissing.vram_inc = Byte & 3;\n\t\t\t#endif\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2116: // VMADDL\n\t\t\t\tPPU.VMA.Address &= 0xff00;\n\t\t\t\tPPU.VMA.Address |= Byte;\n\n\t\t\t\tS9xUpdateVRAMReadBuffer();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2117: // VMADDH\n\t\t\t\tPPU.VMA.Address &= 0x00ff;\n\t\t\t\tPPU.VMA.Address |= Byte << 8;\n\n\t\t\t\tS9xUpdateVRAMReadBuffer();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2118: // VMDATAL\n\t\t\t\tREGISTER_2118(Byte);\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2119: // VMDATAH\n\t\t\t\tREGISTER_2119(Byte);\n\t\t\t\tbreak;\n\n\t\t\tcase 0x211a: // M7SEL\n\t\t\t\tif (Byte != Memory.FillRAM[0x211a])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.Mode7Repeat = Byte >> 6;\n\t\t\t\t\tif (PPU.Mode7Repeat == 1)\n\t\t\t\t\t\tPPU.Mode7Repeat = 0;\n\t\t\t\t\tPPU.Mode7VFlip = (Byte & 2) >> 1;\n\t\t\t\t\tPPU.Mode7HFlip = Byte & 1;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x211b: // M7A\n\t\t\t\tPPU.MatrixA = PPU.M7byte | (Byte << 8);\n\t\t\t\tPPU.Need16x8Mulitply = TRUE;\n\t\t\t\tPPU.M7byte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x211c: // M7B\n\t\t\t\tPPU.MatrixB = PPU.M7byte | (Byte << 8);\n\t\t\t\tPPU.Need16x8Mulitply = TRUE;\n\t\t\t\tPPU.M7byte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x211d: // M7C\n\t\t\t\tPPU.MatrixC = PPU.M7byte | (Byte << 8);\n\t\t\t\tPPU.M7byte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x211e: // M7D\n\t\t\t\tPPU.MatrixD = PPU.M7byte | (Byte << 8);\n\t\t\t\tPPU.M7byte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x211f: // M7X\n\t\t\t\tPPU.CentreX = PPU.M7byte | (Byte << 8);\n\t\t\t\tPPU.M7byte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2120: // M7Y\n\t\t\t\tPPU.CentreY = PPU.M7byte | (Byte << 8);\n\t\t\t\tPPU.M7byte = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2121: // CGADD\n\t\t\t\tPPU.CGFLIP = 0;\n\t\t\t\tPPU.CGFLIPRead = 0;\n\t\t\t\tPPU.CGADD = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2122: // CGDATA\n\t\t\t\tREGISTER_2122(Byte);\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2123: // W12SEL\n\t\t\t\tif (Byte != Memory.FillRAM[0x2123])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.ClipWindow1Enable[0] = !!(Byte & 0x02);\n\t\t\t\t\tPPU.ClipWindow1Enable[1] = !!(Byte & 0x20);\n\t\t\t\t\tPPU.ClipWindow2Enable[0] = !!(Byte & 0x08);\n\t\t\t\t\tPPU.ClipWindow2Enable[1] = !!(Byte & 0x80);\n\t\t\t\t\tPPU.ClipWindow1Inside[0] = !(Byte & 0x01);\n\t\t\t\t\tPPU.ClipWindow1Inside[1] = !(Byte & 0x10);\n\t\t\t\t\tPPU.ClipWindow2Inside[0] = !(Byte & 0x04);\n\t\t\t\t\tPPU.ClipWindow2Inside[1] = !(Byte & 0x40);\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tif (Byte & 0x80)\n\t\t\t\t\t\tmissing.window2[1] = 1;\n\t\t\t\t\tif (Byte & 0x20)\n\t\t\t\t\t\tmissing.window1[1] = 1;\n\t\t\t\t\tif (Byte & 0x08)\n\t\t\t\t\t\tmissing.window2[0] = 1;\n\t\t\t\t\tif (Byte & 0x02)\n\t\t\t\t\t\tmissing.window1[0] = 1;\n\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2124: // W34SEL\n\t\t\t\tif (Byte != Memory.FillRAM[0x2124])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.ClipWindow1Enable[2] = !!(Byte & 0x02);\n\t\t\t\t\tPPU.ClipWindow1Enable[3] = !!(Byte & 0x20);\n\t\t\t\t\tPPU.ClipWindow2Enable[2] = !!(Byte & 0x08);\n\t\t\t\t\tPPU.ClipWindow2Enable[3] = !!(Byte & 0x80);\n\t\t\t\t\tPPU.ClipWindow1Inside[2] = !(Byte & 0x01);\n\t\t\t\t\tPPU.ClipWindow1Inside[3] = !(Byte & 0x10);\n\t\t\t\t\tPPU.ClipWindow2Inside[2] = !(Byte & 0x04);\n\t\t\t\t\tPPU.ClipWindow2Inside[3] = !(Byte & 0x40);\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tif (Byte & 0x80)\n\t\t\t\t\t\tmissing.window2[3] = 1;\n\t\t\t\t\tif (Byte & 0x20)\n\t\t\t\t\t\tmissing.window1[3] = 1;\n\t\t\t\t\tif (Byte & 0x08)\n\t\t\t\t\t\tmissing.window2[2] = 1;\n\t\t\t\t\tif (Byte & 0x02)\n\t\t\t\t\t\tmissing.window1[2] = 1;\n\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2125: // WOBJSEL\n\t\t\t\tif (Byte != Memory.FillRAM[0x2125])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.ClipWindow1Enable[4] = !!(Byte & 0x02);\n\t\t\t\t\tPPU.ClipWindow1Enable[5] = !!(Byte & 0x20);\n\t\t\t\t\tPPU.ClipWindow2Enable[4] = !!(Byte & 0x08);\n\t\t\t\t\tPPU.ClipWindow2Enable[5] = !!(Byte & 0x80);\n\t\t\t\t\tPPU.ClipWindow1Inside[4] = !(Byte & 0x01);\n\t\t\t\t\tPPU.ClipWindow1Inside[5] = !(Byte & 0x10);\n\t\t\t\t\tPPU.ClipWindow2Inside[4] = !(Byte & 0x04);\n\t\t\t\t\tPPU.ClipWindow2Inside[5] = !(Byte & 0x40);\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tif (Byte & 0x80)\n\t\t\t\t\t\tmissing.window2[5] = 1;\n\t\t\t\t\tif (Byte & 0x20)\n\t\t\t\t\t\tmissing.window1[5] = 1;\n\t\t\t\t\tif (Byte & 0x08)\n\t\t\t\t\t\tmissing.window2[4] = 1;\n\t\t\t\t\tif (Byte & 0x02)\n\t\t\t\t\t\tmissing.window1[4] = 1;\n\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2126: // WH0\n\t\t\t\tif (Byte != Memory.FillRAM[0x2126])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.Window1Left = Byte;\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2127: // WH1\n\t\t\t\tif (Byte != Memory.FillRAM[0x2127])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.Window1Right = Byte;\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2128: // WH2\n\t\t\t\tif (Byte != Memory.FillRAM[0x2128])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.Window2Left = Byte;\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2129: // WH3\n\t\t\t\tif (Byte != Memory.FillRAM[0x2129])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.Window2Right = Byte;\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x212a: // WBGLOG\n\t\t\t\tif (Byte != Memory.FillRAM[0x212a])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.ClipWindowOverlapLogic[0] = (Byte & 0x03);\n\t\t\t\t\tPPU.ClipWindowOverlapLogic[1] = (Byte & 0x0c) >> 2;\n\t\t\t\t\tPPU.ClipWindowOverlapLogic[2] = (Byte & 0x30) >> 4;\n\t\t\t\t\tPPU.ClipWindowOverlapLogic[3] = (Byte & 0xc0) >> 6;\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x212b: // WOBJLOG\n\t\t\t\tif (Byte != Memory.FillRAM[0x212b])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.ClipWindowOverlapLogic[4] = (Byte & 0x03);\n\t\t\t\t\tPPU.ClipWindowOverlapLogic[5] = (Byte & 0x0c) >> 2;\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x212c: // TM\n\t\t\t\tif (Byte != Memory.FillRAM[0x212c])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x212d: // TS\n\t\t\t\tif (Byte != Memory.FillRAM[0x212d])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tif (Byte & 0x1f)\n\t\t\t\t\t\tmissing.subscreen = 1;\n\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x212e: // TMW\n\t\t\t\tif (Byte != Memory.FillRAM[0x212e])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x212f: // TSW\n\t\t\t\tif (Byte != Memory.FillRAM[0x212f])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2130: // CGWSEL\n\t\t\t\tif (Byte != Memory.FillRAM[0x2130])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tPPU.RecomputeClipWindows = TRUE;\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tif ((Byte & 1) && (PPU.BGMode == 3 || PPU.BGMode == 4 || PPU.BGMode == 7))\n\t\t\t\t\t\tmissing.direct = 1;\n\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2131: // CGADSUB\n\t\t\t\tif (Byte != Memory.FillRAM[0x2131])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tif (Byte & 0x80)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Memory.FillRAM[0x2130] & 0x02)\n\t\t\t\t\t\t\tmissing.subscreen_sub = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmissing.fixed_colour_sub = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (Memory.FillRAM[0x2130] & 0x02)\n\t\t\t\t\t\t\tmissing.subscreen_add = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmissing.fixed_colour_add = 1;\n\t\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2132: // COLDATA\n\t\t\t\tif (Byte != Memory.FillRAM[0x2132])\n\t\t\t\t{\n\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\tif (Byte & 0x80)\n\t\t\t\t\t\tPPU.FixedColourBlue  = Byte & 0x1f;\n\t\t\t\t\tif (Byte & 0x40)\n\t\t\t\t\t\tPPU.FixedColourGreen = Byte & 0x1f;\n\t\t\t\t\tif (Byte & 0x20)\n\t\t\t\t\t\tPPU.FixedColourRed   = Byte & 0x1f;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2133: // SETINI\n\t\t\t\tif (Byte != Memory.FillRAM[0x2133])\n\t\t\t\t{\n\t\t\t\t\tif ((Memory.FillRAM[0x2133] ^ Byte) & 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\t\tIPPU.PseudoHires = Byte & 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Byte & 0x04)\n\t\t\t\t\t{\n\t\t\t\t\t\tPPU.ScreenHeight = SNES_HEIGHT_EXTENDED;\n\t\t\t\t\t\tif (IPPU.DoubleHeightPixels)\n\t\t\t\t\t\t\tIPPU.RenderedScreenHeight = PPU.ScreenHeight << 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tIPPU.RenderedScreenHeight = PPU.ScreenHeight;\n\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t\tmissing.lines_239 = 1;\n\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tPPU.ScreenHeight = SNES_HEIGHT;\n\t\t\t\t\t\tif (IPPU.DoubleHeightPixels)\n\t\t\t\t\t\t\tIPPU.RenderedScreenHeight = PPU.ScreenHeight << 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tIPPU.RenderedScreenHeight = PPU.ScreenHeight;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((Memory.FillRAM[0x2133] ^ Byte) & 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tFLUSH_REDRAW();\n\t\t\t\t\t\tif ((Memory.FillRAM[0x2133] ^ Byte) & 2)\n\t\t\t\t\t\t\tIPPU.OBJChanged = TRUE;\n\n\t\t\t\t\t\tIPPU.Interlace = Byte & 1;\n\t\t\t\t\t\tIPPU.InterlaceOBJ = Byte & 2;\n\t\t\t\t\t}\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tif (Byte & 0x40)\n\t\t\t\t\t\tmissing.mode7_bgmode = 1;\n\t\t\t\t\tif (Byte & 0x08)\n\t\t\t\t\t\tmissing.pseudo_512 = 1;\n\t\t\t\t\tif (Byte & 0x02)\n\t\t\t\t\t\tmissing.sprite_double_height = 1;\n\t\t\t\t\tif (Byte & 0x01)\n\t\t\t\t\t\tmissing.interlace = 1;\n\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2134: // MPYL\n\t\t\tcase 0x2135: // MPYM\n\t\t\tcase 0x2136: // MPYH\n\t\t\tcase 0x2137: // SLHV\n\t\t\tcase 0x2138: // OAMDATAREAD\n\t\t\tcase 0x2139: // VMDATALREAD\n\t\t\tcase 0x213a: // VMDATAHREAD\n\t\t\tcase 0x213b: // CGDATAREAD\n\t\t\tcase 0x213c: // OPHCT\n\t\t\tcase 0x213d: // OPVCT\n\t\t\tcase 0x213e: // STAT77\n\t\t\tcase 0x213f: // STAT78\n\t\t\t\treturn;\n\n\t\t\tcase 0x2180: // WMDATA\n\t\t\t\tif (!CPU.InWRAMDMAorHDMA)\n\t\t\t\t\tREGISTER_2180(Byte);\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2181: // WMADDL\n\t\t\t\tif (!CPU.InWRAMDMAorHDMA)\n\t\t\t\t{\n\t\t\t\t\tPPU.WRAM &= 0x1ff00;\n\t\t\t\t\tPPU.WRAM |= Byte;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2182: // WMADDM\n\t\t\t\tif (!CPU.InWRAMDMAorHDMA)\n\t\t\t\t{\n\t\t\t\t\tPPU.WRAM &= 0x100ff;\n\t\t\t\t\tPPU.WRAM |= Byte << 8;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x2183: // WMADDH\n\t\t\t\tif (!CPU.InWRAMDMAorHDMA)\n\t\t\t\t{\n\t\t\t\t\tPPU.WRAM &= 0x0ffff;\n\t\t\t\t\tPPU.WRAM |= Byte << 16;\n\t\t\t\t\tPPU.WRAM &= 0x1ffff;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (Settings.SuperFX && Address >= 0x3000 && Address <= 0x32ff)\n\t\t{\n\t\t\tS9xSetSuperFX(Byte, Address);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\tif (Settings.SA1     && Address >= 0x2200)\n\t\t{\n\t\t\tif (Address <= 0x23ff)\n\t\t\t\tS9xSetSA1(Byte, Address);\n\t\t\telse\n\t\t\t\tMemory.FillRAM[Address] = Byte;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\tif (Settings.BS      && Address >= 0x2188 && Address <= 0x219f)\n\t\t\tS9xSetBSXPPU(Byte, Address);\n\t\telse\n\t\tif (Settings.SRTC    && Address == 0x2801)\n\t\t\tS9xSetSRTC(Byte, Address);\n\t#ifdef DEBUGGER\n\t\telse\n\t\t{\n\t\t\tmissing.unknownppu_write = Address;\n\t\t\tif (Settings.TraceUnknownRegisters)\n\t\t\t{\n\t\t\t\tsprintf(String, \"Unknown register write: $%02X->$%04X\\n\", Byte, Address);\n\t\t\t\tS9xMessage(S9X_TRACE, S9X_PPU_TRACE, String);\n\t\t\t}\n\t\t}\n\t#endif\n\t}\n\n\tMemory.FillRAM[Address] = Byte;\n}\n\nuint8 S9xGetPPU (uint16 Address)\n{\n\t// MAP_PPU: $2000-$3FFF\n\tif (Settings.MSU1 && (Address & 0xfff8) == 0x2000)\n\t\treturn (S9xMSU1ReadPort(Address & 7));\n\telse\n\tif (Address < 0x2100)\n\t\treturn (OpenBus);\n\n\tif (CPU.InDMAorHDMA)\n\t{\n\t\tif (CPU.CurrentDMAorHDMAChannel >= 0 && !DMA[CPU.CurrentDMAorHDMAChannel].ReverseTransfer)\n\t\t{\n\t\t\t// S9xGetPPU() is called to read from DMA[].AAddress\n\t\t\tif ((Address & 0xff00) == 0x2100)\n\t\t\t\t// Cannot access to Address Bus B ($2100-$21FF) via (H)DMA\n\t\t\t\treturn (OpenBus);\n\t\t\telse\n\t\t\t\t// $2200-$3FFF are connected to Address Bus A\n\t\t\t\t// SA1, SuperFX and SRTC are mapped here\n\t\t\t\t// I don't bother for now...\n\t\t\t\treturn (OpenBus);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// S9xGetPPU() is called to write to $21xx\n\t\t\t// Take care of DMA wrapping\n\t\t\tif (Address > 0x21ff)\n\t\t\t\tAddress = 0x2100 + (Address & 0xff);\n\t\t}\n\t}\n\n\tif ((Address & 0xffc0) == 0x2140) // APUIO0, APUIO1, APUIO2, APUIO3\n\t\t// read_port will run the APU until given APU time before reading value\n\t\treturn (S9xAPUReadPort(Address & 3));\n\telse\n\tif (Address <= 0x2183)\n    {\n\t\tuint8\tbyte;\n\n\t\tswitch (Address)\n\t\t{\n\t\t\tcase 0x2104: // OAMDATA\n\t\t\tcase 0x2105: // BGMODE\n\t\t\tcase 0x2106: // MOSAIC\n\t\t\tcase 0x2108: // BG2SC\n\t\t\tcase 0x2109: // BG3SC\n\t\t\tcase 0x210a: // BG4SC\n\t\t\tcase 0x2114: // BG4VOFS\n\t\t\tcase 0x2115: // VMAIN\n\t\t\tcase 0x2116: // VMADDL\n\t\t\tcase 0x2118: // VMDATAL\n\t\t\tcase 0x2119: // VMDATAH\n\t\t\tcase 0x211a: // M7SEL\n\t\t\tcase 0x2124: // W34SEL\n\t\t\tcase 0x2125: // WOBJSEL\n\t\t\tcase 0x2126: // WH0\n\t\t\tcase 0x2128: // WH2\n\t\t\tcase 0x2129: // WH3\n\t\t\tcase 0x212a: // WBGLOG\n\t\t\t\treturn (PPU.OpenBus1);\n\n\t\t\tcase 0x2134: // MPYL\n\t\t\tcase 0x2135: // MPYM\n\t\t\tcase 0x2136: // MPYH\n\t\t\t\tif (PPU.Need16x8Mulitply)\n\t\t\t\t{\n\t\t\t\t\tint32 r = (int32) PPU.MatrixA * (int32) (PPU.MatrixB >> 8);\n\t\t\t\t\tMemory.FillRAM[0x2134] = (uint8) r;\n\t\t\t\t\tMemory.FillRAM[0x2135] = (uint8) (r >> 8);\n\t\t\t\t\tMemory.FillRAM[0x2136] = (uint8) (r >> 16);\n\t\t\t\t\tPPU.Need16x8Mulitply = FALSE;\n\t\t\t\t}\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.matrix_multiply = 1;\n\t\t\t#endif\n\t\t\t\treturn (PPU.OpenBus1 = Memory.FillRAM[Address]);\n\n\t\t\tcase 0x2137: // SLHV\n\t\t\t\tS9xLatchCounters(0);\n\t\t\t\treturn (PPU.OpenBus1);\n\n\t\t\tcase 0x2138: // OAMDATAREAD\n\t\t\t\tif (PPU.OAMAddr & 0x100)\n\t\t\t\t{\n\t\t\t\t\tif (!(PPU.OAMFlip & 1))\n\t\t\t\t\t\tbyte = PPU.OAMData[(PPU.OAMAddr & 0x10f) << 1];\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbyte = PPU.OAMData[((PPU.OAMAddr & 0x10f) << 1) + 1];\n\t\t\t\t\t\tPPU.OAMAddr = (PPU.OAMAddr + 1) & 0x1ff;\n\t\t\t\t\t\tif (PPU.OAMPriorityRotation && PPU.FirstSprite != (PPU.OAMAddr >> 1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPPU.FirstSprite = (PPU.OAMAddr & 0xfe) >> 1;\n\t\t\t\t\t\t\tIPPU.OBJChanged = TRUE;\n\t\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t\t\tmissing.sprite_priority_rotation = 1;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!(PPU.OAMFlip & 1))\n\t\t\t\t\t\tbyte = PPU.OAMData[PPU.OAMAddr << 1];\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbyte = PPU.OAMData[(PPU.OAMAddr << 1) + 1];\n\t\t\t\t\t\t++PPU.OAMAddr;\n\t\t\t\t\t\tif (PPU.OAMPriorityRotation && PPU.FirstSprite != (PPU.OAMAddr >> 1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPPU.FirstSprite = (PPU.OAMAddr & 0xfe) >> 1;\n\t\t\t\t\t\t\tIPPU.OBJChanged = TRUE;\n\t\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t\t\tmissing.sprite_priority_rotation = 1;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPPU.OAMFlip ^= 1;\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.oam_read = 1;\n\t\t\t#endif\n\t\t\t\treturn (PPU.OpenBus1 = byte);\n\n\t\t\tcase 0x2139: // VMDATALREAD\n\t\t\t\tbyte = PPU.VRAMReadBuffer & 0xff;\n\t\t\t\tif (!PPU.VMA.High)\n\t\t\t\t{\n\t\t\t\t\tS9xUpdateVRAMReadBuffer();\n\n\t\t\t\t\tPPU.VMA.Address += PPU.VMA.Increment;\n\t\t\t\t}\n\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.vram_read = 1;\n\t\t\t#endif\n\t\t\t\treturn (PPU.OpenBus1 = byte);\n\n\t\t\tcase 0x213a: // VMDATAHREAD\n\t\t\t\tbyte = (PPU.VRAMReadBuffer >> 8) & 0xff;\n\t\t\t\tif (PPU.VMA.High)\n\t\t\t\t{\n\t\t\t\t\tS9xUpdateVRAMReadBuffer();\n\n\t\t\t\t\tPPU.VMA.Address += PPU.VMA.Increment;\n\t\t\t\t}\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.vram_read = 1;\n\t\t\t#endif\n\t\t\t\treturn (PPU.OpenBus1 = byte);\n\n\t\t\tcase 0x213b: // CGDATAREAD\n\t\t\t\tif (PPU.CGFLIPRead)\n\t\t\t\t\tbyte = (PPU.OpenBus2 & 0x80) | ((PPU.CGDATA[PPU.CGADD++] >> 8) & 0x7f);\n\t\t\t\telse\n\t\t\t\t\tbyte = PPU.CGDATA[PPU.CGADD] & 0xff;\n\t\t\t\tPPU.CGFLIPRead ^= 1;\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.cgram_read = 1;\n\t\t\t#endif\n\t\t\t\treturn (PPU.OpenBus2 = byte);\n\n\t\t\tcase 0x213c: // OPHCT\n\t\t\t\tS9xTryGunLatch(false);\n\t\t\t\tif (PPU.HBeamFlip)\n\t\t\t\t\tbyte = (PPU.OpenBus2 & 0xfe) | ((PPU.HBeamPosLatched >> 8) & 0x01);\n\t\t\t\telse\n\t\t\t\t\tbyte = (uint8) PPU.HBeamPosLatched;\n\t\t\t\tPPU.HBeamFlip ^= 1;\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.h_counter_read = 1;\n\t\t\t#endif\n\t\t\t\treturn (PPU.OpenBus2 = byte);\n\n\t\t\tcase 0x213d: // OPVCT\n\t\t\t\tS9xTryGunLatch(false);\n\t\t\t\tif (PPU.VBeamFlip)\n\t\t\t\t\tbyte = (PPU.OpenBus2 & 0xfe) | ((PPU.VBeamPosLatched >> 8) & 0x01);\n\t\t\t\telse\n\t\t\t\t\tbyte = (uint8) PPU.VBeamPosLatched;\n\t\t\t\tPPU.VBeamFlip ^= 1;\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.v_counter_read = 1;\n\t\t\t#endif\n\t\t\t\treturn (PPU.OpenBus2 = byte);\n\n\t\t\tcase 0x213e: // STAT77\n\t\t\t\tFLUSH_REDRAW();\n\t\t\t\tbyte = (PPU.OpenBus1 & 0x10) | PPU.RangeTimeOver | Model->_5C77;\n\t\t\t\treturn (PPU.OpenBus1 = byte);\n\n\t\t\tcase 0x213f: // STAT78\n\t\t\t\tS9xTryGunLatch(false);\n\t\t\t\tPPU.VBeamFlip = PPU.HBeamFlip = 0;\n\t\t\t\tbyte = (PPU.OpenBus2 & 0x20) | (Memory.FillRAM[0x213f] & 0xc0) | (Settings.PAL ? 0x10 : 0) | Model->_5C78;\n\t\t\t\tMemory.FillRAM[0x213f] &= ~0x40;\n\t\t\t\treturn (PPU.OpenBus2 = byte);\n\n\t\t\tcase 0x2180: // WMDATA\n\t\t\t\tif (!CPU.InWRAMDMAorHDMA)\n\t\t\t\t{\n\t\t\t\t\tbyte = Memory.RAM[PPU.WRAM++];\n\t\t\t\t\tPPU.WRAM &= 0x1ffff;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbyte = OpenBus;\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.wram_read = 1;\n\t\t\t#endif\n\t\t\t\treturn (byte);\n\n\t\t\tdefault:\n\t\t\t\treturn (OpenBus);\n\t\t}\n\t}\n\telse\n    {\n\t\tif (Settings.SuperFX && Address >= 0x3000 && Address <= 0x32ff)\n\t\t\treturn (S9xGetSuperFX(Address));\n\t\telse\n\t\tif (Settings.SA1     && Address >= 0x2200)\n\t\t\treturn (S9xGetSA1(Address));\n\t\telse\n\t\tif (Settings.BS      && Address >= 0x2188 && Address <= 0x219f)\n\t\t\treturn (S9xGetBSXPPU(Address));\n\t\telse\n\t\tif (Settings.SRTC    && Address == 0x2800)\n\t\t\treturn (S9xGetSRTC(Address));\n\t\telse\n\t\tswitch (Address)\n\t\t{\n\t\t\tcase 0x21c2:\n\t\t\t\tif (Model->_5C77 == 2)\n\t\t\t\t\treturn (0x20);\n\t\t\t\treturn (OpenBus);\n\n\t\t\tcase 0x21c3:\n\t\t\t\tif (Model->_5C77 == 2)\n\t\t\t\t\treturn (0);\n\t\t\t\treturn (OpenBus);\n\n\t\t\tdefault:\n\t\t\t\treturn (OpenBus);\n\t\t}\n\t}\n}\n\nvoid S9xSetCPU (uint8 Byte, uint16 Address)\n{\n\tif (Address < 0x4200)\n\t{\n\t\tswitch (Address)\n\t\t{\n\t\t\tcase 0x4016: // JOYSER0\n\t\t\t\tS9xSetJoypadLatch(Byte & 1);\n\t\t\t\tbreak;\n\n\t\t\tcase 0x4017: // JOYSER1\n\t\t\t\treturn;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\tif ((Address & 0xff80) == 0x4300)\n\t{\n\t\tif (CPU.InDMAorHDMA)\n\t\t\treturn;\n\n\t\tint\td = (Address >> 4) & 0x7;\n\n\t\tswitch (Address & 0xf)\n\t\t{\n\t\t\tcase 0x0: // 0x43x0: DMAPx\n\t\t\t\tDMA[d].ReverseTransfer        = (Byte & 0x80) ? TRUE : FALSE;\n\t\t\t\tDMA[d].HDMAIndirectAddressing = (Byte & 0x40) ? TRUE : FALSE;\n\t\t\t\tDMA[d].UnusedBit43x0          = (Byte & 0x20) ? TRUE : FALSE;\n\t\t\t\tDMA[d].AAddressDecrement      = (Byte & 0x10) ? TRUE : FALSE;\n\t\t\t\tDMA[d].AAddressFixed          = (Byte & 0x08) ? TRUE : FALSE;\n\t\t\t\tDMA[d].TransferMode           = (Byte & 7);\n\t\t\t\treturn;\n\n\t\t\tcase 0x1: // 0x43x1: BBADx\n\t\t\t\tDMA[d].BAddress = Byte;\n\t\t\t\treturn;\n\n\t\t\tcase 0x2: // 0x43x2: A1TxL\n\t\t\t\tDMA[d].AAddress &= 0xff00;\n\t\t\t\tDMA[d].AAddress |= Byte;\n\t\t\t\treturn;\n\n\t\t\tcase 0x3: // 0x43x3: A1TxH\n\t\t\t\tDMA[d].AAddress &= 0xff;\n\t\t\t\tDMA[d].AAddress |= Byte << 8;\n\t\t\t\treturn;\n\n\t\t\tcase 0x4: // 0x43x4: A1Bx\n\t\t\t\tDMA[d].ABank = Byte;\n\t\t\t\tHDMAMemPointers[d] = NULL;\n\t\t\t\treturn;\n\n\t\t\tcase 0x5: // 0x43x5: DASxL\n\t\t\t\tDMA[d].DMACount_Or_HDMAIndirectAddress &= 0xff00;\n\t\t\t\tDMA[d].DMACount_Or_HDMAIndirectAddress |= Byte;\n\t\t\t\tHDMAMemPointers[d] = NULL;\n\t\t\t\treturn;\n\n\t\t\tcase 0x6: // 0x43x6: DASxH\n\t\t\t\tDMA[d].DMACount_Or_HDMAIndirectAddress &= 0xff;\n\t\t\t\tDMA[d].DMACount_Or_HDMAIndirectAddress |= Byte << 8;\n\t\t\t\tHDMAMemPointers[d] = NULL;\n\t\t\t\treturn;\n\n\t\t\tcase 0x7: // 0x43x7: DASBx\n\t\t\t\tDMA[d].IndirectBank = Byte;\n\t\t\t\tHDMAMemPointers[d] = NULL;\n\t\t\t\treturn;\n\n\t\t\tcase 0x8: // 0x43x8: A2AxL\n\t\t\t\tDMA[d].Address &= 0xff00;\n\t\t\t\tDMA[d].Address |= Byte;\n\t\t\t\tHDMAMemPointers[d] = NULL;\n\t\t\t\treturn;\n\n\t\t\tcase 0x9: // 0x43x9: A2AxH\n\t\t\t\tDMA[d].Address &= 0xff;\n\t\t\t\tDMA[d].Address |= Byte << 8;\n\t\t\t\tHDMAMemPointers[d] = NULL;\n\t\t\t\treturn;\n\n\t\t\tcase 0xa: // 0x43xa: NLTRx\n\t\t\t\tif (Byte & 0x7f)\n\t\t\t\t{\n\t\t\t\t\tDMA[d].LineCount = Byte & 0x7f;\n\t\t\t\t\tDMA[d].Repeat = !(Byte & 0x80);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDMA[d].LineCount = 128;\n\t\t\t\t\tDMA[d].Repeat = !!(Byte & 0x80);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\n\t\t\tcase 0xb: // 0x43xb: ????x\n\t\t\tcase 0xf: // 0x43xf: mirror of 0x43xb\n\t\t\t\tDMA[d].UnknownByte = Byte;\n\t\t\t\treturn;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint16\tpos;\n\n\t\tswitch (Address)\n\t\t{\n\t\t\tcase 0x4200: // NMITIMEN\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\tif (Settings.TraceHCEvent)\n\t\t\t\t\tS9xTraceFormattedMessage(\"Write to 0x4200. Byte is %2x was %2x\\n\", Byte, Memory.FillRAM[Address]);\n\t\t\t\t#endif\n\n\t\t\t\tif (Byte == Memory.FillRAM[0x4200])\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (Byte & 0x20)\n\t\t\t\t{\n\t\t\t\t\tPPU.VTimerEnabled = TRUE;\n\n\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tmissing.virq = 1;\n\t\t\t\t\tmissing.virq_pos = PPU.IRQVBeamPos;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tPPU.VTimerEnabled = FALSE;\n\n\t\t\t\tif (Byte & 0x10)\n\t\t\t\t{\n\t\t\t\t\tPPU.HTimerEnabled = TRUE;\n\n\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tmissing.hirq = 1;\n\t\t\t\t\tmissing.hirq_pos = PPU.IRQHBeamPos;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tPPU.HTimerEnabled = FALSE;\n\n\t\t\t\tif (!(Byte & 0x10) && !(Byte & 0x20))\n\t\t\t\t{\n\t\t\t\t\tCPU.IRQLine = FALSE;\n\t\t\t\t\tCPU.IRQTransition = FALSE;\n\t\t\t\t}\n\n\t\t\t\tif ((Byte & 0x30) != (Memory.FillRAM[0x4200] & 0x30))\n\t\t\t\t{\n\t\t\t\t\t// Only allow instantaneous IRQ if turning it completely on or off\n\t\t\t\t\tif ((Byte & 0x30) == 0 || (Memory.FillRAM[0x4200] & 0x30) == 0)\n\t\t\t\t\t\tS9xUpdateIRQPositions(true);\n\t\t\t\t\telse\n\t\t\t\t\t\tS9xUpdateIRQPositions(false);\n\t\t\t\t}\n\n\t\t\t\t// NMI can trigger immediately during VBlank as long as NMI_read ($4210) wasn't cleard.\n\t\t\t\tif ((Byte & 0x80) && !(Memory.FillRAM[0x4200] & 0x80) &&\n\t\t\t\t\t(CPU.V_Counter >= PPU.ScreenHeight + FIRST_VISIBLE_LINE) && (Memory.FillRAM[0x4210] & 0x80))\n\t\t\t\t{\n\t\t\t\t\t// FIXME: triggered at HC+=6, checked just before the final CPU cycle,\n\t\t\t\t\t// then, when to call S9xOpcode_NMI()?\n\t\t\t\t\tTimings.IRQFlagChanging |= IRQ_TRIGGER_NMI;\n\n\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\tif (Settings.TraceHCEvent)\n\t\t\t\t\t\tS9xTraceFormattedMessage(\"NMI Triggered on low-to-high occurring at next HC=%d\\n\", Timings.NMITriggerPos);\n\t\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\t#ifdef DEBUGGER\n\t\t\t\tS9xTraceFormattedMessage(\"--- IRQ Timer Enable HTimer:%d Pos:%04d  VTimer:%d Pos:%03d\",\n\t\t\t\tPPU.HTimerEnabled, PPU.HTimerPosition, PPU.VTimerEnabled, PPU.VTimerPosition);\n\t\t\t\t#endif\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x4201: // WRIO\n\t\t\t\tif ((Byte & 0x80) == 0 && (Memory.FillRAM[0x4213] & 0x80) == 0x80)\n\t\t\t\t\tS9xLatchCounters(1);\n\t\t\t\telse\n\t\t\t\t\tS9xTryGunLatch((Byte & 0x80) ? true : false);\n\t\t\t\tMemory.FillRAM[0x4201] = Memory.FillRAM[0x4213] = Byte;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x4202: // WRMPYA\n\t\t\t\tbreak;\n\n\t\t\tcase 0x4203: // WRMPYB\n\t\t\t{\n\t\t\t\tuint32 res = Memory.FillRAM[0x4202] * Byte;\n\t\t\t\t// FIXME: The update occurs 8 machine cycles after $4203 is set.\n\t\t\t\tMemory.FillRAM[0x4216] = (uint8) res;\n\t\t\t\tMemory.FillRAM[0x4217] = (uint8) (res >> 8);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase 0x4204: // WRDIVL\n\t\t\tcase 0x4205: // WRDIVH\n\t\t\t\tbreak;\n\n\t\t\tcase 0x4206: // WRDIVB\n\t\t\t{\n\t\t\t\tuint16 a = Memory.FillRAM[0x4204] + (Memory.FillRAM[0x4205] << 8);\n\t\t\t\tuint16 div = Byte ? a / Byte : 0xffff;\n\t\t\t\tuint16 rem = Byte ? a % Byte : a;\n\t\t\t\t// FIXME: The update occurs 16 machine cycles after $4206 is set.\n\t\t\t\tMemory.FillRAM[0x4214] = (uint8) div;\n\t\t\t\tMemory.FillRAM[0x4215] = div >> 8;\n\t\t\t\tMemory.FillRAM[0x4216] = (uint8) rem;\n\t\t\t\tMemory.FillRAM[0x4217] = rem >> 8;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase 0x4207: // HTIMEL\n\t\t\t\tpos = PPU.IRQHBeamPos;\n\t\t\t\tPPU.IRQHBeamPos = (PPU.IRQHBeamPos & 0xff00) | Byte;\n\t\t\t\tif (PPU.IRQHBeamPos != pos)\n\t\t\t\t\tS9xUpdateIRQPositions(false);\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.hirq_pos = PPU.IRQHBeamPos;\n\t\t\t#endif\n\t\t\t\tbreak;\n\n\t\t\tcase 0x4208: // HTIMEH\n\t\t\t\tpos = PPU.IRQHBeamPos;\n\t\t\t\tPPU.IRQHBeamPos = (PPU.IRQHBeamPos & 0xff) | ((Byte & 1) << 8);\n\t\t\t\tif (PPU.IRQHBeamPos != pos)\n\t\t\t\t\tS9xUpdateIRQPositions(false);\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.hirq_pos = PPU.IRQHBeamPos;\n\t\t\t#endif\n\t\t\t\tbreak;\n\n\t\t\tcase 0x4209: // VTIMEL\n\t\t\t\tpos = PPU.IRQVBeamPos;\n\t\t\t\tPPU.IRQVBeamPos = (PPU.IRQVBeamPos & 0xff00) | Byte;\n\t\t\t\tif (PPU.IRQVBeamPos != pos)\n\t\t\t\t\tS9xUpdateIRQPositions(true);\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.virq_pos = PPU.IRQVBeamPos;\n\t\t\t#endif\n\t\t\t\tbreak;\n\n\t\t\tcase 0x420a: // VTIMEH\n\t\t\t\tpos = PPU.IRQVBeamPos;\n\t\t\t\tPPU.IRQVBeamPos = (PPU.IRQVBeamPos & 0xff) | ((Byte & 1) << 8);\n\t\t\t\tif (PPU.IRQVBeamPos != pos)\n\t\t\t\t\tS9xUpdateIRQPositions(true);\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.virq_pos = PPU.IRQVBeamPos;\n\t\t\t#endif\n\t\t\t\tbreak;\n\n\t\t\tcase 0x420b: // MDMAEN\n\t\t\t\tif (CPU.InDMAorHDMA)\n\t\t\t\t\treturn;\n\t\t\t\t// XXX: Not quite right...\n                if (Byte) {\n\t\t\t\tCPU.Cycles += Timings.DMACPUSync;\n                }\n\t\t\t\tif (Byte & 0x01)\n\t\t\t\t\tS9xDoDMA(0);\n\t\t\t\tif (Byte & 0x02)\n\t\t\t\t\tS9xDoDMA(1);\n\t\t\t\tif (Byte & 0x04)\n\t\t\t\t\tS9xDoDMA(2);\n\t\t\t\tif (Byte & 0x08)\n\t\t\t\t\tS9xDoDMA(3);\n\t\t\t\tif (Byte & 0x10)\n\t\t\t\t\tS9xDoDMA(4);\n\t\t\t\tif (Byte & 0x20)\n\t\t\t\t\tS9xDoDMA(5);\n\t\t\t\tif (Byte & 0x40)\n\t\t\t\t\tS9xDoDMA(6);\n\t\t\t\tif (Byte & 0x80)\n\t\t\t\t\tS9xDoDMA(7);\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.dma_this_frame = Byte;\n\t\t\t\tmissing.dma_channels = Byte;\n\t\t\t#endif\n\t\t\t\tbreak;\n\n\t\t\tcase 0x420c: // HDMAEN\n\t\t\t\tif (CPU.InDMAorHDMA)\n\t\t\t\t\treturn;\n\t\t\t\tMemory.FillRAM[0x420c] = Byte;\n\t\t\t\t// Yoshi's Island, Genjyu Ryodan, Mortal Kombat, Tales of Phantasia\n\t\t\t\tPPU.HDMA = Byte & ~PPU.HDMAEnded;\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tmissing.hdma_this_frame |= Byte;\n\t\t\t\tmissing.hdma_channels |= Byte;\n\t\t\t#endif\n\t\t\t\tbreak;\n\n\t\t\tcase 0x420d: // MEMSEL\n\t\t\t\tif ((Byte & 1) != (Memory.FillRAM[0x420d] & 1))\n\t\t\t\t{\n\t\t\t\t\tif (Byte & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tCPU.FastROMSpeed = ONE_CYCLE;\n\t\t\t\t\t#ifdef DEBUGGER\n\t\t\t\t\t\tmissing.fast_rom = 1;\n\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tCPU.FastROMSpeed = SLOW_ONE_CYCLE;\n\t\t\t\t\t// we might currently be in FastROMSpeed region, S9xSetPCBase will update CPU.MemSpeed\n\t\t\t\t\tS9xSetPCBase(Registers.PBPC);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0x4210: // RDNMI\n\t\t\tcase 0x4211: // TIMEUP\n\t\t\tcase 0x4212: // HVBJOY\n\t\t\tcase 0x4213: // RDIO\n\t\t\tcase 0x4214: // RDDIVL\n\t\t\tcase 0x4215: // RDDIVH\n\t\t\tcase 0x4216: // RDMPYL\n\t\t\tcase 0x4217: // RDMPYH\n\t\t\tcase 0x4218: // JOY1L\n\t\t\tcase 0x4219: // JOY1H\n\t\t\tcase 0x421a: // JOY2L\n\t\t\tcase 0x421b: // JOY2H\n\t\t\tcase 0x421c: // JOY3L\n\t\t\tcase 0x421d: // JOY3H\n\t\t\tcase 0x421e: // JOY4L\n\t\t\tcase 0x421f: // JOY4H\n\t\t\t\treturn;\n\n\t\t\tdefault:\n\t\t\t\tif (Settings.SPC7110 && Address >= 0x4800)\n\t\t\t\t\tS9xSetSPC7110(Byte, Address);\n\t\t\t\telse\n\t\t\t\tif (Settings.SDD1 && Address >= 0x4804 && Address <= 0x4807)\n\t\t\t\t\tS9xSetSDD1MemoryMap(Address - 0x4804, Byte & 7);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tMemory.FillRAM[Address] = Byte;\n}\n\nuint8 S9xGetCPU (uint16 Address)\n{\n\tif (Address < 0x4200)\n\t{\n\t#ifdef SNES_JOY_READ_CALLBACKS\n\t\textern bool8 pad_read;\n\t\tif (Address == 0x4016 || Address == 0x4017)\n\t\t{\n\t\t\tS9xOnSNESPadRead();\n\t\t\tpad_read = TRUE;\n\t\t}\n\t#endif\n\n\t\tswitch (Address)\n\t\t{\n\t\t\tcase 0x4016: // JOYSER0\n\t\t\tcase 0x4017: // JOYSER1\n\t\t\t\treturn (S9xReadJOYSERn(Address));\n\n\t\t\tdefault:\n\t\t\t\treturn (OpenBus);\n\t\t}\n\t}\n\telse\n\tif ((Address & 0xff80) == 0x4300)\n\t{\n\t\tif (CPU.InDMAorHDMA)\n\t\t\treturn (OpenBus);\n\n\t\tint\td = (Address >> 4) & 0x7;\n\n\t\tswitch (Address & 0xf)\n\t\t{\n\t\t\tcase 0x0: // 0x43x0: DMAPx\n\t\t\t\treturn ((DMA[d].ReverseTransfer        ? 0x80 : 0) |\n\t\t\t\t\t\t(DMA[d].HDMAIndirectAddressing ? 0x40 : 0) |\n\t\t\t\t\t\t(DMA[d].UnusedBit43x0          ? 0x20 : 0) |\n\t\t\t\t\t\t(DMA[d].AAddressDecrement      ? 0x10 : 0) |\n\t\t\t\t\t\t(DMA[d].AAddressFixed          ? 0x08 : 0) |\n\t\t\t\t\t\t(DMA[d].TransferMode & 7));\n\n\t\t\tcase 0x1: // 0x43x1: BBADx\n\t\t\t\treturn (DMA[d].BAddress);\n\n\t\t\tcase 0x2: // 0x43x2: A1TxL\n\t\t\t\treturn (DMA[d].AAddress & 0xff);\n\n\t\t\tcase 0x3: // 0x43x3: A1TxH\n\t\t\t\treturn (DMA[d].AAddress >> 8);\n\n\t\t\tcase 0x4: // 0x43x4: A1Bx\n\t\t\t\treturn (DMA[d].ABank);\n\n\t\t\tcase 0x5: // 0x43x5: DASxL\n\t\t\t\treturn (DMA[d].DMACount_Or_HDMAIndirectAddress & 0xff);\n\n\t\t\tcase 0x6: // 0x43x6: DASxH\n\t\t\t\treturn (DMA[d].DMACount_Or_HDMAIndirectAddress >> 8);\n\n\t\t\tcase 0x7: // 0x43x7: DASBx\n\t\t\t\treturn (DMA[d].IndirectBank);\n\n\t\t\tcase 0x8: // 0x43x8: A2AxL\n\t\t\t\treturn (DMA[d].Address & 0xff);\n\n\t\t\tcase 0x9: // 0x43x9: A2AxH\n\t\t\t\treturn (DMA[d].Address >> 8);\n\n\t\t\tcase 0xa: // 0x43xa: NLTRx\n\t\t\t\treturn (DMA[d].LineCount ^ (DMA[d].Repeat ? 0x00 : 0x80));\n\n\t\t\tcase 0xb: // 0x43xb: ????x\n\t\t\tcase 0xf: // 0x43xf: mirror of 0x43xb\n\t\t\t\treturn (DMA[d].UnknownByte);\n\n\t\t\tdefault:\n\t\t\t\treturn (OpenBus);\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint8\tbyte;\n\n\t\tswitch (Address)\n\t\t{\n\t\t\tcase 0x4210: // RDNMI\n\t\t\t\tbyte = Memory.FillRAM[0x4210];\n\t\t\t\tMemory.FillRAM[0x4210] = Model->_5A22;\n\t\t\t\treturn ((byte & 0x80) | (OpenBus & 0x70) | Model->_5A22);\n\n\t\t\tcase 0x4211: // TIMEUP\n\t\t\t\tbyte = 0;\n\t\t\t\tif (CPU.IRQLine)\n\t\t\t\t{\n\t\t\t\t\tbyte = 0x80;\n\t\t\t\t\tCPU.IRQLine = FALSE;\n\t\t\t\t\tCPU.IRQTransition = FALSE;\n\t\t\t\t}\n\n\t\t\t\treturn (byte | (OpenBus & 0x7f));\n\n\t\t\tcase 0x4212: // HVBJOY\n\t\t\t\treturn (REGISTER_4212() | (OpenBus & 0x3e));\n\n\t\t\tcase 0x4213: // RDIO\n\t\t\t\treturn (Memory.FillRAM[0x4213]);\n\n\t\t\tcase 0x4214: // RDDIVL\n\t\t\tcase 0x4215: // RDDIVH\n\t\t\tcase 0x4216: // RDMPYL\n\t\t\tcase 0x4217: // RDMPYH\n\t\t\t\treturn (Memory.FillRAM[Address]);\n\n\t\t\tcase 0x4218: // JOY1L\n\t\t\tcase 0x4219: // JOY1H\n\t\t\tcase 0x421a: // JOY2L\n\t\t\tcase 0x421b: // JOY2H\n\t\t\tcase 0x421c: // JOY3L\n\t\t\tcase 0x421d: // JOY3H\n\t\t\tcase 0x421e: // JOY4L\n\t\t\tcase 0x421f: // JOY4H\n\t\t\t#ifdef SNES_JOY_READ_CALLBACKS\n\t\t\t\textern bool8 pad_read;\n\t\t\t\tif (Memory.FillRAM[0x4200] & 1)\n\t\t\t\t{\n\t\t\t\t\tS9xOnSNESPadRead();\n\t\t\t\t\tpad_read = TRUE;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\t\treturn (Memory.FillRAM[Address]);\n\n\t\t\tdefault:\n\t\t\t\tif (Settings.SPC7110 && Address >= 0x4800)\n\t\t\t\t\treturn (S9xGetSPC7110(Address));\n\t\t\t\tif (Settings.SDD1 && Address >= 0x4800 && Address <= 0x4807)\n\t\t\t\t\treturn (Memory.FillRAM[Address]);\n\t\t\t\treturn (OpenBus);\n\t\t}\n\t}\n}\n\nvoid S9xResetPPU (void)\n{\n\tS9xSoftResetPPU();\n\tS9xControlsReset();\n\tPPU.M7HOFS = 0;\n\tPPU.M7VOFS = 0;\n\tPPU.M7byte = 0;\n}\n\nvoid S9xResetPPUFast (void)\n{\n\tPPU.RecomputeClipWindows = TRUE;\n\tIPPU.ColorsChanged = TRUE;\n\tIPPU.OBJChanged = TRUE;\n\tmemset(IPPU.TileCached[TILE_2BIT], 0, MAX_2BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_4BIT], 0, MAX_4BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_8BIT], 0, MAX_8BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_2BIT_EVEN], 0, MAX_2BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_2BIT_ODD], 0, MAX_2BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_4BIT_EVEN], 0, MAX_4BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_4BIT_ODD], 0, MAX_4BIT_TILES);\n}\n\nvoid S9xSoftResetPPU (void)\n{\n\tS9xControlsSoftReset();\n\n\tPPU.VMA.High = 0;\n\tPPU.VMA.Increment = 1;\n\tPPU.VMA.Address = 0;\n\tPPU.VMA.FullGraphicCount = 0;\n\tPPU.VMA.Shift = 0;\n\n\tPPU.WRAM = 0;\n\n\tfor (int c = 0; c < 4; c++)\n\t{\n\t\tPPU.BG[c].SCBase = 0;\n\t\tPPU.BG[c].HOffset = 0;\n\t\tPPU.BG[c].VOffset = 0;\n\t\tPPU.BG[c].BGSize = 0;\n\t\tPPU.BG[c].NameBase = 0;\n\t\tPPU.BG[c].SCSize = 0;\n\t}\n\n\tPPU.BGMode = 0;\n\tPPU.BG3Priority = 0;\n\n\tPPU.CGFLIP = 0;\n\tPPU.CGFLIPRead = 0;\n\tPPU.CGADD = 0;\n\n\tfor (int c = 0; c < 256; c++)\n\t{\n\t\tIPPU.Red[c]   = (c & 7) << 2;\n\t\tIPPU.Green[c] = ((c >> 3) & 7) << 2;\n\t\tIPPU.Blue[c]  = ((c >> 6) & 2) << 3;\n\t\tPPU.CGDATA[c] = IPPU.Red[c] | (IPPU.Green[c] << 5) | (IPPU.Blue[c] << 10);\n\t}\n\n\tfor (int c = 0; c < 128; c++)\n\t{\n\t\tPPU.OBJ[c].HPos = 0;\n\t\tPPU.OBJ[c].VPos = 0;\n\t\tPPU.OBJ[c].HFlip = 0;\n\t\tPPU.OBJ[c].VFlip = 0;\n\t\tPPU.OBJ[c].Name = 0;\n\t\tPPU.OBJ[c].Priority = 0;\n\t\tPPU.OBJ[c].Palette = 0;\n\t\tPPU.OBJ[c].Size = 0;\n\t}\n\n\tPPU.OBJThroughMain = FALSE;\n\tPPU.OBJThroughSub = FALSE;\n\tPPU.OBJAddition = FALSE;\n\tPPU.OBJNameBase = 0;\n\tPPU.OBJNameSelect = 0;\n\tPPU.OBJSizeSelect = 0;\n\n\tPPU.OAMAddr = 0;\n\tPPU.SavedOAMAddr = 0;\n\tPPU.OAMPriorityRotation = 0;\n\tPPU.OAMFlip = 0;\n\tPPU.OAMReadFlip = 0;\n\tPPU.OAMTileAddress = 0;\n\tPPU.OAMWriteRegister = 0;\n\tmemset(PPU.OAMData, 0, 512 + 32);\n\n\tPPU.FirstSprite = 0;\n\tPPU.LastSprite = 127;\n\tPPU.RangeTimeOver = 0;\n\n\tPPU.HTimerEnabled = FALSE;\n\tPPU.VTimerEnabled = FALSE;\n\tPPU.HTimerPosition = Timings.H_Max + 1;\n\tPPU.VTimerPosition = Timings.V_Max + 1;\n\tPPU.IRQHBeamPos = 0x1ff;\n\tPPU.IRQVBeamPos = 0x1ff;\n\n\tPPU.HBeamFlip = 0;\n\tPPU.VBeamFlip = 0;\n\tPPU.HBeamPosLatched = 0;\n\tPPU.VBeamPosLatched = 0;\n\tPPU.GunHLatch = 0;\n\tPPU.GunVLatch = 1000;\n\tPPU.HVBeamCounterLatched = 0;\n\n\tPPU.Mode7HFlip = FALSE;\n\tPPU.Mode7VFlip = FALSE;\n\tPPU.Mode7Repeat = 0;\n\tPPU.MatrixA = 0;\n\tPPU.MatrixB = 0;\n\tPPU.MatrixC = 0;\n\tPPU.MatrixD = 0;\n\tPPU.CentreX = 0;\n\tPPU.CentreY = 0;\n\n\tPPU.Mosaic = 0;\n\tPPU.BGMosaic[0] = FALSE;\n\tPPU.BGMosaic[1] = FALSE;\n\tPPU.BGMosaic[2] = FALSE;\n\tPPU.BGMosaic[3] = FALSE;\n\n\tPPU.Window1Left = 1;\n\tPPU.Window1Right = 0;\n\tPPU.Window2Left = 1;\n\tPPU.Window2Right = 0;\n\tPPU.RecomputeClipWindows = TRUE;\n\n\tfor (int c = 0; c < 6; c++)\n\t{\n\t\tPPU.ClipCounts[c] = 0;\n\t\tPPU.ClipWindowOverlapLogic[c] = CLIP_OR;\n\t\tPPU.ClipWindow1Enable[c] = FALSE;\n\t\tPPU.ClipWindow2Enable[c] = FALSE;\n\t\tPPU.ClipWindow1Inside[c] = TRUE;\n\t\tPPU.ClipWindow2Inside[c] = TRUE;\n\t}\n\n\tPPU.ForcedBlanking = TRUE;\n\n\tPPU.FixedColourRed = 0;\n\tPPU.FixedColourGreen = 0;\n\tPPU.FixedColourBlue = 0;\n\tPPU.Brightness = 0;\n\tPPU.ScreenHeight = SNES_HEIGHT;\n\n\tPPU.Need16x8Mulitply = FALSE;\n\tPPU.BGnxOFSbyte = 0;\n\n\tPPU.HDMA = 0;\n\tPPU.HDMAEnded = 0;\n\n\tPPU.OpenBus1 = 0;\n\tPPU.OpenBus2 = 0;\n\n\tfor (int c = 0; c < 2; c++)\n\t\tmemset(&IPPU.Clip[c], 0, sizeof(struct ClipData));\n\tIPPU.ColorsChanged = TRUE;\n\tIPPU.OBJChanged = TRUE;\n\tmemset(IPPU.TileCached[TILE_2BIT], 0, MAX_2BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_4BIT], 0, MAX_4BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_8BIT], 0, MAX_8BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_2BIT_EVEN], 0, MAX_2BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_2BIT_ODD], 0,  MAX_2BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_4BIT_EVEN], 0, MAX_4BIT_TILES);\n\tmemset(IPPU.TileCached[TILE_4BIT_ODD], 0,  MAX_4BIT_TILES);\n\tPPU.VRAMReadBuffer = 0; // XXX: FIXME: anything better?\n\tGFX.DoInterlace = 0;\n\tIPPU.Interlace = FALSE;\n\tIPPU.InterlaceOBJ = FALSE;\n\tIPPU.DoubleWidthPixels = FALSE;\n\tIPPU.DoubleHeightPixels = FALSE;\n\tIPPU.CurrentLine = 0;\n\tIPPU.PreviousLine = 0;\n\tIPPU.XB = NULL;\n\tfor (int c = 0; c < 256; c++)\n\t\tIPPU.ScreenColors[c] = c;\n\tIPPU.MaxBrightness = 0;\n\tIPPU.RenderThisFrame = TRUE;\n\tIPPU.RenderedScreenWidth = SNES_WIDTH;\n\tIPPU.RenderedScreenHeight = SNES_HEIGHT;\n\tIPPU.FrameCount = 0;\n\tIPPU.RenderedFramesCount = 0;\n\tIPPU.DisplayedRenderedFrameCount = 0;\n\tIPPU.SkippedFrames = 0;\n\tIPPU.FrameSkip = 0;\n\n\tS9xFixColourBrightness();\n\tS9xBuildDirectColourMaps();\n\n\tfor (int c = 0; c < 0x8000; c += 0x100)\n\t\tmemset(&Memory.FillRAM[c], c >> 8, 0x100);\n\tmemset(&Memory.FillRAM[0x2100], 0, 0x100);\n\tmemset(&Memory.FillRAM[0x4200], 0, 0x100);\n\tmemset(&Memory.FillRAM[0x4000], 0, 0x100);\n\t// For BS Suttehakkun 2...\n\tmemset(&Memory.FillRAM[0x1000], 0, 0x1000);\n\n\tMemory.FillRAM[0x4201] = Memory.FillRAM[0x4213] = 0xff;\n\tMemory.FillRAM[0x2126] = Memory.FillRAM[0x2128] = 1;\n}\n"
        },
        {
          "name": "ppu.h",
          "type": "blob",
          "size": 16.111328125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _PPU_H_\n#define _PPU_H_\n\n#define FIRST_VISIBLE_LINE\t1\n\n#define TILE_2BIT\t\t\t0\n#define TILE_4BIT\t\t\t1\n#define TILE_8BIT\t\t\t2\n#define TILE_2BIT_EVEN\t\t3\n#define TILE_2BIT_ODD\t\t4\n#define TILE_4BIT_EVEN\t\t5\n#define TILE_4BIT_ODD\t\t6\n\n#define MAX_2BIT_TILES\t\t4096\n#define MAX_4BIT_TILES\t\t2048\n#define MAX_8BIT_TILES\t\t1024\n\n#define CLIP_OR\t\t\t\t0\n#define CLIP_AND\t\t\t1\n#define CLIP_XOR\t\t\t2\n#define CLIP_XNOR\t\t\t3\n\nstruct ClipData\n{\n\tuint8\tCount;\n\tuint8\tDrawMode[6];\n\tuint16\tLeft[6];\n\tuint16\tRight[6];\n};\n\nstruct InternalPPU\n{\n\tstruct ClipData Clip[2][6];\n\tbool8\tColorsChanged;\n\tbool8\tOBJChanged;\n\tuint8\t*TileCache[7];\n\tuint8\t*TileCached[7];\n\tbool8\tInterlace;\n\tbool8\tInterlaceOBJ;\n\tbool8\tPseudoHires;\n\tbool8\tDoubleWidthPixels;\n\tbool8\tDoubleHeightPixels;\n\tint\t\tCurrentLine;\n\tint\t\tPreviousLine;\n\tuint8\t*XB;\n\tuint32\tRed[256];\n\tuint32\tGreen[256];\n\tuint32\tBlue[256];\n\tuint16\tScreenColors[256];\n\tuint8\tMaxBrightness;\n\tbool8\tRenderThisFrame;\n\tint\t\tRenderedScreenWidth;\n\tint\t\tRenderedScreenHeight;\n\tuint32\tFrameCount;\n\tuint32\tRenderedFramesCount;\n\tuint32\tDisplayedRenderedFrameCount;\n\tuint32\tTotalEmulatedFrames;\n\tuint32\tSkippedFrames;\n\tuint32\tFrameSkip;\n};\n\nstruct SOBJ\n{\n\tint16\tHPos;\n\tuint16\tVPos;\n\tuint8\tHFlip;\n\tuint8\tVFlip;\n\tuint16\tName;\n\tuint8\tPriority;\n\tuint8\tPalette;\n\tuint8\tSize;\n};\n\nstruct SPPU\n{\n\tstruct\n\t{\n\t\tbool8\tHigh;\n\t\tuint8\tIncrement;\n\t\tuint16\tAddress;\n\t\tuint16\tMask1;\n\t\tuint16\tFullGraphicCount;\n\t\tuint16\tShift;\n\t}\tVMA;\n\n\tuint32\tWRAM;\n\n\tstruct\n\t{\n\t\tuint16\tSCBase;\n\t\tuint16\tHOffset;\n\t\tuint16\tVOffset;\n\t\tuint8\tBGSize;\n\t\tuint16\tNameBase;\n\t\tuint16\tSCSize;\n\t}\tBG[4];\n\n\tuint8\tBGMode;\n\tuint8\tBG3Priority;\n\n\tbool8\tCGFLIP;\n\tuint8\tCGFLIPRead;\n\tuint8\tCGADD;\n\tuint8\tCGSavedByte;\n\tuint16\tCGDATA[256];\n\n\tstruct SOBJ OBJ[128];\n\tbool8\tOBJThroughMain;\n\tbool8\tOBJThroughSub;\n\tbool8\tOBJAddition;\n\tuint16\tOBJNameBase;\n\tuint16\tOBJNameSelect;\n\tuint8\tOBJSizeSelect;\n\n\tuint16\tOAMAddr;\n\tuint16\tSavedOAMAddr;\n\tuint8\tOAMPriorityRotation;\n\tuint8\tOAMFlip;\n\tuint8\tOAMReadFlip;\n\tuint16\tOAMTileAddress;\n\tuint16\tOAMWriteRegister;\n\tuint8\tOAMData[512 + 32];\n\n\tuint8\tFirstSprite;\n\tuint8\tLastSprite;\n\tuint8\tRangeTimeOver;\n\n\tbool8\tHTimerEnabled;\n\tbool8\tVTimerEnabled;\n\tshort\tHTimerPosition;\n\tshort\tVTimerPosition;\n\tuint16\tIRQHBeamPos;\n\tuint16\tIRQVBeamPos;\n\n\tuint8\tHBeamFlip;\n\tuint8\tVBeamFlip;\n\tuint16\tHBeamPosLatched;\n\tuint16\tVBeamPosLatched;\n\tuint16\tGunHLatch;\n\tuint16\tGunVLatch;\n\tuint8\tHVBeamCounterLatched;\n\n\tbool8\tMode7HFlip;\n\tbool8\tMode7VFlip;\n\tuint8\tMode7Repeat;\n\tshort\tMatrixA;\n\tshort\tMatrixB;\n\tshort\tMatrixC;\n\tshort\tMatrixD;\n\tshort\tCentreX;\n\tshort\tCentreY;\n\tshort\tM7HOFS;\n\tshort\tM7VOFS;\n\n\tuint8\tMosaic;\n\tuint8\tMosaicStart;\n\tbool8\tBGMosaic[4];\n\n\tuint8\tWindow1Left;\n\tuint8\tWindow1Right;\n\tuint8\tWindow2Left;\n\tuint8\tWindow2Right;\n\tbool8\tRecomputeClipWindows;\n\tuint8\tClipCounts[6];\n\tuint8\tClipWindowOverlapLogic[6];\n\tuint8\tClipWindow1Enable[6];\n\tuint8\tClipWindow2Enable[6];\n\tbool8\tClipWindow1Inside[6];\n\tbool8\tClipWindow2Inside[6];\n\n\tbool8\tForcedBlanking;\n\n\tuint8\tFixedColourRed;\n\tuint8\tFixedColourGreen;\n\tuint8\tFixedColourBlue;\n\tuint8\tBrightness;\n\tuint16\tScreenHeight;\n\n\tbool8\tNeed16x8Mulitply;\n\tuint8\tBGnxOFSbyte;\n\tuint8\tM7byte;\n\n\tuint8\tHDMA;\n\tuint8\tHDMAEnded;\n\n\tuint8\tOpenBus1;\n\tuint8\tOpenBus2;\n\n\tuint16\tVRAMReadBuffer;\n};\n\nextern uint16\t\t\t\tSignExtend[2];\nextern struct SPPU\t\t\tPPU;\nextern struct InternalPPU\tIPPU;\n\nvoid S9xResetPPU (void);\nvoid S9xResetPPUFast (void);\nvoid S9xSoftResetPPU (void);\nvoid S9xSetPPU (uint8, uint16);\nuint8 S9xGetPPU (uint16);\nvoid S9xSetCPU (uint8, uint16);\nuint8 S9xGetCPU (uint16);\nvoid S9xUpdateIRQPositions (bool initial);\nvoid S9xFixColourBrightness (void);\nvoid S9xDoAutoJoypad (void);\n\n#include \"gfx.h\"\n#include \"memmap.h\"\n\ntypedef struct\n{\n\tuint8\t_5C77;\n\tuint8\t_5C78;\n\tuint8\t_5A22;\n}\tSnesModel;\n\nextern SnesModel\t*Model;\nextern SnesModel\tM1SNES;\nextern SnesModel\tM2SNES;\n\n#define MAX_5C77_VERSION\t0x01\n#define MAX_5C78_VERSION\t0x03\n#define MAX_5A22_VERSION\t0x02\n\nvoid S9xUpdateScreen (void);\nstatic inline void FLUSH_REDRAW (void)\n{\n\tif (IPPU.PreviousLine != IPPU.CurrentLine)\n\t\tS9xUpdateScreen();\n}\n\nstatic inline void S9xUpdateVRAMReadBuffer()\n{\n\tif (PPU.VMA.FullGraphicCount)\n\t{\n\t\tuint32 addr = PPU.VMA.Address;\n\t\tuint32 rem = addr & PPU.VMA.Mask1;\n\t\tuint32 address = (addr & ~PPU.VMA.Mask1) + (rem >> PPU.VMA.Shift) + ((rem & (PPU.VMA.FullGraphicCount - 1)) << 3);\n\t\tPPU.VRAMReadBuffer = READ_WORD(Memory.VRAM + ((address << 1) & 0xffff));\n\t}\n\telse\n\t\tPPU.VRAMReadBuffer = READ_WORD(Memory.VRAM + ((PPU.VMA.Address << 1) & 0xffff));\n}\n\nstatic inline void REGISTER_2104 (uint8 Byte)\n{\n\tif (!(PPU.OAMFlip & 1))\n\t{\n\t\tPPU.OAMWriteRegister &= 0xff00;\n\t\tPPU.OAMWriteRegister |= Byte;\n\t}\n\n\tif (PPU.OAMAddr & 0x100)\n\t{\n\t\tint addr = ((PPU.OAMAddr & 0x10f) << 1) + (PPU.OAMFlip & 1);\n\t\tif (Byte != PPU.OAMData[addr])\n\t\t{\n\t\t\tFLUSH_REDRAW();\n\t\t\tPPU.OAMData[addr] = Byte;\n\t\t\tIPPU.OBJChanged = TRUE;\n\n\t\t\t// X position high bit, and sprite size (x4)\n\t\t\tstruct SOBJ *pObj = &PPU.OBJ[(addr & 0x1f) * 4];\n\t\t\tpObj->HPos = (pObj->HPos & 0xFF) | SignExtend[(Byte >> 0) & 1];\n\t\t\tpObj++->Size = Byte & 2;\n\t\t\tpObj->HPos = (pObj->HPos & 0xFF) | SignExtend[(Byte >> 2) & 1];\n\t\t\tpObj++->Size = Byte & 8;\n\t\t\tpObj->HPos = (pObj->HPos & 0xFF) | SignExtend[(Byte >> 4) & 1];\n\t\t\tpObj++->Size = Byte & 32;\n\t\t\tpObj->HPos = (pObj->HPos & 0xFF) | SignExtend[(Byte >> 6) & 1];\n\t\t\tpObj->Size = Byte & 128;\n\t\t}\n\n\t}\n\telse if (PPU.OAMFlip & 1)\n\t{\n\t\tPPU.OAMWriteRegister &= 0x00ff;\n\t\tuint8 lowbyte = (uint8) (PPU.OAMWriteRegister);\n\t\tuint8 highbyte = Byte;\n\t\tPPU.OAMWriteRegister |= Byte << 8;\n\n\t\tint addr = (PPU.OAMAddr << 1);\n\t\tif (lowbyte != PPU.OAMData[addr] || highbyte != PPU.OAMData[addr + 1])\n\t\t{\n\t\t\tFLUSH_REDRAW();\n\t\t\tPPU.OAMData[addr] = lowbyte;\n\t\t\tPPU.OAMData[addr + 1] = highbyte;\n\t\t\tIPPU.OBJChanged = TRUE;\n\t\t\tif (addr & 2)\n\t\t\t{\n\t\t\t\t// Tile\n\t\t\t\tPPU.OBJ[addr = PPU.OAMAddr >> 1].Name = PPU.OAMWriteRegister & 0x1ff;\n\t\t\t\t// priority, h and v flip.\n\t\t\t\tPPU.OBJ[addr].Palette  = (highbyte >> 1) & 7;\n\t\t\t\tPPU.OBJ[addr].Priority = (highbyte >> 4) & 3;\n\t\t\t\tPPU.OBJ[addr].HFlip    = (highbyte >> 6) & 1;\n\t\t\t\tPPU.OBJ[addr].VFlip    = (highbyte >> 7) & 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// X position (low)\n\t\t\t\tPPU.OBJ[addr = PPU.OAMAddr >> 1].HPos &= 0xff00;\n\t\t\t\tPPU.OBJ[addr].HPos |= lowbyte;\n\t\t\t\t// Sprite Y position\n\t\t\t\tPPU.OBJ[addr].VPos = highbyte;\n\t\t\t}\n\t\t}\n\t}\n\n\tPPU.OAMFlip ^= 1;\n\tif (!(PPU.OAMFlip & 1))\n\t{\n\t\t++PPU.OAMAddr;\n\t\tPPU.OAMAddr &= 0x1ff;\n\t\tif (PPU.OAMPriorityRotation && PPU.FirstSprite != (PPU.OAMAddr >> 1))\n\t\t{\n\t\t\tPPU.FirstSprite = (PPU.OAMAddr & 0xfe) >> 1;\n\t\t\tIPPU.OBJChanged = TRUE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (PPU.OAMPriorityRotation && (PPU.OAMAddr & 1))\n\t\t\tIPPU.OBJChanged = TRUE;\n\t}\n}\n\n// This code is correct, however due to Snes9x's inaccurate timings, some games might be broken by this chage. :(\n#ifdef DEBUGGER\n#define CHECK_INBLANK() \\\n\tif (!PPU.ForcedBlanking && CPU.V_Counter < PPU.ScreenHeight + FIRST_VISIBLE_LINE) \\\n\t{ \\\n\t\tprintf(\"Invalid VRAM acess at (%04d, %04d) blank:%d\\n\", CPU.Cycles, CPU.V_Counter, PPU.ForcedBlanking); \\\n\t\tif (Settings.BlockInvalidVRAMAccess) \\\n\t\t{ \\\n\t\t\tPPU.VMA.Address += !PPU.VMA.High ? PPU.VMA.Increment : 0; \\\n\t\t\treturn; \\\n\t\t} \\\n\t}\n#else\n#define CHECK_INBLANK() \\\n\tif (Settings.BlockInvalidVRAMAccess && !PPU.ForcedBlanking && CPU.V_Counter < PPU.ScreenHeight + FIRST_VISIBLE_LINE) \\\n\t{ \\\n\t\tPPU.VMA.Address += !PPU.VMA.High ? PPU.VMA.Increment : 0; \\\n\t\treturn; \\\n\t}\n#endif\n\nstatic inline void REGISTER_2118 (uint8 Byte)\n{\n\tCHECK_INBLANK();\n\n\tuint32\taddress;\n\n\tif (PPU.VMA.FullGraphicCount)\n\t{\n\t\tuint32 rem = PPU.VMA.Address & PPU.VMA.Mask1;\n\t\taddress = (((PPU.VMA.Address & ~PPU.VMA.Mask1) + (rem >> PPU.VMA.Shift) + ((rem & (PPU.VMA.FullGraphicCount - 1)) << 3)) << 1) & 0xffff;\n\t\tMemory.VRAM[address] = Byte;\n\t}\n\telse\n\t\tMemory.VRAM[address = (PPU.VMA.Address << 1) & 0xffff] = Byte;\n\n\tIPPU.TileCached[TILE_2BIT][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_4BIT][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_8BIT][address >> 6] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\n\tif (!PPU.VMA.High)\n\t{\n\t#ifdef DEBUGGER\n\t\tif (Settings.TraceVRAM && !CPU.InDMAorHDMA)\n\t\t\tprintf(\"VRAM write byte: $%04X (%d, %d)\\n\", PPU.VMA.Address, Memory.FillRAM[0x2115] & 3, (Memory.FillRAM[0x2115] & 0x0c) >> 2);\n\t#endif\n\t\tPPU.VMA.Address += PPU.VMA.Increment;\n\t}\n}\n\nstatic inline void REGISTER_2118_tile (uint8 Byte)\n{\n\tCHECK_INBLANK();\n\n\tuint32 rem = PPU.VMA.Address & PPU.VMA.Mask1;\n\tuint32 address = (((PPU.VMA.Address & ~PPU.VMA.Mask1) + (rem >> PPU.VMA.Shift) + ((rem & (PPU.VMA.FullGraphicCount - 1)) << 3)) << 1) & 0xffff;\n\n\tMemory.VRAM[address] = Byte;\n\n\tIPPU.TileCached[TILE_2BIT][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_4BIT][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_8BIT][address >> 6] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\n\tif (!PPU.VMA.High)\n\t\tPPU.VMA.Address += PPU.VMA.Increment;\n}\n\nstatic inline void REGISTER_2118_linear (uint8 Byte)\n{\n\tCHECK_INBLANK();\n\n\tuint32\taddress;\n\n\tMemory.VRAM[address = (PPU.VMA.Address << 1) & 0xffff] = Byte;\n\n\tIPPU.TileCached[TILE_2BIT][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_4BIT][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_8BIT][address >> 6] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\n\tif (!PPU.VMA.High)\n\t\tPPU.VMA.Address += PPU.VMA.Increment;\n}\n\n#undef CHECK_INBLANK\n#ifdef DEBUGGER\n#define CHECK_INBLANK() \\\n    if (!PPU.ForcedBlanking && CPU.V_Counter < PPU.ScreenHeight + FIRST_VISIBLE_LINE) \\\n    { \\\n        printf(\"Invalid VRAM acess at (%04d, %04d) blank:%d\\n\", CPU.Cycles, CPU.V_Counter, PPU.ForcedBlanking); \\\n        if (Settings.BlockInvalidVRAMAccess) \\\n        { \\\n            PPU.VMA.Address += PPU.VMA.High ? PPU.VMA.Increment : 0; \\\n            return; \\\n        } \\\n    }\n#else\n#define CHECK_INBLANK() \\\n        if (Settings.BlockInvalidVRAMAccess && !PPU.ForcedBlanking && CPU.V_Counter < PPU.ScreenHeight + FIRST_VISIBLE_LINE) \\\n        { \\\n            PPU.VMA.Address += PPU.VMA.High ? PPU.VMA.Increment : 0; \\\n            return; \\\n        }\n#endif\n\n\nstatic inline void REGISTER_2119 (uint8 Byte)\n{\n\tCHECK_INBLANK();\n\tuint32\taddress;\n\n\tif (PPU.VMA.FullGraphicCount)\n\t{\n\t\tuint32 rem = PPU.VMA.Address & PPU.VMA.Mask1;\n\t\taddress = ((((PPU.VMA.Address & ~PPU.VMA.Mask1) + (rem >> PPU.VMA.Shift) + ((rem & (PPU.VMA.FullGraphicCount - 1)) << 3)) << 1) + 1) & 0xffff;\n\t\tMemory.VRAM[address] = Byte;\n\t}\n\telse\n\t\tMemory.VRAM[address = ((PPU.VMA.Address << 1) + 1) & 0xffff] = Byte;\n\n\tIPPU.TileCached[TILE_2BIT][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_4BIT][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_8BIT][address >> 6] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\n\tif (PPU.VMA.High)\n\t{\n\t#ifdef DEBUGGER\n\t\tif (Settings.TraceVRAM && !CPU.InDMAorHDMA)\n\t\t\tprintf(\"VRAM write word: $%04X (%d, %d)\\n\", PPU.VMA.Address, Memory.FillRAM[0x2115] & 3, (Memory.FillRAM[0x2115] & 0x0c) >> 2);\n\t#endif\n\t\tPPU.VMA.Address += PPU.VMA.Increment;\n\t}\n}\n\nstatic inline void REGISTER_2119_tile (uint8 Byte)\n{\n\tCHECK_INBLANK();\n\n\tuint32 rem = PPU.VMA.Address & PPU.VMA.Mask1;\n\tuint32 address = ((((PPU.VMA.Address & ~PPU.VMA.Mask1) + (rem >> PPU.VMA.Shift) + ((rem & (PPU.VMA.FullGraphicCount - 1)) << 3)) << 1) + 1) & 0xffff;\n\n\tMemory.VRAM[address] = Byte;\n\n\tIPPU.TileCached[TILE_2BIT][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_4BIT][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_8BIT][address >> 6] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\n\tif (PPU.VMA.High)\n\t\tPPU.VMA.Address += PPU.VMA.Increment;\n}\n\nstatic inline void REGISTER_2119_linear (uint8 Byte)\n{\n\tCHECK_INBLANK();\n\n\tuint32\taddress;\n\n\tMemory.VRAM[address = ((PPU.VMA.Address << 1) + 1) & 0xffff] = Byte;\n\n\tIPPU.TileCached[TILE_2BIT][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_4BIT][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_8BIT][address >> 6] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_EVEN][((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [address >> 4] = FALSE;\n\tIPPU.TileCached[TILE_2BIT_ODD] [((address >> 4) - 1) & (MAX_2BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_EVEN][((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [address >> 5] = FALSE;\n\tIPPU.TileCached[TILE_4BIT_ODD] [((address >> 5) - 1) & (MAX_4BIT_TILES - 1)] = FALSE;\n\n\tif (PPU.VMA.High)\n\t\tPPU.VMA.Address += PPU.VMA.Increment;\n}\n\nstatic inline void REGISTER_2122 (uint8 Byte)\n{\n\tif (PPU.CGFLIP)\n\t{\n\t\tif ((Byte & 0x7f) != (PPU.CGDATA[PPU.CGADD] >> 8) || PPU.CGSavedByte != (uint8) (PPU.CGDATA[PPU.CGADD] & 0xff))\n\t\t{\n\t\t\tFLUSH_REDRAW();\n\t\t\tPPU.CGDATA[PPU.CGADD] = (Byte & 0x7f) << 8 | PPU.CGSavedByte;\n\t\t\tIPPU.ColorsChanged = TRUE;\n\t\t\tIPPU.Red[PPU.CGADD] = IPPU.XB[PPU.CGSavedByte & 0x1f];\n\t\t\tIPPU.Blue[PPU.CGADD] = IPPU.XB[(Byte >> 2) & 0x1f];\n\t\t\tIPPU.Green[PPU.CGADD] = IPPU.XB[(PPU.CGDATA[PPU.CGADD] >> 5) & 0x1f];\n\t\t\tIPPU.ScreenColors[PPU.CGADD] = (uint16) BUILD_PIXEL(IPPU.Red[PPU.CGADD], IPPU.Green[PPU.CGADD], IPPU.Blue[PPU.CGADD]);\n\t\t}\n\n\t\tPPU.CGADD++;\n\t}\n\telse\n\t{\n\t\tPPU.CGSavedByte = Byte;\n\t}\n\n\tPPU.CGFLIP ^= 1;\n}\n\nstatic inline void REGISTER_2180 (uint8 Byte)\n{\n\tMemory.RAM[PPU.WRAM++] = Byte;\n\tPPU.WRAM &= 0x1ffff;\n}\n\nstatic inline uint8 REGISTER_4212 (void)\n{\n\tuint8\tbyte = 0;\n\n    if ((CPU.V_Counter >= PPU.ScreenHeight + FIRST_VISIBLE_LINE) && (CPU.V_Counter < PPU.ScreenHeight + FIRST_VISIBLE_LINE + 3))\n\t\tbyte = 1;\n\tif ((CPU.Cycles < Timings.HBlankEnd) || (CPU.Cycles >= Timings.HBlankStart))\n\t\tbyte |= 0x40;\n    if (CPU.V_Counter >= PPU.ScreenHeight + FIRST_VISIBLE_LINE)\n\t\tbyte |= 0x80;\n\n    return (byte);\n}\n\n#endif\n"
        },
        {
          "name": "qt",
          "type": "tree",
          "content": null
        },
        {
          "name": "sa1.cpp",
          "type": "blob",
          "size": 23.3994140625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n\nuint8\tSA1OpenBus;\n\nstatic void S9xSA1SetBWRAMMemMap (uint8);\nstatic void S9xSetSA1MemMap (uint32, uint8);\nstatic void S9xSA1CharConv2 (void);\nstatic void S9xSA1DMA (void);\nstatic void S9xSA1ReadVariableLengthData (bool8, bool8);\n\n\nvoid S9xSA1Init (void)\n{\n\tSA1.Cycles = 0;\n\tSA1.PrevCycles = 0;\n\tSA1.Flags = 0;\n\tSA1.WaitingForInterrupt = FALSE;\n\n\tmemset(&Memory.FillRAM[0x2200], 0, 0x200);\n\tMemory.FillRAM[0x2200] = 0x20;\n\tMemory.FillRAM[0x2220] = 0x00;\n\tMemory.FillRAM[0x2221] = 0x01;\n\tMemory.FillRAM[0x2222] = 0x02;\n\tMemory.FillRAM[0x2223] = 0x03;\n\tMemory.FillRAM[0x2228] = 0x0f;\n\n\tSA1.in_char_dma = FALSE;\n\tSA1.TimerIRQLastState = FALSE;\n\tSA1.HTimerIRQPos = 0;\n\tSA1.VTimerIRQPos = 0;\n\tSA1.HCounter = 0;\n\tSA1.VCounter = 0;\n\tSA1.PrevHCounter = 0;\n\tSA1.arithmetic_op = 0;\n\tSA1.op1 = 0;\n\tSA1.op2 = 0;\n\tSA1.sum = 0;\n\tSA1.overflow = FALSE;\n\tSA1.VirtualBitmapFormat = 4;\n\tSA1.variable_bit_pos = 0;\n\n\tSA1Registers.PBPC = 0;\n\tSA1Registers.PB = 0;\n\tSA1Registers.PCw = 0;\n\tSA1Registers.D.W = 0;\n\tSA1Registers.DB = 0;\n\tSA1Registers.SH = 1;\n\tSA1Registers.SL = 0xFF;\n\tSA1Registers.XH = 0;\n\tSA1Registers.YH = 0;\n\tSA1Registers.P.W = 0;\n\n\tSA1.ShiftedPB = 0;\n\tSA1.ShiftedDB = 0;\n\tSA1SetFlags(MemoryFlag | IndexFlag | IRQ | Emulation);\n\tSA1ClearFlags(Decimal);\n\n\tSA1.MemSpeed = ONE_CYCLE;\n\tSA1.MemSpeedx2 = ONE_CYCLE * 2;\n\n\tSA1.S9xOpcodes = S9xSA1OpcodesM1X1;\n\tSA1.S9xOpLengths = S9xOpLengthsM1X1;\n\n\tS9xSA1SetPCBase(SA1Registers.PBPC);\n\n\tS9xSA1UnpackStatus();\n\tS9xSA1FixCycles();\n\n\tSA1.BWRAM = Memory.SRAM;\n\n\tCPU.IRQExternal = FALSE;\n}\n\nstatic void S9xSA1SetBWRAMMemMap (uint8 val)\n{\n\tif (val & 0x80)\n\t{\n\t\tfor (int c = 0; c < 0x400; c += 16)\n\t\t{\n\t\t\tSA1.Map[c + 6] = SA1.Map[c + 0x806] = (uint8 *) CMemory::MAP_BWRAM_BITMAP2;\n\t\t\tSA1.Map[c + 7] = SA1.Map[c + 0x807] = (uint8 *) CMemory::MAP_BWRAM_BITMAP2;\n\t\t\tSA1.WriteMap[c + 6] = SA1.WriteMap[c + 0x806] = (uint8 *) CMemory::MAP_BWRAM_BITMAP2;\n\t\t\tSA1.WriteMap[c + 7] = SA1.WriteMap[c + 0x807] = (uint8 *) CMemory::MAP_BWRAM_BITMAP2;\n\t\t}\n\n\t\tSA1.BWRAM = Memory.SRAM + (val & 0x7f) * 0x2000 / 4;\n\t}\n\telse\n\t{\n\t\tfor (int c = 0; c < 0x400; c += 16)\n\t\t{\n\t\t\tSA1.Map[c + 6] = SA1.Map[c + 0x806] = (uint8 *) CMemory::MAP_BWRAM;\n\t\t\tSA1.Map[c + 7] = SA1.Map[c + 0x807] = (uint8 *) CMemory::MAP_BWRAM;\n\t\t\tSA1.WriteMap[c + 6] = SA1.WriteMap[c + 0x806] = (uint8 *) CMemory::MAP_BWRAM;\n\t\t\tSA1.WriteMap[c + 7] = SA1.WriteMap[c + 0x807] = (uint8 *) CMemory::MAP_BWRAM;\n\t\t}\n\n\t\tSA1.BWRAM = Memory.SRAM + (val & 0x1f) * 0x2000;\n\t}\n}\n\nvoid S9xSA1PostLoadState (void)\n{\n\tSA1.ShiftedPB = (uint32) SA1Registers.PB << 16;\n\tSA1.ShiftedDB = (uint32) SA1Registers.DB << 16;\n\n\tS9xSA1SetPCBase(SA1Registers.PBPC);\n\tS9xSA1UnpackStatus();\n\tS9xSA1FixCycles();\n\tSA1.VirtualBitmapFormat = (Memory.FillRAM[0x223f] & 0x80) ? 2 : 4;\n\tMemory.BWRAM = Memory.SRAM + (Memory.FillRAM[0x2224] & 0x1f) * 0x2000;\n\tS9xSA1SetBWRAMMemMap(Memory.FillRAM[0x2225]);\n#if 0\n\tS9xSetSA1(Memory.FillRAM[0x2220], 0x2220);\n\tS9xSetSA1(Memory.FillRAM[0x2221], 0x2221);\n\tS9xSetSA1(Memory.FillRAM[0x2222], 0x2222);\n\tS9xSetSA1(Memory.FillRAM[0x2223], 0x2223);\n#endif\n}\n\nstatic void S9xSetSA1MemMap (uint32 which1, uint8 map)\n{\n\tint\tstart  = which1 * 0x100 + 0xc00;\n\tint\tstart2 = which1 * 0x200;\n\n\tif (which1 >= 2)\n\t\tstart2 += 0x400;\n\n\tfor (int c = 0; c < 0x100; c += 16)\n\t{\n\t\tuint8 *block;\n\t\tif (Multi.cartType != 5)\n\t\t\tblock = &Memory.ROM[(map & 7) * 0x100000 + (c << 12)];\n\t\telse\n\t\t{\n\t\t\tif ((map & 7) < 4)\n\t\t\t\tblock = Memory.ROM + Multi.cartOffsetA + ((map & 7) * 0x100000 + (c << 12));\n\t\t\telse\n\t\t\t\tblock = Memory.ROM + Multi.cartOffsetB + (((map & 7) - 4) * 0x100000 + (c << 12));\n\t\t}\n\t\tfor (int i = c; i < c + 16; i++)\n\t\t\tMemory.Map[start  + i] = SA1.Map[start  + i] = block;\n\t}\n\n\tfor (int c = 0; c < 0x200; c += 16)\n\t{\n        // conversion to int is needed here - map is promoted but which1 is not\n\t\tint32 offset;\n\t\tuint8 *block;\n\t\tif (Multi.cartType != 5)\n\t\t{\n\t\t\toffset = (((map & 0x80) ? map : which1) & 7) * 0x100000 + (c << 11) - 0x8000;\n\t\t\tblock = &Memory.ROM[offset];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((map & 7) < 4)\n\t\t\t{\n\t\t\t\toffset = (((map & 0x80) ? map : which1) & 7) * 0x100000 + (c << 11) - 0x8000;\n\t\t\t\tblock = Memory.ROM + Multi.cartOffsetA + offset;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toffset = (((map & 0x80) ? (map - 4) : which1) & 7) * 0x100000 + (c << 11) - 0x8000;\n\t\t\t\tblock = Memory.ROM + Multi.cartOffsetB + offset;\n\t\t\t}\n\t\t}\n\t\tfor (int i = c + 8; i < c + 16; i++)\n\t\t\tMemory.Map[start2 + i] = SA1.Map[start2 + i] = block;\n\t}\n}\n\nuint8 S9xGetSA1 (uint32 address)\n{\n\tswitch (address)\n\t{\n\t\tcase 0x2300: // S-CPU flag\n\t\t\treturn ((Memory.FillRAM[0x2209] & 0x5f) | (Memory.FillRAM[0x2300] & 0xa0));\n\n\t\tcase 0x2301: // SA-1 flag\n\t\t\treturn ((Memory.FillRAM[0x2200] & 0x0f) | (Memory.FillRAM[0x2301] & 0xf0));\n\n\t\tcase 0x2302: // H counter (L)\n\t\t\tSA1.HTimerIRQPos = SA1.HCounter / ONE_DOT_CYCLE;\n\t\t\tSA1.VTimerIRQPos = SA1.VCounter;\n\t\t\treturn ((uint8)  SA1.HTimerIRQPos);\n\n\t\tcase 0x2303: // H counter (H)\n\t\t\treturn ((uint8) (SA1.HTimerIRQPos >> 8));\n\n\t\tcase 0x2304: // V counter (L)\n\t\t\treturn ((uint8)  SA1.VTimerIRQPos);\n\n\t\tcase 0x2305: // V counter (H)\n\t\t\treturn ((uint8) (SA1.VTimerIRQPos >> 8));\n\n\t\tcase 0x2306: // arithmetic result (LLL)\n\t\t\treturn ((uint8)  SA1.sum);\n\n\t\tcase 0x2307: // arithmetic result (LLH)\n\t\t\treturn ((uint8) (SA1.sum >>  8));\n\n\t\tcase 0x2308: // arithmetic result (LHL)\n\t\t\treturn ((uint8) (SA1.sum >> 16));\n\n\t\tcase 0x2309: // arithmetic result (LLH)\n\t\t\treturn ((uint8) (SA1.sum >> 24));\n\n\t\tcase 0x230a: // arithmetic result (HLL)\n\t\t\treturn ((uint8) (SA1.sum >> 32));\n\n\t\tcase 0x230b: // arithmetic overflow\n\t\t\treturn (SA1.overflow ? 0x80 : 0);\n\n\t\tcase 0x230c: // variable-length data read port (L)\n\t\t\treturn (Memory.FillRAM[0x230c]);\n\n\t\tcase 0x230d: // variable-length data read port (H)\n\t\t{\n\t\t\tuint8\tbyte = Memory.FillRAM[0x230d];\n\n\t\t\tif (Memory.FillRAM[0x2258] & 0x80)\n\t\t\t\tS9xSA1ReadVariableLengthData(TRUE, FALSE);\n\n\t\t\treturn (byte);\n\t\t}\n\n\t\tcase 0x230e: // version code register\n\t\t\treturn (0x23);\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn (Memory.FillRAM[address]);\n}\n\nvoid S9xSetSA1 (uint8 byte, uint32 address)\n{\n\tswitch (address)\n\t{\n\t\tcase 0x2200: // SA-1 control\n\t\t#ifdef DEBUGGER\n\t\t\tif (byte & 0x60)\n\t\t\t\tprintf(\"SA-1 sleep\\n\");\n\t\t#endif\n\n\t\t\t// SA-1 reset\n\t\t\tif (!(byte & 0x80) && (Memory.FillRAM[0x2200] & 0x20))\n\t\t\t{\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tprintf(\"SA-1 reset\\n\");\n\t\t\t#endif\n\t\t\t\tSA1Registers.PBPC = 0;\n\t\t\t\tSA1Registers.PB = 0;\n\t\t\t\tSA1Registers.PCw = Memory.FillRAM[0x2203] | (Memory.FillRAM[0x2204] << 8);\n\t\t\t\tS9xSA1SetPCBase(SA1Registers.PBPC);\n\t\t\t}\n\n\t\t\t// SA-1 IRQ control\n\t\t\tif (byte & 0x80)\n\t\t\t{\n\t\t\t\tMemory.FillRAM[0x2301] |= 0x80;\n\t\t\t\tif (Memory.FillRAM[0x220a] & 0x80)\n\t\t\t\t\tMemory.FillRAM[0x220b] &= ~0x80;\n\t\t\t}\n\n\t\t\t// SA-1 NMI control\n\t\t\tif (byte & 0x10)\n\t\t\t{\n\t\t\t\tMemory.FillRAM[0x2301] |= 0x10;\n\t\t\t\tif (Memory.FillRAM[0x220a] & 0x10)\n\t\t\t\t\tMemory.FillRAM[0x220b] &= ~0x10;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x2201: // S-CPU interrupt enable\n\t\t\t// S-CPU IRQ enable\n\t\t\tif (((byte ^ Memory.FillRAM[0x2201]) & 0x80) && (Memory.FillRAM[0x2300] & byte & 0x80))\n\t\t\t{\n\t\t\t\tMemory.FillRAM[0x2202] &= ~0x80;\n\t\t\t\tCPU.IRQExternal = TRUE;\n\t\t\t}\n\n\t\t\t// S-CPU CHDMA IRQ enable\n\t\t\tif (((byte ^ Memory.FillRAM[0x2201]) & 0x20) && (Memory.FillRAM[0x2300] & byte & 0x20))\n\t\t\t{\n\t\t\t\tMemory.FillRAM[0x2202] &= ~0x20;\n\t\t\t\tCPU.IRQExternal = TRUE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x2202: // S-CPU interrupt clear\n\t\t\t// S-CPU IRQ clear\n\t\t\tif (byte & 0x80)\n\t\t\t\tMemory.FillRAM[0x2300] &= ~0x80;\n\n\t\t\t// S-CPU CHDMA IRQ clear\n\t\t\tif (byte & 0x20)\n\t\t\t\tMemory.FillRAM[0x2300] &= ~0x20;\n\n\t\t\tif (!(Memory.FillRAM[0x2300] & 0xa0))\n\t\t\t\tCPU.IRQExternal = FALSE;\n\n\t\t\tbreak;\n\n\t\tcase 0x2203: // SA-1 reset vector (L)\n\t\tcase 0x2204: // SA-1 reset vector (H)\n\t\tcase 0x2205: // SA-1 NMI vector (L)\n\t\tcase 0x2206: // SA-1 NMI vector (H)\n\t\tcase 0x2207: // SA-1 IRQ vector (L)\n\t\tcase 0x2208: // SA-1 IRQ vector (H)\n\t\t\tbreak;\n\n\t\tcase 0x2209: // S-CPU control\n\t\t\t// 0x40: S-CPU IRQ overwrite\n\t\t\t// 0x20: S-CPU NMI overwrite\n\n\t\t\t// S-CPU IRQ control\n\t\t\tif (byte & 0x80)\n\t\t\t{\n\t\t\t\tMemory.FillRAM[0x2300] |= 0x80;\n\t\t\t\tif (Memory.FillRAM[0x2201] & 0x80)\n\t\t\t\t{\n\t\t\t\t\tMemory.FillRAM[0x2202] &= ~0x80;\n\t\t\t\t\tCPU.IRQExternal = TRUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x220a: // SA-1 interrupt enable\n\t\t\t// SA-1 IRQ enable\n\t\t\tif (((byte ^ Memory.FillRAM[0x220a]) & 0x80) && (Memory.FillRAM[0x2301] & byte & 0x80))\n\t\t\t\tMemory.FillRAM[0x220b] &= ~0x80;\n\n\t\t\t// SA-1 timer IRQ enable\n\t\t\tif (((byte ^ Memory.FillRAM[0x220a]) & 0x40) && (Memory.FillRAM[0x2301] & byte & 0x40))\n\t\t\t\tMemory.FillRAM[0x220b] &= ~0x40;\n\n\t\t\t// SA-1 DMA IRQ enable\n\t\t\tif (((byte ^ Memory.FillRAM[0x220a]) & 0x20) && (Memory.FillRAM[0x2301] & byte & 0x20))\n\t\t\t\tMemory.FillRAM[0x220b] &= ~0x20;\n\n\t\t\t// SA-1 NMI enable\n\t\t\tif (((byte ^ Memory.FillRAM[0x220a]) & 0x10) && (Memory.FillRAM[0x2301] & byte & 0x10))\n\t\t\t\tMemory.FillRAM[0x220b] &= ~0x10;\n\n\t\t\tbreak;\n\n\t\tcase 0x220b: // SA-1 interrupt clear\n\t\t\t// SA-1 IRQ clear\n\t\t\tif (byte & 0x80)\n\t\t\t\tMemory.FillRAM[0x2301] &= ~0x80;\n\n\t\t\t// SA-1 timer IRQ clear\n\t\t\tif (byte & 0x40)\n\t\t\t\tMemory.FillRAM[0x2301] &= ~0x40;\n\n\t\t\t// SA-1 DMA IRQ clear\n\t\t\tif (byte & 0x20)\n\t\t\t\tMemory.FillRAM[0x2301] &= ~0x20;\n\n\t\t\t// SA-1 NMI clear\n\t\t\tif (byte & 0x10)\n\t\t\t\tMemory.FillRAM[0x2301] &= ~0x10;\n\n\t\t\tbreak;\n\n\t\tcase 0x220c: // S-CPU NMI vector (L)\n\t\tcase 0x220d: // S-CPU NMI vector (H)\n\t\tcase 0x220e: // S-CPU IRQ vector (L)\n\t\tcase 0x220f: // S-CPU IRQ vector (H)\n\t\t\tbreak;\n\n\t\tcase 0x2210: // SA-1 timer control\n\t\t\t// 0x80: mode (linear / HV)\n\t\t\t// 0x02: V timer enable\n\t\t\t// 0x01: H timer enable\n\t\t#ifdef DEBUGGER\n\t\t\tprintf(\"SA-1 timer control write:%02x\\n\", byte);\n\t\t#endif\n\t\t\tbreak;\n\n\t\tcase 0x2211: // SA-1 timer reset\n\t\t\tSA1.HCounter = 0;\n\t\t\tSA1.VCounter = 0;\n\t\t\tbreak;\n\n\t\tcase 0x2212: // SA-1 H-timer (L)\n\t\t\tSA1.HTimerIRQPos = byte | (Memory.FillRAM[0x2213] << 8);\n\t\t\tbreak;\n\n\t\tcase 0x2213: // SA-1 H-timer (H)\n\t\t\tSA1.HTimerIRQPos = (byte << 8) | Memory.FillRAM[0x2212];\n\t\t\tbreak;\n\n\t\tcase 0x2214: // SA-1 V-timer (L)\n\t\t\tSA1.VTimerIRQPos = byte | (Memory.FillRAM[0x2215] << 8);\n\t\t\tbreak;\n\n\t\tcase 0x2215: // SA-1 V-timer (H)\n\t\t\tSA1.VTimerIRQPos = (byte << 8) | Memory.FillRAM[0x2214];\n\t\t\tbreak;\n\n\t\tcase 0x2220: // MMC bank C\n\t\tcase 0x2221: // MMC bank D\n\t\tcase 0x2222: // MMC bank E\n\t\tcase 0x2223: // MMC bank F\n\t\t\tS9xSetSA1MemMap(address - 0x2220, byte);\n\t\t\tbreak;\n\n\t\tcase 0x2224: // S-CPU BW-RAM mapping\n\t\t\tMemory.BWRAM = Memory.SRAM + (byte & 0x1f) * 0x2000;\n\t\t\tbreak;\n\n\t\tcase 0x2225: // SA-1 BW-RAM mapping\n\t\t\tif (byte != Memory.FillRAM[0x2225])\n\t\t\t\tS9xSA1SetBWRAMMemMap(byte);\n\n\t\t\tbreak;\n\n\t\tcase 0x2226: // S-CPU BW-RAM write enable\n\t\tcase 0x2227: // SA-1 BW-RAM write enable\n\t\tcase 0x2228: // BW-RAM write-protected area\n\t\tcase 0x2229: // S-CPU I-RAM write protection\n\t\tcase 0x222a: // SA-1 I-RAM write protection\n\t\t\tbreak;\n\n\t\tcase 0x2230: // DMA control\n\t\t\t// 0x80: enable\n\t\t\t// 0x40: priority (DMA / SA-1)\n\t\t\t// 0x20: character conversion / normal\n\t\t\t// 0x10: BW-RAM -> I-RAM / SA-1 -> I-RAM\n\t\t\t// 0x04: destinatin (BW-RAM / I-RAM)\n\t\t\t// 0x03: source\n\t\t\tbreak;\n\n\t\tcase 0x2231: // character conversion DMA parameters\n\t\t\t// 0x80: CHDEND (complete / incomplete)\n\t\t\t// 0x03: color mode\n\t\t\t// (byte >> 2) & 7: virtual VRAM width\n\t\t\tif (byte & 0x80)\n\t\t\t\tSA1.in_char_dma = FALSE;\n\n\t\t\tbreak;\n\n\t\tcase 0x2232: // DMA source start address (LL)\n\t\tcase 0x2233: // DMA source start address (LH)\n\t\tcase 0x2234: // DMA source start address (HL)\n\t\t\tbreak;\n\n\t\tcase 0x2235: // DMA destination start address (LL)\n\t\t\tbreak;\n\n\t\tcase 0x2236: // DMA destination start address (LH)\n\t\t\tMemory.FillRAM[0x2236] = byte;\n\n\t\t\tif ((Memory.FillRAM[0x2230] & 0xa4) == 0x80) // Normal DMA to I-RAM\n\t\t\t\tS9xSA1DMA();\n\t\t\telse\n\t\t\tif ((Memory.FillRAM[0x2230] & 0xb0) == 0xb0) // CC1\n\t\t\t{\n\t\t\t\tSA1.in_char_dma = TRUE;\n\n\t\t\t\tMemory.FillRAM[0x2300] |= 0x20;\n\t\t\t\tif (Memory.FillRAM[0x2201] & 0x20)\n\t\t\t\t{\n\t\t\t\t\tMemory.FillRAM[0x2202] &= ~0x20;\n\t\t\t\t\tCPU.IRQExternal = TRUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x2237: // DMA destination start address (HL)\n\t\t\tMemory.FillRAM[0x2237] = byte;\n\n\t\t\tif ((Memory.FillRAM[0x2230] & 0xa4) == 0x84) // Normal DMA to BW-RAM\n\t\t\t\tS9xSA1DMA();\n\n\t\t\tbreak;\n\n\t\tcase 0x2238: // DMA terminal counter (L)\n\t\tcase 0x2239: // DMA terminal counter (H)\n\t\t\tbreak;\n\n\t\tcase 0x223f: // BW-RAM bitmap format\n\t\t\tSA1.VirtualBitmapFormat = (byte & 0x80) ? 2 : 4;\n\t\t\tbreak;\n\n\t\tcase 0x2240: // bitmap register 0\n\t\tcase 0x2241: // bitmap register 1\n\t\tcase 0x2242: // bitmap register 2\n\t\tcase 0x2243: // bitmap register 3\n\t\tcase 0x2244: // bitmap register 4\n\t\tcase 0x2245: // bitmap register 5\n\t\tcase 0x2246: // bitmap register 6\n\t\tcase 0x2247: // bitmap register 7\n\t\tcase 0x2248: // bitmap register 8\n\t\tcase 0x2249: // bitmap register 9\n\t\tcase 0x224a: // bitmap register A\n\t\tcase 0x224b: // bitmap register B\n\t\tcase 0x224c: // bitmap register C\n\t\tcase 0x224d: // bitmap register D\n\t\tcase 0x224e: // bitmap register E\n\t\t\tbreak;\n\n\t\tcase 0x224f: // bitmap register F\n\t\t\tMemory.FillRAM[0x224f] = byte;\n\n\t\t\tif ((Memory.FillRAM[0x2230] & 0xb0) == 0xa0) // CC2\n\t\t\t{\n\t\t\t\tmemmove(&Memory.ROM[CMemory::MAX_ROM_SIZE - 0x10000] + SA1.in_char_dma * 16, &Memory.FillRAM[0x2240], 16);\n\t\t\t\tSA1.in_char_dma = (SA1.in_char_dma + 1) & 7;\n\t\t\t\tif ((SA1.in_char_dma & 3) == 0)\n\t\t\t\t\tS9xSA1CharConv2();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x2250: // arithmetic control\n\t\t\tif (byte & 2)\n\t\t\t\tSA1.sum = 0;\n\t\t\tSA1.arithmetic_op = byte & 3;\n\t\t\tbreak;\n\n\t\tcase 0x2251: // multiplicand / dividend (L)\n\t\t\tSA1.op1 = (SA1.op1 & 0xff00) |  byte;\n\t\t\tbreak;\n\n\t\tcase 0x2252: // multiplicand / dividend (H)\n\t\t\tSA1.op1 = (SA1.op1 & 0x00ff) | (byte << 8);\n\t\t\tbreak;\n\n\t\tcase 0x2253: // multiplier / divisor (L)\n\t\t\tSA1.op2 = (SA1.op2 & 0xff00) |  byte;\n\t\t\tbreak;\n\n\t\tcase 0x2254: // multiplier / divisor (H)\n\t\t\tSA1.op2 = (SA1.op2 & 0x00ff) | (byte << 8);\n\n\t\t\tswitch (SA1.arithmetic_op)\n\t\t\t{\n\t\t\t\tcase 0:\t// signed multiplication\n\t\t\t\t\tSA1.sum = (int16) SA1.op1 * (int16) SA1.op2;\n\t\t\t\t\tSA1.op2 = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // unsigned division\n\t\t\t\t\tif (SA1.op2 == 0)\n\t\t\t\t\t\tSA1.sum = 0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint16 dividend = (int16) SA1.op1;\n\t\t\t\t\t\tuint16 divisor = (uint16) SA1.op2;\n\t\t\t\t\t\tuint32 dividend_ext = dividend + (uint32)divisor * 65536;\n\t\t\t\t\t\tuint16 remainder = dividend_ext % divisor;\n\t\t\t\t\t\tuint16 quotient = dividend_ext / divisor;\n\t\t\t\t\t\tSA1.sum = (remainder << 16) | quotient;\n\t\t\t\t\t}\n\n\t\t\t\t\tSA1.op1 = 0;\n\t\t\t\t\tSA1.op2 = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // cumulative sum\n\t\t\t\tdefault:\n\t\t\t\t\tSA1.sum += (int16) SA1.op1 * (int16) SA1.op2;\n\t\t\t\t\tSA1.overflow = (SA1.sum >= (1ULL << 40));\n\t\t\t\t\tSA1.sum &= (1ULL << 40) - 1;\n\t\t\t\t\tSA1.op2 = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x2258: // variable bit-field length / auto inc / start\n\t\t\tMemory.FillRAM[0x2258] = byte;\n\t\t\tS9xSA1ReadVariableLengthData(TRUE, FALSE);\n\t\t\treturn;\n\n\t\tcase 0x2259: // variable bit-field start address (LL)\n\t\tcase 0x225a: // variable bit-field start address (LH)\n\t\tcase 0x225b: // variable bit-field start address (HL)\n\t\t\tMemory.FillRAM[address] = byte;\n\t\t\t// XXX: ???\n\t\t\tSA1.variable_bit_pos = 0;\n\t\t\tS9xSA1ReadVariableLengthData(FALSE, TRUE);\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (address >= 0x2200 && address <= 0x22ff)\n\t\tMemory.FillRAM[address] = byte;\n}\n\nstatic void S9xSA1CharConv2 (void)\n{\n\tuint32\tdest           = Memory.FillRAM[0x2235] | (Memory.FillRAM[0x2236] << 8);\n\tuint32\toffset         = (SA1.in_char_dma & 7) ? 0 : 1;\n\tint\t\tdepth          = (Memory.FillRAM[0x2231] & 3) == 0 ? 8 : (Memory.FillRAM[0x2231] & 3) == 1 ? 4 : 2;\n\tint\t\tbytes_per_char = 8 * depth;\n\tuint8\t*p             = &Memory.FillRAM[0x3000] + (dest & 0x7ff) + offset * bytes_per_char;\n\tuint8\t*q             = &Memory.ROM[CMemory::MAX_ROM_SIZE - 0x10000] + offset * 64;\n\n\tswitch (depth)\n\t{\n\t\tcase 2:\n\t\t\tfor (int l = 0; l < 8; l++, q += 8)\n\t\t\t{\n\t\t\t\tfor (int b = 0; b < 8; b++)\n\t\t\t\t{\n\t\t\t\t\tuint8\tr = *(q + b);\n\t\t\t\t\t*(p +  0) = (*(p +  0) << 1) | ((r >> 0) & 1);\n\t\t\t\t\t*(p +  1) = (*(p +  1) << 1) | ((r >> 1) & 1);\n\t\t\t\t}\n\n\t\t\t\tp += 2;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tfor (int l = 0; l < 8; l++, q += 8)\n\t\t\t{\n\t\t\t\tfor (int b = 0; b < 8; b++)\n\t\t\t\t{\n\t\t\t\t\tuint8\tr = *(q + b);\n\t\t\t\t\t*(p +  0) = (*(p +  0) << 1) | ((r >> 0) & 1);\n\t\t\t\t\t*(p +  1) = (*(p +  1) << 1) | ((r >> 1) & 1);\n\t\t\t\t\t*(p + 16) = (*(p + 16) << 1) | ((r >> 2) & 1);\n\t\t\t\t\t*(p + 17) = (*(p + 17) << 1) | ((r >> 3) & 1);\n\t\t\t\t}\n\n\t\t\t\tp += 2;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tfor (int l = 0; l < 8; l++, q += 8)\n\t\t\t{\n\t\t\t\tfor (int b = 0; b < 8; b++)\n\t\t\t\t{\n\t\t\t\t\tuint8\tr = *(q + b);\n\t\t\t\t\t*(p +  0) = (*(p +  0) << 1) | ((r >> 0) & 1);\n\t\t\t\t\t*(p +  1) = (*(p +  1) << 1) | ((r >> 1) & 1);\n\t\t\t\t\t*(p + 16) = (*(p + 16) << 1) | ((r >> 2) & 1);\n\t\t\t\t\t*(p + 17) = (*(p + 17) << 1) | ((r >> 3) & 1);\n\t\t\t\t\t*(p + 32) = (*(p + 32) << 1) | ((r >> 4) & 1);\n\t\t\t\t\t*(p + 33) = (*(p + 33) << 1) | ((r >> 5) & 1);\n\t\t\t\t\t*(p + 48) = (*(p + 48) << 1) | ((r >> 6) & 1);\n\t\t\t\t\t*(p + 49) = (*(p + 49) << 1) | ((r >> 7) & 1);\n\t\t\t\t}\n\n\t\t\t\tp += 2;\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n}\n\nstatic void S9xSA1DMA (void)\n{\n\tuint32\tsrc = Memory.FillRAM[0x2232] | (Memory.FillRAM[0x2233] << 8) | (Memory.FillRAM[0x2234] << 16);\n\tuint32\tdst = Memory.FillRAM[0x2235] | (Memory.FillRAM[0x2236] << 8) | (Memory.FillRAM[0x2237] << 16);\n\tuint32\tlen = Memory.FillRAM[0x2238] | (Memory.FillRAM[0x2239] << 8);\n\tuint8\t*s, *d;\n\n\tswitch (Memory.FillRAM[0x2230] & 3)\n\t{\n\t\tcase 0: // ROM\n\t\t\ts = SA1.Map[((src & 0xffffff) >> MEMMAP_SHIFT)];\n\t\t\tif (s >= (uint8 *) CMemory::MAP_LAST)\n\t\t\t\ts += (src & 0xffff);\n\t\t\telse\n\t\t\t\ts = Memory.ROM + (src & 0xffff);\n\t\t\tbreak;\n\n\t\tcase 1: // BW-RAM\n\t\t\tsrc &= Memory.SRAMMask;\n\t\t\tlen &= Memory.SRAMMask;\n\t\t\ts = Memory.SRAM + src;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\tcase 2:\n\t\t\tsrc &= 0x3ff;\n\t\t\tlen &= 0x3ff;\n\t\t\ts = &Memory.FillRAM[0x3000] + src;\n\t\t\tbreak;\n\t}\n\n\tif (Memory.FillRAM[0x2230] & 4)\n\t{\n\t\tdst &= Memory.SRAMMask;\n\t\tlen &= Memory.SRAMMask;\n\t\td = Memory.SRAM + dst;\n\t}\n\telse\n\t{\n\t\tdst &= 0x3ff;\n\t\tlen &= 0x3ff;\n\t\td = &Memory.FillRAM[0x3000] + dst;\n\t}\n\n\tmemmove(d, s, len);\n\n\t// SA-1 DMA IRQ control\n\tMemory.FillRAM[0x2301] |= 0x20;\n\tif (Memory.FillRAM[0x220a] & 0x20)\n\t\tMemory.FillRAM[0x220b] &= ~0x20;\n}\n\nstatic void S9xSA1ReadVariableLengthData (bool8 inc, bool8 no_shift)\n{\n\tuint32\taddr  = Memory.FillRAM[0x2259] | (Memory.FillRAM[0x225a] << 8) | (Memory.FillRAM[0x225b] << 16);\n\tuint8\tshift = Memory.FillRAM[0x2258] & 15;\n\n\tif (no_shift)\n\t\tshift = 0;\n\telse\n\tif (shift == 0)\n\t\tshift = 16;\n\n\tuint8\ts = shift + SA1.variable_bit_pos;\n\n\tif (s >= 16)\n\t{\n\t\taddr += (s >> 4) << 1;\n\t\ts &= 15;\n\t}\n\n\tuint32\tdata = S9xSA1GetWord(addr) | (S9xSA1GetWord(addr + 2) << 16);\n\n\tdata >>= s;\n\tMemory.FillRAM[0x230c] = (uint8) data;\n\tMemory.FillRAM[0x230d] = (uint8) (data >> 8);\n\n\tif (inc)\n\t{\n\t\tSA1.variable_bit_pos = (SA1.variable_bit_pos + shift) & 15;\n\t\tMemory.FillRAM[0x2259] = (uint8) addr;\n\t\tMemory.FillRAM[0x225a] = (uint8) (addr >> 8);\n\t\tMemory.FillRAM[0x225b] = (uint8) (addr >> 16);\n\t}\n}\n\nuint8 S9xSA1GetByte (uint32 address)\n{\n\tuint8\t*GetAddress = SA1.Map[(address & 0xffffff) >> MEMMAP_SHIFT];\n\n\tif (GetAddress >= (uint8 *)CMemory::MAP_LAST)\n\t{\n\t\tSA1.Cycles += SA1.MemSpeed;\n\t\treturn (*(GetAddress + (address & 0xffff)));\n\t}\n\n\tswitch ((pint) GetAddress)\n\t{\n\t\tcase CMemory::MAP_PPU:\n\t\t\tSA1.Cycles += ONE_CYCLE;\n\t\t\treturn (S9xGetSA1(address & 0xffff));\n\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\tcase CMemory::MAP_HIROM_SRAM:\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\tSA1.Cycles += ONE_CYCLE * 2;\n\t\t\treturn (*(Memory.SRAM + (address & 0x3ffff)));\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\tSA1.Cycles += ONE_CYCLE * 2;\n\t\t\treturn (*(SA1.BWRAM + (address & 0x1fff)));\n\n\t\tcase CMemory::MAP_BWRAM_BITMAP:\n\t\t\tSA1.Cycles += ONE_CYCLE * 2;\n\n\t\t\taddress -= 0x600000;\n\t\t\tif (SA1.VirtualBitmapFormat == 2)\n\t\t\t\treturn ((Memory.SRAM[(address >> 2) & 0x3ffff] >> ((address & 3) << 1)) &  3);\n\t\t\telse\n\t\t\t\treturn ((Memory.SRAM[(address >> 1) & 0x3ffff] >> ((address & 1) << 2)) & 15);\n\n\t\tcase CMemory::MAP_BWRAM_BITMAP2:\n\t\t\tSA1.Cycles += ONE_CYCLE * 2;\n\n\t\t\taddress = (address & 0xffff) - 0x6000;\n\t\t\tif (SA1.VirtualBitmapFormat == 2)\n\t\t\t\treturn ((SA1.BWRAM[(address >> 2) & 0x3ffff] >> ((address & 3) << 1)) &  3);\n\t\t\telse\n\t\t\t\treturn ((SA1.BWRAM[(address >> 1) & 0x3ffff] >> ((address & 1) << 2)) & 15);\n\n\t\tdefault:\n\t\t\tSA1.Cycles += ONE_CYCLE;\n\t\t\treturn (SA1OpenBus);\n\t}\n}\n\nuint16 S9xSA1GetWord (uint32 address, s9xwrap_t w)\n{\n\tPC_t\ta;\n\n\tSA1OpenBus = S9xSA1GetByte(address);\n\n\tswitch (w)\n\t{\n\t\tcase WRAP_PAGE:\n\t\t\ta.xPBPC = address;\n\t\t\ta.B.xPCl++;\n\t\t\treturn (SA1OpenBus | (S9xSA1GetByte(a.xPBPC) << 8));\n\n\t\tcase WRAP_BANK:\n\t\t\ta.xPBPC = address;\n\t\t\ta.W.xPC++;\n\t\t\treturn (SA1OpenBus | (S9xSA1GetByte(a.xPBPC) << 8));\n\n\t\tcase WRAP_NONE:\n\t\tdefault:\n\t\t\treturn (SA1OpenBus | (S9xSA1GetByte(address + 1) << 8));\n\t}\n}\n\nvoid S9xSA1SetByte (uint8 byte, uint32 address)\n{\n\tuint8\t*SetAddress = SA1.WriteMap[(address & 0xffffff) >> MEMMAP_SHIFT];\n\n\tif (SetAddress >= (uint8 *) CMemory::MAP_LAST)\n\t{\n\t\t*(SetAddress + (address & 0xffff)) = byte;\n\t\treturn;\n\t}\n\n\tswitch ((pint) SetAddress)\n\t{\n\t\tcase CMemory::MAP_PPU:\n\t\t\tS9xSetSA1(byte, address & 0xffff);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\tcase CMemory::MAP_HIROM_SRAM:\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\t*(Memory.SRAM + (address & 0x3ffff)) = byte;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\t*(SA1.BWRAM + (address & 0x1fff)) = byte;\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_BWRAM_BITMAP:\n\t\t\taddress -= 0x600000;\n\t\t\tif (SA1.VirtualBitmapFormat == 2)\n\t\t\t{\n\t\t\t\tuint8\t*ptr = &Memory.SRAM[(address >> 2) & 0x3ffff];\n\t\t\t\t*ptr &= ~(3  << ((address & 3) << 1));\n\t\t\t\t*ptr |= (byte &  3) << ((address & 3) << 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint8\t*ptr = &Memory.SRAM[(address >> 1) & 0x3ffff];\n\t\t\t\t*ptr &= ~(15 << ((address & 1) << 2));\n\t\t\t\t*ptr |= (byte & 15) << ((address & 1) << 2);\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_BWRAM_BITMAP2:\n\t\t\taddress = (address & 0xffff) - 0x6000;\n\t\t\tif (SA1.VirtualBitmapFormat == 2)\n\t\t\t{\n\t\t\t\tuint8\t*ptr = &SA1.BWRAM[(address >> 2) & 0x3ffff];\n\t\t\t\t*ptr &= ~(3  << ((address & 3) << 1));\n\t\t\t\t*ptr |= (byte &  3) << ((address & 3) << 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint8\t*ptr = &SA1.BWRAM[(address >> 1) & 0x3ffff];\n\t\t\t\t*ptr &= ~(15 << ((address & 1) << 2));\n\t\t\t\t*ptr |= (byte & 15) << ((address & 1) << 2);\n\t\t\t}\n\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\treturn;\n\t}\n}\n\nvoid S9xSA1SetWord (uint16 Word, uint32 address, enum s9xwrap_t w, enum s9xwriteorder_t o)\n{\n\tPC_t\ta;\n\n\tif (!o)\n\t\tS9xSA1SetByte((uint8) Word, address);\n\n\tswitch (w)\n\t{\n\t\tcase WRAP_PAGE:\n\t\t\ta.xPBPC = address;\n\t\t\ta.B.xPCl++;\n\t\t\tS9xSA1SetByte(Word >> 8, a.xPBPC);\n\t\t\tbreak;\n\n\t\tcase WRAP_BANK:\n\t\t\ta.xPBPC = address;\n\t\t\ta.W.xPC++;\n\t\t\tS9xSA1SetByte(Word >> 8, a.xPBPC);\n\t\t\tbreak;\n\n\t\tcase WRAP_NONE:\n\t\tdefault:\n\t\t\tS9xSA1SetByte(Word >> 8, address + 1);\n\t\t\tbreak;\n\t}\n\n\tif (o)\n\t\tS9xSA1SetByte((uint8) Word, address);\n}\n\nvoid S9xSA1SetPCBase (uint32 address)\n{\n\tSA1Registers.PBPC = address & 0xffffff;\n\tSA1.ShiftedPB = address & 0xff0000;\n\n\t// FIXME\n\tSA1.MemSpeed = ONE_CYCLE;\n\tif ((address & 0xc00000) == 0x400000 || (address & 0x40e000) == 0x6000)\n\t{\n\t\tSA1.MemSpeed = TWO_CYCLES;\n\t}\n\n\tSA1.MemSpeedx2 = SA1.MemSpeed << 1;\n\n\tuint8\t*GetAddress = SA1.Map[(address & 0xffffff) >> MEMMAP_SHIFT];\n\n\tif (GetAddress >= (uint8 *) CMemory::MAP_LAST)\n\t{\n\t\tSA1.PCBase = GetAddress;\n\t\treturn;\n\t}\n\n\tswitch ((pint) GetAddress)\n\t{\n\t\tcase CMemory::MAP_LOROM_SRAM:\n\t\t\tif ((Memory.SRAMMask & MEMMAP_MASK) != MEMMAP_MASK)\n\t\t\t\tSA1.PCBase = NULL;\n\t\t\telse\n\t\t\t\tSA1.PCBase = (Memory.SRAM + ((((address & 0xff0000) >> 1) | (address & 0x7fff)) & Memory.SRAMMask)) - (address & 0xffff);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_HIROM_SRAM:\n\t\t\tif ((Memory.SRAMMask & MEMMAP_MASK) != MEMMAP_MASK)\n\t\t\t\tSA1.PCBase = NULL;\n\t\t\telse\n\t\t\t\tSA1.PCBase = (Memory.SRAM + (((address & 0x7fff) - 0x6000 + ((address & 0xf0000) >> 3)) & Memory.SRAMMask)) - (address & 0xffff);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_BWRAM:\n\t\t\tSA1.PCBase = SA1.BWRAM - 0x6000 - (address & 0x8000);\n\t\t\treturn;\n\n\t\tcase CMemory::MAP_SA1RAM:\n\t\t\tSA1.PCBase = Memory.SRAM;\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\tSA1.PCBase = NULL;\n\t\t\treturn;\n\t}\n}\n"
        },
        {
          "name": "sa1.h",
          "type": "blob",
          "size": 3.5986328125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _SA1_H_\n#define _SA1_H_\n\nstruct SSA1Registers\n{\n\tuint8\tDB;\n\tpair\tP;\n\tpair\tA;\n\tpair\tD;\n\tpair\tS;\n\tpair\tX;\n\tpair\tY;\n\tPC_t\tPC;\n};\n\nstruct SSA1\n{\n\tstruct SOpcodes\t*S9xOpcodes;\n\tuint8\t*S9xOpLengths;\n\tuint8\t_Carry;\n\tuint8\t_Zero;\n\tuint8\t_Negative;\n\tuint8\t_Overflow;\n\tuint32\tShiftedPB;\n\tuint32\tShiftedDB;\n\n\tuint32\tFlags;\n\tint32\tCycles;\n\tint32\tPrevCycles;\n\tuint8\t*PCBase;\n\tbool8\tWaitingForInterrupt;\n\n\tuint8\t*Map[MEMMAP_NUM_BLOCKS];\n\tuint8\t*WriteMap[MEMMAP_NUM_BLOCKS];\n\tuint8\t*BWRAM;\n\n\tbool8\tin_char_dma;\n\tbool8\tTimerIRQLastState;\n\tuint16\tHTimerIRQPos;\n\tuint16\tVTimerIRQPos;\n\tint16\tHCounter;\n\tint16\tVCounter;\n\tint16\tPrevHCounter;\n\tint32\tMemSpeed;\n\tint32\tMemSpeedx2;\n\tint32\tarithmetic_op;\n\tuint16\top1;\n\tuint16\top2;\n\tuint64\tsum;\n\tbool8\toverflow;\n\tuint8\tVirtualBitmapFormat;\n\tuint8\tvariable_bit_pos;\n};\n\n#define SA1CheckCarry()\t\t(SA1._Carry)\n#define SA1CheckZero()\t\t(SA1._Zero == 0)\n#define SA1CheckIRQ()\t\t(SA1Registers.PL & IRQ)\n#define SA1CheckDecimal()\t(SA1Registers.PL & Decimal)\n#define SA1CheckIndex()\t\t(SA1Registers.PL & IndexFlag)\n#define SA1CheckMemory()\t(SA1Registers.PL & MemoryFlag)\n#define SA1CheckOverflow()\t(SA1._Overflow)\n#define SA1CheckNegative()\t(SA1._Negative & 0x80)\n#define SA1CheckEmulation()\t(SA1Registers.P.W & Emulation)\n\n#define SA1SetFlags(f)\t\t(SA1Registers.P.W |= (f))\n#define SA1ClearFlags(f)\t(SA1Registers.P.W &= ~(f))\n#define SA1CheckFlag(f)\t\t(SA1Registers.PL & (f))\n\nextern struct SSA1Registers\tSA1Registers;\nextern struct SSA1\t\t\tSA1;\nextern uint8\t\t\t\tSA1OpenBus;\nextern struct SOpcodes\t\tS9xSA1OpcodesM1X1[256];\nextern struct SOpcodes\t\tS9xSA1OpcodesM1X0[256];\nextern struct SOpcodes\t\tS9xSA1OpcodesM0X1[256];\nextern struct SOpcodes\t\tS9xSA1OpcodesM0X0[256];\nextern uint8\t\t\t\tS9xOpLengthsM1X1[256];\nextern uint8\t\t\t\tS9xOpLengthsM1X0[256];\nextern uint8\t\t\t\tS9xOpLengthsM0X1[256];\nextern uint8\t\t\t\tS9xOpLengthsM0X0[256];\n\nuint8 S9xSA1GetByte (uint32);\nvoid S9xSA1SetByte (uint8, uint32);\nuint16 S9xSA1GetWord (uint32, enum s9xwrap_t w = WRAP_NONE);\nvoid S9xSA1SetWord (uint16, uint32, enum s9xwrap_t w = WRAP_NONE, enum s9xwriteorder_t o = WRITE_01);\nvoid S9xSA1SetPCBase (uint32);\nuint8 S9xGetSA1 (uint32);\nvoid S9xSetSA1 (uint8, uint32);\nvoid S9xSA1Init (void);\nvoid S9xSA1MainLoop (void);\nvoid S9xSA1PostLoadState (void);\n\nstatic inline void S9xSA1UnpackStatus (void)\n{\n\tSA1._Zero = (SA1Registers.PL & Zero) == 0;\n\tSA1._Negative = (SA1Registers.PL & Negative);\n\tSA1._Carry = (SA1Registers.PL & Carry);\n\tSA1._Overflow = (SA1Registers.PL & Overflow) >> 6;\n}\n\nstatic inline void S9xSA1PackStatus (void)\n{\n\tSA1Registers.PL &= ~(Zero | Negative | Carry | Overflow);\n\tSA1Registers.PL |= SA1._Carry | ((SA1._Zero == 0) << 1) | (SA1._Negative & 0x80) | (SA1._Overflow << 6);\n}\n\nstatic inline void S9xSA1FixCycles (void)\n{\n\tif (SA1CheckEmulation())\n\t{\n\t\tSA1.S9xOpcodes = S9xSA1OpcodesM1X1;\n\t\tSA1.S9xOpLengths = S9xOpLengthsM1X1;\n\t}\n\telse\n\tif (SA1CheckMemory())\n\t{\n\t\tif (SA1CheckIndex())\n\t\t{\n\t\t\tSA1.S9xOpcodes = S9xSA1OpcodesM1X1;\n\t\t\tSA1.S9xOpLengths = S9xOpLengthsM1X1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSA1.S9xOpcodes = S9xSA1OpcodesM1X0;\n\t\t\tSA1.S9xOpLengths = S9xOpLengthsM1X0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (SA1CheckIndex())\n\t\t{\n\t\t\tSA1.S9xOpcodes = S9xSA1OpcodesM0X1;\n\t\t\tSA1.S9xOpLengths = S9xOpLengthsM0X1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSA1.S9xOpcodes = S9xSA1OpcodesM0X0;\n\t\t\tSA1.S9xOpLengths = S9xOpLengthsM0X0;\n\t\t}\n\t}\n}\n\n#endif\n"
        },
        {
          "name": "sa1cpu.cpp",
          "type": "blob",
          "size": 5.7587890625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n\n#define CPU\t\t\t\t\t\t\t\tSA1\n#define ICPU\t\t\t\t\t\t\tSA1\n#define Registers\t\t\t\t\t\tSA1Registers\n#define OpenBus\t\t\t\t\t\t\tSA1OpenBus\n#define S9xGetByte\t\t\t\t\t\tS9xSA1GetByte\n#define S9xGetWord\t\t\t\t\t\tS9xSA1GetWord\n#define S9xSetByte\t\t\t\t\t\tS9xSA1SetByte\n#define S9xSetWord\t\t\t\t\t\tS9xSA1SetWord\n#define S9xSetPCBase\t\t\t\t\tS9xSA1SetPCBase\n#define S9xOpcodesM1X1\t\t\t\t\tS9xSA1OpcodesM1X1\n#define S9xOpcodesM1X0\t\t\t\t\tS9xSA1OpcodesM1X0\n#define S9xOpcodesM0X1\t\t\t\t\tS9xSA1OpcodesM0X1\n#define S9xOpcodesM0X0\t\t\t\t\tS9xSA1OpcodesM0X0\n#define S9xOpcodesE1\t\t\t\t\tS9xSA1OpcodesE1\n#define S9xOpcodesSlow\t\t\t\t\tS9xSA1OpcodesSlow\n#define S9xOpcode_IRQ\t\t\t\t\tS9xSA1Opcode_IRQ\n#define S9xOpcode_NMI\t\t\t\t\tS9xSA1Opcode_NMI\n#define S9xUnpackStatus\t\t\t\t\tS9xSA1UnpackStatus\n#define S9xPackStatus\t\t\t\t\tS9xSA1PackStatus\n#define S9xFixCycles\t\t\t\t\tS9xSA1FixCycles\n#define Immediate8\t\t\t\t\t\tSA1Immediate8\n#define Immediate16\t\t\t\t\t\tSA1Immediate16\n#define Relative\t\t\t\t\t\tSA1Relative\n#define RelativeLong\t\t\t\t\tSA1RelativeLong\n#define Absolute\t\t\t\t\t\tSA1Absolute\n#define AbsoluteLong\t\t\t\t\tSA1AbsoluteLong\n#define AbsoluteIndirect\t\t\t\tSA1AbsoluteIndirect\n#define AbsoluteIndirectLong\t\t\tSA1AbsoluteIndirectLong\n#define AbsoluteIndexedIndirect\t\t\tSA1AbsoluteIndexedIndirect\n#define Direct\t\t\t\t\t\t\tSA1Direct\n#define DirectIndirectIndexed\t\t\tSA1DirectIndirectIndexed\n#define DirectIndirectIndexedLong\t\tSA1DirectIndirectIndexedLong\n#define DirectIndexedIndirect\t\t\tSA1DirectIndexedIndirect\n#define DirectIndexedX\t\t\t\t\tSA1DirectIndexedX\n#define DirectIndexedY\t\t\t\t\tSA1DirectIndexedY\n#define AbsoluteIndexedX\t\t\t\tSA1AbsoluteIndexedX\n#define AbsoluteIndexedY\t\t\t\tSA1AbsoluteIndexedY\n#define AbsoluteLongIndexedX\t\t\tSA1AbsoluteLongIndexedX\n#define DirectIndirect\t\t\t\t\tSA1DirectIndirect\n#define DirectIndirectLong\t\t\t\tSA1DirectIndirectLong\n#define StackRelative\t\t\t\t\tSA1StackRelative\n#define StackRelativeIndirectIndexed\tSA1StackRelativeIndirectIndexed\n\n#define SA1_OPCODES\n\n#include \"cpuops.cpp\"\n\nstatic void S9xSA1UpdateTimer (void);\n\n\nvoid S9xSA1MainLoop (void)\n{\n\tif (Memory.FillRAM[0x2200] & 0x60)\n\t{\n\t\tSA1.Cycles += 6; // FIXME\n\t\tS9xSA1UpdateTimer();\n\t\treturn;\n\t}\n\n\t// SA-1 NMI\n\tif ((Memory.FillRAM[0x2200] & 0x10) && !(Memory.FillRAM[0x220b] & 0x10))\n\t{\n\t\tMemory.FillRAM[0x2301] |= 0x10;\n\t\tMemory.FillRAM[0x220b] |= 0x10;\n\n\t\tif (SA1.WaitingForInterrupt)\n\t\t{\n\t\t\tSA1.WaitingForInterrupt = FALSE;\n\t\t\tSA1Registers.PCw++;\n\t\t}\n\n\t\tS9xSA1Opcode_NMI();\n\t}\n\telse\n\tif (!SA1CheckFlag(IRQ))\n\t{\n\t\t// SA-1 Timer IRQ\n\t\tif ((Memory.FillRAM[0x220a] & 0x40) && !(Memory.FillRAM[0x220b] & 0x40))\n\t\t{\n\t\t\tMemory.FillRAM[0x2301] |= 0x40;\n\n\t\t\tif (SA1.WaitingForInterrupt)\n\t\t\t{\n\t\t\t\tSA1.WaitingForInterrupt = FALSE;\n\t\t\t\tSA1Registers.PCw++;\n\t\t\t}\n\n\t\t\tS9xSA1Opcode_IRQ();\n\t\t}\n\t\telse\n\t\t// SA-1 DMA IRQ\n\t\tif ((Memory.FillRAM[0x220a] & 0x20) && !(Memory.FillRAM[0x220b] & 0x20))\n\t\t{\n\t\t\tMemory.FillRAM[0x2301] |= 0x20;\n\n\t\t\tif (SA1.WaitingForInterrupt)\n\t\t\t{\n\t\t\t\tSA1.WaitingForInterrupt = FALSE;\n\t\t\t\tSA1Registers.PCw++;\n\t\t\t}\n\n\t\t\tS9xSA1Opcode_IRQ();\n\t\t}\n\t\telse\n\t\t// SA-1 IRQ\n\t\tif ((Memory.FillRAM[0x2200] & 0x80) && !(Memory.FillRAM[0x220b] & 0x80))\n\t\t{\n\t\t\tMemory.FillRAM[0x2301] |= 0x80;\n\n\t\t\tif (SA1.WaitingForInterrupt)\n\t\t\t{\n\t\t\t\tSA1.WaitingForInterrupt = FALSE;\n\t\t\t\tSA1Registers.PCw++;\n\t\t\t}\n\n\t\t\tS9xSA1Opcode_IRQ();\n\t\t}\n\t}\n\n\t#undef CPU\n\tint cycles = CPU.Cycles * 3;\n\t#define CPU SA1\n\n\tfor (; SA1.Cycles < cycles && !(Memory.FillRAM[0x2200] & 0x60);)\n\t{\n\t#ifdef DEBUGGER\n\t\tif (SA1.Flags & TRACE_FLAG)\n\t\t\tS9xSA1Trace();\n\t#endif\n\n\t\tuint8\t\t\t\tOp;\n\t\tstruct SOpcodes\t*Opcodes;\n\n\t\tif (SA1.PCBase)\n\t\t{\n\t\t\tSA1OpenBus = Op = SA1.PCBase[Registers.PCw];\n\t\t\tOpcodes = SA1.S9xOpcodes;\n\t\t\tSA1.Cycles += SA1.MemSpeed;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOp = S9xSA1GetByte(Registers.PBPC);\n\t\t\tOpcodes = S9xOpcodesSlow;\n\t\t}\n\n\t\tif ((SA1Registers.PCw & MEMMAP_MASK) + SA1.S9xOpLengths[Op] >= MEMMAP_BLOCK_SIZE)\n\t\t{\n\t\t\tuint32\toldPC = SA1Registers.PBPC;\n\t\t\tS9xSA1SetPCBase(SA1Registers.PBPC);\n\t\t\tSA1Registers.PBPC = oldPC;\n\t\t\tOpcodes = S9xSA1OpcodesSlow;\n\t\t}\n\n\t\tRegisters.PCw++;\n\t\t(*Opcodes[Op].S9xOpcode)();\n\t}\n\n\tS9xSA1UpdateTimer();\n}\n\nstatic void S9xSA1UpdateTimer (void) // FIXME\n{\n\tSA1.PrevHCounter = SA1.HCounter;\n\n\tif (Memory.FillRAM[0x2210] & 0x80)\n\t{\n\t\tSA1.HCounter += (SA1.Cycles - SA1.PrevCycles);\n\t\tif (SA1.HCounter >= 0x800)\n\t\t{\n\t\t\tSA1.HCounter -= 0x800;\n\t\t\tSA1.PrevHCounter -= 0x800;\n\t\t\tif (++SA1.VCounter >= 0x200)\n\t\t\t\tSA1.VCounter = 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tSA1.HCounter += (SA1.Cycles - SA1.PrevCycles);\n\t\tif (SA1.HCounter >= Timings.H_Max_Master)\n\t\t{\n\t\t\tSA1.HCounter -= Timings.H_Max_Master;\n\t\t\tSA1.PrevHCounter -= Timings.H_Max_Master;\n\t\t\tif (++SA1.VCounter >= Timings.V_Max_Master)\n\t\t\t\tSA1.VCounter = 0;\n\t\t}\n\t}\n\n\tSA1.PrevCycles = SA1.Cycles;\n\n\tbool8\tthisIRQ = Memory.FillRAM[0x2210] & 0x03;\n\n\tif (Memory.FillRAM[0x2210] & 0x01)\n\t{\n\t\tif (SA1.PrevHCounter >= SA1.HTimerIRQPos * ONE_DOT_CYCLE || SA1.HCounter < SA1.HTimerIRQPos * ONE_DOT_CYCLE)\n\t\t\tthisIRQ = FALSE;\n\t}\n\n\tif (Memory.FillRAM[0x2210] & 0x02)\n\t{\n\t\tif (SA1.VCounter != SA1.VTimerIRQPos * ONE_DOT_CYCLE)\n\t\t\tthisIRQ = FALSE;\n\t}\n\n\t// SA-1 Timer IRQ control\n\tif (!SA1.TimerIRQLastState && thisIRQ)\n\t{\n\t\tMemory.FillRAM[0x2301] |= 0x40;\n\t\tif (Memory.FillRAM[0x220a] & 0x40)\n\t\t{\n\t\t\tMemory.FillRAM[0x220b] &= ~0x40;\n\t\t#ifdef DEBUGGER\n\t\t\tS9xTraceFormattedMessage(\"--- SA-1 Timer IRQ triggered  prev HC:%04d  curr HC:%04d  HTimer:%d Pos:%04d  VTimer:%d Pos:%03d\",\n\t\t\t\tSA1.PrevHCounter, SA1.HCounter,\n\t\t\t\t(Memory.FillRAM[0x2210] & 0x01) ? 1 : 0, SA1.HTimerIRQPos * ONE_DOT_CYCLE,\n\t\t\t\t(Memory.FillRAM[0x2210] & 0x02) ? 1 : 0, SA1.VTimerIRQPos);\n\t\t#endif\n\t\t}\n\t}\n\n\tSA1.TimerIRQLastState = thisIRQ;\n}\n"
        },
        {
          "name": "sar.h",
          "type": "blob",
          "size": 1.1240234375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _SAR_H_\n#define _SAR_H_\n\n#ifdef RIGHTSHIFT_IS_SAR\n#define SAR(b, n)\t((b) >> (n))\n#else\n\nstatic inline int8 SAR (const int8 b, const int n)\n{\n#ifndef RIGHTSHIFT_int8_IS_SAR\n\tif (b < 0)\n\t\treturn ((b >> n) | (-1 << (8  - n)));\n#endif\n\treturn (b >> n);\n}\n\nstatic inline int16 SAR (const int16 b, const int n)\n{\n#ifndef RIGHTSHIFT_int16_IS_SAR\n\tif (b < 0)\n\t\treturn ((b >> n) | (-1 << (16 - n)));\n#endif\n\treturn (b >> n);\n}\n\nstatic inline int32 SAR (const int32 b, const int n)\n{\n#ifndef RIGHTSHIFT_int32_IS_SAR\n\tif (b < 0)\n\t\treturn ((b >> n) | (-1 << (32 - n)));\n#endif\n\treturn (b >> n);\n}\n\nstatic inline int64 SAR (const int64 b, const int n)\n{\n#ifndef RIGHTSHIFT_int64_IS_SAR\n\tif (b < 0)\n\t\treturn ((b >> n) | (-1 << (64 - n)));\n#endif\n\treturn (b >> n);\n}\n\n#endif\n\n#endif\n"
        },
        {
          "name": "screenshot.cpp",
          "type": "blob",
          "size": 3.7080078125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifdef HAVE_LIBPNG\n#include <png.h>\n#endif\n\n#include <ctime>\n#include <sstream>\n#include <iomanip>\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"screenshot.h\"\n\n\nbool8 S9xDoScreenshot (int width, int height)\n{\n\tSettings.TakeScreenshot = FALSE;\n\n#ifdef HAVE_LIBPNG\n\tFILE\t\t*fp;\n\tpng_structp\tpng_ptr;\n\tpng_infop\tinfo_ptr;\n\tpng_color_8\tsig_bit;\n\tint\t\t\timgwidth, imgheight;\n\n\tstd::tm *current_time;\n\tstd::time_t current_timet = time(nullptr);\n\tcurrent_time = localtime(&current_timet);\n\n\tauto screenshot_dir = S9xGetDirectory(SCREENSHOT_DIR);\n\tstd::stringstream ss;\n\tss << screenshot_dir\n\t   << S9xBasenameNoExt(Memory.ROMFilename) << \"-\"\n\t   << std::put_time(current_time, \"%Y-%m-%d-%H-%M-%S\");\n\tstd::string fname = ss.str() + \".png\";\n\n\tfor (int i = 0; i < 1000; i++)\n\t{\n\t\tFILE *fp = fopen(fname.c_str(), \"r\");\n\n\t\tif (!fp)\n\t\t\tbreak;\n\n\t\tfclose(fp);\n\t\tfname = ss.str() + \"-\" + std::to_string(i) + \".png\";\n\t}\n\n\tfp = fopen(fname.c_str(), \"wb\");\n\tif (!fp)\n\t{\n\t\tS9xMessage(S9X_ERROR, 0, \"Failed to take screenshot.\");\n\t\treturn (FALSE);\n\t}\n\n\tpng_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n\tif (!png_ptr)\n\t{\n\t\tfclose(fp);\n\t\tremove(fname.c_str());\n\t\tS9xMessage(S9X_ERROR, 0, \"Failed to take screenshot.\");\n\t\treturn (FALSE);\n\t}\n\n\tinfo_ptr = png_create_info_struct(png_ptr);\n\tif (!info_ptr)\n\t{\n\t\tpng_destroy_write_struct(&png_ptr, (png_infopp) NULL);\n\t\tfclose(fp);\n\t\tremove(fname.c_str());\n\t\tS9xMessage(S9X_ERROR, 0, \"Failed to take screenshot.\");\n\t\treturn (FALSE);\n\t}\n\n\tif (setjmp(png_jmpbuf(png_ptr)))\n\t{\n\t\tpng_destroy_write_struct(&png_ptr, &info_ptr);\n\t\tfclose(fp);\n\t\tremove(fname.c_str());\n\t\tS9xMessage(S9X_ERROR, 0, \"Failed to take screenshot.\");\n\t\treturn (FALSE);\n\t}\n\n\timgwidth  = width;\n\timgheight = height;\n\n\tif (Settings.StretchScreenshots == 1)\n\t{\n\t\tif (width > SNES_WIDTH && height <= SNES_HEIGHT_EXTENDED)\n\t\t\timgheight = height << 1;\n\t}\n\telse if (Settings.StretchScreenshots == 2)\n\t{\n\t\tif (width  <= SNES_WIDTH)\n\t\t\timgwidth  = width  << 1;\n\t\tif (height <= SNES_HEIGHT_EXTENDED)\n\t\t\timgheight = height << 1;\n\t}\n\n\tpng_init_io(png_ptr, fp);\n\n\tpng_set_IHDR(png_ptr, info_ptr, imgwidth, imgheight, 8, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\n\n\tsig_bit.red   = 5;\n\tsig_bit.green = 5;\n\tsig_bit.blue  = 5;\n\tpng_set_sBIT(png_ptr, info_ptr, &sig_bit);\n\tpng_set_shift(png_ptr, &sig_bit);\n\n\tpng_write_info(png_ptr, info_ptr);\n\n\tpng_set_packing(png_ptr);\n\n\tpng_byte\t*row_pointer = new png_byte[png_get_rowbytes(png_ptr, info_ptr)];\n\tuint16\t\t*screen = GFX.Screen;\n\n\tfor (int y = 0; y < height; y++, screen += GFX.RealPPL)\n\t{\n\t\tpng_byte\t*rowpix = row_pointer;\n\n\t\tfor (int x = 0; x < width; x++)\n\t\t{\n\t\t\tuint32\tr, g, b;\n\n\t\t\tDECOMPOSE_PIXEL(screen[x], r, g, b);\n\n\t\t\t*(rowpix++) = r;\n\t\t\t*(rowpix++) = g;\n\t\t\t*(rowpix++) = b;\n\n\t\t\tif (imgwidth != width)\n\t\t\t{\n\t\t\t\t*(rowpix++) = r;\n\t\t\t\t*(rowpix++) = g;\n\t\t\t\t*(rowpix++) = b;\n\t\t\t}\n\t\t}\n\n\t\tpng_write_row(png_ptr, row_pointer);\n\t\tif (imgheight != height)\n\t\t\tpng_write_row(png_ptr, row_pointer);\n\t}\n\n\tdelete [] row_pointer;\n\n\tpng_write_end(png_ptr, info_ptr);\n\tpng_destroy_write_struct(&png_ptr, &info_ptr);\n\n\tfclose(fp);\n\n\tfprintf(stderr, \"%s saved.\\n\", fname.c_str());\n\n\tstd::string base = \"Saved screenshot \" + S9xBasename(fname);\n\tS9xMessage(S9X_INFO, 0, base.c_str());\n\n\treturn (TRUE);\n#else\n\tfprintf(stderr, \"Screenshot support not available (libpng was not found at build time).\\n\");\n\treturn (FALSE);\n#endif\n}\n"
        },
        {
          "name": "screenshot.h",
          "type": "blob",
          "size": 0.453125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _SCREENSHOT_H_\n#define _SCREENSHOT_H_\n\nbool8 S9xDoScreenshot (int, int);\n\n#endif\n"
        },
        {
          "name": "sdd1.cpp",
          "type": "blob",
          "size": 0.9990234375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"sdd1.h\"\n#include \"display.h\"\n\n\nvoid S9xSetSDD1MemoryMap (uint32 bank, uint32 value)\n{\n\tbank = 0xc00 + bank * 0x100;\n\tvalue = value * 1024 * 1024;\n\n\tfor (int c = 0; c < 0x100; c += 16)\n\t{\n\t\tuint8\t*block = &Memory.ROM[value + (c << 12)];\n\t\tfor (int i = c; i < c + 16; i++)\n\t\t\tMemory.Map[i + bank] = block;\n\t}\n}\n\nvoid S9xResetSDD1 (void)\n{\n\tmemset(&Memory.FillRAM[0x4800], 0, 4);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tMemory.FillRAM[0x4804 + i] = i;\n\t\tS9xSetSDD1MemoryMap(i, i);\n\t}\n}\n\nvoid S9xSDD1PostLoadState (void)\n{\n\tfor (int i = 0; i < 4; i++)\n\t\tS9xSetSDD1MemoryMap(i, Memory.FillRAM[0x4804 + i]);\n}\n"
        },
        {
          "name": "sdd1.h",
          "type": "blob",
          "size": 0.5087890625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _SDD1_H_\n#define _SDD1_H_\n\nvoid S9xSetSDD1MemoryMap (uint32, uint32);\nvoid S9xResetSDD1 (void);\nvoid S9xSDD1PostLoadState (void);\n\n#endif\n"
        },
        {
          "name": "sdd1emu.cpp",
          "type": "blob",
          "size": 9.06640625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n/* S-DD1 decompressor\n *\n * Based on code and documentation by Andreas Naive, who deserves a great deal\n * of thanks and credit for figuring this out.\n *\n * Andreas says:\n * The author is greatly indebted with The Dumper, without whose help and\n * patience providing him with real S-DD1 data the research had never been\n * possible. He also wish to note that in the very beggining of his research,\n * Neviksti had done some steps in the right direction. By last, the author is\n * indirectly indebted to all the people that worked and contributed in the\n * S-DD1 issue in the past.\n */\n\n\n#include \"port.h\"\n#include \"sdd1emu.h\"\n\nstatic int valid_bits;\nstatic uint16 in_stream;\nstatic uint8 *in_buf;\nstatic uint8 bit_ctr[8];\nstatic uint8 context_states[32];\nstatic int context_MPS[32];\nstatic int bitplane_type;\nstatic int high_context_bits;\nstatic int low_context_bits;\nstatic int prev_bits[8];\n\nstatic struct {\n    uint8 code_size;\n    uint8 MPS_next;\n    uint8 LPS_next;\n} evolution_table[] = {\n    /*  0 */ { 0,25,25},\n    /*  1 */ { 0, 2, 1},\n    /*  2 */ { 0, 3, 1},\n    /*  3 */ { 0, 4, 2},\n    /*  4 */ { 0, 5, 3},\n    /*  5 */ { 1, 6, 4},\n    /*  6 */ { 1, 7, 5},\n    /*  7 */ { 1, 8, 6},\n    /*  8 */ { 1, 9, 7},\n    /*  9 */ { 2,10, 8},\n    /* 10 */ { 2,11, 9},\n    /* 11 */ { 2,12,10},\n    /* 12 */ { 2,13,11},\n    /* 13 */ { 3,14,12},\n    /* 14 */ { 3,15,13},\n    /* 15 */ { 3,16,14},\n    /* 16 */ { 3,17,15},\n    /* 17 */ { 4,18,16},\n    /* 18 */ { 4,19,17},\n    /* 19 */ { 5,20,18},\n    /* 20 */ { 5,21,19},\n    /* 21 */ { 6,22,20},\n    /* 22 */ { 6,23,21},\n    /* 23 */ { 7,24,22},\n    /* 24 */ { 7,24,23},\n    /* 25 */ { 0,26, 1},\n    /* 26 */ { 1,27, 2},\n    /* 27 */ { 2,28, 4},\n    /* 28 */ { 3,29, 8},\n    /* 29 */ { 4,30,12},\n    /* 30 */ { 5,31,16},\n    /* 31 */ { 6,32,18},\n    /* 32 */ { 7,24,22}\n};\n\nstatic uint8 run_table[128] = {\n    128,  64,  96,  32, 112,  48,  80,  16, 120,  56,  88,  24, 104,  40,  72,\n      8, 124,  60,  92,  28, 108,  44,  76,  12, 116,  52,  84,  20, 100,  36,\n     68,   4, 126,  62,  94,  30, 110,  46,  78,  14, 118,  54,  86,  22, 102,\n     38,  70,   6, 122,  58,  90,  26, 106,  42,  74,  10, 114,  50,  82,  18,\n     98,  34,  66,   2, 127,  63,  95,  31, 111,  47,  79,  15, 119,  55,  87,\n     23, 103,  39,  71,   7, 123,  59,  91,  27, 107,  43,  75,  11, 115,  51,\n     83,  19,  99,  35,  67,   3, 125,  61,  93,  29, 109,  45,  77,  13, 117,\n     53,  85,  21, 101,  37,  69,   5, 121,  57,  89,  25, 105,  41,  73,   9,\n    113,  49,  81,  17,  97,  33,  65,   1\n};\n\nstatic inline uint8 GetCodeword(int bits){\n    uint8 tmp;\n\n    if(!valid_bits){\n        in_stream|=*(in_buf++);\n        valid_bits=8;\n    }\n    in_stream<<=1;\n    valid_bits--;\n    in_stream^=0x8000;\n    if(in_stream&0x8000) return 0x80+(1<<bits);\n    tmp=(in_stream>>8) | (0x7f>>bits);\n    in_stream<<=bits;\n    valid_bits-=bits;\n    if(valid_bits<0){\n        in_stream |= (*(in_buf++))<<(-valid_bits);\n        valid_bits+=8;\n    }\n    return run_table[tmp];\n}\n\nstatic inline uint8 GolombGetBit(int code_size){\n    if(!bit_ctr[code_size]) bit_ctr[code_size]=GetCodeword(code_size);\n    bit_ctr[code_size]--;\n    if(bit_ctr[code_size]==0x80){\n        bit_ctr[code_size]=0;\n        return 2; /* secret code for 'last zero'. ones are always last. */\n    }\n    return (bit_ctr[code_size]==0)?1:0;\n}\n\nstatic inline uint8 ProbGetBit(uint8 context){\n    uint8 state=context_states[context];\n    uint8 bit=GolombGetBit(evolution_table[state].code_size);\n\n    if(bit&1){\n        context_states[context]=evolution_table[state].LPS_next;\n        if(state<2){\n            context_MPS[context]^=1;\n            return context_MPS[context]; /* just inverted, so just return it */\n        } else{\n            return context_MPS[context]^1; /* we know bit is 1, so use a constant */\n        }\n    } else if(bit){\n        context_states[context]=evolution_table[state].MPS_next;\n        /* zero here, zero there, no difference so drop through. */\n    }\n    return context_MPS[context]; /* we know bit is 0, so don't bother xoring */\n}\n\nstatic inline uint8 GetBit(uint8 cur_bitplane){\n    uint8 bit;\n\n    bit=ProbGetBit(((cur_bitplane&1)<<4)\n                   | ((prev_bits[cur_bitplane]&high_context_bits)>>5)\n                   | (prev_bits[cur_bitplane]&low_context_bits));\n\n    prev_bits[cur_bitplane] <<= 1;\n    prev_bits[cur_bitplane] |= bit;\n    return bit;\n}\n\nvoid SDD1_decompress(uint8 *out, uint8 *in, int len){\n    uint8 bit, i, plane;\n    uint8 byte1, byte2;\n\n    if(len==0) len=0x10000;\n\n    bitplane_type=in[0]>>6;\n\n    switch(in[0]&0x30){\n      case 0x00:\n        high_context_bits=0x01c0;\n        low_context_bits =0x0001;\n        break;\n      case 0x10:\n        high_context_bits=0x0180;\n        low_context_bits =0x0001;\n        break;\n      case 0x20:\n        high_context_bits=0x00c0;\n        low_context_bits =0x0001;\n        break;\n      case 0x30:\n        high_context_bits=0x0180;\n        low_context_bits =0x0003;\n        break;\n    }\n\n    in_stream=(in[0]<<11) | (in[1]<<3);\n    valid_bits=5;\n    in_buf=in+2;\n    memset(bit_ctr, 0, sizeof(bit_ctr));\n    memset(context_states, 0, sizeof(context_states));\n    memset(context_MPS, 0, sizeof(context_MPS));\n    memset(prev_bits, 0, sizeof(prev_bits));\n\n    switch(bitplane_type){\n      case 0:\n        while(1) {\n            for(byte1=byte2=0, bit=0x80; bit; bit>>=1){\n                if(GetBit(0)) byte1 |= bit;\n                if(GetBit(1)) byte2 |= bit;\n            }\n            *(out++)=byte1;\n            if(!--len) return;\n            *(out++)=byte2;\n            if(!--len) return;\n        }\n        break;\n      case 1:\n        i=plane=0;\n        while(1) {\n            for(byte1=byte2=0, bit=0x80; bit; bit>>=1){\n                if(GetBit(plane)) byte1 |= bit;\n                if(GetBit(plane+1)) byte2 |= bit;\n            }\n            *(out++)=byte1;\n            if(!--len) return;\n            *(out++)=byte2;\n            if(!--len) return;\n            if(!(i+=32)) plane = (plane+2)&7;\n        }\n        break;\n      case 2:\n        i=plane=0;\n        while(1) {\n            for(byte1=byte2=0, bit=0x80; bit; bit>>=1){\n                if(GetBit(plane)) byte1 |= bit;\n                if(GetBit(plane+1)) byte2 |= bit;\n            }\n            *(out++)=byte1;\n            if(!--len) return;\n            *(out++)=byte2;\n            if(!--len) return;\n            if(!(i+=32)) plane ^= 2;\n        }\n        break;\n      case 3:\n        do {\n            for(byte1=plane=0, bit=1; bit; bit<<=1, plane++){\n                if(GetBit(plane)) byte1 |= bit;\n            }\n            *(out++)=byte1;\n        } while(--len);\n        break;\n    }\n}\n\n#if 0\nstatic uint8 cur_plane;\nstatic uint8 num_bits;\nstatic uint8 next_byte;\n\nvoid SDD1_init(uint8 *in){\n    bitplane_type=in[0]>>6;\n\n    switch(in[0]&0x30){\n      case 0x00:\n        high_context_bits=0x01c0;\n        low_context_bits =0x0001;\n        break;\n      case 0x10:\n        high_context_bits=0x0180;\n        low_context_bits =0x0001;\n        break;\n      case 0x20:\n        high_context_bits=0x00c0;\n        low_context_bits =0x0001;\n        break;\n      case 0x30:\n        high_context_bits=0x0180;\n        low_context_bits =0x0003;\n        break;\n    }\n\n    in_stream=(in[0]<<11) | (in[1]<<3);\n    valid_bits=5;\n    in_buf=in+2;\n    memset(bit_ctr, 0, sizeof(bit_ctr));\n    memset(context_states, 0, sizeof(context_states));\n    memset(context_MPS, 0, sizeof(context_MPS));\n    memset(prev_bits, 0, sizeof(prev_bits));\n\n    cur_plane=0;\n    num_bits=0;\n}\n\nuint8 SDD1_get_byte(void){\n    uint8 bit;\n    uint8 byte=0;\n\n    switch(bitplane_type){\n      case 0:\n        num_bits+=16;\n        if(num_bits&16){\n            next_byte=0;\n            for(bit=0x80; bit; bit>>=1){\n                if(GetBit(0)) byte |= bit;\n                if(GetBit(1)) next_byte |= bit;\n            }\n            return byte;\n        } else {\n            return next_byte;\n        }\n\n      case 1:\n        num_bits+=16;\n        if(num_bits&16){\n            next_byte=0;\n            for(bit=0x80; bit; bit>>=1){\n                if(GetBit(cur_plane)) byte |= bit;\n                if(GetBit(cur_plane+1)) next_byte |= bit;\n            }\n            return byte;\n        } else {\n            if(!num_bits) cur_plane = (cur_plane+2)&7;\n            return next_byte;\n        }\n\n      case 2:\n        num_bits+=16;\n        if(num_bits&16){\n            next_byte=0;\n            for(bit=0x80; bit; bit>>=1){\n                if(GetBit(cur_plane)) byte |= bit;\n                if(GetBit(cur_plane+1)) next_byte |= bit;\n            }\n            return byte;\n        } else {\n            if(!num_bits) cur_plane ^= 2;\n            return next_byte;\n        }\n\n      case 3:\n        for(cur_plane=0, bit=1; bit; bit<<=1, cur_plane++){\n            if(GetBit(cur_plane)) byte |= bit;\n        }\n        return byte;\n\n      default:\n        /* should never happen */\n        return 0;\n    }\n}\n#endif\n"
        },
        {
          "name": "sdd1emu.h",
          "type": "blob",
          "size": 0.458984375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _SDD1EMU_H_\n#define _SDD1EMU_H_\n\nvoid SDD1_decompress (uint8 *, uint8 *, int);\n\n#endif\n"
        },
        {
          "name": "server.cpp",
          "type": "blob",
          "size": 36.8359375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifdef NETPLAY_SUPPORT\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <memory.h>\n#include <sys/types.h>\n#ifdef HAVE_STRINGS_H\n\t#include <strings.h>\n#endif\n\n#include \"snes9x.h\"\n\n#ifdef __WIN32__\n\n\t#include <winsock.h>\n\t#include <process.h>\n\t#include \"win32/wsnes9x.h\"\n\t#define ioctl ioctlsocket\n\t#define close closesocket\n\t#define read(a,b,c) recv(a, b, c, 0)\n\t#define write(a,b,c) send(a, b, c, 0)\n\t#define gettimeofday(a,b) S9xGetTimeOfDay (a)\n\t#define exit(a) _endthread()\n\tvoid S9xGetTimeOfDay (struct timeval *n);\n#else\n\t#include <unistd.h>\n\t#include <sys/time.h>\n\n\t#include <netdb.h>\n\t#include <sys/socket.h>\n\t#include <sys/param.h>\n\t#include <netinet/in.h>\n\t#include <arpa/inet.h>\n\t#include <signal.h>\n\n\t#ifdef __SVR4\n\t\t#include <sys/stropts.h>\n\t#endif\n\n#endif // !__WIN32__\n\n#include \"memmap.h\"\n#include \"snapshot.h\"\n#include \"netplay.h\"\n\n#ifdef __WIN32__\n#define NP_ONE_CLIENT 1\n#else\n#define NP_ONE_CLIENT 0\n#endif\n\nstruct SNPServer NPServer;\n\nextern unsigned long START;\n\nvoid S9xNPSendToAllClients (uint8 *data, int len);\nbool8 S9xNPLoadFreezeFile (const char *fname, uint8 *&data, uint32 &len);\nvoid S9xNPSendFreezeFile (int c, uint8 *data, uint32 len);\nvoid S9xNPNoClientReady (int start_index = NP_ONE_CLIENT);\nvoid S9xNPRecomputePause ();\nvoid S9xNPWaitForEmulationToComplete ();\nvoid S9xNPSendROMImageToAllClients ();\nbool8 S9xNPSendROMImageToClient (int client);\nvoid S9xNPSendSRAMToClient (int c);\nvoid S9xNPSendSRAMToAllClients ();\nvoid S9xNPSyncClient (int);\nvoid S9xNPSendROMLoadRequest (const char *filename);\nvoid S9xNPSendFreezeFileToAllClients (const char *filename);\nvoid S9xNPStopServer ();\n\nvoid S9xNPShutdownClient (int c, bool8 report_error = FALSE)\n{\n    if (NPServer.Clients [c].Connected)\n    {\n        NPServer.Clients [c].Connected = FALSE;\n        NPServer.Clients [c].SaidHello = FALSE;\n\n        close (NPServer.Clients [c].Socket);\n#ifdef NP_DEBUG\n        printf (\"SERVER: Player %d disconnecting @%ld\\n\", c + 1, S9xGetMilliTime () - START);\n#endif\n        if (report_error)\n        {\n            sprintf (NetPlay.ErrorMsg,\n                     \"Player %d on '%s' has disconnected.\", c + 1,\n                     NPServer.Clients [c].HostName);\n            S9xNPSetWarning  (NetPlay.ErrorMsg);\n        }\n\n        if (NPServer.Clients [c].HostName)\n        {\n            free ((char *) NPServer.Clients [c].HostName);\n            NPServer.Clients [c].HostName = NULL;\n        }\n        if (NPServer.Clients [c].ROMName)\n        {\n            free ((char *) NPServer.Clients [c].ROMName);\n            NPServer.Clients [c].ROMName = NULL;\n        }\n        if (NPServer.Clients [c].Who)\n        {\n            free ((char *) NPServer.Clients [c].Who);\n            NPServer.Clients [c].Who = NULL;\n        }\n        NPServer.Joypads [c] = 0;\n        NPServer.NumClients--;\n        S9xNPRecomputePause ();\n    }\n}\n\nstatic bool8 S9xNPSGetData (int socket, uint8 *data, int length)\n{\n    int len = length;\n    uint8 *ptr = data;\n\n    do\n    {\n        int num_bytes = len;\n\n        // Read the data in small chunks, allowing this thread to spot an\n        // abort request from another thread.\n        if (num_bytes > 512)\n            num_bytes = 512;\n\n        int got = read (socket, (char *) ptr, num_bytes);\n        if (got < 0)\n        {\n\t    if (errno == EINTR\n#ifdef EAGAIN\n\t\t|| errno == EAGAIN\n#endif\n#ifdef EWOULDBLOCK\n\t\t|| errno == EWOULDBLOCK\n#endif\n#ifdef WSAEWOULDBLOCK\n                || errno == WSAEWOULDBLOCK\n#endif\n\t\t)\n\t\tcontinue;\n#ifdef WSAEMSGSIZE\n            if (errno != WSAEMSGSIZE)\n                return (FALSE);\n            else\n            {\n                got = num_bytes;\n#ifdef NP_DEBUG\n                printf (\"SERVER: WSAEMSGSIZE, actual bytes %d while receiving data @%d\\n\", got, S9xGetMilliTime () - START);\n#endif\n            }\n#else\n            return (FALSE);\n#endif\n        }\n        else\n        if (got == 0)\n            return (FALSE);\n\n        len -= got;\n        ptr += got;\n    } while (len > 0);\n\n    return (TRUE);\n}\n\nstatic bool8 S9xNPSSendData (int fd, const uint8 *data, int length)\n{\n    int len = length;\n    int chunk = length / 50;\n\n    if (chunk < 1024)\n        chunk = 1024;\n\n    do\n    {\n        int num_bytes = len;\n\n        // Write the data in small chunks, allowing this thread to spot an\n        // abort request from another thread.\n        if (num_bytes > chunk)\n            num_bytes = chunk;\n\n\tint sent;\n\tsent = write (fd, (char *) data, len);\n\n\tif (sent < 0)\n\t{\n\t    if (errno == EINTR\n#ifdef EAGAIN\n\t\t|| errno == EAGAIN\n#endif\n#ifdef EWOULDBLOCK\n\t\t|| errno == EWOULDBLOCK\n#endif\n\t\t)\n            {\n#ifdef NP_DEBUG\n                printf (\"SERVER: EINTR, EAGAIN or EWOULDBLOCK while sending data @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n\t\tcontinue;\n            }\n\t    return (FALSE);\n\t}\n\telse\n\tif (sent == 0)\n\t    return (FALSE);\n\tlen -= sent;\n\tdata += sent;\n        if (length > 1024)\n        {\n#ifdef __WIN32__\n            int Percent = (uint8) (((length - len) * 100) / length);\n            PostMessage (GUI.hWnd, WM_USER, Percent, Percent);\n            Sleep (0);\n#endif\n        }\n    } while (len > 0);\n\n    return (TRUE);\n}\n\nvoid S9xNPSendHeartBeat ()\n{\n    int len = 3;\n    uint8 data [(3 + 4) * 8];\n    uint8 *ptr = data;\n    int n;\n\n    for (n = NP_MAX_CLIENTS - 1; n >= 0; n--)\n    {\n        if (NPServer.Clients [n].SaidHello)\n            break;\n    }\n\n    if (n >= 0)\n    {\n        bool8 Paused = NPServer.Paused != 0;\n\n        NPServer.FrameCount++;\n        *ptr++ = NP_SERV_MAGIC;\n        *ptr++ = 0; // Individual client sequence number will get placed here\n        *ptr++ = NP_SERV_JOYPAD | (n << 6) | ((Paused != 0) << 5);\n\n        WRITE_LONG (ptr, NPServer.FrameCount);\n        len += 4;\n        ptr += 4;\n\n        int i;\n\n        for (i = 0; i <= n; i++)\n        {\n            WRITE_LONG (ptr, NPServer.Joypads [i]);\n            len += 4;\n            ptr += 4;\n        }\n\n        S9xNPSendToAllClients (data, len);\n    }\n}\n\nvoid S9xNPSendToAllClients (uint8 *data, int len)\n{\n    int i;\n\n    for (i = 0; i < NP_MAX_CLIENTS; i++)\n    {\n\tif (NPServer.Clients [i].SaidHello)\n\t{\n            data [1] = NPServer.Clients [i].SendSequenceNum++;\n\t    if (!S9xNPSSendData (NPServer.Clients [i].Socket, data, len))\n\t\tS9xNPShutdownClient (i, TRUE);\n\t}\n    }\n}\n\nvoid S9xNPProcessClient (int c)\n{\n    uint8 header [7];\n    uint8 *data;\n    uint32 len;\n    uint8 *ptr;\n\n    if (!S9xNPSGetData (NPServer.Clients [c].Socket, header, 7))\n    {\n        S9xNPSetWarning (\"SERVER: Failed to get message header from client.\\n\");\n        S9xNPShutdownClient (c, TRUE);\n        return;\n    }\n    if (header [0] != NP_CLNT_MAGIC)\n    {\n        S9xNPSetWarning (\"SERVER: Bad header magic value received from client.\\n\");\n        S9xNPShutdownClient (c, TRUE);\n        return;\n    }\n\n    if (header [1] != NPServer.Clients [c].ReceiveSequenceNum)\n    {\n#ifdef NP_DEBUG\n        printf (\"SERVER: Messages lost from '%s', expected %d, got %d\\n\",\n                NPServer.Clients [c].HostName ?\n                NPServer.Clients [c].HostName : \"Unknown\",\n                NPServer.Clients [c].ReceiveSequenceNum,\n                header [1]);\n#endif\n        sprintf (NetPlay.WarningMsg,\n                 \"SERVER: Messages lost from '%s', expected %d, got %d\\n\",\n                NPServer.Clients [c].HostName ?\n                NPServer.Clients [c].HostName : \"Unknown\",\n                NPServer.Clients [c].ReceiveSequenceNum,\n                header [1]);\n        NPServer.Clients [c].ReceiveSequenceNum = header [1] + 1;\n        S9xNPSetWarning (NetPlay.WarningMsg);\n    }\n    else\n        NPServer.Clients [c].ReceiveSequenceNum++;\n\n    len = READ_LONG (&header [3]);\n\n    switch (header [2] & 0x3f)\n    {\n        case NP_CLNT_HELLO:\n#ifdef NP_DEBUG\n            printf (\"SERVER: Got HELLO from client @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n            S9xNPSetAction (\"Got HELLO from client...\", TRUE);\n            if (len > 0x10000)\n            {\n                S9xNPSetWarning (\"SERVER: Client HELLO message length error.\");\n                S9xNPShutdownClient (c, TRUE);\n                return;\n            }\n            data = new uint8 [len - 7];\n            if (!S9xNPSGetData (NPServer.Clients [c].Socket, data, len - 7))\n            {\n                S9xNPSetWarning (\"SERVER: Failed to get HELLO message content from client.\");\n                S9xNPShutdownClient (c, TRUE);\n                return;\n            }\n\n            if (NPServer.NumClients <= NP_ONE_CLIENT)\n            {\n\t\tNPServer.FrameTime = READ_LONG (data);\n\t\tstrncpy (NPServer.ROMName, (char *) &data [4], 29);\n\t\tNPServer.ROMName [29] = 0;\n            }\n\n            NPServer.Clients [c].ROMName = strdup ((char *) &data [4]);\n#ifdef NP_DEBUG\n            printf (\"SERVER: Client is playing: %s, Frame Time: %d @%ld\\n\", data + 4, READ_LONG (data), S9xGetMilliTime () - START);\n#endif\n\n            NPServer.Clients [c].SendSequenceNum = 0;\n\n            len = 7 + 1 + 1 + 4 + strlen (NPServer.ROMName) + 1;\n\n            delete[] data;\n            ptr = data = new uint8 [len];\n            *ptr++ = NP_SERV_MAGIC;\n            *ptr++ = NPServer.Clients [c].SendSequenceNum++;\n\n            if (NPServer.SendROMImageOnConnect &&\n                NPServer.NumClients > NP_ONE_CLIENT)\n                *ptr++ = NP_SERV_HELLO | 0x80;\n            else\n                *ptr++ = NP_SERV_HELLO;\n            WRITE_LONG (ptr, len);\n            ptr += 4;\n            *ptr++ = NP_VERSION;\n            *ptr++ = c + 1;\n            WRITE_LONG (ptr, NPServer.FrameCount);\n            ptr += 4;\n            strcpy ((char *) ptr, NPServer.ROMName);\n\n#ifdef NP_DEBUG\n            printf (\"SERVER: Sending welcome information to client @%ld...\\n\", S9xGetMilliTime () - START);\n#endif\n            S9xNPSetAction (\"SERVER: Sending welcome information to new client...\", TRUE);\n            if (!S9xNPSSendData (NPServer.Clients [c].Socket, data, len))\n            {\n                S9xNPSetWarning (\"SERVER: Failed to send welcome message to client.\");\n                S9xNPShutdownClient (c, TRUE);\n                return;\n            }\n            delete[] data;\n#ifdef NP_DEBUG\n            printf (\"SERVER: Waiting for a response from the client @%ld...\\n\", S9xGetMilliTime () - START);\n#endif\n            S9xNPSetAction (\"SERVER: Waiting for a response from the client...\", TRUE);\n            break;\n\n        case NP_CLNT_LOADED_ROM:\n#ifdef NP_DEBUG\n            printf (\"SERVER: Client %d loaded requested ROM @%ld...\\n\", c, S9xGetMilliTime () - START);\n#endif\n            NPServer.Clients [c].SaidHello = TRUE;\n            NPServer.Clients [c].Ready = FALSE;\n            NPServer.Clients [c].Paused = FALSE;\n            S9xNPRecomputePause ();\n            S9xNPWaitForEmulationToComplete ();\n\n            if (NPServer.SyncByReset)\n            {\n                S9xNPServerAddTask (NP_SERVER_SEND_SRAM, (void *) (pint) c);\n                S9xNPServerAddTask (NP_SERVER_RESET_ALL, 0);\n            }\n            else\n                S9xNPServerAddTask (NP_SERVER_SYNC_CLIENT, (void *) (pint) c);\n            break;\n\n        case NP_CLNT_RECEIVED_ROM_IMAGE:\n#ifdef NP_DEBUG\n            printf (\"SERVER: Client %d received ROM image @%ld...\\n\", c, S9xGetMilliTime () - START);\n#endif\n            NPServer.Clients [c].SaidHello = TRUE;\n            NPServer.Clients [c].Ready = FALSE;\n            NPServer.Clients [c].Paused = FALSE;\n            S9xNPRecomputePause ();\n            S9xNPWaitForEmulationToComplete ();\n\n            if (NPServer.SyncByReset)\n            {\n                S9xNPServerAddTask (NP_SERVER_SEND_SRAM, (void *) (pint) c);\n                S9xNPServerAddTask (NP_SERVER_RESET_ALL, 0);\n            }\n            else\n                S9xNPServerAddTask (NP_SERVER_SYNC_CLIENT, (void *) (pint) c);\n\n            break;\n\n        case NP_CLNT_WAITING_FOR_ROM_IMAGE:\n#ifdef NP_DEBUG\n            printf (\"SERVER: Client %d waiting for ROM image @%ld...\\n\", c, S9xGetMilliTime () - START);\n#endif\n            NPServer.Clients [c].SaidHello = TRUE;\n            NPServer.Clients [c].Ready = FALSE;\n            NPServer.Clients [c].Paused = FALSE;\n            S9xNPRecomputePause ();\n            S9xNPSendROMImageToClient (c);\n            break;\n\n        case NP_CLNT_READY:\n#ifdef NP_DEBUG\n            printf (\"SERVER: Client %d ready @%ld...\\n\", c, S9xGetMilliTime () - START);\n#endif\n            if (NPServer.Clients [c].SaidHello)\n            {\n                NPServer.Clients [c].Paused = FALSE;\n                NPServer.Clients [c].Ready = TRUE;\n\n                S9xNPRecomputePause ();\n                break;\n            }\n            NPServer.Clients [c].SaidHello = TRUE;\n            NPServer.Clients [c].Ready = TRUE;\n            NPServer.Clients [c].Paused = FALSE;\n            S9xNPRecomputePause ();\n\n//printf (\"SERVER: SaidHello = TRUE, SeqNum = %d @%d\\n\", NPServer.Clients [c].SendSequenceNum, S9xGetMilliTime () - START);\n            if (NPServer.NumClients > NP_ONE_CLIENT)\n            {\n                if (!NPServer.SendROMImageOnConnect)\n                {\n                    S9xNPWaitForEmulationToComplete ();\n\n                    if (NPServer.SyncByReset)\n                    {\n                        S9xNPServerAddTask (NP_SERVER_SEND_SRAM, (void *) (pint) c);\n                        S9xNPServerAddTask (NP_SERVER_RESET_ALL, 0);\n                    }\n                    else\n#ifdef __WIN32__\n                        S9xNPServerAddTask (NP_SERVER_SYNC_CLIENT, (void *)(UINT_PTR) c);\n#else\n                        /* We need to resync all clients on new player connect as we don't have a 'reference game' */\n                        S9xNPServerAddTask (NP_SERVER_SYNC_ALL, (void *) (pint) c);\n#endif\n                }\n            }\n            else\n            {\n                NPServer.Clients [c].Ready = TRUE;\n                S9xNPRecomputePause ();\n            }\n            break;\n        case NP_CLNT_JOYPAD:\n            NPServer.Joypads [c] = len;\n            break;\n        case NP_CLNT_PAUSE:\n#ifdef NP_DEBUG\n            printf (\"SERVER: Client %d Paused: %s @%ld\\n\", c, (header [2] & 0x80) ? \"YES\" : \"NO\", S9xGetMilliTime () - START);\n#endif\n            NPServer.Clients [c].Paused = (header [2] & 0x80) != 0;\n            if (NPServer.Clients [c].Paused)\n                sprintf (NetPlay.WarningMsg, \"SERVER: Client %d has paused.\", c + 1);\n            else\n                sprintf (NetPlay.WarningMsg, \"SERVER: Client %d has resumed.\", c + 1);\n            S9xNPSetWarning (NetPlay.WarningMsg);\n            S9xNPRecomputePause ();\n            break;\n    }\n}\n\nvoid S9xNPAcceptClient (int Listen, bool8 block)\n{\n    struct sockaddr_in remote_address;\n    struct linger val2;\n    struct hostent *host;\n    int new_fd;\n    int i;\n\n#ifdef NP_DEBUG\n    printf (\"SERVER: attempting to accept new client connection @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"SERVER: Attempting to accept client connection...\", TRUE);\n    memset (&remote_address, 0, sizeof (remote_address));\n    socklen_t len = sizeof (remote_address);\n\n    new_fd = accept (Listen, (struct sockaddr *)&remote_address, &len);\n\n    S9xNPSetAction (\"Setting socket options...\", TRUE);\n    val2.l_onoff = 1;\n    val2.l_linger = 0;\n    if (setsockopt (new_fd, SOL_SOCKET, SO_LINGER,\n\t\t    (char *) &val2, sizeof (val2)) < 0)\n    {\n        S9xNPSetError (\"Setting socket options failed.\");\n\tclose (new_fd);\n        return;\n    }\n\n    for (i = 0; i < NP_MAX_CLIENTS; i++)\n    {\n\tif (!NPServer.Clients [i].Connected)\n\t{\n            NPServer.NumClients++;\n\t    NPServer.Clients [i].Socket = new_fd;\n            NPServer.Clients [i].SendSequenceNum = 0;\n            NPServer.Clients [i].ReceiveSequenceNum = 0;\n            NPServer.Clients [i].Connected = TRUE;\n            NPServer.Clients [i].SaidHello = FALSE;\n            NPServer.Clients [i].Paused = FALSE;\n            NPServer.Clients [i].Ready = FALSE;\n            NPServer.Clients [i].ROMName = NULL;\n            NPServer.Clients [i].HostName = NULL;\n            NPServer.Clients [i].Who = NULL;\n\t    break;\n\t}\n    }\n\n    if (i >= NP_MAX_CLIENTS)\n    {\n        S9xNPSetError (\"SERVER: Maximum number of NetPlay Clients have already connected.\");\n\tclose (new_fd);\n\treturn;\n    }\n\n    if (remote_address.sin_family == AF_INET)\n    {\n#ifdef NP_DEBUG\n        printf (\"SERVER: Looking up new client's hostname @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n        S9xNPSetAction (\"SERVER: Looking up new client's hostname...\", TRUE);\n\thost = gethostbyaddr ((char *) &remote_address.sin_addr,\n\t\t\t      sizeof (remote_address.sin_addr), AF_INET);\n\n\tif (host)\n\t{\n#ifdef NP_DEBUG\n            printf (\"SERVER: resolved new client's hostname (%s) @%ld\\n\", host->h_name, S9xGetMilliTime () - START);\n#endif\n\t    sprintf (NetPlay.WarningMsg, \"SERVER: Player %d on %s has connected.\", i + 1, host->h_name);\n\t    NPServer.Clients [i].HostName = strdup (host->h_name);\n\t}\n        else\n        {\n            char *ip = inet_ntoa (remote_address.sin_addr);\n            if (ip)\n                NPServer.Clients [i].HostName = strdup (ip);\n#ifdef NP_DEBUG\n            printf (\"SERVER: couldn't resolve new client's hostname (%s) @%ld\\n\", ip ? ip : \"Unknown\", S9xGetMilliTime () - START);\n#endif\n\t    sprintf (NetPlay.WarningMsg, \"SERVER: Player %d on %s has connected.\", i + 1, ip ? ip : \"Unknown\");\n        }\n        S9xNPSetWarning (NetPlay.WarningMsg);\n    }\n#ifdef NP_DEBUG\n    printf (\"SERVER: waiting for HELLO message from new client @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    S9xNPSetAction (\"SERVER: Waiting for HELLO message from new client...\");\n}\n\nstatic bool8 server_continue = TRUE;\n\nstatic bool8 S9xNPServerInit (int port)\n{\n    struct sockaddr_in address;\n    int i;\n    int val;\n\n    if (!S9xNPInitialise ())\n        return (FALSE);\n\n    for (i = 0; i < NP_MAX_CLIENTS; i++)\n    {\n        NPServer.Clients [i].SendSequenceNum = 0;\n        NPServer.Clients [i].ReceiveSequenceNum = 0;\n        NPServer.Clients [i].Connected = FALSE;\n        NPServer.Clients [i].SaidHello = FALSE;\n        NPServer.Clients [i].Paused = FALSE;\n        NPServer.Clients [i].Ready = FALSE;\n        NPServer.Clients [i].Socket = 0;\n        NPServer.Clients [i].ROMName = NULL;\n        NPServer.Clients [i].HostName = NULL;\n        NPServer.Clients [i].Who = NULL;\n        NPServer.Joypads [i] = 0;\n    }\n\n    NPServer.NumClients = 0;\n    NPServer.FrameCount = 0;\n\n#ifdef NP_DEBUG\n    printf (\"SERVER: Creating socket @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    if ((NPServer.Socket = socket (AF_INET, SOCK_STREAM, 0)) < 0)\n    {\n\tS9xNPSetError (\"NetPlay Server: Can't create listening socket.\");\n\treturn (FALSE);\n    }\n\n    val = 1;\n    setsockopt (NPServer.Socket, SOL_SOCKET, SO_REUSEADDR,\n                (char *)&val, sizeof (val));\n\n    memset (&address, 0, sizeof (address));\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = htonl (INADDR_ANY);\n    address.sin_port = htons (port);\n\n#ifdef NP_DEBUG\n    printf (\"SERVER: Binding socket to address and port @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    if (bind (NPServer.Socket, (struct sockaddr *) &address, sizeof (address)) < 0)\n    {\n\tS9xNPSetError (\"NetPlay Server: Can't bind socket to port number.\\nPort already in use?\");\n\treturn (FALSE);\n    }\n\n#ifdef NP_DEBUG\n    printf (\"SERVER: Getting socket to listen @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    if (listen (NPServer.Socket, NP_MAX_CLIENTS) < 0)\n    {\n\tS9xNPSetError (\"NetPlay Server: Can't get new socket to listen.\");\n\treturn (FALSE);\n    }\n\n#ifdef NP_DEBUG\n    printf (\"SERVER: Init complete @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    return (TRUE);\n}\n\nvoid S9xNPSendServerPause (bool8 paused)\n{\n#ifdef NP_DEBUG\n    printf (\"SERVER: Pause - %s @%ld\\n\", paused ? \"YES\" : \"NO\", S9xGetMilliTime () - START);\n#endif\n    uint8 pause [7];\n    uint8 *ptr = pause;\n    *ptr++ = NP_SERV_MAGIC;\n    *ptr++ = 0;\n    *ptr++ = NP_SERV_PAUSE | (paused ? 0x20 : 0);\n    WRITE_LONG (ptr, NPServer.FrameCount);\n    S9xNPSendToAllClients (pause, 7);\n}\n\nvoid S9xNPSendJoypadSwap()\n{\n#ifdef NP_DEBUG\n\tprintf(\"SERVER: Swap Joypads - @%ld\\n\", S9xGetMilliTime() - START);\n#endif\n\tuint8 swap[7];\n\tuint8 *ptr = swap;\n\t*ptr++ = NP_SERV_MAGIC;\n\t*ptr++ = 0;\n\t*ptr++ = NP_SERV_JOYPAD_SWAP;\n\tWRITE_LONG(ptr, 7);\n\tS9xNPSendToAllClients(swap, 7);\n}\n\nvoid S9xNPServerLoop (void *)\n{\n#ifdef __WIN32__\n    BOOL success = FALSE;\n#else\n    bool8 success = FALSE;\n    static struct timeval next1 = {0, 0};\n    struct timeval now;\n#endif\n\n\tint pausedState = -1, newPausedState = -1;\n\n    while (server_continue)\n    {\n        fd_set read_fds;\n        struct timeval timeout;\n        int res;\n        int i;\n\n        int max_fd = NPServer.Socket;\n\n#ifdef __WIN32__\n        Sleep (0);\n#endif\n\n        if (success && !(Settings.Paused && !Settings.FrameAdvance) && !Settings.StopEmulation &&\n            !Settings.ForcedPause && !NPServer.Paused)\n        {\n            S9xNPSendHeartBeat ();\n\t\t\tnewPausedState = 0;\n        }\n\t\telse\n\t\t{\n\t\t\tnewPausedState = 1;\n\t\t}\n\n\t\tif(pausedState != newPausedState)\n\t\t{\n\t\t\tpausedState = newPausedState;\n//\t\t\tS9xNPSendServerPause(pausedState); // XXX: doesn't seem to work yet...\n\t\t}\n\n        do\n        {\n            FD_ZERO (&read_fds);\n            FD_SET (NPServer.Socket, &read_fds);\n            for (i = 0; i < NP_MAX_CLIENTS; i++)\n            {\n                if (NPServer.Clients [i].Connected)\n                {\n                    FD_SET (NPServer.Clients [i].Socket, &read_fds);\n                    if (NPServer.Clients [i].Socket > max_fd)\n                        max_fd = NPServer.Clients [i].Socket;\n                }\n            }\n\n            timeout.tv_sec = 0;\n            timeout.tv_usec = 1000;\n            res = select (max_fd + 1, &read_fds, NULL, NULL, &timeout);\n\n            if (res > 0)\n            {\n                if (FD_ISSET (NPServer.Socket, &read_fds))\n                    S9xNPAcceptClient (NPServer.Socket, FALSE);\n\n                for (i = 0; i < NP_MAX_CLIENTS; i++)\n                {\n                    if (NPServer.Clients [i].Connected &&\n                        FD_ISSET (NPServer.Clients [i].Socket, &read_fds))\n                    {\n                        S9xNPProcessClient (i);\n                    }\n                }\n            }\n        } while (res > 0);\n\n#ifdef __WIN32__\n        success = WaitForSingleObject (GUI.ServerTimerSemaphore, 200) == WAIT_OBJECT_0;\n#else\n        while (gettimeofday (&now, NULL) < 0) ;\n\n        /* If there is no known \"next\" frame, initialize it now */\n        if (next1.tv_sec == 0) { next1 = now; ++next1.tv_usec; }\n\n\tsuccess=FALSE;\n\n\tif (timercmp(&next1, &now, >))\n        {\n            /* If we're ahead of time, sleep a while */\n            unsigned timeleft =\n                (next1.tv_sec - now.tv_sec) * 1000000\n                + next1.tv_usec - now.tv_usec;\n\t    usleep(timeleft<(200*1000)?timeleft:(200*1000));\n        }\n\n        if (!timercmp(&next1, &now, >))\n        {\n\n            /* Calculate the timestamp of the next frame. */\n            next1.tv_usec += Settings.FrameTime;\n            if (next1.tv_usec >= 1000000)\n            {\n                next1.tv_sec += next1.tv_usec / 1000000;\n                next1.tv_usec %= 1000000;\n            }\n            success=TRUE;\n         }\n#endif\n\n        while (NPServer.TaskHead != NPServer.TaskTail)\n        {\n            void *task_data = NPServer.TaskQueue [NPServer.TaskHead].Data;\n\n#if defined(NP_DEBUG) && NP_DEBUG == 2\n            printf (\"SERVER: task %d @%ld\\n\", NPServer.TaskQueue [NPServer.TaskHead].Task, S9xGetMilliTime () - START);\n#endif\n\n            switch (NPServer.TaskQueue [NPServer.TaskHead].Task)\n            {\n                case NP_SERVER_SEND_ROM_IMAGE:\n                    S9xNPSendROMImageToAllClients ();\n                    break;\n                case NP_SERVER_SYNC_CLIENT:\n                    NPServer.Clients [(pint) task_data].Ready = FALSE;\n                    S9xNPRecomputePause ();\n                    S9xNPSyncClient ((pint) task_data);\n                    break;\n                case NP_SERVER_SYNC_ALL:\n                    S9xNPSyncClients ();\n                    break;\n                case NP_SERVER_SEND_FREEZE_FILE_ALL:\n                    S9xNPSendFreezeFileToAllClients ((char *) task_data);\n                    free ((char *) task_data);\n                    break;\n                case NP_SERVER_SEND_ROM_LOAD_REQUEST_ALL:\n                    S9xNPSendROMLoadRequest ((char *) task_data);\n                    free ((char *) task_data);\n                    break;\n                case NP_SERVER_RESET_ALL:\n                    S9xNPNoClientReady (0);\n                    S9xNPWaitForEmulationToComplete ();\n                    S9xNPSetAction (\"SERVER: Sending RESET to all clients...\", TRUE);\n#ifdef NP_DEBUG\n                    printf (\"SERVER: Sending RESET to all clients @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n                    {\n                        uint8 reset [7];\n                        uint8 *ptr;\n\n                        ptr = reset;\n                        *ptr++ = NP_SERV_MAGIC;\n                        *ptr++ = 0;\n                        *ptr++ = NP_SERV_RESET;\n                        WRITE_LONG (ptr, NPServer.FrameCount);\n                        S9xNPSendToAllClients (reset, 7);\n                    }\n                    S9xNPSetAction (\"\", TRUE);\n                    break;\n                case NP_SERVER_SEND_SRAM:\n                    NPServer.Clients [(pint) task_data].Ready = FALSE;\n                    S9xNPRecomputePause ();\n                    S9xNPWaitForEmulationToComplete ();\n                    S9xNPSendSRAMToClient ((pint) task_data);\n                    break;\n\n                case NP_SERVER_SEND_SRAM_ALL:\n                    S9xNPNoClientReady ();\n                    S9xNPWaitForEmulationToComplete ();\n                    S9xNPSendSRAMToAllClients ();\n                    break;\n\n                default:\n                    S9xNPSetError (\"SERVER: *** Unknown task ***\\n\");\n                    break;\n            }\n            NPServer.TaskHead = (NPServer.TaskHead + 1) % NP_MAX_TASKS;\n        }\n    }\n#ifdef NP_DEBUG\n    printf (\"SERVER: Server thread exiting @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    // OV2: S9xNPStopServer has already been called if we get here\n    // S9xNPStopServer ();\n}\n\nbool8 S9xNPStartServer (int port)\n{\n#ifdef __WIN32__\n    static int p;\n    p = port;\n#endif\n\n#ifdef NP_DEBUG\n    printf (\"SERVER: Starting server on port %d @%ld\\n\", port, S9xGetMilliTime () - START);\n#endif\n\n    server_continue = TRUE;\n    if (S9xNPServerInit (port))\n#ifdef __WIN32__\n        return (_beginthread (S9xNPServerLoop, 0, &p) != (uintptr_t)(~0));\n#else\n    S9xNPServerLoop(NULL);\n    return (TRUE);\n#endif\n\n    return (FALSE);\n}\n\nvoid S9xNPStopServer ()\n{\n#ifdef NP_DEBUG\n    printf (\"SERVER: Stopping server @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    server_continue = FALSE;\n    close (NPServer.Socket);\n\n    for (int i = 0; i < NP_MAX_CLIENTS; i++)\n    {\n        if (NPServer.Clients [i].Connected)\n\t    S9xNPShutdownClient(i, FALSE);\n    }\n}\n\n#ifdef __WIN32__\nvoid S9xGetTimeOfDay (struct timeval *n)\n{\n    unsigned long t = S9xGetMilliTime ();\n\n    n->tv_sec = t / 1000;\n    n->tv_usec = (t % 1000) * 1000;\n}\n#endif\n\nvoid S9xNPSendROMImageToAllClients ()\n{\n    S9xNPNoClientReady ();\n    S9xNPWaitForEmulationToComplete ();\n\n    int c;\n\n    for (c = NP_ONE_CLIENT; c < NP_MAX_CLIENTS; c++)\n    {\n        if (NPServer.Clients [c].SaidHello)\n            S9xNPSendROMImageToClient (c);\n    }\n\n    if (NPServer.SyncByReset)\n    {\n        S9xNPServerAddTask (NP_SERVER_SEND_SRAM_ALL, 0);\n        S9xNPServerAddTask (NP_SERVER_RESET_ALL, 0);\n    }\n    else\n        S9xNPSyncClient (-1);\n}\n\nbool8 S9xNPSendROMImageToClient (int c)\n{\n#ifdef NP_DEBUG\n    printf (\"SERVER: Sending ROM image to player %d @%ld\\n\", c + 1, S9xGetMilliTime () - START);\n#endif\n    sprintf (NetPlay.ActionMsg, \"Sending ROM image to player %d...\", c + 1);\n    S9xNPSetAction (NetPlay.ActionMsg, TRUE);\n\n    uint8 header [7 + 1 + 4];\n    uint8 *ptr = header;\n    int len = sizeof (header) + Memory.CalculatedSize +\n              Memory.ROMFilename.length() + 1;\n    *ptr++ = NP_SERV_MAGIC;\n    *ptr++ = NPServer.Clients [c].SendSequenceNum++;\n    *ptr++ = NP_SERV_ROM_IMAGE;\n    WRITE_LONG (ptr, len);\n    ptr += 4;\n    *ptr++ = Memory.HiROM;\n    WRITE_LONG (ptr, Memory.CalculatedSize);\n\n    if (!S9xNPSSendData (NPServer.Clients [c].Socket, header, sizeof (header)) ||\n        !S9xNPSSendData (NPServer.Clients [c].Socket, Memory.ROM,\n                        Memory.CalculatedSize) ||\n        !S9xNPSSendData (NPServer.Clients [c].Socket, (uint8 *) Memory.ROMFilename.c_str(),\n                        Memory.ROMFilename.length() + 1))\n    {\n        S9xNPShutdownClient (c, TRUE);\n        return (FALSE);\n    }\n    return (TRUE);\n}\n\nvoid S9xNPSyncClients ()\n{\n    S9xNPNoClientReady ();\n    S9xNPSyncClient (-1);\n}\n\nvoid S9xNPSyncClient (int client)\n{\n#ifdef HAVE_MKSTEMP\n    char fname[] = \"/tmp/snes9x_fztmpXXXXXX\";\n    int fd=-1;\n#else\n    char fname [L_tmpnam];\n#endif\n\n    S9xNPWaitForEmulationToComplete ();\n\n    S9xNPSetAction (\"SERVER: Freezing game...\", TRUE);\n#ifdef HAVE_MKSTEMP\n    if ( ((fd=mkstemp(fname)) >= 0) && S9xFreezeGame(fname) )\n#else\n    if ( tmpnam(fname) && S9xFreezeGame(fname) )\n#endif\n    {\n        uint8 *data;\n        uint32 len;\n\n        S9xNPSetAction (\"SERVER: Loading freeze file...\", TRUE);\n        if (S9xNPLoadFreezeFile (fname, data, len))\n        {\n            int c;\n\n            if (client < 0)\n            {\n                for (c = NP_ONE_CLIENT; c < NP_MAX_CLIENTS; c++)\n                {\n                    if (NPServer.Clients [c].SaidHello)\n                    {\n                        NPServer.Clients [c].Ready = FALSE;\n                        S9xNPRecomputePause ();\n                        S9xNPSendFreezeFile (c, data, len);\n                    }\n                }\n            }\n            else\n            {\n                NPServer.Clients [client].Ready = FALSE;\n                S9xNPRecomputePause ();\n                S9xNPSendFreezeFile (client, data, len);\n            }\n            delete[] data;\n        }\n        remove (fname);\n    }\n#ifdef HAVE_MKSTEMP\n    if (fd != -1)\n        close(fd);\n#endif\n}\n\nbool8 S9xNPLoadFreezeFile (const char *fname, uint8 *&data, uint32 &len)\n{\n    FILE *ff;\n\n    if ((ff = fopen (fname, \"rb\")))\n    {\n        fseek (ff, 0, SEEK_END);\n        len = ftell (ff);\n        fseek (ff, 0, SEEK_SET);\n\n        data = new uint8 [len];\n        bool8 ok = (fread (data, 1, len, ff) == len);\n        fclose (ff);\n\n        return (ok);\n    }\n    return (FALSE);\n}\n\nvoid S9xNPSendFreezeFile (int c, uint8 *data, uint32 len)\n{\n#ifdef NP_DEBUG\n    printf (\"SERVER: Sending freeze file to player %d @%ld\\n\", c + 1, S9xGetMilliTime () - START);\n#endif\n\n    sprintf (NetPlay.ActionMsg, \"SERVER: Sending freeze-file to player %d...\", c + 1);\n    S9xNPSetAction (NetPlay.ActionMsg, TRUE);\n    uint8 header [7 + 4];\n    uint8 *ptr = header;\n\n    *ptr++ = NP_SERV_MAGIC;\n    *ptr++ = NPServer.Clients [c].SendSequenceNum++;\n    *ptr++ = NP_SERV_FREEZE_FILE;\n    WRITE_LONG (ptr, len + 7 + 4);\n    ptr += 4;\n    WRITE_LONG (ptr, NPServer.FrameCount);\n\n    if (!S9xNPSSendData (NPServer.Clients [c].Socket, header, 7 + 4) ||\n        !S9xNPSSendData (NPServer.Clients [c].Socket, data, len))\n    {\n       S9xNPShutdownClient (c, TRUE);\n    }\n    S9xNPSetAction (\"\", TRUE);\n}\n\nvoid S9xNPRecomputePause ()\n{\n    int c;\n\n    for (c = 0; c < NP_MAX_CLIENTS; c++)\n    {\n        if (NPServer.Clients [c].SaidHello &&\n            (!NPServer.Clients [c].Ready || NPServer.Clients [c].Paused))\n        {\n#if defined(NP_DEBUG) && NP_DEBUG == 2\n            printf (\"SERVER: Paused because of client %d (%d,%d) @%ld\\n\", c, NPServer.Clients [c].Ready, NPServer.Clients [c].Paused, S9xGetMilliTime () - START);\n#endif\n            NPServer.Paused = TRUE;\n            return;\n        }\n    }\n#if defined(NP_DEBUG) && NP_DEBUG == 2\n    printf (\"SERVER: not paused @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n    NPServer.Paused = FALSE;\n}\n\nvoid S9xNPNoClientReady (int start_index)\n{\n    int c;\n\n    for (c = start_index; c < NP_MAX_CLIENTS; c++)\n        NPServer.Clients [c].Ready = FALSE;\n    S9xNPRecomputePause ();\n}\n\nvoid S9xNPSendROMLoadRequest (const char *filename)\n{\n    S9xNPNoClientReady ();\n\n    int len = 7 + strlen (filename) + 1;\n    uint8 *data = new uint8 [len];\n    uint8 *ptr = data;\n    *ptr++ = NP_SERV_MAGIC;\n    *ptr++ = 0;\n    *ptr++ = NP_SERV_LOAD_ROM;\n    WRITE_LONG (ptr, len);\n    ptr += 4;\n    strcpy ((char *) ptr, filename);\n\n    for (int i = NP_ONE_CLIENT; i < NP_MAX_CLIENTS; i++)\n    {\n\tif (NPServer.Clients [i].SaidHello)\n\t{\n#ifdef NP_DEBUG\n            printf (\"SERVER: Sending load ROM requesting to player %d @%ld\\n\", i + 1, S9xGetMilliTime () - START);\n#endif\n            sprintf (NetPlay.WarningMsg, \"SERVER: sending ROM load request to player %d...\", i + 1);\n            S9xNPSetAction (NetPlay.WarningMsg, TRUE);\n            data [1] = NPServer.Clients [i].SendSequenceNum++;\n\t    if (!S9xNPSSendData (NPServer.Clients [i].Socket, data, len))\n            {\n\t\tS9xNPShutdownClient (i, TRUE);\n            }\n        }\n    }\n    delete[] data;\n}\n\nvoid S9xNPSendSRAMToAllClients ()\n{\n    int i;\n\n    for (i = NP_ONE_CLIENT; i < NP_MAX_CLIENTS; i++)\n    {\n        if (NPServer.Clients [i].SaidHello)\n            S9xNPSendSRAMToClient (i);\n    }\n}\n\nvoid S9xNPSendSRAMToClient (int c)\n{\n#ifdef NP_DEBUG\n    printf (\"SERVER: Sending S-RAM data to player %d @%ld\\n\", c + 1, S9xGetMilliTime () - START);\n#endif\n    uint8 sram [7];\n    int SRAMSize = Memory.SRAMSize ?\n                   (1 << (Memory.SRAMSize + 3)) * 128 : 0;\n    if (Memory.LoROM)\n        SRAMSize = SRAMSize < 0x70000 ? SRAMSize : 0x70000;\n\telse if (Memory.HiROM)\n\t\tSRAMSize = SRAMSize < 0x40000 ? SRAMSize : 0x40000;\n\n    int len = 7 + SRAMSize;\n\n    sprintf (NetPlay.ActionMsg, \"SERVER: Sending S-RAM to player %d...\", c + 1);\n    S9xNPSetAction (NetPlay.ActionMsg, TRUE);\n\n    uint8 *ptr = sram;\n    *ptr++ = NP_SERV_MAGIC;\n    *ptr++ = NPServer.Clients [c].SendSequenceNum++;\n    *ptr++ = NP_SERV_SRAM_DATA;\n    WRITE_LONG (ptr, len);\n    if (!S9xNPSSendData (NPServer.Clients [c].Socket,\n                        sram, sizeof (sram)) ||\n        (len > 7 &&\n         !S9xNPSSendData (NPServer.Clients [c].Socket,\n                         Memory.SRAM, len - 7)))\n    {\n        S9xNPShutdownClient (c, TRUE);\n    }\n}\n\nvoid S9xNPSendFreezeFileToAllClients (const char *filename)\n{\n    uint8 *data;\n    uint32 len;\n\n    if (NPServer.NumClients > NP_ONE_CLIENT && S9xNPLoadFreezeFile (filename, data, len))\n    {\n        S9xNPNoClientReady ();\n\n        for (int c = NP_ONE_CLIENT; c < NP_MAX_CLIENTS; c++)\n        {\n            if (NPServer.Clients [c].SaidHello)\n                S9xNPSendFreezeFile (c, data, len);\n        }\n        delete[] data;\n    }\n}\n\nvoid S9xNPServerAddTask (uint32 task, void *data)\n{\n    NPServer.TaskQueue [NPServer.TaskTail].Task = task;\n    NPServer.TaskQueue [NPServer.TaskTail].Data = data;\n\n    NPServer.TaskTail = (NPServer.TaskTail + 1) % NP_MAX_TASKS;\n}\n\nvoid S9xNPReset ()\n{\n    S9xNPNoClientReady (0);\n    S9xNPServerAddTask (NP_SERVER_RESET_ALL, 0);\n}\n\nvoid S9xNPWaitForEmulationToComplete ()\n{\n#ifdef NP_DEBUG\n    printf (\"SERVER: WaitForEmulationToComplete start @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n\n    while (!NetPlay.PendingWait4Sync && NetPlay.Connected &&\n           !Settings.ForcedPause && !Settings.StopEmulation &&\n           !(Settings.Paused && !Settings.FrameAdvance))\n    {\n#ifdef __WIN32__\n        Sleep (40);\n#endif\n    }\n#ifdef NP_DEBUG\n    printf (\"SERVER: WaitForEmulationToComplete end @%ld\\n\", S9xGetMilliTime () - START);\n#endif\n}\n\nvoid S9xNPServerQueueSyncAll ()\n{\n    if (Settings.NetPlay && Settings.NetPlayServer &&\n        NPServer.NumClients > NP_ONE_CLIENT)\n    {\n        S9xNPNoClientReady ();\n        S9xNPDiscardHeartbeats ();\n        S9xNPServerAddTask (NP_SERVER_SYNC_ALL, 0);\n    }\n}\n\nvoid S9xNPServerQueueSendingROMImage ()\n{\n    if (Settings.NetPlay && Settings.NetPlayServer &&\n        NPServer.NumClients > NP_ONE_CLIENT)\n    {\n        S9xNPNoClientReady ();\n        S9xNPDiscardHeartbeats ();\n        S9xNPServerAddTask (NP_SERVER_SEND_ROM_IMAGE, 0);\n    }\n}\n\nvoid S9xNPServerQueueSendingFreezeFile (const char *filename)\n{\n    if (Settings.NetPlay && Settings.NetPlayServer &&\n        NPServer.NumClients > NP_ONE_CLIENT)\n    {\n        S9xNPNoClientReady ();\n        S9xNPDiscardHeartbeats ();\n        S9xNPServerAddTask (NP_SERVER_SEND_FREEZE_FILE_ALL,\n                            (void *) strdup (filename));\n    }\n}\n\nvoid S9xNPServerQueueSendingLoadROMRequest (const char *filename)\n{\n    if (Settings.NetPlay && Settings.NetPlayServer &&\n        NPServer.NumClients > NP_ONE_CLIENT)\n    {\n        S9xNPNoClientReady ();\n        S9xNPDiscardHeartbeats ();\n        S9xNPServerAddTask (NP_SERVER_SEND_ROM_LOAD_REQUEST_ALL,\n                            (void *) strdup (filename));\n    }\n}\n\n#ifndef __WIN32__\nuint32 S9xGetMilliTime ()\n{\n    static bool8 first = TRUE;\n    static long start_sec;\n    struct timeval tv;\n\n    gettimeofday (&tv, NULL);\n    if (first)\n    {\n\tstart_sec = tv.tv_sec;\n\tfirst = FALSE;\n    }\n    return ((uint32) ((tv.tv_sec - start_sec) * 1000 + tv.tv_usec / 1000));\n}\n#endif\n#endif\n"
        },
        {
          "name": "seta.cpp",
          "type": "blob",
          "size": 0.6455078125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"seta.h\"\n\nuint8\t(*GetSETA) (uint32)        = &S9xGetST010;\nvoid\t(*SetSETA) (uint32, uint8) = &S9xSetST010;\n\n\nuint8 S9xGetSetaDSP (uint32 Address)\n{\n\treturn (GetSETA(Address));\n}\n\nvoid S9xSetSetaDSP (uint8 Byte, uint32 Address)\n{\n\tSetSETA (Address, Byte);\n}\n"
        },
        {
          "name": "seta.h",
          "type": "blob",
          "size": 1.4033203125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _SETA_H_\n#define _SETA_H_\n\n#define ST_010\t0x01\n#define ST_011\t0x02\n#define ST_018\t0x03\n\nstruct SST010\n{\n\tuint8\tinput_params[16];\n\tuint8\toutput_params[16];\n\tuint8\top_reg;\n\tuint8\texecute;\n\tbool8\tcontrol_enable;\n};\n\nstruct SST011\n{\n\tbool8\twaiting4command;\n\tuint8\tstatus;\n\tuint8\tcommand;\n\tuint32\tin_count;\n\tuint32\tin_index;\n\tuint32\tout_count;\n\tuint32\tout_index;\n\tuint8\tparameters[512];\n\tuint8\toutput[512];\n};\n\nstruct SST018\n{\n\tbool8\twaiting4command;\n\tuint8\tstatus;\n\tuint8\tpart_command;\n\tuint8\tpass;\n\tuint32\tcommand;\n\tuint32\tin_count;\n\tuint32\tin_index;\n\tuint32\tout_count;\n\tuint32\tout_index;\n\tuint8\tparameters[512];\n\tuint8\toutput[512];\n};\n\nextern struct SST010\tST010;\nextern struct SST011\tST011;\nextern struct SST018\tST018;\n\nuint8 S9xGetST010 (uint32);\nvoid S9xSetST010 (uint32, uint8);\nuint8 S9xGetST011 (uint32);\nvoid S9xSetST011 (uint32, uint8);\nuint8 S9xGetST018 (uint32);\nvoid S9xSetST018 (uint8, uint32);\nuint8 S9xGetSetaDSP (uint32);\nvoid S9xSetSetaDSP (uint8, uint32);\n\nextern uint8 (*GetSETA) (uint32);\nextern void (*SetSETA) (uint32, uint8);\n\n#endif\n"
        },
        {
          "name": "seta010.cpp",
          "type": "blob",
          "size": 22.1162109375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include <math.h>\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"seta.h\"\n\nstatic const int16\tST010_SinTable[256] =\n{\n\t 0x0000,  0x0324,  0x0648,  0x096a,  0x0c8c,  0x0fab,  0x12c8,  0x15e2,\n\t 0x18f9,  0x1c0b,  0x1f1a,  0x2223,  0x2528,  0x2826,  0x2b1f,  0x2e11,\n\t 0x30fb,  0x33df,  0x36ba,  0x398c,  0x3c56,  0x3f17,  0x41ce,  0x447a,\n\t 0x471c,  0x49b4,  0x4c3f,  0x4ebf,  0x5133,  0x539b,  0x55f5,  0x5842,\n\t 0x5a82,  0x5cb3,  0x5ed7,  0x60eb,  0x62f1,  0x64e8,  0x66cf,  0x68a6,\n\t 0x6a6d,  0x6c23,  0x6dc9,  0x6f5e,  0x70e2,  0x7254,  0x73b5,  0x7504,\n\t 0x7641,  0x776b,  0x7884,  0x7989,  0x7a7c,  0x7b5c,  0x7c29,  0x7ce3,\n\t 0x7d89,  0x7e1d,  0x7e9c,  0x7f09,  0x7f61,  0x7fa6,  0x7fd8,  0x7ff5,\n\t 0x7fff,  0x7ff5,  0x7fd8,  0x7fa6,  0x7f61,  0x7f09,  0x7e9c,  0x7e1d,\n\t 0x7d89,  0x7ce3,  0x7c29,  0x7b5c,  0x7a7c,  0x7989,  0x7884,  0x776b,\n\t 0x7641,  0x7504,  0x73b5,  0x7254,  0x70e2,  0x6f5e,  0x6dc9,  0x6c23,\n\t 0x6a6d,  0x68a6,  0x66cf,  0x64e8,  0x62f1,  0x60eb,  0x5ed7,  0x5cb3,\n\t 0x5a82,  0x5842,  0x55f5,  0x539b,  0x5133,  0x4ebf,  0x4c3f,  0x49b4,\n\t 0x471c,  0x447a,  0x41ce,  0x3f17,  0x3c56,  0x398c,  0x36ba,  0x33df,\n\t 0x30fb,  0x2e11,  0x2b1f,  0x2826,  0x2528,  0x2223,  0x1f1a,  0x1c0b,\n\t 0x18f8,  0x15e2,  0x12c8,  0x0fab,  0x0c8c,  0x096a,  0x0648,  0x0324,\n\t 0x0000, -0x0324, -0x0648, -0x096b, -0x0c8c, -0x0fab, -0x12c8, -0x15e2,\n\t-0x18f9, -0x1c0b, -0x1f1a, -0x2223, -0x2528, -0x2826, -0x2b1f, -0x2e11,\n\t-0x30fb, -0x33df, -0x36ba, -0x398d, -0x3c56, -0x3f17, -0x41ce, -0x447a,\n\t-0x471c, -0x49b4, -0x4c3f, -0x4ebf, -0x5133, -0x539b, -0x55f5, -0x5842,\n\t-0x5a82, -0x5cb3, -0x5ed7, -0x60ec, -0x62f1, -0x64e8, -0x66cf, -0x68a6,\n\t-0x6a6d, -0x6c23, -0x6dc9, -0x6f5e, -0x70e2, -0x7254, -0x73b5, -0x7504,\n\t-0x7641, -0x776b, -0x7884, -0x7989, -0x7a7c, -0x7b5c, -0x7c29, -0x7ce3,\n\t-0x7d89, -0x7e1d, -0x7e9c, -0x7f09, -0x7f61, -0x7fa6, -0x7fd8, -0x7ff5,\n\t-0x7fff, -0x7ff5, -0x7fd8, -0x7fa6, -0x7f61, -0x7f09, -0x7e9c, -0x7e1d,\n\t-0x7d89, -0x7ce3, -0x7c29, -0x7b5c, -0x7a7c, -0x7989, -0x7883, -0x776b,\n\t-0x7641, -0x7504, -0x73b5, -0x7254, -0x70e2, -0x6f5e, -0x6dc9, -0x6c23,\n\t-0x6a6d, -0x68a6, -0x66cf, -0x64e8, -0x62f1, -0x60eb, -0x5ed7, -0x5cb3,\n\t-0x5a82, -0x5842, -0x55f5, -0x539a, -0x5133, -0x4ebf, -0x4c3f, -0x49b3,\n\t-0x471c, -0x447a, -0x41cd, -0x3f17, -0x3c56, -0x398c, -0x36b9, -0x33de,\n\t-0x30fb, -0x2e10, -0x2b1f, -0x2826, -0x2527, -0x2223, -0x1f19, -0x1c0b,\n\t-0x18f8, -0x15e2, -0x12c8, -0x0fab, -0x0c8b, -0x096a, -0x0647, -0x0324\n};\n\nstatic const uint8 ST010_ArcTan[32][32] =\n{\n\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n\t{ 0x40, 0x20, 0x13, 0x0D, 0x0A, 0x08, 0x07, 0x06, 0x05, 0x05, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03,\n\t  0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01 },\n\t{ 0x40, 0x2D, 0x20, 0x18, 0x13, 0x10, 0x0D, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x07, 0x06, 0x06, 0x05,\n\t  0x05, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 },\n\t{ 0x40, 0x33, 0x28, 0x20, 0x1A, 0x16, 0x13, 0x10, 0x0F, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x09, 0x08,\n\t  0x08, 0x07, 0x07, 0x06, 0x06, 0x06, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04 },\n\t{ 0x40, 0x36, 0x2D, 0x26, 0x20, 0x1B, 0x18, 0x15, 0x13, 0x11, 0x10, 0x0E, 0x0D, 0x0C, 0x0B, 0x0B,\n\t  0x0A, 0x09, 0x09, 0x08, 0x08, 0x08, 0x07, 0x07, 0x07, 0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x05 },\n\t{ 0x40, 0x38, 0x30, 0x2A, 0x25, 0x20, 0x1C, 0x19, 0x17, 0x15, 0x13, 0x11, 0x10, 0x0F, 0x0E, 0x0D,\n\t  0x0C, 0x0C, 0x0B, 0x0A, 0x0A, 0x0A, 0x09, 0x09, 0x08, 0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x07 },\n\t{ 0x40, 0x39, 0x33, 0x2D, 0x28, 0x24, 0x20, 0x1D, 0x1A, 0x18, 0x16, 0x14, 0x13, 0x12, 0x10, 0x10,\n\t  0x0F, 0x0E, 0x0D, 0x0C, 0x0C, 0x0B, 0x0B, 0x0A, 0x0A, 0x0A, 0x09, 0x09, 0x09, 0x08, 0x08, 0x08 },\n\t{ 0x40, 0x3A, 0x35, 0x30, 0x2B, 0x27, 0x23, 0x20, 0x1D, 0x1B, 0x19, 0x17, 0x16, 0x14, 0x13, 0x12,\n\t  0x11, 0x10, 0x0F, 0x0E, 0x0E, 0x0D, 0x0D, 0x0C, 0x0C, 0x0B, 0x0B, 0x0A, 0x0A, 0x0A, 0x09, 0x09 },\n\t{ 0x40, 0x3B, 0x36, 0x31, 0x2D, 0x29, 0x26, 0x23, 0x20, 0x1E, 0x1B, 0x1A, 0x18, 0x16, 0x15, 0x14,\n\t  0x13, 0x12, 0x11, 0x10, 0x10, 0x0F, 0x0E, 0x0E, 0x0D, 0x0D, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0A },\n\t{ 0x40, 0x3B, 0x37, 0x33, 0x2F, 0x2B, 0x28, 0x25, 0x22, 0x20, 0x1E, 0x1C, 0x1A, 0x19, 0x17, 0x16,\n\t  0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x10, 0x0F, 0x0F, 0x0E, 0x0E, 0x0D, 0x0D, 0x0C, 0x0C, 0x0C },\n\t{ 0x40, 0x3C, 0x38, 0x34, 0x30, 0x2D, 0x2A, 0x27, 0x25, 0x20, 0x20, 0x1E, 0x1C, 0x1B, 0x19, 0x18,\n\t  0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x11, 0x10, 0x10, 0x0F, 0x0E, 0x0E, 0x0E, 0x0D, 0x0D },\n\t{ 0x40, 0x3C, 0x39, 0x35, 0x32, 0x2F, 0x2C, 0x29, 0x26, 0x24, 0x22, 0x20, 0x1E, 0x1D, 0x1B, 0x1A,\n\t  0x19, 0x17, 0x16, 0x15, 0x14, 0x14, 0x13, 0x12, 0x12, 0x11, 0x10, 0x10, 0x0F, 0x0F, 0x0E, 0x0E },\n\t{ 0x40, 0x3D, 0x39, 0x36, 0x33, 0x30, 0x2D, 0x2A, 0x28, 0x26, 0x24, 0x22, 0x20, 0x1E, 0x1D, 0x1B,\n\t  0x1A, 0x19, 0x18, 0x17, 0x16, 0x15, 0x14, 0x14, 0x13, 0x12, 0x12, 0x11, 0x10, 0x10, 0x10, 0x0F },\n\t{ 0x40, 0x3D, 0x3A, 0x37, 0x34, 0x31, 0x2E, 0x2C, 0x2A, 0x27, 0x25, 0x23, 0x22, 0x20, 0x1E, 0x1D,\n\t  0x1C, 0x1B, 0x19, 0x18, 0x17, 0x17, 0x16, 0x15, 0x14, 0x14, 0x13, 0x12, 0x12, 0x11, 0x11, 0x10 },\n\t{ 0x40, 0x3D, 0x3A, 0x37, 0x35, 0x32, 0x30, 0x2D, 0x2B, 0x29, 0x27, 0x25, 0x23, 0x22, 0x20, 0x1F,\n\t  0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18, 0x17, 0x16, 0x16, 0x15, 0x14, 0x13, 0x13, 0x12, 0x12, 0x11 },\n\t{ 0x40, 0x3D, 0x3B, 0x38, 0x35, 0x33, 0x30, 0x2E, 0x2C, 0x2A, 0x28, 0x26, 0x25, 0x23, 0x21, 0x20,\n\t  0x1F, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18, 0x18, 0x17, 0x16, 0x15, 0x15, 0x14, 0x13, 0x13, 0x12 },\n\t{ 0x40, 0x3D, 0x3B, 0x38, 0x36, 0x34, 0x31, 0x2F, 0x2D, 0x2B, 0x29, 0x27, 0x26, 0x24, 0x23, 0x21,\n\t  0x20, 0x1F, 0x1E, 0x1D, 0x1B, 0x1B, 0x1A, 0x19, 0x18, 0x17, 0x16, 0x16, 0x15, 0x15, 0x14, 0x13 },\n\t{ 0x40, 0x3E, 0x3B, 0x39, 0x37, 0x34, 0x32, 0x30, 0x2E, 0x2C, 0x2A, 0x29, 0x27, 0x25, 0x24, 0x23,\n\t  0x21, 0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18, 0x18, 0x17, 0x16, 0x16, 0x15, 0x14 },\n\t{ 0x40, 0x3E, 0x3B, 0x39, 0x37, 0x35, 0x33, 0x31, 0x2F, 0x2D, 0x2B, 0x2A, 0x28, 0x27, 0x25, 0x24,\n\t  0x22, 0x21, 0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x19, 0x18, 0x17, 0x17, 0x16, 0x15 },\n\t{ 0x40, 0x3E, 0x3C, 0x3A, 0x38, 0x36, 0x34, 0x32, 0x30, 0x2E, 0x2C, 0x2B, 0x29, 0x28, 0x26, 0x25,\n\t  0x23, 0x22, 0x21, 0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x1A, 0x19, 0x18, 0x18, 0x17, 0x16 },\n\t{ 0x40, 0x3E, 0x3C, 0x3A, 0x38, 0x36, 0x34, 0x32, 0x30, 0x2F, 0x2D, 0x2C, 0x2A, 0x29, 0x27, 0x26,\n\t  0x25, 0x23, 0x22, 0x21, 0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1B, 0x1A, 0x19, 0x19, 0x18, 0x17 },\n\t{ 0x40, 0x3E, 0x3C, 0x3A, 0x38, 0x36, 0x35, 0x33, 0x31, 0x30, 0x2E, 0x2C, 0x2B, 0x29, 0x28, 0x27,\n\t  0x25, 0x24, 0x23, 0x22, 0x21, 0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0x1C, 0x1B, 0x1A, 0x1A, 0x19, 0x18 },\n\t{ 0x40, 0x3E, 0x3C, 0x3A, 0x39, 0x37, 0x35, 0x33, 0x32, 0x30, 0x2F, 0x2D, 0x2C, 0x2A, 0x29, 0x28,\n\t  0x26, 0x25, 0x24, 0x23, 0x22, 0x21, 0x20, 0x1F, 0x1E, 0x1D, 0x1D, 0x1C, 0x1B, 0x1A, 0x1A, 0x19 },\n\t{ 0x40, 0x3E, 0x3C, 0x3B, 0x39, 0x37, 0x36, 0x34, 0x32, 0x31, 0x2F, 0x2E, 0x2C, 0x2B, 0x2A, 0x28,\n\t  0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21, 0x20, 0x1F, 0x1E, 0x1E, 0x1D, 0x1C, 0x1B, 0x1B, 0x1A },\n\t{ 0x40, 0x3E, 0x3D, 0x3B, 0x39, 0x38, 0x36, 0x34, 0x33, 0x31, 0x30, 0x2E, 0x2D, 0x2C, 0x2A, 0x29,\n\t  0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21, 0x20, 0x1F, 0x1E, 0x1E, 0x1D, 0x1C, 0x1B, 0x1B },\n\t{ 0x40, 0x3E, 0x3D, 0x3B, 0x3A, 0x38, 0x36, 0x35, 0x33, 0x32, 0x30, 0x2F, 0x2E, 0x2C, 0x2B, 0x2A,\n\t  0x29, 0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21, 0x20, 0x1F, 0x1E, 0x1E, 0x1D, 0x1C, 0x1C },\n\t{ 0x40, 0x3E, 0x3D, 0x3B, 0x3A, 0x38, 0x37, 0x35, 0x34, 0x32, 0x31, 0x30, 0x2E, 0x2D, 0x2C, 0x2B,\n\t  0x2A, 0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x22, 0x21, 0x20, 0x1F, 0x1E, 0x1E, 0x1D, 0x1C },\n\t{ 0x40, 0x3E, 0x3D, 0x3B, 0x3A, 0x39, 0x37, 0x36, 0x34, 0x33, 0x32, 0x30, 0x2F, 0x2E, 0x2D, 0x2B,\n\t  0x2A, 0x29, 0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x22, 0x21, 0x20, 0x1F, 0x1F, 0x1E, 0x1D },\n\t{ 0x40, 0x3F, 0x3D, 0x3C, 0x3A, 0x39, 0x37, 0x36, 0x35, 0x33, 0x32, 0x31, 0x30, 0x2E, 0x2D, 0x2C,\n\t  0x2B, 0x2A, 0x29, 0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x22, 0x21, 0x20, 0x1F, 0x1F, 0x1E },\n\t{ 0x40, 0x3F, 0x3D, 0x3C, 0x3A, 0x39, 0x38, 0x36, 0x35, 0x34, 0x32, 0x31, 0x30, 0x2F, 0x2E, 0x2D,\n\t  0x2B, 0x2A, 0x29, 0x28, 0x27, 0x26, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21, 0x21, 0x20, 0x1F, 0x1F },\n\t{ 0x40, 0x3F, 0x3D, 0x3C, 0x3B, 0x39, 0x38, 0x37, 0x35, 0x34, 0x33, 0x32, 0x30, 0x2F, 0x2E, 0x2D,\n\t  0x2C, 0x2B, 0x2A, 0x29, 0x28, 0x27, 0x26, 0x25, 0x25, 0x24, 0x23, 0x22, 0x21, 0x21, 0x20, 0x1F },\n\t{ 0x40, 0x3F, 0x3D, 0x3C, 0x3B, 0x39, 0x38, 0x37, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30, 0x2F, 0x2E,\n\t  0x2D, 0x2C, 0x2B, 0x2A, 0x29, 0x28, 0x27, 0x26, 0x25, 0x24, 0x24, 0x23, 0x22, 0x21, 0x21, 0x20 }\n};\n\n// Mode 7 scaling constants for all raster lines\nstatic const int16\tST010_M7Scale[176] =\n{\n\t0x0380, 0x0325, 0x02da, 0x029c, 0x0268, 0x023b, 0x0215, 0x01f3,\n\t0x01d5, 0x01bb, 0x01a3, 0x018e, 0x017b, 0x016a, 0x015a, 0x014b,\n\t0x013e, 0x0132, 0x0126, 0x011c, 0x0112, 0x0109, 0x0100, 0x00f8,\n\t0x00f0, 0x00e9, 0x00e3, 0x00dc, 0x00d6, 0x00d1, 0x00cb, 0x00c6,\n\t0x00c1, 0x00bd, 0x00b8, 0x00b4, 0x00b0, 0x00ac, 0x00a8, 0x00a5,\n\t0x00a2, 0x009e, 0x009b, 0x0098, 0x0095, 0x0093, 0x0090, 0x008d,\n\t0x008b, 0x0088, 0x0086, 0x0084, 0x0082, 0x0080, 0x007e, 0x007c,\n\t0x007a, 0x0078, 0x0076, 0x0074, 0x0073, 0x0071, 0x006f, 0x006e,\n\t0x006c, 0x006b, 0x0069, 0x0068, 0x0067, 0x0065, 0x0064, 0x0063,\n\t0x0062, 0x0060, 0x005f, 0x005e, 0x005d, 0x005c, 0x005b, 0x005a,\n\t0x0059, 0x0058, 0x0057, 0x0056, 0x0055, 0x0054, 0x0053, 0x0052,\n\t0x0051, 0x0051, 0x0050, 0x004f, 0x004e, 0x004d, 0x004d, 0x004c,\n\t0x004b, 0x004b, 0x004a, 0x0049, 0x0048, 0x0048, 0x0047, 0x0047,\n\t0x0046, 0x0045, 0x0045, 0x0044, 0x0044, 0x0043, 0x0042, 0x0042,\n\t0x0041, 0x0041, 0x0040, 0x0040, 0x003f, 0x003f, 0x003e, 0x003e,\n\t0x003d, 0x003d, 0x003c, 0x003c, 0x003b, 0x003b, 0x003a, 0x003a,\n\t0x003a, 0x0039, 0x0039, 0x0038, 0x0038, 0x0038, 0x0037, 0x0037,\n\t0x0036, 0x0036, 0x0036, 0x0035, 0x0035, 0x0035, 0x0034, 0x0034,\n\t0x0034, 0x0033, 0x0033, 0x0033, 0x0032, 0x0032, 0x0032, 0x0031,\n\t0x0031, 0x0031, 0x0030, 0x0030, 0x0030, 0x0030, 0x002f, 0x002f,\n\t0x002f, 0x002e, 0x002e, 0x002e, 0x002e, 0x002d, 0x002d, 0x002d,\n\t0x002d, 0x002c, 0x002c, 0x002c, 0x002c, 0x002b, 0x002b, 0x002b\n};\n\n#ifndef PI\n#define PI\t3.1415926535897932384626433832795\n#endif\n\n#define ST010_WORD(offset)\t(Memory.SRAM[offset + 1] << 8) | Memory.SRAM[offset]\n#define ST010_DWORD(offset)\t(Memory.SRAM[offset + 3] << 24) | (Memory.SRAM[offset + 2] << 16) | (Memory.SRAM[offset + 1] << 8) | Memory.SRAM[offset]\n\n\nstatic int16 ST010_Sin (int16 Theta)\n{\n\treturn (ST010_SinTable[(Theta >> 8) & 0xff]);\n}\n\nstatic int16 ST010_Cos (int16 Theta)\n{\n\treturn (ST010_SinTable[((Theta + 0x4000) >> 8) & 0xff]);\n}\n\nvoid ST010_Compass(int16 x0, int16 y0, int16 &x1, int16 &y1, int16 &Quadrant, int16 &Theta)\n{\t\n \tif ((x0 <= 0) && (y0 < 0))\n\t{\t\n\t\tx1 = -x0;\n\t\ty1 = -y0;\n\t\tQuadrant = -0x8000;\n\t}\n\telse if (x0 < 0)\n\t{\n\t\tx1 = y0;\n\t\ty1 = -x0;\n\t\tQuadrant = -0x4000;\n\t}\n\telse if (y0 < 0)\n\t{\n\t\tx1 = -y0;\n\t\ty1 = x0;\n\t\tQuadrant = 0x4000;\n\t}\n\telse\n\t{\n\t\tx1 = x0;\n\t\ty1 = y0;\n\t\tQuadrant = 0x0000;\n\t}\n\n \twhile ((x1 > 0x1f) || (y1 > 0x1f))\n\t{\n\t\tif (x1 > 1) x1 >>= 1;\n\t\tif (y1 > 1) y1 >>= 1;\n\t}\n\n\tTheta = ST010_ArcTan[x1 & 0x1f][y1 & 0x1f] << 8;\n\tTheta = (Theta | Quadrant) ^ 0x8000;\n\n\tif ((x0 == 0) && (y0 < 0)) Quadrant = 0x4000;\n}\n\nstatic void ST010_Scale (int16 Multiplier, int16 X0, int16 Y0, int32 &X1, int32 &Y1)\n{\n\tX1 = X0 * Multiplier << 1;\n\tY1 = Y0 * Multiplier << 1;\n}\n\nstatic void ST010_Multiply (int16 Multiplicand, int16 Multiplier, int32 &Product)\n{\n\tProduct = Multiplicand * Multiplier << 1;\n}\n\nstatic void ST010_Rotate (int16 Theta, int16 X0, int16 Y0, int16 &X1, int16 &Y1)\n{\n\tX1 = (Y0 * ST010_Sin(Theta) >> 15) + (X0 * ST010_Cos(Theta) >> 15);\n\tY1 = (Y0 * ST010_Cos(Theta) >> 15) - (X0 * ST010_Sin(Theta) >> 15);\n}\n\nstatic void ST010_SortDrivers (uint16 Positions, uint16 Places[32], uint16 Drivers[32])\n{\n\tbool\tSorted;\n\tuint16\tTemp;\n\n\tif (Positions > 1)\n\t{\n\t\tdo\n\t\t{\n\t\t\tSorted = true;\n\n\t\t\tfor (int i = 0; i < Positions - 1; i++)\n\t\t\t{\n\t\t\t\tif (Places[i] < Places[i + 1])\n\t\t\t\t{\n\t\t\t\t\tTemp = Places[i + 1];\n\t\t\t\t\tPlaces[i + 1] = Places[i];\n\t\t\t\t\tPlaces[i] = Temp;\n\n\t\t\t\t\tTemp = Drivers[i + 1];\n\t\t\t\t\tDrivers[i + 1] = Drivers[i];\n\t\t\t\t\tDrivers[i] = Temp;\n\n\t\t\t\t\tSorted = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPositions--;\n\t\t}\n\t\twhile (!Sorted);\n\t}\n}\n\nstatic void ST010_Raster(int16 Theta)\n{\n\tint16 data;\n\tint offset = 0;\n\n\tfor (int i = 0; i < 176; i++)\n\t{\n\t\tdata = ST010_M7Scale[i] * ST010_Cos(Theta) >> 15;\n\n\t\tMemory.SRAM[0x00f0 + offset] = data; \n\t\tMemory.SRAM[0x00f1 + offset] = data >> 8;\n\n\t\tMemory.SRAM[0x0510 + offset] = data; \n\t\tMemory.SRAM[0x0511 + offset] = data >> 8; \n\t\t\n\t\tdata = ST010_M7Scale[i] * ST010_Sin(Theta) >> 15;  \n\t\t\n\t\tMemory.SRAM[0x0250 + offset] = data;\t\t\n\t\tMemory.SRAM[0x0251 + offset] = data >> 8;\n\t\t\n\t\tif (data) data = ~data;\n\t\t\t\t \n\t\tMemory.SRAM[0x03b0 + offset] = data;\t\t\n\t\tMemory.SRAM[0x03b1 + offset] = data >> 8;\n\t\t\n\t\toffset += 2;\n\t}\n}\n\nstatic void ST010_Distance(int16 x0, int16 y0, int16 &Distance)\n{\n\tint32 Product;\n\t\n\tx0 = (x0 < 0) ? -x0 : x0;\n\ty0 = (y0 < 0) ? -y0 : y0;\n\n\tif((uint16) x0 >= ((uint16) y0))\n\t\tProduct = ((x0 * 0x3d78 << 1) + (y0 * 0x1976 << 1)) << 1;\n\telse\n\t\tProduct = ((y0 * 0x3d78 << 1) + (x0 * 0x1976 << 1)) << 1;\n\n\tDistance = (Product + 0x8000) >> 16;\n}\n\nstatic void ST010_Navigation(int16 &MaxX, int16 &MaxY, int32 &x0, int32 &y0, int16 &Theta0, int16 &Theta1, int16 &x1, int16 &y1, uint16 &Radius, uint16 Increment, uint16 MaxRadius, int16 &Compass, int16 &Flags, int16 NewMaxX, int16 NewMaxY)\n{\n\tint16\tdummy1,dummy2,dummy3;\n\tuint16 utemp16;\n\tint32 temp32;\n\n\n\tx1 = MaxX - (x0 >> 16);\n\ty1 = MaxY - (y0 >> 16);\n\n\tST010_Compass(x1, y1, dummy1, dummy2, dummy3, Theta1);\n\tTheta1 -= Theta0;\n\n\tif (Theta1 & 0xff00)\n\t\tTheta0 += (Theta1 & 0x8000) ? 0xfd80 : 0x0280;\n\n\t// compiler notice: -0x8000 ==> +0x8000\n\tutemp16 = ((Theta1 < 0) ? (int16) -Theta1 : Theta1) >> 4;\n\n\tif (utemp16 < 0x0100)\n\t{\n\t\ttemp32 = Radius + Increment;\n\t\tRadius = (temp32 >= MaxRadius) ? MaxRadius : (uint16) temp32;\n\t}\n\n\telse\n\t{\n\t\ttemp32 = Radius - utemp16;\n\t\tRadius = (temp32 <= 0) ? 0 : (uint16) temp32;\n\t}\n\n\tx0 -= ((ST010_Sin(Theta0) >> 5) * (Radius >> 8)) << 1;\n\ty0 -= ((ST010_Cos(Theta0) >> 5) * (Radius >> 8)) << 1;\n\n\tx0 &= 0x1fffffff;\n\ty0 &= 0x1fffffff;\n\n\n\tint16 MaxRadiusX, MaxRadiusY;\n\tif (Compass & 0x8000)\n\t{\n\t\tMaxRadiusX = 0x0008;\n\t\tMaxRadiusY = 0x0080;\n\t}\n\telse\n\t{\n\t\tMaxRadiusX = 0x0080;\n\t\tMaxRadiusY = 0x0008;\n\t}\n\n\tif ((abs(x1) < MaxRadiusX) && (abs(y1) < MaxRadiusY))\n\t{\n\t\tMaxX = NewMaxX;\n\t\tMaxY = NewMaxY & 0x0fff;\n\t\tCompass = (NewMaxY & 0x8000) ? 0xffff : 0x0000;\n\t\tFlags |= 0x0008;\n\t}\n}\n\nuint8 S9xGetST010 (uint32 Address)\n{\n\tif (!(Address & 0x80000))\n\t\treturn (0x80);\n\n\tif ((Address & 0xFFF) == 0x20)\n\t\treturn (ST010.op_reg);\n\n\tif ((Address & 0xFFF) == 0x21)\n\t\treturn (ST010.execute);\n\n\treturn (Memory.SRAM[Address & Memory.SRAMMask]);\n}\n\nvoid S9xSetST010 (uint32 Address, uint8 Byte)\n{\n\tif (!(Address & 0x80000))\n\t{\n\t\tST010.control_enable = TRUE;\n\t\treturn;\n\t}\n\n#ifdef DEBUGGER\n\tprintf(\"Write %06X:%02X\\n\", Address, Byte);\n#endif\n\n\tif ((Address & 0xFFF) == 0x20 && ST010.control_enable)\n\t\tST010.op_reg = Byte;\n\n\tif ((Address & 0xFFF) == 0x21 && ST010.control_enable)\n\t\tST010.execute = Byte;\n\telse\n\t\tMemory.SRAM[Address & Memory.SRAMMask] = Byte;\n\n\tif (ST010.execute & 0x80)\n\t{\n\t\tswitch (ST010.op_reg)\n\t\t{\n\t\t\t// Heading\n\t\t\tcase 0x01:\n\t\t\t{\n\t\t\t\tMemory.SRAM[0x0006] = Memory.SRAM[0x0002];\n\t\t\t\tMemory.SRAM[0x0007] = Memory.SRAM[0x0003];\n\n\t\t\t#ifdef FAST_LSB_WORD_ACCESS\n\t\t\t\tST010_Compass(*(int16 *) &Memory.SRAM[0x0000], *(int16 *) &Memory.SRAM[0x0002], (int16 &) Memory.SRAM[0x0000], (int16 &) Memory.SRAM[0x0002], (int16 &) Memory.SRAM[0x0004], (int16 &) Memory.SRAM[0x0010]);\n\t\t\t#else\n\t\t\t\tint16\tx1, y1, Quadrant, Theta;\n\n\t\t\t\tST010_Compass(ST010_WORD(0x0000), ST010_WORD(0x0002), x1, y1, Quadrant, Theta);\n\n\t\t\t\tMemory.SRAM[0x0000] = (uint8) (x1);\n\t\t\t\tMemory.SRAM[0x0001] = (uint8) (x1 >> 8);\n\t\t\t\tMemory.SRAM[0x0002] = (uint8) (y1);\n\t\t\t\tMemory.SRAM[0x0003] = (uint8) (y1 >> 8);\n\t\t\t\tMemory.SRAM[0x0004] = (uint8) (Quadrant);\n\t\t\t\tMemory.SRAM[0x0005] = (uint8) (Quadrant >> 8);\n\t\t\t\tMemory.SRAM[0x0010] = (uint8) (Theta);\n\t\t\t\tMemory.SRAM[0x0011] = (uint8) (Theta >> 8);\n\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Sorts Driver Placements\n\t\t\tcase 0x02:\n\t\t\t{\n\t\t\t#ifdef FAST_LSB_WORD_ACCESS\n\t\t\t\tST010_SortDrivers(*(uint16 *) (Memory.SRAM + 0x0024), (uint16 *) (Memory.SRAM + 0x0040), (uint16 *) (Memory.SRAM + 0x0080));\n\t\t\t#else\n\t\t\t\tuint16\tPlaces[32];\n\t\t\t\tuint16\tPositions = ST010_WORD(0x0024);\n\t\t\t\tint\t\tPos, Offset;\n\n\t\t\t\tOffset = 0;\n\n\t\t\t\tfor (Pos = 0; Pos < Positions; Pos++)\n\t\t\t\t{\n\t\t\t\t\tPlaces[Pos] = ST010_WORD(0x0040 + Offset);\n\t\t\t\t\tOffset += 2;\n\t\t\t\t}\n\n\t\t\t\tST010_SortDrivers(Positions, Places, (uint16 *) (Memory.SRAM + 0x0080));\n\n\t\t\t\tOffset = 0;\n\n\t\t\t\tfor (Pos = 0; Pos < Positions; Pos++)\n\t\t\t\t{\n\t\t\t\t\tMemory.SRAM[0x0040 + Offset] = (uint8) (Places[Pos]);\n\t\t\t\t\tMemory.SRAM[0x0041 + Offset] = (uint8) (Places[Pos] >> 8);\n\t\t\t\t\tOffset += 2;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Two Dimensional Coordinate Scale\n\t\t\tcase 0x03:\n\t\t\t{\n\t\t\t#ifdef FAST_LSB_WORD_ACCESS\n\t\t\t\tST010_Scale(*(int16 *) &Memory.SRAM[0x0004], *(int16 *) &Memory.SRAM[0x0000], *(int16 *) &Memory.SRAM[0x0002], (int32 &) Memory.SRAM[0x0010], (int32 &) Memory.SRAM[0x0014]);\n\t\t\t#else\n\t\t\t\tint32\tx1, y1;\n\n\t\t\t\tST010_Scale(ST010_WORD(0x0004), ST010_WORD(0x0000), ST010_WORD(0x0002), x1, y1);\n\n\t\t\t\tMemory.SRAM[0x0010] = (uint8) (x1);\n\t\t\t\tMemory.SRAM[0x0011] = (uint8) (x1 >> 8);\n\t\t\t\tMemory.SRAM[0x0012] = (uint8) (x1 >> 16);\n\t\t\t\tMemory.SRAM[0x0013] = (uint8) (x1 >> 24);\n\t\t\t\tMemory.SRAM[0x0014] = (uint8) (y1);\n\t\t\t\tMemory.SRAM[0x0015] = (uint8) (y1 >> 8);\n\t\t\t\tMemory.SRAM[0x0016] = (uint8) (y1 >> 16);\n\t\t\t\tMemory.SRAM[0x0017] = (uint8) (y1 >> 24);\n\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// calculate the vector length of (x, y)\n\t\t\tcase 0x04:\n\t\t\t{\n\t\t\t#ifdef FAST_LSB_WORD_ACCESS\n\t\t\t\tST010_Distance(*(int16 *) &Memory.SRAM[0x0000], *(int16 *) &Memory.SRAM[0x0002], (int16 &) Memory.SRAM[0x0010]);\n\t\t\t#else\n\t\t\t\tint16\tsquare;\n\n\t\t\t\tST010_Distance(ST010_WORD(0x0000), ST010_WORD(0x0002), square);\n\n\t\t\t\tMemory.SRAM[0x10] = (uint8) (square);\n\t\t\t\tMemory.SRAM[0x11] = (uint8) (square >> 8);\n\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// calculate AI orientation based on specific guidelines\n\t\t\tcase 0x05:\n\t\t\t{\n\t\t\t#ifdef FAST_LSB_WORD_ACCESS\n\t\t\t\tST010_Navigation((int16 &) Memory.SRAM[0x00c0], (int16 &) Memory.SRAM[0x00c2], (int32 &) Memory.SRAM[0x00c4], (int32 &) Memory.SRAM[0x00c8], (int16 &) Memory.SRAM[0x00cc], (int16 &) Memory.SRAM[0x00ce], (int16 &) Memory.SRAM[0x00d0], (int16 &) Memory.SRAM[0x00d2], (uint16 &) Memory.SRAM[0x00d4], *(uint16 *) &Memory.SRAM[0x00d6], *(uint16 *) &Memory.SRAM[0x00d8], (int16 &) Memory.SRAM[0x00da], (int16 &) Memory.SRAM[0x00dc], *(int16 *) &Memory.SRAM[0x00de], *(int16 *) &Memory.SRAM[0x00e0]);\n\t\t\t#else\n\t\t\t\tint32 x0,y0;\n\t\t\t\tint16 MaxX,MaxY,Theta0,Theta1,x1,y1,Compass,Flags;\n\t\t\t\tuint16 Radius;\n\n\t\t\t\tMaxX = ST010_WORD(0x00c0);\n\t\t\t\tMaxY = ST010_WORD(0x00c2);\n\t\t\t\tx0 = ST010_DWORD(0x00c4);\n\t\t\t\ty0 = ST010_DWORD(0x00c8);\n\t\t\t\tTheta0 = ST010_WORD(0x00cc);\n\t\t\t\tRadius = ST010_WORD(0x00d4);\n\t\t\t\tCompass = ST010_WORD(0x00da);\n\t\t\t\tFlags = ST010_WORD(0x00dc);\n\n\t\t\t\tST010_Navigation(MaxX, MaxY, x0, y0, Theta0, Theta1, x1, y1, Radius, ST010_WORD(0x00d6), ST010_WORD(0x00d8), Compass, Flags, ST010_WORD(0x00de), ST010_WORD(0x00e0));\n\n\t\t\t\tMemory.SRAM[0x00c0] = (uint8) (MaxX);\n\t\t\t\tMemory.SRAM[0x00c1] = (uint8) (MaxX >> 8);\n\t\t\t\tMemory.SRAM[0x00c2] = (uint8) (MaxY);\n\t\t\t\tMemory.SRAM[0x00c3] = (uint8) (MaxY >> 8);\n\t\t\t\tMemory.SRAM[0x00c4] = (uint8) (x0);\n\t\t\t\tMemory.SRAM[0x00c5] = (uint8) (x0 >> 8);\n\t\t\t\tMemory.SRAM[0x00c6] = (uint8) (x0 >> 16);\n\t\t\t\tMemory.SRAM[0x00c7] = (uint8) (x0 >> 24);\n\t\t\t\tMemory.SRAM[0x00c8] = (uint8) (y0);\n\t\t\t\tMemory.SRAM[0x00c9] = (uint8) (y0 >> 8);\n\t\t\t\tMemory.SRAM[0x00ca] = (uint8) (y0 >> 16);\n\t\t\t\tMemory.SRAM[0x00cb] = (uint8) (y0 >> 24);\n\t\t\t\tMemory.SRAM[0x00cc] = (uint8) (Theta0);\n\t\t\t\tMemory.SRAM[0x00cd] = (uint8) (Theta0 >> 8);\n\t\t\t\tMemory.SRAM[0x00ce] = (uint8) (Theta1);\n\t\t\t\tMemory.SRAM[0x00cf] = (uint8) (Theta1 >> 8);\n\t\t\t\tMemory.SRAM[0x00d0] = (uint8) (x1);\n\t\t\t\tMemory.SRAM[0x00d1] = (uint8) (x1 >> 8);\n\t\t\t\tMemory.SRAM[0x00d2] = (uint8) (y1);\n\t\t\t\tMemory.SRAM[0x00d3] = (uint8) (y1 >> 8);\n\t\t\t\tMemory.SRAM[0x00d4] = (uint8) (Radius);\n\t\t\t\tMemory.SRAM[0x00d5] = (uint8) (Radius >> 8);\n\t\t\t\tMemory.SRAM[0x00da] = (uint8) (Compass);\n\t\t\t\tMemory.SRAM[0x00db] = (uint8) (Compass >> 8);\n\t\t\t\tMemory.SRAM[0x00dc] = (uint8) (Flags);\n\t\t\t\tMemory.SRAM[0x00dd] = (uint8) (Flags >> 8);\n\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 16-bit Multiplication\n\t\t\tcase 0x06:\n\t\t\t{\n\t\t\t#ifdef FAST_LSB_WORD_ACCESS\n\t\t\t\tST010_Multiply(*(int16 *) &Memory.SRAM[0x0000], *(int16 *) &Memory.SRAM[0x0002], (int32 &) Memory.SRAM[0x0010]);\n\t\t\t#else\n\t\t\t\tint32\tProduct;\n\n\t\t\t\tST010_Multiply(ST010_WORD(0x0000), ST010_WORD(0x0002), Product);\n\n\t\t\t\tMemory.SRAM[0x0010] = (uint8) (Product);\n\t\t\t\tMemory.SRAM[0x0011] = (uint8) (Product >> 8);\n\t\t\t\tMemory.SRAM[0x0012] = (uint8) (Product >> 16);\n\t\t\t\tMemory.SRAM[0x0013] = (uint8) (Product >> 24);\n\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Mode 7 Raster Data Calculation\n\t\t\tcase 0x07:\n\t\t\t{\n\t\t\t#ifdef FAST_LSB_WORD_ACCESS\n\t\t\t\tST010_Raster(*(int16 *) &Memory.SRAM[0x0000]);\n\t\t\t#else\n\t\t\t\tST010_Raster(ST010_WORD(0x0000));\n\t\t\t#endif\n\n\t\t\t\t// Shift Angle for use with Lookup table\n\t\t\t\tMemory.SRAM[0x00] = Memory.SRAM[0x01];\n\t\t\t\tMemory.SRAM[0x01] = 0x00;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Two dimensional Coordinate Rotation\n\t\t\tcase 0x08:\n\t\t\t{\n\t\t\t#ifdef FAST_LSB_WORD_ACCESS\n\t\t\t\tST010_Rotate(*(int16 *) &Memory.SRAM[0x0004], *(int16 *) &Memory.SRAM[0x0000], *(int16 *) &Memory.SRAM[0x0002], (int16 &) Memory.SRAM[0x0010], (int16 &) Memory.SRAM[0x0012]);\n\t\t\t#else\n\t\t\t\tint16\tx1, y1;\n\n\t\t\t\tST010_Rotate(ST010_WORD(0x0004), ST010_WORD(0x0000), ST010_WORD(0x0002), x1, y1);\n\n\t\t\t\tMemory.SRAM[0x0010] = (uint8) (x1);\n\t\t\t\tMemory.SRAM[0x0011] = (uint8) (x1 >> 8);\n\t\t\t\tMemory.SRAM[0x0012] = (uint8) (y1);\n\t\t\t\tMemory.SRAM[0x0013] = (uint8) (y1 >> 8);\n\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t#ifdef DEBUGGER\n\t\t\t\tprintf(\"Unknown Op\\n\");\n\t\t\t#endif\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// lower signal: op processed\n\t\tST010.op_reg  = 0;\n\t\tST010.execute = 0;\n\t}\n}\n"
        },
        {
          "name": "seta011.cpp",
          "type": "blob",
          "size": 2.8857421875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"seta.h\"\n\nstatic uint8\tboard[9][9];\t// shougi playboard\nstatic int\t\tline = 0;\t\t// line counter\n\n\nuint8 S9xGetST011 (uint32 Address)\n{\n\tuint8\tt;\n\tuint16\taddress = (uint16) Address & 0xFFFF;\n\n\tline++;\n\n\t// status check\n\tif (address == 0x01)\n\t\tt = 0xFF;\t\n\telse\n\t\tt = Memory.SRAM[address]; // read directly from s-ram\n\n#ifdef DEBUGGER\n\tif (address < 0x150)\n\t\tprintf(\"ST011 R: %06X %02X\\n\", Address, t);\n#endif\n\n\treturn (t);\n}\n\nvoid S9xSetST011 (uint32 Address, uint8 Byte)\n{\n\tstatic bool\treset   = false;\n\tuint16\t\taddress = (uint16) Address & 0xFFFF;\n\n\tline++;\n\n\tif (!reset)\n\t{\n\t\t// bootup values\n\t\tST011.waiting4command = true;\n\t\treset = true;\n\t}\n\n#ifdef DEBUGGER\n\tif (address < 0x150)\n\t\tprintf(\"ST011 W: %06X %02X\\n\", Address, Byte);\n#endif\n\n\tMemory.SRAM[address] = Byte;\n\n\t// op commands/data goes through this address\n\tif (address == 0x00)\n\t{\n\t\t// check for new commands\n\t\tif (ST011.waiting4command)\n\t\t{\n\t\t\tST011.waiting4command = false;\n\t\t\tST011.command         = Byte;\n\t\t\tST011.in_index        = 0;\n\t\t\tST011.out_index       = 0;\n\n\t\t\tswitch (ST011.command)\n\t\t\t{\n\t\t\t\tcase 0x01: ST011.in_count = 12 * 10 + 8; break;\n\t\t\t\tcase 0x02: ST011.in_count = 4;           break;\n\t\t\t\tcase 0x04: ST011.in_count = 0;           break;\n\t\t\t\tcase 0x05: ST011.in_count = 0;           break;\n\t\t\t\tcase 0x06: ST011.in_count = 0;           break;\n\t\t\t\tcase 0x07: ST011.in_count = 0;           break;\n\t\t\t\tcase 0x0E: ST011.in_count = 0;           break;\n\t\t\t\tdefault:   ST011.waiting4command = true; break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tST011.parameters[ST011.in_index] = Byte;\n\t\t\tST011.in_index++;\n\t\t}\n\t}\n\n\tif (ST011.in_count == ST011.in_index)\n\t{\n\t\t// actually execute the command\n\t\tST011.waiting4command = true;\n\t\tST011.out_index       = 0;\n\n\t\tswitch (ST011.command)\n\t\t{\n\t\t\t// unknown: download playboard\n\t\t\tcase 0x01:\n\t\t\t\t// 9x9 board data: top to bottom, left to right\n\t\t\t\t// Values represent piece types and ownership\n\t\t\t\tfor (int lcv = 0; lcv < 9; lcv++)\n\t\t\t\t\tmemcpy(board[lcv], ST011.parameters + lcv * 10, 9 * 1);\n\t\t\t\tbreak;\n\n\t\t\t// unknown\n\t\t\tcase 0x02:\n\t\t\t\tbreak;\n\n\t\t\t// unknown\n\t\t\tcase 0x04:\n\t\t\t\t// outputs\n\t\t\t\tMemory.SRAM[0x12C] = 0x00;\n\t\t\t\t//Memory.SRAM[0x12D] = 0x00;\n\t\t\t\tMemory.SRAM[0x12E] = 0x00;\n\t\t\t\tbreak;\n\n\t\t\t// unknown\n\t\t\tcase 0x05:\n\t\t\t\t// outputs\n\t\t\t\tMemory.SRAM[0x12C] = 0x00;\n\t\t\t\t//Memory.SRAM[0x12D] = 0x00;\n\t\t\t\tMemory.SRAM[0x12E] = 0x00;\n\t\t\t\tbreak;\n\n\t\t\t// unknown\n\t\t\tcase 0x06:\n\t\t\t\tbreak;\n\n\t\t\tcase 0x07:\n\t\t\t\tbreak;\n\n\t\t\t// unknown\n\t\t\tcase 0x0E:\n\t\t\t\t// outputs\n\t\t\t\tMemory.SRAM[0x12C] = 0x00;\n\t\t\t\tMemory.SRAM[0x12D] = 0x00;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "seta018.cpp",
          "type": "blob",
          "size": 3.6611328125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"seta.h\"\n\nstatic int\tline;\t// line counter\n\n\nuint8 S9xGetST018 (uint32 Address)\n{\n\tuint8\tt       = 0;\n\tuint16\taddress = (uint16) Address & 0xFFFF;\n\n\tline++;\n\n\t// these roles may be flipped\n\t// op output\n\tif (address == 0x3804)\n\t{\n\t\tif (ST018.out_count)\n\t\t{\n\t\t\tt = (uint8) ST018.output[ST018.out_index];\n\t\t\tST018.out_index++;\n\t\t\tif (ST018.out_count == ST018.out_index)\n\t\t\t\tST018.out_count = 0;\n\t\t}\n\t\telse\n\t\t\tt = 0x81;\n\t}\n\t// status register\n\telse\n\tif (address == 0x3800)\n\t\tt = ST018.status;\n\n#ifdef DEBUGGER\n\tprintf(\"ST018 R: %06X %02X\\n\", Address, t);\n#endif\n\n\treturn (t);\n}\n\nvoid S9xSetST018 (uint8 Byte, uint32 Address)\n{\n\tstatic bool\treset   = false;\n\tuint16\t\taddress = (uint16) Address & 0xFFFF;\n\n#ifdef DEBUGGER\n\tprintf(\"ST018 W: %06X %02X\\n\", Address, Byte);\n#endif\n\n\tline++;\n\n\tif (!reset)\n\t{\n\t\t// bootup values\n\t\tST018.waiting4command = true;\n\t\tST018.part_command    = 0;\n\t\treset = true;\n\t}\n\n\tMemory.SRAM[address] = Byte;\n\n\t// default status for now\n\tST018.status = 0x00;\n\n\t// op data goes through this address\n\tif (address == 0x3804)\n\t{\n\t\t// check for new commands: 3 bytes length\n\t\tif (ST018.waiting4command && ST018.part_command == 2)\n\t\t{\n\t\t\tST018.waiting4command = false;\n\t\t\tST018.in_index        = 0;\n\t\t\tST018.out_index       = 0;\n\t\t\tST018.part_command    = 0; // 3-byte commands\n\t\t\tST018.pass            = 0; // data streams into the chip\n\t\t\tST018.command <<= 8;\n\t\t\tST018.command |= Byte;\n\n\t\t\tswitch (ST018.command & 0xFFFFFF)\n\t\t\t{\n\t\t\t\tcase 0x0100: ST018.in_count        = 0;    break;\n\t\t\t\tcase 0xFF00: ST018.in_count        = 0;    break;\n\t\t\t\tdefault:     ST018.waiting4command = true; break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\tif (ST018.waiting4command)\n\t\t{\n\t\t\t// 3-byte commands\n\t\t\tST018.part_command++;\n\t\t\tST018.command <<= 8;\n\t\t\tST018.command |= Byte;\n\t\t}\n\t}\n\t// extra parameters\n\telse\n\tif (address == 0x3802)\n\t{\n\t\tST018.parameters[ST018.in_index] = Byte;\n\t\tST018.in_index++;\n\t}\n\n\tif (ST018.in_count == ST018.in_index)\n\t{\n\t\t// qctually execute the command\n\t\tST018.waiting4command = true;\n\t\tST018.in_index        = 0;\n\t\tST018.out_index       = 0;\n\n\t\tswitch (ST018.command)\n\t\t{\n\t\t\t// hardware check?\n\t\t\tcase 0x0100:\n\t\t\t\tST018.waiting4command = false;\n\t\t\t\tST018.pass++;\n\n\t\t\t\tif (ST018.pass == 1)\n\t\t\t\t{\n\t\t\t\t\tST018.in_count  = 1;\n\t\t\t\t\tST018.out_count = 2;\n\n\t\t\t\t\t// Overload's research\n\t\t\t\t\tST018.output[0x00] = 0x81;\n\t\t\t\t\tST018.output[0x01] = 0x81;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//ST018.in_count = 1;\n\t\t\t\t\tST018.out_count = 3;\n\n\t\t\t\t\t// no reason to change this\n\t\t\t\t\t//ST018.output[0x00] = 0x81;\n\t\t\t\t\t//ST018.output[0x01] = 0x81;\n\t\t\t\t\tST018.output[0x02] = 0x81;\n\n\t\t\t\t\t// done processing requests\n\t\t\t\t\tif (ST018.pass == 3)\n\t\t\t\t\t\tST018.waiting4command = true;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t// unknown: feels like a security detection\n\t\t\t// format identical to 0x0100\n\t\t\tcase 0xFF00:\n\t\t\t\tST018.waiting4command = false;\n\t\t\t\tST018.pass++;\n\n\t\t\t\tif (ST018.pass == 1)\n\t\t\t\t{\n\t\t\t\t\tST018.in_count  = 1;\n\t\t\t\t\tST018.out_count = 2;\n\n\t\t\t\t\t// Overload's research\n\t\t\t\t\tST018.output[0x00] = 0x81;\n\t\t\t\t\tST018.output[0x01] = 0x81;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//ST018.in_count = 1;\n\t\t\t\t\tST018.out_count = 3;\n\n\t\t\t\t\t// no reason to change this\n\t\t\t\t\t//ST018.output[0x00] = 0x81;\n\t\t\t\t\t//ST018.output[0x01] = 0x81;\n\t\t\t\t\tST018.output[0x02] = 0x81;\n\n\t\t\t\t\t// done processing requests\n\t\t\t\t\tif (ST018.pass == 3)\n\t\t\t\t\t\tST018.waiting4command = true;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "sha256.cpp",
          "type": "blob",
          "size": 5.7275390625,
          "content": "/*********************************************************************\n* Filename:   sha256.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Implementation of the SHA-256 hashing algorithm.\n              SHA-256 is one of the three algorithms in the SHA2\n              specification. The others, SHA-384 and SHA-512, are not\n              offered in this implementation.\n              Algorithm specification can be found here:\n               * http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf\n              This implementation uses little endian byte order.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n/****************************** MACROS ******************************/\n#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))\n#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))\n\n#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))\n#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))\n#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))\n#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))\n#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))\n#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))\n#define SHA256_BLOCK_SIZE 32            /* SHA256 outputs a 32 byte digest */\n\n/**************************** DATA TYPES ****************************/\ntypedef unsigned char BYTE;             /* 8-bit byte */\ntypedef unsigned int  WORD;             /* 32-bit word, change to \"long\" for 16-bit machines */\n\ntypedef struct {\n\tBYTE data[64];\n\tWORD datalen;\n\tuint64_t bitlen;\n\tWORD state[8];\n} SHA256_CTX;\n\n/**************************** VARIABLES *****************************/\nstatic const WORD k[64] = {\n\t0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,\n\t0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,\n\t0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,\n\t0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,\n\t0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,\n\t0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,\n\t0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,\n\t0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2\n};\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nvoid sha256_transform(SHA256_CTX *ctx, const BYTE data[])\n{\n\tWORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];\n\n\tfor (i = 0, j = 0; i < 16; ++i, j += 4)\n\t\tm[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);\n\tfor ( ; i < 64; ++i)\n\t\tm[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];\n\n\ta = ctx->state[0];\n\tb = ctx->state[1];\n\tc = ctx->state[2];\n\td = ctx->state[3];\n\te = ctx->state[4];\n\tf = ctx->state[5];\n\tg = ctx->state[6];\n\th = ctx->state[7];\n\n\tfor (i = 0; i < 64; ++i) {\n\t\tt1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];\n\t\tt2 = EP0(a) + MAJ(a,b,c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + t1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = t1 + t2;\n\t}\n\n\tctx->state[0] += a;\n\tctx->state[1] += b;\n\tctx->state[2] += c;\n\tctx->state[3] += d;\n\tctx->state[4] += e;\n\tctx->state[5] += f;\n\tctx->state[6] += g;\n\tctx->state[7] += h;\n}\n\nvoid sha256_init(SHA256_CTX *ctx)\n{\n\tctx->datalen = 0;\n\tctx->bitlen = 0;\n\tctx->state[0] = 0x6a09e667;\n\tctx->state[1] = 0xbb67ae85;\n\tctx->state[2] = 0x3c6ef372;\n\tctx->state[3] = 0xa54ff53a;\n\tctx->state[4] = 0x510e527f;\n\tctx->state[5] = 0x9b05688c;\n\tctx->state[6] = 0x1f83d9ab;\n\tctx->state[7] = 0x5be0cd19;\n}\n\nvoid sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len)\n{\n\tWORD i;\n\n\tfor (i = 0; i < len; ++i) {\n\t\tctx->data[ctx->datalen] = data[i];\n\t\tctx->datalen++;\n\t\tif (ctx->datalen == 64) {\n\t\t\tsha256_transform(ctx, ctx->data);\n\t\t\tctx->bitlen += 512;\n\t\t\tctx->datalen = 0;\n\t\t}\n\t}\n}\n\nvoid sha256_final(SHA256_CTX *ctx, BYTE hash[])\n{\n\tWORD i;\n\n\ti = ctx->datalen;\n\n\t// Pad whatever data is left in the buffer.\n\tif (ctx->datalen < 56) {\n\t\tctx->data[i++] = 0x80;\n\t\twhile (i < 56)\n\t\t\tctx->data[i++] = 0x00;\n\t}\n\telse {\n\t\tctx->data[i++] = 0x80;\n\t\twhile (i < 64)\n\t\t\tctx->data[i++] = 0x00;\n\t\tsha256_transform(ctx, ctx->data);\n\t\tmemset(ctx->data, 0, 56);\n\t}\n\n\t/* Append to the padding the total message's length in bits and transform. */\n\tctx->bitlen += ctx->datalen * 8;\n\tctx->data[63] = ctx->bitlen;\n\tctx->data[62] = ctx->bitlen >> 8;\n\tctx->data[61] = ctx->bitlen >> 16;\n\tctx->data[60] = ctx->bitlen >> 24;\n\tctx->data[59] = ctx->bitlen >> 32;\n\tctx->data[58] = ctx->bitlen >> 40;\n\tctx->data[57] = ctx->bitlen >> 48;\n\tctx->data[56] = ctx->bitlen >> 56;\n\tsha256_transform(ctx, ctx->data);\n\n\t/* Since this implementation uses little endian byte ordering and SHA uses big endian,\n\t   reverse all the bytes when copying the final state to the output hash. */\n\tfor (i = 0; i < 4; ++i) {\n\t\thash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;\n\t}\n}\n\nvoid sha256sum(unsigned char *data, unsigned int length, unsigned char *hash)\n{\n    SHA256_CTX ctx;\n\n    sha256_init(&ctx);\n    sha256_update(&ctx, data, length);\n    sha256_final(&ctx, hash);\n}\n"
        },
        {
          "name": "sha256.h",
          "type": "blob",
          "size": 0.1240234375,
          "content": "#ifndef __SHA256_H\n#define __SHA256_H\n\nvoid sha256sum (unsigned char *data, unsigned int length, unsigned char *hash);\n\n#endif\n"
        },
        {
          "name": "snapshot.cpp",
          "type": "blob",
          "size": 61.134765625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include <assert.h>\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"dma.h\"\n#include \"apu/apu.h\"\n#include \"fxinst.h\"\n#include \"fxemu.h\"\n#include \"sdd1.h\"\n#include \"srtc.h\"\n#include \"snapshot.h\"\n#include \"controls.h\"\n#include \"movie.h\"\n#include \"display.h\"\n#include \"language.h\"\n#include \"gfx.h\"\n\n#ifndef min\n#define min(a,b)\t(((a) < (b)) ? (a) : (b))\n#endif\n\ntypedef struct\n{\n\tint\t\t\toffset;\n\tint\t\t\toffset2;\n\tint\t\t\tsize;\n\tint\t\t\ttype;\n\tuint16\t\tdebuted_in;\n\tuint16\t\tdeleted_in;\n\tconst char\t*name;\n}\tFreezeData;\n\nenum\n{\n\tINT_V,\n\tuint8_ARRAY_V,\n\tuint16_ARRAY_V,\n\tuint32_ARRAY_V,\n\tuint8_INDIR_ARRAY_V,\n\tuint16_INDIR_ARRAY_V,\n\tuint32_INDIR_ARRAY_V,\n\tPOINTER_V\n};\n\n#define COUNT(ARRAY)\t\t\t\t(sizeof(ARRAY) / sizeof(ARRAY[0]))\n#define Offset(field, structure)\t((int) (((char *) (&(((structure) 1)->field))) - ((char *) 1)))\n#define OFFSET(f)\t\t\t\t\tOffset(f, STRUCT *)\n#define DUMMY(f)\t\t\t\t\tOffset(f, struct Obsolete *)\n#define DELETED(f)\t\t\t\t\t(-1)\n\n#define INT_ENTRY(save_version_introduced, field) \\\n{ \\\n\tOFFSET(field), \\\n\t0, \\\n\tsizeof(((STRUCT *) NULL)->field), \\\n\tINT_V, \\\n\tsave_version_introduced, \\\n\t9999, \\\n\t#field \\\n}\n\n#define ARRAY_ENTRY(save_version_introduced, field, count, elemType) \\\n{ \\\n\tOFFSET(field), \\\n\t0, \\\n\tcount, \\\n\telemType, \\\n\tsave_version_introduced, \\\n\t9999, \\\n\t#field \\\n}\n\n#define POINTER_ENTRY(save_version_introduced, field, relativeToField) \\\n{ \\\n\tOFFSET(field), \\\n\tOFFSET(relativeToField), \\\n\t4, \\\n\tPOINTER_V, \\\n\tsave_version_introduced, \\\n\t9999, \\\n\t#field \\\n}\n\n#define OBSOLETE_INT_ENTRY(save_version_introduced, save_version_removed, field) \\\n{ \\\n\tDUMMY(field), \\\n\t0, \\\n\tsizeof(((struct Obsolete *) NULL)->field), \\\n\tINT_V, \\\n\tsave_version_introduced, \\\n\tsave_version_removed, \\\n\t#field \\\n}\n\n#define OBSOLETE_ARRAY_ENTRY(save_version_introduced, save_version_removed, field, count, elemType) \\\n{ \\\n\tDUMMY(field), \\\n\t0, \\\n\tcount, \\\n\telemType, \\\n\tsave_version_introduced, \\\n\tsave_version_removed, \\\n\t#field \\\n}\n\n#define OBSOLETE_POINTER_ENTRY(save_version_introduced, save_version_removed, field, relativeToField) \\\n{ \\\n\tDUMMY(field), \\\n\tDUMMY(relativeToField), \\\n\t4, \\\n\tPOINTER_V, \\\n\tsave_version_introduced, \\\n\tsave_version_removed, \\\n\t#field \\\n}\n\n#define DELETED_INT_ENTRY(save_version_introduced, save_version_removed, field, size) \\\n{ \\\n\tDELETED(field), \\\n\t0, \\\n\tsize, \\\n\tINT_V, \\\n\tsave_version_introduced, \\\n\tsave_version_removed, \\\n\t#field \\\n}\n\n#define DELETED_ARRAY_ENTRY(save_version_introduced, save_version_removed, field, count, elemType) \\\n{ \\\n\tDELETED(field), \\\n\t0, \\\n\tcount, \\\n\telemType, \\\n\tsave_version_introduced, \\\n\tsave_version_removed, \\\n\t#field \\\n}\n\n#define DELETED_POINTER_ENTRY(save_version_introduced, save_version_removed, field, relativeToField) \\\n{ \\\n\tDELETED(field), \\\n\tDELETED(relativeToField), \\\n\t4, \\\n\tPOINTER_V, \\\n\tsave_version_introduced, \\\n\tsave_version_removed, \\\n\t#field \\\n}\n\nstruct SDMASnapshot\n{\n\tstruct SDMA\tdma[8];\n};\n\nstruct SnapshotMovieInfo\n{\n\tuint32\tMovieInputDataSize;\n};\n\nstruct SnapshotScreenshotInfo\n{\n\tuint16\tWidth;\n\tuint16\tHeight;\n\tuint8\tInterlaced;\n\tuint8\tData[MAX_SNES_WIDTH * MAX_SNES_HEIGHT * 3];\n};\n\nstatic struct Obsolete\n{\n\tuint8\tCPU_IRQActive;\n}\tObsolete;\n\n#define STRUCT\tstruct SCPUState\n\nstatic FreezeData\tSnapCPU[] =\n{\n\tINT_ENTRY(6, Cycles),\n\tINT_ENTRY(6, PrevCycles),\n\tINT_ENTRY(6, V_Counter),\n\tINT_ENTRY(6, Flags),\n\tOBSOLETE_INT_ENTRY(6, 7, CPU_IRQActive),\n\tINT_ENTRY(6, IRQPending),\n\tINT_ENTRY(6, MemSpeed),\n\tINT_ENTRY(6, MemSpeedx2),\n\tINT_ENTRY(6, FastROMSpeed),\n\tINT_ENTRY(6, InDMA),\n\tINT_ENTRY(6, InHDMA),\n\tINT_ENTRY(6, InDMAorHDMA),\n\tINT_ENTRY(6, InWRAMDMAorHDMA),\n\tINT_ENTRY(6, HDMARanInDMA),\n\tINT_ENTRY(6, WhichEvent),\n\tINT_ENTRY(6, NextEvent),\n\tINT_ENTRY(6, WaitingForInterrupt),\n\tDELETED_INT_ENTRY(6, 7, WaitAddress, 4),\n\tDELETED_INT_ENTRY(6, 7, WaitCounter, 4),\n\tDELETED_INT_ENTRY(6, 7, PBPCAtOpcodeStart, 4),\n\tINT_ENTRY(7, NMIPending),\n\tINT_ENTRY(7, IRQLine),\n\tINT_ENTRY(7, IRQTransition),\n\tINT_ENTRY(7, IRQLastState),\n\tINT_ENTRY(7, IRQExternal)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SRegisters\n\nstatic FreezeData\tSnapRegisters[] =\n{\n\tINT_ENTRY(6, PB),\n\tINT_ENTRY(6, DB),\n\tINT_ENTRY(6, P.W),\n\tINT_ENTRY(6, A.W),\n\tINT_ENTRY(6, D.W),\n\tINT_ENTRY(6, S.W),\n\tINT_ENTRY(6, X.W),\n\tINT_ENTRY(6, Y.W),\n\tINT_ENTRY(6, PCw)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SPPU\n\nstatic FreezeData\tSnapPPU[] =\n{\n\tINT_ENTRY(6, VMA.High),\n\tINT_ENTRY(6, VMA.Increment),\n\tINT_ENTRY(6, VMA.Address),\n\tINT_ENTRY(6, VMA.Mask1),\n\tINT_ENTRY(6, VMA.FullGraphicCount),\n\tINT_ENTRY(6, VMA.Shift),\n\tINT_ENTRY(6, WRAM),\n#define O(N) \\\n\tINT_ENTRY(6, BG[N].SCBase), \\\n\tINT_ENTRY(6, BG[N].HOffset), \\\n\tINT_ENTRY(6, BG[N].VOffset), \\\n\tINT_ENTRY(6, BG[N].BGSize), \\\n\tINT_ENTRY(6, BG[N].NameBase), \\\n\tINT_ENTRY(6, BG[N].SCSize)\n\tO(0), O(1), O(2), O(3),\n#undef O\n\tINT_ENTRY(6, BGMode),\n\tINT_ENTRY(6, BG3Priority),\n\tINT_ENTRY(6, CGFLIP),\n\tINT_ENTRY(6, CGFLIPRead),\n\tINT_ENTRY(6, CGADD),\n\tINT_ENTRY(11, CGSavedByte),\n\tARRAY_ENTRY(6, CGDATA, 256, uint16_ARRAY_V),\n#define O(N) \\\n\tINT_ENTRY(6, OBJ[N].HPos), \\\n\tINT_ENTRY(6, OBJ[N].VPos), \\\n\tINT_ENTRY(6, OBJ[N].HFlip), \\\n\tINT_ENTRY(6, OBJ[N].VFlip), \\\n\tINT_ENTRY(6, OBJ[N].Name), \\\n\tINT_ENTRY(6, OBJ[N].Priority), \\\n\tINT_ENTRY(6, OBJ[N].Palette), \\\n\tINT_ENTRY(6, OBJ[N].Size)\n\tO(  0), O(  1), O(  2), O(  3), O(  4), O(  5), O(  6), O(  7),\n\tO(  8), O(  9), O( 10), O( 11), O( 12), O( 13), O( 14), O( 15),\n\tO( 16), O( 17), O( 18), O( 19), O( 20), O( 21), O( 22), O( 23),\n\tO( 24), O( 25), O( 26), O( 27), O( 28), O( 29), O( 30), O( 31),\n\tO( 32), O( 33), O( 34), O( 35), O( 36), O( 37), O( 38), O( 39),\n\tO( 40), O( 41), O( 42), O( 43), O( 44), O( 45), O( 46), O( 47),\n\tO( 48), O( 49), O( 50), O( 51), O( 52), O( 53), O( 54), O( 55),\n\tO( 56), O( 57), O( 58), O( 59), O( 60), O( 61), O( 62), O( 63),\n\tO( 64), O( 65), O( 66), O( 67), O( 68), O( 69), O( 70), O( 71),\n\tO( 72), O( 73), O( 74), O( 75), O( 76), O( 77), O( 78), O( 79),\n\tO( 80), O( 81), O( 82), O( 83), O( 84), O( 85), O( 86), O( 87),\n\tO( 88), O( 89), O( 90), O( 91), O( 92), O( 93), O( 94), O( 95),\n\tO( 96), O( 97), O( 98), O( 99), O(100), O(101), O(102), O(103),\n\tO(104), O(105), O(106), O(107), O(108), O(109), O(110), O(111),\n\tO(112), O(113), O(114), O(115), O(116), O(117), O(118), O(119),\n\tO(120), O(121), O(122), O(123), O(124), O(125), O(126), O(127),\n#undef O\n\tINT_ENTRY(6, OBJThroughMain),\n\tINT_ENTRY(6, OBJThroughSub),\n\tINT_ENTRY(6, OBJAddition),\n\tINT_ENTRY(6, OBJNameBase),\n\tINT_ENTRY(6, OBJNameSelect),\n\tINT_ENTRY(6, OBJSizeSelect),\n\tINT_ENTRY(6, OAMAddr),\n\tINT_ENTRY(6, SavedOAMAddr),\n\tINT_ENTRY(6, OAMPriorityRotation),\n\tINT_ENTRY(6, OAMFlip),\n\tINT_ENTRY(6, OAMReadFlip),\n\tINT_ENTRY(6, OAMTileAddress),\n\tINT_ENTRY(6, OAMWriteRegister),\n\tARRAY_ENTRY(6, OAMData, 512 + 32, uint8_ARRAY_V),\n\tINT_ENTRY(6, FirstSprite),\n\tINT_ENTRY(6, LastSprite),\n\tINT_ENTRY(6, HTimerEnabled),\n\tINT_ENTRY(6, VTimerEnabled),\n\tINT_ENTRY(6, HTimerPosition),\n\tINT_ENTRY(6, VTimerPosition),\n\tINT_ENTRY(6, IRQHBeamPos),\n\tINT_ENTRY(6, IRQVBeamPos),\n\tINT_ENTRY(6, HBeamFlip),\n\tINT_ENTRY(6, VBeamFlip),\n\tINT_ENTRY(6, HBeamPosLatched),\n\tINT_ENTRY(6, VBeamPosLatched),\n\tINT_ENTRY(6, GunHLatch),\n\tINT_ENTRY(6, GunVLatch),\n\tINT_ENTRY(6, HVBeamCounterLatched),\n\tINT_ENTRY(6, Mode7HFlip),\n\tINT_ENTRY(6, Mode7VFlip),\n\tINT_ENTRY(6, Mode7Repeat),\n\tINT_ENTRY(6, MatrixA),\n\tINT_ENTRY(6, MatrixB),\n\tINT_ENTRY(6, MatrixC),\n\tINT_ENTRY(6, MatrixD),\n\tINT_ENTRY(6, CentreX),\n\tINT_ENTRY(6, CentreY),\n\tINT_ENTRY(6, M7HOFS),\n\tINT_ENTRY(6, M7VOFS),\n\tINT_ENTRY(6, Mosaic),\n\tINT_ENTRY(6, MosaicStart),\n\tARRAY_ENTRY(6, BGMosaic, 4, uint8_ARRAY_V),\n\tINT_ENTRY(6, Window1Left),\n\tINT_ENTRY(6, Window1Right),\n\tINT_ENTRY(6, Window2Left),\n\tINT_ENTRY(6, Window2Right),\n\tINT_ENTRY(6, RecomputeClipWindows),\n#define O(N) \\\n\tINT_ENTRY(6, ClipCounts[N]), \\\n\tINT_ENTRY(6, ClipWindowOverlapLogic[N]), \\\n\tINT_ENTRY(6, ClipWindow1Enable[N]), \\\n\tINT_ENTRY(6, ClipWindow2Enable[N]), \\\n\tINT_ENTRY(6, ClipWindow1Inside[N]), \\\n\tINT_ENTRY(6, ClipWindow2Inside[N])\n\tO(0), O(1), O(2), O(3), O(4), O(5),\n#undef O\n\tINT_ENTRY(6, ForcedBlanking),\n\tINT_ENTRY(6, FixedColourRed),\n\tINT_ENTRY(6, FixedColourGreen),\n\tINT_ENTRY(6, FixedColourBlue),\n\tINT_ENTRY(6, Brightness),\n\tINT_ENTRY(6, ScreenHeight),\n\tINT_ENTRY(6, Need16x8Mulitply),\n\tINT_ENTRY(6, BGnxOFSbyte),\n\tINT_ENTRY(6, M7byte),\n\tINT_ENTRY(6, HDMA),\n\tINT_ENTRY(6, HDMAEnded),\n\tINT_ENTRY(6, OpenBus1),\n\tINT_ENTRY(6, OpenBus2),\n\tINT_ENTRY(11, VRAMReadBuffer)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SDMASnapshot\n\nstatic FreezeData\tSnapDMA[] =\n{\n#define O(N) \\\n\tINT_ENTRY(6, dma[N].ReverseTransfer), \\\n\tINT_ENTRY(6, dma[N].HDMAIndirectAddressing), \\\n\tINT_ENTRY(6, dma[N].UnusedBit43x0), \\\n\tINT_ENTRY(6, dma[N].AAddressFixed), \\\n\tINT_ENTRY(6, dma[N].AAddressDecrement), \\\n\tINT_ENTRY(6, dma[N].TransferMode), \\\n\tINT_ENTRY(6, dma[N].BAddress), \\\n\tINT_ENTRY(6, dma[N].AAddress), \\\n\tINT_ENTRY(6, dma[N].ABank), \\\n\tINT_ENTRY(6, dma[N].DMACount_Or_HDMAIndirectAddress), \\\n\tINT_ENTRY(6, dma[N].IndirectBank), \\\n\tINT_ENTRY(6, dma[N].Address), \\\n\tINT_ENTRY(6, dma[N].Repeat), \\\n\tINT_ENTRY(6, dma[N].LineCount), \\\n\tINT_ENTRY(6, dma[N].UnknownByte), \\\n\tINT_ENTRY(6, dma[N].DoTransfer)\n\tO(0), O(1), O(2), O(3), O(4), O(5), O(6), O(7)\n#undef O\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SControlSnapshot\n\nstatic FreezeData\tSnapControls[] =\n{\n\tINT_ENTRY(6, ver),\n\tARRAY_ENTRY(6, port1_read_idx, 2, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, dummy1, 4, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, port2_read_idx, 2, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, dummy2, 4, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, mouse_speed, 2, uint8_ARRAY_V),\n\tINT_ENTRY(6, justifier_select),\n\tARRAY_ENTRY(6, dummy3, 8, uint8_ARRAY_V),\n\tINT_ENTRY(6, pad_read),\n\tINT_ENTRY(6, pad_read_last),\n\tARRAY_ENTRY(6, internal, 60, uint8_ARRAY_V),\n\tARRAY_ENTRY(10, internal_macs, 5, uint8_ARRAY_V)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct STimings\n\nstatic FreezeData\tSnapTimings[] =\n{\n\tINT_ENTRY(6, H_Max_Master),\n\tINT_ENTRY(6, H_Max),\n\tINT_ENTRY(6, V_Max_Master),\n\tINT_ENTRY(6, V_Max),\n\tINT_ENTRY(6, HBlankStart),\n\tINT_ENTRY(6, HBlankEnd),\n\tINT_ENTRY(6, HDMAInit),\n\tINT_ENTRY(6, HDMAStart),\n\tINT_ENTRY(6, NMITriggerPos),\n\tINT_ENTRY(6, WRAMRefreshPos),\n\tINT_ENTRY(6, RenderPos),\n\tINT_ENTRY(6, InterlaceField),\n\tINT_ENTRY(6, DMACPUSync),\n\tINT_ENTRY(6, NMIDMADelay),\n\tINT_ENTRY(6, IRQFlagChanging),\n\tINT_ENTRY(6, APUSpeedup),\n\tINT_ENTRY(7, IRQTriggerCycles),\n\tINT_ENTRY(7, APUAllowTimeOverflow),\n\tINT_ENTRY(11, NextIRQTimer)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct FxRegs_s\n\nstatic FreezeData\tSnapFX[] =\n{\n\tARRAY_ENTRY(6, avReg, 16, uint32_ARRAY_V),\n\tINT_ENTRY(6, vColorReg),\n\tINT_ENTRY(6, vPlotOptionReg),\n\tINT_ENTRY(6, vStatusReg),\n\tINT_ENTRY(6, vPrgBankReg),\n\tINT_ENTRY(6, vRomBankReg),\n\tINT_ENTRY(6, vRamBankReg),\n\tINT_ENTRY(6, vCacheBaseReg),\n\tINT_ENTRY(6, vCacheFlags),\n\tINT_ENTRY(6, vLastRamAdr),\n\tPOINTER_ENTRY(6, pvDreg, avRegAddr),\n\tPOINTER_ENTRY(6, pvSreg, avRegAddr),\n\tINT_ENTRY(6, vRomBuffer),\n\tINT_ENTRY(6, vPipe),\n\tINT_ENTRY(6, vPipeAdr),\n\tINT_ENTRY(6, vSign),\n\tINT_ENTRY(6, vZero),\n\tINT_ENTRY(6, vCarry),\n\tINT_ENTRY(6, vOverflow),\n\tINT_ENTRY(6, vErrorCode),\n\tINT_ENTRY(6, vIllegalAddress),\n\tINT_ENTRY(6, bBreakPoint),\n\tINT_ENTRY(6, vBreakPoint),\n\tINT_ENTRY(6, vStepPoint),\n\tINT_ENTRY(6, nRamBanks),\n\tINT_ENTRY(6, nRomBanks),\n\tINT_ENTRY(6, vMode),\n\tINT_ENTRY(6, vPrevMode),\n\tPOINTER_ENTRY(6, pvScreenBase, pvRam),\n#define O(N) \\\n\tPOINTER_ENTRY(6, apvScreen[N], pvRam)\n\tO(  0), O(  1), O(  2), O(  3), O(  4), O(  5), O(  6), O(  7),\n\tO(  8), O(  9), O( 10), O( 11), O( 12), O( 13), O( 14), O( 15),\n\tO( 16), O( 17), O( 18), O( 19), O( 20), O( 21), O( 22), O( 23),\n\tO( 24), O( 25), O( 26), O( 27), O( 28), O( 29), O( 30), O( 31),\n#undef O\n\tARRAY_ENTRY(6, x, 32, uint32_ARRAY_V),\n\tINT_ENTRY(6, vScreenHeight),\n\tINT_ENTRY(6, vScreenRealHeight),\n\tINT_ENTRY(6, vPrevScreenHeight),\n\tINT_ENTRY(6, vScreenSize),\n\tPOINTER_ENTRY(6, pvRamBank, apvRamBank),\n\tPOINTER_ENTRY(6, pvRomBank, apvRomBank),\n\tPOINTER_ENTRY(6, pvPrgBank, apvRomBank),\n#define O(N) \\\n\tPOINTER_ENTRY(6, apvRamBank[N], pvRam)\n\tO(0), O(1), O(2), O(3),\n#undef O\n\tINT_ENTRY(6, bCacheActive),\n\tPOINTER_ENTRY(6, pvCache, pvRegisters),\n\tARRAY_ENTRY(6, avCacheBackup, 512, uint8_ARRAY_V),\n\tINT_ENTRY(6, vCounter),\n\tINT_ENTRY(6, vInstCount),\n\tINT_ENTRY(6, vSCBRDirty)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SSA1\n\nstatic FreezeData\tSnapSA1[] =\n{\n\tDELETED_INT_ENTRY(6, 7, CPUExecuting, 1),\n\tINT_ENTRY(6, ShiftedPB),\n\tINT_ENTRY(6, ShiftedDB),\n\tINT_ENTRY(6, Flags),\n\tDELETED_INT_ENTRY(6, 7, IRQActive, 1),\n\tDELETED_INT_ENTRY(6, 7, Waiting, 1),\n\tINT_ENTRY(6, WaitingForInterrupt),\n\tDELETED_INT_ENTRY(6, 7, WaitAddress, 4),\n\tDELETED_INT_ENTRY(6, 7, WaitCounter, 4),\n\tDELETED_INT_ENTRY(6, 7, PBPCAtOpcodeStart, 4),\n\tDELETED_INT_ENTRY(6, 7, Executing, 1),\n\tINT_ENTRY(6, overflow),\n\tINT_ENTRY(6, in_char_dma),\n\tINT_ENTRY(6, op1),\n\tINT_ENTRY(6, op2),\n\tINT_ENTRY(6, arithmetic_op),\n\tINT_ENTRY(6, sum),\n\tINT_ENTRY(6, VirtualBitmapFormat),\n\tINT_ENTRY(6, variable_bit_pos),\n\tINT_ENTRY(7, Cycles),\n\tINT_ENTRY(7, PrevCycles),\n\tINT_ENTRY(7, TimerIRQLastState),\n\tINT_ENTRY(7, HTimerIRQPos),\n\tINT_ENTRY(7, VTimerIRQPos),\n\tINT_ENTRY(7, HCounter),\n\tINT_ENTRY(7, VCounter),\n\tINT_ENTRY(7, PrevHCounter),\n\tINT_ENTRY(7, MemSpeed),\n\tINT_ENTRY(7, MemSpeedx2)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SSA1Registers\n\nstatic FreezeData\tSnapSA1Registers[] =\n{\n\tINT_ENTRY(6, PB),\n\tINT_ENTRY(6, DB),\n\tINT_ENTRY(6, P.W),\n\tINT_ENTRY(6, A.W),\n\tINT_ENTRY(6, D.W),\n\tINT_ENTRY(6, S.W),\n\tINT_ENTRY(6, X.W),\n\tINT_ENTRY(6, Y.W),\n\tINT_ENTRY(6, PCw)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SDSP1\n\nstatic FreezeData\tSnapDSP1[] =\n{\n\tINT_ENTRY(6, waiting4command),\n\tINT_ENTRY(6, first_parameter),\n\tINT_ENTRY(6, command),\n\tINT_ENTRY(6, in_count),\n\tINT_ENTRY(6, in_index),\n\tINT_ENTRY(6, out_count),\n\tINT_ENTRY(6, out_index),\n\tARRAY_ENTRY(6, parameters, 512, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, output, 512, uint8_ARRAY_V),\n\tINT_ENTRY(6, CentreX),\n\tINT_ENTRY(6, CentreY),\n\tINT_ENTRY(6, VOffset),\n\tINT_ENTRY(6, VPlane_C),\n\tINT_ENTRY(6, VPlane_E),\n\tINT_ENTRY(6, SinAas),\n\tINT_ENTRY(6, CosAas),\n\tINT_ENTRY(6, SinAzs),\n\tINT_ENTRY(6, CosAzs),\n\tINT_ENTRY(6, SinAZS),\n\tINT_ENTRY(6, CosAZS),\n\tINT_ENTRY(6, SecAZS_C1),\n\tINT_ENTRY(6, SecAZS_E1),\n\tINT_ENTRY(6, SecAZS_C2),\n\tINT_ENTRY(6, SecAZS_E2),\n\tINT_ENTRY(6, Nx),\n\tINT_ENTRY(6, Ny),\n\tINT_ENTRY(6, Nz),\n\tINT_ENTRY(6, Gx),\n\tINT_ENTRY(6, Gy),\n\tINT_ENTRY(6, Gz),\n\tINT_ENTRY(6, C_Les),\n\tINT_ENTRY(6, E_Les),\n\tINT_ENTRY(6, G_Les),\n#define O(N) \\\n\tARRAY_ENTRY(6, matrixA[N], 3, uint16_ARRAY_V), \\\n\tARRAY_ENTRY(6, matrixB[N], 3, uint16_ARRAY_V), \\\n\tARRAY_ENTRY(6, matrixC[N], 3, uint16_ARRAY_V)\n\tO(0), O(1), O(2),\n#undef O\n\tINT_ENTRY(6, Op00Multiplicand),\n\tINT_ENTRY(6, Op00Multiplier),\n\tINT_ENTRY(6, Op00Result),\n\tINT_ENTRY(6, Op20Multiplicand),\n\tINT_ENTRY(6, Op20Multiplier),\n\tINT_ENTRY(6, Op20Result),\n\tINT_ENTRY(6, Op10Coefficient),\n\tINT_ENTRY(6, Op10Exponent),\n\tINT_ENTRY(6, Op10CoefficientR),\n\tINT_ENTRY(6, Op10ExponentR),\n\tINT_ENTRY(6, Op04Angle),\n\tINT_ENTRY(6, Op04Radius),\n\tINT_ENTRY(6, Op04Sin),\n\tINT_ENTRY(6, Op04Cos),\n\tINT_ENTRY(6, Op0CA),\n\tINT_ENTRY(6, Op0CX1),\n\tINT_ENTRY(6, Op0CY1),\n\tINT_ENTRY(6, Op0CX2),\n\tINT_ENTRY(6, Op0CY2),\n\tINT_ENTRY(6, Op02FX),\n\tINT_ENTRY(6, Op02FY),\n\tINT_ENTRY(6, Op02FZ),\n\tINT_ENTRY(6, Op02LFE),\n\tINT_ENTRY(6, Op02LES),\n\tINT_ENTRY(6, Op02AAS),\n\tINT_ENTRY(6, Op02AZS),\n\tINT_ENTRY(6, Op02VOF),\n\tINT_ENTRY(6, Op02VVA),\n\tINT_ENTRY(6, Op02CX),\n\tINT_ENTRY(6, Op02CY),\n\tINT_ENTRY(6, Op0AVS),\n\tINT_ENTRY(6, Op0AA),\n\tINT_ENTRY(6, Op0AB),\n\tINT_ENTRY(6, Op0AC),\n\tINT_ENTRY(6, Op0AD),\n\tINT_ENTRY(6, Op06X),\n\tINT_ENTRY(6, Op06Y),\n\tINT_ENTRY(6, Op06Z),\n\tINT_ENTRY(6, Op06H),\n\tINT_ENTRY(6, Op06V),\n\tINT_ENTRY(6, Op06M),\n\tINT_ENTRY(6, Op01m),\n\tINT_ENTRY(6, Op01Zr),\n\tINT_ENTRY(6, Op01Xr),\n\tINT_ENTRY(6, Op01Yr),\n\tINT_ENTRY(6, Op11m),\n\tINT_ENTRY(6, Op11Zr),\n\tINT_ENTRY(6, Op11Xr),\n\tINT_ENTRY(6, Op11Yr),\n\tINT_ENTRY(6, Op21m),\n\tINT_ENTRY(6, Op21Zr),\n\tINT_ENTRY(6, Op21Xr),\n\tINT_ENTRY(6, Op21Yr),\n\tINT_ENTRY(6, Op0DX),\n\tINT_ENTRY(6, Op0DY),\n\tINT_ENTRY(6, Op0DZ),\n\tINT_ENTRY(6, Op0DF),\n\tINT_ENTRY(6, Op0DL),\n\tINT_ENTRY(6, Op0DU),\n\tINT_ENTRY(6, Op1DX),\n\tINT_ENTRY(6, Op1DY),\n\tINT_ENTRY(6, Op1DZ),\n\tINT_ENTRY(6, Op1DF),\n\tINT_ENTRY(6, Op1DL),\n\tINT_ENTRY(6, Op1DU),\n\tINT_ENTRY(6, Op2DX),\n\tINT_ENTRY(6, Op2DY),\n\tINT_ENTRY(6, Op2DZ),\n\tINT_ENTRY(6, Op2DF),\n\tINT_ENTRY(6, Op2DL),\n\tINT_ENTRY(6, Op2DU),\n\tINT_ENTRY(6, Op03F),\n\tINT_ENTRY(6, Op03L),\n\tINT_ENTRY(6, Op03U),\n\tINT_ENTRY(6, Op03X),\n\tINT_ENTRY(6, Op03Y),\n\tINT_ENTRY(6, Op03Z),\n\tINT_ENTRY(6, Op13F),\n\tINT_ENTRY(6, Op13L),\n\tINT_ENTRY(6, Op13U),\n\tINT_ENTRY(6, Op13X),\n\tINT_ENTRY(6, Op13Y),\n\tINT_ENTRY(6, Op13Z),\n\tINT_ENTRY(6, Op23F),\n\tINT_ENTRY(6, Op23L),\n\tINT_ENTRY(6, Op23U),\n\tINT_ENTRY(6, Op23X),\n\tINT_ENTRY(6, Op23Y),\n\tINT_ENTRY(6, Op23Z),\n\tINT_ENTRY(6, Op14Zr),\n\tINT_ENTRY(6, Op14Xr),\n\tINT_ENTRY(6, Op14Yr),\n\tINT_ENTRY(6, Op14U),\n\tINT_ENTRY(6, Op14F),\n\tINT_ENTRY(6, Op14L),\n\tINT_ENTRY(6, Op14Zrr),\n\tINT_ENTRY(6, Op14Xrr),\n\tINT_ENTRY(6, Op14Yrr),\n\tINT_ENTRY(6, Op0EH),\n\tINT_ENTRY(6, Op0EV),\n\tINT_ENTRY(6, Op0EX),\n\tINT_ENTRY(6, Op0EY),\n\tINT_ENTRY(6, Op0BX),\n\tINT_ENTRY(6, Op0BY),\n\tINT_ENTRY(6, Op0BZ),\n\tINT_ENTRY(6, Op0BS),\n\tINT_ENTRY(6, Op1BX),\n\tINT_ENTRY(6, Op1BY),\n\tINT_ENTRY(6, Op1BZ),\n\tINT_ENTRY(6, Op1BS),\n\tINT_ENTRY(6, Op2BX),\n\tINT_ENTRY(6, Op2BY),\n\tINT_ENTRY(6, Op2BZ),\n\tINT_ENTRY(6, Op2BS),\n\tINT_ENTRY(6, Op28X),\n\tINT_ENTRY(6, Op28Y),\n\tINT_ENTRY(6, Op28Z),\n\tINT_ENTRY(6, Op28R),\n\tINT_ENTRY(6, Op1CX),\n\tINT_ENTRY(6, Op1CY),\n\tINT_ENTRY(6, Op1CZ),\n\tINT_ENTRY(6, Op1CXBR),\n\tINT_ENTRY(6, Op1CYBR),\n\tINT_ENTRY(6, Op1CZBR),\n\tINT_ENTRY(6, Op1CXAR),\n\tINT_ENTRY(6, Op1CYAR),\n\tINT_ENTRY(6, Op1CZAR),\n\tINT_ENTRY(6, Op1CX1),\n\tINT_ENTRY(6, Op1CY1),\n\tINT_ENTRY(6, Op1CZ1),\n\tINT_ENTRY(6, Op1CX2),\n\tINT_ENTRY(6, Op1CY2),\n\tINT_ENTRY(6, Op1CZ2),\n\tINT_ENTRY(6, Op0FRamsize),\n\tINT_ENTRY(6, Op0FPass),\n\tINT_ENTRY(6, Op2FUnknown),\n\tINT_ENTRY(6, Op2FSize),\n\tINT_ENTRY(6, Op08X),\n\tINT_ENTRY(6, Op08Y),\n\tINT_ENTRY(6, Op08Z),\n\tINT_ENTRY(6, Op08Ll),\n\tINT_ENTRY(6, Op08Lh),\n\tINT_ENTRY(6, Op18X),\n\tINT_ENTRY(6, Op18Y),\n\tINT_ENTRY(6, Op18Z),\n\tINT_ENTRY(6, Op18R),\n\tINT_ENTRY(6, Op18D),\n\tINT_ENTRY(6, Op38X),\n\tINT_ENTRY(6, Op38Y),\n\tINT_ENTRY(6, Op38Z),\n\tINT_ENTRY(6, Op38R),\n\tINT_ENTRY(6, Op38D)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SDSP2\n\nstatic FreezeData\tSnapDSP2[] =\n{\n\tINT_ENTRY(6, waiting4command),\n\tINT_ENTRY(6, command),\n\tINT_ENTRY(6, in_count),\n\tINT_ENTRY(6, in_index),\n\tINT_ENTRY(6, out_count),\n\tINT_ENTRY(6, out_index),\n\tARRAY_ENTRY(6, parameters, 512, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, output, 512, uint8_ARRAY_V),\n\tINT_ENTRY(6, Op05HasLen),\n\tINT_ENTRY(6, Op05Len),\n\tINT_ENTRY(6, Op05Transparent),\n\tINT_ENTRY(6, Op06HasLen),\n\tINT_ENTRY(6, Op06Len),\n\tINT_ENTRY(6, Op09Word1),\n\tINT_ENTRY(6, Op09Word2),\n\tINT_ENTRY(6, Op0DHasLen),\n\tINT_ENTRY(6, Op0DOutLen),\n\tINT_ENTRY(6, Op0DInLen)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SDSP4\n\nstatic FreezeData\tSnapDSP4[] =\n{\n\tINT_ENTRY(6, waiting4command),\n\tINT_ENTRY(6, half_command),\n\tINT_ENTRY(6, command),\n\tINT_ENTRY(6, in_count),\n\tINT_ENTRY(6, in_index),\n\tINT_ENTRY(6, out_count),\n\tINT_ENTRY(6, out_index),\n\tARRAY_ENTRY(6, parameters, 512, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, output, 512, uint8_ARRAY_V),\n\tINT_ENTRY(6, byte),\n\tINT_ENTRY(6, address),\n\tINT_ENTRY(6, Logic),\n\tINT_ENTRY(6, lcv),\n\tINT_ENTRY(6, distance),\n\tINT_ENTRY(6, raster),\n\tINT_ENTRY(6, segments),\n\tINT_ENTRY(6, world_x),\n\tINT_ENTRY(6, world_y),\n\tINT_ENTRY(6, world_dx),\n\tINT_ENTRY(6, world_dy),\n\tINT_ENTRY(6, world_ddx),\n\tINT_ENTRY(6, world_ddy),\n\tINT_ENTRY(6, world_xenv),\n\tINT_ENTRY(6, world_yofs),\n\tINT_ENTRY(6, view_x1),\n\tINT_ENTRY(6, view_y1),\n\tINT_ENTRY(6, view_x2),\n\tINT_ENTRY(6, view_y2),\n\tINT_ENTRY(6, view_dx),\n\tINT_ENTRY(6, view_dy),\n\tINT_ENTRY(6, view_xofs1),\n\tINT_ENTRY(6, view_yofs1),\n\tINT_ENTRY(6, view_xofs2),\n\tINT_ENTRY(6, view_yofs2),\n\tINT_ENTRY(6, view_yofsenv),\n\tINT_ENTRY(6, view_turnoff_x),\n\tINT_ENTRY(6, view_turnoff_dx),\n\tINT_ENTRY(6, viewport_cx),\n\tINT_ENTRY(6, viewport_cy),\n\tINT_ENTRY(6, viewport_left),\n\tINT_ENTRY(6, viewport_right),\n\tINT_ENTRY(6, viewport_top),\n\tINT_ENTRY(6, viewport_bottom),\n\tINT_ENTRY(6, sprite_x),\n\tINT_ENTRY(6, sprite_y),\n\tINT_ENTRY(6, sprite_attr),\n\tINT_ENTRY(6, sprite_size),\n\tINT_ENTRY(6, sprite_clipy),\n\tINT_ENTRY(6, sprite_count),\n#define O(N) \\\n\tARRAY_ENTRY(6, poly_clipLf[N], 2, uint16_ARRAY_V), \\\n\tARRAY_ENTRY(6, poly_clipRt[N], 2, uint16_ARRAY_V), \\\n\tARRAY_ENTRY(6, poly_ptr[N], 2, uint16_ARRAY_V), \\\n\tARRAY_ENTRY(6, poly_raster[N], 2, uint16_ARRAY_V), \\\n\tARRAY_ENTRY(6, poly_top[N], 2, uint16_ARRAY_V), \\\n\tARRAY_ENTRY(6, poly_bottom[N], 2, uint16_ARRAY_V), \\\n\tARRAY_ENTRY(6, poly_cx[N], 2, uint16_ARRAY_V)\n\tO(0), O(1),\n#undef O\n\tARRAY_ENTRY(6, poly_start, 2, uint16_ARRAY_V),\n\tARRAY_ENTRY(6, poly_plane, 2, uint16_ARRAY_V),\n\tARRAY_ENTRY(6, OAM_attr, 16, uint16_ARRAY_V),\n\tINT_ENTRY(6, OAM_index),\n\tINT_ENTRY(6, OAM_bits),\n\tINT_ENTRY(6, OAM_RowMax),\n\tARRAY_ENTRY(6, OAM_Row, 32, uint16_ARRAY_V)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SST010\n\nstatic FreezeData\tSnapST010[] =\n{\n\tARRAY_ENTRY(6, input_params, 16, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, output_params, 16, uint8_ARRAY_V),\n\tINT_ENTRY(6, op_reg),\n\tINT_ENTRY(6, execute),\n\tINT_ENTRY(6, control_enable)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SOBC1\n\nstatic FreezeData\tSnapOBC1[] =\n{\n\tINT_ENTRY(6, address),\n\tINT_ENTRY(6, basePtr),\n\tINT_ENTRY(6, shift)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SSPC7110Snapshot\n\nstatic FreezeData\tSnapSPC7110Snap[] =\n{\n\tINT_ENTRY(6, r4801),\n\tINT_ENTRY(6, r4802),\n\tINT_ENTRY(6, r4803),\n\tINT_ENTRY(6, r4804),\n\tINT_ENTRY(6, r4805),\n\tINT_ENTRY(6, r4806),\n\tINT_ENTRY(6, r4807),\n\tINT_ENTRY(6, r4808),\n\tINT_ENTRY(6, r4809),\n\tINT_ENTRY(6, r480a),\n\tINT_ENTRY(6, r480b),\n\tINT_ENTRY(6, r480c),\n\tINT_ENTRY(6, r4811),\n\tINT_ENTRY(6, r4812),\n\tINT_ENTRY(6, r4813),\n\tINT_ENTRY(6, r4814),\n\tINT_ENTRY(6, r4815),\n\tINT_ENTRY(6, r4816),\n\tINT_ENTRY(6, r4817),\n\tINT_ENTRY(6, r4818),\n\tINT_ENTRY(6, r481x),\n\tINT_ENTRY(6, r4814_latch),\n\tINT_ENTRY(6, r4815_latch),\n\tINT_ENTRY(6, r4820),\n\tINT_ENTRY(6, r4821),\n\tINT_ENTRY(6, r4822),\n\tINT_ENTRY(6, r4823),\n\tINT_ENTRY(6, r4824),\n\tINT_ENTRY(6, r4825),\n\tINT_ENTRY(6, r4826),\n\tINT_ENTRY(6, r4827),\n\tINT_ENTRY(6, r4828),\n\tINT_ENTRY(6, r4829),\n\tINT_ENTRY(6, r482a),\n\tINT_ENTRY(6, r482b),\n\tINT_ENTRY(6, r482c),\n\tINT_ENTRY(6, r482d),\n\tINT_ENTRY(6, r482e),\n\tINT_ENTRY(6, r482f),\n\tINT_ENTRY(6, r4830),\n\tINT_ENTRY(6, r4831),\n\tINT_ENTRY(6, r4832),\n\tINT_ENTRY(6, r4833),\n\tINT_ENTRY(6, r4834),\n\tINT_ENTRY(6, dx_offset),\n\tINT_ENTRY(6, ex_offset),\n\tINT_ENTRY(6, fx_offset),\n\tINT_ENTRY(6, r4840),\n\tINT_ENTRY(6, r4841),\n\tINT_ENTRY(6, r4842),\n\tINT_ENTRY(6, rtc_state),\n\tINT_ENTRY(6, rtc_mode),\n\tINT_ENTRY(6, rtc_index),\n\tINT_ENTRY(6, decomp_mode),\n\tINT_ENTRY(6, decomp_offset),\n\tARRAY_ENTRY(6, decomp_buffer, SPC7110_DECOMP_BUFFER_SIZE, uint8_ARRAY_V),\n\tINT_ENTRY(6, decomp_buffer_rdoffset),\n\tINT_ENTRY(6, decomp_buffer_wroffset),\n\tINT_ENTRY(6, decomp_buffer_length),\n#define O(N) \\\n\tINT_ENTRY(6, context[N].index), \\\n\tINT_ENTRY(6, context[N].invert)\n\tO(  0), O(  1), O(  2), O(  3), O(  4), O(  5), O(  6), O(  7),\n\tO(  8), O(  9), O( 10), O( 11), O( 12), O( 13), O( 14), O( 15),\n\tO( 16), O( 17), O( 18), O( 19), O( 20), O( 21), O( 22), O( 23),\n\tO( 24), O( 25), O( 26), O( 27), O( 28), O( 29), O( 30), O( 31)\n#undef O\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SSRTCSnapshot\n\nstatic FreezeData\tSnapSRTCSnap[] =\n{\n\tINT_ENTRY(6, rtc_mode),\n\tINT_ENTRY(6, rtc_index)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SBSX\n\nstatic FreezeData\tSnapBSX[] =\n{\n\tINT_ENTRY(6, dirty),\n\tINT_ENTRY(6, dirty2),\n\tINT_ENTRY(6, bootup),\n\tINT_ENTRY(6, flash_enable),\n\tINT_ENTRY(6, write_enable),\n\tINT_ENTRY(6, read_enable),\n\tINT_ENTRY(6, flash_command),\n\tINT_ENTRY(6, old_write),\n\tINT_ENTRY(6, new_write),\n\tINT_ENTRY(6, out_index),\n\tARRAY_ENTRY(6, output, 32, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, PPU, 32, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, MMC, 16, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, prevMMC, 16, uint8_ARRAY_V),\n\tARRAY_ENTRY(6, test2192, 32, uint8_ARRAY_V)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SMSU1\n\nstatic FreezeData\tSnapMSU1[] =\n{\n\tINT_ENTRY(9, MSU1_STATUS),\n\tINT_ENTRY(9, MSU1_DATA_SEEK),\n\tINT_ENTRY(9, MSU1_DATA_POS),\n\tINT_ENTRY(9, MSU1_TRACK_SEEK),\n\tINT_ENTRY(9, MSU1_CURRENT_TRACK),\n\tINT_ENTRY(9, MSU1_RESUME_TRACK),\n\tINT_ENTRY(9, MSU1_VOLUME),\n\tINT_ENTRY(9, MSU1_CONTROL),\n\tINT_ENTRY(9, MSU1_AUDIO_POS),\n\tINT_ENTRY(9, MSU1_RESUME_POS)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SnapshotScreenshotInfo\n\nstatic FreezeData\tSnapScreenshot[] =\n{\n\tINT_ENTRY(6, Width),\n\tINT_ENTRY(6, Height),\n\tINT_ENTRY(6, Interlaced),\n\tARRAY_ENTRY(6, Data, MAX_SNES_WIDTH * MAX_SNES_HEIGHT * 3, uint8_ARRAY_V)\n};\n\n#undef STRUCT\n#define STRUCT\tstruct SnapshotMovieInfo\n\nstatic FreezeData\tSnapMovie[] =\n{\n\tINT_ENTRY(6, MovieInputDataSize)\n};\n\nstatic int UnfreezeBlock (STREAM, const char *, uint8 *, int);\nstatic int UnfreezeBlockCopy (STREAM, const char *, uint8 **, int);\nstatic int UnfreezeStruct (STREAM, const char *, void *, FreezeData *, int, int);\nstatic int UnfreezeStructCopy (STREAM, const char *, uint8 **, FreezeData *, int, int);\nstatic void UnfreezeStructFromCopy (void *, FreezeData *, int, uint8 *, int);\nstatic void FreezeBlock (STREAM, const char *, uint8 *, int);\nstatic void FreezeStruct (STREAM, const char *, void *, FreezeData *, int);\nstatic bool CheckBlockName(STREAM stream, const char *name, int &len);\nstatic void SkipBlockWithName(STREAM stream, const char *name);\n\n\nvoid S9xResetSaveTimer (bool8 dontsave)\n{\n\tstatic time_t\tt = -1;\n\n\tif (!Settings.DontSaveOopsSnapshot && !dontsave && t != -1 && time(NULL) - t > 300)\n\t{\n\t\tauto filename = S9xGetFilename(\"oops\", SNAPSHOT_DIR);\n\t\tS9xMessage(S9X_INFO, S9X_FREEZE_FILE_INFO, SAVE_INFO_OOPS);\n\t\tS9xFreezeGame(filename.c_str());\n\t}\n\n\tt = time(NULL);\n}\n\nuint32 S9xFreezeSize()\n{\n    nulStream stream;\n    S9xFreezeToStream(&stream);\n    return stream.size();\n}\n\nbool8 S9xFreezeGameMem (uint8 *buf, uint32 bufSize)\n{\n    memStream mStream(buf, bufSize);\n\tS9xFreezeToStream(&mStream);\n\n\treturn (TRUE);\n}\n\nbool8 S9xFreezeGame (const char *filename)\n{\n\tSTREAM\tstream = NULL;\n\n\tif (S9xOpenSnapshotFile(filename, FALSE, &stream))\n\t{\n\t\tS9xFreezeToStream(stream);\n\t\tS9xCloseSnapshotFile(stream);\n\n\t\tS9xResetSaveTimer(TRUE);\n\n\t\tauto base = S9xBasename(filename);\n\t\tif (S9xMovieActive())\n\t\t\tsprintf(String, MOVIE_INFO_SNAPSHOT \" %s\", base.c_str());\n\t\telse\n\t\t\tsprintf(String, SAVE_INFO_SNAPSHOT \" %s\", base.c_str());\n\n\t\tS9xMessage(S9X_INFO, S9X_FREEZE_FILE_INFO, String);\n\n\t\treturn (TRUE);\n\t}\n\n\treturn (FALSE);\n}\n\nint S9xUnfreezeGameMem (const uint8 *buf, uint32 bufSize)\n{\n    memStream stream(buf, bufSize);\n\tint result = S9xUnfreezeFromStream(&stream);\n\n\treturn result;\n}\n\nvoid S9xMessageFromResult(int result, const char* base)\n{\n    switch(result)\n    {\n        case WRONG_FORMAT:\n            S9xMessage(S9X_ERROR, S9X_WRONG_FORMAT, SAVE_ERR_WRONG_FORMAT);\n            break;\n\n        case WRONG_VERSION:\n            S9xMessage(S9X_ERROR, S9X_WRONG_VERSION, SAVE_ERR_WRONG_VERSION);\n            break;\n\n        case WRONG_MOVIE_SNAPSHOT:\n            S9xMessage(S9X_ERROR, S9X_WRONG_MOVIE_SNAPSHOT, MOVIE_ERR_SNAPSHOT_WRONG_MOVIE);\n            break;\n\n        case NOT_A_MOVIE_SNAPSHOT:\n            S9xMessage(S9X_ERROR, S9X_NOT_A_MOVIE_SNAPSHOT, MOVIE_ERR_SNAPSHOT_NOT_MOVIE);\n            break;\n\n        case SNAPSHOT_INCONSISTENT:\n            S9xMessage(S9X_ERROR, S9X_SNAPSHOT_INCONSISTENT, MOVIE_ERR_SNAPSHOT_INCONSISTENT);\n            break;\n\n        case FILE_NOT_FOUND:\n        default:\n            sprintf(String, SAVE_ERR_ROM_NOT_FOUND, base);\n            S9xMessage(S9X_ERROR, S9X_ROM_NOT_FOUND, String);\n            break;\n    }\n}\n\nbool8 S9xUnfreezeGame (const char *filename)\n{\n\tSTREAM\tstream = NULL;\n\n\tauto base = S9xBasename(filename);\n\tauto path = splitpath(filename);\n\tS9xResetSaveTimer(path.ext_is(\".oops\") || path.ext_is(\".oop\"));\n\n\tif (S9xOpenSnapshotFile(filename, TRUE, &stream))\n\t{\n\t\tint\tresult;\n\n\t\tresult = S9xUnfreezeFromStream(stream);\n\t\tS9xCloseSnapshotFile(stream);\n\n\t\tif (result != SUCCESS)\n\t\t{\n            S9xMessageFromResult(result, base.c_str());\n\t\t\treturn (FALSE);\n\t\t}\n\n\t\tif (S9xMovieActive())\n\t\t{\n\t\t\tif (S9xMovieReadOnly())\n\t\t\t\tsprintf(String, MOVIE_INFO_REWIND \" %s\", base.c_str());\n\t\t\telse\n\t\t\t\tsprintf(String, MOVIE_INFO_RERECORD \" %s\", base.c_str());\n\t\t}\n\t\telse\n\t\t\tsprintf(String, SAVE_INFO_LOAD \" %s\", base.c_str());\n\n\t\tS9xMessage(S9X_INFO, S9X_FREEZE_FILE_INFO, String);\n\n\t\treturn (TRUE);\n\t}\n\n\tsprintf(String, SAVE_ERR_SAVE_NOT_FOUND, base.c_str());\n\tS9xMessage(S9X_INFO, S9X_FREEZE_FILE_INFO, String);\n\n\treturn (FALSE);\n}\n\nbool8 S9xUnfreezeScreenshot(const char *filename, uint16 **image_buffer, int &width, int &height)\n{\n    STREAM\tstream = NULL;\n\n    auto base = S9xBasename(filename);\n\n    if(S9xOpenSnapshotFile(filename, TRUE, &stream))\n    {\n        int\tresult;\n\n        result = S9xUnfreezeScreenshotFromStream(stream, image_buffer, width, height);\n        S9xCloseSnapshotFile(stream);\n\n        if(result != SUCCESS)\n        {\n            S9xMessageFromResult(result, base.c_str());\n            return (FALSE);\n        }\n\n        return (TRUE);\n    }\n\n    sprintf(String, SAVE_ERR_SAVE_NOT_FOUND, base.c_str());\n    S9xMessage(S9X_INFO, S9X_FREEZE_FILE_INFO, String);\n\n    return (FALSE);\n}\n\nvoid S9xFreezeToStream (STREAM stream)\n{\n\tchar\tbuffer[8192];\n\tuint8\t*soundsnapshot = new uint8[SPC_SAVE_STATE_BLOCK_SIZE];\n\n\tsprintf(buffer, \"%s:%04d\\n\", SNAPSHOT_MAGIC, SNAPSHOT_VERSION);\n\tWRITE_STREAM(buffer, strlen(buffer), stream);\n\n\tsprintf(buffer, \"NAM:%06d:%s%c\", 8, \"Removed\", 0);\n\tWRITE_STREAM(buffer, strlen(buffer) + 1, stream);\n\n\tFreezeStruct(stream, \"CPU\", &CPU, SnapCPU, COUNT(SnapCPU));\n\n\tFreezeStruct(stream, \"REG\", &Registers, SnapRegisters, COUNT(SnapRegisters));\n\n\tFreezeStruct(stream, \"PPU\", &PPU, SnapPPU, COUNT(SnapPPU));\n\n\tstruct SDMASnapshot\tdma_snap;\n\tfor (int d = 0; d < 8; d++)\n\t\tdma_snap.dma[d] = DMA[d];\n\tFreezeStruct(stream, \"DMA\", &dma_snap, SnapDMA, COUNT(SnapDMA));\n\n\tFreezeBlock (stream, \"VRA\", Memory.VRAM, sizeof(Memory.VRAM));\n\n\tFreezeBlock (stream, \"RAM\", Memory.RAM, sizeof(Memory.RAM));\n\n\tFreezeBlock (stream, \"SRA\", Memory.SRAM, Memory.SRAM_SIZE);\n\n\tFreezeBlock (stream, \"FIL\", Memory.FillRAM, 0x8000);\n\n\tS9xAPUSaveState(soundsnapshot);\n\tFreezeBlock (stream, \"SND\", soundsnapshot, SPC_SAVE_STATE_BLOCK_SIZE);\n\n\tstruct SControlSnapshot\tctl_snap;\n\tS9xControlPreSaveState(&ctl_snap);\n\tFreezeStruct(stream, \"CTL\", &ctl_snap, SnapControls, COUNT(SnapControls));\n\n\tTimings.InterlaceField = S9xInterlaceField();\n\tFreezeStruct(stream, \"TIM\", &Timings, SnapTimings, COUNT(SnapTimings));\n\n\tif (Settings.SuperFX)\n\t{\n\t\tGSU.avRegAddr = (uint8 *) &GSU.avReg;\n\t\tFreezeStruct(stream, \"SFX\", &GSU, SnapFX, COUNT(SnapFX));\n\t}\n\n\tif (Settings.SA1)\n\t{\n\t\tS9xSA1PackStatus();\n\t\tFreezeStruct(stream, \"SA1\", &SA1, SnapSA1, COUNT(SnapSA1));\n\t\tFreezeStruct(stream, \"SAR\", &SA1Registers, SnapSA1Registers, COUNT(SnapSA1Registers));\n\t}\n\n\tif (Settings.DSP == 1)\n\t\tFreezeStruct(stream, \"DP1\", &DSP1, SnapDSP1, COUNT(SnapDSP1));\n\n\tif (Settings.DSP == 2)\n\t\tFreezeStruct(stream, \"DP2\", &DSP2, SnapDSP2, COUNT(SnapDSP2));\n\n\tif (Settings.DSP == 4)\n\t\tFreezeStruct(stream, \"DP4\", &DSP4, SnapDSP4, COUNT(SnapDSP4));\n\n\tif (Settings.C4)\n\t\tFreezeBlock (stream, \"CX4\", Memory.C4RAM, 8192);\n\n\tif (Settings.SETA == ST_010)\n\t\tFreezeStruct(stream, \"ST0\", &ST010, SnapST010, COUNT(SnapST010));\n\n\tif (Settings.OBC1)\n\t{\n\t\tFreezeStruct(stream, \"OBC\", &OBC1, SnapOBC1, COUNT(SnapOBC1));\n\t\tFreezeBlock (stream, \"OBM\", Memory.OBC1RAM, 8192);\n\t}\n\n\tif (Settings.SPC7110)\n\t{\n\t\tS9xSPC7110PreSaveState();\n\t\tFreezeStruct(stream, \"S71\", &s7snap, SnapSPC7110Snap, COUNT(SnapSPC7110Snap));\n\t}\n\n\tif (Settings.SRTC)\n\t{\n\t\tS9xSRTCPreSaveState();\n\t\tFreezeStruct(stream, \"SRT\", &srtcsnap, SnapSRTCSnap, COUNT(SnapSRTCSnap));\n\t}\n\n\tif (Settings.SRTC || Settings.SPC7110RTC)\n\t\tFreezeBlock (stream, \"CLK\", RTCData.reg, 20);\n\n\tif (Settings.BS)\n\t\tFreezeStruct(stream, \"BSX\", &BSX, SnapBSX, COUNT(SnapBSX));\n\n\tif (Settings.MSU1)\n\t\tFreezeStruct(stream, \"MSU\", &MSU1, SnapMSU1, COUNT(SnapMSU1));\n\n\tif (Settings.SnapshotScreenshots)\n\t{\n\t\tSnapshotScreenshotInfo\t*ssi = new SnapshotScreenshotInfo;\n\n\t\tssi->Width  = min(IPPU.RenderedScreenWidth,  MAX_SNES_WIDTH);\n\t\tssi->Height = min(IPPU.RenderedScreenHeight, MAX_SNES_HEIGHT);\n\t\tssi->Interlaced = GFX.DoInterlace;\n\n\t\tuint8\t*rowpix = ssi->Data;\n\t\tuint16\t*screen = GFX.Screen;\n\n\t\tfor (int y = 0; y < ssi->Height; y++, screen += GFX.RealPPL)\n\t\t{\n\t\t\tfor (int x = 0; x < ssi->Width; x++)\n\t\t\t{\n\t\t\t\tuint32\tr, g, b;\n\n\t\t\t\tDECOMPOSE_PIXEL(screen[x], r, g, b);\n\t\t\t\t*(rowpix++) = r;\n\t\t\t\t*(rowpix++) = g;\n\t\t\t\t*(rowpix++) = b;\n\t\t\t}\n\t\t}\n\n\t\tmemset(rowpix, 0, sizeof(ssi->Data) + ssi->Data - rowpix);\n\n\t\tFreezeStruct(stream, \"SHO\", ssi, SnapScreenshot, COUNT(SnapScreenshot));\n\n\t\tdelete ssi;\n\t}\n\n\tif (S9xMovieActive())\n\t{\n\t\tuint8\t*movie_freeze_buf;\n\t\tuint32\tmovie_freeze_size;\n\n\t\tS9xMovieFreeze(&movie_freeze_buf, &movie_freeze_size);\n\t\tif (movie_freeze_buf)\n\t\t{\n\t\t\tstruct SnapshotMovieInfo mi;\n\n\t\t\tmi.MovieInputDataSize = movie_freeze_size;\n\t\t\tFreezeStruct(stream, \"MOV\", &mi, SnapMovie, COUNT(SnapMovie));\n\t\t\tFreezeBlock (stream, \"MID\", movie_freeze_buf, movie_freeze_size);\n\n\t\t\tdelete [] movie_freeze_buf;\n\t\t}\n\t}\n\n\tdelete [] soundsnapshot;\n}\n\nint S9xUnfreezeFromStream (STREAM stream)\n{\n\tconst bool8 fast = Settings.FastSavestates;\n\n\tint\t\tresult = SUCCESS;\n\tint\t\tversion, len;\n\tchar\tbuffer[PATH_MAX + 1];\n\n\tlen = strlen(SNAPSHOT_MAGIC) + 1 + 4 + 1;\n\tif (READ_STREAM(buffer, len, stream) != (unsigned int ) len)\n\t\treturn (WRONG_FORMAT);\n\n\tif (strncmp(buffer, SNAPSHOT_MAGIC, strlen(SNAPSHOT_MAGIC)) != 0)\n\t\treturn (WRONG_FORMAT);\n\n\tversion = atoi(&buffer[strlen(SNAPSHOT_MAGIC) + 1]);\n\tif (version > SNAPSHOT_VERSION)\n\t\treturn (WRONG_VERSION);\n\n\tresult = UnfreezeBlock(stream, \"NAM\", (uint8 *) buffer, PATH_MAX);\n\tif (result != SUCCESS)\n\t\treturn (result);\n\n\tuint8\t*local_cpu           = NULL;\n\tuint8\t*local_registers     = NULL;\n\tuint8\t*local_ppu           = NULL;\n\tuint8\t*local_dma           = NULL;\n\tuint8\t*local_vram          = NULL;\n\tuint8\t*local_ram           = NULL;\n\tuint8\t*local_sram          = NULL;\n\tuint8\t*local_fillram       = NULL;\n\tuint8\t*local_apu_sound     = NULL;\n\tuint8\t*local_control_data  = NULL;\n\tuint8\t*local_timing_data   = NULL;\n\tuint8\t*local_superfx       = NULL;\n\tuint8\t*local_sa1           = NULL;\n\tuint8\t*local_sa1_registers = NULL;\n\tuint8\t*local_dsp1          = NULL;\n\tuint8\t*local_dsp2          = NULL;\n\tuint8\t*local_dsp4          = NULL;\n\tuint8\t*local_cx4_data      = NULL;\n\tuint8\t*local_st010         = NULL;\n\tuint8\t*local_obc1          = NULL;\n\tuint8\t*local_obc1_data     = NULL;\n\tuint8\t*local_spc7110       = NULL;\n\tuint8\t*local_srtc          = NULL;\n\tuint8\t*local_rtc_data      = NULL;\n\tuint8\t*local_bsx_data      = NULL;\n\tuint8\t*local_msu1_data     = NULL;\n\tuint8\t*local_screenshot    = NULL;\n\tuint8\t*local_movie_data    = NULL;\n\n\tdo\n\t{\n\t\tresult = UnfreezeStructCopy(stream, \"CPU\", &local_cpu, SnapCPU, COUNT(SnapCPU), version);\n\t\tif (result != SUCCESS)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"REG\", &local_registers, SnapRegisters, COUNT(SnapRegisters), version);\n\t\tif (result != SUCCESS)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"PPU\", &local_ppu, SnapPPU, COUNT(SnapPPU), version);\n\t\tif (result != SUCCESS)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"DMA\", &local_dma, SnapDMA, COUNT(SnapDMA), version);\n\t\tif (result != SUCCESS)\n\t\t\tbreak;\n\n\t\tif (fast)\n\t\t\tresult = UnfreezeBlock(stream, \"VRA\", Memory.VRAM, 0x10000);\n\t\telse\n\t\t\tresult = UnfreezeBlockCopy(stream, \"VRA\", &local_vram, 0x10000);\n\t\tif (result != SUCCESS)\n\t\t\tbreak;\n\n\t\tif (fast)\n\t\t\tresult = UnfreezeBlock(stream, \"RAM\", Memory.RAM, sizeof(Memory.RAM));\n\t\telse\n\t\t\tresult = UnfreezeBlockCopy(stream, \"RAM\", &local_ram, sizeof(Memory.RAM));\n\t\tif (result != SUCCESS)\n\t\t\tbreak;\n\n\t\tif (fast)\n\t\t\tresult = UnfreezeBlock(stream, \"SRA\", Memory.SRAM, Memory.SRAM_SIZE);\n\t\telse\n\t\t\tresult = UnfreezeBlockCopy (stream, \"SRA\", &local_sram, Memory.SRAM_SIZE);\n\t\tif (result != SUCCESS)\n\t\t\tbreak;\n\n\t\tif (fast)\n\t\t\tresult = UnfreezeBlock(stream, \"FIL\", Memory.FillRAM, 0x8000);\n\t\telse\n\t\t\tresult = UnfreezeBlockCopy(stream, \"FIL\", &local_fillram, 0x8000);\n\t\tif (result != SUCCESS)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeBlockCopy (stream, \"SND\", &local_apu_sound, SPC_SAVE_STATE_BLOCK_SIZE);\n\t\tif (result != SUCCESS)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"CTL\", &local_control_data, SnapControls, COUNT(SnapControls), version);\n\t\tif (result != SUCCESS)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"TIM\", &local_timing_data, SnapTimings, COUNT(SnapTimings), version);\n\t\tif (result != SUCCESS)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"SFX\", &local_superfx, SnapFX, COUNT(SnapFX), version);\n\t\tif (result != SUCCESS && Settings.SuperFX)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"SA1\", &local_sa1, SnapSA1, COUNT(SnapSA1), version);\n\t\tif (result != SUCCESS && Settings.SA1)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"SAR\", &local_sa1_registers, SnapSA1Registers, COUNT(SnapSA1Registers), version);\n\t\tif (result != SUCCESS && Settings.SA1)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"DP1\", &local_dsp1, SnapDSP1, COUNT(SnapDSP1), version);\n\t\tif (result != SUCCESS && Settings.DSP == 1)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"DP2\", &local_dsp2, SnapDSP2, COUNT(SnapDSP2), version);\n\t\tif (result != SUCCESS && Settings.DSP == 2)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"DP4\", &local_dsp4, SnapDSP4, COUNT(SnapDSP4), version);\n\t\tif (result != SUCCESS && Settings.DSP == 4)\n\t\t\tbreak;\n\n\t\tif (Settings.C4)\n\t\t{\n\t\t\tif (fast)\n\t\t\t\tresult = UnfreezeBlock(stream, \"CX4\", Memory.C4RAM, 8192);\n\t\t\telse\n\t\t\t\tresult = UnfreezeBlockCopy(stream, \"CX4\", &local_cx4_data, 8192);\n\t\t\tif (result != SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSkipBlockWithName(stream, \"CX4\");\n\t\t}\n\n\t\tresult = UnfreezeStructCopy(stream, \"ST0\", &local_st010, SnapST010, COUNT(SnapST010), version);\n\t\tif (result != SUCCESS && Settings.SETA == ST_010)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"OBC\", &local_obc1, SnapOBC1, COUNT(SnapOBC1), version);\n\t\tif (result != SUCCESS && Settings.OBC1)\n\t\t\tbreak;\n\n\t\tif (Settings.OBC1)\n\t\t{\n\t\t\tif (fast)\n\t\t\t\tresult = UnfreezeBlock(stream, \"OBM\", Memory.OBC1RAM, 8192);\n\t\t\telse\n\t\t\t\tresult = UnfreezeBlockCopy(stream, \"OBM\", &local_obc1_data, 8192);\n\t\t\tif (result != SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSkipBlockWithName(stream, \"OBM\");\n\t\t}\n\n\t\tresult = UnfreezeStructCopy(stream, \"S71\", &local_spc7110, SnapSPC7110Snap, COUNT(SnapSPC7110Snap), version);\n\t\tif (result != SUCCESS && Settings.SPC7110)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"SRT\", &local_srtc, SnapSRTCSnap, COUNT(SnapSRTCSnap), version);\n\t\tif (result != SUCCESS && Settings.SRTC)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeBlockCopy (stream, \"CLK\", &local_rtc_data, 20);\n\t\tif (result != SUCCESS && (Settings.SRTC || Settings.SPC7110RTC))\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"BSX\", &local_bsx_data, SnapBSX, COUNT(SnapBSX), version);\n\t\tif (result != SUCCESS && Settings.BS)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"MSU\", &local_msu1_data, SnapMSU1, COUNT(SnapMSU1), version);\n\t\tif (result != SUCCESS && Settings.MSU1)\n\t\t\tbreak;\n\n\t\tresult = UnfreezeStructCopy(stream, \"SHO\", &local_screenshot, SnapScreenshot, COUNT(SnapScreenshot), version);\n\n\t\tSnapshotMovieInfo\tmi;\n\n\t\tresult = UnfreezeStruct(stream, \"MOV\", &mi, SnapMovie, COUNT(SnapMovie), version);\n\t\tif (result != SUCCESS)\n\t\t{\n\t\t\tif (S9xMovieActive())\n\t\t\t{\n\t\t\t\tresult = NOT_A_MOVIE_SNAPSHOT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = UnfreezeBlockCopy(stream, \"MID\", &local_movie_data, mi.MovieInputDataSize);\n\t\t\tif (result != SUCCESS)\n\t\t\t{\n\t\t\t\tif (S9xMovieActive())\n\t\t\t\t{\n\t\t\t\t\tresult = NOT_A_MOVIE_SNAPSHOT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (S9xMovieActive())\n\t\t\t{\n\t\t\t\tresult = S9xMovieUnfreeze(local_movie_data, mi.MovieInputDataSize);\n\t\t\t\tif (result != SUCCESS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tresult = SUCCESS;\n\t} while (false);\n\n\tif (result == SUCCESS)\n\t{\n\t\tuint32 old_flags     = CPU.Flags;\n\t\tuint32 sa1_old_flags = SA1.Flags;\n\n\t\tif (fast)\n\t\t{\n\t\t\tS9xResetPPUFast();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Do not call this if you have written directly to \"Memory.\" arrays\n\t\t\tS9xReset();\n\t\t}\n\n\t\tUnfreezeStructFromCopy(&CPU, SnapCPU, COUNT(SnapCPU), local_cpu, version);\n\n\t\tUnfreezeStructFromCopy(&Registers, SnapRegisters, COUNT(SnapRegisters), local_registers, version);\n\n\t\tUnfreezeStructFromCopy(&PPU, SnapPPU, COUNT(SnapPPU), local_ppu, version);\n\n\t\tstruct SDMASnapshot\tdma_snap;\n\t\tUnfreezeStructFromCopy(&dma_snap, SnapDMA, COUNT(SnapDMA), local_dma, version);\n\n\t\tif (local_vram)\n\t\t\tmemcpy(Memory.VRAM, local_vram, 0x10000);\n\n\t\tif (local_ram)\n\t\t\tmemcpy(Memory.RAM, local_ram, 0x20000);\n\n\t\tif (local_sram)\n\t\t\tmemcpy(Memory.SRAM, local_sram, Memory.SRAM_SIZE);\n\n\t\tif (local_fillram)\n\t\t\tmemcpy(Memory.FillRAM, local_fillram, 0x8000);\n\n        if (version < SNAPSHOT_VERSION_BAPU)\n        {\n            printf(\"Using Blargg APU snapshot loading (snapshot version %d, current is %d)\\n...\", version, SNAPSHOT_VERSION);\n            S9xAPULoadBlarggState(local_apu_sound);\n        }\n        else if (version < 12)\n        {\n            printf(\"Adjusting old APU snapshot (snapshot version %d, current is %d)\\n\", version, SNAPSHOT_VERSION);\n            const size_t spc_block_size = 65700;\n            const size_t old_dsp_block_size = 514;\n            const size_t added_bytes_v12 = 128;\n            const size_t bytes_afterward = 16;\n            // Shift end to make room for extra 128 bytes\n            memmove(local_apu_sound + spc_block_size + old_dsp_block_size + added_bytes_v12,\n                    local_apu_sound + spc_block_size + old_dsp_block_size,\n                    bytes_afterward);\n            // Copy saved internal registers to external registers\n\t\t\tconst size_t new_dsp_registers_position = spc_block_size + 513;\n\n            memmove(local_apu_sound + new_dsp_registers_position,\n\t\t\t\t\tlocal_apu_sound + spc_block_size,\n\t\t\t\t\tadded_bytes_v12);\n            // the extra 0 byte between external registers and bytes_afterward is already present due to memset in S9xAPUSaveState\n\n            S9xAPULoadState(local_apu_sound);\n        }\n        else if (version >= 12)\n        {\n            S9xAPULoadState(local_apu_sound);\n        }\n\n        struct SControlSnapshot ctl_snap;\n        UnfreezeStructFromCopy(&ctl_snap, SnapControls, COUNT(SnapControls), local_control_data, version);\n\n        UnfreezeStructFromCopy(&Timings, SnapTimings, COUNT(SnapTimings), local_timing_data, version);\n\n\t\tif (local_superfx)\n\t\t{\n\t\t\tGSU.avRegAddr = (uint8 *) &GSU.avReg;\n\t\t\tUnfreezeStructFromCopy(&GSU, SnapFX, COUNT(SnapFX), local_superfx, version);\n\t\t}\n\n\t\tif (local_sa1)\n\t\t\tUnfreezeStructFromCopy(&SA1, SnapSA1, COUNT(SnapSA1), local_sa1, version);\n\n\t\tif (local_sa1_registers)\n\t\t\tUnfreezeStructFromCopy(&SA1Registers, SnapSA1Registers, COUNT(SnapSA1Registers), local_sa1_registers, version);\n\n\t\tif (local_dsp1)\n\t\t\tUnfreezeStructFromCopy(&DSP1, SnapDSP1, COUNT(SnapDSP1), local_dsp1, version);\n\n\t\tif (local_dsp2)\n\t\t\tUnfreezeStructFromCopy(&DSP2, SnapDSP2, COUNT(SnapDSP2), local_dsp2, version);\n\n\t\tif (local_dsp4)\n\t\t\tUnfreezeStructFromCopy(&DSP4, SnapDSP4, COUNT(SnapDSP4), local_dsp4, version);\n\n\t\tif (local_cx4_data)\n\t\t\tmemcpy(Memory.C4RAM, local_cx4_data, 8192);\n\n\t\tif (local_st010)\n\t\t\tUnfreezeStructFromCopy(&ST010, SnapST010, COUNT(SnapST010), local_st010, version);\n\n\t\tif (local_obc1)\n\t\t\tUnfreezeStructFromCopy(&OBC1, SnapOBC1, COUNT(SnapOBC1), local_obc1, version);\n\n\t\tif (local_obc1_data)\n\t\t\tmemcpy(Memory.OBC1RAM, local_obc1_data, 8192);\n\n\t\tif (local_spc7110)\n\t\t\tUnfreezeStructFromCopy(&s7snap, SnapSPC7110Snap, COUNT(SnapSPC7110Snap), local_spc7110, version);\n\n\t\tif (local_srtc)\n\t\t\tUnfreezeStructFromCopy(&srtcsnap, SnapSRTCSnap, COUNT(SnapSRTCSnap), local_srtc, version);\n\n\t\tif (local_rtc_data)\n\t\t\tmemcpy(RTCData.reg, local_rtc_data, 20);\n\n\t\tif (local_bsx_data)\n\t\t\tUnfreezeStructFromCopy(&BSX, SnapBSX, COUNT(SnapBSX), local_bsx_data, version);\n\n\t\tif (local_msu1_data)\n\t\t\tUnfreezeStructFromCopy(&MSU1, SnapMSU1, COUNT(SnapMSU1), local_msu1_data, version);\n\n\t\tif (version < SNAPSHOT_VERSION_IRQ)\n\t\t{\n\t\t\tprintf(\"Converting old snapshot version %d to %d\\n...\", version, SNAPSHOT_VERSION);\n\n\t\t\tCPU.NMIPending = (CPU.Flags & (1 <<  7)) ? TRUE : FALSE;\n\t\t\tCPU.IRQLine = (CPU.Flags & (1 << 11)) ? TRUE : FALSE;\n\t\t\tCPU.IRQTransition = FALSE;\n\t\t\tCPU.IRQLastState = FALSE;\n\t\t\tCPU.IRQExternal = (Obsolete.CPU_IRQActive & ~(1 << 1)) ? TRUE : FALSE;\n\n\t\t\tswitch (CPU.WhichEvent)\n\t\t\t{\n\t\t\t\tcase 12:\tcase   1:\tCPU.WhichEvent = 1; break;\n\t\t\t\tcase  2:\tcase   3:\tCPU.WhichEvent = 2; break;\n\t\t\t\tcase  4:\tcase   5:\tCPU.WhichEvent = 3; break;\n\t\t\t\tcase  6:\tcase   7:\tCPU.WhichEvent = 4; break;\n\t\t\t\tcase  8:\tcase   9:\tCPU.WhichEvent = 5; break;\n\t\t\t\tcase 10:\tcase  11:\tCPU.WhichEvent = 6; break;\n\t\t\t}\n\n\t\t\tif (local_sa1) // FIXME\n\t\t\t{\n\t\t\t\tSA1.Cycles = SA1.PrevCycles = 0;\n\t\t\t\tSA1.TimerIRQLastState = FALSE;\n\t\t\t\tSA1.HTimerIRQPos = Memory.FillRAM[0x2212] | (Memory.FillRAM[0x2213] << 8);\n\t\t\t\tSA1.VTimerIRQPos = Memory.FillRAM[0x2214] | (Memory.FillRAM[0x2215] << 8);\n\t\t\t\tSA1.HCounter = 0;\n\t\t\t\tSA1.VCounter = 0;\n\t\t\t\tSA1.PrevHCounter = 0;\n\t\t\t\tSA1.MemSpeed = ONE_CYCLE;\n\t\t\t\tSA1.MemSpeedx2 = ONE_CYCLE * 2;\n\t\t\t}\n\t\t}\n\n\t\tCPU.Flags |= old_flags & (DEBUG_MODE_FLAG | TRACE_FLAG | SINGLE_STEP_FLAG | FRAME_ADVANCE_FLAG);\n\t\tICPU.ShiftedPB = Registers.PB << 16;\n\t\tICPU.ShiftedDB = Registers.DB << 16;\n\t\tS9xSetPCBase(Registers.PBPC);\n\t\tS9xUnpackStatus();\n\t\tif(version < SNAPSHOT_VERSION_IRQ_2018)\n\t\t\tS9xUpdateIRQPositions(false); // calculate the new trigger pos from saved PPU data\n\t\tS9xFixCycles();\n\n\t\tfor (int d = 0; d < 8; d++)\n\t\t\tDMA[d] = dma_snap.dma[d];\n\t\t// TODO: these should already be correct since they are stored in the snapshot\n\t\tCPU.InDMA = CPU.InHDMA = FALSE;\n\t\tCPU.InDMAorHDMA = CPU.InWRAMDMAorHDMA = FALSE;\n\t\tCPU.HDMARanInDMA = 0;\n\n\t\tS9xFixColourBrightness();\n\t\tS9xBuildDirectColourMaps();\n\t\tIPPU.ColorsChanged = TRUE;\n\t\tIPPU.OBJChanged = TRUE;\n\t\tIPPU.RenderThisFrame = TRUE;\n\n\t\tGFX.DoInterlace = 0;\n\n\t\tS9xGraphicsScreenResize();\n\n\t\tif (Settings.FastSavestates == 0)\n\t\t\tmemset(GFX.Screen,0,GFX.Pitch * MAX_SNES_HEIGHT);\n\n\t\t// TODO: this seems to be a relic from 1.43 changes, completely remove if no issues in the future\n\t\t/*uint8 hdma_byte = Memory.FillRAM[0x420c];\n\t\tS9xSetCPU(hdma_byte, 0x420c);*/\n\n\t\tS9xControlPostLoadState(&ctl_snap);\n\n\t\tif (local_superfx)\n\t\t{\n\t\t\tGSU.pfPlot = fx_PlotTable[GSU.vMode];\n\t\t\tGSU.pfRpix = fx_PlotTable[GSU.vMode + 5];\n\t\t}\n\n\t\tif (local_sa1 && local_sa1_registers)\n\t\t{\n\t\t\tSA1.Flags |= sa1_old_flags & TRACE_FLAG;\n\t\t\tS9xSA1PostLoadState();\n\t\t}\n\n\t\tif (Settings.SDD1)\n\t\t\tS9xSDD1PostLoadState();\n\n\t\tif (local_spc7110)\n\t\t\tS9xSPC7110PostLoadState(version);\n\n\t\tif (local_srtc)\n\t\t\tS9xSRTCPostLoadState(version);\n\n\t\tif (local_bsx_data)\n\t\t\tS9xBSXPostLoadState();\n\n\t\tif (local_msu1_data)\n\t\t\tS9xMSU1PostLoadState();\n\n\t\tif (local_movie_data)\n\t\t{\n\t\t\t// restore last displayed pad_read status\n\t\t\textern bool8\tpad_read, pad_read_last;\n\t\t\tbool8\t\t\tpad_read_temp = pad_read;\n\n\t\t\tpad_read = pad_read_last;\n\t\t\tS9xUpdateFrameCounter(-1);\n\t\t\tpad_read = pad_read_temp;\n\t\t}\n\n\t\tif (local_screenshot)\n\t\t{\n\t\t\tSnapshotScreenshotInfo\t*ssi = new SnapshotScreenshotInfo;\n\n\t\t\tUnfreezeStructFromCopy(ssi, SnapScreenshot, COUNT(SnapScreenshot), local_screenshot, version);\n\n\t\t\tIPPU.RenderedScreenWidth  = min(ssi->Width,  MAX_SNES_WIDTH);\n\t\t\tIPPU.RenderedScreenHeight = min(ssi->Height, MAX_SNES_HEIGHT);\n\t\t\tconst bool8 scaleDownX = IPPU.RenderedScreenWidth  < ssi->Width;\n\t\t\tconst bool8 scaleDownY = IPPU.RenderedScreenHeight < ssi->Height && ssi->Height > SNES_HEIGHT_EXTENDED;\n\t\t\tGFX.DoInterlace = ssi->Interlaced;\n\n\t\t\tuint8\t*rowpix = ssi->Data;\n\t\t\tuint16\t*screen = GFX.Screen;\n\n\t\t\tfor (int y = 0; y < IPPU.RenderedScreenHeight; y++, screen += GFX.RealPPL)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < IPPU.RenderedScreenWidth; x++)\n\t\t\t\t{\n\t\t\t\t\tuint32\tr, g, b;\n\n\t\t\t\t\tr = *(rowpix++);\n\t\t\t\t\tg = *(rowpix++);\n\t\t\t\t\tb = *(rowpix++);\n\n\t\t\t\t\tif (scaleDownX)\n\t\t\t\t\t{\n\t\t\t\t\t\tr = (r + *(rowpix++)) >> 1;\n\t\t\t\t\t\tg = (g + *(rowpix++)) >> 1;\n\t\t\t\t\t\tb = (b + *(rowpix++)) >> 1;\n\n\t\t\t\t\t\tif (x + x + 1 >= ssi->Width)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tscreen[x] = BUILD_PIXEL(r, g, b);\n\t\t\t\t}\n\n\t\t\t\tif (scaleDownY)\n\t\t\t\t{\n\t\t\t\t\trowpix += 3 * ssi->Width;\n\t\t\t\t\tif (y + y + 1 >= ssi->Height)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// black out what we might have missed\n\t\t\tfor (uint32 y = IPPU.RenderedScreenHeight; y < (uint32) (MAX_SNES_HEIGHT); y++)\n\t\t\t\tmemset(GFX.Screen + y * GFX.RealPPL, 0, GFX.RealPPL * 2);\n\n\t\t\tdelete ssi;\n\t\t}\n\t}\n\n\tif (local_cpu)\t\t\t\tdelete [] local_cpu;\n\tif (local_registers)\t\tdelete [] local_registers;\n\tif (local_ppu)\t\t\t\tdelete [] local_ppu;\n\tif (local_dma)\t\t\t\tdelete [] local_dma;\n\tif (local_vram)\t\t\t\tdelete [] local_vram;\n\tif (local_ram)\t\t\t\tdelete [] local_ram;\n\tif (local_sram)\t\t\t\tdelete [] local_sram;\n\tif (local_fillram)\t\t\tdelete [] local_fillram;\n\tif (local_apu_sound)\t\tdelete [] local_apu_sound;\n\tif (local_control_data)\t\tdelete [] local_control_data;\n\tif (local_timing_data)\t\tdelete [] local_timing_data;\n\tif (local_superfx)\t\t\tdelete [] local_superfx;\n\tif (local_sa1)\t\t\t\tdelete [] local_sa1;\n\tif (local_sa1_registers)\tdelete [] local_sa1_registers;\n\tif (local_dsp1)\t\t\t\tdelete [] local_dsp1;\n\tif (local_dsp2)\t\t\t\tdelete [] local_dsp2;\n\tif (local_dsp4)\t\t\t\tdelete [] local_dsp4;\n\tif (local_cx4_data)\t\t\tdelete [] local_cx4_data;\n\tif (local_st010)\t\t\tdelete [] local_st010;\n\tif (local_obc1)\t\t\t\tdelete [] local_obc1;\n\tif (local_obc1_data)\t\tdelete [] local_obc1_data;\n\tif (local_spc7110)\t\t\tdelete [] local_spc7110;\n\tif (local_srtc)\t\t\t\tdelete [] local_srtc;\n\tif (local_rtc_data)\t\t\tdelete [] local_rtc_data;\n\tif (local_bsx_data)\t\t\tdelete [] local_bsx_data;\n\tif (local_screenshot)\t\tdelete [] local_screenshot;\n\tif (local_movie_data)\t\tdelete [] local_movie_data;\n\n\treturn (result);\n}\n\n// load screenshot from file, allocating memory for it\nint S9xUnfreezeScreenshotFromStream(STREAM stream, uint16 **image_buffer, int &width, int &height)\n{\n    int\t\tresult = SUCCESS;\n    int\t\tversion, len;\n    char\tbuffer[PATH_MAX + 1];\n\n    len = strlen(SNAPSHOT_MAGIC) + 1 + 4 + 1;\n    if(READ_STREAM(buffer, len, stream) != (unsigned int)len)\n        return (WRONG_FORMAT);\n\n    if(strncmp(buffer, SNAPSHOT_MAGIC, strlen(SNAPSHOT_MAGIC)) != 0)\n        return (WRONG_FORMAT);\n\n    version = atoi(&buffer[strlen(SNAPSHOT_MAGIC) + 1]);\n    if(version > SNAPSHOT_VERSION)\n        return (WRONG_VERSION);\n\n    result = UnfreezeBlock(stream, \"NAM\", (uint8 *)buffer, PATH_MAX);\n    if(result != SUCCESS)\n        return (result);\n\n    uint8\t*local_screenshot = NULL;\n\n    // skip all blocks until screenshot\n    SkipBlockWithName(stream, \"CPU\");\n    SkipBlockWithName(stream, \"REG\");\n    SkipBlockWithName(stream, \"PPU\");\n    SkipBlockWithName(stream, \"DMA\");\n    SkipBlockWithName(stream, \"VRA\");\n    SkipBlockWithName(stream, \"RAM\");\n    SkipBlockWithName(stream, \"SRA\");\n    SkipBlockWithName(stream, \"FIL\");\n    SkipBlockWithName(stream, \"SND\");\n    SkipBlockWithName(stream, \"CTL\");\n    SkipBlockWithName(stream, \"TIM\");\n    SkipBlockWithName(stream, \"SFX\");\n    SkipBlockWithName(stream, \"SA1\");\n    SkipBlockWithName(stream, \"SAR\");\n    SkipBlockWithName(stream, \"DP1\");\n    SkipBlockWithName(stream, \"DP2\");\n    SkipBlockWithName(stream, \"DP4\");\n    SkipBlockWithName(stream, \"CX4\");\n    SkipBlockWithName(stream, \"ST0\");\n    SkipBlockWithName(stream, \"OBC\");\n    SkipBlockWithName(stream, \"OBM\");\n    SkipBlockWithName(stream, \"S71\");\n    SkipBlockWithName(stream, \"SRT\");\n    SkipBlockWithName(stream, \"CLK\");\n    SkipBlockWithName(stream, \"BSX\");\n    SkipBlockWithName(stream, \"MSU\");\n    result = UnfreezeStructCopy(stream, \"SHO\", &local_screenshot, SnapScreenshot, COUNT(SnapScreenshot), version);\n\n\n    if(result == SUCCESS && local_screenshot)\n    {\n        SnapshotScreenshotInfo\t*ssi = new SnapshotScreenshotInfo;\n\n        UnfreezeStructFromCopy(ssi, SnapScreenshot, COUNT(SnapScreenshot), local_screenshot, version);\n\n        width = min(ssi->Width, MAX_SNES_WIDTH);\n        height = min(ssi->Height, MAX_SNES_HEIGHT);\n\n        *image_buffer = (uint16 *)malloc(width * height * sizeof(uint16));\n\n        uint8\t*rowpix = ssi->Data;\n        uint16\t*screen = (*image_buffer);\n\n        for(int y = 0; y < height; y++, screen += width)\n        {\n            for(int x = 0; x < width; x++)\n            {\n                uint32\tr, g, b;\n\n                r = *(rowpix++);\n                g = *(rowpix++);\n                b = *(rowpix++);\n\n                screen[x] = BUILD_PIXEL(r, g, b);\n            }\n        }\n\n        delete ssi;\n    }\n\n    if(local_screenshot)\t\tdelete[] local_screenshot;\n\n    return (result);\n}\n\nstatic int FreezeSize (int size, int type)\n{\n\tswitch (type)\n\t{\n\t\tcase uint32_ARRAY_V:\n\t\tcase uint32_INDIR_ARRAY_V:\n\t\t\treturn (size * 4);\n\n\t\tcase uint16_ARRAY_V:\n\t\tcase uint16_INDIR_ARRAY_V:\n\t\t\treturn (size * 2);\n\n\t\tdefault:\n\t\t\treturn (size);\n\t}\n}\n\nstatic void FreezeStruct (STREAM stream, const char *name, void *base, FreezeData *fields, int num_fields)\n{\n\tint\tlen = 0;\n\tint\ti, j;\n\n\tfor (i = 0; i < num_fields; i++)\n\t{\n\t\tif (SNAPSHOT_VERSION < fields[i].debuted_in)\n\t\t{\n\t\t\tfprintf(stderr, \"%s[%p]: field has bad debuted_in value %d, > %d.\", name, (void *) fields, fields[i].debuted_in, SNAPSHOT_VERSION);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (SNAPSHOT_VERSION < fields[i].deleted_in)\n\t\t\tlen += FreezeSize(fields[i].size, fields[i].type);\n\t}\n\n\tuint8\t*block = new uint8[len];\n\tuint8\t*ptr = block;\n\tuint8\t*addr;\n\tuint16\tword;\n\tuint32\tdword;\n\tint64\tqaword;\n\tint\t\trelativeAddr;\n\n\tfor (i = 0; i < num_fields; i++)\n\t{\n\t\tif (SNAPSHOT_VERSION >= fields[i].deleted_in || SNAPSHOT_VERSION < fields[i].debuted_in)\n\t\t\tcontinue;\n\n\t\taddr = (uint8 *) base + fields[i].offset;\n\n\t\t// determine real address of indirect-type fields\n\t\t// (where the structure contains a pointer to an array rather than the array itself)\n\t\tif (fields[i].type == uint8_INDIR_ARRAY_V || fields[i].type == uint16_INDIR_ARRAY_V || fields[i].type == uint32_INDIR_ARRAY_V)\n\t\t\taddr = (uint8 *) (*((pint *) addr));\n\n\t\t// convert pointer-type saves from absolute to relative pointers\n\t\tif (fields[i].type == POINTER_V)\n\t\t{\n\t\t\tuint8\t*pointer    = (uint8 *) *((pint *) ((uint8 *) base + fields[i].offset));\n\t\t\tuint8\t*relativeTo = (uint8 *) *((pint *) ((uint8 *) base + fields[i].offset2));\n\t\t\trelativeAddr = pointer - relativeTo;\n\t\t\taddr = (uint8 *) &relativeAddr;\n\t\t}\n\n\t\tswitch (fields[i].type)\n\t\t{\n\t\t\tcase INT_V:\n\t\t\tcase POINTER_V:\n\t\t\t\tswitch (fields[i].size)\n\t\t\t\t{\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t*ptr++ = *(addr);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tword = *((uint16 *) (addr));\n\t\t\t\t\t\t*ptr++ = (uint8) (word >> 8);\n\t\t\t\t\t\t*ptr++ = (uint8) word;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tdword = *((uint32 *) (addr));\n\t\t\t\t\t\t*ptr++ = (uint8) (dword >> 24);\n\t\t\t\t\t\t*ptr++ = (uint8) (dword >> 16);\n\t\t\t\t\t\t*ptr++ = (uint8) (dword >> 8);\n\t\t\t\t\t\t*ptr++ = (uint8) dword;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\tqaword = *((int64 *) (addr));\n\t\t\t\t\t\t*ptr++ = (uint8) (qaword >> 56);\n\t\t\t\t\t\t*ptr++ = (uint8) (qaword >> 48);\n\t\t\t\t\t\t*ptr++ = (uint8) (qaword >> 40);\n\t\t\t\t\t\t*ptr++ = (uint8) (qaword >> 32);\n\t\t\t\t\t\t*ptr++ = (uint8) (qaword >> 24);\n\t\t\t\t\t\t*ptr++ = (uint8) (qaword >> 16);\n\t\t\t\t\t\t*ptr++ = (uint8) (qaword >> 8);\n\t\t\t\t\t\t*ptr++ = (uint8) qaword;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase uint8_ARRAY_V:\n\t\t\tcase uint8_INDIR_ARRAY_V:\n\t\t\t\tmemmove(ptr, addr, fields[i].size);\n\t\t\t\tptr += fields[i].size;\n\n\t\t\t\tbreak;\n\n\t\t\tcase uint16_ARRAY_V:\n\t\t\tcase uint16_INDIR_ARRAY_V:\n\t\t\t\tfor (j = 0; j < fields[i].size; j++)\n\t\t\t\t{\n\t\t\t\t\tword = *((uint16 *) (addr + j * 2));\n\t\t\t\t\t*ptr++ = (uint8) (word >> 8);\n\t\t\t\t\t*ptr++ = (uint8) word;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase uint32_ARRAY_V:\n\t\t\tcase uint32_INDIR_ARRAY_V:\n\t\t\t\tfor (j = 0; j < fields[i].size; j++)\n\t\t\t\t{\n\t\t\t\t\tdword = *((uint32 *) (addr + j * 4));\n\t\t\t\t\t*ptr++ = (uint8) (dword >> 24);\n\t\t\t\t\t*ptr++ = (uint8) (dword >> 16);\n\t\t\t\t\t*ptr++ = (uint8) (dword >> 8);\n\t\t\t\t\t*ptr++ = (uint8) dword;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tFreezeBlock(stream, name, block, len);\n\tdelete [] block;\n}\n\nstatic void FreezeBlock (STREAM stream, const char *name, uint8 *block, int size)\n{\n\tchar\tbuffer[20];\n\n\t// check if it fits in 6 digits. (letting it go over and using strlen isn't safe)\n\tif (size <= 999999)\n\t\tsprintf(buffer, \"%s:%06d:\", name, size);\n\telse\n\t{\n\t\t// to make it fit, pack it in the bytes instead of as digits\n\t\tsprintf(buffer, \"%s:------:\", name);\n\t\tbuffer[6] = (unsigned char) ((unsigned) size >> 24);\n\t\tbuffer[7] = (unsigned char) ((unsigned) size >> 16);\n\t\tbuffer[8] = (unsigned char) ((unsigned) size >> 8);\n\t\tbuffer[9] = (unsigned char) ((unsigned) size >> 0);\n\t}\n\n\tbuffer[11] = 0;\n\n\tWRITE_STREAM(buffer, 11, stream);\n\tWRITE_STREAM(block, size, stream);\n}\n\nstatic bool CheckBlockName(STREAM stream, const char *name, int &len)\n{\n\tchar\tbuffer[16];\n\tlen = 0;\n\n\tsize_t\tl = READ_STREAM(buffer, 11, stream);\n\tbuffer[l] = 0;\n\tREVERT_STREAM(stream, FIND_STREAM(stream) - l, 0);\n\n\tif (buffer[4] == '-')\n\t{\n\t\tlen = (((unsigned char)buffer[6]) << 24)\n\t\t\t| (((unsigned char)buffer[7]) << 16)\n\t\t\t| (((unsigned char)buffer[8]) << 8)\n\t\t\t| (((unsigned char)buffer[9]) << 0);\n\t}\n\telse\n\t\tlen = atoi(buffer + 4);\n\n\tif (l != 11 || strncmp(buffer, name, 3) != 0 || buffer[3] != ':')\n\t{\n\t\treturn false;\n\t}\n\n\tif (len <= 0)\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void SkipBlockWithName(STREAM stream, const char *name)\n{\n\tint len;\n\tbool matchesName = CheckBlockName(stream, name, len);\n\tif (matchesName)\n\t{\n\t\tlong rewind = FIND_STREAM(stream);\n\t\trewind += len + 11;\n\t\tREVERT_STREAM(stream, rewind, 0);\n\t}\n}\n\nstatic int UnfreezeBlock (STREAM stream, const char *name, uint8 *block, int size)\n{\n\tchar\tbuffer[20];\n\tint\t\tlen = 0, rem = 0;\n\tlong\trewind = FIND_STREAM(stream);\n\n\tsize_t\tl = READ_STREAM(buffer, 11, stream);\n\tbuffer[l] = 0;\n\n\tif (l != 11 || strncmp(buffer, name, 3) != 0 || buffer[3] != ':')\n\t{\n\terr:\n#ifdef DEBUGGER\n\t\tfprintf(stdout, \"absent: %s(%d); next: '%.11s'\\n\", name, size, buffer);\n#endif\n\t\tREVERT_STREAM(stream, FIND_STREAM(stream) - l, 0);\n\t\treturn (WRONG_FORMAT);\n\t}\n\n\tif (buffer[4] == '-')\n\t{\n\t\tlen = (((unsigned char) buffer[6]) << 24)\n\t\t\t| (((unsigned char) buffer[7]) << 16)\n\t\t\t| (((unsigned char) buffer[8]) << 8)\n\t\t\t| (((unsigned char) buffer[9]) << 0);\n\t}\n\telse\n\t\tlen = atoi(buffer + 4);\n\n\tif (len <= 0)\n\t\tgoto err;\n\n\tif (len > size)\n\t{\n\t\trem = len - size;\n\t\tlen = size;\n\t}\n\n\tif (!Settings.FastSavestates)\n\t{\n\t\tmemset(block, 0, size);\n\t}\n\n\tif (READ_STREAM(block, len, stream) != (unsigned int) len)\n\t{\n\t\tREVERT_STREAM(stream, rewind, 0);\n\t\treturn (WRONG_FORMAT);\n\t}\n\n\tif (rem)\n\t{\n\t\tchar\t*junk = new char[rem];\n\t\tlen = READ_STREAM(junk, rem, stream);\n\t\tdelete [] junk;\n\t\tif (len != rem)\n\t\t{\n\t\t\tREVERT_STREAM(stream, rewind, 0);\n\t\t\treturn (WRONG_FORMAT);\n\t\t}\n\t}\n\n\treturn (SUCCESS);\n}\n\nstatic int UnfreezeBlockCopy (STREAM stream, const char *name, uint8 **block, int size)\n{\n\tint\tresult;\n\n\t//check name first to avoid memory allocation\n\tint blockLength;\n\tif (!CheckBlockName(stream, name, blockLength))\n\t{\n\t\treturn 0;\n\t}\n\n\t*block = new uint8[size];\n\n\tresult = UnfreezeBlock(stream, name, *block, size);\n\tif (result != SUCCESS)\n\t{\n\t\tdelete [] (*block);\n\t\t*block = NULL;\n\t\treturn (result);\n\t}\n\n\treturn (SUCCESS);\n}\n\nstatic int UnfreezeStruct (STREAM stream, const char *name, void *base, FreezeData *fields, int num_fields, int version)\n{\n\tint\t\tresult;\n\tuint8\t*block = NULL;\n\n\tresult = UnfreezeStructCopy(stream, name, &block, fields, num_fields, version);\n\tif (result != SUCCESS)\n\t{\n\t\tif (block != NULL)\n\t\t\tdelete [] block;\n\t\treturn (result);\n\t}\n\n\tUnfreezeStructFromCopy(base, fields, num_fields, block, version);\n\tdelete [] block;\n\n\treturn (SUCCESS);\n}\n\nstatic int UnfreezeStructCopy (STREAM stream, const char *name, uint8 **block, FreezeData *fields, int num_fields, int version)\n{\n\tint\tlen = 0;\n\n\tfor (int i = 0; i < num_fields; i++)\n\t{\n\t\tif (version >= fields[i].debuted_in && version < fields[i].deleted_in)\n\t\t\tlen += FreezeSize(fields[i].size, fields[i].type);\n\t}\n\n\treturn (UnfreezeBlockCopy(stream, name, block, len));\n}\n\nstatic void UnfreezeStructFromCopy (void *sbase, FreezeData *fields, int num_fields, uint8 *block, int version)\n{\n\tuint8\t*ptr = block;\n\tuint16\tword;\n\tuint32\tdword;\n\tint64\tqaword;\n\tuint8\t*addr;\n\tvoid\t*base;\n\tint\t\trelativeAddr;\n\tint\t\ti, j;\n\n\tfor (i = 0; i < num_fields; i++)\n\t{\n\t\tif (version < fields[i].debuted_in || version >= fields[i].deleted_in)\n\t\t\tcontinue;\n\n\t\tbase = (SNAPSHOT_VERSION >= fields[i].deleted_in) ? ((void *) &Obsolete) : sbase;\n\t\taddr = (uint8 *) base + fields[i].offset;\n\n\t\tif (fields[i].type == uint8_INDIR_ARRAY_V || fields[i].type == uint16_INDIR_ARRAY_V || fields[i].type == uint32_INDIR_ARRAY_V)\n\t\t\taddr = (uint8 *) (*((pint *) addr));\n\n\t\tswitch (fields[i].type)\n\t\t{\n\t\t\tcase INT_V:\n\t\t\tcase POINTER_V:\n\t\t\t\tswitch (fields[i].size)\n\t\t\t\t{\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (fields[i].offset < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tptr++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t*(addr) = *ptr++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tif (fields[i].offset < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tptr += 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tword  = *ptr++ << 8;\n\t\t\t\t\t\tword |= *ptr++;\n\t\t\t\t\t\t*((uint16 *) (addr)) = word;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tif (fields[i].offset < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tptr += 4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdword  = *ptr++ << 24;\n\t\t\t\t\t\tdword |= *ptr++ << 16;\n\t\t\t\t\t\tdword |= *ptr++ << 8;\n\t\t\t\t\t\tdword |= *ptr++;\n\t\t\t\t\t\t*((uint32 *) (addr)) = dword;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\tif (fields[i].offset < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tptr += 8;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tqaword  = (int64) *ptr++ << 56;\n\t\t\t\t\t\tqaword |= (int64) *ptr++ << 48;\n\t\t\t\t\t\tqaword |= (int64) *ptr++ << 40;\n\t\t\t\t\t\tqaword |= (int64) *ptr++ << 32;\n\t\t\t\t\t\tqaword |= (int64) *ptr++ << 24;\n\t\t\t\t\t\tqaword |= (int64) *ptr++ << 16;\n\t\t\t\t\t\tqaword |= (int64) *ptr++ << 8;\n\t\t\t\t\t\tqaword |= (int64) *ptr++;\n\t\t\t\t\t\t*((int64 *) (addr)) = qaword;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tassert(0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase uint8_ARRAY_V:\n\t\t\tcase uint8_INDIR_ARRAY_V:\n\t\t\t\tif (fields[i].offset >= 0)\n\t\t\t\t\tmemmove(addr, ptr, fields[i].size);\n\t\t\t\tptr += fields[i].size;\n\n\t\t\t\tbreak;\n\n\t\t\tcase uint16_ARRAY_V:\n\t\t\tcase uint16_INDIR_ARRAY_V:\n\t\t\t\tif (fields[i].offset < 0)\n\t\t\t\t{\n\t\t\t\t\tptr += fields[i].size * 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (j = 0; j < fields[i].size; j++)\n\t\t\t\t{\n\t\t\t\t\tword  = *ptr++ << 8;\n\t\t\t\t\tword |= *ptr++;\n\t\t\t\t\t*((uint16 *) (addr + j * 2)) = word;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase uint32_ARRAY_V:\n\t\t\tcase uint32_INDIR_ARRAY_V:\n\t\t\t\tif (fields[i].offset < 0)\n\t\t\t\t{\n\t\t\t\t\tptr += fields[i].size * 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (j = 0; j < fields[i].size; j++)\n\t\t\t\t{\n\t\t\t\t\tdword  = *ptr++ << 24;\n\t\t\t\t\tdword |= *ptr++ << 16;\n\t\t\t\t\tdword |= *ptr++ << 8;\n\t\t\t\t\tdword |= *ptr++;\n\t\t\t\t\t*((uint32 *) (addr + j * 4)) = dword;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (fields[i].type == POINTER_V)\n\t\t{\n\t\t\trelativeAddr = (int) *((pint *) ((uint8 *) base + fields[i].offset));\n\t\t\tuint8\t*relativeTo = (uint8 *) *((pint *) ((uint8 *) base + fields[i].offset2));\n\t\t\t*((pint *) (addr)) = (pint) (relativeTo + relativeAddr);\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "snapshot.h",
          "type": "blob",
          "size": 1.37109375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _SNAPSHOT_H_\n#define _SNAPSHOT_H_\n\n#include \"snes9x.h\"\n\n#define SNAPSHOT_MAGIC\t\t\t\"#!s9xsnp\"\n#define SNAPSHOT_VERSION_IRQ\t\t7\n#define SNAPSHOT_VERSION_BAPU\t\t8\n#define SNAPSHOT_VERSION_IRQ_2018\t11\t\t// irq changes were introduced earlier, since this we store NextIRQTimer directly\n#define SNAPSHOT_VERSION\t\t\t12\n\n#define SUCCESS\t\t\t\t\t1\n#define WRONG_FORMAT\t\t\t(-1)\n#define WRONG_VERSION\t\t\t(-2)\n#define FILE_NOT_FOUND\t\t\t(-3)\n#define WRONG_MOVIE_SNAPSHOT\t(-4)\n#define NOT_A_MOVIE_SNAPSHOT\t(-5)\n#define SNAPSHOT_INCONSISTENT\t(-6)\n\nvoid S9xResetSaveTimer (bool8);\nbool8 S9xFreezeGame (const char *);\nuint32 S9xFreezeSize (void);\nbool8 S9xFreezeGameMem (uint8 *,uint32);\nbool8 S9xUnfreezeGame (const char *);\nint S9xUnfreezeGameMem (const uint8 *,uint32);\nvoid S9xFreezeToStream (STREAM);\nint\t S9xUnfreezeFromStream (STREAM);\nbool8 S9xUnfreezeScreenshot(const char *filename, uint16 **image_buffer, int &width, int &height);\nint S9xUnfreezeScreenshotFromStream(STREAM stream, uint16 **image_buffer, int &width, int &height);\n\n#endif\n"
        },
        {
          "name": "snes9x.cpp",
          "type": "blob",
          "size": 25.9482421875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include <ctype.h>\n#include <string.h>\n#ifdef HAVE_STRINGS_H\n#include <strings.h>\n#endif\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"controls.h\"\n#include \"crosshairs.h\"\n#include \"cheats.h\"\n#include \"display.h\"\n#include \"conffile.h\"\n#ifdef NETPLAY_SUPPORT\n#include \"netplay.h\"\n#endif\n\n#ifdef DEBUGGER\n#include \"debug.h\"\nextern FILE\t*trace;\n#endif\n\n#define S9X_CONF_FILE_NAME\t\"snes9x.conf\"\n\nstatic char\t*rom_filename = NULL;\n\nstatic bool parse_controller_spec (int, const char *);\nstatic void parse_crosshair_spec (enum crosscontrols, const char *);\nstatic bool try_load_config_file (const char *, ConfigFile &);\n\n\nstatic bool parse_controller_spec (int port, const char *arg)\n{\n\tif (!strcasecmp(arg, \"none\"))\n\t\tS9xSetController(port, CTL_NONE,       0, 0, 0, 0);\n\telse if (!strncasecmp(arg, \"pad\",   3) && arg[3] >= '1' && arg[3] <= '8' && arg[4] == '\\0')\n\t\tS9xSetController(port, CTL_JOYPAD, arg[3] - '1', 0, 0, 0);\n\telse if (!strncasecmp(arg, \"mouse\", 5) && arg[5] >= '1' && arg[5] <= '2' && arg[6] == '\\0')\n\t\tS9xSetController(port, CTL_MOUSE,  arg[5] - '1', 0, 0, 0);\n\telse if (!strcasecmp(arg, \"superscope\"))\n\t\tS9xSetController(port, CTL_SUPERSCOPE, 0, 0, 0, 0);\n\telse if (!strcasecmp(arg, \"justifier\"))\n\t\tS9xSetController(port, CTL_JUSTIFIER,  0, 0, 0, 0);\n\telse if (!strcasecmp(arg, \"two-justifiers\"))\n\t\tS9xSetController(port, CTL_JUSTIFIER,  1, 0, 0, 0);\n\telse if (!strcasecmp(arg, \"macsrifle\"))\n\t\tS9xSetController(port, CTL_MACSRIFLE,  0, 0, 0, 0);\n\telse if (!strncasecmp(arg, \"mp5:\", 4) && ((arg[4] >= '1' && arg[4] <= '8') || arg[4] == 'n') &&\n\t\t\t\t\t\t\t\t\t\t((arg[5] >= '1' && arg[5] <= '8') || arg[5] == 'n') &&\n\t\t\t\t\t\t\t\t\t\t((arg[6] >= '1' && arg[6] <= '8') || arg[6] == 'n') &&\n\t\t\t\t\t\t\t\t\t\t((arg[7] >= '1' && arg[7] <= '8') || arg[7] == 'n') && arg[8] == '\\0')\n\t\tS9xSetController(port, CTL_MP5, (arg[4] == 'n') ? -1 : arg[4] - '1',\n\t\t\t\t\t\t\t\t\t\t(arg[5] == 'n') ? -1 : arg[5] - '1',\n\t\t\t\t\t\t\t\t\t\t(arg[6] == 'n') ? -1 : arg[6] - '1',\n\t\t\t\t\t\t\t\t\t\t(arg[7] == 'n') ? -1 : arg[7] - '1');\n\telse\n\t\treturn (false);\n\n\treturn (true);\n}\n\nstatic void parse_crosshair_spec (enum crosscontrols ctl, const char *spec)\n{\n\tint\t\t\tidx = -1, i;\n\tconst char\t*fg = NULL, *bg = NULL, *s = spec;\n\n\tif (s[0] == '\"')\n\t{\n\t\ts++;\n\t\tfor (i = 0; s[i] != '\\0'; i++)\n\t\t\tif (s[i] == '\"' && s[i - 1] != '\\\\')\n\t\t\t\tbreak;\n\n\t\tidx = 31 - ctl;\n\n\t\tstd::string\tfname(s, i);\n\t\tif (!S9xLoadCrosshairFile(idx, fname.c_str()))\n\t\t\treturn;\n\n\t\ts += i + 1;\n\t}\n\telse\n\t{\n\t\tif (isdigit(*s))\n\t\t{\n\t\t\tidx = *s - '0';\n\t\t\ts++;\n\t\t}\n\n\t\tif (isdigit(*s))\n\t\t{\n\t\t\tidx = idx * 10 + *s - '0';\n\t\t\ts++;\n\t\t}\n\n\t\tif (idx > 31)\n\t\t{\n\t\t\tfprintf(stderr, \"Invalid crosshair spec '%s'.\\n\", spec);\n\t\t\treturn;\n\t\t}\n\t}\n\n\twhile (*s != '\\0' && isspace(*s))\n\t\ts++;\n\n\tif (*s != '\\0')\n\t{\n\t\tfg = s;\n\n\t\twhile (isalnum(*s))\n\t\t\ts++;\n\n\t\tif (*s != '/' || !isalnum(s[1]))\n\t\t{\n\t\t\tfprintf(stderr, \"Invalid crosshair spec '%s.'\\n\", spec);\n\t\t\treturn;\n\t\t}\n\n\t\tbg = ++s;\n\n\t\twhile (isalnum(*s))\n\t\t\ts++;\n\n\t\tif (*s != '\\0')\n\t\t{\n\t\t\tfprintf(stderr, \"Invalid crosshair spec '%s'.\\n\", spec);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tS9xSetControllerCrosshair(ctl, idx, fg, bg);\n}\n\nstatic bool try_load_config_file (const char *fname, ConfigFile &conf)\n{\n\tFSTREAM\tfp;\n\n\tfp = OPEN_FSTREAM(fname, \"r\");\n\tif (fp)\n\t{\n\t\tfprintf(stdout, \"Reading config file %s.\\n\", fname);\n\t\tfStream fS(fp);\n\t\tconf.LoadFile(&fS);\n        CLOSE_FSTREAM(fp);\n\t\treturn (true);\n\t}\n\n\treturn (false);\n}\n\nvoid S9xLoadConfigFiles (char **argv, int argc)\n{\n\tstatic ConfigFile\tconf; // static because some of its functions return pointers\n\tconf.Clear();\n\n\tbool\tskip = false;\n\tfor (int i = 0; i < argc; i++)\n\t{\n\t\tif (!strcasecmp(argv[i], \"-nostdconf\"))\n\t\t{\n\t\t\tskip = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!skip)\n\t{\n\t\tstd::string\tfname;\n\n\t\tfname = S9xGetDirectory(DEFAULT_DIR);\n\t\tfname += SLASH_STR S9X_CONF_FILE_NAME;\n\t\ttry_load_config_file(fname.c_str(), conf);\n\t}\n\telse\n\t\tfprintf(stderr, \"Skipping standard config files.\\n\");\n\n\tfor (int i = 0; i < argc - 1; i++)\n\t\tif (!strcasecmp(argv[i], \"-conf\"))\n\t\t\ttry_load_config_file(argv[++i], conf);\n\n\t// Parse config file here\n\n\t// ROM\n\n\tSettings.ForceInterleaved2          =  conf.GetBool(\"ROM::Interleaved2\",                   false);\n\tSettings.ForceInterleaveGD24        =  conf.GetBool(\"ROM::InterleaveGD24\",                 false);\n\tSettings.ApplyCheats                =  conf.GetBool(\"ROM::Cheat\",                          false);\n\tCheat.enabled = false;\n\tSettings.NoPatch                    = !conf.GetBool(\"ROM::Patch\",                          true);\n\tSettings.IgnorePatchChecksum        =  conf.GetBool(\"ROM::IgnorePatchChecksum\",            false);\n\n\tSettings.ForceLoROM = conf.GetBool(\"ROM::LoROM\", false);\n\tSettings.ForceHiROM = conf.GetBool(\"ROM::HiROM\", false);\n\tif (Settings.ForceLoROM)\n\t\tSettings.ForceHiROM = false;\n\n\tSettings.ForcePAL   = conf.GetBool(\"ROM::PAL\",  false);\n\tSettings.ForceNTSC  = conf.GetBool(\"ROM::NTSC\", false);\n\tif (Settings.ForcePAL)\n\t\tSettings.ForceNTSC = false;\n\n\tif (conf.Exists(\"ROM::Header\"))\n\t{\n\t\tSettings.ForceHeader = conf.GetBool(\"ROM::Header\", false);\n\t\tSettings.ForceNoHeader = !Settings.ForceHeader;\n\t}\n\n\tif (conf.Exists(\"ROM::Interleaved\"))\n\t{\n\t\tSettings.ForceInterleaved = conf.GetBool(\"ROM::Interleaved\", false);\n\t\tSettings.ForceNotInterleaved = !Settings.ForceInterleaved;\n\t}\n\n\trom_filename = conf.GetStringDup(\"ROM::Filename\", NULL);\n\tSettings.InitialSnapshotFilename[0] = '\\0';\n\n\t// Sound\n\n\tSettings.SoundSync                  =  conf.GetBool(\"Sound::Sync\",                         false);\n\tSettings.SixteenBitSound            =  conf.GetBool(\"Sound::16BitSound\",                   true);\n\tSettings.Stereo                     =  conf.GetBool(\"Sound::Stereo\",                       true);\n\tSettings.ReverseStereo              =  conf.GetBool(\"Sound::ReverseStereo\",                false);\n\tSettings.SoundPlaybackRate          =  conf.GetUInt(\"Sound::Rate\",                         48000);\n\tSettings.SoundInputRate             =  conf.GetUInt(\"Sound::InputRate\",                    31950);\n\tSettings.Mute                       =  conf.GetBool(\"Sound::Mute\",                         false);\n\tSettings.DynamicRateControl         =  conf.GetBool(\"Sound::DynamicRateControl\",           false);\n\tSettings.DynamicRateLimit           =  conf.GetInt (\"Sound::DynamicRateLimit\",             5);\n\tSettings.InterpolationMethod        =  conf.GetInt (\"Sound::InterpolationMethod\",          2);\n\n\t// Display\n\n\tSettings.Transparency               =  conf.GetBool(\"Display::Transparency\",               true);\n\tSettings.DisableGraphicWindows      = !conf.GetBool(\"Display::GraphicWindows\",             true);\n\tSettings.DisplayTime\t\t\t\t=  conf.GetBool(\"Display::DisplayTime\",                false);\n\tSettings.DisplayFrameRate           =  conf.GetBool(\"Display::DisplayFrameRate\",           false);\n\tSettings.DisplayWatchedAddresses    =  conf.GetBool(\"Display::DisplayWatchedAddresses\",    false);\n\tSettings.DisplayPressedKeys         =  conf.GetBool(\"Display::DisplayInput\",               false);\n\tSettings.DisplayMovieFrame          =  conf.GetBool(\"Display::DisplayFrameCount\",          false);\n\tSettings.AutoDisplayMessages        =  conf.GetBool(\"Display::MessagesInImage\",            true);\n\tSettings.InitialInfoStringTimeout   =  conf.GetInt (\"Display::MessageDisplayTime\",         120);\n\tSettings.BilinearFilter             =  conf.GetBool(\"Display::BilinearFilter\",             false);\n\n\t// Settings\n\n\tSettings.BSXBootup                  =  conf.GetBool(\"Settings::BSXBootup\",                 false);\n\tSettings.TurboMode                  =  conf.GetBool(\"Settings::TurboMode\",                 false);\n\tSettings.TurboSkipFrames            =  conf.GetUInt(\"Settings::TurboFrameSkip\",            15);\n\tSettings.MovieTruncate              =  conf.GetBool(\"Settings::MovieTruncateAtEnd\",        false);\n\tSettings.MovieNotifyIgnored         =  conf.GetBool(\"Settings::MovieNotifyIgnored\",        false);\n\tSettings.WrongMovieStateProtection  =  conf.GetBool(\"Settings::WrongMovieStateProtection\", true);\n\tSettings.StretchScreenshots         =  conf.GetInt (\"Settings::StretchScreenshots\",        1);\n\tSettings.SnapshotScreenshots        =  conf.GetBool(\"Settings::SnapshotScreenshots\",       true);\n\tSettings.DontSaveOopsSnapshot       =  conf.GetBool(\"Settings::DontSaveOopsSnapshot\",      false);\n\tSettings.AutoSaveDelay              =  conf.GetUInt(\"Settings::AutoSaveDelay\",             0);\n\n\tif (conf.Exists(\"Settings::FrameTime\"))\n\t\tSettings.FrameTimePAL = Settings.FrameTimeNTSC = conf.GetUInt(\"Settings::FrameTime\", 16667);\n\n\tif (!strcasecmp(conf.GetString(\"Settings::FrameSkip\", \"Auto\"), \"Auto\"))\n\t\tSettings.SkipFrames = AUTO_FRAMERATE;\n\telse\n\t\tSettings.SkipFrames = conf.GetUInt(\"Settings::FrameSkip\", 0) + 1;\n\n\t// Controls\n\n\tSettings.MouseMaster                =  conf.GetBool(\"Controls::MouseMaster\",               true);\n\tSettings.SuperScopeMaster           =  conf.GetBool(\"Controls::SuperscopeMaster\",          true);\n\tSettings.JustifierMaster            =  conf.GetBool(\"Controls::JustifierMaster\",           true);\n\tSettings.MacsRifleMaster            =  conf.GetBool(\"Controls::MacsRifleMaster\",           true);\n\tSettings.MultiPlayer5Master         =  conf.GetBool(\"Controls::MP5Master\",                 true);\n\tSettings.UpAndDown                  =  conf.GetBool(\"Controls::AllowLeftRight\",            false);\n\n\tif (conf.Exists(\"Controls::Port1\"))\n\t\tparse_controller_spec(0, conf.GetString(\"Controls::Port1\"));\n\tif (conf.Exists(\"Controls::Port2\"))\n\t\tparse_controller_spec(1, conf.GetString(\"Controls::Port2\"));\n\n\tif (conf.Exists(\"Controls::Mouse1Crosshair\"))\n\t\tparse_crosshair_spec(X_MOUSE1,     conf.GetString(\"Controls::Mouse1Crosshair\"));\n\tif (conf.Exists(\"Controls::Mouse2Crosshair\"))\n\t\tparse_crosshair_spec(X_MOUSE2,     conf.GetString(\"Controls::Mouse2Crosshair\"));\n\tif (conf.Exists(\"Controls::SuperscopeCrosshair\"))\n\t\tparse_crosshair_spec(X_SUPERSCOPE, conf.GetString(\"Controls::SuperscopeCrosshair\"));\n\tif (conf.Exists(\"Controls::Justifier1Crosshair\"))\n\t\tparse_crosshair_spec(X_JUSTIFIER1, conf.GetString(\"Controls::Justifier1Crosshair\"));\n\tif (conf.Exists(\"Controls::Justifier2Crosshair\"))\n\t\tparse_crosshair_spec(X_JUSTIFIER2, conf.GetString(\"Controls::Justifier2Crosshair\"));\n\tif (conf.Exists(\"Controls::MacsRifleCrosshair\"))\n\t\tparse_crosshair_spec(X_MACSRIFLE, conf.GetString(\"Controls::MacsRifleCrosshair\"));\n\n\t// Hack\n\tSettings.SuperFXClockMultiplier         = conf.GetUInt(\"Hack::SuperFXClockMultiplier\", 100);\n    Settings.OverclockMode                  = conf.GetUInt(\"Hack::OverclockMode\", 0);\n    Settings.SeparateEchoBuffer             = conf.GetBool(\"Hack::SeparateEchoBuffer\", false);\n\tSettings.DisableGameSpecificHacks       = !conf.GetBool(\"Hack::EnableGameSpecificHacks\",       true);\n\tSettings.BlockInvalidVRAMAccessMaster   = !conf.GetBool(\"Hack::AllowInvalidVRAMAccess\",        false);\n\tSettings.HDMATimingHack                 =  conf.GetInt (\"Hack::HDMATiming\",                    100);\n\tSettings.MaxSpriteTilesPerLine          =  conf.GetInt (\"Hack::MaxSpriteTilesPerLine\",         34);\n\n\t// Netplay\n\n#ifdef NETPLAY_SUPPORT\n\tSettings.NetPlay = conf.GetBool(\"Netplay::Enable\");\n\n\tSettings.Port = NP_DEFAULT_PORT;\n\tif (conf.Exists(\"Netplay::Port\"))\n\t\tSettings.Port = -(int) conf.GetUInt(\"Netplay::Port\");\n\n\tSettings.ServerName[0] = '\\0';\n\tif (conf.Exists(\"Netplay::Server\"))\n\t\tconf.GetString(\"Netplay::Server\", Settings.ServerName, 128);\n#endif\n\n\t// Debug\n\n#ifdef DEBUGGER\n\tif (conf.GetBool(\"DEBUG::Debugger\", false))\n\t\tCPU.Flags |= DEBUG_MODE_FLAG;\n\n\tif (conf.GetBool(\"DEBUG::Trace\", false))\n\t{\n\t\tENSURE_TRACE_OPEN(trace,\"trace.log\",\"wb\")\n\t\tCPU.Flags |= TRACE_FLAG;\n\t}\n\tSettings.TraceSMP = FALSE;\n#endif\n\n\tS9xParsePortConfig(conf, 1);\n\tS9xVerifyControllers();\n}\n\nvoid S9xUsage (void)\n{\n\t/*                               12345678901234567890123456789012345678901234567890123456789012345678901234567890 */\n\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"Snes9x \" VERSION);\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"usage: snes9x [options] <ROM image filename>\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n\n\t// SOUND OPTIONS\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-soundsync                      Synchronize sound as far as possible\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-playbackrate <Hz>              Set sound playback rate\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-inputrate <Hz>                 Set sound input rate\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-reversestereo                  Reverse stereo sound output\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-nostereo                       Disable stereo sound output\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-eightbit                       Use 8bit sound instead of 16bit\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-mute                           Mute sound\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n\n\t// DISPLAY OPTIONS\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-displaytime                    Display the time\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-displayframerate               Display the frame rate counter\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-displaykeypress                Display input of all controllers and peripherals\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-nohires                        (Not recommended) Disable support for hi-res and\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                                interlace modes\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-notransparency                 (Not recommended) Disable transparency effects\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-nowindows                      (Not recommended) Disable graphic window effects\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n\n\t// CONTROLLER OPTIONS\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-nomp5                          Disable emulation of the Multiplayer 5 adapter\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-nomouse                        Disable emulation of the SNES mouse\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-nosuperscope                   Disable emulation of the Superscope\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-nojustifier                    Disable emulation of the Konami Justifier\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-nomacsrifle                    Disable emulation of the M.A.C.S. Rifle\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-port# <control>                Specify which controller to emulate in port 1/2\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"    Controllers: none              No controller\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                 pad#              Joypad number 1-8\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                 mouse#            Mouse number 1-2\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                 superscope        Superscope (not useful with -port1)\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                 justifier         Blue Justifier (not useful with -port1)\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                 two-justifiers    Blue & Pink Justifiers\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                 mp5:####          MP5 with the 4 named pads (1-8 or n)\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                 macsrifle         M.A.C.S. Rifle\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n\n\t// ROM OPTIONS\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-hirom                          Force Hi-ROM memory map\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-lorom                          Force Lo-ROM memory map\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-ntsc                           Force NTSC timing (60 frames/sec)\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-pal                            Force PAL timing (50 frames/sec)\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-nointerleave                   Assume the ROM image is not in interleaved\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                                format\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-interleaved                    Assume the ROM image is in interleaved format\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-interleaved2                   Assume the ROM image is in interleaved 2 format\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-interleavedgd24                Assume the ROM image is in interleaved gd24\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                                format\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-noheader                       Assume the ROM image doesn't have a header of a\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                                copier\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-header                         Assume the ROM image has a header of a copier\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-bsxbootup                      Boot up BS games from BS-X\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n\n\t// PATCH/CHEAT OPTIONS\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-nopatch                        Do not apply any available IPS/UPS patches\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-cheat                          Apply saved cheats\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-cheatcode <code>               Supply a cheat code in Game Genie,\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                                Pro-Action Replay, or Raw format (address=byte)\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n\n#ifdef NETPLAY_SUPPORT\n\t// NETPLAY OPTIONS\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-net                            Enable netplay\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-port <num>                     Use port <num> for netplay (use with -net)\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-server <string>                Use the specified server for netplay\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                                (use with -net)\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n#endif\n\n\t// HACKING OR DEBUGGING OPTIONS\n#ifdef DEBUGGER\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-debug                          Set the Debugger flag\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-trace                          Begin CPU instruction tracing\");\n#endif\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-hdmatiming <1-199>             (Not recommended) Changes HDMA transfer timings\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                                event comes\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-invalidvramaccess              (Not recommended) Allow invalid VRAM access\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n\n\t// OTHER OPTIONS\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-frameskip <num>                Screen update frame skip rate\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-frametime <num>                Milliseconds per frame for frameskip auto-adjust\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-upanddown                      Override protection from pressing left+right or\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"                                up+down together\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-conf <filename>                Use specified conf file (after standard files)\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"-nostdconf                      Do not load the standard config files\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n\n\tS9xExtraUsage();\n\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"\");\n\tS9xMessage(S9X_INFO, S9X_USAGE, \"ROM image can be compressed with zip, gzip, JMA, or compress.\");\n\n\texit(1);\n}\n\nvoid S9xParseArgsForCheats (char **argv, int argc)\n{\n    for (int i = 1; i < argc; i++)\n    {\n        if (!strcasecmp(argv[i], \"-gamegenie\") ||\n            !strcasecmp(argv[i], \"-actionreplay\") ||\n            !strcasecmp(argv[i], \"-cheatcode\"))\n        {\n            if (i + 1 < argc)\n            {\n                if (S9xAddCheatGroup (\"Unknown\", argv[++i]) < 0)\n                {\n                    S9xMessage(S9X_ERROR, S9X_GAME_GENIE_CODE_ERROR, \"Code format invalid\");\n                }\n                else\n                {\n                    S9xEnableCheatGroup (Cheat.group.size() - 1);\n                }\n            }\n            else\n                S9xUsage();\n        }\n    }\n}\n\nchar * S9xParseArgs (char **argv, int argc)\n{\n\tfor (int i = 1; i < argc; i++)\n\t{\n\t\tif (*argv[i] == '-')\n\t\t{\n\t\t\tif (!strcasecmp(argv[i], \"-help\"))\n\t\t\t\tS9xUsage();\n\t\t\telse\n\n\t\t\t// SOUND OPTIONS\n\n\t\t\tif (!strcasecmp(argv[i], \"-soundsync\"))\n\t\t\t\tSettings.SoundSync = TRUE;\n\t\t\telse if (!strcasecmp(argv[i], \"-dynamicratecontrol\"))\n\t\t\t{\n\t\t\t\tSettings.DynamicRateControl = TRUE;\n\t\t\t\tSettings.DynamicRateLimit = 5;\n\t\t\t}\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-playbackrate\"))\n\t\t\t{\n\t\t\t\tif (i + 1 < argc)\n\t\t\t\t{\n\t\t\t\t\tSettings.SoundPlaybackRate = atoi(argv[++i]);\n\t\t\t\t\tif (Settings.SoundPlaybackRate < 8192)\n\t\t\t\t\t\tSettings.SoundPlaybackRate = 8192;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tS9xUsage();\n\t\t\t}\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-inputrate\"))\n\t\t\t{\n\t\t\t\tif (i + 1 < argc)\n\t\t\t\t{\n\t\t\t\t\tSettings.SoundInputRate = atoi(argv[++i]);\n\t\t\t\t\tif (Settings.SoundInputRate < 31700)\n\t\t\t\t\t\tSettings.SoundInputRate = 31700;\n\t\t\t\t\tif (Settings.SoundInputRate > 32300)\n\t\t\t\t\t\tSettings.SoundInputRate = 32300;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tS9xUsage();\n\t\t\t}\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-reversestereo\"))\n\t\t\t\tSettings.ReverseStereo = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-nostereo\"))\n\t\t\t\tSettings.Stereo = FALSE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-eightbit\"))\n\t\t\t\tSettings.SixteenBitSound = FALSE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-mute\"))\n\t\t\t\tSettings.Mute = TRUE;\n\t\t\telse\n\n\t\t\t// DISPLAY OPTIONS\n\n\t\t\tif (!strcasecmp(argv[i], \"-displaytime\"))\n\t\t\t\tSettings.DisplayTime = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-displayframerate\"))\n\t\t\t\tSettings.DisplayFrameRate = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-displaykeypress\"))\n\t\t\t\tSettings.DisplayPressedKeys = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-notransparency\"))\n\t\t\t\tSettings.Transparency = FALSE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-nowindows\"))\n\t\t\t\tSettings.DisableGraphicWindows = TRUE;\n\t\t\telse\n\n\t\t\t// CONTROLLER OPTIONS\n\n\t\t\tif (!strcasecmp(argv[i], \"-nomp5\"))\n\t\t\t\tSettings.MultiPlayer5Master = FALSE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-nomouse\"))\n\t\t\t\tSettings.MouseMaster = FALSE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-nosuperscope\"))\n\t\t\t\tSettings.SuperScopeMaster = FALSE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-nojustifier\"))\n\t\t\t\tSettings.JustifierMaster = FALSE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-nomacsrifle\"))\n\t\t\t\tSettings.MacsRifleMaster = FALSE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-port1\") ||\n\t\t\t\t!strcasecmp(argv[i], \"-port2\"))\n\t\t\t{\n\t\t\t\tif (i + 1 < argc)\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tif (!parse_controller_spec(argv[i - 1][5] - '1', argv[i]))\n\t\t\t\t\t\tS9xUsage();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tS9xUsage();\n\t\t\t}\n\t\t\telse\n\n\t\t\t// ROM OPTIONS\n\n\t\t\tif (!strcasecmp(argv[i], \"-hirom\"))\n\t\t\t\tSettings.ForceHiROM = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-lorom\"))\n\t\t\t\tSettings.ForceLoROM = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-ntsc\"))\n\t\t\t\tSettings.ForceNTSC = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-pal\"))\n\t\t\t\tSettings.ForcePAL = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-nointerleave\"))\n\t\t\t\tSettings.ForceNotInterleaved = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-interleaved\"))\n\t\t\t\tSettings.ForceInterleaved = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-interleaved2\"))\n\t\t\t\tSettings.ForceInterleaved2 = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-interleavedgd24\"))\n\t\t\t\tSettings.ForceInterleaveGD24 = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-noheader\"))\n\t\t\t\tSettings.ForceNoHeader = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-header\"))\n\t\t\t\tSettings.ForceHeader = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-bsxbootup\"))\n\t\t\t\tSettings.BSXBootup = TRUE;\n                        else\n                        if (!strcasecmp(argv[i], \"-snapshot\"))\n                        {\n                                if (i + 1 < argc)\n                                {\n                                        strncpy(Settings.InitialSnapshotFilename, argv[++i], PATH_MAX);\n                                        Settings.InitialSnapshotFilename[PATH_MAX] = 0;\n                                }\n                                else\n                                        S9xUsage();\n                        }\n\t\t\telse\n\n\t\t\t// PATCH/CHEAT OPTIONS\n\n\t\t\tif (!strcasecmp(argv[i], \"-nopatch\"))\n\t\t\t\tSettings.NoPatch = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-cheat\"))\n\t\t\t\tSettings.ApplyCheats = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-gamegenie\") ||\n\t\t\t    !strcasecmp(argv[i], \"-actionreplay\") ||\n\t\t\t    !strcasecmp(argv[i], \"-cheatcode\"))\n\t\t\t{\n\t\t\t\tif (i + 1 < argc)\n\t\t\t\t{\n\t\t\t\t\tif (S9xAddCheatGroup (\"Unknown\", argv[++i]) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tS9xMessage(S9X_ERROR, S9X_GAME_GENIE_CODE_ERROR, \"Code format invalid\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tS9xEnableCheatGroup (Cheat.group.size() - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tS9xUsage();\n\t\t\t}\n\t\t\telse\n\t\t\t// NETPLAY OPTIONS\n\n\t\t#ifdef NETPLAY_SUPPORT\n\t\t\tif (!strcasecmp(argv[i], \"-net\"))\n\t\t\t\tSettings.NetPlay = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-port\"))\n\t\t\t{\n\t\t\t\tif (i + 1 < argc)\n\t\t\t\t\tSettings.Port = -atoi(argv[++i]);\n\t\t\t\telse\n\t\t\t\t\tS9xUsage();\n\t\t\t}\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-server\"))\n\t\t\t{\n\t\t\t\tif (i + 1 < argc)\n\t\t\t\t{\n\t\t\t\t\tstrncpy(Settings.ServerName, argv[++i], 127);\n\t\t\t\t\tSettings.ServerName[127] = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tS9xUsage();\n\t\t\t}\n\t\t\telse\n\t\t#endif\n\n\t\t\t// HACKING OR DEBUGGING OPTIONS\n\n\t\t#ifdef DEBUGGER\n\t\t\tif (!strcasecmp(argv[i], \"-debug\"))\n\t\t\t\tCPU.Flags |= DEBUG_MODE_FLAG;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-trace\"))\n\t\t\t{\n\t\t\t\tENSURE_TRACE_OPEN(trace,\"trace.log\",\"wb\")\n\t\t\t\tCPU.Flags |= TRACE_FLAG;\n\t\t\t}\n\t\t\telse\n\t\t#endif\n\n\t\t\tif (!strcasecmp(argv[i], \"-hdmatiming\"))\n\t\t\t{\n\t\t\t\tif (i + 1 < argc)\n\t\t\t\t{\n\t\t\t\t\tint\tp = atoi(argv[++i]);\n\t\t\t\t\tif (p > 0 && p < 200)\n\t\t\t\t\t\tSettings.HDMATimingHack = p;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tS9xUsage();\n\t\t\t}\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-invalidvramaccess\"))\n\t\t\t\tSettings.BlockInvalidVRAMAccessMaster = FALSE;\n\t\t\telse\n\n\t\t\t// OTHER OPTIONS\n\n\t\t\tif (!strcasecmp(argv[i], \"-frameskip\"))\n\t\t\t{\n\t\t\t\tif (i + 1 < argc)\n\t\t\t\t\tSettings.SkipFrames = atoi(argv[++i]) + 1;\n\t\t\t\telse\n\t\t\t\t\tS9xUsage();\n\t\t\t}\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-frametime\"))\n\t\t\t{\n\t\t\t\tif (i + 1 < argc)\n\t\t\t\t\tSettings.FrameTimePAL = Settings.FrameTimeNTSC = atoi(argv[++i]);\n\t\t\t\telse\n\t\t\t\t\tS9xUsage();\n\t\t\t}\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-upanddown\"))\n\t\t\t\tSettings.UpAndDown = TRUE;\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-conf\"))\n\t\t\t{\n\t\t\t\tif (++i >= argc)\n\t\t\t\t\tS9xUsage();\n\t\t\t\t// Else do nothing, S9xLoadConfigFiles() handled it.\n\t\t\t}\n\t\t\telse\n\t\t\tif (!strcasecmp(argv[i], \"-nostdconf\"))\n\t\t\t{\n\t\t\t\t// Do nothing, S9xLoadConfigFiles() handled it.\n\t\t\t}\n\t\t\telse\n\t\t\t\tS9xParseArg(argv, i, argc);\n\t\t}\n\t\telse\n\t\t\trom_filename = argv[i];\n\t}\n\n\tS9xVerifyControllers();\n\n\treturn (rom_filename);\n}\n"
        },
        {
          "name": "snes9x.h",
          "type": "blob",
          "size": 8.33203125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _SNES9X_H_\n#define _SNES9X_H_\n\n#ifndef VERSION\n#define VERSION\t\"1.63\"\n#endif\n\n#include \"port.h\"\n#include \"65c816.h\"\n#include \"messages.h\"\n\n#ifdef ZLIB\n#include <zlib.h>\n#define FSTREAM\t\t\t\t\tgzFile\n#define READ_FSTREAM(p, l, s)\tgzread(s, p, l)\n#define WRITE_FSTREAM(p, l, s)\tgzwrite(s, p, l)\n#define GETS_FSTREAM(p, l, s)\tgzgets(s, p, l)\n#define GETC_FSTREAM(s)\t\t\tgzgetc(s)\n#define OPEN_FSTREAM(f, m)\t\tgzopen(f, m)\n#define REOPEN_FSTREAM(f, m)\t\tgzdopen(f, m)\n#define FIND_FSTREAM(f)\t\t\tgztell(f)\n#define REVERT_FSTREAM(s, o, p)\tgzseek(s, o, p)\n#define CLOSE_FSTREAM(s)\t\t\tgzclose(s)\n#else\n#define FSTREAM\t\t\t\t\tFILE *\n#define READ_FSTREAM(p, l, s)\tfread(p, 1, l, s)\n#define WRITE_FSTREAM(p, l, s)\tfwrite(p, 1, l, s)\n#define GETS_FSTREAM(p, l, s)\tfgets(p, l, s)\n#define GETC_FSTREAM(s)\t\t\tfgetc(s)\n#define OPEN_FSTREAM(f, m)\t\tfopen(f, m)\n#define REOPEN_FSTREAM(f, m)\t\tfdopen(f, m)\n#define FIND_FSTREAM(s)\t\t\tftell(s)\n#define REVERT_FSTREAM(s, o, p)\tfseek(s, o, p)\n#define CLOSE_FSTREAM(s)\t\t\tfclose(s)\n#endif\n\n#include \"stream.h\"\n\n#define STREAM\t\t\t\t\tStream *\n#define READ_STREAM(p, l, s)\ts->read(p,l)\n#define WRITE_STREAM(p, l, s)\ts->write(p,l)\n#define GETS_STREAM(p, l, s)\ts->gets(p,l)\n#define GETC_STREAM(s)\t\t\ts->get_char()\n#define OPEN_STREAM(f, m)\t\topenStreamFromFSTREAM(f, m)\n#define REOPEN_STREAM(f, m)\t\treopenStreamFromFd(f, m)\n#define FIND_STREAM(s)\t\t\ts->pos()\n#define REVERT_STREAM(s, o, p)\ts->revert(p, o)\n#define CLOSE_STREAM(s)\t\t\ts->closeStream()\n\n#define SNES_WIDTH\t\t\t\t\t256\n#define SNES_HEIGHT\t\t\t\t\t224\n#define SNES_HEIGHT_EXTENDED\t\t239\n#define MAX_SNES_WIDTH\t\t\t\t(SNES_WIDTH * 2)\n#define MAX_SNES_HEIGHT\t\t\t\t(SNES_HEIGHT_EXTENDED * 2)\n\n#define\tNTSC_MASTER_CLOCK\t\t\t21477272.727272 // 21477272 + 8/11 exact\n#define\tPAL_MASTER_CLOCK\t\t\t21281370.0\n#define NTSC_PROGRESSIVE_FRAME_RATE\t60.09881389744051\n#define NTSC_INTERLACED_FRAME_RATE\t59.94005994\n#define PAL_PROGRESSIVE_FRAME_RATE\t50.006977968\n\n\n#define SNES_MAX_NTSC_VCOUNTER\t\t262\n#define SNES_MAX_PAL_VCOUNTER\t\t312\n#define SNES_HCOUNTER_MAX\t\t\t341\n\n#ifndef ALLOW_CPU_OVERCLOCK\n#define ONE_CYCLE\t\t\t\t\t6\n#define SLOW_ONE_CYCLE\t\t\t\t8\n#define TWO_CYCLES\t\t\t\t\t12\n#else\n#define ONE_CYCLE      (Settings.OneClockCycle)\n#define SLOW_ONE_CYCLE (Settings.OneSlowClockCycle)\n#define TWO_CYCLES     (Settings.TwoClockCycles)\n#endif\n#define\tONE_DOT_CYCLE\t\t\t\t4\n\n#define SNES_CYCLES_PER_SCANLINE\t(SNES_HCOUNTER_MAX * ONE_DOT_CYCLE)\n#define SNES_SCANLINE_TIME\t\t\t(SNES_CYCLES_PER_SCANLINE / NTSC_MASTER_CLOCK)\n\n#define SNES_WRAM_REFRESH_HC_v1\t\t530\n#define SNES_WRAM_REFRESH_HC_v2\t\t538\n#define SNES_WRAM_REFRESH_CYCLES\t40\n\n#define SNES_HBLANK_START_HC\t\t1096\t\t\t\t\t// H=274\n#define\tSNES_HDMA_START_HC\t\t\t1106\t\t\t\t\t// FIXME: not true\n#define\tSNES_HBLANK_END_HC\t\t\t4\t\t\t\t\t\t// H=1\n#define\tSNES_HDMA_INIT_HC\t\t\t20\t\t\t\t\t\t// FIXME: not true\n#define\tSNES_RENDER_START_HC\t\t(128 * ONE_DOT_CYCLE)\t// FIXME: Snes9x renders a line at a time.\n\n#define SNES_TR_MASK\t\t(1 <<  4)\n#define SNES_TL_MASK\t\t(1 <<  5)\n#define SNES_X_MASK\t\t\t(1 <<  6)\n#define SNES_A_MASK\t\t\t(1 <<  7)\n#define SNES_RIGHT_MASK\t\t(1 <<  8)\n#define SNES_LEFT_MASK\t\t(1 <<  9)\n#define SNES_DOWN_MASK\t\t(1 << 10)\n#define SNES_UP_MASK\t\t(1 << 11)\n#define SNES_START_MASK\t\t(1 << 12)\n#define SNES_SELECT_MASK\t(1 << 13)\n#define SNES_Y_MASK\t\t\t(1 << 14)\n#define SNES_B_MASK\t\t\t(1 << 15)\n\n#define DEBUG_MODE_FLAG\t\t(1 <<  0)\t// debugger\n#define TRACE_FLAG\t\t\t(1 <<  1)\t// debugger\n#define SINGLE_STEP_FLAG\t(1 <<  2)\t// debugger\n#define BREAK_FLAG\t\t\t(1 <<  3)\t// debugger\n#define SCAN_KEYS_FLAG\t\t(1 <<  4)\t// CPU\n#define HALTED_FLAG\t\t\t(1 << 12)\t// APU\n#define FRAME_ADVANCE_FLAG\t(1 <<  9)\n\n#define ROM_NAME_LEN\t23\n#define AUTO_FRAMERATE\t200\n\nstruct SCPUState\n{\n\tuint32\tFlags;\n\tint32\tCycles;\n\tint32\tPrevCycles;\n\tint32\tV_Counter;\n\tuint8\t*PCBase;\n\tbool8\tNMIPending;\n\tbool8\tIRQLine;\n\tbool8\tIRQTransition;\n\tbool8\tIRQLastState;\n\tbool8\tIRQExternal;\n\tint32\tIRQPending;\n\tint32\tMemSpeed;\n\tint32\tMemSpeedx2;\n\tint32\tFastROMSpeed;\n\tbool8\tInDMA;\n\tbool8\tInHDMA;\n\tbool8\tInDMAorHDMA;\n\tbool8\tInWRAMDMAorHDMA;\n\tuint8\tHDMARanInDMA;\n\tint32\tCurrentDMAorHDMAChannel;\n\tuint8\tWhichEvent;\n\tint32\tNextEvent;\n\tbool8\tWaitingForInterrupt;\n\tuint32\tAutoSaveTimer;\n\tbool8\tSRAMModified;\n};\n\nenum\n{\n\tHC_HBLANK_START_EVENT = 1,\n\tHC_HDMA_START_EVENT   = 2,\n\tHC_HCOUNTER_MAX_EVENT = 3,\n\tHC_HDMA_INIT_EVENT    = 4,\n\tHC_RENDER_EVENT       = 5,\n\tHC_WRAM_REFRESH_EVENT = 6\n};\n\nenum\n{\n\tIRQ_NONE        = 0x0,\n\tIRQ_SET_FLAG    = 0x1,\n\tIRQ_CLEAR_FLAG  = 0x2,\n\tIRQ_TRIGGER_NMI = 0x4\n};\n\nstruct STimings\n{\n\tint32\tH_Max_Master;\n\tint32\tH_Max;\n\tint32\tV_Max_Master;\n\tint32\tV_Max;\n\tint32\tHBlankStart;\n\tint32\tHBlankEnd;\n\tint32\tHDMAInit;\n\tint32\tHDMAStart;\n\tint32\tNMITriggerPos;\n\tint32\tNextIRQTimer;\n\tint32\tIRQTriggerCycles;\n\tint32\tWRAMRefreshPos;\n\tint32\tRenderPos;\n\tbool8\tInterlaceField;\n\tint32\tDMACPUSync;\t\t// The cycles to synchronize DMA and CPU. Snes9x cannot emulate correctly.\n\tint32\tNMIDMADelay;\t// The delay of NMI trigger after DMA transfers. Snes9x cannot emulate correctly.\n\tint32\tIRQFlagChanging;\t// This value is just a hack.\n\tint32\tAPUSpeedup;\n\tbool8\tAPUAllowTimeOverflow;\n};\n\nstruct SSettings\n{\n\tbool8\tTraceDMA;\n\tbool8\tTraceHDMA;\n\tbool8\tTraceVRAM;\n\tbool8\tTraceUnknownRegisters;\n\tbool8\tTraceDSP;\n\tbool8\tTraceHCEvent;\n\tbool8\tTraceSMP;\n\n\tbool8\tSuperFX;\n\tuint8\tDSP;\n\tbool8\tSA1;\n\tbool8\tC4;\n\tbool8\tSDD1;\n\tbool8\tSPC7110;\n\tbool8\tSPC7110RTC;\n\tbool8\tOBC1;\n\tuint8\tSETA;\n\tbool8\tSRTC;\n\tbool8\tBS;\n\tbool8\tBSXItself;\n\tbool8\tBSXBootup;\n\tbool8\tMSU1;\n\tbool8\tMouseMaster;\n\tbool8\tSuperScopeMaster;\n\tbool8\tJustifierMaster;\n\tbool8\tMultiPlayer5Master;\n\tbool8\tMacsRifleMaster;\n\n\tbool8\tForceLoROM;\n\tbool8\tForceHiROM;\n\tbool8\tForceHeader;\n\tbool8\tForceNoHeader;\n\tbool8\tForceInterleaved;\n\tbool8\tForceInterleaved2;\n\tbool8\tForceInterleaveGD24;\n\tbool8\tForceNotInterleaved;\n\tbool8\tForcePAL;\n\tbool8\tForceNTSC;\n\tbool8\tPAL;\n\tuint32\tFrameTimePAL;\n\tuint32\tFrameTimeNTSC;\n\tuint32\tFrameTime;\n\n\tbool8\tSoundSync;\n\tbool8\tSixteenBitSound;\n\tuint32\tSoundPlaybackRate;\n\tuint32\tSoundInputRate;\n\tbool8\tStereo;\n\tbool8\tReverseStereo;\n\tbool8\tMute;\n\tbool8\tDynamicRateControl;\n\tint32\tDynamicRateLimit; /* Multiplied by 1000 */\n\tint32\tInterpolationMethod;\n\n\tbool8\tTransparency;\n\tuint8\tBG_Forced;\n\tbool8\tDisableGraphicWindows;\n\tuint16  ForcedBackdrop;\n\n\tbool8\tDisplayTime;\n\tbool8\tDisplayFrameRate;\n\tbool8\tDisplayWatchedAddresses;\n\tbool8\tDisplayPressedKeys;\n\tbool8\tDisplayMovieFrame;\n\tbool\tDisplayIndicators;\n\tbool8\tAutoDisplayMessages;\n\tuint32\tInitialInfoStringTimeout;\n\tuint16\tDisplayColor;\n\tbool8\tBilinearFilter;\n\tbool\tShowOverscan;\n\n\tbool8\tMulti;\n\tchar\tCartAName[PATH_MAX + 1];\n\tchar\tCartBName[PATH_MAX + 1];\n\n\tbool8\tDisableGameSpecificHacks;\n\tbool8\tBlockInvalidVRAMAccessMaster;\n\tbool8\tBlockInvalidVRAMAccess;\n\tint32\tHDMATimingHack;\n\n\tbool8\tForcedPause;\n\tbool8\tPaused;\n\tbool8\tStopEmulation;\n\n\tuint32\tSkipFrames;\n\tuint32\tTurboSkipFrames;\n\tuint32\tAutoMaxSkipFrames;\n\tbool8\tTurboMode;\n\tuint32\tHighSpeedSeek;\n\tbool8\tFrameAdvance;\n\tbool8\tRewinding;\n\n\tbool8\tNetPlay;\n\tbool8\tNetPlayServer;\n\tchar\tServerName[128];\n\tint\t\tPort;\n\n\tbool8\tMovieTruncate;\n\tbool8\tMovieNotifyIgnored;\n\tbool8\tWrongMovieStateProtection;\n\tbool8\tDumpStreams;\n\tint\t\tDumpStreamsMaxFrames;\n\n\tbool8\tTakeScreenshot;\n\tint8\tStretchScreenshots;\n\tbool8\tSnapshotScreenshots;\n\tchar    InitialSnapshotFilename[PATH_MAX + 1];\n\tbool8\tFastSavestates;\n\n\tbool8\tApplyCheats;\n\tbool8\tNoPatch;\n\tbool8\tIgnorePatchChecksum;\n\tbool8\tIsPatched;\n\tint32\tAutoSaveDelay;\n\tbool8\tDontSaveOopsSnapshot;\n\tbool8\tUpAndDown;\n\n    bool8   SeparateEchoBuffer;\n\tuint32\tSuperFXClockMultiplier;\n    int OverclockMode;\n\tint\tOneClockCycle;\n\tint\tOneSlowClockCycle;\n\tint\tTwoClockCycles;\n\tint\tMaxSpriteTilesPerLine;\n};\n\nstruct SSNESGameFixes\n{\n\tuint8\tSRAMInitialValue;\n\tuint8\tUniracers;\n};\n\nenum\n{\n\tPAUSE_NETPLAY_CONNECT\t\t= (1 << 0),\n\tPAUSE_TOGGLE_FULL_SCREEN\t= (1 << 1),\n\tPAUSE_EXIT\t\t\t\t\t= (1 << 2),\n\tPAUSE_MENU\t\t\t\t\t= (1 << 3),\n\tPAUSE_INACTIVE_WINDOW\t\t= (1 << 4),\n\tPAUSE_WINDOW_ICONISED\t\t= (1 << 5),\n\tPAUSE_RESTORE_GUI\t\t\t= (1 << 6),\n\tPAUSE_FREEZE_FILE\t\t\t= (1 << 7)\n};\n\nvoid S9xSetPause(uint32);\nvoid S9xClearPause(uint32);\nvoid S9xExit(void);\nvoid S9xMessage(int, int, const char *);\n\nextern struct SSettings\t\t\tSettings;\nextern struct SCPUState\t\t\tCPU;\nextern struct STimings\t\t\tTimings;\nextern struct SSNESGameFixes\tSNESGameFixes;\nextern char\t\t\t\t\t\tString[513];\n\n#endif\n"
        },
        {
          "name": "spc7110.cpp",
          "type": "blob",
          "size": 8.037109375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n/*****\n * SPC7110 emulator - version 0.03 (2008-08-10)\n * Copyright (c) 2008, byuu and neviksti\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * The software is provided \"as is\" and the author disclaims all warranties\n * with regard to this software including all implied warranties of\n * merchantibility and fitness, in no event shall the author be liable for\n * any special, direct, indirect, or consequential damages or any damages\n * whatsoever resulting from loss of use, data or profits, whether in an\n * action of contract, negligence or other tortious action, arising out of\n * or in connection with the use or performance of this software.\n *****/\n\n\n#include <limits>\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"srtc.h\"\n#include \"display.h\"\n\n#define memory_cartrom_size()\t\tMemory.CalculatedSize\n#define memory_cartrom_read(a)\t\tMemory.ROM[(a)]\n#define memory_cartrtc_read(a)\t\tRTCData.reg[(a)]\n#define memory_cartrtc_write(a, b)\t{ RTCData.reg[(a)] = (b); }\n#define cartridge_info_spc7110rtc\tSettings.SPC7110RTC\n#define cpu_regs_mdr\t\t\t\tOpenBus\n\n#include \"spc7110emu.h\"\n#include \"spc7110emu.cpp\"\n\nSPC7110\ts7emu;\n\nstatic void SetSPC7110SRAMMap (uint8);\n\n\nvoid S9xInitSPC7110 (void)\n{\n\ts7emu.power();\n\tmemset(RTCData.reg, 0, 20);\n}\n\nvoid S9xResetSPC7110 (void)\n{\n\ts7emu.reset();\n}\n\nstatic void SetSPC7110SRAMMap (uint8 newstate)\n{\n\tif (newstate & 0x80)\n\t{\n\t\tMemory.Map[0x006] = (uint8 *) Memory.MAP_HIROM_SRAM;\n\t\tMemory.Map[0x007] = (uint8 *) Memory.MAP_HIROM_SRAM;\n\t\tMemory.Map[0x306] = (uint8 *) Memory.MAP_HIROM_SRAM;\n\t\tMemory.Map[0x307] = (uint8 *) Memory.MAP_HIROM_SRAM;\n\t}\n\telse\n\t{\n\t\tMemory.Map[0x006] = (uint8 *) Memory.MAP_RONLY_SRAM;\n\t\tMemory.Map[0x007] = (uint8 *) Memory.MAP_RONLY_SRAM;\n\t\tMemory.Map[0x306] = (uint8 *) Memory.MAP_RONLY_SRAM;\n\t\tMemory.Map[0x307] = (uint8 *) Memory.MAP_RONLY_SRAM;\n\t}\n}\n\nuint8 * S9xGetBasePointerSPC7110 (uint32 address)\n{\n\tuint32\ti;\n\t\n\tswitch (address & 0xf00000)\n\t{\n\t\tcase 0xd00000:\n\t\t\ti = s7emu.dx_offset;\n\t\t\tbreak;\n\t\t\t\n\t\tcase 0xe00000:\n\t\t\ti = s7emu.ex_offset;\n\t\t\tbreak;\n\t\t\t\n\t\tcase 0xf00000:\n\t\t\ti = s7emu.fx_offset;\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\ti = 0;\n\t\t\tbreak;\n\t}\n\t\n\ti += address & 0x0f0000;\n\n\treturn (&Memory.ROM[i]);\n}\n\nuint8 S9xGetSPC7110Byte (uint32 address)\n{\n\tuint32\ti;\n\n\tswitch (address & 0xf00000)\n\t{\n\t\tcase 0xd00000:\n\t\t\ti = s7emu.dx_offset;\n\t\t\tbreak;\n\n\t\tcase 0xe00000:\n\t\t\ti = s7emu.ex_offset;\n\t\t\tbreak;\n\n\t\tcase 0xf00000:\n\t\t\ti = s7emu.fx_offset;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ti = 0;\n\t\t\tbreak;\n\t}\n\n\ti += address & 0x0fffff;\n\n\treturn (Memory.ROM[i]);\n}\n\nuint8 S9xGetSPC7110 (uint16 address)\n{\n\tif (!Settings.SPC7110RTC && address > 0x483f)\n\t\treturn (OpenBus);\n\t\n\treturn (s7emu.mmio_read(address));\n}\n\nvoid S9xSetSPC7110 (uint8 byte, uint16 address)\n{\n\tif (!Settings.SPC7110RTC && address > 0x483f)\n\t\treturn;\n\n\tif (address == 0x4830)\n\t\tSetSPC7110SRAMMap(byte);\n\n\ts7emu.mmio_write(address, byte);\n}\n\nvoid S9xSPC7110PreSaveState (void)\n{\n\ts7snap.r4801 = s7emu.r4801;\n\ts7snap.r4802 = s7emu.r4802;\n\ts7snap.r4803 = s7emu.r4803;\n\ts7snap.r4804 = s7emu.r4804;\n\ts7snap.r4805 = s7emu.r4805;\n\ts7snap.r4806 = s7emu.r4806;\n\ts7snap.r4807 = s7emu.r4807;\n\ts7snap.r4808 = s7emu.r4808;\n\ts7snap.r4809 = s7emu.r4809;\n\ts7snap.r480a = s7emu.r480a;\n\ts7snap.r480b = s7emu.r480b;\n\ts7snap.r480c = s7emu.r480c;\n\n\ts7snap.r4811 = s7emu.r4811;\n\ts7snap.r4812 = s7emu.r4812;\n\ts7snap.r4813 = s7emu.r4813;\n\ts7snap.r4814 = s7emu.r4814;\n\ts7snap.r4815 = s7emu.r4815;\n\ts7snap.r4816 = s7emu.r4816;\n\ts7snap.r4817 = s7emu.r4817;\n\ts7snap.r4818 = s7emu.r4818;\n\n\ts7snap.r481x = s7emu.r481x;\n\n\ts7snap.r4814_latch = s7emu.r4814_latch ? TRUE : FALSE;\n\ts7snap.r4815_latch = s7emu.r4815_latch ? TRUE : FALSE;\n\n\ts7snap.r4820 = s7emu.r4820;\n\ts7snap.r4821 = s7emu.r4821;\n\ts7snap.r4822 = s7emu.r4822;\n\ts7snap.r4823 = s7emu.r4823;\n\ts7snap.r4824 = s7emu.r4824;\n\ts7snap.r4825 = s7emu.r4825;\n\ts7snap.r4826 = s7emu.r4826;\n\ts7snap.r4827 = s7emu.r4827;\n\ts7snap.r4828 = s7emu.r4828;\n\ts7snap.r4829 = s7emu.r4829;\n\ts7snap.r482a = s7emu.r482a;\n\ts7snap.r482b = s7emu.r482b;\n\ts7snap.r482c = s7emu.r482c;\n\ts7snap.r482d = s7emu.r482d;\n\ts7snap.r482e = s7emu.r482e;\n\ts7snap.r482f = s7emu.r482f;\n\n\ts7snap.r4830 = s7emu.r4830;\n\ts7snap.r4831 = s7emu.r4831;\n\ts7snap.r4832 = s7emu.r4832;\n\ts7snap.r4833 = s7emu.r4833;\n\ts7snap.r4834 = s7emu.r4834;\n\n\ts7snap.dx_offset = (uint32) s7emu.dx_offset;\n\ts7snap.ex_offset = (uint32) s7emu.ex_offset;\n\ts7snap.fx_offset = (uint32) s7emu.fx_offset;\n\n\ts7snap.r4840 = s7emu.r4840;\n\ts7snap.r4841 = s7emu.r4841;\n\ts7snap.r4842 = s7emu.r4842;\n\n\ts7snap.rtc_state = (int32)  s7emu.rtc_state;\n\ts7snap.rtc_mode  = (int32)  s7emu.rtc_mode;\n\ts7snap.rtc_index = (uint32) s7emu.rtc_index;\n\n\ts7snap.decomp_mode   = (uint32) s7emu.decomp.decomp_mode;\n\ts7snap.decomp_offset = (uint32) s7emu.decomp.decomp_offset;\n\n\tfor (int i = 0; i < SPC7110_DECOMP_BUFFER_SIZE; i++)\n\t\ts7snap.decomp_buffer[i] = s7emu.decomp.decomp_buffer[i];\n\n\ts7snap.decomp_buffer_rdoffset = (uint32) s7emu.decomp.decomp_buffer_rdoffset;\n\ts7snap.decomp_buffer_wroffset = (uint32) s7emu.decomp.decomp_buffer_wroffset;\n\ts7snap.decomp_buffer_length   = (uint32) s7emu.decomp.decomp_buffer_length;\n\n\tfor (int i = 0; i < 32; i++)\n\t{\n\t\ts7snap.context[i].index  = s7emu.decomp.context[i].index;\n\t\ts7snap.context[i].invert = s7emu.decomp.context[i].invert;\n\t}\n}\n\nvoid S9xSPC7110PostLoadState (int version)\n{\n\ts7emu.r4801 = s7snap.r4801;\n\ts7emu.r4802 = s7snap.r4802;\n\ts7emu.r4803 = s7snap.r4803;\n\ts7emu.r4804 = s7snap.r4804;\n\ts7emu.r4805 = s7snap.r4805;\n\ts7emu.r4806 = s7snap.r4806;\n\ts7emu.r4807 = s7snap.r4807;\n\ts7emu.r4808 = s7snap.r4808;\n\ts7emu.r4809 = s7snap.r4809;\n\ts7emu.r480a = s7snap.r480a;\n\ts7emu.r480b = s7snap.r480b;\n\ts7emu.r480c = s7snap.r480c;\n\n\ts7emu.r4811 = s7snap.r4811;\n\ts7emu.r4812 = s7snap.r4812;\n\ts7emu.r4813 = s7snap.r4813;\n\ts7emu.r4814 = s7snap.r4814;\n\ts7emu.r4815 = s7snap.r4815;\n\ts7emu.r4816 = s7snap.r4816;\n\ts7emu.r4817 = s7snap.r4817;\n\ts7emu.r4818 = s7snap.r4818;\n\n\ts7emu.r481x = s7snap.r481x;\n\n\ts7emu.r4814_latch = s7snap.r4814_latch ? true : false;\n\ts7emu.r4815_latch = s7snap.r4815_latch ? true : false;\n\n\ts7emu.r4820 = s7snap.r4820;\n\ts7emu.r4821 = s7snap.r4821;\n\ts7emu.r4822 = s7snap.r4822;\n\ts7emu.r4823 = s7snap.r4823;\n\ts7emu.r4824 = s7snap.r4824;\n\ts7emu.r4825 = s7snap.r4825;\n\ts7emu.r4826 = s7snap.r4826;\n\ts7emu.r4827 = s7snap.r4827;\n\ts7emu.r4828 = s7snap.r4828;\n\ts7emu.r4829 = s7snap.r4829;\n\ts7emu.r482a = s7snap.r482a;\n\ts7emu.r482b = s7snap.r482b;\n\ts7emu.r482c = s7snap.r482c;\n\ts7emu.r482d = s7snap.r482d;\n\ts7emu.r482e = s7snap.r482e;\n\ts7emu.r482f = s7snap.r482f;\n\n\ts7emu.r4830 = s7snap.r4830;\n\ts7emu.r4831 = s7snap.r4831;\n\ts7emu.r4832 = s7snap.r4832;\n\ts7emu.r4833 = s7snap.r4833;\n\ts7emu.r4834 = s7snap.r4834;\n\n\ts7emu.dx_offset = (unsigned) s7snap.dx_offset;\n\ts7emu.ex_offset = (unsigned) s7snap.ex_offset;\n\ts7emu.fx_offset = (unsigned) s7snap.fx_offset;\n\n\ts7emu.r4840 = s7snap.r4840;\n\ts7emu.r4841 = s7snap.r4841;\n\ts7emu.r4842 = s7snap.r4842;\n\n\ts7emu.rtc_state = (SPC7110::RTC_State) s7snap.rtc_state;\n\ts7emu.rtc_mode  = (SPC7110::RTC_Mode)  s7snap.rtc_mode;\n\ts7emu.rtc_index = (unsigned)           s7snap.rtc_index;\n\n\ts7emu.decomp.decomp_mode   = (unsigned) s7snap.decomp_mode;\n\ts7emu.decomp.decomp_offset = (unsigned) s7snap.decomp_offset;\n\n\tfor (int i = 0; i < SPC7110_DECOMP_BUFFER_SIZE; i++)\n\t\ts7emu.decomp.decomp_buffer[i] = s7snap.decomp_buffer[i];\n\n\ts7emu.decomp.decomp_buffer_rdoffset = (unsigned) s7snap.decomp_buffer_rdoffset;\n\ts7emu.decomp.decomp_buffer_wroffset = (unsigned) s7snap.decomp_buffer_wroffset;\n\ts7emu.decomp.decomp_buffer_length   = (unsigned) s7snap.decomp_buffer_length;\n\n\tfor (int i = 0; i < 32; i++)\n\t{\n\t\ts7emu.decomp.context[i].index  = s7snap.context[i].index;\n\t\ts7emu.decomp.context[i].invert = s7snap.context[i].invert;\n\t}\n\n\ts7emu.update_time(0);\n}\n"
        },
        {
          "name": "spc7110.h",
          "type": "blob",
          "size": 2.0146484375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _SPC7110_H_\n#define _SPC7110_H_\n\n#define SPC7110_DECOMP_BUFFER_SIZE\t64\n\n// for snapshot only\nstruct SSPC7110Snapshot\n{\n\tuint8\tr4801;\n\tuint8\tr4802;\n\tuint8\tr4803;\n\tuint8\tr4804;\n\tuint8\tr4805;\n\tuint8\tr4806;\n\tuint8\tr4807;\n\tuint8\tr4808;\n\tuint8\tr4809;\n\tuint8\tr480a;\n\tuint8\tr480b;\n\tuint8\tr480c;\n\n\tuint8\tr4811;\n\tuint8\tr4812;\n\tuint8\tr4813;\n\tuint8\tr4814;\n\tuint8\tr4815;\n\tuint8\tr4816;\n\tuint8\tr4817;\n\tuint8\tr4818;\n\n\tuint8\tr481x;\n\n\tbool8\tr4814_latch;\t\t\t// bool\n\tbool8\tr4815_latch;\t\t\t// bool\n\n\tuint8\tr4820;\n\tuint8\tr4821;\n\tuint8\tr4822;\n\tuint8\tr4823;\n\tuint8\tr4824;\n\tuint8\tr4825;\n\tuint8\tr4826;\n\tuint8\tr4827;\n\tuint8\tr4828;\n\tuint8\tr4829;\n\tuint8\tr482a;\n\tuint8\tr482b;\n\tuint8\tr482c;\n\tuint8\tr482d;\n\tuint8\tr482e;\n\tuint8\tr482f;\n\n\tuint8\tr4830;\n\tuint8\tr4831;\n\tuint8\tr4832;\n\tuint8\tr4833;\n\tuint8\tr4834;\n\n\tuint32\tdx_offset;\t\t\t\t// unsigned\n\tuint32\tex_offset;\t\t\t\t// unsigned\n\tuint32\tfx_offset;\t\t\t\t// unsigned\n\n\tuint8\tr4840;\n\tuint8\tr4841;\n\tuint8\tr4842;\n\n\tint32\trtc_state;\t\t\t\t// enum RTC_State\n\tint32\trtc_mode;\t\t\t\t// enum RTC_Mode\n\tuint32\trtc_index;\t\t\t\t// unsigned\n\n\tuint32\tdecomp_mode;\t\t\t// unsigned\n\tuint32\tdecomp_offset;\t\t\t// unsigned\n\n\tuint8\tdecomp_buffer[SPC7110_DECOMP_BUFFER_SIZE];\n\n\tuint32\tdecomp_buffer_rdoffset;\t// unsigned\n\tuint32\tdecomp_buffer_wroffset;\t// unsigned\n\tuint32\tdecomp_buffer_length;\t// unsigned\n\n\tstruct ContextState\n\t{\n\t\tuint8\tindex;\n\t\tuint8\tinvert;\n\t}\tcontext[32];\n};\n\nextern struct SSPC7110Snapshot\ts7snap;\n\nvoid S9xInitSPC7110 (void);\nvoid S9xResetSPC7110 (void);\nvoid S9xSPC7110PreSaveState (void);\nvoid S9xSPC7110PostLoadState (int);\nvoid S9xSetSPC7110 (uint8, uint16);\nuint8 S9xGetSPC7110 (uint16);\nuint8 S9xGetSPC7110Byte (uint32);\nuint8 * S9xGetBasePointerSPC7110 (uint32);\n\n#endif\n"
        },
        {
          "name": "spc7110dec.cpp",
          "type": "blob",
          "size": 14.4013671875,
          "content": "/*****\n * SPC7110 emulator - version 0.03 (2008-08-10)\n * Copyright (c) 2008, byuu and neviksti\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * The software is provided \"as is\" and the author disclaims all warranties\n * with regard to this software including all implied warranties of\n * merchantibility and fitness, in no event shall the author be liable for\n * any special, direct, indirect, or consequential damages or any damages\n * whatsoever resulting from loss of use, data or profits, whether in an\n * action of contract, negligence or other tortious action, arising out of\n * or in connection with the use or performance of this software.\n *****/\n\n\n#ifdef _SPC7110EMU_CPP_\n\nuint8 SPC7110Decomp::read() {\n  if(decomp_buffer_length == 0) {\n    //decompress at least (decomp_buffer_size / 2) bytes to the buffer\n    switch(decomp_mode) {\n      case 0: mode0(false); break;\n      case 1: mode1(false); break;\n      case 2: mode2(false); break;\n      default: return 0x00;\n    }\n  }\n\n  uint8 data = decomp_buffer[decomp_buffer_rdoffset++];\n  decomp_buffer_rdoffset &= decomp_buffer_size - 1;\n  decomp_buffer_length--;\n  return data;\n}\n\nvoid SPC7110Decomp::write(uint8 data) {\n  decomp_buffer[decomp_buffer_wroffset++] = data;\n  decomp_buffer_wroffset &= decomp_buffer_size - 1;\n  decomp_buffer_length++;\n}\n\nuint8 SPC7110Decomp::dataread() {\n  unsigned size = memory_cartrom_size() > 0x500000 ? memory_cartrom_size() - 0x200000 : memory_cartrom_size() - 0x100000;\n  while(decomp_offset >= size) decomp_offset -= size;\n  return memory_cartrom_read(0x100000 + decomp_offset++);\n}\n\nvoid SPC7110Decomp::init(unsigned mode, unsigned offset, unsigned index) {\n  decomp_mode = mode;\n  decomp_offset = offset;\n\n  decomp_buffer_rdoffset = 0;\n  decomp_buffer_wroffset = 0;\n  decomp_buffer_length   = 0;\n\n  //reset context states\n  for(unsigned i = 0; i < 32; i++) {\n    context[i].index  = 0;\n    context[i].invert = 0;\n  }\n\n  switch(decomp_mode) {\n    case 0: mode0(true); break;\n    case 1: mode1(true); break;\n    case 2: mode2(true); break;\n  }\n\n  //decompress up to requested output data index\n  while(index--) read();\n}\n\n//\n\nvoid SPC7110Decomp::mode0(bool init) {\n  static uint8 val, in, span;\n  static int out, inverts, lps, in_count;\n\n  if(init == true) {\n    out = inverts = lps = 0;\n    span = 0xff;\n    val = dataread();\n    in = dataread();\n    in_count = 8;\n    return;\n  }\n\n  while(decomp_buffer_length < (decomp_buffer_size >> 1)) {\n    for(unsigned bit = 0; bit < 8; bit++) {\n      //get context\n      uint8 mask = (1 << (bit & 3)) - 1;\n      uint8 con = mask + ((inverts & mask) ^ (lps & mask));\n      if(bit > 3) con += 15;\n\n      //get prob and mps\n      unsigned prob = probability(con);\n      unsigned mps = (((out >> 15) & 1) ^ context[con].invert);\n\n      //get bit\n      unsigned flag_lps;\n      if(val <= span - prob) { //mps\n        span = span - prob;\n        out = (out << 1) + mps;\n        flag_lps = 0;\n      } else { //lps\n        val = val - (span - (prob - 1));\n        span = prob - 1;\n        out = (out << 1) + 1 - mps;\n        flag_lps = 1;\n      }\n\n      //renormalize\n      unsigned shift = 0;\n      while(span < 0x7f) {\n        shift++;\n\n        span = (span << 1) + 1;\n        val = (val << 1) + (in >> 7);\n\n        in <<= 1;\n        if(--in_count == 0) {\n          in = dataread();\n          in_count = 8;\n        }\n      }\n\n      //update processing info\n      lps = (lps << 1) + flag_lps;\n      inverts = (inverts << 1) + context[con].invert;\n\n      //update context state\n      if(flag_lps & toggle_invert(con)) context[con].invert ^= 1;\n      if(flag_lps) context[con].index = next_lps(con);\n      else if(shift) context[con].index = next_mps(con);\n    }\n\n    //save byte\n    write(out);\n  }\n}\n\nvoid SPC7110Decomp::mode1(bool init) {\n  static unsigned pixelorder[4], realorder[4];\n  static uint8 in, val, span;\n  static int out, inverts, lps, in_count;\n\n  if(init == true) {\n    for(unsigned i = 0; i < 4; i++) pixelorder[i] = i;\n    out = inverts = lps = 0;\n    span = 0xff;\n    val = dataread();\n    in = dataread();\n    in_count = 8;\n    return;\n  }\n\n  while(decomp_buffer_length < (decomp_buffer_size >> 1)) {\n    for(unsigned pixel = 0; pixel < 8; pixel++) {\n      //get first symbol context\n      unsigned a = ((out >> (1 * 2)) & 3);\n      unsigned b = ((out >> (7 * 2)) & 3);\n      unsigned c = ((out >> (8 * 2)) & 3);\n      unsigned con = (a == b) ? (b != c) : (b == c) ? 2 : 4 - (a == c);\n\n      //update pixel order\n      unsigned m, n;\n      for(m = 0; m < 4; m++) if(pixelorder[m] == a) break;\n      for(n = m; n > 0; n--) pixelorder[n] = pixelorder[n - 1];\n      pixelorder[0] = a;\n\n      //calculate the real pixel order\n      for(m = 0; m < 4; m++) realorder[m] = pixelorder[m];\n\n      //rotate reference pixel c value to top\n      for(m = 0; m < 4; m++) if(realorder[m] == c) break;\n      for(n = m; n > 0; n--) realorder[n] = realorder[n - 1];\n      realorder[0] = c;\n\n      //rotate reference pixel b value to top\n      for(m = 0; m < 4; m++) if(realorder[m] == b) break;\n      for(n = m; n > 0; n--) realorder[n] = realorder[n - 1];\n      realorder[0] = b;\n\n      //rotate reference pixel a value to top\n      for(m = 0; m < 4; m++) if(realorder[m] == a) break;\n      for(n = m; n > 0; n--) realorder[n] = realorder[n - 1];\n      realorder[0] = a;\n\n      //get 2 symbols\n      for(unsigned bit = 0; bit < 2; bit++) {\n        //get prob\n        unsigned prob = probability(con);\n\n        //get symbol\n        unsigned flag_lps;\n        if(val <= span - prob) { //mps\n          span = span - prob;\n          flag_lps = 0;\n        } else { //lps\n          val = val - (span - (prob - 1));\n          span = prob - 1;\n          flag_lps = 1;\n        }\n\n        //renormalize\n        unsigned shift = 0;\n        while(span < 0x7f) {\n          shift++;\n\n          span = (span << 1) + 1;\n          val = (val << 1) + (in >> 7);\n\n          in <<= 1;\n          if(--in_count == 0) {\n            in = dataread();\n            in_count = 8;\n          }\n        }\n\n        //update processing info\n        lps = (lps << 1) + flag_lps;\n        inverts = (inverts << 1) + context[con].invert;\n\n        //update context state\n        if(flag_lps & toggle_invert(con)) context[con].invert ^= 1;\n        if(flag_lps) context[con].index = next_lps(con);\n        else if(shift) context[con].index = next_mps(con);\n\n        //get next context\n        con = 5 + (con << 1) + ((lps ^ inverts) & 1);\n      }\n\n      //get pixel\n      b = realorder[(lps ^ inverts) & 3];\n      out = (out << 2) + b;\n    }\n\n    //turn pixel data into bitplanes\n    unsigned data = morton_2x8(out);\n    write(data >> 8);\n    write(data >> 0);\n  }\n}\n\nvoid SPC7110Decomp::mode2(bool init) {\n  static unsigned pixelorder[16], realorder[16];\n  static uint8 bitplanebuffer[16], buffer_index;\n  static uint8 in, val, span;\n  static int out0, out1, inverts, lps, in_count;\n\n  if(init == true) {\n    for(unsigned i = 0; i < 16; i++) pixelorder[i] = i;\n    buffer_index = 0;\n    out0 = out1 = inverts = lps = 0;\n    span = 0xff;\n    val = dataread();\n    in = dataread();\n    in_count = 8;\n    return;\n  }\n\n  while(decomp_buffer_length < (decomp_buffer_size >> 1)) {\n    for(unsigned pixel = 0; pixel < 8; pixel++) {\n      //get first symbol context\n      unsigned a = ((out0 >> (0 * 4)) & 15);\n      unsigned b = ((out0 >> (7 * 4)) & 15);\n      unsigned c = ((out1 >> (0 * 4)) & 15);\n      unsigned con = 0;\n      unsigned refcon = (a == b) ? (b != c) : (b == c) ? 2 : 4 - (a == c);\n\n      //update pixel order\n      unsigned m, n;\n      for(m = 0; m < 16; m++) if(pixelorder[m] == a) break;\n      for(n = m; n >  0; n--) pixelorder[n] = pixelorder[n - 1];\n      pixelorder[0] = a;\n\n      //calculate the real pixel order\n      for(m = 0; m < 16; m++) realorder[m] = pixelorder[m];\n\n      //rotate reference pixel c value to top\n      for(m = 0; m < 16; m++) if(realorder[m] == c) break;\n      for(n = m; n >  0; n--) realorder[n] = realorder[n - 1];\n      realorder[0] = c;\n\n      //rotate reference pixel b value to top\n      for(m = 0; m < 16; m++) if(realorder[m] == b) break;\n      for(n = m; n >  0; n--) realorder[n] = realorder[n - 1];\n      realorder[0] = b;\n\n      //rotate reference pixel a value to top\n      for(m = 0; m < 16; m++) if(realorder[m] == a) break;\n      for(n = m; n >  0; n--) realorder[n] = realorder[n - 1];\n      realorder[0] = a;\n\n      //get 4 symbols\n      for(unsigned bit = 0; bit < 4; bit++) {\n        //get prob\n        unsigned prob = probability(con);\n\n        //get symbol\n        unsigned flag_lps;\n        if(val <= span - prob) { //mps\n          span = span - prob;\n          flag_lps = 0;\n        } else { //lps\n          val = val - (span - (prob - 1));\n          span = prob - 1;\n          flag_lps = 1;\n        }\n\n        //renormalize\n        unsigned shift = 0;\n        while(span < 0x7f) {\n          shift++;\n\n          span = (span << 1) + 1;\n          val = (val << 1) + (in >> 7);\n\n          in <<= 1;\n          if(--in_count == 0) {\n            in = dataread();\n            in_count = 8;\n          }\n        }\n\n        //update processing info\n        lps = (lps << 1) + flag_lps;\n        unsigned invertbit = context[con].invert;\n        inverts = (inverts << 1) + invertbit;\n\n        //update context state\n        if(flag_lps & toggle_invert(con)) context[con].invert ^= 1;\n        if(flag_lps) context[con].index = next_lps(con);\n        else if(shift) context[con].index = next_mps(con);\n\n        //get next context\n        con = mode2_context_table[con][flag_lps ^ invertbit] + (con == 1 ? refcon : 0);\n      }\n\n      //get pixel\n      b = realorder[(lps ^ inverts) & 0x0f];\n      out1 = (out1 << 4) + ((out0 >> 28) & 0x0f);\n      out0 = (out0 << 4) + b;\n    }\n\n    //convert pixel data into bitplanes\n    unsigned data = morton_4x8(out0);\n    write(data >> 24);\n    write(data >> 16);\n    bitplanebuffer[buffer_index++] = data >> 8;\n    bitplanebuffer[buffer_index++] = data >> 0;\n\n    if(buffer_index == 16) {\n      for(unsigned i = 0; i < 16; i++) write(bitplanebuffer[i]);\n      buffer_index = 0;\n    }\n  }\n}\n\n//\n\nconst uint8 SPC7110Decomp::evolution_table[53][4] = {\n//{ prob, nextlps, nextmps, toggle invert },\n\n  { 0x5a,  1,  1, 1 },\n  { 0x25,  6,  2, 0 },\n  { 0x11,  8,  3, 0 },\n  { 0x08, 10,  4, 0 },\n  { 0x03, 12,  5, 0 },\n  { 0x01, 15,  5, 0 },\n\n  { 0x5a,  7,  7, 1 },\n  { 0x3f, 19,  8, 0 },\n  { 0x2c, 21,  9, 0 },\n  { 0x20, 22, 10, 0 },\n  { 0x17, 23, 11, 0 },\n  { 0x11, 25, 12, 0 },\n  { 0x0c, 26, 13, 0 },\n  { 0x09, 28, 14, 0 },\n  { 0x07, 29, 15, 0 },\n  { 0x05, 31, 16, 0 },\n  { 0x04, 32, 17, 0 },\n  { 0x03, 34, 18, 0 },\n  { 0x02, 35,  5, 0 },\n\n  { 0x5a, 20, 20, 1 },\n  { 0x48, 39, 21, 0 },\n  { 0x3a, 40, 22, 0 },\n  { 0x2e, 42, 23, 0 },\n  { 0x26, 44, 24, 0 },\n  { 0x1f, 45, 25, 0 },\n  { 0x19, 46, 26, 0 },\n  { 0x15, 25, 27, 0 },\n  { 0x11, 26, 28, 0 },\n  { 0x0e, 26, 29, 0 },\n  { 0x0b, 27, 30, 0 },\n  { 0x09, 28, 31, 0 },\n  { 0x08, 29, 32, 0 },\n  { 0x07, 30, 33, 0 },\n  { 0x05, 31, 34, 0 },\n  { 0x04, 33, 35, 0 },\n  { 0x04, 33, 36, 0 },\n  { 0x03, 34, 37, 0 },\n  { 0x02, 35, 38, 0 },\n  { 0x02, 36,  5, 0 },\n\n  { 0x58, 39, 40, 1 },\n  { 0x4d, 47, 41, 0 },\n  { 0x43, 48, 42, 0 },\n  { 0x3b, 49, 43, 0 },\n  { 0x34, 50, 44, 0 },\n  { 0x2e, 51, 45, 0 },\n  { 0x29, 44, 46, 0 },\n  { 0x25, 45, 24, 0 },\n\n  { 0x56, 47, 48, 1 },\n  { 0x4f, 47, 49, 0 },\n  { 0x47, 48, 50, 0 },\n  { 0x41, 49, 51, 0 },\n  { 0x3c, 50, 52, 0 },\n  { 0x37, 51, 43, 0 },\n};\n\nconst uint8 SPC7110Decomp::mode2_context_table[32][2] = {\n//{ next 0, next 1 },\n\n  {  1,  2 },\n\n  {  3,  8 },\n  { 13, 14 },\n\n  { 15, 16 },\n  { 17, 18 },\n  { 19, 20 },\n  { 21, 22 },\n  { 23, 24 },\n  { 25, 26 },\n  { 25, 26 },\n  { 25, 26 },\n  { 25, 26 },\n  { 25, 26 },\n  { 27, 28 },\n  { 29, 30 },\n\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n  { 31, 31 },\n\n  { 31, 31 },\n};\n\nuint8 SPC7110Decomp::probability  (unsigned n) { return evolution_table[context[n].index][0]; }\nuint8 SPC7110Decomp::next_lps     (unsigned n) { return evolution_table[context[n].index][1]; }\nuint8 SPC7110Decomp::next_mps     (unsigned n) { return evolution_table[context[n].index][2]; }\nuint8  SPC7110Decomp::toggle_invert(unsigned n) { return evolution_table[context[n].index][3]; }\n\nunsigned SPC7110Decomp::morton_2x8(unsigned data) {\n  //reverse morton lookup: de-interleave two 8-bit values\n  //15, 13, 11,  9,  7,  5,  3,  1 -> 15- 8\n  //14, 12, 10,  8,  6,  4,  2,  0 ->  7- 0\n  return morton16[0][(data >>  0) & 255] + morton16[1][(data >>  8) & 255];\n}\n\nunsigned SPC7110Decomp::morton_4x8(unsigned data) {\n  //reverse morton lookup: de-interleave four 8-bit values\n  //31, 27, 23, 19, 15, 11,  7,  3 -> 31-24\n  //30, 26, 22, 18, 14, 10,  6,  2 -> 23-16\n  //29, 25, 21, 17, 13,  9,  5,  1 -> 15- 8\n  //28, 24, 20, 16, 12,  8,  4,  0 ->  7- 0\n  return morton32[0][(data >>  0) & 255] + morton32[1][(data >>  8) & 255]\n       + morton32[2][(data >> 16) & 255] + morton32[3][(data >> 24) & 255];\n}\n\n//\n\nvoid SPC7110Decomp::reset() {\n  //mode 3 is invalid; this is treated as a special case to always return 0x00\n  //set to mode 3 so that reading decomp port before starting first decomp will return 0x00\n  decomp_mode = 3;\n\n  decomp_buffer_rdoffset = 0;\n  decomp_buffer_wroffset = 0;\n  decomp_buffer_length   = 0;\n}\n\nSPC7110Decomp::SPC7110Decomp() {\n  decomp_buffer = new uint8[decomp_buffer_size];\n  reset();\n\n  //initialize reverse morton lookup tables\n  for(unsigned i = 0; i < 256; i++) {\n    #define map(x, y) (((i >> x) & 1) << y)\n    //2x8-bit\n    morton16[1][i] = map(7, 15) + map(6,  7) + map(5, 14) + map(4,  6)\n                   + map(3, 13) + map(2,  5) + map(1, 12) + map(0,  4);\n    morton16[0][i] = map(7, 11) + map(6,  3) + map(5, 10) + map(4,  2)\n                   + map(3,  9) + map(2,  1) + map(1,  8) + map(0,  0);\n    //4x8-bit\n    morton32[3][i] = map(7, 31) + map(6, 23) + map(5, 15) + map(4,  7)\n                   + map(3, 30) + map(2, 22) + map(1, 14) + map(0,  6);\n    morton32[2][i] = map(7, 29) + map(6, 21) + map(5, 13) + map(4,  5)\n                   + map(3, 28) + map(2, 20) + map(1, 12) + map(0,  4);\n    morton32[1][i] = map(7, 27) + map(6, 19) + map(5, 11) + map(4,  3)\n                   + map(3, 26) + map(2, 18) + map(1, 10) + map(0,  2);\n    morton32[0][i] = map(7, 25) + map(6, 17) + map(5,  9) + map(4,  1)\n                   + map(3, 24) + map(2, 16) + map(1,  8) + map(0,  0);\n    #undef map\n  }\n}\n\nSPC7110Decomp::~SPC7110Decomp() {\n  delete[] decomp_buffer;\n}\n\n#endif\n"
        },
        {
          "name": "spc7110dec.h",
          "type": "blob",
          "size": 1.919921875,
          "content": "/*****\n * SPC7110 emulator - version 0.03 (2008-08-10)\n * Copyright (c) 2008, byuu and neviksti\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * The software is provided \"as is\" and the author disclaims all warranties\n * with regard to this software including all implied warranties of\n * merchantibility and fitness, in no event shall the author be liable for\n * any special, direct, indirect, or consequential damages or any damages\n * whatsoever resulting from loss of use, data or profits, whether in an\n * action of contract, negligence or other tortious action, arising out of\n * or in connection with the use or performance of this software.\n *****/\n\n\n#ifndef _SPC7110DEC_H_\n#define _SPC7110DEC_H_\n\nclass SPC7110Decomp {\npublic:\n  uint8 read();\n  void init(unsigned mode, unsigned offset, unsigned index);\n  void reset();\n\n  SPC7110Decomp();\n  ~SPC7110Decomp();\n\n  unsigned decomp_mode;\n  unsigned decomp_offset;\n\n  //read() will spool chunks half the size of decomp_buffer_size\n  enum { decomp_buffer_size = SPC7110_DECOMP_BUFFER_SIZE }; //must be >= 64, and must be a power of two\n  uint8 *decomp_buffer;\n  unsigned decomp_buffer_rdoffset;\n  unsigned decomp_buffer_wroffset;\n  unsigned decomp_buffer_length;\n\n  void write(uint8 data);\n  uint8 dataread();\n\n  void mode0(bool init);\n  void mode1(bool init);\n  void mode2(bool init);\n\n  static const uint8 evolution_table[53][4];\n  static const uint8 mode2_context_table[32][2];\n\n  struct ContextState {\n    uint8 index;\n    uint8 invert;\n  } context[32];\n\n  uint8 probability(unsigned n);\n  uint8 next_lps(unsigned n);\n  uint8 next_mps(unsigned n);\n  uint8 toggle_invert(unsigned n);\n\n  unsigned morton16[2][256];\n  unsigned morton32[4][256];\n  unsigned morton_2x8(unsigned data);\n  unsigned morton_4x8(unsigned data);\n};\n\n#endif\n"
        },
        {
          "name": "spc7110emu.cpp",
          "type": "blob",
          "size": 17.25390625,
          "content": "/*****\n * SPC7110 emulator - version 0.03 (2008-08-10)\n * Copyright (c) 2008, byuu and neviksti\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * The software is provided \"as is\" and the author disclaims all warranties\n * with regard to this software including all implied warranties of\n * merchantibility and fitness, in no event shall the author be liable for\n * any special, direct, indirect, or consequential damages or any damages\n * whatsoever resulting from loss of use, data or profits, whether in an\n * action of contract, negligence or other tortious action, arising out of\n * or in connection with the use or performance of this software.\n *****/\n\n\n#define _SPC7110EMU_CPP_\n\n#include \"spc7110dec.cpp\"\n\nconst unsigned SPC7110::months[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\n\nvoid SPC7110::power() {\n  reset();\n}\n\nvoid SPC7110::reset() {\n  r4801 = 0x00;\n  r4802 = 0x00;\n  r4803 = 0x00;\n  r4804 = 0x00;\n  r4805 = 0x00;\n  r4806 = 0x00;\n  r4807 = 0x00;\n  r4808 = 0x00;\n  r4809 = 0x00;\n  r480a = 0x00;\n  r480b = 0x00;\n  r480c = 0x00;\n\n  decomp.reset();\n\n  r4811 = 0x00;\n  r4812 = 0x00;\n  r4813 = 0x00;\n  r4814 = 0x00;\n  r4815 = 0x00;\n  r4816 = 0x00;\n  r4817 = 0x00;\n  r4818 = 0x00;\n\n  r481x = 0x00;\n  r4814_latch = false;\n  r4815_latch = false;\n\n  r4820 = 0x00;\n  r4821 = 0x00;\n  r4822 = 0x00;\n  r4823 = 0x00;\n  r4824 = 0x00;\n  r4825 = 0x00;\n  r4826 = 0x00;\n  r4827 = 0x00;\n  r4828 = 0x00;\n  r4829 = 0x00;\n  r482a = 0x00;\n  r482b = 0x00;\n  r482c = 0x00;\n  r482d = 0x00;\n  r482e = 0x00;\n  r482f = 0x00;\n\n  r4830 = 0x00;\n  mmio_write(0x4831, 0);\n  mmio_write(0x4832, 1);\n  mmio_write(0x4833, 2);\n  r4834 = 0x00;\n\n  r4840 = 0x00;\n  r4841 = 0x00;\n  r4842 = 0x00;\n\n  if(cartridge_info_spc7110rtc) {\n    rtc_state = RTCS_Inactive;\n    rtc_mode  = RTCM_Linear;\n    rtc_index = 0;\n  }\n}\n\nunsigned SPC7110::datarom_addr(unsigned addr) {\n  unsigned size = memory_cartrom_size() > 0x500000 ? memory_cartrom_size() - 0x200000 : memory_cartrom_size() - 0x100000;\n  while(addr >= size) addr -= size;\n  return addr + 0x100000;\n}\n\nunsigned SPC7110::data_pointer()   { return r4811 + (r4812 << 8) + (r4813 << 16); }\nunsigned SPC7110::data_adjust()    { return r4814 + (r4815 << 8); }\nunsigned SPC7110::data_increment() { return r4816 + (r4817 << 8); }\nvoid SPC7110::set_data_pointer(unsigned addr) { r4811 = addr; r4812 = addr >> 8; r4813 = addr >> 16; }\nvoid SPC7110::set_data_adjust(unsigned addr)  { r4814 = addr; r4815 = addr >> 8; }\n\nvoid SPC7110::update_time(int offset) {\n  time_t rtc_time\n  = (memory_cartrtc_read(16) <<  0)\n  | (memory_cartrtc_read(17) <<  8)\n  | (memory_cartrtc_read(18) << 16)\n  | (memory_cartrtc_read(19) << 24);\n  time_t current_time = time(0) - offset;\n\n  //sizeof(time_t) is platform-dependent; though memory::cartrtc needs to be platform-agnostic.\n  //yet platforms with 32-bit signed time_t will overflow every ~68 years. handle this by\n  //accounting for overflow at the cost of 1-bit precision (to catch underflow). this will allow\n  //memory::cartrtc timestamp to remain valid for up to ~34 years from the last update, even if\n  //time_t overflows. calculation should be valid regardless of number representation, time_t size,\n  //or whether time_t is signed or unsigned.\n  time_t diff\n  = (current_time >= rtc_time)\n  ? (current_time - rtc_time)\n  : (std::numeric_limits<time_t>::max() - rtc_time + current_time + 1);  //compensate for overflow\n  if(diff > std::numeric_limits<time_t>::max() / 2) diff = 0;            //compensate for underflow\n\n  bool update = true;\n  if(memory_cartrtc_read(13) & 1) update = false;  //do not update if CR0 timer disable flag is set\n  if(memory_cartrtc_read(15) & 3) update = false;  //do not update if CR2 timer disable flags are set\n\n  if(diff > 0 && update == true) {\n    unsigned second  = memory_cartrtc_read( 0) + memory_cartrtc_read( 1) * 10;\n    unsigned minute  = memory_cartrtc_read( 2) + memory_cartrtc_read( 3) * 10;\n    unsigned hour    = memory_cartrtc_read( 4) + memory_cartrtc_read( 5) * 10;\n    unsigned day     = memory_cartrtc_read( 6) + memory_cartrtc_read( 7) * 10;\n    unsigned month   = memory_cartrtc_read( 8) + memory_cartrtc_read( 9) * 10;\n    unsigned year    = memory_cartrtc_read(10) + memory_cartrtc_read(11) * 10;\n    unsigned weekday = memory_cartrtc_read(12);\n\n    day--;\n    month--;\n    year += (year >= 90) ? 1900 : 2000;  //range = 1990-2089\n\n    second += diff;\n    while(second >= 60) {\n      second -= 60;\n\n      minute++;\n      if(minute < 60) continue;\n      minute = 0;\n\n      hour++;\n      if(hour < 24) continue;\n      hour = 0;\n\n      day++;\n      weekday = (weekday + 1) % 7;\n      unsigned days = months[month % 12];\n      if(days == 28) {\n        bool leapyear = false;\n        if((year % 4) == 0) {\n          leapyear = true;\n          if((year % 100) == 0 && (year % 400) != 0) leapyear = false;\n        }\n        if(leapyear) days++;\n      }\n      if(day < days) continue;\n      day = 0;\n\n      month++;\n      if(month < 12) continue;\n      month = 0;\n\n      year++;\n    }\n\n    day++;\n    month++;\n    year %= 100;\n\n    memory_cartrtc_write( 0, second % 10);\n    memory_cartrtc_write( 1, second / 10);\n    memory_cartrtc_write( 2, minute % 10);\n    memory_cartrtc_write( 3, minute / 10);\n    memory_cartrtc_write( 4, hour % 10);\n    memory_cartrtc_write( 5, hour / 10);\n    memory_cartrtc_write( 6, day % 10);\n    memory_cartrtc_write( 7, day / 10);\n    memory_cartrtc_write( 8, month % 10);\n    memory_cartrtc_write( 9, month / 10);\n    memory_cartrtc_write(10, year % 10);\n    memory_cartrtc_write(11, (year / 10) % 10);\n    memory_cartrtc_write(12, weekday % 7);\n  }\n\n  memory_cartrtc_write(16, current_time >>  0);\n  memory_cartrtc_write(17, current_time >>  8);\n  memory_cartrtc_write(18, current_time >> 16);\n  memory_cartrtc_write(19, current_time >> 24);\n}\n\nuint8 SPC7110::mmio_read(unsigned addr) {\n  addr &= 0xffff;\n\n  switch(addr) {\n    //==================\n    //decompression unit\n    //==================\n\n    case 0x4800: {\n      uint16 counter = (r4809 + (r480a << 8));\n      counter--;\n      r4809 = counter;\n      r480a = counter >> 8;\n      return decomp.read();\n    }\n    case 0x4801: return r4801;\n    case 0x4802: return r4802;\n    case 0x4803: return r4803;\n    case 0x4804: return r4804;\n    case 0x4805: return r4805;\n    case 0x4806: return r4806;\n    case 0x4807: return r4807;\n    case 0x4808: return r4808;\n    case 0x4809: return r4809;\n    case 0x480a: return r480a;\n    case 0x480b: return r480b;\n    case 0x480c: {\n      uint8 status = r480c;\n      r480c &= 0x7f;\n      return status;\n    }\n\n    //==============\n    //data port unit\n    //==============\n\n    case 0x4810: {\n      if(r481x != 0x07) return 0x00;\n\n      unsigned addr = data_pointer();\n      unsigned adjust = data_adjust();\n      if(r4818 & 8) adjust = (int16)adjust;  //16-bit sign extend\n\n      unsigned adjustaddr = addr;\n      if(r4818 & 2) {\n        adjustaddr += adjust;\n        set_data_adjust(adjust + 1);\n      }\n\n      uint8 data = memory_cartrom_read(datarom_addr(adjustaddr));\n      if(!(r4818 & 2)) {\n        unsigned increment = (r4818 & 1) ? data_increment() : 1;\n        if(r4818 & 4) increment = (int16)increment;  //16-bit sign extend\n\n        if((r4818 & 16) == 0) {\n          set_data_pointer(addr + increment);\n        } else {\n          set_data_adjust(adjust + increment);\n        }\n      }\n\n      return data;\n    }\n    case 0x4811: return r4811;\n    case 0x4812: return r4812;\n    case 0x4813: return r4813;\n    case 0x4814: return r4814;\n    case 0x4815: return r4815;\n    case 0x4816: return r4816;\n    case 0x4817: return r4817;\n    case 0x4818: return r4818;\n    case 0x481a: {\n      if(r481x != 0x07) return 0x00;\n\n      unsigned addr = data_pointer();\n      unsigned adjust = data_adjust();\n      if(r4818 & 8) adjust = (int16)adjust;  //16-bit sign extend\n\n      uint8 data = memory_cartrom_read(datarom_addr(addr + adjust));\n      if((r4818 & 0x60) == 0x60) {\n        if((r4818 & 16) == 0) {\n          set_data_pointer(addr + adjust);\n        } else {\n          set_data_adjust(adjust + adjust);\n        }\n      }\n\n      return data;\n    }\n\n    //=========\n    //math unit\n    //=========\n\n    case 0x4820: return r4820;\n    case 0x4821: return r4821;\n    case 0x4822: return r4822;\n    case 0x4823: return r4823;\n    case 0x4824: return r4824;\n    case 0x4825: return r4825;\n    case 0x4826: return r4826;\n    case 0x4827: return r4827;\n    case 0x4828: return r4828;\n    case 0x4829: return r4829;\n    case 0x482a: return r482a;\n    case 0x482b: return r482b;\n    case 0x482c: return r482c;\n    case 0x482d: return r482d;\n    case 0x482e: return r482e;\n    case 0x482f: {\n      uint8 status = r482f;\n      r482f &= 0x7f;\n      return status;\n    }\n\n    //===================\n    //memory mapping unit\n    //===================\n\n    case 0x4830: return r4830;\n    case 0x4831: return r4831;\n    case 0x4832: return r4832;\n    case 0x4833: return r4833;\n    case 0x4834: return r4834;\n\n    //====================\n    //real-time clock unit\n    //====================\n\n    case 0x4840: return r4840;\n    case 0x4841: {\n      if(rtc_state == RTCS_Inactive || rtc_state == RTCS_ModeSelect) return 0x00;\n\n      r4842 = 0x80;\n      uint8 data = memory_cartrtc_read(rtc_index);\n      rtc_index = (rtc_index + 1) & 15;\n      return data;\n    }\n    case 0x4842: {\n      uint8 status = r4842;\n      r4842 &= 0x7f;\n      return status;\n    }\n  }\n\n  return cpu_regs_mdr;\n}\n\nvoid SPC7110::mmio_write(unsigned addr, uint8 data) {\n  addr &= 0xffff;\n\n  switch(addr) {\n    //==================\n    //decompression unit\n    //==================\n\n    case 0x4801: r4801 = data; break;\n    case 0x4802: r4802 = data; break;\n    case 0x4803: r4803 = data; break;\n    case 0x4804: r4804 = data; break;\n    case 0x4805: r4805 = data; break;\n    case 0x4806: {\n      r4806 = data;\n\n      unsigned table   = (r4801 + (r4802 << 8) + (r4803 << 16));\n      unsigned index   = (r4804 << 2);\n      //unsigned length  = (r4809 + (r480a << 8));\n      unsigned addr    = datarom_addr(table + index);\n      unsigned mode    = (memory_cartrom_read(addr + 0));\n      unsigned offset  = (memory_cartrom_read(addr + 1) << 16)\n                       + (memory_cartrom_read(addr + 2) <<  8)\n                       + (memory_cartrom_read(addr + 3) <<  0);\n\n      decomp.init(mode, offset, (r4805 + (r4806 << 8)) << mode);\n      r480c = 0x80;\n    } break;\n\n    case 0x4807: r4807 = data; break;\n    case 0x4808: r4808 = data; break;\n    case 0x4809: r4809 = data; break;\n    case 0x480a: r480a = data; break;\n    case 0x480b: r480b = data; break;\n\n    //==============\n    //data port unit\n    //==============\n\n    case 0x4811: r4811 = data; r481x |= 0x01; break;\n    case 0x4812: r4812 = data; r481x |= 0x02; break;\n    case 0x4813: r4813 = data; r481x |= 0x04; break;\n    case 0x4814: {\n      r4814 = data;\n      r4814_latch = true;\n      if(!r4815_latch) break;\n      if(!(r4818 & 2)) break;\n      if(r4818 & 0x10) break;\n\n      if((r4818 & 0x60) == 0x20) {\n        unsigned increment = data_adjust() & 0xff;\n        if(r4818 & 8) increment = (int8)increment;  //8-bit sign extend\n        set_data_pointer(data_pointer() + increment);\n      } else if((r4818 & 0x60) == 0x40) {\n        unsigned increment = data_adjust();\n        if(r4818 & 8) increment = (int16)increment;  //16-bit sign extend\n        set_data_pointer(data_pointer() + increment);\n      }\n    } break;\n    case 0x4815: {\n      r4815 = data;\n      r4815_latch = true;\n      if(!r4814_latch) break;\n      if(!(r4818 & 2)) break;\n      if(r4818 & 0x10) break;\n\n      if((r4818 & 0x60) == 0x20) {\n        unsigned increment = data_adjust() & 0xff;\n        if(r4818 & 8) increment = (int8)increment;  //8-bit sign extend\n        set_data_pointer(data_pointer() + increment);\n      } else if((r4818 & 0x60) == 0x40) {\n        unsigned increment = data_adjust();\n        if(r4818 & 8) increment = (int16)increment;  //16-bit sign extend\n        set_data_pointer(data_pointer() + increment);\n      }\n    } break;\n    case 0x4816: r4816 = data; break;\n    case 0x4817: r4817 = data; break;\n    case 0x4818: {\n      if(r481x != 0x07) break;\n\n      r4818 = data;\n      r4814_latch = r4815_latch = false;\n    } break;\n\n    //=========\n    //math unit\n    //=========\n\n    case 0x4820: r4820 = data; break;\n    case 0x4821: r4821 = data; break;\n    case 0x4822: r4822 = data; break;\n    case 0x4823: r4823 = data; break;\n    case 0x4824: r4824 = data; break;\n    case 0x4825: {\n      r4825 = data;\n\n      if(r482e & 1) {\n        //signed 16-bit x 16-bit multiplication\n        int16 r0 = (int16)(r4824 + (r4825 << 8));\n        int16 r1 = (int16)(r4820 + (r4821 << 8));\n\n        signed result = r0 * r1;\n        r4828 = result;\n        r4829 = result >> 8;\n        r482a = result >> 16;\n        r482b = result >> 24;\n      } else {\n        //unsigned 16-bit x 16-bit multiplication\n        uint16 r0 = (uint16)(r4824 + (r4825 << 8));\n        uint16 r1 = (uint16)(r4820 + (r4821 << 8));\n\n        unsigned result = r0 * r1;\n        r4828 = result;\n        r4829 = result >> 8;\n        r482a = result >> 16;\n        r482b = result >> 24;\n      }\n\n      r482f = 0x80;\n    } break;\n    case 0x4826: r4826 = data; break;\n    case 0x4827: {\n      r4827 = data;\n\n      if(r482e & 1) {\n        //signed 32-bit x 16-bit division\n        int32 dividend = (int32)(r4820 + (r4821 << 8) + (r4822 << 16) + (r4823 << 24));\n        int16 divisor  = (int16)(r4826 + (r4827 << 8));\n\n        int32 quotient;\n        int16 remainder;\n\n        if(divisor) {\n          quotient  = (int32)(dividend / divisor);\n          remainder = (int32)(dividend % divisor);\n        } else {\n          //illegal division by zero\n          quotient  = 0;\n          remainder = dividend & 0xffff;\n        }\n\n        r4828 = quotient;\n        r4829 = quotient >> 8;\n        r482a = quotient >> 16;\n        r482b = quotient >> 24;\n\n        r482c = remainder;\n        r482d = remainder >> 8;\n      } else {\n        //unsigned 32-bit x 16-bit division\n        uint32 dividend = (uint32)(r4820 + (r4821 << 8) + (r4822 << 16) + (r4823 << 24));\n        uint16 divisor  = (uint16)(r4826 + (r4827 << 8));\n\n        uint32 quotient;\n        uint16 remainder;\n\n        if(divisor) {\n          quotient  = (uint32)(dividend / divisor);\n          remainder = (uint16)(dividend % divisor);\n        } else {\n          //illegal division by zero\n          quotient  = 0;\n          remainder = dividend & 0xffff;\n        }\n\n        r4828 = quotient;\n        r4829 = quotient >> 8;\n        r482a = quotient >> 16;\n        r482b = quotient >> 24;\n\n        r482c = remainder;\n        r482d = remainder >> 8;\n      }\n\n      r482f = 0x80;\n    } break;\n\n    case 0x482e: {\n      //reset math unit\n      r4820 = r4821 = r4822 = r4823 = 0;\n      r4824 = r4825 = r4826 = r4827 = 0;\n      r4828 = r4829 = r482a = r482b = 0;\n      r482c = r482d = 0;\n\n      r482e = data;\n    } break;\n\n    //===================\n    //memory mapping unit\n    //===================\n\n    case 0x4830: r4830 = data; break;\n\n    case 0x4831: {\n      r4831 = data;\n      dx_offset = datarom_addr((data & 7) * 0x100000);\n    } break;\n\n    case 0x4832: {\n      r4832 = data;\n      ex_offset = datarom_addr((data & 7) * 0x100000);\n    } break;\n\n    case 0x4833: {\n      r4833 = data;\n      fx_offset = datarom_addr((data & 7) * 0x100000);\n    } break;\n\n    case 0x4834: r4834 = data; break;\n\n    //====================\n    //real-time clock unit\n    //====================\n\n    case 0x4840: {\n      r4840 = data;\n      if(!(r4840 & 1)) {\n        //disable RTC\n        rtc_state = RTCS_Inactive;\n        update_time();\n      } else {\n        //enable RTC\n        r4842 = 0x80;\n        rtc_state = RTCS_ModeSelect;\n      }\n    } break;\n\n    case 0x4841: {\n      r4841 = data;\n\n      switch(rtc_state) {\n        case RTCS_ModeSelect: {\n          if(data == RTCM_Linear || data == RTCM_Indexed) {\n            r4842 = 0x80;\n            rtc_state = RTCS_IndexSelect;\n            rtc_mode  = (RTC_Mode)data;\n            rtc_index = 0;\n          }\n        } break;\n\n        case RTCS_IndexSelect: {\n          r4842 = 0x80;\n          rtc_index = data & 15;\n          if(rtc_mode == RTCM_Linear) rtc_state = RTCS_Write;\n        } break;\n\n        case RTCS_Write: {\n          r4842 = 0x80;\n\n          //control register 0\n          if(rtc_index == 13) {\n            //increment second counter\n            if(data & 2) update_time(+1);\n\n            //round minute counter\n            if(data & 8) {\n              update_time();\n\n              unsigned second = memory_cartrtc_read( 0) + memory_cartrtc_read( 1) * 10;\n              //clear seconds\n              memory_cartrtc_write(0, 0);\n              memory_cartrtc_write(1, 0);\n\n              if(second >= 30) update_time(+60);\n            }\n          }\n\n          //control register 2\n          if(rtc_index == 15) {\n            //disable timer and clear second counter\n            if((data & 1) && !(memory_cartrtc_read(15) & 1)) {\n              update_time();\n\n              //clear seconds\n              memory_cartrtc_write(0, 0);\n              memory_cartrtc_write(1, 0);\n            }\n\n            //disable timer\n            if((data & 2) && !(memory_cartrtc_read(15) & 2)) {\n              update_time();\n            }\n          }\n\n          memory_cartrtc_write(rtc_index, data & 15);\n          rtc_index = (rtc_index + 1) & 15;\n        } break;\n\n\t\tcase RTCS_Inactive: {\n\t\t} break;\n      } //switch(rtc_state)\n    } break;\n  }\n}\n\nSPC7110::SPC7110() {\n}\n"
        },
        {
          "name": "spc7110emu.h",
          "type": "blob",
          "size": 3.84765625,
          "content": "/*****\n * SPC7110 emulator - version 0.03 (2008-08-10)\n * Copyright (c) 2008, byuu and neviksti\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * The software is provided \"as is\" and the author disclaims all warranties\n * with regard to this software including all implied warranties of\n * merchantibility and fitness, in no event shall the author be liable for\n * any special, direct, indirect, or consequential damages or any damages\n * whatsoever resulting from loss of use, data or profits, whether in an\n * action of contract, negligence or other tortious action, arising out of\n * or in connection with the use or performance of this software.\n *****/\n\n\n#ifndef _SPC7110EMU_H_\n#define _SPC7110EMU_H_\n\n#include \"spc7110dec.h\"\n\nclass SPC7110 {\npublic:\n  void init();\n  void enable();\n  void power();\n  void reset();\n\n  unsigned datarom_addr(unsigned addr);\n\n  unsigned data_pointer();\n  unsigned data_adjust();\n  unsigned data_increment();\n  void set_data_pointer(unsigned addr);\n  void set_data_adjust(unsigned addr);\n\n  void update_time(int offset = 0);\n  time_t create_time();\n\n  uint8 mmio_read (unsigned addr);\n  void  mmio_write(unsigned addr, uint8 data);\n\n  uint8 read (unsigned addr);\n  void  write(unsigned addr, uint8 data);\n\n  //spc7110decomp\n  void decomp_init();\n  uint8 decomp_read();\n\n  SPC7110();\n\n  //==================\n  //decompression unit\n  //==================\n  uint8 r4801; //compression table low\n  uint8 r4802; //compression table high\n  uint8 r4803; //compression table bank\n  uint8 r4804; //compression table index\n  uint8 r4805; //decompression buffer index low\n  uint8 r4806; //decompression buffer index high\n  uint8 r4807; //???\n  uint8 r4808; //???\n  uint8 r4809; //compression length low\n  uint8 r480a; //compression length high\n  uint8 r480b; //decompression control register\n  uint8 r480c; //decompression status\n\n  SPC7110Decomp decomp;\n\n  //==============\n  //data port unit\n  //==============\n  uint8 r4811; //data pointer low\n  uint8 r4812; //data pointer high\n  uint8 r4813; //data pointer bank\n  uint8 r4814; //data adjust low\n  uint8 r4815; //data adjust high\n  uint8 r4816; //data increment low\n  uint8 r4817; //data increment high\n  uint8 r4818; //data port control register\n\n  uint8 r481x;\n\n  bool r4814_latch;\n  bool r4815_latch;\n\n  //=========\n  //math unit\n  //=========\n  uint8 r4820; //16-bit multiplicand B0, 32-bit dividend B0\n  uint8 r4821; //16-bit multiplicand B1, 32-bit dividend B1\n  uint8 r4822; //32-bit dividend B2\n  uint8 r4823; //32-bit dividend B3\n  uint8 r4824; //16-bit multiplier B0\n  uint8 r4825; //16-bit multiplier B1\n  uint8 r4826; //16-bit divisor B0\n  uint8 r4827; //16-bit divisor B1\n  uint8 r4828; //32-bit product B0, 32-bit quotient B0\n  uint8 r4829; //32-bit product B1, 32-bit quotient B1\n  uint8 r482a; //32-bit product B2, 32-bit quotient B2\n  uint8 r482b; //32-bit product B3, 32-bit quotient B3\n  uint8 r482c; //16-bit remainder B0\n  uint8 r482d; //16-bit remainder B1\n  uint8 r482e; //math control register\n  uint8 r482f; //math status\n\n  //===================\n  //memory mapping unit\n  //===================\n  uint8 r4830; //SRAM write enable\n  uint8 r4831; //$[d0-df]:[0000-ffff] mapping\n  uint8 r4832; //$[e0-ef]:[0000-ffff] mapping\n  uint8 r4833; //$[f0-ff]:[0000-ffff] mapping\n  uint8 r4834; //???\n\n  unsigned dx_offset;\n  unsigned ex_offset;\n  unsigned fx_offset;\n\n  //====================\n  //real-time clock unit\n  //====================\n  uint8 r4840; //RTC latch\n  uint8 r4841; //RTC index/data port\n  uint8 r4842; //RTC status\n\n  enum RTC_State { RTCS_Inactive, RTCS_ModeSelect, RTCS_IndexSelect, RTCS_Write } rtc_state;\n  enum RTC_Mode  { RTCM_Linear = 0x03, RTCM_Indexed = 0x0c } rtc_mode;\n  unsigned rtc_index;\n\n  static const unsigned months[12];\n};\n\n#endif\n"
        },
        {
          "name": "srtc.cpp",
          "type": "blob",
          "size": 1.4794921875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n/*****\n * S-RTC emulation code\n * Copyright (c) byuu\n *****/\n\n\n#include <limits>\n\n#include \"snes9x.h\"\n#include \"memmap.h\"\n#include \"srtc.h\"\n#include \"display.h\"\n\n#define memory_cartrtc_read(a)\t\tRTCData.reg[(a)]\n#define memory_cartrtc_write(a, b)\t{ RTCData.reg[(a)] = (b); }\n#define cpu_regs_mdr\t\t\t\tOpenBus\n\nstatic inline unsigned max (unsigned a, unsigned b)\n{\n\treturn ((a > b) ? a : b);\n}\n\nstatic inline unsigned min (unsigned a, unsigned b)\n{\n\treturn ((a < b) ? a : b);\n}\n\n#include \"srtcemu.h\"\n#include \"srtcemu.cpp\"\n\nstatic SRTC\tsrtcemu;\n\n\nvoid S9xInitSRTC (void)\n{\n\tsrtcemu.power();\n\tmemset(RTCData.reg, 0, 20);\n}\n\nvoid S9xResetSRTC (void)\n{\n\tsrtcemu.reset();\n}\n\nvoid S9xSetSRTC (uint8 data, uint16 address)\n{\n\tsrtcemu.mmio_write(address, data);\n}\n\nuint8 S9xGetSRTC (uint16 address)\n{\n\treturn (srtcemu.mmio_read(address));\n}\n\nvoid S9xSRTCPreSaveState (void)\n{\n\tsrtcsnap.rtc_mode  = (int32) srtcemu.rtc_mode;\n\tsrtcsnap.rtc_index = (int32) srtcemu.rtc_index;\n}\n\nvoid S9xSRTCPostLoadState (int)\n{\n\tsrtcemu.rtc_mode  = (SRTC::RTC_Mode) srtcsnap.rtc_mode;\n\tsrtcemu.rtc_index = (signed)         srtcsnap.rtc_index;\n\n\tsrtcemu.update_time();\n}\n"
        },
        {
          "name": "srtc.h",
          "type": "blob",
          "size": 0.7958984375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _SRTC_H_\n#define _SRTC_H_\n\nstruct SRTCData\n{\n\tuint8\treg[20];\n};\n\n// for snapshot only\nstruct SSRTCSnapshot\n{\n\tint32\trtc_mode;\t// enum RTC_Mode\n\tint32\trtc_index;\t// signed\n};\n\nextern struct SRTCData\t\tRTCData;\nextern struct SSRTCSnapshot\tsrtcsnap;\n\nvoid S9xInitSRTC (void);\nvoid S9xResetSRTC (void);\nvoid S9xSRTCPreSaveState (void);\nvoid S9xSRTCPostLoadState (int);\nvoid S9xSetSRTC (uint8, uint16);\nuint8 S9xGetSRTC (uint16);\n\n#endif\n"
        },
        {
          "name": "srtcemu.cpp",
          "type": "blob",
          "size": 5.9052734375,
          "content": "/*****\n * S-RTC emulation code\n * Copyright (c) byuu\n *****/\n\n\n#define _SRTCEMU_CPP_\n\nconst unsigned SRTC::months[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\n\nvoid SRTC::power() {\n  reset();\n}\n\nvoid SRTC::reset() {\n  rtc_mode = RTCM_Read;\n  rtc_index = -1;\n  update_time();\n}\n\nvoid SRTC::update_time() {\n  time_t rtc_time\n  = (memory_cartrtc_read(16) <<  0)\n  | (memory_cartrtc_read(17) <<  8)\n  | (memory_cartrtc_read(18) << 16)\n  | (memory_cartrtc_read(19) << 24);\n  time_t current_time = time(0);\n\n  //sizeof(time_t) is platform-dependent; though memory::cartrtc needs to be platform-agnostic.\n  //yet platforms with 32-bit signed time_t will overflow every ~68 years. handle this by\n  //accounting for overflow at the cost of 1-bit precision (to catch underflow). this will allow\n  //memory::cartrtc timestamp to remain valid for up to ~34 years from the last update, even if\n  //time_t overflows. calculation should be valid regardless of number representation, time_t size,\n  //or whether time_t is signed or unsigned.\n  time_t diff\n  = (current_time >= rtc_time)\n  ? (current_time - rtc_time)\n  : (std::numeric_limits<time_t>::max() - rtc_time + current_time + 1);  //compensate for overflow\n  if(diff > std::numeric_limits<time_t>::max() / 2) diff = 0;            //compensate for underflow\n\n  if(diff > 0) {\n    unsigned second  = memory_cartrtc_read( 0) + memory_cartrtc_read( 1) * 10;\n    unsigned minute  = memory_cartrtc_read( 2) + memory_cartrtc_read( 3) * 10;\n    unsigned hour    = memory_cartrtc_read( 4) + memory_cartrtc_read( 5) * 10;\n    unsigned day     = memory_cartrtc_read( 6) + memory_cartrtc_read( 7) * 10;\n    unsigned month   = memory_cartrtc_read( 8);\n    unsigned year    = memory_cartrtc_read( 9) + memory_cartrtc_read(10) * 10 + memory_cartrtc_read(11) * 100;\n    unsigned weekday = memory_cartrtc_read(12);\n\n    day--;\n    month--;\n    year += 1000;\n\n    second += diff;\n    while(second >= 60) {\n      second -= 60;\n\n      minute++;\n      if(minute < 60) continue;\n      minute = 0;\n\n      hour++;\n      if(hour < 24) continue;\n      hour = 0;\n\n      day++;\n      weekday = (weekday + 1) % 7;\n      unsigned days = months[month % 12];\n      if(days == 28) {\n        bool leapyear = false;\n        if((year % 4) == 0) {\n          leapyear = true;\n          if((year % 100) == 0 && (year % 400) != 0) leapyear = false;\n        }\n        if(leapyear) days++;\n      }\n      if(day < days) continue;\n      day = 0;\n\n      month++;\n      if(month < 12) continue;\n      month = 0;\n\n      year++;\n    }\n\n    day++;\n    month++;\n    year -= 1000;\n\n    memory_cartrtc_write( 0, second % 10);\n    memory_cartrtc_write( 1, second / 10);\n    memory_cartrtc_write( 2, minute % 10);\n    memory_cartrtc_write( 3, minute / 10);\n    memory_cartrtc_write( 4, hour % 10);\n    memory_cartrtc_write( 5, hour / 10);\n    memory_cartrtc_write( 6, day % 10);\n    memory_cartrtc_write( 7, day / 10);\n    memory_cartrtc_write( 8, month);\n    memory_cartrtc_write( 9, year % 10);\n    memory_cartrtc_write(10, (year / 10) % 10);\n    memory_cartrtc_write(11, year / 100);\n    memory_cartrtc_write(12, weekday % 7);\n  }\n\n  memory_cartrtc_write(16, current_time >>  0);\n  memory_cartrtc_write(17, current_time >>  8);\n  memory_cartrtc_write(18, current_time >> 16);\n  memory_cartrtc_write(19, current_time >> 24);\n}\n\n//returns day of week for specified date\n//eg 0 = Sunday, 1 = Monday, ... 6 = Saturday\n//usage: weekday(2008, 1, 1) returns weekday of January 1st, 2008\nunsigned SRTC::weekday(unsigned year, unsigned month, unsigned day) {\n  unsigned y = 1900, m = 1;  //epoch is 1900-01-01\n  unsigned sum = 0;          //number of days passed since epoch\n\n  year = max(1900, year);\n  month = max(1, min(12, month));\n  day = max(1, min(31, day));\n\n  while(y < year) {\n    bool leapyear = false;\n    if((y % 4) == 0) {\n      leapyear = true;\n      if((y % 100) == 0 && (y % 400) != 0) leapyear = false;\n    }\n    sum += leapyear ? 366 : 365;\n    y++;\n  }\n\n  while(m < month) {\n    unsigned days = months[m - 1];\n    if(days == 28) {\n      bool leapyear = false;\n      if((y % 4) == 0) {\n        leapyear = true;\n        if((y % 100) == 0 && (y % 400) != 0) leapyear = false;\n      }\n      if(leapyear) days++;\n    }\n    sum += days;\n    m++;\n  }\n\n  sum += day - 1;\n  return (sum + 1) % 7;  //1900-01-01 was a Monday\n}\n\nuint8 SRTC::mmio_read(unsigned addr) {\n  addr &= 0xffff;\n\n  if(addr == 0x2800) {\n    if(rtc_mode != RTCM_Read) return 0x00;\n\n    if(rtc_index < 0) {\n      update_time();\n      rtc_index++;\n      return 0x0f;\n    } else if(rtc_index > 12) {\n      rtc_index = -1;\n      return 0x0f;\n    } else {\n      return memory_cartrtc_read(rtc_index++);\n    }\n  }\n\n  return cpu_regs_mdr;\n}\n\nvoid SRTC::mmio_write(unsigned addr, uint8 data) {\n  addr &= 0xffff;\n\n  if(addr == 0x2801) {\n    data &= 0x0f;  //only the low four bits are used\n\n    if(data == 0x0d) {\n      rtc_mode = RTCM_Read;\n      rtc_index = -1;\n      return;\n    }\n\n    if(data == 0x0e) {\n      rtc_mode = RTCM_Command;\n      return;\n    }\n\n    if(data == 0x0f) return;  //unknown behavior\n\n    if(rtc_mode == RTCM_Write) {\n      if(rtc_index >= 0 && rtc_index < 12) {\n        memory_cartrtc_write(rtc_index++, data);\n\n        if(rtc_index == 12) {\n          //day of week is automatically calculated and written\n          unsigned day   = memory_cartrtc_read( 6) + memory_cartrtc_read( 7) * 10;\n          unsigned month = memory_cartrtc_read( 8);\n          unsigned year  = memory_cartrtc_read( 9) + memory_cartrtc_read(10) * 10 + memory_cartrtc_read(11) * 100;\n          year += 1000;\n\n          memory_cartrtc_write(rtc_index++, weekday(year, month, day));\n        }\n      }\n    } else if(rtc_mode == RTCM_Command) {\n      if(data == 0) {\n        rtc_mode = RTCM_Write;\n        rtc_index = 0;\n      } else if(data == 4) {\n        rtc_mode = RTCM_Ready;\n        rtc_index = -1;\n        for(unsigned i = 0; i < 13; i++) memory_cartrtc_write(i, 0);\n      } else {\n        //unknown behavior\n        rtc_mode = RTCM_Ready;\n      }\n    }\n  }\n}\n\nSRTC::SRTC() {\n}\n"
        },
        {
          "name": "srtcemu.h",
          "type": "blob",
          "size": 0.5048828125,
          "content": "/*****\n * S-RTC emulation code\n * Copyright (c) byuu\n *****/\n\n\n#ifndef _SRTCEMU_H_\n#define _SRTCEMU_H_\n\nclass SRTC {\npublic:\n  void update_time();\n  unsigned weekday(unsigned year, unsigned month, unsigned day);\n\n  void init();\n  void enable();\n  void power();\n  void reset();\n\n  uint8 mmio_read (unsigned addr);\n  void  mmio_write(unsigned addr, uint8 data);\n\n  SRTC();\n\n  static const unsigned months[12];\n  enum RTC_Mode { RTCM_Ready, RTCM_Command, RTCM_Read, RTCM_Write } rtc_mode;\n  signed rtc_index;\n};\n\n#endif\n"
        },
        {
          "name": "statemanager.cpp",
          "type": "blob",
          "size": 4.3681640625,
          "content": "#include \"statemanager.h\"\n#include \"snapshot.h\"\n\n/*  State Manager Class that records snapshot data for rewinding\n    mostly based on SSNES's rewind code by Themaister\n*/\n\nstatic inline size_t nearest_pow2_size(size_t v)\n{\n   size_t orig = v;\n   v--;\n   v |= v >> 1;\n   v |= v >> 2;\n   v |= v >> 4;\n#if SIZE_MAX >= 0xffff\n      v |= v >> 8;\n#endif\n#if SIZE_MAX >= 0xffffffff\n      v |= v >> 16;\n#endif\n#if SIZE_MAX >= 0xffffffffffffffff\n      v |= v >> 32;\n#endif\n   v++;\n\n   size_t next = v;\n   size_t prev = v >> 1;\n\n   if ((next - orig) < (orig - prev))\n      return next;\n   else\n      return prev;\n}\n\nvoid StateManager::deallocate() {\n    if(buffer) {\n        delete [] buffer;\n        buffer = NULL;\n    }\n    if(tmp_state) {\n        delete [] tmp_state;\n        tmp_state = NULL;\n    }\n    if(in_state) {\n        delete [] in_state;\n        in_state = NULL;\n    }\n}\n\nStateManager::StateManager()\n{\n    buffer = NULL;\n    tmp_state = NULL;\n    in_state = NULL;\n    init_done = false;\n}\n\nStateManager::~StateManager() {\n    deallocate();\n}\n\nbool StateManager::init(size_t buffer_size) {\n\n    init_done = false;\n\n    deallocate();\n\n    real_state_size = S9xFreezeSize();\n    state_size = real_state_size / sizeof(uint32_t); // Works in multiple of 4.\n\n    // We need 4-byte aligned state_size to avoid having to enforce this with unneeded memcpy's!\n    if(real_state_size % sizeof(uint32_t)) state_size ++;\n\n    if (buffer_size <= real_state_size) // Need a sufficient buffer size.\n        return false;\n\n    top_ptr = 1;\n\n    \n    buf_size = nearest_pow2_size(buffer_size) / sizeof(uint64_t); // Works in multiple of 8.\n    buf_size_mask = buf_size - 1;\n\n    if (!(buffer = new uint64_t[buf_size]))\n        return false;\n    if (!(tmp_state = new uint32_t[state_size]))\n       return false;\n    if (!(in_state = new uint32_t[state_size]))\n       return false;\n\n    memset(tmp_state,0,state_size * sizeof(uint32_t));\n    memset(in_state,0,state_size * sizeof(uint32_t));\n\n    init_done = true;\n\n    return true;\n}\n\nint StateManager::pop()\n{ \n    if(!init_done)\n        return 0;\n\n    if (first_pop)\n    {\n      first_pop = false;\n      return S9xUnfreezeGameMem((uint8 *)tmp_state,real_state_size);\n    }\n\n    top_ptr = (top_ptr - 1) & buf_size_mask;\n\n    if (top_ptr == bottom_ptr) // Our stack is completely empty... :v\n    {\n      top_ptr = (top_ptr + 1) & buf_size_mask;\n      return 0;\n    }\n\n    while (buffer[top_ptr])\n    {\n      // Apply the xor patch.\n      uint32_t addr = buffer[top_ptr] >> 32;\n      uint32_t xor_ = buffer[top_ptr] & 0xFFFFFFFFU;\n      tmp_state[addr] ^= xor_;\n\n      top_ptr = (top_ptr - 1) & buf_size_mask;\n    }\n\n    if (top_ptr == bottom_ptr) // Our stack is completely empty... :v\n    {\n      top_ptr = (top_ptr + 1) & buf_size_mask; \n    }\n\n    return S9xUnfreezeGameMem((uint8 *)tmp_state,real_state_size);\n}\n\nvoid StateManager::reassign_bottom()\n{\n   bottom_ptr = (top_ptr + 1) & buf_size_mask;\n   while (buffer[bottom_ptr]) // Skip ahead until we find the first 0 (boundary for state delta).\n      bottom_ptr = (bottom_ptr + 1) & buf_size_mask;\n}\n\nvoid StateManager::generate_delta(const void *data)\n{\n   bool crossed = false;\n   const uint32_t *old_state = tmp_state;\n   const uint32_t *new_state = (const uint32_t*)data;\n\n   buffer[top_ptr++] = 0; // For each separate delta, we have a 0 value sentinel in between.\n   top_ptr &= buf_size_mask;\n\n   // Check if top_ptr and bottom_ptr crossed each other, which means we need to delete old cruft.\n   if (top_ptr == bottom_ptr)\n      crossed = true;\n\n   for (uint64_t i = 0; i < state_size; i++)\n   {\n      uint64_t xor_ = old_state[i] ^ new_state[i];\n\n      // If the data differs (xor != 0), we push that xor on the stack with index and xor.\n      // This can be reversed by reapplying the xor.\n      // This, if states don't really differ much, we'll save lots of space :)\n      // Hopefully this will work really well with save states.\n      if (xor_)\n      {\n         buffer[top_ptr] = (i << 32) | xor_;\n         top_ptr = (top_ptr + 1) & buf_size_mask;\n\n         if (top_ptr == bottom_ptr)\n            crossed = true;\n      }\n   }\n\n   if (crossed)\n      reassign_bottom();\n}\n\nbool StateManager::push()\n{\n    if(!init_done)\n        return false;\n    if(!S9xFreezeGameMem((uint8 *)in_state,real_state_size))\n        return false;\n    generate_delta(in_state);\n    uint32 *tmp = tmp_state;\n    tmp_state = in_state;\n    in_state = tmp;\n\n    first_pop = true;\n\n    return true;\n}\n"
        },
        {
          "name": "statemanager.h",
          "type": "blob",
          "size": 0.7001953125,
          "content": "#ifndef STATEMANAGER_H\n#define STATEMANAGER_H\n\n/*  State Manager Class that records snapshot data for rewinding\n    mostly based on SSNES's rewind code by Themaister\n*/\n\n#include \"snes9x.h\"\n\nclass StateManager {\nprivate:\n    uint64_t *buffer;\n    size_t buf_size;\n    size_t buf_size_mask;\n    uint32_t *tmp_state;\n    uint32_t *in_state;\n    size_t top_ptr;\n    size_t bottom_ptr;\n    size_t state_size;\n    size_t real_state_size;\n    bool init_done;\n    bool first_pop;\n    \n    void reassign_bottom();\n    void generate_delta(const void *data);\n    void deallocate();\npublic:\n    StateManager();\n    ~StateManager();\n    bool init(size_t buffer_size);\n    int pop();\n    bool push();\n};\n\n#endif // STATEMANAGER_H\n"
        },
        {
          "name": "stream.cpp",
          "type": "blob",
          "size": 7.6640625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n// Abstract the details of reading from zip files versus FILE *'s.\n\n#include <string>\n#ifdef UNZIP_SUPPORT\n#  ifdef SYSTEM_ZIP\n#    include <minizip/unzip.h>\n#  else\n#    include \"unzip.h\"\n#  endif\n#endif\n#include \"snes9x.h\"\n#include \"stream.h\"\n\n\n// Generic constructor/destructor\n\nStream::Stream (void)\n{\n\treturn;\n}\n\nStream::~Stream (void)\n{\n\treturn;\n}\n\n// Generic getline function, based on gets. Reimlpement if you can do better.\n\nchar * Stream::getline (void)\n{\n\tbool\t\teof;\n\tstd::string\tret;\n\n\tret = getline(eof);\n\tif (ret.size() == 0 && eof)\n\t\treturn (NULL);\n\n\treturn (strdup(ret.c_str()));\n}\n\nstd::string Stream::getline (bool &eof)\n{\n\tchar\t\tbuf[1024];\n\tstd::string\tret;\n\n\teof = false;\n\tret.clear();\n\n\tdo\n\t{\n\t\tif (gets(buf, sizeof(buf)) == NULL)\n\t\t{\n\t\t\teof = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tret.append(buf);\n\t}\n\twhile (*ret.rbegin() != '\\n');\n\n\treturn (ret);\n}\n\nsize_t Stream::pos_from_origin_offset(uint8 origin, int32 offset)\n{\n    size_t position = 0;\n    switch (origin)\n    {\n        case SEEK_SET:\n            position = offset;\n            break;\n        case SEEK_END:\n            position = size() + offset;\n            break;\n        case SEEK_CUR:\n            position = pos() + offset;\n            break;\n    }\n    return position;\n}\n\n// snes9x.h FSTREAM Stream\n\nfStream::fStream (FSTREAM f)\n{\n\tfp = f;\n}\n\nfStream::~fStream (void)\n{\n\treturn;\n}\n\nint fStream::get_char (void)\n{\n\treturn (GETC_FSTREAM(fp));\n}\n\nchar * fStream::gets (char *buf, size_t len)\n{\n\treturn (GETS_FSTREAM(buf, len, fp));\n}\n\nsize_t fStream::read (void *buf, size_t len)\n{\n\treturn (READ_FSTREAM(buf, len, fp));\n}\n\nsize_t fStream::write (void *buf, size_t len)\n{\n    return (WRITE_FSTREAM(buf, len, fp));\n}\n\nsize_t fStream::pos (void)\n{\n    return (FIND_FSTREAM(fp));\n}\n\nsize_t fStream::size (void)\n{\n    size_t sz;\n    REVERT_FSTREAM(fp,0L,SEEK_END);\n    sz = FIND_FSTREAM(fp);\n    REVERT_FSTREAM(fp,0L,SEEK_SET);\n    return sz;\n}\n\nint fStream::revert (uint8 origin, int32 offset)\n{\n    return (REVERT_FSTREAM(fp, offset, origin));\n}\n\nvoid fStream::closeStream()\n{\n    CLOSE_FSTREAM(fp);\n    delete this;\n}\n\n// unzip Stream\n\n#ifdef UNZIP_SUPPORT\n\nunzStream::unzStream (unzFile &v)\n{\n\tfile = v;\n    pos_in_buf = 0;\n    buf_pos_in_unzipped = unztell(file);\n    bytes_in_buf = 0;\n\n    // remember start pos for seeks\n    unzGetFilePos(file, &unz_file_start_pos);\n}\n\nunzStream::~unzStream (void)\n{\n\treturn;\n}\n\nsize_t unzStream::buffer_remaining()\n{\n    return bytes_in_buf - pos_in_buf;\n}\n\nvoid unzStream::fill_buffer()\n{\n    buf_pos_in_unzipped = unztell(file);\n    bytes_in_buf = unzReadCurrentFile(file, buffer, unz_BUFFSIZ);\n    pos_in_buf = 0;\n}\n\nint unzStream::get_char (void)\n{\n\tunsigned char\tc;\n\n\tif (buffer_remaining() <= 0)\n\t{\n        fill_buffer();\n\t\tif (bytes_in_buf <= 0)\n\t\t\treturn (EOF);\n\t}\n\n\tc = *(buffer + pos_in_buf);\n    pos_in_buf++;\n\n\treturn ((int) c);\n}\n\nchar * unzStream::gets (char *buf, size_t len)\n{\n\tsize_t\ti;\n\tint\t\tc;\n\n\tfor (i = 0; i < len - 1; i++)\n\t{\n\t\tc = get_char();\n\t\tif (c == EOF)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t\treturn (NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf[i] = (char) c;\n\t\tif (buf[i] == '\\n')\n\t\t\tbreak;\n\t}\n\n\tbuf[i] = '\\0';\n\n\treturn (buf);\n}\n\nsize_t unzStream::read (void *buf, size_t len)\n{\n\tif (len == 0)\n\t\treturn (len);\n\n\tsize_t\tto_read = len;\n    uint8 *read_to = (uint8 * )buf;\n    do\n    {\n        size_t in_buffer = buffer_remaining();\n        if (to_read <= in_buffer)\n        {\n            memcpy(read_to, buffer + pos_in_buf, to_read);\n            pos_in_buf += to_read;\n            to_read = 0;\n            break;\n        }\n\n        memcpy(read_to, buffer + pos_in_buf, in_buffer);\n        to_read -= in_buffer;\n        fill_buffer();\n    } while (bytes_in_buf);\n\n\treturn (len - to_read);\n}\n\n// not supported\nsize_t unzStream::write (void *buf, size_t len)\n{\n    return (0);\n}\n\nsize_t unzStream::pos (void)\n{\n    return buf_pos_in_unzipped + pos_in_buf;\n}\n\nsize_t unzStream::size (void)\n{\n    unz_file_info\tinfo;\n    unzGetCurrentFileInfo(file,&info,NULL,0,NULL,0,NULL,0);\n    return info.uncompressed_size;\n}\n\nint unzStream::revert (uint8 origin, int32 offset)\n{\n    size_t target_pos = pos_from_origin_offset(origin, offset);\n\n    // new pos inside buffered data\n    if (target_pos >= buf_pos_in_unzipped && target_pos < buf_pos_in_unzipped + bytes_in_buf)\n    {\n        pos_in_buf = target_pos - buf_pos_in_unzipped;\n    }\n    else // outside of buffer, reset file and read until pos\n    {\n        unzGoToFilePos(file, &unz_file_start_pos);\n        unzOpenCurrentFile(file); // necessary to reopen after seek\n        int times_to_read = target_pos / unz_BUFFSIZ + 1;\n        for( int i = 0; i < times_to_read; i++)\n        {\n            fill_buffer();\n        }\n        pos_in_buf = target_pos % unz_BUFFSIZ;\n    }\n    return 0;\n}\n\nvoid unzStream::closeStream()\n{\n    unzClose(file);\n    delete this;\n}\n\n#endif\n\n// memory Stream\n\nmemStream::memStream (uint8 *source, size_t sourceSize)\n{\n\tmem = head = source;\n    msize = remaining = sourceSize;\n    readonly = false;\n}\n\nmemStream::memStream (const uint8 *source, size_t sourceSize)\n{\n\tmem = head = const_cast<uint8 *>(source);\n    msize = remaining = sourceSize;\n    readonly = true;\n}\n\nmemStream::~memStream (void)\n{\n\treturn;\n}\n\nint memStream::get_char (void)\n{\n    if(!remaining)\n        return EOF;\n\n    remaining--;\n\treturn *head++;\n}\n\nchar * memStream::gets (char *buf, size_t len)\n{\n    size_t\ti;\n\tint\t\tc;\n\n\tfor (i = 0; i < len - 1; i++)\n\t{\n\t\tc = get_char();\n\t\tif (c == EOF)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t\treturn (NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf[i] = (char) c;\n\t\tif (buf[i] == '\\n')\n\t\t\tbreak;\n\t}\n\n\tbuf[i] = '\\0';\n\n\treturn (buf);\n}\n\nsize_t memStream::read (void *buf, size_t len)\n{\n    size_t bytes = len < remaining ? len : remaining;\n    memcpy(buf,head,bytes);\n    head += bytes;\n    remaining -= bytes;\n\n\treturn bytes;\n}\n\nsize_t memStream::write (void *buf, size_t len)\n{\n    if(readonly)\n        return 0;\n\n    size_t bytes = len < remaining ? len : remaining;\n    memcpy(head,buf,bytes);\n    head += bytes;\n    remaining -= bytes;\n\n\treturn bytes;\n}\n\nsize_t memStream::pos (void)\n{\n    return msize - remaining;\n}\n\nsize_t memStream::size (void)\n{\n    return msize;\n}\n\nint memStream::revert (uint8 origin, int32 offset)\n{\n    size_t pos = pos_from_origin_offset(origin, offset);\n\n    if(pos > msize)\n        return -1;\n\n    head = mem + pos;\n    remaining = msize - pos;\n\n    return 0;\n}\n\nvoid memStream::closeStream()\n{\n    delete [] mem;\n    delete this;\n}\n\n// dummy Stream\n\nnulStream::nulStream (void)\n{\n\tbytes_written = 0;\n}\n\nnulStream::~nulStream (void)\n{\n\treturn;\n}\n\nint nulStream::get_char (void)\n{\n    return 0;\n}\n\nchar * nulStream::gets (char *buf, size_t len)\n{\n\t*buf = '\\0';\n\treturn NULL;\n}\n\nsize_t nulStream::read (void *buf, size_t len)\n{\n\treturn 0;\n}\n\nsize_t nulStream::write (void *buf, size_t len)\n{\n    bytes_written += len;\n\treturn len;\n}\n\nsize_t nulStream::pos (void)\n{\n    return 0;\n}\n\nsize_t nulStream::size (void)\n{\n    return bytes_written;\n}\n\nint nulStream::revert (uint8 origin, int32 offset)\n{\n    size_t target_pos = pos_from_origin_offset(origin, offset);\n    bytes_written = target_pos;\n    return 0;\n}\n\nvoid nulStream::closeStream()\n{\n    delete this;\n}\n\nStream *openStreamFromFSTREAM(const char* filename, const char* mode)\n{\n    FSTREAM f = OPEN_FSTREAM(filename,mode);\n    if(!f)\n        return NULL;\n    return new fStream(f);\n}\n\nStream *reopenStreamFromFd(int fd, const char* mode)\n{\n    FSTREAM f = REOPEN_FSTREAM(fd,mode);\n    if(!f)\n        return NULL;\n    return new fStream(f);\n}\n"
        },
        {
          "name": "stream.h",
          "type": "blob",
          "size": 3.49609375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _STREAM_H_\n#define _STREAM_H_\n\n#include <string>\n\nclass Stream\n{\n\tpublic:\n\t\tStream (void);\n\t\tvirtual ~Stream (void);\n\t\tvirtual int get_char (void) = 0;\n\t\tvirtual char * gets (char *, size_t) = 0;\n\t\tvirtual char * getline (void);\t// free() when done\n\t\tvirtual std::string getline (bool &);\n\t\tvirtual size_t read (void *, size_t) = 0;\n        virtual size_t write (void *, size_t) = 0;\n        virtual size_t pos (void) = 0;\n        virtual size_t size (void) = 0;\n        virtual int revert (uint8 origin, int32 offset) = 0;\n        virtual void closeStream() = 0;\n\n\tprotected:\n\t\tsize_t pos_from_origin_offset(uint8 origin, int32 offset);\n};\n\nclass fStream : public Stream\n{\n\tpublic:\n\t\tfStream (FSTREAM);\n\t\tvirtual ~fStream (void);\n\t\tvirtual int get_char (void);\n\t\tvirtual char * gets (char *, size_t);\n\t\tvirtual size_t read (void *, size_t);\n        virtual size_t write (void *, size_t);\n        virtual size_t pos (void);\n        virtual size_t size (void);\n        virtual int revert (uint8 origin, int32 offset);\n        virtual void closeStream();\n\n\tprivate:\n\t\tFSTREAM\tfp;\n};\n\n#ifdef UNZIP_SUPPORT\n#  ifdef SYSTEM_ZIP\n#    include <minizip/unzip.h>\n#  else\n#    include \"unzip.h\"\n#  endif\n\n#define unz_BUFFSIZ\t1024\n\nclass unzStream : public Stream\n{\n\tpublic:\n\t\tunzStream (unzFile &);\n\t\tvirtual ~unzStream (void);\n\t\tvirtual int get_char (void);\n\t\tvirtual char * gets (char *, size_t);\n\t\tvirtual size_t read (void *, size_t);\n        virtual size_t write (void *, size_t);\n        virtual size_t pos (void);\n        virtual size_t size (void);\n        virtual int revert (uint8 origin, int32 offset);\n        virtual void closeStream();\n\n\tprivate:\n        void   fill_buffer();\n        size_t buffer_remaining();\n\n\t\tunzFile\tfile;\n\t\tchar\tbuffer[unz_BUFFSIZ];\n        size_t  pos_in_buf;\n        size_t  buf_pos_in_unzipped;\n\t\tsize_t\tbytes_in_buf;\n        unz_file_pos unz_file_start_pos;\n};\n\n#endif\n\nclass memStream : public Stream\n{\n\tpublic:\n        memStream (uint8 *,size_t);\n        memStream (const uint8 *,size_t);\n\t\tvirtual ~memStream (void);\n\t\tvirtual int get_char (void);\n\t\tvirtual char * gets (char *, size_t);\n\t\tvirtual size_t read (void *, size_t);\n        virtual size_t write (void *, size_t);\n        virtual size_t pos (void);\n        virtual size_t size (void);\n        virtual int revert (uint8 origin, int32 offset);\n        virtual void closeStream();\n\n\tprivate:\n\t\tuint8   *mem;\n        size_t  msize;\n        size_t  remaining;\n\t\tuint8\t*head;\n        bool    readonly;\n};\n\n/* dummy stream that always reads 0 and writes nowhere\n   but counts bytes written\n*/\nclass nulStream : public Stream\n{\n\tpublic:\n        nulStream (void);\n\t\tvirtual ~nulStream (void);\n        virtual int get_char (void);\n        virtual char * gets (char *, size_t);\n\t\tvirtual size_t read (void *, size_t);\n        virtual size_t write (void *, size_t);\n        virtual size_t pos (void);\n        virtual size_t size (void);\n        virtual int revert (uint8 origin, int32 offset);\n        virtual void closeStream();\n\n    private:\n        size_t  bytes_written;\n};\n\nStream *openStreamFromFSTREAM(const char* filename, const char* mode);\nStream *reopenStreamFromFd(int fd, const char* mode);\n\n\n#endif\n"
        },
        {
          "name": "tile.cpp",
          "type": "blob",
          "size": 14.220703125,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#include \"tileimpl.h\"\n\nusing namespace TileImpl;\n\nnamespace {\n\n\tuint32\tpixbit[8][16];\n\tuint8\thrbit_odd[256];\n\tuint8\thrbit_even[256];\n\n\t// Here are the tile converters, selected by S9xSelectTileConverter().\n\t// Really, except for the definition of DOBIT and the number of times it is called, they're all the same.\n\n\t#define DOBIT(n, i) \\\n\t\tif ((pix = *(tp + (n)))) \\\n\t\t{ \\\n\t\t\tp1 |= pixbit[(i)][pix >> 4]; \\\n\t\t\tp2 |= pixbit[(i)][pix & 0xf]; \\\n\t\t}\n\n\tuint8 ConvertTile2 (uint8 *pCache, uint32 TileAddr, uint32)\n\t{\n\t\tuint8\t*tp      = &Memory.VRAM[TileAddr];\n\t\tuint32\t\t\t*p       = (uint32 *) pCache;\n\t\tuint32\t\t\tnon_zero = 0;\n\t\tuint8\t\t\tline;\n\n\t\tfor (line = 8; line != 0; line--, tp += 2)\n\t\t{\n\t\t\tuint32\t\t\tp1 = 0;\n\t\t\tuint32\t\t\tp2 = 0;\n\t\t\tuint8\tpix;\n\n\t\t\tDOBIT( 0, 0);\n\t\t\tDOBIT( 1, 1);\n\t\t\t*p++ = p1;\n\t\t\t*p++ = p2;\n\t\t\tnon_zero |= p1 | p2;\n\t\t}\n\n\t\treturn (non_zero ? TRUE : BLANK_TILE);\n\t}\n\n\tuint8 ConvertTile4 (uint8 *pCache, uint32 TileAddr, uint32)\n\t{\n\t\tuint8\t*tp      = &Memory.VRAM[TileAddr];\n\t\tuint32\t\t\t*p       = (uint32 *) pCache;\n\t\tuint32\t\t\tnon_zero = 0;\n\t\tuint8\t\t\tline;\n\n\t\tfor (line = 8; line != 0; line--, tp += 2)\n\t\t{\n\t\t\tuint32\t\t\tp1 = 0;\n\t\t\tuint32\t\t\tp2 = 0;\n\t\t\tuint8\tpix;\n\n\t\t\tDOBIT( 0, 0);\n\t\t\tDOBIT( 1, 1);\n\t\t\tDOBIT(16, 2);\n\t\t\tDOBIT(17, 3);\n\t\t\t*p++ = p1;\n\t\t\t*p++ = p2;\n\t\t\tnon_zero |= p1 | p2;\n\t\t}\n\n\t\treturn (non_zero ? TRUE : BLANK_TILE);\n\t}\n\n\tuint8 ConvertTile8 (uint8 *pCache, uint32 TileAddr, uint32)\n\t{\n\t\tuint8\t*tp      = &Memory.VRAM[TileAddr];\n\t\tuint32\t\t\t*p       = (uint32 *) pCache;\n\t\tuint32\t\t\tnon_zero = 0;\n\t\tuint8\t\t\tline;\n\n\t\tfor (line = 8; line != 0; line--, tp += 2)\n\t\t{\n\t\t\tuint32\t\t\tp1 = 0;\n\t\t\tuint32\t\t\tp2 = 0;\n\t\t\tuint8\tpix;\n\n\t\t\tDOBIT( 0, 0);\n\t\t\tDOBIT( 1, 1);\n\t\t\tDOBIT(16, 2);\n\t\t\tDOBIT(17, 3);\n\t\t\tDOBIT(32, 4);\n\t\t\tDOBIT(33, 5);\n\t\t\tDOBIT(48, 6);\n\t\t\tDOBIT(49, 7);\n\t\t\t*p++ = p1;\n\t\t\t*p++ = p2;\n\t\t\tnon_zero |= p1 | p2;\n\t\t}\n\n\t\treturn (non_zero ? TRUE : BLANK_TILE);\n\t}\n\n\t#undef DOBIT\n\n\t#define DOBIT(n, i) \\\n\t\tif ((pix = hrbit_odd[*(tp1 + (n))])) \\\n\t\t\tp1 |= pixbit[(i)][pix]; \\\n\t\tif ((pix = hrbit_odd[*(tp2 + (n))])) \\\n\t\t\tp2 |= pixbit[(i)][pix];\n\n\tuint8 ConvertTile2h_odd (uint8 *pCache, uint32 TileAddr, uint32 Tile)\n\t{\n\t\tuint8\t*tp1     = &Memory.VRAM[TileAddr], *tp2;\n\t\tuint32\t\t\t*p       = (uint32 *) pCache;\n\t\tuint32\t\t\tnon_zero = 0;\n\t\tuint8\t\t\tline;\n\n\t\tif (Tile == 0x3ff)\n\t\t\ttp2 = tp1 - (0x3ff << 4);\n\t\telse\n\t\t\ttp2 = tp1 + (1 << 4);\n\n\t\tfor (line = 8; line != 0; line--, tp1 += 2, tp2 += 2)\n\t\t{\n\t\t\tuint32\t\t\tp1 = 0;\n\t\t\tuint32\t\t\tp2 = 0;\n\t\t\tuint8\tpix;\n\n\t\t\tDOBIT( 0, 0);\n\t\t\tDOBIT( 1, 1);\n\t\t\t*p++ = p1;\n\t\t\t*p++ = p2;\n\t\t\tnon_zero |= p1 | p2;\n\t\t}\n\n\t\treturn (non_zero ? TRUE : BLANK_TILE);\n\t}\n\n\tuint8 ConvertTile4h_odd (uint8 *pCache, uint32 TileAddr, uint32 Tile)\n\t{\n\t\tuint8\t*tp1     = &Memory.VRAM[TileAddr], *tp2;\n\t\tuint32\t\t\t*p       = (uint32 *) pCache;\n\t\tuint32\t\t\tnon_zero = 0;\n\t\tuint8\t\t\tline;\n\n\t\tif (Tile == 0x3ff)\n\t\t\ttp2 = tp1 - (0x3ff << 5);\n\t\telse\n\t\t\ttp2 = tp1 + (1 << 5);\n\n\t\tfor (line = 8; line != 0; line--, tp1 += 2, tp2 += 2)\n\t\t{\n\t\t\tuint32\t\t\tp1 = 0;\n\t\t\tuint32\t\t\tp2 = 0;\n\t\t\tuint8\tpix;\n\n\t\t\tDOBIT( 0, 0);\n\t\t\tDOBIT( 1, 1);\n\t\t\tDOBIT(16, 2);\n\t\t\tDOBIT(17, 3);\n\t\t\t*p++ = p1;\n\t\t\t*p++ = p2;\n\t\t\tnon_zero |= p1 | p2;\n\t\t}\n\n\t\treturn (non_zero ? TRUE : BLANK_TILE);\n\t}\n\n\t#undef DOBIT\n\n\t#define DOBIT(n, i) \\\n\t\tif ((pix = hrbit_even[*(tp1 + (n))])) \\\n\t\t\tp1 |= pixbit[(i)][pix]; \\\n\t\tif ((pix = hrbit_even[*(tp2 + (n))])) \\\n\t\t\tp2 |= pixbit[(i)][pix];\n\n\tuint8 ConvertTile2h_even (uint8 *pCache, uint32 TileAddr, uint32 Tile)\n\t{\n\t\tuint8\t*tp1     = &Memory.VRAM[TileAddr], *tp2;\n\t\tuint32\t\t\t*p       = (uint32 *) pCache;\n\t\tuint32\t\t\tnon_zero = 0;\n\t\tuint8\t\t\tline;\n\n\t\tif (Tile == 0x3ff)\n\t\t\ttp2 = tp1 - (0x3ff << 4);\n\t\telse\n\t\t\ttp2 = tp1 + (1 << 4);\n\n\t\tfor (line = 8; line != 0; line--, tp1 += 2, tp2 += 2)\n\t\t{\n\t\t\tuint32\t\t\tp1 = 0;\n\t\t\tuint32\t\t\tp2 = 0;\n\t\t\tuint8\tpix;\n\n\t\t\tDOBIT( 0, 0);\n\t\t\tDOBIT( 1, 1);\n\t\t\t*p++ = p1;\n\t\t\t*p++ = p2;\n\t\t\tnon_zero |= p1 | p2;\n\t\t}\n\n\t\treturn (non_zero ? TRUE : BLANK_TILE);\n\t}\n\n\tuint8 ConvertTile4h_even (uint8 *pCache, uint32 TileAddr, uint32 Tile)\n\t{\n\t\tuint8\t*tp1     = &Memory.VRAM[TileAddr], *tp2;\n\t\tuint32\t\t\t*p       = (uint32 *) pCache;\n\t\tuint32\t\t\tnon_zero = 0;\n\t\tuint8\t\t\tline;\n\n\t\tif (Tile == 0x3ff)\n\t\t\ttp2 = tp1 - (0x3ff << 5);\n\t\telse\n\t\t\ttp2 = tp1 + (1 << 5);\n\n\t\tfor (line = 8; line != 0; line--, tp1 += 2, tp2 += 2)\n\t\t{\n\t\t\tuint32\t\t\tp1 = 0;\n\t\t\tuint32\t\t\tp2 = 0;\n\t\t\tuint8\tpix;\n\n\t\t\tDOBIT( 0, 0);\n\t\t\tDOBIT( 1, 1);\n\t\t\tDOBIT(16, 2);\n\t\t\tDOBIT(17, 3);\n\t\t\t*p++ = p1;\n\t\t\t*p++ = p2;\n\t\t\tnon_zero |= p1 | p2;\n\t\t}\n\n\t\treturn (non_zero ? TRUE : BLANK_TILE);\n\t}\n\n\t#undef DOBIT\n\n} // anonymous namespace\n\nvoid S9xInitTileRenderer (void)\n{\n\tint\ti;\n\n\tfor (i = 0; i < 16; i++)\n\t{\n\t\tuint32\tb = 0;\n\n\t#ifdef LSB_FIRST\n\t\tif (i & 8)\n\t\t\tb |= 1;\n\t\tif (i & 4)\n\t\t\tb |= 1 << 8;\n\t\tif (i & 2)\n\t\t\tb |= 1 << 16;\n\t\tif (i & 1)\n\t\t\tb |= 1 << 24;\n\t#else\n\t\tif (i & 8)\n\t\t\tb |= 1 << 24;\n\t\tif (i & 4)\n\t\t\tb |= 1 << 16;\n\t\tif (i & 2)\n\t\t\tb |= 1 << 8;\n\t\tif (i & 1)\n\t\t\tb |= 1;\n\t#endif\n\n\t\tfor (uint8 bitshift = 0; bitshift < 8; bitshift++)\n\t\t\tpixbit[bitshift][i] = b << bitshift;\n\t}\n\n\tfor (i = 0; i < 256; i++)\n\t{\n\t\tuint8\tm = 0;\n\t\tuint8\ts = 0;\n\n\t\tif (i & 0x80)\n\t\t\ts |= 8;\n\t\tif (i & 0x40)\n\t\t\tm |= 8;\n\t\tif (i & 0x20)\n\t\t\ts |= 4;\n\t\tif (i & 0x10)\n\t\t\tm |= 4;\n\t\tif (i & 0x08)\n\t\t\ts |= 2;\n\t\tif (i & 0x04)\n\t\t\tm |= 2;\n\t\tif (i & 0x02)\n\t\t\ts |= 1;\n\t\tif (i & 0x01)\n\t\t\tm |= 1;\n\n\t\thrbit_odd[i]  = m;\n\t\thrbit_even[i] = s;\n\t}\n}\n\n// Functions to select which converter and renderer to use.\nextern template struct TileImpl::Renderers<DrawTile16, Normal1x1>;\nextern template struct TileImpl::Renderers<DrawClippedTile16, Normal1x1>;\nextern template struct TileImpl::Renderers<DrawMosaicPixel16, Normal1x1>;\nextern template struct TileImpl::Renderers<DrawBackdrop16, Normal1x1>;\nextern template struct TileImpl::Renderers<DrawMode7MosaicBG1, Normal1x1>;\nextern template struct TileImpl::Renderers<DrawMode7BG1, Normal1x1>;\nextern template struct TileImpl::Renderers<DrawMode7MosaicBG2, Normal1x1>;\nextern template struct TileImpl::Renderers<DrawMode7BG2, Normal1x1>;\n\nextern template struct TileImpl::Renderers<DrawTile16, Normal2x1>;\nextern template struct TileImpl::Renderers<DrawClippedTile16, Normal2x1>;\nextern template struct TileImpl::Renderers<DrawMosaicPixel16, Normal2x1>;\nextern template struct TileImpl::Renderers<DrawBackdrop16, Normal2x1>;\nextern template struct TileImpl::Renderers<DrawMode7MosaicBG1, Normal2x1>;\nextern template struct TileImpl::Renderers<DrawMode7BG1, Normal2x1>;\nextern template struct TileImpl::Renderers<DrawMode7MosaicBG2, Normal2x1>;\nextern template struct TileImpl::Renderers<DrawMode7BG2, Normal2x1>;\nextern template struct TileImpl::Renderers<DrawTile16, Interlace>;\nextern template struct TileImpl::Renderers<DrawClippedTile16, Interlace>;\nextern template struct TileImpl::Renderers<DrawMosaicPixel16, Interlace>;\n\nextern template struct TileImpl::Renderers<DrawTile16, Hires>;\nextern template struct TileImpl::Renderers<DrawClippedTile16, Hires>;\nextern template struct TileImpl::Renderers<DrawMosaicPixel16, Hires>;\nextern template struct TileImpl::Renderers<DrawBackdrop16, Hires>;\nextern template struct TileImpl::Renderers<DrawMode7MosaicBG1, Hires>;\nextern template struct TileImpl::Renderers<DrawMode7BG1, Hires>;\nextern template struct TileImpl::Renderers<DrawMode7MosaicBG2, Hires>;\nextern template struct TileImpl::Renderers<DrawMode7BG2, Hires>;\nextern template struct TileImpl::Renderers<DrawTile16, HiresInterlace>;\nextern template struct TileImpl::Renderers<DrawClippedTile16, HiresInterlace>;\nextern template struct TileImpl::Renderers<DrawMosaicPixel16, HiresInterlace>;\n\nvoid S9xSelectTileRenderers (int BGMode, bool8 sub, bool8 obj)\n{\n\tvoid\t(**DT)\t\t(uint32, uint32, uint32, uint32);\n\tvoid\t(**DCT)\t\t(uint32, uint32, uint32, uint32, uint32, uint32);\n\tvoid\t(**DMP)\t\t(uint32, uint32, uint32, uint32, uint32, uint32);\n\tvoid\t(**DB)\t\t(uint32, uint32, uint32);\n\tvoid\t(**DM7BG1)\t(uint32, uint32, int);\n\tvoid\t(**DM7BG2)\t(uint32, uint32, int);\n\tbool8\tM7M1, M7M2;\n\n\tM7M1 = PPU.BGMosaic[0] && PPU.Mosaic > 1;\n\tM7M2 = PPU.BGMosaic[1] && PPU.Mosaic > 1;\n\n\tbool8 interlace = obj ? FALSE : IPPU.Interlace;\n\tbool8 hires = !sub && (BGMode == 5 || BGMode == 6 || IPPU.PseudoHires);\n\n\tif (!IPPU.DoubleWidthPixels)\t// normal width\n\t{\n\t\tDT     = Renderers<DrawTile16, Normal1x1>::Functions;\n\t\tDCT    = Renderers<DrawClippedTile16, Normal1x1>::Functions;\n\t\tDMP    = Renderers<DrawMosaicPixel16, Normal1x1>::Functions;\n\t\tDB     = Renderers<DrawBackdrop16, Normal1x1>::Functions;\n\t\tDM7BG1 = M7M1 ? Renderers<DrawMode7MosaicBG1, Normal1x1>::Functions : Renderers<DrawMode7BG1, Normal1x1>::Functions;\n\t\tDM7BG2 = M7M2 ? Renderers<DrawMode7MosaicBG2, Normal1x1>::Functions : Renderers<DrawMode7BG2, Normal1x1>::Functions;\n\t\tGFX.LinesPerTile = 8;\n\t}\n\telse if(hires)\t\t\t\t\t// hires double width\n\t{\n\t\tif (interlace)\n\t\t{\n\t\t\tDT     = Renderers<DrawTile16, HiresInterlace>::Functions;\n\t\t\tDCT    = Renderers<DrawClippedTile16, HiresInterlace>::Functions;\n\t\t\tDMP    = Renderers<DrawMosaicPixel16, HiresInterlace>::Functions;\n\t\t\tDB     = Renderers<DrawBackdrop16, Hires>::Functions;\n\t\t\tDM7BG1 = M7M1 ? Renderers<DrawMode7MosaicBG1, Hires>::Functions : Renderers<DrawMode7BG1, Hires>::Functions;\n\t\t\tDM7BG2 = M7M2 ? Renderers<DrawMode7MosaicBG2, Hires>::Functions : Renderers<DrawMode7BG2, Hires>::Functions;\n\t\t\tGFX.LinesPerTile = 4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDT     = Renderers<DrawTile16, Hires>::Functions;\n\t\t\tDCT    = Renderers<DrawClippedTile16, Hires>::Functions;\n\t\t\tDMP    = Renderers<DrawMosaicPixel16, Hires>::Functions;\n\t\t\tDB     = Renderers<DrawBackdrop16, Hires>::Functions;\n\t\t\tDM7BG1 = M7M1 ? Renderers<DrawMode7MosaicBG1, Hires>::Functions : Renderers<DrawMode7BG1, Hires>::Functions;\n\t\t\tDM7BG2 = M7M2 ? Renderers<DrawMode7MosaicBG2, Hires>::Functions : Renderers<DrawMode7BG2, Hires>::Functions;\n\t\t\tGFX.LinesPerTile = 8;\n\t\t}\n\t}\n\telse\t\t\t\t\t\t\t// normal double width\n\t{\n\t\tif (interlace)\n\t\t{\n\t\t\tDT     = Renderers<DrawTile16, Interlace>::Functions;\n\t\t\tDCT    = Renderers<DrawClippedTile16, Interlace>::Functions;\n\t\t\tDMP    = Renderers<DrawMosaicPixel16, Interlace>::Functions;\n\t\t\tDB     = Renderers<DrawBackdrop16, Normal2x1>::Functions;\n\t\t\tDM7BG1 = M7M1 ? Renderers<DrawMode7MosaicBG1, Normal2x1>::Functions : Renderers<DrawMode7BG1, Normal2x1>::Functions;\n\t\t\tDM7BG2 = M7M2 ? Renderers<DrawMode7MosaicBG2, Normal2x1>::Functions : Renderers<DrawMode7BG2, Normal2x1>::Functions;\n\t\t\tGFX.LinesPerTile = 4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDT     = Renderers<DrawTile16, Normal2x1>::Functions;\n\t\t\tDCT    = Renderers<DrawClippedTile16, Normal2x1>::Functions;\n\t\t\tDMP    = Renderers<DrawMosaicPixel16, Normal2x1>::Functions;\n\t\t\tDB     = Renderers<DrawBackdrop16, Normal2x1>::Functions;\n\t\t\tDM7BG1 = M7M1 ? Renderers<DrawMode7MosaicBG1, Normal2x1>::Functions : Renderers<DrawMode7BG1, Normal2x1>::Functions;\n\t\t\tDM7BG2 = M7M2 ? Renderers<DrawMode7MosaicBG2, Normal2x1>::Functions : Renderers<DrawMode7BG2, Normal2x1>::Functions;\n\t\t\tGFX.LinesPerTile = 8;\n\t\t}\n\t}\n\n\tGFX.DrawTileNomath        = DT[0];\n\tGFX.DrawClippedTileNomath = DCT[0];\n\tGFX.DrawMosaicPixelNomath = DMP[0];\n\tGFX.DrawBackdropNomath    = DB[0];\n\tGFX.DrawMode7BG1Nomath    = DM7BG1[0];\n\tGFX.DrawMode7BG2Nomath    = DM7BG2[0];\n\n\tint\ti;\n\n\tif (!Settings.Transparency)\n\t\ti = 0;\n\telse\n\t{\n\t\ti = (Memory.FillRAM[0x2131] & 0x80) ? 4 : 1;\n\t\tif (Memory.FillRAM[0x2131] & 0x40)\n\t\t{\n\t\t\ti++;\n\t\t\tif (Memory.FillRAM[0x2130] & 2)\n\t\t\t\ti++;\n\t\t}\n\t\tif (IPPU.MaxBrightness != 0xf)\n\t\t{\n\t\t\tif (i == 1)\n\t\t\t\ti = 7;\n\t\t\telse if (i == 3)\n\t\t\t\ti = 8;\n\t\t}\n\n\t}\n\n\tGFX.DrawTileMath        = DT[i];\n\tGFX.DrawClippedTileMath = DCT[i];\n\tGFX.DrawMosaicPixelMath = DMP[i];\n\tGFX.DrawBackdropMath    = DB[i];\n\tGFX.DrawMode7BG1Math    = DM7BG1[i];\n\tGFX.DrawMode7BG2Math    = DM7BG2[i];\n}\n\nvoid S9xSelectTileConverter (int depth, bool8 hires, bool8 sub, bool8 mosaic)\n{\n\tswitch (depth)\n\t{\n\t\tcase 8:\n\t\t\tBG.ConvertTile      = BG.ConvertTileFlip = ConvertTile8;\n\t\t\tBG.Buffer           = BG.BufferFlip      = IPPU.TileCache[TILE_8BIT];\n\t\t\tBG.Buffered         = BG.BufferedFlip    = IPPU.TileCached[TILE_8BIT];\n\t\t\tBG.TileShift        = 6;\n\t\t\tBG.PaletteShift     = 0;\n\t\t\tBG.PaletteMask      = 0;\n\t\t\tBG.DirectColourMode = Memory.FillRAM[0x2130] & 1;\n\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tif (hires)\n\t\t\t{\n\t\t\t\tif (sub || mosaic)\n\t\t\t\t{\n\t\t\t\t\tBG.ConvertTile     = ConvertTile4h_even;\n\t\t\t\t\tBG.Buffer          = IPPU.TileCache[TILE_4BIT_EVEN];\n\t\t\t\t\tBG.Buffered        = IPPU.TileCached[TILE_4BIT_EVEN];\n\t\t\t\t\tBG.ConvertTileFlip = ConvertTile4h_odd;\n\t\t\t\t\tBG.BufferFlip      = IPPU.TileCache[TILE_4BIT_ODD];\n\t\t\t\t\tBG.BufferedFlip    = IPPU.TileCached[TILE_4BIT_ODD];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBG.ConvertTile     = ConvertTile4h_odd;\n\t\t\t\t\tBG.Buffer          = IPPU.TileCache[TILE_4BIT_ODD];\n\t\t\t\t\tBG.Buffered        = IPPU.TileCached[TILE_4BIT_ODD];\n\t\t\t\t\tBG.ConvertTileFlip = ConvertTile4h_even;\n\t\t\t\t\tBG.BufferFlip      = IPPU.TileCache[TILE_4BIT_EVEN];\n\t\t\t\t\tBG.BufferedFlip    = IPPU.TileCached[TILE_4BIT_EVEN];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tBG.ConvertTile = BG.ConvertTileFlip = ConvertTile4;\n\t\t\t\tBG.Buffer      = BG.BufferFlip      = IPPU.TileCache[TILE_4BIT];\n\t\t\t\tBG.Buffered    = BG.BufferedFlip    = IPPU.TileCached[TILE_4BIT];\n\t\t\t}\n\n\t\t\tBG.TileShift        = 5;\n\t\t\tBG.PaletteShift     = 10 - 4;\n\t\t\tBG.PaletteMask      = 7 << 4;\n\t\t\tBG.DirectColourMode = FALSE;\n\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif (hires)\n\t\t\t{\n\t\t\t\tif (sub || mosaic)\n\t\t\t\t{\n\t\t\t\t\tBG.ConvertTile     = ConvertTile2h_even;\n\t\t\t\t\tBG.Buffer          = IPPU.TileCache[TILE_2BIT_EVEN];\n\t\t\t\t\tBG.Buffered        = IPPU.TileCached[TILE_2BIT_EVEN];\n\t\t\t\t\tBG.ConvertTileFlip = ConvertTile2h_odd;\n\t\t\t\t\tBG.BufferFlip      = IPPU.TileCache[TILE_2BIT_ODD];\n\t\t\t\t\tBG.BufferedFlip    = IPPU.TileCached[TILE_2BIT_ODD];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBG.ConvertTile     = ConvertTile2h_odd;\n\t\t\t\t\tBG.Buffer          = IPPU.TileCache[TILE_2BIT_ODD];\n\t\t\t\t\tBG.Buffered        = IPPU.TileCached[TILE_2BIT_ODD];\n\t\t\t\t\tBG.ConvertTileFlip = ConvertTile2h_even;\n\t\t\t\t\tBG.BufferFlip      = IPPU.TileCache[TILE_2BIT_EVEN];\n\t\t\t\t\tBG.BufferedFlip    = IPPU.TileCached[TILE_2BIT_EVEN];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tBG.ConvertTile = BG.ConvertTileFlip = ConvertTile2;\n\t\t\t\tBG.Buffer      = BG.BufferFlip      = IPPU.TileCache[TILE_2BIT];\n\t\t\t\tBG.Buffered    = BG.BufferedFlip    = IPPU.TileCached[TILE_2BIT];\n\t\t\t}\n\n\t\t\tBG.TileShift        = 4;\n\t\t\tBG.PaletteShift     = 10 - 2;\n\t\t\tBG.PaletteMask      = 7 << 2;\n\t\t\tBG.DirectColourMode = FALSE;\n\n\t\t\tbreak;\n\t}\n}\n"
        },
        {
          "name": "tile.h",
          "type": "blob",
          "size": 0.54296875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _TILE_H_\n#define _TILE_H_\n\nvoid S9xInitTileRenderer (void);\nvoid S9xSelectTileRenderers (int, bool8, bool8);\nvoid S9xSelectTileConverter (int, bool8, bool8, bool8);\n\n#endif\n"
        },
        {
          "name": "tileimpl-h2x1.cpp",
          "type": "blob",
          "size": 2.1884765625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#define _TILEIMPL_CPP_\n#include \"tileimpl.h\"\n\nnamespace TileImpl {\n\n\ttemplate<class MATH, class BPSTART>\n\tvoid HiresBase<MATH, BPSTART>::Draw(int N, int M, uint32 Offset, uint32 OffsetInLine, uint8 Pix, uint8 Z1, uint8 Z2)\n\t{\n\t\tif (Z1 > GFX.DB[Offset + 2 * N] && (M))\n\t\t{\n\t\t\tGFX.S[Offset + 2 * N + 1] = MATH::Calc(GFX.ScreenColors[Pix], GFX.SubScreen[Offset + 2 * N], GFX.SubZBuffer[Offset + 2 * N]);\n\t\t\tif ((OffsetInLine + 2 * N ) != (SNES_WIDTH - 1) << 1)\n\t\t\t\tGFX.S[Offset + 2 * N + 2] = MATH::Calc((GFX.ClipColors ? 0 : GFX.SubScreen[Offset + 2 * N + 2]), GFX.RealScreenColors[Pix], GFX.SubZBuffer[Offset + 2 * N]);\n\t\t\tif ((OffsetInLine + 2 * N) == 0 || (OffsetInLine + 2 * N) == GFX.RealPPL)\n\t\t\t\tGFX.S[Offset + 2 * N] = MATH::Calc((GFX.ClipColors ? 0 : GFX.SubScreen[Offset + 2 * N]), GFX.RealScreenColors[Pix], GFX.SubZBuffer[Offset + 2 * N]);\n\t\t\tGFX.DB[Offset + 2 * N] = GFX.DB[Offset + 2 * N + 1] = Z2;\n\t\t}\n\t}\n\n\n\t// hires double width\n\ttemplate struct Renderers<DrawTile16, Hires>;\n\ttemplate struct Renderers<DrawClippedTile16, Hires>;\n\ttemplate struct Renderers<DrawMosaicPixel16, Hires>;\n\ttemplate struct Renderers<DrawBackdrop16, Hires>;\n\ttemplate struct Renderers<DrawMode7MosaicBG1, Hires>;\n\ttemplate struct Renderers<DrawMode7BG1, Hires>;\n\ttemplate struct Renderers<DrawMode7MosaicBG2, Hires>;\n\ttemplate struct Renderers<DrawMode7BG2, Hires>;\n\n\t// hires double width interlace\n\ttemplate struct Renderers<DrawTile16, HiresInterlace>;\n\ttemplate struct Renderers<DrawClippedTile16, HiresInterlace>;\n\ttemplate struct Renderers<DrawMosaicPixel16, HiresInterlace>;\n\t//template struct Renderers<DrawBackdrop16, Hires>;\n\t//template struct Renderers<DrawMode7MosaicBG1, Hires>;\n\t//template struct Renderers<DrawMode7BG1, Hires>;\n\t//template struct Renderers<DrawMode7MosaicBG2, Hires>;\n\t//template struct Renderers<DrawMode7BG2, Hires>;\n\n} // namespace TileImpl\n"
        },
        {
          "name": "tileimpl-n1x1.cpp",
          "type": "blob",
          "size": 1.27734375,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#define _TILEIMPL_CPP_\n#include \"tileimpl.h\"\n\nnamespace TileImpl {\n\n\ttemplate<class MATH, class BPSTART>\n\tvoid Normal1x1Base<MATH, BPSTART>::Draw(int N, int M, uint32 Offset, uint32 OffsetInLine, uint8 Pix, uint8 Z1, uint8 Z2)\n\t{\n\t\t(void) OffsetInLine;\n\t\tif (Z1 > GFX.DB[Offset + N] && (M))\n\t\t{\n\t\t\tGFX.S[Offset + N] = MATH::Calc(GFX.ScreenColors[Pix], GFX.SubScreen[Offset + N], GFX.SubZBuffer[Offset + N]);\n\t\t\tGFX.DB[Offset + N] = Z2;\n\t\t}\n\t}\n\n\n\t// normal width\n\ttemplate struct Renderers<DrawTile16, Normal1x1>;\n\ttemplate struct Renderers<DrawClippedTile16, Normal1x1>;\n\ttemplate struct Renderers<DrawMosaicPixel16, Normal1x1>;\n\ttemplate struct Renderers<DrawBackdrop16, Normal1x1>;\n\ttemplate struct Renderers<DrawMode7MosaicBG1, Normal1x1>;\n\ttemplate struct Renderers<DrawMode7BG1, Normal1x1>;\n\ttemplate struct Renderers<DrawMode7MosaicBG2, Normal1x1>;\n\ttemplate struct Renderers<DrawMode7BG2, Normal1x1>;\n\n} // namespace TileImpl\n"
        },
        {
          "name": "tileimpl-n2x1.cpp",
          "type": "blob",
          "size": 1.8388671875,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#define _TILEIMPL_CPP_\n#include \"tileimpl.h\"\n\nnamespace TileImpl {\n\n\ttemplate<class MATH, class BPSTART>\n\tvoid Normal2x1Base<MATH, BPSTART>::Draw(int N, int M, uint32 Offset, uint32 OffsetInLine, uint8 Pix, uint8 Z1, uint8 Z2)\n\t{\n\t\t(void) OffsetInLine;\n\t\tif (Z1 > GFX.DB[Offset + 2 * N] && (M))\n\t\t{\n\t\t\tGFX.S[Offset + 2 * N] = GFX.S[Offset + 2 * N + 1] = MATH::Calc(GFX.ScreenColors[Pix], GFX.SubScreen[Offset + 2 * N], GFX.SubZBuffer[Offset + 2 * N]);\n\t\t\tGFX.DB[Offset + 2 * N] = GFX.DB[Offset + 2 * N + 1] = Z2;\n\t\t}\n\t}\n\n\n\t// normal double width\n\ttemplate struct Renderers<DrawTile16, Normal2x1>;\n\ttemplate struct Renderers<DrawClippedTile16, Normal2x1>;\n\ttemplate struct Renderers<DrawMosaicPixel16, Normal2x1>;\n\ttemplate struct Renderers<DrawBackdrop16, Normal2x1>;\n\ttemplate struct Renderers<DrawMode7MosaicBG1, Normal2x1>;\n\ttemplate struct Renderers<DrawMode7BG1, Normal2x1>;\n\ttemplate struct Renderers<DrawMode7MosaicBG2, Normal2x1>;\n\ttemplate struct Renderers<DrawMode7BG2, Normal2x1>;\n\n\t// normal double width interlace\n\ttemplate struct Renderers<DrawTile16, Interlace>;\n\ttemplate struct Renderers<DrawClippedTile16, Interlace>;\n\ttemplate struct Renderers<DrawMosaicPixel16, Interlace>;\n\t//template struct Renderers<DrawBackdrop16, Normal2x1>;\n\t//template struct Renderers<DrawMode7MosaicBG1, Normal2x1>;\n\t//template struct Renderers<DrawMode7BG1, Normal2x1>;\n\t//template struct Renderers<DrawMode7MosaicBG2, Normal2x1>;\n\t//template struct Renderers<DrawMode7BG2, Normal2x1>;\n\n} // namespace TileImpl\n"
        },
        {
          "name": "tileimpl.h",
          "type": "blob",
          "size": 22.0400390625,
          "content": "/*****************************************************************************\\\n     Snes9x - Portable Super Nintendo Entertainment System (TM) emulator.\n                This file is licensed under the Snes9x License.\n   For further information, consult the LICENSE file in the root directory.\n\\*****************************************************************************/\n\n#ifndef _TILEIMPL_H_\n#define _TILEIMPL_H_\n\n#include \"snes9x.h\"\n#include \"ppu.h\"\n#include \"tile.h\"\n\nextern struct SLineMatrixData\tLineMatrixData[240];\n\n\nnamespace TileImpl {\n\n\tstruct BPProgressive\n\t{\n\t\tenum { Pitch = 1 };\n\t\tstatic alwaysinline uint32 Get(uint32 StartLine) { return StartLine; }\n\t};\n\n\t// Interlace: Only draw every other line, so we'll redefine bpstart_t and Pitch to do so.\n\t// Otherwise, it's the same as Normal2x1/Hires2x1.\n\tstruct BPInterlace\n\t{\n\t\tenum { Pitch = 2 };\n\t\tstatic alwaysinline uint32 Get(uint32 StartLine) { return StartLine * 2 + BG.InterlaceLine; }\n\t};\n\n\n\t// The 1x1 pixel plotter, for speedhacking modes.\n\ttemplate<class MATH, class BPSTART>\n\tstruct Normal1x1Base\n\t{\n\t\tenum { Pitch = BPSTART::Pitch };\n\t\ttypedef BPSTART bpstart_t;\n\n\t\tstatic void Draw(int N, int M, uint32 Offset, uint32 OffsetInLine, uint8 Pix, uint8 Z1, uint8 Z2);\n\t};\n\n\ttemplate<class MATH>\n\tstruct Normal1x1 : public Normal1x1Base<MATH, BPProgressive> {};\n\n\n\t// The 2x1 pixel plotter, for normal rendering when we've used hires/interlace already this frame.\n\ttemplate<class MATH, class BPSTART>\n\tstruct Normal2x1Base\n\t{\n\t\tenum { Pitch = BPSTART::Pitch };\n\t\ttypedef BPSTART bpstart_t;\n\n\t\tstatic void Draw(int N, int M, uint32 Offset, uint32 OffsetInLine, uint8 Pix, uint8 Z1, uint8 Z2);\n\t};\n\n\ttemplate<class MATH>\n\tstruct Normal2x1 : public Normal2x1Base<MATH, BPProgressive> {};\n\ttemplate<class MATH>\n\tstruct Interlace : public Normal2x1Base<MATH, BPInterlace> {};\n\n\n\t// Hires pixel plotter, this combines the main and subscreen pixels as appropriate to render hires or pseudo-hires images.\n\t// Use it only on the main screen, subscreen should use Normal2x1 instead.\n\t// Hires math:\n\t//     Main pixel is mathed as normal: Main(x, y) * Sub(x, y).\n\t//     Sub pixel is mathed somewhat weird: Basically, for Sub(x + 1, y) we apply the same operation we applied to Main(x, y)\n\t//     (e.g. no math, add fixed, add1/2 subscreen) using Main(x, y) as the \"corresponding subscreen pixel\".\n\t//     Also, color window clipping clips Sub(x + 1, y) if Main(x, y) is clipped, not Main(x + 1, y).\n\t//     We don't know how Sub(0, y) is handled.\n\ttemplate<class MATH, class BPSTART>\n\tstruct HiresBase\n\t{\n\t\tenum { Pitch = BPSTART::Pitch };\n\t\ttypedef BPSTART bpstart_t;\n\n\t\tstatic void Draw(int N, int M, uint32 Offset, uint32 OffsetInLine, uint8 Pix, uint8 Z1, uint8 Z2);\n\t};\n\n\ttemplate<class MATH>\n\tstruct Hires : public HiresBase<MATH, BPProgressive> {};\n\ttemplate<class MATH>\n\tstruct HiresInterlace : public HiresBase<MATH, BPInterlace> {};\n\n\n\tclass CachedTile\n\t{\n\tpublic:\n\t\tCachedTile(uint32 tile) : Tile(tile) {}\n\n\t\talwaysinline void GetCachedTile()\n\t\t{\n\t\t\tTileAddr = BG.TileAddress + ((Tile & 0x3ff) << BG.TileShift);\n\t\t\tif (Tile & 0x100)\n\t\t\t\tTileAddr += BG.NameSelect;\n\t\t\tTileAddr &= 0xffff;\n\t\t\tTileNumber = TileAddr >> BG.TileShift;\n\t\t\tif (Tile & H_FLIP)\n\t\t\t{\n\t\t\t\tpCache = &BG.BufferFlip[TileNumber << 6];\n\t\t\t\tif (!BG.BufferedFlip[TileNumber])\n\t\t\t\t\tBG.BufferedFlip[TileNumber] = BG.ConvertTileFlip(pCache, TileAddr, Tile & 0x3ff);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpCache = &BG.Buffer[TileNumber << 6];\n\t\t\t\tif (!BG.Buffered[TileNumber])\n\t\t\t\t\tBG.Buffered[TileNumber] = BG.ConvertTile(pCache, TileAddr, Tile & 0x3ff);\n\t\t\t}\n\t\t}\n\n\t\talwaysinline bool IsBlankTile() const\n\t\t{\n\t\t\treturn ((Tile & H_FLIP) ? BG.BufferedFlip[TileNumber] : BG.Buffered[TileNumber]) == BLANK_TILE;\n\t\t}\n\n\t\talwaysinline void SelectPalette() const\n\t\t{\n\t\t\tif (BG.DirectColourMode)\n\t\t\t{\n\t\t\t\tGFX.RealScreenColors = DirectColourMaps[(Tile >> 10) & 7];\n\t\t\t}\n\t\t\telse\n\t\t\t\tGFX.RealScreenColors = &IPPU.ScreenColors[((Tile >> BG.PaletteShift) & BG.PaletteMask) + BG.StartPalette];\n\t\t\tGFX.ScreenColors = GFX.ClipColors ? BlackColourMap : GFX.RealScreenColors;\n\t\t}\n\n\t\talwaysinline uint8* Ptr() const\n\t\t{\n\t\t\treturn pCache;\n\t\t}\n\n\tprivate:\n\t\tuint8  *pCache;\n\t\tuint32 Tile;\n\t\tuint32 TileNumber;\n\t\tuint32 TileAddr;\n\t};\n\n\n\tstruct NOMATH\n\t{\n\t\tstatic alwaysinline uint16 Calc(uint16 Main, uint16 Sub, uint8 SD)\n\t\t{\n\t\t\treturn Main;\n\t\t}\n\t};\n\ttypedef NOMATH Blend_None;\n\n\ttemplate<class Op>\n\tstruct REGMATH\n\t{\n\t\tstatic alwaysinline uint16 Calc(uint16 Main, uint16 Sub, uint8 SD)\n\t\t{\n\t\t\treturn Op::fn(Main, (SD & 0x20) ? Sub : GFX.FixedColour);\n\t\t}\n\t};\n\ttypedef REGMATH<COLOR_ADD> Blend_Add;\n\ttypedef REGMATH<COLOR_SUB> Blend_Sub;\n\ttypedef REGMATH<COLOR_ADD_BRIGHTNESS> Blend_AddBrightness;\n\n\ttemplate<class Op>\n\tstruct MATHF1_2\n\t{\n\t\tstatic alwaysinline uint16 Calc(uint16 Main, uint16 Sub, uint8 SD)\n\t\t{\n\t\t\treturn GFX.ClipColors ? Op::fn(Main, GFX.FixedColour) : Op::fn1_2(Main, GFX.FixedColour);\n\t\t}\n\t};\n\ttypedef MATHF1_2<COLOR_ADD> Blend_AddF1_2;\n\ttypedef MATHF1_2<COLOR_SUB> Blend_SubF1_2;\n\n\ttemplate<class Op>\n\tstruct MATHS1_2\n\t{\n\t\tstatic alwaysinline uint16 Calc(uint16 Main, uint16 Sub, uint8 SD)\n\t\t{\n\t\t\treturn GFX.ClipColors ? REGMATH<Op>::Calc(Main, Sub, SD) : (SD & 0x20) ? Op::fn1_2(Main, Sub) : Op::fn(Main, GFX.FixedColour);\n\t\t}\n\t};\n\ttypedef MATHS1_2<COLOR_ADD> Blend_AddS1_2;\n\ttypedef MATHS1_2<COLOR_SUB> Blend_SubS1_2;\n\ttypedef MATHS1_2<COLOR_ADD_BRIGHTNESS> Blend_AddS1_2Brightness;\n\n\ttemplate<\n\t\ttemplate<class PIXEL_> class TILE,\n\t\ttemplate<class MATH> class PIXEL\n\t>\n\tstruct Renderers\n\t{\n\t\tenum { Pitch = PIXEL<Blend_None>::Pitch };\n\t\ttypedef typename TILE< PIXEL<Blend_None> >::call_t call_t;\n\n\t\tstatic call_t Functions[9];\n\t};\n\n\t#ifdef _TILEIMPL_CPP_\n\ttemplate<\n\t\ttemplate<class PIXEL_> class TILE,\n\t\ttemplate<class MATH> class PIXEL\n\t>\n\ttypename Renderers<TILE, PIXEL>::call_t Renderers<TILE, PIXEL>::Functions[9] =\n\t{\n\t\tTILE< PIXEL<Blend_None> >::Draw,\n\t\tTILE< PIXEL<Blend_Add> >::Draw,\n\t\tTILE< PIXEL<Blend_AddF1_2> >::Draw,\n\t\tTILE< PIXEL<Blend_AddS1_2> >::Draw,\n\t\tTILE< PIXEL<Blend_Sub> >::Draw,\n\t\tTILE< PIXEL<Blend_SubF1_2> >::Draw,\n\t\tTILE< PIXEL<Blend_SubS1_2> >::Draw,\n\t\tTILE< PIXEL<Blend_AddBrightness> >::Draw,\n\t\tTILE< PIXEL<Blend_AddS1_2Brightness> >::Draw,\n\t};\n\t#endif\n\n\t// Basic routine to render an unclipped tile.\n\t// Input parameters:\n\t//     bpstart_t = either StartLine or (StartLine * 2 + BG.InterlaceLine),\n\t//     so interlace modes can render every other line from the tile.\n\t//     Pitch = 1 or 2, again so interlace can count lines properly.\n\t//     DRAW_PIXEL(N, M) is a routine to actually draw the pixel. N is the pixel in the row to draw,\n\t//     and M is a test which if false means the pixel should be skipped.\n\t//     Z1 is the \"draw if Z1 > cur_depth\".\n\t//     Z2 is the \"cur_depth = new_depth\". OBJ need the two separate.\n\t//     Pix is the pixel to draw.\n\n\t#define OFFSET_IN_LINE \\\n\t\tuint32 OffsetInLine = Offset % GFX.RealPPL;\n\t#define DRAW_PIXEL(N, M) PIXEL::Draw(N, M, Offset, OffsetInLine, Pix, Z1, Z2)\n\t#define Z1\tGFX.Z1\n\t#define Z2\tGFX.Z2\n\n\ttemplate<class PIXEL>\n\tstruct DrawTile16\n\t{\n\t\ttypedef void (*call_t)(uint32, uint32, uint32, uint32);\n\n\t\tenum { Pitch = PIXEL::Pitch };\n\t\ttypedef typename PIXEL::bpstart_t bpstart_t;\n\n\t\tstatic void Draw(uint32 Tile, uint32 Offset, uint32 StartLine, uint32 LineCount)\n\t\t{\n\t\t\tCachedTile cache(Tile);\n\t\t\tint32\tl;\n\t\t\tuint8\t*bp, Pix;\n\n\t\t\tcache.GetCachedTile();\n\t\t\tif (cache.IsBlankTile())\n\t\t\t\treturn;\n\t\t\tcache.SelectPalette();\n\n\t\t\tif (!(Tile & (V_FLIP | H_FLIP)))\n\t\t\t{\n\t\t\t\tbp = cache.Ptr() + bpstart_t::Get(StartLine);\n\t\t\t\tOFFSET_IN_LINE;\n\t\t\t\tfor (l = LineCount; l > 0; l--, bp += 8 * Pitch, Offset += GFX.PPL)\n\t\t\t\t{\n\t\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\t\tPix = bp[x]; DRAW_PIXEL(x, Pix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (!(Tile & V_FLIP))\n\t\t\t{\n\t\t\t\tbp = cache.Ptr() + bpstart_t::Get(StartLine);\n\t\t\t\tOFFSET_IN_LINE;\n\t\t\t\tfor (l = LineCount; l > 0; l--, bp += 8 * Pitch, Offset += GFX.PPL)\n\t\t\t\t{\n\t\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\t\tPix = bp[7 - x]; DRAW_PIXEL(x, Pix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (!(Tile & H_FLIP))\n\t\t\t{\n\t\t\t\tbp = cache.Ptr() + 56 - bpstart_t::Get(StartLine);\n\t\t\t\tOFFSET_IN_LINE;\n\t\t\t\tfor (l = LineCount; l > 0; l--, bp -= 8 * Pitch, Offset += GFX.PPL)\n\t\t\t\t{\n\t\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\t\tPix = bp[x]; DRAW_PIXEL(x, Pix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbp = cache.Ptr() + 56 - bpstart_t::Get(StartLine);\n\t\t\t\tOFFSET_IN_LINE;\n\t\t\t\tfor (l = LineCount; l > 0; l--, bp -= 8 * Pitch, Offset += GFX.PPL)\n\t\t\t\t{\n\t\t\t\t\tfor (int x = 0; x < 8; x++) {\n\t\t\t\t\t\tPix = bp[7 - x]; DRAW_PIXEL(x, Pix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t#undef Z1\n\t#undef Z2\n\n\t// Basic routine to render a clipped tile. Inputs same as above.\n\n\t#define Z1\tGFX.Z1\n\t#define Z2\tGFX.Z2\n\n\ttemplate<class PIXEL>\n\tstruct DrawClippedTile16\n\t{\n\t\ttypedef void (*call_t)(uint32, uint32, uint32, uint32, uint32, uint32);\n\n\t\tenum { Pitch = PIXEL::Pitch };\n\t\ttypedef typename PIXEL::bpstart_t bpstart_t;\n\n\t\tstatic void Draw(uint32 Tile, uint32 Offset, uint32 StartPixel, uint32 Width, uint32 StartLine, uint32 LineCount)\n\t\t{\n\t\t\tCachedTile cache(Tile);\n\t\t\tint32\tl;\n\t\t\tuint8\t*bp, Pix, w;\n\n\t\t\tcache.GetCachedTile();\n\t\t\tif (cache.IsBlankTile())\n\t\t\t\treturn;\n\t\t\tcache.SelectPalette();\n\n\t\t\tif (!(Tile & (V_FLIP | H_FLIP)))\n\t\t\t{\n\t\t\t\tbp = cache.Ptr() + bpstart_t::Get(StartLine);\n\t\t\t\tOFFSET_IN_LINE;\n\t\t\t\tfor (l = LineCount; l > 0; l--, bp += 8 * Pitch, Offset += GFX.PPL)\n\t\t\t\t{\n\t\t\t\t\tw = Width;\n\t\t\t\t\tswitch (StartPixel)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 0: Pix = bp[0]; DRAW_PIXEL(0, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 1: Pix = bp[1]; DRAW_PIXEL(1, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 2: Pix = bp[2]; DRAW_PIXEL(2, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 3: Pix = bp[3]; DRAW_PIXEL(3, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 4: Pix = bp[4]; DRAW_PIXEL(4, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 5: Pix = bp[5]; DRAW_PIXEL(5, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 6: Pix = bp[6]; DRAW_PIXEL(6, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 7: Pix = bp[7]; DRAW_PIXEL(7, Pix); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (!(Tile & V_FLIP))\n\t\t\t{\n\t\t\t\tbp = cache.Ptr() + bpstart_t::Get(StartLine);\n\t\t\t\tOFFSET_IN_LINE;\n\t\t\t\tfor (l = LineCount; l > 0; l--, bp += 8 * Pitch, Offset += GFX.PPL)\n\t\t\t\t{\n\t\t\t\t\tw = Width;\n\t\t\t\t\tswitch (StartPixel)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 0: Pix = bp[7]; DRAW_PIXEL(0, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 1: Pix = bp[6]; DRAW_PIXEL(1, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 2: Pix = bp[5]; DRAW_PIXEL(2, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 3: Pix = bp[4]; DRAW_PIXEL(3, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 4: Pix = bp[3]; DRAW_PIXEL(4, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 5: Pix = bp[2]; DRAW_PIXEL(5, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 6: Pix = bp[1]; DRAW_PIXEL(6, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 7: Pix = bp[0]; DRAW_PIXEL(7, Pix); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (!(Tile & H_FLIP))\n\t\t\t{\n\t\t\t\tbp = cache.Ptr() + 56 - bpstart_t::Get(StartLine);\n\t\t\t\tOFFSET_IN_LINE;\n\t\t\t\tfor (l = LineCount; l > 0; l--, bp -= 8 * Pitch, Offset += GFX.PPL)\n\t\t\t\t{\n\t\t\t\t\tw = Width;\n\t\t\t\t\tswitch (StartPixel)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 0: Pix = bp[0]; DRAW_PIXEL(0, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 1: Pix = bp[1]; DRAW_PIXEL(1, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 2: Pix = bp[2]; DRAW_PIXEL(2, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 3: Pix = bp[3]; DRAW_PIXEL(3, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 4: Pix = bp[4]; DRAW_PIXEL(4, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 5: Pix = bp[5]; DRAW_PIXEL(5, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 6: Pix = bp[6]; DRAW_PIXEL(6, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 7: Pix = bp[7]; DRAW_PIXEL(7, Pix); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbp = cache.Ptr() + 56 - bpstart_t::Get(StartLine);\n\t\t\t\tOFFSET_IN_LINE;\n\t\t\t\tfor (l = LineCount; l > 0; l--, bp -= 8 * Pitch, Offset += GFX.PPL)\n\t\t\t\t{\n\t\t\t\t\tw = Width;\n\t\t\t\t\tswitch (StartPixel)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 0: Pix = bp[7]; DRAW_PIXEL(0, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 1: Pix = bp[6]; DRAW_PIXEL(1, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 2: Pix = bp[5]; DRAW_PIXEL(2, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 3: Pix = bp[4]; DRAW_PIXEL(3, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 4: Pix = bp[3]; DRAW_PIXEL(4, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 5: Pix = bp[2]; DRAW_PIXEL(5, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 6: Pix = bp[1]; DRAW_PIXEL(6, Pix); if (!--w) break; /* Fall through */\n\t\t\t\t\t\tcase 7: Pix = bp[0]; DRAW_PIXEL(7, Pix); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t#undef Z1\n\t#undef Z2\n\n\t// Basic routine to render a single mosaic pixel.\n\t// DRAW_PIXEL, bpstart_t, Z1, Z2 and Pix are the same as above, but Pitch is not used.\n\n\t#define Z1\tGFX.Z1\n\t#define Z2\tGFX.Z2\n\n\ttemplate<class PIXEL>\n\tstruct DrawMosaicPixel16\n\t{\n\t\ttypedef void (*call_t)(uint32, uint32, uint32, uint32, uint32, uint32);\n\n\t\ttypedef typename PIXEL::bpstart_t bpstart_t;\n\n\t\tstatic void Draw(uint32 Tile, uint32 Offset, uint32 StartLine, uint32 StartPixel, uint32 Width, uint32 LineCount)\n\t\t{\n\t\t\tCachedTile cache(Tile);\n\t\t\tint32\tl, w;\n\t\t\tuint8\tPix;\n\n\t\t\tcache.GetCachedTile();\n\t\t\tif (cache.IsBlankTile())\n\t\t\t\treturn;\n\t\t\tcache.SelectPalette();\n\n\t\t\tif (Tile & H_FLIP)\n\t\t\t\tStartPixel = 7 - StartPixel;\n\n\t\t\tif (Tile & V_FLIP)\n\t\t\t\tPix = cache.Ptr()[56 - bpstart_t::Get(StartLine) + StartPixel];\n\t\t\telse\n\t\t\t\tPix = cache.Ptr()[bpstart_t::Get(StartLine) + StartPixel];\n\n\t\t\tif (Pix)\n\t\t\t{\n\t\t\t\tOFFSET_IN_LINE;\n\t\t\t\tfor (l = LineCount; l > 0; l--, Offset += GFX.PPL)\n\t\t\t\t{\n\t\t\t\t\tfor (w = Width - 1; w >= 0; w--)\n\t\t\t\t\t\tDRAW_PIXEL(w, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t#undef Z1\n\t#undef Z2\n\n\t// Basic routine to render the backdrop.\n\t// DRAW_PIXEL is the same as above, but since we're just replicating a single pixel there's no need for Pitch or bpstart_t\n\t// (or interlace at all, really).\n\t// The backdrop is always depth = 1, so Z1 = Z2 = 1. And backdrop is always color 0.\n\n\t#define Z1\t\t\t\t1\n\t#define Z2\t\t\t\t1\n\t#define Pix\t\t\t\t0\n\n\ttemplate<class PIXEL>\n\tstruct DrawBackdrop16\n\t{\n\t\ttypedef void (*call_t)(uint32 Offset, uint32 Left, uint32 Right);\n\n\t\tstatic void Draw(uint32 Offset, uint32 Left, uint32 Right)\n\t\t{\n\t\t\tuint32\tl, x;\n\n\t\t\tGFX.RealScreenColors = IPPU.ScreenColors;\n\t\t\tGFX.ScreenColors = GFX.ClipColors ? BlackColourMap : GFX.RealScreenColors;\n\t\t\tif (Settings.ForcedBackdrop)\n\t\t\t\tGFX.ScreenColors = &Settings.ForcedBackdrop;\n\n\t\t\tOFFSET_IN_LINE;\n\t\t\tfor (l = GFX.StartY; l <= GFX.EndY; l++, Offset += GFX.PPL)\n\t\t\t{\n\t\t\t\tfor (x = Left; x < Right; x++)\n\t\t\t\t\tDRAW_PIXEL(x, 1);\n\t\t\t}\n\t\t}\n\t};\n\n\t#undef Pix\n\t#undef Z1\n\t#undef Z2\n\t#undef DRAW_PIXEL\n\n\t// Basic routine to render a chunk of a Mode 7 BG.\n\t// Mode 7 has no interlace, so bpstart_t and Pitch are unused.\n\t// We get some new parameters, so we can use the same DRAW_TILE to do BG1 or BG2:\n\t//     DCMODE tests if Direct Color should apply.\n\t//     BG is the BG, so we use the right clip window.\n\t//     MASK is 0xff or 0x7f, the 'color' portion of the pixel.\n\t// We define Z1/Z2 to either be constant 5 or to vary depending on the 'priority' portion of the pixel.\n\n\t#define CLIP_10_BIT_SIGNED(a)\t(((a) & 0x2000) ? ((a) | ~0x3ff) : ((a) & 0x3ff))\n\n\t#define DRAW_PIXEL(N, M) PIXEL::Draw(N, M, Offset, OffsetInLine, Pix, OP::Z1(D, b), OP::Z2(D, b))\n\n\tstruct DrawMode7BG1_OP\n\t{\n\t\tenum {\n\t\t\tMASK = 0xff,\n\t\t\tBG   = 0\n\t\t};\n\t\tstatic uint8 Z1(int D, uint8 b) { return D + 7; }\n\t\tstatic uint8 Z2(int D, uint8 b) { return D + 7; }\n\t\tstatic uint8 DCMODE() { return Memory.FillRAM[0x2130] & 1; }\n\t};\n\tstruct DrawMode7BG2_OP\n\t{\n\t\tenum {\n\t\t\tMASK = 0x7f,\n\t\t\tBG   = 1\n\t\t};\n\t\tstatic uint8 Z1(int D, uint8 b) { return D + ((b & 0x80) ? 11 : 3); }\n\t\tstatic uint8 Z2(int D, uint8 b) { return D + ((b & 0x80) ? 11 : 3); }\n\t\tstatic uint8 DCMODE() { return 0; }\n\t};\n\n\ttemplate<class PIXEL, class OP>\n\tstruct DrawTileNormal\n\t{\n\t\ttypedef void (*call_t)(uint32 Left, uint32 Right, int D);\n\n\t\tstatic void Draw(uint32 Left, uint32 Right, int D)\n\t\t{\n\t\t\tuint8\t*VRAM1 = Memory.VRAM + 1;\n\n\t\t\tif (OP::DCMODE())\n\t\t\t{\n\t\t\t\tGFX.RealScreenColors = DirectColourMaps[0];\n\t\t\t}\n\t\t\telse\n\t\t\t\tGFX.RealScreenColors = IPPU.ScreenColors;\n\n\t\t\tGFX.ScreenColors = GFX.ClipColors ? BlackColourMap : GFX.RealScreenColors;\n\n\t\t\tint\taa, cc;\n\t\t\tint\tstartx;\n\n\t\t\tuint32\tOffset = GFX.StartY * GFX.PPL;\n\t\t\tstruct SLineMatrixData\t*l = &LineMatrixData[GFX.StartY];\n\n\t\t\tOFFSET_IN_LINE;\n\t\t\tfor (uint32 Line = GFX.StartY; Line <= GFX.EndY; Line++, Offset += GFX.PPL, l++)\n\t\t\t{\n\t\t\t\tint\tyy, starty;\n\n\t\t\t\tint32\tHOffset = ((int32) l->M7HOFS  << 19) >> 19;\n\t\t\t\tint32\tVOffset = ((int32) l->M7VOFS  << 19) >> 19;\n\n\t\t\t\tint32\tCentreX = ((int32) l->CentreX << 19) >> 19;\n\t\t\t\tint32\tCentreY = ((int32) l->CentreY << 19) >> 19;\n\n\t\t\t\tif (PPU.Mode7VFlip)\n\t\t\t\t\tstarty = 255 - (int) (Line + 1);\n\t\t\t\telse\n\t\t\t\t\tstarty = Line + 1;\n\n\t\t\t\tyy = CLIP_10_BIT_SIGNED(VOffset - CentreY);\n\n\t\t\t\tint\tBB = ((l->MatrixB * starty) & ~63) + ((l->MatrixB * yy) & ~63) + (CentreX << 8);\n\t\t\t\tint\tDD = ((l->MatrixD * starty) & ~63) + ((l->MatrixD * yy) & ~63) + (CentreY << 8);\n\n\t\t\t\tif (PPU.Mode7HFlip)\n\t\t\t\t{\n\t\t\t\t\tstartx = Right - 1;\n\t\t\t\t\taa = -l->MatrixA;\n\t\t\t\t\tcc = -l->MatrixC;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstartx = Left;\n\t\t\t\t\taa = l->MatrixA;\n\t\t\t\t\tcc = l->MatrixC;\n\t\t\t\t}\n\n\t\t\t\tint\txx = CLIP_10_BIT_SIGNED(HOffset - CentreX);\n\t\t\t\tint\tAA = l->MatrixA * startx + ((l->MatrixA * xx) & ~63);\n\t\t\t\tint\tCC = l->MatrixC * startx + ((l->MatrixC * xx) & ~63);\n\n\t\t\t\tuint8\tPix;\n\n\t\t\t\tif (!PPU.Mode7Repeat)\n\t\t\t\t{\n\t\t\t\t\tfor (uint32 x = Left; x < Right; x++, AA += aa, CC += cc)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\tX = ((AA + BB) >> 8) & 0x3ff;\n\t\t\t\t\t\tint\tY = ((CC + DD) >> 8) & 0x3ff;\n\n\t\t\t\t\t\tuint8\t*TileData = VRAM1 + (Memory.VRAM[((Y & ~7) << 5) + ((X >> 2) & ~1)] << 7);\n\t\t\t\t\t\tuint8\tb = *(TileData + ((Y & 7) << 4) + ((X & 7) << 1));\n\n\t\t\t\t\t\tPix = b & OP::MASK; DRAW_PIXEL(x, Pix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (uint32 x = Left; x < Right; x++, AA += aa, CC += cc)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\tX = ((AA + BB) >> 8);\n\t\t\t\t\t\tint\tY = ((CC + DD) >> 8);\n\n\t\t\t\t\t\tuint8\tb;\n\n\t\t\t\t\t\tif (((X | Y) & ~0x3ff) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8\t*TileData = VRAM1 + (Memory.VRAM[((Y & ~7) << 5) + ((X >> 2) & ~1)] << 7);\n\t\t\t\t\t\t\tb = *(TileData + ((Y & 7) << 4) + ((X & 7) << 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (PPU.Mode7Repeat == 3)\n\t\t\t\t\t\t\tb = *(VRAM1    + ((Y & 7) << 4) + ((X & 7) << 1));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tPix = b & OP::MASK; DRAW_PIXEL(x, Pix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\ttemplate<class PIXEL>\n\tstruct DrawMode7BG1 : public DrawTileNormal<PIXEL, DrawMode7BG1_OP> {};\n\ttemplate<class PIXEL>\n\tstruct DrawMode7BG2 : public DrawTileNormal<PIXEL, DrawMode7BG2_OP> {};\n\n\ttemplate<class PIXEL, class OP>\n\tstruct DrawTileMosaic\n\t{\n\t\ttypedef void (*call_t)(uint32 Left, uint32 Right, int D);\n\n\t\tstatic void Draw(uint32 Left, uint32 Right, int D)\n\t\t{\n\t\t\tuint8\t*VRAM1 = Memory.VRAM + 1;\n\n\t\t\tif (OP::DCMODE())\n\t\t\t{\n\t\t\t\tGFX.RealScreenColors = DirectColourMaps[0];\n\t\t\t}\n\t\t\telse\n\t\t\t\tGFX.RealScreenColors = IPPU.ScreenColors;\n\n\t\t\tGFX.ScreenColors = GFX.ClipColors ? BlackColourMap : GFX.RealScreenColors;\n\n\t\t\tint\taa, cc;\n\t\t\tint\tstartx, StartY = GFX.StartY;\n\n\t\t\tint\t\tHMosaic = 1, VMosaic = 1, MosaicStart = 0;\n\t\t\tint32\tMLeft = Left, MRight = Right;\n\n\t\t\tif (PPU.BGMosaic[0])\n\t\t\t{\n\t\t\t\tVMosaic = PPU.Mosaic;\n\t\t\t\tMosaicStart = ((uint32) GFX.StartY - PPU.MosaicStart) % VMosaic;\n\t\t\t\tStartY -= MosaicStart;\n\t\t\t}\n\n\t\t\tif (PPU.BGMosaic[OP::BG])\n\t\t\t{\n\t\t\t\tHMosaic = PPU.Mosaic;\n\t\t\t\tMLeft  -= MLeft  % HMosaic;\n\t\t\t\tMRight += HMosaic - 1;\n\t\t\t\tMRight -= MRight % HMosaic;\n\t\t\t}\n\n\t\t\tuint32\tOffset = StartY * GFX.PPL;\n\t\t\tstruct SLineMatrixData\t*l = &LineMatrixData[StartY];\n\n\t\t\tOFFSET_IN_LINE;\n\t\t\tfor (uint32 Line = StartY; Line <= GFX.EndY; Line += VMosaic, Offset += VMosaic * GFX.PPL, l += VMosaic)\n\t\t\t{\n\t\t\t\tif (Line + VMosaic > GFX.EndY)\n\t\t\t\t\tVMosaic = GFX.EndY - Line + 1;\n\n\t\t\t\tint\tyy, starty;\n\n\t\t\t\tint32\tHOffset = ((int32) l->M7HOFS  << 19) >> 19;\n\t\t\t\tint32\tVOffset = ((int32) l->M7VOFS  << 19) >> 19;\n\n\t\t\t\tint32\tCentreX = ((int32) l->CentreX << 19) >> 19;\n\t\t\t\tint32\tCentreY = ((int32) l->CentreY << 19) >> 19;\n\n\t\t\t\tif (PPU.Mode7VFlip)\n\t\t\t\t\tstarty = 255 - (int) (Line + 1);\n\t\t\t\telse\n\t\t\t\t\tstarty = Line + 1;\n\n\t\t\t\tyy = CLIP_10_BIT_SIGNED(VOffset - CentreY);\n\n\t\t\t\tint\tBB = ((l->MatrixB * starty) & ~63) + ((l->MatrixB * yy) & ~63) + (CentreX << 8);\n\t\t\t\tint\tDD = ((l->MatrixD * starty) & ~63) + ((l->MatrixD * yy) & ~63) + (CentreY << 8);\n\n\t\t\t\tif (PPU.Mode7HFlip)\n\t\t\t\t{\n\t\t\t\t\tstartx = MRight - 1;\n\t\t\t\t\taa = -l->MatrixA;\n\t\t\t\t\tcc = -l->MatrixC;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstartx = MLeft;\n\t\t\t\t\taa = l->MatrixA;\n\t\t\t\t\tcc = l->MatrixC;\n\t\t\t\t}\n\n\t\t\t\tint\txx = CLIP_10_BIT_SIGNED(HOffset - CentreX);\n\t\t\t\tint\tAA = l->MatrixA * startx + ((l->MatrixA * xx) & ~63);\n\t\t\t\tint\tCC = l->MatrixC * startx + ((l->MatrixC * xx) & ~63);\n\n\t\t\t\tuint8\tPix;\n\t\t\t\tuint8\tctr = 1;\n\n\t\t\t\tif (!PPU.Mode7Repeat)\n\t\t\t\t{\n\t\t\t\t\tfor (int32 x = MLeft; x < MRight; x++, AA += aa, CC += cc)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (--ctr)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tctr = HMosaic;\n\n\t\t\t\t\t\tint\tX = ((AA + BB) >> 8) & 0x3ff;\n\t\t\t\t\t\tint\tY = ((CC + DD) >> 8) & 0x3ff;\n\n\t\t\t\t\t\tuint8\t*TileData = VRAM1 + (Memory.VRAM[((Y & ~7) << 5) + ((X >> 2) & ~1)] << 7);\n\t\t\t\t\t\tuint8\tb = *(TileData + ((Y & 7) << 4) + ((X & 7) << 1));\n\n\t\t\t\t\t\tif ((Pix = (b & OP::MASK)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int32 h = MosaicStart; h < VMosaic; h++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int32 w = x + HMosaic - 1; w >= x; w--)\n\t\t\t\t\t\t\t\t\tDRAW_PIXEL(w + h * GFX.PPL, (w >= (int32) Left && w < (int32) Right));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int32 x = MLeft; x < MRight; x++, AA += aa, CC += cc)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (--ctr)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tctr = HMosaic;\n\n\t\t\t\t\t\tint\tX = ((AA + BB) >> 8);\n\t\t\t\t\t\tint\tY = ((CC + DD) >> 8);\n\n\t\t\t\t\t\tuint8\tb;\n\n\t\t\t\t\t\tif (((X | Y) & ~0x3ff) == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8\t*TileData = VRAM1 + (Memory.VRAM[((Y & ~7) << 5) + ((X >> 2) & ~1)] << 7);\n\t\t\t\t\t\t\tb = *(TileData + ((Y & 7) << 4) + ((X & 7) << 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\tif (PPU.Mode7Repeat == 3)\n\t\t\t\t\t\t\tb = *(VRAM1    + ((Y & 7) << 4) + ((X & 7) << 1));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif ((Pix = (b & OP::MASK)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int32 h = MosaicStart; h < VMosaic; h++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int32 w = x + HMosaic - 1; w >= x; w--)\n\t\t\t\t\t\t\t\t\tDRAW_PIXEL(w + h * GFX.PPL, (w >= (int32) Left && w < (int32) Right));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tMosaicStart = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\ttemplate<class PIXEL>\n\tstruct DrawMode7MosaicBG1 : public DrawTileMosaic<PIXEL, DrawMode7BG1_OP> {};\n\ttemplate<class PIXEL>\n\tstruct DrawMode7MosaicBG2 : public DrawTileMosaic<PIXEL, DrawMode7BG2_OP> {};\n\n\t#undef DRAW_PIXEL\n\n} // namespace TileImpl\n\n#endif\n"
        },
        {
          "name": "unix",
          "type": "tree",
          "content": null
        },
        {
          "name": "unzip",
          "type": "tree",
          "content": null
        },
        {
          "name": "var8x10font.h",
          "type": "blob",
          "size": 22.5703125,
          "content": "#ifndef __VAR8X10FONT_H\n#define __VAR8X10FONT_H\n\nstatic const char var8x10font_kern[224][2] =\n{\n{ 2, 2 },{ 2, 3 },{ 1, 2 },{ 0, 1 },{ 0, 1 },{ 0, 2 },{ 0, 2 },{ 0, 3 },{ 1, 3 },{ 1, 3 },{ 0, 3 },{ 0, 1 },{ 0, 3 },{ 0, 2 },{ 1, 3 },{ 0, 2 },\n{ 0, 2 },{ 0, 3 },{ 0, 2 },{ 0, 2 },{ 0, 1 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 1, 3 },{ 0, 3 },{ 0, 3 },{ 0, 2 },{ 0, 3 },{ 0, 3 },\n{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 3 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 1 },{ 0, 1 },{ 0, 2 },\n{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 3 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 2 },{ 0, 1 },{ 0, 2 },{ 0, 3 },{ 0, 2 },{ 0, 3 },{ 0, 3 },{ 0, 2 },\n{ 0, 3 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 1, 4 },{ 0, 3 },{ 0, 2 },{ 1, 4 },{ 0, 1 },{ 0, 2 },{ 0, 2 },\n{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 3 },{ 0, 2 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 1, 0 },{ 0, 4 },{ 0, 2 },{ 2, 2 },\n{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },\n{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },\n{ 2, 2 },{ 0, 3 },{ 2, 2 },{ 2, 2 },{ 2, 1 },{ 1, 3 },{ 0, 1 },{ 0, 3 },{ 0, 3 },{ 0, 3 },{ 0, 3 },{ 0, 3 },{ 0, 2 },{ 0, 2 },{ 1, 3 },{ 0, 1 },\n{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 2 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 1 },\n{ 0, 1 },{ 0, 2 },{ 0, 1 },{ 0, 1 },{ 1, 2 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 1, 2 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 1 },\n{ 1, 2 },{ 0, 2 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 1, 1 },{ 0, 1 },{ 1, 1 },{ 0, 1 },{ 0, 2 },{ 0, 1 },{ 0, 1 },{ 0, 1 },{ 0, 2 },{ 0, 3 },\n{ 1, 2 },{ 1, 2 },{ 0, 1 },{ 0, 1 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },\n{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },{ 2, 2 },\n};\n\nstatic const char *var8x10font[] =\n{\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"           .      . .              .                               .      .                                                     \",\n    \"          .#.    .#.#.            .#..   .                ..      .#.    .#.                                                    \",\n    \"          .#.    .#.#.    . .    .####. .#. .     .      .##.    .#.      .#.    . .       .                                .   \",\n    \"          .#.    .#.#.   .#.#.  .#.#..  .#..#.   .#.     .#.     .#.      .#.   .#.#.     .#.                              .#.  \",\n    \"          .#.     . .   .#####.  .###.   ..#.   .#.#.   .#.      .#.      .#.    .#.     ..#..           ....             .#.   \",\n    \"          .#.            .#.#.   ..#.#.  .#..    .#.     .       .#.      .#.   .###.   .#####.   ..    .####.    ..     .#.    \",\n    \"           .            .#####. .####.  .#..#.  .#.#.            .#.      .#.    .#.     ..#..   .##.    ....    .##.   .#.     \",\n    \"          .#.            .#.#.   ..#.    . .#.   .#.#.            .#.    .#.    .#.#.     .#.    .#.             .##.    .      \",\n    \"           .              . .      .        .     . .              .      .      . .       .    .#.               ..            \",\n    \"                                                                                                 .                              \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"  ..      .       ..      ..        .    ....     ..     ....     ..      ..                                              .     \",\n    \" .##.    .#.     .##.    .##.      .#.  .####.   .##.   .####.   .##.    .##.                                            .#.    \",\n    \".#..#.  .##.    .#..#.  .#..#.    .##.  .#...   .#..#.   ...#.  .#..#.  .#..#.    ..      ..       .             .      .#.#.   \",\n    \".#.##.   .#.     . .#.   ...#.   .#.#.  .#..    .#...      .#.  .#..#.  .#..#.   .##.    .##.     .#.    ....   .#.      ..#.   \",\n    \".##.#.   .#.     ..#.    .##.   .#..#.  .###.   .###.     .#.    .##.    .###.   .##.    .##.    .#.    .####.   .#.     .#.    \",\n    \".#..#.   .#.     .#.     ...#.  .#####.  ...#.  .#..#.    .#.   .#..#.   ...#.    ..      ..    .#.      ....     .#.    .#.    \",\n    \".#..#.   .#.    .#...   .#..#.   ...#.  .#..#.  .#..#.   .#.    .#..#.  .#..#.   .##.    .##.    .#.    .####.   .#.      .     \",\n    \" .##.   .###.   .####.   .##.      .#.   .##.    .##.    .#.     .##.    .##.    .##.    .#.      .#.    ....   .#.      .#.    \",\n    \"  ..     ...     ....     ..        .     ..      ..      .       ..      ..      ..    .#.        .             .        .     \",\n    \"                                                                                         .                                      \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"          ..     ...      ..     ...     ....    ....     ..     .  .    ...        .    .  .    .       .. .    .   .    ..    \",\n    \"  ..     .##.   .###.    .##.   .###.   .####.  .####.   .##.   .#..#.  .###.      .#.  .#..#.  .#.     .##.#.  .#. .#.  .##.   \",\n    \" .##.   .#..#.  .#..#.  .#..#.  .#..#.  .#...   .#...   .#..#.  .#..#.   .#.       .#.  .#..#.  .#.     .#.#.#. .##..#. .#..#.  \",\n    \".#..#.  .#..#.  .#..#.  .#. .   .#..#.  .#..    .#..    .#...   .#..#.   .#.       .#.  .#.#.   .#.     .#.#.#. .#.#.#. .#..#.  \",\n    \".#.##.  .####.  .###.   .#.     .#..#.  .###.   .###.   .#.##.  .####.   .#.       .#.  .##.    .#.     .#.#.#. .#..##. .#..#.  \",\n    \".#.##.  .#..#.  .#..#.  .#. .   .#..#.  .#..    .#..    .#..#.  .#..#.   .#.     . .#.  .#.#.   .#.     .#...#. .#. .#. .#..#.  \",\n    \".#...   .#..#.  .#..#.  .#..#.  .#..#.  .#...   .#.     .#..#.  .#..#.   .#.    .#..#.  .#..#.  .#...   .#. .#. .#. .#. .#..#.  \",\n    \" .##.   .#..#.  .###.    .##.   .###.   .####.  .#.      .##.   .#..#.  .###.    .##.   .#..#.  .####.  .#. .#. .#. .#.  .##.   \",\n    \"  ..     .  .    ...      ..     ...     ....    .        ..     .  .    ...      ..     .  .    ....    .   .   .   .    ..    \",\n    \"                                                                                                                                \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \" ...      ..     ...      ..     ...     .   .   .   .   .   .   .  .    .   .   ....    ...             ...                    \",\n    \".###.    .##.   .###.    .##.   .###.   .#. .#. .#. .#. .#. .#. .#..#.  .#. .#. .####.  .###.           .###.     .             \",\n    \".#..#.  .#..#.  .#..#.  .#..#.   .#.    .#. .#. .#. .#. .#. .#. .#..#.  .#. .#.  ...#.  .#..     .       ..#.    .#.            \",\n    \".#..#.  .#..#.  .#..#.  .#...    .#.    .#. .#. .#. .#. .#...#. .#..#.  .#. .#.   .#.   .#.     .#.       .#.   .#.#.           \",\n    \".###.   .#..#.  .###.    .##.    .#.    .#. .#. .#. .#. .#.#.#.  .##.    .#.#.   .#.    .#.      .#.      .#.    . .            \",\n    \".#..    .#..#.  .#..#.   ...#.   .#.    .#. .#. .#. .#. .#.#.#. .#..#.    .#.   .#.     .#.       .#.     .#.                   \",\n    \".#.      .##.   .#..#.  .#..#.   .#.    .#...#.  .#.#.  .##.##. .#..#.    .#.   .#...   .#..       .#.   ..#.            ....   \",\n    \".#.       ..#.  .#..#.   .##.    .#.     .###.    .#.   .#. .#. .#..#.    .#.   .####.  .###.       .   .###.           .####.  \",\n    \" .          .    .  .     ..      .       ...      .     .   .   .  .      .     ....    ...             ...             ....   \",\n    \"                                                                                                                                \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"                 .                  .              .             .        .        .     .        .                             \",\n    \" ..             .#.                .#.            .#.           .#.      .#.      .#.   .#.      .#.                            \",\n    \".##.      ...   .#..      ...     ..#.    ..     .#.#.    ...   .#..      .        .    .#..     .#.     .. ..   ...      ..    \",\n    \" .#.     .###.  .###.    .###.   .###.   .##.    .#..    .###.  .###.    .#.      .#.   .#.#.    .#.    .##.##. .###.    .##.   \",\n    \"  .#.   .#..#.  .#..#.  .#...   .#..#.  .#..#.  .###.   .#..#.  .#..#.   .#.      .#.   .##.     .#.    .#.#.#. .#..#.  .#..#.  \",\n    \"   .    .#..#.  .#..#.  .#.     .#..#.  .####.   .#.    .#..#.  .#..#.   .#.      .#.   .##.     .#.    .#.#.#. .#..#.  .#..#.  \",\n    \"        .#.##.  .#..#.  .#...   .#..#.  .#...    .#.     .###.  .#..#.   .#.     ..#.   .#.#.    .#.    .#.#.#. .#..#.  .#..#.  \",\n    \"         .#.#.  .###.    .###.   .###.   .###.   .#.      ..#.  .#..#.   .#.    .#.#.   .#..#.   .#.    .#.#.#. .#..#.   .##.   \",\n    \"          . .    ...      ...     ...     ...     .      .##.    .  .     .      .#.     .  .     .      . . .   .  .     ..    \",\n    \"                                                          ..                      .                                             \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"                                  .                                                        ..     .    ..                       \",\n    \"                                 .#.                                                      .##.   .#.  .##.        . .           \",\n    \" ...      ...    ...      ...    .#.     .  .    .   .   .   .   .   .   .  .    ....    .#..    .#.   ..#.      .#.#.          \",\n    \".###.    .###.  .###.    .###.  .###.   .#..#.  .#. .#. .#...#. .#. .#. .#..#.  .####.  .#.      .#.     .#.    .#.#.           \",\n    \".#..#.  .#..#.  .#..#.  .#...    .#.    .#..#.  .#. .#. .#.#.#.  .#.#.  .#..#.   ...#.  .#.       .      .#.     . .            \",\n    \".#..#.  .#..#.  .#. .    .##.    .#.    .#..#.   .#.#.  .#.#.#.   .#.   .#..#.    .#.   .#.      .#.     .#.                    \",\n    \".###.    .###.  .#.      ...#.   .#.    .#..#.   .#.#.  .#.#.#.  .#.#.   .#.#.   .#..    .#..    .#.   ..#.                     \",\n    \".#..      ..#.  .#.     .###.    .#.     .###.    .#.    .#.#.  .#. .#.   .#.   .####.    .##.   .#.  .##.                      \",\n    \".#.        .#.   .       ...      .       ...      .      . .    .   .   .#.     ....      ..     .    ..                       \",\n    \" .          .                                                             .                                                     \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"                                                                                                                                \",\n    \"                   ..                            .....                                                                          \",\n    \"                  .##.                          .#####.  ...       .      .               .       .               ..            \",\n    \"                  .#.       .             ..     ....#. .###.     .#.    .#.             .#.     .#..            .##.    . . .  \",\n    \"                  .#.      .#.           .##.   .#####.  ..#.    .#.    .###.    ...    .###.    .###.    ..      .#.   .#.#.#. \",\n    \"          .       .#.      .#.     .     .##.    ....#.  .#.    .##.    .#.#.   .###.    .#.    .##.#.   .##.    .##.   .#.#.#. \",\n    \"         .#.       .       .#.    .#.     ..     ...#.   .#.     .#.     ..#.    .#.    .##.     .#..    ..#.     .#.    ...#.  \",\n    \"        .#.#.             .##.     .#.          .###.   .#.      .#.     .#.    .###.    .#.     .#.    .####.   .##.    .##.   \",\n    \"         .#.               ..       .#.          ...     .        .       .      ...      .       .      ....     ..      ..    \",\n    \"          .                          .                                                                                          \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"                                                                                                                                \",\n    \"         ....       .      .      ...       .      .       .      ....    .               . .    ..  .   .....    .      .   .  \",\n    \"        .####.     .#.   ..#..   .###.   ...#.   ..#..   ..#..   .####.  .#...   ....    .#.#.  .##..#. .#####.  .#...  .#. .#. \",\n    \" ....    ...#.    .#.   .#####.   .#.   .#####. .#####. .#####.  .#..#.  .####. .####.  .#####.  .. .#.  ....#. .#####. .#. .#. \",\n    \".####.   .##.    .##.   .#...#.   .#.    ...#.   ..#.#.  ..#..   .#..#. .#..#.   ...#.   .#.#.  .##..#.    .#.   .#..#.  .#..#. \",\n    \" ....    .#.    .#.#.    .  .#.   .#.     .##.   .#..#. .#####. .#. .#.  . .#.     .#.    ..#.   .. .#.   .#.    .#.#.    . .#. \",\n    \"         .#.     ..#.     ..#.   ..#..   .#.#.   .#..#.  ..#..   . .#.     .#.   ...#.    .#.    ...#.   .#.#.   .#...   ...#.  \",\n    \"        .#.       .#.    .##.   .#####. .#..#.  .#..#.    .#.     .#.     .#.   .####.   .#.    .###.   .#. .#.   .###. .###.   \",\n    \"         .         .      ..     .....   .  .    .  .      .       .       .     ....     .      ...     .   .     ...   ...    \",\n    \"                                                                                                                                \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"                                                                                                                                \",\n    \"  ....     ..    . . .    ...     .        .      ...     ....     .        .            .       .....     .       .            \",\n    \" .####.  ..##.  .#.#.#.  .###.   .#.     ..#..   .###.   .####.  ..#..     .#.    . .   .#. ..  .#####.   .#.    ..#..   .....  \",\n    \" .#..#. .###.   .#.#.#.  .....   .#.    .#####.   ...     ...#. .#####.    .#.   .#.#.  .#..##.  ....#.  .#.#.  .#####. .#####. \",\n    \" .####.  ..#.   .#.#.#. .#####.  .##.    ..#..           .#.#.   ....#.    .#.   .#.#.  .###..      .#. .#..#.   ..#..   ....#. \",\n    \".#...#. .####.   . ..#.  ..#..   .#.#.    .#.             .#.    .###.    .#.   .#. .#. .#..       .#.   .  .#. .#.#.#.  .#.#.  \",\n    \" . .#.   ..#.    ...#.    .#.    .#..    ..#.    .....   .#.#.  .#.#.#.   .#.   .#. .#. .#....   ..#.       .#. .#.#.#.   .#.   \",\n    \"  .#.   .##.    .###.    .#.     .#.    .##.    .#####. .#. .#.  ..#..   .#.    .#. .#.  .####. .##.        .#.  ..#..     .#.  \",\n    \"   .     ..      ...      .       .      ..      .....   .   .     .      .      .   .    ....   ..          .     .        .   \",\n    \"                                                                                                                                \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"                                                                                                                                \",\n    \"  ..       .         .    ...     .               ....   ....     .  .     . .   .               .....       .   . .      .     \",\n    \" .##.     .#.       .#.  .###.   .#...    ...    .####. .####.   .#..#.   .#.#. .#.      .....  .#####.  ....#. .#.#.    .#.    \",\n    \"  ..#.   .#.      . .#.  ..#..   .#.##.  .###.    ...#.  .....   .#..#.   .#.#. .#.     .#####. .#...#. .###.#.  .#.#.  .#.#.   \",\n    \" .##.   .#. .    .#.#.  .#####.  .##.#.   ..#.    .###. .#####.  .#..#.   .#.#. .#. .   .#...#.  .  .#.  ....#.   . .    .#.    \",\n    \"  ..#.  .#..#.    .##.   ..#..  .#.#..     .#.     ..#.  ....#.   . .#.  .#.#.  .#..#.  .#...#.     .#.    .#.            .     \",\n    \" .##.   .####.   ..#.#.   .#..   . .#.   ...#.    ...#.   ..#.    ..#.   .#.#.  .#.#.   .#####.   ..#.   ...#.                  \",\n    \"  ..#.   ...#.  .##. .    .###.    .#.  .#####.  .####.  .##.    .##.   .#..##. .##.    .#...#.  .##.   .###.                   \",\n    \"    .       .    ..        ...      .    .....    ....    ..      ..     .  ..   ..      .   .    ..     ...                    \",\n    \"                                                                                                                                \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"    .     .                                                                                                                     \",\n    \"   .#.   .#.       .     .....                                                                                                  \",\n    \"  .##.   .##.     .#.   .#####.                                                                                                 \",\n    \" .###.   .###.   .###.   .###.                                                                                                  \",\n    \"  .##.   .##.   .#####.   .#.                                                                                                   \",\n    \"   .#.   .#.     .....     .                                                                                                    \",\n    \"    .     .                                                                                                                     \",\n    \"                                                                                                                                \",\n    //2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678/2345678\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \",\n    \"                                                                                                                                \"\n};\n\n#endif // __VAR8X10FONT_H\n"
        },
        {
          "name": "win32",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}