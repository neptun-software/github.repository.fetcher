{
  "metadata": {
    "timestamp": 1736565389698,
    "page": 230,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "laverdet/node-fibers",
      "stars": 3559,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0205078125,
          "content": "build/\nnode_modules/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.31640625,
          "content": "sudo: false\n\nlanguage: node_js\n\nnode_js:\n  - \"6\"\n  - \"8\"\n  - \"10\"\n  - \"12\"\n\ncache:\n  directories:\n    - node_modules\n\ninstall:\n  - npm install\n\nscript:\n  - npm run test\n\nenv:\n  - CXX=g++-4.8 CC=gcc-4.8\n\naddons:\n  apt:\n    sources:\n      - ubuntu-toolchain-r-test\n    packages:\n      - g++-4.8\n\nnotifications:\n  email: false\n"
        },
        {
          "name": "ISSUE_TEMPLATE.md",
          "type": "blob",
          "size": 1.79296875,
          "content": "<!--\nThank you for reporting an issue about fibers. Please make sure you've read the first section of the README because it contains valuable information about common issues.\n\nSome common issues:\n\n- If you are having problems with an odd-numbered version of nodejs please try again with an even-numbered version instead. The nodejs team doesn't do a good job of communicating this but odd-numbered versions are basically beta versions.\n\n- If you are having problems with a Meteor project please stop right now and go read their documentation. You most likely are trying to use a version of nodejs that is not supported by Meteor.\n\n- Find the npm version badge on the front page of this project's github. If the version of fibers you're trying to install is not the latest version then please stop and update your dependencies to require the latest version. This often happens when attempting to install another npm module which depends on fibers.\n\n- If your error says \"Can't wait without a fiber\" then please go read the documentation again. You need a top-level Fiber or Future before calling `wait`.\n\n- If you're using Webpack then don't. Fibers can't be used with Webpack.\n\n\nIf none of these apply then feel free to open a ticket with a bug report or question. PLEASE INCLUDE ENOUGH INFORMATION IN YOUR REPORT. You are a software engineer! Ask yourself: \"if someone was reporting an issue about something that I wrote what information would be helpful?\". That is, please include your nodejs version, your operating system version, your compiler version, what you've tried so far to fix the issue.. things like that. If some specific code is triggering the issue then please include a full example of the code that can be run on its own. Please no \"snippets\", if I can't run the code without modifications then I can't help you.\n-->\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.029296875,
          "content": "Copyright 2011 Marcel Laverdet\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.689453125,
          "content": "**NOTE OF OBSOLESCENCE** -- The author of this project recommends you avoid its use if possible. The\noriginal version of this module targeted nodejs v0.1.x in early 2011 when JavaScript on the server\nlooked a lot different. Since then\n[async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function),\n[Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise),\nand\n[Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator)\nwere standardized and the ecosystem as a whole has moved in that direction.\n\nI'll continue to support newer versions of nodejs as long as possible but v8 and nodejs are\nextraordinarily complex and dynamic platforms. It is inevitable that one day this library will\nabruptly stop working and no one will be able to do anything about it.\n\nI'd like to say thank you to all the users of fibers, your support over the years has meant a lot to\nme.\n\n**Update** *[April 13th, 2021]* -- Fibers is not compatible with nodejs v16.0.0 or later. Unfortunately, v8\ncommit [dacc2fee0f](https://github.com/v8/v8/commit/dacc2fee0f815823782a7e432c79c2a7767a4765) is a breaking\nchange and workarounds are non-trivial.\n\n\nfibers(1) -- Fiber support for v8 and Node\n==========================================\n[![npm version](https://badgen.now.sh/npm/v/fibers)](https://www.npmjs.com/package/fibers)\n[![isc license](https://badgen.now.sh/npm/license/fibers)](https://github.com/laverdet/node-fibers/blob/master/LICENSE)\n[![travis build](https://badgen.now.sh/travis/laverdet/node-fibers)](https://travis-ci.org/laverdet/node-fibers)\n[![npm downloads](https://badgen.now.sh/npm/dm/fibers)](https://www.npmjs.com/package/fibers)\n\nFibers, sometimes called [coroutines](https://en.wikipedia.org/wiki/Coroutine), are a powerful tool which expose an API to jump between multiple call stacks from within a single thread. This can be useful to make code written for a synchronous library play nicely in an asynchronous environment.\n\nINSTALLING\n----------\n[![NPM](https://nodei.co/npm/fibers.png)](https://www.npmjs.com/package/fibers)\n\n### via npm\n* `npm install fibers`\n* You're done! (see \"supported platforms\" below if you run into errors)\n\n### from source\n* `git clone git://github.com/laverdet/node-fibers.git`\n* `cd node-fibers`\n* `npm install`\n\nNote: node-fibers uses [node-gyp](https://github.com/TooTallNate/node-gyp) for\nbuilding. To manually invoke the build process, you can use `node-gyp rebuild`.\nThis will put the compiled extension in `build/Release/fibers.node`. However,\nwhen you do `require('fibers')`, it will expect the module to be in, for\nexample, `bin/linux-x64-v8-3.11/fibers.node`. You can manually put the module\nhere every time you build, or you can use the included build script. Either\n`npm install` or `node build -f` will do this for you. If you are going to be\nhacking on node-fibers, it may be worthwhile to first do `node-gyp configure`\nand then for subsequent rebuilds you can just do `node-gyp build` which will\nbe faster than a full `npm install` or `node-gyp rebuild`.\n\n### meteor users please read this\nIf you're trying to get meteor running and you ended up at this page you're\nprobably doing something wrong. Please uninstall all versions of NodeJS and\nMeteor, then start over. See\n[meteor#5124](https://github.com/meteor/meteor/issues/5124) for more\ninformation.\n\n### supported platforms\nIf you are running 64-bit nodejs version 12.x or 14.x on Linux, OS X, or Windows (7 or later) then\nyou should be able to install fibers from npm just fine. If you are running nodejs v10.x then you\nwill need to use `npm install fibers@4`. Older versions of nodejs will require older and older\nversion of fibers.\n\n(special thanks to [Jeroen Janssen](https://github.com/japj) for his work on fibers in Windows)\n\nIf you do end up needing to compile fibers first make sure you have node-gyp installed as a global\ndependency (`npm install -g node-gyp`), and that you have setup your build environment by following\nthe instructions at [node-gyp](https://github.com/TooTallNate/node-gyp). Ubuntu-flavored Linux users\nmay need to run `sudo apt-get install g++` as well.\n\n\nEXAMPLES\n--------\n\nThe examples below describe basic use of `Fiber`, but note that it is **not\nrecommended** to use `Fiber` without an abstraction in between your code and\nfibers. See \"FUTURES\" below for additional information.\n\n### Sleep\nThis is a quick example of how you can write sleep() with fibers. Note that\nwhile the sleep() call is blocking inside the fiber, node is able to handle\nother events.\n\n\t$ cat sleep.js\n\n```javascript\nvar Fiber = require('fibers');\n\nfunction sleep(ms) {\n\tvar fiber = Fiber.current;\n\tsetTimeout(function() {\n\t\tfiber.run();\n\t}, ms);\n\tFiber.yield();\n}\n\nFiber(function() {\n\tconsole.log('wait... ' + new Date);\n\tsleep(1000);\n\tconsole.log('ok... ' + new Date);\n}).run();\nconsole.log('back in main');\n```\n\n\t$ node sleep.js\n\twait... Fri Jan 21 2011 22:42:04 GMT+0900 (JST)\n\tback in main\n\tok... Fri Jan 21 2011 22:42:05 GMT+0900 (JST)\n\n\n### Incremental Generator\nYielding execution will resume back in the fiber right where you left off. You\ncan also pass values back and forth through yield() and run(). Again, the node\nevent loop is never blocked while this script is running.\n\n\t$ cat generator.js\n\n```javascript\nvar Fiber = require('fibers');\n\nvar inc = Fiber(function(start) {\n\tvar total = start;\n\twhile (true) {\n\t\ttotal += Fiber.yield(total);\n\t}\n});\n\nfor (var ii = inc.run(1); ii <= 10; ii = inc.run(1)) {\n\tconsole.log(ii);\n}\n```\n\n\t$ node generator.js\n\t1\n\t2\n\t3\n\t4\n\t5\n\t6\n\t7\n\t8\n\t9\n\t10\n\n\n### Fibonacci Generator\nExpanding on the incremental generator above, we can create a generator which\nreturns a new Fibonacci number with each invocation. You can compare this with\nthe [ECMAScript Harmony\nGenerator](http://wiki.ecmascript.org/doku.php?id=harmony:generators) Fibonacci\nexample.\n\n\t$ cat fibonacci.js\n\n```javascript\nvar Fiber = require('fibers');\n\n// Generator function. Returns a function which returns incrementing\n// Fibonacci numbers with each call.\nfunction Fibonacci() {\n\t// Create a new fiber which yields sequential Fibonacci numbers\n\tvar fiber = Fiber(function() {\n\t\tFiber.yield(0); // F(0) -> 0\n\t\tvar prev = 0, curr = 1;\n\t\twhile (true) {\n\t\t\tFiber.yield(curr);\n\t\t\tvar tmp = prev + curr;\n\t\t\tprev = curr;\n\t\t\tcurr = tmp;\n\t\t}\n\t});\n\t// Return a bound handle to `run` on this fiber\n\treturn fiber.run.bind(fiber);\n}\n\n// Initialize a new Fibonacci sequence and iterate up to 1597\nvar seq = Fibonacci();\nfor (var ii = seq(); ii <= 1597; ii = seq()) {\n\tconsole.log(ii);\n}\n```\n\n\t$ node fibonacci.js\n\t0\n\t1\n\t1\n\t2\n\t3\n\t5\n\t8\n\t13\n\t21\n\t34\n\t55\n\t89\n\t144\n\t233\n\t377\n\t610\n\t987\n\t1597\n\n\n### Basic Exceptions\nFibers are exception-safe; exceptions will continue travelling through fiber\nboundaries:\n\n\t$ cat error.js\n\n```javascript\nvar Fiber = require('fibers');\n\nvar fn = Fiber(function() {\n\tconsole.log('async work here...');\n\tFiber.yield();\n\tconsole.log('still working...');\n\tFiber.yield();\n\tconsole.log('just a little bit more...');\n\tFiber.yield();\n\tthrow new Error('oh crap!');\n});\n\ntry {\n\twhile (true) {\n\t\tfn.run();\n\t}\n} catch(e) {\n\tconsole.log('safely caught that error!');\n\tconsole.log(e.stack);\n}\nconsole.log('done!');\n```\n\n\t$ node error.js\n\tasync work here...\n\tstill working...\n\tjust a little bit more...\n\tsafely caught that error!\n\tError: oh crap!\n\t\t\tat error.js:11:9\n\tdone!\n\n\nFUTURES\n-------\n\nUsing the `Fiber` class without an abstraction in between your code and the raw\nAPI is **not recommended**. `Fiber` is meant to implement the smallest amount of\nfunctionality in order make possible many different programming patterns. This\nmakes the `Fiber` class relatively lousy to work with directly, but extremely\npowerful when coupled with a decent abstraction. There is no right answer for\nwhich abstraction is right for you and your project. Included with `node-fibers`\nis an implementation of \"futures\" which is fiber-aware. Usage of this library\nis documented below. There are several other externally-maintained options\nwhich can be found on the [wiki](https://github.com/laverdet/node-fibers/wiki).\nYou **should** feel encouraged to be creative with fibers and build a solution\nwhich works well with your project. For instance, `Future` is not a good\nabstraction to use if you want to build a generator function (see Fibonacci\nexample above).\n\nUsing `Future` to wrap existing node functions. At no point is the node event\nloop blocked:\n\n\t$ cat ls.js\n\n```javascript\nvar Future = require('fibers/future');\nvar fs = Future.wrap(require('fs'));\n\nFuture.task(function() {\n\t// Get a list of files in the directory\n\tvar fileNames = fs.readdirFuture('.').wait();\n\tconsole.log('Found '+ fileNames.length+ ' files');\n\n\t// Stat each file\n\tvar stats = [];\n\tfor (var ii = 0; ii < fileNames.length; ++ii) {\n\t\tstats.push(fs.statFuture(fileNames[ii]));\n\t}\n\tstats.map(function(f) {\n\t\tf.wait()\n\t});\n\n\t// Print file size\n\tfor (var ii = 0; ii < fileNames.length; ++ii) {\n\t\tconsole.log(fileNames[ii]+ ': '+ stats[ii].get().size);\n\t}\n}).detach();\n```\n\n\t$ node ls.js \n\tFound 11 files\n\tbin: 4096\n\tfibers.js: 1708\n\t.gitignore: 37\n\tREADME.md: 8664\n\tfuture.js: 5833\n\t.git: 4096\n\tLICENSE: 1054\n\tsrc: 4096\n\tls.js: 860\n\tMakefile: 436\n\tpackage.json: 684\n\n\nThe future API is designed to make it easy to move between classic\ncallback-style code and fiber-aware waiting code:\n\n\t$ cat sleep.js\n\n```javascript\nvar Future = require('fibers/future'), wait = Future.wait;\n\n// This function returns a future which resolves after a timeout. This\n// demonstrates manually resolving futures.\nfunction sleep(ms) {\n\tvar future = new Future;\n\tsetTimeout(function() {\n\t\tfuture.return();\n\t}, ms);\n\treturn future;\n}\n\n// You can create functions which automatically run in their own fiber and\n// return futures that resolve when the fiber returns (this probably sounds\n// confusing.. just play with it to understand).\nvar calcTimerDelta = function(ms) {\n\tvar start = new Date;\n\tsleep(ms).wait();\n\treturn new Date - start;\n}.future(); // <-- important!\n\n// And futures also include node-friendly callbacks if you don't want to use\n// wait()\ncalcTimerDelta(2000).resolve(function(err, val) {\n\tconsole.log('Set timer for 2000ms, waited '+ val+ 'ms');\n});\n```\n\n\t$ node sleep.js\n\tSet timer for 2000ms, waited 2009ms\n\n\nAPI DOCUMENTATION\n-----------------\nFiber's definition looks something like this:\n\n```javascript\n/**\n * Instantiate a new Fiber. You may invoke this either as a function or as\n * a constructor; the behavior is the same.\n *\n * When run() is called on this fiber for the first time, `fn` will be\n * invoked as the first frame on a new stack. Execution will continue on\n * this new stack until `fn` returns, or Fiber.yield() is called.\n *\n * After the function returns the fiber is reset to original state and\n * may be restarted with another call to run().\n */\nfunction Fiber(fn) {\n\t[native code]\n}\n\n/**\n * `Fiber.current` will contain the currently-running Fiber. It will be\n * `undefined` if there is no fiber (i.e. the main stack of execution).\n *\n * See \"Garbage Collection\" for more information on responsible use of\n * `Fiber.current`.\n */\nFiber.current = undefined;\n\n/**\n * `Fiber.yield()` will halt execution of the current fiber and return control\n * back to original caller of run(). If an argument is supplied to yield(),\n * run() will return that value.\n *\n * When run() is called again, yield() will return.\n *\n * Note that this function is a global to allow for correct garbage\n * collection. This results in no loss of functionality because it is only\n * valid to yield from the currently running fiber anyway.\n *\n * Note also that `yield` is a reserved word in Javascript. This is normally\n * not an issue, however some code linters may complain. Rest assured that it\n * will run fine now and in future versions of Javascript.\n */\nFiber.yield = function(param) {\n\t[native code]\n}\n\n/**\n * run() will start execution of this Fiber, or if it is currently yielding,\n * it will resume execution. If an argument is supplied, this argument will\n * be passed to the fiber, either as the first parameter to the main\n * function [if the fiber has not been started] or as the return value of\n * yield() [if the fiber is currently yielding].\n *\n * This function will return either the parameter passed to yield(), or the\n * returned value from the fiber's main function.\n */\nFiber.prototype.run = function(param) {\n\t[native code]\n}\n\n/**\n * reset() will terminate a running Fiber and restore it to its original\n * state, as if it had returned execution.\n *\n * This is accomplished by causing yield() to throw an exception, and any\n * futher calls to yield() will also throw an exception. This continues\n * until the fiber has completely unwound and returns.\n *\n * If the fiber returns a value it will be returned by reset().\n *\n * If the fiber is not running, reset() will have no effect.\n */\nFiber.prototype.reset = function() {\n\t[native code]\n}\n\n/**\n * throwInto() will cause a currently yielding fiber's yield() call to\n * throw instead of return gracefully. This can be useful for notifying a\n * fiber that you are no longer interested in its task, and that it should\n * give up.\n *\n * Note that if the fiber does not handle the exception it will continue to\n * bubble up and throwInto() will throw the exception right back at you.\n */\nFiber.prototype.throwInto = function(exception) {\n\t[native code]\n}\n```\n\n\nFuture's definition looks something like this:\n\n```javascript\n/**\n * Returns a future-function which, when run, starts running the target\n * function and returns a future for the result.\n * \n * Example usage: \n * var funcy = function(arg) {\n *   return arg+1;\n * }.future();\n * \n * funcy(1).wait(); // returns 2\n */\nFunction.prototype.future = function() { ... }\n\n/**\n * Future object, instantiated with the new operator.\n */\nfunction Future() {}\n\n/**\n * Wrap a node-style async function to return a future in place of using a callback.\n * \n * fn - the function or object to wrap\n * array - indicates that this callback will return more than 1 argument after `err`. For example,\n *         `child_process.exec()` returns [err, stdout, stderr]\n * suffix - appends a string to every method that was overridden, if you passed an object\n * \n * Example usage: Future.wrap(asyncFunction)(arg1).wait()\n */\nFuture.wrap = function(fn, multi, suffix) { ... }\n\n/**\n * Invoke a function that will be run in its own fiber context and return a future to its return\n * value.\n *\n * Example:\n * Future.task(function() {\n *   // You can safely `wait` on stuff here\n * }).detach();\n */\nFuture.task = function(fn) { ... }\n\n/**\n * Wait on a series of futures and then return. If the futures throw an exception this function\n * /won't/ throw it back. You can get the value of the future by calling get() on it directly. If\n * you want to wait on a single future you're better off calling future.wait() on the instance.\n * \n * Example usage: Future.wait(aFuture, anotherFuture)\n */\nFuture.wait = function(/* ... */) { ... }\n\n/**\n * Return the value of this future. If the future hasn't resolved yet this will throw an error.\n */\nFuture.prototype.get = function() { ... }\n\n/**\n * Mark this future as returned. All pending callbacks will be invoked immediately.\n * \n * value - the value to return when get() or wait() is called.\n * \n * Example usage: aFuture.return(value)\n */\nFuture.prototype.return = function(value) { ... }\n\n/**\n * Throw from this future as returned. All pending callbacks will be invoked immediately.\n * Note that execution will continue normally after running this method, \n * so make sure you exit appropriately after running throw()\n * \n * error - the error to throw when get() or wait() is called.\n * \n * Example usage: aFuture.throw(new Error(\"Something borked\"))\n */\nFuture.prototype.throw = function(error) { ... }\n\n/**\n * \"detach\" this future. Basically this is useful if you want to run a task in a future, you\n * aren't interested in its return value, but if it throws you don't want the exception to be\n * lost. If this fiber throws, an exception will be thrown to the event loop and node will\n * probably fall down.\n */\nFuture.prototype.detach = function() { ... }\n\n/**\n * Returns whether or not this future has resolved yet.\n */\nFuture.prototype.isResolved = function() { ... }\n\n/**\n * Returns a node-style function which will mark this future as resolved when called.\n * \n * Example usage: \n *   var errback = aFuture.resolver();\n *   asyncFunction(arg1, arg2, etc, errback)\n *   var result = aFuture.wait();\n */\nFuture.prototype.resolver = function() { ... }\n\n/**\n * Waits for this future to resolve and then invokes a callback.\n *\n * If only one argument is passed it is a standard function(err, val){} errback.\n *\n * If two arguments are passed, the first argument is a future which will be thrown to in the case\n * of error, and the second is a function(val){} callback.\n */\nFuture.prototype.resolve = function(/* errback or future, callback */) { ... }\n\n/**\n * Propogate results to another future.\n * \n * Example usage: future1.proxy(future2) // future2 gets automatically resolved with however future1 resolves\n */\nFuture.prototype.proxy = function(future) { ... }\n\n/**\n * Differs from its functional counterpart in that it actually resolves the future. Thus if the\n * future threw, future.wait() will throw.\n */\nFuture.prototype.wait = function() { ... }\n\n/**\n * Support for converting a Future to and from ES6 Promises.\n */\nFuture.fromPromise = function(promise) { ... }\nFuture.prototype.promise = function() { ... }\n```\n\nGARBAGE COLLECTION\n------------------\n\nIf you intend to build generators, iterators, or \"lazy lists\", you should be\naware that all fibers must eventually unwind. This is implemented by causing\nyield() to throw unconditionally when the library is trying to unwind your\nfiber-- either because reset() was called, or all handles to the fiber were lost\nand v8 wants to delete it.\n\nSomething like this will, at some point, cause an infinite loop in your\napplication:\n\n```javascript\nvar fiber = Fiber(function() {\n\twhile (true) {\n\t\ttry {\n\t\t\tFiber.yield();\n\t\t} catch(e) {}\n\t}\n});\nfiber.run();\n```\n\nIf you either call reset() on this fiber, or the v8 garbage collector decides it\nis no longer in use, the fiber library will attempt to unwind the fiber by\ncausing all calls to yield() to throw. However, if you catch these exceptions\nand continue anyway, an infinite loop will occur.\n\nThere are other garbage collection issues that occur with misuse of fiber\nhandles. If you grab a handle to a fiber from within itself, you should make\nsure that the fiber eventually unwinds. This application will leak memory:\n\n```javascript\nvar fiber = Fiber(function() {\n\tvar that = Fiber.current;\n\tFiber.yield();\n}\nfiber.run();\nfiber = undefined;\n```\n\nThere is no way to get back into the fiber that was started, however it's\nimpossible for v8's garbage collector to detect this. With a handle to the fiber\nstill outstanding, v8 will never garbage collect it and the stack will remain in\nmemory until the application exits.\n\nThus, you should take care when grabbing references to `Fiber.current`.\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "binding.gyp",
          "type": "blob",
          "size": 1.7841796875,
          "content": "{\n\t'target_defaults': {\n\t\t'default_configuration': 'Release',\n\t\t'configurations': {\n\t\t\t'Release': {\n\t\t\t\t'cflags': [ '-O3' ],\n\t\t\t\t'xcode_settings': {\n\t\t\t\t\t'GCC_OPTIMIZATION_LEVEL': '3',\n\t\t\t\t\t'GCC_GENERATE_DEBUGGING_SYMBOLS': 'NO',\n\t\t\t\t},\n\t\t\t\t'msvs_settings': {\n\t\t\t\t\t'VCCLCompilerTool': {\n\t\t\t\t\t\t'Optimization': 3,\n\t\t\t\t\t\t'FavorSizeOrSpeed': 1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t},\n\t'targets': [\n\t\t{\n\t\t\t'target_name': 'fibers',\n\t\t\t'sources': [\n\t\t\t\t'src/fibers.cc',\n\t\t\t\t'src/coroutine.cc',\n\t\t\t\t'src/libcoro/coro.c',\n\t\t\t\t# Rebuild on header changes\n\t\t\t\t'src/coroutine.h',\n\t\t\t\t'src/libcoro/coro.h',\n\t\t\t],\n\t\t\t'cflags!': ['-ansi'],\n\t\t\t'conditions': [\n\t\t\t\t['OS == \"win\"',\n\t\t\t\t\t{'defines': ['CORO_FIBER', 'WINDOWS']},\n\t\t\t\t# else\n\t\t\t\t\t{\n\t\t\t\t\t\t'defines': ['USE_CORO', 'CORO_GUARDPAGES=1'],\n\t\t\t\t\t\t'ldflags': ['-pthread'],\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t['OS == \"linux\"',\n\t\t\t\t\t{\n\t\t\t\t\t\t'cflags_c': [ '-std=gnu11' ],\n\t\t\t\t\t\t'variables': {\n\t\t\t\t\t\t\t'USE_MUSL': '<!(ldd --version 2>&1 | head -n1 | grep \"musl\" | wc -l)',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'conditions': [\n\t\t\t\t\t\t\t['<(USE_MUSL) == 1',\n\t\t\t\t\t\t\t\t{'defines': ['CORO_ASM', '__MUSL__']},\n\t\t\t\t\t\t\t\t{'defines': ['CORO_UCONTEXT']}\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t['OS == \"solaris\" or OS == \"sunos\" or OS == \"freebsd\" or OS == \"aix\"', {'defines': ['CORO_UCONTEXT']}],\n\t\t\t\t['OS == \"mac\"', {'defines': ['CORO_ASM']}],\n\t\t\t\t['OS == \"openbsd\"', {'defines': ['CORO_ASM']}],\n\t\t\t\t['target_arch == \"arm\"',\n\t\t\t\t\t{\n\t\t\t\t\t\t# There's been problems getting real fibers working on arm\n\t\t\t\t\t\t'defines': ['CORO_PTHREAD'],\n\t\t\t\t\t\t'defines!': ['CORO_UCONTEXT', 'CORO_SJLJ', 'CORO_ASM'],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t['target_arch == \"arm64\"',\n\t\t\t\t\t{\n\t\t\t\t\t\t# There's been problems getting real fibers working on arm\n\t\t\t\t\t\t'defines': ['CORO_UCONTEXT', '_XOPEN_SOURCE'],\n\t\t\t\t\t\t'defines!': ['CORO_PTHREAD', 'CORO_SJLJ', 'CORO_ASM'],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t],\n\t\t},\n\t],\n}\n"
        },
        {
          "name": "build.js",
          "type": "blob",
          "size": 3.3251953125,
          "content": "#!/usr/bin/env node\nvar cp = require('child_process'),\n\tfs = require('fs'),\n\tpath = require('path'),\n\tdetectLibc = require('detect-libc');\n\n// Parse args\nvar force = false, debug = false;\nvar\n\tarch = process.arch,\n\tplatform = process.platform,\n\tmodules = process.versions.modules;\nvar args = process.argv.slice(2).filter(function(arg) {\n\tif (arg === '-f') {\n\t\tforce = true;\n\t\treturn false;\n\t} else if (arg.substring(0, 13) === '--target_arch') {\n\t\tarch = arg.substring(14);\n\t} else if (arg.substring(0, 10) === '--modules=') {\n\t\tmodules = arg.substring(10);\n\t\treturn false;\n\t} else if (arg === '--debug') {\n\t\tdebug = true;\n\t}\n\treturn true;\n});\nif (!debug) {\n\targs.push('--release');\n}\nif (!{ia32: true, x64: true, arm: true, arm64: true, ppc: true, ppc64: true, s390: true, s390x: true}.hasOwnProperty(arch)) {\n\tconsole.error('Unsupported (?) architecture: `'+ arch+ '`');\n\tprocess.exit(1);\n}\n\n// Test for pre-built library\nvar modPath = platform+ '-'+ arch+ '-'+ process.versions.modules+ ((platform === 'linux') ? '-'+ detectLibc.family : '');\nif (!force) {\n\ttry {\n\t\tfs.statSync(path.join(__dirname, 'bin', modPath, 'fibers.node'));\n\t\tconsole.log('`'+ modPath+ '` exists; testing');\n\t\tcp.execFile(process.execPath, ['quick-test'], function(err, stdout, stderr) {\n\t\t\tif (err || stdout !== 'pass' || stderr) {\n\t\t\t\tconsole.log('Problem with the binary; manual build incoming');\n\t\t\t\tbuild();\n\t\t\t} else {\n\t\t\t\tconsole.log('Binary is fine; exiting');\n\t\t\t}\n\t\t});\n\t} catch (ex) {\n\t\t// Stat failed\n\t\tbuild();\n\t}\n} else {\n\tbuild();\n}\n\n// Build it\nfunction build() {\n\tif (process.versions.electron) {\n\t\targs.push('--target='+ process.versions.electron,  '--dist-url=https://atom.io/download/atom-shell');\n\t}\n\tcp.spawn(\n\t\tprocess.platform === 'win32' ? 'node-gyp.cmd' : 'node-gyp',\n\t\t['rebuild'].concat(args),\n\t\t{stdio: [process.stdin, process.stdout, process.stderr]})\n\t.on('exit', function(err) {\n\t\tif (err) {\n\t\t\tconsole.error(\n\t\t\t\t'node-gyp exited with code: '+ err+ '\\n'+\n\t\t\t\t'Please make sure you are using a supported platform and node version. If you\\n'+\n\t\t\t\t'would like to compile fibers on this machine please make sure you have setup your\\n'+\n\t\t\t\t'build environment--\\n'+\n\t\t\t\t'Windows + OS X instructions here: https://github.com/nodejs/node-gyp\\n'+\n\t\t\t\t'Ubuntu users please run: `sudo apt-get install g++ build-essential`\\n'+\n\t\t\t\t'RHEL users please run: `yum install gcc-c++` and `yum groupinstall \\'Development Tools\\'` \\n'+\n\t\t\t\t'Alpine users please run: `sudo apk add python make g++`'\n\t\t\t);\n\t\t\treturn process.exit(err);\n\t\t}\n\t\tafterBuild();\n\t})\n\t.on('error', function(err) {\n\t\tconsole.error(\n\t\t\t'node-gyp not found! Please ensure node-gyp is in your PATH--\\n'+\n\t\t\t'Try running: `sudo npm install -g node-gyp`'\n\t\t);\n\t\tconsole.log(err.message);\n\t\tprocess.exit(1);\n\t});\n}\n\n// Move it to expected location\nfunction afterBuild() {\n\tvar targetPath = path.join(__dirname, 'build', debug ? 'Debug' : 'Release', 'fibers.node');\n\tvar installPath = path.join(__dirname, 'bin', modPath, 'fibers.node');\n\n\ttry {\n\t\tfs.mkdirSync(path.join(__dirname, 'bin', modPath));\n\t} catch (ex) {}\n\n\ttry {\n\t\tfs.statSync(targetPath);\n\t} catch (ex) {\n\t\tconsole.error('Build succeeded but target not found');\n\t\tprocess.exit(1);\n\t}\n\tfs.renameSync(targetPath, installPath);\n\tconsole.log('Installed in `'+ installPath+ '`');\n\tif (process.versions.electron) {\n\t\tprocess.nextTick(function() {\n\t\t\trequire('electron').app.quit();\n\t\t});\n\t}\n}\n"
        },
        {
          "name": "fibers.js",
          "type": "blob",
          "size": 3.69140625,
          "content": "if (process.fiberLib) {\n\tmodule.exports = process.fiberLib;\n} else {\n\tvar fs = require('fs'), path = require('path'), detectLibc = require('detect-libc');\n\n\t// Seed random numbers [gh-82]\n\tMath.random();\n\n\t// Look for binary for this platform\n\tvar modPath = path.join(__dirname, 'bin', process.platform+ '-'+ process.arch+ '-'+ process.versions.modules+\n\t\t((process.platform === 'linux') ? '-'+ detectLibc.family : ''), 'fibers');\n\ttry {\n\t\t// Pull in fibers implementation\n\t\tprocess.fiberLib = module.exports = require(modPath).Fiber;\n\t} catch (ex) {\n\t\t// No binary!\n\t\tconsole.error(\n\t\t\t'## There is an issue with `node-fibers` ##\\n'+\n\t\t\t'`'+ modPath+ '.node` is missing.\\n\\n'+\n\t\t\t'Try running this to fix the issue: '+ process.execPath+ ' '+ __dirname.replace(' ', '\\\\ ')+ '/build'\n\t\t);\n\t\tconsole.error(ex.stack || ex.message || ex);\n\t\tthrow new Error('Missing binary. See message above.');\n\t}\n\n\tsetupAsyncHacks(module.exports);\n}\n\nfunction setupAsyncHacks(Fiber) {\n\t// Older (or newer?) versions of node may not support this API\n\ttry {\n\t\tvar aw = process.binding('async_wrap');\n\t\tvar getAsyncIdStackSize;\n\n\t\tif (aw.asyncIdStackSize instanceof Function) {\n\t\t\tgetAsyncIdStackSize = aw.asyncIdStackSize;\n\t\t} else if (aw.constants.kStackLength !== undefined) {\n\t\t\tgetAsyncIdStackSize = function(kStackLength) {\n\t\t\t\treturn function() {\n\t\t\t\t\treturn aw.async_hook_fields[kStackLength];\n\t\t\t\t};\n\t\t\t}(aw.constants.kStackLength);\n\t\t} else {\n\t\t\tthrow new Error('Couldn\\'t figure out how to get async stack size');\n\t\t}\n\n\t\tvar popAsyncContext = aw.popAsyncContext || aw.popAsyncIds;\n\t\tvar pushAsyncContext = aw.pushAsyncContext || aw.pushAsyncIds;\n\t\tif (!popAsyncContext || !pushAsyncContext) {\n\t\t\tthrow new Error('Push/pop do not exist');\n\t\t}\n\n\t\tvar kExecutionAsyncId;\n\t\tif (aw.constants.kExecutionAsyncId === undefined) {\n\t\t\tkExecutionAsyncId = aw.constants.kCurrentAsyncId;\n\t\t} else {\n\t\t\tkExecutionAsyncId = aw.constants.kExecutionAsyncId;\n\t\t}\n\t\tvar kTriggerAsyncId;\n\t\tif (aw.constants.kTriggerAsyncId === undefined) {\n\t\t\tkTriggerAsyncId = aw.constants.kCurrentTriggerId;\n\t\t} else {\n\t\t\tkTriggerAsyncId = aw.constants.kTriggerAsyncId;\n\t\t}\n\n\t\tvar asyncIds = aw.async_id_fields || aw.async_uid_fields;\n\n\t\tfunction getAndClearStack() {\n\t\t\tvar ii = getAsyncIdStackSize();\n\t\t\tvar stack = new Array(ii);\n\t\t\tfor (; ii > 0; --ii) {\n\t\t\t\tvar asyncId = asyncIds[kExecutionAsyncId];\n\t\t\t\tstack[ii - 1] = {\n\t\t\t\t\tasyncId: asyncId,\n\t\t\t\t\ttriggerId: asyncIds[kTriggerAsyncId],\n\t\t\t\t};\n\t\t\t\tpopAsyncContext(asyncId);\n\t\t\t}\n\t\t\treturn stack;\n\t\t}\n\n\t\tfunction restoreStack(stack) {\n\t\t\tfor (var ii = 0; ii < stack.length; ++ii) {\n\t\t\t\tpushAsyncContext(stack[ii].asyncId, stack[ii].triggerId);\n\t\t\t}\n\t\t}\n\n\t\tfunction logUsingFibers(fibersMethod) {\n\t\t\tconst logUseFibersLevel = +(process.env.ENABLE_LOG_USE_FIBERS || 0);\n\n\t\t\tif (!logUseFibersLevel) return;\n\n\t\t\tif (logUseFibersLevel === 1) {\n\t\t\t\tconsole.warn(`[FIBERS_LOG] Using ${fibersMethod}.`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { LOG_USE_FIBERS_INCLUDE_IN_PATH } = process.env;\n\t\t\tconst stackFromError = new Error(`[FIBERS_LOG] Using ${fibersMethod}.`).stack;\n\n\t\t\tif (\n\t\t\t\t!LOG_USE_FIBERS_INCLUDE_IN_PATH ||\n\t\t\t\tstackFromError.includes(LOG_USE_FIBERS_INCLUDE_IN_PATH)\n\t\t\t) {\n\t\t\t\tconsole.warn(stackFromError);\n\t\t\t}\n\t\t}\n\n\t\tfunction wrapFunction(fn, fibersMethod) {\n\t\t\treturn function () {\n\t\t\t\tlogUsingFibers(fibersMethod);\n\t\t\t\tvar stack = getAndClearStack();\n\t\t\t\ttry {\n\t\t\t\t\treturn fn.apply(this, arguments);\n\t\t\t\t} finally {\n\t\t\t\t\trestoreStack(stack);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Monkey patch methods which may long jump\n\t\tFiber.yield = wrapFunction(Fiber.yield, \"Fiber.yield\");\n\t\tFiber.prototype.run = wrapFunction(Fiber.prototype.run, \"Fiber.run\");\n\t\tFiber.prototype.throwInto = wrapFunction(\n\t\t\tFiber.prototype.throwInto,\n\t\t\t\"Fiber.throwInto\"\n\t\t);\n\n\t} catch (err) {\n\t\treturn;\n\t}\n}\n"
        },
        {
          "name": "future.js",
          "type": "blob",
          "size": 11.4267578125,
          "content": "\"use strict\";\nvar Fiber = require('./fibers');\nvar util = require('util');\nmodule.exports = Future;\nFunction.prototype.future = function(detach) {\n\tvar fn = this;\n\tvar ret = function() {\n\t\tvar future = new FiberFuture(fn, this, arguments);\n\t\tif (detach) {\n\t\t\tfuture.detach();\n\t\t}\n\t\treturn future;\n\t};\n\tret.toString = function() {\n\t\treturn '<<Future '+ fn+ '.future()>>';\n\t};\n\treturn ret;\n};\n\nfunction Future() {}\n\n/**\n * Run a function(s) in a future context, and return a future to their return value. This is useful\n * for instances where you want a closure to be able to `.wait()`. This also lets you wait for\n * mulitple parallel opertions to run.\n */\nFuture.task = function(fn) {\n\tif (arguments.length === 1) {\n\t\treturn fn.future()();\n\t} else {\n\t\tvar future = new Future, pending = arguments.length, error, values = new Array(arguments.length);\n\t\tfor (var ii = 0; ii < arguments.length; ++ii) {\n\t\t\targuments[ii].future()().resolve(function(ii, err, val) {\n\t\t\t\tif (err) {\n\t\t\t\t\terror = err;\n\t\t\t\t}\n\t\t\t\tvalues[ii] = val;\n\t\t\t\tif (--pending === 0) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tfuture.throw(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfuture.return(values);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.bind(null, ii));\n\t\t}\n\t\treturn future;\n\t}\n};\n\n/**\n * Wrap node-style async functions to instead return futures. This assumes that the last parameter\n * of the function is a callback.\n *\n * If a single function is passed a future-returning function is created. If an object is passed a\n * new object is returned with all functions wrapped.\n *\n * The value that is returned from the invocation of the underlying function is assigned to the\n * property `_` on the future. This is useful for functions like `execFile` which take a callback,\n * but also return meaningful information.\n *\n * `multi` indicates that this callback will return more than 1 argument after `err`. For example,\n * `child_process.exec()`\n *\n * `suffix` will append a string to every method that was overridden, if you pass an object to\n * `Future.wrap()`. Default is 'Future'.\n *\n * var readFileFuture = Future.wrap(require('fs').readFile);\n * var fs = Future.wrap(require('fs'));\n * fs.readFileFuture('example.txt').wait();\n */\nFuture.wrap = function(fnOrObject, multi, suffix, stop) {\n\tif (typeof fnOrObject === 'object') {\n\t\tvar wrapped = Object.create(fnOrObject);\n\t\tfor (var ii in fnOrObject) {\n\t\t\tif (wrapped[ii] instanceof Function) {\n\t\t\t\twrapped[suffix === undefined ? ii+ 'Future' : ii+ suffix] = Future.wrap(wrapped[ii], multi, suffix, stop);\n\t\t\t}\n\t\t}\n\t\treturn wrapped;\n\t} else if (typeof fnOrObject === 'function') {\n\t\tvar fn = function() {\n\t\t\tvar future = new Future;\n\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\tif (multi) {\n\t\t\t\tvar cb = future.resolver();\n\t\t\t\targs.push(function(err) {\n\t\t\t\t\tcb(err, Array.prototype.slice.call(arguments, 1));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\targs.push(future.resolver());\n\t\t\t}\n\t\t\tfuture._ = fnOrObject.apply(this, args);\n\t\t\treturn future;\n\t\t}\n\t\t// Modules like `request` return a function that has more functions as properties. Handle this\n\t\t// in some kind of reasonable way.\n\t\tif (!stop) {\n\t\t\tvar proto = Object.create(fnOrObject);\n\t\t\tfor (var ii in fnOrObject) {\n\t\t\t\tif (fnOrObject.hasOwnProperty(ii) && fnOrObject[ii] instanceof Function) {\n\t\t\t\t\tproto[ii] = proto[ii];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfn.__proto__ = Future.wrap(proto, multi, suffix, true);\n\t\t}\n\t\treturn fn;\n\t}\n};\n\n/**\n * Wait on a series of futures and then return. If the futures throw an exception this function\n * /won't/ throw it back. You can get the value of the future by calling get() on it directly. If\n * you want to wait on a single future you're better off calling future.wait() on the instance.\n */\nFuture.wait = function wait(/* ... */) {\n\n\t// Normalize arguments + pull out a FiberFuture for reuse if possible\n\tvar futures = [], singleFiberFuture;\n\tfor (var ii = 0; ii < arguments.length; ++ii) {\n\t\tvar arg = arguments[ii];\n\t\tif (arg instanceof Future) {\n\t\t\t// Ignore already resolved fibers\n\t\t\tif (arg.isResolved()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Look for fiber reuse\n\t\t\tif (!singleFiberFuture && arg instanceof FiberFuture && !arg.started) {\n\t\t\t\tsingleFiberFuture = arg;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfutures.push(arg);\n\t\t} else if (arg instanceof Array) {\n\t\t\tfor (var jj = 0; jj < arg.length; ++jj) {\n\t\t\t\tvar aarg = arg[jj];\n\t\t\t\tif (aarg instanceof Future) {\n\t\t\t\t\t// Ignore already resolved fibers\n\t\t\t\t\tif (aarg.isResolved()) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Look for fiber reuse\n\t\t\t\t\tif (!singleFiberFuture && aarg instanceof FiberFuture && !aarg.started) {\n\t\t\t\t\t\tsingleFiberFuture = aarg;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfutures.push(aarg);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(aarg+ ' is not a future');\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(arg+ ' is not a future');\n\t\t}\n\t}\n\n\t// Resumes current fiber\n\tvar fiber = Fiber.current;\n\tif (!fiber) {\n\t\tthrow new Error('Can\\'t wait without a fiber');\n\t}\n\n\t// Resolve all futures\n\tvar pending = futures.length + (singleFiberFuture ? 1 : 0);\n\tfunction cb() {\n\t\tif (!--pending) {\n\t\t\tfiber.run();\n\t\t}\n\t}\n\tfor (var ii = 0; ii < futures.length; ++ii) {\n\t\tfutures[ii].resolve(cb);\n\t}\n\n\t// Reusing a fiber?\n\tif (singleFiberFuture) {\n\t\tsingleFiberFuture.started = true;\n\t\ttry {\n\t\t\tsingleFiberFuture.return(\n\t\t\t\tsingleFiberFuture.fn.apply(singleFiberFuture.context, singleFiberFuture.args));\n\t\t} catch(e) {\n\t\t\tsingleFiberFuture.throw(e);\n\t\t}\n\t\t--pending;\n\t}\n\n\t// Yield this fiber\n\tif (pending) {\n\t\tFiber.yield();\n\t}\n};\n\n/**\n * Return a Future that waits on an ES6 Promise.\n */\nFuture.fromPromise = function(promise) {\n\tvar future = new Future;\n\tpromise.then(function(val) {\n\t\tfuture.return(val);\n\t}, function(err) {\n\t\tfuture.throw(err);\n\t});\n\treturn future;\n};\n\nFuture.prototype = {\n\t/**\n\t * Return the value of this future. If the future hasn't resolved yet this will throw an error.\n\t */\n\tget: function() {\n\t\tif (!this.resolved) {\n\t\t\tthrow new Error('Future must resolve before value is ready');\n\t\t} else if (this.error) {\n\t\t\t// Link the stack traces up\n\t\t\tvar error = this.error;\n\t\t\tvar localStack = {};\n\t\t\tError.captureStackTrace(localStack, Future.prototype.get);\n\t\t\tvar futureStack = Object.getOwnPropertyDescriptor(error, 'futureStack');\n\t\t\tif (!futureStack) {\n\t\t\t\tfutureStack = Object.getOwnPropertyDescriptor(error, 'stack');\n\t\t\t\tif (futureStack) {\n\t\t\t\t\tObject.defineProperty(error, 'futureStack', futureStack);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (futureStack && futureStack.get) {\n\t\t\t\tObject.defineProperty(error, 'stack', {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\tvar stack = futureStack.get.apply(error);\n\t\t\t\t\t\tif (stack) {\n\t\t\t\t\t\t\tstack = stack.split('\\n');\n\t\t\t\t\t\t\treturn [stack[0]]\n\t\t\t\t\t\t\t\t.concat(localStack.stack.split('\\n').slice(1))\n\t\t\t\t\t\t\t\t.concat('    - - - - -')\n\t\t\t\t\t\t\t\t.concat(stack.slice(1))\n\t\t\t\t\t\t\t\t.join('\\n');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn localStack.stack;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tset: function(stack) {\n\t\t\t\t\t\tObject.defineProperty(error, 'stack', {\n\t\t\t\t\t\t\tvalue: stack,\n\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\tenumerable: false,\n\t\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow error;\n\t\t} else {\n\t\t\treturn this.value;\n\t\t}\n\t},\n\n\t/**\n\t * Mark this future as returned. All pending callbacks will be invoked immediately.\n\t */\n\t\"return\": function(value) {\n\t\tif (this.resolved) {\n\t\t\tthrow new Error('Future resolved more than once');\n\t\t}\n\t\tthis.value = value;\n\t\tthis.resolved = true;\n\n\t\tvar callbacks = this.callbacks;\n\t\tif (callbacks) {\n\t\t\tdelete this.callbacks;\n\t\t\tfor (var ii = 0; ii < callbacks.length; ++ii) {\n\t\t\t\ttry {\n\t\t\t\t\tvar ref = callbacks[ii];\n\t\t\t\t\tif (ref[1]) {\n\t\t\t\t\t\tref[1](value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tref[0](undefined, value);\n\t\t\t\t\t}\n\t\t\t\t} catch(ex) {\n\t\t\t\t\t// console.log('Resolve cb threw', String(ex.stack || ex.message || ex));\n\t\t\t\t\tprocess.nextTick(function() {\n\t\t\t\t\t\tthrow(ex);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Throw from this future as returned. All pending callbacks will be invoked immediately.\n\t */\n\t\"throw\": function(error) {\n\t\tif (this.resolved) {\n\t\t\tthrow new Error('Future resolved more than once');\n\t\t} else if (!error) {\n\t\t\tthrow new Error('Must throw non-empty error');\n\t\t}\n\t\tthis.error = error;\n\t\tthis.resolved = true;\n\n\t\tvar callbacks = this.callbacks;\n\t\tif (callbacks) {\n\t\t\tdelete this.callbacks;\n\t\t\tfor (var ii = 0; ii < callbacks.length; ++ii) {\n\t\t\t\ttry {\n\t\t\t\t\tvar ref = callbacks[ii];\n\t\t\t\t\tif (ref[1]) {\n\t\t\t\t\t\tref[0].throw(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tref[0](error);\n\t\t\t\t\t}\n\t\t\t\t} catch(ex) {\n\t\t\t\t\t// console.log('Resolve cb threw', String(ex.stack || ex.message || ex));\n\t\t\t\t\tprocess.nextTick(function() {\n\t\t\t\t\t\tthrow(ex);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * \"detach\" this future. Basically this is useful if you want to run a task in a future, you\n\t * aren't interested in its return value, but if it throws you don't want the exception to be\n\t * lost. If this fiber throws, an exception will be thrown to the event loop and node will\n\t * probably fall down.\n\t */\n\tdetach: function() {\n\t\tthis.resolve(function(err) {\n\t\t\tif (err) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Returns whether or not this future has resolved yet.\n\t */\n\tisResolved: function() {\n\t\treturn this.resolved === true;\n\t},\n\n\t/**\n\t * Returns a node-style function which will mark this future as resolved when called.\n\t */\n\tresolver: function() {\n\t\treturn function(err, val) {\n\t\t\tif (err) {\n\t\t\t\tthis.throw(err);\n\t\t\t} else {\n\t\t\t\tthis.return(val);\n\t\t\t}\n\t\t}.bind(this);\n\t},\n\n\t/**\n\t * Waits for this future to resolve and then invokes a callback.\n\t *\n\t * If two arguments are passed, the first argument is a future which will be thrown to in the case\n\t * of error, and the second is a function(val){} callback.\n\t *\n\t * If only one argument is passed it is a standard function(err, val){} callback.\n\t */\n\tresolve: function(arg1, arg2) {\n\t\tif (this.resolved) {\n\t\t\tif (arg2) {\n\t\t\t\tif (this.error) {\n\t\t\t\t\targ1.throw(this.error);\n\t\t\t\t} else {\n\t\t\t\t\targ2(this.value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ1(this.error, this.value);\n\t\t\t}\n\t\t} else {\n\t\t\t(this.callbacks = this.callbacks || []).push([arg1, arg2]);\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * Resolve only in the case of success\n\t */\n\tresolveSuccess: function(cb) {\n\t\tthis.resolve(function(err, val) {\n\t\t\tif (err) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcb(val);\n\t\t});\n\t\treturn this;\n\t},\n\n\t/**\n\t * Propogate results to another future.\n\t */\n\tproxy: function(future) {\n\t\tthis.resolve(function(err, val) {\n\t\t\tif (err) {\n\t\t\t\tfuture.throw(err);\n\t\t\t} else {\n\t\t\t\tfuture.return(val);\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Propogate only errors to an another future or array of futures.\n\t */\n\tproxyErrors: function(futures) {\n\t\tthis.resolve(function(err) {\n\t\t\tif (!err) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (futures instanceof Array) {\n\t\t\t\tfor (var ii = 0; ii < futures.length; ++ii) {\n\t\t\t\t\tfutures[ii].throw(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfutures.throw(err);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t},\n\n\t/**\n\t * Returns an ES6 Promise\n\t */\n\tpromise: function() {\n\t\tvar that = this;\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tthat.resolve(function(err, val) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(val);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * Differs from its functional counterpart in that it actually resolves the future. Thus if the\n\t * future threw, future.wait() will throw.\n\t */\n\twait: function() {\n\t\tif (this.isResolved()) {\n\t\t\treturn this.get();\n\t\t}\n\t\tFuture.wait(this);\n\t\treturn this.get();\n\t},\n};\n\n/**\n * A function call which loads inside a fiber automatically and returns a future.\n */\nfunction FiberFuture(fn, context, args) {\n\tthis.fn = fn;\n\tthis.context = context;\n\tthis.args = args;\n\tthis.started = false;\n\tvar that = this;\n\tprocess.nextTick(function() {\n\t\tif (!that.started) {\n\t\t\tthat.started = true;\n\t\t\tFiber(function() {\n\t\t\t\ttry {\n\t\t\t\t\tthat.return(fn.apply(context, args));\n\t\t\t\t} catch(e) {\n\t\t\t\t\tthat.throw(e);\n\t\t\t\t}\n\t\t\t}).run();\n\t\t}\n\t});\n}\nutil.inherits(FiberFuture, Future);\n"
        },
        {
          "name": "package-lock.json",
          "type": "blob",
          "size": 0.2802734375,
          "content": "{\n\t\"name\": \"fibers\",\n\t\"version\": \"5.0.1\",\n\t\"lockfileVersion\": 1,\n\t\"requires\": true,\n\t\"dependencies\": {\n\t\t\"detect-libc\": {\n\t\t\t\"version\": \"1.0.3\",\n\t\t\t\"resolved\": \"https://registry.npmjs.org/detect-libc/-/detect-libc-1.0.3.tgz\",\n\t\t\t\"integrity\": \"sha1-+hN8S9aY7fVc1c0CrFWfkaTEups=\"\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.6826171875,
          "content": "{\n\t\"name\": \"fibers\",\n\t\"version\": \"5.0.2\",\n\t\"description\": \"Cooperative multi-tasking for Javascript\",\n\t\"keywords\": [\n\t\t\"fiber\",\n\t\t\"fibers\",\n\t\t\"coroutine\",\n\t\t\"thread\",\n\t\t\"async\",\n\t\t\"parallel\",\n\t\t\"worker\",\n\t\t\"future\",\n\t\t\"promise\"\n\t],\n\t\"homepage\": \"https://github.com/laverdet/node-fibers\",\n\t\"author\": \"Marcel Laverdet <marcel@laverdet.com> (https://github.com/laverdet/)\",\n\t\"main\": \"fibers\",\n\t\"scripts\": {\n\t\t\"install\": \"node build.js || nodejs build.js\",\n\t\t\"test\": \"node test.js || nodejs test.js\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git://github.com/laverdet/node-fibers.git\"\n\t},\n\t\"license\": \"MIT\",\n\t\"engines\": {\n\t\t\"node\": \">=10.0.0\"\n\t},\n\t\"dependencies\": {\n\t\t\"detect-libc\": \"^1.0.3\"\n\t}\n}\n"
        },
        {
          "name": "quick-test.js",
          "type": "blob",
          "size": 0.1474609375,
          "content": "\"use strict\"\nvar Fiber = require('./fibers');\nvar fiber = Fiber(function() {\n\tprocess.stdout.write(Fiber.yield());\n});\nfiber.run();\nfiber.run('pass');\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.js",
          "type": "blob",
          "size": 1.4609375,
          "content": "#!/usr/bin/env node\nvar fs = require('fs');\nvar spawn = require('child_process').spawn;\nvar path = require('path');\n\nvar ret = 0;\nfunction runTest(test, cb) {\n\tvar env = {};\n\tfor (var ii in process.env) {\n\t\tenv[ii] = process.env[ii];\n\t}\n\tenv.NODE_PATH = __dirname;\n\tvar args = [];\n\tif (process.versions.modules >= 57 && process.versions.modules < 59) {\n\t\t// Node v8 requires forcing async hook checks. In Node v9 (>=59) and beyond,\n\t\t// async hooks checks are on by default (and the param no longer exists).\n\t\targs.push('--force-async-hooks-checks');\n\t}\n\targs.push(path.join('test', test));\n\tvar proc = spawn(process.execPath, args, { env: env });\n\tproc.stdout.setEncoding('utf8');\n\tproc.stderr.setEncoding('utf8');\n\n\tvar stdout = '', stderr = '';\n\tproc.stdout.on('data', function(data) {\n\t\tstdout += data;\n\t});\n\tproc.stderr.on('data', function(data) {\n\t\tstderr += data;\n\t});\n\tproc.stdin.end();\n\n\tproc.on('exit', function(code) {\n\t\tif (stdout !== 'pass\\n' || stderr !== '') {\n\t\t\tret = 1;\n\t\t\tconsole.error(\n\t\t\t\ttest+ ': *fail*\\n'+\n\t\t\t\t'code: '+ code+ '\\n'+\n\t\t\t\t'stderr: '+ stderr+ '\\n'+\n\t\t\t\t'stdout: '+ stdout\n\t\t\t);\n\t\t} else if (code !== 0) {\n\t\t\tret = 1;\n\t\t\tconsole.error(test+ ': fail ('+ code+ ')');\n\t\t} else {\n\t\t\tconsole.log(test+ ': '+ 'pass');\n\t\t}\n\t\tcb();\n\t});\n}\n\nvar cb = function() {\n\tprocess.exit(ret);\n};\nfs.readdirSync('./test').reverse().forEach(function(file) {\n\tcb = new function(cb) {\n\t\treturn function(err) {\n\t\t\tif (err) return cb(err);\n\t\t\trunTest(file, cb);\n\t\t};\n\t}(cb);\n});\ncb();\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}